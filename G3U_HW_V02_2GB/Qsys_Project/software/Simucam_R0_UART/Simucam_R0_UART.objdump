
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x00055218 memsz 0x0006f484 flags rwx
    LOAD off    0x00057000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00057000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004d2a8  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005f40  8114d504  8114d504  0004e504  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81153444  81153444  00054444  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a26c  81155238  81155238  00056238  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116f4a4  8116f4a4  00057000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00057000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00057000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d78  00000000  00000000  00057028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000733b2  00000000  00000000  00058da0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016ae9  00000000  00000000  000cc152  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002375a  00000000  00000000  000e2c3b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009a5c  00000000  00000000  00106398  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cc7f  00000000  00000000  0010fdf4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ee0  00000000  00000000  0011ca73  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  00143954  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000023a0  00000000  00000000  00143998  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00152259  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0015225f  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0015226b  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0015226c  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0015226d  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00152271  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00152275  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00152279  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00152284  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0015228e  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00152298  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003e  00000000  00000000  001522a9  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  001522e7  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114d504 l    d  .rodata	00000000 .rodata
81153444 l    d  .rwdata	00000000 .rwdata
81155238 l    d  .bss	00000000 .bss
8116f4a4 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811048d4 l     F .text	00000050 uliCommReadReg
81104880 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105220 l     F .text	00000050 uliDpktReadReg
811051cc l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8115525c l     O .bss	00000004 viCh1HoldContext
81155260 l     O .bss	00000004 viCh2HoldContext
81155264 l     O .bss	00000004 viCh3HoldContext
81155268 l     O .bss	00000004 viCh4HoldContext
8115526c l     O .bss	00000004 viCh5HoldContext
81155270 l     O .bss	00000004 viCh6HoldContext
81155274 l     O .bss	00000004 viCh7HoldContext
81155278 l     O .bss	00000004 viCh8HoldContext
811073e0 l     F .text	00000054 vFeebWriteReg
81107434 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8115527c l     O .bss	00000004 viCh1HoldContext
81155280 l     O .bss	00000004 viCh2HoldContext
81155284 l     O .bss	00000004 viCh3HoldContext
81155288 l     O .bss	00000004 viCh4HoldContext
8115528c l     O .bss	00000004 viCh5HoldContext
81155290 l     O .bss	00000004 viCh6HoldContext
81155294 l     O .bss	00000004 viCh7HoldContext
81155298 l     O .bss	00000004 viCh8HoldContext
8110a818 l     F .text	00000054 vRmapWriteReg
8110a8bc l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110b258 l     F .text	00000050 uliSpwcReadReg
8110b204 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81155160 l     O .rwdata	00000001 ucIoValue
8110b458 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110bd48 l     F .text	0000013c msgdma_write_extended_descriptor
8110be84 l     F .text	00000164 msgdma_construct_extended_descriptor
8110bfe8 l     F .text	00000348 msgdma_descriptor_async_transfer
8110c330 l     F .text	00000490 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110cf40 l     F .text	00000054 vRstcWriteReg
8110cf94 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
811552a0 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
811552a8 l     O .bss	00000004 pxNFee.5701
811552ac l     O .bss	00000004 incrementador.5706
811552b0 l     O .bss	00000004 tCodFeeTask.5704
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
811552b6 l     O .bss	00000004 xRAckLocal.5631
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
811552bc l     O .bss	00000004 bDmaBack.5672
811552c0 l     O .bss	00000001 ucWhoGetDMA.5673
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
811552c2 l     O .bss	00000004 xSAckLocal.5616
00000000 l    df *ABS*	00000000 parser_comm_task.c
8115543c l     O .bss	0000004c PreParsedLocal.5669
81155488 l     O .bss	00000054 xTcPusL.5668
00000000 l    df *ABS*	00000000 receiver_uart_task.c
811554dc l     O .bss	0000004c xPreParsedReader.5661
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81155528 l     O .bss	00000054 xPusLocal.5904
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81150d55 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 atoll.c
00000000 l    df *ABS*	00000000 ctype_.c
81152885 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81153444 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81124c34 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81152a52 l     O .rodata	00000010 zeroes.4389
81152a62 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81152a72 l     O .rodata	00000010 zeroes.4404
81129bb0 l     F .text	000000c4 __sbprintf
81152a82 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81152a9a l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8112b898 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112d3e8 l     F .text	00000008 __fp_unlock
8112d3fc l     F .text	000001a4 __sinit.part.1
8112d5a0 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81153c90 l     O .rwdata	00000020 lc_ctype_charset
81153c70 l     O .rwdata	00000020 lc_message_charset
81153cb0 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
81152ad8 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81130410 l     F .text	0000006c sulp
81152c20 l     O .rodata	00000014 fpi.2737
81152c34 l     O .rodata	00000028 tinytens
81152c0c l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81152c6c l     O .rodata	00000010 blanks.4332
81152c5c l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81133798 l     F .text	00000104 __sprint_r.part.0
81152c8c l     O .rodata	00000010 blanks.4348
81152c7c l     O .rodata	00000010 zeroes.4349
81134d34 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
811351e8 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
811383c4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81138508 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
8113853c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
811387c0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
811388b8 l       .text	00000000 tx_next_char
811388e0 l       .text	00000000 end_tx
811388c0 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
811393bc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81139638 l     F .text	00000044 alt_get_errno
8113967c l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
811398a4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
811551a8 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81139e44 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
811551b4 l     O .rwdata	00000004 lockid
81155384 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
811551b8 l     O .rwdata	00000004 lockid
8115538c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8113b8d0 l     F .text	00000050 OS_InitMisc
8113b920 l     F .text	00000074 OS_InitRdyList
8113baa4 l     F .text	000000ec OS_InitTCBList
8113b7e8 l     F .text	000000e8 OS_InitEventList
8113b994 l     F .text	00000088 OS_InitTaskIdle
8113ba1c l     F .text	00000088 OS_InitTaskStat
8113bd34 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113db4c l     F .text	000000fc OS_FlagTaskRdy
8113d8fc l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113f438 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81143e68 l     F .text	00000044 OSTmr_Lock
81143908 l     F .text	00000074 OSTmr_Alloc
81143eac l     F .text	0000003c OSTmr_Unlock
81143d6c l     F .text	000000fc OSTmr_Unlink
8114397c l     F .text	000000a4 OSTmr_Free
81143c1c l     F .text	00000150 OSTmr_Link
81143b94 l     F .text	00000088 OSTmr_InitTask
81143ee8 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81143ff8 l     F .text	0000003c alt_dev_reg
81153f2c l     O .rwdata	0000106c jtag_uart_0
81154f98 l     O .rwdata	000000d0 rs232_uart
81155068 l     O .rwdata	00000064 dma_DDR_M1
811550cc l     O .rwdata	00000064 dma_DDR_M2
81155130 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81148888 l     F .text	000002bc altera_avalon_jtag_uart_irq
81148b44 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81149348 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811496e0 l     F .text	000000a4 altera_avalon_uart_irq
81149784 l     F .text	00000140 altera_avalon_uart_rxirq
811498c4 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81149acc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81149d80 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
8114a004 l     F .text	00000044 alt_get_errno
8114a048 l     F .text	0000009c alt_msgdma_write_standard_descriptor
8114a0e4 l     F .text	00000134 alt_msgdma_write_extended_descriptor
8114a218 l     F .text	0000018c alt_msgdma_irq
8114a3a4 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
8114a438 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8114a594 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
8114a8d4 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
8114afdc l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
8114b088 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114c254 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114c898 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81155434 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81155438 g     O .bss	00000004 alt_instruction_exception_handler
81107944 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81155cbc g     O .bss	00001000 vFeeTask0_stk
81106d6c g     F .text	00000068 bFeebGetCh2LeftFeeBusy
8111d930 g     F .text	00000064 vFailDeleteInitialization
8111bf8c g     F .text	00000ff4 vLoadDebugConfs
81155408 g     O .bss	00000004 aux_status_register
81156cbc g     O .bss	00001000 vInAckHandlerTask_stk
8114c010 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81107c8c g     F .text	00000054 uliRmapCh1WriteCmdAddress
8110d5dc g     F .text	0000004c vSyncInitIrq
81118760 g     F .text	00000284 vCheckRetransmission128
8112fa94 g     F .text	0000007c _mprec_log10
8110d7e4 g     F .text	00000040 bSyncSetMbt
8111f434 g     F .text	0000006c vFailRequestDMAFromIRQ
8110b63c g     F .text	00000108 I2C_Read
81155206 g     O .rwdata	00000002 OSTaskNameSize
811552cc g     O .bss	00000004 xWaitSyncQFee
81157cbc g     O .bss	00000260 xBuffer64
8112fb88 g     F .text	0000008c __any_on
8112e55c g     F .text	0000005c _isatty_r
81152ae4 g     O .rodata	00000028 __mprec_tinytens
81107c34 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811394dc g     F .text	0000015c alt_main
81106a84 g     F .text	00000078 bFeebGetRightBufferEmpty
81124b58 g     F .text	000000c8 _puts_r
81105bd4 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81155394 g     O .bss	00000004 OSTmrFreeList
8116f3a4 g     O .bss	00000100 alt_irq
8112e6cc g     F .text	00000068 _lseek_r
81120888 g     F .text	00000030 vChangeDefaultAutoResetSync
8113e3ac g     F .text	000000d4 OS_MemInit
8111f3c8 g     F .text	0000006c vFailRequestDMA
81106afc g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
8111b21c g     F .text	00000a40 vLoadDefaultETHConf
811133d8 g     F .text	0000014c bCheckInAck64
81157f1c g     O .bss	00000150 xPus
81142e48 g     F .text	00000068 OSTimeSet
81117304 g     F .text	000000ac vPusType250run
8112d7a0 g     F .text	000000ac __sflags
8111ec1c g     F .text	00000080 vCoudlNotCreateNFee2Task
8111f0f8 g     F .text	00000064 vCouldNotGetMutexMebPus
81138068 g     F .text	00000088 .hidden __eqdf2
81117aa0 g     F .text	00000088 vSendCmdQToDataCTRL
81102ae0 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81120774 g     F .text	00000034 vLoadDefaultSyncSource
8111d248 g     F .text	00000064 vFailCreateMutexDMA
811444f8 g     F .text	000001ac Check_for_Master_Boot_Record
81168db8 g     O .bss	00000010 OSTmrWheelTbl
81107d34 g     F .text	00000054 uliRmapCh3WriteCmdAddress
8114ad9c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8115806c g     O .bss	00000020 xFeeQueueTBL3
8113a534 g     F .text	00000594 OSEventPendMulti
811552d0 g     O .bss	00000004 xNfeeSchedule
8116f4a4 g       *ABS*	00000000 __alt_heap_start
8114ced0 g     F .text	0000002c OSTaskCreateHook
81148370 g     F .text	000001c4 alt_up_sd_card_fclose
811552d4 g     O .bss	00000004 xSemCountBuffer64
811045b4 g     F .text	000001b8 bCommSetGlobalIrqEn
811081a0 g     F .text	00000088 bRmapGetIrqControl
8115529d g     O .bss	00000001 SspdConfigControl
8110dc00 g     F .text	00000054 bSyncCtrReset
811551de g     O .rwdata	00000002 OSMboxEn
81111358 g     F .text	00000584 vQCmdFeeRMAPWaitingSync
81121314 g     F .text	000000a4 aatoh
8113ab2c g     F .text	00000054 OSIntEnter
81135e54 g     F .text	000000a4 _wcrtomb_r
81105ae0 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111d868 g     F .text	00000064 vFailReceiverCreate
811552d8 g     O .bss	00000004 xQMaskDataCtrl
81105434 g     F .text	000000b0 vFeebCh2HandleIrq
811250c0 g     F .text	00000064 __sseek
8112d750 g     F .text	00000010 __sinit
8110c880 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8112b518 g     F .text	00000148 __swbuf_r
81118f38 g     F .text	00000470 bResourcesInitRTOS
8110ad40 g     F .text	000000f4 bSpwcGetLinkError
811551ee g     O .rwdata	00000002 OSQEn
811106f0 g     F .text	00000684 vQCmdFeeRMAPinStandBy
81107694 g     F .text	00000038 vRmapCh4HandleIrq
8112e5e8 g     F .text	00000084 _setlocale_r
8115808c g     O .bss	00000020 SyncTBL2
81155164 g     O .rwdata	00000004 LedsPainelControl
811555a4 g     O .bss	00000100 cDebugBuffer
8112d5a8 g     F .text	00000070 __sfmoreglue
81133780 g     F .text	00000018 ungetc
81105de4 g     F .text	000000e0 bFeebCh1SetBufferSize
8113a1f0 g     F .text	000000d4 __malloc_unlock
81102ddc g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114cf50 g     F .text	00000028 OSTaskStatHook
811178fc g     F .text	00000088 vSendCmdQToNFeeCTRL
811207e4 g     F .text	00000030 vChangeDefaultSyncSource
81155398 g     O .bss	00000001 OSLockNesting
8115539c g     O .bss	00000004 OSTmrSemSignal
8111f968 g     F .text	00000294 vNFeeStructureInit
811552dc g     O .bss	00000004 xSemCommInit
81102964 g     F .text	00000080 uliXorshift32
8113047c g     F .text	00001600 _strtod_r
811552e0 g     O .bss	00000004 xSemCountSenderACK
811214e4 g     F .text	00000448 .hidden __divsf3
8115542c g     O .bss	00000004 current_sector_modified
8115522c g     O .rwdata	00000002 OSDataSize
811553a0 g     O .bss	00000001 OSRunning
8110b020 g     F .text	000001e4 bSpwcInitCh
811391a4 g     F .text	00000064 alt_log_jtag_uart_isr_proc
811580ac g     O .bss	00001000 senderTask_stk
81108ce0 g     F .text	00000094 bRmapGetMemConfigStat
811552e4 g     O .bss	00000004 fp
811590ac g     O .bss	00000048 xNfeeScheduleTBL
81113290 g     F .text	00000148 bCheckInAck128
8112ea5c g     F .text	0000015c memmove
8114cfcc g     F .text	0000002c OSInitHookBegin
8110e09c g     F .text	00000074 bSyncCtrCh8OutEnable
81111a48 g     F .text	00000098 bEnableDbBuffer
81155224 g     O .rwdata	00000002 OSTmrSize
8112d738 g     F .text	00000018 _cleanup
81120ca4 g     F .text	00000040 siCloseFile
811071fc g     F .text	000001e4 bFeebInitCh
8112ebb8 g     F .text	000000b0 _Balloc
81120814 g     F .text	00000038 vLoadDefaultAutoResetSync
811082b0 g     F .text	000000dc bRmapSetCodecConfig
81146f4c g     F .text	000000cc alt_up_sd_card_is_Present
8114acdc g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81155240 g     O .bss	00000004 pxDmaM1Dev
81102b78 g     F .text	000000a8 DMA_DISPATCHER_STOP
81144220 g     F .text	00000054 Save_Modified_Sector
81105d34 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
811553a4 g     O .bss	00000004 OSIdleCtr
81155360 g     O .bss	00000001 alt_log_write_on_flag
8110b2a8 g     F .text	0000003c bEnableIsoDrivers
81121f54 g     F .text	000000dc .hidden __gtdf2
8114cc60 g     F .text	0000002c altera_nios2_gen2_irq_init
8114cd48 g       .text	00000000 OSStartTsk
8110d958 g     F .text	00000070 bSyncSetNCycles
8113c0a4 g     F .text	000002dc OS_TCBInit
81155363 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
811203f4 g     F .text	00000080 vInitSimucamBasicHW
811590f4 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110dfb4 g     F .text	00000074 bSyncCtrCh6OutEnable
8110b9b8 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81155424 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
811553a8 g     O .bss	00000002 OSTmrUsed
811552e8 g     O .bss	00000004 xSemCountBuffer128
811032b8 g     F .text	000000f8 TEMP_Read
811080f4 g     F .text	000000ac bRmapSetIrqControl
81106164 g     F .text	000000e0 bFeebCh5SetBufferSize
8115a0f4 g     O .bss	00001000 vDataControlTask_stk
81105594 g     F .text	000000b0 vFeebCh4HandleIrq
8115522a g     O .rwdata	00000002 OSTmrWheelTblSize
8112009c g     F .text	0000002c cFeeSpwChannelDisable
811551ca g     O .rwdata	00000002 OSEventSize
811553aa g     O .bss	00000001 OSPrioHighRdy
81123bb4 g     F .text	00000064 _fstat_r
8114cefc g     F .text	0000002c OSTaskDelHook
8115533c g     O .bss	00000004 errno
8110e390 g     F .text	0000003c uliSyncGetCtr
8112b4a8 g     F .text	0000001c __svfscanf
81125034 g     F .text	00000008 __seofread
8114cd28 g       .text	00000000 OSStartHighRdy
8111f8c8 g     F .text	00000028 vEvtChangeFeeControllerMode
81111c94 g     F .text	00000968 vPrintConsoleNFee
811143b8 g     F .text	000000c8 bSendCmdQToNFeeInst
8110773c g     F .text	00000038 vRmapCh7HandleIrq
81141878 g     F .text	000001ec OSTaskCreateExt
81168d8c g     O .bss	00000011 alt_log_write_buf
81104bc8 g     F .text	00000158 bDpktGetPacketConfig
81107ed8 g     F .text	00000054 uliRmapCh8WriteCmdAddress
8111dd14 g     F .text	00000080 vFailGetCountSemaphorePreParsedBuffer
811322c4 g     F .text	00001244 ___svfiprintf_internal_r
811161a0 g     F .text	0000037c bPreParserV2
8113d42c g     F .text	00000068 OSFlagPendGetFlagsRdy
8115520a g     O .rwdata	00000002 OSTaskStatStkSize
81106c34 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
8113c578 g     F .text	00000310 OSFlagAccept
8113fb54 g     F .text	000000c0 OSQFlush
81155aa4 g     O .bss	00000118 xRmap
8113f5d0 g     F .text	00000148 OSQAccept
81155374 g     O .bss	00000004 alt_argv
8115d15c g       *ABS*	00000000 _gp
8111d458 g     F .text	00000064 vFailSendPreAckReceiverSemaphore
81139d08 g     F .text	0000013c usleep
81147524 g     F .text	00000384 alt_up_sd_card_fopen
81120b10 g     F .text	00000030 bSDcardIsPresent
8111651c g     F .text	00000210 vSenderComTask
8114708c g     F .text	000000d8 alt_up_sd_card_find_first
811416c4 g     F .text	000001b4 OSTaskCreate
8111df14 g     F .text	00000080 vFailSendNack
81155418 g     O .bss	00000004 command_argument_register
811411cc g     F .text	000004f8 OSTaskChangePrio
81116e04 g     F .text	000000c4 vPusMebInTaskConfigMode
8111e86c g     F .text	000000a0 vCouldNotSendTMPusCommand
81155390 g     O .bss	00000004 alt_heapsem
8111ff3c g     F .text	000000b0 vResetMemCCDFEE
8110bc50 g     F .text	00000080 bSetBoardLeds
8113c380 g     F .text	000001f8 OSDebugInit
81141a64 g     F .text	0000034c OSTaskDel
8113e480 g     F .text	000001ac OSMutexAccept
8115b0f4 g     O .bss	000002c0 xSimMeb
811202d8 g     F .text	00000040 vSetTimeCode
8114b884 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
811552ec g     O .bss	00000004 xSemCountPreParsed
81153d10 g     O .rwdata	00000180 alt_fd_list
81105c84 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81153eac g     O .rwdata	0000001d alt_log_msg_alt_main
81168dc8 g     O .bss	00000840 OSFlagTbl
811079cc g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111d620 g     F .text	00000080 vFailGetCountSemaphoreReceiverTask
81107ddc g     F .text	00000054 uliRmapCh5WriteCmdAddress
811206cc g     F .text	0000003c vLoadDefaultRTValue
8113b5b0 g     F .text	000000c0 OS_EventTaskRemove
8115b3b4 g     O .bss	00001000 vFeeTask5_stk
81155362 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
811467a0 g     F .text	00000134 find_first_empty_record_in_root_directory
8114c344 g     F .text	00000098 alt_find_dev
81124700 g     F .text	00000150 memcpy
81135b20 g     F .text	00000264 __hexnan
81104ffc g     F .text	000001d0 bDpktInitCh
8115c3b4 g     O .bss	00000160 xBuffer32
811551f4 g     O .rwdata	00000002 OSRdyTblSize
81169608 g     O .bss	000001a0 OSTmrTbl
8112d3f0 g     F .text	0000000c _cleanup_r
811230d4 g     F .text	000000e4 .hidden __floatsidf
8111ae44 g     F .text	000001a8 vSendPusTM64
8110d754 g     F .text	0000004c ucSyncStatusErrorCode
81117a0c g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
81120198 g     F .text	00000034 cFeeRMAPLogDisable
81114870 g     F .text	00000fc0 vParserCommTask
8114c964 g     F .text	00000084 alt_io_redirect
8112012c g     F .text	00000034 cFeeRMAPEchoingDisable
811380f0 g     F .text	000000f4 .hidden __ltdf2
8111f014 g     F .text	00000064 vFailSendPUStoMebTask
81107bdc g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811066ac g     F .text	000000d8 bFeebSetIrqControl
8111e5ec g     F .text	00000080 vCouldNotRetransmitB128TimeoutTask
811552f0 g     O .bss	00000004 xMutexReceivedACK
81103c40 g     F .text	000000c4 bSdmaInitM2Dma
81155258 g     O .bss	00000004 EDpktMode
8114bd0c g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114c054 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110dca8 g     F .text	00000054 bSyncCtrErrInj
8114bfb4 g     F .text	0000005c alt_msgdma_register_callback
8111bc5c g     F .text	00000330 vShowEthConfig
81120474 g     F .text	00000030 bLogWriteSDCard
8111da14 g     F .text	00000080 vFailSetCountSemaphorexBuffer64
81124c20 g     F .text	00000014 puts
81120d24 g     F .text	000001b8 bInitSync
8114d074 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110d4a4 g     F .text	0000010c vSyncHandleIrq
8113a2c4 g     F .text	00000128 OSEventNameGet
81105948 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
811551d8 g     O .rwdata	00000002 OSFlagMax
8112e7e8 g     F .text	000000e0 mbrtowc
81146398 g     F .text	000001b4 find_first_empty_cluster
81117b28 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110df40 g     F .text	00000074 bSyncCtrCh5OutEnable
811552a4 g     O .bss	00000001 vucN
811301e8 g     F .text	00000074 __fpclassifyd
8110d6b4 g     F .text	00000054 bSyncStatusExtnIrq
8112b4c4 g     F .text	00000054 _vfscanf_r
8113eb00 g     F .text	000005a4 OSMutexPend
8112f9e8 g     F .text	000000ac __ratio
81146e88 g     F .text	000000c4 alt_up_sd_card_open_dev
8111e90c g     F .text	00000080 vWarnCouldNotgetMutexRetrans128
8113ab80 g     F .text	00000100 OSIntExit
8110d824 g     F .text	00000040 bSyncSetBt
81134d18 g     F .text	0000001c __vfiprintf_internal
8111f15c g     F .text	00000080 vCouldNotCreateQueueMaskNfeeCtrl
81155212 g     O .rwdata	00000002 OSTCBSize
81105904 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
811553ab g     O .bss	00000001 OSPrioCur
81148db8 g     F .text	000002c4 altera_avalon_jtag_uart_read
8114b54c g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81136c0c g     F .text	00000064 .hidden __udivsi3
81138804 g     F .text	000000ac isatty
8115529c g     O .bss	00000001 LedsBoardControl
811552f4 g     O .bss	00000004 xSemCountReceivedACK
811551f8 g     O .rwdata	00000002 OSStkWidth
8112e5b8 g     F .text	00000030 iswspace
81152b34 g     O .rodata	000000c8 __mprec_tens
811551ec g     O .rwdata	00000002 OSPtrSize
8111f4a0 g     F .text	0000006c vFailSendRMAPFromIRQ
8111ee1c g     F .text	00000080 vCoudlNotCreateNFeeControllerTask
8112e66c g     F .text	0000000c __locale_charset
8110de58 g     F .text	00000074 bSyncCtrCh3OutEnable
811254b0 g     F .text	0000001c strtoll
81136dfc g     F .text	000000c8 .hidden __lesf2
811551cc g     O .rwdata	00000002 OSEventTblSize
81121468 g     F .text	0000007c .hidden __fixunsdfsi
8114cc8c g       .text	00000000 OSCtxSw
8110b744 g     F .text	00000160 I2C_MultipleRead
81139348 g     F .text	00000074 alt_log_system_clock
81155348 g     O .bss	00000004 __malloc_top_pad
811553ac g     O .bss	00000004 OSTCBList
811438c8 g     F .text	00000040 OSTmrSignal
81155358 g     O .bss	00000004 alt_fd_list_lock
81131df0 g     F .text	0000001c strtoul
8115517c g     O .rwdata	00000004 __mb_cur_max
8112e69c g     F .text	0000000c _localeconv_r
81131e0c g     F .text	000002e0 _strtoull_r
8110ced0 g     F .text	00000070 vRstcHoldDeviceReset
8112efdc g     F .text	00000044 __i2b
8112df00 g     F .text	000004c4 __sfvwrite_r
81145678 g     F .text	000000c0 get_dir_divider_location
81107878 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
811697a8 g     O .bss	00000c30 OSMemTbl
811553b0 g     O .bss	00000001 OSTickStepState
81138f58 g     F .text	00000060 alt_log_printf_proc
81104f38 g     F .text	000000c4 bDpktGetPixelDelay
8115c514 g     O .bss	00001800 vReceiverUartTask_stk
81124e2c g     F .text	0000005c _sbrk_r
811552f8 g     O .bss	00000004 xSemTimeoutChecker
81145338 g     F .text	000000cc filename_to_upper_case
81155364 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
811551f0 g     O .rwdata	00000002 OSQMax
811478a8 g     F .text	00000090 alt_up_sd_card_set_attributes
8113e7fc g     F .text	00000304 OSMutexDel
8116a3d8 g     O .bss	00001000 OSTaskStatStk
81120b40 g     F .text	00000030 bSDcardFAT16Check
8113dfc8 g     F .text	000000f8 OSMemNameGet
8111d1d0 g     F .text	00000078 vFailCreateMutexSResources
811446a4 g     F .text	00000284 Read_File_Record_At_Offset
8115dd14 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
811551d0 g     O .rwdata	00000002 OSFlagEn
8112fc14 g     F .text	00000068 _read_r
81155216 g     O .rwdata	00000002 OSTimeTickHookEn
8113dc48 g     F .text	000000ac OS_FlagUnlink
8114001c g     F .text	00000170 OSQPost
811024c0 g     F .text	000004a4 bDdr2MemoryRandomReadTest
81155198 g     O .rwdata	00000004 alt_max_fd
8111e308 g     F .text	00000064 vFailTimeoutCheckerTaskCreate
8113bbec g     F .text	00000070 OS_MemCopy
8113bc5c g     F .text	000000d8 OS_Sched
81145f1c g     F .text	0000047c find_file_in_directory
81134ec4 g     F .text	000000f8 _fclose_r
8113ded0 g     F .text	000000f8 OSMemGet
811420a8 g     F .text	000001bc OSTaskNameSet
8112d3b8 g     F .text	00000030 fflush
81155344 g     O .bss	00000004 __malloc_max_sbrked_mem
811553b4 g     O .bss	00000004 OSCtxSwCtr
81106244 g     F .text	000000e0 bFeebCh6SetBufferSize
8114cf78 g     F .text	00000054 OSTimeTickHook
8115dd54 g     O .bss	00001000 vOutAckHandlerTask_stk
81138638 g     F .text	00000188 alt_irq_register
811551da g     O .rwdata	00000002 OSFlagNameSize
811231b8 g     F .text	00000118 .hidden __extendsfdf2
8113b670 g     F .text	00000108 OS_EventTaskRemoveMulti
8111ea94 g     F .text	00000088 vFailCreateNFEESyncQueue
81147018 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110b4d4 g     F .text	00000088 I2C_TestAdress
81136ec4 g     F .text	000008b4 .hidden __adddf3
81168da0 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81136cc8 g     F .text	00000078 .hidden __nesf2
81107834 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811052fc g     F .text	0000008c usiLineTrDelayCalcPeriodNs
8113b458 g     F .text	00000158 OS_EventTaskWaitMulti
8115ed54 g     O .bss	00000020 SyncTBL4
8112f780 g     F .text	00000114 __b2d
8114b284 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
811551f2 g     O .rwdata	00000002 OSQSize
811365d4 g     F .text	00000540 .hidden __umoddi3
81139400 g     F .text	000000dc lseek
81140b0c g     F .text	00000214 OSSemPend
8111f078 g     F .text	00000080 vCouldNotGetCmdQueueMeb
81108418 g     F .text	00000160 bRmapGetCodecStatus
8110ae34 g     F .text	000000d0 bSpwcGetLinkStatus
81106fd0 g     F .text	00000088 bFeebGetWindowing
8115516c g     O .rwdata	00000004 _global_impure_ptr
8110d458 g     F .text	0000004c bSSDisplayUpdate
81123500 g     F .text	0000000c _atoll_r
811459dc g     F .text	00000540 get_home_directory_cluster_for_file
8112fc7c g     F .text	0000056c _realloc_r
811551dc g     O .rwdata	00000002 OSLowestPrio
8116f4a4 g       *ABS*	00000000 __bss_end
8114c7a0 g     F .text	000000f8 alt_iic_isr_register
8114d048 g     F .text	0000002c OSTCBInitHook
81155222 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81139bf8 g     F .text	00000110 alt_tick
81107f2c g     F .text	000001c8 vRmapInitIrq
8111d5a0 g     F .text	00000080 vFailGetMutexSenderTask
8110cdf0 g     F .text	0000006c vRstcSimucamReset
81111b4c g     F .text	000000a4 bSendRequestNFeeCtrl
81152c9c g     O .rodata	00000100 __hexdig
8114be00 g     F .text	000001b4 alt_msgdma_init
81136054 g     F .text	00000580 .hidden __udivdi3
81115e70 g     F .text	0000017c setPreAckSenderFreePos
8113513c g     F .text	00000024 _fputwc_r
811551c4 g     O .rwdata	00000002 OSEventEn
81152b0c g     O .rodata	00000028 __mprec_bigtens
8112edb8 g     F .text	0000010c __s2b
8115521e g     O .rwdata	00000002 OSTmrCfgNameSize
8115ed74 g     O .bss	00000020 xFeeQueueTBL4
8110d8e4 g     F .text	00000074 bSyncSetPolarity
811189e4 g     F .text	0000028c vCheckRetransmission64
811381e4 g     F .text	000000b0 .hidden __floatunsidf
81155368 g     O .bss	00000004 alt_system_clock_in_sec
81139150 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111dc94 g     F .text	00000080 vFailFoundBufferRetransmission
8112f4b8 g     F .text	00000060 __mcmp
81155430 g     O .bss	00000004 current_sector_index
81149578 g     F .text	00000168 altera_avalon_uart_init
8114c0dc g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
81104158 g     F .text	0000045c bSdmaDmaM2Transfer
81120318 g     F .text	00000034 vResetTimeCode
81120070 g     F .text	0000002c cFeeSpwChannelEnable
8112d770 g     F .text	00000018 __fp_lock_all
8111f6ac g     F .text	00000064 vFailSendMsgDataCTRL
8114c74c g     F .text	00000054 alt_ic_irq_enabled
8110b55c g     F .text	000000e0 I2C_Write
81107a7c g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
811553b8 g     O .bss	00000002 OSTmrFree
8113da64 g     F .text	000000e8 OS_FlagInit
81139b54 g     F .text	000000a4 alt_alarm_stop
81125494 g     F .text	0000001c strtol
81155361 g     O .bss	00000001 alt_log_sys_clk_on_flag
81143074 g     F .text	00000140 OSTmrDel
81144410 g     F .text	000000e8 mark_cluster
81155200 g     O .rwdata	00000002 OSTaskIdleStkSize
8115535c g     O .bss	00000004 alt_irq_active
8114072c g     F .text	000000b8 OSSemAccept
8112374c g     F .text	0000044c _fseeko_r
811198dc g     F .text	00000354 vFillMemmoryPattern
81125210 g     F .text	00000044 strnlen
8113e1dc g     F .text	000000e0 OSMemPut
8113dcf4 g     F .text	000001dc OSMemCreate
811553bc g     O .bss	00000004 OSIdleCtrMax
8111afec g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
811389a0 g     F .text	000005b8 alt_log_private_printf
81153ce8 g     O .rwdata	00000028 alt_dev_null
8114ae94 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110d8a4 g     F .text	00000040 bSyncSetOst
81155214 g     O .rwdata	00000002 OSTicksPerSec
81153e90 g     O .rwdata	00000019 alt_log_msg_bss
811468d4 g     F .text	00000194 convert_filename_to_name_extension
81108d74 g     F .text	000010cc bRmapSetRmapMemHKArea
81106e3c g     F .text	000000e8 bFeebSetBufferSize
8111672c g     F .text	0000057c vSimMebTask
8110b8a4 g     F .text	00000094 i2c_start
8114cc8c g       .text	00000000 OSIntCtxSw
8111f50c g     F .text	0000006c vFailSendMsgSync
8110decc g     F .text	00000074 bSyncCtrCh4OutEnable
8114bc78 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811384e0 g     F .text	00000028 alt_dcache_flush_all
8112eec4 g     F .text	00000068 __hi0bits
811173b0 g     F .text	0000012c vPusType251run
81107e30 g     F .text	00000054 uliRmapCh6WriteCmdAddress
81120708 g     F .text	0000003c vChangeRTValue
81155404 g     O .bss	00000004 is_sd_card_formated_as_FAT16
811185bc g     F .text	000001a4 vCheck
8111f918 g     F .text	00000050 vNFeeNotInUse
81123054 g     F .text	00000080 .hidden __fixdfsi
81114480 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81106404 g     F .text	000000e0 bFeebCh8SetBufferSize
811070e4 g     F .text	0000008c bFeebStopCh
8110e4bc g     F .text	00000084 uliPerCalcPeriodMs
81113cfc g     F .text	00000450 vNFeeControlTask
8115ed94 g     O .bss	00001000 vInitialTask_stk
811552fc g     O .bss	00000002 usiIdCMD
8115fd94 g     O .bss	00000020 SyncTBL3
8110dbac g     F .text	00000054 bSyncCtrStart
8114654c g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81131a7c g     F .text	00000018 strtod
81107170 g     F .text	0000008c bFeebClrCh
811553c0 g     O .bss	00000004 OSTCBFreeList
81107b84 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
81140d20 g     F .text	00000174 OSSemPendAbort
8111d7a0 g     F .text	00000064 vFailGetMacRTC
81107d88 g     F .text	00000054 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111e240 g     F .text	00000064 vFailCreateTimerRetransmisison
8111dc14 g     F .text	00000080 vFailGetCountSemaphorexBuffer32
81119e24 g     F .text	00000320 bSendUART128v2
8112053c g     F .text	000000ec vSimucamStructureInit
81155190 g     O .rwdata	00000008 alt_dev_list
8112367c g     F .text	0000004c _fputc_r
81139e88 g     F .text	0000010c write
811249e0 g     F .text	000000a8 _putc_r
81155428 g     O .bss	00000004 device_pointer
81155218 g     O .rwdata	00000002 OSVersionNbr
81136d40 g     F .text	000000bc .hidden __gtsf2
8111f7d8 g     F .text	00000064 vFailFlushMEBQueue
81115830 g     F .text	00000118 getPreParsedPacket
811119e8 g     F .text	00000060 bEnableSPWChannel
81138580 g     F .text	000000b8 fstat
81120380 g     F .text	00000040 vChangeIdNFEEMaster
81123650 g     F .text	0000002c fprintf
81120160 g     F .text	00000038 cFeeRMAPLogEnable
81102cc8 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105cdc g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111e3ec g     F .text	00000080 vFailPostBlockingSemTimeoutTask
81120fdc g     F .text	00000058 _reg_write
811203c0 g     F .text	00000034 vChangeDefaultIdNFEEMaster
811380f0 g     F .text	000000f4 .hidden __ledf2
811076cc g     F .text	00000038 vRmapCh5HandleIrq
811118dc g     F .text	00000054 bDisableRmapIRQ
8115fdb4 g     O .bss	00001000 vStackMonitor_stk
8111e7ec g     F .text	00000080 vCouldNotSendLog
811432f4 g     F .text	000001b8 OSTmrRemainGet
811551c0 g     O .rwdata	00000004 OSEndiannessTest
8110cfe4 g     F .text	00000058 v_spi_start
8112f220 g     F .text	00000148 __pow5mult
81107ce0 g     F .text	00000054 uliRmapCh2WriteCmdAddress
811338b4 g     F .text	00001464 ___vfiprintf_internal_r
81155354 g     O .bss	00000004 __nlocale_changed
81136c70 g     F .text	00000058 .hidden __umodsi3
8110dcfc g     F .text	00000074 bSyncCtrSyncOutEnable
81120b70 g     F .text	000000f8 bInitializeSDCard
8111e114 g     F .text	00000064 vFailParserCommTaskCreate
8111e76c g     F .text	00000080 vCouldNotSendReset
81124ecc g     F .text	00000038 _scanf_r
8111e1dc g     F .text	00000064 vFailOutAckHandlerTaskCreate
811551d2 g     O .rwdata	00000002 OSFlagGrpSize
81116ec8 g     F .text	000000ac vPusType250conf
81160db4 g     O .bss	00000058 xInUseRetrans
8110d664 g     F .text	00000050 bSyncIrqFlagSync
8114b2e4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
811434ac g     F .text	000000ec OSTmrStateGet
8116f4a4 g       *ABS*	00000000 end
811056f4 g     F .text	000000b0 vFeebCh6HandleIrq
8111de14 g     F .text	00000080 vNoContentInPreParsedBuffer
81123b98 g     F .text	0000001c fseeko
81115948 g     F .text	00000168 bSendMessagePUStoMebTask
8111ea0c g     F .text	00000088 vFailCreateNFEEQueue
811234e8 g     F .text	0000000c _atoi_r
81149dc4 g     F .text	00000240 altera_avalon_uart_write
811388e4 g     F .text	00000054 alt_log_txchar
81123730 g     F .text	0000001c fseek
81119d94 g     F .text	00000090 vCCDChangeValues
811486b8 g     F .text	000001d0 altera_avalon_jtag_uart_init
8113beec g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111d310 g     F .text	00000064 vFailTestCriticasParts
81106d04 g     F .text	00000068 bFeebGetCh1RightFeeBusy
811fa000 g       *ABS*	00000000 __alt_stack_pointer
81102048 g     F .text	00000478 bDdr2MemoryRandomWriteTest
811493cc g     F .text	00000084 alt_avalon_timer_sc_init
81106f24 g     F .text	000000ac bFeebSetWindowing
811494b8 g     F .text	00000068 altera_avalon_uart_write_fd
81123478 g     F .text	00000064 .hidden __clzsi2
81149520 g     F .text	00000058 altera_avalon_uart_close_fd
81160e0c g     O .bss	00000020 xMebQTBL
8114907c g     F .text	000002cc altera_avalon_jtag_uart_write
81143a20 g     F .text	00000174 OSTmr_Init
81160e2c g     O .bss	00000348 xBuffer128
8112d760 g     F .text	00000004 __sfp_lock_acquire
811033b0 g     F .text	00000048 sense_log_temp
8112e978 g     F .text	000000e4 memchr
8113bb90 g     F .text	0000005c OS_MemClr
81127994 g     F .text	00002200 ___vfprintf_internal_r
8114cd6c g     F .text	00000164 OSTaskStkInit
81124f04 g     F .text	00000060 _sprintf_r
81108a0c g     F .text	000002d4 bRmapGetMemConfigArea
811552fe g     O .bss	00000001 SemCount32
8112dbe8 g     F .text	00000318 _free_r
8114c9e8 g     F .text	00000234 alt_printf
8111adf4 g     F .text	00000050 vTimeoutCheck
8112108c g     F .text	00000214 _print_codec_status
8112e678 g     F .text	00000010 __locale_mb_cur_max
8113b1a0 g     F .text	000001a0 OS_EventTaskRdy
81108228 g     F .text	00000088 bRmapGetIrqFlags
81102c20 g     F .text	000000a8 DMA_DISPATCHER_RESET
8114d2c0 g     F .text	00000188 __call_exitprocs
81114250 g     F .text	00000168 vPerformActionNFCRunning
811553c4 g     O .bss	00000001 OSCPUUsage
8111ed1c g     F .text	00000080 vCoudlNotCreateNFee4Task
81155350 g     O .bss	00000004 __mlocale_changed
8111414c g     F .text	00000104 vPerformActionNFCConfig
8110dc54 g     F .text	00000054 bSyncCtrOneShot
81155174 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110e3cc g     F .text	0000003c uliSyncReadStatus
8115537c g     O .bss	00000004 _alt_tick_rate
8113fc14 g     F .text	00000294 OSQPend
811254cc g     F .text	000002e8 _strtoll_r
81161174 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81168d3c g     O .bss	00000034 xDefaults
81142998 g     F .text	0000010c OSTimeDly
81117240 g     F .text	000000c4 vPusMebInTaskRunningMode
8110d628 g     F .text	0000003c vSyncIrqFlagClrSync
8112f368 g     F .text	00000150 __lshift
81114548 g     F .text	00000328 vOutAckHandlerTask
8114ad3c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81155380 g     O .bss	00000004 _alt_nticks
811398e8 g     F .text	00000104 read
81144074 g     F .text	000000f0 alt_sys_init
81121d30 g     F .text	0000012c .hidden __floatsisf
811077f0 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
811320ec g     F .text	000001d8 __ssprint_r
81124978 g     F .text	00000068 _open_r
81120f7c g     F .text	00000060 bTestSimucamCriticalHW
811068b8 g     F .text	00000154 bFeebGetBuffersStatus
8111cf80 g     F .text	000000a4 ucCrc8
81100824 g     F .text	00000cbc bDdr2EepromDump
811553c5 g     O .bss	00000001 OSTaskCtr
811388b0 g       .text	00000000 tx_log_str
81116ca8 g     F .text	0000015c vPusMebTask
8111ada4 g     F .text	00000050 siPosStr
81117984 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81135d84 g     F .text	000000d0 strncmp
8110e408 g     F .text	0000005c bSyncWriteReg
81107b2c g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81142aa4 g     F .text	00000164 OSTimeDlyHMSM
8112f020 g     F .text	00000200 __multiply
81148c50 g     F .text	00000070 altera_avalon_jtag_uart_close
8110d1b4 g     F .text	00000058 v_spi_end
81120ce4 g     F .text	00000040 cGetNextChar
8114d1d4 g     F .text	000000ec strncpy
8115557c g     O .bss	00000028 __malloc_current_mallinfo
811551c6 g     O .rwdata	00000002 OSEventMax
81136cc8 g     F .text	00000078 .hidden __eqsf2
8112f894 g     F .text	00000154 __d2b
81140e94 g     F .text	00000118 OSSemPost
811059d0 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81120744 g     F .text	00000030 vChangeDefaultRTValue
81105854 g     F .text	000000b0 vFeebCh8HandleIrq
81155400 g     O .bss	00000004 initialized
8111ac54 g     F .text	00000100 vSendLog
8113ad14 g     F .text	000000e4 OSSchedUnlock
8110d20c g     F .text	0000017c RTCC_SPI_R_MAC
811551a4 g     O .rwdata	00000004 alt_log_boot_on_flag
81148534 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
81131b9c g     F .text	00000254 _strtoul_r
811611b4 g     O .bss	00000020 xFeeQueueTBL5
8114c4ec g     F .text	000000e4 alt_get_fd
811553c8 g     O .bss	00000004 OSMemFreeList
8113ae70 g     F .text	000000b8 OSStatInit
81120f48 g     F .text	00000034 bClearCounterSync
811029e4 g     F .text	00000064 DMA_OPEN_DEVICE
8116ee3c g     O .bss	00000014 search_data
8110ab24 g     F .text	00000138 bSpwcSetLink
81138294 g     F .text	00000130 alt_busy_sleep
8113d830 g     F .text	000000cc OSFlagQuery
8110dd70 g     F .text	00000074 bSyncCtrCh1OutEnable
811551fc g     O .rwdata	00000002 OSTaskCreateExtEn
811212a0 g     F .text	00000074 _split_codec_status
8112b83c g     F .text	0000005c _close_r
8111de94 g     F .text	00000080 vCouldNotSendEthConfUART
81113670 g     F .text	0000068c vInitialTask
81139058 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8114b224 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114d158 g     F .text	0000007c memcmp
8113b178 g     F .text	00000028 OS_Dummy
81148604 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116f4a4 g       *ABS*	00000000 __alt_stack_base
81106324 g     F .text	000000e0 bFeebCh7SetBufferSize
8114865c g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105a14 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81123c18 g     F .text	000000d4 _fwrite_r
81117cb8 g     F .text	000000a4 vReleaseSyncMessages
8114b344 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105b24 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8112b6e0 g     F .text	0000015c __swsetup_r
8116b3d8 g     O .bss	00000300 OSQTbl
8111f25c g     F .text	00000080 vCouldNotGetQueueMaskNfeeCtrl
81168d70 g     O .bss	0000001c xConfEth
81137778 g     F .text	000008f0 .hidden __divdf3
811207a8 g     F .text	0000003c vChangeSyncSource
8112d618 g     F .text	00000120 __sfp
8116ee50 g     O .bss	00000054 boot_sector_data
8111f1dc g     F .text	00000080 vCouldNotCreateQueueMaskDataCtrl
8110af94 g     F .text	0000008c bSpwcClearTimecode
81102b2c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112fb10 g     F .text	00000078 __copybits
81153868 g     O .rwdata	00000408 __malloc_av_
8112d76c g     F .text	00000004 __sinit_lock_release
81155238 g     O .bss	00000004 uliInitialState
8110b938 g     F .text	00000080 i2c_stop
811213b8 g     F .text	0000007c Verif_Error
81121434 g     F .text	00000034 toInt
8111d4bc g     F .text	00000064 vFailSendPreAckSenderSemaphore
811553cc g     O .bss	00000004 OSTCBHighRdy
81122030 g     F .text	00000720 .hidden __muldf3
81124fd8 g     F .text	0000005c __sread
8112da80 g     F .text	0000003c fread
811553d0 g     O .bss	00000004 OSQFreeList
8114c3dc g     F .text	00000110 alt_find_file
8114c298 g     F .text	000000ac alt_dev_llist_insert
8113a0c8 g     F .text	00000128 __malloc_lock
81123620 g     F .text	00000030 _fprintf_r
81139a58 g     F .text	000000fc sbrk
8111ffec g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111db94 g     F .text	00000080 vFailGetCountSemaphorexBuffer64
811257b4 g     F .text	000021e0 ___svfprintf_internal_r
8111b194 g     F .text	00000088 vTMPusTestConnection
81155300 g     O .bss	00000004 xMebQ
8113a3ec g     F .text	00000148 OSEventNameSet
8112d354 g     F .text	00000064 _fflush_r
81134df8 g     F .text	000000cc _calloc_r
811553d4 g     O .bss	00000001 OSRdyGrp
8111f648 g     F .text	00000064 vFailSendMsgFeeCTRL
8110d7a0 g     F .text	00000044 ucSyncStatusCycleNumber
8110838c g     F .text	0000008c bRmapGetCodecConfig
81143598 g     F .text	00000148 OSTmrStart
81105644 g     F .text	000000b0 vFeebCh5HandleIrq
81123608 g     F .text	00000018 fopen
81102a48 g     F .text	0000004c DMA_CONFIG
81155238 g       *ABS*	00000000 __bss_start
81106084 g     F .text	000000e0 bFeebCh4SetBufferSize
81124850 g     F .text	00000128 memset
81115d34 g     F .text	0000013c setPreParsedFreePos
8111020c g     F .text	0000025c vQCmdFEEinStandBy
8114bda0 g     F .text	00000060 alt_msgdma_open
81120900 g     F .text	00000210 pattern_createPattern
811196bc g     F .text	00000220 main
8111d6a0 g     F .text	00000080 vFailGetMutexReceiverTask
811611d4 g     O .bss	00001000 vNFeeControlTask_stk
81107988 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
81120660 g     F .text	0000003c vChangeEPValue
81107ad4 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81155378 g     O .bss	00000004 alt_envp
8111f710 g     F .text	00000064 vFailFlushQueue
81155340 g     O .bss	00000004 __malloc_max_total_mem
8114b644 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111d024 g     F .text	0000005c ucCrc8wInit
8111e2a4 g     F .text	00000064 vCouldNotCheckBufferTimeOutFunction
8114859c g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102ff0 g     F .text	000002c8 POWER_Read
8110baf0 g     F .text	00000160 i2c_read
811621d4 g     O .bss	00000020 SyncTBL5
8112b660 g     F .text	00000018 __swbuf
81152f9c g     O .rodata	00000100 OSUnMapTbl
81136dfc g     F .text	000000c8 .hidden __ltsf2
81147938 g     F .text	00000090 alt_up_sd_card_get_attributes
8112d84c g     F .text	00000234 _fread_r
8111d520 g     F .text	00000080 vFailGetCountSemaphoreSenderTask
8110b2e4 g     F .text	0000003c bDisableIsoDrivers
811551f6 g     O .rwdata	00000002 OSSemEn
81144164 g     F .text	000000bc Write_Sector_Data
81147d48 g     F .text	00000628 alt_up_sd_card_write
81155304 g     O .bss	00000004 xFeeQ
81106b64 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113d494 g     F .text	0000039c OSFlagPost
81125124 g     F .text	00000008 __sclose
8111e66c g     F .text	00000080 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81134fbc g     F .text	00000014 fclose
8113b340 g     F .text	00000118 OS_EventTaskWait
8111e4ec g     F .text	00000080 vCouldNotRetransmitB32TimeoutTask
81125254 g     F .text	00000240 _strtol_r
811232d0 g     F .text	000001a8 .hidden __truncdfsf2
811621f4 g     O .bss	00000020 xFeeQueueTBL2
8113bfd0 g     F .text	000000d4 OS_TaskStatStkChk
81141db0 g     F .text	00000158 OSTaskDelReq
81104d20 g     F .text	000000c4 bDpktGetPacketHeader
81107484 g     F .text	000000ec vRmapCh1HandleIrq
8112baa0 g     F .text	00001690 _dtoa_r
8114b960 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81123eec g     F .text	00000814 _malloc_r
81162214 g     O .bss	00000020 SyncTBL0
81135fc0 g     F .text	00000030 __ascii_wctomb
8113e62c g     F .text	000001d0 OSMutexCreate
8111e46c g     F .text	00000080 vFailCouldNotRetransmitTimeoutTask
81113524 g     F .text	0000014c bCheckInAck32
8115519c g     O .rwdata	00000004 alt_errno
8114b48c g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
8113adf8 g     F .text	00000078 OSStart
8110ac5c g     F .text	000000e4 bSpwcGetLink
8110c908 g     F .text	000004e8 POWER_SPI_RW
81133508 g     F .text	000000dc __submore
81138fb8 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
8113a060 g     F .text	00000068 __env_unlock
8111eb9c g     F .text	00000080 vCoudlNotCreateNFee1Task
8112e3c4 g     F .text	000000cc _fwalk
81106c9c g     F .text	00000068 bFeebGetCh1LeftFeeBusy
81142264 g     F .text	000001dc OSTaskResume
8113e2bc g     F .text	000000f0 OSMemQuery
81155208 g     O .rwdata	00000002 OSTaskStatEn
8116f4a4 g       *ABS*	00000000 __alt_stack_limit
81155248 g     O .bss	00000004 ECommSpwCh
8112084c g     F .text	0000003c vChangeAutoResetSync
8112e914 g     F .text	00000064 _mbtowc_r
81112f10 g     F .text	00000380 vInAckHandlerTaskV2
811551e2 g     O .rwdata	00000002 OSMemMax
8114018c g     F .text	00000178 OSQPostFront
81124a88 g     F .text	000000d0 putc
81136b14 g     F .text	00000084 .hidden __divsi3
811553d5 g     O .bss	00000006 OSRdyTbl
811551bc g     O .rwdata	00000002 OSDebugEn
81153f00 g     O .rwdata	0000002a alt_log_msg_cache
8112dabc g     F .text	0000012c _malloc_trim_r
8110a60c g     F .text	0000020c bRmapInitCh
81155334 g     O .bss	00000008 xSdHandle
8112192c g     F .text	00000404 .hidden __mulsf3
811551d4 g     O .rwdata	00000002 OSFlagNodeSize
8115523c g     O .bss	00000004 pnt_memory
811208b8 g     F .text	00000048 vSyncReset
811129e8 g     F .text	00000528 vLoadCtemp
8110d864 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	0000051c bDdr2EepromTest
8115540c g     O .bss	00000004 status_register
8115521c g     O .rwdata	00000002 OSTmrCfgMax
8110e1f8 g     F .text	00000074 bSyncIrqFlagClrError
8111df94 g     F .text	00000080 vFailSetPreAckSenderBuffer
81130334 g     F .text	000000dc strcmp
81155414 g     O .bss	00000004 command_register
8113f718 g     F .text	000001b4 OSQCreate
81141f08 g     F .text	000001a0 OSTaskNameGet
81162234 g     O .bss	00001000 vFeeTask4_stk
81163234 g     O .bss	00000018 xReceivedACK
81140304 g     F .text	00000214 OSQPostOpt
8113af28 g     F .text	00000228 OSTimeTick
81155204 g     O .rwdata	00000002 OSTaskMax
811407e4 g     F .text	000000e0 OSSemCreate
81155228 g     O .rwdata	00000002 OSTmrWheelSize
8111e98c g     F .text	00000080 vFailCreateScheduleQueue
81121034 g     F .text	00000058 _reg_read
8113f2c4 g     F .text	00000174 OSMutexQuery
81111bf0 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81138068 g     F .text	00000088 .hidden __nedf2
811551fe g     O .rwdata	00000002 OSTaskDelEn
81120628 g     F .text	00000038 vLoadDefaultEPValue
8116324c g     O .bss	00001000 vFeeTask1_stk
8110e028 g     F .text	00000074 bSyncCtrCh7OutEnable
81140fac g     F .text	00000118 OSSemQuery
8113f8cc g     F .text	00000288 OSQDel
8113fea8 g     F .text	00000174 OSQPendAbort
81155308 g     O .bss	00000004 xMutexPreParsed
81144034 g     F .text	00000040 alt_irq_init
811399ec g     F .text	0000006c alt_release_fd
81144354 g     F .text	000000bc get_cluster_flag
8110e26c g     F .text	00000074 bSyncIrqFlagClrBlank
8114c098 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110d5b0 g     F .text	0000002c vSyncClearCounter
811125fc g     F .text	000003ec bPrepareDoubleBuffer
81153ecc g     O .rwdata	00000031 alt_log_msg_stackpointer
81124f64 g     F .text	00000074 sprintf
81152684 g     O .rodata	00000100 .hidden __clz_tab
81144928 g     F .text	00000294 Write_File_Record_At_Offset
811015a8 g     F .text	00000588 bDdr2MemoryWriteTest
8111d720 g     F .text	00000080 vFailGetMutexTxUARTSenderTask
8115534c g     O .bss	00000004 _PathLocale
8110e338 g     F .text	00000058 bSyncIrqFlagBlank
8110c7c0 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
811436e0 g     F .text	000001e8 OSTmrStop
8110a86c g     F .text	00000050 uliRmapReadReg
8111ad54 g     F .text	00000050 usiGetIdCMD
8110e464 g     F .text	00000058 uliSyncReadReg
81106dd4 g     F .text	00000068 bFeebGetCh2RightFeeBusy
81131a94 g     F .text	00000108 strtof
811054e4 g     F .text	000000b0 vFeebCh3HandleIrq
81136d40 g     F .text	000000bc .hidden __gesf2
8112512c g     F .text	0000004c strcspn
8112b678 g     F .text	00000068 _write_r
8110ce5c g     F .text	00000074 vRstcReleaseDeviceReset
8111e178 g     F .text	00000064 vFailInAckHandlerTaskCreate
8113ac80 g     F .text	00000094 OSSchedLock
8111ec9c g     F .text	00000080 vCoudlNotCreateNFee3Task
8112e6a8 g     F .text	00000018 setlocale
8114b3ec g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8116b6d8 g     O .bss	00000800 OSTmrTaskStk
81124e88 g     F .text	00000044 scanf
8111ef9c g     F .text	00000078 vFailCreateMutexSPUSQueueMeb
8113c888 g     F .text	00000110 OSFlagCreate
81144bbc g     F .text	00000688 Check_for_DOS_FAT
81117bb0 g     F .text	00000064 vMebInit
81146a68 g     F .text	000002d0 create_file
8113032c g     F .text	00000008 nanf
81155170 g     O .rwdata	00000004 _impure_ptr
81155410 g     O .bss	00000004 CSD_register_w0
81155370 g     O .bss	00000004 alt_argc
8111db14 g     F .text	00000080 vFailGetCountSemaphorexBuffer128
8112d130 g     F .text	00000224 __sflush_r
8112e734 g     F .text	000000b4 _mbrtowc_r
8110af04 g     F .text	00000090 bSpwcGetTimecode
8112e694 g     F .text	00000008 __locale_cjk_lang
811033f8 g     F .text	0000078c sense_log
8115524c g     O .bss	00000004 ESdmaBufferSide
811551ce g     O .rwdata	00000002 OSEventMultiEn
8112372c g     F .text	00000004 _fseek_r
8116424c g     O .bss	00001800 vParserCommTask_stk
8111d160 g     F .text	00000070 printErrorTask
8112069c g     F .text	00000030 vChangeDefaultEPValue
81118c70 g     F .text	000002c8 vCheckRetransmission32
81142eb0 g     F .text	000001c4 OSTmrCreate
81117d5c g     F .text	000007dc vStackMonitor
81124c50 g     F .text	000001dc __srefill_r
8110b320 g     F .text	0000003c bEnableLvdsBoard
8115530c g     O .bss	00000004 xMutexBuffer32
811552b4 g     O .bss	00000001 ucIterationSide
81107570 g     F .text	000000ec vRmapCh2HandleIrq
8113c998 g     F .text	00000250 OSFlagDel
811553dc g     O .bss	00000004 OSEventFreeList
8110b398 g     F .text	000000c0 bSetPreEmphasys
8110ffc8 g     F .text	00000244 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112e8c8 g     F .text	0000004c __ascii_mbtowc
8110db34 g     F .text	00000078 bSyncCtrExtnIrq
81106bcc g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112f71c g     F .text	00000064 __ulp
811201cc g     F .text	0000010c vNFeeControlInit
81117c14 g     F .text	000000a4 vSwapMemmory
8113ce6c g     F .text	000005c0 OSFlagPend
8115521a g     O .rwdata	00000002 OSTmrEn
8112d788 g     F .text	00000018 __fp_unlock_all
81165a4c g     O .bss	00000010 xDma
811236c8 g     F .text	00000064 fputc
81111930 g     F .text	00000058 bEnableRmapIRQ
8111a46c g     F .text	00000328 bSendUART32v2
81115fec g     F .text	000001b4 setPreAckReceiverFreePos
8110daf4 g     F .text	00000040 bSyncErrInj
81155188 g     O .rwdata	00000008 alt_fs_list
81165a5c g     O .bss	00001000 vSimMebTask_stk
8111ef1c g     F .text	00000080 vCoudlNotCreateMebTask
81145404 g     F .text	00000274 check_file_name_for_FAT16_compliance
81166a5c g     O .bss	00001000 vFeeTask3_stk
811431b4 g     F .text	00000140 OSTmrNameGet
811556a4 g     O .bss	00000400 xSZData
81110468 g     F .text	00000288 vQCmdFEEinFullPattern
8113bdb0 g     F .text	0000007c OS_StrCopy
8115541c g     O .bss	00000004 buffer_memory
8111dd94 g     F .text	00000080 vFailGetxMutexPreParsedParserRxTask
811204a4 g     F .text	00000098 vLogWriteNUC
811551e4 g     O .rwdata	00000002 OSMemNameSize
81103b84 g     F .text	000000bc bSdmaInitM1Dma
8110e184 g     F .text	00000074 bSyncIrqEnableBlank
8114cff8 g     F .text	00000028 OSInitHookEnd
8111fbfc g     F .text	00000340 vUpdateMemMapFEE
8111e094 g     F .text	00000080 vFailSetPreAckReceiverBuffer
81105d8c g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81155210 g     O .rwdata	00000002 OSTCBPrioTblMax
8112e6c0 g     F .text	0000000c localeconv
8111ee9c g     F .text	00000080 vCoudlNotCreateDataControllerTask
81155310 g     O .bss	00000004 xTimerRetransmission
81115ab0 g     F .text	00000284 vReceiverUartTask
8115536c g     O .bss	00000004 alt_log_sys_clk_count
8115520c g     O .rwdata	00000002 OSTaskStatStkChkEn
81139208 g     F .text	00000140 alt_log_write
81167a5c g     O .bss	00001000 vFeeTask2_stk
81155314 g     O .bss	00000004 xMutexBuffer128
81105388 g     F .text	000000ac vFeebCh1HandleIrq
81120edc g     F .text	0000003c bStartSync
811057a4 g     F .text	000000b0 vFeebCh7HandleIrq
81120f18 g     F .text	00000030 bStopSync
81155250 g     O .bss	00000004 ECommBufferSide
8114c5d0 g     F .text	00000058 alt_ic_isr_register
811551e0 g     O .rwdata	00000002 OSMemEn
8110765c g     F .text	00000038 vRmapCh3HandleIrq
8115515c g     O .rwdata	00000004 alt_stack_limit_value
811174dc g     F .text	00000420 vPusType252run
8111f5e4 g     F .text	00000064 vFailSendMsgMasterSyncMeb
81123cec g     F .text	0000003c fwrite
81155420 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
811551ea g     O .rwdata	00000002 OSMutexEn
8111f2dc g     F .text	00000080 vCouldNotGetQueueMaskDataCtrl
81155238 g       *ABS*	00000000 _edata
81149450 g     F .text	00000068 altera_avalon_uart_read_fd
8112034c g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105270 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116f4a4 g       *ABS*	00000000 _end
8116eea4 g     O .bss	00000500 active_files
811553e0 g     O .bss	00000001 OSIntNesting
8111d804 g     F .text	00000064 vFailInitialization
811014e0 g     F .text	000000c8 bDdr2SwitchMemory
811200c8 g     F .text	0000002c cFeeRMAPDump
81105fa4 g     F .text	000000e0 bFeebCh3SetBufferSize
81155318 g     O .bss	00000004 xSemCountBuffer32
81134fd0 g     F .text	0000016c __fputwc
8115531c g     O .bss	00000004 xQMaskFeeCtrl
81120018 g     F .text	0000002c vFeeSpwRMAPChangeConfig
8112b438 g     F .text	00000070 vfscanf
81146d38 g     F .text	00000150 copy_file_record_name_to_string
81148cc0 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81142c08 g     F .text	000001dc OSTimeDlyResume
81145244 g     F .text	000000f4 Look_for_FAT16
81111988 g     F .text	00000060 bDisableSPWChannel
8113cd18 g     F .text	00000154 OSFlagNameSet
81111ae0 g     F .text	0000006c bDisAndClrDbBuffer
81155320 g     O .bss	00000004 xMutexBuffer64
81108578 g     F .text	00000160 bRmapGetCodecError
81142440 g     F .text	000001c8 OSTaskStkChk
8114c6b8 g     F .text	00000094 alt_ic_irq_disable
81103d04 g     F .text	00000454 bSdmaDmaM1Transfer
811551e6 g     O .rwdata	00000002 OSMemSize
81116fe0 g     F .text	00000260 vPusType252conf
8111d994 g     F .text	00000080 vFailSetCountSemaphorexBuffer32
8112503c g     F .text	00000084 __swrite
81155178 g     O .rwdata	00000004 __malloc_trim_threshold
8112e688 g     F .text	0000000c __locale_msgcharset
81168a5c g     O .bss	00000020 xFeeQueueTBL1
811553e4 g     O .bss	00000004 OSTCBCur
8111e56c g     F .text	00000080 vCouldNotRetransmitB64TimeoutTask
8110c8c4 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114d118 g     F .text	00000040 exit
8113f0a4 g     F .text	00000220 OSMutexPost
8110e2e0 g     F .text	00000058 bSyncIrqFlagError
81147164 g     F .text	000003c0 alt_up_sd_card_find_next
811551e8 g     O .rwdata	00000002 OSMemTblSize
8112e490 g     F .text	000000cc _fwalk_reent
8114b7e4 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
81121e5c g     F .text	000000f8 .hidden __floatunsisf
8112f518 g     F .text	00000204 __mdiff
8111eb1c g     F .text	00000080 vCoudlNotCreateNFee0Task
811064e4 g     F .text	000001c8 vFeebInitIrq
81104924 g     F .text	000002a4 bDpktSetPacketConfig
8111d8cc g     F .text	00000064 vFailSenderCreate
81136b98 g     F .text	00000074 .hidden __modsi3
8111ed9c g     F .text	00000080 vCoudlNotCreateNFee5Task
8110da40 g     F .text	0000003c uliSyncGetPer
81107704 g     F .text	00000038 vRmapCh6HandleIrq
81155324 g     O .bss	00000004 xMutexSenderACK
8111e36c g     F .text	00000080 vFailGetBlockingSemTimeoutTask
81155168 g     O .rwdata	00000004 __ctype_ptr__
8111e014 g     F .text	00000080 vFailSetPreParsedBuffer
81144274 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112d764 g     F .text	00000004 __sfp_lock_release
81106784 g     F .text	000000ac bFeebGetIrqControl
8111e6ec g     F .text	00000080 vCouldNotSendTurnOff
8113aac8 g     F .text	00000064 OSInit
8110bcd0 g     F .text	00000078 bSetPainelLeds
8114af2c g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
811553e8 g     O .bss	00000004 OSTmrTime
81101b30 g     F .text	00000518 bDdr2MemoryReadTest
811086d8 g     F .text	00000334 bRmapSetMemConfigArea
811427f4 g     F .text	0000012c OSTaskQuery
8110e110 g     F .text	00000074 bSyncIrqEnableError
81155328 g     O .bss	00000004 xMutexPus
8114067c g     F .text	000000b0 OS_QInit
8113025c g     F .text	000000d0 __sccl
811234dc g     F .text	0000000c atoi
8110e5f8 g     F .text	000017b8 vFeeTask
8113be2c g     F .text	0000005c OS_StrLen
8111f83c g     F .text	00000064 vFailFlushNFEEQueue
81105b7c g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111d080 g     F .text	000000e0 vDataControllerInit
8113e0c0 g     F .text	0000011c OSMemNameSet
81152784 g     O .rodata	00000101 _ctype_
8110da04 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111da94 g     F .text	00000080 vFailSetCountSemaphorexBuffer128
81155202 g     O .rwdata	00000002 OSTaskProfileEn
8111f8a0 g     F .text	00000028 vEvtChangeMebMode
8114adfc g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8115532c g     O .bss	00000004 xTxUARTMutex
811553ec g     O .bss	00000004 OSTime
81155180 g     O .rwdata	00000004 __mbtowc
81149a70 g     F .text	0000005c altera_avalon_uart_close
8110fdb0 g     F .text	00000218 vQCmdFEEinWaitingSync
811553f0 g     O .bss	00000004 OSTmrSem
81116f74 g     F .text	0000006c vPusType251conf
8116bed8 g     O .bss	00001000 OSTaskIdleStk
8112350c g     F .text	000000fc _fopen_r
811552c8 g     O .bss	00000004 pdata
8114d448 g     F .text	000000bc _exit
81106a0c g     F .text	00000078 bFeebGetLeftBufferEmpty
8114c120 g     F .text	00000134 alt_alarm_start
8113cbe8 g     F .text	00000130 OSFlagNameGet
81142de4 g     F .text	00000064 OSTimeGet
81155254 g     O .bss	00000004 ESdmaChBufferId
811479c8 g     F .text	00000380 alt_up_sd_card_read
811078bc g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81123d28 g     F .text	000001c4 __smakebuf_r
81155330 g     O .bss	00000001 SemCount64
8111a144 g     F .text	00000328 bSendUART64v2
8111f774 g     F .text	00000064 vFailFlushQueueData
81105c2c g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81155230 g     O .rwdata	00000008 alt_msgdma_list
81125178 g     F .text	00000098 strlen
8110d100 g     F .text	000000b4 uc_spi_get_byte
81107900 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111f35c g     F .text	0000006c vFailSendMsgAccessDMA
8114cf28 g     F .text	00000028 OSTaskSwHook
81139748 g     F .text	0000015c open
81109e40 g     F .text	000007cc bRmapGetRmapMemHKArea
8116ced8 g     O .bss	00000d00 OSEventTbl
81120044 g     F .text	0000002c vFeeSpwRMAPChangeDefault
81121f54 g     F .text	000000dc .hidden __gedf2
8111f578 g     F .text	0000006c vFailSendMsgSyncRMAPTRIGGER
81168a7c g     O .bss	00000020 xSenderACK
8114cc1c g     F .text	00000044 alt_putchar
811234f4 g     F .text	0000000c atoll
8116dbd8 g     O .bss	000011b8 OSTCBTbl
811352e8 g     F .text	00000838 __gethex
811410c4 g     F .text	00000108 OSSemSet
81118538 g     F .text	00000084 vTimeoutCheckerTaskv2
811200f4 g     F .text	00000038 cFeeRMAPEchoingEnable
81155184 g     O .rwdata	00000004 __wctomb
811193a8 g     F .text	00000314 vVariablesInitialization
8113389c g     F .text	00000018 __sprint_r
81110d74 g     F .text	000005e4 vQCmdFeeRMAPinFullPattern
81106830 g     F .text	00000088 bFeebGetIrqFlags
81155244 g     O .bss	00000004 pxDmaM2Dev
8111d2ac g     F .text	00000064 vFailCreateSemaphoreResources
811551a0 g     O .rwdata	00000004 alt_priority_mask
8110b35c g     F .text	0000003c bDisableLvdsBoard
811408c4 g     F .text	00000248 OSSemDel
81105ec4 g     F .text	000000e0 bFeebCh2SetBufferSize
811553f4 g     O .bss	00000004 OSFlagFreeList
8110d03c g     F .text	000000c4 v_spi_send_byte
8110d388 g     F .text	000000d0 bSSDisplayConfig
8114c628 g     F .text	00000090 alt_ic_irq_enable
811551c8 g     O .rwdata	00000002 OSEventNameSize
81129b94 g     F .text	0000001c __vfprintf_internal
811553f8 g     O .bss	00000001 OSStatRdy
8110dde4 g     F .text	00000074 bSyncCtrCh2OutEnable
8116ed90 g     O .bss	000000ac OSTCBPrioTbl
81149b10 g     F .text	00000270 altera_avalon_uart_read
81135ff0 g     F .text	00000064 _wctomb_r
81139f94 g     F .text	000000cc __env_lock
8115520e g     O .rwdata	00000002 OSTaskSwHookEn
81155bbc g     O .bss	00000100 cTemp
8110598c g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81122750 g     F .text	00000904 .hidden __subdf3
81168a9c g     O .bss	00000260 xPreParsed
8110da7c g     F .text	0000003c uliSyncGetOst
81155331 g     O .bss	00000001 SemCount128
81107774 g     F .text	00000038 vRmapCh8HandleIrq
81105a58 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
8111a794 g     F .text	00000290 vSendEthConf
8110476c g     F .text	00000114 bCommInitCh
8112ef2c g     F .text	000000b0 __lo0bits
81129c74 g     F .text	000017c4 __svfscanf_r
811551ac g     O .rwdata	00000008 alt_alarm_list
811335e4 g     F .text	0000019c _ungetc_r
811551d6 g     O .rwdata	00000002 OSFlagWidth
811077ac g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a94 g     F .text	0000004c DMA_BUSY
81135ef8 g     F .text	000000c8 wcrtomb
81104de4 g     F .text	00000154 bDpktSetPixelDelay
81119c30 g     F .text	00000164 vCCDLoadDefaultValues
81138408 g     F .text	000000d8 close
8110dab8 g     F .text	0000003c uliSyncGetGeneral
8111f8f0 g     F .text	00000028 vEvtChangeDataControllerMode
81155388 g     O .bss	00000004 alt_envsem
81138938 g     F .text	00000068 alt_log_repchar
811553fc g     O .bss	00000004 OSIdleCtrRun
8113b150 g     F .text	00000028 OSVersion
81155220 g     O .rwdata	00000002 OSTmrCfgWheelSize
81142920 g     F .text	00000078 OS_TaskStkClr
81120c68 g     F .text	0000003c siOpenFile
8110e540 g     F .text	000000b8 vDataControlTask
811551fa g     O .rwdata	00000002 OSTaskCreateEn
81107a24 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81107e84 g     F .text	00000054 uliRmapCh7WriteCmdAddress
81107058 g     F .text	0000008c bFeebStartCh
8111aa24 g     F .text	00000118 vSendTurnOff
8111d3f4 g     F .text	00000064 vFailSendPreParsedSemaphore
81145738 g     F .text	000002a4 match_file_record_to_name_ext
8113b778 g     F .text	00000070 OS_EventWaitListInit
81135160 g     F .text	00000088 fputwc
81168cfc g     O .bss	00000020 xFeeQueueTBL0
8111d374 g     F .text	00000080 vFailSendxSemCommInit
8114d020 g     F .text	00000028 OSTaskIdleHook
8111ab3c g     F .text	00000118 vSendReset
8112d768 g     F .text	00000004 __sinit_lock_acquire
8112ec90 g     F .text	00000128 __multadd
81168d1c g     O .bss	00000020 SyncTBL1
81105a9c g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110d708 g     F .text	0000004c ucSyncStatusState
81142608 g     F .text	000001ec OSTaskSuspend
8112ec68 g     F .text	00000028 _Bfree
8110d9c8 g     F .text	0000003c uliSyncGetMbt
8113be88 g     F .text	00000064 OS_TaskIdle
81155226 g     O .rwdata	00000002 OSTmrTblSize
81140518 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	113ab2c0 	call	8113ab2c <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10bce904 	addi	r2,r2,-3164
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10bce904 	addi	r2,r2,-3164
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	113ab800 	call	8113ab80 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21146904 	addi	r4,r4,20900
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	210fc004 	addi	r4,r4,16128
81100274:	11388b00 	call	811388b0 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21146904 	addi	r4,r4,20900
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	210fb304 	addi	r4,r4,16076
81100290:	11388b00 	call	811388b0 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6b45714 	ori	gp,gp,53596
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21146904 	addi	r4,r4,20900
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	210fa404 	addi	r4,r4,16016
811002bc:	11388b00 	call	811388b0 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	10948e14 	ori	r2,r2,21048

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18fd2914 	ori	r3,r3,62628

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21146904 	addi	r4,r4,20900
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	210fab04 	addi	r4,r4,16044
811002fc:	11388b00 	call	811388b0 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11394dc0 	call	811394dc <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18d56904 	addi	r3,r3,21924
81100330:	00a04574 	movhi	r2,33045
81100334:	10b54104 	addi	r2,r2,-11004
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29556904 	addi	r5,r5,21924
8110035c:	1009883a 	mov	r4,r2
81100360:	11236500 	call	81123650 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess = FALSE;
8110036c:	e03ff915 	stw	zero,-28(fp)
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	switch (ucMemoryId) {
81100370:	e0bfff03 	ldbu	r2,-4(fp)
81100374:	10000326 	beq	r2,zero,81100384 <bDdr2EepromTest+0x7c>
81100378:	10800060 	cmpeqi	r2,r2,1
8110037c:	10000a1e 	bne	r2,zero,811003a8 <bDdr2EepromTest+0xa0>
81100380:	00001206 	br	811003cc <bDdr2EepromTest+0xc4>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100384:	00a00034 	movhi	r2,32768
81100388:	10827c04 	addi	r2,r2,2544
8110038c:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100390:	00a00034 	movhi	r2,32768
81100394:	10828004 	addi	r2,r2,2560
81100398:	e0bffb15 	stw	r2,-20(fp)
		bSuccess = TRUE;
8110039c:	00800044 	movi	r2,1
811003a0:	e0bff915 	stw	r2,-28(fp)
		break;
811003a4:	00001b06 	br	81100414 <bDdr2EepromTest+0x10c>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a8:	00a00034 	movhi	r2,32768
811003ac:	10825804 	addi	r2,r2,2400
811003b0:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b4:	00a00034 	movhi	r2,32768
811003b8:	10825c04 	addi	r2,r2,2416
811003bc:	e0bffb15 	stw	r2,-20(fp)
		bSuccess = TRUE;
811003c0:	00800044 	movi	r2,1
811003c4:	e0bff915 	stw	r2,-28(fp)
		break;
811003c8:	00001206 	br	81100414 <bDdr2EepromTest+0x10c>
	default:
		bSuccess = FALSE;
811003cc:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811003d0:	00e04574 	movhi	r3,33045
811003d4:	18d56904 	addi	r3,r3,21924
811003d8:	00a04574 	movhi	r2,33045
811003dc:	10b54a04 	addi	r2,r2,-10968
811003e0:	1009883a 	mov	r4,r2
811003e4:	00800bc4 	movi	r2,47
811003e8:	100d883a 	mov	r6,r2
811003ec:	200b883a 	mov	r5,r4
811003f0:	1809883a 	mov	r4,r3
811003f4:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003f8:	d0a06217 	ldw	r2,-32376(gp)
811003fc:	01604574 	movhi	r5,33045
81100400:	29556904 	addi	r5,r5,21924
81100404:	1009883a 	mov	r4,r2
81100408:	11236500 	call	81123650 <fprintf>
		;
#endif
		return bSuccess;
8110040c:	e0bff917 	ldw	r2,-28(fp)
81100410:	0000ff06 	br	81100810 <bDdr2EepromTest+0x508>
	}

	alt_u8 ucControlAddr, ucValue;
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100414:	00e04574 	movhi	r3,33045
81100418:	18d56904 	addi	r3,r3,21924
8110041c:	00a04574 	movhi	r2,33045
81100420:	10b55604 	addi	r2,r2,-10920
81100424:	1009883a 	mov	r4,r2
81100428:	008005c4 	movi	r2,23
8110042c:	100d883a 	mov	r6,r2
81100430:	200b883a 	mov	r5,r4
81100434:	1809883a 	mov	r4,r3
81100438:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
8110043c:	d0a06217 	ldw	r2,-32376(gp)
81100440:	01604574 	movhi	r5,33045
81100444:	29556904 	addi	r5,r5,21924
81100448:	1009883a 	mov	r4,r2
8110044c:	11236500 	call	81123650 <fprintf>
#endif
	usleep(20 * 1000);
81100450:	01138804 	movi	r4,20000
81100454:	1139d080 	call	81139d08 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100458:	e03ffc15 	stw	zero,-16(fp)
8110045c:	00003306 	br	8110052c <bDdr2EepromTest+0x224>
		ucControlAddr = iI;
81100460:	e0bffc17 	ldw	r2,-16(fp)
81100464:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100468:	e0bffd03 	ldbu	r2,-12(fp)
8110046c:	10c03fcc 	andi	r3,r2,255
81100470:	18c0201c 	xori	r3,r3,128
81100474:	18ffe004 	addi	r3,r3,-128
81100478:	e13ffd43 	ldbu	r4,-11(fp)
8110047c:	e0bffe04 	addi	r2,fp,-8
81100480:	d8800015 	stw	r2,0(sp)
81100484:	200f883a 	mov	r7,r4
81100488:	180d883a 	mov	r6,r3
8110048c:	e17ffb17 	ldw	r5,-20(fp)
81100490:	e13ffa17 	ldw	r4,-24(fp)
81100494:	110b63c0 	call	8110b63c <I2C_Read>
81100498:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
8110049c:	e0bff917 	ldw	r2,-28(fp)
811004a0:	10001026 	beq	r2,zero,811004e4 <bDdr2EepromTest+0x1dc>
#if DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
811004a4:	e0bffd43 	ldbu	r2,-11(fp)
811004a8:	e0fffe03 	ldbu	r3,-8(fp)
811004ac:	18c03fcc 	andi	r3,r3,255
811004b0:	180f883a 	mov	r7,r3
811004b4:	100d883a 	mov	r6,r2
811004b8:	01604574 	movhi	r5,33045
811004bc:	29755c04 	addi	r5,r5,-10896
811004c0:	01204574 	movhi	r4,33045
811004c4:	21156904 	addi	r4,r4,21924
811004c8:	1124f640 	call	81124f64 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004cc:	d0a06217 	ldw	r2,-32376(gp)
811004d0:	01604574 	movhi	r5,33045
811004d4:	29556904 	addi	r5,r5,21924
811004d8:	1009883a 	mov	r4,r2
811004dc:	11236500 	call	81123650 <fprintf>
811004e0:	00000f06 	br	81100520 <bDdr2EepromTest+0x218>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004e4:	00e04574 	movhi	r3,33045
811004e8:	18d56904 	addi	r3,r3,21924
811004ec:	00a04574 	movhi	r2,33045
811004f0:	10b56104 	addi	r2,r2,-10876
811004f4:	1009883a 	mov	r4,r2
811004f8:	008005c4 	movi	r2,23
811004fc:	100d883a 	mov	r6,r2
81100500:	200b883a 	mov	r5,r4
81100504:	1809883a 	mov	r4,r3
81100508:	11247000 	call	81124700 <memcpy>
			debug(fp, cDebugBuffer);
8110050c:	d0a06217 	ldw	r2,-32376(gp)
81100510:	01604574 	movhi	r5,33045
81100514:	29556904 	addi	r5,r5,21924
81100518:	1009883a 	mov	r4,r2
8110051c:	11236500 	call	81123650 <fprintf>
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10800044 	addi	r2,r2,1
81100528:	e0bffc15 	stw	r2,-16(fp)
8110052c:	e0bffc17 	ldw	r2,-16(fp)
81100530:	10804008 	cmpgei	r2,r2,256
81100534:	1000021e 	bne	r2,zero,81100540 <bDdr2EepromTest+0x238>
81100538:	e0bff917 	ldw	r2,-28(fp)
8110053c:	103fc81e 	bne	r2,zero,81100460 <__reset+0xfb0e0460>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100540:	e0bff917 	ldw	r2,-28(fp)
81100544:	10001026 	beq	r2,zero,81100588 <bDdr2EepromTest+0x280>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
81100548:	00e04574 	movhi	r3,33045
8110054c:	18d56904 	addi	r3,r3,21924
81100550:	00a04574 	movhi	r2,33045
81100554:	10b56704 	addi	r2,r2,-10852
81100558:	1009883a 	mov	r4,r2
8110055c:	00800884 	movi	r2,34
81100560:	100d883a 	mov	r6,r2
81100564:	200b883a 	mov	r5,r4
81100568:	1809883a 	mov	r4,r3
8110056c:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
81100570:	d0a06217 	ldw	r2,-32376(gp)
81100574:	01604574 	movhi	r5,33045
81100578:	29556904 	addi	r5,r5,21924
8110057c:	1009883a 	mov	r4,r2
81100580:	11236500 	call	81123650 <fprintf>
81100584:	00000f06 	br	811005c4 <bDdr2EepromTest+0x2bc>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
81100588:	00e04574 	movhi	r3,33045
8110058c:	18d56904 	addi	r3,r3,21924
81100590:	00a04574 	movhi	r2,33045
81100594:	10b57004 	addi	r2,r2,-10816
81100598:	1009883a 	mov	r4,r2
8110059c:	008007c4 	movi	r2,31
811005a0:	100d883a 	mov	r6,r2
811005a4:	200b883a 	mov	r5,r4
811005a8:	1809883a 	mov	r4,r3
811005ac:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
811005b0:	d0a06217 	ldw	r2,-32376(gp)
811005b4:	01604574 	movhi	r5,33045
811005b8:	29556904 	addi	r5,r5,21924
811005bc:	1009883a 	mov	r4,r2
811005c0:	11236500 	call	81123650 <fprintf>
#endif
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005c4:	00e04574 	movhi	r3,33045
811005c8:	18d56904 	addi	r3,r3,21924
811005cc:	00a04574 	movhi	r2,33045
811005d0:	10b57804 	addi	r2,r2,-10784
811005d4:	1009883a 	mov	r4,r2
811005d8:	00800604 	movi	r2,24
811005dc:	100d883a 	mov	r6,r2
811005e0:	200b883a 	mov	r5,r4
811005e4:	1809883a 	mov	r4,r3
811005e8:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
811005ec:	d0a06217 	ldw	r2,-32376(gp)
811005f0:	01604574 	movhi	r5,33045
811005f4:	29556904 	addi	r5,r5,21924
811005f8:	1009883a 	mov	r4,r2
811005fc:	11236500 	call	81123650 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
81100600:	00800484 	movi	r2,18
81100604:	e0bffd85 	stb	r2,-10(fp)
81100608:	00bfe004 	movi	r2,-128
8110060c:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100610:	01138804 	movi	r4,20000
81100614:	1139d080 	call	81139d08 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100618:	e0bffd03 	ldbu	r2,-12(fp)
8110061c:	10c03fcc 	andi	r3,r2,255
81100620:	18c0201c 	xori	r3,r3,128
81100624:	18ffe004 	addi	r3,r3,-128
81100628:	e13ffdc3 	ldbu	r4,-9(fp)
8110062c:	e0bffd83 	ldbu	r2,-10(fp)
81100630:	d8800015 	stw	r2,0(sp)
81100634:	200f883a 	mov	r7,r4
81100638:	180d883a 	mov	r6,r3
8110063c:	e17ffb17 	ldw	r5,-20(fp)
81100640:	e13ffa17 	ldw	r4,-24(fp)
81100644:	110b55c0 	call	8110b55c <I2C_Write>
81100648:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
8110064c:	e0bff917 	ldw	r2,-28(fp)
81100650:	1000101e 	bne	r2,zero,81100694 <bDdr2EepromTest+0x38c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100654:	00e04574 	movhi	r3,33045
81100658:	18d56904 	addi	r3,r3,21924
8110065c:	00a04574 	movhi	r2,33045
81100660:	10b57e04 	addi	r2,r2,-10760
81100664:	1009883a 	mov	r4,r2
81100668:	00800604 	movi	r2,24
8110066c:	100d883a 	mov	r6,r2
81100670:	200b883a 	mov	r5,r4
81100674:	1809883a 	mov	r4,r3
81100678:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
8110067c:	d0a06217 	ldw	r2,-32376(gp)
81100680:	01604574 	movhi	r5,33045
81100684:	29556904 	addi	r5,r5,21924
81100688:	1009883a 	mov	r4,r2
8110068c:	11236500 	call	81123650 <fprintf>
81100690:	00003306 	br	81100760 <bDdr2EepromTest+0x458>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100694:	e0bffd03 	ldbu	r2,-12(fp)
81100698:	10c03fcc 	andi	r3,r2,255
8110069c:	18c0201c 	xori	r3,r3,128
811006a0:	18ffe004 	addi	r3,r3,-128
811006a4:	e13ffdc3 	ldbu	r4,-9(fp)
811006a8:	e0bffe44 	addi	r2,fp,-7
811006ac:	d8800015 	stw	r2,0(sp)
811006b0:	200f883a 	mov	r7,r4
811006b4:	180d883a 	mov	r6,r3
811006b8:	e17ffb17 	ldw	r5,-20(fp)
811006bc:	e13ffa17 	ldw	r4,-24(fp)
811006c0:	110b63c0 	call	8110b63c <I2C_Read>
811006c4:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006c8:	e0bff917 	ldw	r2,-28(fp)
811006cc:	1000101e 	bne	r2,zero,81100710 <bDdr2EepromTest+0x408>
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006d0:	00e04574 	movhi	r3,33045
811006d4:	18d56904 	addi	r3,r3,21924
811006d8:	00a04574 	movhi	r2,33045
811006dc:	10b58404 	addi	r2,r2,-10736
811006e0:	1009883a 	mov	r4,r2
811006e4:	00800884 	movi	r2,34
811006e8:	100d883a 	mov	r6,r2
811006ec:	200b883a 	mov	r5,r4
811006f0:	1809883a 	mov	r4,r3
811006f4:	11247000 	call	81124700 <memcpy>
			debug(fp, cDebugBuffer);
811006f8:	d0a06217 	ldw	r2,-32376(gp)
811006fc:	01604574 	movhi	r5,33045
81100700:	29556904 	addi	r5,r5,21924
81100704:	1009883a 	mov	r4,r2
81100708:	11236500 	call	81123650 <fprintf>
8110070c:	00001406 	br	81100760 <bDdr2EepromTest+0x458>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100710:	e0bffe43 	ldbu	r2,-7(fp)
81100714:	10c03fcc 	andi	r3,r2,255
81100718:	e0bffd83 	ldbu	r2,-10(fp)
8110071c:	18801026 	beq	r3,r2,81100760 <bDdr2EepromTest+0x458>
				bSuccess = FALSE;
81100720:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100724:	e0bffe43 	ldbu	r2,-7(fp)
81100728:	10803fcc 	andi	r2,r2,255
8110072c:	e0fffd83 	ldbu	r3,-10(fp)
81100730:	180f883a 	mov	r7,r3
81100734:	100d883a 	mov	r6,r2
81100738:	01604574 	movhi	r5,33045
8110073c:	29758d04 	addi	r5,r5,-10700
81100740:	01204574 	movhi	r4,33045
81100744:	21156904 	addi	r4,r4,21924
81100748:	1124f640 	call	81124f64 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
8110074c:	d0a06217 	ldw	r2,-32376(gp)
81100750:	01604574 	movhi	r5,33045
81100754:	29556904 	addi	r5,r5,21924
81100758:	1009883a 	mov	r4,r2
8110075c:	11236500 	call	81123650 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100760:	e0bff917 	ldw	r2,-28(fp)
81100764:	10001026 	beq	r2,zero,811007a8 <bDdr2EepromTest+0x4a0>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
81100768:	00e04574 	movhi	r3,33045
8110076c:	18d56904 	addi	r3,r3,21924
81100770:	00a04574 	movhi	r2,33045
81100774:	10b59c04 	addi	r2,r2,-10640
81100778:	1009883a 	mov	r4,r2
8110077c:	008008c4 	movi	r2,35
81100780:	100d883a 	mov	r6,r2
81100784:	200b883a 	mov	r5,r4
81100788:	1809883a 	mov	r4,r3
8110078c:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
81100790:	d0a06217 	ldw	r2,-32376(gp)
81100794:	01604574 	movhi	r5,33045
81100798:	29556904 	addi	r5,r5,21924
8110079c:	1009883a 	mov	r4,r2
811007a0:	11236500 	call	81123650 <fprintf>
811007a4:	00000f06 	br	811007e4 <bDdr2EepromTest+0x4dc>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
811007a8:	00e04574 	movhi	r3,33045
811007ac:	18d56904 	addi	r3,r3,21924
811007b0:	00a04574 	movhi	r2,33045
811007b4:	10b5a504 	addi	r2,r2,-10604
811007b8:	1009883a 	mov	r4,r2
811007bc:	00800804 	movi	r2,32
811007c0:	100d883a 	mov	r6,r2
811007c4:	200b883a 	mov	r5,r4
811007c8:	1809883a 	mov	r4,r3
811007cc:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
811007d0:	d0a06217 	ldw	r2,-32376(gp)
811007d4:	01604574 	movhi	r5,33045
811007d8:	29556904 	addi	r5,r5,21924
811007dc:	1009883a 	mov	r4,r2
811007e0:	11236500 	call	81123650 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007e4:	00a04574 	movhi	r2,33045
811007e8:	10956904 	addi	r2,r2,21924
811007ec:	00c00284 	movi	r3,10
811007f0:	10c00005 	stb	r3,0(r2)
811007f4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007f8:	d0a06217 	ldw	r2,-32376(gp)
811007fc:	01604574 	movhi	r5,33045
81100800:	29556904 	addi	r5,r5,21924
81100804:	1009883a 	mov	r4,r2
81100808:	11236500 	call	81123650 <fprintf>
#endif

	return bSuccess;
8110080c:	e0bff917 	ldw	r2,-28(fp)
}
81100810:	e037883a 	mov	sp,fp
81100814:	dfc00117 	ldw	ra,4(sp)
81100818:	df000017 	ldw	fp,0(sp)
8110081c:	dec00204 	addi	sp,sp,8
81100820:	f800283a 	ret

81100824 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100824:	deffb704 	addi	sp,sp,-292
81100828:	de00012e 	bgeu	sp,et,81100830 <bDdr2EepromDump+0xc>
8110082c:	003b68fa 	trap	3
81100830:	dfc04815 	stw	ra,288(sp)
81100834:	df004715 	stw	fp,284(sp)
81100838:	df004704 	addi	fp,sp,284
8110083c:	2005883a 	mov	r2,r4
81100840:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100844:	00e04574 	movhi	r3,33045
81100848:	18d56904 	addi	r3,r3,21924
8110084c:	00a04574 	movhi	r2,33045
81100850:	10b5ad04 	addi	r2,r2,-10572
81100854:	1009883a 	mov	r4,r2
81100858:	00800884 	movi	r2,34
8110085c:	100d883a 	mov	r6,r2
81100860:	200b883a 	mov	r5,r4
81100864:	1809883a 	mov	r4,r3
81100868:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
8110086c:	d0a06217 	ldw	r2,-32376(gp)
81100870:	01604574 	movhi	r5,33045
81100874:	29556904 	addi	r5,r5,21924
81100878:	1009883a 	mov	r4,r2
8110087c:	11236500 	call	81123650 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100880:	00bfe804 	movi	r2,-96
81100884:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess = FALSE;
81100888:	e03fbe15 	stw	zero,-264(fp)
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	switch (ucMemoryId) {
8110088c:	e0bfff03 	ldbu	r2,-4(fp)
81100890:	10000326 	beq	r2,zero,811008a0 <bDdr2EepromDump+0x7c>
81100894:	10800060 	cmpeqi	r2,r2,1
81100898:	10000a1e 	bne	r2,zero,811008c4 <bDdr2EepromDump+0xa0>
8110089c:	00001206 	br	811008e8 <bDdr2EepromDump+0xc4>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
811008a0:	00a00034 	movhi	r2,32768
811008a4:	10827c04 	addi	r2,r2,2544
811008a8:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008ac:	00a00034 	movhi	r2,32768
811008b0:	10828004 	addi	r2,r2,2560
811008b4:	e0bfbb15 	stw	r2,-276(fp)
		bSuccess = TRUE;
811008b8:	00800044 	movi	r2,1
811008bc:	e0bfbe15 	stw	r2,-264(fp)
		break;
811008c0:	00001b06 	br	81100930 <bDdr2EepromDump+0x10c>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008c4:	00a00034 	movhi	r2,32768
811008c8:	10825804 	addi	r2,r2,2400
811008cc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008d0:	00a00034 	movhi	r2,32768
811008d4:	10825c04 	addi	r2,r2,2416
811008d8:	e0bfbb15 	stw	r2,-276(fp)
		bSuccess = TRUE;
811008dc:	00800044 	movi	r2,1
811008e0:	e0bfbe15 	stw	r2,-264(fp)
		break;
811008e4:	00001206 	br	81100930 <bDdr2EepromDump+0x10c>
	default:
		bSuccess = FALSE;
811008e8:	e03fbe15 	stw	zero,-264(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811008ec:	00e04574 	movhi	r3,33045
811008f0:	18d56904 	addi	r3,r3,21924
811008f4:	00a04574 	movhi	r2,33045
811008f8:	10b5b604 	addi	r2,r2,-10536
811008fc:	1009883a 	mov	r4,r2
81100900:	00800bc4 	movi	r2,47
81100904:	100d883a 	mov	r6,r2
81100908:	200b883a 	mov	r5,r4
8110090c:	1809883a 	mov	r4,r3
81100910:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
81100914:	d0a06217 	ldw	r2,-32376(gp)
81100918:	01604574 	movhi	r5,33045
8110091c:	29556904 	addi	r5,r5,21924
81100920:	1009883a 	mov	r4,r2
81100924:	11236500 	call	81123650 <fprintf>
		;
#endif
		return bSuccess;
81100928:	e0bfbe17 	ldw	r2,-264(fp)
8110092c:	0002e706 	br	811014cc <bDdr2EepromDump+0xca8>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100930:	e0bfbd03 	ldbu	r2,-268(fp)
81100934:	10c03fcc 	andi	r3,r2,255
81100938:	18c0201c 	xori	r3,r3,128
8110093c:	18ffe004 	addi	r3,r3,-128
81100940:	e13fbf04 	addi	r4,fp,-260
81100944:	00804004 	movi	r2,256
81100948:	d8800015 	stw	r2,0(sp)
8110094c:	200f883a 	mov	r7,r4
81100950:	180d883a 	mov	r6,r3
81100954:	e17fbb17 	ldw	r5,-276(fp)
81100958:	e13fba17 	ldw	r4,-280(fp)
8110095c:	110b7440 	call	8110b744 <I2C_MultipleRead>
81100960:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
81100964:	e0bfbe17 	ldw	r2,-264(fp)
81100968:	1002be26 	beq	r2,zero,81101464 <bDdr2EepromDump+0xc40>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
8110096c:	e03fbc15 	stw	zero,-272(fp)
81100970:	0002b606 	br	8110144c <bDdr2EepromDump+0xc28>
			if (iI == 0) {
81100974:	e0bfbc17 	ldw	r2,-272(fp)
81100978:	1000121e 	bne	r2,zero,811009c4 <bDdr2EepromDump+0x1a0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
8110097c:	e0ffbf04 	addi	r3,fp,-260
81100980:	e0bfbc17 	ldw	r2,-272(fp)
81100984:	1885883a 	add	r2,r3,r2
81100988:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110098c:	10803fcc 	andi	r2,r2,255
81100990:	100f883a 	mov	r7,r2
81100994:	e1bfbc17 	ldw	r6,-272(fp)
81100998:	01604574 	movhi	r5,33045
8110099c:	2975c204 	addi	r5,r5,-10488
811009a0:	01204574 	movhi	r4,33045
811009a4:	21156904 	addi	r4,r4,21924
811009a8:	1124f640 	call	81124f64 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
811009ac:	d0a06217 	ldw	r2,-32376(gp)
811009b0:	01604574 	movhi	r5,33045
811009b4:	29556904 	addi	r5,r5,21924
811009b8:	1009883a 	mov	r4,r2
811009bc:	11236500 	call	81123650 <fprintf>
811009c0:	00029f06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 1) {
811009c4:	e0bfbc17 	ldw	r2,-272(fp)
811009c8:	10800058 	cmpnei	r2,r2,1
811009cc:	1000101e 	bne	r2,zero,81100a10 <bDdr2EepromDump+0x1ec>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811009d0:	00e04574 	movhi	r3,33045
811009d4:	18d56904 	addi	r3,r3,21924
811009d8:	00a04574 	movhi	r2,33045
811009dc:	10b5ce04 	addi	r2,r2,-10440
811009e0:	1009883a 	mov	r4,r2
811009e4:	00800c04 	movi	r2,48
811009e8:	100d883a 	mov	r6,r2
811009ec:	200b883a 	mov	r5,r4
811009f0:	1809883a 	mov	r4,r3
811009f4:	11247000 	call	81124700 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009f8:	d0a06217 	ldw	r2,-32376(gp)
811009fc:	01604574 	movhi	r5,33045
81100a00:	29556904 	addi	r5,r5,21924
81100a04:	1009883a 	mov	r4,r2
81100a08:	11236500 	call	81123650 <fprintf>
81100a0c:	00028c06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 2) {
81100a10:	e0bfbc17 	ldw	r2,-272(fp)
81100a14:	10800098 	cmpnei	r2,r2,2
81100a18:	1000101e 	bne	r2,zero,81100a5c <bDdr2EepromDump+0x238>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a1c:	00e04574 	movhi	r3,33045
81100a20:	18d56904 	addi	r3,r3,21924
81100a24:	00a04574 	movhi	r2,33045
81100a28:	10b5da04 	addi	r2,r2,-10392
81100a2c:	1009883a 	mov	r4,r2
81100a30:	008007c4 	movi	r2,31
81100a34:	100d883a 	mov	r6,r2
81100a38:	200b883a 	mov	r5,r4
81100a3c:	1809883a 	mov	r4,r3
81100a40:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100a44:	d0a06217 	ldw	r2,-32376(gp)
81100a48:	01604574 	movhi	r5,33045
81100a4c:	29556904 	addi	r5,r5,21924
81100a50:	1009883a 	mov	r4,r2
81100a54:	11236500 	call	81123650 <fprintf>
81100a58:	00027906 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 3) {
81100a5c:	e0bfbc17 	ldw	r2,-272(fp)
81100a60:	108000d8 	cmpnei	r2,r2,3
81100a64:	1000101e 	bne	r2,zero,81100aa8 <bDdr2EepromDump+0x284>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100a68:	00e04574 	movhi	r3,33045
81100a6c:	18d56904 	addi	r3,r3,21924
81100a70:	00a04574 	movhi	r2,33045
81100a74:	10b5e204 	addi	r2,r2,-10360
81100a78:	1009883a 	mov	r4,r2
81100a7c:	008009c4 	movi	r2,39
81100a80:	100d883a 	mov	r6,r2
81100a84:	200b883a 	mov	r5,r4
81100a88:	1809883a 	mov	r4,r3
81100a8c:	11247000 	call	81124700 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a90:	d0a06217 	ldw	r2,-32376(gp)
81100a94:	01604574 	movhi	r5,33045
81100a98:	29556904 	addi	r5,r5,21924
81100a9c:	1009883a 	mov	r4,r2
81100aa0:	11236500 	call	81123650 <fprintf>
81100aa4:	00026606 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 4) {
81100aa8:	e0bfbc17 	ldw	r2,-272(fp)
81100aac:	10800118 	cmpnei	r2,r2,4
81100ab0:	1000101e 	bne	r2,zero,81100af4 <bDdr2EepromDump+0x2d0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ab4:	00e04574 	movhi	r3,33045
81100ab8:	18d56904 	addi	r3,r3,21924
81100abc:	00a04574 	movhi	r2,33045
81100ac0:	10b5ec04 	addi	r2,r2,-10320
81100ac4:	1009883a 	mov	r4,r2
81100ac8:	00800a84 	movi	r2,42
81100acc:	100d883a 	mov	r6,r2
81100ad0:	200b883a 	mov	r5,r4
81100ad4:	1809883a 	mov	r4,r3
81100ad8:	11247000 	call	81124700 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100adc:	d0a06217 	ldw	r2,-32376(gp)
81100ae0:	01604574 	movhi	r5,33045
81100ae4:	29556904 	addi	r5,r5,21924
81100ae8:	1009883a 	mov	r4,r2
81100aec:	11236500 	call	81123650 <fprintf>
81100af0:	00025306 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 5) {
81100af4:	e0bfbc17 	ldw	r2,-272(fp)
81100af8:	10800158 	cmpnei	r2,r2,5
81100afc:	1000101e 	bne	r2,zero,81100b40 <bDdr2EepromDump+0x31c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100b00:	00e04574 	movhi	r3,33045
81100b04:	18d56904 	addi	r3,r3,21924
81100b08:	00a04574 	movhi	r2,33045
81100b0c:	10b5f704 	addi	r2,r2,-10276
81100b10:	1009883a 	mov	r4,r2
81100b14:	00800c04 	movi	r2,48
81100b18:	100d883a 	mov	r6,r2
81100b1c:	200b883a 	mov	r5,r4
81100b20:	1809883a 	mov	r4,r3
81100b24:	11247000 	call	81124700 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b28:	d0a06217 	ldw	r2,-32376(gp)
81100b2c:	01604574 	movhi	r5,33045
81100b30:	29556904 	addi	r5,r5,21924
81100b34:	1009883a 	mov	r4,r2
81100b38:	11236500 	call	81123650 <fprintf>
81100b3c:	00024006 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 6) {
81100b40:	e0bfbc17 	ldw	r2,-272(fp)
81100b44:	10800198 	cmpnei	r2,r2,6
81100b48:	1000101e 	bne	r2,zero,81100b8c <bDdr2EepromDump+0x368>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b4c:	00e04574 	movhi	r3,33045
81100b50:	18d56904 	addi	r3,r3,21924
81100b54:	00a04574 	movhi	r2,33045
81100b58:	10b60304 	addi	r2,r2,-10228
81100b5c:	1009883a 	mov	r4,r2
81100b60:	00800544 	movi	r2,21
81100b64:	100d883a 	mov	r6,r2
81100b68:	200b883a 	mov	r5,r4
81100b6c:	1809883a 	mov	r4,r3
81100b70:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100b74:	d0a06217 	ldw	r2,-32376(gp)
81100b78:	01604574 	movhi	r5,33045
81100b7c:	29556904 	addi	r5,r5,21924
81100b80:	1009883a 	mov	r4,r2
81100b84:	11236500 	call	81123650 <fprintf>
81100b88:	00022d06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 7) {
81100b8c:	e0bfbc17 	ldw	r2,-272(fp)
81100b90:	108001d8 	cmpnei	r2,r2,7
81100b94:	1000101e 	bne	r2,zero,81100bd8 <bDdr2EepromDump+0x3b4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b98:	00e04574 	movhi	r3,33045
81100b9c:	18d56904 	addi	r3,r3,21924
81100ba0:	00a04574 	movhi	r2,33045
81100ba4:	10b60904 	addi	r2,r2,-10204
81100ba8:	1009883a 	mov	r4,r2
81100bac:	00800804 	movi	r2,32
81100bb0:	100d883a 	mov	r6,r2
81100bb4:	200b883a 	mov	r5,r4
81100bb8:	1809883a 	mov	r4,r3
81100bbc:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100bc0:	d0a06217 	ldw	r2,-32376(gp)
81100bc4:	01604574 	movhi	r5,33045
81100bc8:	29556904 	addi	r5,r5,21924
81100bcc:	1009883a 	mov	r4,r2
81100bd0:	11236500 	call	81123650 <fprintf>
81100bd4:	00021a06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 16) {
81100bd8:	e0bfbc17 	ldw	r2,-272(fp)
81100bdc:	10800418 	cmpnei	r2,r2,16
81100be0:	1000101e 	bne	r2,zero,81100c24 <bDdr2EepromDump+0x400>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100be4:	00e04574 	movhi	r3,33045
81100be8:	18d56904 	addi	r3,r3,21924
81100bec:	00a04574 	movhi	r2,33045
81100bf0:	10b61104 	addi	r2,r2,-10172
81100bf4:	1009883a 	mov	r4,r2
81100bf8:	00800d04 	movi	r2,52
81100bfc:	100d883a 	mov	r6,r2
81100c00:	200b883a 	mov	r5,r4
81100c04:	1809883a 	mov	r4,r3
81100c08:	11247000 	call	81124700 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100c0c:	d0a06217 	ldw	r2,-32376(gp)
81100c10:	01604574 	movhi	r5,33045
81100c14:	29556904 	addi	r5,r5,21924
81100c18:	1009883a 	mov	r4,r2
81100c1c:	11236500 	call	81123650 <fprintf>
81100c20:	00020706 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 13) {
81100c24:	e0bfbc17 	ldw	r2,-272(fp)
81100c28:	10800358 	cmpnei	r2,r2,13
81100c2c:	1000101e 	bne	r2,zero,81100c70 <bDdr2EepromDump+0x44c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c30:	00e04574 	movhi	r3,33045
81100c34:	18d56904 	addi	r3,r3,21924
81100c38:	00a04574 	movhi	r2,33045
81100c3c:	10b61e04 	addi	r2,r2,-10120
81100c40:	1009883a 	mov	r4,r2
81100c44:	008005c4 	movi	r2,23
81100c48:	100d883a 	mov	r6,r2
81100c4c:	200b883a 	mov	r5,r4
81100c50:	1809883a 	mov	r4,r3
81100c54:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100c58:	d0a06217 	ldw	r2,-32376(gp)
81100c5c:	01604574 	movhi	r5,33045
81100c60:	29556904 	addi	r5,r5,21924
81100c64:	1009883a 	mov	r4,r2
81100c68:	11236500 	call	81123650 <fprintf>
81100c6c:	0001f406 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 14) {
81100c70:	e0bfbc17 	ldw	r2,-272(fp)
81100c74:	10800398 	cmpnei	r2,r2,14
81100c78:	1000101e 	bne	r2,zero,81100cbc <bDdr2EepromDump+0x498>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c7c:	00e04574 	movhi	r3,33045
81100c80:	18d56904 	addi	r3,r3,21924
81100c84:	00a04574 	movhi	r2,33045
81100c88:	10b62404 	addi	r2,r2,-10096
81100c8c:	1009883a 	mov	r4,r2
81100c90:	008004c4 	movi	r2,19
81100c94:	100d883a 	mov	r6,r2
81100c98:	200b883a 	mov	r5,r4
81100c9c:	1809883a 	mov	r4,r3
81100ca0:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100ca4:	d0a06217 	ldw	r2,-32376(gp)
81100ca8:	01604574 	movhi	r5,33045
81100cac:	29556904 	addi	r5,r5,21924
81100cb0:	1009883a 	mov	r4,r2
81100cb4:	11236500 	call	81123650 <fprintf>
81100cb8:	0001e106 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 17) {
81100cbc:	e0bfbc17 	ldw	r2,-272(fp)
81100cc0:	10800458 	cmpnei	r2,r2,17
81100cc4:	1000101e 	bne	r2,zero,81100d08 <bDdr2EepromDump+0x4e4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cc8:	00e04574 	movhi	r3,33045
81100ccc:	18d56904 	addi	r3,r3,21924
81100cd0:	00a04574 	movhi	r2,33045
81100cd4:	10b62904 	addi	r2,r2,-10076
81100cd8:	1009883a 	mov	r4,r2
81100cdc:	00800684 	movi	r2,26
81100ce0:	100d883a 	mov	r6,r2
81100ce4:	200b883a 	mov	r5,r4
81100ce8:	1809883a 	mov	r4,r3
81100cec:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100cf0:	d0a06217 	ldw	r2,-32376(gp)
81100cf4:	01604574 	movhi	r5,33045
81100cf8:	29556904 	addi	r5,r5,21924
81100cfc:	1009883a 	mov	r4,r2
81100d00:	11236500 	call	81123650 <fprintf>
81100d04:	0001ce06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 18) {
81100d08:	e0bfbc17 	ldw	r2,-272(fp)
81100d0c:	10800498 	cmpnei	r2,r2,18
81100d10:	1000101e 	bne	r2,zero,81100d54 <bDdr2EepromDump+0x530>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100d14:	00e04574 	movhi	r3,33045
81100d18:	18d56904 	addi	r3,r3,21924
81100d1c:	00a04574 	movhi	r2,33045
81100d20:	10b63004 	addi	r2,r2,-10048
81100d24:	1009883a 	mov	r4,r2
81100d28:	00800d44 	movi	r2,53
81100d2c:	100d883a 	mov	r6,r2
81100d30:	200b883a 	mov	r5,r4
81100d34:	1809883a 	mov	r4,r3
81100d38:	11247000 	call	81124700 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d3c:	d0a06217 	ldw	r2,-32376(gp)
81100d40:	01604574 	movhi	r5,33045
81100d44:	29556904 	addi	r5,r5,21924
81100d48:	1009883a 	mov	r4,r2
81100d4c:	11236500 	call	81123650 <fprintf>
81100d50:	0001bb06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 20) {
81100d54:	e0bfbc17 	ldw	r2,-272(fp)
81100d58:	10800518 	cmpnei	r2,r2,20
81100d5c:	1000101e 	bne	r2,zero,81100da0 <bDdr2EepromDump+0x57c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100d60:	00e04574 	movhi	r3,33045
81100d64:	18d56904 	addi	r3,r3,21924
81100d68:	00a04574 	movhi	r2,33045
81100d6c:	10b63e04 	addi	r2,r2,-9992
81100d70:	1009883a 	mov	r4,r2
81100d74:	00801204 	movi	r2,72
81100d78:	100d883a 	mov	r6,r2
81100d7c:	200b883a 	mov	r5,r4
81100d80:	1809883a 	mov	r4,r3
81100d84:	11247000 	call	81124700 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d88:	d0a06217 	ldw	r2,-32376(gp)
81100d8c:	01604574 	movhi	r5,33045
81100d90:	29556904 	addi	r5,r5,21924
81100d94:	1009883a 	mov	r4,r2
81100d98:	11236500 	call	81123650 <fprintf>
81100d9c:	0001a806 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 22) {
81100da0:	e0bfbc17 	ldw	r2,-272(fp)
81100da4:	10800598 	cmpnei	r2,r2,22
81100da8:	1000101e 	bne	r2,zero,81100dec <bDdr2EepromDump+0x5c8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100dac:	00e04574 	movhi	r3,33045
81100db0:	18d56904 	addi	r3,r3,21924
81100db4:	00a04574 	movhi	r2,33045
81100db8:	10b65004 	addi	r2,r2,-9920
81100dbc:	1009883a 	mov	r4,r2
81100dc0:	00800784 	movi	r2,30
81100dc4:	100d883a 	mov	r6,r2
81100dc8:	200b883a 	mov	r5,r4
81100dcc:	1809883a 	mov	r4,r3
81100dd0:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81100dd4:	d0a06217 	ldw	r2,-32376(gp)
81100dd8:	01604574 	movhi	r5,33045
81100ddc:	29556904 	addi	r5,r5,21924
81100de0:	1009883a 	mov	r4,r2
81100de4:	11236500 	call	81123650 <fprintf>
81100de8:	00019506 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 27) {
81100dec:	e0bfbc17 	ldw	r2,-272(fp)
81100df0:	108006d8 	cmpnei	r2,r2,27
81100df4:	1000101e 	bne	r2,zero,81100e38 <bDdr2EepromDump+0x614>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100df8:	00e04574 	movhi	r3,33045
81100dfc:	18d56904 	addi	r3,r3,21924
81100e00:	00a04574 	movhi	r2,33045
81100e04:	10b65804 	addi	r2,r2,-9888
81100e08:	1009883a 	mov	r4,r2
81100e0c:	00800a04 	movi	r2,40
81100e10:	100d883a 	mov	r6,r2
81100e14:	200b883a 	mov	r5,r4
81100e18:	1809883a 	mov	r4,r3
81100e1c:	11247000 	call	81124700 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e20:	d0a06217 	ldw	r2,-32376(gp)
81100e24:	01604574 	movhi	r5,33045
81100e28:	29556904 	addi	r5,r5,21924
81100e2c:	1009883a 	mov	r4,r2
81100e30:	11236500 	call	81123650 <fprintf>
81100e34:	00018206 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 28) {
81100e38:	e0bfbc17 	ldw	r2,-272(fp)
81100e3c:	10800718 	cmpnei	r2,r2,28
81100e40:	1000101e 	bne	r2,zero,81100e84 <bDdr2EepromDump+0x660>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e44:	00e04574 	movhi	r3,33045
81100e48:	18d56904 	addi	r3,r3,21924
81100e4c:	00a04574 	movhi	r2,33045
81100e50:	10b66204 	addi	r2,r2,-9848
81100e54:	1009883a 	mov	r4,r2
81100e58:	00800cc4 	movi	r2,51
81100e5c:	100d883a 	mov	r6,r2
81100e60:	200b883a 	mov	r5,r4
81100e64:	1809883a 	mov	r4,r3
81100e68:	11247000 	call	81124700 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e6c:	d0a06217 	ldw	r2,-32376(gp)
81100e70:	01604574 	movhi	r5,33045
81100e74:	29556904 	addi	r5,r5,21924
81100e78:	1009883a 	mov	r4,r2
81100e7c:	11236500 	call	81123650 <fprintf>
81100e80:	00016f06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 29) {
81100e84:	e0bfbc17 	ldw	r2,-272(fp)
81100e88:	10800758 	cmpnei	r2,r2,29
81100e8c:	1000101e 	bne	r2,zero,81100ed0 <bDdr2EepromDump+0x6ac>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e90:	00e04574 	movhi	r3,33045
81100e94:	18d56904 	addi	r3,r3,21924
81100e98:	00a04574 	movhi	r2,33045
81100e9c:	10b66f04 	addi	r2,r2,-9796
81100ea0:	1009883a 	mov	r4,r2
81100ea4:	008009c4 	movi	r2,39
81100ea8:	100d883a 	mov	r6,r2
81100eac:	200b883a 	mov	r5,r4
81100eb0:	1809883a 	mov	r4,r3
81100eb4:	11247000 	call	81124700 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100eb8:	d0a06217 	ldw	r2,-32376(gp)
81100ebc:	01604574 	movhi	r5,33045
81100ec0:	29556904 	addi	r5,r5,21924
81100ec4:	1009883a 	mov	r4,r2
81100ec8:	11236500 	call	81123650 <fprintf>
81100ecc:	00015c06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 30) {
81100ed0:	e0bfbc17 	ldw	r2,-272(fp)
81100ed4:	10800798 	cmpnei	r2,r2,30
81100ed8:	1000101e 	bne	r2,zero,81100f1c <bDdr2EepromDump+0x6f8>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100edc:	00e04574 	movhi	r3,33045
81100ee0:	18d56904 	addi	r3,r3,21924
81100ee4:	00a04574 	movhi	r2,33045
81100ee8:	10b67904 	addi	r2,r2,-9756
81100eec:	1009883a 	mov	r4,r2
81100ef0:	00800b04 	movi	r2,44
81100ef4:	100d883a 	mov	r6,r2
81100ef8:	200b883a 	mov	r5,r4
81100efc:	1809883a 	mov	r4,r3
81100f00:	11247000 	call	81124700 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100f04:	d0a06217 	ldw	r2,-32376(gp)
81100f08:	01604574 	movhi	r5,33045
81100f0c:	29556904 	addi	r5,r5,21924
81100f10:	1009883a 	mov	r4,r2
81100f14:	11236500 	call	81123650 <fprintf>
81100f18:	00014906 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 31) {
81100f1c:	e0bfbc17 	ldw	r2,-272(fp)
81100f20:	108007d8 	cmpnei	r2,r2,31
81100f24:	1000101e 	bne	r2,zero,81100f68 <bDdr2EepromDump+0x744>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f28:	00e04574 	movhi	r3,33045
81100f2c:	18d56904 	addi	r3,r3,21924
81100f30:	00a04574 	movhi	r2,33045
81100f34:	10b68404 	addi	r2,r2,-9712
81100f38:	1009883a 	mov	r4,r2
81100f3c:	008010c4 	movi	r2,67
81100f40:	100d883a 	mov	r6,r2
81100f44:	200b883a 	mov	r5,r4
81100f48:	1809883a 	mov	r4,r3
81100f4c:	11247000 	call	81124700 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f50:	d0a06217 	ldw	r2,-32376(gp)
81100f54:	01604574 	movhi	r5,33045
81100f58:	29556904 	addi	r5,r5,21924
81100f5c:	1009883a 	mov	r4,r2
81100f60:	11236500 	call	81123650 <fprintf>
81100f64:	00013606 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 36) {
81100f68:	e0bfbc17 	ldw	r2,-272(fp)
81100f6c:	10800918 	cmpnei	r2,r2,36
81100f70:	1000101e 	bne	r2,zero,81100fb4 <bDdr2EepromDump+0x790>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f74:	00e04574 	movhi	r3,33045
81100f78:	18d56904 	addi	r3,r3,21924
81100f7c:	00a04574 	movhi	r2,33045
81100f80:	10b69504 	addi	r2,r2,-9644
81100f84:	1009883a 	mov	r4,r2
81100f88:	00800a84 	movi	r2,42
81100f8c:	100d883a 	mov	r6,r2
81100f90:	200b883a 	mov	r5,r4
81100f94:	1809883a 	mov	r4,r3
81100f98:	11247000 	call	81124700 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f9c:	d0a06217 	ldw	r2,-32376(gp)
81100fa0:	01604574 	movhi	r5,33045
81100fa4:	29556904 	addi	r5,r5,21924
81100fa8:	1009883a 	mov	r4,r2
81100fac:	11236500 	call	81123650 <fprintf>
81100fb0:	00012306 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 37) {
81100fb4:	e0bfbc17 	ldw	r2,-272(fp)
81100fb8:	10800958 	cmpnei	r2,r2,37
81100fbc:	1000101e 	bne	r2,zero,81101000 <bDdr2EepromDump+0x7dc>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100fc0:	00e04574 	movhi	r3,33045
81100fc4:	18d56904 	addi	r3,r3,21924
81100fc8:	00a04574 	movhi	r2,33045
81100fcc:	10b6a004 	addi	r2,r2,-9600
81100fd0:	1009883a 	mov	r4,r2
81100fd4:	00800cc4 	movi	r2,51
81100fd8:	100d883a 	mov	r6,r2
81100fdc:	200b883a 	mov	r5,r4
81100fe0:	1809883a 	mov	r4,r3
81100fe4:	11247000 	call	81124700 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fe8:	d0a06217 	ldw	r2,-32376(gp)
81100fec:	01604574 	movhi	r5,33045
81100ff0:	29556904 	addi	r5,r5,21924
81100ff4:	1009883a 	mov	r4,r2
81100ff8:	11236500 	call	81123650 <fprintf>
81100ffc:	00011006 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 38) {
81101000:	e0bfbc17 	ldw	r2,-272(fp)
81101004:	10800998 	cmpnei	r2,r2,38
81101008:	1000101e 	bne	r2,zero,8110104c <bDdr2EepromDump+0x828>
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110100c:	00e04574 	movhi	r3,33045
81101010:	18d56904 	addi	r3,r3,21924
81101014:	00a04574 	movhi	r2,33045
81101018:	10b6ad04 	addi	r2,r2,-9548
8110101c:	1009883a 	mov	r4,r2
81101020:	00800dc4 	movi	r2,55
81101024:	100d883a 	mov	r6,r2
81101028:	200b883a 	mov	r5,r4
8110102c:	1809883a 	mov	r4,r3
81101030:	11247000 	call	81124700 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
81101034:	d0a06217 	ldw	r2,-32376(gp)
81101038:	01604574 	movhi	r5,33045
8110103c:	29556904 	addi	r5,r5,21924
81101040:	1009883a 	mov	r4,r2
81101044:	11236500 	call	81123650 <fprintf>
81101048:	0000fd06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 41) {
8110104c:	e0bfbc17 	ldw	r2,-272(fp)
81101050:	10800a58 	cmpnei	r2,r2,41
81101054:	1000101e 	bne	r2,zero,81101098 <bDdr2EepromDump+0x874>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101058:	00e04574 	movhi	r3,33045
8110105c:	18d56904 	addi	r3,r3,21924
81101060:	00a04574 	movhi	r2,33045
81101064:	10b6bb04 	addi	r2,r2,-9492
81101068:	1009883a 	mov	r4,r2
8110106c:	00800c84 	movi	r2,50
81101070:	100d883a 	mov	r6,r2
81101074:	200b883a 	mov	r5,r4
81101078:	1809883a 	mov	r4,r3
8110107c:	11247000 	call	81124700 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101080:	d0a06217 	ldw	r2,-32376(gp)
81101084:	01604574 	movhi	r5,33045
81101088:	29556904 	addi	r5,r5,21924
8110108c:	1009883a 	mov	r4,r2
81101090:	11236500 	call	81123650 <fprintf>
81101094:	0000ea06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 42) {
81101098:	e0bfbc17 	ldw	r2,-272(fp)
8110109c:	10800a98 	cmpnei	r2,r2,42
811010a0:	1000101e 	bne	r2,zero,811010e4 <bDdr2EepromDump+0x8c0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811010a4:	00e04574 	movhi	r3,33045
811010a8:	18d56904 	addi	r3,r3,21924
811010ac:	00a04574 	movhi	r2,33045
811010b0:	10b6c804 	addi	r2,r2,-9440
811010b4:	1009883a 	mov	r4,r2
811010b8:	00800cc4 	movi	r2,51
811010bc:	100d883a 	mov	r6,r2
811010c0:	200b883a 	mov	r5,r4
811010c4:	1809883a 	mov	r4,r3
811010c8:	11247000 	call	81124700 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010cc:	d0a06217 	ldw	r2,-32376(gp)
811010d0:	01604574 	movhi	r5,33045
811010d4:	29556904 	addi	r5,r5,21924
811010d8:	1009883a 	mov	r4,r2
811010dc:	11236500 	call	81123650 <fprintf>
811010e0:	0000d706 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 62) {
811010e4:	e0bfbc17 	ldw	r2,-272(fp)
811010e8:	10800f98 	cmpnei	r2,r2,62
811010ec:	1000101e 	bne	r2,zero,81101130 <bDdr2EepromDump+0x90c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010f0:	00e04574 	movhi	r3,33045
811010f4:	18d56904 	addi	r3,r3,21924
811010f8:	00a04574 	movhi	r2,33045
811010fc:	10b6d504 	addi	r2,r2,-9388
81101100:	1009883a 	mov	r4,r2
81101104:	00800404 	movi	r2,16
81101108:	100d883a 	mov	r6,r2
8110110c:	200b883a 	mov	r5,r4
81101110:	1809883a 	mov	r4,r3
81101114:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81101118:	d0a06217 	ldw	r2,-32376(gp)
8110111c:	01604574 	movhi	r5,33045
81101120:	29556904 	addi	r5,r5,21924
81101124:	1009883a 	mov	r4,r2
81101128:	11236500 	call	81123650 <fprintf>
8110112c:	0000c406 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 63) {
81101130:	e0bfbc17 	ldw	r2,-272(fp)
81101134:	10800fd8 	cmpnei	r2,r2,63
81101138:	10001f1e 	bne	r2,zero,811011b8 <bDdr2EepromDump+0x994>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
8110113c:	00a04574 	movhi	r2,33045
81101140:	10956904 	addi	r2,r2,21924
81101144:	00c00a04 	movi	r3,40
81101148:	10c00005 	stb	r3,0(r2)
8110114c:	00c010c4 	movi	r3,67
81101150:	10c00045 	stb	r3,1(r2)
81101154:	00c01a04 	movi	r3,104
81101158:	10c00085 	stb	r3,2(r2)
8110115c:	00c01944 	movi	r3,101
81101160:	10c000c5 	stb	r3,3(r2)
81101164:	00c018c4 	movi	r3,99
81101168:	10c00105 	stb	r3,4(r2)
8110116c:	00c01ac4 	movi	r3,107
81101170:	10c00145 	stb	r3,5(r2)
81101174:	00c01cc4 	movi	r3,115
81101178:	10c00185 	stb	r3,6(r2)
8110117c:	00c01d44 	movi	r3,117
81101180:	10c001c5 	stb	r3,7(r2)
81101184:	00c01b44 	movi	r3,109
81101188:	10c00205 	stb	r3,8(r2)
8110118c:	00c00a44 	movi	r3,41
81101190:	10c00245 	stb	r3,9(r2)
81101194:	00c00284 	movi	r3,10
81101198:	10c00285 	stb	r3,10(r2)
8110119c:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
811011a0:	d0a06217 	ldw	r2,-32376(gp)
811011a4:	01604574 	movhi	r5,33045
811011a8:	29556904 	addi	r5,r5,21924
811011ac:	1009883a 	mov	r4,r2
811011b0:	11236500 	call	81123650 <fprintf>
811011b4:	0000a206 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 64) {
811011b8:	e0bfbc17 	ldw	r2,-272(fp)
811011bc:	10801018 	cmpnei	r2,r2,64
811011c0:	1000101e 	bne	r2,zero,81101204 <bDdr2EepromDump+0x9e0>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011c4:	00e04574 	movhi	r3,33045
811011c8:	18d56904 	addi	r3,r3,21924
811011cc:	00a04574 	movhi	r2,33045
811011d0:	10b6d904 	addi	r2,r2,-9372
811011d4:	1009883a 	mov	r4,r2
811011d8:	00800804 	movi	r2,32
811011dc:	100d883a 	mov	r6,r2
811011e0:	200b883a 	mov	r5,r4
811011e4:	1809883a 	mov	r4,r3
811011e8:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
811011ec:	d0a06217 	ldw	r2,-32376(gp)
811011f0:	01604574 	movhi	r5,33045
811011f4:	29556904 	addi	r5,r5,21924
811011f8:	1009883a 	mov	r4,r2
811011fc:	11236500 	call	81123650 <fprintf>
81101200:	00008f06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 72) {
81101204:	e0bfbc17 	ldw	r2,-272(fp)
81101208:	10801218 	cmpnei	r2,r2,72
8110120c:	1000101e 	bne	r2,zero,81101250 <bDdr2EepromDump+0xa2c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101210:	00e04574 	movhi	r3,33045
81101214:	18d56904 	addi	r3,r3,21924
81101218:	00a04574 	movhi	r2,33045
8110121c:	10b6e104 	addi	r2,r2,-9340
81101220:	1009883a 	mov	r4,r2
81101224:	00800dc4 	movi	r2,55
81101228:	100d883a 	mov	r6,r2
8110122c:	200b883a 	mov	r5,r4
81101230:	1809883a 	mov	r4,r3
81101234:	11247000 	call	81124700 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101238:	d0a06217 	ldw	r2,-32376(gp)
8110123c:	01604574 	movhi	r5,33045
81101240:	29556904 	addi	r5,r5,21924
81101244:	1009883a 	mov	r4,r2
81101248:	11236500 	call	81123650 <fprintf>
8110124c:	00007c06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 73) {
81101250:	e0bfbc17 	ldw	r2,-272(fp)
81101254:	10801258 	cmpnei	r2,r2,73
81101258:	1000101e 	bne	r2,zero,8110129c <bDdr2EepromDump+0xa78>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
8110125c:	00e04574 	movhi	r3,33045
81101260:	18d56904 	addi	r3,r3,21924
81101264:	00a04574 	movhi	r2,33045
81101268:	10b6ef04 	addi	r2,r2,-9284
8110126c:	1009883a 	mov	r4,r2
81101270:	00800784 	movi	r2,30
81101274:	100d883a 	mov	r6,r2
81101278:	200b883a 	mov	r5,r4
8110127c:	1809883a 	mov	r4,r3
81101280:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81101284:	d0a06217 	ldw	r2,-32376(gp)
81101288:	01604574 	movhi	r5,33045
8110128c:	29556904 	addi	r5,r5,21924
81101290:	1009883a 	mov	r4,r2
81101294:	11236500 	call	81123650 <fprintf>
81101298:	00006906 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 91) {
8110129c:	e0bfbc17 	ldw	r2,-272(fp)
811012a0:	108016d8 	cmpnei	r2,r2,91
811012a4:	1000101e 	bne	r2,zero,811012e8 <bDdr2EepromDump+0xac4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
811012a8:	00e04574 	movhi	r3,33045
811012ac:	18d56904 	addi	r3,r3,21924
811012b0:	00a04574 	movhi	r2,33045
811012b4:	10b6f704 	addi	r2,r2,-9252
811012b8:	1009883a 	mov	r4,r2
811012bc:	00800804 	movi	r2,32
811012c0:	100d883a 	mov	r6,r2
811012c4:	200b883a 	mov	r5,r4
811012c8:	1809883a 	mov	r4,r3
811012cc:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
811012d0:	d0a06217 	ldw	r2,-32376(gp)
811012d4:	01604574 	movhi	r5,33045
811012d8:	29556904 	addi	r5,r5,21924
811012dc:	1009883a 	mov	r4,r2
811012e0:	11236500 	call	81123650 <fprintf>
811012e4:	00005606 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 93) {
811012e8:	e0bfbc17 	ldw	r2,-272(fp)
811012ec:	10801758 	cmpnei	r2,r2,93
811012f0:	1000101e 	bne	r2,zero,81101334 <bDdr2EepromDump+0xb10>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811012f4:	00e04574 	movhi	r3,33045
811012f8:	18d56904 	addi	r3,r3,21924
811012fc:	00a04574 	movhi	r2,33045
81101300:	10b6ff04 	addi	r2,r2,-9220
81101304:	1009883a 	mov	r4,r2
81101308:	008009c4 	movi	r2,39
8110130c:	100d883a 	mov	r6,r2
81101310:	200b883a 	mov	r5,r4
81101314:	1809883a 	mov	r4,r3
81101318:	11247000 	call	81124700 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
8110131c:	d0a06217 	ldw	r2,-32376(gp)
81101320:	01604574 	movhi	r5,33045
81101324:	29556904 	addi	r5,r5,21924
81101328:	1009883a 	mov	r4,r2
8110132c:	11236500 	call	81123650 <fprintf>
81101330:	00004306 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 94) {
81101334:	e0bfbc17 	ldw	r2,-272(fp)
81101338:	10801798 	cmpnei	r2,r2,94
8110133c:	1000101e 	bne	r2,zero,81101380 <bDdr2EepromDump+0xb5c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101340:	00e04574 	movhi	r3,33045
81101344:	18d56904 	addi	r3,r3,21924
81101348:	00a04574 	movhi	r2,33045
8110134c:	10b70904 	addi	r2,r2,-9180
81101350:	1009883a 	mov	r4,r2
81101354:	008006c4 	movi	r2,27
81101358:	100d883a 	mov	r6,r2
8110135c:	200b883a 	mov	r5,r4
81101360:	1809883a 	mov	r4,r3
81101364:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81101368:	d0a06217 	ldw	r2,-32376(gp)
8110136c:	01604574 	movhi	r5,33045
81101370:	29556904 	addi	r5,r5,21924
81101374:	1009883a 	mov	r4,r2
81101378:	11236500 	call	81123650 <fprintf>
8110137c:	00003006 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 95) {
81101380:	e0bfbc17 	ldw	r2,-272(fp)
81101384:	108017d8 	cmpnei	r2,r2,95
81101388:	1000101e 	bne	r2,zero,811013cc <bDdr2EepromDump+0xba8>
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110138c:	00e04574 	movhi	r3,33045
81101390:	18d56904 	addi	r3,r3,21924
81101394:	00a04574 	movhi	r2,33045
81101398:	10b71004 	addi	r2,r2,-9152
8110139c:	1009883a 	mov	r4,r2
811013a0:	00800a04 	movi	r2,40
811013a4:	100d883a 	mov	r6,r2
811013a8:	200b883a 	mov	r5,r4
811013ac:	1809883a 	mov	r4,r3
811013b0:	11247000 	call	81124700 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
811013b4:	d0a06217 	ldw	r2,-32376(gp)
811013b8:	01604574 	movhi	r5,33045
811013bc:	29556904 	addi	r5,r5,21924
811013c0:	1009883a 	mov	r4,r2
811013c4:	11236500 	call	81123650 <fprintf>
811013c8:	00001d06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 99) {
811013cc:	e0bfbc17 	ldw	r2,-272(fp)
811013d0:	108018d8 	cmpnei	r2,r2,99
811013d4:	1000101e 	bne	r2,zero,81101418 <bDdr2EepromDump+0xbf4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013d8:	00e04574 	movhi	r3,33045
811013dc:	18d56904 	addi	r3,r3,21924
811013e0:	00a04574 	movhi	r2,33045
811013e4:	10b71a04 	addi	r2,r2,-9112
811013e8:	1009883a 	mov	r4,r2
811013ec:	00800984 	movi	r2,38
811013f0:	100d883a 	mov	r6,r2
811013f4:	200b883a 	mov	r5,r4
811013f8:	1809883a 	mov	r4,r3
811013fc:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81101400:	d0a06217 	ldw	r2,-32376(gp)
81101404:	01604574 	movhi	r5,33045
81101408:	29556904 	addi	r5,r5,21924
8110140c:	1009883a 	mov	r4,r2
81101410:	11236500 	call	81123650 <fprintf>
81101414:	00000a06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101418:	00a04574 	movhi	r2,33045
8110141c:	10956904 	addi	r2,r2,21924
81101420:	00c00284 	movi	r3,10
81101424:	10c00005 	stb	r3,0(r2)
81101428:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
8110142c:	d0a06217 	ldw	r2,-32376(gp)
81101430:	01604574 	movhi	r5,33045
81101434:	29556904 	addi	r5,r5,21924
81101438:	1009883a 	mov	r4,r2
8110143c:	11236500 	call	81123650 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101440:	e0bfbc17 	ldw	r2,-272(fp)
81101444:	10800044 	addi	r2,r2,1
81101448:	e0bfbc15 	stw	r2,-272(fp)
8110144c:	e0bfbc17 	ldw	r2,-272(fp)
81101450:	10804008 	cmpgei	r2,r2,256
81101454:	1000121e 	bne	r2,zero,811014a0 <bDdr2EepromDump+0xc7c>
81101458:	e0bfbe17 	ldw	r2,-264(fp)
8110145c:	103d451e 	bne	r2,zero,81100974 <__reset+0xfb0e0974>
81101460:	00000f06 	br	811014a0 <bDdr2EepromDump+0xc7c>
#endif
			}
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
81101464:	00e04574 	movhi	r3,33045
81101468:	18d56904 	addi	r3,r3,21924
8110146c:	00a04574 	movhi	r2,33045
81101470:	10b72404 	addi	r2,r2,-9072
81101474:	1009883a 	mov	r4,r2
81101478:	008005c4 	movi	r2,23
8110147c:	100d883a 	mov	r6,r2
81101480:	200b883a 	mov	r5,r4
81101484:	1809883a 	mov	r4,r3
81101488:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
8110148c:	d0a06217 	ldw	r2,-32376(gp)
81101490:	01604574 	movhi	r5,33045
81101494:	29556904 	addi	r5,r5,21924
81101498:	1009883a 	mov	r4,r2
8110149c:	11236500 	call	81123650 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811014a0:	00a04574 	movhi	r2,33045
811014a4:	10956904 	addi	r2,r2,21924
811014a8:	00c00284 	movi	r3,10
811014ac:	10c00005 	stb	r3,0(r2)
811014b0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811014b4:	d0a06217 	ldw	r2,-32376(gp)
811014b8:	01604574 	movhi	r5,33045
811014bc:	29556904 	addi	r5,r5,21924
811014c0:	1009883a 	mov	r4,r2
811014c4:	11236500 	call	81123650 <fprintf>
#endif

	return bSuccess;
811014c8:	e0bfbe17 	ldw	r2,-264(fp)
}
811014cc:	e037883a 	mov	sp,fp
811014d0:	dfc00117 	ldw	ra,4(sp)
811014d4:	df000017 	ldw	fp,0(sp)
811014d8:	dec00204 	addi	sp,sp,8
811014dc:	f800283a 	ret

811014e0 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014e0:	defffb04 	addi	sp,sp,-20
811014e4:	de00012e 	bgeu	sp,et,811014ec <bDdr2SwitchMemory+0xc>
811014e8:	003b68fa 	trap	3
811014ec:	dfc00415 	stw	ra,16(sp)
811014f0:	df000315 	stw	fp,12(sp)
811014f4:	df000304 	addi	fp,sp,12
811014f8:	2005883a 	mov	r2,r4
811014fc:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess = FALSE;
81101500:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
81101504:	00a04834 	movhi	r2,33056
81101508:	108c2204 	addi	r2,r2,12424
8110150c:	e0bffe15 	stw	r2,-8(fp)

	switch (ucMemoryId) {
81101510:	e0bfff03 	ldbu	r2,-4(fp)
81101514:	10000326 	beq	r2,zero,81101524 <bDdr2SwitchMemory+0x44>
81101518:	10800060 	cmpeqi	r2,r2,1
8110151c:	1000061e 	bne	r2,zero,81101538 <bDdr2SwitchMemory+0x58>
81101520:	00000b06 	br	81101550 <bDdr2SwitchMemory+0x70>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101524:	e0bffe17 	ldw	r2,-8(fp)
81101528:	10000015 	stw	zero,0(r2)
		bSuccess = TRUE;
8110152c:	00800044 	movi	r2,1
81101530:	e0bffd15 	stw	r2,-12(fp)
		break;
81101534:	00001606 	br	81101590 <bDdr2SwitchMemory+0xb0>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
81101538:	e0bffe17 	ldw	r2,-8(fp)
8110153c:	00e00034 	movhi	r3,32768
81101540:	10c00015 	stw	r3,0(r2)
		bSuccess = TRUE;
81101544:	00800044 	movi	r2,1
81101548:	e0bffd15 	stw	r2,-12(fp)
		break;
8110154c:	00001006 	br	81101590 <bDdr2SwitchMemory+0xb0>
	default:
		bSuccess = FALSE;
81101550:	e03ffd15 	stw	zero,-12(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101554:	00e04574 	movhi	r3,33045
81101558:	18d56904 	addi	r3,r3,21924
8110155c:	00a04574 	movhi	r2,33045
81101560:	10b72a04 	addi	r2,r2,-9048
81101564:	1009883a 	mov	r4,r2
81101568:	00800f04 	movi	r2,60
8110156c:	100d883a 	mov	r6,r2
81101570:	200b883a 	mov	r5,r4
81101574:	1809883a 	mov	r4,r3
81101578:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
8110157c:	d0a06217 	ldw	r2,-32376(gp)
81101580:	01604574 	movhi	r5,33045
81101584:	29556904 	addi	r5,r5,21924
81101588:	1009883a 	mov	r4,r2
8110158c:	11236500 	call	81123650 <fprintf>
		;
#endif
	}

	return bSuccess;
81101590:	e0bffd17 	ldw	r2,-12(fp)
}
81101594:	e037883a 	mov	sp,fp
81101598:	dfc00117 	ldw	ra,4(sp)
8110159c:	df000017 	ldw	fp,0(sp)
811015a0:	dec00204 	addi	sp,sp,8
811015a4:	f800283a 	ret

811015a8 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
811015a8:	deffe204 	addi	sp,sp,-120
811015ac:	de00012e 	bgeu	sp,et,811015b4 <bDdr2MemoryWriteTest+0xc>
811015b0:	003b68fa 	trap	3
811015b4:	dfc01d15 	stw	ra,116(sp)
811015b8:	df001c15 	stw	fp,112(sp)
811015bc:	dc401b15 	stw	r17,108(sp)
811015c0:	dc001a15 	stw	r16,104(sp)
811015c4:	df001c04 	addi	fp,sp,112
811015c8:	2005883a 	mov	r2,r4
811015cc:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015d0:	00e04574 	movhi	r3,33045
811015d4:	18d56904 	addi	r3,r3,21924
811015d8:	00a04574 	movhi	r2,33045
811015dc:	10b73904 	addi	r2,r2,-8988
811015e0:	1009883a 	mov	r4,r2
811015e4:	00800a04 	movi	r2,40
811015e8:	100d883a 	mov	r6,r2
811015ec:	200b883a 	mov	r5,r4
811015f0:	1809883a 	mov	r4,r3
811015f4:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
811015f8:	d0a06217 	ldw	r2,-32376(gp)
811015fc:	01604574 	movhi	r5,33045
81101600:	29556904 	addi	r5,r5,21924
81101604:	1009883a 	mov	r4,r2
81101608:	11236500 	call	81123650 <fprintf>
#endif
	bool bSuccess = FALSE;
8110160c:	e03fe515 	stw	zero,-108(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
81101610:	e0bffd03 	ldbu	r2,-12(fp)
81101614:	10000326 	beq	r2,zero,81101624 <bDdr2MemoryWriteTest+0x7c>
81101618:	10800060 	cmpeqi	r2,r2,1
8110161c:	10000a1e 	bne	r2,zero,81101648 <bDdr2MemoryWriteTest+0xa0>
81101620:	00001206 	br	8110166c <bDdr2MemoryWriteTest+0xc4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101624:	e0bffd03 	ldbu	r2,-12(fp)
81101628:	1009883a 	mov	r4,r2
8110162c:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101630:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101634:	00a00034 	movhi	r2,32768
81101638:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
8110163c:	00800044 	movi	r2,1
81101640:	e0bfe515 	stw	r2,-108(fp)
		break;
81101644:	00001b06 	br	811016b4 <bDdr2MemoryWriteTest+0x10c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101648:	e0bffd03 	ldbu	r2,-12(fp)
8110164c:	1009883a 	mov	r4,r2
81101650:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101654:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101658:	00a00034 	movhi	r2,32768
8110165c:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
81101660:	00800044 	movi	r2,1
81101664:	e0bfe515 	stw	r2,-108(fp)
		break;
81101668:	00001206 	br	811016b4 <bDdr2MemoryWriteTest+0x10c>
	default:
		bSuccess = FALSE;
8110166c:	e03fe515 	stw	zero,-108(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101670:	00e04574 	movhi	r3,33045
81101674:	18d56904 	addi	r3,r3,21924
81101678:	00a04574 	movhi	r2,33045
8110167c:	10b54a04 	addi	r2,r2,-10968
81101680:	1009883a 	mov	r4,r2
81101684:	00800bc4 	movi	r2,47
81101688:	100d883a 	mov	r6,r2
8110168c:	200b883a 	mov	r5,r4
81101690:	1809883a 	mov	r4,r3
81101694:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101698:	d0a06217 	ldw	r2,-32376(gp)
8110169c:	01604574 	movhi	r5,33045
811016a0:	29556904 	addi	r5,r5,21924
811016a4:	1009883a 	mov	r4,r2
811016a8:	11236500 	call	81123650 <fprintf>
		;
#endif
		return bSuccess;
811016ac:	e0bfe517 	ldw	r2,-108(fp)
811016b0:	00011806 	br	81101b14 <bDdr2MemoryWriteTest+0x56c>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
811016b4:	e0bfe717 	ldw	r2,-100(fp)
811016b8:	1004d53a 	srli	r2,r2,20
811016bc:	100d883a 	mov	r6,r2
811016c0:	01604574 	movhi	r5,33045
811016c4:	29774304 	addi	r5,r5,-8948
811016c8:	01204574 	movhi	r4,33045
811016cc:	21156904 	addi	r4,r4,21924
811016d0:	1124f640 	call	81124f64 <sprintf>
	debug(fp, cDebugBuffer);
811016d4:	d0a06217 	ldw	r2,-32376(gp)
811016d8:	01604574 	movhi	r5,33045
811016dc:	29556904 	addi	r5,r5,21924
811016e0:	1009883a 	mov	r4,r2
811016e4:	11236500 	call	81123650 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016e8:	00800104 	movi	r2,4
811016ec:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016f0:	e03fed15 	stw	zero,-76(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016f4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016f8:	e03fe815 	stw	zero,-96(fp)
811016fc:	00001506 	br	81101754 <bDdr2MemoryWriteTest+0x1ac>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101700:	e0ffe717 	ldw	r3,-100(fp)
81101704:	00b33374 	movhi	r2,52429
81101708:	10b33344 	addi	r2,r2,-13107
8110170c:	1888383a 	mulxuu	r4,r3,r2
81101710:	1885383a 	mul	r2,r3,r2
81101714:	1021883a 	mov	r16,r2
81101718:	2023883a 	mov	r17,r4
8110171c:	8804d0fa 	srli	r2,r17,3
81101720:	e0ffe817 	ldw	r3,-96(fp)
81101724:	18c00044 	addi	r3,r3,1
81101728:	10c7383a 	mul	r3,r2,r3
8110172c:	e0bfe817 	ldw	r2,-96(fp)
81101730:	1085883a 	add	r2,r2,r2
81101734:	1085883a 	add	r2,r2,r2
81101738:	e13fe504 	addi	r4,fp,-108
8110173c:	2085883a 	add	r2,r4,r2
81101740:	10800e04 	addi	r2,r2,56
81101744:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101748:	e0bfe817 	ldw	r2,-96(fp)
8110174c:	10800044 	addi	r2,r2,1
81101750:	e0bfe815 	stw	r2,-96(fp)
81101754:	e0bfe817 	ldw	r2,-96(fp)
81101758:	10800290 	cmplti	r2,r2,10
8110175c:	103fe81e 	bne	r2,zero,81101700 <__reset+0xfb0e1700>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101760:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101764:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101768:	00804004 	movi	r2,256
8110176c:	e0bfeb15 	stw	r2,-84(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101770:	e03fe815 	stw	zero,-96(fp)
81101774:	00001e06 	br	811017f0 <bDdr2MemoryWriteTest+0x248>
		if (iI == 0) {
81101778:	e0bfe817 	ldw	r2,-96(fp)
8110177c:	1000091e 	bne	r2,zero,811017a4 <bDdr2MemoryWriteTest+0x1fc>
			xSZData[iI] = uliInitValue;
81101780:	00a04574 	movhi	r2,33045
81101784:	1095a904 	addi	r2,r2,22180
81101788:	e0ffe817 	ldw	r3,-96(fp)
8110178c:	18c7883a 	add	r3,r3,r3
81101790:	18c7883a 	add	r3,r3,r3
81101794:	10c5883a 	add	r2,r2,r3
81101798:	e0fff017 	ldw	r3,-64(fp)
8110179c:	10c00015 	stw	r3,0(r2)
811017a0:	00001006 	br	811017e4 <bDdr2MemoryWriteTest+0x23c>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
811017a4:	e0bfe817 	ldw	r2,-96(fp)
811017a8:	10ffffc4 	addi	r3,r2,-1
811017ac:	00a04574 	movhi	r2,33045
811017b0:	1095a904 	addi	r2,r2,22180
811017b4:	18c7883a 	add	r3,r3,r3
811017b8:	18c7883a 	add	r3,r3,r3
811017bc:	10c5883a 	add	r2,r2,r3
811017c0:	10800017 	ldw	r2,0(r2)
811017c4:	11000364 	muli	r4,r2,13
811017c8:	00a04574 	movhi	r2,33045
811017cc:	1095a904 	addi	r2,r2,22180
811017d0:	e0ffe817 	ldw	r3,-96(fp)
811017d4:	18c7883a 	add	r3,r3,r3
811017d8:	18c7883a 	add	r3,r3,r3
811017dc:	10c5883a 	add	r2,r2,r3
811017e0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017e4:	e0bfe817 	ldw	r2,-96(fp)
811017e8:	10800044 	addi	r2,r2,1
811017ec:	e0bfe815 	stw	r2,-96(fp)
811017f0:	e0ffe817 	ldw	r3,-96(fp)
811017f4:	e0bfeb17 	ldw	r2,-84(fp)
811017f8:	18bfdf16 	blt	r3,r2,81101778 <__reset+0xfb0e1778>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017fc:	e0bfeb17 	ldw	r2,-84(fp)
81101800:	10ffffc4 	addi	r3,r2,-1
81101804:	00a04574 	movhi	r2,33045
81101808:	1095a904 	addi	r2,r2,22180
8110180c:	18c7883a 	add	r3,r3,r3
81101810:	18c7883a 	add	r3,r3,r3
81101814:	10c7883a 	add	r3,r2,r3
81101818:	00aaaaf4 	movhi	r2,43691
8110181c:	10aaaa84 	addi	r2,r2,-21846
81101820:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
81101824:	e0bfeb17 	ldw	r2,-84(fp)
81101828:	10ffff84 	addi	r3,r2,-2
8110182c:	00a04574 	movhi	r2,33045
81101830:	1095a904 	addi	r2,r2,22180
81101834:	18c7883a 	add	r3,r3,r3
81101838:	18c7883a 	add	r3,r3,r3
8110183c:	10c7883a 	add	r3,r2,r3
81101840:	00955574 	movhi	r2,21845
81101844:	10955544 	addi	r2,r2,21845
81101848:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110184c:	e0bfeb17 	ldw	r2,-84(fp)
81101850:	10ffff44 	addi	r3,r2,-3
81101854:	00a04574 	movhi	r2,33045
81101858:	1095a904 	addi	r2,r2,22180
8110185c:	18c7883a 	add	r3,r3,r3
81101860:	18c7883a 	add	r3,r3,r3
81101864:	10c5883a 	add	r2,r2,r3
81101868:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110186c:	e0bfeb17 	ldw	r2,-84(fp)
81101870:	10ffff04 	addi	r3,r2,-4
81101874:	00a04574 	movhi	r2,33045
81101878:	1095a904 	addi	r2,r2,22180
8110187c:	18c7883a 	add	r3,r3,r3
81101880:	18c7883a 	add	r3,r3,r3
81101884:	10c5883a 	add	r2,r2,r3
81101888:	00ffffc4 	movi	r3,-1
8110188c:	10c00015 	stw	r3,0(r2)

#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101890:	00e04574 	movhi	r3,33045
81101894:	18d56904 	addi	r3,r3,21924
81101898:	00a04574 	movhi	r2,33045
8110189c:	10b74904 	addi	r2,r2,-8924
811018a0:	1009883a 	mov	r4,r2
811018a4:	00800444 	movi	r2,17
811018a8:	100d883a 	mov	r6,r2
811018ac:	200b883a 	mov	r5,r4
811018b0:	1809883a 	mov	r4,r3
811018b4:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
811018b8:	d0a06217 	ldw	r2,-32376(gp)
811018bc:	01604574 	movhi	r5,33045
811018c0:	29556904 	addi	r5,r5,21924
811018c4:	1009883a 	mov	r4,r2
811018c8:	11236500 	call	81123650 <fprintf>
811018cc:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018d0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018d4:	e0bfe617 	ldw	r2,-104(fp)
811018d8:	e0bfea15 	stw	r2,-88(fp)
	iNAccessLen = sizeof(xSZData);
811018dc:	00810004 	movi	r2,1024
811018e0:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018e4:	e0ffe917 	ldw	r3,-92(fp)
811018e8:	e0bfee17 	ldw	r2,-72(fp)
811018ec:	1885283a 	div	r2,r3,r2
811018f0:	e0bfeb15 	stw	r2,-84(fp)
	iNPos = 0;
811018f4:	e03fec15 	stw	zero,-80(fp)
	while (iNPos < uliByteLen) {
811018f8:	00003a06 	br	811019e4 <bDdr2MemoryWriteTest+0x43c>
		iNRemainedLen = uliByteLen - iNPos;
811018fc:	e0bfec17 	ldw	r2,-80(fp)
81101900:	e0ffe717 	ldw	r3,-100(fp)
81101904:	1885c83a 	sub	r2,r3,r2
81101908:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
8110190c:	e0bfe917 	ldw	r2,-92(fp)
81101910:	e0fff217 	ldw	r3,-56(fp)
81101914:	1880060e 	bge	r3,r2,81101930 <bDdr2MemoryWriteTest+0x388>
			iNAccessLen = iNRemainedLen;
81101918:	e0bff217 	ldw	r2,-56(fp)
8110191c:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101920:	e0ffe917 	ldw	r3,-92(fp)
81101924:	e0bfee17 	ldw	r2,-72(fp)
81101928:	1885283a 	div	r2,r3,r2
8110192c:	e0bfeb15 	stw	r2,-84(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101930:	e0bfe917 	ldw	r2,-92(fp)
81101934:	100d883a 	mov	r6,r2
81101938:	01604574 	movhi	r5,33045
8110193c:	2955a904 	addi	r5,r5,22180
81101940:	e13fea17 	ldw	r4,-88(fp)
81101944:	11247000 	call	81124700 <memcpy>
		pxDes += iNItemNum;
81101948:	e0bfeb17 	ldw	r2,-84(fp)
8110194c:	1085883a 	add	r2,r2,r2
81101950:	1085883a 	add	r2,r2,r2
81101954:	1007883a 	mov	r3,r2
81101958:	e0bfea17 	ldw	r2,-88(fp)
8110195c:	10c5883a 	add	r2,r2,r3
81101960:	e0bfea15 	stw	r2,-88(fp)
		iNPos += iNAccessLen;
81101964:	e0ffec17 	ldw	r3,-80(fp)
81101968:	e0bfe917 	ldw	r2,-92(fp)
8110196c:	1885883a 	add	r2,r3,r2
81101970:	e0bfec15 	stw	r2,-80(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101974:	e0bfed17 	ldw	r2,-76(fp)
81101978:	10800288 	cmpgei	r2,r2,10
8110197c:	1000191e 	bne	r2,zero,811019e4 <bDdr2MemoryWriteTest+0x43c>
81101980:	e0bfed17 	ldw	r2,-76(fp)
81101984:	1085883a 	add	r2,r2,r2
81101988:	1085883a 	add	r2,r2,r2
8110198c:	e0ffe504 	addi	r3,fp,-108
81101990:	1885883a 	add	r2,r3,r2
81101994:	10800e04 	addi	r2,r2,56
81101998:	10800017 	ldw	r2,0(r2)
8110199c:	e0ffec17 	ldw	r3,-80(fp)
811019a0:	18801036 	bltu	r3,r2,811019e4 <bDdr2MemoryWriteTest+0x43c>
			iNProgressIndex++;
811019a4:	e0bfed17 	ldw	r2,-76(fp)
811019a8:	10800044 	addi	r2,r2,1
811019ac:	e0bfed15 	stw	r2,-76(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
811019b0:	e0bfed17 	ldw	r2,-76(fp)
811019b4:	108002a4 	muli	r2,r2,10
811019b8:	100d883a 	mov	r6,r2
811019bc:	01604574 	movhi	r5,33045
811019c0:	29774e04 	addi	r5,r5,-8904
811019c4:	01204574 	movhi	r4,33045
811019c8:	21156904 	addi	r4,r4,21924
811019cc:	1124f640 	call	81124f64 <sprintf>
			debug(fp, cDebugBuffer);
811019d0:	d0a06217 	ldw	r2,-32376(gp)
811019d4:	01604574 	movhi	r5,33045
811019d8:	29556904 	addi	r5,r5,21924
811019dc:	1009883a 	mov	r4,r2
811019e0:	11236500 	call	81123650 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019e4:	e0ffec17 	ldw	r3,-80(fp)
811019e8:	e0bfe717 	ldw	r2,-100(fp)
811019ec:	18bfc336 	bltu	r3,r2,811018fc <__reset+0xfb0e18fc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019f0:	11384e00 	call	811384e0 <alt_dcache_flush_all>
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019f4:	00a04574 	movhi	r2,33045
811019f8:	10956904 	addi	r2,r2,21924
811019fc:	00c00284 	movi	r3,10
81101a00:	10c00005 	stb	r3,0(r2)
81101a04:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101a08:	d0a06217 	ldw	r2,-32376(gp)
81101a0c:	01604574 	movhi	r5,33045
81101a10:	29556904 	addi	r5,r5,21924
81101a14:	1009883a 	mov	r4,r2
81101a18:	11236500 	call	81123650 <fprintf>
81101a1c:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101a20:	e0bff117 	ldw	r2,-60(fp)
81101a24:	1885c83a 	sub	r2,r3,r2
81101a28:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
81101a2c:	e0bfe517 	ldw	r2,-108(fp)
81101a30:	10001e26 	beq	r2,zero,81101aac <bDdr2MemoryWriteTest+0x504>
#if DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a34:	e13fef17 	ldw	r4,-68(fp)
81101a38:	1121d300 	call	81121d30 <__floatsisf>
81101a3c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a40:	d0a08817 	ldw	r2,-32224(gp)
81101a44:	1009883a 	mov	r4,r2
81101a48:	1121e5c0 	call	81121e5c <__floatunsisf>
81101a4c:	1007883a 	mov	r3,r2
81101a50:	180b883a 	mov	r5,r3
81101a54:	8009883a 	mov	r4,r16
81101a58:	11214e40 	call	811214e4 <__divsf3>
81101a5c:	1007883a 	mov	r3,r2
81101a60:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101a64:	1009883a 	mov	r4,r2
81101a68:	11231b80 	call	811231b8 <__extendsfdf2>
81101a6c:	1009883a 	mov	r4,r2
81101a70:	180b883a 	mov	r5,r3
81101a74:	d9400015 	stw	r5,0(sp)
81101a78:	200f883a 	mov	r7,r4
81101a7c:	e1bfe717 	ldw	r6,-100(fp)
81101a80:	01604574 	movhi	r5,33045
81101a84:	29775004 	addi	r5,r5,-8896
81101a88:	01204574 	movhi	r4,33045
81101a8c:	21156904 	addi	r4,r4,21924
81101a90:	1124f640 	call	81124f64 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a94:	d0a06217 	ldw	r2,-32376(gp)
81101a98:	01604574 	movhi	r5,33045
81101a9c:	29556904 	addi	r5,r5,21924
81101aa0:	1009883a 	mov	r4,r2
81101aa4:	11236500 	call	81123650 <fprintf>
81101aa8:	00000f06 	br	81101ae8 <bDdr2MemoryWriteTest+0x540>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101aac:	00e04574 	movhi	r3,33045
81101ab0:	18d56904 	addi	r3,r3,21924
81101ab4:	00a04574 	movhi	r2,33045
81101ab8:	10b75c04 	addi	r2,r2,-8848
81101abc:	1009883a 	mov	r4,r2
81101ac0:	00800584 	movi	r2,22
81101ac4:	100d883a 	mov	r6,r2
81101ac8:	200b883a 	mov	r5,r4
81101acc:	1809883a 	mov	r4,r3
81101ad0:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
81101ad4:	d0a06217 	ldw	r2,-32376(gp)
81101ad8:	01604574 	movhi	r5,33045
81101adc:	29556904 	addi	r5,r5,21924
81101ae0:	1009883a 	mov	r4,r2
81101ae4:	11236500 	call	81123650 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ae8:	00a04574 	movhi	r2,33045
81101aec:	10956904 	addi	r2,r2,21924
81101af0:	00c00284 	movi	r3,10
81101af4:	10c00005 	stb	r3,0(r2)
81101af8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101afc:	d0a06217 	ldw	r2,-32376(gp)
81101b00:	01604574 	movhi	r5,33045
81101b04:	29556904 	addi	r5,r5,21924
81101b08:	1009883a 	mov	r4,r2
81101b0c:	11236500 	call	81123650 <fprintf>
#endif

	return bSuccess;
81101b10:	e0bfe517 	ldw	r2,-108(fp)
}
81101b14:	e6fffe04 	addi	sp,fp,-8
81101b18:	dfc00317 	ldw	ra,12(sp)
81101b1c:	df000217 	ldw	fp,8(sp)
81101b20:	dc400117 	ldw	r17,4(sp)
81101b24:	dc000017 	ldw	r16,0(sp)
81101b28:	dec00404 	addi	sp,sp,16
81101b2c:	f800283a 	ret

81101b30 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b30:	deffe204 	addi	sp,sp,-120
81101b34:	de00012e 	bgeu	sp,et,81101b3c <bDdr2MemoryReadTest+0xc>
81101b38:	003b68fa 	trap	3
81101b3c:	dfc01d15 	stw	ra,116(sp)
81101b40:	df001c15 	stw	fp,112(sp)
81101b44:	dc401b15 	stw	r17,108(sp)
81101b48:	dc001a15 	stw	r16,104(sp)
81101b4c:	df001c04 	addi	fp,sp,112
81101b50:	2005883a 	mov	r2,r4
81101b54:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b58:	00e04574 	movhi	r3,33045
81101b5c:	18d56904 	addi	r3,r3,21924
81101b60:	00a04574 	movhi	r2,33045
81101b64:	10b76204 	addi	r2,r2,-8824
81101b68:	1009883a 	mov	r4,r2
81101b6c:	008009c4 	movi	r2,39
81101b70:	100d883a 	mov	r6,r2
81101b74:	200b883a 	mov	r5,r4
81101b78:	1809883a 	mov	r4,r3
81101b7c:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
81101b80:	d0a06217 	ldw	r2,-32376(gp)
81101b84:	01604574 	movhi	r5,33045
81101b88:	29556904 	addi	r5,r5,21924
81101b8c:	1009883a 	mov	r4,r2
81101b90:	11236500 	call	81123650 <fprintf>
#endif
	bool bSuccess = FALSE;
81101b94:	e03fe515 	stw	zero,-108(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
81101b98:	e0bffd03 	ldbu	r2,-12(fp)
81101b9c:	10000326 	beq	r2,zero,81101bac <bDdr2MemoryReadTest+0x7c>
81101ba0:	10800060 	cmpeqi	r2,r2,1
81101ba4:	10000a1e 	bne	r2,zero,81101bd0 <bDdr2MemoryReadTest+0xa0>
81101ba8:	00001206 	br	81101bf4 <bDdr2MemoryReadTest+0xc4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101bac:	e0bffd03 	ldbu	r2,-12(fp)
81101bb0:	1009883a 	mov	r4,r2
81101bb4:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101bb8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101bbc:	00a00034 	movhi	r2,32768
81101bc0:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
81101bc4:	00800044 	movi	r2,1
81101bc8:	e0bfe515 	stw	r2,-108(fp)
		break;
81101bcc:	00001b06 	br	81101c3c <bDdr2MemoryReadTest+0x10c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101bd0:	e0bffd03 	ldbu	r2,-12(fp)
81101bd4:	1009883a 	mov	r4,r2
81101bd8:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101bdc:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101be0:	00a00034 	movhi	r2,32768
81101be4:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
81101be8:	00800044 	movi	r2,1
81101bec:	e0bfe515 	stw	r2,-108(fp)
		break;
81101bf0:	00001206 	br	81101c3c <bDdr2MemoryReadTest+0x10c>
	default:
		bSuccess = FALSE;
81101bf4:	e03fe515 	stw	zero,-108(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101bf8:	00e04574 	movhi	r3,33045
81101bfc:	18d56904 	addi	r3,r3,21924
81101c00:	00a04574 	movhi	r2,33045
81101c04:	10b54a04 	addi	r2,r2,-10968
81101c08:	1009883a 	mov	r4,r2
81101c0c:	00800bc4 	movi	r2,47
81101c10:	100d883a 	mov	r6,r2
81101c14:	200b883a 	mov	r5,r4
81101c18:	1809883a 	mov	r4,r3
81101c1c:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29556904 	addi	r5,r5,21924
81101c2c:	1009883a 	mov	r4,r2
81101c30:	11236500 	call	81123650 <fprintf>
		;
#endif
		return bSuccess;
81101c34:	e0bfe517 	ldw	r2,-108(fp)
81101c38:	0000fc06 	br	8110202c <bDdr2MemoryReadTest+0x4fc>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c3c:	e0bfe717 	ldw	r2,-100(fp)
81101c40:	1004d53a 	srli	r2,r2,20
81101c44:	100d883a 	mov	r6,r2
81101c48:	01604574 	movhi	r5,33045
81101c4c:	29776c04 	addi	r5,r5,-8784
81101c50:	01204574 	movhi	r4,33045
81101c54:	21156904 	addi	r4,r4,21924
81101c58:	1124f640 	call	81124f64 <sprintf>
	debug(fp, cDebugBuffer);
81101c5c:	d0a06217 	ldw	r2,-32376(gp)
81101c60:	01604574 	movhi	r5,33045
81101c64:	29556904 	addi	r5,r5,21924
81101c68:	1009883a 	mov	r4,r2
81101c6c:	11236500 	call	81123650 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c70:	00804004 	movi	r2,256
81101c74:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c78:	00800104 	movi	r2,4
81101c7c:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c80:	e0ffec17 	ldw	r3,-80(fp)
81101c84:	e0bfef17 	ldw	r2,-68(fp)
81101c88:	1885383a 	mul	r2,r3,r2
81101c8c:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c90:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c94:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c98:	e03fe815 	stw	zero,-96(fp)
81101c9c:	00001506 	br	81101cf4 <bDdr2MemoryReadTest+0x1c4>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101ca0:	e0ffe717 	ldw	r3,-100(fp)
81101ca4:	00b33374 	movhi	r2,52429
81101ca8:	10b33344 	addi	r2,r2,-13107
81101cac:	1888383a 	mulxuu	r4,r3,r2
81101cb0:	1885383a 	mul	r2,r3,r2
81101cb4:	1021883a 	mov	r16,r2
81101cb8:	2023883a 	mov	r17,r4
81101cbc:	8804d0fa 	srli	r2,r17,3
81101cc0:	e0ffe817 	ldw	r3,-96(fp)
81101cc4:	18c00044 	addi	r3,r3,1
81101cc8:	10c7383a 	mul	r3,r2,r3
81101ccc:	e0bfe817 	ldw	r2,-96(fp)
81101cd0:	1085883a 	add	r2,r2,r2
81101cd4:	1085883a 	add	r2,r2,r2
81101cd8:	e13fe504 	addi	r4,fp,-108
81101cdc:	2085883a 	add	r2,r4,r2
81101ce0:	10800e04 	addi	r2,r2,56
81101ce4:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101ce8:	e0bfe817 	ldw	r2,-96(fp)
81101cec:	10800044 	addi	r2,r2,1
81101cf0:	e0bfe815 	stw	r2,-96(fp)
81101cf4:	e0bfe817 	ldw	r2,-96(fp)
81101cf8:	10800290 	cmplti	r2,r2,10
81101cfc:	103fe81e 	bne	r2,zero,81101ca0 <__reset+0xfb0e1ca0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101d00:	e03fee15 	stw	zero,-72(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101d04:	00e04574 	movhi	r3,33045
81101d08:	18d56904 	addi	r3,r3,21924
81101d0c:	00a04574 	movhi	r2,33045
81101d10:	10b77204 	addi	r2,r2,-8760
81101d14:	1009883a 	mov	r4,r2
81101d18:	008006c4 	movi	r2,27
81101d1c:	100d883a 	mov	r6,r2
81101d20:	200b883a 	mov	r5,r4
81101d24:	1809883a 	mov	r4,r3
81101d28:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
81101d2c:	d0a06217 	ldw	r2,-32376(gp)
81101d30:	01604574 	movhi	r5,33045
81101d34:	29556904 	addi	r5,r5,21924
81101d38:	1009883a 	mov	r4,r2
81101d3c:	11236500 	call	81123650 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d40:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d44:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d48:	e0bfe617 	ldw	r2,-104(fp)
81101d4c:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d50:	00810004 	movi	r2,1024
81101d54:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d68:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d6c:	00006206 	br	81101ef8 <bDdr2MemoryReadTest+0x3c8>
		iNRemainedLen = uliByteLen - iNPos;
81101d70:	e0bfed17 	ldw	r2,-76(fp)
81101d74:	e0ffe717 	ldw	r3,-100(fp)
81101d78:	1885c83a 	sub	r2,r3,r2
81101d7c:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d80:	e0bfe917 	ldw	r2,-92(fp)
81101d84:	e0fff217 	ldw	r3,-56(fp)
81101d88:	1880060e 	bge	r3,r2,81101da4 <bDdr2MemoryReadTest+0x274>
			iNAccessLen = iNRemainedLen;
81101d8c:	e0bff217 	ldw	r2,-56(fp)
81101d90:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d94:	e0ffe917 	ldw	r3,-92(fp)
81101d98:	e0bfef17 	ldw	r2,-68(fp)
81101d9c:	1885283a 	div	r2,r3,r2
81101da0:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101da4:	00a04574 	movhi	r2,33045
81101da8:	1095a904 	addi	r2,r2,22180
81101dac:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101db0:	e03fe815 	stw	zero,-96(fp)
81101db4:	00002b06 	br	81101e64 <bDdr2MemoryReadTest+0x334>
			if (*pxSrc++ != *pxDes++) {
81101db8:	e0bfeb17 	ldw	r2,-84(fp)
81101dbc:	10c00104 	addi	r3,r2,4
81101dc0:	e0ffeb15 	stw	r3,-84(fp)
81101dc4:	10c00017 	ldw	r3,0(r2)
81101dc8:	e0bfea17 	ldw	r2,-88(fp)
81101dcc:	11000104 	addi	r4,r2,4
81101dd0:	e13fea15 	stw	r4,-88(fp)
81101dd4:	10800017 	ldw	r2,0(r2)
81101dd8:	18801f26 	beq	r3,r2,81101e58 <bDdr2MemoryReadTest+0x328>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101ddc:	e0bfeb17 	ldw	r2,-84(fp)
81101de0:	10bfff04 	addi	r2,r2,-4
81101de4:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101de8:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101dec:	00a04574 	movhi	r2,33045
81101df0:	1095a904 	addi	r2,r2,22180
81101df4:	e0ffe817 	ldw	r3,-96(fp)
81101df8:	18c7883a 	add	r3,r3,r3
81101dfc:	18c7883a 	add	r3,r3,r3
81101e00:	10c5883a 	add	r2,r2,r3
81101e04:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101e08:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101e0c:	e0ffed17 	ldw	r3,-76(fp)
81101e10:	e0bfef17 	ldw	r2,-68(fp)
81101e14:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101e18:	e0bfe817 	ldw	r2,-96(fp)
81101e1c:	1885883a 	add	r2,r3,r2
81101e20:	d8800015 	stw	r2,0(sp)
81101e24:	280f883a 	mov	r7,r5
81101e28:	200d883a 	mov	r6,r4
81101e2c:	01604574 	movhi	r5,33045
81101e30:	29777904 	addi	r5,r5,-8732
81101e34:	01204574 	movhi	r4,33045
81101e38:	21156904 	addi	r4,r4,21924
81101e3c:	1124f640 	call	81124f64 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e40:	d0a06217 	ldw	r2,-32376(gp)
81101e44:	01604574 	movhi	r5,33045
81101e48:	29556904 	addi	r5,r5,21924
81101e4c:	1009883a 	mov	r4,r2
81101e50:	11236500 	call	81123650 <fprintf>
#endif
				bSuccess = FALSE;
81101e54:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e58:	e0bfe817 	ldw	r2,-96(fp)
81101e5c:	10800044 	addi	r2,r2,1
81101e60:	e0bfe815 	stw	r2,-96(fp)
81101e64:	e0ffe817 	ldw	r3,-96(fp)
81101e68:	e0bfec17 	ldw	r2,-80(fp)
81101e6c:	1880020e 	bge	r3,r2,81101e78 <bDdr2MemoryReadTest+0x348>
81101e70:	e0bfe517 	ldw	r2,-108(fp)
81101e74:	103fd01e 	bne	r2,zero,81101db8 <__reset+0xfb0e1db8>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e78:	e0ffed17 	ldw	r3,-76(fp)
81101e7c:	e0bfe917 	ldw	r2,-92(fp)
81101e80:	1885883a 	add	r2,r3,r2
81101e84:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	10800288 	cmpgei	r2,r2,10
81101e90:	1000191e 	bne	r2,zero,81101ef8 <bDdr2MemoryReadTest+0x3c8>
81101e94:	e0bfee17 	ldw	r2,-72(fp)
81101e98:	1085883a 	add	r2,r2,r2
81101e9c:	1085883a 	add	r2,r2,r2
81101ea0:	e0ffe504 	addi	r3,fp,-108
81101ea4:	1885883a 	add	r2,r3,r2
81101ea8:	10800e04 	addi	r2,r2,56
81101eac:	10800017 	ldw	r2,0(r2)
81101eb0:	e0ffed17 	ldw	r3,-76(fp)
81101eb4:	18801036 	bltu	r3,r2,81101ef8 <bDdr2MemoryReadTest+0x3c8>
			iNProgressIndex++;
81101eb8:	e0bfee17 	ldw	r2,-72(fp)
81101ebc:	10800044 	addi	r2,r2,1
81101ec0:	e0bfee15 	stw	r2,-72(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101ec4:	e0bfee17 	ldw	r2,-72(fp)
81101ec8:	108002a4 	muli	r2,r2,10
81101ecc:	100d883a 	mov	r6,r2
81101ed0:	01604574 	movhi	r5,33045
81101ed4:	29774e04 	addi	r5,r5,-8904
81101ed8:	01204574 	movhi	r4,33045
81101edc:	21156904 	addi	r4,r4,21924
81101ee0:	1124f640 	call	81124f64 <sprintf>
			debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29556904 	addi	r5,r5,21924
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	11236500 	call	81123650 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ef8:	e0bfe517 	ldw	r2,-108(fp)
81101efc:	10000326 	beq	r2,zero,81101f0c <bDdr2MemoryReadTest+0x3dc>
81101f00:	e0ffed17 	ldw	r3,-76(fp)
81101f04:	e0bfe717 	ldw	r2,-100(fp)
81101f08:	18bf9936 	bltu	r3,r2,81101d70 <__reset+0xfb0e1d70>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101f0c:	00a04574 	movhi	r2,33045
81101f10:	10956904 	addi	r2,r2,21924
81101f14:	00c00284 	movi	r3,10
81101f18:	10c00005 	stb	r3,0(r2)
81101f1c:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101f20:	d0a06217 	ldw	r2,-32376(gp)
81101f24:	01604574 	movhi	r5,33045
81101f28:	29556904 	addi	r5,r5,21924
81101f2c:	1009883a 	mov	r4,r2
81101f30:	11236500 	call	81123650 <fprintf>
81101f34:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101f38:	e0bff117 	ldw	r2,-60(fp)
81101f3c:	1885c83a 	sub	r2,r3,r2
81101f40:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f44:	e0bfe517 	ldw	r2,-108(fp)
81101f48:	10001e26 	beq	r2,zero,81101fc4 <bDdr2MemoryReadTest+0x494>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f4c:	e13ff017 	ldw	r4,-64(fp)
81101f50:	1121d300 	call	81121d30 <__floatsisf>
81101f54:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f58:	d0a08817 	ldw	r2,-32224(gp)
81101f5c:	1009883a 	mov	r4,r2
81101f60:	1121e5c0 	call	81121e5c <__floatunsisf>
81101f64:	1007883a 	mov	r3,r2
81101f68:	180b883a 	mov	r5,r3
81101f6c:	8009883a 	mov	r4,r16
81101f70:	11214e40 	call	811214e4 <__divsf3>
81101f74:	1007883a 	mov	r3,r2
81101f78:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f7c:	1009883a 	mov	r4,r2
81101f80:	11231b80 	call	811231b8 <__extendsfdf2>
81101f84:	1009883a 	mov	r4,r2
81101f88:	180b883a 	mov	r5,r3
81101f8c:	d9400015 	stw	r5,0(sp)
81101f90:	200f883a 	mov	r7,r4
81101f94:	e1bfe717 	ldw	r6,-100(fp)
81101f98:	01604574 	movhi	r5,33045
81101f9c:	29778704 	addi	r5,r5,-8676
81101fa0:	01204574 	movhi	r4,33045
81101fa4:	21156904 	addi	r4,r4,21924
81101fa8:	1124f640 	call	81124f64 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101fac:	d0a06217 	ldw	r2,-32376(gp)
81101fb0:	01604574 	movhi	r5,33045
81101fb4:	29556904 	addi	r5,r5,21924
81101fb8:	1009883a 	mov	r4,r2
81101fbc:	11236500 	call	81123650 <fprintf>
81101fc0:	00000f06 	br	81102000 <bDdr2MemoryReadTest+0x4d0>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101fc4:	00e04574 	movhi	r3,33045
81101fc8:	18d56904 	addi	r3,r3,21924
81101fcc:	00a04574 	movhi	r2,33045
81101fd0:	10b79304 	addi	r2,r2,-8628
81101fd4:	1009883a 	mov	r4,r2
81101fd8:	00800544 	movi	r2,21
81101fdc:	100d883a 	mov	r6,r2
81101fe0:	200b883a 	mov	r5,r4
81101fe4:	1809883a 	mov	r4,r3
81101fe8:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
81101fec:	d0a06217 	ldw	r2,-32376(gp)
81101ff0:	01604574 	movhi	r5,33045
81101ff4:	29556904 	addi	r5,r5,21924
81101ff8:	1009883a 	mov	r4,r2
81101ffc:	11236500 	call	81123650 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102000:	00a04574 	movhi	r2,33045
81102004:	10956904 	addi	r2,r2,21924
81102008:	00c00284 	movi	r3,10
8110200c:	10c00005 	stb	r3,0(r2)
81102010:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102014:	d0a06217 	ldw	r2,-32376(gp)
81102018:	01604574 	movhi	r5,33045
8110201c:	29556904 	addi	r5,r5,21924
81102020:	1009883a 	mov	r4,r2
81102024:	11236500 	call	81123650 <fprintf>
#endif

	return bSuccess;
81102028:	e0bfe517 	ldw	r2,-108(fp)
}
8110202c:	e6fffe04 	addi	sp,fp,-8
81102030:	dfc00317 	ldw	ra,12(sp)
81102034:	df000217 	ldw	fp,8(sp)
81102038:	dc400117 	ldw	r17,4(sp)
8110203c:	dc000017 	ldw	r16,0(sp)
81102040:	dec00404 	addi	sp,sp,16
81102044:	f800283a 	ret

81102048 <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102048:	deffec04 	addi	sp,sp,-80
8110204c:	de00012e 	bgeu	sp,et,81102054 <bDdr2MemoryRandomWriteTest+0xc>
81102050:	003b68fa 	trap	3
81102054:	dfc01315 	stw	ra,76(sp)
81102058:	df001215 	stw	fp,72(sp)
8110205c:	dcc01115 	stw	r19,68(sp)
81102060:	dc801015 	stw	r18,64(sp)
81102064:	dc400f15 	stw	r17,60(sp)
81102068:	dc000e15 	stw	r16,56(sp)
8110206c:	df001204 	addi	fp,sp,72
81102070:	2005883a 	mov	r2,r4
81102074:	e17ffa15 	stw	r5,-24(fp)
81102078:	e1bffb15 	stw	r6,-20(fp)
8110207c:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102080:	00e04574 	movhi	r3,33045
81102084:	18d56904 	addi	r3,r3,21924
81102088:	00a04574 	movhi	r2,33045
8110208c:	10b79904 	addi	r2,r2,-8604
81102090:	1009883a 	mov	r4,r2
81102094:	00800bc4 	movi	r2,47
81102098:	100d883a 	mov	r6,r2
8110209c:	200b883a 	mov	r5,r4
811020a0:	1809883a 	mov	r4,r3
811020a4:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
811020a8:	d0a06217 	ldw	r2,-32376(gp)
811020ac:	01604574 	movhi	r5,33045
811020b0:	29556904 	addi	r5,r5,21924
811020b4:	1009883a 	mov	r4,r2
811020b8:	11236500 	call	81123650 <fprintf>
#endif
	bool bSuccess = FALSE;
811020bc:	e03fef15 	stw	zero,-68(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
811020c0:	e0bff903 	ldbu	r2,-28(fp)
811020c4:	10000326 	beq	r2,zero,811020d4 <bDdr2MemoryRandomWriteTest+0x8c>
811020c8:	10800060 	cmpeqi	r2,r2,1
811020cc:	10000a1e 	bne	r2,zero,811020f8 <bDdr2MemoryRandomWriteTest+0xb0>
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0xd4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020d4:	e0bff903 	ldbu	r2,-28(fp)
811020d8:	1009883a 	mov	r4,r2
811020dc:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020e0:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020e4:	00a00034 	movhi	r2,32768
811020e8:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
811020ec:	00800044 	movi	r2,1
811020f0:	e0bfef15 	stw	r2,-68(fp)
		break;
811020f4:	00001b06 	br	81102164 <bDdr2MemoryRandomWriteTest+0x11c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020f8:	e0bff903 	ldbu	r2,-28(fp)
811020fc:	1009883a 	mov	r4,r2
81102100:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102104:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102108:	00a00034 	movhi	r2,32768
8110210c:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
81102110:	00800044 	movi	r2,1
81102114:	e0bfef15 	stw	r2,-68(fp)
		break;
81102118:	00001206 	br	81102164 <bDdr2MemoryRandomWriteTest+0x11c>
	default:
		bSuccess = FALSE;
8110211c:	e03fef15 	stw	zero,-68(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81102120:	00e04574 	movhi	r3,33045
81102124:	18d56904 	addi	r3,r3,21924
81102128:	00a04574 	movhi	r2,33045
8110212c:	10b54a04 	addi	r2,r2,-10968
81102130:	1009883a 	mov	r4,r2
81102134:	00800bc4 	movi	r2,47
81102138:	100d883a 	mov	r6,r2
8110213c:	200b883a 	mov	r5,r4
81102140:	1809883a 	mov	r4,r3
81102144:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102148:	d0a06217 	ldw	r2,-32376(gp)
8110214c:	01604574 	movhi	r5,33045
81102150:	29556904 	addi	r5,r5,21924
81102154:	1009883a 	mov	r4,r2
81102158:	11236500 	call	81123650 <fprintf>
		;
#endif
		return bSuccess;
8110215c:	e0bfef17 	ldw	r2,-68(fp)
81102160:	0000ce06 	br	8110249c <bDdr2MemoryRandomWriteTest+0x454>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102164:	e0bff117 	ldw	r2,-60(fp)
81102168:	1004d53a 	srli	r2,r2,20
8110216c:	100d883a 	mov	r6,r2
81102170:	01604574 	movhi	r5,33045
81102174:	29774304 	addi	r5,r5,-8948
81102178:	01204574 	movhi	r4,33045
8110217c:	21156904 	addi	r4,r4,21924
81102180:	1124f640 	call	81124f64 <sprintf>
	debug(fp, cDebugBuffer);
81102184:	d0a06217 	ldw	r2,-32376(gp)
81102188:	01604574 	movhi	r5,33045
8110218c:	29556904 	addi	r5,r5,21924
81102190:	1009883a 	mov	r4,r2
81102194:	11236500 	call	81123650 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102198:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
8110219c:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
811021a0:	d0a03717 	ldw	r2,-32548(gp)
811021a4:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811021a8:	e0fff017 	ldw	r3,-64(fp)
811021ac:	e0bff117 	ldw	r2,-60(fp)
811021b0:	1885883a 	add	r2,r3,r2
811021b4:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811021b8:	e0fff117 	ldw	r3,-60(fp)
811021bc:	00b33374 	movhi	r2,52429
811021c0:	10b33344 	addi	r2,r2,-13107
811021c4:	1888383a 	mulxuu	r4,r3,r2
811021c8:	1885383a 	mul	r2,r3,r2
811021cc:	1025883a 	mov	r18,r2
811021d0:	2027883a 	mov	r19,r4
811021d4:	9806d13a 	srli	r3,r19,4
811021d8:	e0bff017 	ldw	r2,-64(fp)
811021dc:	1885883a 	add	r2,r3,r2
811021e0:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
811021e4:	00800144 	movi	r2,5
811021e8:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021ec:	00e04574 	movhi	r3,33045
811021f0:	18d56904 	addi	r3,r3,21924
811021f4:	00a04574 	movhi	r2,33045
811021f8:	10b7a504 	addi	r2,r2,-8556
811021fc:	1009883a 	mov	r4,r2
81102200:	00800584 	movi	r2,22
81102204:	100d883a 	mov	r6,r2
81102208:	200b883a 	mov	r5,r4
8110220c:	1809883a 	mov	r4,r3
81102210:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
81102214:	d0a06217 	ldw	r2,-32376(gp)
81102218:	01604574 	movhi	r5,33045
8110221c:	29556904 	addi	r5,r5,21924
81102220:	1009883a 	mov	r4,r2
81102224:	11236500 	call	81123650 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102228:	e0bffa17 	ldw	r2,-24(fp)
8110222c:	10800058 	cmpnei	r2,r2,1
81102230:	10000a1e 	bne	r2,zero,8110225c <bDdr2MemoryRandomWriteTest+0x214>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102234:	01604574 	movhi	r5,33045
81102238:	2977ab04 	addi	r5,r5,-8532
8110223c:	01204574 	movhi	r4,33045
81102240:	21156904 	addi	r4,r4,21924
81102244:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
81102248:	d0a06217 	ldw	r2,-32376(gp)
8110224c:	01604574 	movhi	r5,33045
81102250:	29556904 	addi	r5,r5,21924
81102254:	1009883a 	mov	r4,r2
81102258:	11236500 	call	81123650 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
8110225c:	e03ff615 	stw	zero,-40(fp)
81102260:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102264:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102268:	e0bff017 	ldw	r2,-64(fp)
8110226c:	e0bff215 	stw	r2,-56(fp)
81102270:	00002c06 	br	81102324 <bDdr2MemoryRandomWriteTest+0x2dc>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
81102274:	e0bff804 	addi	r2,fp,-32
81102278:	1009883a 	mov	r4,r2
8110227c:	11029640 	call	81102964 <uliXorshift32>
81102280:	1007883a 	mov	r3,r2
81102284:	e0bff217 	ldw	r2,-56(fp)
81102288:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
8110228c:	e0bffa17 	ldw	r2,-24(fp)
81102290:	10800060 	cmpeqi	r2,r2,1
81102294:	1009883a 	mov	r4,r2
81102298:	e0bff217 	ldw	r2,-56(fp)
8110229c:	e0fff317 	ldw	r3,-52(fp)
811022a0:	1885803a 	cmpltu	r2,r3,r2
811022a4:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
811022a8:	10803fcc 	andi	r2,r2,255
811022ac:	10001a26 	beq	r2,zero,81102318 <bDdr2MemoryRandomWriteTest+0x2d0>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
811022b0:	e0bff403 	ldbu	r2,-48(fp)
811022b4:	100d883a 	mov	r6,r2
811022b8:	01604574 	movhi	r5,33045
811022bc:	2977ad04 	addi	r5,r5,-8524
811022c0:	01204574 	movhi	r4,33045
811022c4:	21156904 	addi	r4,r4,21924
811022c8:	1124f640 	call	81124f64 <sprintf>
			debug(fp, cDebugBuffer);
811022cc:	d0a06217 	ldw	r2,-32376(gp)
811022d0:	01604574 	movhi	r5,33045
811022d4:	29556904 	addi	r5,r5,21924
811022d8:	1009883a 	mov	r4,r2
811022dc:	11236500 	call	81123650 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
811022e0:	e0fff117 	ldw	r3,-60(fp)
811022e4:	00b33374 	movhi	r2,52429
811022e8:	10b33344 	addi	r2,r2,-13107
811022ec:	1888383a 	mulxuu	r4,r3,r2
811022f0:	1885383a 	mul	r2,r3,r2
811022f4:	1021883a 	mov	r16,r2
811022f8:	2023883a 	mov	r17,r4
811022fc:	8804d13a 	srli	r2,r17,4
81102300:	e0fff317 	ldw	r3,-52(fp)
81102304:	1885883a 	add	r2,r3,r2
81102308:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
8110230c:	e0bff403 	ldbu	r2,-48(fp)
81102310:	10800144 	addi	r2,r2,5
81102314:	e0bff405 	stb	r2,-48(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
81102318:	e0bff217 	ldw	r2,-56(fp)
8110231c:	10800104 	addi	r2,r2,4
81102320:	e0bff215 	stw	r2,-56(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
81102324:	e0fff217 	ldw	r3,-56(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102328:	e0bff517 	ldw	r2,-44(fp)
8110232c:	18bfd136 	bltu	r3,r2,81102274 <__reset+0xfb0e2274>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
81102330:	11384e00 	call	811384e0 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
81102334:	e0bffa17 	ldw	r2,-24(fp)
81102338:	10800058 	cmpnei	r2,r2,1
8110233c:	10000a1e 	bne	r2,zero,81102368 <bDdr2MemoryRandomWriteTest+0x320>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102340:	01604574 	movhi	r5,33045
81102344:	2977b004 	addi	r5,r5,-8512
81102348:	01204574 	movhi	r4,33045
8110234c:	21156904 	addi	r4,r4,21924
81102350:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
81102354:	d0a06217 	ldw	r2,-32376(gp)
81102358:	01604574 	movhi	r5,33045
8110235c:	29556904 	addi	r5,r5,21924
81102360:	1009883a 	mov	r4,r2
81102364:	11236500 	call	81123650 <fprintf>
#endif
	}

	if (bSuccess) {
81102368:	e0bfef17 	ldw	r2,-68(fp)
8110236c:	10003126 	beq	r2,zero,81102434 <bDdr2MemoryRandomWriteTest+0x3ec>
		if (bTime == TRUE) {
81102370:	e0bffb17 	ldw	r2,-20(fp)
81102374:	10800058 	cmpnei	r2,r2,1
81102378:	1000221e 	bne	r2,zero,81102404 <bDdr2MemoryRandomWriteTest+0x3bc>
8110237c:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102380:	e0bff717 	ldw	r2,-36(fp)
81102384:	1885c83a 	sub	r2,r3,r2
81102388:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
8110238c:	e13ff617 	ldw	r4,-40(fp)
81102390:	1121d300 	call	81121d30 <__floatsisf>
81102394:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102398:	d0a08817 	ldw	r2,-32224(gp)
8110239c:	1009883a 	mov	r4,r2
811023a0:	1121e5c0 	call	81121e5c <__floatunsisf>
811023a4:	1007883a 	mov	r3,r2
811023a8:	180b883a 	mov	r5,r3
811023ac:	8009883a 	mov	r4,r16
811023b0:	11214e40 	call	811214e4 <__divsf3>
811023b4:	1007883a 	mov	r3,r2
811023b8:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
811023bc:	1009883a 	mov	r4,r2
811023c0:	11231b80 	call	811231b8 <__extendsfdf2>
811023c4:	1009883a 	mov	r4,r2
811023c8:	180b883a 	mov	r5,r3
811023cc:	d9400015 	stw	r5,0(sp)
811023d0:	200f883a 	mov	r7,r4
811023d4:	e1bff117 	ldw	r6,-60(fp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	2977b304 	addi	r5,r5,-8500
811023e0:	01204574 	movhi	r4,33045
811023e4:	21156904 	addi	r4,r4,21924
811023e8:	1124f640 	call	81124f64 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023ec:	d0a06217 	ldw	r2,-32376(gp)
811023f0:	01604574 	movhi	r5,33045
811023f4:	29556904 	addi	r5,r5,21924
811023f8:	1009883a 	mov	r4,r2
811023fc:	11236500 	call	81123650 <fprintf>
81102400:	00001b06 	br	81102470 <bDdr2MemoryRandomWriteTest+0x428>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
81102404:	e1bff117 	ldw	r6,-60(fp)
81102408:	01604574 	movhi	r5,33045
8110240c:	2977bf04 	addi	r5,r5,-8452
81102410:	01204574 	movhi	r4,33045
81102414:	21156904 	addi	r4,r4,21924
81102418:	1124f640 	call	81124f64 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110241c:	d0a06217 	ldw	r2,-32376(gp)
81102420:	01604574 	movhi	r5,33045
81102424:	29556904 	addi	r5,r5,21924
81102428:	1009883a 	mov	r4,r2
8110242c:	11236500 	call	81123650 <fprintf>
81102430:	00000f06 	br	81102470 <bDdr2MemoryRandomWriteTest+0x428>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81102434:	00e04574 	movhi	r3,33045
81102438:	18d56904 	addi	r3,r3,21924
8110243c:	00a04574 	movhi	r2,33045
81102440:	10b75c04 	addi	r2,r2,-8848
81102444:	1009883a 	mov	r4,r2
81102448:	00800584 	movi	r2,22
8110244c:	100d883a 	mov	r6,r2
81102450:	200b883a 	mov	r5,r4
81102454:	1809883a 	mov	r4,r3
81102458:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
8110245c:	d0a06217 	ldw	r2,-32376(gp)
81102460:	01604574 	movhi	r5,33045
81102464:	29556904 	addi	r5,r5,21924
81102468:	1009883a 	mov	r4,r2
8110246c:	11236500 	call	81123650 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102470:	00a04574 	movhi	r2,33045
81102474:	10956904 	addi	r2,r2,21924
81102478:	00c00284 	movi	r3,10
8110247c:	10c00005 	stb	r3,0(r2)
81102480:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102484:	d0a06217 	ldw	r2,-32376(gp)
81102488:	01604574 	movhi	r5,33045
8110248c:	29556904 	addi	r5,r5,21924
81102490:	1009883a 	mov	r4,r2
81102494:	11236500 	call	81123650 <fprintf>
#endif

	return bSuccess;
81102498:	e0bfef17 	ldw	r2,-68(fp)
}
8110249c:	e6fffc04 	addi	sp,fp,-16
811024a0:	dfc00517 	ldw	ra,20(sp)
811024a4:	df000417 	ldw	fp,16(sp)
811024a8:	dcc00317 	ldw	r19,12(sp)
811024ac:	dc800217 	ldw	r18,8(sp)
811024b0:	dc400117 	ldw	r17,4(sp)
811024b4:	dc000017 	ldw	r16,0(sp)
811024b8:	dec00604 	addi	sp,sp,24
811024bc:	f800283a 	ret

811024c0 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
811024c0:	deffec04 	addi	sp,sp,-80
811024c4:	de00012e 	bgeu	sp,et,811024cc <bDdr2MemoryRandomReadTest+0xc>
811024c8:	003b68fa 	trap	3
811024cc:	dfc01315 	stw	ra,76(sp)
811024d0:	df001215 	stw	fp,72(sp)
811024d4:	dcc01115 	stw	r19,68(sp)
811024d8:	dc801015 	stw	r18,64(sp)
811024dc:	dc400f15 	stw	r17,60(sp)
811024e0:	dc000e15 	stw	r16,56(sp)
811024e4:	df001204 	addi	fp,sp,72
811024e8:	2005883a 	mov	r2,r4
811024ec:	e17ffa15 	stw	r5,-24(fp)
811024f0:	e1bffb15 	stw	r6,-20(fp)
811024f4:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024f8:	00e04574 	movhi	r3,33045
811024fc:	18d56904 	addi	r3,r3,21924
81102500:	00a04574 	movhi	r2,33045
81102504:	10b7c904 	addi	r2,r2,-8412
81102508:	1009883a 	mov	r4,r2
8110250c:	00800b84 	movi	r2,46
81102510:	100d883a 	mov	r6,r2
81102514:	200b883a 	mov	r5,r4
81102518:	1809883a 	mov	r4,r3
8110251c:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
81102520:	d0a06217 	ldw	r2,-32376(gp)
81102524:	01604574 	movhi	r5,33045
81102528:	29556904 	addi	r5,r5,21924
8110252c:	1009883a 	mov	r4,r2
81102530:	11236500 	call	81123650 <fprintf>
#endif
	bool bSuccess = FALSE;
81102534:	e03fef15 	stw	zero,-68(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
81102538:	e0bff903 	ldbu	r2,-28(fp)
8110253c:	10000326 	beq	r2,zero,8110254c <bDdr2MemoryRandomReadTest+0x8c>
81102540:	10800060 	cmpeqi	r2,r2,1
81102544:	10000a1e 	bne	r2,zero,81102570 <bDdr2MemoryRandomReadTest+0xb0>
81102548:	00001206 	br	81102594 <bDdr2MemoryRandomReadTest+0xd4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110254c:	e0bff903 	ldbu	r2,-28(fp)
81102550:	1009883a 	mov	r4,r2
81102554:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102558:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
8110255c:	00a00034 	movhi	r2,32768
81102560:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
81102564:	00800044 	movi	r2,1
81102568:	e0bfef15 	stw	r2,-68(fp)
		break;
8110256c:	00001b06 	br	811025dc <bDdr2MemoryRandomReadTest+0x11c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102570:	e0bff903 	ldbu	r2,-28(fp)
81102574:	1009883a 	mov	r4,r2
81102578:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110257c:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102580:	00a00034 	movhi	r2,32768
81102584:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
81102588:	00800044 	movi	r2,1
8110258c:	e0bfef15 	stw	r2,-68(fp)
		break;
81102590:	00001206 	br	811025dc <bDdr2MemoryRandomReadTest+0x11c>
	default:
		bSuccess = FALSE;
81102594:	e03fef15 	stw	zero,-68(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81102598:	00e04574 	movhi	r3,33045
8110259c:	18d56904 	addi	r3,r3,21924
811025a0:	00a04574 	movhi	r2,33045
811025a4:	10b54a04 	addi	r2,r2,-10968
811025a8:	1009883a 	mov	r4,r2
811025ac:	00800bc4 	movi	r2,47
811025b0:	100d883a 	mov	r6,r2
811025b4:	200b883a 	mov	r5,r4
811025b8:	1809883a 	mov	r4,r3
811025bc:	11247000 	call	81124700 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811025c0:	d0a06217 	ldw	r2,-32376(gp)
811025c4:	01604574 	movhi	r5,33045
811025c8:	29556904 	addi	r5,r5,21924
811025cc:	1009883a 	mov	r4,r2
811025d0:	11236500 	call	81123650 <fprintf>
		;
#endif
		return bSuccess;
811025d4:	e0bfef17 	ldw	r2,-68(fp)
811025d8:	0000d906 	br	81102940 <bDdr2MemoryRandomReadTest+0x480>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
811025dc:	e0bff117 	ldw	r2,-60(fp)
811025e0:	1004d53a 	srli	r2,r2,20
811025e4:	100d883a 	mov	r6,r2
811025e8:	01604574 	movhi	r5,33045
811025ec:	29774304 	addi	r5,r5,-8948
811025f0:	01204574 	movhi	r4,33045
811025f4:	21156904 	addi	r4,r4,21924
811025f8:	1124f640 	call	81124f64 <sprintf>
	debug(fp, cDebugBuffer);
811025fc:	d0a06217 	ldw	r2,-32376(gp)
81102600:	01604574 	movhi	r5,33045
81102604:	29556904 	addi	r5,r5,21924
81102608:	1009883a 	mov	r4,r2
8110260c:	11236500 	call	81123650 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
81102610:	d0a03717 	ldw	r2,-32548(gp)
81102614:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102618:	e0fff017 	ldw	r3,-64(fp)
8110261c:	e0bff117 	ldw	r2,-60(fp)
81102620:	1885883a 	add	r2,r3,r2
81102624:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102628:	e0fff117 	ldw	r3,-60(fp)
8110262c:	00b33374 	movhi	r2,52429
81102630:	10b33344 	addi	r2,r2,-13107
81102634:	1888383a 	mulxuu	r4,r3,r2
81102638:	1885383a 	mul	r2,r3,r2
8110263c:	1025883a 	mov	r18,r2
81102640:	2027883a 	mov	r19,r4
81102644:	9806d13a 	srli	r3,r19,4
81102648:	e0bff017 	ldw	r2,-64(fp)
8110264c:	1885883a 	add	r2,r3,r2
81102650:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102654:	00800144 	movi	r2,5
81102658:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
8110265c:	00e04574 	movhi	r3,33045
81102660:	18d56904 	addi	r3,r3,21924
81102664:	00a04574 	movhi	r2,33045
81102668:	10b7d504 	addi	r2,r2,-8364
8110266c:	1009883a 	mov	r4,r2
81102670:	00800604 	movi	r2,24
81102674:	100d883a 	mov	r6,r2
81102678:	200b883a 	mov	r5,r4
8110267c:	1809883a 	mov	r4,r3
81102680:	11247000 	call	81124700 <memcpy>
	debug(fp, cDebugBuffer);
81102684:	d0a06217 	ldw	r2,-32376(gp)
81102688:	01604574 	movhi	r5,33045
8110268c:	29556904 	addi	r5,r5,21924
81102690:	1009883a 	mov	r4,r2
81102694:	11236500 	call	81123650 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102698:	e0bffa17 	ldw	r2,-24(fp)
8110269c:	10800058 	cmpnei	r2,r2,1
811026a0:	10000a1e 	bne	r2,zero,811026cc <bDdr2MemoryRandomReadTest+0x20c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811026a4:	01604574 	movhi	r5,33045
811026a8:	2977ab04 	addi	r5,r5,-8532
811026ac:	01204574 	movhi	r4,33045
811026b0:	21156904 	addi	r4,r4,21924
811026b4:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
811026b8:	d0a06217 	ldw	r2,-32376(gp)
811026bc:	01604574 	movhi	r5,33045
811026c0:	29556904 	addi	r5,r5,21924
811026c4:	1009883a 	mov	r4,r2
811026c8:	11236500 	call	81123650 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
811026cc:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
811026d0:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
811026d4:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
811026d8:	e0bff017 	ldw	r2,-64(fp)
811026dc:	e0bff215 	stw	r2,-56(fp)
811026e0:	00003a06 	br	811027cc <bDdr2MemoryRandomReadTest+0x30c>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
811026e4:	e0bff804 	addi	r2,fp,-32
811026e8:	1009883a 	mov	r4,r2
811026ec:	11029640 	call	81102964 <uliXorshift32>
811026f0:	1007883a 	mov	r3,r2
811026f4:	e0bff217 	ldw	r2,-56(fp)
811026f8:	10800017 	ldw	r2,0(r2)
811026fc:	18801026 	beq	r3,r2,81102740 <bDdr2MemoryRandomReadTest+0x280>
			bSuccess = FALSE;
81102700:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
81102704:	e0bffa17 	ldw	r2,-24(fp)
81102708:	10800058 	cmpnei	r2,r2,1
8110270c:	10000c1e 	bne	r2,zero,81102740 <bDdr2MemoryRandomReadTest+0x280>
#if DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
81102710:	e0bff217 	ldw	r2,-56(fp)
81102714:	100d883a 	mov	r6,r2
81102718:	01604574 	movhi	r5,33045
8110271c:	2977db04 	addi	r5,r5,-8340
81102720:	01204574 	movhi	r4,33045
81102724:	21156904 	addi	r4,r4,21924
81102728:	1124f640 	call	81124f64 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
8110272c:	d0a06217 	ldw	r2,-32376(gp)
81102730:	01604574 	movhi	r5,33045
81102734:	29556904 	addi	r5,r5,21924
81102738:	1009883a 	mov	r4,r2
8110273c:	11236500 	call	81123650 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
81102740:	e0bffa17 	ldw	r2,-24(fp)
81102744:	10800058 	cmpnei	r2,r2,1
81102748:	10001d1e 	bne	r2,zero,811027c0 <bDdr2MemoryRandomReadTest+0x300>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
8110274c:	e0bff217 	ldw	r2,-56(fp)
81102750:	e0fff317 	ldw	r3,-52(fp)
81102754:	18801a2e 	bgeu	r3,r2,811027c0 <bDdr2MemoryRandomReadTest+0x300>
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102758:	e0bff403 	ldbu	r2,-48(fp)
8110275c:	100d883a 	mov	r6,r2
81102760:	01604574 	movhi	r5,33045
81102764:	2977ad04 	addi	r5,r5,-8524
81102768:	01204574 	movhi	r4,33045
8110276c:	21156904 	addi	r4,r4,21924
81102770:	1124f640 	call	81124f64 <sprintf>
			debug(fp, cDebugBuffer);
81102774:	d0a06217 	ldw	r2,-32376(gp)
81102778:	01604574 	movhi	r5,33045
8110277c:	29556904 	addi	r5,r5,21924
81102780:	1009883a 	mov	r4,r2
81102784:	11236500 	call	81123650 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102788:	e0fff117 	ldw	r3,-60(fp)
8110278c:	00b33374 	movhi	r2,52429
81102790:	10b33344 	addi	r2,r2,-13107
81102794:	1888383a 	mulxuu	r4,r3,r2
81102798:	1885383a 	mul	r2,r3,r2
8110279c:	1021883a 	mov	r16,r2
811027a0:	2023883a 	mov	r17,r4
811027a4:	8804d13a 	srli	r2,r17,4
811027a8:	e0fff317 	ldw	r3,-52(fp)
811027ac:	1885883a 	add	r2,r3,r2
811027b0:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
811027b4:	e0bff403 	ldbu	r2,-48(fp)
811027b8:	10800144 	addi	r2,r2,5
811027bc:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
811027c0:	e0bff217 	ldw	r2,-56(fp)
811027c4:	10800104 	addi	r2,r2,4
811027c8:	e0bff215 	stw	r2,-56(fp)
811027cc:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
811027d0:	e0bff517 	ldw	r2,-44(fp)
811027d4:	18bfc336 	bltu	r3,r2,811026e4 <__reset+0xfb0e26e4>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
811027d8:	e0bffa17 	ldw	r2,-24(fp)
811027dc:	10800058 	cmpnei	r2,r2,1
811027e0:	10000a1e 	bne	r2,zero,8110280c <bDdr2MemoryRandomReadTest+0x34c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811027e4:	01604574 	movhi	r5,33045
811027e8:	2977b004 	addi	r5,r5,-8512
811027ec:	01204574 	movhi	r4,33045
811027f0:	21156904 	addi	r4,r4,21924
811027f4:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
811027f8:	d0a06217 	ldw	r2,-32376(gp)
811027fc:	01604574 	movhi	r5,33045
81102800:	29556904 	addi	r5,r5,21924
81102804:	1009883a 	mov	r4,r2
81102808:	11236500 	call	81123650 <fprintf>
#endif
	}

	if (bSuccess) {
8110280c:	e0bfef17 	ldw	r2,-68(fp)
81102810:	10003126 	beq	r2,zero,811028d8 <bDdr2MemoryRandomReadTest+0x418>
		if (bTime == TRUE) {
81102814:	e0bffb17 	ldw	r2,-20(fp)
81102818:	10800058 	cmpnei	r2,r2,1
8110281c:	1000221e 	bne	r2,zero,811028a8 <bDdr2MemoryRandomReadTest+0x3e8>
81102820:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102824:	e0bff717 	ldw	r2,-36(fp)
81102828:	1885c83a 	sub	r2,r3,r2
8110282c:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102830:	e13ff617 	ldw	r4,-40(fp)
81102834:	1121d300 	call	81121d30 <__floatsisf>
81102838:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8110283c:	d0a08817 	ldw	r2,-32224(gp)
81102840:	1009883a 	mov	r4,r2
81102844:	1121e5c0 	call	81121e5c <__floatunsisf>
81102848:	1007883a 	mov	r3,r2
8110284c:	180b883a 	mov	r5,r3
81102850:	8009883a 	mov	r4,r16
81102854:	11214e40 	call	811214e4 <__divsf3>
81102858:	1007883a 	mov	r3,r2
8110285c:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
81102860:	1009883a 	mov	r4,r2
81102864:	11231b80 	call	811231b8 <__extendsfdf2>
81102868:	1009883a 	mov	r4,r2
8110286c:	180b883a 	mov	r5,r3
81102870:	d9400015 	stw	r5,0(sp)
81102874:	200f883a 	mov	r7,r4
81102878:	e1bff117 	ldw	r6,-60(fp)
8110287c:	01604574 	movhi	r5,33045
81102880:	2977e304 	addi	r5,r5,-8308
81102884:	01204574 	movhi	r4,33045
81102888:	21156904 	addi	r4,r4,21924
8110288c:	1124f640 	call	81124f64 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
81102890:	d0a06217 	ldw	r2,-32376(gp)
81102894:	01604574 	movhi	r5,33045
81102898:	29556904 	addi	r5,r5,21924
8110289c:	1009883a 	mov	r4,r2
811028a0:	11236500 	call	81123650 <fprintf>
811028a4:	00001b06 	br	81102914 <bDdr2MemoryRandomReadTest+0x454>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
811028a8:	e1bff117 	ldw	r6,-60(fp)
811028ac:	01604574 	movhi	r5,33045
811028b0:	2977ef04 	addi	r5,r5,-8260
811028b4:	01204574 	movhi	r4,33045
811028b8:	21156904 	addi	r4,r4,21924
811028bc:	1124f640 	call	81124f64 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811028c0:	d0a06217 	ldw	r2,-32376(gp)
811028c4:	01604574 	movhi	r5,33045
811028c8:	29556904 	addi	r5,r5,21924
811028cc:	1009883a 	mov	r4,r2
811028d0:	11236500 	call	81123650 <fprintf>
811028d4:	00000f06 	br	81102914 <bDdr2MemoryRandomReadTest+0x454>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
811028d8:	00e04574 	movhi	r3,33045
811028dc:	18d56904 	addi	r3,r3,21924
811028e0:	00a04574 	movhi	r2,33045
811028e4:	10b79304 	addi	r2,r2,-8628
811028e8:	1009883a 	mov	r4,r2
811028ec:	00800544 	movi	r2,21
811028f0:	100d883a 	mov	r6,r2
811028f4:	200b883a 	mov	r5,r4
811028f8:	1809883a 	mov	r4,r3
811028fc:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
81102900:	d0a06217 	ldw	r2,-32376(gp)
81102904:	01604574 	movhi	r5,33045
81102908:	29556904 	addi	r5,r5,21924
8110290c:	1009883a 	mov	r4,r2
81102910:	11236500 	call	81123650 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102914:	00a04574 	movhi	r2,33045
81102918:	10956904 	addi	r2,r2,21924
8110291c:	00c00284 	movi	r3,10
81102920:	10c00005 	stb	r3,0(r2)
81102924:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102928:	d0a06217 	ldw	r2,-32376(gp)
8110292c:	01604574 	movhi	r5,33045
81102930:	29556904 	addi	r5,r5,21924
81102934:	1009883a 	mov	r4,r2
81102938:	11236500 	call	81123650 <fprintf>
#endif

	return bSuccess;
8110293c:	e0bfef17 	ldw	r2,-68(fp)
}
81102940:	e6fffc04 	addi	sp,fp,-16
81102944:	dfc00517 	ldw	ra,20(sp)
81102948:	df000417 	ldw	fp,16(sp)
8110294c:	dcc00317 	ldw	r19,12(sp)
81102950:	dc800217 	ldw	r18,8(sp)
81102954:	dc400117 	ldw	r17,4(sp)
81102958:	dc000017 	ldw	r16,0(sp)
8110295c:	dec00604 	addi	sp,sp,24
81102960:	f800283a 	ret

81102964 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102964:	defffd04 	addi	sp,sp,-12
81102968:	de00012e 	bgeu	sp,et,81102970 <uliXorshift32+0xc>
8110296c:	003b68fa 	trap	3
81102970:	df000215 	stw	fp,8(sp)
81102974:	df000204 	addi	fp,sp,8
81102978:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
8110297c:	e0bfff17 	ldw	r2,-4(fp)
81102980:	10800017 	ldw	r2,0(r2)
81102984:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102988:	e0bffe17 	ldw	r2,-8(fp)
8110298c:	1004937a 	slli	r2,r2,13
81102990:	e0fffe17 	ldw	r3,-8(fp)
81102994:	1884f03a 	xor	r2,r3,r2
81102998:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
8110299c:	e0bffe17 	ldw	r2,-8(fp)
811029a0:	1004d47a 	srli	r2,r2,17
811029a4:	e0fffe17 	ldw	r3,-8(fp)
811029a8:	1884f03a 	xor	r2,r3,r2
811029ac:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
811029b0:	e0bffe17 	ldw	r2,-8(fp)
811029b4:	1004917a 	slli	r2,r2,5
811029b8:	e0fffe17 	ldw	r3,-8(fp)
811029bc:	1884f03a 	xor	r2,r3,r2
811029c0:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
811029c4:	e0bfff17 	ldw	r2,-4(fp)
811029c8:	e0fffe17 	ldw	r3,-8(fp)
811029cc:	10c00015 	stw	r3,0(r2)

	return uliX;
811029d0:	e0bffe17 	ldw	r2,-8(fp)
}
811029d4:	e037883a 	mov	sp,fp
811029d8:	df000017 	ldw	fp,0(sp)
811029dc:	dec00104 	addi	sp,sp,4
811029e0:	f800283a 	ret

811029e4 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
811029e4:	defffb04 	addi	sp,sp,-20
811029e8:	de00012e 	bgeu	sp,et,811029f0 <DMA_OPEN_DEVICE+0xc>
811029ec:	003b68fa 	trap	3
811029f0:	dfc00415 	stw	ra,16(sp)
811029f4:	df000315 	stw	fp,12(sp)
811029f8:	df000304 	addi	fp,sp,12
811029fc:	e13ffe15 	stw	r4,-8(fp)
81102a00:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a04:	00800044 	movi	r2,1
81102a08:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
81102a0c:	e13fff17 	ldw	r4,-4(fp)
81102a10:	114bda00 	call	8114bda0 <alt_msgdma_open>
81102a14:	1007883a 	mov	r3,r2
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
81102a20:	e0bffe17 	ldw	r2,-8(fp)
81102a24:	10800017 	ldw	r2,0(r2)
81102a28:	1000011e 	bne	r2,zero,81102a30 <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
81102a2c:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
81102a30:	e0bffd17 	ldw	r2,-12(fp)
}
81102a34:	e037883a 	mov	sp,fp
81102a38:	dfc00117 	ldw	ra,4(sp)
81102a3c:	df000017 	ldw	fp,0(sp)
81102a40:	dec00204 	addi	sp,sp,8
81102a44:	f800283a 	ret

81102a48 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
81102a48:	defffc04 	addi	sp,sp,-16
81102a4c:	de00012e 	bgeu	sp,et,81102a54 <DMA_CONFIG+0xc>
81102a50:	003b68fa 	trap	3
81102a54:	df000315 	stw	fp,12(sp)
81102a58:	df000304 	addi	fp,sp,12
81102a5c:	e13ffe15 	stw	r4,-8(fp)
81102a60:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a64:	00800044 	movi	r2,1
81102a68:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a6c:	e0bffe17 	ldw	r2,-8(fp)
81102a70:	10800317 	ldw	r2,12(r2)
81102a74:	10800104 	addi	r2,r2,4
81102a78:	e0ffff17 	ldw	r3,-4(fp)
81102a7c:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a80:	e0bffd17 	ldw	r2,-12(fp)
}
81102a84:	e037883a 	mov	sp,fp
81102a88:	df000017 	ldw	fp,0(sp)
81102a8c:	dec00104 	addi	sp,sp,4
81102a90:	f800283a 	ret

81102a94 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a94:	defffd04 	addi	sp,sp,-12
81102a98:	de00012e 	bgeu	sp,et,81102aa0 <DMA_BUSY+0xc>
81102a9c:	003b68fa 	trap	3
81102aa0:	df000215 	stw	fp,8(sp)
81102aa4:	df000204 	addi	fp,sp,8
81102aa8:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102aac:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102ab0:	e0bfff17 	ldw	r2,-4(fp)
81102ab4:	10800317 	ldw	r2,12(r2)
81102ab8:	10800037 	ldwio	r2,0(r2)
81102abc:	1080004c 	andi	r2,r2,1
81102ac0:	10000226 	beq	r2,zero,81102acc <DMA_BUSY+0x38>
    bBusy = TRUE;
81102ac4:	00800044 	movi	r2,1
81102ac8:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102acc:	e0bffe17 	ldw	r2,-8(fp)
}
81102ad0:	e037883a 	mov	sp,fp
81102ad4:	df000017 	ldw	fp,0(sp)
81102ad8:	dec00104 	addi	sp,sp,4
81102adc:	f800283a 	ret

81102ae0 <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102ae0:	defffd04 	addi	sp,sp,-12
81102ae4:	de00012e 	bgeu	sp,et,81102aec <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102ae8:	003b68fa 	trap	3
81102aec:	df000215 	stw	fp,8(sp)
81102af0:	df000204 	addi	fp,sp,8
81102af4:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102af8:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102afc:	e0bfff17 	ldw	r2,-4(fp)
81102b00:	10800317 	ldw	r2,12(r2)
81102b04:	10800037 	ldwio	r2,0(r2)
81102b08:	1080010c 	andi	r2,r2,4
81102b0c:	10000226 	beq	r2,zero,81102b18 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102b10:	00800044 	movi	r2,1
81102b14:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102b18:	e0bffe17 	ldw	r2,-8(fp)
}
81102b1c:	e037883a 	mov	sp,fp
81102b20:	df000017 	ldw	fp,0(sp)
81102b24:	dec00104 	addi	sp,sp,4
81102b28:	f800283a 	ret

81102b2c <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102b2c:	defffd04 	addi	sp,sp,-12
81102b30:	de00012e 	bgeu	sp,et,81102b38 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102b34:	003b68fa 	trap	3
81102b38:	df000215 	stw	fp,8(sp)
81102b3c:	df000204 	addi	fp,sp,8
81102b40:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102b44:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102b48:	e0bfff17 	ldw	r2,-4(fp)
81102b4c:	10800317 	ldw	r2,12(r2)
81102b50:	10800037 	ldwio	r2,0(r2)
81102b54:	1080008c 	andi	r2,r2,2
81102b58:	10000226 	beq	r2,zero,81102b64 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b5c:	00800044 	movi	r2,1
81102b60:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b64:	e0bffe17 	ldw	r2,-8(fp)
}
81102b68:	e037883a 	mov	sp,fp
81102b6c:	df000017 	ldw	fp,0(sp)
81102b70:	dec00104 	addi	sp,sp,4
81102b74:	f800283a 	ret

81102b78 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b78:	defffa04 	addi	sp,sp,-24
81102b7c:	de00012e 	bgeu	sp,et,81102b84 <DMA_DISPATCHER_STOP+0xc>
81102b80:	003b68fa 	trap	3
81102b84:	dfc00515 	stw	ra,20(sp)
81102b88:	df000415 	stw	fp,16(sp)
81102b8c:	df000404 	addi	fp,sp,16
81102b90:	e13ffd15 	stw	r4,-12(fp)
81102b94:	e17ffe15 	stw	r5,-8(fp)
81102b98:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b9c:	00800044 	movi	r2,1
81102ba0:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102ba4:	e0bffd17 	ldw	r2,-12(fp)
81102ba8:	10800317 	ldw	r2,12(r2)
81102bac:	10800104 	addi	r2,r2,4
81102bb0:	00c00044 	movi	r3,1
81102bb4:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102bb8:	e0bffe17 	ldw	r2,-8(fp)
81102bbc:	10800058 	cmpnei	r2,r2,1
81102bc0:	10000f1e 	bne	r2,zero,81102c00 <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102bc4:	00000806 	br	81102be8 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102bc8:	e0bfff17 	ldw	r2,-4(fp)
81102bcc:	1000031e 	bne	r2,zero,81102bdc <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102bd0:	01000044 	movi	r4,1
81102bd4:	1139d080 	call	81139d08 <usleep>
81102bd8:	00000306 	br	81102be8 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102bdc:	e0bfff17 	ldw	r2,-4(fp)
81102be0:	1009883a 	mov	r4,r2
81102be4:	1139d080 	call	81139d08 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102be8:	e0bffd17 	ldw	r2,-12(fp)
81102bec:	10800317 	ldw	r2,12(r2)
81102bf0:	10800037 	ldwio	r2,0(r2)
81102bf4:	1080080c 	andi	r2,r2,32
81102bf8:	103ff31e 	bne	r2,zero,81102bc8 <__reset+0xfb0e2bc8>
81102bfc:	00000206 	br	81102c08 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c00:	e0bffc17 	ldw	r2,-16(fp)
81102c04:	00000106 	br	81102c0c <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102c08:	e0bffc17 	ldw	r2,-16(fp)
}
81102c0c:	e037883a 	mov	sp,fp
81102c10:	dfc00117 	ldw	ra,4(sp)
81102c14:	df000017 	ldw	fp,0(sp)
81102c18:	dec00204 	addi	sp,sp,8
81102c1c:	f800283a 	ret

81102c20 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102c20:	defffa04 	addi	sp,sp,-24
81102c24:	de00012e 	bgeu	sp,et,81102c2c <DMA_DISPATCHER_RESET+0xc>
81102c28:	003b68fa 	trap	3
81102c2c:	dfc00515 	stw	ra,20(sp)
81102c30:	df000415 	stw	fp,16(sp)
81102c34:	df000404 	addi	fp,sp,16
81102c38:	e13ffd15 	stw	r4,-12(fp)
81102c3c:	e17ffe15 	stw	r5,-8(fp)
81102c40:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102c44:	00800044 	movi	r2,1
81102c48:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102c4c:	e0bffd17 	ldw	r2,-12(fp)
81102c50:	10800317 	ldw	r2,12(r2)
81102c54:	10800104 	addi	r2,r2,4
81102c58:	00c00084 	movi	r3,2
81102c5c:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c60:	e0bffe17 	ldw	r2,-8(fp)
81102c64:	10800058 	cmpnei	r2,r2,1
81102c68:	10000f1e 	bne	r2,zero,81102ca8 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c6c:	00000806 	br	81102c90 <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c70:	e0bfff17 	ldw	r2,-4(fp)
81102c74:	1000031e 	bne	r2,zero,81102c84 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c78:	01000044 	movi	r4,1
81102c7c:	1139d080 	call	81139d08 <usleep>
81102c80:	00000306 	br	81102c90 <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c84:	e0bfff17 	ldw	r2,-4(fp)
81102c88:	1009883a 	mov	r4,r2
81102c8c:	1139d080 	call	81139d08 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c90:	e0bffd17 	ldw	r2,-12(fp)
81102c94:	10800317 	ldw	r2,12(r2)
81102c98:	10800037 	ldwio	r2,0(r2)
81102c9c:	1080100c 	andi	r2,r2,64
81102ca0:	103ff31e 	bne	r2,zero,81102c70 <__reset+0xfb0e2c70>
81102ca4:	00000206 	br	81102cb0 <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102ca8:	e0bffc17 	ldw	r2,-16(fp)
81102cac:	00000106 	br	81102cb4 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102cb0:	e0bffc17 	ldw	r2,-16(fp)
}
81102cb4:	e037883a 	mov	sp,fp
81102cb8:	dfc00117 	ldw	ra,4(sp)
81102cbc:	df000017 	ldw	fp,0(sp)
81102cc0:	dec00204 	addi	sp,sp,8
81102cc4:	f800283a 	ret

81102cc8 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102cc8:	defff604 	addi	sp,sp,-40
81102ccc:	de00012e 	bgeu	sp,et,81102cd4 <DMA_SINGLE_TRANSFER+0xc>
81102cd0:	003b68fa 	trap	3
81102cd4:	dfc00915 	stw	ra,36(sp)
81102cd8:	df000815 	stw	fp,32(sp)
81102cdc:	dc000715 	stw	r16,28(sp)
81102ce0:	df000804 	addi	fp,sp,32
81102ce4:	e13ffb15 	stw	r4,-20(fp)
81102ce8:	e17ffc15 	stw	r5,-16(fp)
81102cec:	e1bffd15 	stw	r6,-12(fp)
81102cf0:	e1fffe15 	stw	r7,-8(fp)
81102cf4:	defff804 	addi	sp,sp,-32
81102cf8:	d8800204 	addi	r2,sp,8
81102cfc:	108003c4 	addi	r2,r2,15
81102d00:	1004d13a 	srli	r2,r2,4
81102d04:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102d08:	00800044 	movi	r2,1
81102d0c:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102d10:	e0fffc17 	ldw	r3,-16(fp)
81102d14:	e13ffd17 	ldw	r4,-12(fp)
81102d18:	e0800217 	ldw	r2,8(fp)
81102d1c:	d8800115 	stw	r2,4(sp)
81102d20:	e0bffe17 	ldw	r2,-8(fp)
81102d24:	d8800015 	stw	r2,0(sp)
81102d28:	200f883a 	mov	r7,r4
81102d2c:	180d883a 	mov	r6,r3
81102d30:	800b883a 	mov	r5,r16
81102d34:	e13ffb17 	ldw	r4,-20(fp)
81102d38:	114ad9c0 	call	8114ad9c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102d3c:	10000326 	beq	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102d40:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102d44:	e0bffa17 	ldw	r2,-24(fp)
81102d48:	00001e06 	br	81102dc4 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102d4c:	800b883a 	mov	r5,r16
81102d50:	e13ffb17 	ldw	r4,-20(fp)
81102d54:	114c0100 	call	8114c010 <alt_msgdma_standard_descriptor_async_transfer>
81102d58:	10000326 	beq	r2,zero,81102d68 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d5c:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d60:	e0bffa17 	ldw	r2,-24(fp)
81102d64:	00001706 	br	81102dc4 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d68:	e0bffa17 	ldw	r2,-24(fp)
81102d6c:	10800060 	cmpeqi	r2,r2,1
81102d70:	1007883a 	mov	r3,r2
81102d74:	e0800317 	ldw	r2,12(fp)
81102d78:	10800060 	cmpeqi	r2,r2,1
81102d7c:	1884703a 	and	r2,r3,r2
81102d80:	10803fcc 	andi	r2,r2,255
81102d84:	10000e26 	beq	r2,zero,81102dc0 <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d88:	00000806 	br	81102dac <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d8c:	e0800417 	ldw	r2,16(fp)
81102d90:	1000031e 	bne	r2,zero,81102da0 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d94:	0100fa04 	movi	r4,1000
81102d98:	1139d080 	call	81139d08 <usleep>
81102d9c:	00000306 	br	81102dac <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102da0:	e0800417 	ldw	r2,16(fp)
81102da4:	1009883a 	mov	r4,r2
81102da8:	1139d080 	call	81139d08 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102dac:	e0bffb17 	ldw	r2,-20(fp)
81102db0:	10800317 	ldw	r2,12(r2)
81102db4:	10800037 	ldwio	r2,0(r2)
81102db8:	1080004c 	andi	r2,r2,1
81102dbc:	103ff31e 	bne	r2,zero,81102d8c <__reset+0xfb0e2d8c>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102dc0:	e0bffa17 	ldw	r2,-24(fp)
}
81102dc4:	e6ffff04 	addi	sp,fp,-4
81102dc8:	dfc00217 	ldw	ra,8(sp)
81102dcc:	df000117 	ldw	fp,4(sp)
81102dd0:	dc000017 	ldw	r16,0(sp)
81102dd4:	dec00304 	addi	sp,sp,12
81102dd8:	f800283a 	ret

81102ddc <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102ddc:	defff504 	addi	sp,sp,-44
81102de0:	de00012e 	bgeu	sp,et,81102de8 <DMA_MULTIPLE_TRANSFER+0xc>
81102de4:	003b68fa 	trap	3
81102de8:	dfc00a15 	stw	ra,40(sp)
81102dec:	df000915 	stw	fp,36(sp)
81102df0:	dc000815 	stw	r16,32(sp)
81102df4:	df000904 	addi	fp,sp,36
81102df8:	e13ffb15 	stw	r4,-20(fp)
81102dfc:	e17ffc15 	stw	r5,-16(fp)
81102e00:	e1bffd15 	stw	r6,-12(fp)
81102e04:	3805883a 	mov	r2,r7
81102e08:	e0bffe05 	stb	r2,-8(fp)
81102e0c:	defff804 	addi	sp,sp,-32
81102e10:	d8800204 	addi	r2,sp,8
81102e14:	108003c4 	addi	r2,r2,15
81102e18:	1004d13a 	srli	r2,r2,4
81102e1c:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102e20:	00800044 	movi	r2,1
81102e24:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102e28:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e2c:	00002506 	br	81102ec4 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102e30:	e0bffa03 	ldbu	r2,-24(fp)
81102e34:	1085883a 	add	r2,r2,r2
81102e38:	1085883a 	add	r2,r2,r2
81102e3c:	1007883a 	mov	r3,r2
81102e40:	e0bffc17 	ldw	r2,-16(fp)
81102e44:	10c5883a 	add	r2,r2,r3
81102e48:	10800017 	ldw	r2,0(r2)
81102e4c:	1009883a 	mov	r4,r2
81102e50:	e0bffa03 	ldbu	r2,-24(fp)
81102e54:	1085883a 	add	r2,r2,r2
81102e58:	1085883a 	add	r2,r2,r2
81102e5c:	1007883a 	mov	r3,r2
81102e60:	e0bffd17 	ldw	r2,-12(fp)
81102e64:	10c5883a 	add	r2,r2,r3
81102e68:	10800017 	ldw	r2,0(r2)
81102e6c:	1007883a 	mov	r3,r2
81102e70:	e0800317 	ldw	r2,12(fp)
81102e74:	10804034 	orhi	r2,r2,256
81102e78:	d8800115 	stw	r2,4(sp)
81102e7c:	e0800217 	ldw	r2,8(fp)
81102e80:	d8800015 	stw	r2,0(sp)
81102e84:	180f883a 	mov	r7,r3
81102e88:	200d883a 	mov	r6,r4
81102e8c:	800b883a 	mov	r5,r16
81102e90:	e13ffb17 	ldw	r4,-20(fp)
81102e94:	114ad9c0 	call	8114ad9c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e98:	10000226 	beq	r2,zero,81102ea4 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e9c:	e03ff915 	stw	zero,-28(fp)
81102ea0:	00000506 	br	81102eb8 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102ea4:	800b883a 	mov	r5,r16
81102ea8:	e13ffb17 	ldw	r4,-20(fp)
81102eac:	114c0100 	call	8114c010 <alt_msgdma_standard_descriptor_async_transfer>
81102eb0:	10000126 	beq	r2,zero,81102eb8 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102eb4:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102eb8:	e0bffa03 	ldbu	r2,-24(fp)
81102ebc:	10800044 	addi	r2,r2,1
81102ec0:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102ec4:	e0bff917 	ldw	r2,-28(fp)
81102ec8:	10800060 	cmpeqi	r2,r2,1
81102ecc:	1009883a 	mov	r4,r2
81102ed0:	e0fffa03 	ldbu	r3,-24(fp)
81102ed4:	e0bffe03 	ldbu	r2,-8(fp)
81102ed8:	10bfffc4 	addi	r2,r2,-1
81102edc:	1884803a 	cmplt	r2,r3,r2
81102ee0:	2084703a 	and	r2,r4,r2
81102ee4:	10803fcc 	andi	r2,r2,255
81102ee8:	103fd11e 	bne	r2,zero,81102e30 <__reset+0xfb0e2e30>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102eec:	e0bff917 	ldw	r2,-28(fp)
81102ef0:	10800058 	cmpnei	r2,r2,1
81102ef4:	1000211e 	bne	r2,zero,81102f7c <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ef8:	e0bffa03 	ldbu	r2,-24(fp)
81102efc:	1085883a 	add	r2,r2,r2
81102f00:	1085883a 	add	r2,r2,r2
81102f04:	1007883a 	mov	r3,r2
81102f08:	e0bffc17 	ldw	r2,-16(fp)
81102f0c:	10c5883a 	add	r2,r2,r3
81102f10:	10800017 	ldw	r2,0(r2)
81102f14:	1009883a 	mov	r4,r2
81102f18:	e0bffa03 	ldbu	r2,-24(fp)
81102f1c:	1085883a 	add	r2,r2,r2
81102f20:	1085883a 	add	r2,r2,r2
81102f24:	1007883a 	mov	r3,r2
81102f28:	e0bffd17 	ldw	r2,-12(fp)
81102f2c:	10c5883a 	add	r2,r2,r3
81102f30:	10800017 	ldw	r2,0(r2)
81102f34:	1007883a 	mov	r3,r2
81102f38:	e0800317 	ldw	r2,12(fp)
81102f3c:	d8800115 	stw	r2,4(sp)
81102f40:	e0800217 	ldw	r2,8(fp)
81102f44:	d8800015 	stw	r2,0(sp)
81102f48:	180f883a 	mov	r7,r3
81102f4c:	200d883a 	mov	r6,r4
81102f50:	800b883a 	mov	r5,r16
81102f54:	e13ffb17 	ldw	r4,-20(fp)
81102f58:	114ad9c0 	call	8114ad9c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f5c:	10000226 	beq	r2,zero,81102f68 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f60:	e03ff915 	stw	zero,-28(fp)
81102f64:	00000506 	br	81102f7c <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f68:	800b883a 	mov	r5,r16
81102f6c:	e13ffb17 	ldw	r4,-20(fp)
81102f70:	114c0100 	call	8114c010 <alt_msgdma_standard_descriptor_async_transfer>
81102f74:	10000126 	beq	r2,zero,81102f7c <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f78:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f7c:	e0bff917 	ldw	r2,-28(fp)
81102f80:	10800060 	cmpeqi	r2,r2,1
81102f84:	1007883a 	mov	r3,r2
81102f88:	e0800417 	ldw	r2,16(fp)
81102f8c:	10800060 	cmpeqi	r2,r2,1
81102f90:	1884703a 	and	r2,r3,r2
81102f94:	10803fcc 	andi	r2,r2,255
81102f98:	10000e26 	beq	r2,zero,81102fd4 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f9c:	00000806 	br	81102fc0 <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102fa0:	e0800517 	ldw	r2,20(fp)
81102fa4:	1000031e 	bne	r2,zero,81102fb4 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102fa8:	0100fa04 	movi	r4,1000
81102fac:	1139d080 	call	81139d08 <usleep>
81102fb0:	00000306 	br	81102fc0 <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102fb4:	e0800517 	ldw	r2,20(fp)
81102fb8:	1009883a 	mov	r4,r2
81102fbc:	1139d080 	call	81139d08 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102fc0:	e0bffb17 	ldw	r2,-20(fp)
81102fc4:	10800317 	ldw	r2,12(r2)
81102fc8:	10800037 	ldwio	r2,0(r2)
81102fcc:	1080004c 	andi	r2,r2,1
81102fd0:	103ff31e 	bne	r2,zero,81102fa0 <__reset+0xfb0e2fa0>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102fd4:	e0bff917 	ldw	r2,-28(fp)
}
81102fd8:	e6ffff04 	addi	sp,fp,-4
81102fdc:	dfc00217 	ldw	ra,8(sp)
81102fe0:	df000117 	ldw	fp,4(sp)
81102fe4:	dc000017 	ldw	r16,0(sp)
81102fe8:	dec00304 	addi	sp,sp,12
81102fec:	f800283a 	ret

81102ff0 <POWER_Read>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102ff0:	deffef04 	addi	sp,sp,-68
81102ff4:	de00012e 	bgeu	sp,et,81102ffc <POWER_Read+0xc>
81102ff8:	003b68fa 	trap	3
81102ffc:	dfc01015 	stw	ra,64(sp)
81103000:	df000f15 	stw	fp,60(sp)
81103004:	df000f04 	addi	fp,sp,60
81103008:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
8110300c:	00800044 	movi	r2,1
81103010:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81103014:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81103018:	00800204 	movi	r2,8
8110301c:	e0bffc15 	stw	r2,-16(fp)
81103020:	00800104 	movi	r2,4
81103024:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81103028:	00800044 	movi	r2,1
8110302c:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81103030:	00800044 	movi	r2,1
81103034:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81103038:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110303c:	e03ff515 	stw	zero,-44(fp)
81103040:	00009206 	br	8110328c <POWER_Read+0x29c>
		NextChannel = 0;
81103044:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81103048:	e0bff517 	ldw	r2,-44(fp)
8110304c:	10c03fcc 	andi	r3,r2,255
81103050:	e13ffa03 	ldbu	r4,-24(fp)
81103054:	e0bfff17 	ldw	r2,-4(fp)
81103058:	d8800115 	stw	r2,4(sp)
8110305c:	e0bff917 	ldw	r2,-28(fp)
81103060:	d8800015 	stw	r2,0(sp)
81103064:	e1fff817 	ldw	r7,-32(fp)
81103068:	e1bff717 	ldw	r6,-36(fp)
8110306c:	200b883a 	mov	r5,r4
81103070:	1809883a 	mov	r4,r3
81103074:	110c9080 	call	8110c908 <POWER_SPI_RW>
81103078:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
8110307c:	e03ff415 	stw	zero,-48(fp)
81103080:	00007406 	br	81103254 <POWER_Read+0x264>
			NextChannel = i + 1;
81103084:	e0bff417 	ldw	r2,-48(fp)
81103088:	10800044 	addi	r2,r2,1
8110308c:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
81103090:	e0bff517 	ldw	r2,-44(fp)
81103094:	10c03fcc 	andi	r3,r2,255
81103098:	e13ffa03 	ldbu	r4,-24(fp)
8110309c:	e0bffe04 	addi	r2,fp,-8
811030a0:	d8800115 	stw	r2,4(sp)
811030a4:	e0bff917 	ldw	r2,-28(fp)
811030a8:	d8800015 	stw	r2,0(sp)
811030ac:	e1fff817 	ldw	r7,-32(fp)
811030b0:	e1bff717 	ldw	r6,-36(fp)
811030b4:	200b883a 	mov	r5,r4
811030b8:	1809883a 	mov	r4,r3
811030bc:	110c9080 	call	8110c908 <POWER_SPI_RW>
811030c0:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
811030c4:	e0bff317 	ldw	r2,-52(fp)
811030c8:	10005026 	beq	r2,zero,8110320c <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
811030cc:	e0bffe17 	ldw	r2,-8(fp)
811030d0:	1004d7ba 	srli	r2,r2,30
811030d4:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
811030d8:	e0bffe17 	ldw	r2,-8(fp)
811030dc:	1004d07a 	srli	r2,r2,1
811030e0:	108001cc 	andi	r2,r2,7
811030e4:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
811030e8:	e0bffe17 	ldw	r2,-8(fp)
811030ec:	1004d13a 	srli	r2,r2,4
811030f0:	1080004c 	andi	r2,r2,1
811030f4:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030f8:	e0bffe17 	ldw	r2,-8(fp)
811030fc:	1004d17a 	srli	r2,r2,5
81103100:	1080004c 	andi	r2,r2,1
81103104:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
81103108:	e0bffe17 	ldw	r2,-8(fp)
8110310c:	1080004c 	andi	r2,r2,1
81103110:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
81103114:	e0bffa43 	ldbu	r2,-23(fp)
81103118:	10000d26 	beq	r2,zero,81103150 <POWER_Read+0x160>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
8110311c:	e1bff417 	ldw	r6,-48(fp)
81103120:	01604574 	movhi	r5,33045
81103124:	2977f904 	addi	r5,r5,-8220
81103128:	01204574 	movhi	r4,33045
8110312c:	21156904 	addi	r4,r4,21924
81103130:	1124f640 	call	81124f64 <sprintf>
					debug(fp, cDebugBuffer);
81103134:	d0a06217 	ldw	r2,-32376(gp)
81103138:	01604574 	movhi	r5,33045
8110313c:	29556904 	addi	r5,r5,21924
81103140:	1009883a 	mov	r4,r2
81103144:	11236500 	call	81123650 <fprintf>
#endif
					bSuccess = FALSE;
81103148:	e03ff315 	stw	zero,-52(fp)
8110314c:	00002206 	br	811031d8 <POWER_Read+0x1e8>
				} else if (Channel != i) {
81103150:	e0fffa83 	ldbu	r3,-22(fp)
81103154:	e0bff417 	ldw	r2,-48(fp)
81103158:	18801026 	beq	r3,r2,8110319c <POWER_Read+0x1ac>
#if DEBUG_ON
					sprintf(cDebugBuffer,
8110315c:	e0bffa83 	ldbu	r2,-22(fp)
81103160:	d8800015 	stw	r2,0(sp)
81103164:	e1fff417 	ldw	r7,-48(fp)
81103168:	e1bff417 	ldw	r6,-48(fp)
8110316c:	01604574 	movhi	r5,33045
81103170:	2977ff04 	addi	r5,r5,-8196
81103174:	01204574 	movhi	r4,33045
81103178:	21156904 	addi	r4,r4,21924
8110317c:	1124f640 	call	81124f64 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
81103180:	d0a06217 	ldw	r2,-32376(gp)
81103184:	01604574 	movhi	r5,33045
81103188:	29556904 	addi	r5,r5,21924
8110318c:	1009883a 	mov	r4,r2
81103190:	11236500 	call	81123650 <fprintf>
#endif
					bSuccess = FALSE;
81103194:	e03ff315 	stw	zero,-52(fp)
81103198:	00000f06 	br	811031d8 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
8110319c:	e0fffac3 	ldbu	r3,-21(fp)
811031a0:	e0bff817 	ldw	r2,-32(fp)
811031a4:	18800c26 	beq	r3,r2,811031d8 <POWER_Read+0x1e8>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
811031a8:	e1bff417 	ldw	r6,-48(fp)
811031ac:	01604574 	movhi	r5,33045
811031b0:	29780b04 	addi	r5,r5,-8148
811031b4:	01204574 	movhi	r4,33045
811031b8:	21156904 	addi	r4,r4,21924
811031bc:	1124f640 	call	81124f64 <sprintf>
					debug(fp, cDebugBuffer);
811031c0:	d0a06217 	ldw	r2,-32376(gp)
811031c4:	01604574 	movhi	r5,33045
811031c8:	29556904 	addi	r5,r5,21924
811031cc:	1009883a 	mov	r4,r2
811031d0:	11236500 	call	81123650 <fprintf>
#endif
					bSuccess = FALSE;
811031d4:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
811031d8:	e0bff317 	ldw	r2,-52(fp)
811031dc:	10001a26 	beq	r2,zero,81103248 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
811031e0:	e0bff617 	ldw	r2,-40(fp)
811031e4:	10c00044 	addi	r3,r2,1
811031e8:	e0fff615 	stw	r3,-40(fp)
811031ec:	1085883a 	add	r2,r2,r2
811031f0:	1085883a 	add	r2,r2,r2
811031f4:	1007883a 	mov	r3,r2
811031f8:	e0bfff17 	ldw	r2,-4(fp)
811031fc:	10c5883a 	add	r2,r2,r3
81103200:	e0fffe17 	ldw	r3,-8(fp)
81103204:	10c00015 	stw	r3,0(r2)
81103208:	00000f06 	br	81103248 <POWER_Read+0x258>
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
8110320c:	00e04574 	movhi	r3,33045
81103210:	18d56904 	addi	r3,r3,21924
81103214:	00a04574 	movhi	r2,33045
81103218:	10b81104 	addi	r2,r2,-8124
8110321c:	1009883a 	mov	r4,r2
81103220:	00800444 	movi	r2,17
81103224:	100d883a 	mov	r6,r2
81103228:	200b883a 	mov	r5,r4
8110322c:	1809883a 	mov	r4,r3
81103230:	11247000 	call	81124700 <memcpy>
				debug(fp, cDebugBuffer);
81103234:	d0a06217 	ldw	r2,-32376(gp)
81103238:	01604574 	movhi	r5,33045
8110323c:	29556904 	addi	r5,r5,21924
81103240:	1009883a 	mov	r4,r2
81103244:	11236500 	call	81123650 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103248:	e0bff417 	ldw	r2,-48(fp)
8110324c:	10800044 	addi	r2,r2,1
81103250:	e0bff415 	stw	r2,-48(fp)
81103254:	e0bff517 	ldw	r2,-44(fp)
81103258:	1085883a 	add	r2,r2,r2
8110325c:	1085883a 	add	r2,r2,r2
81103260:	e0fff304 	addi	r3,fp,-52
81103264:	1885883a 	add	r2,r3,r2
81103268:	10800904 	addi	r2,r2,36
8110326c:	10800017 	ldw	r2,0(r2)
81103270:	e0fff417 	ldw	r3,-48(fp)
81103274:	1880020e 	bge	r3,r2,81103280 <POWER_Read+0x290>
81103278:	e0bff317 	ldw	r2,-52(fp)
8110327c:	103f811e 	bne	r2,zero,81103084 <__reset+0xfb0e3084>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81103280:	e0bff517 	ldw	r2,-44(fp)
81103284:	10800044 	addi	r2,r2,1
81103288:	e0bff515 	stw	r2,-44(fp)
8110328c:	e0bff517 	ldw	r2,-44(fp)
81103290:	10800088 	cmpgei	r2,r2,2
81103294:	1000021e 	bne	r2,zero,811032a0 <POWER_Read+0x2b0>
81103298:	e0bff317 	ldw	r2,-52(fp)
8110329c:	103f691e 	bne	r2,zero,81103044 <__reset+0xfb0e3044>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
811032a0:	e0bff317 	ldw	r2,-52(fp)
}
811032a4:	e037883a 	mov	sp,fp
811032a8:	dfc00117 	ldw	ra,4(sp)
811032ac:	df000017 	ldw	fp,0(sp)
811032b0:	dec00204 	addi	sp,sp,8
811032b4:	f800283a 	ret

811032b8 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
811032b8:	defff904 	addi	sp,sp,-28
811032bc:	de00012e 	bgeu	sp,et,811032c4 <TEMP_Read+0xc>
811032c0:	003b68fa 	trap	3
811032c4:	dfc00615 	stw	ra,24(sp)
811032c8:	df000515 	stw	fp,20(sp)
811032cc:	df000504 	addi	fp,sp,20
811032d0:	e13ffe15 	stw	r4,-8(fp)
811032d4:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
811032d8:	00800c04 	movi	r2,48
811032dc:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
811032e0:	e0bffd83 	ldbu	r2,-10(fp)
811032e4:	10c03fcc 	andi	r3,r2,255
811032e8:	18c0201c 	xori	r3,r3,128
811032ec:	18ffe004 	addi	r3,r3,-128
811032f0:	e0bffdc4 	addi	r2,fp,-9
811032f4:	d8800015 	stw	r2,0(sp)
811032f8:	000f883a 	mov	r7,zero
811032fc:	180d883a 	mov	r6,r3
81103300:	01600034 	movhi	r5,32768
81103304:	29426004 	addi	r5,r5,2432
81103308:	01200034 	movhi	r4,32768
8110330c:	21026404 	addi	r4,r4,2448
81103310:	110b63c0 	call	8110b63c <I2C_Read>
81103314:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
81103318:	e0bffc17 	ldw	r2,-16(fp)
8110331c:	10000226 	beq	r2,zero,81103328 <TEMP_Read+0x70>
		BoardTemp = Data;
81103320:	e0bffdc3 	ldbu	r2,-9(fp)
81103324:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
81103328:	e0bffc17 	ldw	r2,-16(fp)
8110332c:	10001226 	beq	r2,zero,81103378 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
81103330:	e0bffd83 	ldbu	r2,-10(fp)
81103334:	10c03fcc 	andi	r3,r2,255
81103338:	18c0201c 	xori	r3,r3,128
8110333c:	18ffe004 	addi	r3,r3,-128
81103340:	e0bffdc4 	addi	r2,fp,-9
81103344:	d8800015 	stw	r2,0(sp)
81103348:	01c00044 	movi	r7,1
8110334c:	180d883a 	mov	r6,r3
81103350:	01600034 	movhi	r5,32768
81103354:	29426004 	addi	r5,r5,2432
81103358:	01200034 	movhi	r4,32768
8110335c:	21026404 	addi	r4,r4,2448
81103360:	110b63c0 	call	8110b63c <I2C_Read>
81103364:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103368:	e0bffc17 	ldw	r2,-16(fp)
8110336c:	10000226 	beq	r2,zero,81103378 <TEMP_Read+0xc0>
			FpgaTemp = Data;
81103370:	e0bffdc3 	ldbu	r2,-9(fp)
81103374:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103378:	e0bffc17 	ldw	r2,-16(fp)
8110337c:	10000626 	beq	r2,zero,81103398 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
81103380:	e0bffe17 	ldw	r2,-8(fp)
81103384:	e0fffd03 	ldbu	r3,-12(fp)
81103388:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
8110338c:	e0bfff17 	ldw	r2,-4(fp)
81103390:	e0fffd43 	ldbu	r3,-11(fp)
81103394:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103398:	e0bffc17 	ldw	r2,-16(fp)
}
8110339c:	e037883a 	mov	sp,fp
811033a0:	dfc00117 	ldw	ra,4(sp)
811033a4:	df000017 	ldw	fp,0(sp)
811033a8:	dec00204 	addi	sp,sp,8
811033ac:	f800283a 	ret

811033b0 <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
811033b0:	defffb04 	addi	sp,sp,-20
811033b4:	de00012e 	bgeu	sp,et,811033bc <sense_log_temp+0xc>
811033b8:	003b68fa 	trap	3
811033bc:	dfc00415 	stw	ra,16(sp)
811033c0:	df000315 	stw	fp,12(sp)
811033c4:	df000304 	addi	fp,sp,12
811033c8:	e13ffe15 	stw	r4,-8(fp)
811033cc:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
811033d0:	e17fff17 	ldw	r5,-4(fp)
811033d4:	e13ffe17 	ldw	r4,-8(fp)
811033d8:	11032b80 	call	811032b8 <TEMP_Read>
811033dc:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
811033e0:	e0bffd17 	ldw	r2,-12(fp)
}
811033e4:	e037883a 	mov	sp,fp
811033e8:	dfc00117 	ldw	ra,4(sp)
811033ec:	df000017 	ldw	fp,0(sp)
811033f0:	dec00204 	addi	sp,sp,8
811033f4:	f800283a 	ret

811033f8 <sense_log>:

void sense_log(void) {
811033f8:	deff0404 	addi	sp,sp,-1008
811033fc:	de00012e 	bgeu	sp,et,81103404 <sense_log+0xc>
81103400:	003b68fa 	trap	3
81103404:	dfc0fb15 	stw	ra,1004(sp)
81103408:	df00fa15 	stw	fp,1000(sp)
8110340c:	dd40f915 	stw	r21,996(sp)
81103410:	dd00f815 	stw	r20,992(sp)
81103414:	dcc0f715 	stw	r19,988(sp)
81103418:	dc80f615 	stw	r18,984(sp)
8110341c:	dc40f515 	stw	r17,980(sp)
81103420:	dc00f415 	stw	r16,976(sp)
81103424:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
81103428:	00902834 	movhi	r2,16544
8110342c:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2215 	stw	r2,-888(fp)
8110343c:	008ea0f4 	movhi	r2,14979
81103440:	10849bc4 	addi	r2,r2,4719
81103444:	e0bf2315 	stw	r2,-884(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2415 	stw	r2,-880(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2515 	stw	r2,-876(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2615 	stw	r2,-872(fp)
8110346c:	008ed174 	movhi	r2,15173
81103470:	10a6e984 	addi	r2,r2,-25690
81103474:	e0bf2715 	stw	r2,-868(fp)
81103478:	008ed174 	movhi	r2,15173
8110347c:	10a6e984 	addi	r2,r2,-25690
81103480:	e0bf2815 	stw	r2,-864(fp)
81103484:	008ed174 	movhi	r2,15173
81103488:	10a6e984 	addi	r2,r2,-25690
8110348c:	e0bf2915 	stw	r2,-860(fp)
81103490:	008ed174 	movhi	r2,15173
81103494:	10a6e984 	addi	r2,r2,-25690
81103498:	e0bf2a15 	stw	r2,-856(fp)
8110349c:	008ed174 	movhi	r2,15173
811034a0:	10a6e984 	addi	r2,r2,-25690
811034a4:	e0bf2b15 	stw	r2,-852(fp)
811034a8:	008ed174 	movhi	r2,15173
811034ac:	10a6e984 	addi	r2,r2,-25690
811034b0:	e0bf2c15 	stw	r2,-848(fp)
811034b4:	008ed174 	movhi	r2,15173
811034b8:	10a6e984 	addi	r2,r2,-25690
811034bc:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
811034c0:	008fd9b4 	movhi	r2,16230
811034c4:	10999984 	addi	r2,r2,26214
811034c8:	e0bf2e15 	stw	r2,-840(fp)
811034cc:	008fd9b4 	movhi	r2,16230
811034d0:	10999984 	addi	r2,r2,26214
811034d4:	e0bf2f15 	stw	r2,-836(fp)
811034d8:	00901034 	movhi	r2,16448
811034dc:	e0bf3015 	stw	r2,-832(fp)
811034e0:	008fd9b4 	movhi	r2,16230
811034e4:	10999984 	addi	r2,r2,26214
811034e8:	e0bf3115 	stw	r2,-828(fp)
811034ec:	008ff9b4 	movhi	r2,16358
811034f0:	10999984 	addi	r2,r2,26214
811034f4:	e0bf3215 	stw	r2,-824(fp)
811034f8:	00900834 	movhi	r2,16416
811034fc:	e0bf3315 	stw	r2,-820(fp)
81103500:	008ff9b4 	movhi	r2,16358
81103504:	10999984 	addi	r2,r2,26214
81103508:	e0bf3415 	stw	r2,-816(fp)
8110350c:	00900834 	movhi	r2,16416
81103510:	e0bf3515 	stw	r2,-812(fp)
81103514:	008fe374 	movhi	r2,16269
81103518:	10b33344 	addi	r2,r2,-13107
8110351c:	e0bf3615 	stw	r2,-808(fp)
81103520:	008fecf4 	movhi	r2,16307
81103524:	108cccc4 	addi	r2,r2,13107
81103528:	e0bf3715 	stw	r2,-804(fp)
8110352c:	009014f4 	movhi	r2,16467
81103530:	108cccc4 	addi	r2,r2,13107
81103534:	e0bf3815 	stw	r2,-800(fp)
81103538:	00900834 	movhi	r2,16416
8110353c:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
81103540:	00a04574 	movhi	r2,33045
81103544:	10b84804 	addi	r2,r2,-7904
81103548:	e0ff3a04 	addi	r3,fp,-792
8110354c:	1009883a 	mov	r4,r2
81103550:	0080c004 	movi	r2,768
81103554:	100d883a 	mov	r6,r2
81103558:	200b883a 	mov	r5,r4
8110355c:	1809883a 	mov	r4,r3
81103560:	11247000 	call	81124700 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103564:	e0bf1604 	addi	r2,fp,-936
81103568:	1009883a 	mov	r4,r2
8110356c:	1102ff00 	call	81102ff0 <POWER_Read>
81103570:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103574:	e0bf0f17 	ldw	r2,-964(fp)
81103578:	10016026 	beq	r2,zero,81103afc <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
8110357c:	e03f0c15 	stw	zero,-976(fp)
81103580:	00014c06 	br	81103ab4 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103584:	e0bf0c17 	ldw	r2,-976(fp)
81103588:	1085883a 	add	r2,r2,r2
8110358c:	1085883a 	add	r2,r2,r2
81103590:	e0ff0c04 	addi	r3,fp,-976
81103594:	1885883a 	add	r2,r3,r2
81103598:	10800a04 	addi	r2,r2,40
8110359c:	10800017 	ldw	r2,0(r2)
811035a0:	1004d77a 	srli	r2,r2,29
811035a4:	1080004c 	andi	r2,r2,1
811035a8:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
811035ac:	e0bf0c17 	ldw	r2,-976(fp)
811035b0:	1085883a 	add	r2,r2,r2
811035b4:	1085883a 	add	r2,r2,r2
811035b8:	e0ff0c04 	addi	r3,fp,-976
811035bc:	1885883a 	add	r2,r3,r2
811035c0:	10800a04 	addi	r2,r2,40
811035c4:	10800017 	ldw	r2,0(r2)
811035c8:	1004d73a 	srli	r2,r2,28
811035cc:	1080004c 	andi	r2,r2,1
811035d0:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
811035d4:	e0bf0c17 	ldw	r2,-976(fp)
811035d8:	1085883a 	add	r2,r2,r2
811035dc:	1085883a 	add	r2,r2,r2
811035e0:	e0ff0c04 	addi	r3,fp,-976
811035e4:	1885883a 	add	r2,r3,r2
811035e8:	10800a04 	addi	r2,r2,40
811035ec:	10800017 	ldw	r2,0(r2)
811035f0:	1006d1ba 	srli	r3,r2,6
811035f4:	00801034 	movhi	r2,64
811035f8:	10bfffc4 	addi	r2,r2,-1
811035fc:	1884703a 	and	r2,r3,r2
81103600:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
81103604:	e0bf1117 	ldw	r2,-956(fp)
81103608:	1000091e 	bne	r2,zero,81103630 <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
8110360c:	e13f1217 	ldw	r4,-952(fp)
81103610:	1121e5c0 	call	81121e5c <__floatunsisf>
81103614:	1007883a 	mov	r3,r2
81103618:	0152a034 	movhi	r5,19072
8110361c:	1809883a 	mov	r4,r3
81103620:	11214e40 	call	811214e4 <__divsf3>
81103624:	1007883a 	mov	r3,r2
81103628:	e0ff0d15 	stw	r3,-972(fp)
8110362c:	00000106 	br	81103634 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
81103630:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
81103634:	e0bf1017 	ldw	r2,-960(fp)
81103638:	10002626 	beq	r2,zero,811036d4 <sense_log+0x2dc>
8110363c:	e0bf1117 	ldw	r2,-956(fp)
81103640:	10002426 	beq	r2,zero,811036d4 <sense_log+0x2dc>
				fVol = fRef * 0.5;
81103644:	014fc034 	movhi	r5,16128
81103648:	e13f0e17 	ldw	r4,-968(fp)
8110364c:	112192c0 	call	8112192c <__mulsf3>
81103650:	1007883a 	mov	r3,r2
81103654:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103658:	e0ff3a04 	addi	r3,fp,-792
8110365c:	e0bf0c17 	ldw	r2,-976(fp)
81103660:	100491ba 	slli	r2,r2,6
81103664:	18a1883a 	add	r16,r3,r2
81103668:	e0bf0c17 	ldw	r2,-976(fp)
8110366c:	1085883a 	add	r2,r2,r2
81103670:	1085883a 	add	r2,r2,r2
81103674:	e0ff0c04 	addi	r3,fp,-976
81103678:	1885883a 	add	r2,r3,r2
8110367c:	10800a04 	addi	r2,r2,40
81103680:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103684:	1023883a 	mov	r17,r2
81103688:	e13f1317 	ldw	r4,-948(fp)
8110368c:	11231b80 	call	811231b8 <__extendsfdf2>
81103690:	1009883a 	mov	r4,r2
81103694:	180b883a 	mov	r5,r3
81103698:	d9000015 	stw	r4,0(sp)
8110369c:	d9400115 	stw	r5,4(sp)
811036a0:	880f883a 	mov	r7,r17
811036a4:	800d883a 	mov	r6,r16
811036a8:	01604574 	movhi	r5,33045
811036ac:	29781604 	addi	r5,r5,-8104
811036b0:	01204574 	movhi	r4,33045
811036b4:	21156904 	addi	r4,r4,21924
811036b8:	1124f640 	call	81124f64 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
811036bc:	d0a06217 	ldw	r2,-32376(gp)
811036c0:	01604574 	movhi	r5,33045
811036c4:	29556904 	addi	r5,r5,21924
811036c8:	1009883a 	mov	r4,r2
811036cc:	11236500 	call	81123650 <fprintf>
811036d0:	0000f506 	br	81103aa8 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
811036d4:	e0bf1017 	ldw	r2,-960(fp)
811036d8:	10006426 	beq	r2,zero,8110386c <sense_log+0x474>
811036dc:	e0bf1117 	ldw	r2,-956(fp)
811036e0:	1000621e 	bne	r2,zero,8110386c <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
811036e4:	e13f0e17 	ldw	r4,-968(fp)
811036e8:	11231b80 	call	811231b8 <__extendsfdf2>
811036ec:	1011883a 	mov	r8,r2
811036f0:	1813883a 	mov	r9,r3
811036f4:	000d883a 	mov	r6,zero
811036f8:	01cff834 	movhi	r7,16352
811036fc:	4009883a 	mov	r4,r8
81103700:	480b883a 	mov	r5,r9
81103704:	11220300 	call	81122030 <__muldf3>
81103708:	1009883a 	mov	r4,r2
8110370c:	180b883a 	mov	r5,r3
81103710:	2021883a 	mov	r16,r4
81103714:	2823883a 	mov	r17,r5
81103718:	e13f0d17 	ldw	r4,-972(fp)
8110371c:	11231b80 	call	811231b8 <__extendsfdf2>
81103720:	1009883a 	mov	r4,r2
81103724:	180b883a 	mov	r5,r3
81103728:	200d883a 	mov	r6,r4
8110372c:	280f883a 	mov	r7,r5
81103730:	8009883a 	mov	r4,r16
81103734:	880b883a 	mov	r5,r17
81103738:	11220300 	call	81122030 <__muldf3>
8110373c:	1009883a 	mov	r4,r2
81103740:	180b883a 	mov	r5,r3
81103744:	2005883a 	mov	r2,r4
81103748:	2807883a 	mov	r3,r5
8110374c:	1009883a 	mov	r4,r2
81103750:	180b883a 	mov	r5,r3
81103754:	11232d00 	call	811232d0 <__truncdfsf2>
81103758:	1007883a 	mov	r3,r2
8110375c:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
81103760:	e0bf0c17 	ldw	r2,-976(fp)
81103764:	1085883a 	add	r2,r2,r2
81103768:	1085883a 	add	r2,r2,r2
8110376c:	e0ff0c04 	addi	r3,fp,-976
81103770:	1885883a 	add	r2,r3,r2
81103774:	10801604 	addi	r2,r2,88
81103778:	10c00017 	ldw	r3,0(r2)
8110377c:	180b883a 	mov	r5,r3
81103780:	e13f0d17 	ldw	r4,-972(fp)
81103784:	11214e40 	call	811214e4 <__divsf3>
81103788:	1007883a 	mov	r3,r2
8110378c:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
81103790:	e0bf0c17 	ldw	r2,-976(fp)
81103794:	1085883a 	add	r2,r2,r2
81103798:	1085883a 	add	r2,r2,r2
8110379c:	e0ff0c04 	addi	r3,fp,-976
811037a0:	1885883a 	add	r2,r3,r2
811037a4:	10802204 	addi	r2,r2,136
811037a8:	10c00017 	ldw	r3,0(r2)
811037ac:	e17f1417 	ldw	r5,-944(fp)
811037b0:	1809883a 	mov	r4,r3
811037b4:	112192c0 	call	8112192c <__mulsf3>
811037b8:	1007883a 	mov	r3,r2
811037bc:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
811037c0:	e0ff3a04 	addi	r3,fp,-792
811037c4:	e0bf0c17 	ldw	r2,-976(fp)
811037c8:	100491ba 	slli	r2,r2,6
811037cc:	18a9883a 	add	r20,r3,r2
811037d0:	e0bf0c17 	ldw	r2,-976(fp)
811037d4:	1085883a 	add	r2,r2,r2
811037d8:	1085883a 	add	r2,r2,r2
811037dc:	e0ff0c04 	addi	r3,fp,-976
811037e0:	1885883a 	add	r2,r3,r2
811037e4:	10800a04 	addi	r2,r2,40
811037e8:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
811037ec:	102b883a 	mov	r21,r2
811037f0:	e13f0d17 	ldw	r4,-972(fp)
811037f4:	11231b80 	call	811231b8 <__extendsfdf2>
811037f8:	1021883a 	mov	r16,r2
811037fc:	1823883a 	mov	r17,r3
81103800:	e13f1417 	ldw	r4,-944(fp)
81103804:	11231b80 	call	811231b8 <__extendsfdf2>
81103808:	1025883a 	mov	r18,r2
8110380c:	1827883a 	mov	r19,r3
81103810:	e13f1517 	ldw	r4,-940(fp)
81103814:	11231b80 	call	811231b8 <__extendsfdf2>
81103818:	1009883a 	mov	r4,r2
8110381c:	180b883a 	mov	r5,r3
81103820:	d9000415 	stw	r4,16(sp)
81103824:	d9400515 	stw	r5,20(sp)
81103828:	dc800215 	stw	r18,8(sp)
8110382c:	dcc00315 	stw	r19,12(sp)
81103830:	dc000015 	stw	r16,0(sp)
81103834:	dc400115 	stw	r17,4(sp)
81103838:	a80f883a 	mov	r7,r21
8110383c:	a00d883a 	mov	r6,r20
81103840:	01604574 	movhi	r5,33045
81103844:	29781f04 	addi	r5,r5,-8068
81103848:	01204574 	movhi	r4,33045
8110384c:	21156904 	addi	r4,r4,21924
81103850:	1124f640 	call	81124f64 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103854:	d0a06217 	ldw	r2,-32376(gp)
81103858:	01604574 	movhi	r5,33045
8110385c:	29556904 	addi	r5,r5,21924
81103860:	1009883a 	mov	r4,r2
81103864:	11236500 	call	81123650 <fprintf>
81103868:	00008f06 	br	81103aa8 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
8110386c:	e0bf1017 	ldw	r2,-960(fp)
81103870:	1000641e 	bne	r2,zero,81103a04 <sense_log+0x60c>
81103874:	e0bf1117 	ldw	r2,-956(fp)
81103878:	10006226 	beq	r2,zero,81103a04 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
8110387c:	e13f0e17 	ldw	r4,-968(fp)
81103880:	11231b80 	call	811231b8 <__extendsfdf2>
81103884:	1011883a 	mov	r8,r2
81103888:	1813883a 	mov	r9,r3
8110388c:	000d883a 	mov	r6,zero
81103890:	01cff834 	movhi	r7,16352
81103894:	4009883a 	mov	r4,r8
81103898:	480b883a 	mov	r5,r9
8110389c:	11220300 	call	81122030 <__muldf3>
811038a0:	1009883a 	mov	r4,r2
811038a4:	180b883a 	mov	r5,r3
811038a8:	2021883a 	mov	r16,r4
811038ac:	2823883a 	mov	r17,r5
811038b0:	e13f0d17 	ldw	r4,-972(fp)
811038b4:	11231b80 	call	811231b8 <__extendsfdf2>
811038b8:	1009883a 	mov	r4,r2
811038bc:	180b883a 	mov	r5,r3
811038c0:	200d883a 	mov	r6,r4
811038c4:	280f883a 	mov	r7,r5
811038c8:	8009883a 	mov	r4,r16
811038cc:	880b883a 	mov	r5,r17
811038d0:	11220300 	call	81122030 <__muldf3>
811038d4:	1009883a 	mov	r4,r2
811038d8:	180b883a 	mov	r5,r3
811038dc:	2005883a 	mov	r2,r4
811038e0:	2807883a 	mov	r3,r5
811038e4:	1009883a 	mov	r4,r2
811038e8:	180b883a 	mov	r5,r3
811038ec:	11232d00 	call	811232d0 <__truncdfsf2>
811038f0:	1007883a 	mov	r3,r2
811038f4:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038f8:	e0bf0c17 	ldw	r2,-976(fp)
811038fc:	1085883a 	add	r2,r2,r2
81103900:	1085883a 	add	r2,r2,r2
81103904:	e0ff0c04 	addi	r3,fp,-976
81103908:	1885883a 	add	r2,r3,r2
8110390c:	10801604 	addi	r2,r2,88
81103910:	10c00017 	ldw	r3,0(r2)
81103914:	180b883a 	mov	r5,r3
81103918:	e13f0d17 	ldw	r4,-972(fp)
8110391c:	11214e40 	call	811214e4 <__divsf3>
81103920:	1007883a 	mov	r3,r2
81103924:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
81103928:	e0bf0c17 	ldw	r2,-976(fp)
8110392c:	1085883a 	add	r2,r2,r2
81103930:	1085883a 	add	r2,r2,r2
81103934:	e0ff0c04 	addi	r3,fp,-976
81103938:	1885883a 	add	r2,r3,r2
8110393c:	10802204 	addi	r2,r2,136
81103940:	10c00017 	ldw	r3,0(r2)
81103944:	e17f1417 	ldw	r5,-944(fp)
81103948:	1809883a 	mov	r4,r3
8110394c:	112192c0 	call	8112192c <__mulsf3>
81103950:	1007883a 	mov	r3,r2
81103954:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103958:	e0ff3a04 	addi	r3,fp,-792
8110395c:	e0bf0c17 	ldw	r2,-976(fp)
81103960:	100491ba 	slli	r2,r2,6
81103964:	18a9883a 	add	r20,r3,r2
81103968:	e0bf0c17 	ldw	r2,-976(fp)
8110396c:	1085883a 	add	r2,r2,r2
81103970:	1085883a 	add	r2,r2,r2
81103974:	e0ff0c04 	addi	r3,fp,-976
81103978:	1885883a 	add	r2,r3,r2
8110397c:	10800a04 	addi	r2,r2,40
81103980:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
81103984:	102b883a 	mov	r21,r2
81103988:	e13f0d17 	ldw	r4,-972(fp)
8110398c:	11231b80 	call	811231b8 <__extendsfdf2>
81103990:	1021883a 	mov	r16,r2
81103994:	1823883a 	mov	r17,r3
81103998:	e13f1417 	ldw	r4,-944(fp)
8110399c:	11231b80 	call	811231b8 <__extendsfdf2>
811039a0:	1025883a 	mov	r18,r2
811039a4:	1827883a 	mov	r19,r3
811039a8:	e13f1517 	ldw	r4,-940(fp)
811039ac:	11231b80 	call	811231b8 <__extendsfdf2>
811039b0:	1009883a 	mov	r4,r2
811039b4:	180b883a 	mov	r5,r3
811039b8:	d9000415 	stw	r4,16(sp)
811039bc:	d9400515 	stw	r5,20(sp)
811039c0:	dc800215 	stw	r18,8(sp)
811039c4:	dcc00315 	stw	r19,12(sp)
811039c8:	dc000015 	stw	r16,0(sp)
811039cc:	dc400115 	stw	r17,4(sp)
811039d0:	a80f883a 	mov	r7,r21
811039d4:	a00d883a 	mov	r6,r20
811039d8:	01604574 	movhi	r5,33045
811039dc:	29782f04 	addi	r5,r5,-8004
811039e0:	01204574 	movhi	r4,33045
811039e4:	21156904 	addi	r4,r4,21924
811039e8:	1124f640 	call	81124f64 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
811039ec:	d0a06217 	ldw	r2,-32376(gp)
811039f0:	01604574 	movhi	r5,33045
811039f4:	29556904 	addi	r5,r5,21924
811039f8:	1009883a 	mov	r4,r2
811039fc:	11236500 	call	81123650 <fprintf>
81103a00:	00002906 	br	81103aa8 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
81103a04:	e0bf1017 	ldw	r2,-960(fp)
81103a08:	1000271e 	bne	r2,zero,81103aa8 <sense_log+0x6b0>
81103a0c:	e0bf1117 	ldw	r2,-956(fp)
81103a10:	1000251e 	bne	r2,zero,81103aa8 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
81103a14:	e0bf0e17 	ldw	r2,-968(fp)
81103a18:	10a0003c 	xorhi	r2,r2,32768
81103a1c:	014fc034 	movhi	r5,16128
81103a20:	1009883a 	mov	r4,r2
81103a24:	112192c0 	call	8112192c <__mulsf3>
81103a28:	1007883a 	mov	r3,r2
81103a2c:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103a30:	e0ff3a04 	addi	r3,fp,-792
81103a34:	e0bf0c17 	ldw	r2,-976(fp)
81103a38:	100491ba 	slli	r2,r2,6
81103a3c:	18a1883a 	add	r16,r3,r2
81103a40:	e0bf0c17 	ldw	r2,-976(fp)
81103a44:	1085883a 	add	r2,r2,r2
81103a48:	1085883a 	add	r2,r2,r2
81103a4c:	e0ff0c04 	addi	r3,fp,-976
81103a50:	1885883a 	add	r2,r3,r2
81103a54:	10800a04 	addi	r2,r2,40
81103a58:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a5c:	1023883a 	mov	r17,r2
81103a60:	e13f1317 	ldw	r4,-948(fp)
81103a64:	11231b80 	call	811231b8 <__extendsfdf2>
81103a68:	1009883a 	mov	r4,r2
81103a6c:	180b883a 	mov	r5,r3
81103a70:	d9000015 	stw	r4,0(sp)
81103a74:	d9400115 	stw	r5,4(sp)
81103a78:	880f883a 	mov	r7,r17
81103a7c:	800d883a 	mov	r6,r16
81103a80:	01604574 	movhi	r5,33045
81103a84:	29783f04 	addi	r5,r5,-7940
81103a88:	01204574 	movhi	r4,33045
81103a8c:	21156904 	addi	r4,r4,21924
81103a90:	1124f640 	call	81124f64 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a94:	d0a06217 	ldw	r2,-32376(gp)
81103a98:	01604574 	movhi	r5,33045
81103a9c:	29556904 	addi	r5,r5,21924
81103aa0:	1009883a 	mov	r4,r2
81103aa4:	11236500 	call	81123650 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103aa8:	e0bf0c17 	ldw	r2,-976(fp)
81103aac:	10800044 	addi	r2,r2,1
81103ab0:	e0bf0c15 	stw	r2,-976(fp)
81103ab4:	e0bf0c17 	ldw	r2,-976(fp)
81103ab8:	10800308 	cmpgei	r2,r2,12
81103abc:	1000021e 	bne	r2,zero,81103ac8 <sense_log+0x6d0>
81103ac0:	e0bf0f17 	ldw	r2,-964(fp)
81103ac4:	103eaf1e 	bne	r2,zero,81103584 <__reset+0xfb0e3584>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#if DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103ac8:	00a04574 	movhi	r2,33045
81103acc:	10956904 	addi	r2,r2,21924
81103ad0:	00c00344 	movi	r3,13
81103ad4:	10c00005 	stb	r3,0(r2)
81103ad8:	00c00284 	movi	r3,10
81103adc:	10c00045 	stb	r3,1(r2)
81103ae0:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103ae4:	d0a06217 	ldw	r2,-32376(gp)
81103ae8:	01604574 	movhi	r5,33045
81103aec:	29556904 	addi	r5,r5,21924
81103af0:	1009883a 	mov	r4,r2
81103af4:	11236500 	call	81123650 <fprintf>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103af8:	00001606 	br	81103b54 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103afc:	00a04574 	movhi	r2,33045
81103b00:	10956904 	addi	r2,r2,21924
81103b04:	00c01144 	movi	r3,69
81103b08:	10c00005 	stb	r3,0(r2)
81103b0c:	00c01c84 	movi	r3,114
81103b10:	10c00045 	stb	r3,1(r2)
81103b14:	00c01c84 	movi	r3,114
81103b18:	10c00085 	stb	r3,2(r2)
81103b1c:	00c01bc4 	movi	r3,111
81103b20:	10c000c5 	stb	r3,3(r2)
81103b24:	00c01c84 	movi	r3,114
81103b28:	10c00105 	stb	r3,4(r2)
81103b2c:	00c00344 	movi	r3,13
81103b30:	10c00145 	stb	r3,5(r2)
81103b34:	00c00284 	movi	r3,10
81103b38:	10c00185 	stb	r3,6(r2)
81103b3c:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103b40:	d0a06217 	ldw	r2,-32376(gp)
81103b44:	01604574 	movhi	r5,33045
81103b48:	29556904 	addi	r5,r5,21924
81103b4c:	1009883a 	mov	r4,r2
81103b50:	11236500 	call	81123650 <fprintf>
#endif
	}
}
81103b54:	0001883a 	nop
81103b58:	e6fffa04 	addi	sp,fp,-24
81103b5c:	dfc00717 	ldw	ra,28(sp)
81103b60:	df000617 	ldw	fp,24(sp)
81103b64:	dd400517 	ldw	r21,20(sp)
81103b68:	dd000417 	ldw	r20,16(sp)
81103b6c:	dcc00317 	ldw	r19,12(sp)
81103b70:	dc800217 	ldw	r18,8(sp)
81103b74:	dc400117 	ldw	r17,4(sp)
81103b78:	dc000017 	ldw	r16,0(sp)
81103b7c:	dec00804 	addi	sp,sp,32
81103b80:	f800283a 	ret

81103b84 <bSdmaInitM1Dma>:
alt_msgdma_dev *pxDmaM1Dev = NULL;
alt_msgdma_dev *pxDmaM2Dev = NULL;
//! [data memory public global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b84:	defffb04 	addi	sp,sp,-20
81103b88:	de00012e 	bgeu	sp,et,81103b90 <bSdmaInitM1Dma+0xc>
81103b8c:	003b68fa 	trap	3
81103b90:	dfc00415 	stw	ra,16(sp)
81103b94:	df000315 	stw	fp,12(sp)
81103b98:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103b9c:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103ba0:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103ba4:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103ba8:	01204574 	movhi	r4,33045
81103bac:	21390804 	addi	r4,r4,-7136
81103bb0:	114bda00 	call	8114bda0 <alt_msgdma_open>
81103bb4:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
81103bb8:	d0a03917 	ldw	r2,-32540(gp)
81103bbc:	10001a26 	beq	r2,zero,81103c28 <bSdmaInitM1Dma+0xa4>
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103bc0:	d0a03917 	ldw	r2,-32540(gp)
81103bc4:	10800317 	ldw	r2,12(r2)
81103bc8:	10800104 	addi	r2,r2,4
81103bcc:	00c00084 	movi	r3,2
81103bd0:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bd4:	00000b06 	br	81103c04 <bSdmaInitM1Dma+0x80>
			usleep(1);
81103bd8:	01000044 	movi	r4,1
81103bdc:	1139d080 	call	81139d08 <usleep>
			usiCounter++;
81103be0:	e0bfff0b 	ldhu	r2,-4(fp)
81103be4:	10800044 	addi	r2,r2,1
81103be8:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103bec:	e0bfff0b 	ldhu	r2,-4(fp)
81103bf0:	1084e230 	cmpltui	r2,r2,5000
81103bf4:	1000031e 	bne	r2,zero,81103c04 <bSdmaInitM1Dma+0x80>
				bFailDispatcher = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
				break;
81103c00:	00000506 	br	81103c18 <bSdmaInitM1Dma+0x94>
	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c04:	d0a03917 	ldw	r2,-32540(gp)
81103c08:	10800317 	ldw	r2,12(r2)
81103c0c:	10800037 	ldwio	r2,0(r2)
81103c10:	1080100c 	andi	r2,r2,64
81103c14:	103ff01e 	bne	r2,zero,81103bd8 <__reset+0xfb0e3bd8>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103c18:	e0bffe17 	ldw	r2,-8(fp)
81103c1c:	1000021e 	bne	r2,zero,81103c28 <bSdmaInitM1Dma+0xa4>
			bStatus = TRUE;
81103c20:	00800044 	movi	r2,1
81103c24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81103c28:	e0bffd17 	ldw	r2,-12(fp)
}
81103c2c:	e037883a 	mov	sp,fp
81103c30:	dfc00117 	ldw	ra,4(sp)
81103c34:	df000017 	ldw	fp,0(sp)
81103c38:	dec00204 	addi	sp,sp,8
81103c3c:	f800283a 	ret

81103c40 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103c40:	defffb04 	addi	sp,sp,-20
81103c44:	de00012e 	bgeu	sp,et,81103c4c <bSdmaInitM2Dma+0xc>
81103c48:	003b68fa 	trap	3
81103c4c:	dfc00415 	stw	ra,16(sp)
81103c50:	df000315 	stw	fp,12(sp)
81103c54:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103c58:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103c60:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c64:	01204574 	movhi	r4,33045
81103c68:	21390d04 	addi	r4,r4,-7116
81103c6c:	114bda00 	call	8114bda0 <alt_msgdma_open>
81103c70:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c74:	d0a03a17 	ldw	r2,-32536(gp)
81103c78:	1000021e 	bne	r2,zero,81103c84 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c7c:	e03ffd15 	stw	zero,-12(fp)
81103c80:	00001a06 	br	81103cec <bSdmaInitM2Dma+0xac>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103c84:	d0a03a17 	ldw	r2,-32536(gp)
81103c88:	10800317 	ldw	r2,12(r2)
81103c8c:	10800104 	addi	r2,r2,4
81103c90:	00c00084 	movi	r3,2
81103c94:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c98:	00000b06 	br	81103cc8 <bSdmaInitM2Dma+0x88>
			usleep(1);
81103c9c:	01000044 	movi	r4,1
81103ca0:	1139d080 	call	81139d08 <usleep>
			usiCounter++;
81103ca4:	e0bfff0b 	ldhu	r2,-4(fp)
81103ca8:	10800044 	addi	r2,r2,1
81103cac:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103cb0:	e0bfff0b 	ldhu	r2,-4(fp)
81103cb4:	1084e230 	cmpltui	r2,r2,5000
81103cb8:	1000031e 	bne	r2,zero,81103cc8 <bSdmaInitM2Dma+0x88>
				bFailDispatcher = TRUE;
81103cbc:	00800044 	movi	r2,1
81103cc0:	e0bffe15 	stw	r2,-8(fp)
				break;
81103cc4:	00000506 	br	81103cdc <bSdmaInitM2Dma+0x9c>
		bStatus = FALSE;
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103cc8:	d0a03a17 	ldw	r2,-32536(gp)
81103ccc:	10800317 	ldw	r2,12(r2)
81103cd0:	10800037 	ldwio	r2,0(r2)
81103cd4:	1080100c 	andi	r2,r2,64
81103cd8:	103ff01e 	bne	r2,zero,81103c9c <__reset+0xfb0e3c9c>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103cdc:	e0bffe17 	ldw	r2,-8(fp)
81103ce0:	1000021e 	bne	r2,zero,81103cec <bSdmaInitM2Dma+0xac>
			bStatus = TRUE;
81103ce4:	00800044 	movi	r2,1
81103ce8:	e0bffd15 	stw	r2,-12(fp)
	}
	return bStatus;
81103cec:	e0bffd17 	ldw	r2,-12(fp)
}
81103cf0:	e037883a 	mov	sp,fp
81103cf4:	dfc00117 	ldw	ra,4(sp)
81103cf8:	df000017 	ldw	fp,0(sp)
81103cfc:	dec00204 	addi	sp,sp,8
81103d00:	f800283a 	ret

81103d04 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81103d04:	deffe804 	addi	sp,sp,-96
81103d08:	de00012e 	bgeu	sp,et,81103d10 <bSdmaDmaM1Transfer+0xc>
81103d0c:	003b68fa 	trap	3
81103d10:	dfc01715 	stw	ra,92(sp)
81103d14:	df001615 	stw	fp,88(sp)
81103d18:	dc001515 	stw	r16,84(sp)
81103d1c:	df001604 	addi	fp,sp,88
81103d20:	e13ffb15 	stw	r4,-20(fp)
81103d24:	2809883a 	mov	r4,r5
81103d28:	3007883a 	mov	r3,r6
81103d2c:	3805883a 	mov	r2,r7
81103d30:	e13ffc0d 	sth	r4,-16(fp)
81103d34:	e0fffd05 	stb	r3,-12(fp)
81103d38:	e0bffe05 	stb	r2,-8(fp)
81103d3c:	defff004 	addi	sp,sp,-64
81103d40:	d8800904 	addi	r2,sp,36
81103d44:	108007c4 	addi	r2,r2,31
81103d48:	1004d17a 	srli	r2,r2,5
81103d4c:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103d50:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103d54:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103d58:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103d5c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103d60:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;

	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81103d64:	00800044 	movi	r2,1
81103d68:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
81103d6c:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
81103d70:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
81103d74:	e0bffe03 	ldbu	r2,-8(fp)
81103d78:	10c00228 	cmpgeui	r3,r2,8
81103d7c:	1800b81e 	bne	r3,zero,81104060 <bSdmaDmaM1Transfer+0x35c>
81103d80:	100690ba 	slli	r3,r2,2
81103d84:	00a04434 	movhi	r2,33040
81103d88:	108f6604 	addi	r2,r2,15768
81103d8c:	1885883a 	add	r2,r3,r2
81103d90:	10800017 	ldw	r2,0(r2)
81103d94:	1000683a 	jmp	r2
81103d98:	81103db8 	rdprs	r4,r16,16630
81103d9c:	81103e0c 	andi	r4,r16,16632
81103da0:	81103e68 	cmpgeui	r4,r16,16633
81103da4:	81103ebc 	xorhi	r4,r16,16634
81103da8:	81103f10 	cmplti	r4,r16,16636
81103dac:	81103f64 	muli	r4,r16,16637
81103db0:	81103fb8 	rdprs	r4,r16,16638
81103db4:	8110400c 	andi	r4,r16,16640
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103db8:	e0bffd03 	ldbu	r2,-12(fp)
81103dbc:	10000826 	beq	r2,zero,81103de0 <bSdmaDmaM1Transfer+0xdc>
81103dc0:	10800060 	cmpeqi	r2,r2,1
81103dc4:	10000d26 	beq	r2,zero,81103dfc <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103dc8:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103dcc:	00800044 	movi	r2,1
81103dd0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103dd4:	1106b640 	call	81106b64 <bFeebGetCh1RightBufferEmpty>
81103dd8:	e0bff615 	stw	r2,-40(fp)
			break;
81103ddc:	00000a06 	br	81103e08 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103de0:	00800074 	movhi	r2,1
81103de4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103de8:	00800044 	movi	r2,1
81103dec:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103df0:	1106afc0 	call	81106afc <bFeebGetCh1LeftBufferEmpty>
81103df4:	e0bff615 	stw	r2,-40(fp)
			break;
81103df8:	00000306 	br	81103e08 <bSdmaDmaM1Transfer+0x104>
		default:
			bChannelFlag = FALSE;
81103dfc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e00:	e03ff615 	stw	zero,-40(fp)
			break;
81103e04:	0001883a 	nop
		}
		break;
81103e08:	00009706 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103e0c:	e0bffd03 	ldbu	r2,-12(fp)
81103e10:	10000926 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x134>
81103e14:	10800060 	cmpeqi	r2,r2,1
81103e18:	10000f26 	beq	r2,zero,81103e58 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103e1c:	00880004 	movi	r2,8192
81103e20:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103e24:	00800044 	movi	r2,1
81103e28:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103e2c:	1106c340 	call	81106c34 <bFeebGetCh2RightBufferEmpty>
81103e30:	e0bff615 	stw	r2,-40(fp)
			break;
81103e34:	00000b06 	br	81103e64 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103e38:	00800074 	movhi	r2,1
81103e3c:	10880004 	addi	r2,r2,8192
81103e40:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103e44:	00800044 	movi	r2,1
81103e48:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103e4c:	1106bcc0 	call	81106bcc <bFeebGetCh2LeftBufferEmpty>
81103e50:	e0bff615 	stw	r2,-40(fp)
			break;
81103e54:	00000306 	br	81103e64 <bSdmaDmaM1Transfer+0x160>
		default:
			bChannelFlag = FALSE;
81103e58:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e5c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e60:	0001883a 	nop
		}
		break;
81103e64:	00008006 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103e68:	e0bffd03 	ldbu	r2,-12(fp)
81103e6c:	10000826 	beq	r2,zero,81103e90 <bSdmaDmaM1Transfer+0x18c>
81103e70:	10800060 	cmpeqi	r2,r2,1
81103e74:	10000d26 	beq	r2,zero,81103eac <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e78:	00900004 	movi	r2,16384
81103e7c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e80:	00800044 	movi	r2,1
81103e84:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e88:	e03ff615 	stw	zero,-40(fp)
			break;
81103e8c:	00000a06 	br	81103eb8 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e90:	00800074 	movhi	r2,1
81103e94:	10900004 	addi	r2,r2,16384
81103e98:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e9c:	00800044 	movi	r2,1
81103ea0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ea4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ea8:	00000306 	br	81103eb8 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
81103eac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103eb0:	e03ff615 	stw	zero,-40(fp)
			break;
81103eb4:	0001883a 	nop
		}
		break;
81103eb8:	00006b06 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103ebc:	e0bffd03 	ldbu	r2,-12(fp)
81103ec0:	10000826 	beq	r2,zero,81103ee4 <bSdmaDmaM1Transfer+0x1e0>
81103ec4:	10800060 	cmpeqi	r2,r2,1
81103ec8:	10000d26 	beq	r2,zero,81103f00 <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103ecc:	00980004 	movi	r2,24576
81103ed0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103ed4:	00800044 	movi	r2,1
81103ed8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103edc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee0:	00000a06 	br	81103f0c <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103ee4:	00800074 	movhi	r2,1
81103ee8:	10980004 	addi	r2,r2,24576
81103eec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103ef0:	00800044 	movi	r2,1
81103ef4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ef8:	e03ff615 	stw	zero,-40(fp)
			break;
81103efc:	00000306 	br	81103f0c <bSdmaDmaM1Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81103f00:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f04:	e03ff615 	stw	zero,-40(fp)
			break;
81103f08:	0001883a 	nop
		}
		break;
81103f0c:	00005606 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103f10:	e0bffd03 	ldbu	r2,-12(fp)
81103f14:	10000826 	beq	r2,zero,81103f38 <bSdmaDmaM1Transfer+0x234>
81103f18:	10800060 	cmpeqi	r2,r2,1
81103f1c:	10000d26 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103f20:	00a00014 	movui	r2,32768
81103f24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103f28:	00800044 	movi	r2,1
81103f2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f30:	e03ff615 	stw	zero,-40(fp)
			break;
81103f34:	00000a06 	br	81103f60 <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103f38:	008000b4 	movhi	r2,2
81103f3c:	10a00004 	addi	r2,r2,-32768
81103f40:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103f44:	00800044 	movi	r2,1
81103f48:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f4c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f50:	00000306 	br	81103f60 <bSdmaDmaM1Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
81103f54:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f58:	e03ff615 	stw	zero,-40(fp)
			break;
81103f5c:	0001883a 	nop
		}
		break;
81103f60:	00004106 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103f64:	e0bffd03 	ldbu	r2,-12(fp)
81103f68:	10000826 	beq	r2,zero,81103f8c <bSdmaDmaM1Transfer+0x288>
81103f6c:	10800060 	cmpeqi	r2,r2,1
81103f70:	10000d26 	beq	r2,zero,81103fa8 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f74:	00a80014 	movui	r2,40960
81103f78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f7c:	00800044 	movi	r2,1
81103f80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f84:	e03ff615 	stw	zero,-40(fp)
			break;
81103f88:	00000a06 	br	81103fb4 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f8c:	008000b4 	movhi	r2,2
81103f90:	10a80004 	addi	r2,r2,-24576
81103f94:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f98:	00800044 	movi	r2,1
81103f9c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fa0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fa4:	00000306 	br	81103fb4 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
81103fa8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103fac:	e03ff615 	stw	zero,-40(fp)
			break;
81103fb0:	0001883a 	nop
		}
		break;
81103fb4:	00002c06 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103fb8:	e0bffd03 	ldbu	r2,-12(fp)
81103fbc:	10000826 	beq	r2,zero,81103fe0 <bSdmaDmaM1Transfer+0x2dc>
81103fc0:	10800060 	cmpeqi	r2,r2,1
81103fc4:	10000d26 	beq	r2,zero,81103ffc <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103fc8:	00b00014 	movui	r2,49152
81103fcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103fd0:	00800044 	movi	r2,1
81103fd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fdc:	00000a06 	br	81104008 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103fe0:	008000b4 	movhi	r2,2
81103fe4:	10b00004 	addi	r2,r2,-16384
81103fe8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103fec:	00800044 	movi	r2,1
81103ff0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ff4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ff8:	00000306 	br	81104008 <bSdmaDmaM1Transfer+0x304>
		default:
			bChannelFlag = FALSE;
81103ffc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104000:	e03ff615 	stw	zero,-40(fp)
			break;
81104004:	0001883a 	nop
		}
		break;
81104008:	00001706 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110400c:	e0bffd03 	ldbu	r2,-12(fp)
81104010:	10000826 	beq	r2,zero,81104034 <bSdmaDmaM1Transfer+0x330>
81104014:	10800060 	cmpeqi	r2,r2,1
81104018:	10000d26 	beq	r2,zero,81104050 <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110401c:	00b80014 	movui	r2,57344
81104020:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104024:	00800044 	movi	r2,1
81104028:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110402c:	e03ff615 	stw	zero,-40(fp)
			break;
81104030:	00000a06 	br	8110405c <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104034:	008000b4 	movhi	r2,2
81104038:	10b80004 	addi	r2,r2,-8192
8110403c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104040:	00800044 	movi	r2,1
81104044:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104048:	e03ff615 	stw	zero,-40(fp)
			break;
8110404c:	00000306 	br	8110405c <bSdmaDmaM1Transfer+0x358>
		default:
			bChannelFlag = FALSE;
81104050:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104054:	e03ff615 	stw	zero,-40(fp)
			break;
81104058:	0001883a 	nop
		}
		break;
8110405c:	00000206 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	default:
		bChannelFlag = FALSE;
81104060:	e03ff715 	stw	zero,-36(fp)
		break;
81104064:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW	+ (alt_u32) uliDdrInitialAddr;
81104068:	e0bffb17 	ldw	r2,-20(fp)
8110406c:	e0bff815 	stw	r2,-32(fp)
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104070:	e03ff915 	stw	zero,-28(fp)

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
81104074:	e0bff717 	ldw	r2,-36(fp)
81104078:	10003026 	beq	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
8110407c:	e0bff617 	ldw	r2,-40(fp)
81104080:	10002e26 	beq	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
81104084:	e0bffc0b 	ldhu	r2,-16(fp)
81104088:	10800468 	cmpgeui	r2,r2,17
8110408c:	10002b1e 	bne	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>

		if (pxDmaM1Dev != NULL) {
81104090:	d0a03917 	ldw	r2,-32540(gp)
81104094:	10002926 	beq	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104098:	00000206 	br	811040a4 <bSdmaDmaM1Transfer+0x3a0>
				alt_busy_sleep(1); /* delay 1us */
8110409c:	01000044 	movi	r4,1
811040a0:	11382940 	call	81138294 <alt_busy_sleep>

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {

		if (pxDmaM1Dev != NULL) {
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811040a4:	d0a03917 	ldw	r2,-32540(gp)
811040a8:	10800317 	ldw	r2,12(r2)
811040ac:	10800037 	ldwio	r2,0(r2)
811040b0:	1080010c 	andi	r2,r2,4
811040b4:	103ff91e 	bne	r2,zero,8110409c <__reset+0xfb0e409c>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if (0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
811040b8:	d2203917 	ldw	r8,-32540(gp)
811040bc:	e1bff817 	ldw	r6,-32(fp)
811040c0:	e1fff417 	ldw	r7,-48(fp)
811040c4:	e0bffc0b 	ldhu	r2,-16(fp)
811040c8:	10802224 	muli	r2,r2,136
811040cc:	e0fff917 	ldw	r3,-28(fp)
811040d0:	e13ff517 	ldw	r4,-44(fp)
811040d4:	01400044 	movi	r5,1
811040d8:	d9400815 	stw	r5,32(sp)
811040dc:	01400044 	movi	r5,1
811040e0:	d9400715 	stw	r5,28(sp)
811040e4:	01400044 	movi	r5,1
811040e8:	d9400615 	stw	r5,24(sp)
811040ec:	01400044 	movi	r5,1
811040f0:	d9400515 	stw	r5,20(sp)
811040f4:	01400044 	movi	r5,1
811040f8:	d9400415 	stw	r5,16(sp)
811040fc:	d9000315 	stw	r4,12(sp)
81104100:	d8c00215 	stw	r3,8(sp)
81104104:	e0fffa17 	ldw	r3,-24(fp)
81104108:	d8c00115 	stw	r3,4(sp)
8110410c:	d8800015 	stw	r2,0(sp)
81104110:	800b883a 	mov	r5,r16
81104114:	4009883a 	mov	r4,r8
81104118:	110c7c00 	call	8110c7c0 <iMsgdmaConstructExtendedMmToMmDescriptor>
8110411c:	1000071e 	bne	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)	) {
				/* Success = 0 */
				if (0 == iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,	&xDmaExtendedDescriptor)) {
81104120:	d0a03917 	ldw	r2,-32540(gp)
81104124:	800b883a 	mov	r5,r16
81104128:	1009883a 	mov	r4,r2
8110412c:	110c8800 	call	8110c880 <iMsgdmaExtendedDescriptorAsyncTransfer>
81104130:	1000021e 	bne	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
					bStatus = TRUE;
81104134:	00800044 	movi	r2,1
81104138:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
8110413c:	e0bff317 	ldw	r2,-52(fp)
}
81104140:	e6ffff04 	addi	sp,fp,-4
81104144:	dfc00217 	ldw	ra,8(sp)
81104148:	df000117 	ldw	fp,4(sp)
8110414c:	dc000017 	ldw	r16,0(sp)
81104150:	dec00304 	addi	sp,sp,12
81104154:	f800283a 	ret

81104158 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81104158:	deffe804 	addi	sp,sp,-96
8110415c:	de00012e 	bgeu	sp,et,81104164 <bSdmaDmaM2Transfer+0xc>
81104160:	003b68fa 	trap	3
81104164:	dfc01715 	stw	ra,92(sp)
81104168:	df001615 	stw	fp,88(sp)
8110416c:	dc001515 	stw	r16,84(sp)
81104170:	df001604 	addi	fp,sp,88
81104174:	e13ffb15 	stw	r4,-20(fp)
81104178:	2809883a 	mov	r4,r5
8110417c:	3007883a 	mov	r3,r6
81104180:	3805883a 	mov	r2,r7
81104184:	e13ffc0d 	sth	r4,-16(fp)
81104188:	e0fffd05 	stb	r3,-12(fp)
8110418c:	e0bffe05 	stb	r2,-8(fp)
81104190:	defff004 	addi	sp,sp,-64
81104194:	d8800904 	addi	r2,sp,36
81104198:	108007c4 	addi	r2,r2,31
8110419c:	1004d17a 	srli	r2,r2,5
811041a0:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811041a4:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
811041a8:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
811041ac:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
811041b0:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
811041b4:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;


	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
811041b8:	00800044 	movi	r2,1
811041bc:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
811041c0:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
811041c4:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
811041c8:	e0bffe03 	ldbu	r2,-8(fp)
811041cc:	10c00228 	cmpgeui	r3,r2,8
811041d0:	1800b81e 	bne	r3,zero,811044b4 <bSdmaDmaM2Transfer+0x35c>
811041d4:	100690ba 	slli	r3,r2,2
811041d8:	00a04434 	movhi	r2,33040
811041dc:	10907b04 	addi	r2,r2,16876
811041e0:	1885883a 	add	r2,r3,r2
811041e4:	10800017 	ldw	r2,0(r2)
811041e8:	1000683a 	jmp	r2
811041ec:	8110420c 	andi	r4,r16,16648
811041f0:	81104260 	cmpeqi	r4,r16,16649
811041f4:	811042bc 	xorhi	r4,r16,16650
811041f8:	81104310 	cmplti	r4,r16,16652
811041fc:	81104364 	muli	r4,r16,16653
81104200:	811043b8 	rdprs	r4,r16,16654
81104204:	8110440c 	andi	r4,r16,16656
81104208:	81104460 	cmpeqi	r4,r16,16657
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110420c:	e0bffd03 	ldbu	r2,-12(fp)
81104210:	10000826 	beq	r2,zero,81104234 <bSdmaDmaM2Transfer+0xdc>
81104214:	10800060 	cmpeqi	r2,r2,1
81104218:	10000d26 	beq	r2,zero,81104250 <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110421c:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104220:	00800044 	movi	r2,1
81104224:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81104228:	1106b640 	call	81106b64 <bFeebGetCh1RightBufferEmpty>
8110422c:	e0bff615 	stw	r2,-40(fp)
			break;
81104230:	00000a06 	br	8110425c <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81104234:	00800074 	movhi	r2,1
81104238:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
8110423c:	00800044 	movi	r2,1
81104240:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81104244:	1106afc0 	call	81106afc <bFeebGetCh1LeftBufferEmpty>
81104248:	e0bff615 	stw	r2,-40(fp)
			break;
8110424c:	00000306 	br	8110425c <bSdmaDmaM2Transfer+0x104>
		default:
			bChannelFlag = FALSE;
81104250:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104254:	e03ff615 	stw	zero,-40(fp)
			break;
81104258:	0001883a 	nop
		}
		break;
8110425c:	00009706 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81104260:	e0bffd03 	ldbu	r2,-12(fp)
81104264:	10000926 	beq	r2,zero,8110428c <bSdmaDmaM2Transfer+0x134>
81104268:	10800060 	cmpeqi	r2,r2,1
8110426c:	10000f26 	beq	r2,zero,811042ac <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104270:	00880004 	movi	r2,8192
81104274:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104278:	00800044 	movi	r2,1
8110427c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81104280:	1106c340 	call	81106c34 <bFeebGetCh2RightBufferEmpty>
81104284:	e0bff615 	stw	r2,-40(fp)
			break;
81104288:	00000b06 	br	811042b8 <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
8110428c:	00800074 	movhi	r2,1
81104290:	10880004 	addi	r2,r2,8192
81104294:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104298:	00800044 	movi	r2,1
8110429c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
811042a0:	1106bcc0 	call	81106bcc <bFeebGetCh2LeftBufferEmpty>
811042a4:	e0bff615 	stw	r2,-40(fp)
			break;
811042a8:	00000306 	br	811042b8 <bSdmaDmaM2Transfer+0x160>
		default:
			bChannelFlag = FALSE;
811042ac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811042b0:	e03ff615 	stw	zero,-40(fp)
			break;
811042b4:	0001883a 	nop
		}
		break;
811042b8:	00008006 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811042bc:	e0bffd03 	ldbu	r2,-12(fp)
811042c0:	10000826 	beq	r2,zero,811042e4 <bSdmaDmaM2Transfer+0x18c>
811042c4:	10800060 	cmpeqi	r2,r2,1
811042c8:	10000d26 	beq	r2,zero,81104300 <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811042cc:	00900004 	movi	r2,16384
811042d0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811042d4:	00800044 	movi	r2,1
811042d8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042dc:	e03ff615 	stw	zero,-40(fp)
			break;
811042e0:	00000a06 	br	8110430c <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811042e4:	00800074 	movhi	r2,1
811042e8:	10900004 	addi	r2,r2,16384
811042ec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
811042f0:	00800044 	movi	r2,1
811042f4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042f8:	e03ff615 	stw	zero,-40(fp)
			break;
811042fc:	00000306 	br	8110430c <bSdmaDmaM2Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
81104300:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104304:	e03ff615 	stw	zero,-40(fp)
			break;
81104308:	0001883a 	nop
		}
		break;
8110430c:	00006b06 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81104310:	e0bffd03 	ldbu	r2,-12(fp)
81104314:	10000826 	beq	r2,zero,81104338 <bSdmaDmaM2Transfer+0x1e0>
81104318:	10800060 	cmpeqi	r2,r2,1
8110431c:	10000d26 	beq	r2,zero,81104354 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81104320:	00980004 	movi	r2,24576
81104324:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104328:	00800044 	movi	r2,1
8110432c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104330:	e03ff615 	stw	zero,-40(fp)
			break;
81104334:	00000a06 	br	81104360 <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104338:	00800074 	movhi	r2,1
8110433c:	10980004 	addi	r2,r2,24576
81104340:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81104344:	00800044 	movi	r2,1
81104348:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110434c:	e03ff615 	stw	zero,-40(fp)
			break;
81104350:	00000306 	br	81104360 <bSdmaDmaM2Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81104354:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104358:	e03ff615 	stw	zero,-40(fp)
			break;
8110435c:	0001883a 	nop
		}
		break;
81104360:	00005606 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104364:	e0bffd03 	ldbu	r2,-12(fp)
81104368:	10000826 	beq	r2,zero,8110438c <bSdmaDmaM2Transfer+0x234>
8110436c:	10800060 	cmpeqi	r2,r2,1
81104370:	10000d26 	beq	r2,zero,811043a8 <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104374:	00a00014 	movui	r2,32768
81104378:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110437c:	00800044 	movi	r2,1
81104380:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104384:	e03ff615 	stw	zero,-40(fp)
			break;
81104388:	00000a06 	br	811043b4 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
8110438c:	008000b4 	movhi	r2,2
81104390:	10a00004 	addi	r2,r2,-32768
81104394:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104398:	00800044 	movi	r2,1
8110439c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043a0:	e03ff615 	stw	zero,-40(fp)
			break;
811043a4:	00000306 	br	811043b4 <bSdmaDmaM2Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
811043a8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811043ac:	e03ff615 	stw	zero,-40(fp)
			break;
811043b0:	0001883a 	nop
		}
		break;
811043b4:	00004106 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811043b8:	e0bffd03 	ldbu	r2,-12(fp)
811043bc:	10000826 	beq	r2,zero,811043e0 <bSdmaDmaM2Transfer+0x288>
811043c0:	10800060 	cmpeqi	r2,r2,1
811043c4:	10000d26 	beq	r2,zero,811043fc <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811043c8:	00a80014 	movui	r2,40960
811043cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811043d0:	00800044 	movi	r2,1
811043d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043d8:	e03ff615 	stw	zero,-40(fp)
			break;
811043dc:	00000a06 	br	81104408 <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811043e0:	008000b4 	movhi	r2,2
811043e4:	10a80004 	addi	r2,r2,-24576
811043e8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811043ec:	00800044 	movi	r2,1
811043f0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043f4:	e03ff615 	stw	zero,-40(fp)
			break;
811043f8:	00000306 	br	81104408 <bSdmaDmaM2Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
811043fc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104400:	e03ff615 	stw	zero,-40(fp)
			break;
81104404:	0001883a 	nop
		}
		break;
81104408:	00002c06 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
8110440c:	e0bffd03 	ldbu	r2,-12(fp)
81104410:	10000826 	beq	r2,zero,81104434 <bSdmaDmaM2Transfer+0x2dc>
81104414:	10800060 	cmpeqi	r2,r2,1
81104418:	10000d26 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
8110441c:	00b00014 	movui	r2,49152
81104420:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104424:	00800044 	movi	r2,1
81104428:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110442c:	e03ff615 	stw	zero,-40(fp)
			break;
81104430:	00000a06 	br	8110445c <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104434:	008000b4 	movhi	r2,2
81104438:	10b00004 	addi	r2,r2,-16384
8110443c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104440:	00800044 	movi	r2,1
81104444:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104448:	e03ff615 	stw	zero,-40(fp)
			break;
8110444c:	00000306 	br	8110445c <bSdmaDmaM2Transfer+0x304>
		default:
			bChannelFlag = FALSE;
81104450:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104454:	e03ff615 	stw	zero,-40(fp)
			break;
81104458:	0001883a 	nop
		}
		break;
8110445c:	00001706 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81104460:	e0bffd03 	ldbu	r2,-12(fp)
81104464:	10000826 	beq	r2,zero,81104488 <bSdmaDmaM2Transfer+0x330>
81104468:	10800060 	cmpeqi	r2,r2,1
8110446c:	10000d26 	beq	r2,zero,811044a4 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81104470:	00b80014 	movui	r2,57344
81104474:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104478:	00800044 	movi	r2,1
8110447c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104480:	e03ff615 	stw	zero,-40(fp)
			break;
81104484:	00000a06 	br	811044b0 <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104488:	008000b4 	movhi	r2,2
8110448c:	10b80004 	addi	r2,r2,-8192
81104490:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104494:	00800044 	movi	r2,1
81104498:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110449c:	e03ff615 	stw	zero,-40(fp)
			break;
811044a0:	00000306 	br	811044b0 <bSdmaDmaM2Transfer+0x358>
		default:
			bChannelFlag = FALSE;
811044a4:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811044a8:	e03ff615 	stw	zero,-40(fp)
			break;
811044ac:	0001883a 	nop
		}
		break;
811044b0:	00000206 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	default:
		bChannelFlag = FALSE;
811044b4:	e03ff715 	stw	zero,-36(fp)
		break;
811044b8:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
811044bc:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bChannelFlag = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
811044c0:	00a00034 	movhi	r2,32768
811044c4:	1885883a 	add	r2,r3,r2
811044c8:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044cc:	e03ff915 	stw	zero,-28(fp)

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
811044d0:	e0bff717 	ldw	r2,-36(fp)
811044d4:	10003026 	beq	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
811044d8:	e0bff617 	ldw	r2,-40(fp)
811044dc:	10002e26 	beq	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
811044e0:	e0bffc0b 	ldhu	r2,-16(fp)
811044e4:	10800468 	cmpgeui	r2,r2,17
811044e8:	10002b1e 	bne	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
		if (pxDmaM2Dev != NULL) {
811044ec:	d0a03a17 	ldw	r2,-32536(gp)
811044f0:	10002926 	beq	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044f4:	00000206 	br	81104500 <bSdmaDmaM2Transfer+0x3a8>
				alt_busy_sleep(1); /* delay 1us */
811044f8:	01000044 	movi	r4,1
811044fc:	11382940 	call	81138294 <alt_busy_sleep>
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
		if (pxDmaM2Dev != NULL) {

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104500:	d0a03a17 	ldw	r2,-32536(gp)
81104504:	10800317 	ldw	r2,12(r2)
81104508:	10800037 	ldwio	r2,0(r2)
8110450c:	1080010c 	andi	r2,r2,4
81104510:	103ff91e 	bne	r2,zero,811044f8 <__reset+0xfb0e44f8>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if ( 0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104514:	d2203a17 	ldw	r8,-32536(gp)
81104518:	e1bff817 	ldw	r6,-32(fp)
8110451c:	e1fff417 	ldw	r7,-48(fp)
81104520:	e0bffc0b 	ldhu	r2,-16(fp)
81104524:	10802224 	muli	r2,r2,136
81104528:	e0fff917 	ldw	r3,-28(fp)
8110452c:	e13ff517 	ldw	r4,-44(fp)
81104530:	01400044 	movi	r5,1
81104534:	d9400815 	stw	r5,32(sp)
81104538:	01400044 	movi	r5,1
8110453c:	d9400715 	stw	r5,28(sp)
81104540:	01400044 	movi	r5,1
81104544:	d9400615 	stw	r5,24(sp)
81104548:	01400044 	movi	r5,1
8110454c:	d9400515 	stw	r5,20(sp)
81104550:	01400044 	movi	r5,1
81104554:	d9400415 	stw	r5,16(sp)
81104558:	d9000315 	stw	r4,12(sp)
8110455c:	d8c00215 	stw	r3,8(sp)
81104560:	e0fffa17 	ldw	r3,-24(fp)
81104564:	d8c00115 	stw	r3,4(sp)
81104568:	d8800015 	stw	r2,0(sp)
8110456c:	800b883a 	mov	r5,r16
81104570:	4009883a 	mov	r4,r8
81104574:	110c7c00 	call	8110c7c0 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104578:	1000071e 	bne	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)) {
				/* Success = 0 */
				if ( 0 == iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
8110457c:	d0a03a17 	ldw	r2,-32536(gp)
81104580:	800b883a 	mov	r5,r16
81104584:	1009883a 	mov	r4,r2
81104588:	110c8c40 	call	8110c8c4 <iMsgdmaExtendedDescriptorSyncTransfer>
8110458c:	1000021e 	bne	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
						&xDmaExtendedDescriptor)) {
					bStatus = TRUE;
81104590:	00800044 	movi	r2,1
81104594:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
81104598:	e0bff317 	ldw	r2,-52(fp)
}
8110459c:	e6ffff04 	addi	sp,fp,-4
811045a0:	dfc00217 	ldw	ra,8(sp)
811045a4:	df000117 	ldw	fp,4(sp)
811045a8:	dc000017 	ldw	r16,0(sp)
811045ac:	dec00304 	addi	sp,sp,12
811045b0:	f800283a 	ret

811045b4 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
811045b4:	defff804 	addi	sp,sp,-32
811045b8:	de00012e 	bgeu	sp,et,811045c0 <bCommSetGlobalIrqEn+0xc>
811045bc:	003b68fa 	trap	3
811045c0:	dfc00715 	stw	ra,28(sp)
811045c4:	df000615 	stw	fp,24(sp)
811045c8:	df000604 	addi	fp,sp,24
811045cc:	e13ffe15 	stw	r4,-8(fp)
811045d0:	2805883a 	mov	r2,r5
811045d4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811045d8:	e03ffa15 	stw	zero,-24(fp)
	bool bValidCh = FALSE;
811045dc:	e03ffb15 	stw	zero,-20(fp)
	volatile alt_u32 uliReg = 0;
811045e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 *puliCommAddr = 0;
811045e4:	e03ffc15 	stw	zero,-16(fp)

	switch (ucCommCh) {
811045e8:	e0bfff03 	ldbu	r2,-4(fp)
811045ec:	10c00228 	cmpgeui	r3,r2,8
811045f0:	18003e1e 	bne	r3,zero,811046ec <bCommSetGlobalIrqEn+0x138>
811045f4:	100690ba 	slli	r3,r2,2
811045f8:	00a04434 	movhi	r2,33040
811045fc:	10918304 	addi	r2,r2,17932
81104600:	1885883a 	add	r2,r3,r2
81104604:	10800017 	ldw	r2,0(r2)
81104608:	1000683a 	jmp	r2
8110460c:	8110462c 	andhi	r4,r16,16664
81104610:	81104644 	addi	r4,r16,16665
81104614:	8110465c 	xori	r4,r16,16665
81104618:	81104674 	orhi	r4,r16,16665
8110461c:	8110468c 	andi	r4,r16,16666
81104620:	811046a4 	muli	r4,r16,16666
81104624:	811046bc 	xorhi	r4,r16,16666
81104628:	811046d4 	ori	r4,r16,16667
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110462c:	00a04834 	movhi	r2,33056
81104630:	108b0004 	addi	r2,r2,11264
81104634:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104638:	00800044 	movi	r2,1
8110463c:	e0bffb15 	stw	r2,-20(fp)
		break;
81104640:	00002c06 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104644:	00a04834 	movhi	r2,33056
81104648:	108a0004 	addi	r2,r2,10240
8110464c:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104650:	00800044 	movi	r2,1
81104654:	e0bffb15 	stw	r2,-20(fp)
		break;
81104658:	00002606 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110465c:	00a04834 	movhi	r2,33056
81104660:	108b0004 	addi	r2,r2,11264
81104664:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104668:	00800044 	movi	r2,1
8110466c:	e0bffb15 	stw	r2,-20(fp)
		break;
81104670:	00002006 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104674:	00a04834 	movhi	r2,33056
81104678:	108a0004 	addi	r2,r2,10240
8110467c:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104680:	00800044 	movi	r2,1
81104684:	e0bffb15 	stw	r2,-20(fp)
		break;
81104688:	00001a06 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110468c:	00a04834 	movhi	r2,33056
81104690:	108b0004 	addi	r2,r2,11264
81104694:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104698:	00800044 	movi	r2,1
8110469c:	e0bffb15 	stw	r2,-20(fp)
		break;
811046a0:	00001406 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811046a4:	00a04834 	movhi	r2,33056
811046a8:	108a0004 	addi	r2,r2,10240
811046ac:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
811046b0:	00800044 	movi	r2,1
811046b4:	e0bffb15 	stw	r2,-20(fp)
		break;
811046b8:	00000e06 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811046bc:	00a04834 	movhi	r2,33056
811046c0:	108b0004 	addi	r2,r2,11264
811046c4:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
811046c8:	00800044 	movi	r2,1
811046cc:	e0bffb15 	stw	r2,-20(fp)
		break;
811046d0:	00000806 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811046d4:	00a04834 	movhi	r2,33056
811046d8:	108a0004 	addi	r2,r2,10240
811046dc:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
811046e0:	00800044 	movi	r2,1
811046e4:	e0bffb15 	stw	r2,-20(fp)
		break;
811046e8:	00000206 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	default:
		bValidCh = FALSE;
811046ec:	e03ffb15 	stw	zero,-20(fp)
		break;
811046f0:	0001883a 	nop
	}

	if (bValidCh) {
811046f4:	e0bffb17 	ldw	r2,-20(fp)
811046f8:	10001626 	beq	r2,zero,81104754 <bCommSetGlobalIrqEn+0x1a0>
		uliReg = uliCommReadReg(puliCommAddr,
811046fc:	01400444 	movi	r5,17
81104700:	e13ffc17 	ldw	r4,-16(fp)
81104704:	11048d40 	call	811048d4 <uliCommReadReg>
81104708:	e0bffd15 	stw	r2,-12(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
8110470c:	e0bffe17 	ldw	r2,-8(fp)
81104710:	10000426 	beq	r2,zero,81104724 <bCommSetGlobalIrqEn+0x170>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104714:	e0bffd17 	ldw	r2,-12(fp)
81104718:	10800074 	orhi	r2,r2,1
8110471c:	e0bffd15 	stw	r2,-12(fp)
81104720:	00000506 	br	81104738 <bCommSetGlobalIrqEn+0x184>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104724:	e0fffd17 	ldw	r3,-12(fp)
81104728:	00bffff4 	movhi	r2,65535
8110472c:	10bfffc4 	addi	r2,r2,-1
81104730:	1884703a 	and	r2,r3,r2
81104734:	e0bffd15 	stw	r2,-12(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104738:	e0bffd17 	ldw	r2,-12(fp)
8110473c:	100d883a 	mov	r6,r2
81104740:	01400444 	movi	r5,17
81104744:	e13ffc17 	ldw	r4,-16(fp)
81104748:	11048800 	call	81104880 <vCommWriteReg>

		bStatus = TRUE;
8110474c:	00800044 	movi	r2,1
81104750:	e0bffa15 	stw	r2,-24(fp)
	}

	return bStatus;
81104754:	e0bffa17 	ldw	r2,-24(fp)
}
81104758:	e037883a 	mov	sp,fp
8110475c:	dfc00117 	ldw	ra,4(sp)
81104760:	df000017 	ldw	fp,0(sp)
81104764:	dec00204 	addi	sp,sp,8
81104768:	f800283a 	ret

8110476c <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
8110476c:	defffa04 	addi	sp,sp,-24
81104770:	de00012e 	bgeu	sp,et,81104778 <bCommInitCh+0xc>
81104774:	003b68fa 	trap	3
81104778:	dfc00515 	stw	ra,20(sp)
8110477c:	df000415 	stw	fp,16(sp)
81104780:	df000404 	addi	fp,sp,16
81104784:	e13ffe15 	stw	r4,-8(fp)
81104788:	2805883a 	mov	r2,r5
8110478c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104790:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
81104794:	e03ffd15 	stw	zero,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104798:	e0bffe17 	ldw	r2,-8(fp)
8110479c:	10805904 	addi	r2,r2,356
811047a0:	e0ffff03 	ldbu	r3,-4(fp)
811047a4:	180b883a 	mov	r5,r3
811047a8:	1009883a 	mov	r4,r2
811047ac:	110b0200 	call	8110b020 <bSpwcInitCh>
811047b0:	1000021e 	bne	r2,zero,811047bc <bCommInitCh+0x50>
		bInitFail = TRUE;
811047b4:	00800044 	movi	r2,1
811047b8:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!vFeebInitIrq(ucCommCh)) {
811047bc:	e0bfff03 	ldbu	r2,-4(fp)
811047c0:	1009883a 	mov	r4,r2
811047c4:	11064e40 	call	811064e4 <vFeebInitIrq>
811047c8:	1000021e 	bne	r2,zero,811047d4 <bCommInitCh+0x68>
		bInitFail = TRUE;
811047cc:	00800044 	movi	r2,1
811047d0:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
811047d4:	e0bffe17 	ldw	r2,-8(fp)
811047d8:	10800904 	addi	r2,r2,36
811047dc:	e0ffff03 	ldbu	r3,-4(fp)
811047e0:	180b883a 	mov	r5,r3
811047e4:	1009883a 	mov	r4,r2
811047e8:	11071fc0 	call	811071fc <bFeebInitCh>
811047ec:	1000021e 	bne	r2,zero,811047f8 <bCommInitCh+0x8c>
		bInitFail = TRUE;
811047f0:	00800044 	movi	r2,1
811047f4:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
811047f8:	e0bffe17 	ldw	r2,-8(fp)
811047fc:	10801304 	addi	r2,r2,76
81104800:	e0ffff03 	ldbu	r3,-4(fp)
81104804:	180b883a 	mov	r5,r3
81104808:	1009883a 	mov	r4,r2
8110480c:	110a60c0 	call	8110a60c <bRmapInitCh>
81104810:	1000021e 	bne	r2,zero,8110481c <bCommInitCh+0xb0>
		bInitFail = TRUE;
81104814:	00800044 	movi	r2,1
81104818:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!vRmapInitIrq(ucCommCh)) {
8110481c:	e0bfff03 	ldbu	r2,-4(fp)
81104820:	1009883a 	mov	r4,r2
81104824:	1107f2c0 	call	81107f2c <vRmapInitIrq>
81104828:	1000021e 	bne	r2,zero,81104834 <bCommInitCh+0xc8>
		bInitFail = TRUE;
8110482c:	00800044 	movi	r2,1
81104830:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104834:	e0bffe17 	ldw	r2,-8(fp)
81104838:	10800104 	addi	r2,r2,4
8110483c:	e0ffff03 	ldbu	r3,-4(fp)
81104840:	180b883a 	mov	r5,r3
81104844:	1009883a 	mov	r4,r2
81104848:	1104ffc0 	call	81104ffc <bDpktInitCh>
8110484c:	1000021e 	bne	r2,zero,81104858 <bCommInitCh+0xec>
		bInitFail = TRUE;
81104850:	00800044 	movi	r2,1
81104854:	e0bffd15 	stw	r2,-12(fp)
	}

	if (!bInitFail) {
81104858:	e0bffd17 	ldw	r2,-12(fp)
8110485c:	1000021e 	bne	r2,zero,81104868 <bCommInitCh+0xfc>
		bStatus = TRUE;
81104860:	00800044 	movi	r2,1
81104864:	e0bffc15 	stw	r2,-16(fp)
	}

	return bStatus;
81104868:	e0bffc17 	ldw	r2,-16(fp)
}
8110486c:	e037883a 	mov	sp,fp
81104870:	dfc00117 	ldw	ra,4(sp)
81104874:	df000017 	ldw	fp,0(sp)
81104878:	dec00204 	addi	sp,sp,8
8110487c:	f800283a 	ret

81104880 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104880:	defffc04 	addi	sp,sp,-16
81104884:	de00012e 	bgeu	sp,et,8110488c <vCommWriteReg+0xc>
81104888:	003b68fa 	trap	3
8110488c:	df000315 	stw	fp,12(sp)
81104890:	df000304 	addi	fp,sp,12
81104894:	e13ffd15 	stw	r4,-12(fp)
81104898:	e17ffe15 	stw	r5,-8(fp)
8110489c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811048a0:	e0bffe17 	ldw	r2,-8(fp)
811048a4:	1085883a 	add	r2,r2,r2
811048a8:	1085883a 	add	r2,r2,r2
811048ac:	1007883a 	mov	r3,r2
811048b0:	e0bffd17 	ldw	r2,-12(fp)
811048b4:	10c5883a 	add	r2,r2,r3
811048b8:	e0ffff17 	ldw	r3,-4(fp)
811048bc:	10c00015 	stw	r3,0(r2)
}
811048c0:	0001883a 	nop
811048c4:	e037883a 	mov	sp,fp
811048c8:	df000017 	ldw	fp,0(sp)
811048cc:	dec00104 	addi	sp,sp,4
811048d0:	f800283a 	ret

811048d4 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811048d4:	defffc04 	addi	sp,sp,-16
811048d8:	de00012e 	bgeu	sp,et,811048e0 <uliCommReadReg+0xc>
811048dc:	003b68fa 	trap	3
811048e0:	df000315 	stw	fp,12(sp)
811048e4:	df000304 	addi	fp,sp,12
811048e8:	e13ffe15 	stw	r4,-8(fp)
811048ec:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811048f0:	e0bfff17 	ldw	r2,-4(fp)
811048f4:	1085883a 	add	r2,r2,r2
811048f8:	1085883a 	add	r2,r2,r2
811048fc:	1007883a 	mov	r3,r2
81104900:	e0bffe17 	ldw	r2,-8(fp)
81104904:	10c5883a 	add	r2,r2,r3
81104908:	10800017 	ldw	r2,0(r2)
8110490c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104910:	e0bffd17 	ldw	r2,-12(fp)
}
81104914:	e037883a 	mov	sp,fp
81104918:	df000017 	ldw	fp,0(sp)
8110491c:	dec00104 	addi	sp,sp,4
81104920:	f800283a 	ret

81104924 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81104924:	defffb04 	addi	sp,sp,-20
81104928:	de00012e 	bgeu	sp,et,81104930 <bDpktSetPacketConfig+0xc>
8110492c:	003b68fa 	trap	3
81104930:	dfc00415 	stw	ra,16(sp)
81104934:	df000315 	stw	fp,12(sp)
81104938:	df000304 	addi	fp,sp,12
8110493c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104940:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104944:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104948:	e0bfff17 	ldw	r2,-4(fp)
8110494c:	10009826 	beq	r2,zero,81104bb0 <bDpktSetPacketConfig+0x28c>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104950:	e0bfff17 	ldw	r2,-4(fp)
81104954:	10800017 	ldw	r2,0(r2)
81104958:	01400204 	movi	r5,8
8110495c:	1009883a 	mov	r4,r2
81104960:	11052200 	call	81105220 <uliDpktReadReg>
81104964:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104968:	e0bffe17 	ldw	r2,-8(fp)
8110496c:	10bfffec 	andhi	r2,r2,65535
81104970:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104974:	e0bfff17 	ldw	r2,-4(fp)
81104978:	1080010b 	ldhu	r2,4(r2)
8110497c:	10ffffcc 	andi	r3,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104980:	e0bffe17 	ldw	r2,-8(fp)
81104984:	1884b03a 	or	r2,r3,r2
81104988:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
8110498c:	e0bffe17 	ldw	r2,-8(fp)
81104990:	10bfffcc 	andi	r2,r2,65535
81104994:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104998:	e0bfff17 	ldw	r2,-4(fp)
8110499c:	1080018b 	ldhu	r2,6(r2)
811049a0:	10bfffcc 	andi	r2,r2,65535
811049a4:	1004943a 	slli	r2,r2,16
811049a8:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811049ac:	e0bffe17 	ldw	r2,-8(fp)
811049b0:	1884b03a 	or	r2,r3,r2
811049b4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811049b8:	e0bfff17 	ldw	r2,-4(fp)
811049bc:	10800017 	ldw	r2,0(r2)
811049c0:	e0fffe17 	ldw	r3,-8(fp)
811049c4:	180d883a 	mov	r6,r3
811049c8:	01400204 	movi	r5,8
811049cc:	1009883a 	mov	r4,r2
811049d0:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049d4:	e0bfff17 	ldw	r2,-4(fp)
811049d8:	10800017 	ldw	r2,0(r2)
811049dc:	01400244 	movi	r5,9
811049e0:	1009883a 	mov	r4,r2
811049e4:	11052200 	call	81105220 <uliDpktReadReg>
811049e8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
811049ec:	e0bffe17 	ldw	r2,-8(fp)
811049f0:	10bfffec 	andhi	r2,r2,65535
811049f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
811049f8:	e0bfff17 	ldw	r2,-4(fp)
811049fc:	1080020b 	ldhu	r2,8(r2)
81104a00:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104a04:	e0bffe17 	ldw	r2,-8(fp)
81104a08:	1884b03a 	or	r2,r3,r2
81104a0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104a10:	e0bffe17 	ldw	r2,-8(fp)
81104a14:	10bfffcc 	andi	r2,r2,65535
81104a18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104a1c:	e0bfff17 	ldw	r2,-4(fp)
81104a20:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104a24:	10bfffcc 	andi	r2,r2,65535
81104a28:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104a2c:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104a30:	e0bffe17 	ldw	r2,-8(fp)
81104a34:	1884b03a 	or	r2,r3,r2
81104a38:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104a3c:	e0bfff17 	ldw	r2,-4(fp)
81104a40:	10800017 	ldw	r2,0(r2)
81104a44:	e0fffe17 	ldw	r3,-8(fp)
81104a48:	180d883a 	mov	r6,r3
81104a4c:	01400244 	movi	r5,9
81104a50:	1009883a 	mov	r4,r2
81104a54:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a58:	e0bfff17 	ldw	r2,-4(fp)
81104a5c:	10800017 	ldw	r2,0(r2)
81104a60:	01400284 	movi	r5,10
81104a64:	1009883a 	mov	r4,r2
81104a68:	11052200 	call	81105220 <uliDpktReadReg>
81104a6c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104a70:	e0bffe17 	ldw	r2,-8(fp)
81104a74:	10bfffec 	andhi	r2,r2,65535
81104a78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104a7c:	e0bfff17 	ldw	r2,-4(fp)
81104a80:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104a84:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104a88:	e0bffe17 	ldw	r2,-8(fp)
81104a8c:	1884b03a 	or	r2,r3,r2
81104a90:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104a94:	e0bfff17 	ldw	r2,-4(fp)
81104a98:	10800017 	ldw	r2,0(r2)
81104a9c:	e0fffe17 	ldw	r3,-8(fp)
81104aa0:	180d883a 	mov	r6,r3
81104aa4:	01400284 	movi	r5,10
81104aa8:	1009883a 	mov	r4,r2
81104aac:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ab0:	e0bfff17 	ldw	r2,-4(fp)
81104ab4:	10800017 	ldw	r2,0(r2)
81104ab8:	014002c4 	movi	r5,11
81104abc:	1009883a 	mov	r4,r2
81104ac0:	11052200 	call	81105220 <uliDpktReadReg>
81104ac4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104ac8:	e0fffe17 	ldw	r3,-8(fp)
81104acc:	00bfc004 	movi	r2,-256
81104ad0:	1884703a 	and	r2,r3,r2
81104ad4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104ad8:	e0bfff17 	ldw	r2,-4(fp)
81104adc:	10800383 	ldbu	r2,14(r2)
81104ae0:	10c03fcc 	andi	r3,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104ae4:	e0bffe17 	ldw	r2,-8(fp)
81104ae8:	1884b03a 	or	r2,r3,r2
81104aec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81104af0:	e0fffe17 	ldw	r3,-8(fp)
81104af4:	00bffff4 	movhi	r2,65535
81104af8:	10803fc4 	addi	r2,r2,255
81104afc:	1884703a 	and	r2,r3,r2
81104b00:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104b04:	e0bfff17 	ldw	r2,-4(fp)
81104b08:	108003c3 	ldbu	r2,15(r2)
81104b0c:	10803fcc 	andi	r2,r2,255
81104b10:	1004923a 	slli	r2,r2,8
81104b14:	10ffffcc 	andi	r3,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104b18:	e0bffe17 	ldw	r2,-8(fp)
81104b1c:	1884b03a 	or	r2,r3,r2
81104b20:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
81104b24:	e0fffe17 	ldw	r3,-8(fp)
81104b28:	00bfc074 	movhi	r2,65281
81104b2c:	10bfffc4 	addi	r2,r2,-1
81104b30:	1884703a 	and	r2,r3,r2
81104b34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
81104b38:	e0bfff17 	ldw	r2,-4(fp)
81104b3c:	10800403 	ldbu	r2,16(r2)
81104b40:	10803fcc 	andi	r2,r2,255
81104b44:	1004943a 	slli	r2,r2,16
81104b48:	10c03fec 	andhi	r3,r2,255
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
81104b4c:	e0bffe17 	ldw	r2,-8(fp)
81104b50:	1884b03a 	or	r2,r3,r2
81104b54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
		uliReg &= (~COMM_DATA_PKT_LOGICAL_ADDR_MSK);
81104b58:	e0fffe17 	ldw	r3,-8(fp)
81104b5c:	00804034 	movhi	r2,256
81104b60:	10bfffc4 	addi	r2,r2,-1
81104b64:	1884703a 	and	r2,r3,r2
81104b68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LOGICAL_ADDR_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr << 24));
81104b6c:	e0bfff17 	ldw	r2,-4(fp)
81104b70:	10800443 	ldbu	r2,17(r2)
81104b74:	10803fcc 	andi	r2,r2,255
81104b78:	1004963a 	slli	r2,r2,24
81104b7c:	1007883a 	mov	r3,r2
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
		uliReg &= (~COMM_DATA_PKT_LOGICAL_ADDR_MSK);
		uliReg |= (COMM_DATA_PKT_LOGICAL_ADDR_MSK
81104b80:	e0bffe17 	ldw	r2,-8(fp)
81104b84:	1884b03a 	or	r2,r3,r2
81104b88:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr << 24));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104b8c:	e0bfff17 	ldw	r2,-4(fp)
81104b90:	10800017 	ldw	r2,0(r2)
81104b94:	e0fffe17 	ldw	r3,-8(fp)
81104b98:	180d883a 	mov	r6,r3
81104b9c:	014002c4 	movi	r5,11
81104ba0:	1009883a 	mov	r4,r2
81104ba4:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104ba8:	00800044 	movi	r2,1
81104bac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104bb0:	e0bffd17 	ldw	r2,-12(fp)
}
81104bb4:	e037883a 	mov	sp,fp
81104bb8:	dfc00117 	ldw	ra,4(sp)
81104bbc:	df000017 	ldw	fp,0(sp)
81104bc0:	dec00204 	addi	sp,sp,8
81104bc4:	f800283a 	ret

81104bc8 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104bc8:	defffb04 	addi	sp,sp,-20
81104bcc:	de00012e 	bgeu	sp,et,81104bd4 <bDpktGetPacketConfig+0xc>
81104bd0:	003b68fa 	trap	3
81104bd4:	dfc00415 	stw	ra,16(sp)
81104bd8:	df000315 	stw	fp,12(sp)
81104bdc:	df000304 	addi	fp,sp,12
81104be0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104be4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104be8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bec:	e0bfff17 	ldw	r2,-4(fp)
81104bf0:	10004526 	beq	r2,zero,81104d08 <bDpktGetPacketConfig+0x140>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bf4:	e0bfff17 	ldw	r2,-4(fp)
81104bf8:	10800017 	ldw	r2,0(r2)
81104bfc:	01400204 	movi	r5,8
81104c00:	1009883a 	mov	r4,r2
81104c04:	11052200 	call	81105220 <uliDpktReadReg>
81104c08:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104c0c:	e0bffe17 	ldw	r2,-8(fp)
81104c10:	1007883a 	mov	r3,r2
81104c14:	e0bfff17 	ldw	r2,-4(fp)
81104c18:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104c1c:	e0bffe17 	ldw	r2,-8(fp)
81104c20:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104c24:	1007883a 	mov	r3,r2
81104c28:	e0bfff17 	ldw	r2,-4(fp)
81104c2c:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c30:	e0bfff17 	ldw	r2,-4(fp)
81104c34:	10800017 	ldw	r2,0(r2)
81104c38:	01400244 	movi	r5,9
81104c3c:	1009883a 	mov	r4,r2
81104c40:	11052200 	call	81105220 <uliDpktReadReg>
81104c44:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104c48:	e0bffe17 	ldw	r2,-8(fp)
81104c4c:	1007883a 	mov	r3,r2
81104c50:	e0bfff17 	ldw	r2,-4(fp)
81104c54:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104c58:	e0bffe17 	ldw	r2,-8(fp)
81104c5c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104c60:	1007883a 	mov	r3,r2
81104c64:	e0bfff17 	ldw	r2,-4(fp)
81104c68:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c6c:	e0bfff17 	ldw	r2,-4(fp)
81104c70:	10800017 	ldw	r2,0(r2)
81104c74:	01400284 	movi	r5,10
81104c78:	1009883a 	mov	r4,r2
81104c7c:	11052200 	call	81105220 <uliDpktReadReg>
81104c80:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104c84:	e0bffe17 	ldw	r2,-8(fp)
81104c88:	1007883a 	mov	r3,r2
81104c8c:	e0bfff17 	ldw	r2,-4(fp)
81104c90:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c94:	e0bfff17 	ldw	r2,-4(fp)
81104c98:	10800017 	ldw	r2,0(r2)
81104c9c:	014002c4 	movi	r5,11
81104ca0:	1009883a 	mov	r4,r2
81104ca4:	11052200 	call	81105220 <uliDpktReadReg>
81104ca8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104cac:	e0bffe17 	ldw	r2,-8(fp)
81104cb0:	1007883a 	mov	r3,r2
81104cb4:	e0bfff17 	ldw	r2,-4(fp)
81104cb8:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104cbc:	e0bffe17 	ldw	r2,-8(fp)
81104cc0:	10bfc00c 	andi	r2,r2,65280
81104cc4:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104cc8:	1007883a 	mov	r3,r2
81104ccc:	e0bfff17 	ldw	r2,-4(fp)
81104cd0:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
81104cd4:	e0bffe17 	ldw	r2,-8(fp)
81104cd8:	10803fec 	andhi	r2,r2,255
81104cdc:	1004d43a 	srli	r2,r2,16

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
81104ce0:	1007883a 	mov	r3,r2
81104ce4:	e0bfff17 	ldw	r2,-4(fp)
81104ce8:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
		pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr= (alt_u8)(
				(uliReg & COMM_DATA_PKT_LOGICAL_ADDR_MSK) >> 24);
81104cec:	e0bffe17 	ldw	r2,-8(fp)
81104cf0:	1004d63a 	srli	r2,r2,24
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
		pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr= (alt_u8)(
81104cf4:	1007883a 	mov	r3,r2
81104cf8:	e0bfff17 	ldw	r2,-4(fp)
81104cfc:	10c00445 	stb	r3,17(r2)
				(uliReg & COMM_DATA_PKT_LOGICAL_ADDR_MSK) >> 24);

		bStatus = TRUE;
81104d00:	00800044 	movi	r2,1
81104d04:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d08:	e0bffd17 	ldw	r2,-12(fp)
}
81104d0c:	e037883a 	mov	sp,fp
81104d10:	dfc00117 	ldw	ra,4(sp)
81104d14:	df000017 	ldw	fp,0(sp)
81104d18:	dec00204 	addi	sp,sp,8
81104d1c:	f800283a 	ret

81104d20 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104d20:	defffb04 	addi	sp,sp,-20
81104d24:	de00012e 	bgeu	sp,et,81104d2c <bDpktGetPacketHeader+0xc>
81104d28:	003b68fa 	trap	3
81104d2c:	dfc00415 	stw	ra,16(sp)
81104d30:	df000315 	stw	fp,12(sp)
81104d34:	df000304 	addi	fp,sp,12
81104d38:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d3c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104d40:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104d44:	e0bfff17 	ldw	r2,-4(fp)
81104d48:	10002026 	beq	r2,zero,81104dcc <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d4c:	e0bfff17 	ldw	r2,-4(fp)
81104d50:	10800017 	ldw	r2,0(r2)
81104d54:	01400304 	movi	r5,12
81104d58:	1009883a 	mov	r4,r2
81104d5c:	11052200 	call	81105220 <uliDpktReadReg>
81104d60:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104d64:	e0bffe17 	ldw	r2,-8(fp)
81104d68:	1007883a 	mov	r3,r2
81104d6c:	e0bfff17 	ldw	r2,-4(fp)
81104d70:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104d74:	e0bffe17 	ldw	r2,-8(fp)
81104d78:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104d7c:	1007883a 	mov	r3,r2
81104d80:	e0bfff17 	ldw	r2,-4(fp)
81104d84:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d88:	e0bfff17 	ldw	r2,-4(fp)
81104d8c:	10800017 	ldw	r2,0(r2)
81104d90:	01400344 	movi	r5,13
81104d94:	1009883a 	mov	r4,r2
81104d98:	11052200 	call	81105220 <uliDpktReadReg>
81104d9c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104da0:	e0bffe17 	ldw	r2,-8(fp)
81104da4:	1007883a 	mov	r3,r2
81104da8:	e0bfff17 	ldw	r2,-4(fp)
81104dac:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104db0:	e0bffe17 	ldw	r2,-8(fp)
81104db4:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104db8:	1007883a 	mov	r3,r2
81104dbc:	e0bfff17 	ldw	r2,-4(fp)
81104dc0:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104dc4:	00800044 	movi	r2,1
81104dc8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104dcc:	e0bffd17 	ldw	r2,-12(fp)
}
81104dd0:	e037883a 	mov	sp,fp
81104dd4:	dfc00117 	ldw	ra,4(sp)
81104dd8:	df000017 	ldw	fp,0(sp)
81104ddc:	dec00204 	addi	sp,sp,8
81104de0:	f800283a 	ret

81104de4 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104de4:	defffb04 	addi	sp,sp,-20
81104de8:	de00012e 	bgeu	sp,et,81104df0 <bDpktSetPixelDelay+0xc>
81104dec:	003b68fa 	trap	3
81104df0:	dfc00415 	stw	ra,16(sp)
81104df4:	df000315 	stw	fp,12(sp)
81104df8:	df000304 	addi	fp,sp,12
81104dfc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104e00:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104e04:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104e08:	e0bfff17 	ldw	r2,-4(fp)
81104e0c:	10004426 	beq	r2,zero,81104f20 <bDpktSetPixelDelay+0x13c>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e10:	e0bfff17 	ldw	r2,-4(fp)
81104e14:	10800017 	ldw	r2,0(r2)
81104e18:	01400384 	movi	r5,14
81104e1c:	1009883a 	mov	r4,r2
81104e20:	11052200 	call	81105220 <uliDpktReadReg>
81104e24:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104e28:	e0bffe17 	ldw	r2,-8(fp)
81104e2c:	10bfffec 	andhi	r2,r2,65535
81104e30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104e34:	e0bfff17 	ldw	r2,-4(fp)
81104e38:	1080068b 	ldhu	r2,26(r2)
81104e3c:	10ffffcc 	andi	r3,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104e40:	e0bffe17 	ldw	r2,-8(fp)
81104e44:	1884b03a 	or	r2,r3,r2
81104e48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104e4c:	e0bfff17 	ldw	r2,-4(fp)
81104e50:	10800017 	ldw	r2,0(r2)
81104e54:	e0fffe17 	ldw	r3,-8(fp)
81104e58:	180d883a 	mov	r6,r3
81104e5c:	01400384 	movi	r5,14
81104e60:	1009883a 	mov	r4,r2
81104e64:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e68:	e0bfff17 	ldw	r2,-4(fp)
81104e6c:	10800017 	ldw	r2,0(r2)
81104e70:	014003c4 	movi	r5,15
81104e74:	1009883a 	mov	r4,r2
81104e78:	11052200 	call	81105220 <uliDpktReadReg>
81104e7c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104e80:	e0bffe17 	ldw	r2,-8(fp)
81104e84:	10bfffec 	andhi	r2,r2,65535
81104e88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104e8c:	e0bfff17 	ldw	r2,-4(fp)
81104e90:	1080070b 	ldhu	r2,28(r2)
81104e94:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104e98:	e0bffe17 	ldw	r2,-8(fp)
81104e9c:	1884b03a 	or	r2,r3,r2
81104ea0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104ea4:	e0bfff17 	ldw	r2,-4(fp)
81104ea8:	10800017 	ldw	r2,0(r2)
81104eac:	e0fffe17 	ldw	r3,-8(fp)
81104eb0:	180d883a 	mov	r6,r3
81104eb4:	014003c4 	movi	r5,15
81104eb8:	1009883a 	mov	r4,r2
81104ebc:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ec0:	e0bfff17 	ldw	r2,-4(fp)
81104ec4:	10800017 	ldw	r2,0(r2)
81104ec8:	01400404 	movi	r5,16
81104ecc:	1009883a 	mov	r4,r2
81104ed0:	11052200 	call	81105220 <uliDpktReadReg>
81104ed4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ed8:	e0bffe17 	ldw	r2,-8(fp)
81104edc:	10bfffec 	andhi	r2,r2,65535
81104ee0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104ee4:	e0bfff17 	ldw	r2,-4(fp)
81104ee8:	1080078b 	ldhu	r2,30(r2)
81104eec:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104ef0:	e0bffe17 	ldw	r2,-8(fp)
81104ef4:	1884b03a 	or	r2,r3,r2
81104ef8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104efc:	e0bfff17 	ldw	r2,-4(fp)
81104f00:	10800017 	ldw	r2,0(r2)
81104f04:	e0fffe17 	ldw	r3,-8(fp)
81104f08:	180d883a 	mov	r6,r3
81104f0c:	01400404 	movi	r5,16
81104f10:	1009883a 	mov	r4,r2
81104f14:	11051cc0 	call	811051cc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104f18:	00800044 	movi	r2,1
81104f1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104f20:	e0bffd17 	ldw	r2,-12(fp)
}
81104f24:	e037883a 	mov	sp,fp
81104f28:	dfc00117 	ldw	ra,4(sp)
81104f2c:	df000017 	ldw	fp,0(sp)
81104f30:	dec00204 	addi	sp,sp,8
81104f34:	f800283a 	ret

81104f38 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104f38:	defffb04 	addi	sp,sp,-20
81104f3c:	de00012e 	bgeu	sp,et,81104f44 <bDpktGetPixelDelay+0xc>
81104f40:	003b68fa 	trap	3
81104f44:	dfc00415 	stw	ra,16(sp)
81104f48:	df000315 	stw	fp,12(sp)
81104f4c:	df000304 	addi	fp,sp,12
81104f50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f54:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104f58:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104f5c:	e0bfff17 	ldw	r2,-4(fp)
81104f60:	10002026 	beq	r2,zero,81104fe4 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f64:	e0bfff17 	ldw	r2,-4(fp)
81104f68:	10800017 	ldw	r2,0(r2)
81104f6c:	01400384 	movi	r5,14
81104f70:	1009883a 	mov	r4,r2
81104f74:	11052200 	call	81105220 <uliDpktReadReg>
81104f78:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104f7c:	e0bffe17 	ldw	r2,-8(fp)
81104f80:	1007883a 	mov	r3,r2
81104f84:	e0bfff17 	ldw	r2,-4(fp)
81104f88:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f8c:	e0bfff17 	ldw	r2,-4(fp)
81104f90:	10800017 	ldw	r2,0(r2)
81104f94:	014003c4 	movi	r5,15
81104f98:	1009883a 	mov	r4,r2
81104f9c:	11052200 	call	81105220 <uliDpktReadReg>
81104fa0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104fa4:	e0bffe17 	ldw	r2,-8(fp)
81104fa8:	1007883a 	mov	r3,r2
81104fac:	e0bfff17 	ldw	r2,-4(fp)
81104fb0:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104fb4:	e0bfff17 	ldw	r2,-4(fp)
81104fb8:	10800017 	ldw	r2,0(r2)
81104fbc:	01400404 	movi	r5,16
81104fc0:	1009883a 	mov	r4,r2
81104fc4:	11052200 	call	81105220 <uliDpktReadReg>
81104fc8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104fcc:	e0bffe17 	ldw	r2,-8(fp)
81104fd0:	1007883a 	mov	r3,r2
81104fd4:	e0bfff17 	ldw	r2,-4(fp)
81104fd8:	10c0078d 	sth	r3,30(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104fdc:	00800044 	movi	r2,1
81104fe0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104fe4:	e0bffd17 	ldw	r2,-12(fp)
}
81104fe8:	e037883a 	mov	sp,fp
81104fec:	dfc00117 	ldw	ra,4(sp)
81104ff0:	df000017 	ldw	fp,0(sp)
81104ff4:	dec00204 	addi	sp,sp,8
81104ff8:	f800283a 	ret

81104ffc <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104ffc:	defff904 	addi	sp,sp,-28
81105000:	de00012e 	bgeu	sp,et,81105008 <bDpktInitCh+0xc>
81105004:	003b68fa 	trap	3
81105008:	dfc00615 	stw	ra,24(sp)
8110500c:	df000515 	stw	fp,20(sp)
81105010:	df000504 	addi	fp,sp,20
81105014:	e13ffe15 	stw	r4,-8(fp)
81105018:	2805883a 	mov	r2,r5
8110501c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105020:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
81105024:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
81105028:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
8110502c:	e0bffe17 	ldw	r2,-8(fp)
81105030:	10006026 	beq	r2,zero,811051b4 <bDpktInitCh+0x1b8>

		switch (ucCommCh) {
81105034:	e0bfff03 	ldbu	r2,-4(fp)
81105038:	10c00228 	cmpgeui	r3,r2,8
8110503c:	1800461e 	bne	r3,zero,81105158 <bDpktInitCh+0x15c>
81105040:	100690ba 	slli	r3,r2,2
81105044:	00a04434 	movhi	r2,33040
81105048:	10941604 	addi	r2,r2,20568
8110504c:	1885883a 	add	r2,r3,r2
81105050:	10800017 	ldw	r2,0(r2)
81105054:	1000683a 	jmp	r2
81105058:	81105078 	rdprs	r4,r16,16705
8110505c:	81105094 	ori	r4,r16,16706
81105060:	811050b0 	cmpltui	r4,r16,16706
81105064:	811050cc 	andi	r4,r16,16707
81105068:	811050e8 	cmpgeui	r4,r16,16707
8110506c:	81105104 	addi	r4,r16,16708
81105070:	81105120 	cmpeqi	r4,r16,16708
81105074:	8110513c 	xorhi	r4,r16,16708
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105078:	e0fffe17 	ldw	r3,-8(fp)
8110507c:	00a04834 	movhi	r2,33056
81105080:	108b0004 	addi	r2,r2,11264
81105084:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81105088:	00800044 	movi	r2,1
8110508c:	e0bffc15 	stw	r2,-16(fp)
			break;
81105090:	00003306 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105094:	e0fffe17 	ldw	r3,-8(fp)
81105098:	00a04834 	movhi	r2,33056
8110509c:	108a0004 	addi	r2,r2,10240
811050a0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050a4:	00800044 	movi	r2,1
811050a8:	e0bffc15 	stw	r2,-16(fp)
			break;
811050ac:	00002c06 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811050b0:	e0fffe17 	ldw	r3,-8(fp)
811050b4:	00a04834 	movhi	r2,33056
811050b8:	108b0004 	addi	r2,r2,11264
811050bc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050c0:	00800044 	movi	r2,1
811050c4:	e0bffc15 	stw	r2,-16(fp)
			break;
811050c8:	00002506 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811050cc:	e0fffe17 	ldw	r3,-8(fp)
811050d0:	00a04834 	movhi	r2,33056
811050d4:	108a0004 	addi	r2,r2,10240
811050d8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050dc:	00800044 	movi	r2,1
811050e0:	e0bffc15 	stw	r2,-16(fp)
			break;
811050e4:	00001e06 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811050e8:	e0fffe17 	ldw	r3,-8(fp)
811050ec:	00a04834 	movhi	r2,33056
811050f0:	108b0004 	addi	r2,r2,11264
811050f4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050f8:	00800044 	movi	r2,1
811050fc:	e0bffc15 	stw	r2,-16(fp)
			break;
81105100:	00001706 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81105104:	e0fffe17 	ldw	r3,-8(fp)
81105108:	00a04834 	movhi	r2,33056
8110510c:	108a0004 	addi	r2,r2,10240
81105110:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81105114:	00800044 	movi	r2,1
81105118:	e0bffc15 	stw	r2,-16(fp)
			break;
8110511c:	00001006 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105120:	e0fffe17 	ldw	r3,-8(fp)
81105124:	00a04834 	movhi	r2,33056
81105128:	108b0004 	addi	r2,r2,11264
8110512c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81105130:	00800044 	movi	r2,1
81105134:	e0bffc15 	stw	r2,-16(fp)
			break;
81105138:	00000906 	br	81105160 <bDpktInitCh+0x164>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110513c:	e0fffe17 	ldw	r3,-8(fp)
81105140:	00a04834 	movhi	r2,33056
81105144:	108a0004 	addi	r2,r2,10240
81105148:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110514c:	00800044 	movi	r2,1
81105150:	e0bffc15 	stw	r2,-16(fp)
			break;
81105154:	00000206 	br	81105160 <bDpktInitCh+0x164>
		default:
			bValidCh = FALSE;
81105158:	e03ffc15 	stw	zero,-16(fp)
			break;
8110515c:	0001883a 	nop
		}

		if (bValidCh) {
81105160:	e0bffc17 	ldw	r2,-16(fp)
81105164:	10001326 	beq	r2,zero,811051b4 <bDpktInitCh+0x1b8>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81105168:	e13ffe17 	ldw	r4,-8(fp)
8110516c:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
81105170:	1000021e 	bne	r2,zero,8110517c <bDpktInitCh+0x180>
				bInitFail = TRUE;
81105174:	00800044 	movi	r2,1
81105178:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
8110517c:	e13ffe17 	ldw	r4,-8(fp)
81105180:	1104d200 	call	81104d20 <bDpktGetPacketHeader>
81105184:	1000021e 	bne	r2,zero,81105190 <bDpktInitCh+0x194>
				bInitFail = TRUE;
81105188:	00800044 	movi	r2,1
8110518c:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81105190:	e13ffe17 	ldw	r4,-8(fp)
81105194:	1104f380 	call	81104f38 <bDpktGetPixelDelay>
81105198:	1000021e 	bne	r2,zero,811051a4 <bDpktInitCh+0x1a8>
				bInitFail = TRUE;
8110519c:	00800044 	movi	r2,1
811051a0:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
811051a4:	e0bffd17 	ldw	r2,-12(fp)
811051a8:	1000021e 	bne	r2,zero,811051b4 <bDpktInitCh+0x1b8>
				bStatus = TRUE;
811051ac:	00800044 	movi	r2,1
811051b0:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
811051b4:	e0bffb17 	ldw	r2,-20(fp)
}
811051b8:	e037883a 	mov	sp,fp
811051bc:	dfc00117 	ldw	ra,4(sp)
811051c0:	df000017 	ldw	fp,0(sp)
811051c4:	dec00204 	addi	sp,sp,8
811051c8:	f800283a 	ret

811051cc <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811051cc:	defffc04 	addi	sp,sp,-16
811051d0:	de00012e 	bgeu	sp,et,811051d8 <vDpktWriteReg+0xc>
811051d4:	003b68fa 	trap	3
811051d8:	df000315 	stw	fp,12(sp)
811051dc:	df000304 	addi	fp,sp,12
811051e0:	e13ffd15 	stw	r4,-12(fp)
811051e4:	e17ffe15 	stw	r5,-8(fp)
811051e8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811051ec:	e0bffe17 	ldw	r2,-8(fp)
811051f0:	1085883a 	add	r2,r2,r2
811051f4:	1085883a 	add	r2,r2,r2
811051f8:	1007883a 	mov	r3,r2
811051fc:	e0bffd17 	ldw	r2,-12(fp)
81105200:	10c5883a 	add	r2,r2,r3
81105204:	e0ffff17 	ldw	r3,-4(fp)
81105208:	10c00015 	stw	r3,0(r2)
}
8110520c:	0001883a 	nop
81105210:	e037883a 	mov	sp,fp
81105214:	df000017 	ldw	fp,0(sp)
81105218:	dec00104 	addi	sp,sp,4
8110521c:	f800283a 	ret

81105220 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105220:	defffc04 	addi	sp,sp,-16
81105224:	de00012e 	bgeu	sp,et,8110522c <uliDpktReadReg+0xc>
81105228:	003b68fa 	trap	3
8110522c:	df000315 	stw	fp,12(sp)
81105230:	df000304 	addi	fp,sp,12
81105234:	e13ffe15 	stw	r4,-8(fp)
81105238:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110523c:	e0bfff17 	ldw	r2,-4(fp)
81105240:	1085883a 	add	r2,r2,r2
81105244:	1085883a 	add	r2,r2,r2
81105248:	1007883a 	mov	r3,r2
8110524c:	e0bffe17 	ldw	r2,-8(fp)
81105250:	10c5883a 	add	r2,r2,r3
81105254:	10800017 	ldw	r2,0(r2)
81105258:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110525c:	e0bffd17 	ldw	r2,-12(fp)
}
81105260:	e037883a 	mov	sp,fp
81105264:	df000017 	ldw	fp,0(sp)
81105268:	dec00104 	addi	sp,sp,4
8110526c:	f800283a 	ret

81105270 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105270:	defffc04 	addi	sp,sp,-16
81105274:	de00012e 	bgeu	sp,et,8110527c <usiAdcPxDelayCalcPeriodNs+0xc>
81105278:	003b68fa 	trap	3
8110527c:	dfc00315 	stw	ra,12(sp)
81105280:	df000215 	stw	fp,8(sp)
81105284:	df000204 	addi	fp,sp,8
81105288:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
8110528c:	e13fff17 	ldw	r4,-4(fp)
81105290:	1121e5c0 	call	81121e5c <__floatunsisf>
81105294:	1007883a 	mov	r3,r2
81105298:	1809883a 	mov	r4,r3
8110529c:	11231b80 	call	811231b8 <__extendsfdf2>
811052a0:	1011883a 	mov	r8,r2
811052a4:	1813883a 	mov	r9,r3
811052a8:	01a666b4 	movhi	r6,39322
811052ac:	31a66684 	addi	r6,r6,-26214
811052b0:	01cfeeb4 	movhi	r7,16314
811052b4:	39e66644 	addi	r7,r7,-26215
811052b8:	4009883a 	mov	r4,r8
811052bc:	480b883a 	mov	r5,r9
811052c0:	11220300 	call	81122030 <__muldf3>
811052c4:	1009883a 	mov	r4,r2
811052c8:	180b883a 	mov	r5,r3
811052cc:	2005883a 	mov	r2,r4
811052d0:	2807883a 	mov	r3,r5
811052d4:	1009883a 	mov	r4,r2
811052d8:	180b883a 	mov	r5,r3
811052dc:	11214680 	call	81121468 <__fixunsdfsi>
811052e0:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811052e4:	e0bffe0b 	ldhu	r2,-8(fp)
}
811052e8:	e037883a 	mov	sp,fp
811052ec:	dfc00117 	ldw	ra,4(sp)
811052f0:	df000017 	ldw	fp,0(sp)
811052f4:	dec00204 	addi	sp,sp,8
811052f8:	f800283a 	ret

811052fc <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
811052fc:	defffc04 	addi	sp,sp,-16
81105300:	de00012e 	bgeu	sp,et,81105308 <usiLineTrDelayCalcPeriodNs+0xc>
81105304:	003b68fa 	trap	3
81105308:	dfc00315 	stw	ra,12(sp)
8110530c:	df000215 	stw	fp,8(sp)
81105310:	df000204 	addi	fp,sp,8
81105314:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105318:	e13fff17 	ldw	r4,-4(fp)
8110531c:	1121e5c0 	call	81121e5c <__floatunsisf>
81105320:	1007883a 	mov	r3,r2
81105324:	1809883a 	mov	r4,r3
81105328:	11231b80 	call	811231b8 <__extendsfdf2>
8110532c:	1011883a 	mov	r8,r2
81105330:	1813883a 	mov	r9,r3
81105334:	0191ebb4 	movhi	r6,18350
81105338:	31851ec4 	addi	r6,r6,5243
8110533c:	01cfe134 	movhi	r7,16260
81105340:	39deb844 	addi	r7,r7,31457
81105344:	4009883a 	mov	r4,r8
81105348:	480b883a 	mov	r5,r9
8110534c:	11220300 	call	81122030 <__muldf3>
81105350:	1009883a 	mov	r4,r2
81105354:	180b883a 	mov	r5,r3
81105358:	2005883a 	mov	r2,r4
8110535c:	2807883a 	mov	r3,r5
81105360:	1009883a 	mov	r4,r2
81105364:	180b883a 	mov	r5,r3
81105368:	11214680 	call	81121468 <__fixunsdfsi>
8110536c:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105370:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105374:	e037883a 	mov	sp,fp
81105378:	dfc00117 	ldw	ra,4(sp)
8110537c:	df000017 	ldw	fp,0(sp)
81105380:	dec00204 	addi	sp,sp,8
81105384:	f800283a 	ret

81105388 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105388:	defffb04 	addi	sp,sp,-20
8110538c:	de00012e 	bgeu	sp,et,81105394 <vFeebCh1HandleIrq+0xc>
81105390:	003b68fa 	trap	3
81105394:	dfc00415 	stw	ra,16(sp)
81105398:	df000315 	stw	fp,12(sp)
8110539c:	df000304 	addi	fp,sp,12
811053a0:	e13fff15 	stw	r4,-4(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
811053a4:	11059040 	call	81105904 <vFeebCh1IrqFlagClrBufferEmpty>



	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811053a8:	00800404 	movi	r2,16
811053ac:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811053b0:	00bfe004 	movi	r2,-128
811053b4:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811053b8:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 0;
811053bc:	e03ffe05 	stb	zero,-8(fp)


	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811053c0:	d0a05d17 	ldw	r2,-32396(gp)
811053c4:	e0fffe17 	ldw	r3,-8(fp)
811053c8:	180b883a 	mov	r5,r3
811053cc:	1009883a 	mov	r4,r2
811053d0:	114001c0 	call	8114001c <OSQPost>
811053d4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811053d8:	e0bffd03 	ldbu	r2,-12(fp)
811053dc:	10000226 	beq	r2,zero,811053e8 <vFeebCh1HandleIrq+0x60>
		vFailRequestDMAFromIRQ( 0 );
811053e0:	0009883a 	mov	r4,zero
811053e4:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}



#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811053e8:	00a045f4 	movhi	r2,33047
811053ec:	10a34f04 	addi	r2,r2,-29380
811053f0:	10800a8b 	ldhu	r2,42(r2)
811053f4:	10bfffcc 	andi	r2,r2,65535
811053f8:	108000e8 	cmpgeui	r2,r2,3
811053fc:	1000071e 	bne	r2,zero,8110541c <vFeebCh1HandleIrq+0x94>
		fprintf(fp,"IntF0\n");
81105400:	d0a06217 	ldw	r2,-32376(gp)
81105404:	100f883a 	mov	r7,r2
81105408:	01800184 	movi	r6,6
8110540c:	01400044 	movi	r5,1
81105410:	01204574 	movhi	r4,33045
81105414:	21391204 	addi	r4,r4,-7096
81105418:	1123cec0 	call	81123cec <fwrite>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
8110541c:	0001883a 	nop
81105420:	e037883a 	mov	sp,fp
81105424:	dfc00117 	ldw	ra,4(sp)
81105428:	df000017 	ldw	fp,0(sp)
8110542c:	dec00204 	addi	sp,sp,8
81105430:	f800283a 	ret

81105434 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81105434:	defffb04 	addi	sp,sp,-20
81105438:	de00012e 	bgeu	sp,et,81105440 <vFeebCh2HandleIrq+0xc>
8110543c:	003b68fa 	trap	3
81105440:	dfc00415 	stw	ra,16(sp)
81105444:	df000315 	stw	fp,12(sp)
81105448:	df000304 	addi	fp,sp,12
8110544c:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
81105450:	11059480 	call	81105948 <vFeebCh2IrqFlagClrBufferEmpty>



	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105454:	00800404 	movi	r2,16
81105458:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110545c:	00bfe004 	movi	r2,-128
81105460:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105464:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
81105468:	00800044 	movi	r2,1
8110546c:	e0bffe05 	stb	r2,-8(fp)

	 /*Sync the Meb task and tell that has a PUS command waiting*/
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105470:	d0a05d17 	ldw	r2,-32396(gp)
81105474:	e0fffe17 	ldw	r3,-8(fp)
81105478:	180b883a 	mov	r5,r3
8110547c:	1009883a 	mov	r4,r2
81105480:	114001c0 	call	8114001c <OSQPost>
81105484:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105488:	e0bffd03 	ldbu	r2,-12(fp)
8110548c:	10000226 	beq	r2,zero,81105498 <vFeebCh2HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 1 );
81105490:	01000044 	movi	r4,1
81105494:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81105498:	00a045f4 	movhi	r2,33047
8110549c:	10a34f04 	addi	r2,r2,-29380
811054a0:	10800a8b 	ldhu	r2,42(r2)
811054a4:	10bfffcc 	andi	r2,r2,65535
811054a8:	108000e8 	cmpgeui	r2,r2,3
811054ac:	1000071e 	bne	r2,zero,811054cc <vFeebCh2HandleIrq+0x98>
		fprintf(fp,"IntF1\n");
811054b0:	d0a06217 	ldw	r2,-32376(gp)
811054b4:	100f883a 	mov	r7,r2
811054b8:	01800184 	movi	r6,6
811054bc:	01400044 	movi	r5,1
811054c0:	01204574 	movhi	r4,33045
811054c4:	21391404 	addi	r4,r4,-7088
811054c8:	1123cec0 	call	81123cec <fwrite>
	}
#endif

}
811054cc:	0001883a 	nop
811054d0:	e037883a 	mov	sp,fp
811054d4:	dfc00117 	ldw	ra,4(sp)
811054d8:	df000017 	ldw	fp,0(sp)
811054dc:	dec00204 	addi	sp,sp,8
811054e0:	f800283a 	ret

811054e4 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811054e4:	defffb04 	addi	sp,sp,-20
811054e8:	de00012e 	bgeu	sp,et,811054f0 <vFeebCh3HandleIrq+0xc>
811054ec:	003b68fa 	trap	3
811054f0:	dfc00415 	stw	ra,16(sp)
811054f4:	df000315 	stw	fp,12(sp)
811054f8:	df000304 	addi	fp,sp,12
811054fc:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	INT8U error_codel;
	tQMask uiCmdtoSend;


	vFeebCh3IrqFlagClrBufferEmpty();
81105500:	110598c0 	call	8110598c <vFeebCh3IrqFlagClrBufferEmpty>

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105504:	00800404 	movi	r2,16
81105508:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110550c:	00bfe004 	movi	r2,-128
81105510:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105514:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81105518:	00800084 	movi	r2,2
8110551c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105520:	d0a05d17 	ldw	r2,-32396(gp)
81105524:	e0fffe17 	ldw	r3,-8(fp)
81105528:	180b883a 	mov	r5,r3
8110552c:	1009883a 	mov	r4,r2
81105530:	114001c0 	call	8114001c <OSQPost>
81105534:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105538:	e0bffd03 	ldbu	r2,-12(fp)
8110553c:	10000226 	beq	r2,zero,81105548 <vFeebCh3HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 2 );
81105540:	01000084 	movi	r4,2
81105544:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81105548:	00a045f4 	movhi	r2,33047
8110554c:	10a34f04 	addi	r2,r2,-29380
81105550:	10800a8b 	ldhu	r2,42(r2)
81105554:	10bfffcc 	andi	r2,r2,65535
81105558:	108000e8 	cmpgeui	r2,r2,3
8110555c:	1000071e 	bne	r2,zero,8110557c <vFeebCh3HandleIrq+0x98>
		fprintf(fp,"IntF2\n");
81105560:	d0a06217 	ldw	r2,-32376(gp)
81105564:	100f883a 	mov	r7,r2
81105568:	01800184 	movi	r6,6
8110556c:	01400044 	movi	r5,1
81105570:	01204574 	movhi	r4,33045
81105574:	21391604 	addi	r4,r4,-7080
81105578:	1123cec0 	call	81123cec <fwrite>
	}
#endif
}
8110557c:	0001883a 	nop
81105580:	e037883a 	mov	sp,fp
81105584:	dfc00117 	ldw	ra,4(sp)
81105588:	df000017 	ldw	fp,0(sp)
8110558c:	dec00204 	addi	sp,sp,8
81105590:	f800283a 	ret

81105594 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105594:	defffb04 	addi	sp,sp,-20
81105598:	de00012e 	bgeu	sp,et,811055a0 <vFeebCh4HandleIrq+0xc>
8110559c:	003b68fa 	trap	3
811055a0:	dfc00415 	stw	ra,16(sp)
811055a4:	df000315 	stw	fp,12(sp)
811055a8:	df000304 	addi	fp,sp,12
811055ac:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	INT8U error_codel;
	tQMask uiCmdtoSend;


	vFeebCh4IrqFlagClrBufferEmpty();
811055b0:	11059d00 	call	811059d0 <vFeebCh4IrqFlagClrBufferEmpty>

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811055b4:	00800404 	movi	r2,16
811055b8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811055bc:	00bfe004 	movi	r2,-128
811055c0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811055c4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
811055c8:	008000c4 	movi	r2,3
811055cc:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811055d0:	d0a05d17 	ldw	r2,-32396(gp)
811055d4:	e0fffe17 	ldw	r3,-8(fp)
811055d8:	180b883a 	mov	r5,r3
811055dc:	1009883a 	mov	r4,r2
811055e0:	114001c0 	call	8114001c <OSQPost>
811055e4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811055e8:	e0bffd03 	ldbu	r2,-12(fp)
811055ec:	10000226 	beq	r2,zero,811055f8 <vFeebCh4HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 3 );
811055f0:	010000c4 	movi	r4,3
811055f4:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811055f8:	00a045f4 	movhi	r2,33047
811055fc:	10a34f04 	addi	r2,r2,-29380
81105600:	10800a8b 	ldhu	r2,42(r2)
81105604:	10bfffcc 	andi	r2,r2,65535
81105608:	108000e8 	cmpgeui	r2,r2,3
8110560c:	1000071e 	bne	r2,zero,8110562c <vFeebCh4HandleIrq+0x98>
		fprintf(fp,"IntF3\n");
81105610:	d0a06217 	ldw	r2,-32376(gp)
81105614:	100f883a 	mov	r7,r2
81105618:	01800184 	movi	r6,6
8110561c:	01400044 	movi	r5,1
81105620:	01204574 	movhi	r4,33045
81105624:	21391804 	addi	r4,r4,-7072
81105628:	1123cec0 	call	81123cec <fwrite>
	}
#endif
}
8110562c:	0001883a 	nop
81105630:	e037883a 	mov	sp,fp
81105634:	dfc00117 	ldw	ra,4(sp)
81105638:	df000017 	ldw	fp,0(sp)
8110563c:	dec00204 	addi	sp,sp,8
81105640:	f800283a 	ret

81105644 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105644:	defffb04 	addi	sp,sp,-20
81105648:	de00012e 	bgeu	sp,et,81105650 <vFeebCh5HandleIrq+0xc>
8110564c:	003b68fa 	trap	3
81105650:	dfc00415 	stw	ra,16(sp)
81105654:	df000315 	stw	fp,12(sp)
81105658:	df000304 	addi	fp,sp,12
8110565c:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh5IrqFlagClrBufferEmpty();
81105660:	1105a140 	call	81105a14 <vFeebCh5IrqFlagClrBufferEmpty>

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105664:	00800404 	movi	r2,16
81105668:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110566c:	00bfe004 	movi	r2,-128
81105670:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105674:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81105678:	00800104 	movi	r2,4
8110567c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105680:	d0a05d17 	ldw	r2,-32396(gp)
81105684:	e0fffe17 	ldw	r3,-8(fp)
81105688:	180b883a 	mov	r5,r3
8110568c:	1009883a 	mov	r4,r2
81105690:	114001c0 	call	8114001c <OSQPost>
81105694:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105698:	e0bffd03 	ldbu	r2,-12(fp)
8110569c:	10000226 	beq	r2,zero,811056a8 <vFeebCh5HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 4 );
811056a0:	01000104 	movi	r4,4
811056a4:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811056a8:	00a045f4 	movhi	r2,33047
811056ac:	10a34f04 	addi	r2,r2,-29380
811056b0:	10800a8b 	ldhu	r2,42(r2)
811056b4:	10bfffcc 	andi	r2,r2,65535
811056b8:	108000e8 	cmpgeui	r2,r2,3
811056bc:	1000071e 	bne	r2,zero,811056dc <vFeebCh5HandleIrq+0x98>
		fprintf(fp,"IntF4\n");
811056c0:	d0a06217 	ldw	r2,-32376(gp)
811056c4:	100f883a 	mov	r7,r2
811056c8:	01800184 	movi	r6,6
811056cc:	01400044 	movi	r5,1
811056d0:	01204574 	movhi	r4,33045
811056d4:	21391a04 	addi	r4,r4,-7064
811056d8:	1123cec0 	call	81123cec <fwrite>
	}
#endif

}
811056dc:	0001883a 	nop
811056e0:	e037883a 	mov	sp,fp
811056e4:	dfc00117 	ldw	ra,4(sp)
811056e8:	df000017 	ldw	fp,0(sp)
811056ec:	dec00204 	addi	sp,sp,8
811056f0:	f800283a 	ret

811056f4 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811056f4:	defffb04 	addi	sp,sp,-20
811056f8:	de00012e 	bgeu	sp,et,81105700 <vFeebCh6HandleIrq+0xc>
811056fc:	003b68fa 	trap	3
81105700:	dfc00415 	stw	ra,16(sp)
81105704:	df000315 	stw	fp,12(sp)
81105708:	df000304 	addi	fp,sp,12
8110570c:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh6IrqFlagClrBufferEmpty();
81105710:	1105a580 	call	81105a58 <vFeebCh6IrqFlagClrBufferEmpty>

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105714:	00800404 	movi	r2,16
81105718:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110571c:	00bfe004 	movi	r2,-128
81105720:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105724:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
81105728:	00800144 	movi	r2,5
8110572c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105730:	d0a05d17 	ldw	r2,-32396(gp)
81105734:	e0fffe17 	ldw	r3,-8(fp)
81105738:	180b883a 	mov	r5,r3
8110573c:	1009883a 	mov	r4,r2
81105740:	114001c0 	call	8114001c <OSQPost>
81105744:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105748:	e0bffd03 	ldbu	r2,-12(fp)
8110574c:	10000226 	beq	r2,zero,81105758 <vFeebCh6HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 5 );
81105750:	01000144 	movi	r4,5
81105754:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81105758:	00a045f4 	movhi	r2,33047
8110575c:	10a34f04 	addi	r2,r2,-29380
81105760:	10800a8b 	ldhu	r2,42(r2)
81105764:	10bfffcc 	andi	r2,r2,65535
81105768:	108000e8 	cmpgeui	r2,r2,3
8110576c:	1000071e 	bne	r2,zero,8110578c <vFeebCh6HandleIrq+0x98>
		fprintf(fp,"IntF5\n");
81105770:	d0a06217 	ldw	r2,-32376(gp)
81105774:	100f883a 	mov	r7,r2
81105778:	01800184 	movi	r6,6
8110577c:	01400044 	movi	r5,1
81105780:	01204574 	movhi	r4,33045
81105784:	21391c04 	addi	r4,r4,-7056
81105788:	1123cec0 	call	81123cec <fwrite>
	}
#endif

}
8110578c:	0001883a 	nop
81105790:	e037883a 	mov	sp,fp
81105794:	dfc00117 	ldw	ra,4(sp)
81105798:	df000017 	ldw	fp,0(sp)
8110579c:	dec00204 	addi	sp,sp,8
811057a0:	f800283a 	ret

811057a4 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811057a4:	defffb04 	addi	sp,sp,-20
811057a8:	de00012e 	bgeu	sp,et,811057b0 <vFeebCh7HandleIrq+0xc>
811057ac:	003b68fa 	trap	3
811057b0:	dfc00415 	stw	ra,16(sp)
811057b4:	df000315 	stw	fp,12(sp)
811057b8:	df000304 	addi	fp,sp,12
811057bc:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh7IrqFlagClrBufferEmpty();
811057c0:	1105a9c0 	call	81105a9c <vFeebCh7IrqFlagClrBufferEmpty>

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811057c4:	00800404 	movi	r2,16
811057c8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811057cc:	00bfe004 	movi	r2,-128
811057d0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811057d4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 6;
811057d8:	00800184 	movi	r2,6
811057dc:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811057e0:	d0a05d17 	ldw	r2,-32396(gp)
811057e4:	e0fffe17 	ldw	r3,-8(fp)
811057e8:	180b883a 	mov	r5,r3
811057ec:	1009883a 	mov	r4,r2
811057f0:	114001c0 	call	8114001c <OSQPost>
811057f4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811057f8:	e0bffd03 	ldbu	r2,-12(fp)
811057fc:	10000226 	beq	r2,zero,81105808 <vFeebCh7HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 6 );
81105800:	01000184 	movi	r4,6
81105804:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81105808:	00a045f4 	movhi	r2,33047
8110580c:	10a34f04 	addi	r2,r2,-29380
81105810:	10800a8b 	ldhu	r2,42(r2)
81105814:	10bfffcc 	andi	r2,r2,65535
81105818:	108000e8 	cmpgeui	r2,r2,3
8110581c:	1000071e 	bne	r2,zero,8110583c <vFeebCh7HandleIrq+0x98>
		fprintf(fp,"IntF6\n");
81105820:	d0a06217 	ldw	r2,-32376(gp)
81105824:	100f883a 	mov	r7,r2
81105828:	01800184 	movi	r6,6
8110582c:	01400044 	movi	r5,1
81105830:	01204574 	movhi	r4,33045
81105834:	21391e04 	addi	r4,r4,-7048
81105838:	1123cec0 	call	81123cec <fwrite>
	}
#endif


}
8110583c:	0001883a 	nop
81105840:	e037883a 	mov	sp,fp
81105844:	dfc00117 	ldw	ra,4(sp)
81105848:	df000017 	ldw	fp,0(sp)
8110584c:	dec00204 	addi	sp,sp,8
81105850:	f800283a 	ret

81105854 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105854:	defffb04 	addi	sp,sp,-20
81105858:	de00012e 	bgeu	sp,et,81105860 <vFeebCh8HandleIrq+0xc>
8110585c:	003b68fa 	trap	3
81105860:	dfc00415 	stw	ra,16(sp)
81105864:	df000315 	stw	fp,12(sp)
81105868:	df000304 	addi	fp,sp,12
8110586c:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh8IrqFlagClrBufferEmpty();
81105870:	1105ae00 	call	81105ae0 <vFeebCh8IrqFlagClrBufferEmpty>

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105874:	00800404 	movi	r2,16
81105878:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110587c:	00bfe004 	movi	r2,-128
81105880:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105884:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 7;
81105888:	008001c4 	movi	r2,7
8110588c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105890:	d0a05d17 	ldw	r2,-32396(gp)
81105894:	e0fffe17 	ldw	r3,-8(fp)
81105898:	180b883a 	mov	r5,r3
8110589c:	1009883a 	mov	r4,r2
811058a0:	114001c0 	call	8114001c <OSQPost>
811058a4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811058a8:	e0bffd03 	ldbu	r2,-12(fp)
811058ac:	10000226 	beq	r2,zero,811058b8 <vFeebCh8HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 7 );
811058b0:	010001c4 	movi	r4,7
811058b4:	111f4340 	call	8111f434 <vFailRequestDMAFromIRQ>
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811058b8:	00a045f4 	movhi	r2,33047
811058bc:	10a34f04 	addi	r2,r2,-29380
811058c0:	10800a8b 	ldhu	r2,42(r2)
811058c4:	10bfffcc 	andi	r2,r2,65535
811058c8:	108000e8 	cmpgeui	r2,r2,3
811058cc:	1000071e 	bne	r2,zero,811058ec <vFeebCh8HandleIrq+0x98>
		fprintf(fp,"IntF7\n");
811058d0:	d0a06217 	ldw	r2,-32376(gp)
811058d4:	100f883a 	mov	r7,r2
811058d8:	01800184 	movi	r6,6
811058dc:	01400044 	movi	r5,1
811058e0:	01204574 	movhi	r4,33045
811058e4:	21392004 	addi	r4,r4,-7040
811058e8:	1123cec0 	call	81123cec <fwrite>
	}
#endif

}
811058ec:	0001883a 	nop
811058f0:	e037883a 	mov	sp,fp
811058f4:	dfc00117 	ldw	ra,4(sp)
811058f8:	df000017 	ldw	fp,0(sp)
811058fc:	dec00204 	addi	sp,sp,8
81105900:	f800283a 	ret

81105904 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105904:	defffe04 	addi	sp,sp,-8
81105908:	de00012e 	bgeu	sp,et,81105910 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
8110590c:	003b68fa 	trap	3
81105910:	dfc00115 	stw	ra,4(sp)
81105914:	df000015 	stw	fp,0(sp)
81105918:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110591c:	01804004 	movi	r6,256
81105920:	014004c4 	movi	r5,19
81105924:	01204834 	movhi	r4,33056
81105928:	210b0004 	addi	r4,r4,11264
8110592c:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105930:	0001883a 	nop
81105934:	e037883a 	mov	sp,fp
81105938:	dfc00117 	ldw	ra,4(sp)
8110593c:	df000017 	ldw	fp,0(sp)
81105940:	dec00204 	addi	sp,sp,8
81105944:	f800283a 	ret

81105948 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81105948:	defffe04 	addi	sp,sp,-8
8110594c:	de00012e 	bgeu	sp,et,81105954 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105950:	003b68fa 	trap	3
81105954:	dfc00115 	stw	ra,4(sp)
81105958:	df000015 	stw	fp,0(sp)
8110595c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105960:	01804004 	movi	r6,256
81105964:	014004c4 	movi	r5,19
81105968:	01204834 	movhi	r4,33056
8110596c:	210a0004 	addi	r4,r4,10240
81105970:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105974:	0001883a 	nop
81105978:	e037883a 	mov	sp,fp
8110597c:	dfc00117 	ldw	ra,4(sp)
81105980:	df000017 	ldw	fp,0(sp)
81105984:	dec00204 	addi	sp,sp,8
81105988:	f800283a 	ret

8110598c <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
8110598c:	defffe04 	addi	sp,sp,-8
81105990:	de00012e 	bgeu	sp,et,81105998 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81105994:	003b68fa 	trap	3
81105998:	dfc00115 	stw	ra,4(sp)
8110599c:	df000015 	stw	fp,0(sp)
811059a0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811059a4:	01804004 	movi	r6,256
811059a8:	014004c4 	movi	r5,19
811059ac:	01204834 	movhi	r4,33056
811059b0:	210b0004 	addi	r4,r4,11264
811059b4:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811059b8:	0001883a 	nop
811059bc:	e037883a 	mov	sp,fp
811059c0:	dfc00117 	ldw	ra,4(sp)
811059c4:	df000017 	ldw	fp,0(sp)
811059c8:	dec00204 	addi	sp,sp,8
811059cc:	f800283a 	ret

811059d0 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811059d0:	defffe04 	addi	sp,sp,-8
811059d4:	de00012e 	bgeu	sp,et,811059dc <vFeebCh4IrqFlagClrBufferEmpty+0xc>
811059d8:	003b68fa 	trap	3
811059dc:	dfc00115 	stw	ra,4(sp)
811059e0:	df000015 	stw	fp,0(sp)
811059e4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811059e8:	01804004 	movi	r6,256
811059ec:	014004c4 	movi	r5,19
811059f0:	01204834 	movhi	r4,33056
811059f4:	210a0004 	addi	r4,r4,10240
811059f8:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811059fc:	0001883a 	nop
81105a00:	e037883a 	mov	sp,fp
81105a04:	dfc00117 	ldw	ra,4(sp)
81105a08:	df000017 	ldw	fp,0(sp)
81105a0c:	dec00204 	addi	sp,sp,8
81105a10:	f800283a 	ret

81105a14 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105a14:	defffe04 	addi	sp,sp,-8
81105a18:	de00012e 	bgeu	sp,et,81105a20 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105a1c:	003b68fa 	trap	3
81105a20:	dfc00115 	stw	ra,4(sp)
81105a24:	df000015 	stw	fp,0(sp)
81105a28:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105a2c:	01804004 	movi	r6,256
81105a30:	014004c4 	movi	r5,19
81105a34:	01204834 	movhi	r4,33056
81105a38:	210b0004 	addi	r4,r4,11264
81105a3c:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105a40:	0001883a 	nop
81105a44:	e037883a 	mov	sp,fp
81105a48:	dfc00117 	ldw	ra,4(sp)
81105a4c:	df000017 	ldw	fp,0(sp)
81105a50:	dec00204 	addi	sp,sp,8
81105a54:	f800283a 	ret

81105a58 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81105a58:	defffe04 	addi	sp,sp,-8
81105a5c:	de00012e 	bgeu	sp,et,81105a64 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81105a60:	003b68fa 	trap	3
81105a64:	dfc00115 	stw	ra,4(sp)
81105a68:	df000015 	stw	fp,0(sp)
81105a6c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105a70:	01804004 	movi	r6,256
81105a74:	014004c4 	movi	r5,19
81105a78:	01204834 	movhi	r4,33056
81105a7c:	210a0004 	addi	r4,r4,10240
81105a80:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105a84:	0001883a 	nop
81105a88:	e037883a 	mov	sp,fp
81105a8c:	dfc00117 	ldw	ra,4(sp)
81105a90:	df000017 	ldw	fp,0(sp)
81105a94:	dec00204 	addi	sp,sp,8
81105a98:	f800283a 	ret

81105a9c <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105a9c:	defffe04 	addi	sp,sp,-8
81105aa0:	de00012e 	bgeu	sp,et,81105aa8 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105aa4:	003b68fa 	trap	3
81105aa8:	dfc00115 	stw	ra,4(sp)
81105aac:	df000015 	stw	fp,0(sp)
81105ab0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105ab4:	01804004 	movi	r6,256
81105ab8:	014004c4 	movi	r5,19
81105abc:	01204834 	movhi	r4,33056
81105ac0:	210b0004 	addi	r4,r4,11264
81105ac4:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105ac8:	0001883a 	nop
81105acc:	e037883a 	mov	sp,fp
81105ad0:	dfc00117 	ldw	ra,4(sp)
81105ad4:	df000017 	ldw	fp,0(sp)
81105ad8:	dec00204 	addi	sp,sp,8
81105adc:	f800283a 	ret

81105ae0 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105ae0:	defffe04 	addi	sp,sp,-8
81105ae4:	de00012e 	bgeu	sp,et,81105aec <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105ae8:	003b68fa 	trap	3
81105aec:	dfc00115 	stw	ra,4(sp)
81105af0:	df000015 	stw	fp,0(sp)
81105af4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105af8:	01804004 	movi	r6,256
81105afc:	014004c4 	movi	r5,19
81105b00:	01204834 	movhi	r4,33056
81105b04:	210a0004 	addi	r4,r4,10240
81105b08:	11073e00 	call	811073e0 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105b0c:	0001883a 	nop
81105b10:	e037883a 	mov	sp,fp
81105b14:	dfc00117 	ldw	ra,4(sp)
81105b18:	df000017 	ldw	fp,0(sp)
81105b1c:	dec00204 	addi	sp,sp,8
81105b20:	f800283a 	ret

81105b24 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105b24:	defffd04 	addi	sp,sp,-12
81105b28:	de00012e 	bgeu	sp,et,81105b30 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105b2c:	003b68fa 	trap	3
81105b30:	dfc00215 	stw	ra,8(sp)
81105b34:	df000115 	stw	fp,4(sp)
81105b38:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105b3c:	01400484 	movi	r5,18
81105b40:	01204834 	movhi	r4,33056
81105b44:	210b0004 	addi	r4,r4,11264
81105b48:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105b4c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105b50:	10000326 	beq	r2,zero,81105b60 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105b54:	00800044 	movi	r2,1
81105b58:	e0bfff15 	stw	r2,-4(fp)
81105b5c:	00000106 	br	81105b64 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105b60:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105b64:	e0bfff17 	ldw	r2,-4(fp)
}
81105b68:	e037883a 	mov	sp,fp
81105b6c:	dfc00117 	ldw	ra,4(sp)
81105b70:	df000017 	ldw	fp,0(sp)
81105b74:	dec00204 	addi	sp,sp,8
81105b78:	f800283a 	ret

81105b7c <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81105b7c:	defffd04 	addi	sp,sp,-12
81105b80:	de00012e 	bgeu	sp,et,81105b88 <bFeebCh2IrqFlagBufferEmpty+0xc>
81105b84:	003b68fa 	trap	3
81105b88:	dfc00215 	stw	ra,8(sp)
81105b8c:	df000115 	stw	fp,4(sp)
81105b90:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105b94:	01400484 	movi	r5,18
81105b98:	01204834 	movhi	r4,33056
81105b9c:	210a0004 	addi	r4,r4,10240
81105ba0:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105ba4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105ba8:	10000326 	beq	r2,zero,81105bb8 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105bac:	00800044 	movi	r2,1
81105bb0:	e0bfff15 	stw	r2,-4(fp)
81105bb4:	00000106 	br	81105bbc <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105bb8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105bbc:	e0bfff17 	ldw	r2,-4(fp)
}
81105bc0:	e037883a 	mov	sp,fp
81105bc4:	dfc00117 	ldw	ra,4(sp)
81105bc8:	df000017 	ldw	fp,0(sp)
81105bcc:	dec00204 	addi	sp,sp,8
81105bd0:	f800283a 	ret

81105bd4 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105bd4:	defffd04 	addi	sp,sp,-12
81105bd8:	de00012e 	bgeu	sp,et,81105be0 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105bdc:	003b68fa 	trap	3
81105be0:	dfc00215 	stw	ra,8(sp)
81105be4:	df000115 	stw	fp,4(sp)
81105be8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105bec:	01400484 	movi	r5,18
81105bf0:	01204834 	movhi	r4,33056
81105bf4:	210b0004 	addi	r4,r4,11264
81105bf8:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105bfc:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105c00:	10000326 	beq	r2,zero,81105c10 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105c04:	00800044 	movi	r2,1
81105c08:	e0bfff15 	stw	r2,-4(fp)
81105c0c:	00000106 	br	81105c14 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105c10:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105c14:	e0bfff17 	ldw	r2,-4(fp)
}
81105c18:	e037883a 	mov	sp,fp
81105c1c:	dfc00117 	ldw	ra,4(sp)
81105c20:	df000017 	ldw	fp,0(sp)
81105c24:	dec00204 	addi	sp,sp,8
81105c28:	f800283a 	ret

81105c2c <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105c2c:	defffd04 	addi	sp,sp,-12
81105c30:	de00012e 	bgeu	sp,et,81105c38 <bFeebCh4IrqFlagBufferEmpty+0xc>
81105c34:	003b68fa 	trap	3
81105c38:	dfc00215 	stw	ra,8(sp)
81105c3c:	df000115 	stw	fp,4(sp)
81105c40:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105c44:	01400484 	movi	r5,18
81105c48:	01204834 	movhi	r4,33056
81105c4c:	210a0004 	addi	r4,r4,10240
81105c50:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105c54:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105c58:	10000326 	beq	r2,zero,81105c68 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105c5c:	00800044 	movi	r2,1
81105c60:	e0bfff15 	stw	r2,-4(fp)
81105c64:	00000106 	br	81105c6c <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105c68:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105c6c:	e0bfff17 	ldw	r2,-4(fp)
}
81105c70:	e037883a 	mov	sp,fp
81105c74:	dfc00117 	ldw	ra,4(sp)
81105c78:	df000017 	ldw	fp,0(sp)
81105c7c:	dec00204 	addi	sp,sp,8
81105c80:	f800283a 	ret

81105c84 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81105c84:	defffd04 	addi	sp,sp,-12
81105c88:	de00012e 	bgeu	sp,et,81105c90 <bFeebCh5IrqFlagBufferEmpty+0xc>
81105c8c:	003b68fa 	trap	3
81105c90:	dfc00215 	stw	ra,8(sp)
81105c94:	df000115 	stw	fp,4(sp)
81105c98:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105c9c:	01400484 	movi	r5,18
81105ca0:	01204834 	movhi	r4,33056
81105ca4:	210b0004 	addi	r4,r4,11264
81105ca8:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105cac:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105cb0:	10000326 	beq	r2,zero,81105cc0 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105cb4:	00800044 	movi	r2,1
81105cb8:	e0bfff15 	stw	r2,-4(fp)
81105cbc:	00000106 	br	81105cc4 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105cc0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105cc4:	e0bfff17 	ldw	r2,-4(fp)
}
81105cc8:	e037883a 	mov	sp,fp
81105ccc:	dfc00117 	ldw	ra,4(sp)
81105cd0:	df000017 	ldw	fp,0(sp)
81105cd4:	dec00204 	addi	sp,sp,8
81105cd8:	f800283a 	ret

81105cdc <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105cdc:	defffd04 	addi	sp,sp,-12
81105ce0:	de00012e 	bgeu	sp,et,81105ce8 <bFeebCh6IrqFlagBufferEmpty+0xc>
81105ce4:	003b68fa 	trap	3
81105ce8:	dfc00215 	stw	ra,8(sp)
81105cec:	df000115 	stw	fp,4(sp)
81105cf0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105cf4:	01400484 	movi	r5,18
81105cf8:	01204834 	movhi	r4,33056
81105cfc:	210a0004 	addi	r4,r4,10240
81105d00:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105d04:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105d08:	10000326 	beq	r2,zero,81105d18 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105d0c:	00800044 	movi	r2,1
81105d10:	e0bfff15 	stw	r2,-4(fp)
81105d14:	00000106 	br	81105d1c <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105d18:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105d1c:	e0bfff17 	ldw	r2,-4(fp)
}
81105d20:	e037883a 	mov	sp,fp
81105d24:	dfc00117 	ldw	ra,4(sp)
81105d28:	df000017 	ldw	fp,0(sp)
81105d2c:	dec00204 	addi	sp,sp,8
81105d30:	f800283a 	ret

81105d34 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105d34:	defffd04 	addi	sp,sp,-12
81105d38:	de00012e 	bgeu	sp,et,81105d40 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105d3c:	003b68fa 	trap	3
81105d40:	dfc00215 	stw	ra,8(sp)
81105d44:	df000115 	stw	fp,4(sp)
81105d48:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105d4c:	01400484 	movi	r5,18
81105d50:	01204834 	movhi	r4,33056
81105d54:	210b0004 	addi	r4,r4,11264
81105d58:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105d5c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105d60:	10000326 	beq	r2,zero,81105d70 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105d64:	00800044 	movi	r2,1
81105d68:	e0bfff15 	stw	r2,-4(fp)
81105d6c:	00000106 	br	81105d74 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105d70:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105d74:	e0bfff17 	ldw	r2,-4(fp)
}
81105d78:	e037883a 	mov	sp,fp
81105d7c:	dfc00117 	ldw	ra,4(sp)
81105d80:	df000017 	ldw	fp,0(sp)
81105d84:	dec00204 	addi	sp,sp,8
81105d88:	f800283a 	ret

81105d8c <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105d8c:	defffd04 	addi	sp,sp,-12
81105d90:	de00012e 	bgeu	sp,et,81105d98 <bFeebCh8IrqFlagBufferEmpty+0xc>
81105d94:	003b68fa 	trap	3
81105d98:	dfc00215 	stw	ra,8(sp)
81105d9c:	df000115 	stw	fp,4(sp)
81105da0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105da4:	01400484 	movi	r5,18
81105da8:	01204834 	movhi	r4,33056
81105dac:	210a0004 	addi	r4,r4,10240
81105db0:	11074340 	call	81107434 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105db4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105db8:	10000326 	beq	r2,zero,81105dc8 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105dbc:	00800044 	movi	r2,1
81105dc0:	e0bfff15 	stw	r2,-4(fp)
81105dc4:	00000106 	br	81105dcc <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105dc8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105dcc:	e0bfff17 	ldw	r2,-4(fp)
}
81105dd0:	e037883a 	mov	sp,fp
81105dd4:	dfc00117 	ldw	ra,4(sp)
81105dd8:	df000017 	ldw	fp,0(sp)
81105ddc:	dec00204 	addi	sp,sp,8
81105de0:	f800283a 	ret

81105de4 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105de4:	defffa04 	addi	sp,sp,-24
81105de8:	de00012e 	bgeu	sp,et,81105df0 <bFeebCh1SetBufferSize+0xc>
81105dec:	003b68fa 	trap	3
81105df0:	dfc00515 	stw	ra,20(sp)
81105df4:	df000415 	stw	fp,16(sp)
81105df8:	df000404 	addi	fp,sp,16
81105dfc:	2007883a 	mov	r3,r4
81105e00:	2805883a 	mov	r2,r5
81105e04:	e0fffe05 	stb	r3,-8(fp)
81105e08:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105e0c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105e10:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105e14:	e0bffe03 	ldbu	r2,-8(fp)
81105e18:	10002426 	beq	r2,zero,81105eac <bFeebCh1SetBufferSize+0xc8>
81105e1c:	e0bffe03 	ldbu	r2,-8(fp)
81105e20:	10800468 	cmpgeui	r2,r2,17
81105e24:	1000211e 	bne	r2,zero,81105eac <bFeebCh1SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105e28:	e0bfff03 	ldbu	r2,-4(fp)
81105e2c:	10000326 	beq	r2,zero,81105e3c <bFeebCh1SetBufferSize+0x58>
81105e30:	10800060 	cmpeqi	r2,r2,1
81105e34:	10000e1e 	bne	r2,zero,81105e70 <bFeebCh1SetBufferSize+0x8c>
81105e38:	00001a06 	br	81105ea4 <bFeebCh1SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e3c:	e0bffe03 	ldbu	r2,-8(fp)
81105e40:	10bfffc4 	addi	r2,r2,-1
81105e44:	108003cc 	andi	r2,r2,15
81105e48:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105e4c:	e0bffd17 	ldw	r2,-12(fp)
81105e50:	100d883a 	mov	r6,r2
81105e54:	01400544 	movi	r5,21
81105e58:	01204834 	movhi	r4,33056
81105e5c:	210b0004 	addi	r4,r4,11264
81105e60:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105e64:	00800044 	movi	r2,1
81105e68:	e0bffc15 	stw	r2,-16(fp)
			break;
81105e6c:	00000f06 	br	81105eac <bFeebCh1SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e70:	e0bffe03 	ldbu	r2,-8(fp)
81105e74:	10bfffc4 	addi	r2,r2,-1
81105e78:	108003cc 	andi	r2,r2,15
81105e7c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105e80:	e0bffd17 	ldw	r2,-12(fp)
81105e84:	100d883a 	mov	r6,r2
81105e88:	01400504 	movi	r5,20
81105e8c:	01204834 	movhi	r4,33056
81105e90:	210b0004 	addi	r4,r4,11264
81105e94:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105e98:	00800044 	movi	r2,1
81105e9c:	e0bffc15 	stw	r2,-16(fp)
			break;
81105ea0:	00000206 	br	81105eac <bFeebCh1SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105ea4:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ea8:	0001883a 	nop
		}
	}

	return bStatus;
81105eac:	e0bffc17 	ldw	r2,-16(fp)
}
81105eb0:	e037883a 	mov	sp,fp
81105eb4:	dfc00117 	ldw	ra,4(sp)
81105eb8:	df000017 	ldw	fp,0(sp)
81105ebc:	dec00204 	addi	sp,sp,8
81105ec0:	f800283a 	ret

81105ec4 <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105ec4:	defffa04 	addi	sp,sp,-24
81105ec8:	de00012e 	bgeu	sp,et,81105ed0 <bFeebCh2SetBufferSize+0xc>
81105ecc:	003b68fa 	trap	3
81105ed0:	dfc00515 	stw	ra,20(sp)
81105ed4:	df000415 	stw	fp,16(sp)
81105ed8:	df000404 	addi	fp,sp,16
81105edc:	2007883a 	mov	r3,r4
81105ee0:	2805883a 	mov	r2,r5
81105ee4:	e0fffe05 	stb	r3,-8(fp)
81105ee8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105eec:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105ef0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ef4:	e0bffe03 	ldbu	r2,-8(fp)
81105ef8:	10002426 	beq	r2,zero,81105f8c <bFeebCh2SetBufferSize+0xc8>
81105efc:	e0bffe03 	ldbu	r2,-8(fp)
81105f00:	10800468 	cmpgeui	r2,r2,17
81105f04:	1000211e 	bne	r2,zero,81105f8c <bFeebCh2SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105f08:	e0bfff03 	ldbu	r2,-4(fp)
81105f0c:	10000326 	beq	r2,zero,81105f1c <bFeebCh2SetBufferSize+0x58>
81105f10:	10800060 	cmpeqi	r2,r2,1
81105f14:	10000e1e 	bne	r2,zero,81105f50 <bFeebCh2SetBufferSize+0x8c>
81105f18:	00001a06 	br	81105f84 <bFeebCh2SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105f1c:	e0bffe03 	ldbu	r2,-8(fp)
81105f20:	10bfffc4 	addi	r2,r2,-1
81105f24:	108003cc 	andi	r2,r2,15
81105f28:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105f2c:	e0bffd17 	ldw	r2,-12(fp)
81105f30:	100d883a 	mov	r6,r2
81105f34:	01400544 	movi	r5,21
81105f38:	01204834 	movhi	r4,33056
81105f3c:	210a0004 	addi	r4,r4,10240
81105f40:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105f44:	00800044 	movi	r2,1
81105f48:	e0bffc15 	stw	r2,-16(fp)
			break;
81105f4c:	00000f06 	br	81105f8c <bFeebCh2SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105f50:	e0bffe03 	ldbu	r2,-8(fp)
81105f54:	10bfffc4 	addi	r2,r2,-1
81105f58:	108003cc 	andi	r2,r2,15
81105f5c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105f60:	e0bffd17 	ldw	r2,-12(fp)
81105f64:	100d883a 	mov	r6,r2
81105f68:	01400504 	movi	r5,20
81105f6c:	01204834 	movhi	r4,33056
81105f70:	210a0004 	addi	r4,r4,10240
81105f74:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105f78:	00800044 	movi	r2,1
81105f7c:	e0bffc15 	stw	r2,-16(fp)
			break;
81105f80:	00000206 	br	81105f8c <bFeebCh2SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105f84:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f88:	0001883a 	nop
		}
	}

	return bStatus;
81105f8c:	e0bffc17 	ldw	r2,-16(fp)
}
81105f90:	e037883a 	mov	sp,fp
81105f94:	dfc00117 	ldw	ra,4(sp)
81105f98:	df000017 	ldw	fp,0(sp)
81105f9c:	dec00204 	addi	sp,sp,8
81105fa0:	f800283a 	ret

81105fa4 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105fa4:	defffa04 	addi	sp,sp,-24
81105fa8:	de00012e 	bgeu	sp,et,81105fb0 <bFeebCh3SetBufferSize+0xc>
81105fac:	003b68fa 	trap	3
81105fb0:	dfc00515 	stw	ra,20(sp)
81105fb4:	df000415 	stw	fp,16(sp)
81105fb8:	df000404 	addi	fp,sp,16
81105fbc:	2007883a 	mov	r3,r4
81105fc0:	2805883a 	mov	r2,r5
81105fc4:	e0fffe05 	stb	r3,-8(fp)
81105fc8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105fcc:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105fd0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105fd4:	e0bffe03 	ldbu	r2,-8(fp)
81105fd8:	10002426 	beq	r2,zero,8110606c <bFeebCh3SetBufferSize+0xc8>
81105fdc:	e0bffe03 	ldbu	r2,-8(fp)
81105fe0:	10800468 	cmpgeui	r2,r2,17
81105fe4:	1000211e 	bne	r2,zero,8110606c <bFeebCh3SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105fe8:	e0bfff03 	ldbu	r2,-4(fp)
81105fec:	10000326 	beq	r2,zero,81105ffc <bFeebCh3SetBufferSize+0x58>
81105ff0:	10800060 	cmpeqi	r2,r2,1
81105ff4:	10000e1e 	bne	r2,zero,81106030 <bFeebCh3SetBufferSize+0x8c>
81105ff8:	00001a06 	br	81106064 <bFeebCh3SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ffc:	e0bffe03 	ldbu	r2,-8(fp)
81106000:	10bfffc4 	addi	r2,r2,-1
81106004:	108003cc 	andi	r2,r2,15
81106008:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110600c:	e0bffd17 	ldw	r2,-12(fp)
81106010:	100d883a 	mov	r6,r2
81106014:	01400544 	movi	r5,21
81106018:	01204834 	movhi	r4,33056
8110601c:	210b0004 	addi	r4,r4,11264
81106020:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106024:	00800044 	movi	r2,1
81106028:	e0bffc15 	stw	r2,-16(fp)
			break;
8110602c:	00000f06 	br	8110606c <bFeebCh3SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106030:	e0bffe03 	ldbu	r2,-8(fp)
81106034:	10bfffc4 	addi	r2,r2,-1
81106038:	108003cc 	andi	r2,r2,15
8110603c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106040:	e0bffd17 	ldw	r2,-12(fp)
81106044:	100d883a 	mov	r6,r2
81106048:	01400504 	movi	r5,20
8110604c:	01204834 	movhi	r4,33056
81106050:	210b0004 	addi	r4,r4,11264
81106054:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106058:	00800044 	movi	r2,1
8110605c:	e0bffc15 	stw	r2,-16(fp)
			break;
81106060:	00000206 	br	8110606c <bFeebCh3SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106064:	e03ffc15 	stw	zero,-16(fp)
			break;
81106068:	0001883a 	nop
		}
	}

	return bStatus;
8110606c:	e0bffc17 	ldw	r2,-16(fp)
}
81106070:	e037883a 	mov	sp,fp
81106074:	dfc00117 	ldw	ra,4(sp)
81106078:	df000017 	ldw	fp,0(sp)
8110607c:	dec00204 	addi	sp,sp,8
81106080:	f800283a 	ret

81106084 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106084:	defffa04 	addi	sp,sp,-24
81106088:	de00012e 	bgeu	sp,et,81106090 <bFeebCh4SetBufferSize+0xc>
8110608c:	003b68fa 	trap	3
81106090:	dfc00515 	stw	ra,20(sp)
81106094:	df000415 	stw	fp,16(sp)
81106098:	df000404 	addi	fp,sp,16
8110609c:	2007883a 	mov	r3,r4
811060a0:	2805883a 	mov	r2,r5
811060a4:	e0fffe05 	stb	r3,-8(fp)
811060a8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811060ac:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
811060b0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811060b4:	e0bffe03 	ldbu	r2,-8(fp)
811060b8:	10002426 	beq	r2,zero,8110614c <bFeebCh4SetBufferSize+0xc8>
811060bc:	e0bffe03 	ldbu	r2,-8(fp)
811060c0:	10800468 	cmpgeui	r2,r2,17
811060c4:	1000211e 	bne	r2,zero,8110614c <bFeebCh4SetBufferSize+0xc8>
		switch (ucBufferSide) {
811060c8:	e0bfff03 	ldbu	r2,-4(fp)
811060cc:	10000326 	beq	r2,zero,811060dc <bFeebCh4SetBufferSize+0x58>
811060d0:	10800060 	cmpeqi	r2,r2,1
811060d4:	10000e1e 	bne	r2,zero,81106110 <bFeebCh4SetBufferSize+0x8c>
811060d8:	00001a06 	br	81106144 <bFeebCh4SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811060dc:	e0bffe03 	ldbu	r2,-8(fp)
811060e0:	10bfffc4 	addi	r2,r2,-1
811060e4:	108003cc 	andi	r2,r2,15
811060e8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811060ec:	e0bffd17 	ldw	r2,-12(fp)
811060f0:	100d883a 	mov	r6,r2
811060f4:	01400544 	movi	r5,21
811060f8:	01204834 	movhi	r4,33056
811060fc:	210a0004 	addi	r4,r4,10240
81106100:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106104:	00800044 	movi	r2,1
81106108:	e0bffc15 	stw	r2,-16(fp)
			break;
8110610c:	00000f06 	br	8110614c <bFeebCh4SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106110:	e0bffe03 	ldbu	r2,-8(fp)
81106114:	10bfffc4 	addi	r2,r2,-1
81106118:	108003cc 	andi	r2,r2,15
8110611c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106120:	e0bffd17 	ldw	r2,-12(fp)
81106124:	100d883a 	mov	r6,r2
81106128:	01400504 	movi	r5,20
8110612c:	01204834 	movhi	r4,33056
81106130:	210a0004 	addi	r4,r4,10240
81106134:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106138:	00800044 	movi	r2,1
8110613c:	e0bffc15 	stw	r2,-16(fp)
			break;
81106140:	00000206 	br	8110614c <bFeebCh4SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106144:	e03ffc15 	stw	zero,-16(fp)
			break;
81106148:	0001883a 	nop
		}
	}

	return bStatus;
8110614c:	e0bffc17 	ldw	r2,-16(fp)
}
81106150:	e037883a 	mov	sp,fp
81106154:	dfc00117 	ldw	ra,4(sp)
81106158:	df000017 	ldw	fp,0(sp)
8110615c:	dec00204 	addi	sp,sp,8
81106160:	f800283a 	ret

81106164 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106164:	defffa04 	addi	sp,sp,-24
81106168:	de00012e 	bgeu	sp,et,81106170 <bFeebCh5SetBufferSize+0xc>
8110616c:	003b68fa 	trap	3
81106170:	dfc00515 	stw	ra,20(sp)
81106174:	df000415 	stw	fp,16(sp)
81106178:	df000404 	addi	fp,sp,16
8110617c:	2007883a 	mov	r3,r4
81106180:	2805883a 	mov	r2,r5
81106184:	e0fffe05 	stb	r3,-8(fp)
81106188:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110618c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81106190:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106194:	e0bffe03 	ldbu	r2,-8(fp)
81106198:	10002426 	beq	r2,zero,8110622c <bFeebCh5SetBufferSize+0xc8>
8110619c:	e0bffe03 	ldbu	r2,-8(fp)
811061a0:	10800468 	cmpgeui	r2,r2,17
811061a4:	1000211e 	bne	r2,zero,8110622c <bFeebCh5SetBufferSize+0xc8>
		switch (ucBufferSide) {
811061a8:	e0bfff03 	ldbu	r2,-4(fp)
811061ac:	10000326 	beq	r2,zero,811061bc <bFeebCh5SetBufferSize+0x58>
811061b0:	10800060 	cmpeqi	r2,r2,1
811061b4:	10000e1e 	bne	r2,zero,811061f0 <bFeebCh5SetBufferSize+0x8c>
811061b8:	00001a06 	br	81106224 <bFeebCh5SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811061bc:	e0bffe03 	ldbu	r2,-8(fp)
811061c0:	10bfffc4 	addi	r2,r2,-1
811061c4:	108003cc 	andi	r2,r2,15
811061c8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811061cc:	e0bffd17 	ldw	r2,-12(fp)
811061d0:	100d883a 	mov	r6,r2
811061d4:	01400544 	movi	r5,21
811061d8:	01204834 	movhi	r4,33056
811061dc:	210b0004 	addi	r4,r4,11264
811061e0:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811061e4:	00800044 	movi	r2,1
811061e8:	e0bffc15 	stw	r2,-16(fp)
			break;
811061ec:	00000f06 	br	8110622c <bFeebCh5SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811061f0:	e0bffe03 	ldbu	r2,-8(fp)
811061f4:	10bfffc4 	addi	r2,r2,-1
811061f8:	108003cc 	andi	r2,r2,15
811061fc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106200:	e0bffd17 	ldw	r2,-12(fp)
81106204:	100d883a 	mov	r6,r2
81106208:	01400504 	movi	r5,20
8110620c:	01204834 	movhi	r4,33056
81106210:	210b0004 	addi	r4,r4,11264
81106214:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106218:	00800044 	movi	r2,1
8110621c:	e0bffc15 	stw	r2,-16(fp)
			break;
81106220:	00000206 	br	8110622c <bFeebCh5SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106224:	e03ffc15 	stw	zero,-16(fp)
			break;
81106228:	0001883a 	nop
		}
	}

	return bStatus;
8110622c:	e0bffc17 	ldw	r2,-16(fp)
}
81106230:	e037883a 	mov	sp,fp
81106234:	dfc00117 	ldw	ra,4(sp)
81106238:	df000017 	ldw	fp,0(sp)
8110623c:	dec00204 	addi	sp,sp,8
81106240:	f800283a 	ret

81106244 <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106244:	defffa04 	addi	sp,sp,-24
81106248:	de00012e 	bgeu	sp,et,81106250 <bFeebCh6SetBufferSize+0xc>
8110624c:	003b68fa 	trap	3
81106250:	dfc00515 	stw	ra,20(sp)
81106254:	df000415 	stw	fp,16(sp)
81106258:	df000404 	addi	fp,sp,16
8110625c:	2007883a 	mov	r3,r4
81106260:	2805883a 	mov	r2,r5
81106264:	e0fffe05 	stb	r3,-8(fp)
81106268:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110626c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81106270:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106274:	e0bffe03 	ldbu	r2,-8(fp)
81106278:	10002426 	beq	r2,zero,8110630c <bFeebCh6SetBufferSize+0xc8>
8110627c:	e0bffe03 	ldbu	r2,-8(fp)
81106280:	10800468 	cmpgeui	r2,r2,17
81106284:	1000211e 	bne	r2,zero,8110630c <bFeebCh6SetBufferSize+0xc8>
		switch (ucBufferSide) {
81106288:	e0bfff03 	ldbu	r2,-4(fp)
8110628c:	10000326 	beq	r2,zero,8110629c <bFeebCh6SetBufferSize+0x58>
81106290:	10800060 	cmpeqi	r2,r2,1
81106294:	10000e1e 	bne	r2,zero,811062d0 <bFeebCh6SetBufferSize+0x8c>
81106298:	00001a06 	br	81106304 <bFeebCh6SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8110629c:	e0bffe03 	ldbu	r2,-8(fp)
811062a0:	10bfffc4 	addi	r2,r2,-1
811062a4:	108003cc 	andi	r2,r2,15
811062a8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811062ac:	e0bffd17 	ldw	r2,-12(fp)
811062b0:	100d883a 	mov	r6,r2
811062b4:	01400544 	movi	r5,21
811062b8:	01204834 	movhi	r4,33056
811062bc:	210a0004 	addi	r4,r4,10240
811062c0:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811062c4:	00800044 	movi	r2,1
811062c8:	e0bffc15 	stw	r2,-16(fp)
			break;
811062cc:	00000f06 	br	8110630c <bFeebCh6SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811062d0:	e0bffe03 	ldbu	r2,-8(fp)
811062d4:	10bfffc4 	addi	r2,r2,-1
811062d8:	108003cc 	andi	r2,r2,15
811062dc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811062e0:	e0bffd17 	ldw	r2,-12(fp)
811062e4:	100d883a 	mov	r6,r2
811062e8:	01400504 	movi	r5,20
811062ec:	01204834 	movhi	r4,33056
811062f0:	210a0004 	addi	r4,r4,10240
811062f4:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811062f8:	00800044 	movi	r2,1
811062fc:	e0bffc15 	stw	r2,-16(fp)
			break;
81106300:	00000206 	br	8110630c <bFeebCh6SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106304:	e03ffc15 	stw	zero,-16(fp)
			break;
81106308:	0001883a 	nop
		}
	}

	return bStatus;
8110630c:	e0bffc17 	ldw	r2,-16(fp)
}
81106310:	e037883a 	mov	sp,fp
81106314:	dfc00117 	ldw	ra,4(sp)
81106318:	df000017 	ldw	fp,0(sp)
8110631c:	dec00204 	addi	sp,sp,8
81106320:	f800283a 	ret

81106324 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106324:	defffa04 	addi	sp,sp,-24
81106328:	de00012e 	bgeu	sp,et,81106330 <bFeebCh7SetBufferSize+0xc>
8110632c:	003b68fa 	trap	3
81106330:	dfc00515 	stw	ra,20(sp)
81106334:	df000415 	stw	fp,16(sp)
81106338:	df000404 	addi	fp,sp,16
8110633c:	2007883a 	mov	r3,r4
81106340:	2805883a 	mov	r2,r5
81106344:	e0fffe05 	stb	r3,-8(fp)
81106348:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110634c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81106350:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106354:	e0bffe03 	ldbu	r2,-8(fp)
81106358:	10002426 	beq	r2,zero,811063ec <bFeebCh7SetBufferSize+0xc8>
8110635c:	e0bffe03 	ldbu	r2,-8(fp)
81106360:	10800468 	cmpgeui	r2,r2,17
81106364:	1000211e 	bne	r2,zero,811063ec <bFeebCh7SetBufferSize+0xc8>
		switch (ucBufferSide) {
81106368:	e0bfff03 	ldbu	r2,-4(fp)
8110636c:	10000326 	beq	r2,zero,8110637c <bFeebCh7SetBufferSize+0x58>
81106370:	10800060 	cmpeqi	r2,r2,1
81106374:	10000e1e 	bne	r2,zero,811063b0 <bFeebCh7SetBufferSize+0x8c>
81106378:	00001a06 	br	811063e4 <bFeebCh7SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8110637c:	e0bffe03 	ldbu	r2,-8(fp)
81106380:	10bfffc4 	addi	r2,r2,-1
81106384:	108003cc 	andi	r2,r2,15
81106388:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110638c:	e0bffd17 	ldw	r2,-12(fp)
81106390:	100d883a 	mov	r6,r2
81106394:	01400544 	movi	r5,21
81106398:	01204834 	movhi	r4,33056
8110639c:	210b0004 	addi	r4,r4,11264
811063a0:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811063a4:	00800044 	movi	r2,1
811063a8:	e0bffc15 	stw	r2,-16(fp)
			break;
811063ac:	00000f06 	br	811063ec <bFeebCh7SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811063b0:	e0bffe03 	ldbu	r2,-8(fp)
811063b4:	10bfffc4 	addi	r2,r2,-1
811063b8:	108003cc 	andi	r2,r2,15
811063bc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811063c0:	e0bffd17 	ldw	r2,-12(fp)
811063c4:	100d883a 	mov	r6,r2
811063c8:	01400504 	movi	r5,20
811063cc:	01204834 	movhi	r4,33056
811063d0:	210b0004 	addi	r4,r4,11264
811063d4:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811063d8:	00800044 	movi	r2,1
811063dc:	e0bffc15 	stw	r2,-16(fp)
			break;
811063e0:	00000206 	br	811063ec <bFeebCh7SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
811063e4:	e03ffc15 	stw	zero,-16(fp)
			break;
811063e8:	0001883a 	nop
		}
	}

	return bStatus;
811063ec:	e0bffc17 	ldw	r2,-16(fp)
}
811063f0:	e037883a 	mov	sp,fp
811063f4:	dfc00117 	ldw	ra,4(sp)
811063f8:	df000017 	ldw	fp,0(sp)
811063fc:	dec00204 	addi	sp,sp,8
81106400:	f800283a 	ret

81106404 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106404:	defffa04 	addi	sp,sp,-24
81106408:	de00012e 	bgeu	sp,et,81106410 <bFeebCh8SetBufferSize+0xc>
8110640c:	003b68fa 	trap	3
81106410:	dfc00515 	stw	ra,20(sp)
81106414:	df000415 	stw	fp,16(sp)
81106418:	df000404 	addi	fp,sp,16
8110641c:	2007883a 	mov	r3,r4
81106420:	2805883a 	mov	r2,r5
81106424:	e0fffe05 	stb	r3,-8(fp)
81106428:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110642c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81106430:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106434:	e0bffe03 	ldbu	r2,-8(fp)
81106438:	10002426 	beq	r2,zero,811064cc <bFeebCh8SetBufferSize+0xc8>
8110643c:	e0bffe03 	ldbu	r2,-8(fp)
81106440:	10800468 	cmpgeui	r2,r2,17
81106444:	1000211e 	bne	r2,zero,811064cc <bFeebCh8SetBufferSize+0xc8>
		switch (ucBufferSide) {
81106448:	e0bfff03 	ldbu	r2,-4(fp)
8110644c:	10000326 	beq	r2,zero,8110645c <bFeebCh8SetBufferSize+0x58>
81106450:	10800060 	cmpeqi	r2,r2,1
81106454:	10000e1e 	bne	r2,zero,81106490 <bFeebCh8SetBufferSize+0x8c>
81106458:	00001a06 	br	811064c4 <bFeebCh8SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8110645c:	e0bffe03 	ldbu	r2,-8(fp)
81106460:	10bfffc4 	addi	r2,r2,-1
81106464:	108003cc 	andi	r2,r2,15
81106468:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110646c:	e0bffd17 	ldw	r2,-12(fp)
81106470:	100d883a 	mov	r6,r2
81106474:	01400544 	movi	r5,21
81106478:	01204834 	movhi	r4,33056
8110647c:	210a0004 	addi	r4,r4,10240
81106480:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106484:	00800044 	movi	r2,1
81106488:	e0bffc15 	stw	r2,-16(fp)
			break;
8110648c:	00000f06 	br	811064cc <bFeebCh8SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106490:	e0bffe03 	ldbu	r2,-8(fp)
81106494:	10bfffc4 	addi	r2,r2,-1
81106498:	108003cc 	andi	r2,r2,15
8110649c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811064a0:	e0bffd17 	ldw	r2,-12(fp)
811064a4:	100d883a 	mov	r6,r2
811064a8:	01400504 	movi	r5,20
811064ac:	01204834 	movhi	r4,33056
811064b0:	210a0004 	addi	r4,r4,10240
811064b4:	11073e00 	call	811073e0 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811064b8:	00800044 	movi	r2,1
811064bc:	e0bffc15 	stw	r2,-16(fp)
			break;
811064c0:	00000206 	br	811064cc <bFeebCh8SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
811064c4:	e03ffc15 	stw	zero,-16(fp)
			break;
811064c8:	0001883a 	nop
		}
	}

	return bStatus;
811064cc:	e0bffc17 	ldw	r2,-16(fp)
}
811064d0:	e037883a 	mov	sp,fp
811064d4:	dfc00117 	ldw	ra,4(sp)
811064d8:	df000017 	ldw	fp,0(sp)
811064dc:	dec00204 	addi	sp,sp,8
811064e0:	f800283a 	ret

811064e4 <vFeebInitIrq>:

bool vFeebInitIrq(alt_u8 ucCommCh) {
811064e4:	defffb04 	addi	sp,sp,-20
811064e8:	de00012e 	bgeu	sp,et,811064f0 <vFeebInitIrq+0xc>
811064ec:	003b68fa 	trap	3
811064f0:	dfc00415 	stw	ra,16(sp)
811064f4:	df000315 	stw	fp,12(sp)
811064f8:	df000304 	addi	fp,sp,12
811064fc:	2005883a 	mov	r2,r4
81106500:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106504:	e03ffd15 	stw	zero,-12(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106508:	e0bfff03 	ldbu	r2,-4(fp)
8110650c:	10c00228 	cmpgeui	r3,r2,8
81106510:	18005e1e 	bne	r3,zero,8110668c <vFeebInitIrq+0x1a8>
81106514:	100690ba 	slli	r3,r2,2
81106518:	00a04434 	movhi	r2,33040
8110651c:	10994b04 	addi	r2,r2,25900
81106520:	1885883a 	add	r2,r3,r2
81106524:	10800017 	ldw	r2,0(r2)
81106528:	1000683a 	jmp	r2
8110652c:	8110654c 	andi	r4,r16,16789
81106530:	81106574 	orhi	r4,r16,16789
81106534:	8110659c 	xori	r4,r16,16790
81106538:	811065c4 	addi	r4,r16,16791
8110653c:	811065ec 	andhi	r4,r16,16791
81106540:	81106614 	ori	r4,r16,16792
81106544:	8110663c 	xorhi	r4,r16,16792
81106548:	81106664 	muli	r4,r16,16793
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8110654c:	d0a04004 	addi	r2,gp,-32512
81106550:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81106554:	01a04434 	movhi	r6,33040
81106558:	3194e204 	addi	r6,r6,21384
8110655c:	e17ffe17 	ldw	r5,-8(fp)
81106560:	01000584 	movi	r4,22
81106564:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh1HandleIrq);
		bStatus = TRUE;
81106568:	00800044 	movi	r2,1
8110656c:	e0bffd15 	stw	r2,-12(fp)
		break;
81106570:	00004806 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81106574:	d0a04104 	addi	r2,gp,-32508
81106578:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
8110657c:	01a04434 	movhi	r6,33040
81106580:	31950d04 	addi	r6,r6,21556
81106584:	e17ffe17 	ldw	r5,-8(fp)
81106588:	01000504 	movi	r4,20
8110658c:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh2HandleIrq);
		bStatus = TRUE;
81106590:	00800044 	movi	r2,1
81106594:	e0bffd15 	stw	r2,-12(fp)
		break;
81106598:	00003e06 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
8110659c:	d0a04204 	addi	r2,gp,-32504
811065a0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811065a4:	01a04434 	movhi	r6,33040
811065a8:	31953904 	addi	r6,r6,21732
811065ac:	e17ffe17 	ldw	r5,-8(fp)
811065b0:	01000484 	movi	r4,18
811065b4:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh3HandleIrq);
		bStatus = TRUE;
811065b8:	00800044 	movi	r2,1
811065bc:	e0bffd15 	stw	r2,-12(fp)
		break;
811065c0:	00003406 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811065c4:	d0a04304 	addi	r2,gp,-32500
811065c8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
811065cc:	01a04434 	movhi	r6,33040
811065d0:	31956504 	addi	r6,r6,21908
811065d4:	e17ffe17 	ldw	r5,-8(fp)
811065d8:	01000404 	movi	r4,16
811065dc:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh4HandleIrq);
		bStatus = TRUE;
811065e0:	00800044 	movi	r2,1
811065e4:	e0bffd15 	stw	r2,-12(fp)
		break;
811065e8:	00002a06 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811065ec:	d0a04404 	addi	r2,gp,-32496
811065f0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
811065f4:	01a04434 	movhi	r6,33040
811065f8:	31959104 	addi	r6,r6,22084
811065fc:	e17ffe17 	ldw	r5,-8(fp)
81106600:	01000204 	movi	r4,8
81106604:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh5HandleIrq);
		bStatus = TRUE;
81106608:	00800044 	movi	r2,1
8110660c:	e0bffd15 	stw	r2,-12(fp)
		break;
81106610:	00002006 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106614:	d0a04504 	addi	r2,gp,-32492
81106618:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
8110661c:	01a04434 	movhi	r6,33040
81106620:	3195bd04 	addi	r6,r6,22260
81106624:	e17ffe17 	ldw	r5,-8(fp)
81106628:	01000184 	movi	r4,6
8110662c:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh6HandleIrq);
		bStatus = TRUE;
81106630:	00800044 	movi	r2,1
81106634:	e0bffd15 	stw	r2,-12(fp)
		break;
81106638:	00001606 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110663c:	d0a04604 	addi	r2,gp,-32488
81106640:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106644:	01a04434 	movhi	r6,33040
81106648:	3195e904 	addi	r6,r6,22436
8110664c:	e17ffe17 	ldw	r5,-8(fp)
81106650:	01000144 	movi	r4,5
81106654:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh7HandleIrq);
		bStatus = TRUE;
81106658:	00800044 	movi	r2,1
8110665c:	e0bffd15 	stw	r2,-12(fp)
		break;
81106660:	00000c06 	br	81106694 <vFeebInitIrq+0x1b0>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106664:	d0a04704 	addi	r2,gp,-32484
81106668:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
8110666c:	01a04434 	movhi	r6,33040
81106670:	31961504 	addi	r6,r6,22612
81106674:	e17ffe17 	ldw	r5,-8(fp)
81106678:	01000084 	movi	r4,2
8110667c:	11386380 	call	81138638 <alt_irq_register>
				vFeebCh8HandleIrq);
		bStatus = TRUE;
81106680:	00800044 	movi	r2,1
81106684:	e0bffd15 	stw	r2,-12(fp)
		break;
81106688:	00000206 	br	81106694 <vFeebInitIrq+0x1b0>
	default:
		bStatus = FALSE;
8110668c:	e03ffd15 	stw	zero,-12(fp)
		break;
81106690:	0001883a 	nop
	}

	return bStatus;
81106694:	e0bffd17 	ldw	r2,-12(fp)
}
81106698:	e037883a 	mov	sp,fp
8110669c:	dfc00117 	ldw	ra,4(sp)
811066a0:	df000017 	ldw	fp,0(sp)
811066a4:	dec00204 	addi	sp,sp,8
811066a8:	f800283a 	ret

811066ac <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811066ac:	defffb04 	addi	sp,sp,-20
811066b0:	de00012e 	bgeu	sp,et,811066b8 <bFeebSetIrqControl+0xc>
811066b4:	003b68fa 	trap	3
811066b8:	dfc00415 	stw	ra,16(sp)
811066bc:	df000315 	stw	fp,12(sp)
811066c0:	df000304 	addi	fp,sp,12
811066c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811066c8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811066cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811066d0:	e0bfff17 	ldw	r2,-4(fp)
811066d4:	10002526 	beq	r2,zero,8110676c <bFeebSetIrqControl+0xc0>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811066d8:	e0bfff17 	ldw	r2,-4(fp)
811066dc:	10800017 	ldw	r2,0(r2)
811066e0:	01400444 	movi	r5,17
811066e4:	1009883a 	mov	r4,r2
811066e8:	11074340 	call	81107434 <uliFeebReadReg>
811066ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
811066f0:	e0bfff17 	ldw	r2,-4(fp)
811066f4:	10800217 	ldw	r2,8(r2)
811066f8:	10000426 	beq	r2,zero,8110670c <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811066fc:	e0bffe17 	ldw	r2,-8(fp)
81106700:	10808014 	ori	r2,r2,512
81106704:	e0bffe15 	stw	r2,-8(fp)
81106708:	00000406 	br	8110671c <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
8110670c:	e0fffe17 	ldw	r3,-8(fp)
81106710:	00bf7fc4 	movi	r2,-513
81106714:	1884703a 	and	r2,r3,r2
81106718:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
8110671c:	e0bfff17 	ldw	r2,-4(fp)
81106720:	10800317 	ldw	r2,12(r2)
81106724:	10000426 	beq	r2,zero,81106738 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81106728:	e0bffe17 	ldw	r2,-8(fp)
8110672c:	10804014 	ori	r2,r2,256
81106730:	e0bffe15 	stw	r2,-8(fp)
81106734:	00000406 	br	81106748 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81106738:	e0fffe17 	ldw	r3,-8(fp)
8110673c:	00bfbfc4 	movi	r2,-257
81106740:	1884703a 	and	r2,r3,r2
81106744:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106748:	e0bfff17 	ldw	r2,-4(fp)
8110674c:	10800017 	ldw	r2,0(r2)
81106750:	e0fffe17 	ldw	r3,-8(fp)
81106754:	180d883a 	mov	r6,r3
81106758:	01400444 	movi	r5,17
8110675c:	1009883a 	mov	r4,r2
81106760:	11073e00 	call	811073e0 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106764:	00800044 	movi	r2,1
81106768:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110676c:	e0bffd17 	ldw	r2,-12(fp)
}
81106770:	e037883a 	mov	sp,fp
81106774:	dfc00117 	ldw	ra,4(sp)
81106778:	df000017 	ldw	fp,0(sp)
8110677c:	dec00204 	addi	sp,sp,8
81106780:	f800283a 	ret

81106784 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106784:	defffb04 	addi	sp,sp,-20
81106788:	de00012e 	bgeu	sp,et,81106790 <bFeebGetIrqControl+0xc>
8110678c:	003b68fa 	trap	3
81106790:	dfc00415 	stw	ra,16(sp)
81106794:	df000315 	stw	fp,12(sp)
81106798:	df000304 	addi	fp,sp,12
8110679c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811067a0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811067a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811067a8:	e0bfff17 	ldw	r2,-4(fp)
811067ac:	10001a26 	beq	r2,zero,81106818 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811067b0:	e0bfff17 	ldw	r2,-4(fp)
811067b4:	10800017 	ldw	r2,0(r2)
811067b8:	01400444 	movi	r5,17
811067bc:	1009883a 	mov	r4,r2
811067c0:	11074340 	call	81107434 <uliFeebReadReg>
811067c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811067c8:	e0bffe17 	ldw	r2,-8(fp)
811067cc:	1080800c 	andi	r2,r2,512
811067d0:	10000426 	beq	r2,zero,811067e4 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
811067d4:	e0bfff17 	ldw	r2,-4(fp)
811067d8:	00c00044 	movi	r3,1
811067dc:	10c00215 	stw	r3,8(r2)
811067e0:	00000206 	br	811067ec <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811067e4:	e0bfff17 	ldw	r2,-4(fp)
811067e8:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
811067ec:	e0bffe17 	ldw	r2,-8(fp)
811067f0:	1080400c 	andi	r2,r2,256
811067f4:	10000426 	beq	r2,zero,81106808 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
811067f8:	e0bfff17 	ldw	r2,-4(fp)
811067fc:	00c00044 	movi	r3,1
81106800:	10c00315 	stw	r3,12(r2)
81106804:	00000206 	br	81106810 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81106808:	e0bfff17 	ldw	r2,-4(fp)
8110680c:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81106810:	00800044 	movi	r2,1
81106814:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106818:	e0bffd17 	ldw	r2,-12(fp)
}
8110681c:	e037883a 	mov	sp,fp
81106820:	dfc00117 	ldw	ra,4(sp)
81106824:	df000017 	ldw	fp,0(sp)
81106828:	dec00204 	addi	sp,sp,8
8110682c:	f800283a 	ret

81106830 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81106830:	defffb04 	addi	sp,sp,-20
81106834:	de00012e 	bgeu	sp,et,8110683c <bFeebGetIrqFlags+0xc>
81106838:	003b68fa 	trap	3
8110683c:	dfc00415 	stw	ra,16(sp)
81106840:	df000315 	stw	fp,12(sp)
81106844:	df000304 	addi	fp,sp,12
81106848:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110684c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106850:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106854:	e0bfff17 	ldw	r2,-4(fp)
81106858:	10001126 	beq	r2,zero,811068a0 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110685c:	e0bfff17 	ldw	r2,-4(fp)
81106860:	10800017 	ldw	r2,0(r2)
81106864:	01400484 	movi	r5,18
81106868:	1009883a 	mov	r4,r2
8110686c:	11074340 	call	81107434 <uliFeebReadReg>
81106870:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81106874:	e0bffe17 	ldw	r2,-8(fp)
81106878:	1080400c 	andi	r2,r2,256
8110687c:	10000426 	beq	r2,zero,81106890 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106880:	e0bfff17 	ldw	r2,-4(fp)
81106884:	00c00044 	movi	r3,1
81106888:	10c00415 	stw	r3,16(r2)
8110688c:	00000206 	br	81106898 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81106890:	e0bfff17 	ldw	r2,-4(fp)
81106894:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81106898:	00800044 	movi	r2,1
8110689c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811068a0:	e0bffd17 	ldw	r2,-12(fp)
}
811068a4:	e037883a 	mov	sp,fp
811068a8:	dfc00117 	ldw	ra,4(sp)
811068ac:	df000017 	ldw	fp,0(sp)
811068b0:	dec00204 	addi	sp,sp,8
811068b4:	f800283a 	ret

811068b8 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
811068b8:	defffb04 	addi	sp,sp,-20
811068bc:	de00012e 	bgeu	sp,et,811068c4 <bFeebGetBuffersStatus+0xc>
811068c0:	003b68fa 	trap	3
811068c4:	dfc00415 	stw	ra,16(sp)
811068c8:	df000315 	stw	fp,12(sp)
811068cc:	df000304 	addi	fp,sp,12
811068d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811068d4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811068d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811068dc:	e0bfff17 	ldw	r2,-4(fp)
811068e0:	10004426 	beq	r2,zero,811069f4 <bFeebGetBuffersStatus+0x13c>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811068e4:	e0bfff17 	ldw	r2,-4(fp)
811068e8:	10800017 	ldw	r2,0(r2)
811068ec:	014000c4 	movi	r5,3
811068f0:	1009883a 	mov	r4,r2
811068f4:	11074340 	call	81107434 <uliFeebReadReg>
811068f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811068fc:	e0bffe17 	ldw	r2,-8(fp)
81106900:	1080008c 	andi	r2,r2,2
81106904:	10000426 	beq	r2,zero,81106918 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81106908:	e0bfff17 	ldw	r2,-4(fp)
8110690c:	00c00044 	movi	r3,1
81106910:	10c00515 	stw	r3,20(r2)
81106914:	00000206 	br	81106920 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81106918:	e0bfff17 	ldw	r2,-4(fp)
8110691c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106920:	e0bffe17 	ldw	r2,-8(fp)
81106924:	1080004c 	andi	r2,r2,1
81106928:	10000426 	beq	r2,zero,8110693c <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
8110692c:	e0bfff17 	ldw	r2,-4(fp)
81106930:	00c00044 	movi	r3,1
81106934:	10c00615 	stw	r3,24(r2)
81106938:	00000206 	br	81106944 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
8110693c:	e0bfff17 	ldw	r2,-4(fp)
81106940:	10000615 	stw	zero,24(r2)
		}

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
81106944:	e0bffe17 	ldw	r2,-8(fp)
81106948:	1080400c 	andi	r2,r2,256
8110694c:	10000426 	beq	r2,zero,81106960 <bFeebGetBuffersStatus+0xa8>
			pxFeebCh->xBufferStatus.bRightFeeBusy = TRUE;
81106950:	e0bfff17 	ldw	r2,-4(fp)
81106954:	00c00044 	movi	r3,1
81106958:	10c00815 	stw	r3,32(r2)
8110695c:	00000206 	br	81106968 <bFeebGetBuffersStatus+0xb0>
		} else {
			pxFeebCh->xBufferStatus.bRightFeeBusy = FALSE;
81106960:	e0bfff17 	ldw	r2,-4(fp)
81106964:	10000815 	stw	zero,32(r2)
		}
		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
81106968:	e0bffe17 	ldw	r2,-8(fp)
8110696c:	1080800c 	andi	r2,r2,512
81106970:	10000426 	beq	r2,zero,81106984 <bFeebGetBuffersStatus+0xcc>
			pxFeebCh->xBufferStatus.bLeftFeeBusy = TRUE;
81106974:	e0bfff17 	ldw	r2,-4(fp)
81106978:	00c00044 	movi	r3,1
8110697c:	10c00715 	stw	r3,28(r2)
81106980:	00000206 	br	8110698c <bFeebGetBuffersStatus+0xd4>
		} else {
			pxFeebCh->xBufferStatus.bLeftFeeBusy = FALSE;
81106984:	e0bfff17 	ldw	r2,-4(fp)
81106988:	10000715 	stw	zero,28(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110698c:	e0bfff17 	ldw	r2,-4(fp)
81106990:	10800017 	ldw	r2,0(r2)
81106994:	01400504 	movi	r5,20
81106998:	1009883a 	mov	r4,r2
8110699c:	11074340 	call	81107434 <uliFeebReadReg>
811069a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
811069a4:	e0bffe17 	ldw	r2,-8(fp)
811069a8:	108003cc 	andi	r2,r2,15
811069ac:	10800044 	addi	r2,r2,1
811069b0:	1007883a 	mov	r3,r2
811069b4:	e0bfff17 	ldw	r2,-4(fp)
811069b8:	10c00945 	stb	r3,37(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811069bc:	e0bfff17 	ldw	r2,-4(fp)
811069c0:	10800017 	ldw	r2,0(r2)
811069c4:	01400544 	movi	r5,21
811069c8:	1009883a 	mov	r4,r2
811069cc:	11074340 	call	81107434 <uliFeebReadReg>
811069d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
811069d4:	e0bffe17 	ldw	r2,-8(fp)
811069d8:	108003cc 	andi	r2,r2,15
811069dc:	10800044 	addi	r2,r2,1
811069e0:	1007883a 	mov	r3,r2
811069e4:	e0bfff17 	ldw	r2,-4(fp)
811069e8:	10c00945 	stb	r3,37(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
811069ec:	00800044 	movi	r2,1
811069f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811069f4:	e0bffd17 	ldw	r2,-12(fp)
}
811069f8:	e037883a 	mov	sp,fp
811069fc:	dfc00117 	ldw	ra,4(sp)
81106a00:	df000017 	ldw	fp,0(sp)
81106a04:	dec00204 	addi	sp,sp,8
81106a08:	f800283a 	ret

81106a0c <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
81106a0c:	defffb04 	addi	sp,sp,-20
81106a10:	de00012e 	bgeu	sp,et,81106a18 <bFeebGetLeftBufferEmpty+0xc>
81106a14:	003b68fa 	trap	3
81106a18:	dfc00415 	stw	ra,16(sp)
81106a1c:	df000315 	stw	fp,12(sp)
81106a20:	df000304 	addi	fp,sp,12
81106a24:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106a28:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106a2c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106a30:	e0bfff17 	ldw	r2,-4(fp)
81106a34:	10000d26 	beq	r2,zero,81106a6c <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106a38:	e0bfff17 	ldw	r2,-4(fp)
81106a3c:	10800017 	ldw	r2,0(r2)
81106a40:	014000c4 	movi	r5,3
81106a44:	1009883a 	mov	r4,r2
81106a48:	11074340 	call	81107434 <uliFeebReadReg>
81106a4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106a50:	e0bffe17 	ldw	r2,-8(fp)
81106a54:	1080008c 	andi	r2,r2,2
81106a58:	10000326 	beq	r2,zero,81106a68 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
81106a5c:	00800044 	movi	r2,1
81106a60:	e0bffd15 	stw	r2,-12(fp)
81106a64:	00000106 	br	81106a6c <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106a68:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106a6c:	e0bffd17 	ldw	r2,-12(fp)
}
81106a70:	e037883a 	mov	sp,fp
81106a74:	dfc00117 	ldw	ra,4(sp)
81106a78:	df000017 	ldw	fp,0(sp)
81106a7c:	dec00204 	addi	sp,sp,8
81106a80:	f800283a 	ret

81106a84 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
81106a84:	defffb04 	addi	sp,sp,-20
81106a88:	de00012e 	bgeu	sp,et,81106a90 <bFeebGetRightBufferEmpty+0xc>
81106a8c:	003b68fa 	trap	3
81106a90:	dfc00415 	stw	ra,16(sp)
81106a94:	df000315 	stw	fp,12(sp)
81106a98:	df000304 	addi	fp,sp,12
81106a9c:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106aa0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106aa4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106aa8:	e0bfff17 	ldw	r2,-4(fp)
81106aac:	10000d26 	beq	r2,zero,81106ae4 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106ab0:	e0bfff17 	ldw	r2,-4(fp)
81106ab4:	10800017 	ldw	r2,0(r2)
81106ab8:	014000c4 	movi	r5,3
81106abc:	1009883a 	mov	r4,r2
81106ac0:	11074340 	call	81107434 <uliFeebReadReg>
81106ac4:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106ac8:	e0bffe17 	ldw	r2,-8(fp)
81106acc:	1080004c 	andi	r2,r2,1
81106ad0:	10000326 	beq	r2,zero,81106ae0 <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106ad4:	00800044 	movi	r2,1
81106ad8:	e0bffd15 	stw	r2,-12(fp)
81106adc:	00000106 	br	81106ae4 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106ae0:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106ae4:	e0bffd17 	ldw	r2,-12(fp)
}
81106ae8:	e037883a 	mov	sp,fp
81106aec:	dfc00117 	ldw	ra,4(sp)
81106af0:	df000017 	ldw	fp,0(sp)
81106af4:	dec00204 	addi	sp,sp,8
81106af8:	f800283a 	ret

81106afc <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81106afc:	defffc04 	addi	sp,sp,-16
81106b00:	de00012e 	bgeu	sp,et,81106b08 <bFeebGetCh1LeftBufferEmpty+0xc>
81106b04:	003b68fa 	trap	3
81106b08:	dfc00315 	stw	ra,12(sp)
81106b0c:	df000215 	stw	fp,8(sp)
81106b10:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106b14:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106b18:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106b1c:	014000c4 	movi	r5,3
81106b20:	01204834 	movhi	r4,33056
81106b24:	210b0004 	addi	r4,r4,11264
81106b28:	11074340 	call	81107434 <uliFeebReadReg>
81106b2c:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106b30:	e0bfff17 	ldw	r2,-4(fp)
81106b34:	1080008c 	andi	r2,r2,2
81106b38:	10000326 	beq	r2,zero,81106b48 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106b3c:	00800044 	movi	r2,1
81106b40:	e0bffe15 	stw	r2,-8(fp)
81106b44:	00000106 	br	81106b4c <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106b48:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106b4c:	e0bffe17 	ldw	r2,-8(fp)
}
81106b50:	e037883a 	mov	sp,fp
81106b54:	dfc00117 	ldw	ra,4(sp)
81106b58:	df000017 	ldw	fp,0(sp)
81106b5c:	dec00204 	addi	sp,sp,8
81106b60:	f800283a 	ret

81106b64 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
81106b64:	defffc04 	addi	sp,sp,-16
81106b68:	de00012e 	bgeu	sp,et,81106b70 <bFeebGetCh1RightBufferEmpty+0xc>
81106b6c:	003b68fa 	trap	3
81106b70:	dfc00315 	stw	ra,12(sp)
81106b74:	df000215 	stw	fp,8(sp)
81106b78:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106b7c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106b80:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106b84:	014000c4 	movi	r5,3
81106b88:	01204834 	movhi	r4,33056
81106b8c:	210b0004 	addi	r4,r4,11264
81106b90:	11074340 	call	81107434 <uliFeebReadReg>
81106b94:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106b98:	e0bfff17 	ldw	r2,-4(fp)
81106b9c:	1080004c 	andi	r2,r2,1
81106ba0:	10000326 	beq	r2,zero,81106bb0 <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106ba4:	00800044 	movi	r2,1
81106ba8:	e0bffe15 	stw	r2,-8(fp)
81106bac:	00000106 	br	81106bb4 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106bb0:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106bb4:	e0bffe17 	ldw	r2,-8(fp)
}
81106bb8:	e037883a 	mov	sp,fp
81106bbc:	dfc00117 	ldw	ra,4(sp)
81106bc0:	df000017 	ldw	fp,0(sp)
81106bc4:	dec00204 	addi	sp,sp,8
81106bc8:	f800283a 	ret

81106bcc <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81106bcc:	defffc04 	addi	sp,sp,-16
81106bd0:	de00012e 	bgeu	sp,et,81106bd8 <bFeebGetCh2LeftBufferEmpty+0xc>
81106bd4:	003b68fa 	trap	3
81106bd8:	dfc00315 	stw	ra,12(sp)
81106bdc:	df000215 	stw	fp,8(sp)
81106be0:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106be4:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106be8:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106bec:	014000c4 	movi	r5,3
81106bf0:	01204834 	movhi	r4,33056
81106bf4:	210a0004 	addi	r4,r4,10240
81106bf8:	11074340 	call	81107434 <uliFeebReadReg>
81106bfc:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106c00:	e0bfff17 	ldw	r2,-4(fp)
81106c04:	1080008c 	andi	r2,r2,2
81106c08:	10000326 	beq	r2,zero,81106c18 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106c0c:	00800044 	movi	r2,1
81106c10:	e0bffe15 	stw	r2,-8(fp)
81106c14:	00000106 	br	81106c1c <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106c18:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106c1c:	e0bffe17 	ldw	r2,-8(fp)
}
81106c20:	e037883a 	mov	sp,fp
81106c24:	dfc00117 	ldw	ra,4(sp)
81106c28:	df000017 	ldw	fp,0(sp)
81106c2c:	dec00204 	addi	sp,sp,8
81106c30:	f800283a 	ret

81106c34 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
81106c34:	defffc04 	addi	sp,sp,-16
81106c38:	de00012e 	bgeu	sp,et,81106c40 <bFeebGetCh2RightBufferEmpty+0xc>
81106c3c:	003b68fa 	trap	3
81106c40:	dfc00315 	stw	ra,12(sp)
81106c44:	df000215 	stw	fp,8(sp)
81106c48:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106c4c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106c50:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106c54:	014000c4 	movi	r5,3
81106c58:	01204834 	movhi	r4,33056
81106c5c:	210a0004 	addi	r4,r4,10240
81106c60:	11074340 	call	81107434 <uliFeebReadReg>
81106c64:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106c68:	e0bfff17 	ldw	r2,-4(fp)
81106c6c:	1080004c 	andi	r2,r2,1
81106c70:	10000326 	beq	r2,zero,81106c80 <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106c74:	00800044 	movi	r2,1
81106c78:	e0bffe15 	stw	r2,-8(fp)
81106c7c:	00000106 	br	81106c84 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106c80:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106c84:	e0bffe17 	ldw	r2,-8(fp)
}
81106c88:	e037883a 	mov	sp,fp
81106c8c:	dfc00117 	ldw	ra,4(sp)
81106c90:	df000017 	ldw	fp,0(sp)
81106c94:	dec00204 	addi	sp,sp,8
81106c98:	f800283a 	ret

81106c9c <bFeebGetCh1LeftFeeBusy>:

bool bFeebGetCh1LeftFeeBusy(void){
81106c9c:	defffc04 	addi	sp,sp,-16
81106ca0:	de00012e 	bgeu	sp,et,81106ca8 <bFeebGetCh1LeftFeeBusy+0xc>
81106ca4:	003b68fa 	trap	3
81106ca8:	dfc00315 	stw	ra,12(sp)
81106cac:	df000215 	stw	fp,8(sp)
81106cb0:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106cb4:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106cb8:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106cbc:	014000c4 	movi	r5,3
81106cc0:	01204834 	movhi	r4,33056
81106cc4:	210b0004 	addi	r4,r4,11264
81106cc8:	11074340 	call	81107434 <uliFeebReadReg>
81106ccc:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
81106cd0:	e0bfff17 	ldw	r2,-4(fp)
81106cd4:	1080800c 	andi	r2,r2,512
81106cd8:	10000326 	beq	r2,zero,81106ce8 <bFeebGetCh1LeftFeeBusy+0x4c>
			bFlag = TRUE;
81106cdc:	00800044 	movi	r2,1
81106ce0:	e0bffe15 	stw	r2,-8(fp)
81106ce4:	00000106 	br	81106cec <bFeebGetCh1LeftFeeBusy+0x50>
		} else {
			bFlag = FALSE;
81106ce8:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106cec:	e0bffe17 	ldw	r2,-8(fp)
}
81106cf0:	e037883a 	mov	sp,fp
81106cf4:	dfc00117 	ldw	ra,4(sp)
81106cf8:	df000017 	ldw	fp,0(sp)
81106cfc:	dec00204 	addi	sp,sp,8
81106d00:	f800283a 	ret

81106d04 <bFeebGetCh1RightFeeBusy>:

bool bFeebGetCh1RightFeeBusy(void){
81106d04:	defffc04 	addi	sp,sp,-16
81106d08:	de00012e 	bgeu	sp,et,81106d10 <bFeebGetCh1RightFeeBusy+0xc>
81106d0c:	003b68fa 	trap	3
81106d10:	dfc00315 	stw	ra,12(sp)
81106d14:	df000215 	stw	fp,8(sp)
81106d18:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106d1c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106d20:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106d24:	014000c4 	movi	r5,3
81106d28:	01204834 	movhi	r4,33056
81106d2c:	210b0004 	addi	r4,r4,11264
81106d30:	11074340 	call	81107434 <uliFeebReadReg>
81106d34:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
81106d38:	e0bfff17 	ldw	r2,-4(fp)
81106d3c:	1080400c 	andi	r2,r2,256
81106d40:	10000326 	beq	r2,zero,81106d50 <bFeebGetCh1RightFeeBusy+0x4c>
			bFlag = TRUE;
81106d44:	00800044 	movi	r2,1
81106d48:	e0bffe15 	stw	r2,-8(fp)
81106d4c:	00000106 	br	81106d54 <bFeebGetCh1RightFeeBusy+0x50>
		} else {
			bFlag = FALSE;
81106d50:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106d54:	e0bffe17 	ldw	r2,-8(fp)
}
81106d58:	e037883a 	mov	sp,fp
81106d5c:	dfc00117 	ldw	ra,4(sp)
81106d60:	df000017 	ldw	fp,0(sp)
81106d64:	dec00204 	addi	sp,sp,8
81106d68:	f800283a 	ret

81106d6c <bFeebGetCh2LeftFeeBusy>:

bool bFeebGetCh2LeftFeeBusy(void){
81106d6c:	defffc04 	addi	sp,sp,-16
81106d70:	de00012e 	bgeu	sp,et,81106d78 <bFeebGetCh2LeftFeeBusy+0xc>
81106d74:	003b68fa 	trap	3
81106d78:	dfc00315 	stw	ra,12(sp)
81106d7c:	df000215 	stw	fp,8(sp)
81106d80:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106d84:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106d88:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106d8c:	014000c4 	movi	r5,3
81106d90:	01204834 	movhi	r4,33056
81106d94:	210a0004 	addi	r4,r4,10240
81106d98:	11074340 	call	81107434 <uliFeebReadReg>
81106d9c:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
81106da0:	e0bfff17 	ldw	r2,-4(fp)
81106da4:	1080800c 	andi	r2,r2,512
81106da8:	10000326 	beq	r2,zero,81106db8 <bFeebGetCh2LeftFeeBusy+0x4c>
			bFlag = TRUE;
81106dac:	00800044 	movi	r2,1
81106db0:	e0bffe15 	stw	r2,-8(fp)
81106db4:	00000106 	br	81106dbc <bFeebGetCh2LeftFeeBusy+0x50>
		} else {
			bFlag = FALSE;
81106db8:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106dbc:	e0bffe17 	ldw	r2,-8(fp)
}
81106dc0:	e037883a 	mov	sp,fp
81106dc4:	dfc00117 	ldw	ra,4(sp)
81106dc8:	df000017 	ldw	fp,0(sp)
81106dcc:	dec00204 	addi	sp,sp,8
81106dd0:	f800283a 	ret

81106dd4 <bFeebGetCh2RightFeeBusy>:

bool bFeebGetCh2RightFeeBusy(void){
81106dd4:	defffc04 	addi	sp,sp,-16
81106dd8:	de00012e 	bgeu	sp,et,81106de0 <bFeebGetCh2RightFeeBusy+0xc>
81106ddc:	003b68fa 	trap	3
81106de0:	dfc00315 	stw	ra,12(sp)
81106de4:	df000215 	stw	fp,8(sp)
81106de8:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106dec:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106df0:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106df4:	014000c4 	movi	r5,3
81106df8:	01204834 	movhi	r4,33056
81106dfc:	210a0004 	addi	r4,r4,10240
81106e00:	11074340 	call	81107434 <uliFeebReadReg>
81106e04:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
81106e08:	e0bfff17 	ldw	r2,-4(fp)
81106e0c:	1080400c 	andi	r2,r2,256
81106e10:	10000326 	beq	r2,zero,81106e20 <bFeebGetCh2RightFeeBusy+0x4c>
			bFlag = TRUE;
81106e14:	00800044 	movi	r2,1
81106e18:	e0bffe15 	stw	r2,-8(fp)
81106e1c:	00000106 	br	81106e24 <bFeebGetCh2RightFeeBusy+0x50>
		} else {
			bFlag = FALSE;
81106e20:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106e24:	e0bffe17 	ldw	r2,-8(fp)
}
81106e28:	e037883a 	mov	sp,fp
81106e2c:	dfc00117 	ldw	ra,4(sp)
81106e30:	df000017 	ldw	fp,0(sp)
81106e34:	dec00204 	addi	sp,sp,8
81106e38:	f800283a 	ret

81106e3c <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
81106e3c:	defff904 	addi	sp,sp,-28
81106e40:	de00012e 	bgeu	sp,et,81106e48 <bFeebSetBufferSize+0xc>
81106e44:	003b68fa 	trap	3
81106e48:	dfc00615 	stw	ra,24(sp)
81106e4c:	df000515 	stw	fp,20(sp)
81106e50:	df000504 	addi	fp,sp,20
81106e54:	e13ffd15 	stw	r4,-12(fp)
81106e58:	2807883a 	mov	r3,r5
81106e5c:	3005883a 	mov	r2,r6
81106e60:	e0fffe05 	stb	r3,-8(fp)
81106e64:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106e68:	00800044 	movi	r2,1
81106e6c:	e0bffb15 	stw	r2,-20(fp)
	volatile alt_u32 uliReg = 0;
81106e70:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106e74:	e0bffe03 	ldbu	r2,-8(fp)
81106e78:	10002326 	beq	r2,zero,81106f08 <bFeebSetBufferSize+0xcc>
81106e7c:	e0bffe03 	ldbu	r2,-8(fp)
81106e80:	10800468 	cmpgeui	r2,r2,17
81106e84:	1000201e 	bne	r2,zero,81106f08 <bFeebSetBufferSize+0xcc>
		switch (ucBufferSide) {
81106e88:	e0bfff03 	ldbu	r2,-4(fp)
81106e8c:	10000326 	beq	r2,zero,81106e9c <bFeebSetBufferSize+0x60>
81106e90:	10800060 	cmpeqi	r2,r2,1
81106e94:	10000d1e 	bne	r2,zero,81106ecc <bFeebSetBufferSize+0x90>
81106e98:	00001806 	br	81106efc <bFeebSetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106e9c:	e0bffe03 	ldbu	r2,-8(fp)
81106ea0:	10bfffc4 	addi	r2,r2,-1
81106ea4:	108003cc 	andi	r2,r2,15
81106ea8:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106eac:	e0bffd17 	ldw	r2,-12(fp)
81106eb0:	10800017 	ldw	r2,0(r2)
81106eb4:	e0fffc17 	ldw	r3,-16(fp)
81106eb8:	180d883a 	mov	r6,r3
81106ebc:	01400544 	movi	r5,21
81106ec0:	1009883a 	mov	r4,r2
81106ec4:	11073e00 	call	811073e0 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106ec8:	00000e06 	br	81106f04 <bFeebSetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106ecc:	e0bffe03 	ldbu	r2,-8(fp)
81106ed0:	10bfffc4 	addi	r2,r2,-1
81106ed4:	108003cc 	andi	r2,r2,15
81106ed8:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106edc:	e0bffd17 	ldw	r2,-12(fp)
81106ee0:	10800017 	ldw	r2,0(r2)
81106ee4:	e0fffc17 	ldw	r3,-16(fp)
81106ee8:	180d883a 	mov	r6,r3
81106eec:	01400504 	movi	r5,20
81106ef0:	1009883a 	mov	r4,r2
81106ef4:	11073e00 	call	811073e0 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106ef8:	00000206 	br	81106f04 <bFeebSetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106efc:	e03ffb15 	stw	zero,-20(fp)
			break;
81106f00:	0001883a 	nop
		}
	} else {
81106f04:	00000106 	br	81106f0c <bFeebSetBufferSize+0xd0>
		bStatus = FALSE;
81106f08:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
81106f0c:	e0bffb17 	ldw	r2,-20(fp)
}
81106f10:	e037883a 	mov	sp,fp
81106f14:	dfc00117 	ldw	ra,4(sp)
81106f18:	df000017 	ldw	fp,0(sp)
81106f1c:	dec00204 	addi	sp,sp,8
81106f20:	f800283a 	ret

81106f24 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81106f24:	defffb04 	addi	sp,sp,-20
81106f28:	de00012e 	bgeu	sp,et,81106f30 <bFeebSetWindowing+0xc>
81106f2c:	003b68fa 	trap	3
81106f30:	dfc00415 	stw	ra,16(sp)
81106f34:	df000315 	stw	fp,12(sp)
81106f38:	df000304 	addi	fp,sp,12
81106f3c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106f40:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106f44:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106f48:	e0bfff17 	ldw	r2,-4(fp)
81106f4c:	10001a26 	beq	r2,zero,81106fb8 <bFeebSetWindowing+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106f50:	e0bfff17 	ldw	r2,-4(fp)
81106f54:	10800017 	ldw	r2,0(r2)
81106f58:	01400084 	movi	r5,2
81106f5c:	1009883a 	mov	r4,r2
81106f60:	11074340 	call	81107434 <uliFeebReadReg>
81106f64:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81106f68:	e0bfff17 	ldw	r2,-4(fp)
81106f6c:	10800117 	ldw	r2,4(r2)
81106f70:	10000426 	beq	r2,zero,81106f84 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106f74:	e0bffe17 	ldw	r2,-8(fp)
81106f78:	10800214 	ori	r2,r2,8
81106f7c:	e0bffe15 	stw	r2,-8(fp)
81106f80:	00000406 	br	81106f94 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81106f84:	e0fffe17 	ldw	r3,-8(fp)
81106f88:	00bffdc4 	movi	r2,-9
81106f8c:	1884703a 	and	r2,r3,r2
81106f90:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106f94:	e0bfff17 	ldw	r2,-4(fp)
81106f98:	10800017 	ldw	r2,0(r2)
81106f9c:	e0fffe17 	ldw	r3,-8(fp)
81106fa0:	180d883a 	mov	r6,r3
81106fa4:	01400084 	movi	r5,2
81106fa8:	1009883a 	mov	r4,r2
81106fac:	11073e00 	call	811073e0 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106fb0:	00800044 	movi	r2,1
81106fb4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106fb8:	e0bffd17 	ldw	r2,-12(fp)
}
81106fbc:	e037883a 	mov	sp,fp
81106fc0:	dfc00117 	ldw	ra,4(sp)
81106fc4:	df000017 	ldw	fp,0(sp)
81106fc8:	dec00204 	addi	sp,sp,8
81106fcc:	f800283a 	ret

81106fd0 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81106fd0:	defffb04 	addi	sp,sp,-20
81106fd4:	de00012e 	bgeu	sp,et,81106fdc <bFeebGetWindowing+0xc>
81106fd8:	003b68fa 	trap	3
81106fdc:	dfc00415 	stw	ra,16(sp)
81106fe0:	df000315 	stw	fp,12(sp)
81106fe4:	df000304 	addi	fp,sp,12
81106fe8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106fec:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106ff0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106ff4:	e0bfff17 	ldw	r2,-4(fp)
81106ff8:	10001126 	beq	r2,zero,81107040 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106ffc:	e0bfff17 	ldw	r2,-4(fp)
81107000:	10800017 	ldw	r2,0(r2)
81107004:	01400084 	movi	r5,2
81107008:	1009883a 	mov	r4,r2
8110700c:	11074340 	call	81107434 <uliFeebReadReg>
81107010:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81107014:	e0bffe17 	ldw	r2,-8(fp)
81107018:	1080020c 	andi	r2,r2,8
8110701c:	10000426 	beq	r2,zero,81107030 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81107020:	e0bfff17 	ldw	r2,-4(fp)
81107024:	00c00044 	movi	r3,1
81107028:	10c00115 	stw	r3,4(r2)
8110702c:	00000206 	br	81107038 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81107030:	e0bfff17 	ldw	r2,-4(fp)
81107034:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81107038:	00800044 	movi	r2,1
8110703c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107040:	e0bffd17 	ldw	r2,-12(fp)
}
81107044:	e037883a 	mov	sp,fp
81107048:	dfc00117 	ldw	ra,4(sp)
8110704c:	df000017 	ldw	fp,0(sp)
81107050:	dec00204 	addi	sp,sp,8
81107054:	f800283a 	ret

81107058 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81107058:	defffb04 	addi	sp,sp,-20
8110705c:	de00012e 	bgeu	sp,et,81107064 <bFeebStartCh+0xc>
81107060:	003b68fa 	trap	3
81107064:	dfc00415 	stw	ra,16(sp)
81107068:	df000315 	stw	fp,12(sp)
8110706c:	df000304 	addi	fp,sp,12
81107070:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107074:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107078:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110707c:	e0bfff17 	ldw	r2,-4(fp)
81107080:	10001226 	beq	r2,zero,811070cc <bFeebStartCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81107084:	e0bfff17 	ldw	r2,-4(fp)
81107088:	10800017 	ldw	r2,0(r2)
8110708c:	01400084 	movi	r5,2
81107090:	1009883a 	mov	r4,r2
81107094:	11074340 	call	81107434 <uliFeebReadReg>
81107098:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
8110709c:	e0bffe17 	ldw	r2,-8(fp)
811070a0:	10800114 	ori	r2,r2,4
811070a4:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811070a8:	e0bfff17 	ldw	r2,-4(fp)
811070ac:	10800017 	ldw	r2,0(r2)
811070b0:	e0fffe17 	ldw	r3,-8(fp)
811070b4:	180d883a 	mov	r6,r3
811070b8:	01400084 	movi	r5,2
811070bc:	1009883a 	mov	r4,r2
811070c0:	11073e00 	call	811073e0 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811070c4:	00800044 	movi	r2,1
811070c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811070cc:	e0bffd17 	ldw	r2,-12(fp)
}
811070d0:	e037883a 	mov	sp,fp
811070d4:	dfc00117 	ldw	ra,4(sp)
811070d8:	df000017 	ldw	fp,0(sp)
811070dc:	dec00204 	addi	sp,sp,8
811070e0:	f800283a 	ret

811070e4 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
811070e4:	defffb04 	addi	sp,sp,-20
811070e8:	de00012e 	bgeu	sp,et,811070f0 <bFeebStopCh+0xc>
811070ec:	003b68fa 	trap	3
811070f0:	dfc00415 	stw	ra,16(sp)
811070f4:	df000315 	stw	fp,12(sp)
811070f8:	df000304 	addi	fp,sp,12
811070fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107100:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107104:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81107108:	e0bfff17 	ldw	r2,-4(fp)
8110710c:	10001226 	beq	r2,zero,81107158 <bFeebStopCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81107110:	e0bfff17 	ldw	r2,-4(fp)
81107114:	10800017 	ldw	r2,0(r2)
81107118:	01400084 	movi	r5,2
8110711c:	1009883a 	mov	r4,r2
81107120:	11074340 	call	81107434 <uliFeebReadReg>
81107124:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81107128:	e0bffe17 	ldw	r2,-8(fp)
8110712c:	10800094 	ori	r2,r2,2
81107130:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81107134:	e0bfff17 	ldw	r2,-4(fp)
81107138:	10800017 	ldw	r2,0(r2)
8110713c:	e0fffe17 	ldw	r3,-8(fp)
81107140:	180d883a 	mov	r6,r3
81107144:	01400084 	movi	r5,2
81107148:	1009883a 	mov	r4,r2
8110714c:	11073e00 	call	811073e0 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81107150:	00800044 	movi	r2,1
81107154:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107158:	e0bffd17 	ldw	r2,-12(fp)
}
8110715c:	e037883a 	mov	sp,fp
81107160:	dfc00117 	ldw	ra,4(sp)
81107164:	df000017 	ldw	fp,0(sp)
81107168:	dec00204 	addi	sp,sp,8
8110716c:	f800283a 	ret

81107170 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81107170:	defffb04 	addi	sp,sp,-20
81107174:	de00012e 	bgeu	sp,et,8110717c <bFeebClrCh+0xc>
81107178:	003b68fa 	trap	3
8110717c:	dfc00415 	stw	ra,16(sp)
81107180:	df000315 	stw	fp,12(sp)
81107184:	df000304 	addi	fp,sp,12
81107188:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110718c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107190:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81107194:	e0bfff17 	ldw	r2,-4(fp)
81107198:	10001226 	beq	r2,zero,811071e4 <bFeebClrCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110719c:	e0bfff17 	ldw	r2,-4(fp)
811071a0:	10800017 	ldw	r2,0(r2)
811071a4:	01400084 	movi	r5,2
811071a8:	1009883a 	mov	r4,r2
811071ac:	11074340 	call	81107434 <uliFeebReadReg>
811071b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
811071b4:	e0bffe17 	ldw	r2,-8(fp)
811071b8:	10800054 	ori	r2,r2,1
811071bc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811071c0:	e0bfff17 	ldw	r2,-4(fp)
811071c4:	10800017 	ldw	r2,0(r2)
811071c8:	e0fffe17 	ldw	r3,-8(fp)
811071cc:	180d883a 	mov	r6,r3
811071d0:	01400084 	movi	r5,2
811071d4:	1009883a 	mov	r4,r2
811071d8:	11073e00 	call	811073e0 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811071dc:	00800044 	movi	r2,1
811071e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811071e4:	e0bffd17 	ldw	r2,-12(fp)
}
811071e8:	e037883a 	mov	sp,fp
811071ec:	dfc00117 	ldw	ra,4(sp)
811071f0:	df000017 	ldw	fp,0(sp)
811071f4:	dec00204 	addi	sp,sp,8
811071f8:	f800283a 	ret

811071fc <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
811071fc:	defff904 	addi	sp,sp,-28
81107200:	de00012e 	bgeu	sp,et,81107208 <bFeebInitCh+0xc>
81107204:	003b68fa 	trap	3
81107208:	dfc00615 	stw	ra,24(sp)
8110720c:	df000515 	stw	fp,20(sp)
81107210:	df000504 	addi	fp,sp,20
81107214:	e13ffe15 	stw	r4,-8(fp)
81107218:	2805883a 	mov	r2,r5
8110721c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81107220:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
81107224:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
81107228:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
8110722c:	e0bffe17 	ldw	r2,-8(fp)
81107230:	10006526 	beq	r2,zero,811073c8 <bFeebInitCh+0x1cc>

		switch (ucCommCh) {
81107234:	e0bfff03 	ldbu	r2,-4(fp)
81107238:	10c00228 	cmpgeui	r3,r2,8
8110723c:	1800461e 	bne	r3,zero,81107358 <bFeebInitCh+0x15c>
81107240:	100690ba 	slli	r3,r2,2
81107244:	00a04434 	movhi	r2,33040
81107248:	109c9604 	addi	r2,r2,29272
8110724c:	1885883a 	add	r2,r3,r2
81107250:	10800017 	ldw	r2,0(r2)
81107254:	1000683a 	jmp	r2
81107258:	81107278 	rdprs	r4,r16,16841
8110725c:	81107294 	ori	r4,r16,16842
81107260:	811072b0 	cmpltui	r4,r16,16842
81107264:	811072cc 	andi	r4,r16,16843
81107268:	811072e8 	cmpgeui	r4,r16,16843
8110726c:	81107304 	addi	r4,r16,16844
81107270:	81107320 	cmpeqi	r4,r16,16844
81107274:	8110733c 	xorhi	r4,r16,16844
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81107278:	e0fffe17 	ldw	r3,-8(fp)
8110727c:	00a04834 	movhi	r2,33056
81107280:	108b0004 	addi	r2,r2,11264
81107284:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81107288:	00800044 	movi	r2,1
8110728c:	e0bffc15 	stw	r2,-16(fp)
			break;
81107290:	00003306 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81107294:	e0fffe17 	ldw	r3,-8(fp)
81107298:	00a04834 	movhi	r2,33056
8110729c:	108a0004 	addi	r2,r2,10240
811072a0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811072a4:	00800044 	movi	r2,1
811072a8:	e0bffc15 	stw	r2,-16(fp)
			break;
811072ac:	00002c06 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811072b0:	e0fffe17 	ldw	r3,-8(fp)
811072b4:	00a04834 	movhi	r2,33056
811072b8:	108b0004 	addi	r2,r2,11264
811072bc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811072c0:	00800044 	movi	r2,1
811072c4:	e0bffc15 	stw	r2,-16(fp)
			break;
811072c8:	00002506 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811072cc:	e0fffe17 	ldw	r3,-8(fp)
811072d0:	00a04834 	movhi	r2,33056
811072d4:	108a0004 	addi	r2,r2,10240
811072d8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811072dc:	00800044 	movi	r2,1
811072e0:	e0bffc15 	stw	r2,-16(fp)
			break;
811072e4:	00001e06 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811072e8:	e0fffe17 	ldw	r3,-8(fp)
811072ec:	00a04834 	movhi	r2,33056
811072f0:	108b0004 	addi	r2,r2,11264
811072f4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811072f8:	00800044 	movi	r2,1
811072fc:	e0bffc15 	stw	r2,-16(fp)
			break;
81107300:	00001706 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81107304:	e0fffe17 	ldw	r3,-8(fp)
81107308:	00a04834 	movhi	r2,33056
8110730c:	108a0004 	addi	r2,r2,10240
81107310:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81107314:	00800044 	movi	r2,1
81107318:	e0bffc15 	stw	r2,-16(fp)
			break;
8110731c:	00001006 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81107320:	e0fffe17 	ldw	r3,-8(fp)
81107324:	00a04834 	movhi	r2,33056
81107328:	108b0004 	addi	r2,r2,11264
8110732c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81107330:	00800044 	movi	r2,1
81107334:	e0bffc15 	stw	r2,-16(fp)
			break;
81107338:	00000906 	br	81107360 <bFeebInitCh+0x164>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110733c:	e0fffe17 	ldw	r3,-8(fp)
81107340:	00a04834 	movhi	r2,33056
81107344:	108a0004 	addi	r2,r2,10240
81107348:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110734c:	00800044 	movi	r2,1
81107350:	e0bffc15 	stw	r2,-16(fp)
			break;
81107354:	00000206 	br	81107360 <bFeebInitCh+0x164>
		default:
			bValidCh = FALSE;
81107358:	e03ffc15 	stw	zero,-16(fp)
			break;
8110735c:	0001883a 	nop
		}

		if (bValidCh) {
81107360:	e0bffc17 	ldw	r2,-16(fp)
81107364:	10001826 	beq	r2,zero,811073c8 <bFeebInitCh+0x1cc>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81107368:	e13ffe17 	ldw	r4,-8(fp)
8110736c:	11067840 	call	81106784 <bFeebGetIrqControl>
81107370:	1000021e 	bne	r2,zero,8110737c <bFeebInitCh+0x180>
				bInitFail = TRUE;
81107374:	00800044 	movi	r2,1
81107378:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
8110737c:	e13ffe17 	ldw	r4,-8(fp)
81107380:	11068300 	call	81106830 <bFeebGetIrqFlags>
81107384:	1000021e 	bne	r2,zero,81107390 <bFeebInitCh+0x194>
				bInitFail = TRUE;
81107388:	00800044 	movi	r2,1
8110738c:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81107390:	e13ffe17 	ldw	r4,-8(fp)
81107394:	11068b80 	call	811068b8 <bFeebGetBuffersStatus>
81107398:	1000021e 	bne	r2,zero,811073a4 <bFeebInitCh+0x1a8>
				bInitFail = TRUE;
8110739c:	00800044 	movi	r2,1
811073a0:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
811073a4:	e13ffe17 	ldw	r4,-8(fp)
811073a8:	1106fd00 	call	81106fd0 <bFeebGetWindowing>
811073ac:	1000021e 	bne	r2,zero,811073b8 <bFeebInitCh+0x1bc>
				bInitFail = TRUE;
811073b0:	00800044 	movi	r2,1
811073b4:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
811073b8:	e0bffd17 	ldw	r2,-12(fp)
811073bc:	1000021e 	bne	r2,zero,811073c8 <bFeebInitCh+0x1cc>
				bStatus = TRUE;
811073c0:	00800044 	movi	r2,1
811073c4:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
811073c8:	e0bffb17 	ldw	r2,-20(fp)
}
811073cc:	e037883a 	mov	sp,fp
811073d0:	dfc00117 	ldw	ra,4(sp)
811073d4:	df000017 	ldw	fp,0(sp)
811073d8:	dec00204 	addi	sp,sp,8
811073dc:	f800283a 	ret

811073e0 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811073e0:	defffc04 	addi	sp,sp,-16
811073e4:	de00012e 	bgeu	sp,et,811073ec <vFeebWriteReg+0xc>
811073e8:	003b68fa 	trap	3
811073ec:	df000315 	stw	fp,12(sp)
811073f0:	df000304 	addi	fp,sp,12
811073f4:	e13ffd15 	stw	r4,-12(fp)
811073f8:	e17ffe15 	stw	r5,-8(fp)
811073fc:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81107400:	e0bffe17 	ldw	r2,-8(fp)
81107404:	1085883a 	add	r2,r2,r2
81107408:	1085883a 	add	r2,r2,r2
8110740c:	1007883a 	mov	r3,r2
81107410:	e0bffd17 	ldw	r2,-12(fp)
81107414:	10c5883a 	add	r2,r2,r3
81107418:	e0ffff17 	ldw	r3,-4(fp)
8110741c:	10c00015 	stw	r3,0(r2)
}
81107420:	0001883a 	nop
81107424:	e037883a 	mov	sp,fp
81107428:	df000017 	ldw	fp,0(sp)
8110742c:	dec00104 	addi	sp,sp,4
81107430:	f800283a 	ret

81107434 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81107434:	defffc04 	addi	sp,sp,-16
81107438:	de00012e 	bgeu	sp,et,81107440 <uliFeebReadReg+0xc>
8110743c:	003b68fa 	trap	3
81107440:	df000315 	stw	fp,12(sp)
81107444:	df000304 	addi	fp,sp,12
81107448:	e13ffe15 	stw	r4,-8(fp)
8110744c:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81107450:	e0bfff17 	ldw	r2,-4(fp)
81107454:	1085883a 	add	r2,r2,r2
81107458:	1085883a 	add	r2,r2,r2
8110745c:	1007883a 	mov	r3,r2
81107460:	e0bffe17 	ldw	r2,-8(fp)
81107464:	10c5883a 	add	r2,r2,r3
81107468:	10800017 	ldw	r2,0(r2)
8110746c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81107470:	e0bffd17 	ldw	r2,-12(fp)
}
81107474:	e037883a 	mov	sp,fp
81107478:	df000017 	ldw	fp,0(sp)
8110747c:	dec00104 	addi	sp,sp,4
81107480:	f800283a 	ret

81107484 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81107484:	defffb04 	addi	sp,sp,-20
81107488:	de00012e 	bgeu	sp,et,81107490 <vRmapCh1HandleIrq+0xc>
8110748c:	003b68fa 	trap	3
81107490:	dfc00415 	stw	ra,16(sp)
81107494:	df000315 	stw	fp,12(sp)
81107498:	df000304 	addi	fp,sp,12
8110749c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811074a0:	00a045f4 	movhi	r2,33047
811074a4:	10a34f04 	addi	r2,r2,-29380
811074a8:	10800a8b 	ldhu	r2,42(r2)
811074ac:	10bfffcc 	andi	r2,r2,65535
811074b0:	108000e8 	cmpgeui	r2,r2,3
811074b4:	1000071e 	bne	r2,zero,811074d4 <vRmapCh1HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
811074b8:	d0a06217 	ldw	r2,-32376(gp)
811074bc:	100f883a 	mov	r7,r2
811074c0:	01800284 	movi	r6,10
811074c4:	01400044 	movi	r5,1
811074c8:	01204574 	movhi	r4,33045
811074cc:	21392204 	addi	r4,r4,-7032
811074d0:	1123cec0 	call	81123cec <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
811074d4:	1107c8c0 	call	81107c8c <uliRmapCh1WriteCmdAddress>
811074d8:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
811074dc:	00800444 	movi	r2,17
811074e0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
811074e4:	00bffc04 	movi	r2,-16
811074e8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
811074ec:	e0bffd03 	ldbu	r2,-12(fp)
811074f0:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
811074f4:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811074f8:	00a045f4 	movhi	r2,33047
811074fc:	10a34f04 	addi	r2,r2,-29380
81107500:	10800a8b 	ldhu	r2,42(r2)
81107504:	10bfffcc 	andi	r2,r2,65535
81107508:	108000e8 	cmpgeui	r2,r2,3
8110750c:	1000071e 	bne	r2,zero,8110752c <vRmapCh1HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81107510:	d0a06217 	ldw	r2,-32376(gp)
81107514:	e0fffd03 	ldbu	r3,-12(fp)
81107518:	180d883a 	mov	r6,r3
8110751c:	01604574 	movhi	r5,33045
81107520:	29792504 	addi	r5,r5,-7020
81107524:	1009883a 	mov	r4,r2
81107528:	11236500 	call	81123650 <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
8110752c:	d0a06a17 	ldw	r2,-32344(gp)
81107530:	e0fffe17 	ldw	r3,-8(fp)
81107534:	180b883a 	mov	r5,r3
81107538:	1009883a 	mov	r4,r2
8110753c:	114018c0 	call	8114018c <OSQPostFront>
81107540:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81107544:	e0bffd43 	ldbu	r2,-11(fp)
81107548:	10000226 	beq	r2,zero,81107554 <vRmapCh1HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
8110754c:	0009883a 	mov	r4,zero
81107550:	111f4a00 	call	8111f4a0 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81107554:	11077ac0 	call	811077ac <vRmapCh1IrqFlagClrWriteCmd>
}
81107558:	0001883a 	nop
8110755c:	e037883a 	mov	sp,fp
81107560:	dfc00117 	ldw	ra,4(sp)
81107564:	df000017 	ldw	fp,0(sp)
81107568:	dec00204 	addi	sp,sp,8
8110756c:	f800283a 	ret

81107570 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81107570:	defffb04 	addi	sp,sp,-20
81107574:	de00012e 	bgeu	sp,et,8110757c <vRmapCh2HandleIrq+0xc>
81107578:	003b68fa 	trap	3
8110757c:	dfc00415 	stw	ra,16(sp)
81107580:	df000315 	stw	fp,12(sp)
81107584:	df000304 	addi	fp,sp,12
81107588:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT8U error_codel;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110758c:	00a045f4 	movhi	r2,33047
81107590:	10a34f04 	addi	r2,r2,-29380
81107594:	10800a8b 	ldhu	r2,42(r2)
81107598:	10bfffcc 	andi	r2,r2,65535
8110759c:	108000e8 	cmpgeui	r2,r2,3
811075a0:	1000071e 	bne	r2,zero,811075c0 <vRmapCh2HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
811075a4:	d0a06217 	ldw	r2,-32376(gp)
811075a8:	100f883a 	mov	r7,r2
811075ac:	01800284 	movi	r6,10
811075b0:	01400044 	movi	r5,1
811075b4:	01204574 	movhi	r4,33045
811075b8:	21392204 	addi	r4,r4,-7032
811075bc:	1123cec0 	call	81123cec <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
811075c0:	1107ce00 	call	81107ce0 <uliRmapCh2WriteCmdAddress>
811075c4:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
811075c8:	00800444 	movi	r2,17
811075cc:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
811075d0:	00bffc04 	movi	r2,-16
811075d4:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
811075d8:	e0bffd03 	ldbu	r2,-12(fp)
811075dc:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
811075e0:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811075e4:	00a045f4 	movhi	r2,33047
811075e8:	10a34f04 	addi	r2,r2,-29380
811075ec:	10800a8b 	ldhu	r2,42(r2)
811075f0:	10bfffcc 	andi	r2,r2,65535
811075f4:	108000e8 	cmpgeui	r2,r2,3
811075f8:	1000071e 	bne	r2,zero,81107618 <vRmapCh2HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
811075fc:	d0a06217 	ldw	r2,-32376(gp)
81107600:	e0fffd03 	ldbu	r3,-12(fp)
81107604:	180d883a 	mov	r6,r3
81107608:	01604574 	movhi	r5,33045
8110760c:	29792504 	addi	r5,r5,-7020
81107610:	1009883a 	mov	r4,r2
81107614:	11236500 	call	81123650 <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81107618:	d0a06a17 	ldw	r2,-32344(gp)
8110761c:	e0fffe17 	ldw	r3,-8(fp)
81107620:	180b883a 	mov	r5,r3
81107624:	1009883a 	mov	r4,r2
81107628:	114018c0 	call	8114018c <OSQPostFront>
8110762c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81107630:	e0bffd43 	ldbu	r2,-11(fp)
81107634:	10000226 	beq	r2,zero,81107640 <vRmapCh2HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81107638:	0009883a 	mov	r4,zero
8110763c:	111f4a00 	call	8111f4a0 <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
81107640:	11077f00 	call	811077f0 <vRmapCh2IrqFlagClrWriteCmd>
}
81107644:	0001883a 	nop
81107648:	e037883a 	mov	sp,fp
8110764c:	dfc00117 	ldw	ra,4(sp)
81107650:	df000017 	ldw	fp,0(sp)
81107654:	dec00204 	addi	sp,sp,8
81107658:	f800283a 	ret

8110765c <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
8110765c:	defffd04 	addi	sp,sp,-12
81107660:	de00012e 	bgeu	sp,et,81107668 <vRmapCh3HandleIrq+0xc>
81107664:	003b68fa 	trap	3
81107668:	dfc00215 	stw	ra,8(sp)
8110766c:	df000115 	stw	fp,4(sp)
81107670:	df000104 	addi	fp,sp,4
81107674:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81107678:	11078340 	call	81107834 <vRmapCh3IrqFlagClrWriteCmd>
}
8110767c:	0001883a 	nop
81107680:	e037883a 	mov	sp,fp
81107684:	dfc00117 	ldw	ra,4(sp)
81107688:	df000017 	ldw	fp,0(sp)
8110768c:	dec00204 	addi	sp,sp,8
81107690:	f800283a 	ret

81107694 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81107694:	defffd04 	addi	sp,sp,-12
81107698:	de00012e 	bgeu	sp,et,811076a0 <vRmapCh4HandleIrq+0xc>
8110769c:	003b68fa 	trap	3
811076a0:	dfc00215 	stw	ra,8(sp)
811076a4:	df000115 	stw	fp,4(sp)
811076a8:	df000104 	addi	fp,sp,4
811076ac:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
811076b0:	11078780 	call	81107878 <vRmapCh4IrqFlagClrWriteCmd>
}
811076b4:	0001883a 	nop
811076b8:	e037883a 	mov	sp,fp
811076bc:	dfc00117 	ldw	ra,4(sp)
811076c0:	df000017 	ldw	fp,0(sp)
811076c4:	dec00204 	addi	sp,sp,8
811076c8:	f800283a 	ret

811076cc <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
811076cc:	defffd04 	addi	sp,sp,-12
811076d0:	de00012e 	bgeu	sp,et,811076d8 <vRmapCh5HandleIrq+0xc>
811076d4:	003b68fa 	trap	3
811076d8:	dfc00215 	stw	ra,8(sp)
811076dc:	df000115 	stw	fp,4(sp)
811076e0:	df000104 	addi	fp,sp,4
811076e4:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
811076e8:	11078bc0 	call	811078bc <vRmapCh5IrqFlagClrWriteCmd>
}
811076ec:	0001883a 	nop
811076f0:	e037883a 	mov	sp,fp
811076f4:	dfc00117 	ldw	ra,4(sp)
811076f8:	df000017 	ldw	fp,0(sp)
811076fc:	dec00204 	addi	sp,sp,8
81107700:	f800283a 	ret

81107704 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81107704:	defffd04 	addi	sp,sp,-12
81107708:	de00012e 	bgeu	sp,et,81107710 <vRmapCh6HandleIrq+0xc>
8110770c:	003b68fa 	trap	3
81107710:	dfc00215 	stw	ra,8(sp)
81107714:	df000115 	stw	fp,4(sp)
81107718:	df000104 	addi	fp,sp,4
8110771c:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81107720:	11079000 	call	81107900 <vRmapCh6IrqFlagClrWriteCmd>
}
81107724:	0001883a 	nop
81107728:	e037883a 	mov	sp,fp
8110772c:	dfc00117 	ldw	ra,4(sp)
81107730:	df000017 	ldw	fp,0(sp)
81107734:	dec00204 	addi	sp,sp,8
81107738:	f800283a 	ret

8110773c <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
8110773c:	defffd04 	addi	sp,sp,-12
81107740:	de00012e 	bgeu	sp,et,81107748 <vRmapCh7HandleIrq+0xc>
81107744:	003b68fa 	trap	3
81107748:	dfc00215 	stw	ra,8(sp)
8110774c:	df000115 	stw	fp,4(sp)
81107750:	df000104 	addi	fp,sp,4
81107754:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81107758:	11079440 	call	81107944 <vRmapCh7IrqFlagClrWriteCmd>
}
8110775c:	0001883a 	nop
81107760:	e037883a 	mov	sp,fp
81107764:	dfc00117 	ldw	ra,4(sp)
81107768:	df000017 	ldw	fp,0(sp)
8110776c:	dec00204 	addi	sp,sp,8
81107770:	f800283a 	ret

81107774 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81107774:	defffd04 	addi	sp,sp,-12
81107778:	de00012e 	bgeu	sp,et,81107780 <vRmapCh8HandleIrq+0xc>
8110777c:	003b68fa 	trap	3
81107780:	dfc00215 	stw	ra,8(sp)
81107784:	df000115 	stw	fp,4(sp)
81107788:	df000104 	addi	fp,sp,4
8110778c:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81107790:	11079880 	call	81107988 <vRmapCh8IrqFlagClrWriteCmd>
}
81107794:	0001883a 	nop
81107798:	e037883a 	mov	sp,fp
8110779c:	dfc00117 	ldw	ra,4(sp)
811077a0:	df000017 	ldw	fp,0(sp)
811077a4:	dec00204 	addi	sp,sp,8
811077a8:	f800283a 	ret

811077ac <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
811077ac:	defffe04 	addi	sp,sp,-8
811077b0:	de00012e 	bgeu	sp,et,811077b8 <vRmapCh1IrqFlagClrWriteCmd+0xc>
811077b4:	003b68fa 	trap	3
811077b8:	dfc00115 	stw	ra,4(sp)
811077bc:	df000015 	stw	fp,0(sp)
811077c0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811077c4:	01800044 	movi	r6,1
811077c8:	014004c4 	movi	r5,19
811077cc:	01204834 	movhi	r4,33056
811077d0:	210b0004 	addi	r4,r4,11264
811077d4:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811077d8:	0001883a 	nop
811077dc:	e037883a 	mov	sp,fp
811077e0:	dfc00117 	ldw	ra,4(sp)
811077e4:	df000017 	ldw	fp,0(sp)
811077e8:	dec00204 	addi	sp,sp,8
811077ec:	f800283a 	ret

811077f0 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
811077f0:	defffe04 	addi	sp,sp,-8
811077f4:	de00012e 	bgeu	sp,et,811077fc <vRmapCh2IrqFlagClrWriteCmd+0xc>
811077f8:	003b68fa 	trap	3
811077fc:	dfc00115 	stw	ra,4(sp)
81107800:	df000015 	stw	fp,0(sp)
81107804:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107808:	01800044 	movi	r6,1
8110780c:	014004c4 	movi	r5,19
81107810:	01204834 	movhi	r4,33056
81107814:	210a0004 	addi	r4,r4,10240
81107818:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110781c:	0001883a 	nop
81107820:	e037883a 	mov	sp,fp
81107824:	dfc00117 	ldw	ra,4(sp)
81107828:	df000017 	ldw	fp,0(sp)
8110782c:	dec00204 	addi	sp,sp,8
81107830:	f800283a 	ret

81107834 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81107834:	defffe04 	addi	sp,sp,-8
81107838:	de00012e 	bgeu	sp,et,81107840 <vRmapCh3IrqFlagClrWriteCmd+0xc>
8110783c:	003b68fa 	trap	3
81107840:	dfc00115 	stw	ra,4(sp)
81107844:	df000015 	stw	fp,0(sp)
81107848:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110784c:	01800044 	movi	r6,1
81107850:	014004c4 	movi	r5,19
81107854:	01204834 	movhi	r4,33056
81107858:	210b0004 	addi	r4,r4,11264
8110785c:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107860:	0001883a 	nop
81107864:	e037883a 	mov	sp,fp
81107868:	dfc00117 	ldw	ra,4(sp)
8110786c:	df000017 	ldw	fp,0(sp)
81107870:	dec00204 	addi	sp,sp,8
81107874:	f800283a 	ret

81107878 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81107878:	defffe04 	addi	sp,sp,-8
8110787c:	de00012e 	bgeu	sp,et,81107884 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81107880:	003b68fa 	trap	3
81107884:	dfc00115 	stw	ra,4(sp)
81107888:	df000015 	stw	fp,0(sp)
8110788c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107890:	01800044 	movi	r6,1
81107894:	014004c4 	movi	r5,19
81107898:	01204834 	movhi	r4,33056
8110789c:	210a0004 	addi	r4,r4,10240
811078a0:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811078a4:	0001883a 	nop
811078a8:	e037883a 	mov	sp,fp
811078ac:	dfc00117 	ldw	ra,4(sp)
811078b0:	df000017 	ldw	fp,0(sp)
811078b4:	dec00204 	addi	sp,sp,8
811078b8:	f800283a 	ret

811078bc <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811078bc:	defffe04 	addi	sp,sp,-8
811078c0:	de00012e 	bgeu	sp,et,811078c8 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811078c4:	003b68fa 	trap	3
811078c8:	dfc00115 	stw	ra,4(sp)
811078cc:	df000015 	stw	fp,0(sp)
811078d0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811078d4:	01800044 	movi	r6,1
811078d8:	014004c4 	movi	r5,19
811078dc:	01204834 	movhi	r4,33056
811078e0:	210b0004 	addi	r4,r4,11264
811078e4:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811078e8:	0001883a 	nop
811078ec:	e037883a 	mov	sp,fp
811078f0:	dfc00117 	ldw	ra,4(sp)
811078f4:	df000017 	ldw	fp,0(sp)
811078f8:	dec00204 	addi	sp,sp,8
811078fc:	f800283a 	ret

81107900 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81107900:	defffe04 	addi	sp,sp,-8
81107904:	de00012e 	bgeu	sp,et,8110790c <vRmapCh6IrqFlagClrWriteCmd+0xc>
81107908:	003b68fa 	trap	3
8110790c:	dfc00115 	stw	ra,4(sp)
81107910:	df000015 	stw	fp,0(sp)
81107914:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107918:	01800044 	movi	r6,1
8110791c:	014004c4 	movi	r5,19
81107920:	01204834 	movhi	r4,33056
81107924:	210a0004 	addi	r4,r4,10240
81107928:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110792c:	0001883a 	nop
81107930:	e037883a 	mov	sp,fp
81107934:	dfc00117 	ldw	ra,4(sp)
81107938:	df000017 	ldw	fp,0(sp)
8110793c:	dec00204 	addi	sp,sp,8
81107940:	f800283a 	ret

81107944 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107944:	defffe04 	addi	sp,sp,-8
81107948:	de00012e 	bgeu	sp,et,81107950 <vRmapCh7IrqFlagClrWriteCmd+0xc>
8110794c:	003b68fa 	trap	3
81107950:	dfc00115 	stw	ra,4(sp)
81107954:	df000015 	stw	fp,0(sp)
81107958:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110795c:	01800044 	movi	r6,1
81107960:	014004c4 	movi	r5,19
81107964:	01204834 	movhi	r4,33056
81107968:	210b0004 	addi	r4,r4,11264
8110796c:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107970:	0001883a 	nop
81107974:	e037883a 	mov	sp,fp
81107978:	dfc00117 	ldw	ra,4(sp)
8110797c:	df000017 	ldw	fp,0(sp)
81107980:	dec00204 	addi	sp,sp,8
81107984:	f800283a 	ret

81107988 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
81107988:	defffe04 	addi	sp,sp,-8
8110798c:	de00012e 	bgeu	sp,et,81107994 <vRmapCh8IrqFlagClrWriteCmd+0xc>
81107990:	003b68fa 	trap	3
81107994:	dfc00115 	stw	ra,4(sp)
81107998:	df000015 	stw	fp,0(sp)
8110799c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811079a0:	01800044 	movi	r6,1
811079a4:	014004c4 	movi	r5,19
811079a8:	01204834 	movhi	r4,33056
811079ac:	210a0004 	addi	r4,r4,10240
811079b0:	110a8180 	call	8110a818 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811079b4:	0001883a 	nop
811079b8:	e037883a 	mov	sp,fp
811079bc:	dfc00117 	ldw	ra,4(sp)
811079c0:	df000017 	ldw	fp,0(sp)
811079c4:	dec00204 	addi	sp,sp,8
811079c8:	f800283a 	ret

811079cc <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811079cc:	defffd04 	addi	sp,sp,-12
811079d0:	de00012e 	bgeu	sp,et,811079d8 <bRmapCh1IrqFlagWriteCmd+0xc>
811079d4:	003b68fa 	trap	3
811079d8:	dfc00215 	stw	ra,8(sp)
811079dc:	df000115 	stw	fp,4(sp)
811079e0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811079e4:	01400484 	movi	r5,18
811079e8:	01204834 	movhi	r4,33056
811079ec:	210b0004 	addi	r4,r4,11264
811079f0:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811079f4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811079f8:	10000326 	beq	r2,zero,81107a08 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811079fc:	00800044 	movi	r2,1
81107a00:	e0bfff15 	stw	r2,-4(fp)
81107a04:	00000106 	br	81107a0c <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107a08:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107a0c:	e0bfff17 	ldw	r2,-4(fp)
}
81107a10:	e037883a 	mov	sp,fp
81107a14:	dfc00117 	ldw	ra,4(sp)
81107a18:	df000017 	ldw	fp,0(sp)
81107a1c:	dec00204 	addi	sp,sp,8
81107a20:	f800283a 	ret

81107a24 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107a24:	defffd04 	addi	sp,sp,-12
81107a28:	de00012e 	bgeu	sp,et,81107a30 <bRmapCh2IrqFlagWriteCmd+0xc>
81107a2c:	003b68fa 	trap	3
81107a30:	dfc00215 	stw	ra,8(sp)
81107a34:	df000115 	stw	fp,4(sp)
81107a38:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107a3c:	01400484 	movi	r5,18
81107a40:	01204834 	movhi	r4,33056
81107a44:	210a0004 	addi	r4,r4,10240
81107a48:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107a4c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107a50:	10000326 	beq	r2,zero,81107a60 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107a54:	00800044 	movi	r2,1
81107a58:	e0bfff15 	stw	r2,-4(fp)
81107a5c:	00000106 	br	81107a64 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107a60:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107a64:	e0bfff17 	ldw	r2,-4(fp)
}
81107a68:	e037883a 	mov	sp,fp
81107a6c:	dfc00117 	ldw	ra,4(sp)
81107a70:	df000017 	ldw	fp,0(sp)
81107a74:	dec00204 	addi	sp,sp,8
81107a78:	f800283a 	ret

81107a7c <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81107a7c:	defffd04 	addi	sp,sp,-12
81107a80:	de00012e 	bgeu	sp,et,81107a88 <bRmapCh3IrqFlagWriteCmd+0xc>
81107a84:	003b68fa 	trap	3
81107a88:	dfc00215 	stw	ra,8(sp)
81107a8c:	df000115 	stw	fp,4(sp)
81107a90:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107a94:	01400484 	movi	r5,18
81107a98:	01204834 	movhi	r4,33056
81107a9c:	210b0004 	addi	r4,r4,11264
81107aa0:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107aa4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107aa8:	10000326 	beq	r2,zero,81107ab8 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107aac:	00800044 	movi	r2,1
81107ab0:	e0bfff15 	stw	r2,-4(fp)
81107ab4:	00000106 	br	81107abc <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107ab8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107abc:	e0bfff17 	ldw	r2,-4(fp)
}
81107ac0:	e037883a 	mov	sp,fp
81107ac4:	dfc00117 	ldw	ra,4(sp)
81107ac8:	df000017 	ldw	fp,0(sp)
81107acc:	dec00204 	addi	sp,sp,8
81107ad0:	f800283a 	ret

81107ad4 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81107ad4:	defffd04 	addi	sp,sp,-12
81107ad8:	de00012e 	bgeu	sp,et,81107ae0 <bRmapCh4IrqFlagWriteCmd+0xc>
81107adc:	003b68fa 	trap	3
81107ae0:	dfc00215 	stw	ra,8(sp)
81107ae4:	df000115 	stw	fp,4(sp)
81107ae8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107aec:	01400484 	movi	r5,18
81107af0:	01204834 	movhi	r4,33056
81107af4:	210a0004 	addi	r4,r4,10240
81107af8:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107afc:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107b00:	10000326 	beq	r2,zero,81107b10 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107b04:	00800044 	movi	r2,1
81107b08:	e0bfff15 	stw	r2,-4(fp)
81107b0c:	00000106 	br	81107b14 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107b10:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107b14:	e0bfff17 	ldw	r2,-4(fp)
}
81107b18:	e037883a 	mov	sp,fp
81107b1c:	dfc00117 	ldw	ra,4(sp)
81107b20:	df000017 	ldw	fp,0(sp)
81107b24:	dec00204 	addi	sp,sp,8
81107b28:	f800283a 	ret

81107b2c <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107b2c:	defffd04 	addi	sp,sp,-12
81107b30:	de00012e 	bgeu	sp,et,81107b38 <bRmapCh5IrqFlagWriteCmd+0xc>
81107b34:	003b68fa 	trap	3
81107b38:	dfc00215 	stw	ra,8(sp)
81107b3c:	df000115 	stw	fp,4(sp)
81107b40:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107b44:	01400484 	movi	r5,18
81107b48:	01204834 	movhi	r4,33056
81107b4c:	210b0004 	addi	r4,r4,11264
81107b50:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107b54:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107b58:	10000326 	beq	r2,zero,81107b68 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107b5c:	00800044 	movi	r2,1
81107b60:	e0bfff15 	stw	r2,-4(fp)
81107b64:	00000106 	br	81107b6c <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107b68:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107b6c:	e0bfff17 	ldw	r2,-4(fp)
}
81107b70:	e037883a 	mov	sp,fp
81107b74:	dfc00117 	ldw	ra,4(sp)
81107b78:	df000017 	ldw	fp,0(sp)
81107b7c:	dec00204 	addi	sp,sp,8
81107b80:	f800283a 	ret

81107b84 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81107b84:	defffd04 	addi	sp,sp,-12
81107b88:	de00012e 	bgeu	sp,et,81107b90 <bRmapCh6IrqFlagWriteCmd+0xc>
81107b8c:	003b68fa 	trap	3
81107b90:	dfc00215 	stw	ra,8(sp)
81107b94:	df000115 	stw	fp,4(sp)
81107b98:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107b9c:	01400484 	movi	r5,18
81107ba0:	01204834 	movhi	r4,33056
81107ba4:	210a0004 	addi	r4,r4,10240
81107ba8:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107bac:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107bb0:	10000326 	beq	r2,zero,81107bc0 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107bb4:	00800044 	movi	r2,1
81107bb8:	e0bfff15 	stw	r2,-4(fp)
81107bbc:	00000106 	br	81107bc4 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107bc0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107bc4:	e0bfff17 	ldw	r2,-4(fp)
}
81107bc8:	e037883a 	mov	sp,fp
81107bcc:	dfc00117 	ldw	ra,4(sp)
81107bd0:	df000017 	ldw	fp,0(sp)
81107bd4:	dec00204 	addi	sp,sp,8
81107bd8:	f800283a 	ret

81107bdc <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81107bdc:	defffd04 	addi	sp,sp,-12
81107be0:	de00012e 	bgeu	sp,et,81107be8 <bRmapCh7IrqFlagWriteCmd+0xc>
81107be4:	003b68fa 	trap	3
81107be8:	dfc00215 	stw	ra,8(sp)
81107bec:	df000115 	stw	fp,4(sp)
81107bf0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107bf4:	01400484 	movi	r5,18
81107bf8:	01204834 	movhi	r4,33056
81107bfc:	210b0004 	addi	r4,r4,11264
81107c00:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107c04:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107c08:	10000326 	beq	r2,zero,81107c18 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107c0c:	00800044 	movi	r2,1
81107c10:	e0bfff15 	stw	r2,-4(fp)
81107c14:	00000106 	br	81107c1c <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107c18:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107c1c:	e0bfff17 	ldw	r2,-4(fp)
}
81107c20:	e037883a 	mov	sp,fp
81107c24:	dfc00117 	ldw	ra,4(sp)
81107c28:	df000017 	ldw	fp,0(sp)
81107c2c:	dec00204 	addi	sp,sp,8
81107c30:	f800283a 	ret

81107c34 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107c34:	defffd04 	addi	sp,sp,-12
81107c38:	de00012e 	bgeu	sp,et,81107c40 <bRmapCh8IrqFlagWriteCmd+0xc>
81107c3c:	003b68fa 	trap	3
81107c40:	dfc00215 	stw	ra,8(sp)
81107c44:	df000115 	stw	fp,4(sp)
81107c48:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107c4c:	01400484 	movi	r5,18
81107c50:	01204834 	movhi	r4,33056
81107c54:	210a0004 	addi	r4,r4,10240
81107c58:	110a86c0 	call	8110a86c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107c5c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107c60:	10000326 	beq	r2,zero,81107c70 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107c64:	00800044 	movi	r2,1
81107c68:	e0bfff15 	stw	r2,-4(fp)
81107c6c:	00000106 	br	81107c74 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107c70:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107c74:	e0bfff17 	ldw	r2,-4(fp)
}
81107c78:	e037883a 	mov	sp,fp
81107c7c:	dfc00117 	ldw	ra,4(sp)
81107c80:	df000017 	ldw	fp,0(sp)
81107c84:	dec00204 	addi	sp,sp,8
81107c88:	f800283a 	ret

81107c8c <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81107c8c:	defffd04 	addi	sp,sp,-12
81107c90:	de00012e 	bgeu	sp,et,81107c98 <uliRmapCh1WriteCmdAddress+0xc>
81107c94:	003b68fa 	trap	3
81107c98:	dfc00215 	stw	ra,8(sp)
81107c9c:	df000115 	stw	fp,4(sp)
81107ca0:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107ca4:	01400184 	movi	r5,6
81107ca8:	01204834 	movhi	r4,33056
81107cac:	210b0004 	addi	r4,r4,11264
81107cb0:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107cb4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107cb8:	e0bfff17 	ldw	r2,-4(fp)
81107cbc:	1009883a 	mov	r4,r2
81107cc0:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107cc4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107cc8:	e0bfff17 	ldw	r2,-4(fp)
}
81107ccc:	e037883a 	mov	sp,fp
81107cd0:	dfc00117 	ldw	ra,4(sp)
81107cd4:	df000017 	ldw	fp,0(sp)
81107cd8:	dec00204 	addi	sp,sp,8
81107cdc:	f800283a 	ret

81107ce0 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81107ce0:	defffd04 	addi	sp,sp,-12
81107ce4:	de00012e 	bgeu	sp,et,81107cec <uliRmapCh2WriteCmdAddress+0xc>
81107ce8:	003b68fa 	trap	3
81107cec:	dfc00215 	stw	ra,8(sp)
81107cf0:	df000115 	stw	fp,4(sp)
81107cf4:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107cf8:	01400184 	movi	r5,6
81107cfc:	01204834 	movhi	r4,33056
81107d00:	210a0004 	addi	r4,r4,10240
81107d04:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107d08:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107d0c:	e0bfff17 	ldw	r2,-4(fp)
81107d10:	1009883a 	mov	r4,r2
81107d14:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107d18:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107d1c:	e0bfff17 	ldw	r2,-4(fp)
}
81107d20:	e037883a 	mov	sp,fp
81107d24:	dfc00117 	ldw	ra,4(sp)
81107d28:	df000017 	ldw	fp,0(sp)
81107d2c:	dec00204 	addi	sp,sp,8
81107d30:	f800283a 	ret

81107d34 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107d34:	defffd04 	addi	sp,sp,-12
81107d38:	de00012e 	bgeu	sp,et,81107d40 <uliRmapCh3WriteCmdAddress+0xc>
81107d3c:	003b68fa 	trap	3
81107d40:	dfc00215 	stw	ra,8(sp)
81107d44:	df000115 	stw	fp,4(sp)
81107d48:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107d4c:	01400184 	movi	r5,6
81107d50:	01204834 	movhi	r4,33056
81107d54:	210b0004 	addi	r4,r4,11264
81107d58:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107d5c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107d60:	e0bfff17 	ldw	r2,-4(fp)
81107d64:	1009883a 	mov	r4,r2
81107d68:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107d6c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107d70:	e0bfff17 	ldw	r2,-4(fp)
}
81107d74:	e037883a 	mov	sp,fp
81107d78:	dfc00117 	ldw	ra,4(sp)
81107d7c:	df000017 	ldw	fp,0(sp)
81107d80:	dec00204 	addi	sp,sp,8
81107d84:	f800283a 	ret

81107d88 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
81107d88:	defffd04 	addi	sp,sp,-12
81107d8c:	de00012e 	bgeu	sp,et,81107d94 <uliRmapCh4WriteCmdAddress+0xc>
81107d90:	003b68fa 	trap	3
81107d94:	dfc00215 	stw	ra,8(sp)
81107d98:	df000115 	stw	fp,4(sp)
81107d9c:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107da0:	01400184 	movi	r5,6
81107da4:	01204834 	movhi	r4,33056
81107da8:	210a0004 	addi	r4,r4,10240
81107dac:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107db0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107db4:	e0bfff17 	ldw	r2,-4(fp)
81107db8:	1009883a 	mov	r4,r2
81107dbc:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107dc0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107dc4:	e0bfff17 	ldw	r2,-4(fp)
}
81107dc8:	e037883a 	mov	sp,fp
81107dcc:	dfc00117 	ldw	ra,4(sp)
81107dd0:	df000017 	ldw	fp,0(sp)
81107dd4:	dec00204 	addi	sp,sp,8
81107dd8:	f800283a 	ret

81107ddc <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81107ddc:	defffd04 	addi	sp,sp,-12
81107de0:	de00012e 	bgeu	sp,et,81107de8 <uliRmapCh5WriteCmdAddress+0xc>
81107de4:	003b68fa 	trap	3
81107de8:	dfc00215 	stw	ra,8(sp)
81107dec:	df000115 	stw	fp,4(sp)
81107df0:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107df4:	01400184 	movi	r5,6
81107df8:	01204834 	movhi	r4,33056
81107dfc:	210b0004 	addi	r4,r4,11264
81107e00:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107e04:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107e08:	e0bfff17 	ldw	r2,-4(fp)
81107e0c:	1009883a 	mov	r4,r2
81107e10:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107e14:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107e18:	e0bfff17 	ldw	r2,-4(fp)
}
81107e1c:	e037883a 	mov	sp,fp
81107e20:	dfc00117 	ldw	ra,4(sp)
81107e24:	df000017 	ldw	fp,0(sp)
81107e28:	dec00204 	addi	sp,sp,8
81107e2c:	f800283a 	ret

81107e30 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107e30:	defffd04 	addi	sp,sp,-12
81107e34:	de00012e 	bgeu	sp,et,81107e3c <uliRmapCh6WriteCmdAddress+0xc>
81107e38:	003b68fa 	trap	3
81107e3c:	dfc00215 	stw	ra,8(sp)
81107e40:	df000115 	stw	fp,4(sp)
81107e44:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107e48:	01400184 	movi	r5,6
81107e4c:	01204834 	movhi	r4,33056
81107e50:	210a0004 	addi	r4,r4,10240
81107e54:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107e58:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107e5c:	e0bfff17 	ldw	r2,-4(fp)
81107e60:	1009883a 	mov	r4,r2
81107e64:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107e68:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107e6c:	e0bfff17 	ldw	r2,-4(fp)
}
81107e70:	e037883a 	mov	sp,fp
81107e74:	dfc00117 	ldw	ra,4(sp)
81107e78:	df000017 	ldw	fp,0(sp)
81107e7c:	dec00204 	addi	sp,sp,8
81107e80:	f800283a 	ret

81107e84 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81107e84:	defffd04 	addi	sp,sp,-12
81107e88:	de00012e 	bgeu	sp,et,81107e90 <uliRmapCh7WriteCmdAddress+0xc>
81107e8c:	003b68fa 	trap	3
81107e90:	dfc00215 	stw	ra,8(sp)
81107e94:	df000115 	stw	fp,4(sp)
81107e98:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107e9c:	01400184 	movi	r5,6
81107ea0:	01204834 	movhi	r4,33056
81107ea4:	210b0004 	addi	r4,r4,11264
81107ea8:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107eac:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107eb0:	e0bfff17 	ldw	r2,-4(fp)
81107eb4:	1009883a 	mov	r4,r2
81107eb8:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107ebc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107ec0:	e0bfff17 	ldw	r2,-4(fp)
}
81107ec4:	e037883a 	mov	sp,fp
81107ec8:	dfc00117 	ldw	ra,4(sp)
81107ecc:	df000017 	ldw	fp,0(sp)
81107ed0:	dec00204 	addi	sp,sp,8
81107ed4:	f800283a 	ret

81107ed8 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81107ed8:	defffd04 	addi	sp,sp,-12
81107edc:	de00012e 	bgeu	sp,et,81107ee4 <uliRmapCh8WriteCmdAddress+0xc>
81107ee0:	003b68fa 	trap	3
81107ee4:	dfc00215 	stw	ra,8(sp)
81107ee8:	df000115 	stw	fp,4(sp)
81107eec:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107ef0:	01400184 	movi	r5,6
81107ef4:	01204834 	movhi	r4,33056
81107ef8:	210a0004 	addi	r4,r4,10240
81107efc:	110a86c0 	call	8110a86c <uliRmapReadReg>
81107f00:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107f04:	e0bfff17 	ldw	r2,-4(fp)
81107f08:	1009883a 	mov	r4,r2
81107f0c:	110a8bc0 	call	8110a8bc <uliConvRmapCfgAddr>
81107f10:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107f14:	e0bfff17 	ldw	r2,-4(fp)
}
81107f18:	e037883a 	mov	sp,fp
81107f1c:	dfc00117 	ldw	ra,4(sp)
81107f20:	df000017 	ldw	fp,0(sp)
81107f24:	dec00204 	addi	sp,sp,8
81107f28:	f800283a 	ret

81107f2c <vRmapInitIrq>:

bool vRmapInitIrq(alt_u8 ucCommCh) {
81107f2c:	defffb04 	addi	sp,sp,-20
81107f30:	de00012e 	bgeu	sp,et,81107f38 <vRmapInitIrq+0xc>
81107f34:	003b68fa 	trap	3
81107f38:	dfc00415 	stw	ra,16(sp)
81107f3c:	df000315 	stw	fp,12(sp)
81107f40:	df000304 	addi	fp,sp,12
81107f44:	2005883a 	mov	r2,r4
81107f48:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81107f4c:	e03ffd15 	stw	zero,-12(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107f50:	e0bfff03 	ldbu	r2,-4(fp)
81107f54:	10c00228 	cmpgeui	r3,r2,8
81107f58:	18005e1e 	bne	r3,zero,811080d4 <vRmapInitIrq+0x1a8>
81107f5c:	100690ba 	slli	r3,r2,2
81107f60:	00a04434 	movhi	r2,33040
81107f64:	109fdd04 	addi	r2,r2,32628
81107f68:	1885883a 	add	r2,r3,r2
81107f6c:	10800017 	ldw	r2,0(r2)
81107f70:	1000683a 	jmp	r2
81107f74:	81107f94 	ori	r4,r16,16894
81107f78:	81107fbc 	xorhi	r4,r16,16894
81107f7c:	81107fe4 	muli	r4,r16,16895
81107f80:	8110800c 	andi	r4,r16,16896
81107f84:	81108034 	orhi	r4,r16,16896
81107f88:	8110805c 	xori	r4,r16,16897
81107f8c:	81108084 	addi	r4,r16,16898
81107f90:	811080ac 	andhi	r4,r16,16898
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81107f94:	d0a04804 	addi	r2,gp,-32480
81107f98:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81107f9c:	01a04434 	movhi	r6,33040
81107fa0:	319d2104 	addi	r6,r6,29828
81107fa4:	e17ffe17 	ldw	r5,-8(fp)
81107fa8:	010005c4 	movi	r4,23
81107fac:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
81107fb0:	00800044 	movi	r2,1
81107fb4:	e0bffd15 	stw	r2,-12(fp)
		break;
81107fb8:	00004806 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81107fbc:	d0a04904 	addi	r2,gp,-32476
81107fc0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81107fc4:	01a04434 	movhi	r6,33040
81107fc8:	319d5c04 	addi	r6,r6,30064
81107fcc:	e17ffe17 	ldw	r5,-8(fp)
81107fd0:	01000544 	movi	r4,21
81107fd4:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
81107fd8:	00800044 	movi	r2,1
81107fdc:	e0bffd15 	stw	r2,-12(fp)
		break;
81107fe0:	00003e06 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81107fe4:	d0a04a04 	addi	r2,gp,-32472
81107fe8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81107fec:	01a04434 	movhi	r6,33040
81107ff0:	319d9704 	addi	r6,r6,30300
81107ff4:	e17ffe17 	ldw	r5,-8(fp)
81107ff8:	010004c4 	movi	r4,19
81107ffc:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
81108000:	00800044 	movi	r2,1
81108004:	e0bffd15 	stw	r2,-12(fp)
		break;
81108008:	00003406 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
8110800c:	d0a04b04 	addi	r2,gp,-32468
81108010:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81108014:	01a04434 	movhi	r6,33040
81108018:	319da504 	addi	r6,r6,30356
8110801c:	e17ffe17 	ldw	r5,-8(fp)
81108020:	01000444 	movi	r4,17
81108024:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
81108028:	00800044 	movi	r2,1
8110802c:	e0bffd15 	stw	r2,-12(fp)
		break;
81108030:	00002a06 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81108034:	d0a04c04 	addi	r2,gp,-32464
81108038:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
8110803c:	01a04434 	movhi	r6,33040
81108040:	319db304 	addi	r6,r6,30412
81108044:	e17ffe17 	ldw	r5,-8(fp)
81108048:	01000244 	movi	r4,9
8110804c:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
81108050:	00800044 	movi	r2,1
81108054:	e0bffd15 	stw	r2,-12(fp)
		break;
81108058:	00002006 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110805c:	d0a04d04 	addi	r2,gp,-32460
81108060:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81108064:	01a04434 	movhi	r6,33040
81108068:	319dc104 	addi	r6,r6,30468
8110806c:	e17ffe17 	ldw	r5,-8(fp)
81108070:	010001c4 	movi	r4,7
81108074:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
81108078:	00800044 	movi	r2,1
8110807c:	e0bffd15 	stw	r2,-12(fp)
		break;
81108080:	00001606 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81108084:	d0a04e04 	addi	r2,gp,-32456
81108088:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
8110808c:	01a04434 	movhi	r6,33040
81108090:	319dcf04 	addi	r6,r6,30524
81108094:	e17ffe17 	ldw	r5,-8(fp)
81108098:	01000104 	movi	r4,4
8110809c:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
811080a0:	00800044 	movi	r2,1
811080a4:	e0bffd15 	stw	r2,-12(fp)
		break;
811080a8:	00000c06 	br	811080dc <vRmapInitIrq+0x1b0>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
811080ac:	d0a04f04 	addi	r2,gp,-32452
811080b0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
811080b4:	01a04434 	movhi	r6,33040
811080b8:	319ddd04 	addi	r6,r6,30580
811080bc:	e17ffe17 	ldw	r5,-8(fp)
811080c0:	010000c4 	movi	r4,3
811080c4:	11386380 	call	81138638 <alt_irq_register>
		bStatus = TRUE;
811080c8:	00800044 	movi	r2,1
811080cc:	e0bffd15 	stw	r2,-12(fp)
		break;
811080d0:	00000206 	br	811080dc <vRmapInitIrq+0x1b0>
	default:
		bStatus = FALSE;
811080d4:	e03ffd15 	stw	zero,-12(fp)
		break;
811080d8:	0001883a 	nop
	}

	return bStatus;
811080dc:	e0bffd17 	ldw	r2,-12(fp)
}
811080e0:	e037883a 	mov	sp,fp
811080e4:	dfc00117 	ldw	ra,4(sp)
811080e8:	df000017 	ldw	fp,0(sp)
811080ec:	dec00204 	addi	sp,sp,8
811080f0:	f800283a 	ret

811080f4 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811080f4:	defffb04 	addi	sp,sp,-20
811080f8:	de00012e 	bgeu	sp,et,81108100 <bRmapSetIrqControl+0xc>
811080fc:	003b68fa 	trap	3
81108100:	dfc00415 	stw	ra,16(sp)
81108104:	df000315 	stw	fp,12(sp)
81108108:	df000304 	addi	fp,sp,12
8110810c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108110:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108114:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10001a26 	beq	r2,zero,81108188 <bRmapSetIrqControl+0x94>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108120:	e0bfff17 	ldw	r2,-4(fp)
81108124:	10800017 	ldw	r2,0(r2)
81108128:	01400444 	movi	r5,17
8110812c:	1009883a 	mov	r4,r2
81108130:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108134:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81108138:	e0bfff17 	ldw	r2,-4(fp)
8110813c:	10801017 	ldw	r2,64(r2)
81108140:	10000426 	beq	r2,zero,81108154 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81108144:	e0bffe17 	ldw	r2,-8(fp)
81108148:	10800054 	ori	r2,r2,1
8110814c:	e0bffe15 	stw	r2,-8(fp)
81108150:	00000406 	br	81108164 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81108154:	e0fffe17 	ldw	r3,-8(fp)
81108158:	00bfff84 	movi	r2,-2
8110815c:	1884703a 	and	r2,r3,r2
81108160:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81108164:	e0bfff17 	ldw	r2,-4(fp)
81108168:	10800017 	ldw	r2,0(r2)
8110816c:	e0fffe17 	ldw	r3,-8(fp)
81108170:	180d883a 	mov	r6,r3
81108174:	01400444 	movi	r5,17
81108178:	1009883a 	mov	r4,r2
8110817c:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81108180:	00800044 	movi	r2,1
81108184:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108188:	e0bffd17 	ldw	r2,-12(fp)
}
8110818c:	e037883a 	mov	sp,fp
81108190:	dfc00117 	ldw	ra,4(sp)
81108194:	df000017 	ldw	fp,0(sp)
81108198:	dec00204 	addi	sp,sp,8
8110819c:	f800283a 	ret

811081a0 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
811081a0:	defffb04 	addi	sp,sp,-20
811081a4:	de00012e 	bgeu	sp,et,811081ac <bRmapGetIrqControl+0xc>
811081a8:	003b68fa 	trap	3
811081ac:	dfc00415 	stw	ra,16(sp)
811081b0:	df000315 	stw	fp,12(sp)
811081b4:	df000304 	addi	fp,sp,12
811081b8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811081bc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811081c0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811081c4:	e0bfff17 	ldw	r2,-4(fp)
811081c8:	10001126 	beq	r2,zero,81108210 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081cc:	e0bfff17 	ldw	r2,-4(fp)
811081d0:	10800017 	ldw	r2,0(r2)
811081d4:	01400444 	movi	r5,17
811081d8:	1009883a 	mov	r4,r2
811081dc:	110a86c0 	call	8110a86c <uliRmapReadReg>
811081e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811081e4:	e0bffe17 	ldw	r2,-8(fp)
811081e8:	1080004c 	andi	r2,r2,1
811081ec:	10000426 	beq	r2,zero,81108200 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811081f0:	e0bfff17 	ldw	r2,-4(fp)
811081f4:	00c00044 	movi	r3,1
811081f8:	10c01015 	stw	r3,64(r2)
811081fc:	00000206 	br	81108208 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81108200:	e0bfff17 	ldw	r2,-4(fp)
81108204:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81108208:	00800044 	movi	r2,1
8110820c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108210:	e0bffd17 	ldw	r2,-12(fp)
}
81108214:	e037883a 	mov	sp,fp
81108218:	dfc00117 	ldw	ra,4(sp)
8110821c:	df000017 	ldw	fp,0(sp)
81108220:	dec00204 	addi	sp,sp,8
81108224:	f800283a 	ret

81108228 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81108228:	defffb04 	addi	sp,sp,-20
8110822c:	de00012e 	bgeu	sp,et,81108234 <bRmapGetIrqFlags+0xc>
81108230:	003b68fa 	trap	3
81108234:	dfc00415 	stw	ra,16(sp)
81108238:	df000315 	stw	fp,12(sp)
8110823c:	df000304 	addi	fp,sp,12
81108240:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108244:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108248:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110824c:	e0bfff17 	ldw	r2,-4(fp)
81108250:	10001126 	beq	r2,zero,81108298 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108254:	e0bfff17 	ldw	r2,-4(fp)
81108258:	10800017 	ldw	r2,0(r2)
8110825c:	01400484 	movi	r5,18
81108260:	1009883a 	mov	r4,r2
81108264:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108268:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110826c:	e0bffe17 	ldw	r2,-8(fp)
81108270:	1080004c 	andi	r2,r2,1
81108274:	10000426 	beq	r2,zero,81108288 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81108278:	e0bfff17 	ldw	r2,-4(fp)
8110827c:	00c00044 	movi	r3,1
81108280:	10c01115 	stw	r3,68(r2)
81108284:	00000206 	br	81108290 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81108288:	e0bfff17 	ldw	r2,-4(fp)
8110828c:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81108290:	00800044 	movi	r2,1
81108294:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108298:	e0bffd17 	ldw	r2,-12(fp)
}
8110829c:	e037883a 	mov	sp,fp
811082a0:	dfc00117 	ldw	ra,4(sp)
811082a4:	df000017 	ldw	fp,0(sp)
811082a8:	dec00204 	addi	sp,sp,8
811082ac:	f800283a 	ret

811082b0 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
811082b0:	defffb04 	addi	sp,sp,-20
811082b4:	de00012e 	bgeu	sp,et,811082bc <bRmapSetCodecConfig+0xc>
811082b8:	003b68fa 	trap	3
811082bc:	dfc00415 	stw	ra,16(sp)
811082c0:	df000315 	stw	fp,12(sp)
811082c4:	df000304 	addi	fp,sp,12
811082c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811082cc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811082d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811082d4:	e0bfff17 	ldw	r2,-4(fp)
811082d8:	10002626 	beq	r2,zero,81108374 <bRmapSetCodecConfig+0xc4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082dc:	e0bfff17 	ldw	r2,-4(fp)
811082e0:	10800017 	ldw	r2,0(r2)
811082e4:	01400104 	movi	r5,4
811082e8:	1009883a 	mov	r4,r2
811082ec:	110a86c0 	call	8110a86c <uliRmapReadReg>
811082f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
811082f4:	e0fffe17 	ldw	r3,-8(fp)
811082f8:	00bfc004 	movi	r2,-256
811082fc:	1884703a 	and	r2,r3,r2
81108300:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81108304:	e0bfff17 	ldw	r2,-4(fp)
81108308:	10800143 	ldbu	r2,5(r2)
8110830c:	10c03fcc 	andi	r3,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81108310:	e0bffe17 	ldw	r2,-8(fp)
81108314:	1884b03a 	or	r2,r3,r2
81108318:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
8110831c:	e0fffe17 	ldw	r3,-8(fp)
81108320:	00bffff4 	movhi	r2,65535
81108324:	10803fc4 	addi	r2,r2,255
81108328:	1884703a 	and	r2,r3,r2
8110832c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81108330:	e0bfff17 	ldw	r2,-4(fp)
81108334:	10800103 	ldbu	r2,4(r2)
81108338:	10803fcc 	andi	r2,r2,255
8110833c:	1004923a 	slli	r2,r2,8
81108340:	10ffffcc 	andi	r3,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81108344:	e0bffe17 	ldw	r2,-8(fp)
81108348:	1884b03a 	or	r2,r3,r2
8110834c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81108350:	e0bfff17 	ldw	r2,-4(fp)
81108354:	10800017 	ldw	r2,0(r2)
81108358:	e0fffe17 	ldw	r3,-8(fp)
8110835c:	180d883a 	mov	r6,r3
81108360:	01400104 	movi	r5,4
81108364:	1009883a 	mov	r4,r2
81108368:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
8110836c:	00800044 	movi	r2,1
81108370:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108374:	e0bffd17 	ldw	r2,-12(fp)
}
81108378:	e037883a 	mov	sp,fp
8110837c:	dfc00117 	ldw	ra,4(sp)
81108380:	df000017 	ldw	fp,0(sp)
81108384:	dec00204 	addi	sp,sp,8
81108388:	f800283a 	ret

8110838c <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
8110838c:	defffb04 	addi	sp,sp,-20
81108390:	de00012e 	bgeu	sp,et,81108398 <bRmapGetCodecConfig+0xc>
81108394:	003b68fa 	trap	3
81108398:	dfc00415 	stw	ra,16(sp)
8110839c:	df000315 	stw	fp,12(sp)
811083a0:	df000304 	addi	fp,sp,12
811083a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811083a8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811083ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811083b0:	e0bfff17 	ldw	r2,-4(fp)
811083b4:	10001226 	beq	r2,zero,81108400 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083b8:	e0bfff17 	ldw	r2,-4(fp)
811083bc:	10800017 	ldw	r2,0(r2)
811083c0:	01400104 	movi	r5,4
811083c4:	1009883a 	mov	r4,r2
811083c8:	110a86c0 	call	8110a86c <uliRmapReadReg>
811083cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
811083d0:	e0bffe17 	ldw	r2,-8(fp)
811083d4:	1007883a 	mov	r3,r2
811083d8:	e0bfff17 	ldw	r2,-4(fp)
811083dc:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
811083e0:	e0bffe17 	ldw	r2,-8(fp)
811083e4:	10bfc00c 	andi	r2,r2,65280
811083e8:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
811083ec:	1007883a 	mov	r3,r2
811083f0:	e0bfff17 	ldw	r2,-4(fp)
811083f4:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
811083f8:	00800044 	movi	r2,1
811083fc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108400:	e0bffd17 	ldw	r2,-12(fp)
}
81108404:	e037883a 	mov	sp,fp
81108408:	dfc00117 	ldw	ra,4(sp)
8110840c:	df000017 	ldw	fp,0(sp)
81108410:	dec00204 	addi	sp,sp,8
81108414:	f800283a 	ret

81108418 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81108418:	defffb04 	addi	sp,sp,-20
8110841c:	de00012e 	bgeu	sp,et,81108424 <bRmapGetCodecStatus+0xc>
81108420:	003b68fa 	trap	3
81108424:	dfc00415 	stw	ra,16(sp)
81108428:	df000315 	stw	fp,12(sp)
8110842c:	df000304 	addi	fp,sp,12
81108430:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108434:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108438:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110843c:	e0bfff17 	ldw	r2,-4(fp)
81108440:	10004726 	beq	r2,zero,81108560 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108444:	e0bfff17 	ldw	r2,-4(fp)
81108448:	10800017 	ldw	r2,0(r2)
8110844c:	01400144 	movi	r5,5
81108450:	1009883a 	mov	r4,r2
81108454:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108458:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
8110845c:	e0bffe17 	ldw	r2,-8(fp)
81108460:	1080004c 	andi	r2,r2,1
81108464:	10000426 	beq	r2,zero,81108478 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81108468:	e0bfff17 	ldw	r2,-4(fp)
8110846c:	00c00044 	movi	r3,1
81108470:	10c00215 	stw	r3,8(r2)
81108474:	00000206 	br	81108480 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81108478:	e0bfff17 	ldw	r2,-4(fp)
8110847c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81108480:	e0bffe17 	ldw	r2,-8(fp)
81108484:	1080008c 	andi	r2,r2,2
81108488:	10000426 	beq	r2,zero,8110849c <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
8110848c:	e0bfff17 	ldw	r2,-4(fp)
81108490:	00c00044 	movi	r3,1
81108494:	10c00315 	stw	r3,12(r2)
81108498:	00000206 	br	811084a4 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
8110849c:	e0bfff17 	ldw	r2,-4(fp)
811084a0:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
811084a4:	e0bffe17 	ldw	r2,-8(fp)
811084a8:	1080010c 	andi	r2,r2,4
811084ac:	10000426 	beq	r2,zero,811084c0 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
811084b0:	e0bfff17 	ldw	r2,-4(fp)
811084b4:	00c00044 	movi	r3,1
811084b8:	10c00415 	stw	r3,16(r2)
811084bc:	00000206 	br	811084c8 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
811084c0:	e0bfff17 	ldw	r2,-4(fp)
811084c4:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
811084c8:	e0bffe17 	ldw	r2,-8(fp)
811084cc:	1080020c 	andi	r2,r2,8
811084d0:	10000426 	beq	r2,zero,811084e4 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
811084d4:	e0bfff17 	ldw	r2,-4(fp)
811084d8:	00c00044 	movi	r3,1
811084dc:	10c00515 	stw	r3,20(r2)
811084e0:	00000206 	br	811084ec <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
811084e4:	e0bfff17 	ldw	r2,-4(fp)
811084e8:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
811084ec:	e0bffe17 	ldw	r2,-8(fp)
811084f0:	1080040c 	andi	r2,r2,16
811084f4:	10000426 	beq	r2,zero,81108508 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
811084f8:	e0bfff17 	ldw	r2,-4(fp)
811084fc:	00c00044 	movi	r3,1
81108500:	10c00615 	stw	r3,24(r2)
81108504:	00000206 	br	81108510 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81108508:	e0bfff17 	ldw	r2,-4(fp)
8110850c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81108510:	e0bffe17 	ldw	r2,-8(fp)
81108514:	1080080c 	andi	r2,r2,32
81108518:	10000426 	beq	r2,zero,8110852c <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
8110851c:	e0bfff17 	ldw	r2,-4(fp)
81108520:	00c00044 	movi	r3,1
81108524:	10c00715 	stw	r3,28(r2)
81108528:	00000206 	br	81108534 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
8110852c:	e0bfff17 	ldw	r2,-4(fp)
81108530:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81108534:	e0bffe17 	ldw	r2,-8(fp)
81108538:	1080100c 	andi	r2,r2,64
8110853c:	10000426 	beq	r2,zero,81108550 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81108540:	e0bfff17 	ldw	r2,-4(fp)
81108544:	00c00044 	movi	r3,1
81108548:	10c00815 	stw	r3,32(r2)
8110854c:	00000206 	br	81108558 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81108550:	e0bfff17 	ldw	r2,-4(fp)
81108554:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81108558:	00800044 	movi	r2,1
8110855c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108560:	e0bffd17 	ldw	r2,-12(fp)
}
81108564:	e037883a 	mov	sp,fp
81108568:	dfc00117 	ldw	ra,4(sp)
8110856c:	df000017 	ldw	fp,0(sp)
81108570:	dec00204 	addi	sp,sp,8
81108574:	f800283a 	ret

81108578 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81108578:	defffb04 	addi	sp,sp,-20
8110857c:	de00012e 	bgeu	sp,et,81108584 <bRmapGetCodecError+0xc>
81108580:	003b68fa 	trap	3
81108584:	dfc00415 	stw	ra,16(sp)
81108588:	df000315 	stw	fp,12(sp)
8110858c:	df000304 	addi	fp,sp,12
81108590:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108594:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108598:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110859c:	e0bfff17 	ldw	r2,-4(fp)
811085a0:	10004726 	beq	r2,zero,811086c0 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085a4:	e0bfff17 	ldw	r2,-4(fp)
811085a8:	10800017 	ldw	r2,0(r2)
811085ac:	01400144 	movi	r5,5
811085b0:	1009883a 	mov	r4,r2
811085b4:	110a86c0 	call	8110a86c <uliRmapReadReg>
811085b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
811085bc:	e0bffe17 	ldw	r2,-8(fp)
811085c0:	1080006c 	andhi	r2,r2,1
811085c4:	10000426 	beq	r2,zero,811085d8 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
811085c8:	e0bfff17 	ldw	r2,-4(fp)
811085cc:	00c00044 	movi	r3,1
811085d0:	10c00915 	stw	r3,36(r2)
811085d4:	00000206 	br	811085e0 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
811085d8:	e0bfff17 	ldw	r2,-4(fp)
811085dc:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
811085e0:	e0bffe17 	ldw	r2,-8(fp)
811085e4:	108000ac 	andhi	r2,r2,2
811085e8:	10000426 	beq	r2,zero,811085fc <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
811085ec:	e0bfff17 	ldw	r2,-4(fp)
811085f0:	00c00044 	movi	r3,1
811085f4:	10c00a15 	stw	r3,40(r2)
811085f8:	00000206 	br	81108604 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
811085fc:	e0bfff17 	ldw	r2,-4(fp)
81108600:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81108604:	e0bffe17 	ldw	r2,-8(fp)
81108608:	1080012c 	andhi	r2,r2,4
8110860c:	10000426 	beq	r2,zero,81108620 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81108610:	e0bfff17 	ldw	r2,-4(fp)
81108614:	00c00044 	movi	r3,1
81108618:	10c00b15 	stw	r3,44(r2)
8110861c:	00000206 	br	81108628 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81108620:	e0bfff17 	ldw	r2,-4(fp)
81108624:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81108628:	e0bffe17 	ldw	r2,-8(fp)
8110862c:	1080022c 	andhi	r2,r2,8
81108630:	10000426 	beq	r2,zero,81108644 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81108634:	e0bfff17 	ldw	r2,-4(fp)
81108638:	00c00044 	movi	r3,1
8110863c:	10c00c15 	stw	r3,48(r2)
81108640:	00000206 	br	8110864c <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81108644:	e0bfff17 	ldw	r2,-4(fp)
81108648:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
8110864c:	e0bffe17 	ldw	r2,-8(fp)
81108650:	1080042c 	andhi	r2,r2,16
81108654:	10000426 	beq	r2,zero,81108668 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81108658:	e0bfff17 	ldw	r2,-4(fp)
8110865c:	00c00044 	movi	r3,1
81108660:	10c00d15 	stw	r3,52(r2)
81108664:	00000206 	br	81108670 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81108668:	e0bfff17 	ldw	r2,-4(fp)
8110866c:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81108670:	e0bffe17 	ldw	r2,-8(fp)
81108674:	1080082c 	andhi	r2,r2,32
81108678:	10000426 	beq	r2,zero,8110868c <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
8110867c:	e0bfff17 	ldw	r2,-4(fp)
81108680:	00c00044 	movi	r3,1
81108684:	10c00e15 	stw	r3,56(r2)
81108688:	00000206 	br	81108694 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
8110868c:	e0bfff17 	ldw	r2,-4(fp)
81108690:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81108694:	e0bffe17 	ldw	r2,-8(fp)
81108698:	1080102c 	andhi	r2,r2,64
8110869c:	10000426 	beq	r2,zero,811086b0 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
811086a0:	e0bfff17 	ldw	r2,-4(fp)
811086a4:	00c00044 	movi	r3,1
811086a8:	10c00f15 	stw	r3,60(r2)
811086ac:	00000206 	br	811086b8 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
811086b0:	e0bfff17 	ldw	r2,-4(fp)
811086b4:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
811086b8:	00800044 	movi	r2,1
811086bc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811086c0:	e0bffd17 	ldw	r2,-12(fp)
}
811086c4:	e037883a 	mov	sp,fp
811086c8:	dfc00117 	ldw	ra,4(sp)
811086cc:	df000017 	ldw	fp,0(sp)
811086d0:	dec00204 	addi	sp,sp,8
811086d4:	f800283a 	ret

811086d8 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
811086d8:	defffb04 	addi	sp,sp,-20
811086dc:	de00012e 	bgeu	sp,et,811086e4 <bRmapSetMemConfigArea+0xc>
811086e0:	003b68fa 	trap	3
811086e4:	dfc00415 	stw	ra,16(sp)
811086e8:	df000315 	stw	fp,12(sp)
811086ec:	df000304 	addi	fp,sp,12
811086f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811086f4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811086f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811086fc:	e0bfff17 	ldw	r2,-4(fp)
81108700:	1000bc26 	beq	r2,zero,811089f4 <bRmapSetMemConfigArea+0x31c>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81108704:	e0bfff17 	ldw	r2,-4(fp)
81108708:	10801217 	ldw	r2,72(r2)
8110870c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108710:	e0bfff17 	ldw	r2,-4(fp)
81108714:	10800017 	ldw	r2,0(r2)
81108718:	e0fffe17 	ldw	r3,-8(fp)
8110871c:	180d883a 	mov	r6,r3
81108720:	01401004 	movi	r5,64
81108724:	1009883a 	mov	r4,r2
81108728:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
8110872c:	e0bfff17 	ldw	r2,-4(fp)
81108730:	10801317 	ldw	r2,76(r2)
81108734:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108738:	e0bfff17 	ldw	r2,-4(fp)
8110873c:	10800017 	ldw	r2,0(r2)
81108740:	e0fffe17 	ldw	r3,-8(fp)
81108744:	180d883a 	mov	r6,r3
81108748:	01401044 	movi	r5,65
8110874c:	1009883a 	mov	r4,r2
81108750:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81108754:	e0bfff17 	ldw	r2,-4(fp)
81108758:	10801417 	ldw	r2,80(r2)
8110875c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108760:	e0bfff17 	ldw	r2,-4(fp)
81108764:	10800017 	ldw	r2,0(r2)
81108768:	e0fffe17 	ldw	r3,-8(fp)
8110876c:	180d883a 	mov	r6,r3
81108770:	01401084 	movi	r5,66
81108774:	1009883a 	mov	r4,r2
81108778:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
8110877c:	e0bfff17 	ldw	r2,-4(fp)
81108780:	10801517 	ldw	r2,84(r2)
81108784:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108788:	e0bfff17 	ldw	r2,-4(fp)
8110878c:	10800017 	ldw	r2,0(r2)
81108790:	e0fffe17 	ldw	r3,-8(fp)
81108794:	180d883a 	mov	r6,r3
81108798:	014010c4 	movi	r5,67
8110879c:	1009883a 	mov	r4,r2
811087a0:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811087a4:	e0bfff17 	ldw	r2,-4(fp)
811087a8:	10802217 	ldw	r2,136(r2)
811087ac:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811087b0:	e0bfff17 	ldw	r2,-4(fp)
811087b4:	10800017 	ldw	r2,0(r2)
811087b8:	e0fffe17 	ldw	r3,-8(fp)
811087bc:	180d883a 	mov	r6,r3
811087c0:	01401104 	movi	r5,68
811087c4:	1009883a 	mov	r4,r2
811087c8:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
811087cc:	e0bfff17 	ldw	r2,-4(fp)
811087d0:	10801717 	ldw	r2,92(r2)
811087d4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811087d8:	e0bfff17 	ldw	r2,-4(fp)
811087dc:	10800017 	ldw	r2,0(r2)
811087e0:	e0fffe17 	ldw	r3,-8(fp)
811087e4:	180d883a 	mov	r6,r3
811087e8:	01401144 	movi	r5,69
811087ec:	1009883a 	mov	r4,r2
811087f0:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
811087f4:	e0bfff17 	ldw	r2,-4(fp)
811087f8:	10801817 	ldw	r2,96(r2)
811087fc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108800:	e0bfff17 	ldw	r2,-4(fp)
81108804:	10800017 	ldw	r2,0(r2)
81108808:	e0fffe17 	ldw	r3,-8(fp)
8110880c:	180d883a 	mov	r6,r3
81108810:	01401184 	movi	r5,70
81108814:	1009883a 	mov	r4,r2
81108818:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
8110881c:	e0bfff17 	ldw	r2,-4(fp)
81108820:	10801917 	ldw	r2,100(r2)
81108824:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108828:	e0bfff17 	ldw	r2,-4(fp)
8110882c:	10800017 	ldw	r2,0(r2)
81108830:	e0fffe17 	ldw	r3,-8(fp)
81108834:	180d883a 	mov	r6,r3
81108838:	014011c4 	movi	r5,71
8110883c:	1009883a 	mov	r4,r2
81108840:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81108844:	e0bfff17 	ldw	r2,-4(fp)
81108848:	10801a17 	ldw	r2,104(r2)
8110884c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108850:	e0bfff17 	ldw	r2,-4(fp)
81108854:	10800017 	ldw	r2,0(r2)
81108858:	e0fffe17 	ldw	r3,-8(fp)
8110885c:	180d883a 	mov	r6,r3
81108860:	01401204 	movi	r5,72
81108864:	1009883a 	mov	r4,r2
81108868:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
8110886c:	e0bfff17 	ldw	r2,-4(fp)
81108870:	10801b17 	ldw	r2,108(r2)
81108874:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108878:	e0bfff17 	ldw	r2,-4(fp)
8110887c:	10800017 	ldw	r2,0(r2)
81108880:	e0fffe17 	ldw	r3,-8(fp)
81108884:	180d883a 	mov	r6,r3
81108888:	01401244 	movi	r5,73
8110888c:	1009883a 	mov	r4,r2
81108890:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108894:	e0bfff17 	ldw	r2,-4(fp)
81108898:	10800017 	ldw	r2,0(r2)
8110889c:	01401284 	movi	r5,74
811088a0:	1009883a 	mov	r4,r2
811088a4:	110a86c0 	call	8110a86c <uliRmapReadReg>
811088a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
811088ac:	e0bfff17 	ldw	r2,-4(fp)
811088b0:	10801c17 	ldw	r2,112(r2)
811088b4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811088b8:	e0bfff17 	ldw	r2,-4(fp)
811088bc:	10800017 	ldw	r2,0(r2)
811088c0:	e0fffe17 	ldw	r3,-8(fp)
811088c4:	180d883a 	mov	r6,r3
811088c8:	01401284 	movi	r5,74
811088cc:	1009883a 	mov	r4,r2
811088d0:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
811088d4:	e0bfff17 	ldw	r2,-4(fp)
811088d8:	10801d17 	ldw	r2,116(r2)
811088dc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811088e0:	e0bfff17 	ldw	r2,-4(fp)
811088e4:	10800017 	ldw	r2,0(r2)
811088e8:	e0fffe17 	ldw	r3,-8(fp)
811088ec:	180d883a 	mov	r6,r3
811088f0:	014012c4 	movi	r5,75
811088f4:	1009883a 	mov	r4,r2
811088f8:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
811088fc:	e0bfff17 	ldw	r2,-4(fp)
81108900:	10801e17 	ldw	r2,120(r2)
81108904:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81108908:	e0bfff17 	ldw	r2,-4(fp)
8110890c:	10800017 	ldw	r2,0(r2)
81108910:	e0fffe17 	ldw	r3,-8(fp)
81108914:	180d883a 	mov	r6,r3
81108918:	01401304 	movi	r5,76
8110891c:	1009883a 	mov	r4,r2
81108920:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81108924:	e0bfff17 	ldw	r2,-4(fp)
81108928:	10801f17 	ldw	r2,124(r2)
8110892c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81108930:	e0bfff17 	ldw	r2,-4(fp)
81108934:	10800017 	ldw	r2,0(r2)
81108938:	e0fffe17 	ldw	r3,-8(fp)
8110893c:	180d883a 	mov	r6,r3
81108940:	01401344 	movi	r5,77
81108944:	1009883a 	mov	r4,r2
81108948:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
8110894c:	e0bfff17 	ldw	r2,-4(fp)
81108950:	10802017 	ldw	r2,128(r2)
81108954:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81108958:	e0bfff17 	ldw	r2,-4(fp)
8110895c:	10800017 	ldw	r2,0(r2)
81108960:	e0fffe17 	ldw	r3,-8(fp)
81108964:	180d883a 	mov	r6,r3
81108968:	01401384 	movi	r5,78
8110896c:	1009883a 	mov	r4,r2
81108970:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81108974:	e0bfff17 	ldw	r2,-4(fp)
81108978:	10802217 	ldw	r2,136(r2)
8110897c:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108980:	e0bfff17 	ldw	r2,-4(fp)
81108984:	10800017 	ldw	r2,0(r2)
81108988:	e0fffe17 	ldw	r3,-8(fp)
8110898c:	180d883a 	mov	r6,r3
81108990:	014013c4 	movi	r5,79
81108994:	1009883a 	mov	r4,r2
81108998:	110a8180 	call	8110a818 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
8110899c:	e0bfff17 	ldw	r2,-4(fp)
811089a0:	10802217 	ldw	r2,136(r2)
811089a4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
811089a8:	e0bfff17 	ldw	r2,-4(fp)
811089ac:	10800017 	ldw	r2,0(r2)
811089b0:	e0fffe17 	ldw	r3,-8(fp)
811089b4:	180d883a 	mov	r6,r3
811089b8:	01401404 	movi	r5,80
811089bc:	1009883a 	mov	r4,r2
811089c0:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
811089c4:	e0bfff17 	ldw	r2,-4(fp)
811089c8:	10802317 	ldw	r2,140(r2)
811089cc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
811089d0:	e0bfff17 	ldw	r2,-4(fp)
811089d4:	10800017 	ldw	r2,0(r2)
811089d8:	e0fffe17 	ldw	r3,-8(fp)
811089dc:	180d883a 	mov	r6,r3
811089e0:	01401444 	movi	r5,81
811089e4:	1009883a 	mov	r4,r2
811089e8:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811089ec:	00800044 	movi	r2,1
811089f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811089f4:	e0bffd17 	ldw	r2,-12(fp)
}
811089f8:	e037883a 	mov	sp,fp
811089fc:	dfc00117 	ldw	ra,4(sp)
81108a00:	df000017 	ldw	fp,0(sp)
81108a04:	dec00204 	addi	sp,sp,8
81108a08:	f800283a 	ret

81108a0c <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108a0c:	defffb04 	addi	sp,sp,-20
81108a10:	de00012e 	bgeu	sp,et,81108a18 <bRmapGetMemConfigArea+0xc>
81108a14:	003b68fa 	trap	3
81108a18:	dfc00415 	stw	ra,16(sp)
81108a1c:	df000315 	stw	fp,12(sp)
81108a20:	df000304 	addi	fp,sp,12
81108a24:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108a28:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108a2c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108a30:	e0bfff17 	ldw	r2,-4(fp)
81108a34:	1000a426 	beq	r2,zero,81108cc8 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a38:	e0bfff17 	ldw	r2,-4(fp)
81108a3c:	10800017 	ldw	r2,0(r2)
81108a40:	01401004 	movi	r5,64
81108a44:	1009883a 	mov	r4,r2
81108a48:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108a4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
81108a50:	e0fffe17 	ldw	r3,-8(fp)
81108a54:	e0bfff17 	ldw	r2,-4(fp)
81108a58:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a5c:	e0bfff17 	ldw	r2,-4(fp)
81108a60:	10800017 	ldw	r2,0(r2)
81108a64:	01401044 	movi	r5,65
81108a68:	1009883a 	mov	r4,r2
81108a6c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108a70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
81108a74:	e0fffe17 	ldw	r3,-8(fp)
81108a78:	e0bfff17 	ldw	r2,-4(fp)
81108a7c:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a80:	e0bfff17 	ldw	r2,-4(fp)
81108a84:	10800017 	ldw	r2,0(r2)
81108a88:	01401084 	movi	r5,66
81108a8c:	1009883a 	mov	r4,r2
81108a90:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108a94:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81108a98:	e0fffe17 	ldw	r3,-8(fp)
81108a9c:	e0bfff17 	ldw	r2,-4(fp)
81108aa0:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aa4:	e0bfff17 	ldw	r2,-4(fp)
81108aa8:	10800017 	ldw	r2,0(r2)
81108aac:	014010c4 	movi	r5,67
81108ab0:	1009883a 	mov	r4,r2
81108ab4:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108ab8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81108abc:	e0fffe17 	ldw	r3,-8(fp)
81108ac0:	e0bfff17 	ldw	r2,-4(fp)
81108ac4:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ac8:	e0bfff17 	ldw	r2,-4(fp)
81108acc:	10800017 	ldw	r2,0(r2)
81108ad0:	01401104 	movi	r5,68
81108ad4:	1009883a 	mov	r4,r2
81108ad8:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108adc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108ae0:	e0fffe17 	ldw	r3,-8(fp)
81108ae4:	e0bfff17 	ldw	r2,-4(fp)
81108ae8:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aec:	e0bfff17 	ldw	r2,-4(fp)
81108af0:	10800017 	ldw	r2,0(r2)
81108af4:	01401144 	movi	r5,69
81108af8:	1009883a 	mov	r4,r2
81108afc:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108b00:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81108b04:	e0fffe17 	ldw	r3,-8(fp)
81108b08:	e0bfff17 	ldw	r2,-4(fp)
81108b0c:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b10:	e0bfff17 	ldw	r2,-4(fp)
81108b14:	10800017 	ldw	r2,0(r2)
81108b18:	01401184 	movi	r5,70
81108b1c:	1009883a 	mov	r4,r2
81108b20:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108b24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81108b28:	e0fffe17 	ldw	r3,-8(fp)
81108b2c:	e0bfff17 	ldw	r2,-4(fp)
81108b30:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b34:	e0bfff17 	ldw	r2,-4(fp)
81108b38:	10800017 	ldw	r2,0(r2)
81108b3c:	014011c4 	movi	r5,71
81108b40:	1009883a 	mov	r4,r2
81108b44:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108b48:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81108b4c:	e0fffe17 	ldw	r3,-8(fp)
81108b50:	e0bfff17 	ldw	r2,-4(fp)
81108b54:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b58:	e0bfff17 	ldw	r2,-4(fp)
81108b5c:	10800017 	ldw	r2,0(r2)
81108b60:	01401204 	movi	r5,72
81108b64:	1009883a 	mov	r4,r2
81108b68:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108b6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
81108b70:	e0fffe17 	ldw	r3,-8(fp)
81108b74:	e0bfff17 	ldw	r2,-4(fp)
81108b78:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b7c:	e0bfff17 	ldw	r2,-4(fp)
81108b80:	10800017 	ldw	r2,0(r2)
81108b84:	01401244 	movi	r5,73
81108b88:	1009883a 	mov	r4,r2
81108b8c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108b90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
81108b94:	e0fffe17 	ldw	r3,-8(fp)
81108b98:	e0bfff17 	ldw	r2,-4(fp)
81108b9c:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ba0:	e0bfff17 	ldw	r2,-4(fp)
81108ba4:	10800017 	ldw	r2,0(r2)
81108ba8:	01401284 	movi	r5,74
81108bac:	1009883a 	mov	r4,r2
81108bb0:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108bb4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81108bb8:	e0fffe17 	ldw	r3,-8(fp)
81108bbc:	e0bfff17 	ldw	r2,-4(fp)
81108bc0:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bc4:	e0bfff17 	ldw	r2,-4(fp)
81108bc8:	10800017 	ldw	r2,0(r2)
81108bcc:	014012c4 	movi	r5,75
81108bd0:	1009883a 	mov	r4,r2
81108bd4:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108bd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108bdc:	e0fffe17 	ldw	r3,-8(fp)
81108be0:	e0bfff17 	ldw	r2,-4(fp)
81108be4:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108be8:	e0bfff17 	ldw	r2,-4(fp)
81108bec:	10800017 	ldw	r2,0(r2)
81108bf0:	01401304 	movi	r5,76
81108bf4:	1009883a 	mov	r4,r2
81108bf8:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108bfc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81108c00:	e0fffe17 	ldw	r3,-8(fp)
81108c04:	e0bfff17 	ldw	r2,-4(fp)
81108c08:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c0c:	e0bfff17 	ldw	r2,-4(fp)
81108c10:	10800017 	ldw	r2,0(r2)
81108c14:	01401344 	movi	r5,77
81108c18:	1009883a 	mov	r4,r2
81108c1c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108c20:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81108c24:	e0fffe17 	ldw	r3,-8(fp)
81108c28:	e0bfff17 	ldw	r2,-4(fp)
81108c2c:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c30:	e0bfff17 	ldw	r2,-4(fp)
81108c34:	10800017 	ldw	r2,0(r2)
81108c38:	01401384 	movi	r5,78
81108c3c:	1009883a 	mov	r4,r2
81108c40:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108c44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81108c48:	e0fffe17 	ldw	r3,-8(fp)
81108c4c:	e0bfff17 	ldw	r2,-4(fp)
81108c50:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c54:	e0bfff17 	ldw	r2,-4(fp)
81108c58:	10800017 	ldw	r2,0(r2)
81108c5c:	014013c4 	movi	r5,79
81108c60:	1009883a 	mov	r4,r2
81108c64:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108c68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108c6c:	e0fffe17 	ldw	r3,-8(fp)
81108c70:	e0bfff17 	ldw	r2,-4(fp)
81108c74:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c78:	e0bfff17 	ldw	r2,-4(fp)
81108c7c:	10800017 	ldw	r2,0(r2)
81108c80:	01401404 	movi	r5,80
81108c84:	1009883a 	mov	r4,r2
81108c88:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108c8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108c90:	e0fffe17 	ldw	r3,-8(fp)
81108c94:	e0bfff17 	ldw	r2,-4(fp)
81108c98:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c9c:	e0bfff17 	ldw	r2,-4(fp)
81108ca0:	10800017 	ldw	r2,0(r2)
81108ca4:	01401444 	movi	r5,81
81108ca8:	1009883a 	mov	r4,r2
81108cac:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108cb0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81108cb4:	e0fffe17 	ldw	r3,-8(fp)
81108cb8:	e0bfff17 	ldw	r2,-4(fp)
81108cbc:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81108cc0:	00800044 	movi	r2,1
81108cc4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108cc8:	e0bffd17 	ldw	r2,-12(fp)
}
81108ccc:	e037883a 	mov	sp,fp
81108cd0:	dfc00117 	ldw	ra,4(sp)
81108cd4:	df000017 	ldw	fp,0(sp)
81108cd8:	dec00204 	addi	sp,sp,8
81108cdc:	f800283a 	ret

81108ce0 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81108ce0:	defffb04 	addi	sp,sp,-20
81108ce4:	de00012e 	bgeu	sp,et,81108cec <bRmapGetMemConfigStat+0xc>
81108ce8:	003b68fa 	trap	3
81108cec:	dfc00415 	stw	ra,16(sp)
81108cf0:	df000315 	stw	fp,12(sp)
81108cf4:	df000304 	addi	fp,sp,12
81108cf8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108cfc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108d00:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108d04:	e0bfff17 	ldw	r2,-4(fp)
81108d08:	10001426 	beq	r2,zero,81108d5c <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d0c:	e0bfff17 	ldw	r2,-4(fp)
81108d10:	10800017 	ldw	r2,0(r2)
81108d14:	014001c4 	movi	r5,7
81108d18:	1009883a 	mov	r4,r2
81108d1c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108d20:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81108d24:	e0fffe17 	ldw	r3,-8(fp)
81108d28:	e0bfff17 	ldw	r2,-4(fp)
81108d2c:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d30:	e0bfff17 	ldw	r2,-4(fp)
81108d34:	10800017 	ldw	r2,0(r2)
81108d38:	01400184 	movi	r5,6
81108d3c:	1009883a 	mov	r4,r2
81108d40:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108d44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81108d48:	e0fffe17 	ldw	r3,-8(fp)
81108d4c:	e0bfff17 	ldw	r2,-4(fp)
81108d50:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
81108d54:	00800044 	movi	r2,1
81108d58:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108d5c:	e0bffd17 	ldw	r2,-12(fp)
}
81108d60:	e037883a 	mov	sp,fp
81108d64:	dfc00117 	ldw	ra,4(sp)
81108d68:	df000017 	ldw	fp,0(sp)
81108d6c:	dec00204 	addi	sp,sp,8
81108d70:	f800283a 	ret

81108d74 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108d74:	defffb04 	addi	sp,sp,-20
81108d78:	de00012e 	bgeu	sp,et,81108d80 <bRmapSetRmapMemHKArea+0xc>
81108d7c:	003b68fa 	trap	3
81108d80:	dfc00415 	stw	ra,16(sp)
81108d84:	df000315 	stw	fp,12(sp)
81108d88:	df000304 	addi	fp,sp,12
81108d8c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108d90:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108d94:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108d98:	e0bfff17 	ldw	r2,-4(fp)
81108d9c:	10042226 	beq	r2,zero,81109e28 <bRmapSetRmapMemHKArea+0x10b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108da0:	e0bfff17 	ldw	r2,-4(fp)
81108da4:	10800017 	ldw	r2,0(r2)
81108da8:	01402804 	movi	r5,160
81108dac:	1009883a 	mov	r4,r2
81108db0:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108db4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81108db8:	e0bffe17 	ldw	r2,-8(fp)
81108dbc:	10bfffec 	andhi	r2,r2,65535
81108dc0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81108dc4:	e0bfff17 	ldw	r2,-4(fp)
81108dc8:	1080260b 	ldhu	r2,152(r2)
81108dcc:	10ffffcc 	andi	r3,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108dd0:	e0bffe17 	ldw	r2,-8(fp)
81108dd4:	1884b03a 	or	r2,r3,r2
81108dd8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108ddc:	e0bffe17 	ldw	r2,-8(fp)
81108de0:	10bfffcc 	andi	r2,r2,65535
81108de4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108de8:	e0bfff17 	ldw	r2,-4(fp)
81108dec:	1080268b 	ldhu	r2,154(r2)
81108df0:	10bfffcc 	andi	r2,r2,65535
81108df4:	1004943a 	slli	r2,r2,16
81108df8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108dfc:	e0bffe17 	ldw	r2,-8(fp)
81108e00:	1884b03a 	or	r2,r3,r2
81108e04:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108e08:	e0bfff17 	ldw	r2,-4(fp)
81108e0c:	10800017 	ldw	r2,0(r2)
81108e10:	e0fffe17 	ldw	r3,-8(fp)
81108e14:	180d883a 	mov	r6,r3
81108e18:	01402804 	movi	r5,160
81108e1c:	1009883a 	mov	r4,r2
81108e20:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e24:	e0bfff17 	ldw	r2,-4(fp)
81108e28:	10800017 	ldw	r2,0(r2)
81108e2c:	01402844 	movi	r5,161
81108e30:	1009883a 	mov	r4,r2
81108e34:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108e38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81108e3c:	e0bffe17 	ldw	r2,-8(fp)
81108e40:	10bfffec 	andhi	r2,r2,65535
81108e44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81108e48:	e0bfff17 	ldw	r2,-4(fp)
81108e4c:	1080270b 	ldhu	r2,156(r2)
81108e50:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81108e54:	e0bffe17 	ldw	r2,-8(fp)
81108e58:	1884b03a 	or	r2,r3,r2
81108e5c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81108e60:	e0bffe17 	ldw	r2,-8(fp)
81108e64:	10bfffcc 	andi	r2,r2,65535
81108e68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
81108e6c:	e0bfff17 	ldw	r2,-4(fp)
81108e70:	1080278b 	ldhu	r2,158(r2)
81108e74:	10bfffcc 	andi	r2,r2,65535
81108e78:	1004943a 	slli	r2,r2,16
81108e7c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
81108e80:	e0bffe17 	ldw	r2,-8(fp)
81108e84:	1884b03a 	or	r2,r3,r2
81108e88:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81108e8c:	e0bfff17 	ldw	r2,-4(fp)
81108e90:	10800017 	ldw	r2,0(r2)
81108e94:	e0fffe17 	ldw	r3,-8(fp)
81108e98:	180d883a 	mov	r6,r3
81108e9c:	01402844 	movi	r5,161
81108ea0:	1009883a 	mov	r4,r2
81108ea4:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ea8:	e0bfff17 	ldw	r2,-4(fp)
81108eac:	10800017 	ldw	r2,0(r2)
81108eb0:	01402884 	movi	r5,162
81108eb4:	1009883a 	mov	r4,r2
81108eb8:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108ebc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108ec0:	e0bffe17 	ldw	r2,-8(fp)
81108ec4:	10bfffec 	andhi	r2,r2,65535
81108ec8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108ecc:	e0bfff17 	ldw	r2,-4(fp)
81108ed0:	1080280b 	ldhu	r2,160(r2)
81108ed4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108ed8:	e0bffe17 	ldw	r2,-8(fp)
81108edc:	1884b03a 	or	r2,r3,r2
81108ee0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108ee4:	e0bffe17 	ldw	r2,-8(fp)
81108ee8:	10bfffcc 	andi	r2,r2,65535
81108eec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108ef0:	e0bfff17 	ldw	r2,-4(fp)
81108ef4:	1080288b 	ldhu	r2,162(r2)
81108ef8:	10bfffcc 	andi	r2,r2,65535
81108efc:	1004943a 	slli	r2,r2,16
81108f00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108f04:	e0bffe17 	ldw	r2,-8(fp)
81108f08:	1884b03a 	or	r2,r3,r2
81108f0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108f10:	e0bfff17 	ldw	r2,-4(fp)
81108f14:	10800017 	ldw	r2,0(r2)
81108f18:	e0fffe17 	ldw	r3,-8(fp)
81108f1c:	180d883a 	mov	r6,r3
81108f20:	01402884 	movi	r5,162
81108f24:	1009883a 	mov	r4,r2
81108f28:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f2c:	e0bfff17 	ldw	r2,-4(fp)
81108f30:	10800017 	ldw	r2,0(r2)
81108f34:	014028c4 	movi	r5,163
81108f38:	1009883a 	mov	r4,r2
81108f3c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108f40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81108f44:	e0bffe17 	ldw	r2,-8(fp)
81108f48:	10bfffec 	andhi	r2,r2,65535
81108f4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81108f50:	e0bfff17 	ldw	r2,-4(fp)
81108f54:	1080290b 	ldhu	r2,164(r2)
81108f58:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81108f5c:	e0bffe17 	ldw	r2,-8(fp)
81108f60:	1884b03a 	or	r2,r3,r2
81108f64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81108f68:	e0bffe17 	ldw	r2,-8(fp)
81108f6c:	10bfffcc 	andi	r2,r2,65535
81108f70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
81108f74:	e0bfff17 	ldw	r2,-4(fp)
81108f78:	1080298b 	ldhu	r2,166(r2)
81108f7c:	10bfffcc 	andi	r2,r2,65535
81108f80:	1004943a 	slli	r2,r2,16
81108f84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
81108f88:	e0bffe17 	ldw	r2,-8(fp)
81108f8c:	1884b03a 	or	r2,r3,r2
81108f90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81108f94:	e0bfff17 	ldw	r2,-4(fp)
81108f98:	10800017 	ldw	r2,0(r2)
81108f9c:	e0fffe17 	ldw	r3,-8(fp)
81108fa0:	180d883a 	mov	r6,r3
81108fa4:	014028c4 	movi	r5,163
81108fa8:	1009883a 	mov	r4,r2
81108fac:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fb0:	e0bfff17 	ldw	r2,-4(fp)
81108fb4:	10800017 	ldw	r2,0(r2)
81108fb8:	01402904 	movi	r5,164
81108fbc:	1009883a 	mov	r4,r2
81108fc0:	110a86c0 	call	8110a86c <uliRmapReadReg>
81108fc4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108fc8:	e0bffe17 	ldw	r2,-8(fp)
81108fcc:	10bfffec 	andhi	r2,r2,65535
81108fd0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81108fd4:	e0bfff17 	ldw	r2,-4(fp)
81108fd8:	10802a0b 	ldhu	r2,168(r2)
81108fdc:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108fe0:	e0bffe17 	ldw	r2,-8(fp)
81108fe4:	1884b03a 	or	r2,r3,r2
81108fe8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108fec:	e0bffe17 	ldw	r2,-8(fp)
81108ff0:	10bfffcc 	andi	r2,r2,65535
81108ff4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108ff8:	e0bfff17 	ldw	r2,-4(fp)
81108ffc:	10802a8b 	ldhu	r2,170(r2)
81109000:	10bfffcc 	andi	r2,r2,65535
81109004:	1004943a 	slli	r2,r2,16
81109008:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
8110900c:	e0bffe17 	ldw	r2,-8(fp)
81109010:	1884b03a 	or	r2,r3,r2
81109014:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81109018:	e0bfff17 	ldw	r2,-4(fp)
8110901c:	10800017 	ldw	r2,0(r2)
81109020:	e0fffe17 	ldw	r3,-8(fp)
81109024:	180d883a 	mov	r6,r3
81109028:	01402904 	movi	r5,164
8110902c:	1009883a 	mov	r4,r2
81109030:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109034:	e0bfff17 	ldw	r2,-4(fp)
81109038:	10800017 	ldw	r2,0(r2)
8110903c:	01402944 	movi	r5,165
81109040:	1009883a 	mov	r4,r2
81109044:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109048:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
8110904c:	e0bffe17 	ldw	r2,-8(fp)
81109050:	10bfffec 	andhi	r2,r2,65535
81109054:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81109058:	e0bfff17 	ldw	r2,-4(fp)
8110905c:	10802b0b 	ldhu	r2,172(r2)
81109060:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81109064:	e0bffe17 	ldw	r2,-8(fp)
81109068:	1884b03a 	or	r2,r3,r2
8110906c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81109070:	e0bffe17 	ldw	r2,-8(fp)
81109074:	10bfffcc 	andi	r2,r2,65535
81109078:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
8110907c:	e0bfff17 	ldw	r2,-4(fp)
81109080:	10802b8b 	ldhu	r2,174(r2)
81109084:	10bfffcc 	andi	r2,r2,65535
81109088:	1004943a 	slli	r2,r2,16
8110908c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
81109090:	e0bffe17 	ldw	r2,-8(fp)
81109094:	1884b03a 	or	r2,r3,r2
81109098:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
8110909c:	e0bfff17 	ldw	r2,-4(fp)
811090a0:	10800017 	ldw	r2,0(r2)
811090a4:	e0fffe17 	ldw	r3,-8(fp)
811090a8:	180d883a 	mov	r6,r3
811090ac:	01402944 	movi	r5,165
811090b0:	1009883a 	mov	r4,r2
811090b4:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090b8:	e0bfff17 	ldw	r2,-4(fp)
811090bc:	10800017 	ldw	r2,0(r2)
811090c0:	01402984 	movi	r5,166
811090c4:	1009883a 	mov	r4,r2
811090c8:	110a86c0 	call	8110a86c <uliRmapReadReg>
811090cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
811090d0:	e0bffe17 	ldw	r2,-8(fp)
811090d4:	10bfffec 	andhi	r2,r2,65535
811090d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
811090dc:	e0bfff17 	ldw	r2,-4(fp)
811090e0:	10802c0b 	ldhu	r2,176(r2)
811090e4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
811090e8:	e0bffe17 	ldw	r2,-8(fp)
811090ec:	1884b03a 	or	r2,r3,r2
811090f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
811090f4:	e0bffe17 	ldw	r2,-8(fp)
811090f8:	10bfffcc 	andi	r2,r2,65535
811090fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81109100:	e0bfff17 	ldw	r2,-4(fp)
81109104:	10802c8b 	ldhu	r2,178(r2)
81109108:	10bfffcc 	andi	r2,r2,65535
8110910c:	1004943a 	slli	r2,r2,16
81109110:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81109114:	e0bffe17 	ldw	r2,-8(fp)
81109118:	1884b03a 	or	r2,r3,r2
8110911c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81109120:	e0bfff17 	ldw	r2,-4(fp)
81109124:	10800017 	ldw	r2,0(r2)
81109128:	e0fffe17 	ldw	r3,-8(fp)
8110912c:	180d883a 	mov	r6,r3
81109130:	01402984 	movi	r5,166
81109134:	1009883a 	mov	r4,r2
81109138:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110913c:	e0bfff17 	ldw	r2,-4(fp)
81109140:	10800017 	ldw	r2,0(r2)
81109144:	014029c4 	movi	r5,167
81109148:	1009883a 	mov	r4,r2
8110914c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109150:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81109154:	e0bffe17 	ldw	r2,-8(fp)
81109158:	10bfffec 	andhi	r2,r2,65535
8110915c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81109160:	e0bfff17 	ldw	r2,-4(fp)
81109164:	10802d0b 	ldhu	r2,180(r2)
81109168:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
8110916c:	e0bffe17 	ldw	r2,-8(fp)
81109170:	1884b03a 	or	r2,r3,r2
81109174:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81109178:	e0bffe17 	ldw	r2,-8(fp)
8110917c:	10bfffcc 	andi	r2,r2,65535
81109180:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
81109184:	e0bfff17 	ldw	r2,-4(fp)
81109188:	10802d8b 	ldhu	r2,182(r2)
8110918c:	10bfffcc 	andi	r2,r2,65535
81109190:	1004943a 	slli	r2,r2,16
81109194:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81109198:	e0bffe17 	ldw	r2,-8(fp)
8110919c:	1884b03a 	or	r2,r3,r2
811091a0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
811091a4:	e0bfff17 	ldw	r2,-4(fp)
811091a8:	10800017 	ldw	r2,0(r2)
811091ac:	e0fffe17 	ldw	r3,-8(fp)
811091b0:	180d883a 	mov	r6,r3
811091b4:	014029c4 	movi	r5,167
811091b8:	1009883a 	mov	r4,r2
811091bc:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091c0:	e0bfff17 	ldw	r2,-4(fp)
811091c4:	10800017 	ldw	r2,0(r2)
811091c8:	01402a04 	movi	r5,168
811091cc:	1009883a 	mov	r4,r2
811091d0:	110a86c0 	call	8110a86c <uliRmapReadReg>
811091d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
811091d8:	e0bffe17 	ldw	r2,-8(fp)
811091dc:	10bfffec 	andhi	r2,r2,65535
811091e0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
811091e4:	e0bfff17 	ldw	r2,-4(fp)
811091e8:	10802e0b 	ldhu	r2,184(r2)
811091ec:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
811091f0:	e0bffe17 	ldw	r2,-8(fp)
811091f4:	1884b03a 	or	r2,r3,r2
811091f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
811091fc:	e0bffe17 	ldw	r2,-8(fp)
81109200:	10bfffcc 	andi	r2,r2,65535
81109204:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81109208:	e0bfff17 	ldw	r2,-4(fp)
8110920c:	10802e8b 	ldhu	r2,186(r2)
81109210:	10bfffcc 	andi	r2,r2,65535
81109214:	1004943a 	slli	r2,r2,16
81109218:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
8110921c:	e0bffe17 	ldw	r2,-8(fp)
81109220:	1884b03a 	or	r2,r3,r2
81109224:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81109228:	e0bfff17 	ldw	r2,-4(fp)
8110922c:	10800017 	ldw	r2,0(r2)
81109230:	e0fffe17 	ldw	r3,-8(fp)
81109234:	180d883a 	mov	r6,r3
81109238:	01402a04 	movi	r5,168
8110923c:	1009883a 	mov	r4,r2
81109240:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109244:	e0bfff17 	ldw	r2,-4(fp)
81109248:	10800017 	ldw	r2,0(r2)
8110924c:	01402a44 	movi	r5,169
81109250:	1009883a 	mov	r4,r2
81109254:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109258:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
8110925c:	e0bffe17 	ldw	r2,-8(fp)
81109260:	10bfffec 	andhi	r2,r2,65535
81109264:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81109268:	e0bfff17 	ldw	r2,-4(fp)
8110926c:	10802f0b 	ldhu	r2,188(r2)
81109270:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81109274:	e0bffe17 	ldw	r2,-8(fp)
81109278:	1884b03a 	or	r2,r3,r2
8110927c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81109280:	e0bffe17 	ldw	r2,-8(fp)
81109284:	10bfffcc 	andi	r2,r2,65535
81109288:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
8110928c:	e0bfff17 	ldw	r2,-4(fp)
81109290:	10802f8b 	ldhu	r2,190(r2)
81109294:	10bfffcc 	andi	r2,r2,65535
81109298:	1004943a 	slli	r2,r2,16
8110929c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
811092a0:	e0bffe17 	ldw	r2,-8(fp)
811092a4:	1884b03a 	or	r2,r3,r2
811092a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
811092ac:	e0bfff17 	ldw	r2,-4(fp)
811092b0:	10800017 	ldw	r2,0(r2)
811092b4:	e0fffe17 	ldw	r3,-8(fp)
811092b8:	180d883a 	mov	r6,r3
811092bc:	01402a44 	movi	r5,169
811092c0:	1009883a 	mov	r4,r2
811092c4:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092c8:	e0bfff17 	ldw	r2,-4(fp)
811092cc:	10800017 	ldw	r2,0(r2)
811092d0:	01402a84 	movi	r5,170
811092d4:	1009883a 	mov	r4,r2
811092d8:	110a86c0 	call	8110a86c <uliRmapReadReg>
811092dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
811092e0:	e0bffe17 	ldw	r2,-8(fp)
811092e4:	10bfffec 	andhi	r2,r2,65535
811092e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
811092ec:	e0bfff17 	ldw	r2,-4(fp)
811092f0:	1080300b 	ldhu	r2,192(r2)
811092f4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
811092f8:	e0bffe17 	ldw	r2,-8(fp)
811092fc:	1884b03a 	or	r2,r3,r2
81109300:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81109304:	e0bffe17 	ldw	r2,-8(fp)
81109308:	10bfffcc 	andi	r2,r2,65535
8110930c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81109310:	e0bfff17 	ldw	r2,-4(fp)
81109314:	1080308b 	ldhu	r2,194(r2)
81109318:	10bfffcc 	andi	r2,r2,65535
8110931c:	1004943a 	slli	r2,r2,16
81109320:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81109324:	e0bffe17 	ldw	r2,-8(fp)
81109328:	1884b03a 	or	r2,r3,r2
8110932c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81109330:	e0bfff17 	ldw	r2,-4(fp)
81109334:	10800017 	ldw	r2,0(r2)
81109338:	e0fffe17 	ldw	r3,-8(fp)
8110933c:	180d883a 	mov	r6,r3
81109340:	01402a84 	movi	r5,170
81109344:	1009883a 	mov	r4,r2
81109348:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110934c:	e0bfff17 	ldw	r2,-4(fp)
81109350:	10800017 	ldw	r2,0(r2)
81109354:	01402ac4 	movi	r5,171
81109358:	1009883a 	mov	r4,r2
8110935c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109360:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81109364:	e0bffe17 	ldw	r2,-8(fp)
81109368:	10bfffec 	andhi	r2,r2,65535
8110936c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81109370:	e0bfff17 	ldw	r2,-4(fp)
81109374:	1080310b 	ldhu	r2,196(r2)
81109378:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
8110937c:	e0bffe17 	ldw	r2,-8(fp)
81109380:	1884b03a 	or	r2,r3,r2
81109384:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81109388:	e0bffe17 	ldw	r2,-8(fp)
8110938c:	10bfffcc 	andi	r2,r2,65535
81109390:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81109394:	e0bfff17 	ldw	r2,-4(fp)
81109398:	1080318b 	ldhu	r2,198(r2)
8110939c:	10bfffcc 	andi	r2,r2,65535
811093a0:	1004943a 	slli	r2,r2,16
811093a4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
811093a8:	e0bffe17 	ldw	r2,-8(fp)
811093ac:	1884b03a 	or	r2,r3,r2
811093b0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
811093b4:	e0bfff17 	ldw	r2,-4(fp)
811093b8:	10800017 	ldw	r2,0(r2)
811093bc:	e0fffe17 	ldw	r3,-8(fp)
811093c0:	180d883a 	mov	r6,r3
811093c4:	01402ac4 	movi	r5,171
811093c8:	1009883a 	mov	r4,r2
811093cc:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093d0:	e0bfff17 	ldw	r2,-4(fp)
811093d4:	10800017 	ldw	r2,0(r2)
811093d8:	01402b04 	movi	r5,172
811093dc:	1009883a 	mov	r4,r2
811093e0:	110a86c0 	call	8110a86c <uliRmapReadReg>
811093e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
811093e8:	e0bffe17 	ldw	r2,-8(fp)
811093ec:	10bfffec 	andhi	r2,r2,65535
811093f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
811093f4:	e0bfff17 	ldw	r2,-4(fp)
811093f8:	1080320b 	ldhu	r2,200(r2)
811093fc:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81109400:	e0bffe17 	ldw	r2,-8(fp)
81109404:	1884b03a 	or	r2,r3,r2
81109408:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
8110940c:	e0bffe17 	ldw	r2,-8(fp)
81109410:	10bfffcc 	andi	r2,r2,65535
81109414:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81109418:	e0bfff17 	ldw	r2,-4(fp)
8110941c:	1080328b 	ldhu	r2,202(r2)
81109420:	10bfffcc 	andi	r2,r2,65535
81109424:	1004943a 	slli	r2,r2,16
81109428:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
8110942c:	e0bffe17 	ldw	r2,-8(fp)
81109430:	1884b03a 	or	r2,r3,r2
81109434:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81109438:	e0bfff17 	ldw	r2,-4(fp)
8110943c:	10800017 	ldw	r2,0(r2)
81109440:	e0fffe17 	ldw	r3,-8(fp)
81109444:	180d883a 	mov	r6,r3
81109448:	01402b04 	movi	r5,172
8110944c:	1009883a 	mov	r4,r2
81109450:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109454:	e0bfff17 	ldw	r2,-4(fp)
81109458:	10800017 	ldw	r2,0(r2)
8110945c:	01402b44 	movi	r5,173
81109460:	1009883a 	mov	r4,r2
81109464:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109468:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
8110946c:	e0bffe17 	ldw	r2,-8(fp)
81109470:	10bfffec 	andhi	r2,r2,65535
81109474:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81109478:	e0bfff17 	ldw	r2,-4(fp)
8110947c:	1080330b 	ldhu	r2,204(r2)
81109480:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81109484:	e0bffe17 	ldw	r2,-8(fp)
81109488:	1884b03a 	or	r2,r3,r2
8110948c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81109490:	e0bffe17 	ldw	r2,-8(fp)
81109494:	10bfffcc 	andi	r2,r2,65535
81109498:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
8110949c:	e0bfff17 	ldw	r2,-4(fp)
811094a0:	1080338b 	ldhu	r2,206(r2)
811094a4:	10bfffcc 	andi	r2,r2,65535
811094a8:	1004943a 	slli	r2,r2,16
811094ac:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
811094b0:	e0bffe17 	ldw	r2,-8(fp)
811094b4:	1884b03a 	or	r2,r3,r2
811094b8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
811094bc:	e0bfff17 	ldw	r2,-4(fp)
811094c0:	10800017 	ldw	r2,0(r2)
811094c4:	e0fffe17 	ldw	r3,-8(fp)
811094c8:	180d883a 	mov	r6,r3
811094cc:	01402b44 	movi	r5,173
811094d0:	1009883a 	mov	r4,r2
811094d4:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094d8:	e0bfff17 	ldw	r2,-4(fp)
811094dc:	10800017 	ldw	r2,0(r2)
811094e0:	01402b84 	movi	r5,174
811094e4:	1009883a 	mov	r4,r2
811094e8:	110a86c0 	call	8110a86c <uliRmapReadReg>
811094ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
811094f0:	e0bffe17 	ldw	r2,-8(fp)
811094f4:	10bfffec 	andhi	r2,r2,65535
811094f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
811094fc:	e0bfff17 	ldw	r2,-4(fp)
81109500:	1080340b 	ldhu	r2,208(r2)
81109504:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81109508:	e0bffe17 	ldw	r2,-8(fp)
8110950c:	1884b03a 	or	r2,r3,r2
81109510:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81109514:	e0bffe17 	ldw	r2,-8(fp)
81109518:	10bfffcc 	andi	r2,r2,65535
8110951c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81109520:	e0bfff17 	ldw	r2,-4(fp)
81109524:	1080348b 	ldhu	r2,210(r2)
81109528:	10bfffcc 	andi	r2,r2,65535
8110952c:	1004943a 	slli	r2,r2,16
81109530:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81109534:	e0bffe17 	ldw	r2,-8(fp)
81109538:	1884b03a 	or	r2,r3,r2
8110953c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81109540:	e0bfff17 	ldw	r2,-4(fp)
81109544:	10800017 	ldw	r2,0(r2)
81109548:	e0fffe17 	ldw	r3,-8(fp)
8110954c:	180d883a 	mov	r6,r3
81109550:	01402b84 	movi	r5,174
81109554:	1009883a 	mov	r4,r2
81109558:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110955c:	e0bfff17 	ldw	r2,-4(fp)
81109560:	10800017 	ldw	r2,0(r2)
81109564:	01402bc4 	movi	r5,175
81109568:	1009883a 	mov	r4,r2
8110956c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109570:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81109574:	e0bffe17 	ldw	r2,-8(fp)
81109578:	10bfffec 	andhi	r2,r2,65535
8110957c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81109580:	e0bfff17 	ldw	r2,-4(fp)
81109584:	1080350b 	ldhu	r2,212(r2)
81109588:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
8110958c:	e0bffe17 	ldw	r2,-8(fp)
81109590:	1884b03a 	or	r2,r3,r2
81109594:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81109598:	e0bffe17 	ldw	r2,-8(fp)
8110959c:	10bfffcc 	andi	r2,r2,65535
811095a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
811095a4:	e0bfff17 	ldw	r2,-4(fp)
811095a8:	1080358b 	ldhu	r2,214(r2)
811095ac:	10bfffcc 	andi	r2,r2,65535
811095b0:	1004943a 	slli	r2,r2,16
811095b4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
811095b8:	e0bffe17 	ldw	r2,-8(fp)
811095bc:	1884b03a 	or	r2,r3,r2
811095c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
811095c4:	e0bfff17 	ldw	r2,-4(fp)
811095c8:	10800017 	ldw	r2,0(r2)
811095cc:	e0fffe17 	ldw	r3,-8(fp)
811095d0:	180d883a 	mov	r6,r3
811095d4:	01402bc4 	movi	r5,175
811095d8:	1009883a 	mov	r4,r2
811095dc:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095e0:	e0bfff17 	ldw	r2,-4(fp)
811095e4:	10800017 	ldw	r2,0(r2)
811095e8:	01402c04 	movi	r5,176
811095ec:	1009883a 	mov	r4,r2
811095f0:	110a86c0 	call	8110a86c <uliRmapReadReg>
811095f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
811095f8:	e0bffe17 	ldw	r2,-8(fp)
811095fc:	10bfffec 	andhi	r2,r2,65535
81109600:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81109604:	e0bfff17 	ldw	r2,-4(fp)
81109608:	1080360b 	ldhu	r2,216(r2)
8110960c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81109610:	e0bffe17 	ldw	r2,-8(fp)
81109614:	1884b03a 	or	r2,r3,r2
81109618:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
8110961c:	e0bffe17 	ldw	r2,-8(fp)
81109620:	10bfffcc 	andi	r2,r2,65535
81109624:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81109628:	e0bfff17 	ldw	r2,-4(fp)
8110962c:	1080368b 	ldhu	r2,218(r2)
81109630:	10bfffcc 	andi	r2,r2,65535
81109634:	1004943a 	slli	r2,r2,16
81109638:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
8110963c:	e0bffe17 	ldw	r2,-8(fp)
81109640:	1884b03a 	or	r2,r3,r2
81109644:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81109648:	e0bfff17 	ldw	r2,-4(fp)
8110964c:	10800017 	ldw	r2,0(r2)
81109650:	e0fffe17 	ldw	r3,-8(fp)
81109654:	180d883a 	mov	r6,r3
81109658:	01402c04 	movi	r5,176
8110965c:	1009883a 	mov	r4,r2
81109660:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109664:	e0bfff17 	ldw	r2,-4(fp)
81109668:	10800017 	ldw	r2,0(r2)
8110966c:	01402c44 	movi	r5,177
81109670:	1009883a 	mov	r4,r2
81109674:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109678:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
8110967c:	e0bffe17 	ldw	r2,-8(fp)
81109680:	10bfffec 	andhi	r2,r2,65535
81109684:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81109688:	e0bfff17 	ldw	r2,-4(fp)
8110968c:	1080370b 	ldhu	r2,220(r2)
81109690:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81109694:	e0bffe17 	ldw	r2,-8(fp)
81109698:	1884b03a 	or	r2,r3,r2
8110969c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
811096a0:	e0bffe17 	ldw	r2,-8(fp)
811096a4:	10bfffcc 	andi	r2,r2,65535
811096a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
811096ac:	e0bfff17 	ldw	r2,-4(fp)
811096b0:	1080378b 	ldhu	r2,222(r2)
811096b4:	10bfffcc 	andi	r2,r2,65535
811096b8:	1004943a 	slli	r2,r2,16
811096bc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
811096c0:	e0bffe17 	ldw	r2,-8(fp)
811096c4:	1884b03a 	or	r2,r3,r2
811096c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
811096cc:	e0bfff17 	ldw	r2,-4(fp)
811096d0:	10800017 	ldw	r2,0(r2)
811096d4:	e0fffe17 	ldw	r3,-8(fp)
811096d8:	180d883a 	mov	r6,r3
811096dc:	01402c44 	movi	r5,177
811096e0:	1009883a 	mov	r4,r2
811096e4:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096e8:	e0bfff17 	ldw	r2,-4(fp)
811096ec:	10800017 	ldw	r2,0(r2)
811096f0:	01402c84 	movi	r5,178
811096f4:	1009883a 	mov	r4,r2
811096f8:	110a86c0 	call	8110a86c <uliRmapReadReg>
811096fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81109700:	e0bffe17 	ldw	r2,-8(fp)
81109704:	10bfffec 	andhi	r2,r2,65535
81109708:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
8110970c:	e0bfff17 	ldw	r2,-4(fp)
81109710:	1080380b 	ldhu	r2,224(r2)
81109714:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81109718:	e0bffe17 	ldw	r2,-8(fp)
8110971c:	1884b03a 	or	r2,r3,r2
81109720:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81109724:	e0bffe17 	ldw	r2,-8(fp)
81109728:	10bfffcc 	andi	r2,r2,65535
8110972c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81109730:	e0bfff17 	ldw	r2,-4(fp)
81109734:	1080388b 	ldhu	r2,226(r2)
81109738:	10bfffcc 	andi	r2,r2,65535
8110973c:	1004943a 	slli	r2,r2,16
81109740:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81109744:	e0bffe17 	ldw	r2,-8(fp)
81109748:	1884b03a 	or	r2,r3,r2
8110974c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81109750:	e0bfff17 	ldw	r2,-4(fp)
81109754:	10800017 	ldw	r2,0(r2)
81109758:	e0fffe17 	ldw	r3,-8(fp)
8110975c:	180d883a 	mov	r6,r3
81109760:	01402c84 	movi	r5,178
81109764:	1009883a 	mov	r4,r2
81109768:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110976c:	e0bfff17 	ldw	r2,-4(fp)
81109770:	10800017 	ldw	r2,0(r2)
81109774:	01402cc4 	movi	r5,179
81109778:	1009883a 	mov	r4,r2
8110977c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109780:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81109784:	e0bffe17 	ldw	r2,-8(fp)
81109788:	10bfffec 	andhi	r2,r2,65535
8110978c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81109790:	e0bfff17 	ldw	r2,-4(fp)
81109794:	1080390b 	ldhu	r2,228(r2)
81109798:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
8110979c:	e0bffe17 	ldw	r2,-8(fp)
811097a0:	1884b03a 	or	r2,r3,r2
811097a4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
811097a8:	e0bffe17 	ldw	r2,-8(fp)
811097ac:	10bfffcc 	andi	r2,r2,65535
811097b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
811097b4:	e0bfff17 	ldw	r2,-4(fp)
811097b8:	1080398b 	ldhu	r2,230(r2)
811097bc:	10bfffcc 	andi	r2,r2,65535
811097c0:	1004943a 	slli	r2,r2,16
811097c4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
811097c8:	e0bffe17 	ldw	r2,-8(fp)
811097cc:	1884b03a 	or	r2,r3,r2
811097d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
811097d4:	e0bfff17 	ldw	r2,-4(fp)
811097d8:	10800017 	ldw	r2,0(r2)
811097dc:	e0fffe17 	ldw	r3,-8(fp)
811097e0:	180d883a 	mov	r6,r3
811097e4:	01402cc4 	movi	r5,179
811097e8:	1009883a 	mov	r4,r2
811097ec:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097f0:	e0bfff17 	ldw	r2,-4(fp)
811097f4:	10800017 	ldw	r2,0(r2)
811097f8:	01402d04 	movi	r5,180
811097fc:	1009883a 	mov	r4,r2
81109800:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109804:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81109808:	e0bffe17 	ldw	r2,-8(fp)
8110980c:	10bfffec 	andhi	r2,r2,65535
81109810:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81109814:	e0bfff17 	ldw	r2,-4(fp)
81109818:	10803a0b 	ldhu	r2,232(r2)
8110981c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81109820:	e0bffe17 	ldw	r2,-8(fp)
81109824:	1884b03a 	or	r2,r3,r2
81109828:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
8110982c:	e0bffe17 	ldw	r2,-8(fp)
81109830:	10bfffcc 	andi	r2,r2,65535
81109834:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81109838:	e0bfff17 	ldw	r2,-4(fp)
8110983c:	10803a8b 	ldhu	r2,234(r2)
81109840:	10bfffcc 	andi	r2,r2,65535
81109844:	1004943a 	slli	r2,r2,16
81109848:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
8110984c:	e0bffe17 	ldw	r2,-8(fp)
81109850:	1884b03a 	or	r2,r3,r2
81109854:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81109858:	e0bfff17 	ldw	r2,-4(fp)
8110985c:	10800017 	ldw	r2,0(r2)
81109860:	e0fffe17 	ldw	r3,-8(fp)
81109864:	180d883a 	mov	r6,r3
81109868:	01402d04 	movi	r5,180
8110986c:	1009883a 	mov	r4,r2
81109870:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109874:	e0bfff17 	ldw	r2,-4(fp)
81109878:	10800017 	ldw	r2,0(r2)
8110987c:	01402d44 	movi	r5,181
81109880:	1009883a 	mov	r4,r2
81109884:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109888:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
8110988c:	e0bffe17 	ldw	r2,-8(fp)
81109890:	10bfffec 	andhi	r2,r2,65535
81109894:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81109898:	e0bfff17 	ldw	r2,-4(fp)
8110989c:	10803b0b 	ldhu	r2,236(r2)
811098a0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
811098a4:	e0bffe17 	ldw	r2,-8(fp)
811098a8:	1884b03a 	or	r2,r3,r2
811098ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
811098b0:	e0bffe17 	ldw	r2,-8(fp)
811098b4:	10bfffcc 	andi	r2,r2,65535
811098b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
811098bc:	e0bfff17 	ldw	r2,-4(fp)
811098c0:	10803b8b 	ldhu	r2,238(r2)
811098c4:	10bfffcc 	andi	r2,r2,65535
811098c8:	1004943a 	slli	r2,r2,16
811098cc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
811098d0:	e0bffe17 	ldw	r2,-8(fp)
811098d4:	1884b03a 	or	r2,r3,r2
811098d8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
811098dc:	e0bfff17 	ldw	r2,-4(fp)
811098e0:	10800017 	ldw	r2,0(r2)
811098e4:	e0fffe17 	ldw	r3,-8(fp)
811098e8:	180d883a 	mov	r6,r3
811098ec:	01402d44 	movi	r5,181
811098f0:	1009883a 	mov	r4,r2
811098f4:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098f8:	e0bfff17 	ldw	r2,-4(fp)
811098fc:	10800017 	ldw	r2,0(r2)
81109900:	01402d84 	movi	r5,182
81109904:	1009883a 	mov	r4,r2
81109908:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110990c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81109910:	e0bffe17 	ldw	r2,-8(fp)
81109914:	10bfffec 	andhi	r2,r2,65535
81109918:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
8110991c:	e0bfff17 	ldw	r2,-4(fp)
81109920:	10803c0b 	ldhu	r2,240(r2)
81109924:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81109928:	e0bffe17 	ldw	r2,-8(fp)
8110992c:	1884b03a 	or	r2,r3,r2
81109930:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81109934:	e0bffe17 	ldw	r2,-8(fp)
81109938:	10bfffcc 	andi	r2,r2,65535
8110993c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81109940:	e0bfff17 	ldw	r2,-4(fp)
81109944:	10803c8b 	ldhu	r2,242(r2)
81109948:	10bfffcc 	andi	r2,r2,65535
8110994c:	1004943a 	slli	r2,r2,16
81109950:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81109954:	e0bffe17 	ldw	r2,-8(fp)
81109958:	1884b03a 	or	r2,r3,r2
8110995c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81109960:	e0bfff17 	ldw	r2,-4(fp)
81109964:	10800017 	ldw	r2,0(r2)
81109968:	e0fffe17 	ldw	r3,-8(fp)
8110996c:	180d883a 	mov	r6,r3
81109970:	01402d84 	movi	r5,182
81109974:	1009883a 	mov	r4,r2
81109978:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110997c:	e0bfff17 	ldw	r2,-4(fp)
81109980:	10800017 	ldw	r2,0(r2)
81109984:	01402dc4 	movi	r5,183
81109988:	1009883a 	mov	r4,r2
8110998c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109990:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81109994:	e0bffe17 	ldw	r2,-8(fp)
81109998:	10bfffec 	andhi	r2,r2,65535
8110999c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
811099a0:	e0bfff17 	ldw	r2,-4(fp)
811099a4:	10803d0b 	ldhu	r2,244(r2)
811099a8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
811099ac:	e0bffe17 	ldw	r2,-8(fp)
811099b0:	1884b03a 	or	r2,r3,r2
811099b4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
811099b8:	e0bffe17 	ldw	r2,-8(fp)
811099bc:	10bfffcc 	andi	r2,r2,65535
811099c0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
811099c4:	e0bfff17 	ldw	r2,-4(fp)
811099c8:	10803d8b 	ldhu	r2,246(r2)
811099cc:	10bfffcc 	andi	r2,r2,65535
811099d0:	1004943a 	slli	r2,r2,16
811099d4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
811099d8:	e0bffe17 	ldw	r2,-8(fp)
811099dc:	1884b03a 	or	r2,r3,r2
811099e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
811099e4:	e0bfff17 	ldw	r2,-4(fp)
811099e8:	10800017 	ldw	r2,0(r2)
811099ec:	e0fffe17 	ldw	r3,-8(fp)
811099f0:	180d883a 	mov	r6,r3
811099f4:	01402dc4 	movi	r5,183
811099f8:	1009883a 	mov	r4,r2
811099fc:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a00:	e0bfff17 	ldw	r2,-4(fp)
81109a04:	10800017 	ldw	r2,0(r2)
81109a08:	01402e04 	movi	r5,184
81109a0c:	1009883a 	mov	r4,r2
81109a10:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109a14:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81109a18:	e0bffe17 	ldw	r2,-8(fp)
81109a1c:	10bfffec 	andhi	r2,r2,65535
81109a20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81109a24:	e0bfff17 	ldw	r2,-4(fp)
81109a28:	10803e0b 	ldhu	r2,248(r2)
81109a2c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81109a30:	e0bffe17 	ldw	r2,-8(fp)
81109a34:	1884b03a 	or	r2,r3,r2
81109a38:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109a3c:	e0bffe17 	ldw	r2,-8(fp)
81109a40:	10bfffcc 	andi	r2,r2,65535
81109a44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109a48:	e0bfff17 	ldw	r2,-4(fp)
81109a4c:	10803e8b 	ldhu	r2,250(r2)
81109a50:	10bfffcc 	andi	r2,r2,65535
81109a54:	1004943a 	slli	r2,r2,16
81109a58:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109a5c:	e0bffe17 	ldw	r2,-8(fp)
81109a60:	1884b03a 	or	r2,r3,r2
81109a64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109a68:	e0bfff17 	ldw	r2,-4(fp)
81109a6c:	10800017 	ldw	r2,0(r2)
81109a70:	e0fffe17 	ldw	r3,-8(fp)
81109a74:	180d883a 	mov	r6,r3
81109a78:	01402e04 	movi	r5,184
81109a7c:	1009883a 	mov	r4,r2
81109a80:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a84:	e0bfff17 	ldw	r2,-4(fp)
81109a88:	10800017 	ldw	r2,0(r2)
81109a8c:	01402e44 	movi	r5,185
81109a90:	1009883a 	mov	r4,r2
81109a94:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109a98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81109a9c:	e0bffe17 	ldw	r2,-8(fp)
81109aa0:	10bfffec 	andhi	r2,r2,65535
81109aa4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81109aa8:	e0bfff17 	ldw	r2,-4(fp)
81109aac:	10803f0b 	ldhu	r2,252(r2)
81109ab0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81109ab4:	e0bffe17 	ldw	r2,-8(fp)
81109ab8:	1884b03a 	or	r2,r3,r2
81109abc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81109ac0:	e0bffe17 	ldw	r2,-8(fp)
81109ac4:	10bfffcc 	andi	r2,r2,65535
81109ac8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
81109acc:	e0bfff17 	ldw	r2,-4(fp)
81109ad0:	10803f8b 	ldhu	r2,254(r2)
81109ad4:	10bfffcc 	andi	r2,r2,65535
81109ad8:	1004943a 	slli	r2,r2,16
81109adc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
81109ae0:	e0bffe17 	ldw	r2,-8(fp)
81109ae4:	1884b03a 	or	r2,r3,r2
81109ae8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81109aec:	e0bfff17 	ldw	r2,-4(fp)
81109af0:	10800017 	ldw	r2,0(r2)
81109af4:	e0fffe17 	ldw	r3,-8(fp)
81109af8:	180d883a 	mov	r6,r3
81109afc:	01402e44 	movi	r5,185
81109b00:	1009883a 	mov	r4,r2
81109b04:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b08:	e0bfff17 	ldw	r2,-4(fp)
81109b0c:	10800017 	ldw	r2,0(r2)
81109b10:	01402e84 	movi	r5,186
81109b14:	1009883a 	mov	r4,r2
81109b18:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109b1c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81109b20:	e0bffe17 	ldw	r2,-8(fp)
81109b24:	10bfffec 	andhi	r2,r2,65535
81109b28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81109b2c:	e0bfff17 	ldw	r2,-4(fp)
81109b30:	1080400b 	ldhu	r2,256(r2)
81109b34:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81109b38:	e0bffe17 	ldw	r2,-8(fp)
81109b3c:	1884b03a 	or	r2,r3,r2
81109b40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109b44:	e0bffe17 	ldw	r2,-8(fp)
81109b48:	10bfffcc 	andi	r2,r2,65535
81109b4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81109b50:	e0bfff17 	ldw	r2,-4(fp)
81109b54:	1080408b 	ldhu	r2,258(r2)
81109b58:	10bfffcc 	andi	r2,r2,65535
81109b5c:	1004943a 	slli	r2,r2,16
81109b60:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109b64:	e0bffe17 	ldw	r2,-8(fp)
81109b68:	1884b03a 	or	r2,r3,r2
81109b6c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81109b70:	e0bfff17 	ldw	r2,-4(fp)
81109b74:	10800017 	ldw	r2,0(r2)
81109b78:	e0fffe17 	ldw	r3,-8(fp)
81109b7c:	180d883a 	mov	r6,r3
81109b80:	01402e84 	movi	r5,186
81109b84:	1009883a 	mov	r4,r2
81109b88:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b8c:	e0bfff17 	ldw	r2,-4(fp)
81109b90:	10800017 	ldw	r2,0(r2)
81109b94:	01402ec4 	movi	r5,187
81109b98:	1009883a 	mov	r4,r2
81109b9c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109ba0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81109ba4:	e0bffe17 	ldw	r2,-8(fp)
81109ba8:	10bfffec 	andhi	r2,r2,65535
81109bac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81109bb0:	e0bfff17 	ldw	r2,-4(fp)
81109bb4:	1080410b 	ldhu	r2,260(r2)
81109bb8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81109bbc:	e0bffe17 	ldw	r2,-8(fp)
81109bc0:	1884b03a 	or	r2,r3,r2
81109bc4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81109bc8:	e0bffe17 	ldw	r2,-8(fp)
81109bcc:	10bfffcc 	andi	r2,r2,65535
81109bd0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
81109bd4:	e0bfff17 	ldw	r2,-4(fp)
81109bd8:	1080418b 	ldhu	r2,262(r2)
81109bdc:	10bfffcc 	andi	r2,r2,65535
81109be0:	1004943a 	slli	r2,r2,16
81109be4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
81109be8:	e0bffe17 	ldw	r2,-8(fp)
81109bec:	1884b03a 	or	r2,r3,r2
81109bf0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81109bf4:	e0bfff17 	ldw	r2,-4(fp)
81109bf8:	10800017 	ldw	r2,0(r2)
81109bfc:	e0fffe17 	ldw	r3,-8(fp)
81109c00:	180d883a 	mov	r6,r3
81109c04:	01402ec4 	movi	r5,187
81109c08:	1009883a 	mov	r4,r2
81109c0c:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c10:	e0bfff17 	ldw	r2,-4(fp)
81109c14:	10800017 	ldw	r2,0(r2)
81109c18:	01402f04 	movi	r5,188
81109c1c:	1009883a 	mov	r4,r2
81109c20:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109c24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81109c28:	e0bffe17 	ldw	r2,-8(fp)
81109c2c:	10bfffec 	andhi	r2,r2,65535
81109c30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81109c34:	e0bfff17 	ldw	r2,-4(fp)
81109c38:	1080420b 	ldhu	r2,264(r2)
81109c3c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81109c40:	e0bffe17 	ldw	r2,-8(fp)
81109c44:	1884b03a 	or	r2,r3,r2
81109c48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109c4c:	e0bffe17 	ldw	r2,-8(fp)
81109c50:	10bfffcc 	andi	r2,r2,65535
81109c54:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109c58:	e0bfff17 	ldw	r2,-4(fp)
81109c5c:	1080428b 	ldhu	r2,266(r2)
81109c60:	10bfffcc 	andi	r2,r2,65535
81109c64:	1004943a 	slli	r2,r2,16
81109c68:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109c6c:	e0bffe17 	ldw	r2,-8(fp)
81109c70:	1884b03a 	or	r2,r3,r2
81109c74:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81109c78:	e0bfff17 	ldw	r2,-4(fp)
81109c7c:	10800017 	ldw	r2,0(r2)
81109c80:	e0fffe17 	ldw	r3,-8(fp)
81109c84:	180d883a 	mov	r6,r3
81109c88:	01402f04 	movi	r5,188
81109c8c:	1009883a 	mov	r4,r2
81109c90:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c94:	e0bfff17 	ldw	r2,-4(fp)
81109c98:	10800017 	ldw	r2,0(r2)
81109c9c:	01402f44 	movi	r5,189
81109ca0:	1009883a 	mov	r4,r2
81109ca4:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109ca8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81109cac:	e0bffe17 	ldw	r2,-8(fp)
81109cb0:	10bfffec 	andhi	r2,r2,65535
81109cb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81109cb8:	e0bfff17 	ldw	r2,-4(fp)
81109cbc:	1080430b 	ldhu	r2,268(r2)
81109cc0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81109cc4:	e0bffe17 	ldw	r2,-8(fp)
81109cc8:	1884b03a 	or	r2,r3,r2
81109ccc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81109cd0:	e0bffe17 	ldw	r2,-8(fp)
81109cd4:	10bfffcc 	andi	r2,r2,65535
81109cd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
81109cdc:	e0bfff17 	ldw	r2,-4(fp)
81109ce0:	1080438b 	ldhu	r2,270(r2)
81109ce4:	10bfffcc 	andi	r2,r2,65535
81109ce8:	1004943a 	slli	r2,r2,16
81109cec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
81109cf0:	e0bffe17 	ldw	r2,-8(fp)
81109cf4:	1884b03a 	or	r2,r3,r2
81109cf8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81109cfc:	e0bfff17 	ldw	r2,-4(fp)
81109d00:	10800017 	ldw	r2,0(r2)
81109d04:	e0fffe17 	ldw	r3,-8(fp)
81109d08:	180d883a 	mov	r6,r3
81109d0c:	01402f44 	movi	r5,189
81109d10:	1009883a 	mov	r4,r2
81109d14:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d18:	e0bfff17 	ldw	r2,-4(fp)
81109d1c:	10800017 	ldw	r2,0(r2)
81109d20:	01402f84 	movi	r5,190
81109d24:	1009883a 	mov	r4,r2
81109d28:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109d2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81109d30:	e0bffe17 	ldw	r2,-8(fp)
81109d34:	10bfffec 	andhi	r2,r2,65535
81109d38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81109d3c:	e0bfff17 	ldw	r2,-4(fp)
81109d40:	1080440b 	ldhu	r2,272(r2)
81109d44:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81109d48:	e0bffe17 	ldw	r2,-8(fp)
81109d4c:	1884b03a 	or	r2,r3,r2
81109d50:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109d54:	e0bffe17 	ldw	r2,-8(fp)
81109d58:	10bfffcc 	andi	r2,r2,65535
81109d5c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81109d60:	e0bfff17 	ldw	r2,-4(fp)
81109d64:	1080448b 	ldhu	r2,274(r2)
81109d68:	10bfffcc 	andi	r2,r2,65535
81109d6c:	1004943a 	slli	r2,r2,16
81109d70:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81109d74:	e0bffe17 	ldw	r2,-8(fp)
81109d78:	1884b03a 	or	r2,r3,r2
81109d7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81109d80:	e0bfff17 	ldw	r2,-4(fp)
81109d84:	10800017 	ldw	r2,0(r2)
81109d88:	e0fffe17 	ldw	r3,-8(fp)
81109d8c:	180d883a 	mov	r6,r3
81109d90:	01402f84 	movi	r5,190
81109d94:	1009883a 	mov	r4,r2
81109d98:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d9c:	e0bfff17 	ldw	r2,-4(fp)
81109da0:	10800017 	ldw	r2,0(r2)
81109da4:	01402fc4 	movi	r5,191
81109da8:	1009883a 	mov	r4,r2
81109dac:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109db0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81109db4:	e0bffe17 	ldw	r2,-8(fp)
81109db8:	10bfffec 	andhi	r2,r2,65535
81109dbc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
81109dc0:	e0bfff17 	ldw	r2,-4(fp)
81109dc4:	1080450b 	ldhu	r2,276(r2)
81109dc8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81109dcc:	e0bffe17 	ldw	r2,-8(fp)
81109dd0:	1884b03a 	or	r2,r3,r2
81109dd4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81109dd8:	e0bffe17 	ldw	r2,-8(fp)
81109ddc:	10bfffcc 	andi	r2,r2,65535
81109de0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
81109de4:	e0bfff17 	ldw	r2,-4(fp)
81109de8:	1080458b 	ldhu	r2,278(r2)
81109dec:	10bfffcc 	andi	r2,r2,65535
81109df0:	1004943a 	slli	r2,r2,16
81109df4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
81109df8:	e0bffe17 	ldw	r2,-8(fp)
81109dfc:	1884b03a 	or	r2,r3,r2
81109e00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81109e04:	e0bfff17 	ldw	r2,-4(fp)
81109e08:	10800017 	ldw	r2,0(r2)
81109e0c:	e0fffe17 	ldw	r3,-8(fp)
81109e10:	180d883a 	mov	r6,r3
81109e14:	01402fc4 	movi	r5,191
81109e18:	1009883a 	mov	r4,r2
81109e1c:	110a8180 	call	8110a818 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81109e20:	00800044 	movi	r2,1
81109e24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109e28:	e0bffd17 	ldw	r2,-12(fp)
}
81109e2c:	e037883a 	mov	sp,fp
81109e30:	dfc00117 	ldw	ra,4(sp)
81109e34:	df000017 	ldw	fp,0(sp)
81109e38:	dec00204 	addi	sp,sp,8
81109e3c:	f800283a 	ret

81109e40 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81109e40:	defffb04 	addi	sp,sp,-20
81109e44:	de00012e 	bgeu	sp,et,81109e4c <bRmapGetRmapMemHKArea+0xc>
81109e48:	003b68fa 	trap	3
81109e4c:	dfc00415 	stw	ra,16(sp)
81109e50:	df000315 	stw	fp,12(sp)
81109e54:	df000304 	addi	fp,sp,12
81109e58:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109e5c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81109e60:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81109e64:	e0bfff17 	ldw	r2,-4(fp)
81109e68:	1001e226 	beq	r2,zero,8110a5f4 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109e6c:	e0bfff17 	ldw	r2,-4(fp)
81109e70:	10800017 	ldw	r2,0(r2)
81109e74:	01402804 	movi	r5,160
81109e78:	1009883a 	mov	r4,r2
81109e7c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109e80:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81109e84:	e0bffe17 	ldw	r2,-8(fp)
81109e88:	1007883a 	mov	r3,r2
81109e8c:	e0bfff17 	ldw	r2,-4(fp)
81109e90:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81109e94:	e0bffe17 	ldw	r2,-8(fp)
81109e98:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81109e9c:	1007883a 	mov	r3,r2
81109ea0:	e0bfff17 	ldw	r2,-4(fp)
81109ea4:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ea8:	e0bfff17 	ldw	r2,-4(fp)
81109eac:	10800017 	ldw	r2,0(r2)
81109eb0:	01402844 	movi	r5,161
81109eb4:	1009883a 	mov	r4,r2
81109eb8:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109ebc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81109ec0:	e0bffe17 	ldw	r2,-8(fp)
81109ec4:	1007883a 	mov	r3,r2
81109ec8:	e0bfff17 	ldw	r2,-4(fp)
81109ecc:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81109ed0:	e0bffe17 	ldw	r2,-8(fp)
81109ed4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81109ed8:	1007883a 	mov	r3,r2
81109edc:	e0bfff17 	ldw	r2,-4(fp)
81109ee0:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ee4:	e0bfff17 	ldw	r2,-4(fp)
81109ee8:	10800017 	ldw	r2,0(r2)
81109eec:	01402884 	movi	r5,162
81109ef0:	1009883a 	mov	r4,r2
81109ef4:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109ef8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81109efc:	e0bffe17 	ldw	r2,-8(fp)
81109f00:	1007883a 	mov	r3,r2
81109f04:	e0bfff17 	ldw	r2,-4(fp)
81109f08:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81109f0c:	e0bffe17 	ldw	r2,-8(fp)
81109f10:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81109f14:	1007883a 	mov	r3,r2
81109f18:	e0bfff17 	ldw	r2,-4(fp)
81109f1c:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109f20:	e0bfff17 	ldw	r2,-4(fp)
81109f24:	10800017 	ldw	r2,0(r2)
81109f28:	014028c4 	movi	r5,163
81109f2c:	1009883a 	mov	r4,r2
81109f30:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109f34:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81109f38:	e0bffe17 	ldw	r2,-8(fp)
81109f3c:	1007883a 	mov	r3,r2
81109f40:	e0bfff17 	ldw	r2,-4(fp)
81109f44:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109f48:	e0bffe17 	ldw	r2,-8(fp)
81109f4c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109f50:	1007883a 	mov	r3,r2
81109f54:	e0bfff17 	ldw	r2,-4(fp)
81109f58:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109f5c:	e0bfff17 	ldw	r2,-4(fp)
81109f60:	10800017 	ldw	r2,0(r2)
81109f64:	01402904 	movi	r5,164
81109f68:	1009883a 	mov	r4,r2
81109f6c:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109f70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81109f74:	e0bffe17 	ldw	r2,-8(fp)
81109f78:	1007883a 	mov	r3,r2
81109f7c:	e0bfff17 	ldw	r2,-4(fp)
81109f80:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81109f84:	e0bffe17 	ldw	r2,-8(fp)
81109f88:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109f8c:	1007883a 	mov	r3,r2
81109f90:	e0bfff17 	ldw	r2,-4(fp)
81109f94:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109f98:	e0bfff17 	ldw	r2,-4(fp)
81109f9c:	10800017 	ldw	r2,0(r2)
81109fa0:	01402944 	movi	r5,165
81109fa4:	1009883a 	mov	r4,r2
81109fa8:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109fac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81109fb0:	e0bffe17 	ldw	r2,-8(fp)
81109fb4:	1007883a 	mov	r3,r2
81109fb8:	e0bfff17 	ldw	r2,-4(fp)
81109fbc:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81109fc0:	e0bffe17 	ldw	r2,-8(fp)
81109fc4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81109fc8:	1007883a 	mov	r3,r2
81109fcc:	e0bfff17 	ldw	r2,-4(fp)
81109fd0:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109fd4:	e0bfff17 	ldw	r2,-4(fp)
81109fd8:	10800017 	ldw	r2,0(r2)
81109fdc:	01402984 	movi	r5,166
81109fe0:	1009883a 	mov	r4,r2
81109fe4:	110a86c0 	call	8110a86c <uliRmapReadReg>
81109fe8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
81109fec:	e0bffe17 	ldw	r2,-8(fp)
81109ff0:	1007883a 	mov	r3,r2
81109ff4:	e0bfff17 	ldw	r2,-4(fp)
81109ff8:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81109ffc:	e0bffe17 	ldw	r2,-8(fp)
8110a000:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
8110a004:	1007883a 	mov	r3,r2
8110a008:	e0bfff17 	ldw	r2,-4(fp)
8110a00c:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a010:	e0bfff17 	ldw	r2,-4(fp)
8110a014:	10800017 	ldw	r2,0(r2)
8110a018:	014029c4 	movi	r5,167
8110a01c:	1009883a 	mov	r4,r2
8110a020:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a024:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
8110a028:	e0bffe17 	ldw	r2,-8(fp)
8110a02c:	1007883a 	mov	r3,r2
8110a030:	e0bfff17 	ldw	r2,-4(fp)
8110a034:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
8110a038:	e0bffe17 	ldw	r2,-8(fp)
8110a03c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
8110a040:	1007883a 	mov	r3,r2
8110a044:	e0bfff17 	ldw	r2,-4(fp)
8110a048:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a04c:	e0bfff17 	ldw	r2,-4(fp)
8110a050:	10800017 	ldw	r2,0(r2)
8110a054:	01402a04 	movi	r5,168
8110a058:	1009883a 	mov	r4,r2
8110a05c:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a060:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
8110a064:	e0bffe17 	ldw	r2,-8(fp)
8110a068:	1007883a 	mov	r3,r2
8110a06c:	e0bfff17 	ldw	r2,-4(fp)
8110a070:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
8110a074:	e0bffe17 	ldw	r2,-8(fp)
8110a078:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
8110a07c:	1007883a 	mov	r3,r2
8110a080:	e0bfff17 	ldw	r2,-4(fp)
8110a084:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a088:	e0bfff17 	ldw	r2,-4(fp)
8110a08c:	10800017 	ldw	r2,0(r2)
8110a090:	01402a44 	movi	r5,169
8110a094:	1009883a 	mov	r4,r2
8110a098:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a09c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
8110a0a0:	e0bffe17 	ldw	r2,-8(fp)
8110a0a4:	1007883a 	mov	r3,r2
8110a0a8:	e0bfff17 	ldw	r2,-4(fp)
8110a0ac:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
8110a0b0:	e0bffe17 	ldw	r2,-8(fp)
8110a0b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
8110a0b8:	1007883a 	mov	r3,r2
8110a0bc:	e0bfff17 	ldw	r2,-4(fp)
8110a0c0:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a0c4:	e0bfff17 	ldw	r2,-4(fp)
8110a0c8:	10800017 	ldw	r2,0(r2)
8110a0cc:	01402a84 	movi	r5,170
8110a0d0:	1009883a 	mov	r4,r2
8110a0d4:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a0d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
8110a0dc:	e0bffe17 	ldw	r2,-8(fp)
8110a0e0:	1007883a 	mov	r3,r2
8110a0e4:	e0bfff17 	ldw	r2,-4(fp)
8110a0e8:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
8110a0ec:	e0bffe17 	ldw	r2,-8(fp)
8110a0f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
8110a0f4:	1007883a 	mov	r3,r2
8110a0f8:	e0bfff17 	ldw	r2,-4(fp)
8110a0fc:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a100:	e0bfff17 	ldw	r2,-4(fp)
8110a104:	10800017 	ldw	r2,0(r2)
8110a108:	01402ac4 	movi	r5,171
8110a10c:	1009883a 	mov	r4,r2
8110a110:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a114:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
8110a118:	e0bffe17 	ldw	r2,-8(fp)
8110a11c:	1007883a 	mov	r3,r2
8110a120:	e0bfff17 	ldw	r2,-4(fp)
8110a124:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
8110a128:	e0bffe17 	ldw	r2,-8(fp)
8110a12c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
8110a130:	1007883a 	mov	r3,r2
8110a134:	e0bfff17 	ldw	r2,-4(fp)
8110a138:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a13c:	e0bfff17 	ldw	r2,-4(fp)
8110a140:	10800017 	ldw	r2,0(r2)
8110a144:	01402b04 	movi	r5,172
8110a148:	1009883a 	mov	r4,r2
8110a14c:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a150:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
8110a154:	e0bffe17 	ldw	r2,-8(fp)
8110a158:	1007883a 	mov	r3,r2
8110a15c:	e0bfff17 	ldw	r2,-4(fp)
8110a160:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
8110a164:	e0bffe17 	ldw	r2,-8(fp)
8110a168:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
8110a16c:	1007883a 	mov	r3,r2
8110a170:	e0bfff17 	ldw	r2,-4(fp)
8110a174:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a178:	e0bfff17 	ldw	r2,-4(fp)
8110a17c:	10800017 	ldw	r2,0(r2)
8110a180:	01402b44 	movi	r5,173
8110a184:	1009883a 	mov	r4,r2
8110a188:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a18c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
8110a190:	e0bffe17 	ldw	r2,-8(fp)
8110a194:	1007883a 	mov	r3,r2
8110a198:	e0bfff17 	ldw	r2,-4(fp)
8110a19c:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
8110a1a0:	e0bffe17 	ldw	r2,-8(fp)
8110a1a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
8110a1a8:	1007883a 	mov	r3,r2
8110a1ac:	e0bfff17 	ldw	r2,-4(fp)
8110a1b0:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a1b4:	e0bfff17 	ldw	r2,-4(fp)
8110a1b8:	10800017 	ldw	r2,0(r2)
8110a1bc:	01402b84 	movi	r5,174
8110a1c0:	1009883a 	mov	r4,r2
8110a1c4:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a1c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
8110a1cc:	e0bffe17 	ldw	r2,-8(fp)
8110a1d0:	1007883a 	mov	r3,r2
8110a1d4:	e0bfff17 	ldw	r2,-4(fp)
8110a1d8:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
8110a1dc:	e0bffe17 	ldw	r2,-8(fp)
8110a1e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
8110a1e4:	1007883a 	mov	r3,r2
8110a1e8:	e0bfff17 	ldw	r2,-4(fp)
8110a1ec:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a1f0:	e0bfff17 	ldw	r2,-4(fp)
8110a1f4:	10800017 	ldw	r2,0(r2)
8110a1f8:	01402bc4 	movi	r5,175
8110a1fc:	1009883a 	mov	r4,r2
8110a200:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a204:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
8110a208:	e0bffe17 	ldw	r2,-8(fp)
8110a20c:	1007883a 	mov	r3,r2
8110a210:	e0bfff17 	ldw	r2,-4(fp)
8110a214:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
8110a218:	e0bffe17 	ldw	r2,-8(fp)
8110a21c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
8110a220:	1007883a 	mov	r3,r2
8110a224:	e0bfff17 	ldw	r2,-4(fp)
8110a228:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a22c:	e0bfff17 	ldw	r2,-4(fp)
8110a230:	10800017 	ldw	r2,0(r2)
8110a234:	01402c04 	movi	r5,176
8110a238:	1009883a 	mov	r4,r2
8110a23c:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a240:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
8110a244:	e0bffe17 	ldw	r2,-8(fp)
8110a248:	1007883a 	mov	r3,r2
8110a24c:	e0bfff17 	ldw	r2,-4(fp)
8110a250:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
8110a254:	e0bffe17 	ldw	r2,-8(fp)
8110a258:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
8110a25c:	1007883a 	mov	r3,r2
8110a260:	e0bfff17 	ldw	r2,-4(fp)
8110a264:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a268:	e0bfff17 	ldw	r2,-4(fp)
8110a26c:	10800017 	ldw	r2,0(r2)
8110a270:	01402c44 	movi	r5,177
8110a274:	1009883a 	mov	r4,r2
8110a278:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a27c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
8110a280:	e0bffe17 	ldw	r2,-8(fp)
8110a284:	1007883a 	mov	r3,r2
8110a288:	e0bfff17 	ldw	r2,-4(fp)
8110a28c:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
8110a290:	e0bffe17 	ldw	r2,-8(fp)
8110a294:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
8110a298:	1007883a 	mov	r3,r2
8110a29c:	e0bfff17 	ldw	r2,-4(fp)
8110a2a0:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a2a4:	e0bfff17 	ldw	r2,-4(fp)
8110a2a8:	10800017 	ldw	r2,0(r2)
8110a2ac:	01402c84 	movi	r5,178
8110a2b0:	1009883a 	mov	r4,r2
8110a2b4:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a2b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
8110a2bc:	e0bffe17 	ldw	r2,-8(fp)
8110a2c0:	1007883a 	mov	r3,r2
8110a2c4:	e0bfff17 	ldw	r2,-4(fp)
8110a2c8:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
8110a2cc:	e0bffe17 	ldw	r2,-8(fp)
8110a2d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
8110a2d4:	1007883a 	mov	r3,r2
8110a2d8:	e0bfff17 	ldw	r2,-4(fp)
8110a2dc:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a2e0:	e0bfff17 	ldw	r2,-4(fp)
8110a2e4:	10800017 	ldw	r2,0(r2)
8110a2e8:	01402cc4 	movi	r5,179
8110a2ec:	1009883a 	mov	r4,r2
8110a2f0:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a2f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
8110a2f8:	e0bffe17 	ldw	r2,-8(fp)
8110a2fc:	1007883a 	mov	r3,r2
8110a300:	e0bfff17 	ldw	r2,-4(fp)
8110a304:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
8110a308:	e0bffe17 	ldw	r2,-8(fp)
8110a30c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
8110a310:	1007883a 	mov	r3,r2
8110a314:	e0bfff17 	ldw	r2,-4(fp)
8110a318:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a31c:	e0bfff17 	ldw	r2,-4(fp)
8110a320:	10800017 	ldw	r2,0(r2)
8110a324:	01402d04 	movi	r5,180
8110a328:	1009883a 	mov	r4,r2
8110a32c:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a330:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
8110a334:	e0bffe17 	ldw	r2,-8(fp)
8110a338:	1007883a 	mov	r3,r2
8110a33c:	e0bfff17 	ldw	r2,-4(fp)
8110a340:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
8110a344:	e0bffe17 	ldw	r2,-8(fp)
8110a348:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
8110a34c:	1007883a 	mov	r3,r2
8110a350:	e0bfff17 	ldw	r2,-4(fp)
8110a354:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a358:	e0bfff17 	ldw	r2,-4(fp)
8110a35c:	10800017 	ldw	r2,0(r2)
8110a360:	01402d44 	movi	r5,181
8110a364:	1009883a 	mov	r4,r2
8110a368:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a36c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
8110a370:	e0bffe17 	ldw	r2,-8(fp)
8110a374:	1007883a 	mov	r3,r2
8110a378:	e0bfff17 	ldw	r2,-4(fp)
8110a37c:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
8110a380:	e0bffe17 	ldw	r2,-8(fp)
8110a384:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
8110a388:	1007883a 	mov	r3,r2
8110a38c:	e0bfff17 	ldw	r2,-4(fp)
8110a390:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a394:	e0bfff17 	ldw	r2,-4(fp)
8110a398:	10800017 	ldw	r2,0(r2)
8110a39c:	01402d84 	movi	r5,182
8110a3a0:	1009883a 	mov	r4,r2
8110a3a4:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a3a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
8110a3ac:	e0bffe17 	ldw	r2,-8(fp)
8110a3b0:	1007883a 	mov	r3,r2
8110a3b4:	e0bfff17 	ldw	r2,-4(fp)
8110a3b8:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
8110a3bc:	e0bffe17 	ldw	r2,-8(fp)
8110a3c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
8110a3c4:	1007883a 	mov	r3,r2
8110a3c8:	e0bfff17 	ldw	r2,-4(fp)
8110a3cc:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a3d0:	e0bfff17 	ldw	r2,-4(fp)
8110a3d4:	10800017 	ldw	r2,0(r2)
8110a3d8:	01402dc4 	movi	r5,183
8110a3dc:	1009883a 	mov	r4,r2
8110a3e0:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a3e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
8110a3e8:	e0bffe17 	ldw	r2,-8(fp)
8110a3ec:	1007883a 	mov	r3,r2
8110a3f0:	e0bfff17 	ldw	r2,-4(fp)
8110a3f4:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
8110a3f8:	e0bffe17 	ldw	r2,-8(fp)
8110a3fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
8110a400:	1007883a 	mov	r3,r2
8110a404:	e0bfff17 	ldw	r2,-4(fp)
8110a408:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a40c:	e0bfff17 	ldw	r2,-4(fp)
8110a410:	10800017 	ldw	r2,0(r2)
8110a414:	01402e04 	movi	r5,184
8110a418:	1009883a 	mov	r4,r2
8110a41c:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a420:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
8110a424:	e0bffe17 	ldw	r2,-8(fp)
8110a428:	1007883a 	mov	r3,r2
8110a42c:	e0bfff17 	ldw	r2,-4(fp)
8110a430:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
8110a434:	e0bffe17 	ldw	r2,-8(fp)
8110a438:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
8110a43c:	1007883a 	mov	r3,r2
8110a440:	e0bfff17 	ldw	r2,-4(fp)
8110a444:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a448:	e0bfff17 	ldw	r2,-4(fp)
8110a44c:	10800017 	ldw	r2,0(r2)
8110a450:	01402e44 	movi	r5,185
8110a454:	1009883a 	mov	r4,r2
8110a458:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a45c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
8110a460:	e0bffe17 	ldw	r2,-8(fp)
8110a464:	1007883a 	mov	r3,r2
8110a468:	e0bfff17 	ldw	r2,-4(fp)
8110a46c:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
8110a470:	e0bffe17 	ldw	r2,-8(fp)
8110a474:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
8110a478:	1007883a 	mov	r3,r2
8110a47c:	e0bfff17 	ldw	r2,-4(fp)
8110a480:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a484:	e0bfff17 	ldw	r2,-4(fp)
8110a488:	10800017 	ldw	r2,0(r2)
8110a48c:	01402e84 	movi	r5,186
8110a490:	1009883a 	mov	r4,r2
8110a494:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a498:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
8110a49c:	e0bffe17 	ldw	r2,-8(fp)
8110a4a0:	1007883a 	mov	r3,r2
8110a4a4:	e0bfff17 	ldw	r2,-4(fp)
8110a4a8:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
8110a4ac:	e0bffe17 	ldw	r2,-8(fp)
8110a4b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
8110a4b4:	1007883a 	mov	r3,r2
8110a4b8:	e0bfff17 	ldw	r2,-4(fp)
8110a4bc:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a4c0:	e0bfff17 	ldw	r2,-4(fp)
8110a4c4:	10800017 	ldw	r2,0(r2)
8110a4c8:	01402ec4 	movi	r5,187
8110a4cc:	1009883a 	mov	r4,r2
8110a4d0:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a4d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
8110a4d8:	e0bffe17 	ldw	r2,-8(fp)
8110a4dc:	1007883a 	mov	r3,r2
8110a4e0:	e0bfff17 	ldw	r2,-4(fp)
8110a4e4:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
8110a4e8:	e0bffe17 	ldw	r2,-8(fp)
8110a4ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
8110a4f0:	1007883a 	mov	r3,r2
8110a4f4:	e0bfff17 	ldw	r2,-4(fp)
8110a4f8:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a4fc:	e0bfff17 	ldw	r2,-4(fp)
8110a500:	10800017 	ldw	r2,0(r2)
8110a504:	01402f04 	movi	r5,188
8110a508:	1009883a 	mov	r4,r2
8110a50c:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a510:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
8110a514:	e0bffe17 	ldw	r2,-8(fp)
8110a518:	1007883a 	mov	r3,r2
8110a51c:	e0bfff17 	ldw	r2,-4(fp)
8110a520:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
8110a524:	e0bffe17 	ldw	r2,-8(fp)
8110a528:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
8110a52c:	1007883a 	mov	r3,r2
8110a530:	e0bfff17 	ldw	r2,-4(fp)
8110a534:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a538:	e0bfff17 	ldw	r2,-4(fp)
8110a53c:	10800017 	ldw	r2,0(r2)
8110a540:	01402f44 	movi	r5,189
8110a544:	1009883a 	mov	r4,r2
8110a548:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a54c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
8110a550:	e0bffe17 	ldw	r2,-8(fp)
8110a554:	1007883a 	mov	r3,r2
8110a558:	e0bfff17 	ldw	r2,-4(fp)
8110a55c:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
8110a560:	e0bffe17 	ldw	r2,-8(fp)
8110a564:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
8110a568:	1007883a 	mov	r3,r2
8110a56c:	e0bfff17 	ldw	r2,-4(fp)
8110a570:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a574:	e0bfff17 	ldw	r2,-4(fp)
8110a578:	10800017 	ldw	r2,0(r2)
8110a57c:	01402f84 	movi	r5,190
8110a580:	1009883a 	mov	r4,r2
8110a584:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a588:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
8110a58c:	e0bffe17 	ldw	r2,-8(fp)
8110a590:	1007883a 	mov	r3,r2
8110a594:	e0bfff17 	ldw	r2,-4(fp)
8110a598:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
8110a59c:	e0bffe17 	ldw	r2,-8(fp)
8110a5a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
8110a5a4:	1007883a 	mov	r3,r2
8110a5a8:	e0bfff17 	ldw	r2,-4(fp)
8110a5ac:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a5b0:	e0bfff17 	ldw	r2,-4(fp)
8110a5b4:	10800017 	ldw	r2,0(r2)
8110a5b8:	01402fc4 	movi	r5,191
8110a5bc:	1009883a 	mov	r4,r2
8110a5c0:	110a86c0 	call	8110a86c <uliRmapReadReg>
8110a5c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
8110a5c8:	e0bffe17 	ldw	r2,-8(fp)
8110a5cc:	1007883a 	mov	r3,r2
8110a5d0:	e0bfff17 	ldw	r2,-4(fp)
8110a5d4:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
8110a5d8:	e0bffe17 	ldw	r2,-8(fp)
8110a5dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
8110a5e0:	1007883a 	mov	r3,r2
8110a5e4:	e0bfff17 	ldw	r2,-4(fp)
8110a5e8:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
8110a5ec:	00800044 	movi	r2,1
8110a5f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a5f4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a5f8:	e037883a 	mov	sp,fp
8110a5fc:	dfc00117 	ldw	ra,4(sp)
8110a600:	df000017 	ldw	fp,0(sp)
8110a604:	dec00204 	addi	sp,sp,8
8110a608:	f800283a 	ret

8110a60c <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
8110a60c:	defff904 	addi	sp,sp,-28
8110a610:	de00012e 	bgeu	sp,et,8110a618 <bRmapInitCh+0xc>
8110a614:	003b68fa 	trap	3
8110a618:	dfc00615 	stw	ra,24(sp)
8110a61c:	df000515 	stw	fp,20(sp)
8110a620:	df000504 	addi	fp,sp,20
8110a624:	e13ffe15 	stw	r4,-8(fp)
8110a628:	2805883a 	mov	r2,r5
8110a62c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a630:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8110a634:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8110a638:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
8110a63c:	e0bffe17 	ldw	r2,-8(fp)
8110a640:	10006f26 	beq	r2,zero,8110a800 <bRmapInitCh+0x1f4>

		switch (ucCommCh) {
8110a644:	e0bfff03 	ldbu	r2,-4(fp)
8110a648:	10c00228 	cmpgeui	r3,r2,8
8110a64c:	1800461e 	bne	r3,zero,8110a768 <bRmapInitCh+0x15c>
8110a650:	100690ba 	slli	r3,r2,2
8110a654:	00a04474 	movhi	r2,33041
8110a658:	10a99a04 	addi	r2,r2,-22936
8110a65c:	1885883a 	add	r2,r3,r2
8110a660:	10800017 	ldw	r2,0(r2)
8110a664:	1000683a 	jmp	r2
8110a668:	8110a688 	cmpgei	r4,r16,17050
8110a66c:	8110a6a4 	muli	r4,r16,17050
8110a670:	8110a6c0 	call	88110a6c <__reset+0x20f0a6c>
8110a674:	8110a6dc 	xori	r4,r16,17051
8110a678:	8110a6f8 	rdprs	r4,r16,17051
8110a67c:	8110a714 	ori	r4,r16,17052
8110a680:	8110a730 	cmpltui	r4,r16,17052
8110a684:	8110a74c 	andi	r4,r16,17053
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a688:	e0fffe17 	ldw	r3,-8(fp)
8110a68c:	00a04834 	movhi	r2,33056
8110a690:	108b0004 	addi	r2,r2,11264
8110a694:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a698:	00800044 	movi	r2,1
8110a69c:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a6a0:	00003306 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a6a4:	e0fffe17 	ldw	r3,-8(fp)
8110a6a8:	00a04834 	movhi	r2,33056
8110a6ac:	108a0004 	addi	r2,r2,10240
8110a6b0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a6b4:	00800044 	movi	r2,1
8110a6b8:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a6bc:	00002c06 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a6c0:	e0fffe17 	ldw	r3,-8(fp)
8110a6c4:	00a04834 	movhi	r2,33056
8110a6c8:	108b0004 	addi	r2,r2,11264
8110a6cc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a6d0:	00800044 	movi	r2,1
8110a6d4:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a6d8:	00002506 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a6dc:	e0fffe17 	ldw	r3,-8(fp)
8110a6e0:	00a04834 	movhi	r2,33056
8110a6e4:	108a0004 	addi	r2,r2,10240
8110a6e8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a6ec:	00800044 	movi	r2,1
8110a6f0:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a6f4:	00001e06 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a6f8:	e0fffe17 	ldw	r3,-8(fp)
8110a6fc:	00a04834 	movhi	r2,33056
8110a700:	108b0004 	addi	r2,r2,11264
8110a704:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a708:	00800044 	movi	r2,1
8110a70c:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a710:	00001706 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a714:	e0fffe17 	ldw	r3,-8(fp)
8110a718:	00a04834 	movhi	r2,33056
8110a71c:	108a0004 	addi	r2,r2,10240
8110a720:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a724:	00800044 	movi	r2,1
8110a728:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a72c:	00001006 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a730:	e0fffe17 	ldw	r3,-8(fp)
8110a734:	00a04834 	movhi	r2,33056
8110a738:	108b0004 	addi	r2,r2,11264
8110a73c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a740:	00800044 	movi	r2,1
8110a744:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a748:	00000906 	br	8110a770 <bRmapInitCh+0x164>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a74c:	e0fffe17 	ldw	r3,-8(fp)
8110a750:	00a04834 	movhi	r2,33056
8110a754:	108a0004 	addi	r2,r2,10240
8110a758:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a75c:	00800044 	movi	r2,1
8110a760:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a764:	00000206 	br	8110a770 <bRmapInitCh+0x164>
		default:
			bValidCh = FALSE;
8110a768:	e03ffc15 	stw	zero,-16(fp)
			break;
8110a76c:	0001883a 	nop
		}

		if (bValidCh) {
8110a770:	e0bffc17 	ldw	r2,-16(fp)
8110a774:	10002226 	beq	r2,zero,8110a800 <bRmapInitCh+0x1f4>
			if (!bRmapGetIrqControl(pxRmapCh)) {
8110a778:	e13ffe17 	ldw	r4,-8(fp)
8110a77c:	11081a00 	call	811081a0 <bRmapGetIrqControl>
8110a780:	1000021e 	bne	r2,zero,8110a78c <bRmapInitCh+0x180>
				bInitFail = TRUE;
8110a784:	00800044 	movi	r2,1
8110a788:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
8110a78c:	e13ffe17 	ldw	r4,-8(fp)
8110a790:	110838c0 	call	8110838c <bRmapGetCodecConfig>
8110a794:	1000021e 	bne	r2,zero,8110a7a0 <bRmapInitCh+0x194>
				bInitFail = TRUE;
8110a798:	00800044 	movi	r2,1
8110a79c:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
8110a7a0:	e13ffe17 	ldw	r4,-8(fp)
8110a7a4:	11084180 	call	81108418 <bRmapGetCodecStatus>
8110a7a8:	1000021e 	bne	r2,zero,8110a7b4 <bRmapInitCh+0x1a8>
				bInitFail = TRUE;
8110a7ac:	00800044 	movi	r2,1
8110a7b0:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
8110a7b4:	e13ffe17 	ldw	r4,-8(fp)
8110a7b8:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
8110a7bc:	1000021e 	bne	r2,zero,8110a7c8 <bRmapInitCh+0x1bc>
				bInitFail = TRUE;
8110a7c0:	00800044 	movi	r2,1
8110a7c4:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
8110a7c8:	e13ffe17 	ldw	r4,-8(fp)
8110a7cc:	1108ce00 	call	81108ce0 <bRmapGetMemConfigStat>
8110a7d0:	1000021e 	bne	r2,zero,8110a7dc <bRmapInitCh+0x1d0>
				bInitFail = TRUE;
8110a7d4:	00800044 	movi	r2,1
8110a7d8:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
8110a7dc:	e13ffe17 	ldw	r4,-8(fp)
8110a7e0:	1109e400 	call	81109e40 <bRmapGetRmapMemHKArea>
8110a7e4:	1000021e 	bne	r2,zero,8110a7f0 <bRmapInitCh+0x1e4>
				bInitFail = TRUE;
8110a7e8:	00800044 	movi	r2,1
8110a7ec:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8110a7f0:	e0bffd17 	ldw	r2,-12(fp)
8110a7f4:	1000021e 	bne	r2,zero,8110a800 <bRmapInitCh+0x1f4>
				bStatus = TRUE;
8110a7f8:	00800044 	movi	r2,1
8110a7fc:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8110a800:	e0bffb17 	ldw	r2,-20(fp)
}
8110a804:	e037883a 	mov	sp,fp
8110a808:	dfc00117 	ldw	ra,4(sp)
8110a80c:	df000017 	ldw	fp,0(sp)
8110a810:	dec00204 	addi	sp,sp,8
8110a814:	f800283a 	ret

8110a818 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a818:	defffc04 	addi	sp,sp,-16
8110a81c:	de00012e 	bgeu	sp,et,8110a824 <vRmapWriteReg+0xc>
8110a820:	003b68fa 	trap	3
8110a824:	df000315 	stw	fp,12(sp)
8110a828:	df000304 	addi	fp,sp,12
8110a82c:	e13ffd15 	stw	r4,-12(fp)
8110a830:	e17ffe15 	stw	r5,-8(fp)
8110a834:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a838:	e0bffe17 	ldw	r2,-8(fp)
8110a83c:	1085883a 	add	r2,r2,r2
8110a840:	1085883a 	add	r2,r2,r2
8110a844:	1007883a 	mov	r3,r2
8110a848:	e0bffd17 	ldw	r2,-12(fp)
8110a84c:	10c5883a 	add	r2,r2,r3
8110a850:	e0ffff17 	ldw	r3,-4(fp)
8110a854:	10c00015 	stw	r3,0(r2)
}
8110a858:	0001883a 	nop
8110a85c:	e037883a 	mov	sp,fp
8110a860:	df000017 	ldw	fp,0(sp)
8110a864:	dec00104 	addi	sp,sp,4
8110a868:	f800283a 	ret

8110a86c <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a86c:	defffc04 	addi	sp,sp,-16
8110a870:	de00012e 	bgeu	sp,et,8110a878 <uliRmapReadReg+0xc>
8110a874:	003b68fa 	trap	3
8110a878:	df000315 	stw	fp,12(sp)
8110a87c:	df000304 	addi	fp,sp,12
8110a880:	e13ffe15 	stw	r4,-8(fp)
8110a884:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a888:	e0bfff17 	ldw	r2,-4(fp)
8110a88c:	1085883a 	add	r2,r2,r2
8110a890:	1085883a 	add	r2,r2,r2
8110a894:	1007883a 	mov	r3,r2
8110a898:	e0bffe17 	ldw	r2,-8(fp)
8110a89c:	10c5883a 	add	r2,r2,r3
8110a8a0:	10800017 	ldw	r2,0(r2)
8110a8a4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a8a8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a8ac:	e037883a 	mov	sp,fp
8110a8b0:	df000017 	ldw	fp,0(sp)
8110a8b4:	dec00104 	addi	sp,sp,4
8110a8b8:	f800283a 	ret

8110a8bc <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
8110a8bc:	defffd04 	addi	sp,sp,-12
8110a8c0:	de00012e 	bgeu	sp,et,8110a8c8 <uliConvRmapCfgAddr+0xc>
8110a8c4:	003b68fa 	trap	3
8110a8c8:	df000215 	stw	fp,8(sp)
8110a8cc:	df000204 	addi	fp,sp,8
8110a8d0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
8110a8d4:	e0bfff17 	ldw	r2,-4(fp)
8110a8d8:	10801368 	cmpgeui	r2,r2,77
8110a8dc:	10008a1e 	bne	r2,zero,8110ab08 <uliConvRmapCfgAddr+0x24c>
8110a8e0:	e0bfff17 	ldw	r2,-4(fp)
8110a8e4:	100690ba 	slli	r3,r2,2
8110a8e8:	00a04474 	movhi	r2,33041
8110a8ec:	10aa3f04 	addi	r2,r2,-22276
8110a8f0:	1885883a 	add	r2,r3,r2
8110a8f4:	10800017 	ldw	r2,0(r2)
8110a8f8:	1000683a 	jmp	r2
8110a8fc:	8110aa30 	cmpltui	r4,r16,17064
8110a900:	8110ab08 	cmpgei	r4,r16,17068
8110a904:	8110ab08 	cmpgei	r4,r16,17068
8110a908:	8110ab08 	cmpgei	r4,r16,17068
8110a90c:	8110aa3c 	xorhi	r4,r16,17064
8110a910:	8110ab08 	cmpgei	r4,r16,17068
8110a914:	8110ab08 	cmpgei	r4,r16,17068
8110a918:	8110ab08 	cmpgei	r4,r16,17068
8110a91c:	8110aa48 	cmpgei	r4,r16,17065
8110a920:	8110ab08 	cmpgei	r4,r16,17068
8110a924:	8110ab08 	cmpgei	r4,r16,17068
8110a928:	8110ab08 	cmpgei	r4,r16,17068
8110a92c:	8110aa54 	ori	r4,r16,17065
8110a930:	8110ab08 	cmpgei	r4,r16,17068
8110a934:	8110ab08 	cmpgei	r4,r16,17068
8110a938:	8110ab08 	cmpgei	r4,r16,17068
8110a93c:	8110aa60 	cmpeqi	r4,r16,17065
8110a940:	8110ab08 	cmpgei	r4,r16,17068
8110a944:	8110ab08 	cmpgei	r4,r16,17068
8110a948:	8110ab08 	cmpgei	r4,r16,17068
8110a94c:	8110aa6c 	andhi	r4,r16,17065
8110a950:	8110ab08 	cmpgei	r4,r16,17068
8110a954:	8110ab08 	cmpgei	r4,r16,17068
8110a958:	8110ab08 	cmpgei	r4,r16,17068
8110a95c:	8110aa78 	rdprs	r4,r16,17065
8110a960:	8110ab08 	cmpgei	r4,r16,17068
8110a964:	8110ab08 	cmpgei	r4,r16,17068
8110a968:	8110ab08 	cmpgei	r4,r16,17068
8110a96c:	8110aa84 	addi	r4,r16,17066
8110a970:	8110ab08 	cmpgei	r4,r16,17068
8110a974:	8110ab08 	cmpgei	r4,r16,17068
8110a978:	8110ab08 	cmpgei	r4,r16,17068
8110a97c:	8110aa90 	cmplti	r4,r16,17066
8110a980:	8110ab08 	cmpgei	r4,r16,17068
8110a984:	8110ab08 	cmpgei	r4,r16,17068
8110a988:	8110ab08 	cmpgei	r4,r16,17068
8110a98c:	8110aa9c 	xori	r4,r16,17066
8110a990:	8110ab08 	cmpgei	r4,r16,17068
8110a994:	8110ab08 	cmpgei	r4,r16,17068
8110a998:	8110ab08 	cmpgei	r4,r16,17068
8110a99c:	8110aaa8 	cmpgeui	r4,r16,17066
8110a9a0:	8110ab08 	cmpgei	r4,r16,17068
8110a9a4:	8110ab08 	cmpgei	r4,r16,17068
8110a9a8:	8110ab08 	cmpgei	r4,r16,17068
8110a9ac:	8110aab4 	orhi	r4,r16,17066
8110a9b0:	8110ab08 	cmpgei	r4,r16,17068
8110a9b4:	8110ab08 	cmpgei	r4,r16,17068
8110a9b8:	8110ab08 	cmpgei	r4,r16,17068
8110a9bc:	8110ab08 	cmpgei	r4,r16,17068
8110a9c0:	8110ab08 	cmpgei	r4,r16,17068
8110a9c4:	8110ab08 	cmpgei	r4,r16,17068
8110a9c8:	8110ab08 	cmpgei	r4,r16,17068
8110a9cc:	8110ab08 	cmpgei	r4,r16,17068
8110a9d0:	8110ab08 	cmpgei	r4,r16,17068
8110a9d4:	8110ab08 	cmpgei	r4,r16,17068
8110a9d8:	8110ab08 	cmpgei	r4,r16,17068
8110a9dc:	8110aac0 	call	88110aac <__reset+0x20f0aac>
8110a9e0:	8110ab08 	cmpgei	r4,r16,17068
8110a9e4:	8110ab08 	cmpgei	r4,r16,17068
8110a9e8:	8110ab08 	cmpgei	r4,r16,17068
8110a9ec:	8110aacc 	andi	r4,r16,17067
8110a9f0:	8110ab08 	cmpgei	r4,r16,17068
8110a9f4:	8110ab08 	cmpgei	r4,r16,17068
8110a9f8:	8110ab08 	cmpgei	r4,r16,17068
8110a9fc:	8110aad8 	cmpnei	r4,r16,17067
8110aa00:	8110ab08 	cmpgei	r4,r16,17068
8110aa04:	8110ab08 	cmpgei	r4,r16,17068
8110aa08:	8110ab08 	cmpgei	r4,r16,17068
8110aa0c:	8110aae4 	muli	r4,r16,17067
8110aa10:	8110ab08 	cmpgei	r4,r16,17068
8110aa14:	8110ab08 	cmpgei	r4,r16,17068
8110aa18:	8110ab08 	cmpgei	r4,r16,17068
8110aa1c:	8110aaf0 	cmpltui	r4,r16,17067
8110aa20:	8110ab08 	cmpgei	r4,r16,17068
8110aa24:	8110ab08 	cmpgei	r4,r16,17068
8110aa28:	8110ab08 	cmpgei	r4,r16,17068
8110aa2c:	8110aafc 	xorhi	r4,r16,17067
	case 0x00000000:
		uliValue = 0x00000040;
8110aa30:	00801004 	movi	r2,64
8110aa34:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa38:	00003506 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110aa3c:	00801044 	movi	r2,65
8110aa40:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa44:	00003206 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8110aa48:	00801084 	movi	r2,66
8110aa4c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa50:	00002f06 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110aa54:	008010c4 	movi	r2,67
8110aa58:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa5c:	00002c06 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110aa60:	00801104 	movi	r2,68
8110aa64:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa68:	00002906 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110aa6c:	00801144 	movi	r2,69
8110aa70:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa74:	00002606 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110aa78:	00801184 	movi	r2,70
8110aa7c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa80:	00002306 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110aa84:	008011c4 	movi	r2,71
8110aa88:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa8c:	00002006 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110aa90:	00801204 	movi	r2,72
8110aa94:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aa98:	00001d06 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110aa9c:	00801244 	movi	r2,73
8110aaa0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aaa4:	00001a06 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110aaa8:	00801284 	movi	r2,74
8110aaac:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aab0:	00001706 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110aab4:	008012c4 	movi	r2,75
8110aab8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aabc:	00001406 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110aac0:	00801304 	movi	r2,76
8110aac4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aac8:	00001106 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110aacc:	00801344 	movi	r2,77
8110aad0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aad4:	00000e06 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110aad8:	00801384 	movi	r2,78
8110aadc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aae0:	00000b06 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110aae4:	008013c4 	movi	r2,79
8110aae8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aaec:	00000806 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110aaf0:	00801404 	movi	r2,80
8110aaf4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110aaf8:	00000506 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110aafc:	00801444 	movi	r2,81
8110ab00:	e0bffe15 	stw	r2,-8(fp)
		break;
8110ab04:	00000206 	br	8110ab10 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110ab08:	e03ffe15 	stw	zero,-8(fp)
		break;
8110ab0c:	0001883a 	nop
	}

	return uliValue;
8110ab10:	e0bffe17 	ldw	r2,-8(fp)
}
8110ab14:	e037883a 	mov	sp,fp
8110ab18:	df000017 	ldw	fp,0(sp)
8110ab1c:	dec00104 	addi	sp,sp,4
8110ab20:	f800283a 	ret

8110ab24 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110ab24:	defffb04 	addi	sp,sp,-20
8110ab28:	de00012e 	bgeu	sp,et,8110ab30 <bSpwcSetLink+0xc>
8110ab2c:	003b68fa 	trap	3
8110ab30:	dfc00415 	stw	ra,16(sp)
8110ab34:	df000315 	stw	fp,12(sp)
8110ab38:	df000304 	addi	fp,sp,12
8110ab3c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110ab40:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110ab44:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110ab48:	e0bfff17 	ldw	r2,-4(fp)
8110ab4c:	10003d26 	beq	r2,zero,8110ac44 <bSpwcSetLink+0x120>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110ab50:	e0bfff17 	ldw	r2,-4(fp)
8110ab54:	10800017 	ldw	r2,0(r2)
8110ab58:	000b883a 	mov	r5,zero
8110ab5c:	1009883a 	mov	r4,r2
8110ab60:	110b2580 	call	8110b258 <uliSpwcReadReg>
8110ab64:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110ab68:	e0bfff17 	ldw	r2,-4(fp)
8110ab6c:	10800117 	ldw	r2,4(r2)
8110ab70:	10000426 	beq	r2,zero,8110ab84 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110ab74:	e0bffe17 	ldw	r2,-8(fp)
8110ab78:	10800114 	ori	r2,r2,4
8110ab7c:	e0bffe15 	stw	r2,-8(fp)
8110ab80:	00000406 	br	8110ab94 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110ab84:	e0fffe17 	ldw	r3,-8(fp)
8110ab88:	00bffec4 	movi	r2,-5
8110ab8c:	1884703a 	and	r2,r3,r2
8110ab90:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110ab94:	e0bfff17 	ldw	r2,-4(fp)
8110ab98:	10800217 	ldw	r2,8(r2)
8110ab9c:	10000426 	beq	r2,zero,8110abb0 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110aba0:	e0bffe17 	ldw	r2,-8(fp)
8110aba4:	10800094 	ori	r2,r2,2
8110aba8:	e0bffe15 	stw	r2,-8(fp)
8110abac:	00000406 	br	8110abc0 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110abb0:	e0fffe17 	ldw	r3,-8(fp)
8110abb4:	00bfff44 	movi	r2,-3
8110abb8:	1884703a 	and	r2,r3,r2
8110abbc:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110abc0:	e0bfff17 	ldw	r2,-4(fp)
8110abc4:	10800317 	ldw	r2,12(r2)
8110abc8:	10000426 	beq	r2,zero,8110abdc <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110abcc:	e0bffe17 	ldw	r2,-8(fp)
8110abd0:	10800054 	ori	r2,r2,1
8110abd4:	e0bffe15 	stw	r2,-8(fp)
8110abd8:	00000406 	br	8110abec <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110abdc:	e0fffe17 	ldw	r3,-8(fp)
8110abe0:	00bfff84 	movi	r2,-2
8110abe4:	1884703a 	and	r2,r3,r2
8110abe8:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110abec:	e0fffe17 	ldw	r3,-8(fp)
8110abf0:	00804034 	movhi	r2,256
8110abf4:	10bfffc4 	addi	r2,r2,-1
8110abf8:	1884703a 	and	r2,r3,r2
8110abfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110ac00:	e0bfff17 	ldw	r2,-4(fp)
8110ac04:	10800403 	ldbu	r2,16(r2)
8110ac08:	10803fcc 	andi	r2,r2,255
8110ac0c:	1004963a 	slli	r2,r2,24
8110ac10:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110ac14:	e0bffe17 	ldw	r2,-8(fp)
8110ac18:	1884b03a 	or	r2,r3,r2
8110ac1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110ac20:	e0bfff17 	ldw	r2,-4(fp)
8110ac24:	10800017 	ldw	r2,0(r2)
8110ac28:	e0fffe17 	ldw	r3,-8(fp)
8110ac2c:	180d883a 	mov	r6,r3
8110ac30:	000b883a 	mov	r5,zero
8110ac34:	1009883a 	mov	r4,r2
8110ac38:	110b2040 	call	8110b204 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110ac3c:	00800044 	movi	r2,1
8110ac40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110ac44:	e0bffd17 	ldw	r2,-12(fp)
}
8110ac48:	e037883a 	mov	sp,fp
8110ac4c:	dfc00117 	ldw	ra,4(sp)
8110ac50:	df000017 	ldw	fp,0(sp)
8110ac54:	dec00204 	addi	sp,sp,8
8110ac58:	f800283a 	ret

8110ac5c <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110ac5c:	defffb04 	addi	sp,sp,-20
8110ac60:	de00012e 	bgeu	sp,et,8110ac68 <bSpwcGetLink+0xc>
8110ac64:	003b68fa 	trap	3
8110ac68:	dfc00415 	stw	ra,16(sp)
8110ac6c:	df000315 	stw	fp,12(sp)
8110ac70:	df000304 	addi	fp,sp,12
8110ac74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110ac78:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110ac7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110ac80:	e0bfff17 	ldw	r2,-4(fp)
8110ac84:	10002826 	beq	r2,zero,8110ad28 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110ac88:	e0bfff17 	ldw	r2,-4(fp)
8110ac8c:	10800017 	ldw	r2,0(r2)
8110ac90:	000b883a 	mov	r5,zero
8110ac94:	1009883a 	mov	r4,r2
8110ac98:	110b2580 	call	8110b258 <uliSpwcReadReg>
8110ac9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110aca0:	e0bffe17 	ldw	r2,-8(fp)
8110aca4:	1080010c 	andi	r2,r2,4
8110aca8:	10000426 	beq	r2,zero,8110acbc <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110acac:	e0bfff17 	ldw	r2,-4(fp)
8110acb0:	00c00044 	movi	r3,1
8110acb4:	10c00115 	stw	r3,4(r2)
8110acb8:	00000206 	br	8110acc4 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110acbc:	e0bfff17 	ldw	r2,-4(fp)
8110acc0:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110acc4:	e0bffe17 	ldw	r2,-8(fp)
8110acc8:	1080008c 	andi	r2,r2,2
8110accc:	10000426 	beq	r2,zero,8110ace0 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110acd0:	e0bfff17 	ldw	r2,-4(fp)
8110acd4:	00c00044 	movi	r3,1
8110acd8:	10c00215 	stw	r3,8(r2)
8110acdc:	00000206 	br	8110ace8 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110ace0:	e0bfff17 	ldw	r2,-4(fp)
8110ace4:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110ace8:	e0bffe17 	ldw	r2,-8(fp)
8110acec:	1080004c 	andi	r2,r2,1
8110acf0:	10000426 	beq	r2,zero,8110ad04 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110acf4:	e0bfff17 	ldw	r2,-4(fp)
8110acf8:	00c00044 	movi	r3,1
8110acfc:	10c00315 	stw	r3,12(r2)
8110ad00:	00000206 	br	8110ad0c <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110ad04:	e0bfff17 	ldw	r2,-4(fp)
8110ad08:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110ad0c:	e0bffe17 	ldw	r2,-8(fp)
8110ad10:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110ad14:	1007883a 	mov	r3,r2
8110ad18:	e0bfff17 	ldw	r2,-4(fp)
8110ad1c:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110ad20:	00800044 	movi	r2,1
8110ad24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110ad28:	e0bffd17 	ldw	r2,-12(fp)
}
8110ad2c:	e037883a 	mov	sp,fp
8110ad30:	dfc00117 	ldw	ra,4(sp)
8110ad34:	df000017 	ldw	fp,0(sp)
8110ad38:	dec00204 	addi	sp,sp,8
8110ad3c:	f800283a 	ret

8110ad40 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110ad40:	defffb04 	addi	sp,sp,-20
8110ad44:	de00012e 	bgeu	sp,et,8110ad4c <bSpwcGetLinkError+0xc>
8110ad48:	003b68fa 	trap	3
8110ad4c:	dfc00415 	stw	ra,16(sp)
8110ad50:	df000315 	stw	fp,12(sp)
8110ad54:	df000304 	addi	fp,sp,12
8110ad58:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110ad5c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110ad60:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110ad64:	e0bfff17 	ldw	r2,-4(fp)
8110ad68:	10002c26 	beq	r2,zero,8110ae1c <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110ad6c:	e0bfff17 	ldw	r2,-4(fp)
8110ad70:	10800017 	ldw	r2,0(r2)
8110ad74:	000b883a 	mov	r5,zero
8110ad78:	1009883a 	mov	r4,r2
8110ad7c:	110b2580 	call	8110b258 <uliSpwcReadReg>
8110ad80:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110ad84:	e0bffe17 	ldw	r2,-8(fp)
8110ad88:	1080006c 	andhi	r2,r2,1
8110ad8c:	10000426 	beq	r2,zero,8110ada0 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110ad90:	e0bfff17 	ldw	r2,-4(fp)
8110ad94:	00c00044 	movi	r3,1
8110ad98:	10c00515 	stw	r3,20(r2)
8110ad9c:	00000206 	br	8110ada8 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110ada0:	e0bfff17 	ldw	r2,-4(fp)
8110ada4:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110ada8:	e0bffe17 	ldw	r2,-8(fp)
8110adac:	108000ac 	andhi	r2,r2,2
8110adb0:	10000426 	beq	r2,zero,8110adc4 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110adb4:	e0bfff17 	ldw	r2,-4(fp)
8110adb8:	00c00044 	movi	r3,1
8110adbc:	10c00615 	stw	r3,24(r2)
8110adc0:	00000206 	br	8110adcc <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110adc4:	e0bfff17 	ldw	r2,-4(fp)
8110adc8:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110adcc:	e0bffe17 	ldw	r2,-8(fp)
8110add0:	1080012c 	andhi	r2,r2,4
8110add4:	10000426 	beq	r2,zero,8110ade8 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110add8:	e0bfff17 	ldw	r2,-4(fp)
8110addc:	00c00044 	movi	r3,1
8110ade0:	10c00715 	stw	r3,28(r2)
8110ade4:	00000206 	br	8110adf0 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110ade8:	e0bfff17 	ldw	r2,-4(fp)
8110adec:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110adf0:	e0bffe17 	ldw	r2,-8(fp)
8110adf4:	1080022c 	andhi	r2,r2,8
8110adf8:	10000426 	beq	r2,zero,8110ae0c <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110adfc:	e0bfff17 	ldw	r2,-4(fp)
8110ae00:	00c00044 	movi	r3,1
8110ae04:	10c00815 	stw	r3,32(r2)
8110ae08:	00000206 	br	8110ae14 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110ae0c:	e0bfff17 	ldw	r2,-4(fp)
8110ae10:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110ae14:	00800044 	movi	r2,1
8110ae18:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110ae1c:	e0bffd17 	ldw	r2,-12(fp)
}
8110ae20:	e037883a 	mov	sp,fp
8110ae24:	dfc00117 	ldw	ra,4(sp)
8110ae28:	df000017 	ldw	fp,0(sp)
8110ae2c:	dec00204 	addi	sp,sp,8
8110ae30:	f800283a 	ret

8110ae34 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110ae34:	defffb04 	addi	sp,sp,-20
8110ae38:	de00012e 	bgeu	sp,et,8110ae40 <bSpwcGetLinkStatus+0xc>
8110ae3c:	003b68fa 	trap	3
8110ae40:	dfc00415 	stw	ra,16(sp)
8110ae44:	df000315 	stw	fp,12(sp)
8110ae48:	df000304 	addi	fp,sp,12
8110ae4c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110ae50:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110ae54:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110ae58:	e0bfff17 	ldw	r2,-4(fp)
8110ae5c:	10002326 	beq	r2,zero,8110aeec <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110ae60:	e0bfff17 	ldw	r2,-4(fp)
8110ae64:	10800017 	ldw	r2,0(r2)
8110ae68:	000b883a 	mov	r5,zero
8110ae6c:	1009883a 	mov	r4,r2
8110ae70:	110b2580 	call	8110b258 <uliSpwcReadReg>
8110ae74:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110ae78:	e0bffe17 	ldw	r2,-8(fp)
8110ae7c:	1081000c 	andi	r2,r2,1024
8110ae80:	10000426 	beq	r2,zero,8110ae94 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110ae84:	e0bfff17 	ldw	r2,-4(fp)
8110ae88:	00c00044 	movi	r3,1
8110ae8c:	10c00915 	stw	r3,36(r2)
8110ae90:	00000206 	br	8110ae9c <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110ae94:	e0bfff17 	ldw	r2,-4(fp)
8110ae98:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110ae9c:	e0bffe17 	ldw	r2,-8(fp)
8110aea0:	1080800c 	andi	r2,r2,512
8110aea4:	10000426 	beq	r2,zero,8110aeb8 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110aea8:	e0bfff17 	ldw	r2,-4(fp)
8110aeac:	00c00044 	movi	r3,1
8110aeb0:	10c00a15 	stw	r3,40(r2)
8110aeb4:	00000206 	br	8110aec0 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110aeb8:	e0bfff17 	ldw	r2,-4(fp)
8110aebc:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110aec0:	e0bffe17 	ldw	r2,-8(fp)
8110aec4:	1080400c 	andi	r2,r2,256
8110aec8:	10000426 	beq	r2,zero,8110aedc <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110aecc:	e0bfff17 	ldw	r2,-4(fp)
8110aed0:	00c00044 	movi	r3,1
8110aed4:	10c00b15 	stw	r3,44(r2)
8110aed8:	00000206 	br	8110aee4 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110aedc:	e0bfff17 	ldw	r2,-4(fp)
8110aee0:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110aee4:	00800044 	movi	r2,1
8110aee8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110aeec:	e0bffd17 	ldw	r2,-12(fp)
}
8110aef0:	e037883a 	mov	sp,fp
8110aef4:	dfc00117 	ldw	ra,4(sp)
8110aef8:	df000017 	ldw	fp,0(sp)
8110aefc:	dec00204 	addi	sp,sp,8
8110af00:	f800283a 	ret

8110af04 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110af04:	defffb04 	addi	sp,sp,-20
8110af08:	de00012e 	bgeu	sp,et,8110af10 <bSpwcGetTimecode+0xc>
8110af0c:	003b68fa 	trap	3
8110af10:	dfc00415 	stw	ra,16(sp)
8110af14:	df000315 	stw	fp,12(sp)
8110af18:	df000304 	addi	fp,sp,12
8110af1c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110af20:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110af24:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110af28:	e0bfff17 	ldw	r2,-4(fp)
8110af2c:	10001326 	beq	r2,zero,8110af7c <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110af30:	e0bfff17 	ldw	r2,-4(fp)
8110af34:	10800017 	ldw	r2,0(r2)
8110af38:	01400044 	movi	r5,1
8110af3c:	1009883a 	mov	r4,r2
8110af40:	110b2580 	call	8110b258 <uliSpwcReadReg>
8110af44:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110af48:	e0bffe17 	ldw	r2,-8(fp)
8110af4c:	1080300c 	andi	r2,r2,192
8110af50:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110af54:	1007883a 	mov	r3,r2
8110af58:	e0bfff17 	ldw	r2,-4(fp)
8110af5c:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110af60:	e0bffe17 	ldw	r2,-8(fp)
8110af64:	10800fcc 	andi	r2,r2,63
8110af68:	1007883a 	mov	r3,r2
8110af6c:	e0bfff17 	ldw	r2,-4(fp)
8110af70:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110af74:	00800044 	movi	r2,1
8110af78:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110af7c:	e0bffd17 	ldw	r2,-12(fp)
}
8110af80:	e037883a 	mov	sp,fp
8110af84:	dfc00117 	ldw	ra,4(sp)
8110af88:	df000017 	ldw	fp,0(sp)
8110af8c:	dec00204 	addi	sp,sp,8
8110af90:	f800283a 	ret

8110af94 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110af94:	defffb04 	addi	sp,sp,-20
8110af98:	de00012e 	bgeu	sp,et,8110afa0 <bSpwcClearTimecode+0xc>
8110af9c:	003b68fa 	trap	3
8110afa0:	dfc00415 	stw	ra,16(sp)
8110afa4:	df000315 	stw	fp,12(sp)
8110afa8:	df000304 	addi	fp,sp,12
8110afac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110afb0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110afb4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110afb8:	e0bfff17 	ldw	r2,-4(fp)
8110afbc:	10001226 	beq	r2,zero,8110b008 <bSpwcClearTimecode+0x74>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110afc0:	e0bfff17 	ldw	r2,-4(fp)
8110afc4:	10800017 	ldw	r2,0(r2)
8110afc8:	01400044 	movi	r5,1
8110afcc:	1009883a 	mov	r4,r2
8110afd0:	110b2580 	call	8110b258 <uliSpwcReadReg>
8110afd4:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110afd8:	e0bffe17 	ldw	r2,-8(fp)
8110afdc:	10804014 	ori	r2,r2,256
8110afe0:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110afe4:	e0bfff17 	ldw	r2,-4(fp)
8110afe8:	10800017 	ldw	r2,0(r2)
8110afec:	e0fffe17 	ldw	r3,-8(fp)
8110aff0:	180d883a 	mov	r6,r3
8110aff4:	01400044 	movi	r5,1
8110aff8:	1009883a 	mov	r4,r2
8110affc:	110b2040 	call	8110b204 <vSpwcWriteReg>
		bStatus = TRUE;
8110b000:	00800044 	movi	r2,1
8110b004:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110b008:	e0bffd17 	ldw	r2,-12(fp)
}
8110b00c:	e037883a 	mov	sp,fp
8110b010:	dfc00117 	ldw	ra,4(sp)
8110b014:	df000017 	ldw	fp,0(sp)
8110b018:	dec00204 	addi	sp,sp,8
8110b01c:	f800283a 	ret

8110b020 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110b020:	defff904 	addi	sp,sp,-28
8110b024:	de00012e 	bgeu	sp,et,8110b02c <bSpwcInitCh+0xc>
8110b028:	003b68fa 	trap	3
8110b02c:	dfc00615 	stw	ra,24(sp)
8110b030:	df000515 	stw	fp,20(sp)
8110b034:	df000504 	addi	fp,sp,20
8110b038:	e13ffe15 	stw	r4,-8(fp)
8110b03c:	2805883a 	mov	r2,r5
8110b040:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110b044:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8110b048:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8110b04c:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110b050:	e0bffe17 	ldw	r2,-8(fp)
8110b054:	10006526 	beq	r2,zero,8110b1ec <bSpwcInitCh+0x1cc>

		switch (ucCommCh) {
8110b058:	e0bfff03 	ldbu	r2,-4(fp)
8110b05c:	10c00228 	cmpgeui	r3,r2,8
8110b060:	1800461e 	bne	r3,zero,8110b17c <bSpwcInitCh+0x15c>
8110b064:	100690ba 	slli	r3,r2,2
8110b068:	00a04474 	movhi	r2,33041
8110b06c:	10ac1f04 	addi	r2,r2,-20356
8110b070:	1885883a 	add	r2,r3,r2
8110b074:	10800017 	ldw	r2,0(r2)
8110b078:	1000683a 	jmp	r2
8110b07c:	8110b09c 	xori	r4,r16,17090
8110b080:	8110b0b8 	rdprs	r4,r16,17090
8110b084:	8110b0d4 	ori	r4,r16,17091
8110b088:	8110b0f0 	cmpltui	r4,r16,17091
8110b08c:	8110b10c 	andi	r4,r16,17092
8110b090:	8110b128 	cmpgeui	r4,r16,17092
8110b094:	8110b144 	addi	r4,r16,17093
8110b098:	8110b160 	cmpeqi	r4,r16,17093
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110b09c:	e0fffe17 	ldw	r3,-8(fp)
8110b0a0:	00a04834 	movhi	r2,33056
8110b0a4:	108b0004 	addi	r2,r2,11264
8110b0a8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b0ac:	00800044 	movi	r2,1
8110b0b0:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b0b4:	00003306 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110b0b8:	e0fffe17 	ldw	r3,-8(fp)
8110b0bc:	00a04834 	movhi	r2,33056
8110b0c0:	108a0004 	addi	r2,r2,10240
8110b0c4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b0c8:	00800044 	movi	r2,1
8110b0cc:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b0d0:	00002c06 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110b0d4:	e0fffe17 	ldw	r3,-8(fp)
8110b0d8:	00a04834 	movhi	r2,33056
8110b0dc:	108b0004 	addi	r2,r2,11264
8110b0e0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b0e4:	00800044 	movi	r2,1
8110b0e8:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b0ec:	00002506 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110b0f0:	e0fffe17 	ldw	r3,-8(fp)
8110b0f4:	00a04834 	movhi	r2,33056
8110b0f8:	108a0004 	addi	r2,r2,10240
8110b0fc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b100:	00800044 	movi	r2,1
8110b104:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b108:	00001e06 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110b10c:	e0fffe17 	ldw	r3,-8(fp)
8110b110:	00a04834 	movhi	r2,33056
8110b114:	108b0004 	addi	r2,r2,11264
8110b118:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b11c:	00800044 	movi	r2,1
8110b120:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b124:	00001706 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110b128:	e0fffe17 	ldw	r3,-8(fp)
8110b12c:	00a04834 	movhi	r2,33056
8110b130:	108a0004 	addi	r2,r2,10240
8110b134:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b138:	00800044 	movi	r2,1
8110b13c:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b140:	00001006 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110b144:	e0fffe17 	ldw	r3,-8(fp)
8110b148:	00a04834 	movhi	r2,33056
8110b14c:	108b0004 	addi	r2,r2,11264
8110b150:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b154:	00800044 	movi	r2,1
8110b158:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b15c:	00000906 	br	8110b184 <bSpwcInitCh+0x164>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110b160:	e0fffe17 	ldw	r3,-8(fp)
8110b164:	00a04834 	movhi	r2,33056
8110b168:	108a0004 	addi	r2,r2,10240
8110b16c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110b170:	00800044 	movi	r2,1
8110b174:	e0bffc15 	stw	r2,-16(fp)
			break;
8110b178:	00000206 	br	8110b184 <bSpwcInitCh+0x164>
		default:
			bValidCh = FALSE;
8110b17c:	e03ffc15 	stw	zero,-16(fp)
			break;
8110b180:	0001883a 	nop
		}

		if (bValidCh) {
8110b184:	e0bffc17 	ldw	r2,-16(fp)
8110b188:	10001826 	beq	r2,zero,8110b1ec <bSpwcInitCh+0x1cc>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110b18c:	e13ffe17 	ldw	r4,-8(fp)
8110b190:	110ac5c0 	call	8110ac5c <bSpwcGetLink>
8110b194:	1000021e 	bne	r2,zero,8110b1a0 <bSpwcInitCh+0x180>
				bInitFail = TRUE;
8110b198:	00800044 	movi	r2,1
8110b19c:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110b1a0:	e13ffe17 	ldw	r4,-8(fp)
8110b1a4:	110ad400 	call	8110ad40 <bSpwcGetLinkError>
8110b1a8:	1000021e 	bne	r2,zero,8110b1b4 <bSpwcInitCh+0x194>
				bInitFail = TRUE;
8110b1ac:	00800044 	movi	r2,1
8110b1b0:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110b1b4:	e13ffe17 	ldw	r4,-8(fp)
8110b1b8:	110ae340 	call	8110ae34 <bSpwcGetLinkStatus>
8110b1bc:	1000021e 	bne	r2,zero,8110b1c8 <bSpwcInitCh+0x1a8>
				bInitFail = TRUE;
8110b1c0:	00800044 	movi	r2,1
8110b1c4:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110b1c8:	e13ffe17 	ldw	r4,-8(fp)
8110b1cc:	110af040 	call	8110af04 <bSpwcGetTimecode>
8110b1d0:	1000021e 	bne	r2,zero,8110b1dc <bSpwcInitCh+0x1bc>
				bInitFail = TRUE;
8110b1d4:	00800044 	movi	r2,1
8110b1d8:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8110b1dc:	e0bffd17 	ldw	r2,-12(fp)
8110b1e0:	1000021e 	bne	r2,zero,8110b1ec <bSpwcInitCh+0x1cc>
				bStatus = TRUE;
8110b1e4:	00800044 	movi	r2,1
8110b1e8:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8110b1ec:	e0bffb17 	ldw	r2,-20(fp)
}
8110b1f0:	e037883a 	mov	sp,fp
8110b1f4:	dfc00117 	ldw	ra,4(sp)
8110b1f8:	df000017 	ldw	fp,0(sp)
8110b1fc:	dec00204 	addi	sp,sp,8
8110b200:	f800283a 	ret

8110b204 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110b204:	defffc04 	addi	sp,sp,-16
8110b208:	de00012e 	bgeu	sp,et,8110b210 <vSpwcWriteReg+0xc>
8110b20c:	003b68fa 	trap	3
8110b210:	df000315 	stw	fp,12(sp)
8110b214:	df000304 	addi	fp,sp,12
8110b218:	e13ffd15 	stw	r4,-12(fp)
8110b21c:	e17ffe15 	stw	r5,-8(fp)
8110b220:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110b224:	e0bffe17 	ldw	r2,-8(fp)
8110b228:	1085883a 	add	r2,r2,r2
8110b22c:	1085883a 	add	r2,r2,r2
8110b230:	1007883a 	mov	r3,r2
8110b234:	e0bffd17 	ldw	r2,-12(fp)
8110b238:	10c5883a 	add	r2,r2,r3
8110b23c:	e0ffff17 	ldw	r3,-4(fp)
8110b240:	10c00015 	stw	r3,0(r2)
}
8110b244:	0001883a 	nop
8110b248:	e037883a 	mov	sp,fp
8110b24c:	df000017 	ldw	fp,0(sp)
8110b250:	dec00104 	addi	sp,sp,4
8110b254:	f800283a 	ret

8110b258 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110b258:	defffc04 	addi	sp,sp,-16
8110b25c:	de00012e 	bgeu	sp,et,8110b264 <uliSpwcReadReg+0xc>
8110b260:	003b68fa 	trap	3
8110b264:	df000315 	stw	fp,12(sp)
8110b268:	df000304 	addi	fp,sp,12
8110b26c:	e13ffe15 	stw	r4,-8(fp)
8110b270:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110b274:	e0bfff17 	ldw	r2,-4(fp)
8110b278:	1085883a 	add	r2,r2,r2
8110b27c:	1085883a 	add	r2,r2,r2
8110b280:	1007883a 	mov	r3,r2
8110b284:	e0bffe17 	ldw	r2,-8(fp)
8110b288:	10c5883a 	add	r2,r2,r3
8110b28c:	10800017 	ldw	r2,0(r2)
8110b290:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110b294:	e0bffd17 	ldw	r2,-12(fp)
}
8110b298:	e037883a 	mov	sp,fp
8110b29c:	df000017 	ldw	fp,0(sp)
8110b2a0:	dec00104 	addi	sp,sp,4
8110b2a4:	f800283a 	ret

8110b2a8 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110b2a8:	defffe04 	addi	sp,sp,-8
8110b2ac:	de00012e 	bgeu	sp,et,8110b2b4 <bEnableIsoDrivers+0xc>
8110b2b0:	003b68fa 	trap	3
8110b2b4:	dfc00115 	stw	ra,4(sp)
8110b2b8:	df000015 	stw	fp,0(sp)
8110b2bc:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110b2c0:	01400204 	movi	r5,8
8110b2c4:	01000044 	movi	r4,1
8110b2c8:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
  return  TRUE;
8110b2cc:	00800044 	movi	r2,1
}
8110b2d0:	e037883a 	mov	sp,fp
8110b2d4:	dfc00117 	ldw	ra,4(sp)
8110b2d8:	df000017 	ldw	fp,0(sp)
8110b2dc:	dec00204 	addi	sp,sp,8
8110b2e0:	f800283a 	ret

8110b2e4 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110b2e4:	defffe04 	addi	sp,sp,-8
8110b2e8:	de00012e 	bgeu	sp,et,8110b2f0 <bDisableIsoDrivers+0xc>
8110b2ec:	003b68fa 	trap	3
8110b2f0:	dfc00115 	stw	ra,4(sp)
8110b2f4:	df000015 	stw	fp,0(sp)
8110b2f8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110b2fc:	01400204 	movi	r5,8
8110b300:	0009883a 	mov	r4,zero
8110b304:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
  return  TRUE;
8110b308:	00800044 	movi	r2,1
}
8110b30c:	e037883a 	mov	sp,fp
8110b310:	dfc00117 	ldw	ra,4(sp)
8110b314:	df000017 	ldw	fp,0(sp)
8110b318:	dec00204 	addi	sp,sp,8
8110b31c:	f800283a 	ret

8110b320 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110b320:	defffe04 	addi	sp,sp,-8
8110b324:	de00012e 	bgeu	sp,et,8110b32c <bEnableLvdsBoard+0xc>
8110b328:	003b68fa 	trap	3
8110b32c:	dfc00115 	stw	ra,4(sp)
8110b330:	df000015 	stw	fp,0(sp)
8110b334:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110b338:	01400104 	movi	r5,4
8110b33c:	01000044 	movi	r4,1
8110b340:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
  return  TRUE;
8110b344:	00800044 	movi	r2,1
}
8110b348:	e037883a 	mov	sp,fp
8110b34c:	dfc00117 	ldw	ra,4(sp)
8110b350:	df000017 	ldw	fp,0(sp)
8110b354:	dec00204 	addi	sp,sp,8
8110b358:	f800283a 	ret

8110b35c <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110b35c:	defffe04 	addi	sp,sp,-8
8110b360:	de00012e 	bgeu	sp,et,8110b368 <bDisableLvdsBoard+0xc>
8110b364:	003b68fa 	trap	3
8110b368:	dfc00115 	stw	ra,4(sp)
8110b36c:	df000015 	stw	fp,0(sp)
8110b370:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110b374:	01400104 	movi	r5,4
8110b378:	0009883a 	mov	r4,zero
8110b37c:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
  return  TRUE;
8110b380:	00800044 	movi	r2,1
}
8110b384:	e037883a 	mov	sp,fp
8110b388:	dfc00117 	ldw	ra,4(sp)
8110b38c:	df000017 	ldw	fp,0(sp)
8110b390:	dec00204 	addi	sp,sp,8
8110b394:	f800283a 	ret

8110b398 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110b398:	defffd04 	addi	sp,sp,-12
8110b39c:	de00012e 	bgeu	sp,et,8110b3a4 <bSetPreEmphasys+0xc>
8110b3a0:	003b68fa 	trap	3
8110b3a4:	dfc00215 	stw	ra,8(sp)
8110b3a8:	df000115 	stw	fp,4(sp)
8110b3ac:	df000104 	addi	fp,sp,4
8110b3b0:	2005883a 	mov	r2,r4
8110b3b4:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110b3b8:	e0bfff03 	ldbu	r2,-4(fp)
8110b3bc:	10c00060 	cmpeqi	r3,r2,1
8110b3c0:	18000d1e 	bne	r3,zero,8110b3f8 <bSetPreEmphasys+0x60>
8110b3c4:	10c00088 	cmpgei	r3,r2,2
8110b3c8:	1800021e 	bne	r3,zero,8110b3d4 <bSetPreEmphasys+0x3c>
8110b3cc:	10000626 	beq	r2,zero,8110b3e8 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110b3d0:	00001b06 	br	8110b440 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110b3d4:	10c000a0 	cmpeqi	r3,r2,2
8110b3d8:	18000e1e 	bne	r3,zero,8110b414 <bSetPreEmphasys+0x7c>
8110b3dc:	108000e0 	cmpeqi	r2,r2,3
8110b3e0:	1000131e 	bne	r2,zero,8110b430 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110b3e4:	00001606 	br	8110b440 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110b3e8:	014000c4 	movi	r5,3
8110b3ec:	0009883a 	mov	r4,zero
8110b3f0:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
      break;
8110b3f4:	00001206 	br	8110b440 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110b3f8:	01400084 	movi	r5,2
8110b3fc:	0009883a 	mov	r4,zero
8110b400:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110b404:	01400044 	movi	r5,1
8110b408:	01000044 	movi	r4,1
8110b40c:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
      break;
8110b410:	00000b06 	br	8110b440 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110b414:	01400044 	movi	r5,1
8110b418:	0009883a 	mov	r4,zero
8110b41c:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110b420:	01400084 	movi	r5,2
8110b424:	01000044 	movi	r4,1
8110b428:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
      break;
8110b42c:	00000406 	br	8110b440 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110b430:	014000c4 	movi	r5,3
8110b434:	01000044 	movi	r4,1
8110b438:	110b4580 	call	8110b458 <bCtrlIoLvdsDrive>
      break;
8110b43c:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110b440:	00800044 	movi	r2,1
}
8110b444:	e037883a 	mov	sp,fp
8110b448:	dfc00117 	ldw	ra,4(sp)
8110b44c:	df000017 	ldw	fp,0(sp)
8110b450:	dec00204 	addi	sp,sp,8
8110b454:	f800283a 	ret

8110b458 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110b458:	defffd04 	addi	sp,sp,-12
8110b45c:	de00012e 	bgeu	sp,et,8110b464 <bCtrlIoLvdsDrive+0xc>
8110b460:	003b68fa 	trap	3
8110b464:	df000215 	stw	fp,8(sp)
8110b468:	df000204 	addi	fp,sp,8
8110b46c:	e13ffe15 	stw	r4,-8(fp)
8110b470:	2805883a 	mov	r2,r5
8110b474:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110b478:	e0bffe17 	ldw	r2,-8(fp)
8110b47c:	1000071e 	bne	r2,zero,8110b49c <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110b480:	e0bfff03 	ldbu	r2,-4(fp)
8110b484:	0084303a 	nor	r2,zero,r2
8110b488:	1007883a 	mov	r3,r2
8110b48c:	d0a00103 	ldbu	r2,-32764(gp)
8110b490:	1884703a 	and	r2,r3,r2
8110b494:	d0a00105 	stb	r2,-32764(gp)
8110b498:	00000406 	br	8110b4ac <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110b49c:	d0e00103 	ldbu	r3,-32764(gp)
8110b4a0:	e0bfff03 	ldbu	r2,-4(fp)
8110b4a4:	1884b03a 	or	r2,r3,r2
8110b4a8:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110b4ac:	d0a00103 	ldbu	r2,-32764(gp)
8110b4b0:	10c03fcc 	andi	r3,r2,255
8110b4b4:	00a00034 	movhi	r2,32768
8110b4b8:	10822804 	addi	r2,r2,2208
8110b4bc:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110b4c0:	00800044 	movi	r2,1
}
8110b4c4:	e037883a 	mov	sp,fp
8110b4c8:	df000017 	ldw	fp,0(sp)
8110b4cc:	dec00104 	addi	sp,sp,4
8110b4d0:	f800283a 	ret

8110b4d4 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110b4d4:	defffa04 	addi	sp,sp,-24
8110b4d8:	de00012e 	bgeu	sp,et,8110b4e0 <I2C_TestAdress+0xc>
8110b4dc:	003b68fa 	trap	3
8110b4e0:	dfc00515 	stw	ra,20(sp)
8110b4e4:	df000415 	stw	fp,16(sp)
8110b4e8:	df000404 	addi	fp,sp,16
8110b4ec:	e13ffd15 	stw	r4,-12(fp)
8110b4f0:	e17ffe15 	stw	r5,-8(fp)
8110b4f4:	3005883a 	mov	r2,r6
8110b4f8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110b4fc:	00800044 	movi	r2,1
8110b500:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b504:	e17ffe17 	ldw	r5,-8(fp)
8110b508:	e13ffd17 	ldw	r4,-12(fp)
8110b50c:	110b8a40 	call	8110b8a4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b510:	e0bfff03 	ldbu	r2,-4(fp)
8110b514:	10803fcc 	andi	r2,r2,255
8110b518:	100d883a 	mov	r6,r2
8110b51c:	e17ffe17 	ldw	r5,-8(fp)
8110b520:	e13ffd17 	ldw	r4,-12(fp)
8110b524:	110b9b80 	call	8110b9b8 <i2c_write>
8110b528:	1000011e 	bne	r2,zero,8110b530 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110b52c:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110b530:	e17ffe17 	ldw	r5,-8(fp)
8110b534:	e13ffd17 	ldw	r4,-12(fp)
8110b538:	110b9380 	call	8110b938 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110b53c:	0106d604 	movi	r4,7000
8110b540:	1139d080 	call	81139d08 <usleep>
    
    return bSuccess;
8110b544:	e0bffc17 	ldw	r2,-16(fp)

}
8110b548:	e037883a 	mov	sp,fp
8110b54c:	dfc00117 	ldw	ra,4(sp)
8110b550:	df000017 	ldw	fp,0(sp)
8110b554:	dec00204 	addi	sp,sp,8
8110b558:	f800283a 	ret

8110b55c <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110b55c:	defff804 	addi	sp,sp,-32
8110b560:	de00012e 	bgeu	sp,et,8110b568 <I2C_Write+0xc>
8110b564:	003b68fa 	trap	3
8110b568:	dfc00715 	stw	ra,28(sp)
8110b56c:	df000615 	stw	fp,24(sp)
8110b570:	df000604 	addi	fp,sp,24
8110b574:	e13ffb15 	stw	r4,-20(fp)
8110b578:	e17ffc15 	stw	r5,-16(fp)
8110b57c:	3009883a 	mov	r4,r6
8110b580:	3807883a 	mov	r3,r7
8110b584:	e0800217 	ldw	r2,8(fp)
8110b588:	e13ffd05 	stb	r4,-12(fp)
8110b58c:	e0fffe05 	stb	r3,-8(fp)
8110b590:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110b594:	00800044 	movi	r2,1
8110b598:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b59c:	e17ffc17 	ldw	r5,-16(fp)
8110b5a0:	e13ffb17 	ldw	r4,-20(fp)
8110b5a4:	110b8a40 	call	8110b8a4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b5a8:	e0bffd03 	ldbu	r2,-12(fp)
8110b5ac:	10803fcc 	andi	r2,r2,255
8110b5b0:	100d883a 	mov	r6,r2
8110b5b4:	e17ffc17 	ldw	r5,-16(fp)
8110b5b8:	e13ffb17 	ldw	r4,-20(fp)
8110b5bc:	110b9b80 	call	8110b9b8 <i2c_write>
8110b5c0:	1000011e 	bne	r2,zero,8110b5c8 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110b5c4:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110b5c8:	e0bffa17 	ldw	r2,-24(fp)
8110b5cc:	10000726 	beq	r2,zero,8110b5ec <I2C_Write+0x90>
8110b5d0:	e0bffe03 	ldbu	r2,-8(fp)
8110b5d4:	100d883a 	mov	r6,r2
8110b5d8:	e17ffc17 	ldw	r5,-16(fp)
8110b5dc:	e13ffb17 	ldw	r4,-20(fp)
8110b5e0:	110b9b80 	call	8110b9b8 <i2c_write>
8110b5e4:	1000011e 	bne	r2,zero,8110b5ec <I2C_Write+0x90>
        bSuccess = FALSE;
8110b5e8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110b5ec:	e0bffa17 	ldw	r2,-24(fp)
8110b5f0:	10000726 	beq	r2,zero,8110b610 <I2C_Write+0xb4>
8110b5f4:	e0bfff03 	ldbu	r2,-4(fp)
8110b5f8:	100d883a 	mov	r6,r2
8110b5fc:	e17ffc17 	ldw	r5,-16(fp)
8110b600:	e13ffb17 	ldw	r4,-20(fp)
8110b604:	110b9b80 	call	8110b9b8 <i2c_write>
8110b608:	1000011e 	bne	r2,zero,8110b610 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110b60c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110b610:	e17ffc17 	ldw	r5,-16(fp)
8110b614:	e13ffb17 	ldw	r4,-20(fp)
8110b618:	110b9380 	call	8110b938 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110b61c:	0106d604 	movi	r4,7000
8110b620:	1139d080 	call	81139d08 <usleep>
    
    return bSuccess;
8110b624:	e0bffa17 	ldw	r2,-24(fp)

}
8110b628:	e037883a 	mov	sp,fp
8110b62c:	dfc00117 	ldw	ra,4(sp)
8110b630:	df000017 	ldw	fp,0(sp)
8110b634:	dec00204 	addi	sp,sp,8
8110b638:	f800283a 	ret

8110b63c <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110b63c:	defff904 	addi	sp,sp,-28
8110b640:	de00012e 	bgeu	sp,et,8110b648 <I2C_Read+0xc>
8110b644:	003b68fa 	trap	3
8110b648:	dfc00615 	stw	ra,24(sp)
8110b64c:	df000515 	stw	fp,20(sp)
8110b650:	df000504 	addi	fp,sp,20
8110b654:	e13ffc15 	stw	r4,-16(fp)
8110b658:	e17ffd15 	stw	r5,-12(fp)
8110b65c:	3007883a 	mov	r3,r6
8110b660:	3805883a 	mov	r2,r7
8110b664:	e0fffe05 	stb	r3,-8(fp)
8110b668:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110b66c:	00800044 	movi	r2,1
8110b670:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b674:	e17ffd17 	ldw	r5,-12(fp)
8110b678:	e13ffc17 	ldw	r4,-16(fp)
8110b67c:	110b8a40 	call	8110b8a4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b680:	e0bffe03 	ldbu	r2,-8(fp)
8110b684:	10803fcc 	andi	r2,r2,255
8110b688:	100d883a 	mov	r6,r2
8110b68c:	e17ffd17 	ldw	r5,-12(fp)
8110b690:	e13ffc17 	ldw	r4,-16(fp)
8110b694:	110b9b80 	call	8110b9b8 <i2c_write>
8110b698:	1000011e 	bne	r2,zero,8110b6a0 <I2C_Read+0x64>
        bSuccess = FALSE;
8110b69c:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110b6a0:	e0bffb17 	ldw	r2,-20(fp)
8110b6a4:	10000726 	beq	r2,zero,8110b6c4 <I2C_Read+0x88>
8110b6a8:	e0bfff03 	ldbu	r2,-4(fp)
8110b6ac:	100d883a 	mov	r6,r2
8110b6b0:	e17ffd17 	ldw	r5,-12(fp)
8110b6b4:	e13ffc17 	ldw	r4,-16(fp)
8110b6b8:	110b9b80 	call	8110b9b8 <i2c_write>
8110b6bc:	1000011e 	bne	r2,zero,8110b6c4 <I2C_Read+0x88>
        bSuccess = FALSE;
8110b6c0:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110b6c4:	e17ffd17 	ldw	r5,-12(fp)
8110b6c8:	e13ffc17 	ldw	r4,-16(fp)
8110b6cc:	110b8a40 	call	8110b8a4 <i2c_start>
    DeviceAddr |= 1; // Read
8110b6d0:	e0bffe03 	ldbu	r2,-8(fp)
8110b6d4:	10800054 	ori	r2,r2,1
8110b6d8:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110b6dc:	e0bffb17 	ldw	r2,-20(fp)
8110b6e0:	10000826 	beq	r2,zero,8110b704 <I2C_Read+0xc8>
8110b6e4:	e0bffe03 	ldbu	r2,-8(fp)
8110b6e8:	10803fcc 	andi	r2,r2,255
8110b6ec:	100d883a 	mov	r6,r2
8110b6f0:	e17ffd17 	ldw	r5,-12(fp)
8110b6f4:	e13ffc17 	ldw	r4,-16(fp)
8110b6f8:	110b9b80 	call	8110b9b8 <i2c_write>
8110b6fc:	1000011e 	bne	r2,zero,8110b704 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110b700:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110b704:	e0bffb17 	ldw	r2,-20(fp)
8110b708:	10000526 	beq	r2,zero,8110b720 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110b70c:	000f883a 	mov	r7,zero
8110b710:	e1800217 	ldw	r6,8(fp)
8110b714:	e17ffd17 	ldw	r5,-12(fp)
8110b718:	e13ffc17 	ldw	r4,-16(fp)
8110b71c:	110baf00 	call	8110baf0 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110b720:	e17ffd17 	ldw	r5,-12(fp)
8110b724:	e13ffc17 	ldw	r4,-16(fp)
8110b728:	110b9380 	call	8110b938 <i2c_stop>
    
    return bSuccess;
8110b72c:	e0bffb17 	ldw	r2,-20(fp)
}
8110b730:	e037883a 	mov	sp,fp
8110b734:	dfc00117 	ldw	ra,4(sp)
8110b738:	df000017 	ldw	fp,0(sp)
8110b73c:	dec00204 	addi	sp,sp,8
8110b740:	f800283a 	ret

8110b744 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110b744:	defff604 	addi	sp,sp,-40
8110b748:	de00012e 	bgeu	sp,et,8110b750 <I2C_MultipleRead+0xc>
8110b74c:	003b68fa 	trap	3
8110b750:	dfc00915 	stw	ra,36(sp)
8110b754:	df000815 	stw	fp,32(sp)
8110b758:	df000804 	addi	fp,sp,32
8110b75c:	e13ffb15 	stw	r4,-20(fp)
8110b760:	e17ffc15 	stw	r5,-16(fp)
8110b764:	3007883a 	mov	r3,r6
8110b768:	e1fffe15 	stw	r7,-8(fp)
8110b76c:	e0800217 	ldw	r2,8(fp)
8110b770:	e0fffd05 	stb	r3,-12(fp)
8110b774:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110b778:	00800044 	movi	r2,1
8110b77c:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110b780:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b784:	e17ffc17 	ldw	r5,-16(fp)
8110b788:	e13ffb17 	ldw	r4,-20(fp)
8110b78c:	110b8a40 	call	8110b8a4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b790:	e0bffd03 	ldbu	r2,-12(fp)
8110b794:	10803fcc 	andi	r2,r2,255
8110b798:	100d883a 	mov	r6,r2
8110b79c:	e17ffc17 	ldw	r5,-16(fp)
8110b7a0:	e13ffb17 	ldw	r4,-20(fp)
8110b7a4:	110b9b80 	call	8110b9b8 <i2c_write>
8110b7a8:	1000011e 	bne	r2,zero,8110b7b0 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110b7ac:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110b7b0:	e0bff917 	ldw	r2,-28(fp)
8110b7b4:	10000726 	beq	r2,zero,8110b7d4 <I2C_MultipleRead+0x90>
8110b7b8:	e0bffa03 	ldbu	r2,-24(fp)
8110b7bc:	100d883a 	mov	r6,r2
8110b7c0:	e17ffc17 	ldw	r5,-16(fp)
8110b7c4:	e13ffb17 	ldw	r4,-20(fp)
8110b7c8:	110b9b80 	call	8110b9b8 <i2c_write>
8110b7cc:	1000011e 	bne	r2,zero,8110b7d4 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110b7d0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110b7d4:	e0bff917 	ldw	r2,-28(fp)
8110b7d8:	10000326 	beq	r2,zero,8110b7e8 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110b7dc:	e17ffc17 	ldw	r5,-16(fp)
8110b7e0:	e13ffb17 	ldw	r4,-20(fp)
8110b7e4:	110b8a40 	call	8110b8a4 <i2c_start>
    DeviceAddr |= 1; // Read
8110b7e8:	e0bffd03 	ldbu	r2,-12(fp)
8110b7ec:	10800054 	ori	r2,r2,1
8110b7f0:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110b7f4:	e0bff917 	ldw	r2,-28(fp)
8110b7f8:	10000826 	beq	r2,zero,8110b81c <I2C_MultipleRead+0xd8>
8110b7fc:	e0bffd03 	ldbu	r2,-12(fp)
8110b800:	10803fcc 	andi	r2,r2,255
8110b804:	100d883a 	mov	r6,r2
8110b808:	e17ffc17 	ldw	r5,-16(fp)
8110b80c:	e13ffb17 	ldw	r4,-20(fp)
8110b810:	110b9b80 	call	8110b9b8 <i2c_write>
8110b814:	1000011e 	bne	r2,zero,8110b81c <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110b818:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110b81c:	e0bff917 	ldw	r2,-28(fp)
8110b820:	10001726 	beq	r2,zero,8110b880 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110b824:	e03ff815 	stw	zero,-32(fp)
8110b828:	00001006 	br	8110b86c <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110b82c:	e0bff817 	ldw	r2,-32(fp)
8110b830:	e0fffe17 	ldw	r3,-8(fp)
8110b834:	1889883a 	add	r4,r3,r2
8110b838:	e0bfff0b 	ldhu	r2,-4(fp)
8110b83c:	10ffffc4 	addi	r3,r2,-1
8110b840:	e0bff817 	ldw	r2,-32(fp)
8110b844:	1884c03a 	cmpne	r2,r3,r2
8110b848:	10803fcc 	andi	r2,r2,255
8110b84c:	100f883a 	mov	r7,r2
8110b850:	200d883a 	mov	r6,r4
8110b854:	e17ffc17 	ldw	r5,-16(fp)
8110b858:	e13ffb17 	ldw	r4,-20(fp)
8110b85c:	110baf00 	call	8110baf0 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110b860:	e0bff817 	ldw	r2,-32(fp)
8110b864:	10800044 	addi	r2,r2,1
8110b868:	e0bff815 	stw	r2,-32(fp)
8110b86c:	e0bfff0b 	ldhu	r2,-4(fp)
8110b870:	e0fff817 	ldw	r3,-32(fp)
8110b874:	1880020e 	bge	r3,r2,8110b880 <I2C_MultipleRead+0x13c>
8110b878:	e0bff917 	ldw	r2,-28(fp)
8110b87c:	103feb1e 	bne	r2,zero,8110b82c <__reset+0xfb0eb82c>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110b880:	e17ffc17 	ldw	r5,-16(fp)
8110b884:	e13ffb17 	ldw	r4,-20(fp)
8110b888:	110b9380 	call	8110b938 <i2c_stop>
    
    return bSuccess;    
8110b88c:	e0bff917 	ldw	r2,-28(fp)
    
}
8110b890:	e037883a 	mov	sp,fp
8110b894:	dfc00117 	ldw	ra,4(sp)
8110b898:	df000017 	ldw	fp,0(sp)
8110b89c:	dec00204 	addi	sp,sp,8
8110b8a0:	f800283a 	ret

8110b8a4 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110b8a4:	defffc04 	addi	sp,sp,-16
8110b8a8:	de00012e 	bgeu	sp,et,8110b8b0 <i2c_start+0xc>
8110b8ac:	003b68fa 	trap	3
8110b8b0:	dfc00315 	stw	ra,12(sp)
8110b8b4:	df000215 	stw	fp,8(sp)
8110b8b8:	df000204 	addi	fp,sp,8
8110b8bc:	e13ffe15 	stw	r4,-8(fp)
8110b8c0:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110b8c4:	e0bfff17 	ldw	r2,-4(fp)
8110b8c8:	10800104 	addi	r2,r2,4
8110b8cc:	1007883a 	mov	r3,r2
8110b8d0:	00800044 	movi	r2,1
8110b8d4:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110b8d8:	e0bfff17 	ldw	r2,-4(fp)
8110b8dc:	00c00044 	movi	r3,1
8110b8e0:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110b8e4:	e0bffe17 	ldw	r2,-8(fp)
8110b8e8:	00c00044 	movi	r3,1
8110b8ec:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110b8f0:	01000044 	movi	r4,1
8110b8f4:	1139d080 	call	81139d08 <usleep>
     
    SDA_LOW(data_base); // data low
8110b8f8:	e0bfff17 	ldw	r2,-4(fp)
8110b8fc:	0007883a 	mov	r3,zero
8110b900:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110b904:	01000044 	movi	r4,1
8110b908:	1139d080 	call	81139d08 <usleep>
    SCL_LOW(clk_base); // clock low
8110b90c:	e0bffe17 	ldw	r2,-8(fp)
8110b910:	0007883a 	mov	r3,zero
8110b914:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110b918:	01000044 	movi	r4,1
8110b91c:	1139d080 	call	81139d08 <usleep>
}
8110b920:	0001883a 	nop
8110b924:	e037883a 	mov	sp,fp
8110b928:	dfc00117 	ldw	ra,4(sp)
8110b92c:	df000017 	ldw	fp,0(sp)
8110b930:	dec00204 	addi	sp,sp,8
8110b934:	f800283a 	ret

8110b938 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110b938:	defffc04 	addi	sp,sp,-16
8110b93c:	de00012e 	bgeu	sp,et,8110b944 <i2c_stop+0xc>
8110b940:	003b68fa 	trap	3
8110b944:	dfc00315 	stw	ra,12(sp)
8110b948:	df000215 	stw	fp,8(sp)
8110b94c:	df000204 	addi	fp,sp,8
8110b950:	e13ffe15 	stw	r4,-8(fp)
8110b954:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110b958:	e0bfff17 	ldw	r2,-4(fp)
8110b95c:	10800104 	addi	r2,r2,4
8110b960:	1007883a 	mov	r3,r2
8110b964:	00800044 	movi	r2,1
8110b968:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110b96c:	e0bfff17 	ldw	r2,-4(fp)
8110b970:	0007883a 	mov	r3,zero
8110b974:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110b978:	e0bffe17 	ldw	r2,-8(fp)
8110b97c:	00c00044 	movi	r3,1
8110b980:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110b984:	01000044 	movi	r4,1
8110b988:	1139d080 	call	81139d08 <usleep>
    SDA_HIGH(data_base); // data high
8110b98c:	e0bfff17 	ldw	r2,-4(fp)
8110b990:	00c00044 	movi	r3,1
8110b994:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110b998:	01000044 	movi	r4,1
8110b99c:	1139d080 	call	81139d08 <usleep>
    

    
}
8110b9a0:	0001883a 	nop
8110b9a4:	e037883a 	mov	sp,fp
8110b9a8:	dfc00117 	ldw	ra,4(sp)
8110b9ac:	df000017 	ldw	fp,0(sp)
8110b9b0:	dec00204 	addi	sp,sp,8
8110b9b4:	f800283a 	ret

8110b9b8 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110b9b8:	defff804 	addi	sp,sp,-32
8110b9bc:	de00012e 	bgeu	sp,et,8110b9c4 <i2c_write+0xc>
8110b9c0:	003b68fa 	trap	3
8110b9c4:	dfc00715 	stw	ra,28(sp)
8110b9c8:	df000615 	stw	fp,24(sp)
8110b9cc:	df000604 	addi	fp,sp,24
8110b9d0:	e13ffd15 	stw	r4,-12(fp)
8110b9d4:	e17ffe15 	stw	r5,-8(fp)
8110b9d8:	3005883a 	mov	r2,r6
8110b9dc:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110b9e0:	00bfe004 	movi	r2,-128
8110b9e4:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110b9e8:	e0bffe17 	ldw	r2,-8(fp)
8110b9ec:	10800104 	addi	r2,r2,4
8110b9f0:	1007883a 	mov	r3,r2
8110b9f4:	00800044 	movi	r2,1
8110b9f8:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110b9fc:	e03ffb15 	stw	zero,-20(fp)
8110ba00:	00001f06 	br	8110ba80 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110ba04:	e0bffd17 	ldw	r2,-12(fp)
8110ba08:	0007883a 	mov	r3,zero
8110ba0c:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110ba10:	e0ffff03 	ldbu	r3,-4(fp)
8110ba14:	e0bffa03 	ldbu	r2,-24(fp)
8110ba18:	1884703a 	and	r2,r3,r2
8110ba1c:	10803fcc 	andi	r2,r2,255
8110ba20:	10000426 	beq	r2,zero,8110ba34 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110ba24:	e0bffe17 	ldw	r2,-8(fp)
8110ba28:	00c00044 	movi	r3,1
8110ba2c:	10c00035 	stwio	r3,0(r2)
8110ba30:	00000306 	br	8110ba40 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110ba34:	e0bffe17 	ldw	r2,-8(fp)
8110ba38:	0007883a 	mov	r3,zero
8110ba3c:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110ba40:	e0bffa03 	ldbu	r2,-24(fp)
8110ba44:	1004d07a 	srli	r2,r2,1
8110ba48:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110ba4c:	e0bffd17 	ldw	r2,-12(fp)
8110ba50:	00c00044 	movi	r3,1
8110ba54:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110ba58:	01000044 	movi	r4,1
8110ba5c:	1139d080 	call	81139d08 <usleep>
        SCL_LOW(clk_base);
8110ba60:	e0bffd17 	ldw	r2,-12(fp)
8110ba64:	0007883a 	mov	r3,zero
8110ba68:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110ba6c:	01000044 	movi	r4,1
8110ba70:	1139d080 	call	81139d08 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110ba74:	e0bffb17 	ldw	r2,-20(fp)
8110ba78:	10800044 	addi	r2,r2,1
8110ba7c:	e0bffb15 	stw	r2,-20(fp)
8110ba80:	e0bffb17 	ldw	r2,-20(fp)
8110ba84:	10800210 	cmplti	r2,r2,8
8110ba88:	103fde1e 	bne	r2,zero,8110ba04 <__reset+0xfb0eba04>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110ba8c:	e0bffe17 	ldw	r2,-8(fp)
8110ba90:	10800104 	addi	r2,r2,4
8110ba94:	0007883a 	mov	r3,zero
8110ba98:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110ba9c:	e0bffd17 	ldw	r2,-12(fp)
8110baa0:	00c00044 	movi	r3,1
8110baa4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110baa8:	01000044 	movi	r4,1
8110baac:	1139d080 	call	81139d08 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110bab0:	e0bffe17 	ldw	r2,-8(fp)
8110bab4:	10800037 	ldwio	r2,0(r2)
8110bab8:	1005003a 	cmpeq	r2,r2,zero
8110babc:	10803fcc 	andi	r2,r2,255
8110bac0:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110bac4:	e0bffd17 	ldw	r2,-12(fp)
8110bac8:	0007883a 	mov	r3,zero
8110bacc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110bad0:	01000044 	movi	r4,1
8110bad4:	1139d080 	call	81139d08 <usleep>
    return bAck;
8110bad8:	e0bffc17 	ldw	r2,-16(fp)
}    
8110badc:	e037883a 	mov	sp,fp
8110bae0:	dfc00117 	ldw	ra,4(sp)
8110bae4:	df000017 	ldw	fp,0(sp)
8110bae8:	dec00204 	addi	sp,sp,8
8110baec:	f800283a 	ret

8110baf0 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110baf0:	defff804 	addi	sp,sp,-32
8110baf4:	de00012e 	bgeu	sp,et,8110bafc <i2c_read+0xc>
8110baf8:	003b68fa 	trap	3
8110bafc:	dfc00715 	stw	ra,28(sp)
8110bb00:	df000615 	stw	fp,24(sp)
8110bb04:	df000604 	addi	fp,sp,24
8110bb08:	e13ffc15 	stw	r4,-16(fp)
8110bb0c:	e17ffd15 	stw	r5,-12(fp)
8110bb10:	e1bffe15 	stw	r6,-8(fp)
8110bb14:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110bb18:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110bb1c:	e0bffd17 	ldw	r2,-12(fp)
8110bb20:	10800104 	addi	r2,r2,4
8110bb24:	0007883a 	mov	r3,zero
8110bb28:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110bb2c:	e0bffc17 	ldw	r2,-16(fp)
8110bb30:	0007883a 	mov	r3,zero
8110bb34:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110bb38:	01000044 	movi	r4,1
8110bb3c:	1139d080 	call	81139d08 <usleep>

    for(i=0;i<8;i++){
8110bb40:	e03ffb15 	stw	zero,-20(fp)
8110bb44:	00001606 	br	8110bba0 <i2c_read+0xb0>
        Data <<= 1;
8110bb48:	e0bffa03 	ldbu	r2,-24(fp)
8110bb4c:	1085883a 	add	r2,r2,r2
8110bb50:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110bb54:	e0bffc17 	ldw	r2,-16(fp)
8110bb58:	00c00044 	movi	r3,1
8110bb5c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110bb60:	01000044 	movi	r4,1
8110bb64:	1139d080 	call	81139d08 <usleep>
        if (SDA_READ(data_base))  // read data   
8110bb68:	e0bffd17 	ldw	r2,-12(fp)
8110bb6c:	10800037 	ldwio	r2,0(r2)
8110bb70:	10000326 	beq	r2,zero,8110bb80 <i2c_read+0x90>
            Data |= 0x01;
8110bb74:	e0bffa03 	ldbu	r2,-24(fp)
8110bb78:	10800054 	ori	r2,r2,1
8110bb7c:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110bb80:	e0bffc17 	ldw	r2,-16(fp)
8110bb84:	0007883a 	mov	r3,zero
8110bb88:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110bb8c:	01000044 	movi	r4,1
8110bb90:	1139d080 	call	81139d08 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110bb94:	e0bffb17 	ldw	r2,-20(fp)
8110bb98:	10800044 	addi	r2,r2,1
8110bb9c:	e0bffb15 	stw	r2,-20(fp)
8110bba0:	e0bffb17 	ldw	r2,-20(fp)
8110bba4:	10800210 	cmplti	r2,r2,8
8110bba8:	103fe71e 	bne	r2,zero,8110bb48 <__reset+0xfb0ebb48>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110bbac:	e0bffc17 	ldw	r2,-16(fp)
8110bbb0:	0007883a 	mov	r3,zero
8110bbb4:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110bbb8:	e0bffd17 	ldw	r2,-12(fp)
8110bbbc:	10800104 	addi	r2,r2,4
8110bbc0:	1007883a 	mov	r3,r2
8110bbc4:	00800044 	movi	r2,1
8110bbc8:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110bbcc:	e0bfff17 	ldw	r2,-4(fp)
8110bbd0:	10000426 	beq	r2,zero,8110bbe4 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110bbd4:	e0bffd17 	ldw	r2,-12(fp)
8110bbd8:	0007883a 	mov	r3,zero
8110bbdc:	10c00035 	stwio	r3,0(r2)
8110bbe0:	00000306 	br	8110bbf0 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110bbe4:	e0bffd17 	ldw	r2,-12(fp)
8110bbe8:	00c00044 	movi	r3,1
8110bbec:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110bbf0:	e0bffc17 	ldw	r2,-16(fp)
8110bbf4:	00c00044 	movi	r3,1
8110bbf8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110bbfc:	01000044 	movi	r4,1
8110bc00:	1139d080 	call	81139d08 <usleep>
    SCL_LOW(clk_base); // clock low
8110bc04:	e0bffc17 	ldw	r2,-16(fp)
8110bc08:	0007883a 	mov	r3,zero
8110bc0c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110bc10:	01000044 	movi	r4,1
8110bc14:	1139d080 	call	81139d08 <usleep>
    SDA_LOW(data_base);  // data low
8110bc18:	e0bffd17 	ldw	r2,-12(fp)
8110bc1c:	0007883a 	mov	r3,zero
8110bc20:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110bc24:	01000044 	movi	r4,1
8110bc28:	1139d080 	call	81139d08 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110bc2c:	e0bffe17 	ldw	r2,-8(fp)
8110bc30:	e0fffa03 	ldbu	r3,-24(fp)
8110bc34:	10c00005 	stb	r3,0(r2)
}
8110bc38:	0001883a 	nop
8110bc3c:	e037883a 	mov	sp,fp
8110bc40:	dfc00117 	ldw	ra,4(sp)
8110bc44:	df000017 	ldw	fp,0(sp)
8110bc48:	dec00204 	addi	sp,sp,8
8110bc4c:	f800283a 	ret

8110bc50 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110bc50:	defffd04 	addi	sp,sp,-12
8110bc54:	de00012e 	bgeu	sp,et,8110bc5c <bSetBoardLeds+0xc>
8110bc58:	003b68fa 	trap	3
8110bc5c:	df000215 	stw	fp,8(sp)
8110bc60:	df000204 	addi	fp,sp,8
8110bc64:	e13ffe15 	stw	r4,-8(fp)
8110bc68:	2805883a 	mov	r2,r5
8110bc6c:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110bc70:	e0bffe17 	ldw	r2,-8(fp)
8110bc74:	10800058 	cmpnei	r2,r2,1
8110bc78:	1000071e 	bne	r2,zero,8110bc98 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110bc7c:	e0bfff03 	ldbu	r2,-4(fp)
8110bc80:	0084303a 	nor	r2,zero,r2
8110bc84:	1007883a 	mov	r3,r2
8110bc88:	d0a05003 	ldbu	r2,-32448(gp)
8110bc8c:	1884703a 	and	r2,r3,r2
8110bc90:	d0a05005 	stb	r2,-32448(gp)
8110bc94:	00000406 	br	8110bca8 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110bc98:	d0e05003 	ldbu	r3,-32448(gp)
8110bc9c:	e0bfff03 	ldbu	r2,-4(fp)
8110bca0:	1884b03a 	or	r2,r3,r2
8110bca4:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110bca8:	d0a05003 	ldbu	r2,-32448(gp)
8110bcac:	10c03fcc 	andi	r3,r2,255
8110bcb0:	00a00034 	movhi	r2,32768
8110bcb4:	10827404 	addi	r2,r2,2512
8110bcb8:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110bcbc:	00800044 	movi	r2,1
}
8110bcc0:	e037883a 	mov	sp,fp
8110bcc4:	df000017 	ldw	fp,0(sp)
8110bcc8:	dec00104 	addi	sp,sp,4
8110bccc:	f800283a 	ret

8110bcd0 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110bcd0:	defffd04 	addi	sp,sp,-12
8110bcd4:	de00012e 	bgeu	sp,et,8110bcdc <bSetPainelLeds+0xc>
8110bcd8:	003b68fa 	trap	3
8110bcdc:	df000215 	stw	fp,8(sp)
8110bce0:	df000204 	addi	fp,sp,8
8110bce4:	e13ffe15 	stw	r4,-8(fp)
8110bce8:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110bcec:	e0bffe17 	ldw	r2,-8(fp)
8110bcf0:	10800058 	cmpnei	r2,r2,1
8110bcf4:	1000051e 	bne	r2,zero,8110bd0c <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110bcf8:	d0e00217 	ldw	r3,-32760(gp)
8110bcfc:	e0bfff17 	ldw	r2,-4(fp)
8110bd00:	1884b03a 	or	r2,r3,r2
8110bd04:	d0a00215 	stw	r2,-32760(gp)
8110bd08:	00000506 	br	8110bd20 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110bd0c:	e0bfff17 	ldw	r2,-4(fp)
8110bd10:	0086303a 	nor	r3,zero,r2
8110bd14:	d0a00217 	ldw	r2,-32760(gp)
8110bd18:	1884703a 	and	r2,r3,r2
8110bd1c:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110bd20:	d0a00217 	ldw	r2,-32760(gp)
8110bd24:	1007883a 	mov	r3,r2
8110bd28:	00a00034 	movhi	r2,32768
8110bd2c:	10824004 	addi	r2,r2,2304
8110bd30:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110bd34:	00800044 	movi	r2,1
}
8110bd38:	e037883a 	mov	sp,fp
8110bd3c:	df000017 	ldw	fp,0(sp)
8110bd40:	dec00104 	addi	sp,sp,4
8110bd44:	f800283a 	ret

8110bd48 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110bd48:	defffc04 	addi	sp,sp,-16
8110bd4c:	de00012e 	bgeu	sp,et,8110bd54 <msgdma_write_extended_descriptor+0xc>
8110bd50:	003b68fa 	trap	3
8110bd54:	df000315 	stw	fp,12(sp)
8110bd58:	df000304 	addi	fp,sp,12
8110bd5c:	e13ffd15 	stw	r4,-12(fp)
8110bd60:	e17ffe15 	stw	r5,-8(fp)
8110bd64:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110bd68:	e0bffd17 	ldw	r2,-12(fp)
8110bd6c:	10800037 	ldwio	r2,0(r2)
8110bd70:	1080010c 	andi	r2,r2,4
8110bd74:	10000226 	beq	r2,zero,8110bd80 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110bd78:	00bff904 	movi	r2,-28
8110bd7c:	00003d06 	br	8110be74 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110bd80:	e0bfff17 	ldw	r2,-4(fp)
8110bd84:	10800017 	ldw	r2,0(r2)
8110bd88:	1007883a 	mov	r3,r2
8110bd8c:	e0bffe17 	ldw	r2,-8(fp)
8110bd90:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110bd94:	e0bffe17 	ldw	r2,-8(fp)
8110bd98:	10800104 	addi	r2,r2,4
8110bd9c:	e0ffff17 	ldw	r3,-4(fp)
8110bda0:	18c00117 	ldw	r3,4(r3)
8110bda4:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110bda8:	e0bffe17 	ldw	r2,-8(fp)
8110bdac:	10800204 	addi	r2,r2,8
8110bdb0:	e0ffff17 	ldw	r3,-4(fp)
8110bdb4:	18c00217 	ldw	r3,8(r3)
8110bdb8:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110bdbc:	e0bffe17 	ldw	r2,-8(fp)
8110bdc0:	10800304 	addi	r2,r2,12
8110bdc4:	e0ffff17 	ldw	r3,-4(fp)
8110bdc8:	18c0030b 	ldhu	r3,12(r3)
8110bdcc:	18ffffcc 	andi	r3,r3,65535
8110bdd0:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110bdd4:	e0bffe17 	ldw	r2,-8(fp)
8110bdd8:	10800384 	addi	r2,r2,14
8110bddc:	e0ffff17 	ldw	r3,-4(fp)
8110bde0:	18c00383 	ldbu	r3,14(r3)
8110bde4:	18c03fcc 	andi	r3,r3,255
8110bde8:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110bdec:	e0bffe17 	ldw	r2,-8(fp)
8110bdf0:	108003c4 	addi	r2,r2,15
8110bdf4:	e0ffff17 	ldw	r3,-4(fp)
8110bdf8:	18c003c3 	ldbu	r3,15(r3)
8110bdfc:	18c03fcc 	andi	r3,r3,255
8110be00:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110be04:	e0bffe17 	ldw	r2,-8(fp)
8110be08:	10800404 	addi	r2,r2,16
8110be0c:	e0ffff17 	ldw	r3,-4(fp)
8110be10:	18c0040b 	ldhu	r3,16(r3)
8110be14:	18ffffcc 	andi	r3,r3,65535
8110be18:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110be1c:	e0bffe17 	ldw	r2,-8(fp)
8110be20:	10800484 	addi	r2,r2,18
8110be24:	e0ffff17 	ldw	r3,-4(fp)
8110be28:	18c0048b 	ldhu	r3,18(r3)
8110be2c:	18ffffcc 	andi	r3,r3,65535
8110be30:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110be34:	e0bffe17 	ldw	r2,-8(fp)
8110be38:	10800504 	addi	r2,r2,20
8110be3c:	e0ffff17 	ldw	r3,-4(fp)
8110be40:	18c00517 	ldw	r3,20(r3)
8110be44:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110be48:	e0bffe17 	ldw	r2,-8(fp)
8110be4c:	10800604 	addi	r2,r2,24
8110be50:	e0ffff17 	ldw	r3,-4(fp)
8110be54:	18c00617 	ldw	r3,24(r3)
8110be58:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110be5c:	e0bffe17 	ldw	r2,-8(fp)
8110be60:	10800704 	addi	r2,r2,28
8110be64:	e0ffff17 	ldw	r3,-4(fp)
8110be68:	18c00717 	ldw	r3,28(r3)
8110be6c:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110be70:	0005883a 	mov	r2,zero
}
8110be74:	e037883a 	mov	sp,fp
8110be78:	df000017 	ldw	fp,0(sp)
8110be7c:	dec00104 	addi	sp,sp,4
8110be80:	f800283a 	ret

8110be84 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110be84:	defff604 	addi	sp,sp,-40
8110be88:	de00012e 	bgeu	sp,et,8110be90 <msgdma_construct_extended_descriptor+0xc>
8110be8c:	003b68fa 	trap	3
8110be90:	df000915 	stw	fp,36(sp)
8110be94:	df000904 	addi	fp,sp,36
8110be98:	e13ff715 	stw	r4,-36(fp)
8110be9c:	e17ff815 	stw	r5,-32(fp)
8110bea0:	e1bff915 	stw	r6,-28(fp)
8110bea4:	e1fffa15 	stw	r7,-24(fp)
8110bea8:	e1800517 	ldw	r6,20(fp)
8110beac:	e1400617 	ldw	r5,24(fp)
8110beb0:	e1000717 	ldw	r4,28(fp)
8110beb4:	e0c00817 	ldw	r3,32(fp)
8110beb8:	e0800917 	ldw	r2,36(fp)
8110bebc:	e1bffb0d 	sth	r6,-20(fp)
8110bec0:	e17ffc05 	stb	r5,-16(fp)
8110bec4:	e13ffd05 	stb	r4,-12(fp)
8110bec8:	e0fffe0d 	sth	r3,-8(fp)
8110becc:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110bed0:	e0bff717 	ldw	r2,-36(fp)
8110bed4:	10c01217 	ldw	r3,72(r2)
8110bed8:	e0800117 	ldw	r2,4(fp)
8110bedc:	18801936 	bltu	r3,r2,8110bf44 <msgdma_construct_extended_descriptor+0xc0>
8110bee0:	e13ff717 	ldw	r4,-36(fp)
8110bee4:	20801317 	ldw	r2,76(r4)
8110bee8:	20c01417 	ldw	r3,80(r4)
8110beec:	e13ffe0b 	ldhu	r4,-8(fp)
8110bef0:	213fffcc 	andi	r4,r4,65535
8110bef4:	2015883a 	mov	r10,r4
8110bef8:	0017883a 	mov	r11,zero
8110befc:	1ac01136 	bltu	r3,r11,8110bf44 <msgdma_construct_extended_descriptor+0xc0>
8110bf00:	58c0011e 	bne	r11,r3,8110bf08 <msgdma_construct_extended_descriptor+0x84>
8110bf04:	12800f36 	bltu	r2,r10,8110bf44 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110bf08:	e13ff717 	ldw	r4,-36(fp)
8110bf0c:	20801317 	ldw	r2,76(r4)
8110bf10:	20c01417 	ldw	r3,80(r4)
8110bf14:	e13fff0b 	ldhu	r4,-4(fp)
8110bf18:	213fffcc 	andi	r4,r4,65535
8110bf1c:	2011883a 	mov	r8,r4
8110bf20:	0013883a 	mov	r9,zero
8110bf24:	1a400736 	bltu	r3,r9,8110bf44 <msgdma_construct_extended_descriptor+0xc0>
8110bf28:	48c0011e 	bne	r9,r3,8110bf30 <msgdma_construct_extended_descriptor+0xac>
8110bf2c:	12000536 	bltu	r2,r8,8110bf44 <msgdma_construct_extended_descriptor+0xc0>
8110bf30:	e0bff717 	ldw	r2,-36(fp)
8110bf34:	10801703 	ldbu	r2,92(r2)
8110bf38:	10803fcc 	andi	r2,r2,255
8110bf3c:	10800060 	cmpeqi	r2,r2,1
8110bf40:	1000021e 	bne	r2,zero,8110bf4c <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110bf44:	00bffa84 	movi	r2,-22
8110bf48:	00002306 	br	8110bfd8 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110bf4c:	e0bff817 	ldw	r2,-32(fp)
8110bf50:	e0fff917 	ldw	r3,-28(fp)
8110bf54:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110bf58:	e0bff817 	ldw	r2,-32(fp)
8110bf5c:	e0fffa17 	ldw	r3,-24(fp)
8110bf60:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110bf64:	e0bff817 	ldw	r2,-32(fp)
8110bf68:	e0c00117 	ldw	r3,4(fp)
8110bf6c:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110bf70:	e0bff817 	ldw	r2,-32(fp)
8110bf74:	e0fffb0b 	ldhu	r3,-20(fp)
8110bf78:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110bf7c:	e0bff817 	ldw	r2,-32(fp)
8110bf80:	e0fffc03 	ldbu	r3,-16(fp)
8110bf84:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110bf88:	e0bff817 	ldw	r2,-32(fp)
8110bf8c:	e0fffd03 	ldbu	r3,-12(fp)
8110bf90:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110bf94:	e0bff817 	ldw	r2,-32(fp)
8110bf98:	e0fffe0b 	ldhu	r3,-8(fp)
8110bf9c:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110bfa0:	e0bff817 	ldw	r2,-32(fp)
8110bfa4:	e0ffff0b 	ldhu	r3,-4(fp)
8110bfa8:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110bfac:	e0bff817 	ldw	r2,-32(fp)
8110bfb0:	e0c00317 	ldw	r3,12(fp)
8110bfb4:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110bfb8:	e0bff817 	ldw	r2,-32(fp)
8110bfbc:	e0c00417 	ldw	r3,16(fp)
8110bfc0:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110bfc4:	e0800217 	ldw	r2,8(fp)
8110bfc8:	10e00034 	orhi	r3,r2,32768
8110bfcc:	e0bff817 	ldw	r2,-32(fp)
8110bfd0:	10c00715 	stw	r3,28(r2)

	return 0;
8110bfd4:	0005883a 	mov	r2,zero

}
8110bfd8:	e037883a 	mov	sp,fp
8110bfdc:	df000017 	ldw	fp,0(sp)
8110bfe0:	dec00104 	addi	sp,sp,4
8110bfe4:	f800283a 	ret

8110bfe8 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110bfe8:	deffee04 	addi	sp,sp,-72
8110bfec:	de00012e 	bgeu	sp,et,8110bff4 <msgdma_descriptor_async_transfer+0xc>
8110bff0:	003b68fa 	trap	3
8110bff4:	dfc01115 	stw	ra,68(sp)
8110bff8:	df001015 	stw	fp,64(sp)
8110bffc:	df001004 	addi	fp,sp,64
8110c000:	e13ffd15 	stw	r4,-12(fp)
8110c004:	e17ffe15 	stw	r5,-8(fp)
8110c008:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110c00c:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110c010:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110c014:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c018:	e0bffd17 	ldw	r2,-12(fp)
8110c01c:	10800317 	ldw	r2,12(r2)
8110c020:	10800204 	addi	r2,r2,8
8110c024:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110c028:	10bfffcc 	andi	r2,r2,65535
8110c02c:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c030:	e0bffd17 	ldw	r2,-12(fp)
8110c034:	10800317 	ldw	r2,12(r2)
8110c038:	10800204 	addi	r2,r2,8
8110c03c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110c040:	1004d43a 	srli	r2,r2,16
8110c044:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110c048:	e0bffd17 	ldw	r2,-12(fp)
8110c04c:	10800917 	ldw	r2,36(r2)
8110c050:	e0fff417 	ldw	r3,-48(fp)
8110c054:	1880042e 	bgeu	r3,r2,8110c068 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110c058:	e0bffd17 	ldw	r2,-12(fp)
8110c05c:	10800917 	ldw	r2,36(r2)
8110c060:	e0fff317 	ldw	r3,-52(fp)
8110c064:	18800236 	bltu	r3,r2,8110c070 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110c068:	00bff904 	movi	r2,-28
8110c06c:	0000ab06 	br	8110c31c <msgdma_descriptor_async_transfer+0x334>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110c070:	e0bffd17 	ldw	r2,-12(fp)
8110c074:	10801817 	ldw	r2,96(r2)
8110c078:	e0bff615 	stw	r2,-40(fp)
8110c07c:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110c080:	e0bffc0b 	ldhu	r2,-16(fp)
8110c084:	e0fffc84 	addi	r3,fp,-14
8110c088:	180d883a 	mov	r6,r3
8110c08c:	100b883a 	mov	r5,r2
8110c090:	e13ff617 	ldw	r4,-40(fp)
8110c094:	1140b0c0 	call	81140b0c <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110c098:	00800804 	movi	r2,32
8110c09c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c0a0:	0005303a 	rdctl	r2,status
8110c0a4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c0a8:	e0fff717 	ldw	r3,-36(fp)
8110c0ac:	00bfff84 	movi	r2,-2
8110c0b0:	1884703a 	and	r2,r3,r2
8110c0b4:	1001703a 	wrctl	status,r2
  
  return context;
8110c0b8:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110c0bc:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110c0c0:	e0bffd17 	ldw	r2,-12(fp)
8110c0c4:	10800317 	ldw	r2,12(r2)
8110c0c8:	10800104 	addi	r2,r2,4
8110c0cc:	e0fff117 	ldw	r3,-60(fp)
8110c0d0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110c0d4:	e0bffd17 	ldw	r2,-12(fp)
8110c0d8:	10800317 	ldw	r2,12(r2)
8110c0dc:	e0fffd17 	ldw	r3,-12(fp)
8110c0e0:	18c00317 	ldw	r3,12(r3)
8110c0e4:	18c00037 	ldwio	r3,0(r3)
8110c0e8:	10c00035 	stwio	r3,0(r2)
8110c0ec:	e0bff217 	ldw	r2,-56(fp)
8110c0f0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c0f4:	e0bffb17 	ldw	r2,-20(fp)
8110c0f8:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110c0fc:	e0bffe17 	ldw	r2,-8(fp)
8110c100:	10001626 	beq	r2,zero,8110c15c <msgdma_descriptor_async_transfer+0x174>
8110c104:	e0bfff17 	ldw	r2,-4(fp)
8110c108:	1000141e 	bne	r2,zero,8110c15c <msgdma_descriptor_async_transfer+0x174>
		counter = 0; /* reset counter */
8110c10c:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c110:	00a045f4 	movhi	r2,33047
8110c114:	10a34f04 	addi	r2,r2,-29380
8110c118:	10800a8b 	ldhu	r2,42(r2)
8110c11c:	10bfffcc 	andi	r2,r2,65535
8110c120:	10800228 	cmpgeui	r2,r2,8
8110c124:	1000071e 	bne	r2,zero,8110c144 <msgdma_descriptor_async_transfer+0x15c>
		debug(fp, "invalid dma descriptor option\n");
8110c128:	d0a06217 	ldw	r2,-32376(gp)
8110c12c:	100f883a 	mov	r7,r2
8110c130:	01800784 	movi	r6,30
8110c134:	01400044 	movi	r5,1
8110c138:	01204574 	movhi	r4,33045
8110c13c:	21392904 	addi	r4,r4,-7004
8110c140:	1123cec0 	call	81123cec <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c144:	e0bffd17 	ldw	r2,-12(fp)
8110c148:	10801817 	ldw	r2,96(r2)
8110c14c:	1009883a 	mov	r4,r2
8110c150:	1140e940 	call	81140e94 <OSSemPost>

		return -ETIME;
8110c154:	00bff084 	movi	r2,-62
8110c158:	00007006 	br	8110c31c <msgdma_descriptor_async_transfer+0x334>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110c15c:	e0bffe17 	ldw	r2,-8(fp)
8110c160:	1000291e 	bne	r2,zero,8110c208 <msgdma_descriptor_async_transfer+0x220>
8110c164:	e0bfff17 	ldw	r2,-4(fp)
8110c168:	10002726 	beq	r2,zero,8110c208 <msgdma_descriptor_async_transfer+0x220>
		counter = 0; /* reset counter */
8110c16c:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110c170:	00001b06 	br	8110c1e0 <msgdma_descriptor_async_transfer+0x1f8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110c174:	01000044 	movi	r4,1
8110c178:	11382940 	call	81138294 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c17c:	e0bff00b 	ldhu	r2,-64(fp)
8110c180:	1084e230 	cmpltui	r2,r2,5000
8110c184:	1000131e 	bne	r2,zero,8110c1d4 <msgdma_descriptor_async_transfer+0x1ec>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c188:	00a045f4 	movhi	r2,33047
8110c18c:	10a34f04 	addi	r2,r2,-29380
8110c190:	10800a8b 	ldhu	r2,42(r2)
8110c194:	10bfffcc 	andi	r2,r2,65535
8110c198:	10800228 	cmpgeui	r2,r2,8
8110c19c:	1000071e 	bne	r2,zero,8110c1bc <msgdma_descriptor_async_transfer+0x1d4>
					debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing extended descriptor\n");
8110c1a0:	d0a06217 	ldw	r2,-32376(gp)
8110c1a4:	100f883a 	mov	r7,r2
8110c1a8:	01801544 	movi	r6,85
8110c1ac:	01400044 	movi	r5,1
8110c1b0:	01204574 	movhi	r4,33045
8110c1b4:	21393104 	addi	r4,r4,-6972
8110c1b8:	1123cec0 	call	81123cec <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110c1bc:	e0bffd17 	ldw	r2,-12(fp)
8110c1c0:	10801817 	ldw	r2,96(r2)
8110c1c4:	1009883a 	mov	r4,r2
8110c1c8:	1140e940 	call	81140e94 <OSSemPost>

				return -ETIME;
8110c1cc:	00bff084 	movi	r2,-62
8110c1d0:	00005206 	br	8110c31c <msgdma_descriptor_async_transfer+0x334>
			}
			counter++;
8110c1d4:	e0bff00b 	ldhu	r2,-64(fp)
8110c1d8:	10800044 	addi	r2,r2,1
8110c1dc:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110c1e0:	e0bffd17 	ldw	r2,-12(fp)
8110c1e4:	10c00317 	ldw	r3,12(r2)
8110c1e8:	e0bffd17 	ldw	r2,-12(fp)
8110c1ec:	10800417 	ldw	r2,16(r2)
8110c1f0:	e1bfff17 	ldw	r6,-4(fp)
8110c1f4:	100b883a 	mov	r5,r2
8110c1f8:	1809883a 	mov	r4,r3
8110c1fc:	110bd480 	call	8110bd48 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110c200:	103fdc1e 	bne	r2,zero,8110c174 <__reset+0xfb0ec174>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110c204:	00000606 	br	8110c220 <msgdma_descriptor_async_transfer+0x238>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c208:	e0bffd17 	ldw	r2,-12(fp)
8110c20c:	10801817 	ldw	r2,96(r2)
8110c210:	1009883a 	mov	r4,r2
8110c214:	1140e940 	call	81140e94 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110c218:	00bfffc4 	movi	r2,-1
8110c21c:	00003f06 	br	8110c31c <msgdma_descriptor_async_transfer+0x334>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110c220:	e0bffd17 	ldw	r2,-12(fp)
8110c224:	10800b17 	ldw	r2,44(r2)
8110c228:	10001c26 	beq	r2,zero,8110c29c <msgdma_descriptor_async_transfer+0x2b4>

		control |= (dev->control |
8110c22c:	e0bffd17 	ldw	r2,-12(fp)
8110c230:	10c00d17 	ldw	r3,52(r2)
8110c234:	e0bff117 	ldw	r2,-60(fp)
8110c238:	1884b03a 	or	r2,r3,r2
8110c23c:	10800514 	ori	r2,r2,20
8110c240:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110c244:	e0fff117 	ldw	r3,-60(fp)
8110c248:	00bff7c4 	movi	r2,-33
8110c24c:	1884703a 	and	r2,r3,r2
8110c250:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c254:	0005303a 	rdctl	r2,status
8110c258:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c25c:	e0fff917 	ldw	r3,-28(fp)
8110c260:	00bfff84 	movi	r2,-2
8110c264:	1884703a 	and	r2,r3,r2
8110c268:	1001703a 	wrctl	status,r2
  
  return context;
8110c26c:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110c270:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110c274:	e0bffd17 	ldw	r2,-12(fp)
8110c278:	10800317 	ldw	r2,12(r2)
8110c27c:	10800104 	addi	r2,r2,4
8110c280:	e0fff117 	ldw	r3,-60(fp)
8110c284:	10c00035 	stwio	r3,0(r2)
8110c288:	e0bff217 	ldw	r2,-56(fp)
8110c28c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c290:	e0bff517 	ldw	r2,-44(fp)
8110c294:	1001703a 	wrctl	status,r2
8110c298:	00001b06 	br	8110c308 <msgdma_descriptor_async_transfer+0x320>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110c29c:	e0bffd17 	ldw	r2,-12(fp)
8110c2a0:	10c00d17 	ldw	r3,52(r2)
8110c2a4:	e0bff117 	ldw	r2,-60(fp)
8110c2a8:	1884b03a 	or	r2,r3,r2
8110c2ac:	10800114 	ori	r2,r2,4
8110c2b0:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110c2b4:	e0fff117 	ldw	r3,-60(fp)
8110c2b8:	00bff3c4 	movi	r2,-49
8110c2bc:	1884703a 	and	r2,r3,r2
8110c2c0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c2c4:	0005303a 	rdctl	r2,status
8110c2c8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c2cc:	e0fffa17 	ldw	r3,-24(fp)
8110c2d0:	00bfff84 	movi	r2,-2
8110c2d4:	1884703a 	and	r2,r3,r2
8110c2d8:	1001703a 	wrctl	status,r2
  
  return context;
8110c2dc:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110c2e0:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110c2e4:	e0bffd17 	ldw	r2,-12(fp)
8110c2e8:	10800317 	ldw	r2,12(r2)
8110c2ec:	10800104 	addi	r2,r2,4
8110c2f0:	e0fff117 	ldw	r3,-60(fp)
8110c2f4:	10c00035 	stwio	r3,0(r2)
8110c2f8:	e0bff217 	ldw	r2,-56(fp)
8110c2fc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c300:	e0bff817 	ldw	r2,-32(fp)
8110c304:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110c308:	e0bffd17 	ldw	r2,-12(fp)
8110c30c:	10801817 	ldw	r2,96(r2)
8110c310:	1009883a 	mov	r4,r2
8110c314:	1140e940 	call	81140e94 <OSSemPost>

	return 0;
8110c318:	0005883a 	mov	r2,zero
}
8110c31c:	e037883a 	mov	sp,fp
8110c320:	dfc00117 	ldw	ra,4(sp)
8110c324:	df000017 	ldw	fp,0(sp)
8110c328:	dec00204 	addi	sp,sp,8
8110c32c:	f800283a 	ret

8110c330 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110c330:	deffee04 	addi	sp,sp,-72
8110c334:	de00012e 	bgeu	sp,et,8110c33c <msgdma_descriptor_sync_transfer+0xc>
8110c338:	003b68fa 	trap	3
8110c33c:	dfc01115 	stw	ra,68(sp)
8110c340:	df001015 	stw	fp,64(sp)
8110c344:	df001004 	addi	fp,sp,64
8110c348:	e13ffd15 	stw	r4,-12(fp)
8110c34c:	e17ffe15 	stw	r5,-8(fp)
8110c350:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110c354:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110c358:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110c35c:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110c360:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c364:	e0bffd17 	ldw	r2,-12(fp)
8110c368:	10800317 	ldw	r2,12(r2)
8110c36c:	10800204 	addi	r2,r2,8
8110c370:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110c374:	10bfffcc 	andi	r2,r2,65535
8110c378:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c37c:	e0bffd17 	ldw	r2,-12(fp)
8110c380:	10800317 	ldw	r2,12(r2)
8110c384:	10800204 	addi	r2,r2,8
8110c388:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110c38c:	1004d43a 	srli	r2,r2,16
8110c390:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110c394:	00807804 	movi	r2,480
8110c398:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110c39c:	00003006 	br	8110c460 <msgdma_descriptor_sync_transfer+0x130>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110c3a0:	01000044 	movi	r4,1
8110c3a4:	11382940 	call	81138294 <alt_busy_sleep>
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c3a8:	00a045f4 	movhi	r2,33047
8110c3ac:	10a34f04 	addi	r2,r2,-29380
8110c3b0:	10800a8b 	ldhu	r2,42(r2)
8110c3b4:	10bfffcc 	andi	r2,r2,65535
8110c3b8:	10800228 	cmpgeui	r2,r2,8
8110c3bc:	1000071e 	bne	r2,zero,8110c3dc <msgdma_descriptor_sync_transfer+0xac>
		fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110c3c0:	d0a06217 	ldw	r2,-32376(gp)
8110c3c4:	100f883a 	mov	r7,r2
8110c3c8:	01800a04 	movi	r6,40
8110c3cc:	01400044 	movi	r5,1
8110c3d0:	01204574 	movhi	r4,33045
8110c3d4:	21394704 	addi	r4,r4,-6884
8110c3d8:	1123cec0 	call	81123cec <fwrite>
	}
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c3dc:	e0bff10b 	ldhu	r2,-60(fp)
8110c3e0:	1084e230 	cmpltui	r2,r2,5000
8110c3e4:	10000f1e 	bne	r2,zero,8110c424 <msgdma_descriptor_sync_transfer+0xf4>
		{
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c3e8:	00a045f4 	movhi	r2,33047
8110c3ec:	10a34f04 	addi	r2,r2,-29380
8110c3f0:	10800a8b 	ldhu	r2,42(r2)
8110c3f4:	10bfffcc 	andi	r2,r2,65535
8110c3f8:	10800228 	cmpgeui	r2,r2,8
8110c3fc:	1000071e 	bne	r2,zero,8110c41c <msgdma_descriptor_sync_transfer+0xec>
		debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
8110c400:	d0a06217 	ldw	r2,-32376(gp)
8110c404:	100f883a 	mov	r7,r2
8110c408:	01801304 	movi	r6,76
8110c40c:	01400044 	movi	r5,1
8110c410:	01204574 	movhi	r4,33045
8110c414:	21395204 	addi	r4,r4,-6840
8110c418:	1123cec0 	call	81123cec <fwrite>
	}
#endif
			return -ETIME;
8110c41c:	00bff084 	movi	r2,-62
8110c420:	0000e206 	br	8110c7ac <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110c424:	e0bff10b 	ldhu	r2,-60(fp)
8110c428:	10800044 	addi	r2,r2,1
8110c42c:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c430:	e0bffd17 	ldw	r2,-12(fp)
8110c434:	10800317 	ldw	r2,12(r2)
8110c438:	10800204 	addi	r2,r2,8
8110c43c:	10800037 	ldwio	r2,0(r2)
	}
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110c440:	10bfffcc 	andi	r2,r2,65535
8110c444:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c448:	e0bffd17 	ldw	r2,-12(fp)
8110c44c:	10800317 	ldw	r2,12(r2)
8110c450:	10800204 	addi	r2,r2,8
8110c454:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110c458:	1004d43a 	srli	r2,r2,16
8110c45c:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110c460:	e0bffd17 	ldw	r2,-12(fp)
8110c464:	10800917 	ldw	r2,36(r2)
8110c468:	e0fff317 	ldw	r3,-52(fp)
8110c46c:	18bfcc2e 	bgeu	r3,r2,8110c3a0 <__reset+0xfb0ec3a0>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110c470:	e0bffd17 	ldw	r2,-12(fp)
8110c474:	10800917 	ldw	r2,36(r2)
8110c478:	e0fff217 	ldw	r3,-56(fp)
8110c47c:	18bfc82e 	bgeu	r3,r2,8110c3a0 <__reset+0xfb0ec3a0>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110c480:	e0bffd17 	ldw	r2,-12(fp)
8110c484:	10801817 	ldw	r2,96(r2)
8110c488:	e0bff815 	stw	r2,-32(fp)
8110c48c:	e03ffc0d 	sth	zero,-16(fp)
8110c490:	e0bffc0b 	ldhu	r2,-16(fp)
8110c494:	e0fffc84 	addi	r3,fp,-14
8110c498:	180d883a 	mov	r6,r3
8110c49c:	100b883a 	mov	r5,r2
8110c4a0:	e13ff817 	ldw	r4,-32(fp)
8110c4a4:	1140b0c0 	call	81140b0c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c4a8:	0005303a 	rdctl	r2,status
8110c4ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c4b0:	e0fffb17 	ldw	r3,-20(fp)
8110c4b4:	00bfff84 	movi	r2,-2
8110c4b8:	1884703a 	and	r2,r3,r2
8110c4bc:	1001703a 	wrctl	status,r2
  
  return context;
8110c4c0:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110c4c4:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110c4c8:	e0bffd17 	ldw	r2,-12(fp)
8110c4cc:	10800317 	ldw	r2,12(r2)
8110c4d0:	10800104 	addi	r2,r2,4
8110c4d4:	00c00804 	movi	r3,32
8110c4d8:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110c4dc:	e0bffd17 	ldw	r2,-12(fp)
8110c4e0:	10800317 	ldw	r2,12(r2)
8110c4e4:	e0fffd17 	ldw	r3,-12(fp)
8110c4e8:	18c00317 	ldw	r3,12(r3)
8110c4ec:	18c00037 	ldwio	r3,0(r3)
8110c4f0:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110c4f4:	e0bffe17 	ldw	r2,-8(fp)
8110c4f8:	10001626 	beq	r2,zero,8110c554 <msgdma_descriptor_sync_transfer+0x224>
8110c4fc:	e0bfff17 	ldw	r2,-4(fp)
8110c500:	1000141e 	bne	r2,zero,8110c554 <msgdma_descriptor_sync_transfer+0x224>
		counter = 0; /* reset counter */
8110c504:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c508:	00a045f4 	movhi	r2,33047
8110c50c:	10a34f04 	addi	r2,r2,-29380
8110c510:	10800a8b 	ldhu	r2,42(r2)
8110c514:	10bfffcc 	andi	r2,r2,65535
8110c518:	10800228 	cmpgeui	r2,r2,8
8110c51c:	1000071e 	bne	r2,zero,8110c53c <msgdma_descriptor_sync_transfer+0x20c>
			debug(fp, "invalid dma descriptor option\n");
8110c520:	d0a06217 	ldw	r2,-32376(gp)
8110c524:	100f883a 	mov	r7,r2
8110c528:	01800784 	movi	r6,30
8110c52c:	01400044 	movi	r5,1
8110c530:	01204574 	movhi	r4,33045
8110c534:	21392904 	addi	r4,r4,-7004
8110c538:	1123cec0 	call	81123cec <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c53c:	e0bffd17 	ldw	r2,-12(fp)
8110c540:	10801817 	ldw	r2,96(r2)
8110c544:	1009883a 	mov	r4,r2
8110c548:	1140e940 	call	81140e94 <OSSemPost>

		return -ETIME;
8110c54c:	00bff084 	movi	r2,-62
8110c550:	00009606 	br	8110c7ac <msgdma_descriptor_sync_transfer+0x47c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110c554:	e0bffe17 	ldw	r2,-8(fp)
8110c558:	1000291e 	bne	r2,zero,8110c600 <msgdma_descriptor_sync_transfer+0x2d0>
8110c55c:	e0bfff17 	ldw	r2,-4(fp)
8110c560:	10002726 	beq	r2,zero,8110c600 <msgdma_descriptor_sync_transfer+0x2d0>
		counter = 0; /* reset counter */
8110c564:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110c568:	00001b06 	br	8110c5d8 <msgdma_descriptor_sync_transfer+0x2a8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110c56c:	01000044 	movi	r4,1
8110c570:	11382940 	call	81138294 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c574:	e0bff10b 	ldhu	r2,-60(fp)
8110c578:	1084e230 	cmpltui	r2,r2,5000
8110c57c:	1000131e 	bne	r2,zero,8110c5cc <msgdma_descriptor_sync_transfer+0x29c>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c580:	00a045f4 	movhi	r2,33047
8110c584:	10a34f04 	addi	r2,r2,-29380
8110c588:	10800a8b 	ldhu	r2,42(r2)
8110c58c:	10bfffcc 	andi	r2,r2,65535
8110c590:	10800228 	cmpgeui	r2,r2,8
8110c594:	1000071e 	bne	r2,zero,8110c5b4 <msgdma_descriptor_sync_transfer+0x284>
					debug(fp, "time out after 5 msec while writing extended descriptor to FIFO\n");
8110c598:	d0a06217 	ldw	r2,-32376(gp)
8110c59c:	100f883a 	mov	r7,r2
8110c5a0:	01801004 	movi	r6,64
8110c5a4:	01400044 	movi	r5,1
8110c5a8:	01204574 	movhi	r4,33045
8110c5ac:	21396604 	addi	r4,r4,-6760
8110c5b0:	1123cec0 	call	81123cec <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110c5b4:	e0bffd17 	ldw	r2,-12(fp)
8110c5b8:	10801817 	ldw	r2,96(r2)
8110c5bc:	1009883a 	mov	r4,r2
8110c5c0:	1140e940 	call	81140e94 <OSSemPost>

				return -ETIME;
8110c5c4:	00bff084 	movi	r2,-62
8110c5c8:	00007806 	br	8110c7ac <msgdma_descriptor_sync_transfer+0x47c>
			}
			counter++;
8110c5cc:	e0bff10b 	ldhu	r2,-60(fp)
8110c5d0:	10800044 	addi	r2,r2,1
8110c5d4:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110c5d8:	e0bffd17 	ldw	r2,-12(fp)
8110c5dc:	10c00317 	ldw	r3,12(r2)
8110c5e0:	e0bffd17 	ldw	r2,-12(fp)
8110c5e4:	10800417 	ldw	r2,16(r2)
8110c5e8:	e1bfff17 	ldw	r6,-4(fp)
8110c5ec:	100b883a 	mov	r5,r2
8110c5f0:	1809883a 	mov	r4,r3
8110c5f4:	110bd480 	call	8110bd48 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110c5f8:	103fdc1e 	bne	r2,zero,8110c56c <__reset+0xfb0ec56c>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110c5fc:	00000606 	br	8110c618 <msgdma_descriptor_sync_transfer+0x2e8>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c600:	e0bffd17 	ldw	r2,-12(fp)
8110c604:	10801817 	ldw	r2,96(r2)
8110c608:	1009883a 	mov	r4,r2
8110c60c:	1140e940 	call	81140e94 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110c610:	00bfffc4 	movi	r2,-1
8110c614:	00006506 	br	8110c7ac <msgdma_descriptor_sync_transfer+0x47c>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110c618:	e0bffd17 	ldw	r2,-12(fp)
8110c61c:	10800317 	ldw	r2,12(r2)
8110c620:	10800104 	addi	r2,r2,4
8110c624:	e0fffd17 	ldw	r3,-12(fp)
8110c628:	19000d17 	ldw	r4,52(r3)
8110c62c:	00fff2c4 	movi	r3,-53
8110c630:	20c6703a 	and	r3,r4,r3
8110c634:	18c00114 	ori	r3,r3,4
8110c638:	10c00035 	stwio	r3,0(r2)
8110c63c:	e0bff517 	ldw	r2,-44(fp)
8110c640:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c644:	e0bff717 	ldw	r2,-36(fp)
8110c648:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110c64c:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110c650:	e0bffd17 	ldw	r2,-12(fp)
8110c654:	10800317 	ldw	r2,12(r2)
8110c658:	10800037 	ldwio	r2,0(r2)
8110c65c:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110c660:	00001f06 	br	8110c6e0 <msgdma_descriptor_sync_transfer+0x3b0>
		alt_busy_sleep(1); /* delay 1us */
8110c664:	01000044 	movi	r4,1
8110c668:	11382940 	call	81138294 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c66c:	e0bff10b 	ldhu	r2,-60(fp)
8110c670:	1084e230 	cmpltui	r2,r2,5000
8110c674:	1000131e 	bne	r2,zero,8110c6c4 <msgdma_descriptor_sync_transfer+0x394>
		{
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c678:	00a045f4 	movhi	r2,33047
8110c67c:	10a34f04 	addi	r2,r2,-29380
8110c680:	10800a8b 	ldhu	r2,42(r2)
8110c684:	10bfffcc 	andi	r2,r2,65535
8110c688:	10800228 	cmpgeui	r2,r2,8
8110c68c:	1000071e 	bne	r2,zero,8110c6ac <msgdma_descriptor_sync_transfer+0x37c>
				debug(fp, "time out after 5 msec while waiting for any pending transfer complete\n");
8110c690:	d0a06217 	ldw	r2,-32376(gp)
8110c694:	100f883a 	mov	r7,r2
8110c698:	01801184 	movi	r6,70
8110c69c:	01400044 	movi	r5,1
8110c6a0:	01204574 	movhi	r4,33045
8110c6a4:	21397704 	addi	r4,r4,-6692
8110c6a8:	1123cec0 	call	81123cec <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110c6ac:	e0bffd17 	ldw	r2,-12(fp)
8110c6b0:	10801817 	ldw	r2,96(r2)
8110c6b4:	1009883a 	mov	r4,r2
8110c6b8:	1140e940 	call	81140e94 <OSSemPost>

			return -ETIME;
8110c6bc:	00bff084 	movi	r2,-62
8110c6c0:	00003a06 	br	8110c7ac <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110c6c4:	e0bff10b 	ldhu	r2,-60(fp)
8110c6c8:	10800044 	addi	r2,r2,1
8110c6cc:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110c6d0:	e0bffd17 	ldw	r2,-12(fp)
8110c6d4:	10800317 	ldw	r2,12(r2)
8110c6d8:	10800037 	ldwio	r2,0(r2)
8110c6dc:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110c6e0:	e0fff017 	ldw	r3,-64(fp)
8110c6e4:	e0bff617 	ldw	r2,-40(fp)
8110c6e8:	1884703a 	and	r2,r3,r2
8110c6ec:	1000031e 	bne	r2,zero,8110c6fc <msgdma_descriptor_sync_transfer+0x3cc>
8110c6f0:	e0bff017 	ldw	r2,-64(fp)
8110c6f4:	1080004c 	andi	r2,r2,1
8110c6f8:	103fda1e 	bne	r2,zero,8110c664 <__reset+0xfb0ec664>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110c6fc:	e0fff017 	ldw	r3,-64(fp)
8110c700:	e0bff617 	ldw	r2,-40(fp)
8110c704:	1884703a 	and	r2,r3,r2
8110c708:	10000626 	beq	r2,zero,8110c724 <msgdma_descriptor_sync_transfer+0x3f4>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c70c:	e0bffd17 	ldw	r2,-12(fp)
8110c710:	10801817 	ldw	r2,96(r2)
8110c714:	1009883a 	mov	r4,r2
8110c718:	1140e940 	call	81140e94 <OSSemPost>

		return error;
8110c71c:	e0bff617 	ldw	r2,-40(fp)
8110c720:	00002206 	br	8110c7ac <msgdma_descriptor_sync_transfer+0x47c>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110c724:	e0bffd17 	ldw	r2,-12(fp)
8110c728:	10800317 	ldw	r2,12(r2)
8110c72c:	10800104 	addi	r2,r2,4
8110c730:	10800037 	ldwio	r2,0(r2)
8110c734:	10800814 	ori	r2,r2,32
8110c738:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c73c:	0005303a 	rdctl	r2,status
8110c740:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c744:	e0fffa17 	ldw	r3,-24(fp)
8110c748:	00bfff84 	movi	r2,-2
8110c74c:	1884703a 	and	r2,r3,r2
8110c750:	1001703a 	wrctl	status,r2
  
  return context;
8110c754:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110c758:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110c75c:	e0bffd17 	ldw	r2,-12(fp)
8110c760:	10800317 	ldw	r2,12(r2)
8110c764:	10800104 	addi	r2,r2,4
8110c768:	e0fff417 	ldw	r3,-48(fp)
8110c76c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110c770:	e0bffd17 	ldw	r2,-12(fp)
8110c774:	10800317 	ldw	r2,12(r2)
8110c778:	e0fffd17 	ldw	r3,-12(fp)
8110c77c:	18c00317 	ldw	r3,12(r3)
8110c780:	18c00037 	ldwio	r3,0(r3)
8110c784:	10c00035 	stwio	r3,0(r2)
8110c788:	e0bff517 	ldw	r2,-44(fp)
8110c78c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c790:	e0bff917 	ldw	r2,-28(fp)
8110c794:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110c798:	e0bffd17 	ldw	r2,-12(fp)
8110c79c:	10801817 	ldw	r2,96(r2)
8110c7a0:	1009883a 	mov	r4,r2
8110c7a4:	1140e940 	call	81140e94 <OSSemPost>

	return 0;
8110c7a8:	0005883a 	mov	r2,zero

}
8110c7ac:	e037883a 	mov	sp,fp
8110c7b0:	dfc00117 	ldw	ra,4(sp)
8110c7b4:	df000017 	ldw	fp,0(sp)
8110c7b8:	dec00204 	addi	sp,sp,8
8110c7bc:	f800283a 	ret

8110c7c0 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110c7c0:	deffec04 	addi	sp,sp,-80
8110c7c4:	de00012e 	bgeu	sp,et,8110c7cc <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110c7c8:	003b68fa 	trap	3
8110c7cc:	dfc01315 	stw	ra,76(sp)
8110c7d0:	df001215 	stw	fp,72(sp)
8110c7d4:	df001204 	addi	fp,sp,72
8110c7d8:	e13ff715 	stw	r4,-36(fp)
8110c7dc:	e17ff815 	stw	r5,-32(fp)
8110c7e0:	e1bff915 	stw	r6,-28(fp)
8110c7e4:	e1fffa15 	stw	r7,-24(fp)
8110c7e8:	e1800617 	ldw	r6,24(fp)
8110c7ec:	e1400717 	ldw	r5,28(fp)
8110c7f0:	e1000817 	ldw	r4,32(fp)
8110c7f4:	e0c00917 	ldw	r3,36(fp)
8110c7f8:	e0800a17 	ldw	r2,40(fp)
8110c7fc:	e1bffb0d 	sth	r6,-20(fp)
8110c800:	e17ffc05 	stb	r5,-16(fp)
8110c804:	e13ffd05 	stb	r4,-12(fp)
8110c808:	e0fffe0d 	sth	r3,-8(fp)
8110c80c:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110c810:	e0bffb0b 	ldhu	r2,-20(fp)
8110c814:	e0fffc03 	ldbu	r3,-16(fp)
8110c818:	e13ffd03 	ldbu	r4,-12(fp)
8110c81c:	e17ffe0b 	ldhu	r5,-8(fp)
8110c820:	e1bfff0b 	ldhu	r6,-4(fp)
8110c824:	d9800815 	stw	r6,32(sp)
8110c828:	d9400715 	stw	r5,28(sp)
8110c82c:	d9000615 	stw	r4,24(sp)
8110c830:	d8c00515 	stw	r3,20(sp)
8110c834:	d8800415 	stw	r2,16(sp)
8110c838:	e0800517 	ldw	r2,20(fp)
8110c83c:	d8800315 	stw	r2,12(sp)
8110c840:	e0800417 	ldw	r2,16(fp)
8110c844:	d8800215 	stw	r2,8(sp)
8110c848:	e0800317 	ldw	r2,12(fp)
8110c84c:	d8800115 	stw	r2,4(sp)
8110c850:	e0800217 	ldw	r2,8(fp)
8110c854:	d8800015 	stw	r2,0(sp)
8110c858:	e1fffa17 	ldw	r7,-24(fp)
8110c85c:	e1bff917 	ldw	r6,-28(fp)
8110c860:	e17ff817 	ldw	r5,-32(fp)
8110c864:	e13ff717 	ldw	r4,-36(fp)
8110c868:	110be840 	call	8110be84 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110c86c:	e037883a 	mov	sp,fp
8110c870:	dfc00117 	ldw	ra,4(sp)
8110c874:	df000017 	ldw	fp,0(sp)
8110c878:	dec00204 	addi	sp,sp,8
8110c87c:	f800283a 	ret

8110c880 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110c880:	defffc04 	addi	sp,sp,-16
8110c884:	de00012e 	bgeu	sp,et,8110c88c <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110c888:	003b68fa 	trap	3
8110c88c:	dfc00315 	stw	ra,12(sp)
8110c890:	df000215 	stw	fp,8(sp)
8110c894:	df000204 	addi	fp,sp,8
8110c898:	e13ffe15 	stw	r4,-8(fp)
8110c89c:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110c8a0:	e1bfff17 	ldw	r6,-4(fp)
8110c8a4:	000b883a 	mov	r5,zero
8110c8a8:	e13ffe17 	ldw	r4,-8(fp)
8110c8ac:	110bfe80 	call	8110bfe8 <msgdma_descriptor_async_transfer>
}
8110c8b0:	e037883a 	mov	sp,fp
8110c8b4:	dfc00117 	ldw	ra,4(sp)
8110c8b8:	df000017 	ldw	fp,0(sp)
8110c8bc:	dec00204 	addi	sp,sp,8
8110c8c0:	f800283a 	ret

8110c8c4 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110c8c4:	defffc04 	addi	sp,sp,-16
8110c8c8:	de00012e 	bgeu	sp,et,8110c8d0 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110c8cc:	003b68fa 	trap	3
8110c8d0:	dfc00315 	stw	ra,12(sp)
8110c8d4:	df000215 	stw	fp,8(sp)
8110c8d8:	df000204 	addi	fp,sp,8
8110c8dc:	e13ffe15 	stw	r4,-8(fp)
8110c8e0:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110c8e4:	e1bfff17 	ldw	r6,-4(fp)
8110c8e8:	000b883a 	mov	r5,zero
8110c8ec:	e13ffe17 	ldw	r4,-8(fp)
8110c8f0:	110c3300 	call	8110c330 <msgdma_descriptor_sync_transfer>
}
8110c8f4:	e037883a 	mov	sp,fp
8110c8f8:	dfc00117 	ldw	ra,4(sp)
8110c8fc:	df000017 	ldw	fp,0(sp)
8110c900:	dec00204 	addi	sp,sp,8
8110c904:	f800283a 	ret

8110c908 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110c908:	defff204 	addi	sp,sp,-56
8110c90c:	de00012e 	bgeu	sp,et,8110c914 <POWER_SPI_RW+0xc>
8110c910:	003b68fa 	trap	3
8110c914:	dfc00d15 	stw	ra,52(sp)
8110c918:	df000c15 	stw	fp,48(sp)
8110c91c:	df000c04 	addi	fp,sp,48
8110c920:	2007883a 	mov	r3,r4
8110c924:	2805883a 	mov	r2,r5
8110c928:	e1bffe15 	stw	r6,-8(fp)
8110c92c:	e1ffff15 	stw	r7,-4(fp)
8110c930:	e0fffc05 	stb	r3,-16(fp)
8110c934:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110c938:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110c93c:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110c940:	008003f4 	movhi	r2,15
8110c944:	10909004 	addi	r2,r2,16960
8110c948:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110c94c:	00bfe004 	movi	r2,-128
8110c950:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110c954:	e0bffe17 	ldw	r2,-8(fp)
8110c958:	10000226 	beq	r2,zero,8110c964 <POWER_SPI_RW+0x5c>
8110c95c:	00800804 	movi	r2,32
8110c960:	00000106 	br	8110c968 <POWER_SPI_RW+0x60>
8110c964:	0005883a 	mov	r2,zero
8110c968:	e0fff403 	ldbu	r3,-48(fp)
8110c96c:	10c4b03a 	or	r2,r2,r3
8110c970:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110c974:	e0800217 	ldw	r2,8(fp)
8110c978:	10000226 	beq	r2,zero,8110c984 <POWER_SPI_RW+0x7c>
8110c97c:	00800404 	movi	r2,16
8110c980:	00000106 	br	8110c988 <POWER_SPI_RW+0x80>
8110c984:	0005883a 	mov	r2,zero
8110c988:	e0fff403 	ldbu	r3,-48(fp)
8110c98c:	10c4b03a 	or	r2,r2,r3
8110c990:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110c994:	e0bfff17 	ldw	r2,-4(fp)
8110c998:	10000226 	beq	r2,zero,8110c9a4 <POWER_SPI_RW+0x9c>
8110c99c:	00800204 	movi	r2,8
8110c9a0:	00000106 	br	8110c9a8 <POWER_SPI_RW+0xa0>
8110c9a4:	0005883a 	mov	r2,zero
8110c9a8:	e0fff403 	ldbu	r3,-48(fp)
8110c9ac:	10c4b03a 	or	r2,r2,r3
8110c9b0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110c9b4:	e0bffd03 	ldbu	r2,-12(fp)
8110c9b8:	108001cc 	andi	r2,r2,7
8110c9bc:	1007883a 	mov	r3,r2
8110c9c0:	e0bff403 	ldbu	r2,-48(fp)
8110c9c4:	1884b03a 	or	r2,r3,r2
8110c9c8:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110c9cc:	0007883a 	mov	r3,zero
8110c9d0:	00a00034 	movhi	r2,32768
8110c9d4:	10824404 	addi	r2,r2,2320
8110c9d8:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110c9dc:	0007883a 	mov	r3,zero
8110c9e0:	00a00034 	movhi	r2,32768
8110c9e4:	10824c04 	addi	r2,r2,2352
8110c9e8:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110c9ec:	e0bffc03 	ldbu	r2,-16(fp)
8110c9f0:	1000021e 	bne	r2,zero,8110c9fc <POWER_SPI_RW+0xf4>
8110c9f4:	00c00084 	movi	r3,2
8110c9f8:	00000106 	br	8110ca00 <POWER_SPI_RW+0xf8>
8110c9fc:	00c00044 	movi	r3,1
8110ca00:	00a00034 	movhi	r2,32768
8110ca04:	10824804 	addi	r2,r2,2336
8110ca08:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110ca0c:	010003c4 	movi	r4,15
8110ca10:	1139d080 	call	81139d08 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ca14:	00000306 	br	8110ca24 <POWER_SPI_RW+0x11c>
		nWait++;
8110ca18:	e0bff817 	ldw	r2,-32(fp)
8110ca1c:	10800044 	addi	r2,r2,1
8110ca20:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ca24:	00a00034 	movhi	r2,32768
8110ca28:	10825404 	addi	r2,r2,2384
8110ca2c:	10800037 	ldwio	r2,0(r2)
8110ca30:	1080004c 	andi	r2,r2,1
8110ca34:	10000326 	beq	r2,zero,8110ca44 <POWER_SPI_RW+0x13c>
8110ca38:	e0fff817 	ldw	r3,-32(fp)
8110ca3c:	e0bffa17 	ldw	r2,-24(fp)
8110ca40:	18bff516 	blt	r3,r2,8110ca18 <__reset+0xfb0eca18>
		nWait++;
	}

	if (SPI_SDO) {
8110ca44:	00a00034 	movhi	r2,32768
8110ca48:	10825404 	addi	r2,r2,2384
8110ca4c:	10800037 	ldwio	r2,0(r2)
8110ca50:	1080004c 	andi	r2,r2,1
8110ca54:	10000626 	beq	r2,zero,8110ca70 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110ca58:	00c000c4 	movi	r3,3
8110ca5c:	00a00034 	movhi	r2,32768
8110ca60:	10824804 	addi	r2,r2,2336
8110ca64:	10c00035 	stwio	r3,0(r2)
		return FALSE;
8110ca68:	0005883a 	mov	r2,zero
8110ca6c:	0000db06 	br	8110cddc <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110ca70:	e03ff715 	stw	zero,-36(fp)
8110ca74:	00002406 	br	8110cb08 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110ca78:	e0bff403 	ldbu	r2,-48(fp)
8110ca7c:	10803fcc 	andi	r2,r2,255
8110ca80:	1004d1fa 	srli	r2,r2,7
8110ca84:	10c03fcc 	andi	r3,r2,255
8110ca88:	00a00034 	movhi	r2,32768
8110ca8c:	10825004 	addi	r2,r2,2368
8110ca90:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110ca94:	e0bff403 	ldbu	r2,-48(fp)
8110ca98:	1085883a 	add	r2,r2,r2
8110ca9c:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110caa0:	e0bff517 	ldw	r2,-44(fp)
8110caa4:	1085883a 	add	r2,r2,r2
8110caa8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110caac:	00a00034 	movhi	r2,32768
8110cab0:	10825404 	addi	r2,r2,2384
8110cab4:	10800037 	ldwio	r2,0(r2)
8110cab8:	1080004c 	andi	r2,r2,1
8110cabc:	1007883a 	mov	r3,r2
8110cac0:	e0bff517 	ldw	r2,-44(fp)
8110cac4:	10c4b03a 	or	r2,r2,r3
8110cac8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110cacc:	00c00044 	movi	r3,1
8110cad0:	00a00034 	movhi	r2,32768
8110cad4:	10824c04 	addi	r2,r2,2352
8110cad8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cadc:	010003c4 	movi	r4,15
8110cae0:	1139d080 	call	81139d08 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110cae4:	0007883a 	mov	r3,zero
8110cae8:	00a00034 	movhi	r2,32768
8110caec:	10824c04 	addi	r2,r2,2352
8110caf0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110caf4:	010003c4 	movi	r4,15
8110caf8:	1139d080 	call	81139d08 <usleep>
	if (SPI_SDO) {
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110cafc:	e0bff717 	ldw	r2,-36(fp)
8110cb00:	10800044 	addi	r2,r2,1
8110cb04:	e0bff715 	stw	r2,-36(fp)
8110cb08:	e0bff717 	ldw	r2,-36(fp)
8110cb0c:	10800090 	cmplti	r2,r2,2
8110cb10:	103fd91e 	bne	r2,zero,8110ca78 <__reset+0xfb0eca78>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110cb14:	e03ff715 	stw	zero,-36(fp)
8110cb18:	00002406 	br	8110cbac <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110cb1c:	e0bff403 	ldbu	r2,-48(fp)
8110cb20:	10803fcc 	andi	r2,r2,255
8110cb24:	1004d1fa 	srli	r2,r2,7
8110cb28:	10c03fcc 	andi	r3,r2,255
8110cb2c:	00a00034 	movhi	r2,32768
8110cb30:	10825004 	addi	r2,r2,2368
8110cb34:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110cb38:	e0bff403 	ldbu	r2,-48(fp)
8110cb3c:	1085883a 	add	r2,r2,r2
8110cb40:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110cb44:	e0bff517 	ldw	r2,-44(fp)
8110cb48:	1085883a 	add	r2,r2,r2
8110cb4c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110cb50:	00a00034 	movhi	r2,32768
8110cb54:	10825404 	addi	r2,r2,2384
8110cb58:	10800037 	ldwio	r2,0(r2)
8110cb5c:	1080004c 	andi	r2,r2,1
8110cb60:	1007883a 	mov	r3,r2
8110cb64:	e0bff517 	ldw	r2,-44(fp)
8110cb68:	10c4b03a 	or	r2,r2,r3
8110cb6c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110cb70:	00c00044 	movi	r3,1
8110cb74:	00a00034 	movhi	r2,32768
8110cb78:	10824c04 	addi	r2,r2,2352
8110cb7c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cb80:	010003c4 	movi	r4,15
8110cb84:	1139d080 	call	81139d08 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110cb88:	0007883a 	mov	r3,zero
8110cb8c:	00a00034 	movhi	r2,32768
8110cb90:	10824c04 	addi	r2,r2,2352
8110cb94:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cb98:	010003c4 	movi	r4,15
8110cb9c:	1139d080 	call	81139d08 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110cba0:	e0bff717 	ldw	r2,-36(fp)
8110cba4:	10800044 	addi	r2,r2,1
8110cba8:	e0bff715 	stw	r2,-36(fp)
8110cbac:	e0bff717 	ldw	r2,-36(fp)
8110cbb0:	10800210 	cmplti	r2,r2,8
8110cbb4:	103fd91e 	bne	r2,zero,8110cb1c <__reset+0xfb0ecb1c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110cbb8:	e03ff715 	stw	zero,-36(fp)
8110cbbc:	00001a06 	br	8110cc28 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110cbc0:	e0bff517 	ldw	r2,-44(fp)
8110cbc4:	1085883a 	add	r2,r2,r2
8110cbc8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110cbcc:	00a00034 	movhi	r2,32768
8110cbd0:	10825404 	addi	r2,r2,2384
8110cbd4:	10800037 	ldwio	r2,0(r2)
8110cbd8:	1080004c 	andi	r2,r2,1
8110cbdc:	1007883a 	mov	r3,r2
8110cbe0:	e0bff517 	ldw	r2,-44(fp)
8110cbe4:	10c4b03a 	or	r2,r2,r3
8110cbe8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110cbec:	00c00044 	movi	r3,1
8110cbf0:	00a00034 	movhi	r2,32768
8110cbf4:	10824c04 	addi	r2,r2,2352
8110cbf8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cbfc:	010003c4 	movi	r4,15
8110cc00:	1139d080 	call	81139d08 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110cc04:	0007883a 	mov	r3,zero
8110cc08:	00a00034 	movhi	r2,32768
8110cc0c:	10824c04 	addi	r2,r2,2352
8110cc10:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cc14:	010003c4 	movi	r4,15
8110cc18:	1139d080 	call	81139d08 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110cc1c:	e0bff717 	ldw	r2,-36(fp)
8110cc20:	10800044 	addi	r2,r2,1
8110cc24:	e0bff715 	stw	r2,-36(fp)
8110cc28:	e0bff717 	ldw	r2,-36(fp)
8110cc2c:	10800210 	cmplti	r2,r2,8
8110cc30:	103fe31e 	bne	r2,zero,8110cbc0 <__reset+0xfb0ecbc0>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110cc34:	e03ff715 	stw	zero,-36(fp)
8110cc38:	00001a06 	br	8110cca4 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110cc3c:	e0bff517 	ldw	r2,-44(fp)
8110cc40:	1085883a 	add	r2,r2,r2
8110cc44:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110cc48:	00a00034 	movhi	r2,32768
8110cc4c:	10825404 	addi	r2,r2,2384
8110cc50:	10800037 	ldwio	r2,0(r2)
8110cc54:	1080004c 	andi	r2,r2,1
8110cc58:	1007883a 	mov	r3,r2
8110cc5c:	e0bff517 	ldw	r2,-44(fp)
8110cc60:	10c4b03a 	or	r2,r2,r3
8110cc64:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110cc68:	00c00044 	movi	r3,1
8110cc6c:	00a00034 	movhi	r2,32768
8110cc70:	10824c04 	addi	r2,r2,2352
8110cc74:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cc78:	010003c4 	movi	r4,15
8110cc7c:	1139d080 	call	81139d08 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110cc80:	0007883a 	mov	r3,zero
8110cc84:	00a00034 	movhi	r2,32768
8110cc88:	10824c04 	addi	r2,r2,2352
8110cc8c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cc90:	010003c4 	movi	r4,15
8110cc94:	1139d080 	call	81139d08 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110cc98:	e0bff717 	ldw	r2,-36(fp)
8110cc9c:	10800044 	addi	r2,r2,1
8110cca0:	e0bff715 	stw	r2,-36(fp)
8110cca4:	e0bff717 	ldw	r2,-36(fp)
8110cca8:	10800210 	cmplti	r2,r2,8
8110ccac:	103fe31e 	bne	r2,zero,8110cc3c <__reset+0xfb0ecc3c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110ccb0:	e03ff715 	stw	zero,-36(fp)
8110ccb4:	00001a06 	br	8110cd20 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110ccb8:	e0bff517 	ldw	r2,-44(fp)
8110ccbc:	1085883a 	add	r2,r2,r2
8110ccc0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110ccc4:	00a00034 	movhi	r2,32768
8110ccc8:	10825404 	addi	r2,r2,2384
8110cccc:	10800037 	ldwio	r2,0(r2)
8110ccd0:	1080004c 	andi	r2,r2,1
8110ccd4:	1007883a 	mov	r3,r2
8110ccd8:	e0bff517 	ldw	r2,-44(fp)
8110ccdc:	10c4b03a 	or	r2,r2,r3
8110cce0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110cce4:	00c00044 	movi	r3,1
8110cce8:	00a00034 	movhi	r2,32768
8110ccec:	10824c04 	addi	r2,r2,2352
8110ccf0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ccf4:	010003c4 	movi	r4,15
8110ccf8:	1139d080 	call	81139d08 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ccfc:	0007883a 	mov	r3,zero
8110cd00:	00a00034 	movhi	r2,32768
8110cd04:	10824c04 	addi	r2,r2,2352
8110cd08:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110cd0c:	010003c4 	movi	r4,15
8110cd10:	1139d080 	call	81139d08 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110cd14:	e0bff717 	ldw	r2,-36(fp)
8110cd18:	10800044 	addi	r2,r2,1
8110cd1c:	e0bff715 	stw	r2,-36(fp)
8110cd20:	e0bff717 	ldw	r2,-36(fp)
8110cd24:	10800190 	cmplti	r2,r2,6
8110cd28:	103fe31e 	bne	r2,zero,8110ccb8 <__reset+0xfb0eccb8>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110cd2c:	00c00044 	movi	r3,1
8110cd30:	00a00034 	movhi	r2,32768
8110cd34:	10824c04 	addi	r2,r2,2352
8110cd38:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110cd3c:	010003c4 	movi	r4,15
8110cd40:	1139d080 	call	81139d08 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110cd44:	00c000c4 	movi	r3,3
8110cd48:	00a00034 	movhi	r2,32768
8110cd4c:	10824804 	addi	r2,r2,2336
8110cd50:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110cd54:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110cd58:	00800044 	movi	r2,1
8110cd5c:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110cd60:	e03ff715 	stw	zero,-36(fp)
8110cd64:	00000d06 	br	8110cd9c <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110cd68:	e0fff517 	ldw	r3,-44(fp)
8110cd6c:	e0bff617 	ldw	r2,-40(fp)
8110cd70:	1884703a 	and	r2,r3,r2
8110cd74:	1000031e 	bne	r2,zero,8110cd84 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110cd78:	e0bff917 	ldw	r2,-28(fp)
8110cd7c:	10800044 	addi	r2,r2,1
8110cd80:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110cd84:	e0bff617 	ldw	r2,-40(fp)
8110cd88:	1085883a 	add	r2,r2,r2
8110cd8c:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110cd90:	e0bff717 	ldw	r2,-36(fp)
8110cd94:	10800044 	addi	r2,r2,1
8110cd98:	e0bff715 	stw	r2,-36(fp)
8110cd9c:	e0bff717 	ldw	r2,-36(fp)
8110cda0:	10800810 	cmplti	r2,r2,32
8110cda4:	103ff01e 	bne	r2,zero,8110cd68 <__reset+0xfb0ecd68>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110cda8:	e0bff917 	ldw	r2,-28(fp)
8110cdac:	1080004c 	andi	r2,r2,1
8110cdb0:	1005003a 	cmpeq	r2,r2,zero
8110cdb4:	10803fcc 	andi	r2,r2,255
8110cdb8:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110cdbc:	e0bffb17 	ldw	r2,-20(fp)
8110cdc0:	1000021e 	bne	r2,zero,8110cdcc <POWER_SPI_RW+0x4c4>
		return FALSE;
8110cdc4:	0005883a 	mov	r2,zero
8110cdc8:	00000406 	br	8110cddc <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110cdcc:	e0800317 	ldw	r2,12(fp)
8110cdd0:	e0fff517 	ldw	r3,-44(fp)
8110cdd4:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110cdd8:	e0bffb17 	ldw	r2,-20(fp)
}
8110cddc:	e037883a 	mov	sp,fp
8110cde0:	dfc00117 	ldw	ra,4(sp)
8110cde4:	df000017 	ldw	fp,0(sp)
8110cde8:	dec00204 	addi	sp,sp,8
8110cdec:	f800283a 	ret

8110cdf0 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110cdf0:	defffc04 	addi	sp,sp,-16
8110cdf4:	de00012e 	bgeu	sp,et,8110cdfc <vRstcSimucamReset+0xc>
8110cdf8:	003b68fa 	trap	3
8110cdfc:	dfc00315 	stw	ra,12(sp)
8110ce00:	df000215 	stw	fp,8(sp)
8110ce04:	df000204 	addi	fp,sp,8
8110ce08:	2005883a 	mov	r2,r4
8110ce0c:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110ce10:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110ce14:	e0bfff0b 	ldhu	r2,-4(fp)
8110ce18:	e0fffe17 	ldw	r3,-8(fp)
8110ce1c:	1884b03a 	or	r2,r3,r2
8110ce20:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110ce24:	e0bffe17 	ldw	r2,-8(fp)
8110ce28:	10800074 	orhi	r2,r2,1
8110ce2c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110ce30:	e1bffe17 	ldw	r6,-8(fp)
8110ce34:	000b883a 	mov	r5,zero
8110ce38:	01200034 	movhi	r4,32768
8110ce3c:	21020004 	addi	r4,r4,2048
8110ce40:	110cf400 	call	8110cf40 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110ce44:	0001883a 	nop
8110ce48:	e037883a 	mov	sp,fp
8110ce4c:	dfc00117 	ldw	ra,4(sp)
8110ce50:	df000017 	ldw	fp,0(sp)
8110ce54:	dec00204 	addi	sp,sp,8
8110ce58:	f800283a 	ret

8110ce5c <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110ce5c:	defffc04 	addi	sp,sp,-16
8110ce60:	de00012e 	bgeu	sp,et,8110ce68 <vRstcReleaseDeviceReset+0xc>
8110ce64:	003b68fa 	trap	3
8110ce68:	dfc00315 	stw	ra,12(sp)
8110ce6c:	df000215 	stw	fp,8(sp)
8110ce70:	df000204 	addi	fp,sp,8
8110ce74:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110ce78:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110ce7c:	01400044 	movi	r5,1
8110ce80:	01200034 	movhi	r4,32768
8110ce84:	21020004 	addi	r4,r4,2048
8110ce88:	110cf940 	call	8110cf94 <uliRstReadReg>
8110ce8c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110ce90:	e0bfff17 	ldw	r2,-4(fp)
8110ce94:	0084303a 	nor	r2,zero,r2
8110ce98:	e0fffe17 	ldw	r3,-8(fp)
8110ce9c:	1884703a 	and	r2,r3,r2
8110cea0:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110cea4:	e1bffe17 	ldw	r6,-8(fp)
8110cea8:	01400044 	movi	r5,1
8110ceac:	01200034 	movhi	r4,32768
8110ceb0:	21020004 	addi	r4,r4,2048
8110ceb4:	110cf400 	call	8110cf40 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110ceb8:	0001883a 	nop
8110cebc:	e037883a 	mov	sp,fp
8110cec0:	dfc00117 	ldw	ra,4(sp)
8110cec4:	df000017 	ldw	fp,0(sp)
8110cec8:	dec00204 	addi	sp,sp,8
8110cecc:	f800283a 	ret

8110ced0 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110ced0:	defffc04 	addi	sp,sp,-16
8110ced4:	de00012e 	bgeu	sp,et,8110cedc <vRstcHoldDeviceReset+0xc>
8110ced8:	003b68fa 	trap	3
8110cedc:	dfc00315 	stw	ra,12(sp)
8110cee0:	df000215 	stw	fp,8(sp)
8110cee4:	df000204 	addi	fp,sp,8
8110cee8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110ceec:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110cef0:	01400044 	movi	r5,1
8110cef4:	01200034 	movhi	r4,32768
8110cef8:	21020004 	addi	r4,r4,2048
8110cefc:	110cf940 	call	8110cf94 <uliRstReadReg>
8110cf00:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110cf04:	e0fffe17 	ldw	r3,-8(fp)
8110cf08:	e0bfff17 	ldw	r2,-4(fp)
8110cf0c:	1884b03a 	or	r2,r3,r2
8110cf10:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110cf14:	e1bffe17 	ldw	r6,-8(fp)
8110cf18:	01400044 	movi	r5,1
8110cf1c:	01200034 	movhi	r4,32768
8110cf20:	21020004 	addi	r4,r4,2048
8110cf24:	110cf400 	call	8110cf40 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110cf28:	0001883a 	nop
8110cf2c:	e037883a 	mov	sp,fp
8110cf30:	dfc00117 	ldw	ra,4(sp)
8110cf34:	df000017 	ldw	fp,0(sp)
8110cf38:	dec00204 	addi	sp,sp,8
8110cf3c:	f800283a 	ret

8110cf40 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110cf40:	defffc04 	addi	sp,sp,-16
8110cf44:	de00012e 	bgeu	sp,et,8110cf4c <vRstcWriteReg+0xc>
8110cf48:	003b68fa 	trap	3
8110cf4c:	df000315 	stw	fp,12(sp)
8110cf50:	df000304 	addi	fp,sp,12
8110cf54:	e13ffd15 	stw	r4,-12(fp)
8110cf58:	e17ffe15 	stw	r5,-8(fp)
8110cf5c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110cf60:	e0bffe17 	ldw	r2,-8(fp)
8110cf64:	1085883a 	add	r2,r2,r2
8110cf68:	1085883a 	add	r2,r2,r2
8110cf6c:	1007883a 	mov	r3,r2
8110cf70:	e0bffd17 	ldw	r2,-12(fp)
8110cf74:	10c5883a 	add	r2,r2,r3
8110cf78:	e0ffff17 	ldw	r3,-4(fp)
8110cf7c:	10c00015 	stw	r3,0(r2)
}
8110cf80:	0001883a 	nop
8110cf84:	e037883a 	mov	sp,fp
8110cf88:	df000017 	ldw	fp,0(sp)
8110cf8c:	dec00104 	addi	sp,sp,4
8110cf90:	f800283a 	ret

8110cf94 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110cf94:	defffc04 	addi	sp,sp,-16
8110cf98:	de00012e 	bgeu	sp,et,8110cfa0 <uliRstReadReg+0xc>
8110cf9c:	003b68fa 	trap	3
8110cfa0:	df000315 	stw	fp,12(sp)
8110cfa4:	df000304 	addi	fp,sp,12
8110cfa8:	e13ffe15 	stw	r4,-8(fp)
8110cfac:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110cfb0:	e0bfff17 	ldw	r2,-4(fp)
8110cfb4:	1085883a 	add	r2,r2,r2
8110cfb8:	1085883a 	add	r2,r2,r2
8110cfbc:	1007883a 	mov	r3,r2
8110cfc0:	e0bffe17 	ldw	r2,-8(fp)
8110cfc4:	10c5883a 	add	r2,r2,r3
8110cfc8:	10800017 	ldw	r2,0(r2)
8110cfcc:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110cfd0:	e0bffd17 	ldw	r2,-12(fp)
}
8110cfd4:	e037883a 	mov	sp,fp
8110cfd8:	df000017 	ldw	fp,0(sp)
8110cfdc:	dec00104 	addi	sp,sp,4
8110cfe0:	f800283a 	ret

8110cfe4 <v_spi_start>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110cfe4:	defffe04 	addi	sp,sp,-8
8110cfe8:	de00012e 	bgeu	sp,et,8110cff0 <v_spi_start+0xc>
8110cfec:	003b68fa 	trap	3
8110cff0:	dfc00115 	stw	ra,4(sp)
8110cff4:	df000015 	stw	fp,0(sp)
8110cff8:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110cffc:	0007883a 	mov	r3,zero
8110d000:	00a00034 	movhi	r2,32768
8110d004:	10823004 	addi	r2,r2,2240
8110d008:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110d00c:	0007883a 	mov	r3,zero
8110d010:	00a00034 	movhi	r2,32768
8110d014:	10822c04 	addi	r2,r2,2224
8110d018:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110d01c:	01002584 	movi	r4,150
8110d020:	1139d080 	call	81139d08 <usleep>
}
8110d024:	0001883a 	nop
8110d028:	e037883a 	mov	sp,fp
8110d02c:	dfc00117 	ldw	ra,4(sp)
8110d030:	df000017 	ldw	fp,0(sp)
8110d034:	dec00204 	addi	sp,sp,8
8110d038:	f800283a 	ret

8110d03c <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110d03c:	defffc04 	addi	sp,sp,-16
8110d040:	de00012e 	bgeu	sp,et,8110d048 <v_spi_send_byte+0xc>
8110d044:	003b68fa 	trap	3
8110d048:	dfc00315 	stw	ra,12(sp)
8110d04c:	df000215 	stw	fp,8(sp)
8110d050:	df000204 	addi	fp,sp,8
8110d054:	2005883a 	mov	r2,r4
8110d058:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110d05c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110d060:	00bfe004 	movi	r2,-128
8110d064:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110d068:	e03ffe05 	stb	zero,-8(fp)
8110d06c:	00001b06 	br	8110d0dc <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110d070:	e0ffff03 	ldbu	r3,-4(fp)
8110d074:	e0bffe43 	ldbu	r2,-7(fp)
8110d078:	1884703a 	and	r2,r3,r2
8110d07c:	10803fcc 	andi	r2,r2,255
8110d080:	1004c03a 	cmpne	r2,r2,zero
8110d084:	10c03fcc 	andi	r3,r2,255
8110d088:	00a00034 	movhi	r2,32768
8110d08c:	10823404 	addi	r2,r2,2256
8110d090:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110d094:	e0bffe43 	ldbu	r2,-7(fp)
8110d098:	1004d07a 	srli	r2,r2,1
8110d09c:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110d0a0:	00c00044 	movi	r3,1
8110d0a4:	00a00034 	movhi	r2,32768
8110d0a8:	10823004 	addi	r2,r2,2240
8110d0ac:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110d0b0:	01002584 	movi	r4,150
8110d0b4:	1139d080 	call	81139d08 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110d0b8:	0007883a 	mov	r3,zero
8110d0bc:	00a00034 	movhi	r2,32768
8110d0c0:	10823004 	addi	r2,r2,2240
8110d0c4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110d0c8:	01002584 	movi	r4,150
8110d0cc:	1139d080 	call	81139d08 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110d0d0:	e0bffe03 	ldbu	r2,-8(fp)
8110d0d4:	10800044 	addi	r2,r2,1
8110d0d8:	e0bffe05 	stb	r2,-8(fp)
8110d0dc:	e0bffe03 	ldbu	r2,-8(fp)
8110d0e0:	10800230 	cmpltui	r2,r2,8
8110d0e4:	103fe21e 	bne	r2,zero,8110d070 <__reset+0xfb0ed070>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110d0e8:	0001883a 	nop
8110d0ec:	e037883a 	mov	sp,fp
8110d0f0:	dfc00117 	ldw	ra,4(sp)
8110d0f4:	df000017 	ldw	fp,0(sp)
8110d0f8:	dec00204 	addi	sp,sp,8
8110d0fc:	f800283a 	ret

8110d100 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110d100:	defffd04 	addi	sp,sp,-12
8110d104:	de00012e 	bgeu	sp,et,8110d10c <uc_spi_get_byte+0xc>
8110d108:	003b68fa 	trap	3
8110d10c:	dfc00215 	stw	ra,8(sp)
8110d110:	df000115 	stw	fp,4(sp)
8110d114:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110d118:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110d11c:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110d120:	e03fff05 	stb	zero,-4(fp)
8110d124:	00001a06 	br	8110d190 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110d128:	e0bfff43 	ldbu	r2,-3(fp)
8110d12c:	1085883a 	add	r2,r2,r2
8110d130:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110d134:	00a00034 	movhi	r2,32768
8110d138:	10823804 	addi	r2,r2,2272
8110d13c:	10800037 	ldwio	r2,0(r2)
8110d140:	1080004c 	andi	r2,r2,1
8110d144:	1007883a 	mov	r3,r2
8110d148:	e0bfff43 	ldbu	r2,-3(fp)
8110d14c:	1884b03a 	or	r2,r3,r2
8110d150:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110d154:	00c00044 	movi	r3,1
8110d158:	00a00034 	movhi	r2,32768
8110d15c:	10823004 	addi	r2,r2,2240
8110d160:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110d164:	01002584 	movi	r4,150
8110d168:	1139d080 	call	81139d08 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110d16c:	0007883a 	mov	r3,zero
8110d170:	00a00034 	movhi	r2,32768
8110d174:	10823004 	addi	r2,r2,2240
8110d178:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110d17c:	01002584 	movi	r4,150
8110d180:	1139d080 	call	81139d08 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110d184:	e0bfff03 	ldbu	r2,-4(fp)
8110d188:	10800044 	addi	r2,r2,1
8110d18c:	e0bfff05 	stb	r2,-4(fp)
8110d190:	e0bfff03 	ldbu	r2,-4(fp)
8110d194:	10800230 	cmpltui	r2,r2,8
8110d198:	103fe31e 	bne	r2,zero,8110d128 <__reset+0xfb0ed128>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110d19c:	e0bfff43 	ldbu	r2,-3(fp)
}
8110d1a0:	e037883a 	mov	sp,fp
8110d1a4:	dfc00117 	ldw	ra,4(sp)
8110d1a8:	df000017 	ldw	fp,0(sp)
8110d1ac:	dec00204 	addi	sp,sp,8
8110d1b0:	f800283a 	ret

8110d1b4 <v_spi_end>:

void v_spi_end(void){
8110d1b4:	defffe04 	addi	sp,sp,-8
8110d1b8:	de00012e 	bgeu	sp,et,8110d1c0 <v_spi_end+0xc>
8110d1bc:	003b68fa 	trap	3
8110d1c0:	dfc00115 	stw	ra,4(sp)
8110d1c4:	df000015 	stw	fp,0(sp)
8110d1c8:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110d1cc:	0007883a 	mov	r3,zero
8110d1d0:	00a00034 	movhi	r2,32768
8110d1d4:	10823004 	addi	r2,r2,2240
8110d1d8:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110d1dc:	01002584 	movi	r4,150
8110d1e0:	1139d080 	call	81139d08 <usleep>
    SPI_CS_N(1);
8110d1e4:	00c00044 	movi	r3,1
8110d1e8:	00a00034 	movhi	r2,32768
8110d1ec:	10822c04 	addi	r2,r2,2224
8110d1f0:	10c00035 	stwio	r3,0(r2)
}
8110d1f4:	0001883a 	nop
8110d1f8:	e037883a 	mov	sp,fp
8110d1fc:	dfc00117 	ldw	ra,4(sp)
8110d200:	df000017 	ldw	fp,0(sp)
8110d204:	dec00204 	addi	sp,sp,8
8110d208:	f800283a 	ret

8110d20c <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110d20c:	defff604 	addi	sp,sp,-40
8110d210:	de00012e 	bgeu	sp,et,8110d218 <RTCC_SPI_R_MAC+0xc>
8110d214:	003b68fa 	trap	3
8110d218:	dfc00915 	stw	ra,36(sp)
8110d21c:	df000815 	stw	fp,32(sp)
8110d220:	df000804 	addi	fp,sp,32
8110d224:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110d228:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110d22c:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110d230:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110d234:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110d238:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110d23c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110d240:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110d244:	00800084 	movi	r2,2
8110d248:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110d24c:	00800cc4 	movi	r2,51
8110d250:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110d254:	110cfe40 	call	8110cfe4 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110d258:	e0bffec3 	ldbu	r2,-5(fp)
8110d25c:	1009883a 	mov	r4,r2
8110d260:	110d03c0 	call	8110d03c <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110d264:	e0bffe83 	ldbu	r2,-6(fp)
8110d268:	1009883a 	mov	r4,r2
8110d26c:	110d03c0 	call	8110d03c <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110d270:	110d1000 	call	8110d100 <uc_spi_get_byte>
8110d274:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110d278:	110d1000 	call	8110d100 <uc_spi_get_byte>
8110d27c:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110d280:	110d1000 	call	8110d100 <uc_spi_get_byte>
8110d284:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110d288:	110d1000 	call	8110d100 <uc_spi_get_byte>
8110d28c:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110d290:	110d1000 	call	8110d100 <uc_spi_get_byte>
8110d294:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110d298:	110d1000 	call	8110d100 <uc_spi_get_byte>
8110d29c:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110d2a0:	110d1b40 	call	8110d1b4 <v_spi_end>

    bSuccess = TRUE;
8110d2a4:	00800044 	movi	r2,1
8110d2a8:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110d2ac:	e0bfff17 	ldw	r2,-4(fp)
8110d2b0:	e0fffd03 	ldbu	r3,-12(fp)
8110d2b4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110d2b8:	e0bfff17 	ldw	r2,-4(fp)
8110d2bc:	10800044 	addi	r2,r2,1
8110d2c0:	e0fffd43 	ldbu	r3,-11(fp)
8110d2c4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110d2c8:	e0bfff17 	ldw	r2,-4(fp)
8110d2cc:	10800084 	addi	r2,r2,2
8110d2d0:	e0fffd83 	ldbu	r3,-10(fp)
8110d2d4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110d2d8:	e0bfff17 	ldw	r2,-4(fp)
8110d2dc:	108000c4 	addi	r2,r2,3
8110d2e0:	e0fffdc3 	ldbu	r3,-9(fp)
8110d2e4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110d2e8:	e0bfff17 	ldw	r2,-4(fp)
8110d2ec:	10800104 	addi	r2,r2,4
8110d2f0:	e0fffe03 	ldbu	r3,-8(fp)
8110d2f4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110d2f8:	e0bfff17 	ldw	r2,-4(fp)
8110d2fc:	10800144 	addi	r2,r2,5
8110d300:	e0fffe43 	ldbu	r3,-7(fp)
8110d304:	10c00005 	stb	r3,0(r2)

#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110d308:	00a045f4 	movhi	r2,33047
8110d30c:	10a34f04 	addi	r2,r2,-29380
8110d310:	10800a8b 	ldhu	r2,42(r2)
8110d314:	10bfffcc 	andi	r2,r2,65535
8110d318:	108000e8 	cmpgeui	r2,r2,3
8110d31c:	1000141e 	bne	r2,zero,8110d370 <RTCC_SPI_R_MAC+0x164>
		sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110d320:	e1bffd03 	ldbu	r6,-12(fp)
8110d324:	e1fffd43 	ldbu	r7,-11(fp)
8110d328:	e0bffd83 	ldbu	r2,-10(fp)
8110d32c:	e0fffdc3 	ldbu	r3,-9(fp)
8110d330:	e13ffe03 	ldbu	r4,-8(fp)
8110d334:	e17ffe43 	ldbu	r5,-7(fp)
8110d338:	d9400315 	stw	r5,12(sp)
8110d33c:	d9000215 	stw	r4,8(sp)
8110d340:	d8c00115 	stw	r3,4(sp)
8110d344:	d8800015 	stw	r2,0(sp)
8110d348:	01604574 	movhi	r5,33045
8110d34c:	29798904 	addi	r5,r5,-6620
8110d350:	01204574 	movhi	r4,33045
8110d354:	21156904 	addi	r4,r4,21924
8110d358:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
8110d35c:	d0a06217 	ldw	r2,-32376(gp)
8110d360:	01604574 	movhi	r5,33045
8110d364:	29556904 	addi	r5,r5,21924
8110d368:	1009883a 	mov	r4,r2
8110d36c:	11236500 	call	81123650 <fprintf>
    }
#endif

    return bSuccess;
8110d370:	e0bffc17 	ldw	r2,-16(fp)
}
8110d374:	e037883a 	mov	sp,fp
8110d378:	dfc00117 	ldw	ra,4(sp)
8110d37c:	df000017 	ldw	fp,0(sp)
8110d380:	dec00204 	addi	sp,sp,8
8110d384:	f800283a 	ret

8110d388 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110d388:	defffd04 	addi	sp,sp,-12
8110d38c:	de00012e 	bgeu	sp,et,8110d394 <bSSDisplayConfig+0xc>
8110d390:	003b68fa 	trap	3
8110d394:	df000215 	stw	fp,8(sp)
8110d398:	df000204 	addi	fp,sp,8
8110d39c:	2005883a 	mov	r2,r4
8110d3a0:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110d3a4:	e0bfff03 	ldbu	r2,-4(fp)
8110d3a8:	10c00168 	cmpgeui	r3,r2,5
8110d3ac:	18001c1e 	bne	r3,zero,8110d420 <bSSDisplayConfig+0x98>
8110d3b0:	100690ba 	slli	r3,r2,2
8110d3b4:	00a04474 	movhi	r2,33041
8110d3b8:	10b4f204 	addi	r2,r2,-11320
8110d3bc:	1885883a 	add	r2,r3,r2
8110d3c0:	10800017 	ldw	r2,0(r2)
8110d3c4:	1000683a 	jmp	r2
8110d3c8:	8110d3dc 	xori	r4,r16,17231
8110d3cc:	8110d3e8 	cmpgeui	r4,r16,17231
8110d3d0:	8110d3f4 	orhi	r4,r16,17231
8110d3d4:	8110d408 	cmpgei	r4,r16,17232
8110d3d8:	8110d418 	cmpnei	r4,r16,17232
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110d3dc:	00800cc4 	movi	r2,51
8110d3e0:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d3e4:	00001006 	br	8110d428 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110d3e8:	00801544 	movi	r2,85
8110d3ec:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d3f0:	00000d06 	br	8110d428 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110d3f4:	d0e05043 	ldbu	r3,-32447(gp)
8110d3f8:	00bff744 	movi	r2,-35
8110d3fc:	1884703a 	and	r2,r3,r2
8110d400:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d404:	00000806 	br	8110d428 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110d408:	d0a05043 	ldbu	r2,-32447(gp)
8110d40c:	10800894 	ori	r2,r2,34
8110d410:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d414:	00000406 	br	8110d428 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110d418:	d0205045 	stb	zero,-32447(gp)
	    break;
8110d41c:	00000206 	br	8110d428 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110d420:	0005883a 	mov	r2,zero
8110d424:	00000806 	br	8110d448 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110d428:	00a00034 	movhi	r2,32768
8110d42c:	10828404 	addi	r2,r2,2576
8110d430:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110d434:	d0a05043 	ldbu	r2,-32447(gp)
8110d438:	10c03fcc 	andi	r3,r2,255
8110d43c:	e0bffe17 	ldw	r2,-8(fp)
8110d440:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110d444:	00800044 	movi	r2,1
}
8110d448:	e037883a 	mov	sp,fp
8110d44c:	df000017 	ldw	fp,0(sp)
8110d450:	dec00104 	addi	sp,sp,4
8110d454:	f800283a 	ret

8110d458 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110d458:	defffd04 	addi	sp,sp,-12
8110d45c:	de00012e 	bgeu	sp,et,8110d464 <bSSDisplayUpdate+0xc>
8110d460:	003b68fa 	trap	3
8110d464:	df000215 	stw	fp,8(sp)
8110d468:	df000204 	addi	fp,sp,8
8110d46c:	2005883a 	mov	r2,r4
8110d470:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110d474:	00a00034 	movhi	r2,32768
8110d478:	10828404 	addi	r2,r2,2576
8110d47c:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110d480:	e0bffe17 	ldw	r2,-8(fp)
8110d484:	10800104 	addi	r2,r2,4
8110d488:	e0ffff03 	ldbu	r3,-4(fp)
8110d48c:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110d490:	00800044 	movi	r2,1
}
8110d494:	e037883a 	mov	sp,fp
8110d498:	df000017 	ldw	fp,0(sp)
8110d49c:	dec00104 	addi	sp,sp,4
8110d4a0:	f800283a 	ret

8110d4a4 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110d4a4:	defff904 	addi	sp,sp,-28
8110d4a8:	de00012e 	bgeu	sp,et,8110d4b0 <vSyncHandleIrq+0xc>
8110d4ac:	003b68fa 	trap	3
8110d4b0:	dfc00615 	stw	ra,24(sp)
8110d4b4:	df000515 	stw	fp,20(sp)
8110d4b8:	df000504 	addi	fp,sp,20
8110d4bc:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110d4c0:	e0bfff17 	ldw	r2,-4(fp)
8110d4c4:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110d4c8:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110d4cc:	d0a05203 	ldbu	r2,-32440(gp)
8110d4d0:	108000cc 	andi	r2,r2,3
8110d4d4:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110d4d8:	e0bffd03 	ldbu	r2,-12(fp)
8110d4dc:	1000031e 	bne	r2,zero,8110d4ec <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110d4e0:	00bff804 	movi	r2,-32
8110d4e4:	e0bffe85 	stb	r2,-6(fp)
8110d4e8:	00000206 	br	8110d4f4 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110d4ec:	00bff844 	movi	r2,-31
8110d4f0:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110d4f4:	00800044 	movi	r2,1
8110d4f8:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110d4fc:	d0a06917 	ldw	r2,-32348(gp)
8110d500:	e0fffe17 	ldw	r3,-8(fp)
8110d504:	180b883a 	mov	r5,r3
8110d508:	1009883a 	mov	r4,r2
8110d50c:	114018c0 	call	8114018c <OSQPostFront>
8110d510:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110d514:	e0bffd43 	ldbu	r2,-11(fp)
8110d518:	10000126 	beq	r2,zero,8110d520 <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110d51c:	111f5e40 	call	8111f5e4 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110d520:	e03ffb05 	stb	zero,-20(fp)
8110d524:	00001606 	br	8110d580 <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110d528:	e0bffb03 	ldbu	r2,-20(fp)
8110d52c:	10800444 	addi	r2,r2,17
8110d530:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110d534:	e0bffb03 	ldbu	r2,-20(fp)
8110d538:	1085883a 	add	r2,r2,r2
8110d53c:	1087883a 	add	r3,r2,r2
8110d540:	d0a06a04 	addi	r2,gp,-32344
8110d544:	1885883a 	add	r2,r3,r2
8110d548:	10800017 	ldw	r2,0(r2)
8110d54c:	e0fffe17 	ldw	r3,-8(fp)
8110d550:	180b883a 	mov	r5,r3
8110d554:	1009883a 	mov	r4,r2
8110d558:	114018c0 	call	8114018c <OSQPostFront>
8110d55c:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110d560:	e0bffd43 	ldbu	r2,-11(fp)
8110d564:	10000326 	beq	r2,zero,8110d574 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110d568:	e0bffb03 	ldbu	r2,-20(fp)
8110d56c:	1009883a 	mov	r4,r2
8110d570:	111f50c0 	call	8111f50c <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110d574:	e0bffb03 	ldbu	r2,-20(fp)
8110d578:	10800044 	addi	r2,r2,1
8110d57c:	e0bffb05 	stb	r2,-20(fp)
8110d580:	e0bffb03 	ldbu	r2,-20(fp)
8110d584:	103fe826 	beq	r2,zero,8110d528 <__reset+0xfb0ed528>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110d588:	d0a05203 	ldbu	r2,-32440(gp)
8110d58c:	10800044 	addi	r2,r2,1
8110d590:	d0a05205 	stb	r2,-32440(gp)

	vSyncIrqFlagClrSync();
8110d594:	110d6280 	call	8110d628 <vSyncIrqFlagClrSync>
}
8110d598:	0001883a 	nop
8110d59c:	e037883a 	mov	sp,fp
8110d5a0:	dfc00117 	ldw	ra,4(sp)
8110d5a4:	df000017 	ldw	fp,0(sp)
8110d5a8:	dec00204 	addi	sp,sp,8
8110d5ac:	f800283a 	ret

8110d5b0 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110d5b0:	deffff04 	addi	sp,sp,-4
8110d5b4:	de00012e 	bgeu	sp,et,8110d5bc <vSyncClearCounter+0xc>
8110d5b8:	003b68fa 	trap	3
8110d5bc:	df000015 	stw	fp,0(sp)
8110d5c0:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110d5c4:	d0205205 	stb	zero,-32440(gp)
}
8110d5c8:	0001883a 	nop
8110d5cc:	e037883a 	mov	sp,fp
8110d5d0:	df000017 	ldw	fp,0(sp)
8110d5d4:	dec00104 	addi	sp,sp,4
8110d5d8:	f800283a 	ret

8110d5dc <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110d5dc:	defffd04 	addi	sp,sp,-12
8110d5e0:	de00012e 	bgeu	sp,et,8110d5e8 <vSyncInitIrq+0xc>
8110d5e4:	003b68fa 	trap	3
8110d5e8:	dfc00215 	stw	ra,8(sp)
8110d5ec:	df000115 	stw	fp,4(sp)
8110d5f0:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110d5f4:	d0a05104 	addi	r2,gp,-32444
8110d5f8:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110d5fc:	01a04474 	movhi	r6,33041
8110d600:	31b52904 	addi	r6,r6,-11100
8110d604:	e17fff17 	ldw	r5,-4(fp)
8110d608:	01000284 	movi	r4,10
8110d60c:	11386380 	call	81138638 <alt_irq_register>
}
8110d610:	0001883a 	nop
8110d614:	e037883a 	mov	sp,fp
8110d618:	dfc00117 	ldw	ra,4(sp)
8110d61c:	df000017 	ldw	fp,0(sp)
8110d620:	dec00204 	addi	sp,sp,8
8110d624:	f800283a 	ret

8110d628 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110d628:	defffe04 	addi	sp,sp,-8
8110d62c:	de00012e 	bgeu	sp,et,8110d634 <vSyncIrqFlagClrSync+0xc>
8110d630:	003b68fa 	trap	3
8110d634:	dfc00115 	stw	ra,4(sp)
8110d638:	df000015 	stw	fp,0(sp)
8110d63c:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110d640:	01400044 	movi	r5,1
8110d644:	010002c4 	movi	r4,11
8110d648:	110e4080 	call	8110e408 <bSyncWriteReg>
}
8110d64c:	0001883a 	nop
8110d650:	e037883a 	mov	sp,fp
8110d654:	dfc00117 	ldw	ra,4(sp)
8110d658:	df000017 	ldw	fp,0(sp)
8110d65c:	dec00204 	addi	sp,sp,8
8110d660:	f800283a 	ret

8110d664 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110d664:	defffd04 	addi	sp,sp,-12
8110d668:	de00012e 	bgeu	sp,et,8110d670 <bSyncIrqFlagSync+0xc>
8110d66c:	003b68fa 	trap	3
8110d670:	dfc00215 	stw	ra,8(sp)
8110d674:	df000115 	stw	fp,4(sp)
8110d678:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110d67c:	01000304 	movi	r4,12
8110d680:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d684:	1080004c 	andi	r2,r2,1
8110d688:	10000326 	beq	r2,zero,8110d698 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110d68c:	00800044 	movi	r2,1
8110d690:	e0bfff15 	stw	r2,-4(fp)
8110d694:	00000106 	br	8110d69c <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110d698:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110d69c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d6a0:	e037883a 	mov	sp,fp
8110d6a4:	dfc00117 	ldw	ra,4(sp)
8110d6a8:	df000017 	ldw	fp,0(sp)
8110d6ac:	dec00204 	addi	sp,sp,8
8110d6b0:	f800283a 	ret

8110d6b4 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110d6b4:	defffc04 	addi	sp,sp,-16
8110d6b8:	de00012e 	bgeu	sp,et,8110d6c0 <bSyncStatusExtnIrq+0xc>
8110d6bc:	003b68fa 	trap	3
8110d6c0:	dfc00315 	stw	ra,12(sp)
8110d6c4:	df000215 	stw	fp,8(sp)
8110d6c8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d6cc:	0009883a 	mov	r4,zero
8110d6d0:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d6d4:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110d6d8:	e0bfff17 	ldw	r2,-4(fp)
8110d6dc:	1000030e 	bge	r2,zero,8110d6ec <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110d6e0:	00800044 	movi	r2,1
8110d6e4:	e0bffe15 	stw	r2,-8(fp)
8110d6e8:	00000106 	br	8110d6f0 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110d6ec:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d6f0:	e0bffe17 	ldw	r2,-8(fp)
}
8110d6f4:	e037883a 	mov	sp,fp
8110d6f8:	dfc00117 	ldw	ra,4(sp)
8110d6fc:	df000017 	ldw	fp,0(sp)
8110d700:	dec00204 	addi	sp,sp,8
8110d704:	f800283a 	ret

8110d708 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110d708:	defffc04 	addi	sp,sp,-16
8110d70c:	de00012e 	bgeu	sp,et,8110d714 <ucSyncStatusState+0xc>
8110d710:	003b68fa 	trap	3
8110d714:	dfc00315 	stw	ra,12(sp)
8110d718:	df000215 	stw	fp,8(sp)
8110d71c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d720:	0009883a 	mov	r4,zero
8110d724:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d728:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110d72c:	e0bffe17 	ldw	r2,-8(fp)
8110d730:	10803fec 	andhi	r2,r2,255
8110d734:	1004d43a 	srli	r2,r2,16
8110d738:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110d73c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110d740:	e037883a 	mov	sp,fp
8110d744:	dfc00117 	ldw	ra,4(sp)
8110d748:	df000017 	ldw	fp,0(sp)
8110d74c:	dec00204 	addi	sp,sp,8
8110d750:	f800283a 	ret

8110d754 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110d754:	defffc04 	addi	sp,sp,-16
8110d758:	de00012e 	bgeu	sp,et,8110d760 <ucSyncStatusErrorCode+0xc>
8110d75c:	003b68fa 	trap	3
8110d760:	dfc00315 	stw	ra,12(sp)
8110d764:	df000215 	stw	fp,8(sp)
8110d768:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d76c:	0009883a 	mov	r4,zero
8110d770:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d774:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110d778:	e0bffe17 	ldw	r2,-8(fp)
8110d77c:	10bfc00c 	andi	r2,r2,65280
8110d780:	1004d23a 	srli	r2,r2,8
8110d784:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110d788:	e0bfff03 	ldbu	r2,-4(fp)
}
8110d78c:	e037883a 	mov	sp,fp
8110d790:	dfc00117 	ldw	ra,4(sp)
8110d794:	df000017 	ldw	fp,0(sp)
8110d798:	dec00204 	addi	sp,sp,8
8110d79c:	f800283a 	ret

8110d7a0 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110d7a0:	defffc04 	addi	sp,sp,-16
8110d7a4:	de00012e 	bgeu	sp,et,8110d7ac <ucSyncStatusCycleNumber+0xc>
8110d7a8:	003b68fa 	trap	3
8110d7ac:	dfc00315 	stw	ra,12(sp)
8110d7b0:	df000215 	stw	fp,8(sp)
8110d7b4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d7b8:	0009883a 	mov	r4,zero
8110d7bc:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d7c0:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110d7c4:	e0bffe17 	ldw	r2,-8(fp)
8110d7c8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110d7cc:	e0bfff03 	ldbu	r2,-4(fp)
}
8110d7d0:	e037883a 	mov	sp,fp
8110d7d4:	dfc00117 	ldw	ra,4(sp)
8110d7d8:	df000017 	ldw	fp,0(sp)
8110d7dc:	dec00204 	addi	sp,sp,8
8110d7e0:	f800283a 	ret

8110d7e4 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110d7e4:	defffd04 	addi	sp,sp,-12
8110d7e8:	de00012e 	bgeu	sp,et,8110d7f0 <bSyncSetMbt+0xc>
8110d7ec:	003b68fa 	trap	3
8110d7f0:	dfc00215 	stw	ra,8(sp)
8110d7f4:	df000115 	stw	fp,4(sp)
8110d7f8:	df000104 	addi	fp,sp,4
8110d7fc:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110d800:	e17fff17 	ldw	r5,-4(fp)
8110d804:	01000104 	movi	r4,4
8110d808:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110d80c:	00800044 	movi	r2,1
}
8110d810:	e037883a 	mov	sp,fp
8110d814:	dfc00117 	ldw	ra,4(sp)
8110d818:	df000017 	ldw	fp,0(sp)
8110d81c:	dec00204 	addi	sp,sp,8
8110d820:	f800283a 	ret

8110d824 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110d824:	defffd04 	addi	sp,sp,-12
8110d828:	de00012e 	bgeu	sp,et,8110d830 <bSyncSetBt+0xc>
8110d82c:	003b68fa 	trap	3
8110d830:	dfc00215 	stw	ra,8(sp)
8110d834:	df000115 	stw	fp,4(sp)
8110d838:	df000104 	addi	fp,sp,4
8110d83c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110d840:	e17fff17 	ldw	r5,-4(fp)
8110d844:	01000144 	movi	r4,5
8110d848:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110d84c:	00800044 	movi	r2,1
}
8110d850:	e037883a 	mov	sp,fp
8110d854:	dfc00117 	ldw	ra,4(sp)
8110d858:	df000017 	ldw	fp,0(sp)
8110d85c:	dec00204 	addi	sp,sp,8
8110d860:	f800283a 	ret

8110d864 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110d864:	defffd04 	addi	sp,sp,-12
8110d868:	de00012e 	bgeu	sp,et,8110d870 <bSyncSetPer+0xc>
8110d86c:	003b68fa 	trap	3
8110d870:	dfc00215 	stw	ra,8(sp)
8110d874:	df000115 	stw	fp,4(sp)
8110d878:	df000104 	addi	fp,sp,4
8110d87c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110d880:	e17fff17 	ldw	r5,-4(fp)
8110d884:	01000184 	movi	r4,6
8110d888:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110d88c:	00800044 	movi	r2,1
}
8110d890:	e037883a 	mov	sp,fp
8110d894:	dfc00117 	ldw	ra,4(sp)
8110d898:	df000017 	ldw	fp,0(sp)
8110d89c:	dec00204 	addi	sp,sp,8
8110d8a0:	f800283a 	ret

8110d8a4 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110d8a4:	defffd04 	addi	sp,sp,-12
8110d8a8:	de00012e 	bgeu	sp,et,8110d8b0 <bSyncSetOst+0xc>
8110d8ac:	003b68fa 	trap	3
8110d8b0:	dfc00215 	stw	ra,8(sp)
8110d8b4:	df000115 	stw	fp,4(sp)
8110d8b8:	df000104 	addi	fp,sp,4
8110d8bc:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110d8c0:	e17fff17 	ldw	r5,-4(fp)
8110d8c4:	010001c4 	movi	r4,7
8110d8c8:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110d8cc:	00800044 	movi	r2,1
}
8110d8d0:	e037883a 	mov	sp,fp
8110d8d4:	dfc00117 	ldw	ra,4(sp)
8110d8d8:	df000017 	ldw	fp,0(sp)
8110d8dc:	dec00204 	addi	sp,sp,8
8110d8e0:	f800283a 	ret

8110d8e4 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110d8e4:	defffc04 	addi	sp,sp,-16
8110d8e8:	de00012e 	bgeu	sp,et,8110d8f0 <bSyncSetPolarity+0xc>
8110d8ec:	003b68fa 	trap	3
8110d8f0:	dfc00315 	stw	ra,12(sp)
8110d8f4:	df000215 	stw	fp,8(sp)
8110d8f8:	df000204 	addi	fp,sp,8
8110d8fc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d900:	01000204 	movi	r4,8
8110d904:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d908:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d90c:	e0bfff17 	ldw	r2,-4(fp)
8110d910:	1000051e 	bne	r2,zero,8110d928 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110d914:	e0fffe17 	ldw	r3,-8(fp)
8110d918:	00bfbfc4 	movi	r2,-257
8110d91c:	1884703a 	and	r2,r3,r2
8110d920:	e0bffe15 	stw	r2,-8(fp)
8110d924:	00000306 	br	8110d934 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110d928:	e0bffe17 	ldw	r2,-8(fp)
8110d92c:	10804014 	ori	r2,r2,256
8110d930:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110d934:	e17ffe17 	ldw	r5,-8(fp)
8110d938:	01000204 	movi	r4,8
8110d93c:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110d940:	00800044 	movi	r2,1
}
8110d944:	e037883a 	mov	sp,fp
8110d948:	dfc00117 	ldw	ra,4(sp)
8110d94c:	df000017 	ldw	fp,0(sp)
8110d950:	dec00204 	addi	sp,sp,8
8110d954:	f800283a 	ret

8110d958 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110d958:	defffc04 	addi	sp,sp,-16
8110d95c:	de00012e 	bgeu	sp,et,8110d964 <bSyncSetNCycles+0xc>
8110d960:	003b68fa 	trap	3
8110d964:	dfc00315 	stw	ra,12(sp)
8110d968:	df000215 	stw	fp,8(sp)
8110d96c:	df000204 	addi	fp,sp,8
8110d970:	2005883a 	mov	r2,r4
8110d974:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d978:	01000204 	movi	r4,8
8110d97c:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d980:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110d984:	e0fffe17 	ldw	r3,-8(fp)
8110d988:	00bfc004 	movi	r2,-256
8110d98c:	1884703a 	and	r2,r3,r2
8110d990:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110d994:	e0bfff03 	ldbu	r2,-4(fp)
8110d998:	e0fffe17 	ldw	r3,-8(fp)
8110d99c:	1884b03a 	or	r2,r3,r2
8110d9a0:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110d9a4:	e17ffe17 	ldw	r5,-8(fp)
8110d9a8:	01000204 	movi	r4,8
8110d9ac:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110d9b0:	00800044 	movi	r2,1
}
8110d9b4:	e037883a 	mov	sp,fp
8110d9b8:	dfc00117 	ldw	ra,4(sp)
8110d9bc:	df000017 	ldw	fp,0(sp)
8110d9c0:	dec00204 	addi	sp,sp,8
8110d9c4:	f800283a 	ret

8110d9c8 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110d9c8:	defffd04 	addi	sp,sp,-12
8110d9cc:	de00012e 	bgeu	sp,et,8110d9d4 <uliSyncGetMbt+0xc>
8110d9d0:	003b68fa 	trap	3
8110d9d4:	dfc00215 	stw	ra,8(sp)
8110d9d8:	df000115 	stw	fp,4(sp)
8110d9dc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110d9e0:	01000104 	movi	r4,4
8110d9e4:	110e4640 	call	8110e464 <uliSyncReadReg>
8110d9e8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d9ec:	e0bfff17 	ldw	r2,-4(fp)
}
8110d9f0:	e037883a 	mov	sp,fp
8110d9f4:	dfc00117 	ldw	ra,4(sp)
8110d9f8:	df000017 	ldw	fp,0(sp)
8110d9fc:	dec00204 	addi	sp,sp,8
8110da00:	f800283a 	ret

8110da04 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110da04:	defffd04 	addi	sp,sp,-12
8110da08:	de00012e 	bgeu	sp,et,8110da10 <uliSyncGetBt+0xc>
8110da0c:	003b68fa 	trap	3
8110da10:	dfc00215 	stw	ra,8(sp)
8110da14:	df000115 	stw	fp,4(sp)
8110da18:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110da1c:	01000144 	movi	r4,5
8110da20:	110e4640 	call	8110e464 <uliSyncReadReg>
8110da24:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110da28:	e0bfff17 	ldw	r2,-4(fp)
}
8110da2c:	e037883a 	mov	sp,fp
8110da30:	dfc00117 	ldw	ra,4(sp)
8110da34:	df000017 	ldw	fp,0(sp)
8110da38:	dec00204 	addi	sp,sp,8
8110da3c:	f800283a 	ret

8110da40 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110da40:	defffd04 	addi	sp,sp,-12
8110da44:	de00012e 	bgeu	sp,et,8110da4c <uliSyncGetPer+0xc>
8110da48:	003b68fa 	trap	3
8110da4c:	dfc00215 	stw	ra,8(sp)
8110da50:	df000115 	stw	fp,4(sp)
8110da54:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110da58:	01000184 	movi	r4,6
8110da5c:	110e4640 	call	8110e464 <uliSyncReadReg>
8110da60:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110da64:	e0bfff17 	ldw	r2,-4(fp)
}
8110da68:	e037883a 	mov	sp,fp
8110da6c:	dfc00117 	ldw	ra,4(sp)
8110da70:	df000017 	ldw	fp,0(sp)
8110da74:	dec00204 	addi	sp,sp,8
8110da78:	f800283a 	ret

8110da7c <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110da7c:	defffd04 	addi	sp,sp,-12
8110da80:	de00012e 	bgeu	sp,et,8110da88 <uliSyncGetOst+0xc>
8110da84:	003b68fa 	trap	3
8110da88:	dfc00215 	stw	ra,8(sp)
8110da8c:	df000115 	stw	fp,4(sp)
8110da90:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110da94:	010001c4 	movi	r4,7
8110da98:	110e4640 	call	8110e464 <uliSyncReadReg>
8110da9c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110daa0:	e0bfff17 	ldw	r2,-4(fp)
}
8110daa4:	e037883a 	mov	sp,fp
8110daa8:	dfc00117 	ldw	ra,4(sp)
8110daac:	df000017 	ldw	fp,0(sp)
8110dab0:	dec00204 	addi	sp,sp,8
8110dab4:	f800283a 	ret

8110dab8 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110dab8:	defffd04 	addi	sp,sp,-12
8110dabc:	de00012e 	bgeu	sp,et,8110dac4 <uliSyncGetGeneral+0xc>
8110dac0:	003b68fa 	trap	3
8110dac4:	dfc00215 	stw	ra,8(sp)
8110dac8:	df000115 	stw	fp,4(sp)
8110dacc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110dad0:	01000204 	movi	r4,8
8110dad4:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dad8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110dadc:	e0bfff17 	ldw	r2,-4(fp)
}
8110dae0:	e037883a 	mov	sp,fp
8110dae4:	dfc00117 	ldw	ra,4(sp)
8110dae8:	df000017 	ldw	fp,0(sp)
8110daec:	dec00204 	addi	sp,sp,8
8110daf0:	f800283a 	ret

8110daf4 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110daf4:	defffd04 	addi	sp,sp,-12
8110daf8:	de00012e 	bgeu	sp,et,8110db00 <bSyncErrInj+0xc>
8110dafc:	003b68fa 	trap	3
8110db00:	dfc00215 	stw	ra,8(sp)
8110db04:	df000115 	stw	fp,4(sp)
8110db08:	df000104 	addi	fp,sp,4
8110db0c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110db10:	e17fff17 	ldw	r5,-4(fp)
8110db14:	01000244 	movi	r4,9
8110db18:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110db1c:	00800044 	movi	r2,1
}
8110db20:	e037883a 	mov	sp,fp
8110db24:	dfc00117 	ldw	ra,4(sp)
8110db28:	df000017 	ldw	fp,0(sp)
8110db2c:	dec00204 	addi	sp,sp,8
8110db30:	f800283a 	ret

8110db34 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110db34:	defffc04 	addi	sp,sp,-16
8110db38:	de00012e 	bgeu	sp,et,8110db40 <bSyncCtrExtnIrq+0xc>
8110db3c:	003b68fa 	trap	3
8110db40:	dfc00315 	stw	ra,12(sp)
8110db44:	df000215 	stw	fp,8(sp)
8110db48:	df000204 	addi	fp,sp,8
8110db4c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110db50:	01000284 	movi	r4,10
8110db54:	110e4640 	call	8110e464 <uliSyncReadReg>
8110db58:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110db5c:	e0bfff17 	ldw	r2,-4(fp)
8110db60:	1000061e 	bne	r2,zero,8110db7c <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110db64:	e0fffe17 	ldw	r3,-8(fp)
8110db68:	00a00034 	movhi	r2,32768
8110db6c:	10bfffc4 	addi	r2,r2,-1
8110db70:	1884703a 	and	r2,r3,r2
8110db74:	e0bffe15 	stw	r2,-8(fp)
8110db78:	00000306 	br	8110db88 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110db7c:	e0bffe17 	ldw	r2,-8(fp)
8110db80:	10a00034 	orhi	r2,r2,32768
8110db84:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110db88:	e17ffe17 	ldw	r5,-8(fp)
8110db8c:	01000284 	movi	r4,10
8110db90:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110db94:	00800044 	movi	r2,1
}
8110db98:	e037883a 	mov	sp,fp
8110db9c:	dfc00117 	ldw	ra,4(sp)
8110dba0:	df000017 	ldw	fp,0(sp)
8110dba4:	dec00204 	addi	sp,sp,8
8110dba8:	f800283a 	ret

8110dbac <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110dbac:	defffd04 	addi	sp,sp,-12
8110dbb0:	de00012e 	bgeu	sp,et,8110dbb8 <bSyncCtrStart+0xc>
8110dbb4:	003b68fa 	trap	3
8110dbb8:	dfc00215 	stw	ra,8(sp)
8110dbbc:	df000115 	stw	fp,4(sp)
8110dbc0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dbc4:	01000284 	movi	r4,10
8110dbc8:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dbcc:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110dbd0:	e0bfff17 	ldw	r2,-4(fp)
8110dbd4:	10800234 	orhi	r2,r2,8
8110dbd8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dbdc:	e17fff17 	ldw	r5,-4(fp)
8110dbe0:	01000284 	movi	r4,10
8110dbe4:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110dbe8:	00800044 	movi	r2,1
}
8110dbec:	e037883a 	mov	sp,fp
8110dbf0:	dfc00117 	ldw	ra,4(sp)
8110dbf4:	df000017 	ldw	fp,0(sp)
8110dbf8:	dec00204 	addi	sp,sp,8
8110dbfc:	f800283a 	ret

8110dc00 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110dc00:	defffd04 	addi	sp,sp,-12
8110dc04:	de00012e 	bgeu	sp,et,8110dc0c <bSyncCtrReset+0xc>
8110dc08:	003b68fa 	trap	3
8110dc0c:	dfc00215 	stw	ra,8(sp)
8110dc10:	df000115 	stw	fp,4(sp)
8110dc14:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dc18:	01000284 	movi	r4,10
8110dc1c:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dc20:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110dc24:	e0bfff17 	ldw	r2,-4(fp)
8110dc28:	10800134 	orhi	r2,r2,4
8110dc2c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dc30:	e17fff17 	ldw	r5,-4(fp)
8110dc34:	01000284 	movi	r4,10
8110dc38:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110dc3c:	00800044 	movi	r2,1
}
8110dc40:	e037883a 	mov	sp,fp
8110dc44:	dfc00117 	ldw	ra,4(sp)
8110dc48:	df000017 	ldw	fp,0(sp)
8110dc4c:	dec00204 	addi	sp,sp,8
8110dc50:	f800283a 	ret

8110dc54 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110dc54:	defffd04 	addi	sp,sp,-12
8110dc58:	de00012e 	bgeu	sp,et,8110dc60 <bSyncCtrOneShot+0xc>
8110dc5c:	003b68fa 	trap	3
8110dc60:	dfc00215 	stw	ra,8(sp)
8110dc64:	df000115 	stw	fp,4(sp)
8110dc68:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dc6c:	01000284 	movi	r4,10
8110dc70:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dc74:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110dc78:	e0bfff17 	ldw	r2,-4(fp)
8110dc7c:	108000b4 	orhi	r2,r2,2
8110dc80:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dc84:	e17fff17 	ldw	r5,-4(fp)
8110dc88:	01000284 	movi	r4,10
8110dc8c:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110dc90:	00800044 	movi	r2,1
}
8110dc94:	e037883a 	mov	sp,fp
8110dc98:	dfc00117 	ldw	ra,4(sp)
8110dc9c:	df000017 	ldw	fp,0(sp)
8110dca0:	dec00204 	addi	sp,sp,8
8110dca4:	f800283a 	ret

8110dca8 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110dca8:	defffd04 	addi	sp,sp,-12
8110dcac:	de00012e 	bgeu	sp,et,8110dcb4 <bSyncCtrErrInj+0xc>
8110dcb0:	003b68fa 	trap	3
8110dcb4:	dfc00215 	stw	ra,8(sp)
8110dcb8:	df000115 	stw	fp,4(sp)
8110dcbc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dcc0:	01000284 	movi	r4,10
8110dcc4:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dcc8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110dccc:	e0bfff17 	ldw	r2,-4(fp)
8110dcd0:	10800074 	orhi	r2,r2,1
8110dcd4:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dcd8:	e17fff17 	ldw	r5,-4(fp)
8110dcdc:	01000284 	movi	r4,10
8110dce0:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110dce4:	00800044 	movi	r2,1
}
8110dce8:	e037883a 	mov	sp,fp
8110dcec:	dfc00117 	ldw	ra,4(sp)
8110dcf0:	df000017 	ldw	fp,0(sp)
8110dcf4:	dec00204 	addi	sp,sp,8
8110dcf8:	f800283a 	ret

8110dcfc <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110dcfc:	defffc04 	addi	sp,sp,-16
8110dd00:	de00012e 	bgeu	sp,et,8110dd08 <bSyncCtrSyncOutEnable+0xc>
8110dd04:	003b68fa 	trap	3
8110dd08:	dfc00315 	stw	ra,12(sp)
8110dd0c:	df000215 	stw	fp,8(sp)
8110dd10:	df000204 	addi	fp,sp,8
8110dd14:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dd18:	01000284 	movi	r4,10
8110dd1c:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dd20:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dd24:	e0bfff17 	ldw	r2,-4(fp)
8110dd28:	1000051e 	bne	r2,zero,8110dd40 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110dd2c:	e0fffe17 	ldw	r3,-8(fp)
8110dd30:	00bfbfc4 	movi	r2,-257
8110dd34:	1884703a 	and	r2,r3,r2
8110dd38:	e0bffe15 	stw	r2,-8(fp)
8110dd3c:	00000306 	br	8110dd4c <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110dd40:	e0bffe17 	ldw	r2,-8(fp)
8110dd44:	10804014 	ori	r2,r2,256
8110dd48:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dd4c:	e17ffe17 	ldw	r5,-8(fp)
8110dd50:	01000284 	movi	r4,10
8110dd54:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110dd58:	00800044 	movi	r2,1
}
8110dd5c:	e037883a 	mov	sp,fp
8110dd60:	dfc00117 	ldw	ra,4(sp)
8110dd64:	df000017 	ldw	fp,0(sp)
8110dd68:	dec00204 	addi	sp,sp,8
8110dd6c:	f800283a 	ret

8110dd70 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110dd70:	defffc04 	addi	sp,sp,-16
8110dd74:	de00012e 	bgeu	sp,et,8110dd7c <bSyncCtrCh1OutEnable+0xc>
8110dd78:	003b68fa 	trap	3
8110dd7c:	dfc00315 	stw	ra,12(sp)
8110dd80:	df000215 	stw	fp,8(sp)
8110dd84:	df000204 	addi	fp,sp,8
8110dd88:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dd8c:	01000284 	movi	r4,10
8110dd90:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dd94:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dd98:	e0bfff17 	ldw	r2,-4(fp)
8110dd9c:	1000051e 	bne	r2,zero,8110ddb4 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110dda0:	e0fffe17 	ldw	r3,-8(fp)
8110dda4:	00bfff84 	movi	r2,-2
8110dda8:	1884703a 	and	r2,r3,r2
8110ddac:	e0bffe15 	stw	r2,-8(fp)
8110ddb0:	00000306 	br	8110ddc0 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110ddb4:	e0bffe17 	ldw	r2,-8(fp)
8110ddb8:	10800054 	ori	r2,r2,1
8110ddbc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110ddc0:	e17ffe17 	ldw	r5,-8(fp)
8110ddc4:	01000284 	movi	r4,10
8110ddc8:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110ddcc:	00800044 	movi	r2,1
}
8110ddd0:	e037883a 	mov	sp,fp
8110ddd4:	dfc00117 	ldw	ra,4(sp)
8110ddd8:	df000017 	ldw	fp,0(sp)
8110dddc:	dec00204 	addi	sp,sp,8
8110dde0:	f800283a 	ret

8110dde4 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110dde4:	defffc04 	addi	sp,sp,-16
8110dde8:	de00012e 	bgeu	sp,et,8110ddf0 <bSyncCtrCh2OutEnable+0xc>
8110ddec:	003b68fa 	trap	3
8110ddf0:	dfc00315 	stw	ra,12(sp)
8110ddf4:	df000215 	stw	fp,8(sp)
8110ddf8:	df000204 	addi	fp,sp,8
8110ddfc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110de00:	01000284 	movi	r4,10
8110de04:	110e4640 	call	8110e464 <uliSyncReadReg>
8110de08:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110de0c:	e0bfff17 	ldw	r2,-4(fp)
8110de10:	1000051e 	bne	r2,zero,8110de28 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110de14:	e0fffe17 	ldw	r3,-8(fp)
8110de18:	00bfff44 	movi	r2,-3
8110de1c:	1884703a 	and	r2,r3,r2
8110de20:	e0bffe15 	stw	r2,-8(fp)
8110de24:	00000306 	br	8110de34 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110de28:	e0bffe17 	ldw	r2,-8(fp)
8110de2c:	10800094 	ori	r2,r2,2
8110de30:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110de34:	e17ffe17 	ldw	r5,-8(fp)
8110de38:	01000284 	movi	r4,10
8110de3c:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110de40:	00800044 	movi	r2,1
}
8110de44:	e037883a 	mov	sp,fp
8110de48:	dfc00117 	ldw	ra,4(sp)
8110de4c:	df000017 	ldw	fp,0(sp)
8110de50:	dec00204 	addi	sp,sp,8
8110de54:	f800283a 	ret

8110de58 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110de58:	defffc04 	addi	sp,sp,-16
8110de5c:	de00012e 	bgeu	sp,et,8110de64 <bSyncCtrCh3OutEnable+0xc>
8110de60:	003b68fa 	trap	3
8110de64:	dfc00315 	stw	ra,12(sp)
8110de68:	df000215 	stw	fp,8(sp)
8110de6c:	df000204 	addi	fp,sp,8
8110de70:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110de74:	01000284 	movi	r4,10
8110de78:	110e4640 	call	8110e464 <uliSyncReadReg>
8110de7c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110de80:	e0bfff17 	ldw	r2,-4(fp)
8110de84:	1000051e 	bne	r2,zero,8110de9c <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110de88:	e0fffe17 	ldw	r3,-8(fp)
8110de8c:	00bffec4 	movi	r2,-5
8110de90:	1884703a 	and	r2,r3,r2
8110de94:	e0bffe15 	stw	r2,-8(fp)
8110de98:	00000306 	br	8110dea8 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110de9c:	e0bffe17 	ldw	r2,-8(fp)
8110dea0:	10800114 	ori	r2,r2,4
8110dea4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dea8:	e17ffe17 	ldw	r5,-8(fp)
8110deac:	01000284 	movi	r4,10
8110deb0:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110deb4:	00800044 	movi	r2,1
}
8110deb8:	e037883a 	mov	sp,fp
8110debc:	dfc00117 	ldw	ra,4(sp)
8110dec0:	df000017 	ldw	fp,0(sp)
8110dec4:	dec00204 	addi	sp,sp,8
8110dec8:	f800283a 	ret

8110decc <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110decc:	defffc04 	addi	sp,sp,-16
8110ded0:	de00012e 	bgeu	sp,et,8110ded8 <bSyncCtrCh4OutEnable+0xc>
8110ded4:	003b68fa 	trap	3
8110ded8:	dfc00315 	stw	ra,12(sp)
8110dedc:	df000215 	stw	fp,8(sp)
8110dee0:	df000204 	addi	fp,sp,8
8110dee4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dee8:	01000284 	movi	r4,10
8110deec:	110e4640 	call	8110e464 <uliSyncReadReg>
8110def0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110def4:	e0bfff17 	ldw	r2,-4(fp)
8110def8:	1000051e 	bne	r2,zero,8110df10 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110defc:	e0fffe17 	ldw	r3,-8(fp)
8110df00:	00bffdc4 	movi	r2,-9
8110df04:	1884703a 	and	r2,r3,r2
8110df08:	e0bffe15 	stw	r2,-8(fp)
8110df0c:	00000306 	br	8110df1c <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110df10:	e0bffe17 	ldw	r2,-8(fp)
8110df14:	10800214 	ori	r2,r2,8
8110df18:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110df1c:	e17ffe17 	ldw	r5,-8(fp)
8110df20:	01000284 	movi	r4,10
8110df24:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110df28:	00800044 	movi	r2,1
}
8110df2c:	e037883a 	mov	sp,fp
8110df30:	dfc00117 	ldw	ra,4(sp)
8110df34:	df000017 	ldw	fp,0(sp)
8110df38:	dec00204 	addi	sp,sp,8
8110df3c:	f800283a 	ret

8110df40 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110df40:	defffc04 	addi	sp,sp,-16
8110df44:	de00012e 	bgeu	sp,et,8110df4c <bSyncCtrCh5OutEnable+0xc>
8110df48:	003b68fa 	trap	3
8110df4c:	dfc00315 	stw	ra,12(sp)
8110df50:	df000215 	stw	fp,8(sp)
8110df54:	df000204 	addi	fp,sp,8
8110df58:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110df5c:	01000284 	movi	r4,10
8110df60:	110e4640 	call	8110e464 <uliSyncReadReg>
8110df64:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110df68:	e0bfff17 	ldw	r2,-4(fp)
8110df6c:	1000051e 	bne	r2,zero,8110df84 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110df70:	e0fffe17 	ldw	r3,-8(fp)
8110df74:	00bffbc4 	movi	r2,-17
8110df78:	1884703a 	and	r2,r3,r2
8110df7c:	e0bffe15 	stw	r2,-8(fp)
8110df80:	00000306 	br	8110df90 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110df84:	e0bffe17 	ldw	r2,-8(fp)
8110df88:	10800414 	ori	r2,r2,16
8110df8c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110df90:	e17ffe17 	ldw	r5,-8(fp)
8110df94:	01000284 	movi	r4,10
8110df98:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110df9c:	00800044 	movi	r2,1
}
8110dfa0:	e037883a 	mov	sp,fp
8110dfa4:	dfc00117 	ldw	ra,4(sp)
8110dfa8:	df000017 	ldw	fp,0(sp)
8110dfac:	dec00204 	addi	sp,sp,8
8110dfb0:	f800283a 	ret

8110dfb4 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110dfb4:	defffc04 	addi	sp,sp,-16
8110dfb8:	de00012e 	bgeu	sp,et,8110dfc0 <bSyncCtrCh6OutEnable+0xc>
8110dfbc:	003b68fa 	trap	3
8110dfc0:	dfc00315 	stw	ra,12(sp)
8110dfc4:	df000215 	stw	fp,8(sp)
8110dfc8:	df000204 	addi	fp,sp,8
8110dfcc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dfd0:	01000284 	movi	r4,10
8110dfd4:	110e4640 	call	8110e464 <uliSyncReadReg>
8110dfd8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dfdc:	e0bfff17 	ldw	r2,-4(fp)
8110dfe0:	1000051e 	bne	r2,zero,8110dff8 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110dfe4:	e0fffe17 	ldw	r3,-8(fp)
8110dfe8:	00bff7c4 	movi	r2,-33
8110dfec:	1884703a 	and	r2,r3,r2
8110dff0:	e0bffe15 	stw	r2,-8(fp)
8110dff4:	00000306 	br	8110e004 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110dff8:	e0bffe17 	ldw	r2,-8(fp)
8110dffc:	10800814 	ori	r2,r2,32
8110e000:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110e004:	e17ffe17 	ldw	r5,-8(fp)
8110e008:	01000284 	movi	r4,10
8110e00c:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e010:	00800044 	movi	r2,1
}
8110e014:	e037883a 	mov	sp,fp
8110e018:	dfc00117 	ldw	ra,4(sp)
8110e01c:	df000017 	ldw	fp,0(sp)
8110e020:	dec00204 	addi	sp,sp,8
8110e024:	f800283a 	ret

8110e028 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110e028:	defffc04 	addi	sp,sp,-16
8110e02c:	de00012e 	bgeu	sp,et,8110e034 <bSyncCtrCh7OutEnable+0xc>
8110e030:	003b68fa 	trap	3
8110e034:	dfc00315 	stw	ra,12(sp)
8110e038:	df000215 	stw	fp,8(sp)
8110e03c:	df000204 	addi	fp,sp,8
8110e040:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110e044:	01000284 	movi	r4,10
8110e048:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e04c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110e050:	e0bfff17 	ldw	r2,-4(fp)
8110e054:	1000051e 	bne	r2,zero,8110e06c <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110e058:	e0fffe17 	ldw	r3,-8(fp)
8110e05c:	00bfefc4 	movi	r2,-65
8110e060:	1884703a 	and	r2,r3,r2
8110e064:	e0bffe15 	stw	r2,-8(fp)
8110e068:	00000306 	br	8110e078 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110e06c:	e0bffe17 	ldw	r2,-8(fp)
8110e070:	10801014 	ori	r2,r2,64
8110e074:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110e078:	e17ffe17 	ldw	r5,-8(fp)
8110e07c:	01000284 	movi	r4,10
8110e080:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e084:	00800044 	movi	r2,1
}
8110e088:	e037883a 	mov	sp,fp
8110e08c:	dfc00117 	ldw	ra,4(sp)
8110e090:	df000017 	ldw	fp,0(sp)
8110e094:	dec00204 	addi	sp,sp,8
8110e098:	f800283a 	ret

8110e09c <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110e09c:	defffc04 	addi	sp,sp,-16
8110e0a0:	de00012e 	bgeu	sp,et,8110e0a8 <bSyncCtrCh8OutEnable+0xc>
8110e0a4:	003b68fa 	trap	3
8110e0a8:	dfc00315 	stw	ra,12(sp)
8110e0ac:	df000215 	stw	fp,8(sp)
8110e0b0:	df000204 	addi	fp,sp,8
8110e0b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110e0b8:	01000284 	movi	r4,10
8110e0bc:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e0c0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110e0c4:	e0bfff17 	ldw	r2,-4(fp)
8110e0c8:	1000051e 	bne	r2,zero,8110e0e0 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110e0cc:	e0fffe17 	ldw	r3,-8(fp)
8110e0d0:	00bfdfc4 	movi	r2,-129
8110e0d4:	1884703a 	and	r2,r3,r2
8110e0d8:	e0bffe15 	stw	r2,-8(fp)
8110e0dc:	00000306 	br	8110e0ec <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110e0e0:	e0bffe17 	ldw	r2,-8(fp)
8110e0e4:	10802014 	ori	r2,r2,128
8110e0e8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110e0ec:	e17ffe17 	ldw	r5,-8(fp)
8110e0f0:	01000284 	movi	r4,10
8110e0f4:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e0f8:	00800044 	movi	r2,1
}
8110e0fc:	e037883a 	mov	sp,fp
8110e100:	dfc00117 	ldw	ra,4(sp)
8110e104:	df000017 	ldw	fp,0(sp)
8110e108:	dec00204 	addi	sp,sp,8
8110e10c:	f800283a 	ret

8110e110 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110e110:	defffc04 	addi	sp,sp,-16
8110e114:	de00012e 	bgeu	sp,et,8110e11c <bSyncIrqEnableError+0xc>
8110e118:	003b68fa 	trap	3
8110e11c:	dfc00315 	stw	ra,12(sp)
8110e120:	df000215 	stw	fp,8(sp)
8110e124:	df000204 	addi	fp,sp,8
8110e128:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110e12c:	01000044 	movi	r4,1
8110e130:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e134:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110e138:	e0bfff17 	ldw	r2,-4(fp)
8110e13c:	1000051e 	bne	r2,zero,8110e154 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110e140:	e0fffe17 	ldw	r3,-8(fp)
8110e144:	00bfff44 	movi	r2,-3
8110e148:	1884703a 	and	r2,r3,r2
8110e14c:	e0bffe15 	stw	r2,-8(fp)
8110e150:	00000306 	br	8110e160 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110e154:	e0bffe17 	ldw	r2,-8(fp)
8110e158:	10800094 	ori	r2,r2,2
8110e15c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110e160:	e17ffe17 	ldw	r5,-8(fp)
8110e164:	01000044 	movi	r4,1
8110e168:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e16c:	00800044 	movi	r2,1
}
8110e170:	e037883a 	mov	sp,fp
8110e174:	dfc00117 	ldw	ra,4(sp)
8110e178:	df000017 	ldw	fp,0(sp)
8110e17c:	dec00204 	addi	sp,sp,8
8110e180:	f800283a 	ret

8110e184 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110e184:	defffc04 	addi	sp,sp,-16
8110e188:	de00012e 	bgeu	sp,et,8110e190 <bSyncIrqEnableBlank+0xc>
8110e18c:	003b68fa 	trap	3
8110e190:	dfc00315 	stw	ra,12(sp)
8110e194:	df000215 	stw	fp,8(sp)
8110e198:	df000204 	addi	fp,sp,8
8110e19c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110e1a0:	01000044 	movi	r4,1
8110e1a4:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e1a8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110e1ac:	e0bfff17 	ldw	r2,-4(fp)
8110e1b0:	1000051e 	bne	r2,zero,8110e1c8 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110e1b4:	e0fffe17 	ldw	r3,-8(fp)
8110e1b8:	00bfff84 	movi	r2,-2
8110e1bc:	1884703a 	and	r2,r3,r2
8110e1c0:	e0bffe15 	stw	r2,-8(fp)
8110e1c4:	00000306 	br	8110e1d4 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110e1c8:	e0bffe17 	ldw	r2,-8(fp)
8110e1cc:	10800054 	ori	r2,r2,1
8110e1d0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110e1d4:	e17ffe17 	ldw	r5,-8(fp)
8110e1d8:	01000044 	movi	r4,1
8110e1dc:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e1e0:	00800044 	movi	r2,1
}
8110e1e4:	e037883a 	mov	sp,fp
8110e1e8:	dfc00117 	ldw	ra,4(sp)
8110e1ec:	df000017 	ldw	fp,0(sp)
8110e1f0:	dec00204 	addi	sp,sp,8
8110e1f4:	f800283a 	ret

8110e1f8 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110e1f8:	defffc04 	addi	sp,sp,-16
8110e1fc:	de00012e 	bgeu	sp,et,8110e204 <bSyncIrqFlagClrError+0xc>
8110e200:	003b68fa 	trap	3
8110e204:	dfc00315 	stw	ra,12(sp)
8110e208:	df000215 	stw	fp,8(sp)
8110e20c:	df000204 	addi	fp,sp,8
8110e210:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110e214:	01000084 	movi	r4,2
8110e218:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e21c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110e220:	e0bfff17 	ldw	r2,-4(fp)
8110e224:	1000051e 	bne	r2,zero,8110e23c <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110e228:	e0fffe17 	ldw	r3,-8(fp)
8110e22c:	00bfff44 	movi	r2,-3
8110e230:	1884703a 	and	r2,r3,r2
8110e234:	e0bffe15 	stw	r2,-8(fp)
8110e238:	00000306 	br	8110e248 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110e23c:	e0bffe17 	ldw	r2,-8(fp)
8110e240:	10800094 	ori	r2,r2,2
8110e244:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110e248:	e17ffe17 	ldw	r5,-8(fp)
8110e24c:	01000084 	movi	r4,2
8110e250:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e254:	00800044 	movi	r2,1
}
8110e258:	e037883a 	mov	sp,fp
8110e25c:	dfc00117 	ldw	ra,4(sp)
8110e260:	df000017 	ldw	fp,0(sp)
8110e264:	dec00204 	addi	sp,sp,8
8110e268:	f800283a 	ret

8110e26c <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110e26c:	defffc04 	addi	sp,sp,-16
8110e270:	de00012e 	bgeu	sp,et,8110e278 <bSyncIrqFlagClrBlank+0xc>
8110e274:	003b68fa 	trap	3
8110e278:	dfc00315 	stw	ra,12(sp)
8110e27c:	df000215 	stw	fp,8(sp)
8110e280:	df000204 	addi	fp,sp,8
8110e284:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110e288:	01000084 	movi	r4,2
8110e28c:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e290:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110e294:	e0bfff17 	ldw	r2,-4(fp)
8110e298:	1000051e 	bne	r2,zero,8110e2b0 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110e29c:	e0fffe17 	ldw	r3,-8(fp)
8110e2a0:	00bfff84 	movi	r2,-2
8110e2a4:	1884703a 	and	r2,r3,r2
8110e2a8:	e0bffe15 	stw	r2,-8(fp)
8110e2ac:	00000306 	br	8110e2bc <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110e2b0:	e0bffe17 	ldw	r2,-8(fp)
8110e2b4:	10800054 	ori	r2,r2,1
8110e2b8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110e2bc:	e17ffe17 	ldw	r5,-8(fp)
8110e2c0:	01000084 	movi	r4,2
8110e2c4:	110e4080 	call	8110e408 <bSyncWriteReg>
	return TRUE;
8110e2c8:	00800044 	movi	r2,1
}
8110e2cc:	e037883a 	mov	sp,fp
8110e2d0:	dfc00117 	ldw	ra,4(sp)
8110e2d4:	df000017 	ldw	fp,0(sp)
8110e2d8:	dec00204 	addi	sp,sp,8
8110e2dc:	f800283a 	ret

8110e2e0 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110e2e0:	defffc04 	addi	sp,sp,-16
8110e2e4:	de00012e 	bgeu	sp,et,8110e2ec <bSyncIrqFlagError+0xc>
8110e2e8:	003b68fa 	trap	3
8110e2ec:	dfc00315 	stw	ra,12(sp)
8110e2f0:	df000215 	stw	fp,8(sp)
8110e2f4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110e2f8:	010000c4 	movi	r4,3
8110e2fc:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e300:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110e304:	e0bfff17 	ldw	r2,-4(fp)
8110e308:	1080008c 	andi	r2,r2,2
8110e30c:	10000326 	beq	r2,zero,8110e31c <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110e310:	00800044 	movi	r2,1
8110e314:	e0bffe15 	stw	r2,-8(fp)
8110e318:	00000106 	br	8110e320 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110e31c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110e320:	e0bffe17 	ldw	r2,-8(fp)
}
8110e324:	e037883a 	mov	sp,fp
8110e328:	dfc00117 	ldw	ra,4(sp)
8110e32c:	df000017 	ldw	fp,0(sp)
8110e330:	dec00204 	addi	sp,sp,8
8110e334:	f800283a 	ret

8110e338 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110e338:	defffc04 	addi	sp,sp,-16
8110e33c:	de00012e 	bgeu	sp,et,8110e344 <bSyncIrqFlagBlank+0xc>
8110e340:	003b68fa 	trap	3
8110e344:	dfc00315 	stw	ra,12(sp)
8110e348:	df000215 	stw	fp,8(sp)
8110e34c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110e350:	010000c4 	movi	r4,3
8110e354:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e358:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110e35c:	e0bfff17 	ldw	r2,-4(fp)
8110e360:	1080004c 	andi	r2,r2,1
8110e364:	10000326 	beq	r2,zero,8110e374 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110e368:	00800044 	movi	r2,1
8110e36c:	e0bffe15 	stw	r2,-8(fp)
8110e370:	00000106 	br	8110e378 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110e374:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110e378:	e0bffe17 	ldw	r2,-8(fp)
}
8110e37c:	e037883a 	mov	sp,fp
8110e380:	dfc00117 	ldw	ra,4(sp)
8110e384:	df000017 	ldw	fp,0(sp)
8110e388:	dec00204 	addi	sp,sp,8
8110e38c:	f800283a 	ret

8110e390 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110e390:	defffd04 	addi	sp,sp,-12
8110e394:	de00012e 	bgeu	sp,et,8110e39c <uliSyncGetCtr+0xc>
8110e398:	003b68fa 	trap	3
8110e39c:	dfc00215 	stw	ra,8(sp)
8110e3a0:	df000115 	stw	fp,4(sp)
8110e3a4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110e3a8:	01000284 	movi	r4,10
8110e3ac:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e3b0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110e3b4:	e0bfff17 	ldw	r2,-4(fp)
}
8110e3b8:	e037883a 	mov	sp,fp
8110e3bc:	dfc00117 	ldw	ra,4(sp)
8110e3c0:	df000017 	ldw	fp,0(sp)
8110e3c4:	dec00204 	addi	sp,sp,8
8110e3c8:	f800283a 	ret

8110e3cc <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110e3cc:	defffd04 	addi	sp,sp,-12
8110e3d0:	de00012e 	bgeu	sp,et,8110e3d8 <uliSyncReadStatus+0xc>
8110e3d4:	003b68fa 	trap	3
8110e3d8:	dfc00215 	stw	ra,8(sp)
8110e3dc:	df000115 	stw	fp,4(sp)
8110e3e0:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110e3e4:	0009883a 	mov	r4,zero
8110e3e8:	110e4640 	call	8110e464 <uliSyncReadReg>
8110e3ec:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110e3f0:	e0bfff17 	ldw	r2,-4(fp)
}
8110e3f4:	e037883a 	mov	sp,fp
8110e3f8:	dfc00117 	ldw	ra,4(sp)
8110e3fc:	df000017 	ldw	fp,0(sp)
8110e400:	dec00204 	addi	sp,sp,8
8110e404:	f800283a 	ret

8110e408 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110e408:	defffc04 	addi	sp,sp,-16
8110e40c:	de00012e 	bgeu	sp,et,8110e414 <bSyncWriteReg+0xc>
8110e410:	003b68fa 	trap	3
8110e414:	df000315 	stw	fp,12(sp)
8110e418:	df000304 	addi	fp,sp,12
8110e41c:	e13ffe15 	stw	r4,-8(fp)
8110e420:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110e424:	00a00034 	movhi	r2,32768
8110e428:	10810004 	addi	r2,r2,1024
8110e42c:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110e430:	e0bffe17 	ldw	r2,-8(fp)
8110e434:	1085883a 	add	r2,r2,r2
8110e438:	1085883a 	add	r2,r2,r2
8110e43c:	1007883a 	mov	r3,r2
8110e440:	e0bffd17 	ldw	r2,-12(fp)
8110e444:	10c5883a 	add	r2,r2,r3
8110e448:	e0ffff17 	ldw	r3,-4(fp)
8110e44c:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110e450:	00800044 	movi	r2,1
}
8110e454:	e037883a 	mov	sp,fp
8110e458:	df000017 	ldw	fp,0(sp)
8110e45c:	dec00104 	addi	sp,sp,4
8110e460:	f800283a 	ret

8110e464 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110e464:	defffc04 	addi	sp,sp,-16
8110e468:	de00012e 	bgeu	sp,et,8110e470 <uliSyncReadReg+0xc>
8110e46c:	003b68fa 	trap	3
8110e470:	df000315 	stw	fp,12(sp)
8110e474:	df000304 	addi	fp,sp,12
8110e478:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110e47c:	00a00034 	movhi	r2,32768
8110e480:	10810004 	addi	r2,r2,1024
8110e484:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110e488:	e0bfff17 	ldw	r2,-4(fp)
8110e48c:	1085883a 	add	r2,r2,r2
8110e490:	1085883a 	add	r2,r2,r2
8110e494:	1007883a 	mov	r3,r2
8110e498:	e0bffd17 	ldw	r2,-12(fp)
8110e49c:	10c5883a 	add	r2,r2,r3
8110e4a0:	10800017 	ldw	r2,0(r2)
8110e4a4:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110e4a8:	e0bffe17 	ldw	r2,-8(fp)
}
8110e4ac:	e037883a 	mov	sp,fp
8110e4b0:	df000017 	ldw	fp,0(sp)
8110e4b4:	dec00104 	addi	sp,sp,4
8110e4b8:	f800283a 	ret

8110e4bc <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110e4bc:	defffc04 	addi	sp,sp,-16
8110e4c0:	de00012e 	bgeu	sp,et,8110e4c8 <uliPerCalcPeriodMs+0xc>
8110e4c4:	003b68fa 	trap	3
8110e4c8:	dfc00315 	stw	ra,12(sp)
8110e4cc:	df000215 	stw	fp,8(sp)
8110e4d0:	df000204 	addi	fp,sp,8
8110e4d4:	2005883a 	mov	r2,r4
8110e4d8:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110e4dc:	e0bfff0b 	ldhu	r2,-4(fp)
8110e4e0:	1009883a 	mov	r4,r2
8110e4e4:	11230d40 	call	811230d4 <__floatsidf>
8110e4e8:	1011883a 	mov	r8,r2
8110e4ec:	1813883a 	mov	r9,r3
8110e4f0:	000d883a 	mov	r6,zero
8110e4f4:	01d03a34 	movhi	r7,16616
8110e4f8:	39da8004 	addi	r7,r7,27136
8110e4fc:	4009883a 	mov	r4,r8
8110e500:	480b883a 	mov	r5,r9
8110e504:	11220300 	call	81122030 <__muldf3>
8110e508:	1009883a 	mov	r4,r2
8110e50c:	180b883a 	mov	r5,r3
8110e510:	2005883a 	mov	r2,r4
8110e514:	2807883a 	mov	r3,r5
8110e518:	1009883a 	mov	r4,r2
8110e51c:	180b883a 	mov	r5,r3
8110e520:	11214680 	call	81121468 <__fixunsdfsi>
8110e524:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110e528:	e0bffe17 	ldw	r2,-8(fp)
}
8110e52c:	e037883a 	mov	sp,fp
8110e530:	dfc00117 	ldw	ra,4(sp)
8110e534:	df000017 	ldw	fp,0(sp)
8110e538:	dec00204 	addi	sp,sp,8
8110e53c:	f800283a 	ret

8110e540 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110e540:	defff804 	addi	sp,sp,-32
8110e544:	de00012e 	bgeu	sp,et,8110e54c <vDataControlTask+0xc>
8110e548:	003b68fa 	trap	3
8110e54c:	dfc00715 	stw	ra,28(sp)
8110e550:	df000615 	stw	fp,24(sp)
8110e554:	df000604 	addi	fp,sp,24
8110e558:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110e55c:	e0bffd17 	ldw	r2,-12(fp)
8110e560:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e564:	00a045f4 	movhi	r2,33047
8110e568:	10a34f04 	addi	r2,r2,-29380
8110e56c:	10800a8b 	ldhu	r2,42(r2)
8110e570:	10bfffcc 	andi	r2,r2,65535
8110e574:	10800168 	cmpgeui	r2,r2,5
8110e578:	1000071e 	bne	r2,zero,8110e598 <vDataControlTask+0x58>
        debug(fp,"Data Controller Task. (Task on)\n");
8110e57c:	d0a06217 	ldw	r2,-32376(gp)
8110e580:	100f883a 	mov	r7,r2
8110e584:	01800804 	movi	r6,32
8110e588:	01400044 	movi	r5,1
8110e58c:	01204574 	movhi	r4,33045
8110e590:	21399804 	addi	r4,r4,-6560
8110e594:	1123cec0 	call	81123cec <fwrite>
	}
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110e598:	e0bffa17 	ldw	r2,-24(fp)
8110e59c:	00c00044 	movi	r3,1
8110e5a0:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110e5a4:	d0a05f17 	ldw	r2,-32388(gp)
8110e5a8:	1009883a 	mov	r4,r2
8110e5ac:	113fb540 	call	8113fb54 <OSQFlush>
8110e5b0:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110e5b4:	e0bffc03 	ldbu	r2,-16(fp)
8110e5b8:	10803fcc 	andi	r2,r2,255
8110e5bc:	10000126 	beq	r2,zero,8110e5c4 <vDataControlTask+0x84>
		vFailFlushQueueData();
8110e5c0:	111f7740 	call	8111f774 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110e5c4:	d0a05f17 	ldw	r2,-32388(gp)
8110e5c8:	e0fffc04 	addi	r3,fp,-16
8110e5cc:	180d883a 	mov	r6,r3
8110e5d0:	000b883a 	mov	r5,zero
8110e5d4:	1009883a 	mov	r4,r2
8110e5d8:	113fc140 	call	8113fc14 <OSQPend>
8110e5dc:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110e5e0:	000f883a 	mov	r7,zero
8110e5e4:	01800144 	movi	r6,5
8110e5e8:	000b883a 	mov	r5,zero
8110e5ec:	0009883a 	mov	r4,zero
8110e5f0:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
	}
8110e5f4:	003ff306 	br	8110e5c4 <__reset+0xfb0ee5c4>

8110e5f8 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110e5f8:	defff204 	addi	sp,sp,-56
8110e5fc:	de00012e 	bgeu	sp,et,8110e604 <vFeeTask+0xc>
8110e600:	003b68fa 	trap	3
8110e604:	dfc00d15 	stw	ra,52(sp)
8110e608:	df000c15 	stw	fp,48(sp)
8110e60c:	df000c04 	addi	fp,sp,48
8110e610:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110e614:	e0bfff17 	ldw	r2,-4(fp)
8110e618:	d0a05315 	stw	r2,-32436(gp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e61c:	00a045f4 	movhi	r2,33047
8110e620:	10a34f04 	addi	r2,r2,-29380
8110e624:	10800a8b 	ldhu	r2,42(r2)
8110e628:	10bfffcc 	andi	r2,r2,65535
8110e62c:	10800168 	cmpgeui	r2,r2,5
8110e630:	1000091e 	bne	r2,zero,8110e658 <vFeeTask+0x60>
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110e634:	d0e06217 	ldw	r3,-32376(gp)
8110e638:	d0a05317 	ldw	r2,-32436(gp)
8110e63c:	10800003 	ldbu	r2,0(r2)
8110e640:	10803fcc 	andi	r2,r2,255
8110e644:	100d883a 	mov	r6,r2
8110e648:	01604574 	movhi	r5,33045
8110e64c:	2979a104 	addi	r5,r5,-6524
8110e650:	1809883a 	mov	r4,r3
8110e654:	11236500 	call	81123650 <fprintf>
	}
	#endif

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e658:	00a045f4 	movhi	r2,33047
8110e65c:	10a34f04 	addi	r2,r2,-29380
8110e660:	10800a8b 	ldhu	r2,42(r2)
8110e664:	10bfffcc 	andi	r2,r2,65535
8110e668:	108000e8 	cmpgeui	r2,r2,3
8110e66c:	1000031e 	bne	r2,zero,8110e67c <vFeeTask+0x84>
		vPrintConsoleNFee( pxNFee );
8110e670:	d0a05317 	ldw	r2,-32436(gp)
8110e674:	1009883a 	mov	r4,r2
8110e678:	1111c940 	call	81111c94 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110e67c:	d0a05317 	ldw	r2,-32436(gp)
8110e680:	10802c17 	ldw	r2,176(r2)
8110e684:	10c00368 	cmpgeui	r3,r2,13
8110e688:	1805aa1e 	bne	r3,zero,8110fd34 <vFeeTask+0x173c>
8110e68c:	100690ba 	slli	r3,r2,2
8110e690:	00a04474 	movhi	r2,33041
8110e694:	10b9a904 	addi	r2,r2,-6492
8110e698:	1885883a 	add	r2,r3,r2
8110e69c:	10800017 	ldw	r2,0(r2)
8110e6a0:	1000683a 	jmp	r2
8110e6a4:	8110e6d8 	cmpnei	r4,r16,17307
8110e6a8:	8110eee4 	muli	r4,r16,17339
8110e6ac:	8110ef80 	call	88110ef8 <__reset+0x20f0ef8>
8110e6b0:	8110f0f8 	rdprs	r4,r16,17347
8110e6b4:	8110f850 	cmplti	r4,r16,17377
8110e6b8:	8110ed04 	addi	r4,r16,17332
8110e6bc:	8110ef90 	cmplti	r4,r16,17342
8110e6c0:	8110f744 	addi	r4,r16,17373
8110e6c4:	8110fd34 	orhi	r4,r16,17396
8110e6c8:	8110fd34 	orhi	r4,r16,17396
8110e6cc:	8110f194 	ori	r4,r16,17350
8110e6d0:	8110fb40 	call	88110fb4 <__reset+0x20f0fb4>
8110e6d4:	8110fc5c 	xori	r4,r16,17393
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e6d8:	d0a05317 	ldw	r2,-32436(gp)
8110e6dc:	10800003 	ldbu	r2,0(r2)
8110e6e0:	10803fcc 	andi	r2,r2,255
8110e6e4:	1085883a 	add	r2,r2,r2
8110e6e8:	1087883a 	add	r3,r2,r2
8110e6ec:	d0a06a04 	addi	r2,gp,-32344
8110e6f0:	1885883a 	add	r2,r3,r2
8110e6f4:	10800017 	ldw	r2,0(r2)
8110e6f8:	1009883a 	mov	r4,r2
8110e6fc:	113fb540 	call	8113fb54 <OSQFlush>
8110e700:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e704:	e0bffd03 	ldbu	r2,-12(fp)
8110e708:	10803fcc 	andi	r2,r2,255
8110e70c:	10000126 	beq	r2,zero,8110e714 <vFeeTask+0x11c>
					vFailFlushNFEEQueue();
8110e710:	111f83c0 	call	8111f83c <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e714:	d0a05317 	ldw	r2,-32436(gp)
8110e718:	10800003 	ldbu	r2,0(r2)
8110e71c:	10803fcc 	andi	r2,r2,255
8110e720:	1085883a 	add	r2,r2,r2
8110e724:	1087883a 	add	r3,r2,r2
8110e728:	d0a05c04 	addi	r2,gp,-32400
8110e72c:	1885883a 	add	r2,r3,r2
8110e730:	10800017 	ldw	r2,0(r2)
8110e734:	1009883a 	mov	r4,r2
8110e738:	113fb540 	call	8113fb54 <OSQFlush>
8110e73c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e740:	e0bffd03 	ldbu	r2,-12(fp)
8110e744:	10803fcc 	andi	r2,r2,255
8110e748:	10000126 	beq	r2,zero,8110e750 <vFeeTask+0x158>
					vFailFlushNFEEQueue();
8110e74c:	111f83c0 	call	8111f83c <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e750:	d0a05317 	ldw	r2,-32436(gp)
8110e754:	10803304 	addi	r2,r2,204
8110e758:	1009883a 	mov	r4,r2
8110e75c:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110e760:	d0a05317 	ldw	r2,-32436(gp)
8110e764:	d0e05317 	ldw	r3,-32436(gp)
8110e768:	1900308b 	ldhu	r4,194(r3)
8110e76c:	d0e05317 	ldw	r3,-32436(gp)
8110e770:	18c02f0b 	ldhu	r3,188(r3)
8110e774:	20c7883a 	add	r3,r4,r3
8110e778:	1809883a 	mov	r4,r3
8110e77c:	d0e05317 	ldw	r3,-32436(gp)
8110e780:	18c02f8b 	ldhu	r3,190(r3)
8110e784:	20c7883a 	add	r3,r4,r3
8110e788:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110e78c:	d0a05317 	ldw	r2,-32436(gp)
8110e790:	d0e05317 	ldw	r3,-32436(gp)
8110e794:	1900310b 	ldhu	r4,196(r3)
8110e798:	d0e05317 	ldw	r3,-32436(gp)
8110e79c:	18c0300b 	ldhu	r3,192(r3)
8110e7a0:	20c7883a 	add	r3,r4,r3
8110e7a4:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110e7a8:	d0a05317 	ldw	r2,-32436(gp)
8110e7ac:	d0e05317 	ldw	r3,-32436(gp)
8110e7b0:	18c0310b 	ldhu	r3,196(r3)
8110e7b4:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110e7b8:	d0a05317 	ldw	r2,-32436(gp)
8110e7bc:	d0e05317 	ldw	r3,-32436(gp)
8110e7c0:	18c0300b 	ldhu	r3,192(r3)
8110e7c4:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110e7c8:	d0a05317 	ldw	r2,-32436(gp)
8110e7cc:	00e00004 	movi	r3,-32768
8110e7d0:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110e7d4:	d0a05317 	ldw	r2,-32436(gp)
8110e7d8:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8110e7dc:	d0a05317 	ldw	r2,-32436(gp)
8110e7e0:	10003685 	stb	zero,218(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucProtocolId = xDefaults.usiDataProtId; /* 0xF0 ou  0x02*/
8110e7e4:	d0e05317 	ldw	r3,-32436(gp)
8110e7e8:	00a045f4 	movhi	r2,33047
8110e7ec:	10a34f04 	addi	r2,r2,-29380
8110e7f0:	10800c0b 	ldhu	r2,48(r2)
8110e7f4:	18803705 	stb	r2,220(r3)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucLogicalAddr = xDefaults.usiDpuLogicalAddr;
8110e7f8:	d0e05317 	ldw	r3,-32436(gp)
8110e7fc:	00a045f4 	movhi	r2,33047
8110e800:	10a34f04 	addi	r2,r2,-29380
8110e804:	10800c8b 	ldhu	r2,50(r2)
8110e808:	18803745 	stb	r2,221(r3)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e80c:	d0a05317 	ldw	r2,-32436(gp)
8110e810:	10803304 	addi	r2,r2,204
8110e814:	1009883a 	mov	r4,r2
8110e818:	11049240 	call	81104924 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e81c:	d0a05317 	ldw	r2,-32436(gp)
8110e820:	10804504 	addi	r2,r2,276
8110e824:	1009883a 	mov	r4,r2
8110e828:	1109e400 	call	81109e40 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110e82c:	d0a05317 	ldw	r2,-32436(gp)
8110e830:	00ffc004 	movi	r3,-256
8110e834:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110e838:	d0a05317 	ldw	r2,-32436(gp)
8110e83c:	00ffc044 	movi	r3,-255
8110e840:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110e844:	d0a05317 	ldw	r2,-32436(gp)
8110e848:	00ffc084 	movi	r3,-254
8110e84c:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110e850:	d0a05317 	ldw	r2,-32436(gp)
8110e854:	00ffc0c4 	movi	r3,-253
8110e858:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110e85c:	d0a05317 	ldw	r2,-32436(gp)
8110e860:	00ffc104 	movi	r3,-252
8110e864:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110e868:	d0a05317 	ldw	r2,-32436(gp)
8110e86c:	00ffc144 	movi	r3,-251
8110e870:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110e874:	d0a05317 	ldw	r2,-32436(gp)
8110e878:	00ffc184 	movi	r3,-250
8110e87c:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110e880:	d0a05317 	ldw	r2,-32436(gp)
8110e884:	00ffc1c4 	movi	r3,-249
8110e888:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110e88c:	d0a05317 	ldw	r2,-32436(gp)
8110e890:	00ffc204 	movi	r3,-248
8110e894:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110e898:	d0a05317 	ldw	r2,-32436(gp)
8110e89c:	00ffc244 	movi	r3,-247
8110e8a0:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110e8a4:	d0a05317 	ldw	r2,-32436(gp)
8110e8a8:	00ffc284 	movi	r3,-246
8110e8ac:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110e8b0:	d0a05317 	ldw	r2,-32436(gp)
8110e8b4:	00ffc2c4 	movi	r3,-245
8110e8b8:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110e8bc:	d0a05317 	ldw	r2,-32436(gp)
8110e8c0:	00ffc304 	movi	r3,-244
8110e8c4:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110e8c8:	d0a05317 	ldw	r2,-32436(gp)
8110e8cc:	00ffc344 	movi	r3,-243
8110e8d0:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110e8d4:	d0a05317 	ldw	r2,-32436(gp)
8110e8d8:	00ffc384 	movi	r3,-242
8110e8dc:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110e8e0:	d0a05317 	ldw	r2,-32436(gp)
8110e8e4:	00ffc3c4 	movi	r3,-241
8110e8e8:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110e8ec:	d0a05317 	ldw	r2,-32436(gp)
8110e8f0:	00ffc404 	movi	r3,-240
8110e8f4:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110e8f8:	d0a05317 	ldw	r2,-32436(gp)
8110e8fc:	00ffc444 	movi	r3,-239
8110e900:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110e904:	d0a05317 	ldw	r2,-32436(gp)
8110e908:	00ffc484 	movi	r3,-238
8110e90c:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110e910:	d0a05317 	ldw	r2,-32436(gp)
8110e914:	00ffc4c4 	movi	r3,-237
8110e918:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110e91c:	d0a05317 	ldw	r2,-32436(gp)
8110e920:	00ffc504 	movi	r3,-236
8110e924:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110e928:	d0a05317 	ldw	r2,-32436(gp)
8110e92c:	00ffc544 	movi	r3,-235
8110e930:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110e934:	d0a05317 	ldw	r2,-32436(gp)
8110e938:	00ffc584 	movi	r3,-234
8110e93c:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110e940:	d0a05317 	ldw	r2,-32436(gp)
8110e944:	00ffc5c4 	movi	r3,-233
8110e948:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110e94c:	d0a05317 	ldw	r2,-32436(gp)
8110e950:	00ffc604 	movi	r3,-232
8110e954:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110e958:	d0a05317 	ldw	r2,-32436(gp)
8110e95c:	00ffc644 	movi	r3,-231
8110e960:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110e964:	d0a05317 	ldw	r2,-32436(gp)
8110e968:	00ffc684 	movi	r3,-230
8110e96c:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110e970:	d0a05317 	ldw	r2,-32436(gp)
8110e974:	00ffc6c4 	movi	r3,-229
8110e978:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110e97c:	d0a05317 	ldw	r2,-32436(gp)
8110e980:	00ffc704 	movi	r3,-228
8110e984:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110e988:	d0a05317 	ldw	r2,-32436(gp)
8110e98c:	00ffc744 	movi	r3,-227
8110e990:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110e994:	d0a05317 	ldw	r2,-32436(gp)
8110e998:	00ffc784 	movi	r3,-226
8110e99c:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110e9a0:	d0a05317 	ldw	r2,-32436(gp)
8110e9a4:	00ffc7c4 	movi	r3,-225
8110e9a8:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110e9ac:	d0a05317 	ldw	r2,-32436(gp)
8110e9b0:	00ffc804 	movi	r3,-224
8110e9b4:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110e9b8:	d0a05317 	ldw	r2,-32436(gp)
8110e9bc:	00ffc844 	movi	r3,-223
8110e9c0:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110e9c4:	d0a05317 	ldw	r2,-32436(gp)
8110e9c8:	00ffc884 	movi	r3,-222
8110e9cc:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110e9d0:	d0a05317 	ldw	r2,-32436(gp)
8110e9d4:	00ffc8c4 	movi	r3,-221
8110e9d8:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110e9dc:	d0a05317 	ldw	r2,-32436(gp)
8110e9e0:	00ffc904 	movi	r3,-220
8110e9e4:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110e9e8:	d0a05317 	ldw	r2,-32436(gp)
8110e9ec:	00ffc944 	movi	r3,-219
8110e9f0:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110e9f4:	d0a05317 	ldw	r2,-32436(gp)
8110e9f8:	00ffc984 	movi	r3,-218
8110e9fc:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110ea00:	d0a05317 	ldw	r2,-32436(gp)
8110ea04:	00ffc9c4 	movi	r3,-217
8110ea08:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110ea0c:	d0a05317 	ldw	r2,-32436(gp)
8110ea10:	00ffca04 	movi	r3,-216
8110ea14:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110ea18:	d0a05317 	ldw	r2,-32436(gp)
8110ea1c:	00ffca44 	movi	r3,-215
8110ea20:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110ea24:	d0a05317 	ldw	r2,-32436(gp)
8110ea28:	00ffca84 	movi	r3,-214
8110ea2c:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110ea30:	d0a05317 	ldw	r2,-32436(gp)
8110ea34:	00ffcac4 	movi	r3,-213
8110ea38:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110ea3c:	d0a05317 	ldw	r2,-32436(gp)
8110ea40:	00ffcb04 	movi	r3,-212
8110ea44:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110ea48:	d0a05317 	ldw	r2,-32436(gp)
8110ea4c:	00ffcb44 	movi	r3,-211
8110ea50:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110ea54:	d0a05317 	ldw	r2,-32436(gp)
8110ea58:	00ffcb84 	movi	r3,-210
8110ea5c:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110ea60:	d0a05317 	ldw	r2,-32436(gp)
8110ea64:	00ffcbc4 	movi	r3,-209
8110ea68:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110ea6c:	d0a05317 	ldw	r2,-32436(gp)
8110ea70:	00ffcc04 	movi	r3,-208
8110ea74:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110ea78:	d0a05317 	ldw	r2,-32436(gp)
8110ea7c:	00ffcc44 	movi	r3,-207
8110ea80:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110ea84:	d0a05317 	ldw	r2,-32436(gp)
8110ea88:	00ffcc84 	movi	r3,-206
8110ea8c:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110ea90:	d0a05317 	ldw	r2,-32436(gp)
8110ea94:	00ffccc4 	movi	r3,-205
8110ea98:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110ea9c:	d0a05317 	ldw	r2,-32436(gp)
8110eaa0:	00ffcd04 	movi	r3,-204
8110eaa4:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110eaa8:	d0a05317 	ldw	r2,-32436(gp)
8110eaac:	00ffcd44 	movi	r3,-203
8110eab0:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110eab4:	d0a05317 	ldw	r2,-32436(gp)
8110eab8:	00ffcd84 	movi	r3,-202
8110eabc:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110eac0:	d0a05317 	ldw	r2,-32436(gp)
8110eac4:	00ffcdc4 	movi	r3,-201
8110eac8:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110eacc:	d0a05317 	ldw	r2,-32436(gp)
8110ead0:	00ffce04 	movi	r3,-200
8110ead4:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110ead8:	d0a05317 	ldw	r2,-32436(gp)
8110eadc:	00ffce44 	movi	r3,-199
8110eae0:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110eae4:	d0a05317 	ldw	r2,-32436(gp)
8110eae8:	00ffce84 	movi	r3,-198
8110eaec:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110eaf0:	d0a05317 	ldw	r2,-32436(gp)
8110eaf4:	00ffcec4 	movi	r3,-197
8110eaf8:	10c0888d 	sth	r3,546(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110eafc:	d0a05317 	ldw	r2,-32436(gp)
8110eb00:	00ffcf04 	movi	r3,-196
8110eb04:	10c0890d 	sth	r3,548(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110eb08:	d0a05317 	ldw	r2,-32436(gp)
8110eb0c:	00ffcf44 	movi	r3,-195
8110eb10:	10c0898d 	sth	r3,550(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110eb14:	d0a05317 	ldw	r2,-32436(gp)
8110eb18:	00ffcf84 	movi	r3,-194
8110eb1c:	10c08a0d 	sth	r3,552(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110eb20:	d0a05317 	ldw	r2,-32436(gp)
8110eb24:	00ffcfc4 	movi	r3,-193
8110eb28:	10c08a8d 	sth	r3,554(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110eb2c:	d0a05317 	ldw	r2,-32436(gp)
8110eb30:	10804504 	addi	r2,r2,276
8110eb34:	1009883a 	mov	r4,r2
8110eb38:	1108d740 	call	81108d74 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110eb3c:	11129e80 	call	811129e8 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110eb40:	d0a05317 	ldw	r2,-32436(gp)
8110eb44:	10804504 	addi	r2,r2,276
8110eb48:	1009883a 	mov	r4,r2
8110eb4c:	1109e400 	call	81109e40 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110eb50:	d0a05317 	ldw	r2,-32436(gp)
8110eb54:	10806b04 	addi	r2,r2,428
8110eb58:	e0bffa15 	stw	r2,-24(fp)

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110eb5c:	00a045f4 	movhi	r2,33047
8110eb60:	10a34f04 	addi	r2,r2,-29380
8110eb64:	10800a8b 	ldhu	r2,42(r2)
8110eb68:	10bfffcc 	andi	r2,r2,65535
8110eb6c:	108000e8 	cmpgeui	r2,r2,3
8110eb70:	1000291e 	bne	r2,zero,8110ec18 <vFeeTask+0x620>
					fprintf(fp,"\n\n================= H  K ==================\n");
8110eb74:	d0a06217 	ldw	r2,-32376(gp)
8110eb78:	100f883a 	mov	r7,r2
8110eb7c:	01800b04 	movi	r6,44
8110eb80:	01400044 	movi	r5,1
8110eb84:	01204574 	movhi	r4,33045
8110eb88:	2139a804 	addi	r4,r4,-6496
8110eb8c:	1123cec0 	call	81123cec <fwrite>
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110eb90:	e03ffb05 	stb	zero,-20(fp)
8110eb94:	00001606 	br	8110ebf0 <vFeeTask+0x5f8>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110eb98:	d1206217 	ldw	r4,-32376(gp)
8110eb9c:	e0fffb03 	ldbu	r3,-20(fp)
8110eba0:	00a04574 	movhi	r2,33045
8110eba4:	1096ef04 	addi	r2,r2,23484
8110eba8:	18c7883a 	add	r3,r3,r3
8110ebac:	18c7883a 	add	r3,r3,r3
8110ebb0:	10c5883a 	add	r2,r2,r3
8110ebb4:	10c00017 	ldw	r3,0(r2)
8110ebb8:	e0bffa17 	ldw	r2,-24(fp)
8110ebbc:	1080000b 	ldhu	r2,0(r2)
8110ebc0:	10bfffcc 	andi	r2,r2,65535
8110ebc4:	100f883a 	mov	r7,r2
8110ebc8:	180d883a 	mov	r6,r3
8110ebcc:	01604574 	movhi	r5,33045
8110ebd0:	2979b404 	addi	r5,r5,-6448
8110ebd4:	11236500 	call	81123650 <fprintf>
						pusiHK++;
8110ebd8:	e0bffa17 	ldw	r2,-24(fp)
8110ebdc:	10800084 	addi	r2,r2,2
8110ebe0:	e0bffa15 	stw	r2,-24(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"\n\n================= H  K ==================\n");
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110ebe4:	e0bffb03 	ldbu	r2,-20(fp)
8110ebe8:	10800044 	addi	r2,r2,1
8110ebec:	e0bffb05 	stb	r2,-20(fp)
8110ebf0:	e0bffb03 	ldbu	r2,-20(fp)
8110ebf4:	10801030 	cmpltui	r2,r2,64
8110ebf8:	103fe71e 	bne	r2,zero,8110eb98 <__reset+0xfb0eeb98>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110ebfc:	d0a06217 	ldw	r2,-32376(gp)
8110ec00:	100f883a 	mov	r7,r2
8110ec04:	01800b04 	movi	r6,44
8110ec08:	01400044 	movi	r5,1
8110ec0c:	01204574 	movhi	r4,33045
8110ec10:	2139b904 	addi	r4,r4,-6428
8110ec14:	1123cec0 	call	81123cec <fwrite>
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110ec18:	d0a05317 	ldw	r2,-32436(gp)
8110ec1c:	10804504 	addi	r2,r2,276
8110ec20:	1009883a 	mov	r4,r2
8110ec24:	110838c0 	call	8110838c <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110ec28:	d0e05317 	ldw	r3,-32436(gp)
8110ec2c:	00a045f4 	movhi	r2,33047
8110ec30:	10a34f04 	addi	r2,r2,-29380
8110ec34:	1080080b 	ldhu	r2,32(r2)
8110ec38:	18804605 	stb	r2,280(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110ec3c:	d0e05317 	ldw	r3,-32436(gp)
8110ec40:	00a045f4 	movhi	r2,33047
8110ec44:	10a34f04 	addi	r2,r2,-29380
8110ec48:	1080088b 	ldhu	r2,34(r2)
8110ec4c:	18804645 	stb	r2,281(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110ec50:	d0a05317 	ldw	r2,-32436(gp)
8110ec54:	10804504 	addi	r2,r2,276
8110ec58:	1009883a 	mov	r4,r2
8110ec5c:	11082b00 	call	811082b0 <bRmapSetCodecConfig>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110ec60:	00a045f4 	movhi	r2,33047
8110ec64:	10a34f04 	addi	r2,r2,-29380
8110ec68:	10800a8b 	ldhu	r2,42(r2)
8110ec6c:	10bfffcc 	andi	r2,r2,65535
8110ec70:	108000e8 	cmpgeui	r2,r2,3
8110ec74:	10001c1e 	bne	r2,zero,8110ece8 <vFeeTask+0x6f0>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
8110ec78:	d0e06217 	ldw	r3,-32376(gp)
8110ec7c:	d0a05317 	ldw	r2,-32436(gp)
8110ec80:	10800003 	ldbu	r2,0(r2)
8110ec84:	11003fcc 	andi	r4,r2,255
8110ec88:	00a045f4 	movhi	r2,33047
8110ec8c:	10a34f04 	addi	r2,r2,-29380
8110ec90:	1080080b 	ldhu	r2,32(r2)
8110ec94:	10bfffcc 	andi	r2,r2,65535
8110ec98:	100f883a 	mov	r7,r2
8110ec9c:	200d883a 	mov	r6,r4
8110eca0:	01604574 	movhi	r5,33045
8110eca4:	2979c504 	addi	r5,r5,-6380
8110eca8:	1809883a 	mov	r4,r3
8110ecac:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
8110ecb0:	d0e06217 	ldw	r3,-32376(gp)
8110ecb4:	d0a05317 	ldw	r2,-32436(gp)
8110ecb8:	10800003 	ldbu	r2,0(r2)
8110ecbc:	11003fcc 	andi	r4,r2,255
8110ecc0:	00a045f4 	movhi	r2,33047
8110ecc4:	10a34f04 	addi	r2,r2,-29380
8110ecc8:	1080088b 	ldhu	r2,34(r2)
8110eccc:	10bfffcc 	andi	r2,r2,65535
8110ecd0:	100f883a 	mov	r7,r2
8110ecd4:	200d883a 	mov	r6,r4
8110ecd8:	01604574 	movhi	r5,33045
8110ecdc:	2979cd04 	addi	r5,r5,-6348
8110ece0:	1809883a 	mov	r4,r3
8110ece4:	11236500 	call	81123650 <fprintf>
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110ece8:	d0a05317 	ldw	r2,-32436(gp)
8110ecec:	00c00144 	movi	r3,5
8110ecf0:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110ecf4:	d0a05317 	ldw	r2,-32436(gp)
8110ecf8:	10802e17 	ldw	r2,184(r2)
8110ecfc:	d0a05605 	stb	r2,-32424(gp)

				break;
8110ed00:	00042a06 	br	8110fdac <vFeeTask+0x17b4>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ed04:	d0a05317 	ldw	r2,-32436(gp)
8110ed08:	10804504 	addi	r2,r2,276
8110ed0c:	1009883a 	mov	r4,r2
8110ed10:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110ed14:	d0a05317 	ldw	r2,-32436(gp)
8110ed18:	00c00184 	movi	r3,6
8110ed1c:	10c06815 	stw	r3,416(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ed20:	d0a05317 	ldw	r2,-32436(gp)
8110ed24:	10804504 	addi	r2,r2,276
8110ed28:	1009883a 	mov	r4,r2
8110ed2c:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110ed30:	d0a05317 	ldw	r2,-32436(gp)
8110ed34:	10808b04 	addi	r2,r2,556
8110ed38:	1009883a 	mov	r4,r2
8110ed3c:	11119880 	call	81111988 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110ed40:	d0a05317 	ldw	r2,-32436(gp)
8110ed44:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110ed48:	d0a05317 	ldw	r2,-32436(gp)
8110ed4c:	10c04504 	addi	r3,r2,276
8110ed50:	d0a05317 	ldw	r2,-32436(gp)
8110ed54:	10800043 	ldbu	r2,1(r2)
8110ed58:	10803fcc 	andi	r2,r2,255
8110ed5c:	100b883a 	mov	r5,r2
8110ed60:	1809883a 	mov	r4,r3
8110ed64:	11118dc0 	call	811118dc <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110ed68:	d0a05317 	ldw	r2,-32436(gp)
8110ed6c:	10803b04 	addi	r2,r2,236
8110ed70:	1009883a 	mov	r4,r2
8110ed74:	1111ae00 	call	81111ae0 <bDisAndClrDbBuffer>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110ed78:	00a045f4 	movhi	r2,33047
8110ed7c:	10a34f04 	addi	r2,r2,-29380
8110ed80:	10800a8b 	ldhu	r2,42(r2)
8110ed84:	10bfffcc 	andi	r2,r2,65535
8110ed88:	10800168 	cmpgeui	r2,r2,5
8110ed8c:	1000091e 	bne	r2,zero,8110edb4 <vFeeTask+0x7bc>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110ed90:	d0e06217 	ldw	r3,-32376(gp)
8110ed94:	d0a05317 	ldw	r2,-32436(gp)
8110ed98:	10800003 	ldbu	r2,0(r2)
8110ed9c:	10803fcc 	andi	r2,r2,255
8110eda0:	100d883a 	mov	r6,r2
8110eda4:	01604574 	movhi	r5,33045
8110eda8:	2979d604 	addi	r5,r5,-6312
8110edac:	1809883a 	mov	r4,r3
8110edb0:	11236500 	call	81123650 <fprintf>
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110edb4:	d0a05317 	ldw	r2,-32436(gp)
8110edb8:	10802217 	ldw	r2,136(r2)
8110edbc:	10800058 	cmpnei	r2,r2,1
8110edc0:	10000a1e 	bne	r2,zero,8110edec <vFeeTask+0x7f4>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110edc4:	e0fff403 	ldbu	r3,-48(fp)
8110edc8:	00a045b4 	movhi	r2,33046
8110edcc:	10969304 	addi	r2,r2,23116
8110edd0:	180690fa 	slli	r3,r3,3
8110edd4:	10c5883a 	add	r2,r2,r3
8110edd8:	10800017 	ldw	r2,0(r2)
8110eddc:	1009883a 	mov	r4,r2
8110ede0:	113f0a40 	call	8113f0a4 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110ede4:	d0a05317 	ldw	r2,-32436(gp)
8110ede8:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110edec:	d0a05317 	ldw	r2,-32436(gp)
8110edf0:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110edf4:	d0a05317 	ldw	r2,-32436(gp)
8110edf8:	10800003 	ldbu	r2,0(r2)
8110edfc:	10803fcc 	andi	r2,r2,255
8110ee00:	1085883a 	add	r2,r2,r2
8110ee04:	1087883a 	add	r3,r2,r2
8110ee08:	d0a05c04 	addi	r2,gp,-32400
8110ee0c:	1885883a 	add	r2,r3,r2
8110ee10:	10800017 	ldw	r2,0(r2)
8110ee14:	1009883a 	mov	r4,r2
8110ee18:	113fb540 	call	8113fb54 <OSQFlush>
8110ee1c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110ee20:	e0bffd03 	ldbu	r2,-12(fp)
8110ee24:	10803fcc 	andi	r2,r2,255
8110ee28:	10000126 	beq	r2,zero,8110ee30 <vFeeTask+0x838>
					vFailFlushNFEEQueue();
8110ee2c:	111f83c0 	call	8111f83c <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ee30:	d0a05317 	ldw	r2,-32436(gp)
8110ee34:	10800003 	ldbu	r2,0(r2)
8110ee38:	10803fcc 	andi	r2,r2,255
8110ee3c:	100d883a 	mov	r6,r2
8110ee40:	000b883a 	mov	r5,zero
8110ee44:	01002044 	movi	r4,129
8110ee48:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110ee4c:	d0a05317 	ldw	r2,-32436(gp)
8110ee50:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110ee54:	d0a05317 	ldw	r2,-32436(gp)
8110ee58:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110ee5c:	d0a05317 	ldw	r2,-32436(gp)
8110ee60:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ee64:	d0a05317 	ldw	r2,-32436(gp)
8110ee68:	00c00044 	movi	r3,1
8110ee6c:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110ee70:	d0a05317 	ldw	r2,-32436(gp)
8110ee74:	1009883a 	mov	r4,r2
8110ee78:	111ff3c0 	call	8111ff3c <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110ee7c:	d0a05317 	ldw	r2,-32436(gp)
8110ee80:	10800003 	ldbu	r2,0(r2)
8110ee84:	10803fcc 	andi	r2,r2,255
8110ee88:	1085883a 	add	r2,r2,r2
8110ee8c:	1087883a 	add	r3,r2,r2
8110ee90:	d0a06a04 	addi	r2,gp,-32344
8110ee94:	1885883a 	add	r2,r3,r2
8110ee98:	10800017 	ldw	r2,0(r2)
8110ee9c:	1009883a 	mov	r4,r2
8110eea0:	113fb540 	call	8113fb54 <OSQFlush>
8110eea4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110eea8:	e0bffd03 	ldbu	r2,-12(fp)
8110eeac:	10803fcc 	andi	r2,r2,255
8110eeb0:	10000126 	beq	r2,zero,8110eeb8 <vFeeTask+0x8c0>
					vFailFlushNFEEQueue();
8110eeb4:	111f83c0 	call	8111f83c <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110eeb8:	d0a05317 	ldw	r2,-32436(gp)
8110eebc:	00c00044 	movi	r3,1
8110eec0:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110eec4:	d0a05317 	ldw	r2,-32436(gp)
8110eec8:	00c00044 	movi	r3,1
8110eecc:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110eed0:	d0a05317 	ldw	r2,-32436(gp)
8110eed4:	10802e17 	ldw	r2,184(r2)
8110eed8:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110eedc:	e03ff915 	stw	zero,-28(fp)
				break;
8110eee0:	0003b206 	br	8110fdac <vFeeTask+0x17b4>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110eee4:	d0a05317 	ldw	r2,-32436(gp)
8110eee8:	10800003 	ldbu	r2,0(r2)
8110eeec:	10803fcc 	andi	r2,r2,255
8110eef0:	1085883a 	add	r2,r2,r2
8110eef4:	1087883a 	add	r3,r2,r2
8110eef8:	d0a06a04 	addi	r2,gp,-32344
8110eefc:	1885883a 	add	r2,r3,r2
8110ef00:	10800017 	ldw	r2,0(r2)
8110ef04:	e0fffd04 	addi	r3,fp,-12
8110ef08:	180d883a 	mov	r6,r3
8110ef0c:	000b883a 	mov	r5,zero
8110ef10:	1009883a 	mov	r4,r2
8110ef14:	113fc140 	call	8113fc14 <OSQPend>
8110ef18:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ef1c:	e0bffd03 	ldbu	r2,-12(fp)
8110ef20:	10803fcc 	andi	r2,r2,255
8110ef24:	1000061e 	bne	r2,zero,8110ef40 <vFeeTask+0x948>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110ef28:	d0a05317 	ldw	r2,-32436(gp)
8110ef2c:	e0fffe17 	ldw	r3,-8(fp)
8110ef30:	180b883a 	mov	r5,r3
8110ef34:	1009883a 	mov	r4,r2
8110ef38:	110ffc80 	call	8110ffc8 <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110ef3c:	00039006 	br	8110fd80 <vFeeTask+0x1788>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ef40:	00a045f4 	movhi	r2,33047
8110ef44:	10a34f04 	addi	r2,r2,-29380
8110ef48:	10800a8b 	ldhu	r2,42(r2)
8110ef4c:	10bfffcc 	andi	r2,r2,65535
8110ef50:	10800228 	cmpgeui	r2,r2,8
8110ef54:	10038a1e 	bne	r2,zero,8110fd80 <vFeeTask+0x1788>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ef58:	d0e06217 	ldw	r3,-32376(gp)
8110ef5c:	d0a05317 	ldw	r2,-32436(gp)
8110ef60:	10800003 	ldbu	r2,0(r2)
8110ef64:	10803fcc 	andi	r2,r2,255
8110ef68:	100d883a 	mov	r6,r2
8110ef6c:	01604574 	movhi	r5,33045
8110ef70:	2979dd04 	addi	r5,r5,-6284
8110ef74:	1809883a 	mov	r4,r3
8110ef78:	11236500 	call	81123650 <fprintf>
					}
					#endif
				}

				break;
8110ef7c:	00038006 	br	8110fd80 <vFeeTask+0x1788>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110ef80:	d0a05317 	ldw	r2,-32436(gp)
8110ef84:	00c00184 	movi	r3,6
8110ef88:	10c02c15 	stw	r3,176(r2)
				break;
8110ef8c:	00038706 	br	8110fdac <vFeeTask+0x17b4>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ef90:	d0a05317 	ldw	r2,-32436(gp)
8110ef94:	10804504 	addi	r2,r2,276
8110ef98:	1009883a 	mov	r4,r2
8110ef9c:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110efa0:	d0a05317 	ldw	r2,-32436(gp)
8110efa4:	10006815 	stw	zero,416(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110efa8:	d0a05317 	ldw	r2,-32436(gp)
8110efac:	10804504 	addi	r2,r2,276
8110efb0:	1009883a 	mov	r4,r2
8110efb4:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110efb8:	d0a05317 	ldw	r2,-32436(gp)
8110efbc:	10803b04 	addi	r2,r2,236
8110efc0:	1009883a 	mov	r4,r2
8110efc4:	1111ae00 	call	81111ae0 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110efc8:	d0a05317 	ldw	r2,-32436(gp)
8110efcc:	10c04504 	addi	r3,r2,276
8110efd0:	d0a05317 	ldw	r2,-32436(gp)
8110efd4:	10800003 	ldbu	r2,0(r2)
8110efd8:	10803fcc 	andi	r2,r2,255
8110efdc:	100b883a 	mov	r5,r2
8110efe0:	1809883a 	mov	r4,r3
8110efe4:	11119300 	call	81111930 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110efe8:	d0a05317 	ldw	r2,-32436(gp)
8110efec:	10808b04 	addi	r2,r2,556
8110eff0:	1009883a 	mov	r4,r2
8110eff4:	11119e80 	call	811119e8 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110eff8:	d0a05317 	ldw	r2,-32436(gp)
8110effc:	00c00044 	movi	r3,1
8110f000:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110f004:	d0a05317 	ldw	r2,-32436(gp)
8110f008:	00c00044 	movi	r3,1
8110f00c:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110f010:	d0a05317 	ldw	r2,-32436(gp)
8110f014:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110f018:	d0a05317 	ldw	r2,-32436(gp)
8110f01c:	00c00044 	movi	r3,1
8110f020:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110f024:	d0a05317 	ldw	r2,-32436(gp)
8110f028:	10800003 	ldbu	r2,0(r2)
8110f02c:	10803fcc 	andi	r2,r2,255
8110f030:	100d883a 	mov	r6,r2
8110f034:	000b883a 	mov	r5,zero
8110f038:	01002044 	movi	r4,129
8110f03c:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110f040:	d0a05317 	ldw	r2,-32436(gp)
8110f044:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110f048:	d0a05317 	ldw	r2,-32436(gp)
8110f04c:	10800003 	ldbu	r2,0(r2)
8110f050:	10803fcc 	andi	r2,r2,255
8110f054:	1085883a 	add	r2,r2,r2
8110f058:	1087883a 	add	r3,r2,r2
8110f05c:	d0a05c04 	addi	r2,gp,-32400
8110f060:	1885883a 	add	r2,r3,r2
8110f064:	10800017 	ldw	r2,0(r2)
8110f068:	1009883a 	mov	r4,r2
8110f06c:	113fb540 	call	8113fb54 <OSQFlush>
8110f070:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110f074:	e0bffd03 	ldbu	r2,-12(fp)
8110f078:	10803fcc 	andi	r2,r2,255
8110f07c:	10000126 	beq	r2,zero,8110f084 <vFeeTask+0xa8c>
					vFailFlushNFEEQueue();
8110f080:	111f83c0 	call	8111f83c <vFailFlushNFEEQueue>
				}

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f084:	00a045f4 	movhi	r2,33047
8110f088:	10a34f04 	addi	r2,r2,-29380
8110f08c:	10800a8b 	ldhu	r2,42(r2)
8110f090:	10bfffcc 	andi	r2,r2,65535
8110f094:	10800168 	cmpgeui	r2,r2,5
8110f098:	1000091e 	bne	r2,zero,8110f0c0 <vFeeTask+0xac8>
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
8110f09c:	d0e06217 	ldw	r3,-32376(gp)
8110f0a0:	d0a05317 	ldw	r2,-32436(gp)
8110f0a4:	10800003 	ldbu	r2,0(r2)
8110f0a8:	10803fcc 	andi	r2,r2,255
8110f0ac:	100d883a 	mov	r6,r2
8110f0b0:	01604574 	movhi	r5,33045
8110f0b4:	2979e904 	addi	r5,r5,-6236
8110f0b8:	1809883a 	mov	r4,r3
8110f0bc:	11236500 	call	81123650 <fprintf>
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110f0c0:	d0a05317 	ldw	r2,-32436(gp)
8110f0c4:	1009883a 	mov	r4,r2
8110f0c8:	111ff3c0 	call	8111ff3c <vResetMemCCDFEE>

				incrementador = 0;
8110f0cc:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110f0d0:	d0a05317 	ldw	r2,-32436(gp)
8110f0d4:	00c00044 	movi	r3,1
8110f0d8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110f0dc:	d0a05317 	ldw	r2,-32436(gp)
8110f0e0:	00c000c4 	movi	r3,3
8110f0e4:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110f0e8:	d0a05317 	ldw	r2,-32436(gp)
8110f0ec:	10802e17 	ldw	r2,184(r2)
8110f0f0:	d0a05605 	stb	r2,-32424(gp)
				break;
8110f0f4:	00032d06 	br	8110fdac <vFeeTask+0x17b4>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f0f8:	d0a05317 	ldw	r2,-32436(gp)
8110f0fc:	10800003 	ldbu	r2,0(r2)
8110f100:	10803fcc 	andi	r2,r2,255
8110f104:	1085883a 	add	r2,r2,r2
8110f108:	1087883a 	add	r3,r2,r2
8110f10c:	d0a06a04 	addi	r2,gp,-32344
8110f110:	1885883a 	add	r2,r3,r2
8110f114:	10800017 	ldw	r2,0(r2)
8110f118:	e0fffd04 	addi	r3,fp,-12
8110f11c:	180d883a 	mov	r6,r3
8110f120:	000b883a 	mov	r5,zero
8110f124:	1009883a 	mov	r4,r2
8110f128:	113fc140 	call	8113fc14 <OSQPend>
8110f12c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110f130:	e0bffd03 	ldbu	r2,-12(fp)
8110f134:	10803fcc 	andi	r2,r2,255
8110f138:	1000061e 	bne	r2,zero,8110f154 <vFeeTask+0xb5c>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110f13c:	d0a05317 	ldw	r2,-32436(gp)
8110f140:	e0fffe17 	ldw	r3,-8(fp)
8110f144:	180b883a 	mov	r5,r3
8110f148:	1009883a 	mov	r4,r2
8110f14c:	111020c0 	call	8111020c <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f150:	00030d06 	br	8110fd88 <vFeeTask+0x1790>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f154:	00a045f4 	movhi	r2,33047
8110f158:	10a34f04 	addi	r2,r2,-29380
8110f15c:	10800a8b 	ldhu	r2,42(r2)
8110f160:	10bfffcc 	andi	r2,r2,65535
8110f164:	10800228 	cmpgeui	r2,r2,8
8110f168:	1003071e 	bne	r2,zero,8110fd88 <vFeeTask+0x1790>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f16c:	d0e06217 	ldw	r3,-32376(gp)
8110f170:	d0a05317 	ldw	r2,-32436(gp)
8110f174:	10800003 	ldbu	r2,0(r2)
8110f178:	10803fcc 	andi	r2,r2,255
8110f17c:	100d883a 	mov	r6,r2
8110f180:	01604574 	movhi	r5,33045
8110f184:	2979dd04 	addi	r5,r5,-6284
8110f188:	1809883a 	mov	r4,r3
8110f18c:	11236500 	call	81123650 <fprintf>
					}
					#endif
				}

				break;
8110f190:	0002fd06 	br	8110fd88 <vFeeTask+0x1790>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110f194:	d0a05317 	ldw	r2,-32436(gp)
8110f198:	10800003 	ldbu	r2,0(r2)
8110f19c:	10803fcc 	andi	r2,r2,255
8110f1a0:	1085883a 	add	r2,r2,r2
8110f1a4:	1087883a 	add	r3,r2,r2
8110f1a8:	d0a05c04 	addi	r2,gp,-32400
8110f1ac:	1885883a 	add	r2,r3,r2
8110f1b0:	10800017 	ldw	r2,0(r2)
8110f1b4:	1009883a 	mov	r4,r2
8110f1b8:	113fb540 	call	8113fb54 <OSQFlush>
8110f1bc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110f1c0:	e0bffd03 	ldbu	r2,-12(fp)
8110f1c4:	10803fcc 	andi	r2,r2,255
8110f1c8:	10000126 	beq	r2,zero,8110f1d0 <vFeeTask+0xbd8>
					vFailFlushNFEEQueue();
8110f1cc:	111f83c0 	call	8111f83c <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110f1d0:	d0a05317 	ldw	r2,-32436(gp)
8110f1d4:	00c00044 	movi	r3,1
8110f1d8:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110f1dc:	d0a05317 	ldw	r2,-32436(gp)
8110f1e0:	00c00044 	movi	r3,1
8110f1e4:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110f1e8:	d0a05317 	ldw	r2,-32436(gp)
8110f1ec:	1009883a 	mov	r4,r2
8110f1f0:	111ff3c0 	call	8111ff3c <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				if (xDefaults.usiLinkNFEE0 == 0) {
8110f1f4:	00a045f4 	movhi	r2,33047
8110f1f8:	10a34f04 	addi	r2,r2,-29380
8110f1fc:	10800a0b 	ldhu	r2,40(r2)
8110f200:	10bfffcc 	andi	r2,r2,65535
8110f204:	1000081e 	bne	r2,zero,8110f228 <vFeeTask+0xc30>
					while ( (bFeebGetCh1LeftFeeBusy()== TRUE) || (bFeebGetCh1RightFeeBusy()== TRUE)  ) {}
8110f208:	0001883a 	nop
8110f20c:	1106c9c0 	call	81106c9c <bFeebGetCh1LeftFeeBusy>
8110f210:	10800060 	cmpeqi	r2,r2,1
8110f214:	103ffd1e 	bne	r2,zero,8110f20c <__reset+0xfb0ef20c>
8110f218:	1106d040 	call	81106d04 <bFeebGetCh1RightFeeBusy>
8110f21c:	10800060 	cmpeqi	r2,r2,1
8110f220:	103ffa1e 	bne	r2,zero,8110f20c <__reset+0xfb0ef20c>
8110f224:	00000706 	br	8110f244 <vFeeTask+0xc4c>
				} else {
					while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
8110f228:	0001883a 	nop
8110f22c:	1106d6c0 	call	81106d6c <bFeebGetCh2LeftFeeBusy>
8110f230:	10800060 	cmpeqi	r2,r2,1
8110f234:	103ffd1e 	bne	r2,zero,8110f22c <__reset+0xfb0ef22c>
8110f238:	1106dd40 	call	81106dd4 <bFeebGetCh2RightFeeBusy>
8110f23c:	10800060 	cmpeqi	r2,r2,1
8110f240:	103ffa1e 	bne	r2,zero,8110f22c <__reset+0xfb0ef22c>
				}

				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
8110f244:	00a045f4 	movhi	r2,33047
8110f248:	10a34f04 	addi	r2,r2,-29380
8110f24c:	10800b8b 	ldhu	r2,46(r2)
8110f250:	10bfffcc 	andi	r2,r2,65535
8110f254:	100f883a 	mov	r7,r2
8110f258:	000d883a 	mov	r6,zero
8110f25c:	000b883a 	mov	r5,zero
8110f260:	0009883a 	mov	r4,zero
8110f264:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110f268:	00a045f4 	movhi	r2,33047
8110f26c:	10a34f04 	addi	r2,r2,-29380
8110f270:	10800a0b 	ldhu	r2,40(r2)
8110f274:	10bfffcc 	andi	r2,r2,65535
8110f278:	1000071e 	bne	r2,zero,8110f298 <vFeeTask+0xca0>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110f27c:	000b883a 	mov	r5,zero
8110f280:	01000404 	movi	r4,16
8110f284:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110f288:	01400044 	movi	r5,1
8110f28c:	01000404 	movi	r4,16
8110f290:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
8110f294:	00000606 	br	8110f2b0 <vFeeTask+0xcb8>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110f298:	000b883a 	mov	r5,zero
8110f29c:	01000404 	movi	r4,16
8110f2a0:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110f2a4:	01400044 	movi	r5,1
8110f2a8:	01000404 	movi	r4,16
8110f2ac:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
				}

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110f2b0:	d0a05317 	ldw	r2,-32436(gp)
8110f2b4:	10803b04 	addi	r2,r2,236
8110f2b8:	1009883a 	mov	r4,r2
8110f2bc:	1111a480 	call	81111a48 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110f2c0:	d0a05317 	ldw	r2,-32436(gp)
8110f2c4:	10808b04 	addi	r2,r2,556
8110f2c8:	1009883a 	mov	r4,r2
8110f2cc:	110af040 	call	8110af04 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110f2d0:	d0a05317 	ldw	r2,-32436(gp)
8110f2d4:	10809743 	ldbu	r2,605(r2)
8110f2d8:	10803fcc 	andi	r2,r2,255
8110f2dc:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110f2e0:	d0a05517 	ldw	r2,-32428(gp)
8110f2e4:	10800044 	addi	r2,r2,1
8110f2e8:	108000cc 	andi	r2,r2,3
8110f2ec:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110f2f0:	e0bffc17 	ldw	r2,-16(fp)
8110f2f4:	10000e1e 	bne	r2,zero,8110f330 <vFeeTask+0xd38>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110f2f8:	d0a05317 	ldw	r2,-32436(gp)
8110f2fc:	10802917 	ldw	r2,164(r2)
8110f300:	10800003 	ldbu	r2,0(r2)
8110f304:	10803fcc 	andi	r2,r2,255
8110f308:	10c00044 	addi	r3,r2,1
8110f30c:	00a00034 	movhi	r2,32768
8110f310:	10800044 	addi	r2,r2,1
8110f314:	1884703a 	and	r2,r3,r2
8110f318:	1000040e 	bge	r2,zero,8110f32c <vFeeTask+0xd34>
8110f31c:	10bfffc4 	addi	r2,r2,-1
8110f320:	00ffff84 	movi	r3,-2
8110f324:	10c4b03a 	or	r2,r2,r3
8110f328:	10800044 	addi	r2,r2,1
8110f32c:	e0bff405 	stb	r2,-48(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110f330:	d0e05317 	ldw	r3,-32436(gp)
8110f334:	e0bffc17 	ldw	r2,-16(fp)
8110f338:	1885883a 	add	r2,r3,r2
8110f33c:	10802a44 	addi	r2,r2,169
8110f340:	10800003 	ldbu	r2,0(r2)
8110f344:	e0bff605 	stb	r2,-40(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110f348:	d0a05317 	ldw	r2,-32436(gp)
8110f34c:	10802e17 	ldw	r2,184(r2)
8110f350:	1000071e 	bne	r2,zero,8110f370 <vFeeTask+0xd78>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110f354:	d0e05317 	ldw	r3,-32436(gp)
8110f358:	e0bff603 	ldbu	r2,-40(fp)
8110f35c:	10800624 	muli	r2,r2,24
8110f360:	10800904 	addi	r2,r2,36
8110f364:	1885883a 	add	r2,r3,r2
8110f368:	e0bff515 	stw	r2,-44(fp)
8110f36c:	00000606 	br	8110f388 <vFeeTask+0xd90>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110f370:	d0e05317 	ldw	r3,-32436(gp)
8110f374:	e0bff603 	ldbu	r2,-40(fp)
8110f378:	10800624 	muli	r2,r2,24
8110f37c:	10800c04 	addi	r2,r2,48
8110f380:	1885883a 	add	r2,r3,r2
8110f384:	e0bff515 	stw	r2,-44(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110f388:	d0a05317 	ldw	r2,-32436(gp)
8110f38c:	10802e17 	ldw	r2,184(r2)
8110f390:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f394:	d0a05317 	ldw	r2,-32436(gp)
8110f398:	10803304 	addi	r2,r2,204
8110f39c:	1009883a 	mov	r4,r2
8110f3a0:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110f3a4:	d0a05317 	ldw	r2,-32436(gp)
8110f3a8:	e0fff603 	ldbu	r3,-40(fp)
8110f3ac:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
8110f3b0:	d0a05317 	ldw	r2,-32436(gp)
8110f3b4:	00c00244 	movi	r3,9
8110f3b8:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f3bc:	d0a05317 	ldw	r2,-32436(gp)
8110f3c0:	10803304 	addi	r2,r2,204
8110f3c4:	1009883a 	mov	r4,r2
8110f3c8:	11049240 	call	81104924 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f3cc:	d0a05317 	ldw	r2,-32436(gp)
8110f3d0:	10803304 	addi	r2,r2,204
8110f3d4:	1009883a 	mov	r4,r2
8110f3d8:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110f3dc:	00a045f4 	movhi	r2,33047
8110f3e0:	10a34f04 	addi	r2,r2,-29380
8110f3e4:	10800a8b 	ldhu	r2,42(r2)
8110f3e8:	10bfffcc 	andi	r2,r2,65535
8110f3ec:	108000e8 	cmpgeui	r2,r2,3
8110f3f0:	10004d1e 	bne	r2,zero,8110f528 <vFeeTask+0xf30>
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110f3f4:	d0a06217 	ldw	r2,-32376(gp)
8110f3f8:	100f883a 	mov	r7,r2
8110f3fc:	01800904 	movi	r6,36
8110f400:	01400044 	movi	r5,1
8110f404:	01204574 	movhi	r4,33045
8110f408:	2139ef04 	addi	r4,r4,-6212
8110f40c:	1123cec0 	call	81123cec <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110f410:	d0e06217 	ldw	r3,-32376(gp)
8110f414:	d0a05317 	ldw	r2,-32436(gp)
8110f418:	1080340b 	ldhu	r2,208(r2)
8110f41c:	10bfffcc 	andi	r2,r2,65535
8110f420:	100d883a 	mov	r6,r2
8110f424:	01604574 	movhi	r5,33045
8110f428:	2979f904 	addi	r5,r5,-6172
8110f42c:	1809883a 	mov	r4,r3
8110f430:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110f434:	d0e06217 	ldw	r3,-32376(gp)
8110f438:	d0a05317 	ldw	r2,-32436(gp)
8110f43c:	1080348b 	ldhu	r2,210(r2)
8110f440:	10bfffcc 	andi	r2,r2,65535
8110f444:	100d883a 	mov	r6,r2
8110f448:	01604574 	movhi	r5,33045
8110f44c:	2979fe04 	addi	r5,r5,-6152
8110f450:	1809883a 	mov	r4,r3
8110f454:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110f458:	d0e06217 	ldw	r3,-32376(gp)
8110f45c:	d0a05317 	ldw	r2,-32436(gp)
8110f460:	1080350b 	ldhu	r2,212(r2)
8110f464:	10bfffcc 	andi	r2,r2,65535
8110f468:	100d883a 	mov	r6,r2
8110f46c:	01604574 	movhi	r5,33045
8110f470:	297a0304 	addi	r5,r5,-6132
8110f474:	1809883a 	mov	r4,r3
8110f478:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110f47c:	d0e06217 	ldw	r3,-32376(gp)
8110f480:	d0a05317 	ldw	r2,-32436(gp)
8110f484:	1080358b 	ldhu	r2,214(r2)
8110f488:	10bfffcc 	andi	r2,r2,65535
8110f48c:	100d883a 	mov	r6,r2
8110f490:	01604574 	movhi	r5,33045
8110f494:	297a0804 	addi	r5,r5,-6112
8110f498:	1809883a 	mov	r4,r3
8110f49c:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110f4a0:	d0e06217 	ldw	r3,-32376(gp)
8110f4a4:	d0a05317 	ldw	r2,-32436(gp)
8110f4a8:	1080360b 	ldhu	r2,216(r2)
8110f4ac:	10bfffcc 	andi	r2,r2,65535
8110f4b0:	100d883a 	mov	r6,r2
8110f4b4:	01604574 	movhi	r5,33045
8110f4b8:	297a0e04 	addi	r5,r5,-6088
8110f4bc:	1809883a 	mov	r4,r3
8110f4c0:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110f4c4:	d0e06217 	ldw	r3,-32376(gp)
8110f4c8:	d0a05317 	ldw	r2,-32436(gp)
8110f4cc:	108036c3 	ldbu	r2,219(r2)
8110f4d0:	10803fcc 	andi	r2,r2,255
8110f4d4:	100d883a 	mov	r6,r2
8110f4d8:	01604574 	movhi	r5,33045
8110f4dc:	297a1404 	addi	r5,r5,-6064
8110f4e0:	1809883a 	mov	r4,r3
8110f4e4:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110f4e8:	d0e06217 	ldw	r3,-32376(gp)
8110f4ec:	d0a05317 	ldw	r2,-32436(gp)
8110f4f0:	10803683 	ldbu	r2,218(r2)
8110f4f4:	10803fcc 	andi	r2,r2,255
8110f4f8:	100d883a 	mov	r6,r2
8110f4fc:	01604574 	movhi	r5,33045
8110f500:	297a1904 	addi	r5,r5,-6044
8110f504:	1809883a 	mov	r4,r3
8110f508:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110f50c:	d0a06217 	ldw	r2,-32376(gp)
8110f510:	100f883a 	mov	r7,r2
8110f514:	01800884 	movi	r6,34
8110f518:	01400044 	movi	r5,1
8110f51c:	01204574 	movhi	r4,33045
8110f520:	213a1d04 	addi	r4,r4,-6028
8110f524:	1123cec0 	call	81123cec <fwrite>
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110f528:	d0a05317 	ldw	r2,-32436(gp)
8110f52c:	10800003 	ldbu	r2,0(r2)
8110f530:	10803fcc 	andi	r2,r2,255
8110f534:	100d883a 	mov	r6,r2
8110f538:	000b883a 	mov	r5,zero
8110f53c:	01002004 	movi	r4,128
8110f540:	1111b4c0 	call	81111b4c <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110f544:	e03ff815 	stw	zero,-32(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f548:	d0a05317 	ldw	r2,-32436(gp)
8110f54c:	10800003 	ldbu	r2,0(r2)
8110f550:	10803fcc 	andi	r2,r2,255
8110f554:	1085883a 	add	r2,r2,r2
8110f558:	1087883a 	add	r3,r2,r2
8110f55c:	d0a06a04 	addi	r2,gp,-32344
8110f560:	1885883a 	add	r2,r3,r2
8110f564:	10800017 	ldw	r2,0(r2)
8110f568:	e0fffd04 	addi	r3,fp,-12
8110f56c:	180d883a 	mov	r6,r3
8110f570:	000b883a 	mov	r5,zero
8110f574:	1009883a 	mov	r4,r2
8110f578:	113fc140 	call	8113fc14 <OSQPend>
8110f57c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110f580:	e0bffd03 	ldbu	r2,-12(fp)
8110f584:	10803fcc 	andi	r2,r2,255
8110f588:	10005e1e 	bne	r2,zero,8110f704 <vFeeTask+0x110c>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110f58c:	e0bffe83 	ldbu	r2,-6(fp)
8110f590:	10803fcc 	andi	r2,r2,255
8110f594:	108023d8 	cmpnei	r2,r2,143
8110f598:	1000541e 	bne	r2,zero,8110f6ec <vFeeTask+0x10f4>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110f59c:	e0fff403 	ldbu	r3,-48(fp)
8110f5a0:	00a045b4 	movhi	r2,33046
8110f5a4:	10969304 	addi	r2,r2,23116
8110f5a8:	180690fa 	slli	r3,r3,3
8110f5ac:	10c5883a 	add	r2,r2,r3
8110f5b0:	10800017 	ldw	r2,0(r2)
8110f5b4:	e0fffd04 	addi	r3,fp,-12
8110f5b8:	180d883a 	mov	r6,r3
8110f5bc:	000b883a 	mov	r5,zero
8110f5c0:	1009883a 	mov	r4,r2
8110f5c4:	113eb000 	call	8113eb00 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110f5c8:	e0bffd03 	ldbu	r2,-12(fp)
8110f5cc:	10803fcc 	andi	r2,r2,255
8110f5d0:	1000181e 	bne	r2,zero,8110f634 <vFeeTask+0x103c>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110f5d4:	d0a05317 	ldw	r2,-32436(gp)
8110f5d8:	00c00044 	movi	r3,1
8110f5dc:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110f5e0:	e0fff403 	ldbu	r3,-48(fp)
8110f5e4:	d0a05317 	ldw	r2,-32436(gp)
8110f5e8:	10800003 	ldbu	r2,0(r2)
8110f5ec:	10803fcc 	andi	r2,r2,255
8110f5f0:	d1205317 	ldw	r4,-32436(gp)
8110f5f4:	200f883a 	mov	r7,r4
8110f5f8:	100d883a 	mov	r6,r2
8110f5fc:	180b883a 	mov	r5,r3
8110f600:	e13ff517 	ldw	r4,-44(fp)
8110f604:	11125fc0 	call	811125fc <bPrepareDoubleBuffer>
8110f608:	e0bff815 	stw	r2,-32(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110f60c:	e0fff403 	ldbu	r3,-48(fp)
8110f610:	00a045b4 	movhi	r2,33046
8110f614:	10969304 	addi	r2,r2,23116
8110f618:	180690fa 	slli	r3,r3,3
8110f61c:	10c5883a 	add	r2,r2,r3
8110f620:	10800017 	ldw	r2,0(r2)
8110f624:	1009883a 	mov	r4,r2
8110f628:	113f0a40 	call	8113f0a4 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110f62c:	d0a05317 	ldw	r2,-32436(gp)
8110f630:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110f634:	d0a05317 	ldw	r2,-32436(gp)
8110f638:	10800003 	ldbu	r2,0(r2)
8110f63c:	10803fcc 	andi	r2,r2,255
8110f640:	100d883a 	mov	r6,r2
8110f644:	000b883a 	mov	r5,zero
8110f648:	01002044 	movi	r4,129
8110f64c:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110f650:	e0bff817 	ldw	r2,-32(fp)
8110f654:	10800058 	cmpnei	r2,r2,1
8110f658:	1000141e 	bne	r2,zero,8110f6ac <vFeeTask+0x10b4>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110f65c:	d0a05317 	ldw	r2,-32436(gp)
8110f660:	10802817 	ldw	r2,160(r2)
8110f664:	10800058 	cmpnei	r2,r2,1
8110f668:	1000071e 	bne	r2,zero,8110f688 <vFeeTask+0x1090>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110f66c:	d0a05317 	ldw	r2,-32436(gp)
8110f670:	00c001c4 	movi	r3,7
8110f674:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110f678:	d0a05317 	ldw	r2,-32436(gp)
8110f67c:	00c00304 	movi	r3,12
8110f680:	10c02c15 	stw	r3,176(r2)
8110f684:	00000606 	br	8110f6a0 <vFeeTask+0x10a8>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110f688:	d0a05317 	ldw	r2,-32436(gp)
8110f68c:	00c001c4 	movi	r3,7
8110f690:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110f694:	d0a05317 	ldw	r2,-32436(gp)
8110f698:	00c001c4 	movi	r3,7
8110f69c:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110f6a0:	d0a05417 	ldw	r2,-32432(gp)
8110f6a4:	10800044 	addi	r2,r2,1
8110f6a8:	d0a05415 	stw	r2,-32432(gp)
						}

						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f6ac:	00a045f4 	movhi	r2,33047
8110f6b0:	10a34f04 	addi	r2,r2,-29380
8110f6b4:	10800a8b 	ldhu	r2,42(r2)
8110f6b8:	10bfffcc 	andi	r2,r2,65535
8110f6bc:	10800168 	cmpgeui	r2,r2,5
8110f6c0:	1001b31e 	bne	r2,zero,8110fd90 <vFeeTask+0x1798>
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
8110f6c4:	d0e06217 	ldw	r3,-32376(gp)
8110f6c8:	d0a05317 	ldw	r2,-32436(gp)
8110f6cc:	10800003 	ldbu	r2,0(r2)
8110f6d0:	10803fcc 	andi	r2,r2,255
8110f6d4:	100d883a 	mov	r6,r2
8110f6d8:	01604574 	movhi	r5,33045
8110f6dc:	297a2604 	addi	r5,r5,-5992
8110f6e0:	1809883a 	mov	r4,r3
8110f6e4:	11236500 	call	81123650 <fprintf>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f6e8:	0001a906 	br	8110fd90 <vFeeTask+0x1798>
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
						}
						#endif
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110f6ec:	d0a05317 	ldw	r2,-32436(gp)
8110f6f0:	e0fffe17 	ldw	r3,-8(fp)
8110f6f4:	180b883a 	mov	r5,r3
8110f6f8:	1009883a 	mov	r4,r2
8110f6fc:	11104680 	call	81110468 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f700:	0001a306 	br	8110fd90 <vFeeTask+0x1798>
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f704:	00a045f4 	movhi	r2,33047
8110f708:	10a34f04 	addi	r2,r2,-29380
8110f70c:	10800a8b 	ldhu	r2,42(r2)
8110f710:	10bfffcc 	andi	r2,r2,65535
8110f714:	10800228 	cmpgeui	r2,r2,8
8110f718:	10019d1e 	bne	r2,zero,8110fd90 <vFeeTask+0x1798>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f71c:	d0e06217 	ldw	r3,-32376(gp)
8110f720:	d0a05317 	ldw	r2,-32436(gp)
8110f724:	10800003 	ldbu	r2,0(r2)
8110f728:	10803fcc 	andi	r2,r2,255
8110f72c:	100d883a 	mov	r6,r2
8110f730:	01604574 	movhi	r5,33045
8110f734:	2979dd04 	addi	r5,r5,-6284
8110f738:	1809883a 	mov	r4,r3
8110f73c:	11236500 	call	81123650 <fprintf>
					}
					#endif
				}	
				break;
8110f740:	00019306 	br	8110fd90 <vFeeTask+0x1798>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110f744:	e03ff915 	stw	zero,-28(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110f748:	d0a05317 	ldw	r2,-32436(gp)
8110f74c:	10804504 	addi	r2,r2,276
8110f750:	1009883a 	mov	r4,r2
8110f754:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110f758:	d0a05317 	ldw	r2,-32436(gp)
8110f75c:	00c00084 	movi	r3,2
8110f760:	10c06815 	stw	r3,416(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110f764:	d0a05317 	ldw	r2,-32436(gp)
8110f768:	10804504 	addi	r2,r2,276
8110f76c:	1009883a 	mov	r4,r2
8110f770:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110f774:	00a045f4 	movhi	r2,33047
8110f778:	10a34f04 	addi	r2,r2,-29380
8110f77c:	10800a8b 	ldhu	r2,42(r2)
8110f780:	10bfffcc 	andi	r2,r2,65535
8110f784:	108000e8 	cmpgeui	r2,r2,3
8110f788:	1000091e 	bne	r2,zero,8110f7b0 <vFeeTask+0x11b8>
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110f78c:	d0e06217 	ldw	r3,-32376(gp)
8110f790:	d0a05317 	ldw	r2,-32436(gp)
8110f794:	10800003 	ldbu	r2,0(r2)
8110f798:	10803fcc 	andi	r2,r2,255
8110f79c:	100d883a 	mov	r6,r2
8110f7a0:	01604574 	movhi	r5,33045
8110f7a4:	297a3004 	addi	r5,r5,-5952
8110f7a8:	1809883a 	mov	r4,r3
8110f7ac:	11236500 	call	81123650 <fprintf>
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110f7b0:	d0a05317 	ldw	r2,-32436(gp)
8110f7b4:	10802e17 	ldw	r2,184(r2)
8110f7b8:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110f7bc:	d0a05317 	ldw	r2,-32436(gp)
8110f7c0:	00c00044 	movi	r3,1
8110f7c4:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110f7c8:	d0a05317 	ldw	r2,-32436(gp)
8110f7cc:	00c00104 	movi	r3,4
8110f7d0:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110f7d4:	d0a05317 	ldw	r2,-32436(gp)
8110f7d8:	00c00104 	movi	r3,4
8110f7dc:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110f7e0:	d0a05317 	ldw	r2,-32436(gp)
8110f7e4:	00c00044 	movi	r3,1
8110f7e8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110f7ec:	d0a05317 	ldw	r2,-32436(gp)
8110f7f0:	00c00044 	movi	r3,1
8110f7f4:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110f7f8:	d0a05317 	ldw	r2,-32436(gp)
8110f7fc:	00c00044 	movi	r3,1
8110f800:	10c02115 	stw	r3,132(r2)
				//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				if (xDefaults.usiLinkNFEE0 == 0) {
8110f804:	00a045f4 	movhi	r2,33047
8110f808:	10a34f04 	addi	r2,r2,-29380
8110f80c:	10800a0b 	ldhu	r2,40(r2)
8110f810:	10bfffcc 	andi	r2,r2,65535
8110f814:	1000071e 	bne	r2,zero,8110f834 <vFeeTask+0x123c>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110f818:	000b883a 	mov	r5,zero
8110f81c:	01000404 	movi	r4,16
8110f820:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110f824:	01400044 	movi	r5,1
8110f828:	01000404 	movi	r4,16
8110f82c:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}

				break;
8110f830:	00015e06 	br	8110fdac <vFeeTask+0x17b4>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110f834:	000b883a 	mov	r5,zero
8110f838:	01000404 	movi	r4,16
8110f83c:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110f840:	01400044 	movi	r5,1
8110f844:	01000404 	movi	r4,16
8110f848:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
				}

				break;
8110f84c:	00015706 	br	8110fdac <vFeeTask+0x17b4>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110f850:	e03ff915 	stw	zero,-28(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f854:	d0a05317 	ldw	r2,-32436(gp)
8110f858:	10800003 	ldbu	r2,0(r2)
8110f85c:	10803fcc 	andi	r2,r2,255
8110f860:	1085883a 	add	r2,r2,r2
8110f864:	1087883a 	add	r3,r2,r2
8110f868:	d0a06a04 	addi	r2,gp,-32344
8110f86c:	1885883a 	add	r2,r3,r2
8110f870:	10800017 	ldw	r2,0(r2)
8110f874:	e0fffd04 	addi	r3,fp,-12
8110f878:	180d883a 	mov	r6,r3
8110f87c:	000b883a 	mov	r5,zero
8110f880:	1009883a 	mov	r4,r2
8110f884:	113fc140 	call	8113fc14 <OSQPend>
8110f888:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110f88c:	e0bffd03 	ldbu	r2,-12(fp)
8110f890:	10803fcc 	andi	r2,r2,255
8110f894:	10009a1e 	bne	r2,zero,8110fb00 <vFeeTask+0x1508>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110f898:	e0bffe83 	ldbu	r2,-6(fp)
8110f89c:	10803fcc 	andi	r2,r2,255
8110f8a0:	108023d8 	cmpnei	r2,r2,143
8110f8a4:	1000891e 	bne	r2,zero,8110facc <vFeeTask+0x14d4>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110f8a8:	e0fff403 	ldbu	r3,-48(fp)
8110f8ac:	00a045b4 	movhi	r2,33046
8110f8b0:	10969304 	addi	r2,r2,23116
8110f8b4:	180690fa 	slli	r3,r3,3
8110f8b8:	10c5883a 	add	r2,r2,r3
8110f8bc:	10800017 	ldw	r2,0(r2)
8110f8c0:	e0fffd04 	addi	r3,fp,-12
8110f8c4:	180d883a 	mov	r6,r3
8110f8c8:	000b883a 	mov	r5,zero
8110f8cc:	1009883a 	mov	r4,r2
8110f8d0:	113eb000 	call	8113eb00 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
8110f8d4:	e0bffd03 	ldbu	r2,-12(fp)
8110f8d8:	10803fcc 	andi	r2,r2,255
8110f8dc:	10012e1e 	bne	r2,zero,8110fd98 <vFeeTask+0x17a0>
							pxNFee->xControl.bDMALocked = TRUE;
8110f8e0:	d0a05317 	ldw	r2,-32436(gp)
8110f8e4:	00c00044 	movi	r3,1
8110f8e8:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110f8ec:	e0bff517 	ldw	r2,-44(fp)
8110f8f0:	10800117 	ldw	r2,4(r2)
8110f8f4:	10c00404 	addi	r3,r2,16
8110f8f8:	d0a05317 	ldw	r2,-32436(gp)
8110f8fc:	10800417 	ldw	r2,16(r2)
8110f900:	18802336 	bltu	r3,r2,8110f990 <vFeeTask+0x1398>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110f904:	d0a05317 	ldw	r2,-32436(gp)
8110f908:	10c00417 	ldw	r3,16(r2)
8110f90c:	e0bff517 	ldw	r2,-44(fp)
8110f910:	10800117 	ldw	r2,4(r2)
8110f914:	1885c83a 	sub	r2,r3,r2
8110f918:	e0bff715 	stw	r2,-36(fp)

								if (xDefaults.usiLinkNFEE0 == 0) {
8110f91c:	00a045f4 	movhi	r2,33047
8110f920:	10a34f04 	addi	r2,r2,-29380
8110f924:	10800a0b 	ldhu	r2,40(r2)
8110f928:	10bfffcc 	andi	r2,r2,65535
8110f92c:	10000b1e 	bne	r2,zero,8110f95c <vFeeTask+0x1364>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110f930:	e0bff717 	ldw	r2,-36(fp)
8110f934:	10803fcc 	andi	r2,r2,255
8110f938:	000b883a 	mov	r5,zero
8110f93c:	1009883a 	mov	r4,r2
8110f940:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110f944:	e0bff717 	ldw	r2,-36(fp)
8110f948:	10803fcc 	andi	r2,r2,255
8110f94c:	01400044 	movi	r5,1
8110f950:	1009883a 	mov	r4,r2
8110f954:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
8110f958:	00000a06 	br	8110f984 <vFeeTask+0x138c>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110f95c:	e0bff717 	ldw	r2,-36(fp)
8110f960:	10803fcc 	andi	r2,r2,255
8110f964:	000b883a 	mov	r5,zero
8110f968:	1009883a 	mov	r4,r2
8110f96c:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110f970:	e0bff717 	ldw	r2,-36(fp)
8110f974:	10803fcc 	andi	r2,r2,255
8110f978:	01400044 	movi	r5,1
8110f97c:	1009883a 	mov	r4,r2
8110f980:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
								}

								bFinal = TRUE;
8110f984:	00800044 	movi	r2,1
8110f988:	e0bff915 	stw	r2,-28(fp)
8110f98c:	00000206 	br	8110f998 <vFeeTask+0x13a0>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
8110f990:	00800404 	movi	r2,16
8110f994:	e0bff715 	stw	r2,-36(fp)
							}


							if ( ucMemUsing == 0  ) {
8110f998:	e0bff403 	ldbu	r2,-48(fp)
8110f99c:	1000111e 	bne	r2,zero,8110f9e4 <vFeeTask+0x13ec>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110f9a0:	e0bff517 	ldw	r2,-44(fp)
8110f9a4:	10800217 	ldw	r2,8(r2)
8110f9a8:	1011883a 	mov	r8,r2
8110f9ac:	e0bff717 	ldw	r2,-36(fp)
8110f9b0:	10ffffcc 	andi	r3,r2,65535
8110f9b4:	d0a05603 	ldbu	r2,-32424(gp)
8110f9b8:	11003fcc 	andi	r4,r2,255
8110f9bc:	d0a05317 	ldw	r2,-32436(gp)
8110f9c0:	10800043 	ldbu	r2,1(r2)
8110f9c4:	10803fcc 	andi	r2,r2,255
8110f9c8:	100f883a 	mov	r7,r2
8110f9cc:	200d883a 	mov	r6,r4
8110f9d0:	180b883a 	mov	r5,r3
8110f9d4:	4009883a 	mov	r4,r8
8110f9d8:	1103d040 	call	81103d04 <bSdmaDmaM1Transfer>
8110f9dc:	e0bff815 	stw	r2,-32(fp)
8110f9e0:	00001006 	br	8110fa24 <vFeeTask+0x142c>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110f9e4:	e0bff517 	ldw	r2,-44(fp)
8110f9e8:	10800217 	ldw	r2,8(r2)
8110f9ec:	1011883a 	mov	r8,r2
8110f9f0:	e0bff717 	ldw	r2,-36(fp)
8110f9f4:	10ffffcc 	andi	r3,r2,65535
8110f9f8:	d0a05603 	ldbu	r2,-32424(gp)
8110f9fc:	11003fcc 	andi	r4,r2,255
8110fa00:	d0a05317 	ldw	r2,-32436(gp)
8110fa04:	10800043 	ldbu	r2,1(r2)
8110fa08:	10803fcc 	andi	r2,r2,255
8110fa0c:	100f883a 	mov	r7,r2
8110fa10:	200d883a 	mov	r6,r4
8110fa14:	180b883a 	mov	r5,r3
8110fa18:	4009883a 	mov	r4,r8
8110fa1c:	11041580 	call	81104158 <bSdmaDmaM2Transfer>
8110fa20:	e0bff815 	stw	r2,-32(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110fa24:	e0fff403 	ldbu	r3,-48(fp)
8110fa28:	00a045b4 	movhi	r2,33046
8110fa2c:	10969304 	addi	r2,r2,23116
8110fa30:	180690fa 	slli	r3,r3,3
8110fa34:	10c5883a 	add	r2,r2,r3
8110fa38:	10800017 	ldw	r2,0(r2)
8110fa3c:	1009883a 	mov	r4,r2
8110fa40:	113f0a40 	call	8113f0a4 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110fa44:	d0a05317 	ldw	r2,-32436(gp)
8110fa48:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
8110fa4c:	e0bff817 	ldw	r2,-32(fp)
8110fa50:	10800058 	cmpnei	r2,r2,1
8110fa54:	10000e1e 	bne	r2,zero,8110fa90 <vFeeTask+0x1498>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110fa58:	e0bff517 	ldw	r2,-44(fp)
8110fa5c:	10c00217 	ldw	r3,8(r2)
8110fa60:	e0bff717 	ldw	r2,-36(fp)
8110fa64:	10802224 	muli	r2,r2,136
8110fa68:	1887883a 	add	r3,r3,r2
8110fa6c:	e0bff517 	ldw	r2,-44(fp)
8110fa70:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110fa74:	e0bff517 	ldw	r2,-44(fp)
8110fa78:	10c00117 	ldw	r3,4(r2)
8110fa7c:	e0bff717 	ldw	r2,-36(fp)
8110fa80:	1887883a 	add	r3,r3,r2
8110fa84:	e0bff517 	ldw	r2,-44(fp)
8110fa88:	10c00115 	stw	r3,4(r2)
8110fa8c:	00000106 	br	8110fa94 <vFeeTask+0x149c>
							} else {
								bFinal = FALSE;
8110fa90:	e03ff915 	stw	zero,-28(fp)
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110fa94:	d0a05317 	ldw	r2,-32436(gp)
8110fa98:	10800003 	ldbu	r2,0(r2)
8110fa9c:	10803fcc 	andi	r2,r2,255
8110faa0:	100d883a 	mov	r6,r2
8110faa4:	000b883a 	mov	r5,zero
8110faa8:	01002044 	movi	r4,129
8110faac:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
8110fab0:	e0bff917 	ldw	r2,-28(fp)
8110fab4:	10800058 	cmpnei	r2,r2,1
8110fab8:	1000b71e 	bne	r2,zero,8110fd98 <vFeeTask+0x17a0>
								pxNFee->xControl.eMode = sEndTransmission;
8110fabc:	d0a05317 	ldw	r2,-32436(gp)
8110fac0:	00c002c4 	movi	r3,11
8110fac4:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110fac8:	0000b306 	br	8110fd98 <vFeeTask+0x17a0>
								//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110facc:	d0a05317 	ldw	r2,-32436(gp)
8110fad0:	e0fffe17 	ldw	r3,-8(fp)
8110fad4:	180b883a 	mov	r5,r3
8110fad8:	1009883a 	mov	r4,r2
8110fadc:	11104680 	call	81110468 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110fae0:	d0a05317 	ldw	r2,-32436(gp)
8110fae4:	10802817 	ldw	r2,160(r2)
8110fae8:	1000ab1e 	bne	r2,zero,8110fd98 <vFeeTask+0x17a0>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110faec:	d0a05317 	ldw	r2,-32436(gp)
8110faf0:	d0e05317 	ldw	r3,-32436(gp)
8110faf4:	18c02d17 	ldw	r3,180(r3)
8110faf8:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110fafc:	0000a606 	br	8110fd98 <vFeeTask+0x17a0>
						}
					}

				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fb00:	00a045f4 	movhi	r2,33047
8110fb04:	10a34f04 	addi	r2,r2,-29380
8110fb08:	10800a8b 	ldhu	r2,42(r2)
8110fb0c:	10bfffcc 	andi	r2,r2,65535
8110fb10:	10800228 	cmpgeui	r2,r2,8
8110fb14:	1000a01e 	bne	r2,zero,8110fd98 <vFeeTask+0x17a0>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110fb18:	d0e06217 	ldw	r3,-32376(gp)
8110fb1c:	d0a05317 	ldw	r2,-32436(gp)
8110fb20:	10800003 	ldbu	r2,0(r2)
8110fb24:	10803fcc 	andi	r2,r2,255
8110fb28:	100d883a 	mov	r6,r2
8110fb2c:	01604574 	movhi	r5,33045
8110fb30:	2979dd04 	addi	r5,r5,-6284
8110fb34:	1809883a 	mov	r4,r3
8110fb38:	11236500 	call	81123650 <fprintf>
					}
					#endif
				}

				break;
8110fb3c:	00009606 	br	8110fd98 <vFeeTask+0x17a0>

			case sEndTransmission:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fb40:	00a045f4 	movhi	r2,33047
8110fb44:	10a34f04 	addi	r2,r2,-29380
8110fb48:	10800a8b 	ldhu	r2,42(r2)
8110fb4c:	10bfffcc 	andi	r2,r2,65535
8110fb50:	10800168 	cmpgeui	r2,r2,5
8110fb54:	1000121e 	bne	r2,zero,8110fba0 <vFeeTask+0x15a8>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
8110fb58:	d0e06217 	ldw	r3,-32376(gp)
8110fb5c:	d0a05317 	ldw	r2,-32436(gp)
8110fb60:	10800003 	ldbu	r2,0(r2)
8110fb64:	10803fcc 	andi	r2,r2,255
8110fb68:	e13ff603 	ldbu	r4,-40(fp)
8110fb6c:	200f883a 	mov	r7,r4
8110fb70:	100d883a 	mov	r6,r2
8110fb74:	01604574 	movhi	r5,33045
8110fb78:	297a3a04 	addi	r5,r5,-5912
8110fb7c:	1809883a 	mov	r4,r3
8110fb80:	11236500 	call	81123650 <fprintf>
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
8110fb84:	d0a06217 	ldw	r2,-32376(gp)
8110fb88:	e0fff403 	ldbu	r3,-48(fp)
8110fb8c:	180d883a 	mov	r6,r3
8110fb90:	01604574 	movhi	r5,33045
8110fb94:	297a4504 	addi	r5,r5,-5868
8110fb98:	1009883a 	mov	r4,r2
8110fb9c:	11236500 	call	81123650 <fprintf>
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
8110fba0:	d0a05317 	ldw	r2,-32436(gp)
8110fba4:	00c00044 	movi	r3,1
8110fba8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110fbac:	d0a05317 	ldw	r2,-32436(gp)
8110fbb0:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
8110fbb4:	00a045f4 	movhi	r2,33047
8110fbb8:	10a34f04 	addi	r2,r2,-29380
8110fbbc:	10800917 	ldw	r2,36(r2)
8110fbc0:	10001f1e 	bne	r2,zero,8110fc40 <vFeeTask+0x1648>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110fbc4:	d0a05317 	ldw	r2,-32436(gp)
8110fbc8:	10802d17 	ldw	r2,180(r2)
8110fbcc:	10800198 	cmpnei	r2,r2,6
8110fbd0:	1000141e 	bne	r2,zero,8110fc24 <vFeeTask+0x162c>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110fbd4:	d0a05317 	ldw	r2,-32436(gp)
8110fbd8:	10803304 	addi	r2,r2,204
8110fbdc:	1009883a 	mov	r4,r2
8110fbe0:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110fbe4:	d0a05317 	ldw	r2,-32436(gp)
8110fbe8:	e0fff603 	ldbu	r3,-40(fp)
8110fbec:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8110fbf0:	d0a05317 	ldw	r2,-32436(gp)
8110fbf4:	10003685 	stb	zero,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110fbf8:	d0a05317 	ldw	r2,-32436(gp)
8110fbfc:	10803304 	addi	r2,r2,204
8110fc00:	1009883a 	mov	r4,r2
8110fc04:	11049240 	call	81104924 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110fc08:	d0a05317 	ldw	r2,-32436(gp)
8110fc0c:	00c00304 	movi	r3,12
8110fc10:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110fc14:	d0a05317 	ldw	r2,-32436(gp)
8110fc18:	00c00184 	movi	r3,6
8110fc1c:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110fc20:	00006206 	br	8110fdac <vFeeTask+0x17b4>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110fc24:	d0a05317 	ldw	r2,-32436(gp)
8110fc28:	00c00284 	movi	r3,10
8110fc2c:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110fc30:	d0a05317 	ldw	r2,-32436(gp)
8110fc34:	00c00304 	movi	r3,12
8110fc38:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110fc3c:	00005b06 	br	8110fdac <vFeeTask+0x17b4>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110fc40:	d0a05317 	ldw	r2,-32436(gp)
8110fc44:	00c00304 	movi	r3,12
8110fc48:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110fc4c:	d0a05317 	ldw	r2,-32436(gp)
8110fc50:	00c00184 	movi	r3,6
8110fc54:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110fc58:	00005406 	br	8110fdac <vFeeTask+0x17b4>

			case sFeeWaitingSync:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fc5c:	00a045f4 	movhi	r2,33047
8110fc60:	10a34f04 	addi	r2,r2,-29380
8110fc64:	10800a8b 	ldhu	r2,42(r2)
8110fc68:	10bfffcc 	andi	r2,r2,65535
8110fc6c:	10800168 	cmpgeui	r2,r2,5
8110fc70:	1000091e 	bne	r2,zero,8110fc98 <vFeeTask+0x16a0>
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110fc74:	d0e06217 	ldw	r3,-32376(gp)
8110fc78:	d0a05317 	ldw	r2,-32436(gp)
8110fc7c:	10800003 	ldbu	r2,0(r2)
8110fc80:	10803fcc 	andi	r2,r2,255
8110fc84:	100d883a 	mov	r6,r2
8110fc88:	01604574 	movhi	r5,33045
8110fc8c:	297a4a04 	addi	r5,r5,-5848
8110fc90:	1809883a 	mov	r4,r3
8110fc94:	11236500 	call	81123650 <fprintf>
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110fc98:	d0a05317 	ldw	r2,-32436(gp)
8110fc9c:	10800003 	ldbu	r2,0(r2)
8110fca0:	10803fcc 	andi	r2,r2,255
8110fca4:	1085883a 	add	r2,r2,r2
8110fca8:	1087883a 	add	r3,r2,r2
8110fcac:	d0a06a04 	addi	r2,gp,-32344
8110fcb0:	1885883a 	add	r2,r3,r2
8110fcb4:	10800017 	ldw	r2,0(r2)
8110fcb8:	e0fffd04 	addi	r3,fp,-12
8110fcbc:	180d883a 	mov	r6,r3
8110fcc0:	000b883a 	mov	r5,zero
8110fcc4:	1009883a 	mov	r4,r2
8110fcc8:	113fc140 	call	8113fc14 <OSQPend>
8110fccc:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110fcd0:	e0bffd03 	ldbu	r2,-12(fp)
8110fcd4:	10803fcc 	andi	r2,r2,255
8110fcd8:	10001026 	beq	r2,zero,8110fd1c <vFeeTask+0x1724>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fcdc:	00a045f4 	movhi	r2,33047
8110fce0:	10a34f04 	addi	r2,r2,-29380
8110fce4:	10800a8b 	ldhu	r2,42(r2)
8110fce8:	10bfffcc 	andi	r2,r2,65535
8110fcec:	10800228 	cmpgeui	r2,r2,8
8110fcf0:	10002b1e 	bne	r2,zero,8110fda0 <vFeeTask+0x17a8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110fcf4:	d0e06217 	ldw	r3,-32376(gp)
8110fcf8:	d0a05317 	ldw	r2,-32436(gp)
8110fcfc:	10800003 	ldbu	r2,0(r2)
8110fd00:	10803fcc 	andi	r2,r2,255
8110fd04:	100d883a 	mov	r6,r2
8110fd08:	01604574 	movhi	r5,33045
8110fd0c:	297a5304 	addi	r5,r5,-5812
8110fd10:	1809883a 	mov	r4,r3
8110fd14:	11236500 	call	81123650 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110fd18:	00002106 	br	8110fda0 <vFeeTask+0x17a8>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110fd1c:	d0a05317 	ldw	r2,-32436(gp)
8110fd20:	e0fffe17 	ldw	r3,-8(fp)
8110fd24:	180b883a 	mov	r5,r3
8110fd28:	1009883a 	mov	r4,r2
8110fd2c:	110fdb00 	call	8110fdb0 <vQCmdFEEinWaitingSync>
				}

				break;
8110fd30:	00001b06 	br	8110fda0 <vFeeTask+0x17a8>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110fd34:	d0a05317 	ldw	r2,-32436(gp)
8110fd38:	00c00144 	movi	r3,5
8110fd3c:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fd40:	00a045f4 	movhi	r2,33047
8110fd44:	10a34f04 	addi	r2,r2,-29380
8110fd48:	10800a8b 	ldhu	r2,42(r2)
8110fd4c:	10bfffcc 	andi	r2,r2,65535
8110fd50:	10800228 	cmpgeui	r2,r2,8
8110fd54:	1000141e 	bne	r2,zero,8110fda8 <vFeeTask+0x17b0>
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110fd58:	d0e06217 	ldw	r3,-32376(gp)
8110fd5c:	d0a05317 	ldw	r2,-32436(gp)
8110fd60:	10800003 	ldbu	r2,0(r2)
8110fd64:	10803fcc 	andi	r2,r2,255
8110fd68:	100d883a 	mov	r6,r2
8110fd6c:	01604574 	movhi	r5,33045
8110fd70:	297a6404 	addi	r5,r5,-5744
8110fd74:	1809883a 	mov	r4,r3
8110fd78:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
8110fd7c:	00000a06 	br	8110fda8 <vFeeTask+0x17b0>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110fd80:	0001883a 	nop
8110fd84:	003a3d06 	br	8110e67c <__reset+0xfb0ee67c>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110fd88:	0001883a 	nop
8110fd8c:	003a3b06 	br	8110e67c <__reset+0xfb0ee67c>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110fd90:	0001883a 	nop
8110fd94:	003a3906 	br	8110e67c <__reset+0xfb0ee67c>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110fd98:	0001883a 	nop
8110fd9c:	003a3706 	br	8110e67c <__reset+0xfb0ee67c>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110fda0:	0001883a 	nop
8110fda4:	003a3506 	br	8110e67c <__reset+0xfb0ee67c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
8110fda8:	0001883a 	nop
		}

	}
8110fdac:	003a3306 	br	8110e67c <__reset+0xfb0ee67c>

8110fdb0 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110fdb0:	defffb04 	addi	sp,sp,-20
8110fdb4:	de00012e 	bgeu	sp,et,8110fdbc <vQCmdFEEinWaitingSync+0xc>
8110fdb8:	003b68fa 	trap	3
8110fdbc:	dfc00415 	stw	ra,16(sp)
8110fdc0:	df000315 	stw	fp,12(sp)
8110fdc4:	df000304 	addi	fp,sp,12
8110fdc8:	e13ffe15 	stw	r4,-8(fp)
8110fdcc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110fdd0:	e0bfff17 	ldw	r2,-4(fp)
8110fdd4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110fdd8:	e0bffdc3 	ldbu	r2,-9(fp)
8110fddc:	10c03fcc 	andi	r3,r2,255
8110fde0:	e0bffe17 	ldw	r2,-8(fp)
8110fde4:	10800003 	ldbu	r2,0(r2)
8110fde8:	10803fcc 	andi	r2,r2,255
8110fdec:	10800444 	addi	r2,r2,17
8110fdf0:	18806f1e 	bne	r3,r2,8110ffb0 <vQCmdFEEinWaitingSync+0x200>

		switch (uiCmdFEEL.ucByte[2]) {
8110fdf4:	e0bffd83 	ldbu	r2,-10(fp)
8110fdf8:	10803fcc 	andi	r2,r2,255
8110fdfc:	10c02860 	cmpeqi	r3,r2,161
8110fe00:	18001a1e 	bne	r3,zero,8110fe6c <vQCmdFEEinWaitingSync+0xbc>
8110fe04:	10c02888 	cmpgei	r3,r2,162
8110fe08:	18000c1e 	bne	r3,zero,8110fe3c <vQCmdFEEinWaitingSync+0x8c>
8110fe0c:	10c00120 	cmpeqi	r3,r2,4
8110fe10:	18001f1e 	bne	r3,zero,8110fe90 <vQCmdFEEinWaitingSync+0xe0>
8110fe14:	10c00148 	cmpgei	r3,r2,5
8110fe18:	1800031e 	bne	r3,zero,8110fe28 <vQCmdFEEinWaitingSync+0x78>
8110fe1c:	10800060 	cmpeqi	r2,r2,1
8110fe20:	1000121e 	bne	r2,zero,8110fe6c <vQCmdFEEinWaitingSync+0xbc>
8110fe24:	00005206 	br	8110ff70 <vQCmdFEEinWaitingSync+0x1c0>
8110fe28:	10c00220 	cmpeqi	r3,r2,8
8110fe2c:	1800221e 	bne	r3,zero,8110feb8 <vQCmdFEEinWaitingSync+0x108>
8110fe30:	108023e0 	cmpeqi	r2,r2,143
8110fe34:	1000441e 	bne	r2,zero,8110ff48 <vQCmdFEEinWaitingSync+0x198>
8110fe38:	00004d06 	br	8110ff70 <vQCmdFEEinWaitingSync+0x1c0>
8110fe3c:	10c03888 	cmpgei	r3,r2,226
8110fe40:	1800071e 	bne	r3,zero,8110fe60 <vQCmdFEEinWaitingSync+0xb0>
8110fe44:	10c03808 	cmpgei	r3,r2,224
8110fe48:	1800381e 	bne	r3,zero,8110ff2c <vQCmdFEEinWaitingSync+0x17c>
8110fe4c:	10c02920 	cmpeqi	r3,r2,164
8110fe50:	18000f1e 	bne	r3,zero,8110fe90 <vQCmdFEEinWaitingSync+0xe0>
8110fe54:	10802a20 	cmpeqi	r2,r2,168
8110fe58:	1000171e 	bne	r2,zero,8110feb8 <vQCmdFEEinWaitingSync+0x108>
8110fe5c:	00004406 	br	8110ff70 <vQCmdFEEinWaitingSync+0x1c0>
8110fe60:	10803c20 	cmpeqi	r2,r2,240
8110fe64:	10001e1e 	bne	r2,zero,8110fee0 <vQCmdFEEinWaitingSync+0x130>
8110fe68:	00004106 	br	8110ff70 <vQCmdFEEinWaitingSync+0x1c0>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fe6c:	e0bffe17 	ldw	r2,-8(fp)
8110fe70:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110fe74:	e0bffe17 	ldw	r2,-8(fp)
8110fe78:	00c00144 	movi	r3,5
8110fe7c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110fe80:	e0bffe17 	ldw	r2,-8(fp)
8110fe84:	00c00144 	movi	r3,5
8110fe88:	10c02d15 	stw	r3,180(r2)
				break;
8110fe8c:	00004806 	br	8110ffb0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110fe90:	e0bffe17 	ldw	r2,-8(fp)
8110fe94:	00c00044 	movi	r3,1
8110fe98:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110fe9c:	e0bffe17 	ldw	r2,-8(fp)
8110fea0:	00c00304 	movi	r3,12
8110fea4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fea8:	e0bffe17 	ldw	r2,-8(fp)
8110feac:	00c00184 	movi	r3,6
8110feb0:	10c02d15 	stw	r3,180(r2)
				break;
8110feb4:	00003e06 	br	8110ffb0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110feb8:	e0bffe17 	ldw	r2,-8(fp)
8110febc:	00c00044 	movi	r3,1
8110fec0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110fec4:	e0bffe17 	ldw	r2,-8(fp)
8110fec8:	00c00284 	movi	r3,10
8110fecc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110fed0:	e0bffe17 	ldw	r2,-8(fp)
8110fed4:	00c00304 	movi	r3,12
8110fed8:	10c02d15 	stw	r3,180(r2)
				break;
8110fedc:	00003406 	br	8110ffb0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fee0:	00a045f4 	movhi	r2,33047
8110fee4:	10a34f04 	addi	r2,r2,-29380
8110fee8:	10800a8b 	ldhu	r2,42(r2)
8110feec:	10bfffcc 	andi	r2,r2,65535
8110fef0:	108000e8 	cmpgeui	r2,r2,3
8110fef4:	1000091e 	bne	r2,zero,8110ff1c <vQCmdFEEinWaitingSync+0x16c>
					fprintf(fp,"\nNFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110fef8:	d0e06217 	ldw	r3,-32376(gp)
8110fefc:	e0bffe17 	ldw	r2,-8(fp)
8110ff00:	10800003 	ldbu	r2,0(r2)
8110ff04:	10803fcc 	andi	r2,r2,255
8110ff08:	100d883a 	mov	r6,r2
8110ff0c:	01604574 	movhi	r5,33045
8110ff10:	297a6f04 	addi	r5,r5,-5700
8110ff14:	1809883a 	mov	r4,r3
8110ff18:	11236500 	call	81123650 <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110ff1c:	e17fff17 	ldw	r5,-4(fp)
8110ff20:	e13ffe17 	ldw	r4,-8(fp)
8110ff24:	11113580 	call	81111358 <vQCmdFeeRMAPWaitingSync>
				break;
8110ff28:	00002106 	br	8110ffb0 <vQCmdFEEinWaitingSync+0x200>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110ff2c:	e0bffe17 	ldw	r2,-8(fp)
8110ff30:	10c02d17 	ldw	r3,180(r2)
8110ff34:	e0bffe17 	ldw	r2,-8(fp)
8110ff38:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110ff3c:	e0bffe17 	ldw	r2,-8(fp)
8110ff40:	10002815 	stw	zero,160(r2)

				break;
8110ff44:	00001a06 	br	8110ffb0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110ff48:	e0bffe17 	ldw	r2,-8(fp)
8110ff4c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110ff50:	e0bffe17 	ldw	r2,-8(fp)
8110ff54:	10800003 	ldbu	r2,0(r2)
8110ff58:	10803fcc 	andi	r2,r2,255
8110ff5c:	100d883a 	mov	r6,r2
8110ff60:	000b883a 	mov	r5,zero
8110ff64:	01002044 	movi	r4,129
8110ff68:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>
				break;
8110ff6c:	00001006 	br	8110ffb0 <vQCmdFEEinWaitingSync+0x200>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ff70:	00a045f4 	movhi	r2,33047
8110ff74:	10a34f04 	addi	r2,r2,-29380
8110ff78:	10800a8b 	ldhu	r2,42(r2)
8110ff7c:	10bfffcc 	andi	r2,r2,65535
8110ff80:	10800228 	cmpgeui	r2,r2,8
8110ff84:	1000091e 	bne	r2,zero,8110ffac <vQCmdFEEinWaitingSync+0x1fc>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110ff88:	d0e06217 	ldw	r3,-32376(gp)
8110ff8c:	e0bffe17 	ldw	r2,-8(fp)
8110ff90:	10800003 	ldbu	r2,0(r2)
8110ff94:	10803fcc 	andi	r2,r2,255
8110ff98:	100d883a 	mov	r6,r2
8110ff9c:	01604574 	movhi	r5,33045
8110ffa0:	297a7704 	addi	r5,r5,-5668
8110ffa4:	1809883a 	mov	r4,r3
8110ffa8:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
8110ffac:	0001883a 	nop
		}
	}
}
8110ffb0:	0001883a 	nop
8110ffb4:	e037883a 	mov	sp,fp
8110ffb8:	dfc00117 	ldw	ra,4(sp)
8110ffbc:	df000017 	ldw	fp,0(sp)
8110ffc0:	dec00204 	addi	sp,sp,8
8110ffc4:	f800283a 	ret

8110ffc8 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110ffc8:	defffb04 	addi	sp,sp,-20
8110ffcc:	de00012e 	bgeu	sp,et,8110ffd4 <vQCmdFEEinConfig+0xc>
8110ffd0:	003b68fa 	trap	3
8110ffd4:	dfc00415 	stw	ra,16(sp)
8110ffd8:	df000315 	stw	fp,12(sp)
8110ffdc:	df000304 	addi	fp,sp,12
8110ffe0:	e13ffe15 	stw	r4,-8(fp)
8110ffe4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110ffe8:	e0bfff17 	ldw	r2,-4(fp)
8110ffec:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110fff0:	e0bffdc3 	ldbu	r2,-9(fp)
8110fff4:	10c03fcc 	andi	r3,r2,255
8110fff8:	e0bffe17 	ldw	r2,-8(fp)
8110fffc:	10800003 	ldbu	r2,0(r2)
81110000:	10803fcc 	andi	r2,r2,255
81110004:	10800444 	addi	r2,r2,17
81110008:	18807a1e 	bne	r3,r2,811101f4 <vQCmdFEEinConfig+0x22c>

		switch (uiCmdFEEL.ucByte[2]) {
8111000c:	e0bffd83 	ldbu	r2,-10(fp)
81110010:	10803fcc 	andi	r2,r2,255
81110014:	10c02860 	cmpeqi	r3,r2,161
81110018:	18001a1e 	bne	r3,zero,81110084 <vQCmdFEEinConfig+0xbc>
8111001c:	10c02888 	cmpgei	r3,r2,162
81110020:	18000c1e 	bne	r3,zero,81110054 <vQCmdFEEinConfig+0x8c>
81110024:	10c00120 	cmpeqi	r3,r2,4
81110028:	1800261e 	bne	r3,zero,811100c4 <vQCmdFEEinConfig+0xfc>
8111002c:	10c00148 	cmpgei	r3,r2,5
81110030:	1800031e 	bne	r3,zero,81110040 <vQCmdFEEinConfig+0x78>
81110034:	10800060 	cmpeqi	r2,r2,1
81110038:	1000121e 	bne	r2,zero,81110084 <vQCmdFEEinConfig+0xbc>
8111003c:	00005406 	br	81110190 <vQCmdFEEinConfig+0x1c8>
81110040:	10c00220 	cmpeqi	r3,r2,8
81110044:	1800281e 	bne	r3,zero,811100e8 <vQCmdFEEinConfig+0x120>
81110048:	108023e0 	cmpeqi	r2,r2,143
8111004c:	1000461e 	bne	r2,zero,81110168 <vQCmdFEEinConfig+0x1a0>
81110050:	00004f06 	br	81110190 <vQCmdFEEinConfig+0x1c8>
81110054:	10c03888 	cmpgei	r3,r2,226
81110058:	1800071e 	bne	r3,zero,81110078 <vQCmdFEEinConfig+0xb0>
8111005c:	10c03808 	cmpgei	r3,r2,224
81110060:	18005b1e 	bne	r3,zero,811101d0 <vQCmdFEEinConfig+0x208>
81110064:	10c02920 	cmpeqi	r3,r2,164
81110068:	1800161e 	bne	r3,zero,811100c4 <vQCmdFEEinConfig+0xfc>
8111006c:	10802a20 	cmpeqi	r2,r2,168
81110070:	10001d1e 	bne	r2,zero,811100e8 <vQCmdFEEinConfig+0x120>
81110074:	00004606 	br	81110190 <vQCmdFEEinConfig+0x1c8>
81110078:	10803c20 	cmpeqi	r2,r2,240
8111007c:	10002a1e 	bne	r2,zero,81110128 <vQCmdFEEinConfig+0x160>
81110080:	00004306 	br	81110190 <vQCmdFEEinConfig+0x1c8>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110084:	00a045f4 	movhi	r2,33047
81110088:	10a34f04 	addi	r2,r2,-29380
8111008c:	10800a8b 	ldhu	r2,42(r2)
81110090:	10bfffcc 	andi	r2,r2,65535
81110094:	10800168 	cmpgeui	r2,r2,5
81110098:	10004f1e 	bne	r2,zero,811101d8 <vQCmdFEEinConfig+0x210>
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8111009c:	d0e06217 	ldw	r3,-32376(gp)
811100a0:	e0bffe17 	ldw	r2,-8(fp)
811100a4:	10800003 	ldbu	r2,0(r2)
811100a8:	10803fcc 	andi	r2,r2,255
811100ac:	100d883a 	mov	r6,r2
811100b0:	01604574 	movhi	r5,33045
811100b4:	297a8804 	addi	r5,r5,-5600
811100b8:	1809883a 	mov	r4,r3
811100bc:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
811100c0:	00004506 	br	811101d8 <vQCmdFEEinConfig+0x210>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
811100c4:	e0bffe17 	ldw	r2,-8(fp)
811100c8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
811100cc:	e0bffe17 	ldw	r2,-8(fp)
811100d0:	00c00184 	movi	r3,6
811100d4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811100d8:	e0bffe17 	ldw	r2,-8(fp)
811100dc:	00c00184 	movi	r3,6
811100e0:	10c02d15 	stw	r3,180(r2)
				break;				
811100e4:	00004306 	br	811101f4 <vQCmdFEEinConfig+0x22c>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811100e8:	00a045f4 	movhi	r2,33047
811100ec:	10a34f04 	addi	r2,r2,-29380
811100f0:	10800a8b 	ldhu	r2,42(r2)
811100f4:	10bfffcc 	andi	r2,r2,65535
811100f8:	10800168 	cmpgeui	r2,r2,5
811100fc:	1000381e 	bne	r2,zero,811101e0 <vQCmdFEEinConfig+0x218>
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
81110100:	d0e06217 	ldw	r3,-32376(gp)
81110104:	e0bffe17 	ldw	r2,-8(fp)
81110108:	10800003 	ldbu	r2,0(r2)
8111010c:	10803fcc 	andi	r2,r2,255
81110110:	100d883a 	mov	r6,r2
81110114:	01604574 	movhi	r5,33045
81110118:	297a9304 	addi	r5,r5,-5556
8111011c:	1809883a 	mov	r4,r3
81110120:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
81110124:	00002e06 	br	811101e0 <vQCmdFEEinConfig+0x218>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110128:	00a045f4 	movhi	r2,33047
8111012c:	10a34f04 	addi	r2,r2,-29380
81110130:	10800a8b 	ldhu	r2,42(r2)
81110134:	10bfffcc 	andi	r2,r2,65535
81110138:	10800168 	cmpgeui	r2,r2,5
8111013c:	10002a1e 	bne	r2,zero,811101e8 <vQCmdFEEinConfig+0x220>
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
81110140:	d0e06217 	ldw	r3,-32376(gp)
81110144:	e0bffe17 	ldw	r2,-8(fp)
81110148:	10800003 	ldbu	r2,0(r2)
8111014c:	10803fcc 	andi	r2,r2,255
81110150:	100d883a 	mov	r6,r2
81110154:	01604574 	movhi	r5,33045
81110158:	297aa404 	addi	r5,r5,-5488
8111015c:	1809883a 	mov	r4,r3
81110160:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
81110164:	00002006 	br	811101e8 <vQCmdFEEinConfig+0x220>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
81110168:	e0bffe17 	ldw	r2,-8(fp)
8111016c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
81110170:	e0bffe17 	ldw	r2,-8(fp)
81110174:	10800003 	ldbu	r2,0(r2)
81110178:	10803fcc 	andi	r2,r2,255
8111017c:	100d883a 	mov	r6,r2
81110180:	000b883a 	mov	r5,zero
81110184:	01002044 	movi	r4,129
81110188:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>
				break;
8111018c:	00001906 	br	811101f4 <vQCmdFEEinConfig+0x22c>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110190:	00a045f4 	movhi	r2,33047
81110194:	10a34f04 	addi	r2,r2,-29380
81110198:	10800a8b 	ldhu	r2,42(r2)
8111019c:	10bfffcc 	andi	r2,r2,65535
811101a0:	10800228 	cmpgeui	r2,r2,8
811101a4:	1000121e 	bne	r2,zero,811101f0 <vQCmdFEEinConfig+0x228>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
811101a8:	d0e06217 	ldw	r3,-32376(gp)
811101ac:	e0bffe17 	ldw	r2,-8(fp)
811101b0:	10800003 	ldbu	r2,0(r2)
811101b4:	10803fcc 	andi	r2,r2,255
811101b8:	100d883a 	mov	r6,r2
811101bc:	01604574 	movhi	r5,33045
811101c0:	297ab504 	addi	r5,r5,-5420
811101c4:	1809883a 	mov	r4,r3
811101c8:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
811101cc:	00000806 	br	811101f0 <vQCmdFEEinConfig+0x228>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
811101d0:	0001883a 	nop
811101d4:	00000706 	br	811101f4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
811101d8:	0001883a 	nop
811101dc:	00000506 	br	811101f4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
811101e0:	0001883a 	nop
811101e4:	00000306 	br	811101f4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
811101e8:	0001883a 	nop
811101ec:	00000106 	br	811101f4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
811101f0:	0001883a 	nop
		}
	}
}
811101f4:	0001883a 	nop
811101f8:	e037883a 	mov	sp,fp
811101fc:	dfc00117 	ldw	ra,4(sp)
81110200:	df000017 	ldw	fp,0(sp)
81110204:	dec00204 	addi	sp,sp,8
81110208:	f800283a 	ret

8111020c <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8111020c:	defffb04 	addi	sp,sp,-20
81110210:	de00012e 	bgeu	sp,et,81110218 <vQCmdFEEinStandBy+0xc>
81110214:	003b68fa 	trap	3
81110218:	dfc00415 	stw	ra,16(sp)
8111021c:	df000315 	stw	fp,12(sp)
81110220:	df000304 	addi	fp,sp,12
81110224:	e13ffe15 	stw	r4,-8(fp)
81110228:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8111022c:	e0bfff17 	ldw	r2,-4(fp)
81110230:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
81110234:	e0bffdc3 	ldbu	r2,-9(fp)
81110238:	10c03fcc 	andi	r3,r2,255
8111023c:	e0bffe17 	ldw	r2,-8(fp)
81110240:	10800003 	ldbu	r2,0(r2)
81110244:	10803fcc 	andi	r2,r2,255
81110248:	10800444 	addi	r2,r2,17
8111024c:	1880801e 	bne	r3,r2,81110450 <vQCmdFEEinStandBy+0x244>

		switch (uiCmdFEEL.ucByte[2]) {
81110250:	e0bffd83 	ldbu	r2,-10(fp)
81110254:	10803fcc 	andi	r2,r2,255
81110258:	10c02860 	cmpeqi	r3,r2,161
8111025c:	18001a1e 	bne	r3,zero,811102c8 <vQCmdFEEinStandBy+0xbc>
81110260:	10c02888 	cmpgei	r3,r2,162
81110264:	18000c1e 	bne	r3,zero,81110298 <vQCmdFEEinStandBy+0x8c>
81110268:	10c00120 	cmpeqi	r3,r2,4
8111026c:	18001f1e 	bne	r3,zero,811102ec <vQCmdFEEinStandBy+0xe0>
81110270:	10c00148 	cmpgei	r3,r2,5
81110274:	1800031e 	bne	r3,zero,81110284 <vQCmdFEEinStandBy+0x78>
81110278:	10800060 	cmpeqi	r2,r2,1
8111027c:	1000121e 	bne	r2,zero,811102c8 <vQCmdFEEinStandBy+0xbc>
81110280:	00005c06 	br	811103f4 <vQCmdFEEinStandBy+0x1e8>
81110284:	10c00220 	cmpeqi	r3,r2,8
81110288:	1800281e 	bne	r3,zero,8111032c <vQCmdFEEinStandBy+0x120>
8111028c:	108023e0 	cmpeqi	r2,r2,143
81110290:	10004e1e 	bne	r2,zero,811103cc <vQCmdFEEinStandBy+0x1c0>
81110294:	00005706 	br	811103f4 <vQCmdFEEinStandBy+0x1e8>
81110298:	10c03888 	cmpgei	r3,r2,226
8111029c:	1800071e 	bne	r3,zero,811102bc <vQCmdFEEinStandBy+0xb0>
811102a0:	10c03808 	cmpgei	r3,r2,224
811102a4:	18003e1e 	bne	r3,zero,811103a0 <vQCmdFEEinStandBy+0x194>
811102a8:	10c02920 	cmpeqi	r3,r2,164
811102ac:	18000f1e 	bne	r3,zero,811102ec <vQCmdFEEinStandBy+0xe0>
811102b0:	10802a20 	cmpeqi	r2,r2,168
811102b4:	10001d1e 	bne	r2,zero,8111032c <vQCmdFEEinStandBy+0x120>
811102b8:	00004e06 	br	811103f4 <vQCmdFEEinStandBy+0x1e8>
811102bc:	10803c20 	cmpeqi	r2,r2,240
811102c0:	1000241e 	bne	r2,zero,81110354 <vQCmdFEEinStandBy+0x148>
811102c4:	00004b06 	br	811103f4 <vQCmdFEEinStandBy+0x1e8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
811102c8:	e0bffe17 	ldw	r2,-8(fp)
811102cc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
811102d0:	e0bffe17 	ldw	r2,-8(fp)
811102d4:	00c00144 	movi	r3,5
811102d8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
811102dc:	e0bffe17 	ldw	r2,-8(fp)
811102e0:	00c00144 	movi	r3,5
811102e4:	10c02d15 	stw	r3,180(r2)
				break;				
811102e8:	00005906 	br	81110450 <vQCmdFEEinStandBy+0x244>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811102ec:	00a045f4 	movhi	r2,33047
811102f0:	10a34f04 	addi	r2,r2,-29380
811102f4:	10800a8b 	ldhu	r2,42(r2)
811102f8:	10bfffcc 	andi	r2,r2,65535
811102fc:	10800168 	cmpgeui	r2,r2,5
81110300:	10004c1e 	bne	r2,zero,81110434 <vQCmdFEEinStandBy+0x228>
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
81110304:	d0e06217 	ldw	r3,-32376(gp)
81110308:	e0bffe17 	ldw	r2,-8(fp)
8111030c:	10800003 	ldbu	r2,0(r2)
81110310:	10803fcc 	andi	r2,r2,255
81110314:	100d883a 	mov	r6,r2
81110318:	01604574 	movhi	r5,33045
8111031c:	297ac404 	addi	r5,r5,-5360
81110320:	1809883a 	mov	r4,r3
81110324:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
81110328:	00004206 	br	81110434 <vQCmdFEEinStandBy+0x228>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8111032c:	e0bffe17 	ldw	r2,-8(fp)
81110330:	00c00044 	movi	r3,1
81110334:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81110338:	e0bffe17 	ldw	r2,-8(fp)
8111033c:	00c00284 	movi	r3,10
81110340:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
81110344:	e0bffe17 	ldw	r2,-8(fp)
81110348:	00c00304 	movi	r3,12
8111034c:	10c02d15 	stw	r3,180(r2)
				break;
81110350:	00003f06 	br	81110450 <vQCmdFEEinStandBy+0x244>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
81110354:	e17fff17 	ldw	r5,-4(fp)
81110358:	e13ffe17 	ldw	r4,-8(fp)
8111035c:	11106f00 	call	811106f0 <vQCmdFeeRMAPinStandBy>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110360:	00a045f4 	movhi	r2,33047
81110364:	10a34f04 	addi	r2,r2,-29380
81110368:	10800a8b 	ldhu	r2,42(r2)
8111036c:	10bfffcc 	andi	r2,r2,65535
81110370:	10800168 	cmpgeui	r2,r2,5
81110374:	1000311e 	bne	r2,zero,8111043c <vQCmdFEEinStandBy+0x230>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
81110378:	d0e06217 	ldw	r3,-32376(gp)
8111037c:	e0bffe17 	ldw	r2,-8(fp)
81110380:	10800003 	ldbu	r2,0(r2)
81110384:	10803fcc 	andi	r2,r2,255
81110388:	100d883a 	mov	r6,r2
8111038c:	01604574 	movhi	r5,33045
81110390:	297ace04 	addi	r5,r5,-5320
81110394:	1809883a 	mov	r4,r3
81110398:	11236500 	call	81123650 <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8111039c:	00002706 	br	8111043c <vQCmdFEEinStandBy+0x230>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
811103a0:	e0bffe17 	ldw	r2,-8(fp)
811103a4:	10802c17 	ldw	r2,176(r2)
811103a8:	10800318 	cmpnei	r2,r2,12
811103ac:	1000251e 	bne	r2,zero,81110444 <vQCmdFEEinStandBy+0x238>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811103b0:	e0bffe17 	ldw	r2,-8(fp)
811103b4:	10c02d17 	ldw	r3,180(r2)
811103b8:	e0bffe17 	ldw	r2,-8(fp)
811103bc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
811103c0:	e0bffe17 	ldw	r2,-8(fp)
811103c4:	10002815 	stw	zero,160(r2)
				}
				break;
811103c8:	00001e06 	br	81110444 <vQCmdFEEinStandBy+0x238>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
811103cc:	e0bffe17 	ldw	r2,-8(fp)
811103d0:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
811103d4:	e0bffe17 	ldw	r2,-8(fp)
811103d8:	10800003 	ldbu	r2,0(r2)
811103dc:	10803fcc 	andi	r2,r2,255
811103e0:	100d883a 	mov	r6,r2
811103e4:	000b883a 	mov	r5,zero
811103e8:	01002044 	movi	r4,129
811103ec:	1111bf00 	call	81111bf0 <bSendGiveBackNFeeCtrl>
				break;
811103f0:	00001706 	br	81110450 <vQCmdFEEinStandBy+0x244>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811103f4:	00a045f4 	movhi	r2,33047
811103f8:	10a34f04 	addi	r2,r2,-29380
811103fc:	10800a8b 	ldhu	r2,42(r2)
81110400:	10bfffcc 	andi	r2,r2,65535
81110404:	10800228 	cmpgeui	r2,r2,8
81110408:	1000101e 	bne	r2,zero,8111044c <vQCmdFEEinStandBy+0x240>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8111040c:	d0e06217 	ldw	r3,-32376(gp)
81110410:	e0bffe17 	ldw	r2,-8(fp)
81110414:	10800003 	ldbu	r2,0(r2)
81110418:	10803fcc 	andi	r2,r2,255
8111041c:	100d883a 	mov	r6,r2
81110420:	01604574 	movhi	r5,33045
81110424:	297a7704 	addi	r5,r5,-5668
81110428:	1809883a 	mov	r4,r3
8111042c:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
81110430:	00000606 	br	8111044c <vQCmdFEEinStandBy+0x240>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
				}
				#endif
				break;
81110434:	0001883a 	nop
81110438:	00000506 	br	81110450 <vQCmdFEEinStandBy+0x244>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8111043c:	0001883a 	nop
81110440:	00000306 	br	81110450 <vQCmdFEEinStandBy+0x244>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
81110444:	0001883a 	nop
81110448:	00000106 	br	81110450 <vQCmdFEEinStandBy+0x244>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8111044c:	0001883a 	nop
		}
	}
}
81110450:	0001883a 	nop
81110454:	e037883a 	mov	sp,fp
81110458:	dfc00117 	ldw	ra,4(sp)
8111045c:	df000017 	ldw	fp,0(sp)
81110460:	dec00204 	addi	sp,sp,8
81110464:	f800283a 	ret

81110468 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
81110468:	defffb04 	addi	sp,sp,-20
8111046c:	de00012e 	bgeu	sp,et,81110474 <vQCmdFEEinFullPattern+0xc>
81110470:	003b68fa 	trap	3
81110474:	dfc00415 	stw	ra,16(sp)
81110478:	df000315 	stw	fp,12(sp)
8111047c:	df000304 	addi	fp,sp,12
81110480:	e13ffe15 	stw	r4,-8(fp)
81110484:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
81110488:	e0bfff17 	ldw	r2,-4(fp)
8111048c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
81110490:	e0bffdc3 	ldbu	r2,-9(fp)
81110494:	10c03fcc 	andi	r3,r2,255
81110498:	e0bffe17 	ldw	r2,-8(fp)
8111049c:	10800003 	ldbu	r2,0(r2)
811104a0:	10803fcc 	andi	r2,r2,255
811104a4:	10800444 	addi	r2,r2,17
811104a8:	18808b1e 	bne	r3,r2,811106d8 <vQCmdFEEinFullPattern+0x270>

		switch (uiCmdFEEL.ucByte[2]) {
811104ac:	e0bffd83 	ldbu	r2,-10(fp)
811104b0:	10803fcc 	andi	r2,r2,255
811104b4:	10c02860 	cmpeqi	r3,r2,161
811104b8:	1800181e 	bne	r3,zero,8111051c <vQCmdFEEinFullPattern+0xb4>
811104bc:	10c02888 	cmpgei	r3,r2,162
811104c0:	18000c1e 	bne	r3,zero,811104f4 <vQCmdFEEinFullPattern+0x8c>
811104c4:	10c000a0 	cmpeqi	r3,r2,2
811104c8:	18007c1e 	bne	r3,zero,811106bc <vQCmdFEEinFullPattern+0x254>
811104cc:	10c000c8 	cmpgei	r3,r2,3
811104d0:	1800031e 	bne	r3,zero,811104e0 <vQCmdFEEinFullPattern+0x78>
811104d4:	10800060 	cmpeqi	r2,r2,1
811104d8:	1000101e 	bne	r2,zero,8111051c <vQCmdFEEinFullPattern+0xb4>
811104dc:	00006706 	br	8111067c <vQCmdFEEinFullPattern+0x214>
811104e0:	10c00120 	cmpeqi	r3,r2,4
811104e4:	1800161e 	bne	r3,zero,81110540 <vQCmdFEEinFullPattern+0xd8>
811104e8:	10800220 	cmpeqi	r2,r2,8
811104ec:	1000351e 	bne	r2,zero,811105c4 <vQCmdFEEinFullPattern+0x15c>
811104f0:	00006206 	br	8111067c <vQCmdFEEinFullPattern+0x214>
811104f4:	10c03888 	cmpgei	r3,r2,226
811104f8:	1800051e 	bne	r3,zero,81110510 <vQCmdFEEinFullPattern+0xa8>
811104fc:	10c03808 	cmpgei	r3,r2,224
81110500:	1800531e 	bne	r3,zero,81110650 <vQCmdFEEinFullPattern+0x1e8>
81110504:	10802920 	cmpeqi	r2,r2,164
81110508:	1000251e 	bne	r2,zero,811105a0 <vQCmdFEEinFullPattern+0x138>
8111050c:	00005b06 	br	8111067c <vQCmdFEEinFullPattern+0x214>
81110510:	10803c20 	cmpeqi	r2,r2,240
81110514:	10003b1e 	bne	r2,zero,81110604 <vQCmdFEEinFullPattern+0x19c>
81110518:	00005806 	br	8111067c <vQCmdFEEinFullPattern+0x214>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8111051c:	e0bffe17 	ldw	r2,-8(fp)
81110520:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
81110524:	e0bffe17 	ldw	r2,-8(fp)
81110528:	00c00144 	movi	r3,5
8111052c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
81110530:	e0bffe17 	ldw	r2,-8(fp)
81110534:	00c00144 	movi	r3,5
81110538:	10c02d15 	stw	r3,180(r2)
				break;				
8111053c:	00006606 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
81110540:	e0bffe17 	ldw	r2,-8(fp)
81110544:	10802c17 	ldw	r2,176(r2)
81110548:	10800298 	cmpnei	r2,r2,10
8111054c:	10000a1e 	bne	r2,zero,81110578 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
81110550:	e0bffe17 	ldw	r2,-8(fp)
81110554:	00c00044 	movi	r3,1
81110558:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8111055c:	e0bffe17 	ldw	r2,-8(fp)
81110560:	00c00304 	movi	r3,12
81110564:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110568:	e0bffe17 	ldw	r2,-8(fp)
8111056c:	00c00184 	movi	r3,6
81110570:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
81110574:	00005806 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
81110578:	e0bffe17 	ldw	r2,-8(fp)
8111057c:	00c00044 	movi	r3,1
81110580:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
81110584:	e0bffe17 	ldw	r2,-8(fp)
81110588:	00c00104 	movi	r3,4
8111058c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110590:	e0bffe17 	ldw	r2,-8(fp)
81110594:	00c00184 	movi	r3,6
81110598:	10c02d15 	stw	r3,180(r2)
				}

				break;
8111059c:	00004e06 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
811105a0:	e0bffe17 	ldw	r2,-8(fp)
811105a4:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
811105a8:	e0bffe17 	ldw	r2,-8(fp)
811105ac:	00c00184 	movi	r3,6
811105b0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
811105b4:	e0bffe17 	ldw	r2,-8(fp)
811105b8:	00c00184 	movi	r3,6
811105bc:	10c02d15 	stw	r3,180(r2)
				break;				
811105c0:	00004506 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811105c4:	00a045f4 	movhi	r2,33047
811105c8:	10a34f04 	addi	r2,r2,-29380
811105cc:	10800a8b 	ldhu	r2,42(r2)
811105d0:	10bfffcc 	andi	r2,r2,65535
811105d4:	10800168 	cmpgeui	r2,r2,5
811105d8:	10003a1e 	bne	r2,zero,811106c4 <vQCmdFEEinFullPattern+0x25c>
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811105dc:	d0e06217 	ldw	r3,-32376(gp)
811105e0:	e0bffe17 	ldw	r2,-8(fp)
811105e4:	10800003 	ldbu	r2,0(r2)
811105e8:	10803fcc 	andi	r2,r2,255
811105ec:	100d883a 	mov	r6,r2
811105f0:	01604574 	movhi	r5,33045
811105f4:	297ad604 	addi	r5,r5,-5288
811105f8:	1809883a 	mov	r4,r3
811105fc:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
81110600:	00003006 	br	811106c4 <vQCmdFEEinFullPattern+0x25c>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110604:	00a045f4 	movhi	r2,33047
81110608:	10a34f04 	addi	r2,r2,-29380
8111060c:	10800a8b 	ldhu	r2,42(r2)
81110610:	10bfffcc 	andi	r2,r2,65535
81110614:	10800168 	cmpgeui	r2,r2,5
81110618:	1000091e 	bne	r2,zero,81110640 <vQCmdFEEinFullPattern+0x1d8>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8111061c:	d0e06217 	ldw	r3,-32376(gp)
81110620:	e0bffe17 	ldw	r2,-8(fp)
81110624:	10800003 	ldbu	r2,0(r2)
81110628:	10803fcc 	andi	r2,r2,255
8111062c:	100d883a 	mov	r6,r2
81110630:	01604574 	movhi	r5,33045
81110634:	297ace04 	addi	r5,r5,-5320
81110638:	1809883a 	mov	r4,r3
8111063c:	11236500 	call	81123650 <fprintf>
				}
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
81110640:	e17fff17 	ldw	r5,-4(fp)
81110644:	e13ffe17 	ldw	r4,-8(fp)
81110648:	1110d740 	call	81110d74 <vQCmdFeeRMAPinFullPattern>

				break;
8111064c:	00002206 	br	811106d8 <vQCmdFEEinFullPattern+0x270>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
81110650:	e0bffe17 	ldw	r2,-8(fp)
81110654:	10802c17 	ldw	r2,176(r2)
81110658:	10800318 	cmpnei	r2,r2,12
8111065c:	10001b1e 	bne	r2,zero,811106cc <vQCmdFEEinFullPattern+0x264>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110660:	e0bffe17 	ldw	r2,-8(fp)
81110664:	10c02d17 	ldw	r3,180(r2)
81110668:	e0bffe17 	ldw	r2,-8(fp)
8111066c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
81110670:	e0bffe17 	ldw	r2,-8(fp)
81110674:	10002815 	stw	zero,160(r2)
				}

				break;
81110678:	00001406 	br	811106cc <vQCmdFEEinFullPattern+0x264>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111067c:	00a045f4 	movhi	r2,33047
81110680:	10a34f04 	addi	r2,r2,-29380
81110684:	10800a8b 	ldhu	r2,42(r2)
81110688:	10bfffcc 	andi	r2,r2,65535
8111068c:	10800228 	cmpgeui	r2,r2,8
81110690:	1000101e 	bne	r2,zero,811106d4 <vQCmdFEEinFullPattern+0x26c>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
81110694:	d0e06217 	ldw	r3,-32376(gp)
81110698:	e0bffe17 	ldw	r2,-8(fp)
8111069c:	10800003 	ldbu	r2,0(r2)
811106a0:	10803fcc 	andi	r2,r2,255
811106a4:	100d883a 	mov	r6,r2
811106a8:	01604574 	movhi	r5,33045
811106ac:	297ae404 	addi	r5,r5,-5232
811106b0:	1809883a 	mov	r4,r3
811106b4:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
811106b8:	00000606 	br	811106d4 <vQCmdFEEinFullPattern+0x26c>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
811106bc:	0001883a 	nop
811106c0:	00000506 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
811106c4:	0001883a 	nop
811106c8:	00000306 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
811106cc:	0001883a 	nop
811106d0:	00000106 	br	811106d8 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
811106d4:	0001883a 	nop
		}
	}
}
811106d8:	0001883a 	nop
811106dc:	e037883a 	mov	sp,fp
811106e0:	dfc00117 	ldw	ra,4(sp)
811106e4:	df000017 	ldw	fp,0(sp)
811106e8:	dec00204 	addi	sp,sp,8
811106ec:	f800283a 	ret

811106f0 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
811106f0:	defff704 	addi	sp,sp,-36
811106f4:	de00012e 	bgeu	sp,et,811106fc <vQCmdFeeRMAPinStandBy+0xc>
811106f8:	003b68fa 	trap	3
811106fc:	dfc00815 	stw	ra,32(sp)
81110700:	df000715 	stw	fp,28(sp)
81110704:	df000704 	addi	fp,sp,28
81110708:	e13ffe15 	stw	r4,-8(fp)
8111070c:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110710:	00a045f4 	movhi	r2,33047
81110714:	10a34f04 	addi	r2,r2,-29380
81110718:	10800a8b 	ldhu	r2,42(r2)
8111071c:	10bfffcc 	andi	r2,r2,65535
81110720:	108000e8 	cmpgeui	r2,r2,3
81110724:	1000091e 	bne	r2,zero,8111074c <vQCmdFeeRMAPinStandBy+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
81110728:	d0e06217 	ldw	r3,-32376(gp)
8111072c:	e0bffe17 	ldw	r2,-8(fp)
81110730:	10800003 	ldbu	r2,0(r2)
81110734:	10803fcc 	andi	r2,r2,255
81110738:	100d883a 	mov	r6,r2
8111073c:	01604574 	movhi	r5,33045
81110740:	297af504 	addi	r5,r5,-5164
81110744:	1809883a 	mov	r4,r3
81110748:	11236500 	call	81123650 <fprintf>
	}
#endif


	uiCmdFEEL.ulWord = cmd;
8111074c:	e0bfff17 	ldw	r2,-4(fp)
81110750:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
81110754:	e0bffd43 	ldbu	r2,-11(fp)
81110758:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8111075c:	e0bffe17 	ldw	r2,-8(fp)
81110760:	10804517 	ldw	r2,276(r2)
81110764:	e0fff903 	ldbu	r3,-28(fp)
81110768:	180b883a 	mov	r5,r3
8111076c:	1009883a 	mov	r4,r2
81110770:	110a86c0 	call	8110a86c <uliRmapReadReg>
81110774:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
81110778:	e0bff903 	ldbu	r2,-28(fp)
8111077c:	10bff004 	addi	r2,r2,-64
81110780:	10c003a8 	cmpgeui	r3,r2,14
81110784:	18015e1e 	bne	r3,zero,81110d00 <vQCmdFeeRMAPinStandBy+0x610>
81110788:	100690ba 	slli	r3,r2,2
8111078c:	00a04474 	movhi	r2,33041
81110790:	1081e804 	addi	r2,r2,1952
81110794:	1885883a 	add	r2,r3,r2
81110798:	10800017 	ldw	r2,0(r2)
8111079c:	1000683a 	jmp	r2
811107a0:	811107d8 	cmpnei	r4,r16,17439
811107a4:	81110d38 	rdprs	r4,r16,17460
811107a8:	811108c4 	addi	r4,r16,17443
811107ac:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107b0:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107b4:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107b8:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107bc:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107c0:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107c4:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107c8:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107cc:	81110b00 	call	881110b0 <__reset+0x20f10b0>
811107d0:	81110b38 	rdprs	r4,r16,17452
811107d4:	81110c78 	rdprs	r4,r16,17457
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
811107d8:	e0fffa17 	ldw	r3,-24(fp)
811107dc:	00800434 	movhi	r2,16
811107e0:	10bffc04 	addi	r2,r2,-16
811107e4:	1884703a 	and	r2,r3,r2
811107e8:	1004d13a 	srli	r2,r2,4
811107ec:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
811107f0:	e0bffa17 	ldw	r2,-24(fp)
811107f4:	1004d53a 	srli	r2,r2,20
811107f8:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
811107fc:	e0bffb17 	ldw	r2,-20(fp)
81110800:	1007883a 	mov	r3,r2
81110804:	e0bffe17 	ldw	r2,-8(fp)
81110808:	1080300b 	ldhu	r2,192(r2)
8111080c:	1885c83a 	sub	r2,r3,r2
81110810:	1007883a 	mov	r3,r2
81110814:	e0bffe17 	ldw	r2,-8(fp)
81110818:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8111081c:	e0bffc17 	ldw	r2,-16(fp)
81110820:	1009883a 	mov	r4,r2
81110824:	e0bffe17 	ldw	r2,-8(fp)
81110828:	10c02f8b 	ldhu	r3,190(r2)
8111082c:	e0bffe17 	ldw	r2,-8(fp)
81110830:	10802f0b 	ldhu	r2,188(r2)
81110834:	1885883a 	add	r2,r3,r2
81110838:	2085c83a 	sub	r2,r4,r2
8111083c:	1007883a 	mov	r3,r2
81110840:	e0bffe17 	ldw	r2,-8(fp)
81110844:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
81110848:	e13ffe17 	ldw	r4,-8(fp)
8111084c:	111fbfc0 	call	8111fbfc <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
81110850:	e0bffe17 	ldw	r2,-8(fp)
81110854:	10803304 	addi	r2,r2,204
81110858:	1009883a 	mov	r4,r2
8111085c:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
81110860:	e0bffe17 	ldw	r2,-8(fp)
81110864:	10c0300b 	ldhu	r3,192(r2)
81110868:	e0bffe17 	ldw	r2,-8(fp)
8111086c:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
81110870:	e0bffc17 	ldw	r2,-16(fp)
81110874:	1007883a 	mov	r3,r2
81110878:	e0bffe17 	ldw	r2,-8(fp)
8111087c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
81110880:	e0bffb17 	ldw	r2,-20(fp)
81110884:	1007883a 	mov	r3,r2
81110888:	e0bffe17 	ldw	r2,-8(fp)
8111088c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
81110890:	e0bffb17 	ldw	r2,-20(fp)
81110894:	1007883a 	mov	r3,r2
81110898:	e0bffe17 	ldw	r2,-8(fp)
8111089c:	1080300b 	ldhu	r2,192(r2)
811108a0:	1885c83a 	sub	r2,r3,r2
811108a4:	1007883a 	mov	r3,r2
811108a8:	e0bffe17 	ldw	r2,-8(fp)
811108ac:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
811108b0:	e0bffe17 	ldw	r2,-8(fp)
811108b4:	10803304 	addi	r2,r2,204
811108b8:	1009883a 	mov	r4,r2
811108bc:	11049240 	call	81104924 <bDpktSetPacketConfig>

			break;
811108c0:	00012606 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
811108c4:	e0fffa17 	ldw	r3,-24(fp)
811108c8:	00800434 	movhi	r2,16
811108cc:	10bffc04 	addi	r2,r2,-16
811108d0:	1884703a 	and	r2,r3,r2
811108d4:	1004d13a 	srli	r2,r2,4
811108d8:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
811108dc:	e0bffe17 	ldw	r2,-8(fp)
811108e0:	10803304 	addi	r2,r2,204
811108e4:	1009883a 	mov	r4,r2
811108e8:	1104bc80 	call	81104bc8 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
811108ec:	e0bffb17 	ldw	r2,-20(fp)
811108f0:	1007883a 	mov	r3,r2
811108f4:	e0bffe17 	ldw	r2,-8(fp)
811108f8:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
811108fc:	e0bffe17 	ldw	r2,-8(fp)
81110900:	10803304 	addi	r2,r2,204
81110904:	1009883a 	mov	r4,r2
81110908:	11049240 	call	81104924 <bDpktSetPacketConfig>

			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111090c:	00a045f4 	movhi	r2,33047
81110910:	10a34f04 	addi	r2,r2,-29380
81110914:	10800a8b 	ldhu	r2,42(r2)
81110918:	10bfffcc 	andi	r2,r2,65535
8111091c:	108000e8 	cmpgeui	r2,r2,3
81110920:	1000061e 	bne	r2,zero,8111093c <vQCmdFeeRMAPinStandBy+0x24c>
				fprintf(fp,"- Pckt Length: %lu\n", ucValueMasked);
81110924:	d0a06217 	ldw	r2,-32376(gp)
81110928:	e1bffb17 	ldw	r6,-20(fp)
8111092c:	01604574 	movhi	r5,33045
81110930:	297b0104 	addi	r5,r5,-5116
81110934:	1009883a 	mov	r4,r2
81110938:	11236500 	call	81123650 <fprintf>
			}
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8111093c:	e0bffa17 	ldw	r2,-24(fp)
81110940:	1080030c 	andi	r2,r2,12
81110944:	1004d0ba 	srli	r2,r2,2
81110948:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8111094c:	e0bffc17 	ldw	r2,-16(fp)
81110950:	10c000a0 	cmpeqi	r3,r2,2
81110954:	1800141e 	bne	r3,zero,811109a8 <vQCmdFeeRMAPinStandBy+0x2b8>
81110958:	10c000e0 	cmpeqi	r3,r2,3
8111095c:	1800231e 	bne	r3,zero,811109ec <vQCmdFeeRMAPinStandBy+0x2fc>
81110960:	10800060 	cmpeqi	r2,r2,1
81110964:	10003026 	beq	r2,zero,81110a28 <vQCmdFeeRMAPinStandBy+0x338>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
81110968:	e0bffe17 	ldw	r2,-8(fp)
8111096c:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110970:	00a045f4 	movhi	r2,33047
81110974:	10a34f04 	addi	r2,r2,-29380
81110978:	10800a8b 	ldhu	r2,42(r2)
8111097c:	10bfffcc 	andi	r2,r2,65535
81110980:	108000e8 	cmpgeui	r2,r2,3
81110984:	1000461e 	bne	r2,zero,81110aa0 <vQCmdFeeRMAPinStandBy+0x3b0>
						fprintf(fp," - Left side\n");
81110988:	d0a06217 	ldw	r2,-32376(gp)
8111098c:	100f883a 	mov	r7,r2
81110990:	01800344 	movi	r6,13
81110994:	01400044 	movi	r5,1
81110998:	01204574 	movhi	r4,33045
8111099c:	213b0604 	addi	r4,r4,-5096
811109a0:	1123cec0 	call	81123cec <fwrite>
					}
					#endif
					break;
811109a4:	00003e06 	br	81110aa0 <vQCmdFeeRMAPinStandBy+0x3b0>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
811109a8:	e0bffe17 	ldw	r2,-8(fp)
811109ac:	00c00044 	movi	r3,1
811109b0:	10c02e15 	stw	r3,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811109b4:	00a045f4 	movhi	r2,33047
811109b8:	10a34f04 	addi	r2,r2,-29380
811109bc:	10800a8b 	ldhu	r2,42(r2)
811109c0:	10bfffcc 	andi	r2,r2,65535
811109c4:	108000e8 	cmpgeui	r2,r2,3
811109c8:	1000371e 	bne	r2,zero,81110aa8 <vQCmdFeeRMAPinStandBy+0x3b8>
						fprintf(fp," - Right side\n");
811109cc:	d0a06217 	ldw	r2,-32376(gp)
811109d0:	100f883a 	mov	r7,r2
811109d4:	01800384 	movi	r6,14
811109d8:	01400044 	movi	r5,1
811109dc:	01204574 	movhi	r4,33045
811109e0:	213b0a04 	addi	r4,r4,-5080
811109e4:	1123cec0 	call	81123cec <fwrite>
					}
					#endif
					break;
811109e8:	00002f06 	br	81110aa8 <vQCmdFeeRMAPinStandBy+0x3b8>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
811109ec:	e0bffe17 	ldw	r2,-8(fp)
811109f0:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811109f4:	00a045f4 	movhi	r2,33047
811109f8:	10a34f04 	addi	r2,r2,-29380
811109fc:	10800a8b 	ldhu	r2,42(r2)
81110a00:	10bfffcc 	andi	r2,r2,65535
81110a04:	108000e8 	cmpgeui	r2,r2,3
81110a08:	1000071e 	bne	r2,zero,81110a28 <vQCmdFeeRMAPinStandBy+0x338>
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81110a0c:	d0a06217 	ldw	r2,-32376(gp)
81110a10:	100f883a 	mov	r7,r2
81110a14:	01800f44 	movi	r6,61
81110a18:	01400044 	movi	r5,1
81110a1c:	01204574 	movhi	r4,33045
81110a20:	213b0e04 	addi	r4,r4,-5064
81110a24:	1123cec0 	call	81123cec <fwrite>
					}
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
81110a28:	e0bffe17 	ldw	r2,-8(fp)
81110a2c:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110a30:	e0bffe17 	ldw	r2,-8(fp)
81110a34:	10804504 	addi	r2,r2,276
81110a38:	1009883a 	mov	r4,r2
81110a3c:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110a40:	e0bffe17 	ldw	r2,-8(fp)
81110a44:	10c05917 	ldw	r3,356(r2)
81110a48:	00bffdc4 	movi	r2,-9
81110a4c:	1886703a 	and	r3,r3,r2
81110a50:	e0bffe17 	ldw	r2,-8(fp)
81110a54:	10c05915 	stw	r3,356(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110a58:	e0bffe17 	ldw	r2,-8(fp)
81110a5c:	10804504 	addi	r2,r2,276
81110a60:	1009883a 	mov	r4,r2
81110a64:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110a68:	00a045f4 	movhi	r2,33047
81110a6c:	10a34f04 	addi	r2,r2,-29380
81110a70:	10800a8b 	ldhu	r2,42(r2)
81110a74:	10bfffcc 	andi	r2,r2,65535
81110a78:	108000e8 	cmpgeui	r2,r2,3
81110a7c:	10000c1e 	bne	r2,zero,81110ab0 <vQCmdFeeRMAPinStandBy+0x3c0>
						fprintf(fp," - Switching to Left side\n");
81110a80:	d0a06217 	ldw	r2,-32376(gp)
81110a84:	100f883a 	mov	r7,r2
81110a88:	01800684 	movi	r6,26
81110a8c:	01400044 	movi	r5,1
81110a90:	01204574 	movhi	r4,33045
81110a94:	213b1e04 	addi	r4,r4,-5000
81110a98:	1123cec0 	call	81123cec <fwrite>
					}
					#endif
					break;
81110a9c:	00000406 	br	81110ab0 <vQCmdFeeRMAPinStandBy+0x3c0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Left side\n");
					}
					#endif
					break;
81110aa0:	0001883a 	nop
81110aa4:	00000306 	br	81110ab4 <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Right side\n");
					}
					#endif
					break;
81110aa8:	0001883a 	nop
81110aac:	00000106 	br	81110ab4 <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Switching to Left side\n");
					}
					#endif
					break;
81110ab0:	0001883a 	nop
				}
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110ab4:	00a045f4 	movhi	r2,33047
81110ab8:	10a34f04 	addi	r2,r2,-29380
81110abc:	10800a8b 	ldhu	r2,42(r2)
81110ac0:	10bfffcc 	andi	r2,r2,65535
81110ac4:	10800168 	cmpgeui	r2,r2,5
81110ac8:	10009d1e 	bne	r2,zero,81110d40 <vQCmdFeeRMAPinStandBy+0x650>
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110acc:	d0e06217 	ldw	r3,-32376(gp)
81110ad0:	e0bffe17 	ldw	r2,-8(fp)
81110ad4:	10800003 	ldbu	r2,0(r2)
81110ad8:	11003fcc 	andi	r4,r2,255
81110adc:	e0bffe17 	ldw	r2,-8(fp)
81110ae0:	10802e17 	ldw	r2,184(r2)
81110ae4:	100f883a 	mov	r7,r2
81110ae8:	200d883a 	mov	r6,r4
81110aec:	01604574 	movhi	r5,33045
81110af0:	297b2504 	addi	r5,r5,-4972
81110af4:	1809883a 	mov	r4,r3
81110af8:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
81110afc:	00009006 	br	81110d40 <vQCmdFeeRMAPinStandBy+0x650>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110b00:	00a045f4 	movhi	r2,33047
81110b04:	10a34f04 	addi	r2,r2,-29380
81110b08:	10800a8b 	ldhu	r2,42(r2)
81110b0c:	10bfffcc 	andi	r2,r2,65535
81110b10:	10800168 	cmpgeui	r2,r2,5
81110b14:	10008c1e 	bne	r2,zero,81110d48 <vQCmdFeeRMAPinStandBy+0x658>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81110b18:	d0a06217 	ldw	r2,-32376(gp)
81110b1c:	e0fff903 	ldbu	r3,-28(fp)
81110b20:	180d883a 	mov	r6,r3
81110b24:	01604574 	movhi	r5,33045
81110b28:	297b3304 	addi	r5,r5,-4916
81110b2c:	1009883a 	mov	r4,r2
81110b30:	11236500 	call	81123650 <fprintf>
			}
			#endif
				break;
81110b34:	00008406 	br	81110d48 <vQCmdFeeRMAPinStandBy+0x658>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110b38:	e0bffa17 	ldw	r2,-24(fp)
81110b3c:	10803c0c 	andi	r2,r2,240
81110b40:	1004d13a 	srli	r2,r2,4
81110b44:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
81110b48:	e0bffb17 	ldw	r2,-20(fp)
81110b4c:	10c000a0 	cmpeqi	r3,r2,2
81110b50:	1800111e 	bne	r3,zero,81110b98 <vQCmdFeeRMAPinStandBy+0x4a8>
81110b54:	10c001a0 	cmpeqi	r3,r2,6
81110b58:	1800261e 	bne	r3,zero,81110bf4 <vQCmdFeeRMAPinStandBy+0x504>
81110b5c:	1000331e 	bne	r2,zero,81110c2c <vQCmdFeeRMAPinStandBy+0x53c>
				case 0: /* Standby */

				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110b60:	00a045f4 	movhi	r2,33047
81110b64:	10a34f04 	addi	r2,r2,-29380
81110b68:	10800a8b 	ldhu	r2,42(r2)
81110b6c:	10bfffcc 	andi	r2,r2,65535
81110b70:	10800168 	cmpgeui	r2,r2,5
81110b74:	10003a1e 	bne	r2,zero,81110c60 <vQCmdFeeRMAPinStandBy+0x570>
						fprintf(fp,"- already in Stand by mode\n");
81110b78:	d0a06217 	ldw	r2,-32376(gp)
81110b7c:	100f883a 	mov	r7,r2
81110b80:	018006c4 	movi	r6,27
81110b84:	01400044 	movi	r5,1
81110b88:	01204574 	movhi	r4,33045
81110b8c:	213b3c04 	addi	r4,r4,-4880
81110b90:	1123cec0 	call	81123cec <fwrite>
					}
				#endif

					break;
81110b94:	00003206 	br	81110c60 <vQCmdFeeRMAPinStandBy+0x570>
				case 2: /* PAttern Full image */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110b98:	00a045f4 	movhi	r2,33047
81110b9c:	10a34f04 	addi	r2,r2,-29380
81110ba0:	10800a8b 	ldhu	r2,42(r2)
81110ba4:	10bfffcc 	andi	r2,r2,65535
81110ba8:	10800168 	cmpgeui	r2,r2,5
81110bac:	1000071e 	bne	r2,zero,81110bcc <vQCmdFeeRMAPinStandBy+0x4dc>
						fprintf(fp,"- to Full-Image-Pattern\n");
81110bb0:	d0a06217 	ldw	r2,-32376(gp)
81110bb4:	100f883a 	mov	r7,r2
81110bb8:	01800604 	movi	r6,24
81110bbc:	01400044 	movi	r5,1
81110bc0:	01204574 	movhi	r4,33045
81110bc4:	213b4304 	addi	r4,r4,-4852
81110bc8:	1123cec0 	call	81123cec <fwrite>
					}
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
81110bcc:	e0bffe17 	ldw	r2,-8(fp)
81110bd0:	00c00044 	movi	r3,1
81110bd4:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81110bd8:	e0bffe17 	ldw	r2,-8(fp)
81110bdc:	00c00284 	movi	r3,10
81110be0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
81110be4:	e0bffe17 	ldw	r2,-8(fp)
81110be8:	00c00304 	movi	r3,12
81110bec:	10c02d15 	stw	r3,180(r2)

					break;
81110bf0:	00002006 	br	81110c74 <vQCmdFeeRMAPinStandBy+0x584>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110bf4:	00a045f4 	movhi	r2,33047
81110bf8:	10a34f04 	addi	r2,r2,-29380
81110bfc:	10800a8b 	ldhu	r2,42(r2)
81110c00:	10bfffcc 	andi	r2,r2,65535
81110c04:	10800168 	cmpgeui	r2,r2,5
81110c08:	1000171e 	bne	r2,zero,81110c68 <vQCmdFeeRMAPinStandBy+0x578>
						fprintf(fp,"- Off-Mode not allowed.\n");
81110c0c:	d0a06217 	ldw	r2,-32376(gp)
81110c10:	100f883a 	mov	r7,r2
81110c14:	01800604 	movi	r6,24
81110c18:	01400044 	movi	r5,1
81110c1c:	01204574 	movhi	r4,33045
81110c20:	213b4a04 	addi	r4,r4,-4824
81110c24:	1123cec0 	call	81123cec <fwrite>
					}
				#endif
					break;
81110c28:	00000f06 	br	81110c68 <vQCmdFeeRMAPinStandBy+0x578>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110c2c:	00a045f4 	movhi	r2,33047
81110c30:	10a34f04 	addi	r2,r2,-29380
81110c34:	10800a8b 	ldhu	r2,42(r2)
81110c38:	10bfffcc 	andi	r2,r2,65535
81110c3c:	10800228 	cmpgeui	r2,r2,8
81110c40:	10000b1e 	bne	r2,zero,81110c70 <vQCmdFeeRMAPinStandBy+0x580>
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
81110c44:	d0a06217 	ldw	r2,-32376(gp)
81110c48:	e1bffb17 	ldw	r6,-20(fp)
81110c4c:	01604574 	movhi	r5,33045
81110c50:	297b5104 	addi	r5,r5,-4796
81110c54:	1009883a 	mov	r4,r2
81110c58:	11236500 	call	81123650 <fprintf>
					}
					#endif
					break;
81110c5c:	00000406 	br	81110c70 <vQCmdFeeRMAPinStandBy+0x580>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- already in Stand by mode\n");
					}
				#endif

					break;
81110c60:	0001883a 	nop
81110c64:	00003d06 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- Off-Mode not allowed.\n");
					}
				#endif
					break;
81110c68:	0001883a 	nop
81110c6c:	00003b06 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81110c70:	0001883a 	nop
			}

			break;
81110c74:	00003906 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110c78:	e0bffa17 	ldw	r2,-24(fp)
81110c7c:	1080010c 	andi	r2,r2,4
81110c80:	1004d0ba 	srli	r2,r2,2
81110c84:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
81110c88:	e0bffb17 	ldw	r2,-20(fp)
81110c8c:	10003026 	beq	r2,zero,81110d50 <vQCmdFeeRMAPinStandBy+0x660>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c90:	00a045f4 	movhi	r2,33047
81110c94:	10a34f04 	addi	r2,r2,-29380
81110c98:	10800a8b 	ldhu	r2,42(r2)
81110c9c:	10bfffcc 	andi	r2,r2,65535
81110ca0:	10800168 	cmpgeui	r2,r2,5
81110ca4:	1000071e 	bne	r2,zero,81110cc4 <vQCmdFeeRMAPinStandBy+0x5d4>
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
81110ca8:	d0a06217 	ldw	r2,-32376(gp)
81110cac:	100f883a 	mov	r7,r2
81110cb0:	01800a04 	movi	r6,40
81110cb4:	01400044 	movi	r5,1
81110cb8:	01204574 	movhi	r4,33045
81110cbc:	213b5904 	addi	r4,r4,-4764
81110cc0:	1123cec0 	call	81123cec <fwrite>
				}
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110cc4:	e0bffe17 	ldw	r2,-8(fp)
81110cc8:	10804504 	addi	r2,r2,276
81110ccc:	1009883a 	mov	r4,r2
81110cd0:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
81110cd4:	e0bffe17 	ldw	r2,-8(fp)
81110cd8:	10c06417 	ldw	r3,400(r2)
81110cdc:	00bffec4 	movi	r2,-5
81110ce0:	1886703a 	and	r3,r3,r2
81110ce4:	e0bffe17 	ldw	r2,-8(fp)
81110ce8:	10c06415 	stw	r3,400(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110cec:	e0bffe17 	ldw	r2,-8(fp)
81110cf0:	10804504 	addi	r2,r2,276
81110cf4:	1009883a 	mov	r4,r2
81110cf8:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>
			}

			break;
81110cfc:	00001406 	br	81110d50 <vQCmdFeeRMAPinStandBy+0x660>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110d00:	00a045f4 	movhi	r2,33047
81110d04:	10a34f04 	addi	r2,r2,-29380
81110d08:	10800a8b 	ldhu	r2,42(r2)
81110d0c:	10bfffcc 	andi	r2,r2,65535
81110d10:	10800228 	cmpgeui	r2,r2,8
81110d14:	1000101e 	bne	r2,zero,81110d58 <vQCmdFeeRMAPinStandBy+0x668>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110d18:	d0a06217 	ldw	r2,-32376(gp)
81110d1c:	e0fff903 	ldbu	r3,-28(fp)
81110d20:	180d883a 	mov	r6,r3
81110d24:	01604574 	movhi	r5,33045
81110d28:	297b6404 	addi	r5,r5,-4720
81110d2c:	1009883a 	mov	r4,r2
81110d30:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
81110d34:	00000806 	br	81110d58 <vQCmdFeeRMAPinStandBy+0x668>
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
81110d38:	0001883a 	nop
81110d3c:	00000706 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
			}
			#endif
			break;
81110d40:	0001883a 	nop
81110d44:	00000506 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
81110d48:	0001883a 	nop
81110d4c:	00000306 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110d50:	0001883a 	nop
81110d54:	00000106 	br	81110d5c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81110d58:	0001883a 	nop
		}
}
81110d5c:	0001883a 	nop
81110d60:	e037883a 	mov	sp,fp
81110d64:	dfc00117 	ldw	ra,4(sp)
81110d68:	df000017 	ldw	fp,0(sp)
81110d6c:	dec00204 	addi	sp,sp,8
81110d70:	f800283a 	ret

81110d74 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
81110d74:	defff804 	addi	sp,sp,-32
81110d78:	de00012e 	bgeu	sp,et,81110d80 <vQCmdFeeRMAPinFullPattern+0xc>
81110d7c:	003b68fa 	trap	3
81110d80:	dfc00715 	stw	ra,28(sp)
81110d84:	df000615 	stw	fp,24(sp)
81110d88:	df000604 	addi	fp,sp,24
81110d8c:	e13ffe15 	stw	r4,-8(fp)
81110d90:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110d94:	00a045f4 	movhi	r2,33047
81110d98:	10a34f04 	addi	r2,r2,-29380
81110d9c:	10800a8b 	ldhu	r2,42(r2)
81110da0:	10bfffcc 	andi	r2,r2,65535
81110da4:	108000e8 	cmpgeui	r2,r2,3
81110da8:	1000091e 	bne	r2,zero,81110dd0 <vQCmdFeeRMAPinFullPattern+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
81110dac:	d0e06217 	ldw	r3,-32376(gp)
81110db0:	e0bffe17 	ldw	r2,-8(fp)
81110db4:	10800003 	ldbu	r2,0(r2)
81110db8:	10803fcc 	andi	r2,r2,255
81110dbc:	100d883a 	mov	r6,r2
81110dc0:	01604574 	movhi	r5,33045
81110dc4:	297b6d04 	addi	r5,r5,-4684
81110dc8:	1809883a 	mov	r4,r3
81110dcc:	11236500 	call	81123650 <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
81110dd0:	e0bfff17 	ldw	r2,-4(fp)
81110dd4:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
81110dd8:	e0bffd43 	ldbu	r2,-11(fp)
81110ddc:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
81110de0:	e0bffe17 	ldw	r2,-8(fp)
81110de4:	10804517 	ldw	r2,276(r2)
81110de8:	e0fffa03 	ldbu	r3,-24(fp)
81110dec:	180b883a 	mov	r5,r3
81110df0:	1009883a 	mov	r4,r2
81110df4:	110a86c0 	call	8110a86c <uliRmapReadReg>
81110df8:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
81110dfc:	e0bffa03 	ldbu	r2,-24(fp)
81110e00:	10bff004 	addi	r2,r2,-64
81110e04:	10c003a8 	cmpgeui	r3,r2,14
81110e08:	1801381e 	bne	r3,zero,811112ec <vQCmdFeeRMAPinFullPattern+0x578>
81110e0c:	100690ba 	slli	r3,r2,2
81110e10:	00a04474 	movhi	r2,33041
81110e14:	10838904 	addi	r2,r2,3620
81110e18:	1885883a 	add	r2,r3,r2
81110e1c:	10800017 	ldw	r2,0(r2)
81110e20:	1000683a 	jmp	r2
81110e24:	81110e5c 	xori	r4,r16,17465
81110e28:	81110e5c 	xori	r4,r16,17465
81110e2c:	81110e5c 	xori	r4,r16,17465
81110e30:	811110b4 	orhi	r4,r16,17474
81110e34:	811110b4 	orhi	r4,r16,17474
81110e38:	811110b4 	orhi	r4,r16,17474
81110e3c:	811110b4 	orhi	r4,r16,17474
81110e40:	811110b4 	orhi	r4,r16,17474
81110e44:	811110b4 	orhi	r4,r16,17474
81110e48:	811110b4 	orhi	r4,r16,17474
81110e4c:	811110b4 	orhi	r4,r16,17474
81110e50:	811110b4 	orhi	r4,r16,17474
81110e54:	811110ec 	andhi	r4,r16,17475
81110e58:	8111126c 	andhi	r4,r16,17481
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81110e5c:	e0bffe17 	ldw	r2,-8(fp)
81110e60:	10802d17 	ldw	r2,180(r2)
81110e64:	108001e0 	cmpeqi	r2,r2,7
81110e68:	1000041e 	bne	r2,zero,81110e7c <vQCmdFeeRMAPinFullPattern+0x108>
81110e6c:	e0bffe17 	ldw	r2,-8(fp)
81110e70:	10802d17 	ldw	r2,180(r2)
81110e74:	10800318 	cmpnei	r2,r2,12
81110e78:	1000771e 	bne	r2,zero,81111058 <vQCmdFeeRMAPinFullPattern+0x2e4>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81110e7c:	e0bffa43 	ldbu	r2,-23(fp)
81110e80:	1080030c 	andi	r2,r2,12
81110e84:	1005d0ba 	srai	r2,r2,2
81110e88:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110e8c:	e0bffb17 	ldw	r2,-20(fp)
81110e90:	10c000a0 	cmpeqi	r3,r2,2
81110e94:	1800141e 	bne	r3,zero,81110ee8 <vQCmdFeeRMAPinFullPattern+0x174>
81110e98:	10c000e0 	cmpeqi	r3,r2,3
81110e9c:	1800231e 	bne	r3,zero,81110f2c <vQCmdFeeRMAPinFullPattern+0x1b8>
81110ea0:	10800060 	cmpeqi	r2,r2,1
81110ea4:	10003026 	beq	r2,zero,81110f68 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81110ea8:	e0bffe17 	ldw	r2,-8(fp)
81110eac:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110eb0:	00a045f4 	movhi	r2,33047
81110eb4:	10a34f04 	addi	r2,r2,-29380
81110eb8:	10800a8b 	ldhu	r2,42(r2)
81110ebc:	10bfffcc 	andi	r2,r2,65535
81110ec0:	108000e8 	cmpgeui	r2,r2,3
81110ec4:	1000461e 	bne	r2,zero,81110fe0 <vQCmdFeeRMAPinFullPattern+0x26c>
							fprintf(fp," - Left side\n");
81110ec8:	d0a06217 	ldw	r2,-32376(gp)
81110ecc:	100f883a 	mov	r7,r2
81110ed0:	01800344 	movi	r6,13
81110ed4:	01400044 	movi	r5,1
81110ed8:	01204574 	movhi	r4,33045
81110edc:	213b0604 	addi	r4,r4,-5096
81110ee0:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						break;
81110ee4:	00003e06 	br	81110fe0 <vQCmdFeeRMAPinFullPattern+0x26c>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110ee8:	e0bffe17 	ldw	r2,-8(fp)
81110eec:	00c00044 	movi	r3,1
81110ef0:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110ef4:	00a045f4 	movhi	r2,33047
81110ef8:	10a34f04 	addi	r2,r2,-29380
81110efc:	10800a8b 	ldhu	r2,42(r2)
81110f00:	10bfffcc 	andi	r2,r2,65535
81110f04:	108000e8 	cmpgeui	r2,r2,3
81110f08:	1000371e 	bne	r2,zero,81110fe8 <vQCmdFeeRMAPinFullPattern+0x274>
							fprintf(fp," - Right side\n");
81110f0c:	d0a06217 	ldw	r2,-32376(gp)
81110f10:	100f883a 	mov	r7,r2
81110f14:	01800384 	movi	r6,14
81110f18:	01400044 	movi	r5,1
81110f1c:	01204574 	movhi	r4,33045
81110f20:	213b0a04 	addi	r4,r4,-5080
81110f24:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						break;
81110f28:	00002f06 	br	81110fe8 <vQCmdFeeRMAPinFullPattern+0x274>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
81110f2c:	e0bffe17 	ldw	r2,-8(fp)
81110f30:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110f34:	00a045f4 	movhi	r2,33047
81110f38:	10a34f04 	addi	r2,r2,-29380
81110f3c:	10800a8b 	ldhu	r2,42(r2)
81110f40:	10bfffcc 	andi	r2,r2,65535
81110f44:	108000e8 	cmpgeui	r2,r2,3
81110f48:	1000071e 	bne	r2,zero,81110f68 <vQCmdFeeRMAPinFullPattern+0x1f4>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81110f4c:	d0a06217 	ldw	r2,-32376(gp)
81110f50:	100f883a 	mov	r7,r2
81110f54:	01800f44 	movi	r6,61
81110f58:	01400044 	movi	r5,1
81110f5c:	01204574 	movhi	r4,33045
81110f60:	213b0e04 	addi	r4,r4,-5064
81110f64:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110f68:	e0bffe17 	ldw	r2,-8(fp)
81110f6c:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110f70:	e0bffe17 	ldw	r2,-8(fp)
81110f74:	10804504 	addi	r2,r2,276
81110f78:	1009883a 	mov	r4,r2
81110f7c:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110f80:	e0bffe17 	ldw	r2,-8(fp)
81110f84:	10c05917 	ldw	r3,356(r2)
81110f88:	00bffdc4 	movi	r2,-9
81110f8c:	1886703a 	and	r3,r3,r2
81110f90:	e0bffe17 	ldw	r2,-8(fp)
81110f94:	10c05915 	stw	r3,356(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110f98:	e0bffe17 	ldw	r2,-8(fp)
81110f9c:	10804504 	addi	r2,r2,276
81110fa0:	1009883a 	mov	r4,r2
81110fa4:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110fa8:	00a045f4 	movhi	r2,33047
81110fac:	10a34f04 	addi	r2,r2,-29380
81110fb0:	10800a8b 	ldhu	r2,42(r2)
81110fb4:	10bfffcc 	andi	r2,r2,65535
81110fb8:	108000e8 	cmpgeui	r2,r2,3
81110fbc:	10000c1e 	bne	r2,zero,81110ff0 <vQCmdFeeRMAPinFullPattern+0x27c>
							fprintf(fp," - Switching to Left side\n");
81110fc0:	d0a06217 	ldw	r2,-32376(gp)
81110fc4:	100f883a 	mov	r7,r2
81110fc8:	01800684 	movi	r6,26
81110fcc:	01400044 	movi	r5,1
81110fd0:	01204574 	movhi	r4,33045
81110fd4:	213b1e04 	addi	r4,r4,-5000
81110fd8:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
					break;
81110fdc:	00000406 	br	81110ff0 <vQCmdFeeRMAPinFullPattern+0x27c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
81110fe0:	0001883a 	nop
81110fe4:	00000306 	br	81110ff4 <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
81110fe8:	0001883a 	nop
81110fec:	00000106 	br	81110ff4 <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
81110ff0:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110ff4:	00a045f4 	movhi	r2,33047
81110ff8:	10a34f04 	addi	r2,r2,-29380
81110ffc:	10800a8b 	ldhu	r2,42(r2)
81111000:	10bfffcc 	andi	r2,r2,65535
81111004:	10800168 	cmpgeui	r2,r2,5
81111008:	10000c1e 	bne	r2,zero,8111103c <vQCmdFeeRMAPinFullPattern+0x2c8>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8111100c:	d0e06217 	ldw	r3,-32376(gp)
81111010:	e0bffe17 	ldw	r2,-8(fp)
81111014:	10800003 	ldbu	r2,0(r2)
81111018:	11003fcc 	andi	r4,r2,255
8111101c:	e0bffe17 	ldw	r2,-8(fp)
81111020:	10802e17 	ldw	r2,184(r2)
81111024:	100f883a 	mov	r7,r2
81111028:	200d883a 	mov	r6,r4
8111102c:	01604574 	movhi	r5,33045
81111030:	297b2504 	addi	r5,r5,-4972
81111034:	1809883a 	mov	r4,r3
81111038:	11236500 	call	81123650 <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8111103c:	e0bffe17 	ldw	r2,-8(fp)
81111040:	00c00284 	movi	r3,10
81111044:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81111048:	e0bffe17 	ldw	r2,-8(fp)
8111104c:	00c00304 	movi	r3,12
81111050:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
81111054:	0000b306 	br	81111324 <vQCmdFeeRMAPinFullPattern+0x5b0>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81111058:	e0bffe17 	ldw	r2,-8(fp)
8111105c:	10802d17 	ldw	r2,180(r2)
81111060:	10800118 	cmpnei	r2,r2,4
81111064:	1000af1e 	bne	r2,zero,81111324 <vQCmdFeeRMAPinFullPattern+0x5b0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111068:	00a045f4 	movhi	r2,33047
8111106c:	10a34f04 	addi	r2,r2,-29380
81111070:	10800a8b 	ldhu	r2,42(r2)
81111074:	10bfffcc 	andi	r2,r2,65535
81111078:	10800168 	cmpgeui	r2,r2,5
8111107c:	1000a91e 	bne	r2,zero,81111324 <vQCmdFeeRMAPinFullPattern+0x5b0>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81111080:	d0e06217 	ldw	r3,-32376(gp)
81111084:	e0bffe17 	ldw	r2,-8(fp)
81111088:	10800003 	ldbu	r2,0(r2)
8111108c:	11003fcc 	andi	r4,r2,255
81111090:	e0bffe17 	ldw	r2,-8(fp)
81111094:	10802e17 	ldw	r2,184(r2)
81111098:	100f883a 	mov	r7,r2
8111109c:	200d883a 	mov	r6,r4
811110a0:	01604574 	movhi	r5,33045
811110a4:	297b7a04 	addi	r5,r5,-4632
811110a8:	1809883a 	mov	r4,r3
811110ac:	11236500 	call	81123650 <fprintf>
				}
			}



			break;
811110b0:	00009c06 	br	81111324 <vQCmdFeeRMAPinFullPattern+0x5b0>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811110b4:	00a045f4 	movhi	r2,33047
811110b8:	10a34f04 	addi	r2,r2,-29380
811110bc:	10800a8b 	ldhu	r2,42(r2)
811110c0:	10bfffcc 	andi	r2,r2,65535
811110c4:	10800168 	cmpgeui	r2,r2,5
811110c8:	1000981e 	bne	r2,zero,8111132c <vQCmdFeeRMAPinFullPattern+0x5b8>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
811110cc:	d0a06217 	ldw	r2,-32376(gp)
811110d0:	e0fffa03 	ldbu	r3,-24(fp)
811110d4:	180d883a 	mov	r6,r3
811110d8:	01604574 	movhi	r5,33045
811110dc:	297b6404 	addi	r5,r5,-4720
811110e0:	1009883a 	mov	r4,r2
811110e4:	11236500 	call	81123650 <fprintf>
			}
			#endif
				break;
811110e8:	00009006 	br	8111132c <vQCmdFeeRMAPinFullPattern+0x5b8>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811110ec:	e0bffa43 	ldbu	r2,-23(fp)
811110f0:	1004d13a 	srli	r2,r2,4
811110f4:	10803fcc 	andi	r2,r2,255
811110f8:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
811110fc:	e0bffc17 	ldw	r2,-16(fp)
81111100:	10c000a0 	cmpeqi	r3,r2,2
81111104:	1800281e 	bne	r3,zero,811111a8 <vQCmdFeeRMAPinFullPattern+0x434>
81111108:	10c001a0 	cmpeqi	r3,r2,6
8111110c:	1800361e 	bne	r3,zero,811111e8 <vQCmdFeeRMAPinFullPattern+0x474>
81111110:	1000431e 	bne	r2,zero,81111220 <vQCmdFeeRMAPinFullPattern+0x4ac>
				case 0: /* Standby */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81111114:	00a045f4 	movhi	r2,33047
81111118:	10a34f04 	addi	r2,r2,-29380
8111111c:	10800a8b 	ldhu	r2,42(r2)
81111120:	10bfffcc 	andi	r2,r2,65535
81111124:	108000e8 	cmpgeui	r2,r2,3
81111128:	1000071e 	bne	r2,zero,81111148 <vQCmdFeeRMAPinFullPattern+0x3d4>
						fprintf(fp,"- to Stand-By\n");
8111112c:	d0a06217 	ldw	r2,-32376(gp)
81111130:	100f883a 	mov	r7,r2
81111134:	01800384 	movi	r6,14
81111138:	01400044 	movi	r5,1
8111113c:	01204574 	movhi	r4,33045
81111140:	213b9104 	addi	r4,r4,-4540
81111144:	1123cec0 	call	81123cec <fwrite>
					}
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
81111148:	e0bffe17 	ldw	r2,-8(fp)
8111114c:	10802c17 	ldw	r2,176(r2)
81111150:	10800298 	cmpnei	r2,r2,10
81111154:	10000a1e 	bne	r2,zero,81111180 <vQCmdFeeRMAPinFullPattern+0x40c>
						pxNFeeP->xControl.bWatingSync = TRUE;
81111158:	e0bffe17 	ldw	r2,-8(fp)
8111115c:	00c00044 	movi	r3,1
81111160:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
81111164:	e0bffe17 	ldw	r2,-8(fp)
81111168:	00c00304 	movi	r3,12
8111116c:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81111170:	e0bffe17 	ldw	r2,-8(fp)
81111174:	00c00184 	movi	r3,6
81111178:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8111117c:	00003a06 	br	81111268 <vQCmdFeeRMAPinFullPattern+0x4f4>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
81111180:	e0bffe17 	ldw	r2,-8(fp)
81111184:	00c00044 	movi	r3,1
81111188:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8111118c:	e0bffe17 	ldw	r2,-8(fp)
81111190:	00c00104 	movi	r3,4
81111194:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81111198:	e0bffe17 	ldw	r2,-8(fp)
8111119c:	00c00184 	movi	r3,6
811111a0:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
811111a4:	00003006 	br	81111268 <vQCmdFeeRMAPinFullPattern+0x4f4>
				case 2: /* PAttern Full image */
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811111a8:	00a045f4 	movhi	r2,33047
811111ac:	10a34f04 	addi	r2,r2,-29380
811111b0:	10800a8b 	ldhu	r2,42(r2)
811111b4:	10bfffcc 	andi	r2,r2,65535
811111b8:	10800168 	cmpgeui	r2,r2,5
811111bc:	1000251e 	bne	r2,zero,81111254 <vQCmdFeeRMAPinFullPattern+0x4e0>
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811111c0:	d0e06217 	ldw	r3,-32376(gp)
811111c4:	e0bffe17 	ldw	r2,-8(fp)
811111c8:	10800003 	ldbu	r2,0(r2)
811111cc:	10803fcc 	andi	r2,r2,255
811111d0:	100d883a 	mov	r6,r2
811111d4:	01604574 	movhi	r5,33045
811111d8:	297ad604 	addi	r5,r5,-5288
811111dc:	1809883a 	mov	r4,r3
811111e0:	11236500 	call	81123650 <fprintf>
					}
					#endif

					break;
811111e4:	00001b06 	br	81111254 <vQCmdFeeRMAPinFullPattern+0x4e0>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811111e8:	00a045f4 	movhi	r2,33047
811111ec:	10a34f04 	addi	r2,r2,-29380
811111f0:	10800a8b 	ldhu	r2,42(r2)
811111f4:	10bfffcc 	andi	r2,r2,65535
811111f8:	10800168 	cmpgeui	r2,r2,5
811111fc:	1000171e 	bne	r2,zero,8111125c <vQCmdFeeRMAPinFullPattern+0x4e8>
						fprintf(fp," Off-Mode not allowed.\n");
81111200:	d0a06217 	ldw	r2,-32376(gp)
81111204:	100f883a 	mov	r7,r2
81111208:	018005c4 	movi	r6,23
8111120c:	01400044 	movi	r5,1
81111210:	01204574 	movhi	r4,33045
81111214:	213b9504 	addi	r4,r4,-4524
81111218:	1123cec0 	call	81123cec <fwrite>
					}
				#endif
					break;
8111121c:	00000f06 	br	8111125c <vQCmdFeeRMAPinFullPattern+0x4e8>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111220:	00a045f4 	movhi	r2,33047
81111224:	10a34f04 	addi	r2,r2,-29380
81111228:	10800a8b 	ldhu	r2,42(r2)
8111122c:	10bfffcc 	andi	r2,r2,65535
81111230:	10800168 	cmpgeui	r2,r2,5
81111234:	10000b1e 	bne	r2,zero,81111264 <vQCmdFeeRMAPinFullPattern+0x4f0>
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81111238:	d0a06217 	ldw	r2,-32376(gp)
8111123c:	e1bffc17 	ldw	r6,-16(fp)
81111240:	01604574 	movhi	r5,33045
81111244:	297b9b04 	addi	r5,r5,-4500
81111248:	1009883a 	mov	r4,r2
8111124c:	11236500 	call	81123650 <fprintf>
					}
					#endif
					break;
81111250:	00000406 	br	81111264 <vQCmdFeeRMAPinFullPattern+0x4f0>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
					}
					#endif

					break;
81111254:	0001883a 	nop
81111258:	00003906 	br	81111340 <vQCmdFeeRMAPinFullPattern+0x5cc>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," Off-Mode not allowed.\n");
					}
				#endif
					break;
8111125c:	0001883a 	nop
81111260:	00003706 	br	81111340 <vQCmdFeeRMAPinFullPattern+0x5cc>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81111264:	0001883a 	nop
			}

			break;
81111268:	00003506 	br	81111340 <vQCmdFeeRMAPinFullPattern+0x5cc>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8111126c:	e0bffa43 	ldbu	r2,-23(fp)
81111270:	1080010c 	andi	r2,r2,4
81111274:	10803fcc 	andi	r2,r2,255
81111278:	1004d0ba 	srli	r2,r2,2
8111127c:	10803fcc 	andi	r2,r2,255
81111280:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81111284:	e0bffc17 	ldw	r2,-16(fp)
81111288:	10002a26 	beq	r2,zero,81111334 <vQCmdFeeRMAPinFullPattern+0x5c0>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8111128c:	e0bffe17 	ldw	r2,-8(fp)
81111290:	10802d17 	ldw	r2,180(r2)
81111294:	10800198 	cmpnei	r2,r2,6
81111298:	1000261e 	bne	r2,zero,81111334 <vQCmdFeeRMAPinFullPattern+0x5c0>
					pxNFeeP->xControl.bWatingSync = FALSE;
8111129c:	e0bffe17 	ldw	r2,-8(fp)
811112a0:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811112a4:	e0bffe17 	ldw	r2,-8(fp)
811112a8:	10c02d17 	ldw	r3,180(r2)
811112ac:	e0bffe17 	ldw	r2,-8(fp)
811112b0:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811112b4:	00a045f4 	movhi	r2,33047
811112b8:	10a34f04 	addi	r2,r2,-29380
811112bc:	10800a8b 	ldhu	r2,42(r2)
811112c0:	10bfffcc 	andi	r2,r2,65535
811112c4:	10800168 	cmpgeui	r2,r2,5
811112c8:	10001a1e 	bne	r2,zero,81111334 <vQCmdFeeRMAPinFullPattern+0x5c0>
						fprintf(fp," - Mode Forced.\n");
811112cc:	d0a06217 	ldw	r2,-32376(gp)
811112d0:	100f883a 	mov	r7,r2
811112d4:	01800404 	movi	r6,16
811112d8:	01400044 	movi	r5,1
811112dc:	01204574 	movhi	r4,33045
811112e0:	213ba304 	addi	r4,r4,-4468
811112e4:	1123cec0 	call	81123cec <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
811112e8:	00001206 	br	81111334 <vQCmdFeeRMAPinFullPattern+0x5c0>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811112ec:	00a045f4 	movhi	r2,33047
811112f0:	10a34f04 	addi	r2,r2,-29380
811112f4:	10800a8b 	ldhu	r2,42(r2)
811112f8:	10bfffcc 	andi	r2,r2,65535
811112fc:	10800228 	cmpgeui	r2,r2,8
81111300:	10000e1e 	bne	r2,zero,8111133c <vQCmdFeeRMAPinFullPattern+0x5c8>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81111304:	d0a06217 	ldw	r2,-32376(gp)
81111308:	e0fffa03 	ldbu	r3,-24(fp)
8111130c:	180d883a 	mov	r6,r3
81111310:	01604574 	movhi	r5,33045
81111314:	297b3304 	addi	r5,r5,-4916
81111318:	1009883a 	mov	r4,r2
8111131c:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
81111320:	00000606 	br	8111133c <vQCmdFeeRMAPinFullPattern+0x5c8>
				}
			}



			break;
81111324:	0001883a 	nop
81111328:	00000506 	br	81111340 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
8111132c:	0001883a 	nop
81111330:	00000306 	br	81111340 <vQCmdFeeRMAPinFullPattern+0x5cc>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81111334:	0001883a 	nop
81111338:	00000106 	br	81111340 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
8111133c:	0001883a 	nop
		}
}
81111340:	0001883a 	nop
81111344:	e037883a 	mov	sp,fp
81111348:	dfc00117 	ldw	ra,4(sp)
8111134c:	df000017 	ldw	fp,0(sp)
81111350:	dec00204 	addi	sp,sp,8
81111354:	f800283a 	ret

81111358 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
81111358:	defff804 	addi	sp,sp,-32
8111135c:	de00012e 	bgeu	sp,et,81111364 <vQCmdFeeRMAPWaitingSync+0xc>
81111360:	003b68fa 	trap	3
81111364:	dfc00715 	stw	ra,28(sp)
81111368:	df000615 	stw	fp,24(sp)
8111136c:	df000604 	addi	fp,sp,24
81111370:	e13ffe15 	stw	r4,-8(fp)
81111374:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81111378:	00a045f4 	movhi	r2,33047
8111137c:	10a34f04 	addi	r2,r2,-29380
81111380:	10800a8b 	ldhu	r2,42(r2)
81111384:	10bfffcc 	andi	r2,r2,65535
81111388:	108000e8 	cmpgeui	r2,r2,3
8111138c:	1000091e 	bne	r2,zero,811113b4 <vQCmdFeeRMAPWaitingSync+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
81111390:	d0e06217 	ldw	r3,-32376(gp)
81111394:	e0bffe17 	ldw	r2,-8(fp)
81111398:	10800003 	ldbu	r2,0(r2)
8111139c:	10803fcc 	andi	r2,r2,255
811113a0:	100d883a 	mov	r6,r2
811113a4:	01604574 	movhi	r5,33045
811113a8:	297ba804 	addi	r5,r5,-4448
811113ac:	1809883a 	mov	r4,r3
811113b0:	11236500 	call	81123650 <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
811113b4:	e0bfff17 	ldw	r2,-4(fp)
811113b8:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811113bc:	e0bffd43 	ldbu	r2,-11(fp)
811113c0:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811113c4:	e0bffe17 	ldw	r2,-8(fp)
811113c8:	10804517 	ldw	r2,276(r2)
811113cc:	e0fffa03 	ldbu	r3,-24(fp)
811113d0:	180b883a 	mov	r5,r3
811113d4:	1009883a 	mov	r4,r2
811113d8:	110a86c0 	call	8110a86c <uliRmapReadReg>
811113dc:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
811113e0:	e0bffa03 	ldbu	r2,-24(fp)
811113e4:	10c010c8 	cmpgei	r3,r2,67
811113e8:	1800051e 	bne	r3,zero,81111400 <vQCmdFeeRMAPWaitingSync+0xa8>
811113ec:	10c01008 	cmpgei	r3,r2,64
811113f0:	1800081e 	bne	r3,zero,81111414 <vQCmdFeeRMAPWaitingSync+0xbc>
811113f4:	108000a0 	cmpeqi	r2,r2,2
811113f8:	1000e61e 	bne	r2,zero,81111794 <vQCmdFeeRMAPWaitingSync+0x43c>
811113fc:	00011e06 	br	81111878 <vQCmdFeeRMAPWaitingSync+0x520>
81111400:	10c01350 	cmplti	r3,r2,77
81111404:	1800991e 	bne	r3,zero,8111166c <vQCmdFeeRMAPWaitingSync+0x314>
81111408:	10801360 	cmpeqi	r2,r2,77
8111140c:	1000fa1e 	bne	r2,zero,811117f8 <vQCmdFeeRMAPWaitingSync+0x4a0>
81111410:	00011906 	br	81111878 <vQCmdFeeRMAPWaitingSync+0x520>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81111414:	e0bffe17 	ldw	r2,-8(fp)
81111418:	10802d17 	ldw	r2,180(r2)
8111141c:	108001e0 	cmpeqi	r2,r2,7
81111420:	1000041e 	bne	r2,zero,81111434 <vQCmdFeeRMAPWaitingSync+0xdc>
81111424:	e0bffe17 	ldw	r2,-8(fp)
81111428:	10802d17 	ldw	r2,180(r2)
8111142c:	10800318 	cmpnei	r2,r2,12
81111430:	1000771e 	bne	r2,zero,81111610 <vQCmdFeeRMAPWaitingSync+0x2b8>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81111434:	e0bffa43 	ldbu	r2,-23(fp)
81111438:	1080030c 	andi	r2,r2,12
8111143c:	1005d0ba 	srai	r2,r2,2
81111440:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81111444:	e0bffb17 	ldw	r2,-20(fp)
81111448:	10c000a0 	cmpeqi	r3,r2,2
8111144c:	1800141e 	bne	r3,zero,811114a0 <vQCmdFeeRMAPWaitingSync+0x148>
81111450:	10c000e0 	cmpeqi	r3,r2,3
81111454:	1800231e 	bne	r3,zero,811114e4 <vQCmdFeeRMAPWaitingSync+0x18c>
81111458:	10800060 	cmpeqi	r2,r2,1
8111145c:	10003026 	beq	r2,zero,81111520 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81111460:	e0bffe17 	ldw	r2,-8(fp)
81111464:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81111468:	00a045f4 	movhi	r2,33047
8111146c:	10a34f04 	addi	r2,r2,-29380
81111470:	10800a8b 	ldhu	r2,42(r2)
81111474:	10bfffcc 	andi	r2,r2,65535
81111478:	108000e8 	cmpgeui	r2,r2,3
8111147c:	1000461e 	bne	r2,zero,81111598 <vQCmdFeeRMAPWaitingSync+0x240>
							fprintf(fp," - Left side\n");
81111480:	d0a06217 	ldw	r2,-32376(gp)
81111484:	100f883a 	mov	r7,r2
81111488:	01800344 	movi	r6,13
8111148c:	01400044 	movi	r5,1
81111490:	01204574 	movhi	r4,33045
81111494:	213b0604 	addi	r4,r4,-5096
81111498:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						break;
8111149c:	00003e06 	br	81111598 <vQCmdFeeRMAPWaitingSync+0x240>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
811114a0:	e0bffe17 	ldw	r2,-8(fp)
811114a4:	00c00044 	movi	r3,1
811114a8:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811114ac:	00a045f4 	movhi	r2,33047
811114b0:	10a34f04 	addi	r2,r2,-29380
811114b4:	10800a8b 	ldhu	r2,42(r2)
811114b8:	10bfffcc 	andi	r2,r2,65535
811114bc:	108000e8 	cmpgeui	r2,r2,3
811114c0:	1000371e 	bne	r2,zero,811115a0 <vQCmdFeeRMAPWaitingSync+0x248>
							fprintf(fp," - Right side\n");
811114c4:	d0a06217 	ldw	r2,-32376(gp)
811114c8:	100f883a 	mov	r7,r2
811114cc:	01800384 	movi	r6,14
811114d0:	01400044 	movi	r5,1
811114d4:	01204574 	movhi	r4,33045
811114d8:	213b0a04 	addi	r4,r4,-5080
811114dc:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						break;
811114e0:	00002f06 	br	811115a0 <vQCmdFeeRMAPWaitingSync+0x248>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
811114e4:	e0bffe17 	ldw	r2,-8(fp)
811114e8:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811114ec:	00a045f4 	movhi	r2,33047
811114f0:	10a34f04 	addi	r2,r2,-29380
811114f4:	10800a8b 	ldhu	r2,42(r2)
811114f8:	10bfffcc 	andi	r2,r2,65535
811114fc:	10800168 	cmpgeui	r2,r2,5
81111500:	1000071e 	bne	r2,zero,81111520 <vQCmdFeeRMAPWaitingSync+0x1c8>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81111504:	d0a06217 	ldw	r2,-32376(gp)
81111508:	100f883a 	mov	r7,r2
8111150c:	01800f44 	movi	r6,61
81111510:	01400044 	movi	r5,1
81111514:	01204574 	movhi	r4,33045
81111518:	213b0e04 	addi	r4,r4,-5064
8111151c:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81111520:	e0bffe17 	ldw	r2,-8(fp)
81111524:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81111528:	e0bffe17 	ldw	r2,-8(fp)
8111152c:	10804504 	addi	r2,r2,276
81111530:	1009883a 	mov	r4,r2
81111534:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81111538:	e0bffe17 	ldw	r2,-8(fp)
8111153c:	10c05917 	ldw	r3,356(r2)
81111540:	00bffdc4 	movi	r2,-9
81111544:	1886703a 	and	r3,r3,r2
81111548:	e0bffe17 	ldw	r2,-8(fp)
8111154c:	10c05915 	stw	r3,356(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81111550:	e0bffe17 	ldw	r2,-8(fp)
81111554:	10804504 	addi	r2,r2,276
81111558:	1009883a 	mov	r4,r2
8111155c:	11086d80 	call	811086d8 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81111560:	00a045f4 	movhi	r2,33047
81111564:	10a34f04 	addi	r2,r2,-29380
81111568:	10800a8b 	ldhu	r2,42(r2)
8111156c:	10bfffcc 	andi	r2,r2,65535
81111570:	108000e8 	cmpgeui	r2,r2,3
81111574:	10000c1e 	bne	r2,zero,811115a8 <vQCmdFeeRMAPWaitingSync+0x250>
							fprintf(fp," - Switching to Left side\n");
81111578:	d0a06217 	ldw	r2,-32376(gp)
8111157c:	100f883a 	mov	r7,r2
81111580:	01800684 	movi	r6,26
81111584:	01400044 	movi	r5,1
81111588:	01204574 	movhi	r4,33045
8111158c:	213b1e04 	addi	r4,r4,-5000
81111590:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
					break;
81111594:	00000406 	br	811115a8 <vQCmdFeeRMAPWaitingSync+0x250>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
81111598:	0001883a 	nop
8111159c:	00000306 	br	811115ac <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
811115a0:	0001883a 	nop
811115a4:	00000106 	br	811115ac <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
811115a8:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811115ac:	00a045f4 	movhi	r2,33047
811115b0:	10a34f04 	addi	r2,r2,-29380
811115b4:	10800a8b 	ldhu	r2,42(r2)
811115b8:	10bfffcc 	andi	r2,r2,65535
811115bc:	10800168 	cmpgeui	r2,r2,5
811115c0:	10000c1e 	bne	r2,zero,811115f4 <vQCmdFeeRMAPWaitingSync+0x29c>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
811115c4:	d0e06217 	ldw	r3,-32376(gp)
811115c8:	e0bffe17 	ldw	r2,-8(fp)
811115cc:	10800003 	ldbu	r2,0(r2)
811115d0:	11003fcc 	andi	r4,r2,255
811115d4:	e0bffe17 	ldw	r2,-8(fp)
811115d8:	10802e17 	ldw	r2,184(r2)
811115dc:	100f883a 	mov	r7,r2
811115e0:	200d883a 	mov	r6,r4
811115e4:	01604574 	movhi	r5,33045
811115e8:	297b2504 	addi	r5,r5,-4972
811115ec:	1809883a 	mov	r4,r3
811115f0:	11236500 	call	81123650 <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
811115f4:	e0bffe17 	ldw	r2,-8(fp)
811115f8:	00c00284 	movi	r3,10
811115fc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81111600:	e0bffe17 	ldw	r2,-8(fp)
81111604:	00c00304 	movi	r3,12
81111608:	10c02d15 	stw	r3,180(r2)
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
8111160c:	0000a806 	br	811118b0 <vQCmdFeeRMAPWaitingSync+0x558>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81111610:	e0bffe17 	ldw	r2,-8(fp)
81111614:	10802d17 	ldw	r2,180(r2)
81111618:	10800118 	cmpnei	r2,r2,4
8111161c:	1000a41e 	bne	r2,zero,811118b0 <vQCmdFeeRMAPWaitingSync+0x558>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81111620:	00a045f4 	movhi	r2,33047
81111624:	10a34f04 	addi	r2,r2,-29380
81111628:	10800a8b 	ldhu	r2,42(r2)
8111162c:	10bfffcc 	andi	r2,r2,65535
81111630:	10800228 	cmpgeui	r2,r2,8
81111634:	10009e1e 	bne	r2,zero,811118b0 <vQCmdFeeRMAPWaitingSync+0x558>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81111638:	d0e06217 	ldw	r3,-32376(gp)
8111163c:	e0bffe17 	ldw	r2,-8(fp)
81111640:	10800003 	ldbu	r2,0(r2)
81111644:	11003fcc 	andi	r4,r2,255
81111648:	e0bffe17 	ldw	r2,-8(fp)
8111164c:	10802e17 	ldw	r2,184(r2)
81111650:	100f883a 	mov	r7,r2
81111654:	200d883a 	mov	r6,r4
81111658:	01604574 	movhi	r5,33045
8111165c:	297b7a04 	addi	r5,r5,-4632
81111660:	1809883a 	mov	r4,r3
81111664:	11236500 	call	81123650 <fprintf>
					}
					#endif
				}
			}
			break;
81111668:	00009106 	br	811118b0 <vQCmdFeeRMAPWaitingSync+0x558>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8111166c:	e0bffa43 	ldbu	r2,-23(fp)
81111670:	1004d13a 	srli	r2,r2,4
81111674:	10803fcc 	andi	r2,r2,255
81111678:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
8111167c:	e0bffc17 	ldw	r2,-16(fp)
81111680:	10c000a0 	cmpeqi	r3,r2,2
81111684:	18001a1e 	bne	r3,zero,811116f0 <vQCmdFeeRMAPWaitingSync+0x398>
81111688:	10c001a0 	cmpeqi	r3,r2,6
8111168c:	1800221e 	bne	r3,zero,81111718 <vQCmdFeeRMAPWaitingSync+0x3c0>
81111690:	10002f1e 	bne	r2,zero,81111750 <vQCmdFeeRMAPWaitingSync+0x3f8>
			case 0: /* Standby */
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81111694:	00a045f4 	movhi	r2,33047
81111698:	10a34f04 	addi	r2,r2,-29380
8111169c:	10800a8b 	ldhu	r2,42(r2)
811116a0:	10bfffcc 	andi	r2,r2,65535
811116a4:	108000e8 	cmpgeui	r2,r2,3
811116a8:	1000071e 	bne	r2,zero,811116c8 <vQCmdFeeRMAPWaitingSync+0x370>
					fprintf(fp,"- to Stand-By\n");
811116ac:	d0a06217 	ldw	r2,-32376(gp)
811116b0:	100f883a 	mov	r7,r2
811116b4:	01800384 	movi	r6,14
811116b8:	01400044 	movi	r5,1
811116bc:	01204574 	movhi	r4,33045
811116c0:	213b9104 	addi	r4,r4,-4540
811116c4:	1123cec0 	call	81123cec <fwrite>
				}
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
811116c8:	e0bffe17 	ldw	r2,-8(fp)
811116cc:	00c00044 	movi	r3,1
811116d0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
811116d4:	e0bffe17 	ldw	r2,-8(fp)
811116d8:	00c00304 	movi	r3,12
811116dc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811116e0:	e0bffe17 	ldw	r2,-8(fp)
811116e4:	00c00184 	movi	r3,6
811116e8:	10c02d15 	stw	r3,180(r2)


				break;
811116ec:	00002806 	br	81111790 <vQCmdFeeRMAPWaitingSync+0x438>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
811116f0:	e0bffe17 	ldw	r2,-8(fp)
811116f4:	00c00044 	movi	r3,1
811116f8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
811116fc:	e0bffe17 	ldw	r2,-8(fp)
81111700:	00c00304 	movi	r3,12
81111704:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81111708:	e0bffe17 	ldw	r2,-8(fp)
8111170c:	00c00284 	movi	r3,10
81111710:	10c02d15 	stw	r3,180(r2)

				break;
81111714:	00001e06 	br	81111790 <vQCmdFeeRMAPWaitingSync+0x438>
			case 6:
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111718:	00a045f4 	movhi	r2,33047
8111171c:	10a34f04 	addi	r2,r2,-29380
81111720:	10800a8b 	ldhu	r2,42(r2)
81111724:	10bfffcc 	andi	r2,r2,65535
81111728:	10800168 	cmpgeui	r2,r2,5
8111172c:	1000151e 	bne	r2,zero,81111784 <vQCmdFeeRMAPWaitingSync+0x42c>
					fprintf(fp," Off-Mode not allowed.\n");
81111730:	d0a06217 	ldw	r2,-32376(gp)
81111734:	100f883a 	mov	r7,r2
81111738:	018005c4 	movi	r6,23
8111173c:	01400044 	movi	r5,1
81111740:	01204574 	movhi	r4,33045
81111744:	213b9504 	addi	r4,r4,-4524
81111748:	1123cec0 	call	81123cec <fwrite>
				}
			#endif
				break;
8111174c:	00000d06 	br	81111784 <vQCmdFeeRMAPWaitingSync+0x42c>
			case 3:
			case 4:
			case 5:
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111750:	00a045f4 	movhi	r2,33047
81111754:	10a34f04 	addi	r2,r2,-29380
81111758:	10800a8b 	ldhu	r2,42(r2)
8111175c:	10bfffcc 	andi	r2,r2,65535
81111760:	10800168 	cmpgeui	r2,r2,5
81111764:	1000091e 	bne	r2,zero,8111178c <vQCmdFeeRMAPWaitingSync+0x434>
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81111768:	d0a06217 	ldw	r2,-32376(gp)
8111176c:	e1bffc17 	ldw	r6,-16(fp)
81111770:	01604574 	movhi	r5,33045
81111774:	297b9b04 	addi	r5,r5,-4500
81111778:	1009883a 	mov	r4,r2
8111177c:	11236500 	call	81123650 <fprintf>
				}
				#endif
				break;
81111780:	00000206 	br	8111178c <vQCmdFeeRMAPWaitingSync+0x434>
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," Off-Mode not allowed.\n");
				}
			#endif
				break;
81111784:	0001883a 	nop
81111788:	00004e06 	br	811118c4 <vQCmdFeeRMAPWaitingSync+0x56c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
				}
				#endif
				break;
8111178c:	0001883a 	nop
		}

			break;
81111790:	00004c06 	br	811118c4 <vQCmdFeeRMAPWaitingSync+0x56c>
		case 2: /* PAttern Full image */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111794:	00a045f4 	movhi	r2,33047
81111798:	10a34f04 	addi	r2,r2,-29380
8111179c:	10800a8b 	ldhu	r2,42(r2)
811117a0:	10bfffcc 	andi	r2,r2,65535
811117a4:	10800168 	cmpgeui	r2,r2,5
811117a8:	1000091e 	bne	r2,zero,811117d0 <vQCmdFeeRMAPWaitingSync+0x478>
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811117ac:	d0e06217 	ldw	r3,-32376(gp)
811117b0:	e0bffe17 	ldw	r2,-8(fp)
811117b4:	10800003 	ldbu	r2,0(r2)
811117b8:	10803fcc 	andi	r2,r2,255
811117bc:	100d883a 	mov	r6,r2
811117c0:	01604574 	movhi	r5,33045
811117c4:	297ad604 	addi	r5,r5,-5288
811117c8:	1809883a 	mov	r4,r3
811117cc:	11236500 	call	81123650 <fprintf>
			}
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
811117d0:	e0bffe17 	ldw	r2,-8(fp)
811117d4:	00c00044 	movi	r3,1
811117d8:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
811117dc:	e0bffe17 	ldw	r2,-8(fp)
811117e0:	00c00284 	movi	r3,10
811117e4:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
811117e8:	e0bffe17 	ldw	r2,-8(fp)
811117ec:	00c00304 	movi	r3,12
811117f0:	10c02d15 	stw	r3,180(r2)

			break;
811117f4:	00003306 	br	811118c4 <vQCmdFeeRMAPWaitingSync+0x56c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811117f8:	e0bffa43 	ldbu	r2,-23(fp)
811117fc:	1080010c 	andi	r2,r2,4
81111800:	10803fcc 	andi	r2,r2,255
81111804:	1004d0ba 	srli	r2,r2,2
81111808:	10803fcc 	andi	r2,r2,255
8111180c:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81111810:	e0bffc17 	ldw	r2,-16(fp)
81111814:	10002826 	beq	r2,zero,811118b8 <vQCmdFeeRMAPWaitingSync+0x560>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81111818:	e0bffe17 	ldw	r2,-8(fp)
8111181c:	10802d17 	ldw	r2,180(r2)
81111820:	10800198 	cmpnei	r2,r2,6
81111824:	1000241e 	bne	r2,zero,811118b8 <vQCmdFeeRMAPWaitingSync+0x560>
					pxNFeeP->xControl.bWatingSync = FALSE;
81111828:	e0bffe17 	ldw	r2,-8(fp)
8111182c:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81111830:	e0bffe17 	ldw	r2,-8(fp)
81111834:	10c02d17 	ldw	r3,180(r2)
81111838:	e0bffe17 	ldw	r2,-8(fp)
8111183c:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111840:	00a045f4 	movhi	r2,33047
81111844:	10a34f04 	addi	r2,r2,-29380
81111848:	10800a8b 	ldhu	r2,42(r2)
8111184c:	10bfffcc 	andi	r2,r2,65535
81111850:	10800168 	cmpgeui	r2,r2,5
81111854:	1000181e 	bne	r2,zero,811118b8 <vQCmdFeeRMAPWaitingSync+0x560>
						fprintf(fp," - Mode Forced.\n");
81111858:	d0a06217 	ldw	r2,-32376(gp)
8111185c:	100f883a 	mov	r7,r2
81111860:	01800404 	movi	r6,16
81111864:	01400044 	movi	r5,1
81111868:	01204574 	movhi	r4,33045
8111186c:	213ba304 	addi	r4,r4,-4468
81111870:	1123cec0 	call	81123cec <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81111874:	00001006 	br	811118b8 <vQCmdFeeRMAPWaitingSync+0x560>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81111878:	00a045f4 	movhi	r2,33047
8111187c:	10a34f04 	addi	r2,r2,-29380
81111880:	10800a8b 	ldhu	r2,42(r2)
81111884:	10bfffcc 	andi	r2,r2,65535
81111888:	10800228 	cmpgeui	r2,r2,8
8111188c:	10000c1e 	bne	r2,zero,811118c0 <vQCmdFeeRMAPWaitingSync+0x568>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81111890:	d0a06217 	ldw	r2,-32376(gp)
81111894:	e0fffa03 	ldbu	r3,-24(fp)
81111898:	180d883a 	mov	r6,r3
8111189c:	01604574 	movhi	r5,33045
811118a0:	297b6404 	addi	r5,r5,-4720
811118a4:	1009883a 	mov	r4,r2
811118a8:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
811118ac:	00000406 	br	811118c0 <vQCmdFeeRMAPWaitingSync+0x568>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
811118b0:	0001883a 	nop
811118b4:	00000306 	br	811118c4 <vQCmdFeeRMAPWaitingSync+0x56c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
811118b8:	0001883a 	nop
811118bc:	00000106 	br	811118c4 <vQCmdFeeRMAPWaitingSync+0x56c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
811118c0:	0001883a 	nop
		}
}
811118c4:	0001883a 	nop
811118c8:	e037883a 	mov	sp,fp
811118cc:	dfc00117 	ldw	ra,4(sp)
811118d0:	df000017 	ldw	fp,0(sp)
811118d4:	dec00204 	addi	sp,sp,8
811118d8:	f800283a 	ret

811118dc <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
811118dc:	defffc04 	addi	sp,sp,-16
811118e0:	de00012e 	bgeu	sp,et,811118e8 <bDisableRmapIRQ+0xc>
811118e4:	003b68fa 	trap	3
811118e8:	dfc00315 	stw	ra,12(sp)
811118ec:	df000215 	stw	fp,8(sp)
811118f0:	df000204 	addi	fp,sp,8
811118f4:	e13ffe15 	stw	r4,-8(fp)
811118f8:	2805883a 	mov	r2,r5
811118fc:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
81111900:	e13ffe17 	ldw	r4,-8(fp)
81111904:	11081a00 	call	811081a0 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81111908:	e0bffe17 	ldw	r2,-8(fp)
8111190c:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81111910:	e13ffe17 	ldw	r4,-8(fp)
81111914:	11080f40 	call	811080f4 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81111918:	00800044 	movi	r2,1
}
8111191c:	e037883a 	mov	sp,fp
81111920:	dfc00117 	ldw	ra,4(sp)
81111924:	df000017 	ldw	fp,0(sp)
81111928:	dec00204 	addi	sp,sp,8
8111192c:	f800283a 	ret

81111930 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81111930:	defffc04 	addi	sp,sp,-16
81111934:	de00012e 	bgeu	sp,et,8111193c <bEnableRmapIRQ+0xc>
81111938:	003b68fa 	trap	3
8111193c:	dfc00315 	stw	ra,12(sp)
81111940:	df000215 	stw	fp,8(sp)
81111944:	df000204 	addi	fp,sp,8
81111948:	e13ffe15 	stw	r4,-8(fp)
8111194c:	2805883a 	mov	r2,r5
81111950:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
81111954:	e13ffe17 	ldw	r4,-8(fp)
81111958:	11081a00 	call	811081a0 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8111195c:	e0bffe17 	ldw	r2,-8(fp)
81111960:	00c00044 	movi	r3,1
81111964:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81111968:	e13ffe17 	ldw	r4,-8(fp)
8111196c:	11080f40 	call	811080f4 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81111970:	00800044 	movi	r2,1
}
81111974:	e037883a 	mov	sp,fp
81111978:	dfc00117 	ldw	ra,4(sp)
8111197c:	df000017 	ldw	fp,0(sp)
81111980:	dec00204 	addi	sp,sp,8
81111984:	f800283a 	ret

81111988 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
81111988:	defffd04 	addi	sp,sp,-12
8111198c:	de00012e 	bgeu	sp,et,81111994 <bDisableSPWChannel+0xc>
81111990:	003b68fa 	trap	3
81111994:	dfc00215 	stw	ra,8(sp)
81111998:	df000115 	stw	fp,4(sp)
8111199c:	df000104 	addi	fp,sp,4
811119a0:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
811119a4:	e13fff17 	ldw	r4,-4(fp)
811119a8:	110ac5c0 	call	8110ac5c <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
811119ac:	e0bfff17 	ldw	r2,-4(fp)
811119b0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
811119b4:	e0bfff17 	ldw	r2,-4(fp)
811119b8:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
811119bc:	e0bfff17 	ldw	r2,-4(fp)
811119c0:	00c00044 	movi	r3,1
811119c4:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
811119c8:	e13fff17 	ldw	r4,-4(fp)
811119cc:	110ab240 	call	8110ab24 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
811119d0:	00800044 	movi	r2,1
}
811119d4:	e037883a 	mov	sp,fp
811119d8:	dfc00117 	ldw	ra,4(sp)
811119dc:	df000017 	ldw	fp,0(sp)
811119e0:	dec00204 	addi	sp,sp,8
811119e4:	f800283a 	ret

811119e8 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
811119e8:	defffd04 	addi	sp,sp,-12
811119ec:	de00012e 	bgeu	sp,et,811119f4 <bEnableSPWChannel+0xc>
811119f0:	003b68fa 	trap	3
811119f4:	dfc00215 	stw	ra,8(sp)
811119f8:	df000115 	stw	fp,4(sp)
811119fc:	df000104 	addi	fp,sp,4
81111a00:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
81111a04:	e13fff17 	ldw	r4,-4(fp)
81111a08:	110ac5c0 	call	8110ac5c <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81111a0c:	e0bfff17 	ldw	r2,-4(fp)
81111a10:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
81111a14:	e0bfff17 	ldw	r2,-4(fp)
81111a18:	00c00044 	movi	r3,1
81111a1c:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
81111a20:	e0bfff17 	ldw	r2,-4(fp)
81111a24:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
81111a28:	e13fff17 	ldw	r4,-4(fp)
81111a2c:	110ab240 	call	8110ab24 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81111a30:	00800044 	movi	r2,1
}
81111a34:	e037883a 	mov	sp,fp
81111a38:	dfc00117 	ldw	ra,4(sp)
81111a3c:	df000017 	ldw	fp,0(sp)
81111a40:	dec00204 	addi	sp,sp,8
81111a44:	f800283a 	ret

81111a48 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
81111a48:	defffd04 	addi	sp,sp,-12
81111a4c:	de00012e 	bgeu	sp,et,81111a54 <bEnableDbBuffer+0xc>
81111a50:	003b68fa 	trap	3
81111a54:	dfc00215 	stw	ra,8(sp)
81111a58:	df000115 	stw	fp,4(sp)
81111a5c:	df000104 	addi	fp,sp,4
81111a60:	e13fff15 	stw	r4,-4(fp)
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81111a64:	e13fff17 	ldw	r4,-4(fp)
81111a68:	11070e40 	call	811070e4 <bFeebStopCh>
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81111a6c:	e13fff17 	ldw	r4,-4(fp)
81111a70:	11071700 	call	81107170 <bFeebClrCh>
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
81111a74:	e13fff17 	ldw	r4,-4(fp)
81111a78:	11070580 	call	81107058 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
81111a7c:	e13fff17 	ldw	r4,-4(fp)
81111a80:	1106fd00 	call	81106fd0 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
81111a84:	00a045f4 	movhi	r2,33047
81111a88:	10a34f04 	addi	r2,r2,-29380
81111a8c:	10c00417 	ldw	r3,16(r2)
81111a90:	e0bfff17 	ldw	r2,-4(fp)
81111a94:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81111a98:	e13fff17 	ldw	r4,-4(fp)
81111a9c:	1106f240 	call	81106f24 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81111aa0:	e13fff17 	ldw	r4,-4(fp)
81111aa4:	11067840 	call	81106784 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81111aa8:	e0bfff17 	ldw	r2,-4(fp)
81111aac:	00c00044 	movi	r3,1
81111ab0:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81111ab4:	e0bfff17 	ldw	r2,-4(fp)
81111ab8:	00c00044 	movi	r3,1
81111abc:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81111ac0:	e13fff17 	ldw	r4,-4(fp)
81111ac4:	11066ac0 	call	811066ac <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81111ac8:	00800044 	movi	r2,1
}
81111acc:	e037883a 	mov	sp,fp
81111ad0:	dfc00117 	ldw	ra,4(sp)
81111ad4:	df000017 	ldw	fp,0(sp)
81111ad8:	dec00204 	addi	sp,sp,8
81111adc:	f800283a 	ret

81111ae0 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
81111ae0:	defffd04 	addi	sp,sp,-12
81111ae4:	de00012e 	bgeu	sp,et,81111aec <bDisAndClrDbBuffer+0xc>
81111ae8:	003b68fa 	trap	3
81111aec:	dfc00215 	stw	ra,8(sp)
81111af0:	df000115 	stw	fp,4(sp)
81111af4:	df000104 	addi	fp,sp,4
81111af8:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81111afc:	e13fff17 	ldw	r4,-4(fp)
81111b00:	11067840 	call	81106784 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81111b04:	e0bfff17 	ldw	r2,-4(fp)
81111b08:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81111b0c:	e0bfff17 	ldw	r2,-4(fp)
81111b10:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81111b14:	e13fff17 	ldw	r4,-4(fp)
81111b18:	11066ac0 	call	811066ac <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81111b1c:	e13fff17 	ldw	r4,-4(fp)
81111b20:	11070e40 	call	811070e4 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81111b24:	e13fff17 	ldw	r4,-4(fp)
81111b28:	11071700 	call	81107170 <bFeebClrCh>
	bFeebStartCh(pxFeebCh);
81111b2c:	e13fff17 	ldw	r4,-4(fp)
81111b30:	11070580 	call	81107058 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
81111b34:	00800044 	movi	r2,1
}
81111b38:	e037883a 	mov	sp,fp
81111b3c:	dfc00117 	ldw	ra,4(sp)
81111b40:	df000017 	ldw	fp,0(sp)
81111b44:	dec00204 	addi	sp,sp,8
81111b48:	f800283a 	ret

81111b4c <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111b4c:	defff804 	addi	sp,sp,-32
81111b50:	de00012e 	bgeu	sp,et,81111b58 <bSendRequestNFeeCtrl+0xc>
81111b54:	003b68fa 	trap	3
81111b58:	dfc00715 	stw	ra,28(sp)
81111b5c:	df000615 	stw	fp,24(sp)
81111b60:	df000604 	addi	fp,sp,24
81111b64:	2807883a 	mov	r3,r5
81111b68:	3005883a 	mov	r2,r6
81111b6c:	e13ffd05 	stb	r4,-12(fp)
81111b70:	e0fffe05 	stb	r3,-8(fp)
81111b74:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111b78:	00800404 	movi	r2,16
81111b7c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111b80:	e0bffd03 	ldbu	r2,-12(fp)
81111b84:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111b88:	e0bffe03 	ldbu	r2,-8(fp)
81111b8c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111b90:	e0bfff03 	ldbu	r2,-4(fp)
81111b94:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111b98:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81111b9c:	d0a05d17 	ldw	r2,-32396(gp)
81111ba0:	e0fffc17 	ldw	r3,-16(fp)
81111ba4:	180b883a 	mov	r5,r3
81111ba8:	1009883a 	mov	r4,r2
81111bac:	114001c0 	call	8114001c <OSQPost>
81111bb0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111bb4:	e0bffb03 	ldbu	r2,-20(fp)
81111bb8:	10000526 	beq	r2,zero,81111bd0 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81111bbc:	e0bfff03 	ldbu	r2,-4(fp)
81111bc0:	1009883a 	mov	r4,r2
81111bc4:	111f3c80 	call	8111f3c8 <vFailRequestDMA>
		bSuccesL = FALSE;
81111bc8:	e03ffa15 	stw	zero,-24(fp)
81111bcc:	00000206 	br	81111bd8 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81111bd0:	00800044 	movi	r2,1
81111bd4:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81111bd8:	e0bffa17 	ldw	r2,-24(fp)
}
81111bdc:	e037883a 	mov	sp,fp
81111be0:	dfc00117 	ldw	ra,4(sp)
81111be4:	df000017 	ldw	fp,0(sp)
81111be8:	dec00204 	addi	sp,sp,8
81111bec:	f800283a 	ret

81111bf0 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111bf0:	defff804 	addi	sp,sp,-32
81111bf4:	de00012e 	bgeu	sp,et,81111bfc <bSendGiveBackNFeeCtrl+0xc>
81111bf8:	003b68fa 	trap	3
81111bfc:	dfc00715 	stw	ra,28(sp)
81111c00:	df000615 	stw	fp,24(sp)
81111c04:	df000604 	addi	fp,sp,24
81111c08:	2807883a 	mov	r3,r5
81111c0c:	3005883a 	mov	r2,r6
81111c10:	e13ffd05 	stb	r4,-12(fp)
81111c14:	e0fffe05 	stb	r3,-8(fp)
81111c18:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111c1c:	00800404 	movi	r2,16
81111c20:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111c24:	e0bffd03 	ldbu	r2,-12(fp)
81111c28:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111c2c:	e0bffe03 	ldbu	r2,-8(fp)
81111c30:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111c34:	e0bfff03 	ldbu	r2,-4(fp)
81111c38:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111c3c:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111c40:	d0a07017 	ldw	r2,-32320(gp)
81111c44:	e0fffc17 	ldw	r3,-16(fp)
81111c48:	180b883a 	mov	r5,r3
81111c4c:	1009883a 	mov	r4,r2
81111c50:	114001c0 	call	8114001c <OSQPost>
81111c54:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111c58:	e0bffb03 	ldbu	r2,-20(fp)
81111c5c:	10000526 	beq	r2,zero,81111c74 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81111c60:	e0bfff03 	ldbu	r2,-4(fp)
81111c64:	1009883a 	mov	r4,r2
81111c68:	111f3c80 	call	8111f3c8 <vFailRequestDMA>
		bSuccesL = FALSE;
81111c6c:	e03ffa15 	stw	zero,-24(fp)
81111c70:	00000206 	br	81111c7c <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81111c74:	00800044 	movi	r2,1
81111c78:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81111c7c:	e0bffa17 	ldw	r2,-24(fp)
}
81111c80:	e037883a 	mov	sp,fp
81111c84:	dfc00117 	ldw	ra,4(sp)
81111c88:	df000017 	ldw	fp,0(sp)
81111c8c:	dec00204 	addi	sp,sp,8
81111c90:	f800283a 	ret

81111c94 <vPrintConsoleNFee>:




#if DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81111c94:	defffa04 	addi	sp,sp,-24
81111c98:	de00012e 	bgeu	sp,et,81111ca0 <vPrintConsoleNFee+0xc>
81111c9c:	003b68fa 	trap	3
81111ca0:	dfc00515 	stw	ra,20(sp)
81111ca4:	df000415 	stw	fp,16(sp)
81111ca8:	df000404 	addi	fp,sp,16
81111cac:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81111cb0:	e0bfff17 	ldw	r2,-4(fp)
81111cb4:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81111cb8:	d0e06217 	ldw	r3,-32376(gp)
81111cbc:	e0bffe17 	ldw	r2,-8(fp)
81111cc0:	10800003 	ldbu	r2,0(r2)
81111cc4:	10803fcc 	andi	r2,r2,255
81111cc8:	100d883a 	mov	r6,r2
81111ccc:	01604574 	movhi	r5,33045
81111cd0:	297bb504 	addi	r5,r5,-4396
81111cd4:	1809883a 	mov	r4,r3
81111cd8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
81111cdc:	d0a06217 	ldw	r2,-32376(gp)
81111ce0:	100b883a 	mov	r5,r2
81111ce4:	01000284 	movi	r4,10
81111ce8:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81111cec:	d0e06217 	ldw	r3,-32376(gp)
81111cf0:	e0bffe17 	ldw	r2,-8(fp)
81111cf4:	10800003 	ldbu	r2,0(r2)
81111cf8:	10803fcc 	andi	r2,r2,255
81111cfc:	100d883a 	mov	r6,r2
81111d00:	01604574 	movhi	r5,33045
81111d04:	297bca04 	addi	r5,r5,-4312
81111d08:	1809883a 	mov	r4,r3
81111d0c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81111d10:	d0e06217 	ldw	r3,-32376(gp)
81111d14:	e0bffe17 	ldw	r2,-8(fp)
81111d18:	10802f0b 	ldhu	r2,188(r2)
81111d1c:	10bfffcc 	andi	r2,r2,65535
81111d20:	100d883a 	mov	r6,r2
81111d24:	01604574 	movhi	r5,33045
81111d28:	297bd004 	addi	r5,r5,-4288
81111d2c:	1809883a 	mov	r4,r3
81111d30:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
81111d34:	d0e06217 	ldw	r3,-32376(gp)
81111d38:	e0bffe17 	ldw	r2,-8(fp)
81111d3c:	10802f8b 	ldhu	r2,190(r2)
81111d40:	10bfffcc 	andi	r2,r2,65535
81111d44:	100d883a 	mov	r6,r2
81111d48:	01604574 	movhi	r5,33045
81111d4c:	297bd504 	addi	r5,r5,-4268
81111d50:	1809883a 	mov	r4,r3
81111d54:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81111d58:	d0e06217 	ldw	r3,-32376(gp)
81111d5c:	e0bffe17 	ldw	r2,-8(fp)
81111d60:	1080300b 	ldhu	r2,192(r2)
81111d64:	10bfffcc 	andi	r2,r2,65535
81111d68:	100d883a 	mov	r6,r2
81111d6c:	01604574 	movhi	r5,33045
81111d70:	297bdb04 	addi	r5,r5,-4244
81111d74:	1809883a 	mov	r4,r3
81111d78:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81111d7c:	d0e06217 	ldw	r3,-32376(gp)
81111d80:	e0bffe17 	ldw	r2,-8(fp)
81111d84:	1080308b 	ldhu	r2,194(r2)
81111d88:	10bfffcc 	andi	r2,r2,65535
81111d8c:	100d883a 	mov	r6,r2
81111d90:	01604574 	movhi	r5,33045
81111d94:	297bdf04 	addi	r5,r5,-4228
81111d98:	1809883a 	mov	r4,r3
81111d9c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81111da0:	d0e06217 	ldw	r3,-32376(gp)
81111da4:	e0bffe17 	ldw	r2,-8(fp)
81111da8:	1080310b 	ldhu	r2,196(r2)
81111dac:	10bfffcc 	andi	r2,r2,65535
81111db0:	100d883a 	mov	r6,r2
81111db4:	01604574 	movhi	r5,33045
81111db8:	297be504 	addi	r5,r5,-4204
81111dbc:	1809883a 	mov	r4,r3
81111dc0:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
81111dc4:	d0a06217 	ldw	r2,-32376(gp)
81111dc8:	100b883a 	mov	r5,r2
81111dcc:	01000284 	movi	r4,10
81111dd0:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81111dd4:	d0e06217 	ldw	r3,-32376(gp)
81111dd8:	e0bffe17 	ldw	r2,-8(fp)
81111ddc:	10800003 	ldbu	r2,0(r2)
81111de0:	10803fcc 	andi	r2,r2,255
81111de4:	100d883a 	mov	r6,r2
81111de8:	01604574 	movhi	r5,33045
81111dec:	297bea04 	addi	r5,r5,-4184
81111df0:	1809883a 	mov	r4,r3
81111df4:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81111df8:	d0e06217 	ldw	r3,-32376(gp)
81111dfc:	e0bffe17 	ldw	r2,-8(fp)
81111e00:	10802c17 	ldw	r2,176(r2)
81111e04:	100d883a 	mov	r6,r2
81111e08:	01604574 	movhi	r5,33045
81111e0c:	297bf004 	addi	r5,r5,-4160
81111e10:	1809883a 	mov	r4,r3
81111e14:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81111e18:	d0e06217 	ldw	r3,-32376(gp)
81111e1c:	e0bffe17 	ldw	r2,-8(fp)
81111e20:	10802117 	ldw	r2,132(r2)
81111e24:	100d883a 	mov	r6,r2
81111e28:	01604574 	movhi	r5,33045
81111e2c:	297bf604 	addi	r5,r5,-4136
81111e30:	1809883a 	mov	r4,r3
81111e34:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81111e38:	d0e06217 	ldw	r3,-32376(gp)
81111e3c:	e0bffe17 	ldw	r2,-8(fp)
81111e40:	10802317 	ldw	r2,140(r2)
81111e44:	100d883a 	mov	r6,r2
81111e48:	01604574 	movhi	r5,33045
81111e4c:	297bfd04 	addi	r5,r5,-4108
81111e50:	1809883a 	mov	r4,r3
81111e54:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81111e58:	d0e06217 	ldw	r3,-32376(gp)
81111e5c:	e0bffe17 	ldw	r2,-8(fp)
81111e60:	10802417 	ldw	r2,144(r2)
81111e64:	100d883a 	mov	r6,r2
81111e68:	01604574 	movhi	r5,33045
81111e6c:	297c0404 	addi	r5,r5,-4080
81111e70:	1809883a 	mov	r4,r3
81111e74:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81111e78:	d0e06217 	ldw	r3,-32376(gp)
81111e7c:	e0bffe17 	ldw	r2,-8(fp)
81111e80:	10802517 	ldw	r2,148(r2)
81111e84:	100d883a 	mov	r6,r2
81111e88:	01604574 	movhi	r5,33045
81111e8c:	297c0b04 	addi	r5,r5,-4052
81111e90:	1809883a 	mov	r4,r3
81111e94:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81111e98:	d0e06217 	ldw	r3,-32376(gp)
81111e9c:	e0bffe17 	ldw	r2,-8(fp)
81111ea0:	10802617 	ldw	r2,152(r2)
81111ea4:	100d883a 	mov	r6,r2
81111ea8:	01604574 	movhi	r5,33045
81111eac:	297c1204 	addi	r5,r5,-4024
81111eb0:	1809883a 	mov	r4,r3
81111eb4:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81111eb8:	d1206217 	ldw	r4,-32376(gp)
81111ebc:	e0bffe17 	ldw	r2,-8(fp)
81111ec0:	10802a43 	ldbu	r2,169(r2)
81111ec4:	11403fcc 	andi	r5,r2,255
81111ec8:	e0bffe17 	ldw	r2,-8(fp)
81111ecc:	10802a83 	ldbu	r2,170(r2)
81111ed0:	11803fcc 	andi	r6,r2,255
81111ed4:	e0bffe17 	ldw	r2,-8(fp)
81111ed8:	10802ac3 	ldbu	r2,171(r2)
81111edc:	10803fcc 	andi	r2,r2,255
81111ee0:	e0fffe17 	ldw	r3,-8(fp)
81111ee4:	18c02b03 	ldbu	r3,172(r3)
81111ee8:	18c03fcc 	andi	r3,r3,255
81111eec:	d8c00115 	stw	r3,4(sp)
81111ef0:	d8800015 	stw	r2,0(sp)
81111ef4:	300f883a 	mov	r7,r6
81111ef8:	280d883a 	mov	r6,r5
81111efc:	01604574 	movhi	r5,33045
81111f00:	297c1904 	addi	r5,r5,-3996
81111f04:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81111f08:	d0e06217 	ldw	r3,-32376(gp)
81111f0c:	e0bffe17 	ldw	r2,-8(fp)
81111f10:	10802e17 	ldw	r2,184(r2)
81111f14:	100d883a 	mov	r6,r2
81111f18:	01604574 	movhi	r5,33045
81111f1c:	297c2604 	addi	r5,r5,-3944
81111f20:	1809883a 	mov	r4,r3
81111f24:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n\n");
81111f28:	d0a06217 	ldw	r2,-32376(gp)
81111f2c:	100f883a 	mov	r7,r2
81111f30:	01800084 	movi	r6,2
81111f34:	01400044 	movi	r5,1
81111f38:	01204574 	movhi	r4,33045
81111f3c:	213c2c04 	addi	r4,r4,-3920
81111f40:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81111f44:	d0e06217 	ldw	r3,-32376(gp)
81111f48:	e0bffe17 	ldw	r2,-8(fp)
81111f4c:	10800003 	ldbu	r2,0(r2)
81111f50:	10803fcc 	andi	r2,r2,255
81111f54:	100d883a 	mov	r6,r2
81111f58:	01604574 	movhi	r5,33045
81111f5c:	297c2d04 	addi	r5,r5,-3916
81111f60:	1809883a 	mov	r4,r3
81111f64:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    General Info: \n");
81111f68:	d0a06217 	ldw	r2,-32376(gp)
81111f6c:	100f883a 	mov	r7,r2
81111f70:	018004c4 	movi	r6,19
81111f74:	01400044 	movi	r5,1
81111f78:	01204574 	movhi	r4,33045
81111f7c:	213c3304 	addi	r4,r4,-3892
81111f80:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81111f84:	d0e06217 	ldw	r3,-32376(gp)
81111f88:	e0bffe17 	ldw	r2,-8(fp)
81111f8c:	10800117 	ldw	r2,4(r2)
81111f90:	100d883a 	mov	r6,r2
81111f94:	01604574 	movhi	r5,33045
81111f98:	297c3804 	addi	r5,r5,-3872
81111f9c:	1809883a 	mov	r4,r3
81111fa0:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81111fa4:	d0e06217 	ldw	r3,-32376(gp)
81111fa8:	e0bffe17 	ldw	r2,-8(fp)
81111fac:	10800217 	ldw	r2,8(r2)
81111fb0:	100d883a 	mov	r6,r2
81111fb4:	01604574 	movhi	r5,33045
81111fb8:	297c4004 	addi	r5,r5,-3840
81111fbc:	1809883a 	mov	r4,r3
81111fc0:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81111fc4:	d0e06217 	ldw	r3,-32376(gp)
81111fc8:	e0bffe17 	ldw	r2,-8(fp)
81111fcc:	10800317 	ldw	r2,12(r2)
81111fd0:	100d883a 	mov	r6,r2
81111fd4:	01604574 	movhi	r5,33045
81111fd8:	297c4804 	addi	r5,r5,-3808
81111fdc:	1809883a 	mov	r4,r3
81111fe0:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81111fe4:	d0a06217 	ldw	r2,-32376(gp)
81111fe8:	100f883a 	mov	r7,r2
81111fec:	01800644 	movi	r6,25
81111ff0:	01400044 	movi	r5,1
81111ff4:	01204574 	movhi	r4,33045
81111ff8:	213c4f04 	addi	r4,r4,-3780
81111ffc:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81112000:	d0e06217 	ldw	r3,-32376(gp)
81112004:	e0bffe17 	ldw	r2,-8(fp)
81112008:	10800517 	ldw	r2,20(r2)
8111200c:	100d883a 	mov	r6,r2
81112010:	01604574 	movhi	r5,33045
81112014:	297c4004 	addi	r5,r5,-3840
81112018:	1809883a 	mov	r4,r3
8111201c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Total of Blocks = %lu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81112020:	d0e06217 	ldw	r3,-32376(gp)
81112024:	e0bffe17 	ldw	r2,-8(fp)
81112028:	10800417 	ldw	r2,16(r2)
8111202c:	100d883a 	mov	r6,r2
81112030:	01604574 	movhi	r5,33045
81112034:	297c5604 	addi	r5,r5,-3752
81112038:	1809883a 	mov	r4,r3
8111203c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81112040:	d0e06217 	ldw	r3,-32376(gp)
81112044:	e0bffe17 	ldw	r2,-8(fp)
81112048:	10800603 	ldbu	r2,24(r2)
8111204c:	10803fcc 	andi	r2,r2,255
81112050:	100d883a 	mov	r6,r2
81112054:	01604574 	movhi	r5,33045
81112058:	297c5e04 	addi	r5,r5,-3720
8111205c:	1809883a 	mov	r4,r3
81112060:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81112064:	d2206217 	ldw	r8,-32376(gp)
81112068:	e13ffe17 	ldw	r4,-8(fp)
8111206c:	20800717 	ldw	r2,28(r4)
81112070:	20c00817 	ldw	r3,32(r4)
81112074:	100d883a 	mov	r6,r2
81112078:	180f883a 	mov	r7,r3
8111207c:	01604574 	movhi	r5,33045
81112080:	297c6604 	addi	r5,r5,-3688
81112084:	4009883a 	mov	r4,r8
81112088:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
8111208c:	d0a06217 	ldw	r2,-32376(gp)
81112090:	100b883a 	mov	r5,r2
81112094:	01000284 	movi	r4,10
81112098:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8111209c:	d0e06217 	ldw	r3,-32376(gp)
811120a0:	e0bffe17 	ldw	r2,-8(fp)
811120a4:	10800003 	ldbu	r2,0(r2)
811120a8:	10803fcc 	andi	r2,r2,255
811120ac:	100f883a 	mov	r7,r2
811120b0:	000d883a 	mov	r6,zero
811120b4:	01604574 	movhi	r5,33045
811120b8:	297c6e04 	addi	r5,r5,-3656
811120bc:	1809883a 	mov	r4,r3
811120c0:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Left side \n");
811120c4:	d0a06217 	ldw	r2,-32376(gp)
811120c8:	100f883a 	mov	r7,r2
811120cc:	018004c4 	movi	r6,19
811120d0:	01400044 	movi	r5,1
811120d4:	01204574 	movhi	r4,33045
811120d8:	213c7804 	addi	r4,r4,-3616
811120dc:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
811120e0:	d0e06217 	ldw	r3,-32376(gp)
811120e4:	e0bffe17 	ldw	r2,-8(fp)
811120e8:	10800917 	ldw	r2,36(r2)
811120ec:	100d883a 	mov	r6,r2
811120f0:	01604574 	movhi	r5,33045
811120f4:	297c7d04 	addi	r5,r5,-3596
811120f8:	1809883a 	mov	r4,r3
811120fc:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81112100:	d0e06217 	ldw	r3,-32376(gp)
81112104:	e0bffe17 	ldw	r2,-8(fp)
81112108:	10800a17 	ldw	r2,40(r2)
8111210c:	100d883a 	mov	r6,r2
81112110:	01604574 	movhi	r5,33045
81112114:	297c8604 	addi	r5,r5,-3560
81112118:	1809883a 	mov	r4,r3
8111211c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81112120:	d0e06217 	ldw	r3,-32376(gp)
81112124:	e0bffe17 	ldw	r2,-8(fp)
81112128:	10800b17 	ldw	r2,44(r2)
8111212c:	100d883a 	mov	r6,r2
81112130:	01604574 	movhi	r5,33045
81112134:	297c9104 	addi	r5,r5,-3516
81112138:	1809883a 	mov	r4,r3
8111213c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Right side \n");
81112140:	d0a06217 	ldw	r2,-32376(gp)
81112144:	100f883a 	mov	r7,r2
81112148:	01800504 	movi	r6,20
8111214c:	01400044 	movi	r5,1
81112150:	01204574 	movhi	r4,33045
81112154:	213c9d04 	addi	r4,r4,-3468
81112158:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8111215c:	d0e06217 	ldw	r3,-32376(gp)
81112160:	e0bffe17 	ldw	r2,-8(fp)
81112164:	10800c17 	ldw	r2,48(r2)
81112168:	100d883a 	mov	r6,r2
8111216c:	01604574 	movhi	r5,33045
81112170:	297c7d04 	addi	r5,r5,-3596
81112174:	1809883a 	mov	r4,r3
81112178:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8111217c:	d0e06217 	ldw	r3,-32376(gp)
81112180:	e0bffe17 	ldw	r2,-8(fp)
81112184:	10800d17 	ldw	r2,52(r2)
81112188:	100d883a 	mov	r6,r2
8111218c:	01604574 	movhi	r5,33045
81112190:	297c8604 	addi	r5,r5,-3560
81112194:	1809883a 	mov	r4,r3
81112198:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8111219c:	d0e06217 	ldw	r3,-32376(gp)
811121a0:	e0bffe17 	ldw	r2,-8(fp)
811121a4:	10800e17 	ldw	r2,56(r2)
811121a8:	100d883a 	mov	r6,r2
811121ac:	01604574 	movhi	r5,33045
811121b0:	297c9104 	addi	r5,r5,-3516
811121b4:	1809883a 	mov	r4,r3
811121b8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
811121bc:	d0a06217 	ldw	r2,-32376(gp)
811121c0:	100b883a 	mov	r5,r2
811121c4:	01000284 	movi	r4,10
811121c8:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
811121cc:	d0e06217 	ldw	r3,-32376(gp)
811121d0:	e0bffe17 	ldw	r2,-8(fp)
811121d4:	10800003 	ldbu	r2,0(r2)
811121d8:	10803fcc 	andi	r2,r2,255
811121dc:	100f883a 	mov	r7,r2
811121e0:	01800044 	movi	r6,1
811121e4:	01604574 	movhi	r5,33045
811121e8:	297c6e04 	addi	r5,r5,-3656
811121ec:	1809883a 	mov	r4,r3
811121f0:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Left side \n");
811121f4:	d0a06217 	ldw	r2,-32376(gp)
811121f8:	100f883a 	mov	r7,r2
811121fc:	018004c4 	movi	r6,19
81112200:	01400044 	movi	r5,1
81112204:	01204574 	movhi	r4,33045
81112208:	213c7804 	addi	r4,r4,-3616
8111220c:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81112210:	d0e06217 	ldw	r3,-32376(gp)
81112214:	e0bffe17 	ldw	r2,-8(fp)
81112218:	10800f17 	ldw	r2,60(r2)
8111221c:	100d883a 	mov	r6,r2
81112220:	01604574 	movhi	r5,33045
81112224:	297c7d04 	addi	r5,r5,-3596
81112228:	1809883a 	mov	r4,r3
8111222c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81112230:	d0e06217 	ldw	r3,-32376(gp)
81112234:	e0bffe17 	ldw	r2,-8(fp)
81112238:	10801017 	ldw	r2,64(r2)
8111223c:	100d883a 	mov	r6,r2
81112240:	01604574 	movhi	r5,33045
81112244:	297c8604 	addi	r5,r5,-3560
81112248:	1809883a 	mov	r4,r3
8111224c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81112250:	d0e06217 	ldw	r3,-32376(gp)
81112254:	e0bffe17 	ldw	r2,-8(fp)
81112258:	10801117 	ldw	r2,68(r2)
8111225c:	100d883a 	mov	r6,r2
81112260:	01604574 	movhi	r5,33045
81112264:	297c9104 	addi	r5,r5,-3516
81112268:	1809883a 	mov	r4,r3
8111226c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Right side \n");
81112270:	d0a06217 	ldw	r2,-32376(gp)
81112274:	100f883a 	mov	r7,r2
81112278:	01800504 	movi	r6,20
8111227c:	01400044 	movi	r5,1
81112280:	01204574 	movhi	r4,33045
81112284:	213c9d04 	addi	r4,r4,-3468
81112288:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8111228c:	d0e06217 	ldw	r3,-32376(gp)
81112290:	e0bffe17 	ldw	r2,-8(fp)
81112294:	10801217 	ldw	r2,72(r2)
81112298:	100d883a 	mov	r6,r2
8111229c:	01604574 	movhi	r5,33045
811122a0:	297c7d04 	addi	r5,r5,-3596
811122a4:	1809883a 	mov	r4,r3
811122a8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
811122ac:	d0e06217 	ldw	r3,-32376(gp)
811122b0:	e0bffe17 	ldw	r2,-8(fp)
811122b4:	10801317 	ldw	r2,76(r2)
811122b8:	100d883a 	mov	r6,r2
811122bc:	01604574 	movhi	r5,33045
811122c0:	297c8604 	addi	r5,r5,-3560
811122c4:	1809883a 	mov	r4,r3
811122c8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
811122cc:	d0e06217 	ldw	r3,-32376(gp)
811122d0:	e0bffe17 	ldw	r2,-8(fp)
811122d4:	10801417 	ldw	r2,80(r2)
811122d8:	100d883a 	mov	r6,r2
811122dc:	01604574 	movhi	r5,33045
811122e0:	297c9104 	addi	r5,r5,-3516
811122e4:	1809883a 	mov	r4,r3
811122e8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
811122ec:	d0a06217 	ldw	r2,-32376(gp)
811122f0:	100b883a 	mov	r5,r2
811122f4:	01000284 	movi	r4,10
811122f8:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
811122fc:	d0e06217 	ldw	r3,-32376(gp)
81112300:	e0bffe17 	ldw	r2,-8(fp)
81112304:	10800003 	ldbu	r2,0(r2)
81112308:	10803fcc 	andi	r2,r2,255
8111230c:	100f883a 	mov	r7,r2
81112310:	01800084 	movi	r6,2
81112314:	01604574 	movhi	r5,33045
81112318:	297c6e04 	addi	r5,r5,-3656
8111231c:	1809883a 	mov	r4,r3
81112320:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Left side \n");
81112324:	d0a06217 	ldw	r2,-32376(gp)
81112328:	100f883a 	mov	r7,r2
8111232c:	018004c4 	movi	r6,19
81112330:	01400044 	movi	r5,1
81112334:	01204574 	movhi	r4,33045
81112338:	213c7804 	addi	r4,r4,-3616
8111233c:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81112340:	d0e06217 	ldw	r3,-32376(gp)
81112344:	e0bffe17 	ldw	r2,-8(fp)
81112348:	10801517 	ldw	r2,84(r2)
8111234c:	100d883a 	mov	r6,r2
81112350:	01604574 	movhi	r5,33045
81112354:	297c7d04 	addi	r5,r5,-3596
81112358:	1809883a 	mov	r4,r3
8111235c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81112360:	d0e06217 	ldw	r3,-32376(gp)
81112364:	e0bffe17 	ldw	r2,-8(fp)
81112368:	10801617 	ldw	r2,88(r2)
8111236c:	100d883a 	mov	r6,r2
81112370:	01604574 	movhi	r5,33045
81112374:	297c8604 	addi	r5,r5,-3560
81112378:	1809883a 	mov	r4,r3
8111237c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81112380:	d0e06217 	ldw	r3,-32376(gp)
81112384:	e0bffe17 	ldw	r2,-8(fp)
81112388:	10801717 	ldw	r2,92(r2)
8111238c:	100d883a 	mov	r6,r2
81112390:	01604574 	movhi	r5,33045
81112394:	297c9104 	addi	r5,r5,-3516
81112398:	1809883a 	mov	r4,r3
8111239c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Right side \n");
811123a0:	d0a06217 	ldw	r2,-32376(gp)
811123a4:	100f883a 	mov	r7,r2
811123a8:	01800504 	movi	r6,20
811123ac:	01400044 	movi	r5,1
811123b0:	01204574 	movhi	r4,33045
811123b4:	213c9d04 	addi	r4,r4,-3468
811123b8:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
811123bc:	d0e06217 	ldw	r3,-32376(gp)
811123c0:	e0bffe17 	ldw	r2,-8(fp)
811123c4:	10801817 	ldw	r2,96(r2)
811123c8:	100d883a 	mov	r6,r2
811123cc:	01604574 	movhi	r5,33045
811123d0:	297c7d04 	addi	r5,r5,-3596
811123d4:	1809883a 	mov	r4,r3
811123d8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
811123dc:	d0e06217 	ldw	r3,-32376(gp)
811123e0:	e0bffe17 	ldw	r2,-8(fp)
811123e4:	10801917 	ldw	r2,100(r2)
811123e8:	100d883a 	mov	r6,r2
811123ec:	01604574 	movhi	r5,33045
811123f0:	297c8604 	addi	r5,r5,-3560
811123f4:	1809883a 	mov	r4,r3
811123f8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
811123fc:	d0e06217 	ldw	r3,-32376(gp)
81112400:	e0bffe17 	ldw	r2,-8(fp)
81112404:	10801a17 	ldw	r2,104(r2)
81112408:	100d883a 	mov	r6,r2
8111240c:	01604574 	movhi	r5,33045
81112410:	297c9104 	addi	r5,r5,-3516
81112414:	1809883a 	mov	r4,r3
81112418:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
8111241c:	d0a06217 	ldw	r2,-32376(gp)
81112420:	100b883a 	mov	r5,r2
81112424:	01000284 	movi	r4,10
81112428:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8111242c:	d0e06217 	ldw	r3,-32376(gp)
81112430:	e0bffe17 	ldw	r2,-8(fp)
81112434:	10800003 	ldbu	r2,0(r2)
81112438:	10803fcc 	andi	r2,r2,255
8111243c:	100f883a 	mov	r7,r2
81112440:	018000c4 	movi	r6,3
81112444:	01604574 	movhi	r5,33045
81112448:	297c6e04 	addi	r5,r5,-3656
8111244c:	1809883a 	mov	r4,r3
81112450:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Left side \n");
81112454:	d0a06217 	ldw	r2,-32376(gp)
81112458:	100f883a 	mov	r7,r2
8111245c:	018004c4 	movi	r6,19
81112460:	01400044 	movi	r5,1
81112464:	01204574 	movhi	r4,33045
81112468:	213c7804 	addi	r4,r4,-3616
8111246c:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81112470:	d0e06217 	ldw	r3,-32376(gp)
81112474:	e0bffe17 	ldw	r2,-8(fp)
81112478:	10801b17 	ldw	r2,108(r2)
8111247c:	100d883a 	mov	r6,r2
81112480:	01604574 	movhi	r5,33045
81112484:	297c7d04 	addi	r5,r5,-3596
81112488:	1809883a 	mov	r4,r3
8111248c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81112490:	d0e06217 	ldw	r3,-32376(gp)
81112494:	e0bffe17 	ldw	r2,-8(fp)
81112498:	10801c17 	ldw	r2,112(r2)
8111249c:	100d883a 	mov	r6,r2
811124a0:	01604574 	movhi	r5,33045
811124a4:	297c8604 	addi	r5,r5,-3560
811124a8:	1809883a 	mov	r4,r3
811124ac:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
811124b0:	d0e06217 	ldw	r3,-32376(gp)
811124b4:	e0bffe17 	ldw	r2,-8(fp)
811124b8:	10801d17 	ldw	r2,116(r2)
811124bc:	100d883a 	mov	r6,r2
811124c0:	01604574 	movhi	r5,33045
811124c4:	297c9104 	addi	r5,r5,-3516
811124c8:	1809883a 	mov	r4,r3
811124cc:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"        Right side \n");
811124d0:	d0a06217 	ldw	r2,-32376(gp)
811124d4:	100f883a 	mov	r7,r2
811124d8:	01800504 	movi	r6,20
811124dc:	01400044 	movi	r5,1
811124e0:	01204574 	movhi	r4,33045
811124e4:	213c9d04 	addi	r4,r4,-3468
811124e8:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
811124ec:	d0e06217 	ldw	r3,-32376(gp)
811124f0:	e0bffe17 	ldw	r2,-8(fp)
811124f4:	10801e17 	ldw	r2,120(r2)
811124f8:	100d883a 	mov	r6,r2
811124fc:	01604574 	movhi	r5,33045
81112500:	297c7d04 	addi	r5,r5,-3596
81112504:	1809883a 	mov	r4,r3
81112508:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8111250c:	d0e06217 	ldw	r3,-32376(gp)
81112510:	e0bffe17 	ldw	r2,-8(fp)
81112514:	10801f17 	ldw	r2,124(r2)
81112518:	100d883a 	mov	r6,r2
8111251c:	01604574 	movhi	r5,33045
81112520:	297c8604 	addi	r5,r5,-3560
81112524:	1809883a 	mov	r4,r3
81112528:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8111252c:	d0e06217 	ldw	r3,-32376(gp)
81112530:	e0bffe17 	ldw	r2,-8(fp)
81112534:	10802017 	ldw	r2,128(r2)
81112538:	100d883a 	mov	r6,r2
8111253c:	01604574 	movhi	r5,33045
81112540:	297c9104 	addi	r5,r5,-3516
81112544:	1809883a 	mov	r4,r3
81112548:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"\n");
8111254c:	d0a06217 	ldw	r2,-32376(gp)
81112550:	100b883a 	mov	r5,r2
81112554:	01000284 	movi	r4,10
81112558:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"==============================================================================\n");
8111255c:	d0a06217 	ldw	r2,-32376(gp)
81112560:	100f883a 	mov	r7,r2
81112564:	018013c4 	movi	r6,79
81112568:	01400044 	movi	r5,1
8111256c:	01204574 	movhi	r4,33045
81112570:	213ca304 	addi	r4,r4,-3444
81112574:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"==============================================================================\n");
81112578:	d0a06217 	ldw	r2,-32376(gp)
8111257c:	100f883a 	mov	r7,r2
81112580:	018013c4 	movi	r6,79
81112584:	01400044 	movi	r5,1
81112588:	01204574 	movhi	r4,33045
8111258c:	213ca304 	addi	r4,r4,-3444
81112590:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"\n");
81112594:	d0a06217 	ldw	r2,-32376(gp)
81112598:	100b883a 	mov	r5,r2
8111259c:	01000284 	movi	r4,10
811125a0:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"\n");
811125a4:	d0a06217 	ldw	r2,-32376(gp)
811125a8:	100b883a 	mov	r5,r2
811125ac:	01000284 	movi	r4,10
811125b0:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"\n");
811125b4:	d0a06217 	ldw	r2,-32376(gp)
811125b8:	100b883a 	mov	r5,r2
811125bc:	01000284 	movi	r4,10
811125c0:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"\n");
811125c4:	d0a06217 	ldw	r2,-32376(gp)
811125c8:	100b883a 	mov	r5,r2
811125cc:	01000284 	movi	r4,10
811125d0:	11236c80 	call	811236c8 <fputc>
		fprintf(fp,"\n");
811125d4:	d0a06217 	ldw	r2,-32376(gp)
811125d8:	100b883a 	mov	r5,r2
811125dc:	01000284 	movi	r4,10
811125e0:	11236c80 	call	811236c8 <fputc>
	}
811125e4:	0001883a 	nop
811125e8:	e037883a 	mov	sp,fp
811125ec:	dfc00117 	ldw	ra,4(sp)
811125f0:	df000017 	ldw	fp,0(sp)
811125f4:	dec00204 	addi	sp,sp,8
811125f8:	f800283a 	ret

811125fc <bPrepareDoubleBuffer>:
#endif


bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
811125fc:	defff804 	addi	sp,sp,-32
81112600:	de00012e 	bgeu	sp,et,81112608 <bPrepareDoubleBuffer+0xc>
81112604:	003b68fa 	trap	3
81112608:	dfc00715 	stw	ra,28(sp)
8111260c:	df000615 	stw	fp,24(sp)
81112610:	df000604 	addi	fp,sp,24
81112614:	e13ffc15 	stw	r4,-16(fp)
81112618:	2807883a 	mov	r3,r5
8111261c:	3005883a 	mov	r2,r6
81112620:	e1ffff15 	stw	r7,-4(fp)
81112624:	e0fffd05 	stb	r3,-12(fp)
81112628:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
8111262c:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
81112630:	e0bffc17 	ldw	r2,-16(fp)
81112634:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
81112638:	e0bffc17 	ldw	r2,-16(fp)
8111263c:	10c00017 	ldw	r3,0(r2)
81112640:	e0bffc17 	ldw	r2,-16(fp)
81112644:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
81112648:	e0bffc17 	ldw	r2,-16(fp)
8111264c:	10800117 	ldw	r2,4(r2)
81112650:	10c00404 	addi	r3,r2,16
81112654:	e0bfff17 	ldw	r2,-4(fp)
81112658:	10800417 	ldw	r2,16(r2)
8111265c:	18800736 	bltu	r3,r2,8111267c <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81112660:	e0bfff17 	ldw	r2,-4(fp)
81112664:	10c00417 	ldw	r3,16(r2)
81112668:	e0bffc17 	ldw	r2,-16(fp)
8111266c:	10800117 	ldw	r2,4(r2)
81112670:	1885c83a 	sub	r2,r3,r2
81112674:	e0bffb15 	stw	r2,-20(fp)
81112678:	00000206 	br	81112684 <bPrepareDoubleBuffer+0x88>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
8111267c:	00800404 	movi	r2,16
81112680:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81112684:	00a045f4 	movhi	r2,33047
81112688:	10a34f04 	addi	r2,r2,-29380
8111268c:	10800a0b 	ldhu	r2,40(r2)
81112690:	10bfffcc 	andi	r2,r2,65535
81112694:	10000b1e 	bne	r2,zero,811126c4 <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81112698:	e0bffb17 	ldw	r2,-20(fp)
8111269c:	10803fcc 	andi	r2,r2,255
811126a0:	000b883a 	mov	r5,zero
811126a4:	1009883a 	mov	r4,r2
811126a8:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
811126ac:	e0bffb17 	ldw	r2,-20(fp)
811126b0:	10803fcc 	andi	r2,r2,255
811126b4:	01400044 	movi	r5,1
811126b8:	1009883a 	mov	r4,r2
811126bc:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
811126c0:	00000a06 	br	811126ec <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
811126c4:	e0bffb17 	ldw	r2,-20(fp)
811126c8:	10803fcc 	andi	r2,r2,255
811126cc:	000b883a 	mov	r5,zero
811126d0:	1009883a 	mov	r4,r2
811126d4:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
811126d8:	e0bffb17 	ldw	r2,-20(fp)
811126dc:	10803fcc 	andi	r2,r2,255
811126e0:	01400044 	movi	r5,1
811126e4:	1009883a 	mov	r4,r2
811126e8:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
811126ec:	e0bffd03 	ldbu	r2,-12(fp)
811126f0:	1000231e 	bne	r2,zero,81112780 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811126f4:	e0bffc17 	ldw	r2,-16(fp)
811126f8:	10800217 	ldw	r2,8(r2)
811126fc:	1011883a 	mov	r8,r2
81112700:	e0bffb17 	ldw	r2,-20(fp)
81112704:	10ffffcc 	andi	r3,r2,65535
81112708:	d0a05603 	ldbu	r2,-32424(gp)
8111270c:	11003fcc 	andi	r4,r2,255
81112710:	e0bfff17 	ldw	r2,-4(fp)
81112714:	10800043 	ldbu	r2,1(r2)
81112718:	10803fcc 	andi	r2,r2,255
8111271c:	100f883a 	mov	r7,r2
81112720:	200d883a 	mov	r6,r4
81112724:	180b883a 	mov	r5,r3
81112728:	4009883a 	mov	r4,r8
8111272c:	1103d040 	call	81103d04 <bSdmaDmaM1Transfer>
81112730:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81112734:	e0bffa17 	ldw	r2,-24(fp)
81112738:	10800058 	cmpnei	r2,r2,1
8111273c:	10000e1e 	bne	r2,zero,81112778 <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81112740:	e0bffc17 	ldw	r2,-16(fp)
81112744:	10c00217 	ldw	r3,8(r2)
81112748:	e0bffb17 	ldw	r2,-20(fp)
8111274c:	10802224 	muli	r2,r2,136
81112750:	1887883a 	add	r3,r3,r2
81112754:	e0bffc17 	ldw	r2,-16(fp)
81112758:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8111275c:	e0bffc17 	ldw	r2,-16(fp)
81112760:	10c00117 	ldw	r3,4(r2)
81112764:	e0bffb17 	ldw	r2,-20(fp)
81112768:	1887883a 	add	r3,r3,r2
8111276c:	e0bffc17 	ldw	r2,-16(fp)
81112770:	10c00115 	stw	r3,4(r2)
81112774:	00002506 	br	8111280c <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81112778:	e0bffa17 	ldw	r2,-24(fp)
8111277c:	00009506 	br	811129d4 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81112780:	e0bffc17 	ldw	r2,-16(fp)
81112784:	10800217 	ldw	r2,8(r2)
81112788:	1011883a 	mov	r8,r2
8111278c:	e0bffb17 	ldw	r2,-20(fp)
81112790:	10ffffcc 	andi	r3,r2,65535
81112794:	d0a05603 	ldbu	r2,-32424(gp)
81112798:	11003fcc 	andi	r4,r2,255
8111279c:	e0bfff17 	ldw	r2,-4(fp)
811127a0:	10800043 	ldbu	r2,1(r2)
811127a4:	10803fcc 	andi	r2,r2,255
811127a8:	100f883a 	mov	r7,r2
811127ac:	200d883a 	mov	r6,r4
811127b0:	180b883a 	mov	r5,r3
811127b4:	4009883a 	mov	r4,r8
811127b8:	11041580 	call	81104158 <bSdmaDmaM2Transfer>
811127bc:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
811127c0:	e0bffa17 	ldw	r2,-24(fp)
811127c4:	10800058 	cmpnei	r2,r2,1
811127c8:	10000e1e 	bne	r2,zero,81112804 <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811127cc:	e0bffc17 	ldw	r2,-16(fp)
811127d0:	10c00217 	ldw	r3,8(r2)
811127d4:	e0bffb17 	ldw	r2,-20(fp)
811127d8:	10802224 	muli	r2,r2,136
811127dc:	1887883a 	add	r3,r3,r2
811127e0:	e0bffc17 	ldw	r2,-16(fp)
811127e4:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
811127e8:	e0bffc17 	ldw	r2,-16(fp)
811127ec:	10c00117 	ldw	r3,4(r2)
811127f0:	e0bffb17 	ldw	r2,-20(fp)
811127f4:	1887883a 	add	r3,r3,r2
811127f8:	e0bffc17 	ldw	r2,-16(fp)
811127fc:	10c00115 	stw	r3,4(r2)
81112800:	00000206 	br	8111280c <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81112804:	e0bffa17 	ldw	r2,-24(fp)
81112808:	00007206 	br	811129d4 <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8111280c:	e0bffc17 	ldw	r2,-16(fp)
81112810:	10800117 	ldw	r2,4(r2)
81112814:	10c00404 	addi	r3,r2,16
81112818:	e0bfff17 	ldw	r2,-4(fp)
8111281c:	10800417 	ldw	r2,16(r2)
81112820:	18800736 	bltu	r3,r2,81112840 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81112824:	e0bfff17 	ldw	r2,-4(fp)
81112828:	10c00417 	ldw	r3,16(r2)
8111282c:	e0bffc17 	ldw	r2,-16(fp)
81112830:	10800117 	ldw	r2,4(r2)
81112834:	1885c83a 	sub	r2,r3,r2
81112838:	e0bffb15 	stw	r2,-20(fp)
8111283c:	00000206 	br	81112848 <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81112840:	00800404 	movi	r2,16
81112844:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81112848:	00a045f4 	movhi	r2,33047
8111284c:	10a34f04 	addi	r2,r2,-29380
81112850:	10800a0b 	ldhu	r2,40(r2)
81112854:	10bfffcc 	andi	r2,r2,65535
81112858:	10000b1e 	bne	r2,zero,81112888 <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
8111285c:	e0bffb17 	ldw	r2,-20(fp)
81112860:	10803fcc 	andi	r2,r2,255
81112864:	000b883a 	mov	r5,zero
81112868:	1009883a 	mov	r4,r2
8111286c:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81112870:	e0bffb17 	ldw	r2,-20(fp)
81112874:	10803fcc 	andi	r2,r2,255
81112878:	01400044 	movi	r5,1
8111287c:	1009883a 	mov	r4,r2
81112880:	1105de40 	call	81105de4 <bFeebCh1SetBufferSize>
81112884:	00000a06 	br	811128b0 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81112888:	e0bffb17 	ldw	r2,-20(fp)
8111288c:	10803fcc 	andi	r2,r2,255
81112890:	000b883a 	mov	r5,zero
81112894:	1009883a 	mov	r4,r2
81112898:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
8111289c:	e0bffb17 	ldw	r2,-20(fp)
811128a0:	10803fcc 	andi	r2,r2,255
811128a4:	01400044 	movi	r5,1
811128a8:	1009883a 	mov	r4,r2
811128ac:	1105ec40 	call	81105ec4 <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
811128b0:	e0bffd03 	ldbu	r2,-12(fp)
811128b4:	1000231e 	bne	r2,zero,81112944 <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811128b8:	e0bffc17 	ldw	r2,-16(fp)
811128bc:	10800217 	ldw	r2,8(r2)
811128c0:	1011883a 	mov	r8,r2
811128c4:	e0bffb17 	ldw	r2,-20(fp)
811128c8:	10ffffcc 	andi	r3,r2,65535
811128cc:	d0a05603 	ldbu	r2,-32424(gp)
811128d0:	11003fcc 	andi	r4,r2,255
811128d4:	e0bfff17 	ldw	r2,-4(fp)
811128d8:	10800043 	ldbu	r2,1(r2)
811128dc:	10803fcc 	andi	r2,r2,255
811128e0:	100f883a 	mov	r7,r2
811128e4:	200d883a 	mov	r6,r4
811128e8:	180b883a 	mov	r5,r3
811128ec:	4009883a 	mov	r4,r8
811128f0:	1103d040 	call	81103d04 <bSdmaDmaM1Transfer>
811128f4:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
811128f8:	e0bffa17 	ldw	r2,-24(fp)
811128fc:	10800058 	cmpnei	r2,r2,1
81112900:	10000e1e 	bne	r2,zero,8111293c <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81112904:	e0bffc17 	ldw	r2,-16(fp)
81112908:	10c00217 	ldw	r3,8(r2)
8111290c:	e0bffb17 	ldw	r2,-20(fp)
81112910:	10802224 	muli	r2,r2,136
81112914:	1887883a 	add	r3,r3,r2
81112918:	e0bffc17 	ldw	r2,-16(fp)
8111291c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81112920:	e0bffc17 	ldw	r2,-16(fp)
81112924:	10c00117 	ldw	r3,4(r2)
81112928:	e0bffb17 	ldw	r2,-20(fp)
8111292c:	1887883a 	add	r3,r3,r2
81112930:	e0bffc17 	ldw	r2,-16(fp)
81112934:	10c00115 	stw	r3,4(r2)
81112938:	00002506 	br	811129d0 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
8111293c:	e0bffa17 	ldw	r2,-24(fp)
81112940:	00002406 	br	811129d4 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81112944:	e0bffc17 	ldw	r2,-16(fp)
81112948:	10800217 	ldw	r2,8(r2)
8111294c:	1011883a 	mov	r8,r2
81112950:	e0bffb17 	ldw	r2,-20(fp)
81112954:	10ffffcc 	andi	r3,r2,65535
81112958:	d0a05603 	ldbu	r2,-32424(gp)
8111295c:	11003fcc 	andi	r4,r2,255
81112960:	e0bfff17 	ldw	r2,-4(fp)
81112964:	10800043 	ldbu	r2,1(r2)
81112968:	10803fcc 	andi	r2,r2,255
8111296c:	100f883a 	mov	r7,r2
81112970:	200d883a 	mov	r6,r4
81112974:	180b883a 	mov	r5,r3
81112978:	4009883a 	mov	r4,r8
8111297c:	11041580 	call	81104158 <bSdmaDmaM2Transfer>
81112980:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81112984:	e0bffa17 	ldw	r2,-24(fp)
81112988:	10800058 	cmpnei	r2,r2,1
8111298c:	10000e1e 	bne	r2,zero,811129c8 <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81112990:	e0bffc17 	ldw	r2,-16(fp)
81112994:	10c00217 	ldw	r3,8(r2)
81112998:	e0bffb17 	ldw	r2,-20(fp)
8111299c:	10802224 	muli	r2,r2,136
811129a0:	1887883a 	add	r3,r3,r2
811129a4:	e0bffc17 	ldw	r2,-16(fp)
811129a8:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
811129ac:	e0bffc17 	ldw	r2,-16(fp)
811129b0:	10c00117 	ldw	r3,4(r2)
811129b4:	e0bffb17 	ldw	r2,-20(fp)
811129b8:	1887883a 	add	r3,r3,r2
811129bc:	e0bffc17 	ldw	r2,-16(fp)
811129c0:	10c00115 	stw	r3,4(r2)
811129c4:	00000206 	br	811129d0 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
811129c8:	e0bffa17 	ldw	r2,-24(fp)
811129cc:	00000106 	br	811129d4 <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
811129d0:	e0bffa17 	ldw	r2,-24(fp)

}
811129d4:	e037883a 	mov	sp,fp
811129d8:	dfc00117 	ldw	ra,4(sp)
811129dc:	df000017 	ldw	fp,0(sp)
811129e0:	dec00204 	addi	sp,sp,8
811129e4:	f800283a 	ret

811129e8 <vLoadCtemp>:


void vLoadCtemp(void) {
811129e8:	deffff04 	addi	sp,sp,-4
811129ec:	de00012e 	bgeu	sp,et,811129f4 <vLoadCtemp+0xc>
811129f0:	003b68fa 	trap	3
811129f4:	df000015 	stw	fp,0(sp)
811129f8:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
811129fc:	00a04574 	movhi	r2,33045
81112a00:	1096ef04 	addi	r2,r2,23484
81112a04:	00e04574 	movhi	r3,33045
81112a08:	18fcb704 	addi	r3,r3,-3364
81112a0c:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
81112a10:	00a04574 	movhi	r2,33045
81112a14:	1096ef04 	addi	r2,r2,23484
81112a18:	00e04574 	movhi	r3,33045
81112a1c:	18fcbb04 	addi	r3,r3,-3348
81112a20:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
81112a24:	00a04574 	movhi	r2,33045
81112a28:	1096ef04 	addi	r2,r2,23484
81112a2c:	00e04574 	movhi	r3,33045
81112a30:	18fcbf04 	addi	r3,r3,-3332
81112a34:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
81112a38:	00a04574 	movhi	r2,33045
81112a3c:	1096ef04 	addi	r2,r2,23484
81112a40:	00e04574 	movhi	r3,33045
81112a44:	18fcc304 	addi	r3,r3,-3316
81112a48:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
81112a4c:	00a04574 	movhi	r2,33045
81112a50:	1096ef04 	addi	r2,r2,23484
81112a54:	00e04574 	movhi	r3,33045
81112a58:	18fcc704 	addi	r3,r3,-3300
81112a5c:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
81112a60:	00a04574 	movhi	r2,33045
81112a64:	1096ef04 	addi	r2,r2,23484
81112a68:	00e04574 	movhi	r3,33045
81112a6c:	18fccb04 	addi	r3,r3,-3284
81112a70:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
81112a74:	00a04574 	movhi	r2,33045
81112a78:	1096ef04 	addi	r2,r2,23484
81112a7c:	00e04574 	movhi	r3,33045
81112a80:	18fccf04 	addi	r3,r3,-3268
81112a84:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
81112a88:	00a04574 	movhi	r2,33045
81112a8c:	1096ef04 	addi	r2,r2,23484
81112a90:	00e04574 	movhi	r3,33045
81112a94:	18fcd304 	addi	r3,r3,-3252
81112a98:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81112a9c:	00a04574 	movhi	r2,33045
81112aa0:	1096ef04 	addi	r2,r2,23484
81112aa4:	00e04574 	movhi	r3,33045
81112aa8:	18fcd704 	addi	r3,r3,-3236
81112aac:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81112ab0:	00a04574 	movhi	r2,33045
81112ab4:	1096ef04 	addi	r2,r2,23484
81112ab8:	00e04574 	movhi	r3,33045
81112abc:	18fcdb04 	addi	r3,r3,-3220
81112ac0:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81112ac4:	00a04574 	movhi	r2,33045
81112ac8:	1096ef04 	addi	r2,r2,23484
81112acc:	00e04574 	movhi	r3,33045
81112ad0:	18fcdf04 	addi	r3,r3,-3204
81112ad4:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81112ad8:	00a04574 	movhi	r2,33045
81112adc:	1096ef04 	addi	r2,r2,23484
81112ae0:	00e04574 	movhi	r3,33045
81112ae4:	18fce304 	addi	r3,r3,-3188
81112ae8:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
81112aec:	00a04574 	movhi	r2,33045
81112af0:	1096ef04 	addi	r2,r2,23484
81112af4:	00e04574 	movhi	r3,33045
81112af8:	18fce704 	addi	r3,r3,-3172
81112afc:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
81112b00:	00a04574 	movhi	r2,33045
81112b04:	1096ef04 	addi	r2,r2,23484
81112b08:	00e04574 	movhi	r3,33045
81112b0c:	18fcea04 	addi	r3,r3,-3160
81112b10:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
81112b14:	00a04574 	movhi	r2,33045
81112b18:	1096ef04 	addi	r2,r2,23484
81112b1c:	00e04574 	movhi	r3,33045
81112b20:	18fced04 	addi	r3,r3,-3148
81112b24:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
81112b28:	00a04574 	movhi	r2,33045
81112b2c:	1096ef04 	addi	r2,r2,23484
81112b30:	00e04574 	movhi	r3,33045
81112b34:	18fcf004 	addi	r3,r3,-3136
81112b38:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
81112b3c:	00a04574 	movhi	r2,33045
81112b40:	1096ef04 	addi	r2,r2,23484
81112b44:	00e04574 	movhi	r3,33045
81112b48:	18fcf404 	addi	r3,r3,-3120
81112b4c:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
81112b50:	00a04574 	movhi	r2,33045
81112b54:	1096ef04 	addi	r2,r2,23484
81112b58:	00e04574 	movhi	r3,33045
81112b5c:	18fcf704 	addi	r3,r3,-3108
81112b60:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
81112b64:	00a04574 	movhi	r2,33045
81112b68:	1096ef04 	addi	r2,r2,23484
81112b6c:	00e04574 	movhi	r3,33045
81112b70:	18fcfa04 	addi	r3,r3,-3096
81112b74:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
81112b78:	00a04574 	movhi	r2,33045
81112b7c:	1096ef04 	addi	r2,r2,23484
81112b80:	00e04574 	movhi	r3,33045
81112b84:	18fcfe04 	addi	r3,r3,-3080
81112b88:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
81112b8c:	00a04574 	movhi	r2,33045
81112b90:	1096ef04 	addi	r2,r2,23484
81112b94:	00e04574 	movhi	r3,33045
81112b98:	18fd0204 	addi	r3,r3,-3064
81112b9c:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
81112ba0:	00a04574 	movhi	r2,33045
81112ba4:	1096ef04 	addi	r2,r2,23484
81112ba8:	00e04574 	movhi	r3,33045
81112bac:	18fd0604 	addi	r3,r3,-3048
81112bb0:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
81112bb4:	00a04574 	movhi	r2,33045
81112bb8:	1096ef04 	addi	r2,r2,23484
81112bbc:	00e04574 	movhi	r3,33045
81112bc0:	18fd0a04 	addi	r3,r3,-3032
81112bc4:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
81112bc8:	00a04574 	movhi	r2,33045
81112bcc:	1096ef04 	addi	r2,r2,23484
81112bd0:	00e04574 	movhi	r3,33045
81112bd4:	18fd0e04 	addi	r3,r3,-3016
81112bd8:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
81112bdc:	00a04574 	movhi	r2,33045
81112be0:	1096ef04 	addi	r2,r2,23484
81112be4:	00e04574 	movhi	r3,33045
81112be8:	18fd1104 	addi	r3,r3,-3004
81112bec:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
81112bf0:	00a04574 	movhi	r2,33045
81112bf4:	1096ef04 	addi	r2,r2,23484
81112bf8:	00e04574 	movhi	r3,33045
81112bfc:	18fd1504 	addi	r3,r3,-2988
81112c00:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
81112c04:	00a04574 	movhi	r2,33045
81112c08:	1096ef04 	addi	r2,r2,23484
81112c0c:	00e04574 	movhi	r3,33045
81112c10:	18fd1904 	addi	r3,r3,-2972
81112c14:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
81112c18:	00a04574 	movhi	r2,33045
81112c1c:	1096ef04 	addi	r2,r2,23484
81112c20:	00e04574 	movhi	r3,33045
81112c24:	18fd1d04 	addi	r3,r3,-2956
81112c28:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
81112c2c:	00a04574 	movhi	r2,33045
81112c30:	1096ef04 	addi	r2,r2,23484
81112c34:	00e04574 	movhi	r3,33045
81112c38:	18fd2104 	addi	r3,r3,-2940
81112c3c:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
81112c40:	00a04574 	movhi	r2,33045
81112c44:	1096ef04 	addi	r2,r2,23484
81112c48:	00e04574 	movhi	r3,33045
81112c4c:	18fd2504 	addi	r3,r3,-2924
81112c50:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
81112c54:	00a04574 	movhi	r2,33045
81112c58:	1096ef04 	addi	r2,r2,23484
81112c5c:	00e04574 	movhi	r3,33045
81112c60:	18fd2a04 	addi	r3,r3,-2904
81112c64:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
81112c68:	00a04574 	movhi	r2,33045
81112c6c:	1096ef04 	addi	r2,r2,23484
81112c70:	00e04574 	movhi	r3,33045
81112c74:	18fd2e04 	addi	r3,r3,-2888
81112c78:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
81112c7c:	00a04574 	movhi	r2,33045
81112c80:	1096ef04 	addi	r2,r2,23484
81112c84:	00e04574 	movhi	r3,33045
81112c88:	18fd3204 	addi	r3,r3,-2872
81112c8c:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
81112c90:	00a04574 	movhi	r2,33045
81112c94:	1096ef04 	addi	r2,r2,23484
81112c98:	00e04574 	movhi	r3,33045
81112c9c:	18fd3604 	addi	r3,r3,-2856
81112ca0:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
81112ca4:	00a04574 	movhi	r2,33045
81112ca8:	1096ef04 	addi	r2,r2,23484
81112cac:	00e04574 	movhi	r3,33045
81112cb0:	18fd3a04 	addi	r3,r3,-2840
81112cb4:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
81112cb8:	00a04574 	movhi	r2,33045
81112cbc:	1096ef04 	addi	r2,r2,23484
81112cc0:	00e04574 	movhi	r3,33045
81112cc4:	18fd3e04 	addi	r3,r3,-2824
81112cc8:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
81112ccc:	00a04574 	movhi	r2,33045
81112cd0:	1096ef04 	addi	r2,r2,23484
81112cd4:	00e04574 	movhi	r3,33045
81112cd8:	18fd4204 	addi	r3,r3,-2808
81112cdc:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
81112ce0:	00a04574 	movhi	r2,33045
81112ce4:	1096ef04 	addi	r2,r2,23484
81112ce8:	00e04574 	movhi	r3,33045
81112cec:	18fd4604 	addi	r3,r3,-2792
81112cf0:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
81112cf4:	00a04574 	movhi	r2,33045
81112cf8:	1096ef04 	addi	r2,r2,23484
81112cfc:	00e04574 	movhi	r3,33045
81112d00:	18fd4a04 	addi	r3,r3,-2776
81112d04:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
81112d08:	00a04574 	movhi	r2,33045
81112d0c:	1096ef04 	addi	r2,r2,23484
81112d10:	00e04574 	movhi	r3,33045
81112d14:	18fd4e04 	addi	r3,r3,-2760
81112d18:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
81112d1c:	00a04574 	movhi	r2,33045
81112d20:	1096ef04 	addi	r2,r2,23484
81112d24:	00e04574 	movhi	r3,33045
81112d28:	18fd5204 	addi	r3,r3,-2744
81112d2c:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
81112d30:	00a04574 	movhi	r2,33045
81112d34:	1096ef04 	addi	r2,r2,23484
81112d38:	00e04574 	movhi	r3,33045
81112d3c:	18fd5604 	addi	r3,r3,-2728
81112d40:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
81112d44:	00a04574 	movhi	r2,33045
81112d48:	1096ef04 	addi	r2,r2,23484
81112d4c:	00e04574 	movhi	r3,33045
81112d50:	18fd5a04 	addi	r3,r3,-2712
81112d54:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
81112d58:	00a04574 	movhi	r2,33045
81112d5c:	1096ef04 	addi	r2,r2,23484
81112d60:	00e04574 	movhi	r3,33045
81112d64:	18fd5e04 	addi	r3,r3,-2696
81112d68:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
81112d6c:	00a04574 	movhi	r2,33045
81112d70:	1096ef04 	addi	r2,r2,23484
81112d74:	00e04574 	movhi	r3,33045
81112d78:	18fd6204 	addi	r3,r3,-2680
81112d7c:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
81112d80:	00a04574 	movhi	r2,33045
81112d84:	1096ef04 	addi	r2,r2,23484
81112d88:	00e04574 	movhi	r3,33045
81112d8c:	18fd6604 	addi	r3,r3,-2664
81112d90:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
81112d94:	00a04574 	movhi	r2,33045
81112d98:	1096ef04 	addi	r2,r2,23484
81112d9c:	00e04574 	movhi	r3,33045
81112da0:	18fd6a04 	addi	r3,r3,-2648
81112da4:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81112da8:	00a04574 	movhi	r2,33045
81112dac:	1096ef04 	addi	r2,r2,23484
81112db0:	00e04574 	movhi	r3,33045
81112db4:	18fd6e04 	addi	r3,r3,-2632
81112db8:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
81112dbc:	00a04574 	movhi	r2,33045
81112dc0:	1096ef04 	addi	r2,r2,23484
81112dc4:	00e04574 	movhi	r3,33045
81112dc8:	18fd7204 	addi	r3,r3,-2616
81112dcc:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
81112dd0:	00a04574 	movhi	r2,33045
81112dd4:	1096ef04 	addi	r2,r2,23484
81112dd8:	00e04574 	movhi	r3,33045
81112ddc:	18fd7604 	addi	r3,r3,-2600
81112de0:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
81112de4:	00a04574 	movhi	r2,33045
81112de8:	1096ef04 	addi	r2,r2,23484
81112dec:	00e04574 	movhi	r3,33045
81112df0:	18fd7a04 	addi	r3,r3,-2584
81112df4:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
81112df8:	00a04574 	movhi	r2,33045
81112dfc:	1096ef04 	addi	r2,r2,23484
81112e00:	00e04574 	movhi	r3,33045
81112e04:	18fd7e04 	addi	r3,r3,-2568
81112e08:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
81112e0c:	00a04574 	movhi	r2,33045
81112e10:	1096ef04 	addi	r2,r2,23484
81112e14:	00e04574 	movhi	r3,33045
81112e18:	18fd8204 	addi	r3,r3,-2552
81112e1c:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81112e20:	00a04574 	movhi	r2,33045
81112e24:	1096ef04 	addi	r2,r2,23484
81112e28:	00e04574 	movhi	r3,33045
81112e2c:	18fd8604 	addi	r3,r3,-2536
81112e30:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81112e34:	00a04574 	movhi	r2,33045
81112e38:	1096ef04 	addi	r2,r2,23484
81112e3c:	00e04574 	movhi	r3,33045
81112e40:	18fd8a04 	addi	r3,r3,-2520
81112e44:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81112e48:	00a04574 	movhi	r2,33045
81112e4c:	1096ef04 	addi	r2,r2,23484
81112e50:	00e04574 	movhi	r3,33045
81112e54:	18fd8e04 	addi	r3,r3,-2504
81112e58:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
81112e5c:	00a04574 	movhi	r2,33045
81112e60:	1096ef04 	addi	r2,r2,23484
81112e64:	00e04574 	movhi	r3,33045
81112e68:	18fd9204 	addi	r3,r3,-2488
81112e6c:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81112e70:	00a04574 	movhi	r2,33045
81112e74:	1096ef04 	addi	r2,r2,23484
81112e78:	00e04574 	movhi	r3,33045
81112e7c:	18fd9604 	addi	r3,r3,-2472
81112e80:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81112e84:	00a04574 	movhi	r2,33045
81112e88:	1096ef04 	addi	r2,r2,23484
81112e8c:	00e04574 	movhi	r3,33045
81112e90:	18fd9a04 	addi	r3,r3,-2456
81112e94:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81112e98:	00a04574 	movhi	r2,33045
81112e9c:	1096ef04 	addi	r2,r2,23484
81112ea0:	00e04574 	movhi	r3,33045
81112ea4:	18fd9e04 	addi	r3,r3,-2440
81112ea8:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
81112eac:	00a04574 	movhi	r2,33045
81112eb0:	1096ef04 	addi	r2,r2,23484
81112eb4:	00e04574 	movhi	r3,33045
81112eb8:	18fda204 	addi	r3,r3,-2424
81112ebc:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
81112ec0:	00a04574 	movhi	r2,33045
81112ec4:	1096ef04 	addi	r2,r2,23484
81112ec8:	00e04574 	movhi	r3,33045
81112ecc:	18fda604 	addi	r3,r3,-2408
81112ed0:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
81112ed4:	00a04574 	movhi	r2,33045
81112ed8:	1096ef04 	addi	r2,r2,23484
81112edc:	00e04574 	movhi	r3,33045
81112ee0:	18fdaa04 	addi	r3,r3,-2392
81112ee4:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
81112ee8:	00a04574 	movhi	r2,33045
81112eec:	1096ef04 	addi	r2,r2,23484
81112ef0:	00e04574 	movhi	r3,33045
81112ef4:	18fdae04 	addi	r3,r3,-2376
81112ef8:	10c03f15 	stw	r3,252(r2)
}
81112efc:	0001883a 	nop
81112f00:	e037883a 	mov	sp,fp
81112f04:	df000017 	ldw	fp,0(sp)
81112f08:	dec00104 	addi	sp,sp,4
81112f0c:	f800283a 	ret

81112f10 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81112f10:	defff604 	addi	sp,sp,-40
81112f14:	de00012e 	bgeu	sp,et,81112f1c <vInAckHandlerTaskV2+0xc>
81112f18:	003b68fa 	trap	3
81112f1c:	dfc00915 	stw	ra,36(sp)
81112f20:	df000815 	stw	fp,32(sp)
81112f24:	df000804 	addi	fp,sp,32
81112f28:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81112f2c:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81112f30:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81112f34:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81112f38:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81112f3c:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81112f40:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81112f44:	e03ffa45 	stb	zero,-23(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81112f48:	00a045f4 	movhi	r2,33047
81112f4c:	10a34f04 	addi	r2,r2,-29380
81112f50:	10800a8b 	ldhu	r2,42(r2)
81112f54:	10bfffcc 	andi	r2,r2,65535
81112f58:	10800168 	cmpgeui	r2,r2,5
81112f5c:	1000071e 	bne	r2,zero,81112f7c <vInAckHandlerTaskV2+0x6c>
        debug(fp,"In Ack Handler Task. (Task on)\n");
81112f60:	d0a06217 	ldw	r2,-32376(gp)
81112f64:	100f883a 	mov	r7,r2
81112f68:	018007c4 	movi	r6,31
81112f6c:	01400044 	movi	r5,1
81112f70:	01204574 	movhi	r4,33045
81112f74:	213db204 	addi	r4,r4,-2360
81112f78:	1123cec0 	call	81123cec <fwrite>
    }
    #endif

	eReceiverAckState = sRAConfiguring;
81112f7c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81112f80:	e0bff917 	ldw	r2,-28(fp)
81112f84:	10c00060 	cmpeqi	r3,r2,1
81112f88:	1800071e 	bne	r3,zero,81112fa8 <vInAckHandlerTaskV2+0x98>
81112f8c:	0080032e 	bgeu	zero,r2,81112f9c <vInAckHandlerTaskV2+0x8c>
81112f90:	108000a0 	cmpeqi	r2,r2,2
81112f94:	10004a1e 	bne	r2,zero,811130c0 <vInAckHandlerTaskV2+0x1b0>
81112f98:	0000ac06 	br	8111324c <vInAckHandlerTaskV2+0x33c>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81112f9c:	00800044 	movi	r2,1
81112fa0:	e0bff915 	stw	r2,-28(fp)
				break;
81112fa4:	0000b906 	br	8111328c <vInAckHandlerTaskV2+0x37c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81112fa8:	00800044 	movi	r2,1
81112fac:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81112fb0:	d0a06617 	ldw	r2,-32360(gp)
81112fb4:	e0fffe04 	addi	r3,fp,-8
81112fb8:	180d883a 	mov	r6,r3
81112fbc:	000b883a 	mov	r5,zero
81112fc0:	1009883a 	mov	r4,r2
81112fc4:	1140b0c0 	call	81140b0c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81112fc8:	e0bffe03 	ldbu	r2,-8(fp)
81112fcc:	10803fcc 	andi	r2,r2,255
81112fd0:	1000391e 	bne	r2,zero,811130b8 <vInAckHandlerTaskV2+0x1a8>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81112fd4:	d0a06517 	ldw	r2,-32364(gp)
81112fd8:	e0fffe04 	addi	r3,fp,-8
81112fdc:	180d883a 	mov	r6,r3
81112fe0:	000b883a 	mov	r5,zero
81112fe4:	1009883a 	mov	r4,r2
81112fe8:	113eb000 	call	8113eb00 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81112fec:	e0bffe03 	ldbu	r2,-8(fp)
81112ff0:	10803fcc 	andi	r2,r2,255
81112ff4:	10002b1e 	bne	r2,zero,811130a4 <vInAckHandlerTaskV2+0x194>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81112ff8:	e03ffa45 	stb	zero,-23(fp)
81112ffc:	00002206 	br	81113088 <vInAckHandlerTaskV2+0x178>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81113000:	e0fffa43 	ldbu	r3,-23(fp)
81113004:	00a045b4 	movhi	r2,33046
81113008:	108c8d04 	addi	r2,r2,12852
8111300c:	18c7883a 	add	r3,r3,r3
81113010:	18c7883a 	add	r3,r3,r3
81113014:	10c5883a 	add	r2,r2,r3
81113018:	10800003 	ldbu	r2,0(r2)
8111301c:	10803fcc 	andi	r2,r2,255
81113020:	1080201c 	xori	r2,r2,128
81113024:	10bfe004 	addi	r2,r2,-128
81113028:	10001426 	beq	r2,zero,8111307c <vInAckHandlerTaskV2+0x16c>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8111302c:	e0fffa43 	ldbu	r3,-23(fp)
81113030:	00a045b4 	movhi	r2,33046
81113034:	108c8d04 	addi	r2,r2,12852
81113038:	18c7883a 	add	r3,r3,r3
8111303c:	18c7883a 	add	r3,r3,r3
81113040:	10c5883a 	add	r2,r2,r3
81113044:	10c0000b 	ldhu	r3,0(r2)
81113048:	d0e0568d 	sth	r3,-32422(gp)
8111304c:	1080008b 	ldhu	r2,2(r2)
81113050:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81113054:	e0fffa43 	ldbu	r3,-23(fp)
81113058:	00a045b4 	movhi	r2,33046
8111305c:	108c8d04 	addi	r2,r2,12852
81113060:	18c7883a 	add	r3,r3,r3
81113064:	18c7883a 	add	r3,r3,r3
81113068:	10c5883a 	add	r2,r2,r3
8111306c:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81113070:	00800084 	movi	r2,2
81113074:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81113078:	00000606 	br	81113094 <vInAckHandlerTaskV2+0x184>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8111307c:	e0bffa43 	ldbu	r2,-23(fp)
81113080:	10800044 	addi	r2,r2,1
81113084:	e0bffa45 	stb	r2,-23(fp)
81113088:	e0bffa43 	ldbu	r2,-23(fp)
8111308c:	108001b0 	cmpltui	r2,r2,6
81113090:	103fdb1e 	bne	r2,zero,81113000 <__reset+0xfb0f3000>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81113094:	d0a06517 	ldw	r2,-32364(gp)
81113098:	1009883a 	mov	r4,r2
8111309c:	113f0a40 	call	8113f0a4 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811130a0:	00007a06 	br	8111328c <vInAckHandlerTaskV2+0x37c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
811130a4:	d0a06617 	ldw	r2,-32360(gp)
811130a8:	1009883a 	mov	r4,r2
811130ac:	1140e940 	call	81140e94 <OSSemPost>
                    	vFailGetMutexReceiverTask();
811130b0:	111d6a00 	call	8111d6a0 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811130b4:	00007506 	br	8111328c <vInAckHandlerTaskV2+0x37c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
811130b8:	111d6200 	call	8111d620 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
811130bc:	00007306 	br	8111328c <vInAckHandlerTaskV2+0x37c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
811130c0:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
811130c4:	d0a06883 	ldbu	r2,-32350(gp)
811130c8:	10803fcc 	andi	r2,r2,255
811130cc:	10800218 	cmpnei	r2,r2,8
811130d0:	1000021e 	bne	r2,zero,811130dc <vInAckHandlerTaskV2+0x1cc>
811130d4:	00c00104 	movi	r3,4
811130d8:	00000106 	br	811130e0 <vInAckHandlerTaskV2+0x1d0>
811130dc:	0007883a 	mov	r3,zero
811130e0:	d0a07503 	ldbu	r2,-32300(gp)
811130e4:	10803fcc 	andi	r2,r2,255
811130e8:	10800218 	cmpnei	r2,r2,8
811130ec:	1000021e 	bne	r2,zero,811130f8 <vInAckHandlerTaskV2+0x1e8>
811130f0:	00800084 	movi	r2,2
811130f4:	00000106 	br	811130fc <vInAckHandlerTaskV2+0x1ec>
811130f8:	0005883a 	mov	r2,zero
811130fc:	1884b03a 	or	r2,r3,r2
81113100:	1007883a 	mov	r3,r2
81113104:	d0a07543 	ldbu	r2,-32299(gp)
81113108:	10803fcc 	andi	r2,r2,255
8111310c:	108001a0 	cmpeqi	r2,r2,6
81113110:	1884b03a 	or	r2,r3,r2
81113114:	1007883a 	mov	r3,r2
81113118:	e0bffa83 	ldbu	r2,-22(fp)
8111311c:	1884b03a 	or	r2,r3,r2
81113120:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81113124:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81113128:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8111312c:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81113130:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81113134:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81113138:	e0bffa03 	ldbu	r2,-24(fp)
8111313c:	10800044 	addi	r2,r2,1
81113140:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81113144:	e0bffa83 	ldbu	r2,-22(fp)
81113148:	1080004c 	andi	r2,r2,1
8111314c:	10803fcc 	andi	r2,r2,255
81113150:	1000061e 	bne	r2,zero,8111316c <vInAckHandlerTaskV2+0x25c>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81113154:	e0bffd04 	addi	r2,fp,-12
81113158:	100b883a 	mov	r5,r2
8111315c:	d1205684 	addi	r4,gp,-32422
81113160:	11132900 	call	81113290 <bCheckInAck128>
81113164:	e0bff815 	stw	r2,-32(fp)
81113168:	00000206 	br	81113174 <vInAckHandlerTaskV2+0x264>
                    else
                        bFinished128 = TRUE;
8111316c:	00800044 	movi	r2,1
81113170:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81113174:	e0bffa83 	ldbu	r2,-22(fp)
81113178:	1080008c 	andi	r2,r2,2
8111317c:	10803fcc 	andi	r2,r2,255
81113180:	1000081e 	bne	r2,zero,811131a4 <vInAckHandlerTaskV2+0x294>
81113184:	e0bff817 	ldw	r2,-32(fp)
81113188:	1000061e 	bne	r2,zero,811131a4 <vInAckHandlerTaskV2+0x294>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8111318c:	e0bffc04 	addi	r2,fp,-16
81113190:	100b883a 	mov	r5,r2
81113194:	d1205684 	addi	r4,gp,-32422
81113198:	11133d80 	call	811133d8 <bCheckInAck64>
8111319c:	e0bff815 	stw	r2,-32(fp)
811131a0:	00000206 	br	811131ac <vInAckHandlerTaskV2+0x29c>
                    else
                        bFinished64 = TRUE;
811131a4:	00800044 	movi	r2,1
811131a8:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
811131ac:	e0bffa83 	ldbu	r2,-22(fp)
811131b0:	1080010c 	andi	r2,r2,4
811131b4:	10803fcc 	andi	r2,r2,255
811131b8:	1000081e 	bne	r2,zero,811131dc <vInAckHandlerTaskV2+0x2cc>
811131bc:	e0bff817 	ldw	r2,-32(fp)
811131c0:	1000061e 	bne	r2,zero,811131dc <vInAckHandlerTaskV2+0x2cc>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
811131c4:	e0bffb04 	addi	r2,fp,-20
811131c8:	100b883a 	mov	r5,r2
811131cc:	d1205684 	addi	r4,gp,-32422
811131d0:	11135240 	call	81113524 <bCheckInAck32>
811131d4:	e0bff815 	stw	r2,-32(fp)
811131d8:	00000206 	br	811131e4 <vInAckHandlerTaskV2+0x2d4>
                    else
                        bFinished32 = TRUE;
811131dc:	00800044 	movi	r2,1
811131e0:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
811131e4:	e0bffa03 	ldbu	r2,-24(fp)
811131e8:	10c00044 	addi	r3,r2,1
811131ec:	e0fffa05 	stb	r3,-24(fp)
811131f0:	10803fcc 	andi	r2,r2,255
811131f4:	10800ca8 	cmpgeui	r2,r2,50
811131f8:	10000e1e 	bne	r2,zero,81113234 <vInAckHandlerTaskV2+0x324>
811131fc:	e0bff817 	ldw	r2,-32(fp)
81113200:	10000c1e 	bne	r2,zero,81113234 <vInAckHandlerTaskV2+0x324>
81113204:	e0bffb17 	ldw	r2,-20(fp)
81113208:	1005003a 	cmpeq	r2,r2,zero
8111320c:	1007883a 	mov	r3,r2
81113210:	e0bffc17 	ldw	r2,-16(fp)
81113214:	1005003a 	cmpeq	r2,r2,zero
81113218:	1884b03a 	or	r2,r3,r2
8111321c:	10c03fcc 	andi	r3,r2,255
81113220:	e0bffd17 	ldw	r2,-12(fp)
81113224:	1005003a 	cmpeq	r2,r2,zero
81113228:	10803fcc 	andi	r2,r2,255
8111322c:	1884b03a 	or	r2,r3,r2
81113230:	103fc11e 	bne	r2,zero,81113138 <__reset+0xfb0f3138>
                
                if (bFound == FALSE) {
81113234:	e0bff817 	ldw	r2,-32(fp)
81113238:	1000011e 	bne	r2,zero,81113240 <vInAckHandlerTaskV2+0x330>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8111323c:	111dc940 	call	8111dc94 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81113240:	00800044 	movi	r2,1
81113244:	e0bff915 	stw	r2,-28(fp)
				break;
81113248:	00001006 	br	8111328c <vInAckHandlerTaskV2+0x37c>
			default:
                #if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly) {
8111324c:	00a045f4 	movhi	r2,33047
81113250:	10a34f04 	addi	r2,r2,-29380
81113254:	10800a8b 	ldhu	r2,42(r2)
81113258:	10bfffcc 	andi	r2,r2,65535
8111325c:	10800228 	cmpgeui	r2,r2,8
81113260:	1000071e 	bne	r2,zero,81113280 <vInAckHandlerTaskV2+0x370>
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81113264:	d0a06217 	ldw	r2,-32376(gp)
81113268:	100f883a 	mov	r7,r2
8111326c:	01801144 	movi	r6,69
81113270:	01400044 	movi	r5,1
81113274:	01204574 	movhi	r4,33045
81113278:	213dba04 	addi	r4,r4,-2328
8111327c:	1123cec0 	call	81123cec <fwrite>
				}
	            #endif
                eReceiverAckState = sRAGettingACK;
81113280:	00800044 	movi	r2,1
81113284:	e0bff915 	stw	r2,-28(fp)
				break;
81113288:	0001883a 	nop
		}
	}
8111328c:	003f3c06 	br	81112f80 <__reset+0xfb0f2f80>

81113290 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81113290:	defffa04 	addi	sp,sp,-24
81113294:	de00012e 	bgeu	sp,et,8111329c <bCheckInAck128+0xc>
81113298:	003b68fa 	trap	3
8111329c:	dfc00515 	stw	ra,20(sp)
811132a0:	df000415 	stw	fp,16(sp)
811132a4:	df000404 	addi	fp,sp,16
811132a8:	e13ffe15 	stw	r4,-8(fp)
811132ac:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811132b0:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811132b4:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811132b8:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811132bc:	e0bfff17 	ldw	r2,-4(fp)
811132c0:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
811132c4:	d0a06e17 	ldw	r2,-32328(gp)
811132c8:	e0fffd44 	addi	r3,fp,-11
811132cc:	180d883a 	mov	r6,r3
811132d0:	01400144 	movi	r5,5
811132d4:	1009883a 	mov	r4,r2
811132d8:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811132dc:	e0bffd43 	ldbu	r2,-11(fp)
811132e0:	10803fcc 	andi	r2,r2,255
811132e4:	10000226 	beq	r2,zero,811132f0 <bCheckInAck128+0x60>
        return bFound;
811132e8:	e0bffc17 	ldw	r2,-16(fp)
811132ec:	00003506 	br	811133c4 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
811132f0:	e03ffd05 	stb	zero,-12(fp)
811132f4:	00002706 	br	81113394 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
811132f8:	e0fffd03 	ldbu	r3,-12(fp)
811132fc:	00a045b4 	movhi	r2,33046
81113300:	10838b04 	addi	r2,r2,3628
81113304:	18c02324 	muli	r3,r3,140
81113308:	10c5883a 	add	r2,r2,r3
8111330c:	10802104 	addi	r2,r2,132
81113310:	10c0000b 	ldhu	r3,0(r2)
81113314:	e0bffe17 	ldw	r2,-8(fp)
81113318:	1080008b 	ldhu	r2,2(r2)
8111331c:	18ffffcc 	andi	r3,r3,65535
81113320:	10bfffcc 	andi	r2,r2,65535
81113324:	1880181e 	bne	r3,r2,81113388 <bCheckInAck128+0xf8>
            bFound = TRUE;
81113328:	00800044 	movi	r2,1
8111332c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81113330:	e0fffd03 	ldbu	r3,-12(fp)
81113334:	00a045b4 	movhi	r2,33046
81113338:	10836d04 	addi	r2,r2,3508
8111333c:	18c7883a 	add	r3,r3,r3
81113340:	18c7883a 	add	r3,r3,r3
81113344:	10c5883a 	add	r2,r2,r3
81113348:	10000015 	stw	zero,0(r2)
            SemCount128++;
8111334c:	d0a07543 	ldbu	r2,-32299(gp)
81113350:	10800044 	addi	r2,r2,1
81113354:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81113358:	d0a06317 	ldw	r2,-32372(gp)
8111335c:	1009883a 	mov	r4,r2
81113360:	1140e940 	call	81140e94 <OSSemPost>
81113364:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81113368:	e0bffd43 	ldbu	r2,-11(fp)
8111336c:	10803fcc 	andi	r2,r2,255
81113370:	10000c26 	beq	r2,zero,811133a4 <bCheckInAck128+0x114>
                SemCount128--;
81113374:	d0a07543 	ldbu	r2,-32299(gp)
81113378:	10bfffc4 	addi	r2,r2,-1
8111337c:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81113380:	111da940 	call	8111da94 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81113384:	00000706 	br	811133a4 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81113388:	e0bffd03 	ldbu	r2,-12(fp)
8111338c:	10800044 	addi	r2,r2,1
81113390:	e0bffd05 	stb	r2,-12(fp)
81113394:	e0bffd03 	ldbu	r2,-12(fp)
81113398:	108001b0 	cmpltui	r2,r2,6
8111339c:	103fd61e 	bne	r2,zero,811132f8 <__reset+0xfb0f32f8>
811133a0:	00000106 	br	811133a8 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
811133a4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811133a8:	d0a06e17 	ldw	r2,-32328(gp)
811133ac:	1009883a 	mov	r4,r2
811133b0:	113f0a40 	call	8113f0a4 <OSMutexPost>
    (*bFinished) = TRUE;
811133b4:	e0bfff17 	ldw	r2,-4(fp)
811133b8:	00c00044 	movi	r3,1
811133bc:	10c00015 	stw	r3,0(r2)

    return bFound;
811133c0:	e0bffc17 	ldw	r2,-16(fp)
}
811133c4:	e037883a 	mov	sp,fp
811133c8:	dfc00117 	ldw	ra,4(sp)
811133cc:	df000017 	ldw	fp,0(sp)
811133d0:	dec00204 	addi	sp,sp,8
811133d4:	f800283a 	ret

811133d8 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
811133d8:	defffa04 	addi	sp,sp,-24
811133dc:	de00012e 	bgeu	sp,et,811133e4 <bCheckInAck64+0xc>
811133e0:	003b68fa 	trap	3
811133e4:	dfc00515 	stw	ra,20(sp)
811133e8:	df000415 	stw	fp,16(sp)
811133ec:	df000404 	addi	fp,sp,16
811133f0:	e13ffe15 	stw	r4,-8(fp)
811133f4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811133f8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811133fc:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81113400:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81113404:	e0bfff17 	ldw	r2,-4(fp)
81113408:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8111340c:	d0a07117 	ldw	r2,-32316(gp)
81113410:	e0fffd44 	addi	r3,fp,-11
81113414:	180d883a 	mov	r6,r3
81113418:	01400044 	movi	r5,1
8111341c:	1009883a 	mov	r4,r2
81113420:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81113424:	e0bffd43 	ldbu	r2,-11(fp)
81113428:	10803fcc 	andi	r2,r2,255
8111342c:	10000226 	beq	r2,zero,81113438 <bCheckInAck64+0x60>
        return bFound;
81113430:	e0bffc17 	ldw	r2,-16(fp)
81113434:	00003606 	br	81113510 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81113438:	e03ffd05 	stb	zero,-12(fp)
8111343c:	00002806 	br	811134e0 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
81113440:	e0fffd03 	ldbu	r3,-12(fp)
81113444:	00a04574 	movhi	r2,33045
81113448:	109f2f04 	addi	r2,r2,31932
8111344c:	18c01324 	muli	r3,r3,76
81113450:	10c5883a 	add	r2,r2,r3
81113454:	10801104 	addi	r2,r2,68
81113458:	10c0000b 	ldhu	r3,0(r2)
8111345c:	e0bffe17 	ldw	r2,-8(fp)
81113460:	1080008b 	ldhu	r2,2(r2)
81113464:	18ffffcc 	andi	r3,r3,65535
81113468:	10bfffcc 	andi	r2,r2,65535
8111346c:	1880191e 	bne	r3,r2,811134d4 <bCheckInAck64+0xfc>
            bFound = TRUE;
81113470:	00800044 	movi	r2,1
81113474:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
81113478:	e0fffd03 	ldbu	r3,-12(fp)
8111347c:	00a045b4 	movhi	r2,33046
81113480:	10836d04 	addi	r2,r2,3508
81113484:	18c00184 	addi	r3,r3,6
81113488:	18c7883a 	add	r3,r3,r3
8111348c:	18c7883a 	add	r3,r3,r3
81113490:	10c5883a 	add	r2,r2,r3
81113494:	10000015 	stw	zero,0(r2)
            SemCount64++;
81113498:	d0a07503 	ldbu	r2,-32300(gp)
8111349c:	10800044 	addi	r2,r2,1
811134a0:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
811134a4:	d0a05e17 	ldw	r2,-32392(gp)
811134a8:	1009883a 	mov	r4,r2
811134ac:	1140e940 	call	81140e94 <OSSemPost>
811134b0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811134b4:	e0bffd43 	ldbu	r2,-11(fp)
811134b8:	10803fcc 	andi	r2,r2,255
811134bc:	10000c26 	beq	r2,zero,811134f0 <bCheckInAck64+0x118>
                SemCount64--;
811134c0:	d0a07503 	ldbu	r2,-32300(gp)
811134c4:	10bfffc4 	addi	r2,r2,-1
811134c8:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
811134cc:	111da140 	call	8111da14 <vFailSetCountSemaphorexBuffer64>
            }
            break;
811134d0:	00000706 	br	811134f0 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811134d4:	e0bffd03 	ldbu	r2,-12(fp)
811134d8:	10800044 	addi	r2,r2,1
811134dc:	e0bffd05 	stb	r2,-12(fp)
811134e0:	e0bffd03 	ldbu	r2,-12(fp)
811134e4:	10800230 	cmpltui	r2,r2,8
811134e8:	103fd51e 	bne	r2,zero,81113440 <__reset+0xfb0f3440>
811134ec:	00000106 	br	811134f4 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
811134f0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
811134f4:	d0a07117 	ldw	r2,-32316(gp)
811134f8:	1009883a 	mov	r4,r2
811134fc:	113f0a40 	call	8113f0a4 <OSMutexPost>
    (*bFinished) = TRUE;
81113500:	e0bfff17 	ldw	r2,-4(fp)
81113504:	00c00044 	movi	r3,1
81113508:	10c00015 	stw	r3,0(r2)

    return bFound;
8111350c:	e0bffc17 	ldw	r2,-16(fp)
}
81113510:	e037883a 	mov	sp,fp
81113514:	dfc00117 	ldw	ra,4(sp)
81113518:	df000017 	ldw	fp,0(sp)
8111351c:	dec00204 	addi	sp,sp,8
81113520:	f800283a 	ret

81113524 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81113524:	defffa04 	addi	sp,sp,-24
81113528:	de00012e 	bgeu	sp,et,81113530 <bCheckInAck32+0xc>
8111352c:	003b68fa 	trap	3
81113530:	dfc00515 	stw	ra,20(sp)
81113534:	df000415 	stw	fp,16(sp)
81113538:	df000404 	addi	fp,sp,16
8111353c:	e13ffe15 	stw	r4,-8(fp)
81113540:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81113544:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81113548:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8111354c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81113550:	e0bfff17 	ldw	r2,-4(fp)
81113554:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81113558:	d0a06c17 	ldw	r2,-32336(gp)
8111355c:	e0fffd44 	addi	r3,fp,-11
81113560:	180d883a 	mov	r6,r3
81113564:	01400044 	movi	r5,1
81113568:	1009883a 	mov	r4,r2
8111356c:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81113570:	e0bffd43 	ldbu	r2,-11(fp)
81113574:	10803fcc 	andi	r2,r2,255
81113578:	10000226 	beq	r2,zero,81113584 <bCheckInAck32+0x60>
        return bFound;
8111357c:	e0bffc17 	ldw	r2,-16(fp)
81113580:	00003606 	br	8111365c <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81113584:	e03ffd05 	stb	zero,-12(fp)
81113588:	00002806 	br	8111362c <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8111358c:	e0fffd03 	ldbu	r3,-12(fp)
81113590:	00a045b4 	movhi	r2,33046
81113594:	10b0ed04 	addi	r2,r2,-15436
81113598:	18c00b24 	muli	r3,r3,44
8111359c:	10c5883a 	add	r2,r2,r3
811135a0:	10800904 	addi	r2,r2,36
811135a4:	10c0000b 	ldhu	r3,0(r2)
811135a8:	e0bffe17 	ldw	r2,-8(fp)
811135ac:	1080008b 	ldhu	r2,2(r2)
811135b0:	18ffffcc 	andi	r3,r3,65535
811135b4:	10bfffcc 	andi	r2,r2,65535
811135b8:	1880191e 	bne	r3,r2,81113620 <bCheckInAck32+0xfc>
            bFound = TRUE;
811135bc:	00800044 	movi	r2,1
811135c0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
811135c4:	e0fffd03 	ldbu	r3,-12(fp)
811135c8:	00a045b4 	movhi	r2,33046
811135cc:	10836d04 	addi	r2,r2,3508
811135d0:	18c00384 	addi	r3,r3,14
811135d4:	18c7883a 	add	r3,r3,r3
811135d8:	18c7883a 	add	r3,r3,r3
811135dc:	10c5883a 	add	r2,r2,r3
811135e0:	10000015 	stw	zero,0(r2)
            SemCount32++;
811135e4:	d0a06883 	ldbu	r2,-32350(gp)
811135e8:	10800044 	addi	r2,r2,1
811135ec:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
811135f0:	d0a06f17 	ldw	r2,-32324(gp)
811135f4:	1009883a 	mov	r4,r2
811135f8:	1140e940 	call	81140e94 <OSSemPost>
811135fc:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81113600:	e0bffd43 	ldbu	r2,-11(fp)
81113604:	10803fcc 	andi	r2,r2,255
81113608:	10000c26 	beq	r2,zero,8111363c <bCheckInAck32+0x118>
                SemCount32--;
8111360c:	d0a06883 	ldbu	r2,-32350(gp)
81113610:	10bfffc4 	addi	r2,r2,-1
81113614:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
81113618:	111d9940 	call	8111d994 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8111361c:	00000706 	br	8111363c <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81113620:	e0bffd03 	ldbu	r2,-12(fp)
81113624:	10800044 	addi	r2,r2,1
81113628:	e0bffd05 	stb	r2,-12(fp)
8111362c:	e0bffd03 	ldbu	r2,-12(fp)
81113630:	10800230 	cmpltui	r2,r2,8
81113634:	103fd51e 	bne	r2,zero,8111358c <__reset+0xfb0f358c>
81113638:	00000106 	br	81113640 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8111363c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
81113640:	d0a06c17 	ldw	r2,-32336(gp)
81113644:	1009883a 	mov	r4,r2
81113648:	113f0a40 	call	8113f0a4 <OSMutexPost>
    (*bFinished) = TRUE;
8111364c:	e0bfff17 	ldw	r2,-4(fp)
81113650:	00c00044 	movi	r3,1
81113654:	10c00015 	stw	r3,0(r2)

    return bFound;
81113658:	e0bffc17 	ldw	r2,-16(fp)
}
8111365c:	e037883a 	mov	sp,fp
81113660:	dfc00117 	ldw	ra,4(sp)
81113664:	df000017 	ldw	fp,0(sp)
81113668:	dec00204 	addi	sp,sp,8
8111366c:	f800283a 	ret

81113670 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81113670:	defff704 	addi	sp,sp,-36
81113674:	de00012e 	bgeu	sp,et,8111367c <vInitialTask+0xc>
81113678:	003b68fa 	trap	3
8111367c:	dfc00815 	stw	ra,32(sp)
81113680:	df000715 	stw	fp,28(sp)
81113684:	df000704 	addi	fp,sp,28
81113688:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8111368c:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81113690:	d8000415 	stw	zero,16(sp)
81113694:	d8000315 	stw	zero,12(sp)
81113698:	00810004 	movi	r2,1024
8111369c:	d8800215 	stw	r2,8(sp)
811136a0:	00a04574 	movhi	r2,33045
811136a4:	10972f04 	addi	r2,r2,23740
811136a8:	d8800115 	stw	r2,4(sp)
811136ac:	008002c4 	movi	r2,11
811136b0:	d8800015 	stw	r2,0(sp)
811136b4:	01c002c4 	movi	r7,11
811136b8:	01a04574 	movhi	r6,33045
811136bc:	319b2e04 	addi	r6,r6,27832
811136c0:	016045b4 	movhi	r5,33046
811136c4:	296c4f04 	addi	r5,r5,-20164
811136c8:	01204474 	movhi	r4,33041
811136cc:	21397e04 	addi	r4,r4,-6664
811136d0:	11418780 	call	81141878 <OSTaskCreateExt>
811136d4:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811136d8:	e0bffe03 	ldbu	r2,-8(fp)
811136dc:	10803fcc 	andi	r2,r2,255
811136e0:	10000b26 	beq	r2,zero,81113710 <vInitialTask+0xa0>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811136e4:	00a045f4 	movhi	r2,33047
811136e8:	10a34f04 	addi	r2,r2,-29380
811136ec:	10800a8b 	ldhu	r2,42(r2)
811136f0:	10bfffcc 	andi	r2,r2,65535
811136f4:	10800228 	cmpgeui	r2,r2,8
811136f8:	1000041e 	bne	r2,zero,8111370c <vInitialTask+0x9c>
			printErrorTask( error_code );
811136fc:	e0bffe03 	ldbu	r2,-8(fp)
81113700:	10803fcc 	andi	r2,r2,255
81113704:	1009883a 	mov	r4,r2
81113708:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFee0Task();
8111370c:	111eb1c0 	call	8111eb1c <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81113710:	01c17704 	movi	r7,1500
81113714:	000d883a 	mov	r6,zero
81113718:	000b883a 	mov	r5,zero
8111371c:	0009883a 	mov	r4,zero
81113720:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81113724:	d8000415 	stw	zero,16(sp)
81113728:	d8000315 	stw	zero,12(sp)
8111372c:	00810004 	movi	r2,1024
81113730:	d8800215 	stw	r2,8(sp)
81113734:	00a045b4 	movhi	r2,33046
81113738:	10a83d04 	addi	r2,r2,-24332
8111373c:	d8800115 	stw	r2,4(sp)
81113740:	00800284 	movi	r2,10
81113744:	d8800015 	stw	r2,0(sp)
81113748:	01c00284 	movi	r7,10
8111374c:	01a045b4 	movhi	r6,33046
81113750:	31ac3c04 	addi	r6,r6,-20240
81113754:	016045b4 	movhi	r5,33046
81113758:	296c4704 	addi	r5,r5,-20196
8111375c:	01204474 	movhi	r4,33041
81113760:	21395004 	addi	r4,r4,-6848
81113764:	11418780 	call	81141878 <OSTaskCreateExt>
81113768:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8111376c:	e0bffe03 	ldbu	r2,-8(fp)
81113770:	10803fcc 	andi	r2,r2,255
81113774:	10000b26 	beq	r2,zero,811137a4 <vInitialTask+0x134>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113778:	00a045f4 	movhi	r2,33047
8111377c:	10a34f04 	addi	r2,r2,-29380
81113780:	10800a8b 	ldhu	r2,42(r2)
81113784:	10bfffcc 	andi	r2,r2,65535
81113788:	10800228 	cmpgeui	r2,r2,8
8111378c:	1000041e 	bne	r2,zero,811137a0 <vInitialTask+0x130>
			printErrorTask( error_code );
81113790:	e0bffe03 	ldbu	r2,-8(fp)
81113794:	10803fcc 	andi	r2,r2,255
81113798:	1009883a 	mov	r4,r2
8111379c:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
			vCoudlNotCreateDataControllerTask();
811137a0:	111ee9c0 	call	8111ee9c <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811137a4:	01c17704 	movi	r7,1500
811137a8:	000d883a 	mov	r6,zero
811137ac:	000b883a 	mov	r5,zero
811137b0:	0009883a 	mov	r4,zero
811137b4:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
811137b8:	d8000415 	stw	zero,16(sp)
811137bc:	d8000315 	stw	zero,12(sp)
811137c0:	00810004 	movi	r2,1024
811137c4:	d8800215 	stw	r2,8(sp)
811137c8:	00a045b4 	movhi	r2,33046
811137cc:	10847504 	addi	r2,r2,4564
811137d0:	d8800115 	stw	r2,4(sp)
811137d4:	00800244 	movi	r2,9
811137d8:	d8800015 	stw	r2,0(sp)
811137dc:	01c00244 	movi	r7,9
811137e0:	01a045b4 	movhi	r6,33046
811137e4:	31887404 	addi	r6,r6,8656
811137e8:	016045b4 	movhi	r5,33046
811137ec:	296c4f04 	addi	r5,r5,-20164
811137f0:	01204474 	movhi	r4,33041
811137f4:	210f3f04 	addi	r4,r4,15612
811137f8:	11418780 	call	81141878 <OSTaskCreateExt>
811137fc:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113800:	e0bffe03 	ldbu	r2,-8(fp)
81113804:	10803fcc 	andi	r2,r2,255
81113808:	10000b26 	beq	r2,zero,81113838 <vInitialTask+0x1c8>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111380c:	00a045f4 	movhi	r2,33047
81113810:	10a34f04 	addi	r2,r2,-29380
81113814:	10800a8b 	ldhu	r2,42(r2)
81113818:	10bfffcc 	andi	r2,r2,65535
8111381c:	10800228 	cmpgeui	r2,r2,8
81113820:	1000041e 	bne	r2,zero,81113834 <vInitialTask+0x1c4>
			printErrorTask( error_code );
81113824:	e0bffe03 	ldbu	r2,-8(fp)
81113828:	10803fcc 	andi	r2,r2,255
8111382c:	1009883a 	mov	r4,r2
81113830:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFeeControllerTask();
81113834:	111ee1c0 	call	8111ee1c <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81113838:	01c17704 	movi	r7,1500
8111383c:	000d883a 	mov	r6,zero
81113840:	000b883a 	mov	r5,zero
81113844:	0009883a 	mov	r4,zero
81113848:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8111384c:	d8000415 	stw	zero,16(sp)
81113850:	d8000315 	stw	zero,12(sp)
81113854:	00810004 	movi	r2,1024
81113858:	d8800215 	stw	r2,8(sp)
8111385c:	00a045b4 	movhi	r2,33046
81113860:	10969704 	addi	r2,r2,23132
81113864:	d8800115 	stw	r2,4(sp)
81113868:	00800204 	movi	r2,8
8111386c:	d8800015 	stw	r2,0(sp)
81113870:	01c00204 	movi	r7,8
81113874:	01a045b4 	movhi	r6,33046
81113878:	319a9604 	addi	r6,r6,27224
8111387c:	016045b4 	movhi	r5,33046
81113880:	296c3d04 	addi	r5,r5,-20236
81113884:	01204474 	movhi	r4,33041
81113888:	2119cb04 	addi	r4,r4,26412
8111388c:	11418780 	call	81141878 <OSTaskCreateExt>
81113890:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113894:	e0bffe03 	ldbu	r2,-8(fp)
81113898:	10803fcc 	andi	r2,r2,255
8111389c:	10000b26 	beq	r2,zero,811138cc <vInitialTask+0x25c>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811138a0:	00a045f4 	movhi	r2,33047
811138a4:	10a34f04 	addi	r2,r2,-29380
811138a8:	10800a8b 	ldhu	r2,42(r2)
811138ac:	10bfffcc 	andi	r2,r2,65535
811138b0:	10800228 	cmpgeui	r2,r2,8
811138b4:	1000041e 	bne	r2,zero,811138c8 <vInitialTask+0x258>
			printErrorTask( error_code );
811138b8:	e0bffe03 	ldbu	r2,-8(fp)
811138bc:	10803fcc 	andi	r2,r2,255
811138c0:	1009883a 	mov	r4,r2
811138c4:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
			vCoudlNotCreateMebTask();
811138c8:	111ef1c0 	call	8111ef1c <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811138cc:	01c17704 	movi	r7,1500
811138d0:	000d883a 	mov	r6,zero
811138d4:	000b883a 	mov	r5,zero
811138d8:	0009883a 	mov	r4,zero
811138dc:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
811138e0:	d8000415 	stw	zero,16(sp)
811138e4:	d8000315 	stw	zero,12(sp)
811138e8:	00810004 	movi	r2,1024
811138ec:	d8800215 	stw	r2,8(sp)
811138f0:	00a045b4 	movhi	r2,33046
811138f4:	10a43d04 	addi	r2,r2,-28428
811138f8:	d8800115 	stw	r2,4(sp)
811138fc:	00800784 	movi	r2,30
81113900:	d8800015 	stw	r2,0(sp)
81113904:	01c00784 	movi	r7,30
81113908:	01a045b4 	movhi	r6,33046
8111390c:	31a83c04 	addi	r6,r6,-24336
81113910:	000b883a 	mov	r5,zero
81113914:	012044b4 	movhi	r4,33042
81113918:	21214e04 	addi	r4,r4,-31432
8111391c:	11418780 	call	81141878 <OSTaskCreateExt>
81113920:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113924:	e0bffe03 	ldbu	r2,-8(fp)
81113928:	10803fcc 	andi	r2,r2,255
8111392c:	10000b26 	beq	r2,zero,8111395c <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113930:	00a045f4 	movhi	r2,33047
81113934:	10a34f04 	addi	r2,r2,-29380
81113938:	10800a8b 	ldhu	r2,42(r2)
8111393c:	10bfffcc 	andi	r2,r2,65535
81113940:	10800228 	cmpgeui	r2,r2,8
81113944:	1000041e 	bne	r2,zero,81113958 <vInitialTask+0x2e8>
			printErrorTask( error_code );
81113948:	e0bffe03 	ldbu	r2,-8(fp)
8111394c:	10803fcc 	andi	r2,r2,255
81113950:	1009883a 	mov	r4,r2
81113954:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailTimeoutCheckerTaskCreate();
81113958:	111e3080 	call	8111e308 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8111395c:	01c03204 	movi	r7,200
81113960:	000d883a 	mov	r6,zero
81113964:	000b883a 	mov	r5,zero
81113968:	0009883a 	mov	r4,zero
8111396c:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81113970:	d8000415 	stw	zero,16(sp)
81113974:	d8000315 	stw	zero,12(sp)
81113978:	00810004 	movi	r2,1024
8111397c:	d8800215 	stw	r2,8(sp)
81113980:	00a045b4 	movhi	r2,33046
81113984:	10b75504 	addi	r2,r2,-8876
81113988:	d8800115 	stw	r2,4(sp)
8111398c:	008006c4 	movi	r2,27
81113990:	d8800015 	stw	r2,0(sp)
81113994:	01c006c4 	movi	r7,27
81113998:	01a045b4 	movhi	r6,33046
8111399c:	31bb5404 	addi	r6,r6,-4784
811139a0:	000b883a 	mov	r5,zero
811139a4:	01204474 	movhi	r4,33041
811139a8:	21115204 	addi	r4,r4,17736
811139ac:	11418780 	call	81141878 <OSTaskCreateExt>
811139b0:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811139b4:	e0bffe03 	ldbu	r2,-8(fp)
811139b8:	10803fcc 	andi	r2,r2,255
811139bc:	10000b26 	beq	r2,zero,811139ec <vInitialTask+0x37c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811139c0:	00a045f4 	movhi	r2,33047
811139c4:	10a34f04 	addi	r2,r2,-29380
811139c8:	10800a8b 	ldhu	r2,42(r2)
811139cc:	10bfffcc 	andi	r2,r2,65535
811139d0:	10800228 	cmpgeui	r2,r2,8
811139d4:	1000041e 	bne	r2,zero,811139e8 <vInitialTask+0x378>
			printErrorTask( error_code );
811139d8:	e0bffe03 	ldbu	r2,-8(fp)
811139dc:	10803fcc 	andi	r2,r2,255
811139e0:	1009883a 	mov	r4,r2
811139e4:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailOutAckHandlerTaskCreate();
811139e8:	111e1dc0 	call	8111e1dc <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811139ec:	01c03204 	movi	r7,200
811139f0:	000d883a 	mov	r6,zero
811139f4:	000b883a 	mov	r5,zero
811139f8:	0009883a 	mov	r4,zero
811139fc:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81113a00:	d8000415 	stw	zero,16(sp)
81113a04:	d8000315 	stw	zero,12(sp)
81113a08:	00810004 	movi	r2,1024
81113a0c:	d8800215 	stw	r2,8(sp)
81113a10:	00a04574 	movhi	r2,33045
81113a14:	109b2f04 	addi	r2,r2,27836
81113a18:	d8800115 	stw	r2,4(sp)
81113a1c:	00800644 	movi	r2,25
81113a20:	d8800015 	stw	r2,0(sp)
81113a24:	01c00644 	movi	r7,25
81113a28:	01a04574 	movhi	r6,33045
81113a2c:	319f2e04 	addi	r6,r6,31928
81113a30:	000b883a 	mov	r5,zero
81113a34:	01204474 	movhi	r4,33041
81113a38:	210bc404 	addi	r4,r4,12048
81113a3c:	11418780 	call	81141878 <OSTaskCreateExt>
81113a40:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113a44:	e0bffe03 	ldbu	r2,-8(fp)
81113a48:	10803fcc 	andi	r2,r2,255
81113a4c:	10000b26 	beq	r2,zero,81113a7c <vInitialTask+0x40c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113a50:	00a045f4 	movhi	r2,33047
81113a54:	10a34f04 	addi	r2,r2,-29380
81113a58:	10800a8b 	ldhu	r2,42(r2)
81113a5c:	10bfffcc 	andi	r2,r2,65535
81113a60:	10800228 	cmpgeui	r2,r2,8
81113a64:	1000041e 	bne	r2,zero,81113a78 <vInitialTask+0x408>
			printErrorTask( error_code );
81113a68:	e0bffe03 	ldbu	r2,-8(fp)
81113a6c:	10803fcc 	andi	r2,r2,255
81113a70:	1009883a 	mov	r4,r2
81113a74:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailInAckHandlerTaskCreate();
81113a78:	111e1780 	call	8111e178 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81113a7c:	01c03204 	movi	r7,200
81113a80:	000d883a 	mov	r6,zero
81113a84:	000b883a 	mov	r5,zero
81113a88:	0009883a 	mov	r4,zero
81113a8c:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81113a90:	d8000415 	stw	zero,16(sp)
81113a94:	d8000315 	stw	zero,12(sp)
81113a98:	00818004 	movi	r2,1536
81113a9c:	d8800215 	stw	r2,8(sp)
81113aa0:	00a045b4 	movhi	r2,33046
81113aa4:	10909304 	addi	r2,r2,16972
81113aa8:	d8800115 	stw	r2,4(sp)
81113aac:	00800704 	movi	r2,28
81113ab0:	d8800015 	stw	r2,0(sp)
81113ab4:	01c00704 	movi	r7,28
81113ab8:	01a045b4 	movhi	r6,33046
81113abc:	31969204 	addi	r6,r6,23112
81113ac0:	000b883a 	mov	r5,zero
81113ac4:	01204474 	movhi	r4,33041
81113ac8:	21121c04 	addi	r4,r4,18544
81113acc:	11418780 	call	81141878 <OSTaskCreateExt>
81113ad0:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113ad4:	e0bffe03 	ldbu	r2,-8(fp)
81113ad8:	10803fcc 	andi	r2,r2,255
81113adc:	10000b26 	beq	r2,zero,81113b0c <vInitialTask+0x49c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113ae0:	00a045f4 	movhi	r2,33047
81113ae4:	10a34f04 	addi	r2,r2,-29380
81113ae8:	10800a8b 	ldhu	r2,42(r2)
81113aec:	10bfffcc 	andi	r2,r2,65535
81113af0:	10800228 	cmpgeui	r2,r2,8
81113af4:	1000041e 	bne	r2,zero,81113b08 <vInitialTask+0x498>
			printErrorTask( error_code );
81113af8:	e0bffe03 	ldbu	r2,-8(fp)
81113afc:	10803fcc 	andi	r2,r2,255
81113b00:	1009883a 	mov	r4,r2
81113b04:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailParserCommTaskCreate();
81113b08:	111e1140 	call	8111e114 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81113b0c:	01c03204 	movi	r7,200
81113b10:	000d883a 	mov	r6,zero
81113b14:	000b883a 	mov	r5,zero
81113b18:	0009883a 	mov	r4,zero
81113b1c:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81113b20:	d8000415 	stw	zero,16(sp)
81113b24:	d8000315 	stw	zero,12(sp)
81113b28:	00818004 	movi	r2,1536
81113b2c:	d8800215 	stw	r2,8(sp)
81113b30:	00a045b4 	movhi	r2,33046
81113b34:	10b14504 	addi	r2,r2,-15084
81113b38:	d8800115 	stw	r2,4(sp)
81113b3c:	00800804 	movi	r2,32
81113b40:	d8800015 	stw	r2,0(sp)
81113b44:	01c00804 	movi	r7,32
81113b48:	01a045b4 	movhi	r6,33046
81113b4c:	31b74404 	addi	r6,r6,-8944
81113b50:	000b883a 	mov	r5,zero
81113b54:	01204474 	movhi	r4,33041
81113b58:	2116ac04 	addi	r4,r4,23216
81113b5c:	11418780 	call	81141878 <OSTaskCreateExt>
81113b60:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113b64:	e0bffe03 	ldbu	r2,-8(fp)
81113b68:	10803fcc 	andi	r2,r2,255
81113b6c:	10000b26 	beq	r2,zero,81113b9c <vInitialTask+0x52c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113b70:	00a045f4 	movhi	r2,33047
81113b74:	10a34f04 	addi	r2,r2,-29380
81113b78:	10800a8b 	ldhu	r2,42(r2)
81113b7c:	10bfffcc 	andi	r2,r2,65535
81113b80:	10800228 	cmpgeui	r2,r2,8
81113b84:	1000041e 	bne	r2,zero,81113b98 <vInitialTask+0x528>
			printErrorTask( error_code );
81113b88:	e0bffe03 	ldbu	r2,-8(fp)
81113b8c:	10803fcc 	andi	r2,r2,255
81113b90:	1009883a 	mov	r4,r2
81113b94:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailReceiverCreate();
81113b98:	111d8680 	call	8111d868 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81113b9c:	01c03204 	movi	r7,200
81113ba0:	000d883a 	mov	r6,zero
81113ba4:	000b883a 	mov	r5,zero
81113ba8:	0009883a 	mov	r4,zero
81113bac:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81113bb0:	d8000415 	stw	zero,16(sp)
81113bb4:	d8000315 	stw	zero,12(sp)
81113bb8:	00810004 	movi	r2,1024
81113bbc:	d8800215 	stw	r2,8(sp)
81113bc0:	00a045b4 	movhi	r2,33046
81113bc4:	10a02b04 	addi	r2,r2,-32596
81113bc8:	d8800115 	stw	r2,4(sp)
81113bcc:	00800684 	movi	r2,26
81113bd0:	d8800015 	stw	r2,0(sp)
81113bd4:	01c00684 	movi	r7,26
81113bd8:	01a045b4 	movhi	r6,33046
81113bdc:	31a42a04 	addi	r6,r6,-28504
81113be0:	000b883a 	mov	r5,zero
81113be4:	01204474 	movhi	r4,33041
81113be8:	21194704 	addi	r4,r4,25884
81113bec:	11418780 	call	81141878 <OSTaskCreateExt>
81113bf0:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
81113bf4:	01c03204 	movi	r7,200
81113bf8:	000d883a 	mov	r6,zero
81113bfc:	000b883a 	mov	r5,zero
81113c00:	0009883a 	mov	r4,zero
81113c04:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
81113c08:	e0bffe03 	ldbu	r2,-8(fp)
81113c0c:	10803fcc 	andi	r2,r2,255
81113c10:	10000b26 	beq	r2,zero,81113c40 <vInitialTask+0x5d0>
		/* Can't create Task for sender comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113c14:	00a045f4 	movhi	r2,33047
81113c18:	10a34f04 	addi	r2,r2,-29380
81113c1c:	10800a8b 	ldhu	r2,42(r2)
81113c20:	10bfffcc 	andi	r2,r2,65535
81113c24:	10800228 	cmpgeui	r2,r2,8
81113c28:	1000041e 	bne	r2,zero,81113c3c <vInitialTask+0x5cc>
			printErrorTask( error_code );
81113c2c:	e0bffe03 	ldbu	r2,-8(fp)
81113c30:	10803fcc 	andi	r2,r2,255
81113c34:	1009883a 	mov	r4,r2
81113c38:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailSenderCreate();
81113c3c:	111d8cc0 	call	8111d8cc <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
81113c40:	d0a06d17 	ldw	r2,-32332(gp)
81113c44:	e17ffe04 	addi	r5,fp,-8
81113c48:	1009883a 	mov	r4,r2
81113c4c:	11435980 	call	81143598 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81113c50:	e0bffe03 	ldbu	r2,-8(fp)
81113c54:	10803fcc 	andi	r2,r2,255
81113c58:	10000126 	beq	r2,zero,81113c60 <vInitialTask+0x5f0>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
81113c5c:	111e66c0 	call	8111e66c <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
81113c60:	01c00084 	movi	r7,2
81113c64:	01800784 	movi	r6,30
81113c68:	000b883a 	mov	r5,zero
81113c6c:	0009883a 	mov	r4,zero
81113c70:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
81113c74:	01003fc4 	movi	r4,255
81113c78:	1141a640 	call	81141a64 <OSTaskDel>
81113c7c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81113c80:	e0bffe03 	ldbu	r2,-8(fp)
81113c84:	10803fcc 	andi	r2,r2,255
81113c88:	10001626 	beq	r2,zero,81113ce4 <vInitialTask+0x674>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113c8c:	00a045f4 	movhi	r2,33047
81113c90:	10a34f04 	addi	r2,r2,-29380
81113c94:	10800a8b 	ldhu	r2,42(r2)
81113c98:	10bfffcc 	andi	r2,r2,65535
81113c9c:	10800228 	cmpgeui	r2,r2,8
81113ca0:	1000041e 	bne	r2,zero,81113cb4 <vInitialTask+0x644>
			printErrorTask( error_code );		
81113ca4:	e0bffe03 	ldbu	r2,-8(fp)
81113ca8:	10803fcc 	andi	r2,r2,255
81113cac:	1009883a 	mov	r4,r2
81113cb0:	111d1600 	call	8111d160 <printErrorTask>
		}
		#endif
		vFailDeleteInitialization();
81113cb4:	111d9300 	call	8111d930 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
81113cb8:	014009c4 	movi	r5,39
81113cbc:	01000044 	movi	r4,1
81113cc0:	11411cc0 	call	811411cc <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
81113cc4:	01003fc4 	movi	r4,255
81113cc8:	1141a640 	call	81141a64 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
81113ccc:	000f883a 	mov	r7,zero
81113cd0:	01800284 	movi	r6,10
81113cd4:	000b883a 	mov	r5,zero
81113cd8:	0009883a 	mov	r4,zero
81113cdc:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
		}
81113ce0:	003ff806 	br	81113cc4 <__reset+0xfb0f3cc4>
	}

}
81113ce4:	0001883a 	nop
81113ce8:	e037883a 	mov	sp,fp
81113cec:	dfc00117 	ldw	ra,4(sp)
81113cf0:	df000017 	ldw	fp,0(sp)
81113cf4:	dec00204 	addi	sp,sp,8
81113cf8:	f800283a 	ret

81113cfc <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81113cfc:	defff704 	addi	sp,sp,-36
81113d00:	de00012e 	bgeu	sp,et,81113d08 <vNFeeControlTask+0xc>
81113d04:	003b68fa 	trap	3
81113d08:	dfc00815 	stw	ra,32(sp)
81113d0c:	df000715 	stw	fp,28(sp)
81113d10:	df000704 	addi	fp,sp,28
81113d14:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81113d18:	e0bfff17 	ldw	r2,-4(fp)
81113d1c:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113d20:	00a045f4 	movhi	r2,33047
81113d24:	10a34f04 	addi	r2,r2,-29380
81113d28:	10800a8b 	ldhu	r2,42(r2)
81113d2c:	10bfffcc 	andi	r2,r2,65535
81113d30:	10800168 	cmpgeui	r2,r2,5
81113d34:	1000071e 	bne	r2,zero,81113d54 <vNFeeControlTask+0x58>
        debug(fp,"NFee Controller Task. (Task on)\n");
81113d38:	d0a06217 	ldw	r2,-32376(gp)
81113d3c:	100f883a 	mov	r7,r2
81113d40:	01800804 	movi	r6,32
81113d44:	01400044 	movi	r5,1
81113d48:	01204574 	movhi	r4,33045
81113d4c:	213dcc04 	addi	r4,r4,-2256
81113d50:	1123cec0 	call	81123cec <fwrite>
	}
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
81113d54:	e0bffa17 	ldw	r2,-24(fp)
81113d58:	10809c17 	ldw	r2,624(r2)
81113d5c:	10c00168 	cmpgeui	r3,r2,5
81113d60:	1800e71e 	bne	r3,zero,81114100 <vNFeeControlTask+0x404>
81113d64:	100690ba 	slli	r3,r2,2
81113d68:	00a04474 	movhi	r2,33041
81113d6c:	108f5f04 	addi	r2,r2,15740
81113d70:	1885883a 	add	r2,r3,r2
81113d74:	10800017 	ldw	r2,0(r2)
81113d78:	1000683a 	jmp	r2
81113d7c:	81113d90 	cmplti	r4,r16,17654
81113d80:	81113dc0 	call	881113dc <__reset+0x20f13dc>
81113d84:	81113e38 	rdprs	r4,r16,17656
81113d88:	81113f04 	addi	r4,r16,17660
81113d8c:	81113f64 	muli	r4,r16,17661
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
81113d90:	d0a07017 	ldw	r2,-32320(gp)
81113d94:	1009883a 	mov	r4,r2
81113d98:	113fb540 	call	8113fb54 <OSQFlush>
81113d9c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113da0:	e0bffe03 	ldbu	r2,-8(fp)
81113da4:	10803fcc 	andi	r2,r2,255
81113da8:	10000126 	beq	r2,zero,81113db0 <vNFeeControlTask+0xb4>
					vFailFlushQueue();
81113dac:	111f7100 	call	8111f710 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
81113db0:	e0bffa17 	ldw	r2,-24(fp)
81113db4:	00c00044 	movi	r3,1
81113db8:	10c09c15 	stw	r3,624(r2)
				break;
81113dbc:	0000e206 	br	81114148 <vNFeeControlTask+0x44c>


			case sMebToConfig:
				/* Transition state */
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113dc0:	00a045f4 	movhi	r2,33047
81113dc4:	10a34f04 	addi	r2,r2,-29380
81113dc8:	10800a8b 	ldhu	r2,42(r2)
81113dcc:	10bfffcc 	andi	r2,r2,65535
81113dd0:	108000e8 	cmpgeui	r2,r2,3
81113dd4:	1000071e 	bne	r2,zero,81113df4 <vNFeeControlTask+0xf8>
					debug(fp,"NFEE Controller Task: Config Mode\n");
81113dd8:	d0a06217 	ldw	r2,-32376(gp)
81113ddc:	100f883a 	mov	r7,r2
81113de0:	01800884 	movi	r6,34
81113de4:	01400044 	movi	r5,1
81113de8:	01204574 	movhi	r4,33045
81113dec:	213dd504 	addi	r4,r4,-2220
81113df0:	1123cec0 	call	81123cec <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113df4:	d0a05d17 	ldw	r2,-32396(gp)
81113df8:	1009883a 	mov	r4,r2
81113dfc:	113fb540 	call	8113fb54 <OSQFlush>
81113e00:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113e04:	e0bffe03 	ldbu	r2,-8(fp)
81113e08:	10803fcc 	andi	r2,r2,255
81113e0c:	10000126 	beq	r2,zero,81113e14 <vNFeeControlTask+0x118>
					vFailFlushQueue();
81113e10:	111f7100 	call	8111f710 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81113e14:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81113e18:	00800044 	movi	r2,1
81113e1c:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81113e20:	00bfffc4 	movi	r2,-1
81113e24:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
81113e28:	e0bffa17 	ldw	r2,-24(fp)
81113e2c:	00c000c4 	movi	r3,3
81113e30:	10c09c15 	stw	r3,624(r2)
				break;
81113e34:	0000c406 	br	81114148 <vNFeeControlTask+0x44c>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81113e38:	111f8c80 	call	8111f8c8 <vEvtChangeFeeControllerMode>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113e3c:	00a045f4 	movhi	r2,33047
81113e40:	10a34f04 	addi	r2,r2,-29380
81113e44:	10800a8b 	ldhu	r2,42(r2)
81113e48:	10bfffcc 	andi	r2,r2,65535
81113e4c:	108000e8 	cmpgeui	r2,r2,3
81113e50:	1000071e 	bne	r2,zero,81113e70 <vNFeeControlTask+0x174>
					debug(fp,"NFEE Controller Task: RUN Mode\n");
81113e54:	d0a06217 	ldw	r2,-32376(gp)
81113e58:	100f883a 	mov	r7,r2
81113e5c:	018007c4 	movi	r6,31
81113e60:	01400044 	movi	r5,1
81113e64:	01204574 	movhi	r4,33045
81113e68:	213dde04 	addi	r4,r4,-2184
81113e6c:	1123cec0 	call	81123cec <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113e70:	d0a05d17 	ldw	r2,-32396(gp)
81113e74:	1009883a 	mov	r4,r2
81113e78:	113fb540 	call	8113fb54 <OSQFlush>
81113e7c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113e80:	e0bffe03 	ldbu	r2,-8(fp)
81113e84:	10803fcc 	andi	r2,r2,255
81113e88:	10000126 	beq	r2,zero,81113e90 <vNFeeControlTask+0x194>
					vFailFlushQueue();
81113e8c:	111f7100 	call	8111f710 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81113e90:	e03ff905 	stb	zero,-28(fp)
81113e94:	00001006 	br	81113ed8 <vNFeeControlTask+0x1dc>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81113e98:	e0bff903 	ldbu	r2,-28(fp)
81113e9c:	1085883a 	add	r2,r2,r2
81113ea0:	1087883a 	add	r3,r2,r2
81113ea4:	d0a06a04 	addi	r2,gp,-32344
81113ea8:	1885883a 	add	r2,r3,r2
81113eac:	10800017 	ldw	r2,0(r2)
81113eb0:	1009883a 	mov	r4,r2
81113eb4:	113fb540 	call	8113fb54 <OSQFlush>
81113eb8:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
81113ebc:	e0bffe03 	ldbu	r2,-8(fp)
81113ec0:	10803fcc 	andi	r2,r2,255
81113ec4:	10000126 	beq	r2,zero,81113ecc <vNFeeControlTask+0x1d0>
						vFailFlushQueue();
81113ec8:	111f7100 	call	8111f710 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81113ecc:	e0bff903 	ldbu	r2,-28(fp)
81113ed0:	10800044 	addi	r2,r2,1
81113ed4:	e0bff905 	stb	r2,-28(fp)
81113ed8:	e0bff903 	ldbu	r2,-28(fp)
81113edc:	103fee26 	beq	r2,zero,81113e98 <__reset+0xfb0f3e98>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
81113ee0:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81113ee4:	00800044 	movi	r2,1
81113ee8:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81113eec:	00bfffc4 	movi	r2,-1
81113ef0:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
81113ef4:	e0bffa17 	ldw	r2,-24(fp)
81113ef8:	00c00104 	movi	r3,4
81113efc:	10c09c15 	stw	r3,624(r2)
				break;
81113f00:	00009106 	br	81114148 <vNFeeControlTask+0x44c>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81113f04:	d0a07017 	ldw	r2,-32320(gp)
81113f08:	e0fffe04 	addi	r3,fp,-8
81113f0c:	180d883a 	mov	r6,r3
81113f10:	000b883a 	mov	r5,zero
81113f14:	1009883a 	mov	r4,r2
81113f18:	113fc140 	call	8113fc14 <OSQPend>
81113f1c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81113f20:	e0bffe03 	ldbu	r2,-8(fp)
81113f24:	10803fcc 	andi	r2,r2,255
81113f28:	10000c1e 	bne	r2,zero,81113f5c <vNFeeControlTask+0x260>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81113f2c:	e0bffdc3 	ldbu	r2,-9(fp)
81113f30:	10803fcc 	andi	r2,r2,255
81113f34:	10800418 	cmpnei	r2,r2,16
81113f38:	1000041e 	bne	r2,zero,81113f4c <vNFeeControlTask+0x250>
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81113f3c:	e0bffd17 	ldw	r2,-12(fp)
81113f40:	e17ffa17 	ldw	r5,-24(fp)
81113f44:	1009883a 	mov	r4,r2
81113f48:	111414c0 	call	8111414c <vPerformActionNFCConfig>
					}
					bCmdSent = FALSE;
81113f4c:	e03ffb15 	stw	zero,-20(fp)
					bDmaBack = TRUE;
81113f50:	00800044 	movi	r2,1
81113f54:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81113f58:	00007b06 	br	81114148 <vNFeeControlTask+0x44c>
					}
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81113f5c:	111f25c0 	call	8111f25c <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81113f60:	00007906 	br	81114148 <vNFeeControlTask+0x44c>
				/* 	We have 2 importantes Queues here.  
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fast way and
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				
				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81113f64:	d0a05817 	ldw	r2,-32416(gp)
81113f68:	10800058 	cmpnei	r2,r2,1
81113f6c:	1000221e 	bne	r2,zero,81113ff8 <vNFeeControlTask+0x2fc>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81113f70:	d0a05d17 	ldw	r2,-32396(gp)
81113f74:	e0fffe04 	addi	r3,fp,-8
81113f78:	180d883a 	mov	r6,r3
81113f7c:	01400104 	movi	r5,4
81113f80:	1009883a 	mov	r4,r2
81113f84:	113fc140 	call	8113fc14 <OSQPend>
81113f88:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81113f8c:	e0bffe03 	ldbu	r2,-8(fp)
81113f90:	10803fcc 	andi	r2,r2,255
81113f94:	1000181e 	bne	r2,zero,81113ff8 <vNFeeControlTask+0x2fc>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81113f98:	e0bffd03 	ldbu	r2,-12(fp)
81113f9c:	e0bffc05 	stb	r2,-16(fp)

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81113fa0:	e0bffc03 	ldbu	r2,-16(fp)
81113fa4:	e0fffa17 	ldw	r3,-24(fp)
81113fa8:	10809824 	muli	r2,r2,608
81113fac:	1885883a 	add	r2,r3,r2
81113fb0:	10802304 	addi	r2,r2,140
81113fb4:	10800017 	ldw	r2,0(r2)
81113fb8:	10800058 	cmpnei	r2,r2,1
81113fbc:	10000e1e 	bne	r2,zero,81113ff8 <vNFeeControlTask+0x2fc>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81113fc0:	e0bffc03 	ldbu	r2,-16(fp)
81113fc4:	e0fffc03 	ldbu	r3,-16(fp)
81113fc8:	180f883a 	mov	r7,r3
81113fcc:	000d883a 	mov	r6,zero
81113fd0:	014023c4 	movi	r5,143
81113fd4:	1009883a 	mov	r4,r2
81113fd8:	11143b80 	call	811143b8 <bSendCmdQToNFeeInst>
81113fdc:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
81113fe0:	e0bffb17 	ldw	r2,-20(fp)
81113fe4:	10800058 	cmpnei	r2,r2,1
81113fe8:	1000031e 	bne	r2,zero,81113ff8 <vNFeeControlTask+0x2fc>
								bDmaBack = FALSE;
81113fec:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
81113ff0:	e0bffc03 	ldbu	r2,-16(fp)
81113ff4:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81113ff8:	d0a05817 	ldw	r2,-32416(gp)
81113ffc:	1000081e 	bne	r2,zero,81114020 <vNFeeControlTask+0x324>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81114000:	d0a07017 	ldw	r2,-32320(gp)
81114004:	e0fffe04 	addi	r3,fp,-8
81114008:	180d883a 	mov	r6,r3
8111400c:	000b883a 	mov	r5,zero
81114010:	1009883a 	mov	r4,r2
81114014:	113fc140 	call	8113fc14 <OSQPend>
81114018:	e0bffd15 	stw	r2,-12(fp)
8111401c:	00000706 	br	8111403c <vNFeeControlTask+0x340>
				} else {
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81114020:	d0a07017 	ldw	r2,-32320(gp)
81114024:	e0fffe04 	addi	r3,fp,-8
81114028:	180d883a 	mov	r6,r3
8111402c:	01400104 	movi	r5,4
81114030:	1009883a 	mov	r4,r2
81114034:	113fc140 	call	8113fc14 <OSQPend>
81114038:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
8111403c:	e0bffe03 	ldbu	r2,-8(fp)
81114040:	10803fcc 	andi	r2,r2,255
81114044:	10003f1e 	bne	r2,zero,81114144 <vNFeeControlTask+0x448>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81114048:	e0bffd83 	ldbu	r2,-10(fp)
8111404c:	10803fcc 	andi	r2,r2,255
81114050:	10802058 	cmpnei	r2,r2,129
81114054:	10000a1e 	bne	r2,zero,81114080 <vNFeeControlTask+0x384>
						if ( uiCmdNFC.ucByte[0] == ucWhoGetDMA ){
81114058:	e0fffd03 	ldbu	r3,-12(fp)
8111405c:	d0a05903 	ldbu	r2,-32412(gp)
81114060:	18c03fcc 	andi	r3,r3,255
81114064:	10803fcc 	andi	r2,r2,255
81114068:	1880361e 	bne	r3,r2,81114144 <vNFeeControlTask+0x448>
							bDmaBack = TRUE;
8111406c:	00800044 	movi	r2,1
81114070:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81114074:	00bfffc4 	movi	r2,-1
81114078:	e0bffc05 	stb	r2,-16(fp)
							}
						}
					}
				}
				
				break;		
8111407c:	00003106 	br	81114144 <vNFeeControlTask+0x448>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81114080:	e0bffdc3 	ldbu	r2,-9(fp)
81114084:	10803fcc 	andi	r2,r2,255
81114088:	10800418 	cmpnei	r2,r2,16
8111408c:	1000051e 	bne	r2,zero,811140a4 <vNFeeControlTask+0x3a8>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81114090:	e0bffd17 	ldw	r2,-12(fp)
81114094:	e17ffa17 	ldw	r5,-24(fp)
81114098:	1009883a 	mov	r4,r2
8111409c:	11142500 	call	81114250 <vPerformActionNFCRunning>
							}
						}
					}
				}
				
				break;		
811140a0:	00002806 	br	81114144 <vNFeeControlTask+0x448>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
811140a4:	e0bffdc3 	ldbu	r2,-9(fp)
811140a8:	10803fcc 	andi	r2,r2,255
811140ac:	10800470 	cmpltui	r2,r2,17
811140b0:	1000241e 	bne	r2,zero,81114144 <vNFeeControlTask+0x448>
811140b4:	e0bffdc3 	ldbu	r2,-9(fp)
811140b8:	10803fcc 	andi	r2,r2,255
811140bc:	108004e8 	cmpgeui	r2,r2,19
811140c0:	1000201e 	bne	r2,zero,81114144 <vNFeeControlTask+0x448>
								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
811140c4:	e0bffdc3 	ldbu	r2,-9(fp)
811140c8:	10bffbc4 	addi	r2,r2,-17
811140cc:	10803fcc 	andi	r2,r2,255
811140d0:	e0fffd83 	ldbu	r3,-10(fp)
811140d4:	18c03fcc 	andi	r3,r3,255
811140d8:	e13ffd43 	ldbu	r4,-11(fp)
811140dc:	21003fcc 	andi	r4,r4,255
811140e0:	e17ffd03 	ldbu	r5,-12(fp)
811140e4:	29403fcc 	andi	r5,r5,255
811140e8:	280f883a 	mov	r7,r5
811140ec:	200d883a 	mov	r6,r4
811140f0:	180b883a 	mov	r5,r3
811140f4:	1009883a 	mov	r4,r2
811140f8:	11143b80 	call	811143b8 <bSendCmdQToNFeeInst>
							}
						}
					}
				}
				
				break;		
811140fc:	00001106 	br	81114144 <vNFeeControlTask+0x448>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81114100:	00a045f4 	movhi	r2,33047
81114104:	10a34f04 	addi	r2,r2,-29380
81114108:	10800a8b 	ldhu	r2,42(r2)
8111410c:	10bfffcc 	andi	r2,r2,65535
81114110:	10800228 	cmpgeui	r2,r2,8
81114114:	1000071e 	bne	r2,zero,81114134 <vNFeeControlTask+0x438>
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81114118:	d0a06217 	ldw	r2,-32376(gp)
8111411c:	100f883a 	mov	r7,r2
81114120:	01800f44 	movi	r6,61
81114124:	01400044 	movi	r5,1
81114128:	01204574 	movhi	r4,33045
8111412c:	213de604 	addi	r4,r4,-2152
81114130:	1123cec0 	call	81123cec <fwrite>
				}
				#endif
				
				pxFeeC->sMode = sMebConfig;
81114134:	e0bffa17 	ldw	r2,-24(fp)
81114138:	00c000c4 	movi	r3,3
8111413c:	10c09c15 	stw	r3,624(r2)
				break;
81114140:	00000106 	br	81114148 <vNFeeControlTask+0x44c>
							}
						}
					}
				}
				
				break;		
81114144:	0001883a 	nop
				#endif
				
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81114148:	003f0206 	br	81113d54 <__reset+0xfb0f3d54>

8111414c <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8111414c:	defffb04 	addi	sp,sp,-20
81114150:	de00012e 	bgeu	sp,et,81114158 <vPerformActionNFCConfig+0xc>
81114154:	003b68fa 	trap	3
81114158:	dfc00415 	stw	ra,16(sp)
8111415c:	df000315 	stw	fp,12(sp)
81114160:	df000304 	addi	fp,sp,12
81114164:	e13ffe15 	stw	r4,-8(fp)
81114168:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;

	uiCmdLocal.ulWord = uiCmdParam;
8111416c:	e0bffe17 	ldw	r2,-8(fp)
81114170:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81114174:	e0bffd83 	ldbu	r2,-10(fp)
81114178:	10803fcc 	andi	r2,r2,255
8111417c:	10c000a0 	cmpeqi	r3,r2,2
81114180:	1800181e 	bne	r3,zero,811141e4 <vPerformActionNFCConfig+0x98>
81114184:	10c000c8 	cmpgei	r3,r2,3
81114188:	1800031e 	bne	r3,zero,81114198 <vPerformActionNFCConfig+0x4c>
8111418c:	10800060 	cmpeqi	r2,r2,1
81114190:	1000061e 	bne	r2,zero,811141ac <vPerformActionNFCConfig+0x60>
81114194:	00001706 	br	811141f4 <vPerformActionNFCConfig+0xa8>
81114198:	10c02860 	cmpeqi	r3,r2,161
8111419c:	1800031e 	bne	r3,zero,811141ac <vPerformActionNFCConfig+0x60>
811141a0:	108028a0 	cmpeqi	r2,r2,162
811141a4:	10000f1e 	bne	r2,zero,811141e4 <vPerformActionNFCConfig+0x98>
811141a8:	00001206 	br	811141f4 <vPerformActionNFCConfig+0xa8>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811141ac:	00a045f4 	movhi	r2,33047
811141b0:	10a34f04 	addi	r2,r2,-29380
811141b4:	10800a8b 	ldhu	r2,42(r2)
811141b8:	10bfffcc 	andi	r2,r2,65535
811141bc:	108000e8 	cmpgeui	r2,r2,3
811141c0:	10001a1e 	bne	r2,zero,8111422c <vPerformActionNFCConfig+0xe0>
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
811141c4:	d0a06217 	ldw	r2,-32376(gp)
811141c8:	100f883a 	mov	r7,r2
811141cc:	01800d44 	movi	r6,53
811141d0:	01400044 	movi	r5,1
811141d4:	01204574 	movhi	r4,33045
811141d8:	213df604 	addi	r4,r4,-2088
811141dc:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			/* Do nothing for now */
			break;
811141e0:	00001206 	br	8111422c <vPerformActionNFCConfig+0xe0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
811141e4:	e0bfff17 	ldw	r2,-4(fp)
811141e8:	00c00084 	movi	r3,2
811141ec:	10c09c15 	stw	r3,624(r2)
			break;
811141f0:	00001106 	br	81114238 <vPerformActionNFCConfig+0xec>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811141f4:	00a045f4 	movhi	r2,33047
811141f8:	10a34f04 	addi	r2,r2,-29380
811141fc:	10800a8b 	ldhu	r2,42(r2)
81114200:	10bfffcc 	andi	r2,r2,65535
81114204:	10800228 	cmpgeui	r2,r2,8
81114208:	10000a1e 	bne	r2,zero,81114234 <vPerformActionNFCConfig+0xe8>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8111420c:	d0a06217 	ldw	r2,-32376(gp)
81114210:	100f883a 	mov	r7,r2
81114214:	018009c4 	movi	r6,39
81114218:	01400044 	movi	r5,1
8111421c:	01204574 	movhi	r4,33045
81114220:	213e0404 	addi	r4,r4,-2032
81114224:	1123cec0 	call	81123cec <fwrite>
			}
			#endif	
			break;
81114228:	00000206 	br	81114234 <vPerformActionNFCConfig+0xe8>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
			}
			#endif
			/* Do nothing for now */
			break;
8111422c:	0001883a 	nop
81114230:	00000106 	br	81114238 <vPerformActionNFCConfig+0xec>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
81114234:	0001883a 	nop
	}

}
81114238:	0001883a 	nop
8111423c:	e037883a 	mov	sp,fp
81114240:	dfc00117 	ldw	ra,4(sp)
81114244:	df000017 	ldw	fp,0(sp)
81114248:	dec00204 	addi	sp,sp,8
8111424c:	f800283a 	ret

81114250 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81114250:	defffa04 	addi	sp,sp,-24
81114254:	de00012e 	bgeu	sp,et,8111425c <vPerformActionNFCRunning+0xc>
81114258:	003b68fa 	trap	3
8111425c:	dfc00515 	stw	ra,20(sp)
81114260:	df000415 	stw	fp,16(sp)
81114264:	df000404 	addi	fp,sp,16
81114268:	e13ffe15 	stw	r4,-8(fp)
8111426c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81114270:	e0bffe17 	ldw	r2,-8(fp)
81114274:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81114278:	e0bffd83 	ldbu	r2,-10(fp)
8111427c:	10803fcc 	andi	r2,r2,255
81114280:	10c02088 	cmpgei	r3,r2,130
81114284:	1800071e 	bne	r3,zero,811142a4 <vPerformActionNFCRunning+0x54>
81114288:	10c02008 	cmpgei	r3,r2,128
8111428c:	18003f1e 	bne	r3,zero,8111438c <vPerformActionNFCRunning+0x13c>
81114290:	10c00060 	cmpeqi	r3,r2,1
81114294:	1800051e 	bne	r3,zero,811142ac <vPerformActionNFCRunning+0x5c>
81114298:	108000a0 	cmpeqi	r2,r2,2
8111429c:	10001f1e 	bne	r2,zero,8111431c <vPerformActionNFCRunning+0xcc>
811142a0:	00002c06 	br	81114354 <vPerformActionNFCRunning+0x104>
811142a4:	10802860 	cmpeqi	r2,r2,161
811142a8:	10002a26 	beq	r2,zero,81114354 <vPerformActionNFCRunning+0x104>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
811142ac:	e0bfff17 	ldw	r2,-4(fp)
811142b0:	00c00044 	movi	r3,1
811142b4:	10c09c15 	stw	r3,624(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
811142b8:	e03ffc05 	stb	zero,-16(fp)
811142bc:	00001406 	br	81114310 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
811142c0:	e0bffc03 	ldbu	r2,-16(fp)
811142c4:	e0ffff17 	ldw	r3,-4(fp)
811142c8:	10802644 	addi	r2,r2,153
811142cc:	1085883a 	add	r2,r2,r2
811142d0:	1085883a 	add	r2,r2,r2
811142d4:	1885883a 	add	r2,r3,r2
811142d8:	10800017 	ldw	r2,0(r2)
811142dc:	10800017 	ldw	r2,0(r2)
811142e0:	10800058 	cmpnei	r2,r2,1
811142e4:	1000071e 	bne	r2,zero,81114304 <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
811142e8:	e0bffc03 	ldbu	r2,-16(fp)
811142ec:	e0fffc03 	ldbu	r3,-16(fp)
811142f0:	180f883a 	mov	r7,r3
811142f4:	000d883a 	mov	r6,zero
811142f8:	01402844 	movi	r5,161
811142fc:	1009883a 	mov	r4,r2
81114300:	11144800 	call	81114480 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81114304:	e0bffc03 	ldbu	r2,-16(fp)
81114308:	10800044 	addi	r2,r2,1
8111430c:	e0bffc05 	stb	r2,-16(fp)
81114310:	e0bffc03 	ldbu	r2,-16(fp)
81114314:	103fea26 	beq	r2,zero,811142c0 <__reset+0xfb0f42c0>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81114318:	00002106 	br	811143a0 <vPerformActionNFCRunning+0x150>
		case M_NFC_RUN:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111431c:	00a045f4 	movhi	r2,33047
81114320:	10a34f04 	addi	r2,r2,-29380
81114324:	10800a8b 	ldhu	r2,42(r2)
81114328:	10bfffcc 	andi	r2,r2,65535
8111432c:	108000e8 	cmpgeui	r2,r2,3
81114330:	1000181e 	bne	r2,zero,81114394 <vPerformActionNFCRunning+0x144>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81114334:	d0a06217 	ldw	r2,-32376(gp)
81114338:	100f883a 	mov	r7,r2
8111433c:	01800d84 	movi	r6,54
81114340:	01400044 	movi	r5,1
81114344:	01204574 	movhi	r4,33045
81114348:	213e0e04 	addi	r4,r4,-1992
8111434c:	1123cec0 	call	81123cec <fwrite>
			}
			#endif		
			/* Do nothing for now */

			break;
81114350:	00001006 	br	81114394 <vPerformActionNFCRunning+0x144>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81114354:	00a045f4 	movhi	r2,33047
81114358:	10a34f04 	addi	r2,r2,-29380
8111435c:	10800a8b 	ldhu	r2,42(r2)
81114360:	10bfffcc 	andi	r2,r2,65535
81114364:	10800228 	cmpgeui	r2,r2,8
81114368:	10000c1e 	bne	r2,zero,8111439c <vPerformActionNFCRunning+0x14c>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8111436c:	d0a06217 	ldw	r2,-32376(gp)
81114370:	100f883a 	mov	r7,r2
81114374:	018009c4 	movi	r6,39
81114378:	01400044 	movi	r5,1
8111437c:	01204574 	movhi	r4,33045
81114380:	213e0404 	addi	r4,r4,-2032
81114384:	1123cec0 	call	81123cec <fwrite>
			}
			#endif	
			break;
81114388:	00000406 	br	8111439c <vPerformActionNFCRunning+0x14c>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
8111438c:	0001883a 	nop
81114390:	00000306 	br	811143a0 <vPerformActionNFCRunning+0x150>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
			}
			#endif		
			/* Do nothing for now */

			break;
81114394:	0001883a 	nop
81114398:	00000106 	br	811143a0 <vPerformActionNFCRunning+0x150>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
8111439c:	0001883a 	nop
	}
}
811143a0:	0001883a 	nop
811143a4:	e037883a 	mov	sp,fp
811143a8:	dfc00117 	ldw	ra,4(sp)
811143ac:	df000017 	ldw	fp,0(sp)
811143b0:	dec00204 	addi	sp,sp,8
811143b4:	f800283a 	ret

811143b8 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811143b8:	defff704 	addi	sp,sp,-36
811143bc:	de00012e 	bgeu	sp,et,811143c4 <bSendCmdQToNFeeInst+0xc>
811143c0:	003b68fa 	trap	3
811143c4:	dfc00815 	stw	ra,32(sp)
811143c8:	df000715 	stw	fp,28(sp)
811143cc:	df000704 	addi	fp,sp,28
811143d0:	2011883a 	mov	r8,r4
811143d4:	2809883a 	mov	r4,r5
811143d8:	3007883a 	mov	r3,r6
811143dc:	3805883a 	mov	r2,r7
811143e0:	e23ffc05 	stb	r8,-16(fp)
811143e4:	e13ffd05 	stb	r4,-12(fp)
811143e8:	e0fffe05 	stb	r3,-8(fp)
811143ec:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811143f0:	e0bffc03 	ldbu	r2,-16(fp)
811143f4:	10800444 	addi	r2,r2,17
811143f8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811143fc:	e0bffd03 	ldbu	r2,-12(fp)
81114400:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81114404:	e0bffe03 	ldbu	r2,-8(fp)
81114408:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111440c:	e0bfff03 	ldbu	r2,-4(fp)
81114410:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81114414:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81114418:	e0bffc03 	ldbu	r2,-16(fp)
8111441c:	1085883a 	add	r2,r2,r2
81114420:	1087883a 	add	r3,r2,r2
81114424:	d0a06a04 	addi	r2,gp,-32344
81114428:	1885883a 	add	r2,r3,r2
8111442c:	10800017 	ldw	r2,0(r2)
81114430:	e0fffb17 	ldw	r3,-20(fp)
81114434:	180b883a 	mov	r5,r3
81114438:	1009883a 	mov	r4,r2
8111443c:	114001c0 	call	8114001c <OSQPost>
81114440:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81114444:	e0bffa03 	ldbu	r2,-24(fp)
81114448:	10000526 	beq	r2,zero,81114460 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8111444c:	e0bffc03 	ldbu	r2,-16(fp)
81114450:	1009883a 	mov	r4,r2
81114454:	111f35c0 	call	8111f35c <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81114458:	e03ff915 	stw	zero,-28(fp)
8111445c:	00000206 	br	81114468 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81114460:	00800044 	movi	r2,1
81114464:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81114468:	e0bff917 	ldw	r2,-28(fp)
}
8111446c:	e037883a 	mov	sp,fp
81114470:	dfc00117 	ldw	ra,4(sp)
81114474:	df000017 	ldw	fp,0(sp)
81114478:	dec00204 	addi	sp,sp,8
8111447c:	f800283a 	ret

81114480 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81114480:	defff704 	addi	sp,sp,-36
81114484:	de00012e 	bgeu	sp,et,8111448c <bSendCmdQToNFeeInst_Prio+0xc>
81114488:	003b68fa 	trap	3
8111448c:	dfc00815 	stw	ra,32(sp)
81114490:	df000715 	stw	fp,28(sp)
81114494:	df000704 	addi	fp,sp,28
81114498:	2011883a 	mov	r8,r4
8111449c:	2809883a 	mov	r4,r5
811144a0:	3007883a 	mov	r3,r6
811144a4:	3805883a 	mov	r2,r7
811144a8:	e23ffc05 	stb	r8,-16(fp)
811144ac:	e13ffd05 	stb	r4,-12(fp)
811144b0:	e0fffe05 	stb	r3,-8(fp)
811144b4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811144b8:	e0bffc03 	ldbu	r2,-16(fp)
811144bc:	10800444 	addi	r2,r2,17
811144c0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811144c4:	e0bffd03 	ldbu	r2,-12(fp)
811144c8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811144cc:	e0bffe03 	ldbu	r2,-8(fp)
811144d0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811144d4:	e0bfff03 	ldbu	r2,-4(fp)
811144d8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811144dc:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
811144e0:	e0bffc03 	ldbu	r2,-16(fp)
811144e4:	1085883a 	add	r2,r2,r2
811144e8:	1087883a 	add	r3,r2,r2
811144ec:	d0a06a04 	addi	r2,gp,-32344
811144f0:	1885883a 	add	r2,r3,r2
811144f4:	10800017 	ldw	r2,0(r2)
811144f8:	e0fffb17 	ldw	r3,-20(fp)
811144fc:	180b883a 	mov	r5,r3
81114500:	1009883a 	mov	r4,r2
81114504:	114018c0 	call	8114018c <OSQPostFront>
81114508:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111450c:	e0bffa03 	ldbu	r2,-24(fp)
81114510:	10000526 	beq	r2,zero,81114528 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81114514:	e0bffc03 	ldbu	r2,-16(fp)
81114518:	1009883a 	mov	r4,r2
8111451c:	111f35c0 	call	8111f35c <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81114520:	e03ff915 	stw	zero,-28(fp)
81114524:	00000206 	br	81114530 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81114528:	00800044 	movi	r2,1
8111452c:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81114530:	e0bff917 	ldw	r2,-28(fp)
}
81114534:	e037883a 	mov	sp,fp
81114538:	dfc00117 	ldw	ra,4(sp)
8111453c:	df000017 	ldw	fp,0(sp)
81114540:	dec00204 	addi	sp,sp,8
81114544:	f800283a 	ret

81114548 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81114548:	defff704 	addi	sp,sp,-36
8111454c:	de00012e 	bgeu	sp,et,81114554 <vOutAckHandlerTask+0xc>
81114550:	003b68fa 	trap	3
81114554:	dfc00815 	stw	ra,32(sp)
81114558:	df000715 	stw	fp,28(sp)
8111455c:	df000704 	addi	fp,sp,28
81114560:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81114564:	e03ffac5 	stb	zero,-21(fp)
81114568:	e03ffb05 	stb	zero,-20(fp)
8111456c:	e03ffb45 	stb	zero,-19(fp)
81114570:	e03ffb85 	stb	zero,-18(fp)
81114574:	e03ffbc5 	stb	zero,-17(fp)
81114578:	e03ffc05 	stb	zero,-16(fp)
8111457c:	e03ffc45 	stb	zero,-15(fp)
81114580:	e03ffc85 	stb	zero,-14(fp)
81114584:	e03ffcc5 	stb	zero,-13(fp)
81114588:	e03ffd05 	stb	zero,-12(fp)
8111458c:	e03ffd45 	stb	zero,-11(fp)
81114590:	e03ffd85 	stb	zero,-10(fp)
81114594:	e03ffdc5 	stb	zero,-9(fp)
81114598:	e03ffe05 	stb	zero,-8(fp)
8111459c:	e03ffe45 	stb	zero,-7(fp)
811145a0:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
811145a4:	e03ffa45 	stb	zero,-23(fp)

	#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811145a8:	00a045f4 	movhi	r2,33047
811145ac:	10a34f04 	addi	r2,r2,-29380
811145b0:	10800a8b 	ldhu	r2,42(r2)
811145b4:	10bfffcc 	andi	r2,r2,65535
811145b8:	10800168 	cmpgeui	r2,r2,5
811145bc:	1000071e 	bne	r2,zero,811145dc <vOutAckHandlerTask+0x94>
		debug(fp,"Out Ack Handler Task. (Task on)\n");
811145c0:	d0a06217 	ldw	r2,-32376(gp)
811145c4:	100f883a 	mov	r7,r2
811145c8:	01800804 	movi	r6,32
811145cc:	01400044 	movi	r5,1
811145d0:	01204574 	movhi	r4,33045
811145d4:	213e1c04 	addi	r4,r4,-1936
811145d8:	1123cec0 	call	81123cec <fwrite>
    }
	#endif

	eSenderAckState = sSAConfiguring;
811145dc:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
811145e0:	e0bff917 	ldw	r2,-28(fp)
811145e4:	10c00060 	cmpeqi	r3,r2,1
811145e8:	1800071e 	bne	r3,zero,81114608 <vOutAckHandlerTask+0xc0>
811145ec:	0080032e 	bgeu	zero,r2,811145fc <vOutAckHandlerTask+0xb4>
811145f0:	108000a0 	cmpeqi	r2,r2,2
811145f4:	1000471e 	bne	r2,zero,81114714 <vOutAckHandlerTask+0x1cc>
811145f8:	00008c06 	br	8111482c <vOutAckHandlerTask+0x2e4>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
811145fc:	00800044 	movi	r2,1
81114600:	e0bff915 	stw	r2,-28(fp)
				break;
81114604:	00009906 	br	8111486c <vOutAckHandlerTask+0x324>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81114608:	00800044 	movi	r2,1
8111460c:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81114610:	d0a06117 	ldw	r2,-32380(gp)
81114614:	e0fffa84 	addi	r3,fp,-22
81114618:	180d883a 	mov	r6,r3
8111461c:	000b883a 	mov	r5,zero
81114620:	1009883a 	mov	r4,r2
81114624:	1140b0c0 	call	81140b0c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81114628:	e0bffa83 	ldbu	r2,-22(fp)
8111462c:	10803fcc 	andi	r2,r2,255
81114630:	1000361e 	bne	r2,zero,8111470c <vOutAckHandlerTask+0x1c4>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
81114634:	d0a07217 	ldw	r2,-32312(gp)
81114638:	e0fffa84 	addi	r3,fp,-22
8111463c:	180d883a 	mov	r6,r3
81114640:	000b883a 	mov	r5,zero
81114644:	1009883a 	mov	r4,r2
81114648:	113eb000 	call	8113eb00 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8111464c:	e0bffa83 	ldbu	r2,-22(fp)
81114650:	10803fcc 	andi	r2,r2,255
81114654:	10002b1e 	bne	r2,zero,81114704 <vOutAckHandlerTask+0x1bc>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81114658:	e03ffa05 	stb	zero,-24(fp)
8111465c:	00002206 	br	811146e8 <vOutAckHandlerTask+0x1a0>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81114660:	e0fffa03 	ldbu	r3,-24(fp)
81114664:	00a045f4 	movhi	r2,33047
81114668:	10a29f04 	addi	r2,r2,-30084
8111466c:	18c7883a 	add	r3,r3,r3
81114670:	18c7883a 	add	r3,r3,r3
81114674:	10c5883a 	add	r2,r2,r3
81114678:	10800003 	ldbu	r2,0(r2)
8111467c:	10803fcc 	andi	r2,r2,255
81114680:	1080201c 	xori	r2,r2,128
81114684:	10bfe004 	addi	r2,r2,-128
81114688:	10001426 	beq	r2,zero,811146dc <vOutAckHandlerTask+0x194>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8111468c:	e0fffa03 	ldbu	r3,-24(fp)
81114690:	00a045f4 	movhi	r2,33047
81114694:	10a29f04 	addi	r2,r2,-30084
81114698:	18c7883a 	add	r3,r3,r3
8111469c:	18c7883a 	add	r3,r3,r3
811146a0:	10c5883a 	add	r2,r2,r3
811146a4:	10c0000b 	ldhu	r3,0(r2)
811146a8:	d0e0598d 	sth	r3,-32410(gp)
811146ac:	1080008b 	ldhu	r2,2(r2)
811146b0:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
811146b4:	00800084 	movi	r2,2
811146b8:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
811146bc:	e0fffa03 	ldbu	r3,-24(fp)
811146c0:	00a045f4 	movhi	r2,33047
811146c4:	10a29f04 	addi	r2,r2,-30084
811146c8:	18c7883a 	add	r3,r3,r3
811146cc:	18c7883a 	add	r3,r3,r3
811146d0:	10c5883a 	add	r2,r2,r3
811146d4:	10000005 	stb	zero,0(r2)
                                break;
811146d8:	00000606 	br	811146f4 <vOutAckHandlerTask+0x1ac>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
811146dc:	e0bffa03 	ldbu	r2,-24(fp)
811146e0:	10800044 	addi	r2,r2,1
811146e4:	e0bffa05 	stb	r2,-24(fp)
811146e8:	e0bffa03 	ldbu	r2,-24(fp)
811146ec:	10800230 	cmpltui	r2,r2,8
811146f0:	103fdb1e 	bne	r2,zero,81114660 <__reset+0xfb0f4660>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
811146f4:	d0a07217 	ldw	r2,-32312(gp)
811146f8:	1009883a 	mov	r4,r2
811146fc:	113f0a40 	call	8113f0a4 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81114700:	00005a06 	br	8111486c <vOutAckHandlerTask+0x324>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81114704:	111d5a00 	call	8111d5a0 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81114708:	00005806 	br	8111486c <vOutAckHandlerTask+0x324>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8111470c:	111d5200 	call	8111d520 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81114710:	00005606 	br	8111486c <vOutAckHandlerTask+0x324>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81114714:	d0a05983 	ldbu	r2,-32410(gp)
81114718:	10803fcc 	andi	r2,r2,255
8111471c:	1080201c 	xori	r2,r2,128
81114720:	10bfe004 	addi	r2,r2,-128
81114724:	108008e0 	cmpeqi	r2,r2,35
81114728:	1000201e 	bne	r2,zero,811147ac <vOutAckHandlerTask+0x264>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8111472c:	d0a059c3 	ldbu	r2,-32409(gp)
81114730:	10c03fcc 	andi	r3,r2,255
81114734:	18c0201c 	xori	r3,r3,128
81114738:	18ffe004 	addi	r3,r3,-128
8111473c:	d0a05a0b 	ldhu	r2,-32408(gp)
81114740:	113fffcc 	andi	r4,r2,65535
81114744:	e0bffac4 	addi	r2,fp,-21
81114748:	200f883a 	mov	r7,r4
8111474c:	180d883a 	mov	r6,r3
81114750:	01604574 	movhi	r5,33045
81114754:	297e2504 	addi	r5,r5,-1900
81114758:	1009883a 	mov	r4,r2
8111475c:	1124f640 	call	81124f64 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81114760:	e0bffac4 	addi	r2,fp,-21
81114764:	1009883a 	mov	r4,r2
81114768:	11251780 	call	81125178 <strlen>
8111476c:	1007883a 	mov	r3,r2
81114770:	e0bffac4 	addi	r2,fp,-21
81114774:	180b883a 	mov	r5,r3
81114778:	1009883a 	mov	r4,r2
8111477c:	111d0240 	call	8111d024 <ucCrc8wInit>
81114780:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81114784:	e13ffa43 	ldbu	r4,-23(fp)
81114788:	e0fffac4 	addi	r3,fp,-21
8111478c:	e0bffac4 	addi	r2,fp,-21
81114790:	200f883a 	mov	r7,r4
81114794:	180d883a 	mov	r6,r3
81114798:	01604574 	movhi	r5,33045
8111479c:	297e2704 	addi	r5,r5,-1892
811147a0:	1009883a 	mov	r4,r2
811147a4:	1124f640 	call	81124f64 <sprintf>
811147a8:	00000c06 	br	811147dc <vOutAckHandlerTask+0x294>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
811147ac:	e0bffac4 	addi	r2,fp,-21
811147b0:	00c008c4 	movi	r3,35
811147b4:	10c00005 	stb	r3,0(r2)
811147b8:	00c01f04 	movi	r3,124
811147bc:	10c00045 	stb	r3,1(r2)
811147c0:	00c00d44 	movi	r3,53
811147c4:	10c00085 	stb	r3,2(r2)
811147c8:	00c00d04 	movi	r3,52
811147cc:	10c000c5 	stb	r3,3(r2)
811147d0:	00c00ec4 	movi	r3,59
811147d4:	10c00105 	stb	r3,4(r2)
811147d8:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
811147dc:	d0a07417 	ldw	r2,-32304(gp)
811147e0:	e0fffa84 	addi	r3,fp,-22
811147e4:	180d883a 	mov	r6,r3
811147e8:	01401904 	movi	r5,100
811147ec:	1009883a 	mov	r4,r2
811147f0:	113eb000 	call	8113eb00 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
811147f4:	e0bffa83 	ldbu	r2,-22(fp)
811147f8:	10803fcc 	andi	r2,r2,255
811147fc:	1000071e 	bne	r2,zero,8111481c <vOutAckHandlerTask+0x2d4>
                    puts(cBufferAck);
81114800:	e0bffac4 	addi	r2,fp,-21
81114804:	1009883a 	mov	r4,r2
81114808:	1124c200 	call	81124c20 <puts>
                    OSMutexPost(xTxUARTMutex);
8111480c:	d0a07417 	ldw	r2,-32304(gp)
81114810:	1009883a 	mov	r4,r2
81114814:	113f0a40 	call	8113f0a4 <OSMutexPost>
81114818:	00000106 	br	81114820 <vOutAckHandlerTask+0x2d8>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8111481c:	111d7200 	call	8111d720 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81114820:	00800044 	movi	r2,1
81114824:	e0bff915 	stw	r2,-28(fp)
                
				break;
81114828:	00001006 	br	8111486c <vOutAckHandlerTask+0x324>
			default:
            	#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111482c:	00a045f4 	movhi	r2,33047
81114830:	10a34f04 	addi	r2,r2,-29380
81114834:	10800a8b 	ldhu	r2,42(r2)
81114838:	10bfffcc 	andi	r2,r2,65535
8111483c:	10800228 	cmpgeui	r2,r2,8
81114840:	1000071e 	bne	r2,zero,81114860 <vOutAckHandlerTask+0x318>
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81114844:	d0a06217 	ldw	r2,-32376(gp)
81114848:	100f883a 	mov	r7,r2
8111484c:	01801104 	movi	r6,68
81114850:	01400044 	movi	r5,1
81114854:	01204574 	movhi	r4,33045
81114858:	213e2a04 	addi	r4,r4,-1880
8111485c:	1123cec0 	call	81123cec <fwrite>
				}
	            #endif
                eSenderAckState = sSAGettingACK;
81114860:	00800044 	movi	r2,1
81114864:	e0bff915 	stw	r2,-28(fp)
				break;
81114868:	0001883a 	nop
		}
	}
8111486c:	003f5c06 	br	811145e0 <__reset+0xfb0f45e0>

81114870 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81114870:	deffd704 	addi	sp,sp,-164
81114874:	de00012e 	bgeu	sp,et,8111487c <vParserCommTask+0xc>
81114878:	003b68fa 	trap	3
8111487c:	dfc02815 	stw	ra,160(sp)
81114880:	df002715 	stw	fp,156(sp)
81114884:	df002704 	addi	fp,sp,156
81114888:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8111488c:	e03fdd15 	stw	zero,-140(fp)
	#if DEBUG_ON
		char cPUSDebug[128];
	#endif

    #if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81114890:	00a045f4 	movhi	r2,33047
81114894:	10a34f04 	addi	r2,r2,-29380
81114898:	10800a8b 	ldhu	r2,42(r2)
8111489c:	10bfffcc 	andi	r2,r2,65535
811148a0:	10800168 	cmpgeui	r2,r2,5
811148a4:	1000071e 	bne	r2,zero,811148c4 <vParserCommTask+0x54>
			debug(fp,"Parser Comm Task. (Task on)\n");
811148a8:	d0a06217 	ldw	r2,-32376(gp)
811148ac:	100f883a 	mov	r7,r2
811148b0:	01800704 	movi	r6,28
811148b4:	01400044 	movi	r5,1
811148b8:	01204574 	movhi	r4,33045
811148bc:	213e3c04 	addi	r4,r4,-1808
811148c0:	1123cec0 	call	81123cec <fwrite>
		}
    #endif

	eParserMode = sConfiguring;
811148c4:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
811148c8:	e0bfdc17 	ldw	r2,-144(fp)
811148cc:	10800168 	cmpgeui	r2,r2,5
811148d0:	1003d31e 	bne	r2,zero,81115820 <vParserCommTask+0xfb0>
811148d4:	e0bfdc17 	ldw	r2,-144(fp)
811148d8:	100690ba 	slli	r3,r2,2
811148dc:	00a04474 	movhi	r2,33041
811148e0:	10923c04 	addi	r2,r2,18672
811148e4:	1885883a 	add	r2,r3,r2
811148e8:	10800017 	ldw	r2,0(r2)
811148ec:	1000683a 	jmp	r2
811148f0:	81114904 	addi	r4,r16,17700
811148f4:	81114910 	cmplti	r4,r16,17700
811148f8:	811149a4 	muli	r4,r16,17702
811148fc:	81114b20 	cmpeqi	r4,r16,17708
81114900:	81114b64 	muli	r4,r16,17709
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81114904:	00800044 	movi	r2,1
81114908:	e0bfdc15 	stw	r2,-144(fp)
				break;
8111490c:	0003c706 	br	8111582c <vParserCommTask+0xfbc>
			case sWaitingMessage:

				bSuccess = FALSE;
81114910:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81114914:	00800044 	movi	r2,1
81114918:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8111491c:	d0a06417 	ldw	r2,-32368(gp)
81114920:	e0ffde84 	addi	r3,fp,-134
81114924:	180d883a 	mov	r6,r3
81114928:	000b883a 	mov	r5,zero
8111492c:	1009883a 	mov	r4,r2
81114930:	1140b0c0 	call	81140b0c <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81114934:	e0bfde83 	ldbu	r2,-134(fp)
81114938:	10803fcc 	andi	r2,r2,255
8111493c:	1000171e 	bne	r2,zero,8111499c <vParserCommTask+0x12c>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81114940:	01204574 	movhi	r4,33045
81114944:	21150f04 	addi	r4,r4,21564
81114948:	11158300 	call	81115830 <getPreParsedPacket>
8111494c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81114950:	e0bfdd17 	ldw	r2,-140(fp)
81114954:	10800058 	cmpnei	r2,r2,1
81114958:	10000e1e 	bne	r2,zero,81114994 <vParserCommTask+0x124>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8111495c:	00a04574 	movhi	r2,33045
81114960:	10950f04 	addi	r2,r2,21564
81114964:	10800103 	ldbu	r2,4(r2)
81114968:	10803fcc 	andi	r2,r2,255
8111496c:	1080201c 	xori	r2,r2,128
81114970:	10bfe004 	addi	r2,r2,-128
81114974:	10800858 	cmpnei	r2,r2,33
81114978:	1000031e 	bne	r2,zero,81114988 <vParserCommTask+0x118>
							eParserMode = sReplyParsing;
8111497c:	008000c4 	movi	r2,3
81114980:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81114984:	0003a906 	br	8111582c <vParserCommTask+0xfbc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81114988:	00800084 	movi	r2,2
8111498c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81114990:	0003a606 	br	8111582c <vParserCommTask+0xfbc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81114994:	111de140 	call	8111de14 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81114998:	0003a406 	br	8111582c <vParserCommTask+0xfbc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8111499c:	111dd140 	call	8111dd14 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
811149a0:	0003a206 	br	8111582c <vParserCommTask+0xfbc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
811149a4:	00a04574 	movhi	r2,33045
811149a8:	10950f04 	addi	r2,r2,21564
811149ac:	10800143 	ldbu	r2,5(r2)
811149b0:	10803fcc 	andi	r2,r2,255
811149b4:	1080201c 	xori	r2,r2,128
811149b8:	10bfe004 	addi	r2,r2,-128
811149bc:	10c010e0 	cmpeqi	r3,r2,67
811149c0:	1800031e 	bne	r3,zero,811149d0 <vParserCommTask+0x160>
811149c4:	10801420 	cmpeqi	r2,r2,80
811149c8:	1000051e 	bne	r2,zero,811149e0 <vParserCommTask+0x170>
811149cc:	00005006 	br	81114b10 <vParserCommTask+0x2a0>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
811149d0:	111a7940 	call	8111a794 <vSendEthConf>
						eParserMode = sWaitingMessage;
811149d4:	00800044 	movi	r2,1
811149d8:	e0bfdc15 	stw	r2,-144(fp)
						break;
811149dc:	00004f06 	br	81114b1c <vParserCommTask+0x2ac>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#if DEBUG_ON
                    	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811149e0:	00a045f4 	movhi	r2,33047
811149e4:	10a34f04 	addi	r2,r2,-29380
811149e8:	10800a8b 	ldhu	r2,42(r2)
811149ec:	10bfffcc 	andi	r2,r2,65535
811149f0:	108000e8 	cmpgeui	r2,r2,3
811149f4:	1000281e 	bne	r2,zero,81114a98 <vParserCommTask+0x228>
							memset(cPUSDebug,0,128);
811149f8:	e0bfdec4 	addi	r2,fp,-133
811149fc:	01802004 	movi	r6,128
81114a00:	000b883a 	mov	r5,zero
81114a04:	1009883a 	mov	r4,r2
81114a08:	11248500 	call	81124850 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81114a0c:	00a04574 	movhi	r2,33045
81114a10:	10950f04 	addi	r2,r2,21564
81114a14:	1080028b 	ldhu	r2,10(r2)
81114a18:	117fffcc 	andi	r5,r2,65535
81114a1c:	00a04574 	movhi	r2,33045
81114a20:	10950f04 	addi	r2,r2,21564
81114a24:	1080030b 	ldhu	r2,12(r2)
81114a28:	11bfffcc 	andi	r6,r2,65535
81114a2c:	00a04574 	movhi	r2,33045
81114a30:	10950f04 	addi	r2,r2,21564
81114a34:	1080038b 	ldhu	r2,14(r2)
81114a38:	10ffffcc 	andi	r3,r2,65535
81114a3c:	00a04574 	movhi	r2,33045
81114a40:	10950f04 	addi	r2,r2,21564
81114a44:	1080040b 	ldhu	r2,16(r2)
81114a48:	113fffcc 	andi	r4,r2,65535
81114a4c:	00a04574 	movhi	r2,33045
81114a50:	10950f04 	addi	r2,r2,21564
81114a54:	1080048b 	ldhu	r2,18(r2)
81114a58:	10bfffcc 	andi	r2,r2,65535
81114a5c:	e23fdec4 	addi	r8,fp,-133
81114a60:	d8800215 	stw	r2,8(sp)
81114a64:	d9000115 	stw	r4,4(sp)
81114a68:	d8c00015 	stw	r3,0(sp)
81114a6c:	300f883a 	mov	r7,r6
81114a70:	280d883a 	mov	r6,r5
81114a74:	01604574 	movhi	r5,33045
81114a78:	297e4404 	addi	r5,r5,-1776
81114a7c:	4009883a 	mov	r4,r8
81114a80:	1124f640 	call	81124f64 <sprintf>
							debug(fp, cPUSDebug );
81114a84:	d0a06217 	ldw	r2,-32376(gp)
81114a88:	e0ffdec4 	addi	r3,fp,-133
81114a8c:	180b883a 	mov	r5,r3
81114a90:	1009883a 	mov	r4,r2
81114a94:	11236500 	call	81123650 <fprintf>
                    	}
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81114a98:	00a04574 	movhi	r2,33045
81114a9c:	10950f04 	addi	r2,r2,21564
81114aa0:	10c0030b 	ldhu	r3,12(r2)
81114aa4:	00a04574 	movhi	r2,33045
81114aa8:	10952204 	addi	r2,r2,21640
81114aac:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81114ab0:	00a04574 	movhi	r2,33045
81114ab4:	10950f04 	addi	r2,r2,21564
81114ab8:	10c0038b 	ldhu	r3,14(r2)
81114abc:	00a04574 	movhi	r2,33045
81114ac0:	10952204 	addi	r2,r2,21640
81114ac4:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81114ac8:	00a04574 	movhi	r2,33045
81114acc:	10950f04 	addi	r2,r2,21564
81114ad0:	10c0040b 	ldhu	r3,16(r2)
81114ad4:	00a04574 	movhi	r2,33045
81114ad8:	10952204 	addi	r2,r2,21640
81114adc:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81114ae0:	00a04574 	movhi	r2,33045
81114ae4:	10950f04 	addi	r2,r2,21564
81114ae8:	10c0048b 	ldhu	r3,18(r2)
81114aec:	00a04574 	movhi	r2,33045
81114af0:	10952204 	addi	r2,r2,21640
81114af4:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81114af8:	00a04574 	movhi	r2,33045
81114afc:	10952204 	addi	r2,r2,21640
81114b00:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81114b04:	00800104 	movi	r2,4
81114b08:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81114b0c:	00000306 	br	81114b1c <vParserCommTask+0x2ac>
					default:
						eParserMode = sWaitingMessage;
81114b10:	00800044 	movi	r2,1
81114b14:	e0bfdc15 	stw	r2,-144(fp)
						break;
81114b18:	0001883a 	nop
				}
				break;
81114b1c:	00034306 	br	8111582c <vParserCommTask+0xfbc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81114b20:	00800044 	movi	r2,1
81114b24:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81114b28:	00a04574 	movhi	r2,33045
81114b2c:	10952204 	addi	r2,r2,21640
81114b30:	1080030b 	ldhu	r2,12(r2)
81114b34:	10bfffcc 	andi	r2,r2,65535
81114b38:	10c01220 	cmpeqi	r3,r2,72
81114b3c:	1800051e 	bne	r3,zero,81114b54 <vParserCommTask+0x2e4>
81114b40:	108014e0 	cmpeqi	r2,r2,83
81114b44:	1000051e 	bne	r2,zero,81114b5c <vParserCommTask+0x2ec>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81114b48:	00800044 	movi	r2,1
81114b4c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81114b50:	00000306 	br	81114b60 <vParserCommTask+0x2f0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81114b54:	0001883a 	nop
81114b58:	00033406 	br	8111582c <vParserCommTask+0xfbc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81114b5c:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81114b60:	00033206 	br	8111582c <vParserCommTask+0xfbc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81114b64:	00800044 	movi	r2,1
81114b68:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
81114b6c:	00a04574 	movhi	r2,33045
81114b70:	10952204 	addi	r2,r2,21640
81114b74:	1080030b 	ldhu	r2,12(r2)
81114b78:	10bfffcc 	andi	r2,r2,65535
81114b7c:	10c03ea0 	cmpeqi	r3,r2,250
81114b80:	18004c1e 	bne	r3,zero,81114cb4 <vParserCommTask+0x444>
81114b84:	10c03ec8 	cmpgei	r3,r2,251
81114b88:	1800031e 	bne	r3,zero,81114b98 <vParserCommTask+0x328>
81114b8c:	10800460 	cmpeqi	r2,r2,17
81114b90:	1000061e 	bne	r2,zero,81114bac <vParserCommTask+0x33c>
81114b94:	00031d06 	br	8111580c <vParserCommTask+0xf9c>
81114b98:	10c03ee0 	cmpeqi	r3,r2,251
81114b9c:	1800c71e 	bne	r3,zero,81114ebc <vParserCommTask+0x64c>
81114ba0:	10803f20 	cmpeqi	r2,r2,252
81114ba4:	10017a1e 	bne	r2,zero,81115190 <vParserCommTask+0x920>
81114ba8:	00031806 	br	8111580c <vParserCommTask+0xf9c>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81114bac:	00a04574 	movhi	r2,33045
81114bb0:	10952204 	addi	r2,r2,21640
81114bb4:	1080038b 	ldhu	r2,14(r2)
81114bb8:	10bfffcc 	andi	r2,r2,65535
81114bbc:	10800060 	cmpeqi	r2,r2,1
81114bc0:	10001426 	beq	r2,zero,81114c14 <vParserCommTask+0x3a4>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81114bc4:	00a045f4 	movhi	r2,33047
81114bc8:	10a34f04 	addi	r2,r2,-29380
81114bcc:	10800a8b 	ldhu	r2,42(r2)
81114bd0:	10bfffcc 	andi	r2,r2,65535
81114bd4:	10800168 	cmpgeui	r2,r2,5
81114bd8:	1000071e 	bne	r2,zero,81114bf8 <vParserCommTask+0x388>
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81114bdc:	d0a06217 	ldw	r2,-32376(gp)
81114be0:	100f883a 	mov	r7,r2
81114be4:	01800944 	movi	r6,37
81114be8:	01400044 	movi	r5,1
81114bec:	01204574 	movhi	r4,33045
81114bf0:	213e5a04 	addi	r4,r4,-1688
81114bf4:	1123cec0 	call	81123cec <fwrite>
								}
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81114bf8:	00a04574 	movhi	r2,33045
81114bfc:	10952204 	addi	r2,r2,21640
81114c00:	1080040b 	ldhu	r2,16(r2)
81114c04:	10bfffcc 	andi	r2,r2,65535
81114c08:	1009883a 	mov	r4,r2
81114c0c:	111b1940 	call	8111b194 <vTMPusTestConnection>

								break;
81114c10:	00002706 	br	81114cb0 <vParserCommTask+0x440>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114c14:	00a045f4 	movhi	r2,33047
81114c18:	10a34f04 	addi	r2,r2,-29380
81114c1c:	10800a8b 	ldhu	r2,42(r2)
81114c20:	10bfffcc 	andi	r2,r2,65535
81114c24:	108000e8 	cmpgeui	r2,r2,3
81114c28:	10001e1e 	bne	r2,zero,81114ca4 <vParserCommTask+0x434>
									memset(cPUSDebug,0,128);
81114c2c:	e0bfdec4 	addi	r2,fp,-133
81114c30:	01802004 	movi	r6,128
81114c34:	000b883a 	mov	r5,zero
81114c38:	1009883a 	mov	r4,r2
81114c3c:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114c40:	00a04574 	movhi	r2,33045
81114c44:	10952204 	addi	r2,r2,21640
81114c48:	1080030b 	ldhu	r2,12(r2)
81114c4c:	113fffcc 	andi	r4,r2,65535
81114c50:	00a04574 	movhi	r2,33045
81114c54:	10952204 	addi	r2,r2,21640
81114c58:	1080038b 	ldhu	r2,14(r2)
81114c5c:	117fffcc 	andi	r5,r2,65535
81114c60:	00a04574 	movhi	r2,33045
81114c64:	10952204 	addi	r2,r2,21640
81114c68:	1080040b 	ldhu	r2,16(r2)
81114c6c:	10bfffcc 	andi	r2,r2,65535
81114c70:	e0ffdec4 	addi	r3,fp,-133
81114c74:	d8800015 	stw	r2,0(sp)
81114c78:	280f883a 	mov	r7,r5
81114c7c:	200d883a 	mov	r6,r4
81114c80:	01604574 	movhi	r5,33045
81114c84:	297e6404 	addi	r5,r5,-1648
81114c88:	1809883a 	mov	r4,r3
81114c8c:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81114c90:	d0a06217 	ldw	r2,-32376(gp)
81114c94:	e0ffdec4 	addi	r3,fp,-133
81114c98:	180b883a 	mov	r5,r3
81114c9c:	1009883a 	mov	r4,r2
81114ca0:	11236500 	call	81123650 <fprintf>
								}
								#endif
								eParserMode = sWaitingMessage;
81114ca4:	00800044 	movi	r2,1
81114ca8:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114cac:	0001883a 	nop
						}
                        break;
81114cb0:	0002da06 	br	8111581c <vParserCommTask+0xfac>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
81114cb4:	00a04574 	movhi	r2,33045
81114cb8:	10952204 	addi	r2,r2,21640
81114cbc:	1080038b 	ldhu	r2,14(r2)
81114cc0:	10bfffcc 	andi	r2,r2,65535
81114cc4:	10c00f20 	cmpeqi	r3,r2,60
81114cc8:	1800201e 	bne	r3,zero,81114d4c <vParserCommTask+0x4dc>
81114ccc:	10c00f48 	cmpgei	r3,r2,61
81114cd0:	1800031e 	bne	r3,zero,81114ce0 <vParserCommTask+0x470>
81114cd4:	10800ee0 	cmpeqi	r2,r2,59
81114cd8:	1000061e 	bne	r2,zero,81114cf4 <vParserCommTask+0x484>
81114cdc:	00004f06 	br	81114e1c <vParserCommTask+0x5ac>
81114ce0:	10c00f60 	cmpeqi	r3,r2,61
81114ce4:	18002a1e 	bne	r3,zero,81114d90 <vParserCommTask+0x520>
81114ce8:	10800fa0 	cmpeqi	r2,r2,62
81114cec:	1000391e 	bne	r2,zero,81114dd4 <vParserCommTask+0x564>
81114cf0:	00004a06 	br	81114e1c <vParserCommTask+0x5ac>
						{
							case 59: /* TC_SCAM_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114cf4:	00a045f4 	movhi	r2,33047
81114cf8:	10a34f04 	addi	r2,r2,-29380
81114cfc:	10800a8b 	ldhu	r2,42(r2)
81114d00:	10bfffcc 	andi	r2,r2,65535
81114d04:	108000e8 	cmpgeui	r2,r2,3
81114d08:	1000071e 	bne	r2,zero,81114d28 <vParserCommTask+0x4b8>
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
81114d0c:	d0a06217 	ldw	r2,-32376(gp)
81114d10:	100f883a 	mov	r7,r2
81114d14:	018006c4 	movi	r6,27
81114d18:	01400044 	movi	r5,1
81114d1c:	01204574 	movhi	r4,33045
81114d20:	213e7704 	addi	r4,r4,-1572
81114d24:	1123cec0 	call	81123cec <fwrite>
								}
								#endif
								vSendReset();
81114d28:	111ab3c0 	call	8111ab3c <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
81114d2c:	000f883a 	mov	r7,zero
81114d30:	018000c4 	movi	r6,3
81114d34:	000b883a 	mov	r5,zero
81114d38:	0009883a 	mov	r4,zero
81114d3c:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81114d40:	0104e204 	movi	r4,5000
81114d44:	110cdf00 	call	8110cdf0 <vRstcSimucamReset>

								break;
81114d48:	00005b06 	br	81114eb8 <vParserCommTask+0x648>
							case 60: /* TC_SCAM_CONFIG */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114d4c:	00a045f4 	movhi	r2,33047
81114d50:	10a34f04 	addi	r2,r2,-29380
81114d54:	10800a8b 	ldhu	r2,42(r2)
81114d58:	10bfffcc 	andi	r2,r2,65535
81114d5c:	108000e8 	cmpgeui	r2,r2,3
81114d60:	1000071e 	bne	r2,zero,81114d80 <vParserCommTask+0x510>
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81114d64:	d0a06217 	ldw	r2,-32376(gp)
81114d68:	100f883a 	mov	r7,r2
81114d6c:	01800704 	movi	r6,28
81114d70:	01400044 	movi	r5,1
81114d74:	01204574 	movhi	r4,33045
81114d78:	213e7e04 	addi	r4,r4,-1544
81114d7c:	1123cec0 	call	81123cec <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114d80:	01204574 	movhi	r4,33045
81114d84:	21152204 	addi	r4,r4,21640
81114d88:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

								break;
81114d8c:	00004a06 	br	81114eb8 <vParserCommTask+0x648>
							case 61: /* TC_SCAM_RUN */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114d90:	00a045f4 	movhi	r2,33047
81114d94:	10a34f04 	addi	r2,r2,-29380
81114d98:	10800a8b 	ldhu	r2,42(r2)
81114d9c:	10bfffcc 	andi	r2,r2,65535
81114da0:	108000e8 	cmpgeui	r2,r2,3
81114da4:	1000071e 	bne	r2,zero,81114dc4 <vParserCommTask+0x554>
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81114da8:	d0a06217 	ldw	r2,-32376(gp)
81114dac:	100f883a 	mov	r7,r2
81114db0:	01800644 	movi	r6,25
81114db4:	01400044 	movi	r5,1
81114db8:	01204574 	movhi	r4,33045
81114dbc:	213e8604 	addi	r4,r4,-1512
81114dc0:	1123cec0 	call	81123cec <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114dc4:	01204574 	movhi	r4,33045
81114dc8:	21152204 	addi	r4,r4,21640
81114dcc:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

								break;
81114dd0:	00003906 	br	81114eb8 <vParserCommTask+0x648>
							case 62: /* TC_SCAM_TURNOFF */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114dd4:	00a045f4 	movhi	r2,33047
81114dd8:	10a34f04 	addi	r2,r2,-29380
81114ddc:	10800a8b 	ldhu	r2,42(r2)
81114de0:	10bfffcc 	andi	r2,r2,65535
81114de4:	108000e8 	cmpgeui	r2,r2,3
81114de8:	1000071e 	bne	r2,zero,81114e08 <vParserCommTask+0x598>
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81114dec:	d0a06217 	ldw	r2,-32376(gp)
81114df0:	100f883a 	mov	r7,r2
81114df4:	01800744 	movi	r6,29
81114df8:	01400044 	movi	r5,1
81114dfc:	01204574 	movhi	r4,33045
81114e00:	213e8d04 	addi	r4,r4,-1484
81114e04:	1123cec0 	call	81123cec <fwrite>
								}
								#endif
								vSendTurnOff();
81114e08:	111aa240 	call	8111aa24 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81114e0c:	01204574 	movhi	r4,33045
81114e10:	21152204 	addi	r4,r4,21640
81114e14:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

								break;
81114e18:	00002706 	br	81114eb8 <vParserCommTask+0x648>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114e1c:	00a045f4 	movhi	r2,33047
81114e20:	10a34f04 	addi	r2,r2,-29380
81114e24:	10800a8b 	ldhu	r2,42(r2)
81114e28:	10bfffcc 	andi	r2,r2,65535
81114e2c:	108000e8 	cmpgeui	r2,r2,3
81114e30:	10001e1e 	bne	r2,zero,81114eac <vParserCommTask+0x63c>
									memset(cPUSDebug,0,128);
81114e34:	e0bfdec4 	addi	r2,fp,-133
81114e38:	01802004 	movi	r6,128
81114e3c:	000b883a 	mov	r5,zero
81114e40:	1009883a 	mov	r4,r2
81114e44:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114e48:	00a04574 	movhi	r2,33045
81114e4c:	10952204 	addi	r2,r2,21640
81114e50:	1080030b 	ldhu	r2,12(r2)
81114e54:	113fffcc 	andi	r4,r2,65535
81114e58:	00a04574 	movhi	r2,33045
81114e5c:	10952204 	addi	r2,r2,21640
81114e60:	1080038b 	ldhu	r2,14(r2)
81114e64:	117fffcc 	andi	r5,r2,65535
81114e68:	00a04574 	movhi	r2,33045
81114e6c:	10952204 	addi	r2,r2,21640
81114e70:	1080040b 	ldhu	r2,16(r2)
81114e74:	10bfffcc 	andi	r2,r2,65535
81114e78:	e0ffdec4 	addi	r3,fp,-133
81114e7c:	d8800015 	stw	r2,0(sp)
81114e80:	280f883a 	mov	r7,r5
81114e84:	200d883a 	mov	r6,r4
81114e88:	01604574 	movhi	r5,33045
81114e8c:	297e6404 	addi	r5,r5,-1648
81114e90:	1809883a 	mov	r4,r3
81114e94:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81114e98:	d0a06217 	ldw	r2,-32376(gp)
81114e9c:	e0ffdec4 	addi	r3,fp,-133
81114ea0:	180b883a 	mov	r5,r3
81114ea4:	1009883a 	mov	r4,r2
81114ea8:	11236500 	call	81123650 <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
81114eac:	00800044 	movi	r2,1
81114eb0:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114eb4:	0001883a 	nop
						}
                        break;
81114eb8:	00025806 	br	8111581c <vParserCommTask+0xfac>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81114ebc:	00a04574 	movhi	r2,33045
81114ec0:	10950f04 	addi	r2,r2,21564
81114ec4:	1080050b 	ldhu	r2,20(r2)
81114ec8:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
81114ecc:	e0bfde0b 	ldhu	r2,-136(fp)
81114ed0:	108000b0 	cmpltui	r2,r2,2
81114ed4:	1000181e 	bne	r2,zero,81114f38 <vParserCommTask+0x6c8>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114ed8:	00a045f4 	movhi	r2,33047
81114edc:	10a34f04 	addi	r2,r2,-29380
81114ee0:	10800a8b 	ldhu	r2,42(r2)
81114ee4:	10bfffcc 	andi	r2,r2,65535
81114ee8:	108000e8 	cmpgeui	r2,r2,3
81114eec:	10024a1e 	bne	r2,zero,81115818 <vParserCommTask+0xfa8>
								memset(cPUSDebug,0,128);
81114ef0:	e0bfdec4 	addi	r2,fp,-133
81114ef4:	01802004 	movi	r6,128
81114ef8:	000b883a 	mov	r5,zero
81114efc:	1009883a 	mov	r4,r2
81114f00:	11248500 	call	81124850 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81114f04:	e0ffde0b 	ldhu	r3,-136(fp)
81114f08:	e0bfdec4 	addi	r2,fp,-133
81114f0c:	180d883a 	mov	r6,r3
81114f10:	01604574 	movhi	r5,33045
81114f14:	297e9504 	addi	r5,r5,-1452
81114f18:	1009883a 	mov	r4,r2
81114f1c:	1124f640 	call	81124f64 <sprintf>
								debug(fp, cPUSDebug );
81114f20:	d0a06217 	ldw	r2,-32376(gp)
81114f24:	e0ffdec4 	addi	r3,fp,-133
81114f28:	180b883a 	mov	r5,r3
81114f2c:	1009883a 	mov	r4,r2
81114f30:	11236500 	call	81123650 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81114f34:	00023806 	br	81115818 <vParserCommTask+0xfa8>
								debug(fp, cPUSDebug );
							}
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81114f38:	00a04574 	movhi	r2,33045
81114f3c:	10952204 	addi	r2,r2,21640
81114f40:	10800483 	ldbu	r2,18(r2)
81114f44:	10c03fcc 	andi	r3,r2,255
81114f48:	00a04574 	movhi	r2,33045
81114f4c:	10952204 	addi	r2,r2,21640
81114f50:	18c00284 	addi	r3,r3,10
81114f54:	18c7883a 	add	r3,r3,r3
81114f58:	10c5883a 	add	r2,r2,r3
81114f5c:	e0ffde0b 	ldhu	r3,-136(fp)
81114f60:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81114f64:	00a04574 	movhi	r2,33045
81114f68:	10952204 	addi	r2,r2,21640
81114f6c:	10800483 	ldbu	r2,18(r2)
81114f70:	10800044 	addi	r2,r2,1
81114f74:	1007883a 	mov	r3,r2
81114f78:	00a04574 	movhi	r2,33045
81114f7c:	10952204 	addi	r2,r2,21640
81114f80:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81114f84:	00a04574 	movhi	r2,33045
81114f88:	10952204 	addi	r2,r2,21640
81114f8c:	1080038b 	ldhu	r2,14(r2)
81114f90:	10bfffcc 	andi	r2,r2,65535
81114f94:	10c000a0 	cmpeqi	r3,r2,2
81114f98:	18001f1e 	bne	r3,zero,81115018 <vParserCommTask+0x7a8>
81114f9c:	10c00160 	cmpeqi	r3,r2,5
81114fa0:	1800381e 	bne	r3,zero,81115084 <vParserCommTask+0x814>
81114fa4:	10800060 	cmpeqi	r2,r2,1
81114fa8:	10005126 	beq	r2,zero,811150f0 <vParserCommTask+0x880>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114fac:	00a045f4 	movhi	r2,33047
81114fb0:	10a34f04 	addi	r2,r2,-29380
81114fb4:	10800a8b 	ldhu	r2,42(r2)
81114fb8:	10bfffcc 	andi	r2,r2,65535
81114fbc:	108000e8 	cmpgeui	r2,r2,3
81114fc0:	1000111e 	bne	r2,zero,81115008 <vParserCommTask+0x798>
										memset(cPUSDebug,0,128);
81114fc4:	e0bfdec4 	addi	r2,fp,-133
81114fc8:	01802004 	movi	r6,128
81114fcc:	000b883a 	mov	r5,zero
81114fd0:	1009883a 	mov	r4,r2
81114fd4:	11248500 	call	81124850 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114fd8:	e0ffde0b 	ldhu	r3,-136(fp)
81114fdc:	e0bfdec4 	addi	r2,fp,-133
81114fe0:	180d883a 	mov	r6,r3
81114fe4:	01604574 	movhi	r5,33045
81114fe8:	297ea404 	addi	r5,r5,-1392
81114fec:	1009883a 	mov	r4,r2
81114ff0:	1124f640 	call	81124f64 <sprintf>
										debug(fp, cPUSDebug );
81114ff4:	d0a06217 	ldw	r2,-32376(gp)
81114ff8:	e0ffdec4 	addi	r3,fp,-133
81114ffc:	180b883a 	mov	r5,r3
81115000:	1009883a 	mov	r4,r2
81115004:	11236500 	call	81123650 <fprintf>
									}
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81115008:	01204574 	movhi	r4,33045
8111500c:	21152204 	addi	r4,r4,21640
81115010:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

									break;
81115014:	00005d06 	br	8111518c <vParserCommTask+0x91c>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115018:	00a045f4 	movhi	r2,33047
8111501c:	10a34f04 	addi	r2,r2,-29380
81115020:	10800a8b 	ldhu	r2,42(r2)
81115024:	10bfffcc 	andi	r2,r2,65535
81115028:	108000e8 	cmpgeui	r2,r2,3
8111502c:	1000111e 	bne	r2,zero,81115074 <vParserCommTask+0x804>
										memset(cPUSDebug,0,128);
81115030:	e0bfdec4 	addi	r2,fp,-133
81115034:	01802004 	movi	r6,128
81115038:	000b883a 	mov	r5,zero
8111503c:	1009883a 	mov	r4,r2
81115040:	11248500 	call	81124850 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81115044:	e0ffde0b 	ldhu	r3,-136(fp)
81115048:	e0bfdec4 	addi	r2,fp,-133
8111504c:	180d883a 	mov	r6,r3
81115050:	01604574 	movhi	r5,33045
81115054:	297eb404 	addi	r5,r5,-1328
81115058:	1009883a 	mov	r4,r2
8111505c:	1124f640 	call	81124f64 <sprintf>
										debug(fp, cPUSDebug );
81115060:	d0a06217 	ldw	r2,-32376(gp)
81115064:	e0ffdec4 	addi	r3,fp,-133
81115068:	180b883a 	mov	r5,r3
8111506c:	1009883a 	mov	r4,r2
81115070:	11236500 	call	81123650 <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81115074:	01204574 	movhi	r4,33045
81115078:	21152204 	addi	r4,r4,21640
8111507c:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

									break;
81115080:	00004206 	br	8111518c <vParserCommTask+0x91c>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115084:	00a045f4 	movhi	r2,33047
81115088:	10a34f04 	addi	r2,r2,-29380
8111508c:	10800a8b 	ldhu	r2,42(r2)
81115090:	10bfffcc 	andi	r2,r2,65535
81115094:	108000e8 	cmpgeui	r2,r2,3
81115098:	1000111e 	bne	r2,zero,811150e0 <vParserCommTask+0x870>
										memset(cPUSDebug,0,128);
8111509c:	e0bfdec4 	addi	r2,fp,-133
811150a0:	01802004 	movi	r6,128
811150a4:	000b883a 	mov	r5,zero
811150a8:	1009883a 	mov	r4,r2
811150ac:	11248500 	call	81124850 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811150b0:	e0ffde0b 	ldhu	r3,-136(fp)
811150b4:	e0bfdec4 	addi	r2,fp,-133
811150b8:	180d883a 	mov	r6,r3
811150bc:	01604574 	movhi	r5,33045
811150c0:	297ec404 	addi	r5,r5,-1264
811150c4:	1009883a 	mov	r4,r2
811150c8:	1124f640 	call	81124f64 <sprintf>
										debug(fp, cPUSDebug );
811150cc:	d0a06217 	ldw	r2,-32376(gp)
811150d0:	e0ffdec4 	addi	r3,fp,-133
811150d4:	180b883a 	mov	r5,r3
811150d8:	1009883a 	mov	r4,r2
811150dc:	11236500 	call	81123650 <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811150e0:	01204574 	movhi	r4,33045
811150e4:	21152204 	addi	r4,r4,21640
811150e8:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

									break;
811150ec:	00002706 	br	8111518c <vParserCommTask+0x91c>
								default:
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811150f0:	00a045f4 	movhi	r2,33047
811150f4:	10a34f04 	addi	r2,r2,-29380
811150f8:	10800a8b 	ldhu	r2,42(r2)
811150fc:	10bfffcc 	andi	r2,r2,65535
81115100:	108000e8 	cmpgeui	r2,r2,3
81115104:	10001e1e 	bne	r2,zero,81115180 <vParserCommTask+0x910>
										memset(cPUSDebug,0,128);
81115108:	e0bfdec4 	addi	r2,fp,-133
8111510c:	01802004 	movi	r6,128
81115110:	000b883a 	mov	r5,zero
81115114:	1009883a 	mov	r4,r2
81115118:	11248500 	call	81124850 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8111511c:	00a04574 	movhi	r2,33045
81115120:	10952204 	addi	r2,r2,21640
81115124:	1080030b 	ldhu	r2,12(r2)
81115128:	113fffcc 	andi	r4,r2,65535
8111512c:	00a04574 	movhi	r2,33045
81115130:	10952204 	addi	r2,r2,21640
81115134:	1080038b 	ldhu	r2,14(r2)
81115138:	117fffcc 	andi	r5,r2,65535
8111513c:	00a04574 	movhi	r2,33045
81115140:	10952204 	addi	r2,r2,21640
81115144:	1080040b 	ldhu	r2,16(r2)
81115148:	10bfffcc 	andi	r2,r2,65535
8111514c:	e0ffdec4 	addi	r3,fp,-133
81115150:	d8800015 	stw	r2,0(sp)
81115154:	280f883a 	mov	r7,r5
81115158:	200d883a 	mov	r6,r4
8111515c:	01604574 	movhi	r5,33045
81115160:	297e6404 	addi	r5,r5,-1648
81115164:	1809883a 	mov	r4,r3
81115168:	1124f640 	call	81124f64 <sprintf>
										debug(fp, cPUSDebug );
8111516c:	d0a06217 	ldw	r2,-32376(gp)
81115170:	e0ffdec4 	addi	r3,fp,-133
81115174:	180b883a 	mov	r5,r3
81115178:	1009883a 	mov	r4,r2
8111517c:	11236500 	call	81123650 <fprintf>
									}
									#endif							
									eParserMode = sWaitingMessage;
81115180:	00800044 	movi	r2,1
81115184:	e0bfdc15 	stw	r2,-144(fp)
									break;
81115188:	0001883a 	nop
							}
						}
                        break;
8111518c:	0001a206 	br	81115818 <vParserCommTask+0xfa8>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81115190:	00a04574 	movhi	r2,33045
81115194:	10950f04 	addi	r2,r2,21564
81115198:	1080050b 	ldhu	r2,20(r2)
8111519c:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811151a0:	00a04574 	movhi	r2,33045
811151a4:	10952204 	addi	r2,r2,21640
811151a8:	10800483 	ldbu	r2,18(r2)
811151ac:	10c03fcc 	andi	r3,r2,255
811151b0:	00a04574 	movhi	r2,33045
811151b4:	10952204 	addi	r2,r2,21640
811151b8:	18c00284 	addi	r3,r3,10
811151bc:	18c7883a 	add	r3,r3,r3
811151c0:	10c5883a 	add	r2,r2,r3
811151c4:	e0ffde0b 	ldhu	r3,-136(fp)
811151c8:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
811151cc:	00a04574 	movhi	r2,33045
811151d0:	10952204 	addi	r2,r2,21640
811151d4:	10800483 	ldbu	r2,18(r2)
811151d8:	10800044 	addi	r2,r2,1
811151dc:	1007883a 	mov	r3,r2
811151e0:	00a04574 	movhi	r2,33045
811151e4:	10952204 	addi	r2,r2,21640
811151e8:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811151ec:	00a04574 	movhi	r2,33045
811151f0:	10952204 	addi	r2,r2,21640
811151f4:	1080038b 	ldhu	r2,14(r2)
811151f8:	10bfffcc 	andi	r2,r2,65535
811151fc:	10c000e0 	cmpeqi	r3,r2,3
81115200:	18000a1e 	bne	r3,zero,8111522c <vParserCommTask+0x9bc>
81115204:	10c00108 	cmpgei	r3,r2,4
81115208:	1800031e 	bne	r3,zero,81115218 <vParserCommTask+0x9a8>
8111520c:	108000a0 	cmpeqi	r2,r2,2
81115210:	1000571e 	bne	r2,zero,81115370 <vParserCommTask+0xb00>
81115214:	00015406 	br	81115768 <vParserCommTask+0xef8>
81115218:	10c00120 	cmpeqi	r3,r2,4
8111521c:	18001e1e 	bne	r3,zero,81115298 <vParserCommTask+0xa28>
81115220:	10800160 	cmpeqi	r2,r2,5
81115224:	1000371e 	bne	r2,zero,81115304 <vParserCommTask+0xa94>
81115228:	00014f06 	br	81115768 <vParserCommTask+0xef8>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111522c:	00a045f4 	movhi	r2,33047
81115230:	10a34f04 	addi	r2,r2,-29380
81115234:	10800a8b 	ldhu	r2,42(r2)
81115238:	10bfffcc 	andi	r2,r2,65535
8111523c:	108000e8 	cmpgeui	r2,r2,3
81115240:	1000111e 	bne	r2,zero,81115288 <vParserCommTask+0xa18>
									memset(cPUSDebug,0,128);
81115244:	e0bfdec4 	addi	r2,fp,-133
81115248:	01802004 	movi	r6,128
8111524c:	000b883a 	mov	r5,zero
81115250:	1009883a 	mov	r4,r2
81115254:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81115258:	e0ffde0b 	ldhu	r3,-136(fp)
8111525c:	e0bfdec4 	addi	r2,fp,-133
81115260:	180d883a 	mov	r6,r3
81115264:	01604574 	movhi	r5,33045
81115268:	297ed604 	addi	r5,r5,-1192
8111526c:	1009883a 	mov	r4,r2
81115270:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81115274:	d0a06217 	ldw	r2,-32376(gp)
81115278:	e0ffdec4 	addi	r3,fp,-133
8111527c:	180b883a 	mov	r5,r3
81115280:	1009883a 	mov	r4,r2
81115284:	11236500 	call	81123650 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81115288:	01204574 	movhi	r4,33045
8111528c:	21152204 	addi	r4,r4,21640
81115290:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

								break;
81115294:	00015c06 	br	81115808 <vParserCommTask+0xf98>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115298:	00a045f4 	movhi	r2,33047
8111529c:	10a34f04 	addi	r2,r2,-29380
811152a0:	10800a8b 	ldhu	r2,42(r2)
811152a4:	10bfffcc 	andi	r2,r2,65535
811152a8:	108000e8 	cmpgeui	r2,r2,3
811152ac:	1000111e 	bne	r2,zero,811152f4 <vParserCommTask+0xa84>
									memset(cPUSDebug,0,128);
811152b0:	e0bfdec4 	addi	r2,fp,-133
811152b4:	01802004 	movi	r6,128
811152b8:	000b883a 	mov	r5,zero
811152bc:	1009883a 	mov	r4,r2
811152c0:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811152c4:	e0ffde0b 	ldhu	r3,-136(fp)
811152c8:	e0bfdec4 	addi	r2,fp,-133
811152cc:	180d883a 	mov	r6,r3
811152d0:	01604574 	movhi	r5,33045
811152d4:	297ee604 	addi	r5,r5,-1128
811152d8:	1009883a 	mov	r4,r2
811152dc:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
811152e0:	d0a06217 	ldw	r2,-32376(gp)
811152e4:	e0ffdec4 	addi	r3,fp,-133
811152e8:	180b883a 	mov	r5,r3
811152ec:	1009883a 	mov	r4,r2
811152f0:	11236500 	call	81123650 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811152f4:	01204574 	movhi	r4,33045
811152f8:	21152204 	addi	r4,r4,21640
811152fc:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

								break;
81115300:	00014106 	br	81115808 <vParserCommTask+0xf98>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115304:	00a045f4 	movhi	r2,33047
81115308:	10a34f04 	addi	r2,r2,-29380
8111530c:	10800a8b 	ldhu	r2,42(r2)
81115310:	10bfffcc 	andi	r2,r2,65535
81115314:	108000e8 	cmpgeui	r2,r2,3
81115318:	1000111e 	bne	r2,zero,81115360 <vParserCommTask+0xaf0>
									memset(cPUSDebug,0,128);
8111531c:	e0bfdec4 	addi	r2,fp,-133
81115320:	01802004 	movi	r6,128
81115324:	000b883a 	mov	r5,zero
81115328:	1009883a 	mov	r4,r2
8111532c:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81115330:	e0ffde0b 	ldhu	r3,-136(fp)
81115334:	e0bfdec4 	addi	r2,fp,-133
81115338:	180d883a 	mov	r6,r3
8111533c:	01604574 	movhi	r5,33045
81115340:	297ef604 	addi	r5,r5,-1064
81115344:	1009883a 	mov	r4,r2
81115348:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
8111534c:	d0a06217 	ldw	r2,-32376(gp)
81115350:	e0ffdec4 	addi	r3,fp,-133
81115354:	180b883a 	mov	r5,r3
81115358:	1009883a 	mov	r4,r2
8111535c:	11236500 	call	81123650 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81115360:	01204574 	movhi	r4,33045
81115364:	21152204 	addi	r4,r4,21640
81115368:	11159480 	call	81115948 <bSendMessagePUStoMebTask>

								break;
8111536c:	00012606 	br	81115808 <vParserCommTask+0xf98>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81115370:	00a04574 	movhi	r2,33045
81115374:	10952204 	addi	r2,r2,21640
81115378:	10800483 	ldbu	r2,18(r2)
8111537c:	10c03fcc 	andi	r3,r2,255
81115380:	00a04574 	movhi	r2,33045
81115384:	10950f04 	addi	r2,r2,21564
81115388:	1100058b 	ldhu	r4,22(r2)
8111538c:	00a04574 	movhi	r2,33045
81115390:	10952204 	addi	r2,r2,21640
81115394:	18c00284 	addi	r3,r3,10
81115398:	18c7883a 	add	r3,r3,r3
8111539c:	10c5883a 	add	r2,r2,r3
811153a0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811153a4:	00a04574 	movhi	r2,33045
811153a8:	10952204 	addi	r2,r2,21640
811153ac:	10800483 	ldbu	r2,18(r2)
811153b0:	10800044 	addi	r2,r2,1
811153b4:	1007883a 	mov	r3,r2
811153b8:	00a04574 	movhi	r2,33045
811153bc:	10952204 	addi	r2,r2,21640
811153c0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
811153c4:	00a04574 	movhi	r2,33045
811153c8:	10952204 	addi	r2,r2,21640
811153cc:	10800483 	ldbu	r2,18(r2)
811153d0:	10c03fcc 	andi	r3,r2,255
811153d4:	00a04574 	movhi	r2,33045
811153d8:	10950f04 	addi	r2,r2,21564
811153dc:	1100060b 	ldhu	r4,24(r2)
811153e0:	00a04574 	movhi	r2,33045
811153e4:	10952204 	addi	r2,r2,21640
811153e8:	18c00284 	addi	r3,r3,10
811153ec:	18c7883a 	add	r3,r3,r3
811153f0:	10c5883a 	add	r2,r2,r3
811153f4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811153f8:	00a04574 	movhi	r2,33045
811153fc:	10952204 	addi	r2,r2,21640
81115400:	10800483 	ldbu	r2,18(r2)
81115404:	10800044 	addi	r2,r2,1
81115408:	1007883a 	mov	r3,r2
8111540c:	00a04574 	movhi	r2,33045
81115410:	10952204 	addi	r2,r2,21640
81115414:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81115418:	00a04574 	movhi	r2,33045
8111541c:	10952204 	addi	r2,r2,21640
81115420:	10800483 	ldbu	r2,18(r2)
81115424:	10c03fcc 	andi	r3,r2,255
81115428:	00a04574 	movhi	r2,33045
8111542c:	10950f04 	addi	r2,r2,21564
81115430:	1100068b 	ldhu	r4,26(r2)
81115434:	00a04574 	movhi	r2,33045
81115438:	10952204 	addi	r2,r2,21640
8111543c:	18c00284 	addi	r3,r3,10
81115440:	18c7883a 	add	r3,r3,r3
81115444:	10c5883a 	add	r2,r2,r3
81115448:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111544c:	00a04574 	movhi	r2,33045
81115450:	10952204 	addi	r2,r2,21640
81115454:	10800483 	ldbu	r2,18(r2)
81115458:	10800044 	addi	r2,r2,1
8111545c:	1007883a 	mov	r3,r2
81115460:	00a04574 	movhi	r2,33045
81115464:	10952204 	addi	r2,r2,21640
81115468:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8111546c:	00a04574 	movhi	r2,33045
81115470:	10952204 	addi	r2,r2,21640
81115474:	10800483 	ldbu	r2,18(r2)
81115478:	10c03fcc 	andi	r3,r2,255
8111547c:	00a04574 	movhi	r2,33045
81115480:	10950f04 	addi	r2,r2,21564
81115484:	1100070b 	ldhu	r4,28(r2)
81115488:	00a04574 	movhi	r2,33045
8111548c:	10952204 	addi	r2,r2,21640
81115490:	18c00284 	addi	r3,r3,10
81115494:	18c7883a 	add	r3,r3,r3
81115498:	10c5883a 	add	r2,r2,r3
8111549c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811154a0:	00a04574 	movhi	r2,33045
811154a4:	10952204 	addi	r2,r2,21640
811154a8:	10800483 	ldbu	r2,18(r2)
811154ac:	10800044 	addi	r2,r2,1
811154b0:	1007883a 	mov	r3,r2
811154b4:	00a04574 	movhi	r2,33045
811154b8:	10952204 	addi	r2,r2,21640
811154bc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
811154c0:	00a04574 	movhi	r2,33045
811154c4:	10952204 	addi	r2,r2,21640
811154c8:	10800483 	ldbu	r2,18(r2)
811154cc:	10c03fcc 	andi	r3,r2,255
811154d0:	00a04574 	movhi	r2,33045
811154d4:	10950f04 	addi	r2,r2,21564
811154d8:	1100078b 	ldhu	r4,30(r2)
811154dc:	00a04574 	movhi	r2,33045
811154e0:	10952204 	addi	r2,r2,21640
811154e4:	18c00284 	addi	r3,r3,10
811154e8:	18c7883a 	add	r3,r3,r3
811154ec:	10c5883a 	add	r2,r2,r3
811154f0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811154f4:	00a04574 	movhi	r2,33045
811154f8:	10952204 	addi	r2,r2,21640
811154fc:	10800483 	ldbu	r2,18(r2)
81115500:	10800044 	addi	r2,r2,1
81115504:	1007883a 	mov	r3,r2
81115508:	00a04574 	movhi	r2,33045
8111550c:	10952204 	addi	r2,r2,21640
81115510:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81115514:	00a04574 	movhi	r2,33045
81115518:	10952204 	addi	r2,r2,21640
8111551c:	10800483 	ldbu	r2,18(r2)
81115520:	10c03fcc 	andi	r3,r2,255
81115524:	00a04574 	movhi	r2,33045
81115528:	10950f04 	addi	r2,r2,21564
8111552c:	1100080b 	ldhu	r4,32(r2)
81115530:	00a04574 	movhi	r2,33045
81115534:	10952204 	addi	r2,r2,21640
81115538:	18c00284 	addi	r3,r3,10
8111553c:	18c7883a 	add	r3,r3,r3
81115540:	10c5883a 	add	r2,r2,r3
81115544:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81115548:	00a04574 	movhi	r2,33045
8111554c:	10952204 	addi	r2,r2,21640
81115550:	10800483 	ldbu	r2,18(r2)
81115554:	10800044 	addi	r2,r2,1
81115558:	1007883a 	mov	r3,r2
8111555c:	00a04574 	movhi	r2,33045
81115560:	10952204 	addi	r2,r2,21640
81115564:	10c00485 	stb	r3,18(r2)


								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115568:	00a045f4 	movhi	r2,33047
8111556c:	10a34f04 	addi	r2,r2,-29380
81115570:	10800a8b 	ldhu	r2,42(r2)
81115574:	10bfffcc 	andi	r2,r2,65535
81115578:	108000e8 	cmpgeui	r2,r2,3
8111557c:	1000a11e 	bne	r2,zero,81115804 <vParserCommTask+0xf94>
									memset(cPUSDebug,0,128);
81115580:	e0bfdec4 	addi	r2,fp,-133
81115584:	01802004 	movi	r6,128
81115588:	000b883a 	mov	r5,zero
8111558c:	1009883a 	mov	r4,r2
81115590:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81115594:	e0ffdec4 	addi	r3,fp,-133
81115598:	00a04574 	movhi	r2,33045
8111559c:	10bf0504 	addi	r2,r2,-1004
811155a0:	1009883a 	mov	r4,r2
811155a4:	00800b84 	movi	r2,46
811155a8:	100d883a 	mov	r6,r2
811155ac:	200b883a 	mov	r5,r4
811155b0:	1809883a 	mov	r4,r3
811155b4:	11247000 	call	81124700 <memcpy>
									debug(fp, cPUSDebug );
811155b8:	d0a06217 	ldw	r2,-32376(gp)
811155bc:	e0ffdec4 	addi	r3,fp,-133
811155c0:	180b883a 	mov	r5,r3
811155c4:	1009883a 	mov	r4,r2
811155c8:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
811155cc:	e0ffde0b 	ldhu	r3,-136(fp)
811155d0:	e0bfdec4 	addi	r2,fp,-133
811155d4:	180d883a 	mov	r6,r3
811155d8:	01604574 	movhi	r5,33045
811155dc:	297f1104 	addi	r5,r5,-956
811155e0:	1009883a 	mov	r4,r2
811155e4:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
811155e8:	d0a06217 	ldw	r2,-32376(gp)
811155ec:	e0ffdec4 	addi	r3,fp,-133
811155f0:	180b883a 	mov	r5,r3
811155f4:	1009883a 	mov	r4,r2
811155f8:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
811155fc:	00a04574 	movhi	r2,33045
81115600:	10950f04 	addi	r2,r2,21564
81115604:	1080058b 	ldhu	r2,22(r2)
81115608:	10ffffcc 	andi	r3,r2,65535
8111560c:	e0bfdec4 	addi	r2,fp,-133
81115610:	180d883a 	mov	r6,r3
81115614:	01604574 	movhi	r5,33045
81115618:	297f1804 	addi	r5,r5,-928
8111561c:	1009883a 	mov	r4,r2
81115620:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81115624:	d0a06217 	ldw	r2,-32376(gp)
81115628:	e0ffdec4 	addi	r3,fp,-133
8111562c:	180b883a 	mov	r5,r3
81115630:	1009883a 	mov	r4,r2
81115634:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81115638:	00a04574 	movhi	r2,33045
8111563c:	10950f04 	addi	r2,r2,21564
81115640:	1080060b 	ldhu	r2,24(r2)
81115644:	10ffffcc 	andi	r3,r2,65535
81115648:	e0bfdec4 	addi	r2,fp,-133
8111564c:	180d883a 	mov	r6,r3
81115650:	01604574 	movhi	r5,33045
81115654:	297f1c04 	addi	r5,r5,-912
81115658:	1009883a 	mov	r4,r2
8111565c:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81115660:	d0a06217 	ldw	r2,-32376(gp)
81115664:	e0ffdec4 	addi	r3,fp,-133
81115668:	180b883a 	mov	r5,r3
8111566c:	1009883a 	mov	r4,r2
81115670:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81115674:	00a04574 	movhi	r2,33045
81115678:	10950f04 	addi	r2,r2,21564
8111567c:	1080068b 	ldhu	r2,26(r2)
81115680:	10ffffcc 	andi	r3,r2,65535
81115684:	e0bfdec4 	addi	r2,fp,-133
81115688:	180d883a 	mov	r6,r3
8111568c:	01604574 	movhi	r5,33045
81115690:	297f2104 	addi	r5,r5,-892
81115694:	1009883a 	mov	r4,r2
81115698:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
8111569c:	d0a06217 	ldw	r2,-32376(gp)
811156a0:	e0ffdec4 	addi	r3,fp,-133
811156a4:	180b883a 	mov	r5,r3
811156a8:	1009883a 	mov	r4,r2
811156ac:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
811156b0:	00a04574 	movhi	r2,33045
811156b4:	10950f04 	addi	r2,r2,21564
811156b8:	1080070b 	ldhu	r2,28(r2)
811156bc:	10ffffcc 	andi	r3,r2,65535
811156c0:	e0bfdec4 	addi	r2,fp,-133
811156c4:	180d883a 	mov	r6,r3
811156c8:	01604574 	movhi	r5,33045
811156cc:	297f2804 	addi	r5,r5,-864
811156d0:	1009883a 	mov	r4,r2
811156d4:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
811156d8:	d0a06217 	ldw	r2,-32376(gp)
811156dc:	e0ffdec4 	addi	r3,fp,-133
811156e0:	180b883a 	mov	r5,r3
811156e4:	1009883a 	mov	r4,r2
811156e8:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
811156ec:	00a04574 	movhi	r2,33045
811156f0:	10950f04 	addi	r2,r2,21564
811156f4:	1080078b 	ldhu	r2,30(r2)
811156f8:	10ffffcc 	andi	r3,r2,65535
811156fc:	e0bfdec4 	addi	r2,fp,-133
81115700:	180d883a 	mov	r6,r3
81115704:	01604574 	movhi	r5,33045
81115708:	297f2f04 	addi	r5,r5,-836
8111570c:	1009883a 	mov	r4,r2
81115710:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81115714:	d0a06217 	ldw	r2,-32376(gp)
81115718:	e0ffdec4 	addi	r3,fp,-133
8111571c:	180b883a 	mov	r5,r3
81115720:	1009883a 	mov	r4,r2
81115724:	11236500 	call	81123650 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81115728:	00a04574 	movhi	r2,33045
8111572c:	10950f04 	addi	r2,r2,21564
81115730:	1080080b 	ldhu	r2,32(r2)
81115734:	10ffffcc 	andi	r3,r2,65535
81115738:	e0bfdec4 	addi	r2,fp,-133
8111573c:	180d883a 	mov	r6,r3
81115740:	01604574 	movhi	r5,33045
81115744:	297f3504 	addi	r5,r5,-812
81115748:	1009883a 	mov	r4,r2
8111574c:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
81115750:	d0a06217 	ldw	r2,-32376(gp)
81115754:	e0ffdec4 	addi	r3,fp,-133
81115758:	180b883a 	mov	r5,r3
8111575c:	1009883a 	mov	r4,r2
81115760:	11236500 	call	81123650 <fprintf>
								}
								#endif

								break;
81115764:	00002706 	br	81115804 <vParserCommTask+0xf94>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115768:	00a045f4 	movhi	r2,33047
8111576c:	10a34f04 	addi	r2,r2,-29380
81115770:	10800a8b 	ldhu	r2,42(r2)
81115774:	10bfffcc 	andi	r2,r2,65535
81115778:	108000e8 	cmpgeui	r2,r2,3
8111577c:	10001e1e 	bne	r2,zero,811157f8 <vParserCommTask+0xf88>
									memset(cPUSDebug,0,128);
81115780:	e0bfdec4 	addi	r2,fp,-133
81115784:	01802004 	movi	r6,128
81115788:	000b883a 	mov	r5,zero
8111578c:	1009883a 	mov	r4,r2
81115790:	11248500 	call	81124850 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81115794:	00a04574 	movhi	r2,33045
81115798:	10952204 	addi	r2,r2,21640
8111579c:	1080030b 	ldhu	r2,12(r2)
811157a0:	113fffcc 	andi	r4,r2,65535
811157a4:	00a04574 	movhi	r2,33045
811157a8:	10952204 	addi	r2,r2,21640
811157ac:	1080038b 	ldhu	r2,14(r2)
811157b0:	117fffcc 	andi	r5,r2,65535
811157b4:	00a04574 	movhi	r2,33045
811157b8:	10952204 	addi	r2,r2,21640
811157bc:	1080040b 	ldhu	r2,16(r2)
811157c0:	10bfffcc 	andi	r2,r2,65535
811157c4:	e0ffdec4 	addi	r3,fp,-133
811157c8:	d8800015 	stw	r2,0(sp)
811157cc:	280f883a 	mov	r7,r5
811157d0:	200d883a 	mov	r6,r4
811157d4:	01604574 	movhi	r5,33045
811157d8:	297e6404 	addi	r5,r5,-1648
811157dc:	1809883a 	mov	r4,r3
811157e0:	1124f640 	call	81124f64 <sprintf>
									debug(fp, cPUSDebug );
811157e4:	d0a06217 	ldw	r2,-32376(gp)
811157e8:	e0ffdec4 	addi	r3,fp,-133
811157ec:	180b883a 	mov	r5,r3
811157f0:	1009883a 	mov	r4,r2
811157f4:	11236500 	call	81123650 <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
811157f8:	00800044 	movi	r2,1
811157fc:	e0bfdc15 	stw	r2,-144(fp)
								break;
81115800:	00000106 	br	81115808 <vParserCommTask+0xf98>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
									debug(fp, cPUSDebug );
								}
								#endif

								break;
81115804:	0001883a 	nop
								}
								#endif							
								eParserMode = sWaitingMessage;
								break;
						}
                        break;
81115808:	00000406 	br	8111581c <vParserCommTask+0xfac>
                    default:
						eParserMode = sWaitingMessage;
8111580c:	00800044 	movi	r2,1
81115810:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81115814:	00000106 	br	8111581c <vParserCommTask+0xfac>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81115818:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;				
8111581c:	00000306 	br	8111582c <vParserCommTask+0xfbc>
			default:
				eParserMode = sWaitingMessage;
81115820:	00800044 	movi	r2,1
81115824:	e0bfdc15 	stw	r2,-144(fp)
				break;
81115828:	0001883a 	nop
		}
	}
8111582c:	003c2606 	br	811148c8 <__reset+0xfb0f48c8>

81115830 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81115830:	defffb04 	addi	sp,sp,-20
81115834:	de00012e 	bgeu	sp,et,8111583c <getPreParsedPacket+0xc>
81115838:	003b68fa 	trap	3
8111583c:	dfc00415 	stw	ra,16(sp)
81115840:	df000315 	stw	fp,12(sp)
81115844:	df000304 	addi	fp,sp,12
81115848:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111584c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81115850:	d0a06b17 	ldw	r2,-32340(gp)
81115854:	e0fffe44 	addi	r3,fp,-7
81115858:	180d883a 	mov	r6,r3
8111585c:	000b883a 	mov	r5,zero
81115860:	1009883a 	mov	r4,r2
81115864:	113eb000 	call	8113eb00 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81115868:	e0bffe43 	ldbu	r2,-7(fp)
8111586c:	10803fcc 	andi	r2,r2,255
81115870:	10002e1e 	bne	r2,zero,8111592c <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81115874:	e03ffe05 	stb	zero,-8(fp)
81115878:	00002506 	br	81115910 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
8111587c:	e0fffe03 	ldbu	r3,-8(fp)
81115880:	00a045f4 	movhi	r2,33047
81115884:	10a2a704 	addi	r2,r2,-30052
81115888:	18c01324 	muli	r3,r3,76
8111588c:	10c5883a 	add	r2,r2,r3
81115890:	10800104 	addi	r2,r2,4
81115894:	10800003 	ldbu	r2,0(r2)
81115898:	10803fcc 	andi	r2,r2,255
8111589c:	1080201c 	xori	r2,r2,128
811158a0:	10bfe004 	addi	r2,r2,-128
811158a4:	10001726 	beq	r2,zero,81115904 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
811158a8:	e0fffe03 	ldbu	r3,-8(fp)
811158ac:	e13fff17 	ldw	r4,-4(fp)
811158b0:	00a045f4 	movhi	r2,33047
811158b4:	10a2a704 	addi	r2,r2,-30052
811158b8:	18c01324 	muli	r3,r3,76
811158bc:	10c5883a 	add	r2,r2,r3
811158c0:	2007883a 	mov	r3,r4
811158c4:	1009883a 	mov	r4,r2
811158c8:	00801304 	movi	r2,76
811158cc:	100d883a 	mov	r6,r2
811158d0:	200b883a 	mov	r5,r4
811158d4:	1809883a 	mov	r4,r3
811158d8:	11247000 	call	81124700 <memcpy>
                bSuccess = TRUE;
811158dc:	00800044 	movi	r2,1
811158e0:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
811158e4:	e0fffe03 	ldbu	r3,-8(fp)
811158e8:	00a045f4 	movhi	r2,33047
811158ec:	10a2a704 	addi	r2,r2,-30052
811158f0:	18c01324 	muli	r3,r3,76
811158f4:	10c5883a 	add	r2,r2,r3
811158f8:	10800104 	addi	r2,r2,4
811158fc:	10000005 	stb	zero,0(r2)
                break;
81115900:	00000606 	br	8111591c <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81115904:	e0bffe03 	ldbu	r2,-8(fp)
81115908:	10800044 	addi	r2,r2,1
8111590c:	e0bffe05 	stb	r2,-8(fp)
81115910:	e0bffe03 	ldbu	r2,-8(fp)
81115914:	10800230 	cmpltui	r2,r2,8
81115918:	103fd81e 	bne	r2,zero,8111587c <__reset+0xfb0f587c>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
8111591c:	d0a06b17 	ldw	r2,-32340(gp)
81115920:	1009883a 	mov	r4,r2
81115924:	113f0a40 	call	8113f0a4 <OSMutexPost>
81115928:	00000106 	br	81115930 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
8111592c:	111dd940 	call	8111dd94 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81115930:	e0bffd17 	ldw	r2,-12(fp)
}
81115934:	e037883a 	mov	sp,fp
81115938:	dfc00117 	ldw	ra,4(sp)
8111593c:	df000017 	ldw	fp,0(sp)
81115940:	dec00204 	addi	sp,sp,8
81115944:	f800283a 	ret

81115948 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81115948:	defffa04 	addi	sp,sp,-24
8111594c:	de00012e 	bgeu	sp,et,81115954 <bSendMessagePUStoMebTask+0xc>
81115950:	003b68fa 	trap	3
81115954:	dfc00515 	stw	ra,20(sp)
81115958:	df000415 	stw	fp,16(sp)
8111595c:	df000404 	addi	fp,sp,16
81115960:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115964:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81115968:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
8111596c:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81115970:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81115974:	d0a07317 	ldw	r2,-32308(gp)
81115978:	e0fffd44 	addi	r3,fp,-11
8111597c:	180d883a 	mov	r6,r3
81115980:	01400284 	movi	r5,10
81115984:	1009883a 	mov	r4,r2
81115988:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8111598c:	e0bffd43 	ldbu	r2,-11(fp)
81115990:	10803fcc 	andi	r2,r2,255
81115994:	1000401e 	bne	r2,zero,81115a98 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81115998:	e03ffd05 	stb	zero,-12(fp)
8111599c:	00003806 	br	81115a80 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811159a0:	e0fffd03 	ldbu	r3,-12(fp)
811159a4:	00a04574 	movhi	r2,33045
811159a8:	109fc704 	addi	r2,r2,32540
811159ac:	18c01524 	muli	r3,r3,84
811159b0:	10c5883a 	add	r2,r2,r3
811159b4:	10800104 	addi	r2,r2,4
811159b8:	10800017 	ldw	r2,0(r2)
811159bc:	10002d1e 	bne	r2,zero,81115a74 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
811159c0:	e0fffd03 	ldbu	r3,-12(fp)
811159c4:	00a04574 	movhi	r2,33045
811159c8:	109fc704 	addi	r2,r2,32540
811159cc:	18c01524 	muli	r3,r3,84
811159d0:	10c7883a 	add	r3,r2,r3
811159d4:	e0bfff17 	ldw	r2,-4(fp)
811159d8:	1009883a 	mov	r4,r2
811159dc:	00801504 	movi	r2,84
811159e0:	100d883a 	mov	r6,r2
811159e4:	200b883a 	mov	r5,r4
811159e8:	1809883a 	mov	r4,r3
811159ec:	11247000 	call	81124700 <memcpy>
            	xPus[i].bInUse = TRUE;
811159f0:	e0fffd03 	ldbu	r3,-12(fp)
811159f4:	00a04574 	movhi	r2,33045
811159f8:	109fc704 	addi	r2,r2,32540
811159fc:	18c01524 	muli	r3,r3,84
81115a00:	10c5883a 	add	r2,r2,r3
81115a04:	10800104 	addi	r2,r2,4
81115a08:	00c00044 	movi	r3,1
81115a0c:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81115a10:	00800044 	movi	r2,1
81115a14:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81115a18:	00800044 	movi	r2,1
81115a1c:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81115a20:	d0a06917 	ldw	r2,-32348(gp)
81115a24:	e0fffe17 	ldw	r3,-8(fp)
81115a28:	180b883a 	mov	r5,r3
81115a2c:	1009883a 	mov	r4,r2
81115a30:	114001c0 	call	8114001c <OSQPost>
81115a34:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81115a38:	e0bffd43 	ldbu	r2,-11(fp)
81115a3c:	10803fcc 	andi	r2,r2,255
81115a40:	10000926 	beq	r2,zero,81115a68 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81115a44:	111f0140 	call	8111f014 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81115a48:	e0fffd03 	ldbu	r3,-12(fp)
81115a4c:	00a04574 	movhi	r2,33045
81115a50:	109fc704 	addi	r2,r2,32540
81115a54:	18c01524 	muli	r3,r3,84
81115a58:	10c5883a 	add	r2,r2,r3
81115a5c:	10800104 	addi	r2,r2,4
81115a60:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81115a64:	00000906 	br	81115a8c <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81115a68:	00800044 	movi	r2,1
81115a6c:	e0bffc15 	stw	r2,-16(fp)
                break;
81115a70:	00000606 	br	81115a8c <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81115a74:	e0bffd03 	ldbu	r2,-12(fp)
81115a78:	10800044 	addi	r2,r2,1
81115a7c:	e0bffd05 	stb	r2,-12(fp)
81115a80:	e0bffd03 	ldbu	r2,-12(fp)
81115a84:	10800130 	cmpltui	r2,r2,4
81115a88:	103fc51e 	bne	r2,zero,811159a0 <__reset+0xfb0f59a0>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81115a8c:	d0a07317 	ldw	r2,-32308(gp)
81115a90:	1009883a 	mov	r4,r2
81115a94:	113f0a40 	call	8113f0a4 <OSMutexPost>
    }

    return bSuccess;
81115a98:	e0bffc17 	ldw	r2,-16(fp)
}
81115a9c:	e037883a 	mov	sp,fp
81115aa0:	dfc00117 	ldw	ra,4(sp)
81115aa4:	df000017 	ldw	fp,0(sp)
81115aa8:	dec00204 	addi	sp,sp,8
81115aac:	f800283a 	ret

81115ab0 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81115ab0:	deffab04 	addi	sp,sp,-340
81115ab4:	de00012e 	bgeu	sp,et,81115abc <vReceiverUartTask+0xc>
81115ab8:	003b68fa 	trap	3
81115abc:	dfc05415 	stw	ra,336(sp)
81115ac0:	df005315 	stw	fp,332(sp)
81115ac4:	df005304 	addi	fp,sp,332
81115ac8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115acc:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115ad0:	00a045f4 	movhi	r2,33047
81115ad4:	10a34f04 	addi	r2,r2,-29380
81115ad8:	10800a8b 	ldhu	r2,42(r2)
81115adc:	10bfffcc 	andi	r2,r2,65535
81115ae0:	10800168 	cmpgeui	r2,r2,5
81115ae4:	1000071e 	bne	r2,zero,81115b04 <vReceiverUartTask+0x54>
        debug(fp,"Receiver UART Task. (Task on)\n");
81115ae8:	d0a06217 	ldw	r2,-32376(gp)
81115aec:	100f883a 	mov	r7,r2
81115af0:	01800784 	movi	r6,30
81115af4:	01400044 	movi	r5,1
81115af8:	01204574 	movhi	r4,33045
81115afc:	213f3b04 	addi	r4,r4,-788
81115b00:	1123cec0 	call	81123cec <fwrite>
    }
    #endif

    eReaderRXMode = sRConfiguring;
81115b04:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81115b08:	e0bfad17 	ldw	r2,-332(fp)
81115b0c:	10c00060 	cmpeqi	r3,r2,1
81115b10:	1800091e 	bne	r3,zero,81115b38 <vReceiverUartTask+0x88>
81115b14:	0080052e 	bgeu	zero,r2,81115b2c <vReceiverUartTask+0x7c>
81115b18:	10c000a0 	cmpeqi	r3,r2,2
81115b1c:	1800631e 	bne	r3,zero,81115cac <vReceiverUartTask+0x1fc>
81115b20:	108000e0 	cmpeqi	r2,r2,3
81115b24:	1000741e 	bne	r2,zero,81115cf8 <vReceiverUartTask+0x248>
81115b28:	00007d06 	br	81115d20 <vReceiverUartTask+0x270>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81115b2c:	00800044 	movi	r2,1
81115b30:	e0bfad15 	stw	r2,-332(fp)
                break;
81115b34:	00007e06 	br	81115d30 <vReceiverUartTask+0x280>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81115b38:	e0bfaf04 	addi	r2,fp,-324
81115b3c:	01802004 	movi	r6,128
81115b40:	000b883a 	mov	r5,zero
81115b44:	1009883a 	mov	r4,r2
81115b48:	11248500 	call	81124850 <memset>
                scanf("%s", cReceive);
81115b4c:	e0bfcf04 	addi	r2,fp,-196
81115b50:	100b883a 	mov	r5,r2
81115b54:	01204574 	movhi	r4,33045
81115b58:	213f4304 	addi	r4,r4,-756
81115b5c:	1124e880 	call	81124e88 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81115b60:	e0ffcf04 	addi	r3,fp,-196
81115b64:	e0bfaf04 	addi	r2,fp,-324
81115b68:	01801fc4 	movi	r6,127
81115b6c:	180b883a 	mov	r5,r3
81115b70:	1009883a 	mov	r4,r2
81115b74:	11247000 	call	81124700 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81115b78:	e0bfaf04 	addi	r2,fp,-324
81115b7c:	01604574 	movhi	r5,33045
81115b80:	29553704 	addi	r5,r5,21724
81115b84:	1009883a 	mov	r4,r2
81115b88:	11161a00 	call	811161a0 <bPreParserV2>
81115b8c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81115b90:	e0bfae17 	ldw	r2,-328(fp)
81115b94:	10800058 	cmpnei	r2,r2,1
81115b98:	10002e1e 	bne	r2,zero,81115c54 <vReceiverUartTask+0x1a4>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
81115b9c:	00a04574 	movhi	r2,33045
81115ba0:	10953704 	addi	r2,r2,21724
81115ba4:	10800103 	ldbu	r2,4(r2)
81115ba8:	10803fcc 	andi	r2,r2,255
81115bac:	1080201c 	xori	r2,r2,128
81115bb0:	10bfe004 	addi	r2,r2,-128
81115bb4:	10800fe0 	cmpeqi	r2,r2,63
81115bb8:	1000081e 	bne	r2,zero,81115bdc <vReceiverUartTask+0x12c>
81115bbc:	00a04574 	movhi	r2,33045
81115bc0:	10953704 	addi	r2,r2,21724
81115bc4:	10800103 	ldbu	r2,4(r2)
81115bc8:	10803fcc 	andi	r2,r2,255
81115bcc:	1080201c 	xori	r2,r2,128
81115bd0:	10bfe004 	addi	r2,r2,-128
81115bd4:	10800858 	cmpnei	r2,r2,33
81115bd8:	1000031e 	bne	r2,zero,81115be8 <vReceiverUartTask+0x138>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81115bdc:	00800084 	movi	r2,2
81115be0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115be4:	00005106 	br	81115d2c <vReceiverUartTask+0x27c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81115be8:	00a04574 	movhi	r2,33045
81115bec:	10953704 	addi	r2,r2,21724
81115bf0:	10800103 	ldbu	r2,4(r2)
81115bf4:	10803fcc 	andi	r2,r2,255
81115bf8:	1080201c 	xori	r2,r2,128
81115bfc:	10bfe004 	addi	r2,r2,-128
81115c00:	108008d8 	cmpnei	r2,r2,35
81115c04:	1000101e 	bne	r2,zero,81115c48 <vReceiverUartTask+0x198>
                            eReaderRXMode = sGetRxUart;
81115c08:	00800044 	movi	r2,1
81115c0c:	e0bfad15 	stw	r2,-332(fp)
                            #if DEBUG_ON
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115c10:	00a045f4 	movhi	r2,33047
81115c14:	10a34f04 	addi	r2,r2,-29380
81115c18:	10800a8b 	ldhu	r2,42(r2)
81115c1c:	10bfffcc 	andi	r2,r2,65535
81115c20:	108000e8 	cmpgeui	r2,r2,3
81115c24:	1000411e 	bne	r2,zero,81115d2c <vReceiverUartTask+0x27c>
                                debug(fp,"Nack Received. Do nothing!\n");
81115c28:	d0a06217 	ldw	r2,-32376(gp)
81115c2c:	100f883a 	mov	r7,r2
81115c30:	018006c4 	movi	r6,27
81115c34:	01400044 	movi	r5,1
81115c38:	01204574 	movhi	r4,33045
81115c3c:	213f4404 	addi	r4,r4,-752
81115c40:	1123cec0 	call	81123cec <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115c44:	00003906 	br	81115d2c <vReceiverUartTask+0x27c>
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                                debug(fp,"Nack Received. Do nothing!\n");
                            }
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81115c48:	008000c4 	movi	r2,3
81115c4c:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115c50:	00003606 	br	81115d2c <vReceiverUartTask+0x27c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81115c54:	00a04574 	movhi	r2,33045
81115c58:	10953704 	addi	r2,r2,21724
81115c5c:	00c008c4 	movi	r3,35
81115c60:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81115c64:	00a04574 	movhi	r2,33045
81115c68:	10953704 	addi	r2,r2,21724
81115c6c:	00c00b84 	movi	r3,46
81115c70:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81115c74:	00a04574 	movhi	r2,33045
81115c78:	10953704 	addi	r2,r2,21724
81115c7c:	00c00044 	movi	r3,1
81115c80:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81115c84:	01204574 	movhi	r4,33045
81115c88:	21153704 	addi	r4,r4,21724
81115c8c:	1115e700 	call	81115e70 <setPreAckSenderFreePos>
81115c90:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81115c94:	e0bfae17 	ldw	r2,-328(fp)
81115c98:	1000011e 	bne	r2,zero,81115ca0 <vReceiverUartTask+0x1f0>
                        vFailSendNack();
81115c9c:	111df140 	call	8111df14 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81115ca0:	00800044 	movi	r2,1
81115ca4:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81115ca8:	00002006 	br	81115d2c <vReceiverUartTask+0x27c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81115cac:	01204574 	movhi	r4,33045
81115cb0:	21153704 	addi	r4,r4,21724
81115cb4:	1115e700 	call	81115e70 <setPreAckSenderFreePos>
81115cb8:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81115cbc:	e0bfae17 	ldw	r2,-328(fp)
81115cc0:	10800058 	cmpnei	r2,r2,1
81115cc4:	1000081e 	bne	r2,zero,81115ce8 <vReceiverUartTask+0x238>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81115cc8:	01204574 	movhi	r4,33045
81115ccc:	21153704 	addi	r4,r4,21724
81115cd0:	1115d340 	call	81115d34 <setPreParsedFreePos>
81115cd4:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81115cd8:	e0bfae17 	ldw	r2,-328(fp)
81115cdc:	1000031e 	bne	r2,zero,81115cec <vReceiverUartTask+0x23c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81115ce0:	111e0140 	call	8111e014 <vFailSetPreParsedBuffer>
81115ce4:	00000106 	br	81115cec <vReceiverUartTask+0x23c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81115ce8:	111df940 	call	8111df94 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81115cec:	00800044 	movi	r2,1
81115cf0:	e0bfad15 	stw	r2,-332(fp)
                break;
81115cf4:	00000e06 	br	81115d30 <vReceiverUartTask+0x280>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81115cf8:	01204574 	movhi	r4,33045
81115cfc:	21153704 	addi	r4,r4,21724
81115d00:	1115fec0 	call	81115fec <setPreAckReceiverFreePos>
81115d04:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81115d08:	e0bfae17 	ldw	r2,-328(fp)
81115d0c:	1000011e 	bne	r2,zero,81115d14 <vReceiverUartTask+0x264>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81115d10:	111e0940 	call	8111e094 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81115d14:	00800044 	movi	r2,1
81115d18:	e0bfad15 	stw	r2,-332(fp)
                break;
81115d1c:	00000406 	br	81115d30 <vReceiverUartTask+0x280>
            default:
                eReaderRXMode = sGetRxUart;
81115d20:	00800044 	movi	r2,1
81115d24:	e0bfad15 	stw	r2,-332(fp)
                break;
81115d28:	00000106 	br	81115d30 <vReceiverUartTask+0x280>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115d2c:	0001883a 	nop
            default:
                eReaderRXMode = sGetRxUart;
                break;
        }

    }
81115d30:	003f7506 	br	81115b08 <__reset+0xfb0f5b08>

81115d34 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81115d34:	defffb04 	addi	sp,sp,-20
81115d38:	de00012e 	bgeu	sp,et,81115d40 <setPreParsedFreePos+0xc>
81115d3c:	003b68fa 	trap	3
81115d40:	dfc00415 	stw	ra,16(sp)
81115d44:	df000315 	stw	fp,12(sp)
81115d48:	df000304 	addi	fp,sp,12
81115d4c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115d50:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115d54:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115d58:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81115d5c:	d0a06b17 	ldw	r2,-32340(gp)
81115d60:	e0fffe44 	addi	r3,fp,-7
81115d64:	180d883a 	mov	r6,r3
81115d68:	01400284 	movi	r5,10
81115d6c:	1009883a 	mov	r4,r2
81115d70:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81115d74:	e0bffe43 	ldbu	r2,-7(fp)
81115d78:	10803fcc 	andi	r2,r2,255
81115d7c:	1000361e 	bne	r2,zero,81115e58 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115d80:	e03ffe05 	stb	zero,-8(fp)
81115d84:	00002e06 	br	81115e40 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81115d88:	e0fffe03 	ldbu	r3,-8(fp)
81115d8c:	00a045f4 	movhi	r2,33047
81115d90:	10a2a704 	addi	r2,r2,-30052
81115d94:	18c01324 	muli	r3,r3,76
81115d98:	10c5883a 	add	r2,r2,r3
81115d9c:	10800104 	addi	r2,r2,4
81115da0:	10800003 	ldbu	r2,0(r2)
81115da4:	10803fcc 	andi	r2,r2,255
81115da8:	1080201c 	xori	r2,r2,128
81115dac:	10bfe004 	addi	r2,r2,-128
81115db0:	1000201e 	bne	r2,zero,81115e34 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81115db4:	e0fffe03 	ldbu	r3,-8(fp)
81115db8:	00a045f4 	movhi	r2,33047
81115dbc:	10a2a704 	addi	r2,r2,-30052
81115dc0:	18c01324 	muli	r3,r3,76
81115dc4:	10c7883a 	add	r3,r2,r3
81115dc8:	e0bfff17 	ldw	r2,-4(fp)
81115dcc:	1009883a 	mov	r4,r2
81115dd0:	00801304 	movi	r2,76
81115dd4:	100d883a 	mov	r6,r2
81115dd8:	200b883a 	mov	r5,r4
81115ddc:	1809883a 	mov	r4,r3
81115de0:	11247000 	call	81124700 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81115de4:	d0a06417 	ldw	r2,-32368(gp)
81115de8:	1009883a 	mov	r4,r2
81115dec:	1140e940 	call	81140e94 <OSSemPost>
81115df0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81115df4:	e0bffe43 	ldbu	r2,-7(fp)
81115df8:	10803fcc 	andi	r2,r2,255
81115dfc:	1000031e 	bne	r2,zero,81115e0c <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81115e00:	00800044 	movi	r2,1
81115e04:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81115e08:	00001006 	br	81115e4c <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81115e0c:	111d3f40 	call	8111d3f4 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81115e10:	e0fffe03 	ldbu	r3,-8(fp)
81115e14:	00a045f4 	movhi	r2,33047
81115e18:	10a2a704 	addi	r2,r2,-30052
81115e1c:	18c01324 	muli	r3,r3,76
81115e20:	10c5883a 	add	r2,r2,r3
81115e24:	10800104 	addi	r2,r2,4
81115e28:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81115e2c:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81115e30:	00000606 	br	81115e4c <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115e34:	e0bffe03 	ldbu	r2,-8(fp)
81115e38:	10800044 	addi	r2,r2,1
81115e3c:	e0bffe05 	stb	r2,-8(fp)
81115e40:	e0bffe03 	ldbu	r2,-8(fp)
81115e44:	10800230 	cmpltui	r2,r2,8
81115e48:	103fcf1e 	bne	r2,zero,81115d88 <__reset+0xfb0f5d88>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81115e4c:	d0a06b17 	ldw	r2,-32340(gp)
81115e50:	1009883a 	mov	r4,r2
81115e54:	113f0a40 	call	8113f0a4 <OSMutexPost>
    }
    return bSuccess;
81115e58:	e0bffd17 	ldw	r2,-12(fp)
}
81115e5c:	e037883a 	mov	sp,fp
81115e60:	dfc00117 	ldw	ra,4(sp)
81115e64:	df000017 	ldw	fp,0(sp)
81115e68:	dec00204 	addi	sp,sp,8
81115e6c:	f800283a 	ret

81115e70 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81115e70:	defffb04 	addi	sp,sp,-20
81115e74:	de00012e 	bgeu	sp,et,81115e7c <setPreAckSenderFreePos+0xc>
81115e78:	003b68fa 	trap	3
81115e7c:	dfc00415 	stw	ra,16(sp)
81115e80:	df000315 	stw	fp,12(sp)
81115e84:	df000304 	addi	fp,sp,12
81115e88:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115e8c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115e90:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115e94:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81115e98:	d0a07217 	ldw	r2,-32312(gp)
81115e9c:	e0fffe44 	addi	r3,fp,-7
81115ea0:	180d883a 	mov	r6,r3
81115ea4:	01400284 	movi	r5,10
81115ea8:	1009883a 	mov	r4,r2
81115eac:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81115eb0:	e0bffe43 	ldbu	r2,-7(fp)
81115eb4:	10803fcc 	andi	r2,r2,255
81115eb8:	1000461e 	bne	r2,zero,81115fd4 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81115ebc:	e03ffe05 	stb	zero,-8(fp)
81115ec0:	00003e06 	br	81115fbc <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81115ec4:	e0fffe03 	ldbu	r3,-8(fp)
81115ec8:	00a045f4 	movhi	r2,33047
81115ecc:	10a29f04 	addi	r2,r2,-30084
81115ed0:	18c7883a 	add	r3,r3,r3
81115ed4:	18c7883a 	add	r3,r3,r3
81115ed8:	10c5883a 	add	r2,r2,r3
81115edc:	10800003 	ldbu	r2,0(r2)
81115ee0:	10803fcc 	andi	r2,r2,255
81115ee4:	1080201c 	xori	r2,r2,128
81115ee8:	10bfe004 	addi	r2,r2,-128
81115eec:	1000301e 	bne	r2,zero,81115fb0 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81115ef0:	e0fffe03 	ldbu	r3,-8(fp)
81115ef4:	e0bfff17 	ldw	r2,-4(fp)
81115ef8:	11000103 	ldbu	r4,4(r2)
81115efc:	00a045f4 	movhi	r2,33047
81115f00:	10a29f04 	addi	r2,r2,-30084
81115f04:	18c7883a 	add	r3,r3,r3
81115f08:	18c7883a 	add	r3,r3,r3
81115f0c:	10c5883a 	add	r2,r2,r3
81115f10:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81115f14:	e0fffe03 	ldbu	r3,-8(fp)
81115f18:	e0bfff17 	ldw	r2,-4(fp)
81115f1c:	11000143 	ldbu	r4,5(r2)
81115f20:	00a045f4 	movhi	r2,33047
81115f24:	10a29f04 	addi	r2,r2,-30084
81115f28:	18c7883a 	add	r3,r3,r3
81115f2c:	18c7883a 	add	r3,r3,r3
81115f30:	10c5883a 	add	r2,r2,r3
81115f34:	10800044 	addi	r2,r2,1
81115f38:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81115f3c:	e0fffe03 	ldbu	r3,-8(fp)
81115f40:	e0bfff17 	ldw	r2,-4(fp)
81115f44:	1100020b 	ldhu	r4,8(r2)
81115f48:	00a045f4 	movhi	r2,33047
81115f4c:	10a29f04 	addi	r2,r2,-30084
81115f50:	18c7883a 	add	r3,r3,r3
81115f54:	18c7883a 	add	r3,r3,r3
81115f58:	10c5883a 	add	r2,r2,r3
81115f5c:	10800084 	addi	r2,r2,2
81115f60:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81115f64:	d0a06117 	ldw	r2,-32380(gp)
81115f68:	1009883a 	mov	r4,r2
81115f6c:	1140e940 	call	81140e94 <OSSemPost>
81115f70:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81115f74:	e0bffe43 	ldbu	r2,-7(fp)
81115f78:	10803fcc 	andi	r2,r2,255
81115f7c:	10000926 	beq	r2,zero,81115fa4 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81115f80:	111d4bc0 	call	8111d4bc <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81115f84:	e0fffe03 	ldbu	r3,-8(fp)
81115f88:	00a045f4 	movhi	r2,33047
81115f8c:	10a29f04 	addi	r2,r2,-30084
81115f90:	18c7883a 	add	r3,r3,r3
81115f94:	18c7883a 	add	r3,r3,r3
81115f98:	10c5883a 	add	r2,r2,r3
81115f9c:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81115fa0:	00000906 	br	81115fc8 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81115fa4:	00800044 	movi	r2,1
81115fa8:	e0bffd15 	stw	r2,-12(fp)
                break;
81115fac:	00000606 	br	81115fc8 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81115fb0:	e0bffe03 	ldbu	r2,-8(fp)
81115fb4:	10800044 	addi	r2,r2,1
81115fb8:	e0bffe05 	stb	r2,-8(fp)
81115fbc:	e0bffe03 	ldbu	r2,-8(fp)
81115fc0:	10800230 	cmpltui	r2,r2,8
81115fc4:	103fbf1e 	bne	r2,zero,81115ec4 <__reset+0xfb0f5ec4>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81115fc8:	d0a07217 	ldw	r2,-32312(gp)
81115fcc:	1009883a 	mov	r4,r2
81115fd0:	113f0a40 	call	8113f0a4 <OSMutexPost>
    }

    return bSuccess;
81115fd4:	e0bffd17 	ldw	r2,-12(fp)
}
81115fd8:	e037883a 	mov	sp,fp
81115fdc:	dfc00117 	ldw	ra,4(sp)
81115fe0:	df000017 	ldw	fp,0(sp)
81115fe4:	dec00204 	addi	sp,sp,8
81115fe8:	f800283a 	ret

81115fec <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81115fec:	defffb04 	addi	sp,sp,-20
81115ff0:	de00012e 	bgeu	sp,et,81115ff8 <setPreAckReceiverFreePos+0xc>
81115ff4:	003b68fa 	trap	3
81115ff8:	dfc00415 	stw	ra,16(sp)
81115ffc:	df000315 	stw	fp,12(sp)
81116000:	df000304 	addi	fp,sp,12
81116004:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81116008:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8111600c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81116010:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81116014:	d0a06517 	ldw	r2,-32364(gp)
81116018:	e0fffe44 	addi	r3,fp,-7
8111601c:	180d883a 	mov	r6,r3
81116020:	01400504 	movi	r5,20
81116024:	1009883a 	mov	r4,r2
81116028:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8111602c:	e0bffe43 	ldbu	r2,-7(fp)
81116030:	10803fcc 	andi	r2,r2,255
81116034:	1000471e 	bne	r2,zero,81116154 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81116038:	e03ffe05 	stb	zero,-8(fp)
8111603c:	00003e06 	br	81116138 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81116040:	e0fffe03 	ldbu	r3,-8(fp)
81116044:	00a045b4 	movhi	r2,33046
81116048:	108c8d04 	addi	r2,r2,12852
8111604c:	18c7883a 	add	r3,r3,r3
81116050:	18c7883a 	add	r3,r3,r3
81116054:	10c5883a 	add	r2,r2,r3
81116058:	10800003 	ldbu	r2,0(r2)
8111605c:	10803fcc 	andi	r2,r2,255
81116060:	1080201c 	xori	r2,r2,128
81116064:	10bfe004 	addi	r2,r2,-128
81116068:	1000301e 	bne	r2,zero,8111612c <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
8111606c:	e0fffe03 	ldbu	r3,-8(fp)
81116070:	e0bfff17 	ldw	r2,-4(fp)
81116074:	11000103 	ldbu	r4,4(r2)
81116078:	00a045b4 	movhi	r2,33046
8111607c:	108c8d04 	addi	r2,r2,12852
81116080:	18c7883a 	add	r3,r3,r3
81116084:	18c7883a 	add	r3,r3,r3
81116088:	10c5883a 	add	r2,r2,r3
8111608c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81116090:	e0fffe03 	ldbu	r3,-8(fp)
81116094:	e0bfff17 	ldw	r2,-4(fp)
81116098:	11000143 	ldbu	r4,5(r2)
8111609c:	00a045b4 	movhi	r2,33046
811160a0:	108c8d04 	addi	r2,r2,12852
811160a4:	18c7883a 	add	r3,r3,r3
811160a8:	18c7883a 	add	r3,r3,r3
811160ac:	10c5883a 	add	r2,r2,r3
811160b0:	10800044 	addi	r2,r2,1
811160b4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
811160b8:	e0fffe03 	ldbu	r3,-8(fp)
811160bc:	e0bfff17 	ldw	r2,-4(fp)
811160c0:	1100020b 	ldhu	r4,8(r2)
811160c4:	00a045b4 	movhi	r2,33046
811160c8:	108c8d04 	addi	r2,r2,12852
811160cc:	18c7883a 	add	r3,r3,r3
811160d0:	18c7883a 	add	r3,r3,r3
811160d4:	10c5883a 	add	r2,r2,r3
811160d8:	10800084 	addi	r2,r2,2
811160dc:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
811160e0:	d0a06617 	ldw	r2,-32360(gp)
811160e4:	1009883a 	mov	r4,r2
811160e8:	1140e940 	call	81140e94 <OSSemPost>
811160ec:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811160f0:	e0bffe43 	ldbu	r2,-7(fp)
811160f4:	10803fcc 	andi	r2,r2,255
811160f8:	1000031e 	bne	r2,zero,81116108 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
811160fc:	00800044 	movi	r2,1
81116100:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81116104:	00000f06 	br	81116144 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81116108:	111d4580 	call	8111d458 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
8111610c:	e0fffe03 	ldbu	r3,-8(fp)
81116110:	00a045b4 	movhi	r2,33046
81116114:	108c8d04 	addi	r2,r2,12852
81116118:	18c7883a 	add	r3,r3,r3
8111611c:	18c7883a 	add	r3,r3,r3
81116120:	10c5883a 	add	r2,r2,r3
81116124:	10000005 	stb	zero,0(r2)
                }
                break;
81116128:	00000606 	br	81116144 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111612c:	e0bffe03 	ldbu	r2,-8(fp)
81116130:	10800044 	addi	r2,r2,1
81116134:	e0bffe05 	stb	r2,-8(fp)
81116138:	e0bffe03 	ldbu	r2,-8(fp)
8111613c:	108001b0 	cmpltui	r2,r2,6
81116140:	103fbf1e 	bne	r2,zero,81116040 <__reset+0xfb0f6040>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81116144:	d0a06517 	ldw	r2,-32364(gp)
81116148:	1009883a 	mov	r4,r2
8111614c:	113f0a40 	call	8113f0a4 <OSMutexPost>
81116150:	00000d06 	br	81116188 <setPreAckReceiverFreePos+0x19c>
    } else {
        /* Could not  */
        #if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116154:	00a045f4 	movhi	r2,33047
81116158:	10a34f04 	addi	r2,r2,-29380
8111615c:	10800a8b 	ldhu	r2,42(r2)
81116160:	10bfffcc 	andi	r2,r2,65535
81116164:	10800228 	cmpgeui	r2,r2,8
81116168:	1000071e 	bne	r2,zero,81116188 <setPreAckReceiverFreePos+0x19c>
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8111616c:	d0a06217 	ldw	r2,-32376(gp)
81116170:	100f883a 	mov	r7,r2
81116174:	01801404 	movi	r6,80
81116178:	01400044 	movi	r5,1
8111617c:	01204574 	movhi	r4,33045
81116180:	213f4b04 	addi	r4,r4,-724
81116184:	1123cec0 	call	81123cec <fwrite>
    	}
        #endif
    }

    return bSuccess;
81116188:	e0bffd17 	ldw	r2,-12(fp)
}
8111618c:	e037883a 	mov	sp,fp
81116190:	dfc00117 	ldw	ra,4(sp)
81116194:	df000017 	ldw	fp,0(sp)
81116198:	dec00204 	addi	sp,sp,8
8111619c:	f800283a 	ret

811161a0 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
811161a0:	defff404 	addi	sp,sp,-48
811161a4:	de00012e 	bgeu	sp,et,811161ac <bPreParserV2+0xc>
811161a8:	003b68fa 	trap	3
811161ac:	dfc00b15 	stw	ra,44(sp)
811161b0:	df000a15 	stw	fp,40(sp)
811161b4:	dc000915 	stw	r16,36(sp)
811161b8:	df000a04 	addi	fp,sp,40
811161bc:	e13ffd15 	stw	r4,-12(fp)
811161c0:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
811161c4:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
811161c8:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
811161cc:	01402004 	movi	r5,128
811161d0:	e13ffd17 	ldw	r4,-12(fp)
811161d4:	11252100 	call	81125210 <strnlen>
811161d8:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
811161dc:	01400ec4 	movi	r5,59
811161e0:	e13ffd17 	ldw	r4,-12(fp)
811161e4:	111ada40 	call	8111ada4 <siPosStr>
811161e8:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
811161ec:	e0fff98f 	ldh	r3,-26(fp)
811161f0:	e0bff90f 	ldh	r2,-28(fp)
811161f4:	10bfffc4 	addi	r2,r2,-1
811161f8:	18800226 	beq	r3,r2,81116204 <bPreParserV2+0x64>
        return bSuccess;
811161fc:	e0bff617 	ldw	r2,-40(fp)
81116200:	0000c006 	br	81116504 <bPreParserV2+0x364>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81116204:	01401f04 	movi	r5,124
81116208:	e13ffd17 	ldw	r4,-12(fp)
8111620c:	111ada40 	call	8111ada4 <siPosStr>
81116210:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81116214:	e0bffa0f 	ldh	r2,-24(fp)
81116218:	e0fff98f 	ldh	r3,-26(fp)
8111621c:	1880020e 	bge	r3,r2,81116228 <bPreParserV2+0x88>
        return bSuccess;
81116220:	e0bff617 	ldw	r2,-40(fp)
81116224:	0000b706 	br	81116504 <bPreParserV2+0x364>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81116228:	01604574 	movhi	r5,33045
8111622c:	297f6004 	addi	r5,r5,-640
81116230:	e13ffd17 	ldw	r4,-12(fp)
81116234:	112512c0 	call	8112512c <strcspn>
81116238:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8111623c:	e0bffa8f 	ldh	r2,-22(fp)
81116240:	e0fffa0f 	ldh	r3,-24(fp)
81116244:	1880020e 	bge	r3,r2,81116250 <bPreParserV2+0xb0>
        return bSuccess;
81116248:	e0bff617 	ldw	r2,-40(fp)
8111624c:	0000ad06 	br	81116504 <bPreParserV2+0x364>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81116250:	e0bffa8f 	ldh	r2,-22(fp)
81116254:	e0fffd17 	ldw	r3,-12(fp)
81116258:	1885883a 	add	r2,r3,r2
8111625c:	10c00003 	ldbu	r3,0(r2)
81116260:	e0bffe17 	ldw	r2,-8(fp)
81116264:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81116268:	e0bffe17 	ldw	r2,-8(fp)
8111626c:	10800103 	ldbu	r2,4(r2)
81116270:	10803fcc 	andi	r2,r2,255
81116274:	1080201c 	xori	r2,r2,128
81116278:	10bfe004 	addi	r2,r2,-128
8111627c:	108008d8 	cmpnei	r2,r2,35
81116280:	1000041e 	bne	r2,zero,81116294 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81116284:	00800044 	movi	r2,1
81116288:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8111628c:	e0bff617 	ldw	r2,-40(fp)
81116290:	00009c06 	br	81116504 <bPreParserV2+0x364>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81116294:	e0bffa8f 	ldh	r2,-22(fp)
81116298:	e0fffd17 	ldw	r3,-12(fp)
8111629c:	1889883a 	add	r4,r3,r2
811162a0:	e0fffa0f 	ldh	r3,-24(fp)
811162a4:	e0bffa8f 	ldh	r2,-22(fp)
811162a8:	1885c83a 	sub	r2,r3,r2
811162ac:	100b883a 	mov	r5,r2
811162b0:	111d0240 	call	8111d024 <ucCrc8wInit>
811162b4:	1007883a 	mov	r3,r2
811162b8:	e0bffe17 	ldw	r2,-8(fp)
811162bc:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
811162c0:	e0bffa8f 	ldh	r2,-22(fp)
811162c4:	10800044 	addi	r2,r2,1
811162c8:	e0fffd17 	ldw	r3,-12(fp)
811162cc:	1885883a 	add	r2,r3,r2
811162d0:	10c00003 	ldbu	r3,0(r2)
811162d4:	e0bffe17 	ldw	r2,-8(fp)
811162d8:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
811162dc:	e0bffe17 	ldw	r2,-8(fp)
811162e0:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
811162e4:	e0bffe17 	ldw	r2,-8(fp)
811162e8:	10800204 	addi	r2,r2,8
811162ec:	01801004 	movi	r6,64
811162f0:	000b883a 	mov	r5,zero
811162f4:	1009883a 	mov	r4,r2
811162f8:	11248500 	call	81124850 <memset>

    i = siIni + 3; /* "?C:i..." */
811162fc:	e0bffa8b 	ldhu	r2,-22(fp)
81116300:	108000c4 	addi	r2,r2,3
81116304:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81116308:	e0bffb44 	addi	r2,fp,-19
8111630c:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81116310:	e0bffb44 	addi	r2,fp,-19
81116314:	01800184 	movi	r6,6
81116318:	000b883a 	mov	r5,zero
8111631c:	1009883a 	mov	r4,r2
81116320:	11248500 	call	81124850 <memset>
        do {
            c = buffer[i];
81116324:	e0bff703 	ldbu	r2,-36(fp)
81116328:	e0fffd17 	ldw	r3,-12(fp)
8111632c:	1885883a 	add	r2,r3,r2
81116330:	10800003 	ldbu	r2,0(r2)
81116334:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81116338:	d0e00317 	ldw	r3,-32756(gp)
8111633c:	e0bffb07 	ldb	r2,-20(fp)
81116340:	10800044 	addi	r2,r2,1
81116344:	1885883a 	add	r2,r3,r2
81116348:	10800003 	ldbu	r2,0(r2)
8111634c:	10803fcc 	andi	r2,r2,255
81116350:	1080010c 	andi	r2,r2,4
81116354:	10000626 	beq	r2,zero,81116370 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81116358:	e0bff817 	ldw	r2,-32(fp)
8111635c:	e0fffb03 	ldbu	r3,-20(fp)
81116360:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81116364:	e0bff817 	ldw	r2,-32(fp)
81116368:	10800044 	addi	r2,r2,1
8111636c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81116370:	e0bff703 	ldbu	r2,-36(fp)
81116374:	10800044 	addi	r2,r2,1
81116378:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8111637c:	e0bff90f 	ldh	r2,-28(fp)
81116380:	e0fff703 	ldbu	r3,-36(fp)
81116384:	1880090e 	bge	r3,r2,811163ac <bPreParserV2+0x20c>
81116388:	e0bffb07 	ldb	r2,-20(fp)
8111638c:	10800ea0 	cmpeqi	r2,r2,58
81116390:	1000061e 	bne	r2,zero,811163ac <bPreParserV2+0x20c>
81116394:	e0bffb07 	ldb	r2,-20(fp)
81116398:	10800ee0 	cmpeqi	r2,r2,59
8111639c:	1000031e 	bne	r2,zero,811163ac <bPreParserV2+0x20c>
811163a0:	e0bffb07 	ldb	r2,-20(fp)
811163a4:	10801f18 	cmpnei	r2,r2,124
811163a8:	103fde1e 	bne	r2,zero,81116324 <__reset+0xfb0f6324>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811163ac:	e0bff817 	ldw	r2,-32(fp)
811163b0:	00c00284 	movi	r3,10
811163b4:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
811163b8:	e0bffb07 	ldb	r2,-20(fp)
811163bc:	10800ea0 	cmpeqi	r2,r2,58
811163c0:	1000031e 	bne	r2,zero,811163d0 <bPreParserV2+0x230>
811163c4:	e0bffb07 	ldb	r2,-20(fp)
811163c8:	10801f18 	cmpnei	r2,r2,124
811163cc:	10001a1e 	bne	r2,zero,81116438 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
811163d0:	e0bffe17 	ldw	r2,-8(fp)
811163d4:	10800183 	ldbu	r2,6(r2)
811163d8:	10803fcc 	andi	r2,r2,255
811163dc:	10800828 	cmpgeui	r2,r2,32
811163e0:	1000041e 	bne	r2,zero,811163f4 <bPreParserV2+0x254>
811163e4:	e0bffe17 	ldw	r2,-8(fp)
811163e8:	10800183 	ldbu	r2,6(r2)
811163ec:	14003fcc 	andi	r16,r2,255
811163f0:	00000106 	br	811163f8 <bPreParserV2+0x258>
811163f4:	04000804 	movi	r16,32
811163f8:	e0bffb44 	addi	r2,fp,-19
811163fc:	1009883a 	mov	r4,r2
81116400:	11234dc0 	call	811234dc <atoi>
81116404:	1009883a 	mov	r4,r2
81116408:	e0fffe17 	ldw	r3,-8(fp)
8111640c:	80800104 	addi	r2,r16,4
81116410:	1085883a 	add	r2,r2,r2
81116414:	1885883a 	add	r2,r3,r2
81116418:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8111641c:	e0bffe17 	ldw	r2,-8(fp)
81116420:	10800183 	ldbu	r2,6(r2)
81116424:	10800044 	addi	r2,r2,1
81116428:	1007883a 	mov	r3,r2
8111642c:	e0bffe17 	ldw	r2,-8(fp)
81116430:	10c00185 	stb	r3,6(r2)
81116434:	00000906 	br	8111645c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81116438:	e0bffb07 	ldb	r2,-20(fp)
8111643c:	10800ed8 	cmpnei	r2,r2,59
81116440:	1000061e 	bne	r2,zero,8111645c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81116444:	e0bffb44 	addi	r2,fp,-19
81116448:	1009883a 	mov	r4,r2
8111644c:	11234dc0 	call	811234dc <atoi>
81116450:	1007883a 	mov	r3,r2
81116454:	e0bffe17 	ldw	r2,-8(fp)
81116458:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8111645c:	e0bffb07 	ldb	r2,-20(fp)
81116460:	10800ee0 	cmpeqi	r2,r2,59
81116464:	1000031e 	bne	r2,zero,81116474 <bPreParserV2+0x2d4>
81116468:	e0bff90f 	ldh	r2,-28(fp)
8111646c:	e0fff703 	ldbu	r3,-36(fp)
81116470:	18bfa516 	blt	r3,r2,81116308 <__reset+0xfb0f6308>


    if ( c == FINAL_CHAR )
81116474:	e0bffb07 	ldb	r2,-20(fp)
81116478:	10800ed8 	cmpnei	r2,r2,59
8111647c:	10001f1e 	bne	r2,zero,811164fc <bPreParserV2+0x35c>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81116480:	e0bffe17 	ldw	r2,-8(fp)
81116484:	10c01243 	ldbu	r3,73(r2)
81116488:	e0bffe17 	ldw	r2,-8(fp)
8111648c:	10801203 	ldbu	r2,72(r2)
81116490:	18c03fcc 	andi	r3,r3,255
81116494:	10803fcc 	andi	r2,r2,255
81116498:	1880031e 	bne	r3,r2,811164a8 <bPreParserV2+0x308>
            bSuccess = TRUE;
8111649c:	00800044 	movi	r2,1
811164a0:	e0bff615 	stw	r2,-40(fp)
811164a4:	00001606 	br	81116500 <bPreParserV2+0x360>
        } else {
            /* Wrong CRC */
            #if DEBUG_ON
        	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811164a8:	00a045f4 	movhi	r2,33047
811164ac:	10a34f04 	addi	r2,r2,-29380
811164b0:	10800a8b 	ldhu	r2,42(r2)
811164b4:	10bfffcc 	andi	r2,r2,65535
811164b8:	10800228 	cmpgeui	r2,r2,8
811164bc:	10000d1e 	bne	r2,zero,811164f4 <bPreParserV2+0x354>
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
811164c0:	d0e06217 	ldw	r3,-32376(gp)
811164c4:	e0bffe17 	ldw	r2,-8(fp)
811164c8:	10801203 	ldbu	r2,72(r2)
811164cc:	11003fcc 	andi	r4,r2,255
811164d0:	e0bffe17 	ldw	r2,-8(fp)
811164d4:	10801243 	ldbu	r2,73(r2)
811164d8:	10803fcc 	andi	r2,r2,255
811164dc:	100f883a 	mov	r7,r2
811164e0:	200d883a 	mov	r6,r4
811164e4:	01604574 	movhi	r5,33045
811164e8:	297f6204 	addi	r5,r5,-632
811164ec:	1809883a 	mov	r4,r3
811164f0:	11236500 	call	81123650 <fprintf>
        	}
            #endif
            bSuccess = FALSE;
811164f4:	e03ff615 	stw	zero,-40(fp)
811164f8:	00000106 	br	81116500 <bPreParserV2+0x360>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
811164fc:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81116500:	e0bff617 	ldw	r2,-40(fp)
}
81116504:	e6ffff04 	addi	sp,fp,-4
81116508:	dfc00217 	ldw	ra,8(sp)
8111650c:	df000117 	ldw	fp,4(sp)
81116510:	dc000017 	ldw	r16,0(sp)
81116514:	dec00304 	addi	sp,sp,12
81116518:	f800283a 	ret

8111651c <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
8111651c:	defffb04 	addi	sp,sp,-20
81116520:	de00012e 	bgeu	sp,et,81116528 <vSenderComTask+0xc>
81116524:	003b68fa 	trap	3
81116528:	dfc00415 	stw	ra,16(sp)
8111652c:	df000315 	stw	fp,12(sp)
81116530:	df000304 	addi	fp,sp,12
81116534:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81116538:	e03ffd15 	stw	zero,-12(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111653c:	00a045f4 	movhi	r2,33047
81116540:	10a34f04 	addi	r2,r2,-29380
81116544:	10800a8b 	ldhu	r2,42(r2)
81116548:	10bfffcc 	andi	r2,r2,65535
8111654c:	10800168 	cmpgeui	r2,r2,5
81116550:	1000071e 	bne	r2,zero,81116570 <vSenderComTask+0x54>
        debug(fp,"Sender Comm Task. (Task on)\n");
81116554:	d0a06217 	ldw	r2,-32376(gp)
81116558:	100f883a 	mov	r7,r2
8111655c:	01800704 	movi	r6,28
81116560:	01400044 	movi	r5,1
81116564:	01204574 	movhi	r4,33045
81116568:	213f6e04 	addi	r4,r4,-584
8111656c:	1123cec0 	call	81123cec <fwrite>
    }
    #endif

    for (;;){
        
        switch (eSenderMode)
81116570:	e0bffd17 	ldw	r2,-12(fp)
81116574:	10c00060 	cmpeqi	r3,r2,1
81116578:	1800091e 	bne	r3,zero,811165a0 <vSenderComTask+0x84>
8111657c:	0080052e 	bgeu	zero,r2,81116594 <vSenderComTask+0x78>
81116580:	10c000a0 	cmpeqi	r3,r2,2
81116584:	1800651e 	bne	r3,zero,8111671c <vSenderComTask+0x200>
81116588:	10800160 	cmpeqi	r2,r2,5
8111658c:	10003e1e 	bne	r2,zero,81116688 <vSenderComTask+0x16c>
81116590:	00005206 	br	811166dc <vSenderComTask+0x1c0>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81116594:	00800044 	movi	r2,1
81116598:	e0bffd15 	stw	r2,-12(fp)
                break;
8111659c:	00006206 	br	81116728 <vSenderComTask+0x20c>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811165a0:	00a045f4 	movhi	r2,33047
811165a4:	10a34f04 	addi	r2,r2,-29380
811165a8:	10800a8b 	ldhu	r2,42(r2)
811165ac:	10bfffcc 	andi	r2,r2,65535
811165b0:	108000e8 	cmpgeui	r2,r2,3
811165b4:	1000071e 	bne	r2,zero,811165d4 <vSenderComTask+0xb8>
                    debug(fp,"Preparing the Start Sequence.\n");
811165b8:	d0a06217 	ldw	r2,-32376(gp)
811165bc:	100f883a 	mov	r7,r2
811165c0:	01800784 	movi	r6,30
811165c4:	01400044 	movi	r5,1
811165c8:	01204574 	movhi	r4,33045
811165cc:	213f7604 	addi	r4,r4,-552
811165d0:	1123cec0 	call	81123cec <fwrite>
            	}
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
811165d4:	01400044 	movi	r5,1
811165d8:	01204574 	movhi	r4,33045
811165dc:	213f7e04 	addi	r4,r4,-520
811165e0:	111a46c0 	call	8111a46c <bSendUART32v2>
811165e4:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
811165e8:	e0bffe17 	ldw	r2,-8(fp)
811165ec:	10800058 	cmpnei	r2,r2,1
811165f0:	1000101e 	bne	r2,zero,81116634 <vSenderComTask+0x118>
                    eSenderMode = sDummySender;
811165f4:	00800144 	movi	r2,5
811165f8:	e0bffd15 	stw	r2,-12(fp)
                    #if DEBUG_ON
                    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811165fc:	00a045f4 	movhi	r2,33047
81116600:	10a34f04 	addi	r2,r2,-29380
81116604:	10800a8b 	ldhu	r2,42(r2)
81116608:	10bfffcc 	andi	r2,r2,65535
8111660c:	108000e8 	cmpgeui	r2,r2,3
81116610:	1000441e 	bne	r2,zero,81116724 <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81116614:	d0a06217 	ldw	r2,-32376(gp)
81116618:	100f883a 	mov	r7,r2
8111661c:	01800d44 	movi	r6,53
81116620:	01400044 	movi	r5,1
81116624:	01204574 	movhi	r4,33045
81116628:	213f8104 	addi	r4,r4,-508
8111662c:	1123cec0 	call	81123cec <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81116630:	00003c06 	br	81116724 <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    }
                    #endif                    
                } else {
                    #if DEBUG_ON
                	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116634:	00a045f4 	movhi	r2,33047
81116638:	10a34f04 	addi	r2,r2,-29380
8111663c:	10800a8b 	ldhu	r2,42(r2)
81116640:	10bfffcc 	andi	r2,r2,65535
81116644:	108000e8 	cmpgeui	r2,r2,3
81116648:	1000071e 	bne	r2,zero,81116668 <vSenderComTask+0x14c>
                        debug(fp,"Fail, try again in 5 seconds.\n");
8111664c:	d0a06217 	ldw	r2,-32376(gp)
81116650:	100f883a 	mov	r7,r2
81116654:	01800784 	movi	r6,30
81116658:	01400044 	movi	r5,1
8111665c:	01204574 	movhi	r4,33045
81116660:	213f8f04 	addi	r4,r4,-452
81116664:	1123cec0 	call	81123cec <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
81116668:	00800044 	movi	r2,1
8111666c:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81116670:	000f883a 	mov	r7,zero
81116674:	01800144 	movi	r6,5
81116678:	000b883a 	mov	r5,zero
8111667c:	0009883a 	mov	r4,zero
81116680:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
                }
                break;
81116684:	00002706 	br	81116724 <vSenderComTask+0x208>
            case sReadingQueue:

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81116688:	00800144 	movi	r2,5
8111668c:	e0bffd15 	stw	r2,-12(fp)

                #if DEBUG_ON
                if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116690:	00a045f4 	movhi	r2,33047
81116694:	10a34f04 	addi	r2,r2,-29380
81116698:	10800a8b 	ldhu	r2,42(r2)
8111669c:	10bfffcc 	andi	r2,r2,65535
811166a0:	108000e8 	cmpgeui	r2,r2,3
811166a4:	1000071e 	bne	r2,zero,811166c4 <vSenderComTask+0x1a8>
                    debug(fp,"Working...\n");
811166a8:	d0a06217 	ldw	r2,-32376(gp)
811166ac:	100f883a 	mov	r7,r2
811166b0:	018002c4 	movi	r6,11
811166b4:	01400044 	movi	r5,1
811166b8:	01204574 	movhi	r4,33045
811166bc:	213f9704 	addi	r4,r4,-420
811166c0:	1123cec0 	call	81123cec <fwrite>
                }
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
811166c4:	000f883a 	mov	r7,zero
811166c8:	01800644 	movi	r6,25
811166cc:	000b883a 	mov	r5,zero
811166d0:	0009883a 	mov	r4,zero
811166d4:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>

                break;
811166d8:	00001306 	br	81116728 <vSenderComTask+0x20c>
            default:
                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811166dc:	00a045f4 	movhi	r2,33047
811166e0:	10a34f04 	addi	r2,r2,-29380
811166e4:	10800a8b 	ldhu	r2,42(r2)
811166e8:	10bfffcc 	andi	r2,r2,65535
811166ec:	10800228 	cmpgeui	r2,r2,8
811166f0:	1000071e 	bne	r2,zero,81116710 <vSenderComTask+0x1f4>
                    debug(fp,"Sender default\n");
811166f4:	d0a06217 	ldw	r2,-32376(gp)
811166f8:	100f883a 	mov	r7,r2
811166fc:	018003c4 	movi	r6,15
81116700:	01400044 	movi	r5,1
81116704:	01204574 	movhi	r4,33045
81116708:	213f9a04 	addi	r4,r4,-408
8111670c:	1123cec0 	call	81123cec <fwrite>
            	}
                #endif
                eSenderMode = sDummySender;
81116710:	00800144 	movi	r2,5
81116714:	e0bffd15 	stw	r2,-12(fp)
                break;
81116718:	00000306 	br	81116728 <vSenderComTask+0x20c>
                break;


            case sReadingQueue:

                break;
8111671c:	0001883a 	nop
81116720:	003f9306 	br	81116570 <__reset+0xfb0f6570>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81116724:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81116728:	003f9106 	br	81116570 <__reset+0xfb0f6570>

8111672c <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
8111672c:	defff804 	addi	sp,sp,-32
81116730:	de00012e 	bgeu	sp,et,81116738 <vSimMebTask+0xc>
81116734:	003b68fa 	trap	3
81116738:	dfc00715 	stw	ra,28(sp)
8111673c:	df000615 	stw	fp,24(sp)
81116740:	df000604 	addi	fp,sp,24
81116744:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81116748:	e0bfff17 	ldw	r2,-4(fp)
8111674c:	e0bffb15 	stw	r2,-20(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116750:	00a045f4 	movhi	r2,33047
81116754:	10a34f04 	addi	r2,r2,-29380
81116758:	10800a8b 	ldhu	r2,42(r2)
8111675c:	10bfffcc 	andi	r2,r2,65535
81116760:	10800168 	cmpgeui	r2,r2,5
81116764:	1000071e 	bne	r2,zero,81116784 <vSimMebTask+0x58>
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81116768:	d0a06217 	ldw	r2,-32376(gp)
8111676c:	100f883a 	mov	r7,r2
81116770:	018008c4 	movi	r6,35
81116774:	01400044 	movi	r5,1
81116778:	01204574 	movhi	r4,33045
8111677c:	213f9e04 	addi	r4,r4,-392
81116780:	1123cec0 	call	81123cec <fwrite>
	}
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81116784:	e0bffb17 	ldw	r2,-20(fp)
81116788:	10800117 	ldw	r2,4(r2)
8111678c:	10c00168 	cmpgeui	r3,r2,5
81116790:	1801301e 	bne	r3,zero,81116c54 <vSimMebTask+0x528>
81116794:	100690ba 	slli	r3,r2,2
81116798:	00a04474 	movhi	r2,33041
8111679c:	1099eb04 	addi	r2,r2,26540
811167a0:	1885883a 	add	r2,r3,r2
811167a4:	10800017 	ldw	r2,0(r2)
811167a8:	1000683a 	jmp	r2
811167ac:	811167c0 	call	8811167c <__reset+0x20f167c>
811167b0:	811167d8 	cmpnei	r4,r16,17823
811167b4:	81116870 	cmpltui	r4,r16,17825
811167b8:	81116954 	ori	r4,r16,17829
811167bc:	81116a80 	call	881116a8 <__reset+0x20f16a8>
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
811167c0:	e13ffb17 	ldw	r4,-20(fp)
811167c4:	1117bb00 	call	81117bb0 <vMebInit>
				pxMebC->eMode = sMebToConfig;
811167c8:	e0bffb17 	ldw	r2,-20(fp)
811167cc:	00c00044 	movi	r3,1
811167d0:	10c00115 	stw	r3,4(r2)
				break;
811167d4:	00013306 	br	81116ca4 <vSimMebTask+0x578>


			case sMebToConfig:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811167d8:	00a045f4 	movhi	r2,33047
811167dc:	10a34f04 	addi	r2,r2,-29380
811167e0:	10800a8b 	ldhu	r2,42(r2)
811167e4:	10bfffcc 	andi	r2,r2,65535
811167e8:	10800168 	cmpgeui	r2,r2,5
811167ec:	1000071e 	bne	r2,zero,8111680c <vSimMebTask+0xe0>
					debug(fp,"MEB Task: Config Mode\n");
811167f0:	d0a06217 	ldw	r2,-32376(gp)
811167f4:	100f883a 	mov	r7,r2
811167f8:	01800584 	movi	r6,22
811167fc:	01400044 	movi	r5,1
81116800:	01204574 	movhi	r4,33045
81116804:	213fa704 	addi	r4,r4,-356
81116808:	1123cec0 	call	81123cec <fwrite>
				}
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
8111680c:	1120f180 	call	81120f18 <bStopSync>
				vSyncClearCounter();
81116810:	110d5b00 	call	8110d5b0 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81116814:	1117cb80 	call	81117cb8 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81116818:	01c00284 	movi	r7,10
8111681c:	000d883a 	mov	r6,zero
81116820:	000b883a 	mov	r5,zero
81116824:	0009883a 	mov	r4,zero
81116828:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
8111682c:	000d883a 	mov	r6,zero
81116830:	000b883a 	mov	r5,zero
81116834:	01002844 	movi	r4,161
81116838:	11179840 	call	81117984 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
8111683c:	000d883a 	mov	r6,zero
81116840:	000b883a 	mov	r5,zero
81116844:	01002844 	movi	r4,161
81116848:	1117b280 	call	81117b28 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
8111684c:	01c03e84 	movi	r7,250
81116850:	000d883a 	mov	r6,zero
81116854:	000b883a 	mov	r5,zero
81116858:	0009883a 	mov	r4,zero
8111685c:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81116860:	e0bffb17 	ldw	r2,-20(fp)
81116864:	00c000c4 	movi	r3,3
81116868:	10c00115 	stw	r3,4(r2)
				break;
8111686c:	00010d06 	br	81116ca4 <vSimMebTask+0x578>


			case sMebToRun:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116870:	00a045f4 	movhi	r2,33047
81116874:	10a34f04 	addi	r2,r2,-29380
81116878:	10800a8b 	ldhu	r2,42(r2)
8111687c:	10bfffcc 	andi	r2,r2,65535
81116880:	10800168 	cmpgeui	r2,r2,5
81116884:	1000071e 	bne	r2,zero,811168a4 <vSimMebTask+0x178>
					debug(fp,"MEB Task: Run Mode\n");
81116888:	d0a06217 	ldw	r2,-32376(gp)
8111688c:	100f883a 	mov	r7,r2
81116890:	018004c4 	movi	r6,19
81116894:	01400044 	movi	r5,1
81116898:	01204574 	movhi	r4,33045
8111689c:	213fad04 	addi	r4,r4,-332
811168a0:	1123cec0 	call	81123cec <fwrite>
				}
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
811168a4:	000d883a 	mov	r6,zero
811168a8:	000b883a 	mov	r5,zero
811168ac:	01002884 	movi	r4,162
811168b0:	11179840 	call	81117984 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
811168b4:	000d883a 	mov	r6,zero
811168b8:	000b883a 	mov	r5,zero
811168bc:	01002884 	movi	r4,162
811168c0:	1117b280 	call	81117b28 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811168c4:	e0bffb17 	ldw	r2,-20(fp)
811168c8:	1080050b 	ldhu	r2,20(r2)
811168cc:	10bfffcc 	andi	r2,r2,65535
811168d0:	100f883a 	mov	r7,r2
811168d4:	000d883a 	mov	r6,zero
811168d8:	000b883a 	mov	r5,zero
811168dc:	0009883a 	mov	r4,zero
811168e0:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
811168e4:	e03ffa05 	stb	zero,-24(fp)
811168e8:	00001006 	br	8111692c <vSimMebTask+0x200>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
811168ec:	e0bffa03 	ldbu	r2,-24(fp)
811168f0:	10809824 	muli	r2,r2,608
811168f4:	10809d04 	addi	r2,r2,628
811168f8:	e0fffb17 	ldw	r3,-20(fp)
811168fc:	1885883a 	add	r2,r3,r2
81116900:	1009883a 	mov	r4,r2
81116904:	110af940 	call	8110af94 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81116908:	e0bffa03 	ldbu	r2,-24(fp)
8111690c:	e0fffb17 	ldw	r3,-20(fp)
81116910:	10809824 	muli	r2,r2,608
81116914:	1885883a 	add	r2,r3,r2
81116918:	10803c04 	addi	r2,r2,240
8111691c:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81116920:	e0bffa03 	ldbu	r2,-24(fp)
81116924:	10800044 	addi	r2,r2,1
81116928:	e0bffa05 	stb	r2,-24(fp)
8111692c:	e0bffa03 	ldbu	r2,-24(fp)
81116930:	103fee26 	beq	r2,zero,811168ec <__reset+0xfb0f68ec>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81116934:	110dc000 	call	8110dc00 <bSyncCtrReset>
				vSyncClearCounter();
81116938:	110d5b00 	call	8110d5b0 <vSyncClearCounter>
				bStartSync();
8111693c:	1120edc0 	call	81120edc <bStartSync>

				vEvtChangeMebMode();
81116940:	111f8a00 	call	8111f8a0 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81116944:	e0bffb17 	ldw	r2,-20(fp)
81116948:	00c00104 	movi	r3,4
8111694c:	10c00115 	stw	r3,4(r2)
				break;
81116950:	0000d406 	br	81116ca4 <vSimMebTask+0x578>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81116954:	d0a06917 	ldw	r2,-32348(gp)
81116958:	e0fffe04 	addi	r3,fp,-8
8111695c:	180d883a 	mov	r6,r3
81116960:	000b883a 	mov	r5,zero
81116964:	1009883a 	mov	r4,r2
81116968:	113fc140 	call	8113fc14 <OSQPend>
8111696c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81116970:	e0bffe03 	ldbu	r2,-8(fp)
81116974:	10803fcc 	andi	r2,r2,255
81116978:	10003b1e 	bne	r2,zero,81116a68 <vSimMebTask+0x33c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8111697c:	e0bffdc3 	ldbu	r2,-9(fp)
81116980:	10803fcc 	andi	r2,r2,255
81116984:	10800058 	cmpnei	r2,r2,1
81116988:	1000281e 	bne	r2,zero,81116a2c <vSimMebTask+0x300>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
8111698c:	e0bffd83 	ldbu	r2,-10(fp)
81116990:	10803fcc 	andi	r2,r2,255
81116994:	10c00060 	cmpeqi	r3,r2,1
81116998:	1800031e 	bne	r3,zero,811169a8 <vSimMebTask+0x27c>
8111699c:	10803820 	cmpeqi	r2,r2,224
811169a0:	1000041e 	bne	r2,zero,811169b4 <vSimMebTask+0x288>
811169a4:	00001106 	br	811169ec <vSimMebTask+0x2c0>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
811169a8:	e13ffb17 	ldw	r4,-20(fp)
811169ac:	1116ca80 	call	81116ca8 <vPusMebTask>
								break;
811169b0:	00003206 	br	81116a7c <vSimMebTask+0x350>
							case M_MASTER_SYNC:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811169b4:	00a045f4 	movhi	r2,33047
811169b8:	10a34f04 	addi	r2,r2,-29380
811169bc:	10800a8b 	ldhu	r2,42(r2)
811169c0:	10bfffcc 	andi	r2,r2,65535
811169c4:	10800228 	cmpgeui	r2,r2,8
811169c8:	1000291e 	bne	r2,zero,81116a70 <vSimMebTask+0x344>
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
811169cc:	d0a06217 	ldw	r2,-32376(gp)
811169d0:	100f883a 	mov	r7,r2
811169d4:	018012c4 	movi	r6,75
811169d8:	01400044 	movi	r5,1
811169dc:	01204574 	movhi	r4,33045
811169e0:	213fb204 	addi	r4,r4,-312
811169e4:	1123cec0 	call	81123cec <fwrite>
								}
								#endif
								break;
811169e8:	00002106 	br	81116a70 <vSimMebTask+0x344>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811169ec:	00a045f4 	movhi	r2,33047
811169f0:	10a34f04 	addi	r2,r2,-29380
811169f4:	10800a8b 	ldhu	r2,42(r2)
811169f8:	10bfffcc 	andi	r2,r2,65535
811169fc:	10800228 	cmpgeui	r2,r2,8
81116a00:	10001d1e 	bne	r2,zero,81116a78 <vSimMebTask+0x34c>
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81116a04:	d0a06217 	ldw	r2,-32376(gp)
81116a08:	e0fffd83 	ldbu	r3,-10(fp)
81116a0c:	18c03fcc 	andi	r3,r3,255
81116a10:	180d883a 	mov	r6,r3
81116a14:	01604574 	movhi	r5,33045
81116a18:	297fc504 	addi	r5,r5,-236
81116a1c:	1009883a 	mov	r4,r2
81116a20:	11236500 	call	81123650 <fprintf>
								}
								#endif
								break;
81116a24:	0001883a 	nop
81116a28:	00001306 	br	81116a78 <vSimMebTask+0x34c>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116a2c:	00a045f4 	movhi	r2,33047
81116a30:	10a34f04 	addi	r2,r2,-29380
81116a34:	10800a8b 	ldhu	r2,42(r2)
81116a38:	10bfffcc 	andi	r2,r2,65535
81116a3c:	10800228 	cmpgeui	r2,r2,8
81116a40:	1000951e 	bne	r2,zero,81116c98 <vSimMebTask+0x56c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81116a44:	d0a06217 	ldw	r2,-32376(gp)
81116a48:	e0fffdc3 	ldbu	r3,-9(fp)
81116a4c:	18c03fcc 	andi	r3,r3,255
81116a50:	180d883a 	mov	r6,r3
81116a54:	01604574 	movhi	r5,33045
81116a58:	297fd704 	addi	r5,r5,-164
81116a5c:	1009883a 	mov	r4,r2
81116a60:	11236500 	call	81123650 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81116a64:	00008c06 	br	81116c98 <vSimMebTask+0x56c>
						}
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81116a68:	111f0780 	call	8111f078 <vCouldNotGetCmdQueueMeb>
				}

				break;
81116a6c:	00008a06 	br	81116c98 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
								}
								#endif
								break;
81116a70:	0001883a 	nop
81116a74:	00008806 	br	81116c98 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
81116a78:	0001883a 	nop
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81116a7c:	00008606 	br	81116c98 <vSimMebTask+0x56c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81116a80:	d0a06917 	ldw	r2,-32348(gp)
81116a84:	e0fffe04 	addi	r3,fp,-8
81116a88:	180d883a 	mov	r6,r3
81116a8c:	000b883a 	mov	r5,zero
81116a90:	1009883a 	mov	r4,r2
81116a94:	113fc140 	call	8113fc14 <OSQPend>
81116a98:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81116a9c:	e0bffe03 	ldbu	r2,-8(fp)
81116aa0:	10803fcc 	andi	r2,r2,255
81116aa4:	1000651e 	bne	r2,zero,81116c3c <vSimMebTask+0x510>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81116aa8:	e0bffdc3 	ldbu	r2,-9(fp)
81116aac:	10803fcc 	andi	r2,r2,255
81116ab0:	10800058 	cmpnei	r2,r2,1
81116ab4:	1000521e 	bne	r2,zero,81116c00 <vSimMebTask+0x4d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81116ab8:	e0bffd83 	ldbu	r2,-10(fp)
81116abc:	10803fcc 	andi	r2,r2,255
81116ac0:	10c03820 	cmpeqi	r3,r2,224
81116ac4:	1800071e 	bne	r3,zero,81116ae4 <vSimMebTask+0x3b8>
81116ac8:	10c03860 	cmpeqi	r3,r2,225
81116acc:	1800071e 	bne	r3,zero,81116aec <vSimMebTask+0x3c0>
81116ad0:	10800060 	cmpeqi	r2,r2,1
81116ad4:	10003a26 	beq	r2,zero,81116bc0 <vSimMebTask+0x494>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81116ad8:	e13ffb17 	ldw	r4,-20(fp)
81116adc:	1116ca80 	call	81116ca8 <vPusMebTask>
								break;
81116ae0:	00005b06 	br	81116c50 <vSimMebTask+0x524>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81116ae4:	e13ffb17 	ldw	r4,-20(fp)
81116ae8:	1117c140 	call	81117c14 <vSwapMemmory>
							case M_SYNC:
								#if DEBUG_ON

								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116aec:	00a045f4 	movhi	r2,33047
81116af0:	10a34f04 	addi	r2,r2,-29380
81116af4:	10800a8b 	ldhu	r2,42(r2)
81116af8:	10bfffcc 	andi	r2,r2,65535
81116afc:	10800168 	cmpgeui	r2,r2,5
81116b00:	1000501e 	bne	r2,zero,81116c44 <vSimMebTask+0x518>
									fprintf(fp,"\n\nSync\n");
81116b04:	d0a06217 	ldw	r2,-32376(gp)
81116b08:	100f883a 	mov	r7,r2
81116b0c:	018001c4 	movi	r6,7
81116b10:	01400044 	movi	r5,1
81116b14:	01204574 	movhi	r4,33045
81116b18:	213fe504 	addi	r4,r4,-108
81116b1c:	1123cec0 	call	81123cec <fwrite>
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116b20:	00a045f4 	movhi	r2,33047
81116b24:	10a34f04 	addi	r2,r2,-29380
81116b28:	10800a8b 	ldhu	r2,42(r2)
81116b2c:	10bfffcc 	andi	r2,r2,65535
81116b30:	108000e8 	cmpgeui	r2,r2,3
81116b34:	1000431e 	bne	r2,zero,81116c44 <vSimMebTask+0x518>
										bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
81116b38:	e0bffb17 	ldw	r2,-20(fp)
81116b3c:	10809d04 	addi	r2,r2,628
81116b40:	1009883a 	mov	r4,r2
81116b44:	110af040 	call	8110af04 <bSpwcGetTimecode>
										tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81116b48:	e0bffb17 	ldw	r2,-20(fp)
81116b4c:	1080a943 	ldbu	r2,677(r2)
81116b50:	e0bffc05 	stb	r2,-16(fp)
										tCodeNext = ( tCode ) % 4;
81116b54:	e0bffc03 	ldbu	r2,-16(fp)
81116b58:	108000cc 	andi	r2,r2,3
81116b5c:	e0bffc45 	stb	r2,-15(fp)
										fprintf(fp,"TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
81116b60:	d0a06217 	ldw	r2,-32376(gp)
81116b64:	e0fffc03 	ldbu	r3,-16(fp)
81116b68:	e13ffc43 	ldbu	r4,-15(fp)
81116b6c:	200f883a 	mov	r7,r4
81116b70:	180d883a 	mov	r6,r3
81116b74:	01604574 	movhi	r5,33045
81116b78:	297fe704 	addi	r5,r5,-100
81116b7c:	1009883a 	mov	r4,r2
81116b80:	11236500 	call	81123650 <fprintf>
										bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
81116b84:	e0bffb17 	ldw	r2,-20(fp)
81116b88:	10805704 	addi	r2,r2,348
81116b8c:	1009883a 	mov	r4,r2
81116b90:	1108a0c0 	call	81108a0c <bRmapGetMemConfigArea>
										ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
81116b94:	e0bffb17 	ldw	r2,-20(fp)
81116b98:	10807917 	ldw	r2,484(r2)
81116b9c:	e0bffc85 	stb	r2,-14(fp)
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
81116ba0:	d0a06217 	ldw	r2,-32376(gp)
81116ba4:	e0fffc83 	ldbu	r3,-14(fp)
81116ba8:	180d883a 	mov	r6,r3
81116bac:	01604574 	movhi	r5,33045
81116bb0:	297fec04 	addi	r5,r5,-80
81116bb4:	1009883a 	mov	r4,r2
81116bb8:	11236500 	call	81123650 <fprintf>
									}
								}
								#endif

								break;
81116bbc:	00002106 	br	81116c44 <vSimMebTask+0x518>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116bc0:	00a045f4 	movhi	r2,33047
81116bc4:	10a34f04 	addi	r2,r2,-29380
81116bc8:	10800a8b 	ldhu	r2,42(r2)
81116bcc:	10bfffcc 	andi	r2,r2,65535
81116bd0:	10800228 	cmpgeui	r2,r2,8
81116bd4:	10001d1e 	bne	r2,zero,81116c4c <vSimMebTask+0x520>
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
81116bd8:	d0a06217 	ldw	r2,-32376(gp)
81116bdc:	e0fffd83 	ldbu	r3,-10(fp)
81116be0:	18c03fcc 	andi	r3,r3,255
81116be4:	180d883a 	mov	r6,r3
81116be8:	01604574 	movhi	r5,33045
81116bec:	297ff504 	addi	r5,r5,-44
81116bf0:	1009883a 	mov	r4,r2
81116bf4:	11236500 	call	81123650 <fprintf>
								}
								#endif
								break;
81116bf8:	0001883a 	nop
81116bfc:	00001306 	br	81116c4c <vSimMebTask+0x520>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116c00:	00a045f4 	movhi	r2,33047
81116c04:	10a34f04 	addi	r2,r2,-29380
81116c08:	10800a8b 	ldhu	r2,42(r2)
81116c0c:	10bfffcc 	andi	r2,r2,65535
81116c10:	10800228 	cmpgeui	r2,r2,8
81116c14:	1000221e 	bne	r2,zero,81116ca0 <vSimMebTask+0x574>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81116c18:	d0a06217 	ldw	r2,-32376(gp)
81116c1c:	e0fffdc3 	ldbu	r3,-9(fp)
81116c20:	18c03fcc 	andi	r3,r3,255
81116c24:	180d883a 	mov	r6,r3
81116c28:	01604574 	movhi	r5,33045
81116c2c:	297fd704 	addi	r5,r5,-164
81116c30:	1009883a 	mov	r4,r2
81116c34:	11236500 	call	81123650 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116c38:	00001906 	br	81116ca0 <vSimMebTask+0x574>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81116c3c:	111f0780 	call	8111f078 <vCouldNotGetCmdQueueMeb>
				}			
				break;
81116c40:	00001706 	br	81116ca0 <vSimMebTask+0x574>
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
									}
								}
								#endif

								break;
81116c44:	0001883a 	nop
81116c48:	00001506 	br	81116ca0 <vSimMebTask+0x574>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
81116c4c:	0001883a 	nop

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116c50:	00001306 	br	81116ca0 <vSimMebTask+0x574>

			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116c54:	00a045f4 	movhi	r2,33047
81116c58:	10a34f04 	addi	r2,r2,-29380
81116c5c:	10800a8b 	ldhu	r2,42(r2)
81116c60:	10bfffcc 	andi	r2,r2,65535
81116c64:	10800228 	cmpgeui	r2,r2,8
81116c68:	1000071e 	bne	r2,zero,81116c88 <vSimMebTask+0x55c>
					debug(fp,"MEB Task: Unknown state, backing to Config Mode\n");
81116c6c:	d0a06217 	ldw	r2,-32376(gp)
81116c70:	100f883a 	mov	r7,r2
81116c74:	01800c04 	movi	r6,48
81116c78:	01400044 	movi	r5,1
81116c7c:	01204574 	movhi	r4,33045
81116c80:	213ffe04 	addi	r4,r4,-8
81116c84:	1123cec0 	call	81123cec <fwrite>
				}
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81116c88:	e0bffb17 	ldw	r2,-20(fp)
81116c8c:	00c00044 	movi	r3,1
81116c90:	10c00115 	stw	r3,4(r2)
				break;
81116c94:	00000306 	br	81116ca4 <vSimMebTask+0x578>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81116c98:	0001883a 	nop
81116c9c:	003eb906 	br	81116784 <__reset+0xfb0f6784>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116ca0:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
				break;
		}
	}
81116ca4:	003eb706 	br	81116784 <__reset+0xfb0f6784>

81116ca8 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81116ca8:	defffb04 	addi	sp,sp,-20
81116cac:	de00012e 	bgeu	sp,et,81116cb4 <vPusMebTask+0xc>
81116cb0:	003b68fa 	trap	3
81116cb4:	dfc00415 	stw	ra,16(sp)
81116cb8:	df000315 	stw	fp,12(sp)
81116cbc:	df000304 	addi	fp,sp,12
81116cc0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81116cc4:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81116cc8:	d0a07317 	ldw	r2,-32308(gp)
81116ccc:	e0fffe44 	addi	r3,fp,-7
81116cd0:	180d883a 	mov	r6,r3
81116cd4:	01400084 	movi	r5,2
81116cd8:	1009883a 	mov	r4,r2
81116cdc:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81116ce0:	e0bffe43 	ldbu	r2,-7(fp)
81116ce4:	10803fcc 	andi	r2,r2,255
81116ce8:	10002c1e 	bne	r2,zero,81116d9c <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81116cec:	e03ffe05 	stb	zero,-8(fp)
81116cf0:	00002306 	br	81116d80 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81116cf4:	e0fffe03 	ldbu	r3,-8(fp)
81116cf8:	00a04574 	movhi	r2,33045
81116cfc:	109fc704 	addi	r2,r2,32540
81116d00:	18c01524 	muli	r3,r3,84
81116d04:	10c5883a 	add	r2,r2,r3
81116d08:	10800104 	addi	r2,r2,4
81116d0c:	10800017 	ldw	r2,0(r2)
81116d10:	10800058 	cmpnei	r2,r2,1
81116d14:	1000171e 	bne	r2,zero,81116d74 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81116d18:	e13ffe03 	ldbu	r4,-8(fp)
81116d1c:	00e04574 	movhi	r3,33045
81116d20:	18d54a04 	addi	r3,r3,21800
81116d24:	00a04574 	movhi	r2,33045
81116d28:	109fc704 	addi	r2,r2,32540
81116d2c:	21001524 	muli	r4,r4,84
81116d30:	1105883a 	add	r2,r2,r4
81116d34:	1009883a 	mov	r4,r2
81116d38:	00801504 	movi	r2,84
81116d3c:	100d883a 	mov	r6,r2
81116d40:	200b883a 	mov	r5,r4
81116d44:	1809883a 	mov	r4,r3
81116d48:	11247000 	call	81124700 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81116d4c:	e0fffe03 	ldbu	r3,-8(fp)
81116d50:	00a04574 	movhi	r2,33045
81116d54:	109fc704 	addi	r2,r2,32540
81116d58:	18c01524 	muli	r3,r3,84
81116d5c:	10c5883a 	add	r2,r2,r3
81116d60:	10800104 	addi	r2,r2,4
81116d64:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81116d68:	00800044 	movi	r2,1
81116d6c:	e0bffd15 	stw	r2,-12(fp)
                break;
81116d70:	00000606 	br	81116d8c <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81116d74:	e0bffe03 	ldbu	r2,-8(fp)
81116d78:	10800044 	addi	r2,r2,1
81116d7c:	e0bffe05 	stb	r2,-8(fp)
81116d80:	e0bffe03 	ldbu	r2,-8(fp)
81116d84:	10800130 	cmpltui	r2,r2,4
81116d88:	103fda1e 	bne	r2,zero,81116cf4 <__reset+0xfb0f6cf4>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81116d8c:	d0a07317 	ldw	r2,-32308(gp)
81116d90:	1009883a 	mov	r4,r2
81116d94:	113f0a40 	call	8113f0a4 <OSMutexPost>
81116d98:	00000106 	br	81116da0 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81116d9c:	111f0f80 	call	8111f0f8 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81116da0:	e0bffd17 	ldw	r2,-12(fp)
81116da4:	10001126 	beq	r2,zero,81116dec <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81116da8:	e0bfff17 	ldw	r2,-4(fp)
81116dac:	10800117 	ldw	r2,4(r2)
81116db0:	10c000e0 	cmpeqi	r3,r2,3
81116db4:	1800031e 	bne	r3,zero,81116dc4 <vPusMebTask+0x11c>
81116db8:	10800120 	cmpeqi	r2,r2,4
81116dbc:	1000061e 	bne	r2,zero,81116dd8 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81116dc0:	00000a06 	br	81116dec <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81116dc4:	01604574 	movhi	r5,33045
81116dc8:	29554a04 	addi	r5,r5,21800
81116dcc:	e13fff17 	ldw	r4,-4(fp)
81116dd0:	1116e040 	call	81116e04 <vPusMebInTaskConfigMode>
				break;
81116dd4:	00000506 	br	81116dec <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81116dd8:	01604574 	movhi	r5,33045
81116ddc:	29554a04 	addi	r5,r5,21800
81116de0:	e13fff17 	ldw	r4,-4(fp)
81116de4:	11172400 	call	81117240 <vPusMebInTaskRunningMode>
				break;
81116de8:	0001883a 	nop
			default:
				break;
		}
	}
}
81116dec:	0001883a 	nop
81116df0:	e037883a 	mov	sp,fp
81116df4:	dfc00117 	ldw	ra,4(sp)
81116df8:	df000017 	ldw	fp,0(sp)
81116dfc:	dec00204 	addi	sp,sp,8
81116e00:	f800283a 	ret

81116e04 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116e04:	defffc04 	addi	sp,sp,-16
81116e08:	de00012e 	bgeu	sp,et,81116e10 <vPusMebInTaskConfigMode+0xc>
81116e0c:	003b68fa 	trap	3
81116e10:	dfc00315 	stw	ra,12(sp)
81116e14:	df000215 	stw	fp,8(sp)
81116e18:	df000204 	addi	fp,sp,8
81116e1c:	e13ffe15 	stw	r4,-8(fp)
81116e20:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116e24:	e0bfff17 	ldw	r2,-4(fp)
81116e28:	1080030b 	ldhu	r2,12(r2)
81116e2c:	10bfffcc 	andi	r2,r2,65535
81116e30:	10c03ee0 	cmpeqi	r3,r2,251
81116e34:	1800081e 	bne	r3,zero,81116e58 <vPusMebInTaskConfigMode+0x54>
81116e38:	10c03f20 	cmpeqi	r3,r2,252
81116e3c:	18000a1e 	bne	r3,zero,81116e68 <vPusMebInTaskConfigMode+0x64>
81116e40:	10803ea0 	cmpeqi	r2,r2,250
81116e44:	10000c26 	beq	r2,zero,81116e78 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81116e48:	e17fff17 	ldw	r5,-4(fp)
81116e4c:	e13ffe17 	ldw	r4,-8(fp)
81116e50:	1116ec80 	call	81116ec8 <vPusType250conf>
			break;
81116e54:	00001606 	br	81116eb0 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81116e58:	e17fff17 	ldw	r5,-4(fp)
81116e5c:	e13ffe17 	ldw	r4,-8(fp)
81116e60:	1116f740 	call	81116f74 <vPusType251conf>
			break;
81116e64:	00001206 	br	81116eb0 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81116e68:	e17fff17 	ldw	r5,-4(fp)
81116e6c:	e13ffe17 	ldw	r4,-8(fp)
81116e70:	1116fe00 	call	81116fe0 <vPusType252conf>
			break;
81116e74:	00000e06 	br	81116eb0 <vPusMebInTaskConfigMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116e78:	00a045f4 	movhi	r2,33047
81116e7c:	10a34f04 	addi	r2,r2,-29380
81116e80:	10800a8b 	ldhu	r2,42(r2)
81116e84:	10bfffcc 	andi	r2,r2,65535
81116e88:	10800228 	cmpgeui	r2,r2,8
81116e8c:	1000071e 	bne	r2,zero,81116eac <vPusMebInTaskConfigMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81116e90:	d0a06217 	ldw	r2,-32376(gp)
81116e94:	100f883a 	mov	r7,r2
81116e98:	01800d84 	movi	r6,54
81116e9c:	01400044 	movi	r5,1
81116ea0:	01204574 	movhi	r4,33045
81116ea4:	21000b04 	addi	r4,r4,44
81116ea8:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
81116eac:	0001883a 	nop
	}
}
81116eb0:	0001883a 	nop
81116eb4:	e037883a 	mov	sp,fp
81116eb8:	dfc00117 	ldw	ra,4(sp)
81116ebc:	df000017 	ldw	fp,0(sp)
81116ec0:	dec00204 	addi	sp,sp,8
81116ec4:	f800283a 	ret

81116ec8 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116ec8:	defffc04 	addi	sp,sp,-16
81116ecc:	de00012e 	bgeu	sp,et,81116ed4 <vPusType250conf+0xc>
81116ed0:	003b68fa 	trap	3
81116ed4:	dfc00315 	stw	ra,12(sp)
81116ed8:	df000215 	stw	fp,8(sp)
81116edc:	df000204 	addi	fp,sp,8
81116ee0:	e13ffe15 	stw	r4,-8(fp)
81116ee4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81116ee8:	e0bfff17 	ldw	r2,-4(fp)
81116eec:	1080038b 	ldhu	r2,14(r2)
81116ef0:	10bfffcc 	andi	r2,r2,65535
81116ef4:	10c00f60 	cmpeqi	r3,r2,61
81116ef8:	1800031e 	bne	r3,zero,81116f08 <vPusType250conf+0x40>
81116efc:	10800fa0 	cmpeqi	r2,r2,62
81116f00:	1000131e 	bne	r2,zero,81116f50 <vPusType250conf+0x88>
81116f04:	00000406 	br	81116f18 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81116f08:	e0bffe17 	ldw	r2,-8(fp)
81116f0c:	00c00084 	movi	r3,2
81116f10:	10c00115 	stw	r3,4(r2)
			break;
81116f14:	00001106 	br	81116f5c <vPusType250conf+0x94>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116f18:	00a045f4 	movhi	r2,33047
81116f1c:	10a34f04 	addi	r2,r2,-29380
81116f20:	10800a8b 	ldhu	r2,42(r2)
81116f24:	10bfffcc 	andi	r2,r2,65535
81116f28:	10800228 	cmpgeui	r2,r2,8
81116f2c:	10000a1e 	bne	r2,zero,81116f58 <vPusType250conf+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81116f30:	d0a06217 	ldw	r2,-32376(gp)
81116f34:	100f883a 	mov	r7,r2
81116f38:	01800b04 	movi	r6,44
81116f3c:	01400044 	movi	r5,1
81116f40:	01204574 	movhi	r4,33045
81116f44:	21001904 	addi	r4,r4,100
81116f48:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
81116f4c:	00000206 	br	81116f58 <vPusType250conf+0x90>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81116f50:	0001883a 	nop
81116f54:	00000106 	br	81116f5c <vPusType250conf+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116f58:	0001883a 	nop
	}
}
81116f5c:	0001883a 	nop
81116f60:	e037883a 	mov	sp,fp
81116f64:	dfc00117 	ldw	ra,4(sp)
81116f68:	df000017 	ldw	fp,0(sp)
81116f6c:	dec00204 	addi	sp,sp,8
81116f70:	f800283a 	ret

81116f74 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116f74:	defffc04 	addi	sp,sp,-16
81116f78:	de00012e 	bgeu	sp,et,81116f80 <vPusType251conf+0xc>
81116f7c:	003b68fa 	trap	3
81116f80:	dfc00315 	stw	ra,12(sp)
81116f84:	df000215 	stw	fp,8(sp)
81116f88:	df000204 	addi	fp,sp,8
81116f8c:	e13ffe15 	stw	r4,-8(fp)
81116f90:	e17fff15 	stw	r5,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116f94:	00a045f4 	movhi	r2,33047
81116f98:	10a34f04 	addi	r2,r2,-29380
81116f9c:	10800a8b 	ldhu	r2,42(r2)
81116fa0:	10bfffcc 	andi	r2,r2,65535
81116fa4:	10800168 	cmpgeui	r2,r2,5
81116fa8:	1000071e 	bne	r2,zero,81116fc8 <vPusType251conf+0x54>
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81116fac:	d0a06217 	ldw	r2,-32376(gp)
81116fb0:	100f883a 	mov	r7,r2
81116fb4:	01801184 	movi	r6,70
81116fb8:	01400044 	movi	r5,1
81116fbc:	01204574 	movhi	r4,33045
81116fc0:	21002504 	addi	r4,r4,148
81116fc4:	1123cec0 	call	81123cec <fwrite>
	}
	#endif
}
81116fc8:	0001883a 	nop
81116fcc:	e037883a 	mov	sp,fp
81116fd0:	dfc00117 	ldw	ra,4(sp)
81116fd4:	df000017 	ldw	fp,0(sp)
81116fd8:	dec00204 	addi	sp,sp,8
81116fdc:	f800283a 	ret

81116fe0 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116fe0:	defffb04 	addi	sp,sp,-20
81116fe4:	de00012e 	bgeu	sp,et,81116fec <vPusType252conf+0xc>
81116fe8:	003b68fa 	trap	3
81116fec:	dfc00415 	stw	ra,16(sp)
81116ff0:	df000315 	stw	fp,12(sp)
81116ff4:	df000304 	addi	fp,sp,12
81116ff8:	e13ffe15 	stw	r4,-8(fp)
81116ffc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81117000:	e0bfff17 	ldw	r2,-4(fp)
81117004:	1080050b 	ldhu	r2,20(r2)
81117008:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
8111700c:	e0bfff17 	ldw	r2,-4(fp)
81117010:	1080038b 	ldhu	r2,14(r2)
81117014:	10bfffcc 	andi	r2,r2,65535
81117018:	10c000a0 	cmpeqi	r3,r2,2
8111701c:	1800121e 	bne	r3,zero,81117068 <vPusType252conf+0x88>
81117020:	10c00090 	cmplti	r3,r2,2
81117024:	18006d1e 	bne	r3,zero,811171dc <vPusType252conf+0x1fc>
81117028:	10800188 	cmpgei	r2,r2,6
8111702c:	10006b1e 	bne	r2,zero,811171dc <vPusType252conf+0x1fc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81117030:	00a045f4 	movhi	r2,33047
81117034:	10a34f04 	addi	r2,r2,-29380
81117038:	10800a8b 	ldhu	r2,42(r2)
8111703c:	10bfffcc 	andi	r2,r2,65535
81117040:	10800168 	cmpgeui	r2,r2,5
81117044:	1000731e 	bne	r2,zero,81117214 <vPusType252conf+0x234>
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81117048:	d0a06217 	ldw	r2,-32376(gp)
8111704c:	100f883a 	mov	r7,r2
81117050:	01801384 	movi	r6,78
81117054:	01400044 	movi	r5,1
81117058:	01204574 	movhi	r4,33045
8111705c:	21003704 	addi	r4,r4,220
81117060:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
81117064:	00006b06 	br	81117214 <vPusType252conf+0x234>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117068:	e0bffd0b 	ldhu	r2,-12(fp)
8111706c:	10809824 	muli	r2,r2,608
81117070:	10805704 	addi	r2,r2,348
81117074:	e0fffe17 	ldw	r3,-8(fp)
81117078:	1885883a 	add	r2,r3,r2
8111707c:	1009883a 	mov	r4,r2
81117080:	11081a00 	call	811081a0 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81117084:	e0bffd0b 	ldhu	r2,-12(fp)
81117088:	e0fffe17 	ldw	r3,-8(fp)
8111708c:	10809824 	muli	r2,r2,608
81117090:	1885883a 	add	r2,r3,r2
81117094:	10806704 	addi	r2,r2,412
81117098:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111709c:	e0bffd0b 	ldhu	r2,-12(fp)
811170a0:	10809824 	muli	r2,r2,608
811170a4:	10805704 	addi	r2,r2,348
811170a8:	e0fffe17 	ldw	r3,-8(fp)
811170ac:	1885883a 	add	r2,r3,r2
811170b0:	1009883a 	mov	r4,r2
811170b4:	11080f40 	call	811080f4 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811170b8:	e0bffd0b 	ldhu	r2,-12(fp)
811170bc:	10809824 	muli	r2,r2,608
811170c0:	10805704 	addi	r2,r2,348
811170c4:	e0fffe17 	ldw	r3,-8(fp)
811170c8:	1885883a 	add	r2,r3,r2
811170cc:	1009883a 	mov	r4,r2
811170d0:	110838c0 	call	8110838c <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811170d4:	e0bffd0b 	ldhu	r2,-12(fp)
811170d8:	e0ffff17 	ldw	r3,-4(fp)
811170dc:	18c00b0b 	ldhu	r3,44(r3)
811170e0:	1809883a 	mov	r4,r3
811170e4:	e0fffe17 	ldw	r3,-8(fp)
811170e8:	10809824 	muli	r2,r2,608
811170ec:	1885883a 	add	r2,r3,r2
811170f0:	10805804 	addi	r2,r2,352
811170f4:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811170f8:	e0bffd0b 	ldhu	r2,-12(fp)
811170fc:	e0ffff17 	ldw	r3,-4(fp)
81117100:	18c0098b 	ldhu	r3,38(r3)
81117104:	1809883a 	mov	r4,r3
81117108:	e0fffe17 	ldw	r3,-8(fp)
8111710c:	10809824 	muli	r2,r2,608
81117110:	1885883a 	add	r2,r3,r2
81117114:	10805844 	addi	r2,r2,353
81117118:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111711c:	e0bffd0b 	ldhu	r2,-12(fp)
81117120:	10809824 	muli	r2,r2,608
81117124:	10805704 	addi	r2,r2,348
81117128:	e0fffe17 	ldw	r3,-8(fp)
8111712c:	1885883a 	add	r2,r3,r2
81117130:	1009883a 	mov	r4,r2
81117134:	11082b00 	call	811082b0 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117138:	e0bffd0b 	ldhu	r2,-12(fp)
8111713c:	10809824 	muli	r2,r2,608
81117140:	10805704 	addi	r2,r2,348
81117144:	e0fffe17 	ldw	r3,-8(fp)
81117148:	1885883a 	add	r2,r3,r2
8111714c:	1009883a 	mov	r4,r2
81117150:	11081a00 	call	811081a0 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81117154:	e0bffd0b 	ldhu	r2,-12(fp)
81117158:	e0fffe17 	ldw	r3,-8(fp)
8111715c:	10809824 	muli	r2,r2,608
81117160:	1885883a 	add	r2,r3,r2
81117164:	10806704 	addi	r2,r2,412
81117168:	00c00044 	movi	r3,1
8111716c:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117170:	e0bffd0b 	ldhu	r2,-12(fp)
81117174:	10809824 	muli	r2,r2,608
81117178:	10805704 	addi	r2,r2,348
8111717c:	e0fffe17 	ldw	r3,-8(fp)
81117180:	1885883a 	add	r2,r3,r2
81117184:	1009883a 	mov	r4,r2
81117188:	11080f40 	call	811080f4 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111718c:	00a045f4 	movhi	r2,33047
81117190:	10a34f04 	addi	r2,r2,-29380
81117194:	10800a8b 	ldhu	r2,42(r2)
81117198:	10bfffcc 	andi	r2,r2,65535
8111719c:	108000e8 	cmpgeui	r2,r2,3
811171a0:	10001e1e 	bne	r2,zero,8111721c <vPusType252conf+0x23c>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811171a4:	d0e06217 	ldw	r3,-32376(gp)
811171a8:	e0bfff17 	ldw	r2,-4(fp)
811171ac:	10800b0b 	ldhu	r2,44(r2)
811171b0:	113fffcc 	andi	r4,r2,65535
811171b4:	e0bfff17 	ldw	r2,-4(fp)
811171b8:	1080098b 	ldhu	r2,38(r2)
811171bc:	10bfffcc 	andi	r2,r2,65535
811171c0:	100f883a 	mov	r7,r2
811171c4:	200d883a 	mov	r6,r4
811171c8:	01604574 	movhi	r5,33045
811171cc:	29404b04 	addi	r5,r5,300
811171d0:	1809883a 	mov	r4,r3
811171d4:	11236500 	call	81123650 <fprintf>
			}
			#endif

			break;
811171d8:	00001006 	br	8111721c <vPusType252conf+0x23c>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811171dc:	00a045f4 	movhi	r2,33047
811171e0:	10a34f04 	addi	r2,r2,-29380
811171e4:	10800a8b 	ldhu	r2,42(r2)
811171e8:	10bfffcc 	andi	r2,r2,65535
811171ec:	10800228 	cmpgeui	r2,r2,8
811171f0:	10000c1e 	bne	r2,zero,81117224 <vPusType252conf+0x244>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811171f4:	d0a06217 	ldw	r2,-32376(gp)
811171f8:	100f883a 	mov	r7,r2
811171fc:	01800b04 	movi	r6,44
81117200:	01400044 	movi	r5,1
81117204:	01204574 	movhi	r4,33045
81117208:	21001904 	addi	r4,r4,100
8111720c:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
81117210:	00000406 	br	81117224 <vPusType252conf+0x244>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
			}
			#endif
			break;
81117214:	0001883a 	nop
81117218:	00000306 	br	81117228 <vPusType252conf+0x248>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif

			break;
8111721c:	0001883a 	nop
81117220:	00000106 	br	81117228 <vPusType252conf+0x248>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81117224:	0001883a 	nop
	}
}
81117228:	0001883a 	nop
8111722c:	e037883a 	mov	sp,fp
81117230:	dfc00117 	ldw	ra,4(sp)
81117234:	df000017 	ldw	fp,0(sp)
81117238:	dec00204 	addi	sp,sp,8
8111723c:	f800283a 	ret

81117240 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81117240:	defffc04 	addi	sp,sp,-16
81117244:	de00012e 	bgeu	sp,et,8111724c <vPusMebInTaskRunningMode+0xc>
81117248:	003b68fa 	trap	3
8111724c:	dfc00315 	stw	ra,12(sp)
81117250:	df000215 	stw	fp,8(sp)
81117254:	df000204 	addi	fp,sp,8
81117258:	e13ffe15 	stw	r4,-8(fp)
8111725c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81117260:	e0bfff17 	ldw	r2,-4(fp)
81117264:	1080030b 	ldhu	r2,12(r2)
81117268:	10bfffcc 	andi	r2,r2,65535
8111726c:	10c03ee0 	cmpeqi	r3,r2,251
81117270:	1800081e 	bne	r3,zero,81117294 <vPusMebInTaskRunningMode+0x54>
81117274:	10c03f20 	cmpeqi	r3,r2,252
81117278:	18000a1e 	bne	r3,zero,811172a4 <vPusMebInTaskRunningMode+0x64>
8111727c:	10803ea0 	cmpeqi	r2,r2,250
81117280:	10000c26 	beq	r2,zero,811172b4 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81117284:	e17fff17 	ldw	r5,-4(fp)
81117288:	e13ffe17 	ldw	r4,-8(fp)
8111728c:	11173040 	call	81117304 <vPusType250run>
			break;
81117290:	00001606 	br	811172ec <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81117294:	e17fff17 	ldw	r5,-4(fp)
81117298:	e13ffe17 	ldw	r4,-8(fp)
8111729c:	11173b00 	call	811173b0 <vPusType251run>
			break;
811172a0:	00001206 	br	811172ec <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
811172a4:	e17fff17 	ldw	r5,-4(fp)
811172a8:	e13ffe17 	ldw	r4,-8(fp)
811172ac:	11174dc0 	call	811174dc <vPusType252run>
			break;
811172b0:	00000e06 	br	811172ec <vPusMebInTaskRunningMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811172b4:	00a045f4 	movhi	r2,33047
811172b8:	10a34f04 	addi	r2,r2,-29380
811172bc:	10800a8b 	ldhu	r2,42(r2)
811172c0:	10bfffcc 	andi	r2,r2,65535
811172c4:	10800228 	cmpgeui	r2,r2,8
811172c8:	1000071e 	bne	r2,zero,811172e8 <vPusMebInTaskRunningMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
811172cc:	d0a06217 	ldw	r2,-32376(gp)
811172d0:	100f883a 	mov	r7,r2
811172d4:	01800cc4 	movi	r6,51
811172d8:	01400044 	movi	r5,1
811172dc:	01204574 	movhi	r4,33045
811172e0:	21005b04 	addi	r4,r4,364
811172e4:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
811172e8:	0001883a 	nop
	}
}
811172ec:	0001883a 	nop
811172f0:	e037883a 	mov	sp,fp
811172f4:	dfc00117 	ldw	ra,4(sp)
811172f8:	df000017 	ldw	fp,0(sp)
811172fc:	dec00204 	addi	sp,sp,8
81117300:	f800283a 	ret

81117304 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81117304:	defffc04 	addi	sp,sp,-16
81117308:	de00012e 	bgeu	sp,et,81117310 <vPusType250run+0xc>
8111730c:	003b68fa 	trap	3
81117310:	dfc00315 	stw	ra,12(sp)
81117314:	df000215 	stw	fp,8(sp)
81117318:	df000204 	addi	fp,sp,8
8111731c:	e13ffe15 	stw	r4,-8(fp)
81117320:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81117324:	e0bfff17 	ldw	r2,-4(fp)
81117328:	1080038b 	ldhu	r2,14(r2)
8111732c:	10bfffcc 	andi	r2,r2,65535
81117330:	10c00f20 	cmpeqi	r3,r2,60
81117334:	1800031e 	bne	r3,zero,81117344 <vPusType250run+0x40>
81117338:	10800fa0 	cmpeqi	r2,r2,62
8111733c:	1000131e 	bne	r2,zero,8111738c <vPusType250run+0x88>
81117340:	00000406 	br	81117354 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81117344:	e0bffe17 	ldw	r2,-8(fp)
81117348:	00c00044 	movi	r3,1
8111734c:	10c00115 	stw	r3,4(r2)
			break;
81117350:	00001106 	br	81117398 <vPusType250run+0x94>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81117354:	00a045f4 	movhi	r2,33047
81117358:	10a34f04 	addi	r2,r2,-29380
8111735c:	10800a8b 	ldhu	r2,42(r2)
81117360:	10bfffcc 	andi	r2,r2,65535
81117364:	10800228 	cmpgeui	r2,r2,8
81117368:	10000a1e 	bne	r2,zero,81117394 <vPusType250run+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
8111736c:	d0a06217 	ldw	r2,-32376(gp)
81117370:	100f883a 	mov	r7,r2
81117374:	01800c84 	movi	r6,50
81117378:	01400044 	movi	r5,1
8111737c:	01204574 	movhi	r4,33045
81117380:	21006804 	addi	r4,r4,416
81117384:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
81117388:	00000206 	br	81117394 <vPusType250run+0x90>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111738c:	0001883a 	nop
81117390:	00000106 	br	81117398 <vPusType250run+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
81117394:	0001883a 	nop
	}
}
81117398:	0001883a 	nop
8111739c:	e037883a 	mov	sp,fp
811173a0:	dfc00117 	ldw	ra,4(sp)
811173a4:	df000017 	ldw	fp,0(sp)
811173a8:	dec00204 	addi	sp,sp,8
811173ac:	f800283a 	ret

811173b0 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811173b0:	defffb04 	addi	sp,sp,-20
811173b4:	de00012e 	bgeu	sp,et,811173bc <vPusType251run+0xc>
811173b8:	003b68fa 	trap	3
811173bc:	dfc00415 	stw	ra,16(sp)
811173c0:	df000315 	stw	fp,12(sp)
811173c4:	df000304 	addi	fp,sp,12
811173c8:	e13ffe15 	stw	r4,-8(fp)
811173cc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811173d0:	e0bfff17 	ldw	r2,-4(fp)
811173d4:	1080050b 	ldhu	r2,20(r2)
811173d8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811173dc:	e0bfff17 	ldw	r2,-4(fp)
811173e0:	1080038b 	ldhu	r2,14(r2)
811173e4:	10bfffcc 	andi	r2,r2,65535
811173e8:	10c000a0 	cmpeqi	r3,r2,2
811173ec:	18000f1e 	bne	r3,zero,8111742c <vPusType251run+0x7c>
811173f0:	10c00160 	cmpeqi	r3,r2,5
811173f4:	1800181e 	bne	r3,zero,81117458 <vPusType251run+0xa8>
811173f8:	10800060 	cmpeqi	r2,r2,1
811173fc:	10002126 	beq	r2,zero,81117484 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81117400:	e0bffd0b 	ldhu	r2,-12(fp)
81117404:	10800444 	addi	r2,r2,17
81117408:	10803fcc 	andi	r2,r2,255
8111740c:	e0fffd0b 	ldhu	r3,-12(fp)
81117410:	18c03fcc 	andi	r3,r3,255
81117414:	180f883a 	mov	r7,r3
81117418:	000d883a 	mov	r6,zero
8111741c:	01400044 	movi	r5,1
81117420:	1009883a 	mov	r4,r2
81117424:	1117a0c0 	call	81117a0c <vSendCmdQToNFeeCTRL_GEN>
			break;
81117428:	00002606 	br	811174c4 <vPusType251run+0x114>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
8111742c:	e0bffd0b 	ldhu	r2,-12(fp)
81117430:	10800444 	addi	r2,r2,17
81117434:	10803fcc 	andi	r2,r2,255
81117438:	e0fffd0b 	ldhu	r3,-12(fp)
8111743c:	18c03fcc 	andi	r3,r3,255
81117440:	180f883a 	mov	r7,r3
81117444:	000d883a 	mov	r6,zero
81117448:	01400104 	movi	r5,4
8111744c:	1009883a 	mov	r4,r2
81117450:	1117a0c0 	call	81117a0c <vSendCmdQToNFeeCTRL_GEN>
			break;
81117454:	00001b06 	br	811174c4 <vPusType251run+0x114>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81117458:	e0bffd0b 	ldhu	r2,-12(fp)
8111745c:	10800444 	addi	r2,r2,17
81117460:	10803fcc 	andi	r2,r2,255
81117464:	e0fffd0b 	ldhu	r3,-12(fp)
81117468:	18c03fcc 	andi	r3,r3,255
8111746c:	180f883a 	mov	r7,r3
81117470:	000d883a 	mov	r6,zero
81117474:	01400204 	movi	r5,8
81117478:	1009883a 	mov	r4,r2
8111747c:	1117a0c0 	call	81117a0c <vSendCmdQToNFeeCTRL_GEN>
			break;
81117480:	00001006 	br	811174c4 <vPusType251run+0x114>
		case 3:
		case 4:
		case 6:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81117484:	00a045f4 	movhi	r2,33047
81117488:	10a34f04 	addi	r2,r2,-29380
8111748c:	10800a8b 	ldhu	r2,42(r2)
81117490:	10bfffcc 	andi	r2,r2,65535
81117494:	10800228 	cmpgeui	r2,r2,8
81117498:	1000091e 	bne	r2,zero,811174c0 <vPusType251run+0x110>
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
8111749c:	d0e06217 	ldw	r3,-32376(gp)
811174a0:	e0bfff17 	ldw	r2,-4(fp)
811174a4:	1080038b 	ldhu	r2,14(r2)
811174a8:	10bfffcc 	andi	r2,r2,65535
811174ac:	100d883a 	mov	r6,r2
811174b0:	01604574 	movhi	r5,33045
811174b4:	29407504 	addi	r5,r5,468
811174b8:	1809883a 	mov	r4,r3
811174bc:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
811174c0:	0001883a 	nop
	}
}
811174c4:	0001883a 	nop
811174c8:	e037883a 	mov	sp,fp
811174cc:	dfc00117 	ldw	ra,4(sp)
811174d0:	df000017 	ldw	fp,0(sp)
811174d4:	dec00204 	addi	sp,sp,8
811174d8:	f800283a 	ret

811174dc <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811174dc:	defffb04 	addi	sp,sp,-20
811174e0:	de00012e 	bgeu	sp,et,811174e8 <vPusType252run+0xc>
811174e4:	003b68fa 	trap	3
811174e8:	dfc00415 	stw	ra,16(sp)
811174ec:	df000315 	stw	fp,12(sp)
811174f0:	df000304 	addi	fp,sp,12
811174f4:	e13ffe15 	stw	r4,-8(fp)
811174f8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811174fc:	e0bfff17 	ldw	r2,-4(fp)
81117500:	1080050b 	ldhu	r2,20(r2)
81117504:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81117508:	e0bfff17 	ldw	r2,-4(fp)
8111750c:	1080038b 	ldhu	r2,14(r2)
81117510:	10bfffcc 	andi	r2,r2,65535
81117514:	10c000e0 	cmpeqi	r3,r2,3
81117518:	18000a1e 	bne	r3,zero,81117544 <vPusType252run+0x68>
8111751c:	10c00108 	cmpgei	r3,r2,4
81117520:	1800031e 	bne	r3,zero,81117530 <vPusType252run+0x54>
81117524:	108000a0 	cmpeqi	r2,r2,2
81117528:	1000641e 	bne	r2,zero,811176bc <vPusType252run+0x1e0>
8111752c:	0000d606 	br	81117888 <vPusType252run+0x3ac>
81117530:	10c00120 	cmpeqi	r3,r2,4
81117534:	1800321e 	bne	r3,zero,81117600 <vPusType252run+0x124>
81117538:	10800160 	cmpeqi	r2,r2,5
8111753c:	1000e01e 	bne	r2,zero,811178c0 <vPusType252run+0x3e4>
81117540:	0000d106 	br	81117888 <vPusType252run+0x3ac>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81117544:	e0bffd0b 	ldhu	r2,-12(fp)
81117548:	10809824 	muli	r2,r2,608
8111754c:	10809d04 	addi	r2,r2,628
81117550:	e0fffe17 	ldw	r3,-8(fp)
81117554:	1885883a 	add	r2,r3,r2
81117558:	1009883a 	mov	r4,r2
8111755c:	110ac5c0 	call	8110ac5c <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81117560:	e0bffd0b 	ldhu	r2,-12(fp)
81117564:	e0fffe17 	ldw	r3,-8(fp)
81117568:	10809824 	muli	r2,r2,608
8111756c:	1885883a 	add	r2,r3,r2
81117570:	10809f04 	addi	r2,r2,636
81117574:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81117578:	e0bffd0b 	ldhu	r2,-12(fp)
8111757c:	e0fffe17 	ldw	r3,-8(fp)
81117580:	10809824 	muli	r2,r2,608
81117584:	1885883a 	add	r2,r3,r2
81117588:	10809e04 	addi	r2,r2,632
8111758c:	00c00044 	movi	r3,1
81117590:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81117594:	e0bffd0b 	ldhu	r2,-12(fp)
81117598:	e0fffe17 	ldw	r3,-8(fp)
8111759c:	10809824 	muli	r2,r2,608
811175a0:	1885883a 	add	r2,r3,r2
811175a4:	1080a004 	addi	r2,r2,640
811175a8:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811175ac:	e0bffd0b 	ldhu	r2,-12(fp)
811175b0:	10809824 	muli	r2,r2,608
811175b4:	10809d04 	addi	r2,r2,628
811175b8:	e0fffe17 	ldw	r3,-8(fp)
811175bc:	1885883a 	add	r2,r3,r2
811175c0:	1009883a 	mov	r4,r2
811175c4:	110ab240 	call	8110ab24 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811175c8:	00a045f4 	movhi	r2,33047
811175cc:	10a34f04 	addi	r2,r2,-29380
811175d0:	10800a8b 	ldhu	r2,42(r2)
811175d4:	10bfffcc 	andi	r2,r2,65535
811175d8:	108000e8 	cmpgeui	r2,r2,3
811175dc:	1000ba1e 	bne	r2,zero,811178c8 <vPusType252run+0x3ec>
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
811175e0:	d0a06217 	ldw	r2,-32376(gp)
811175e4:	e0fffd0b 	ldhu	r3,-12(fp)
811175e8:	180d883a 	mov	r6,r3
811175ec:	01604574 	movhi	r5,33045
811175f0:	29408304 	addi	r5,r5,524
811175f4:	1009883a 	mov	r4,r2
811175f8:	11236500 	call	81123650 <fprintf>
			}
			#endif

			break;
811175fc:	0000b206 	br	811178c8 <vPusType252run+0x3ec>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81117600:	e0bffd0b 	ldhu	r2,-12(fp)
81117604:	10809824 	muli	r2,r2,608
81117608:	10809d04 	addi	r2,r2,628
8111760c:	e0fffe17 	ldw	r3,-8(fp)
81117610:	1885883a 	add	r2,r3,r2
81117614:	1009883a 	mov	r4,r2
81117618:	110ac5c0 	call	8110ac5c <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
8111761c:	e0bffd0b 	ldhu	r2,-12(fp)
81117620:	e0fffe17 	ldw	r3,-8(fp)
81117624:	10809824 	muli	r2,r2,608
81117628:	1885883a 	add	r2,r3,r2
8111762c:	10809f04 	addi	r2,r2,636
81117630:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81117634:	e0bffd0b 	ldhu	r2,-12(fp)
81117638:	e0fffe17 	ldw	r3,-8(fp)
8111763c:	10809824 	muli	r2,r2,608
81117640:	1885883a 	add	r2,r3,r2
81117644:	10809e04 	addi	r2,r2,632
81117648:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
8111764c:	e0bffd0b 	ldhu	r2,-12(fp)
81117650:	e0fffe17 	ldw	r3,-8(fp)
81117654:	10809824 	muli	r2,r2,608
81117658:	1885883a 	add	r2,r3,r2
8111765c:	1080a004 	addi	r2,r2,640
81117660:	00c00044 	movi	r3,1
81117664:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81117668:	e0bffd0b 	ldhu	r2,-12(fp)
8111766c:	10809824 	muli	r2,r2,608
81117670:	10809d04 	addi	r2,r2,628
81117674:	e0fffe17 	ldw	r3,-8(fp)
81117678:	1885883a 	add	r2,r3,r2
8111767c:	1009883a 	mov	r4,r2
81117680:	110ab240 	call	8110ab24 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81117684:	00a045f4 	movhi	r2,33047
81117688:	10a34f04 	addi	r2,r2,-29380
8111768c:	10800a8b 	ldhu	r2,42(r2)
81117690:	10bfffcc 	andi	r2,r2,65535
81117694:	108000e8 	cmpgeui	r2,r2,3
81117698:	10008d1e 	bne	r2,zero,811178d0 <vPusType252run+0x3f4>
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
8111769c:	d0a06217 	ldw	r2,-32376(gp)
811176a0:	e0fffd0b 	ldhu	r3,-12(fp)
811176a4:	180d883a 	mov	r6,r3
811176a8:	01604574 	movhi	r5,33045
811176ac:	29408c04 	addi	r5,r5,560
811176b0:	1009883a 	mov	r4,r2
811176b4:	11236500 	call	81123650 <fprintf>
			}
			#endif

			break;
811176b8:	00008506 	br	811178d0 <vPusType252run+0x3f4>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
811176bc:	e0bffd0b 	ldhu	r2,-12(fp)
811176c0:	e0fffe17 	ldw	r3,-8(fp)
811176c4:	10809824 	muli	r2,r2,608
811176c8:	1885883a 	add	r2,r3,r2
811176cc:	10803e04 	addi	r2,r2,248
811176d0:	10800017 	ldw	r2,0(r2)
811176d4:	10800058 	cmpnei	r2,r2,1
811176d8:	10004a1e 	bne	r2,zero,81117804 <vPusType252run+0x328>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811176dc:	e0bffd0b 	ldhu	r2,-12(fp)
811176e0:	10809824 	muli	r2,r2,608
811176e4:	10805704 	addi	r2,r2,348
811176e8:	e0fffe17 	ldw	r3,-8(fp)
811176ec:	1885883a 	add	r2,r3,r2
811176f0:	1009883a 	mov	r4,r2
811176f4:	11081a00 	call	811081a0 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
811176f8:	e0bffd0b 	ldhu	r2,-12(fp)
811176fc:	e0fffe17 	ldw	r3,-8(fp)
81117700:	10809824 	muli	r2,r2,608
81117704:	1885883a 	add	r2,r3,r2
81117708:	10806704 	addi	r2,r2,412
8111770c:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117710:	e0bffd0b 	ldhu	r2,-12(fp)
81117714:	10809824 	muli	r2,r2,608
81117718:	10805704 	addi	r2,r2,348
8111771c:	e0fffe17 	ldw	r3,-8(fp)
81117720:	1885883a 	add	r2,r3,r2
81117724:	1009883a 	mov	r4,r2
81117728:	11080f40 	call	811080f4 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111772c:	e0bffd0b 	ldhu	r2,-12(fp)
81117730:	10809824 	muli	r2,r2,608
81117734:	10805704 	addi	r2,r2,348
81117738:	e0fffe17 	ldw	r3,-8(fp)
8111773c:	1885883a 	add	r2,r3,r2
81117740:	1009883a 	mov	r4,r2
81117744:	110838c0 	call	8110838c <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81117748:	e0bffd0b 	ldhu	r2,-12(fp)
8111774c:	e0ffff17 	ldw	r3,-4(fp)
81117750:	18c00b0b 	ldhu	r3,44(r3)
81117754:	1809883a 	mov	r4,r3
81117758:	e0fffe17 	ldw	r3,-8(fp)
8111775c:	10809824 	muli	r2,r2,608
81117760:	1885883a 	add	r2,r3,r2
81117764:	10805804 	addi	r2,r2,352
81117768:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
8111776c:	e0bffd0b 	ldhu	r2,-12(fp)
81117770:	e0ffff17 	ldw	r3,-4(fp)
81117774:	18c0098b 	ldhu	r3,38(r3)
81117778:	1809883a 	mov	r4,r3
8111777c:	e0fffe17 	ldw	r3,-8(fp)
81117780:	10809824 	muli	r2,r2,608
81117784:	1885883a 	add	r2,r3,r2
81117788:	10805844 	addi	r2,r2,353
8111778c:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81117790:	e0bffd0b 	ldhu	r2,-12(fp)
81117794:	10809824 	muli	r2,r2,608
81117798:	10805704 	addi	r2,r2,348
8111779c:	e0fffe17 	ldw	r3,-8(fp)
811177a0:	1885883a 	add	r2,r3,r2
811177a4:	1009883a 	mov	r4,r2
811177a8:	11082b00 	call	811082b0 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811177ac:	e0bffd0b 	ldhu	r2,-12(fp)
811177b0:	10809824 	muli	r2,r2,608
811177b4:	10805704 	addi	r2,r2,348
811177b8:	e0fffe17 	ldw	r3,-8(fp)
811177bc:	1885883a 	add	r2,r3,r2
811177c0:	1009883a 	mov	r4,r2
811177c4:	11081a00 	call	811081a0 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811177c8:	e0bffd0b 	ldhu	r2,-12(fp)
811177cc:	e0fffe17 	ldw	r3,-8(fp)
811177d0:	10809824 	muli	r2,r2,608
811177d4:	1885883a 	add	r2,r3,r2
811177d8:	10806704 	addi	r2,r2,412
811177dc:	00c00044 	movi	r3,1
811177e0:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811177e4:	e0bffd0b 	ldhu	r2,-12(fp)
811177e8:	10809824 	muli	r2,r2,608
811177ec:	10805704 	addi	r2,r2,348
811177f0:	e0fffe17 	ldw	r3,-8(fp)
811177f4:	1885883a 	add	r2,r3,r2
811177f8:	1009883a 	mov	r4,r2
811177fc:	11080f40 	call	811080f4 <bRmapSetIrqControl>
81117800:	00000d06 	br	81117838 <vPusType252run+0x35c>
			} else {
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81117804:	00a045f4 	movhi	r2,33047
81117808:	10a34f04 	addi	r2,r2,-29380
8111780c:	10800a8b 	ldhu	r2,42(r2)
81117810:	10bfffcc 	andi	r2,r2,65535
81117814:	10800168 	cmpgeui	r2,r2,5
81117818:	1000071e 	bne	r2,zero,81117838 <vPusType252run+0x35c>
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
8111781c:	d0a06217 	ldw	r2,-32376(gp)
81117820:	e0fffd0b 	ldhu	r3,-12(fp)
81117824:	180d883a 	mov	r6,r3
81117828:	01604574 	movhi	r5,33045
8111782c:	29409504 	addi	r5,r5,596
81117830:	1009883a 	mov	r4,r2
81117834:	11236500 	call	81123650 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81117838:	00a045f4 	movhi	r2,33047
8111783c:	10a34f04 	addi	r2,r2,-29380
81117840:	10800a8b 	ldhu	r2,42(r2)
81117844:	10bfffcc 	andi	r2,r2,65535
81117848:	108000e8 	cmpgeui	r2,r2,3
8111784c:	1000221e 	bne	r2,zero,811178d8 <vPusType252run+0x3fc>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81117850:	d0e06217 	ldw	r3,-32376(gp)
81117854:	e0bfff17 	ldw	r2,-4(fp)
81117858:	10800b0b 	ldhu	r2,44(r2)
8111785c:	113fffcc 	andi	r4,r2,65535
81117860:	e0bfff17 	ldw	r2,-4(fp)
81117864:	1080098b 	ldhu	r2,38(r2)
81117868:	10bfffcc 	andi	r2,r2,65535
8111786c:	100f883a 	mov	r7,r2
81117870:	200d883a 	mov	r6,r4
81117874:	01604574 	movhi	r5,33045
81117878:	29404b04 	addi	r5,r5,300
8111787c:	1809883a 	mov	r4,r3
81117880:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
81117884:	00001406 	br	811178d8 <vPusType252run+0x3fc>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81117888:	00a045f4 	movhi	r2,33047
8111788c:	10a34f04 	addi	r2,r2,-29380
81117890:	10800a8b 	ldhu	r2,42(r2)
81117894:	10bfffcc 	andi	r2,r2,65535
81117898:	10800168 	cmpgeui	r2,r2,5
8111789c:	1000101e 	bne	r2,zero,811178e0 <vPusType252run+0x404>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
811178a0:	d0a06217 	ldw	r2,-32376(gp)
811178a4:	100f883a 	mov	r7,r2
811178a8:	01800c84 	movi	r6,50
811178ac:	01400044 	movi	r5,1
811178b0:	01204574 	movhi	r4,33045
811178b4:	21006804 	addi	r4,r4,416
811178b8:	1123cec0 	call	81123cec <fwrite>
			}
			#endif
			break;
811178bc:	00000806 	br	811178e0 <vPusType252run+0x404>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
811178c0:	0001883a 	nop
811178c4:	00000706 	br	811178e4 <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
811178c8:	0001883a 	nop
811178cc:	00000506 	br	811178e4 <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
811178d0:	0001883a 	nop
811178d4:	00000306 	br	811178e4 <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif
			break;
811178d8:	0001883a 	nop
811178dc:	00000106 	br	811178e4 <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
811178e0:	0001883a 	nop
	}
}
811178e4:	0001883a 	nop
811178e8:	e037883a 	mov	sp,fp
811178ec:	dfc00117 	ldw	ra,4(sp)
811178f0:	df000017 	ldw	fp,0(sp)
811178f4:	dec00204 	addi	sp,sp,8
811178f8:	f800283a 	ret

811178fc <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811178fc:	defff904 	addi	sp,sp,-28
81117900:	de00012e 	bgeu	sp,et,81117908 <vSendCmdQToNFeeCTRL+0xc>
81117904:	003b68fa 	trap	3
81117908:	dfc00615 	stw	ra,24(sp)
8111790c:	df000515 	stw	fp,20(sp)
81117910:	df000504 	addi	fp,sp,20
81117914:	2807883a 	mov	r3,r5
81117918:	3005883a 	mov	r2,r6
8111791c:	e13ffd05 	stb	r4,-12(fp)
81117920:	e0fffe05 	stb	r3,-8(fp)
81117924:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81117928:	00800404 	movi	r2,16
8111792c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81117930:	e0bffd03 	ldbu	r2,-12(fp)
81117934:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117938:	e0bffe03 	ldbu	r2,-8(fp)
8111793c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81117940:	e0bfff03 	ldbu	r2,-4(fp)
81117944:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81117948:	d0a07017 	ldw	r2,-32320(gp)
8111794c:	e0fffc17 	ldw	r3,-16(fp)
81117950:	180b883a 	mov	r5,r3
81117954:	1009883a 	mov	r4,r2
81117958:	114001c0 	call	8114001c <OSQPost>
8111795c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81117960:	e0bffb03 	ldbu	r2,-20(fp)
81117964:	10000126 	beq	r2,zero,8111796c <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81117968:	111f6480 	call	8111f648 <vFailSendMsgFeeCTRL>
	}
}
8111796c:	0001883a 	nop
81117970:	e037883a 	mov	sp,fp
81117974:	dfc00117 	ldw	ra,4(sp)
81117978:	df000017 	ldw	fp,0(sp)
8111797c:	dec00204 	addi	sp,sp,8
81117980:	f800283a 	ret

81117984 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117984:	defff904 	addi	sp,sp,-28
81117988:	de00012e 	bgeu	sp,et,81117990 <vSendCmdQToNFeeCTRL_PRIO+0xc>
8111798c:	003b68fa 	trap	3
81117990:	dfc00615 	stw	ra,24(sp)
81117994:	df000515 	stw	fp,20(sp)
81117998:	df000504 	addi	fp,sp,20
8111799c:	2807883a 	mov	r3,r5
811179a0:	3005883a 	mov	r2,r6
811179a4:	e13ffd05 	stb	r4,-12(fp)
811179a8:	e0fffe05 	stb	r3,-8(fp)
811179ac:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811179b0:	00800404 	movi	r2,16
811179b4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811179b8:	e0bffd03 	ldbu	r2,-12(fp)
811179bc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811179c0:	e0bffe03 	ldbu	r2,-8(fp)
811179c4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811179c8:	e0bfff03 	ldbu	r2,-4(fp)
811179cc:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811179d0:	d0a07017 	ldw	r2,-32320(gp)
811179d4:	e0fffc17 	ldw	r3,-16(fp)
811179d8:	180b883a 	mov	r5,r3
811179dc:	1009883a 	mov	r4,r2
811179e0:	114018c0 	call	8114018c <OSQPostFront>
811179e4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811179e8:	e0bffb03 	ldbu	r2,-20(fp)
811179ec:	10000126 	beq	r2,zero,811179f4 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811179f0:	111f6480 	call	8111f648 <vFailSendMsgFeeCTRL>
	}
}
811179f4:	0001883a 	nop
811179f8:	e037883a 	mov	sp,fp
811179fc:	dfc00117 	ldw	ra,4(sp)
81117a00:	df000017 	ldw	fp,0(sp)
81117a04:	dec00204 	addi	sp,sp,8
81117a08:	f800283a 	ret

81117a0c <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117a0c:	defff804 	addi	sp,sp,-32
81117a10:	de00012e 	bgeu	sp,et,81117a18 <vSendCmdQToNFeeCTRL_GEN+0xc>
81117a14:	003b68fa 	trap	3
81117a18:	dfc00715 	stw	ra,28(sp)
81117a1c:	df000615 	stw	fp,24(sp)
81117a20:	df000604 	addi	fp,sp,24
81117a24:	2011883a 	mov	r8,r4
81117a28:	2809883a 	mov	r4,r5
81117a2c:	3007883a 	mov	r3,r6
81117a30:	3805883a 	mov	r2,r7
81117a34:	e23ffc05 	stb	r8,-16(fp)
81117a38:	e13ffd05 	stb	r4,-12(fp)
81117a3c:	e0fffe05 	stb	r3,-8(fp)
81117a40:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81117a44:	e0bffc03 	ldbu	r2,-16(fp)
81117a48:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81117a4c:	e0bffd03 	ldbu	r2,-12(fp)
81117a50:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117a54:	e0bffe03 	ldbu	r2,-8(fp)
81117a58:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81117a5c:	e0bfff03 	ldbu	r2,-4(fp)
81117a60:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81117a64:	d0a07017 	ldw	r2,-32320(gp)
81117a68:	e0fffb17 	ldw	r3,-20(fp)
81117a6c:	180b883a 	mov	r5,r3
81117a70:	1009883a 	mov	r4,r2
81117a74:	114001c0 	call	8114001c <OSQPost>
81117a78:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81117a7c:	e0bffa03 	ldbu	r2,-24(fp)
81117a80:	10000126 	beq	r2,zero,81117a88 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81117a84:	111f6480 	call	8111f648 <vFailSendMsgFeeCTRL>
	}
}
81117a88:	0001883a 	nop
81117a8c:	e037883a 	mov	sp,fp
81117a90:	dfc00117 	ldw	ra,4(sp)
81117a94:	df000017 	ldw	fp,0(sp)
81117a98:	dec00204 	addi	sp,sp,8
81117a9c:	f800283a 	ret

81117aa0 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117aa0:	defff904 	addi	sp,sp,-28
81117aa4:	de00012e 	bgeu	sp,et,81117aac <vSendCmdQToDataCTRL+0xc>
81117aa8:	003b68fa 	trap	3
81117aac:	dfc00615 	stw	ra,24(sp)
81117ab0:	df000515 	stw	fp,20(sp)
81117ab4:	df000504 	addi	fp,sp,20
81117ab8:	2807883a 	mov	r3,r5
81117abc:	3005883a 	mov	r2,r6
81117ac0:	e13ffd05 	stb	r4,-12(fp)
81117ac4:	e0fffe05 	stb	r3,-8(fp)
81117ac8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81117acc:	00800804 	movi	r2,32
81117ad0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81117ad4:	e0bffd03 	ldbu	r2,-12(fp)
81117ad8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117adc:	e0bffe03 	ldbu	r2,-8(fp)
81117ae0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81117ae4:	e0bfff03 	ldbu	r2,-4(fp)
81117ae8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81117aec:	d0a05f17 	ldw	r2,-32388(gp)
81117af0:	e0fffc17 	ldw	r3,-16(fp)
81117af4:	180b883a 	mov	r5,r3
81117af8:	1009883a 	mov	r4,r2
81117afc:	114001c0 	call	8114001c <OSQPost>
81117b00:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81117b04:	e0bffb03 	ldbu	r2,-20(fp)
81117b08:	10000126 	beq	r2,zero,81117b10 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81117b0c:	111f6ac0 	call	8111f6ac <vFailSendMsgDataCTRL>
	}
}
81117b10:	0001883a 	nop
81117b14:	e037883a 	mov	sp,fp
81117b18:	dfc00117 	ldw	ra,4(sp)
81117b1c:	df000017 	ldw	fp,0(sp)
81117b20:	dec00204 	addi	sp,sp,8
81117b24:	f800283a 	ret

81117b28 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117b28:	defff904 	addi	sp,sp,-28
81117b2c:	de00012e 	bgeu	sp,et,81117b34 <vSendCmdQToDataCTRL_PRIO+0xc>
81117b30:	003b68fa 	trap	3
81117b34:	dfc00615 	stw	ra,24(sp)
81117b38:	df000515 	stw	fp,20(sp)
81117b3c:	df000504 	addi	fp,sp,20
81117b40:	2807883a 	mov	r3,r5
81117b44:	3005883a 	mov	r2,r6
81117b48:	e13ffd05 	stb	r4,-12(fp)
81117b4c:	e0fffe05 	stb	r3,-8(fp)
81117b50:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81117b54:	00800404 	movi	r2,16
81117b58:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81117b5c:	e0bffd03 	ldbu	r2,-12(fp)
81117b60:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117b64:	e0bffe03 	ldbu	r2,-8(fp)
81117b68:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81117b6c:	e0bfff03 	ldbu	r2,-4(fp)
81117b70:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81117b74:	d0a05f17 	ldw	r2,-32388(gp)
81117b78:	e0fffc17 	ldw	r3,-16(fp)
81117b7c:	180b883a 	mov	r5,r3
81117b80:	1009883a 	mov	r4,r2
81117b84:	114018c0 	call	8114018c <OSQPostFront>
81117b88:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81117b8c:	e0bffb03 	ldbu	r2,-20(fp)
81117b90:	10000126 	beq	r2,zero,81117b98 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81117b94:	111f6480 	call	8111f648 <vFailSendMsgFeeCTRL>
	}
}
81117b98:	0001883a 	nop
81117b9c:	e037883a 	mov	sp,fp
81117ba0:	dfc00117 	ldw	ra,4(sp)
81117ba4:	df000017 	ldw	fp,0(sp)
81117ba8:	dec00204 	addi	sp,sp,8
81117bac:	f800283a 	ret

81117bb0 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81117bb0:	defffc04 	addi	sp,sp,-16
81117bb4:	de00012e 	bgeu	sp,et,81117bbc <vMebInit+0xc>
81117bb8:	003b68fa 	trap	3
81117bbc:	dfc00315 	stw	ra,12(sp)
81117bc0:	df000215 	stw	fp,8(sp)
81117bc4:	df000204 	addi	fp,sp,8
81117bc8:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81117bcc:	e0bfff17 	ldw	r2,-4(fp)
81117bd0:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81117bd4:	e0bfff17 	ldw	r2,-4(fp)
81117bd8:	00c00044 	movi	r3,1
81117bdc:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81117be0:	d0a06917 	ldw	r2,-32348(gp)
81117be4:	1009883a 	mov	r4,r2
81117be8:	113fb540 	call	8113fb54 <OSQFlush>
81117bec:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81117bf0:	e0bffe03 	ldbu	r2,-8(fp)
81117bf4:	10000126 	beq	r2,zero,81117bfc <vMebInit+0x4c>
		vFailFlushMEBQueue();
81117bf8:	111f7d80 	call	8111f7d8 <vFailFlushMEBQueue>
	}
}
81117bfc:	0001883a 	nop
81117c00:	e037883a 	mov	sp,fp
81117c04:	dfc00117 	ldw	ra,4(sp)
81117c08:	df000017 	ldw	fp,0(sp)
81117c0c:	dec00204 	addi	sp,sp,8
81117c10:	f800283a 	ret

81117c14 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81117c14:	defffe04 	addi	sp,sp,-8
81117c18:	de00012e 	bgeu	sp,et,81117c20 <vSwapMemmory+0xc>
81117c1c:	003b68fa 	trap	3
81117c20:	df000115 	stw	fp,4(sp)
81117c24:	df000104 	addi	fp,sp,4
81117c28:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81117c2c:	e0bfff17 	ldw	r2,-4(fp)
81117c30:	10800203 	ldbu	r2,8(r2)
81117c34:	10803fcc 	andi	r2,r2,255
81117c38:	10c00044 	addi	r3,r2,1
81117c3c:	00a00034 	movhi	r2,32768
81117c40:	10800044 	addi	r2,r2,1
81117c44:	1884703a 	and	r2,r3,r2
81117c48:	1000040e 	bge	r2,zero,81117c5c <vSwapMemmory+0x48>
81117c4c:	10bfffc4 	addi	r2,r2,-1
81117c50:	00ffff84 	movi	r3,-2
81117c54:	10c4b03a 	or	r2,r2,r3
81117c58:	10800044 	addi	r2,r2,1
81117c5c:	1007883a 	mov	r3,r2
81117c60:	e0bfff17 	ldw	r2,-4(fp)
81117c64:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81117c68:	e0bfff17 	ldw	r2,-4(fp)
81117c6c:	10800243 	ldbu	r2,9(r2)
81117c70:	10803fcc 	andi	r2,r2,255
81117c74:	10c00044 	addi	r3,r2,1
81117c78:	00a00034 	movhi	r2,32768
81117c7c:	10800044 	addi	r2,r2,1
81117c80:	1884703a 	and	r2,r3,r2
81117c84:	1000040e 	bge	r2,zero,81117c98 <vSwapMemmory+0x84>
81117c88:	10bfffc4 	addi	r2,r2,-1
81117c8c:	00ffff84 	movi	r3,-2
81117c90:	10c4b03a 	or	r2,r2,r3
81117c94:	10800044 	addi	r2,r2,1
81117c98:	1007883a 	mov	r3,r2
81117c9c:	e0bfff17 	ldw	r2,-4(fp)
81117ca0:	10c00245 	stb	r3,9(r2)

}
81117ca4:	0001883a 	nop
81117ca8:	e037883a 	mov	sp,fp
81117cac:	df000017 	ldw	fp,0(sp)
81117cb0:	dec00104 	addi	sp,sp,4
81117cb4:	f800283a 	ret

81117cb8 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81117cb8:	defffc04 	addi	sp,sp,-16
81117cbc:	de00012e 	bgeu	sp,et,81117cc4 <vReleaseSyncMessages+0xc>
81117cc0:	003b68fa 	trap	3
81117cc4:	dfc00315 	stw	ra,12(sp)
81117cc8:	df000215 	stw	fp,8(sp)
81117ccc:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81117cd0:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81117cd4:	00bff844 	movi	r2,-31
81117cd8:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81117cdc:	e03ffe05 	stb	zero,-8(fp)
81117ce0:	00001606 	br	81117d3c <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
81117ce4:	e0bffe03 	ldbu	r2,-8(fp)
81117ce8:	10800444 	addi	r2,r2,17
81117cec:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81117cf0:	e0bffe03 	ldbu	r2,-8(fp)
81117cf4:	1085883a 	add	r2,r2,r2
81117cf8:	1087883a 	add	r3,r2,r2
81117cfc:	d0a05c04 	addi	r2,gp,-32400
81117d00:	1885883a 	add	r2,r3,r2
81117d04:	10800017 	ldw	r2,0(r2)
81117d08:	e0ffff17 	ldw	r3,-4(fp)
81117d0c:	180b883a 	mov	r5,r3
81117d10:	1009883a 	mov	r4,r2
81117d14:	114001c0 	call	8114001c <OSQPost>
81117d18:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81117d1c:	e0bffe43 	ldbu	r2,-7(fp)
81117d20:	10000326 	beq	r2,zero,81117d30 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81117d24:	e0bffe03 	ldbu	r2,-8(fp)
81117d28:	1009883a 	mov	r4,r2
81117d2c:	111f50c0 	call	8111f50c <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81117d30:	e0bffe03 	ldbu	r2,-8(fp)
81117d34:	10800044 	addi	r2,r2,1
81117d38:	e0bffe05 	stb	r2,-8(fp)
81117d3c:	e0bffe03 	ldbu	r2,-8(fp)
81117d40:	103fe826 	beq	r2,zero,81117ce4 <__reset+0xfb0f7ce4>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81117d44:	0001883a 	nop
81117d48:	e037883a 	mov	sp,fp
81117d4c:	dfc00117 	ldw	ra,4(sp)
81117d50:	df000017 	ldw	fp,0(sp)
81117d54:	dec00204 	addi	sp,sp,8
81117d58:	f800283a 	ret

81117d5c <vStackMonitor>:
    }
}

#else
#if DEBUG_ON
void vStackMonitor(void *task_data) {
81117d5c:	defff804 	addi	sp,sp,-32
81117d60:	de00012e 	bgeu	sp,et,81117d68 <vStackMonitor+0xc>
81117d64:	003b68fa 	trap	3
81117d68:	dfc00715 	stw	ra,28(sp)
81117d6c:	df000615 	stw	fp,24(sp)
81117d70:	df000604 	addi	fp,sp,24
81117d74:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81117d78:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81117d7c:	d0a06217 	ldw	r2,-32376(gp)
81117d80:	100f883a 	mov	r7,r2
81117d84:	018006c4 	movi	r6,27
81117d88:	01400044 	movi	r5,1
81117d8c:	01204574 	movhi	r4,33045
81117d90:	2100a804 	addi	r4,r4,672
81117d94:	1123cec0 	call	81123cec <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81117d98:	d0a06217 	ldw	r2,-32376(gp)
81117d9c:	100f883a 	mov	r7,r2
81117da0:	01800b04 	movi	r6,44
81117da4:	01400044 	movi	r5,1
81117da8:	01204574 	movhi	r4,33045
81117dac:	2100af04 	addi	r4,r4,700
81117db0:	1123cec0 	call	81123cec <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81117db4:	d0a06217 	ldw	r2,-32376(gp)
81117db8:	100f883a 	mov	r7,r2
81117dbc:	01800f84 	movi	r6,62
81117dc0:	01400044 	movi	r5,1
81117dc4:	01204574 	movhi	r4,33045
81117dc8:	2100bb04 	addi	r4,r4,748
81117dcc:	1123cec0 	call	81123cec <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81117dd0:	e0bffd04 	addi	r2,fp,-12
81117dd4:	100b883a 	mov	r5,r2
81117dd8:	01000804 	movi	r4,32
81117ddc:	11424400 	call	81142440 <OSTaskStkChk>
81117de0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81117de4:	e0bffc03 	ldbu	r2,-16(fp)
81117de8:	10000f1e 	bne	r2,zero,81117e28 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117dec:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81117df0:	e0fffd17 	ldw	r3,-12(fp)
81117df4:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117df8:	188b883a 	add	r5,r3,r2
81117dfc:	e0bffd17 	ldw	r2,-12(fp)
81117e00:	e0fffe17 	ldw	r3,-8(fp)
81117e04:	d8c00115 	stw	r3,4(sp)
81117e08:	d8800015 	stw	r2,0(sp)
81117e0c:	280f883a 	mov	r7,r5
81117e10:	01a04574 	movhi	r6,33045
81117e14:	3180cb04 	addi	r6,r6,812
81117e18:	01604574 	movhi	r5,33045
81117e1c:	2940cf04 	addi	r5,r5,828
81117e20:	11236500 	call	81123650 <fprintf>
81117e24:	00000706 	br	81117e44 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81117e28:	d0a06217 	ldw	r2,-32376(gp)
81117e2c:	100f883a 	mov	r7,r2
81117e30:	01800904 	movi	r6,36
81117e34:	01400044 	movi	r5,1
81117e38:	01204574 	movhi	r4,33045
81117e3c:	2100de04 	addi	r4,r4,888
81117e40:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81117e44:	e0bffd04 	addi	r2,fp,-12
81117e48:	100b883a 	mov	r5,r2
81117e4c:	01000784 	movi	r4,30
81117e50:	11424400 	call	81142440 <OSTaskStkChk>
81117e54:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117e58:	e0bffc03 	ldbu	r2,-16(fp)
81117e5c:	10000f1e 	bne	r2,zero,81117e9c <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117e60:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81117e64:	e0fffd17 	ldw	r3,-12(fp)
81117e68:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117e6c:	188b883a 	add	r5,r3,r2
81117e70:	e0bffd17 	ldw	r2,-12(fp)
81117e74:	e0fffe17 	ldw	r3,-8(fp)
81117e78:	d8c00115 	stw	r3,4(sp)
81117e7c:	d8800015 	stw	r2,0(sp)
81117e80:	280f883a 	mov	r7,r5
81117e84:	01a04574 	movhi	r6,33045
81117e88:	3180e804 	addi	r6,r6,928
81117e8c:	01604574 	movhi	r5,33045
81117e90:	2940cf04 	addi	r5,r5,828
81117e94:	11236500 	call	81123650 <fprintf>
81117e98:	00000706 	br	81117eb8 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81117e9c:	d0a06217 	ldw	r2,-32376(gp)
81117ea0:	100f883a 	mov	r7,r2
81117ea4:	01800984 	movi	r6,38
81117ea8:	01400044 	movi	r5,1
81117eac:	01204574 	movhi	r4,33045
81117eb0:	2100ec04 	addi	r4,r4,944
81117eb4:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81117eb8:	e0bffd04 	addi	r2,fp,-12
81117ebc:	100b883a 	mov	r5,r2
81117ec0:	01000704 	movi	r4,28
81117ec4:	11424400 	call	81142440 <OSTaskStkChk>
81117ec8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117ecc:	e0bffc03 	ldbu	r2,-16(fp)
81117ed0:	10000f1e 	bne	r2,zero,81117f10 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117ed4:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81117ed8:	e0fffd17 	ldw	r3,-12(fp)
81117edc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117ee0:	188b883a 	add	r5,r3,r2
81117ee4:	e0bffd17 	ldw	r2,-12(fp)
81117ee8:	e0fffe17 	ldw	r3,-8(fp)
81117eec:	d8c00115 	stw	r3,4(sp)
81117ef0:	d8800015 	stw	r2,0(sp)
81117ef4:	280f883a 	mov	r7,r5
81117ef8:	01a04574 	movhi	r6,33045
81117efc:	3180f604 	addi	r6,r6,984
81117f00:	01604574 	movhi	r5,33045
81117f04:	2940cf04 	addi	r5,r5,828
81117f08:	11236500 	call	81123650 <fprintf>
81117f0c:	00000706 	br	81117f2c <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81117f10:	d0a06217 	ldw	r2,-32376(gp)
81117f14:	100f883a 	mov	r7,r2
81117f18:	01800884 	movi	r6,34
81117f1c:	01400044 	movi	r5,1
81117f20:	01204574 	movhi	r4,33045
81117f24:	2100f904 	addi	r4,r4,996
81117f28:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81117f2c:	e0bffd04 	addi	r2,fp,-12
81117f30:	100b883a 	mov	r5,r2
81117f34:	010006c4 	movi	r4,27
81117f38:	11424400 	call	81142440 <OSTaskStkChk>
81117f3c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117f40:	e0bffc03 	ldbu	r2,-16(fp)
81117f44:	10000f1e 	bne	r2,zero,81117f84 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117f48:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81117f4c:	e0fffd17 	ldw	r3,-12(fp)
81117f50:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117f54:	188b883a 	add	r5,r3,r2
81117f58:	e0bffd17 	ldw	r2,-12(fp)
81117f5c:	e0fffe17 	ldw	r3,-8(fp)
81117f60:	d8c00115 	stw	r3,4(sp)
81117f64:	d8800015 	stw	r2,0(sp)
81117f68:	280f883a 	mov	r7,r5
81117f6c:	01a04574 	movhi	r6,33045
81117f70:	31810204 	addi	r6,r6,1032
81117f74:	01604574 	movhi	r5,33045
81117f78:	2940cf04 	addi	r5,r5,828
81117f7c:	11236500 	call	81123650 <fprintf>
81117f80:	00000706 	br	81117fa0 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81117f84:	d0a06217 	ldw	r2,-32376(gp)
81117f88:	100f883a 	mov	r7,r2
81117f8c:	018008c4 	movi	r6,35
81117f90:	01400044 	movi	r5,1
81117f94:	01204574 	movhi	r4,33045
81117f98:	21010604 	addi	r4,r4,1048
81117f9c:	1123cec0 	call	81123cec <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81117fa0:	e0bffd04 	addi	r2,fp,-12
81117fa4:	100b883a 	mov	r5,r2
81117fa8:	01000684 	movi	r4,26
81117fac:	11424400 	call	81142440 <OSTaskStkChk>
81117fb0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117fb4:	e0bffc03 	ldbu	r2,-16(fp)
81117fb8:	10000f1e 	bne	r2,zero,81117ff8 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117fbc:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81117fc0:	e0fffd17 	ldw	r3,-12(fp)
81117fc4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117fc8:	188b883a 	add	r5,r3,r2
81117fcc:	e0bffd17 	ldw	r2,-12(fp)
81117fd0:	e0fffe17 	ldw	r3,-8(fp)
81117fd4:	d8c00115 	stw	r3,4(sp)
81117fd8:	d8800015 	stw	r2,0(sp)
81117fdc:	280f883a 	mov	r7,r5
81117fe0:	01a04574 	movhi	r6,33045
81117fe4:	31810f04 	addi	r6,r6,1084
81117fe8:	01604574 	movhi	r5,33045
81117fec:	2940cf04 	addi	r5,r5,828
81117ff0:	11236500 	call	81123650 <fprintf>
81117ff4:	00000706 	br	81118014 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81117ff8:	d0a06217 	ldw	r2,-32376(gp)
81117ffc:	100f883a 	mov	r7,r2
81118000:	01800884 	movi	r6,34
81118004:	01400044 	movi	r5,1
81118008:	01204574 	movhi	r4,33045
8111800c:	21011204 	addi	r4,r4,1096
81118010:	1123cec0 	call	81123cec <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81118014:	e0bffd04 	addi	r2,fp,-12
81118018:	100b883a 	mov	r5,r2
8111801c:	01000644 	movi	r4,25
81118020:	11424400 	call	81142440 <OSTaskStkChk>
81118024:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81118028:	e0bffc03 	ldbu	r2,-16(fp)
8111802c:	10000f1e 	bne	r2,zero,8111806c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118030:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81118034:	e0fffd17 	ldw	r3,-12(fp)
81118038:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111803c:	188b883a 	add	r5,r3,r2
81118040:	e0bffd17 	ldw	r2,-12(fp)
81118044:	e0fffe17 	ldw	r3,-8(fp)
81118048:	d8c00115 	stw	r3,4(sp)
8111804c:	d8800015 	stw	r2,0(sp)
81118050:	280f883a 	mov	r7,r5
81118054:	01a04574 	movhi	r6,33045
81118058:	31811b04 	addi	r6,r6,1132
8111805c:	01604574 	movhi	r5,33045
81118060:	2940cf04 	addi	r5,r5,828
81118064:	11236500 	call	81123650 <fprintf>
81118068:	00000706 	br	81118088 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8111806c:	d0a06217 	ldw	r2,-32376(gp)
81118070:	100f883a 	mov	r7,r2
81118074:	01800884 	movi	r6,34
81118078:	01400044 	movi	r5,1
8111807c:	01204574 	movhi	r4,33045
81118080:	21011e04 	addi	r4,r4,1144
81118084:	1123cec0 	call	81123cec <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81118088:	e0bffd04 	addi	r2,fp,-12
8111808c:	100b883a 	mov	r5,r2
81118090:	01000044 	movi	r4,1
81118094:	11424400 	call	81142440 <OSTaskStkChk>
81118098:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111809c:	e0bffc03 	ldbu	r2,-16(fp)
811180a0:	10000f1e 	bne	r2,zero,811180e0 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811180a4:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
811180a8:	e0fffd17 	ldw	r3,-12(fp)
811180ac:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811180b0:	188b883a 	add	r5,r3,r2
811180b4:	e0bffd17 	ldw	r2,-12(fp)
811180b8:	e0fffe17 	ldw	r3,-8(fp)
811180bc:	d8c00115 	stw	r3,4(sp)
811180c0:	d8800015 	stw	r2,0(sp)
811180c4:	280f883a 	mov	r7,r5
811180c8:	01a04574 	movhi	r6,33045
811180cc:	31812704 	addi	r6,r6,1180
811180d0:	01604574 	movhi	r5,33045
811180d4:	2940cf04 	addi	r5,r5,828
811180d8:	11236500 	call	81123650 <fprintf>
811180dc:	00000706 	br	811180fc <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
811180e0:	d0a06217 	ldw	r2,-32376(gp)
811180e4:	100f883a 	mov	r7,r2
811180e8:	01800804 	movi	r6,32
811180ec:	01400044 	movi	r5,1
811180f0:	01204574 	movhi	r4,33045
811180f4:	21012a04 	addi	r4,r4,1192
811180f8:	1123cec0 	call	81123cec <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
811180fc:	e0bffd04 	addi	r2,fp,-12
81118100:	100b883a 	mov	r5,r2
81118104:	010002c4 	movi	r4,11
81118108:	11424400 	call	81142440 <OSTaskStkChk>
8111810c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81118110:	e0bffc03 	ldbu	r2,-16(fp)
81118114:	10000f1e 	bne	r2,zero,81118154 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118118:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
8111811c:	e0fffd17 	ldw	r3,-12(fp)
81118120:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118124:	188b883a 	add	r5,r3,r2
81118128:	e0bffd17 	ldw	r2,-12(fp)
8111812c:	e0fffe17 	ldw	r3,-8(fp)
81118130:	d8c00115 	stw	r3,4(sp)
81118134:	d8800015 	stw	r2,0(sp)
81118138:	280f883a 	mov	r7,r5
8111813c:	01a04574 	movhi	r6,33045
81118140:	31813304 	addi	r6,r6,1228
81118144:	01604574 	movhi	r5,33045
81118148:	2940cf04 	addi	r5,r5,828
8111814c:	11236500 	call	81123650 <fprintf>
81118150:	00000706 	br	81118170 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81118154:	d0a06217 	ldw	r2,-32376(gp)
81118158:	100f883a 	mov	r7,r2
8111815c:	018008c4 	movi	r6,35
81118160:	01400044 	movi	r5,1
81118164:	01204574 	movhi	r4,33045
81118168:	21013604 	addi	r4,r4,1240
8111816c:	1123cec0 	call	81123cec <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81118170:	e0bffd04 	addi	r2,fp,-12
81118174:	100b883a 	mov	r5,r2
81118178:	01000304 	movi	r4,12
8111817c:	11424400 	call	81142440 <OSTaskStkChk>
81118180:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81118184:	e0bffc03 	ldbu	r2,-16(fp)
81118188:	10000f1e 	bne	r2,zero,811181c8 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111818c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81118190:	e0fffd17 	ldw	r3,-12(fp)
81118194:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118198:	188b883a 	add	r5,r3,r2
8111819c:	e0bffd17 	ldw	r2,-12(fp)
811181a0:	e0fffe17 	ldw	r3,-8(fp)
811181a4:	d8c00115 	stw	r3,4(sp)
811181a8:	d8800015 	stw	r2,0(sp)
811181ac:	280f883a 	mov	r7,r5
811181b0:	01a04574 	movhi	r6,33045
811181b4:	31813f04 	addi	r6,r6,1276
811181b8:	01604574 	movhi	r5,33045
811181bc:	2940cf04 	addi	r5,r5,828
811181c0:	11236500 	call	81123650 <fprintf>
811181c4:	00000706 	br	811181e4 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
811181c8:	d0a06217 	ldw	r2,-32376(gp)
811181cc:	100f883a 	mov	r7,r2
811181d0:	018008c4 	movi	r6,35
811181d4:	01400044 	movi	r5,1
811181d8:	01204574 	movhi	r4,33045
811181dc:	21014204 	addi	r4,r4,1288
811181e0:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
811181e4:	e0bffd04 	addi	r2,fp,-12
811181e8:	100b883a 	mov	r5,r2
811181ec:	01000344 	movi	r4,13
811181f0:	11424400 	call	81142440 <OSTaskStkChk>
811181f4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811181f8:	e0bffc03 	ldbu	r2,-16(fp)
811181fc:	10000f1e 	bne	r2,zero,8111823c <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118200:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81118204:	e0fffd17 	ldw	r3,-12(fp)
81118208:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111820c:	188b883a 	add	r5,r3,r2
81118210:	e0bffd17 	ldw	r2,-12(fp)
81118214:	e0fffe17 	ldw	r3,-8(fp)
81118218:	d8c00115 	stw	r3,4(sp)
8111821c:	d8800015 	stw	r2,0(sp)
81118220:	280f883a 	mov	r7,r5
81118224:	01a04574 	movhi	r6,33045
81118228:	31814b04 	addi	r6,r6,1324
8111822c:	01604574 	movhi	r5,33045
81118230:	2940cf04 	addi	r5,r5,828
81118234:	11236500 	call	81123650 <fprintf>
81118238:	00000706 	br	81118258 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
8111823c:	d0a06217 	ldw	r2,-32376(gp)
81118240:	100f883a 	mov	r7,r2
81118244:	018008c4 	movi	r6,35
81118248:	01400044 	movi	r5,1
8111824c:	01204574 	movhi	r4,33045
81118250:	21014e04 	addi	r4,r4,1336
81118254:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81118258:	e0bffd04 	addi	r2,fp,-12
8111825c:	100b883a 	mov	r5,r2
81118260:	01000384 	movi	r4,14
81118264:	11424400 	call	81142440 <OSTaskStkChk>
81118268:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111826c:	e0bffc03 	ldbu	r2,-16(fp)
81118270:	10000f1e 	bne	r2,zero,811182b0 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118274:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81118278:	e0fffd17 	ldw	r3,-12(fp)
8111827c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118280:	188b883a 	add	r5,r3,r2
81118284:	e0bffd17 	ldw	r2,-12(fp)
81118288:	e0fffe17 	ldw	r3,-8(fp)
8111828c:	d8c00115 	stw	r3,4(sp)
81118290:	d8800015 	stw	r2,0(sp)
81118294:	280f883a 	mov	r7,r5
81118298:	01a04574 	movhi	r6,33045
8111829c:	31815704 	addi	r6,r6,1372
811182a0:	01604574 	movhi	r5,33045
811182a4:	2940cf04 	addi	r5,r5,828
811182a8:	11236500 	call	81123650 <fprintf>
811182ac:	00000706 	br	811182cc <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
811182b0:	d0a06217 	ldw	r2,-32376(gp)
811182b4:	100f883a 	mov	r7,r2
811182b8:	018008c4 	movi	r6,35
811182bc:	01400044 	movi	r5,1
811182c0:	01204574 	movhi	r4,33045
811182c4:	21015a04 	addi	r4,r4,1384
811182c8:	1123cec0 	call	81123cec <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
811182cc:	e0bffd04 	addi	r2,fp,-12
811182d0:	100b883a 	mov	r5,r2
811182d4:	010003c4 	movi	r4,15
811182d8:	11424400 	call	81142440 <OSTaskStkChk>
811182dc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811182e0:	e0bffc03 	ldbu	r2,-16(fp)
811182e4:	10000f1e 	bne	r2,zero,81118324 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811182e8:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
811182ec:	e0fffd17 	ldw	r3,-12(fp)
811182f0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811182f4:	188b883a 	add	r5,r3,r2
811182f8:	e0bffd17 	ldw	r2,-12(fp)
811182fc:	e0fffe17 	ldw	r3,-8(fp)
81118300:	d8c00115 	stw	r3,4(sp)
81118304:	d8800015 	stw	r2,0(sp)
81118308:	280f883a 	mov	r7,r5
8111830c:	01a04574 	movhi	r6,33045
81118310:	31816304 	addi	r6,r6,1420
81118314:	01604574 	movhi	r5,33045
81118318:	2940cf04 	addi	r5,r5,828
8111831c:	11236500 	call	81123650 <fprintf>
81118320:	00000706 	br	81118340 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81118324:	d0a06217 	ldw	r2,-32376(gp)
81118328:	100f883a 	mov	r7,r2
8111832c:	018008c4 	movi	r6,35
81118330:	01400044 	movi	r5,1
81118334:	01204574 	movhi	r4,33045
81118338:	21016604 	addi	r4,r4,1432
8111833c:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81118340:	e0bffd04 	addi	r2,fp,-12
81118344:	100b883a 	mov	r5,r2
81118348:	01000404 	movi	r4,16
8111834c:	11424400 	call	81142440 <OSTaskStkChk>
81118350:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81118354:	e0bffc03 	ldbu	r2,-16(fp)
81118358:	10000f1e 	bne	r2,zero,81118398 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111835c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81118360:	e0fffd17 	ldw	r3,-12(fp)
81118364:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118368:	188b883a 	add	r5,r3,r2
8111836c:	e0bffd17 	ldw	r2,-12(fp)
81118370:	e0fffe17 	ldw	r3,-8(fp)
81118374:	d8c00115 	stw	r3,4(sp)
81118378:	d8800015 	stw	r2,0(sp)
8111837c:	280f883a 	mov	r7,r5
81118380:	01a04574 	movhi	r6,33045
81118384:	31816f04 	addi	r6,r6,1468
81118388:	01604574 	movhi	r5,33045
8111838c:	2940cf04 	addi	r5,r5,828
81118390:	11236500 	call	81123650 <fprintf>
81118394:	00000706 	br	811183b4 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81118398:	d0a06217 	ldw	r2,-32376(gp)
8111839c:	100f883a 	mov	r7,r2
811183a0:	018008c4 	movi	r6,35
811183a4:	01400044 	movi	r5,1
811183a8:	01204574 	movhi	r4,33045
811183ac:	21017204 	addi	r4,r4,1480
811183b0:	1123cec0 	call	81123cec <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
811183b4:	e0bffd04 	addi	r2,fp,-12
811183b8:	100b883a 	mov	r5,r2
811183bc:	01000284 	movi	r4,10
811183c0:	11424400 	call	81142440 <OSTaskStkChk>
811183c4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811183c8:	e0bffc03 	ldbu	r2,-16(fp)
811183cc:	10000f1e 	bne	r2,zero,8111840c <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811183d0:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
811183d4:	e0fffd17 	ldw	r3,-12(fp)
811183d8:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811183dc:	188b883a 	add	r5,r3,r2
811183e0:	e0bffd17 	ldw	r2,-12(fp)
811183e4:	e0fffe17 	ldw	r3,-8(fp)
811183e8:	d8c00115 	stw	r3,4(sp)
811183ec:	d8800015 	stw	r2,0(sp)
811183f0:	280f883a 	mov	r7,r5
811183f4:	01a04574 	movhi	r6,33045
811183f8:	31817b04 	addi	r6,r6,1516
811183fc:	01604574 	movhi	r5,33045
81118400:	2940cf04 	addi	r5,r5,828
81118404:	11236500 	call	81123650 <fprintf>
81118408:	00000706 	br	81118428 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
8111840c:	d0a06217 	ldw	r2,-32376(gp)
81118410:	100f883a 	mov	r7,r2
81118414:	01800884 	movi	r6,34
81118418:	01400044 	movi	r5,1
8111841c:	01204574 	movhi	r4,33045
81118420:	21017e04 	addi	r4,r4,1528
81118424:	1123cec0 	call	81123cec <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81118428:	e0bffd04 	addi	r2,fp,-12
8111842c:	100b883a 	mov	r5,r2
81118430:	01000244 	movi	r4,9
81118434:	11424400 	call	81142440 <OSTaskStkChk>
81118438:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111843c:	e0bffc03 	ldbu	r2,-16(fp)
81118440:	10000f1e 	bne	r2,zero,81118480 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118444:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81118448:	e0fffd17 	ldw	r3,-12(fp)
8111844c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118450:	188b883a 	add	r5,r3,r2
81118454:	e0bffd17 	ldw	r2,-12(fp)
81118458:	e0fffe17 	ldw	r3,-8(fp)
8111845c:	d8c00115 	stw	r3,4(sp)
81118460:	d8800015 	stw	r2,0(sp)
81118464:	280f883a 	mov	r7,r5
81118468:	01a04574 	movhi	r6,33045
8111846c:	31818704 	addi	r6,r6,1564
81118470:	01604574 	movhi	r5,33045
81118474:	2940cf04 	addi	r5,r5,828
81118478:	11236500 	call	81123650 <fprintf>
8111847c:	00000706 	br	8111849c <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81118480:	d0a06217 	ldw	r2,-32376(gp)
81118484:	100f883a 	mov	r7,r2
81118488:	01800844 	movi	r6,33
8111848c:	01400044 	movi	r5,1
81118490:	01204574 	movhi	r4,33045
81118494:	21018a04 	addi	r4,r4,1576
81118498:	1123cec0 	call	81123cec <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
8111849c:	e0bffd04 	addi	r2,fp,-12
811184a0:	100b883a 	mov	r5,r2
811184a4:	01000204 	movi	r4,8
811184a8:	11424400 	call	81142440 <OSTaskStkChk>
811184ac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811184b0:	e0bffc03 	ldbu	r2,-16(fp)
811184b4:	10000f1e 	bne	r2,zero,811184f4 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811184b8:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
811184bc:	e0fffd17 	ldw	r3,-12(fp)
811184c0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811184c4:	188b883a 	add	r5,r3,r2
811184c8:	e0bffd17 	ldw	r2,-12(fp)
811184cc:	e0fffe17 	ldw	r3,-8(fp)
811184d0:	d8c00115 	stw	r3,4(sp)
811184d4:	d8800015 	stw	r2,0(sp)
811184d8:	280f883a 	mov	r7,r5
811184dc:	01a04574 	movhi	r6,33045
811184e0:	31819304 	addi	r6,r6,1612
811184e4:	01604574 	movhi	r5,33045
811184e8:	2940cf04 	addi	r5,r5,828
811184ec:	11236500 	call	81123650 <fprintf>
811184f0:	00000706 	br	81118510 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
811184f4:	d0a06217 	ldw	r2,-32376(gp)
811184f8:	100f883a 	mov	r7,r2
811184fc:	018007c4 	movi	r6,31
81118500:	01400044 	movi	r5,1
81118504:	01204574 	movhi	r4,33045
81118508:	21019604 	addi	r4,r4,1624
8111850c:	1123cec0 	call	81123cec <fwrite>
    	}		


    	fprintf(fp, "\n" );
81118510:	d0a06217 	ldw	r2,-32376(gp)
81118514:	100b883a 	mov	r5,r2
81118518:	01000284 	movi	r4,10
8111851c:	11236c80 	call	811236c8 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81118520:	000f883a 	mov	r7,zero
81118524:	01800284 	movi	r6,10
81118528:	000b883a 	mov	r5,zero
8111852c:	0009883a 	mov	r4,zero
81118530:	1142aa40 	call	81142aa4 <OSTimeDlyHMSM>
    }
81118534:	003e1806 	br	81117d98 <__reset+0xfb0f7d98>

81118538 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81118538:	defffc04 	addi	sp,sp,-16
8111853c:	de00012e 	bgeu	sp,et,81118544 <vTimeoutCheckerTaskv2+0xc>
81118540:	003b68fa 	trap	3
81118544:	dfc00315 	stw	ra,12(sp)
81118548:	df000215 	stw	fp,8(sp)
8111854c:	df000204 	addi	fp,sp,8
81118550:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81118554:	e03ffe05 	stb	zero,-8(fp)

    #if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118558:	00a045f4 	movhi	r2,33047
8111855c:	10a34f04 	addi	r2,r2,-29380
81118560:	10800a8b 	ldhu	r2,42(r2)
81118564:	10bfffcc 	andi	r2,r2,65535
81118568:	10800168 	cmpgeui	r2,r2,5
8111856c:	1000071e 	bne	r2,zero,8111858c <vTimeoutCheckerTaskv2+0x54>
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81118570:	d0a06217 	ldw	r2,-32376(gp)
81118574:	100f883a 	mov	r7,r2
81118578:	01800844 	movi	r6,33
8111857c:	01400044 	movi	r5,1
81118580:	01204574 	movhi	r4,33045
81118584:	21019e04 	addi	r4,r4,1656
81118588:	1123cec0 	call	81123cec <fwrite>
	}
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
8111858c:	d0a06717 	ldw	r2,-32356(gp)
81118590:	e1bffe04 	addi	r6,fp,-8
81118594:	000b883a 	mov	r5,zero
81118598:	1009883a 	mov	r4,r2
8111859c:	1140b0c0 	call	81140b0c <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
811185a0:	e0bffe03 	ldbu	r2,-8(fp)
811185a4:	10803fcc 	andi	r2,r2,255
811185a8:	1000021e 	bne	r2,zero,811185b4 <vTimeoutCheckerTaskv2+0x7c>
            /* Just check the restransmission buffer */
            vCheck();
811185ac:	11185bc0 	call	811185bc <vCheck>
811185b0:	003ff606 	br	8111858c <__reset+0xfb0f858c>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
811185b4:	111e36c0 	call	8111e36c <vFailGetBlockingSemTimeoutTask>
        }
    }
811185b8:	003ff406 	br	8111858c <__reset+0xfb0f858c>

811185bc <vCheck>:
}


void vCheck( void ) {
811185bc:	defffd04 	addi	sp,sp,-12
811185c0:	de00012e 	bgeu	sp,et,811185c8 <vCheck+0xc>
811185c4:	003b68fa 	trap	3
811185c8:	dfc00215 	stw	ra,8(sp)
811185cc:	df000115 	stw	fp,4(sp)
811185d0:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
811185d4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
811185d8:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
811185dc:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
811185e0:	d0a06883 	ldbu	r2,-32350(gp)
811185e4:	10803fcc 	andi	r2,r2,255
811185e8:	10800218 	cmpnei	r2,r2,8
811185ec:	1000021e 	bne	r2,zero,811185f8 <vCheck+0x3c>
811185f0:	00c00104 	movi	r3,4
811185f4:	00000106 	br	811185fc <vCheck+0x40>
811185f8:	0007883a 	mov	r3,zero
811185fc:	d0a07503 	ldbu	r2,-32300(gp)
81118600:	10803fcc 	andi	r2,r2,255
81118604:	10800218 	cmpnei	r2,r2,8
81118608:	1000021e 	bne	r2,zero,81118614 <vCheck+0x58>
8111860c:	00800084 	movi	r2,2
81118610:	00000106 	br	81118618 <vCheck+0x5c>
81118614:	0005883a 	mov	r2,zero
81118618:	1884b03a 	or	r2,r3,r2
8111861c:	1007883a 	mov	r3,r2
81118620:	d0a07543 	ldbu	r2,-32299(gp)
81118624:	10803fcc 	andi	r2,r2,255
81118628:	108001a0 	cmpeqi	r2,r2,6
8111862c:	1884b03a 	or	r2,r3,r2
81118630:	1007883a 	mov	r3,r2
81118634:	e0bfff03 	ldbu	r2,-4(fp)
81118638:	1884b03a 	or	r2,r3,r2
8111863c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81118640:	e0bfff03 	ldbu	r2,-4(fp)
81118644:	108001d8 	cmpnei	r2,r2,7
81118648:	10003d26 	beq	r2,zero,81118740 <vCheck+0x184>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
8111864c:	d0a07417 	ldw	r2,-32304(gp)
81118650:	e0ffff44 	addi	r3,fp,-3
81118654:	180d883a 	mov	r6,r3
81118658:	000b883a 	mov	r5,zero
8111865c:	1009883a 	mov	r4,r2
81118660:	113eb000 	call	8113eb00 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81118664:	e0bfff43 	ldbu	r2,-3(fp)
81118668:	10803fcc 	andi	r2,r2,255
8111866c:	10000e26 	beq	r2,zero,811186a8 <vCheck+0xec>
        /* Should never get here, is a blocking operation */
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118670:	00a045f4 	movhi	r2,33047
81118674:	10a34f04 	addi	r2,r2,-29380
81118678:	10800a8b 	ldhu	r2,42(r2)
8111867c:	10bfffcc 	andi	r2,r2,65535
81118680:	10800228 	cmpgeui	r2,r2,8
81118684:	1000301e 	bne	r2,zero,81118748 <vCheck+0x18c>
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81118688:	d0a06217 	ldw	r2,-32376(gp)
8111868c:	100f883a 	mov	r7,r2
81118690:	01800f04 	movi	r6,60
81118694:	01400044 	movi	r5,1
81118698:	01204574 	movhi	r4,33045
8111869c:	2101a704 	addi	r4,r4,1692
811186a0:	1123cec0 	call	81123cec <fwrite>
    	}
		#endif
        return;
811186a4:	00002806 	br	81118748 <vCheck+0x18c>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
811186a8:	e0bfff03 	ldbu	r2,-4(fp)
811186ac:	1080004c 	andi	r2,r2,1
811186b0:	10803fcc 	andi	r2,r2,255
811186b4:	1000021e 	bne	r2,zero,811186c0 <vCheck+0x104>
        vCheckRetransmission128();
811186b8:	11187600 	call	81118760 <vCheckRetransmission128>
811186bc:	00000506 	br	811186d4 <vCheck+0x118>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
811186c0:	01800604 	movi	r6,24
811186c4:	000b883a 	mov	r5,zero
811186c8:	012045b4 	movhi	r4,33046
811186cc:	21036d04 	addi	r4,r4,3508
811186d0:	11248500 	call	81124850 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
811186d4:	e0bfff03 	ldbu	r2,-4(fp)
811186d8:	1080008c 	andi	r2,r2,2
811186dc:	10803fcc 	andi	r2,r2,255
811186e0:	1000021e 	bne	r2,zero,811186ec <vCheck+0x130>
        vCheckRetransmission64();
811186e4:	11189e40 	call	811189e4 <vCheckRetransmission64>
811186e8:	00000506 	br	81118700 <vCheck+0x144>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
811186ec:	01800804 	movi	r6,32
811186f0:	000b883a 	mov	r5,zero
811186f4:	012045b4 	movhi	r4,33046
811186f8:	21037304 	addi	r4,r4,3532
811186fc:	11248500 	call	81124850 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81118700:	e0bfff03 	ldbu	r2,-4(fp)
81118704:	1080010c 	andi	r2,r2,4
81118708:	10803fcc 	andi	r2,r2,255
8111870c:	1000021e 	bne	r2,zero,81118718 <vCheck+0x15c>
        vCheckRetransmission32();
81118710:	1118c700 	call	81118c70 <vCheckRetransmission32>
81118714:	00000506 	br	8111872c <vCheck+0x170>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81118718:	01800804 	movi	r6,32
8111871c:	000b883a 	mov	r5,zero
81118720:	012045b4 	movhi	r4,33046
81118724:	21037b04 	addi	r4,r4,3564
81118728:	11248500 	call	81124850 <memset>


    OSMutexPost(xTxUARTMutex);
8111872c:	d0a07417 	ldw	r2,-32304(gp)
81118730:	1009883a 	mov	r4,r2
81118734:	113f0a40 	call	8113f0a4 <OSMutexPost>

    return;
81118738:	0001883a 	nop
8111873c:	00000306 	br	8111874c <vCheck+0x190>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81118740:	0001883a 	nop
81118744:	00000106 	br	8111874c <vCheck+0x190>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
    	}
		#endif
        return;
81118748:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
8111874c:	e037883a 	mov	sp,fp
81118750:	dfc00117 	ldw	ra,4(sp)
81118754:	df000017 	ldw	fp,0(sp)
81118758:	dec00204 	addi	sp,sp,8
8111875c:	f800283a 	ret

81118760 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81118760:	defffd04 	addi	sp,sp,-12
81118764:	de00012e 	bgeu	sp,et,8111876c <vCheckRetransmission128+0xc>
81118768:	003b68fa 	trap	3
8111876c:	dfc00215 	stw	ra,8(sp)
81118770:	df000115 	stw	fp,4(sp)
81118774:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81118778:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8111877c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81118780:	d0a06e17 	ldw	r2,-32328(gp)
81118784:	e0ffff44 	addi	r3,fp,-3
81118788:	180b883a 	mov	r5,r3
8111878c:	1009883a 	mov	r4,r2
81118790:	113e4800 	call	8113e480 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81118794:	e0bfff43 	ldbu	r2,-3(fp)
81118798:	10803fcc 	andi	r2,r2,255
8111879c:	10008b1e 	bne	r2,zero,811189cc <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811187a0:	e03fff05 	stb	zero,-4(fp)
811187a4:	00008106 	br	811189ac <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
811187a8:	e0ffff03 	ldbu	r3,-4(fp)
811187ac:	00a045b4 	movhi	r2,33046
811187b0:	10836d04 	addi	r2,r2,3508
811187b4:	18c7883a 	add	r3,r3,r3
811187b8:	18c7883a 	add	r3,r3,r3
811187bc:	10c5883a 	add	r2,r2,r3
811187c0:	10800017 	ldw	r2,0(r2)
811187c4:	10800058 	cmpnei	r2,r2,1
811187c8:	1000751e 	bne	r2,zero,811189a0 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
811187cc:	e0ffff03 	ldbu	r3,-4(fp)
811187d0:	00a045b4 	movhi	r2,33046
811187d4:	10838b04 	addi	r2,r2,3628
811187d8:	18c02324 	muli	r3,r3,140
811187dc:	10c5883a 	add	r2,r2,r3
811187e0:	10802004 	addi	r2,r2,128
811187e4:	10800017 	ldw	r2,0(r2)
811187e8:	10800058 	cmpnei	r2,r2,1
811187ec:	1000211e 	bne	r2,zero,81118874 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
811187f0:	e0ffff03 	ldbu	r3,-4(fp)
811187f4:	00a045b4 	movhi	r2,33046
811187f8:	10838b04 	addi	r2,r2,3628
811187fc:	19002324 	muli	r4,r3,140
81118800:	1105883a 	add	r2,r2,r4
81118804:	10802184 	addi	r2,r2,134
81118808:	1080000b 	ldhu	r2,0(r2)
8111880c:	10800044 	addi	r2,r2,1
81118810:	100b883a 	mov	r5,r2
81118814:	00a045b4 	movhi	r2,33046
81118818:	10838b04 	addi	r2,r2,3628
8111881c:	19002324 	muli	r4,r3,140
81118820:	1105883a 	add	r2,r2,r4
81118824:	10802184 	addi	r2,r2,134
81118828:	1140000d 	sth	r5,0(r2)
8111882c:	00a045b4 	movhi	r2,33046
81118830:	10838b04 	addi	r2,r2,3628
81118834:	18c02324 	muli	r3,r3,140
81118838:	10c5883a 	add	r2,r2,r3
8111883c:	10802184 	addi	r2,r2,134
81118840:	1080000b 	ldhu	r2,0(r2)
81118844:	10bfffcc 	andi	r2,r2,65535
81118848:	10a0001c 	xori	r2,r2,32768
8111884c:	10a00004 	addi	r2,r2,-32768
81118850:	10800090 	cmplti	r2,r2,2
81118854:	1000071e 	bne	r2,zero,81118874 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81118858:	e0ffff03 	ldbu	r3,-4(fp)
8111885c:	00a045b4 	movhi	r2,33046
81118860:	10838b04 	addi	r2,r2,3628
81118864:	18c02324 	muli	r3,r3,140
81118868:	10c5883a 	add	r2,r2,r3
8111886c:	10802004 	addi	r2,r2,128
81118870:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81118874:	e0ffff03 	ldbu	r3,-4(fp)
81118878:	00a045b4 	movhi	r2,33046
8111887c:	10838b04 	addi	r2,r2,3628
81118880:	18c02324 	muli	r3,r3,140
81118884:	10c5883a 	add	r2,r2,r3
81118888:	10802004 	addi	r2,r2,128
8111888c:	10800017 	ldw	r2,0(r2)
81118890:	1000431e 	bne	r2,zero,811189a0 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81118894:	e0bfff03 	ldbu	r2,-4(fp)
81118898:	10c02324 	muli	r3,r2,140
8111889c:	00a045b4 	movhi	r2,33046
811188a0:	10838b04 	addi	r2,r2,3628
811188a4:	1885883a 	add	r2,r3,r2
811188a8:	1009883a 	mov	r4,r2
811188ac:	1124c200 	call	81124c20 <puts>
                xBuffer128[ucIL].bSent = TRUE;
811188b0:	e0ffff03 	ldbu	r3,-4(fp)
811188b4:	00a045b4 	movhi	r2,33046
811188b8:	10838b04 	addi	r2,r2,3628
811188bc:	18c02324 	muli	r3,r3,140
811188c0:	10c5883a 	add	r2,r2,r3
811188c4:	10802004 	addi	r2,r2,128
811188c8:	00c00044 	movi	r3,1
811188cc:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
811188d0:	e0ffff03 	ldbu	r3,-4(fp)
811188d4:	00a045b4 	movhi	r2,33046
811188d8:	10838b04 	addi	r2,r2,3628
811188dc:	18c02324 	muli	r3,r3,140
811188e0:	10c5883a 	add	r2,r2,r3
811188e4:	10802184 	addi	r2,r2,134
811188e8:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
811188ec:	e0ffff03 	ldbu	r3,-4(fp)
811188f0:	00a045b4 	movhi	r2,33046
811188f4:	10838b04 	addi	r2,r2,3628
811188f8:	19002324 	muli	r4,r3,140
811188fc:	1105883a 	add	r2,r2,r4
81118900:	10802204 	addi	r2,r2,136
81118904:	10800003 	ldbu	r2,0(r2)
81118908:	10800044 	addi	r2,r2,1
8111890c:	100b883a 	mov	r5,r2
81118910:	00a045b4 	movhi	r2,33046
81118914:	10838b04 	addi	r2,r2,3628
81118918:	19002324 	muli	r4,r3,140
8111891c:	1105883a 	add	r2,r2,r4
81118920:	10802204 	addi	r2,r2,136
81118924:	11400005 	stb	r5,0(r2)
81118928:	00a045b4 	movhi	r2,33046
8111892c:	10838b04 	addi	r2,r2,3628
81118930:	18c02324 	muli	r3,r3,140
81118934:	10c5883a 	add	r2,r2,r3
81118938:	10802204 	addi	r2,r2,136
8111893c:	10800003 	ldbu	r2,0(r2)
81118940:	10803fcc 	andi	r2,r2,255
81118944:	108000b0 	cmpltui	r2,r2,2
81118948:	1000151e 	bne	r2,zero,811189a0 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
8111894c:	e0ffff03 	ldbu	r3,-4(fp)
81118950:	00a045b4 	movhi	r2,33046
81118954:	10836d04 	addi	r2,r2,3508
81118958:	18c7883a 	add	r3,r3,r3
8111895c:	18c7883a 	add	r3,r3,r3
81118960:	10c5883a 	add	r2,r2,r3
81118964:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81118968:	d0a07543 	ldbu	r2,-32299(gp)
8111896c:	10800044 	addi	r2,r2,1
81118970:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81118974:	d0a06317 	ldw	r2,-32372(gp)
81118978:	1009883a 	mov	r4,r2
8111897c:	1140e940 	call	81140e94 <OSSemPost>
81118980:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118984:	e0bfff43 	ldbu	r2,-3(fp)
81118988:	10803fcc 	andi	r2,r2,255
8111898c:	10000426 	beq	r2,zero,811189a0 <vCheckRetransmission128+0x240>
                        SemCount128--;
81118990:	d0a07543 	ldbu	r2,-32299(gp)
81118994:	10bfffc4 	addi	r2,r2,-1
81118998:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111899c:	111da940 	call	8111da94 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811189a0:	e0bfff03 	ldbu	r2,-4(fp)
811189a4:	10800044 	addi	r2,r2,1
811189a8:	e0bfff05 	stb	r2,-4(fp)
811189ac:	e0bfff03 	ldbu	r2,-4(fp)
811189b0:	108001b0 	cmpltui	r2,r2,6
811189b4:	103f7c1e 	bne	r2,zero,811187a8 <__reset+0xfb0f87a8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
811189b8:	d0a06e17 	ldw	r2,-32328(gp)
811189bc:	1009883a 	mov	r4,r2
811189c0:	113f0a40 	call	8113f0a4 <OSMutexPost>

    return;
811189c4:	0001883a 	nop
811189c8:	00000106 	br	811189d0 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811189cc:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
811189d0:	e037883a 	mov	sp,fp
811189d4:	dfc00117 	ldw	ra,4(sp)
811189d8:	df000017 	ldw	fp,0(sp)
811189dc:	dec00204 	addi	sp,sp,8
811189e0:	f800283a 	ret

811189e4 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
811189e4:	defffd04 	addi	sp,sp,-12
811189e8:	de00012e 	bgeu	sp,et,811189f0 <vCheckRetransmission64+0xc>
811189ec:	003b68fa 	trap	3
811189f0:	dfc00215 	stw	ra,8(sp)
811189f4:	df000115 	stw	fp,4(sp)
811189f8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811189fc:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81118a00:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81118a04:	d0a07117 	ldw	r2,-32316(gp)
81118a08:	e0ffff44 	addi	r3,fp,-3
81118a0c:	180b883a 	mov	r5,r3
81118a10:	1009883a 	mov	r4,r2
81118a14:	113e4800 	call	8113e480 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81118a18:	e0bfff43 	ldbu	r2,-3(fp)
81118a1c:	10803fcc 	andi	r2,r2,255
81118a20:	10008d1e 	bne	r2,zero,81118c58 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81118a24:	e03fff05 	stb	zero,-4(fp)
81118a28:	00008306 	br	81118c38 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81118a2c:	e0ffff03 	ldbu	r3,-4(fp)
81118a30:	00a045b4 	movhi	r2,33046
81118a34:	10836d04 	addi	r2,r2,3508
81118a38:	18c00184 	addi	r3,r3,6
81118a3c:	18c7883a 	add	r3,r3,r3
81118a40:	18c7883a 	add	r3,r3,r3
81118a44:	10c5883a 	add	r2,r2,r3
81118a48:	10800017 	ldw	r2,0(r2)
81118a4c:	10800058 	cmpnei	r2,r2,1
81118a50:	1000761e 	bne	r2,zero,81118c2c <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81118a54:	e0ffff03 	ldbu	r3,-4(fp)
81118a58:	00a04574 	movhi	r2,33045
81118a5c:	109f2f04 	addi	r2,r2,31932
81118a60:	18c01324 	muli	r3,r3,76
81118a64:	10c5883a 	add	r2,r2,r3
81118a68:	10801004 	addi	r2,r2,64
81118a6c:	10800017 	ldw	r2,0(r2)
81118a70:	10800058 	cmpnei	r2,r2,1
81118a74:	1000211e 	bne	r2,zero,81118afc <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81118a78:	e0ffff03 	ldbu	r3,-4(fp)
81118a7c:	00a04574 	movhi	r2,33045
81118a80:	109f2f04 	addi	r2,r2,31932
81118a84:	19001324 	muli	r4,r3,76
81118a88:	1105883a 	add	r2,r2,r4
81118a8c:	10801184 	addi	r2,r2,70
81118a90:	1080000b 	ldhu	r2,0(r2)
81118a94:	10800044 	addi	r2,r2,1
81118a98:	100b883a 	mov	r5,r2
81118a9c:	00a04574 	movhi	r2,33045
81118aa0:	109f2f04 	addi	r2,r2,31932
81118aa4:	19001324 	muli	r4,r3,76
81118aa8:	1105883a 	add	r2,r2,r4
81118aac:	10801184 	addi	r2,r2,70
81118ab0:	1140000d 	sth	r5,0(r2)
81118ab4:	00a04574 	movhi	r2,33045
81118ab8:	109f2f04 	addi	r2,r2,31932
81118abc:	18c01324 	muli	r3,r3,76
81118ac0:	10c5883a 	add	r2,r2,r3
81118ac4:	10801184 	addi	r2,r2,70
81118ac8:	1080000b 	ldhu	r2,0(r2)
81118acc:	10bfffcc 	andi	r2,r2,65535
81118ad0:	10a0001c 	xori	r2,r2,32768
81118ad4:	10a00004 	addi	r2,r2,-32768
81118ad8:	10800090 	cmplti	r2,r2,2
81118adc:	1000071e 	bne	r2,zero,81118afc <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81118ae0:	e0ffff03 	ldbu	r3,-4(fp)
81118ae4:	00a04574 	movhi	r2,33045
81118ae8:	109f2f04 	addi	r2,r2,31932
81118aec:	18c01324 	muli	r3,r3,76
81118af0:	10c5883a 	add	r2,r2,r3
81118af4:	10801004 	addi	r2,r2,64
81118af8:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81118afc:	e0ffff03 	ldbu	r3,-4(fp)
81118b00:	00a04574 	movhi	r2,33045
81118b04:	109f2f04 	addi	r2,r2,31932
81118b08:	18c01324 	muli	r3,r3,76
81118b0c:	10c5883a 	add	r2,r2,r3
81118b10:	10801004 	addi	r2,r2,64
81118b14:	10800017 	ldw	r2,0(r2)
81118b18:	1000441e 	bne	r2,zero,81118c2c <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81118b1c:	e0bfff03 	ldbu	r2,-4(fp)
81118b20:	10c01324 	muli	r3,r2,76
81118b24:	00a04574 	movhi	r2,33045
81118b28:	109f2f04 	addi	r2,r2,31932
81118b2c:	1885883a 	add	r2,r3,r2
81118b30:	1009883a 	mov	r4,r2
81118b34:	1124c200 	call	81124c20 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81118b38:	e0ffff03 	ldbu	r3,-4(fp)
81118b3c:	00a04574 	movhi	r2,33045
81118b40:	109f2f04 	addi	r2,r2,31932
81118b44:	18c01324 	muli	r3,r3,76
81118b48:	10c5883a 	add	r2,r2,r3
81118b4c:	10801004 	addi	r2,r2,64
81118b50:	00c00044 	movi	r3,1
81118b54:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81118b58:	e0ffff03 	ldbu	r3,-4(fp)
81118b5c:	00a04574 	movhi	r2,33045
81118b60:	109f2f04 	addi	r2,r2,31932
81118b64:	18c01324 	muli	r3,r3,76
81118b68:	10c5883a 	add	r2,r2,r3
81118b6c:	10801184 	addi	r2,r2,70
81118b70:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81118b74:	e0ffff03 	ldbu	r3,-4(fp)
81118b78:	00a04574 	movhi	r2,33045
81118b7c:	109f2f04 	addi	r2,r2,31932
81118b80:	19001324 	muli	r4,r3,76
81118b84:	1105883a 	add	r2,r2,r4
81118b88:	10801204 	addi	r2,r2,72
81118b8c:	10800003 	ldbu	r2,0(r2)
81118b90:	10800044 	addi	r2,r2,1
81118b94:	100b883a 	mov	r5,r2
81118b98:	00a04574 	movhi	r2,33045
81118b9c:	109f2f04 	addi	r2,r2,31932
81118ba0:	19001324 	muli	r4,r3,76
81118ba4:	1105883a 	add	r2,r2,r4
81118ba8:	10801204 	addi	r2,r2,72
81118bac:	11400005 	stb	r5,0(r2)
81118bb0:	00a04574 	movhi	r2,33045
81118bb4:	109f2f04 	addi	r2,r2,31932
81118bb8:	18c01324 	muli	r3,r3,76
81118bbc:	10c5883a 	add	r2,r2,r3
81118bc0:	10801204 	addi	r2,r2,72
81118bc4:	10800003 	ldbu	r2,0(r2)
81118bc8:	10803fcc 	andi	r2,r2,255
81118bcc:	108000b0 	cmpltui	r2,r2,2
81118bd0:	1000161e 	bne	r2,zero,81118c2c <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
81118bd4:	e0ffff03 	ldbu	r3,-4(fp)
81118bd8:	00a045b4 	movhi	r2,33046
81118bdc:	10836d04 	addi	r2,r2,3508
81118be0:	18c00184 	addi	r3,r3,6
81118be4:	18c7883a 	add	r3,r3,r3
81118be8:	18c7883a 	add	r3,r3,r3
81118bec:	10c5883a 	add	r2,r2,r3
81118bf0:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81118bf4:	d0a07503 	ldbu	r2,-32300(gp)
81118bf8:	10800044 	addi	r2,r2,1
81118bfc:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81118c00:	d0a05e17 	ldw	r2,-32392(gp)
81118c04:	1009883a 	mov	r4,r2
81118c08:	1140e940 	call	81140e94 <OSSemPost>
81118c0c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118c10:	e0bfff43 	ldbu	r2,-3(fp)
81118c14:	10803fcc 	andi	r2,r2,255
81118c18:	10000426 	beq	r2,zero,81118c2c <vCheckRetransmission64+0x248>
                        SemCount64--;
81118c1c:	d0a07503 	ldbu	r2,-32300(gp)
81118c20:	10bfffc4 	addi	r2,r2,-1
81118c24:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118c28:	111da140 	call	8111da14 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81118c2c:	e0bfff03 	ldbu	r2,-4(fp)
81118c30:	10800044 	addi	r2,r2,1
81118c34:	e0bfff05 	stb	r2,-4(fp)
81118c38:	e0bfff03 	ldbu	r2,-4(fp)
81118c3c:	10800230 	cmpltui	r2,r2,8
81118c40:	103f7a1e 	bne	r2,zero,81118a2c <__reset+0xfb0f8a2c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81118c44:	d0a07117 	ldw	r2,-32316(gp)
81118c48:	1009883a 	mov	r4,r2
81118c4c:	113f0a40 	call	8113f0a4 <OSMutexPost>

    return;
81118c50:	0001883a 	nop
81118c54:	00000106 	br	81118c5c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118c58:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
81118c5c:	e037883a 	mov	sp,fp
81118c60:	dfc00117 	ldw	ra,4(sp)
81118c64:	df000017 	ldw	fp,0(sp)
81118c68:	dec00204 	addi	sp,sp,8
81118c6c:	f800283a 	ret

81118c70 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81118c70:	defffd04 	addi	sp,sp,-12
81118c74:	de00012e 	bgeu	sp,et,81118c7c <vCheckRetransmission32+0xc>
81118c78:	003b68fa 	trap	3
81118c7c:	dfc00215 	stw	ra,8(sp)
81118c80:	df000115 	stw	fp,4(sp)
81118c84:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81118c88:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81118c8c:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81118c90:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81118c94:	d0a06c17 	ldw	r2,-32336(gp)
81118c98:	e0ffff84 	addi	r3,fp,-2
81118c9c:	180b883a 	mov	r5,r3
81118ca0:	1009883a 	mov	r4,r2
81118ca4:	113e4800 	call	8113e480 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81118ca8:	e0bfff83 	ldbu	r2,-2(fp)
81118cac:	10803fcc 	andi	r2,r2,255
81118cb0:	10009b1e 	bne	r2,zero,81118f20 <vCheckRetransmission32+0x2b0>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81118cb4:	e03fff05 	stb	zero,-4(fp)
81118cb8:	00009106 	br	81118f00 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81118cbc:	e0ffff03 	ldbu	r3,-4(fp)
81118cc0:	00a045b4 	movhi	r2,33046
81118cc4:	10836d04 	addi	r2,r2,3508
81118cc8:	18c00384 	addi	r3,r3,14
81118ccc:	18c7883a 	add	r3,r3,r3
81118cd0:	18c7883a 	add	r3,r3,r3
81118cd4:	10c5883a 	add	r2,r2,r3
81118cd8:	10800017 	ldw	r2,0(r2)
81118cdc:	10800058 	cmpnei	r2,r2,1
81118ce0:	1000841e 	bne	r2,zero,81118ef4 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81118ce4:	e0ffff03 	ldbu	r3,-4(fp)
81118ce8:	00a045b4 	movhi	r2,33046
81118cec:	10b0ed04 	addi	r2,r2,-15436
81118cf0:	18c00b24 	muli	r3,r3,44
81118cf4:	10c5883a 	add	r2,r2,r3
81118cf8:	10800804 	addi	r2,r2,32
81118cfc:	10800017 	ldw	r2,0(r2)
81118d00:	10800058 	cmpnei	r2,r2,1
81118d04:	1000211e 	bne	r2,zero,81118d8c <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81118d08:	e0ffff03 	ldbu	r3,-4(fp)
81118d0c:	00a045b4 	movhi	r2,33046
81118d10:	10b0ed04 	addi	r2,r2,-15436
81118d14:	19000b24 	muli	r4,r3,44
81118d18:	1105883a 	add	r2,r2,r4
81118d1c:	10800984 	addi	r2,r2,38
81118d20:	1080000b 	ldhu	r2,0(r2)
81118d24:	10800044 	addi	r2,r2,1
81118d28:	100b883a 	mov	r5,r2
81118d2c:	00a045b4 	movhi	r2,33046
81118d30:	10b0ed04 	addi	r2,r2,-15436
81118d34:	19000b24 	muli	r4,r3,44
81118d38:	1105883a 	add	r2,r2,r4
81118d3c:	10800984 	addi	r2,r2,38
81118d40:	1140000d 	sth	r5,0(r2)
81118d44:	00a045b4 	movhi	r2,33046
81118d48:	10b0ed04 	addi	r2,r2,-15436
81118d4c:	18c00b24 	muli	r3,r3,44
81118d50:	10c5883a 	add	r2,r2,r3
81118d54:	10800984 	addi	r2,r2,38
81118d58:	1080000b 	ldhu	r2,0(r2)
81118d5c:	10bfffcc 	andi	r2,r2,65535
81118d60:	10a0001c 	xori	r2,r2,32768
81118d64:	10a00004 	addi	r2,r2,-32768
81118d68:	10800090 	cmplti	r2,r2,2
81118d6c:	1000071e 	bne	r2,zero,81118d8c <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81118d70:	e0ffff03 	ldbu	r3,-4(fp)
81118d74:	00a045b4 	movhi	r2,33046
81118d78:	10b0ed04 	addi	r2,r2,-15436
81118d7c:	18c00b24 	muli	r3,r3,44
81118d80:	10c5883a 	add	r2,r2,r3
81118d84:	10800804 	addi	r2,r2,32
81118d88:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81118d8c:	e0ffff03 	ldbu	r3,-4(fp)
81118d90:	00a045b4 	movhi	r2,33046
81118d94:	10b0ed04 	addi	r2,r2,-15436
81118d98:	18c00b24 	muli	r3,r3,44
81118d9c:	10c5883a 	add	r2,r2,r3
81118da0:	10800804 	addi	r2,r2,32
81118da4:	10800017 	ldw	r2,0(r2)
81118da8:	1000521e 	bne	r2,zero,81118ef4 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81118dac:	e0bfff03 	ldbu	r2,-4(fp)
81118db0:	10c00b24 	muli	r3,r2,44
81118db4:	00a045b4 	movhi	r2,33046
81118db8:	10b0ed04 	addi	r2,r2,-15436
81118dbc:	1885883a 	add	r2,r3,r2
81118dc0:	1009883a 	mov	r4,r2
81118dc4:	1124c200 	call	81124c20 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81118dc8:	e0ffff03 	ldbu	r3,-4(fp)
81118dcc:	00a045b4 	movhi	r2,33046
81118dd0:	10b0ed04 	addi	r2,r2,-15436
81118dd4:	18c00b24 	muli	r3,r3,44
81118dd8:	10c5883a 	add	r2,r2,r3
81118ddc:	10800804 	addi	r2,r2,32
81118de0:	00c00044 	movi	r3,1
81118de4:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81118de8:	e0ffff03 	ldbu	r3,-4(fp)
81118dec:	00a045b4 	movhi	r2,33046
81118df0:	10b0ed04 	addi	r2,r2,-15436
81118df4:	18c00b24 	muli	r3,r3,44
81118df8:	10c5883a 	add	r2,r2,r3
81118dfc:	10800984 	addi	r2,r2,38
81118e00:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81118e04:	e0ffff03 	ldbu	r3,-4(fp)
81118e08:	00a045b4 	movhi	r2,33046
81118e0c:	10b0ed04 	addi	r2,r2,-15436
81118e10:	18c00b24 	muli	r3,r3,44
81118e14:	10c5883a 	add	r2,r2,r3
81118e18:	10800904 	addi	r2,r2,36
81118e1c:	1080000b 	ldhu	r2,0(r2)
81118e20:	10bfffcc 	andi	r2,r2,65535
81118e24:	10800058 	cmpnei	r2,r2,1
81118e28:	1000021e 	bne	r2,zero,81118e34 <vCheckRetransmission32+0x1c4>
81118e2c:	00bffe84 	movi	r2,-6
81118e30:	00000106 	br	81118e38 <vCheckRetransmission32+0x1c8>
81118e34:	00800044 	movi	r2,1
81118e38:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81118e3c:	e0ffff03 	ldbu	r3,-4(fp)
81118e40:	00a045b4 	movhi	r2,33046
81118e44:	10b0ed04 	addi	r2,r2,-15436
81118e48:	19000b24 	muli	r4,r3,44
81118e4c:	1105883a 	add	r2,r2,r4
81118e50:	10800a04 	addi	r2,r2,40
81118e54:	10800003 	ldbu	r2,0(r2)
81118e58:	10800044 	addi	r2,r2,1
81118e5c:	100b883a 	mov	r5,r2
81118e60:	00a045b4 	movhi	r2,33046
81118e64:	10b0ed04 	addi	r2,r2,-15436
81118e68:	19000b24 	muli	r4,r3,44
81118e6c:	1105883a 	add	r2,r2,r4
81118e70:	10800a04 	addi	r2,r2,40
81118e74:	11400005 	stb	r5,0(r2)
81118e78:	00a045b4 	movhi	r2,33046
81118e7c:	10b0ed04 	addi	r2,r2,-15436
81118e80:	18c00b24 	muli	r3,r3,44
81118e84:	10c5883a 	add	r2,r2,r3
81118e88:	10800a04 	addi	r2,r2,40
81118e8c:	10800003 	ldbu	r2,0(r2)
81118e90:	10803fcc 	andi	r2,r2,255
81118e94:	e0ffff43 	ldbu	r3,-3(fp)
81118e98:	1880162e 	bgeu	r3,r2,81118ef4 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81118e9c:	e0ffff03 	ldbu	r3,-4(fp)
81118ea0:	00a045b4 	movhi	r2,33046
81118ea4:	10836d04 	addi	r2,r2,3508
81118ea8:	18c00384 	addi	r3,r3,14
81118eac:	18c7883a 	add	r3,r3,r3
81118eb0:	18c7883a 	add	r3,r3,r3
81118eb4:	10c5883a 	add	r2,r2,r3
81118eb8:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81118ebc:	d0a06883 	ldbu	r2,-32350(gp)
81118ec0:	10800044 	addi	r2,r2,1
81118ec4:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81118ec8:	d0a06f17 	ldw	r2,-32324(gp)
81118ecc:	1009883a 	mov	r4,r2
81118ed0:	1140e940 	call	81140e94 <OSSemPost>
81118ed4:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118ed8:	e0bfff83 	ldbu	r2,-2(fp)
81118edc:	10803fcc 	andi	r2,r2,255
81118ee0:	10000426 	beq	r2,zero,81118ef4 <vCheckRetransmission32+0x284>
                        SemCount32--;
81118ee4:	d0a06883 	ldbu	r2,-32350(gp)
81118ee8:	10bfffc4 	addi	r2,r2,-1
81118eec:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118ef0:	111d9940 	call	8111d994 <vFailSetCountSemaphorexBuffer32>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81118ef4:	e0bfff03 	ldbu	r2,-4(fp)
81118ef8:	10800044 	addi	r2,r2,1
81118efc:	e0bfff05 	stb	r2,-4(fp)
81118f00:	e0bfff03 	ldbu	r2,-4(fp)
81118f04:	10800230 	cmpltui	r2,r2,8
81118f08:	103f6c1e 	bne	r2,zero,81118cbc <__reset+0xfb0f8cbc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81118f0c:	d0a06c17 	ldw	r2,-32336(gp)
81118f10:	1009883a 	mov	r4,r2
81118f14:	113f0a40 	call	8113f0a4 <OSMutexPost>

    return;
81118f18:	0001883a 	nop
81118f1c:	00000106 	br	81118f24 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118f20:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81118f24:	e037883a 	mov	sp,fp
81118f28:	dfc00117 	ldw	ra,4(sp)
81118f2c:	df000017 	ldw	fp,0(sp)
81118f30:	dec00204 	addi	sp,sp,8
81118f34:	f800283a 	ret

81118f38 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81118f38:	defff904 	addi	sp,sp,-28
81118f3c:	de00012e 	bgeu	sp,et,81118f44 <bResourcesInitRTOS+0xc>
81118f40:	003b68fa 	trap	3
81118f44:	dfc00615 	stw	ra,24(sp)
81118f48:	df000515 	stw	fp,20(sp)
81118f4c:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81118f50:	00800044 	movi	r2,1
81118f54:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81118f58:	0009883a 	mov	r4,zero
81118f5c:	11407e40 	call	811407e4 <OSSemCreate>
81118f60:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
81118f64:	d0a06017 	ldw	r2,-32384(gp)
81118f68:	1000021e 	bne	r2,zero,81118f74 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81118f6c:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118f70:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81118f74:	e0bfff04 	addi	r2,fp,-4
81118f78:	100b883a 	mov	r5,r2
81118f7c:	01000444 	movi	r4,17
81118f80:	113e62c0 	call	8113e62c <OSMutexCreate>
81118f84:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81118f88:	e0bfff03 	ldbu	r2,-4(fp)
81118f8c:	10803fcc 	andi	r2,r2,255
81118f90:	10000526 	beq	r2,zero,81118fa8 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81118f94:	e0bfff03 	ldbu	r2,-4(fp)
81118f98:	10803fcc 	andi	r2,r2,255
81118f9c:	1009883a 	mov	r4,r2
81118fa0:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118fa4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81118fa8:	e0bfff04 	addi	r2,fp,-4
81118fac:	100b883a 	mov	r5,r2
81118fb0:	01000504 	movi	r4,20
81118fb4:	113e62c0 	call	8113e62c <OSMutexCreate>
81118fb8:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
81118fbc:	e0bfff03 	ldbu	r2,-4(fp)
81118fc0:	10803fcc 	andi	r2,r2,255
81118fc4:	10000526 	beq	r2,zero,81118fdc <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81118fc8:	e0bfff03 	ldbu	r2,-4(fp)
81118fcc:	10803fcc 	andi	r2,r2,255
81118fd0:	1009883a 	mov	r4,r2
81118fd4:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118fd8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81118fdc:	e0bfff04 	addi	r2,fp,-4
81118fe0:	100b883a 	mov	r5,r2
81118fe4:	01000544 	movi	r4,21
81118fe8:	113e62c0 	call	8113e62c <OSMutexCreate>
81118fec:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81118ff0:	e0bfff03 	ldbu	r2,-4(fp)
81118ff4:	10803fcc 	andi	r2,r2,255
81118ff8:	10000526 	beq	r2,zero,81119010 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81118ffc:	e0bfff03 	ldbu	r2,-4(fp)
81119000:	10803fcc 	andi	r2,r2,255
81119004:	1009883a 	mov	r4,r2
81119008:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111900c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81119010:	e0bfff04 	addi	r2,fp,-4
81119014:	100b883a 	mov	r5,r2
81119018:	01000584 	movi	r4,22
8111901c:	113e62c0 	call	8113e62c <OSMutexCreate>
81119020:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81119024:	e0bfff03 	ldbu	r2,-4(fp)
81119028:	10803fcc 	andi	r2,r2,255
8111902c:	10000526 	beq	r2,zero,81119044 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81119030:	e0bfff03 	ldbu	r2,-4(fp)
81119034:	10803fcc 	andi	r2,r2,255
81119038:	1009883a 	mov	r4,r2
8111903c:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81119040:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81119044:	00800184 	movi	r2,6
81119048:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8111904c:	01000184 	movi	r4,6
81119050:	11407e40 	call	811407e4 <OSSemCreate>
81119054:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
81119058:	d0a06317 	ldw	r2,-32372(gp)
8111905c:	1000031e 	bne	r2,zero,8111906c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81119060:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
81119064:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81119068:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8111906c:	00800204 	movi	r2,8
81119070:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81119074:	01000204 	movi	r4,8
81119078:	11407e40 	call	811407e4 <OSSemCreate>
8111907c:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
81119080:	d0a05e17 	ldw	r2,-32392(gp)
81119084:	1000031e 	bne	r2,zero,81119094 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81119088:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
8111908c:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81119090:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81119094:	00800204 	movi	r2,8
81119098:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
8111909c:	01000204 	movi	r4,8
811190a0:	11407e40 	call	811407e4 <OSSemCreate>
811190a4:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
811190a8:	d0a06f17 	ldw	r2,-32324(gp)
811190ac:	1000031e 	bne	r2,zero,811190bc <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
811190b0:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
811190b4:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811190b8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
811190bc:	e0bfff04 	addi	r2,fp,-4
811190c0:	100b883a 	mov	r5,r2
811190c4:	010004c4 	movi	r4,19
811190c8:	113e62c0 	call	8113e62c <OSMutexCreate>
811190cc:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
811190d0:	e0bfff03 	ldbu	r2,-4(fp)
811190d4:	10803fcc 	andi	r2,r2,255
811190d8:	10000526 	beq	r2,zero,811190f0 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
811190dc:	e0bfff03 	ldbu	r2,-4(fp)
811190e0:	10803fcc 	andi	r2,r2,255
811190e4:	1009883a 	mov	r4,r2
811190e8:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811190ec:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
811190f0:	e0bfff04 	addi	r2,fp,-4
811190f4:	100b883a 	mov	r5,r2
811190f8:	010005c4 	movi	r4,23
811190fc:	113e62c0 	call	8113e62c <OSMutexCreate>
81119100:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81119104:	e0bfff03 	ldbu	r2,-4(fp)
81119108:	10803fcc 	andi	r2,r2,255
8111910c:	10000526 	beq	r2,zero,81119124 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81119110:	e0bfff03 	ldbu	r2,-4(fp)
81119114:	10803fcc 	andi	r2,r2,255
81119118:	1009883a 	mov	r4,r2
8111911c:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81119120:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81119124:	0009883a 	mov	r4,zero
81119128:	11407e40 	call	811407e4 <OSSemCreate>
8111912c:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
81119130:	d0a06617 	ldw	r2,-32360(gp)
81119134:	1000021e 	bne	r2,zero,81119140 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81119138:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111913c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81119140:	0009883a 	mov	r4,zero
81119144:	11407e40 	call	811407e4 <OSSemCreate>
81119148:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
8111914c:	d0a06417 	ldw	r2,-32368(gp)
81119150:	1000021e 	bne	r2,zero,8111915c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81119154:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81119158:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8111915c:	0009883a 	mov	r4,zero
81119160:	11407e40 	call	811407e4 <OSSemCreate>
81119164:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
81119168:	d0a06117 	ldw	r2,-32380(gp)
8111916c:	1000021e 	bne	r2,zero,81119178 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81119170:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81119174:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81119178:	e0bfff04 	addi	r2,fp,-4
8111917c:	100b883a 	mov	r5,r2
81119180:	01000484 	movi	r4,18
81119184:	113e62c0 	call	8113e62c <OSMutexCreate>
81119188:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
8111918c:	e0bfff03 	ldbu	r2,-4(fp)
81119190:	10803fcc 	andi	r2,r2,255
81119194:	10000526 	beq	r2,zero,811191ac <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81119198:	e0bfff03 	ldbu	r2,-4(fp)
8111919c:	10803fcc 	andi	r2,r2,255
811191a0:	1009883a 	mov	r4,r2
811191a4:	111d1d00 	call	8111d1d0 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811191a8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
811191ac:	0009883a 	mov	r4,zero
811191b0:	11407e40 	call	811407e4 <OSSemCreate>
811191b4:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
811191b8:	d0a06717 	ldw	r2,-32356(gp)
811191bc:	1000021e 	bne	r2,zero,811191c8 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
811191c0:	111d2ac0 	call	8111d2ac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811191c4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
811191c8:	e0bfff04 	addi	r2,fp,-4
811191cc:	d8800215 	stw	r2,8(sp)
811191d0:	00a04574 	movhi	r2,33045
811191d4:	1081b704 	addi	r2,r2,1756
811191d8:	d8800115 	stw	r2,4(sp)
811191dc:	d8000015 	stw	zero,0(sp)
811191e0:	01e044b4 	movhi	r7,33042
811191e4:	39eb7d04 	addi	r7,r7,-21004
811191e8:	01800084 	movi	r6,2
811191ec:	01400104 	movi	r5,4
811191f0:	01000284 	movi	r4,10
811191f4:	1142eb00 	call	81142eb0 <OSTmrCreate>
811191f8:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
811191fc:	e0bfff03 	ldbu	r2,-4(fp)
81119200:	10803fcc 	andi	r2,r2,255
81119204:	10000226 	beq	r2,zero,81119210 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81119208:	111e2400 	call	8111e240 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8111920c:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81119210:	01400484 	movi	r5,18
81119214:	012045b4 	movhi	r4,33046
81119218:	21242b04 	addi	r4,r4,-28500
8111921c:	113f7180 	call	8113f718 <OSQCreate>
81119220:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
81119224:	d0a05d17 	ldw	r2,-32396(gp)
81119228:	1000021e 	bne	r2,zero,81119234 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8111922c:	111e98c0 	call	8111e98c <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81119230:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81119234:	01400204 	movi	r5,8
81119238:	012045f4 	movhi	r4,33047
8111923c:	21233f04 	addi	r4,r4,-29444
81119240:	113f7180 	call	8113f718 <OSQCreate>
81119244:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
81119248:	d0a06a17 	ldw	r2,-32344(gp)
8111924c:	1000031e 	bne	r2,zero,8111925c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81119250:	0009883a 	mov	r4,zero
81119254:	111ea0c0 	call	8111ea0c <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81119258:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
8111925c:	01400204 	movi	r5,8
81119260:	012045b4 	movhi	r4,33046
81119264:	21088504 	addi	r4,r4,8724
81119268:	113f7180 	call	8113f718 <OSQCreate>
8111926c:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81119270:	d0a05c17 	ldw	r2,-32400(gp)
81119274:	1000031e 	bne	r2,zero,81119284 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81119278:	0009883a 	mov	r4,zero
8111927c:	111ea940 	call	8111ea94 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81119280:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81119284:	01400204 	movi	r5,8
81119288:	012045b4 	movhi	r4,33046
8111928c:	21038304 	addi	r4,r4,3596
81119290:	113f7180 	call	8113f718 <OSQCreate>
81119294:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
81119298:	d0a06917 	ldw	r2,-32348(gp)
8111929c:	1000031e 	bne	r2,zero,811192ac <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
811192a0:	01000144 	movi	r4,5
811192a4:	111ea0c0 	call	8111ea0c <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811192a8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
811192ac:	e0bfff04 	addi	r2,fp,-4
811192b0:	100b883a 	mov	r5,r2
811192b4:	010001c4 	movi	r4,7
811192b8:	113e62c0 	call	8113e62c <OSMutexCreate>
811192bc:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
811192c0:	e0bfff03 	ldbu	r2,-4(fp)
811192c4:	10803fcc 	andi	r2,r2,255
811192c8:	10000526 	beq	r2,zero,811192e0 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
811192cc:	e0bfff03 	ldbu	r2,-4(fp)
811192d0:	10803fcc 	andi	r2,r2,255
811192d4:	1009883a 	mov	r4,r2
811192d8:	111ef9c0 	call	8111ef9c <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
811192dc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
811192e0:	01400404 	movi	r5,16
811192e4:	012045b4 	movhi	r4,33046
811192e8:	21045d04 	addi	r4,r4,4468
811192ec:	113f7180 	call	8113f718 <OSQCreate>
811192f0:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
811192f4:	d0a07017 	ldw	r2,-32320(gp)
811192f8:	1000021e 	bne	r2,zero,81119304 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
811192fc:	111f15c0 	call	8111f15c <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81119300:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81119304:	01400404 	movi	r5,16
81119308:	012045b4 	movhi	r4,33046
8111930c:	21374504 	addi	r4,r4,-8940
81119310:	113f7180 	call	8113f718 <OSQCreate>
81119314:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
81119318:	d0a05f17 	ldw	r2,-32388(gp)
8111931c:	1000021e 	bne	r2,zero,81119328 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81119320:	111f1dc0 	call	8111f1dc <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81119324:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81119328:	e0bfff04 	addi	r2,fp,-4
8111932c:	100b883a 	mov	r5,r2
81119330:	01000104 	movi	r4,4
81119334:	113e62c0 	call	8113e62c <OSMutexCreate>
81119338:	1007883a 	mov	r3,r2
8111933c:	00a045b4 	movhi	r2,33046
81119340:	10969304 	addi	r2,r2,23116
81119344:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81119348:	e0bfff03 	ldbu	r2,-4(fp)
8111934c:	10803fcc 	andi	r2,r2,255
81119350:	10000226 	beq	r2,zero,8111935c <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81119354:	111d2480 	call	8111d248 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81119358:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
8111935c:	e0bfff04 	addi	r2,fp,-4
81119360:	100b883a 	mov	r5,r2
81119364:	01000184 	movi	r4,6
81119368:	113e62c0 	call	8113e62c <OSMutexCreate>
8111936c:	1007883a 	mov	r3,r2
81119370:	00a045b4 	movhi	r2,33046
81119374:	10969304 	addi	r2,r2,23116
81119378:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
8111937c:	e0bfff03 	ldbu	r2,-4(fp)
81119380:	10803fcc 	andi	r2,r2,255
81119384:	10000226 	beq	r2,zero,81119390 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81119388:	111d2480 	call	8111d248 <vFailCreateMutexDMA>
		bSuccess = FALSE;
8111938c:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81119390:	e0bffe17 	ldw	r2,-8(fp)
}
81119394:	e037883a 	mov	sp,fp
81119398:	dfc00117 	ldw	ra,4(sp)
8111939c:	df000017 	ldw	fp,0(sp)
811193a0:	dec00204 	addi	sp,sp,8
811193a4:	f800283a 	ret

811193a8 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
811193a8:	defffd04 	addi	sp,sp,-12
811193ac:	de00012e 	bgeu	sp,et,811193b4 <vVariablesInitialization+0xc>
811193b0:	003b68fa 	trap	3
811193b4:	dfc00215 	stw	ra,8(sp)
811193b8:	df000115 	stw	fp,4(sp)
811193bc:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
811193c0:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
811193c4:	00800084 	movi	r2,2
811193c8:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
811193cc:	01800604 	movi	r6,24
811193d0:	000b883a 	mov	r5,zero
811193d4:	012045b4 	movhi	r4,33046
811193d8:	21036d04 	addi	r4,r4,3508
811193dc:	11248500 	call	81124850 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
811193e0:	01800804 	movi	r6,32
811193e4:	000b883a 	mov	r5,zero
811193e8:	012045b4 	movhi	r4,33046
811193ec:	21037304 	addi	r4,r4,3532
811193f0:	11248500 	call	81124850 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
811193f4:	01800804 	movi	r6,32
811193f8:	000b883a 	mov	r5,zero
811193fc:	012045b4 	movhi	r4,33046
81119400:	21037b04 	addi	r4,r4,3564
81119404:	11248500 	call	81124850 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119408:	e03fff05 	stb	zero,-4(fp)
8111940c:	00002806 	br	811194b0 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81119410:	e0bfff03 	ldbu	r2,-4(fp)
81119414:	10c02324 	muli	r3,r2,140
81119418:	00a045b4 	movhi	r2,33046
8111941c:	10838b04 	addi	r2,r2,3628
81119420:	1885883a 	add	r2,r3,r2
81119424:	01802004 	movi	r6,128
81119428:	000b883a 	mov	r5,zero
8111942c:	1009883a 	mov	r4,r2
81119430:	11248500 	call	81124850 <memset>
		xBuffer128[ucIL].bSent = FALSE;
81119434:	e0ffff03 	ldbu	r3,-4(fp)
81119438:	00a045b4 	movhi	r2,33046
8111943c:	10838b04 	addi	r2,r2,3628
81119440:	18c02324 	muli	r3,r3,140
81119444:	10c5883a 	add	r2,r2,r3
81119448:	10802004 	addi	r2,r2,128
8111944c:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81119450:	e0ffff03 	ldbu	r3,-4(fp)
81119454:	00a045b4 	movhi	r2,33046
81119458:	10838b04 	addi	r2,r2,3628
8111945c:	18c02324 	muli	r3,r3,140
81119460:	10c5883a 	add	r2,r2,r3
81119464:	10802104 	addi	r2,r2,132
81119468:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
8111946c:	e0ffff03 	ldbu	r3,-4(fp)
81119470:	00a045b4 	movhi	r2,33046
81119474:	10838b04 	addi	r2,r2,3628
81119478:	18c02324 	muli	r3,r3,140
8111947c:	10c5883a 	add	r2,r2,r3
81119480:	10802184 	addi	r2,r2,134
81119484:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81119488:	e0ffff03 	ldbu	r3,-4(fp)
8111948c:	00a045b4 	movhi	r2,33046
81119490:	10838b04 	addi	r2,r2,3628
81119494:	18c02324 	muli	r3,r3,140
81119498:	10c5883a 	add	r2,r2,r3
8111949c:	10802204 	addi	r2,r2,136
811194a0:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811194a4:	e0bfff03 	ldbu	r2,-4(fp)
811194a8:	10800044 	addi	r2,r2,1
811194ac:	e0bfff05 	stb	r2,-4(fp)
811194b0:	e0bfff03 	ldbu	r2,-4(fp)
811194b4:	108001b0 	cmpltui	r2,r2,6
811194b8:	103fd51e 	bne	r2,zero,81119410 <__reset+0xfb0f9410>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811194bc:	e03fff05 	stb	zero,-4(fp)
811194c0:	00002806 	br	81119564 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
811194c4:	e0bfff03 	ldbu	r2,-4(fp)
811194c8:	10c01324 	muli	r3,r2,76
811194cc:	00a04574 	movhi	r2,33045
811194d0:	109f2f04 	addi	r2,r2,31932
811194d4:	1885883a 	add	r2,r3,r2
811194d8:	01801004 	movi	r6,64
811194dc:	000b883a 	mov	r5,zero
811194e0:	1009883a 	mov	r4,r2
811194e4:	11248500 	call	81124850 <memset>
		xBuffer64[ucIL].bSent = FALSE;
811194e8:	e0ffff03 	ldbu	r3,-4(fp)
811194ec:	00a04574 	movhi	r2,33045
811194f0:	109f2f04 	addi	r2,r2,31932
811194f4:	18c01324 	muli	r3,r3,76
811194f8:	10c5883a 	add	r2,r2,r3
811194fc:	10801004 	addi	r2,r2,64
81119500:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81119504:	e0ffff03 	ldbu	r3,-4(fp)
81119508:	00a04574 	movhi	r2,33045
8111950c:	109f2f04 	addi	r2,r2,31932
81119510:	18c01324 	muli	r3,r3,76
81119514:	10c5883a 	add	r2,r2,r3
81119518:	10801104 	addi	r2,r2,68
8111951c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81119520:	e0ffff03 	ldbu	r3,-4(fp)
81119524:	00a04574 	movhi	r2,33045
81119528:	109f2f04 	addi	r2,r2,31932
8111952c:	18c01324 	muli	r3,r3,76
81119530:	10c5883a 	add	r2,r2,r3
81119534:	10801184 	addi	r2,r2,70
81119538:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
8111953c:	e0ffff03 	ldbu	r3,-4(fp)
81119540:	00a04574 	movhi	r2,33045
81119544:	109f2f04 	addi	r2,r2,31932
81119548:	18c01324 	muli	r3,r3,76
8111954c:	10c5883a 	add	r2,r2,r3
81119550:	10801204 	addi	r2,r2,72
81119554:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81119558:	e0bfff03 	ldbu	r2,-4(fp)
8111955c:	10800044 	addi	r2,r2,1
81119560:	e0bfff05 	stb	r2,-4(fp)
81119564:	e0bfff03 	ldbu	r2,-4(fp)
81119568:	10800230 	cmpltui	r2,r2,8
8111956c:	103fd51e 	bne	r2,zero,811194c4 <__reset+0xfb0f94c4>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81119570:	e03fff05 	stb	zero,-4(fp)
81119574:	00002806 	br	81119618 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81119578:	e0bfff03 	ldbu	r2,-4(fp)
8111957c:	10c00b24 	muli	r3,r2,44
81119580:	00a045b4 	movhi	r2,33046
81119584:	10b0ed04 	addi	r2,r2,-15436
81119588:	1885883a 	add	r2,r3,r2
8111958c:	01800804 	movi	r6,32
81119590:	000b883a 	mov	r5,zero
81119594:	1009883a 	mov	r4,r2
81119598:	11248500 	call	81124850 <memset>
		xBuffer32[ucIL].bSent = FALSE;
8111959c:	e0ffff03 	ldbu	r3,-4(fp)
811195a0:	00a045b4 	movhi	r2,33046
811195a4:	10b0ed04 	addi	r2,r2,-15436
811195a8:	18c00b24 	muli	r3,r3,44
811195ac:	10c5883a 	add	r2,r2,r3
811195b0:	10800804 	addi	r2,r2,32
811195b4:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
811195b8:	e0ffff03 	ldbu	r3,-4(fp)
811195bc:	00a045b4 	movhi	r2,33046
811195c0:	10b0ed04 	addi	r2,r2,-15436
811195c4:	18c00b24 	muli	r3,r3,44
811195c8:	10c5883a 	add	r2,r2,r3
811195cc:	10800904 	addi	r2,r2,36
811195d0:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
811195d4:	e0ffff03 	ldbu	r3,-4(fp)
811195d8:	00a045b4 	movhi	r2,33046
811195dc:	10b0ed04 	addi	r2,r2,-15436
811195e0:	18c00b24 	muli	r3,r3,44
811195e4:	10c5883a 	add	r2,r2,r3
811195e8:	10800984 	addi	r2,r2,38
811195ec:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
811195f0:	e0ffff03 	ldbu	r3,-4(fp)
811195f4:	00a045b4 	movhi	r2,33046
811195f8:	10b0ed04 	addi	r2,r2,-15436
811195fc:	18c00b24 	muli	r3,r3,44
81119600:	10c5883a 	add	r2,r2,r3
81119604:	10800a04 	addi	r2,r2,40
81119608:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8111960c:	e0bfff03 	ldbu	r2,-4(fp)
81119610:	10800044 	addi	r2,r2,1
81119614:	e0bfff05 	stb	r2,-4(fp)
81119618:	e0bfff03 	ldbu	r2,-4(fp)
8111961c:	10800230 	cmpltui	r2,r2,8
81119620:	103fd51e 	bne	r2,zero,81119578 <__reset+0xfb0f9578>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81119624:	e03fff05 	stb	zero,-4(fp)
81119628:	00001b06 	br	81119698 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
8111962c:	e0ffff03 	ldbu	r3,-4(fp)
81119630:	00a04574 	movhi	r2,33045
81119634:	109fc704 	addi	r2,r2,32540
81119638:	18c01524 	muli	r3,r3,84
8111963c:	10c5883a 	add	r2,r2,r3
81119640:	10800104 	addi	r2,r2,4
81119644:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81119648:	e0ffff03 	ldbu	r3,-4(fp)
8111964c:	00a04574 	movhi	r2,33045
81119650:	109fc704 	addi	r2,r2,32540
81119654:	18c01524 	muli	r3,r3,84
81119658:	10c5883a 	add	r2,r2,r3
8111965c:	10800484 	addi	r2,r2,18
81119660:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81119664:	e0bfff03 	ldbu	r2,-4(fp)
81119668:	10801524 	muli	r2,r2,84
8111966c:	10c00504 	addi	r3,r2,20
81119670:	00a04574 	movhi	r2,33045
81119674:	109fc704 	addi	r2,r2,32540
81119678:	1885883a 	add	r2,r3,r2
8111967c:	01801004 	movi	r6,64
81119680:	000b883a 	mov	r5,zero
81119684:	1009883a 	mov	r4,r2
81119688:	11248500 	call	81124850 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8111968c:	e0bfff03 	ldbu	r2,-4(fp)
81119690:	10800044 	addi	r2,r2,1
81119694:	e0bfff05 	stb	r2,-4(fp)
81119698:	e0bfff03 	ldbu	r2,-4(fp)
8111969c:	10800130 	cmpltui	r2,r2,4
811196a0:	103fe21e 	bne	r2,zero,8111962c <__reset+0xfb0f962c>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
811196a4:	0001883a 	nop
811196a8:	e037883a 	mov	sp,fp
811196ac:	dfc00117 	ldw	ra,4(sp)
811196b0:	df000017 	ldw	fp,0(sp)
811196b4:	dec00204 	addi	sp,sp,8
811196b8:	f800283a 	ret

811196bc <main>:
void vFillMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
811196bc:	defff704 	addi	sp,sp,-36
811196c0:	de00012e 	bgeu	sp,et,811196c8 <main+0xc>
811196c4:	003b68fa 	trap	3
811196c8:	dfc00815 	stw	ra,32(sp)
811196cc:	df000715 	stw	fp,28(sp)
811196d0:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
811196d4:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
811196d8:	113aac80 	call	8113aac8 <OSInit>

	/* Debug device initialization - JTAG USB */
	#if DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
811196dc:	01604574 	movhi	r5,33045
811196e0:	2941bb04 	addi	r5,r5,1772
811196e4:	01204574 	movhi	r4,33045
811196e8:	2101bc04 	addi	r4,r4,1776
811196ec:	11236080 	call	81123608 <fopen>
811196f0:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#if DEBUG_ON
		debug(fp, "Main entry point.\n");
811196f4:	d0a06217 	ldw	r2,-32376(gp)
811196f8:	100f883a 	mov	r7,r2
811196fc:	01800484 	movi	r6,18
81119700:	01400044 	movi	r5,1
81119704:	01204574 	movhi	r4,33045
81119708:	2101c104 	addi	r4,r4,1796
8111970c:	1123cec0 	call	81123cec <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81119710:	11203f40 	call	811203f4 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81119714:	1120f7c0 	call	81120f7c <bTestSimucamCriticalHW>
81119718:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8111971c:	e0bffe17 	ldw	r2,-8(fp)
81119720:	1000031e 	bne	r2,zero,81119730 <main+0x74>
		vFailTestCriticasParts();
81119724:	111d3100 	call	8111d310 <vFailTestCriticasParts>
		return -1;
81119728:	00bfffc4 	movi	r2,-1
8111972c:	00006606 	br	811198c8 <main+0x20c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81119730:	1120b700 	call	81120b70 <bInitializeSDCard>
81119734:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81119738:	e0bffe17 	ldw	r2,-8(fp)
8111973c:	1000031e 	bne	r2,zero,8111974c <main+0x90>
		vFailTestCriticasParts();
81119740:	111d3100 	call	8111d310 <vFailTestCriticasParts>
		return -1;
81119744:	00bfffc4 	movi	r2,-1
81119748:	00005f06 	br	811198c8 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDebugConfs();
8111974c:	111bf8c0 	call	8111bf8c <vLoadDebugConfs>
81119750:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81119754:	e0bffe17 	ldw	r2,-8(fp)
81119758:	10000f1e 	bne	r2,zero,81119798 <main+0xdc>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111975c:	00a045f4 	movhi	r2,33047
81119760:	10a34f04 	addi	r2,r2,-29380
81119764:	10800a8b 	ldhu	r2,42(r2)
81119768:	10bfffcc 	andi	r2,r2,65535
8111976c:	10800228 	cmpgeui	r2,r2,8
81119770:	1000071e 	bne	r2,zero,81119790 <main+0xd4>
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81119774:	d0a06217 	ldw	r2,-32376(gp)
81119778:	100f883a 	mov	r7,r2
8111977c:	01801504 	movi	r6,84
81119780:	01400044 	movi	r5,1
81119784:	01204574 	movhi	r4,33045
81119788:	2101c604 	addi	r4,r4,1816
8111978c:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		return -1;
81119790:	00bfffc4 	movi	r2,-1
81119794:	00004c06 	br	811198c8 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81119798:	111b21c0 	call	8111b21c <vLoadDefaultETHConf>
8111979c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811197a0:	e0bffe17 	ldw	r2,-8(fp)
811197a4:	10000f1e 	bne	r2,zero,811197e4 <main+0x128>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811197a8:	00a045f4 	movhi	r2,33047
811197ac:	10a34f04 	addi	r2,r2,-29380
811197b0:	10800a8b 	ldhu	r2,42(r2)
811197b4:	10bfffcc 	andi	r2,r2,65535
811197b8:	10800228 	cmpgeui	r2,r2,8
811197bc:	1000071e 	bne	r2,zero,811197dc <main+0x120>
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
811197c0:	d0a06217 	ldw	r2,-32376(gp)
811197c4:	100f883a 	mov	r7,r2
811197c8:	01801484 	movi	r6,82
811197cc:	01400044 	movi	r5,1
811197d0:	01204574 	movhi	r4,33045
811197d4:	2101dc04 	addi	r4,r4,1904
811197d8:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		return -1;
811197dc:	00bfffc4 	movi	r2,-1
811197e0:	00003906 	br	811198c8 <main+0x20c>
	}


	/* If debug is enable, will print the eth configuration in the*/
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811197e4:	00a045f4 	movhi	r2,33047
811197e8:	10a34f04 	addi	r2,r2,-29380
811197ec:	10800a8b 	ldhu	r2,42(r2)
811197f0:	10bfffcc 	andi	r2,r2,65535
811197f4:	108000e8 	cmpgeui	r2,r2,3
811197f8:	1000011e 	bne	r2,zero,81119800 <main+0x144>
		vShowEthConfig();
811197fc:	111bc5c0 	call	8111bc5c <vShowEthConfig>
	}
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81119800:	1118f380 	call	81118f38 <bResourcesInitRTOS>
81119804:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81119808:	e0bffe17 	ldw	r2,-8(fp)
8111980c:	10000f1e 	bne	r2,zero,8111984c <main+0x190>
		/* Default configuration for eth connection loaded */
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119810:	00a045f4 	movhi	r2,33047
81119814:	10a34f04 	addi	r2,r2,-29380
81119818:	10800a8b 	ldhu	r2,42(r2)
8111981c:	10bfffcc 	andi	r2,r2,65535
81119820:	10800228 	cmpgeui	r2,r2,8
81119824:	1000071e 	bne	r2,zero,81119844 <main+0x188>
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81119828:	d0a06217 	ldw	r2,-32376(gp)
8111982c:	100f883a 	mov	r7,r2
81119830:	01800ac4 	movi	r6,43
81119834:	01400044 	movi	r5,1
81119838:	01204574 	movhi	r4,33045
8111983c:	2101f104 	addi	r4,r4,1988
81119840:	1123cec0 	call	81123cec <fwrite>
	}
	#endif
		return -1;
81119844:	00bfffc4 	movi	r2,-1
81119848:	00001f06 	br	811198c8 <main+0x20c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
8111984c:	012045b4 	movhi	r4,33046
81119850:	212c3d04 	addi	r4,r4,-20236
81119854:	112053c0 	call	8112053c <vSimucamStructureInit>

	vVariablesInitialization();
81119858:	11193a80 	call	811193a8 <vVariablesInitialization>

	bInitSync();
8111985c:	1120d240 	call	81120d24 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81119860:	012045b4 	movhi	r4,33046
81119864:	212c3d04 	addi	r4,r4,-20236
81119868:	11198dc0 	call	811198dc <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
8111986c:	d8000415 	stw	zero,16(sp)
81119870:	d8000315 	stw	zero,12(sp)
81119874:	00810004 	movi	r2,1024
81119878:	d8800215 	stw	r2,8(sp)
8111987c:	00a045b4 	movhi	r2,33046
81119880:	10bb6504 	addi	r2,r2,-4716
81119884:	d8800115 	stw	r2,4(sp)
81119888:	00800044 	movi	r2,1
8111988c:	d8800015 	stw	r2,0(sp)
81119890:	01c00044 	movi	r7,1
81119894:	01a045b4 	movhi	r6,33046
81119898:	31bf6404 	addi	r6,r6,-624
8111989c:	000b883a 	mov	r5,zero
811198a0:	01204474 	movhi	r4,33041
811198a4:	210d9c04 	addi	r4,r4,13936
811198a8:	11418780 	call	81141878 <OSTaskCreateExt>
811198ac:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
811198b0:	e0bfff03 	ldbu	r2,-4(fp)
811198b4:	1000021e 	bne	r2,zero,811198c0 <main+0x204>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
811198b8:	113adf80 	call	8113adf8 <OSStart>
811198bc:	00000106 	br	811198c4 <main+0x208>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
811198c0:	111d8040 	call	8111d804 <vFailInitialization>
	}
  
	return 0;
811198c4:	0005883a 	mov	r2,zero
}
811198c8:	e037883a 	mov	sp,fp
811198cc:	dfc00117 	ldw	ra,4(sp)
811198d0:	df000017 	ldw	fp,0(sp)
811198d4:	dec00204 	addi	sp,sp,8
811198d8:	f800283a 	ret

811198dc <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
811198dc:	defff604 	addi	sp,sp,-40
811198e0:	de00012e 	bgeu	sp,et,811198e8 <vFillMemmoryPattern+0xc>
811198e4:	003b68fa 	trap	3
811198e8:	dfc00915 	stw	ra,36(sp)
811198ec:	df000815 	stw	fp,32(sp)
811198f0:	df000804 	addi	fp,sp,32
811198f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
811198f8:	00800044 	movi	r2,1
811198fc:	e0bffcc5 	stb	r2,-13(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119900:	00a045f4 	movhi	r2,33047
81119904:	10a34f04 	addi	r2,r2,-29380
81119908:	10800a8b 	ldhu	r2,42(r2)
8111990c:	10bfffcc 	andi	r2,r2,65535
81119910:	10800168 	cmpgeui	r2,r2,5
81119914:	1000071e 	bne	r2,zero,81119934 <vFillMemmoryPattern+0x58>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
81119918:	d0a06217 	ldw	r2,-32376(gp)
8111991c:	100f883a 	mov	r7,r2
81119920:	01800a04 	movi	r6,40
81119924:	01400044 	movi	r5,1
81119928:	01204574 	movhi	r4,33045
8111992c:	2101fc04 	addi	r4,r4,2032
81119930:	1123cec0 	call	81123cec <fwrite>
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81119934:	e03ffa05 	stb	zero,-24(fp)
81119938:	0000a706 	br	81119bd8 <vFillMemmoryPattern+0x2fc>
		/* n NFEE */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111993c:	00a045f4 	movhi	r2,33047
81119940:	10a34f04 	addi	r2,r2,-29380
81119944:	10800a8b 	ldhu	r2,42(r2)
81119948:	10bfffcc 	andi	r2,r2,65535
8111994c:	10800168 	cmpgeui	r2,r2,5
81119950:	1000071e 	bne	r2,zero,81119970 <vFillMemmoryPattern+0x94>
			fprintf(fp, "Memory %i\n",mem_number);
81119954:	d0a06217 	ldw	r2,-32376(gp)
81119958:	e0fffa03 	ldbu	r3,-24(fp)
8111995c:	180d883a 	mov	r6,r3
81119960:	01604574 	movhi	r5,33045
81119964:	29420704 	addi	r5,r5,2076
81119968:	1009883a 	mov	r4,r2
8111996c:	11236500 	call	81123650 <fprintf>
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81119970:	e03ffc85 	stb	zero,-14(fp)
81119974:	00009206 	br	81119bc0 <vFillMemmoryPattern+0x2e4>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119978:	00a045f4 	movhi	r2,33047
8111997c:	10a34f04 	addi	r2,r2,-29380
81119980:	10800a8b 	ldhu	r2,42(r2)
81119984:	10bfffcc 	andi	r2,r2,65535
81119988:	10800168 	cmpgeui	r2,r2,5
8111998c:	1000071e 	bne	r2,zero,811199ac <vFillMemmoryPattern+0xd0>
				fprintf(fp, "--NFEE %i\n", NFee_i);
81119990:	d0a06217 	ldw	r2,-32376(gp)
81119994:	e0fffc83 	ldbu	r3,-14(fp)
81119998:	180d883a 	mov	r6,r3
8111999c:	01604574 	movhi	r5,33045
811199a0:	29420a04 	addi	r5,r5,2088
811199a4:	1009883a 	mov	r4,r2
811199a8:	11236500 	call	81123650 <fprintf>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
811199ac:	e0bffc83 	ldbu	r2,-14(fp)
811199b0:	e0ffff17 	ldw	r3,-4(fp)
811199b4:	10809824 	muli	r2,r2,608
811199b8:	1885883a 	add	r2,r3,r2
811199bc:	10804304 	addi	r2,r2,268
811199c0:	1080000b 	ldhu	r2,0(r2)
811199c4:	10ffffcc 	andi	r3,r2,65535
811199c8:	e0bffc83 	ldbu	r2,-14(fp)
811199cc:	e13fff17 	ldw	r4,-4(fp)
811199d0:	10809824 	muli	r2,r2,608
811199d4:	2085883a 	add	r2,r4,r2
811199d8:	10804204 	addi	r2,r2,264
811199dc:	1080000b 	ldhu	r2,0(r2)
811199e0:	10bfffcc 	andi	r2,r2,65535
811199e4:	1885883a 	add	r2,r3,r2
811199e8:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811199ec:	e0bffc83 	ldbu	r2,-14(fp)
811199f0:	e0ffff17 	ldw	r3,-4(fp)
811199f4:	10809824 	muli	r2,r2,608
811199f8:	1885883a 	add	r2,r3,r2
811199fc:	10804284 	addi	r2,r2,266
81119a00:	1080000b 	ldhu	r2,0(r2)
81119a04:	10ffffcc 	andi	r3,r2,65535
81119a08:	e0bffc83 	ldbu	r2,-14(fp)
81119a0c:	e13fff17 	ldw	r4,-4(fp)
81119a10:	10809824 	muli	r2,r2,608
81119a14:	2085883a 	add	r2,r4,r2
81119a18:	10804184 	addi	r2,r2,262
81119a1c:	1080000b 	ldhu	r2,0(r2)
81119a20:	10bfffcc 	andi	r2,r2,65535
81119a24:	1887883a 	add	r3,r3,r2
81119a28:	e0bffc83 	ldbu	r2,-14(fp)
81119a2c:	e13fff17 	ldw	r4,-4(fp)
81119a30:	10809824 	muli	r2,r2,608
81119a34:	2085883a 	add	r2,r4,r2
81119a38:	10804104 	addi	r2,r2,260
81119a3c:	1080000b 	ldhu	r2,0(r2)
81119a40:	10bfffcc 	andi	r2,r2,65535
81119a44:	1885883a 	add	r2,r3,r2
81119a48:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81119a4c:	e03ffc05 	stb	zero,-16(fp)
81119a50:	00005506 	br	81119ba8 <vFillMemmoryPattern+0x2cc>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119a54:	00a045f4 	movhi	r2,33047
81119a58:	10a34f04 	addi	r2,r2,-29380
81119a5c:	10800a8b 	ldhu	r2,42(r2)
81119a60:	10bfffcc 	andi	r2,r2,65535
81119a64:	10800168 	cmpgeui	r2,r2,5
81119a68:	1000071e 	bne	r2,zero,81119a88 <vFillMemmoryPattern+0x1ac>
					fprintf(fp, "-----CCD %i\n", ccd_number);
81119a6c:	d0a06217 	ldw	r2,-32376(gp)
81119a70:	e0fffc03 	ldbu	r3,-16(fp)
81119a74:	180d883a 	mov	r6,r3
81119a78:	01604574 	movhi	r5,33045
81119a7c:	29420d04 	addi	r5,r5,2100
81119a80:	1009883a 	mov	r4,r2
81119a84:	11236500 	call	81123650 <fprintf>
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81119a88:	e03ffc45 	stb	zero,-15(fp)
81119a8c:	00004006 	br	81119b90 <vFillMemmoryPattern+0x2b4>
					if (ccd_side == 0){
81119a90:	e0bffc43 	ldbu	r2,-15(fp)
81119a94:	1000181e 	bne	r2,zero,81119af8 <vFillMemmoryPattern+0x21c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119a98:	00a045f4 	movhi	r2,33047
81119a9c:	10a34f04 	addi	r2,r2,-29380
81119aa0:	10800a8b 	ldhu	r2,42(r2)
81119aa4:	10bfffcc 	andi	r2,r2,65535
81119aa8:	10800168 	cmpgeui	r2,r2,5
81119aac:	1000071e 	bne	r2,zero,81119acc <vFillMemmoryPattern+0x1f0>
							fprintf(fp, "------Left side\n");
81119ab0:	d0a06217 	ldw	r2,-32376(gp)
81119ab4:	100f883a 	mov	r7,r2
81119ab8:	01800404 	movi	r6,16
81119abc:	01400044 	movi	r5,1
81119ac0:	01204574 	movhi	r4,33045
81119ac4:	21021104 	addi	r4,r4,2116
81119ac8:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81119acc:	e0bffc83 	ldbu	r2,-14(fp)
81119ad0:	e13ffc03 	ldbu	r4,-16(fp)
81119ad4:	e0ffff17 	ldw	r3,-4(fp)
81119ad8:	21000624 	muli	r4,r4,24
81119adc:	10809824 	muli	r2,r2,608
81119ae0:	2085883a 	add	r2,r4,r2
81119ae4:	1885883a 	add	r2,r3,r2
81119ae8:	10801b04 	addi	r2,r2,108
81119aec:	10800017 	ldw	r2,0(r2)
81119af0:	e0bffb15 	stw	r2,-20(fp)
81119af4:	00001706 	br	81119b54 <vFillMemmoryPattern+0x278>
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119af8:	00a045f4 	movhi	r2,33047
81119afc:	10a34f04 	addi	r2,r2,-29380
81119b00:	10800a8b 	ldhu	r2,42(r2)
81119b04:	10bfffcc 	andi	r2,r2,65535
81119b08:	10800168 	cmpgeui	r2,r2,5
81119b0c:	1000071e 	bne	r2,zero,81119b2c <vFillMemmoryPattern+0x250>
							fprintf(fp, "------Right side\n");
81119b10:	d0a06217 	ldw	r2,-32376(gp)
81119b14:	100f883a 	mov	r7,r2
81119b18:	01800444 	movi	r6,17
81119b1c:	01400044 	movi	r5,1
81119b20:	01204574 	movhi	r4,33045
81119b24:	21021604 	addi	r4,r4,2136
81119b28:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81119b2c:	e0bffc83 	ldbu	r2,-14(fp)
81119b30:	e13ffc03 	ldbu	r4,-16(fp)
81119b34:	e0ffff17 	ldw	r3,-4(fp)
81119b38:	21000624 	muli	r4,r4,24
81119b3c:	10809824 	muli	r2,r2,608
81119b40:	2085883a 	add	r2,r4,r2
81119b44:	1885883a 	add	r2,r3,r2
81119b48:	10801e04 	addi	r2,r2,120
81119b4c:	10800017 	ldw	r2,0(r2)
81119b50:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81119b54:	e0fffa03 	ldbu	r3,-24(fp)
81119b58:	e13ffc03 	ldbu	r4,-16(fp)
81119b5c:	e17ffc43 	ldbu	r5,-15(fp)
81119b60:	e0bffd17 	ldw	r2,-12(fp)
81119b64:	d8800115 	stw	r2,4(sp)
81119b68:	e0bffe17 	ldw	r2,-8(fp)
81119b6c:	d8800015 	stw	r2,0(sp)
81119b70:	280f883a 	mov	r7,r5
81119b74:	200d883a 	mov	r6,r4
81119b78:	e17ffb17 	ldw	r5,-20(fp)
81119b7c:	1809883a 	mov	r4,r3
81119b80:	11209000 	call	81120900 <pattern_createPattern>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp, "-----CCD %i\n", ccd_number);
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81119b84:	e0bffc43 	ldbu	r2,-15(fp)
81119b88:	10800044 	addi	r2,r2,1
81119b8c:	e0bffc45 	stb	r2,-15(fp)
81119b90:	e0bffc43 	ldbu	r2,-15(fp)
81119b94:	108000b0 	cmpltui	r2,r2,2
81119b98:	103fbd1e 	bne	r2,zero,81119a90 <__reset+0xfb0f9a90>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81119b9c:	e0bffc03 	ldbu	r2,-16(fp)
81119ba0:	10800044 	addi	r2,r2,1
81119ba4:	e0bffc05 	stb	r2,-16(fp)
81119ba8:	e0bffc03 	ldbu	r2,-16(fp)
81119bac:	10800130 	cmpltui	r2,r2,4
81119bb0:	103fa81e 	bne	r2,zero,81119a54 <__reset+0xfb0f9a54>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			fprintf(fp, "Memory %i\n",mem_number);
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81119bb4:	e0bffc83 	ldbu	r2,-14(fp)
81119bb8:	10800044 	addi	r2,r2,1
81119bbc:	e0bffc85 	stb	r2,-14(fp)
81119bc0:	e0fffc83 	ldbu	r3,-14(fp)
81119bc4:	e0bffcc3 	ldbu	r2,-13(fp)
81119bc8:	18bf6b36 	bltu	r3,r2,81119978 <__reset+0xfb0f9978>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81119bcc:	e0bffa03 	ldbu	r2,-24(fp)
81119bd0:	10800044 	addi	r2,r2,1
81119bd4:	e0bffa05 	stb	r2,-24(fp)
81119bd8:	e0bffa03 	ldbu	r2,-24(fp)
81119bdc:	108000b0 	cmpltui	r2,r2,2
81119be0:	103f561e 	bne	r2,zero,8111993c <__reset+0xfb0f993c>
			}
		}
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119be4:	00a045f4 	movhi	r2,33047
81119be8:	10a34f04 	addi	r2,r2,-29380
81119bec:	10800a8b 	ldhu	r2,42(r2)
81119bf0:	10bfffcc 	andi	r2,r2,65535
81119bf4:	10800168 	cmpgeui	r2,r2,5
81119bf8:	1000071e 	bne	r2,zero,81119c18 <vFillMemmoryPattern+0x33c>
	debug(fp, "\nMemory Filled\n");
81119bfc:	d0a06217 	ldw	r2,-32376(gp)
81119c00:	100f883a 	mov	r7,r2
81119c04:	018003c4 	movi	r6,15
81119c08:	01400044 	movi	r5,1
81119c0c:	01204574 	movhi	r4,33045
81119c10:	21021b04 	addi	r4,r4,2156
81119c14:	1123cec0 	call	81123cec <fwrite>
	}
#endif

}
81119c18:	0001883a 	nop
81119c1c:	e037883a 	mov	sp,fp
81119c20:	dfc00117 	ldw	ra,4(sp)
81119c24:	df000017 	ldw	fp,0(sp)
81119c28:	dec00204 	addi	sp,sp,8
81119c2c:	f800283a 	ret

81119c30 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81119c30:	defffd04 	addi	sp,sp,-12
81119c34:	de00012e 	bgeu	sp,et,81119c3c <vCCDLoadDefaultValues+0xc>
81119c38:	003b68fa 	trap	3
81119c3c:	dfc00215 	stw	ra,8(sp)
81119c40:	df000115 	stw	fp,4(sp)
81119c44:	df000104 	addi	fp,sp,4
81119c48:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
81119c4c:	00a045f4 	movhi	r2,33047
81119c50:	10a34f04 	addi	r2,r2,-29380
81119c54:	10c0030b 	ldhu	r3,12(r2)
81119c58:	e0bfff17 	ldw	r2,-4(fp)
81119c5c:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
81119c60:	00a045f4 	movhi	r2,33047
81119c64:	10a34f04 	addi	r2,r2,-29380
81119c68:	10c0020b 	ldhu	r3,8(r2)
81119c6c:	e0bfff17 	ldw	r2,-4(fp)
81119c70:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81119c74:	00a045f4 	movhi	r2,33047
81119c78:	10a34f04 	addi	r2,r2,-29380
81119c7c:	10c0028b 	ldhu	r3,10(r2)
81119c80:	e0bfff17 	ldw	r2,-4(fp)
81119c84:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81119c88:	00a045f4 	movhi	r2,33047
81119c8c:	10a34f04 	addi	r2,r2,-29380
81119c90:	10c0010b 	ldhu	r3,4(r2)
81119c94:	e0bfff17 	ldw	r2,-4(fp)
81119c98:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
81119c9c:	00a045f4 	movhi	r2,33047
81119ca0:	10a34f04 	addi	r2,r2,-29380
81119ca4:	10c0018b 	ldhu	r3,6(r2)
81119ca8:	e0bfff17 	ldw	r2,-4(fp)
81119cac:	10c0000d 	sth	r3,0(r2)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81119cb0:	00a045f4 	movhi	r2,33047
81119cb4:	10a34f04 	addi	r2,r2,-29380
81119cb8:	10800a8b 	ldhu	r2,42(r2)
81119cbc:	10bfffcc 	andi	r2,r2,65535
81119cc0:	108000e8 	cmpgeui	r2,r2,3
81119cc4:	10002d1e 	bne	r2,zero,81119d7c <vCCDLoadDefaultValues+0x14c>
		fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
81119cc8:	d0e06217 	ldw	r3,-32376(gp)
81119ccc:	e0bfff17 	ldw	r2,-4(fp)
81119cd0:	1080020b 	ldhu	r2,8(r2)
81119cd4:	10bfffcc 	andi	r2,r2,65535
81119cd8:	100d883a 	mov	r6,r2
81119cdc:	01604574 	movhi	r5,33045
81119ce0:	29421f04 	addi	r5,r5,2172
81119ce4:	1809883a 	mov	r4,r3
81119ce8:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
81119cec:	d0e06217 	ldw	r3,-32376(gp)
81119cf0:	e0bfff17 	ldw	r2,-4(fp)
81119cf4:	1080010b 	ldhu	r2,4(r2)
81119cf8:	10bfffcc 	andi	r2,r2,65535
81119cfc:	100d883a 	mov	r6,r2
81119d00:	01604574 	movhi	r5,33045
81119d04:	29422304 	addi	r5,r5,2188
81119d08:	1809883a 	mov	r4,r3
81119d0c:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
81119d10:	d0e06217 	ldw	r3,-32376(gp)
81119d14:	e0bfff17 	ldw	r2,-4(fp)
81119d18:	1080018b 	ldhu	r2,6(r2)
81119d1c:	10bfffcc 	andi	r2,r2,65535
81119d20:	100d883a 	mov	r6,r2
81119d24:	01604574 	movhi	r5,33045
81119d28:	29422604 	addi	r5,r5,2200
81119d2c:	1809883a 	mov	r4,r3
81119d30:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
81119d34:	d0e06217 	ldw	r3,-32376(gp)
81119d38:	e0bfff17 	ldw	r2,-4(fp)
81119d3c:	1080008b 	ldhu	r2,2(r2)
81119d40:	10bfffcc 	andi	r2,r2,65535
81119d44:	100d883a 	mov	r6,r2
81119d48:	01604574 	movhi	r5,33045
81119d4c:	29422b04 	addi	r5,r5,2220
81119d50:	1809883a 	mov	r4,r3
81119d54:	11236500 	call	81123650 <fprintf>
		fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
81119d58:	d0e06217 	ldw	r3,-32376(gp)
81119d5c:	e0bfff17 	ldw	r2,-4(fp)
81119d60:	1080000b 	ldhu	r2,0(r2)
81119d64:	10bfffcc 	andi	r2,r2,65535
81119d68:	100d883a 	mov	r6,r2
81119d6c:	01604574 	movhi	r5,33045
81119d70:	29423004 	addi	r5,r5,2240
81119d74:	1809883a 	mov	r4,r3
81119d78:	11236500 	call	81123650 <fprintf>
	}
#endif

}
81119d7c:	0001883a 	nop
81119d80:	e037883a 	mov	sp,fp
81119d84:	dfc00117 	ldw	ra,4(sp)
81119d88:	df000017 	ldw	fp,0(sp)
81119d8c:	dec00204 	addi	sp,sp,8
81119d90:	f800283a 	ret

81119d94 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81119d94:	defff904 	addi	sp,sp,-28
81119d98:	de00012e 	bgeu	sp,et,81119da0 <vCCDChangeValues+0xc>
81119d9c:	003b68fa 	trap	3
81119da0:	df000615 	stw	fp,24(sp)
81119da4:	df000604 	addi	fp,sp,24
81119da8:	e13ffa15 	stw	r4,-24(fp)
81119dac:	2811883a 	mov	r8,r5
81119db0:	300b883a 	mov	r5,r6
81119db4:	3809883a 	mov	r4,r7
81119db8:	e0c00117 	ldw	r3,4(fp)
81119dbc:	e0800217 	ldw	r2,8(fp)
81119dc0:	e23ffb0d 	sth	r8,-20(fp)
81119dc4:	e17ffc0d 	sth	r5,-16(fp)
81119dc8:	e13ffd0d 	sth	r4,-12(fp)
81119dcc:	e0fffe0d 	sth	r3,-8(fp)
81119dd0:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81119dd4:	e0bffa17 	ldw	r2,-24(fp)
81119dd8:	e0fffb0b 	ldhu	r3,-20(fp)
81119ddc:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81119de0:	e0bffa17 	ldw	r2,-24(fp)
81119de4:	e0fffc0b 	ldhu	r3,-16(fp)
81119de8:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81119dec:	e0bffa17 	ldw	r2,-24(fp)
81119df0:	e0fffd0b 	ldhu	r3,-12(fp)
81119df4:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81119df8:	e0bffa17 	ldw	r2,-24(fp)
81119dfc:	e0fffe0b 	ldhu	r3,-8(fp)
81119e00:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81119e04:	e0bffa17 	ldw	r2,-24(fp)
81119e08:	e0ffff0b 	ldhu	r3,-4(fp)
81119e0c:	10c0000d 	sth	r3,0(r2)
}
81119e10:	0001883a 	nop
81119e14:	e037883a 	mov	sp,fp
81119e18:	df000017 	ldw	fp,0(sp)
81119e1c:	dec00104 	addi	sp,sp,4
81119e20:	f800283a 	ret

81119e24 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81119e24:	defff904 	addi	sp,sp,-28
81119e28:	de00012e 	bgeu	sp,et,81119e30 <bSendUART128v2+0xc>
81119e2c:	003b68fa 	trap	3
81119e30:	dfc00615 	stw	ra,24(sp)
81119e34:	df000515 	stw	fp,20(sp)
81119e38:	df000504 	addi	fp,sp,20
81119e3c:	e13ffe15 	stw	r4,-8(fp)
81119e40:	2805883a 	mov	r2,r5
81119e44:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81119e48:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81119e4c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119e50:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119e54:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119e58:	d0a06317 	ldw	r2,-32372(gp)
81119e5c:	e0fffd04 	addi	r3,fp,-12
81119e60:	180d883a 	mov	r6,r3
81119e64:	01400504 	movi	r5,20
81119e68:	1009883a 	mov	r4,r2
81119e6c:	1140b0c0 	call	81140b0c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81119e70:	e0bffd03 	ldbu	r2,-12(fp)
81119e74:	10803fcc 	andi	r2,r2,255
81119e78:	10000326 	beq	r2,zero,81119e88 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81119e7c:	111db140 	call	8111db14 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81119e80:	e0bffc17 	ldw	r2,-16(fp)
81119e84:	0000aa06 	br	8111a130 <bSendUART128v2+0x30c>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81119e88:	d0a06e17 	ldw	r2,-32328(gp)
81119e8c:	e0fffd04 	addi	r3,fp,-12
81119e90:	180d883a 	mov	r6,r3
81119e94:	01400104 	movi	r5,4
81119e98:	1009883a 	mov	r4,r2
81119e9c:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119ea0:	e0bffd03 	ldbu	r2,-12(fp)
81119ea4:	10803fcc 	andi	r2,r2,255
81119ea8:	10001726 	beq	r2,zero,81119f08 <bSendUART128v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119eac:	00a045f4 	movhi	r2,33047
81119eb0:	10a34f04 	addi	r2,r2,-29380
81119eb4:	10800a8b 	ldhu	r2,42(r2)
81119eb8:	10bfffcc 	andi	r2,r2,65535
81119ebc:	10800228 	cmpgeui	r2,r2,8
81119ec0:	1000071e 	bne	r2,zero,81119ee0 <bSendUART128v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81119ec4:	d0a06217 	ldw	r2,-32376(gp)
81119ec8:	100f883a 	mov	r7,r2
81119ecc:	01801484 	movi	r6,82
81119ed0:	01400044 	movi	r5,1
81119ed4:	01204574 	movhi	r4,33045
81119ed8:	21023504 	addi	r4,r4,2260
81119edc:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81119ee0:	d0a06317 	ldw	r2,-32372(gp)
81119ee4:	1009883a 	mov	r4,r2
81119ee8:	1140e940 	call	81140e94 <OSSemPost>
81119eec:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119ef0:	e0bffd03 	ldbu	r2,-12(fp)
81119ef4:	10803fcc 	andi	r2,r2,255
81119ef8:	10000126 	beq	r2,zero,81119f00 <bSendUART128v2+0xdc>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81119efc:	111da940 	call	8111da94 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81119f00:	e0bffc17 	ldw	r2,-16(fp)
81119f04:	00008a06 	br	8111a130 <bSendUART128v2+0x30c>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119f08:	e03ffb05 	stb	zero,-20(fp)
81119f0c:	00004306 	br	8111a01c <bSendUART128v2+0x1f8>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81119f10:	e0fffb03 	ldbu	r3,-20(fp)
81119f14:	00a045b4 	movhi	r2,33046
81119f18:	10836d04 	addi	r2,r2,3508
81119f1c:	18c7883a 	add	r3,r3,r3
81119f20:	18c7883a 	add	r3,r3,r3
81119f24:	10c5883a 	add	r2,r2,r3
81119f28:	10800017 	ldw	r2,0(r2)
81119f2c:	1000381e 	bne	r2,zero,8111a010 <bSendUART128v2+0x1ec>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81119f30:	e0bffb03 	ldbu	r2,-20(fp)
81119f34:	10c02324 	muli	r3,r2,140
81119f38:	00a045b4 	movhi	r2,33046
81119f3c:	10838b04 	addi	r2,r2,3628
81119f40:	1885883a 	add	r2,r3,r2
81119f44:	01802004 	movi	r6,128
81119f48:	000b883a 	mov	r5,zero
81119f4c:	1009883a 	mov	r4,r2
81119f50:	11248500 	call	81124850 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81119f54:	e0bffb03 	ldbu	r2,-20(fp)
81119f58:	10c02324 	muli	r3,r2,140
81119f5c:	00a045b4 	movhi	r2,33046
81119f60:	10838b04 	addi	r2,r2,3628
81119f64:	1885883a 	add	r2,r3,r2
81119f68:	01801fc4 	movi	r6,127
81119f6c:	e17ffe17 	ldw	r5,-8(fp)
81119f70:	1009883a 	mov	r4,r2
81119f74:	11247000 	call	81124700 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81119f78:	e13ffb03 	ldbu	r4,-20(fp)
81119f7c:	e0ffff0b 	ldhu	r3,-4(fp)
81119f80:	00a045b4 	movhi	r2,33046
81119f84:	10838b04 	addi	r2,r2,3628
81119f88:	21002324 	muli	r4,r4,140
81119f8c:	1105883a 	add	r2,r2,r4
81119f90:	10802104 	addi	r2,r2,132
81119f94:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81119f98:	e0fffb03 	ldbu	r3,-20(fp)
81119f9c:	00a045b4 	movhi	r2,33046
81119fa0:	10838b04 	addi	r2,r2,3628
81119fa4:	18c02324 	muli	r3,r3,140
81119fa8:	10c5883a 	add	r2,r2,r3
81119fac:	10802204 	addi	r2,r2,136
81119fb0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81119fb4:	e0fffb03 	ldbu	r3,-20(fp)
81119fb8:	00a045b4 	movhi	r2,33046
81119fbc:	10838b04 	addi	r2,r2,3628
81119fc0:	18c02324 	muli	r3,r3,140
81119fc4:	10c5883a 	add	r2,r2,r3
81119fc8:	10802184 	addi	r2,r2,134
81119fcc:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81119fd0:	e0fffb03 	ldbu	r3,-20(fp)
81119fd4:	00a045b4 	movhi	r2,33046
81119fd8:	10838b04 	addi	r2,r2,3628
81119fdc:	18c02324 	muli	r3,r3,140
81119fe0:	10c5883a 	add	r2,r2,r3
81119fe4:	10802004 	addi	r2,r2,128
81119fe8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81119fec:	e0fffb03 	ldbu	r3,-20(fp)
81119ff0:	00a045b4 	movhi	r2,33046
81119ff4:	10836d04 	addi	r2,r2,3508
81119ff8:	18c7883a 	add	r3,r3,r3
81119ffc:	18c7883a 	add	r3,r3,r3
8111a000:	10c5883a 	add	r2,r2,r3
8111a004:	00c00044 	movi	r3,1
8111a008:	10c00015 	stw	r3,0(r2)
			break;
8111a00c:	00000606 	br	8111a028 <bSendUART128v2+0x204>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111a010:	e0bffb03 	ldbu	r2,-20(fp)
8111a014:	10800044 	addi	r2,r2,1
8111a018:	e0bffb05 	stb	r2,-20(fp)
8111a01c:	e0bffb03 	ldbu	r2,-20(fp)
8111a020:	108001b0 	cmpltui	r2,r2,6
8111a024:	103fba1e 	bne	r2,zero,81119f10 <__reset+0xfb0f9f10>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
8111a028:	e0bffb03 	ldbu	r2,-20(fp)
8111a02c:	108001b0 	cmpltui	r2,r2,6
8111a030:	1000091e 	bne	r2,zero,8111a058 <bSendUART128v2+0x234>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
8111a034:	d0a06317 	ldw	r2,-32372(gp)
8111a038:	1009883a 	mov	r4,r2
8111a03c:	1140e940 	call	81140e94 <OSSemPost>
8111a040:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
8111a044:	d0a06e17 	ldw	r2,-32328(gp)
8111a048:	1009883a 	mov	r4,r2
8111a04c:	113f0a40 	call	8113f0a4 <OSMutexPost>
		return bSuccessL;
8111a050:	e0bffc17 	ldw	r2,-16(fp)
8111a054:	00003606 	br	8111a130 <bSendUART128v2+0x30c>
	}

	bSuccessL = TRUE;
8111a058:	00800044 	movi	r2,1
8111a05c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
8111a060:	d0a07543 	ldbu	r2,-32299(gp)
8111a064:	10bfffc4 	addi	r2,r2,-1
8111a068:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111a06c:	d0a07417 	ldw	r2,-32304(gp)
8111a070:	e0fffd04 	addi	r3,fp,-12
8111a074:	180d883a 	mov	r6,r3
8111a078:	01400084 	movi	r5,2
8111a07c:	1009883a 	mov	r4,r2
8111a080:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a084:	e0bffd03 	ldbu	r2,-12(fp)
8111a088:	10803fcc 	andi	r2,r2,255
8111a08c:	10001226 	beq	r2,zero,8111a0d8 <bSendUART128v2+0x2b4>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a090:	00a045f4 	movhi	r2,33047
8111a094:	10a34f04 	addi	r2,r2,-29380
8111a098:	10800a8b 	ldhu	r2,42(r2)
8111a09c:	10bfffcc 	andi	r2,r2,65535
8111a0a0:	10800228 	cmpgeui	r2,r2,8
8111a0a4:	1000071e 	bne	r2,zero,8111a0c4 <bSendUART128v2+0x2a0>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
8111a0a8:	d0a06217 	ldw	r2,-32376(gp)
8111a0ac:	100f883a 	mov	r7,r2
8111a0b0:	01801c04 	movi	r6,112
8111a0b4:	01400044 	movi	r5,1
8111a0b8:	01204574 	movhi	r4,33045
8111a0bc:	21024a04 	addi	r4,r4,2344
8111a0c0:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8111a0c4:	d0a06e17 	ldw	r2,-32328(gp)
8111a0c8:	1009883a 	mov	r4,r2
8111a0cc:	113f0a40 	call	8113f0a4 <OSMutexPost>
		return bSuccessL;
8111a0d0:	e0bffc17 	ldw	r2,-16(fp)
8111a0d4:	00001606 	br	8111a130 <bSendUART128v2+0x30c>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
8111a0d8:	e0bffb03 	ldbu	r2,-20(fp)
8111a0dc:	10c02324 	muli	r3,r2,140
8111a0e0:	00a045b4 	movhi	r2,33046
8111a0e4:	10838b04 	addi	r2,r2,3628
8111a0e8:	1885883a 	add	r2,r3,r2
8111a0ec:	1009883a 	mov	r4,r2
8111a0f0:	1124c200 	call	81124c20 <puts>
	xBuffer128[ucIL].bSent = TRUE;
8111a0f4:	e0fffb03 	ldbu	r3,-20(fp)
8111a0f8:	00a045b4 	movhi	r2,33046
8111a0fc:	10838b04 	addi	r2,r2,3628
8111a100:	18c02324 	muli	r3,r3,140
8111a104:	10c5883a 	add	r2,r2,r3
8111a108:	10802004 	addi	r2,r2,128
8111a10c:	00c00044 	movi	r3,1
8111a110:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
8111a114:	d0a07417 	ldw	r2,-32304(gp)
8111a118:	1009883a 	mov	r4,r2
8111a11c:	113f0a40 	call	8113f0a4 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
8111a120:	d0a06e17 	ldw	r2,-32328(gp)
8111a124:	1009883a 	mov	r4,r2
8111a128:	113f0a40 	call	8113f0a4 <OSMutexPost>

	return bSuccessL;
8111a12c:	e0bffc17 	ldw	r2,-16(fp)
}
8111a130:	e037883a 	mov	sp,fp
8111a134:	dfc00117 	ldw	ra,4(sp)
8111a138:	df000017 	ldw	fp,0(sp)
8111a13c:	dec00204 	addi	sp,sp,8
8111a140:	f800283a 	ret

8111a144 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
8111a144:	defff904 	addi	sp,sp,-28
8111a148:	de00012e 	bgeu	sp,et,8111a150 <bSendUART64v2+0xc>
8111a14c:	003b68fa 	trap	3
8111a150:	dfc00615 	stw	ra,24(sp)
8111a154:	df000515 	stw	fp,20(sp)
8111a158:	df000504 	addi	fp,sp,20
8111a15c:	e13ffe15 	stw	r4,-8(fp)
8111a160:	2805883a 	mov	r2,r5
8111a164:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8111a168:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111a16c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111a170:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111a174:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111a178:	d0a05e17 	ldw	r2,-32392(gp)
8111a17c:	e0fffd04 	addi	r3,fp,-12
8111a180:	180d883a 	mov	r6,r3
8111a184:	01400504 	movi	r5,20
8111a188:	1009883a 	mov	r4,r2
8111a18c:	1140b0c0 	call	81140b0c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111a190:	e0bffd03 	ldbu	r2,-12(fp)
8111a194:	10803fcc 	andi	r2,r2,255
8111a198:	10000326 	beq	r2,zero,8111a1a8 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111a19c:	111db940 	call	8111db94 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
8111a1a0:	e0bffc17 	ldw	r2,-16(fp)
8111a1a4:	0000ac06 	br	8111a458 <bSendUART64v2+0x314>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111a1a8:	d0a07117 	ldw	r2,-32316(gp)
8111a1ac:	e0fffd04 	addi	r3,fp,-12
8111a1b0:	180d883a 	mov	r6,r3
8111a1b4:	01400104 	movi	r5,4
8111a1b8:	1009883a 	mov	r4,r2
8111a1bc:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a1c0:	e0bffd03 	ldbu	r2,-12(fp)
8111a1c4:	10803fcc 	andi	r2,r2,255
8111a1c8:	10001726 	beq	r2,zero,8111a228 <bSendUART64v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a1cc:	00a045f4 	movhi	r2,33047
8111a1d0:	10a34f04 	addi	r2,r2,-29380
8111a1d4:	10800a8b 	ldhu	r2,42(r2)
8111a1d8:	10bfffcc 	andi	r2,r2,65535
8111a1dc:	10800228 	cmpgeui	r2,r2,8
8111a1e0:	1000071e 	bne	r2,zero,8111a200 <bSendUART64v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
8111a1e4:	d0a06217 	ldw	r2,-32376(gp)
8111a1e8:	100f883a 	mov	r7,r2
8111a1ec:	018013c4 	movi	r6,79
8111a1f0:	01400044 	movi	r5,1
8111a1f4:	01204574 	movhi	r4,33045
8111a1f8:	21026704 	addi	r4,r4,2460
8111a1fc:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8111a200:	d0a05e17 	ldw	r2,-32392(gp)
8111a204:	1009883a 	mov	r4,r2
8111a208:	1140e940 	call	81140e94 <OSSemPost>
8111a20c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8111a210:	e0bffd03 	ldbu	r2,-12(fp)
8111a214:	10803fcc 	andi	r2,r2,255
8111a218:	10000126 	beq	r2,zero,8111a220 <bSendUART64v2+0xdc>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111a21c:	111da140 	call	8111da14 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
8111a220:	e0bffc17 	ldw	r2,-16(fp)
8111a224:	00008c06 	br	8111a458 <bSendUART64v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111a228:	e03ffb05 	stb	zero,-20(fp)
8111a22c:	00004506 	br	8111a344 <bSendUART64v2+0x200>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
8111a230:	e0fffb03 	ldbu	r3,-20(fp)
8111a234:	00a045b4 	movhi	r2,33046
8111a238:	10836d04 	addi	r2,r2,3508
8111a23c:	18c00184 	addi	r3,r3,6
8111a240:	18c7883a 	add	r3,r3,r3
8111a244:	18c7883a 	add	r3,r3,r3
8111a248:	10c5883a 	add	r2,r2,r3
8111a24c:	10800017 	ldw	r2,0(r2)
8111a250:	1000391e 	bne	r2,zero,8111a338 <bSendUART64v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
8111a254:	e0bffb03 	ldbu	r2,-20(fp)
8111a258:	10c01324 	muli	r3,r2,76
8111a25c:	00a04574 	movhi	r2,33045
8111a260:	109f2f04 	addi	r2,r2,31932
8111a264:	1885883a 	add	r2,r3,r2
8111a268:	01801004 	movi	r6,64
8111a26c:	000b883a 	mov	r5,zero
8111a270:	1009883a 	mov	r4,r2
8111a274:	11248500 	call	81124850 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
8111a278:	e0bffb03 	ldbu	r2,-20(fp)
8111a27c:	10c01324 	muli	r3,r2,76
8111a280:	00a04574 	movhi	r2,33045
8111a284:	109f2f04 	addi	r2,r2,31932
8111a288:	1885883a 	add	r2,r3,r2
8111a28c:	01800fc4 	movi	r6,63
8111a290:	e17ffe17 	ldw	r5,-8(fp)
8111a294:	1009883a 	mov	r4,r2
8111a298:	11247000 	call	81124700 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
8111a29c:	e13ffb03 	ldbu	r4,-20(fp)
8111a2a0:	e0ffff0b 	ldhu	r3,-4(fp)
8111a2a4:	00a04574 	movhi	r2,33045
8111a2a8:	109f2f04 	addi	r2,r2,31932
8111a2ac:	21001324 	muli	r4,r4,76
8111a2b0:	1105883a 	add	r2,r2,r4
8111a2b4:	10801104 	addi	r2,r2,68
8111a2b8:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
8111a2bc:	e0fffb03 	ldbu	r3,-20(fp)
8111a2c0:	00a04574 	movhi	r2,33045
8111a2c4:	109f2f04 	addi	r2,r2,31932
8111a2c8:	18c01324 	muli	r3,r3,76
8111a2cc:	10c5883a 	add	r2,r2,r3
8111a2d0:	10801204 	addi	r2,r2,72
8111a2d4:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
8111a2d8:	e0fffb03 	ldbu	r3,-20(fp)
8111a2dc:	00a04574 	movhi	r2,33045
8111a2e0:	109f2f04 	addi	r2,r2,31932
8111a2e4:	18c01324 	muli	r3,r3,76
8111a2e8:	10c5883a 	add	r2,r2,r3
8111a2ec:	10801184 	addi	r2,r2,70
8111a2f0:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
8111a2f4:	e0fffb03 	ldbu	r3,-20(fp)
8111a2f8:	00a04574 	movhi	r2,33045
8111a2fc:	109f2f04 	addi	r2,r2,31932
8111a300:	18c01324 	muli	r3,r3,76
8111a304:	10c5883a 	add	r2,r2,r3
8111a308:	10801004 	addi	r2,r2,64
8111a30c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
8111a310:	e0fffb03 	ldbu	r3,-20(fp)
8111a314:	00a045b4 	movhi	r2,33046
8111a318:	10836d04 	addi	r2,r2,3508
8111a31c:	18c00184 	addi	r3,r3,6
8111a320:	18c7883a 	add	r3,r3,r3
8111a324:	18c7883a 	add	r3,r3,r3
8111a328:	10c5883a 	add	r2,r2,r3
8111a32c:	00c00044 	movi	r3,1
8111a330:	10c00015 	stw	r3,0(r2)
			break;
8111a334:	00000606 	br	8111a350 <bSendUART64v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111a338:	e0bffb03 	ldbu	r2,-20(fp)
8111a33c:	10800044 	addi	r2,r2,1
8111a340:	e0bffb05 	stb	r2,-20(fp)
8111a344:	e0bffb03 	ldbu	r2,-20(fp)
8111a348:	10800230 	cmpltui	r2,r2,8
8111a34c:	103fb81e 	bne	r2,zero,8111a230 <__reset+0xfb0fa230>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
8111a350:	e0bffb03 	ldbu	r2,-20(fp)
8111a354:	10800230 	cmpltui	r2,r2,8
8111a358:	1000091e 	bne	r2,zero,8111a380 <bSendUART64v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8111a35c:	d0a05e17 	ldw	r2,-32392(gp)
8111a360:	1009883a 	mov	r4,r2
8111a364:	1140e940 	call	81140e94 <OSSemPost>
8111a368:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
8111a36c:	d0a07117 	ldw	r2,-32316(gp)
8111a370:	1009883a 	mov	r4,r2
8111a374:	113f0a40 	call	8113f0a4 <OSMutexPost>
		return bSuccessL;
8111a378:	e0bffc17 	ldw	r2,-16(fp)
8111a37c:	00003606 	br	8111a458 <bSendUART64v2+0x314>
	}

	bSuccessL = TRUE;
8111a380:	00800044 	movi	r2,1
8111a384:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
8111a388:	d0a07503 	ldbu	r2,-32300(gp)
8111a38c:	10bfffc4 	addi	r2,r2,-1
8111a390:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111a394:	d0a07417 	ldw	r2,-32304(gp)
8111a398:	e0fffd04 	addi	r3,fp,-12
8111a39c:	180d883a 	mov	r6,r3
8111a3a0:	01400084 	movi	r5,2
8111a3a4:	1009883a 	mov	r4,r2
8111a3a8:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a3ac:	e0bffd03 	ldbu	r2,-12(fp)
8111a3b0:	10803fcc 	andi	r2,r2,255
8111a3b4:	10001226 	beq	r2,zero,8111a400 <bSendUART64v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a3b8:	00a045f4 	movhi	r2,33047
8111a3bc:	10a34f04 	addi	r2,r2,-29380
8111a3c0:	10800a8b 	ldhu	r2,42(r2)
8111a3c4:	10bfffcc 	andi	r2,r2,65535
8111a3c8:	10800228 	cmpgeui	r2,r2,8
8111a3cc:	1000071e 	bne	r2,zero,8111a3ec <bSendUART64v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
8111a3d0:	d0a06217 	ldw	r2,-32376(gp)
8111a3d4:	100f883a 	mov	r7,r2
8111a3d8:	01801bc4 	movi	r6,111
8111a3dc:	01400044 	movi	r5,1
8111a3e0:	01204574 	movhi	r4,33045
8111a3e4:	21027b04 	addi	r4,r4,2540
8111a3e8:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
8111a3ec:	d0a07117 	ldw	r2,-32316(gp)
8111a3f0:	1009883a 	mov	r4,r2
8111a3f4:	113f0a40 	call	8113f0a4 <OSMutexPost>
		return bSuccessL;
8111a3f8:	e0bffc17 	ldw	r2,-16(fp)
8111a3fc:	00001606 	br	8111a458 <bSendUART64v2+0x314>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8111a400:	e0bffb03 	ldbu	r2,-20(fp)
8111a404:	10c01324 	muli	r3,r2,76
8111a408:	00a04574 	movhi	r2,33045
8111a40c:	109f2f04 	addi	r2,r2,31932
8111a410:	1885883a 	add	r2,r3,r2
8111a414:	1009883a 	mov	r4,r2
8111a418:	1124c200 	call	81124c20 <puts>
	xBuffer64[ucIL].bSent = TRUE;
8111a41c:	e0fffb03 	ldbu	r3,-20(fp)
8111a420:	00a04574 	movhi	r2,33045
8111a424:	109f2f04 	addi	r2,r2,31932
8111a428:	18c01324 	muli	r3,r3,76
8111a42c:	10c5883a 	add	r2,r2,r3
8111a430:	10801004 	addi	r2,r2,64
8111a434:	00c00044 	movi	r3,1
8111a438:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
8111a43c:	d0a07417 	ldw	r2,-32304(gp)
8111a440:	1009883a 	mov	r4,r2
8111a444:	113f0a40 	call	8113f0a4 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
8111a448:	d0a07117 	ldw	r2,-32316(gp)
8111a44c:	1009883a 	mov	r4,r2
8111a450:	113f0a40 	call	8113f0a4 <OSMutexPost>

	return bSuccessL;
8111a454:	e0bffc17 	ldw	r2,-16(fp)
}
8111a458:	e037883a 	mov	sp,fp
8111a45c:	dfc00117 	ldw	ra,4(sp)
8111a460:	df000017 	ldw	fp,0(sp)
8111a464:	dec00204 	addi	sp,sp,8
8111a468:	f800283a 	ret

8111a46c <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8111a46c:	defff904 	addi	sp,sp,-28
8111a470:	de00012e 	bgeu	sp,et,8111a478 <bSendUART32v2+0xc>
8111a474:	003b68fa 	trap	3
8111a478:	dfc00615 	stw	ra,24(sp)
8111a47c:	df000515 	stw	fp,20(sp)
8111a480:	df000504 	addi	fp,sp,20
8111a484:	e13ffe15 	stw	r4,-8(fp)
8111a488:	2805883a 	mov	r2,r5
8111a48c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8111a490:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111a494:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111a498:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111a49c:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111a4a0:	d0a06f17 	ldw	r2,-32324(gp)
8111a4a4:	e0fffd04 	addi	r3,fp,-12
8111a4a8:	180d883a 	mov	r6,r3
8111a4ac:	01400504 	movi	r5,20
8111a4b0:	1009883a 	mov	r4,r2
8111a4b4:	1140b0c0 	call	81140b0c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111a4b8:	e0bffd03 	ldbu	r2,-12(fp)
8111a4bc:	10803fcc 	andi	r2,r2,255
8111a4c0:	10000326 	beq	r2,zero,8111a4d0 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111a4c4:	111dc140 	call	8111dc14 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8111a4c8:	e0bffc17 	ldw	r2,-16(fp)
8111a4cc:	0000ac06 	br	8111a780 <bSendUART32v2+0x314>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111a4d0:	d0a06c17 	ldw	r2,-32336(gp)
8111a4d4:	e0fffd04 	addi	r3,fp,-12
8111a4d8:	180d883a 	mov	r6,r3
8111a4dc:	01400104 	movi	r5,4
8111a4e0:	1009883a 	mov	r4,r2
8111a4e4:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a4e8:	e0bffd03 	ldbu	r2,-12(fp)
8111a4ec:	10803fcc 	andi	r2,r2,255
8111a4f0:	10001726 	beq	r2,zero,8111a550 <bSendUART32v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a4f4:	00a045f4 	movhi	r2,33047
8111a4f8:	10a34f04 	addi	r2,r2,-29380
8111a4fc:	10800a8b 	ldhu	r2,42(r2)
8111a500:	10bfffcc 	andi	r2,r2,65535
8111a504:	10800228 	cmpgeui	r2,r2,8
8111a508:	1000071e 	bne	r2,zero,8111a528 <bSendUART32v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
8111a50c:	d0a06217 	ldw	r2,-32376(gp)
8111a510:	100f883a 	mov	r7,r2
8111a514:	018013c4 	movi	r6,79
8111a518:	01400044 	movi	r5,1
8111a51c:	01204574 	movhi	r4,33045
8111a520:	21029704 	addi	r4,r4,2652
8111a524:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8111a528:	d0a06f17 	ldw	r2,-32324(gp)
8111a52c:	1009883a 	mov	r4,r2
8111a530:	1140e940 	call	81140e94 <OSSemPost>
8111a534:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8111a538:	e0bffd03 	ldbu	r2,-12(fp)
8111a53c:	10803fcc 	andi	r2,r2,255
8111a540:	10000126 	beq	r2,zero,8111a548 <bSendUART32v2+0xdc>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111a544:	111d9940 	call	8111d994 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
8111a548:	e0bffc17 	ldw	r2,-16(fp)
8111a54c:	00008c06 	br	8111a780 <bSendUART32v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8111a550:	e03ffb05 	stb	zero,-20(fp)
8111a554:	00004506 	br	8111a66c <bSendUART32v2+0x200>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
8111a558:	e0fffb03 	ldbu	r3,-20(fp)
8111a55c:	00a045b4 	movhi	r2,33046
8111a560:	10836d04 	addi	r2,r2,3508
8111a564:	18c00384 	addi	r3,r3,14
8111a568:	18c7883a 	add	r3,r3,r3
8111a56c:	18c7883a 	add	r3,r3,r3
8111a570:	10c5883a 	add	r2,r2,r3
8111a574:	10800017 	ldw	r2,0(r2)
8111a578:	1000391e 	bne	r2,zero,8111a660 <bSendUART32v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
8111a57c:	e0bffb03 	ldbu	r2,-20(fp)
8111a580:	10c00b24 	muli	r3,r2,44
8111a584:	00a045b4 	movhi	r2,33046
8111a588:	10b0ed04 	addi	r2,r2,-15436
8111a58c:	1885883a 	add	r2,r3,r2
8111a590:	01800804 	movi	r6,32
8111a594:	000b883a 	mov	r5,zero
8111a598:	1009883a 	mov	r4,r2
8111a59c:	11248500 	call	81124850 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
8111a5a0:	e0bffb03 	ldbu	r2,-20(fp)
8111a5a4:	10c00b24 	muli	r3,r2,44
8111a5a8:	00a045b4 	movhi	r2,33046
8111a5ac:	10b0ed04 	addi	r2,r2,-15436
8111a5b0:	1885883a 	add	r2,r3,r2
8111a5b4:	018007c4 	movi	r6,31
8111a5b8:	e17ffe17 	ldw	r5,-8(fp)
8111a5bc:	1009883a 	mov	r4,r2
8111a5c0:	11247000 	call	81124700 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
8111a5c4:	e13ffb03 	ldbu	r4,-20(fp)
8111a5c8:	e0ffff0b 	ldhu	r3,-4(fp)
8111a5cc:	00a045b4 	movhi	r2,33046
8111a5d0:	10b0ed04 	addi	r2,r2,-15436
8111a5d4:	21000b24 	muli	r4,r4,44
8111a5d8:	1105883a 	add	r2,r2,r4
8111a5dc:	10800904 	addi	r2,r2,36
8111a5e0:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
8111a5e4:	e0fffb03 	ldbu	r3,-20(fp)
8111a5e8:	00a045b4 	movhi	r2,33046
8111a5ec:	10b0ed04 	addi	r2,r2,-15436
8111a5f0:	18c00b24 	muli	r3,r3,44
8111a5f4:	10c5883a 	add	r2,r2,r3
8111a5f8:	10800a04 	addi	r2,r2,40
8111a5fc:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
8111a600:	e0fffb03 	ldbu	r3,-20(fp)
8111a604:	00a045b4 	movhi	r2,33046
8111a608:	10b0ed04 	addi	r2,r2,-15436
8111a60c:	18c00b24 	muli	r3,r3,44
8111a610:	10c5883a 	add	r2,r2,r3
8111a614:	10800984 	addi	r2,r2,38
8111a618:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
8111a61c:	e0fffb03 	ldbu	r3,-20(fp)
8111a620:	00a045b4 	movhi	r2,33046
8111a624:	10b0ed04 	addi	r2,r2,-15436
8111a628:	18c00b24 	muli	r3,r3,44
8111a62c:	10c5883a 	add	r2,r2,r3
8111a630:	10800804 	addi	r2,r2,32
8111a634:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
8111a638:	e0fffb03 	ldbu	r3,-20(fp)
8111a63c:	00a045b4 	movhi	r2,33046
8111a640:	10836d04 	addi	r2,r2,3508
8111a644:	18c00384 	addi	r3,r3,14
8111a648:	18c7883a 	add	r3,r3,r3
8111a64c:	18c7883a 	add	r3,r3,r3
8111a650:	10c5883a 	add	r2,r2,r3
8111a654:	00c00044 	movi	r3,1
8111a658:	10c00015 	stw	r3,0(r2)
			break;
8111a65c:	00000606 	br	8111a678 <bSendUART32v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8111a660:	e0bffb03 	ldbu	r2,-20(fp)
8111a664:	10800044 	addi	r2,r2,1
8111a668:	e0bffb05 	stb	r2,-20(fp)
8111a66c:	e0bffb03 	ldbu	r2,-20(fp)
8111a670:	10800230 	cmpltui	r2,r2,8
8111a674:	103fb81e 	bne	r2,zero,8111a558 <__reset+0xfb0fa558>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
8111a678:	e0bffb03 	ldbu	r2,-20(fp)
8111a67c:	10800230 	cmpltui	r2,r2,8
8111a680:	1000091e 	bne	r2,zero,8111a6a8 <bSendUART32v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8111a684:	d0a06f17 	ldw	r2,-32324(gp)
8111a688:	1009883a 	mov	r4,r2
8111a68c:	1140e940 	call	81140e94 <OSSemPost>
8111a690:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
8111a694:	d0a06c17 	ldw	r2,-32336(gp)
8111a698:	1009883a 	mov	r4,r2
8111a69c:	113f0a40 	call	8113f0a4 <OSMutexPost>
		return bSuccessL;
8111a6a0:	e0bffc17 	ldw	r2,-16(fp)
8111a6a4:	00003606 	br	8111a780 <bSendUART32v2+0x314>
	}
	
	bSuccessL = TRUE;
8111a6a8:	00800044 	movi	r2,1
8111a6ac:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
8111a6b0:	d0a06883 	ldbu	r2,-32350(gp)
8111a6b4:	10bfffc4 	addi	r2,r2,-1
8111a6b8:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111a6bc:	d0a07417 	ldw	r2,-32304(gp)
8111a6c0:	e0fffd04 	addi	r3,fp,-12
8111a6c4:	180d883a 	mov	r6,r3
8111a6c8:	01400084 	movi	r5,2
8111a6cc:	1009883a 	mov	r4,r2
8111a6d0:	113eb000 	call	8113eb00 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a6d4:	e0bffd03 	ldbu	r2,-12(fp)
8111a6d8:	10803fcc 	andi	r2,r2,255
8111a6dc:	10001226 	beq	r2,zero,8111a728 <bSendUART32v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a6e0:	00a045f4 	movhi	r2,33047
8111a6e4:	10a34f04 	addi	r2,r2,-29380
8111a6e8:	10800a8b 	ldhu	r2,42(r2)
8111a6ec:	10bfffcc 	andi	r2,r2,65535
8111a6f0:	10800228 	cmpgeui	r2,r2,8
8111a6f4:	1000071e 	bne	r2,zero,8111a714 <bSendUART32v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
8111a6f8:	d0a06217 	ldw	r2,-32376(gp)
8111a6fc:	100f883a 	mov	r7,r2
8111a700:	01801bc4 	movi	r6,111
8111a704:	01400044 	movi	r5,1
8111a708:	01204574 	movhi	r4,33045
8111a70c:	2102ab04 	addi	r4,r4,2732
8111a710:	1123cec0 	call	81123cec <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
8111a714:	d0a06c17 	ldw	r2,-32336(gp)
8111a718:	1009883a 	mov	r4,r2
8111a71c:	113f0a40 	call	8113f0a4 <OSMutexPost>
		return bSuccessL;
8111a720:	e0bffc17 	ldw	r2,-16(fp)
8111a724:	00001606 	br	8111a780 <bSendUART32v2+0x314>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8111a728:	e0bffb03 	ldbu	r2,-20(fp)
8111a72c:	10c00b24 	muli	r3,r2,44
8111a730:	00a045b4 	movhi	r2,33046
8111a734:	10b0ed04 	addi	r2,r2,-15436
8111a738:	1885883a 	add	r2,r3,r2
8111a73c:	1009883a 	mov	r4,r2
8111a740:	1124c200 	call	81124c20 <puts>
	xBuffer32[ucIL].bSent = TRUE;
8111a744:	e0fffb03 	ldbu	r3,-20(fp)
8111a748:	00a045b4 	movhi	r2,33046
8111a74c:	10b0ed04 	addi	r2,r2,-15436
8111a750:	18c00b24 	muli	r3,r3,44
8111a754:	10c5883a 	add	r2,r2,r3
8111a758:	10800804 	addi	r2,r2,32
8111a75c:	00c00044 	movi	r3,1
8111a760:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
8111a764:	d0a07417 	ldw	r2,-32304(gp)
8111a768:	1009883a 	mov	r4,r2
8111a76c:	113f0a40 	call	8113f0a4 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8111a770:	d0a06c17 	ldw	r2,-32336(gp)
8111a774:	1009883a 	mov	r4,r2
8111a778:	113f0a40 	call	8113f0a4 <OSMutexPost>

	return bSuccessL;
8111a77c:	e0bffc17 	ldw	r2,-16(fp)
}
8111a780:	e037883a 	mov	sp,fp
8111a784:	dfc00117 	ldw	ra,4(sp)
8111a788:	df000017 	ldw	fp,0(sp)
8111a78c:	dec00204 	addi	sp,sp,8
8111a790:	f800283a 	ret

8111a794 <vSendEthConf>:


void vSendEthConf ( void ) {
8111a794:	deffc304 	addi	sp,sp,-244
8111a798:	de00012e 	bgeu	sp,et,8111a7a0 <vSendEthConf+0xc>
8111a79c:	003b68fa 	trap	3
8111a7a0:	dfc03c15 	stw	ra,240(sp)
8111a7a4:	df003b15 	stw	fp,236(sp)
8111a7a8:	dd403a15 	stw	r21,232(sp)
8111a7ac:	dd003915 	stw	r20,228(sp)
8111a7b0:	dcc03815 	stw	r19,224(sp)
8111a7b4:	dc803715 	stw	r18,220(sp)
8111a7b8:	dc403615 	stw	r17,216(sp)
8111a7bc:	dc003515 	stw	r16,212(sp)
8111a7c0:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8111a7c4:	e03fd98d 	sth	zero,-154(fp)
8111a7c8:	e03fda0d 	sth	zero,-152(fp)
8111a7cc:	e0bfda84 	addi	r2,fp,-150
8111a7d0:	00c01f04 	movi	r3,124
8111a7d4:	180d883a 	mov	r6,r3
8111a7d8:	000b883a 	mov	r5,zero
8111a7dc:	1009883a 	mov	r4,r2
8111a7e0:	11248500 	call	81124850 <memset>
    unsigned char crc = 0;
8111a7e4:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a7e8:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a7ec:	111ad540 	call	8111ad54 <usiGetIdCMD>
8111a7f0:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a7f4:	e57fd90b 	ldhu	r21,-156(fp)
8111a7f8:	00a045f4 	movhi	r2,33047
8111a7fc:	10a35c04 	addi	r2,r2,-29328
8111a800:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a804:	00a045f4 	movhi	r2,33047
8111a808:	10a35c04 	addi	r2,r2,-29328
8111a80c:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a810:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a814:	00a045f4 	movhi	r2,33047
8111a818:	10a35c04 	addi	r2,r2,-29328
8111a81c:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a820:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a824:	00a045f4 	movhi	r2,33047
8111a828:	10a35c04 	addi	r2,r2,-29328
8111a82c:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a830:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a834:	00a045f4 	movhi	r2,33047
8111a838:	10a35c04 	addi	r2,r2,-29328
8111a83c:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a840:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a844:	00a045f4 	movhi	r2,33047
8111a848:	10a35c04 	addi	r2,r2,-29328
8111a84c:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a850:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a854:	00a045f4 	movhi	r2,33047
8111a858:	10a35c04 	addi	r2,r2,-29328
8111a85c:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a860:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a864:	00a045f4 	movhi	r2,33047
8111a868:	10a35c04 	addi	r2,r2,-29328
8111a86c:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a870:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a874:	00a045f4 	movhi	r2,33047
8111a878:	10a35c04 	addi	r2,r2,-29328
8111a87c:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a880:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a884:	00a045f4 	movhi	r2,33047
8111a888:	10a35c04 	addi	r2,r2,-29328
8111a88c:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a890:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a894:	00a045f4 	movhi	r2,33047
8111a898:	10a35c04 	addi	r2,r2,-29328
8111a89c:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a8a0:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a8a4:	00a045f4 	movhi	r2,33047
8111a8a8:	10a35c04 	addi	r2,r2,-29328
8111a8ac:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a8b0:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a8b4:	00a045f4 	movhi	r2,33047
8111a8b8:	10a35c04 	addi	r2,r2,-29328
8111a8bc:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a8c0:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a8c4:	00a045f4 	movhi	r2,33047
8111a8c8:	10a35c04 	addi	r2,r2,-29328
8111a8cc:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a8d0:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a8d4:	00a045f4 	movhi	r2,33047
8111a8d8:	10a35c04 	addi	r2,r2,-29328
8111a8dc:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a8e0:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a8e4:	00a045f4 	movhi	r2,33047
8111a8e8:	10a35c04 	addi	r2,r2,-29328
8111a8ec:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a8f0:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a8f4:	00a045f4 	movhi	r2,33047
8111a8f8:	10a35c04 	addi	r2,r2,-29328
8111a8fc:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a900:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8111a904:	00a045f4 	movhi	r2,33047
8111a908:	10a35c04 	addi	r2,r2,-29328
8111a90c:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a910:	10bfffcc 	andi	r2,r2,65535
8111a914:	e53fd984 	addi	r20,fp,-154
8111a918:	d8801115 	stw	r2,68(sp)
8111a91c:	dcc01015 	stw	r19,64(sp)
8111a920:	dc800f15 	stw	r18,60(sp)
8111a924:	dc400e15 	stw	r17,56(sp)
8111a928:	dc000d15 	stw	r16,52(sp)
8111a92c:	dbc00c15 	stw	r15,48(sp)
8111a930:	db800b15 	stw	r14,44(sp)
8111a934:	db400a15 	stw	r13,40(sp)
8111a938:	db000915 	stw	r12,36(sp)
8111a93c:	dac00815 	stw	r11,32(sp)
8111a940:	da800715 	stw	r10,28(sp)
8111a944:	da400615 	stw	r9,24(sp)
8111a948:	da000515 	stw	r8,20(sp)
8111a94c:	d9c00415 	stw	r7,16(sp)
8111a950:	d9800315 	stw	r6,12(sp)
8111a954:	d9400215 	stw	r5,8(sp)
8111a958:	d9000115 	stw	r4,4(sp)
8111a95c:	d8c00015 	stw	r3,0(sp)
8111a960:	a80f883a 	mov	r7,r21
8111a964:	018010c4 	movi	r6,67
8111a968:	01604574 	movhi	r5,33045
8111a96c:	2942c704 	addi	r5,r5,2844
8111a970:	a009883a 	mov	r4,r20
8111a974:	1124f640 	call	81124f64 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8111a978:	e0bfd984 	addi	r2,fp,-154
8111a97c:	1009883a 	mov	r4,r2
8111a980:	11251780 	call	81125178 <strlen>
8111a984:	1007883a 	mov	r3,r2
8111a988:	e0bfd984 	addi	r2,fp,-154
8111a98c:	180b883a 	mov	r5,r3
8111a990:	1009883a 	mov	r4,r2
8111a994:	111d0240 	call	8111d024 <ucCrc8wInit>
8111a998:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
8111a99c:	e13fd703 	ldbu	r4,-164(fp)
8111a9a0:	e0ffd984 	addi	r3,fp,-154
8111a9a4:	e0bfd984 	addi	r2,fp,-154
8111a9a8:	200f883a 	mov	r7,r4
8111a9ac:	180d883a 	mov	r6,r3
8111a9b0:	01604574 	movhi	r5,33045
8111a9b4:	2942df04 	addi	r5,r5,2940
8111a9b8:	1009883a 	mov	r4,r2
8111a9bc:	1124f640 	call	81124f64 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
8111a9c0:	e0bfd90b 	ldhu	r2,-156(fp)
8111a9c4:	10ffffcc 	andi	r3,r2,65535
8111a9c8:	18e0001c 	xori	r3,r3,32768
8111a9cc:	18e00004 	addi	r3,r3,-32768
8111a9d0:	e0bfd984 	addi	r2,fp,-154
8111a9d4:	180b883a 	mov	r5,r3
8111a9d8:	1009883a 	mov	r4,r2
8111a9dc:	1119e240 	call	81119e24 <bSendUART128v2>
8111a9e0:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8111a9e4:	e0bfd817 	ldw	r2,-160(fp)
8111a9e8:	10800060 	cmpeqi	r2,r2,1
8111a9ec:	1000011e 	bne	r2,zero,8111a9f4 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
8111a9f0:	111de940 	call	8111de94 <vCouldNotSendEthConfUART>
	}
}
8111a9f4:	0001883a 	nop
8111a9f8:	e6fffa04 	addi	sp,fp,-24
8111a9fc:	dfc00717 	ldw	ra,28(sp)
8111aa00:	df000617 	ldw	fp,24(sp)
8111aa04:	dd400517 	ldw	r21,20(sp)
8111aa08:	dd000417 	ldw	r20,16(sp)
8111aa0c:	dcc00317 	ldw	r19,12(sp)
8111aa10:	dc800217 	ldw	r18,8(sp)
8111aa14:	dc400117 	ldw	r17,4(sp)
8111aa18:	dc000017 	ldw	r16,0(sp)
8111aa1c:	dec00804 	addi	sp,sp,32
8111aa20:	f800283a 	ret

8111aa24 <vSendTurnOff>:


void vSendTurnOff ( void ) {
8111aa24:	defff304 	addi	sp,sp,-52
8111aa28:	de00012e 	bgeu	sp,et,8111aa30 <vSendTurnOff+0xc>
8111aa2c:	003b68fa 	trap	3
8111aa30:	dfc00c15 	stw	ra,48(sp)
8111aa34:	df000b15 	stw	fp,44(sp)
8111aa38:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8111aa3c:	e03ff78d 	sth	zero,-34(fp)
8111aa40:	e03ff80d 	sth	zero,-32(fp)
8111aa44:	e03ff88d 	sth	zero,-30(fp)
8111aa48:	e03ff90d 	sth	zero,-28(fp)
8111aa4c:	e03ff98d 	sth	zero,-26(fp)
8111aa50:	e03ffa0d 	sth	zero,-24(fp)
8111aa54:	e03ffa8d 	sth	zero,-22(fp)
8111aa58:	e03ffb0d 	sth	zero,-20(fp)
8111aa5c:	e03ffb8d 	sth	zero,-18(fp)
8111aa60:	e03ffc0d 	sth	zero,-16(fp)
8111aa64:	e03ffc8d 	sth	zero,-14(fp)
8111aa68:	e03ffd0d 	sth	zero,-12(fp)
8111aa6c:	e03ffd8d 	sth	zero,-10(fp)
8111aa70:	e03ffe0d 	sth	zero,-8(fp)
8111aa74:	e03ffe8d 	sth	zero,-6(fp)
8111aa78:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111aa7c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111aa80:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111aa84:	111ad540 	call	8111ad54 <usiGetIdCMD>
8111aa88:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
8111aa8c:	e0fff70b 	ldhu	r3,-36(fp)
8111aa90:	e0bff784 	addi	r2,fp,-34
8111aa94:	180d883a 	mov	r6,r3
8111aa98:	01604574 	movhi	r5,33045
8111aa9c:	2942e204 	addi	r5,r5,2952
8111aaa0:	1009883a 	mov	r4,r2
8111aaa4:	1124f640 	call	81124f64 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111aaa8:	e0bff784 	addi	r2,fp,-34
8111aaac:	1009883a 	mov	r4,r2
8111aab0:	11251780 	call	81125178 <strlen>
8111aab4:	1007883a 	mov	r3,r2
8111aab8:	e0bff784 	addi	r2,fp,-34
8111aabc:	180b883a 	mov	r5,r3
8111aac0:	1009883a 	mov	r4,r2
8111aac4:	111d0240 	call	8111d024 <ucCrc8wInit>
8111aac8:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111aacc:	e13ff503 	ldbu	r4,-44(fp)
8111aad0:	e0fff784 	addi	r3,fp,-34
8111aad4:	e0bff784 	addi	r2,fp,-34
8111aad8:	200f883a 	mov	r7,r4
8111aadc:	180d883a 	mov	r6,r3
8111aae0:	01604574 	movhi	r5,33045
8111aae4:	2942df04 	addi	r5,r5,2940
8111aae8:	1009883a 	mov	r4,r2
8111aaec:	1124f640 	call	81124f64 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111aaf0:	e0bff70b 	ldhu	r2,-36(fp)
8111aaf4:	10ffffcc 	andi	r3,r2,65535
8111aaf8:	18e0001c 	xori	r3,r3,32768
8111aafc:	18e00004 	addi	r3,r3,-32768
8111ab00:	e0bff784 	addi	r2,fp,-34
8111ab04:	180b883a 	mov	r5,r3
8111ab08:	1009883a 	mov	r4,r2
8111ab0c:	111a46c0 	call	8111a46c <bSendUART32v2>
8111ab10:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111ab14:	e0bff617 	ldw	r2,-40(fp)
8111ab18:	10800060 	cmpeqi	r2,r2,1
8111ab1c:	1000011e 	bne	r2,zero,8111ab24 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111ab20:	111e6ec0 	call	8111e6ec <vCouldNotSendTurnOff>
	}
}
8111ab24:	0001883a 	nop
8111ab28:	e037883a 	mov	sp,fp
8111ab2c:	dfc00117 	ldw	ra,4(sp)
8111ab30:	df000017 	ldw	fp,0(sp)
8111ab34:	dec00204 	addi	sp,sp,8
8111ab38:	f800283a 	ret

8111ab3c <vSendReset>:

void vSendReset ( void ) {
8111ab3c:	defff304 	addi	sp,sp,-52
8111ab40:	de00012e 	bgeu	sp,et,8111ab48 <vSendReset+0xc>
8111ab44:	003b68fa 	trap	3
8111ab48:	dfc00c15 	stw	ra,48(sp)
8111ab4c:	df000b15 	stw	fp,44(sp)
8111ab50:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8111ab54:	e03ff78d 	sth	zero,-34(fp)
8111ab58:	e03ff80d 	sth	zero,-32(fp)
8111ab5c:	e03ff88d 	sth	zero,-30(fp)
8111ab60:	e03ff90d 	sth	zero,-28(fp)
8111ab64:	e03ff98d 	sth	zero,-26(fp)
8111ab68:	e03ffa0d 	sth	zero,-24(fp)
8111ab6c:	e03ffa8d 	sth	zero,-22(fp)
8111ab70:	e03ffb0d 	sth	zero,-20(fp)
8111ab74:	e03ffb8d 	sth	zero,-18(fp)
8111ab78:	e03ffc0d 	sth	zero,-16(fp)
8111ab7c:	e03ffc8d 	sth	zero,-14(fp)
8111ab80:	e03ffd0d 	sth	zero,-12(fp)
8111ab84:	e03ffd8d 	sth	zero,-10(fp)
8111ab88:	e03ffe0d 	sth	zero,-8(fp)
8111ab8c:	e03ffe8d 	sth	zero,-6(fp)
8111ab90:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111ab94:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111ab98:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111ab9c:	111ad540 	call	8111ad54 <usiGetIdCMD>
8111aba0:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8111aba4:	e0fff70b 	ldhu	r3,-36(fp)
8111aba8:	e0bff784 	addi	r2,fp,-34
8111abac:	180d883a 	mov	r6,r3
8111abb0:	01604574 	movhi	r5,33045
8111abb4:	2942e404 	addi	r5,r5,2960
8111abb8:	1009883a 	mov	r4,r2
8111abbc:	1124f640 	call	81124f64 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111abc0:	e0bff784 	addi	r2,fp,-34
8111abc4:	1009883a 	mov	r4,r2
8111abc8:	11251780 	call	81125178 <strlen>
8111abcc:	1007883a 	mov	r3,r2
8111abd0:	e0bff784 	addi	r2,fp,-34
8111abd4:	180b883a 	mov	r5,r3
8111abd8:	1009883a 	mov	r4,r2
8111abdc:	111d0240 	call	8111d024 <ucCrc8wInit>
8111abe0:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111abe4:	e13ff503 	ldbu	r4,-44(fp)
8111abe8:	e0fff784 	addi	r3,fp,-34
8111abec:	e0bff784 	addi	r2,fp,-34
8111abf0:	200f883a 	mov	r7,r4
8111abf4:	180d883a 	mov	r6,r3
8111abf8:	01604574 	movhi	r5,33045
8111abfc:	2942df04 	addi	r5,r5,2940
8111ac00:	1009883a 	mov	r4,r2
8111ac04:	1124f640 	call	81124f64 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111ac08:	e0bff70b 	ldhu	r2,-36(fp)
8111ac0c:	10ffffcc 	andi	r3,r2,65535
8111ac10:	18e0001c 	xori	r3,r3,32768
8111ac14:	18e00004 	addi	r3,r3,-32768
8111ac18:	e0bff784 	addi	r2,fp,-34
8111ac1c:	180b883a 	mov	r5,r3
8111ac20:	1009883a 	mov	r4,r2
8111ac24:	111a46c0 	call	8111a46c <bSendUART32v2>
8111ac28:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111ac2c:	e0bff617 	ldw	r2,-40(fp)
8111ac30:	10800060 	cmpeqi	r2,r2,1
8111ac34:	1000011e 	bne	r2,zero,8111ac3c <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111ac38:	111e6ec0 	call	8111e6ec <vCouldNotSendTurnOff>
	}
}
8111ac3c:	0001883a 	nop
8111ac40:	e037883a 	mov	sp,fp
8111ac44:	dfc00117 	ldw	ra,4(sp)
8111ac48:	df000017 	ldw	fp,0(sp)
8111ac4c:	dec00204 	addi	sp,sp,8
8111ac50:	f800283a 	ret

8111ac54 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8111ac54:	deffda04 	addi	sp,sp,-152
8111ac58:	de00012e 	bgeu	sp,et,8111ac60 <vSendLog+0xc>
8111ac5c:	003b68fa 	trap	3
8111ac60:	dfc02515 	stw	ra,148(sp)
8111ac64:	df002415 	stw	fp,144(sp)
8111ac68:	df002404 	addi	fp,sp,144
8111ac6c:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8111ac70:	e03fde8d 	sth	zero,-134(fp)
8111ac74:	e03fdf0d 	sth	zero,-132(fp)
8111ac78:	e0bfdf84 	addi	r2,fp,-130
8111ac7c:	00c01f04 	movi	r3,124
8111ac80:	180d883a 	mov	r6,r3
8111ac84:	000b883a 	mov	r5,zero
8111ac88:	1009883a 	mov	r4,r2
8111ac8c:	11248500 	call	81124850 <memset>
    unsigned char crc = 0;
8111ac90:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111ac94:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111ac98:	111ad540 	call	8111ad54 <usiGetIdCMD>
8111ac9c:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8111aca0:	e0ffde0b 	ldhu	r3,-136(fp)
8111aca4:	e0bfde84 	addi	r2,fp,-134
8111aca8:	e1ffff17 	ldw	r7,-4(fp)
8111acac:	180d883a 	mov	r6,r3
8111acb0:	01604574 	movhi	r5,33045
8111acb4:	2942e604 	addi	r5,r5,2968
8111acb8:	1009883a 	mov	r4,r2
8111acbc:	1124f640 	call	81124f64 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8111acc0:	e0bfde84 	addi	r2,fp,-134
8111acc4:	1009883a 	mov	r4,r2
8111acc8:	11251780 	call	81125178 <strlen>
8111accc:	1007883a 	mov	r3,r2
8111acd0:	e0bfde84 	addi	r2,fp,-134
8111acd4:	180b883a 	mov	r5,r3
8111acd8:	1009883a 	mov	r4,r2
8111acdc:	111d0240 	call	8111d024 <ucCrc8wInit>
8111ace0:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8111ace4:	e13fdc03 	ldbu	r4,-144(fp)
8111ace8:	e0ffde84 	addi	r3,fp,-134
8111acec:	e0bfde84 	addi	r2,fp,-134
8111acf0:	200f883a 	mov	r7,r4
8111acf4:	180d883a 	mov	r6,r3
8111acf8:	01604574 	movhi	r5,33045
8111acfc:	2942df04 	addi	r5,r5,2940
8111ad00:	1009883a 	mov	r4,r2
8111ad04:	1124f640 	call	81124f64 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111ad08:	e0bfde0b 	ldhu	r2,-136(fp)
8111ad0c:	10ffffcc 	andi	r3,r2,65535
8111ad10:	18e0001c 	xori	r3,r3,32768
8111ad14:	18e00004 	addi	r3,r3,-32768
8111ad18:	e0bfde84 	addi	r2,fp,-134
8111ad1c:	180b883a 	mov	r5,r3
8111ad20:	1009883a 	mov	r4,r2
8111ad24:	1119e240 	call	81119e24 <bSendUART128v2>
8111ad28:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8111ad2c:	e0bfdd17 	ldw	r2,-140(fp)
8111ad30:	10800060 	cmpeqi	r2,r2,1
8111ad34:	1000011e 	bne	r2,zero,8111ad3c <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111ad38:	111e7ec0 	call	8111e7ec <vCouldNotSendLog>
	}
}
8111ad3c:	0001883a 	nop
8111ad40:	e037883a 	mov	sp,fp
8111ad44:	dfc00117 	ldw	ra,4(sp)
8111ad48:	df000017 	ldw	fp,0(sp)
8111ad4c:	dec00204 	addi	sp,sp,8
8111ad50:	f800283a 	ret

8111ad54 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8111ad54:	deffff04 	addi	sp,sp,-4
8111ad58:	de00012e 	bgeu	sp,et,8111ad60 <usiGetIdCMD+0xc>
8111ad5c:	003b68fa 	trap	3
8111ad60:	df000015 	stw	fp,0(sp)
8111ad64:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8111ad68:	d0a0680b 	ldhu	r2,-32352(gp)
8111ad6c:	10ffffcc 	andi	r3,r2,65535
8111ad70:	00bfffd4 	movui	r2,65535
8111ad74:	1880031e 	bne	r3,r2,8111ad84 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111ad78:	00800084 	movi	r2,2
8111ad7c:	d0a0680d 	sth	r2,-32352(gp)
8111ad80:	00000306 	br	8111ad90 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8111ad84:	d0a0680b 	ldhu	r2,-32352(gp)
8111ad88:	10800044 	addi	r2,r2,1
8111ad8c:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
8111ad90:	d0a0680b 	ldhu	r2,-32352(gp)
}
8111ad94:	e037883a 	mov	sp,fp
8111ad98:	df000017 	ldw	fp,0(sp)
8111ad9c:	dec00104 	addi	sp,sp,4
8111ada0:	f800283a 	ret

8111ada4 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8111ada4:	defffb04 	addi	sp,sp,-20
8111ada8:	de00012e 	bgeu	sp,et,8111adb0 <siPosStr+0xc>
8111adac:	003b68fa 	trap	3
8111adb0:	dfc00415 	stw	ra,16(sp)
8111adb4:	df000315 	stw	fp,12(sp)
8111adb8:	df000304 	addi	fp,sp,12
8111adbc:	e13ffe15 	stw	r4,-8(fp)
8111adc0:	2805883a 	mov	r2,r5
8111adc4:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8111adc8:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8111adcc:	e0bfff03 	ldbu	r2,-4(fp)
8111add0:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8111add4:	e17ffd04 	addi	r5,fp,-12
8111add8:	e13ffe17 	ldw	r4,-8(fp)
8111addc:	112512c0 	call	8112512c <strcspn>
}
8111ade0:	e037883a 	mov	sp,fp
8111ade4:	dfc00117 	ldw	ra,4(sp)
8111ade8:	df000017 	ldw	fp,0(sp)
8111adec:	dec00204 	addi	sp,sp,8
8111adf0:	f800283a 	ret

8111adf4 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8111adf4:	defffc04 	addi	sp,sp,-16
8111adf8:	de00012e 	bgeu	sp,et,8111ae00 <vTimeoutCheck+0xc>
8111adfc:	003b68fa 	trap	3
8111ae00:	dfc00315 	stw	ra,12(sp)
8111ae04:	df000215 	stw	fp,8(sp)
8111ae08:	df000204 	addi	fp,sp,8
8111ae0c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8111ae10:	d0a06717 	ldw	r2,-32356(gp)
8111ae14:	1009883a 	mov	r4,r2
8111ae18:	1140e940 	call	81140e94 <OSSemPost>
8111ae1c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111ae20:	e0bffe03 	ldbu	r2,-8(fp)
8111ae24:	10000126 	beq	r2,zero,8111ae2c <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8111ae28:	111e3ec0 	call	8111e3ec <vFailPostBlockingSemTimeoutTask>
	}
}
8111ae2c:	0001883a 	nop
8111ae30:	e037883a 	mov	sp,fp
8111ae34:	dfc00117 	ldw	ra,4(sp)
8111ae38:	df000017 	ldw	fp,0(sp)
8111ae3c:	dec00204 	addi	sp,sp,8
8111ae40:	f800283a 	ret

8111ae44 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8111ae44:	deffe304 	addi	sp,sp,-116
8111ae48:	de00012e 	bgeu	sp,et,8111ae50 <vSendPusTM64+0xc>
8111ae4c:	003b68fa 	trap	3
8111ae50:	dfc01815 	stw	ra,96(sp)
8111ae54:	df001715 	stw	fp,92(sp)
8111ae58:	df001704 	addi	fp,sp,92
8111ae5c:	e1000215 	stw	r4,8(fp)
8111ae60:	e1400315 	stw	r5,12(fp)
8111ae64:	e1800415 	stw	r6,16(fp)
8111ae68:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8111ae6c:	e03fef8d 	sth	zero,-66(fp)
8111ae70:	e03ff00d 	sth	zero,-64(fp)
8111ae74:	e0bff084 	addi	r2,fp,-62
8111ae78:	00c00f04 	movi	r3,60
8111ae7c:	180d883a 	mov	r6,r3
8111ae80:	000b883a 	mov	r5,zero
8111ae84:	1009883a 	mov	r4,r2
8111ae88:	11248500 	call	81124850 <memset>
    unsigned char crc = 0;
8111ae8c:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111ae90:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111ae94:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111ae98:	111ad540 	call	8111ad54 <usiGetIdCMD>
8111ae9c:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111aea0:	e1bfef0b 	ldhu	r6,-68(fp)
8111aea4:	e080040b 	ldhu	r2,16(fp)
8111aea8:	11ffffcc 	andi	r7,r2,65535
8111aeac:	e080048b 	ldhu	r2,18(fp)
8111aeb0:	10bfffcc 	andi	r2,r2,65535
8111aeb4:	e0c0050b 	ldhu	r3,20(fp)
8111aeb8:	18ffffcc 	andi	r3,r3,65535
8111aebc:	e100058b 	ldhu	r4,22(fp)
8111aec0:	213fffcc 	andi	r4,r4,65535
8111aec4:	e140060b 	ldhu	r5,24(fp)
8111aec8:	297fffcc 	andi	r5,r5,65535
8111aecc:	e23fef84 	addi	r8,fp,-66
8111aed0:	d9400315 	stw	r5,12(sp)
8111aed4:	d9000215 	stw	r4,8(sp)
8111aed8:	d8c00115 	stw	r3,4(sp)
8111aedc:	d8800015 	stw	r2,0(sp)
8111aee0:	01604574 	movhi	r5,33045
8111aee4:	2942e904 	addi	r5,r5,2980
8111aee8:	4009883a 	mov	r4,r8
8111aeec:	1124f640 	call	81124f64 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111aef0:	e03fed05 	stb	zero,-76(fp)
8111aef4:	00001206 	br	8111af40 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111aef8:	e0bfed03 	ldbu	r2,-76(fp)
8111aefc:	10800284 	addi	r2,r2,10
8111af00:	1085883a 	add	r2,r2,r2
8111af04:	e0c00204 	addi	r3,fp,8
8111af08:	1885883a 	add	r2,r3,r2
8111af0c:	1080000b 	ldhu	r2,0(r2)
8111af10:	113fffcc 	andi	r4,r2,65535
8111af14:	e0ffef84 	addi	r3,fp,-66
8111af18:	e0bfef84 	addi	r2,fp,-66
8111af1c:	200f883a 	mov	r7,r4
8111af20:	180d883a 	mov	r6,r3
8111af24:	01604574 	movhi	r5,33045
8111af28:	2942f004 	addi	r5,r5,3008
8111af2c:	1009883a 	mov	r4,r2
8111af30:	1124f640 	call	81124f64 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111af34:	e0bfed03 	ldbu	r2,-76(fp)
8111af38:	10800044 	addi	r2,r2,1
8111af3c:	e0bfed05 	stb	r2,-76(fp)
8111af40:	e0800683 	ldbu	r2,26(fp)
8111af44:	10803fcc 	andi	r2,r2,255
8111af48:	e0ffed03 	ldbu	r3,-76(fp)
8111af4c:	18bfea36 	bltu	r3,r2,8111aef8 <__reset+0xfb0faef8>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111af50:	e0bfef84 	addi	r2,fp,-66
8111af54:	1009883a 	mov	r4,r2
8111af58:	11251780 	call	81125178 <strlen>
8111af5c:	1007883a 	mov	r3,r2
8111af60:	e0bfef84 	addi	r2,fp,-66
8111af64:	180b883a 	mov	r5,r3
8111af68:	1009883a 	mov	r4,r2
8111af6c:	111d0240 	call	8111d024 <ucCrc8wInit>
8111af70:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111af74:	e13fed43 	ldbu	r4,-75(fp)
8111af78:	e0ffef84 	addi	r3,fp,-66
8111af7c:	e0bfef84 	addi	r2,fp,-66
8111af80:	200f883a 	mov	r7,r4
8111af84:	180d883a 	mov	r6,r3
8111af88:	01604574 	movhi	r5,33045
8111af8c:	2942df04 	addi	r5,r5,2940
8111af90:	1009883a 	mov	r4,r2
8111af94:	1124f640 	call	81124f64 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8111af98:	e0bfef0b 	ldhu	r2,-68(fp)
8111af9c:	10ffffcc 	andi	r3,r2,65535
8111afa0:	18e0001c 	xori	r3,r3,32768
8111afa4:	18e00004 	addi	r3,r3,-32768
8111afa8:	e0bfef84 	addi	r2,fp,-66
8111afac:	180b883a 	mov	r5,r3
8111afb0:	1009883a 	mov	r4,r2
8111afb4:	111a1440 	call	8111a144 <bSendUART64v2>
8111afb8:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8111afbc:	e0bfee17 	ldw	r2,-72(fp)
8111afc0:	10800060 	cmpeqi	r2,r2,1
8111afc4:	1000031e 	bne	r2,zero,8111afd4 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111afc8:	e0bfef84 	addi	r2,fp,-66
8111afcc:	1009883a 	mov	r4,r2
8111afd0:	111e86c0 	call	8111e86c <vCouldNotSendTMPusCommand>
	}
}
8111afd4:	0001883a 	nop
8111afd8:	e037883a 	mov	sp,fp
8111afdc:	dfc00117 	ldw	ra,4(sp)
8111afe0:	df000017 	ldw	fp,0(sp)
8111afe4:	dec00604 	addi	sp,sp,24
8111afe8:	f800283a 	ret

8111afec <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8111afec:	deffd304 	addi	sp,sp,-180
8111aff0:	de00012e 	bgeu	sp,et,8111aff8 <vSendPusTM128+0xc>
8111aff4:	003b68fa 	trap	3
8111aff8:	dfc02815 	stw	ra,160(sp)
8111affc:	df002715 	stw	fp,156(sp)
8111b000:	df002704 	addi	fp,sp,156
8111b004:	e1000215 	stw	r4,8(fp)
8111b008:	e1400315 	stw	r5,12(fp)
8111b00c:	e1800415 	stw	r6,16(fp)
8111b010:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8111b014:	e03fdf8d 	sth	zero,-130(fp)
8111b018:	e03fe00d 	sth	zero,-128(fp)
8111b01c:	e0bfe084 	addi	r2,fp,-126
8111b020:	00c01f04 	movi	r3,124
8111b024:	180d883a 	mov	r6,r3
8111b028:	000b883a 	mov	r5,zero
8111b02c:	1009883a 	mov	r4,r2
8111b030:	11248500 	call	81124850 <memset>
    unsigned char crc = 0;
8111b034:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8111b038:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8111b03c:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111b040:	111ad540 	call	8111ad54 <usiGetIdCMD>
8111b044:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111b048:	e1bfdf0b 	ldhu	r6,-132(fp)
8111b04c:	e080040b 	ldhu	r2,16(fp)
8111b050:	11ffffcc 	andi	r7,r2,65535
8111b054:	e080048b 	ldhu	r2,18(fp)
8111b058:	10bfffcc 	andi	r2,r2,65535
8111b05c:	e0c0050b 	ldhu	r3,20(fp)
8111b060:	18ffffcc 	andi	r3,r3,65535
8111b064:	e100058b 	ldhu	r4,22(fp)
8111b068:	213fffcc 	andi	r4,r4,65535
8111b06c:	e140060b 	ldhu	r5,24(fp)
8111b070:	297fffcc 	andi	r5,r5,65535
8111b074:	e23fdf84 	addi	r8,fp,-130
8111b078:	d9400315 	stw	r5,12(sp)
8111b07c:	d9000215 	stw	r4,8(sp)
8111b080:	d8c00115 	stw	r3,4(sp)
8111b084:	d8800015 	stw	r2,0(sp)
8111b088:	01604574 	movhi	r5,33045
8111b08c:	2942e904 	addi	r5,r5,2980
8111b090:	4009883a 	mov	r4,r8
8111b094:	1124f640 	call	81124f64 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111b098:	e03fdd05 	stb	zero,-140(fp)
8111b09c:	00001206 	br	8111b0e8 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111b0a0:	e0bfdd03 	ldbu	r2,-140(fp)
8111b0a4:	10800284 	addi	r2,r2,10
8111b0a8:	1085883a 	add	r2,r2,r2
8111b0ac:	e0c00204 	addi	r3,fp,8
8111b0b0:	1885883a 	add	r2,r3,r2
8111b0b4:	1080000b 	ldhu	r2,0(r2)
8111b0b8:	113fffcc 	andi	r4,r2,65535
8111b0bc:	e0ffdf84 	addi	r3,fp,-130
8111b0c0:	e0bfdf84 	addi	r2,fp,-130
8111b0c4:	200f883a 	mov	r7,r4
8111b0c8:	180d883a 	mov	r6,r3
8111b0cc:	01604574 	movhi	r5,33045
8111b0d0:	2942f004 	addi	r5,r5,3008
8111b0d4:	1009883a 	mov	r4,r2
8111b0d8:	1124f640 	call	81124f64 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111b0dc:	e0bfdd03 	ldbu	r2,-140(fp)
8111b0e0:	10800044 	addi	r2,r2,1
8111b0e4:	e0bfdd05 	stb	r2,-140(fp)
8111b0e8:	e0800683 	ldbu	r2,26(fp)
8111b0ec:	10803fcc 	andi	r2,r2,255
8111b0f0:	e0ffdd03 	ldbu	r3,-140(fp)
8111b0f4:	18bfea36 	bltu	r3,r2,8111b0a0 <__reset+0xfb0fb0a0>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111b0f8:	e0bfdf84 	addi	r2,fp,-130
8111b0fc:	1009883a 	mov	r4,r2
8111b100:	11251780 	call	81125178 <strlen>
8111b104:	1007883a 	mov	r3,r2
8111b108:	e0bfdf84 	addi	r2,fp,-130
8111b10c:	180b883a 	mov	r5,r3
8111b110:	1009883a 	mov	r4,r2
8111b114:	111d0240 	call	8111d024 <ucCrc8wInit>
8111b118:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111b11c:	e13fdd43 	ldbu	r4,-139(fp)
8111b120:	e0ffdf84 	addi	r3,fp,-130
8111b124:	e0bfdf84 	addi	r2,fp,-130
8111b128:	200f883a 	mov	r7,r4
8111b12c:	180d883a 	mov	r6,r3
8111b130:	01604574 	movhi	r5,33045
8111b134:	2942df04 	addi	r5,r5,2940
8111b138:	1009883a 	mov	r4,r2
8111b13c:	1124f640 	call	81124f64 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111b140:	e0bfdf0b 	ldhu	r2,-132(fp)
8111b144:	10ffffcc 	andi	r3,r2,65535
8111b148:	18e0001c 	xori	r3,r3,32768
8111b14c:	18e00004 	addi	r3,r3,-32768
8111b150:	e0bfdf84 	addi	r2,fp,-130
8111b154:	180b883a 	mov	r5,r3
8111b158:	1009883a 	mov	r4,r2
8111b15c:	1119e240 	call	81119e24 <bSendUART128v2>
8111b160:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8111b164:	e0bfde17 	ldw	r2,-136(fp)
8111b168:	10800060 	cmpeqi	r2,r2,1
8111b16c:	1000031e 	bne	r2,zero,8111b17c <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111b170:	e0bfdf84 	addi	r2,fp,-130
8111b174:	1009883a 	mov	r4,r2
8111b178:	111e86c0 	call	8111e86c <vCouldNotSendTMPusCommand>
	}
}
8111b17c:	0001883a 	nop
8111b180:	e037883a 	mov	sp,fp
8111b184:	dfc00117 	ldw	ra,4(sp)
8111b188:	df000017 	ldw	fp,0(sp)
8111b18c:	dec00604 	addi	sp,sp,24
8111b190:	f800283a 	ret

8111b194 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8111b194:	deffd704 	addi	sp,sp,-164
8111b198:	de00012e 	bgeu	sp,et,8111b1a0 <vTMPusTestConnection+0xc>
8111b19c:	003b68fa 	trap	3
8111b1a0:	dfc02815 	stw	ra,160(sp)
8111b1a4:	df002715 	stw	fp,156(sp)
8111b1a8:	df002704 	addi	fp,sp,156
8111b1ac:	2005883a 	mov	r2,r4
8111b1b0:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8111b1b4:	e0bfff0b 	ldhu	r2,-4(fp)
8111b1b8:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
8111b1bc:	00801c04 	movi	r2,112
8111b1c0:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8111b1c4:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8111b1c8:	00800444 	movi	r2,17
8111b1cc:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
8111b1d0:	00800084 	movi	r2,2
8111b1d4:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8111b1d8:	d809883a 	mov	r4,sp
8111b1dc:	e0bfee04 	addi	r2,fp,-72
8111b1e0:	00c01104 	movi	r3,68
8111b1e4:	180d883a 	mov	r6,r3
8111b1e8:	100b883a 	mov	r5,r2
8111b1ec:	11247000 	call	81124700 <memcpy>
8111b1f0:	e13fea17 	ldw	r4,-88(fp)
8111b1f4:	e17feb17 	ldw	r5,-84(fp)
8111b1f8:	e1bfec17 	ldw	r6,-80(fp)
8111b1fc:	e1ffed17 	ldw	r7,-76(fp)
8111b200:	111ae440 	call	8111ae44 <vSendPusTM64>
}
8111b204:	0001883a 	nop
8111b208:	e037883a 	mov	sp,fp
8111b20c:	dfc00117 	ldw	ra,4(sp)
8111b210:	df000017 	ldw	fp,0(sp)
8111b214:	dec00204 	addi	sp,sp,8
8111b218:	f800283a 	ret

8111b21c <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
8111b21c:	defff504 	addi	sp,sp,-44
8111b220:	de00012e 	bgeu	sp,et,8111b228 <vLoadDefaultETHConf+0xc>
8111b224:	003b68fa 	trap	3
8111b228:	dfc00a15 	stw	ra,40(sp)
8111b22c:	df000915 	stw	fp,36(sp)
8111b230:	dc000815 	stw	r16,32(sp)
8111b234:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111b238:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8111b23c:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111b240:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111b244:	d0a07617 	ldw	r2,-32296(gp)
8111b248:	10800058 	cmpnei	r2,r2,1
8111b24c:	10021f1e 	bne	r2,zero,8111bacc <vLoadDefaultETHConf+0x8b0>
8111b250:	1120b100 	call	81120b10 <bSDcardIsPresent>
8111b254:	10021d26 	beq	r2,zero,8111bacc <vLoadDefaultETHConf+0x8b0>
8111b258:	1120b400 	call	81120b40 <bSDcardFAT16Check>
8111b25c:	10021b26 	beq	r2,zero,8111bacc <vLoadDefaultETHConf+0x8b0>

		siFile = siOpenFile( ETH_FILE_NAME );
8111b260:	01204574 	movhi	r4,33045
8111b264:	2102f204 	addi	r4,r4,3016
8111b268:	1120c680 	call	81120c68 <siOpenFile>
8111b26c:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111b270:	e0bffc0f 	ldh	r2,-16(fp)
8111b274:	10020716 	blt	r2,zero,8111ba94 <vLoadDefaultETHConf+0x878>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111b278:	e0bffd04 	addi	r2,fp,-12
8111b27c:	01800204 	movi	r6,8
8111b280:	01400284 	movi	r5,10
8111b284:	1009883a 	mov	r4,r2
8111b288:	11248500 	call	81124850 <memset>
			p_inteiro = inteiro;
8111b28c:	e0bffd04 	addi	r2,fp,-12
8111b290:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8111b294:	e0bffc0f 	ldh	r2,-16(fp)
8111b298:	1009883a 	mov	r4,r2
8111b29c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b2a0:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8111b2a4:	e0bff947 	ldb	r2,-27(fp)
8111b2a8:	10800084 	addi	r2,r2,2
8111b2ac:	10c015a8 	cmpgeui	r3,r2,86
8111b2b0:	1801e41e 	bne	r3,zero,8111ba44 <vLoadDefaultETHConf+0x828>
8111b2b4:	100690ba 	slli	r3,r2,2
8111b2b8:	00a044b4 	movhi	r2,33042
8111b2bc:	10acb304 	addi	r2,r2,-19764
8111b2c0:	1885883a 	add	r2,r3,r2
8111b2c4:	10800017 	ldw	r2,0(r2)
8111b2c8:	1000683a 	jmp	r2
8111b2cc:	8111b464 	muli	r4,r16,18129
8111b2d0:	8111b458 	cmpnei	r4,r16,18129
8111b2d4:	8111ba44 	addi	r4,r16,18153
8111b2d8:	8111ba44 	addi	r4,r16,18153
8111b2dc:	8111ba44 	addi	r4,r16,18153
8111b2e0:	8111ba44 	addi	r4,r16,18153
8111b2e4:	8111ba44 	addi	r4,r16,18153
8111b2e8:	8111ba44 	addi	r4,r16,18153
8111b2ec:	8111ba44 	addi	r4,r16,18153
8111b2f0:	8111ba44 	addi	r4,r16,18153
8111b2f4:	8111ba44 	addi	r4,r16,18153
8111b2f8:	8111ba44 	addi	r4,r16,18153
8111b2fc:	8111ba7c 	xorhi	r4,r16,18153
8111b300:	8111ba44 	addi	r4,r16,18153
8111b304:	8111ba44 	addi	r4,r16,18153
8111b308:	8111ba7c 	xorhi	r4,r16,18153
8111b30c:	8111ba44 	addi	r4,r16,18153
8111b310:	8111ba44 	addi	r4,r16,18153
8111b314:	8111ba44 	addi	r4,r16,18153
8111b318:	8111ba44 	addi	r4,r16,18153
8111b31c:	8111ba44 	addi	r4,r16,18153
8111b320:	8111ba44 	addi	r4,r16,18153
8111b324:	8111ba44 	addi	r4,r16,18153
8111b328:	8111ba44 	addi	r4,r16,18153
8111b32c:	8111ba44 	addi	r4,r16,18153
8111b330:	8111ba44 	addi	r4,r16,18153
8111b334:	8111ba44 	addi	r4,r16,18153
8111b338:	8111ba44 	addi	r4,r16,18153
8111b33c:	8111ba44 	addi	r4,r16,18153
8111b340:	8111ba44 	addi	r4,r16,18153
8111b344:	8111ba44 	addi	r4,r16,18153
8111b348:	8111ba44 	addi	r4,r16,18153
8111b34c:	8111ba44 	addi	r4,r16,18153
8111b350:	8111ba44 	addi	r4,r16,18153
8111b354:	8111ba7c 	xorhi	r4,r16,18153
8111b358:	8111ba44 	addi	r4,r16,18153
8111b35c:	8111ba44 	addi	r4,r16,18153
8111b360:	8111ba44 	addi	r4,r16,18153
8111b364:	8111ba44 	addi	r4,r16,18153
8111b368:	8111ba44 	addi	r4,r16,18153
8111b36c:	8111ba44 	addi	r4,r16,18153
8111b370:	8111b424 	muli	r4,r16,18128
8111b374:	8111ba44 	addi	r4,r16,18153
8111b378:	8111ba44 	addi	r4,r16,18153
8111b37c:	8111ba44 	addi	r4,r16,18153
8111b380:	8111ba44 	addi	r4,r16,18153
8111b384:	8111ba44 	addi	r4,r16,18153
8111b388:	8111ba44 	addi	r4,r16,18153
8111b38c:	8111ba44 	addi	r4,r16,18153
8111b390:	8111ba44 	addi	r4,r16,18153
8111b394:	8111ba44 	addi	r4,r16,18153
8111b398:	8111ba44 	addi	r4,r16,18153
8111b39c:	8111ba44 	addi	r4,r16,18153
8111b3a0:	8111ba44 	addi	r4,r16,18153
8111b3a4:	8111ba44 	addi	r4,r16,18153
8111b3a8:	8111ba44 	addi	r4,r16,18153
8111b3ac:	8111ba44 	addi	r4,r16,18153
8111b3b0:	8111ba44 	addi	r4,r16,18153
8111b3b4:	8111ba44 	addi	r4,r16,18153
8111b3b8:	8111ba44 	addi	r4,r16,18153
8111b3bc:	8111ba44 	addi	r4,r16,18153
8111b3c0:	8111ba44 	addi	r4,r16,18153
8111b3c4:	8111b9e4 	muli	r4,r16,18151
8111b3c8:	8111ba44 	addi	r4,r16,18153
8111b3cc:	8111ba44 	addi	r4,r16,18153
8111b3d0:	8111ba44 	addi	r4,r16,18153
8111b3d4:	8111ba44 	addi	r4,r16,18153
8111b3d8:	8111ba44 	addi	r4,r16,18153
8111b3dc:	8111ba44 	addi	r4,r16,18153
8111b3e0:	8111ba44 	addi	r4,r16,18153
8111b3e4:	8111b914 	ori	r4,r16,18148
8111b3e8:	8111ba44 	addi	r4,r16,18153
8111b3ec:	8111ba44 	addi	r4,r16,18153
8111b3f0:	8111b640 	call	88111b64 <__reset+0x20f1b64>
8111b3f4:	8111b79c 	xori	r4,r16,18142
8111b3f8:	8111b574 	orhi	r4,r16,18133
8111b3fc:	8111ba44 	addi	r4,r16,18153
8111b400:	8111ba44 	addi	r4,r16,18153
8111b404:	8111ba44 	addi	r4,r16,18153
8111b408:	8111b4a4 	muli	r4,r16,18130
8111b40c:	8111ba44 	addi	r4,r16,18153
8111b410:	8111ba44 	addi	r4,r16,18153
8111b414:	8111b710 	cmplti	r4,r16,18140
8111b418:	8111ba44 	addi	r4,r16,18153
8111b41c:	8111ba44 	addi	r4,r16,18153
8111b420:	8111b844 	addi	r4,r16,18145
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111b424:	e0bffc0f 	ldh	r2,-16(fp)
8111b428:	1009883a 	mov	r4,r2
8111b42c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b430:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8111b434:	00000406 	br	8111b448 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111b438:	e0bffc0f 	ldh	r2,-16(fp)
8111b43c:	1009883a 	mov	r4,r2
8111b440:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b444:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111b448:	e0bff947 	ldb	r2,-27(fp)
8111b44c:	108009d8 	cmpnei	r2,r2,39
8111b450:	103ff91e 	bne	r2,zero,8111b438 <__reset+0xfb0fb438>
							c = cGetNextChar(siFile);
						}
						break;
8111b454:	00018c06 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case -1: 	//EOF
						bEOF = TRUE;
8111b458:	00800044 	movi	r2,1
8111b45c:	e0bff815 	stw	r2,-32(fp)
						break;
8111b460:	00018906 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case -2: 	//EOF
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b464:	00a045f4 	movhi	r2,33047
8111b468:	10a34f04 	addi	r2,r2,-29380
8111b46c:	10800a8b 	ldhu	r2,42(r2)
8111b470:	10bfffcc 	andi	r2,r2,65535
8111b474:	10800228 	cmpgeui	r2,r2,8
8111b478:	1000071e 	bne	r2,zero,8111b498 <vLoadDefaultETHConf+0x27c>
							debug(fp,"SDCard: Problem with SDCard");
8111b47c:	d0a06217 	ldw	r2,-32376(gp)
8111b480:	100f883a 	mov	r7,r2
8111b484:	018006c4 	movi	r6,27
8111b488:	01400044 	movi	r5,1
8111b48c:	01204574 	movhi	r4,33045
8111b490:	2102f404 	addi	r4,r4,3024
8111b494:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						bEOF = TRUE;
8111b498:	00800044 	movi	r2,1
8111b49c:	e0bff815 	stw	r2,-32(fp)
						break;
8111b4a0:	00017906 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8111b4a4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b4a8:	e0bffc0f 	ldh	r2,-16(fp)
8111b4ac:	1009883a 	mov	r4,r2
8111b4b0:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b4b4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b4b8:	d0e00317 	ldw	r3,-32756(gp)
8111b4bc:	e0bff947 	ldb	r2,-27(fp)
8111b4c0:	10800044 	addi	r2,r2,1
8111b4c4:	1885883a 	add	r2,r3,r2
8111b4c8:	10800003 	ldbu	r2,0(r2)
8111b4cc:	10803fcc 	andi	r2,r2,255
8111b4d0:	1080010c 	andi	r2,r2,4
8111b4d4:	10000626 	beq	r2,zero,8111b4f0 <vLoadDefaultETHConf+0x2d4>
									(*p_inteiro) = c;
8111b4d8:	e0bffa17 	ldw	r2,-24(fp)
8111b4dc:	e0fff943 	ldbu	r3,-27(fp)
8111b4e0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b4e4:	e0bffa17 	ldw	r2,-24(fp)
8111b4e8:	10800044 	addi	r2,r2,1
8111b4ec:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111b4f0:	e0bff947 	ldb	r2,-27(fp)
8111b4f4:	10800ea0 	cmpeqi	r2,r2,58
8111b4f8:	1000031e 	bne	r2,zero,8111b508 <vLoadDefaultETHConf+0x2ec>
8111b4fc:	e0bff947 	ldb	r2,-27(fp)
8111b500:	10800ed8 	cmpnei	r2,r2,59
8111b504:	103fe81e 	bne	r2,zero,8111b4a8 <__reset+0xfb0fb4a8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b508:	e0bffa17 	ldw	r2,-24(fp)
8111b50c:	00c00284 	movi	r3,10
8111b510:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = (unsigned char)atoi( inteiro );
8111b514:	e0bff903 	ldbu	r2,-28(fp)
8111b518:	10800168 	cmpgeui	r2,r2,5
8111b51c:	1000021e 	bne	r2,zero,8111b528 <vLoadDefaultETHConf+0x30c>
8111b520:	e43ff903 	ldbu	r16,-28(fp)
8111b524:	00000106 	br	8111b52c <vLoadDefaultETHConf+0x310>
8111b528:	04000144 	movi	r16,5
8111b52c:	e0bffd04 	addi	r2,fp,-12
8111b530:	1009883a 	mov	r4,r2
8111b534:	11234dc0 	call	811234dc <atoi>
8111b538:	1007883a 	mov	r3,r2
8111b53c:	00a045f4 	movhi	r2,33047
8111b540:	10a35c04 	addi	r2,r2,-29328
8111b544:	1405883a 	add	r2,r2,r16
8111b548:	10800404 	addi	r2,r2,16
8111b54c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b550:	e0bffd04 	addi	r2,fp,-12
8111b554:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b558:	e0bff903 	ldbu	r2,-28(fp)
8111b55c:	10800044 	addi	r2,r2,1
8111b560:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b564:	e0bff947 	ldb	r2,-27(fp)
8111b568:	10800ed8 	cmpnei	r2,r2,59
8111b56c:	103fce1e 	bne	r2,zero,8111b4a8 <__reset+0xfb0fb4a8>

						break;
8111b570:	00014506 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 'I':

						ucParser = 0;
8111b574:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b578:	e0bffc0f 	ldh	r2,-16(fp)
8111b57c:	1009883a 	mov	r4,r2
8111b580:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b584:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b588:	d0e00317 	ldw	r3,-32756(gp)
8111b58c:	e0bff947 	ldb	r2,-27(fp)
8111b590:	10800044 	addi	r2,r2,1
8111b594:	1885883a 	add	r2,r3,r2
8111b598:	10800003 	ldbu	r2,0(r2)
8111b59c:	10803fcc 	andi	r2,r2,255
8111b5a0:	1080010c 	andi	r2,r2,4
8111b5a4:	10000626 	beq	r2,zero,8111b5c0 <vLoadDefaultETHConf+0x3a4>
									(*p_inteiro) = c;
8111b5a8:	e0bffa17 	ldw	r2,-24(fp)
8111b5ac:	e0fff943 	ldbu	r3,-27(fp)
8111b5b0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b5b4:	e0bffa17 	ldw	r2,-24(fp)
8111b5b8:	10800044 	addi	r2,r2,1
8111b5bc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b5c0:	e0bff947 	ldb	r2,-27(fp)
8111b5c4:	10800ba0 	cmpeqi	r2,r2,46
8111b5c8:	1000031e 	bne	r2,zero,8111b5d8 <vLoadDefaultETHConf+0x3bc>
8111b5cc:	e0bff947 	ldb	r2,-27(fp)
8111b5d0:	10800ed8 	cmpnei	r2,r2,59
8111b5d4:	103fe81e 	bne	r2,zero,8111b578 <__reset+0xfb0fb578>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b5d8:	e0bffa17 	ldw	r2,-24(fp)
8111b5dc:	00c00284 	movi	r3,10
8111b5e0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b5e4:	e0bff903 	ldbu	r2,-28(fp)
8111b5e8:	108000e8 	cmpgeui	r2,r2,3
8111b5ec:	1000021e 	bne	r2,zero,8111b5f8 <vLoadDefaultETHConf+0x3dc>
8111b5f0:	e43ff903 	ldbu	r16,-28(fp)
8111b5f4:	00000106 	br	8111b5fc <vLoadDefaultETHConf+0x3e0>
8111b5f8:	040000c4 	movi	r16,3
8111b5fc:	e0bffd04 	addi	r2,fp,-12
8111b600:	1009883a 	mov	r4,r2
8111b604:	11234dc0 	call	811234dc <atoi>
8111b608:	1007883a 	mov	r3,r2
8111b60c:	00a045f4 	movhi	r2,33047
8111b610:	10a35c04 	addi	r2,r2,-29328
8111b614:	1405883a 	add	r2,r2,r16
8111b618:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b61c:	e0bffd04 	addi	r2,fp,-12
8111b620:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b624:	e0bff903 	ldbu	r2,-28(fp)
8111b628:	10800044 	addi	r2,r2,1
8111b62c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b630:	e0bff947 	ldb	r2,-27(fp)
8111b634:	10800ed8 	cmpnei	r2,r2,59
8111b638:	103fcf1e 	bne	r2,zero,8111b578 <__reset+0xfb0fb578>

						break;
8111b63c:	00011206 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 'G':

						ucParser = 0;
8111b640:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b644:	e0bffc0f 	ldh	r2,-16(fp)
8111b648:	1009883a 	mov	r4,r2
8111b64c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b650:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b654:	d0e00317 	ldw	r3,-32756(gp)
8111b658:	e0bff947 	ldb	r2,-27(fp)
8111b65c:	10800044 	addi	r2,r2,1
8111b660:	1885883a 	add	r2,r3,r2
8111b664:	10800003 	ldbu	r2,0(r2)
8111b668:	10803fcc 	andi	r2,r2,255
8111b66c:	1080010c 	andi	r2,r2,4
8111b670:	10000626 	beq	r2,zero,8111b68c <vLoadDefaultETHConf+0x470>
									(*p_inteiro) = c;
8111b674:	e0bffa17 	ldw	r2,-24(fp)
8111b678:	e0fff943 	ldbu	r3,-27(fp)
8111b67c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b680:	e0bffa17 	ldw	r2,-24(fp)
8111b684:	10800044 	addi	r2,r2,1
8111b688:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b68c:	e0bff947 	ldb	r2,-27(fp)
8111b690:	10800ba0 	cmpeqi	r2,r2,46
8111b694:	1000031e 	bne	r2,zero,8111b6a4 <vLoadDefaultETHConf+0x488>
8111b698:	e0bff947 	ldb	r2,-27(fp)
8111b69c:	10800ed8 	cmpnei	r2,r2,59
8111b6a0:	103fe81e 	bne	r2,zero,8111b644 <__reset+0xfb0fb644>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b6a4:	e0bffa17 	ldw	r2,-24(fp)
8111b6a8:	00c00284 	movi	r3,10
8111b6ac:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b6b0:	e0bff903 	ldbu	r2,-28(fp)
8111b6b4:	108000e8 	cmpgeui	r2,r2,3
8111b6b8:	1000021e 	bne	r2,zero,8111b6c4 <vLoadDefaultETHConf+0x4a8>
8111b6bc:	e43ff903 	ldbu	r16,-28(fp)
8111b6c0:	00000106 	br	8111b6c8 <vLoadDefaultETHConf+0x4ac>
8111b6c4:	040000c4 	movi	r16,3
8111b6c8:	e0bffd04 	addi	r2,fp,-12
8111b6cc:	1009883a 	mov	r4,r2
8111b6d0:	11234dc0 	call	811234dc <atoi>
8111b6d4:	1007883a 	mov	r3,r2
8111b6d8:	00a045f4 	movhi	r2,33047
8111b6dc:	10a35c04 	addi	r2,r2,-29328
8111b6e0:	1405883a 	add	r2,r2,r16
8111b6e4:	10800104 	addi	r2,r2,4
8111b6e8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b6ec:	e0bffd04 	addi	r2,fp,-12
8111b6f0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b6f4:	e0bff903 	ldbu	r2,-28(fp)
8111b6f8:	10800044 	addi	r2,r2,1
8111b6fc:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b700:	e0bff947 	ldb	r2,-27(fp)
8111b704:	10800ed8 	cmpnei	r2,r2,59
8111b708:	103fce1e 	bne	r2,zero,8111b644 <__reset+0xfb0fb644>

						break;
8111b70c:	0000de06 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 'P':
						ucParser = 0;
8111b710:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
8111b714:	e0bffc0f 	ldh	r2,-16(fp)
8111b718:	1009883a 	mov	r4,r2
8111b71c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b720:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111b724:	d0e00317 	ldw	r3,-32756(gp)
8111b728:	e0bff947 	ldb	r2,-27(fp)
8111b72c:	10800044 	addi	r2,r2,1
8111b730:	1885883a 	add	r2,r3,r2
8111b734:	10800003 	ldbu	r2,0(r2)
8111b738:	10803fcc 	andi	r2,r2,255
8111b73c:	1080010c 	andi	r2,r2,4
8111b740:	10000626 	beq	r2,zero,8111b75c <vLoadDefaultETHConf+0x540>
								(*p_inteiro) = c;
8111b744:	e0bffa17 	ldw	r2,-24(fp)
8111b748:	e0fff943 	ldbu	r3,-27(fp)
8111b74c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b750:	e0bffa17 	ldw	r2,-24(fp)
8111b754:	10800044 	addi	r2,r2,1
8111b758:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b75c:	e0bff947 	ldb	r2,-27(fp)
8111b760:	10800ed8 	cmpnei	r2,r2,59
8111b764:	103feb1e 	bne	r2,zero,8111b714 <__reset+0xfb0fb714>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b768:	e0bffa17 	ldw	r2,-24(fp)
8111b76c:	00c00284 	movi	r3,10
8111b770:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = (unsigned short int)atoi( inteiro );
8111b774:	e0bffd04 	addi	r2,fp,-12
8111b778:	1009883a 	mov	r4,r2
8111b77c:	11234dc0 	call	811234dc <atoi>
8111b780:	1007883a 	mov	r3,r2
8111b784:	00a045f4 	movhi	r2,33047
8111b788:	10a35c04 	addi	r2,r2,-29328
8111b78c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b790:	e0bffd04 	addi	r2,fp,-12
8111b794:	e0bffa15 	stw	r2,-24(fp)

						break;
8111b798:	0000bb06 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111b79c:	e0bffc0f 	ldh	r2,-16(fp)
8111b7a0:	1009883a 	mov	r4,r2
8111b7a4:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b7a8:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111b7ac:	d0e00317 	ldw	r3,-32756(gp)
8111b7b0:	e0bff947 	ldb	r2,-27(fp)
8111b7b4:	10800044 	addi	r2,r2,1
8111b7b8:	1885883a 	add	r2,r3,r2
8111b7bc:	10800003 	ldbu	r2,0(r2)
8111b7c0:	10803fcc 	andi	r2,r2,255
8111b7c4:	1080010c 	andi	r2,r2,4
8111b7c8:	10000626 	beq	r2,zero,8111b7e4 <vLoadDefaultETHConf+0x5c8>
								(*p_inteiro) = c;
8111b7cc:	e0bffa17 	ldw	r2,-24(fp)
8111b7d0:	e0fff943 	ldbu	r3,-27(fp)
8111b7d4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b7d8:	e0bffa17 	ldw	r2,-24(fp)
8111b7dc:	10800044 	addi	r2,r2,1
8111b7e0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b7e4:	e0bff947 	ldb	r2,-27(fp)
8111b7e8:	10800ed8 	cmpnei	r2,r2,59
8111b7ec:	103feb1e 	bne	r2,zero,8111b79c <__reset+0xfb0fb79c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b7f0:	e0bffa17 	ldw	r2,-24(fp)
8111b7f4:	00c00284 	movi	r3,10
8111b7f8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111b7fc:	e0bffd04 	addi	r2,fp,-12
8111b800:	1009883a 	mov	r4,r2
8111b804:	11234dc0 	call	811234dc <atoi>
8111b808:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111b80c:	e0bffc8f 	ldh	r2,-14(fp)
8111b810:	10800058 	cmpnei	r2,r2,1
8111b814:	1000051e 	bne	r2,zero,8111b82c <vLoadDefaultETHConf+0x610>
							xConfEth.bDHCP = TRUE;
8111b818:	00a045f4 	movhi	r2,33047
8111b81c:	10a35c04 	addi	r2,r2,-29328
8111b820:	00c00044 	movi	r3,1
8111b824:	10c00615 	stw	r3,24(r2)
8111b828:	00000306 	br	8111b838 <vLoadDefaultETHConf+0x61c>
						else
							xConfEth.bDHCP = FALSE;
8111b82c:	00a045f4 	movhi	r2,33047
8111b830:	10a35c04 	addi	r2,r2,-29328
8111b834:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b838:	e0bffd04 	addi	r2,fp,-12
8111b83c:	e0bffa15 	stw	r2,-24(fp)

						break;
8111b840:	00009106 	br	8111ba88 <vLoadDefaultETHConf+0x86c>

					case 'S':

						ucParser = 0;
8111b844:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b848:	e0bffc0f 	ldh	r2,-16(fp)
8111b84c:	1009883a 	mov	r4,r2
8111b850:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b854:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b858:	d0e00317 	ldw	r3,-32756(gp)
8111b85c:	e0bff947 	ldb	r2,-27(fp)
8111b860:	10800044 	addi	r2,r2,1
8111b864:	1885883a 	add	r2,r3,r2
8111b868:	10800003 	ldbu	r2,0(r2)
8111b86c:	10803fcc 	andi	r2,r2,255
8111b870:	1080010c 	andi	r2,r2,4
8111b874:	10000626 	beq	r2,zero,8111b890 <vLoadDefaultETHConf+0x674>
									(*p_inteiro) = c;
8111b878:	e0bffa17 	ldw	r2,-24(fp)
8111b87c:	e0fff943 	ldbu	r3,-27(fp)
8111b880:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b884:	e0bffa17 	ldw	r2,-24(fp)
8111b888:	10800044 	addi	r2,r2,1
8111b88c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b890:	e0bff947 	ldb	r2,-27(fp)
8111b894:	10800ba0 	cmpeqi	r2,r2,46
8111b898:	1000031e 	bne	r2,zero,8111b8a8 <vLoadDefaultETHConf+0x68c>
8111b89c:	e0bff947 	ldb	r2,-27(fp)
8111b8a0:	10800ed8 	cmpnei	r2,r2,59
8111b8a4:	103fe81e 	bne	r2,zero,8111b848 <__reset+0xfb0fb848>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b8a8:	e0bffa17 	ldw	r2,-24(fp)
8111b8ac:	00c00284 	movi	r3,10
8111b8b0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b8b4:	e0bff903 	ldbu	r2,-28(fp)
8111b8b8:	108000e8 	cmpgeui	r2,r2,3
8111b8bc:	1000021e 	bne	r2,zero,8111b8c8 <vLoadDefaultETHConf+0x6ac>
8111b8c0:	e43ff903 	ldbu	r16,-28(fp)
8111b8c4:	00000106 	br	8111b8cc <vLoadDefaultETHConf+0x6b0>
8111b8c8:	040000c4 	movi	r16,3
8111b8cc:	e0bffd04 	addi	r2,fp,-12
8111b8d0:	1009883a 	mov	r4,r2
8111b8d4:	11234dc0 	call	811234dc <atoi>
8111b8d8:	1007883a 	mov	r3,r2
8111b8dc:	00a045f4 	movhi	r2,33047
8111b8e0:	10a35c04 	addi	r2,r2,-29328
8111b8e4:	1405883a 	add	r2,r2,r16
8111b8e8:	10800204 	addi	r2,r2,8
8111b8ec:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b8f0:	e0bffd04 	addi	r2,fp,-12
8111b8f4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b8f8:	e0bff903 	ldbu	r2,-28(fp)
8111b8fc:	10800044 	addi	r2,r2,1
8111b900:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b904:	e0bff947 	ldb	r2,-27(fp)
8111b908:	10800ed8 	cmpnei	r2,r2,59
8111b90c:	103fce1e 	bne	r2,zero,8111b848 <__reset+0xfb0fb848>

						break;
8111b910:	00005d06 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 'D':

						ucParser = 0;
8111b914:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b918:	e0bffc0f 	ldh	r2,-16(fp)
8111b91c:	1009883a 	mov	r4,r2
8111b920:	1120ce40 	call	81120ce4 <cGetNextChar>
8111b924:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b928:	d0e00317 	ldw	r3,-32756(gp)
8111b92c:	e0bff947 	ldb	r2,-27(fp)
8111b930:	10800044 	addi	r2,r2,1
8111b934:	1885883a 	add	r2,r3,r2
8111b938:	10800003 	ldbu	r2,0(r2)
8111b93c:	10803fcc 	andi	r2,r2,255
8111b940:	1080010c 	andi	r2,r2,4
8111b944:	10000626 	beq	r2,zero,8111b960 <vLoadDefaultETHConf+0x744>
									(*p_inteiro) = c;
8111b948:	e0bffa17 	ldw	r2,-24(fp)
8111b94c:	e0fff943 	ldbu	r3,-27(fp)
8111b950:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b954:	e0bffa17 	ldw	r2,-24(fp)
8111b958:	10800044 	addi	r2,r2,1
8111b95c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b960:	e0bff947 	ldb	r2,-27(fp)
8111b964:	10800ba0 	cmpeqi	r2,r2,46
8111b968:	1000031e 	bne	r2,zero,8111b978 <vLoadDefaultETHConf+0x75c>
8111b96c:	e0bff947 	ldb	r2,-27(fp)
8111b970:	10800ed8 	cmpnei	r2,r2,59
8111b974:	103fe81e 	bne	r2,zero,8111b918 <__reset+0xfb0fb918>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b978:	e0bffa17 	ldw	r2,-24(fp)
8111b97c:	00c00284 	movi	r3,10
8111b980:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b984:	e0bff903 	ldbu	r2,-28(fp)
8111b988:	108000e8 	cmpgeui	r2,r2,3
8111b98c:	1000021e 	bne	r2,zero,8111b998 <vLoadDefaultETHConf+0x77c>
8111b990:	e43ff903 	ldbu	r16,-28(fp)
8111b994:	00000106 	br	8111b99c <vLoadDefaultETHConf+0x780>
8111b998:	040000c4 	movi	r16,3
8111b99c:	e0bffd04 	addi	r2,fp,-12
8111b9a0:	1009883a 	mov	r4,r2
8111b9a4:	11234dc0 	call	811234dc <atoi>
8111b9a8:	1007883a 	mov	r3,r2
8111b9ac:	00a045f4 	movhi	r2,33047
8111b9b0:	10a35c04 	addi	r2,r2,-29328
8111b9b4:	1405883a 	add	r2,r2,r16
8111b9b8:	10800304 	addi	r2,r2,12
8111b9bc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b9c0:	e0bffd04 	addi	r2,fp,-12
8111b9c4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b9c8:	e0bff903 	ldbu	r2,-28(fp)
8111b9cc:	10800044 	addi	r2,r2,1
8111b9d0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b9d4:	e0bff947 	ldb	r2,-27(fp)
8111b9d8:	10800ed8 	cmpnei	r2,r2,59
8111b9dc:	103fce1e 	bne	r2,zero,8111b918 <__reset+0xfb0fb918>

						break;						
8111b9e0:	00002906 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111b9e4:	e0bffc0f 	ldh	r2,-16(fp)
8111b9e8:	1009883a 	mov	r4,r2
8111b9ec:	1120ca40 	call	81120ca4 <siCloseFile>
8111b9f0:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111b9f4:	e0bffb17 	ldw	r2,-20(fp)
8111b9f8:	10000d1e 	bne	r2,zero,8111ba30 <vLoadDefaultETHConf+0x814>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b9fc:	00a045f4 	movhi	r2,33047
8111ba00:	10a34f04 	addi	r2,r2,-29380
8111ba04:	10800a8b 	ldhu	r2,42(r2)
8111ba08:	10bfffcc 	andi	r2,r2,65535
8111ba0c:	10800228 	cmpgeui	r2,r2,8
8111ba10:	1000071e 	bne	r2,zero,8111ba30 <vLoadDefaultETHConf+0x814>
								debug(fp,"SDCard: Can't close the file.\n");
8111ba14:	d0a06217 	ldw	r2,-32376(gp)
8111ba18:	100f883a 	mov	r7,r2
8111ba1c:	01800784 	movi	r6,30
8111ba20:	01400044 	movi	r5,1
8111ba24:	01204574 	movhi	r4,33045
8111ba28:	2102fb04 	addi	r4,r4,3052
8111ba2c:	1123cec0 	call	81123cec <fwrite>
							}
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111ba30:	00800044 	movi	r2,1
8111ba34:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111ba38:	00800044 	movi	r2,1
8111ba3c:	e0bff715 	stw	r2,-36(fp)
						break;
8111ba40:	00001106 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
					default:
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ba44:	00a045f4 	movhi	r2,33047
8111ba48:	10a34f04 	addi	r2,r2,-29380
8111ba4c:	10800a8b 	ldhu	r2,42(r2)
8111ba50:	10bfffcc 	andi	r2,r2,65535
8111ba54:	10800228 	cmpgeui	r2,r2,8
8111ba58:	10000a1e 	bne	r2,zero,8111ba84 <vLoadDefaultETHConf+0x868>
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111ba5c:	d0a06217 	ldw	r2,-32376(gp)
8111ba60:	100f883a 	mov	r7,r2
8111ba64:	01800844 	movi	r6,33
8111ba68:	01400044 	movi	r5,1
8111ba6c:	01204574 	movhi	r4,33045
8111ba70:	21030304 	addi	r4,r4,3084
8111ba74:	1123cec0 	call	81123cec <fwrite>
						}
						#endif
						break;
8111ba78:	00000206 	br	8111ba84 <vLoadDefaultETHConf+0x868>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111ba7c:	0001883a 	nop
8111ba80:	00000106 	br	8111ba88 <vLoadDefaultETHConf+0x86c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
							fprintf(fp,"SDCard: Problem with the parser.\n");
						}
						#endif
						break;
8111ba84:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8111ba88:	e0bff817 	ldw	r2,-32(fp)
8111ba8c:	103e0126 	beq	r2,zero,8111b294 <__reset+0xfb0fb294>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111ba90:	00001c06 	br	8111bb04 <vLoadDefaultETHConf+0x8e8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ba94:	00a045f4 	movhi	r2,33047
8111ba98:	10a34f04 	addi	r2,r2,-29380
8111ba9c:	10800a8b 	ldhu	r2,42(r2)
8111baa0:	10bfffcc 	andi	r2,r2,65535
8111baa4:	10800228 	cmpgeui	r2,r2,8
8111baa8:	1000161e 	bne	r2,zero,8111bb04 <vLoadDefaultETHConf+0x8e8>
				fprintf(fp,"SDCard: File not found.\n");
8111baac:	d0a06217 	ldw	r2,-32376(gp)
8111bab0:	100f883a 	mov	r7,r2
8111bab4:	01800604 	movi	r6,24
8111bab8:	01400044 	movi	r5,1
8111babc:	01204574 	movhi	r4,33045
8111bac0:	21030c04 	addi	r4,r4,3120
8111bac4:	1123cec0 	call	81123cec <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111bac8:	00000e06 	br	8111bb04 <vLoadDefaultETHConf+0x8e8>
			}
			#endif
		}
	} else {
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111bacc:	00a045f4 	movhi	r2,33047
8111bad0:	10a34f04 	addi	r2,r2,-29380
8111bad4:	10800a8b 	ldhu	r2,42(r2)
8111bad8:	10bfffcc 	andi	r2,r2,65535
8111badc:	10800228 	cmpgeui	r2,r2,8
8111bae0:	1000091e 	bne	r2,zero,8111bb08 <vLoadDefaultETHConf+0x8ec>
			fprintf(fp,"SDCard: No SDCard.\n");
8111bae4:	d0a06217 	ldw	r2,-32376(gp)
8111bae8:	100f883a 	mov	r7,r2
8111baec:	018004c4 	movi	r6,19
8111baf0:	01400044 	movi	r5,1
8111baf4:	01204574 	movhi	r4,33045
8111baf8:	21031304 	addi	r4,r4,3148
8111bafc:	1123cec0 	call	81123cec <fwrite>
8111bb00:	00000106 	br	8111bb08 <vLoadDefaultETHConf+0x8ec>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111bb04:	0001883a 	nop
			fprintf(fp,"SDCard: No SDCard.\n");
		}
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111bb08:	e0bff717 	ldw	r2,-36(fp)
8111bb0c:	10004c1e 	bne	r2,zero,8111bc40 <vLoadDefaultETHConf+0xa24>
		xConfEth.siPortPUS = 17000;
8111bb10:	00a045f4 	movhi	r2,33047
8111bb14:	10a35c04 	addi	r2,r2,-29328
8111bb18:	00d09a04 	movi	r3,17000
8111bb1c:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111bb20:	00a045f4 	movhi	r2,33047
8111bb24:	10a35c04 	addi	r2,r2,-29328
8111bb28:	00fff004 	movi	r3,-64
8111bb2c:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111bb30:	00a045f4 	movhi	r2,33047
8111bb34:	10a35c04 	addi	r2,r2,-29328
8111bb38:	00ffea04 	movi	r3,-88
8111bb3c:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111bb40:	00a045f4 	movhi	r2,33047
8111bb44:	10a35c04 	addi	r2,r2,-29328
8111bb48:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8111bb4c:	00a045f4 	movhi	r2,33047
8111bb50:	10a35c04 	addi	r2,r2,-29328
8111bb54:	00c00144 	movi	r3,5
8111bb58:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8111bb5c:	00a045f4 	movhi	r2,33047
8111bb60:	10a35c04 	addi	r2,r2,-29328
8111bb64:	00fff004 	movi	r3,-64
8111bb68:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8111bb6c:	00a045f4 	movhi	r2,33047
8111bb70:	10a35c04 	addi	r2,r2,-29328
8111bb74:	00ffea04 	movi	r3,-88
8111bb78:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111bb7c:	00a045f4 	movhi	r2,33047
8111bb80:	10a35c04 	addi	r2,r2,-29328
8111bb84:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111bb88:	00a045f4 	movhi	r2,33047
8111bb8c:	10a35c04 	addi	r2,r2,-29328
8111bb90:	00c00044 	movi	r3,1
8111bb94:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111bb98:	00a045f4 	movhi	r2,33047
8111bb9c:	10a35c04 	addi	r2,r2,-29328
8111bba0:	00ffffc4 	movi	r3,-1
8111bba4:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111bba8:	00a045f4 	movhi	r2,33047
8111bbac:	10a35c04 	addi	r2,r2,-29328
8111bbb0:	00ffffc4 	movi	r3,-1
8111bbb4:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111bbb8:	00a045f4 	movhi	r2,33047
8111bbbc:	10a35c04 	addi	r2,r2,-29328
8111bbc0:	00ffffc4 	movi	r3,-1
8111bbc4:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111bbc8:	00a045f4 	movhi	r2,33047
8111bbcc:	10a35c04 	addi	r2,r2,-29328
8111bbd0:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111bbd4:	00a045f4 	movhi	r2,33047
8111bbd8:	10a35c04 	addi	r2,r2,-29328
8111bbdc:	00ffff04 	movi	r3,-4
8111bbe0:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111bbe4:	00a045f4 	movhi	r2,33047
8111bbe8:	10a35c04 	addi	r2,r2,-29328
8111bbec:	00fffdc4 	movi	r3,-9
8111bbf0:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111bbf4:	00a045f4 	movhi	r2,33047
8111bbf8:	10a35c04 	addi	r2,r2,-29328
8111bbfc:	00c018c4 	movi	r3,99
8111bc00:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111bc04:	00a045f4 	movhi	r2,33047
8111bc08:	10a35c04 	addi	r2,r2,-29328
8111bc0c:	00c01344 	movi	r3,77
8111bc10:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111bc14:	00a045f4 	movhi	r2,33047
8111bc18:	10a35c04 	addi	r2,r2,-29328
8111bc1c:	00c007c4 	movi	r3,31
8111bc20:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111bc24:	00a045f4 	movhi	r2,33047
8111bc28:	10a35c04 	addi	r2,r2,-29328
8111bc2c:	00c01084 	movi	r3,66
8111bc30:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111bc34:	00a045f4 	movhi	r2,33047
8111bc38:	10a35c04 	addi	r2,r2,-29328
8111bc3c:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111bc40:	e0bff717 	ldw	r2,-36(fp)
}
8111bc44:	e6ffff04 	addi	sp,fp,-4
8111bc48:	dfc00217 	ldw	ra,8(sp)
8111bc4c:	df000117 	ldw	fp,4(sp)
8111bc50:	dc000017 	ldw	r16,0(sp)
8111bc54:	dec00304 	addi	sp,sp,12
8111bc58:	f800283a 	ret

8111bc5c <vShowEthConfig>:

#if DEBUG_ON
	void vShowEthConfig( void ) {
8111bc5c:	defff004 	addi	sp,sp,-64
8111bc60:	de00012e 	bgeu	sp,et,8111bc68 <vShowEthConfig+0xc>
8111bc64:	003b68fa 	trap	3
8111bc68:	dfc00f15 	stw	ra,60(sp)
8111bc6c:	df000e15 	stw	fp,56(sp)
8111bc70:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111bc74:	d0a06217 	ldw	r2,-32376(gp)
8111bc78:	100f883a 	mov	r7,r2
8111bc7c:	018007c4 	movi	r6,31
8111bc80:	01400044 	movi	r5,1
8111bc84:	01204574 	movhi	r4,33045
8111bc88:	21031804 	addi	r4,r4,3168
8111bc8c:	1123cec0 	call	81123cec <fwrite>

		memset(buffer,0,40);
8111bc90:	01800a04 	movi	r6,40
8111bc94:	000b883a 	mov	r5,zero
8111bc98:	e13ff604 	addi	r4,fp,-40
8111bc9c:	11248500 	call	81124850 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111bca0:	00a045f4 	movhi	r2,33047
8111bca4:	10a35c04 	addi	r2,r2,-29328
8111bca8:	10800403 	ldbu	r2,16(r2)
8111bcac:	11803fcc 	andi	r6,r2,255
8111bcb0:	00a045f4 	movhi	r2,33047
8111bcb4:	10a35c04 	addi	r2,r2,-29328
8111bcb8:	10800443 	ldbu	r2,17(r2)
8111bcbc:	11c03fcc 	andi	r7,r2,255
8111bcc0:	00a045f4 	movhi	r2,33047
8111bcc4:	10a35c04 	addi	r2,r2,-29328
8111bcc8:	10800483 	ldbu	r2,18(r2)
8111bccc:	10c03fcc 	andi	r3,r2,255
8111bcd0:	00a045f4 	movhi	r2,33047
8111bcd4:	10a35c04 	addi	r2,r2,-29328
8111bcd8:	108004c3 	ldbu	r2,19(r2)
8111bcdc:	11003fcc 	andi	r4,r2,255
8111bce0:	00a045f4 	movhi	r2,33047
8111bce4:	10a35c04 	addi	r2,r2,-29328
8111bce8:	10800503 	ldbu	r2,20(r2)
8111bcec:	11403fcc 	andi	r5,r2,255
8111bcf0:	00a045f4 	movhi	r2,33047
8111bcf4:	10a35c04 	addi	r2,r2,-29328
8111bcf8:	10800543 	ldbu	r2,21(r2)
8111bcfc:	10803fcc 	andi	r2,r2,255
8111bd00:	d8800315 	stw	r2,12(sp)
8111bd04:	d9400215 	stw	r5,8(sp)
8111bd08:	d9000115 	stw	r4,4(sp)
8111bd0c:	d8c00015 	stw	r3,0(sp)
8111bd10:	01604574 	movhi	r5,33045
8111bd14:	29432004 	addi	r5,r5,3200
8111bd18:	e13ff604 	addi	r4,fp,-40
8111bd1c:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer );
8111bd20:	d0a06217 	ldw	r2,-32376(gp)
8111bd24:	e17ff604 	addi	r5,fp,-40
8111bd28:	1009883a 	mov	r4,r2
8111bd2c:	11236500 	call	81123650 <fprintf>

		memset(buffer,0,40);
8111bd30:	01800a04 	movi	r6,40
8111bd34:	000b883a 	mov	r5,zero
8111bd38:	e13ff604 	addi	r4,fp,-40
8111bd3c:	11248500 	call	81124850 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111bd40:	00a045f4 	movhi	r2,33047
8111bd44:	10a35c04 	addi	r2,r2,-29328
8111bd48:	10800003 	ldbu	r2,0(r2)
8111bd4c:	11003fcc 	andi	r4,r2,255
8111bd50:	00a045f4 	movhi	r2,33047
8111bd54:	10a35c04 	addi	r2,r2,-29328
8111bd58:	10800043 	ldbu	r2,1(r2)
8111bd5c:	11403fcc 	andi	r5,r2,255
8111bd60:	00a045f4 	movhi	r2,33047
8111bd64:	10a35c04 	addi	r2,r2,-29328
8111bd68:	10800083 	ldbu	r2,2(r2)
8111bd6c:	10c03fcc 	andi	r3,r2,255
8111bd70:	00a045f4 	movhi	r2,33047
8111bd74:	10a35c04 	addi	r2,r2,-29328
8111bd78:	108000c3 	ldbu	r2,3(r2)
8111bd7c:	10803fcc 	andi	r2,r2,255
8111bd80:	d8800115 	stw	r2,4(sp)
8111bd84:	d8c00015 	stw	r3,0(sp)
8111bd88:	280f883a 	mov	r7,r5
8111bd8c:	200d883a 	mov	r6,r4
8111bd90:	01604574 	movhi	r5,33045
8111bd94:	29432904 	addi	r5,r5,3236
8111bd98:	e13ff604 	addi	r4,fp,-40
8111bd9c:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer );
8111bda0:	d0a06217 	ldw	r2,-32376(gp)
8111bda4:	e17ff604 	addi	r5,fp,-40
8111bda8:	1009883a 	mov	r4,r2
8111bdac:	11236500 	call	81123650 <fprintf>

		memset(buffer,0,40);
8111bdb0:	01800a04 	movi	r6,40
8111bdb4:	000b883a 	mov	r5,zero
8111bdb8:	e13ff604 	addi	r4,fp,-40
8111bdbc:	11248500 	call	81124850 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111bdc0:	00a045f4 	movhi	r2,33047
8111bdc4:	10a35c04 	addi	r2,r2,-29328
8111bdc8:	10800103 	ldbu	r2,4(r2)
8111bdcc:	11003fcc 	andi	r4,r2,255
8111bdd0:	00a045f4 	movhi	r2,33047
8111bdd4:	10a35c04 	addi	r2,r2,-29328
8111bdd8:	10800143 	ldbu	r2,5(r2)
8111bddc:	11403fcc 	andi	r5,r2,255
8111bde0:	00a045f4 	movhi	r2,33047
8111bde4:	10a35c04 	addi	r2,r2,-29328
8111bde8:	10800183 	ldbu	r2,6(r2)
8111bdec:	10c03fcc 	andi	r3,r2,255
8111bdf0:	00a045f4 	movhi	r2,33047
8111bdf4:	10a35c04 	addi	r2,r2,-29328
8111bdf8:	108001c3 	ldbu	r2,7(r2)
8111bdfc:	10803fcc 	andi	r2,r2,255
8111be00:	d8800115 	stw	r2,4(sp)
8111be04:	d8c00015 	stw	r3,0(sp)
8111be08:	280f883a 	mov	r7,r5
8111be0c:	200d883a 	mov	r6,r4
8111be10:	01604574 	movhi	r5,33045
8111be14:	29432f04 	addi	r5,r5,3260
8111be18:	e13ff604 	addi	r4,fp,-40
8111be1c:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer );
8111be20:	d0a06217 	ldw	r2,-32376(gp)
8111be24:	e17ff604 	addi	r5,fp,-40
8111be28:	1009883a 	mov	r4,r2
8111be2c:	11236500 	call	81123650 <fprintf>

		memset(buffer,0,40);
8111be30:	01800a04 	movi	r6,40
8111be34:	000b883a 	mov	r5,zero
8111be38:	e13ff604 	addi	r4,fp,-40
8111be3c:	11248500 	call	81124850 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111be40:	00a045f4 	movhi	r2,33047
8111be44:	10a35c04 	addi	r2,r2,-29328
8111be48:	10800203 	ldbu	r2,8(r2)
8111be4c:	11003fcc 	andi	r4,r2,255
8111be50:	00a045f4 	movhi	r2,33047
8111be54:	10a35c04 	addi	r2,r2,-29328
8111be58:	10800243 	ldbu	r2,9(r2)
8111be5c:	11403fcc 	andi	r5,r2,255
8111be60:	00a045f4 	movhi	r2,33047
8111be64:	10a35c04 	addi	r2,r2,-29328
8111be68:	10800283 	ldbu	r2,10(r2)
8111be6c:	10c03fcc 	andi	r3,r2,255
8111be70:	00a045f4 	movhi	r2,33047
8111be74:	10a35c04 	addi	r2,r2,-29328
8111be78:	108002c3 	ldbu	r2,11(r2)
8111be7c:	10803fcc 	andi	r2,r2,255
8111be80:	d8800115 	stw	r2,4(sp)
8111be84:	d8c00015 	stw	r3,0(sp)
8111be88:	280f883a 	mov	r7,r5
8111be8c:	200d883a 	mov	r6,r4
8111be90:	01604574 	movhi	r5,33045
8111be94:	29433604 	addi	r5,r5,3288
8111be98:	e13ff604 	addi	r4,fp,-40
8111be9c:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer );
8111bea0:	d0a06217 	ldw	r2,-32376(gp)
8111bea4:	e17ff604 	addi	r5,fp,-40
8111bea8:	1009883a 	mov	r4,r2
8111beac:	11236500 	call	81123650 <fprintf>

		memset(buffer,0,40);
8111beb0:	01800a04 	movi	r6,40
8111beb4:	000b883a 	mov	r5,zero
8111beb8:	e13ff604 	addi	r4,fp,-40
8111bebc:	11248500 	call	81124850 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111bec0:	00a045f4 	movhi	r2,33047
8111bec4:	10a35c04 	addi	r2,r2,-29328
8111bec8:	10800303 	ldbu	r2,12(r2)
8111becc:	11003fcc 	andi	r4,r2,255
8111bed0:	00a045f4 	movhi	r2,33047
8111bed4:	10a35c04 	addi	r2,r2,-29328
8111bed8:	10800343 	ldbu	r2,13(r2)
8111bedc:	11403fcc 	andi	r5,r2,255
8111bee0:	00a045f4 	movhi	r2,33047
8111bee4:	10a35c04 	addi	r2,r2,-29328
8111bee8:	10800383 	ldbu	r2,14(r2)
8111beec:	10c03fcc 	andi	r3,r2,255
8111bef0:	00a045f4 	movhi	r2,33047
8111bef4:	10a35c04 	addi	r2,r2,-29328
8111bef8:	108003c3 	ldbu	r2,15(r2)
8111befc:	10803fcc 	andi	r2,r2,255
8111bf00:	d8800115 	stw	r2,4(sp)
8111bf04:	d8c00015 	stw	r3,0(sp)
8111bf08:	280f883a 	mov	r7,r5
8111bf0c:	200d883a 	mov	r6,r4
8111bf10:	01604574 	movhi	r5,33045
8111bf14:	29433d04 	addi	r5,r5,3316
8111bf18:	e13ff604 	addi	r4,fp,-40
8111bf1c:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer );
8111bf20:	d0a06217 	ldw	r2,-32376(gp)
8111bf24:	e17ff604 	addi	r5,fp,-40
8111bf28:	1009883a 	mov	r4,r2
8111bf2c:	11236500 	call	81123650 <fprintf>

		memset(buffer,0,40);
8111bf30:	01800a04 	movi	r6,40
8111bf34:	000b883a 	mov	r5,zero
8111bf38:	e13ff604 	addi	r4,fp,-40
8111bf3c:	11248500 	call	81124850 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111bf40:	00a045f4 	movhi	r2,33047
8111bf44:	10a35c04 	addi	r2,r2,-29328
8111bf48:	1080058b 	ldhu	r2,22(r2)
8111bf4c:	10bfffcc 	andi	r2,r2,65535
8111bf50:	100d883a 	mov	r6,r2
8111bf54:	01604574 	movhi	r5,33045
8111bf58:	29434404 	addi	r5,r5,3344
8111bf5c:	e13ff604 	addi	r4,fp,-40
8111bf60:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer );
8111bf64:	d0a06217 	ldw	r2,-32376(gp)
8111bf68:	e17ff604 	addi	r5,fp,-40
8111bf6c:	1009883a 	mov	r4,r2
8111bf70:	11236500 	call	81123650 <fprintf>

	}
8111bf74:	0001883a 	nop
8111bf78:	e037883a 	mov	sp,fp
8111bf7c:	dfc00117 	ldw	ra,4(sp)
8111bf80:	df000017 	ldw	fp,0(sp)
8111bf84:	dec00204 	addi	sp,sp,8
8111bf88:	f800283a 	ret

8111bf8c <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111bf8c:	deffee04 	addi	sp,sp,-72
8111bf90:	de00012e 	bgeu	sp,et,8111bf98 <vLoadDebugConfs+0xc>
8111bf94:	003b68fa 	trap	3
8111bf98:	dfc01115 	stw	ra,68(sp)
8111bf9c:	df001015 	stw	fp,64(sp)
8111bfa0:	dc000f15 	stw	r16,60(sp)
8111bfa4:	df001004 	addi	fp,sp,64
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111bfa8:	e03ff015 	stw	zero,-64(fp)
	bool bEOF = FALSE;
8111bfac:	e03ff115 	stw	zero,-60(fp)
	bool close = FALSE;
8111bfb0:	e03ff515 	stw	zero,-44(fp)
	char c, *p_inteiro, *p_inteiroll;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111bfb4:	d0a07617 	ldw	r2,-32296(gp)
8111bfb8:	10800058 	cmpnei	r2,r2,1
8111bfbc:	1003e21e 	bne	r2,zero,8111cf48 <vLoadDebugConfs+0xfbc>
8111bfc0:	1120b100 	call	81120b10 <bSDcardIsPresent>
8111bfc4:	1003e026 	beq	r2,zero,8111cf48 <vLoadDebugConfs+0xfbc>
8111bfc8:	1120b400 	call	81120b40 <bSDcardFAT16Check>
8111bfcc:	1003de26 	beq	r2,zero,8111cf48 <vLoadDebugConfs+0xfbc>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111bfd0:	01204574 	movhi	r4,33045
8111bfd4:	21034804 	addi	r4,r4,3360
8111bfd8:	1120c680 	call	81120c68 <siOpenFile>
8111bfdc:	e0bff60d 	sth	r2,-40(fp)

		if ( siFile >= 0 ){
8111bfe0:	e0bff60f 	ldh	r2,-40(fp)
8111bfe4:	1003d016 	blt	r2,zero,8111cf28 <vLoadDebugConfs+0xf9c>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111bfe8:	e0bff704 	addi	r2,fp,-36
8111bfec:	01800204 	movi	r6,8
8111bff0:	01400284 	movi	r5,10
8111bff4:	1009883a 	mov	r4,r2
8111bff8:	11248500 	call	81124850 <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8111bffc:	e0bff904 	addi	r2,fp,-28
8111c000:	01800604 	movi	r6,24
8111c004:	01400284 	movi	r5,10
8111c008:	1009883a 	mov	r4,r2
8111c00c:	11248500 	call	81124850 <memset>
			p_inteiro = inteiro;
8111c010:	e0bff704 	addi	r2,fp,-36
8111c014:	e0bff315 	stw	r2,-52(fp)
			p_inteiroll = inteiroll;
8111c018:	e0bff904 	addi	r2,fp,-28
8111c01c:	e0bff415 	stw	r2,-48(fp)

			do {
				c = cGetNextChar(siFile);
8111c020:	e0bff60f 	ldh	r2,-40(fp)
8111c024:	1009883a 	mov	r4,r2
8111c028:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c02c:	e0bff245 	stb	r2,-55(fp)
				//printf("%c \n", c);
				switch (c) {
8111c030:	e0bff247 	ldb	r2,-55(fp)
8111c034:	10800084 	addi	r2,r2,2
8111c038:	10c01768 	cmpgeui	r3,r2,93
8111c03c:	1803ae1e 	bne	r3,zero,8111cef8 <vLoadDebugConfs+0xf6c>
8111c040:	100690ba 	slli	r3,r2,2
8111c044:	00a044b4 	movhi	r2,33042
8111c048:	10b01604 	addi	r2,r2,-16296
8111c04c:	1885883a 	add	r2,r3,r2
8111c050:	10800017 	ldw	r2,0(r2)
8111c054:	1000683a 	jmp	r2
8111c058:	8111c20c 	andi	r4,r16,18184
8111c05c:	8111c200 	call	88111c20 <__reset+0x20f1c20>
8111c060:	8111cef8 	rdprs	r4,r16,18235
8111c064:	8111cef8 	rdprs	r4,r16,18235
8111c068:	8111cef8 	rdprs	r4,r16,18235
8111c06c:	8111cef8 	rdprs	r4,r16,18235
8111c070:	8111cef8 	rdprs	r4,r16,18235
8111c074:	8111cef8 	rdprs	r4,r16,18235
8111c078:	8111cef8 	rdprs	r4,r16,18235
8111c07c:	8111cef8 	rdprs	r4,r16,18235
8111c080:	8111cef8 	rdprs	r4,r16,18235
8111c084:	8111cef8 	rdprs	r4,r16,18235
8111c088:	8111cf18 	cmpnei	r4,r16,18236
8111c08c:	8111cef8 	rdprs	r4,r16,18235
8111c090:	8111cef8 	rdprs	r4,r16,18235
8111c094:	8111cf18 	cmpnei	r4,r16,18236
8111c098:	8111cef8 	rdprs	r4,r16,18235
8111c09c:	8111cef8 	rdprs	r4,r16,18235
8111c0a0:	8111cef8 	rdprs	r4,r16,18235
8111c0a4:	8111cef8 	rdprs	r4,r16,18235
8111c0a8:	8111cef8 	rdprs	r4,r16,18235
8111c0ac:	8111cef8 	rdprs	r4,r16,18235
8111c0b0:	8111cef8 	rdprs	r4,r16,18235
8111c0b4:	8111cef8 	rdprs	r4,r16,18235
8111c0b8:	8111cef8 	rdprs	r4,r16,18235
8111c0bc:	8111cef8 	rdprs	r4,r16,18235
8111c0c0:	8111cef8 	rdprs	r4,r16,18235
8111c0c4:	8111cef8 	rdprs	r4,r16,18235
8111c0c8:	8111cef8 	rdprs	r4,r16,18235
8111c0cc:	8111cef8 	rdprs	r4,r16,18235
8111c0d0:	8111cef8 	rdprs	r4,r16,18235
8111c0d4:	8111cef8 	rdprs	r4,r16,18235
8111c0d8:	8111cef8 	rdprs	r4,r16,18235
8111c0dc:	8111cef8 	rdprs	r4,r16,18235
8111c0e0:	8111cf18 	cmpnei	r4,r16,18236
8111c0e4:	8111cef8 	rdprs	r4,r16,18235
8111c0e8:	8111cef8 	rdprs	r4,r16,18235
8111c0ec:	8111cef8 	rdprs	r4,r16,18235
8111c0f0:	8111cef8 	rdprs	r4,r16,18235
8111c0f4:	8111cef8 	rdprs	r4,r16,18235
8111c0f8:	8111cef8 	rdprs	r4,r16,18235
8111c0fc:	8111c1cc 	andi	r4,r16,18183
8111c100:	8111cef8 	rdprs	r4,r16,18235
8111c104:	8111cef8 	rdprs	r4,r16,18235
8111c108:	8111cef8 	rdprs	r4,r16,18235
8111c10c:	8111cef8 	rdprs	r4,r16,18235
8111c110:	8111cef8 	rdprs	r4,r16,18235
8111c114:	8111cef8 	rdprs	r4,r16,18235
8111c118:	8111cef8 	rdprs	r4,r16,18235
8111c11c:	8111cef8 	rdprs	r4,r16,18235
8111c120:	8111cef8 	rdprs	r4,r16,18235
8111c124:	8111cef8 	rdprs	r4,r16,18235
8111c128:	8111cef8 	rdprs	r4,r16,18235
8111c12c:	8111cef8 	rdprs	r4,r16,18235
8111c130:	8111cef8 	rdprs	r4,r16,18235
8111c134:	8111cef8 	rdprs	r4,r16,18235
8111c138:	8111cef8 	rdprs	r4,r16,18235
8111c13c:	8111cef8 	rdprs	r4,r16,18235
8111c140:	8111cef8 	rdprs	r4,r16,18235
8111c144:	8111cef8 	rdprs	r4,r16,18235
8111c148:	8111cef8 	rdprs	r4,r16,18235
8111c14c:	8111cef8 	rdprs	r4,r16,18235
8111c150:	8111ceb0 	cmpltui	r4,r16,18234
8111c154:	8111cef8 	rdprs	r4,r16,18235
8111c158:	8111cef8 	rdprs	r4,r16,18235
8111c15c:	8111cef8 	rdprs	r4,r16,18235
8111c160:	8111cef8 	rdprs	r4,r16,18235
8111c164:	8111c4f4 	orhi	r4,r16,18195
8111c168:	8111c964 	muli	r4,r16,18213
8111c16c:	8111c704 	addi	r4,r16,18204
8111c170:	8111cb84 	addi	r4,r16,18222
8111c174:	8111cc94 	ori	r4,r16,18226
8111c178:	8111c9ec 	andhi	r4,r16,18215
8111c17c:	8111cef8 	rdprs	r4,r16,18235
8111c180:	8111cc0c 	andi	r4,r16,18224
8111c184:	8111cef8 	rdprs	r4,r16,18235
8111c188:	8111c8d4 	ori	r4,r16,18211
8111c18c:	8111c7b4 	orhi	r4,r16,18206
8111c190:	8111c5a4 	muli	r4,r16,18198
8111c194:	8111c844 	addi	r4,r16,18209
8111c198:	8111c394 	ori	r4,r16,18190
8111c19c:	8111c654 	ori	r4,r16,18201
8111c1a0:	8111c2e4 	muli	r4,r16,18187
8111c1a4:	8111ca74 	orhi	r4,r16,18217
8111c1a8:	8111c444 	addi	r4,r16,18193
8111c1ac:	8111c234 	orhi	r4,r16,18184
8111c1b0:	8111cd60 	cmpeqi	r4,r16,18229
8111c1b4:	8111cef8 	rdprs	r4,r16,18235
8111c1b8:	8111cef8 	rdprs	r4,r16,18235
8111c1bc:	8111cef8 	rdprs	r4,r16,18235
8111c1c0:	8111cef8 	rdprs	r4,r16,18235
8111c1c4:	8111cafc 	xorhi	r4,r16,18219
8111c1c8:	8111ce08 	cmpgei	r4,r16,18232
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111c1cc:	e0bff60f 	ldh	r2,-40(fp)
8111c1d0:	1009883a 	mov	r4,r2
8111c1d4:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c1d8:	e0bff245 	stb	r2,-55(fp)
						while ( c != 39 ){
8111c1dc:	00000406 	br	8111c1f0 <vLoadDebugConfs+0x264>
							c = cGetNextChar(siFile);
8111c1e0:	e0bff60f 	ldh	r2,-40(fp)
8111c1e4:	1009883a 	mov	r4,r2
8111c1e8:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c1ec:	e0bff245 	stb	r2,-55(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111c1f0:	e0bff247 	ldb	r2,-55(fp)
8111c1f4:	108009d8 	cmpnei	r2,r2,39
8111c1f8:	103ff91e 	bne	r2,zero,8111c1e0 <__reset+0xfb0fc1e0>
							c = cGetNextChar(siFile);
						}
						break;
8111c1fc:	00034706 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case -1: 	//EOF
						bEOF = TRUE;
8111c200:	00800044 	movi	r2,1
8111c204:	e0bff115 	stw	r2,-60(fp)
						break;
8111c208:	00034406 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111c20c:	d0a06217 	ldw	r2,-32376(gp)
8111c210:	100f883a 	mov	r7,r2
8111c214:	018006c4 	movi	r6,27
8111c218:	01400044 	movi	r5,1
8111c21c:	01204574 	movhi	r4,33045
8111c220:	2102f404 	addi	r4,r4,3024
8111c224:	1123cec0 	call	81123cec <fwrite>
						#endif
						bEOF = TRUE;
8111c228:	00800044 	movi	r2,1
8111c22c:	e0bff115 	stw	r2,-60(fp)
						break;
8111c230:	00033a06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111c234:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c238:	e0bff60f 	ldh	r2,-40(fp)
8111c23c:	1009883a 	mov	r4,r2
8111c240:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c244:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c248:	d0e00317 	ldw	r3,-32756(gp)
8111c24c:	e0bff247 	ldb	r2,-55(fp)
8111c250:	10800044 	addi	r2,r2,1
8111c254:	1885883a 	add	r2,r3,r2
8111c258:	10800003 	ldbu	r2,0(r2)
8111c25c:	10803fcc 	andi	r2,r2,255
8111c260:	1080010c 	andi	r2,r2,4
8111c264:	10000626 	beq	r2,zero,8111c280 <vLoadDebugConfs+0x2f4>
									(*p_inteiro) = c;
8111c268:	e0bff317 	ldw	r2,-52(fp)
8111c26c:	e0fff243 	ldbu	r3,-55(fp)
8111c270:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c274:	e0bff317 	ldw	r2,-52(fp)
8111c278:	10800044 	addi	r2,r2,1
8111c27c:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c280:	e0bff247 	ldb	r2,-55(fp)
8111c284:	10800ba0 	cmpeqi	r2,r2,46
8111c288:	1000031e 	bne	r2,zero,8111c298 <vLoadDebugConfs+0x30c>
8111c28c:	e0bff247 	ldb	r2,-55(fp)
8111c290:	10800ed8 	cmpnei	r2,r2,59
8111c294:	103fe81e 	bne	r2,zero,8111c238 <__reset+0xfb0fc238>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c298:	e0bff317 	ldw	r2,-52(fp)
8111c29c:	00c00284 	movi	r3,10
8111c2a0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = (unsigned short int)atoi( inteiro );
8111c2a4:	e0bff704 	addi	r2,fp,-36
8111c2a8:	1009883a 	mov	r4,r2
8111c2ac:	11234dc0 	call	811234dc <atoi>
8111c2b0:	1007883a 	mov	r3,r2
8111c2b4:	00a045f4 	movhi	r2,33047
8111c2b8:	10a34f04 	addi	r2,r2,-29380
8111c2bc:	10c0038d 	sth	r3,14(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c2c0:	e0bff704 	addi	r2,fp,-36
8111c2c4:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c2c8:	e0bff203 	ldbu	r2,-56(fp)
8111c2cc:	10800044 	addi	r2,r2,1
8111c2d0:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c2d4:	e0bff247 	ldb	r2,-55(fp)
8111c2d8:	10800ed8 	cmpnei	r2,r2,59
8111c2dc:	103fd61e 	bne	r2,zero,8111c238 <__reset+0xfb0fc238>

						break;
8111c2e0:	00030e06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'P':
						ucParser = 0;
8111c2e4:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c2e8:	e0bff60f 	ldh	r2,-40(fp)
8111c2ec:	1009883a 	mov	r4,r2
8111c2f0:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c2f4:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c2f8:	d0e00317 	ldw	r3,-32756(gp)
8111c2fc:	e0bff247 	ldb	r2,-55(fp)
8111c300:	10800044 	addi	r2,r2,1
8111c304:	1885883a 	add	r2,r3,r2
8111c308:	10800003 	ldbu	r2,0(r2)
8111c30c:	10803fcc 	andi	r2,r2,255
8111c310:	1080010c 	andi	r2,r2,4
8111c314:	10000626 	beq	r2,zero,8111c330 <vLoadDebugConfs+0x3a4>
									(*p_inteiro) = c;
8111c318:	e0bff317 	ldw	r2,-52(fp)
8111c31c:	e0fff243 	ldbu	r3,-55(fp)
8111c320:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c324:	e0bff317 	ldw	r2,-52(fp)
8111c328:	10800044 	addi	r2,r2,1
8111c32c:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c330:	e0bff247 	ldb	r2,-55(fp)
8111c334:	10800ba0 	cmpeqi	r2,r2,46
8111c338:	1000031e 	bne	r2,zero,8111c348 <vLoadDebugConfs+0x3bc>
8111c33c:	e0bff247 	ldb	r2,-55(fp)
8111c340:	10800ed8 	cmpnei	r2,r2,59
8111c344:	103fe81e 	bne	r2,zero,8111c2e8 <__reset+0xfb0fc2e8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c348:	e0bff317 	ldw	r2,-52(fp)
8111c34c:	00c00284 	movi	r3,10
8111c350:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = (unsigned short int)atoi( inteiro );
8111c354:	e0bff704 	addi	r2,fp,-36
8111c358:	1009883a 	mov	r4,r2
8111c35c:	11234dc0 	call	811234dc <atoi>
8111c360:	1007883a 	mov	r3,r2
8111c364:	00a045f4 	movhi	r2,33047
8111c368:	10a34f04 	addi	r2,r2,-29380
8111c36c:	10c0018d 	sth	r3,6(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c370:	e0bff704 	addi	r2,fp,-36
8111c374:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c378:	e0bff203 	ldbu	r2,-56(fp)
8111c37c:	10800044 	addi	r2,r2,1
8111c380:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c384:	e0bff247 	ldb	r2,-55(fp)
8111c388:	10800ed8 	cmpnei	r2,r2,59
8111c38c:	103fd61e 	bne	r2,zero,8111c2e8 <__reset+0xfb0fc2e8>

						break;
8111c390:	0002e206 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'N':
						ucParser = 0;
8111c394:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c398:	e0bff60f 	ldh	r2,-40(fp)
8111c39c:	1009883a 	mov	r4,r2
8111c3a0:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c3a4:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c3a8:	d0e00317 	ldw	r3,-32756(gp)
8111c3ac:	e0bff247 	ldb	r2,-55(fp)
8111c3b0:	10800044 	addi	r2,r2,1
8111c3b4:	1885883a 	add	r2,r3,r2
8111c3b8:	10800003 	ldbu	r2,0(r2)
8111c3bc:	10803fcc 	andi	r2,r2,255
8111c3c0:	1080010c 	andi	r2,r2,4
8111c3c4:	10000626 	beq	r2,zero,8111c3e0 <vLoadDebugConfs+0x454>
									(*p_inteiro) = c;
8111c3c8:	e0bff317 	ldw	r2,-52(fp)
8111c3cc:	e0fff243 	ldbu	r3,-55(fp)
8111c3d0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c3d4:	e0bff317 	ldw	r2,-52(fp)
8111c3d8:	10800044 	addi	r2,r2,1
8111c3dc:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c3e0:	e0bff247 	ldb	r2,-55(fp)
8111c3e4:	10800ba0 	cmpeqi	r2,r2,46
8111c3e8:	1000031e 	bne	r2,zero,8111c3f8 <vLoadDebugConfs+0x46c>
8111c3ec:	e0bff247 	ldb	r2,-55(fp)
8111c3f0:	10800ed8 	cmpnei	r2,r2,59
8111c3f4:	103fe81e 	bne	r2,zero,8111c398 <__reset+0xfb0fc398>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c3f8:	e0bff317 	ldw	r2,-52(fp)
8111c3fc:	00c00284 	movi	r3,10
8111c400:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = (unsigned short int)atoi( inteiro );
8111c404:	e0bff704 	addi	r2,fp,-36
8111c408:	1009883a 	mov	r4,r2
8111c40c:	11234dc0 	call	811234dc <atoi>
8111c410:	1007883a 	mov	r3,r2
8111c414:	00a045f4 	movhi	r2,33047
8111c418:	10a34f04 	addi	r2,r2,-29380
8111c41c:	10c0010d 	sth	r3,4(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c420:	e0bff704 	addi	r2,fp,-36
8111c424:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c428:	e0bff203 	ldbu	r2,-56(fp)
8111c42c:	10800044 	addi	r2,r2,1
8111c430:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c434:	e0bff247 	ldb	r2,-55(fp)
8111c438:	10800ed8 	cmpnei	r2,r2,59
8111c43c:	103fd61e 	bne	r2,zero,8111c398 <__reset+0xfb0fc398>

						break;
8111c440:	0002b606 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'R':
						ucParser = 0;
8111c444:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c448:	e0bff60f 	ldh	r2,-40(fp)
8111c44c:	1009883a 	mov	r4,r2
8111c450:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c454:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c458:	d0e00317 	ldw	r3,-32756(gp)
8111c45c:	e0bff247 	ldb	r2,-55(fp)
8111c460:	10800044 	addi	r2,r2,1
8111c464:	1885883a 	add	r2,r3,r2
8111c468:	10800003 	ldbu	r2,0(r2)
8111c46c:	10803fcc 	andi	r2,r2,255
8111c470:	1080010c 	andi	r2,r2,4
8111c474:	10000626 	beq	r2,zero,8111c490 <vLoadDebugConfs+0x504>
									(*p_inteiro) = c;
8111c478:	e0bff317 	ldw	r2,-52(fp)
8111c47c:	e0fff243 	ldbu	r3,-55(fp)
8111c480:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c484:	e0bff317 	ldw	r2,-52(fp)
8111c488:	10800044 	addi	r2,r2,1
8111c48c:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c490:	e0bff247 	ldb	r2,-55(fp)
8111c494:	10800ba0 	cmpeqi	r2,r2,46
8111c498:	1000031e 	bne	r2,zero,8111c4a8 <vLoadDebugConfs+0x51c>
8111c49c:	e0bff247 	ldb	r2,-55(fp)
8111c4a0:	10800ed8 	cmpnei	r2,r2,59
8111c4a4:	103fe81e 	bne	r2,zero,8111c448 <__reset+0xfb0fc448>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c4a8:	e0bff317 	ldw	r2,-52(fp)
8111c4ac:	00c00284 	movi	r3,10
8111c4b0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = (unsigned short int)atoi( inteiro );
8111c4b4:	e0bff704 	addi	r2,fp,-36
8111c4b8:	1009883a 	mov	r4,r2
8111c4bc:	11234dc0 	call	811234dc <atoi>
8111c4c0:	1007883a 	mov	r3,r2
8111c4c4:	00a045f4 	movhi	r2,33047
8111c4c8:	10a34f04 	addi	r2,r2,-29380
8111c4cc:	10c0080d 	sth	r3,32(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c4d0:	e0bff704 	addi	r2,fp,-36
8111c4d4:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c4d8:	e0bff203 	ldbu	r2,-56(fp)
8111c4dc:	10800044 	addi	r2,r2,1
8111c4e0:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c4e4:	e0bff247 	ldb	r2,-55(fp)
8111c4e8:	10800ed8 	cmpnei	r2,r2,59
8111c4ec:	103fd61e 	bne	r2,zero,8111c448 <__reset+0xfb0fc448>

						break;
8111c4f0:	00028a06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'A':
						ucParser = 0;
8111c4f4:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c4f8:	e0bff60f 	ldh	r2,-40(fp)
8111c4fc:	1009883a 	mov	r4,r2
8111c500:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c504:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c508:	d0e00317 	ldw	r3,-32756(gp)
8111c50c:	e0bff247 	ldb	r2,-55(fp)
8111c510:	10800044 	addi	r2,r2,1
8111c514:	1885883a 	add	r2,r3,r2
8111c518:	10800003 	ldbu	r2,0(r2)
8111c51c:	10803fcc 	andi	r2,r2,255
8111c520:	1080010c 	andi	r2,r2,4
8111c524:	10000626 	beq	r2,zero,8111c540 <vLoadDebugConfs+0x5b4>
									(*p_inteiro) = c;
8111c528:	e0bff317 	ldw	r2,-52(fp)
8111c52c:	e0fff243 	ldbu	r3,-55(fp)
8111c530:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c534:	e0bff317 	ldw	r2,-52(fp)
8111c538:	10800044 	addi	r2,r2,1
8111c53c:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c540:	e0bff247 	ldb	r2,-55(fp)
8111c544:	10800ba0 	cmpeqi	r2,r2,46
8111c548:	1000031e 	bne	r2,zero,8111c558 <vLoadDebugConfs+0x5cc>
8111c54c:	e0bff247 	ldb	r2,-55(fp)
8111c550:	10800ed8 	cmpnei	r2,r2,59
8111c554:	103fe81e 	bne	r2,zero,8111c4f8 <__reset+0xfb0fc4f8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c558:	e0bff317 	ldw	r2,-52(fp)
8111c55c:	00c00284 	movi	r3,10
8111c560:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = (unsigned short int)atoi( inteiro );
8111c564:	e0bff704 	addi	r2,fp,-36
8111c568:	1009883a 	mov	r4,r2
8111c56c:	11234dc0 	call	811234dc <atoi>
8111c570:	1007883a 	mov	r3,r2
8111c574:	00a045f4 	movhi	r2,33047
8111c578:	10a34f04 	addi	r2,r2,-29380
8111c57c:	10c0088d 	sth	r3,34(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c580:	e0bff704 	addi	r2,fp,-36
8111c584:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c588:	e0bff203 	ldbu	r2,-56(fp)
8111c58c:	10800044 	addi	r2,r2,1
8111c590:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c594:	e0bff247 	ldb	r2,-55(fp)
8111c598:	10800ed8 	cmpnei	r2,r2,59
8111c59c:	103fd61e 	bne	r2,zero,8111c4f8 <__reset+0xfb0fc4f8>

						break;
8111c5a0:	00025e06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'L':
						ucParser = 0;
8111c5a4:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c5a8:	e0bff60f 	ldh	r2,-40(fp)
8111c5ac:	1009883a 	mov	r4,r2
8111c5b0:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c5b4:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c5b8:	d0e00317 	ldw	r3,-32756(gp)
8111c5bc:	e0bff247 	ldb	r2,-55(fp)
8111c5c0:	10800044 	addi	r2,r2,1
8111c5c4:	1885883a 	add	r2,r3,r2
8111c5c8:	10800003 	ldbu	r2,0(r2)
8111c5cc:	10803fcc 	andi	r2,r2,255
8111c5d0:	1080010c 	andi	r2,r2,4
8111c5d4:	10000626 	beq	r2,zero,8111c5f0 <vLoadDebugConfs+0x664>
									(*p_inteiro) = c;
8111c5d8:	e0bff317 	ldw	r2,-52(fp)
8111c5dc:	e0fff243 	ldbu	r3,-55(fp)
8111c5e0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c5e4:	e0bff317 	ldw	r2,-52(fp)
8111c5e8:	10800044 	addi	r2,r2,1
8111c5ec:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c5f0:	e0bff247 	ldb	r2,-55(fp)
8111c5f4:	10800ba0 	cmpeqi	r2,r2,46
8111c5f8:	1000031e 	bne	r2,zero,8111c608 <vLoadDebugConfs+0x67c>
8111c5fc:	e0bff247 	ldb	r2,-55(fp)
8111c600:	10800ed8 	cmpnei	r2,r2,59
8111c604:	103fe81e 	bne	r2,zero,8111c5a8 <__reset+0xfb0fc5a8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c608:	e0bff317 	ldw	r2,-52(fp)
8111c60c:	00c00284 	movi	r3,10
8111c610:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = (unsigned short int)atoi( inteiro );
8111c614:	e0bff704 	addi	r2,fp,-36
8111c618:	1009883a 	mov	r4,r2
8111c61c:	11234dc0 	call	811234dc <atoi>
8111c620:	1007883a 	mov	r3,r2
8111c624:	00a045f4 	movhi	r2,33047
8111c628:	10a34f04 	addi	r2,r2,-29380
8111c62c:	10c0030d 	sth	r3,12(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c630:	e0bff704 	addi	r2,fp,-36
8111c634:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c638:	e0bff203 	ldbu	r2,-56(fp)
8111c63c:	10800044 	addi	r2,r2,1
8111c640:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c644:	e0bff247 	ldb	r2,-55(fp)
8111c648:	10800ed8 	cmpnei	r2,r2,59
8111c64c:	103fd61e 	bne	r2,zero,8111c5a8 <__reset+0xfb0fc5a8>

						break;
8111c650:	00023206 	br	8111cf1c <vLoadDebugConfs+0xf90>

					case 'O':
						ucParser = 0;
8111c654:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c658:	e0bff60f 	ldh	r2,-40(fp)
8111c65c:	1009883a 	mov	r4,r2
8111c660:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c664:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c668:	d0e00317 	ldw	r3,-32756(gp)
8111c66c:	e0bff247 	ldb	r2,-55(fp)
8111c670:	10800044 	addi	r2,r2,1
8111c674:	1885883a 	add	r2,r3,r2
8111c678:	10800003 	ldbu	r2,0(r2)
8111c67c:	10803fcc 	andi	r2,r2,255
8111c680:	1080010c 	andi	r2,r2,4
8111c684:	10000626 	beq	r2,zero,8111c6a0 <vLoadDebugConfs+0x714>
									(*p_inteiro) = c;
8111c688:	e0bff317 	ldw	r2,-52(fp)
8111c68c:	e0fff243 	ldbu	r3,-55(fp)
8111c690:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c694:	e0bff317 	ldw	r2,-52(fp)
8111c698:	10800044 	addi	r2,r2,1
8111c69c:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c6a0:	e0bff247 	ldb	r2,-55(fp)
8111c6a4:	10800ba0 	cmpeqi	r2,r2,46
8111c6a8:	1000031e 	bne	r2,zero,8111c6b8 <vLoadDebugConfs+0x72c>
8111c6ac:	e0bff247 	ldb	r2,-55(fp)
8111c6b0:	10800ed8 	cmpnei	r2,r2,59
8111c6b4:	103fe81e 	bne	r2,zero,8111c658 <__reset+0xfb0fc658>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c6b8:	e0bff317 	ldw	r2,-52(fp)
8111c6bc:	00c00284 	movi	r3,10
8111c6c0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = (unsigned short int)atoi( inteiro );
8111c6c4:	e0bff704 	addi	r2,fp,-36
8111c6c8:	1009883a 	mov	r4,r2
8111c6cc:	11234dc0 	call	811234dc <atoi>
8111c6d0:	1007883a 	mov	r3,r2
8111c6d4:	00a045f4 	movhi	r2,33047
8111c6d8:	10a34f04 	addi	r2,r2,-29380
8111c6dc:	10c0020d 	sth	r3,8(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c6e0:	e0bff704 	addi	r2,fp,-36
8111c6e4:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c6e8:	e0bff203 	ldbu	r2,-56(fp)
8111c6ec:	10800044 	addi	r2,r2,1
8111c6f0:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c6f4:	e0bff247 	ldb	r2,-55(fp)
8111c6f8:	10800ed8 	cmpnei	r2,r2,59
8111c6fc:	103fd61e 	bne	r2,zero,8111c658 <__reset+0xfb0fc658>

						break;
8111c700:	00020606 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'C':
						ucParser = 0;
8111c704:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c708:	e0bff60f 	ldh	r2,-40(fp)
8111c70c:	1009883a 	mov	r4,r2
8111c710:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c714:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c718:	d0e00317 	ldw	r3,-32756(gp)
8111c71c:	e0bff247 	ldb	r2,-55(fp)
8111c720:	10800044 	addi	r2,r2,1
8111c724:	1885883a 	add	r2,r3,r2
8111c728:	10800003 	ldbu	r2,0(r2)
8111c72c:	10803fcc 	andi	r2,r2,255
8111c730:	1080010c 	andi	r2,r2,4
8111c734:	10000626 	beq	r2,zero,8111c750 <vLoadDebugConfs+0x7c4>
									(*p_inteiro) = c;
8111c738:	e0bff317 	ldw	r2,-52(fp)
8111c73c:	e0fff243 	ldbu	r3,-55(fp)
8111c740:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c744:	e0bff317 	ldw	r2,-52(fp)
8111c748:	10800044 	addi	r2,r2,1
8111c74c:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c750:	e0bff247 	ldb	r2,-55(fp)
8111c754:	10800ba0 	cmpeqi	r2,r2,46
8111c758:	1000031e 	bne	r2,zero,8111c768 <vLoadDebugConfs+0x7dc>
8111c75c:	e0bff247 	ldb	r2,-55(fp)
8111c760:	10800ed8 	cmpnei	r2,r2,59
8111c764:	103fe81e 	bne	r2,zero,8111c708 <__reset+0xfb0fc708>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c768:	e0bff317 	ldw	r2,-52(fp)
8111c76c:	00c00284 	movi	r3,10
8111c770:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = (unsigned short int)atoi( inteiro );
8111c774:	e0bff704 	addi	r2,fp,-36
8111c778:	1009883a 	mov	r4,r2
8111c77c:	11234dc0 	call	811234dc <atoi>
8111c780:	1007883a 	mov	r3,r2
8111c784:	00a045f4 	movhi	r2,33047
8111c788:	10a34f04 	addi	r2,r2,-29380
8111c78c:	10c0028d 	sth	r3,10(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c790:	e0bff704 	addi	r2,fp,-36
8111c794:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c798:	e0bff203 	ldbu	r2,-56(fp)
8111c79c:	10800044 	addi	r2,r2,1
8111c7a0:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c7a4:	e0bff247 	ldb	r2,-55(fp)
8111c7a8:	10800ed8 	cmpnei	r2,r2,59
8111c7ac:	103fd61e 	bne	r2,zero,8111c708 <__reset+0xfb0fc708>

						break;
8111c7b0:	0001da06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111c7b4:	e0bff60f 	ldh	r2,-40(fp)
8111c7b8:	1009883a 	mov	r4,r2
8111c7bc:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c7c0:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c7c4:	d0e00317 	ldw	r3,-32756(gp)
8111c7c8:	e0bff247 	ldb	r2,-55(fp)
8111c7cc:	10800044 	addi	r2,r2,1
8111c7d0:	1885883a 	add	r2,r3,r2
8111c7d4:	10800003 	ldbu	r2,0(r2)
8111c7d8:	10803fcc 	andi	r2,r2,255
8111c7dc:	1080010c 	andi	r2,r2,4
8111c7e0:	10000626 	beq	r2,zero,8111c7fc <vLoadDebugConfs+0x870>
								(*p_inteiroll) = c;
8111c7e4:	e0bff417 	ldw	r2,-48(fp)
8111c7e8:	e0fff243 	ldbu	r3,-55(fp)
8111c7ec:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8111c7f0:	e0bff417 	ldw	r2,-48(fp)
8111c7f4:	10800044 	addi	r2,r2,1
8111c7f8:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c7fc:	e0bff247 	ldb	r2,-55(fp)
8111c800:	10800ed8 	cmpnei	r2,r2,59
8111c804:	103feb1e 	bne	r2,zero,8111c7b4 <__reset+0xfb0fc7b4>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c808:	e0bff417 	ldw	r2,-48(fp)
8111c80c:	00c00284 	movi	r3,10
8111c810:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = (unsigned long)atoll( inteiroll );
8111c814:	e0bff904 	addi	r2,fp,-28
8111c818:	1009883a 	mov	r4,r2
8111c81c:	11234f40 	call	811234f4 <atoll>
8111c820:	1009883a 	mov	r4,r2
8111c824:	180b883a 	mov	r5,r3
8111c828:	2007883a 	mov	r3,r4
8111c82c:	00a045f4 	movhi	r2,33047
8111c830:	10a34f04 	addi	r2,r2,-29380
8111c834:	10c00615 	stw	r3,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8111c838:	e0bff904 	addi	r2,fp,-28
8111c83c:	e0bff415 	stw	r2,-48(fp)

						break;
8111c840:	0001b606 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111c844:	e0bff60f 	ldh	r2,-40(fp)
8111c848:	1009883a 	mov	r4,r2
8111c84c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c850:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c854:	d0e00317 	ldw	r3,-32756(gp)
8111c858:	e0bff247 	ldb	r2,-55(fp)
8111c85c:	10800044 	addi	r2,r2,1
8111c860:	1885883a 	add	r2,r3,r2
8111c864:	10800003 	ldbu	r2,0(r2)
8111c868:	10803fcc 	andi	r2,r2,255
8111c86c:	1080010c 	andi	r2,r2,4
8111c870:	10000626 	beq	r2,zero,8111c88c <vLoadDebugConfs+0x900>
								(*p_inteiroll) = c;
8111c874:	e0bff417 	ldw	r2,-48(fp)
8111c878:	e0fff243 	ldbu	r3,-55(fp)
8111c87c:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8111c880:	e0bff417 	ldw	r2,-48(fp)
8111c884:	10800044 	addi	r2,r2,1
8111c888:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c88c:	e0bff247 	ldb	r2,-55(fp)
8111c890:	10800ed8 	cmpnei	r2,r2,59
8111c894:	103feb1e 	bne	r2,zero,8111c844 <__reset+0xfb0fc844>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c898:	e0bff417 	ldw	r2,-48(fp)
8111c89c:	00c00284 	movi	r3,10
8111c8a0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = (unsigned long)atoll( inteiroll );
8111c8a4:	e0bff904 	addi	r2,fp,-28
8111c8a8:	1009883a 	mov	r4,r2
8111c8ac:	11234f40 	call	811234f4 <atoll>
8111c8b0:	1009883a 	mov	r4,r2
8111c8b4:	180b883a 	mov	r5,r3
8111c8b8:	2007883a 	mov	r3,r4
8111c8bc:	00a045f4 	movhi	r2,33047
8111c8c0:	10a34f04 	addi	r2,r2,-29380
8111c8c4:	10c00715 	stw	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8111c8c8:	e0bff904 	addi	r2,fp,-28
8111c8cc:	e0bff415 	stw	r2,-48(fp)

						break;
8111c8d0:	00019206 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111c8d4:	e0bff60f 	ldh	r2,-40(fp)
8111c8d8:	1009883a 	mov	r4,r2
8111c8dc:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c8e0:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c8e4:	d0e00317 	ldw	r3,-32756(gp)
8111c8e8:	e0bff247 	ldb	r2,-55(fp)
8111c8ec:	10800044 	addi	r2,r2,1
8111c8f0:	1885883a 	add	r2,r3,r2
8111c8f4:	10800003 	ldbu	r2,0(r2)
8111c8f8:	10803fcc 	andi	r2,r2,255
8111c8fc:	1080010c 	andi	r2,r2,4
8111c900:	10000626 	beq	r2,zero,8111c91c <vLoadDebugConfs+0x990>
								(*p_inteiroll) = c;
8111c904:	e0bff417 	ldw	r2,-48(fp)
8111c908:	e0fff243 	ldbu	r3,-55(fp)
8111c90c:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8111c910:	e0bff417 	ldw	r2,-48(fp)
8111c914:	10800044 	addi	r2,r2,1
8111c918:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c91c:	e0bff247 	ldb	r2,-55(fp)
8111c920:	10800ed8 	cmpnei	r2,r2,59
8111c924:	103feb1e 	bne	r2,zero,8111c8d4 <__reset+0xfb0fc8d4>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c928:	e0bff417 	ldw	r2,-48(fp)
8111c92c:	00c00284 	movi	r3,10
8111c930:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = (unsigned long)atoll( inteiroll );
8111c934:	e0bff904 	addi	r2,fp,-28
8111c938:	1009883a 	mov	r4,r2
8111c93c:	11234f40 	call	811234f4 <atoll>
8111c940:	1009883a 	mov	r4,r2
8111c944:	180b883a 	mov	r5,r3
8111c948:	2007883a 	mov	r3,r4
8111c94c:	00a045f4 	movhi	r2,33047
8111c950:	10a34f04 	addi	r2,r2,-29380
8111c954:	10c00515 	stw	r3,20(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8111c958:	e0bff904 	addi	r2,fp,-28
8111c95c:	e0bff415 	stw	r2,-48(fp)

						break;
8111c960:	00016e06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8111c964:	e0bff60f 	ldh	r2,-40(fp)
8111c968:	1009883a 	mov	r4,r2
8111c96c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c970:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c974:	d0e00317 	ldw	r3,-32756(gp)
8111c978:	e0bff247 	ldb	r2,-55(fp)
8111c97c:	10800044 	addi	r2,r2,1
8111c980:	1885883a 	add	r2,r3,r2
8111c984:	10800003 	ldbu	r2,0(r2)
8111c988:	10803fcc 	andi	r2,r2,255
8111c98c:	1080010c 	andi	r2,r2,4
8111c990:	10000626 	beq	r2,zero,8111c9ac <vLoadDebugConfs+0xa20>
								(*p_inteiro) = c;
8111c994:	e0bff317 	ldw	r2,-52(fp)
8111c998:	e0fff243 	ldbu	r3,-55(fp)
8111c99c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c9a0:	e0bff317 	ldw	r2,-52(fp)
8111c9a4:	10800044 	addi	r2,r2,1
8111c9a8:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c9ac:	e0bff247 	ldb	r2,-55(fp)
8111c9b0:	10800ed8 	cmpnei	r2,r2,59
8111c9b4:	103feb1e 	bne	r2,zero,8111c964 <__reset+0xfb0fc964>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c9b8:	e0bff317 	ldw	r2,-52(fp)
8111c9bc:	00c00284 	movi	r3,10
8111c9c0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = (unsigned short int)atoi( inteiro );
8111c9c4:	e0bff704 	addi	r2,fp,-36
8111c9c8:	1009883a 	mov	r4,r2
8111c9cc:	11234dc0 	call	811234dc <atoi>
8111c9d0:	1007883a 	mov	r3,r2
8111c9d4:	00a045f4 	movhi	r2,33047
8111c9d8:	10a34f04 	addi	r2,r2,-29380
8111c9dc:	10c00a0d 	sth	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c9e0:	e0bff704 	addi	r2,fp,-36
8111c9e4:	e0bff315 	stw	r2,-52(fp)

						break;
8111c9e8:	00014c06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'F':

						do {
							c = cGetNextChar(siFile);
8111c9ec:	e0bff60f 	ldh	r2,-40(fp)
8111c9f0:	1009883a 	mov	r4,r2
8111c9f4:	1120ce40 	call	81120ce4 <cGetNextChar>
8111c9f8:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c9fc:	d0e00317 	ldw	r3,-32756(gp)
8111ca00:	e0bff247 	ldb	r2,-55(fp)
8111ca04:	10800044 	addi	r2,r2,1
8111ca08:	1885883a 	add	r2,r3,r2
8111ca0c:	10800003 	ldbu	r2,0(r2)
8111ca10:	10803fcc 	andi	r2,r2,255
8111ca14:	1080010c 	andi	r2,r2,4
8111ca18:	10000626 	beq	r2,zero,8111ca34 <vLoadDebugConfs+0xaa8>
								(*p_inteiro) = c;
8111ca1c:	e0bff317 	ldw	r2,-52(fp)
8111ca20:	e0fff243 	ldbu	r3,-55(fp)
8111ca24:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ca28:	e0bff317 	ldw	r2,-52(fp)
8111ca2c:	10800044 	addi	r2,r2,1
8111ca30:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ca34:	e0bff247 	ldb	r2,-55(fp)
8111ca38:	10800ed8 	cmpnei	r2,r2,59
8111ca3c:	103feb1e 	bne	r2,zero,8111c9ec <__reset+0xfb0fc9ec>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ca40:	e0bff317 	ldw	r2,-52(fp)
8111ca44:	00c00284 	movi	r3,10
8111ca48:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDebugLevel = (unsigned short int)atoi( inteiro );
8111ca4c:	e0bff704 	addi	r2,fp,-36
8111ca50:	1009883a 	mov	r4,r2
8111ca54:	11234dc0 	call	811234dc <atoi>
8111ca58:	1007883a 	mov	r3,r2
8111ca5c:	00a045f4 	movhi	r2,33047
8111ca60:	10a34f04 	addi	r2,r2,-29380
8111ca64:	10c00a8d 	sth	r3,42(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ca68:	e0bff704 	addi	r2,fp,-36
8111ca6c:	e0bff315 	stw	r2,-52(fp)

						break;
8111ca70:	00012a06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'Q':

						do {
							c = cGetNextChar(siFile);
8111ca74:	e0bff60f 	ldh	r2,-40(fp)
8111ca78:	1009883a 	mov	r4,r2
8111ca7c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111ca80:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111ca84:	d0e00317 	ldw	r3,-32756(gp)
8111ca88:	e0bff247 	ldb	r2,-55(fp)
8111ca8c:	10800044 	addi	r2,r2,1
8111ca90:	1885883a 	add	r2,r3,r2
8111ca94:	10800003 	ldbu	r2,0(r2)
8111ca98:	10803fcc 	andi	r2,r2,255
8111ca9c:	1080010c 	andi	r2,r2,4
8111caa0:	10000626 	beq	r2,zero,8111cabc <vLoadDebugConfs+0xb30>
								(*p_inteiro) = c;
8111caa4:	e0bff317 	ldw	r2,-52(fp)
8111caa8:	e0fff243 	ldbu	r3,-55(fp)
8111caac:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111cab0:	e0bff317 	ldw	r2,-52(fp)
8111cab4:	10800044 	addi	r2,r2,1
8111cab8:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111cabc:	e0bff247 	ldb	r2,-55(fp)
8111cac0:	10800ed8 	cmpnei	r2,r2,59
8111cac4:	103feb1e 	bne	r2,zero,8111ca74 <__reset+0xfb0fca74>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111cac8:	e0bff317 	ldw	r2,-52(fp)
8111cacc:	00c00284 	movi	r3,10
8111cad0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiPatternType = (unsigned short int)atoi( inteiro );
8111cad4:	e0bff704 	addi	r2,fp,-36
8111cad8:	1009883a 	mov	r4,r2
8111cadc:	11234dc0 	call	811234dc <atoi>
8111cae0:	1007883a 	mov	r3,r2
8111cae4:	00a045f4 	movhi	r2,33047
8111cae8:	10a34f04 	addi	r2,r2,-29380
8111caec:	10c00b0d 	sth	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111caf0:	e0bff704 	addi	r2,fp,-36
8111caf4:	e0bff315 	stw	r2,-52(fp)

						break;
8111caf8:	00010806 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'Y':

						do {
							c = cGetNextChar(siFile);
8111cafc:	e0bff60f 	ldh	r2,-40(fp)
8111cb00:	1009883a 	mov	r4,r2
8111cb04:	1120ce40 	call	81120ce4 <cGetNextChar>
8111cb08:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111cb0c:	d0e00317 	ldw	r3,-32756(gp)
8111cb10:	e0bff247 	ldb	r2,-55(fp)
8111cb14:	10800044 	addi	r2,r2,1
8111cb18:	1885883a 	add	r2,r3,r2
8111cb1c:	10800003 	ldbu	r2,0(r2)
8111cb20:	10803fcc 	andi	r2,r2,255
8111cb24:	1080010c 	andi	r2,r2,4
8111cb28:	10000626 	beq	r2,zero,8111cb44 <vLoadDebugConfs+0xbb8>
								(*p_inteiro) = c;
8111cb2c:	e0bff317 	ldw	r2,-52(fp)
8111cb30:	e0fff243 	ldbu	r3,-55(fp)
8111cb34:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111cb38:	e0bff317 	ldw	r2,-52(fp)
8111cb3c:	10800044 	addi	r2,r2,1
8111cb40:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111cb44:	e0bff247 	ldb	r2,-55(fp)
8111cb48:	10800ed8 	cmpnei	r2,r2,59
8111cb4c:	103feb1e 	bne	r2,zero,8111cafc <__reset+0xfb0fcafc>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111cb50:	e0bff317 	ldw	r2,-52(fp)
8111cb54:	00c00284 	movi	r3,10
8111cb58:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiGuardNFEEDelay = (unsigned short int)atoi( inteiro );
8111cb5c:	e0bff704 	addi	r2,fp,-36
8111cb60:	1009883a 	mov	r4,r2
8111cb64:	11234dc0 	call	811234dc <atoi>
8111cb68:	1007883a 	mov	r3,r2
8111cb6c:	00a045f4 	movhi	r2,33047
8111cb70:	10a34f04 	addi	r2,r2,-29380
8111cb74:	10c00b8d 	sth	r3,46(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111cb78:	e0bff704 	addi	r2,fp,-36
8111cb7c:	e0bff315 	stw	r2,-52(fp)

						break;
8111cb80:	0000e606 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111cb84:	e0bff60f 	ldh	r2,-40(fp)
8111cb88:	1009883a 	mov	r4,r2
8111cb8c:	1120ce40 	call	81120ce4 <cGetNextChar>
8111cb90:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111cb94:	d0e00317 	ldw	r3,-32756(gp)
8111cb98:	e0bff247 	ldb	r2,-55(fp)
8111cb9c:	10800044 	addi	r2,r2,1
8111cba0:	1885883a 	add	r2,r3,r2
8111cba4:	10800003 	ldbu	r2,0(r2)
8111cba8:	10803fcc 	andi	r2,r2,255
8111cbac:	1080010c 	andi	r2,r2,4
8111cbb0:	10000626 	beq	r2,zero,8111cbcc <vLoadDebugConfs+0xc40>
								(*p_inteiro) = c;
8111cbb4:	e0bff317 	ldw	r2,-52(fp)
8111cbb8:	e0fff243 	ldbu	r3,-55(fp)
8111cbbc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111cbc0:	e0bff317 	ldw	r2,-52(fp)
8111cbc4:	10800044 	addi	r2,r2,1
8111cbc8:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111cbcc:	e0bff247 	ldb	r2,-55(fp)
8111cbd0:	10800ed8 	cmpnei	r2,r2,59
8111cbd4:	103feb1e 	bne	r2,zero,8111cb84 <__reset+0xfb0fcb84>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111cbd8:	e0bff317 	ldw	r2,-52(fp)
8111cbdc:	00c00284 	movi	r3,10
8111cbe0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDataProtId = (unsigned short int)atoi( inteiro );
8111cbe4:	e0bff704 	addi	r2,fp,-36
8111cbe8:	1009883a 	mov	r4,r2
8111cbec:	11234dc0 	call	811234dc <atoi>
8111cbf0:	1007883a 	mov	r3,r2
8111cbf4:	00a045f4 	movhi	r2,33047
8111cbf8:	10a34f04 	addi	r2,r2,-29380
8111cbfc:	10c00c0d 	sth	r3,48(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111cc00:	e0bff704 	addi	r2,fp,-36
8111cc04:	e0bff315 	stw	r2,-52(fp)

						break;
8111cc08:	0000c406 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111cc0c:	e0bff60f 	ldh	r2,-40(fp)
8111cc10:	1009883a 	mov	r4,r2
8111cc14:	1120ce40 	call	81120ce4 <cGetNextChar>
8111cc18:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111cc1c:	d0e00317 	ldw	r3,-32756(gp)
8111cc20:	e0bff247 	ldb	r2,-55(fp)
8111cc24:	10800044 	addi	r2,r2,1
8111cc28:	1885883a 	add	r2,r3,r2
8111cc2c:	10800003 	ldbu	r2,0(r2)
8111cc30:	10803fcc 	andi	r2,r2,255
8111cc34:	1080010c 	andi	r2,r2,4
8111cc38:	10000626 	beq	r2,zero,8111cc54 <vLoadDebugConfs+0xcc8>
								(*p_inteiro) = c;
8111cc3c:	e0bff317 	ldw	r2,-52(fp)
8111cc40:	e0fff243 	ldbu	r3,-55(fp)
8111cc44:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111cc48:	e0bff317 	ldw	r2,-52(fp)
8111cc4c:	10800044 	addi	r2,r2,1
8111cc50:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111cc54:	e0bff247 	ldb	r2,-55(fp)
8111cc58:	10800ed8 	cmpnei	r2,r2,59
8111cc5c:	103feb1e 	bne	r2,zero,8111cc0c <__reset+0xfb0fcc0c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111cc60:	e0bff317 	ldw	r2,-52(fp)
8111cc64:	00c00284 	movi	r3,10
8111cc68:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDpuLogicalAddr = (unsigned short int)atoi( inteiro );
8111cc6c:	e0bff704 	addi	r2,fp,-36
8111cc70:	1009883a 	mov	r4,r2
8111cc74:	11234dc0 	call	811234dc <atoi>
8111cc78:	1007883a 	mov	r3,r2
8111cc7c:	00a045f4 	movhi	r2,33047
8111cc80:	10a34f04 	addi	r2,r2,-29380
8111cc84:	10c00c8d 	sth	r3,50(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111cc88:	e0bff704 	addi	r2,fp,-36
8111cc8c:	e0bff315 	stw	r2,-52(fp)

						break;
8111cc90:	0000a206 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'E':

						ucParser = 0;
8111cc94:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111cc98:	e0bff60f 	ldh	r2,-40(fp)
8111cc9c:	1009883a 	mov	r4,r2
8111cca0:	1120ce40 	call	81120ce4 <cGetNextChar>
8111cca4:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111cca8:	d0e00317 	ldw	r3,-32756(gp)
8111ccac:	e0bff247 	ldb	r2,-55(fp)
8111ccb0:	10800044 	addi	r2,r2,1
8111ccb4:	1885883a 	add	r2,r3,r2
8111ccb8:	10800003 	ldbu	r2,0(r2)
8111ccbc:	10803fcc 	andi	r2,r2,255
8111ccc0:	1080010c 	andi	r2,r2,4
8111ccc4:	10000626 	beq	r2,zero,8111cce0 <vLoadDebugConfs+0xd54>
									(*p_inteiro) = c;
8111ccc8:	e0bff317 	ldw	r2,-52(fp)
8111cccc:	e0fff243 	ldbu	r3,-55(fp)
8111ccd0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ccd4:	e0bff317 	ldw	r2,-52(fp)
8111ccd8:	10800044 	addi	r2,r2,1
8111ccdc:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111cce0:	e0bff247 	ldb	r2,-55(fp)
8111cce4:	10800ba0 	cmpeqi	r2,r2,46
8111cce8:	1000031e 	bne	r2,zero,8111ccf8 <vLoadDebugConfs+0xd6c>
8111ccec:	e0bff247 	ldb	r2,-55(fp)
8111ccf0:	10800ed8 	cmpnei	r2,r2,59
8111ccf4:	103fe81e 	bne	r2,zero,8111cc98 <__reset+0xfb0fcc98>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ccf8:	e0bff317 	ldw	r2,-52(fp)
8111ccfc:	00c00284 	movi	r3,10
8111cd00:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucReadOutOrder[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111cd04:	e0bff203 	ldbu	r2,-56(fp)
8111cd08:	108000e8 	cmpgeui	r2,r2,3
8111cd0c:	1000021e 	bne	r2,zero,8111cd18 <vLoadDebugConfs+0xd8c>
8111cd10:	e43ff203 	ldbu	r16,-56(fp)
8111cd14:	00000106 	br	8111cd1c <vLoadDebugConfs+0xd90>
8111cd18:	040000c4 	movi	r16,3
8111cd1c:	e0bff704 	addi	r2,fp,-36
8111cd20:	1009883a 	mov	r4,r2
8111cd24:	11234dc0 	call	811234dc <atoi>
8111cd28:	1007883a 	mov	r3,r2
8111cd2c:	00a045f4 	movhi	r2,33047
8111cd30:	10a34f04 	addi	r2,r2,-29380
8111cd34:	1405883a 	add	r2,r2,r16
8111cd38:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111cd3c:	e0bff704 	addi	r2,fp,-36
8111cd40:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111cd44:	e0bff203 	ldbu	r2,-56(fp)
8111cd48:	10800044 	addi	r2,r2,1
8111cd4c:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111cd50:	e0bff247 	ldb	r2,-55(fp)
8111cd54:	10800ed8 	cmpnei	r2,r2,59
8111cd58:	103fcf1e 	bne	r2,zero,8111cc98 <__reset+0xfb0fcc98>

						break;
8111cd5c:	00006f06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111cd60:	e0bff60f 	ldh	r2,-40(fp)
8111cd64:	1009883a 	mov	r4,r2
8111cd68:	1120ce40 	call	81120ce4 <cGetNextChar>
8111cd6c:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111cd70:	d0e00317 	ldw	r3,-32756(gp)
8111cd74:	e0bff247 	ldb	r2,-55(fp)
8111cd78:	10800044 	addi	r2,r2,1
8111cd7c:	1885883a 	add	r2,r3,r2
8111cd80:	10800003 	ldbu	r2,0(r2)
8111cd84:	10803fcc 	andi	r2,r2,255
8111cd88:	1080010c 	andi	r2,r2,4
8111cd8c:	10000626 	beq	r2,zero,8111cda8 <vLoadDebugConfs+0xe1c>
								(*p_inteiro) = c;
8111cd90:	e0bff317 	ldw	r2,-52(fp)
8111cd94:	e0fff243 	ldbu	r3,-55(fp)
8111cd98:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111cd9c:	e0bff317 	ldw	r2,-52(fp)
8111cda0:	10800044 	addi	r2,r2,1
8111cda4:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111cda8:	e0bff247 	ldb	r2,-55(fp)
8111cdac:	10800ed8 	cmpnei	r2,r2,59
8111cdb0:	103feb1e 	bne	r2,zero,8111cd60 <__reset+0xfb0fcd60>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111cdb4:	e0bff317 	ldw	r2,-52(fp)
8111cdb8:	00c00284 	movi	r3,10
8111cdbc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111cdc0:	e0bff704 	addi	r2,fp,-36
8111cdc4:	1009883a 	mov	r4,r2
8111cdc8:	11234dc0 	call	811234dc <atoi>
8111cdcc:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111cdd0:	e0bff68f 	ldh	r2,-38(fp)
8111cdd4:	10800058 	cmpnei	r2,r2,1
8111cdd8:	1000051e 	bne	r2,zero,8111cdf0 <vLoadDebugConfs+0xe64>
							xDefaults.bDataPacket = TRUE;
8111cddc:	00a045f4 	movhi	r2,33047
8111cde0:	10a34f04 	addi	r2,r2,-29380
8111cde4:	00c00044 	movi	r3,1
8111cde8:	10c00415 	stw	r3,16(r2)
8111cdec:	00000306 	br	8111cdfc <vLoadDebugConfs+0xe70>
						else
							xDefaults.bDataPacket = FALSE;
8111cdf0:	00a045f4 	movhi	r2,33047
8111cdf4:	10a34f04 	addi	r2,r2,-29380
8111cdf8:	10000415 	stw	zero,16(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111cdfc:	e0bff704 	addi	r2,fp,-36
8111ce00:	e0bff315 	stw	r2,-52(fp)

						break;
8111ce04:	00004506 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8111ce08:	e0bff60f 	ldh	r2,-40(fp)
8111ce0c:	1009883a 	mov	r4,r2
8111ce10:	1120ce40 	call	81120ce4 <cGetNextChar>
8111ce14:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111ce18:	d0e00317 	ldw	r3,-32756(gp)
8111ce1c:	e0bff247 	ldb	r2,-55(fp)
8111ce20:	10800044 	addi	r2,r2,1
8111ce24:	1885883a 	add	r2,r3,r2
8111ce28:	10800003 	ldbu	r2,0(r2)
8111ce2c:	10803fcc 	andi	r2,r2,255
8111ce30:	1080010c 	andi	r2,r2,4
8111ce34:	10000626 	beq	r2,zero,8111ce50 <vLoadDebugConfs+0xec4>
								(*p_inteiro) = c;
8111ce38:	e0bff317 	ldw	r2,-52(fp)
8111ce3c:	e0fff243 	ldbu	r3,-55(fp)
8111ce40:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ce44:	e0bff317 	ldw	r2,-52(fp)
8111ce48:	10800044 	addi	r2,r2,1
8111ce4c:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ce50:	e0bff247 	ldb	r2,-55(fp)
8111ce54:	10800ed8 	cmpnei	r2,r2,59
8111ce58:	103feb1e 	bne	r2,zero,8111ce08 <__reset+0xfb0fce08>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ce5c:	e0bff317 	ldw	r2,-52(fp)
8111ce60:	00c00284 	movi	r3,10
8111ce64:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111ce68:	e0bff704 	addi	r2,fp,-36
8111ce6c:	1009883a 	mov	r4,r2
8111ce70:	11234dc0 	call	811234dc <atoi>
8111ce74:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111ce78:	e0bff68f 	ldh	r2,-38(fp)
8111ce7c:	10800058 	cmpnei	r2,r2,1
8111ce80:	1000051e 	bne	r2,zero,8111ce98 <vLoadDebugConfs+0xf0c>
							xDefaults.bOneShot = TRUE;
8111ce84:	00a045f4 	movhi	r2,33047
8111ce88:	10a34f04 	addi	r2,r2,-29380
8111ce8c:	00c00044 	movi	r3,1
8111ce90:	10c00915 	stw	r3,36(r2)
8111ce94:	00000306 	br	8111cea4 <vLoadDebugConfs+0xf18>
						else
							xDefaults.bOneShot = FALSE;
8111ce98:	00a045f4 	movhi	r2,33047
8111ce9c:	10a34f04 	addi	r2,r2,-29380
8111cea0:	10000915 	stw	zero,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111cea4:	e0bff704 	addi	r2,fp,-36
8111cea8:	e0bff315 	stw	r2,-52(fp)

						break;
8111ceac:	00001b06 	br	8111cf1c <vLoadDebugConfs+0xf90>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111ceb0:	e0bff60f 	ldh	r2,-40(fp)
8111ceb4:	1009883a 	mov	r4,r2
8111ceb8:	1120ca40 	call	81120ca4 <siCloseFile>
8111cebc:	e0bff515 	stw	r2,-44(fp)
						if (close == FALSE){
8111cec0:	e0bff517 	ldw	r2,-44(fp)
8111cec4:	1000071e 	bne	r2,zero,8111cee4 <vLoadDebugConfs+0xf58>
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111cec8:	d0a06217 	ldw	r2,-32376(gp)
8111cecc:	100f883a 	mov	r7,r2
8111ced0:	01800784 	movi	r6,30
8111ced4:	01400044 	movi	r5,1
8111ced8:	01204574 	movhi	r4,33045
8111cedc:	2102fb04 	addi	r4,r4,3052
8111cee0:	1123cec0 	call	81123cec <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111cee4:	00800044 	movi	r2,1
8111cee8:	e0bff115 	stw	r2,-60(fp)
						bSuccess = TRUE; //pensar melhor
8111ceec:	00800044 	movi	r2,1
8111cef0:	e0bff015 	stw	r2,-64(fp)
						break;
8111cef4:	00000906 	br	8111cf1c <vLoadDebugConfs+0xf90>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser. (%hhu)\n",c);
8111cef8:	d0a06217 	ldw	r2,-32376(gp)
8111cefc:	e0fff247 	ldb	r3,-55(fp)
8111cf00:	180d883a 	mov	r6,r3
8111cf04:	01604574 	movhi	r5,33045
8111cf08:	29434b04 	addi	r5,r5,3372
8111cf0c:	1009883a 	mov	r4,r2
8111cf10:	11236500 	call	81123650 <fprintf>
						#endif
						break;
8111cf14:	00000106 	br	8111cf1c <vLoadDebugConfs+0xf90>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111cf18:	0001883a 	nop
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser. (%hhu)\n",c);
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111cf1c:	e0bff117 	ldw	r2,-60(fp)
8111cf20:	103c3f26 	beq	r2,zero,8111c020 <__reset+0xfb0fc020>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111cf24:	00000f06 	br	8111cf64 <vLoadDebugConfs+0xfd8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111cf28:	d0a06217 	ldw	r2,-32376(gp)
8111cf2c:	100f883a 	mov	r7,r2
8111cf30:	01800604 	movi	r6,24
8111cf34:	01400044 	movi	r5,1
8111cf38:	01204574 	movhi	r4,33045
8111cf3c:	21030c04 	addi	r4,r4,3120
8111cf40:	1123cec0 	call	81123cec <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111cf44:	00000706 	br	8111cf64 <vLoadDebugConfs+0xfd8>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#if DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111cf48:	d0a06217 	ldw	r2,-32376(gp)
8111cf4c:	100f883a 	mov	r7,r2
8111cf50:	018004c4 	movi	r6,19
8111cf54:	01400044 	movi	r5,1
8111cf58:	01204574 	movhi	r4,33045
8111cf5c:	21031304 	addi	r4,r4,3148
8111cf60:	1123cec0 	call	81123cec <fwrite>
	if ( bSuccess == FALSE ) {
		/* Load default? */

	}

	return bSuccess;
8111cf64:	e0bff017 	ldw	r2,-64(fp)
}
8111cf68:	e6ffff04 	addi	sp,fp,-4
8111cf6c:	dfc00217 	ldw	ra,8(sp)
8111cf70:	df000117 	ldw	fp,4(sp)
8111cf74:	dc000017 	ldw	r16,0(sp)
8111cf78:	dec00304 	addi	sp,sp,12
8111cf7c:	f800283a 	ret

8111cf80 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111cf80:	defffb04 	addi	sp,sp,-20
8111cf84:	de00012e 	bgeu	sp,et,8111cf8c <ucCrc8+0xc>
8111cf88:	003b68fa 	trap	3
8111cf8c:	df000415 	stw	fp,16(sp)
8111cf90:	df000404 	addi	fp,sp,16
8111cf94:	e13ffd15 	stw	r4,-12(fp)
8111cf98:	e17ffe15 	stw	r5,-8(fp)
8111cf9c:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111cfa0:	e0bffe17 	ldw	r2,-8(fp)
8111cfa4:	1000021e 	bne	r2,zero,8111cfb0 <ucCrc8+0x30>
        return 0;
8111cfa8:	0005883a 	mov	r2,zero
8111cfac:	00001906 	br	8111d014 <ucCrc8+0x94>
    crc &= 0xff;
8111cfb0:	e0bffd17 	ldw	r2,-12(fp)
8111cfb4:	10803fcc 	andi	r2,r2,255
8111cfb8:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111cfbc:	e0fffe17 	ldw	r3,-8(fp)
8111cfc0:	e0bfff17 	ldw	r2,-4(fp)
8111cfc4:	1885883a 	add	r2,r3,r2
8111cfc8:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111cfcc:	00000d06 	br	8111d004 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111cfd0:	e0bffe17 	ldw	r2,-8(fp)
8111cfd4:	10c00044 	addi	r3,r2,1
8111cfd8:	e0fffe15 	stw	r3,-8(fp)
8111cfdc:	10800003 	ldbu	r2,0(r2)
8111cfe0:	10c03fcc 	andi	r3,r2,255
8111cfe4:	e0bffd17 	ldw	r2,-12(fp)
8111cfe8:	1886f03a 	xor	r3,r3,r2
8111cfec:	00a04574 	movhi	r2,33045
8111cff0:	10835544 	addi	r2,r2,3413
8111cff4:	10c5883a 	add	r2,r2,r3
8111cff8:	10800003 	ldbu	r2,0(r2)
8111cffc:	10803fcc 	andi	r2,r2,255
8111d000:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111d004:	e0fffe17 	ldw	r3,-8(fp)
8111d008:	e0bffc17 	ldw	r2,-16(fp)
8111d00c:	18bff036 	bltu	r3,r2,8111cfd0 <__reset+0xfb0fcfd0>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111d010:	e0bffd17 	ldw	r2,-12(fp)
}
8111d014:	e037883a 	mov	sp,fp
8111d018:	df000017 	ldw	fp,0(sp)
8111d01c:	dec00104 	addi	sp,sp,4
8111d020:	f800283a 	ret

8111d024 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111d024:	defffb04 	addi	sp,sp,-20
8111d028:	de00012e 	bgeu	sp,et,8111d030 <ucCrc8wInit+0xc>
8111d02c:	003b68fa 	trap	3
8111d030:	dfc00415 	stw	ra,16(sp)
8111d034:	df000315 	stw	fp,12(sp)
8111d038:	df000304 	addi	fp,sp,12
8111d03c:	e13ffe15 	stw	r4,-8(fp)
8111d040:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111d044:	000d883a 	mov	r6,zero
8111d048:	000b883a 	mov	r5,zero
8111d04c:	0009883a 	mov	r4,zero
8111d050:	111cf800 	call	8111cf80 <ucCrc8>
8111d054:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111d058:	e0bffd03 	ldbu	r2,-12(fp)
8111d05c:	e1bfff17 	ldw	r6,-4(fp)
8111d060:	e17ffe17 	ldw	r5,-8(fp)
8111d064:	1009883a 	mov	r4,r2
8111d068:	111cf800 	call	8111cf80 <ucCrc8>
}
8111d06c:	e037883a 	mov	sp,fp
8111d070:	dfc00117 	ldw	ra,4(sp)
8111d074:	df000017 	ldw	fp,0(sp)
8111d078:	dec00204 	addi	sp,sp,8
8111d07c:	f800283a 	ret

8111d080 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111d080:	defffc04 	addi	sp,sp,-16
8111d084:	de00012e 	bgeu	sp,et,8111d08c <vDataControllerInit+0xc>
8111d088:	003b68fa 	trap	3
8111d08c:	df000315 	stw	fp,12(sp)
8111d090:	df000304 	addi	fp,sp,12
8111d094:	e13ffe15 	stw	r4,-8(fp)
8111d098:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111d09c:	e0bffe17 	ldw	r2,-8(fp)
8111d0a0:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111d0a4:	e03ffd05 	stb	zero,-12(fp)
8111d0a8:	00001c06 	br	8111d11c <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111d0ac:	e0bffd03 	ldbu	r2,-12(fp)
8111d0b0:	e0fffd03 	ldbu	r3,-12(fp)
8111d0b4:	18c09824 	muli	r3,r3,608
8111d0b8:	e13fff17 	ldw	r4,-4(fp)
8111d0bc:	20c7883a 	add	r3,r4,r3
8111d0c0:	e13ffe17 	ldw	r4,-8(fp)
8111d0c4:	10800084 	addi	r2,r2,2
8111d0c8:	1085883a 	add	r2,r2,r2
8111d0cc:	1085883a 	add	r2,r2,r2
8111d0d0:	2085883a 	add	r2,r4,r2
8111d0d4:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111d0d8:	e17ffd03 	ldbu	r5,-12(fp)
8111d0dc:	e0bffd03 	ldbu	r2,-12(fp)
8111d0e0:	e0ffff17 	ldw	r3,-4(fp)
8111d0e4:	10802644 	addi	r2,r2,153
8111d0e8:	1085883a 	add	r2,r2,r2
8111d0ec:	1085883a 	add	r2,r2,r2
8111d0f0:	1885883a 	add	r2,r3,r2
8111d0f4:	10c00017 	ldw	r3,0(r2)
8111d0f8:	e13ffe17 	ldw	r4,-8(fp)
8111d0fc:	288000c4 	addi	r2,r5,3
8111d100:	1085883a 	add	r2,r2,r2
8111d104:	1085883a 	add	r2,r2,r2
8111d108:	2085883a 	add	r2,r4,r2
8111d10c:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111d110:	e0bffd03 	ldbu	r2,-12(fp)
8111d114:	10800044 	addi	r2,r2,1
8111d118:	e0bffd05 	stb	r2,-12(fp)
8111d11c:	e0bffd03 	ldbu	r2,-12(fp)
8111d120:	103fe226 	beq	r2,zero,8111d0ac <__reset+0xfb0fd0ac>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111d124:	e0bfff17 	ldw	r2,-4(fp)
8111d128:	10c09b04 	addi	r3,r2,620
8111d12c:	e0bffe17 	ldw	r2,-8(fp)
8111d130:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111d134:	e0bffe17 	ldw	r2,-8(fp)
8111d138:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111d13c:	e0bffe17 	ldw	r2,-8(fp)
8111d140:	10c00504 	addi	r3,r2,20
8111d144:	e0bfff17 	ldw	r2,-4(fp)
8111d148:	10c09d15 	stw	r3,628(r2)
}
8111d14c:	0001883a 	nop
8111d150:	e037883a 	mov	sp,fp
8111d154:	df000017 	ldw	fp,0(sp)
8111d158:	dec00104 	addi	sp,sp,4
8111d15c:	f800283a 	ret

8111d160 <printErrorTask>:

#include "error_handler_simucam.h"


#if DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111d160:	defff904 	addi	sp,sp,-28
8111d164:	de00012e 	bgeu	sp,et,8111d16c <printErrorTask+0xc>
8111d168:	003b68fa 	trap	3
8111d16c:	dfc00615 	stw	ra,24(sp)
8111d170:	df000515 	stw	fp,20(sp)
8111d174:	df000504 	addi	fp,sp,20
8111d178:	2005883a 	mov	r2,r4
8111d17c:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111d180:	e03ffb15 	stw	zero,-20(fp)
8111d184:	e03ffc15 	stw	zero,-16(fp)
8111d188:	e03ffd15 	stw	zero,-12(fp)
8111d18c:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111d190:	e0bfff03 	ldbu	r2,-4(fp)
8111d194:	100d883a 	mov	r6,r2
8111d198:	01604574 	movhi	r5,33045
8111d19c:	29439604 	addi	r5,r5,3672
8111d1a0:	e13ffb04 	addi	r4,fp,-20
8111d1a4:	1124f640 	call	81124f64 <sprintf>
		debug(fp, buffer);
8111d1a8:	d0a06217 	ldw	r2,-32376(gp)
8111d1ac:	e17ffb04 	addi	r5,fp,-20
8111d1b0:	1009883a 	mov	r4,r2
8111d1b4:	11236500 	call	81123650 <fprintf>
	}
8111d1b8:	0001883a 	nop
8111d1bc:	e037883a 	mov	sp,fp
8111d1c0:	dfc00117 	ldw	ra,4(sp)
8111d1c4:	df000017 	ldw	fp,0(sp)
8111d1c8:	dec00204 	addi	sp,sp,8
8111d1cc:	f800283a 	ret

8111d1d0 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111d1d0:	defffd04 	addi	sp,sp,-12
8111d1d4:	de00012e 	bgeu	sp,et,8111d1dc <vFailCreateMutexSResources+0xc>
8111d1d8:	003b68fa 	trap	3
8111d1dc:	dfc00215 	stw	ra,8(sp)
8111d1e0:	df000115 	stw	fp,4(sp)
8111d1e4:	df000104 	addi	fp,sp,4
8111d1e8:	2005883a 	mov	r2,r4
8111d1ec:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d1f0:	00a045f4 	movhi	r2,33047
8111d1f4:	10a34f04 	addi	r2,r2,-29380
8111d1f8:	10800a8b 	ldhu	r2,42(r2)
8111d1fc:	10bfffcc 	andi	r2,r2,65535
8111d200:	10800228 	cmpgeui	r2,r2,8
8111d204:	10000a1e 	bne	r2,zero,8111d230 <vFailCreateMutexSResources+0x60>
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111d208:	d0a06217 	ldw	r2,-32376(gp)
8111d20c:	100f883a 	mov	r7,r2
8111d210:	018008c4 	movi	r6,35
8111d214:	01400044 	movi	r5,1
8111d218:	01204574 	movhi	r4,33045
8111d21c:	21039904 	addi	r4,r4,3684
8111d220:	1123cec0 	call	81123cec <fwrite>
		printErrorTask(error_code);
8111d224:	e0bfff03 	ldbu	r2,-4(fp)
8111d228:	1009883a 	mov	r4,r2
8111d22c:	111d1600 	call	8111d160 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d230:	0001883a 	nop
8111d234:	e037883a 	mov	sp,fp
8111d238:	dfc00117 	ldw	ra,4(sp)
8111d23c:	df000017 	ldw	fp,0(sp)
8111d240:	dec00204 	addi	sp,sp,8
8111d244:	f800283a 	ret

8111d248 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111d248:	defffe04 	addi	sp,sp,-8
8111d24c:	de00012e 	bgeu	sp,et,8111d254 <vFailCreateMutexDMA+0xc>
8111d250:	003b68fa 	trap	3
8111d254:	dfc00115 	stw	ra,4(sp)
8111d258:	df000015 	stw	fp,0(sp)
8111d25c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d260:	00a045f4 	movhi	r2,33047
8111d264:	10a34f04 	addi	r2,r2,-29380
8111d268:	10800a8b 	ldhu	r2,42(r2)
8111d26c:	10bfffcc 	andi	r2,r2,65535
8111d270:	10800228 	cmpgeui	r2,r2,8
8111d274:	1000071e 	bne	r2,zero,8111d294 <vFailCreateMutexDMA+0x4c>
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111d278:	d0a06217 	ldw	r2,-32376(gp)
8111d27c:	100f883a 	mov	r7,r2
8111d280:	018009c4 	movi	r6,39
8111d284:	01400044 	movi	r5,1
8111d288:	01204574 	movhi	r4,33045
8111d28c:	2103a204 	addi	r4,r4,3720
8111d290:	1123cec0 	call	81123cec <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d294:	0001883a 	nop
8111d298:	e037883a 	mov	sp,fp
8111d29c:	dfc00117 	ldw	ra,4(sp)
8111d2a0:	df000017 	ldw	fp,0(sp)
8111d2a4:	dec00204 	addi	sp,sp,8
8111d2a8:	f800283a 	ret

8111d2ac <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111d2ac:	defffe04 	addi	sp,sp,-8
8111d2b0:	de00012e 	bgeu	sp,et,8111d2b8 <vFailCreateSemaphoreResources+0xc>
8111d2b4:	003b68fa 	trap	3
8111d2b8:	dfc00115 	stw	ra,4(sp)
8111d2bc:	df000015 	stw	fp,0(sp)
8111d2c0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d2c4:	00a045f4 	movhi	r2,33047
8111d2c8:	10a34f04 	addi	r2,r2,-29380
8111d2cc:	10800a8b 	ldhu	r2,42(r2)
8111d2d0:	10bfffcc 	andi	r2,r2,65535
8111d2d4:	10800228 	cmpgeui	r2,r2,8
8111d2d8:	1000071e 	bne	r2,zero,8111d2f8 <vFailCreateSemaphoreResources+0x4c>
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111d2dc:	d0a06217 	ldw	r2,-32376(gp)
8111d2e0:	100f883a 	mov	r7,r2
8111d2e4:	01800984 	movi	r6,38
8111d2e8:	01400044 	movi	r5,1
8111d2ec:	01204574 	movhi	r4,33045
8111d2f0:	2103ac04 	addi	r4,r4,3760
8111d2f4:	1123cec0 	call	81123cec <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d2f8:	0001883a 	nop
8111d2fc:	e037883a 	mov	sp,fp
8111d300:	dfc00117 	ldw	ra,4(sp)
8111d304:	df000017 	ldw	fp,0(sp)
8111d308:	dec00204 	addi	sp,sp,8
8111d30c:	f800283a 	ret

8111d310 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111d310:	defffe04 	addi	sp,sp,-8
8111d314:	de00012e 	bgeu	sp,et,8111d31c <vFailTestCriticasParts+0xc>
8111d318:	003b68fa 	trap	3
8111d31c:	dfc00115 	stw	ra,4(sp)
8111d320:	df000015 	stw	fp,0(sp)
8111d324:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d328:	00a045f4 	movhi	r2,33047
8111d32c:	10a34f04 	addi	r2,r2,-29380
8111d330:	10800a8b 	ldhu	r2,42(r2)
8111d334:	10bfffcc 	andi	r2,r2,65535
8111d338:	10800228 	cmpgeui	r2,r2,8
8111d33c:	1000071e 	bne	r2,zero,8111d35c <vFailTestCriticasParts+0x4c>
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111d340:	d0a06217 	ldw	r2,-32376(gp)
8111d344:	100f883a 	mov	r7,r2
8111d348:	018007c4 	movi	r6,31
8111d34c:	01400044 	movi	r5,1
8111d350:	01204574 	movhi	r4,33045
8111d354:	2103b604 	addi	r4,r4,3800
8111d358:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d35c:	0001883a 	nop
8111d360:	e037883a 	mov	sp,fp
8111d364:	dfc00117 	ldw	ra,4(sp)
8111d368:	df000017 	ldw	fp,0(sp)
8111d36c:	dec00204 	addi	sp,sp,8
8111d370:	f800283a 	ret

8111d374 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111d374:	defffe04 	addi	sp,sp,-8
8111d378:	de00012e 	bgeu	sp,et,8111d380 <vFailSendxSemCommInit+0xc>
8111d37c:	003b68fa 	trap	3
8111d380:	dfc00115 	stw	ra,4(sp)
8111d384:	df000015 	stw	fp,0(sp)
8111d388:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d38c:	00a045f4 	movhi	r2,33047
8111d390:	10a34f04 	addi	r2,r2,-29380
8111d394:	10800a8b 	ldhu	r2,42(r2)
8111d398:	10bfffcc 	andi	r2,r2,65535
8111d39c:	10800228 	cmpgeui	r2,r2,8
8111d3a0:	10000e1e 	bne	r2,zero,8111d3dc <vFailSendxSemCommInit+0x68>
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111d3a4:	d0a06217 	ldw	r2,-32376(gp)
8111d3a8:	100f883a 	mov	r7,r2
8111d3ac:	01800744 	movi	r6,29
8111d3b0:	01400044 	movi	r5,1
8111d3b4:	01204574 	movhi	r4,33045
8111d3b8:	2103be04 	addi	r4,r4,3832
8111d3bc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111d3c0:	d0a06217 	ldw	r2,-32376(gp)
8111d3c4:	100f883a 	mov	r7,r2
8111d3c8:	01800a44 	movi	r6,41
8111d3cc:	01400044 	movi	r5,1
8111d3d0:	01204574 	movhi	r4,33045
8111d3d4:	2103c604 	addi	r4,r4,3864
8111d3d8:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d3dc:	0001883a 	nop
8111d3e0:	e037883a 	mov	sp,fp
8111d3e4:	dfc00117 	ldw	ra,4(sp)
8111d3e8:	df000017 	ldw	fp,0(sp)
8111d3ec:	dec00204 	addi	sp,sp,8
8111d3f0:	f800283a 	ret

8111d3f4 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111d3f4:	defffe04 	addi	sp,sp,-8
8111d3f8:	de00012e 	bgeu	sp,et,8111d400 <vFailSendPreParsedSemaphore+0xc>
8111d3fc:	003b68fa 	trap	3
8111d400:	dfc00115 	stw	ra,4(sp)
8111d404:	df000015 	stw	fp,0(sp)
8111d408:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d40c:	00a045f4 	movhi	r2,33047
8111d410:	10a34f04 	addi	r2,r2,-29380
8111d414:	10800a8b 	ldhu	r2,42(r2)
8111d418:	10bfffcc 	andi	r2,r2,65535
8111d41c:	10800228 	cmpgeui	r2,r2,8
8111d420:	1000071e 	bne	r2,zero,8111d440 <vFailSendPreParsedSemaphore+0x4c>
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111d424:	d0a06217 	ldw	r2,-32376(gp)
8111d428:	100f883a 	mov	r7,r2
8111d42c:	01800904 	movi	r6,36
8111d430:	01400044 	movi	r5,1
8111d434:	01204574 	movhi	r4,33045
8111d438:	2103d104 	addi	r4,r4,3908
8111d43c:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d440:	0001883a 	nop
8111d444:	e037883a 	mov	sp,fp
8111d448:	dfc00117 	ldw	ra,4(sp)
8111d44c:	df000017 	ldw	fp,0(sp)
8111d450:	dec00204 	addi	sp,sp,8
8111d454:	f800283a 	ret

8111d458 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111d458:	defffe04 	addi	sp,sp,-8
8111d45c:	de00012e 	bgeu	sp,et,8111d464 <vFailSendPreAckReceiverSemaphore+0xc>
8111d460:	003b68fa 	trap	3
8111d464:	dfc00115 	stw	ra,4(sp)
8111d468:	df000015 	stw	fp,0(sp)
8111d46c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d470:	00a045f4 	movhi	r2,33047
8111d474:	10a34f04 	addi	r2,r2,-29380
8111d478:	10800a8b 	ldhu	r2,42(r2)
8111d47c:	10bfffcc 	andi	r2,r2,65535
8111d480:	10800228 	cmpgeui	r2,r2,8
8111d484:	1000071e 	bne	r2,zero,8111d4a4 <vFailSendPreAckReceiverSemaphore+0x4c>
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111d488:	d0a06217 	ldw	r2,-32376(gp)
8111d48c:	100f883a 	mov	r7,r2
8111d490:	01800a44 	movi	r6,41
8111d494:	01400044 	movi	r5,1
8111d498:	01204574 	movhi	r4,33045
8111d49c:	2103db04 	addi	r4,r4,3948
8111d4a0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d4a4:	0001883a 	nop
8111d4a8:	e037883a 	mov	sp,fp
8111d4ac:	dfc00117 	ldw	ra,4(sp)
8111d4b0:	df000017 	ldw	fp,0(sp)
8111d4b4:	dec00204 	addi	sp,sp,8
8111d4b8:	f800283a 	ret

8111d4bc <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111d4bc:	defffe04 	addi	sp,sp,-8
8111d4c0:	de00012e 	bgeu	sp,et,8111d4c8 <vFailSendPreAckSenderSemaphore+0xc>
8111d4c4:	003b68fa 	trap	3
8111d4c8:	dfc00115 	stw	ra,4(sp)
8111d4cc:	df000015 	stw	fp,0(sp)
8111d4d0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d4d4:	00a045f4 	movhi	r2,33047
8111d4d8:	10a34f04 	addi	r2,r2,-29380
8111d4dc:	10800a8b 	ldhu	r2,42(r2)
8111d4e0:	10bfffcc 	andi	r2,r2,65535
8111d4e4:	10800228 	cmpgeui	r2,r2,8
8111d4e8:	1000071e 	bne	r2,zero,8111d508 <vFailSendPreAckSenderSemaphore+0x4c>
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111d4ec:	d0a06217 	ldw	r2,-32376(gp)
8111d4f0:	100f883a 	mov	r7,r2
8111d4f4:	018009c4 	movi	r6,39
8111d4f8:	01400044 	movi	r5,1
8111d4fc:	01204574 	movhi	r4,33045
8111d500:	2103e604 	addi	r4,r4,3992
8111d504:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d508:	0001883a 	nop
8111d50c:	e037883a 	mov	sp,fp
8111d510:	dfc00117 	ldw	ra,4(sp)
8111d514:	df000017 	ldw	fp,0(sp)
8111d518:	dec00204 	addi	sp,sp,8
8111d51c:	f800283a 	ret

8111d520 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111d520:	defffe04 	addi	sp,sp,-8
8111d524:	de00012e 	bgeu	sp,et,8111d52c <vFailGetCountSemaphoreSenderTask+0xc>
8111d528:	003b68fa 	trap	3
8111d52c:	dfc00115 	stw	ra,4(sp)
8111d530:	df000015 	stw	fp,0(sp)
8111d534:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d538:	00a045f4 	movhi	r2,33047
8111d53c:	10a34f04 	addi	r2,r2,-29380
8111d540:	10800a8b 	ldhu	r2,42(r2)
8111d544:	10bfffcc 	andi	r2,r2,65535
8111d548:	10800228 	cmpgeui	r2,r2,8
8111d54c:	10000e1e 	bne	r2,zero,8111d588 <vFailGetCountSemaphoreSenderTask+0x68>
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111d550:	d0a06217 	ldw	r2,-32376(gp)
8111d554:	100f883a 	mov	r7,r2
8111d558:	01800a44 	movi	r6,41
8111d55c:	01400044 	movi	r5,1
8111d560:	01204574 	movhi	r4,33045
8111d564:	2103f004 	addi	r4,r4,4032
8111d568:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111d56c:	d0a06217 	ldw	r2,-32376(gp)
8111d570:	100f883a 	mov	r7,r2
8111d574:	01801104 	movi	r6,68
8111d578:	01400044 	movi	r5,1
8111d57c:	01204574 	movhi	r4,33045
8111d580:	2103fb04 	addi	r4,r4,4076
8111d584:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d588:	0001883a 	nop
8111d58c:	e037883a 	mov	sp,fp
8111d590:	dfc00117 	ldw	ra,4(sp)
8111d594:	df000017 	ldw	fp,0(sp)
8111d598:	dec00204 	addi	sp,sp,8
8111d59c:	f800283a 	ret

8111d5a0 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111d5a0:	defffe04 	addi	sp,sp,-8
8111d5a4:	de00012e 	bgeu	sp,et,8111d5ac <vFailGetMutexSenderTask+0xc>
8111d5a8:	003b68fa 	trap	3
8111d5ac:	dfc00115 	stw	ra,4(sp)
8111d5b0:	df000015 	stw	fp,0(sp)
8111d5b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d5b8:	00a045f4 	movhi	r2,33047
8111d5bc:	10a34f04 	addi	r2,r2,-29380
8111d5c0:	10800a8b 	ldhu	r2,42(r2)
8111d5c4:	10bfffcc 	andi	r2,r2,65535
8111d5c8:	10800228 	cmpgeui	r2,r2,8
8111d5cc:	10000e1e 	bne	r2,zero,8111d608 <vFailGetMutexSenderTask+0x68>
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111d5d0:	d0a06217 	ldw	r2,-32376(gp)
8111d5d4:	100f883a 	mov	r7,r2
8111d5d8:	01800804 	movi	r6,32
8111d5dc:	01400044 	movi	r5,1
8111d5e0:	01204574 	movhi	r4,33045
8111d5e4:	21040d04 	addi	r4,r4,4148
8111d5e8:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111d5ec:	d0a06217 	ldw	r2,-32376(gp)
8111d5f0:	100f883a 	mov	r7,r2
8111d5f4:	01801084 	movi	r6,66
8111d5f8:	01400044 	movi	r5,1
8111d5fc:	01204574 	movhi	r4,33045
8111d600:	21041604 	addi	r4,r4,4184
8111d604:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d608:	0001883a 	nop
8111d60c:	e037883a 	mov	sp,fp
8111d610:	dfc00117 	ldw	ra,4(sp)
8111d614:	df000017 	ldw	fp,0(sp)
8111d618:	dec00204 	addi	sp,sp,8
8111d61c:	f800283a 	ret

8111d620 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111d620:	defffe04 	addi	sp,sp,-8
8111d624:	de00012e 	bgeu	sp,et,8111d62c <vFailGetCountSemaphoreReceiverTask+0xc>
8111d628:	003b68fa 	trap	3
8111d62c:	dfc00115 	stw	ra,4(sp)
8111d630:	df000015 	stw	fp,0(sp)
8111d634:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d638:	00a045f4 	movhi	r2,33047
8111d63c:	10a34f04 	addi	r2,r2,-29380
8111d640:	10800a8b 	ldhu	r2,42(r2)
8111d644:	10bfffcc 	andi	r2,r2,65535
8111d648:	10800228 	cmpgeui	r2,r2,8
8111d64c:	10000e1e 	bne	r2,zero,8111d688 <vFailGetCountSemaphoreReceiverTask+0x68>
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111d650:	d0a06217 	ldw	r2,-32376(gp)
8111d654:	100f883a 	mov	r7,r2
8111d658:	01800ac4 	movi	r6,43
8111d65c:	01400044 	movi	r5,1
8111d660:	01204574 	movhi	r4,33045
8111d664:	21042704 	addi	r4,r4,4252
8111d668:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111d66c:	d0a06217 	ldw	r2,-32376(gp)
8111d670:	100f883a 	mov	r7,r2
8111d674:	01801184 	movi	r6,70
8111d678:	01400044 	movi	r5,1
8111d67c:	01204574 	movhi	r4,33045
8111d680:	21043204 	addi	r4,r4,4296
8111d684:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d688:	0001883a 	nop
8111d68c:	e037883a 	mov	sp,fp
8111d690:	dfc00117 	ldw	ra,4(sp)
8111d694:	df000017 	ldw	fp,0(sp)
8111d698:	dec00204 	addi	sp,sp,8
8111d69c:	f800283a 	ret

8111d6a0 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111d6a0:	defffe04 	addi	sp,sp,-8
8111d6a4:	de00012e 	bgeu	sp,et,8111d6ac <vFailGetMutexReceiverTask+0xc>
8111d6a8:	003b68fa 	trap	3
8111d6ac:	dfc00115 	stw	ra,4(sp)
8111d6b0:	df000015 	stw	fp,0(sp)
8111d6b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d6b8:	00a045f4 	movhi	r2,33047
8111d6bc:	10a34f04 	addi	r2,r2,-29380
8111d6c0:	10800a8b 	ldhu	r2,42(r2)
8111d6c4:	10bfffcc 	andi	r2,r2,65535
8111d6c8:	10800228 	cmpgeui	r2,r2,8
8111d6cc:	10000e1e 	bne	r2,zero,8111d708 <vFailGetMutexReceiverTask+0x68>
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111d6d0:	d0a06217 	ldw	r2,-32376(gp)
8111d6d4:	100f883a 	mov	r7,r2
8111d6d8:	01800884 	movi	r6,34
8111d6dc:	01400044 	movi	r5,1
8111d6e0:	01204574 	movhi	r4,33045
8111d6e4:	21044404 	addi	r4,r4,4368
8111d6e8:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111d6ec:	d0a06217 	ldw	r2,-32376(gp)
8111d6f0:	100f883a 	mov	r7,r2
8111d6f4:	01801104 	movi	r6,68
8111d6f8:	01400044 	movi	r5,1
8111d6fc:	01204574 	movhi	r4,33045
8111d700:	21044d04 	addi	r4,r4,4404
8111d704:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d708:	0001883a 	nop
8111d70c:	e037883a 	mov	sp,fp
8111d710:	dfc00117 	ldw	ra,4(sp)
8111d714:	df000017 	ldw	fp,0(sp)
8111d718:	dec00204 	addi	sp,sp,8
8111d71c:	f800283a 	ret

8111d720 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111d720:	defffe04 	addi	sp,sp,-8
8111d724:	de00012e 	bgeu	sp,et,8111d72c <vFailGetMutexTxUARTSenderTask+0xc>
8111d728:	003b68fa 	trap	3
8111d72c:	dfc00115 	stw	ra,4(sp)
8111d730:	df000015 	stw	fp,0(sp)
8111d734:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d738:	00a045f4 	movhi	r2,33047
8111d73c:	10a34f04 	addi	r2,r2,-29380
8111d740:	10800a8b 	ldhu	r2,42(r2)
8111d744:	10bfffcc 	andi	r2,r2,65535
8111d748:	10800228 	cmpgeui	r2,r2,8
8111d74c:	10000e1e 	bne	r2,zero,8111d788 <vFailGetMutexTxUARTSenderTask+0x68>
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111d750:	d0a06217 	ldw	r2,-32376(gp)
8111d754:	100f883a 	mov	r7,r2
8111d758:	01800984 	movi	r6,38
8111d75c:	01400044 	movi	r5,1
8111d760:	01204574 	movhi	r4,33045
8111d764:	21045f04 	addi	r4,r4,4476
8111d768:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111d76c:	d0a06217 	ldw	r2,-32376(gp)
8111d770:	100f883a 	mov	r7,r2
8111d774:	01801044 	movi	r6,65
8111d778:	01400044 	movi	r5,1
8111d77c:	01204574 	movhi	r4,33045
8111d780:	21046904 	addi	r4,r4,4516
8111d784:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d788:	0001883a 	nop
8111d78c:	e037883a 	mov	sp,fp
8111d790:	dfc00117 	ldw	ra,4(sp)
8111d794:	df000017 	ldw	fp,0(sp)
8111d798:	dec00204 	addi	sp,sp,8
8111d79c:	f800283a 	ret

8111d7a0 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111d7a0:	defffe04 	addi	sp,sp,-8
8111d7a4:	de00012e 	bgeu	sp,et,8111d7ac <vFailGetMacRTC+0xc>
8111d7a8:	003b68fa 	trap	3
8111d7ac:	dfc00115 	stw	ra,4(sp)
8111d7b0:	df000015 	stw	fp,0(sp)
8111d7b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d7b8:	00a045f4 	movhi	r2,33047
8111d7bc:	10a34f04 	addi	r2,r2,-29380
8111d7c0:	10800a8b 	ldhu	r2,42(r2)
8111d7c4:	10bfffcc 	andi	r2,r2,65535
8111d7c8:	10800228 	cmpgeui	r2,r2,8
8111d7cc:	1000071e 	bne	r2,zero,8111d7ec <vFailGetMacRTC+0x4c>
		debug(fp,"vFailGetMacRTC\n");
8111d7d0:	d0a06217 	ldw	r2,-32376(gp)
8111d7d4:	100f883a 	mov	r7,r2
8111d7d8:	018003c4 	movi	r6,15
8111d7dc:	01400044 	movi	r5,1
8111d7e0:	01204574 	movhi	r4,33045
8111d7e4:	21047a04 	addi	r4,r4,4584
8111d7e8:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d7ec:	0001883a 	nop
8111d7f0:	e037883a 	mov	sp,fp
8111d7f4:	dfc00117 	ldw	ra,4(sp)
8111d7f8:	df000017 	ldw	fp,0(sp)
8111d7fc:	dec00204 	addi	sp,sp,8
8111d800:	f800283a 	ret

8111d804 <vFailInitialization>:


void vFailInitialization( void )
{
8111d804:	defffe04 	addi	sp,sp,-8
8111d808:	de00012e 	bgeu	sp,et,8111d810 <vFailInitialization+0xc>
8111d80c:	003b68fa 	trap	3
8111d810:	dfc00115 	stw	ra,4(sp)
8111d814:	df000015 	stw	fp,0(sp)
8111d818:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d81c:	00a045f4 	movhi	r2,33047
8111d820:	10a34f04 	addi	r2,r2,-29380
8111d824:	10800a8b 	ldhu	r2,42(r2)
8111d828:	10bfffcc 	andi	r2,r2,65535
8111d82c:	10800228 	cmpgeui	r2,r2,8
8111d830:	1000071e 	bne	r2,zero,8111d850 <vFailInitialization+0x4c>
		debug(fp,"vFailInitialization\n");
8111d834:	d0a06217 	ldw	r2,-32376(gp)
8111d838:	100f883a 	mov	r7,r2
8111d83c:	01800504 	movi	r6,20
8111d840:	01400044 	movi	r5,1
8111d844:	01204574 	movhi	r4,33045
8111d848:	21047e04 	addi	r4,r4,4600
8111d84c:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d850:	0001883a 	nop
8111d854:	e037883a 	mov	sp,fp
8111d858:	dfc00117 	ldw	ra,4(sp)
8111d85c:	df000017 	ldw	fp,0(sp)
8111d860:	dec00204 	addi	sp,sp,8
8111d864:	f800283a 	ret

8111d868 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111d868:	defffe04 	addi	sp,sp,-8
8111d86c:	de00012e 	bgeu	sp,et,8111d874 <vFailReceiverCreate+0xc>
8111d870:	003b68fa 	trap	3
8111d874:	dfc00115 	stw	ra,4(sp)
8111d878:	df000015 	stw	fp,0(sp)
8111d87c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d880:	00a045f4 	movhi	r2,33047
8111d884:	10a34f04 	addi	r2,r2,-29380
8111d888:	10800a8b 	ldhu	r2,42(r2)
8111d88c:	10bfffcc 	andi	r2,r2,65535
8111d890:	10800228 	cmpgeui	r2,r2,8
8111d894:	1000071e 	bne	r2,zero,8111d8b4 <vFailReceiverCreate+0x4c>
		debug(fp,"vReceiverUartTask\n");
8111d898:	d0a06217 	ldw	r2,-32376(gp)
8111d89c:	100f883a 	mov	r7,r2
8111d8a0:	01800484 	movi	r6,18
8111d8a4:	01400044 	movi	r5,1
8111d8a8:	01204574 	movhi	r4,33045
8111d8ac:	21048404 	addi	r4,r4,4624
8111d8b0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d8b4:	0001883a 	nop
8111d8b8:	e037883a 	mov	sp,fp
8111d8bc:	dfc00117 	ldw	ra,4(sp)
8111d8c0:	df000017 	ldw	fp,0(sp)
8111d8c4:	dec00204 	addi	sp,sp,8
8111d8c8:	f800283a 	ret

8111d8cc <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111d8cc:	defffe04 	addi	sp,sp,-8
8111d8d0:	de00012e 	bgeu	sp,et,8111d8d8 <vFailSenderCreate+0xc>
8111d8d4:	003b68fa 	trap	3
8111d8d8:	dfc00115 	stw	ra,4(sp)
8111d8dc:	df000015 	stw	fp,0(sp)
8111d8e0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d8e4:	00a045f4 	movhi	r2,33047
8111d8e8:	10a34f04 	addi	r2,r2,-29380
8111d8ec:	10800a8b 	ldhu	r2,42(r2)
8111d8f0:	10bfffcc 	andi	r2,r2,65535
8111d8f4:	10800228 	cmpgeui	r2,r2,8
8111d8f8:	1000071e 	bne	r2,zero,8111d918 <vFailSenderCreate+0x4c>
		debug(fp,"vFailSenderCreate\n");
8111d8fc:	d0a06217 	ldw	r2,-32376(gp)
8111d900:	100f883a 	mov	r7,r2
8111d904:	01800484 	movi	r6,18
8111d908:	01400044 	movi	r5,1
8111d90c:	01204574 	movhi	r4,33045
8111d910:	21048904 	addi	r4,r4,4644
8111d914:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d918:	0001883a 	nop
8111d91c:	e037883a 	mov	sp,fp
8111d920:	dfc00117 	ldw	ra,4(sp)
8111d924:	df000017 	ldw	fp,0(sp)
8111d928:	dec00204 	addi	sp,sp,8
8111d92c:	f800283a 	ret

8111d930 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111d930:	defffe04 	addi	sp,sp,-8
8111d934:	de00012e 	bgeu	sp,et,8111d93c <vFailDeleteInitialization+0xc>
8111d938:	003b68fa 	trap	3
8111d93c:	dfc00115 	stw	ra,4(sp)
8111d940:	df000015 	stw	fp,0(sp)
8111d944:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d948:	00a045f4 	movhi	r2,33047
8111d94c:	10a34f04 	addi	r2,r2,-29380
8111d950:	10800a8b 	ldhu	r2,42(r2)
8111d954:	10bfffcc 	andi	r2,r2,65535
8111d958:	10800228 	cmpgeui	r2,r2,8
8111d95c:	1000071e 	bne	r2,zero,8111d97c <vFailDeleteInitialization+0x4c>
		debug(fp,"vFailDeleteInitialization\n");
8111d960:	d0a06217 	ldw	r2,-32376(gp)
8111d964:	100f883a 	mov	r7,r2
8111d968:	01800684 	movi	r6,26
8111d96c:	01400044 	movi	r5,1
8111d970:	01204574 	movhi	r4,33045
8111d974:	21048e04 	addi	r4,r4,4664
8111d978:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d97c:	0001883a 	nop
8111d980:	e037883a 	mov	sp,fp
8111d984:	dfc00117 	ldw	ra,4(sp)
8111d988:	df000017 	ldw	fp,0(sp)
8111d98c:	dec00204 	addi	sp,sp,8
8111d990:	f800283a 	ret

8111d994 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111d994:	defffe04 	addi	sp,sp,-8
8111d998:	de00012e 	bgeu	sp,et,8111d9a0 <vFailSetCountSemaphorexBuffer32+0xc>
8111d99c:	003b68fa 	trap	3
8111d9a0:	dfc00115 	stw	ra,4(sp)
8111d9a4:	df000015 	stw	fp,0(sp)
8111d9a8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d9ac:	00a045f4 	movhi	r2,33047
8111d9b0:	10a34f04 	addi	r2,r2,-29380
8111d9b4:	10800a8b 	ldhu	r2,42(r2)
8111d9b8:	10bfffcc 	andi	r2,r2,65535
8111d9bc:	10800228 	cmpgeui	r2,r2,8
8111d9c0:	10000e1e 	bne	r2,zero,8111d9fc <vFailSetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111d9c4:	d0a06217 	ldw	r2,-32376(gp)
8111d9c8:	100f883a 	mov	r7,r2
8111d9cc:	01800a04 	movi	r6,40
8111d9d0:	01400044 	movi	r5,1
8111d9d4:	01204574 	movhi	r4,33045
8111d9d8:	21049504 	addi	r4,r4,4692
8111d9dc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111d9e0:	d0a06217 	ldw	r2,-32376(gp)
8111d9e4:	100f883a 	mov	r7,r2
8111d9e8:	018008c4 	movi	r6,35
8111d9ec:	01400044 	movi	r5,1
8111d9f0:	01204574 	movhi	r4,33045
8111d9f4:	2104a004 	addi	r4,r4,4736
8111d9f8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d9fc:	0001883a 	nop
8111da00:	e037883a 	mov	sp,fp
8111da04:	dfc00117 	ldw	ra,4(sp)
8111da08:	df000017 	ldw	fp,0(sp)
8111da0c:	dec00204 	addi	sp,sp,8
8111da10:	f800283a 	ret

8111da14 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111da14:	defffe04 	addi	sp,sp,-8
8111da18:	de00012e 	bgeu	sp,et,8111da20 <vFailSetCountSemaphorexBuffer64+0xc>
8111da1c:	003b68fa 	trap	3
8111da20:	dfc00115 	stw	ra,4(sp)
8111da24:	df000015 	stw	fp,0(sp)
8111da28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111da2c:	00a045f4 	movhi	r2,33047
8111da30:	10a34f04 	addi	r2,r2,-29380
8111da34:	10800a8b 	ldhu	r2,42(r2)
8111da38:	10bfffcc 	andi	r2,r2,65535
8111da3c:	10800228 	cmpgeui	r2,r2,8
8111da40:	10000e1e 	bne	r2,zero,8111da7c <vFailSetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111da44:	d0a06217 	ldw	r2,-32376(gp)
8111da48:	100f883a 	mov	r7,r2
8111da4c:	01800a04 	movi	r6,40
8111da50:	01400044 	movi	r5,1
8111da54:	01204574 	movhi	r4,33045
8111da58:	2104a904 	addi	r4,r4,4772
8111da5c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111da60:	d0a06217 	ldw	r2,-32376(gp)
8111da64:	100f883a 	mov	r7,r2
8111da68:	018008c4 	movi	r6,35
8111da6c:	01400044 	movi	r5,1
8111da70:	01204574 	movhi	r4,33045
8111da74:	2104a004 	addi	r4,r4,4736
8111da78:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111da7c:	0001883a 	nop
8111da80:	e037883a 	mov	sp,fp
8111da84:	dfc00117 	ldw	ra,4(sp)
8111da88:	df000017 	ldw	fp,0(sp)
8111da8c:	dec00204 	addi	sp,sp,8
8111da90:	f800283a 	ret

8111da94 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111da94:	defffe04 	addi	sp,sp,-8
8111da98:	de00012e 	bgeu	sp,et,8111daa0 <vFailSetCountSemaphorexBuffer128+0xc>
8111da9c:	003b68fa 	trap	3
8111daa0:	dfc00115 	stw	ra,4(sp)
8111daa4:	df000015 	stw	fp,0(sp)
8111daa8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111daac:	00a045f4 	movhi	r2,33047
8111dab0:	10a34f04 	addi	r2,r2,-29380
8111dab4:	10800a8b 	ldhu	r2,42(r2)
8111dab8:	10bfffcc 	andi	r2,r2,65535
8111dabc:	10800228 	cmpgeui	r2,r2,8
8111dac0:	10000e1e 	bne	r2,zero,8111dafc <vFailSetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111dac4:	d0a06217 	ldw	r2,-32376(gp)
8111dac8:	100f883a 	mov	r7,r2
8111dacc:	01800a44 	movi	r6,41
8111dad0:	01400044 	movi	r5,1
8111dad4:	01204574 	movhi	r4,33045
8111dad8:	2104b404 	addi	r4,r4,4816
8111dadc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111dae0:	d0a06217 	ldw	r2,-32376(gp)
8111dae4:	100f883a 	mov	r7,r2
8111dae8:	018008c4 	movi	r6,35
8111daec:	01400044 	movi	r5,1
8111daf0:	01204574 	movhi	r4,33045
8111daf4:	2104a004 	addi	r4,r4,4736
8111daf8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dafc:	0001883a 	nop
8111db00:	e037883a 	mov	sp,fp
8111db04:	dfc00117 	ldw	ra,4(sp)
8111db08:	df000017 	ldw	fp,0(sp)
8111db0c:	dec00204 	addi	sp,sp,8
8111db10:	f800283a 	ret

8111db14 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111db14:	defffe04 	addi	sp,sp,-8
8111db18:	de00012e 	bgeu	sp,et,8111db20 <vFailGetCountSemaphorexBuffer128+0xc>
8111db1c:	003b68fa 	trap	3
8111db20:	dfc00115 	stw	ra,4(sp)
8111db24:	df000015 	stw	fp,0(sp)
8111db28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111db2c:	00a045f4 	movhi	r2,33047
8111db30:	10a34f04 	addi	r2,r2,-29380
8111db34:	10800a8b 	ldhu	r2,42(r2)
8111db38:	10bfffcc 	andi	r2,r2,65535
8111db3c:	10800228 	cmpgeui	r2,r2,8
8111db40:	10000e1e 	bne	r2,zero,8111db7c <vFailGetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111db44:	d0a06217 	ldw	r2,-32376(gp)
8111db48:	100f883a 	mov	r7,r2
8111db4c:	01800a44 	movi	r6,41
8111db50:	01400044 	movi	r5,1
8111db54:	01204574 	movhi	r4,33045
8111db58:	2104bf04 	addi	r4,r4,4860
8111db5c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111db60:	d0a06217 	ldw	r2,-32376(gp)
8111db64:	100f883a 	mov	r7,r2
8111db68:	01800884 	movi	r6,34
8111db6c:	01400044 	movi	r5,1
8111db70:	01204574 	movhi	r4,33045
8111db74:	2104ca04 	addi	r4,r4,4904
8111db78:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111db7c:	0001883a 	nop
8111db80:	e037883a 	mov	sp,fp
8111db84:	dfc00117 	ldw	ra,4(sp)
8111db88:	df000017 	ldw	fp,0(sp)
8111db8c:	dec00204 	addi	sp,sp,8
8111db90:	f800283a 	ret

8111db94 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111db94:	defffe04 	addi	sp,sp,-8
8111db98:	de00012e 	bgeu	sp,et,8111dba0 <vFailGetCountSemaphorexBuffer64+0xc>
8111db9c:	003b68fa 	trap	3
8111dba0:	dfc00115 	stw	ra,4(sp)
8111dba4:	df000015 	stw	fp,0(sp)
8111dba8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dbac:	00a045f4 	movhi	r2,33047
8111dbb0:	10a34f04 	addi	r2,r2,-29380
8111dbb4:	10800a8b 	ldhu	r2,42(r2)
8111dbb8:	10bfffcc 	andi	r2,r2,65535
8111dbbc:	10800228 	cmpgeui	r2,r2,8
8111dbc0:	10000e1e 	bne	r2,zero,8111dbfc <vFailGetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111dbc4:	d0a06217 	ldw	r2,-32376(gp)
8111dbc8:	100f883a 	mov	r7,r2
8111dbcc:	01800a04 	movi	r6,40
8111dbd0:	01400044 	movi	r5,1
8111dbd4:	01204574 	movhi	r4,33045
8111dbd8:	2104d304 	addi	r4,r4,4940
8111dbdc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111dbe0:	d0a06217 	ldw	r2,-32376(gp)
8111dbe4:	100f883a 	mov	r7,r2
8111dbe8:	01800884 	movi	r6,34
8111dbec:	01400044 	movi	r5,1
8111dbf0:	01204574 	movhi	r4,33045
8111dbf4:	2104ca04 	addi	r4,r4,4904
8111dbf8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dbfc:	0001883a 	nop
8111dc00:	e037883a 	mov	sp,fp
8111dc04:	dfc00117 	ldw	ra,4(sp)
8111dc08:	df000017 	ldw	fp,0(sp)
8111dc0c:	dec00204 	addi	sp,sp,8
8111dc10:	f800283a 	ret

8111dc14 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111dc14:	defffe04 	addi	sp,sp,-8
8111dc18:	de00012e 	bgeu	sp,et,8111dc20 <vFailGetCountSemaphorexBuffer32+0xc>
8111dc1c:	003b68fa 	trap	3
8111dc20:	dfc00115 	stw	ra,4(sp)
8111dc24:	df000015 	stw	fp,0(sp)
8111dc28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dc2c:	00a045f4 	movhi	r2,33047
8111dc30:	10a34f04 	addi	r2,r2,-29380
8111dc34:	10800a8b 	ldhu	r2,42(r2)
8111dc38:	10bfffcc 	andi	r2,r2,65535
8111dc3c:	10800228 	cmpgeui	r2,r2,8
8111dc40:	10000e1e 	bne	r2,zero,8111dc7c <vFailGetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111dc44:	d0a06217 	ldw	r2,-32376(gp)
8111dc48:	100f883a 	mov	r7,r2
8111dc4c:	01800a04 	movi	r6,40
8111dc50:	01400044 	movi	r5,1
8111dc54:	01204574 	movhi	r4,33045
8111dc58:	2104de04 	addi	r4,r4,4984
8111dc5c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111dc60:	d0a06217 	ldw	r2,-32376(gp)
8111dc64:	100f883a 	mov	r7,r2
8111dc68:	01800884 	movi	r6,34
8111dc6c:	01400044 	movi	r5,1
8111dc70:	01204574 	movhi	r4,33045
8111dc74:	2104ca04 	addi	r4,r4,4904
8111dc78:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dc7c:	0001883a 	nop
8111dc80:	e037883a 	mov	sp,fp
8111dc84:	dfc00117 	ldw	ra,4(sp)
8111dc88:	df000017 	ldw	fp,0(sp)
8111dc8c:	dec00204 	addi	sp,sp,8
8111dc90:	f800283a 	ret

8111dc94 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111dc94:	defffe04 	addi	sp,sp,-8
8111dc98:	de00012e 	bgeu	sp,et,8111dca0 <vFailFoundBufferRetransmission+0xc>
8111dc9c:	003b68fa 	trap	3
8111dca0:	dfc00115 	stw	ra,4(sp)
8111dca4:	df000015 	stw	fp,0(sp)
8111dca8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dcac:	00a045f4 	movhi	r2,33047
8111dcb0:	10a34f04 	addi	r2,r2,-29380
8111dcb4:	10800a8b 	ldhu	r2,42(r2)
8111dcb8:	10bfffcc 	andi	r2,r2,65535
8111dcbc:	10800228 	cmpgeui	r2,r2,8
8111dcc0:	10000e1e 	bne	r2,zero,8111dcfc <vFailFoundBufferRetransmission+0x68>
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111dcc4:	d0a06217 	ldw	r2,-32376(gp)
8111dcc8:	100f883a 	mov	r7,r2
8111dccc:	01800a84 	movi	r6,42
8111dcd0:	01400044 	movi	r5,1
8111dcd4:	01204574 	movhi	r4,33045
8111dcd8:	2104e904 	addi	r4,r4,5028
8111dcdc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111dce0:	d0a06217 	ldw	r2,-32376(gp)
8111dce4:	100f883a 	mov	r7,r2
8111dce8:	01801204 	movi	r6,72
8111dcec:	01400044 	movi	r5,1
8111dcf0:	01204574 	movhi	r4,33045
8111dcf4:	2104f404 	addi	r4,r4,5072
8111dcf8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dcfc:	0001883a 	nop
8111dd00:	e037883a 	mov	sp,fp
8111dd04:	dfc00117 	ldw	ra,4(sp)
8111dd08:	df000017 	ldw	fp,0(sp)
8111dd0c:	dec00204 	addi	sp,sp,8
8111dd10:	f800283a 	ret

8111dd14 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111dd14:	defffe04 	addi	sp,sp,-8
8111dd18:	de00012e 	bgeu	sp,et,8111dd20 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111dd1c:	003b68fa 	trap	3
8111dd20:	dfc00115 	stw	ra,4(sp)
8111dd24:	df000015 	stw	fp,0(sp)
8111dd28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dd2c:	00a045f4 	movhi	r2,33047
8111dd30:	10a34f04 	addi	r2,r2,-29380
8111dd34:	10800a8b 	ldhu	r2,42(r2)
8111dd38:	10bfffcc 	andi	r2,r2,65535
8111dd3c:	10800228 	cmpgeui	r2,r2,8
8111dd40:	10000e1e 	bne	r2,zero,8111dd7c <vFailGetCountSemaphorePreParsedBuffer+0x68>
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111dd44:	d0a06217 	ldw	r2,-32376(gp)
8111dd48:	100f883a 	mov	r7,r2
8111dd4c:	01800b84 	movi	r6,46
8111dd50:	01400044 	movi	r5,1
8111dd54:	01204574 	movhi	r4,33045
8111dd58:	21050704 	addi	r4,r4,5148
8111dd5c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111dd60:	d0a06217 	ldw	r2,-32376(gp)
8111dd64:	100f883a 	mov	r7,r2
8111dd68:	018010c4 	movi	r6,67
8111dd6c:	01400044 	movi	r5,1
8111dd70:	01204574 	movhi	r4,33045
8111dd74:	21051304 	addi	r4,r4,5196
8111dd78:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dd7c:	0001883a 	nop
8111dd80:	e037883a 	mov	sp,fp
8111dd84:	dfc00117 	ldw	ra,4(sp)
8111dd88:	df000017 	ldw	fp,0(sp)
8111dd8c:	dec00204 	addi	sp,sp,8
8111dd90:	f800283a 	ret

8111dd94 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111dd94:	defffe04 	addi	sp,sp,-8
8111dd98:	de00012e 	bgeu	sp,et,8111dda0 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111dd9c:	003b68fa 	trap	3
8111dda0:	dfc00115 	stw	ra,4(sp)
8111dda4:	df000015 	stw	fp,0(sp)
8111dda8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ddac:	00a045f4 	movhi	r2,33047
8111ddb0:	10a34f04 	addi	r2,r2,-29380
8111ddb4:	10800a8b 	ldhu	r2,42(r2)
8111ddb8:	10bfffcc 	andi	r2,r2,65535
8111ddbc:	10800228 	cmpgeui	r2,r2,8
8111ddc0:	10000e1e 	bne	r2,zero,8111ddfc <vFailGetxMutexPreParsedParserRxTask+0x68>
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111ddc4:	d0a06217 	ldw	r2,-32376(gp)
8111ddc8:	100f883a 	mov	r7,r2
8111ddcc:	01800b04 	movi	r6,44
8111ddd0:	01400044 	movi	r5,1
8111ddd4:	01204574 	movhi	r4,33045
8111ddd8:	21052404 	addi	r4,r4,5264
8111dddc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111dde0:	d0a06217 	ldw	r2,-32376(gp)
8111dde4:	100f883a 	mov	r7,r2
8111dde8:	01800fc4 	movi	r6,63
8111ddec:	01400044 	movi	r5,1
8111ddf0:	01204574 	movhi	r4,33045
8111ddf4:	21053004 	addi	r4,r4,5312
8111ddf8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ddfc:	0001883a 	nop
8111de00:	e037883a 	mov	sp,fp
8111de04:	dfc00117 	ldw	ra,4(sp)
8111de08:	df000017 	ldw	fp,0(sp)
8111de0c:	dec00204 	addi	sp,sp,8
8111de10:	f800283a 	ret

8111de14 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111de14:	defffe04 	addi	sp,sp,-8
8111de18:	de00012e 	bgeu	sp,et,8111de20 <vNoContentInPreParsedBuffer+0xc>
8111de1c:	003b68fa 	trap	3
8111de20:	dfc00115 	stw	ra,4(sp)
8111de24:	df000015 	stw	fp,0(sp)
8111de28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111de2c:	00a045f4 	movhi	r2,33047
8111de30:	10a34f04 	addi	r2,r2,-29380
8111de34:	10800a8b 	ldhu	r2,42(r2)
8111de38:	10bfffcc 	andi	r2,r2,65535
8111de3c:	10800228 	cmpgeui	r2,r2,8
8111de40:	10000e1e 	bne	r2,zero,8111de7c <vNoContentInPreParsedBuffer+0x68>
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111de44:	d0a06217 	ldw	r2,-32376(gp)
8111de48:	100f883a 	mov	r7,r2
8111de4c:	01800904 	movi	r6,36
8111de50:	01400044 	movi	r5,1
8111de54:	01204574 	movhi	r4,33045
8111de58:	21054004 	addi	r4,r4,5376
8111de5c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111de60:	d0a06217 	ldw	r2,-32376(gp)
8111de64:	100f883a 	mov	r7,r2
8111de68:	01801684 	movi	r6,90
8111de6c:	01400044 	movi	r5,1
8111de70:	01204574 	movhi	r4,33045
8111de74:	21054a04 	addi	r4,r4,5416
8111de78:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111de7c:	0001883a 	nop
8111de80:	e037883a 	mov	sp,fp
8111de84:	dfc00117 	ldw	ra,4(sp)
8111de88:	df000017 	ldw	fp,0(sp)
8111de8c:	dec00204 	addi	sp,sp,8
8111de90:	f800283a 	ret

8111de94 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111de94:	defffe04 	addi	sp,sp,-8
8111de98:	de00012e 	bgeu	sp,et,8111dea0 <vCouldNotSendEthConfUART+0xc>
8111de9c:	003b68fa 	trap	3
8111dea0:	dfc00115 	stw	ra,4(sp)
8111dea4:	df000015 	stw	fp,0(sp)
8111dea8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111deac:	00a045f4 	movhi	r2,33047
8111deb0:	10a34f04 	addi	r2,r2,-29380
8111deb4:	10800a8b 	ldhu	r2,42(r2)
8111deb8:	10bfffcc 	andi	r2,r2,65535
8111debc:	10800228 	cmpgeui	r2,r2,8
8111dec0:	10000e1e 	bne	r2,zero,8111defc <vCouldNotSendEthConfUART+0x68>
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111dec4:	d0a06217 	ldw	r2,-32376(gp)
8111dec8:	100f883a 	mov	r7,r2
8111decc:	01800844 	movi	r6,33
8111ded0:	01400044 	movi	r5,1
8111ded4:	01204574 	movhi	r4,33045
8111ded8:	21056104 	addi	r4,r4,5508
8111dedc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111dee0:	d0a06217 	ldw	r2,-32376(gp)
8111dee4:	100f883a 	mov	r7,r2
8111dee8:	01801784 	movi	r6,94
8111deec:	01400044 	movi	r5,1
8111def0:	01204574 	movhi	r4,33045
8111def4:	21056a04 	addi	r4,r4,5544
8111def8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111defc:	0001883a 	nop
8111df00:	e037883a 	mov	sp,fp
8111df04:	dfc00117 	ldw	ra,4(sp)
8111df08:	df000017 	ldw	fp,0(sp)
8111df0c:	dec00204 	addi	sp,sp,8
8111df10:	f800283a 	ret

8111df14 <vFailSendNack>:

void vFailSendNack( void )
{
8111df14:	defffe04 	addi	sp,sp,-8
8111df18:	de00012e 	bgeu	sp,et,8111df20 <vFailSendNack+0xc>
8111df1c:	003b68fa 	trap	3
8111df20:	dfc00115 	stw	ra,4(sp)
8111df24:	df000015 	stw	fp,0(sp)
8111df28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111df2c:	00a045f4 	movhi	r2,33047
8111df30:	10a34f04 	addi	r2,r2,-29380
8111df34:	10800a8b 	ldhu	r2,42(r2)
8111df38:	10bfffcc 	andi	r2,r2,65535
8111df3c:	10800228 	cmpgeui	r2,r2,8
8111df40:	10000e1e 	bne	r2,zero,8111df7c <vFailSendNack+0x68>
		debug(fp,"vFailSendNack. (exit)\n");
8111df44:	d0a06217 	ldw	r2,-32376(gp)
8111df48:	100f883a 	mov	r7,r2
8111df4c:	01800584 	movi	r6,22
8111df50:	01400044 	movi	r5,1
8111df54:	01204574 	movhi	r4,33045
8111df58:	21058204 	addi	r4,r4,5640
8111df5c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111df60:	d0a06217 	ldw	r2,-32376(gp)
8111df64:	100f883a 	mov	r7,r2
8111df68:	01800a84 	movi	r6,42
8111df6c:	01400044 	movi	r5,1
8111df70:	01204574 	movhi	r4,33045
8111df74:	21058804 	addi	r4,r4,5664
8111df78:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111df7c:	0001883a 	nop
8111df80:	e037883a 	mov	sp,fp
8111df84:	dfc00117 	ldw	ra,4(sp)
8111df88:	df000017 	ldw	fp,0(sp)
8111df8c:	dec00204 	addi	sp,sp,8
8111df90:	f800283a 	ret

8111df94 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111df94:	defffe04 	addi	sp,sp,-8
8111df98:	de00012e 	bgeu	sp,et,8111dfa0 <vFailSetPreAckSenderBuffer+0xc>
8111df9c:	003b68fa 	trap	3
8111dfa0:	dfc00115 	stw	ra,4(sp)
8111dfa4:	df000015 	stw	fp,0(sp)
8111dfa8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dfac:	00a045f4 	movhi	r2,33047
8111dfb0:	10a34f04 	addi	r2,r2,-29380
8111dfb4:	10800a8b 	ldhu	r2,42(r2)
8111dfb8:	10bfffcc 	andi	r2,r2,65535
8111dfbc:	10800228 	cmpgeui	r2,r2,8
8111dfc0:	10000e1e 	bne	r2,zero,8111dffc <vFailSetPreAckSenderBuffer+0x68>
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111dfc4:	d0a06217 	ldw	r2,-32376(gp)
8111dfc8:	100f883a 	mov	r7,r2
8111dfcc:	018008c4 	movi	r6,35
8111dfd0:	01400044 	movi	r5,1
8111dfd4:	01204574 	movhi	r4,33045
8111dfd8:	21059304 	addi	r4,r4,5708
8111dfdc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111dfe0:	d0a06217 	ldw	r2,-32376(gp)
8111dfe4:	100f883a 	mov	r7,r2
8111dfe8:	01801584 	movi	r6,86
8111dfec:	01400044 	movi	r5,1
8111dff0:	01204574 	movhi	r4,33045
8111dff4:	21059c04 	addi	r4,r4,5744
8111dff8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dffc:	0001883a 	nop
8111e000:	e037883a 	mov	sp,fp
8111e004:	dfc00117 	ldw	ra,4(sp)
8111e008:	df000017 	ldw	fp,0(sp)
8111e00c:	dec00204 	addi	sp,sp,8
8111e010:	f800283a 	ret

8111e014 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111e014:	defffe04 	addi	sp,sp,-8
8111e018:	de00012e 	bgeu	sp,et,8111e020 <vFailSetPreParsedBuffer+0xc>
8111e01c:	003b68fa 	trap	3
8111e020:	dfc00115 	stw	ra,4(sp)
8111e024:	df000015 	stw	fp,0(sp)
8111e028:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e02c:	00a045f4 	movhi	r2,33047
8111e030:	10a34f04 	addi	r2,r2,-29380
8111e034:	10800a8b 	ldhu	r2,42(r2)
8111e038:	10bfffcc 	andi	r2,r2,65535
8111e03c:	10800228 	cmpgeui	r2,r2,8
8111e040:	10000e1e 	bne	r2,zero,8111e07c <vFailSetPreParsedBuffer+0x68>
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111e044:	d0a06217 	ldw	r2,-32376(gp)
8111e048:	100f883a 	mov	r7,r2
8111e04c:	01800804 	movi	r6,32
8111e050:	01400044 	movi	r5,1
8111e054:	01204574 	movhi	r4,33045
8111e058:	2105b204 	addi	r4,r4,5832
8111e05c:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111e060:	d0a06217 	ldw	r2,-32376(gp)
8111e064:	100f883a 	mov	r7,r2
8111e068:	018013c4 	movi	r6,79
8111e06c:	01400044 	movi	r5,1
8111e070:	01204574 	movhi	r4,33045
8111e074:	2105bb04 	addi	r4,r4,5868
8111e078:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e07c:	0001883a 	nop
8111e080:	e037883a 	mov	sp,fp
8111e084:	dfc00117 	ldw	ra,4(sp)
8111e088:	df000017 	ldw	fp,0(sp)
8111e08c:	dec00204 	addi	sp,sp,8
8111e090:	f800283a 	ret

8111e094 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111e094:	defffe04 	addi	sp,sp,-8
8111e098:	de00012e 	bgeu	sp,et,8111e0a0 <vFailSetPreAckReceiverBuffer+0xc>
8111e09c:	003b68fa 	trap	3
8111e0a0:	dfc00115 	stw	ra,4(sp)
8111e0a4:	df000015 	stw	fp,0(sp)
8111e0a8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e0ac:	00a045f4 	movhi	r2,33047
8111e0b0:	10a34f04 	addi	r2,r2,-29380
8111e0b4:	10800a8b 	ldhu	r2,42(r2)
8111e0b8:	10bfffcc 	andi	r2,r2,65535
8111e0bc:	10800228 	cmpgeui	r2,r2,8
8111e0c0:	10000e1e 	bne	r2,zero,8111e0fc <vFailSetPreAckReceiverBuffer+0x68>
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111e0c4:	d0a06217 	ldw	r2,-32376(gp)
8111e0c8:	100f883a 	mov	r7,r2
8111e0cc:	01800944 	movi	r6,37
8111e0d0:	01400044 	movi	r5,1
8111e0d4:	01204574 	movhi	r4,33045
8111e0d8:	2105cf04 	addi	r4,r4,5948
8111e0dc:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111e0e0:	d0a06217 	ldw	r2,-32376(gp)
8111e0e4:	100f883a 	mov	r7,r2
8111e0e8:	018015c4 	movi	r6,87
8111e0ec:	01400044 	movi	r5,1
8111e0f0:	01204574 	movhi	r4,33045
8111e0f4:	2105d904 	addi	r4,r4,5988
8111e0f8:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e0fc:	0001883a 	nop
8111e100:	e037883a 	mov	sp,fp
8111e104:	dfc00117 	ldw	ra,4(sp)
8111e108:	df000017 	ldw	fp,0(sp)
8111e10c:	dec00204 	addi	sp,sp,8
8111e110:	f800283a 	ret

8111e114 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111e114:	defffe04 	addi	sp,sp,-8
8111e118:	de00012e 	bgeu	sp,et,8111e120 <vFailParserCommTaskCreate+0xc>
8111e11c:	003b68fa 	trap	3
8111e120:	dfc00115 	stw	ra,4(sp)
8111e124:	df000015 	stw	fp,0(sp)
8111e128:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e12c:	00a045f4 	movhi	r2,33047
8111e130:	10a34f04 	addi	r2,r2,-29380
8111e134:	10800a8b 	ldhu	r2,42(r2)
8111e138:	10bfffcc 	andi	r2,r2,65535
8111e13c:	10800228 	cmpgeui	r2,r2,8
8111e140:	1000071e 	bne	r2,zero,8111e160 <vFailParserCommTaskCreate+0x4c>
		debug(fp,"vFailParserCommTaskCreate\n");
8111e144:	d0a06217 	ldw	r2,-32376(gp)
8111e148:	100f883a 	mov	r7,r2
8111e14c:	01800684 	movi	r6,26
8111e150:	01400044 	movi	r5,1
8111e154:	01204574 	movhi	r4,33045
8111e158:	2105ef04 	addi	r4,r4,6076
8111e15c:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e160:	0001883a 	nop
8111e164:	e037883a 	mov	sp,fp
8111e168:	dfc00117 	ldw	ra,4(sp)
8111e16c:	df000017 	ldw	fp,0(sp)
8111e170:	dec00204 	addi	sp,sp,8
8111e174:	f800283a 	ret

8111e178 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111e178:	defffe04 	addi	sp,sp,-8
8111e17c:	de00012e 	bgeu	sp,et,8111e184 <vFailInAckHandlerTaskCreate+0xc>
8111e180:	003b68fa 	trap	3
8111e184:	dfc00115 	stw	ra,4(sp)
8111e188:	df000015 	stw	fp,0(sp)
8111e18c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e190:	00a045f4 	movhi	r2,33047
8111e194:	10a34f04 	addi	r2,r2,-29380
8111e198:	10800a8b 	ldhu	r2,42(r2)
8111e19c:	10bfffcc 	andi	r2,r2,65535
8111e1a0:	10800228 	cmpgeui	r2,r2,8
8111e1a4:	1000071e 	bne	r2,zero,8111e1c4 <vFailInAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111e1a8:	d0a06217 	ldw	r2,-32376(gp)
8111e1ac:	100f883a 	mov	r7,r2
8111e1b0:	01800704 	movi	r6,28
8111e1b4:	01400044 	movi	r5,1
8111e1b8:	01204574 	movhi	r4,33045
8111e1bc:	2105f604 	addi	r4,r4,6104
8111e1c0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e1c4:	0001883a 	nop
8111e1c8:	e037883a 	mov	sp,fp
8111e1cc:	dfc00117 	ldw	ra,4(sp)
8111e1d0:	df000017 	ldw	fp,0(sp)
8111e1d4:	dec00204 	addi	sp,sp,8
8111e1d8:	f800283a 	ret

8111e1dc <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111e1dc:	defffe04 	addi	sp,sp,-8
8111e1e0:	de00012e 	bgeu	sp,et,8111e1e8 <vFailOutAckHandlerTaskCreate+0xc>
8111e1e4:	003b68fa 	trap	3
8111e1e8:	dfc00115 	stw	ra,4(sp)
8111e1ec:	df000015 	stw	fp,0(sp)
8111e1f0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e1f4:	00a045f4 	movhi	r2,33047
8111e1f8:	10a34f04 	addi	r2,r2,-29380
8111e1fc:	10800a8b 	ldhu	r2,42(r2)
8111e200:	10bfffcc 	andi	r2,r2,65535
8111e204:	10800228 	cmpgeui	r2,r2,8
8111e208:	1000071e 	bne	r2,zero,8111e228 <vFailOutAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111e20c:	d0a06217 	ldw	r2,-32376(gp)
8111e210:	100f883a 	mov	r7,r2
8111e214:	01800704 	movi	r6,28
8111e218:	01400044 	movi	r5,1
8111e21c:	01204574 	movhi	r4,33045
8111e220:	2105f604 	addi	r4,r4,6104
8111e224:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e228:	0001883a 	nop
8111e22c:	e037883a 	mov	sp,fp
8111e230:	dfc00117 	ldw	ra,4(sp)
8111e234:	df000017 	ldw	fp,0(sp)
8111e238:	dec00204 	addi	sp,sp,8
8111e23c:	f800283a 	ret

8111e240 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111e240:	defffe04 	addi	sp,sp,-8
8111e244:	de00012e 	bgeu	sp,et,8111e24c <vFailCreateTimerRetransmisison+0xc>
8111e248:	003b68fa 	trap	3
8111e24c:	dfc00115 	stw	ra,4(sp)
8111e250:	df000015 	stw	fp,0(sp)
8111e254:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e258:	00a045f4 	movhi	r2,33047
8111e25c:	10a34f04 	addi	r2,r2,-29380
8111e260:	10800a8b 	ldhu	r2,42(r2)
8111e264:	10bfffcc 	andi	r2,r2,65535
8111e268:	10800228 	cmpgeui	r2,r2,8
8111e26c:	1000071e 	bne	r2,zero,8111e28c <vFailCreateTimerRetransmisison+0x4c>
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111e270:	d0a06217 	ldw	r2,-32376(gp)
8111e274:	100f883a 	mov	r7,r2
8111e278:	018007c4 	movi	r6,31
8111e27c:	01400044 	movi	r5,1
8111e280:	01204574 	movhi	r4,33045
8111e284:	2105fe04 	addi	r4,r4,6136
8111e288:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e28c:	0001883a 	nop
8111e290:	e037883a 	mov	sp,fp
8111e294:	dfc00117 	ldw	ra,4(sp)
8111e298:	df000017 	ldw	fp,0(sp)
8111e29c:	dec00204 	addi	sp,sp,8
8111e2a0:	f800283a 	ret

8111e2a4 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111e2a4:	defffe04 	addi	sp,sp,-8
8111e2a8:	de00012e 	bgeu	sp,et,8111e2b0 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111e2ac:	003b68fa 	trap	3
8111e2b0:	dfc00115 	stw	ra,4(sp)
8111e2b4:	df000015 	stw	fp,0(sp)
8111e2b8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e2bc:	00a045f4 	movhi	r2,33047
8111e2c0:	10a34f04 	addi	r2,r2,-29380
8111e2c4:	10800a8b 	ldhu	r2,42(r2)
8111e2c8:	10bfffcc 	andi	r2,r2,65535
8111e2cc:	10800228 	cmpgeui	r2,r2,8
8111e2d0:	1000071e 	bne	r2,zero,8111e2f0 <vCouldNotCheckBufferTimeOutFunction+0x4c>
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111e2d4:	d0a06217 	ldw	r2,-32376(gp)
8111e2d8:	100f883a 	mov	r7,r2
8111e2dc:	01800904 	movi	r6,36
8111e2e0:	01400044 	movi	r5,1
8111e2e4:	01204574 	movhi	r4,33045
8111e2e8:	21060604 	addi	r4,r4,6168
8111e2ec:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e2f0:	0001883a 	nop
8111e2f4:	e037883a 	mov	sp,fp
8111e2f8:	dfc00117 	ldw	ra,4(sp)
8111e2fc:	df000017 	ldw	fp,0(sp)
8111e300:	dec00204 	addi	sp,sp,8
8111e304:	f800283a 	ret

8111e308 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111e308:	defffe04 	addi	sp,sp,-8
8111e30c:	de00012e 	bgeu	sp,et,8111e314 <vFailTimeoutCheckerTaskCreate+0xc>
8111e310:	003b68fa 	trap	3
8111e314:	dfc00115 	stw	ra,4(sp)
8111e318:	df000015 	stw	fp,0(sp)
8111e31c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e320:	00a045f4 	movhi	r2,33047
8111e324:	10a34f04 	addi	r2,r2,-29380
8111e328:	10800a8b 	ldhu	r2,42(r2)
8111e32c:	10bfffcc 	andi	r2,r2,65535
8111e330:	10800228 	cmpgeui	r2,r2,8
8111e334:	1000071e 	bne	r2,zero,8111e354 <vFailTimeoutCheckerTaskCreate+0x4c>
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111e338:	d0a06217 	ldw	r2,-32376(gp)
8111e33c:	100f883a 	mov	r7,r2
8111e340:	01800a04 	movi	r6,40
8111e344:	01400044 	movi	r5,1
8111e348:	01204574 	movhi	r4,33045
8111e34c:	21061004 	addi	r4,r4,6208
8111e350:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e354:	0001883a 	nop
8111e358:	e037883a 	mov	sp,fp
8111e35c:	dfc00117 	ldw	ra,4(sp)
8111e360:	df000017 	ldw	fp,0(sp)
8111e364:	dec00204 	addi	sp,sp,8
8111e368:	f800283a 	ret

8111e36c <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111e36c:	defffe04 	addi	sp,sp,-8
8111e370:	de00012e 	bgeu	sp,et,8111e378 <vFailGetBlockingSemTimeoutTask+0xc>
8111e374:	003b68fa 	trap	3
8111e378:	dfc00115 	stw	ra,4(sp)
8111e37c:	df000015 	stw	fp,0(sp)
8111e380:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e384:	00a045f4 	movhi	r2,33047
8111e388:	10a34f04 	addi	r2,r2,-29380
8111e38c:	10800a8b 	ldhu	r2,42(r2)
8111e390:	10bfffcc 	andi	r2,r2,65535
8111e394:	10800228 	cmpgeui	r2,r2,8
8111e398:	10000e1e 	bne	r2,zero,8111e3d4 <vFailGetBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111e39c:	d0a06217 	ldw	r2,-32376(gp)
8111e3a0:	100f883a 	mov	r7,r2
8111e3a4:	018009c4 	movi	r6,39
8111e3a8:	01400044 	movi	r5,1
8111e3ac:	01204574 	movhi	r4,33045
8111e3b0:	21061b04 	addi	r4,r4,6252
8111e3b4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111e3b8:	d0a06217 	ldw	r2,-32376(gp)
8111e3bc:	100f883a 	mov	r7,r2
8111e3c0:	01800cc4 	movi	r6,51
8111e3c4:	01400044 	movi	r5,1
8111e3c8:	01204574 	movhi	r4,33045
8111e3cc:	21062504 	addi	r4,r4,6292
8111e3d0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e3d4:	0001883a 	nop
8111e3d8:	e037883a 	mov	sp,fp
8111e3dc:	dfc00117 	ldw	ra,4(sp)
8111e3e0:	df000017 	ldw	fp,0(sp)
8111e3e4:	dec00204 	addi	sp,sp,8
8111e3e8:	f800283a 	ret

8111e3ec <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111e3ec:	defffe04 	addi	sp,sp,-8
8111e3f0:	de00012e 	bgeu	sp,et,8111e3f8 <vFailPostBlockingSemTimeoutTask+0xc>
8111e3f4:	003b68fa 	trap	3
8111e3f8:	dfc00115 	stw	ra,4(sp)
8111e3fc:	df000015 	stw	fp,0(sp)
8111e400:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e404:	00a045f4 	movhi	r2,33047
8111e408:	10a34f04 	addi	r2,r2,-29380
8111e40c:	10800a8b 	ldhu	r2,42(r2)
8111e410:	10bfffcc 	andi	r2,r2,65535
8111e414:	10800228 	cmpgeui	r2,r2,8
8111e418:	10000e1e 	bne	r2,zero,8111e454 <vFailPostBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111e41c:	d0a06217 	ldw	r2,-32376(gp)
8111e420:	100f883a 	mov	r7,r2
8111e424:	01800a04 	movi	r6,40
8111e428:	01400044 	movi	r5,1
8111e42c:	01204574 	movhi	r4,33045
8111e430:	21063204 	addi	r4,r4,6344
8111e434:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111e438:	d0a06217 	ldw	r2,-32376(gp)
8111e43c:	100f883a 	mov	r7,r2
8111e440:	01800c84 	movi	r6,50
8111e444:	01400044 	movi	r5,1
8111e448:	01204574 	movhi	r4,33045
8111e44c:	21063d04 	addi	r4,r4,6388
8111e450:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e454:	0001883a 	nop
8111e458:	e037883a 	mov	sp,fp
8111e45c:	dfc00117 	ldw	ra,4(sp)
8111e460:	df000017 	ldw	fp,0(sp)
8111e464:	dec00204 	addi	sp,sp,8
8111e468:	f800283a 	ret

8111e46c <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111e46c:	defffe04 	addi	sp,sp,-8
8111e470:	de00012e 	bgeu	sp,et,8111e478 <vFailCouldNotRetransmitTimeoutTask+0xc>
8111e474:	003b68fa 	trap	3
8111e478:	dfc00115 	stw	ra,4(sp)
8111e47c:	df000015 	stw	fp,0(sp)
8111e480:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e484:	00a045f4 	movhi	r2,33047
8111e488:	10a34f04 	addi	r2,r2,-29380
8111e48c:	10800a8b 	ldhu	r2,42(r2)
8111e490:	10bfffcc 	andi	r2,r2,65535
8111e494:	10800228 	cmpgeui	r2,r2,8
8111e498:	10000e1e 	bne	r2,zero,8111e4d4 <vFailCouldNotRetransmitTimeoutTask+0x68>
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111e49c:	d0a06217 	ldw	r2,-32376(gp)
8111e4a0:	100f883a 	mov	r7,r2
8111e4a4:	01800ac4 	movi	r6,43
8111e4a8:	01400044 	movi	r5,1
8111e4ac:	01204574 	movhi	r4,33045
8111e4b0:	21064a04 	addi	r4,r4,6440
8111e4b4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111e4b8:	d0a06217 	ldw	r2,-32376(gp)
8111e4bc:	100f883a 	mov	r7,r2
8111e4c0:	01801644 	movi	r6,89
8111e4c4:	01400044 	movi	r5,1
8111e4c8:	01204574 	movhi	r4,33045
8111e4cc:	21065504 	addi	r4,r4,6484
8111e4d0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e4d4:	0001883a 	nop
8111e4d8:	e037883a 	mov	sp,fp
8111e4dc:	dfc00117 	ldw	ra,4(sp)
8111e4e0:	df000017 	ldw	fp,0(sp)
8111e4e4:	dec00204 	addi	sp,sp,8
8111e4e8:	f800283a 	ret

8111e4ec <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111e4ec:	defffe04 	addi	sp,sp,-8
8111e4f0:	de00012e 	bgeu	sp,et,8111e4f8 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111e4f4:	003b68fa 	trap	3
8111e4f8:	dfc00115 	stw	ra,4(sp)
8111e4fc:	df000015 	stw	fp,0(sp)
8111e500:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e504:	00a045f4 	movhi	r2,33047
8111e508:	10a34f04 	addi	r2,r2,-29380
8111e50c:	10800a8b 	ldhu	r2,42(r2)
8111e510:	10bfffcc 	andi	r2,r2,65535
8111e514:	10800228 	cmpgeui	r2,r2,8
8111e518:	10000e1e 	bne	r2,zero,8111e554 <vCouldNotRetransmitB32TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111e51c:	d0a06217 	ldw	r2,-32376(gp)
8111e520:	100f883a 	mov	r7,r2
8111e524:	01800a84 	movi	r6,42
8111e528:	01400044 	movi	r5,1
8111e52c:	01204574 	movhi	r4,33045
8111e530:	21066c04 	addi	r4,r4,6576
8111e534:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111e538:	d0a06217 	ldw	r2,-32376(gp)
8111e53c:	100f883a 	mov	r7,r2
8111e540:	01801444 	movi	r6,81
8111e544:	01400044 	movi	r5,1
8111e548:	01204574 	movhi	r4,33045
8111e54c:	21067704 	addi	r4,r4,6620
8111e550:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e554:	0001883a 	nop
8111e558:	e037883a 	mov	sp,fp
8111e55c:	dfc00117 	ldw	ra,4(sp)
8111e560:	df000017 	ldw	fp,0(sp)
8111e564:	dec00204 	addi	sp,sp,8
8111e568:	f800283a 	ret

8111e56c <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111e56c:	defffe04 	addi	sp,sp,-8
8111e570:	de00012e 	bgeu	sp,et,8111e578 <vCouldNotRetransmitB64TimeoutTask+0xc>
8111e574:	003b68fa 	trap	3
8111e578:	dfc00115 	stw	ra,4(sp)
8111e57c:	df000015 	stw	fp,0(sp)
8111e580:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e584:	00a045f4 	movhi	r2,33047
8111e588:	10a34f04 	addi	r2,r2,-29380
8111e58c:	10800a8b 	ldhu	r2,42(r2)
8111e590:	10bfffcc 	andi	r2,r2,65535
8111e594:	10800228 	cmpgeui	r2,r2,8
8111e598:	10000e1e 	bne	r2,zero,8111e5d4 <vCouldNotRetransmitB64TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111e59c:	d0a06217 	ldw	r2,-32376(gp)
8111e5a0:	100f883a 	mov	r7,r2
8111e5a4:	01800a84 	movi	r6,42
8111e5a8:	01400044 	movi	r5,1
8111e5ac:	01204574 	movhi	r4,33045
8111e5b0:	21068c04 	addi	r4,r4,6704
8111e5b4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111e5b8:	d0a06217 	ldw	r2,-32376(gp)
8111e5bc:	100f883a 	mov	r7,r2
8111e5c0:	01801444 	movi	r6,81
8111e5c4:	01400044 	movi	r5,1
8111e5c8:	01204574 	movhi	r4,33045
8111e5cc:	21069704 	addi	r4,r4,6748
8111e5d0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e5d4:	0001883a 	nop
8111e5d8:	e037883a 	mov	sp,fp
8111e5dc:	dfc00117 	ldw	ra,4(sp)
8111e5e0:	df000017 	ldw	fp,0(sp)
8111e5e4:	dec00204 	addi	sp,sp,8
8111e5e8:	f800283a 	ret

8111e5ec <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111e5ec:	defffe04 	addi	sp,sp,-8
8111e5f0:	de00012e 	bgeu	sp,et,8111e5f8 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111e5f4:	003b68fa 	trap	3
8111e5f8:	dfc00115 	stw	ra,4(sp)
8111e5fc:	df000015 	stw	fp,0(sp)
8111e600:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e604:	00a045f4 	movhi	r2,33047
8111e608:	10a34f04 	addi	r2,r2,-29380
8111e60c:	10800a8b 	ldhu	r2,42(r2)
8111e610:	10bfffcc 	andi	r2,r2,65535
8111e614:	10800228 	cmpgeui	r2,r2,8
8111e618:	10000e1e 	bne	r2,zero,8111e654 <vCouldNotRetransmitB128TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111e61c:	d0a06217 	ldw	r2,-32376(gp)
8111e620:	100f883a 	mov	r7,r2
8111e624:	01800ac4 	movi	r6,43
8111e628:	01400044 	movi	r5,1
8111e62c:	01204574 	movhi	r4,33045
8111e630:	2106ac04 	addi	r4,r4,6832
8111e634:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111e638:	d0a06217 	ldw	r2,-32376(gp)
8111e63c:	100f883a 	mov	r7,r2
8111e640:	01801484 	movi	r6,82
8111e644:	01400044 	movi	r5,1
8111e648:	01204574 	movhi	r4,33045
8111e64c:	2106b704 	addi	r4,r4,6876
8111e650:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e654:	0001883a 	nop
8111e658:	e037883a 	mov	sp,fp
8111e65c:	dfc00117 	ldw	ra,4(sp)
8111e660:	df000017 	ldw	fp,0(sp)
8111e664:	dec00204 	addi	sp,sp,8
8111e668:	f800283a 	ret

8111e66c <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111e66c:	defffe04 	addi	sp,sp,-8
8111e670:	de00012e 	bgeu	sp,et,8111e678 <vFailStartTimerRetransmission+0xc>
8111e674:	003b68fa 	trap	3
8111e678:	dfc00115 	stw	ra,4(sp)
8111e67c:	df000015 	stw	fp,0(sp)
8111e680:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e684:	00a045f4 	movhi	r2,33047
8111e688:	10a34f04 	addi	r2,r2,-29380
8111e68c:	10800a8b 	ldhu	r2,42(r2)
8111e690:	10bfffcc 	andi	r2,r2,65535
8111e694:	10800228 	cmpgeui	r2,r2,8
8111e698:	10000e1e 	bne	r2,zero,8111e6d4 <vFailStartTimerRetransmission+0x68>
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111e69c:	d0a06217 	ldw	r2,-32376(gp)
8111e6a0:	100f883a 	mov	r7,r2
8111e6a4:	01800984 	movi	r6,38
8111e6a8:	01400044 	movi	r5,1
8111e6ac:	01204574 	movhi	r4,33045
8111e6b0:	2106cc04 	addi	r4,r4,6960
8111e6b4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111e6b8:	d0a06217 	ldw	r2,-32376(gp)
8111e6bc:	100f883a 	mov	r7,r2
8111e6c0:	01800d44 	movi	r6,53
8111e6c4:	01400044 	movi	r5,1
8111e6c8:	01204574 	movhi	r4,33045
8111e6cc:	2106d604 	addi	r4,r4,7000
8111e6d0:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e6d4:	0001883a 	nop
8111e6d8:	e037883a 	mov	sp,fp
8111e6dc:	dfc00117 	ldw	ra,4(sp)
8111e6e0:	df000017 	ldw	fp,0(sp)
8111e6e4:	dec00204 	addi	sp,sp,8
8111e6e8:	f800283a 	ret

8111e6ec <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111e6ec:	defffe04 	addi	sp,sp,-8
8111e6f0:	de00012e 	bgeu	sp,et,8111e6f8 <vCouldNotSendTurnOff+0xc>
8111e6f4:	003b68fa 	trap	3
8111e6f8:	dfc00115 	stw	ra,4(sp)
8111e6fc:	df000015 	stw	fp,0(sp)
8111e700:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e704:	00a045f4 	movhi	r2,33047
8111e708:	10a34f04 	addi	r2,r2,-29380
8111e70c:	10800a8b 	ldhu	r2,42(r2)
8111e710:	10bfffcc 	andi	r2,r2,65535
8111e714:	10800228 	cmpgeui	r2,r2,8
8111e718:	10000e1e 	bne	r2,zero,8111e754 <vCouldNotSendTurnOff+0x68>
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111e71c:	d0a06217 	ldw	r2,-32376(gp)
8111e720:	100f883a 	mov	r7,r2
8111e724:	01800744 	movi	r6,29
8111e728:	01400044 	movi	r5,1
8111e72c:	01204574 	movhi	r4,33045
8111e730:	2106e404 	addi	r4,r4,7056
8111e734:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the turn off command. \n");
8111e738:	d0a06217 	ldw	r2,-32376(gp)
8111e73c:	100f883a 	mov	r7,r2
8111e740:	01800984 	movi	r6,38
8111e744:	01400044 	movi	r5,1
8111e748:	01204574 	movhi	r4,33045
8111e74c:	2106ec04 	addi	r4,r4,7088
8111e750:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e754:	0001883a 	nop
8111e758:	e037883a 	mov	sp,fp
8111e75c:	dfc00117 	ldw	ra,4(sp)
8111e760:	df000017 	ldw	fp,0(sp)
8111e764:	dec00204 	addi	sp,sp,8
8111e768:	f800283a 	ret

8111e76c <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111e76c:	defffe04 	addi	sp,sp,-8
8111e770:	de00012e 	bgeu	sp,et,8111e778 <vCouldNotSendReset+0xc>
8111e774:	003b68fa 	trap	3
8111e778:	dfc00115 	stw	ra,4(sp)
8111e77c:	df000015 	stw	fp,0(sp)
8111e780:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e784:	00a045f4 	movhi	r2,33047
8111e788:	10a34f04 	addi	r2,r2,-29380
8111e78c:	10800a8b 	ldhu	r2,42(r2)
8111e790:	10bfffcc 	andi	r2,r2,65535
8111e794:	10800228 	cmpgeui	r2,r2,8
8111e798:	10000e1e 	bne	r2,zero,8111e7d4 <vCouldNotSendReset+0x68>
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111e79c:	d0a06217 	ldw	r2,-32376(gp)
8111e7a0:	100f883a 	mov	r7,r2
8111e7a4:	018006c4 	movi	r6,27
8111e7a8:	01400044 	movi	r5,1
8111e7ac:	01204574 	movhi	r4,33045
8111e7b0:	2106f604 	addi	r4,r4,7128
8111e7b4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the reset command. \n");
8111e7b8:	d0a06217 	ldw	r2,-32376(gp)
8111e7bc:	100f883a 	mov	r7,r2
8111e7c0:	018008c4 	movi	r6,35
8111e7c4:	01400044 	movi	r5,1
8111e7c8:	01204574 	movhi	r4,33045
8111e7cc:	2106fd04 	addi	r4,r4,7156
8111e7d0:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e7d4:	0001883a 	nop
8111e7d8:	e037883a 	mov	sp,fp
8111e7dc:	dfc00117 	ldw	ra,4(sp)
8111e7e0:	df000017 	ldw	fp,0(sp)
8111e7e4:	dec00204 	addi	sp,sp,8
8111e7e8:	f800283a 	ret

8111e7ec <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111e7ec:	defffe04 	addi	sp,sp,-8
8111e7f0:	de00012e 	bgeu	sp,et,8111e7f8 <vCouldNotSendLog+0xc>
8111e7f4:	003b68fa 	trap	3
8111e7f8:	dfc00115 	stw	ra,4(sp)
8111e7fc:	df000015 	stw	fp,0(sp)
8111e800:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e804:	00a045f4 	movhi	r2,33047
8111e808:	10a34f04 	addi	r2,r2,-29380
8111e80c:	10800a8b 	ldhu	r2,42(r2)
8111e810:	10bfffcc 	andi	r2,r2,65535
8111e814:	10800228 	cmpgeui	r2,r2,8
8111e818:	10000e1e 	bne	r2,zero,8111e854 <vCouldNotSendLog+0x68>
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111e81c:	d0a06217 	ldw	r2,-32376(gp)
8111e820:	100f883a 	mov	r7,r2
8111e824:	01800644 	movi	r6,25
8111e828:	01400044 	movi	r5,1
8111e82c:	01204574 	movhi	r4,33045
8111e830:	21070604 	addi	r4,r4,7192
8111e834:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send log packet to NUC. \n");
8111e838:	d0a06217 	ldw	r2,-32376(gp)
8111e83c:	100f883a 	mov	r7,r2
8111e840:	018008c4 	movi	r6,35
8111e844:	01400044 	movi	r5,1
8111e848:	01204574 	movhi	r4,33045
8111e84c:	21070d04 	addi	r4,r4,7220
8111e850:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e854:	0001883a 	nop
8111e858:	e037883a 	mov	sp,fp
8111e85c:	dfc00117 	ldw	ra,4(sp)
8111e860:	df000017 	ldw	fp,0(sp)
8111e864:	dec00204 	addi	sp,sp,8
8111e868:	f800283a 	ret

8111e86c <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111e86c:	defffd04 	addi	sp,sp,-12
8111e870:	de00012e 	bgeu	sp,et,8111e878 <vCouldNotSendTMPusCommand+0xc>
8111e874:	003b68fa 	trap	3
8111e878:	dfc00215 	stw	ra,8(sp)
8111e87c:	df000115 	stw	fp,4(sp)
8111e880:	df000104 	addi	fp,sp,4
8111e884:	e13fff15 	stw	r4,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e888:	00a045f4 	movhi	r2,33047
8111e88c:	10a34f04 	addi	r2,r2,-29380
8111e890:	10800a8b 	ldhu	r2,42(r2)
8111e894:	10bfffcc 	andi	r2,r2,65535
8111e898:	10800228 	cmpgeui	r2,r2,8
8111e89c:	1000151e 	bne	r2,zero,8111e8f4 <vCouldNotSendTMPusCommand+0x88>
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111e8a0:	d0a06217 	ldw	r2,-32376(gp)
8111e8a4:	100f883a 	mov	r7,r2
8111e8a8:	01800884 	movi	r6,34
8111e8ac:	01400044 	movi	r5,1
8111e8b0:	01204574 	movhi	r4,33045
8111e8b4:	21071604 	addi	r4,r4,7256
8111e8b8:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111e8bc:	d0a06217 	ldw	r2,-32376(gp)
8111e8c0:	100f883a 	mov	r7,r2
8111e8c4:	01800ac4 	movi	r6,43
8111e8c8:	01400044 	movi	r5,1
8111e8cc:	01204574 	movhi	r4,33045
8111e8d0:	21071f04 	addi	r4,r4,7292
8111e8d4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"cData");
8111e8d8:	d0a06217 	ldw	r2,-32376(gp)
8111e8dc:	100f883a 	mov	r7,r2
8111e8e0:	01800144 	movi	r6,5
8111e8e4:	01400044 	movi	r5,1
8111e8e8:	01204574 	movhi	r4,33045
8111e8ec:	21072a04 	addi	r4,r4,7336
8111e8f0:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e8f4:	0001883a 	nop
8111e8f8:	e037883a 	mov	sp,fp
8111e8fc:	dfc00117 	ldw	ra,4(sp)
8111e900:	df000017 	ldw	fp,0(sp)
8111e904:	dec00204 	addi	sp,sp,8
8111e908:	f800283a 	ret

8111e90c <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111e90c:	defffe04 	addi	sp,sp,-8
8111e910:	de00012e 	bgeu	sp,et,8111e918 <vWarnCouldNotgetMutexRetrans128+0xc>
8111e914:	003b68fa 	trap	3
8111e918:	dfc00115 	stw	ra,4(sp)
8111e91c:	df000015 	stw	fp,0(sp)
8111e920:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e924:	00a045f4 	movhi	r2,33047
8111e928:	10a34f04 	addi	r2,r2,-29380
8111e92c:	10800a8b 	ldhu	r2,42(r2)
8111e930:	10bfffcc 	andi	r2,r2,65535
8111e934:	10800228 	cmpgeui	r2,r2,8
8111e938:	10000e1e 	bne	r2,zero,8111e974 <vWarnCouldNotgetMutexRetrans128+0x68>
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111e93c:	d0a06217 	ldw	r2,-32376(gp)
8111e940:	100f883a 	mov	r7,r2
8111e944:	01800a04 	movi	r6,40
8111e948:	01400044 	movi	r5,1
8111e94c:	01204574 	movhi	r4,33045
8111e950:	21072c04 	addi	r4,r4,7344
8111e954:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111e958:	d0a06217 	ldw	r2,-32376(gp)
8111e95c:	100f883a 	mov	r7,r2
8111e960:	018014c4 	movi	r6,83
8111e964:	01400044 	movi	r5,1
8111e968:	01204574 	movhi	r4,33045
8111e96c:	21073704 	addi	r4,r4,7388
8111e970:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e974:	0001883a 	nop
8111e978:	e037883a 	mov	sp,fp
8111e97c:	dfc00117 	ldw	ra,4(sp)
8111e980:	df000017 	ldw	fp,0(sp)
8111e984:	dec00204 	addi	sp,sp,8
8111e988:	f800283a 	ret

8111e98c <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111e98c:	defffe04 	addi	sp,sp,-8
8111e990:	de00012e 	bgeu	sp,et,8111e998 <vFailCreateScheduleQueue+0xc>
8111e994:	003b68fa 	trap	3
8111e998:	dfc00115 	stw	ra,4(sp)
8111e99c:	df000015 	stw	fp,0(sp)
8111e9a0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e9a4:	00a045f4 	movhi	r2,33047
8111e9a8:	10a34f04 	addi	r2,r2,-29380
8111e9ac:	10800a8b 	ldhu	r2,42(r2)
8111e9b0:	10bfffcc 	andi	r2,r2,65535
8111e9b4:	10800228 	cmpgeui	r2,r2,8
8111e9b8:	10000e1e 	bne	r2,zero,8111e9f4 <vFailCreateScheduleQueue+0x68>
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111e9bc:	d0a06217 	ldw	r2,-32376(gp)
8111e9c0:	100f883a 	mov	r7,r2
8111e9c4:	01800844 	movi	r6,33
8111e9c8:	01400044 	movi	r5,1
8111e9cc:	01204574 	movhi	r4,33045
8111e9d0:	21074c04 	addi	r4,r4,7472
8111e9d4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111e9d8:	d0a06217 	ldw	r2,-32376(gp)
8111e9dc:	100f883a 	mov	r7,r2
8111e9e0:	01801204 	movi	r6,72
8111e9e4:	01400044 	movi	r5,1
8111e9e8:	01204574 	movhi	r4,33045
8111e9ec:	21075504 	addi	r4,r4,7508
8111e9f0:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e9f4:	0001883a 	nop
8111e9f8:	e037883a 	mov	sp,fp
8111e9fc:	dfc00117 	ldw	ra,4(sp)
8111ea00:	df000017 	ldw	fp,0(sp)
8111ea04:	dec00204 	addi	sp,sp,8
8111ea08:	f800283a 	ret

8111ea0c <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111ea0c:	defffd04 	addi	sp,sp,-12
8111ea10:	de00012e 	bgeu	sp,et,8111ea18 <vFailCreateNFEEQueue+0xc>
8111ea14:	003b68fa 	trap	3
8111ea18:	dfc00215 	stw	ra,8(sp)
8111ea1c:	df000115 	stw	fp,4(sp)
8111ea20:	df000104 	addi	fp,sp,4
8111ea24:	2005883a 	mov	r2,r4
8111ea28:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea2c:	00a045f4 	movhi	r2,33047
8111ea30:	10a34f04 	addi	r2,r2,-29380
8111ea34:	10800a8b 	ldhu	r2,42(r2)
8111ea38:	10bfffcc 	andi	r2,r2,65535
8111ea3c:	10800228 	cmpgeui	r2,r2,8
8111ea40:	10000e1e 	bne	r2,zero,8111ea7c <vFailCreateNFEEQueue+0x70>
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111ea44:	d0a06217 	ldw	r2,-32376(gp)
8111ea48:	100f883a 	mov	r7,r2
8111ea4c:	01800744 	movi	r6,29
8111ea50:	01400044 	movi	r5,1
8111ea54:	01204574 	movhi	r4,33045
8111ea58:	21076804 	addi	r4,r4,7584
8111ea5c:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111ea60:	d0a06217 	ldw	r2,-32376(gp)
8111ea64:	e0ffff03 	ldbu	r3,-4(fp)
8111ea68:	180d883a 	mov	r6,r3
8111ea6c:	01604574 	movhi	r5,33045
8111ea70:	29477004 	addi	r5,r5,7616
8111ea74:	1009883a 	mov	r4,r2
8111ea78:	11236500 	call	81123650 <fprintf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ea7c:	0001883a 	nop
8111ea80:	e037883a 	mov	sp,fp
8111ea84:	dfc00117 	ldw	ra,4(sp)
8111ea88:	df000017 	ldw	fp,0(sp)
8111ea8c:	dec00204 	addi	sp,sp,8
8111ea90:	f800283a 	ret

8111ea94 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111ea94:	defffd04 	addi	sp,sp,-12
8111ea98:	de00012e 	bgeu	sp,et,8111eaa0 <vFailCreateNFEESyncQueue+0xc>
8111ea9c:	003b68fa 	trap	3
8111eaa0:	dfc00215 	stw	ra,8(sp)
8111eaa4:	df000115 	stw	fp,4(sp)
8111eaa8:	df000104 	addi	fp,sp,4
8111eaac:	2005883a 	mov	r2,r4
8111eab0:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eab4:	00a045f4 	movhi	r2,33047
8111eab8:	10a34f04 	addi	r2,r2,-29380
8111eabc:	10800a8b 	ldhu	r2,42(r2)
8111eac0:	10bfffcc 	andi	r2,r2,65535
8111eac4:	10800228 	cmpgeui	r2,r2,8
8111eac8:	10000e1e 	bne	r2,zero,8111eb04 <vFailCreateNFEESyncQueue+0x70>
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111eacc:	d0a06217 	ldw	r2,-32376(gp)
8111ead0:	100f883a 	mov	r7,r2
8111ead4:	01800844 	movi	r6,33
8111ead8:	01400044 	movi	r5,1
8111eadc:	01204574 	movhi	r4,33045
8111eae0:	21077e04 	addi	r4,r4,7672
8111eae4:	1123cec0 	call	81123cec <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111eae8:	d0a06217 	ldw	r2,-32376(gp)
8111eaec:	e0ffff03 	ldbu	r3,-4(fp)
8111eaf0:	180d883a 	mov	r6,r3
8111eaf4:	01604574 	movhi	r5,33045
8111eaf8:	29478704 	addi	r5,r5,7708
8111eafc:	1009883a 	mov	r4,r2
8111eb00:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb04:	0001883a 	nop
8111eb08:	e037883a 	mov	sp,fp
8111eb0c:	dfc00117 	ldw	ra,4(sp)
8111eb10:	df000017 	ldw	fp,0(sp)
8111eb14:	dec00204 	addi	sp,sp,8
8111eb18:	f800283a 	ret

8111eb1c <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111eb1c:	defffe04 	addi	sp,sp,-8
8111eb20:	de00012e 	bgeu	sp,et,8111eb28 <vCoudlNotCreateNFee0Task+0xc>
8111eb24:	003b68fa 	trap	3
8111eb28:	dfc00115 	stw	ra,4(sp)
8111eb2c:	df000015 	stw	fp,0(sp)
8111eb30:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eb34:	00a045f4 	movhi	r2,33047
8111eb38:	10a34f04 	addi	r2,r2,-29380
8111eb3c:	10800a8b 	ldhu	r2,42(r2)
8111eb40:	10bfffcc 	andi	r2,r2,65535
8111eb44:	10800228 	cmpgeui	r2,r2,8
8111eb48:	10000e1e 	bne	r2,zero,8111eb84 <vCoudlNotCreateNFee0Task+0x68>
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111eb4c:	d0a06217 	ldw	r2,-32376(gp)
8111eb50:	100f883a 	mov	r7,r2
8111eb54:	01800844 	movi	r6,33
8111eb58:	01400044 	movi	r5,1
8111eb5c:	01204574 	movhi	r4,33045
8111eb60:	21079504 	addi	r4,r4,7764
8111eb64:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE 0 Task.\n");
8111eb68:	d0a06217 	ldw	r2,-32376(gp)
8111eb6c:	100f883a 	mov	r7,r2
8111eb70:	01800784 	movi	r6,30
8111eb74:	01400044 	movi	r5,1
8111eb78:	01204574 	movhi	r4,33045
8111eb7c:	21079e04 	addi	r4,r4,7800
8111eb80:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb84:	0001883a 	nop
8111eb88:	e037883a 	mov	sp,fp
8111eb8c:	dfc00117 	ldw	ra,4(sp)
8111eb90:	df000017 	ldw	fp,0(sp)
8111eb94:	dec00204 	addi	sp,sp,8
8111eb98:	f800283a 	ret

8111eb9c <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111eb9c:	defffe04 	addi	sp,sp,-8
8111eba0:	de00012e 	bgeu	sp,et,8111eba8 <vCoudlNotCreateNFee1Task+0xc>
8111eba4:	003b68fa 	trap	3
8111eba8:	dfc00115 	stw	ra,4(sp)
8111ebac:	df000015 	stw	fp,0(sp)
8111ebb0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ebb4:	00a045f4 	movhi	r2,33047
8111ebb8:	10a34f04 	addi	r2,r2,-29380
8111ebbc:	10800a8b 	ldhu	r2,42(r2)
8111ebc0:	10bfffcc 	andi	r2,r2,65535
8111ebc4:	10800228 	cmpgeui	r2,r2,8
8111ebc8:	10000e1e 	bne	r2,zero,8111ec04 <vCoudlNotCreateNFee1Task+0x68>
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111ebcc:	d0a06217 	ldw	r2,-32376(gp)
8111ebd0:	100f883a 	mov	r7,r2
8111ebd4:	01800844 	movi	r6,33
8111ebd8:	01400044 	movi	r5,1
8111ebdc:	01204574 	movhi	r4,33045
8111ebe0:	2107a604 	addi	r4,r4,7832
8111ebe4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE 1 Task.\n");
8111ebe8:	d0a06217 	ldw	r2,-32376(gp)
8111ebec:	100f883a 	mov	r7,r2
8111ebf0:	01800784 	movi	r6,30
8111ebf4:	01400044 	movi	r5,1
8111ebf8:	01204574 	movhi	r4,33045
8111ebfc:	2107af04 	addi	r4,r4,7868
8111ec00:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ec04:	0001883a 	nop
8111ec08:	e037883a 	mov	sp,fp
8111ec0c:	dfc00117 	ldw	ra,4(sp)
8111ec10:	df000017 	ldw	fp,0(sp)
8111ec14:	dec00204 	addi	sp,sp,8
8111ec18:	f800283a 	ret

8111ec1c <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111ec1c:	defffe04 	addi	sp,sp,-8
8111ec20:	de00012e 	bgeu	sp,et,8111ec28 <vCoudlNotCreateNFee2Task+0xc>
8111ec24:	003b68fa 	trap	3
8111ec28:	dfc00115 	stw	ra,4(sp)
8111ec2c:	df000015 	stw	fp,0(sp)
8111ec30:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ec34:	00a045f4 	movhi	r2,33047
8111ec38:	10a34f04 	addi	r2,r2,-29380
8111ec3c:	10800a8b 	ldhu	r2,42(r2)
8111ec40:	10bfffcc 	andi	r2,r2,65535
8111ec44:	10800228 	cmpgeui	r2,r2,8
8111ec48:	10000e1e 	bne	r2,zero,8111ec84 <vCoudlNotCreateNFee2Task+0x68>
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111ec4c:	d0a06217 	ldw	r2,-32376(gp)
8111ec50:	100f883a 	mov	r7,r2
8111ec54:	01800844 	movi	r6,33
8111ec58:	01400044 	movi	r5,1
8111ec5c:	01204574 	movhi	r4,33045
8111ec60:	2107b704 	addi	r4,r4,7900
8111ec64:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE 2 Task.\n");
8111ec68:	d0a06217 	ldw	r2,-32376(gp)
8111ec6c:	100f883a 	mov	r7,r2
8111ec70:	01800784 	movi	r6,30
8111ec74:	01400044 	movi	r5,1
8111ec78:	01204574 	movhi	r4,33045
8111ec7c:	2107c004 	addi	r4,r4,7936
8111ec80:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ec84:	0001883a 	nop
8111ec88:	e037883a 	mov	sp,fp
8111ec8c:	dfc00117 	ldw	ra,4(sp)
8111ec90:	df000017 	ldw	fp,0(sp)
8111ec94:	dec00204 	addi	sp,sp,8
8111ec98:	f800283a 	ret

8111ec9c <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111ec9c:	defffe04 	addi	sp,sp,-8
8111eca0:	de00012e 	bgeu	sp,et,8111eca8 <vCoudlNotCreateNFee3Task+0xc>
8111eca4:	003b68fa 	trap	3
8111eca8:	dfc00115 	stw	ra,4(sp)
8111ecac:	df000015 	stw	fp,0(sp)
8111ecb0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ecb4:	00a045f4 	movhi	r2,33047
8111ecb8:	10a34f04 	addi	r2,r2,-29380
8111ecbc:	10800a8b 	ldhu	r2,42(r2)
8111ecc0:	10bfffcc 	andi	r2,r2,65535
8111ecc4:	10800228 	cmpgeui	r2,r2,8
8111ecc8:	10000e1e 	bne	r2,zero,8111ed04 <vCoudlNotCreateNFee3Task+0x68>
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111eccc:	d0a06217 	ldw	r2,-32376(gp)
8111ecd0:	100f883a 	mov	r7,r2
8111ecd4:	01800844 	movi	r6,33
8111ecd8:	01400044 	movi	r5,1
8111ecdc:	01204574 	movhi	r4,33045
8111ece0:	2107c804 	addi	r4,r4,7968
8111ece4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE 3 Task.\n");
8111ece8:	d0a06217 	ldw	r2,-32376(gp)
8111ecec:	100f883a 	mov	r7,r2
8111ecf0:	01800784 	movi	r6,30
8111ecf4:	01400044 	movi	r5,1
8111ecf8:	01204574 	movhi	r4,33045
8111ecfc:	2107d104 	addi	r4,r4,8004
8111ed00:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ed04:	0001883a 	nop
8111ed08:	e037883a 	mov	sp,fp
8111ed0c:	dfc00117 	ldw	ra,4(sp)
8111ed10:	df000017 	ldw	fp,0(sp)
8111ed14:	dec00204 	addi	sp,sp,8
8111ed18:	f800283a 	ret

8111ed1c <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111ed1c:	defffe04 	addi	sp,sp,-8
8111ed20:	de00012e 	bgeu	sp,et,8111ed28 <vCoudlNotCreateNFee4Task+0xc>
8111ed24:	003b68fa 	trap	3
8111ed28:	dfc00115 	stw	ra,4(sp)
8111ed2c:	df000015 	stw	fp,0(sp)
8111ed30:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ed34:	00a045f4 	movhi	r2,33047
8111ed38:	10a34f04 	addi	r2,r2,-29380
8111ed3c:	10800a8b 	ldhu	r2,42(r2)
8111ed40:	10bfffcc 	andi	r2,r2,65535
8111ed44:	10800228 	cmpgeui	r2,r2,8
8111ed48:	10000e1e 	bne	r2,zero,8111ed84 <vCoudlNotCreateNFee4Task+0x68>
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111ed4c:	d0a06217 	ldw	r2,-32376(gp)
8111ed50:	100f883a 	mov	r7,r2
8111ed54:	01800844 	movi	r6,33
8111ed58:	01400044 	movi	r5,1
8111ed5c:	01204574 	movhi	r4,33045
8111ed60:	2107d904 	addi	r4,r4,8036
8111ed64:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE 4 Task.\n");
8111ed68:	d0a06217 	ldw	r2,-32376(gp)
8111ed6c:	100f883a 	mov	r7,r2
8111ed70:	01800784 	movi	r6,30
8111ed74:	01400044 	movi	r5,1
8111ed78:	01204574 	movhi	r4,33045
8111ed7c:	2107e204 	addi	r4,r4,8072
8111ed80:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ed84:	0001883a 	nop
8111ed88:	e037883a 	mov	sp,fp
8111ed8c:	dfc00117 	ldw	ra,4(sp)
8111ed90:	df000017 	ldw	fp,0(sp)
8111ed94:	dec00204 	addi	sp,sp,8
8111ed98:	f800283a 	ret

8111ed9c <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111ed9c:	defffe04 	addi	sp,sp,-8
8111eda0:	de00012e 	bgeu	sp,et,8111eda8 <vCoudlNotCreateNFee5Task+0xc>
8111eda4:	003b68fa 	trap	3
8111eda8:	dfc00115 	stw	ra,4(sp)
8111edac:	df000015 	stw	fp,0(sp)
8111edb0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111edb4:	00a045f4 	movhi	r2,33047
8111edb8:	10a34f04 	addi	r2,r2,-29380
8111edbc:	10800a8b 	ldhu	r2,42(r2)
8111edc0:	10bfffcc 	andi	r2,r2,65535
8111edc4:	10800228 	cmpgeui	r2,r2,8
8111edc8:	10000e1e 	bne	r2,zero,8111ee04 <vCoudlNotCreateNFee5Task+0x68>
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111edcc:	d0a06217 	ldw	r2,-32376(gp)
8111edd0:	100f883a 	mov	r7,r2
8111edd4:	01800844 	movi	r6,33
8111edd8:	01400044 	movi	r5,1
8111eddc:	01204574 	movhi	r4,33045
8111ede0:	2107ea04 	addi	r4,r4,8104
8111ede4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE 5 Task.\n");
8111ede8:	d0a06217 	ldw	r2,-32376(gp)
8111edec:	100f883a 	mov	r7,r2
8111edf0:	01800784 	movi	r6,30
8111edf4:	01400044 	movi	r5,1
8111edf8:	01204574 	movhi	r4,33045
8111edfc:	2107f304 	addi	r4,r4,8140
8111ee00:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ee04:	0001883a 	nop
8111ee08:	e037883a 	mov	sp,fp
8111ee0c:	dfc00117 	ldw	ra,4(sp)
8111ee10:	df000017 	ldw	fp,0(sp)
8111ee14:	dec00204 	addi	sp,sp,8
8111ee18:	f800283a 	ret

8111ee1c <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111ee1c:	defffe04 	addi	sp,sp,-8
8111ee20:	de00012e 	bgeu	sp,et,8111ee28 <vCoudlNotCreateNFeeControllerTask+0xc>
8111ee24:	003b68fa 	trap	3
8111ee28:	dfc00115 	stw	ra,4(sp)
8111ee2c:	df000015 	stw	fp,0(sp)
8111ee30:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ee34:	00a045f4 	movhi	r2,33047
8111ee38:	10a34f04 	addi	r2,r2,-29380
8111ee3c:	10800a8b 	ldhu	r2,42(r2)
8111ee40:	10bfffcc 	andi	r2,r2,65535
8111ee44:	10800228 	cmpgeui	r2,r2,8
8111ee48:	10000e1e 	bne	r2,zero,8111ee84 <vCoudlNotCreateNFeeControllerTask+0x68>
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111ee4c:	d0a06217 	ldw	r2,-32376(gp)
8111ee50:	100f883a 	mov	r7,r2
8111ee54:	01800a84 	movi	r6,42
8111ee58:	01400044 	movi	r5,1
8111ee5c:	01204574 	movhi	r4,33045
8111ee60:	2107fb04 	addi	r4,r4,8172
8111ee64:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create NFEE Controller Task.\n");
8111ee68:	d0a06217 	ldw	r2,-32376(gp)
8111ee6c:	100f883a 	mov	r7,r2
8111ee70:	018009c4 	movi	r6,39
8111ee74:	01400044 	movi	r5,1
8111ee78:	01204574 	movhi	r4,33045
8111ee7c:	21080604 	addi	r4,r4,8216
8111ee80:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ee84:	0001883a 	nop
8111ee88:	e037883a 	mov	sp,fp
8111ee8c:	dfc00117 	ldw	ra,4(sp)
8111ee90:	df000017 	ldw	fp,0(sp)
8111ee94:	dec00204 	addi	sp,sp,8
8111ee98:	f800283a 	ret

8111ee9c <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111ee9c:	defffe04 	addi	sp,sp,-8
8111eea0:	de00012e 	bgeu	sp,et,8111eea8 <vCoudlNotCreateDataControllerTask+0xc>
8111eea4:	003b68fa 	trap	3
8111eea8:	dfc00115 	stw	ra,4(sp)
8111eeac:	df000015 	stw	fp,0(sp)
8111eeb0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eeb4:	00a045f4 	movhi	r2,33047
8111eeb8:	10a34f04 	addi	r2,r2,-29380
8111eebc:	10800a8b 	ldhu	r2,42(r2)
8111eec0:	10bfffcc 	andi	r2,r2,65535
8111eec4:	10800228 	cmpgeui	r2,r2,8
8111eec8:	10000e1e 	bne	r2,zero,8111ef04 <vCoudlNotCreateDataControllerTask+0x68>
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111eecc:	d0a06217 	ldw	r2,-32376(gp)
8111eed0:	100f883a 	mov	r7,r2
8111eed4:	01800a84 	movi	r6,42
8111eed8:	01400044 	movi	r5,1
8111eedc:	01204574 	movhi	r4,33045
8111eee0:	21081004 	addi	r4,r4,8256
8111eee4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create Data Controller Task.\n");
8111eee8:	d0a06217 	ldw	r2,-32376(gp)
8111eeec:	100f883a 	mov	r7,r2
8111eef0:	018009c4 	movi	r6,39
8111eef4:	01400044 	movi	r5,1
8111eef8:	01204574 	movhi	r4,33045
8111eefc:	21081b04 	addi	r4,r4,8300
8111ef00:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ef04:	0001883a 	nop
8111ef08:	e037883a 	mov	sp,fp
8111ef0c:	dfc00117 	ldw	ra,4(sp)
8111ef10:	df000017 	ldw	fp,0(sp)
8111ef14:	dec00204 	addi	sp,sp,8
8111ef18:	f800283a 	ret

8111ef1c <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111ef1c:	defffe04 	addi	sp,sp,-8
8111ef20:	de00012e 	bgeu	sp,et,8111ef28 <vCoudlNotCreateMebTask+0xc>
8111ef24:	003b68fa 	trap	3
8111ef28:	dfc00115 	stw	ra,4(sp)
8111ef2c:	df000015 	stw	fp,0(sp)
8111ef30:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ef34:	00a045f4 	movhi	r2,33047
8111ef38:	10a34f04 	addi	r2,r2,-29380
8111ef3c:	10800a8b 	ldhu	r2,42(r2)
8111ef40:	10bfffcc 	andi	r2,r2,65535
8111ef44:	10800228 	cmpgeui	r2,r2,8
8111ef48:	10000e1e 	bne	r2,zero,8111ef84 <vCoudlNotCreateMebTask+0x68>
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111ef4c:	d0a06217 	ldw	r2,-32376(gp)
8111ef50:	100f883a 	mov	r7,r2
8111ef54:	018007c4 	movi	r6,31
8111ef58:	01400044 	movi	r5,1
8111ef5c:	01204574 	movhi	r4,33045
8111ef60:	21082504 	addi	r4,r4,8340
8111ef64:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not create Meb Task.\n");
8111ef68:	d0a06217 	ldw	r2,-32376(gp)
8111ef6c:	100f883a 	mov	r7,r2
8111ef70:	018006c4 	movi	r6,27
8111ef74:	01400044 	movi	r5,1
8111ef78:	01204574 	movhi	r4,33045
8111ef7c:	21082d04 	addi	r4,r4,8372
8111ef80:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ef84:	0001883a 	nop
8111ef88:	e037883a 	mov	sp,fp
8111ef8c:	dfc00117 	ldw	ra,4(sp)
8111ef90:	df000017 	ldw	fp,0(sp)
8111ef94:	dec00204 	addi	sp,sp,8
8111ef98:	f800283a 	ret

8111ef9c <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111ef9c:	defffd04 	addi	sp,sp,-12
8111efa0:	de00012e 	bgeu	sp,et,8111efa8 <vFailCreateMutexSPUSQueueMeb+0xc>
8111efa4:	003b68fa 	trap	3
8111efa8:	dfc00215 	stw	ra,8(sp)
8111efac:	df000115 	stw	fp,4(sp)
8111efb0:	df000104 	addi	fp,sp,4
8111efb4:	2005883a 	mov	r2,r4
8111efb8:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111efbc:	00a045f4 	movhi	r2,33047
8111efc0:	10a34f04 	addi	r2,r2,-29380
8111efc4:	10800a8b 	ldhu	r2,42(r2)
8111efc8:	10bfffcc 	andi	r2,r2,65535
8111efcc:	10800228 	cmpgeui	r2,r2,8
8111efd0:	10000a1e 	bne	r2,zero,8111effc <vFailCreateMutexSPUSQueueMeb+0x60>
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111efd4:	d0a06217 	ldw	r2,-32376(gp)
8111efd8:	100f883a 	mov	r7,r2
8111efdc:	01800944 	movi	r6,37
8111efe0:	01400044 	movi	r5,1
8111efe4:	01204574 	movhi	r4,33045
8111efe8:	21083404 	addi	r4,r4,8400
8111efec:	1123cec0 	call	81123cec <fwrite>
		printErrorTask(error_code);
8111eff0:	e0bfff03 	ldbu	r2,-4(fp)
8111eff4:	1009883a 	mov	r4,r2
8111eff8:	111d1600 	call	8111d160 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111effc:	0001883a 	nop
8111f000:	e037883a 	mov	sp,fp
8111f004:	dfc00117 	ldw	ra,4(sp)
8111f008:	df000017 	ldw	fp,0(sp)
8111f00c:	dec00204 	addi	sp,sp,8
8111f010:	f800283a 	ret

8111f014 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111f014:	defffe04 	addi	sp,sp,-8
8111f018:	de00012e 	bgeu	sp,et,8111f020 <vFailSendPUStoMebTask+0xc>
8111f01c:	003b68fa 	trap	3
8111f020:	dfc00115 	stw	ra,4(sp)
8111f024:	df000015 	stw	fp,0(sp)
8111f028:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f02c:	00a045f4 	movhi	r2,33047
8111f030:	10a34f04 	addi	r2,r2,-29380
8111f034:	10800a8b 	ldhu	r2,42(r2)
8111f038:	10bfffcc 	andi	r2,r2,65535
8111f03c:	10800228 	cmpgeui	r2,r2,8
8111f040:	1000071e 	bne	r2,zero,8111f060 <vFailSendPUStoMebTask+0x4c>
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111f044:	d0a06217 	ldw	r2,-32376(gp)
8111f048:	100f883a 	mov	r7,r2
8111f04c:	01800784 	movi	r6,30
8111f050:	01400044 	movi	r5,1
8111f054:	01204574 	movhi	r4,33045
8111f058:	21083e04 	addi	r4,r4,8440
8111f05c:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f060:	0001883a 	nop
8111f064:	e037883a 	mov	sp,fp
8111f068:	dfc00117 	ldw	ra,4(sp)
8111f06c:	df000017 	ldw	fp,0(sp)
8111f070:	dec00204 	addi	sp,sp,8
8111f074:	f800283a 	ret

8111f078 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111f078:	defffe04 	addi	sp,sp,-8
8111f07c:	de00012e 	bgeu	sp,et,8111f084 <vCouldNotGetCmdQueueMeb+0xc>
8111f080:	003b68fa 	trap	3
8111f084:	dfc00115 	stw	ra,4(sp)
8111f088:	df000015 	stw	fp,0(sp)
8111f08c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f090:	00a045f4 	movhi	r2,33047
8111f094:	10a34f04 	addi	r2,r2,-29380
8111f098:	10800a8b 	ldhu	r2,42(r2)
8111f09c:	10bfffcc 	andi	r2,r2,65535
8111f0a0:	10800228 	cmpgeui	r2,r2,8
8111f0a4:	10000e1e 	bne	r2,zero,8111f0e0 <vCouldNotGetCmdQueueMeb+0x68>
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111f0a8:	d0a06217 	ldw	r2,-32376(gp)
8111f0ac:	100f883a 	mov	r7,r2
8111f0b0:	01800a84 	movi	r6,42
8111f0b4:	01400044 	movi	r5,1
8111f0b8:	01204574 	movhi	r4,33045
8111f0bc:	21084604 	addi	r4,r4,8472
8111f0c0:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111f0c4:	d0a06217 	ldw	r2,-32376(gp)
8111f0c8:	100f883a 	mov	r7,r2
8111f0cc:	01800cc4 	movi	r6,51
8111f0d0:	01400044 	movi	r5,1
8111f0d4:	01204574 	movhi	r4,33045
8111f0d8:	21085104 	addi	r4,r4,8516
8111f0dc:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f0e0:	0001883a 	nop
8111f0e4:	e037883a 	mov	sp,fp
8111f0e8:	dfc00117 	ldw	ra,4(sp)
8111f0ec:	df000017 	ldw	fp,0(sp)
8111f0f0:	dec00204 	addi	sp,sp,8
8111f0f4:	f800283a 	ret

8111f0f8 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111f0f8:	defffe04 	addi	sp,sp,-8
8111f0fc:	de00012e 	bgeu	sp,et,8111f104 <vCouldNotGetMutexMebPus+0xc>
8111f100:	003b68fa 	trap	3
8111f104:	dfc00115 	stw	ra,4(sp)
8111f108:	df000015 	stw	fp,0(sp)
8111f10c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f110:	00a045f4 	movhi	r2,33047
8111f114:	10a34f04 	addi	r2,r2,-29380
8111f118:	10800a8b 	ldhu	r2,42(r2)
8111f11c:	10bfffcc 	andi	r2,r2,65535
8111f120:	10800228 	cmpgeui	r2,r2,8
8111f124:	1000071e 	bne	r2,zero,8111f144 <vCouldNotGetMutexMebPus+0x4c>
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111f128:	d0a06217 	ldw	r2,-32376(gp)
8111f12c:	100f883a 	mov	r7,r2
8111f130:	01800804 	movi	r6,32
8111f134:	01400044 	movi	r5,1
8111f138:	01204574 	movhi	r4,33045
8111f13c:	21085e04 	addi	r4,r4,8568
8111f140:	1123cec0 	call	81123cec <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f144:	0001883a 	nop
8111f148:	e037883a 	mov	sp,fp
8111f14c:	dfc00117 	ldw	ra,4(sp)
8111f150:	df000017 	ldw	fp,0(sp)
8111f154:	dec00204 	addi	sp,sp,8
8111f158:	f800283a 	ret

8111f15c <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111f15c:	defffe04 	addi	sp,sp,-8
8111f160:	de00012e 	bgeu	sp,et,8111f168 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111f164:	003b68fa 	trap	3
8111f168:	dfc00115 	stw	ra,4(sp)
8111f16c:	df000015 	stw	fp,0(sp)
8111f170:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f174:	00a045f4 	movhi	r2,33047
8111f178:	10a34f04 	addi	r2,r2,-29380
8111f17c:	10800a8b 	ldhu	r2,42(r2)
8111f180:	10bfffcc 	andi	r2,r2,65535
8111f184:	10800228 	cmpgeui	r2,r2,8
8111f188:	10000e1e 	bne	r2,zero,8111f1c4 <vCouldNotCreateQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111f18c:	d0a06217 	ldw	r2,-32376(gp)
8111f190:	100f883a 	mov	r7,r2
8111f194:	01800a44 	movi	r6,41
8111f198:	01400044 	movi	r5,1
8111f19c:	01204574 	movhi	r4,33045
8111f1a0:	21086704 	addi	r4,r4,8604
8111f1a4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111f1a8:	d0a06217 	ldw	r2,-32376(gp)
8111f1ac:	100f883a 	mov	r7,r2
8111f1b0:	01800c84 	movi	r6,50
8111f1b4:	01400044 	movi	r5,1
8111f1b8:	01204574 	movhi	r4,33045
8111f1bc:	21087204 	addi	r4,r4,8648
8111f1c0:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f1c4:	0001883a 	nop
8111f1c8:	e037883a 	mov	sp,fp
8111f1cc:	dfc00117 	ldw	ra,4(sp)
8111f1d0:	df000017 	ldw	fp,0(sp)
8111f1d4:	dec00204 	addi	sp,sp,8
8111f1d8:	f800283a 	ret

8111f1dc <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111f1dc:	defffe04 	addi	sp,sp,-8
8111f1e0:	de00012e 	bgeu	sp,et,8111f1e8 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111f1e4:	003b68fa 	trap	3
8111f1e8:	dfc00115 	stw	ra,4(sp)
8111f1ec:	df000015 	stw	fp,0(sp)
8111f1f0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f1f4:	00a045f4 	movhi	r2,33047
8111f1f8:	10a34f04 	addi	r2,r2,-29380
8111f1fc:	10800a8b 	ldhu	r2,42(r2)
8111f200:	10bfffcc 	andi	r2,r2,65535
8111f204:	10800228 	cmpgeui	r2,r2,8
8111f208:	10000e1e 	bne	r2,zero,8111f244 <vCouldNotCreateQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111f20c:	d0a06217 	ldw	r2,-32376(gp)
8111f210:	100f883a 	mov	r7,r2
8111f214:	01800a44 	movi	r6,41
8111f218:	01400044 	movi	r5,1
8111f21c:	01204574 	movhi	r4,33045
8111f220:	21087f04 	addi	r4,r4,8700
8111f224:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111f228:	d0a06217 	ldw	r2,-32376(gp)
8111f22c:	100f883a 	mov	r7,r2
8111f230:	01800c84 	movi	r6,50
8111f234:	01400044 	movi	r5,1
8111f238:	01204574 	movhi	r4,33045
8111f23c:	21088a04 	addi	r4,r4,8744
8111f240:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f244:	0001883a 	nop
8111f248:	e037883a 	mov	sp,fp
8111f24c:	dfc00117 	ldw	ra,4(sp)
8111f250:	df000017 	ldw	fp,0(sp)
8111f254:	dec00204 	addi	sp,sp,8
8111f258:	f800283a 	ret

8111f25c <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111f25c:	defffe04 	addi	sp,sp,-8
8111f260:	de00012e 	bgeu	sp,et,8111f268 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111f264:	003b68fa 	trap	3
8111f268:	dfc00115 	stw	ra,4(sp)
8111f26c:	df000015 	stw	fp,0(sp)
8111f270:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f274:	00a045f4 	movhi	r2,33047
8111f278:	10a34f04 	addi	r2,r2,-29380
8111f27c:	10800a8b 	ldhu	r2,42(r2)
8111f280:	10bfffcc 	andi	r2,r2,65535
8111f284:	10800228 	cmpgeui	r2,r2,8
8111f288:	10000e1e 	bne	r2,zero,8111f2c4 <vCouldNotGetQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111f28c:	d0a06217 	ldw	r2,-32376(gp)
8111f290:	100f883a 	mov	r7,r2
8111f294:	01800984 	movi	r6,38
8111f298:	01400044 	movi	r5,1
8111f29c:	01204574 	movhi	r4,33045
8111f2a0:	21089704 	addi	r4,r4,8796
8111f2a4:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111f2a8:	d0a06217 	ldw	r2,-32376(gp)
8111f2ac:	100f883a 	mov	r7,r2
8111f2b0:	01800bc4 	movi	r6,47
8111f2b4:	01400044 	movi	r5,1
8111f2b8:	01204574 	movhi	r4,33045
8111f2bc:	2108a104 	addi	r4,r4,8836
8111f2c0:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f2c4:	0001883a 	nop
8111f2c8:	e037883a 	mov	sp,fp
8111f2cc:	dfc00117 	ldw	ra,4(sp)
8111f2d0:	df000017 	ldw	fp,0(sp)
8111f2d4:	dec00204 	addi	sp,sp,8
8111f2d8:	f800283a 	ret

8111f2dc <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111f2dc:	defffe04 	addi	sp,sp,-8
8111f2e0:	de00012e 	bgeu	sp,et,8111f2e8 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111f2e4:	003b68fa 	trap	3
8111f2e8:	dfc00115 	stw	ra,4(sp)
8111f2ec:	df000015 	stw	fp,0(sp)
8111f2f0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f2f4:	00a045f4 	movhi	r2,33047
8111f2f8:	10a34f04 	addi	r2,r2,-29380
8111f2fc:	10800a8b 	ldhu	r2,42(r2)
8111f300:	10bfffcc 	andi	r2,r2,65535
8111f304:	10800228 	cmpgeui	r2,r2,8
8111f308:	10000e1e 	bne	r2,zero,8111f344 <vCouldNotGetQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111f30c:	d0a06217 	ldw	r2,-32376(gp)
8111f310:	100f883a 	mov	r7,r2
8111f314:	01800984 	movi	r6,38
8111f318:	01400044 	movi	r5,1
8111f31c:	01204574 	movhi	r4,33045
8111f320:	2108ad04 	addi	r4,r4,8884
8111f324:	1123cec0 	call	81123cec <fwrite>
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111f328:	d0a06217 	ldw	r2,-32376(gp)
8111f32c:	100f883a 	mov	r7,r2
8111f330:	01800bc4 	movi	r6,47
8111f334:	01400044 	movi	r5,1
8111f338:	01204574 	movhi	r4,33045
8111f33c:	2108b704 	addi	r4,r4,8924
8111f340:	1123cec0 	call	81123cec <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f344:	0001883a 	nop
8111f348:	e037883a 	mov	sp,fp
8111f34c:	dfc00117 	ldw	ra,4(sp)
8111f350:	df000017 	ldw	fp,0(sp)
8111f354:	dec00204 	addi	sp,sp,8
8111f358:	f800283a 	ret

8111f35c <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111f35c:	defffd04 	addi	sp,sp,-12
8111f360:	de00012e 	bgeu	sp,et,8111f368 <vFailSendMsgAccessDMA+0xc>
8111f364:	003b68fa 	trap	3
8111f368:	dfc00215 	stw	ra,8(sp)
8111f36c:	df000115 	stw	fp,4(sp)
8111f370:	df000104 	addi	fp,sp,4
8111f374:	2005883a 	mov	r2,r4
8111f378:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f37c:	00a045f4 	movhi	r2,33047
8111f380:	10a34f04 	addi	r2,r2,-29380
8111f384:	10800a8b 	ldhu	r2,42(r2)
8111f388:	10bfffcc 	andi	r2,r2,65535
8111f38c:	10800228 	cmpgeui	r2,r2,8
8111f390:	1000071e 	bne	r2,zero,8111f3b0 <vFailSendMsgAccessDMA+0x54>
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n:%hhu \n", ucTemp);
8111f394:	d0a06217 	ldw	r2,-32376(gp)
8111f398:	e0ffff03 	ldbu	r3,-4(fp)
8111f39c:	180d883a 	mov	r6,r3
8111f3a0:	01604574 	movhi	r5,33045
8111f3a4:	2948c304 	addi	r5,r5,8972
8111f3a8:	1009883a 	mov	r4,r2
8111f3ac:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f3b0:	0001883a 	nop
8111f3b4:	e037883a 	mov	sp,fp
8111f3b8:	dfc00117 	ldw	ra,4(sp)
8111f3bc:	df000017 	ldw	fp,0(sp)
8111f3c0:	dec00204 	addi	sp,sp,8
8111f3c4:	f800283a 	ret

8111f3c8 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111f3c8:	defffd04 	addi	sp,sp,-12
8111f3cc:	de00012e 	bgeu	sp,et,8111f3d4 <vFailRequestDMA+0xc>
8111f3d0:	003b68fa 	trap	3
8111f3d4:	dfc00215 	stw	ra,8(sp)
8111f3d8:	df000115 	stw	fp,4(sp)
8111f3dc:	df000104 	addi	fp,sp,4
8111f3e0:	2005883a 	mov	r2,r4
8111f3e4:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f3e8:	00a045f4 	movhi	r2,33047
8111f3ec:	10a34f04 	addi	r2,r2,-29380
8111f3f0:	10800a8b 	ldhu	r2,42(r2)
8111f3f4:	10bfffcc 	andi	r2,r2,65535
8111f3f8:	10800228 	cmpgeui	r2,r2,8
8111f3fc:	1000071e 	bne	r2,zero,8111f41c <vFailRequestDMA+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111f400:	d0a06217 	ldw	r2,-32376(gp)
8111f404:	e0ffff03 	ldbu	r3,-4(fp)
8111f408:	180d883a 	mov	r6,r3
8111f40c:	01604574 	movhi	r5,33045
8111f410:	2948cc04 	addi	r5,r5,9008
8111f414:	1009883a 	mov	r4,r2
8111f418:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f41c:	0001883a 	nop
8111f420:	e037883a 	mov	sp,fp
8111f424:	dfc00117 	ldw	ra,4(sp)
8111f428:	df000017 	ldw	fp,0(sp)
8111f42c:	dec00204 	addi	sp,sp,8
8111f430:	f800283a 	ret

8111f434 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111f434:	defffd04 	addi	sp,sp,-12
8111f438:	de00012e 	bgeu	sp,et,8111f440 <vFailRequestDMAFromIRQ+0xc>
8111f43c:	003b68fa 	trap	3
8111f440:	dfc00215 	stw	ra,8(sp)
8111f444:	df000115 	stw	fp,4(sp)
8111f448:	df000104 	addi	fp,sp,4
8111f44c:	2005883a 	mov	r2,r4
8111f450:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f454:	00a045f4 	movhi	r2,33047
8111f458:	10a34f04 	addi	r2,r2,-29380
8111f45c:	10800a8b 	ldhu	r2,42(r2)
8111f460:	10bfffcc 	andi	r2,r2,65535
8111f464:	10800228 	cmpgeui	r2,r2,8
8111f468:	1000071e 	bne	r2,zero,8111f488 <vFailRequestDMAFromIRQ+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111f46c:	d0a06217 	ldw	r2,-32376(gp)
8111f470:	e0ffff03 	ldbu	r3,-4(fp)
8111f474:	180d883a 	mov	r6,r3
8111f478:	01604574 	movhi	r5,33045
8111f47c:	2948cc04 	addi	r5,r5,9008
8111f480:	1009883a 	mov	r4,r2
8111f484:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f488:	0001883a 	nop
8111f48c:	e037883a 	mov	sp,fp
8111f490:	dfc00117 	ldw	ra,4(sp)
8111f494:	df000017 	ldw	fp,0(sp)
8111f498:	dec00204 	addi	sp,sp,8
8111f49c:	f800283a 	ret

8111f4a0 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111f4a0:	defffd04 	addi	sp,sp,-12
8111f4a4:	de00012e 	bgeu	sp,et,8111f4ac <vFailSendRMAPFromIRQ+0xc>
8111f4a8:	003b68fa 	trap	3
8111f4ac:	dfc00215 	stw	ra,8(sp)
8111f4b0:	df000115 	stw	fp,4(sp)
8111f4b4:	df000104 	addi	fp,sp,4
8111f4b8:	2005883a 	mov	r2,r4
8111f4bc:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f4c0:	00a045f4 	movhi	r2,33047
8111f4c4:	10a34f04 	addi	r2,r2,-29380
8111f4c8:	10800a8b 	ldhu	r2,42(r2)
8111f4cc:	10bfffcc 	andi	r2,r2,65535
8111f4d0:	10800228 	cmpgeui	r2,r2,8
8111f4d4:	1000071e 	bne	r2,zero,8111f4f4 <vFailSendRMAPFromIRQ+0x54>
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n:%hhu \n", ucTemp);
8111f4d8:	d0a06217 	ldw	r2,-32376(gp)
8111f4dc:	e0ffff03 	ldbu	r3,-4(fp)
8111f4e0:	180d883a 	mov	r6,r3
8111f4e4:	01604574 	movhi	r5,33045
8111f4e8:	2948d404 	addi	r5,r5,9040
8111f4ec:	1009883a 	mov	r4,r2
8111f4f0:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f4f4:	0001883a 	nop
8111f4f8:	e037883a 	mov	sp,fp
8111f4fc:	dfc00117 	ldw	ra,4(sp)
8111f500:	df000017 	ldw	fp,0(sp)
8111f504:	dec00204 	addi	sp,sp,8
8111f508:	f800283a 	ret

8111f50c <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111f50c:	defffd04 	addi	sp,sp,-12
8111f510:	de00012e 	bgeu	sp,et,8111f518 <vFailSendMsgSync+0xc>
8111f514:	003b68fa 	trap	3
8111f518:	dfc00215 	stw	ra,8(sp)
8111f51c:	df000115 	stw	fp,4(sp)
8111f520:	df000104 	addi	fp,sp,4
8111f524:	2005883a 	mov	r2,r4
8111f528:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f52c:	00a045f4 	movhi	r2,33047
8111f530:	10a34f04 	addi	r2,r2,-29380
8111f534:	10800a8b 	ldhu	r2,42(r2)
8111f538:	10bfffcc 	andi	r2,r2,65535
8111f53c:	10800228 	cmpgeui	r2,r2,8
8111f540:	1000071e 	bne	r2,zero,8111f560 <vFailSendMsgSync+0x54>
		fprintf(fp,"vFailSendMsgSync. FEE n:%hhu \n", ucTemp);
8111f544:	d0a06217 	ldw	r2,-32376(gp)
8111f548:	e0ffff03 	ldbu	r3,-4(fp)
8111f54c:	180d883a 	mov	r6,r3
8111f550:	01604574 	movhi	r5,33045
8111f554:	2948dd04 	addi	r5,r5,9076
8111f558:	1009883a 	mov	r4,r2
8111f55c:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f560:	0001883a 	nop
8111f564:	e037883a 	mov	sp,fp
8111f568:	dfc00117 	ldw	ra,4(sp)
8111f56c:	df000017 	ldw	fp,0(sp)
8111f570:	dec00204 	addi	sp,sp,8
8111f574:	f800283a 	ret

8111f578 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111f578:	defffd04 	addi	sp,sp,-12
8111f57c:	de00012e 	bgeu	sp,et,8111f584 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111f580:	003b68fa 	trap	3
8111f584:	dfc00215 	stw	ra,8(sp)
8111f588:	df000115 	stw	fp,4(sp)
8111f58c:	df000104 	addi	fp,sp,4
8111f590:	2005883a 	mov	r2,r4
8111f594:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f598:	00a045f4 	movhi	r2,33047
8111f59c:	10a34f04 	addi	r2,r2,-29380
8111f5a0:	10800a8b 	ldhu	r2,42(r2)
8111f5a4:	10bfffcc 	andi	r2,r2,65535
8111f5a8:	10800228 	cmpgeui	r2,r2,8
8111f5ac:	1000071e 	bne	r2,zero,8111f5cc <vFailSendMsgSyncRMAPTRIGGER+0x54>
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n:%hhu \n", ucTemp);
8111f5b0:	d0a06217 	ldw	r2,-32376(gp)
8111f5b4:	e0ffff03 	ldbu	r3,-4(fp)
8111f5b8:	180d883a 	mov	r6,r3
8111f5bc:	01604574 	movhi	r5,33045
8111f5c0:	2948e504 	addi	r5,r5,9108
8111f5c4:	1009883a 	mov	r4,r2
8111f5c8:	11236500 	call	81123650 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f5cc:	0001883a 	nop
8111f5d0:	e037883a 	mov	sp,fp
8111f5d4:	dfc00117 	ldw	ra,4(sp)
8111f5d8:	df000017 	ldw	fp,0(sp)
8111f5dc:	dec00204 	addi	sp,sp,8
8111f5e0:	f800283a 	ret

8111f5e4 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111f5e4:	defffe04 	addi	sp,sp,-8
8111f5e8:	de00012e 	bgeu	sp,et,8111f5f0 <vFailSendMsgMasterSyncMeb+0xc>
8111f5ec:	003b68fa 	trap	3
8111f5f0:	dfc00115 	stw	ra,4(sp)
8111f5f4:	df000015 	stw	fp,0(sp)
8111f5f8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f5fc:	00a045f4 	movhi	r2,33047
8111f600:	10a34f04 	addi	r2,r2,-29380
8111f604:	10800a8b 	ldhu	r2,42(r2)
8111f608:	10bfffcc 	andi	r2,r2,65535
8111f60c:	10800228 	cmpgeui	r2,r2,8
8111f610:	1000071e 	bne	r2,zero,8111f630 <vFailSendMsgMasterSyncMeb+0x4c>
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111f614:	d0a06217 	ldw	r2,-32376(gp)
8111f618:	100f883a 	mov	r7,r2
8111f61c:	018006c4 	movi	r6,27
8111f620:	01400044 	movi	r5,1
8111f624:	01204574 	movhi	r4,33045
8111f628:	2108f304 	addi	r4,r4,9164
8111f62c:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f630:	0001883a 	nop
8111f634:	e037883a 	mov	sp,fp
8111f638:	dfc00117 	ldw	ra,4(sp)
8111f63c:	df000017 	ldw	fp,0(sp)
8111f640:	dec00204 	addi	sp,sp,8
8111f644:	f800283a 	ret

8111f648 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111f648:	defffe04 	addi	sp,sp,-8
8111f64c:	de00012e 	bgeu	sp,et,8111f654 <vFailSendMsgFeeCTRL+0xc>
8111f650:	003b68fa 	trap	3
8111f654:	dfc00115 	stw	ra,4(sp)
8111f658:	df000015 	stw	fp,0(sp)
8111f65c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f660:	00a045f4 	movhi	r2,33047
8111f664:	10a34f04 	addi	r2,r2,-29380
8111f668:	10800a8b 	ldhu	r2,42(r2)
8111f66c:	10bfffcc 	andi	r2,r2,65535
8111f670:	10800228 	cmpgeui	r2,r2,8
8111f674:	1000071e 	bne	r2,zero,8111f694 <vFailSendMsgFeeCTRL+0x4c>
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111f678:	d0a06217 	ldw	r2,-32376(gp)
8111f67c:	100f883a 	mov	r7,r2
8111f680:	018005c4 	movi	r6,23
8111f684:	01400044 	movi	r5,1
8111f688:	01204574 	movhi	r4,33045
8111f68c:	2108fa04 	addi	r4,r4,9192
8111f690:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f694:	0001883a 	nop
8111f698:	e037883a 	mov	sp,fp
8111f69c:	dfc00117 	ldw	ra,4(sp)
8111f6a0:	df000017 	ldw	fp,0(sp)
8111f6a4:	dec00204 	addi	sp,sp,8
8111f6a8:	f800283a 	ret

8111f6ac <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111f6ac:	defffe04 	addi	sp,sp,-8
8111f6b0:	de00012e 	bgeu	sp,et,8111f6b8 <vFailSendMsgDataCTRL+0xc>
8111f6b4:	003b68fa 	trap	3
8111f6b8:	dfc00115 	stw	ra,4(sp)
8111f6bc:	df000015 	stw	fp,0(sp)
8111f6c0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f6c4:	00a045f4 	movhi	r2,33047
8111f6c8:	10a34f04 	addi	r2,r2,-29380
8111f6cc:	10800a8b 	ldhu	r2,42(r2)
8111f6d0:	10bfffcc 	andi	r2,r2,65535
8111f6d4:	10800228 	cmpgeui	r2,r2,8
8111f6d8:	1000071e 	bne	r2,zero,8111f6f8 <vFailSendMsgDataCTRL+0x4c>
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111f6dc:	d0a06217 	ldw	r2,-32376(gp)
8111f6e0:	100f883a 	mov	r7,r2
8111f6e4:	01800604 	movi	r6,24
8111f6e8:	01400044 	movi	r5,1
8111f6ec:	01204574 	movhi	r4,33045
8111f6f0:	21090004 	addi	r4,r4,9216
8111f6f4:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f6f8:	0001883a 	nop
8111f6fc:	e037883a 	mov	sp,fp
8111f700:	dfc00117 	ldw	ra,4(sp)
8111f704:	df000017 	ldw	fp,0(sp)
8111f708:	dec00204 	addi	sp,sp,8
8111f70c:	f800283a 	ret

8111f710 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111f710:	defffe04 	addi	sp,sp,-8
8111f714:	de00012e 	bgeu	sp,et,8111f71c <vFailFlushQueue+0xc>
8111f718:	003b68fa 	trap	3
8111f71c:	dfc00115 	stw	ra,4(sp)
8111f720:	df000015 	stw	fp,0(sp)
8111f724:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f728:	00a045f4 	movhi	r2,33047
8111f72c:	10a34f04 	addi	r2,r2,-29380
8111f730:	10800a8b 	ldhu	r2,42(r2)
8111f734:	10bfffcc 	andi	r2,r2,65535
8111f738:	10800228 	cmpgeui	r2,r2,8
8111f73c:	1000071e 	bne	r2,zero,8111f75c <vFailFlushQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111f740:	d0a06217 	ldw	r2,-32376(gp)
8111f744:	100f883a 	mov	r7,r2
8111f748:	01800744 	movi	r6,29
8111f74c:	01400044 	movi	r5,1
8111f750:	01204574 	movhi	r4,33045
8111f754:	21090704 	addi	r4,r4,9244
8111f758:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f75c:	0001883a 	nop
8111f760:	e037883a 	mov	sp,fp
8111f764:	dfc00117 	ldw	ra,4(sp)
8111f768:	df000017 	ldw	fp,0(sp)
8111f76c:	dec00204 	addi	sp,sp,8
8111f770:	f800283a 	ret

8111f774 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111f774:	defffe04 	addi	sp,sp,-8
8111f778:	de00012e 	bgeu	sp,et,8111f780 <vFailFlushQueueData+0xc>
8111f77c:	003b68fa 	trap	3
8111f780:	dfc00115 	stw	ra,4(sp)
8111f784:	df000015 	stw	fp,0(sp)
8111f788:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f78c:	00a045f4 	movhi	r2,33047
8111f790:	10a34f04 	addi	r2,r2,-29380
8111f794:	10800a8b 	ldhu	r2,42(r2)
8111f798:	10bfffcc 	andi	r2,r2,65535
8111f79c:	10800228 	cmpgeui	r2,r2,8
8111f7a0:	1000071e 	bne	r2,zero,8111f7c0 <vFailFlushQueueData+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111f7a4:	d0a06217 	ldw	r2,-32376(gp)
8111f7a8:	100f883a 	mov	r7,r2
8111f7ac:	01800844 	movi	r6,33
8111f7b0:	01400044 	movi	r5,1
8111f7b4:	01204574 	movhi	r4,33045
8111f7b8:	21090f04 	addi	r4,r4,9276
8111f7bc:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f7c0:	0001883a 	nop
8111f7c4:	e037883a 	mov	sp,fp
8111f7c8:	dfc00117 	ldw	ra,4(sp)
8111f7cc:	df000017 	ldw	fp,0(sp)
8111f7d0:	dec00204 	addi	sp,sp,8
8111f7d4:	f800283a 	ret

8111f7d8 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111f7d8:	defffe04 	addi	sp,sp,-8
8111f7dc:	de00012e 	bgeu	sp,et,8111f7e4 <vFailFlushMEBQueue+0xc>
8111f7e0:	003b68fa 	trap	3
8111f7e4:	dfc00115 	stw	ra,4(sp)
8111f7e8:	df000015 	stw	fp,0(sp)
8111f7ec:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f7f0:	00a045f4 	movhi	r2,33047
8111f7f4:	10a34f04 	addi	r2,r2,-29380
8111f7f8:	10800a8b 	ldhu	r2,42(r2)
8111f7fc:	10bfffcc 	andi	r2,r2,65535
8111f800:	10800228 	cmpgeui	r2,r2,8
8111f804:	1000071e 	bne	r2,zero,8111f824 <vFailFlushMEBQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111f808:	d0a06217 	ldw	r2,-32376(gp)
8111f80c:	100f883a 	mov	r7,r2
8111f810:	01800804 	movi	r6,32
8111f814:	01400044 	movi	r5,1
8111f818:	01204574 	movhi	r4,33045
8111f81c:	21091804 	addi	r4,r4,9312
8111f820:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f824:	0001883a 	nop
8111f828:	e037883a 	mov	sp,fp
8111f82c:	dfc00117 	ldw	ra,4(sp)
8111f830:	df000017 	ldw	fp,0(sp)
8111f834:	dec00204 	addi	sp,sp,8
8111f838:	f800283a 	ret

8111f83c <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111f83c:	defffe04 	addi	sp,sp,-8
8111f840:	de00012e 	bgeu	sp,et,8111f848 <vFailFlushNFEEQueue+0xc>
8111f844:	003b68fa 	trap	3
8111f848:	dfc00115 	stw	ra,4(sp)
8111f84c:	df000015 	stw	fp,0(sp)
8111f850:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f854:	00a045f4 	movhi	r2,33047
8111f858:	10a34f04 	addi	r2,r2,-29380
8111f85c:	10800a8b 	ldhu	r2,42(r2)
8111f860:	10bfffcc 	andi	r2,r2,65535
8111f864:	10800228 	cmpgeui	r2,r2,8
8111f868:	1000071e 	bne	r2,zero,8111f888 <vFailFlushNFEEQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111f86c:	d0a06217 	ldw	r2,-32376(gp)
8111f870:	100f883a 	mov	r7,r2
8111f874:	01800844 	movi	r6,33
8111f878:	01400044 	movi	r5,1
8111f87c:	01204574 	movhi	r4,33045
8111f880:	21092104 	addi	r4,r4,9348
8111f884:	1123cec0 	call	81123cec <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f888:	0001883a 	nop
8111f88c:	e037883a 	mov	sp,fp
8111f890:	dfc00117 	ldw	ra,4(sp)
8111f894:	df000017 	ldw	fp,0(sp)
8111f898:	dec00204 	addi	sp,sp,8
8111f89c:	f800283a 	ret

8111f8a0 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111f8a0:	deffff04 	addi	sp,sp,-4
8111f8a4:	de00012e 	bgeu	sp,et,8111f8ac <vEvtChangeMebMode+0xc>
8111f8a8:	003b68fa 	trap	3
8111f8ac:	df000015 	stw	fp,0(sp)
8111f8b0:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111f8b4:	0001883a 	nop
8111f8b8:	e037883a 	mov	sp,fp
8111f8bc:	df000017 	ldw	fp,0(sp)
8111f8c0:	dec00104 	addi	sp,sp,4
8111f8c4:	f800283a 	ret

8111f8c8 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111f8c8:	deffff04 	addi	sp,sp,-4
8111f8cc:	de00012e 	bgeu	sp,et,8111f8d4 <vEvtChangeFeeControllerMode+0xc>
8111f8d0:	003b68fa 	trap	3
8111f8d4:	df000015 	stw	fp,0(sp)
8111f8d8:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111f8dc:	0001883a 	nop
8111f8e0:	e037883a 	mov	sp,fp
8111f8e4:	df000017 	ldw	fp,0(sp)
8111f8e8:	dec00104 	addi	sp,sp,4
8111f8ec:	f800283a 	ret

8111f8f0 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111f8f0:	deffff04 	addi	sp,sp,-4
8111f8f4:	de00012e 	bgeu	sp,et,8111f8fc <vEvtChangeDataControllerMode+0xc>
8111f8f8:	003b68fa 	trap	3
8111f8fc:	df000015 	stw	fp,0(sp)
8111f900:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111f904:	0001883a 	nop
8111f908:	e037883a 	mov	sp,fp
8111f90c:	df000017 	ldw	fp,0(sp)
8111f910:	dec00104 	addi	sp,sp,4
8111f914:	f800283a 	ret

8111f918 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111f918:	defffd04 	addi	sp,sp,-12
8111f91c:	de00012e 	bgeu	sp,et,8111f924 <vNFeeNotInUse+0xc>
8111f920:	003b68fa 	trap	3
8111f924:	df000215 	stw	fp,8(sp)
8111f928:	df000204 	addi	fp,sp,8
8111f92c:	e13ffe15 	stw	r4,-8(fp)
8111f930:	2805883a 	mov	r2,r5
8111f934:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111f938:	e0bffe17 	ldw	r2,-8(fp)
8111f93c:	e0ffff03 	ldbu	r3,-4(fp)
8111f940:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111f944:	e0bffe17 	ldw	r2,-8(fp)
8111f948:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111f94c:	e0bffe17 	ldw	r2,-8(fp)
8111f950:	10002315 	stw	zero,140(r2)
}
8111f954:	0001883a 	nop
8111f958:	e037883a 	mov	sp,fp
8111f95c:	df000017 	ldw	fp,0(sp)
8111f960:	dec00104 	addi	sp,sp,4
8111f964:	f800283a 	ret

8111f968 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111f968:	defffb04 	addi	sp,sp,-20
8111f96c:	de00012e 	bgeu	sp,et,8111f974 <vNFeeStructureInit+0xc>
8111f970:	003b68fa 	trap	3
8111f974:	dfc00415 	stw	ra,16(sp)
8111f978:	df000315 	stw	fp,12(sp)
8111f97c:	df000304 	addi	fp,sp,12
8111f980:	e13ffe15 	stw	r4,-8(fp)
8111f984:	2805883a 	mov	r2,r5
8111f988:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111f98c:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111f990:	e0bffe17 	ldw	r2,-8(fp)
8111f994:	e0ffff03 	ldbu	r3,-4(fp)
8111f998:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111f99c:	e0bffe17 	ldw	r2,-8(fp)
8111f9a0:	10802f04 	addi	r2,r2,188
8111f9a4:	1009883a 	mov	r4,r2
8111f9a8:	1119c300 	call	81119c30 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111f9ac:	e13ffe17 	ldw	r4,-8(fp)
8111f9b0:	111fbfc0 	call	8111fbfc <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111f9b4:	e0bffe17 	ldw	r2,-8(fp)
8111f9b8:	00c00044 	movi	r3,1
8111f9bc:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111f9c0:	e0bffe17 	ldw	r2,-8(fp)
8111f9c4:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111f9c8:	e0bffe17 	ldw	r2,-8(fp)
8111f9cc:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111f9d0:	e0bffe17 	ldw	r2,-8(fp)
8111f9d4:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111f9d8:	e0bffe17 	ldw	r2,-8(fp)
8111f9dc:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111f9e0:	e0bffe17 	ldw	r2,-8(fp)
8111f9e4:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111f9e8:	e0bffe17 	ldw	r2,-8(fp)
8111f9ec:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111f9f0:	e0bffe17 	ldw	r2,-8(fp)
8111f9f4:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111f9f8:	e0bffe17 	ldw	r2,-8(fp)
8111f9fc:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111fa00:	e0bffe17 	ldw	r2,-8(fp)
8111fa04:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111fa08:	e0bffe17 	ldw	r2,-8(fp)
8111fa0c:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111fa10:	e0bffe17 	ldw	r2,-8(fp)
8111fa14:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
8111fa18:	e0bfff03 	ldbu	r2,-4(fp)
8111fa1c:	1000071e 	bne	r2,zero,8111fa3c <vNFeeStructureInit+0xd4>
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
8111fa20:	00a045f4 	movhi	r2,33047
8111fa24:	10a34f04 	addi	r2,r2,-29380
8111fa28:	10800a0b 	ldhu	r2,40(r2)
8111fa2c:	1007883a 	mov	r3,r2
8111fa30:	e0bffe17 	ldw	r2,-8(fp)
8111fa34:	10c00045 	stb	r3,1(r2)
			break;
8111fa38:	00001006 	br	8111fa7c <vNFeeStructureInit+0x114>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111fa3c:	00a045f4 	movhi	r2,33047
8111fa40:	10a34f04 	addi	r2,r2,-29380
8111fa44:	10800a8b 	ldhu	r2,42(r2)
8111fa48:	10bfffcc 	andi	r2,r2,65535
8111fa4c:	10800228 	cmpgeui	r2,r2,8
8111fa50:	1000091e 	bne	r2,zero,8111fa78 <vNFeeStructureInit+0x110>
				fprintf(fp, "\n CRITICAL! Can't bind the SPW channel with the NFEE %i \n", pxNfeeL->ucId);
8111fa54:	d0e06217 	ldw	r3,-32376(gp)
8111fa58:	e0bffe17 	ldw	r2,-8(fp)
8111fa5c:	10800003 	ldbu	r2,0(r2)
8111fa60:	10803fcc 	andi	r2,r2,255
8111fa64:	100d883a 	mov	r6,r2
8111fa68:	01604574 	movhi	r5,33045
8111fa6c:	29492a04 	addi	r5,r5,9384
8111fa70:	1809883a 	mov	r4,r3
8111fa74:	11236500 	call	81123650 <fprintf>
			}
			#endif
			break;
8111fa78:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111fa7c:	e03ffd05 	stb	zero,-12(fp)
8111fa80:	00000d06 	br	8111fab8 <vNFeeStructureInit+0x150>
        pxNfeeL->xControl.ucROutOrder[ucIL] =  xDefaults.ucReadOutOrder[ucIL];
8111fa84:	e13ffd03 	ldbu	r4,-12(fp)
8111fa88:	e0fffd03 	ldbu	r3,-12(fp)
8111fa8c:	00a045f4 	movhi	r2,33047
8111fa90:	10a34f04 	addi	r2,r2,-29380
8111fa94:	10c5883a 	add	r2,r2,r3
8111fa98:	10c00003 	ldbu	r3,0(r2)
8111fa9c:	e0bffe17 	ldw	r2,-8(fp)
8111faa0:	1105883a 	add	r2,r2,r4
8111faa4:	10802a44 	addi	r2,r2,169
8111faa8:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111faac:	e0bffd03 	ldbu	r2,-12(fp)
8111fab0:	10800044 	addi	r2,r2,1
8111fab4:	e0bffd05 	stb	r2,-12(fp)
8111fab8:	e0bffd03 	ldbu	r2,-12(fp)
8111fabc:	10800130 	cmpltui	r2,r2,4
8111fac0:	103ff01e 	bne	r2,zero,8111fa84 <__reset+0xfb0ffa84>
        pxNfeeL->xControl.ucROutOrder[ucIL] =  xDefaults.ucReadOutOrder[ucIL];

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8111fac4:	e0bffe17 	ldw	r2,-8(fp)
8111fac8:	10c03204 	addi	r3,r2,200
8111facc:	e0bffe17 	ldw	r2,-8(fp)
8111fad0:	10800043 	ldbu	r2,1(r2)
8111fad4:	10803fcc 	andi	r2,r2,255
8111fad8:	100b883a 	mov	r5,r2
8111fadc:	1809883a 	mov	r4,r3
8111fae0:	110476c0 	call	8110476c <bCommInitCh>
8111fae4:	10000f1e 	bne	r2,zero,8111fb24 <vNFeeStructureInit+0x1bc>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111fae8:	00a045f4 	movhi	r2,33047
8111faec:	10a34f04 	addi	r2,r2,-29380
8111faf0:	10800a8b 	ldhu	r2,42(r2)
8111faf4:	10bfffcc 	andi	r2,r2,65535
8111faf8:	10800228 	cmpgeui	r2,r2,8
8111fafc:	1000091e 	bne	r2,zero,8111fb24 <vNFeeStructureInit+0x1bc>
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111fb00:	d0e06217 	ldw	r3,-32376(gp)
8111fb04:	e0bffe17 	ldw	r2,-8(fp)
8111fb08:	10800003 	ldbu	r2,0(r2)
8111fb0c:	10803fcc 	andi	r2,r2,255
8111fb10:	100d883a 	mov	r6,r2
8111fb14:	01604574 	movhi	r5,33045
8111fb18:	29493904 	addi	r5,r5,9444
8111fb1c:	1809883a 	mov	r4,r3
8111fb20:	11236500 	call	81123650 <fprintf>
    	}
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8111fb24:	e0bffe17 	ldw	r2,-8(fp)
8111fb28:	10800043 	ldbu	r2,1(r2)
8111fb2c:	10803fcc 	andi	r2,r2,255
8111fb30:	100b883a 	mov	r5,r2
8111fb34:	01000044 	movi	r4,1
8111fb38:	11045b40 	call	811045b4 <bCommSetGlobalIrqEn>
8111fb3c:	10000f1e 	bne	r2,zero,8111fb7c <vNFeeStructureInit+0x214>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111fb40:	00a045f4 	movhi	r2,33047
8111fb44:	10a34f04 	addi	r2,r2,-29380
8111fb48:	10800a8b 	ldhu	r2,42(r2)
8111fb4c:	10bfffcc 	andi	r2,r2,65535
8111fb50:	10800228 	cmpgeui	r2,r2,8
8111fb54:	1000091e 	bne	r2,zero,8111fb7c <vNFeeStructureInit+0x214>
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111fb58:	d0e06217 	ldw	r3,-32376(gp)
8111fb5c:	e0bffe17 	ldw	r2,-8(fp)
8111fb60:	10800003 	ldbu	r2,0(r2)
8111fb64:	10803fcc 	andi	r2,r2,255
8111fb68:	100d883a 	mov	r6,r2
8111fb6c:	01604574 	movhi	r5,33045
8111fb70:	29494504 	addi	r5,r5,9492
8111fb74:	1809883a 	mov	r4,r3
8111fb78:	11236500 	call	81123650 <fprintf>
    	}
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111fb7c:	e0bffe17 	ldw	r2,-8(fp)
8111fb80:	10803304 	addi	r2,r2,204
8111fb84:	1009883a 	mov	r4,r2
8111fb88:	1104f380 	call	81104f38 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111fb8c:	00a045f4 	movhi	r2,33047
8111fb90:	10a34f04 	addi	r2,r2,-29380
8111fb94:	10800717 	ldw	r2,28(r2)
8111fb98:	1009883a 	mov	r4,r2
8111fb9c:	11052700 	call	81105270 <usiAdcPxDelayCalcPeriodNs>
8111fba0:	1007883a 	mov	r3,r2
8111fba4:	e0bffe17 	ldw	r2,-8(fp)
8111fba8:	10c03a8d 	sth	r3,234(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111fbac:	e0bffe17 	ldw	r2,-8(fp)
8111fbb0:	10003a0d 	sth	zero,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111fbb4:	00a045f4 	movhi	r2,33047
8111fbb8:	10a34f04 	addi	r2,r2,-29380
8111fbbc:	10800517 	ldw	r2,20(r2)
8111fbc0:	1009883a 	mov	r4,r2
8111fbc4:	11052fc0 	call	811052fc <usiLineTrDelayCalcPeriodNs>
8111fbc8:	1007883a 	mov	r3,r2
8111fbcc:	e0bffe17 	ldw	r2,-8(fp)
8111fbd0:	10c0398d 	sth	r3,230(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111fbd4:	e0bffe17 	ldw	r2,-8(fp)
8111fbd8:	10803304 	addi	r2,r2,204
8111fbdc:	1009883a 	mov	r4,r2
8111fbe0:	1104de40 	call	81104de4 <bDpktSetPixelDelay>

}
8111fbe4:	0001883a 	nop
8111fbe8:	e037883a 	mov	sp,fp
8111fbec:	dfc00117 	ldw	ra,4(sp)
8111fbf0:	df000017 	ldw	fp,0(sp)
8111fbf4:	dec00204 	addi	sp,sp,8
8111fbf8:	f800283a 	ret

8111fbfc <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111fbfc:	defff404 	addi	sp,sp,-48
8111fc00:	de00012e 	bgeu	sp,et,8111fc08 <vUpdateMemMapFEE+0xc>
8111fc04:	003b68fa 	trap	3
8111fc08:	df000b15 	stw	fp,44(sp)
8111fc0c:	df000b04 	addi	fp,sp,44
8111fc10:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111fc14:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111fc18:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111fc1c:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111fc20:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111fc24:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111fc28:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111fc2c:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111fc30:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111fc34:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111fc38:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111fc3c:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111fc40:	e17fff17 	ldw	r5,-4(fp)
8111fc44:	01035a34 	movhi	r4,3432
8111fc48:	21348c04 	addi	r4,r4,-11728
8111fc4c:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111fc50:	e13fff17 	ldw	r4,-4(fp)
8111fc54:	21000003 	ldbu	r4,0(r4)
8111fc58:	21403fcc 	andi	r5,r4,255
8111fc5c:	01035a34 	movhi	r4,3432
8111fc60:	21348c04 	addi	r4,r4,-11728
8111fc64:	2909383a 	mul	r4,r5,r4
8111fc68:	200b883a 	mov	r5,r4
8111fc6c:	e13fff17 	ldw	r4,-4(fp)
8111fc70:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111fc74:	e13fff17 	ldw	r4,-4(fp)
8111fc78:	21400117 	ldw	r5,4(r4)
8111fc7c:	01033234 	movhi	r4,3272
8111fc80:	21348c04 	addi	r4,r4,-11728
8111fc84:	290b883a 	add	r5,r5,r4
8111fc88:	e13fff17 	ldw	r4,-4(fp)
8111fc8c:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111fc90:	e13fff17 	ldw	r4,-4(fp)
8111fc94:	2100310b 	ldhu	r4,196(r4)
8111fc98:	217fffcc 	andi	r5,r4,65535
8111fc9c:	e13fff17 	ldw	r4,-4(fp)
8111fca0:	2100300b 	ldhu	r4,192(r4)
8111fca4:	213fffcc 	andi	r4,r4,65535
8111fca8:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111fcac:	e13fff17 	ldw	r4,-4(fp)
8111fcb0:	2100308b 	ldhu	r4,194(r4)
8111fcb4:	21bfffcc 	andi	r6,r4,65535
8111fcb8:	e13fff17 	ldw	r4,-4(fp)
8111fcbc:	21002f8b 	ldhu	r4,190(r4)
8111fcc0:	213fffcc 	andi	r4,r4,65535
8111fcc4:	310d883a 	add	r6,r6,r4
8111fcc8:	e13fff17 	ldw	r4,-4(fp)
8111fccc:	21002f0b 	ldhu	r4,188(r4)
8111fcd0:	213fffcc 	andi	r4,r4,65535
8111fcd4:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111fcd8:	2909383a 	mul	r4,r5,r4
8111fcdc:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111fce0:	e13ffa17 	ldw	r4,-24(fp)
8111fce4:	2109883a 	add	r4,r4,r4
8111fce8:	200b883a 	mov	r5,r4
8111fcec:	e13fff17 	ldw	r4,-4(fp)
8111fcf0:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111fcf4:	e13fff17 	ldw	r4,-4(fp)
8111fcf8:	21000517 	ldw	r4,20(r4)
8111fcfc:	2008d0fa 	srli	r4,r4,3
8111fd00:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111fd04:	e13fff17 	ldw	r4,-4(fp)
8111fd08:	21000517 	ldw	r4,20(r4)
8111fd0c:	210001cc 	andi	r4,r4,7
8111fd10:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111fd14:	e13ffb17 	ldw	r4,-20(fp)
8111fd18:	20001226 	beq	r4,zero,8111fd64 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111fd1c:	e13ff517 	ldw	r4,-44(fp)
8111fd20:	21000044 	addi	r4,r4,1
8111fd24:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111fd28:	e13fff17 	ldw	r4,-4(fp)
8111fd2c:	21400517 	ldw	r5,20(r4)
8111fd30:	e13ffb17 	ldw	r4,-20(fp)
8111fd34:	2909c83a 	sub	r4,r5,r4
8111fd38:	21400204 	addi	r5,r4,8
8111fd3c:	e13fff17 	ldw	r4,-4(fp)
8111fd40:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111fd44:	e13ffb17 	ldw	r4,-20(fp)
8111fd48:	200b883a 	mov	r5,r4
8111fd4c:	01000204 	movi	r4,8
8111fd50:	2149c83a 	sub	r4,r4,r5
8111fd54:	200b883a 	mov	r5,r4
8111fd58:	e13fff17 	ldw	r4,-4(fp)
8111fd5c:	21400605 	stb	r5,24(r4)
8111fd60:	00000206 	br	8111fd6c <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111fd64:	e13fff17 	ldw	r4,-4(fp)
8111fd68:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111fd6c:	e13ff517 	ldw	r4,-44(fp)
8111fd70:	2008d13a 	srli	r4,r4,4
8111fd74:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111fd78:	e13ff517 	ldw	r4,-44(fp)
8111fd7c:	210003cc 	andi	r4,r4,15
8111fd80:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111fd84:	e13ffc17 	ldw	r4,-16(fp)
8111fd88:	20000b26 	beq	r4,zero,8111fdb8 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111fd8c:	e13ff717 	ldw	r4,-36(fp)
8111fd90:	21000044 	addi	r4,r4,1
8111fd94:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111fd98:	e17ff517 	ldw	r5,-44(fp)
8111fd9c:	e13ffc17 	ldw	r4,-16(fp)
8111fda0:	290bc83a 	sub	r5,r5,r4
8111fda4:	e13ff717 	ldw	r4,-36(fp)
8111fda8:	2909883a 	add	r4,r5,r4
8111fdac:	21000404 	addi	r4,r4,16
8111fdb0:	e13ff615 	stw	r4,-40(fp)
8111fdb4:	00000406 	br	8111fdc8 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111fdb8:	e17ff517 	ldw	r5,-44(fp)
8111fdbc:	e13ff717 	ldw	r4,-36(fp)
8111fdc0:	2909883a 	add	r4,r5,r4
8111fdc4:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111fdc8:	e13ff617 	ldw	r4,-40(fp)
8111fdcc:	200a90fa 	slli	r5,r4,3
8111fdd0:	e13fff17 	ldw	r4,-4(fp)
8111fdd4:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111fdd8:	e13ffb17 	ldw	r4,-20(fp)
8111fddc:	20000926 	beq	r4,zero,8111fe04 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111fde0:	e13ffc17 	ldw	r4,-16(fp)
8111fde4:	2109883a 	add	r4,r4,r4
8111fde8:	2109883a 	add	r4,r4,r4
8111fdec:	200b883a 	mov	r5,r4
8111fdf0:	e13ffb17 	ldw	r4,-20(fp)
8111fdf4:	2008d07a 	srli	r4,r4,1
8111fdf8:	2909883a 	add	r4,r5,r4
8111fdfc:	e13ff805 	stb	r4,-32(fp)
8111fe00:	00000406 	br	8111fe14 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111fe04:	e13ffc17 	ldw	r4,-16(fp)
8111fe08:	2109883a 	add	r4,r4,r4
8111fe0c:	2109883a 	add	r4,r4,r4
8111fe10:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111fe14:	e13ff803 	ldbu	r4,-32(fp)
8111fe18:	01401004 	movi	r5,64
8111fe1c:	2909c83a 	sub	r4,r5,r4
8111fe20:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8111fe24:	e13ffd03 	ldbu	r4,-12(fp)
8111fe28:	217ff804 	addi	r5,r4,-32
8111fe2c:	28000416 	blt	r5,zero,8111fe40 <vUpdateMemMapFEE+0x244>
8111fe30:	013fffc4 	movi	r4,-1
8111fe34:	2146983a 	sll	r3,r4,r5
8111fe38:	0005883a 	mov	r2,zero
8111fe3c:	00000a06 	br	8111fe68 <vUpdateMemMapFEE+0x26c>
8111fe40:	017fffc4 	movi	r5,-1
8111fe44:	280cd07a 	srli	r6,r5,1
8111fe48:	014007c4 	movi	r5,31
8111fe4c:	290bc83a 	sub	r5,r5,r4
8111fe50:	314ad83a 	srl	r5,r6,r5
8111fe54:	01bfffc4 	movi	r6,-1
8111fe58:	3106983a 	sll	r3,r6,r4
8111fe5c:	28c6b03a 	or	r3,r5,r3
8111fe60:	017fffc4 	movi	r5,-1
8111fe64:	2904983a 	sll	r2,r5,r4
8111fe68:	e13fff17 	ldw	r4,-4(fp)
8111fe6c:	20800715 	stw	r2,28(r4)
8111fe70:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111fe74:	e0bfff17 	ldw	r2,-4(fp)
8111fe78:	e0fff717 	ldw	r3,-36(fp)
8111fe7c:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111fe80:	e0bfff17 	ldw	r2,-4(fp)
8111fe84:	10c00117 	ldw	r3,4(r2)
8111fe88:	008004b4 	movhi	r2,18
8111fe8c:	10a40004 	addi	r2,r2,-28672
8111fe90:	1885883a 	add	r2,r3,r2
8111fe94:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111fe98:	e0bfff17 	ldw	r2,-4(fp)
8111fe9c:	10c00517 	ldw	r3,20(r2)
8111fea0:	008000b4 	movhi	r2,2
8111fea4:	10a40004 	addi	r2,r2,-28672
8111fea8:	1885883a 	add	r2,r3,r2
8111feac:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111feb0:	e03ff845 	stb	zero,-31(fp)
8111feb4:	00001906 	br	8111ff1c <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111feb8:	e0bff843 	ldbu	r2,-31(fp)
8111febc:	e0ffff17 	ldw	r3,-4(fp)
8111fec0:	10800624 	muli	r2,r2,24
8111fec4:	1885883a 	add	r2,r3,r2
8111fec8:	10800904 	addi	r2,r2,36
8111fecc:	e0fff917 	ldw	r3,-28(fp)
8111fed0:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111fed4:	e0fff917 	ldw	r3,-28(fp)
8111fed8:	e0bffe17 	ldw	r2,-8(fp)
8111fedc:	1885883a 	add	r2,r3,r2
8111fee0:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111fee4:	e0bff843 	ldbu	r2,-31(fp)
8111fee8:	e0ffff17 	ldw	r3,-4(fp)
8111feec:	10800624 	muli	r2,r2,24
8111fef0:	1885883a 	add	r2,r3,r2
8111fef4:	10800c04 	addi	r2,r2,48
8111fef8:	e0fff917 	ldw	r3,-28(fp)
8111fefc:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111ff00:	e0fff917 	ldw	r3,-28(fp)
8111ff04:	e0bffe17 	ldw	r2,-8(fp)
8111ff08:	1885883a 	add	r2,r3,r2
8111ff0c:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111ff10:	e0bff843 	ldbu	r2,-31(fp)
8111ff14:	10800044 	addi	r2,r2,1
8111ff18:	e0bff845 	stb	r2,-31(fp)
8111ff1c:	e0bff843 	ldbu	r2,-31(fp)
8111ff20:	10800130 	cmpltui	r2,r2,4
8111ff24:	103fe41e 	bne	r2,zero,8111feb8 <__reset+0xfb0ffeb8>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111ff28:	0001883a 	nop
8111ff2c:	e037883a 	mov	sp,fp
8111ff30:	df000017 	ldw	fp,0(sp)
8111ff34:	dec00104 	addi	sp,sp,4
8111ff38:	f800283a 	ret

8111ff3c <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111ff3c:	defffd04 	addi	sp,sp,-12
8111ff40:	de00012e 	bgeu	sp,et,8111ff48 <vResetMemCCDFEE+0xc>
8111ff44:	003b68fa 	trap	3
8111ff48:	df000215 	stw	fp,8(sp)
8111ff4c:	df000204 	addi	fp,sp,8
8111ff50:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111ff54:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111ff58:	e03ffe05 	stb	zero,-8(fp)
8111ff5c:	00001b06 	br	8111ffcc <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111ff60:	e0bffe03 	ldbu	r2,-8(fp)
8111ff64:	e0ffff17 	ldw	r3,-4(fp)
8111ff68:	10800624 	muli	r2,r2,24
8111ff6c:	1885883a 	add	r2,r3,r2
8111ff70:	10800b04 	addi	r2,r2,44
8111ff74:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111ff78:	e0bffe03 	ldbu	r2,-8(fp)
8111ff7c:	e0ffff17 	ldw	r3,-4(fp)
8111ff80:	10800624 	muli	r2,r2,24
8111ff84:	1885883a 	add	r2,r3,r2
8111ff88:	10800a04 	addi	r2,r2,40
8111ff8c:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111ff90:	e0bffe03 	ldbu	r2,-8(fp)
8111ff94:	e0ffff17 	ldw	r3,-4(fp)
8111ff98:	10800624 	muli	r2,r2,24
8111ff9c:	1885883a 	add	r2,r3,r2
8111ffa0:	10800e04 	addi	r2,r2,56
8111ffa4:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111ffa8:	e0bffe03 	ldbu	r2,-8(fp)
8111ffac:	e0ffff17 	ldw	r3,-4(fp)
8111ffb0:	10800624 	muli	r2,r2,24
8111ffb4:	1885883a 	add	r2,r3,r2
8111ffb8:	10800d04 	addi	r2,r2,52
8111ffbc:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111ffc0:	e0bffe03 	ldbu	r2,-8(fp)
8111ffc4:	10800044 	addi	r2,r2,1
8111ffc8:	e0bffe05 	stb	r2,-8(fp)
8111ffcc:	e0bffe03 	ldbu	r2,-8(fp)
8111ffd0:	10800130 	cmpltui	r2,r2,4
8111ffd4:	103fe21e 	bne	r2,zero,8111ff60 <__reset+0xfb0fff60>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111ffd8:	0001883a 	nop
8111ffdc:	e037883a 	mov	sp,fp
8111ffe0:	df000017 	ldw	fp,0(sp)
8111ffe4:	dec00104 	addi	sp,sp,4
8111ffe8:	f800283a 	ret

8111ffec <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111ffec:	defffe04 	addi	sp,sp,-8
8111fff0:	de00012e 	bgeu	sp,et,8111fff8 <vFeeSpwRMAPLoadDefault+0xc>
8111fff4:	003b68fa 	trap	3
8111fff8:	df000115 	stw	fp,4(sp)
8111fffc:	df000104 	addi	fp,sp,4
81120000:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
81120004:	0001883a 	nop
81120008:	e037883a 	mov	sp,fp
8112000c:	df000017 	ldw	fp,0(sp)
81120010:	dec00104 	addi	sp,sp,4
81120014:	f800283a 	ret

81120018 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81120018:	defffe04 	addi	sp,sp,-8
8112001c:	de00012e 	bgeu	sp,et,81120024 <vFeeSpwRMAPChangeConfig+0xc>
81120020:	003b68fa 	trap	3
81120024:	df000115 	stw	fp,4(sp)
81120028:	df000104 	addi	fp,sp,4
8112002c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81120030:	0001883a 	nop
81120034:	e037883a 	mov	sp,fp
81120038:	df000017 	ldw	fp,0(sp)
8112003c:	dec00104 	addi	sp,sp,4
81120040:	f800283a 	ret

81120044 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81120044:	defffe04 	addi	sp,sp,-8
81120048:	de00012e 	bgeu	sp,et,81120050 <vFeeSpwRMAPChangeDefault+0xc>
8112004c:	003b68fa 	trap	3
81120050:	df000115 	stw	fp,4(sp)
81120054:	df000104 	addi	fp,sp,4
81120058:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8112005c:	0001883a 	nop
81120060:	e037883a 	mov	sp,fp
81120064:	df000017 	ldw	fp,0(sp)
81120068:	dec00104 	addi	sp,sp,4
8112006c:	f800283a 	ret

81120070 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81120070:	defffe04 	addi	sp,sp,-8
81120074:	de00012e 	bgeu	sp,et,8112007c <cFeeSpwChannelEnable+0xc>
81120078:	003b68fa 	trap	3
8112007c:	df000115 	stw	fp,4(sp)
81120080:	df000104 	addi	fp,sp,4
81120084:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81120088:	0001883a 	nop
8112008c:	e037883a 	mov	sp,fp
81120090:	df000017 	ldw	fp,0(sp)
81120094:	dec00104 	addi	sp,sp,4
81120098:	f800283a 	ret

8112009c <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8112009c:	defffe04 	addi	sp,sp,-8
811200a0:	de00012e 	bgeu	sp,et,811200a8 <cFeeSpwChannelDisable+0xc>
811200a4:	003b68fa 	trap	3
811200a8:	df000115 	stw	fp,4(sp)
811200ac:	df000104 	addi	fp,sp,4
811200b0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
811200b4:	0001883a 	nop
811200b8:	e037883a 	mov	sp,fp
811200bc:	df000017 	ldw	fp,0(sp)
811200c0:	dec00104 	addi	sp,sp,4
811200c4:	f800283a 	ret

811200c8 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
811200c8:	defffe04 	addi	sp,sp,-8
811200cc:	de00012e 	bgeu	sp,et,811200d4 <cFeeRMAPDump+0xc>
811200d0:	003b68fa 	trap	3
811200d4:	df000115 	stw	fp,4(sp)
811200d8:	df000104 	addi	fp,sp,4
811200dc:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
811200e0:	0001883a 	nop
811200e4:	e037883a 	mov	sp,fp
811200e8:	df000017 	ldw	fp,0(sp)
811200ec:	dec00104 	addi	sp,sp,4
811200f0:	f800283a 	ret

811200f4 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
811200f4:	defffe04 	addi	sp,sp,-8
811200f8:	de00012e 	bgeu	sp,et,81120100 <cFeeRMAPEchoingEnable+0xc>
811200fc:	003b68fa 	trap	3
81120100:	df000115 	stw	fp,4(sp)
81120104:	df000104 	addi	fp,sp,4
81120108:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8112010c:	e0bfff17 	ldw	r2,-4(fp)
81120110:	00c00044 	movi	r3,1
81120114:	10c02515 	stw	r3,148(r2)
}
81120118:	0001883a 	nop
8112011c:	e037883a 	mov	sp,fp
81120120:	df000017 	ldw	fp,0(sp)
81120124:	dec00104 	addi	sp,sp,4
81120128:	f800283a 	ret

8112012c <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8112012c:	defffe04 	addi	sp,sp,-8
81120130:	de00012e 	bgeu	sp,et,81120138 <cFeeRMAPEchoingDisable+0xc>
81120134:	003b68fa 	trap	3
81120138:	df000115 	stw	fp,4(sp)
8112013c:	df000104 	addi	fp,sp,4
81120140:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
81120144:	e0bfff17 	ldw	r2,-4(fp)
81120148:	10002515 	stw	zero,148(r2)
}
8112014c:	0001883a 	nop
81120150:	e037883a 	mov	sp,fp
81120154:	df000017 	ldw	fp,0(sp)
81120158:	dec00104 	addi	sp,sp,4
8112015c:	f800283a 	ret

81120160 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
81120160:	defffe04 	addi	sp,sp,-8
81120164:	de00012e 	bgeu	sp,et,8112016c <cFeeRMAPLogEnable+0xc>
81120168:	003b68fa 	trap	3
8112016c:	df000115 	stw	fp,4(sp)
81120170:	df000104 	addi	fp,sp,4
81120174:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
81120178:	e0bfff17 	ldw	r2,-4(fp)
8112017c:	00c00044 	movi	r3,1
81120180:	10c02415 	stw	r3,144(r2)
}
81120184:	0001883a 	nop
81120188:	e037883a 	mov	sp,fp
8112018c:	df000017 	ldw	fp,0(sp)
81120190:	dec00104 	addi	sp,sp,4
81120194:	f800283a 	ret

81120198 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
81120198:	defffe04 	addi	sp,sp,-8
8112019c:	de00012e 	bgeu	sp,et,811201a4 <cFeeRMAPLogDisable+0xc>
811201a0:	003b68fa 	trap	3
811201a4:	df000115 	stw	fp,4(sp)
811201a8:	df000104 	addi	fp,sp,4
811201ac:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
811201b0:	e0bfff17 	ldw	r2,-4(fp)
811201b4:	10002415 	stw	zero,144(r2)
}
811201b8:	0001883a 	nop
811201bc:	e037883a 	mov	sp,fp
811201c0:	df000017 	ldw	fp,0(sp)
811201c4:	dec00104 	addi	sp,sp,4
811201c8:	f800283a 	ret

811201cc <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
811201cc:	defffc04 	addi	sp,sp,-16
811201d0:	de00012e 	bgeu	sp,et,811201d8 <vNFeeControlInit+0xc>
811201d4:	003b68fa 	trap	3
811201d8:	dfc00315 	stw	ra,12(sp)
811201dc:	df000215 	stw	fp,8(sp)
811201e0:	df000204 	addi	fp,sp,8
811201e4:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
811201e8:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
811201ec:	e13fff17 	ldw	r4,-4(fp)
811201f0:	11203180 	call	81120318 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
811201f4:	e13fff17 	ldw	r4,-4(fp)
811201f8:	112034c0 	call	8112034c <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
811201fc:	e0bfff17 	ldw	r2,-4(fp)
81120200:	10009c15 	stw	zero,624(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81120204:	e03ffe05 	stb	zero,-8(fp)
81120208:	00002b06 	br	811202b8 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8112020c:	e0bffe03 	ldbu	r2,-8(fp)
81120210:	10809824 	muli	r2,r2,608
81120214:	e0ffff17 	ldw	r3,-4(fp)
81120218:	1885883a 	add	r2,r3,r2
8112021c:	e0fffe03 	ldbu	r3,-8(fp)
81120220:	180b883a 	mov	r5,r3
81120224:	1009883a 	mov	r4,r2
81120228:	111f9680 	call	8111f968 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8112022c:	e0bffe03 	ldbu	r2,-8(fp)
81120230:	e0fffe03 	ldbu	r3,-8(fp)
81120234:	18c09824 	muli	r3,r3,608
81120238:	18c02104 	addi	r3,r3,132
8112023c:	e13fff17 	ldw	r4,-4(fp)
81120240:	20c7883a 	add	r3,r4,r3
81120244:	e13fff17 	ldw	r4,-4(fp)
81120248:	10802644 	addi	r2,r2,153
8112024c:	1085883a 	add	r2,r2,r2
81120250:	1085883a 	add	r2,r2,r2
81120254:	2085883a 	add	r2,r4,r2
81120258:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8112025c:	e0bffe03 	ldbu	r2,-8(fp)
81120260:	e0fffe03 	ldbu	r3,-8(fp)
81120264:	18c09824 	muli	r3,r3,608
81120268:	18c02704 	addi	r3,r3,156
8112026c:	e13fff17 	ldw	r4,-4(fp)
81120270:	20c7883a 	add	r3,r4,r3
81120274:	e13fff17 	ldw	r4,-4(fp)
81120278:	10802684 	addi	r2,r2,154
8112027c:	1085883a 	add	r2,r2,r2
81120280:	1085883a 	add	r2,r2,r2
81120284:	2085883a 	add	r2,r4,r2
81120288:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8112028c:	e0bffe03 	ldbu	r2,-8(fp)
81120290:	e0ffff17 	ldw	r3,-4(fp)
81120294:	18c09817 	ldw	r3,608(r3)
81120298:	e13fff17 	ldw	r4,-4(fp)
8112029c:	10809824 	muli	r2,r2,608
811202a0:	2085883a 	add	r2,r4,r2
811202a4:	10802904 	addi	r2,r2,164
811202a8:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811202ac:	e0bffe03 	ldbu	r2,-8(fp)
811202b0:	10800044 	addi	r2,r2,1
811202b4:	e0bffe05 	stb	r2,-8(fp)
811202b8:	e0bffe03 	ldbu	r2,-8(fp)
811202bc:	103fd326 	beq	r2,zero,8112020c <__reset+0xfb10020c>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
811202c0:	0001883a 	nop
811202c4:	e037883a 	mov	sp,fp
811202c8:	dfc00117 	ldw	ra,4(sp)
811202cc:	df000017 	ldw	fp,0(sp)
811202d0:	dec00204 	addi	sp,sp,8
811202d4:	f800283a 	ret

811202d8 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
811202d8:	defffd04 	addi	sp,sp,-12
811202dc:	de00012e 	bgeu	sp,et,811202e4 <vSetTimeCode+0xc>
811202e0:	003b68fa 	trap	3
811202e4:	df000215 	stw	fp,8(sp)
811202e8:	df000204 	addi	fp,sp,8
811202ec:	e13ffe15 	stw	r4,-8(fp)
811202f0:	2805883a 	mov	r2,r5
811202f4:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
811202f8:	e0bffe17 	ldw	r2,-8(fp)
811202fc:	e0ffff03 	ldbu	r3,-4(fp)
81120300:	10c09b05 	stb	r3,620(r2)
}
81120304:	0001883a 	nop
81120308:	e037883a 	mov	sp,fp
8112030c:	df000017 	ldw	fp,0(sp)
81120310:	dec00104 	addi	sp,sp,4
81120314:	f800283a 	ret

81120318 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
81120318:	defffe04 	addi	sp,sp,-8
8112031c:	de00012e 	bgeu	sp,et,81120324 <vResetTimeCode+0xc>
81120320:	003b68fa 	trap	3
81120324:	df000115 	stw	fp,4(sp)
81120328:	df000104 	addi	fp,sp,4
8112032c:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
81120330:	e0bfff17 	ldw	r2,-4(fp)
81120334:	10009b05 	stb	zero,620(r2)
}
81120338:	0001883a 	nop
8112033c:	e037883a 	mov	sp,fp
81120340:	df000017 	ldw	fp,0(sp)
81120344:	dec00104 	addi	sp,sp,4
81120348:	f800283a 	ret

8112034c <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8112034c:	defffe04 	addi	sp,sp,-8
81120350:	de00012e 	bgeu	sp,et,81120358 <vLoadDefaultIdNFEEMaster+0xc>
81120354:	003b68fa 	trap	3
81120358:	df000115 	stw	fp,4(sp)
8112035c:	df000104 	addi	fp,sp,4
81120360:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
81120364:	e0bfff17 	ldw	r2,-4(fp)
81120368:	10009b45 	stb	zero,621(r2)
}
8112036c:	0001883a 	nop
81120370:	e037883a 	mov	sp,fp
81120374:	df000017 	ldw	fp,0(sp)
81120378:	dec00104 	addi	sp,sp,4
8112037c:	f800283a 	ret

81120380 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81120380:	defffd04 	addi	sp,sp,-12
81120384:	de00012e 	bgeu	sp,et,8112038c <vChangeIdNFEEMaster+0xc>
81120388:	003b68fa 	trap	3
8112038c:	df000215 	stw	fp,8(sp)
81120390:	df000204 	addi	fp,sp,8
81120394:	e13ffe15 	stw	r4,-8(fp)
81120398:	2805883a 	mov	r2,r5
8112039c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
811203a0:	e0bffe17 	ldw	r2,-8(fp)
811203a4:	e0ffff03 	ldbu	r3,-4(fp)
811203a8:	10c09b45 	stb	r3,621(r2)
}
811203ac:	0001883a 	nop
811203b0:	e037883a 	mov	sp,fp
811203b4:	df000017 	ldw	fp,0(sp)
811203b8:	dec00104 	addi	sp,sp,4
811203bc:	f800283a 	ret

811203c0 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
811203c0:	defffd04 	addi	sp,sp,-12
811203c4:	de00012e 	bgeu	sp,et,811203cc <vChangeDefaultIdNFEEMaster+0xc>
811203c8:	003b68fa 	trap	3
811203cc:	df000215 	stw	fp,8(sp)
811203d0:	df000204 	addi	fp,sp,8
811203d4:	e13ffe15 	stw	r4,-8(fp)
811203d8:	2805883a 	mov	r2,r5
811203dc:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
811203e0:	0001883a 	nop
811203e4:	e037883a 	mov	sp,fp
811203e8:	df000017 	ldw	fp,0(sp)
811203ec:	dec00104 	addi	sp,sp,4
811203f0:	f800283a 	ret

811203f4 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
811203f4:	defffe04 	addi	sp,sp,-8
811203f8:	de00012e 	bgeu	sp,et,81120400 <vInitSimucamBasicHW+0xc>
811203fc:	003b68fa 	trap	3
81120400:	dfc00115 	stw	ra,4(sp)
81120404:	df000015 	stw	fp,0(sp)
81120408:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8112040c:	01403fc4 	movi	r5,255
81120410:	0009883a 	mov	r4,zero
81120414:	110bc500 	call	8110bc50 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81120418:	01400834 	movhi	r5,32
8112041c:	297fffc4 	addi	r5,r5,-1
81120420:	0009883a 	mov	r4,zero
81120424:	110bcd00 	call	8110bcd0 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81120428:	01400074 	movhi	r5,1
8112042c:	01000044 	movi	r4,1
81120430:	110bcd00 	call	8110bcd0 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
81120434:	0009883a 	mov	r4,zero
81120438:	110d3880 	call	8110d388 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8112043c:	0009883a 	mov	r4,zero
81120440:	110d4580 	call	8110d458 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81120444:	01008004 	movi	r4,512
81120448:	110ced00 	call	8110ced0 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8112044c:	01008004 	movi	r4,512
81120450:	110ce5c0 	call	8110ce5c <vRstcReleaseDeviceReset>

	bEnableIsoDrivers();
81120454:	110b2a80 	call	8110b2a8 <bEnableIsoDrivers>
	bEnableLvdsBoard();
81120458:	110b3200 	call	8110b320 <bEnableLvdsBoard>

}
8112045c:	0001883a 	nop
81120460:	e037883a 	mov	sp,fp
81120464:	dfc00117 	ldw	ra,4(sp)
81120468:	df000017 	ldw	fp,0(sp)
8112046c:	dec00204 	addi	sp,sp,8
81120470:	f800283a 	ret

81120474 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81120474:	defffd04 	addi	sp,sp,-12
81120478:	de00012e 	bgeu	sp,et,81120480 <bLogWriteSDCard+0xc>
8112047c:	003b68fa 	trap	3
81120480:	df000215 	stw	fp,8(sp)
81120484:	df000204 	addi	fp,sp,8
81120488:	e13ffe15 	stw	r4,-8(fp)
8112048c:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81120490:	00800044 	movi	r2,1
}
81120494:	e037883a 	mov	sp,fp
81120498:	df000017 	ldw	fp,0(sp)
8112049c:	dec00104 	addi	sp,sp,4
811204a0:	f800283a 	ret

811204a4 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
811204a4:	deffe004 	addi	sp,sp,-128
811204a8:	de00012e 	bgeu	sp,et,811204b0 <vLogWriteNUC+0xc>
811204ac:	003b68fa 	trap	3
811204b0:	dfc01f15 	stw	ra,124(sp)
811204b4:	df001e15 	stw	fp,120(sp)
811204b8:	df001e04 	addi	fp,sp,120
811204bc:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
811204c0:	e03fe215 	stw	zero,-120(fp)
811204c4:	e0bfe304 	addi	r2,fp,-116
811204c8:	00c01b84 	movi	r3,110
811204cc:	180d883a 	mov	r6,r3
811204d0:	000b883a 	mov	r5,zero
811204d4:	1009883a 	mov	r4,r2
811204d8:	11248500 	call	81124850 <memset>
	memset(cTemp,0,114);
811204dc:	01801c84 	movi	r6,114
811204e0:	000b883a 	mov	r5,zero
811204e4:	e13fe204 	addi	r4,fp,-120
811204e8:	11248500 	call	81124850 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
811204ec:	e13fff17 	ldw	r4,-4(fp)
811204f0:	11251780 	call	81125178 <strlen>
811204f4:	10801c68 	cmpgeui	r2,r2,113
811204f8:	1000031e 	bne	r2,zero,81120508 <vLogWriteNUC+0x64>
811204fc:	e13fff17 	ldw	r4,-4(fp)
81120500:	11251780 	call	81125178 <strlen>
81120504:	00000106 	br	8112050c <vLogWriteNUC+0x68>
81120508:	00801c44 	movi	r2,113
8112050c:	100d883a 	mov	r6,r2
81120510:	e17fff17 	ldw	r5,-4(fp)
81120514:	e13fe204 	addi	r4,fp,-120
81120518:	11247000 	call	81124700 <memcpy>
	vSendLog ( cDataIn );
8112051c:	e13fff17 	ldw	r4,-4(fp)
81120520:	111ac540 	call	8111ac54 <vSendLog>
}
81120524:	0001883a 	nop
81120528:	e037883a 	mov	sp,fp
8112052c:	dfc00117 	ldw	ra,4(sp)
81120530:	df000017 	ldw	fp,0(sp)
81120534:	dec00204 	addi	sp,sp,8
81120538:	f800283a 	ret

8112053c <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8112053c:	defffd04 	addi	sp,sp,-12
81120540:	de00012e 	bgeu	sp,et,81120548 <vSimucamStructureInit+0xc>
81120544:	003b68fa 	trap	3
81120548:	dfc00215 	stw	ra,8(sp)
8112054c:	df000115 	stw	fp,4(sp)
81120550:	df000104 	addi	fp,sp,4
81120554:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
81120558:	e0bfff17 	ldw	r2,-4(fp)
8112055c:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
81120560:	e0bfff17 	ldw	r2,-4(fp)
81120564:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
81120568:	e13fff17 	ldw	r4,-4(fp)
8112056c:	11206280 	call	81120628 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81120570:	e13fff17 	ldw	r4,-4(fp)
81120574:	11206cc0 	call	811206cc <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
81120578:	e13fff17 	ldw	r4,-4(fp)
8112057c:	11207740 	call	81120774 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81120580:	e13fff17 	ldw	r4,-4(fp)
81120584:	11208140 	call	81120814 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
81120588:	e0bfff17 	ldw	r2,-4(fp)
8112058c:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
81120590:	e0bfff17 	ldw	r2,-4(fp)
81120594:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
81120598:	e0bfff17 	ldw	r2,-4(fp)
8112059c:	00c07d04 	movi	r3,500
811205a0:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
811205a4:	e0bfff17 	ldw	r2,-4(fp)
811205a8:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
811205ac:	e0bfff17 	ldw	r2,-4(fp)
811205b0:	00c00044 	movi	r3,1
811205b4:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
811205b8:	e0bfff17 	ldw	r2,-4(fp)
811205bc:	10c00204 	addi	r3,r2,8
811205c0:	e0bfff17 	ldw	r2,-4(fp)
811205c4:	10c0aa15 	stw	r3,680(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
811205c8:	e0bfff17 	ldw	r2,-4(fp)
811205cc:	10c00244 	addi	r3,r2,9
811205d0:	e0bfff17 	ldw	r2,-4(fp)
811205d4:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
811205d8:	e0bfff17 	ldw	r2,-4(fp)
811205dc:	10800017 	ldw	r2,0(r2)
811205e0:	10000b1e 	bne	r2,zero,81120610 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
811205e4:	e0bfff17 	ldw	r2,-4(fp)
811205e8:	10801204 	addi	r2,r2,72
811205ec:	1009883a 	mov	r4,r2
811205f0:	11201cc0 	call	811201cc <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
811205f4:	e0bfff17 	ldw	r2,-4(fp)
811205f8:	10c00a04 	addi	r3,r2,40
811205fc:	e0bfff17 	ldw	r2,-4(fp)
81120600:	10801204 	addi	r2,r2,72
81120604:	100b883a 	mov	r5,r2
81120608:	1809883a 	mov	r4,r3
8112060c:	111d0800 	call	8111d080 <vDataControllerInit>
        /* Are Fast Fee instances */
        /* todo: Not in use yet */
    }

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */
}
81120610:	0001883a 	nop
81120614:	e037883a 	mov	sp,fp
81120618:	dfc00117 	ldw	ra,4(sp)
8112061c:	df000017 	ldw	fp,0(sp)
81120620:	dec00204 	addi	sp,sp,8
81120624:	f800283a 	ret

81120628 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81120628:	defffe04 	addi	sp,sp,-8
8112062c:	de00012e 	bgeu	sp,et,81120634 <vLoadDefaultEPValue+0xc>
81120630:	003b68fa 	trap	3
81120634:	df000115 	stw	fp,4(sp)
81120638:	df000104 	addi	fp,sp,4
8112063c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
81120640:	e0bfff17 	ldw	r2,-4(fp)
81120644:	00d07234 	movhi	r3,16840
81120648:	10c00315 	stw	r3,12(r2)
}
8112064c:	0001883a 	nop
81120650:	e037883a 	mov	sp,fp
81120654:	df000017 	ldw	fp,0(sp)
81120658:	dec00104 	addi	sp,sp,4
8112065c:	f800283a 	ret

81120660 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81120660:	defffd04 	addi	sp,sp,-12
81120664:	de00012e 	bgeu	sp,et,8112066c <vChangeEPValue+0xc>
81120668:	003b68fa 	trap	3
8112066c:	df000215 	stw	fp,8(sp)
81120670:	df000204 	addi	fp,sp,8
81120674:	e13ffe15 	stw	r4,-8(fp)
81120678:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8112067c:	e0bffe17 	ldw	r2,-8(fp)
81120680:	e0ffff17 	ldw	r3,-4(fp)
81120684:	10c00315 	stw	r3,12(r2)
}
81120688:	0001883a 	nop
8112068c:	e037883a 	mov	sp,fp
81120690:	df000017 	ldw	fp,0(sp)
81120694:	dec00104 	addi	sp,sp,4
81120698:	f800283a 	ret

8112069c <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8112069c:	defffd04 	addi	sp,sp,-12
811206a0:	de00012e 	bgeu	sp,et,811206a8 <vChangeDefaultEPValue+0xc>
811206a4:	003b68fa 	trap	3
811206a8:	df000215 	stw	fp,8(sp)
811206ac:	df000204 	addi	fp,sp,8
811206b0:	e13ffe15 	stw	r4,-8(fp)
811206b4:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
811206b8:	0001883a 	nop
811206bc:	e037883a 	mov	sp,fp
811206c0:	df000017 	ldw	fp,0(sp)
811206c4:	dec00104 	addi	sp,sp,4
811206c8:	f800283a 	ret

811206cc <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
811206cc:	defffe04 	addi	sp,sp,-8
811206d0:	de00012e 	bgeu	sp,et,811206d8 <vLoadDefaultRTValue+0xc>
811206d4:	003b68fa 	trap	3
811206d8:	df000115 	stw	fp,4(sp)
811206dc:	df000104 	addi	fp,sp,4
811206e0:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
811206e4:	e0ffff17 	ldw	r3,-4(fp)
811206e8:	00901eb4 	movhi	r2,16506
811206ec:	10a66684 	addi	r2,r2,-26214
811206f0:	18800415 	stw	r2,16(r3)
}
811206f4:	0001883a 	nop
811206f8:	e037883a 	mov	sp,fp
811206fc:	df000017 	ldw	fp,0(sp)
81120700:	dec00104 	addi	sp,sp,4
81120704:	f800283a 	ret

81120708 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81120708:	defffd04 	addi	sp,sp,-12
8112070c:	de00012e 	bgeu	sp,et,81120714 <vChangeRTValue+0xc>
81120710:	003b68fa 	trap	3
81120714:	df000215 	stw	fp,8(sp)
81120718:	df000204 	addi	fp,sp,8
8112071c:	e13ffe15 	stw	r4,-8(fp)
81120720:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81120724:	e0bffe17 	ldw	r2,-8(fp)
81120728:	e0ffff17 	ldw	r3,-4(fp)
8112072c:	10c00415 	stw	r3,16(r2)
}
81120730:	0001883a 	nop
81120734:	e037883a 	mov	sp,fp
81120738:	df000017 	ldw	fp,0(sp)
8112073c:	dec00104 	addi	sp,sp,4
81120740:	f800283a 	ret

81120744 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81120744:	defffd04 	addi	sp,sp,-12
81120748:	de00012e 	bgeu	sp,et,81120750 <vChangeDefaultRTValue+0xc>
8112074c:	003b68fa 	trap	3
81120750:	df000215 	stw	fp,8(sp)
81120754:	df000204 	addi	fp,sp,8
81120758:	e13ffe15 	stw	r4,-8(fp)
8112075c:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
81120760:	0001883a 	nop
81120764:	e037883a 	mov	sp,fp
81120768:	df000017 	ldw	fp,0(sp)
8112076c:	dec00104 	addi	sp,sp,4
81120770:	f800283a 	ret

81120774 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81120774:	defffe04 	addi	sp,sp,-8
81120778:	de00012e 	bgeu	sp,et,81120780 <vLoadDefaultSyncSource+0xc>
8112077c:	003b68fa 	trap	3
81120780:	df000115 	stw	fp,4(sp)
81120784:	df000104 	addi	fp,sp,4
81120788:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8112078c:	e0bfff17 	ldw	r2,-4(fp)
81120790:	10000815 	stw	zero,32(r2)
}
81120794:	0001883a 	nop
81120798:	e037883a 	mov	sp,fp
8112079c:	df000017 	ldw	fp,0(sp)
811207a0:	dec00104 	addi	sp,sp,4
811207a4:	f800283a 	ret

811207a8 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811207a8:	defffd04 	addi	sp,sp,-12
811207ac:	de00012e 	bgeu	sp,et,811207b4 <vChangeSyncSource+0xc>
811207b0:	003b68fa 	trap	3
811207b4:	df000215 	stw	fp,8(sp)
811207b8:	df000204 	addi	fp,sp,8
811207bc:	e13ffe15 	stw	r4,-8(fp)
811207c0:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
811207c4:	e0bffe17 	ldw	r2,-8(fp)
811207c8:	e0ffff17 	ldw	r3,-4(fp)
811207cc:	10c00815 	stw	r3,32(r2)
}
811207d0:	0001883a 	nop
811207d4:	e037883a 	mov	sp,fp
811207d8:	df000017 	ldw	fp,0(sp)
811207dc:	dec00104 	addi	sp,sp,4
811207e0:	f800283a 	ret

811207e4 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811207e4:	defffd04 	addi	sp,sp,-12
811207e8:	de00012e 	bgeu	sp,et,811207f0 <vChangeDefaultSyncSource+0xc>
811207ec:	003b68fa 	trap	3
811207f0:	df000215 	stw	fp,8(sp)
811207f4:	df000204 	addi	fp,sp,8
811207f8:	e13ffe15 	stw	r4,-8(fp)
811207fc:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
81120800:	0001883a 	nop
81120804:	e037883a 	mov	sp,fp
81120808:	df000017 	ldw	fp,0(sp)
8112080c:	dec00104 	addi	sp,sp,4
81120810:	f800283a 	ret

81120814 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
81120814:	defffe04 	addi	sp,sp,-8
81120818:	de00012e 	bgeu	sp,et,81120820 <vLoadDefaultAutoResetSync+0xc>
8112081c:	003b68fa 	trap	3
81120820:	df000115 	stw	fp,4(sp)
81120824:	df000104 	addi	fp,sp,4
81120828:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8112082c:	e0bfff17 	ldw	r2,-4(fp)
81120830:	00c00044 	movi	r3,1
81120834:	10c00915 	stw	r3,36(r2)
}
81120838:	0001883a 	nop
8112083c:	e037883a 	mov	sp,fp
81120840:	df000017 	ldw	fp,0(sp)
81120844:	dec00104 	addi	sp,sp,4
81120848:	f800283a 	ret

8112084c <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8112084c:	defffd04 	addi	sp,sp,-12
81120850:	de00012e 	bgeu	sp,et,81120858 <vChangeAutoResetSync+0xc>
81120854:	003b68fa 	trap	3
81120858:	df000215 	stw	fp,8(sp)
8112085c:	df000204 	addi	fp,sp,8
81120860:	e13ffe15 	stw	r4,-8(fp)
81120864:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
81120868:	e0bffe17 	ldw	r2,-8(fp)
8112086c:	e0ffff17 	ldw	r3,-4(fp)
81120870:	10c00915 	stw	r3,36(r2)
}
81120874:	0001883a 	nop
81120878:	e037883a 	mov	sp,fp
8112087c:	df000017 	ldw	fp,0(sp)
81120880:	dec00104 	addi	sp,sp,4
81120884:	f800283a 	ret

81120888 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81120888:	defffd04 	addi	sp,sp,-12
8112088c:	de00012e 	bgeu	sp,et,81120894 <vChangeDefaultAutoResetSync+0xc>
81120890:	003b68fa 	trap	3
81120894:	df000215 	stw	fp,8(sp)
81120898:	df000204 	addi	fp,sp,8
8112089c:	e13ffe15 	stw	r4,-8(fp)
811208a0:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
811208a4:	0001883a 	nop
811208a8:	e037883a 	mov	sp,fp
811208ac:	df000017 	ldw	fp,0(sp)
811208b0:	dec00104 	addi	sp,sp,4
811208b4:	f800283a 	ret

811208b8 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
811208b8:	defffc04 	addi	sp,sp,-16
811208bc:	de00012e 	bgeu	sp,et,811208c4 <vSyncReset+0xc>
811208c0:	003b68fa 	trap	3
811208c4:	dfc00315 	stw	ra,12(sp)
811208c8:	df000215 	stw	fp,8(sp)
811208cc:	df000204 	addi	fp,sp,8
811208d0:	e13ffe15 	stw	r4,-8(fp)
811208d4:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
811208d8:	e0bffe17 	ldw	r2,-8(fp)
811208dc:	10801204 	addi	r2,r2,72
811208e0:	1009883a 	mov	r4,r2
811208e4:	11203180 	call	81120318 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
811208e8:	0001883a 	nop
811208ec:	e037883a 	mov	sp,fp
811208f0:	dfc00117 	ldw	ra,4(sp)
811208f4:	df000017 	ldw	fp,0(sp)
811208f8:	dec00204 	addi	sp,sp,8
811208fc:	f800283a 	ret

81120900 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
81120900:	defff004 	addi	sp,sp,-64
81120904:	de00012e 	bgeu	sp,et,8112090c <pattern_createPattern+0xc>
81120908:	003b68fa 	trap	3
8112090c:	dfc00f15 	stw	ra,60(sp)
81120910:	df000e15 	stw	fp,56(sp)
81120914:	dcc00d15 	stw	r19,52(sp)
81120918:	dc800c15 	stw	r18,48(sp)
8112091c:	dc400b15 	stw	r17,44(sp)
81120920:	dc000a15 	stw	r16,40(sp)
81120924:	df000e04 	addi	fp,sp,56
81120928:	e17ff915 	stw	r5,-28(fp)
8112092c:	3007883a 	mov	r3,r6
81120930:	3805883a 	mov	r2,r7
81120934:	e13ff805 	stb	r4,-32(fp)
81120938:	e0fffa05 	stb	r3,-24(fp)
8112093c:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
81120940:	e0bff803 	ldbu	r2,-32(fp)
81120944:	1009883a 	mov	r4,r2
81120948:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8112094c:	e0bff917 	ldw	r2,-28(fp)
81120950:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
81120954:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
81120958:	e0bff217 	ldw	r2,-56(fp)
8112095c:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81120960:	e03ff515 	stw	zero,-44(fp)
81120964:	00003606 	br	81120a40 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81120968:	e03ff615 	stw	zero,-40(fp)
8112096c:	00002e06 	br	81120a28 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
81120970:	e0bff303 	ldbu	r2,-52(fp)
81120974:	10801018 	cmpnei	r2,r2,64
81120978:	10000b1e 	bne	r2,zero,811209a8 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8112097c:	e0bff417 	ldw	r2,-48(fp)
81120980:	00ffffc4 	movi	r3,-1
81120984:	10c02015 	stw	r3,128(r2)
81120988:	00ffffc4 	movi	r3,-1
8112098c:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
81120990:	e0bff217 	ldw	r2,-56(fp)
81120994:	10802204 	addi	r2,r2,136
81120998:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8112099c:	e0bff217 	ldw	r2,-56(fp)
811209a0:	e0bff415 	stw	r2,-48(fp)
				i = 0;
811209a4:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
811209a8:	e0bff303 	ldbu	r2,-52(fp)
811209ac:	10c00044 	addi	r3,r2,1
811209b0:	e0fff305 	stb	r3,-52(fp)
811209b4:	10803fcc 	andi	r2,r2,255
811209b8:	e0fffa03 	ldbu	r3,-24(fp)
811209bc:	18c000cc 	andi	r3,r3,3
811209c0:	180692fa 	slli	r3,r3,11
811209c4:	1809883a 	mov	r4,r3
811209c8:	00f80004 	movi	r3,-8192
811209cc:	20c6b03a 	or	r3,r4,r3
811209d0:	1809883a 	mov	r4,r3
811209d4:	e0fffb03 	ldbu	r3,-20(fp)
811209d8:	18c0004c 	andi	r3,r3,1
811209dc:	180692ba 	slli	r3,r3,10
811209e0:	20c6b03a 	or	r3,r4,r3
811209e4:	1809883a 	mov	r4,r3
811209e8:	e0fff517 	ldw	r3,-44(fp)
811209ec:	18c007cc 	andi	r3,r3,31
811209f0:	1806917a 	slli	r3,r3,5
811209f4:	20c6b03a 	or	r3,r4,r3
811209f8:	1809883a 	mov	r4,r3
811209fc:	e0fff617 	ldw	r3,-40(fp)
81120a00:	18c007cc 	andi	r3,r3,31
81120a04:	20c6b03a 	or	r3,r4,r3
81120a08:	1809883a 	mov	r4,r3
81120a0c:	e0fff417 	ldw	r3,-48(fp)
81120a10:	1085883a 	add	r2,r2,r2
81120a14:	1885883a 	add	r2,r3,r2
81120a18:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81120a1c:	e0bff617 	ldw	r2,-40(fp)
81120a20:	10800044 	addi	r2,r2,1
81120a24:	e0bff615 	stw	r2,-40(fp)
81120a28:	e0fff617 	ldw	r3,-40(fp)
81120a2c:	e0800217 	ldw	r2,8(fp)
81120a30:	18bfcf36 	bltu	r3,r2,81120970 <__reset+0xfb100970>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81120a34:	e0bff517 	ldw	r2,-44(fp)
81120a38:	10800044 	addi	r2,r2,1
81120a3c:	e0bff515 	stw	r2,-44(fp)
81120a40:	e0fff517 	ldw	r3,-44(fp)
81120a44:	e0800317 	ldw	r2,12(fp)
81120a48:	18bfc736 	bltu	r3,r2,81120968 <__reset+0xfb100968>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
81120a4c:	e0bff417 	ldw	r2,-48(fp)
81120a50:	10002015 	stw	zero,128(r2)
81120a54:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81120a58:	e03ff705 	stb	zero,-36(fp)
81120a5c:	00001c06 	br	81120ad0 <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
81120a60:	e13ff417 	ldw	r4,-48(fp)
81120a64:	20802017 	ldw	r2,128(r4)
81120a68:	20c02117 	ldw	r3,132(r4)
81120a6c:	e13ff703 	ldbu	r4,-36(fp)
81120a70:	217ff804 	addi	r5,r4,-32
81120a74:	28000416 	blt	r5,zero,81120a88 <pattern_createPattern+0x188>
81120a78:	01200034 	movhi	r4,32768
81120a7c:	2160d83a 	srl	r16,r4,r5
81120a80:	0023883a 	mov	r17,zero
81120a84:	00000a06 	br	81120ab0 <pattern_createPattern+0x1b0>
81120a88:	01600034 	movhi	r5,32768
81120a8c:	280c907a 	slli	r6,r5,1
81120a90:	014007c4 	movi	r5,31
81120a94:	290bc83a 	sub	r5,r5,r4
81120a98:	314a983a 	sll	r5,r6,r5
81120a9c:	000d883a 	mov	r6,zero
81120aa0:	3120d83a 	srl	r16,r6,r4
81120aa4:	2c20b03a 	or	r16,r5,r16
81120aa8:	01600034 	movhi	r5,32768
81120aac:	2922d83a 	srl	r17,r5,r4
81120ab0:	1424b03a 	or	r18,r2,r16
81120ab4:	1c66b03a 	or	r19,r3,r17
81120ab8:	e0bff417 	ldw	r2,-48(fp)
81120abc:	14802015 	stw	r18,128(r2)
81120ac0:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81120ac4:	e0bff703 	ldbu	r2,-36(fp)
81120ac8:	10800044 	addi	r2,r2,1
81120acc:	e0bff705 	stb	r2,-36(fp)
81120ad0:	e0fff703 	ldbu	r3,-36(fp)
81120ad4:	e0bff303 	ldbu	r2,-52(fp)
81120ad8:	18bfe136 	bltu	r3,r2,81120a60 <__reset+0xfb100a60>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}

	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
81120adc:	e0bff217 	ldw	r2,-56(fp)
81120ae0:	10802204 	addi	r2,r2,136
81120ae4:	e0bff215 	stw	r2,-56(fp)
	return offset;
81120ae8:	e0bff217 	ldw	r2,-56(fp)
}
81120aec:	e6fffc04 	addi	sp,fp,-16
81120af0:	dfc00517 	ldw	ra,20(sp)
81120af4:	df000417 	ldw	fp,16(sp)
81120af8:	dcc00317 	ldw	r19,12(sp)
81120afc:	dc800217 	ldw	r18,8(sp)
81120b00:	dc400117 	ldw	r17,4(sp)
81120b04:	dc000017 	ldw	r16,0(sp)
81120b08:	dec00604 	addi	sp,sp,24
81120b0c:	f800283a 	ret

81120b10 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81120b10:	defffe04 	addi	sp,sp,-8
81120b14:	de00012e 	bgeu	sp,et,81120b1c <bSDcardIsPresent+0xc>
81120b18:	003b68fa 	trap	3
81120b1c:	dfc00115 	stw	ra,4(sp)
81120b20:	df000015 	stw	fp,0(sp)
81120b24:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81120b28:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
}
81120b2c:	e037883a 	mov	sp,fp
81120b30:	dfc00117 	ldw	ra,4(sp)
81120b34:	df000017 	ldw	fp,0(sp)
81120b38:	dec00204 	addi	sp,sp,8
81120b3c:	f800283a 	ret

81120b40 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81120b40:	defffe04 	addi	sp,sp,-8
81120b44:	de00012e 	bgeu	sp,et,81120b4c <bSDcardFAT16Check+0xc>
81120b48:	003b68fa 	trap	3
81120b4c:	dfc00115 	stw	ra,4(sp)
81120b50:	df000015 	stw	fp,0(sp)
81120b54:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
81120b58:	11470180 	call	81147018 <alt_up_sd_card_is_FAT16>
}
81120b5c:	e037883a 	mov	sp,fp
81120b60:	dfc00117 	ldw	ra,4(sp)
81120b64:	df000017 	ldw	fp,0(sp)
81120b68:	dec00204 	addi	sp,sp,8
81120b6c:	f800283a 	ret

81120b70 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81120b70:	defffd04 	addi	sp,sp,-12
81120b74:	de00012e 	bgeu	sp,et,81120b7c <bInitializeSDCard+0xc>
81120b78:	003b68fa 	trap	3
81120b7c:	dfc00215 	stw	ra,8(sp)
81120b80:	df000115 	stw	fp,4(sp)
81120b84:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
81120b88:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81120b8c:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81120b90:	01204574 	movhi	r4,33045
81120b94:	21095504 	addi	r4,r4,9556
81120b98:	1146e880 	call	81146e88 <alt_up_sd_card_open_dev>
81120b9c:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81120ba0:	d0a07717 	ldw	r2,-32292(gp)
81120ba4:	10002226 	beq	r2,zero,81120c30 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
81120ba8:	1120b100 	call	81120b10 <bSDcardIsPresent>
81120bac:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81120bb0:	e0bfff17 	ldw	r2,-4(fp)
81120bb4:	10001626 	beq	r2,zero,81120c10 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
81120bb8:	1120b400 	call	81120b40 <bSDcardFAT16Check>
81120bbc:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81120bc0:	e0bfff17 	ldw	r2,-4(fp)
81120bc4:	10000a26 	beq	r2,zero,81120bf0 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
81120bc8:	00800044 	movi	r2,1
81120bcc:	d0a07615 	stw	r2,-32296(gp)
				#if DEBUG_ON
					debug(fp, "SD is up.\r\n");
81120bd0:	d0a06217 	ldw	r2,-32376(gp)
81120bd4:	100f883a 	mov	r7,r2
81120bd8:	018002c4 	movi	r6,11
81120bdc:	01400044 	movi	r5,1
81120be0:	01204574 	movhi	r4,33045
81120be4:	21096004 	addi	r4,r4,9600
81120be8:	1123cec0 	call	81123cec <fwrite>
81120bec:	00001806 	br	81120c50 <bInitializeSDCard+0xe0>
				#endif

			} else {
				/* SD isn't in FAT16 format*/
				#if DEBUG_ON
					debug(fp, "SD Card should be formated in FAT16.\r\n");
81120bf0:	d0a06217 	ldw	r2,-32376(gp)
81120bf4:	100f883a 	mov	r7,r2
81120bf8:	01800984 	movi	r6,38
81120bfc:	01400044 	movi	r5,1
81120c00:	01204574 	movhi	r4,33045
81120c04:	21096304 	addi	r4,r4,9612
81120c08:	1123cec0 	call	81123cec <fwrite>
81120c0c:	00001006 	br	81120c50 <bInitializeSDCard+0xe0>
				#endif
			}
		} else {
			/* There's no SDCard in the slot */
			#if DEBUG_ON
				debug(fp, "There is no SD in the slot.\r\n");
81120c10:	d0a06217 	ldw	r2,-32376(gp)
81120c14:	100f883a 	mov	r7,r2
81120c18:	01800744 	movi	r6,29
81120c1c:	01400044 	movi	r5,1
81120c20:	01204574 	movhi	r4,33045
81120c24:	21096d04 	addi	r4,r4,9652
81120c28:	1123cec0 	call	81123cec <fwrite>
81120c2c:	00000806 	br	81120c50 <bInitializeSDCard+0xe0>
			#endif
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81120c30:	e03fff15 	stw	zero,-4(fp)
		#if DEBUG_ON
			debug(fp, "Unable to open the SDCard device.\r\n");
81120c34:	d0a06217 	ldw	r2,-32376(gp)
81120c38:	100f883a 	mov	r7,r2
81120c3c:	018008c4 	movi	r6,35
81120c40:	01400044 	movi	r5,1
81120c44:	01204574 	movhi	r4,33045
81120c48:	21097504 	addi	r4,r4,9684
81120c4c:	1123cec0 	call	81123cec <fwrite>
		#endif
	}

	return bSucess;
81120c50:	e0bfff17 	ldw	r2,-4(fp)
}
81120c54:	e037883a 	mov	sp,fp
81120c58:	dfc00117 	ldw	ra,4(sp)
81120c5c:	df000017 	ldw	fp,0(sp)
81120c60:	dec00204 	addi	sp,sp,8
81120c64:	f800283a 	ret

81120c68 <siOpenFile>:

short int siOpenFile( char *filename ) {
81120c68:	defffd04 	addi	sp,sp,-12
81120c6c:	de00012e 	bgeu	sp,et,81120c74 <siOpenFile+0xc>
81120c70:	003b68fa 	trap	3
81120c74:	dfc00215 	stw	ra,8(sp)
81120c78:	df000115 	stw	fp,4(sp)
81120c7c:	df000104 	addi	fp,sp,4
81120c80:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81120c84:	000b883a 	mov	r5,zero
81120c88:	e13fff17 	ldw	r4,-4(fp)
81120c8c:	11475240 	call	81147524 <alt_up_sd_card_fopen>
}
81120c90:	e037883a 	mov	sp,fp
81120c94:	dfc00117 	ldw	ra,4(sp)
81120c98:	df000017 	ldw	fp,0(sp)
81120c9c:	dec00204 	addi	sp,sp,8
81120ca0:	f800283a 	ret

81120ca4 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81120ca4:	defffd04 	addi	sp,sp,-12
81120ca8:	de00012e 	bgeu	sp,et,81120cb0 <siCloseFile+0xc>
81120cac:	003b68fa 	trap	3
81120cb0:	dfc00215 	stw	ra,8(sp)
81120cb4:	df000115 	stw	fp,4(sp)
81120cb8:	df000104 	addi	fp,sp,4
81120cbc:	2005883a 	mov	r2,r4
81120cc0:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81120cc4:	e0bfff0f 	ldh	r2,-4(fp)
81120cc8:	1009883a 	mov	r4,r2
81120ccc:	11483700 	call	81148370 <alt_up_sd_card_fclose>
}
81120cd0:	e037883a 	mov	sp,fp
81120cd4:	dfc00117 	ldw	ra,4(sp)
81120cd8:	df000017 	ldw	fp,0(sp)
81120cdc:	dec00204 	addi	sp,sp,8
81120ce0:	f800283a 	ret

81120ce4 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81120ce4:	defffd04 	addi	sp,sp,-12
81120ce8:	de00012e 	bgeu	sp,et,81120cf0 <cGetNextChar+0xc>
81120cec:	003b68fa 	trap	3
81120cf0:	dfc00215 	stw	ra,8(sp)
81120cf4:	df000115 	stw	fp,4(sp)
81120cf8:	df000104 	addi	fp,sp,4
81120cfc:	2005883a 	mov	r2,r4
81120d00:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81120d04:	e0bfff0f 	ldh	r2,-4(fp)
81120d08:	1009883a 	mov	r4,r2
81120d0c:	11479c80 	call	811479c8 <alt_up_sd_card_read>
}
81120d10:	e037883a 	mov	sp,fp
81120d14:	dfc00117 	ldw	ra,4(sp)
81120d18:	df000017 	ldw	fp,0(sp)
81120d1c:	dec00204 	addi	sp,sp,8
81120d20:	f800283a 	ret

81120d24 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81120d24:	defffd04 	addi	sp,sp,-12
81120d28:	de00012e 	bgeu	sp,et,81120d30 <bInitSync+0xc>
81120d2c:	003b68fa 	trap	3
81120d30:	dfc00215 	stw	ra,8(sp)
81120d34:	df000115 	stw	fp,4(sp)
81120d38:	df000104 	addi	fp,sp,4
	bool	bSuccess;

	vSyncInitIrq();
81120d3c:	110d5dc0 	call	8110d5dc <vSyncInitIrq>

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81120d40:	00a045f4 	movhi	r2,33047
81120d44:	10a34f04 	addi	r2,r2,-29380
81120d48:	10800a8b 	ldhu	r2,42(r2)
81120d4c:	10bfffcc 	andi	r2,r2,65535
81120d50:	108000e8 	cmpgeui	r2,r2,3
81120d54:	1000071e 	bne	r2,zero,81120d74 <bInitSync+0x50>
		debug(fp, "Initializing Sync Module.\n");
81120d58:	d0a06217 	ldw	r2,-32376(gp)
81120d5c:	100f883a 	mov	r7,r2
81120d60:	01800684 	movi	r6,26
81120d64:	01400044 	movi	r5,1
81120d68:	01204574 	movhi	r4,33045
81120d6c:	21097e04 	addi	r4,r4,9720
81120d70:	1123cec0 	call	81123cec <fwrite>
	}
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
81120d74:	01004c74 	movhi	r4,305
81120d78:	210b4004 	addi	r4,r4,11520
81120d7c:	110d7e40 	call	8110d7e4 <bSyncSetMbt>
81120d80:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120d84:	e0bfff17 	ldw	r2,-4(fp)
81120d88:	1000021e 	bne	r2,zero,81120d94 <bInitSync+0x70>
		return bSuccess;
81120d8c:	e0bfff17 	ldw	r2,-4(fp)
81120d90:	00004d06 	br	81120ec8 <bInitSync+0x1a4>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
81120d94:	01002674 	movhi	r4,153
81120d98:	2125a004 	addi	r4,r4,-27008
81120d9c:	110d8240 	call	8110d824 <bSyncSetBt>
81120da0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120da4:	e0bfff17 	ldw	r2,-4(fp)
81120da8:	1000021e 	bne	r2,zero,81120db4 <bInitSync+0x90>
		return bSuccess;
81120dac:	e0bfff17 	ldw	r2,-4(fp)
81120db0:	00004506 	br	81120ec8 <bInitSync+0x1a4>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
81120db4:	00a045f4 	movhi	r2,33047
81120db8:	10a34f04 	addi	r2,r2,-29380
81120dbc:	1080038b 	ldhu	r2,14(r2)
81120dc0:	10bfffcc 	andi	r2,r2,65535
81120dc4:	1009883a 	mov	r4,r2
81120dc8:	110e4bc0 	call	8110e4bc <uliPerCalcPeriodMs>
81120dcc:	1009883a 	mov	r4,r2
81120dd0:	110d8640 	call	8110d864 <bSyncSetPer>
81120dd4:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120dd8:	e0bfff17 	ldw	r2,-4(fp)
81120ddc:	1000021e 	bne	r2,zero,81120de8 <bInitSync+0xc4>
		return bSuccess;
81120de0:	e0bfff17 	ldw	r2,-4(fp)
81120de4:	00003806 	br	81120ec8 <bInitSync+0x1a4>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
81120de8:	01005f74 	movhi	r4,381
81120dec:	211e1004 	addi	r4,r4,30784
81120df0:	110d8a40 	call	8110d8a4 <bSyncSetOst>
81120df4:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120df8:	e0bfff17 	ldw	r2,-4(fp)
81120dfc:	1000021e 	bne	r2,zero,81120e08 <bInitSync+0xe4>
		return bSuccess;
81120e00:	e0bfff17 	ldw	r2,-4(fp)
81120e04:	00003006 	br	81120ec8 <bInitSync+0x1a4>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
81120e08:	0009883a 	mov	r4,zero
81120e0c:	110d8e40 	call	8110d8e4 <bSyncSetPolarity>
81120e10:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120e14:	e0bfff17 	ldw	r2,-4(fp)
81120e18:	1000021e 	bne	r2,zero,81120e24 <bInitSync+0x100>
		return bSuccess;
81120e1c:	e0bfff17 	ldw	r2,-4(fp)
81120e20:	00002906 	br	81120ec8 <bInitSync+0x1a4>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81120e24:	01000104 	movi	r4,4
81120e28:	110d9580 	call	8110d958 <bSyncSetNCycles>
81120e2c:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120e30:	e0bfff17 	ldw	r2,-4(fp)
81120e34:	1000021e 	bne	r2,zero,81120e40 <bInitSync+0x11c>
		return bSuccess;
81120e38:	e0bfff17 	ldw	r2,-4(fp)
81120e3c:	00002206 	br	81120ec8 <bInitSync+0x1a4>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
81120e40:	01000044 	movi	r4,1
81120e44:	110db340 	call	8110db34 <bSyncCtrExtnIrq>
81120e48:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120e4c:	e0bfff17 	ldw	r2,-4(fp)
81120e50:	1000021e 	bne	r2,zero,81120e5c <bInitSync+0x138>
		return bSuccess;
81120e54:	e0bfff17 	ldw	r2,-4(fp)
81120e58:	00001b06 	br	81120ec8 <bInitSync+0x1a4>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
81120e5c:	01000044 	movi	r4,1
81120e60:	110dcfc0 	call	8110dcfc <bSyncCtrSyncOutEnable>
81120e64:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120e68:	e0bfff17 	ldw	r2,-4(fp)
81120e6c:	1000021e 	bne	r2,zero,81120e78 <bInitSync+0x154>
		return bSuccess;
81120e70:	e0bfff17 	ldw	r2,-4(fp)
81120e74:	00001406 	br	81120ec8 <bInitSync+0x1a4>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
81120e78:	01000044 	movi	r4,1
81120e7c:	110dd700 	call	8110dd70 <bSyncCtrCh1OutEnable>
81120e80:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120e84:	e0bfff17 	ldw	r2,-4(fp)
81120e88:	1000021e 	bne	r2,zero,81120e94 <bInitSync+0x170>
		return bSuccess;
81120e8c:	e0bfff17 	ldw	r2,-4(fp)
81120e90:	00000d06 	br	81120ec8 <bInitSync+0x1a4>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
81120e94:	01000044 	movi	r4,1
81120e98:	110dde40 	call	8110dde4 <bSyncCtrCh2OutEnable>
81120e9c:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120ea0:	e0bfff17 	ldw	r2,-4(fp)
81120ea4:	1000021e 	bne	r2,zero,81120eb0 <bInitSync+0x18c>
		return bSuccess;
81120ea8:	e0bfff17 	ldw	r2,-4(fp)
81120eac:	00000606 	br	81120ec8 <bInitSync+0x1a4>
	}

	bSuccess = bSyncCtrStart();
81120eb0:	110dbac0 	call	8110dbac <bSyncCtrStart>
81120eb4:	e0bfff15 	stw	r2,-4(fp)
	bSyncCtrReset();
81120eb8:	110dc000 	call	8110dc00 <bSyncCtrReset>
	bSyncIrqEnableBlank(TRUE);
81120ebc:	01000044 	movi	r4,1
81120ec0:	110e1840 	call	8110e184 <bSyncIrqEnableBlank>


	return bSuccess;
81120ec4:	e0bfff17 	ldw	r2,-4(fp)
}
81120ec8:	e037883a 	mov	sp,fp
81120ecc:	dfc00117 	ldw	ra,4(sp)
81120ed0:	df000017 	ldw	fp,0(sp)
81120ed4:	dec00204 	addi	sp,sp,8
81120ed8:	f800283a 	ret

81120edc <bStartSync>:


bool bStartSync(void) {
81120edc:	defffd04 	addi	sp,sp,-12
81120ee0:	de00012e 	bgeu	sp,et,81120ee8 <bStartSync+0xc>
81120ee4:	003b68fa 	trap	3
81120ee8:	dfc00215 	stw	ra,8(sp)
81120eec:	df000115 	stw	fp,4(sp)
81120ef0:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
81120ef4:	110dc000 	call	8110dc00 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
81120ef8:	110dbac0 	call	8110dbac <bSyncCtrStart>
81120efc:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
81120f00:	e0bfff17 	ldw	r2,-4(fp)
}
81120f04:	e037883a 	mov	sp,fp
81120f08:	dfc00117 	ldw	ra,4(sp)
81120f0c:	df000017 	ldw	fp,0(sp)
81120f10:	dec00204 	addi	sp,sp,8
81120f14:	f800283a 	ret

81120f18 <bStopSync>:

bool bStopSync(void) {
81120f18:	defffe04 	addi	sp,sp,-8
81120f1c:	de00012e 	bgeu	sp,et,81120f24 <bStopSync+0xc>
81120f20:	003b68fa 	trap	3
81120f24:	dfc00115 	stw	ra,4(sp)
81120f28:	df000015 	stw	fp,0(sp)
81120f2c:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
81120f30:	110dc000 	call	8110dc00 <bSyncCtrReset>
}
81120f34:	e037883a 	mov	sp,fp
81120f38:	dfc00117 	ldw	ra,4(sp)
81120f3c:	df000017 	ldw	fp,0(sp)
81120f40:	dec00204 	addi	sp,sp,8
81120f44:	f800283a 	ret

81120f48 <bClearCounterSync>:

void bClearCounterSync(void) {
81120f48:	defffe04 	addi	sp,sp,-8
81120f4c:	de00012e 	bgeu	sp,et,81120f54 <bClearCounterSync+0xc>
81120f50:	003b68fa 	trap	3
81120f54:	dfc00115 	stw	ra,4(sp)
81120f58:	df000015 	stw	fp,0(sp)
81120f5c:	d839883a 	mov	fp,sp
	vSyncClearCounter();
81120f60:	110d5b00 	call	8110d5b0 <vSyncClearCounter>
}
81120f64:	0001883a 	nop
81120f68:	e037883a 	mov	sp,fp
81120f6c:	dfc00117 	ldw	ra,4(sp)
81120f70:	df000017 	ldw	fp,0(sp)
81120f74:	dec00204 	addi	sp,sp,8
81120f78:	f800283a 	ret

81120f7c <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
81120f7c:	defffd04 	addi	sp,sp,-12
81120f80:	de00012e 	bgeu	sp,et,81120f88 <bTestSimucamCriticalHW+0xc>
81120f84:	003b68fa 	trap	3
81120f88:	dfc00215 	stw	ra,8(sp)
81120f8c:	df000115 	stw	fp,4(sp)
81120f90:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
81120f94:	1103b840 	call	81103b84 <bSdmaInitM1Dma>
81120f98:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81120f9c:	e0bfff17 	ldw	r2,-4(fp)
81120fa0:	1000021e 	bne	r2,zero,81120fac <bTestSimucamCriticalHW+0x30>
		return bSuccess;
81120fa4:	e0bfff17 	ldw	r2,-4(fp)
81120fa8:	00000706 	br	81120fc8 <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
81120fac:	1103c400 	call	81103c40 <bSdmaInitM2Dma>
81120fb0:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81120fb4:	e0bfff17 	ldw	r2,-4(fp)
81120fb8:	1000021e 	bne	r2,zero,81120fc4 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
81120fbc:	e0bfff17 	ldw	r2,-4(fp)
81120fc0:	00000106 	br	81120fc8 <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
81120fc4:	00800044 	movi	r2,1
}
81120fc8:	e037883a 	mov	sp,fp
81120fcc:	dfc00117 	ldw	ra,4(sp)
81120fd0:	df000017 	ldw	fp,0(sp)
81120fd4:	dec00204 	addi	sp,sp,8
81120fd8:	f800283a 	ret

81120fdc <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81120fdc:	defffc04 	addi	sp,sp,-16
81120fe0:	de00012e 	bgeu	sp,et,81120fe8 <_reg_write+0xc>
81120fe4:	003b68fa 	trap	3
81120fe8:	df000315 	stw	fp,12(sp)
81120fec:	df000304 	addi	fp,sp,12
81120ff0:	e13ffd15 	stw	r4,-12(fp)
81120ff4:	e17ffe15 	stw	r5,-8(fp)
81120ff8:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81120ffc:	e0bffe17 	ldw	r2,-8(fp)
81121000:	1085883a 	add	r2,r2,r2
81121004:	1085883a 	add	r2,r2,r2
81121008:	1007883a 	mov	r3,r2
8112100c:	e0bffd17 	ldw	r2,-12(fp)
81121010:	1885883a 	add	r2,r3,r2
81121014:	1007883a 	mov	r3,r2
81121018:	e0bfff17 	ldw	r2,-4(fp)
8112101c:	18800035 	stwio	r2,0(r3)
	return 1;
81121020:	00800044 	movi	r2,1

}
81121024:	e037883a 	mov	sp,fp
81121028:	df000017 	ldw	fp,0(sp)
8112102c:	dec00104 	addi	sp,sp,4
81121030:	f800283a 	ret

81121034 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81121034:	defffc04 	addi	sp,sp,-16
81121038:	de00012e 	bgeu	sp,et,81121040 <_reg_read+0xc>
8112103c:	003b68fa 	trap	3
81121040:	df000315 	stw	fp,12(sp)
81121044:	df000304 	addi	fp,sp,12
81121048:	e13ffd15 	stw	r4,-12(fp)
8112104c:	e17ffe15 	stw	r5,-8(fp)
81121050:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81121054:	e0bffe17 	ldw	r2,-8(fp)
81121058:	1085883a 	add	r2,r2,r2
8112105c:	1085883a 	add	r2,r2,r2
81121060:	1007883a 	mov	r3,r2
81121064:	e0bffd17 	ldw	r2,-12(fp)
81121068:	1885883a 	add	r2,r3,r2
8112106c:	10c00037 	ldwio	r3,0(r2)
81121070:	e0bfff17 	ldw	r2,-4(fp)
81121074:	10c00015 	stw	r3,0(r2)
	return 1;
81121078:	00800044 	movi	r2,1

}
8112107c:	e037883a 	mov	sp,fp
81121080:	df000017 	ldw	fp,0(sp)
81121084:	dec00104 	addi	sp,sp,4
81121088:	f800283a 	ret

8112108c <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8112108c:	defffa04 	addi	sp,sp,-24
81121090:	de00012e 	bgeu	sp,et,81121098 <_print_codec_status+0xc>
81121094:	003b68fa 	trap	3
81121098:	dfc00515 	stw	ra,20(sp)
8112109c:	df000415 	stw	fp,16(sp)
811210a0:	df000404 	addi	fp,sp,16
811210a4:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
811210a8:	e0bfff17 	ldw	r2,-4(fp)
811210ac:	1005d1ba 	srai	r2,r2,6
811210b0:	1080004c 	andi	r2,r2,1
811210b4:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
811210b8:	e0bfff17 	ldw	r2,-4(fp)
811210bc:	1005d17a 	srai	r2,r2,5
811210c0:	1080004c 	andi	r2,r2,1
811210c4:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
811210c8:	e0bfff17 	ldw	r2,-4(fp)
811210cc:	1005d13a 	srai	r2,r2,4
811210d0:	1080004c 	andi	r2,r2,1
811210d4:	e0bffe15 	stw	r2,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811210d8:	00a045f4 	movhi	r2,33047
811210dc:	10a34f04 	addi	r2,r2,-29380
811210e0:	10800a8b 	ldhu	r2,42(r2)
811210e4:	10bfffcc 	andi	r2,r2,65535
811210e8:	108000e8 	cmpgeui	r2,r2,3
811210ec:	1000661e 	bne	r2,zero,81121288 <_print_codec_status+0x1fc>
		sprintf(cDebugBuffer, "-------- link status \n");
811210f0:	00e04574 	movhi	r3,33045
811210f4:	18d56904 	addi	r3,r3,21924
811210f8:	00a04574 	movhi	r2,33045
811210fc:	10898504 	addi	r2,r2,9748
81121100:	1009883a 	mov	r4,r2
81121104:	008005c4 	movi	r2,23
81121108:	100d883a 	mov	r6,r2
8112110c:	200b883a 	mov	r5,r4
81121110:	1809883a 	mov	r4,r3
81121114:	11247000 	call	81124700 <memcpy>
		debug(fp, cDebugBuffer);
81121118:	d0a06217 	ldw	r2,-32376(gp)
8112111c:	01604574 	movhi	r5,33045
81121120:	29556904 	addi	r5,r5,21924
81121124:	1009883a 	mov	r4,r2
81121128:	11236500 	call	81123650 <fprintf>
		sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8112112c:	e0bffc17 	ldw	r2,-16(fp)
81121130:	10800058 	cmpnei	r2,r2,1
81121134:	1000031e 	bne	r2,zero,81121144 <_print_codec_status+0xb8>
81121138:	00a04574 	movhi	r2,33045
8112113c:	10898b04 	addi	r2,r2,9772
81121140:	00000206 	br	8112114c <_print_codec_status+0xc0>
81121144:	00a04574 	movhi	r2,33045
81121148:	10898c04 	addi	r2,r2,9776
8112114c:	100d883a 	mov	r6,r2
81121150:	01604574 	movhi	r5,33045
81121154:	29498d04 	addi	r5,r5,9780
81121158:	01204574 	movhi	r4,33045
8112115c:	21156904 	addi	r4,r4,21924
81121160:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
81121164:	d0a06217 	ldw	r2,-32376(gp)
81121168:	01604574 	movhi	r5,33045
8112116c:	29556904 	addi	r5,r5,21924
81121170:	1009883a 	mov	r4,r2
81121174:	11236500 	call	81123650 <fprintf>
		sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81121178:	e0bffd17 	ldw	r2,-12(fp)
8112117c:	10800058 	cmpnei	r2,r2,1
81121180:	1000031e 	bne	r2,zero,81121190 <_print_codec_status+0x104>
81121184:	00a04574 	movhi	r2,33045
81121188:	10898b04 	addi	r2,r2,9772
8112118c:	00000206 	br	81121198 <_print_codec_status+0x10c>
81121190:	00a04574 	movhi	r2,33045
81121194:	10898c04 	addi	r2,r2,9776
81121198:	100d883a 	mov	r6,r2
8112119c:	01604574 	movhi	r5,33045
811211a0:	29499304 	addi	r5,r5,9804
811211a4:	01204574 	movhi	r4,33045
811211a8:	21156904 	addi	r4,r4,21924
811211ac:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
811211b0:	d0a06217 	ldw	r2,-32376(gp)
811211b4:	01604574 	movhi	r5,33045
811211b8:	29556904 	addi	r5,r5,21924
811211bc:	1009883a 	mov	r4,r2
811211c0:	11236500 	call	81123650 <fprintf>
		sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
811211c4:	e0bffe17 	ldw	r2,-8(fp)
811211c8:	10800058 	cmpnei	r2,r2,1
811211cc:	1000031e 	bne	r2,zero,811211dc <_print_codec_status+0x150>
811211d0:	00a04574 	movhi	r2,33045
811211d4:	10898b04 	addi	r2,r2,9772
811211d8:	00000206 	br	811211e4 <_print_codec_status+0x158>
811211dc:	00a04574 	movhi	r2,33045
811211e0:	10898c04 	addi	r2,r2,9776
811211e4:	100d883a 	mov	r6,r2
811211e8:	01604574 	movhi	r5,33045
811211ec:	29499904 	addi	r5,r5,9828
811211f0:	01204574 	movhi	r4,33045
811211f4:	21156904 	addi	r4,r4,21924
811211f8:	1124f640 	call	81124f64 <sprintf>
		debug(fp, cDebugBuffer);
811211fc:	d0a06217 	ldw	r2,-32376(gp)
81121200:	01604574 	movhi	r5,33045
81121204:	29556904 	addi	r5,r5,21924
81121208:	1009883a 	mov	r4,r2
8112120c:	11236500 	call	81123650 <fprintf>
		sprintf(cDebugBuffer, "--------  \n");
81121210:	00a04574 	movhi	r2,33045
81121214:	10956904 	addi	r2,r2,21924
81121218:	00c00b44 	movi	r3,45
8112121c:	10c00005 	stb	r3,0(r2)
81121220:	00c00b44 	movi	r3,45
81121224:	10c00045 	stb	r3,1(r2)
81121228:	00c00b44 	movi	r3,45
8112122c:	10c00085 	stb	r3,2(r2)
81121230:	00c00b44 	movi	r3,45
81121234:	10c000c5 	stb	r3,3(r2)
81121238:	00c00b44 	movi	r3,45
8112123c:	10c00105 	stb	r3,4(r2)
81121240:	00c00b44 	movi	r3,45
81121244:	10c00145 	stb	r3,5(r2)
81121248:	00c00b44 	movi	r3,45
8112124c:	10c00185 	stb	r3,6(r2)
81121250:	00c00b44 	movi	r3,45
81121254:	10c001c5 	stb	r3,7(r2)
81121258:	00c00804 	movi	r3,32
8112125c:	10c00205 	stb	r3,8(r2)
81121260:	00c00804 	movi	r3,32
81121264:	10c00245 	stb	r3,9(r2)
81121268:	00c00284 	movi	r3,10
8112126c:	10c00285 	stb	r3,10(r2)
81121270:	100002c5 	stb	zero,11(r2)
		debug(fp, cDebugBuffer);
81121274:	d0a06217 	ldw	r2,-32376(gp)
81121278:	01604574 	movhi	r5,33045
8112127c:	29556904 	addi	r5,r5,21924
81121280:	1009883a 	mov	r4,r2
81121284:	11236500 	call	81123650 <fprintf>
	}
#endif
}
81121288:	0001883a 	nop
8112128c:	e037883a 	mov	sp,fp
81121290:	dfc00117 	ldw	ra,4(sp)
81121294:	df000017 	ldw	fp,0(sp)
81121298:	dec00204 	addi	sp,sp,8
8112129c:	f800283a 	ret

811212a0 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
811212a0:	defffb04 	addi	sp,sp,-20
811212a4:	de00012e 	bgeu	sp,et,811212ac <_split_codec_status+0xc>
811212a8:	003b68fa 	trap	3
811212ac:	df000415 	stw	fp,16(sp)
811212b0:	df000404 	addi	fp,sp,16
811212b4:	e13ffc15 	stw	r4,-16(fp)
811212b8:	e17ffd15 	stw	r5,-12(fp)
811212bc:	e1bffe15 	stw	r6,-8(fp)
811212c0:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
811212c4:	e0bffc17 	ldw	r2,-16(fp)
811212c8:	1005d1ba 	srai	r2,r2,6
811212cc:	10c0004c 	andi	r3,r2,1
811212d0:	e0bffd17 	ldw	r2,-12(fp)
811212d4:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
811212d8:	e0bffc17 	ldw	r2,-16(fp)
811212dc:	1005d17a 	srai	r2,r2,5
811212e0:	10c0004c 	andi	r3,r2,1
811212e4:	e0bffe17 	ldw	r2,-8(fp)
811212e8:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
811212ec:	e0bffc17 	ldw	r2,-16(fp)
811212f0:	1005d13a 	srai	r2,r2,4
811212f4:	10c0004c 	andi	r3,r2,1
811212f8:	e0bfff17 	ldw	r2,-4(fp)
811212fc:	10c00015 	stw	r3,0(r2)
}
81121300:	0001883a 	nop
81121304:	e037883a 	mov	sp,fp
81121308:	df000017 	ldw	fp,0(sp)
8112130c:	dec00104 	addi	sp,sp,4
81121310:	f800283a 	ret

81121314 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81121314:	defffc04 	addi	sp,sp,-16
81121318:	de00012e 	bgeu	sp,et,81121320 <aatoh+0xc>
8112131c:	003b68fa 	trap	3
81121320:	df000315 	stw	fp,12(sp)
81121324:	df000304 	addi	fp,sp,12
81121328:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8112132c:	e0bfff17 	ldw	r2,-4(fp)
81121330:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81121334:	e0bffd17 	ldw	r2,-12(fp)
81121338:	10c00003 	ldbu	r3,0(r2)
8112133c:	e0bffd17 	ldw	r2,-12(fp)
81121340:	10800003 	ldbu	r2,0(r2)
81121344:	10803fcc 	andi	r2,r2,255
81121348:	10800eb0 	cmpltui	r2,r2,58
8112134c:	1000021e 	bne	r2,zero,81121358 <aatoh+0x44>
81121350:	00800dc4 	movi	r2,55
81121354:	00000106 	br	8112135c <aatoh+0x48>
81121358:	00800c04 	movi	r2,48
8112135c:	1885c83a 	sub	r2,r3,r2
81121360:	1004913a 	slli	r2,r2,4
81121364:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81121368:	e0bffd17 	ldw	r2,-12(fp)
8112136c:	10800044 	addi	r2,r2,1
81121370:	10c00003 	ldbu	r3,0(r2)
81121374:	e0bffd17 	ldw	r2,-12(fp)
81121378:	10800044 	addi	r2,r2,1
8112137c:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81121380:	10803fcc 	andi	r2,r2,255
81121384:	10800eb0 	cmpltui	r2,r2,58
81121388:	1000021e 	bne	r2,zero,81121394 <aatoh+0x80>
8112138c:	00800dc4 	movi	r2,55
81121390:	00000106 	br	81121398 <aatoh+0x84>
81121394:	00800c04 	movi	r2,48
81121398:	1885c83a 	sub	r2,r3,r2
8112139c:	2085883a 	add	r2,r4,r2
811213a0:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
811213a4:	e0bffe03 	ldbu	r2,-8(fp)
}
811213a8:	e037883a 	mov	sp,fp
811213ac:	df000017 	ldw	fp,0(sp)
811213b0:	dec00104 	addi	sp,sp,4
811213b4:	f800283a 	ret

811213b8 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
811213b8:	defffd04 	addi	sp,sp,-12
811213bc:	de00012e 	bgeu	sp,et,811213c4 <Verif_Error+0xc>
811213c0:	003b68fa 	trap	3
811213c4:	dfc00215 	stw	ra,8(sp)
811213c8:	df000115 	stw	fp,4(sp)
811213cc:	df000104 	addi	fp,sp,4
811213d0:	2005883a 	mov	r2,r4
811213d4:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
811213d8:	e0bfff03 	ldbu	r2,-4(fp)
811213dc:	10000f1e 	bne	r2,zero,8112141c <Verif_Error+0x64>
#if DEBUG_ON
if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811213e0:	00a045f4 	movhi	r2,33047
811213e4:	10a34f04 	addi	r2,r2,-29380
811213e8:	10800a8b 	ldhu	r2,42(r2)
811213ec:	10bfffcc 	andi	r2,r2,65535
811213f0:	10800228 	cmpgeui	r2,r2,8
811213f4:	1000071e 	bne	r2,zero,81121414 <Verif_Error+0x5c>
	debug(fp, "ERROR\n\r");
811213f8:	d0a06217 	ldw	r2,-32376(gp)
811213fc:	100f883a 	mov	r7,r2
81121400:	018001c4 	movi	r6,7
81121404:	01400044 	movi	r5,1
81121408:	01204574 	movhi	r4,33045
8112140c:	21099f04 	addi	r4,r4,9852
81121410:	1123cec0 	call	81123cec <fwrite>
}
#endif
		return 0;
81121414:	0005883a 	mov	r2,zero
81121418:	00000106 	br	81121420 <Verif_Error+0x68>
	} else
		return 1;
8112141c:	00800044 	movi	r2,1
}
81121420:	e037883a 	mov	sp,fp
81121424:	dfc00117 	ldw	ra,4(sp)
81121428:	df000017 	ldw	fp,0(sp)
8112142c:	dec00204 	addi	sp,sp,8
81121430:	f800283a 	ret

81121434 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81121434:	defffe04 	addi	sp,sp,-8
81121438:	de00012e 	bgeu	sp,et,81121440 <toInt+0xc>
8112143c:	003b68fa 	trap	3
81121440:	df000115 	stw	fp,4(sp)
81121444:	df000104 	addi	fp,sp,4
81121448:	2005883a 	mov	r2,r4
8112144c:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
81121450:	e0bfff03 	ldbu	r2,-4(fp)
81121454:	10bff404 	addi	r2,r2,-48
}
81121458:	e037883a 	mov	sp,fp
8112145c:	df000017 	ldw	fp,0(sp)
81121460:	dec00104 	addi	sp,sp,4
81121464:	f800283a 	ret

81121468 <__fixunsdfsi>:
81121468:	defffd04 	addi	sp,sp,-12
8112146c:	000d883a 	mov	r6,zero
81121470:	01d07834 	movhi	r7,16864
81121474:	de00012e 	bgeu	sp,et,8112147c <__fixunsdfsi+0x14>
81121478:	003b68fa 	trap	3
8112147c:	dc400115 	stw	r17,4(sp)
81121480:	dc000015 	stw	r16,0(sp)
81121484:	dfc00215 	stw	ra,8(sp)
81121488:	2023883a 	mov	r17,r4
8112148c:	2821883a 	mov	r16,r5
81121490:	1121f540 	call	81121f54 <__gedf2>
81121494:	1000080e 	bge	r2,zero,811214b8 <__fixunsdfsi+0x50>
81121498:	8809883a 	mov	r4,r17
8112149c:	800b883a 	mov	r5,r16
811214a0:	11230540 	call	81123054 <__fixdfsi>
811214a4:	dfc00217 	ldw	ra,8(sp)
811214a8:	dc400117 	ldw	r17,4(sp)
811214ac:	dc000017 	ldw	r16,0(sp)
811214b0:	dec00304 	addi	sp,sp,12
811214b4:	f800283a 	ret
811214b8:	000d883a 	mov	r6,zero
811214bc:	01d07834 	movhi	r7,16864
811214c0:	8809883a 	mov	r4,r17
811214c4:	800b883a 	mov	r5,r16
811214c8:	11227500 	call	81122750 <__subdf3>
811214cc:	180b883a 	mov	r5,r3
811214d0:	1009883a 	mov	r4,r2
811214d4:	11230540 	call	81123054 <__fixdfsi>
811214d8:	00e00034 	movhi	r3,32768
811214dc:	10c5883a 	add	r2,r2,r3
811214e0:	003ff006 	br	811214a4 <__reset+0xfb1014a4>

811214e4 <__divsf3>:
811214e4:	defff504 	addi	sp,sp,-44
811214e8:	200cd5fa 	srli	r6,r4,23
811214ec:	de00012e 	bgeu	sp,et,811214f4 <__divsf3+0x10>
811214f0:	003b68fa 	trap	3
811214f4:	dcc00415 	stw	r19,16(sp)
811214f8:	2026d7fa 	srli	r19,r4,31
811214fc:	00c02034 	movhi	r3,128
81121500:	dd800715 	stw	r22,28(sp)
81121504:	dd000515 	stw	r20,20(sp)
81121508:	dc800315 	stw	r18,12(sp)
8112150c:	18ffffc4 	addi	r3,r3,-1
81121510:	dfc00a15 	stw	ra,40(sp)
81121514:	df000915 	stw	fp,36(sp)
81121518:	ddc00815 	stw	r23,32(sp)
8112151c:	dd400615 	stw	r21,24(sp)
81121520:	dc400215 	stw	r17,8(sp)
81121524:	dc000115 	stw	r16,4(sp)
81121528:	35003fcc 	andi	r20,r6,255
8112152c:	1924703a 	and	r18,r3,r4
81121530:	9d803fcc 	andi	r22,r19,255
81121534:	a0005226 	beq	r20,zero,81121680 <__divsf3+0x19c>
81121538:	00803fc4 	movi	r2,255
8112153c:	a0802e26 	beq	r20,r2,811215f8 <__divsf3+0x114>
81121540:	91002034 	orhi	r4,r18,128
81121544:	202490fa 	slli	r18,r4,3
81121548:	a53fe044 	addi	r20,r20,-127
8112154c:	0021883a 	mov	r16,zero
81121550:	002f883a 	mov	r23,zero
81121554:	280cd5fa 	srli	r6,r5,23
81121558:	282ad7fa 	srli	r21,r5,31
8112155c:	00c02034 	movhi	r3,128
81121560:	18ffffc4 	addi	r3,r3,-1
81121564:	31803fcc 	andi	r6,r6,255
81121568:	1962703a 	and	r17,r3,r5
8112156c:	af003fcc 	andi	fp,r21,255
81121570:	30004a26 	beq	r6,zero,8112169c <__divsf3+0x1b8>
81121574:	00803fc4 	movi	r2,255
81121578:	30804526 	beq	r6,r2,81121690 <__divsf3+0x1ac>
8112157c:	89402034 	orhi	r5,r17,128
81121580:	282290fa 	slli	r17,r5,3
81121584:	31bfe044 	addi	r6,r6,-127
81121588:	000b883a 	mov	r5,zero
8112158c:	2c20b03a 	or	r16,r5,r16
81121590:	802090ba 	slli	r16,r16,2
81121594:	00a044b4 	movhi	r2,33042
81121598:	10856e04 	addi	r2,r2,5560
8112159c:	80a1883a 	add	r16,r16,r2
811215a0:	81000017 	ldw	r4,0(r16)
811215a4:	9d46f03a 	xor	r3,r19,r21
811215a8:	180f883a 	mov	r7,r3
811215ac:	18803fcc 	andi	r2,r3,255
811215b0:	a18dc83a 	sub	r6,r20,r6
811215b4:	2000683a 	jmp	r4
811215b8:	8112179c 	xori	r4,r16,18526
811215bc:	81121620 	cmpeqi	r4,r16,18520
811215c0:	81121790 	cmplti	r4,r16,18526
811215c4:	8112160c 	andi	r4,r16,18520
811215c8:	81121790 	cmplti	r4,r16,18526
811215cc:	81121768 	cmpgeui	r4,r16,18525
811215d0:	81121790 	cmplti	r4,r16,18526
811215d4:	8112160c 	andi	r4,r16,18520
811215d8:	81121620 	cmpeqi	r4,r16,18520
811215dc:	81121620 	cmpeqi	r4,r16,18520
811215e0:	81121768 	cmpgeui	r4,r16,18525
811215e4:	8112160c 	andi	r4,r16,18520
811215e8:	8112187c 	xorhi	r4,r16,18529
811215ec:	8112187c 	xorhi	r4,r16,18529
811215f0:	8112187c 	xorhi	r4,r16,18529
811215f4:	81121830 	cmpltui	r4,r16,18528
811215f8:	9000581e 	bne	r18,zero,8112175c <__divsf3+0x278>
811215fc:	04000204 	movi	r16,8
81121600:	05c00084 	movi	r23,2
81121604:	003fd306 	br	81121554 <__reset+0xfb101554>
81121608:	0023883a 	mov	r17,zero
8112160c:	e02d883a 	mov	r22,fp
81121610:	282f883a 	mov	r23,r5
81121614:	00800084 	movi	r2,2
81121618:	b8808f1e 	bne	r23,r2,81121858 <__divsf3+0x374>
8112161c:	b005883a 	mov	r2,r22
81121620:	11c0004c 	andi	r7,r2,1
81121624:	013fffc4 	movi	r4,-1
81121628:	000d883a 	mov	r6,zero
8112162c:	21003fcc 	andi	r4,r4,255
81121630:	200895fa 	slli	r4,r4,23
81121634:	38803fcc 	andi	r2,r7,255
81121638:	00c02034 	movhi	r3,128
8112163c:	100497fa 	slli	r2,r2,31
81121640:	18ffffc4 	addi	r3,r3,-1
81121644:	30c6703a 	and	r3,r6,r3
81121648:	1906b03a 	or	r3,r3,r4
8112164c:	1884b03a 	or	r2,r3,r2
81121650:	dfc00a17 	ldw	ra,40(sp)
81121654:	df000917 	ldw	fp,36(sp)
81121658:	ddc00817 	ldw	r23,32(sp)
8112165c:	dd800717 	ldw	r22,28(sp)
81121660:	dd400617 	ldw	r21,24(sp)
81121664:	dd000517 	ldw	r20,20(sp)
81121668:	dcc00417 	ldw	r19,16(sp)
8112166c:	dc800317 	ldw	r18,12(sp)
81121670:	dc400217 	ldw	r17,8(sp)
81121674:	dc000117 	ldw	r16,4(sp)
81121678:	dec00b04 	addi	sp,sp,44
8112167c:	f800283a 	ret
81121680:	90002b1e 	bne	r18,zero,81121730 <__divsf3+0x24c>
81121684:	04000104 	movi	r16,4
81121688:	05c00044 	movi	r23,1
8112168c:	003fb106 	br	81121554 <__reset+0xfb101554>
81121690:	8800251e 	bne	r17,zero,81121728 <__divsf3+0x244>
81121694:	01400084 	movi	r5,2
81121698:	00000206 	br	811216a4 <__divsf3+0x1c0>
8112169c:	88001a1e 	bne	r17,zero,81121708 <__divsf3+0x224>
811216a0:	01400044 	movi	r5,1
811216a4:	8160b03a 	or	r16,r16,r5
811216a8:	802090ba 	slli	r16,r16,2
811216ac:	00e044b4 	movhi	r3,33042
811216b0:	18c5b204 	addi	r3,r3,5832
811216b4:	80e1883a 	add	r16,r16,r3
811216b8:	80c00017 	ldw	r3,0(r16)
811216bc:	9d44f03a 	xor	r2,r19,r21
811216c0:	a18dc83a 	sub	r6,r20,r6
811216c4:	1800683a 	jmp	r3
811216c8:	81121620 	cmpeqi	r4,r16,18520
811216cc:	81121620 	cmpeqi	r4,r16,18520
811216d0:	8112186c 	andhi	r4,r16,18529
811216d4:	81121608 	cmpgei	r4,r16,18520
811216d8:	8112186c 	andhi	r4,r16,18529
811216dc:	81121768 	cmpgeui	r4,r16,18525
811216e0:	8112186c 	andhi	r4,r16,18529
811216e4:	81121608 	cmpgei	r4,r16,18520
811216e8:	81121620 	cmpeqi	r4,r16,18520
811216ec:	81121620 	cmpeqi	r4,r16,18520
811216f0:	81121768 	cmpgeui	r4,r16,18525
811216f4:	81121608 	cmpgei	r4,r16,18520
811216f8:	8112187c 	xorhi	r4,r16,18529
811216fc:	8112187c 	xorhi	r4,r16,18529
81121700:	8112187c 	xorhi	r4,r16,18529
81121704:	81121894 	ori	r4,r16,18530
81121708:	8809883a 	mov	r4,r17
8112170c:	11234780 	call	81123478 <__clzsi2>
81121710:	10fffec4 	addi	r3,r2,-5
81121714:	10801d84 	addi	r2,r2,118
81121718:	88e2983a 	sll	r17,r17,r3
8112171c:	008dc83a 	sub	r6,zero,r2
81121720:	000b883a 	mov	r5,zero
81121724:	003f9906 	br	8112158c <__reset+0xfb10158c>
81121728:	014000c4 	movi	r5,3
8112172c:	003f9706 	br	8112158c <__reset+0xfb10158c>
81121730:	9009883a 	mov	r4,r18
81121734:	d9400015 	stw	r5,0(sp)
81121738:	11234780 	call	81123478 <__clzsi2>
8112173c:	10fffec4 	addi	r3,r2,-5
81121740:	11801d84 	addi	r6,r2,118
81121744:	90e4983a 	sll	r18,r18,r3
81121748:	01a9c83a 	sub	r20,zero,r6
8112174c:	0021883a 	mov	r16,zero
81121750:	002f883a 	mov	r23,zero
81121754:	d9400017 	ldw	r5,0(sp)
81121758:	003f7e06 	br	81121554 <__reset+0xfb101554>
8112175c:	04000304 	movi	r16,12
81121760:	05c000c4 	movi	r23,3
81121764:	003f7b06 	br	81121554 <__reset+0xfb101554>
81121768:	01802034 	movhi	r6,128
8112176c:	000f883a 	mov	r7,zero
81121770:	31bfffc4 	addi	r6,r6,-1
81121774:	013fffc4 	movi	r4,-1
81121778:	003fac06 	br	8112162c <__reset+0xfb10162c>
8112177c:	01400044 	movi	r5,1
81121780:	2909c83a 	sub	r4,r5,r4
81121784:	00c006c4 	movi	r3,27
81121788:	19004b0e 	bge	r3,r4,811218b8 <__divsf3+0x3d4>
8112178c:	114e703a 	and	r7,r2,r5
81121790:	0009883a 	mov	r4,zero
81121794:	000d883a 	mov	r6,zero
81121798:	003fa406 	br	8112162c <__reset+0xfb10162c>
8112179c:	9006917a 	slli	r3,r18,5
811217a0:	8822917a 	slli	r17,r17,5
811217a4:	1c40372e 	bgeu	r3,r17,81121884 <__divsf3+0x3a0>
811217a8:	31bfffc4 	addi	r6,r6,-1
811217ac:	010006c4 	movi	r4,27
811217b0:	000b883a 	mov	r5,zero
811217b4:	180f883a 	mov	r7,r3
811217b8:	294b883a 	add	r5,r5,r5
811217bc:	18c7883a 	add	r3,r3,r3
811217c0:	38000116 	blt	r7,zero,811217c8 <__divsf3+0x2e4>
811217c4:	1c400236 	bltu	r3,r17,811217d0 <__divsf3+0x2ec>
811217c8:	1c47c83a 	sub	r3,r3,r17
811217cc:	29400054 	ori	r5,r5,1
811217d0:	213fffc4 	addi	r4,r4,-1
811217d4:	203ff71e 	bne	r4,zero,811217b4 <__reset+0xfb1017b4>
811217d8:	1806c03a 	cmpne	r3,r3,zero
811217dc:	1962b03a 	or	r17,r3,r5
811217e0:	31001fc4 	addi	r4,r6,127
811217e4:	013fe50e 	bge	zero,r4,8112177c <__reset+0xfb10177c>
811217e8:	88c001cc 	andi	r3,r17,7
811217ec:	18000426 	beq	r3,zero,81121800 <__divsf3+0x31c>
811217f0:	88c003cc 	andi	r3,r17,15
811217f4:	01400104 	movi	r5,4
811217f8:	19400126 	beq	r3,r5,81121800 <__divsf3+0x31c>
811217fc:	8963883a 	add	r17,r17,r5
81121800:	88c2002c 	andhi	r3,r17,2048
81121804:	18000426 	beq	r3,zero,81121818 <__divsf3+0x334>
81121808:	00fe0034 	movhi	r3,63488
8112180c:	18ffffc4 	addi	r3,r3,-1
81121810:	31002004 	addi	r4,r6,128
81121814:	88e2703a 	and	r17,r17,r3
81121818:	00c03f84 	movi	r3,254
8112181c:	193f8016 	blt	r3,r4,81121620 <__reset+0xfb101620>
81121820:	880c91ba 	slli	r6,r17,6
81121824:	11c0004c 	andi	r7,r2,1
81121828:	300cd27a 	srli	r6,r6,9
8112182c:	003f7f06 	br	8112162c <__reset+0xfb10162c>
81121830:	9080102c 	andhi	r2,r18,64
81121834:	10000226 	beq	r2,zero,81121840 <__divsf3+0x35c>
81121838:	8880102c 	andhi	r2,r17,64
8112183c:	10001826 	beq	r2,zero,811218a0 <__divsf3+0x3bc>
81121840:	00802034 	movhi	r2,128
81121844:	91801034 	orhi	r6,r18,64
81121848:	10bfffc4 	addi	r2,r2,-1
8112184c:	980f883a 	mov	r7,r19
81121850:	308c703a 	and	r6,r6,r2
81121854:	003fc706 	br	81121774 <__reset+0xfb101774>
81121858:	008000c4 	movi	r2,3
8112185c:	b8802d26 	beq	r23,r2,81121914 <__divsf3+0x430>
81121860:	00c00044 	movi	r3,1
81121864:	b005883a 	mov	r2,r22
81121868:	b8ffdd1e 	bne	r23,r3,811217e0 <__reset+0xfb1017e0>
8112186c:	11c0004c 	andi	r7,r2,1
81121870:	0009883a 	mov	r4,zero
81121874:	000d883a 	mov	r6,zero
81121878:	003f6c06 	br	8112162c <__reset+0xfb10162c>
8112187c:	9023883a 	mov	r17,r18
81121880:	003f6406 	br	81121614 <__reset+0xfb101614>
81121884:	1c47c83a 	sub	r3,r3,r17
81121888:	01000684 	movi	r4,26
8112188c:	01400044 	movi	r5,1
81121890:	003fc806 	br	811217b4 <__reset+0xfb1017b4>
81121894:	9080102c 	andhi	r2,r18,64
81121898:	103fe926 	beq	r2,zero,81121840 <__reset+0xfb101840>
8112189c:	0023883a 	mov	r17,zero
811218a0:	00802034 	movhi	r2,128
811218a4:	89801034 	orhi	r6,r17,64
811218a8:	10bfffc4 	addi	r2,r2,-1
811218ac:	a80f883a 	mov	r7,r21
811218b0:	308c703a 	and	r6,r6,r2
811218b4:	003faf06 	br	81121774 <__reset+0xfb101774>
811218b8:	01c00804 	movi	r7,32
811218bc:	390fc83a 	sub	r7,r7,r4
811218c0:	89ce983a 	sll	r7,r17,r7
811218c4:	890ad83a 	srl	r5,r17,r4
811218c8:	380ec03a 	cmpne	r7,r7,zero
811218cc:	29cab03a 	or	r5,r5,r7
811218d0:	28c001cc 	andi	r3,r5,7
811218d4:	18000426 	beq	r3,zero,811218e8 <__divsf3+0x404>
811218d8:	28c003cc 	andi	r3,r5,15
811218dc:	01000104 	movi	r4,4
811218e0:	19000126 	beq	r3,r4,811218e8 <__divsf3+0x404>
811218e4:	290b883a 	add	r5,r5,r4
811218e8:	28c1002c 	andhi	r3,r5,1024
811218ec:	18000426 	beq	r3,zero,81121900 <__divsf3+0x41c>
811218f0:	11c0004c 	andi	r7,r2,1
811218f4:	01000044 	movi	r4,1
811218f8:	000d883a 	mov	r6,zero
811218fc:	003f4b06 	br	8112162c <__reset+0xfb10162c>
81121900:	280a91ba 	slli	r5,r5,6
81121904:	11c0004c 	andi	r7,r2,1
81121908:	0009883a 	mov	r4,zero
8112190c:	280cd27a 	srli	r6,r5,9
81121910:	003f4606 	br	8112162c <__reset+0xfb10162c>
81121914:	00802034 	movhi	r2,128
81121918:	89801034 	orhi	r6,r17,64
8112191c:	10bfffc4 	addi	r2,r2,-1
81121920:	b00f883a 	mov	r7,r22
81121924:	308c703a 	and	r6,r6,r2
81121928:	003f9206 	br	81121774 <__reset+0xfb101774>

8112192c <__mulsf3>:
8112192c:	defff504 	addi	sp,sp,-44
81121930:	de00012e 	bgeu	sp,et,81121938 <__mulsf3+0xc>
81121934:	003b68fa 	trap	3
81121938:	dc000115 	stw	r16,4(sp)
8112193c:	2020d5fa 	srli	r16,r4,23
81121940:	dd400615 	stw	r21,24(sp)
81121944:	202ad7fa 	srli	r21,r4,31
81121948:	dc800315 	stw	r18,12(sp)
8112194c:	04802034 	movhi	r18,128
81121950:	df000915 	stw	fp,36(sp)
81121954:	dd000515 	stw	r20,20(sp)
81121958:	94bfffc4 	addi	r18,r18,-1
8112195c:	dfc00a15 	stw	ra,40(sp)
81121960:	ddc00815 	stw	r23,32(sp)
81121964:	dd800715 	stw	r22,28(sp)
81121968:	dcc00415 	stw	r19,16(sp)
8112196c:	dc400215 	stw	r17,8(sp)
81121970:	84003fcc 	andi	r16,r16,255
81121974:	9124703a 	and	r18,r18,r4
81121978:	a829883a 	mov	r20,r21
8112197c:	af003fcc 	andi	fp,r21,255
81121980:	80005426 	beq	r16,zero,81121ad4 <__mulsf3+0x1a8>
81121984:	00803fc4 	movi	r2,255
81121988:	80802f26 	beq	r16,r2,81121a48 <__mulsf3+0x11c>
8112198c:	91002034 	orhi	r4,r18,128
81121990:	202490fa 	slli	r18,r4,3
81121994:	843fe044 	addi	r16,r16,-127
81121998:	0023883a 	mov	r17,zero
8112199c:	002f883a 	mov	r23,zero
811219a0:	2804d5fa 	srli	r2,r5,23
811219a4:	282cd7fa 	srli	r22,r5,31
811219a8:	01002034 	movhi	r4,128
811219ac:	213fffc4 	addi	r4,r4,-1
811219b0:	10803fcc 	andi	r2,r2,255
811219b4:	2166703a 	and	r19,r4,r5
811219b8:	b1803fcc 	andi	r6,r22,255
811219bc:	10004c26 	beq	r2,zero,81121af0 <__mulsf3+0x1c4>
811219c0:	00c03fc4 	movi	r3,255
811219c4:	10c04726 	beq	r2,r3,81121ae4 <__mulsf3+0x1b8>
811219c8:	99002034 	orhi	r4,r19,128
811219cc:	202690fa 	slli	r19,r4,3
811219d0:	10bfe044 	addi	r2,r2,-127
811219d4:	0007883a 	mov	r3,zero
811219d8:	80a1883a 	add	r16,r16,r2
811219dc:	010003c4 	movi	r4,15
811219e0:	1c44b03a 	or	r2,r3,r17
811219e4:	b56af03a 	xor	r21,r22,r21
811219e8:	81c00044 	addi	r7,r16,1
811219ec:	20806b36 	bltu	r4,r2,81121b9c <__mulsf3+0x270>
811219f0:	100490ba 	slli	r2,r2,2
811219f4:	012044b4 	movhi	r4,33042
811219f8:	21068204 	addi	r4,r4,6664
811219fc:	1105883a 	add	r2,r2,r4
81121a00:	10800017 	ldw	r2,0(r2)
81121a04:	1000683a 	jmp	r2
81121a08:	81121b9c 	xori	r4,r16,18542
81121a0c:	81121a5c 	xori	r4,r16,18537
81121a10:	81121a5c 	xori	r4,r16,18537
81121a14:	81121a58 	cmpnei	r4,r16,18537
81121a18:	81121b80 	call	881121b8 <__reset+0x20f21b8>
81121a1c:	81121b80 	call	881121b8 <__reset+0x20f21b8>
81121a20:	81121b6c 	andhi	r4,r16,18541
81121a24:	81121a58 	cmpnei	r4,r16,18537
81121a28:	81121b80 	call	881121b8 <__reset+0x20f21b8>
81121a2c:	81121b6c 	andhi	r4,r16,18541
81121a30:	81121b80 	call	881121b8 <__reset+0x20f21b8>
81121a34:	81121a58 	cmpnei	r4,r16,18537
81121a38:	81121b8c 	andi	r4,r16,18542
81121a3c:	81121b8c 	andi	r4,r16,18542
81121a40:	81121b8c 	andi	r4,r16,18542
81121a44:	81121c68 	cmpgeui	r4,r16,18545
81121a48:	90003b1e 	bne	r18,zero,81121b38 <__mulsf3+0x20c>
81121a4c:	04400204 	movi	r17,8
81121a50:	05c00084 	movi	r23,2
81121a54:	003fd206 	br	811219a0 <__reset+0xfb1019a0>
81121a58:	302b883a 	mov	r21,r6
81121a5c:	00800084 	movi	r2,2
81121a60:	18802626 	beq	r3,r2,81121afc <__mulsf3+0x1d0>
81121a64:	008000c4 	movi	r2,3
81121a68:	1880ab26 	beq	r3,r2,81121d18 <__mulsf3+0x3ec>
81121a6c:	00800044 	movi	r2,1
81121a70:	1880a21e 	bne	r3,r2,81121cfc <__mulsf3+0x3d0>
81121a74:	a829883a 	mov	r20,r21
81121a78:	0007883a 	mov	r3,zero
81121a7c:	0009883a 	mov	r4,zero
81121a80:	18803fcc 	andi	r2,r3,255
81121a84:	100695fa 	slli	r3,r2,23
81121a88:	a0803fcc 	andi	r2,r20,255
81121a8c:	100a97fa 	slli	r5,r2,31
81121a90:	00802034 	movhi	r2,128
81121a94:	10bfffc4 	addi	r2,r2,-1
81121a98:	2084703a 	and	r2,r4,r2
81121a9c:	10c4b03a 	or	r2,r2,r3
81121aa0:	1144b03a 	or	r2,r2,r5
81121aa4:	dfc00a17 	ldw	ra,40(sp)
81121aa8:	df000917 	ldw	fp,36(sp)
81121aac:	ddc00817 	ldw	r23,32(sp)
81121ab0:	dd800717 	ldw	r22,28(sp)
81121ab4:	dd400617 	ldw	r21,24(sp)
81121ab8:	dd000517 	ldw	r20,20(sp)
81121abc:	dcc00417 	ldw	r19,16(sp)
81121ac0:	dc800317 	ldw	r18,12(sp)
81121ac4:	dc400217 	ldw	r17,8(sp)
81121ac8:	dc000117 	ldw	r16,4(sp)
81121acc:	dec00b04 	addi	sp,sp,44
81121ad0:	f800283a 	ret
81121ad4:	90000d1e 	bne	r18,zero,81121b0c <__mulsf3+0x1e0>
81121ad8:	04400104 	movi	r17,4
81121adc:	05c00044 	movi	r23,1
81121ae0:	003faf06 	br	811219a0 <__reset+0xfb1019a0>
81121ae4:	9806c03a 	cmpne	r3,r19,zero
81121ae8:	18c00084 	addi	r3,r3,2
81121aec:	003fba06 	br	811219d8 <__reset+0xfb1019d8>
81121af0:	9800141e 	bne	r19,zero,81121b44 <__mulsf3+0x218>
81121af4:	00c00044 	movi	r3,1
81121af8:	003fb706 	br	811219d8 <__reset+0xfb1019d8>
81121afc:	a829883a 	mov	r20,r21
81121b00:	00ffffc4 	movi	r3,-1
81121b04:	0009883a 	mov	r4,zero
81121b08:	003fdd06 	br	81121a80 <__reset+0xfb101a80>
81121b0c:	9009883a 	mov	r4,r18
81121b10:	d9400015 	stw	r5,0(sp)
81121b14:	11234780 	call	81123478 <__clzsi2>
81121b18:	10fffec4 	addi	r3,r2,-5
81121b1c:	10801d84 	addi	r2,r2,118
81121b20:	90e4983a 	sll	r18,r18,r3
81121b24:	00a1c83a 	sub	r16,zero,r2
81121b28:	0023883a 	mov	r17,zero
81121b2c:	002f883a 	mov	r23,zero
81121b30:	d9400017 	ldw	r5,0(sp)
81121b34:	003f9a06 	br	811219a0 <__reset+0xfb1019a0>
81121b38:	04400304 	movi	r17,12
81121b3c:	05c000c4 	movi	r23,3
81121b40:	003f9706 	br	811219a0 <__reset+0xfb1019a0>
81121b44:	9809883a 	mov	r4,r19
81121b48:	d9800015 	stw	r6,0(sp)
81121b4c:	11234780 	call	81123478 <__clzsi2>
81121b50:	10fffec4 	addi	r3,r2,-5
81121b54:	10801d84 	addi	r2,r2,118
81121b58:	98e6983a 	sll	r19,r19,r3
81121b5c:	0085c83a 	sub	r2,zero,r2
81121b60:	0007883a 	mov	r3,zero
81121b64:	d9800017 	ldw	r6,0(sp)
81121b68:	003f9b06 	br	811219d8 <__reset+0xfb1019d8>
81121b6c:	01002034 	movhi	r4,128
81121b70:	0029883a 	mov	r20,zero
81121b74:	213fffc4 	addi	r4,r4,-1
81121b78:	00ffffc4 	movi	r3,-1
81121b7c:	003fc006 	br	81121a80 <__reset+0xfb101a80>
81121b80:	9027883a 	mov	r19,r18
81121b84:	b807883a 	mov	r3,r23
81121b88:	003fb406 	br	81121a5c <__reset+0xfb101a5c>
81121b8c:	9027883a 	mov	r19,r18
81121b90:	e02b883a 	mov	r21,fp
81121b94:	b807883a 	mov	r3,r23
81121b98:	003fb006 	br	81121a5c <__reset+0xfb101a5c>
81121b9c:	9004d43a 	srli	r2,r18,16
81121ba0:	9810d43a 	srli	r8,r19,16
81121ba4:	94bfffcc 	andi	r18,r18,65535
81121ba8:	993fffcc 	andi	r4,r19,65535
81121bac:	910d383a 	mul	r6,r18,r4
81121bb0:	20a7383a 	mul	r19,r4,r2
81121bb4:	9225383a 	mul	r18,r18,r8
81121bb8:	3006d43a 	srli	r3,r6,16
81121bbc:	1211383a 	mul	r8,r2,r8
81121bc0:	94e5883a 	add	r18,r18,r19
81121bc4:	1c87883a 	add	r3,r3,r18
81121bc8:	1cc0022e 	bgeu	r3,r19,81121bd4 <__mulsf3+0x2a8>
81121bcc:	00800074 	movhi	r2,1
81121bd0:	4091883a 	add	r8,r8,r2
81121bd4:	1804943a 	slli	r2,r3,16
81121bd8:	31bfffcc 	andi	r6,r6,65535
81121bdc:	1806d43a 	srli	r3,r3,16
81121be0:	1185883a 	add	r2,r2,r6
81121be4:	102691ba 	slli	r19,r2,6
81121be8:	1a07883a 	add	r3,r3,r8
81121bec:	1004d6ba 	srli	r2,r2,26
81121bf0:	180891ba 	slli	r4,r3,6
81121bf4:	9826c03a 	cmpne	r19,r19,zero
81121bf8:	9884b03a 	or	r2,r19,r2
81121bfc:	1126b03a 	or	r19,r2,r4
81121c00:	9882002c 	andhi	r2,r19,2048
81121c04:	10000426 	beq	r2,zero,81121c18 <__mulsf3+0x2ec>
81121c08:	9804d07a 	srli	r2,r19,1
81121c0c:	9900004c 	andi	r4,r19,1
81121c10:	3821883a 	mov	r16,r7
81121c14:	1126b03a 	or	r19,r2,r4
81121c18:	80c01fc4 	addi	r3,r16,127
81121c1c:	00c0210e 	bge	zero,r3,81121ca4 <__mulsf3+0x378>
81121c20:	988001cc 	andi	r2,r19,7
81121c24:	10000426 	beq	r2,zero,81121c38 <__mulsf3+0x30c>
81121c28:	988003cc 	andi	r2,r19,15
81121c2c:	01000104 	movi	r4,4
81121c30:	11000126 	beq	r2,r4,81121c38 <__mulsf3+0x30c>
81121c34:	9927883a 	add	r19,r19,r4
81121c38:	9882002c 	andhi	r2,r19,2048
81121c3c:	10000426 	beq	r2,zero,81121c50 <__mulsf3+0x324>
81121c40:	00be0034 	movhi	r2,63488
81121c44:	10bfffc4 	addi	r2,r2,-1
81121c48:	80c02004 	addi	r3,r16,128
81121c4c:	98a6703a 	and	r19,r19,r2
81121c50:	00803f84 	movi	r2,254
81121c54:	10ffa916 	blt	r2,r3,81121afc <__reset+0xfb101afc>
81121c58:	980891ba 	slli	r4,r19,6
81121c5c:	a829883a 	mov	r20,r21
81121c60:	2008d27a 	srli	r4,r4,9
81121c64:	003f8606 	br	81121a80 <__reset+0xfb101a80>
81121c68:	9080102c 	andhi	r2,r18,64
81121c6c:	10000826 	beq	r2,zero,81121c90 <__mulsf3+0x364>
81121c70:	9880102c 	andhi	r2,r19,64
81121c74:	1000061e 	bne	r2,zero,81121c90 <__mulsf3+0x364>
81121c78:	00802034 	movhi	r2,128
81121c7c:	99001034 	orhi	r4,r19,64
81121c80:	10bfffc4 	addi	r2,r2,-1
81121c84:	b029883a 	mov	r20,r22
81121c88:	2088703a 	and	r4,r4,r2
81121c8c:	003fba06 	br	81121b78 <__reset+0xfb101b78>
81121c90:	00802034 	movhi	r2,128
81121c94:	91001034 	orhi	r4,r18,64
81121c98:	10bfffc4 	addi	r2,r2,-1
81121c9c:	2088703a 	and	r4,r4,r2
81121ca0:	003fb506 	br	81121b78 <__reset+0xfb101b78>
81121ca4:	00800044 	movi	r2,1
81121ca8:	10c7c83a 	sub	r3,r2,r3
81121cac:	008006c4 	movi	r2,27
81121cb0:	10ff7016 	blt	r2,r3,81121a74 <__reset+0xfb101a74>
81121cb4:	00800804 	movi	r2,32
81121cb8:	10c5c83a 	sub	r2,r2,r3
81121cbc:	9884983a 	sll	r2,r19,r2
81121cc0:	98c6d83a 	srl	r3,r19,r3
81121cc4:	1004c03a 	cmpne	r2,r2,zero
81121cc8:	1884b03a 	or	r2,r3,r2
81121ccc:	10c001cc 	andi	r3,r2,7
81121cd0:	18000426 	beq	r3,zero,81121ce4 <__mulsf3+0x3b8>
81121cd4:	10c003cc 	andi	r3,r2,15
81121cd8:	01000104 	movi	r4,4
81121cdc:	19000126 	beq	r3,r4,81121ce4 <__mulsf3+0x3b8>
81121ce0:	1105883a 	add	r2,r2,r4
81121ce4:	10c1002c 	andhi	r3,r2,1024
81121ce8:	18000626 	beq	r3,zero,81121d04 <__mulsf3+0x3d8>
81121cec:	a829883a 	mov	r20,r21
81121cf0:	00c00044 	movi	r3,1
81121cf4:	0009883a 	mov	r4,zero
81121cf8:	003f6106 	br	81121a80 <__reset+0xfb101a80>
81121cfc:	3821883a 	mov	r16,r7
81121d00:	003fc506 	br	81121c18 <__reset+0xfb101c18>
81121d04:	100491ba 	slli	r2,r2,6
81121d08:	a829883a 	mov	r20,r21
81121d0c:	0007883a 	mov	r3,zero
81121d10:	1008d27a 	srli	r4,r2,9
81121d14:	003f5a06 	br	81121a80 <__reset+0xfb101a80>
81121d18:	00802034 	movhi	r2,128
81121d1c:	99001034 	orhi	r4,r19,64
81121d20:	10bfffc4 	addi	r2,r2,-1
81121d24:	a829883a 	mov	r20,r21
81121d28:	2088703a 	and	r4,r4,r2
81121d2c:	003f9206 	br	81121b78 <__reset+0xfb101b78>

81121d30 <__floatsisf>:
81121d30:	defffd04 	addi	sp,sp,-12
81121d34:	de00012e 	bgeu	sp,et,81121d3c <__floatsisf+0xc>
81121d38:	003b68fa 	trap	3
81121d3c:	dfc00215 	stw	ra,8(sp)
81121d40:	dc400115 	stw	r17,4(sp)
81121d44:	dc000015 	stw	r16,0(sp)
81121d48:	20003526 	beq	r4,zero,81121e20 <__floatsisf+0xf0>
81121d4c:	2021883a 	mov	r16,r4
81121d50:	2022d7fa 	srli	r17,r4,31
81121d54:	20003616 	blt	r4,zero,81121e30 <__floatsisf+0x100>
81121d58:	8009883a 	mov	r4,r16
81121d5c:	11234780 	call	81123478 <__clzsi2>
81121d60:	00c02784 	movi	r3,158
81121d64:	1887c83a 	sub	r3,r3,r2
81121d68:	01002584 	movi	r4,150
81121d6c:	20c01416 	blt	r4,r3,81121dc0 <__floatsisf+0x90>
81121d70:	20c9c83a 	sub	r4,r4,r3
81121d74:	8120983a 	sll	r16,r16,r4
81121d78:	00802034 	movhi	r2,128
81121d7c:	10bfffc4 	addi	r2,r2,-1
81121d80:	8809883a 	mov	r4,r17
81121d84:	80a0703a 	and	r16,r16,r2
81121d88:	18803fcc 	andi	r2,r3,255
81121d8c:	100695fa 	slli	r3,r2,23
81121d90:	20803fcc 	andi	r2,r4,255
81121d94:	100897fa 	slli	r4,r2,31
81121d98:	00802034 	movhi	r2,128
81121d9c:	10bfffc4 	addi	r2,r2,-1
81121da0:	8084703a 	and	r2,r16,r2
81121da4:	10c4b03a 	or	r2,r2,r3
81121da8:	1104b03a 	or	r2,r2,r4
81121dac:	dfc00217 	ldw	ra,8(sp)
81121db0:	dc400117 	ldw	r17,4(sp)
81121db4:	dc000017 	ldw	r16,0(sp)
81121db8:	dec00304 	addi	sp,sp,12
81121dbc:	f800283a 	ret
81121dc0:	01002644 	movi	r4,153
81121dc4:	20c01c16 	blt	r4,r3,81121e38 <__floatsisf+0x108>
81121dc8:	20c9c83a 	sub	r4,r4,r3
81121dcc:	8120983a 	sll	r16,r16,r4
81121dd0:	013f0034 	movhi	r4,64512
81121dd4:	213fffc4 	addi	r4,r4,-1
81121dd8:	814001cc 	andi	r5,r16,7
81121ddc:	8108703a 	and	r4,r16,r4
81121de0:	28000426 	beq	r5,zero,81121df4 <__floatsisf+0xc4>
81121de4:	840003cc 	andi	r16,r16,15
81121de8:	01400104 	movi	r5,4
81121dec:	81400126 	beq	r16,r5,81121df4 <__floatsisf+0xc4>
81121df0:	2149883a 	add	r4,r4,r5
81121df4:	2141002c 	andhi	r5,r4,1024
81121df8:	28000526 	beq	r5,zero,81121e10 <__floatsisf+0xe0>
81121dfc:	00c027c4 	movi	r3,159
81121e00:	1887c83a 	sub	r3,r3,r2
81121e04:	00bf0034 	movhi	r2,64512
81121e08:	10bfffc4 	addi	r2,r2,-1
81121e0c:	2088703a 	and	r4,r4,r2
81121e10:	202091ba 	slli	r16,r4,6
81121e14:	8809883a 	mov	r4,r17
81121e18:	8020d27a 	srli	r16,r16,9
81121e1c:	003fda06 	br	81121d88 <__reset+0xfb101d88>
81121e20:	0009883a 	mov	r4,zero
81121e24:	0007883a 	mov	r3,zero
81121e28:	0021883a 	mov	r16,zero
81121e2c:	003fd606 	br	81121d88 <__reset+0xfb101d88>
81121e30:	0121c83a 	sub	r16,zero,r4
81121e34:	003fc806 	br	81121d58 <__reset+0xfb101d58>
81121e38:	01002e44 	movi	r4,185
81121e3c:	20c9c83a 	sub	r4,r4,r3
81121e40:	01400144 	movi	r5,5
81121e44:	8108983a 	sll	r4,r16,r4
81121e48:	288bc83a 	sub	r5,r5,r2
81121e4c:	8160d83a 	srl	r16,r16,r5
81121e50:	2008c03a 	cmpne	r4,r4,zero
81121e54:	8120b03a 	or	r16,r16,r4
81121e58:	003fdd06 	br	81121dd0 <__reset+0xfb101dd0>

81121e5c <__floatunsisf>:
81121e5c:	defffe04 	addi	sp,sp,-8
81121e60:	de00012e 	bgeu	sp,et,81121e68 <__floatunsisf+0xc>
81121e64:	003b68fa 	trap	3
81121e68:	dfc00115 	stw	ra,4(sp)
81121e6c:	dc000015 	stw	r16,0(sp)
81121e70:	20002c26 	beq	r4,zero,81121f24 <__floatunsisf+0xc8>
81121e74:	2021883a 	mov	r16,r4
81121e78:	11234780 	call	81123478 <__clzsi2>
81121e7c:	00c02784 	movi	r3,158
81121e80:	1887c83a 	sub	r3,r3,r2
81121e84:	01002584 	movi	r4,150
81121e88:	20c00f16 	blt	r4,r3,81121ec8 <__floatunsisf+0x6c>
81121e8c:	20c9c83a 	sub	r4,r4,r3
81121e90:	8108983a 	sll	r4,r16,r4
81121e94:	00802034 	movhi	r2,128
81121e98:	10bfffc4 	addi	r2,r2,-1
81121e9c:	2088703a 	and	r4,r4,r2
81121ea0:	18803fcc 	andi	r2,r3,255
81121ea4:	100695fa 	slli	r3,r2,23
81121ea8:	00802034 	movhi	r2,128
81121eac:	10bfffc4 	addi	r2,r2,-1
81121eb0:	2084703a 	and	r2,r4,r2
81121eb4:	10c4b03a 	or	r2,r2,r3
81121eb8:	dfc00117 	ldw	ra,4(sp)
81121ebc:	dc000017 	ldw	r16,0(sp)
81121ec0:	dec00204 	addi	sp,sp,8
81121ec4:	f800283a 	ret
81121ec8:	01002644 	movi	r4,153
81121ecc:	20c01816 	blt	r4,r3,81121f30 <__floatunsisf+0xd4>
81121ed0:	20c9c83a 	sub	r4,r4,r3
81121ed4:	8108983a 	sll	r4,r16,r4
81121ed8:	017f0034 	movhi	r5,64512
81121edc:	297fffc4 	addi	r5,r5,-1
81121ee0:	218001cc 	andi	r6,r4,7
81121ee4:	214a703a 	and	r5,r4,r5
81121ee8:	30000426 	beq	r6,zero,81121efc <__floatunsisf+0xa0>
81121eec:	210003cc 	andi	r4,r4,15
81121ef0:	01800104 	movi	r6,4
81121ef4:	21800126 	beq	r4,r6,81121efc <__floatunsisf+0xa0>
81121ef8:	298b883a 	add	r5,r5,r6
81121efc:	2901002c 	andhi	r4,r5,1024
81121f00:	20000526 	beq	r4,zero,81121f18 <__floatunsisf+0xbc>
81121f04:	00c027c4 	movi	r3,159
81121f08:	1887c83a 	sub	r3,r3,r2
81121f0c:	00bf0034 	movhi	r2,64512
81121f10:	10bfffc4 	addi	r2,r2,-1
81121f14:	288a703a 	and	r5,r5,r2
81121f18:	280891ba 	slli	r4,r5,6
81121f1c:	2008d27a 	srli	r4,r4,9
81121f20:	003fdf06 	br	81121ea0 <__reset+0xfb101ea0>
81121f24:	0007883a 	mov	r3,zero
81121f28:	0009883a 	mov	r4,zero
81121f2c:	003fdc06 	br	81121ea0 <__reset+0xfb101ea0>
81121f30:	01402e44 	movi	r5,185
81121f34:	28cbc83a 	sub	r5,r5,r3
81121f38:	01000144 	movi	r4,5
81121f3c:	2089c83a 	sub	r4,r4,r2
81121f40:	814a983a 	sll	r5,r16,r5
81121f44:	8108d83a 	srl	r4,r16,r4
81121f48:	2820c03a 	cmpne	r16,r5,zero
81121f4c:	2408b03a 	or	r4,r4,r16
81121f50:	003fe106 	br	81121ed8 <__reset+0xfb101ed8>

81121f54 <__gedf2>:
81121f54:	2804d53a 	srli	r2,r5,20
81121f58:	3806d53a 	srli	r3,r7,20
81121f5c:	02000434 	movhi	r8,16
81121f60:	423fffc4 	addi	r8,r8,-1
81121f64:	1081ffcc 	andi	r2,r2,2047
81121f68:	0241ffc4 	movi	r9,2047
81121f6c:	2a14703a 	and	r10,r5,r8
81121f70:	18c1ffcc 	andi	r3,r3,2047
81121f74:	3a10703a 	and	r8,r7,r8
81121f78:	280ad7fa 	srli	r5,r5,31
81121f7c:	380ed7fa 	srli	r7,r7,31
81121f80:	12401d26 	beq	r2,r9,81121ff8 <__gedf2+0xa4>
81121f84:	0241ffc4 	movi	r9,2047
81121f88:	1a401226 	beq	r3,r9,81121fd4 <__gedf2+0x80>
81121f8c:	1000081e 	bne	r2,zero,81121fb0 <__gedf2+0x5c>
81121f90:	2296b03a 	or	r11,r4,r10
81121f94:	5813003a 	cmpeq	r9,r11,zero
81121f98:	1800091e 	bne	r3,zero,81121fc0 <__gedf2+0x6c>
81121f9c:	3218b03a 	or	r12,r6,r8
81121fa0:	6000071e 	bne	r12,zero,81121fc0 <__gedf2+0x6c>
81121fa4:	0005883a 	mov	r2,zero
81121fa8:	5800101e 	bne	r11,zero,81121fec <__gedf2+0x98>
81121fac:	f800283a 	ret
81121fb0:	18000c1e 	bne	r3,zero,81121fe4 <__gedf2+0x90>
81121fb4:	3212b03a 	or	r9,r6,r8
81121fb8:	48000c26 	beq	r9,zero,81121fec <__gedf2+0x98>
81121fbc:	0013883a 	mov	r9,zero
81121fc0:	39c03fcc 	andi	r7,r7,255
81121fc4:	48000826 	beq	r9,zero,81121fe8 <__gedf2+0x94>
81121fc8:	38000926 	beq	r7,zero,81121ff0 <__gedf2+0x9c>
81121fcc:	00800044 	movi	r2,1
81121fd0:	f800283a 	ret
81121fd4:	3212b03a 	or	r9,r6,r8
81121fd8:	483fec26 	beq	r9,zero,81121f8c <__reset+0xfb101f8c>
81121fdc:	00bfff84 	movi	r2,-2
81121fe0:	f800283a 	ret
81121fe4:	39c03fcc 	andi	r7,r7,255
81121fe8:	29c00626 	beq	r5,r7,81122004 <__gedf2+0xb0>
81121fec:	283ff726 	beq	r5,zero,81121fcc <__reset+0xfb101fcc>
81121ff0:	00bfffc4 	movi	r2,-1
81121ff4:	f800283a 	ret
81121ff8:	2292b03a 	or	r9,r4,r10
81121ffc:	483fe126 	beq	r9,zero,81121f84 <__reset+0xfb101f84>
81122000:	003ff606 	br	81121fdc <__reset+0xfb101fdc>
81122004:	18bff916 	blt	r3,r2,81121fec <__reset+0xfb101fec>
81122008:	10c00316 	blt	r2,r3,81122018 <__gedf2+0xc4>
8112200c:	42bff736 	bltu	r8,r10,81121fec <__reset+0xfb101fec>
81122010:	52000326 	beq	r10,r8,81122020 <__gedf2+0xcc>
81122014:	5200042e 	bgeu	r10,r8,81122028 <__gedf2+0xd4>
81122018:	283fec1e 	bne	r5,zero,81121fcc <__reset+0xfb101fcc>
8112201c:	003ff406 	br	81121ff0 <__reset+0xfb101ff0>
81122020:	313ff236 	bltu	r6,r4,81121fec <__reset+0xfb101fec>
81122024:	21bffc36 	bltu	r4,r6,81122018 <__reset+0xfb102018>
81122028:	0005883a 	mov	r2,zero
8112202c:	f800283a 	ret

81122030 <__muldf3>:
81122030:	defff304 	addi	sp,sp,-52
81122034:	2804d53a 	srli	r2,r5,20
81122038:	de00012e 	bgeu	sp,et,81122040 <__muldf3+0x10>
8112203c:	003b68fa 	trap	3
81122040:	dd800915 	stw	r22,36(sp)
81122044:	282cd7fa 	srli	r22,r5,31
81122048:	dc000315 	stw	r16,12(sp)
8112204c:	04000434 	movhi	r16,16
81122050:	dd400815 	stw	r21,32(sp)
81122054:	dc800515 	stw	r18,20(sp)
81122058:	843fffc4 	addi	r16,r16,-1
8112205c:	dfc00c15 	stw	ra,48(sp)
81122060:	df000b15 	stw	fp,44(sp)
81122064:	ddc00a15 	stw	r23,40(sp)
81122068:	dd000715 	stw	r20,28(sp)
8112206c:	dcc00615 	stw	r19,24(sp)
81122070:	dc400415 	stw	r17,16(sp)
81122074:	1481ffcc 	andi	r18,r2,2047
81122078:	2c20703a 	and	r16,r5,r16
8112207c:	b02b883a 	mov	r21,r22
81122080:	b2403fcc 	andi	r9,r22,255
81122084:	90006026 	beq	r18,zero,81122208 <__muldf3+0x1d8>
81122088:	0081ffc4 	movi	r2,2047
8112208c:	2029883a 	mov	r20,r4
81122090:	90803626 	beq	r18,r2,8112216c <__muldf3+0x13c>
81122094:	80800434 	orhi	r2,r16,16
81122098:	100490fa 	slli	r2,r2,3
8112209c:	2020d77a 	srli	r16,r4,29
811220a0:	202890fa 	slli	r20,r4,3
811220a4:	94bf0044 	addi	r18,r18,-1023
811220a8:	80a0b03a 	or	r16,r16,r2
811220ac:	0027883a 	mov	r19,zero
811220b0:	0039883a 	mov	fp,zero
811220b4:	3804d53a 	srli	r2,r7,20
811220b8:	382ed7fa 	srli	r23,r7,31
811220bc:	04400434 	movhi	r17,16
811220c0:	8c7fffc4 	addi	r17,r17,-1
811220c4:	1081ffcc 	andi	r2,r2,2047
811220c8:	3011883a 	mov	r8,r6
811220cc:	3c62703a 	and	r17,r7,r17
811220d0:	ba803fcc 	andi	r10,r23,255
811220d4:	10006d26 	beq	r2,zero,8112228c <__muldf3+0x25c>
811220d8:	00c1ffc4 	movi	r3,2047
811220dc:	10c06526 	beq	r2,r3,81122274 <__muldf3+0x244>
811220e0:	88c00434 	orhi	r3,r17,16
811220e4:	180690fa 	slli	r3,r3,3
811220e8:	3022d77a 	srli	r17,r6,29
811220ec:	301090fa 	slli	r8,r6,3
811220f0:	10bf0044 	addi	r2,r2,-1023
811220f4:	88e2b03a 	or	r17,r17,r3
811220f8:	000b883a 	mov	r5,zero
811220fc:	9085883a 	add	r2,r18,r2
81122100:	2cc8b03a 	or	r4,r5,r19
81122104:	00c003c4 	movi	r3,15
81122108:	bdacf03a 	xor	r22,r23,r22
8112210c:	12c00044 	addi	r11,r2,1
81122110:	19009936 	bltu	r3,r4,81122378 <__muldf3+0x348>
81122114:	200890ba 	slli	r4,r4,2
81122118:	00e044b4 	movhi	r3,33042
8112211c:	18c84b04 	addi	r3,r3,8492
81122120:	20c9883a 	add	r4,r4,r3
81122124:	20c00017 	ldw	r3,0(r4)
81122128:	1800683a 	jmp	r3
8112212c:	81122378 	rdprs	r4,r16,18573
81122130:	8112218c 	andi	r4,r16,18566
81122134:	8112218c 	andi	r4,r16,18566
81122138:	81122188 	cmpgei	r4,r16,18566
8112213c:	81122354 	ori	r4,r16,18573
81122140:	81122354 	ori	r4,r16,18573
81122144:	8112233c 	xorhi	r4,r16,18572
81122148:	81122188 	cmpgei	r4,r16,18566
8112214c:	81122354 	ori	r4,r16,18573
81122150:	8112233c 	xorhi	r4,r16,18572
81122154:	81122354 	ori	r4,r16,18573
81122158:	81122188 	cmpgei	r4,r16,18566
8112215c:	81122364 	muli	r4,r16,18573
81122160:	81122364 	muli	r4,r16,18573
81122164:	81122364 	muli	r4,r16,18573
81122168:	81122580 	call	88112258 <__reset+0x20f2258>
8112216c:	2404b03a 	or	r2,r4,r16
81122170:	10006f1e 	bne	r2,zero,81122330 <__muldf3+0x300>
81122174:	04c00204 	movi	r19,8
81122178:	0021883a 	mov	r16,zero
8112217c:	0029883a 	mov	r20,zero
81122180:	07000084 	movi	fp,2
81122184:	003fcb06 	br	811220b4 <__reset+0xfb1020b4>
81122188:	502d883a 	mov	r22,r10
8112218c:	00800084 	movi	r2,2
81122190:	28805726 	beq	r5,r2,811222f0 <__muldf3+0x2c0>
81122194:	008000c4 	movi	r2,3
81122198:	28816626 	beq	r5,r2,81122734 <__muldf3+0x704>
8112219c:	00800044 	movi	r2,1
811221a0:	2881411e 	bne	r5,r2,811226a8 <__muldf3+0x678>
811221a4:	b02b883a 	mov	r21,r22
811221a8:	0005883a 	mov	r2,zero
811221ac:	000b883a 	mov	r5,zero
811221b0:	0029883a 	mov	r20,zero
811221b4:	1004953a 	slli	r2,r2,20
811221b8:	a8c03fcc 	andi	r3,r21,255
811221bc:	04400434 	movhi	r17,16
811221c0:	8c7fffc4 	addi	r17,r17,-1
811221c4:	180697fa 	slli	r3,r3,31
811221c8:	2c4a703a 	and	r5,r5,r17
811221cc:	288ab03a 	or	r5,r5,r2
811221d0:	28c6b03a 	or	r3,r5,r3
811221d4:	a005883a 	mov	r2,r20
811221d8:	dfc00c17 	ldw	ra,48(sp)
811221dc:	df000b17 	ldw	fp,44(sp)
811221e0:	ddc00a17 	ldw	r23,40(sp)
811221e4:	dd800917 	ldw	r22,36(sp)
811221e8:	dd400817 	ldw	r21,32(sp)
811221ec:	dd000717 	ldw	r20,28(sp)
811221f0:	dcc00617 	ldw	r19,24(sp)
811221f4:	dc800517 	ldw	r18,20(sp)
811221f8:	dc400417 	ldw	r17,16(sp)
811221fc:	dc000317 	ldw	r16,12(sp)
81122200:	dec00d04 	addi	sp,sp,52
81122204:	f800283a 	ret
81122208:	2404b03a 	or	r2,r4,r16
8112220c:	2027883a 	mov	r19,r4
81122210:	10004226 	beq	r2,zero,8112231c <__muldf3+0x2ec>
81122214:	8000fc26 	beq	r16,zero,81122608 <__muldf3+0x5d8>
81122218:	8009883a 	mov	r4,r16
8112221c:	d9800215 	stw	r6,8(sp)
81122220:	d9c00015 	stw	r7,0(sp)
81122224:	da400115 	stw	r9,4(sp)
81122228:	11234780 	call	81123478 <__clzsi2>
8112222c:	d9800217 	ldw	r6,8(sp)
81122230:	d9c00017 	ldw	r7,0(sp)
81122234:	da400117 	ldw	r9,4(sp)
81122238:	113ffd44 	addi	r4,r2,-11
8112223c:	00c00704 	movi	r3,28
81122240:	1900ed16 	blt	r3,r4,811225f8 <__muldf3+0x5c8>
81122244:	00c00744 	movi	r3,29
81122248:	147ffe04 	addi	r17,r2,-8
8112224c:	1907c83a 	sub	r3,r3,r4
81122250:	8460983a 	sll	r16,r16,r17
81122254:	98c6d83a 	srl	r3,r19,r3
81122258:	9c68983a 	sll	r20,r19,r17
8112225c:	1c20b03a 	or	r16,r3,r16
81122260:	1080fcc4 	addi	r2,r2,1011
81122264:	00a5c83a 	sub	r18,zero,r2
81122268:	0027883a 	mov	r19,zero
8112226c:	0039883a 	mov	fp,zero
81122270:	003f9006 	br	811220b4 <__reset+0xfb1020b4>
81122274:	3446b03a 	or	r3,r6,r17
81122278:	1800261e 	bne	r3,zero,81122314 <__muldf3+0x2e4>
8112227c:	0023883a 	mov	r17,zero
81122280:	0011883a 	mov	r8,zero
81122284:	01400084 	movi	r5,2
81122288:	003f9c06 	br	811220fc <__reset+0xfb1020fc>
8112228c:	3446b03a 	or	r3,r6,r17
81122290:	18001c26 	beq	r3,zero,81122304 <__muldf3+0x2d4>
81122294:	8800ce26 	beq	r17,zero,811225d0 <__muldf3+0x5a0>
81122298:	8809883a 	mov	r4,r17
8112229c:	d9800215 	stw	r6,8(sp)
811222a0:	da400115 	stw	r9,4(sp)
811222a4:	da800015 	stw	r10,0(sp)
811222a8:	11234780 	call	81123478 <__clzsi2>
811222ac:	d9800217 	ldw	r6,8(sp)
811222b0:	da400117 	ldw	r9,4(sp)
811222b4:	da800017 	ldw	r10,0(sp)
811222b8:	113ffd44 	addi	r4,r2,-11
811222bc:	00c00704 	movi	r3,28
811222c0:	1900bf16 	blt	r3,r4,811225c0 <__muldf3+0x590>
811222c4:	00c00744 	movi	r3,29
811222c8:	123ffe04 	addi	r8,r2,-8
811222cc:	1907c83a 	sub	r3,r3,r4
811222d0:	8a22983a 	sll	r17,r17,r8
811222d4:	30c6d83a 	srl	r3,r6,r3
811222d8:	3210983a 	sll	r8,r6,r8
811222dc:	1c62b03a 	or	r17,r3,r17
811222e0:	1080fcc4 	addi	r2,r2,1011
811222e4:	0085c83a 	sub	r2,zero,r2
811222e8:	000b883a 	mov	r5,zero
811222ec:	003f8306 	br	811220fc <__reset+0xfb1020fc>
811222f0:	b02b883a 	mov	r21,r22
811222f4:	0081ffc4 	movi	r2,2047
811222f8:	000b883a 	mov	r5,zero
811222fc:	0029883a 	mov	r20,zero
81122300:	003fac06 	br	811221b4 <__reset+0xfb1021b4>
81122304:	0023883a 	mov	r17,zero
81122308:	0011883a 	mov	r8,zero
8112230c:	01400044 	movi	r5,1
81122310:	003f7a06 	br	811220fc <__reset+0xfb1020fc>
81122314:	014000c4 	movi	r5,3
81122318:	003f7806 	br	811220fc <__reset+0xfb1020fc>
8112231c:	04c00104 	movi	r19,4
81122320:	0021883a 	mov	r16,zero
81122324:	0029883a 	mov	r20,zero
81122328:	07000044 	movi	fp,1
8112232c:	003f6106 	br	811220b4 <__reset+0xfb1020b4>
81122330:	04c00304 	movi	r19,12
81122334:	070000c4 	movi	fp,3
81122338:	003f5e06 	br	811220b4 <__reset+0xfb1020b4>
8112233c:	01400434 	movhi	r5,16
81122340:	002b883a 	mov	r21,zero
81122344:	297fffc4 	addi	r5,r5,-1
81122348:	053fffc4 	movi	r20,-1
8112234c:	0081ffc4 	movi	r2,2047
81122350:	003f9806 	br	811221b4 <__reset+0xfb1021b4>
81122354:	8023883a 	mov	r17,r16
81122358:	a011883a 	mov	r8,r20
8112235c:	e00b883a 	mov	r5,fp
81122360:	003f8a06 	br	8112218c <__reset+0xfb10218c>
81122364:	8023883a 	mov	r17,r16
81122368:	a011883a 	mov	r8,r20
8112236c:	482d883a 	mov	r22,r9
81122370:	e00b883a 	mov	r5,fp
81122374:	003f8506 	br	8112218c <__reset+0xfb10218c>
81122378:	a00ad43a 	srli	r5,r20,16
8112237c:	401ad43a 	srli	r13,r8,16
81122380:	a53fffcc 	andi	r20,r20,65535
81122384:	423fffcc 	andi	r8,r8,65535
81122388:	4519383a 	mul	r12,r8,r20
8112238c:	4147383a 	mul	r3,r8,r5
81122390:	6d09383a 	mul	r4,r13,r20
81122394:	600cd43a 	srli	r6,r12,16
81122398:	2b5d383a 	mul	r14,r5,r13
8112239c:	20c9883a 	add	r4,r4,r3
811223a0:	310d883a 	add	r6,r6,r4
811223a4:	30c0022e 	bgeu	r6,r3,811223b0 <__muldf3+0x380>
811223a8:	00c00074 	movhi	r3,1
811223ac:	70dd883a 	add	r14,r14,r3
811223b0:	8826d43a 	srli	r19,r17,16
811223b4:	8bffffcc 	andi	r15,r17,65535
811223b8:	7d23383a 	mul	r17,r15,r20
811223bc:	7949383a 	mul	r4,r15,r5
811223c0:	9d29383a 	mul	r20,r19,r20
811223c4:	8814d43a 	srli	r10,r17,16
811223c8:	3012943a 	slli	r9,r6,16
811223cc:	a129883a 	add	r20,r20,r4
811223d0:	633fffcc 	andi	r12,r12,65535
811223d4:	5515883a 	add	r10,r10,r20
811223d8:	3006d43a 	srli	r3,r6,16
811223dc:	4b13883a 	add	r9,r9,r12
811223e0:	2ccb383a 	mul	r5,r5,r19
811223e4:	5100022e 	bgeu	r10,r4,811223f0 <__muldf3+0x3c0>
811223e8:	01000074 	movhi	r4,1
811223ec:	290b883a 	add	r5,r5,r4
811223f0:	802ad43a 	srli	r21,r16,16
811223f4:	843fffcc 	andi	r16,r16,65535
811223f8:	440d383a 	mul	r6,r8,r16
811223fc:	4565383a 	mul	r18,r8,r21
81122400:	8349383a 	mul	r4,r16,r13
81122404:	500e943a 	slli	r7,r10,16
81122408:	3010d43a 	srli	r8,r6,16
8112240c:	5028d43a 	srli	r20,r10,16
81122410:	2489883a 	add	r4,r4,r18
81122414:	8abfffcc 	andi	r10,r17,65535
81122418:	3a95883a 	add	r10,r7,r10
8112241c:	4119883a 	add	r12,r8,r4
81122420:	a169883a 	add	r20,r20,r5
81122424:	1a87883a 	add	r3,r3,r10
81122428:	6d5b383a 	mul	r13,r13,r21
8112242c:	6480022e 	bgeu	r12,r18,81122438 <__muldf3+0x408>
81122430:	01000074 	movhi	r4,1
81122434:	691b883a 	add	r13,r13,r4
81122438:	7c25383a 	mul	r18,r15,r16
8112243c:	7d4b383a 	mul	r5,r15,r21
81122440:	84cf383a 	mul	r7,r16,r19
81122444:	901ed43a 	srli	r15,r18,16
81122448:	6008d43a 	srli	r4,r12,16
8112244c:	6010943a 	slli	r8,r12,16
81122450:	394f883a 	add	r7,r7,r5
81122454:	333fffcc 	andi	r12,r6,65535
81122458:	79df883a 	add	r15,r15,r7
8112245c:	235b883a 	add	r13,r4,r13
81122460:	9d63383a 	mul	r17,r19,r21
81122464:	4309883a 	add	r4,r8,r12
81122468:	7940022e 	bgeu	r15,r5,81122474 <__muldf3+0x444>
8112246c:	01400074 	movhi	r5,1
81122470:	8963883a 	add	r17,r17,r5
81122474:	780a943a 	slli	r5,r15,16
81122478:	91bfffcc 	andi	r6,r18,65535
8112247c:	70c7883a 	add	r3,r14,r3
81122480:	298d883a 	add	r6,r5,r6
81122484:	1a8f803a 	cmpltu	r7,r3,r10
81122488:	350b883a 	add	r5,r6,r20
8112248c:	20c7883a 	add	r3,r4,r3
81122490:	3955883a 	add	r10,r7,r5
81122494:	1909803a 	cmpltu	r4,r3,r4
81122498:	6a91883a 	add	r8,r13,r10
8112249c:	780cd43a 	srli	r6,r15,16
811224a0:	2219883a 	add	r12,r4,r8
811224a4:	2d0b803a 	cmpltu	r5,r5,r20
811224a8:	51cf803a 	cmpltu	r7,r10,r7
811224ac:	29ceb03a 	or	r7,r5,r7
811224b0:	4351803a 	cmpltu	r8,r8,r13
811224b4:	610b803a 	cmpltu	r5,r12,r4
811224b8:	4148b03a 	or	r4,r8,r5
811224bc:	398f883a 	add	r7,r7,r6
811224c0:	3909883a 	add	r4,r7,r4
811224c4:	1810927a 	slli	r8,r3,9
811224c8:	2449883a 	add	r4,r4,r17
811224cc:	2008927a 	slli	r4,r4,9
811224d0:	6022d5fa 	srli	r17,r12,23
811224d4:	1806d5fa 	srli	r3,r3,23
811224d8:	4252b03a 	or	r9,r8,r9
811224dc:	600a927a 	slli	r5,r12,9
811224e0:	4810c03a 	cmpne	r8,r9,zero
811224e4:	2462b03a 	or	r17,r4,r17
811224e8:	40c6b03a 	or	r3,r8,r3
811224ec:	8900402c 	andhi	r4,r17,256
811224f0:	1950b03a 	or	r8,r3,r5
811224f4:	20000726 	beq	r4,zero,81122514 <__muldf3+0x4e4>
811224f8:	4006d07a 	srli	r3,r8,1
811224fc:	880497fa 	slli	r2,r17,31
81122500:	4200004c 	andi	r8,r8,1
81122504:	8822d07a 	srli	r17,r17,1
81122508:	1a10b03a 	or	r8,r3,r8
8112250c:	1210b03a 	or	r8,r2,r8
81122510:	5805883a 	mov	r2,r11
81122514:	1140ffc4 	addi	r5,r2,1023
81122518:	0140440e 	bge	zero,r5,8112262c <__muldf3+0x5fc>
8112251c:	40c001cc 	andi	r3,r8,7
81122520:	18000726 	beq	r3,zero,81122540 <__muldf3+0x510>
81122524:	40c003cc 	andi	r3,r8,15
81122528:	01000104 	movi	r4,4
8112252c:	19000426 	beq	r3,r4,81122540 <__muldf3+0x510>
81122530:	4107883a 	add	r3,r8,r4
81122534:	1a11803a 	cmpltu	r8,r3,r8
81122538:	8a23883a 	add	r17,r17,r8
8112253c:	1811883a 	mov	r8,r3
81122540:	88c0402c 	andhi	r3,r17,256
81122544:	18000426 	beq	r3,zero,81122558 <__muldf3+0x528>
81122548:	11410004 	addi	r5,r2,1024
8112254c:	00bfc034 	movhi	r2,65280
81122550:	10bfffc4 	addi	r2,r2,-1
81122554:	88a2703a 	and	r17,r17,r2
81122558:	0081ff84 	movi	r2,2046
8112255c:	117f6416 	blt	r2,r5,811222f0 <__reset+0xfb1022f0>
81122560:	8828977a 	slli	r20,r17,29
81122564:	4010d0fa 	srli	r8,r8,3
81122568:	8822927a 	slli	r17,r17,9
8112256c:	2881ffcc 	andi	r2,r5,2047
81122570:	a228b03a 	or	r20,r20,r8
81122574:	880ad33a 	srli	r5,r17,12
81122578:	b02b883a 	mov	r21,r22
8112257c:	003f0d06 	br	811221b4 <__reset+0xfb1021b4>
81122580:	8080022c 	andhi	r2,r16,8
81122584:	10000926 	beq	r2,zero,811225ac <__muldf3+0x57c>
81122588:	8880022c 	andhi	r2,r17,8
8112258c:	1000071e 	bne	r2,zero,811225ac <__muldf3+0x57c>
81122590:	00800434 	movhi	r2,16
81122594:	89400234 	orhi	r5,r17,8
81122598:	10bfffc4 	addi	r2,r2,-1
8112259c:	b82b883a 	mov	r21,r23
811225a0:	288a703a 	and	r5,r5,r2
811225a4:	4029883a 	mov	r20,r8
811225a8:	003f6806 	br	8112234c <__reset+0xfb10234c>
811225ac:	00800434 	movhi	r2,16
811225b0:	81400234 	orhi	r5,r16,8
811225b4:	10bfffc4 	addi	r2,r2,-1
811225b8:	288a703a 	and	r5,r5,r2
811225bc:	003f6306 	br	8112234c <__reset+0xfb10234c>
811225c0:	147ff604 	addi	r17,r2,-40
811225c4:	3462983a 	sll	r17,r6,r17
811225c8:	0011883a 	mov	r8,zero
811225cc:	003f4406 	br	811222e0 <__reset+0xfb1022e0>
811225d0:	3009883a 	mov	r4,r6
811225d4:	d9800215 	stw	r6,8(sp)
811225d8:	da400115 	stw	r9,4(sp)
811225dc:	da800015 	stw	r10,0(sp)
811225e0:	11234780 	call	81123478 <__clzsi2>
811225e4:	10800804 	addi	r2,r2,32
811225e8:	da800017 	ldw	r10,0(sp)
811225ec:	da400117 	ldw	r9,4(sp)
811225f0:	d9800217 	ldw	r6,8(sp)
811225f4:	003f3006 	br	811222b8 <__reset+0xfb1022b8>
811225f8:	143ff604 	addi	r16,r2,-40
811225fc:	9c20983a 	sll	r16,r19,r16
81122600:	0029883a 	mov	r20,zero
81122604:	003f1606 	br	81122260 <__reset+0xfb102260>
81122608:	d9800215 	stw	r6,8(sp)
8112260c:	d9c00015 	stw	r7,0(sp)
81122610:	da400115 	stw	r9,4(sp)
81122614:	11234780 	call	81123478 <__clzsi2>
81122618:	10800804 	addi	r2,r2,32
8112261c:	da400117 	ldw	r9,4(sp)
81122620:	d9c00017 	ldw	r7,0(sp)
81122624:	d9800217 	ldw	r6,8(sp)
81122628:	003f0306 	br	81122238 <__reset+0xfb102238>
8112262c:	00c00044 	movi	r3,1
81122630:	1947c83a 	sub	r3,r3,r5
81122634:	00800e04 	movi	r2,56
81122638:	10feda16 	blt	r2,r3,811221a4 <__reset+0xfb1021a4>
8112263c:	008007c4 	movi	r2,31
81122640:	10c01b16 	blt	r2,r3,811226b0 <__muldf3+0x680>
81122644:	00800804 	movi	r2,32
81122648:	10c5c83a 	sub	r2,r2,r3
8112264c:	888a983a 	sll	r5,r17,r2
81122650:	40c8d83a 	srl	r4,r8,r3
81122654:	4084983a 	sll	r2,r8,r2
81122658:	88e2d83a 	srl	r17,r17,r3
8112265c:	2906b03a 	or	r3,r5,r4
81122660:	1004c03a 	cmpne	r2,r2,zero
81122664:	1886b03a 	or	r3,r3,r2
81122668:	188001cc 	andi	r2,r3,7
8112266c:	10000726 	beq	r2,zero,8112268c <__muldf3+0x65c>
81122670:	188003cc 	andi	r2,r3,15
81122674:	01000104 	movi	r4,4
81122678:	11000426 	beq	r2,r4,8112268c <__muldf3+0x65c>
8112267c:	1805883a 	mov	r2,r3
81122680:	10c00104 	addi	r3,r2,4
81122684:	1885803a 	cmpltu	r2,r3,r2
81122688:	88a3883a 	add	r17,r17,r2
8112268c:	8880202c 	andhi	r2,r17,128
81122690:	10001c26 	beq	r2,zero,81122704 <__muldf3+0x6d4>
81122694:	b02b883a 	mov	r21,r22
81122698:	00800044 	movi	r2,1
8112269c:	000b883a 	mov	r5,zero
811226a0:	0029883a 	mov	r20,zero
811226a4:	003ec306 	br	811221b4 <__reset+0xfb1021b4>
811226a8:	5805883a 	mov	r2,r11
811226ac:	003f9906 	br	81122514 <__reset+0xfb102514>
811226b0:	00bff844 	movi	r2,-31
811226b4:	1145c83a 	sub	r2,r2,r5
811226b8:	8888d83a 	srl	r4,r17,r2
811226bc:	00800804 	movi	r2,32
811226c0:	18801a26 	beq	r3,r2,8112272c <__muldf3+0x6fc>
811226c4:	00801004 	movi	r2,64
811226c8:	10c5c83a 	sub	r2,r2,r3
811226cc:	8884983a 	sll	r2,r17,r2
811226d0:	1204b03a 	or	r2,r2,r8
811226d4:	1004c03a 	cmpne	r2,r2,zero
811226d8:	2084b03a 	or	r2,r4,r2
811226dc:	144001cc 	andi	r17,r2,7
811226e0:	88000d1e 	bne	r17,zero,81122718 <__muldf3+0x6e8>
811226e4:	000b883a 	mov	r5,zero
811226e8:	1028d0fa 	srli	r20,r2,3
811226ec:	b02b883a 	mov	r21,r22
811226f0:	0005883a 	mov	r2,zero
811226f4:	a468b03a 	or	r20,r20,r17
811226f8:	003eae06 	br	811221b4 <__reset+0xfb1021b4>
811226fc:	1007883a 	mov	r3,r2
81122700:	0023883a 	mov	r17,zero
81122704:	880a927a 	slli	r5,r17,9
81122708:	1805883a 	mov	r2,r3
8112270c:	8822977a 	slli	r17,r17,29
81122710:	280ad33a 	srli	r5,r5,12
81122714:	003ff406 	br	811226e8 <__reset+0xfb1026e8>
81122718:	10c003cc 	andi	r3,r2,15
8112271c:	01000104 	movi	r4,4
81122720:	193ff626 	beq	r3,r4,811226fc <__reset+0xfb1026fc>
81122724:	0023883a 	mov	r17,zero
81122728:	003fd506 	br	81122680 <__reset+0xfb102680>
8112272c:	0005883a 	mov	r2,zero
81122730:	003fe706 	br	811226d0 <__reset+0xfb1026d0>
81122734:	00800434 	movhi	r2,16
81122738:	89400234 	orhi	r5,r17,8
8112273c:	10bfffc4 	addi	r2,r2,-1
81122740:	b02b883a 	mov	r21,r22
81122744:	288a703a 	and	r5,r5,r2
81122748:	4029883a 	mov	r20,r8
8112274c:	003eff06 	br	8112234c <__reset+0xfb10234c>

81122750 <__subdf3>:
81122750:	02000434 	movhi	r8,16
81122754:	423fffc4 	addi	r8,r8,-1
81122758:	defffb04 	addi	sp,sp,-20
8112275c:	2a14703a 	and	r10,r5,r8
81122760:	3812d53a 	srli	r9,r7,20
81122764:	3a10703a 	and	r8,r7,r8
81122768:	de00012e 	bgeu	sp,et,81122770 <__subdf3+0x20>
8112276c:	003b68fa 	trap	3
81122770:	2006d77a 	srli	r3,r4,29
81122774:	3004d77a 	srli	r2,r6,29
81122778:	dc000015 	stw	r16,0(sp)
8112277c:	501490fa 	slli	r10,r10,3
81122780:	2820d53a 	srli	r16,r5,20
81122784:	401090fa 	slli	r8,r8,3
81122788:	dc800215 	stw	r18,8(sp)
8112278c:	dc400115 	stw	r17,4(sp)
81122790:	dfc00415 	stw	ra,16(sp)
81122794:	202290fa 	slli	r17,r4,3
81122798:	dcc00315 	stw	r19,12(sp)
8112279c:	4a41ffcc 	andi	r9,r9,2047
811227a0:	0101ffc4 	movi	r4,2047
811227a4:	2824d7fa 	srli	r18,r5,31
811227a8:	8401ffcc 	andi	r16,r16,2047
811227ac:	50c6b03a 	or	r3,r10,r3
811227b0:	380ed7fa 	srli	r7,r7,31
811227b4:	408ab03a 	or	r5,r8,r2
811227b8:	300c90fa 	slli	r6,r6,3
811227bc:	49009626 	beq	r9,r4,81122a18 <__subdf3+0x2c8>
811227c0:	39c0005c 	xori	r7,r7,1
811227c4:	8245c83a 	sub	r2,r16,r9
811227c8:	3c807426 	beq	r7,r18,8112299c <__subdf3+0x24c>
811227cc:	0080af0e 	bge	zero,r2,81122a8c <__subdf3+0x33c>
811227d0:	48002a1e 	bne	r9,zero,8112287c <__subdf3+0x12c>
811227d4:	2988b03a 	or	r4,r5,r6
811227d8:	20009a1e 	bne	r4,zero,81122a44 <__subdf3+0x2f4>
811227dc:	888001cc 	andi	r2,r17,7
811227e0:	10000726 	beq	r2,zero,81122800 <__subdf3+0xb0>
811227e4:	888003cc 	andi	r2,r17,15
811227e8:	01000104 	movi	r4,4
811227ec:	11000426 	beq	r2,r4,81122800 <__subdf3+0xb0>
811227f0:	890b883a 	add	r5,r17,r4
811227f4:	2c63803a 	cmpltu	r17,r5,r17
811227f8:	1c47883a 	add	r3,r3,r17
811227fc:	2823883a 	mov	r17,r5
81122800:	1880202c 	andhi	r2,r3,128
81122804:	10005926 	beq	r2,zero,8112296c <__subdf3+0x21c>
81122808:	84000044 	addi	r16,r16,1
8112280c:	0081ffc4 	movi	r2,2047
81122810:	8080be26 	beq	r16,r2,81122b0c <__subdf3+0x3bc>
81122814:	017fe034 	movhi	r5,65408
81122818:	297fffc4 	addi	r5,r5,-1
8112281c:	1946703a 	and	r3,r3,r5
81122820:	1804977a 	slli	r2,r3,29
81122824:	1806927a 	slli	r3,r3,9
81122828:	8822d0fa 	srli	r17,r17,3
8112282c:	8401ffcc 	andi	r16,r16,2047
81122830:	180ad33a 	srli	r5,r3,12
81122834:	9100004c 	andi	r4,r18,1
81122838:	1444b03a 	or	r2,r2,r17
8112283c:	80c1ffcc 	andi	r3,r16,2047
81122840:	1820953a 	slli	r16,r3,20
81122844:	20c03fcc 	andi	r3,r4,255
81122848:	180897fa 	slli	r4,r3,31
8112284c:	00c00434 	movhi	r3,16
81122850:	18ffffc4 	addi	r3,r3,-1
81122854:	28c6703a 	and	r3,r5,r3
81122858:	1c06b03a 	or	r3,r3,r16
8112285c:	1906b03a 	or	r3,r3,r4
81122860:	dfc00417 	ldw	ra,16(sp)
81122864:	dcc00317 	ldw	r19,12(sp)
81122868:	dc800217 	ldw	r18,8(sp)
8112286c:	dc400117 	ldw	r17,4(sp)
81122870:	dc000017 	ldw	r16,0(sp)
81122874:	dec00504 	addi	sp,sp,20
81122878:	f800283a 	ret
8112287c:	0101ffc4 	movi	r4,2047
81122880:	813fd626 	beq	r16,r4,811227dc <__reset+0xfb1027dc>
81122884:	29402034 	orhi	r5,r5,128
81122888:	01000e04 	movi	r4,56
8112288c:	2080a316 	blt	r4,r2,81122b1c <__subdf3+0x3cc>
81122890:	010007c4 	movi	r4,31
81122894:	2080c616 	blt	r4,r2,81122bb0 <__subdf3+0x460>
81122898:	01000804 	movi	r4,32
8112289c:	2089c83a 	sub	r4,r4,r2
811228a0:	2910983a 	sll	r8,r5,r4
811228a4:	308ed83a 	srl	r7,r6,r2
811228a8:	3108983a 	sll	r4,r6,r4
811228ac:	2884d83a 	srl	r2,r5,r2
811228b0:	41ccb03a 	or	r6,r8,r7
811228b4:	2008c03a 	cmpne	r4,r4,zero
811228b8:	310cb03a 	or	r6,r6,r4
811228bc:	898dc83a 	sub	r6,r17,r6
811228c0:	89a3803a 	cmpltu	r17,r17,r6
811228c4:	1887c83a 	sub	r3,r3,r2
811228c8:	1c47c83a 	sub	r3,r3,r17
811228cc:	3023883a 	mov	r17,r6
811228d0:	1880202c 	andhi	r2,r3,128
811228d4:	10002326 	beq	r2,zero,81122964 <__subdf3+0x214>
811228d8:	04c02034 	movhi	r19,128
811228dc:	9cffffc4 	addi	r19,r19,-1
811228e0:	1ce6703a 	and	r19,r3,r19
811228e4:	98007a26 	beq	r19,zero,81122ad0 <__subdf3+0x380>
811228e8:	9809883a 	mov	r4,r19
811228ec:	11234780 	call	81123478 <__clzsi2>
811228f0:	113ffe04 	addi	r4,r2,-8
811228f4:	00c007c4 	movi	r3,31
811228f8:	19007b16 	blt	r3,r4,81122ae8 <__subdf3+0x398>
811228fc:	00800804 	movi	r2,32
81122900:	1105c83a 	sub	r2,r2,r4
81122904:	8884d83a 	srl	r2,r17,r2
81122908:	9906983a 	sll	r3,r19,r4
8112290c:	8922983a 	sll	r17,r17,r4
81122910:	10c4b03a 	or	r2,r2,r3
81122914:	24007816 	blt	r4,r16,81122af8 <__subdf3+0x3a8>
81122918:	2421c83a 	sub	r16,r4,r16
8112291c:	80c00044 	addi	r3,r16,1
81122920:	010007c4 	movi	r4,31
81122924:	20c09516 	blt	r4,r3,81122b7c <__subdf3+0x42c>
81122928:	01400804 	movi	r5,32
8112292c:	28cbc83a 	sub	r5,r5,r3
81122930:	88c8d83a 	srl	r4,r17,r3
81122934:	8962983a 	sll	r17,r17,r5
81122938:	114a983a 	sll	r5,r2,r5
8112293c:	10c6d83a 	srl	r3,r2,r3
81122940:	8804c03a 	cmpne	r2,r17,zero
81122944:	290ab03a 	or	r5,r5,r4
81122948:	28a2b03a 	or	r17,r5,r2
8112294c:	0021883a 	mov	r16,zero
81122950:	003fa206 	br	811227dc <__reset+0xfb1027dc>
81122954:	2090b03a 	or	r8,r4,r2
81122958:	40018e26 	beq	r8,zero,81122f94 <__subdf3+0x844>
8112295c:	1007883a 	mov	r3,r2
81122960:	2023883a 	mov	r17,r4
81122964:	888001cc 	andi	r2,r17,7
81122968:	103f9e1e 	bne	r2,zero,811227e4 <__reset+0xfb1027e4>
8112296c:	1804977a 	slli	r2,r3,29
81122970:	8822d0fa 	srli	r17,r17,3
81122974:	1810d0fa 	srli	r8,r3,3
81122978:	9100004c 	andi	r4,r18,1
8112297c:	1444b03a 	or	r2,r2,r17
81122980:	00c1ffc4 	movi	r3,2047
81122984:	80c02826 	beq	r16,r3,81122a28 <__subdf3+0x2d8>
81122988:	01400434 	movhi	r5,16
8112298c:	297fffc4 	addi	r5,r5,-1
81122990:	80e0703a 	and	r16,r16,r3
81122994:	414a703a 	and	r5,r8,r5
81122998:	003fa806 	br	8112283c <__reset+0xfb10283c>
8112299c:	0080630e 	bge	zero,r2,81122b2c <__subdf3+0x3dc>
811229a0:	48003026 	beq	r9,zero,81122a64 <__subdf3+0x314>
811229a4:	0101ffc4 	movi	r4,2047
811229a8:	813f8c26 	beq	r16,r4,811227dc <__reset+0xfb1027dc>
811229ac:	29402034 	orhi	r5,r5,128
811229b0:	01000e04 	movi	r4,56
811229b4:	2080a90e 	bge	r4,r2,81122c5c <__subdf3+0x50c>
811229b8:	298cb03a 	or	r6,r5,r6
811229bc:	3012c03a 	cmpne	r9,r6,zero
811229c0:	0005883a 	mov	r2,zero
811229c4:	4c53883a 	add	r9,r9,r17
811229c8:	4c63803a 	cmpltu	r17,r9,r17
811229cc:	10c7883a 	add	r3,r2,r3
811229d0:	88c7883a 	add	r3,r17,r3
811229d4:	4823883a 	mov	r17,r9
811229d8:	1880202c 	andhi	r2,r3,128
811229dc:	1000d026 	beq	r2,zero,81122d20 <__subdf3+0x5d0>
811229e0:	84000044 	addi	r16,r16,1
811229e4:	0081ffc4 	movi	r2,2047
811229e8:	8080fe26 	beq	r16,r2,81122de4 <__subdf3+0x694>
811229ec:	00bfe034 	movhi	r2,65408
811229f0:	10bfffc4 	addi	r2,r2,-1
811229f4:	1886703a 	and	r3,r3,r2
811229f8:	880ad07a 	srli	r5,r17,1
811229fc:	180497fa 	slli	r2,r3,31
81122a00:	8900004c 	andi	r4,r17,1
81122a04:	2922b03a 	or	r17,r5,r4
81122a08:	1806d07a 	srli	r3,r3,1
81122a0c:	1462b03a 	or	r17,r2,r17
81122a10:	3825883a 	mov	r18,r7
81122a14:	003f7106 	br	811227dc <__reset+0xfb1027dc>
81122a18:	2984b03a 	or	r2,r5,r6
81122a1c:	103f6826 	beq	r2,zero,811227c0 <__reset+0xfb1027c0>
81122a20:	39c03fcc 	andi	r7,r7,255
81122a24:	003f6706 	br	811227c4 <__reset+0xfb1027c4>
81122a28:	4086b03a 	or	r3,r8,r2
81122a2c:	18015226 	beq	r3,zero,81122f78 <__subdf3+0x828>
81122a30:	00c00434 	movhi	r3,16
81122a34:	41400234 	orhi	r5,r8,8
81122a38:	18ffffc4 	addi	r3,r3,-1
81122a3c:	28ca703a 	and	r5,r5,r3
81122a40:	003f7e06 	br	8112283c <__reset+0xfb10283c>
81122a44:	10bfffc4 	addi	r2,r2,-1
81122a48:	1000491e 	bne	r2,zero,81122b70 <__subdf3+0x420>
81122a4c:	898fc83a 	sub	r7,r17,r6
81122a50:	89e3803a 	cmpltu	r17,r17,r7
81122a54:	1947c83a 	sub	r3,r3,r5
81122a58:	1c47c83a 	sub	r3,r3,r17
81122a5c:	3823883a 	mov	r17,r7
81122a60:	003f9b06 	br	811228d0 <__reset+0xfb1028d0>
81122a64:	2988b03a 	or	r4,r5,r6
81122a68:	203f5c26 	beq	r4,zero,811227dc <__reset+0xfb1027dc>
81122a6c:	10bfffc4 	addi	r2,r2,-1
81122a70:	1000931e 	bne	r2,zero,81122cc0 <__subdf3+0x570>
81122a74:	898d883a 	add	r6,r17,r6
81122a78:	3463803a 	cmpltu	r17,r6,r17
81122a7c:	1947883a 	add	r3,r3,r5
81122a80:	88c7883a 	add	r3,r17,r3
81122a84:	3023883a 	mov	r17,r6
81122a88:	003fd306 	br	811229d8 <__reset+0xfb1029d8>
81122a8c:	1000541e 	bne	r2,zero,81122be0 <__subdf3+0x490>
81122a90:	80800044 	addi	r2,r16,1
81122a94:	1081ffcc 	andi	r2,r2,2047
81122a98:	01000044 	movi	r4,1
81122a9c:	2080a20e 	bge	r4,r2,81122d28 <__subdf3+0x5d8>
81122aa0:	8989c83a 	sub	r4,r17,r6
81122aa4:	8905803a 	cmpltu	r2,r17,r4
81122aa8:	1967c83a 	sub	r19,r3,r5
81122aac:	98a7c83a 	sub	r19,r19,r2
81122ab0:	9880202c 	andhi	r2,r19,128
81122ab4:	10006326 	beq	r2,zero,81122c44 <__subdf3+0x4f4>
81122ab8:	3463c83a 	sub	r17,r6,r17
81122abc:	28c7c83a 	sub	r3,r5,r3
81122ac0:	344d803a 	cmpltu	r6,r6,r17
81122ac4:	19a7c83a 	sub	r19,r3,r6
81122ac8:	3825883a 	mov	r18,r7
81122acc:	983f861e 	bne	r19,zero,811228e8 <__reset+0xfb1028e8>
81122ad0:	8809883a 	mov	r4,r17
81122ad4:	11234780 	call	81123478 <__clzsi2>
81122ad8:	10800804 	addi	r2,r2,32
81122adc:	113ffe04 	addi	r4,r2,-8
81122ae0:	00c007c4 	movi	r3,31
81122ae4:	193f850e 	bge	r3,r4,811228fc <__reset+0xfb1028fc>
81122ae8:	10bff604 	addi	r2,r2,-40
81122aec:	8884983a 	sll	r2,r17,r2
81122af0:	0023883a 	mov	r17,zero
81122af4:	243f880e 	bge	r4,r16,81122918 <__reset+0xfb102918>
81122af8:	00ffe034 	movhi	r3,65408
81122afc:	18ffffc4 	addi	r3,r3,-1
81122b00:	8121c83a 	sub	r16,r16,r4
81122b04:	10c6703a 	and	r3,r2,r3
81122b08:	003f3406 	br	811227dc <__reset+0xfb1027dc>
81122b0c:	9100004c 	andi	r4,r18,1
81122b10:	000b883a 	mov	r5,zero
81122b14:	0005883a 	mov	r2,zero
81122b18:	003f4806 	br	8112283c <__reset+0xfb10283c>
81122b1c:	298cb03a 	or	r6,r5,r6
81122b20:	300cc03a 	cmpne	r6,r6,zero
81122b24:	0005883a 	mov	r2,zero
81122b28:	003f6406 	br	811228bc <__reset+0xfb1028bc>
81122b2c:	10009a1e 	bne	r2,zero,81122d98 <__subdf3+0x648>
81122b30:	82400044 	addi	r9,r16,1
81122b34:	4881ffcc 	andi	r2,r9,2047
81122b38:	02800044 	movi	r10,1
81122b3c:	5080670e 	bge	r10,r2,81122cdc <__subdf3+0x58c>
81122b40:	0081ffc4 	movi	r2,2047
81122b44:	4880af26 	beq	r9,r2,81122e04 <__subdf3+0x6b4>
81122b48:	898d883a 	add	r6,r17,r6
81122b4c:	1945883a 	add	r2,r3,r5
81122b50:	3447803a 	cmpltu	r3,r6,r17
81122b54:	1887883a 	add	r3,r3,r2
81122b58:	182297fa 	slli	r17,r3,31
81122b5c:	300cd07a 	srli	r6,r6,1
81122b60:	1806d07a 	srli	r3,r3,1
81122b64:	4821883a 	mov	r16,r9
81122b68:	89a2b03a 	or	r17,r17,r6
81122b6c:	003f1b06 	br	811227dc <__reset+0xfb1027dc>
81122b70:	0101ffc4 	movi	r4,2047
81122b74:	813f441e 	bne	r16,r4,81122888 <__reset+0xfb102888>
81122b78:	003f1806 	br	811227dc <__reset+0xfb1027dc>
81122b7c:	843ff844 	addi	r16,r16,-31
81122b80:	01400804 	movi	r5,32
81122b84:	1408d83a 	srl	r4,r2,r16
81122b88:	19405026 	beq	r3,r5,81122ccc <__subdf3+0x57c>
81122b8c:	01401004 	movi	r5,64
81122b90:	28c7c83a 	sub	r3,r5,r3
81122b94:	10c4983a 	sll	r2,r2,r3
81122b98:	88a2b03a 	or	r17,r17,r2
81122b9c:	8822c03a 	cmpne	r17,r17,zero
81122ba0:	2462b03a 	or	r17,r4,r17
81122ba4:	0007883a 	mov	r3,zero
81122ba8:	0021883a 	mov	r16,zero
81122bac:	003f6d06 	br	81122964 <__reset+0xfb102964>
81122bb0:	11fff804 	addi	r7,r2,-32
81122bb4:	01000804 	movi	r4,32
81122bb8:	29ced83a 	srl	r7,r5,r7
81122bbc:	11004526 	beq	r2,r4,81122cd4 <__subdf3+0x584>
81122bc0:	01001004 	movi	r4,64
81122bc4:	2089c83a 	sub	r4,r4,r2
81122bc8:	2904983a 	sll	r2,r5,r4
81122bcc:	118cb03a 	or	r6,r2,r6
81122bd0:	300cc03a 	cmpne	r6,r6,zero
81122bd4:	398cb03a 	or	r6,r7,r6
81122bd8:	0005883a 	mov	r2,zero
81122bdc:	003f3706 	br	811228bc <__reset+0xfb1028bc>
81122be0:	80002a26 	beq	r16,zero,81122c8c <__subdf3+0x53c>
81122be4:	0101ffc4 	movi	r4,2047
81122be8:	49006626 	beq	r9,r4,81122d84 <__subdf3+0x634>
81122bec:	0085c83a 	sub	r2,zero,r2
81122bf0:	18c02034 	orhi	r3,r3,128
81122bf4:	01000e04 	movi	r4,56
81122bf8:	20807e16 	blt	r4,r2,81122df4 <__subdf3+0x6a4>
81122bfc:	010007c4 	movi	r4,31
81122c00:	2080e716 	blt	r4,r2,81122fa0 <__subdf3+0x850>
81122c04:	01000804 	movi	r4,32
81122c08:	2089c83a 	sub	r4,r4,r2
81122c0c:	1914983a 	sll	r10,r3,r4
81122c10:	8890d83a 	srl	r8,r17,r2
81122c14:	8908983a 	sll	r4,r17,r4
81122c18:	1884d83a 	srl	r2,r3,r2
81122c1c:	5222b03a 	or	r17,r10,r8
81122c20:	2006c03a 	cmpne	r3,r4,zero
81122c24:	88e2b03a 	or	r17,r17,r3
81122c28:	3463c83a 	sub	r17,r6,r17
81122c2c:	2885c83a 	sub	r2,r5,r2
81122c30:	344d803a 	cmpltu	r6,r6,r17
81122c34:	1187c83a 	sub	r3,r2,r6
81122c38:	4821883a 	mov	r16,r9
81122c3c:	3825883a 	mov	r18,r7
81122c40:	003f2306 	br	811228d0 <__reset+0xfb1028d0>
81122c44:	24d0b03a 	or	r8,r4,r19
81122c48:	40001b1e 	bne	r8,zero,81122cb8 <__subdf3+0x568>
81122c4c:	0005883a 	mov	r2,zero
81122c50:	0009883a 	mov	r4,zero
81122c54:	0021883a 	mov	r16,zero
81122c58:	003f4906 	br	81122980 <__reset+0xfb102980>
81122c5c:	010007c4 	movi	r4,31
81122c60:	20803a16 	blt	r4,r2,81122d4c <__subdf3+0x5fc>
81122c64:	01000804 	movi	r4,32
81122c68:	2089c83a 	sub	r4,r4,r2
81122c6c:	2912983a 	sll	r9,r5,r4
81122c70:	3090d83a 	srl	r8,r6,r2
81122c74:	3108983a 	sll	r4,r6,r4
81122c78:	2884d83a 	srl	r2,r5,r2
81122c7c:	4a12b03a 	or	r9,r9,r8
81122c80:	2008c03a 	cmpne	r4,r4,zero
81122c84:	4912b03a 	or	r9,r9,r4
81122c88:	003f4e06 	br	811229c4 <__reset+0xfb1029c4>
81122c8c:	1c48b03a 	or	r4,r3,r17
81122c90:	20003c26 	beq	r4,zero,81122d84 <__subdf3+0x634>
81122c94:	0084303a 	nor	r2,zero,r2
81122c98:	1000381e 	bne	r2,zero,81122d7c <__subdf3+0x62c>
81122c9c:	3463c83a 	sub	r17,r6,r17
81122ca0:	28c5c83a 	sub	r2,r5,r3
81122ca4:	344d803a 	cmpltu	r6,r6,r17
81122ca8:	1187c83a 	sub	r3,r2,r6
81122cac:	4821883a 	mov	r16,r9
81122cb0:	3825883a 	mov	r18,r7
81122cb4:	003f0606 	br	811228d0 <__reset+0xfb1028d0>
81122cb8:	2023883a 	mov	r17,r4
81122cbc:	003f0906 	br	811228e4 <__reset+0xfb1028e4>
81122cc0:	0101ffc4 	movi	r4,2047
81122cc4:	813f3a1e 	bne	r16,r4,811229b0 <__reset+0xfb1029b0>
81122cc8:	003ec406 	br	811227dc <__reset+0xfb1027dc>
81122ccc:	0005883a 	mov	r2,zero
81122cd0:	003fb106 	br	81122b98 <__reset+0xfb102b98>
81122cd4:	0005883a 	mov	r2,zero
81122cd8:	003fbc06 	br	81122bcc <__reset+0xfb102bcc>
81122cdc:	1c44b03a 	or	r2,r3,r17
81122ce0:	80008e1e 	bne	r16,zero,81122f1c <__subdf3+0x7cc>
81122ce4:	1000c826 	beq	r2,zero,81123008 <__subdf3+0x8b8>
81122ce8:	2984b03a 	or	r2,r5,r6
81122cec:	103ebb26 	beq	r2,zero,811227dc <__reset+0xfb1027dc>
81122cf0:	8989883a 	add	r4,r17,r6
81122cf4:	1945883a 	add	r2,r3,r5
81122cf8:	2447803a 	cmpltu	r3,r4,r17
81122cfc:	1887883a 	add	r3,r3,r2
81122d00:	1880202c 	andhi	r2,r3,128
81122d04:	2023883a 	mov	r17,r4
81122d08:	103f1626 	beq	r2,zero,81122964 <__reset+0xfb102964>
81122d0c:	00bfe034 	movhi	r2,65408
81122d10:	10bfffc4 	addi	r2,r2,-1
81122d14:	5021883a 	mov	r16,r10
81122d18:	1886703a 	and	r3,r3,r2
81122d1c:	003eaf06 	br	811227dc <__reset+0xfb1027dc>
81122d20:	3825883a 	mov	r18,r7
81122d24:	003f0f06 	br	81122964 <__reset+0xfb102964>
81122d28:	1c44b03a 	or	r2,r3,r17
81122d2c:	8000251e 	bne	r16,zero,81122dc4 <__subdf3+0x674>
81122d30:	1000661e 	bne	r2,zero,81122ecc <__subdf3+0x77c>
81122d34:	2990b03a 	or	r8,r5,r6
81122d38:	40009626 	beq	r8,zero,81122f94 <__subdf3+0x844>
81122d3c:	2807883a 	mov	r3,r5
81122d40:	3023883a 	mov	r17,r6
81122d44:	3825883a 	mov	r18,r7
81122d48:	003ea406 	br	811227dc <__reset+0xfb1027dc>
81122d4c:	127ff804 	addi	r9,r2,-32
81122d50:	01000804 	movi	r4,32
81122d54:	2a52d83a 	srl	r9,r5,r9
81122d58:	11008c26 	beq	r2,r4,81122f8c <__subdf3+0x83c>
81122d5c:	01001004 	movi	r4,64
81122d60:	2085c83a 	sub	r2,r4,r2
81122d64:	2884983a 	sll	r2,r5,r2
81122d68:	118cb03a 	or	r6,r2,r6
81122d6c:	300cc03a 	cmpne	r6,r6,zero
81122d70:	4992b03a 	or	r9,r9,r6
81122d74:	0005883a 	mov	r2,zero
81122d78:	003f1206 	br	811229c4 <__reset+0xfb1029c4>
81122d7c:	0101ffc4 	movi	r4,2047
81122d80:	493f9c1e 	bne	r9,r4,81122bf4 <__reset+0xfb102bf4>
81122d84:	2807883a 	mov	r3,r5
81122d88:	3023883a 	mov	r17,r6
81122d8c:	4821883a 	mov	r16,r9
81122d90:	3825883a 	mov	r18,r7
81122d94:	003e9106 	br	811227dc <__reset+0xfb1027dc>
81122d98:	80001f1e 	bne	r16,zero,81122e18 <__subdf3+0x6c8>
81122d9c:	1c48b03a 	or	r4,r3,r17
81122da0:	20005a26 	beq	r4,zero,81122f0c <__subdf3+0x7bc>
81122da4:	0084303a 	nor	r2,zero,r2
81122da8:	1000561e 	bne	r2,zero,81122f04 <__subdf3+0x7b4>
81122dac:	89a3883a 	add	r17,r17,r6
81122db0:	1945883a 	add	r2,r3,r5
81122db4:	898d803a 	cmpltu	r6,r17,r6
81122db8:	3087883a 	add	r3,r6,r2
81122dbc:	4821883a 	mov	r16,r9
81122dc0:	003f0506 	br	811229d8 <__reset+0xfb1029d8>
81122dc4:	10002b1e 	bne	r2,zero,81122e74 <__subdf3+0x724>
81122dc8:	2984b03a 	or	r2,r5,r6
81122dcc:	10008026 	beq	r2,zero,81122fd0 <__subdf3+0x880>
81122dd0:	2807883a 	mov	r3,r5
81122dd4:	3023883a 	mov	r17,r6
81122dd8:	3825883a 	mov	r18,r7
81122ddc:	0401ffc4 	movi	r16,2047
81122de0:	003e7e06 	br	811227dc <__reset+0xfb1027dc>
81122de4:	3809883a 	mov	r4,r7
81122de8:	0011883a 	mov	r8,zero
81122dec:	0005883a 	mov	r2,zero
81122df0:	003ee306 	br	81122980 <__reset+0xfb102980>
81122df4:	1c62b03a 	or	r17,r3,r17
81122df8:	8822c03a 	cmpne	r17,r17,zero
81122dfc:	0005883a 	mov	r2,zero
81122e00:	003f8906 	br	81122c28 <__reset+0xfb102c28>
81122e04:	3809883a 	mov	r4,r7
81122e08:	4821883a 	mov	r16,r9
81122e0c:	0011883a 	mov	r8,zero
81122e10:	0005883a 	mov	r2,zero
81122e14:	003eda06 	br	81122980 <__reset+0xfb102980>
81122e18:	0101ffc4 	movi	r4,2047
81122e1c:	49003b26 	beq	r9,r4,81122f0c <__subdf3+0x7bc>
81122e20:	0085c83a 	sub	r2,zero,r2
81122e24:	18c02034 	orhi	r3,r3,128
81122e28:	01000e04 	movi	r4,56
81122e2c:	20806e16 	blt	r4,r2,81122fe8 <__subdf3+0x898>
81122e30:	010007c4 	movi	r4,31
81122e34:	20807716 	blt	r4,r2,81123014 <__subdf3+0x8c4>
81122e38:	01000804 	movi	r4,32
81122e3c:	2089c83a 	sub	r4,r4,r2
81122e40:	1914983a 	sll	r10,r3,r4
81122e44:	8890d83a 	srl	r8,r17,r2
81122e48:	8908983a 	sll	r4,r17,r4
81122e4c:	1884d83a 	srl	r2,r3,r2
81122e50:	5222b03a 	or	r17,r10,r8
81122e54:	2006c03a 	cmpne	r3,r4,zero
81122e58:	88e2b03a 	or	r17,r17,r3
81122e5c:	89a3883a 	add	r17,r17,r6
81122e60:	1145883a 	add	r2,r2,r5
81122e64:	898d803a 	cmpltu	r6,r17,r6
81122e68:	3087883a 	add	r3,r6,r2
81122e6c:	4821883a 	mov	r16,r9
81122e70:	003ed906 	br	811229d8 <__reset+0xfb1029d8>
81122e74:	2984b03a 	or	r2,r5,r6
81122e78:	10004226 	beq	r2,zero,81122f84 <__subdf3+0x834>
81122e7c:	1808d0fa 	srli	r4,r3,3
81122e80:	8822d0fa 	srli	r17,r17,3
81122e84:	1806977a 	slli	r3,r3,29
81122e88:	2080022c 	andhi	r2,r4,8
81122e8c:	1c62b03a 	or	r17,r3,r17
81122e90:	10000826 	beq	r2,zero,81122eb4 <__subdf3+0x764>
81122e94:	2812d0fa 	srli	r9,r5,3
81122e98:	4880022c 	andhi	r2,r9,8
81122e9c:	1000051e 	bne	r2,zero,81122eb4 <__subdf3+0x764>
81122ea0:	300cd0fa 	srli	r6,r6,3
81122ea4:	2804977a 	slli	r2,r5,29
81122ea8:	4809883a 	mov	r4,r9
81122eac:	3825883a 	mov	r18,r7
81122eb0:	11a2b03a 	or	r17,r2,r6
81122eb4:	8806d77a 	srli	r3,r17,29
81122eb8:	200890fa 	slli	r4,r4,3
81122ebc:	882290fa 	slli	r17,r17,3
81122ec0:	0401ffc4 	movi	r16,2047
81122ec4:	1906b03a 	or	r3,r3,r4
81122ec8:	003e4406 	br	811227dc <__reset+0xfb1027dc>
81122ecc:	2984b03a 	or	r2,r5,r6
81122ed0:	103e4226 	beq	r2,zero,811227dc <__reset+0xfb1027dc>
81122ed4:	8989c83a 	sub	r4,r17,r6
81122ed8:	8911803a 	cmpltu	r8,r17,r4
81122edc:	1945c83a 	sub	r2,r3,r5
81122ee0:	1205c83a 	sub	r2,r2,r8
81122ee4:	1200202c 	andhi	r8,r2,128
81122ee8:	403e9a26 	beq	r8,zero,81122954 <__reset+0xfb102954>
81122eec:	3463c83a 	sub	r17,r6,r17
81122ef0:	28c5c83a 	sub	r2,r5,r3
81122ef4:	344d803a 	cmpltu	r6,r6,r17
81122ef8:	1187c83a 	sub	r3,r2,r6
81122efc:	3825883a 	mov	r18,r7
81122f00:	003e3606 	br	811227dc <__reset+0xfb1027dc>
81122f04:	0101ffc4 	movi	r4,2047
81122f08:	493fc71e 	bne	r9,r4,81122e28 <__reset+0xfb102e28>
81122f0c:	2807883a 	mov	r3,r5
81122f10:	3023883a 	mov	r17,r6
81122f14:	4821883a 	mov	r16,r9
81122f18:	003e3006 	br	811227dc <__reset+0xfb1027dc>
81122f1c:	10003626 	beq	r2,zero,81122ff8 <__subdf3+0x8a8>
81122f20:	2984b03a 	or	r2,r5,r6
81122f24:	10001726 	beq	r2,zero,81122f84 <__subdf3+0x834>
81122f28:	1808d0fa 	srli	r4,r3,3
81122f2c:	8822d0fa 	srli	r17,r17,3
81122f30:	1806977a 	slli	r3,r3,29
81122f34:	2080022c 	andhi	r2,r4,8
81122f38:	1c62b03a 	or	r17,r3,r17
81122f3c:	10000726 	beq	r2,zero,81122f5c <__subdf3+0x80c>
81122f40:	2812d0fa 	srli	r9,r5,3
81122f44:	4880022c 	andhi	r2,r9,8
81122f48:	1000041e 	bne	r2,zero,81122f5c <__subdf3+0x80c>
81122f4c:	300cd0fa 	srli	r6,r6,3
81122f50:	2804977a 	slli	r2,r5,29
81122f54:	4809883a 	mov	r4,r9
81122f58:	11a2b03a 	or	r17,r2,r6
81122f5c:	8806d77a 	srli	r3,r17,29
81122f60:	200890fa 	slli	r4,r4,3
81122f64:	882290fa 	slli	r17,r17,3
81122f68:	3825883a 	mov	r18,r7
81122f6c:	1906b03a 	or	r3,r3,r4
81122f70:	0401ffc4 	movi	r16,2047
81122f74:	003e1906 	br	811227dc <__reset+0xfb1027dc>
81122f78:	000b883a 	mov	r5,zero
81122f7c:	0005883a 	mov	r2,zero
81122f80:	003e2e06 	br	8112283c <__reset+0xfb10283c>
81122f84:	0401ffc4 	movi	r16,2047
81122f88:	003e1406 	br	811227dc <__reset+0xfb1027dc>
81122f8c:	0005883a 	mov	r2,zero
81122f90:	003f7506 	br	81122d68 <__reset+0xfb102d68>
81122f94:	0005883a 	mov	r2,zero
81122f98:	0009883a 	mov	r4,zero
81122f9c:	003e7806 	br	81122980 <__reset+0xfb102980>
81122fa0:	123ff804 	addi	r8,r2,-32
81122fa4:	01000804 	movi	r4,32
81122fa8:	1a10d83a 	srl	r8,r3,r8
81122fac:	11002526 	beq	r2,r4,81123044 <__subdf3+0x8f4>
81122fb0:	01001004 	movi	r4,64
81122fb4:	2085c83a 	sub	r2,r4,r2
81122fb8:	1884983a 	sll	r2,r3,r2
81122fbc:	1444b03a 	or	r2,r2,r17
81122fc0:	1004c03a 	cmpne	r2,r2,zero
81122fc4:	40a2b03a 	or	r17,r8,r2
81122fc8:	0005883a 	mov	r2,zero
81122fcc:	003f1606 	br	81122c28 <__reset+0xfb102c28>
81122fd0:	02000434 	movhi	r8,16
81122fd4:	0009883a 	mov	r4,zero
81122fd8:	423fffc4 	addi	r8,r8,-1
81122fdc:	00bfffc4 	movi	r2,-1
81122fe0:	0401ffc4 	movi	r16,2047
81122fe4:	003e6606 	br	81122980 <__reset+0xfb102980>
81122fe8:	1c62b03a 	or	r17,r3,r17
81122fec:	8822c03a 	cmpne	r17,r17,zero
81122ff0:	0005883a 	mov	r2,zero
81122ff4:	003f9906 	br	81122e5c <__reset+0xfb102e5c>
81122ff8:	2807883a 	mov	r3,r5
81122ffc:	3023883a 	mov	r17,r6
81123000:	0401ffc4 	movi	r16,2047
81123004:	003df506 	br	811227dc <__reset+0xfb1027dc>
81123008:	2807883a 	mov	r3,r5
8112300c:	3023883a 	mov	r17,r6
81123010:	003df206 	br	811227dc <__reset+0xfb1027dc>
81123014:	123ff804 	addi	r8,r2,-32
81123018:	01000804 	movi	r4,32
8112301c:	1a10d83a 	srl	r8,r3,r8
81123020:	11000a26 	beq	r2,r4,8112304c <__subdf3+0x8fc>
81123024:	01001004 	movi	r4,64
81123028:	2085c83a 	sub	r2,r4,r2
8112302c:	1884983a 	sll	r2,r3,r2
81123030:	1444b03a 	or	r2,r2,r17
81123034:	1004c03a 	cmpne	r2,r2,zero
81123038:	40a2b03a 	or	r17,r8,r2
8112303c:	0005883a 	mov	r2,zero
81123040:	003f8606 	br	81122e5c <__reset+0xfb102e5c>
81123044:	0005883a 	mov	r2,zero
81123048:	003fdc06 	br	81122fbc <__reset+0xfb102fbc>
8112304c:	0005883a 	mov	r2,zero
81123050:	003ff706 	br	81123030 <__reset+0xfb103030>

81123054 <__fixdfsi>:
81123054:	280cd53a 	srli	r6,r5,20
81123058:	00c00434 	movhi	r3,16
8112305c:	18ffffc4 	addi	r3,r3,-1
81123060:	3181ffcc 	andi	r6,r6,2047
81123064:	01c0ff84 	movi	r7,1022
81123068:	28c6703a 	and	r3,r5,r3
8112306c:	280ad7fa 	srli	r5,r5,31
81123070:	3980120e 	bge	r7,r6,811230bc <__fixdfsi+0x68>
81123074:	00810744 	movi	r2,1053
81123078:	11800c16 	blt	r2,r6,811230ac <__fixdfsi+0x58>
8112307c:	00810cc4 	movi	r2,1075
81123080:	1185c83a 	sub	r2,r2,r6
81123084:	01c007c4 	movi	r7,31
81123088:	18c00434 	orhi	r3,r3,16
8112308c:	38800d16 	blt	r7,r2,811230c4 <__fixdfsi+0x70>
81123090:	31befb44 	addi	r6,r6,-1043
81123094:	2084d83a 	srl	r2,r4,r2
81123098:	1986983a 	sll	r3,r3,r6
8112309c:	1884b03a 	or	r2,r3,r2
811230a0:	28000726 	beq	r5,zero,811230c0 <__fixdfsi+0x6c>
811230a4:	0085c83a 	sub	r2,zero,r2
811230a8:	f800283a 	ret
811230ac:	00a00034 	movhi	r2,32768
811230b0:	10bfffc4 	addi	r2,r2,-1
811230b4:	2885883a 	add	r2,r5,r2
811230b8:	f800283a 	ret
811230bc:	0005883a 	mov	r2,zero
811230c0:	f800283a 	ret
811230c4:	008104c4 	movi	r2,1043
811230c8:	1185c83a 	sub	r2,r2,r6
811230cc:	1884d83a 	srl	r2,r3,r2
811230d0:	003ff306 	br	811230a0 <__reset+0xfb1030a0>

811230d4 <__floatsidf>:
811230d4:	defffd04 	addi	sp,sp,-12
811230d8:	de00012e 	bgeu	sp,et,811230e0 <__floatsidf+0xc>
811230dc:	003b68fa 	trap	3
811230e0:	dfc00215 	stw	ra,8(sp)
811230e4:	dc400115 	stw	r17,4(sp)
811230e8:	dc000015 	stw	r16,0(sp)
811230ec:	20002b26 	beq	r4,zero,8112319c <__floatsidf+0xc8>
811230f0:	2023883a 	mov	r17,r4
811230f4:	2020d7fa 	srli	r16,r4,31
811230f8:	20002d16 	blt	r4,zero,811231b0 <__floatsidf+0xdc>
811230fc:	8809883a 	mov	r4,r17
81123100:	11234780 	call	81123478 <__clzsi2>
81123104:	01410784 	movi	r5,1054
81123108:	288bc83a 	sub	r5,r5,r2
8112310c:	01010cc4 	movi	r4,1075
81123110:	2149c83a 	sub	r4,r4,r5
81123114:	00c007c4 	movi	r3,31
81123118:	1900160e 	bge	r3,r4,81123174 <__floatsidf+0xa0>
8112311c:	00c104c4 	movi	r3,1043
81123120:	1947c83a 	sub	r3,r3,r5
81123124:	88c6983a 	sll	r3,r17,r3
81123128:	00800434 	movhi	r2,16
8112312c:	10bfffc4 	addi	r2,r2,-1
81123130:	1886703a 	and	r3,r3,r2
81123134:	2941ffcc 	andi	r5,r5,2047
81123138:	800d883a 	mov	r6,r16
8112313c:	0005883a 	mov	r2,zero
81123140:	280a953a 	slli	r5,r5,20
81123144:	31803fcc 	andi	r6,r6,255
81123148:	01000434 	movhi	r4,16
8112314c:	300c97fa 	slli	r6,r6,31
81123150:	213fffc4 	addi	r4,r4,-1
81123154:	1906703a 	and	r3,r3,r4
81123158:	1946b03a 	or	r3,r3,r5
8112315c:	1986b03a 	or	r3,r3,r6
81123160:	dfc00217 	ldw	ra,8(sp)
81123164:	dc400117 	ldw	r17,4(sp)
81123168:	dc000017 	ldw	r16,0(sp)
8112316c:	dec00304 	addi	sp,sp,12
81123170:	f800283a 	ret
81123174:	00c002c4 	movi	r3,11
81123178:	1887c83a 	sub	r3,r3,r2
8112317c:	88c6d83a 	srl	r3,r17,r3
81123180:	8904983a 	sll	r2,r17,r4
81123184:	01000434 	movhi	r4,16
81123188:	213fffc4 	addi	r4,r4,-1
8112318c:	2941ffcc 	andi	r5,r5,2047
81123190:	1906703a 	and	r3,r3,r4
81123194:	800d883a 	mov	r6,r16
81123198:	003fe906 	br	81123140 <__reset+0xfb103140>
8112319c:	000d883a 	mov	r6,zero
811231a0:	000b883a 	mov	r5,zero
811231a4:	0007883a 	mov	r3,zero
811231a8:	0005883a 	mov	r2,zero
811231ac:	003fe406 	br	81123140 <__reset+0xfb103140>
811231b0:	0123c83a 	sub	r17,zero,r4
811231b4:	003fd106 	br	811230fc <__reset+0xfb1030fc>

811231b8 <__extendsfdf2>:
811231b8:	200ad5fa 	srli	r5,r4,23
811231bc:	defffd04 	addi	sp,sp,-12
811231c0:	de00012e 	bgeu	sp,et,811231c8 <__extendsfdf2+0x10>
811231c4:	003b68fa 	trap	3
811231c8:	29403fcc 	andi	r5,r5,255
811231cc:	dc400115 	stw	r17,4(sp)
811231d0:	29800044 	addi	r6,r5,1
811231d4:	04402034 	movhi	r17,128
811231d8:	dc000015 	stw	r16,0(sp)
811231dc:	8c7fffc4 	addi	r17,r17,-1
811231e0:	dfc00215 	stw	ra,8(sp)
811231e4:	31803fcc 	andi	r6,r6,255
811231e8:	00800044 	movi	r2,1
811231ec:	8922703a 	and	r17,r17,r4
811231f0:	2020d7fa 	srli	r16,r4,31
811231f4:	1180110e 	bge	r2,r6,8112323c <__extendsfdf2+0x84>
811231f8:	880cd0fa 	srli	r6,r17,3
811231fc:	8822977a 	slli	r17,r17,29
81123200:	2940e004 	addi	r5,r5,896
81123204:	2941ffcc 	andi	r5,r5,2047
81123208:	2804953a 	slli	r2,r5,20
8112320c:	01400434 	movhi	r5,16
81123210:	800697fa 	slli	r3,r16,31
81123214:	297fffc4 	addi	r5,r5,-1
81123218:	314a703a 	and	r5,r6,r5
8112321c:	288ab03a 	or	r5,r5,r2
81123220:	28c6b03a 	or	r3,r5,r3
81123224:	8805883a 	mov	r2,r17
81123228:	dfc00217 	ldw	ra,8(sp)
8112322c:	dc400117 	ldw	r17,4(sp)
81123230:	dc000017 	ldw	r16,0(sp)
81123234:	dec00304 	addi	sp,sp,12
81123238:	f800283a 	ret
8112323c:	2800111e 	bne	r5,zero,81123284 <__extendsfdf2+0xcc>
81123240:	88001c26 	beq	r17,zero,811232b4 <__extendsfdf2+0xfc>
81123244:	8809883a 	mov	r4,r17
81123248:	11234780 	call	81123478 <__clzsi2>
8112324c:	00c00284 	movi	r3,10
81123250:	18801b16 	blt	r3,r2,811232c0 <__extendsfdf2+0x108>
81123254:	018002c4 	movi	r6,11
81123258:	308dc83a 	sub	r6,r6,r2
8112325c:	11000544 	addi	r4,r2,21
81123260:	8986d83a 	srl	r3,r17,r6
81123264:	8922983a 	sll	r17,r17,r4
81123268:	0180e244 	movi	r6,905
8112326c:	01400434 	movhi	r5,16
81123270:	3085c83a 	sub	r2,r6,r2
81123274:	297fffc4 	addi	r5,r5,-1
81123278:	194c703a 	and	r6,r3,r5
8112327c:	1141ffcc 	andi	r5,r2,2047
81123280:	003fe006 	br	81123204 <__reset+0xfb103204>
81123284:	88000826 	beq	r17,zero,811232a8 <__extendsfdf2+0xf0>
81123288:	880cd0fa 	srli	r6,r17,3
8112328c:	00800434 	movhi	r2,16
81123290:	10bfffc4 	addi	r2,r2,-1
81123294:	31800234 	orhi	r6,r6,8
81123298:	8822977a 	slli	r17,r17,29
8112329c:	308c703a 	and	r6,r6,r2
811232a0:	0141ffc4 	movi	r5,2047
811232a4:	003fd706 	br	81123204 <__reset+0xfb103204>
811232a8:	0141ffc4 	movi	r5,2047
811232ac:	000d883a 	mov	r6,zero
811232b0:	003fd406 	br	81123204 <__reset+0xfb103204>
811232b4:	000b883a 	mov	r5,zero
811232b8:	000d883a 	mov	r6,zero
811232bc:	003fd106 	br	81123204 <__reset+0xfb103204>
811232c0:	11bffd44 	addi	r6,r2,-11
811232c4:	8986983a 	sll	r3,r17,r6
811232c8:	0023883a 	mov	r17,zero
811232cc:	003fe606 	br	81123268 <__reset+0xfb103268>

811232d0 <__truncdfsf2>:
811232d0:	2810d53a 	srli	r8,r5,20
811232d4:	01c00434 	movhi	r7,16
811232d8:	39ffffc4 	addi	r7,r7,-1
811232dc:	29ce703a 	and	r7,r5,r7
811232e0:	4201ffcc 	andi	r8,r8,2047
811232e4:	380e90fa 	slli	r7,r7,3
811232e8:	200cd77a 	srli	r6,r4,29
811232ec:	42400044 	addi	r9,r8,1
811232f0:	4a41ffcc 	andi	r9,r9,2047
811232f4:	00c00044 	movi	r3,1
811232f8:	280ad7fa 	srli	r5,r5,31
811232fc:	31ceb03a 	or	r7,r6,r7
81123300:	200490fa 	slli	r2,r4,3
81123304:	1a40230e 	bge	r3,r9,81123394 <__truncdfsf2+0xc4>
81123308:	40ff2004 	addi	r3,r8,-896
8112330c:	01803f84 	movi	r6,254
81123310:	30c01516 	blt	r6,r3,81123368 <__truncdfsf2+0x98>
81123314:	00c0380e 	bge	zero,r3,811233f8 <__truncdfsf2+0x128>
81123318:	200c91ba 	slli	r6,r4,6
8112331c:	380e90fa 	slli	r7,r7,3
81123320:	1004d77a 	srli	r2,r2,29
81123324:	300cc03a 	cmpne	r6,r6,zero
81123328:	31ccb03a 	or	r6,r6,r7
8112332c:	308cb03a 	or	r6,r6,r2
81123330:	308001cc 	andi	r2,r6,7
81123334:	10000426 	beq	r2,zero,81123348 <__truncdfsf2+0x78>
81123338:	308003cc 	andi	r2,r6,15
8112333c:	01000104 	movi	r4,4
81123340:	11000126 	beq	r2,r4,81123348 <__truncdfsf2+0x78>
81123344:	31800104 	addi	r6,r6,4
81123348:	3081002c 	andhi	r2,r6,1024
8112334c:	10001626 	beq	r2,zero,811233a8 <__truncdfsf2+0xd8>
81123350:	18c00044 	addi	r3,r3,1
81123354:	00803fc4 	movi	r2,255
81123358:	18800326 	beq	r3,r2,81123368 <__truncdfsf2+0x98>
8112335c:	300c91ba 	slli	r6,r6,6
81123360:	300cd27a 	srli	r6,r6,9
81123364:	00000206 	br	81123370 <__truncdfsf2+0xa0>
81123368:	00ffffc4 	movi	r3,-1
8112336c:	000d883a 	mov	r6,zero
81123370:	18c03fcc 	andi	r3,r3,255
81123374:	180895fa 	slli	r4,r3,23
81123378:	00c02034 	movhi	r3,128
8112337c:	280a97fa 	slli	r5,r5,31
81123380:	18ffffc4 	addi	r3,r3,-1
81123384:	30c6703a 	and	r3,r6,r3
81123388:	1906b03a 	or	r3,r3,r4
8112338c:	1944b03a 	or	r2,r3,r5
81123390:	f800283a 	ret
81123394:	40000b1e 	bne	r8,zero,811233c4 <__truncdfsf2+0xf4>
81123398:	388cb03a 	or	r6,r7,r2
8112339c:	0007883a 	mov	r3,zero
811233a0:	30000426 	beq	r6,zero,811233b4 <__truncdfsf2+0xe4>
811233a4:	01800144 	movi	r6,5
811233a8:	00803fc4 	movi	r2,255
811233ac:	300cd0fa 	srli	r6,r6,3
811233b0:	18800a26 	beq	r3,r2,811233dc <__truncdfsf2+0x10c>
811233b4:	00802034 	movhi	r2,128
811233b8:	10bfffc4 	addi	r2,r2,-1
811233bc:	308c703a 	and	r6,r6,r2
811233c0:	003feb06 	br	81123370 <__reset+0xfb103370>
811233c4:	3888b03a 	or	r4,r7,r2
811233c8:	203fe726 	beq	r4,zero,81123368 <__reset+0xfb103368>
811233cc:	380c90fa 	slli	r6,r7,3
811233d0:	00c03fc4 	movi	r3,255
811233d4:	31808034 	orhi	r6,r6,512
811233d8:	003fd506 	br	81123330 <__reset+0xfb103330>
811233dc:	303fe226 	beq	r6,zero,81123368 <__reset+0xfb103368>
811233e0:	00802034 	movhi	r2,128
811233e4:	31801034 	orhi	r6,r6,64
811233e8:	10bfffc4 	addi	r2,r2,-1
811233ec:	00ffffc4 	movi	r3,-1
811233f0:	308c703a 	and	r6,r6,r2
811233f4:	003fde06 	br	81123370 <__reset+0xfb103370>
811233f8:	013ffa44 	movi	r4,-23
811233fc:	19000e16 	blt	r3,r4,81123438 <__truncdfsf2+0x168>
81123400:	01000784 	movi	r4,30
81123404:	20c9c83a 	sub	r4,r4,r3
81123408:	018007c4 	movi	r6,31
8112340c:	39c02034 	orhi	r7,r7,128
81123410:	31000b16 	blt	r6,r4,81123440 <__truncdfsf2+0x170>
81123414:	423f2084 	addi	r8,r8,-894
81123418:	120c983a 	sll	r6,r2,r8
8112341c:	3a0e983a 	sll	r7,r7,r8
81123420:	1104d83a 	srl	r2,r2,r4
81123424:	300cc03a 	cmpne	r6,r6,zero
81123428:	31ceb03a 	or	r7,r6,r7
8112342c:	388cb03a 	or	r6,r7,r2
81123430:	0007883a 	mov	r3,zero
81123434:	003fbe06 	br	81123330 <__reset+0xfb103330>
81123438:	0007883a 	mov	r3,zero
8112343c:	003fd906 	br	811233a4 <__reset+0xfb1033a4>
81123440:	01bfff84 	movi	r6,-2
81123444:	30cdc83a 	sub	r6,r6,r3
81123448:	00c00804 	movi	r3,32
8112344c:	398cd83a 	srl	r6,r7,r6
81123450:	20c00726 	beq	r4,r3,81123470 <__truncdfsf2+0x1a0>
81123454:	423f2884 	addi	r8,r8,-862
81123458:	3a0e983a 	sll	r7,r7,r8
8112345c:	3884b03a 	or	r2,r7,r2
81123460:	1004c03a 	cmpne	r2,r2,zero
81123464:	118cb03a 	or	r6,r2,r6
81123468:	0007883a 	mov	r3,zero
8112346c:	003fb006 	br	81123330 <__reset+0xfb103330>
81123470:	000f883a 	mov	r7,zero
81123474:	003ff906 	br	8112345c <__reset+0xfb10345c>

81123478 <__clzsi2>:
81123478:	00bfffd4 	movui	r2,65535
8112347c:	11000536 	bltu	r2,r4,81123494 <__clzsi2+0x1c>
81123480:	00803fc4 	movi	r2,255
81123484:	11000f36 	bltu	r2,r4,811234c4 <__clzsi2+0x4c>
81123488:	00800804 	movi	r2,32
8112348c:	0007883a 	mov	r3,zero
81123490:	00000506 	br	811234a8 <__clzsi2+0x30>
81123494:	00804034 	movhi	r2,256
81123498:	10bfffc4 	addi	r2,r2,-1
8112349c:	11000c2e 	bgeu	r2,r4,811234d0 <__clzsi2+0x58>
811234a0:	00800204 	movi	r2,8
811234a4:	00c00604 	movi	r3,24
811234a8:	20c8d83a 	srl	r4,r4,r3
811234ac:	00e04574 	movhi	r3,33045
811234b0:	18c9a104 	addi	r3,r3,9860
811234b4:	1909883a 	add	r4,r3,r4
811234b8:	20c00003 	ldbu	r3,0(r4)
811234bc:	10c5c83a 	sub	r2,r2,r3
811234c0:	f800283a 	ret
811234c4:	00800604 	movi	r2,24
811234c8:	00c00204 	movi	r3,8
811234cc:	003ff606 	br	811234a8 <__reset+0xfb1034a8>
811234d0:	00800404 	movi	r2,16
811234d4:	1007883a 	mov	r3,r2
811234d8:	003ff306 	br	811234a8 <__reset+0xfb1034a8>

811234dc <atoi>:
811234dc:	01800284 	movi	r6,10
811234e0:	000b883a 	mov	r5,zero
811234e4:	11254941 	jmpi	81125494 <strtol>

811234e8 <_atoi_r>:
811234e8:	01c00284 	movi	r7,10
811234ec:	000d883a 	mov	r6,zero
811234f0:	11252541 	jmpi	81125254 <_strtol_r>

811234f4 <atoll>:
811234f4:	01800284 	movi	r6,10
811234f8:	000b883a 	mov	r5,zero
811234fc:	11254b01 	jmpi	811254b0 <strtoll>

81123500 <_atoll_r>:
81123500:	01c00284 	movi	r7,10
81123504:	000d883a 	mov	r6,zero
81123508:	11254cc1 	jmpi	811254cc <_strtoll_r>

8112350c <_fopen_r>:
8112350c:	defffa04 	addi	sp,sp,-24
81123510:	3005883a 	mov	r2,r6
81123514:	de00012e 	bgeu	sp,et,8112351c <_fopen_r+0x10>
81123518:	003b68fa 	trap	3
8112351c:	d80d883a 	mov	r6,sp
81123520:	dcc00415 	stw	r19,16(sp)
81123524:	2827883a 	mov	r19,r5
81123528:	100b883a 	mov	r5,r2
8112352c:	dc800315 	stw	r18,12(sp)
81123530:	dfc00515 	stw	ra,20(sp)
81123534:	dc400215 	stw	r17,8(sp)
81123538:	dc000115 	stw	r16,4(sp)
8112353c:	2025883a 	mov	r18,r4
81123540:	112d7a00 	call	8112d7a0 <__sflags>
81123544:	10002726 	beq	r2,zero,811235e4 <_fopen_r+0xd8>
81123548:	9009883a 	mov	r4,r18
8112354c:	1023883a 	mov	r17,r2
81123550:	112d6180 	call	8112d618 <__sfp>
81123554:	1021883a 	mov	r16,r2
81123558:	10002226 	beq	r2,zero,811235e4 <_fopen_r+0xd8>
8112355c:	d9800017 	ldw	r6,0(sp)
81123560:	01c06d84 	movi	r7,438
81123564:	980b883a 	mov	r5,r19
81123568:	9009883a 	mov	r4,r18
8112356c:	11249780 	call	81124978 <_open_r>
81123570:	10001916 	blt	r2,zero,811235d8 <_fopen_r+0xcc>
81123574:	8080038d 	sth	r2,14(r16)
81123578:	00a044b4 	movhi	r2,33042
8112357c:	1093f604 	addi	r2,r2,20440
81123580:	80800815 	stw	r2,32(r16)
81123584:	00a044b4 	movhi	r2,33042
81123588:	10940f04 	addi	r2,r2,20540
8112358c:	80800915 	stw	r2,36(r16)
81123590:	00a044b4 	movhi	r2,33042
81123594:	10943004 	addi	r2,r2,20672
81123598:	80800a15 	stw	r2,40(r16)
8112359c:	00a044b4 	movhi	r2,33042
811235a0:	10944904 	addi	r2,r2,20772
811235a4:	8440030d 	sth	r17,12(r16)
811235a8:	84000715 	stw	r16,28(r16)
811235ac:	80800b15 	stw	r2,44(r16)
811235b0:	8c40400c 	andi	r17,r17,256
811235b4:	88000d1e 	bne	r17,zero,811235ec <_fopen_r+0xe0>
811235b8:	8005883a 	mov	r2,r16
811235bc:	dfc00517 	ldw	ra,20(sp)
811235c0:	dcc00417 	ldw	r19,16(sp)
811235c4:	dc800317 	ldw	r18,12(sp)
811235c8:	dc400217 	ldw	r17,8(sp)
811235cc:	dc000117 	ldw	r16,4(sp)
811235d0:	dec00604 	addi	sp,sp,24
811235d4:	f800283a 	ret
811235d8:	112d7600 	call	8112d760 <__sfp_lock_acquire>
811235dc:	8000030d 	sth	zero,12(r16)
811235e0:	112d7640 	call	8112d764 <__sfp_lock_release>
811235e4:	0005883a 	mov	r2,zero
811235e8:	003ff406 	br	811235bc <__reset+0xfb1035bc>
811235ec:	01c00084 	movi	r7,2
811235f0:	000d883a 	mov	r6,zero
811235f4:	800b883a 	mov	r5,r16
811235f8:	9009883a 	mov	r4,r18
811235fc:	112372c0 	call	8112372c <_fseek_r>
81123600:	8005883a 	mov	r2,r16
81123604:	003fed06 	br	811235bc <__reset+0xfb1035bc>

81123608 <fopen>:
81123608:	00a04574 	movhi	r2,33045
8112360c:	10945c04 	addi	r2,r2,20848
81123610:	280d883a 	mov	r6,r5
81123614:	200b883a 	mov	r5,r4
81123618:	11000017 	ldw	r4,0(r2)
8112361c:	112350c1 	jmpi	8112350c <_fopen_r>

81123620 <_fprintf_r>:
81123620:	defffe04 	addi	sp,sp,-8
81123624:	2809883a 	mov	r4,r5
81123628:	300b883a 	mov	r5,r6
8112362c:	de00012e 	bgeu	sp,et,81123634 <_fprintf_r+0x14>
81123630:	003b68fa 	trap	3
81123634:	dfc00015 	stw	ra,0(sp)
81123638:	d9c00115 	stw	r7,4(sp)
8112363c:	d9800104 	addi	r6,sp,4
81123640:	1129b940 	call	81129b94 <__vfprintf_internal>
81123644:	dfc00017 	ldw	ra,0(sp)
81123648:	dec00204 	addi	sp,sp,8
8112364c:	f800283a 	ret

81123650 <fprintf>:
81123650:	defffd04 	addi	sp,sp,-12
81123654:	de00012e 	bgeu	sp,et,8112365c <fprintf+0xc>
81123658:	003b68fa 	trap	3
8112365c:	dfc00015 	stw	ra,0(sp)
81123660:	d9800115 	stw	r6,4(sp)
81123664:	d9c00215 	stw	r7,8(sp)
81123668:	d9800104 	addi	r6,sp,4
8112366c:	1129b940 	call	81129b94 <__vfprintf_internal>
81123670:	dfc00017 	ldw	ra,0(sp)
81123674:	dec00304 	addi	sp,sp,12
81123678:	f800283a 	ret

8112367c <_fputc_r>:
8112367c:	defffc04 	addi	sp,sp,-16
81123680:	de00012e 	bgeu	sp,et,81123688 <_fputc_r+0xc>
81123684:	003b68fa 	trap	3
81123688:	dc000215 	stw	r16,8(sp)
8112368c:	dfc00315 	stw	ra,12(sp)
81123690:	2021883a 	mov	r16,r4
81123694:	20000726 	beq	r4,zero,811236b4 <_fputc_r+0x38>
81123698:	20800e17 	ldw	r2,56(r4)
8112369c:	1000051e 	bne	r2,zero,811236b4 <_fputc_r+0x38>
811236a0:	d9400015 	stw	r5,0(sp)
811236a4:	d9800115 	stw	r6,4(sp)
811236a8:	112d7500 	call	8112d750 <__sinit>
811236ac:	d9800117 	ldw	r6,4(sp)
811236b0:	d9400017 	ldw	r5,0(sp)
811236b4:	8009883a 	mov	r4,r16
811236b8:	dfc00317 	ldw	ra,12(sp)
811236bc:	dc000217 	ldw	r16,8(sp)
811236c0:	dec00404 	addi	sp,sp,16
811236c4:	11249e01 	jmpi	811249e0 <_putc_r>

811236c8 <fputc>:
811236c8:	00a04574 	movhi	r2,33045
811236cc:	defffc04 	addi	sp,sp,-16
811236d0:	10945c04 	addi	r2,r2,20848
811236d4:	de00012e 	bgeu	sp,et,811236dc <fputc+0x14>
811236d8:	003b68fa 	trap	3
811236dc:	dc000115 	stw	r16,4(sp)
811236e0:	14000017 	ldw	r16,0(r2)
811236e4:	dc400215 	stw	r17,8(sp)
811236e8:	dfc00315 	stw	ra,12(sp)
811236ec:	2023883a 	mov	r17,r4
811236f0:	80000626 	beq	r16,zero,8112370c <fputc+0x44>
811236f4:	80800e17 	ldw	r2,56(r16)
811236f8:	1000041e 	bne	r2,zero,8112370c <fputc+0x44>
811236fc:	8009883a 	mov	r4,r16
81123700:	d9400015 	stw	r5,0(sp)
81123704:	112d7500 	call	8112d750 <__sinit>
81123708:	d9400017 	ldw	r5,0(sp)
8112370c:	280d883a 	mov	r6,r5
81123710:	8009883a 	mov	r4,r16
81123714:	880b883a 	mov	r5,r17
81123718:	dfc00317 	ldw	ra,12(sp)
8112371c:	dc400217 	ldw	r17,8(sp)
81123720:	dc000117 	ldw	r16,4(sp)
81123724:	dec00404 	addi	sp,sp,16
81123728:	11249e01 	jmpi	811249e0 <_putc_r>

8112372c <_fseek_r>:
8112372c:	112374c1 	jmpi	8112374c <_fseeko_r>

81123730 <fseek>:
81123730:	00a04574 	movhi	r2,33045
81123734:	10945c04 	addi	r2,r2,20848
81123738:	300f883a 	mov	r7,r6
8112373c:	280d883a 	mov	r6,r5
81123740:	200b883a 	mov	r5,r4
81123744:	11000017 	ldw	r4,0(r2)
81123748:	112374c1 	jmpi	8112374c <_fseeko_r>

8112374c <_fseeko_r>:
8112374c:	deffe804 	addi	sp,sp,-96
81123750:	de00012e 	bgeu	sp,et,81123758 <_fseeko_r+0xc>
81123754:	003b68fa 	trap	3
81123758:	dd401415 	stw	r21,80(sp)
8112375c:	dc801115 	stw	r18,68(sp)
81123760:	dc401015 	stw	r17,64(sp)
81123764:	dc000f15 	stw	r16,60(sp)
81123768:	dfc01715 	stw	ra,92(sp)
8112376c:	ddc01615 	stw	r23,88(sp)
81123770:	dd801515 	stw	r22,84(sp)
81123774:	dd001315 	stw	r20,76(sp)
81123778:	dcc01215 	stw	r19,72(sp)
8112377c:	2023883a 	mov	r17,r4
81123780:	2821883a 	mov	r16,r5
81123784:	302b883a 	mov	r21,r6
81123788:	3825883a 	mov	r18,r7
8112378c:	20000226 	beq	r4,zero,81123798 <_fseeko_r+0x4c>
81123790:	20800e17 	ldw	r2,56(r4)
81123794:	10005a26 	beq	r2,zero,81123900 <_fseeko_r+0x1b4>
81123798:	8080030b 	ldhu	r2,12(r16)
8112379c:	00c04204 	movi	r3,264
811237a0:	1080420c 	andi	r2,r2,264
811237a4:	10c05b26 	beq	r2,r3,81123914 <_fseeko_r+0x1c8>
811237a8:	85000a17 	ldw	r20,40(r16)
811237ac:	a000f626 	beq	r20,zero,81123b88 <_fseeko_r+0x43c>
811237b0:	00800044 	movi	r2,1
811237b4:	90803e26 	beq	r18,r2,811238b0 <_fseeko_r+0x164>
811237b8:	00800084 	movi	r2,2
811237bc:	90801026 	beq	r18,r2,81123800 <_fseeko_r+0xb4>
811237c0:	90000f26 	beq	r18,zero,81123800 <_fseeko_r+0xb4>
811237c4:	00800584 	movi	r2,22
811237c8:	88800015 	stw	r2,0(r17)
811237cc:	04ffffc4 	movi	r19,-1
811237d0:	9805883a 	mov	r2,r19
811237d4:	dfc01717 	ldw	ra,92(sp)
811237d8:	ddc01617 	ldw	r23,88(sp)
811237dc:	dd801517 	ldw	r22,84(sp)
811237e0:	dd401417 	ldw	r21,80(sp)
811237e4:	dd001317 	ldw	r20,76(sp)
811237e8:	dcc01217 	ldw	r19,72(sp)
811237ec:	dc801117 	ldw	r18,68(sp)
811237f0:	dc401017 	ldw	r17,64(sp)
811237f4:	dc000f17 	ldw	r16,60(sp)
811237f8:	dec01804 	addi	sp,sp,96
811237fc:	f800283a 	ret
81123800:	80800417 	ldw	r2,16(r16)
81123804:	002f883a 	mov	r23,zero
81123808:	0027883a 	mov	r19,zero
8112380c:	1000cb26 	beq	r2,zero,81123b3c <_fseeko_r+0x3f0>
81123810:	8080030b 	ldhu	r2,12(r16)
81123814:	10c2068c 	andi	r3,r2,2074
81123818:	1800071e 	bne	r3,zero,81123838 <_fseeko_r+0xec>
8112381c:	10c1000c 	andi	r3,r2,1024
81123820:	1800451e 	bne	r3,zero,81123938 <_fseeko_r+0x1ec>
81123824:	00e044b4 	movhi	r3,33042
81123828:	18d43004 	addi	r3,r3,20672
8112382c:	a0c0b726 	beq	r20,r3,81123b0c <_fseeko_r+0x3c0>
81123830:	10820014 	ori	r2,r2,2048
81123834:	8080030d 	sth	r2,12(r16)
81123838:	800b883a 	mov	r5,r16
8112383c:	8809883a 	mov	r4,r17
81123840:	112d3540 	call	8112d354 <_fflush_r>
81123844:	1027883a 	mov	r19,r2
81123848:	103fe01e 	bne	r2,zero,811237cc <__reset+0xfb1037cc>
8112384c:	81400717 	ldw	r5,28(r16)
81123850:	900f883a 	mov	r7,r18
81123854:	a80d883a 	mov	r6,r21
81123858:	8809883a 	mov	r4,r17
8112385c:	a03ee83a 	callr	r20
81123860:	00ffffc4 	movi	r3,-1
81123864:	10ffd926 	beq	r2,r3,811237cc <__reset+0xfb1037cc>
81123868:	81400c17 	ldw	r5,48(r16)
8112386c:	28000526 	beq	r5,zero,81123884 <_fseeko_r+0x138>
81123870:	80801004 	addi	r2,r16,64
81123874:	28800226 	beq	r5,r2,81123880 <_fseeko_r+0x134>
81123878:	8809883a 	mov	r4,r17
8112387c:	112dbe80 	call	8112dbe8 <_free_r>
81123880:	80000c15 	stw	zero,48(r16)
81123884:	8080030b 	ldhu	r2,12(r16)
81123888:	80c00417 	ldw	r3,16(r16)
8112388c:	80000115 	stw	zero,4(r16)
81123890:	10bdf7cc 	andi	r2,r2,63455
81123894:	80c00015 	stw	r3,0(r16)
81123898:	8080030d 	sth	r2,12(r16)
8112389c:	01800204 	movi	r6,8
811238a0:	000b883a 	mov	r5,zero
811238a4:	81001704 	addi	r4,r16,92
811238a8:	11248500 	call	81124850 <memset>
811238ac:	003fc806 	br	811237d0 <__reset+0xfb1037d0>
811238b0:	800b883a 	mov	r5,r16
811238b4:	8809883a 	mov	r4,r17
811238b8:	112d3540 	call	8112d354 <_fflush_r>
811238bc:	8080030b 	ldhu	r2,12(r16)
811238c0:	10c4000c 	andi	r3,r2,4096
811238c4:	18008726 	beq	r3,zero,81123ae4 <_fseeko_r+0x398>
811238c8:	84c01417 	ldw	r19,80(r16)
811238cc:	10c0010c 	andi	r3,r2,4
811238d0:	1800431e 	bne	r3,zero,811239e0 <_fseeko_r+0x294>
811238d4:	1080020c 	andi	r2,r2,8
811238d8:	10008026 	beq	r2,zero,81123adc <_fseeko_r+0x390>
811238dc:	80c00017 	ldw	r3,0(r16)
811238e0:	80800417 	ldw	r2,16(r16)
811238e4:	18000226 	beq	r3,zero,811238f0 <_fseeko_r+0x1a4>
811238e8:	1887c83a 	sub	r3,r3,r2
811238ec:	98e7883a 	add	r19,r19,r3
811238f0:	aceb883a 	add	r21,r21,r19
811238f4:	05c00044 	movi	r23,1
811238f8:	0025883a 	mov	r18,zero
811238fc:	003fc306 	br	8112380c <__reset+0xfb10380c>
81123900:	112d7500 	call	8112d750 <__sinit>
81123904:	8080030b 	ldhu	r2,12(r16)
81123908:	00c04204 	movi	r3,264
8112390c:	1080420c 	andi	r2,r2,264
81123910:	10ffa51e 	bne	r2,r3,811237a8 <__reset+0xfb1037a8>
81123914:	800b883a 	mov	r5,r16
81123918:	8809883a 	mov	r4,r17
8112391c:	112d3540 	call	8112d354 <_fflush_r>
81123920:	003fa106 	br	811237a8 <__reset+0xfb1037a8>
81123924:	8080030b 	ldhu	r2,12(r16)
81123928:	00c10004 	movi	r3,1024
8112392c:	80c01315 	stw	r3,76(r16)
81123930:	10c4b03a 	or	r2,r2,r3
81123934:	8080030d 	sth	r2,12(r16)
81123938:	9000311e 	bne	r18,zero,81123a00 <_fseeko_r+0x2b4>
8112393c:	a82d883a 	mov	r22,r21
81123940:	b800371e 	bne	r23,zero,81123a20 <_fseeko_r+0x2d4>
81123944:	8080030b 	ldhu	r2,12(r16)
81123948:	1084000c 	andi	r2,r2,4096
8112394c:	10007f26 	beq	r2,zero,81123b4c <_fseeko_r+0x400>
81123950:	80801417 	ldw	r2,80(r16)
81123954:	81800117 	ldw	r6,4(r16)
81123958:	81400c17 	ldw	r5,48(r16)
8112395c:	11a7c83a 	sub	r19,r2,r6
81123960:	28008226 	beq	r5,zero,81123b6c <_fseeko_r+0x420>
81123964:	81c00f17 	ldw	r7,60(r16)
81123968:	99e7c83a 	sub	r19,r19,r7
8112396c:	81000e17 	ldw	r4,56(r16)
81123970:	80800417 	ldw	r2,16(r16)
81123974:	99a7883a 	add	r19,r19,r6
81123978:	2087c83a 	sub	r3,r4,r2
8112397c:	98e7c83a 	sub	r19,r19,r3
81123980:	38c7883a 	add	r3,r7,r3
81123984:	b4c02b16 	blt	r22,r19,81123a34 <_fseeko_r+0x2e8>
81123988:	98c9883a 	add	r4,r19,r3
8112398c:	b100292e 	bgeu	r22,r4,81123a34 <_fseeko_r+0x2e8>
81123990:	b4e7c83a 	sub	r19,r22,r19
81123994:	14c5883a 	add	r2,r2,r19
81123998:	1ce7c83a 	sub	r19,r3,r19
8112399c:	80800015 	stw	r2,0(r16)
811239a0:	84c00115 	stw	r19,4(r16)
811239a4:	28000526 	beq	r5,zero,811239bc <_fseeko_r+0x270>
811239a8:	80801004 	addi	r2,r16,64
811239ac:	28800226 	beq	r5,r2,811239b8 <_fseeko_r+0x26c>
811239b0:	8809883a 	mov	r4,r17
811239b4:	112dbe80 	call	8112dbe8 <_free_r>
811239b8:	80000c15 	stw	zero,48(r16)
811239bc:	8080030b 	ldhu	r2,12(r16)
811239c0:	01800204 	movi	r6,8
811239c4:	000b883a 	mov	r5,zero
811239c8:	10bff7cc 	andi	r2,r2,65503
811239cc:	8080030d 	sth	r2,12(r16)
811239d0:	81001704 	addi	r4,r16,92
811239d4:	11248500 	call	81124850 <memset>
811239d8:	0027883a 	mov	r19,zero
811239dc:	003f7c06 	br	811237d0 <__reset+0xfb1037d0>
811239e0:	80c00117 	ldw	r3,4(r16)
811239e4:	80800c17 	ldw	r2,48(r16)
811239e8:	98e7c83a 	sub	r19,r19,r3
811239ec:	10003b26 	beq	r2,zero,81123adc <_fseeko_r+0x390>
811239f0:	80c00f17 	ldw	r3,60(r16)
811239f4:	80800417 	ldw	r2,16(r16)
811239f8:	98e7c83a 	sub	r19,r19,r3
811239fc:	003fbc06 	br	811238f0 <__reset+0xfb1038f0>
81123a00:	8140038f 	ldh	r5,14(r16)
81123a04:	d80d883a 	mov	r6,sp
81123a08:	8809883a 	mov	r4,r17
81123a0c:	1123bb40 	call	81123bb4 <_fstat_r>
81123a10:	103f891e 	bne	r2,zero,81123838 <__reset+0xfb103838>
81123a14:	dd800417 	ldw	r22,16(sp)
81123a18:	adad883a 	add	r22,r21,r22
81123a1c:	b83fc926 	beq	r23,zero,81123944 <__reset+0xfb103944>
81123a20:	81400c17 	ldw	r5,48(r16)
81123a24:	81800117 	ldw	r6,4(r16)
81123a28:	28005026 	beq	r5,zero,81123b6c <_fseeko_r+0x420>
81123a2c:	81c00f17 	ldw	r7,60(r16)
81123a30:	003fce06 	br	8112396c <__reset+0xfb10396c>
81123a34:	84c01317 	ldw	r19,76(r16)
81123a38:	81400717 	ldw	r5,28(r16)
81123a3c:	000f883a 	mov	r7,zero
81123a40:	04e7c83a 	sub	r19,zero,r19
81123a44:	9da6703a 	and	r19,r19,r22
81123a48:	980d883a 	mov	r6,r19
81123a4c:	8809883a 	mov	r4,r17
81123a50:	a03ee83a 	callr	r20
81123a54:	00ffffc4 	movi	r3,-1
81123a58:	10ff7726 	beq	r2,r3,81123838 <__reset+0xfb103838>
81123a5c:	80800417 	ldw	r2,16(r16)
81123a60:	81400c17 	ldw	r5,48(r16)
81123a64:	80000115 	stw	zero,4(r16)
81123a68:	80800015 	stw	r2,0(r16)
81123a6c:	28000526 	beq	r5,zero,81123a84 <_fseeko_r+0x338>
81123a70:	80801004 	addi	r2,r16,64
81123a74:	28800226 	beq	r5,r2,81123a80 <_fseeko_r+0x334>
81123a78:	8809883a 	mov	r4,r17
81123a7c:	112dbe80 	call	8112dbe8 <_free_r>
81123a80:	80000c15 	stw	zero,48(r16)
81123a84:	8080030b 	ldhu	r2,12(r16)
81123a88:	b4e7c83a 	sub	r19,r22,r19
81123a8c:	10bff7cc 	andi	r2,r2,65503
81123a90:	8080030d 	sth	r2,12(r16)
81123a94:	98000b26 	beq	r19,zero,81123ac4 <_fseeko_r+0x378>
81123a98:	800b883a 	mov	r5,r16
81123a9c:	8809883a 	mov	r4,r17
81123aa0:	1124c500 	call	81124c50 <__srefill_r>
81123aa4:	103f641e 	bne	r2,zero,81123838 <__reset+0xfb103838>
81123aa8:	80800117 	ldw	r2,4(r16)
81123aac:	14ff6236 	bltu	r2,r19,81123838 <__reset+0xfb103838>
81123ab0:	80c00017 	ldw	r3,0(r16)
81123ab4:	14c5c83a 	sub	r2,r2,r19
81123ab8:	80800115 	stw	r2,4(r16)
81123abc:	1ce7883a 	add	r19,r3,r19
81123ac0:	84c00015 	stw	r19,0(r16)
81123ac4:	01800204 	movi	r6,8
81123ac8:	000b883a 	mov	r5,zero
81123acc:	81001704 	addi	r4,r16,92
81123ad0:	11248500 	call	81124850 <memset>
81123ad4:	0027883a 	mov	r19,zero
81123ad8:	003f3d06 	br	811237d0 <__reset+0xfb1037d0>
81123adc:	80800417 	ldw	r2,16(r16)
81123ae0:	003f8306 	br	811238f0 <__reset+0xfb1038f0>
81123ae4:	81400717 	ldw	r5,28(r16)
81123ae8:	900f883a 	mov	r7,r18
81123aec:	000d883a 	mov	r6,zero
81123af0:	8809883a 	mov	r4,r17
81123af4:	a03ee83a 	callr	r20
81123af8:	1027883a 	mov	r19,r2
81123afc:	00bfffc4 	movi	r2,-1
81123b00:	98bf3226 	beq	r19,r2,811237cc <__reset+0xfb1037cc>
81123b04:	8080030b 	ldhu	r2,12(r16)
81123b08:	003f7006 	br	811238cc <__reset+0xfb1038cc>
81123b0c:	8140038f 	ldh	r5,14(r16)
81123b10:	283f4716 	blt	r5,zero,81123830 <__reset+0xfb103830>
81123b14:	d80d883a 	mov	r6,sp
81123b18:	8809883a 	mov	r4,r17
81123b1c:	1123bb40 	call	81123bb4 <_fstat_r>
81123b20:	1000041e 	bne	r2,zero,81123b34 <_fseeko_r+0x3e8>
81123b24:	d8800117 	ldw	r2,4(sp)
81123b28:	00e00014 	movui	r3,32768
81123b2c:	10bc000c 	andi	r2,r2,61440
81123b30:	10ff7c26 	beq	r2,r3,81123924 <__reset+0xfb103924>
81123b34:	8080030b 	ldhu	r2,12(r16)
81123b38:	003f3d06 	br	81123830 <__reset+0xfb103830>
81123b3c:	800b883a 	mov	r5,r16
81123b40:	8809883a 	mov	r4,r17
81123b44:	1123d280 	call	81123d28 <__smakebuf_r>
81123b48:	003f3106 	br	81123810 <__reset+0xfb103810>
81123b4c:	81400717 	ldw	r5,28(r16)
81123b50:	01c00044 	movi	r7,1
81123b54:	000d883a 	mov	r6,zero
81123b58:	8809883a 	mov	r4,r17
81123b5c:	a03ee83a 	callr	r20
81123b60:	00ffffc4 	movi	r3,-1
81123b64:	10ff7b1e 	bne	r2,r3,81123954 <__reset+0xfb103954>
81123b68:	003f3306 	br	81123838 <__reset+0xfb103838>
81123b6c:	80c00017 	ldw	r3,0(r16)
81123b70:	80800417 	ldw	r2,16(r16)
81123b74:	000b883a 	mov	r5,zero
81123b78:	1887c83a 	sub	r3,r3,r2
81123b7c:	98e7c83a 	sub	r19,r19,r3
81123b80:	30c7883a 	add	r3,r6,r3
81123b84:	003f7f06 	br	81123984 <__reset+0xfb103984>
81123b88:	00800744 	movi	r2,29
81123b8c:	88800015 	stw	r2,0(r17)
81123b90:	04ffffc4 	movi	r19,-1
81123b94:	003f0e06 	br	811237d0 <__reset+0xfb1037d0>

81123b98 <fseeko>:
81123b98:	00a04574 	movhi	r2,33045
81123b9c:	10945c04 	addi	r2,r2,20848
81123ba0:	300f883a 	mov	r7,r6
81123ba4:	280d883a 	mov	r6,r5
81123ba8:	200b883a 	mov	r5,r4
81123bac:	11000017 	ldw	r4,0(r2)
81123bb0:	112374c1 	jmpi	8112374c <_fseeko_r>

81123bb4 <_fstat_r>:
81123bb4:	defffd04 	addi	sp,sp,-12
81123bb8:	de00012e 	bgeu	sp,et,81123bc0 <_fstat_r+0xc>
81123bbc:	003b68fa 	trap	3
81123bc0:	2805883a 	mov	r2,r5
81123bc4:	dc000015 	stw	r16,0(sp)
81123bc8:	04204574 	movhi	r16,33045
81123bcc:	dc400115 	stw	r17,4(sp)
81123bd0:	8414cf04 	addi	r16,r16,21308
81123bd4:	2023883a 	mov	r17,r4
81123bd8:	300b883a 	mov	r5,r6
81123bdc:	1009883a 	mov	r4,r2
81123be0:	dfc00215 	stw	ra,8(sp)
81123be4:	80000015 	stw	zero,0(r16)
81123be8:	11385800 	call	81138580 <fstat>
81123bec:	00ffffc4 	movi	r3,-1
81123bf0:	10c00526 	beq	r2,r3,81123c08 <_fstat_r+0x54>
81123bf4:	dfc00217 	ldw	ra,8(sp)
81123bf8:	dc400117 	ldw	r17,4(sp)
81123bfc:	dc000017 	ldw	r16,0(sp)
81123c00:	dec00304 	addi	sp,sp,12
81123c04:	f800283a 	ret
81123c08:	80c00017 	ldw	r3,0(r16)
81123c0c:	183ff926 	beq	r3,zero,81123bf4 <__reset+0xfb103bf4>
81123c10:	88c00015 	stw	r3,0(r17)
81123c14:	003ff706 	br	81123bf4 <__reset+0xfb103bf4>

81123c18 <_fwrite_r>:
81123c18:	defff504 	addi	sp,sp,-44
81123c1c:	de00012e 	bgeu	sp,et,81123c24 <_fwrite_r+0xc>
81123c20:	003b68fa 	trap	3
81123c24:	dc800815 	stw	r18,32(sp)
81123c28:	39a5383a 	mul	r18,r7,r6
81123c2c:	d8800304 	addi	r2,sp,12
81123c30:	d8800015 	stw	r2,0(sp)
81123c34:	00800044 	movi	r2,1
81123c38:	dcc00915 	stw	r19,36(sp)
81123c3c:	dc400715 	stw	r17,28(sp)
81123c40:	dc000615 	stw	r16,24(sp)
81123c44:	d9400315 	stw	r5,12(sp)
81123c48:	dfc00a15 	stw	ra,40(sp)
81123c4c:	dc800415 	stw	r18,16(sp)
81123c50:	dc800215 	stw	r18,8(sp)
81123c54:	d8800115 	stw	r2,4(sp)
81123c58:	3027883a 	mov	r19,r6
81123c5c:	3821883a 	mov	r16,r7
81123c60:	2023883a 	mov	r17,r4
81123c64:	d9400b17 	ldw	r5,44(sp)
81123c68:	20000226 	beq	r4,zero,81123c74 <_fwrite_r+0x5c>
81123c6c:	20800e17 	ldw	r2,56(r4)
81123c70:	10001a26 	beq	r2,zero,81123cdc <_fwrite_r+0xc4>
81123c74:	2880030b 	ldhu	r2,12(r5)
81123c78:	10c8000c 	andi	r3,r2,8192
81123c7c:	1800061e 	bne	r3,zero,81123c98 <_fwrite_r+0x80>
81123c80:	29001917 	ldw	r4,100(r5)
81123c84:	00f7ffc4 	movi	r3,-8193
81123c88:	10880014 	ori	r2,r2,8192
81123c8c:	20c6703a 	and	r3,r4,r3
81123c90:	2880030d 	sth	r2,12(r5)
81123c94:	28c01915 	stw	r3,100(r5)
81123c98:	d80d883a 	mov	r6,sp
81123c9c:	8809883a 	mov	r4,r17
81123ca0:	112df000 	call	8112df00 <__sfvwrite_r>
81123ca4:	10000b26 	beq	r2,zero,81123cd4 <_fwrite_r+0xbc>
81123ca8:	d9000217 	ldw	r4,8(sp)
81123cac:	980b883a 	mov	r5,r19
81123cb0:	9109c83a 	sub	r4,r18,r4
81123cb4:	1136c0c0 	call	81136c0c <__udivsi3>
81123cb8:	dfc00a17 	ldw	ra,40(sp)
81123cbc:	dcc00917 	ldw	r19,36(sp)
81123cc0:	dc800817 	ldw	r18,32(sp)
81123cc4:	dc400717 	ldw	r17,28(sp)
81123cc8:	dc000617 	ldw	r16,24(sp)
81123ccc:	dec00b04 	addi	sp,sp,44
81123cd0:	f800283a 	ret
81123cd4:	8005883a 	mov	r2,r16
81123cd8:	003ff706 	br	81123cb8 <__reset+0xfb103cb8>
81123cdc:	d9400515 	stw	r5,20(sp)
81123ce0:	112d7500 	call	8112d750 <__sinit>
81123ce4:	d9400517 	ldw	r5,20(sp)
81123ce8:	003fe206 	br	81123c74 <__reset+0xfb103c74>

81123cec <fwrite>:
81123cec:	defffe04 	addi	sp,sp,-8
81123cf0:	00a04574 	movhi	r2,33045
81123cf4:	de00012e 	bgeu	sp,et,81123cfc <fwrite+0x10>
81123cf8:	003b68fa 	trap	3
81123cfc:	10945c04 	addi	r2,r2,20848
81123d00:	d9c00015 	stw	r7,0(sp)
81123d04:	300f883a 	mov	r7,r6
81123d08:	280d883a 	mov	r6,r5
81123d0c:	200b883a 	mov	r5,r4
81123d10:	11000017 	ldw	r4,0(r2)
81123d14:	dfc00115 	stw	ra,4(sp)
81123d18:	1123c180 	call	81123c18 <_fwrite_r>
81123d1c:	dfc00117 	ldw	ra,4(sp)
81123d20:	dec00204 	addi	sp,sp,8
81123d24:	f800283a 	ret

81123d28 <__smakebuf_r>:
81123d28:	2880030b 	ldhu	r2,12(r5)
81123d2c:	10c0008c 	andi	r3,r2,2
81123d30:	1800431e 	bne	r3,zero,81123e40 <__smakebuf_r+0x118>
81123d34:	deffec04 	addi	sp,sp,-80
81123d38:	de00012e 	bgeu	sp,et,81123d40 <__smakebuf_r+0x18>
81123d3c:	003b68fa 	trap	3
81123d40:	dc000f15 	stw	r16,60(sp)
81123d44:	2821883a 	mov	r16,r5
81123d48:	2940038f 	ldh	r5,14(r5)
81123d4c:	dc401015 	stw	r17,64(sp)
81123d50:	dfc01315 	stw	ra,76(sp)
81123d54:	dcc01215 	stw	r19,72(sp)
81123d58:	dc801115 	stw	r18,68(sp)
81123d5c:	2023883a 	mov	r17,r4
81123d60:	28001c16 	blt	r5,zero,81123dd4 <__smakebuf_r+0xac>
81123d64:	d80d883a 	mov	r6,sp
81123d68:	1123bb40 	call	81123bb4 <_fstat_r>
81123d6c:	10001816 	blt	r2,zero,81123dd0 <__smakebuf_r+0xa8>
81123d70:	d8800117 	ldw	r2,4(sp)
81123d74:	00e00014 	movui	r3,32768
81123d78:	10bc000c 	andi	r2,r2,61440
81123d7c:	14c80020 	cmpeqi	r19,r2,8192
81123d80:	10c03726 	beq	r2,r3,81123e60 <__smakebuf_r+0x138>
81123d84:	80c0030b 	ldhu	r3,12(r16)
81123d88:	18c20014 	ori	r3,r3,2048
81123d8c:	80c0030d 	sth	r3,12(r16)
81123d90:	00c80004 	movi	r3,8192
81123d94:	10c0521e 	bne	r2,r3,81123ee0 <__smakebuf_r+0x1b8>
81123d98:	8140038f 	ldh	r5,14(r16)
81123d9c:	8809883a 	mov	r4,r17
81123da0:	112e55c0 	call	8112e55c <_isatty_r>
81123da4:	10004c26 	beq	r2,zero,81123ed8 <__smakebuf_r+0x1b0>
81123da8:	8080030b 	ldhu	r2,12(r16)
81123dac:	80c010c4 	addi	r3,r16,67
81123db0:	80c00015 	stw	r3,0(r16)
81123db4:	10800054 	ori	r2,r2,1
81123db8:	8080030d 	sth	r2,12(r16)
81123dbc:	00800044 	movi	r2,1
81123dc0:	80c00415 	stw	r3,16(r16)
81123dc4:	80800515 	stw	r2,20(r16)
81123dc8:	04810004 	movi	r18,1024
81123dcc:	00000706 	br	81123dec <__smakebuf_r+0xc4>
81123dd0:	8080030b 	ldhu	r2,12(r16)
81123dd4:	10c0200c 	andi	r3,r2,128
81123dd8:	18001f1e 	bne	r3,zero,81123e58 <__smakebuf_r+0x130>
81123ddc:	04810004 	movi	r18,1024
81123de0:	10820014 	ori	r2,r2,2048
81123de4:	8080030d 	sth	r2,12(r16)
81123de8:	0027883a 	mov	r19,zero
81123dec:	900b883a 	mov	r5,r18
81123df0:	8809883a 	mov	r4,r17
81123df4:	1123eec0 	call	81123eec <_malloc_r>
81123df8:	10002c26 	beq	r2,zero,81123eac <__smakebuf_r+0x184>
81123dfc:	80c0030b 	ldhu	r3,12(r16)
81123e00:	012044f4 	movhi	r4,33043
81123e04:	2134fc04 	addi	r4,r4,-11280
81123e08:	89000f15 	stw	r4,60(r17)
81123e0c:	18c02014 	ori	r3,r3,128
81123e10:	80c0030d 	sth	r3,12(r16)
81123e14:	80800015 	stw	r2,0(r16)
81123e18:	80800415 	stw	r2,16(r16)
81123e1c:	84800515 	stw	r18,20(r16)
81123e20:	98001a1e 	bne	r19,zero,81123e8c <__smakebuf_r+0x164>
81123e24:	dfc01317 	ldw	ra,76(sp)
81123e28:	dcc01217 	ldw	r19,72(sp)
81123e2c:	dc801117 	ldw	r18,68(sp)
81123e30:	dc401017 	ldw	r17,64(sp)
81123e34:	dc000f17 	ldw	r16,60(sp)
81123e38:	dec01404 	addi	sp,sp,80
81123e3c:	f800283a 	ret
81123e40:	288010c4 	addi	r2,r5,67
81123e44:	28800015 	stw	r2,0(r5)
81123e48:	28800415 	stw	r2,16(r5)
81123e4c:	00800044 	movi	r2,1
81123e50:	28800515 	stw	r2,20(r5)
81123e54:	f800283a 	ret
81123e58:	04801004 	movi	r18,64
81123e5c:	003fe006 	br	81123de0 <__reset+0xfb103de0>
81123e60:	81000a17 	ldw	r4,40(r16)
81123e64:	00e044b4 	movhi	r3,33042
81123e68:	18d43004 	addi	r3,r3,20672
81123e6c:	20ffc51e 	bne	r4,r3,81123d84 <__reset+0xfb103d84>
81123e70:	8080030b 	ldhu	r2,12(r16)
81123e74:	04810004 	movi	r18,1024
81123e78:	84801315 	stw	r18,76(r16)
81123e7c:	1484b03a 	or	r2,r2,r18
81123e80:	8080030d 	sth	r2,12(r16)
81123e84:	0027883a 	mov	r19,zero
81123e88:	003fd806 	br	81123dec <__reset+0xfb103dec>
81123e8c:	8140038f 	ldh	r5,14(r16)
81123e90:	8809883a 	mov	r4,r17
81123e94:	112e55c0 	call	8112e55c <_isatty_r>
81123e98:	103fe226 	beq	r2,zero,81123e24 <__reset+0xfb103e24>
81123e9c:	8080030b 	ldhu	r2,12(r16)
81123ea0:	10800054 	ori	r2,r2,1
81123ea4:	8080030d 	sth	r2,12(r16)
81123ea8:	003fde06 	br	81123e24 <__reset+0xfb103e24>
81123eac:	8080030b 	ldhu	r2,12(r16)
81123eb0:	10c0800c 	andi	r3,r2,512
81123eb4:	183fdb1e 	bne	r3,zero,81123e24 <__reset+0xfb103e24>
81123eb8:	10800094 	ori	r2,r2,2
81123ebc:	80c010c4 	addi	r3,r16,67
81123ec0:	8080030d 	sth	r2,12(r16)
81123ec4:	00800044 	movi	r2,1
81123ec8:	80c00015 	stw	r3,0(r16)
81123ecc:	80c00415 	stw	r3,16(r16)
81123ed0:	80800515 	stw	r2,20(r16)
81123ed4:	003fd306 	br	81123e24 <__reset+0xfb103e24>
81123ed8:	04810004 	movi	r18,1024
81123edc:	003fc306 	br	81123dec <__reset+0xfb103dec>
81123ee0:	0027883a 	mov	r19,zero
81123ee4:	04810004 	movi	r18,1024
81123ee8:	003fc006 	br	81123dec <__reset+0xfb103dec>

81123eec <_malloc_r>:
81123eec:	defff504 	addi	sp,sp,-44
81123ef0:	de00012e 	bgeu	sp,et,81123ef8 <_malloc_r+0xc>
81123ef4:	003b68fa 	trap	3
81123ef8:	288002c4 	addi	r2,r5,11
81123efc:	dc800315 	stw	r18,12(sp)
81123f00:	dfc00a15 	stw	ra,40(sp)
81123f04:	df000915 	stw	fp,36(sp)
81123f08:	ddc00815 	stw	r23,32(sp)
81123f0c:	dd800715 	stw	r22,28(sp)
81123f10:	dd400615 	stw	r21,24(sp)
81123f14:	dd000515 	stw	r20,20(sp)
81123f18:	dcc00415 	stw	r19,16(sp)
81123f1c:	dc400215 	stw	r17,8(sp)
81123f20:	dc000115 	stw	r16,4(sp)
81123f24:	00c00584 	movi	r3,22
81123f28:	2025883a 	mov	r18,r4
81123f2c:	18807f2e 	bgeu	r3,r2,8112412c <_malloc_r+0x240>
81123f30:	047ffe04 	movi	r17,-8
81123f34:	1462703a 	and	r17,r2,r17
81123f38:	8800a316 	blt	r17,zero,811241c8 <_malloc_r+0x2dc>
81123f3c:	8940a236 	bltu	r17,r5,811241c8 <_malloc_r+0x2dc>
81123f40:	113a0c80 	call	8113a0c8 <__malloc_lock>
81123f44:	00807dc4 	movi	r2,503
81123f48:	1441e92e 	bgeu	r2,r17,811246f0 <_malloc_r+0x804>
81123f4c:	8804d27a 	srli	r2,r17,9
81123f50:	1000a126 	beq	r2,zero,811241d8 <_malloc_r+0x2ec>
81123f54:	00c00104 	movi	r3,4
81123f58:	18811e36 	bltu	r3,r2,811243d4 <_malloc_r+0x4e8>
81123f5c:	8804d1ba 	srli	r2,r17,6
81123f60:	12000e44 	addi	r8,r2,57
81123f64:	11c00e04 	addi	r7,r2,56
81123f68:	4209883a 	add	r4,r8,r8
81123f6c:	04e04574 	movhi	r19,33045
81123f70:	2109883a 	add	r4,r4,r4
81123f74:	9cce1a04 	addi	r19,r19,14440
81123f78:	2109883a 	add	r4,r4,r4
81123f7c:	9909883a 	add	r4,r19,r4
81123f80:	24000117 	ldw	r16,4(r4)
81123f84:	213ffe04 	addi	r4,r4,-8
81123f88:	24009726 	beq	r4,r16,811241e8 <_malloc_r+0x2fc>
81123f8c:	80800117 	ldw	r2,4(r16)
81123f90:	01bfff04 	movi	r6,-4
81123f94:	014003c4 	movi	r5,15
81123f98:	1184703a 	and	r2,r2,r6
81123f9c:	1447c83a 	sub	r3,r2,r17
81123fa0:	28c00716 	blt	r5,r3,81123fc0 <_malloc_r+0xd4>
81123fa4:	1800920e 	bge	r3,zero,811241f0 <_malloc_r+0x304>
81123fa8:	84000317 	ldw	r16,12(r16)
81123fac:	24008e26 	beq	r4,r16,811241e8 <_malloc_r+0x2fc>
81123fb0:	80800117 	ldw	r2,4(r16)
81123fb4:	1184703a 	and	r2,r2,r6
81123fb8:	1447c83a 	sub	r3,r2,r17
81123fbc:	28fff90e 	bge	r5,r3,81123fa4 <__reset+0xfb103fa4>
81123fc0:	3809883a 	mov	r4,r7
81123fc4:	01a04574 	movhi	r6,33045
81123fc8:	9c000417 	ldw	r16,16(r19)
81123fcc:	318e1a04 	addi	r6,r6,14440
81123fd0:	32000204 	addi	r8,r6,8
81123fd4:	82013426 	beq	r16,r8,811244a8 <_malloc_r+0x5bc>
81123fd8:	80c00117 	ldw	r3,4(r16)
81123fdc:	00bfff04 	movi	r2,-4
81123fe0:	188e703a 	and	r7,r3,r2
81123fe4:	3c45c83a 	sub	r2,r7,r17
81123fe8:	00c003c4 	movi	r3,15
81123fec:	18811f16 	blt	r3,r2,8112446c <_malloc_r+0x580>
81123ff0:	32000515 	stw	r8,20(r6)
81123ff4:	32000415 	stw	r8,16(r6)
81123ff8:	10007f0e 	bge	r2,zero,811241f8 <_malloc_r+0x30c>
81123ffc:	00807fc4 	movi	r2,511
81124000:	11c0fd36 	bltu	r2,r7,811243f8 <_malloc_r+0x50c>
81124004:	3806d0fa 	srli	r3,r7,3
81124008:	01c00044 	movi	r7,1
8112400c:	30800117 	ldw	r2,4(r6)
81124010:	19400044 	addi	r5,r3,1
81124014:	294b883a 	add	r5,r5,r5
81124018:	1807d0ba 	srai	r3,r3,2
8112401c:	294b883a 	add	r5,r5,r5
81124020:	294b883a 	add	r5,r5,r5
81124024:	298b883a 	add	r5,r5,r6
81124028:	38c6983a 	sll	r3,r7,r3
8112402c:	29c00017 	ldw	r7,0(r5)
81124030:	2a7ffe04 	addi	r9,r5,-8
81124034:	1886b03a 	or	r3,r3,r2
81124038:	82400315 	stw	r9,12(r16)
8112403c:	81c00215 	stw	r7,8(r16)
81124040:	30c00115 	stw	r3,4(r6)
81124044:	2c000015 	stw	r16,0(r5)
81124048:	3c000315 	stw	r16,12(r7)
8112404c:	2005d0ba 	srai	r2,r4,2
81124050:	01400044 	movi	r5,1
81124054:	288a983a 	sll	r5,r5,r2
81124058:	19406f36 	bltu	r3,r5,81124218 <_malloc_r+0x32c>
8112405c:	28c4703a 	and	r2,r5,r3
81124060:	10000a1e 	bne	r2,zero,8112408c <_malloc_r+0x1a0>
81124064:	00bfff04 	movi	r2,-4
81124068:	294b883a 	add	r5,r5,r5
8112406c:	2088703a 	and	r4,r4,r2
81124070:	28c4703a 	and	r2,r5,r3
81124074:	21000104 	addi	r4,r4,4
81124078:	1000041e 	bne	r2,zero,8112408c <_malloc_r+0x1a0>
8112407c:	294b883a 	add	r5,r5,r5
81124080:	28c4703a 	and	r2,r5,r3
81124084:	21000104 	addi	r4,r4,4
81124088:	103ffc26 	beq	r2,zero,8112407c <__reset+0xfb10407c>
8112408c:	02bfff04 	movi	r10,-4
81124090:	024003c4 	movi	r9,15
81124094:	21800044 	addi	r6,r4,1
81124098:	318d883a 	add	r6,r6,r6
8112409c:	318d883a 	add	r6,r6,r6
811240a0:	318d883a 	add	r6,r6,r6
811240a4:	998d883a 	add	r6,r19,r6
811240a8:	333ffe04 	addi	r12,r6,-8
811240ac:	2017883a 	mov	r11,r4
811240b0:	31800104 	addi	r6,r6,4
811240b4:	34000017 	ldw	r16,0(r6)
811240b8:	31fffd04 	addi	r7,r6,-12
811240bc:	81c0041e 	bne	r16,r7,811240d0 <_malloc_r+0x1e4>
811240c0:	0000fb06 	br	811244b0 <_malloc_r+0x5c4>
811240c4:	1801030e 	bge	r3,zero,811244d4 <_malloc_r+0x5e8>
811240c8:	84000317 	ldw	r16,12(r16)
811240cc:	81c0f826 	beq	r16,r7,811244b0 <_malloc_r+0x5c4>
811240d0:	80800117 	ldw	r2,4(r16)
811240d4:	1284703a 	and	r2,r2,r10
811240d8:	1447c83a 	sub	r3,r2,r17
811240dc:	48fff90e 	bge	r9,r3,811240c4 <__reset+0xfb1040c4>
811240e0:	80800317 	ldw	r2,12(r16)
811240e4:	81000217 	ldw	r4,8(r16)
811240e8:	89400054 	ori	r5,r17,1
811240ec:	81400115 	stw	r5,4(r16)
811240f0:	20800315 	stw	r2,12(r4)
811240f4:	11000215 	stw	r4,8(r2)
811240f8:	8463883a 	add	r17,r16,r17
811240fc:	9c400515 	stw	r17,20(r19)
81124100:	9c400415 	stw	r17,16(r19)
81124104:	18800054 	ori	r2,r3,1
81124108:	88800115 	stw	r2,4(r17)
8112410c:	8a000315 	stw	r8,12(r17)
81124110:	8a000215 	stw	r8,8(r17)
81124114:	88e3883a 	add	r17,r17,r3
81124118:	88c00015 	stw	r3,0(r17)
8112411c:	9009883a 	mov	r4,r18
81124120:	113a1f00 	call	8113a1f0 <__malloc_unlock>
81124124:	80800204 	addi	r2,r16,8
81124128:	00001b06 	br	81124198 <_malloc_r+0x2ac>
8112412c:	04400404 	movi	r17,16
81124130:	89402536 	bltu	r17,r5,811241c8 <_malloc_r+0x2dc>
81124134:	113a0c80 	call	8113a0c8 <__malloc_lock>
81124138:	00800184 	movi	r2,6
8112413c:	01000084 	movi	r4,2
81124140:	04e04574 	movhi	r19,33045
81124144:	1085883a 	add	r2,r2,r2
81124148:	9cce1a04 	addi	r19,r19,14440
8112414c:	1085883a 	add	r2,r2,r2
81124150:	9885883a 	add	r2,r19,r2
81124154:	14000117 	ldw	r16,4(r2)
81124158:	10fffe04 	addi	r3,r2,-8
8112415c:	80c0d926 	beq	r16,r3,811244c4 <_malloc_r+0x5d8>
81124160:	80c00117 	ldw	r3,4(r16)
81124164:	81000317 	ldw	r4,12(r16)
81124168:	00bfff04 	movi	r2,-4
8112416c:	1884703a 	and	r2,r3,r2
81124170:	81400217 	ldw	r5,8(r16)
81124174:	8085883a 	add	r2,r16,r2
81124178:	10c00117 	ldw	r3,4(r2)
8112417c:	29000315 	stw	r4,12(r5)
81124180:	21400215 	stw	r5,8(r4)
81124184:	18c00054 	ori	r3,r3,1
81124188:	10c00115 	stw	r3,4(r2)
8112418c:	9009883a 	mov	r4,r18
81124190:	113a1f00 	call	8113a1f0 <__malloc_unlock>
81124194:	80800204 	addi	r2,r16,8
81124198:	dfc00a17 	ldw	ra,40(sp)
8112419c:	df000917 	ldw	fp,36(sp)
811241a0:	ddc00817 	ldw	r23,32(sp)
811241a4:	dd800717 	ldw	r22,28(sp)
811241a8:	dd400617 	ldw	r21,24(sp)
811241ac:	dd000517 	ldw	r20,20(sp)
811241b0:	dcc00417 	ldw	r19,16(sp)
811241b4:	dc800317 	ldw	r18,12(sp)
811241b8:	dc400217 	ldw	r17,8(sp)
811241bc:	dc000117 	ldw	r16,4(sp)
811241c0:	dec00b04 	addi	sp,sp,44
811241c4:	f800283a 	ret
811241c8:	00800304 	movi	r2,12
811241cc:	90800015 	stw	r2,0(r18)
811241d0:	0005883a 	mov	r2,zero
811241d4:	003ff006 	br	81124198 <__reset+0xfb104198>
811241d8:	01002004 	movi	r4,128
811241dc:	02001004 	movi	r8,64
811241e0:	01c00fc4 	movi	r7,63
811241e4:	003f6106 	br	81123f6c <__reset+0xfb103f6c>
811241e8:	4009883a 	mov	r4,r8
811241ec:	003f7506 	br	81123fc4 <__reset+0xfb103fc4>
811241f0:	81000317 	ldw	r4,12(r16)
811241f4:	003fde06 	br	81124170 <__reset+0xfb104170>
811241f8:	81c5883a 	add	r2,r16,r7
811241fc:	11400117 	ldw	r5,4(r2)
81124200:	9009883a 	mov	r4,r18
81124204:	29400054 	ori	r5,r5,1
81124208:	11400115 	stw	r5,4(r2)
8112420c:	113a1f00 	call	8113a1f0 <__malloc_unlock>
81124210:	80800204 	addi	r2,r16,8
81124214:	003fe006 	br	81124198 <__reset+0xfb104198>
81124218:	9c000217 	ldw	r16,8(r19)
8112421c:	00bfff04 	movi	r2,-4
81124220:	85800117 	ldw	r22,4(r16)
81124224:	b0ac703a 	and	r22,r22,r2
81124228:	b4400336 	bltu	r22,r17,81124238 <_malloc_r+0x34c>
8112422c:	b445c83a 	sub	r2,r22,r17
81124230:	00c003c4 	movi	r3,15
81124234:	18805d16 	blt	r3,r2,811243ac <_malloc_r+0x4c0>
81124238:	05e04574 	movhi	r23,33045
8112423c:	00a04574 	movhi	r2,33045
81124240:	1094d204 	addi	r2,r2,21320
81124244:	bdd45d04 	addi	r23,r23,20852
81124248:	15400017 	ldw	r21,0(r2)
8112424c:	b8c00017 	ldw	r3,0(r23)
81124250:	00bfffc4 	movi	r2,-1
81124254:	858d883a 	add	r6,r16,r22
81124258:	8d6b883a 	add	r21,r17,r21
8112425c:	1880ea26 	beq	r3,r2,81124608 <_malloc_r+0x71c>
81124260:	ad4403c4 	addi	r21,r21,4111
81124264:	00bc0004 	movi	r2,-4096
81124268:	a8aa703a 	and	r21,r21,r2
8112426c:	a80b883a 	mov	r5,r21
81124270:	9009883a 	mov	r4,r18
81124274:	d9800015 	stw	r6,0(sp)
81124278:	1124e2c0 	call	81124e2c <_sbrk_r>
8112427c:	1029883a 	mov	r20,r2
81124280:	00bfffc4 	movi	r2,-1
81124284:	d9800017 	ldw	r6,0(sp)
81124288:	a080e826 	beq	r20,r2,8112462c <_malloc_r+0x740>
8112428c:	a180a636 	bltu	r20,r6,81124528 <_malloc_r+0x63c>
81124290:	07204574 	movhi	fp,33045
81124294:	e7155f04 	addi	fp,fp,21884
81124298:	e0800017 	ldw	r2,0(fp)
8112429c:	a887883a 	add	r3,r21,r2
811242a0:	e0c00015 	stw	r3,0(fp)
811242a4:	3500e626 	beq	r6,r20,81124640 <_malloc_r+0x754>
811242a8:	b9000017 	ldw	r4,0(r23)
811242ac:	00bfffc4 	movi	r2,-1
811242b0:	2080ee26 	beq	r4,r2,8112466c <_malloc_r+0x780>
811242b4:	a185c83a 	sub	r2,r20,r6
811242b8:	10c5883a 	add	r2,r2,r3
811242bc:	e0800015 	stw	r2,0(fp)
811242c0:	a0c001cc 	andi	r3,r20,7
811242c4:	1800bc26 	beq	r3,zero,811245b8 <_malloc_r+0x6cc>
811242c8:	a0e9c83a 	sub	r20,r20,r3
811242cc:	00840204 	movi	r2,4104
811242d0:	a5000204 	addi	r20,r20,8
811242d4:	10c7c83a 	sub	r3,r2,r3
811242d8:	a545883a 	add	r2,r20,r21
811242dc:	1083ffcc 	andi	r2,r2,4095
811242e0:	18abc83a 	sub	r21,r3,r2
811242e4:	a80b883a 	mov	r5,r21
811242e8:	9009883a 	mov	r4,r18
811242ec:	1124e2c0 	call	81124e2c <_sbrk_r>
811242f0:	00ffffc4 	movi	r3,-1
811242f4:	10c0e126 	beq	r2,r3,8112467c <_malloc_r+0x790>
811242f8:	1505c83a 	sub	r2,r2,r20
811242fc:	1545883a 	add	r2,r2,r21
81124300:	10800054 	ori	r2,r2,1
81124304:	e0c00017 	ldw	r3,0(fp)
81124308:	9d000215 	stw	r20,8(r19)
8112430c:	a0800115 	stw	r2,4(r20)
81124310:	a8c7883a 	add	r3,r21,r3
81124314:	e0c00015 	stw	r3,0(fp)
81124318:	84c00e26 	beq	r16,r19,81124354 <_malloc_r+0x468>
8112431c:	018003c4 	movi	r6,15
81124320:	3580a72e 	bgeu	r6,r22,811245c0 <_malloc_r+0x6d4>
81124324:	81400117 	ldw	r5,4(r16)
81124328:	013ffe04 	movi	r4,-8
8112432c:	b0bffd04 	addi	r2,r22,-12
81124330:	1104703a 	and	r2,r2,r4
81124334:	2900004c 	andi	r4,r5,1
81124338:	2088b03a 	or	r4,r4,r2
8112433c:	81000115 	stw	r4,4(r16)
81124340:	01400144 	movi	r5,5
81124344:	8089883a 	add	r4,r16,r2
81124348:	21400115 	stw	r5,4(r4)
8112434c:	21400215 	stw	r5,8(r4)
81124350:	3080cd36 	bltu	r6,r2,81124688 <_malloc_r+0x79c>
81124354:	00a04574 	movhi	r2,33045
81124358:	1094d104 	addi	r2,r2,21316
8112435c:	11000017 	ldw	r4,0(r2)
81124360:	20c0012e 	bgeu	r4,r3,81124368 <_malloc_r+0x47c>
81124364:	10c00015 	stw	r3,0(r2)
81124368:	00a04574 	movhi	r2,33045
8112436c:	1094d004 	addi	r2,r2,21312
81124370:	11000017 	ldw	r4,0(r2)
81124374:	9c000217 	ldw	r16,8(r19)
81124378:	20c0012e 	bgeu	r4,r3,81124380 <_malloc_r+0x494>
8112437c:	10c00015 	stw	r3,0(r2)
81124380:	80c00117 	ldw	r3,4(r16)
81124384:	00bfff04 	movi	r2,-4
81124388:	1886703a 	and	r3,r3,r2
8112438c:	1c45c83a 	sub	r2,r3,r17
81124390:	1c400236 	bltu	r3,r17,8112439c <_malloc_r+0x4b0>
81124394:	00c003c4 	movi	r3,15
81124398:	18800416 	blt	r3,r2,811243ac <_malloc_r+0x4c0>
8112439c:	9009883a 	mov	r4,r18
811243a0:	113a1f00 	call	8113a1f0 <__malloc_unlock>
811243a4:	0005883a 	mov	r2,zero
811243a8:	003f7b06 	br	81124198 <__reset+0xfb104198>
811243ac:	88c00054 	ori	r3,r17,1
811243b0:	80c00115 	stw	r3,4(r16)
811243b4:	8463883a 	add	r17,r16,r17
811243b8:	10800054 	ori	r2,r2,1
811243bc:	9c400215 	stw	r17,8(r19)
811243c0:	88800115 	stw	r2,4(r17)
811243c4:	9009883a 	mov	r4,r18
811243c8:	113a1f00 	call	8113a1f0 <__malloc_unlock>
811243cc:	80800204 	addi	r2,r16,8
811243d0:	003f7106 	br	81124198 <__reset+0xfb104198>
811243d4:	00c00504 	movi	r3,20
811243d8:	18804a2e 	bgeu	r3,r2,81124504 <_malloc_r+0x618>
811243dc:	00c01504 	movi	r3,84
811243e0:	18806e36 	bltu	r3,r2,8112459c <_malloc_r+0x6b0>
811243e4:	8804d33a 	srli	r2,r17,12
811243e8:	12001bc4 	addi	r8,r2,111
811243ec:	11c01b84 	addi	r7,r2,110
811243f0:	4209883a 	add	r4,r8,r8
811243f4:	003edd06 	br	81123f6c <__reset+0xfb103f6c>
811243f8:	3804d27a 	srli	r2,r7,9
811243fc:	00c00104 	movi	r3,4
81124400:	1880442e 	bgeu	r3,r2,81124514 <_malloc_r+0x628>
81124404:	00c00504 	movi	r3,20
81124408:	18808136 	bltu	r3,r2,81124610 <_malloc_r+0x724>
8112440c:	11401704 	addi	r5,r2,92
81124410:	10c016c4 	addi	r3,r2,91
81124414:	294b883a 	add	r5,r5,r5
81124418:	294b883a 	add	r5,r5,r5
8112441c:	294b883a 	add	r5,r5,r5
81124420:	994b883a 	add	r5,r19,r5
81124424:	28800017 	ldw	r2,0(r5)
81124428:	01a04574 	movhi	r6,33045
8112442c:	297ffe04 	addi	r5,r5,-8
81124430:	318e1a04 	addi	r6,r6,14440
81124434:	28806526 	beq	r5,r2,811245cc <_malloc_r+0x6e0>
81124438:	01bfff04 	movi	r6,-4
8112443c:	10c00117 	ldw	r3,4(r2)
81124440:	1986703a 	and	r3,r3,r6
81124444:	38c0022e 	bgeu	r7,r3,81124450 <_malloc_r+0x564>
81124448:	10800217 	ldw	r2,8(r2)
8112444c:	28bffb1e 	bne	r5,r2,8112443c <__reset+0xfb10443c>
81124450:	11400317 	ldw	r5,12(r2)
81124454:	98c00117 	ldw	r3,4(r19)
81124458:	81400315 	stw	r5,12(r16)
8112445c:	80800215 	stw	r2,8(r16)
81124460:	2c000215 	stw	r16,8(r5)
81124464:	14000315 	stw	r16,12(r2)
81124468:	003ef806 	br	8112404c <__reset+0xfb10404c>
8112446c:	88c00054 	ori	r3,r17,1
81124470:	80c00115 	stw	r3,4(r16)
81124474:	8463883a 	add	r17,r16,r17
81124478:	34400515 	stw	r17,20(r6)
8112447c:	34400415 	stw	r17,16(r6)
81124480:	10c00054 	ori	r3,r2,1
81124484:	8a000315 	stw	r8,12(r17)
81124488:	8a000215 	stw	r8,8(r17)
8112448c:	88c00115 	stw	r3,4(r17)
81124490:	88a3883a 	add	r17,r17,r2
81124494:	88800015 	stw	r2,0(r17)
81124498:	9009883a 	mov	r4,r18
8112449c:	113a1f00 	call	8113a1f0 <__malloc_unlock>
811244a0:	80800204 	addi	r2,r16,8
811244a4:	003f3c06 	br	81124198 <__reset+0xfb104198>
811244a8:	30c00117 	ldw	r3,4(r6)
811244ac:	003ee706 	br	8112404c <__reset+0xfb10404c>
811244b0:	5ac00044 	addi	r11,r11,1
811244b4:	588000cc 	andi	r2,r11,3
811244b8:	31800204 	addi	r6,r6,8
811244bc:	103efd1e 	bne	r2,zero,811240b4 <__reset+0xfb1040b4>
811244c0:	00002406 	br	81124554 <_malloc_r+0x668>
811244c4:	14000317 	ldw	r16,12(r2)
811244c8:	143f251e 	bne	r2,r16,81124160 <__reset+0xfb104160>
811244cc:	21000084 	addi	r4,r4,2
811244d0:	003ebc06 	br	81123fc4 <__reset+0xfb103fc4>
811244d4:	8085883a 	add	r2,r16,r2
811244d8:	10c00117 	ldw	r3,4(r2)
811244dc:	81000317 	ldw	r4,12(r16)
811244e0:	81400217 	ldw	r5,8(r16)
811244e4:	18c00054 	ori	r3,r3,1
811244e8:	10c00115 	stw	r3,4(r2)
811244ec:	29000315 	stw	r4,12(r5)
811244f0:	21400215 	stw	r5,8(r4)
811244f4:	9009883a 	mov	r4,r18
811244f8:	113a1f00 	call	8113a1f0 <__malloc_unlock>
811244fc:	80800204 	addi	r2,r16,8
81124500:	003f2506 	br	81124198 <__reset+0xfb104198>
81124504:	12001704 	addi	r8,r2,92
81124508:	11c016c4 	addi	r7,r2,91
8112450c:	4209883a 	add	r4,r8,r8
81124510:	003e9606 	br	81123f6c <__reset+0xfb103f6c>
81124514:	3804d1ba 	srli	r2,r7,6
81124518:	11400e44 	addi	r5,r2,57
8112451c:	10c00e04 	addi	r3,r2,56
81124520:	294b883a 	add	r5,r5,r5
81124524:	003fbc06 	br	81124418 <__reset+0xfb104418>
81124528:	84ff5926 	beq	r16,r19,81124290 <__reset+0xfb104290>
8112452c:	00a04574 	movhi	r2,33045
81124530:	108e1a04 	addi	r2,r2,14440
81124534:	14000217 	ldw	r16,8(r2)
81124538:	00bfff04 	movi	r2,-4
8112453c:	80c00117 	ldw	r3,4(r16)
81124540:	1886703a 	and	r3,r3,r2
81124544:	003f9106 	br	8112438c <__reset+0xfb10438c>
81124548:	60800217 	ldw	r2,8(r12)
8112454c:	213fffc4 	addi	r4,r4,-1
81124550:	1300651e 	bne	r2,r12,811246e8 <_malloc_r+0x7fc>
81124554:	208000cc 	andi	r2,r4,3
81124558:	633ffe04 	addi	r12,r12,-8
8112455c:	103ffa1e 	bne	r2,zero,81124548 <__reset+0xfb104548>
81124560:	98800117 	ldw	r2,4(r19)
81124564:	0146303a 	nor	r3,zero,r5
81124568:	1884703a 	and	r2,r3,r2
8112456c:	98800115 	stw	r2,4(r19)
81124570:	294b883a 	add	r5,r5,r5
81124574:	117f2836 	bltu	r2,r5,81124218 <__reset+0xfb104218>
81124578:	283f2726 	beq	r5,zero,81124218 <__reset+0xfb104218>
8112457c:	2886703a 	and	r3,r5,r2
81124580:	5809883a 	mov	r4,r11
81124584:	183ec31e 	bne	r3,zero,81124094 <__reset+0xfb104094>
81124588:	294b883a 	add	r5,r5,r5
8112458c:	2886703a 	and	r3,r5,r2
81124590:	21000104 	addi	r4,r4,4
81124594:	183ffc26 	beq	r3,zero,81124588 <__reset+0xfb104588>
81124598:	003ebe06 	br	81124094 <__reset+0xfb104094>
8112459c:	00c05504 	movi	r3,340
811245a0:	18801236 	bltu	r3,r2,811245ec <_malloc_r+0x700>
811245a4:	8804d3fa 	srli	r2,r17,15
811245a8:	12001e04 	addi	r8,r2,120
811245ac:	11c01dc4 	addi	r7,r2,119
811245b0:	4209883a 	add	r4,r8,r8
811245b4:	003e6d06 	br	81123f6c <__reset+0xfb103f6c>
811245b8:	00c40004 	movi	r3,4096
811245bc:	003f4606 	br	811242d8 <__reset+0xfb1042d8>
811245c0:	00800044 	movi	r2,1
811245c4:	a0800115 	stw	r2,4(r20)
811245c8:	003f7406 	br	8112439c <__reset+0xfb10439c>
811245cc:	1805d0ba 	srai	r2,r3,2
811245d0:	01c00044 	movi	r7,1
811245d4:	30c00117 	ldw	r3,4(r6)
811245d8:	388e983a 	sll	r7,r7,r2
811245dc:	2805883a 	mov	r2,r5
811245e0:	38c6b03a 	or	r3,r7,r3
811245e4:	30c00115 	stw	r3,4(r6)
811245e8:	003f9b06 	br	81124458 <__reset+0xfb104458>
811245ec:	00c15504 	movi	r3,1364
811245f0:	18801a36 	bltu	r3,r2,8112465c <_malloc_r+0x770>
811245f4:	8804d4ba 	srli	r2,r17,18
811245f8:	12001f44 	addi	r8,r2,125
811245fc:	11c01f04 	addi	r7,r2,124
81124600:	4209883a 	add	r4,r8,r8
81124604:	003e5906 	br	81123f6c <__reset+0xfb103f6c>
81124608:	ad400404 	addi	r21,r21,16
8112460c:	003f1706 	br	8112426c <__reset+0xfb10426c>
81124610:	00c01504 	movi	r3,84
81124614:	18802336 	bltu	r3,r2,811246a4 <_malloc_r+0x7b8>
81124618:	3804d33a 	srli	r2,r7,12
8112461c:	11401bc4 	addi	r5,r2,111
81124620:	10c01b84 	addi	r3,r2,110
81124624:	294b883a 	add	r5,r5,r5
81124628:	003f7b06 	br	81124418 <__reset+0xfb104418>
8112462c:	9c000217 	ldw	r16,8(r19)
81124630:	00bfff04 	movi	r2,-4
81124634:	80c00117 	ldw	r3,4(r16)
81124638:	1886703a 	and	r3,r3,r2
8112463c:	003f5306 	br	8112438c <__reset+0xfb10438c>
81124640:	3083ffcc 	andi	r2,r6,4095
81124644:	103f181e 	bne	r2,zero,811242a8 <__reset+0xfb1042a8>
81124648:	99000217 	ldw	r4,8(r19)
8112464c:	b545883a 	add	r2,r22,r21
81124650:	10800054 	ori	r2,r2,1
81124654:	20800115 	stw	r2,4(r4)
81124658:	003f3e06 	br	81124354 <__reset+0xfb104354>
8112465c:	01003f84 	movi	r4,254
81124660:	02001fc4 	movi	r8,127
81124664:	01c01f84 	movi	r7,126
81124668:	003e4006 	br	81123f6c <__reset+0xfb103f6c>
8112466c:	00a04574 	movhi	r2,33045
81124670:	10945d04 	addi	r2,r2,20852
81124674:	15000015 	stw	r20,0(r2)
81124678:	003f1106 	br	811242c0 <__reset+0xfb1042c0>
8112467c:	00800044 	movi	r2,1
81124680:	002b883a 	mov	r21,zero
81124684:	003f1f06 	br	81124304 <__reset+0xfb104304>
81124688:	81400204 	addi	r5,r16,8
8112468c:	9009883a 	mov	r4,r18
81124690:	112dbe80 	call	8112dbe8 <_free_r>
81124694:	00a04574 	movhi	r2,33045
81124698:	10955f04 	addi	r2,r2,21884
8112469c:	10c00017 	ldw	r3,0(r2)
811246a0:	003f2c06 	br	81124354 <__reset+0xfb104354>
811246a4:	00c05504 	movi	r3,340
811246a8:	18800536 	bltu	r3,r2,811246c0 <_malloc_r+0x7d4>
811246ac:	3804d3fa 	srli	r2,r7,15
811246b0:	11401e04 	addi	r5,r2,120
811246b4:	10c01dc4 	addi	r3,r2,119
811246b8:	294b883a 	add	r5,r5,r5
811246bc:	003f5606 	br	81124418 <__reset+0xfb104418>
811246c0:	00c15504 	movi	r3,1364
811246c4:	18800536 	bltu	r3,r2,811246dc <_malloc_r+0x7f0>
811246c8:	3804d4ba 	srli	r2,r7,18
811246cc:	11401f44 	addi	r5,r2,125
811246d0:	10c01f04 	addi	r3,r2,124
811246d4:	294b883a 	add	r5,r5,r5
811246d8:	003f4f06 	br	81124418 <__reset+0xfb104418>
811246dc:	01403f84 	movi	r5,254
811246e0:	00c01f84 	movi	r3,126
811246e4:	003f4c06 	br	81124418 <__reset+0xfb104418>
811246e8:	98800117 	ldw	r2,4(r19)
811246ec:	003fa006 	br	81124570 <__reset+0xfb104570>
811246f0:	8808d0fa 	srli	r4,r17,3
811246f4:	20800044 	addi	r2,r4,1
811246f8:	1085883a 	add	r2,r2,r2
811246fc:	003e9006 	br	81124140 <__reset+0xfb104140>

81124700 <memcpy>:
81124700:	defffd04 	addi	sp,sp,-12
81124704:	de00012e 	bgeu	sp,et,8112470c <memcpy+0xc>
81124708:	003b68fa 	trap	3
8112470c:	00c003c4 	movi	r3,15
81124710:	dfc00215 	stw	ra,8(sp)
81124714:	dc400115 	stw	r17,4(sp)
81124718:	dc000015 	stw	r16,0(sp)
8112471c:	2005883a 	mov	r2,r4
81124720:	1980452e 	bgeu	r3,r6,81124838 <memcpy+0x138>
81124724:	2906b03a 	or	r3,r5,r4
81124728:	18c000cc 	andi	r3,r3,3
8112472c:	1800441e 	bne	r3,zero,81124840 <memcpy+0x140>
81124730:	347ffc04 	addi	r17,r6,-16
81124734:	8822d13a 	srli	r17,r17,4
81124738:	28c00104 	addi	r3,r5,4
8112473c:	23400104 	addi	r13,r4,4
81124740:	8820913a 	slli	r16,r17,4
81124744:	2b000204 	addi	r12,r5,8
81124748:	22c00204 	addi	r11,r4,8
8112474c:	84000504 	addi	r16,r16,20
81124750:	2a800304 	addi	r10,r5,12
81124754:	22400304 	addi	r9,r4,12
81124758:	2c21883a 	add	r16,r5,r16
8112475c:	2811883a 	mov	r8,r5
81124760:	200f883a 	mov	r7,r4
81124764:	41000017 	ldw	r4,0(r8)
81124768:	1fc00017 	ldw	ra,0(r3)
8112476c:	63c00017 	ldw	r15,0(r12)
81124770:	39000015 	stw	r4,0(r7)
81124774:	53800017 	ldw	r14,0(r10)
81124778:	6fc00015 	stw	ra,0(r13)
8112477c:	5bc00015 	stw	r15,0(r11)
81124780:	4b800015 	stw	r14,0(r9)
81124784:	18c00404 	addi	r3,r3,16
81124788:	39c00404 	addi	r7,r7,16
8112478c:	42000404 	addi	r8,r8,16
81124790:	6b400404 	addi	r13,r13,16
81124794:	63000404 	addi	r12,r12,16
81124798:	5ac00404 	addi	r11,r11,16
8112479c:	52800404 	addi	r10,r10,16
811247a0:	4a400404 	addi	r9,r9,16
811247a4:	1c3fef1e 	bne	r3,r16,81124764 <__reset+0xfb104764>
811247a8:	89c00044 	addi	r7,r17,1
811247ac:	380e913a 	slli	r7,r7,4
811247b0:	310003cc 	andi	r4,r6,15
811247b4:	02c000c4 	movi	r11,3
811247b8:	11c7883a 	add	r3,r2,r7
811247bc:	29cb883a 	add	r5,r5,r7
811247c0:	5900212e 	bgeu	r11,r4,81124848 <memcpy+0x148>
811247c4:	1813883a 	mov	r9,r3
811247c8:	2811883a 	mov	r8,r5
811247cc:	200f883a 	mov	r7,r4
811247d0:	42800017 	ldw	r10,0(r8)
811247d4:	4a400104 	addi	r9,r9,4
811247d8:	39ffff04 	addi	r7,r7,-4
811247dc:	4abfff15 	stw	r10,-4(r9)
811247e0:	42000104 	addi	r8,r8,4
811247e4:	59fffa36 	bltu	r11,r7,811247d0 <__reset+0xfb1047d0>
811247e8:	213fff04 	addi	r4,r4,-4
811247ec:	2008d0ba 	srli	r4,r4,2
811247f0:	318000cc 	andi	r6,r6,3
811247f4:	21000044 	addi	r4,r4,1
811247f8:	2109883a 	add	r4,r4,r4
811247fc:	2109883a 	add	r4,r4,r4
81124800:	1907883a 	add	r3,r3,r4
81124804:	290b883a 	add	r5,r5,r4
81124808:	30000626 	beq	r6,zero,81124824 <memcpy+0x124>
8112480c:	198d883a 	add	r6,r3,r6
81124810:	29c00003 	ldbu	r7,0(r5)
81124814:	18c00044 	addi	r3,r3,1
81124818:	29400044 	addi	r5,r5,1
8112481c:	19ffffc5 	stb	r7,-1(r3)
81124820:	19bffb1e 	bne	r3,r6,81124810 <__reset+0xfb104810>
81124824:	dfc00217 	ldw	ra,8(sp)
81124828:	dc400117 	ldw	r17,4(sp)
8112482c:	dc000017 	ldw	r16,0(sp)
81124830:	dec00304 	addi	sp,sp,12
81124834:	f800283a 	ret
81124838:	2007883a 	mov	r3,r4
8112483c:	003ff206 	br	81124808 <__reset+0xfb104808>
81124840:	2007883a 	mov	r3,r4
81124844:	003ff106 	br	8112480c <__reset+0xfb10480c>
81124848:	200d883a 	mov	r6,r4
8112484c:	003fee06 	br	81124808 <__reset+0xfb104808>

81124850 <memset>:
81124850:	20c000cc 	andi	r3,r4,3
81124854:	2005883a 	mov	r2,r4
81124858:	18004426 	beq	r3,zero,8112496c <memset+0x11c>
8112485c:	31ffffc4 	addi	r7,r6,-1
81124860:	30004026 	beq	r6,zero,81124964 <memset+0x114>
81124864:	2813883a 	mov	r9,r5
81124868:	200d883a 	mov	r6,r4
8112486c:	2007883a 	mov	r3,r4
81124870:	00000406 	br	81124884 <memset+0x34>
81124874:	3a3fffc4 	addi	r8,r7,-1
81124878:	31800044 	addi	r6,r6,1
8112487c:	38003926 	beq	r7,zero,81124964 <memset+0x114>
81124880:	400f883a 	mov	r7,r8
81124884:	18c00044 	addi	r3,r3,1
81124888:	32400005 	stb	r9,0(r6)
8112488c:	1a0000cc 	andi	r8,r3,3
81124890:	403ff81e 	bne	r8,zero,81124874 <__reset+0xfb104874>
81124894:	010000c4 	movi	r4,3
81124898:	21c02d2e 	bgeu	r4,r7,81124950 <memset+0x100>
8112489c:	29003fcc 	andi	r4,r5,255
811248a0:	200c923a 	slli	r6,r4,8
811248a4:	3108b03a 	or	r4,r6,r4
811248a8:	200c943a 	slli	r6,r4,16
811248ac:	218cb03a 	or	r6,r4,r6
811248b0:	010003c4 	movi	r4,15
811248b4:	21c0182e 	bgeu	r4,r7,81124918 <memset+0xc8>
811248b8:	3b3ffc04 	addi	r12,r7,-16
811248bc:	6018d13a 	srli	r12,r12,4
811248c0:	1a000104 	addi	r8,r3,4
811248c4:	1ac00204 	addi	r11,r3,8
811248c8:	6008913a 	slli	r4,r12,4
811248cc:	1a800304 	addi	r10,r3,12
811248d0:	1813883a 	mov	r9,r3
811248d4:	21000504 	addi	r4,r4,20
811248d8:	1909883a 	add	r4,r3,r4
811248dc:	49800015 	stw	r6,0(r9)
811248e0:	41800015 	stw	r6,0(r8)
811248e4:	59800015 	stw	r6,0(r11)
811248e8:	51800015 	stw	r6,0(r10)
811248ec:	42000404 	addi	r8,r8,16
811248f0:	4a400404 	addi	r9,r9,16
811248f4:	5ac00404 	addi	r11,r11,16
811248f8:	52800404 	addi	r10,r10,16
811248fc:	413ff71e 	bne	r8,r4,811248dc <__reset+0xfb1048dc>
81124900:	63000044 	addi	r12,r12,1
81124904:	6018913a 	slli	r12,r12,4
81124908:	39c003cc 	andi	r7,r7,15
8112490c:	010000c4 	movi	r4,3
81124910:	1b07883a 	add	r3,r3,r12
81124914:	21c00e2e 	bgeu	r4,r7,81124950 <memset+0x100>
81124918:	1813883a 	mov	r9,r3
8112491c:	3811883a 	mov	r8,r7
81124920:	010000c4 	movi	r4,3
81124924:	49800015 	stw	r6,0(r9)
81124928:	423fff04 	addi	r8,r8,-4
8112492c:	4a400104 	addi	r9,r9,4
81124930:	223ffc36 	bltu	r4,r8,81124924 <__reset+0xfb104924>
81124934:	393fff04 	addi	r4,r7,-4
81124938:	2008d0ba 	srli	r4,r4,2
8112493c:	39c000cc 	andi	r7,r7,3
81124940:	21000044 	addi	r4,r4,1
81124944:	2109883a 	add	r4,r4,r4
81124948:	2109883a 	add	r4,r4,r4
8112494c:	1907883a 	add	r3,r3,r4
81124950:	38000526 	beq	r7,zero,81124968 <memset+0x118>
81124954:	19cf883a 	add	r7,r3,r7
81124958:	19400005 	stb	r5,0(r3)
8112495c:	18c00044 	addi	r3,r3,1
81124960:	38fffd1e 	bne	r7,r3,81124958 <__reset+0xfb104958>
81124964:	f800283a 	ret
81124968:	f800283a 	ret
8112496c:	2007883a 	mov	r3,r4
81124970:	300f883a 	mov	r7,r6
81124974:	003fc706 	br	81124894 <__reset+0xfb104894>

81124978 <_open_r>:
81124978:	defffd04 	addi	sp,sp,-12
8112497c:	de00012e 	bgeu	sp,et,81124984 <_open_r+0xc>
81124980:	003b68fa 	trap	3
81124984:	2805883a 	mov	r2,r5
81124988:	dc000015 	stw	r16,0(sp)
8112498c:	04204574 	movhi	r16,33045
81124990:	dc400115 	stw	r17,4(sp)
81124994:	300b883a 	mov	r5,r6
81124998:	8414cf04 	addi	r16,r16,21308
8112499c:	2023883a 	mov	r17,r4
811249a0:	380d883a 	mov	r6,r7
811249a4:	1009883a 	mov	r4,r2
811249a8:	dfc00215 	stw	ra,8(sp)
811249ac:	80000015 	stw	zero,0(r16)
811249b0:	11397480 	call	81139748 <open>
811249b4:	00ffffc4 	movi	r3,-1
811249b8:	10c00526 	beq	r2,r3,811249d0 <_open_r+0x58>
811249bc:	dfc00217 	ldw	ra,8(sp)
811249c0:	dc400117 	ldw	r17,4(sp)
811249c4:	dc000017 	ldw	r16,0(sp)
811249c8:	dec00304 	addi	sp,sp,12
811249cc:	f800283a 	ret
811249d0:	80c00017 	ldw	r3,0(r16)
811249d4:	183ff926 	beq	r3,zero,811249bc <__reset+0xfb1049bc>
811249d8:	88c00015 	stw	r3,0(r17)
811249dc:	003ff706 	br	811249bc <__reset+0xfb1049bc>

811249e0 <_putc_r>:
811249e0:	defffc04 	addi	sp,sp,-16
811249e4:	de00012e 	bgeu	sp,et,811249ec <_putc_r+0xc>
811249e8:	003b68fa 	trap	3
811249ec:	dc000215 	stw	r16,8(sp)
811249f0:	dfc00315 	stw	ra,12(sp)
811249f4:	2021883a 	mov	r16,r4
811249f8:	20000226 	beq	r4,zero,81124a04 <_putc_r+0x24>
811249fc:	20800e17 	ldw	r2,56(r4)
81124a00:	10001b26 	beq	r2,zero,81124a70 <_putc_r+0x90>
81124a04:	30800217 	ldw	r2,8(r6)
81124a08:	10bfffc4 	addi	r2,r2,-1
81124a0c:	30800215 	stw	r2,8(r6)
81124a10:	10000a16 	blt	r2,zero,81124a3c <_putc_r+0x5c>
81124a14:	30800017 	ldw	r2,0(r6)
81124a18:	11400005 	stb	r5,0(r2)
81124a1c:	30800017 	ldw	r2,0(r6)
81124a20:	10c00044 	addi	r3,r2,1
81124a24:	30c00015 	stw	r3,0(r6)
81124a28:	10800003 	ldbu	r2,0(r2)
81124a2c:	dfc00317 	ldw	ra,12(sp)
81124a30:	dc000217 	ldw	r16,8(sp)
81124a34:	dec00404 	addi	sp,sp,16
81124a38:	f800283a 	ret
81124a3c:	30c00617 	ldw	r3,24(r6)
81124a40:	10c00616 	blt	r2,r3,81124a5c <_putc_r+0x7c>
81124a44:	30800017 	ldw	r2,0(r6)
81124a48:	00c00284 	movi	r3,10
81124a4c:	11400005 	stb	r5,0(r2)
81124a50:	30800017 	ldw	r2,0(r6)
81124a54:	11400003 	ldbu	r5,0(r2)
81124a58:	28fff11e 	bne	r5,r3,81124a20 <__reset+0xfb104a20>
81124a5c:	8009883a 	mov	r4,r16
81124a60:	dfc00317 	ldw	ra,12(sp)
81124a64:	dc000217 	ldw	r16,8(sp)
81124a68:	dec00404 	addi	sp,sp,16
81124a6c:	112b5181 	jmpi	8112b518 <__swbuf_r>
81124a70:	d9400015 	stw	r5,0(sp)
81124a74:	d9800115 	stw	r6,4(sp)
81124a78:	112d7500 	call	8112d750 <__sinit>
81124a7c:	d9800117 	ldw	r6,4(sp)
81124a80:	d9400017 	ldw	r5,0(sp)
81124a84:	003fdf06 	br	81124a04 <__reset+0xfb104a04>

81124a88 <putc>:
81124a88:	00a04574 	movhi	r2,33045
81124a8c:	defffc04 	addi	sp,sp,-16
81124a90:	10945c04 	addi	r2,r2,20848
81124a94:	de00012e 	bgeu	sp,et,81124a9c <putc+0x14>
81124a98:	003b68fa 	trap	3
81124a9c:	dc000115 	stw	r16,4(sp)
81124aa0:	14000017 	ldw	r16,0(r2)
81124aa4:	dc400215 	stw	r17,8(sp)
81124aa8:	dfc00315 	stw	ra,12(sp)
81124aac:	2023883a 	mov	r17,r4
81124ab0:	80000226 	beq	r16,zero,81124abc <putc+0x34>
81124ab4:	80800e17 	ldw	r2,56(r16)
81124ab8:	10001a26 	beq	r2,zero,81124b24 <putc+0x9c>
81124abc:	28800217 	ldw	r2,8(r5)
81124ac0:	10bfffc4 	addi	r2,r2,-1
81124ac4:	28800215 	stw	r2,8(r5)
81124ac8:	10000b16 	blt	r2,zero,81124af8 <putc+0x70>
81124acc:	28800017 	ldw	r2,0(r5)
81124ad0:	14400005 	stb	r17,0(r2)
81124ad4:	28800017 	ldw	r2,0(r5)
81124ad8:	10c00044 	addi	r3,r2,1
81124adc:	28c00015 	stw	r3,0(r5)
81124ae0:	10800003 	ldbu	r2,0(r2)
81124ae4:	dfc00317 	ldw	ra,12(sp)
81124ae8:	dc400217 	ldw	r17,8(sp)
81124aec:	dc000117 	ldw	r16,4(sp)
81124af0:	dec00404 	addi	sp,sp,16
81124af4:	f800283a 	ret
81124af8:	28c00617 	ldw	r3,24(r5)
81124afc:	10c00e16 	blt	r2,r3,81124b38 <putc+0xb0>
81124b00:	28800017 	ldw	r2,0(r5)
81124b04:	01000284 	movi	r4,10
81124b08:	14400005 	stb	r17,0(r2)
81124b0c:	28800017 	ldw	r2,0(r5)
81124b10:	10c00003 	ldbu	r3,0(r2)
81124b14:	193ff01e 	bne	r3,r4,81124ad8 <__reset+0xfb104ad8>
81124b18:	280d883a 	mov	r6,r5
81124b1c:	180b883a 	mov	r5,r3
81124b20:	00000706 	br	81124b40 <putc+0xb8>
81124b24:	8009883a 	mov	r4,r16
81124b28:	d9400015 	stw	r5,0(sp)
81124b2c:	112d7500 	call	8112d750 <__sinit>
81124b30:	d9400017 	ldw	r5,0(sp)
81124b34:	003fe106 	br	81124abc <__reset+0xfb104abc>
81124b38:	280d883a 	mov	r6,r5
81124b3c:	880b883a 	mov	r5,r17
81124b40:	8009883a 	mov	r4,r16
81124b44:	dfc00317 	ldw	ra,12(sp)
81124b48:	dc400217 	ldw	r17,8(sp)
81124b4c:	dc000117 	ldw	r16,4(sp)
81124b50:	dec00404 	addi	sp,sp,16
81124b54:	112b5181 	jmpi	8112b518 <__swbuf_r>

81124b58 <_puts_r>:
81124b58:	defff604 	addi	sp,sp,-40
81124b5c:	de00012e 	bgeu	sp,et,81124b64 <_puts_r+0xc>
81124b60:	003b68fa 	trap	3
81124b64:	dc000715 	stw	r16,28(sp)
81124b68:	2021883a 	mov	r16,r4
81124b6c:	2809883a 	mov	r4,r5
81124b70:	dc400815 	stw	r17,32(sp)
81124b74:	dfc00915 	stw	ra,36(sp)
81124b78:	2823883a 	mov	r17,r5
81124b7c:	11251780 	call	81125178 <strlen>
81124b80:	10c00044 	addi	r3,r2,1
81124b84:	d8800115 	stw	r2,4(sp)
81124b88:	00a04574 	movhi	r2,33045
81124b8c:	108a8304 	addi	r2,r2,10764
81124b90:	d8800215 	stw	r2,8(sp)
81124b94:	00800044 	movi	r2,1
81124b98:	d8800315 	stw	r2,12(sp)
81124b9c:	00800084 	movi	r2,2
81124ba0:	dc400015 	stw	r17,0(sp)
81124ba4:	d8c00615 	stw	r3,24(sp)
81124ba8:	dec00415 	stw	sp,16(sp)
81124bac:	d8800515 	stw	r2,20(sp)
81124bb0:	80000226 	beq	r16,zero,81124bbc <_puts_r+0x64>
81124bb4:	80800e17 	ldw	r2,56(r16)
81124bb8:	10001426 	beq	r2,zero,81124c0c <_puts_r+0xb4>
81124bbc:	81400217 	ldw	r5,8(r16)
81124bc0:	2880030b 	ldhu	r2,12(r5)
81124bc4:	10c8000c 	andi	r3,r2,8192
81124bc8:	1800061e 	bne	r3,zero,81124be4 <_puts_r+0x8c>
81124bcc:	29001917 	ldw	r4,100(r5)
81124bd0:	00f7ffc4 	movi	r3,-8193
81124bd4:	10880014 	ori	r2,r2,8192
81124bd8:	20c6703a 	and	r3,r4,r3
81124bdc:	2880030d 	sth	r2,12(r5)
81124be0:	28c01915 	stw	r3,100(r5)
81124be4:	d9800404 	addi	r6,sp,16
81124be8:	8009883a 	mov	r4,r16
81124bec:	112df000 	call	8112df00 <__sfvwrite_r>
81124bf0:	1000091e 	bne	r2,zero,81124c18 <_puts_r+0xc0>
81124bf4:	00800284 	movi	r2,10
81124bf8:	dfc00917 	ldw	ra,36(sp)
81124bfc:	dc400817 	ldw	r17,32(sp)
81124c00:	dc000717 	ldw	r16,28(sp)
81124c04:	dec00a04 	addi	sp,sp,40
81124c08:	f800283a 	ret
81124c0c:	8009883a 	mov	r4,r16
81124c10:	112d7500 	call	8112d750 <__sinit>
81124c14:	003fe906 	br	81124bbc <__reset+0xfb104bbc>
81124c18:	00bfffc4 	movi	r2,-1
81124c1c:	003ff606 	br	81124bf8 <__reset+0xfb104bf8>

81124c20 <puts>:
81124c20:	00a04574 	movhi	r2,33045
81124c24:	10945c04 	addi	r2,r2,20848
81124c28:	200b883a 	mov	r5,r4
81124c2c:	11000017 	ldw	r4,0(r2)
81124c30:	1124b581 	jmpi	81124b58 <_puts_r>

81124c34 <lflush>:
81124c34:	2080030b 	ldhu	r2,12(r4)
81124c38:	00c00244 	movi	r3,9
81124c3c:	1080024c 	andi	r2,r2,9
81124c40:	10c00226 	beq	r2,r3,81124c4c <lflush+0x18>
81124c44:	0005883a 	mov	r2,zero
81124c48:	f800283a 	ret
81124c4c:	112d3b81 	jmpi	8112d3b8 <fflush>

81124c50 <__srefill_r>:
81124c50:	defffc04 	addi	sp,sp,-16
81124c54:	de00012e 	bgeu	sp,et,81124c5c <__srefill_r+0xc>
81124c58:	003b68fa 	trap	3
81124c5c:	dc400115 	stw	r17,4(sp)
81124c60:	dc000015 	stw	r16,0(sp)
81124c64:	dfc00315 	stw	ra,12(sp)
81124c68:	dc800215 	stw	r18,8(sp)
81124c6c:	2023883a 	mov	r17,r4
81124c70:	2821883a 	mov	r16,r5
81124c74:	20000226 	beq	r4,zero,81124c80 <__srefill_r+0x30>
81124c78:	20800e17 	ldw	r2,56(r4)
81124c7c:	10003c26 	beq	r2,zero,81124d70 <__srefill_r+0x120>
81124c80:	80c0030b 	ldhu	r3,12(r16)
81124c84:	1908000c 	andi	r4,r3,8192
81124c88:	1805883a 	mov	r2,r3
81124c8c:	2000071e 	bne	r4,zero,81124cac <__srefill_r+0x5c>
81124c90:	81001917 	ldw	r4,100(r16)
81124c94:	18880014 	ori	r2,r3,8192
81124c98:	00f7ffc4 	movi	r3,-8193
81124c9c:	20c8703a 	and	r4,r4,r3
81124ca0:	8080030d 	sth	r2,12(r16)
81124ca4:	1007883a 	mov	r3,r2
81124ca8:	81001915 	stw	r4,100(r16)
81124cac:	80000115 	stw	zero,4(r16)
81124cb0:	1100080c 	andi	r4,r2,32
81124cb4:	2000571e 	bne	r4,zero,81124e14 <__srefill_r+0x1c4>
81124cb8:	1100010c 	andi	r4,r2,4
81124cbc:	20001f26 	beq	r4,zero,81124d3c <__srefill_r+0xec>
81124cc0:	81400c17 	ldw	r5,48(r16)
81124cc4:	28000826 	beq	r5,zero,81124ce8 <__srefill_r+0x98>
81124cc8:	80801004 	addi	r2,r16,64
81124ccc:	28800226 	beq	r5,r2,81124cd8 <__srefill_r+0x88>
81124cd0:	8809883a 	mov	r4,r17
81124cd4:	112dbe80 	call	8112dbe8 <_free_r>
81124cd8:	80800f17 	ldw	r2,60(r16)
81124cdc:	80000c15 	stw	zero,48(r16)
81124ce0:	80800115 	stw	r2,4(r16)
81124ce4:	1000391e 	bne	r2,zero,81124dcc <__srefill_r+0x17c>
81124ce8:	80800417 	ldw	r2,16(r16)
81124cec:	10004b26 	beq	r2,zero,81124e1c <__srefill_r+0x1cc>
81124cf0:	8480030b 	ldhu	r18,12(r16)
81124cf4:	908000cc 	andi	r2,r18,3
81124cf8:	10001f1e 	bne	r2,zero,81124d78 <__srefill_r+0x128>
81124cfc:	81800417 	ldw	r6,16(r16)
81124d00:	80800817 	ldw	r2,32(r16)
81124d04:	81c00517 	ldw	r7,20(r16)
81124d08:	81400717 	ldw	r5,28(r16)
81124d0c:	81800015 	stw	r6,0(r16)
81124d10:	8809883a 	mov	r4,r17
81124d14:	103ee83a 	callr	r2
81124d18:	80800115 	stw	r2,4(r16)
81124d1c:	00800e0e 	bge	zero,r2,81124d58 <__srefill_r+0x108>
81124d20:	0005883a 	mov	r2,zero
81124d24:	dfc00317 	ldw	ra,12(sp)
81124d28:	dc800217 	ldw	r18,8(sp)
81124d2c:	dc400117 	ldw	r17,4(sp)
81124d30:	dc000017 	ldw	r16,0(sp)
81124d34:	dec00404 	addi	sp,sp,16
81124d38:	f800283a 	ret
81124d3c:	1100040c 	andi	r4,r2,16
81124d40:	20003026 	beq	r4,zero,81124e04 <__srefill_r+0x1b4>
81124d44:	1080020c 	andi	r2,r2,8
81124d48:	1000241e 	bne	r2,zero,81124ddc <__srefill_r+0x18c>
81124d4c:	18c00114 	ori	r3,r3,4
81124d50:	80c0030d 	sth	r3,12(r16)
81124d54:	003fe406 	br	81124ce8 <__reset+0xfb104ce8>
81124d58:	80c0030b 	ldhu	r3,12(r16)
81124d5c:	1000161e 	bne	r2,zero,81124db8 <__srefill_r+0x168>
81124d60:	18c00814 	ori	r3,r3,32
81124d64:	00bfffc4 	movi	r2,-1
81124d68:	80c0030d 	sth	r3,12(r16)
81124d6c:	003fed06 	br	81124d24 <__reset+0xfb104d24>
81124d70:	112d7500 	call	8112d750 <__sinit>
81124d74:	003fc206 	br	81124c80 <__reset+0xfb104c80>
81124d78:	00a04574 	movhi	r2,33045
81124d7c:	10945b04 	addi	r2,r2,20844
81124d80:	11000017 	ldw	r4,0(r2)
81124d84:	016044b4 	movhi	r5,33042
81124d88:	00800044 	movi	r2,1
81124d8c:	29530d04 	addi	r5,r5,19508
81124d90:	8080030d 	sth	r2,12(r16)
81124d94:	112e3c40 	call	8112e3c4 <_fwalk>
81124d98:	00800244 	movi	r2,9
81124d9c:	8480030d 	sth	r18,12(r16)
81124da0:	9480024c 	andi	r18,r18,9
81124da4:	90bfd51e 	bne	r18,r2,81124cfc <__reset+0xfb104cfc>
81124da8:	800b883a 	mov	r5,r16
81124dac:	8809883a 	mov	r4,r17
81124db0:	112d1300 	call	8112d130 <__sflush_r>
81124db4:	003fd106 	br	81124cfc <__reset+0xfb104cfc>
81124db8:	18c01014 	ori	r3,r3,64
81124dbc:	80000115 	stw	zero,4(r16)
81124dc0:	00bfffc4 	movi	r2,-1
81124dc4:	80c0030d 	sth	r3,12(r16)
81124dc8:	003fd606 	br	81124d24 <__reset+0xfb104d24>
81124dcc:	80c00e17 	ldw	r3,56(r16)
81124dd0:	0005883a 	mov	r2,zero
81124dd4:	80c00015 	stw	r3,0(r16)
81124dd8:	003fd206 	br	81124d24 <__reset+0xfb104d24>
81124ddc:	800b883a 	mov	r5,r16
81124de0:	8809883a 	mov	r4,r17
81124de4:	112d3540 	call	8112d354 <_fflush_r>
81124de8:	10000a1e 	bne	r2,zero,81124e14 <__srefill_r+0x1c4>
81124dec:	8080030b 	ldhu	r2,12(r16)
81124df0:	00fffdc4 	movi	r3,-9
81124df4:	80000215 	stw	zero,8(r16)
81124df8:	1886703a 	and	r3,r3,r2
81124dfc:	80000615 	stw	zero,24(r16)
81124e00:	003fd206 	br	81124d4c <__reset+0xfb104d4c>
81124e04:	00800244 	movi	r2,9
81124e08:	88800015 	stw	r2,0(r17)
81124e0c:	18c01014 	ori	r3,r3,64
81124e10:	80c0030d 	sth	r3,12(r16)
81124e14:	00bfffc4 	movi	r2,-1
81124e18:	003fc206 	br	81124d24 <__reset+0xfb104d24>
81124e1c:	800b883a 	mov	r5,r16
81124e20:	8809883a 	mov	r4,r17
81124e24:	1123d280 	call	81123d28 <__smakebuf_r>
81124e28:	003fb106 	br	81124cf0 <__reset+0xfb104cf0>

81124e2c <_sbrk_r>:
81124e2c:	defffd04 	addi	sp,sp,-12
81124e30:	de00012e 	bgeu	sp,et,81124e38 <_sbrk_r+0xc>
81124e34:	003b68fa 	trap	3
81124e38:	dc000015 	stw	r16,0(sp)
81124e3c:	04204574 	movhi	r16,33045
81124e40:	dc400115 	stw	r17,4(sp)
81124e44:	8414cf04 	addi	r16,r16,21308
81124e48:	2023883a 	mov	r17,r4
81124e4c:	2809883a 	mov	r4,r5
81124e50:	dfc00215 	stw	ra,8(sp)
81124e54:	80000015 	stw	zero,0(r16)
81124e58:	1139a580 	call	81139a58 <sbrk>
81124e5c:	00ffffc4 	movi	r3,-1
81124e60:	10c00526 	beq	r2,r3,81124e78 <_sbrk_r+0x4c>
81124e64:	dfc00217 	ldw	ra,8(sp)
81124e68:	dc400117 	ldw	r17,4(sp)
81124e6c:	dc000017 	ldw	r16,0(sp)
81124e70:	dec00304 	addi	sp,sp,12
81124e74:	f800283a 	ret
81124e78:	80c00017 	ldw	r3,0(r16)
81124e7c:	183ff926 	beq	r3,zero,81124e64 <__reset+0xfb104e64>
81124e80:	88c00015 	stw	r3,0(r17)
81124e84:	003ff706 	br	81124e64 <__reset+0xfb104e64>

81124e88 <scanf>:
81124e88:	defffc04 	addi	sp,sp,-16
81124e8c:	de00012e 	bgeu	sp,et,81124e94 <scanf+0xc>
81124e90:	003b68fa 	trap	3
81124e94:	dfc00015 	stw	ra,0(sp)
81124e98:	d9400115 	stw	r5,4(sp)
81124e9c:	d9800215 	stw	r6,8(sp)
81124ea0:	d9c00315 	stw	r7,12(sp)
81124ea4:	00a04574 	movhi	r2,33045
81124ea8:	10945c04 	addi	r2,r2,20848
81124eac:	200d883a 	mov	r6,r4
81124eb0:	11000017 	ldw	r4,0(r2)
81124eb4:	d9c00104 	addi	r7,sp,4
81124eb8:	21400117 	ldw	r5,4(r4)
81124ebc:	112b4c40 	call	8112b4c4 <_vfscanf_r>
81124ec0:	dfc00017 	ldw	ra,0(sp)
81124ec4:	dec00404 	addi	sp,sp,16
81124ec8:	f800283a 	ret

81124ecc <_scanf_r>:
81124ecc:	defffd04 	addi	sp,sp,-12
81124ed0:	2805883a 	mov	r2,r5
81124ed4:	de00012e 	bgeu	sp,et,81124edc <_scanf_r+0x10>
81124ed8:	003b68fa 	trap	3
81124edc:	dfc00015 	stw	ra,0(sp)
81124ee0:	d9800115 	stw	r6,4(sp)
81124ee4:	d9c00215 	stw	r7,8(sp)
81124ee8:	21400117 	ldw	r5,4(r4)
81124eec:	d9c00104 	addi	r7,sp,4
81124ef0:	100d883a 	mov	r6,r2
81124ef4:	112b4c40 	call	8112b4c4 <_vfscanf_r>
81124ef8:	dfc00017 	ldw	ra,0(sp)
81124efc:	dec00304 	addi	sp,sp,12
81124f00:	f800283a 	ret

81124f04 <_sprintf_r>:
81124f04:	deffe404 	addi	sp,sp,-112
81124f08:	2807883a 	mov	r3,r5
81124f0c:	de00012e 	bgeu	sp,et,81124f14 <_sprintf_r+0x10>
81124f10:	003b68fa 	trap	3
81124f14:	dfc01a15 	stw	ra,104(sp)
81124f18:	d9c01b15 	stw	r7,108(sp)
81124f1c:	00a00034 	movhi	r2,32768
81124f20:	10bfffc4 	addi	r2,r2,-1
81124f24:	02008204 	movi	r8,520
81124f28:	d8800215 	stw	r2,8(sp)
81124f2c:	d8800515 	stw	r2,20(sp)
81124f30:	d9c01b04 	addi	r7,sp,108
81124f34:	d80b883a 	mov	r5,sp
81124f38:	00bfffc4 	movi	r2,-1
81124f3c:	d8c00015 	stw	r3,0(sp)
81124f40:	d8c00415 	stw	r3,16(sp)
81124f44:	da00030d 	sth	r8,12(sp)
81124f48:	d880038d 	sth	r2,14(sp)
81124f4c:	11257b40 	call	811257b4 <___svfprintf_internal_r>
81124f50:	d8c00017 	ldw	r3,0(sp)
81124f54:	18000005 	stb	zero,0(r3)
81124f58:	dfc01a17 	ldw	ra,104(sp)
81124f5c:	dec01c04 	addi	sp,sp,112
81124f60:	f800283a 	ret

81124f64 <sprintf>:
81124f64:	deffe304 	addi	sp,sp,-116
81124f68:	2007883a 	mov	r3,r4
81124f6c:	de00012e 	bgeu	sp,et,81124f74 <sprintf+0x10>
81124f70:	003b68fa 	trap	3
81124f74:	dfc01a15 	stw	ra,104(sp)
81124f78:	d9801b15 	stw	r6,108(sp)
81124f7c:	d9c01c15 	stw	r7,112(sp)
81124f80:	01204574 	movhi	r4,33045
81124f84:	21145c04 	addi	r4,r4,20848
81124f88:	21000017 	ldw	r4,0(r4)
81124f8c:	00a00034 	movhi	r2,32768
81124f90:	10bfffc4 	addi	r2,r2,-1
81124f94:	280d883a 	mov	r6,r5
81124f98:	02008204 	movi	r8,520
81124f9c:	d8800215 	stw	r2,8(sp)
81124fa0:	d8800515 	stw	r2,20(sp)
81124fa4:	d9c01b04 	addi	r7,sp,108
81124fa8:	d80b883a 	mov	r5,sp
81124fac:	00bfffc4 	movi	r2,-1
81124fb0:	d8c00015 	stw	r3,0(sp)
81124fb4:	d8c00415 	stw	r3,16(sp)
81124fb8:	da00030d 	sth	r8,12(sp)
81124fbc:	d880038d 	sth	r2,14(sp)
81124fc0:	11257b40 	call	811257b4 <___svfprintf_internal_r>
81124fc4:	d8c00017 	ldw	r3,0(sp)
81124fc8:	18000005 	stb	zero,0(r3)
81124fcc:	dfc01a17 	ldw	ra,104(sp)
81124fd0:	dec01d04 	addi	sp,sp,116
81124fd4:	f800283a 	ret

81124fd8 <__sread>:
81124fd8:	defffe04 	addi	sp,sp,-8
81124fdc:	de00012e 	bgeu	sp,et,81124fe4 <__sread+0xc>
81124fe0:	003b68fa 	trap	3
81124fe4:	dc000015 	stw	r16,0(sp)
81124fe8:	2821883a 	mov	r16,r5
81124fec:	2940038f 	ldh	r5,14(r5)
81124ff0:	dfc00115 	stw	ra,4(sp)
81124ff4:	112fc140 	call	8112fc14 <_read_r>
81124ff8:	10000716 	blt	r2,zero,81125018 <__sread+0x40>
81124ffc:	80c01417 	ldw	r3,80(r16)
81125000:	1887883a 	add	r3,r3,r2
81125004:	80c01415 	stw	r3,80(r16)
81125008:	dfc00117 	ldw	ra,4(sp)
8112500c:	dc000017 	ldw	r16,0(sp)
81125010:	dec00204 	addi	sp,sp,8
81125014:	f800283a 	ret
81125018:	80c0030b 	ldhu	r3,12(r16)
8112501c:	18fbffcc 	andi	r3,r3,61439
81125020:	80c0030d 	sth	r3,12(r16)
81125024:	dfc00117 	ldw	ra,4(sp)
81125028:	dc000017 	ldw	r16,0(sp)
8112502c:	dec00204 	addi	sp,sp,8
81125030:	f800283a 	ret

81125034 <__seofread>:
81125034:	0005883a 	mov	r2,zero
81125038:	f800283a 	ret

8112503c <__swrite>:
8112503c:	defffb04 	addi	sp,sp,-20
81125040:	de00012e 	bgeu	sp,et,81125048 <__swrite+0xc>
81125044:	003b68fa 	trap	3
81125048:	2880030b 	ldhu	r2,12(r5)
8112504c:	dcc00315 	stw	r19,12(sp)
81125050:	dc800215 	stw	r18,8(sp)
81125054:	dc400115 	stw	r17,4(sp)
81125058:	dc000015 	stw	r16,0(sp)
8112505c:	dfc00415 	stw	ra,16(sp)
81125060:	10c0400c 	andi	r3,r2,256
81125064:	2821883a 	mov	r16,r5
81125068:	2023883a 	mov	r17,r4
8112506c:	3025883a 	mov	r18,r6
81125070:	3827883a 	mov	r19,r7
81125074:	18000526 	beq	r3,zero,8112508c <__swrite+0x50>
81125078:	2940038f 	ldh	r5,14(r5)
8112507c:	01c00084 	movi	r7,2
81125080:	000d883a 	mov	r6,zero
81125084:	112e6cc0 	call	8112e6cc <_lseek_r>
81125088:	8080030b 	ldhu	r2,12(r16)
8112508c:	8140038f 	ldh	r5,14(r16)
81125090:	10bbffcc 	andi	r2,r2,61439
81125094:	980f883a 	mov	r7,r19
81125098:	900d883a 	mov	r6,r18
8112509c:	8809883a 	mov	r4,r17
811250a0:	8080030d 	sth	r2,12(r16)
811250a4:	dfc00417 	ldw	ra,16(sp)
811250a8:	dcc00317 	ldw	r19,12(sp)
811250ac:	dc800217 	ldw	r18,8(sp)
811250b0:	dc400117 	ldw	r17,4(sp)
811250b4:	dc000017 	ldw	r16,0(sp)
811250b8:	dec00504 	addi	sp,sp,20
811250bc:	112b6781 	jmpi	8112b678 <_write_r>

811250c0 <__sseek>:
811250c0:	defffe04 	addi	sp,sp,-8
811250c4:	de00012e 	bgeu	sp,et,811250cc <__sseek+0xc>
811250c8:	003b68fa 	trap	3
811250cc:	dc000015 	stw	r16,0(sp)
811250d0:	2821883a 	mov	r16,r5
811250d4:	2940038f 	ldh	r5,14(r5)
811250d8:	dfc00115 	stw	ra,4(sp)
811250dc:	112e6cc0 	call	8112e6cc <_lseek_r>
811250e0:	00ffffc4 	movi	r3,-1
811250e4:	10c00826 	beq	r2,r3,81125108 <__sseek+0x48>
811250e8:	80c0030b 	ldhu	r3,12(r16)
811250ec:	80801415 	stw	r2,80(r16)
811250f0:	18c40014 	ori	r3,r3,4096
811250f4:	80c0030d 	sth	r3,12(r16)
811250f8:	dfc00117 	ldw	ra,4(sp)
811250fc:	dc000017 	ldw	r16,0(sp)
81125100:	dec00204 	addi	sp,sp,8
81125104:	f800283a 	ret
81125108:	80c0030b 	ldhu	r3,12(r16)
8112510c:	18fbffcc 	andi	r3,r3,61439
81125110:	80c0030d 	sth	r3,12(r16)
81125114:	dfc00117 	ldw	ra,4(sp)
81125118:	dc000017 	ldw	r16,0(sp)
8112511c:	dec00204 	addi	sp,sp,8
81125120:	f800283a 	ret

81125124 <__sclose>:
81125124:	2940038f 	ldh	r5,14(r5)
81125128:	112b83c1 	jmpi	8112b83c <_close_r>

8112512c <strcspn>:
8112512c:	21c00007 	ldb	r7,0(r4)
81125130:	38000f26 	beq	r7,zero,81125170 <strcspn+0x44>
81125134:	2a000007 	ldb	r8,0(r5)
81125138:	2005883a 	mov	r2,r4
8112513c:	40000726 	beq	r8,zero,8112515c <strcspn+0x30>
81125140:	3a000926 	beq	r7,r8,81125168 <strcspn+0x3c>
81125144:	2807883a 	mov	r3,r5
81125148:	00000106 	br	81125150 <strcspn+0x24>
8112514c:	31c00626 	beq	r6,r7,81125168 <strcspn+0x3c>
81125150:	18c00044 	addi	r3,r3,1
81125154:	19800007 	ldb	r6,0(r3)
81125158:	303ffc1e 	bne	r6,zero,8112514c <__reset+0xfb10514c>
8112515c:	10800044 	addi	r2,r2,1
81125160:	11c00007 	ldb	r7,0(r2)
81125164:	383ff51e 	bne	r7,zero,8112513c <__reset+0xfb10513c>
81125168:	1105c83a 	sub	r2,r2,r4
8112516c:	f800283a 	ret
81125170:	0005883a 	mov	r2,zero
81125174:	f800283a 	ret

81125178 <strlen>:
81125178:	208000cc 	andi	r2,r4,3
8112517c:	10002026 	beq	r2,zero,81125200 <strlen+0x88>
81125180:	20800007 	ldb	r2,0(r4)
81125184:	10002026 	beq	r2,zero,81125208 <strlen+0x90>
81125188:	2005883a 	mov	r2,r4
8112518c:	00000206 	br	81125198 <strlen+0x20>
81125190:	10c00007 	ldb	r3,0(r2)
81125194:	18001826 	beq	r3,zero,811251f8 <strlen+0x80>
81125198:	10800044 	addi	r2,r2,1
8112519c:	10c000cc 	andi	r3,r2,3
811251a0:	183ffb1e 	bne	r3,zero,81125190 <__reset+0xfb105190>
811251a4:	10c00017 	ldw	r3,0(r2)
811251a8:	01ffbff4 	movhi	r7,65279
811251ac:	39ffbfc4 	addi	r7,r7,-257
811251b0:	00ca303a 	nor	r5,zero,r3
811251b4:	01a02074 	movhi	r6,32897
811251b8:	19c7883a 	add	r3,r3,r7
811251bc:	31a02004 	addi	r6,r6,-32640
811251c0:	1946703a 	and	r3,r3,r5
811251c4:	1986703a 	and	r3,r3,r6
811251c8:	1800091e 	bne	r3,zero,811251f0 <strlen+0x78>
811251cc:	10800104 	addi	r2,r2,4
811251d0:	10c00017 	ldw	r3,0(r2)
811251d4:	19cb883a 	add	r5,r3,r7
811251d8:	00c6303a 	nor	r3,zero,r3
811251dc:	28c6703a 	and	r3,r5,r3
811251e0:	1986703a 	and	r3,r3,r6
811251e4:	183ff926 	beq	r3,zero,811251cc <__reset+0xfb1051cc>
811251e8:	00000106 	br	811251f0 <strlen+0x78>
811251ec:	10800044 	addi	r2,r2,1
811251f0:	10c00007 	ldb	r3,0(r2)
811251f4:	183ffd1e 	bne	r3,zero,811251ec <__reset+0xfb1051ec>
811251f8:	1105c83a 	sub	r2,r2,r4
811251fc:	f800283a 	ret
81125200:	2005883a 	mov	r2,r4
81125204:	003fe706 	br	811251a4 <__reset+0xfb1051a4>
81125208:	0005883a 	mov	r2,zero
8112520c:	f800283a 	ret

81125210 <strnlen>:
81125210:	28000e26 	beq	r5,zero,8112524c <strnlen+0x3c>
81125214:	20800007 	ldb	r2,0(r4)
81125218:	10000c26 	beq	r2,zero,8112524c <strnlen+0x3c>
8112521c:	20c00044 	addi	r3,r4,1
81125220:	214b883a 	add	r5,r4,r5
81125224:	28c00526 	beq	r5,r3,8112523c <strnlen+0x2c>
81125228:	19800007 	ldb	r6,0(r3)
8112522c:	19c00044 	addi	r7,r3,1
81125230:	30000426 	beq	r6,zero,81125244 <strnlen+0x34>
81125234:	3807883a 	mov	r3,r7
81125238:	28fffb1e 	bne	r5,r3,81125228 <__reset+0xfb105228>
8112523c:	2905c83a 	sub	r2,r5,r4
81125240:	f800283a 	ret
81125244:	1905c83a 	sub	r2,r3,r4
81125248:	f800283a 	ret
8112524c:	0005883a 	mov	r2,zero
81125250:	f800283a 	ret

81125254 <_strtol_r>:
81125254:	00a04574 	movhi	r2,33045
81125258:	defff404 	addi	sp,sp,-48
8112525c:	10945a04 	addi	r2,r2,20840
81125260:	de00012e 	bgeu	sp,et,81125268 <_strtol_r+0x14>
81125264:	003b68fa 	trap	3
81125268:	dd400715 	stw	r21,28(sp)
8112526c:	15400017 	ldw	r21,0(r2)
81125270:	dd800815 	stw	r22,32(sp)
81125274:	dd000615 	stw	r20,24(sp)
81125278:	dcc00515 	stw	r19,20(sp)
8112527c:	d9000015 	stw	r4,0(sp)
81125280:	dfc00b15 	stw	ra,44(sp)
81125284:	df000a15 	stw	fp,40(sp)
81125288:	ddc00915 	stw	r23,36(sp)
8112528c:	dc800415 	stw	r18,16(sp)
81125290:	dc400315 	stw	r17,12(sp)
81125294:	dc000215 	stw	r16,8(sp)
81125298:	2829883a 	mov	r20,r5
8112529c:	3027883a 	mov	r19,r6
811252a0:	382d883a 	mov	r22,r7
811252a4:	2809883a 	mov	r4,r5
811252a8:	24000003 	ldbu	r16,0(r4)
811252ac:	24400044 	addi	r17,r4,1
811252b0:	2007883a 	mov	r3,r4
811252b4:	ac05883a 	add	r2,r21,r16
811252b8:	10800043 	ldbu	r2,1(r2)
811252bc:	8809883a 	mov	r4,r17
811252c0:	1080020c 	andi	r2,r2,8
811252c4:	103ff81e 	bne	r2,zero,811252a8 <__reset+0xfb1052a8>
811252c8:	00800b44 	movi	r2,45
811252cc:	80805826 	beq	r16,r2,81125430 <_strtol_r+0x1dc>
811252d0:	00800ac4 	movi	r2,43
811252d4:	80805a26 	beq	r16,r2,81125440 <_strtol_r+0x1ec>
811252d8:	0039883a 	mov	fp,zero
811252dc:	b0004426 	beq	r22,zero,811253f0 <_strtol_r+0x19c>
811252e0:	00800404 	movi	r2,16
811252e4:	b0806026 	beq	r22,r2,81125468 <_strtol_r+0x214>
811252e8:	b02f883a 	mov	r23,r22
811252ec:	00a00034 	movhi	r2,32768
811252f0:	e025003a 	cmpeq	r18,fp,zero
811252f4:	14a5c83a 	sub	r18,r2,r18
811252f8:	b80b883a 	mov	r5,r23
811252fc:	9009883a 	mov	r4,r18
81125300:	1136c700 	call	81136c70 <__umodsi3>
81125304:	b80b883a 	mov	r5,r23
81125308:	9009883a 	mov	r4,r18
8112530c:	d8800115 	stw	r2,4(sp)
81125310:	1136c0c0 	call	81136c0c <__udivsi3>
81125314:	ac07883a 	add	r3,r21,r16
81125318:	18c00043 	ldbu	r3,1(r3)
8112531c:	880b883a 	mov	r5,r17
81125320:	000d883a 	mov	r6,zero
81125324:	1a00010c 	andi	r8,r3,4
81125328:	0009883a 	mov	r4,zero
8112532c:	02800044 	movi	r10,1
81125330:	027fffc4 	movi	r9,-1
81125334:	d9c00117 	ldw	r7,4(sp)
81125338:	40000e26 	beq	r8,zero,81125374 <_strtol_r+0x120>
8112533c:	843ff404 	addi	r16,r16,-48
81125340:	8580120e 	bge	r16,r22,8112538c <_strtol_r+0x138>
81125344:	32400526 	beq	r6,r9,8112535c <_strtol_r+0x108>
81125348:	11002536 	bltu	r2,r4,811253e0 <_strtol_r+0x18c>
8112534c:	20802326 	beq	r4,r2,811253dc <_strtol_r+0x188>
81125350:	25c9383a 	mul	r4,r4,r23
81125354:	01800044 	movi	r6,1
81125358:	8109883a 	add	r4,r16,r4
8112535c:	2c000003 	ldbu	r16,0(r5)
81125360:	29400044 	addi	r5,r5,1
81125364:	ac07883a 	add	r3,r21,r16
81125368:	18c00043 	ldbu	r3,1(r3)
8112536c:	1a00010c 	andi	r8,r3,4
81125370:	403ff21e 	bne	r8,zero,8112533c <__reset+0xfb10533c>
81125374:	18c000cc 	andi	r3,r3,3
81125378:	18000426 	beq	r3,zero,8112538c <_strtol_r+0x138>
8112537c:	1a801a26 	beq	r3,r10,811253e8 <_strtol_r+0x194>
81125380:	00c015c4 	movi	r3,87
81125384:	80e1c83a 	sub	r16,r16,r3
81125388:	85bfee16 	blt	r16,r22,81125344 <__reset+0xfb105344>
8112538c:	00bfffc4 	movi	r2,-1
81125390:	30801e26 	beq	r6,r2,8112540c <_strtol_r+0x1b8>
81125394:	e0001b1e 	bne	fp,zero,81125404 <_strtol_r+0x1b0>
81125398:	2005883a 	mov	r2,r4
8112539c:	98000326 	beq	r19,zero,811253ac <_strtol_r+0x158>
811253a0:	3000211e 	bne	r6,zero,81125428 <_strtol_r+0x1d4>
811253a4:	a00b883a 	mov	r5,r20
811253a8:	99400015 	stw	r5,0(r19)
811253ac:	dfc00b17 	ldw	ra,44(sp)
811253b0:	df000a17 	ldw	fp,40(sp)
811253b4:	ddc00917 	ldw	r23,36(sp)
811253b8:	dd800817 	ldw	r22,32(sp)
811253bc:	dd400717 	ldw	r21,28(sp)
811253c0:	dd000617 	ldw	r20,24(sp)
811253c4:	dcc00517 	ldw	r19,20(sp)
811253c8:	dc800417 	ldw	r18,16(sp)
811253cc:	dc400317 	ldw	r17,12(sp)
811253d0:	dc000217 	ldw	r16,8(sp)
811253d4:	dec00c04 	addi	sp,sp,48
811253d8:	f800283a 	ret
811253dc:	3c3fdc0e 	bge	r7,r16,81125350 <__reset+0xfb105350>
811253e0:	01bfffc4 	movi	r6,-1
811253e4:	003fdd06 	br	8112535c <__reset+0xfb10535c>
811253e8:	00c00dc4 	movi	r3,55
811253ec:	003fe506 	br	81125384 <__reset+0xfb105384>
811253f0:	00800c04 	movi	r2,48
811253f4:	80801626 	beq	r16,r2,81125450 <_strtol_r+0x1fc>
811253f8:	05800284 	movi	r22,10
811253fc:	b02f883a 	mov	r23,r22
81125400:	003fba06 	br	811252ec <__reset+0xfb1052ec>
81125404:	0109c83a 	sub	r4,zero,r4
81125408:	003fe306 	br	81125398 <__reset+0xfb105398>
8112540c:	d9000017 	ldw	r4,0(sp)
81125410:	00c00884 	movi	r3,34
81125414:	e005003a 	cmpeq	r2,fp,zero
81125418:	20c00015 	stw	r3,0(r4)
8112541c:	00e00034 	movhi	r3,32768
81125420:	1885c83a 	sub	r2,r3,r2
81125424:	983fe126 	beq	r19,zero,811253ac <__reset+0xfb1053ac>
81125428:	297fffc4 	addi	r5,r5,-1
8112542c:	003fde06 	br	811253a8 <__reset+0xfb1053a8>
81125430:	1c400084 	addi	r17,r3,2
81125434:	1c000043 	ldbu	r16,1(r3)
81125438:	07000044 	movi	fp,1
8112543c:	003fa706 	br	811252dc <__reset+0xfb1052dc>
81125440:	1c400084 	addi	r17,r3,2
81125444:	1c000043 	ldbu	r16,1(r3)
81125448:	0039883a 	mov	fp,zero
8112544c:	003fa306 	br	811252dc <__reset+0xfb1052dc>
81125450:	88800003 	ldbu	r2,0(r17)
81125454:	00c01604 	movi	r3,88
81125458:	108037cc 	andi	r2,r2,223
8112545c:	10c00826 	beq	r2,r3,81125480 <_strtol_r+0x22c>
81125460:	05800204 	movi	r22,8
81125464:	003fa006 	br	811252e8 <__reset+0xfb1052e8>
81125468:	00800c04 	movi	r2,48
8112546c:	80bf9e1e 	bne	r16,r2,811252e8 <__reset+0xfb1052e8>
81125470:	88800003 	ldbu	r2,0(r17)
81125474:	00c01604 	movi	r3,88
81125478:	108037cc 	andi	r2,r2,223
8112547c:	10ff9a1e 	bne	r2,r3,811252e8 <__reset+0xfb1052e8>
81125480:	05c00404 	movi	r23,16
81125484:	8c000043 	ldbu	r16,1(r17)
81125488:	b82d883a 	mov	r22,r23
8112548c:	8c400084 	addi	r17,r17,2
81125490:	003f9606 	br	811252ec <__reset+0xfb1052ec>

81125494 <strtol>:
81125494:	00a04574 	movhi	r2,33045
81125498:	10945c04 	addi	r2,r2,20848
8112549c:	300f883a 	mov	r7,r6
811254a0:	280d883a 	mov	r6,r5
811254a4:	200b883a 	mov	r5,r4
811254a8:	11000017 	ldw	r4,0(r2)
811254ac:	11252541 	jmpi	81125254 <_strtol_r>

811254b0 <strtoll>:
811254b0:	00a04574 	movhi	r2,33045
811254b4:	10945c04 	addi	r2,r2,20848
811254b8:	300f883a 	mov	r7,r6
811254bc:	280d883a 	mov	r6,r5
811254c0:	200b883a 	mov	r5,r4
811254c4:	11000017 	ldw	r4,0(r2)
811254c8:	11254cc1 	jmpi	811254cc <_strtoll_r>

811254cc <_strtoll_r>:
811254cc:	00a04574 	movhi	r2,33045
811254d0:	defff304 	addi	sp,sp,-52
811254d4:	10945a04 	addi	r2,r2,20840
811254d8:	de00012e 	bgeu	sp,et,811254e0 <_strtoll_r+0x14>
811254dc:	003b68fa 	trap	3
811254e0:	dc800515 	stw	r18,20(sp)
811254e4:	14800017 	ldw	r18,0(r2)
811254e8:	dd800915 	stw	r22,36(sp)
811254ec:	dd400815 	stw	r21,32(sp)
811254f0:	dcc00615 	stw	r19,24(sp)
811254f4:	d9000015 	stw	r4,0(sp)
811254f8:	dfc00c15 	stw	ra,48(sp)
811254fc:	df000b15 	stw	fp,44(sp)
81125500:	ddc00a15 	stw	r23,40(sp)
81125504:	dd000715 	stw	r20,28(sp)
81125508:	dc400415 	stw	r17,16(sp)
8112550c:	dc000315 	stw	r16,12(sp)
81125510:	282d883a 	mov	r22,r5
81125514:	302b883a 	mov	r21,r6
81125518:	3827883a 	mov	r19,r7
8112551c:	2809883a 	mov	r4,r5
81125520:	24000003 	ldbu	r16,0(r4)
81125524:	24400044 	addi	r17,r4,1
81125528:	2007883a 	mov	r3,r4
8112552c:	9405883a 	add	r2,r18,r16
81125530:	10800043 	ldbu	r2,1(r2)
81125534:	8809883a 	mov	r4,r17
81125538:	1080020c 	andi	r2,r2,8
8112553c:	103ff81e 	bne	r2,zero,81125520 <__reset+0xfb105520>
81125540:	00800b44 	movi	r2,45
81125544:	80807826 	beq	r16,r2,81125728 <_strtoll_r+0x25c>
81125548:	00800ac4 	movi	r2,43
8112554c:	80807a26 	beq	r16,r2,81125738 <_strtoll_r+0x26c>
81125550:	0039883a 	mov	fp,zero
81125554:	98004e26 	beq	r19,zero,81125690 <_strtoll_r+0x1c4>
81125558:	00800404 	movi	r2,16
8112555c:	98808226 	beq	r19,r2,81125768 <_strtoll_r+0x29c>
81125560:	982fd7fa 	srai	r23,r19,31
81125564:	9829883a 	mov	r20,r19
81125568:	e0004f26 	beq	fp,zero,811256a8 <_strtoll_r+0x1dc>
8112556c:	0017883a 	mov	r11,zero
81125570:	02a00034 	movhi	r10,32768
81125574:	5809883a 	mov	r4,r11
81125578:	500b883a 	mov	r5,r10
8112557c:	a00d883a 	mov	r6,r20
81125580:	b80f883a 	mov	r7,r23
81125584:	da800215 	stw	r10,8(sp)
81125588:	dac00115 	stw	r11,4(sp)
8112558c:	11365d40 	call	811365d4 <__umoddi3>
81125590:	dac00117 	ldw	r11,4(sp)
81125594:	da800217 	ldw	r10,8(sp)
81125598:	a00d883a 	mov	r6,r20
8112559c:	5809883a 	mov	r4,r11
811255a0:	500b883a 	mov	r5,r10
811255a4:	b80f883a 	mov	r7,r23
811255a8:	d8800115 	stw	r2,4(sp)
811255ac:	11360540 	call	81136054 <__udivdi3>
811255b0:	9409883a 	add	r4,r18,r16
811255b4:	21000043 	ldbu	r4,1(r4)
811255b8:	1019883a 	mov	r12,r2
811255bc:	880b883a 	mov	r5,r17
811255c0:	2240010c 	andi	r9,r4,4
811255c4:	0015883a 	mov	r10,zero
811255c8:	000d883a 	mov	r6,zero
811255cc:	000f883a 	mov	r7,zero
811255d0:	03400044 	movi	r13,1
811255d4:	02ffffc4 	movi	r11,-1
811255d8:	da000117 	ldw	r8,4(sp)
811255dc:	48000d26 	beq	r9,zero,81125614 <_strtoll_r+0x148>
811255e0:	843ff404 	addi	r16,r16,-48
811255e4:	84c0110e 	bge	r16,r19,8112562c <_strtoll_r+0x160>
811255e8:	52c00426 	beq	r10,r11,811255fc <_strtoll_r+0x130>
811255ec:	19c00236 	bltu	r3,r7,811255f8 <_strtoll_r+0x12c>
811255f0:	38c0311e 	bne	r7,r3,811256b8 <_strtoll_r+0x1ec>
811255f4:	6180302e 	bgeu	r12,r6,811256b8 <_strtoll_r+0x1ec>
811255f8:	02bfffc4 	movi	r10,-1
811255fc:	2c000003 	ldbu	r16,0(r5)
81125600:	29400044 	addi	r5,r5,1
81125604:	9409883a 	add	r4,r18,r16
81125608:	21000043 	ldbu	r4,1(r4)
8112560c:	2240010c 	andi	r9,r4,4
81125610:	483ff31e 	bne	r9,zero,811255e0 <__reset+0xfb1055e0>
81125614:	210000cc 	andi	r4,r4,3
81125618:	20000426 	beq	r4,zero,8112562c <_strtoll_r+0x160>
8112561c:	23403426 	beq	r4,r13,811256f0 <_strtoll_r+0x224>
81125620:	008015c4 	movi	r2,87
81125624:	80a1c83a 	sub	r16,r16,r2
81125628:	84ffef16 	blt	r16,r19,811255e8 <__reset+0xfb1055e8>
8112562c:	00bfffc4 	movi	r2,-1
81125630:	50803426 	beq	r10,r2,81125704 <_strtoll_r+0x238>
81125634:	e0000426 	beq	fp,zero,81125648 <_strtoll_r+0x17c>
81125638:	018dc83a 	sub	r6,zero,r6
8112563c:	3004c03a 	cmpne	r2,r6,zero
81125640:	01e1c83a 	sub	r16,zero,r7
81125644:	808fc83a 	sub	r7,r16,r2
81125648:	3005883a 	mov	r2,r6
8112564c:	3807883a 	mov	r3,r7
81125650:	a8000326 	beq	r21,zero,81125660 <_strtoll_r+0x194>
81125654:	5000321e 	bne	r10,zero,81125720 <_strtoll_r+0x254>
81125658:	b00b883a 	mov	r5,r22
8112565c:	a9400015 	stw	r5,0(r21)
81125660:	dfc00c17 	ldw	ra,48(sp)
81125664:	df000b17 	ldw	fp,44(sp)
81125668:	ddc00a17 	ldw	r23,40(sp)
8112566c:	dd800917 	ldw	r22,36(sp)
81125670:	dd400817 	ldw	r21,32(sp)
81125674:	dd000717 	ldw	r20,28(sp)
81125678:	dcc00617 	ldw	r19,24(sp)
8112567c:	dc800517 	ldw	r18,20(sp)
81125680:	dc400417 	ldw	r17,16(sp)
81125684:	dc000317 	ldw	r16,12(sp)
81125688:	dec00d04 	addi	sp,sp,52
8112568c:	f800283a 	ret
81125690:	00800c04 	movi	r2,48
81125694:	80802c26 	beq	r16,r2,81125748 <_strtoll_r+0x27c>
81125698:	05000284 	movi	r20,10
8112569c:	002f883a 	mov	r23,zero
811256a0:	a027883a 	mov	r19,r20
811256a4:	e03fb11e 	bne	fp,zero,8112556c <__reset+0xfb10556c>
811256a8:	02a00034 	movhi	r10,32768
811256ac:	52bfffc4 	addi	r10,r10,-1
811256b0:	02ffffc4 	movi	r11,-1
811256b4:	003faf06 	br	81125574 <__reset+0xfb105574>
811256b8:	33000f26 	beq	r6,r12,811256f8 <_strtoll_r+0x22c>
811256bc:	b985383a 	mul	r2,r23,r6
811256c0:	3d0f383a 	mul	r7,r7,r20
811256c4:	3508383a 	mulxuu	r4,r6,r20
811256c8:	350d383a 	mul	r6,r6,r20
811256cc:	8013d7fa 	srai	r9,r16,31
811256d0:	388f883a 	add	r7,r7,r2
811256d4:	818d883a 	add	r6,r16,r6
811256d8:	390f883a 	add	r7,r7,r4
811256dc:	3421803a 	cmpltu	r16,r6,r16
811256e0:	49cf883a 	add	r7,r9,r7
811256e4:	81cf883a 	add	r7,r16,r7
811256e8:	02800044 	movi	r10,1
811256ec:	003fc306 	br	811255fc <__reset+0xfb1055fc>
811256f0:	00800dc4 	movi	r2,55
811256f4:	003fcb06 	br	81125624 <__reset+0xfb105624>
811256f8:	38fff01e 	bne	r7,r3,811256bc <__reset+0xfb1056bc>
811256fc:	443fbe16 	blt	r8,r16,811255f8 <__reset+0xfb1055f8>
81125700:	003fee06 	br	811256bc <__reset+0xfb1056bc>
81125704:	e0002426 	beq	fp,zero,81125798 <_strtoll_r+0x2cc>
81125708:	0005883a 	mov	r2,zero
8112570c:	00e00034 	movhi	r3,32768
81125710:	d9800017 	ldw	r6,0(sp)
81125714:	01000884 	movi	r4,34
81125718:	31000015 	stw	r4,0(r6)
8112571c:	a83fd026 	beq	r21,zero,81125660 <__reset+0xfb105660>
81125720:	297fffc4 	addi	r5,r5,-1
81125724:	003fcd06 	br	8112565c <__reset+0xfb10565c>
81125728:	1c400084 	addi	r17,r3,2
8112572c:	1c000043 	ldbu	r16,1(r3)
81125730:	07000044 	movi	fp,1
81125734:	003f8706 	br	81125554 <__reset+0xfb105554>
81125738:	1c400084 	addi	r17,r3,2
8112573c:	1c000043 	ldbu	r16,1(r3)
81125740:	0039883a 	mov	fp,zero
81125744:	003f8306 	br	81125554 <__reset+0xfb105554>
81125748:	88800003 	ldbu	r2,0(r17)
8112574c:	00c01604 	movi	r3,88
81125750:	108037cc 	andi	r2,r2,223
81125754:	10c00a26 	beq	r2,r3,81125780 <_strtoll_r+0x2b4>
81125758:	05000204 	movi	r20,8
8112575c:	002f883a 	mov	r23,zero
81125760:	a027883a 	mov	r19,r20
81125764:	003f8006 	br	81125568 <__reset+0xfb105568>
81125768:	00800c04 	movi	r2,48
8112576c:	80800e1e 	bne	r16,r2,811257a8 <_strtoll_r+0x2dc>
81125770:	88800003 	ldbu	r2,0(r17)
81125774:	00c01604 	movi	r3,88
81125778:	108037cc 	andi	r2,r2,223
8112577c:	10c00a1e 	bne	r2,r3,811257a8 <_strtoll_r+0x2dc>
81125780:	05000404 	movi	r20,16
81125784:	8c000043 	ldbu	r16,1(r17)
81125788:	002f883a 	mov	r23,zero
8112578c:	8c400084 	addi	r17,r17,2
81125790:	a027883a 	mov	r19,r20
81125794:	003f7406 	br	81125568 <__reset+0xfb105568>
81125798:	00e00034 	movhi	r3,32768
8112579c:	18ffffc4 	addi	r3,r3,-1
811257a0:	5005883a 	mov	r2,r10
811257a4:	003fda06 	br	81125710 <__reset+0xfb105710>
811257a8:	9829883a 	mov	r20,r19
811257ac:	002f883a 	mov	r23,zero
811257b0:	003f6d06 	br	81125568 <__reset+0xfb105568>

811257b4 <___svfprintf_internal_r>:
811257b4:	deffb704 	addi	sp,sp,-292
811257b8:	de00012e 	bgeu	sp,et,811257c0 <___svfprintf_internal_r+0xc>
811257bc:	003b68fa 	trap	3
811257c0:	dfc04815 	stw	ra,288(sp)
811257c4:	ddc04615 	stw	r23,280(sp)
811257c8:	d9402c15 	stw	r5,176(sp)
811257cc:	d9003915 	stw	r4,228(sp)
811257d0:	302f883a 	mov	r23,r6
811257d4:	d9c02d15 	stw	r7,180(sp)
811257d8:	df004715 	stw	fp,284(sp)
811257dc:	dd804515 	stw	r22,276(sp)
811257e0:	dd404415 	stw	r21,272(sp)
811257e4:	dd004315 	stw	r20,268(sp)
811257e8:	dcc04215 	stw	r19,264(sp)
811257ec:	dc804115 	stw	r18,260(sp)
811257f0:	dc404015 	stw	r17,256(sp)
811257f4:	dc003f15 	stw	r16,252(sp)
811257f8:	112e69c0 	call	8112e69c <_localeconv_r>
811257fc:	10800017 	ldw	r2,0(r2)
81125800:	1009883a 	mov	r4,r2
81125804:	d8803415 	stw	r2,208(sp)
81125808:	11251780 	call	81125178 <strlen>
8112580c:	d8c02c17 	ldw	r3,176(sp)
81125810:	d8803815 	stw	r2,224(sp)
81125814:	1880030b 	ldhu	r2,12(r3)
81125818:	1080200c 	andi	r2,r2,128
8112581c:	10000226 	beq	r2,zero,81125828 <___svfprintf_internal_r+0x74>
81125820:	18800417 	ldw	r2,16(r3)
81125824:	10067f26 	beq	r2,zero,81127224 <___svfprintf_internal_r+0x1a70>
81125828:	dcc03917 	ldw	r19,228(sp)
8112582c:	d8c00404 	addi	r3,sp,16
81125830:	05604574 	movhi	r21,33045
81125834:	d9001e04 	addi	r4,sp,120
81125838:	ad4a9484 	addi	r21,r21,10834
8112583c:	d8c01e15 	stw	r3,120(sp)
81125840:	d8002015 	stw	zero,128(sp)
81125844:	d8001f15 	stw	zero,124(sp)
81125848:	d8003315 	stw	zero,204(sp)
8112584c:	d8003615 	stw	zero,216(sp)
81125850:	d8003715 	stw	zero,220(sp)
81125854:	1811883a 	mov	r8,r3
81125858:	d8003a15 	stw	zero,232(sp)
8112585c:	d8003b15 	stw	zero,236(sp)
81125860:	d8002f15 	stw	zero,188(sp)
81125864:	d9002815 	stw	r4,160(sp)
81125868:	b8800007 	ldb	r2,0(r23)
8112586c:	10026726 	beq	r2,zero,8112620c <___svfprintf_internal_r+0xa58>
81125870:	00c00944 	movi	r3,37
81125874:	b821883a 	mov	r16,r23
81125878:	10c0021e 	bne	r2,r3,81125884 <___svfprintf_internal_r+0xd0>
8112587c:	00001406 	br	811258d0 <___svfprintf_internal_r+0x11c>
81125880:	10c00326 	beq	r2,r3,81125890 <___svfprintf_internal_r+0xdc>
81125884:	84000044 	addi	r16,r16,1
81125888:	80800007 	ldb	r2,0(r16)
8112588c:	103ffc1e 	bne	r2,zero,81125880 <__reset+0xfb105880>
81125890:	85e3c83a 	sub	r17,r16,r23
81125894:	88000e26 	beq	r17,zero,811258d0 <___svfprintf_internal_r+0x11c>
81125898:	d8c02017 	ldw	r3,128(sp)
8112589c:	d8801f17 	ldw	r2,124(sp)
811258a0:	45c00015 	stw	r23,0(r8)
811258a4:	1c47883a 	add	r3,r3,r17
811258a8:	10800044 	addi	r2,r2,1
811258ac:	d8c02015 	stw	r3,128(sp)
811258b0:	44400115 	stw	r17,4(r8)
811258b4:	d8801f15 	stw	r2,124(sp)
811258b8:	00c001c4 	movi	r3,7
811258bc:	18809716 	blt	r3,r2,81125b1c <___svfprintf_internal_r+0x368>
811258c0:	42000204 	addi	r8,r8,8
811258c4:	d9402f17 	ldw	r5,188(sp)
811258c8:	2c4b883a 	add	r5,r5,r17
811258cc:	d9402f15 	stw	r5,188(sp)
811258d0:	80800007 	ldb	r2,0(r16)
811258d4:	10009826 	beq	r2,zero,81125b38 <___svfprintf_internal_r+0x384>
811258d8:	84400047 	ldb	r17,1(r16)
811258dc:	00bfffc4 	movi	r2,-1
811258e0:	85c00044 	addi	r23,r16,1
811258e4:	d8002785 	stb	zero,158(sp)
811258e8:	0007883a 	mov	r3,zero
811258ec:	000f883a 	mov	r7,zero
811258f0:	d8802915 	stw	r2,164(sp)
811258f4:	d8003115 	stw	zero,196(sp)
811258f8:	0025883a 	mov	r18,zero
811258fc:	01401604 	movi	r5,88
81125900:	01800244 	movi	r6,9
81125904:	02800a84 	movi	r10,42
81125908:	02401b04 	movi	r9,108
8112590c:	bdc00044 	addi	r23,r23,1
81125910:	88bff804 	addi	r2,r17,-32
81125914:	2882f036 	bltu	r5,r2,811264d8 <___svfprintf_internal_r+0xd24>
81125918:	100490ba 	slli	r2,r2,2
8112591c:	012044b4 	movhi	r4,33042
81125920:	21164c04 	addi	r4,r4,22832
81125924:	1105883a 	add	r2,r2,r4
81125928:	10800017 	ldw	r2,0(r2)
8112592c:	1000683a 	jmp	r2
81125930:	81126440 	call	88112644 <__reset+0x20f2644>
81125934:	811264d8 	cmpnei	r4,r16,18835
81125938:	811264d8 	cmpnei	r4,r16,18835
8112593c:	81126434 	orhi	r4,r16,18832
81125940:	811264d8 	cmpnei	r4,r16,18835
81125944:	811264d8 	cmpnei	r4,r16,18835
81125948:	811264d8 	cmpnei	r4,r16,18835
8112594c:	811264d8 	cmpnei	r4,r16,18835
81125950:	811264d8 	cmpnei	r4,r16,18835
81125954:	811264d8 	cmpnei	r4,r16,18835
81125958:	81125b94 	ori	r4,r16,18798
8112595c:	81126370 	cmpltui	r4,r16,18829
81125960:	811264d8 	cmpnei	r4,r16,18835
81125964:	81125aa4 	muli	r4,r16,18794
81125968:	81125bbc 	xorhi	r4,r16,18798
8112596c:	811264d8 	cmpnei	r4,r16,18835
81125970:	81125c30 	cmpltui	r4,r16,18800
81125974:	81125bfc 	xorhi	r4,r16,18799
81125978:	81125bfc 	xorhi	r4,r16,18799
8112597c:	81125bfc 	xorhi	r4,r16,18799
81125980:	81125bfc 	xorhi	r4,r16,18799
81125984:	81125bfc 	xorhi	r4,r16,18799
81125988:	81125bfc 	xorhi	r4,r16,18799
8112598c:	81125bfc 	xorhi	r4,r16,18799
81125990:	81125bfc 	xorhi	r4,r16,18799
81125994:	81125bfc 	xorhi	r4,r16,18799
81125998:	811264d8 	cmpnei	r4,r16,18835
8112599c:	811264d8 	cmpnei	r4,r16,18835
811259a0:	811264d8 	cmpnei	r4,r16,18835
811259a4:	811264d8 	cmpnei	r4,r16,18835
811259a8:	811264d8 	cmpnei	r4,r16,18835
811259ac:	811264d8 	cmpnei	r4,r16,18835
811259b0:	811264d8 	cmpnei	r4,r16,18835
811259b4:	811264d8 	cmpnei	r4,r16,18835
811259b8:	811264d8 	cmpnei	r4,r16,18835
811259bc:	811264d8 	cmpnei	r4,r16,18835
811259c0:	81125ce8 	cmpgeui	r4,r16,18803
811259c4:	81125c3c 	xorhi	r4,r16,18800
811259c8:	811264d8 	cmpnei	r4,r16,18835
811259cc:	81125c3c 	xorhi	r4,r16,18800
811259d0:	811264d8 	cmpnei	r4,r16,18835
811259d4:	811264d8 	cmpnei	r4,r16,18835
811259d8:	811264d8 	cmpnei	r4,r16,18835
811259dc:	811264d8 	cmpnei	r4,r16,18835
811259e0:	81125cdc 	xori	r4,r16,18803
811259e4:	811264d8 	cmpnei	r4,r16,18835
811259e8:	811264d8 	cmpnei	r4,r16,18835
811259ec:	81125da4 	muli	r4,r16,18806
811259f0:	811264d8 	cmpnei	r4,r16,18835
811259f4:	811264d8 	cmpnei	r4,r16,18835
811259f8:	811264d8 	cmpnei	r4,r16,18835
811259fc:	811264d8 	cmpnei	r4,r16,18835
81125a00:	811264d8 	cmpnei	r4,r16,18835
81125a04:	81126214 	ori	r4,r16,18824
81125a08:	811264d8 	cmpnei	r4,r16,18835
81125a0c:	811264d8 	cmpnei	r4,r16,18835
81125a10:	81126274 	orhi	r4,r16,18825
81125a14:	811264d8 	cmpnei	r4,r16,18835
81125a18:	811264d8 	cmpnei	r4,r16,18835
81125a1c:	811264d8 	cmpnei	r4,r16,18835
81125a20:	811264d8 	cmpnei	r4,r16,18835
81125a24:	811264d8 	cmpnei	r4,r16,18835
81125a28:	811264d8 	cmpnei	r4,r16,18835
81125a2c:	811264d8 	cmpnei	r4,r16,18835
81125a30:	811264d8 	cmpnei	r4,r16,18835
81125a34:	811264d8 	cmpnei	r4,r16,18835
81125a38:	811264d8 	cmpnei	r4,r16,18835
81125a3c:	81126324 	muli	r4,r16,18828
81125a40:	81126460 	cmpeqi	r4,r16,18833
81125a44:	81125c3c 	xorhi	r4,r16,18800
81125a48:	81125c3c 	xorhi	r4,r16,18800
81125a4c:	81125c3c 	xorhi	r4,r16,18800
81125a50:	811264b4 	orhi	r4,r16,18834
81125a54:	81126460 	cmpeqi	r4,r16,18833
81125a58:	811264d8 	cmpnei	r4,r16,18835
81125a5c:	811264d8 	cmpnei	r4,r16,18835
81125a60:	81126470 	cmpltui	r4,r16,18833
81125a64:	811264d8 	cmpnei	r4,r16,18835
81125a68:	81126480 	call	88112648 <__reset+0x20f2648>
81125a6c:	81126360 	cmpeqi	r4,r16,18829
81125a70:	81125ab0 	cmpltui	r4,r16,18794
81125a74:	81126380 	call	88112638 <__reset+0x20f2638>
81125a78:	811264d8 	cmpnei	r4,r16,18835
81125a7c:	8112638c 	andi	r4,r16,18830
81125a80:	811264d8 	cmpnei	r4,r16,18835
81125a84:	811263e8 	cmpgeui	r4,r16,18831
81125a88:	811264d8 	cmpnei	r4,r16,18835
81125a8c:	811264d8 	cmpnei	r4,r16,18835
81125a90:	811263f8 	rdprs	r4,r16,18831
81125a94:	d9003117 	ldw	r4,196(sp)
81125a98:	d8802d15 	stw	r2,180(sp)
81125a9c:	0109c83a 	sub	r4,zero,r4
81125aa0:	d9003115 	stw	r4,196(sp)
81125aa4:	94800114 	ori	r18,r18,4
81125aa8:	bc400007 	ldb	r17,0(r23)
81125aac:	003f9706 	br	8112590c <__reset+0xfb10590c>
81125ab0:	00800c04 	movi	r2,48
81125ab4:	d9002d17 	ldw	r4,180(sp)
81125ab8:	d9402917 	ldw	r5,164(sp)
81125abc:	d8802705 	stb	r2,156(sp)
81125ac0:	00801e04 	movi	r2,120
81125ac4:	d8802745 	stb	r2,157(sp)
81125ac8:	d8002785 	stb	zero,158(sp)
81125acc:	20c00104 	addi	r3,r4,4
81125ad0:	25000017 	ldw	r20,0(r4)
81125ad4:	002d883a 	mov	r22,zero
81125ad8:	90800094 	ori	r2,r18,2
81125adc:	28028616 	blt	r5,zero,811264f8 <___svfprintf_internal_r+0xd44>
81125ae0:	00bfdfc4 	movi	r2,-129
81125ae4:	90a4703a 	and	r18,r18,r2
81125ae8:	d8c02d15 	stw	r3,180(sp)
81125aec:	94800094 	ori	r18,r18,2
81125af0:	a002731e 	bne	r20,zero,811264c0 <___svfprintf_internal_r+0xd0c>
81125af4:	00a04574 	movhi	r2,33045
81125af8:	108a8d04 	addi	r2,r2,10804
81125afc:	d8803a15 	stw	r2,232(sp)
81125b00:	04401e04 	movi	r17,120
81125b04:	d8c02917 	ldw	r3,164(sp)
81125b08:	0039883a 	mov	fp,zero
81125b0c:	1801d526 	beq	r3,zero,81126264 <___svfprintf_internal_r+0xab0>
81125b10:	0029883a 	mov	r20,zero
81125b14:	002d883a 	mov	r22,zero
81125b18:	0001f106 	br	811262e0 <___svfprintf_internal_r+0xb2c>
81125b1c:	d9402c17 	ldw	r5,176(sp)
81125b20:	d9801e04 	addi	r6,sp,120
81125b24:	9809883a 	mov	r4,r19
81125b28:	11320ec0 	call	811320ec <__ssprint_r>
81125b2c:	1000081e 	bne	r2,zero,81125b50 <___svfprintf_internal_r+0x39c>
81125b30:	da000404 	addi	r8,sp,16
81125b34:	003f6306 	br	811258c4 <__reset+0xfb1058c4>
81125b38:	d8802017 	ldw	r2,128(sp)
81125b3c:	10000426 	beq	r2,zero,81125b50 <___svfprintf_internal_r+0x39c>
81125b40:	d9402c17 	ldw	r5,176(sp)
81125b44:	d9003917 	ldw	r4,228(sp)
81125b48:	d9801e04 	addi	r6,sp,120
81125b4c:	11320ec0 	call	811320ec <__ssprint_r>
81125b50:	d8802c17 	ldw	r2,176(sp)
81125b54:	10c0030b 	ldhu	r3,12(r2)
81125b58:	d8802f17 	ldw	r2,188(sp)
81125b5c:	18c0100c 	andi	r3,r3,64
81125b60:	1805f51e 	bne	r3,zero,81127338 <___svfprintf_internal_r+0x1b84>
81125b64:	dfc04817 	ldw	ra,288(sp)
81125b68:	df004717 	ldw	fp,284(sp)
81125b6c:	ddc04617 	ldw	r23,280(sp)
81125b70:	dd804517 	ldw	r22,276(sp)
81125b74:	dd404417 	ldw	r21,272(sp)
81125b78:	dd004317 	ldw	r20,268(sp)
81125b7c:	dcc04217 	ldw	r19,264(sp)
81125b80:	dc804117 	ldw	r18,260(sp)
81125b84:	dc404017 	ldw	r17,256(sp)
81125b88:	dc003f17 	ldw	r16,252(sp)
81125b8c:	dec04904 	addi	sp,sp,292
81125b90:	f800283a 	ret
81125b94:	d8802d17 	ldw	r2,180(sp)
81125b98:	d9002d17 	ldw	r4,180(sp)
81125b9c:	10800017 	ldw	r2,0(r2)
81125ba0:	d8803115 	stw	r2,196(sp)
81125ba4:	20800104 	addi	r2,r4,4
81125ba8:	d9003117 	ldw	r4,196(sp)
81125bac:	203fb916 	blt	r4,zero,81125a94 <__reset+0xfb105a94>
81125bb0:	d8802d15 	stw	r2,180(sp)
81125bb4:	bc400007 	ldb	r17,0(r23)
81125bb8:	003f5406 	br	8112590c <__reset+0xfb10590c>
81125bbc:	bc400007 	ldb	r17,0(r23)
81125bc0:	bac00044 	addi	r11,r23,1
81125bc4:	8a873926 	beq	r17,r10,811278ac <___svfprintf_internal_r+0x20f8>
81125bc8:	88bff404 	addi	r2,r17,-48
81125bcc:	0009883a 	mov	r4,zero
81125bd0:	30868836 	bltu	r6,r2,811275f4 <___svfprintf_internal_r+0x1e40>
81125bd4:	5c400007 	ldb	r17,0(r11)
81125bd8:	210002a4 	muli	r4,r4,10
81125bdc:	5dc00044 	addi	r23,r11,1
81125be0:	b817883a 	mov	r11,r23
81125be4:	2089883a 	add	r4,r4,r2
81125be8:	88bff404 	addi	r2,r17,-48
81125bec:	30bff92e 	bgeu	r6,r2,81125bd4 <__reset+0xfb105bd4>
81125bf0:	2005d716 	blt	r4,zero,81127350 <___svfprintf_internal_r+0x1b9c>
81125bf4:	d9002915 	stw	r4,164(sp)
81125bf8:	003f4506 	br	81125910 <__reset+0xfb105910>
81125bfc:	b809883a 	mov	r4,r23
81125c00:	d8003115 	stw	zero,196(sp)
81125c04:	88bff404 	addi	r2,r17,-48
81125c08:	0017883a 	mov	r11,zero
81125c0c:	24400007 	ldb	r17,0(r4)
81125c10:	5ac002a4 	muli	r11,r11,10
81125c14:	bdc00044 	addi	r23,r23,1
81125c18:	b809883a 	mov	r4,r23
81125c1c:	12d7883a 	add	r11,r2,r11
81125c20:	88bff404 	addi	r2,r17,-48
81125c24:	30bff92e 	bgeu	r6,r2,81125c0c <__reset+0xfb105c0c>
81125c28:	dac03115 	stw	r11,196(sp)
81125c2c:	003f3806 	br	81125910 <__reset+0xfb105910>
81125c30:	94802014 	ori	r18,r18,128
81125c34:	bc400007 	ldb	r17,0(r23)
81125c38:	003f3406 	br	8112590c <__reset+0xfb10590c>
81125c3c:	18c03fcc 	andi	r3,r3,255
81125c40:	1807471e 	bne	r3,zero,81127960 <___svfprintf_internal_r+0x21ac>
81125c44:	9080020c 	andi	r2,r18,8
81125c48:	10047d26 	beq	r2,zero,81126e40 <___svfprintf_internal_r+0x168c>
81125c4c:	d8c02d17 	ldw	r3,180(sp)
81125c50:	d9002d17 	ldw	r4,180(sp)
81125c54:	d9402d17 	ldw	r5,180(sp)
81125c58:	18c00017 	ldw	r3,0(r3)
81125c5c:	21000117 	ldw	r4,4(r4)
81125c60:	29400204 	addi	r5,r5,8
81125c64:	d8c03615 	stw	r3,216(sp)
81125c68:	d9003715 	stw	r4,220(sp)
81125c6c:	d9402d15 	stw	r5,180(sp)
81125c70:	d9003617 	ldw	r4,216(sp)
81125c74:	d9403717 	ldw	r5,220(sp)
81125c78:	da003e15 	stw	r8,248(sp)
81125c7c:	04000044 	movi	r16,1
81125c80:	11301e80 	call	811301e8 <__fpclassifyd>
81125c84:	da003e17 	ldw	r8,248(sp)
81125c88:	14044b1e 	bne	r2,r16,81126db8 <___svfprintf_internal_r+0x1604>
81125c8c:	d9003617 	ldw	r4,216(sp)
81125c90:	d9403717 	ldw	r5,220(sp)
81125c94:	000d883a 	mov	r6,zero
81125c98:	000f883a 	mov	r7,zero
81125c9c:	11380f00 	call	811380f0 <__ledf2>
81125ca0:	da003e17 	ldw	r8,248(sp)
81125ca4:	1005f316 	blt	r2,zero,81127474 <___svfprintf_internal_r+0x1cc0>
81125ca8:	df002783 	ldbu	fp,158(sp)
81125cac:	008011c4 	movi	r2,71
81125cb0:	1445590e 	bge	r2,r17,81127218 <___svfprintf_internal_r+0x1a64>
81125cb4:	04204574 	movhi	r16,33045
81125cb8:	840a8504 	addi	r16,r16,10772
81125cbc:	00c000c4 	movi	r3,3
81125cc0:	00bfdfc4 	movi	r2,-129
81125cc4:	d8c02a15 	stw	r3,168(sp)
81125cc8:	90a4703a 	and	r18,r18,r2
81125ccc:	d8c02e15 	stw	r3,184(sp)
81125cd0:	d8002915 	stw	zero,164(sp)
81125cd4:	d8003215 	stw	zero,200(sp)
81125cd8:	00006606 	br	81125e74 <___svfprintf_internal_r+0x6c0>
81125cdc:	94800214 	ori	r18,r18,8
81125ce0:	bc400007 	ldb	r17,0(r23)
81125ce4:	003f0906 	br	8112590c <__reset+0xfb10590c>
81125ce8:	18c03fcc 	andi	r3,r3,255
81125cec:	1807181e 	bne	r3,zero,81127950 <___svfprintf_internal_r+0x219c>
81125cf0:	94800414 	ori	r18,r18,16
81125cf4:	9080080c 	andi	r2,r18,32
81125cf8:	10039626 	beq	r2,zero,81126b54 <___svfprintf_internal_r+0x13a0>
81125cfc:	d9402d17 	ldw	r5,180(sp)
81125d00:	28800117 	ldw	r2,4(r5)
81125d04:	2d000017 	ldw	r20,0(r5)
81125d08:	29400204 	addi	r5,r5,8
81125d0c:	d9402d15 	stw	r5,180(sp)
81125d10:	102d883a 	mov	r22,r2
81125d14:	10039816 	blt	r2,zero,81126b78 <___svfprintf_internal_r+0x13c4>
81125d18:	d9402917 	ldw	r5,164(sp)
81125d1c:	df002783 	ldbu	fp,158(sp)
81125d20:	2803ab16 	blt	r5,zero,81126bd0 <___svfprintf_internal_r+0x141c>
81125d24:	00ffdfc4 	movi	r3,-129
81125d28:	a584b03a 	or	r2,r20,r22
81125d2c:	90e4703a 	and	r18,r18,r3
81125d30:	10014a26 	beq	r2,zero,8112625c <___svfprintf_internal_r+0xaa8>
81125d34:	b0034b26 	beq	r22,zero,81126a64 <___svfprintf_internal_r+0x12b0>
81125d38:	dc402a15 	stw	r17,168(sp)
81125d3c:	dc001e04 	addi	r16,sp,120
81125d40:	b023883a 	mov	r17,r22
81125d44:	402d883a 	mov	r22,r8
81125d48:	a009883a 	mov	r4,r20
81125d4c:	880b883a 	mov	r5,r17
81125d50:	01800284 	movi	r6,10
81125d54:	000f883a 	mov	r7,zero
81125d58:	11365d40 	call	811365d4 <__umoddi3>
81125d5c:	10800c04 	addi	r2,r2,48
81125d60:	843fffc4 	addi	r16,r16,-1
81125d64:	a009883a 	mov	r4,r20
81125d68:	880b883a 	mov	r5,r17
81125d6c:	80800005 	stb	r2,0(r16)
81125d70:	01800284 	movi	r6,10
81125d74:	000f883a 	mov	r7,zero
81125d78:	11360540 	call	81136054 <__udivdi3>
81125d7c:	1029883a 	mov	r20,r2
81125d80:	10c4b03a 	or	r2,r2,r3
81125d84:	1823883a 	mov	r17,r3
81125d88:	103fef1e 	bne	r2,zero,81125d48 <__reset+0xfb105d48>
81125d8c:	d8c02817 	ldw	r3,160(sp)
81125d90:	dc402a17 	ldw	r17,168(sp)
81125d94:	b011883a 	mov	r8,r22
81125d98:	1c07c83a 	sub	r3,r3,r16
81125d9c:	d8c02e15 	stw	r3,184(sp)
81125da0:	00002e06 	br	81125e5c <___svfprintf_internal_r+0x6a8>
81125da4:	18c03fcc 	andi	r3,r3,255
81125da8:	1806e71e 	bne	r3,zero,81127948 <___svfprintf_internal_r+0x2194>
81125dac:	94800414 	ori	r18,r18,16
81125db0:	9080080c 	andi	r2,r18,32
81125db4:	1002d426 	beq	r2,zero,81126908 <___svfprintf_internal_r+0x1154>
81125db8:	d9402d17 	ldw	r5,180(sp)
81125dbc:	d8c02917 	ldw	r3,164(sp)
81125dc0:	d8002785 	stb	zero,158(sp)
81125dc4:	28800204 	addi	r2,r5,8
81125dc8:	2d000017 	ldw	r20,0(r5)
81125dcc:	2d800117 	ldw	r22,4(r5)
81125dd0:	18041516 	blt	r3,zero,81126e28 <___svfprintf_internal_r+0x1674>
81125dd4:	013fdfc4 	movi	r4,-129
81125dd8:	a586b03a 	or	r3,r20,r22
81125ddc:	d8802d15 	stw	r2,180(sp)
81125de0:	9124703a 	and	r18,r18,r4
81125de4:	1802d51e 	bne	r3,zero,8112693c <___svfprintf_internal_r+0x1188>
81125de8:	d9402917 	ldw	r5,164(sp)
81125dec:	0039883a 	mov	fp,zero
81125df0:	2806be26 	beq	r5,zero,811278ec <___svfprintf_internal_r+0x2138>
81125df4:	0029883a 	mov	r20,zero
81125df8:	002d883a 	mov	r22,zero
81125dfc:	dc001e04 	addi	r16,sp,120
81125e00:	a006d0fa 	srli	r3,r20,3
81125e04:	b008977a 	slli	r4,r22,29
81125e08:	b02cd0fa 	srli	r22,r22,3
81125e0c:	a50001cc 	andi	r20,r20,7
81125e10:	a0800c04 	addi	r2,r20,48
81125e14:	843fffc4 	addi	r16,r16,-1
81125e18:	20e8b03a 	or	r20,r4,r3
81125e1c:	80800005 	stb	r2,0(r16)
81125e20:	a586b03a 	or	r3,r20,r22
81125e24:	183ff61e 	bne	r3,zero,81125e00 <__reset+0xfb105e00>
81125e28:	90c0004c 	andi	r3,r18,1
81125e2c:	18013926 	beq	r3,zero,81126314 <___svfprintf_internal_r+0xb60>
81125e30:	10803fcc 	andi	r2,r2,255
81125e34:	1080201c 	xori	r2,r2,128
81125e38:	10bfe004 	addi	r2,r2,-128
81125e3c:	00c00c04 	movi	r3,48
81125e40:	10c13426 	beq	r2,r3,81126314 <___svfprintf_internal_r+0xb60>
81125e44:	80ffffc5 	stb	r3,-1(r16)
81125e48:	d8c02817 	ldw	r3,160(sp)
81125e4c:	80bfffc4 	addi	r2,r16,-1
81125e50:	1021883a 	mov	r16,r2
81125e54:	1887c83a 	sub	r3,r3,r2
81125e58:	d8c02e15 	stw	r3,184(sp)
81125e5c:	d8802e17 	ldw	r2,184(sp)
81125e60:	d9002917 	ldw	r4,164(sp)
81125e64:	1100010e 	bge	r2,r4,81125e6c <___svfprintf_internal_r+0x6b8>
81125e68:	2005883a 	mov	r2,r4
81125e6c:	d8802a15 	stw	r2,168(sp)
81125e70:	d8003215 	stw	zero,200(sp)
81125e74:	e7003fcc 	andi	fp,fp,255
81125e78:	e700201c 	xori	fp,fp,128
81125e7c:	e73fe004 	addi	fp,fp,-128
81125e80:	e0000326 	beq	fp,zero,81125e90 <___svfprintf_internal_r+0x6dc>
81125e84:	d8c02a17 	ldw	r3,168(sp)
81125e88:	18c00044 	addi	r3,r3,1
81125e8c:	d8c02a15 	stw	r3,168(sp)
81125e90:	90c0008c 	andi	r3,r18,2
81125e94:	d8c02b15 	stw	r3,172(sp)
81125e98:	18000326 	beq	r3,zero,81125ea8 <___svfprintf_internal_r+0x6f4>
81125e9c:	d8c02a17 	ldw	r3,168(sp)
81125ea0:	18c00084 	addi	r3,r3,2
81125ea4:	d8c02a15 	stw	r3,168(sp)
81125ea8:	90c0210c 	andi	r3,r18,132
81125eac:	d8c03015 	stw	r3,192(sp)
81125eb0:	1801a11e 	bne	r3,zero,81126538 <___svfprintf_internal_r+0xd84>
81125eb4:	d9003117 	ldw	r4,196(sp)
81125eb8:	d8c02a17 	ldw	r3,168(sp)
81125ebc:	20e9c83a 	sub	r20,r4,r3
81125ec0:	05019d0e 	bge	zero,r20,81126538 <___svfprintf_internal_r+0xd84>
81125ec4:	02400404 	movi	r9,16
81125ec8:	d8c02017 	ldw	r3,128(sp)
81125ecc:	d8801f17 	ldw	r2,124(sp)
81125ed0:	4d051b0e 	bge	r9,r20,81127340 <___svfprintf_internal_r+0x1b8c>
81125ed4:	01604574 	movhi	r5,33045
81125ed8:	294a9884 	addi	r5,r5,10850
81125edc:	dc403c15 	stw	r17,240(sp)
81125ee0:	d9403515 	stw	r5,212(sp)
81125ee4:	a023883a 	mov	r17,r20
81125ee8:	482d883a 	mov	r22,r9
81125eec:	9029883a 	mov	r20,r18
81125ef0:	070001c4 	movi	fp,7
81125ef4:	8025883a 	mov	r18,r16
81125ef8:	dc002c17 	ldw	r16,176(sp)
81125efc:	00000306 	br	81125f0c <___svfprintf_internal_r+0x758>
81125f00:	8c7ffc04 	addi	r17,r17,-16
81125f04:	42000204 	addi	r8,r8,8
81125f08:	b440130e 	bge	r22,r17,81125f58 <___svfprintf_internal_r+0x7a4>
81125f0c:	01204574 	movhi	r4,33045
81125f10:	18c00404 	addi	r3,r3,16
81125f14:	10800044 	addi	r2,r2,1
81125f18:	210a9884 	addi	r4,r4,10850
81125f1c:	41000015 	stw	r4,0(r8)
81125f20:	45800115 	stw	r22,4(r8)
81125f24:	d8c02015 	stw	r3,128(sp)
81125f28:	d8801f15 	stw	r2,124(sp)
81125f2c:	e0bff40e 	bge	fp,r2,81125f00 <__reset+0xfb105f00>
81125f30:	d9801e04 	addi	r6,sp,120
81125f34:	800b883a 	mov	r5,r16
81125f38:	9809883a 	mov	r4,r19
81125f3c:	11320ec0 	call	811320ec <__ssprint_r>
81125f40:	103f031e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81125f44:	8c7ffc04 	addi	r17,r17,-16
81125f48:	d8c02017 	ldw	r3,128(sp)
81125f4c:	d8801f17 	ldw	r2,124(sp)
81125f50:	da000404 	addi	r8,sp,16
81125f54:	b47fed16 	blt	r22,r17,81125f0c <__reset+0xfb105f0c>
81125f58:	9021883a 	mov	r16,r18
81125f5c:	a025883a 	mov	r18,r20
81125f60:	8829883a 	mov	r20,r17
81125f64:	dc403c17 	ldw	r17,240(sp)
81125f68:	d9403517 	ldw	r5,212(sp)
81125f6c:	a0c7883a 	add	r3,r20,r3
81125f70:	10800044 	addi	r2,r2,1
81125f74:	41400015 	stw	r5,0(r8)
81125f78:	45000115 	stw	r20,4(r8)
81125f7c:	d8c02015 	stw	r3,128(sp)
81125f80:	d8801f15 	stw	r2,124(sp)
81125f84:	010001c4 	movi	r4,7
81125f88:	20829f16 	blt	r4,r2,81126a08 <___svfprintf_internal_r+0x1254>
81125f8c:	df002787 	ldb	fp,158(sp)
81125f90:	42000204 	addi	r8,r8,8
81125f94:	e0000c26 	beq	fp,zero,81125fc8 <___svfprintf_internal_r+0x814>
81125f98:	d8801f17 	ldw	r2,124(sp)
81125f9c:	d9002784 	addi	r4,sp,158
81125fa0:	18c00044 	addi	r3,r3,1
81125fa4:	10800044 	addi	r2,r2,1
81125fa8:	41000015 	stw	r4,0(r8)
81125fac:	01000044 	movi	r4,1
81125fb0:	41000115 	stw	r4,4(r8)
81125fb4:	d8c02015 	stw	r3,128(sp)
81125fb8:	d8801f15 	stw	r2,124(sp)
81125fbc:	010001c4 	movi	r4,7
81125fc0:	20823816 	blt	r4,r2,811268a4 <___svfprintf_internal_r+0x10f0>
81125fc4:	42000204 	addi	r8,r8,8
81125fc8:	d8802b17 	ldw	r2,172(sp)
81125fcc:	10000c26 	beq	r2,zero,81126000 <___svfprintf_internal_r+0x84c>
81125fd0:	d8801f17 	ldw	r2,124(sp)
81125fd4:	d9002704 	addi	r4,sp,156
81125fd8:	18c00084 	addi	r3,r3,2
81125fdc:	10800044 	addi	r2,r2,1
81125fe0:	41000015 	stw	r4,0(r8)
81125fe4:	01000084 	movi	r4,2
81125fe8:	41000115 	stw	r4,4(r8)
81125fec:	d8c02015 	stw	r3,128(sp)
81125ff0:	d8801f15 	stw	r2,124(sp)
81125ff4:	010001c4 	movi	r4,7
81125ff8:	20823216 	blt	r4,r2,811268c4 <___svfprintf_internal_r+0x1110>
81125ffc:	42000204 	addi	r8,r8,8
81126000:	d9003017 	ldw	r4,192(sp)
81126004:	00802004 	movi	r2,128
81126008:	20819726 	beq	r4,r2,81126668 <___svfprintf_internal_r+0xeb4>
8112600c:	d9402917 	ldw	r5,164(sp)
81126010:	d8802e17 	ldw	r2,184(sp)
81126014:	28adc83a 	sub	r22,r5,r2
81126018:	05802f0e 	bge	zero,r22,811260d8 <___svfprintf_internal_r+0x924>
8112601c:	07000404 	movi	fp,16
81126020:	d8801f17 	ldw	r2,124(sp)
81126024:	e583c00e 	bge	fp,r22,81126f28 <___svfprintf_internal_r+0x1774>
81126028:	01604574 	movhi	r5,33045
8112602c:	294a9484 	addi	r5,r5,10834
81126030:	dc402915 	stw	r17,164(sp)
81126034:	d9402b15 	stw	r5,172(sp)
81126038:	b023883a 	mov	r17,r22
8112603c:	050001c4 	movi	r20,7
81126040:	902d883a 	mov	r22,r18
81126044:	8025883a 	mov	r18,r16
81126048:	dc002c17 	ldw	r16,176(sp)
8112604c:	00000306 	br	8112605c <___svfprintf_internal_r+0x8a8>
81126050:	8c7ffc04 	addi	r17,r17,-16
81126054:	42000204 	addi	r8,r8,8
81126058:	e440110e 	bge	fp,r17,811260a0 <___svfprintf_internal_r+0x8ec>
8112605c:	18c00404 	addi	r3,r3,16
81126060:	10800044 	addi	r2,r2,1
81126064:	45400015 	stw	r21,0(r8)
81126068:	47000115 	stw	fp,4(r8)
8112606c:	d8c02015 	stw	r3,128(sp)
81126070:	d8801f15 	stw	r2,124(sp)
81126074:	a0bff60e 	bge	r20,r2,81126050 <__reset+0xfb106050>
81126078:	d9801e04 	addi	r6,sp,120
8112607c:	800b883a 	mov	r5,r16
81126080:	9809883a 	mov	r4,r19
81126084:	11320ec0 	call	811320ec <__ssprint_r>
81126088:	103eb11e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
8112608c:	8c7ffc04 	addi	r17,r17,-16
81126090:	d8c02017 	ldw	r3,128(sp)
81126094:	d8801f17 	ldw	r2,124(sp)
81126098:	da000404 	addi	r8,sp,16
8112609c:	e47fef16 	blt	fp,r17,8112605c <__reset+0xfb10605c>
811260a0:	9021883a 	mov	r16,r18
811260a4:	b025883a 	mov	r18,r22
811260a8:	882d883a 	mov	r22,r17
811260ac:	dc402917 	ldw	r17,164(sp)
811260b0:	d9002b17 	ldw	r4,172(sp)
811260b4:	1d87883a 	add	r3,r3,r22
811260b8:	10800044 	addi	r2,r2,1
811260bc:	41000015 	stw	r4,0(r8)
811260c0:	45800115 	stw	r22,4(r8)
811260c4:	d8c02015 	stw	r3,128(sp)
811260c8:	d8801f15 	stw	r2,124(sp)
811260cc:	010001c4 	movi	r4,7
811260d0:	2081ec16 	blt	r4,r2,81126884 <___svfprintf_internal_r+0x10d0>
811260d4:	42000204 	addi	r8,r8,8
811260d8:	9080400c 	andi	r2,r18,256
811260dc:	1001181e 	bne	r2,zero,81126540 <___svfprintf_internal_r+0xd8c>
811260e0:	d9402e17 	ldw	r5,184(sp)
811260e4:	d8801f17 	ldw	r2,124(sp)
811260e8:	44000015 	stw	r16,0(r8)
811260ec:	1947883a 	add	r3,r3,r5
811260f0:	10800044 	addi	r2,r2,1
811260f4:	41400115 	stw	r5,4(r8)
811260f8:	d8c02015 	stw	r3,128(sp)
811260fc:	d8801f15 	stw	r2,124(sp)
81126100:	010001c4 	movi	r4,7
81126104:	2081d116 	blt	r4,r2,8112684c <___svfprintf_internal_r+0x1098>
81126108:	42000204 	addi	r8,r8,8
8112610c:	9480010c 	andi	r18,r18,4
81126110:	90003226 	beq	r18,zero,811261dc <___svfprintf_internal_r+0xa28>
81126114:	d9403117 	ldw	r5,196(sp)
81126118:	d8802a17 	ldw	r2,168(sp)
8112611c:	28a1c83a 	sub	r16,r5,r2
81126120:	04002e0e 	bge	zero,r16,811261dc <___svfprintf_internal_r+0xa28>
81126124:	04400404 	movi	r17,16
81126128:	d8801f17 	ldw	r2,124(sp)
8112612c:	8c04b90e 	bge	r17,r16,81127414 <___svfprintf_internal_r+0x1c60>
81126130:	01604574 	movhi	r5,33045
81126134:	294a9884 	addi	r5,r5,10850
81126138:	d9403515 	stw	r5,212(sp)
8112613c:	048001c4 	movi	r18,7
81126140:	dd002c17 	ldw	r20,176(sp)
81126144:	00000306 	br	81126154 <___svfprintf_internal_r+0x9a0>
81126148:	843ffc04 	addi	r16,r16,-16
8112614c:	42000204 	addi	r8,r8,8
81126150:	8c00130e 	bge	r17,r16,811261a0 <___svfprintf_internal_r+0x9ec>
81126154:	01204574 	movhi	r4,33045
81126158:	18c00404 	addi	r3,r3,16
8112615c:	10800044 	addi	r2,r2,1
81126160:	210a9884 	addi	r4,r4,10850
81126164:	41000015 	stw	r4,0(r8)
81126168:	44400115 	stw	r17,4(r8)
8112616c:	d8c02015 	stw	r3,128(sp)
81126170:	d8801f15 	stw	r2,124(sp)
81126174:	90bff40e 	bge	r18,r2,81126148 <__reset+0xfb106148>
81126178:	d9801e04 	addi	r6,sp,120
8112617c:	a00b883a 	mov	r5,r20
81126180:	9809883a 	mov	r4,r19
81126184:	11320ec0 	call	811320ec <__ssprint_r>
81126188:	103e711e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
8112618c:	843ffc04 	addi	r16,r16,-16
81126190:	d8c02017 	ldw	r3,128(sp)
81126194:	d8801f17 	ldw	r2,124(sp)
81126198:	da000404 	addi	r8,sp,16
8112619c:	8c3fed16 	blt	r17,r16,81126154 <__reset+0xfb106154>
811261a0:	d9403517 	ldw	r5,212(sp)
811261a4:	1c07883a 	add	r3,r3,r16
811261a8:	10800044 	addi	r2,r2,1
811261ac:	41400015 	stw	r5,0(r8)
811261b0:	44000115 	stw	r16,4(r8)
811261b4:	d8c02015 	stw	r3,128(sp)
811261b8:	d8801f15 	stw	r2,124(sp)
811261bc:	010001c4 	movi	r4,7
811261c0:	2080060e 	bge	r4,r2,811261dc <___svfprintf_internal_r+0xa28>
811261c4:	d9402c17 	ldw	r5,176(sp)
811261c8:	d9801e04 	addi	r6,sp,120
811261cc:	9809883a 	mov	r4,r19
811261d0:	11320ec0 	call	811320ec <__ssprint_r>
811261d4:	103e5e1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811261d8:	d8c02017 	ldw	r3,128(sp)
811261dc:	d8803117 	ldw	r2,196(sp)
811261e0:	d9002a17 	ldw	r4,168(sp)
811261e4:	1100010e 	bge	r2,r4,811261ec <___svfprintf_internal_r+0xa38>
811261e8:	2005883a 	mov	r2,r4
811261ec:	d9402f17 	ldw	r5,188(sp)
811261f0:	288b883a 	add	r5,r5,r2
811261f4:	d9402f15 	stw	r5,188(sp)
811261f8:	18019c1e 	bne	r3,zero,8112686c <___svfprintf_internal_r+0x10b8>
811261fc:	b8800007 	ldb	r2,0(r23)
81126200:	d8001f15 	stw	zero,124(sp)
81126204:	da000404 	addi	r8,sp,16
81126208:	103d991e 	bne	r2,zero,81125870 <__reset+0xfb105870>
8112620c:	b821883a 	mov	r16,r23
81126210:	003daf06 	br	811258d0 <__reset+0xfb1058d0>
81126214:	18c03fcc 	andi	r3,r3,255
81126218:	1805c71e 	bne	r3,zero,81127938 <___svfprintf_internal_r+0x2184>
8112621c:	94800414 	ori	r18,r18,16
81126220:	9080080c 	andi	r2,r18,32
81126224:	10020126 	beq	r2,zero,81126a2c <___svfprintf_internal_r+0x1278>
81126228:	d8802d17 	ldw	r2,180(sp)
8112622c:	d9002917 	ldw	r4,164(sp)
81126230:	d8002785 	stb	zero,158(sp)
81126234:	10c00204 	addi	r3,r2,8
81126238:	15000017 	ldw	r20,0(r2)
8112623c:	15800117 	ldw	r22,4(r2)
81126240:	20038e16 	blt	r4,zero,8112707c <___svfprintf_internal_r+0x18c8>
81126244:	013fdfc4 	movi	r4,-129
81126248:	a584b03a 	or	r2,r20,r22
8112624c:	d8c02d15 	stw	r3,180(sp)
81126250:	9124703a 	and	r18,r18,r4
81126254:	0039883a 	mov	fp,zero
81126258:	103eb61e 	bne	r2,zero,81125d34 <__reset+0xfb105d34>
8112625c:	d8802917 	ldw	r2,164(sp)
81126260:	1002c81e 	bne	r2,zero,81126d84 <___svfprintf_internal_r+0x15d0>
81126264:	d8002915 	stw	zero,164(sp)
81126268:	d8002e15 	stw	zero,184(sp)
8112626c:	dc001e04 	addi	r16,sp,120
81126270:	003efa06 	br	81125e5c <__reset+0xfb105e5c>
81126274:	18c03fcc 	andi	r3,r3,255
81126278:	1805ad1e 	bne	r3,zero,81127930 <___svfprintf_internal_r+0x217c>
8112627c:	01604574 	movhi	r5,33045
81126280:	294a8804 	addi	r5,r5,10784
81126284:	d9403a15 	stw	r5,232(sp)
81126288:	9080080c 	andi	r2,r18,32
8112628c:	10006126 	beq	r2,zero,81126414 <___svfprintf_internal_r+0xc60>
81126290:	d8802d17 	ldw	r2,180(sp)
81126294:	15000017 	ldw	r20,0(r2)
81126298:	15800117 	ldw	r22,4(r2)
8112629c:	10800204 	addi	r2,r2,8
811262a0:	d8802d15 	stw	r2,180(sp)
811262a4:	9080004c 	andi	r2,r18,1
811262a8:	10018e26 	beq	r2,zero,811268e4 <___svfprintf_internal_r+0x1130>
811262ac:	a584b03a 	or	r2,r20,r22
811262b0:	10030926 	beq	r2,zero,81126ed8 <___svfprintf_internal_r+0x1724>
811262b4:	d8c02917 	ldw	r3,164(sp)
811262b8:	00800c04 	movi	r2,48
811262bc:	d8802705 	stb	r2,156(sp)
811262c0:	dc402745 	stb	r17,157(sp)
811262c4:	d8002785 	stb	zero,158(sp)
811262c8:	90800094 	ori	r2,r18,2
811262cc:	18048716 	blt	r3,zero,811274ec <___svfprintf_internal_r+0x1d38>
811262d0:	00bfdfc4 	movi	r2,-129
811262d4:	90a4703a 	and	r18,r18,r2
811262d8:	94800094 	ori	r18,r18,2
811262dc:	0039883a 	mov	fp,zero
811262e0:	d9003a17 	ldw	r4,232(sp)
811262e4:	dc001e04 	addi	r16,sp,120
811262e8:	a08003cc 	andi	r2,r20,15
811262ec:	b006973a 	slli	r3,r22,28
811262f0:	2085883a 	add	r2,r4,r2
811262f4:	a028d13a 	srli	r20,r20,4
811262f8:	10800003 	ldbu	r2,0(r2)
811262fc:	b02cd13a 	srli	r22,r22,4
81126300:	843fffc4 	addi	r16,r16,-1
81126304:	1d28b03a 	or	r20,r3,r20
81126308:	80800005 	stb	r2,0(r16)
8112630c:	a584b03a 	or	r2,r20,r22
81126310:	103ff51e 	bne	r2,zero,811262e8 <__reset+0xfb1062e8>
81126314:	d8c02817 	ldw	r3,160(sp)
81126318:	1c07c83a 	sub	r3,r3,r16
8112631c:	d8c02e15 	stw	r3,184(sp)
81126320:	003ece06 	br	81125e5c <__reset+0xfb105e5c>
81126324:	d8c02d17 	ldw	r3,180(sp)
81126328:	d9002d17 	ldw	r4,180(sp)
8112632c:	d8002785 	stb	zero,158(sp)
81126330:	18800017 	ldw	r2,0(r3)
81126334:	21000104 	addi	r4,r4,4
81126338:	00c00044 	movi	r3,1
8112633c:	d8c02a15 	stw	r3,168(sp)
81126340:	d8801405 	stb	r2,80(sp)
81126344:	d9002d15 	stw	r4,180(sp)
81126348:	d8c02e15 	stw	r3,184(sp)
8112634c:	d8002915 	stw	zero,164(sp)
81126350:	d8003215 	stw	zero,200(sp)
81126354:	dc001404 	addi	r16,sp,80
81126358:	0039883a 	mov	fp,zero
8112635c:	003ecc06 	br	81125e90 <__reset+0xfb105e90>
81126360:	18c03fcc 	andi	r3,r3,255
81126364:	183e9226 	beq	r3,zero,81125db0 <__reset+0xfb105db0>
81126368:	d9c02785 	stb	r7,158(sp)
8112636c:	003e9006 	br	81125db0 <__reset+0xfb105db0>
81126370:	00c00044 	movi	r3,1
81126374:	01c00ac4 	movi	r7,43
81126378:	bc400007 	ldb	r17,0(r23)
8112637c:	003d6306 	br	8112590c <__reset+0xfb10590c>
81126380:	94800814 	ori	r18,r18,32
81126384:	bc400007 	ldb	r17,0(r23)
81126388:	003d6006 	br	8112590c <__reset+0xfb10590c>
8112638c:	d8c02d17 	ldw	r3,180(sp)
81126390:	d8002785 	stb	zero,158(sp)
81126394:	1c000017 	ldw	r16,0(r3)
81126398:	1d000104 	addi	r20,r3,4
8112639c:	80040f26 	beq	r16,zero,811273dc <___svfprintf_internal_r+0x1c28>
811263a0:	d9002917 	ldw	r4,164(sp)
811263a4:	2003dc16 	blt	r4,zero,81127318 <___svfprintf_internal_r+0x1b64>
811263a8:	200d883a 	mov	r6,r4
811263ac:	000b883a 	mov	r5,zero
811263b0:	8009883a 	mov	r4,r16
811263b4:	da003e15 	stw	r8,248(sp)
811263b8:	112e9780 	call	8112e978 <memchr>
811263bc:	da003e17 	ldw	r8,248(sp)
811263c0:	10045826 	beq	r2,zero,81127524 <___svfprintf_internal_r+0x1d70>
811263c4:	1405c83a 	sub	r2,r2,r16
811263c8:	d8802e15 	stw	r2,184(sp)
811263cc:	1003d816 	blt	r2,zero,81127330 <___svfprintf_internal_r+0x1b7c>
811263d0:	df002783 	ldbu	fp,158(sp)
811263d4:	d8802a15 	stw	r2,168(sp)
811263d8:	dd002d15 	stw	r20,180(sp)
811263dc:	d8002915 	stw	zero,164(sp)
811263e0:	d8003215 	stw	zero,200(sp)
811263e4:	003ea306 	br	81125e74 <__reset+0xfb105e74>
811263e8:	18c03fcc 	andi	r3,r3,255
811263ec:	183f8c26 	beq	r3,zero,81126220 <__reset+0xfb106220>
811263f0:	d9c02785 	stb	r7,158(sp)
811263f4:	003f8a06 	br	81126220 <__reset+0xfb106220>
811263f8:	18c03fcc 	andi	r3,r3,255
811263fc:	1805631e 	bne	r3,zero,8112798c <___svfprintf_internal_r+0x21d8>
81126400:	01604574 	movhi	r5,33045
81126404:	294a8d04 	addi	r5,r5,10804
81126408:	d9403a15 	stw	r5,232(sp)
8112640c:	9080080c 	andi	r2,r18,32
81126410:	103f9f1e 	bne	r2,zero,81126290 <__reset+0xfb106290>
81126414:	9080040c 	andi	r2,r18,16
81126418:	10029c26 	beq	r2,zero,81126e8c <___svfprintf_internal_r+0x16d8>
8112641c:	d8c02d17 	ldw	r3,180(sp)
81126420:	002d883a 	mov	r22,zero
81126424:	1d000017 	ldw	r20,0(r3)
81126428:	18c00104 	addi	r3,r3,4
8112642c:	d8c02d15 	stw	r3,180(sp)
81126430:	003f9c06 	br	811262a4 <__reset+0xfb1062a4>
81126434:	94800054 	ori	r18,r18,1
81126438:	bc400007 	ldb	r17,0(r23)
8112643c:	003d3306 	br	8112590c <__reset+0xfb10590c>
81126440:	38803fcc 	andi	r2,r7,255
81126444:	1080201c 	xori	r2,r2,128
81126448:	10bfe004 	addi	r2,r2,-128
8112644c:	1002971e 	bne	r2,zero,81126eac <___svfprintf_internal_r+0x16f8>
81126450:	00c00044 	movi	r3,1
81126454:	01c00804 	movi	r7,32
81126458:	bc400007 	ldb	r17,0(r23)
8112645c:	003d2b06 	br	8112590c <__reset+0xfb10590c>
81126460:	18c03fcc 	andi	r3,r3,255
81126464:	183e2326 	beq	r3,zero,81125cf4 <__reset+0xfb105cf4>
81126468:	d9c02785 	stb	r7,158(sp)
8112646c:	003e2106 	br	81125cf4 <__reset+0xfb105cf4>
81126470:	bc400007 	ldb	r17,0(r23)
81126474:	8a430426 	beq	r17,r9,81127088 <___svfprintf_internal_r+0x18d4>
81126478:	94800414 	ori	r18,r18,16
8112647c:	003d2306 	br	8112590c <__reset+0xfb10590c>
81126480:	18c03fcc 	andi	r3,r3,255
81126484:	18053f1e 	bne	r3,zero,81127984 <___svfprintf_internal_r+0x21d0>
81126488:	9080080c 	andi	r2,r18,32
8112648c:	10028926 	beq	r2,zero,81126eb4 <___svfprintf_internal_r+0x1700>
81126490:	d9402d17 	ldw	r5,180(sp)
81126494:	d9002f17 	ldw	r4,188(sp)
81126498:	28800017 	ldw	r2,0(r5)
8112649c:	2007d7fa 	srai	r3,r4,31
811264a0:	29400104 	addi	r5,r5,4
811264a4:	d9402d15 	stw	r5,180(sp)
811264a8:	11000015 	stw	r4,0(r2)
811264ac:	10c00115 	stw	r3,4(r2)
811264b0:	003ced06 	br	81125868 <__reset+0xfb105868>
811264b4:	94801014 	ori	r18,r18,64
811264b8:	bc400007 	ldb	r17,0(r23)
811264bc:	003d1306 	br	8112590c <__reset+0xfb10590c>
811264c0:	01204574 	movhi	r4,33045
811264c4:	210a8d04 	addi	r4,r4,10804
811264c8:	0039883a 	mov	fp,zero
811264cc:	d9003a15 	stw	r4,232(sp)
811264d0:	04401e04 	movi	r17,120
811264d4:	003f8206 	br	811262e0 <__reset+0xfb1062e0>
811264d8:	18c03fcc 	andi	r3,r3,255
811264dc:	1805221e 	bne	r3,zero,81127968 <___svfprintf_internal_r+0x21b4>
811264e0:	883d9526 	beq	r17,zero,81125b38 <__reset+0xfb105b38>
811264e4:	00c00044 	movi	r3,1
811264e8:	d8c02a15 	stw	r3,168(sp)
811264ec:	dc401405 	stb	r17,80(sp)
811264f0:	d8002785 	stb	zero,158(sp)
811264f4:	003f9406 	br	81126348 <__reset+0xfb106348>
811264f8:	01204574 	movhi	r4,33045
811264fc:	210a8d04 	addi	r4,r4,10804
81126500:	d9003a15 	stw	r4,232(sp)
81126504:	d8c02d15 	stw	r3,180(sp)
81126508:	1025883a 	mov	r18,r2
8112650c:	04401e04 	movi	r17,120
81126510:	a584b03a 	or	r2,r20,r22
81126514:	1000fa1e 	bne	r2,zero,81126900 <___svfprintf_internal_r+0x114c>
81126518:	0039883a 	mov	fp,zero
8112651c:	00800084 	movi	r2,2
81126520:	10803fcc 	andi	r2,r2,255
81126524:	00c00044 	movi	r3,1
81126528:	10c21626 	beq	r2,r3,81126d84 <___svfprintf_internal_r+0x15d0>
8112652c:	00c00084 	movi	r3,2
81126530:	10fe301e 	bne	r2,r3,81125df4 <__reset+0xfb105df4>
81126534:	003d7606 	br	81125b10 <__reset+0xfb105b10>
81126538:	d8c02017 	ldw	r3,128(sp)
8112653c:	003e9506 	br	81125f94 <__reset+0xfb105f94>
81126540:	00801944 	movi	r2,101
81126544:	14407c0e 	bge	r2,r17,81126738 <___svfprintf_internal_r+0xf84>
81126548:	d9003617 	ldw	r4,216(sp)
8112654c:	d9403717 	ldw	r5,220(sp)
81126550:	000d883a 	mov	r6,zero
81126554:	000f883a 	mov	r7,zero
81126558:	d8c03d15 	stw	r3,244(sp)
8112655c:	da003e15 	stw	r8,248(sp)
81126560:	11380680 	call	81138068 <__eqdf2>
81126564:	d8c03d17 	ldw	r3,244(sp)
81126568:	da003e17 	ldw	r8,248(sp)
8112656c:	1000f51e 	bne	r2,zero,81126944 <___svfprintf_internal_r+0x1190>
81126570:	d8801f17 	ldw	r2,124(sp)
81126574:	01204574 	movhi	r4,33045
81126578:	210a9404 	addi	r4,r4,10832
8112657c:	18c00044 	addi	r3,r3,1
81126580:	10800044 	addi	r2,r2,1
81126584:	41000015 	stw	r4,0(r8)
81126588:	01000044 	movi	r4,1
8112658c:	41000115 	stw	r4,4(r8)
81126590:	d8c02015 	stw	r3,128(sp)
81126594:	d8801f15 	stw	r2,124(sp)
81126598:	010001c4 	movi	r4,7
8112659c:	20826616 	blt	r4,r2,81126f38 <___svfprintf_internal_r+0x1784>
811265a0:	42000204 	addi	r8,r8,8
811265a4:	d8802617 	ldw	r2,152(sp)
811265a8:	d9403317 	ldw	r5,204(sp)
811265ac:	11400216 	blt	r2,r5,811265b8 <___svfprintf_internal_r+0xe04>
811265b0:	9080004c 	andi	r2,r18,1
811265b4:	103ed526 	beq	r2,zero,8112610c <__reset+0xfb10610c>
811265b8:	d8803817 	ldw	r2,224(sp)
811265bc:	d9003417 	ldw	r4,208(sp)
811265c0:	d9403817 	ldw	r5,224(sp)
811265c4:	1887883a 	add	r3,r3,r2
811265c8:	d8801f17 	ldw	r2,124(sp)
811265cc:	41000015 	stw	r4,0(r8)
811265d0:	41400115 	stw	r5,4(r8)
811265d4:	10800044 	addi	r2,r2,1
811265d8:	d8c02015 	stw	r3,128(sp)
811265dc:	d8801f15 	stw	r2,124(sp)
811265e0:	010001c4 	movi	r4,7
811265e4:	2082af16 	blt	r4,r2,811270a4 <___svfprintf_internal_r+0x18f0>
811265e8:	42000204 	addi	r8,r8,8
811265ec:	d8803317 	ldw	r2,204(sp)
811265f0:	143fffc4 	addi	r16,r2,-1
811265f4:	043ec50e 	bge	zero,r16,8112610c <__reset+0xfb10610c>
811265f8:	04400404 	movi	r17,16
811265fc:	d8801f17 	ldw	r2,124(sp)
81126600:	8c00860e 	bge	r17,r16,8112681c <___svfprintf_internal_r+0x1068>
81126604:	01604574 	movhi	r5,33045
81126608:	294a9484 	addi	r5,r5,10834
8112660c:	d9402b15 	stw	r5,172(sp)
81126610:	058001c4 	movi	r22,7
81126614:	dd002c17 	ldw	r20,176(sp)
81126618:	00000306 	br	81126628 <___svfprintf_internal_r+0xe74>
8112661c:	42000204 	addi	r8,r8,8
81126620:	843ffc04 	addi	r16,r16,-16
81126624:	8c00800e 	bge	r17,r16,81126828 <___svfprintf_internal_r+0x1074>
81126628:	18c00404 	addi	r3,r3,16
8112662c:	10800044 	addi	r2,r2,1
81126630:	45400015 	stw	r21,0(r8)
81126634:	44400115 	stw	r17,4(r8)
81126638:	d8c02015 	stw	r3,128(sp)
8112663c:	d8801f15 	stw	r2,124(sp)
81126640:	b0bff60e 	bge	r22,r2,8112661c <__reset+0xfb10661c>
81126644:	d9801e04 	addi	r6,sp,120
81126648:	a00b883a 	mov	r5,r20
8112664c:	9809883a 	mov	r4,r19
81126650:	11320ec0 	call	811320ec <__ssprint_r>
81126654:	103d3e1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126658:	d8c02017 	ldw	r3,128(sp)
8112665c:	d8801f17 	ldw	r2,124(sp)
81126660:	da000404 	addi	r8,sp,16
81126664:	003fee06 	br	81126620 <__reset+0xfb106620>
81126668:	d9403117 	ldw	r5,196(sp)
8112666c:	d8802a17 	ldw	r2,168(sp)
81126670:	28adc83a 	sub	r22,r5,r2
81126674:	05be650e 	bge	zero,r22,8112600c <__reset+0xfb10600c>
81126678:	07000404 	movi	fp,16
8112667c:	d8801f17 	ldw	r2,124(sp)
81126680:	e583a20e 	bge	fp,r22,8112750c <___svfprintf_internal_r+0x1d58>
81126684:	01604574 	movhi	r5,33045
81126688:	294a9484 	addi	r5,r5,10834
8112668c:	dc403015 	stw	r17,192(sp)
81126690:	d9402b15 	stw	r5,172(sp)
81126694:	b023883a 	mov	r17,r22
81126698:	050001c4 	movi	r20,7
8112669c:	902d883a 	mov	r22,r18
811266a0:	8025883a 	mov	r18,r16
811266a4:	dc002c17 	ldw	r16,176(sp)
811266a8:	00000306 	br	811266b8 <___svfprintf_internal_r+0xf04>
811266ac:	8c7ffc04 	addi	r17,r17,-16
811266b0:	42000204 	addi	r8,r8,8
811266b4:	e440110e 	bge	fp,r17,811266fc <___svfprintf_internal_r+0xf48>
811266b8:	18c00404 	addi	r3,r3,16
811266bc:	10800044 	addi	r2,r2,1
811266c0:	45400015 	stw	r21,0(r8)
811266c4:	47000115 	stw	fp,4(r8)
811266c8:	d8c02015 	stw	r3,128(sp)
811266cc:	d8801f15 	stw	r2,124(sp)
811266d0:	a0bff60e 	bge	r20,r2,811266ac <__reset+0xfb1066ac>
811266d4:	d9801e04 	addi	r6,sp,120
811266d8:	800b883a 	mov	r5,r16
811266dc:	9809883a 	mov	r4,r19
811266e0:	11320ec0 	call	811320ec <__ssprint_r>
811266e4:	103d1a1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811266e8:	8c7ffc04 	addi	r17,r17,-16
811266ec:	d8c02017 	ldw	r3,128(sp)
811266f0:	d8801f17 	ldw	r2,124(sp)
811266f4:	da000404 	addi	r8,sp,16
811266f8:	e47fef16 	blt	fp,r17,811266b8 <__reset+0xfb1066b8>
811266fc:	9021883a 	mov	r16,r18
81126700:	b025883a 	mov	r18,r22
81126704:	882d883a 	mov	r22,r17
81126708:	dc403017 	ldw	r17,192(sp)
8112670c:	d9002b17 	ldw	r4,172(sp)
81126710:	1d87883a 	add	r3,r3,r22
81126714:	10800044 	addi	r2,r2,1
81126718:	41000015 	stw	r4,0(r8)
8112671c:	45800115 	stw	r22,4(r8)
81126720:	d8c02015 	stw	r3,128(sp)
81126724:	d8801f15 	stw	r2,124(sp)
81126728:	010001c4 	movi	r4,7
8112672c:	20819a16 	blt	r4,r2,81126d98 <___svfprintf_internal_r+0x15e4>
81126730:	42000204 	addi	r8,r8,8
81126734:	003e3506 	br	8112600c <__reset+0xfb10600c>
81126738:	d9403317 	ldw	r5,204(sp)
8112673c:	00800044 	movi	r2,1
81126740:	18c00044 	addi	r3,r3,1
81126744:	1141710e 	bge	r2,r5,81126d0c <___svfprintf_internal_r+0x1558>
81126748:	dc401f17 	ldw	r17,124(sp)
8112674c:	00800044 	movi	r2,1
81126750:	40800115 	stw	r2,4(r8)
81126754:	8c400044 	addi	r17,r17,1
81126758:	44000015 	stw	r16,0(r8)
8112675c:	d8c02015 	stw	r3,128(sp)
81126760:	dc401f15 	stw	r17,124(sp)
81126764:	008001c4 	movi	r2,7
81126768:	14417416 	blt	r2,r17,81126d3c <___svfprintf_internal_r+0x1588>
8112676c:	42000204 	addi	r8,r8,8
81126770:	d8803817 	ldw	r2,224(sp)
81126774:	d9003417 	ldw	r4,208(sp)
81126778:	8c400044 	addi	r17,r17,1
8112677c:	10c7883a 	add	r3,r2,r3
81126780:	40800115 	stw	r2,4(r8)
81126784:	41000015 	stw	r4,0(r8)
81126788:	d8c02015 	stw	r3,128(sp)
8112678c:	dc401f15 	stw	r17,124(sp)
81126790:	008001c4 	movi	r2,7
81126794:	14417216 	blt	r2,r17,81126d60 <___svfprintf_internal_r+0x15ac>
81126798:	45800204 	addi	r22,r8,8
8112679c:	d9003617 	ldw	r4,216(sp)
811267a0:	d9403717 	ldw	r5,220(sp)
811267a4:	000d883a 	mov	r6,zero
811267a8:	000f883a 	mov	r7,zero
811267ac:	d8c03d15 	stw	r3,244(sp)
811267b0:	11380680 	call	81138068 <__eqdf2>
811267b4:	d8c03d17 	ldw	r3,244(sp)
811267b8:	1000b326 	beq	r2,zero,81126a88 <___svfprintf_internal_r+0x12d4>
811267bc:	d9403317 	ldw	r5,204(sp)
811267c0:	84000044 	addi	r16,r16,1
811267c4:	8c400044 	addi	r17,r17,1
811267c8:	28bfffc4 	addi	r2,r5,-1
811267cc:	1887883a 	add	r3,r3,r2
811267d0:	b0800115 	stw	r2,4(r22)
811267d4:	b4000015 	stw	r16,0(r22)
811267d8:	d8c02015 	stw	r3,128(sp)
811267dc:	dc401f15 	stw	r17,124(sp)
811267e0:	008001c4 	movi	r2,7
811267e4:	1440d216 	blt	r2,r17,81126b30 <___svfprintf_internal_r+0x137c>
811267e8:	b5800204 	addi	r22,r22,8
811267ec:	d9003b17 	ldw	r4,236(sp)
811267f0:	df0022c4 	addi	fp,sp,139
811267f4:	8c400044 	addi	r17,r17,1
811267f8:	20c7883a 	add	r3,r4,r3
811267fc:	b7000015 	stw	fp,0(r22)
81126800:	b1000115 	stw	r4,4(r22)
81126804:	d8c02015 	stw	r3,128(sp)
81126808:	dc401f15 	stw	r17,124(sp)
8112680c:	008001c4 	movi	r2,7
81126810:	14400e16 	blt	r2,r17,8112684c <___svfprintf_internal_r+0x1098>
81126814:	b2000204 	addi	r8,r22,8
81126818:	003e3c06 	br	8112610c <__reset+0xfb10610c>
8112681c:	01204574 	movhi	r4,33045
81126820:	210a9484 	addi	r4,r4,10834
81126824:	d9002b15 	stw	r4,172(sp)
81126828:	d9002b17 	ldw	r4,172(sp)
8112682c:	1c07883a 	add	r3,r3,r16
81126830:	44000115 	stw	r16,4(r8)
81126834:	41000015 	stw	r4,0(r8)
81126838:	10800044 	addi	r2,r2,1
8112683c:	d8c02015 	stw	r3,128(sp)
81126840:	d8801f15 	stw	r2,124(sp)
81126844:	010001c4 	movi	r4,7
81126848:	20be2f0e 	bge	r4,r2,81126108 <__reset+0xfb106108>
8112684c:	d9402c17 	ldw	r5,176(sp)
81126850:	d9801e04 	addi	r6,sp,120
81126854:	9809883a 	mov	r4,r19
81126858:	11320ec0 	call	811320ec <__ssprint_r>
8112685c:	103cbc1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126860:	d8c02017 	ldw	r3,128(sp)
81126864:	da000404 	addi	r8,sp,16
81126868:	003e2806 	br	8112610c <__reset+0xfb10610c>
8112686c:	d9402c17 	ldw	r5,176(sp)
81126870:	d9801e04 	addi	r6,sp,120
81126874:	9809883a 	mov	r4,r19
81126878:	11320ec0 	call	811320ec <__ssprint_r>
8112687c:	103e5f26 	beq	r2,zero,811261fc <__reset+0xfb1061fc>
81126880:	003cb306 	br	81125b50 <__reset+0xfb105b50>
81126884:	d9402c17 	ldw	r5,176(sp)
81126888:	d9801e04 	addi	r6,sp,120
8112688c:	9809883a 	mov	r4,r19
81126890:	11320ec0 	call	811320ec <__ssprint_r>
81126894:	103cae1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126898:	d8c02017 	ldw	r3,128(sp)
8112689c:	da000404 	addi	r8,sp,16
811268a0:	003e0d06 	br	811260d8 <__reset+0xfb1060d8>
811268a4:	d9402c17 	ldw	r5,176(sp)
811268a8:	d9801e04 	addi	r6,sp,120
811268ac:	9809883a 	mov	r4,r19
811268b0:	11320ec0 	call	811320ec <__ssprint_r>
811268b4:	103ca61e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811268b8:	d8c02017 	ldw	r3,128(sp)
811268bc:	da000404 	addi	r8,sp,16
811268c0:	003dc106 	br	81125fc8 <__reset+0xfb105fc8>
811268c4:	d9402c17 	ldw	r5,176(sp)
811268c8:	d9801e04 	addi	r6,sp,120
811268cc:	9809883a 	mov	r4,r19
811268d0:	11320ec0 	call	811320ec <__ssprint_r>
811268d4:	103c9e1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811268d8:	d8c02017 	ldw	r3,128(sp)
811268dc:	da000404 	addi	r8,sp,16
811268e0:	003dc706 	br	81126000 <__reset+0xfb106000>
811268e4:	d8802917 	ldw	r2,164(sp)
811268e8:	d8002785 	stb	zero,158(sp)
811268ec:	103f0816 	blt	r2,zero,81126510 <__reset+0xfb106510>
811268f0:	00ffdfc4 	movi	r3,-129
811268f4:	a584b03a 	or	r2,r20,r22
811268f8:	90e4703a 	and	r18,r18,r3
811268fc:	103c8126 	beq	r2,zero,81125b04 <__reset+0xfb105b04>
81126900:	0039883a 	mov	fp,zero
81126904:	003e7606 	br	811262e0 <__reset+0xfb1062e0>
81126908:	9080040c 	andi	r2,r18,16
8112690c:	10013d26 	beq	r2,zero,81126e04 <___svfprintf_internal_r+0x1650>
81126910:	d9002d17 	ldw	r4,180(sp)
81126914:	d9402917 	ldw	r5,164(sp)
81126918:	d8002785 	stb	zero,158(sp)
8112691c:	20800104 	addi	r2,r4,4
81126920:	25000017 	ldw	r20,0(r4)
81126924:	002d883a 	mov	r22,zero
81126928:	28013f16 	blt	r5,zero,81126e28 <___svfprintf_internal_r+0x1674>
8112692c:	00ffdfc4 	movi	r3,-129
81126930:	d8802d15 	stw	r2,180(sp)
81126934:	90e4703a 	and	r18,r18,r3
81126938:	a03d2b26 	beq	r20,zero,81125de8 <__reset+0xfb105de8>
8112693c:	0039883a 	mov	fp,zero
81126940:	003d2e06 	br	81125dfc <__reset+0xfb105dfc>
81126944:	dc402617 	ldw	r17,152(sp)
81126948:	0441830e 	bge	zero,r17,81126f58 <___svfprintf_internal_r+0x17a4>
8112694c:	dc403217 	ldw	r17,200(sp)
81126950:	d8803317 	ldw	r2,204(sp)
81126954:	1440010e 	bge	r2,r17,8112695c <___svfprintf_internal_r+0x11a8>
81126958:	1023883a 	mov	r17,r2
8112695c:	04400a0e 	bge	zero,r17,81126988 <___svfprintf_internal_r+0x11d4>
81126960:	d8801f17 	ldw	r2,124(sp)
81126964:	1c47883a 	add	r3,r3,r17
81126968:	44000015 	stw	r16,0(r8)
8112696c:	10800044 	addi	r2,r2,1
81126970:	44400115 	stw	r17,4(r8)
81126974:	d8c02015 	stw	r3,128(sp)
81126978:	d8801f15 	stw	r2,124(sp)
8112697c:	010001c4 	movi	r4,7
81126980:	20827516 	blt	r4,r2,81127358 <___svfprintf_internal_r+0x1ba4>
81126984:	42000204 	addi	r8,r8,8
81126988:	88027b16 	blt	r17,zero,81127378 <___svfprintf_internal_r+0x1bc4>
8112698c:	d9003217 	ldw	r4,200(sp)
81126990:	2463c83a 	sub	r17,r4,r17
81126994:	0440990e 	bge	zero,r17,81126bfc <___svfprintf_internal_r+0x1448>
81126998:	05800404 	movi	r22,16
8112699c:	d8801f17 	ldw	r2,124(sp)
811269a0:	b441530e 	bge	r22,r17,81126ef0 <___svfprintf_internal_r+0x173c>
811269a4:	01204574 	movhi	r4,33045
811269a8:	210a9484 	addi	r4,r4,10834
811269ac:	d9002b15 	stw	r4,172(sp)
811269b0:	070001c4 	movi	fp,7
811269b4:	dd002c17 	ldw	r20,176(sp)
811269b8:	00000306 	br	811269c8 <___svfprintf_internal_r+0x1214>
811269bc:	42000204 	addi	r8,r8,8
811269c0:	8c7ffc04 	addi	r17,r17,-16
811269c4:	b4414d0e 	bge	r22,r17,81126efc <___svfprintf_internal_r+0x1748>
811269c8:	18c00404 	addi	r3,r3,16
811269cc:	10800044 	addi	r2,r2,1
811269d0:	45400015 	stw	r21,0(r8)
811269d4:	45800115 	stw	r22,4(r8)
811269d8:	d8c02015 	stw	r3,128(sp)
811269dc:	d8801f15 	stw	r2,124(sp)
811269e0:	e0bff60e 	bge	fp,r2,811269bc <__reset+0xfb1069bc>
811269e4:	d9801e04 	addi	r6,sp,120
811269e8:	a00b883a 	mov	r5,r20
811269ec:	9809883a 	mov	r4,r19
811269f0:	11320ec0 	call	811320ec <__ssprint_r>
811269f4:	103c561e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811269f8:	d8c02017 	ldw	r3,128(sp)
811269fc:	d8801f17 	ldw	r2,124(sp)
81126a00:	da000404 	addi	r8,sp,16
81126a04:	003fee06 	br	811269c0 <__reset+0xfb1069c0>
81126a08:	d9402c17 	ldw	r5,176(sp)
81126a0c:	d9801e04 	addi	r6,sp,120
81126a10:	9809883a 	mov	r4,r19
81126a14:	11320ec0 	call	811320ec <__ssprint_r>
81126a18:	103c4d1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126a1c:	d8c02017 	ldw	r3,128(sp)
81126a20:	df002787 	ldb	fp,158(sp)
81126a24:	da000404 	addi	r8,sp,16
81126a28:	003d5a06 	br	81125f94 <__reset+0xfb105f94>
81126a2c:	9080040c 	andi	r2,r18,16
81126a30:	10005c26 	beq	r2,zero,81126ba4 <___svfprintf_internal_r+0x13f0>
81126a34:	d9402d17 	ldw	r5,180(sp)
81126a38:	d8c02917 	ldw	r3,164(sp)
81126a3c:	d8002785 	stb	zero,158(sp)
81126a40:	28800104 	addi	r2,r5,4
81126a44:	2d000017 	ldw	r20,0(r5)
81126a48:	002d883a 	mov	r22,zero
81126a4c:	18005e16 	blt	r3,zero,81126bc8 <___svfprintf_internal_r+0x1414>
81126a50:	00ffdfc4 	movi	r3,-129
81126a54:	d8802d15 	stw	r2,180(sp)
81126a58:	90e4703a 	and	r18,r18,r3
81126a5c:	0039883a 	mov	fp,zero
81126a60:	a03dfe26 	beq	r20,zero,8112625c <__reset+0xfb10625c>
81126a64:	00800244 	movi	r2,9
81126a68:	153cb336 	bltu	r2,r20,81125d38 <__reset+0xfb105d38>
81126a6c:	a5000c04 	addi	r20,r20,48
81126a70:	dc001dc4 	addi	r16,sp,119
81126a74:	dd001dc5 	stb	r20,119(sp)
81126a78:	d8c02817 	ldw	r3,160(sp)
81126a7c:	1c07c83a 	sub	r3,r3,r16
81126a80:	d8c02e15 	stw	r3,184(sp)
81126a84:	003cf506 	br	81125e5c <__reset+0xfb105e5c>
81126a88:	d8803317 	ldw	r2,204(sp)
81126a8c:	143fffc4 	addi	r16,r2,-1
81126a90:	043f560e 	bge	zero,r16,811267ec <__reset+0xfb1067ec>
81126a94:	07000404 	movi	fp,16
81126a98:	e403530e 	bge	fp,r16,811277e8 <___svfprintf_internal_r+0x2034>
81126a9c:	01604574 	movhi	r5,33045
81126aa0:	294a9484 	addi	r5,r5,10834
81126aa4:	d9402b15 	stw	r5,172(sp)
81126aa8:	01c001c4 	movi	r7,7
81126aac:	dd002c17 	ldw	r20,176(sp)
81126ab0:	00000306 	br	81126ac0 <___svfprintf_internal_r+0x130c>
81126ab4:	843ffc04 	addi	r16,r16,-16
81126ab8:	b5800204 	addi	r22,r22,8
81126abc:	e400130e 	bge	fp,r16,81126b0c <___svfprintf_internal_r+0x1358>
81126ac0:	18c00404 	addi	r3,r3,16
81126ac4:	8c400044 	addi	r17,r17,1
81126ac8:	b5400015 	stw	r21,0(r22)
81126acc:	b7000115 	stw	fp,4(r22)
81126ad0:	d8c02015 	stw	r3,128(sp)
81126ad4:	dc401f15 	stw	r17,124(sp)
81126ad8:	3c7ff60e 	bge	r7,r17,81126ab4 <__reset+0xfb106ab4>
81126adc:	d9801e04 	addi	r6,sp,120
81126ae0:	a00b883a 	mov	r5,r20
81126ae4:	9809883a 	mov	r4,r19
81126ae8:	d9c03d15 	stw	r7,244(sp)
81126aec:	11320ec0 	call	811320ec <__ssprint_r>
81126af0:	d9c03d17 	ldw	r7,244(sp)
81126af4:	103c161e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126af8:	843ffc04 	addi	r16,r16,-16
81126afc:	d8c02017 	ldw	r3,128(sp)
81126b00:	dc401f17 	ldw	r17,124(sp)
81126b04:	dd800404 	addi	r22,sp,16
81126b08:	e43fed16 	blt	fp,r16,81126ac0 <__reset+0xfb106ac0>
81126b0c:	d8802b17 	ldw	r2,172(sp)
81126b10:	1c07883a 	add	r3,r3,r16
81126b14:	8c400044 	addi	r17,r17,1
81126b18:	b0800015 	stw	r2,0(r22)
81126b1c:	b4000115 	stw	r16,4(r22)
81126b20:	d8c02015 	stw	r3,128(sp)
81126b24:	dc401f15 	stw	r17,124(sp)
81126b28:	008001c4 	movi	r2,7
81126b2c:	147f2e0e 	bge	r2,r17,811267e8 <__reset+0xfb1067e8>
81126b30:	d9402c17 	ldw	r5,176(sp)
81126b34:	d9801e04 	addi	r6,sp,120
81126b38:	9809883a 	mov	r4,r19
81126b3c:	11320ec0 	call	811320ec <__ssprint_r>
81126b40:	103c031e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126b44:	d8c02017 	ldw	r3,128(sp)
81126b48:	dc401f17 	ldw	r17,124(sp)
81126b4c:	dd800404 	addi	r22,sp,16
81126b50:	003f2606 	br	811267ec <__reset+0xfb1067ec>
81126b54:	9080040c 	andi	r2,r18,16
81126b58:	1000c326 	beq	r2,zero,81126e68 <___svfprintf_internal_r+0x16b4>
81126b5c:	d8802d17 	ldw	r2,180(sp)
81126b60:	15000017 	ldw	r20,0(r2)
81126b64:	10800104 	addi	r2,r2,4
81126b68:	d8802d15 	stw	r2,180(sp)
81126b6c:	a02dd7fa 	srai	r22,r20,31
81126b70:	b005883a 	mov	r2,r22
81126b74:	103c680e 	bge	r2,zero,81125d18 <__reset+0xfb105d18>
81126b78:	0529c83a 	sub	r20,zero,r20
81126b7c:	a004c03a 	cmpne	r2,r20,zero
81126b80:	05adc83a 	sub	r22,zero,r22
81126b84:	b0adc83a 	sub	r22,r22,r2
81126b88:	d8802917 	ldw	r2,164(sp)
81126b8c:	07000b44 	movi	fp,45
81126b90:	df002785 	stb	fp,158(sp)
81126b94:	10022e16 	blt	r2,zero,81127450 <___svfprintf_internal_r+0x1c9c>
81126b98:	00bfdfc4 	movi	r2,-129
81126b9c:	90a4703a 	and	r18,r18,r2
81126ba0:	003c6406 	br	81125d34 <__reset+0xfb105d34>
81126ba4:	9080100c 	andi	r2,r18,64
81126ba8:	d8002785 	stb	zero,158(sp)
81126bac:	10012526 	beq	r2,zero,81127044 <___svfprintf_internal_r+0x1890>
81126bb0:	d9002d17 	ldw	r4,180(sp)
81126bb4:	d9402917 	ldw	r5,164(sp)
81126bb8:	002d883a 	mov	r22,zero
81126bbc:	20800104 	addi	r2,r4,4
81126bc0:	2500000b 	ldhu	r20,0(r4)
81126bc4:	283fa20e 	bge	r5,zero,81126a50 <__reset+0xfb106a50>
81126bc8:	d8802d15 	stw	r2,180(sp)
81126bcc:	0039883a 	mov	fp,zero
81126bd0:	a584b03a 	or	r2,r20,r22
81126bd4:	103c571e 	bne	r2,zero,81125d34 <__reset+0xfb105d34>
81126bd8:	00800044 	movi	r2,1
81126bdc:	003e5006 	br	81126520 <__reset+0xfb106520>
81126be0:	d9402c17 	ldw	r5,176(sp)
81126be4:	d9801e04 	addi	r6,sp,120
81126be8:	9809883a 	mov	r4,r19
81126bec:	11320ec0 	call	811320ec <__ssprint_r>
81126bf0:	103bd71e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126bf4:	d8c02017 	ldw	r3,128(sp)
81126bf8:	da000404 	addi	r8,sp,16
81126bfc:	d9003217 	ldw	r4,200(sp)
81126c00:	d8802617 	ldw	r2,152(sp)
81126c04:	d9403317 	ldw	r5,204(sp)
81126c08:	8123883a 	add	r17,r16,r4
81126c0c:	11400216 	blt	r2,r5,81126c18 <___svfprintf_internal_r+0x1464>
81126c10:	9100004c 	andi	r4,r18,1
81126c14:	20000d26 	beq	r4,zero,81126c4c <___svfprintf_internal_r+0x1498>
81126c18:	d9003817 	ldw	r4,224(sp)
81126c1c:	d9403417 	ldw	r5,208(sp)
81126c20:	1907883a 	add	r3,r3,r4
81126c24:	d9001f17 	ldw	r4,124(sp)
81126c28:	41400015 	stw	r5,0(r8)
81126c2c:	d9403817 	ldw	r5,224(sp)
81126c30:	21000044 	addi	r4,r4,1
81126c34:	d8c02015 	stw	r3,128(sp)
81126c38:	41400115 	stw	r5,4(r8)
81126c3c:	d9001f15 	stw	r4,124(sp)
81126c40:	014001c4 	movi	r5,7
81126c44:	2901dc16 	blt	r5,r4,811273b8 <___svfprintf_internal_r+0x1c04>
81126c48:	42000204 	addi	r8,r8,8
81126c4c:	d9003317 	ldw	r4,204(sp)
81126c50:	8121883a 	add	r16,r16,r4
81126c54:	2085c83a 	sub	r2,r4,r2
81126c58:	8461c83a 	sub	r16,r16,r17
81126c5c:	1400010e 	bge	r2,r16,81126c64 <___svfprintf_internal_r+0x14b0>
81126c60:	1021883a 	mov	r16,r2
81126c64:	04000a0e 	bge	zero,r16,81126c90 <___svfprintf_internal_r+0x14dc>
81126c68:	d9001f17 	ldw	r4,124(sp)
81126c6c:	1c07883a 	add	r3,r3,r16
81126c70:	44400015 	stw	r17,0(r8)
81126c74:	21000044 	addi	r4,r4,1
81126c78:	44000115 	stw	r16,4(r8)
81126c7c:	d8c02015 	stw	r3,128(sp)
81126c80:	d9001f15 	stw	r4,124(sp)
81126c84:	014001c4 	movi	r5,7
81126c88:	2901e616 	blt	r5,r4,81127424 <___svfprintf_internal_r+0x1c70>
81126c8c:	42000204 	addi	r8,r8,8
81126c90:	8001f616 	blt	r16,zero,8112746c <___svfprintf_internal_r+0x1cb8>
81126c94:	1421c83a 	sub	r16,r2,r16
81126c98:	043d1c0e 	bge	zero,r16,8112610c <__reset+0xfb10610c>
81126c9c:	04400404 	movi	r17,16
81126ca0:	d8801f17 	ldw	r2,124(sp)
81126ca4:	8c3edd0e 	bge	r17,r16,8112681c <__reset+0xfb10681c>
81126ca8:	01604574 	movhi	r5,33045
81126cac:	294a9484 	addi	r5,r5,10834
81126cb0:	d9402b15 	stw	r5,172(sp)
81126cb4:	058001c4 	movi	r22,7
81126cb8:	dd002c17 	ldw	r20,176(sp)
81126cbc:	00000306 	br	81126ccc <___svfprintf_internal_r+0x1518>
81126cc0:	42000204 	addi	r8,r8,8
81126cc4:	843ffc04 	addi	r16,r16,-16
81126cc8:	8c3ed70e 	bge	r17,r16,81126828 <__reset+0xfb106828>
81126ccc:	18c00404 	addi	r3,r3,16
81126cd0:	10800044 	addi	r2,r2,1
81126cd4:	45400015 	stw	r21,0(r8)
81126cd8:	44400115 	stw	r17,4(r8)
81126cdc:	d8c02015 	stw	r3,128(sp)
81126ce0:	d8801f15 	stw	r2,124(sp)
81126ce4:	b0bff60e 	bge	r22,r2,81126cc0 <__reset+0xfb106cc0>
81126ce8:	d9801e04 	addi	r6,sp,120
81126cec:	a00b883a 	mov	r5,r20
81126cf0:	9809883a 	mov	r4,r19
81126cf4:	11320ec0 	call	811320ec <__ssprint_r>
81126cf8:	103b951e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126cfc:	d8c02017 	ldw	r3,128(sp)
81126d00:	d8801f17 	ldw	r2,124(sp)
81126d04:	da000404 	addi	r8,sp,16
81126d08:	003fee06 	br	81126cc4 <__reset+0xfb106cc4>
81126d0c:	9088703a 	and	r4,r18,r2
81126d10:	203e8d1e 	bne	r4,zero,81126748 <__reset+0xfb106748>
81126d14:	dc401f17 	ldw	r17,124(sp)
81126d18:	40800115 	stw	r2,4(r8)
81126d1c:	44000015 	stw	r16,0(r8)
81126d20:	8c400044 	addi	r17,r17,1
81126d24:	d8c02015 	stw	r3,128(sp)
81126d28:	dc401f15 	stw	r17,124(sp)
81126d2c:	008001c4 	movi	r2,7
81126d30:	147f7f16 	blt	r2,r17,81126b30 <__reset+0xfb106b30>
81126d34:	45800204 	addi	r22,r8,8
81126d38:	003eac06 	br	811267ec <__reset+0xfb1067ec>
81126d3c:	d9402c17 	ldw	r5,176(sp)
81126d40:	d9801e04 	addi	r6,sp,120
81126d44:	9809883a 	mov	r4,r19
81126d48:	11320ec0 	call	811320ec <__ssprint_r>
81126d4c:	103b801e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126d50:	d8c02017 	ldw	r3,128(sp)
81126d54:	dc401f17 	ldw	r17,124(sp)
81126d58:	da000404 	addi	r8,sp,16
81126d5c:	003e8406 	br	81126770 <__reset+0xfb106770>
81126d60:	d9402c17 	ldw	r5,176(sp)
81126d64:	d9801e04 	addi	r6,sp,120
81126d68:	9809883a 	mov	r4,r19
81126d6c:	11320ec0 	call	811320ec <__ssprint_r>
81126d70:	103b771e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126d74:	d8c02017 	ldw	r3,128(sp)
81126d78:	dc401f17 	ldw	r17,124(sp)
81126d7c:	dd800404 	addi	r22,sp,16
81126d80:	003e8606 	br	8112679c <__reset+0xfb10679c>
81126d84:	0029883a 	mov	r20,zero
81126d88:	a5000c04 	addi	r20,r20,48
81126d8c:	dc001dc4 	addi	r16,sp,119
81126d90:	dd001dc5 	stb	r20,119(sp)
81126d94:	003f3806 	br	81126a78 <__reset+0xfb106a78>
81126d98:	d9402c17 	ldw	r5,176(sp)
81126d9c:	d9801e04 	addi	r6,sp,120
81126da0:	9809883a 	mov	r4,r19
81126da4:	11320ec0 	call	811320ec <__ssprint_r>
81126da8:	103b691e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126dac:	d8c02017 	ldw	r3,128(sp)
81126db0:	da000404 	addi	r8,sp,16
81126db4:	003c9506 	br	8112600c <__reset+0xfb10600c>
81126db8:	d9003617 	ldw	r4,216(sp)
81126dbc:	d9403717 	ldw	r5,220(sp)
81126dc0:	da003e15 	stw	r8,248(sp)
81126dc4:	11301e80 	call	811301e8 <__fpclassifyd>
81126dc8:	da003e17 	ldw	r8,248(sp)
81126dcc:	1000bd1e 	bne	r2,zero,811270c4 <___svfprintf_internal_r+0x1910>
81126dd0:	008011c4 	movi	r2,71
81126dd4:	14411e0e 	bge	r2,r17,81127250 <___svfprintf_internal_r+0x1a9c>
81126dd8:	04204574 	movhi	r16,33045
81126ddc:	840a8704 	addi	r16,r16,10780
81126de0:	00c000c4 	movi	r3,3
81126de4:	00bfdfc4 	movi	r2,-129
81126de8:	d8c02a15 	stw	r3,168(sp)
81126dec:	90a4703a 	and	r18,r18,r2
81126df0:	df002783 	ldbu	fp,158(sp)
81126df4:	d8c02e15 	stw	r3,184(sp)
81126df8:	d8002915 	stw	zero,164(sp)
81126dfc:	d8003215 	stw	zero,200(sp)
81126e00:	003c1c06 	br	81125e74 <__reset+0xfb105e74>
81126e04:	9080100c 	andi	r2,r18,64
81126e08:	d8002785 	stb	zero,158(sp)
81126e0c:	10009426 	beq	r2,zero,81127060 <___svfprintf_internal_r+0x18ac>
81126e10:	d8c02d17 	ldw	r3,180(sp)
81126e14:	d9002917 	ldw	r4,164(sp)
81126e18:	002d883a 	mov	r22,zero
81126e1c:	18800104 	addi	r2,r3,4
81126e20:	1d00000b 	ldhu	r20,0(r3)
81126e24:	203ec10e 	bge	r4,zero,8112692c <__reset+0xfb10692c>
81126e28:	a586b03a 	or	r3,r20,r22
81126e2c:	d8802d15 	stw	r2,180(sp)
81126e30:	183ec21e 	bne	r3,zero,8112693c <__reset+0xfb10693c>
81126e34:	0039883a 	mov	fp,zero
81126e38:	0005883a 	mov	r2,zero
81126e3c:	003db806 	br	81126520 <__reset+0xfb106520>
81126e40:	d8802d17 	ldw	r2,180(sp)
81126e44:	d8c02d17 	ldw	r3,180(sp)
81126e48:	d9002d17 	ldw	r4,180(sp)
81126e4c:	10800017 	ldw	r2,0(r2)
81126e50:	18c00117 	ldw	r3,4(r3)
81126e54:	21000204 	addi	r4,r4,8
81126e58:	d8803615 	stw	r2,216(sp)
81126e5c:	d8c03715 	stw	r3,220(sp)
81126e60:	d9002d15 	stw	r4,180(sp)
81126e64:	003b8206 	br	81125c70 <__reset+0xfb105c70>
81126e68:	9080100c 	andi	r2,r18,64
81126e6c:	10010726 	beq	r2,zero,8112728c <___svfprintf_internal_r+0x1ad8>
81126e70:	d8c02d17 	ldw	r3,180(sp)
81126e74:	1d00000f 	ldh	r20,0(r3)
81126e78:	18c00104 	addi	r3,r3,4
81126e7c:	d8c02d15 	stw	r3,180(sp)
81126e80:	a02dd7fa 	srai	r22,r20,31
81126e84:	b005883a 	mov	r2,r22
81126e88:	003ba206 	br	81125d14 <__reset+0xfb105d14>
81126e8c:	9080100c 	andi	r2,r18,64
81126e90:	10010526 	beq	r2,zero,811272a8 <___svfprintf_internal_r+0x1af4>
81126e94:	d9002d17 	ldw	r4,180(sp)
81126e98:	002d883a 	mov	r22,zero
81126e9c:	2500000b 	ldhu	r20,0(r4)
81126ea0:	21000104 	addi	r4,r4,4
81126ea4:	d9002d15 	stw	r4,180(sp)
81126ea8:	003cfe06 	br	811262a4 <__reset+0xfb1062a4>
81126eac:	bc400007 	ldb	r17,0(r23)
81126eb0:	003a9606 	br	8112590c <__reset+0xfb10590c>
81126eb4:	9080040c 	andi	r2,r18,16
81126eb8:	10010126 	beq	r2,zero,811272c0 <___svfprintf_internal_r+0x1b0c>
81126ebc:	d9402d17 	ldw	r5,180(sp)
81126ec0:	d8c02f17 	ldw	r3,188(sp)
81126ec4:	28800017 	ldw	r2,0(r5)
81126ec8:	29400104 	addi	r5,r5,4
81126ecc:	d9402d15 	stw	r5,180(sp)
81126ed0:	10c00015 	stw	r3,0(r2)
81126ed4:	003a6406 	br	81125868 <__reset+0xfb105868>
81126ed8:	d9002917 	ldw	r4,164(sp)
81126edc:	d8002785 	stb	zero,158(sp)
81126ee0:	203d8d16 	blt	r4,zero,81126518 <__reset+0xfb106518>
81126ee4:	00bfdfc4 	movi	r2,-129
81126ee8:	90a4703a 	and	r18,r18,r2
81126eec:	003b0506 	br	81125b04 <__reset+0xfb105b04>
81126ef0:	01604574 	movhi	r5,33045
81126ef4:	294a9484 	addi	r5,r5,10834
81126ef8:	d9402b15 	stw	r5,172(sp)
81126efc:	d9402b17 	ldw	r5,172(sp)
81126f00:	1c47883a 	add	r3,r3,r17
81126f04:	10800044 	addi	r2,r2,1
81126f08:	41400015 	stw	r5,0(r8)
81126f0c:	44400115 	stw	r17,4(r8)
81126f10:	d8c02015 	stw	r3,128(sp)
81126f14:	d8801f15 	stw	r2,124(sp)
81126f18:	010001c4 	movi	r4,7
81126f1c:	20bf3016 	blt	r4,r2,81126be0 <__reset+0xfb106be0>
81126f20:	42000204 	addi	r8,r8,8
81126f24:	003f3506 	br	81126bfc <__reset+0xfb106bfc>
81126f28:	01204574 	movhi	r4,33045
81126f2c:	210a9484 	addi	r4,r4,10834
81126f30:	d9002b15 	stw	r4,172(sp)
81126f34:	003c5e06 	br	811260b0 <__reset+0xfb1060b0>
81126f38:	d9402c17 	ldw	r5,176(sp)
81126f3c:	d9801e04 	addi	r6,sp,120
81126f40:	9809883a 	mov	r4,r19
81126f44:	11320ec0 	call	811320ec <__ssprint_r>
81126f48:	103b011e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81126f4c:	d8c02017 	ldw	r3,128(sp)
81126f50:	da000404 	addi	r8,sp,16
81126f54:	003d9306 	br	811265a4 <__reset+0xfb1065a4>
81126f58:	d8801f17 	ldw	r2,124(sp)
81126f5c:	01604574 	movhi	r5,33045
81126f60:	01000044 	movi	r4,1
81126f64:	18c00044 	addi	r3,r3,1
81126f68:	10800044 	addi	r2,r2,1
81126f6c:	294a9404 	addi	r5,r5,10832
81126f70:	41000115 	stw	r4,4(r8)
81126f74:	41400015 	stw	r5,0(r8)
81126f78:	d8c02015 	stw	r3,128(sp)
81126f7c:	d8801f15 	stw	r2,124(sp)
81126f80:	010001c4 	movi	r4,7
81126f84:	2080b516 	blt	r4,r2,8112725c <___svfprintf_internal_r+0x1aa8>
81126f88:	42000204 	addi	r8,r8,8
81126f8c:	8800041e 	bne	r17,zero,81126fa0 <___svfprintf_internal_r+0x17ec>
81126f90:	d8803317 	ldw	r2,204(sp)
81126f94:	1000021e 	bne	r2,zero,81126fa0 <___svfprintf_internal_r+0x17ec>
81126f98:	9080004c 	andi	r2,r18,1
81126f9c:	103c5b26 	beq	r2,zero,8112610c <__reset+0xfb10610c>
81126fa0:	d9003817 	ldw	r4,224(sp)
81126fa4:	d8801f17 	ldw	r2,124(sp)
81126fa8:	d9403417 	ldw	r5,208(sp)
81126fac:	20c7883a 	add	r3,r4,r3
81126fb0:	10800044 	addi	r2,r2,1
81126fb4:	41000115 	stw	r4,4(r8)
81126fb8:	41400015 	stw	r5,0(r8)
81126fbc:	d8c02015 	stw	r3,128(sp)
81126fc0:	d8801f15 	stw	r2,124(sp)
81126fc4:	010001c4 	movi	r4,7
81126fc8:	20818016 	blt	r4,r2,811275cc <___svfprintf_internal_r+0x1e18>
81126fcc:	42000204 	addi	r8,r8,8
81126fd0:	0463c83a 	sub	r17,zero,r17
81126fd4:	0440cb0e 	bge	zero,r17,81127304 <___svfprintf_internal_r+0x1b50>
81126fd8:	05800404 	movi	r22,16
81126fdc:	b440e80e 	bge	r22,r17,81127380 <___svfprintf_internal_r+0x1bcc>
81126fe0:	01604574 	movhi	r5,33045
81126fe4:	294a9484 	addi	r5,r5,10834
81126fe8:	d9402b15 	stw	r5,172(sp)
81126fec:	070001c4 	movi	fp,7
81126ff0:	dd002c17 	ldw	r20,176(sp)
81126ff4:	00000306 	br	81127004 <___svfprintf_internal_r+0x1850>
81126ff8:	42000204 	addi	r8,r8,8
81126ffc:	8c7ffc04 	addi	r17,r17,-16
81127000:	b440e20e 	bge	r22,r17,8112738c <___svfprintf_internal_r+0x1bd8>
81127004:	18c00404 	addi	r3,r3,16
81127008:	10800044 	addi	r2,r2,1
8112700c:	45400015 	stw	r21,0(r8)
81127010:	45800115 	stw	r22,4(r8)
81127014:	d8c02015 	stw	r3,128(sp)
81127018:	d8801f15 	stw	r2,124(sp)
8112701c:	e0bff60e 	bge	fp,r2,81126ff8 <__reset+0xfb106ff8>
81127020:	d9801e04 	addi	r6,sp,120
81127024:	a00b883a 	mov	r5,r20
81127028:	9809883a 	mov	r4,r19
8112702c:	11320ec0 	call	811320ec <__ssprint_r>
81127030:	103ac71e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81127034:	d8c02017 	ldw	r3,128(sp)
81127038:	d8801f17 	ldw	r2,124(sp)
8112703c:	da000404 	addi	r8,sp,16
81127040:	003fee06 	br	81126ffc <__reset+0xfb106ffc>
81127044:	d8c02d17 	ldw	r3,180(sp)
81127048:	d9002917 	ldw	r4,164(sp)
8112704c:	002d883a 	mov	r22,zero
81127050:	18800104 	addi	r2,r3,4
81127054:	1d000017 	ldw	r20,0(r3)
81127058:	203e7d0e 	bge	r4,zero,81126a50 <__reset+0xfb106a50>
8112705c:	003eda06 	br	81126bc8 <__reset+0xfb106bc8>
81127060:	d9402d17 	ldw	r5,180(sp)
81127064:	d8c02917 	ldw	r3,164(sp)
81127068:	002d883a 	mov	r22,zero
8112706c:	28800104 	addi	r2,r5,4
81127070:	2d000017 	ldw	r20,0(r5)
81127074:	183e2d0e 	bge	r3,zero,8112692c <__reset+0xfb10692c>
81127078:	003f6b06 	br	81126e28 <__reset+0xfb106e28>
8112707c:	d8c02d15 	stw	r3,180(sp)
81127080:	0039883a 	mov	fp,zero
81127084:	003ed206 	br	81126bd0 <__reset+0xfb106bd0>
81127088:	bc400043 	ldbu	r17,1(r23)
8112708c:	94800814 	ori	r18,r18,32
81127090:	bdc00044 	addi	r23,r23,1
81127094:	8c403fcc 	andi	r17,r17,255
81127098:	8c40201c 	xori	r17,r17,128
8112709c:	8c7fe004 	addi	r17,r17,-128
811270a0:	003a1a06 	br	8112590c <__reset+0xfb10590c>
811270a4:	d9402c17 	ldw	r5,176(sp)
811270a8:	d9801e04 	addi	r6,sp,120
811270ac:	9809883a 	mov	r4,r19
811270b0:	11320ec0 	call	811320ec <__ssprint_r>
811270b4:	103aa61e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811270b8:	d8c02017 	ldw	r3,128(sp)
811270bc:	da000404 	addi	r8,sp,16
811270c0:	003d4a06 	br	811265ec <__reset+0xfb1065ec>
811270c4:	d9002917 	ldw	r4,164(sp)
811270c8:	05bff7c4 	movi	r22,-33
811270cc:	00bfffc4 	movi	r2,-1
811270d0:	8dac703a 	and	r22,r17,r22
811270d4:	20806a26 	beq	r4,r2,81127280 <___svfprintf_internal_r+0x1acc>
811270d8:	008011c4 	movi	r2,71
811270dc:	b0813726 	beq	r22,r2,811275bc <___svfprintf_internal_r+0x1e08>
811270e0:	d9003717 	ldw	r4,220(sp)
811270e4:	90c04014 	ori	r3,r18,256
811270e8:	d8c02b15 	stw	r3,172(sp)
811270ec:	20015d16 	blt	r4,zero,81127664 <___svfprintf_internal_r+0x1eb0>
811270f0:	dd003717 	ldw	r20,220(sp)
811270f4:	d8002a05 	stb	zero,168(sp)
811270f8:	00801984 	movi	r2,102
811270fc:	88814026 	beq	r17,r2,81127600 <___svfprintf_internal_r+0x1e4c>
81127100:	00801184 	movi	r2,70
81127104:	88817126 	beq	r17,r2,811276cc <___svfprintf_internal_r+0x1f18>
81127108:	00801144 	movi	r2,69
8112710c:	b0816226 	beq	r22,r2,81127698 <___svfprintf_internal_r+0x1ee4>
81127110:	d8c02917 	ldw	r3,164(sp)
81127114:	d8802104 	addi	r2,sp,132
81127118:	d8800315 	stw	r2,12(sp)
8112711c:	d9403617 	ldw	r5,216(sp)
81127120:	d8802504 	addi	r2,sp,148
81127124:	d8800215 	stw	r2,8(sp)
81127128:	d8802604 	addi	r2,sp,152
8112712c:	d8c00015 	stw	r3,0(sp)
81127130:	d8800115 	stw	r2,4(sp)
81127134:	01c00084 	movi	r7,2
81127138:	a00d883a 	mov	r6,r20
8112713c:	9809883a 	mov	r4,r19
81127140:	d8c03d15 	stw	r3,244(sp)
81127144:	da003e15 	stw	r8,248(sp)
81127148:	112baa00 	call	8112baa0 <_dtoa_r>
8112714c:	1021883a 	mov	r16,r2
81127150:	008019c4 	movi	r2,103
81127154:	d8c03d17 	ldw	r3,244(sp)
81127158:	da003e17 	ldw	r8,248(sp)
8112715c:	8880e726 	beq	r17,r2,811274fc <___svfprintf_internal_r+0x1d48>
81127160:	008011c4 	movi	r2,71
81127164:	8880d426 	beq	r17,r2,811274b8 <___svfprintf_internal_r+0x1d04>
81127168:	80f9883a 	add	fp,r16,r3
8112716c:	d9003617 	ldw	r4,216(sp)
81127170:	000d883a 	mov	r6,zero
81127174:	000f883a 	mov	r7,zero
81127178:	a00b883a 	mov	r5,r20
8112717c:	da003e15 	stw	r8,248(sp)
81127180:	11380680 	call	81138068 <__eqdf2>
81127184:	da003e17 	ldw	r8,248(sp)
81127188:	1000e426 	beq	r2,zero,8112751c <___svfprintf_internal_r+0x1d68>
8112718c:	d8802117 	ldw	r2,132(sp)
81127190:	1700062e 	bgeu	r2,fp,811271ac <___svfprintf_internal_r+0x19f8>
81127194:	01000c04 	movi	r4,48
81127198:	10c00044 	addi	r3,r2,1
8112719c:	d8c02115 	stw	r3,132(sp)
811271a0:	11000005 	stb	r4,0(r2)
811271a4:	d8802117 	ldw	r2,132(sp)
811271a8:	173ffb36 	bltu	r2,fp,81127198 <__reset+0xfb107198>
811271ac:	1405c83a 	sub	r2,r2,r16
811271b0:	d8803315 	stw	r2,204(sp)
811271b4:	008011c4 	movi	r2,71
811271b8:	b080c526 	beq	r22,r2,811274d0 <___svfprintf_internal_r+0x1d1c>
811271bc:	00801944 	movi	r2,101
811271c0:	1441d90e 	bge	r2,r17,81127928 <___svfprintf_internal_r+0x2174>
811271c4:	d8c02617 	ldw	r3,152(sp)
811271c8:	00801984 	movi	r2,102
811271cc:	d8c03215 	stw	r3,200(sp)
811271d0:	88813426 	beq	r17,r2,811276a4 <___svfprintf_internal_r+0x1ef0>
811271d4:	d8c03217 	ldw	r3,200(sp)
811271d8:	d9003317 	ldw	r4,204(sp)
811271dc:	19012516 	blt	r3,r4,81127674 <___svfprintf_internal_r+0x1ec0>
811271e0:	9480004c 	andi	r18,r18,1
811271e4:	9001841e 	bne	r18,zero,811277f8 <___svfprintf_internal_r+0x2044>
811271e8:	1805883a 	mov	r2,r3
811271ec:	1801cc16 	blt	r3,zero,81127920 <___svfprintf_internal_r+0x216c>
811271f0:	d8c03217 	ldw	r3,200(sp)
811271f4:	044019c4 	movi	r17,103
811271f8:	d8c02e15 	stw	r3,184(sp)
811271fc:	df002a07 	ldb	fp,168(sp)
81127200:	e000a61e 	bne	fp,zero,8112749c <___svfprintf_internal_r+0x1ce8>
81127204:	df002783 	ldbu	fp,158(sp)
81127208:	d8802a15 	stw	r2,168(sp)
8112720c:	dc802b17 	ldw	r18,172(sp)
81127210:	d8002915 	stw	zero,164(sp)
81127214:	003b1706 	br	81125e74 <__reset+0xfb105e74>
81127218:	04204574 	movhi	r16,33045
8112721c:	840a8404 	addi	r16,r16,10768
81127220:	003aa606 	br	81125cbc <__reset+0xfb105cbc>
81127224:	d9003917 	ldw	r4,228(sp)
81127228:	04001004 	movi	r16,64
8112722c:	800b883a 	mov	r5,r16
81127230:	1123eec0 	call	81123eec <_malloc_r>
81127234:	d9002c17 	ldw	r4,176(sp)
81127238:	20800015 	stw	r2,0(r4)
8112723c:	20800415 	stw	r2,16(r4)
81127240:	1001cb26 	beq	r2,zero,81127970 <___svfprintf_internal_r+0x21bc>
81127244:	d8802c17 	ldw	r2,176(sp)
81127248:	14000515 	stw	r16,20(r2)
8112724c:	00397606 	br	81125828 <__reset+0xfb105828>
81127250:	04204574 	movhi	r16,33045
81127254:	840a8604 	addi	r16,r16,10776
81127258:	003ee106 	br	81126de0 <__reset+0xfb106de0>
8112725c:	d9402c17 	ldw	r5,176(sp)
81127260:	d9801e04 	addi	r6,sp,120
81127264:	9809883a 	mov	r4,r19
81127268:	11320ec0 	call	811320ec <__ssprint_r>
8112726c:	103a381e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81127270:	dc402617 	ldw	r17,152(sp)
81127274:	d8c02017 	ldw	r3,128(sp)
81127278:	da000404 	addi	r8,sp,16
8112727c:	003f4306 	br	81126f8c <__reset+0xfb106f8c>
81127280:	01400184 	movi	r5,6
81127284:	d9402915 	stw	r5,164(sp)
81127288:	003f9506 	br	811270e0 <__reset+0xfb1070e0>
8112728c:	d9002d17 	ldw	r4,180(sp)
81127290:	25000017 	ldw	r20,0(r4)
81127294:	21000104 	addi	r4,r4,4
81127298:	d9002d15 	stw	r4,180(sp)
8112729c:	a02dd7fa 	srai	r22,r20,31
811272a0:	b005883a 	mov	r2,r22
811272a4:	003a9b06 	br	81125d14 <__reset+0xfb105d14>
811272a8:	d9402d17 	ldw	r5,180(sp)
811272ac:	002d883a 	mov	r22,zero
811272b0:	2d000017 	ldw	r20,0(r5)
811272b4:	29400104 	addi	r5,r5,4
811272b8:	d9402d15 	stw	r5,180(sp)
811272bc:	003bf906 	br	811262a4 <__reset+0xfb1062a4>
811272c0:	9480100c 	andi	r18,r18,64
811272c4:	90006e26 	beq	r18,zero,81127480 <___svfprintf_internal_r+0x1ccc>
811272c8:	d9002d17 	ldw	r4,180(sp)
811272cc:	d9402f17 	ldw	r5,188(sp)
811272d0:	20800017 	ldw	r2,0(r4)
811272d4:	21000104 	addi	r4,r4,4
811272d8:	d9002d15 	stw	r4,180(sp)
811272dc:	1140000d 	sth	r5,0(r2)
811272e0:	00396106 	br	81125868 <__reset+0xfb105868>
811272e4:	d9402c17 	ldw	r5,176(sp)
811272e8:	d9801e04 	addi	r6,sp,120
811272ec:	9809883a 	mov	r4,r19
811272f0:	11320ec0 	call	811320ec <__ssprint_r>
811272f4:	103a161e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811272f8:	d8c02017 	ldw	r3,128(sp)
811272fc:	d8801f17 	ldw	r2,124(sp)
81127300:	da000404 	addi	r8,sp,16
81127304:	d9403317 	ldw	r5,204(sp)
81127308:	10800044 	addi	r2,r2,1
8112730c:	44000015 	stw	r16,0(r8)
81127310:	28c7883a 	add	r3,r5,r3
81127314:	003b7706 	br	811260f4 <__reset+0xfb1060f4>
81127318:	8009883a 	mov	r4,r16
8112731c:	da003e15 	stw	r8,248(sp)
81127320:	11251780 	call	81125178 <strlen>
81127324:	d8802e15 	stw	r2,184(sp)
81127328:	da003e17 	ldw	r8,248(sp)
8112732c:	103c280e 	bge	r2,zero,811263d0 <__reset+0xfb1063d0>
81127330:	0005883a 	mov	r2,zero
81127334:	003c2606 	br	811263d0 <__reset+0xfb1063d0>
81127338:	00bfffc4 	movi	r2,-1
8112733c:	003a0906 	br	81125b64 <__reset+0xfb105b64>
81127340:	01204574 	movhi	r4,33045
81127344:	210a9884 	addi	r4,r4,10850
81127348:	d9003515 	stw	r4,212(sp)
8112734c:	003b0606 	br	81125f68 <__reset+0xfb105f68>
81127350:	013fffc4 	movi	r4,-1
81127354:	003a2706 	br	81125bf4 <__reset+0xfb105bf4>
81127358:	d9402c17 	ldw	r5,176(sp)
8112735c:	d9801e04 	addi	r6,sp,120
81127360:	9809883a 	mov	r4,r19
81127364:	11320ec0 	call	811320ec <__ssprint_r>
81127368:	1039f91e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
8112736c:	d8c02017 	ldw	r3,128(sp)
81127370:	da000404 	addi	r8,sp,16
81127374:	003d8406 	br	81126988 <__reset+0xfb106988>
81127378:	0023883a 	mov	r17,zero
8112737c:	003d8306 	br	8112698c <__reset+0xfb10698c>
81127380:	01204574 	movhi	r4,33045
81127384:	210a9484 	addi	r4,r4,10834
81127388:	d9002b15 	stw	r4,172(sp)
8112738c:	d9002b17 	ldw	r4,172(sp)
81127390:	1c47883a 	add	r3,r3,r17
81127394:	10800044 	addi	r2,r2,1
81127398:	41000015 	stw	r4,0(r8)
8112739c:	44400115 	stw	r17,4(r8)
811273a0:	d8c02015 	stw	r3,128(sp)
811273a4:	d8801f15 	stw	r2,124(sp)
811273a8:	010001c4 	movi	r4,7
811273ac:	20bfcd16 	blt	r4,r2,811272e4 <__reset+0xfb1072e4>
811273b0:	42000204 	addi	r8,r8,8
811273b4:	003fd306 	br	81127304 <__reset+0xfb107304>
811273b8:	d9402c17 	ldw	r5,176(sp)
811273bc:	d9801e04 	addi	r6,sp,120
811273c0:	9809883a 	mov	r4,r19
811273c4:	11320ec0 	call	811320ec <__ssprint_r>
811273c8:	1039e11e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811273cc:	d8802617 	ldw	r2,152(sp)
811273d0:	d8c02017 	ldw	r3,128(sp)
811273d4:	da000404 	addi	r8,sp,16
811273d8:	003e1c06 	br	81126c4c <__reset+0xfb106c4c>
811273dc:	d8802917 	ldw	r2,164(sp)
811273e0:	00c00184 	movi	r3,6
811273e4:	1880012e 	bgeu	r3,r2,811273ec <___svfprintf_internal_r+0x1c38>
811273e8:	1805883a 	mov	r2,r3
811273ec:	d8802e15 	stw	r2,184(sp)
811273f0:	1000f316 	blt	r2,zero,811277c0 <___svfprintf_internal_r+0x200c>
811273f4:	04204574 	movhi	r16,33045
811273f8:	d8802a15 	stw	r2,168(sp)
811273fc:	dd002d15 	stw	r20,180(sp)
81127400:	d8002915 	stw	zero,164(sp)
81127404:	d8003215 	stw	zero,200(sp)
81127408:	840a9204 	addi	r16,r16,10824
8112740c:	0039883a 	mov	fp,zero
81127410:	003a9f06 	br	81125e90 <__reset+0xfb105e90>
81127414:	01204574 	movhi	r4,33045
81127418:	210a9884 	addi	r4,r4,10850
8112741c:	d9003515 	stw	r4,212(sp)
81127420:	003b5f06 	br	811261a0 <__reset+0xfb1061a0>
81127424:	d9402c17 	ldw	r5,176(sp)
81127428:	d9801e04 	addi	r6,sp,120
8112742c:	9809883a 	mov	r4,r19
81127430:	11320ec0 	call	811320ec <__ssprint_r>
81127434:	1039c61e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
81127438:	d8802617 	ldw	r2,152(sp)
8112743c:	d9403317 	ldw	r5,204(sp)
81127440:	d8c02017 	ldw	r3,128(sp)
81127444:	da000404 	addi	r8,sp,16
81127448:	2885c83a 	sub	r2,r5,r2
8112744c:	003e1006 	br	81126c90 <__reset+0xfb106c90>
81127450:	00800044 	movi	r2,1
81127454:	10803fcc 	andi	r2,r2,255
81127458:	00c00044 	movi	r3,1
8112745c:	10fa3526 	beq	r2,r3,81125d34 <__reset+0xfb105d34>
81127460:	00c00084 	movi	r3,2
81127464:	10fb9e26 	beq	r2,r3,811262e0 <__reset+0xfb1062e0>
81127468:	003a6406 	br	81125dfc <__reset+0xfb105dfc>
8112746c:	0021883a 	mov	r16,zero
81127470:	003e0806 	br	81126c94 <__reset+0xfb106c94>
81127474:	07000b44 	movi	fp,45
81127478:	df002785 	stb	fp,158(sp)
8112747c:	003a0b06 	br	81125cac <__reset+0xfb105cac>
81127480:	d8c02d17 	ldw	r3,180(sp)
81127484:	d9002f17 	ldw	r4,188(sp)
81127488:	18800017 	ldw	r2,0(r3)
8112748c:	18c00104 	addi	r3,r3,4
81127490:	d8c02d15 	stw	r3,180(sp)
81127494:	11000015 	stw	r4,0(r2)
81127498:	0038f306 	br	81125868 <__reset+0xfb105868>
8112749c:	00c00b44 	movi	r3,45
811274a0:	d8c02785 	stb	r3,158(sp)
811274a4:	d8802a15 	stw	r2,168(sp)
811274a8:	dc802b17 	ldw	r18,172(sp)
811274ac:	d8002915 	stw	zero,164(sp)
811274b0:	07000b44 	movi	fp,45
811274b4:	003a7306 	br	81125e84 <__reset+0xfb105e84>
811274b8:	9080004c 	andi	r2,r18,1
811274bc:	1000941e 	bne	r2,zero,81127710 <___svfprintf_internal_r+0x1f5c>
811274c0:	d8802117 	ldw	r2,132(sp)
811274c4:	1405c83a 	sub	r2,r2,r16
811274c8:	d8803315 	stw	r2,204(sp)
811274cc:	b441161e 	bne	r22,r17,81127928 <___svfprintf_internal_r+0x2174>
811274d0:	dd802617 	ldw	r22,152(sp)
811274d4:	00bfff44 	movi	r2,-3
811274d8:	b0801a16 	blt	r22,r2,81127544 <___svfprintf_internal_r+0x1d90>
811274dc:	d9402917 	ldw	r5,164(sp)
811274e0:	2d801816 	blt	r5,r22,81127544 <___svfprintf_internal_r+0x1d90>
811274e4:	dd803215 	stw	r22,200(sp)
811274e8:	003f3a06 	br	811271d4 <__reset+0xfb1071d4>
811274ec:	1025883a 	mov	r18,r2
811274f0:	0039883a 	mov	fp,zero
811274f4:	00800084 	movi	r2,2
811274f8:	003fd606 	br	81127454 <__reset+0xfb107454>
811274fc:	9080004c 	andi	r2,r18,1
81127500:	103f191e 	bne	r2,zero,81127168 <__reset+0xfb107168>
81127504:	d8802117 	ldw	r2,132(sp)
81127508:	003f2806 	br	811271ac <__reset+0xfb1071ac>
8112750c:	01204574 	movhi	r4,33045
81127510:	210a9484 	addi	r4,r4,10834
81127514:	d9002b15 	stw	r4,172(sp)
81127518:	003c7c06 	br	8112670c <__reset+0xfb10670c>
8112751c:	e005883a 	mov	r2,fp
81127520:	003f2206 	br	811271ac <__reset+0xfb1071ac>
81127524:	d9402917 	ldw	r5,164(sp)
81127528:	df002783 	ldbu	fp,158(sp)
8112752c:	dd002d15 	stw	r20,180(sp)
81127530:	d9402a15 	stw	r5,168(sp)
81127534:	d9402e15 	stw	r5,184(sp)
81127538:	d8002915 	stw	zero,164(sp)
8112753c:	d8003215 	stw	zero,200(sp)
81127540:	003a4c06 	br	81125e74 <__reset+0xfb105e74>
81127544:	8c7fff84 	addi	r17,r17,-2
81127548:	b5bfffc4 	addi	r22,r22,-1
8112754c:	dd802615 	stw	r22,152(sp)
81127550:	dc4022c5 	stb	r17,139(sp)
81127554:	b000c316 	blt	r22,zero,81127864 <___svfprintf_internal_r+0x20b0>
81127558:	00800ac4 	movi	r2,43
8112755c:	d8802305 	stb	r2,140(sp)
81127560:	00800244 	movi	r2,9
81127564:	15806e16 	blt	r2,r22,81127720 <___svfprintf_internal_r+0x1f6c>
81127568:	00800c04 	movi	r2,48
8112756c:	b5800c04 	addi	r22,r22,48
81127570:	d8802345 	stb	r2,141(sp)
81127574:	dd802385 	stb	r22,142(sp)
81127578:	d88023c4 	addi	r2,sp,143
8112757c:	df0022c4 	addi	fp,sp,139
81127580:	d8c03317 	ldw	r3,204(sp)
81127584:	1739c83a 	sub	fp,r2,fp
81127588:	d9003317 	ldw	r4,204(sp)
8112758c:	e0c7883a 	add	r3,fp,r3
81127590:	df003b15 	stw	fp,236(sp)
81127594:	d8c02e15 	stw	r3,184(sp)
81127598:	00800044 	movi	r2,1
8112759c:	1100b70e 	bge	r2,r4,8112787c <___svfprintf_internal_r+0x20c8>
811275a0:	d8c02e17 	ldw	r3,184(sp)
811275a4:	18c00044 	addi	r3,r3,1
811275a8:	d8c02e15 	stw	r3,184(sp)
811275ac:	1805883a 	mov	r2,r3
811275b0:	1800b016 	blt	r3,zero,81127874 <___svfprintf_internal_r+0x20c0>
811275b4:	d8003215 	stw	zero,200(sp)
811275b8:	003f1006 	br	811271fc <__reset+0xfb1071fc>
811275bc:	d8802917 	ldw	r2,164(sp)
811275c0:	103ec71e 	bne	r2,zero,811270e0 <__reset+0xfb1070e0>
811275c4:	dc002915 	stw	r16,164(sp)
811275c8:	003ec506 	br	811270e0 <__reset+0xfb1070e0>
811275cc:	d9402c17 	ldw	r5,176(sp)
811275d0:	d9801e04 	addi	r6,sp,120
811275d4:	9809883a 	mov	r4,r19
811275d8:	11320ec0 	call	811320ec <__ssprint_r>
811275dc:	10395c1e 	bne	r2,zero,81125b50 <__reset+0xfb105b50>
811275e0:	dc402617 	ldw	r17,152(sp)
811275e4:	d8c02017 	ldw	r3,128(sp)
811275e8:	d8801f17 	ldw	r2,124(sp)
811275ec:	da000404 	addi	r8,sp,16
811275f0:	003e7706 	br	81126fd0 <__reset+0xfb106fd0>
811275f4:	582f883a 	mov	r23,r11
811275f8:	d8002915 	stw	zero,164(sp)
811275fc:	0038c406 	br	81125910 <__reset+0xfb105910>
81127600:	d8c02917 	ldw	r3,164(sp)
81127604:	d8802104 	addi	r2,sp,132
81127608:	d8800315 	stw	r2,12(sp)
8112760c:	d9403617 	ldw	r5,216(sp)
81127610:	d8802504 	addi	r2,sp,148
81127614:	d8800215 	stw	r2,8(sp)
81127618:	d8802604 	addi	r2,sp,152
8112761c:	d8c00015 	stw	r3,0(sp)
81127620:	9809883a 	mov	r4,r19
81127624:	d8800115 	stw	r2,4(sp)
81127628:	01c000c4 	movi	r7,3
8112762c:	a00d883a 	mov	r6,r20
81127630:	da003e15 	stw	r8,248(sp)
81127634:	112baa00 	call	8112baa0 <_dtoa_r>
81127638:	d9002917 	ldw	r4,164(sp)
8112763c:	da003e17 	ldw	r8,248(sp)
81127640:	1021883a 	mov	r16,r2
81127644:	1139883a 	add	fp,r2,r4
81127648:	2007883a 	mov	r3,r4
8112764c:	81000007 	ldb	r4,0(r16)
81127650:	00800c04 	movi	r2,48
81127654:	20806f26 	beq	r4,r2,81127814 <___svfprintf_internal_r+0x2060>
81127658:	d8c02617 	ldw	r3,152(sp)
8112765c:	e0f9883a 	add	fp,fp,r3
81127660:	003ec206 	br	8112716c <__reset+0xfb10716c>
81127664:	00c00b44 	movi	r3,45
81127668:	2520003c 	xorhi	r20,r4,32768
8112766c:	d8c02a05 	stb	r3,168(sp)
81127670:	003ea106 	br	811270f8 <__reset+0xfb1070f8>
81127674:	d8c03217 	ldw	r3,200(sp)
81127678:	00c0890e 	bge	zero,r3,811278a0 <___svfprintf_internal_r+0x20ec>
8112767c:	00800044 	movi	r2,1
81127680:	d9003317 	ldw	r4,204(sp)
81127684:	1105883a 	add	r2,r2,r4
81127688:	d8802e15 	stw	r2,184(sp)
8112768c:	10005f16 	blt	r2,zero,8112780c <___svfprintf_internal_r+0x2058>
81127690:	044019c4 	movi	r17,103
81127694:	003ed906 	br	811271fc <__reset+0xfb1071fc>
81127698:	d9002917 	ldw	r4,164(sp)
8112769c:	20c00044 	addi	r3,r4,1
811276a0:	003e9c06 	br	81127114 <__reset+0xfb107114>
811276a4:	d9002917 	ldw	r4,164(sp)
811276a8:	00c0680e 	bge	zero,r3,8112784c <___svfprintf_internal_r+0x2098>
811276ac:	2000461e 	bne	r4,zero,811277c8 <___svfprintf_internal_r+0x2014>
811276b0:	9480004c 	andi	r18,r18,1
811276b4:	9000441e 	bne	r18,zero,811277c8 <___svfprintf_internal_r+0x2014>
811276b8:	1805883a 	mov	r2,r3
811276bc:	1800a016 	blt	r3,zero,81127940 <___svfprintf_internal_r+0x218c>
811276c0:	d8c03217 	ldw	r3,200(sp)
811276c4:	d8c02e15 	stw	r3,184(sp)
811276c8:	003ecc06 	br	811271fc <__reset+0xfb1071fc>
811276cc:	d9402917 	ldw	r5,164(sp)
811276d0:	d8802104 	addi	r2,sp,132
811276d4:	d8800315 	stw	r2,12(sp)
811276d8:	d9400015 	stw	r5,0(sp)
811276dc:	d8802504 	addi	r2,sp,148
811276e0:	d9403617 	ldw	r5,216(sp)
811276e4:	d8800215 	stw	r2,8(sp)
811276e8:	d8802604 	addi	r2,sp,152
811276ec:	d8800115 	stw	r2,4(sp)
811276f0:	01c000c4 	movi	r7,3
811276f4:	a00d883a 	mov	r6,r20
811276f8:	9809883a 	mov	r4,r19
811276fc:	da003e15 	stw	r8,248(sp)
81127700:	112baa00 	call	8112baa0 <_dtoa_r>
81127704:	d8c02917 	ldw	r3,164(sp)
81127708:	da003e17 	ldw	r8,248(sp)
8112770c:	1021883a 	mov	r16,r2
81127710:	00801184 	movi	r2,70
81127714:	80f9883a 	add	fp,r16,r3
81127718:	88bfcc26 	beq	r17,r2,8112764c <__reset+0xfb10764c>
8112771c:	003e9306 	br	8112716c <__reset+0xfb10716c>
81127720:	df0022c4 	addi	fp,sp,139
81127724:	dc002915 	stw	r16,164(sp)
81127728:	9829883a 	mov	r20,r19
8112772c:	e021883a 	mov	r16,fp
81127730:	4027883a 	mov	r19,r8
81127734:	b009883a 	mov	r4,r22
81127738:	01400284 	movi	r5,10
8112773c:	1136b980 	call	81136b98 <__modsi3>
81127740:	10800c04 	addi	r2,r2,48
81127744:	843fffc4 	addi	r16,r16,-1
81127748:	b009883a 	mov	r4,r22
8112774c:	01400284 	movi	r5,10
81127750:	80800005 	stb	r2,0(r16)
81127754:	1136b140 	call	81136b14 <__divsi3>
81127758:	102d883a 	mov	r22,r2
8112775c:	00800244 	movi	r2,9
81127760:	15bff416 	blt	r2,r22,81127734 <__reset+0xfb107734>
81127764:	9811883a 	mov	r8,r19
81127768:	b0800c04 	addi	r2,r22,48
8112776c:	a027883a 	mov	r19,r20
81127770:	8029883a 	mov	r20,r16
81127774:	a17fffc4 	addi	r5,r20,-1
81127778:	a0bfffc5 	stb	r2,-1(r20)
8112777c:	dc002917 	ldw	r16,164(sp)
81127780:	2f00752e 	bgeu	r5,fp,81127958 <___svfprintf_internal_r+0x21a4>
81127784:	d9c02384 	addi	r7,sp,142
81127788:	3d0fc83a 	sub	r7,r7,r20
8112778c:	d9002344 	addi	r4,sp,141
81127790:	e1cf883a 	add	r7,fp,r7
81127794:	00000106 	br	8112779c <___svfprintf_internal_r+0x1fe8>
81127798:	28800003 	ldbu	r2,0(r5)
8112779c:	20800005 	stb	r2,0(r4)
811277a0:	21000044 	addi	r4,r4,1
811277a4:	29400044 	addi	r5,r5,1
811277a8:	21fffb1e 	bne	r4,r7,81127798 <__reset+0xfb107798>
811277ac:	d8802304 	addi	r2,sp,140
811277b0:	1505c83a 	sub	r2,r2,r20
811277b4:	d8c02344 	addi	r3,sp,141
811277b8:	1885883a 	add	r2,r3,r2
811277bc:	003f7006 	br	81127580 <__reset+0xfb107580>
811277c0:	0005883a 	mov	r2,zero
811277c4:	003f0b06 	br	811273f4 <__reset+0xfb1073f4>
811277c8:	d9002917 	ldw	r4,164(sp)
811277cc:	d8c03217 	ldw	r3,200(sp)
811277d0:	20800044 	addi	r2,r4,1
811277d4:	1885883a 	add	r2,r3,r2
811277d8:	d8802e15 	stw	r2,184(sp)
811277dc:	103e870e 	bge	r2,zero,811271fc <__reset+0xfb1071fc>
811277e0:	0005883a 	mov	r2,zero
811277e4:	003e8506 	br	811271fc <__reset+0xfb1071fc>
811277e8:	01204574 	movhi	r4,33045
811277ec:	210a9484 	addi	r4,r4,10834
811277f0:	d9002b15 	stw	r4,172(sp)
811277f4:	003cc506 	br	81126b0c <__reset+0xfb106b0c>
811277f8:	d8c03217 	ldw	r3,200(sp)
811277fc:	18c00044 	addi	r3,r3,1
81127800:	d8c02e15 	stw	r3,184(sp)
81127804:	1805883a 	mov	r2,r3
81127808:	183fa10e 	bge	r3,zero,81127690 <__reset+0xfb107690>
8112780c:	0005883a 	mov	r2,zero
81127810:	003f9f06 	br	81127690 <__reset+0xfb107690>
81127814:	d9003617 	ldw	r4,216(sp)
81127818:	000d883a 	mov	r6,zero
8112781c:	000f883a 	mov	r7,zero
81127820:	a00b883a 	mov	r5,r20
81127824:	d8c03d15 	stw	r3,244(sp)
81127828:	da003e15 	stw	r8,248(sp)
8112782c:	11380680 	call	81138068 <__eqdf2>
81127830:	d8c03d17 	ldw	r3,244(sp)
81127834:	da003e17 	ldw	r8,248(sp)
81127838:	103f8726 	beq	r2,zero,81127658 <__reset+0xfb107658>
8112783c:	00800044 	movi	r2,1
81127840:	10c7c83a 	sub	r3,r2,r3
81127844:	d8c02615 	stw	r3,152(sp)
81127848:	003f8406 	br	8112765c <__reset+0xfb10765c>
8112784c:	20000e1e 	bne	r4,zero,81127888 <___svfprintf_internal_r+0x20d4>
81127850:	9480004c 	andi	r18,r18,1
81127854:	90000c1e 	bne	r18,zero,81127888 <___svfprintf_internal_r+0x20d4>
81127858:	00800044 	movi	r2,1
8112785c:	d8802e15 	stw	r2,184(sp)
81127860:	003e6606 	br	811271fc <__reset+0xfb1071fc>
81127864:	00800b44 	movi	r2,45
81127868:	05adc83a 	sub	r22,zero,r22
8112786c:	d8802305 	stb	r2,140(sp)
81127870:	003f3b06 	br	81127560 <__reset+0xfb107560>
81127874:	0005883a 	mov	r2,zero
81127878:	003f4e06 	br	811275b4 <__reset+0xfb1075b4>
8112787c:	90a4703a 	and	r18,r18,r2
81127880:	903f4a26 	beq	r18,zero,811275ac <__reset+0xfb1075ac>
81127884:	003f4606 	br	811275a0 <__reset+0xfb1075a0>
81127888:	d8c02917 	ldw	r3,164(sp)
8112788c:	18c00084 	addi	r3,r3,2
81127890:	d8c02e15 	stw	r3,184(sp)
81127894:	1805883a 	mov	r2,r3
81127898:	183e580e 	bge	r3,zero,811271fc <__reset+0xfb1071fc>
8112789c:	003fd006 	br	811277e0 <__reset+0xfb1077e0>
811278a0:	00800084 	movi	r2,2
811278a4:	10c5c83a 	sub	r2,r2,r3
811278a8:	003f7506 	br	81127680 <__reset+0xfb107680>
811278ac:	d8802d17 	ldw	r2,180(sp)
811278b0:	d9002d17 	ldw	r4,180(sp)
811278b4:	bc400043 	ldbu	r17,1(r23)
811278b8:	10800017 	ldw	r2,0(r2)
811278bc:	582f883a 	mov	r23,r11
811278c0:	d8802915 	stw	r2,164(sp)
811278c4:	20800104 	addi	r2,r4,4
811278c8:	d9002917 	ldw	r4,164(sp)
811278cc:	d8802d15 	stw	r2,180(sp)
811278d0:	203df00e 	bge	r4,zero,81127094 <__reset+0xfb107094>
811278d4:	8c403fcc 	andi	r17,r17,255
811278d8:	00bfffc4 	movi	r2,-1
811278dc:	8c40201c 	xori	r17,r17,128
811278e0:	d8802915 	stw	r2,164(sp)
811278e4:	8c7fe004 	addi	r17,r17,-128
811278e8:	00380806 	br	8112590c <__reset+0xfb10590c>
811278ec:	9080004c 	andi	r2,r18,1
811278f0:	0039883a 	mov	fp,zero
811278f4:	10000726 	beq	r2,zero,81127914 <___svfprintf_internal_r+0x2160>
811278f8:	d8c02817 	ldw	r3,160(sp)
811278fc:	dc001dc4 	addi	r16,sp,119
81127900:	00800c04 	movi	r2,48
81127904:	1c07c83a 	sub	r3,r3,r16
81127908:	d8801dc5 	stb	r2,119(sp)
8112790c:	d8c02e15 	stw	r3,184(sp)
81127910:	00395206 	br	81125e5c <__reset+0xfb105e5c>
81127914:	d8002e15 	stw	zero,184(sp)
81127918:	dc001e04 	addi	r16,sp,120
8112791c:	00394f06 	br	81125e5c <__reset+0xfb105e5c>
81127920:	0005883a 	mov	r2,zero
81127924:	003e3206 	br	811271f0 <__reset+0xfb1071f0>
81127928:	dd802617 	ldw	r22,152(sp)
8112792c:	003f0606 	br	81127548 <__reset+0xfb107548>
81127930:	d9c02785 	stb	r7,158(sp)
81127934:	003a5106 	br	8112627c <__reset+0xfb10627c>
81127938:	d9c02785 	stb	r7,158(sp)
8112793c:	003a3706 	br	8112621c <__reset+0xfb10621c>
81127940:	0005883a 	mov	r2,zero
81127944:	003f5e06 	br	811276c0 <__reset+0xfb1076c0>
81127948:	d9c02785 	stb	r7,158(sp)
8112794c:	00391706 	br	81125dac <__reset+0xfb105dac>
81127950:	d9c02785 	stb	r7,158(sp)
81127954:	0038e606 	br	81125cf0 <__reset+0xfb105cf0>
81127958:	d8802344 	addi	r2,sp,141
8112795c:	003f0806 	br	81127580 <__reset+0xfb107580>
81127960:	d9c02785 	stb	r7,158(sp)
81127964:	0038b706 	br	81125c44 <__reset+0xfb105c44>
81127968:	d9c02785 	stb	r7,158(sp)
8112796c:	003adc06 	br	811264e0 <__reset+0xfb1064e0>
81127970:	d9403917 	ldw	r5,228(sp)
81127974:	00800304 	movi	r2,12
81127978:	28800015 	stw	r2,0(r5)
8112797c:	00bfffc4 	movi	r2,-1
81127980:	00387806 	br	81125b64 <__reset+0xfb105b64>
81127984:	d9c02785 	stb	r7,158(sp)
81127988:	003abf06 	br	81126488 <__reset+0xfb106488>
8112798c:	d9c02785 	stb	r7,158(sp)
81127990:	003a9b06 	br	81126400 <__reset+0xfb106400>

81127994 <___vfprintf_internal_r>:
81127994:	deffb804 	addi	sp,sp,-288
81127998:	de00012e 	bgeu	sp,et,811279a0 <___vfprintf_internal_r+0xc>
8112799c:	003b68fa 	trap	3
811279a0:	dfc04715 	stw	ra,284(sp)
811279a4:	ddc04515 	stw	r23,276(sp)
811279a8:	dd404315 	stw	r21,268(sp)
811279ac:	d9002c15 	stw	r4,176(sp)
811279b0:	282f883a 	mov	r23,r5
811279b4:	302b883a 	mov	r21,r6
811279b8:	d9c02d15 	stw	r7,180(sp)
811279bc:	df004615 	stw	fp,280(sp)
811279c0:	dd804415 	stw	r22,272(sp)
811279c4:	dd004215 	stw	r20,264(sp)
811279c8:	dcc04115 	stw	r19,260(sp)
811279cc:	dc804015 	stw	r18,256(sp)
811279d0:	dc403f15 	stw	r17,252(sp)
811279d4:	dc003e15 	stw	r16,248(sp)
811279d8:	112e69c0 	call	8112e69c <_localeconv_r>
811279dc:	10800017 	ldw	r2,0(r2)
811279e0:	1009883a 	mov	r4,r2
811279e4:	d8803415 	stw	r2,208(sp)
811279e8:	11251780 	call	81125178 <strlen>
811279ec:	d8803715 	stw	r2,220(sp)
811279f0:	d8802c17 	ldw	r2,176(sp)
811279f4:	10000226 	beq	r2,zero,81127a00 <___vfprintf_internal_r+0x6c>
811279f8:	10800e17 	ldw	r2,56(r2)
811279fc:	1000f926 	beq	r2,zero,81127de4 <___vfprintf_internal_r+0x450>
81127a00:	b880030b 	ldhu	r2,12(r23)
81127a04:	10c8000c 	andi	r3,r2,8192
81127a08:	1800061e 	bne	r3,zero,81127a24 <___vfprintf_internal_r+0x90>
81127a0c:	b9001917 	ldw	r4,100(r23)
81127a10:	00f7ffc4 	movi	r3,-8193
81127a14:	10880014 	ori	r2,r2,8192
81127a18:	20c6703a 	and	r3,r4,r3
81127a1c:	b880030d 	sth	r2,12(r23)
81127a20:	b8c01915 	stw	r3,100(r23)
81127a24:	10c0020c 	andi	r3,r2,8
81127a28:	1800c126 	beq	r3,zero,81127d30 <___vfprintf_internal_r+0x39c>
81127a2c:	b8c00417 	ldw	r3,16(r23)
81127a30:	1800bf26 	beq	r3,zero,81127d30 <___vfprintf_internal_r+0x39c>
81127a34:	1080068c 	andi	r2,r2,26
81127a38:	00c00284 	movi	r3,10
81127a3c:	10c0c426 	beq	r2,r3,81127d50 <___vfprintf_internal_r+0x3bc>
81127a40:	d8c00404 	addi	r3,sp,16
81127a44:	05204574 	movhi	r20,33045
81127a48:	d9001e04 	addi	r4,sp,120
81127a4c:	a50a9c84 	addi	r20,r20,10866
81127a50:	d8c01e15 	stw	r3,120(sp)
81127a54:	d8002015 	stw	zero,128(sp)
81127a58:	d8001f15 	stw	zero,124(sp)
81127a5c:	d8003315 	stw	zero,204(sp)
81127a60:	d8003615 	stw	zero,216(sp)
81127a64:	d8003815 	stw	zero,224(sp)
81127a68:	1811883a 	mov	r8,r3
81127a6c:	d8003915 	stw	zero,228(sp)
81127a70:	d8003a15 	stw	zero,232(sp)
81127a74:	d8002f15 	stw	zero,188(sp)
81127a78:	d9002815 	stw	r4,160(sp)
81127a7c:	a8800007 	ldb	r2,0(r21)
81127a80:	10027b26 	beq	r2,zero,81128470 <___vfprintf_internal_r+0xadc>
81127a84:	00c00944 	movi	r3,37
81127a88:	a821883a 	mov	r16,r21
81127a8c:	10c0021e 	bne	r2,r3,81127a98 <___vfprintf_internal_r+0x104>
81127a90:	00001406 	br	81127ae4 <___vfprintf_internal_r+0x150>
81127a94:	10c00326 	beq	r2,r3,81127aa4 <___vfprintf_internal_r+0x110>
81127a98:	84000044 	addi	r16,r16,1
81127a9c:	80800007 	ldb	r2,0(r16)
81127aa0:	103ffc1e 	bne	r2,zero,81127a94 <__reset+0xfb107a94>
81127aa4:	8563c83a 	sub	r17,r16,r21
81127aa8:	88000e26 	beq	r17,zero,81127ae4 <___vfprintf_internal_r+0x150>
81127aac:	d8c02017 	ldw	r3,128(sp)
81127ab0:	d8801f17 	ldw	r2,124(sp)
81127ab4:	45400015 	stw	r21,0(r8)
81127ab8:	1c47883a 	add	r3,r3,r17
81127abc:	10800044 	addi	r2,r2,1
81127ac0:	d8c02015 	stw	r3,128(sp)
81127ac4:	44400115 	stw	r17,4(r8)
81127ac8:	d8801f15 	stw	r2,124(sp)
81127acc:	00c001c4 	movi	r3,7
81127ad0:	1880a716 	blt	r3,r2,81127d70 <___vfprintf_internal_r+0x3dc>
81127ad4:	42000204 	addi	r8,r8,8
81127ad8:	d9402f17 	ldw	r5,188(sp)
81127adc:	2c4b883a 	add	r5,r5,r17
81127ae0:	d9402f15 	stw	r5,188(sp)
81127ae4:	80800007 	ldb	r2,0(r16)
81127ae8:	1000a826 	beq	r2,zero,81127d8c <___vfprintf_internal_r+0x3f8>
81127aec:	84400047 	ldb	r17,1(r16)
81127af0:	00bfffc4 	movi	r2,-1
81127af4:	85400044 	addi	r21,r16,1
81127af8:	d8002785 	stb	zero,158(sp)
81127afc:	0007883a 	mov	r3,zero
81127b00:	000f883a 	mov	r7,zero
81127b04:	d8802915 	stw	r2,164(sp)
81127b08:	d8003115 	stw	zero,196(sp)
81127b0c:	0025883a 	mov	r18,zero
81127b10:	01401604 	movi	r5,88
81127b14:	01800244 	movi	r6,9
81127b18:	02800a84 	movi	r10,42
81127b1c:	02401b04 	movi	r9,108
81127b20:	ad400044 	addi	r21,r21,1
81127b24:	88bff804 	addi	r2,r17,-32
81127b28:	28830436 	bltu	r5,r2,8112873c <___vfprintf_internal_r+0xda8>
81127b2c:	100490ba 	slli	r2,r2,2
81127b30:	012044b4 	movhi	r4,33042
81127b34:	211ed104 	addi	r4,r4,31556
81127b38:	1105883a 	add	r2,r2,r4
81127b3c:	10800017 	ldw	r2,0(r2)
81127b40:	1000683a 	jmp	r2
81127b44:	8112865c 	xori	r4,r16,18969
81127b48:	8112873c 	xorhi	r4,r16,18972
81127b4c:	8112873c 	xorhi	r4,r16,18972
81127b50:	8112867c 	xorhi	r4,r16,18969
81127b54:	8112873c 	xorhi	r4,r16,18972
81127b58:	8112873c 	xorhi	r4,r16,18972
81127b5c:	8112873c 	xorhi	r4,r16,18972
81127b60:	8112873c 	xorhi	r4,r16,18972
81127b64:	8112873c 	xorhi	r4,r16,18972
81127b68:	8112873c 	xorhi	r4,r16,18972
81127b6c:	81127df0 	cmpltui	r4,r16,18935
81127b70:	81128598 	cmpnei	r4,r16,18966
81127b74:	8112873c 	xorhi	r4,r16,18972
81127b78:	81127cb8 	rdprs	r4,r16,18930
81127b7c:	81127e18 	cmpnei	r4,r16,18936
81127b80:	8112873c 	xorhi	r4,r16,18972
81127b84:	81127e58 	cmpnei	r4,r16,18937
81127b88:	81127e64 	muli	r4,r16,18937
81127b8c:	81127e64 	muli	r4,r16,18937
81127b90:	81127e64 	muli	r4,r16,18937
81127b94:	81127e64 	muli	r4,r16,18937
81127b98:	81127e64 	muli	r4,r16,18937
81127b9c:	81127e64 	muli	r4,r16,18937
81127ba0:	81127e64 	muli	r4,r16,18937
81127ba4:	81127e64 	muli	r4,r16,18937
81127ba8:	81127e64 	muli	r4,r16,18937
81127bac:	8112873c 	xorhi	r4,r16,18972
81127bb0:	8112873c 	xorhi	r4,r16,18972
81127bb4:	8112873c 	xorhi	r4,r16,18972
81127bb8:	8112873c 	xorhi	r4,r16,18972
81127bbc:	8112873c 	xorhi	r4,r16,18972
81127bc0:	8112873c 	xorhi	r4,r16,18972
81127bc4:	8112873c 	xorhi	r4,r16,18972
81127bc8:	8112873c 	xorhi	r4,r16,18972
81127bcc:	8112873c 	xorhi	r4,r16,18972
81127bd0:	8112873c 	xorhi	r4,r16,18972
81127bd4:	81127e98 	cmpnei	r4,r16,18938
81127bd8:	81127f54 	ori	r4,r16,18941
81127bdc:	8112873c 	xorhi	r4,r16,18972
81127be0:	81127f54 	ori	r4,r16,18941
81127be4:	8112873c 	xorhi	r4,r16,18972
81127be8:	8112873c 	xorhi	r4,r16,18972
81127bec:	8112873c 	xorhi	r4,r16,18972
81127bf0:	8112873c 	xorhi	r4,r16,18972
81127bf4:	81127ff4 	orhi	r4,r16,18943
81127bf8:	8112873c 	xorhi	r4,r16,18972
81127bfc:	8112873c 	xorhi	r4,r16,18972
81127c00:	81128000 	call	88112800 <__reset+0x20f2800>
81127c04:	8112873c 	xorhi	r4,r16,18972
81127c08:	8112873c 	xorhi	r4,r16,18972
81127c0c:	8112873c 	xorhi	r4,r16,18972
81127c10:	8112873c 	xorhi	r4,r16,18972
81127c14:	8112873c 	xorhi	r4,r16,18972
81127c18:	81128478 	rdprs	r4,r16,18961
81127c1c:	8112873c 	xorhi	r4,r16,18972
81127c20:	8112873c 	xorhi	r4,r16,18972
81127c24:	811284d8 	cmpnei	r4,r16,18963
81127c28:	8112873c 	xorhi	r4,r16,18972
81127c2c:	8112873c 	xorhi	r4,r16,18972
81127c30:	8112873c 	xorhi	r4,r16,18972
81127c34:	8112873c 	xorhi	r4,r16,18972
81127c38:	8112873c 	xorhi	r4,r16,18972
81127c3c:	8112873c 	xorhi	r4,r16,18972
81127c40:	8112873c 	xorhi	r4,r16,18972
81127c44:	8112873c 	xorhi	r4,r16,18972
81127c48:	8112873c 	xorhi	r4,r16,18972
81127c4c:	8112873c 	xorhi	r4,r16,18972
81127c50:	811286e8 	cmpgeui	r4,r16,18971
81127c54:	81128688 	cmpgei	r4,r16,18970
81127c58:	81127f54 	ori	r4,r16,18941
81127c5c:	81127f54 	ori	r4,r16,18941
81127c60:	81127f54 	ori	r4,r16,18941
81127c64:	81128698 	cmpnei	r4,r16,18970
81127c68:	81128688 	cmpgei	r4,r16,18970
81127c6c:	8112873c 	xorhi	r4,r16,18972
81127c70:	8112873c 	xorhi	r4,r16,18972
81127c74:	811286a4 	muli	r4,r16,18970
81127c78:	8112873c 	xorhi	r4,r16,18972
81127c7c:	811286b4 	orhi	r4,r16,18970
81127c80:	81128588 	cmpgei	r4,r16,18966
81127c84:	81127cc4 	addi	r4,r16,18931
81127c88:	811285a8 	cmpgeui	r4,r16,18966
81127c8c:	8112873c 	xorhi	r4,r16,18972
81127c90:	811285b4 	orhi	r4,r16,18966
81127c94:	8112873c 	xorhi	r4,r16,18972
81127c98:	81128610 	cmplti	r4,r16,18968
81127c9c:	8112873c 	xorhi	r4,r16,18972
81127ca0:	8112873c 	xorhi	r4,r16,18972
81127ca4:	81128620 	cmpeqi	r4,r16,18968
81127ca8:	d9003117 	ldw	r4,196(sp)
81127cac:	d8802d15 	stw	r2,180(sp)
81127cb0:	0109c83a 	sub	r4,zero,r4
81127cb4:	d9003115 	stw	r4,196(sp)
81127cb8:	94800114 	ori	r18,r18,4
81127cbc:	ac400007 	ldb	r17,0(r21)
81127cc0:	003f9706 	br	81127b20 <__reset+0xfb107b20>
81127cc4:	00800c04 	movi	r2,48
81127cc8:	d9002d17 	ldw	r4,180(sp)
81127ccc:	d9402917 	ldw	r5,164(sp)
81127cd0:	d8802705 	stb	r2,156(sp)
81127cd4:	00801e04 	movi	r2,120
81127cd8:	d8802745 	stb	r2,157(sp)
81127cdc:	d8002785 	stb	zero,158(sp)
81127ce0:	20c00104 	addi	r3,r4,4
81127ce4:	24c00017 	ldw	r19,0(r4)
81127ce8:	002d883a 	mov	r22,zero
81127cec:	90800094 	ori	r2,r18,2
81127cf0:	28029a16 	blt	r5,zero,8112875c <___vfprintf_internal_r+0xdc8>
81127cf4:	00bfdfc4 	movi	r2,-129
81127cf8:	90a4703a 	and	r18,r18,r2
81127cfc:	d8c02d15 	stw	r3,180(sp)
81127d00:	94800094 	ori	r18,r18,2
81127d04:	9802871e 	bne	r19,zero,81128724 <___vfprintf_internal_r+0xd90>
81127d08:	00a04574 	movhi	r2,33045
81127d0c:	108a8d04 	addi	r2,r2,10804
81127d10:	d8803915 	stw	r2,228(sp)
81127d14:	04401e04 	movi	r17,120
81127d18:	d8802917 	ldw	r2,164(sp)
81127d1c:	0039883a 	mov	fp,zero
81127d20:	1001e926 	beq	r2,zero,811284c8 <___vfprintf_internal_r+0xb34>
81127d24:	0027883a 	mov	r19,zero
81127d28:	002d883a 	mov	r22,zero
81127d2c:	00020506 	br	81128544 <___vfprintf_internal_r+0xbb0>
81127d30:	d9002c17 	ldw	r4,176(sp)
81127d34:	b80b883a 	mov	r5,r23
81127d38:	112b6e00 	call	8112b6e0 <__swsetup_r>
81127d3c:	1005ac1e 	bne	r2,zero,811293f0 <___vfprintf_internal_r+0x1a5c>
81127d40:	b880030b 	ldhu	r2,12(r23)
81127d44:	00c00284 	movi	r3,10
81127d48:	1080068c 	andi	r2,r2,26
81127d4c:	10ff3c1e 	bne	r2,r3,81127a40 <__reset+0xfb107a40>
81127d50:	b880038f 	ldh	r2,14(r23)
81127d54:	103f3a16 	blt	r2,zero,81127a40 <__reset+0xfb107a40>
81127d58:	d9c02d17 	ldw	r7,180(sp)
81127d5c:	d9002c17 	ldw	r4,176(sp)
81127d60:	a80d883a 	mov	r6,r21
81127d64:	b80b883a 	mov	r5,r23
81127d68:	1129bb00 	call	81129bb0 <__sbprintf>
81127d6c:	00001106 	br	81127db4 <___vfprintf_internal_r+0x420>
81127d70:	d9002c17 	ldw	r4,176(sp)
81127d74:	d9801e04 	addi	r6,sp,120
81127d78:	b80b883a 	mov	r5,r23
81127d7c:	113389c0 	call	8113389c <__sprint_r>
81127d80:	1000081e 	bne	r2,zero,81127da4 <___vfprintf_internal_r+0x410>
81127d84:	da000404 	addi	r8,sp,16
81127d88:	003f5306 	br	81127ad8 <__reset+0xfb107ad8>
81127d8c:	d8802017 	ldw	r2,128(sp)
81127d90:	10000426 	beq	r2,zero,81127da4 <___vfprintf_internal_r+0x410>
81127d94:	d9002c17 	ldw	r4,176(sp)
81127d98:	d9801e04 	addi	r6,sp,120
81127d9c:	b80b883a 	mov	r5,r23
81127da0:	113389c0 	call	8113389c <__sprint_r>
81127da4:	b880030b 	ldhu	r2,12(r23)
81127da8:	1080100c 	andi	r2,r2,64
81127dac:	1005901e 	bne	r2,zero,811293f0 <___vfprintf_internal_r+0x1a5c>
81127db0:	d8802f17 	ldw	r2,188(sp)
81127db4:	dfc04717 	ldw	ra,284(sp)
81127db8:	df004617 	ldw	fp,280(sp)
81127dbc:	ddc04517 	ldw	r23,276(sp)
81127dc0:	dd804417 	ldw	r22,272(sp)
81127dc4:	dd404317 	ldw	r21,268(sp)
81127dc8:	dd004217 	ldw	r20,264(sp)
81127dcc:	dcc04117 	ldw	r19,260(sp)
81127dd0:	dc804017 	ldw	r18,256(sp)
81127dd4:	dc403f17 	ldw	r17,252(sp)
81127dd8:	dc003e17 	ldw	r16,248(sp)
81127ddc:	dec04804 	addi	sp,sp,288
81127de0:	f800283a 	ret
81127de4:	d9002c17 	ldw	r4,176(sp)
81127de8:	112d7500 	call	8112d750 <__sinit>
81127dec:	003f0406 	br	81127a00 <__reset+0xfb107a00>
81127df0:	d8802d17 	ldw	r2,180(sp)
81127df4:	d9002d17 	ldw	r4,180(sp)
81127df8:	10800017 	ldw	r2,0(r2)
81127dfc:	d8803115 	stw	r2,196(sp)
81127e00:	20800104 	addi	r2,r4,4
81127e04:	d9003117 	ldw	r4,196(sp)
81127e08:	203fa716 	blt	r4,zero,81127ca8 <__reset+0xfb107ca8>
81127e0c:	d8802d15 	stw	r2,180(sp)
81127e10:	ac400007 	ldb	r17,0(r21)
81127e14:	003f4206 	br	81127b20 <__reset+0xfb107b20>
81127e18:	ac400007 	ldb	r17,0(r21)
81127e1c:	aac00044 	addi	r11,r21,1
81127e20:	8a872826 	beq	r17,r10,81129ac4 <___vfprintf_internal_r+0x2130>
81127e24:	88bff404 	addi	r2,r17,-48
81127e28:	0009883a 	mov	r4,zero
81127e2c:	30867d36 	bltu	r6,r2,81129824 <___vfprintf_internal_r+0x1e90>
81127e30:	5c400007 	ldb	r17,0(r11)
81127e34:	210002a4 	muli	r4,r4,10
81127e38:	5d400044 	addi	r21,r11,1
81127e3c:	a817883a 	mov	r11,r21
81127e40:	2089883a 	add	r4,r4,r2
81127e44:	88bff404 	addi	r2,r17,-48
81127e48:	30bff92e 	bgeu	r6,r2,81127e30 <__reset+0xfb107e30>
81127e4c:	2005c916 	blt	r4,zero,81129574 <___vfprintf_internal_r+0x1be0>
81127e50:	d9002915 	stw	r4,164(sp)
81127e54:	003f3306 	br	81127b24 <__reset+0xfb107b24>
81127e58:	94802014 	ori	r18,r18,128
81127e5c:	ac400007 	ldb	r17,0(r21)
81127e60:	003f2f06 	br	81127b20 <__reset+0xfb107b20>
81127e64:	a809883a 	mov	r4,r21
81127e68:	d8003115 	stw	zero,196(sp)
81127e6c:	88bff404 	addi	r2,r17,-48
81127e70:	0017883a 	mov	r11,zero
81127e74:	24400007 	ldb	r17,0(r4)
81127e78:	5ac002a4 	muli	r11,r11,10
81127e7c:	ad400044 	addi	r21,r21,1
81127e80:	a809883a 	mov	r4,r21
81127e84:	12d7883a 	add	r11,r2,r11
81127e88:	88bff404 	addi	r2,r17,-48
81127e8c:	30bff92e 	bgeu	r6,r2,81127e74 <__reset+0xfb107e74>
81127e90:	dac03115 	stw	r11,196(sp)
81127e94:	003f2306 	br	81127b24 <__reset+0xfb107b24>
81127e98:	18c03fcc 	andi	r3,r3,255
81127e9c:	18072b1e 	bne	r3,zero,81129b4c <___vfprintf_internal_r+0x21b8>
81127ea0:	94800414 	ori	r18,r18,16
81127ea4:	9080080c 	andi	r2,r18,32
81127ea8:	10037b26 	beq	r2,zero,81128c98 <___vfprintf_internal_r+0x1304>
81127eac:	d9402d17 	ldw	r5,180(sp)
81127eb0:	28800117 	ldw	r2,4(r5)
81127eb4:	2cc00017 	ldw	r19,0(r5)
81127eb8:	29400204 	addi	r5,r5,8
81127ebc:	d9402d15 	stw	r5,180(sp)
81127ec0:	102d883a 	mov	r22,r2
81127ec4:	10044b16 	blt	r2,zero,81128ff4 <___vfprintf_internal_r+0x1660>
81127ec8:	d9402917 	ldw	r5,164(sp)
81127ecc:	df002783 	ldbu	fp,158(sp)
81127ed0:	2803bc16 	blt	r5,zero,81128dc4 <___vfprintf_internal_r+0x1430>
81127ed4:	00ffdfc4 	movi	r3,-129
81127ed8:	9d84b03a 	or	r2,r19,r22
81127edc:	90e4703a 	and	r18,r18,r3
81127ee0:	10017726 	beq	r2,zero,811284c0 <___vfprintf_internal_r+0xb2c>
81127ee4:	b0038326 	beq	r22,zero,81128cf4 <___vfprintf_internal_r+0x1360>
81127ee8:	dc402a15 	stw	r17,168(sp)
81127eec:	dc001e04 	addi	r16,sp,120
81127ef0:	b023883a 	mov	r17,r22
81127ef4:	402d883a 	mov	r22,r8
81127ef8:	9809883a 	mov	r4,r19
81127efc:	880b883a 	mov	r5,r17
81127f00:	01800284 	movi	r6,10
81127f04:	000f883a 	mov	r7,zero
81127f08:	11365d40 	call	811365d4 <__umoddi3>
81127f0c:	10800c04 	addi	r2,r2,48
81127f10:	843fffc4 	addi	r16,r16,-1
81127f14:	9809883a 	mov	r4,r19
81127f18:	880b883a 	mov	r5,r17
81127f1c:	80800005 	stb	r2,0(r16)
81127f20:	01800284 	movi	r6,10
81127f24:	000f883a 	mov	r7,zero
81127f28:	11360540 	call	81136054 <__udivdi3>
81127f2c:	1027883a 	mov	r19,r2
81127f30:	10c4b03a 	or	r2,r2,r3
81127f34:	1823883a 	mov	r17,r3
81127f38:	103fef1e 	bne	r2,zero,81127ef8 <__reset+0xfb107ef8>
81127f3c:	d8c02817 	ldw	r3,160(sp)
81127f40:	dc402a17 	ldw	r17,168(sp)
81127f44:	b011883a 	mov	r8,r22
81127f48:	1c07c83a 	sub	r3,r3,r16
81127f4c:	d8c02e15 	stw	r3,184(sp)
81127f50:	00005906 	br	811280b8 <___vfprintf_internal_r+0x724>
81127f54:	18c03fcc 	andi	r3,r3,255
81127f58:	1806fa1e 	bne	r3,zero,81129b44 <___vfprintf_internal_r+0x21b0>
81127f5c:	9080020c 	andi	r2,r18,8
81127f60:	10048a26 	beq	r2,zero,8112918c <___vfprintf_internal_r+0x17f8>
81127f64:	d8c02d17 	ldw	r3,180(sp)
81127f68:	d9002d17 	ldw	r4,180(sp)
81127f6c:	d9402d17 	ldw	r5,180(sp)
81127f70:	18c00017 	ldw	r3,0(r3)
81127f74:	21000117 	ldw	r4,4(r4)
81127f78:	29400204 	addi	r5,r5,8
81127f7c:	d8c03615 	stw	r3,216(sp)
81127f80:	d9003815 	stw	r4,224(sp)
81127f84:	d9402d15 	stw	r5,180(sp)
81127f88:	d9003617 	ldw	r4,216(sp)
81127f8c:	d9403817 	ldw	r5,224(sp)
81127f90:	da003d15 	stw	r8,244(sp)
81127f94:	04000044 	movi	r16,1
81127f98:	11301e80 	call	811301e8 <__fpclassifyd>
81127f9c:	da003d17 	ldw	r8,244(sp)
81127fa0:	14041f1e 	bne	r2,r16,81129020 <___vfprintf_internal_r+0x168c>
81127fa4:	d9003617 	ldw	r4,216(sp)
81127fa8:	d9403817 	ldw	r5,224(sp)
81127fac:	000d883a 	mov	r6,zero
81127fb0:	000f883a 	mov	r7,zero
81127fb4:	11380f00 	call	811380f0 <__ledf2>
81127fb8:	da003d17 	ldw	r8,244(sp)
81127fbc:	1005be16 	blt	r2,zero,811296b8 <___vfprintf_internal_r+0x1d24>
81127fc0:	df002783 	ldbu	fp,158(sp)
81127fc4:	008011c4 	movi	r2,71
81127fc8:	1445330e 	bge	r2,r17,81129498 <___vfprintf_internal_r+0x1b04>
81127fcc:	04204574 	movhi	r16,33045
81127fd0:	840a8504 	addi	r16,r16,10772
81127fd4:	00c000c4 	movi	r3,3
81127fd8:	00bfdfc4 	movi	r2,-129
81127fdc:	d8c02a15 	stw	r3,168(sp)
81127fe0:	90a4703a 	and	r18,r18,r2
81127fe4:	d8c02e15 	stw	r3,184(sp)
81127fe8:	d8002915 	stw	zero,164(sp)
81127fec:	d8003215 	stw	zero,200(sp)
81127ff0:	00003706 	br	811280d0 <___vfprintf_internal_r+0x73c>
81127ff4:	94800214 	ori	r18,r18,8
81127ff8:	ac400007 	ldb	r17,0(r21)
81127ffc:	003ec806 	br	81127b20 <__reset+0xfb107b20>
81128000:	18c03fcc 	andi	r3,r3,255
81128004:	1806db1e 	bne	r3,zero,81129b74 <___vfprintf_internal_r+0x21e0>
81128008:	94800414 	ori	r18,r18,16
8112800c:	9080080c 	andi	r2,r18,32
81128010:	1002d826 	beq	r2,zero,81128b74 <___vfprintf_internal_r+0x11e0>
81128014:	d9402d17 	ldw	r5,180(sp)
81128018:	d8c02917 	ldw	r3,164(sp)
8112801c:	d8002785 	stb	zero,158(sp)
81128020:	28800204 	addi	r2,r5,8
81128024:	2cc00017 	ldw	r19,0(r5)
81128028:	2d800117 	ldw	r22,4(r5)
8112802c:	18048f16 	blt	r3,zero,8112926c <___vfprintf_internal_r+0x18d8>
81128030:	013fdfc4 	movi	r4,-129
81128034:	9d86b03a 	or	r3,r19,r22
81128038:	d8802d15 	stw	r2,180(sp)
8112803c:	9124703a 	and	r18,r18,r4
81128040:	1802d91e 	bne	r3,zero,81128ba8 <___vfprintf_internal_r+0x1214>
81128044:	d8c02917 	ldw	r3,164(sp)
81128048:	0039883a 	mov	fp,zero
8112804c:	1805c326 	beq	r3,zero,8112975c <___vfprintf_internal_r+0x1dc8>
81128050:	0027883a 	mov	r19,zero
81128054:	002d883a 	mov	r22,zero
81128058:	dc001e04 	addi	r16,sp,120
8112805c:	9806d0fa 	srli	r3,r19,3
81128060:	b008977a 	slli	r4,r22,29
81128064:	b02cd0fa 	srli	r22,r22,3
81128068:	9cc001cc 	andi	r19,r19,7
8112806c:	98800c04 	addi	r2,r19,48
81128070:	843fffc4 	addi	r16,r16,-1
81128074:	20e6b03a 	or	r19,r4,r3
81128078:	80800005 	stb	r2,0(r16)
8112807c:	9d86b03a 	or	r3,r19,r22
81128080:	183ff61e 	bne	r3,zero,8112805c <__reset+0xfb10805c>
81128084:	90c0004c 	andi	r3,r18,1
81128088:	18013b26 	beq	r3,zero,81128578 <___vfprintf_internal_r+0xbe4>
8112808c:	10803fcc 	andi	r2,r2,255
81128090:	1080201c 	xori	r2,r2,128
81128094:	10bfe004 	addi	r2,r2,-128
81128098:	00c00c04 	movi	r3,48
8112809c:	10c13626 	beq	r2,r3,81128578 <___vfprintf_internal_r+0xbe4>
811280a0:	80ffffc5 	stb	r3,-1(r16)
811280a4:	d8c02817 	ldw	r3,160(sp)
811280a8:	80bfffc4 	addi	r2,r16,-1
811280ac:	1021883a 	mov	r16,r2
811280b0:	1887c83a 	sub	r3,r3,r2
811280b4:	d8c02e15 	stw	r3,184(sp)
811280b8:	d8802e17 	ldw	r2,184(sp)
811280bc:	d9002917 	ldw	r4,164(sp)
811280c0:	1100010e 	bge	r2,r4,811280c8 <___vfprintf_internal_r+0x734>
811280c4:	2005883a 	mov	r2,r4
811280c8:	d8802a15 	stw	r2,168(sp)
811280cc:	d8003215 	stw	zero,200(sp)
811280d0:	e7003fcc 	andi	fp,fp,255
811280d4:	e700201c 	xori	fp,fp,128
811280d8:	e73fe004 	addi	fp,fp,-128
811280dc:	e0000326 	beq	fp,zero,811280ec <___vfprintf_internal_r+0x758>
811280e0:	d8c02a17 	ldw	r3,168(sp)
811280e4:	18c00044 	addi	r3,r3,1
811280e8:	d8c02a15 	stw	r3,168(sp)
811280ec:	90c0008c 	andi	r3,r18,2
811280f0:	d8c02b15 	stw	r3,172(sp)
811280f4:	18000326 	beq	r3,zero,81128104 <___vfprintf_internal_r+0x770>
811280f8:	d8c02a17 	ldw	r3,168(sp)
811280fc:	18c00084 	addi	r3,r3,2
81128100:	d8c02a15 	stw	r3,168(sp)
81128104:	90c0210c 	andi	r3,r18,132
81128108:	d8c03015 	stw	r3,192(sp)
8112810c:	1801a31e 	bne	r3,zero,8112879c <___vfprintf_internal_r+0xe08>
81128110:	d9003117 	ldw	r4,196(sp)
81128114:	d8c02a17 	ldw	r3,168(sp)
81128118:	20e7c83a 	sub	r19,r4,r3
8112811c:	04c19f0e 	bge	zero,r19,8112879c <___vfprintf_internal_r+0xe08>
81128120:	02400404 	movi	r9,16
81128124:	d8c02017 	ldw	r3,128(sp)
81128128:	d8801f17 	ldw	r2,124(sp)
8112812c:	4cc50d0e 	bge	r9,r19,81129564 <___vfprintf_internal_r+0x1bd0>
81128130:	01604574 	movhi	r5,33045
81128134:	294aa084 	addi	r5,r5,10882
81128138:	dc403b15 	stw	r17,236(sp)
8112813c:	d9403515 	stw	r5,212(sp)
81128140:	9823883a 	mov	r17,r19
81128144:	482d883a 	mov	r22,r9
81128148:	9027883a 	mov	r19,r18
8112814c:	070001c4 	movi	fp,7
81128150:	8025883a 	mov	r18,r16
81128154:	dc002c17 	ldw	r16,176(sp)
81128158:	00000306 	br	81128168 <___vfprintf_internal_r+0x7d4>
8112815c:	8c7ffc04 	addi	r17,r17,-16
81128160:	42000204 	addi	r8,r8,8
81128164:	b440130e 	bge	r22,r17,811281b4 <___vfprintf_internal_r+0x820>
81128168:	01204574 	movhi	r4,33045
8112816c:	18c00404 	addi	r3,r3,16
81128170:	10800044 	addi	r2,r2,1
81128174:	210aa084 	addi	r4,r4,10882
81128178:	41000015 	stw	r4,0(r8)
8112817c:	45800115 	stw	r22,4(r8)
81128180:	d8c02015 	stw	r3,128(sp)
81128184:	d8801f15 	stw	r2,124(sp)
81128188:	e0bff40e 	bge	fp,r2,8112815c <__reset+0xfb10815c>
8112818c:	d9801e04 	addi	r6,sp,120
81128190:	b80b883a 	mov	r5,r23
81128194:	8009883a 	mov	r4,r16
81128198:	113389c0 	call	8113389c <__sprint_r>
8112819c:	103f011e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811281a0:	8c7ffc04 	addi	r17,r17,-16
811281a4:	d8c02017 	ldw	r3,128(sp)
811281a8:	d8801f17 	ldw	r2,124(sp)
811281ac:	da000404 	addi	r8,sp,16
811281b0:	b47fed16 	blt	r22,r17,81128168 <__reset+0xfb108168>
811281b4:	9021883a 	mov	r16,r18
811281b8:	9825883a 	mov	r18,r19
811281bc:	8827883a 	mov	r19,r17
811281c0:	dc403b17 	ldw	r17,236(sp)
811281c4:	d9403517 	ldw	r5,212(sp)
811281c8:	98c7883a 	add	r3,r19,r3
811281cc:	10800044 	addi	r2,r2,1
811281d0:	41400015 	stw	r5,0(r8)
811281d4:	44c00115 	stw	r19,4(r8)
811281d8:	d8c02015 	stw	r3,128(sp)
811281dc:	d8801f15 	stw	r2,124(sp)
811281e0:	010001c4 	movi	r4,7
811281e4:	2082a316 	blt	r4,r2,81128c74 <___vfprintf_internal_r+0x12e0>
811281e8:	df002787 	ldb	fp,158(sp)
811281ec:	42000204 	addi	r8,r8,8
811281f0:	e0000c26 	beq	fp,zero,81128224 <___vfprintf_internal_r+0x890>
811281f4:	d8801f17 	ldw	r2,124(sp)
811281f8:	d9002784 	addi	r4,sp,158
811281fc:	18c00044 	addi	r3,r3,1
81128200:	10800044 	addi	r2,r2,1
81128204:	41000015 	stw	r4,0(r8)
81128208:	01000044 	movi	r4,1
8112820c:	41000115 	stw	r4,4(r8)
81128210:	d8c02015 	stw	r3,128(sp)
81128214:	d8801f15 	stw	r2,124(sp)
81128218:	010001c4 	movi	r4,7
8112821c:	20823c16 	blt	r4,r2,81128b10 <___vfprintf_internal_r+0x117c>
81128220:	42000204 	addi	r8,r8,8
81128224:	d8802b17 	ldw	r2,172(sp)
81128228:	10000c26 	beq	r2,zero,8112825c <___vfprintf_internal_r+0x8c8>
8112822c:	d8801f17 	ldw	r2,124(sp)
81128230:	d9002704 	addi	r4,sp,156
81128234:	18c00084 	addi	r3,r3,2
81128238:	10800044 	addi	r2,r2,1
8112823c:	41000015 	stw	r4,0(r8)
81128240:	01000084 	movi	r4,2
81128244:	41000115 	stw	r4,4(r8)
81128248:	d8c02015 	stw	r3,128(sp)
8112824c:	d8801f15 	stw	r2,124(sp)
81128250:	010001c4 	movi	r4,7
81128254:	20823616 	blt	r4,r2,81128b30 <___vfprintf_internal_r+0x119c>
81128258:	42000204 	addi	r8,r8,8
8112825c:	d9003017 	ldw	r4,192(sp)
81128260:	00802004 	movi	r2,128
81128264:	20819926 	beq	r4,r2,811288cc <___vfprintf_internal_r+0xf38>
81128268:	d9402917 	ldw	r5,164(sp)
8112826c:	d8802e17 	ldw	r2,184(sp)
81128270:	28adc83a 	sub	r22,r5,r2
81128274:	0580310e 	bge	zero,r22,8112833c <___vfprintf_internal_r+0x9a8>
81128278:	07000404 	movi	fp,16
8112827c:	d8801f17 	ldw	r2,124(sp)
81128280:	e584140e 	bge	fp,r22,811292d4 <___vfprintf_internal_r+0x1940>
81128284:	01604574 	movhi	r5,33045
81128288:	294a9c84 	addi	r5,r5,10866
8112828c:	dc402915 	stw	r17,164(sp)
81128290:	d9402b15 	stw	r5,172(sp)
81128294:	b023883a 	mov	r17,r22
81128298:	04c001c4 	movi	r19,7
8112829c:	a82d883a 	mov	r22,r21
811282a0:	902b883a 	mov	r21,r18
811282a4:	8025883a 	mov	r18,r16
811282a8:	dc002c17 	ldw	r16,176(sp)
811282ac:	00000306 	br	811282bc <___vfprintf_internal_r+0x928>
811282b0:	8c7ffc04 	addi	r17,r17,-16
811282b4:	42000204 	addi	r8,r8,8
811282b8:	e440110e 	bge	fp,r17,81128300 <___vfprintf_internal_r+0x96c>
811282bc:	18c00404 	addi	r3,r3,16
811282c0:	10800044 	addi	r2,r2,1
811282c4:	45000015 	stw	r20,0(r8)
811282c8:	47000115 	stw	fp,4(r8)
811282cc:	d8c02015 	stw	r3,128(sp)
811282d0:	d8801f15 	stw	r2,124(sp)
811282d4:	98bff60e 	bge	r19,r2,811282b0 <__reset+0xfb1082b0>
811282d8:	d9801e04 	addi	r6,sp,120
811282dc:	b80b883a 	mov	r5,r23
811282e0:	8009883a 	mov	r4,r16
811282e4:	113389c0 	call	8113389c <__sprint_r>
811282e8:	103eae1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811282ec:	8c7ffc04 	addi	r17,r17,-16
811282f0:	d8c02017 	ldw	r3,128(sp)
811282f4:	d8801f17 	ldw	r2,124(sp)
811282f8:	da000404 	addi	r8,sp,16
811282fc:	e47fef16 	blt	fp,r17,811282bc <__reset+0xfb1082bc>
81128300:	9021883a 	mov	r16,r18
81128304:	a825883a 	mov	r18,r21
81128308:	b02b883a 	mov	r21,r22
8112830c:	882d883a 	mov	r22,r17
81128310:	dc402917 	ldw	r17,164(sp)
81128314:	d9002b17 	ldw	r4,172(sp)
81128318:	1d87883a 	add	r3,r3,r22
8112831c:	10800044 	addi	r2,r2,1
81128320:	41000015 	stw	r4,0(r8)
81128324:	45800115 	stw	r22,4(r8)
81128328:	d8c02015 	stw	r3,128(sp)
8112832c:	d8801f15 	stw	r2,124(sp)
81128330:	010001c4 	movi	r4,7
81128334:	2081ee16 	blt	r4,r2,81128af0 <___vfprintf_internal_r+0x115c>
81128338:	42000204 	addi	r8,r8,8
8112833c:	9080400c 	andi	r2,r18,256
81128340:	1001181e 	bne	r2,zero,811287a4 <___vfprintf_internal_r+0xe10>
81128344:	d9402e17 	ldw	r5,184(sp)
81128348:	d8801f17 	ldw	r2,124(sp)
8112834c:	44000015 	stw	r16,0(r8)
81128350:	1947883a 	add	r3,r3,r5
81128354:	10800044 	addi	r2,r2,1
81128358:	41400115 	stw	r5,4(r8)
8112835c:	d8c02015 	stw	r3,128(sp)
81128360:	d8801f15 	stw	r2,124(sp)
81128364:	010001c4 	movi	r4,7
81128368:	2081d316 	blt	r4,r2,81128ab8 <___vfprintf_internal_r+0x1124>
8112836c:	42000204 	addi	r8,r8,8
81128370:	9480010c 	andi	r18,r18,4
81128374:	90003226 	beq	r18,zero,81128440 <___vfprintf_internal_r+0xaac>
81128378:	d9403117 	ldw	r5,196(sp)
8112837c:	d8802a17 	ldw	r2,168(sp)
81128380:	28a1c83a 	sub	r16,r5,r2
81128384:	04002e0e 	bge	zero,r16,81128440 <___vfprintf_internal_r+0xaac>
81128388:	04400404 	movi	r17,16
8112838c:	d8801f17 	ldw	r2,124(sp)
81128390:	8c04a20e 	bge	r17,r16,8112961c <___vfprintf_internal_r+0x1c88>
81128394:	01604574 	movhi	r5,33045
81128398:	294aa084 	addi	r5,r5,10882
8112839c:	d9403515 	stw	r5,212(sp)
811283a0:	048001c4 	movi	r18,7
811283a4:	dcc02c17 	ldw	r19,176(sp)
811283a8:	00000306 	br	811283b8 <___vfprintf_internal_r+0xa24>
811283ac:	843ffc04 	addi	r16,r16,-16
811283b0:	42000204 	addi	r8,r8,8
811283b4:	8c00130e 	bge	r17,r16,81128404 <___vfprintf_internal_r+0xa70>
811283b8:	01204574 	movhi	r4,33045
811283bc:	18c00404 	addi	r3,r3,16
811283c0:	10800044 	addi	r2,r2,1
811283c4:	210aa084 	addi	r4,r4,10882
811283c8:	41000015 	stw	r4,0(r8)
811283cc:	44400115 	stw	r17,4(r8)
811283d0:	d8c02015 	stw	r3,128(sp)
811283d4:	d8801f15 	stw	r2,124(sp)
811283d8:	90bff40e 	bge	r18,r2,811283ac <__reset+0xfb1083ac>
811283dc:	d9801e04 	addi	r6,sp,120
811283e0:	b80b883a 	mov	r5,r23
811283e4:	9809883a 	mov	r4,r19
811283e8:	113389c0 	call	8113389c <__sprint_r>
811283ec:	103e6d1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811283f0:	843ffc04 	addi	r16,r16,-16
811283f4:	d8c02017 	ldw	r3,128(sp)
811283f8:	d8801f17 	ldw	r2,124(sp)
811283fc:	da000404 	addi	r8,sp,16
81128400:	8c3fed16 	blt	r17,r16,811283b8 <__reset+0xfb1083b8>
81128404:	d9403517 	ldw	r5,212(sp)
81128408:	1c07883a 	add	r3,r3,r16
8112840c:	10800044 	addi	r2,r2,1
81128410:	41400015 	stw	r5,0(r8)
81128414:	44000115 	stw	r16,4(r8)
81128418:	d8c02015 	stw	r3,128(sp)
8112841c:	d8801f15 	stw	r2,124(sp)
81128420:	010001c4 	movi	r4,7
81128424:	2080060e 	bge	r4,r2,81128440 <___vfprintf_internal_r+0xaac>
81128428:	d9002c17 	ldw	r4,176(sp)
8112842c:	d9801e04 	addi	r6,sp,120
81128430:	b80b883a 	mov	r5,r23
81128434:	113389c0 	call	8113389c <__sprint_r>
81128438:	103e5a1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
8112843c:	d8c02017 	ldw	r3,128(sp)
81128440:	d8803117 	ldw	r2,196(sp)
81128444:	d9002a17 	ldw	r4,168(sp)
81128448:	1100010e 	bge	r2,r4,81128450 <___vfprintf_internal_r+0xabc>
8112844c:	2005883a 	mov	r2,r4
81128450:	d9402f17 	ldw	r5,188(sp)
81128454:	288b883a 	add	r5,r5,r2
81128458:	d9402f15 	stw	r5,188(sp)
8112845c:	18019e1e 	bne	r3,zero,81128ad8 <___vfprintf_internal_r+0x1144>
81128460:	a8800007 	ldb	r2,0(r21)
81128464:	d8001f15 	stw	zero,124(sp)
81128468:	da000404 	addi	r8,sp,16
8112846c:	103d851e 	bne	r2,zero,81127a84 <__reset+0xfb107a84>
81128470:	a821883a 	mov	r16,r21
81128474:	003d9b06 	br	81127ae4 <__reset+0xfb107ae4>
81128478:	18c03fcc 	andi	r3,r3,255
8112847c:	1805c11e 	bne	r3,zero,81129b84 <___vfprintf_internal_r+0x21f0>
81128480:	94800414 	ori	r18,r18,16
81128484:	9080080c 	andi	r2,r18,32
81128488:	10020c26 	beq	r2,zero,81128cbc <___vfprintf_internal_r+0x1328>
8112848c:	d8802d17 	ldw	r2,180(sp)
81128490:	d9002917 	ldw	r4,164(sp)
81128494:	d8002785 	stb	zero,158(sp)
81128498:	10c00204 	addi	r3,r2,8
8112849c:	14c00017 	ldw	r19,0(r2)
811284a0:	15800117 	ldw	r22,4(r2)
811284a4:	20040f16 	blt	r4,zero,811294e4 <___vfprintf_internal_r+0x1b50>
811284a8:	013fdfc4 	movi	r4,-129
811284ac:	9d84b03a 	or	r2,r19,r22
811284b0:	d8c02d15 	stw	r3,180(sp)
811284b4:	9124703a 	and	r18,r18,r4
811284b8:	0039883a 	mov	fp,zero
811284bc:	103e891e 	bne	r2,zero,81127ee4 <__reset+0xfb107ee4>
811284c0:	d9002917 	ldw	r4,164(sp)
811284c4:	2002c11e 	bne	r4,zero,81128fcc <___vfprintf_internal_r+0x1638>
811284c8:	d8002915 	stw	zero,164(sp)
811284cc:	d8002e15 	stw	zero,184(sp)
811284d0:	dc001e04 	addi	r16,sp,120
811284d4:	003ef806 	br	811280b8 <__reset+0xfb1080b8>
811284d8:	18c03fcc 	andi	r3,r3,255
811284dc:	18059d1e 	bne	r3,zero,81129b54 <___vfprintf_internal_r+0x21c0>
811284e0:	01604574 	movhi	r5,33045
811284e4:	294a8804 	addi	r5,r5,10784
811284e8:	d9403915 	stw	r5,228(sp)
811284ec:	9080080c 	andi	r2,r18,32
811284f0:	10005226 	beq	r2,zero,8112863c <___vfprintf_internal_r+0xca8>
811284f4:	d8802d17 	ldw	r2,180(sp)
811284f8:	14c00017 	ldw	r19,0(r2)
811284fc:	15800117 	ldw	r22,4(r2)
81128500:	10800204 	addi	r2,r2,8
81128504:	d8802d15 	stw	r2,180(sp)
81128508:	9080004c 	andi	r2,r18,1
8112850c:	10019026 	beq	r2,zero,81128b50 <___vfprintf_internal_r+0x11bc>
81128510:	9d84b03a 	or	r2,r19,r22
81128514:	10036926 	beq	r2,zero,811292bc <___vfprintf_internal_r+0x1928>
81128518:	d8c02917 	ldw	r3,164(sp)
8112851c:	00800c04 	movi	r2,48
81128520:	d8802705 	stb	r2,156(sp)
81128524:	dc402745 	stb	r17,157(sp)
81128528:	d8002785 	stb	zero,158(sp)
8112852c:	90800094 	ori	r2,r18,2
81128530:	18045d16 	blt	r3,zero,811296a8 <___vfprintf_internal_r+0x1d14>
81128534:	00bfdfc4 	movi	r2,-129
81128538:	90a4703a 	and	r18,r18,r2
8112853c:	94800094 	ori	r18,r18,2
81128540:	0039883a 	mov	fp,zero
81128544:	d9003917 	ldw	r4,228(sp)
81128548:	dc001e04 	addi	r16,sp,120
8112854c:	988003cc 	andi	r2,r19,15
81128550:	b006973a 	slli	r3,r22,28
81128554:	2085883a 	add	r2,r4,r2
81128558:	9826d13a 	srli	r19,r19,4
8112855c:	10800003 	ldbu	r2,0(r2)
81128560:	b02cd13a 	srli	r22,r22,4
81128564:	843fffc4 	addi	r16,r16,-1
81128568:	1ce6b03a 	or	r19,r3,r19
8112856c:	80800005 	stb	r2,0(r16)
81128570:	9d84b03a 	or	r2,r19,r22
81128574:	103ff51e 	bne	r2,zero,8112854c <__reset+0xfb10854c>
81128578:	d8c02817 	ldw	r3,160(sp)
8112857c:	1c07c83a 	sub	r3,r3,r16
81128580:	d8c02e15 	stw	r3,184(sp)
81128584:	003ecc06 	br	811280b8 <__reset+0xfb1080b8>
81128588:	18c03fcc 	andi	r3,r3,255
8112858c:	183e9f26 	beq	r3,zero,8112800c <__reset+0xfb10800c>
81128590:	d9c02785 	stb	r7,158(sp)
81128594:	003e9d06 	br	8112800c <__reset+0xfb10800c>
81128598:	00c00044 	movi	r3,1
8112859c:	01c00ac4 	movi	r7,43
811285a0:	ac400007 	ldb	r17,0(r21)
811285a4:	003d5e06 	br	81127b20 <__reset+0xfb107b20>
811285a8:	94800814 	ori	r18,r18,32
811285ac:	ac400007 	ldb	r17,0(r21)
811285b0:	003d5b06 	br	81127b20 <__reset+0xfb107b20>
811285b4:	d8c02d17 	ldw	r3,180(sp)
811285b8:	d8002785 	stb	zero,158(sp)
811285bc:	1c000017 	ldw	r16,0(r3)
811285c0:	1cc00104 	addi	r19,r3,4
811285c4:	80041926 	beq	r16,zero,8112962c <___vfprintf_internal_r+0x1c98>
811285c8:	d9002917 	ldw	r4,164(sp)
811285cc:	2003d016 	blt	r4,zero,81129510 <___vfprintf_internal_r+0x1b7c>
811285d0:	200d883a 	mov	r6,r4
811285d4:	000b883a 	mov	r5,zero
811285d8:	8009883a 	mov	r4,r16
811285dc:	da003d15 	stw	r8,244(sp)
811285e0:	112e9780 	call	8112e978 <memchr>
811285e4:	da003d17 	ldw	r8,244(sp)
811285e8:	10045426 	beq	r2,zero,8112973c <___vfprintf_internal_r+0x1da8>
811285ec:	1405c83a 	sub	r2,r2,r16
811285f0:	d8802e15 	stw	r2,184(sp)
811285f4:	1003cc16 	blt	r2,zero,81129528 <___vfprintf_internal_r+0x1b94>
811285f8:	df002783 	ldbu	fp,158(sp)
811285fc:	d8802a15 	stw	r2,168(sp)
81128600:	dcc02d15 	stw	r19,180(sp)
81128604:	d8002915 	stw	zero,164(sp)
81128608:	d8003215 	stw	zero,200(sp)
8112860c:	003eb006 	br	811280d0 <__reset+0xfb1080d0>
81128610:	18c03fcc 	andi	r3,r3,255
81128614:	183f9b26 	beq	r3,zero,81128484 <__reset+0xfb108484>
81128618:	d9c02785 	stb	r7,158(sp)
8112861c:	003f9906 	br	81128484 <__reset+0xfb108484>
81128620:	18c03fcc 	andi	r3,r3,255
81128624:	1805551e 	bne	r3,zero,81129b7c <___vfprintf_internal_r+0x21e8>
81128628:	01604574 	movhi	r5,33045
8112862c:	294a8d04 	addi	r5,r5,10804
81128630:	d9403915 	stw	r5,228(sp)
81128634:	9080080c 	andi	r2,r18,32
81128638:	103fae1e 	bne	r2,zero,811284f4 <__reset+0xfb1084f4>
8112863c:	9080040c 	andi	r2,r18,16
81128640:	1002de26 	beq	r2,zero,811291bc <___vfprintf_internal_r+0x1828>
81128644:	d8c02d17 	ldw	r3,180(sp)
81128648:	002d883a 	mov	r22,zero
8112864c:	1cc00017 	ldw	r19,0(r3)
81128650:	18c00104 	addi	r3,r3,4
81128654:	d8c02d15 	stw	r3,180(sp)
81128658:	003fab06 	br	81128508 <__reset+0xfb108508>
8112865c:	38803fcc 	andi	r2,r7,255
81128660:	1080201c 	xori	r2,r2,128
81128664:	10bfe004 	addi	r2,r2,-128
81128668:	1002d21e 	bne	r2,zero,811291b4 <___vfprintf_internal_r+0x1820>
8112866c:	00c00044 	movi	r3,1
81128670:	01c00804 	movi	r7,32
81128674:	ac400007 	ldb	r17,0(r21)
81128678:	003d2906 	br	81127b20 <__reset+0xfb107b20>
8112867c:	94800054 	ori	r18,r18,1
81128680:	ac400007 	ldb	r17,0(r21)
81128684:	003d2606 	br	81127b20 <__reset+0xfb107b20>
81128688:	18c03fcc 	andi	r3,r3,255
8112868c:	183e0526 	beq	r3,zero,81127ea4 <__reset+0xfb107ea4>
81128690:	d9c02785 	stb	r7,158(sp)
81128694:	003e0306 	br	81127ea4 <__reset+0xfb107ea4>
81128698:	94801014 	ori	r18,r18,64
8112869c:	ac400007 	ldb	r17,0(r21)
811286a0:	003d1f06 	br	81127b20 <__reset+0xfb107b20>
811286a4:	ac400007 	ldb	r17,0(r21)
811286a8:	8a438726 	beq	r17,r9,811294c8 <___vfprintf_internal_r+0x1b34>
811286ac:	94800414 	ori	r18,r18,16
811286b0:	003d1b06 	br	81127b20 <__reset+0xfb107b20>
811286b4:	18c03fcc 	andi	r3,r3,255
811286b8:	1805341e 	bne	r3,zero,81129b8c <___vfprintf_internal_r+0x21f8>
811286bc:	9080080c 	andi	r2,r18,32
811286c0:	1002cd26 	beq	r2,zero,811291f8 <___vfprintf_internal_r+0x1864>
811286c4:	d9402d17 	ldw	r5,180(sp)
811286c8:	d9002f17 	ldw	r4,188(sp)
811286cc:	28800017 	ldw	r2,0(r5)
811286d0:	2007d7fa 	srai	r3,r4,31
811286d4:	29400104 	addi	r5,r5,4
811286d8:	d9402d15 	stw	r5,180(sp)
811286dc:	11000015 	stw	r4,0(r2)
811286e0:	10c00115 	stw	r3,4(r2)
811286e4:	003ce506 	br	81127a7c <__reset+0xfb107a7c>
811286e8:	d8c02d17 	ldw	r3,180(sp)
811286ec:	d9002d17 	ldw	r4,180(sp)
811286f0:	d8002785 	stb	zero,158(sp)
811286f4:	18800017 	ldw	r2,0(r3)
811286f8:	21000104 	addi	r4,r4,4
811286fc:	00c00044 	movi	r3,1
81128700:	d8c02a15 	stw	r3,168(sp)
81128704:	d8801405 	stb	r2,80(sp)
81128708:	d9002d15 	stw	r4,180(sp)
8112870c:	d8c02e15 	stw	r3,184(sp)
81128710:	d8002915 	stw	zero,164(sp)
81128714:	d8003215 	stw	zero,200(sp)
81128718:	dc001404 	addi	r16,sp,80
8112871c:	0039883a 	mov	fp,zero
81128720:	003e7206 	br	811280ec <__reset+0xfb1080ec>
81128724:	01204574 	movhi	r4,33045
81128728:	210a8d04 	addi	r4,r4,10804
8112872c:	0039883a 	mov	fp,zero
81128730:	d9003915 	stw	r4,228(sp)
81128734:	04401e04 	movi	r17,120
81128738:	003f8206 	br	81128544 <__reset+0xfb108544>
8112873c:	18c03fcc 	andi	r3,r3,255
81128740:	1805061e 	bne	r3,zero,81129b5c <___vfprintf_internal_r+0x21c8>
81128744:	883d9126 	beq	r17,zero,81127d8c <__reset+0xfb107d8c>
81128748:	00c00044 	movi	r3,1
8112874c:	d8c02a15 	stw	r3,168(sp)
81128750:	dc401405 	stb	r17,80(sp)
81128754:	d8002785 	stb	zero,158(sp)
81128758:	003fec06 	br	8112870c <__reset+0xfb10870c>
8112875c:	01604574 	movhi	r5,33045
81128760:	294a8d04 	addi	r5,r5,10804
81128764:	d9403915 	stw	r5,228(sp)
81128768:	d8c02d15 	stw	r3,180(sp)
8112876c:	1025883a 	mov	r18,r2
81128770:	04401e04 	movi	r17,120
81128774:	9d84b03a 	or	r2,r19,r22
81128778:	1000fc1e 	bne	r2,zero,81128b6c <___vfprintf_internal_r+0x11d8>
8112877c:	0039883a 	mov	fp,zero
81128780:	00800084 	movi	r2,2
81128784:	10803fcc 	andi	r2,r2,255
81128788:	00c00044 	movi	r3,1
8112878c:	10c20f26 	beq	r2,r3,81128fcc <___vfprintf_internal_r+0x1638>
81128790:	00c00084 	movi	r3,2
81128794:	10fd6326 	beq	r2,r3,81127d24 <__reset+0xfb107d24>
81128798:	003e2d06 	br	81128050 <__reset+0xfb108050>
8112879c:	d8c02017 	ldw	r3,128(sp)
811287a0:	003e9306 	br	811281f0 <__reset+0xfb1081f0>
811287a4:	00801944 	movi	r2,101
811287a8:	14407e0e 	bge	r2,r17,811289a4 <___vfprintf_internal_r+0x1010>
811287ac:	d9003617 	ldw	r4,216(sp)
811287b0:	d9403817 	ldw	r5,224(sp)
811287b4:	000d883a 	mov	r6,zero
811287b8:	000f883a 	mov	r7,zero
811287bc:	d8c03c15 	stw	r3,240(sp)
811287c0:	da003d15 	stw	r8,244(sp)
811287c4:	11380680 	call	81138068 <__eqdf2>
811287c8:	d8c03c17 	ldw	r3,240(sp)
811287cc:	da003d17 	ldw	r8,244(sp)
811287d0:	1000f71e 	bne	r2,zero,81128bb0 <___vfprintf_internal_r+0x121c>
811287d4:	d8801f17 	ldw	r2,124(sp)
811287d8:	01204574 	movhi	r4,33045
811287dc:	210a9404 	addi	r4,r4,10832
811287e0:	18c00044 	addi	r3,r3,1
811287e4:	10800044 	addi	r2,r2,1
811287e8:	41000015 	stw	r4,0(r8)
811287ec:	01000044 	movi	r4,1
811287f0:	41000115 	stw	r4,4(r8)
811287f4:	d8c02015 	stw	r3,128(sp)
811287f8:	d8801f15 	stw	r2,124(sp)
811287fc:	010001c4 	movi	r4,7
81128800:	2082b816 	blt	r4,r2,811292e4 <___vfprintf_internal_r+0x1950>
81128804:	42000204 	addi	r8,r8,8
81128808:	d8802617 	ldw	r2,152(sp)
8112880c:	d9403317 	ldw	r5,204(sp)
81128810:	11400216 	blt	r2,r5,8112881c <___vfprintf_internal_r+0xe88>
81128814:	9080004c 	andi	r2,r18,1
81128818:	103ed526 	beq	r2,zero,81128370 <__reset+0xfb108370>
8112881c:	d8803717 	ldw	r2,220(sp)
81128820:	d9003417 	ldw	r4,208(sp)
81128824:	d9403717 	ldw	r5,220(sp)
81128828:	1887883a 	add	r3,r3,r2
8112882c:	d8801f17 	ldw	r2,124(sp)
81128830:	41000015 	stw	r4,0(r8)
81128834:	41400115 	stw	r5,4(r8)
81128838:	10800044 	addi	r2,r2,1
8112883c:	d8c02015 	stw	r3,128(sp)
81128840:	d8801f15 	stw	r2,124(sp)
81128844:	010001c4 	movi	r4,7
81128848:	20832916 	blt	r4,r2,811294f0 <___vfprintf_internal_r+0x1b5c>
8112884c:	42000204 	addi	r8,r8,8
81128850:	d8803317 	ldw	r2,204(sp)
81128854:	143fffc4 	addi	r16,r2,-1
81128858:	043ec50e 	bge	zero,r16,81128370 <__reset+0xfb108370>
8112885c:	04400404 	movi	r17,16
81128860:	d8801f17 	ldw	r2,124(sp)
81128864:	8c00880e 	bge	r17,r16,81128a88 <___vfprintf_internal_r+0x10f4>
81128868:	01604574 	movhi	r5,33045
8112886c:	294a9c84 	addi	r5,r5,10866
81128870:	d9402b15 	stw	r5,172(sp)
81128874:	058001c4 	movi	r22,7
81128878:	dcc02c17 	ldw	r19,176(sp)
8112887c:	00000306 	br	8112888c <___vfprintf_internal_r+0xef8>
81128880:	42000204 	addi	r8,r8,8
81128884:	843ffc04 	addi	r16,r16,-16
81128888:	8c00820e 	bge	r17,r16,81128a94 <___vfprintf_internal_r+0x1100>
8112888c:	18c00404 	addi	r3,r3,16
81128890:	10800044 	addi	r2,r2,1
81128894:	45000015 	stw	r20,0(r8)
81128898:	44400115 	stw	r17,4(r8)
8112889c:	d8c02015 	stw	r3,128(sp)
811288a0:	d8801f15 	stw	r2,124(sp)
811288a4:	b0bff60e 	bge	r22,r2,81128880 <__reset+0xfb108880>
811288a8:	d9801e04 	addi	r6,sp,120
811288ac:	b80b883a 	mov	r5,r23
811288b0:	9809883a 	mov	r4,r19
811288b4:	113389c0 	call	8113389c <__sprint_r>
811288b8:	103d3a1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811288bc:	d8c02017 	ldw	r3,128(sp)
811288c0:	d8801f17 	ldw	r2,124(sp)
811288c4:	da000404 	addi	r8,sp,16
811288c8:	003fee06 	br	81128884 <__reset+0xfb108884>
811288cc:	d9403117 	ldw	r5,196(sp)
811288d0:	d8802a17 	ldw	r2,168(sp)
811288d4:	28adc83a 	sub	r22,r5,r2
811288d8:	05be630e 	bge	zero,r22,81128268 <__reset+0xfb108268>
811288dc:	07000404 	movi	fp,16
811288e0:	d8801f17 	ldw	r2,124(sp)
811288e4:	e5838f0e 	bge	fp,r22,81129724 <___vfprintf_internal_r+0x1d90>
811288e8:	01604574 	movhi	r5,33045
811288ec:	294a9c84 	addi	r5,r5,10866
811288f0:	dc403015 	stw	r17,192(sp)
811288f4:	d9402b15 	stw	r5,172(sp)
811288f8:	b023883a 	mov	r17,r22
811288fc:	04c001c4 	movi	r19,7
81128900:	a82d883a 	mov	r22,r21
81128904:	902b883a 	mov	r21,r18
81128908:	8025883a 	mov	r18,r16
8112890c:	dc002c17 	ldw	r16,176(sp)
81128910:	00000306 	br	81128920 <___vfprintf_internal_r+0xf8c>
81128914:	8c7ffc04 	addi	r17,r17,-16
81128918:	42000204 	addi	r8,r8,8
8112891c:	e440110e 	bge	fp,r17,81128964 <___vfprintf_internal_r+0xfd0>
81128920:	18c00404 	addi	r3,r3,16
81128924:	10800044 	addi	r2,r2,1
81128928:	45000015 	stw	r20,0(r8)
8112892c:	47000115 	stw	fp,4(r8)
81128930:	d8c02015 	stw	r3,128(sp)
81128934:	d8801f15 	stw	r2,124(sp)
81128938:	98bff60e 	bge	r19,r2,81128914 <__reset+0xfb108914>
8112893c:	d9801e04 	addi	r6,sp,120
81128940:	b80b883a 	mov	r5,r23
81128944:	8009883a 	mov	r4,r16
81128948:	113389c0 	call	8113389c <__sprint_r>
8112894c:	103d151e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128950:	8c7ffc04 	addi	r17,r17,-16
81128954:	d8c02017 	ldw	r3,128(sp)
81128958:	d8801f17 	ldw	r2,124(sp)
8112895c:	da000404 	addi	r8,sp,16
81128960:	e47fef16 	blt	fp,r17,81128920 <__reset+0xfb108920>
81128964:	9021883a 	mov	r16,r18
81128968:	a825883a 	mov	r18,r21
8112896c:	b02b883a 	mov	r21,r22
81128970:	882d883a 	mov	r22,r17
81128974:	dc403017 	ldw	r17,192(sp)
81128978:	d9002b17 	ldw	r4,172(sp)
8112897c:	1d87883a 	add	r3,r3,r22
81128980:	10800044 	addi	r2,r2,1
81128984:	41000015 	stw	r4,0(r8)
81128988:	45800115 	stw	r22,4(r8)
8112898c:	d8c02015 	stw	r3,128(sp)
81128990:	d8801f15 	stw	r2,124(sp)
81128994:	010001c4 	movi	r4,7
81128998:	20818e16 	blt	r4,r2,81128fd4 <___vfprintf_internal_r+0x1640>
8112899c:	42000204 	addi	r8,r8,8
811289a0:	003e3106 	br	81128268 <__reset+0xfb108268>
811289a4:	d9403317 	ldw	r5,204(sp)
811289a8:	00800044 	movi	r2,1
811289ac:	18c00044 	addi	r3,r3,1
811289b0:	1141530e 	bge	r2,r5,81128f00 <___vfprintf_internal_r+0x156c>
811289b4:	dc401f17 	ldw	r17,124(sp)
811289b8:	00800044 	movi	r2,1
811289bc:	40800115 	stw	r2,4(r8)
811289c0:	8c400044 	addi	r17,r17,1
811289c4:	44000015 	stw	r16,0(r8)
811289c8:	d8c02015 	stw	r3,128(sp)
811289cc:	dc401f15 	stw	r17,124(sp)
811289d0:	008001c4 	movi	r2,7
811289d4:	14416b16 	blt	r2,r17,81128f84 <___vfprintf_internal_r+0x15f0>
811289d8:	42000204 	addi	r8,r8,8
811289dc:	d8803717 	ldw	r2,220(sp)
811289e0:	d9003417 	ldw	r4,208(sp)
811289e4:	8c400044 	addi	r17,r17,1
811289e8:	10c7883a 	add	r3,r2,r3
811289ec:	40800115 	stw	r2,4(r8)
811289f0:	41000015 	stw	r4,0(r8)
811289f4:	d8c02015 	stw	r3,128(sp)
811289f8:	dc401f15 	stw	r17,124(sp)
811289fc:	008001c4 	movi	r2,7
81128a00:	14416916 	blt	r2,r17,81128fa8 <___vfprintf_internal_r+0x1614>
81128a04:	45800204 	addi	r22,r8,8
81128a08:	d9003617 	ldw	r4,216(sp)
81128a0c:	d9403817 	ldw	r5,224(sp)
81128a10:	000d883a 	mov	r6,zero
81128a14:	000f883a 	mov	r7,zero
81128a18:	d8c03c15 	stw	r3,240(sp)
81128a1c:	11380680 	call	81138068 <__eqdf2>
81128a20:	d8c03c17 	ldw	r3,240(sp)
81128a24:	1000bc26 	beq	r2,zero,81128d18 <___vfprintf_internal_r+0x1384>
81128a28:	d9403317 	ldw	r5,204(sp)
81128a2c:	84000044 	addi	r16,r16,1
81128a30:	8c400044 	addi	r17,r17,1
81128a34:	28bfffc4 	addi	r2,r5,-1
81128a38:	1887883a 	add	r3,r3,r2
81128a3c:	b0800115 	stw	r2,4(r22)
81128a40:	b4000015 	stw	r16,0(r22)
81128a44:	d8c02015 	stw	r3,128(sp)
81128a48:	dc401f15 	stw	r17,124(sp)
81128a4c:	008001c4 	movi	r2,7
81128a50:	14414316 	blt	r2,r17,81128f60 <___vfprintf_internal_r+0x15cc>
81128a54:	b5800204 	addi	r22,r22,8
81128a58:	d9003a17 	ldw	r4,232(sp)
81128a5c:	df0022c4 	addi	fp,sp,139
81128a60:	8c400044 	addi	r17,r17,1
81128a64:	20c7883a 	add	r3,r4,r3
81128a68:	b7000015 	stw	fp,0(r22)
81128a6c:	b1000115 	stw	r4,4(r22)
81128a70:	d8c02015 	stw	r3,128(sp)
81128a74:	dc401f15 	stw	r17,124(sp)
81128a78:	008001c4 	movi	r2,7
81128a7c:	14400e16 	blt	r2,r17,81128ab8 <___vfprintf_internal_r+0x1124>
81128a80:	b2000204 	addi	r8,r22,8
81128a84:	003e3a06 	br	81128370 <__reset+0xfb108370>
81128a88:	01204574 	movhi	r4,33045
81128a8c:	210a9c84 	addi	r4,r4,10866
81128a90:	d9002b15 	stw	r4,172(sp)
81128a94:	d9002b17 	ldw	r4,172(sp)
81128a98:	1c07883a 	add	r3,r3,r16
81128a9c:	44000115 	stw	r16,4(r8)
81128aa0:	41000015 	stw	r4,0(r8)
81128aa4:	10800044 	addi	r2,r2,1
81128aa8:	d8c02015 	stw	r3,128(sp)
81128aac:	d8801f15 	stw	r2,124(sp)
81128ab0:	010001c4 	movi	r4,7
81128ab4:	20be2d0e 	bge	r4,r2,8112836c <__reset+0xfb10836c>
81128ab8:	d9002c17 	ldw	r4,176(sp)
81128abc:	d9801e04 	addi	r6,sp,120
81128ac0:	b80b883a 	mov	r5,r23
81128ac4:	113389c0 	call	8113389c <__sprint_r>
81128ac8:	103cb61e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128acc:	d8c02017 	ldw	r3,128(sp)
81128ad0:	da000404 	addi	r8,sp,16
81128ad4:	003e2606 	br	81128370 <__reset+0xfb108370>
81128ad8:	d9002c17 	ldw	r4,176(sp)
81128adc:	d9801e04 	addi	r6,sp,120
81128ae0:	b80b883a 	mov	r5,r23
81128ae4:	113389c0 	call	8113389c <__sprint_r>
81128ae8:	103e5d26 	beq	r2,zero,81128460 <__reset+0xfb108460>
81128aec:	003cad06 	br	81127da4 <__reset+0xfb107da4>
81128af0:	d9002c17 	ldw	r4,176(sp)
81128af4:	d9801e04 	addi	r6,sp,120
81128af8:	b80b883a 	mov	r5,r23
81128afc:	113389c0 	call	8113389c <__sprint_r>
81128b00:	103ca81e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128b04:	d8c02017 	ldw	r3,128(sp)
81128b08:	da000404 	addi	r8,sp,16
81128b0c:	003e0b06 	br	8112833c <__reset+0xfb10833c>
81128b10:	d9002c17 	ldw	r4,176(sp)
81128b14:	d9801e04 	addi	r6,sp,120
81128b18:	b80b883a 	mov	r5,r23
81128b1c:	113389c0 	call	8113389c <__sprint_r>
81128b20:	103ca01e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128b24:	d8c02017 	ldw	r3,128(sp)
81128b28:	da000404 	addi	r8,sp,16
81128b2c:	003dbd06 	br	81128224 <__reset+0xfb108224>
81128b30:	d9002c17 	ldw	r4,176(sp)
81128b34:	d9801e04 	addi	r6,sp,120
81128b38:	b80b883a 	mov	r5,r23
81128b3c:	113389c0 	call	8113389c <__sprint_r>
81128b40:	103c981e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128b44:	d8c02017 	ldw	r3,128(sp)
81128b48:	da000404 	addi	r8,sp,16
81128b4c:	003dc306 	br	8112825c <__reset+0xfb10825c>
81128b50:	d8802917 	ldw	r2,164(sp)
81128b54:	d8002785 	stb	zero,158(sp)
81128b58:	103f0616 	blt	r2,zero,81128774 <__reset+0xfb108774>
81128b5c:	00ffdfc4 	movi	r3,-129
81128b60:	9d84b03a 	or	r2,r19,r22
81128b64:	90e4703a 	and	r18,r18,r3
81128b68:	103c6b26 	beq	r2,zero,81127d18 <__reset+0xfb107d18>
81128b6c:	0039883a 	mov	fp,zero
81128b70:	003e7406 	br	81128544 <__reset+0xfb108544>
81128b74:	9080040c 	andi	r2,r18,16
81128b78:	1001b326 	beq	r2,zero,81129248 <___vfprintf_internal_r+0x18b4>
81128b7c:	d9002d17 	ldw	r4,180(sp)
81128b80:	d9402917 	ldw	r5,164(sp)
81128b84:	d8002785 	stb	zero,158(sp)
81128b88:	20800104 	addi	r2,r4,4
81128b8c:	24c00017 	ldw	r19,0(r4)
81128b90:	002d883a 	mov	r22,zero
81128b94:	2801b516 	blt	r5,zero,8112926c <___vfprintf_internal_r+0x18d8>
81128b98:	00ffdfc4 	movi	r3,-129
81128b9c:	d8802d15 	stw	r2,180(sp)
81128ba0:	90e4703a 	and	r18,r18,r3
81128ba4:	983d2726 	beq	r19,zero,81128044 <__reset+0xfb108044>
81128ba8:	0039883a 	mov	fp,zero
81128bac:	003d2a06 	br	81128058 <__reset+0xfb108058>
81128bb0:	dc402617 	ldw	r17,152(sp)
81128bb4:	0441d30e 	bge	zero,r17,81129304 <___vfprintf_internal_r+0x1970>
81128bb8:	dc403217 	ldw	r17,200(sp)
81128bbc:	d8803317 	ldw	r2,204(sp)
81128bc0:	1440010e 	bge	r2,r17,81128bc8 <___vfprintf_internal_r+0x1234>
81128bc4:	1023883a 	mov	r17,r2
81128bc8:	04400a0e 	bge	zero,r17,81128bf4 <___vfprintf_internal_r+0x1260>
81128bcc:	d8801f17 	ldw	r2,124(sp)
81128bd0:	1c47883a 	add	r3,r3,r17
81128bd4:	44000015 	stw	r16,0(r8)
81128bd8:	10800044 	addi	r2,r2,1
81128bdc:	44400115 	stw	r17,4(r8)
81128be0:	d8c02015 	stw	r3,128(sp)
81128be4:	d8801f15 	stw	r2,124(sp)
81128be8:	010001c4 	movi	r4,7
81128bec:	20826516 	blt	r4,r2,81129584 <___vfprintf_internal_r+0x1bf0>
81128bf0:	42000204 	addi	r8,r8,8
81128bf4:	88026116 	blt	r17,zero,8112957c <___vfprintf_internal_r+0x1be8>
81128bf8:	d9003217 	ldw	r4,200(sp)
81128bfc:	2463c83a 	sub	r17,r4,r17
81128c00:	04407b0e 	bge	zero,r17,81128df0 <___vfprintf_internal_r+0x145c>
81128c04:	05800404 	movi	r22,16
81128c08:	d8801f17 	ldw	r2,124(sp)
81128c0c:	b4419d0e 	bge	r22,r17,81129284 <___vfprintf_internal_r+0x18f0>
81128c10:	01204574 	movhi	r4,33045
81128c14:	210a9c84 	addi	r4,r4,10866
81128c18:	d9002b15 	stw	r4,172(sp)
81128c1c:	070001c4 	movi	fp,7
81128c20:	dcc02c17 	ldw	r19,176(sp)
81128c24:	00000306 	br	81128c34 <___vfprintf_internal_r+0x12a0>
81128c28:	42000204 	addi	r8,r8,8
81128c2c:	8c7ffc04 	addi	r17,r17,-16
81128c30:	b441970e 	bge	r22,r17,81129290 <___vfprintf_internal_r+0x18fc>
81128c34:	18c00404 	addi	r3,r3,16
81128c38:	10800044 	addi	r2,r2,1
81128c3c:	45000015 	stw	r20,0(r8)
81128c40:	45800115 	stw	r22,4(r8)
81128c44:	d8c02015 	stw	r3,128(sp)
81128c48:	d8801f15 	stw	r2,124(sp)
81128c4c:	e0bff60e 	bge	fp,r2,81128c28 <__reset+0xfb108c28>
81128c50:	d9801e04 	addi	r6,sp,120
81128c54:	b80b883a 	mov	r5,r23
81128c58:	9809883a 	mov	r4,r19
81128c5c:	113389c0 	call	8113389c <__sprint_r>
81128c60:	103c501e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128c64:	d8c02017 	ldw	r3,128(sp)
81128c68:	d8801f17 	ldw	r2,124(sp)
81128c6c:	da000404 	addi	r8,sp,16
81128c70:	003fee06 	br	81128c2c <__reset+0xfb108c2c>
81128c74:	d9002c17 	ldw	r4,176(sp)
81128c78:	d9801e04 	addi	r6,sp,120
81128c7c:	b80b883a 	mov	r5,r23
81128c80:	113389c0 	call	8113389c <__sprint_r>
81128c84:	103c471e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128c88:	d8c02017 	ldw	r3,128(sp)
81128c8c:	df002787 	ldb	fp,158(sp)
81128c90:	da000404 	addi	r8,sp,16
81128c94:	003d5606 	br	811281f0 <__reset+0xfb1081f0>
81128c98:	9080040c 	andi	r2,r18,16
81128c9c:	10016126 	beq	r2,zero,81129224 <___vfprintf_internal_r+0x1890>
81128ca0:	d8802d17 	ldw	r2,180(sp)
81128ca4:	14c00017 	ldw	r19,0(r2)
81128ca8:	10800104 	addi	r2,r2,4
81128cac:	d8802d15 	stw	r2,180(sp)
81128cb0:	982dd7fa 	srai	r22,r19,31
81128cb4:	b005883a 	mov	r2,r22
81128cb8:	003c8206 	br	81127ec4 <__reset+0xfb107ec4>
81128cbc:	9080040c 	andi	r2,r18,16
81128cc0:	10003526 	beq	r2,zero,81128d98 <___vfprintf_internal_r+0x1404>
81128cc4:	d9402d17 	ldw	r5,180(sp)
81128cc8:	d8c02917 	ldw	r3,164(sp)
81128ccc:	d8002785 	stb	zero,158(sp)
81128cd0:	28800104 	addi	r2,r5,4
81128cd4:	2cc00017 	ldw	r19,0(r5)
81128cd8:	002d883a 	mov	r22,zero
81128cdc:	18003716 	blt	r3,zero,81128dbc <___vfprintf_internal_r+0x1428>
81128ce0:	00ffdfc4 	movi	r3,-129
81128ce4:	d8802d15 	stw	r2,180(sp)
81128ce8:	90e4703a 	and	r18,r18,r3
81128cec:	0039883a 	mov	fp,zero
81128cf0:	983df326 	beq	r19,zero,811284c0 <__reset+0xfb1084c0>
81128cf4:	00800244 	movi	r2,9
81128cf8:	14fc7b36 	bltu	r2,r19,81127ee8 <__reset+0xfb107ee8>
81128cfc:	d8c02817 	ldw	r3,160(sp)
81128d00:	dc001dc4 	addi	r16,sp,119
81128d04:	9cc00c04 	addi	r19,r19,48
81128d08:	1c07c83a 	sub	r3,r3,r16
81128d0c:	dcc01dc5 	stb	r19,119(sp)
81128d10:	d8c02e15 	stw	r3,184(sp)
81128d14:	003ce806 	br	811280b8 <__reset+0xfb1080b8>
81128d18:	d8803317 	ldw	r2,204(sp)
81128d1c:	143fffc4 	addi	r16,r2,-1
81128d20:	043f4d0e 	bge	zero,r16,81128a58 <__reset+0xfb108a58>
81128d24:	07000404 	movi	fp,16
81128d28:	e400810e 	bge	fp,r16,81128f30 <___vfprintf_internal_r+0x159c>
81128d2c:	01604574 	movhi	r5,33045
81128d30:	294a9c84 	addi	r5,r5,10866
81128d34:	d9402b15 	stw	r5,172(sp)
81128d38:	01c001c4 	movi	r7,7
81128d3c:	dcc02c17 	ldw	r19,176(sp)
81128d40:	00000306 	br	81128d50 <___vfprintf_internal_r+0x13bc>
81128d44:	b5800204 	addi	r22,r22,8
81128d48:	843ffc04 	addi	r16,r16,-16
81128d4c:	e4007b0e 	bge	fp,r16,81128f3c <___vfprintf_internal_r+0x15a8>
81128d50:	18c00404 	addi	r3,r3,16
81128d54:	8c400044 	addi	r17,r17,1
81128d58:	b5000015 	stw	r20,0(r22)
81128d5c:	b7000115 	stw	fp,4(r22)
81128d60:	d8c02015 	stw	r3,128(sp)
81128d64:	dc401f15 	stw	r17,124(sp)
81128d68:	3c7ff60e 	bge	r7,r17,81128d44 <__reset+0xfb108d44>
81128d6c:	d9801e04 	addi	r6,sp,120
81128d70:	b80b883a 	mov	r5,r23
81128d74:	9809883a 	mov	r4,r19
81128d78:	d9c03c15 	stw	r7,240(sp)
81128d7c:	113389c0 	call	8113389c <__sprint_r>
81128d80:	d9c03c17 	ldw	r7,240(sp)
81128d84:	103c071e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128d88:	d8c02017 	ldw	r3,128(sp)
81128d8c:	dc401f17 	ldw	r17,124(sp)
81128d90:	dd800404 	addi	r22,sp,16
81128d94:	003fec06 	br	81128d48 <__reset+0xfb108d48>
81128d98:	9080100c 	andi	r2,r18,64
81128d9c:	d8002785 	stb	zero,158(sp)
81128da0:	10010e26 	beq	r2,zero,811291dc <___vfprintf_internal_r+0x1848>
81128da4:	d9002d17 	ldw	r4,180(sp)
81128da8:	d9402917 	ldw	r5,164(sp)
81128dac:	002d883a 	mov	r22,zero
81128db0:	20800104 	addi	r2,r4,4
81128db4:	24c0000b 	ldhu	r19,0(r4)
81128db8:	283fc90e 	bge	r5,zero,81128ce0 <__reset+0xfb108ce0>
81128dbc:	d8802d15 	stw	r2,180(sp)
81128dc0:	0039883a 	mov	fp,zero
81128dc4:	9d84b03a 	or	r2,r19,r22
81128dc8:	103c461e 	bne	r2,zero,81127ee4 <__reset+0xfb107ee4>
81128dcc:	00800044 	movi	r2,1
81128dd0:	003e6c06 	br	81128784 <__reset+0xfb108784>
81128dd4:	d9002c17 	ldw	r4,176(sp)
81128dd8:	d9801e04 	addi	r6,sp,120
81128ddc:	b80b883a 	mov	r5,r23
81128de0:	113389c0 	call	8113389c <__sprint_r>
81128de4:	103bef1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128de8:	d8c02017 	ldw	r3,128(sp)
81128dec:	da000404 	addi	r8,sp,16
81128df0:	d9003217 	ldw	r4,200(sp)
81128df4:	d8802617 	ldw	r2,152(sp)
81128df8:	d9403317 	ldw	r5,204(sp)
81128dfc:	8123883a 	add	r17,r16,r4
81128e00:	11400216 	blt	r2,r5,81128e0c <___vfprintf_internal_r+0x1478>
81128e04:	9100004c 	andi	r4,r18,1
81128e08:	20000d26 	beq	r4,zero,81128e40 <___vfprintf_internal_r+0x14ac>
81128e0c:	d9003717 	ldw	r4,220(sp)
81128e10:	d9403417 	ldw	r5,208(sp)
81128e14:	1907883a 	add	r3,r3,r4
81128e18:	d9001f17 	ldw	r4,124(sp)
81128e1c:	41400015 	stw	r5,0(r8)
81128e20:	d9403717 	ldw	r5,220(sp)
81128e24:	21000044 	addi	r4,r4,1
81128e28:	d8c02015 	stw	r3,128(sp)
81128e2c:	41400115 	stw	r5,4(r8)
81128e30:	d9001f15 	stw	r4,124(sp)
81128e34:	014001c4 	movi	r5,7
81128e38:	2901e816 	blt	r5,r4,811295dc <___vfprintf_internal_r+0x1c48>
81128e3c:	42000204 	addi	r8,r8,8
81128e40:	d9003317 	ldw	r4,204(sp)
81128e44:	8121883a 	add	r16,r16,r4
81128e48:	2085c83a 	sub	r2,r4,r2
81128e4c:	8461c83a 	sub	r16,r16,r17
81128e50:	1400010e 	bge	r2,r16,81128e58 <___vfprintf_internal_r+0x14c4>
81128e54:	1021883a 	mov	r16,r2
81128e58:	04000a0e 	bge	zero,r16,81128e84 <___vfprintf_internal_r+0x14f0>
81128e5c:	d9001f17 	ldw	r4,124(sp)
81128e60:	1c07883a 	add	r3,r3,r16
81128e64:	44400015 	stw	r17,0(r8)
81128e68:	21000044 	addi	r4,r4,1
81128e6c:	44000115 	stw	r16,4(r8)
81128e70:	d8c02015 	stw	r3,128(sp)
81128e74:	d9001f15 	stw	r4,124(sp)
81128e78:	014001c4 	movi	r5,7
81128e7c:	2901fb16 	blt	r5,r4,8112966c <___vfprintf_internal_r+0x1cd8>
81128e80:	42000204 	addi	r8,r8,8
81128e84:	8001f716 	blt	r16,zero,81129664 <___vfprintf_internal_r+0x1cd0>
81128e88:	1421c83a 	sub	r16,r2,r16
81128e8c:	043d380e 	bge	zero,r16,81128370 <__reset+0xfb108370>
81128e90:	04400404 	movi	r17,16
81128e94:	d8801f17 	ldw	r2,124(sp)
81128e98:	8c3efb0e 	bge	r17,r16,81128a88 <__reset+0xfb108a88>
81128e9c:	01604574 	movhi	r5,33045
81128ea0:	294a9c84 	addi	r5,r5,10866
81128ea4:	d9402b15 	stw	r5,172(sp)
81128ea8:	058001c4 	movi	r22,7
81128eac:	dcc02c17 	ldw	r19,176(sp)
81128eb0:	00000306 	br	81128ec0 <___vfprintf_internal_r+0x152c>
81128eb4:	42000204 	addi	r8,r8,8
81128eb8:	843ffc04 	addi	r16,r16,-16
81128ebc:	8c3ef50e 	bge	r17,r16,81128a94 <__reset+0xfb108a94>
81128ec0:	18c00404 	addi	r3,r3,16
81128ec4:	10800044 	addi	r2,r2,1
81128ec8:	45000015 	stw	r20,0(r8)
81128ecc:	44400115 	stw	r17,4(r8)
81128ed0:	d8c02015 	stw	r3,128(sp)
81128ed4:	d8801f15 	stw	r2,124(sp)
81128ed8:	b0bff60e 	bge	r22,r2,81128eb4 <__reset+0xfb108eb4>
81128edc:	d9801e04 	addi	r6,sp,120
81128ee0:	b80b883a 	mov	r5,r23
81128ee4:	9809883a 	mov	r4,r19
81128ee8:	113389c0 	call	8113389c <__sprint_r>
81128eec:	103bad1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128ef0:	d8c02017 	ldw	r3,128(sp)
81128ef4:	d8801f17 	ldw	r2,124(sp)
81128ef8:	da000404 	addi	r8,sp,16
81128efc:	003fee06 	br	81128eb8 <__reset+0xfb108eb8>
81128f00:	9088703a 	and	r4,r18,r2
81128f04:	203eab1e 	bne	r4,zero,811289b4 <__reset+0xfb1089b4>
81128f08:	dc401f17 	ldw	r17,124(sp)
81128f0c:	40800115 	stw	r2,4(r8)
81128f10:	44000015 	stw	r16,0(r8)
81128f14:	8c400044 	addi	r17,r17,1
81128f18:	d8c02015 	stw	r3,128(sp)
81128f1c:	dc401f15 	stw	r17,124(sp)
81128f20:	008001c4 	movi	r2,7
81128f24:	14400e16 	blt	r2,r17,81128f60 <___vfprintf_internal_r+0x15cc>
81128f28:	45800204 	addi	r22,r8,8
81128f2c:	003eca06 	br	81128a58 <__reset+0xfb108a58>
81128f30:	01204574 	movhi	r4,33045
81128f34:	210a9c84 	addi	r4,r4,10866
81128f38:	d9002b15 	stw	r4,172(sp)
81128f3c:	d8802b17 	ldw	r2,172(sp)
81128f40:	1c07883a 	add	r3,r3,r16
81128f44:	8c400044 	addi	r17,r17,1
81128f48:	b0800015 	stw	r2,0(r22)
81128f4c:	b4000115 	stw	r16,4(r22)
81128f50:	d8c02015 	stw	r3,128(sp)
81128f54:	dc401f15 	stw	r17,124(sp)
81128f58:	008001c4 	movi	r2,7
81128f5c:	147ebd0e 	bge	r2,r17,81128a54 <__reset+0xfb108a54>
81128f60:	d9002c17 	ldw	r4,176(sp)
81128f64:	d9801e04 	addi	r6,sp,120
81128f68:	b80b883a 	mov	r5,r23
81128f6c:	113389c0 	call	8113389c <__sprint_r>
81128f70:	103b8c1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128f74:	d8c02017 	ldw	r3,128(sp)
81128f78:	dc401f17 	ldw	r17,124(sp)
81128f7c:	dd800404 	addi	r22,sp,16
81128f80:	003eb506 	br	81128a58 <__reset+0xfb108a58>
81128f84:	d9002c17 	ldw	r4,176(sp)
81128f88:	d9801e04 	addi	r6,sp,120
81128f8c:	b80b883a 	mov	r5,r23
81128f90:	113389c0 	call	8113389c <__sprint_r>
81128f94:	103b831e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128f98:	d8c02017 	ldw	r3,128(sp)
81128f9c:	dc401f17 	ldw	r17,124(sp)
81128fa0:	da000404 	addi	r8,sp,16
81128fa4:	003e8d06 	br	811289dc <__reset+0xfb1089dc>
81128fa8:	d9002c17 	ldw	r4,176(sp)
81128fac:	d9801e04 	addi	r6,sp,120
81128fb0:	b80b883a 	mov	r5,r23
81128fb4:	113389c0 	call	8113389c <__sprint_r>
81128fb8:	103b7a1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128fbc:	d8c02017 	ldw	r3,128(sp)
81128fc0:	dc401f17 	ldw	r17,124(sp)
81128fc4:	dd800404 	addi	r22,sp,16
81128fc8:	003e8f06 	br	81128a08 <__reset+0xfb108a08>
81128fcc:	0027883a 	mov	r19,zero
81128fd0:	003f4a06 	br	81128cfc <__reset+0xfb108cfc>
81128fd4:	d9002c17 	ldw	r4,176(sp)
81128fd8:	d9801e04 	addi	r6,sp,120
81128fdc:	b80b883a 	mov	r5,r23
81128fe0:	113389c0 	call	8113389c <__sprint_r>
81128fe4:	103b6f1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81128fe8:	d8c02017 	ldw	r3,128(sp)
81128fec:	da000404 	addi	r8,sp,16
81128ff0:	003c9d06 	br	81128268 <__reset+0xfb108268>
81128ff4:	04e7c83a 	sub	r19,zero,r19
81128ff8:	9804c03a 	cmpne	r2,r19,zero
81128ffc:	05adc83a 	sub	r22,zero,r22
81129000:	b0adc83a 	sub	r22,r22,r2
81129004:	d8802917 	ldw	r2,164(sp)
81129008:	07000b44 	movi	fp,45
8112900c:	df002785 	stb	fp,158(sp)
81129010:	10017b16 	blt	r2,zero,81129600 <___vfprintf_internal_r+0x1c6c>
81129014:	00bfdfc4 	movi	r2,-129
81129018:	90a4703a 	and	r18,r18,r2
8112901c:	003bb106 	br	81127ee4 <__reset+0xfb107ee4>
81129020:	d9003617 	ldw	r4,216(sp)
81129024:	d9403817 	ldw	r5,224(sp)
81129028:	da003d15 	stw	r8,244(sp)
8112902c:	11301e80 	call	811301e8 <__fpclassifyd>
81129030:	da003d17 	ldw	r8,244(sp)
81129034:	1000f026 	beq	r2,zero,811293f8 <___vfprintf_internal_r+0x1a64>
81129038:	d9002917 	ldw	r4,164(sp)
8112903c:	05bff7c4 	movi	r22,-33
81129040:	00bfffc4 	movi	r2,-1
81129044:	8dac703a 	and	r22,r17,r22
81129048:	20820026 	beq	r4,r2,8112984c <___vfprintf_internal_r+0x1eb8>
8112904c:	008011c4 	movi	r2,71
81129050:	b081f726 	beq	r22,r2,81129830 <___vfprintf_internal_r+0x1e9c>
81129054:	d9003817 	ldw	r4,224(sp)
81129058:	90c04014 	ori	r3,r18,256
8112905c:	d8c02b15 	stw	r3,172(sp)
81129060:	20021516 	blt	r4,zero,811298b8 <___vfprintf_internal_r+0x1f24>
81129064:	dcc03817 	ldw	r19,224(sp)
81129068:	d8002a05 	stb	zero,168(sp)
8112906c:	00801984 	movi	r2,102
81129070:	8881f926 	beq	r17,r2,81129858 <___vfprintf_internal_r+0x1ec4>
81129074:	00801184 	movi	r2,70
81129078:	88821c26 	beq	r17,r2,811298ec <___vfprintf_internal_r+0x1f58>
8112907c:	00801144 	movi	r2,69
81129080:	b081ef26 	beq	r22,r2,81129840 <___vfprintf_internal_r+0x1eac>
81129084:	d8c02917 	ldw	r3,164(sp)
81129088:	d8802104 	addi	r2,sp,132
8112908c:	d8800315 	stw	r2,12(sp)
81129090:	d9403617 	ldw	r5,216(sp)
81129094:	d8802504 	addi	r2,sp,148
81129098:	d9002c17 	ldw	r4,176(sp)
8112909c:	d8800215 	stw	r2,8(sp)
811290a0:	d8802604 	addi	r2,sp,152
811290a4:	d8c00015 	stw	r3,0(sp)
811290a8:	d8800115 	stw	r2,4(sp)
811290ac:	01c00084 	movi	r7,2
811290b0:	980d883a 	mov	r6,r19
811290b4:	d8c03c15 	stw	r3,240(sp)
811290b8:	da003d15 	stw	r8,244(sp)
811290bc:	112baa00 	call	8112baa0 <_dtoa_r>
811290c0:	1021883a 	mov	r16,r2
811290c4:	008019c4 	movi	r2,103
811290c8:	d8c03c17 	ldw	r3,240(sp)
811290cc:	da003d17 	ldw	r8,244(sp)
811290d0:	88817126 	beq	r17,r2,81129698 <___vfprintf_internal_r+0x1d04>
811290d4:	008011c4 	movi	r2,71
811290d8:	88829226 	beq	r17,r2,81129b24 <___vfprintf_internal_r+0x2190>
811290dc:	80f9883a 	add	fp,r16,r3
811290e0:	d9003617 	ldw	r4,216(sp)
811290e4:	000d883a 	mov	r6,zero
811290e8:	000f883a 	mov	r7,zero
811290ec:	980b883a 	mov	r5,r19
811290f0:	da003d15 	stw	r8,244(sp)
811290f4:	11380680 	call	81138068 <__eqdf2>
811290f8:	da003d17 	ldw	r8,244(sp)
811290fc:	10018d26 	beq	r2,zero,81129734 <___vfprintf_internal_r+0x1da0>
81129100:	d8802117 	ldw	r2,132(sp)
81129104:	1700062e 	bgeu	r2,fp,81129120 <___vfprintf_internal_r+0x178c>
81129108:	01000c04 	movi	r4,48
8112910c:	10c00044 	addi	r3,r2,1
81129110:	d8c02115 	stw	r3,132(sp)
81129114:	11000005 	stb	r4,0(r2)
81129118:	d8802117 	ldw	r2,132(sp)
8112911c:	173ffb36 	bltu	r2,fp,8112910c <__reset+0xfb10910c>
81129120:	1405c83a 	sub	r2,r2,r16
81129124:	d8803315 	stw	r2,204(sp)
81129128:	008011c4 	movi	r2,71
8112912c:	b0817626 	beq	r22,r2,81129708 <___vfprintf_internal_r+0x1d74>
81129130:	00801944 	movi	r2,101
81129134:	1442810e 	bge	r2,r17,81129b3c <___vfprintf_internal_r+0x21a8>
81129138:	d8c02617 	ldw	r3,152(sp)
8112913c:	00801984 	movi	r2,102
81129140:	d8c03215 	stw	r3,200(sp)
81129144:	8881fe26 	beq	r17,r2,81129940 <___vfprintf_internal_r+0x1fac>
81129148:	d8c03217 	ldw	r3,200(sp)
8112914c:	d9003317 	ldw	r4,204(sp)
81129150:	1901dd16 	blt	r3,r4,811298c8 <___vfprintf_internal_r+0x1f34>
81129154:	9480004c 	andi	r18,r18,1
81129158:	90022b1e 	bne	r18,zero,81129a08 <___vfprintf_internal_r+0x2074>
8112915c:	1805883a 	mov	r2,r3
81129160:	18028016 	blt	r3,zero,81129b64 <___vfprintf_internal_r+0x21d0>
81129164:	d8c03217 	ldw	r3,200(sp)
81129168:	044019c4 	movi	r17,103
8112916c:	d8c02e15 	stw	r3,184(sp)
81129170:	df002a07 	ldb	fp,168(sp)
81129174:	e001531e 	bne	fp,zero,811296c4 <___vfprintf_internal_r+0x1d30>
81129178:	df002783 	ldbu	fp,158(sp)
8112917c:	d8802a15 	stw	r2,168(sp)
81129180:	dc802b17 	ldw	r18,172(sp)
81129184:	d8002915 	stw	zero,164(sp)
81129188:	003bd106 	br	811280d0 <__reset+0xfb1080d0>
8112918c:	d8802d17 	ldw	r2,180(sp)
81129190:	d8c02d17 	ldw	r3,180(sp)
81129194:	d9002d17 	ldw	r4,180(sp)
81129198:	10800017 	ldw	r2,0(r2)
8112919c:	18c00117 	ldw	r3,4(r3)
811291a0:	21000204 	addi	r4,r4,8
811291a4:	d8803615 	stw	r2,216(sp)
811291a8:	d8c03815 	stw	r3,224(sp)
811291ac:	d9002d15 	stw	r4,180(sp)
811291b0:	003b7506 	br	81127f88 <__reset+0xfb107f88>
811291b4:	ac400007 	ldb	r17,0(r21)
811291b8:	003a5906 	br	81127b20 <__reset+0xfb107b20>
811291bc:	9080100c 	andi	r2,r18,64
811291c0:	1000a826 	beq	r2,zero,81129464 <___vfprintf_internal_r+0x1ad0>
811291c4:	d9002d17 	ldw	r4,180(sp)
811291c8:	002d883a 	mov	r22,zero
811291cc:	24c0000b 	ldhu	r19,0(r4)
811291d0:	21000104 	addi	r4,r4,4
811291d4:	d9002d15 	stw	r4,180(sp)
811291d8:	003ccb06 	br	81128508 <__reset+0xfb108508>
811291dc:	d8c02d17 	ldw	r3,180(sp)
811291e0:	d9002917 	ldw	r4,164(sp)
811291e4:	002d883a 	mov	r22,zero
811291e8:	18800104 	addi	r2,r3,4
811291ec:	1cc00017 	ldw	r19,0(r3)
811291f0:	203ebb0e 	bge	r4,zero,81128ce0 <__reset+0xfb108ce0>
811291f4:	003ef106 	br	81128dbc <__reset+0xfb108dbc>
811291f8:	9080040c 	andi	r2,r18,16
811291fc:	1000921e 	bne	r2,zero,81129448 <___vfprintf_internal_r+0x1ab4>
81129200:	9480100c 	andi	r18,r18,64
81129204:	90013926 	beq	r18,zero,811296ec <___vfprintf_internal_r+0x1d58>
81129208:	d9002d17 	ldw	r4,180(sp)
8112920c:	d9402f17 	ldw	r5,188(sp)
81129210:	20800017 	ldw	r2,0(r4)
81129214:	21000104 	addi	r4,r4,4
81129218:	d9002d15 	stw	r4,180(sp)
8112921c:	1140000d 	sth	r5,0(r2)
81129220:	003a1606 	br	81127a7c <__reset+0xfb107a7c>
81129224:	9080100c 	andi	r2,r18,64
81129228:	10008026 	beq	r2,zero,8112942c <___vfprintf_internal_r+0x1a98>
8112922c:	d8c02d17 	ldw	r3,180(sp)
81129230:	1cc0000f 	ldh	r19,0(r3)
81129234:	18c00104 	addi	r3,r3,4
81129238:	d8c02d15 	stw	r3,180(sp)
8112923c:	982dd7fa 	srai	r22,r19,31
81129240:	b005883a 	mov	r2,r22
81129244:	003b1f06 	br	81127ec4 <__reset+0xfb107ec4>
81129248:	9080100c 	andi	r2,r18,64
8112924c:	d8002785 	stb	zero,158(sp)
81129250:	10008a1e 	bne	r2,zero,8112947c <___vfprintf_internal_r+0x1ae8>
81129254:	d9402d17 	ldw	r5,180(sp)
81129258:	d8c02917 	ldw	r3,164(sp)
8112925c:	002d883a 	mov	r22,zero
81129260:	28800104 	addi	r2,r5,4
81129264:	2cc00017 	ldw	r19,0(r5)
81129268:	183e4b0e 	bge	r3,zero,81128b98 <__reset+0xfb108b98>
8112926c:	9d86b03a 	or	r3,r19,r22
81129270:	d8802d15 	stw	r2,180(sp)
81129274:	183e4c1e 	bne	r3,zero,81128ba8 <__reset+0xfb108ba8>
81129278:	0039883a 	mov	fp,zero
8112927c:	0005883a 	mov	r2,zero
81129280:	003d4006 	br	81128784 <__reset+0xfb108784>
81129284:	01604574 	movhi	r5,33045
81129288:	294a9c84 	addi	r5,r5,10866
8112928c:	d9402b15 	stw	r5,172(sp)
81129290:	d9402b17 	ldw	r5,172(sp)
81129294:	1c47883a 	add	r3,r3,r17
81129298:	10800044 	addi	r2,r2,1
8112929c:	41400015 	stw	r5,0(r8)
811292a0:	44400115 	stw	r17,4(r8)
811292a4:	d8c02015 	stw	r3,128(sp)
811292a8:	d8801f15 	stw	r2,124(sp)
811292ac:	010001c4 	movi	r4,7
811292b0:	20bec816 	blt	r4,r2,81128dd4 <__reset+0xfb108dd4>
811292b4:	42000204 	addi	r8,r8,8
811292b8:	003ecd06 	br	81128df0 <__reset+0xfb108df0>
811292bc:	d9002917 	ldw	r4,164(sp)
811292c0:	d8002785 	stb	zero,158(sp)
811292c4:	203d2d16 	blt	r4,zero,8112877c <__reset+0xfb10877c>
811292c8:	00bfdfc4 	movi	r2,-129
811292cc:	90a4703a 	and	r18,r18,r2
811292d0:	003a9106 	br	81127d18 <__reset+0xfb107d18>
811292d4:	01204574 	movhi	r4,33045
811292d8:	210a9c84 	addi	r4,r4,10866
811292dc:	d9002b15 	stw	r4,172(sp)
811292e0:	003c0c06 	br	81128314 <__reset+0xfb108314>
811292e4:	d9002c17 	ldw	r4,176(sp)
811292e8:	d9801e04 	addi	r6,sp,120
811292ec:	b80b883a 	mov	r5,r23
811292f0:	113389c0 	call	8113389c <__sprint_r>
811292f4:	103aab1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811292f8:	d8c02017 	ldw	r3,128(sp)
811292fc:	da000404 	addi	r8,sp,16
81129300:	003d4106 	br	81128808 <__reset+0xfb108808>
81129304:	d8801f17 	ldw	r2,124(sp)
81129308:	01604574 	movhi	r5,33045
8112930c:	01000044 	movi	r4,1
81129310:	18c00044 	addi	r3,r3,1
81129314:	10800044 	addi	r2,r2,1
81129318:	294a9404 	addi	r5,r5,10832
8112931c:	41000115 	stw	r4,4(r8)
81129320:	41400015 	stw	r5,0(r8)
81129324:	d8c02015 	stw	r3,128(sp)
81129328:	d8801f15 	stw	r2,124(sp)
8112932c:	010001c4 	movi	r4,7
81129330:	20805c16 	blt	r4,r2,811294a4 <___vfprintf_internal_r+0x1b10>
81129334:	42000204 	addi	r8,r8,8
81129338:	8800041e 	bne	r17,zero,8112934c <___vfprintf_internal_r+0x19b8>
8112933c:	d8803317 	ldw	r2,204(sp)
81129340:	1000021e 	bne	r2,zero,8112934c <___vfprintf_internal_r+0x19b8>
81129344:	9080004c 	andi	r2,r18,1
81129348:	103c0926 	beq	r2,zero,81128370 <__reset+0xfb108370>
8112934c:	d9003717 	ldw	r4,220(sp)
81129350:	d8801f17 	ldw	r2,124(sp)
81129354:	d9403417 	ldw	r5,208(sp)
81129358:	20c7883a 	add	r3,r4,r3
8112935c:	10800044 	addi	r2,r2,1
81129360:	41000115 	stw	r4,4(r8)
81129364:	41400015 	stw	r5,0(r8)
81129368:	d8c02015 	stw	r3,128(sp)
8112936c:	d8801f15 	stw	r2,124(sp)
81129370:	010001c4 	movi	r4,7
81129374:	20812116 	blt	r4,r2,811297fc <___vfprintf_internal_r+0x1e68>
81129378:	42000204 	addi	r8,r8,8
8112937c:	0463c83a 	sub	r17,zero,r17
81129380:	0440730e 	bge	zero,r17,81129550 <___vfprintf_internal_r+0x1bbc>
81129384:	05800404 	movi	r22,16
81129388:	b440860e 	bge	r22,r17,811295a4 <___vfprintf_internal_r+0x1c10>
8112938c:	01604574 	movhi	r5,33045
81129390:	294a9c84 	addi	r5,r5,10866
81129394:	d9402b15 	stw	r5,172(sp)
81129398:	070001c4 	movi	fp,7
8112939c:	dcc02c17 	ldw	r19,176(sp)
811293a0:	00000306 	br	811293b0 <___vfprintf_internal_r+0x1a1c>
811293a4:	42000204 	addi	r8,r8,8
811293a8:	8c7ffc04 	addi	r17,r17,-16
811293ac:	b440800e 	bge	r22,r17,811295b0 <___vfprintf_internal_r+0x1c1c>
811293b0:	18c00404 	addi	r3,r3,16
811293b4:	10800044 	addi	r2,r2,1
811293b8:	45000015 	stw	r20,0(r8)
811293bc:	45800115 	stw	r22,4(r8)
811293c0:	d8c02015 	stw	r3,128(sp)
811293c4:	d8801f15 	stw	r2,124(sp)
811293c8:	e0bff60e 	bge	fp,r2,811293a4 <__reset+0xfb1093a4>
811293cc:	d9801e04 	addi	r6,sp,120
811293d0:	b80b883a 	mov	r5,r23
811293d4:	9809883a 	mov	r4,r19
811293d8:	113389c0 	call	8113389c <__sprint_r>
811293dc:	103a711e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811293e0:	d8c02017 	ldw	r3,128(sp)
811293e4:	d8801f17 	ldw	r2,124(sp)
811293e8:	da000404 	addi	r8,sp,16
811293ec:	003fee06 	br	811293a8 <__reset+0xfb1093a8>
811293f0:	00bfffc4 	movi	r2,-1
811293f4:	003a6f06 	br	81127db4 <__reset+0xfb107db4>
811293f8:	008011c4 	movi	r2,71
811293fc:	1440b816 	blt	r2,r17,811296e0 <___vfprintf_internal_r+0x1d4c>
81129400:	04204574 	movhi	r16,33045
81129404:	840a8604 	addi	r16,r16,10776
81129408:	00c000c4 	movi	r3,3
8112940c:	00bfdfc4 	movi	r2,-129
81129410:	d8c02a15 	stw	r3,168(sp)
81129414:	90a4703a 	and	r18,r18,r2
81129418:	df002783 	ldbu	fp,158(sp)
8112941c:	d8c02e15 	stw	r3,184(sp)
81129420:	d8002915 	stw	zero,164(sp)
81129424:	d8003215 	stw	zero,200(sp)
81129428:	003b2906 	br	811280d0 <__reset+0xfb1080d0>
8112942c:	d9002d17 	ldw	r4,180(sp)
81129430:	24c00017 	ldw	r19,0(r4)
81129434:	21000104 	addi	r4,r4,4
81129438:	d9002d15 	stw	r4,180(sp)
8112943c:	982dd7fa 	srai	r22,r19,31
81129440:	b005883a 	mov	r2,r22
81129444:	003a9f06 	br	81127ec4 <__reset+0xfb107ec4>
81129448:	d9402d17 	ldw	r5,180(sp)
8112944c:	d8c02f17 	ldw	r3,188(sp)
81129450:	28800017 	ldw	r2,0(r5)
81129454:	29400104 	addi	r5,r5,4
81129458:	d9402d15 	stw	r5,180(sp)
8112945c:	10c00015 	stw	r3,0(r2)
81129460:	00398606 	br	81127a7c <__reset+0xfb107a7c>
81129464:	d9402d17 	ldw	r5,180(sp)
81129468:	002d883a 	mov	r22,zero
8112946c:	2cc00017 	ldw	r19,0(r5)
81129470:	29400104 	addi	r5,r5,4
81129474:	d9402d15 	stw	r5,180(sp)
81129478:	003c2306 	br	81128508 <__reset+0xfb108508>
8112947c:	d8c02d17 	ldw	r3,180(sp)
81129480:	d9002917 	ldw	r4,164(sp)
81129484:	002d883a 	mov	r22,zero
81129488:	18800104 	addi	r2,r3,4
8112948c:	1cc0000b 	ldhu	r19,0(r3)
81129490:	203dc10e 	bge	r4,zero,81128b98 <__reset+0xfb108b98>
81129494:	003f7506 	br	8112926c <__reset+0xfb10926c>
81129498:	04204574 	movhi	r16,33045
8112949c:	840a8404 	addi	r16,r16,10768
811294a0:	003acc06 	br	81127fd4 <__reset+0xfb107fd4>
811294a4:	d9002c17 	ldw	r4,176(sp)
811294a8:	d9801e04 	addi	r6,sp,120
811294ac:	b80b883a 	mov	r5,r23
811294b0:	113389c0 	call	8113389c <__sprint_r>
811294b4:	103a3b1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811294b8:	dc402617 	ldw	r17,152(sp)
811294bc:	d8c02017 	ldw	r3,128(sp)
811294c0:	da000404 	addi	r8,sp,16
811294c4:	003f9c06 	br	81129338 <__reset+0xfb109338>
811294c8:	ac400043 	ldbu	r17,1(r21)
811294cc:	94800814 	ori	r18,r18,32
811294d0:	ad400044 	addi	r21,r21,1
811294d4:	8c403fcc 	andi	r17,r17,255
811294d8:	8c40201c 	xori	r17,r17,128
811294dc:	8c7fe004 	addi	r17,r17,-128
811294e0:	00398f06 	br	81127b20 <__reset+0xfb107b20>
811294e4:	d8c02d15 	stw	r3,180(sp)
811294e8:	0039883a 	mov	fp,zero
811294ec:	003e3506 	br	81128dc4 <__reset+0xfb108dc4>
811294f0:	d9002c17 	ldw	r4,176(sp)
811294f4:	d9801e04 	addi	r6,sp,120
811294f8:	b80b883a 	mov	r5,r23
811294fc:	113389c0 	call	8113389c <__sprint_r>
81129500:	103a281e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81129504:	d8c02017 	ldw	r3,128(sp)
81129508:	da000404 	addi	r8,sp,16
8112950c:	003cd006 	br	81128850 <__reset+0xfb108850>
81129510:	8009883a 	mov	r4,r16
81129514:	da003d15 	stw	r8,244(sp)
81129518:	11251780 	call	81125178 <strlen>
8112951c:	d8802e15 	stw	r2,184(sp)
81129520:	da003d17 	ldw	r8,244(sp)
81129524:	103c340e 	bge	r2,zero,811285f8 <__reset+0xfb1085f8>
81129528:	0005883a 	mov	r2,zero
8112952c:	003c3206 	br	811285f8 <__reset+0xfb1085f8>
81129530:	d9002c17 	ldw	r4,176(sp)
81129534:	d9801e04 	addi	r6,sp,120
81129538:	b80b883a 	mov	r5,r23
8112953c:	113389c0 	call	8113389c <__sprint_r>
81129540:	103a181e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81129544:	d8c02017 	ldw	r3,128(sp)
81129548:	d8801f17 	ldw	r2,124(sp)
8112954c:	da000404 	addi	r8,sp,16
81129550:	d9403317 	ldw	r5,204(sp)
81129554:	10800044 	addi	r2,r2,1
81129558:	44000015 	stw	r16,0(r8)
8112955c:	28c7883a 	add	r3,r5,r3
81129560:	003b7d06 	br	81128358 <__reset+0xfb108358>
81129564:	01204574 	movhi	r4,33045
81129568:	210aa084 	addi	r4,r4,10882
8112956c:	d9003515 	stw	r4,212(sp)
81129570:	003b1406 	br	811281c4 <__reset+0xfb1081c4>
81129574:	013fffc4 	movi	r4,-1
81129578:	003a3506 	br	81127e50 <__reset+0xfb107e50>
8112957c:	0023883a 	mov	r17,zero
81129580:	003d9d06 	br	81128bf8 <__reset+0xfb108bf8>
81129584:	d9002c17 	ldw	r4,176(sp)
81129588:	d9801e04 	addi	r6,sp,120
8112958c:	b80b883a 	mov	r5,r23
81129590:	113389c0 	call	8113389c <__sprint_r>
81129594:	103a031e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81129598:	d8c02017 	ldw	r3,128(sp)
8112959c:	da000404 	addi	r8,sp,16
811295a0:	003d9406 	br	81128bf4 <__reset+0xfb108bf4>
811295a4:	01204574 	movhi	r4,33045
811295a8:	210a9c84 	addi	r4,r4,10866
811295ac:	d9002b15 	stw	r4,172(sp)
811295b0:	d9002b17 	ldw	r4,172(sp)
811295b4:	1c47883a 	add	r3,r3,r17
811295b8:	10800044 	addi	r2,r2,1
811295bc:	41000015 	stw	r4,0(r8)
811295c0:	44400115 	stw	r17,4(r8)
811295c4:	d8c02015 	stw	r3,128(sp)
811295c8:	d8801f15 	stw	r2,124(sp)
811295cc:	010001c4 	movi	r4,7
811295d0:	20bfd716 	blt	r4,r2,81129530 <__reset+0xfb109530>
811295d4:	42000204 	addi	r8,r8,8
811295d8:	003fdd06 	br	81129550 <__reset+0xfb109550>
811295dc:	d9002c17 	ldw	r4,176(sp)
811295e0:	d9801e04 	addi	r6,sp,120
811295e4:	b80b883a 	mov	r5,r23
811295e8:	113389c0 	call	8113389c <__sprint_r>
811295ec:	1039ed1e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
811295f0:	d8802617 	ldw	r2,152(sp)
811295f4:	d8c02017 	ldw	r3,128(sp)
811295f8:	da000404 	addi	r8,sp,16
811295fc:	003e1006 	br	81128e40 <__reset+0xfb108e40>
81129600:	00800044 	movi	r2,1
81129604:	10803fcc 	andi	r2,r2,255
81129608:	00c00044 	movi	r3,1
8112960c:	10fa3526 	beq	r2,r3,81127ee4 <__reset+0xfb107ee4>
81129610:	00c00084 	movi	r3,2
81129614:	10fbcb26 	beq	r2,r3,81128544 <__reset+0xfb108544>
81129618:	003a8f06 	br	81128058 <__reset+0xfb108058>
8112961c:	01204574 	movhi	r4,33045
81129620:	210aa084 	addi	r4,r4,10882
81129624:	d9003515 	stw	r4,212(sp)
81129628:	003b7606 	br	81128404 <__reset+0xfb108404>
8112962c:	d8802917 	ldw	r2,164(sp)
81129630:	00c00184 	movi	r3,6
81129634:	1880012e 	bgeu	r3,r2,8112963c <___vfprintf_internal_r+0x1ca8>
81129638:	1805883a 	mov	r2,r3
8112963c:	d8802e15 	stw	r2,184(sp)
81129640:	1000ef16 	blt	r2,zero,81129a00 <___vfprintf_internal_r+0x206c>
81129644:	04204574 	movhi	r16,33045
81129648:	d8802a15 	stw	r2,168(sp)
8112964c:	dcc02d15 	stw	r19,180(sp)
81129650:	d8002915 	stw	zero,164(sp)
81129654:	d8003215 	stw	zero,200(sp)
81129658:	840a9204 	addi	r16,r16,10824
8112965c:	0039883a 	mov	fp,zero
81129660:	003aa206 	br	811280ec <__reset+0xfb1080ec>
81129664:	0021883a 	mov	r16,zero
81129668:	003e0706 	br	81128e88 <__reset+0xfb108e88>
8112966c:	d9002c17 	ldw	r4,176(sp)
81129670:	d9801e04 	addi	r6,sp,120
81129674:	b80b883a 	mov	r5,r23
81129678:	113389c0 	call	8113389c <__sprint_r>
8112967c:	1039c91e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81129680:	d8802617 	ldw	r2,152(sp)
81129684:	d9403317 	ldw	r5,204(sp)
81129688:	d8c02017 	ldw	r3,128(sp)
8112968c:	da000404 	addi	r8,sp,16
81129690:	2885c83a 	sub	r2,r5,r2
81129694:	003dfb06 	br	81128e84 <__reset+0xfb108e84>
81129698:	9080004c 	andi	r2,r18,1
8112969c:	103e8f1e 	bne	r2,zero,811290dc <__reset+0xfb1090dc>
811296a0:	d8802117 	ldw	r2,132(sp)
811296a4:	003e9e06 	br	81129120 <__reset+0xfb109120>
811296a8:	1025883a 	mov	r18,r2
811296ac:	0039883a 	mov	fp,zero
811296b0:	00800084 	movi	r2,2
811296b4:	003fd306 	br	81129604 <__reset+0xfb109604>
811296b8:	07000b44 	movi	fp,45
811296bc:	df002785 	stb	fp,158(sp)
811296c0:	003a4006 	br	81127fc4 <__reset+0xfb107fc4>
811296c4:	00c00b44 	movi	r3,45
811296c8:	d8c02785 	stb	r3,158(sp)
811296cc:	d8802a15 	stw	r2,168(sp)
811296d0:	dc802b17 	ldw	r18,172(sp)
811296d4:	d8002915 	stw	zero,164(sp)
811296d8:	07000b44 	movi	fp,45
811296dc:	003a8006 	br	811280e0 <__reset+0xfb1080e0>
811296e0:	04204574 	movhi	r16,33045
811296e4:	840a8704 	addi	r16,r16,10780
811296e8:	003f4706 	br	81129408 <__reset+0xfb109408>
811296ec:	d8c02d17 	ldw	r3,180(sp)
811296f0:	d9002f17 	ldw	r4,188(sp)
811296f4:	18800017 	ldw	r2,0(r3)
811296f8:	18c00104 	addi	r3,r3,4
811296fc:	d8c02d15 	stw	r3,180(sp)
81129700:	11000015 	stw	r4,0(r2)
81129704:	0038dd06 	br	81127a7c <__reset+0xfb107a7c>
81129708:	dd802617 	ldw	r22,152(sp)
8112970c:	00bfff44 	movi	r2,-3
81129710:	b0801c16 	blt	r22,r2,81129784 <___vfprintf_internal_r+0x1df0>
81129714:	d9402917 	ldw	r5,164(sp)
81129718:	2d801a16 	blt	r5,r22,81129784 <___vfprintf_internal_r+0x1df0>
8112971c:	dd803215 	stw	r22,200(sp)
81129720:	003e8906 	br	81129148 <__reset+0xfb109148>
81129724:	01204574 	movhi	r4,33045
81129728:	210a9c84 	addi	r4,r4,10866
8112972c:	d9002b15 	stw	r4,172(sp)
81129730:	003c9106 	br	81128978 <__reset+0xfb108978>
81129734:	e005883a 	mov	r2,fp
81129738:	003e7906 	br	81129120 <__reset+0xfb109120>
8112973c:	d9402917 	ldw	r5,164(sp)
81129740:	df002783 	ldbu	fp,158(sp)
81129744:	dcc02d15 	stw	r19,180(sp)
81129748:	d9402a15 	stw	r5,168(sp)
8112974c:	d9402e15 	stw	r5,184(sp)
81129750:	d8002915 	stw	zero,164(sp)
81129754:	d8003215 	stw	zero,200(sp)
81129758:	003a5d06 	br	811280d0 <__reset+0xfb1080d0>
8112975c:	9080004c 	andi	r2,r18,1
81129760:	0039883a 	mov	fp,zero
81129764:	10000426 	beq	r2,zero,81129778 <___vfprintf_internal_r+0x1de4>
81129768:	00800c04 	movi	r2,48
8112976c:	dc001dc4 	addi	r16,sp,119
81129770:	d8801dc5 	stb	r2,119(sp)
81129774:	003b8006 	br	81128578 <__reset+0xfb108578>
81129778:	d8002e15 	stw	zero,184(sp)
8112977c:	dc001e04 	addi	r16,sp,120
81129780:	003a4d06 	br	811280b8 <__reset+0xfb1080b8>
81129784:	8c7fff84 	addi	r17,r17,-2
81129788:	b5bfffc4 	addi	r22,r22,-1
8112978c:	dd802615 	stw	r22,152(sp)
81129790:	dc4022c5 	stb	r17,139(sp)
81129794:	b000bf16 	blt	r22,zero,81129a94 <___vfprintf_internal_r+0x2100>
81129798:	00800ac4 	movi	r2,43
8112979c:	d8802305 	stb	r2,140(sp)
811297a0:	00800244 	movi	r2,9
811297a4:	15807016 	blt	r2,r22,81129968 <___vfprintf_internal_r+0x1fd4>
811297a8:	00800c04 	movi	r2,48
811297ac:	b5800c04 	addi	r22,r22,48
811297b0:	d8802345 	stb	r2,141(sp)
811297b4:	dd802385 	stb	r22,142(sp)
811297b8:	d88023c4 	addi	r2,sp,143
811297bc:	df0022c4 	addi	fp,sp,139
811297c0:	d8c03317 	ldw	r3,204(sp)
811297c4:	1739c83a 	sub	fp,r2,fp
811297c8:	d9003317 	ldw	r4,204(sp)
811297cc:	e0c7883a 	add	r3,fp,r3
811297d0:	df003a15 	stw	fp,232(sp)
811297d4:	d8c02e15 	stw	r3,184(sp)
811297d8:	00800044 	movi	r2,1
811297dc:	1100b30e 	bge	r2,r4,81129aac <___vfprintf_internal_r+0x2118>
811297e0:	d8c02e17 	ldw	r3,184(sp)
811297e4:	18c00044 	addi	r3,r3,1
811297e8:	d8c02e15 	stw	r3,184(sp)
811297ec:	1805883a 	mov	r2,r3
811297f0:	1800ac16 	blt	r3,zero,81129aa4 <___vfprintf_internal_r+0x2110>
811297f4:	d8003215 	stw	zero,200(sp)
811297f8:	003e5d06 	br	81129170 <__reset+0xfb109170>
811297fc:	d9002c17 	ldw	r4,176(sp)
81129800:	d9801e04 	addi	r6,sp,120
81129804:	b80b883a 	mov	r5,r23
81129808:	113389c0 	call	8113389c <__sprint_r>
8112980c:	1039651e 	bne	r2,zero,81127da4 <__reset+0xfb107da4>
81129810:	dc402617 	ldw	r17,152(sp)
81129814:	d8c02017 	ldw	r3,128(sp)
81129818:	d8801f17 	ldw	r2,124(sp)
8112981c:	da000404 	addi	r8,sp,16
81129820:	003ed606 	br	8112937c <__reset+0xfb10937c>
81129824:	582b883a 	mov	r21,r11
81129828:	d8002915 	stw	zero,164(sp)
8112982c:	0038bd06 	br	81127b24 <__reset+0xfb107b24>
81129830:	d8802917 	ldw	r2,164(sp)
81129834:	103e071e 	bne	r2,zero,81129054 <__reset+0xfb109054>
81129838:	dc002915 	stw	r16,164(sp)
8112983c:	003e0506 	br	81129054 <__reset+0xfb109054>
81129840:	d9002917 	ldw	r4,164(sp)
81129844:	20c00044 	addi	r3,r4,1
81129848:	003e0f06 	br	81129088 <__reset+0xfb109088>
8112984c:	01400184 	movi	r5,6
81129850:	d9402915 	stw	r5,164(sp)
81129854:	003dff06 	br	81129054 <__reset+0xfb109054>
81129858:	d8802104 	addi	r2,sp,132
8112985c:	d8800315 	stw	r2,12(sp)
81129860:	d8802504 	addi	r2,sp,148
81129864:	d8800215 	stw	r2,8(sp)
81129868:	d8802604 	addi	r2,sp,152
8112986c:	d8800115 	stw	r2,4(sp)
81129870:	d8802917 	ldw	r2,164(sp)
81129874:	d9403617 	ldw	r5,216(sp)
81129878:	d9002c17 	ldw	r4,176(sp)
8112987c:	d8800015 	stw	r2,0(sp)
81129880:	01c000c4 	movi	r7,3
81129884:	980d883a 	mov	r6,r19
81129888:	da003d15 	stw	r8,244(sp)
8112988c:	112baa00 	call	8112baa0 <_dtoa_r>
81129890:	d8c02917 	ldw	r3,164(sp)
81129894:	da003d17 	ldw	r8,244(sp)
81129898:	1021883a 	mov	r16,r2
8112989c:	10f9883a 	add	fp,r2,r3
811298a0:	81000007 	ldb	r4,0(r16)
811298a4:	00800c04 	movi	r2,48
811298a8:	20805e26 	beq	r4,r2,81129a24 <___vfprintf_internal_r+0x2090>
811298ac:	d8c02617 	ldw	r3,152(sp)
811298b0:	e0f9883a 	add	fp,fp,r3
811298b4:	003e0a06 	br	811290e0 <__reset+0xfb1090e0>
811298b8:	00c00b44 	movi	r3,45
811298bc:	24e0003c 	xorhi	r19,r4,32768
811298c0:	d8c02a05 	stb	r3,168(sp)
811298c4:	003de906 	br	8112906c <__reset+0xfb10906c>
811298c8:	d8c03217 	ldw	r3,200(sp)
811298cc:	00c07a0e 	bge	zero,r3,81129ab8 <___vfprintf_internal_r+0x2124>
811298d0:	00800044 	movi	r2,1
811298d4:	d9003317 	ldw	r4,204(sp)
811298d8:	1105883a 	add	r2,r2,r4
811298dc:	d8802e15 	stw	r2,184(sp)
811298e0:	10004e16 	blt	r2,zero,81129a1c <___vfprintf_internal_r+0x2088>
811298e4:	044019c4 	movi	r17,103
811298e8:	003e2106 	br	81129170 <__reset+0xfb109170>
811298ec:	d9002917 	ldw	r4,164(sp)
811298f0:	d8802104 	addi	r2,sp,132
811298f4:	d8800315 	stw	r2,12(sp)
811298f8:	d9000015 	stw	r4,0(sp)
811298fc:	d8802504 	addi	r2,sp,148
81129900:	d9403617 	ldw	r5,216(sp)
81129904:	d9002c17 	ldw	r4,176(sp)
81129908:	d8800215 	stw	r2,8(sp)
8112990c:	d8802604 	addi	r2,sp,152
81129910:	d8800115 	stw	r2,4(sp)
81129914:	01c000c4 	movi	r7,3
81129918:	980d883a 	mov	r6,r19
8112991c:	da003d15 	stw	r8,244(sp)
81129920:	112baa00 	call	8112baa0 <_dtoa_r>
81129924:	d8c02917 	ldw	r3,164(sp)
81129928:	da003d17 	ldw	r8,244(sp)
8112992c:	1021883a 	mov	r16,r2
81129930:	00801184 	movi	r2,70
81129934:	80f9883a 	add	fp,r16,r3
81129938:	88bfd926 	beq	r17,r2,811298a0 <__reset+0xfb1098a0>
8112993c:	003de806 	br	811290e0 <__reset+0xfb1090e0>
81129940:	d9002917 	ldw	r4,164(sp)
81129944:	00c04d0e 	bge	zero,r3,81129a7c <___vfprintf_internal_r+0x20e8>
81129948:	2000441e 	bne	r4,zero,81129a5c <___vfprintf_internal_r+0x20c8>
8112994c:	9480004c 	andi	r18,r18,1
81129950:	9000421e 	bne	r18,zero,81129a5c <___vfprintf_internal_r+0x20c8>
81129954:	1805883a 	mov	r2,r3
81129958:	18007016 	blt	r3,zero,81129b1c <___vfprintf_internal_r+0x2188>
8112995c:	d8c03217 	ldw	r3,200(sp)
81129960:	d8c02e15 	stw	r3,184(sp)
81129964:	003e0206 	br	81129170 <__reset+0xfb109170>
81129968:	df0022c4 	addi	fp,sp,139
8112996c:	dc002915 	stw	r16,164(sp)
81129970:	4027883a 	mov	r19,r8
81129974:	e021883a 	mov	r16,fp
81129978:	b009883a 	mov	r4,r22
8112997c:	01400284 	movi	r5,10
81129980:	1136b980 	call	81136b98 <__modsi3>
81129984:	10800c04 	addi	r2,r2,48
81129988:	843fffc4 	addi	r16,r16,-1
8112998c:	b009883a 	mov	r4,r22
81129990:	01400284 	movi	r5,10
81129994:	80800005 	stb	r2,0(r16)
81129998:	1136b140 	call	81136b14 <__divsi3>
8112999c:	102d883a 	mov	r22,r2
811299a0:	00800244 	movi	r2,9
811299a4:	15bff416 	blt	r2,r22,81129978 <__reset+0xfb109978>
811299a8:	9811883a 	mov	r8,r19
811299ac:	b0800c04 	addi	r2,r22,48
811299b0:	8027883a 	mov	r19,r16
811299b4:	997fffc4 	addi	r5,r19,-1
811299b8:	98bfffc5 	stb	r2,-1(r19)
811299bc:	dc002917 	ldw	r16,164(sp)
811299c0:	2f006a2e 	bgeu	r5,fp,81129b6c <___vfprintf_internal_r+0x21d8>
811299c4:	d9c02384 	addi	r7,sp,142
811299c8:	3ccfc83a 	sub	r7,r7,r19
811299cc:	d9002344 	addi	r4,sp,141
811299d0:	e1cf883a 	add	r7,fp,r7
811299d4:	00000106 	br	811299dc <___vfprintf_internal_r+0x2048>
811299d8:	28800003 	ldbu	r2,0(r5)
811299dc:	20800005 	stb	r2,0(r4)
811299e0:	21000044 	addi	r4,r4,1
811299e4:	29400044 	addi	r5,r5,1
811299e8:	393ffb1e 	bne	r7,r4,811299d8 <__reset+0xfb1099d8>
811299ec:	d8802304 	addi	r2,sp,140
811299f0:	14c5c83a 	sub	r2,r2,r19
811299f4:	d8c02344 	addi	r3,sp,141
811299f8:	1885883a 	add	r2,r3,r2
811299fc:	003f7006 	br	811297c0 <__reset+0xfb1097c0>
81129a00:	0005883a 	mov	r2,zero
81129a04:	003f0f06 	br	81129644 <__reset+0xfb109644>
81129a08:	d8c03217 	ldw	r3,200(sp)
81129a0c:	18c00044 	addi	r3,r3,1
81129a10:	d8c02e15 	stw	r3,184(sp)
81129a14:	1805883a 	mov	r2,r3
81129a18:	183fb20e 	bge	r3,zero,811298e4 <__reset+0xfb1098e4>
81129a1c:	0005883a 	mov	r2,zero
81129a20:	003fb006 	br	811298e4 <__reset+0xfb1098e4>
81129a24:	d9003617 	ldw	r4,216(sp)
81129a28:	000d883a 	mov	r6,zero
81129a2c:	000f883a 	mov	r7,zero
81129a30:	980b883a 	mov	r5,r19
81129a34:	d8c03c15 	stw	r3,240(sp)
81129a38:	da003d15 	stw	r8,244(sp)
81129a3c:	11380680 	call	81138068 <__eqdf2>
81129a40:	d8c03c17 	ldw	r3,240(sp)
81129a44:	da003d17 	ldw	r8,244(sp)
81129a48:	103f9826 	beq	r2,zero,811298ac <__reset+0xfb1098ac>
81129a4c:	00800044 	movi	r2,1
81129a50:	10c7c83a 	sub	r3,r2,r3
81129a54:	d8c02615 	stw	r3,152(sp)
81129a58:	003f9506 	br	811298b0 <__reset+0xfb1098b0>
81129a5c:	d9002917 	ldw	r4,164(sp)
81129a60:	d8c03217 	ldw	r3,200(sp)
81129a64:	20800044 	addi	r2,r4,1
81129a68:	1885883a 	add	r2,r3,r2
81129a6c:	d8802e15 	stw	r2,184(sp)
81129a70:	103dbf0e 	bge	r2,zero,81129170 <__reset+0xfb109170>
81129a74:	0005883a 	mov	r2,zero
81129a78:	003dbd06 	br	81129170 <__reset+0xfb109170>
81129a7c:	2000211e 	bne	r4,zero,81129b04 <___vfprintf_internal_r+0x2170>
81129a80:	9480004c 	andi	r18,r18,1
81129a84:	90001f1e 	bne	r18,zero,81129b04 <___vfprintf_internal_r+0x2170>
81129a88:	00800044 	movi	r2,1
81129a8c:	d8802e15 	stw	r2,184(sp)
81129a90:	003db706 	br	81129170 <__reset+0xfb109170>
81129a94:	00800b44 	movi	r2,45
81129a98:	05adc83a 	sub	r22,zero,r22
81129a9c:	d8802305 	stb	r2,140(sp)
81129aa0:	003f3f06 	br	811297a0 <__reset+0xfb1097a0>
81129aa4:	0005883a 	mov	r2,zero
81129aa8:	003f5206 	br	811297f4 <__reset+0xfb1097f4>
81129aac:	90a4703a 	and	r18,r18,r2
81129ab0:	903f4e26 	beq	r18,zero,811297ec <__reset+0xfb1097ec>
81129ab4:	003f4a06 	br	811297e0 <__reset+0xfb1097e0>
81129ab8:	00800084 	movi	r2,2
81129abc:	10c5c83a 	sub	r2,r2,r3
81129ac0:	003f8406 	br	811298d4 <__reset+0xfb1098d4>
81129ac4:	d8802d17 	ldw	r2,180(sp)
81129ac8:	d9002d17 	ldw	r4,180(sp)
81129acc:	ac400043 	ldbu	r17,1(r21)
81129ad0:	10800017 	ldw	r2,0(r2)
81129ad4:	582b883a 	mov	r21,r11
81129ad8:	d8802915 	stw	r2,164(sp)
81129adc:	20800104 	addi	r2,r4,4
81129ae0:	d9002917 	ldw	r4,164(sp)
81129ae4:	d8802d15 	stw	r2,180(sp)
81129ae8:	203e7a0e 	bge	r4,zero,811294d4 <__reset+0xfb1094d4>
81129aec:	8c403fcc 	andi	r17,r17,255
81129af0:	00bfffc4 	movi	r2,-1
81129af4:	8c40201c 	xori	r17,r17,128
81129af8:	d8802915 	stw	r2,164(sp)
81129afc:	8c7fe004 	addi	r17,r17,-128
81129b00:	00380706 	br	81127b20 <__reset+0xfb107b20>
81129b04:	d8c02917 	ldw	r3,164(sp)
81129b08:	18c00084 	addi	r3,r3,2
81129b0c:	d8c02e15 	stw	r3,184(sp)
81129b10:	1805883a 	mov	r2,r3
81129b14:	183d960e 	bge	r3,zero,81129170 <__reset+0xfb109170>
81129b18:	003fd606 	br	81129a74 <__reset+0xfb109a74>
81129b1c:	0005883a 	mov	r2,zero
81129b20:	003f8e06 	br	8112995c <__reset+0xfb10995c>
81129b24:	9080004c 	andi	r2,r18,1
81129b28:	103f811e 	bne	r2,zero,81129930 <__reset+0xfb109930>
81129b2c:	d8802117 	ldw	r2,132(sp)
81129b30:	1405c83a 	sub	r2,r2,r16
81129b34:	d8803315 	stw	r2,204(sp)
81129b38:	b47ef326 	beq	r22,r17,81129708 <__reset+0xfb109708>
81129b3c:	dd802617 	ldw	r22,152(sp)
81129b40:	003f1106 	br	81129788 <__reset+0xfb109788>
81129b44:	d9c02785 	stb	r7,158(sp)
81129b48:	00390406 	br	81127f5c <__reset+0xfb107f5c>
81129b4c:	d9c02785 	stb	r7,158(sp)
81129b50:	0038d306 	br	81127ea0 <__reset+0xfb107ea0>
81129b54:	d9c02785 	stb	r7,158(sp)
81129b58:	003a6106 	br	811284e0 <__reset+0xfb1084e0>
81129b5c:	d9c02785 	stb	r7,158(sp)
81129b60:	003af806 	br	81128744 <__reset+0xfb108744>
81129b64:	0005883a 	mov	r2,zero
81129b68:	003d7e06 	br	81129164 <__reset+0xfb109164>
81129b6c:	d8802344 	addi	r2,sp,141
81129b70:	003f1306 	br	811297c0 <__reset+0xfb1097c0>
81129b74:	d9c02785 	stb	r7,158(sp)
81129b78:	00392306 	br	81128008 <__reset+0xfb108008>
81129b7c:	d9c02785 	stb	r7,158(sp)
81129b80:	003aa906 	br	81128628 <__reset+0xfb108628>
81129b84:	d9c02785 	stb	r7,158(sp)
81129b88:	003a3d06 	br	81128480 <__reset+0xfb108480>
81129b8c:	d9c02785 	stb	r7,158(sp)
81129b90:	003aca06 	br	811286bc <__reset+0xfb1086bc>

81129b94 <__vfprintf_internal>:
81129b94:	00a04574 	movhi	r2,33045
81129b98:	10945c04 	addi	r2,r2,20848
81129b9c:	300f883a 	mov	r7,r6
81129ba0:	280d883a 	mov	r6,r5
81129ba4:	200b883a 	mov	r5,r4
81129ba8:	11000017 	ldw	r4,0(r2)
81129bac:	11279941 	jmpi	81127994 <___vfprintf_internal_r>

81129bb0 <__sbprintf>:
81129bb0:	defee204 	addi	sp,sp,-1144
81129bb4:	de00012e 	bgeu	sp,et,81129bbc <__sbprintf+0xc>
81129bb8:	003b68fa 	trap	3
81129bbc:	2880030b 	ldhu	r2,12(r5)
81129bc0:	2ac01917 	ldw	r11,100(r5)
81129bc4:	2a80038b 	ldhu	r10,14(r5)
81129bc8:	2a400717 	ldw	r9,28(r5)
81129bcc:	2a000917 	ldw	r8,36(r5)
81129bd0:	00c10004 	movi	r3,1024
81129bd4:	dc011a15 	stw	r16,1128(sp)
81129bd8:	10bfff4c 	andi	r2,r2,65533
81129bdc:	2821883a 	mov	r16,r5
81129be0:	d8cb883a 	add	r5,sp,r3
81129be4:	dc811c15 	stw	r18,1136(sp)
81129be8:	dc411b15 	stw	r17,1132(sp)
81129bec:	dfc11d15 	stw	ra,1140(sp)
81129bf0:	2025883a 	mov	r18,r4
81129bf4:	d881030d 	sth	r2,1036(sp)
81129bf8:	dac11915 	stw	r11,1124(sp)
81129bfc:	da81038d 	sth	r10,1038(sp)
81129c00:	da410715 	stw	r9,1052(sp)
81129c04:	da010915 	stw	r8,1060(sp)
81129c08:	dec10015 	stw	sp,1024(sp)
81129c0c:	dec10415 	stw	sp,1040(sp)
81129c10:	d8c10215 	stw	r3,1032(sp)
81129c14:	d8c10515 	stw	r3,1044(sp)
81129c18:	d8010615 	stw	zero,1048(sp)
81129c1c:	11279940 	call	81127994 <___vfprintf_internal_r>
81129c20:	1023883a 	mov	r17,r2
81129c24:	10000416 	blt	r2,zero,81129c38 <__sbprintf+0x88>
81129c28:	d9410004 	addi	r5,sp,1024
81129c2c:	9009883a 	mov	r4,r18
81129c30:	112d3540 	call	8112d354 <_fflush_r>
81129c34:	10000d1e 	bne	r2,zero,81129c6c <__sbprintf+0xbc>
81129c38:	d881030b 	ldhu	r2,1036(sp)
81129c3c:	1080100c 	andi	r2,r2,64
81129c40:	10000326 	beq	r2,zero,81129c50 <__sbprintf+0xa0>
81129c44:	8080030b 	ldhu	r2,12(r16)
81129c48:	10801014 	ori	r2,r2,64
81129c4c:	8080030d 	sth	r2,12(r16)
81129c50:	8805883a 	mov	r2,r17
81129c54:	dfc11d17 	ldw	ra,1140(sp)
81129c58:	dc811c17 	ldw	r18,1136(sp)
81129c5c:	dc411b17 	ldw	r17,1132(sp)
81129c60:	dc011a17 	ldw	r16,1128(sp)
81129c64:	dec11e04 	addi	sp,sp,1144
81129c68:	f800283a 	ret
81129c6c:	047fffc4 	movi	r17,-1
81129c70:	003ff106 	br	81129c38 <__reset+0xfb109c38>

81129c74 <__svfscanf_r>:
81129c74:	deff4b04 	addi	sp,sp,-724
81129c78:	de00012e 	bgeu	sp,et,81129c80 <__svfscanf_r+0xc>
81129c7c:	003b68fa 	trap	3
81129c80:	2880030b 	ldhu	r2,12(r5)
81129c84:	df00b315 	stw	fp,716(sp)
81129c88:	dd80b115 	stw	r22,708(sp)
81129c8c:	dfc0b415 	stw	ra,720(sp)
81129c90:	ddc0b215 	stw	r23,712(sp)
81129c94:	dd40b015 	stw	r21,704(sp)
81129c98:	dd00af15 	stw	r20,700(sp)
81129c9c:	dcc0ae15 	stw	r19,696(sp)
81129ca0:	dc80ad15 	stw	r18,692(sp)
81129ca4:	dc40ac15 	stw	r17,688(sp)
81129ca8:	dc00ab15 	stw	r16,684(sp)
81129cac:	10c8000c 	andi	r3,r2,8192
81129cb0:	d9c09c15 	stw	r7,624(sp)
81129cb4:	2839883a 	mov	fp,r5
81129cb8:	202d883a 	mov	r22,r4
81129cbc:	1800061e 	bne	r3,zero,81129cd8 <__svfscanf_r+0x64>
81129cc0:	29001917 	ldw	r4,100(r5)
81129cc4:	00f7ffc4 	movi	r3,-8193
81129cc8:	10880014 	ori	r2,r2,8192
81129ccc:	20c6703a 	and	r3,r4,r3
81129cd0:	2880030d 	sth	r2,12(r5)
81129cd4:	28c01915 	stw	r3,100(r5)
81129cd8:	30800003 	ldbu	r2,0(r6)
81129cdc:	0021883a 	mov	r16,zero
81129ce0:	05e04574 	movhi	r23,33045
81129ce4:	d800a115 	stw	zero,644(sp)
81129ce8:	d8009e15 	stw	zero,632(sp)
81129cec:	d800a015 	stw	zero,640(sp)
81129cf0:	d8809b15 	stw	r2,620(sp)
81129cf4:	bdd45a04 	addi	r23,r23,20840
81129cf8:	8025883a 	mov	r18,r16
81129cfc:	35000044 	addi	r20,r6,1
81129d00:	10001e26 	beq	r2,zero,81129d7c <__svfscanf_r+0x108>
81129d04:	b9c00017 	ldw	r7,0(r23)
81129d08:	3887883a 	add	r3,r7,r2
81129d0c:	18c00043 	ldbu	r3,1(r3)
81129d10:	18c0020c 	andi	r3,r3,8
81129d14:	18001b26 	beq	r3,zero,81129d84 <__svfscanf_r+0x110>
81129d18:	e0800117 	ldw	r2,4(fp)
81129d1c:	00800e0e 	bge	zero,r2,81129d58 <__svfscanf_r+0xe4>
81129d20:	e0c00017 	ldw	r3,0(fp)
81129d24:	b9000017 	ldw	r4,0(r23)
81129d28:	18800003 	ldbu	r2,0(r3)
81129d2c:	2085883a 	add	r2,r4,r2
81129d30:	10800043 	ldbu	r2,1(r2)
81129d34:	1080020c 	andi	r2,r2,8
81129d38:	10000b26 	beq	r2,zero,81129d68 <__svfscanf_r+0xf4>
81129d3c:	e0800117 	ldw	r2,4(fp)
81129d40:	18c00044 	addi	r3,r3,1
81129d44:	e0c00015 	stw	r3,0(fp)
81129d48:	10bfffc4 	addi	r2,r2,-1
81129d4c:	e0800115 	stw	r2,4(fp)
81129d50:	94800044 	addi	r18,r18,1
81129d54:	00bff216 	blt	zero,r2,81129d20 <__reset+0xfb109d20>
81129d58:	e00b883a 	mov	r5,fp
81129d5c:	b009883a 	mov	r4,r22
81129d60:	1124c500 	call	81124c50 <__srefill_r>
81129d64:	103fee26 	beq	r2,zero,81129d20 <__reset+0xfb109d20>
81129d68:	a00d883a 	mov	r6,r20
81129d6c:	30800003 	ldbu	r2,0(r6)
81129d70:	35000044 	addi	r20,r6,1
81129d74:	d8809b15 	stw	r2,620(sp)
81129d78:	103fe21e 	bne	r2,zero,81129d04 <__reset+0xfb109d04>
81129d7c:	d880a017 	ldw	r2,640(sp)
81129d80:	00009906 	br	81129fe8 <__svfscanf_r+0x374>
81129d84:	00c00944 	movi	r3,37
81129d88:	10c0881e 	bne	r2,r3,81129fac <__svfscanf_r+0x338>
81129d8c:	30c00043 	ldbu	r3,1(r6)
81129d90:	0023883a 	mov	r17,zero
81129d94:	0027883a 	mov	r19,zero
81129d98:	01001e04 	movi	r4,120
81129d9c:	01401b04 	movi	r5,108
81129da0:	a1800044 	addi	r6,r20,1
81129da4:	20c0a236 	bltu	r4,r3,8112a030 <__svfscanf_r+0x3bc>
81129da8:	180490ba 	slli	r2,r3,2
81129dac:	022044f4 	movhi	r8,33043
81129db0:	42277004 	addi	r8,r8,-25152
81129db4:	1205883a 	add	r2,r2,r8
81129db8:	10800017 	ldw	r2,0(r2)
81129dbc:	1000683a 	jmp	r2
81129dc0:	81129fe4 	muli	r4,r16,19071
81129dc4:	8112a030 	cmpltui	r4,r16,19072
81129dc8:	8112a030 	cmpltui	r4,r16,19072
81129dcc:	8112a030 	cmpltui	r4,r16,19072
81129dd0:	8112a030 	cmpltui	r4,r16,19072
81129dd4:	8112a030 	cmpltui	r4,r16,19072
81129dd8:	8112a030 	cmpltui	r4,r16,19072
81129ddc:	8112a030 	cmpltui	r4,r16,19072
81129de0:	8112a030 	cmpltui	r4,r16,19072
81129de4:	8112a030 	cmpltui	r4,r16,19072
81129de8:	8112a030 	cmpltui	r4,r16,19072
81129dec:	8112a030 	cmpltui	r4,r16,19072
81129df0:	8112a030 	cmpltui	r4,r16,19072
81129df4:	8112a030 	cmpltui	r4,r16,19072
81129df8:	8112a030 	cmpltui	r4,r16,19072
81129dfc:	8112a030 	cmpltui	r4,r16,19072
81129e00:	8112a030 	cmpltui	r4,r16,19072
81129e04:	8112a030 	cmpltui	r4,r16,19072
81129e08:	8112a030 	cmpltui	r4,r16,19072
81129e0c:	8112a030 	cmpltui	r4,r16,19072
81129e10:	8112a030 	cmpltui	r4,r16,19072
81129e14:	8112a030 	cmpltui	r4,r16,19072
81129e18:	8112a030 	cmpltui	r4,r16,19072
81129e1c:	8112a030 	cmpltui	r4,r16,19072
81129e20:	8112a030 	cmpltui	r4,r16,19072
81129e24:	8112a030 	cmpltui	r4,r16,19072
81129e28:	8112a030 	cmpltui	r4,r16,19072
81129e2c:	8112a030 	cmpltui	r4,r16,19072
81129e30:	8112a030 	cmpltui	r4,r16,19072
81129e34:	8112a030 	cmpltui	r4,r16,19072
81129e38:	8112a030 	cmpltui	r4,r16,19072
81129e3c:	8112a030 	cmpltui	r4,r16,19072
81129e40:	8112a030 	cmpltui	r4,r16,19072
81129e44:	8112a030 	cmpltui	r4,r16,19072
81129e48:	8112a030 	cmpltui	r4,r16,19072
81129e4c:	8112a030 	cmpltui	r4,r16,19072
81129e50:	8112a030 	cmpltui	r4,r16,19072
81129e54:	81129fa4 	muli	r4,r16,19070
81129e58:	8112a030 	cmpltui	r4,r16,19072
81129e5c:	8112a030 	cmpltui	r4,r16,19072
81129e60:	8112a030 	cmpltui	r4,r16,19072
81129e64:	8112a030 	cmpltui	r4,r16,19072
81129e68:	8112a018 	cmpnei	r4,r16,19072
81129e6c:	8112a030 	cmpltui	r4,r16,19072
81129e70:	8112a030 	cmpltui	r4,r16,19072
81129e74:	8112a030 	cmpltui	r4,r16,19072
81129e78:	8112a030 	cmpltui	r4,r16,19072
81129e7c:	8112a030 	cmpltui	r4,r16,19072
81129e80:	8112a14c 	andi	r4,r16,19077
81129e84:	8112a14c 	andi	r4,r16,19077
81129e88:	8112a14c 	andi	r4,r16,19077
81129e8c:	8112a14c 	andi	r4,r16,19077
81129e90:	8112a14c 	andi	r4,r16,19077
81129e94:	8112a14c 	andi	r4,r16,19077
81129e98:	8112a14c 	andi	r4,r16,19077
81129e9c:	8112a14c 	andi	r4,r16,19077
81129ea0:	8112a14c 	andi	r4,r16,19077
81129ea4:	8112a14c 	andi	r4,r16,19077
81129ea8:	8112a030 	cmpltui	r4,r16,19072
81129eac:	8112a030 	cmpltui	r4,r16,19072
81129eb0:	8112a030 	cmpltui	r4,r16,19072
81129eb4:	8112a030 	cmpltui	r4,r16,19072
81129eb8:	8112a030 	cmpltui	r4,r16,19072
81129ebc:	8112a030 	cmpltui	r4,r16,19072
81129ec0:	8112a030 	cmpltui	r4,r16,19072
81129ec4:	8112a030 	cmpltui	r4,r16,19072
81129ec8:	8112a030 	cmpltui	r4,r16,19072
81129ecc:	8112a030 	cmpltui	r4,r16,19072
81129ed0:	8112a120 	cmpeqi	r4,r16,19076
81129ed4:	8112a1d0 	cmplti	r4,r16,19079
81129ed8:	8112a030 	cmpltui	r4,r16,19072
81129edc:	8112a1d0 	cmplti	r4,r16,19079
81129ee0:	8112a030 	cmpltui	r4,r16,19072
81129ee4:	8112a030 	cmpltui	r4,r16,19072
81129ee8:	8112a030 	cmpltui	r4,r16,19072
81129eec:	8112a030 	cmpltui	r4,r16,19072
81129ef0:	8112a1bc 	xorhi	r4,r16,19078
81129ef4:	8112a030 	cmpltui	r4,r16,19072
81129ef8:	8112a030 	cmpltui	r4,r16,19072
81129efc:	8112a190 	cmplti	r4,r16,19078
81129f00:	8112a030 	cmpltui	r4,r16,19072
81129f04:	8112a030 	cmpltui	r4,r16,19072
81129f08:	8112a030 	cmpltui	r4,r16,19072
81129f0c:	8112a030 	cmpltui	r4,r16,19072
81129f10:	8112a030 	cmpltui	r4,r16,19072
81129f14:	8112a030 	cmpltui	r4,r16,19072
81129f18:	8112a030 	cmpltui	r4,r16,19072
81129f1c:	8112a030 	cmpltui	r4,r16,19072
81129f20:	8112a168 	cmpgeui	r4,r16,19077
81129f24:	8112a030 	cmpltui	r4,r16,19072
81129f28:	8112a030 	cmpltui	r4,r16,19072
81129f2c:	8112a304 	addi	r4,r16,19084
81129f30:	8112a030 	cmpltui	r4,r16,19072
81129f34:	8112a030 	cmpltui	r4,r16,19072
81129f38:	8112a030 	cmpltui	r4,r16,19072
81129f3c:	8112a030 	cmpltui	r4,r16,19072
81129f40:	8112a030 	cmpltui	r4,r16,19072
81129f44:	8112a030 	cmpltui	r4,r16,19072
81129f48:	8112a030 	cmpltui	r4,r16,19072
81129f4c:	8112a288 	cmpgei	r4,r16,19082
81129f50:	8112a260 	cmpeqi	r4,r16,19081
81129f54:	8112a1d0 	cmplti	r4,r16,19079
81129f58:	8112a1d0 	cmplti	r4,r16,19079
81129f5c:	8112a1d0 	cmplti	r4,r16,19079
81129f60:	8112a24c 	andi	r4,r16,19081
81129f64:	8112a390 	cmplti	r4,r16,19086
81129f68:	8112a030 	cmpltui	r4,r16,19072
81129f6c:	8112a030 	cmpltui	r4,r16,19072
81129f70:	8112a238 	rdprs	r4,r16,19080
81129f74:	8112a030 	cmpltui	r4,r16,19072
81129f78:	8112a208 	cmpgei	r4,r16,19080
81129f7c:	8112a1e4 	muli	r4,r16,19079
81129f80:	8112a0f4 	orhi	r4,r16,19075
81129f84:	8112a030 	cmpltui	r4,r16,19072
81129f88:	8112a030 	cmpltui	r4,r16,19072
81129f8c:	8112a0e0 	cmpeqi	r4,r16,19075
81129f90:	8112a030 	cmpltui	r4,r16,19072
81129f94:	8112a068 	cmpgeui	r4,r16,19073
81129f98:	8112a030 	cmpltui	r4,r16,19072
81129f9c:	8112a030 	cmpltui	r4,r16,19072
81129fa0:	8112a168 	cmpgeui	r4,r16,19077
81129fa4:	d9809d15 	stw	r6,628(sp)
81129fa8:	3029883a 	mov	r20,r6
81129fac:	e0800117 	ldw	r2,4(fp)
81129fb0:	0081aa0e 	bge	zero,r2,8112a65c <__svfscanf_r+0x9e8>
81129fb4:	e0800017 	ldw	r2,0(fp)
81129fb8:	a0ffffc3 	ldbu	r3,-1(r20)
81129fbc:	11000003 	ldbu	r4,0(r2)
81129fc0:	20ff6e1e 	bne	r4,r3,81129d7c <__reset+0xfb109d7c>
81129fc4:	e0c00117 	ldw	r3,4(fp)
81129fc8:	10800044 	addi	r2,r2,1
81129fcc:	e0800015 	stw	r2,0(fp)
81129fd0:	18bfffc4 	addi	r2,r3,-1
81129fd4:	e0800115 	stw	r2,4(fp)
81129fd8:	94800044 	addi	r18,r18,1
81129fdc:	a00d883a 	mov	r6,r20
81129fe0:	003f6206 	br	81129d6c <__reset+0xfb109d6c>
81129fe4:	00bfffc4 	movi	r2,-1
81129fe8:	dfc0b417 	ldw	ra,720(sp)
81129fec:	df00b317 	ldw	fp,716(sp)
81129ff0:	ddc0b217 	ldw	r23,712(sp)
81129ff4:	dd80b117 	ldw	r22,708(sp)
81129ff8:	dd40b017 	ldw	r21,704(sp)
81129ffc:	dd00af17 	ldw	r20,700(sp)
8112a000:	dcc0ae17 	ldw	r19,696(sp)
8112a004:	dc80ad17 	ldw	r18,692(sp)
8112a008:	dc40ac17 	ldw	r17,688(sp)
8112a00c:	dc00ab17 	ldw	r16,684(sp)
8112a010:	dec0b504 	addi	sp,sp,724
8112a014:	f800283a 	ret
8112a018:	a0800043 	ldbu	r2,1(r20)
8112a01c:	3029883a 	mov	r20,r6
8112a020:	8c400414 	ori	r17,r17,16
8112a024:	10c03fcc 	andi	r3,r2,255
8112a028:	a1800044 	addi	r6,r20,1
8112a02c:	20ff5e2e 	bgeu	r4,r3,81129da8 <__reset+0xfb109da8>
8112a030:	38c7883a 	add	r3,r7,r3
8112a034:	18800043 	ldbu	r2,1(r3)
8112a038:	d9809d15 	stw	r6,628(sp)
8112a03c:	00c00044 	movi	r3,1
8112a040:	108000cc 	andi	r2,r2,3
8112a044:	10c18f26 	beq	r2,r3,8112a684 <__svfscanf_r+0xa10>
8112a048:	e0800117 	ldw	r2,4(fp)
8112a04c:	00808716 	blt	zero,r2,8112a26c <__svfscanf_r+0x5f8>
8112a050:	e00b883a 	mov	r5,fp
8112a054:	b009883a 	mov	r4,r22
8112a058:	1124c500 	call	81124c50 <__srefill_r>
8112a05c:	1001431e 	bne	r2,zero,8112a56c <__svfscanf_r+0x8f8>
8112a060:	b9c00017 	ldw	r7,0(r23)
8112a064:	00008106 	br	8112a26c <__svfscanf_r+0x5f8>
8112a068:	e0800117 	ldw	r2,4(fp)
8112a06c:	d9809d15 	stw	r6,628(sp)
8112a070:	0081a30e 	bge	zero,r2,8112a700 <__svfscanf_r+0xa8c>
8112a074:	00a044f4 	movhi	r2,33043
8112a078:	1086e704 	addi	r2,r2,7068
8112a07c:	02000284 	movi	r8,10
8112a080:	d880a115 	stw	r2,644(sp)
8112a084:	da009e15 	stw	r8,632(sp)
8112a088:	050000c4 	movi	r20,3
8112a08c:	e0c00017 	ldw	r3,0(fp)
8112a090:	00000206 	br	8112a09c <__svfscanf_r+0x428>
8112a094:	18c00044 	addi	r3,r3,1
8112a098:	e0c00015 	stw	r3,0(fp)
8112a09c:	19000003 	ldbu	r4,0(r3)
8112a0a0:	20803fcc 	andi	r2,r4,255
8112a0a4:	3885883a 	add	r2,r7,r2
8112a0a8:	10800043 	ldbu	r2,1(r2)
8112a0ac:	1140020c 	andi	r5,r2,8
8112a0b0:	2801ab26 	beq	r5,zero,8112a760 <__svfscanf_r+0xaec>
8112a0b4:	e0800117 	ldw	r2,4(fp)
8112a0b8:	94800044 	addi	r18,r18,1
8112a0bc:	10bfffc4 	addi	r2,r2,-1
8112a0c0:	e0800115 	stw	r2,4(fp)
8112a0c4:	00bff316 	blt	zero,r2,8112a094 <__reset+0xfb10a094>
8112a0c8:	e00b883a 	mov	r5,fp
8112a0cc:	b009883a 	mov	r4,r22
8112a0d0:	1124c500 	call	81124c50 <__srefill_r>
8112a0d4:	1001251e 	bne	r2,zero,8112a56c <__svfscanf_r+0x8f8>
8112a0d8:	b9c00017 	ldw	r7,0(r23)
8112a0dc:	003feb06 	br	8112a08c <__reset+0xfb10a08c>
8112a0e0:	e0800117 	ldw	r2,4(fp)
8112a0e4:	d9809d15 	stw	r6,628(sp)
8112a0e8:	00818b0e 	bge	zero,r2,8112a718 <__svfscanf_r+0xaa4>
8112a0ec:	05000084 	movi	r20,2
8112a0f0:	003fe606 	br	8112a08c <__reset+0xfb10a08c>
8112a0f4:	e0800117 	ldw	r2,4(fp)
8112a0f8:	d9809d15 	stw	r6,628(sp)
8112a0fc:	8c408814 	ori	r17,r17,544
8112a100:	00801d0e 	bge	zero,r2,8112a178 <__svfscanf_r+0x504>
8112a104:	00a044f4 	movhi	r2,33043
8112a108:	1086e704 	addi	r2,r2,7068
8112a10c:	02000404 	movi	r8,16
8112a110:	d880a115 	stw	r2,644(sp)
8112a114:	da009e15 	stw	r8,632(sp)
8112a118:	050000c4 	movi	r20,3
8112a11c:	003fdb06 	br	8112a08c <__reset+0xfb10a08c>
8112a120:	e0800117 	ldw	r2,4(fp)
8112a124:	d9809d15 	stw	r6,628(sp)
8112a128:	8c400054 	ori	r17,r17,1
8112a12c:	00bfc80e 	bge	zero,r2,8112a050 <__reset+0xfb10a050>
8112a130:	00e044b4 	movhi	r3,33042
8112a134:	18d49504 	addi	r3,r3,21076
8112a138:	02000284 	movi	r8,10
8112a13c:	d8c0a115 	stw	r3,644(sp)
8112a140:	da009e15 	stw	r8,632(sp)
8112a144:	050000c4 	movi	r20,3
8112a148:	003fd006 	br	8112a08c <__reset+0xfb10a08c>
8112a14c:	9cc002a4 	muli	r19,r19,10
8112a150:	a0800043 	ldbu	r2,1(r20)
8112a154:	3029883a 	mov	r20,r6
8112a158:	98e7883a 	add	r19,r19,r3
8112a15c:	9cfff404 	addi	r19,r19,-48
8112a160:	10c03fcc 	andi	r3,r2,255
8112a164:	003f0e06 	br	81129da0 <__reset+0xfb109da0>
8112a168:	e0800117 	ldw	r2,4(fp)
8112a16c:	d9809d15 	stw	r6,628(sp)
8112a170:	8c408014 	ori	r17,r17,512
8112a174:	00bfe316 	blt	zero,r2,8112a104 <__reset+0xfb10a104>
8112a178:	e00b883a 	mov	r5,fp
8112a17c:	b009883a 	mov	r4,r22
8112a180:	1124c500 	call	81124c50 <__srefill_r>
8112a184:	1000f91e 	bne	r2,zero,8112a56c <__svfscanf_r+0x8f8>
8112a188:	b9c00017 	ldw	r7,0(r23)
8112a18c:	003fdd06 	br	8112a104 <__reset+0xfb10a104>
8112a190:	e0800117 	ldw	r2,4(fp)
8112a194:	d9809d15 	stw	r6,628(sp)
8112a198:	8c400054 	ori	r17,r17,1
8112a19c:	0080140e 	bge	zero,r2,8112a1f0 <__svfscanf_r+0x57c>
8112a1a0:	00a044f4 	movhi	r2,33043
8112a1a4:	1086e704 	addi	r2,r2,7068
8112a1a8:	02000204 	movi	r8,8
8112a1ac:	d880a115 	stw	r2,644(sp)
8112a1b0:	da009e15 	stw	r8,632(sp)
8112a1b4:	050000c4 	movi	r20,3
8112a1b8:	003fb406 	br	8112a08c <__reset+0xfb10a08c>
8112a1bc:	a0800043 	ldbu	r2,1(r20)
8112a1c0:	8c400094 	ori	r17,r17,2
8112a1c4:	3029883a 	mov	r20,r6
8112a1c8:	10c03fcc 	andi	r3,r2,255
8112a1cc:	003ef406 	br	81129da0 <__reset+0xfb109da0>
8112a1d0:	e0800117 	ldw	r2,4(fp)
8112a1d4:	d9809d15 	stw	r6,628(sp)
8112a1d8:	0081420e 	bge	zero,r2,8112a6e4 <__svfscanf_r+0xa70>
8112a1dc:	05000104 	movi	r20,4
8112a1e0:	003faa06 	br	8112a08c <__reset+0xfb10a08c>
8112a1e4:	e0800117 	ldw	r2,4(fp)
8112a1e8:	d9809d15 	stw	r6,628(sp)
8112a1ec:	00bfec16 	blt	zero,r2,8112a1a0 <__reset+0xfb10a1a0>
8112a1f0:	e00b883a 	mov	r5,fp
8112a1f4:	b009883a 	mov	r4,r22
8112a1f8:	1124c500 	call	81124c50 <__srefill_r>
8112a1fc:	1000db1e 	bne	r2,zero,8112a56c <__svfscanf_r+0x8f8>
8112a200:	b9c00017 	ldw	r7,0(r23)
8112a204:	003fe606 	br	8112a1a0 <__reset+0xfb10a1a0>
8112a208:	d9809d15 	stw	r6,628(sp)
8112a20c:	8880040c 	andi	r2,r17,16
8112a210:	10009c1e 	bne	r2,zero,8112a484 <__svfscanf_r+0x810>
8112a214:	8880010c 	andi	r2,r17,4
8112a218:	10011e26 	beq	r2,zero,8112a694 <__svfscanf_r+0xa20>
8112a21c:	da009c17 	ldw	r8,624(sp)
8112a220:	3029883a 	mov	r20,r6
8112a224:	40800017 	ldw	r2,0(r8)
8112a228:	42000104 	addi	r8,r8,4
8112a22c:	da009c15 	stw	r8,624(sp)
8112a230:	1480000d 	sth	r18,0(r2)
8112a234:	003ecc06 	br	81129d68 <__reset+0xfb109d68>
8112a238:	a0c00043 	ldbu	r3,1(r20)
8112a23c:	19410c26 	beq	r3,r5,8112a670 <__svfscanf_r+0x9fc>
8112a240:	8c400054 	ori	r17,r17,1
8112a244:	3029883a 	mov	r20,r6
8112a248:	003ed506 	br	81129da0 <__reset+0xfb109da0>
8112a24c:	a0800043 	ldbu	r2,1(r20)
8112a250:	8c400114 	ori	r17,r17,4
8112a254:	3029883a 	mov	r20,r6
8112a258:	10c03fcc 	andi	r3,r2,255
8112a25c:	003ed006 	br	81129da0 <__reset+0xfb109da0>
8112a260:	e0800117 	ldw	r2,4(fp)
8112a264:	d9809d15 	stw	r6,628(sp)
8112a268:	00bf790e 	bge	zero,r2,8112a050 <__reset+0xfb10a050>
8112a26c:	00a044b4 	movhi	r2,33042
8112a270:	10949504 	addi	r2,r2,21076
8112a274:	02000284 	movi	r8,10
8112a278:	d880a115 	stw	r2,644(sp)
8112a27c:	da009e15 	stw	r8,632(sp)
8112a280:	050000c4 	movi	r20,3
8112a284:	003f8106 	br	8112a08c <__reset+0xfb10a08c>
8112a288:	e0800117 	ldw	r2,4(fp)
8112a28c:	d9809d15 	stw	r6,628(sp)
8112a290:	0080c40e 	bge	zero,r2,8112a5a4 <__svfscanf_r+0x930>
8112a294:	9800011e 	bne	r19,zero,8112a29c <__svfscanf_r+0x628>
8112a298:	04c00044 	movi	r19,1
8112a29c:	8880004c 	andi	r2,r17,1
8112a2a0:	1000441e 	bne	r2,zero,8112a3b4 <__svfscanf_r+0x740>
8112a2a4:	8c40040c 	andi	r17,r17,16
8112a2a8:	8800da26 	beq	r17,zero,8112a614 <__svfscanf_r+0x9a0>
8112a2ac:	0021883a 	mov	r16,zero
8112a2b0:	00000806 	br	8112a2d4 <__svfscanf_r+0x660>
8112a2b4:	1887883a 	add	r3,r3,r2
8112a2b8:	e00b883a 	mov	r5,fp
8112a2bc:	b009883a 	mov	r4,r22
8112a2c0:	e0c00015 	stw	r3,0(fp)
8112a2c4:	80a1883a 	add	r16,r16,r2
8112a2c8:	98a7c83a 	sub	r19,r19,r2
8112a2cc:	1124c500 	call	81124c50 <__srefill_r>
8112a2d0:	1000ca1e 	bne	r2,zero,8112a5fc <__svfscanf_r+0x988>
8112a2d4:	e0800117 	ldw	r2,4(fp)
8112a2d8:	e0c00017 	ldw	r3,0(fp)
8112a2dc:	14fff516 	blt	r2,r19,8112a2b4 <__reset+0xfb10a2b4>
8112a2e0:	14c5c83a 	sub	r2,r2,r19
8112a2e4:	1cd5883a 	add	r10,r3,r19
8112a2e8:	84e1883a 	add	r16,r16,r19
8112a2ec:	e0800115 	stw	r2,4(fp)
8112a2f0:	e2800015 	stw	r10,0(fp)
8112a2f4:	dd009d17 	ldw	r20,628(sp)
8112a2f8:	9425883a 	add	r18,r18,r16
8112a2fc:	a00d883a 	mov	r6,r20
8112a300:	003e9a06 	br	81129d6c <__reset+0xfb109d6c>
8112a304:	300b883a 	mov	r5,r6
8112a308:	d9005884 	addi	r4,sp,354
8112a30c:	d9809d15 	stw	r6,628(sp)
8112a310:	113025c0 	call	8113025c <__sccl>
8112a314:	1029883a 	mov	r20,r2
8112a318:	e0800117 	ldw	r2,4(fp)
8112a31c:	0081050e 	bge	zero,r2,8112a734 <__svfscanf_r+0xac0>
8112a320:	e1000017 	ldw	r4,0(fp)
8112a324:	20800003 	ldbu	r2,0(r4)
8112a328:	98005926 	beq	r19,zero,8112a490 <__svfscanf_r+0x81c>
8112a32c:	8c40040c 	andi	r17,r17,16
8112a330:	88005a26 	beq	r17,zero,8112a49c <__svfscanf_r+0x828>
8112a334:	9823883a 	mov	r17,r19
8112a338:	0021883a 	mov	r16,zero
8112a33c:	00000106 	br	8112a344 <__svfscanf_r+0x6d0>
8112a340:	20800003 	ldbu	r2,0(r4)
8112a344:	10803fcc 	andi	r2,r2,255
8112a348:	d8c05884 	addi	r3,sp,354
8112a34c:	1885883a 	add	r2,r3,r2
8112a350:	10800007 	ldb	r2,0(r2)
8112a354:	1000ad26 	beq	r2,zero,8112a60c <__svfscanf_r+0x998>
8112a358:	e0800117 	ldw	r2,4(fp)
8112a35c:	21000044 	addi	r4,r4,1
8112a360:	84000044 	addi	r16,r16,1
8112a364:	10bfffc4 	addi	r2,r2,-1
8112a368:	e0800115 	stw	r2,4(fp)
8112a36c:	e1000015 	stw	r4,0(fp)
8112a370:	84c0a026 	beq	r16,r19,8112a5f4 <__svfscanf_r+0x980>
8112a374:	00bff216 	blt	zero,r2,8112a340 <__reset+0xfb10a340>
8112a378:	e00b883a 	mov	r5,fp
8112a37c:	b009883a 	mov	r4,r22
8112a380:	1124c500 	call	81124c50 <__srefill_r>
8112a384:	10009a1e 	bne	r2,zero,8112a5f0 <__svfscanf_r+0x97c>
8112a388:	e1000017 	ldw	r4,0(fp)
8112a38c:	003fec06 	br	8112a340 <__reset+0xfb10a340>
8112a390:	e0800117 	ldw	r2,4(fp)
8112a394:	d9809d15 	stw	r6,628(sp)
8112a398:	0080eb0e 	bge	zero,r2,8112a748 <__svfscanf_r+0xad4>
8112a39c:	00a044b4 	movhi	r2,33042
8112a3a0:	10949504 	addi	r2,r2,21076
8112a3a4:	d880a115 	stw	r2,644(sp)
8112a3a8:	d8009e15 	stw	zero,632(sp)
8112a3ac:	050000c4 	movi	r20,3
8112a3b0:	003f3606 	br	8112a08c <__reset+0xfb10a08c>
8112a3b4:	dd409904 	addi	r21,sp,612
8112a3b8:	8c40040c 	andi	r17,r17,16
8112a3bc:	01800204 	movi	r6,8
8112a3c0:	000b883a 	mov	r5,zero
8112a3c4:	a809883a 	mov	r4,r21
8112a3c8:	dc409f15 	stw	r17,636(sp)
8112a3cc:	11248500 	call	81124850 <memset>
8112a3d0:	dc409f17 	ldw	r17,636(sp)
8112a3d4:	88006e26 	beq	r17,zero,8112a590 <__svfscanf_r+0x91c>
8112a3d8:	0029883a 	mov	r20,zero
8112a3dc:	0023883a 	mov	r17,zero
8112a3e0:	112e6780 	call	8112e678 <__locale_mb_cur_max>
8112a3e4:	14406126 	beq	r2,r17,8112a56c <__svfscanf_r+0x8f8>
8112a3e8:	e0800017 	ldw	r2,0(fp)
8112a3ec:	e0c00117 	ldw	r3,4(fp)
8112a3f0:	d9000104 	addi	r4,sp,4
8112a3f4:	12000003 	ldbu	r8,0(r2)
8112a3f8:	18ffffc4 	addi	r3,r3,-1
8112a3fc:	10800044 	addi	r2,r2,1
8112a400:	e0c00115 	stw	r3,4(fp)
8112a404:	e0800015 	stw	r2,0(fp)
8112a408:	8c000044 	addi	r16,r17,1
8112a40c:	dd400015 	stw	r21,0(sp)
8112a410:	2463883a 	add	r17,r4,r17
8112a414:	200d883a 	mov	r6,r4
8112a418:	a00b883a 	mov	r5,r20
8112a41c:	800f883a 	mov	r7,r16
8112a420:	b009883a 	mov	r4,r22
8112a424:	8a000005 	stb	r8,0(r17)
8112a428:	112e7340 	call	8112e734 <_mbrtowc_r>
8112a42c:	017fffc4 	movi	r5,-1
8112a430:	11404e26 	beq	r2,r5,8112a56c <__svfscanf_r+0x8f8>
8112a434:	1000601e 	bne	r2,zero,8112a5b8 <__svfscanf_r+0x944>
8112a438:	da009f17 	ldw	r8,636(sp)
8112a43c:	4000641e 	bne	r8,zero,8112a5d0 <__svfscanf_r+0x95c>
8112a440:	a0000015 	stw	zero,0(r20)
8112a444:	9425883a 	add	r18,r18,r16
8112a448:	9967883a 	add	r19,r19,r5
8112a44c:	a5000104 	addi	r20,r20,4
8112a450:	e0800117 	ldw	r2,4(fp)
8112a454:	0023883a 	mov	r17,zero
8112a458:	00804b16 	blt	zero,r2,8112a588 <__svfscanf_r+0x914>
8112a45c:	e00b883a 	mov	r5,fp
8112a460:	b009883a 	mov	r4,r22
8112a464:	1124c500 	call	81124c50 <__srefill_r>
8112a468:	10004726 	beq	r2,zero,8112a588 <__svfscanf_r+0x914>
8112a46c:	88003f1e 	bne	r17,zero,8112a56c <__svfscanf_r+0x8f8>
8112a470:	d8c09f17 	ldw	r3,636(sp)
8112a474:	1800031e 	bne	r3,zero,8112a484 <__svfscanf_r+0x810>
8112a478:	da00a017 	ldw	r8,640(sp)
8112a47c:	42000044 	addi	r8,r8,1
8112a480:	da00a015 	stw	r8,640(sp)
8112a484:	dd009d17 	ldw	r20,628(sp)
8112a488:	a00d883a 	mov	r6,r20
8112a48c:	003e3706 	br	81129d6c <__reset+0xfb109d6c>
8112a490:	8c40040c 	andi	r17,r17,16
8112a494:	04ffffc4 	movi	r19,-1
8112a498:	883fa61e 	bne	r17,zero,8112a334 <__reset+0xfb10a334>
8112a49c:	da009c17 	ldw	r8,624(sp)
8112a4a0:	9abfffc4 	addi	r10,r19,-1
8112a4a4:	44000017 	ldw	r16,0(r8)
8112a4a8:	44400104 	addi	r17,r8,4
8112a4ac:	8007883a 	mov	r3,r16
8112a4b0:	82ab883a 	add	r21,r16,r10
8112a4b4:	00000306 	br	8112a4c4 <__svfscanf_r+0x850>
8112a4b8:	e1000017 	ldw	r4,0(fp)
8112a4bc:	9807883a 	mov	r3,r19
8112a4c0:	20800003 	ldbu	r2,0(r4)
8112a4c4:	10803fcc 	andi	r2,r2,255
8112a4c8:	d9405884 	addi	r5,sp,354
8112a4cc:	2885883a 	add	r2,r5,r2
8112a4d0:	10800007 	ldb	r2,0(r2)
8112a4d4:	10004b26 	beq	r2,zero,8112a604 <__svfscanf_r+0x990>
8112a4d8:	e0800117 	ldw	r2,4(fp)
8112a4dc:	21400044 	addi	r5,r4,1
8112a4e0:	e1400015 	stw	r5,0(fp)
8112a4e4:	10bfffc4 	addi	r2,r2,-1
8112a4e8:	e0800115 	stw	r2,4(fp)
8112a4ec:	20800003 	ldbu	r2,0(r4)
8112a4f0:	1cc00044 	addi	r19,r3,1
8112a4f4:	18800005 	stb	r2,0(r3)
8112a4f8:	1d400726 	beq	r3,r21,8112a518 <__svfscanf_r+0x8a4>
8112a4fc:	e0800117 	ldw	r2,4(fp)
8112a500:	00bfed16 	blt	zero,r2,8112a4b8 <__reset+0xfb10a4b8>
8112a504:	e00b883a 	mov	r5,fp
8112a508:	b009883a 	mov	r4,r22
8112a50c:	1124c500 	call	81124c50 <__srefill_r>
8112a510:	103fe926 	beq	r2,zero,8112a4b8 <__reset+0xfb10a4b8>
8112a514:	84c01526 	beq	r16,r19,8112a56c <__svfscanf_r+0x8f8>
8112a518:	9c21c83a 	sub	r16,r19,r16
8112a51c:	803e1726 	beq	r16,zero,81129d7c <__reset+0xfb109d7c>
8112a520:	da00a017 	ldw	r8,640(sp)
8112a524:	98000005 	stb	zero,0(r19)
8112a528:	dc409c15 	stw	r17,624(sp)
8112a52c:	42000044 	addi	r8,r8,1
8112a530:	da00a015 	stw	r8,640(sp)
8112a534:	9425883a 	add	r18,r18,r16
8112a538:	a00d883a 	mov	r6,r20
8112a53c:	003e0b06 	br	81129d6c <__reset+0xfb109d6c>
8112a540:	017fff84 	movi	r5,-2
8112a544:	11439b1e 	bne	r2,r5,8112b3b4 <__svfscanf_r+0x1740>
8112a548:	8821883a 	mov	r16,r17
8112a54c:	e0800117 	ldw	r2,4(fp)
8112a550:	0082e516 	blt	zero,r2,8112b0e8 <__svfscanf_r+0x1474>
8112a554:	e00b883a 	mov	r5,fp
8112a558:	b009883a 	mov	r4,r22
8112a55c:	1124c500 	call	81124c50 <__srefill_r>
8112a560:	1002e126 	beq	r2,zero,8112b0e8 <__svfscanf_r+0x1474>
8112a564:	dc409f17 	ldw	r17,636(sp)
8112a568:	8002e826 	beq	r16,zero,8112b10c <__svfscanf_r+0x1498>
8112a56c:	da00a017 	ldw	r8,640(sp)
8112a570:	403e9c26 	beq	r8,zero,81129fe4 <__reset+0xfb109fe4>
8112a574:	e080030b 	ldhu	r2,12(fp)
8112a578:	1080100c 	andi	r2,r2,64
8112a57c:	103e991e 	bne	r2,zero,81129fe4 <__reset+0xfb109fe4>
8112a580:	4005883a 	mov	r2,r8
8112a584:	003e9806 	br	81129fe8 <__reset+0xfb109fe8>
8112a588:	983f951e 	bne	r19,zero,8112a3e0 <__reset+0xfb10a3e0>
8112a58c:	003fb806 	br	8112a470 <__reset+0xfb10a470>
8112a590:	da009c17 	ldw	r8,624(sp)
8112a594:	45000017 	ldw	r20,0(r8)
8112a598:	42000104 	addi	r8,r8,4
8112a59c:	da009c15 	stw	r8,624(sp)
8112a5a0:	003f8e06 	br	8112a3dc <__reset+0xfb10a3dc>
8112a5a4:	e00b883a 	mov	r5,fp
8112a5a8:	b009883a 	mov	r4,r22
8112a5ac:	1124c500 	call	81124c50 <__srefill_r>
8112a5b0:	103f3826 	beq	r2,zero,8112a294 <__reset+0xfb10a294>
8112a5b4:	003fed06 	br	8112a56c <__reset+0xfb10a56c>
8112a5b8:	00ffff84 	movi	r3,-2
8112a5bc:	10c0071e 	bne	r2,r3,8112a5dc <__svfscanf_r+0x968>
8112a5c0:	e0800117 	ldw	r2,4(fp)
8112a5c4:	8023883a 	mov	r17,r16
8112a5c8:	00bf8516 	blt	zero,r2,8112a3e0 <__reset+0xfb10a3e0>
8112a5cc:	003fa306 	br	8112a45c <__reset+0xfb10a45c>
8112a5d0:	9425883a 	add	r18,r18,r16
8112a5d4:	9cffffc4 	addi	r19,r19,-1
8112a5d8:	003f9d06 	br	8112a450 <__reset+0xfb10a450>
8112a5dc:	da009f17 	ldw	r8,636(sp)
8112a5e0:	9425883a 	add	r18,r18,r16
8112a5e4:	9cffffc4 	addi	r19,r19,-1
8112a5e8:	403f9826 	beq	r8,zero,8112a44c <__reset+0xfb10a44c>
8112a5ec:	003f9806 	br	8112a450 <__reset+0xfb10a450>
8112a5f0:	8023883a 	mov	r17,r16
8112a5f4:	8821883a 	mov	r16,r17
8112a5f8:	003fce06 	br	8112a534 <__reset+0xfb10a534>
8112a5fc:	803f3d1e 	bne	r16,zero,8112a2f4 <__reset+0xfb10a2f4>
8112a600:	003fda06 	br	8112a56c <__reset+0xfb10a56c>
8112a604:	1827883a 	mov	r19,r3
8112a608:	003fc306 	br	8112a518 <__reset+0xfb10a518>
8112a60c:	803fc91e 	bne	r16,zero,8112a534 <__reset+0xfb10a534>
8112a610:	003dda06 	br	81129d7c <__reset+0xfb109d7c>
8112a614:	da009c17 	ldw	r8,624(sp)
8112a618:	df000015 	stw	fp,0(sp)
8112a61c:	980f883a 	mov	r7,r19
8112a620:	41400017 	ldw	r5,0(r8)
8112a624:	01800044 	movi	r6,1
8112a628:	b009883a 	mov	r4,r22
8112a62c:	112d84c0 	call	8112d84c <_fread_r>
8112a630:	da009c17 	ldw	r8,624(sp)
8112a634:	40c00104 	addi	r3,r8,4
8112a638:	103fcc26 	beq	r2,zero,8112a56c <__reset+0xfb10a56c>
8112a63c:	da00a017 	ldw	r8,640(sp)
8112a640:	dd009d17 	ldw	r20,628(sp)
8112a644:	90a5883a 	add	r18,r18,r2
8112a648:	42000044 	addi	r8,r8,1
8112a64c:	da00a015 	stw	r8,640(sp)
8112a650:	d8c09c15 	stw	r3,624(sp)
8112a654:	a00d883a 	mov	r6,r20
8112a658:	003dc406 	br	81129d6c <__reset+0xfb109d6c>
8112a65c:	e00b883a 	mov	r5,fp
8112a660:	b009883a 	mov	r4,r22
8112a664:	1124c500 	call	81124c50 <__srefill_r>
8112a668:	103e5226 	beq	r2,zero,81129fb4 <__reset+0xfb109fb4>
8112a66c:	003fbf06 	br	8112a56c <__reset+0xfb10a56c>
8112a670:	a0800083 	ldbu	r2,2(r20)
8112a674:	8c400094 	ori	r17,r17,2
8112a678:	a5000084 	addi	r20,r20,2
8112a67c:	10c03fcc 	andi	r3,r2,255
8112a680:	003dc706 	br	81129da0 <__reset+0xfb109da0>
8112a684:	e0800117 	ldw	r2,4(fp)
8112a688:	88e2b03a 	or	r17,r17,r3
8112a68c:	00bef716 	blt	zero,r2,8112a26c <__reset+0xfb10a26c>
8112a690:	003e6f06 	br	8112a050 <__reset+0xfb10a050>
8112a694:	8880004c 	andi	r2,r17,1
8112a698:	10000b1e 	bne	r2,zero,8112a6c8 <__svfscanf_r+0xa54>
8112a69c:	8c40008c 	andi	r17,r17,2
8112a6a0:	88000926 	beq	r17,zero,8112a6c8 <__svfscanf_r+0xa54>
8112a6a4:	da009c17 	ldw	r8,624(sp)
8112a6a8:	9007d7fa 	srai	r3,r18,31
8112a6ac:	dd009d17 	ldw	r20,628(sp)
8112a6b0:	40800017 	ldw	r2,0(r8)
8112a6b4:	42000104 	addi	r8,r8,4
8112a6b8:	da009c15 	stw	r8,624(sp)
8112a6bc:	14800015 	stw	r18,0(r2)
8112a6c0:	10c00115 	stw	r3,4(r2)
8112a6c4:	003da806 	br	81129d68 <__reset+0xfb109d68>
8112a6c8:	da009c17 	ldw	r8,624(sp)
8112a6cc:	dd009d17 	ldw	r20,628(sp)
8112a6d0:	40800017 	ldw	r2,0(r8)
8112a6d4:	42000104 	addi	r8,r8,4
8112a6d8:	da009c15 	stw	r8,624(sp)
8112a6dc:	14800015 	stw	r18,0(r2)
8112a6e0:	003da106 	br	81129d68 <__reset+0xfb109d68>
8112a6e4:	e00b883a 	mov	r5,fp
8112a6e8:	b009883a 	mov	r4,r22
8112a6ec:	1124c500 	call	81124c50 <__srefill_r>
8112a6f0:	103f9e1e 	bne	r2,zero,8112a56c <__reset+0xfb10a56c>
8112a6f4:	b9c00017 	ldw	r7,0(r23)
8112a6f8:	05000104 	movi	r20,4
8112a6fc:	003e6306 	br	8112a08c <__reset+0xfb10a08c>
8112a700:	e00b883a 	mov	r5,fp
8112a704:	b009883a 	mov	r4,r22
8112a708:	1124c500 	call	81124c50 <__srefill_r>
8112a70c:	103f971e 	bne	r2,zero,8112a56c <__reset+0xfb10a56c>
8112a710:	b9c00017 	ldw	r7,0(r23)
8112a714:	003e5706 	br	8112a074 <__reset+0xfb10a074>
8112a718:	e00b883a 	mov	r5,fp
8112a71c:	b009883a 	mov	r4,r22
8112a720:	1124c500 	call	81124c50 <__srefill_r>
8112a724:	103f911e 	bne	r2,zero,8112a56c <__reset+0xfb10a56c>
8112a728:	b9c00017 	ldw	r7,0(r23)
8112a72c:	05000084 	movi	r20,2
8112a730:	003e5606 	br	8112a08c <__reset+0xfb10a08c>
8112a734:	e00b883a 	mov	r5,fp
8112a738:	b009883a 	mov	r4,r22
8112a73c:	1124c500 	call	81124c50 <__srefill_r>
8112a740:	103ef726 	beq	r2,zero,8112a320 <__reset+0xfb10a320>
8112a744:	003f8906 	br	8112a56c <__reset+0xfb10a56c>
8112a748:	e00b883a 	mov	r5,fp
8112a74c:	b009883a 	mov	r4,r22
8112a750:	1124c500 	call	81124c50 <__srefill_r>
8112a754:	103f851e 	bne	r2,zero,8112a56c <__reset+0xfb10a56c>
8112a758:	b9c00017 	ldw	r7,0(r23)
8112a75c:	003f0f06 	br	8112a39c <__reset+0xfb10a39c>
8112a760:	014000c4 	movi	r5,3
8112a764:	a1414a26 	beq	r20,r5,8112ac90 <__svfscanf_r+0x101c>
8112a768:	01000104 	movi	r4,4
8112a76c:	a101f11e 	bne	r20,r4,8112af34 <__svfscanf_r+0x12c0>
8112a770:	b009883a 	mov	r4,r22
8112a774:	112e69c0 	call	8112e69c <_localeconv_r>
8112a778:	10800017 	ldw	r2,0(r2)
8112a77c:	98ffffc4 	addi	r3,r19,-1
8112a780:	d880a315 	stw	r2,652(sp)
8112a784:	00805704 	movi	r2,348
8112a788:	10c21e2e 	bgeu	r2,r3,8112b004 <__svfscanf_r+0x1390>
8112a78c:	9cffa8c4 	addi	r19,r19,-349
8112a790:	dcc0a215 	stw	r19,648(sp)
8112a794:	04c05744 	movi	r19,349
8112a798:	8d01e014 	ori	r20,r17,1920
8112a79c:	0023883a 	mov	r17,zero
8112a7a0:	dc000104 	addi	r16,sp,4
8112a7a4:	8805883a 	mov	r2,r17
8112a7a8:	0019883a 	mov	r12,zero
8112a7ac:	8023883a 	mov	r17,r16
8112a7b0:	b007883a 	mov	r3,r22
8112a7b4:	9821883a 	mov	r16,r19
8112a7b8:	002b883a 	mov	r21,zero
8112a7bc:	d800a515 	stw	zero,660(sp)
8112a7c0:	d800a415 	stw	zero,656(sp)
8112a7c4:	d8009f15 	stw	zero,636(sp)
8112a7c8:	01c01384 	movi	r7,78
8112a7cc:	602d883a 	mov	r22,r12
8112a7d0:	1027883a 	mov	r19,r2
8112a7d4:	e1000017 	ldw	r4,0(fp)
8112a7d8:	21400003 	ldbu	r5,0(r4)
8112a7dc:	28bff544 	addi	r2,r5,-43
8112a7e0:	10803fcc 	andi	r2,r2,255
8112a7e4:	38810e36 	bltu	r7,r2,8112ac20 <__svfscanf_r+0xfac>
8112a7e8:	100490ba 	slli	r2,r2,2
8112a7ec:	01a044f4 	movhi	r6,33043
8112a7f0:	31aa0004 	addi	r6,r6,-22528
8112a7f4:	1185883a 	add	r2,r2,r6
8112a7f8:	10800017 	ldw	r2,0(r2)
8112a7fc:	1000683a 	jmp	r2
8112a800:	8112aaf8 	rdprs	r4,r16,19115
8112a804:	8112ac20 	cmpeqi	r4,r16,19120
8112a808:	8112aaf8 	rdprs	r4,r16,19115
8112a80c:	8112ac20 	cmpeqi	r4,r16,19120
8112a810:	8112ac20 	cmpeqi	r4,r16,19120
8112a814:	8112aacc 	andi	r4,r16,19115
8112a818:	8112a93c 	xorhi	r4,r16,19108
8112a81c:	8112a93c 	xorhi	r4,r16,19108
8112a820:	8112a93c 	xorhi	r4,r16,19108
8112a824:	8112a93c 	xorhi	r4,r16,19108
8112a828:	8112a93c 	xorhi	r4,r16,19108
8112a82c:	8112a93c 	xorhi	r4,r16,19108
8112a830:	8112a93c 	xorhi	r4,r16,19108
8112a834:	8112a93c 	xorhi	r4,r16,19108
8112a838:	8112a93c 	xorhi	r4,r16,19108
8112a83c:	8112ac20 	cmpeqi	r4,r16,19120
8112a840:	8112ac20 	cmpeqi	r4,r16,19120
8112a844:	8112ac20 	cmpeqi	r4,r16,19120
8112a848:	8112ac20 	cmpeqi	r4,r16,19120
8112a84c:	8112ac20 	cmpeqi	r4,r16,19120
8112a850:	8112ac20 	cmpeqi	r4,r16,19120
8112a854:	8112ac20 	cmpeqi	r4,r16,19120
8112a858:	8112ac10 	cmplti	r4,r16,19120
8112a85c:	8112ac20 	cmpeqi	r4,r16,19120
8112a860:	8112ac20 	cmpeqi	r4,r16,19120
8112a864:	8112ac20 	cmpeqi	r4,r16,19120
8112a868:	8112abcc 	andi	r4,r16,19119
8112a86c:	8112abb0 	cmpltui	r4,r16,19118
8112a870:	8112ac20 	cmpeqi	r4,r16,19120
8112a874:	8112ac20 	cmpeqi	r4,r16,19120
8112a878:	8112ab7c 	xorhi	r4,r16,19117
8112a87c:	8112ac20 	cmpeqi	r4,r16,19120
8112a880:	8112ac20 	cmpeqi	r4,r16,19120
8112a884:	8112ac20 	cmpeqi	r4,r16,19120
8112a888:	8112ac20 	cmpeqi	r4,r16,19120
8112a88c:	8112ab44 	addi	r4,r16,19117
8112a890:	8112ac20 	cmpeqi	r4,r16,19120
8112a894:	8112ac20 	cmpeqi	r4,r16,19120
8112a898:	8112ac20 	cmpeqi	r4,r16,19120
8112a89c:	8112ac20 	cmpeqi	r4,r16,19120
8112a8a0:	8112ac20 	cmpeqi	r4,r16,19120
8112a8a4:	8112ab28 	cmpgeui	r4,r16,19116
8112a8a8:	8112ac20 	cmpeqi	r4,r16,19120
8112a8ac:	8112ac20 	cmpeqi	r4,r16,19120
8112a8b0:	8112ac20 	cmpeqi	r4,r16,19120
8112a8b4:	8112ac20 	cmpeqi	r4,r16,19120
8112a8b8:	8112ab0c 	andi	r4,r16,19116
8112a8bc:	8112ac20 	cmpeqi	r4,r16,19120
8112a8c0:	8112ac20 	cmpeqi	r4,r16,19120
8112a8c4:	8112ac20 	cmpeqi	r4,r16,19120
8112a8c8:	8112ac20 	cmpeqi	r4,r16,19120
8112a8cc:	8112ac20 	cmpeqi	r4,r16,19120
8112a8d0:	8112ac20 	cmpeqi	r4,r16,19120
8112a8d4:	8112ac20 	cmpeqi	r4,r16,19120
8112a8d8:	8112ac10 	cmplti	r4,r16,19120
8112a8dc:	8112ac20 	cmpeqi	r4,r16,19120
8112a8e0:	8112ac20 	cmpeqi	r4,r16,19120
8112a8e4:	8112ac20 	cmpeqi	r4,r16,19120
8112a8e8:	8112abcc 	andi	r4,r16,19119
8112a8ec:	8112abb0 	cmpltui	r4,r16,19118
8112a8f0:	8112ac20 	cmpeqi	r4,r16,19120
8112a8f4:	8112ac20 	cmpeqi	r4,r16,19120
8112a8f8:	8112ab7c 	xorhi	r4,r16,19117
8112a8fc:	8112ac20 	cmpeqi	r4,r16,19120
8112a900:	8112ac20 	cmpeqi	r4,r16,19120
8112a904:	8112ac20 	cmpeqi	r4,r16,19120
8112a908:	8112ac20 	cmpeqi	r4,r16,19120
8112a90c:	8112ab44 	addi	r4,r16,19117
8112a910:	8112ac20 	cmpeqi	r4,r16,19120
8112a914:	8112ac20 	cmpeqi	r4,r16,19120
8112a918:	8112ac20 	cmpeqi	r4,r16,19120
8112a91c:	8112ac20 	cmpeqi	r4,r16,19120
8112a920:	8112ac20 	cmpeqi	r4,r16,19120
8112a924:	8112ab28 	cmpgeui	r4,r16,19116
8112a928:	8112ac20 	cmpeqi	r4,r16,19120
8112a92c:	8112ac20 	cmpeqi	r4,r16,19120
8112a930:	8112ac20 	cmpeqi	r4,r16,19120
8112a934:	8112ac20 	cmpeqi	r4,r16,19120
8112a938:	8112ab0c 	andi	r4,r16,19116
8112a93c:	a8803fcc 	andi	r2,r21,255
8112a940:	1080201c 	xori	r2,r2,128
8112a944:	10bfe004 	addi	r2,r2,-128
8112a948:	b085883a 	add	r2,r22,r2
8112a94c:	10000d1e 	bne	r2,zero,8112a984 <__svfscanf_r+0xd10>
8112a950:	00bf9fc4 	movi	r2,-385
8112a954:	a0a8703a 	and	r20,r20,r2
8112a958:	89400005 	stb	r5,0(r17)
8112a95c:	8c400044 	addi	r17,r17,1
8112a960:	e0800117 	ldw	r2,4(fp)
8112a964:	843fffc4 	addi	r16,r16,-1
8112a968:	94800044 	addi	r18,r18,1
8112a96c:	10bfffc4 	addi	r2,r2,-1
8112a970:	e0800115 	stw	r2,4(fp)
8112a974:	0080b40e 	bge	zero,r2,8112ac48 <__svfscanf_r+0xfd4>
8112a978:	21000044 	addi	r4,r4,1
8112a97c:	e1000015 	stw	r4,0(fp)
8112a980:	803f941e 	bne	r16,zero,8112a7d4 <__reset+0xfb10a7d4>
8112a984:	8821883a 	mov	r16,r17
8112a988:	b019883a 	mov	r12,r22
8112a98c:	9823883a 	mov	r17,r19
8112a990:	182d883a 	mov	r22,r3
8112a994:	9801961e 	bne	r19,zero,8112aff0 <__svfscanf_r+0x137c>
8112a998:	633fffc4 	addi	r12,r12,-1
8112a99c:	00800044 	movi	r2,1
8112a9a0:	1302882e 	bgeu	r2,r12,8112b3c4 <__svfscanf_r+0x1750>
8112a9a4:	a8803fcc 	andi	r2,r21,255
8112a9a8:	1080201c 	xori	r2,r2,128
8112a9ac:	10bfe004 	addi	r2,r2,-128
8112a9b0:	113fffc4 	addi	r4,r2,-1
8112a9b4:	01400184 	movi	r5,6
8112a9b8:	29001136 	bltu	r5,r4,8112aa00 <__svfscanf_r+0xd8c>
8112a9bc:	01000084 	movi	r4,2
8112a9c0:	2082900e 	bge	r4,r2,8112b404 <__svfscanf_r+0x1790>
8112a9c4:	00c000c4 	movi	r3,3
8112a9c8:	10c00d26 	beq	r2,r3,8112aa00 <__svfscanf_r+0xd8c>
8112a9cc:	9425c83a 	sub	r18,r18,r16
8112a9d0:	1827883a 	mov	r19,r3
8112a9d4:	843fffc4 	addi	r16,r16,-1
8112a9d8:	81400007 	ldb	r5,0(r16)
8112a9dc:	e00d883a 	mov	r6,fp
8112a9e0:	b009883a 	mov	r4,r22
8112a9e4:	11335e40 	call	811335e4 <_ungetc_r>
8112a9e8:	a8bfffc4 	addi	r2,r21,-1
8112a9ec:	10c03fcc 	andi	r3,r2,255
8112a9f0:	8493883a 	add	r9,r16,r18
8112a9f4:	102b883a 	mov	r21,r2
8112a9f8:	98fff636 	bltu	r19,r3,8112a9d4 <__reset+0xfb10a9d4>
8112a9fc:	4825883a 	mov	r18,r9
8112aa00:	a080400c 	andi	r2,r20,256
8112aa04:	10001426 	beq	r2,zero,8112aa58 <__svfscanf_r+0xde4>
8112aa08:	a081000c 	andi	r2,r20,1024
8112aa0c:	1002571e 	bne	r2,zero,8112b36c <__svfscanf_r+0x16f8>
8112aa10:	817fffc7 	ldb	r5,-1(r16)
8112aa14:	00801944 	movi	r2,101
8112aa18:	84ffffc4 	addi	r19,r16,-1
8112aa1c:	957fffc4 	addi	r21,r18,-1
8112aa20:	28800826 	beq	r5,r2,8112aa44 <__svfscanf_r+0xdd0>
8112aa24:	00801144 	movi	r2,69
8112aa28:	28800626 	beq	r5,r2,8112aa44 <__svfscanf_r+0xdd0>
8112aa2c:	e00d883a 	mov	r6,fp
8112aa30:	b009883a 	mov	r4,r22
8112aa34:	11335e40 	call	811335e4 <_ungetc_r>
8112aa38:	817fff87 	ldb	r5,-2(r16)
8112aa3c:	84ffff84 	addi	r19,r16,-2
8112aa40:	957fff84 	addi	r21,r18,-2
8112aa44:	e00d883a 	mov	r6,fp
8112aa48:	b009883a 	mov	r4,r22
8112aa4c:	11335e40 	call	811335e4 <_ungetc_r>
8112aa50:	a825883a 	mov	r18,r21
8112aa54:	9821883a 	mov	r16,r19
8112aa58:	a080040c 	andi	r2,r20,16
8112aa5c:	103e891e 	bne	r2,zero,8112a484 <__reset+0xfb10a484>
8112aa60:	80000005 	stb	zero,0(r16)
8112aa64:	a081800c 	andi	r2,r20,1536
8112aa68:	01010004 	movi	r4,1024
8112aa6c:	1101dd26 	beq	r2,r4,8112b1e4 <__svfscanf_r+0x1570>
8112aa70:	da00a417 	ldw	r8,656(sp)
8112aa74:	4001e71e 	bne	r8,zero,8112b214 <__svfscanf_r+0x15a0>
8112aa78:	000d883a 	mov	r6,zero
8112aa7c:	d9400104 	addi	r5,sp,4
8112aa80:	b009883a 	mov	r4,r22
8112aa84:	113047c0 	call	8113047c <_strtod_r>
8112aa88:	1021883a 	mov	r16,r2
8112aa8c:	a080004c 	andi	r2,r20,1
8112aa90:	1000021e 	bne	r2,zero,8112aa9c <__svfscanf_r+0xe28>
8112aa94:	a2c0008c 	andi	r11,r20,2
8112aa98:	5801e826 	beq	r11,zero,8112b23c <__svfscanf_r+0x15c8>
8112aa9c:	da009c17 	ldw	r8,624(sp)
8112aaa0:	40800017 	ldw	r2,0(r8)
8112aaa4:	42000104 	addi	r8,r8,4
8112aaa8:	da009c15 	stw	r8,624(sp)
8112aaac:	14000015 	stw	r16,0(r2)
8112aab0:	10c00115 	stw	r3,4(r2)
8112aab4:	da00a017 	ldw	r8,640(sp)
8112aab8:	dd009d17 	ldw	r20,628(sp)
8112aabc:	42000044 	addi	r8,r8,1
8112aac0:	da00a015 	stw	r8,640(sp)
8112aac4:	a00d883a 	mov	r6,r20
8112aac8:	003ca806 	br	81129d6c <__reset+0xfb109d6c>
8112aacc:	a080400c 	andi	r2,r20,256
8112aad0:	103f9a26 	beq	r2,zero,8112a93c <__reset+0xfb10a93c>
8112aad4:	da00a217 	ldw	r8,648(sp)
8112aad8:	00bfdfc4 	movi	r2,-129
8112aadc:	a0a8703a 	and	r20,r20,r2
8112aae0:	9cc00044 	addi	r19,r19,1
8112aae4:	403f9e26 	beq	r8,zero,8112a960 <__reset+0xfb10a960>
8112aae8:	423fffc4 	addi	r8,r8,-1
8112aaec:	da00a215 	stw	r8,648(sp)
8112aaf0:	84000044 	addi	r16,r16,1
8112aaf4:	003f9a06 	br	8112a960 <__reset+0xfb10a960>
8112aaf8:	a080200c 	andi	r2,r20,128
8112aafc:	103fa126 	beq	r2,zero,8112a984 <__reset+0xfb10a984>
8112ab00:	00bfdfc4 	movi	r2,-129
8112ab04:	a0a8703a 	and	r20,r20,r2
8112ab08:	003f9306 	br	8112a958 <__reset+0xfb10a958>
8112ab0c:	a8803fcc 	andi	r2,r21,255
8112ab10:	1080201c 	xori	r2,r2,128
8112ab14:	10bfe004 	addi	r2,r2,-128
8112ab18:	020001c4 	movi	r8,7
8112ab1c:	123f991e 	bne	r2,r8,8112a984 <__reset+0xfb10a984>
8112ab20:	05400204 	movi	r21,8
8112ab24:	003f8c06 	br	8112a958 <__reset+0xfb10a958>
8112ab28:	a8803fcc 	andi	r2,r21,255
8112ab2c:	1080201c 	xori	r2,r2,128
8112ab30:	10bfe004 	addi	r2,r2,-128
8112ab34:	01800184 	movi	r6,6
8112ab38:	11bf921e 	bne	r2,r6,8112a984 <__reset+0xfb10a984>
8112ab3c:	054001c4 	movi	r21,7
8112ab40:	003f8506 	br	8112a958 <__reset+0xfb10a958>
8112ab44:	b000491e 	bne	r22,zero,8112ac6c <__svfscanf_r+0xff8>
8112ab48:	9800031e 	bne	r19,zero,8112ab58 <__svfscanf_r+0xee4>
8112ab4c:	a081c00c 	andi	r2,r20,1792
8112ab50:	0181c004 	movi	r6,1792
8112ab54:	11819f26 	beq	r2,r6,8112b1d4 <__svfscanf_r+0x1560>
8112ab58:	a8803fcc 	andi	r2,r21,255
8112ab5c:	1080201c 	xori	r2,r2,128
8112ab60:	10bfe004 	addi	r2,r2,-128
8112ab64:	01800044 	movi	r6,1
8112ab68:	11800226 	beq	r2,r6,8112ab74 <__svfscanf_r+0xf00>
8112ab6c:	01800104 	movi	r6,4
8112ab70:	11bf841e 	bne	r2,r6,8112a984 <__reset+0xfb10a984>
8112ab74:	ad400044 	addi	r21,r21,1
8112ab78:	003f7706 	br	8112a958 <__reset+0xfb10a958>
8112ab7c:	a8803fcc 	andi	r2,r21,255
8112ab80:	1080201c 	xori	r2,r2,128
8112ab84:	10bfe004 	addi	r2,r2,-128
8112ab88:	10003c1e 	bne	r2,zero,8112ac7c <__svfscanf_r+0x1008>
8112ab8c:	9801141e 	bne	r19,zero,8112afe0 <__svfscanf_r+0x136c>
8112ab90:	a081c00c 	andi	r2,r20,1792
8112ab94:	0181c004 	movi	r6,1792
8112ab98:	11818226 	beq	r2,r6,8112b1a4 <__svfscanf_r+0x1530>
8112ab9c:	8821883a 	mov	r16,r17
8112aba0:	b019883a 	mov	r12,r22
8112aba4:	9823883a 	mov	r17,r19
8112aba8:	182d883a 	mov	r22,r3
8112abac:	003f7a06 	br	8112a998 <__reset+0xfb10a998>
8112abb0:	a8803fcc 	andi	r2,r21,255
8112abb4:	1080201c 	xori	r2,r2,128
8112abb8:	10bfe004 	addi	r2,r2,-128
8112abbc:	01800084 	movi	r6,2
8112abc0:	11bf701e 	bne	r2,r6,8112a984 <__reset+0xfb10a984>
8112abc4:	054000c4 	movi	r21,3
8112abc8:	003f6306 	br	8112a958 <__reset+0xfb10a958>
8112abcc:	a081400c 	andi	r2,r20,1280
8112abd0:	01810004 	movi	r6,1024
8112abd4:	11800326 	beq	r2,r6,8112abe4 <__svfscanf_r+0xf70>
8112abd8:	a184703a 	and	r2,r20,r6
8112abdc:	103f6926 	beq	r2,zero,8112a984 <__reset+0xfb10a984>
8112abe0:	983fee26 	beq	r19,zero,8112ab9c <__reset+0xfb10ab9c>
8112abe4:	a080800c 	andi	r2,r20,512
8112abe8:	1000041e 	bne	r2,zero,8112abfc <__svfscanf_r+0xf88>
8112abec:	da009f17 	ldw	r8,636(sp)
8112abf0:	dc40a515 	stw	r17,660(sp)
8112abf4:	9a27c83a 	sub	r19,r19,r8
8112abf8:	dcc0a415 	stw	r19,656(sp)
8112abfc:	00be1fc4 	movi	r2,-1921
8112ac00:	a0a8703a 	and	r20,r20,r2
8112ac04:	a5006014 	ori	r20,r20,384
8112ac08:	0027883a 	mov	r19,zero
8112ac0c:	003f5206 	br	8112a958 <__reset+0xfb10a958>
8112ac10:	00800044 	movi	r2,1
8112ac14:	b0bf5b1e 	bne	r22,r2,8112a984 <__reset+0xfb10a984>
8112ac18:	05800084 	movi	r22,2
8112ac1c:	003f4e06 	br	8112a958 <__reset+0xfb10a958>
8112ac20:	d980a317 	ldw	r6,652(sp)
8112ac24:	30800003 	ldbu	r2,0(r6)
8112ac28:	29803fcc 	andi	r6,r5,255
8112ac2c:	30bf551e 	bne	r6,r2,8112a984 <__reset+0xfb10a984>
8112ac30:	a080800c 	andi	r2,r20,512
8112ac34:	103f5326 	beq	r2,zero,8112a984 <__reset+0xfb10a984>
8112ac38:	023f5fc4 	movi	r8,-641
8112ac3c:	a228703a 	and	r20,r20,r8
8112ac40:	dcc09f15 	stw	r19,636(sp)
8112ac44:	003f4406 	br	8112a958 <__reset+0xfb10a958>
8112ac48:	1809883a 	mov	r4,r3
8112ac4c:	e00b883a 	mov	r5,fp
8112ac50:	d8c0a615 	stw	r3,664(sp)
8112ac54:	d9c0aa15 	stw	r7,680(sp)
8112ac58:	1124c500 	call	81124c50 <__srefill_r>
8112ac5c:	d8c0a617 	ldw	r3,664(sp)
8112ac60:	d9c0aa17 	ldw	r7,680(sp)
8112ac64:	103f4626 	beq	r2,zero,8112a980 <__reset+0xfb10a980>
8112ac68:	003f4606 	br	8112a984 <__reset+0xfb10a984>
8112ac6c:	00800084 	movi	r2,2
8112ac70:	b0bfb91e 	bne	r22,r2,8112ab58 <__reset+0xfb10ab58>
8112ac74:	058000c4 	movi	r22,3
8112ac78:	003f3706 	br	8112a958 <__reset+0xfb10a958>
8112ac7c:	018000c4 	movi	r6,3
8112ac80:	11bfbc26 	beq	r2,r6,8112ab74 <__reset+0xfb10ab74>
8112ac84:	01800144 	movi	r6,5
8112ac88:	11bfba26 	beq	r2,r6,8112ab74 <__reset+0xfb10ab74>
8112ac8c:	003f3d06 	br	8112a984 <__reset+0xfb10a984>
8112ac90:	98bfffc4 	addi	r2,r19,-1
8112ac94:	01405704 	movi	r5,348
8112ac98:	2880d82e 	bgeu	r5,r2,8112affc <__svfscanf_r+0x1388>
8112ac9c:	99ffa8c4 	addi	r7,r19,-349
8112aca0:	04c05744 	movi	r19,349
8112aca4:	8c436014 	ori	r17,r17,3456
8112aca8:	9013883a 	mov	r9,r18
8112acac:	8825883a 	mov	r18,r17
8112acb0:	dc409e17 	ldw	r17,632(sp)
8112acb4:	0029883a 	mov	r20,zero
8112acb8:	dc000104 	addi	r16,sp,4
8112acbc:	05401344 	movi	r21,77
8112acc0:	02c08004 	movi	r11,512
8112acc4:	01bf7fc4 	movi	r6,-513
8112acc8:	023fdfc4 	movi	r8,-129
8112accc:	20bff544 	addi	r2,r4,-43
8112acd0:	10803fcc 	andi	r2,r2,255
8112acd4:	a8807236 	bltu	r21,r2,8112aea0 <__svfscanf_r+0x122c>
8112acd8:	100490ba 	slli	r2,r2,2
8112acdc:	016044f4 	movhi	r5,33043
8112ace0:	296b3c04 	addi	r5,r5,-21264
8112ace4:	1145883a 	add	r2,r2,r5
8112ace8:	10800017 	ldw	r2,0(r2)
8112acec:	1000683a 	jmp	r2
8112acf0:	8112af24 	muli	r4,r16,19132
8112acf4:	8112aea0 	cmpeqi	r4,r16,19130
8112acf8:	8112af24 	muli	r4,r16,19132
8112acfc:	8112aea0 	cmpeqi	r4,r16,19130
8112ad00:	8112aea0 	cmpeqi	r4,r16,19130
8112ad04:	8112aefc 	xorhi	r4,r16,19131
8112ad08:	8112aedc 	xori	r4,r16,19131
8112ad0c:	8112aedc 	xori	r4,r16,19131
8112ad10:	8112aedc 	xori	r4,r16,19131
8112ad14:	8112aedc 	xori	r4,r16,19131
8112ad18:	8112aedc 	xori	r4,r16,19131
8112ad1c:	8112aedc 	xori	r4,r16,19131
8112ad20:	8112aedc 	xori	r4,r16,19131
8112ad24:	8112ae84 	addi	r4,r16,19130
8112ad28:	8112ae84 	addi	r4,r16,19130
8112ad2c:	8112aea0 	cmpeqi	r4,r16,19130
8112ad30:	8112aea0 	cmpeqi	r4,r16,19130
8112ad34:	8112aea0 	cmpeqi	r4,r16,19130
8112ad38:	8112aea0 	cmpeqi	r4,r16,19130
8112ad3c:	8112aea0 	cmpeqi	r4,r16,19130
8112ad40:	8112aea0 	cmpeqi	r4,r16,19130
8112ad44:	8112aea0 	cmpeqi	r4,r16,19130
8112ad48:	8112ae70 	cmpltui	r4,r16,19129
8112ad4c:	8112ae70 	cmpltui	r4,r16,19129
8112ad50:	8112ae70 	cmpltui	r4,r16,19129
8112ad54:	8112ae70 	cmpltui	r4,r16,19129
8112ad58:	8112ae70 	cmpltui	r4,r16,19129
8112ad5c:	8112ae70 	cmpltui	r4,r16,19129
8112ad60:	8112aea0 	cmpeqi	r4,r16,19130
8112ad64:	8112aea0 	cmpeqi	r4,r16,19130
8112ad68:	8112aea0 	cmpeqi	r4,r16,19130
8112ad6c:	8112aea0 	cmpeqi	r4,r16,19130
8112ad70:	8112aea0 	cmpeqi	r4,r16,19130
8112ad74:	8112aea0 	cmpeqi	r4,r16,19130
8112ad78:	8112aea0 	cmpeqi	r4,r16,19130
8112ad7c:	8112aea0 	cmpeqi	r4,r16,19130
8112ad80:	8112aea0 	cmpeqi	r4,r16,19130
8112ad84:	8112aea0 	cmpeqi	r4,r16,19130
8112ad88:	8112aea0 	cmpeqi	r4,r16,19130
8112ad8c:	8112aea0 	cmpeqi	r4,r16,19130
8112ad90:	8112aea0 	cmpeqi	r4,r16,19130
8112ad94:	8112aea0 	cmpeqi	r4,r16,19130
8112ad98:	8112aea0 	cmpeqi	r4,r16,19130
8112ad9c:	8112aea0 	cmpeqi	r4,r16,19130
8112ada0:	8112aea0 	cmpeqi	r4,r16,19130
8112ada4:	8112ae28 	cmpgeui	r4,r16,19128
8112ada8:	8112aea0 	cmpeqi	r4,r16,19130
8112adac:	8112aea0 	cmpeqi	r4,r16,19130
8112adb0:	8112aea0 	cmpeqi	r4,r16,19130
8112adb4:	8112aea0 	cmpeqi	r4,r16,19130
8112adb8:	8112aea0 	cmpeqi	r4,r16,19130
8112adbc:	8112aea0 	cmpeqi	r4,r16,19130
8112adc0:	8112aea0 	cmpeqi	r4,r16,19130
8112adc4:	8112aea0 	cmpeqi	r4,r16,19130
8112adc8:	8112ae70 	cmpltui	r4,r16,19129
8112adcc:	8112ae70 	cmpltui	r4,r16,19129
8112add0:	8112ae70 	cmpltui	r4,r16,19129
8112add4:	8112ae70 	cmpltui	r4,r16,19129
8112add8:	8112ae70 	cmpltui	r4,r16,19129
8112addc:	8112ae70 	cmpltui	r4,r16,19129
8112ade0:	8112aea0 	cmpeqi	r4,r16,19130
8112ade4:	8112aea0 	cmpeqi	r4,r16,19130
8112ade8:	8112aea0 	cmpeqi	r4,r16,19130
8112adec:	8112aea0 	cmpeqi	r4,r16,19130
8112adf0:	8112aea0 	cmpeqi	r4,r16,19130
8112adf4:	8112aea0 	cmpeqi	r4,r16,19130
8112adf8:	8112aea0 	cmpeqi	r4,r16,19130
8112adfc:	8112aea0 	cmpeqi	r4,r16,19130
8112ae00:	8112aea0 	cmpeqi	r4,r16,19130
8112ae04:	8112aea0 	cmpeqi	r4,r16,19130
8112ae08:	8112aea0 	cmpeqi	r4,r16,19130
8112ae0c:	8112aea0 	cmpeqi	r4,r16,19130
8112ae10:	8112aea0 	cmpeqi	r4,r16,19130
8112ae14:	8112aea0 	cmpeqi	r4,r16,19130
8112ae18:	8112aea0 	cmpeqi	r4,r16,19130
8112ae1c:	8112aea0 	cmpeqi	r4,r16,19130
8112ae20:	8112aea0 	cmpeqi	r4,r16,19130
8112ae24:	8112ae28 	cmpgeui	r4,r16,19128
8112ae28:	9081800c 	andi	r2,r18,1536
8112ae2c:	12c01c1e 	bne	r2,r11,8112aea0 <__svfscanf_r+0x122c>
8112ae30:	91a4703a 	and	r18,r18,r6
8112ae34:	94814014 	ori	r18,r18,1280
8112ae38:	04400404 	movi	r17,16
8112ae3c:	81000005 	stb	r4,0(r16)
8112ae40:	84000044 	addi	r16,r16,1
8112ae44:	e0800117 	ldw	r2,4(fp)
8112ae48:	10bfffc4 	addi	r2,r2,-1
8112ae4c:	e0800115 	stw	r2,4(fp)
8112ae50:	0080540e 	bge	zero,r2,8112afa4 <__svfscanf_r+0x1330>
8112ae54:	18c00044 	addi	r3,r3,1
8112ae58:	e0c00015 	stw	r3,0(fp)
8112ae5c:	9cffffc4 	addi	r19,r19,-1
8112ae60:	98000f26 	beq	r19,zero,8112aea0 <__svfscanf_r+0x122c>
8112ae64:	e0c00017 	ldw	r3,0(fp)
8112ae68:	19000003 	ldbu	r4,0(r3)
8112ae6c:	003f9706 	br	8112accc <__reset+0xfb10accc>
8112ae70:	00800284 	movi	r2,10
8112ae74:	14400a0e 	bge	r2,r17,8112aea0 <__svfscanf_r+0x122c>
8112ae78:	00bd1fc4 	movi	r2,-2945
8112ae7c:	90a4703a 	and	r18,r18,r2
8112ae80:	003fee06 	br	8112ae3c <__reset+0xfb10ae3c>
8112ae84:	01604574 	movhi	r5,33045
8112ae88:	8c63883a 	add	r17,r17,r17
8112ae8c:	294aa684 	addi	r5,r5,10906
8112ae90:	2c45883a 	add	r2,r5,r17
8112ae94:	1440000f 	ldh	r17,0(r2)
8112ae98:	00800204 	movi	r2,8
8112ae9c:	147ff616 	blt	r2,r17,8112ae78 <__reset+0xfb10ae78>
8112aea0:	dc409e15 	stw	r17,632(sp)
8112aea4:	9023883a 	mov	r17,r18
8112aea8:	8880400c 	andi	r2,r17,256
8112aeac:	4825883a 	mov	r18,r9
8112aeb0:	10000426 	beq	r2,zero,8112aec4 <__svfscanf_r+0x1250>
8112aeb4:	d9800104 	addi	r6,sp,4
8112aeb8:	3400be36 	bltu	r6,r16,8112b1b4 <__svfscanf_r+0x1540>
8112aebc:	da000104 	addi	r8,sp,4
8112aec0:	443bae26 	beq	r8,r16,81129d7c <__reset+0xfb109d7c>
8112aec4:	8880040c 	andi	r2,r17,16
8112aec8:	10009326 	beq	r2,zero,8112b118 <__svfscanf_r+0x14a4>
8112aecc:	d8800104 	addi	r2,sp,4
8112aed0:	80a1c83a 	sub	r16,r16,r2
8112aed4:	8521883a 	add	r16,r16,r20
8112aed8:	003d0606 	br	8112a2f4 <__reset+0xfb10a2f4>
8112aedc:	01604574 	movhi	r5,33045
8112aee0:	8c63883a 	add	r17,r17,r17
8112aee4:	294aa684 	addi	r5,r5,10906
8112aee8:	2c45883a 	add	r2,r5,r17
8112aeec:	1440000f 	ldh	r17,0(r2)
8112aef0:	00bd1fc4 	movi	r2,-2945
8112aef4:	90a4703a 	and	r18,r18,r2
8112aef8:	003fd006 	br	8112ae3c <__reset+0xfb10ae3c>
8112aefc:	9082000c 	andi	r2,r18,2048
8112af00:	103fce26 	beq	r2,zero,8112ae3c <__reset+0xfb10ae3c>
8112af04:	8800021e 	bne	r17,zero,8112af10 <__svfscanf_r+0x129c>
8112af08:	94808014 	ori	r18,r18,512
8112af0c:	04400204 	movi	r17,8
8112af10:	9081000c 	andi	r2,r18,1024
8112af14:	10009426 	beq	r2,zero,8112b168 <__svfscanf_r+0x14f4>
8112af18:	00be9fc4 	movi	r2,-1409
8112af1c:	90a4703a 	and	r18,r18,r2
8112af20:	003fc606 	br	8112ae3c <__reset+0xfb10ae3c>
8112af24:	9080200c 	andi	r2,r18,128
8112af28:	103fdd26 	beq	r2,zero,8112aea0 <__reset+0xfb10aea0>
8112af2c:	9224703a 	and	r18,r18,r8
8112af30:	003fc206 	br	8112ae3c <__reset+0xfb10ae3c>
8112af34:	9800011e 	bne	r19,zero,8112af3c <__svfscanf_r+0x12c8>
8112af38:	04ffffc4 	movi	r19,-1
8112af3c:	8900004c 	andi	r4,r17,1
8112af40:	20005b1e 	bne	r4,zero,8112b0b0 <__svfscanf_r+0x143c>
8112af44:	8c40040c 	andi	r17,r17,16
8112af48:	88003026 	beq	r17,zero,8112b00c <__svfscanf_r+0x1398>
8112af4c:	0021883a 	mov	r16,zero
8112af50:	00000306 	br	8112af60 <__svfscanf_r+0x12ec>
8112af54:	18800003 	ldbu	r2,0(r3)
8112af58:	3885883a 	add	r2,r7,r2
8112af5c:	10800043 	ldbu	r2,1(r2)
8112af60:	1080020c 	andi	r2,r2,8
8112af64:	103ce31e 	bne	r2,zero,8112a2f4 <__reset+0xfb10a2f4>
8112af68:	e0800117 	ldw	r2,4(fp)
8112af6c:	18c00044 	addi	r3,r3,1
8112af70:	84000044 	addi	r16,r16,1
8112af74:	10bfffc4 	addi	r2,r2,-1
8112af78:	e0800115 	stw	r2,4(fp)
8112af7c:	e0c00015 	stw	r3,0(fp)
8112af80:	84fcdc26 	beq	r16,r19,8112a2f4 <__reset+0xfb10a2f4>
8112af84:	00bff316 	blt	zero,r2,8112af54 <__reset+0xfb10af54>
8112af88:	e00b883a 	mov	r5,fp
8112af8c:	b009883a 	mov	r4,r22
8112af90:	1124c500 	call	81124c50 <__srefill_r>
8112af94:	103cd71e 	bne	r2,zero,8112a2f4 <__reset+0xfb10a2f4>
8112af98:	b9c00017 	ldw	r7,0(r23)
8112af9c:	e0c00017 	ldw	r3,0(fp)
8112afa0:	003fec06 	br	8112af54 <__reset+0xfb10af54>
8112afa4:	e00b883a 	mov	r5,fp
8112afa8:	b009883a 	mov	r4,r22
8112afac:	d980a715 	stw	r6,668(sp)
8112afb0:	d9c0aa15 	stw	r7,680(sp)
8112afb4:	da00a815 	stw	r8,672(sp)
8112afb8:	da40a915 	stw	r9,676(sp)
8112afbc:	dac0a615 	stw	r11,664(sp)
8112afc0:	1124c500 	call	81124c50 <__srefill_r>
8112afc4:	d980a717 	ldw	r6,668(sp)
8112afc8:	d9c0aa17 	ldw	r7,680(sp)
8112afcc:	da00a817 	ldw	r8,672(sp)
8112afd0:	da40a917 	ldw	r9,676(sp)
8112afd4:	dac0a617 	ldw	r11,664(sp)
8112afd8:	103fa026 	beq	r2,zero,8112ae5c <__reset+0xfb10ae5c>
8112afdc:	003fb006 	br	8112aea0 <__reset+0xfb10aea0>
8112afe0:	8821883a 	mov	r16,r17
8112afe4:	b019883a 	mov	r12,r22
8112afe8:	9823883a 	mov	r17,r19
8112afec:	182d883a 	mov	r22,r3
8112aff0:	00bfbfc4 	movi	r2,-257
8112aff4:	a0a8703a 	and	r20,r20,r2
8112aff8:	003e6706 	br	8112a998 <__reset+0xfb10a998>
8112affc:	000f883a 	mov	r7,zero
8112b000:	003f2806 	br	8112aca4 <__reset+0xfb10aca4>
8112b004:	d800a215 	stw	zero,648(sp)
8112b008:	003de306 	br	8112a798 <__reset+0xfb10a798>
8112b00c:	da009c17 	ldw	r8,624(sp)
8112b010:	9abfffc4 	addi	r10,r19,-1
8112b014:	44400017 	ldw	r17,0(r8)
8112b018:	44000104 	addi	r16,r8,4
8112b01c:	880b883a 	mov	r5,r17
8112b020:	8aa9883a 	add	r20,r17,r10
8112b024:	00000606 	br	8112b040 <__svfscanf_r+0x13cc>
8112b028:	e0c00017 	ldw	r3,0(fp)
8112b02c:	b9000017 	ldw	r4,0(r23)
8112b030:	a80b883a 	mov	r5,r21
8112b034:	18800003 	ldbu	r2,0(r3)
8112b038:	2085883a 	add	r2,r4,r2
8112b03c:	10800043 	ldbu	r2,1(r2)
8112b040:	1080020c 	andi	r2,r2,8
8112b044:	1000551e 	bne	r2,zero,8112b19c <__svfscanf_r+0x1528>
8112b048:	e0800117 	ldw	r2,4(fp)
8112b04c:	19000044 	addi	r4,r3,1
8112b050:	e1000015 	stw	r4,0(fp)
8112b054:	10bfffc4 	addi	r2,r2,-1
8112b058:	e0800115 	stw	r2,4(fp)
8112b05c:	18800003 	ldbu	r2,0(r3)
8112b060:	2d400044 	addi	r21,r5,1
8112b064:	a827883a 	mov	r19,r21
8112b068:	28800005 	stb	r2,0(r5)
8112b06c:	2d000626 	beq	r5,r20,8112b088 <__svfscanf_r+0x1414>
8112b070:	e0800117 	ldw	r2,4(fp)
8112b074:	00bfec16 	blt	zero,r2,8112b028 <__reset+0xfb10b028>
8112b078:	e00b883a 	mov	r5,fp
8112b07c:	b009883a 	mov	r4,r22
8112b080:	1124c500 	call	81124c50 <__srefill_r>
8112b084:	103fe826 	beq	r2,zero,8112b028 <__reset+0xfb10b028>
8112b088:	da00a017 	ldw	r8,640(sp)
8112b08c:	dd009d17 	ldw	r20,628(sp)
8112b090:	9c63c83a 	sub	r17,r19,r17
8112b094:	42000044 	addi	r8,r8,1
8112b098:	98000005 	stb	zero,0(r19)
8112b09c:	9465883a 	add	r18,r18,r17
8112b0a0:	da00a015 	stw	r8,640(sp)
8112b0a4:	dc009c15 	stw	r16,624(sp)
8112b0a8:	a00d883a 	mov	r6,r20
8112b0ac:	003b2f06 	br	81129d6c <__reset+0xfb109d6c>
8112b0b0:	dd409904 	addi	r21,sp,612
8112b0b4:	8c40040c 	andi	r17,r17,16
8112b0b8:	01800204 	movi	r6,8
8112b0bc:	000b883a 	mov	r5,zero
8112b0c0:	a809883a 	mov	r4,r21
8112b0c4:	11248500 	call	81124850 <memset>
8112b0c8:	8800401e 	bne	r17,zero,8112b1cc <__svfscanf_r+0x1558>
8112b0cc:	da009c17 	ldw	r8,624(sp)
8112b0d0:	45000017 	ldw	r20,0(r8)
8112b0d4:	42000104 	addi	r8,r8,4
8112b0d8:	da009c15 	stw	r8,624(sp)
8112b0dc:	000d883a 	mov	r6,zero
8112b0e0:	3021883a 	mov	r16,r6
8112b0e4:	dc409f15 	stw	r17,636(sp)
8112b0e8:	e0800017 	ldw	r2,0(fp)
8112b0ec:	b8c00017 	ldw	r3,0(r23)
8112b0f0:	10800003 	ldbu	r2,0(r2)
8112b0f4:	1885883a 	add	r2,r3,r2
8112b0f8:	10800043 	ldbu	r2,1(r2)
8112b0fc:	1080020c 	andi	r2,r2,8
8112b100:	1000011e 	bne	r2,zero,8112b108 <__svfscanf_r+0x1494>
8112b104:	9800701e 	bne	r19,zero,8112b2c8 <__svfscanf_r+0x1654>
8112b108:	dc409f17 	ldw	r17,636(sp)
8112b10c:	883cdd1e 	bne	r17,zero,8112a484 <__reset+0xfb10a484>
8112b110:	a0000015 	stw	zero,0(r20)
8112b114:	003cd806 	br	8112a478 <__reset+0xfb10a478>
8112b118:	d9c09e17 	ldw	r7,632(sp)
8112b11c:	da00a117 	ldw	r8,644(sp)
8112b120:	000d883a 	mov	r6,zero
8112b124:	d9400104 	addi	r5,sp,4
8112b128:	b009883a 	mov	r4,r22
8112b12c:	80000005 	stb	zero,0(r16)
8112b130:	403ee83a 	callr	r8
8112b134:	88c0080c 	andi	r3,r17,32
8112b138:	1800121e 	bne	r3,zero,8112b184 <__svfscanf_r+0x1510>
8112b13c:	88c0010c 	andi	r3,r17,4
8112b140:	18004d26 	beq	r3,zero,8112b278 <__svfscanf_r+0x1604>
8112b144:	da009c17 	ldw	r8,624(sp)
8112b148:	40c00017 	ldw	r3,0(r8)
8112b14c:	42000104 	addi	r8,r8,4
8112b150:	da009c15 	stw	r8,624(sp)
8112b154:	1880000d 	sth	r2,0(r3)
8112b158:	da00a017 	ldw	r8,640(sp)
8112b15c:	42000044 	addi	r8,r8,1
8112b160:	da00a015 	stw	r8,640(sp)
8112b164:	003f5906 	br	8112aecc <__reset+0xfb10aecc>
8112b168:	00bf1fc4 	movi	r2,-897
8112b16c:	90a4703a 	and	r18,r18,r2
8112b170:	38000226 	beq	r7,zero,8112b17c <__svfscanf_r+0x1508>
8112b174:	39ffffc4 	addi	r7,r7,-1
8112b178:	9cc00044 	addi	r19,r19,1
8112b17c:	a5000044 	addi	r20,r20,1
8112b180:	003f3006 	br	8112ae44 <__reset+0xfb10ae44>
8112b184:	da009c17 	ldw	r8,624(sp)
8112b188:	40c00017 	ldw	r3,0(r8)
8112b18c:	42000104 	addi	r8,r8,4
8112b190:	da009c15 	stw	r8,624(sp)
8112b194:	18800015 	stw	r2,0(r3)
8112b198:	003fef06 	br	8112b158 <__reset+0xfb10b158>
8112b19c:	2827883a 	mov	r19,r5
8112b1a0:	003fb906 	br	8112b088 <__reset+0xfb10b088>
8112b1a4:	01be1fc4 	movi	r6,-1921
8112b1a8:	a1a8703a 	and	r20,r20,r6
8112b1ac:	05400044 	movi	r21,1
8112b1b0:	003de906 	br	8112a958 <__reset+0xfb10a958>
8112b1b4:	817fffc7 	ldb	r5,-1(r16)
8112b1b8:	e00d883a 	mov	r6,fp
8112b1bc:	b009883a 	mov	r4,r22
8112b1c0:	843fffc4 	addi	r16,r16,-1
8112b1c4:	11335e40 	call	811335e4 <_ungetc_r>
8112b1c8:	003f3c06 	br	8112aebc <__reset+0xfb10aebc>
8112b1cc:	dd009b04 	addi	r20,sp,620
8112b1d0:	003fc206 	br	8112b0dc <__reset+0xfb10b0dc>
8112b1d4:	00be1fc4 	movi	r2,-1921
8112b1d8:	a0a8703a 	and	r20,r20,r2
8112b1dc:	05800044 	movi	r22,1
8112b1e0:	003ddd06 	br	8112a958 <__reset+0xfb10a958>
8112b1e4:	d8c09f17 	ldw	r3,636(sp)
8112b1e8:	88e3c83a 	sub	r17,r17,r3
8112b1ec:	044dc83a 	sub	r6,zero,r17
8112b1f0:	883e2126 	beq	r17,zero,8112aa78 <__reset+0xfb10aa78>
8112b1f4:	d88055c4 	addi	r2,sp,343
8112b1f8:	80800136 	bltu	r16,r2,8112b200 <__svfscanf_r+0x158c>
8112b1fc:	dc005584 	addi	r16,sp,342
8112b200:	01604574 	movhi	r5,33045
8112b204:	294aa504 	addi	r5,r5,10900
8112b208:	8009883a 	mov	r4,r16
8112b20c:	1124f640 	call	81124f64 <sprintf>
8112b210:	003e1906 	br	8112aa78 <__reset+0xfb10aa78>
8112b214:	d8c0a517 	ldw	r3,660(sp)
8112b218:	000d883a 	mov	r6,zero
8112b21c:	01c00284 	movi	r7,10
8112b220:	19400044 	addi	r5,r3,1
8112b224:	b009883a 	mov	r4,r22
8112b228:	11252540 	call	81125254 <_strtol_r>
8112b22c:	da00a417 	ldw	r8,656(sp)
8112b230:	dc00a517 	ldw	r16,660(sp)
8112b234:	120dc83a 	sub	r6,r2,r8
8112b238:	003fee06 	br	8112b1f4 <__reset+0xfb10b1f4>
8112b23c:	da009c17 	ldw	r8,624(sp)
8112b240:	180b883a 	mov	r5,r3
8112b244:	8009883a 	mov	r4,r16
8112b248:	45000017 	ldw	r20,0(r8)
8112b24c:	44400104 	addi	r17,r8,4
8112b250:	d8c0a615 	stw	r3,664(sp)
8112b254:	11301e80 	call	811301e8 <__fpclassifyd>
8112b258:	d8c0a617 	ldw	r3,664(sp)
8112b25c:	10006426 	beq	r2,zero,8112b3f0 <__svfscanf_r+0x177c>
8112b260:	8009883a 	mov	r4,r16
8112b264:	180b883a 	mov	r5,r3
8112b268:	11232d00 	call	811232d0 <__truncdfsf2>
8112b26c:	a0800015 	stw	r2,0(r20)
8112b270:	dc409c15 	stw	r17,624(sp)
8112b274:	003e0f06 	br	8112aab4 <__reset+0xfb10aab4>
8112b278:	88c0004c 	andi	r3,r17,1
8112b27c:	183fc11e 	bne	r3,zero,8112b184 <__reset+0xfb10b184>
8112b280:	8c40008c 	andi	r17,r17,2
8112b284:	883fbf26 	beq	r17,zero,8112b184 <__reset+0xfb10b184>
8112b288:	da00a117 	ldw	r8,644(sp)
8112b28c:	00a044f4 	movhi	r2,33043
8112b290:	1086e704 	addi	r2,r2,7068
8112b294:	d9c09e17 	ldw	r7,632(sp)
8112b298:	000d883a 	mov	r6,zero
8112b29c:	d9400104 	addi	r5,sp,4
8112b2a0:	b009883a 	mov	r4,r22
8112b2a4:	40806226 	beq	r8,r2,8112b430 <__svfscanf_r+0x17bc>
8112b2a8:	11254cc0 	call	811254cc <_strtoll_r>
8112b2ac:	da009c17 	ldw	r8,624(sp)
8112b2b0:	41000017 	ldw	r4,0(r8)
8112b2b4:	42000104 	addi	r8,r8,4
8112b2b8:	da009c15 	stw	r8,624(sp)
8112b2bc:	20800015 	stw	r2,0(r4)
8112b2c0:	20c00115 	stw	r3,4(r4)
8112b2c4:	003fa406 	br	8112b158 <__reset+0xfb10b158>
8112b2c8:	112e6780 	call	8112e678 <__locale_mb_cur_max>
8112b2cc:	80bca726 	beq	r16,r2,8112a56c <__reset+0xfb10a56c>
8112b2d0:	e0800017 	ldw	r2,0(fp)
8112b2d4:	e1000117 	ldw	r4,4(fp)
8112b2d8:	d8c00104 	addi	r3,sp,4
8112b2dc:	12000003 	ldbu	r8,0(r2)
8112b2e0:	213fffc4 	addi	r4,r4,-1
8112b2e4:	10800044 	addi	r2,r2,1
8112b2e8:	e1000115 	stw	r4,4(fp)
8112b2ec:	e0800015 	stw	r2,0(fp)
8112b2f0:	84400044 	addi	r17,r16,1
8112b2f4:	dd400015 	stw	r21,0(sp)
8112b2f8:	1c21883a 	add	r16,r3,r16
8112b2fc:	b009883a 	mov	r4,r22
8112b300:	880f883a 	mov	r7,r17
8112b304:	180d883a 	mov	r6,r3
8112b308:	a00b883a 	mov	r5,r20
8112b30c:	82000005 	stb	r8,0(r16)
8112b310:	112e7340 	call	8112e734 <_mbrtowc_r>
8112b314:	013fffc4 	movi	r4,-1
8112b318:	113c9426 	beq	r2,r4,8112a56c <__reset+0xfb10a56c>
8112b31c:	103c881e 	bne	r2,zero,8112a540 <__reset+0xfb10a540>
8112b320:	a0000015 	stw	zero,0(r20)
8112b324:	0009883a 	mov	r4,zero
8112b328:	112e5b80 	call	8112e5b8 <iswspace>
8112b32c:	10001a26 	beq	r2,zero,8112b398 <__svfscanf_r+0x1724>
8112b330:	8821883a 	mov	r16,r17
8112b334:	dc409f17 	ldw	r17,636(sp)
8112b338:	803f7426 	beq	r16,zero,8112b10c <__reset+0xfb10b10c>
8112b33c:	843fffc4 	addi	r16,r16,-1
8112b340:	d9800104 	addi	r6,sp,4
8112b344:	342b883a 	add	r21,r6,r16
8112b348:	00000106 	br	8112b350 <__svfscanf_r+0x16dc>
8112b34c:	843fffc4 	addi	r16,r16,-1
8112b350:	a9400003 	ldbu	r5,0(r21)
8112b354:	e00d883a 	mov	r6,fp
8112b358:	b009883a 	mov	r4,r22
8112b35c:	11335e40 	call	811335e4 <_ungetc_r>
8112b360:	ad7fffc4 	addi	r21,r21,-1
8112b364:	803ff91e 	bne	r16,zero,8112b34c <__reset+0xfb10b34c>
8112b368:	003f6806 	br	8112b10c <__reset+0xfb10b10c>
8112b36c:	d9800104 	addi	r6,sp,4
8112b370:	802b883a 	mov	r21,r16
8112b374:	343a812e 	bgeu	r6,r16,81129d7c <__reset+0xfb109d7c>
8112b378:	ad7fffc4 	addi	r21,r21,-1
8112b37c:	a9400007 	ldb	r5,0(r21)
8112b380:	e00d883a 	mov	r6,fp
8112b384:	b009883a 	mov	r4,r22
8112b388:	11335e40 	call	811335e4 <_ungetc_r>
8112b38c:	da000104 	addi	r8,sp,4
8112b390:	457ff91e 	bne	r8,r21,8112b378 <__reset+0xfb10b378>
8112b394:	003a7906 	br	81129d7c <__reset+0xfb109d7c>
8112b398:	da009f17 	ldw	r8,636(sp)
8112b39c:	9465883a 	add	r18,r18,r17
8112b3a0:	9cffffc4 	addi	r19,r19,-1
8112b3a4:	4000051e 	bne	r8,zero,8112b3bc <__svfscanf_r+0x1748>
8112b3a8:	a5000104 	addi	r20,r20,4
8112b3ac:	0021883a 	mov	r16,zero
8112b3b0:	003c6606 	br	8112a54c <__reset+0xfb10a54c>
8112b3b4:	a1000017 	ldw	r4,0(r20)
8112b3b8:	003fdb06 	br	8112b328 <__reset+0xfb10b328>
8112b3bc:	0021883a 	mov	r16,zero
8112b3c0:	003c6206 	br	8112a54c <__reset+0xfb10a54c>
8112b3c4:	d8800104 	addi	r2,sp,4
8112b3c8:	802b883a 	mov	r21,r16
8112b3cc:	143a6b2e 	bgeu	r2,r16,81129d7c <__reset+0xfb109d7c>
8112b3d0:	ad7fffc4 	addi	r21,r21,-1
8112b3d4:	a9400007 	ldb	r5,0(r21)
8112b3d8:	e00d883a 	mov	r6,fp
8112b3dc:	b009883a 	mov	r4,r22
8112b3e0:	11335e40 	call	811335e4 <_ungetc_r>
8112b3e4:	d8c00104 	addi	r3,sp,4
8112b3e8:	1d7ff91e 	bne	r3,r21,8112b3d0 <__reset+0xfb10b3d0>
8112b3ec:	003a6306 	br	81129d7c <__reset+0xfb109d7c>
8112b3f0:	0009883a 	mov	r4,zero
8112b3f4:	113032c0 	call	8113032c <nanf>
8112b3f8:	a0800015 	stw	r2,0(r20)
8112b3fc:	dc409c15 	stw	r17,624(sp)
8112b400:	003dac06 	br	8112aab4 <__reset+0xfb10aab4>
8112b404:	d9000104 	addi	r4,sp,4
8112b408:	802b883a 	mov	r21,r16
8112b40c:	243a5b2e 	bgeu	r4,r16,81129d7c <__reset+0xfb109d7c>
8112b410:	ad7fffc4 	addi	r21,r21,-1
8112b414:	a9400007 	ldb	r5,0(r21)
8112b418:	e00d883a 	mov	r6,fp
8112b41c:	b009883a 	mov	r4,r22
8112b420:	11335e40 	call	811335e4 <_ungetc_r>
8112b424:	d9400104 	addi	r5,sp,4
8112b428:	2d7ff91e 	bne	r5,r21,8112b410 <__reset+0xfb10b410>
8112b42c:	003a5306 	br	81129d7c <__reset+0xfb109d7c>
8112b430:	1131e0c0 	call	81131e0c <_strtoull_r>
8112b434:	003f9d06 	br	8112b2ac <__reset+0xfb10b2ac>

8112b438 <vfscanf>:
8112b438:	00a04574 	movhi	r2,33045
8112b43c:	defffb04 	addi	sp,sp,-20
8112b440:	10945c04 	addi	r2,r2,20848
8112b444:	de00012e 	bgeu	sp,et,8112b44c <vfscanf+0x14>
8112b448:	003b68fa 	trap	3
8112b44c:	dc000215 	stw	r16,8(sp)
8112b450:	14000017 	ldw	r16,0(r2)
8112b454:	dc400315 	stw	r17,12(sp)
8112b458:	dfc00415 	stw	ra,16(sp)
8112b45c:	2023883a 	mov	r17,r4
8112b460:	80000826 	beq	r16,zero,8112b484 <vfscanf+0x4c>
8112b464:	80800e17 	ldw	r2,56(r16)
8112b468:	1000061e 	bne	r2,zero,8112b484 <vfscanf+0x4c>
8112b46c:	8009883a 	mov	r4,r16
8112b470:	d9400015 	stw	r5,0(sp)
8112b474:	d9800115 	stw	r6,4(sp)
8112b478:	112d7500 	call	8112d750 <__sinit>
8112b47c:	d9800117 	ldw	r6,4(sp)
8112b480:	d9400017 	ldw	r5,0(sp)
8112b484:	300f883a 	mov	r7,r6
8112b488:	8009883a 	mov	r4,r16
8112b48c:	280d883a 	mov	r6,r5
8112b490:	880b883a 	mov	r5,r17
8112b494:	dfc00417 	ldw	ra,16(sp)
8112b498:	dc400317 	ldw	r17,12(sp)
8112b49c:	dc000217 	ldw	r16,8(sp)
8112b4a0:	dec00504 	addi	sp,sp,20
8112b4a4:	1129c741 	jmpi	81129c74 <__svfscanf_r>

8112b4a8 <__svfscanf>:
8112b4a8:	00a04574 	movhi	r2,33045
8112b4ac:	10945c04 	addi	r2,r2,20848
8112b4b0:	300f883a 	mov	r7,r6
8112b4b4:	280d883a 	mov	r6,r5
8112b4b8:	200b883a 	mov	r5,r4
8112b4bc:	11000017 	ldw	r4,0(r2)
8112b4c0:	1129c741 	jmpi	81129c74 <__svfscanf_r>

8112b4c4 <_vfscanf_r>:
8112b4c4:	defffb04 	addi	sp,sp,-20
8112b4c8:	de00012e 	bgeu	sp,et,8112b4d0 <_vfscanf_r+0xc>
8112b4cc:	003b68fa 	trap	3
8112b4d0:	dc000315 	stw	r16,12(sp)
8112b4d4:	dfc00415 	stw	ra,16(sp)
8112b4d8:	2021883a 	mov	r16,r4
8112b4dc:	20000926 	beq	r4,zero,8112b504 <_vfscanf_r+0x40>
8112b4e0:	20800e17 	ldw	r2,56(r4)
8112b4e4:	1000071e 	bne	r2,zero,8112b504 <_vfscanf_r+0x40>
8112b4e8:	d9400015 	stw	r5,0(sp)
8112b4ec:	d9800115 	stw	r6,4(sp)
8112b4f0:	d9c00215 	stw	r7,8(sp)
8112b4f4:	112d7500 	call	8112d750 <__sinit>
8112b4f8:	d9c00217 	ldw	r7,8(sp)
8112b4fc:	d9800117 	ldw	r6,4(sp)
8112b500:	d9400017 	ldw	r5,0(sp)
8112b504:	8009883a 	mov	r4,r16
8112b508:	dfc00417 	ldw	ra,16(sp)
8112b50c:	dc000317 	ldw	r16,12(sp)
8112b510:	dec00504 	addi	sp,sp,20
8112b514:	1129c741 	jmpi	81129c74 <__svfscanf_r>

8112b518 <__swbuf_r>:
8112b518:	defffb04 	addi	sp,sp,-20
8112b51c:	de00012e 	bgeu	sp,et,8112b524 <__swbuf_r+0xc>
8112b520:	003b68fa 	trap	3
8112b524:	dcc00315 	stw	r19,12(sp)
8112b528:	dc800215 	stw	r18,8(sp)
8112b52c:	dc000015 	stw	r16,0(sp)
8112b530:	dfc00415 	stw	ra,16(sp)
8112b534:	dc400115 	stw	r17,4(sp)
8112b538:	2025883a 	mov	r18,r4
8112b53c:	2827883a 	mov	r19,r5
8112b540:	3021883a 	mov	r16,r6
8112b544:	20000226 	beq	r4,zero,8112b550 <__swbuf_r+0x38>
8112b548:	20800e17 	ldw	r2,56(r4)
8112b54c:	10004226 	beq	r2,zero,8112b658 <__swbuf_r+0x140>
8112b550:	80800617 	ldw	r2,24(r16)
8112b554:	8100030b 	ldhu	r4,12(r16)
8112b558:	80800215 	stw	r2,8(r16)
8112b55c:	2080020c 	andi	r2,r4,8
8112b560:	10003626 	beq	r2,zero,8112b63c <__swbuf_r+0x124>
8112b564:	80c00417 	ldw	r3,16(r16)
8112b568:	18003426 	beq	r3,zero,8112b63c <__swbuf_r+0x124>
8112b56c:	2088000c 	andi	r2,r4,8192
8112b570:	9c403fcc 	andi	r17,r19,255
8112b574:	10001a26 	beq	r2,zero,8112b5e0 <__swbuf_r+0xc8>
8112b578:	80800017 	ldw	r2,0(r16)
8112b57c:	81000517 	ldw	r4,20(r16)
8112b580:	10c7c83a 	sub	r3,r2,r3
8112b584:	1900200e 	bge	r3,r4,8112b608 <__swbuf_r+0xf0>
8112b588:	18c00044 	addi	r3,r3,1
8112b58c:	81000217 	ldw	r4,8(r16)
8112b590:	11400044 	addi	r5,r2,1
8112b594:	81400015 	stw	r5,0(r16)
8112b598:	213fffc4 	addi	r4,r4,-1
8112b59c:	81000215 	stw	r4,8(r16)
8112b5a0:	14c00005 	stb	r19,0(r2)
8112b5a4:	80800517 	ldw	r2,20(r16)
8112b5a8:	10c01e26 	beq	r2,r3,8112b624 <__swbuf_r+0x10c>
8112b5ac:	8080030b 	ldhu	r2,12(r16)
8112b5b0:	1080004c 	andi	r2,r2,1
8112b5b4:	10000226 	beq	r2,zero,8112b5c0 <__swbuf_r+0xa8>
8112b5b8:	00800284 	movi	r2,10
8112b5bc:	88801926 	beq	r17,r2,8112b624 <__swbuf_r+0x10c>
8112b5c0:	8805883a 	mov	r2,r17
8112b5c4:	dfc00417 	ldw	ra,16(sp)
8112b5c8:	dcc00317 	ldw	r19,12(sp)
8112b5cc:	dc800217 	ldw	r18,8(sp)
8112b5d0:	dc400117 	ldw	r17,4(sp)
8112b5d4:	dc000017 	ldw	r16,0(sp)
8112b5d8:	dec00504 	addi	sp,sp,20
8112b5dc:	f800283a 	ret
8112b5e0:	81401917 	ldw	r5,100(r16)
8112b5e4:	00b7ffc4 	movi	r2,-8193
8112b5e8:	21080014 	ori	r4,r4,8192
8112b5ec:	2884703a 	and	r2,r5,r2
8112b5f0:	80801915 	stw	r2,100(r16)
8112b5f4:	80800017 	ldw	r2,0(r16)
8112b5f8:	8100030d 	sth	r4,12(r16)
8112b5fc:	81000517 	ldw	r4,20(r16)
8112b600:	10c7c83a 	sub	r3,r2,r3
8112b604:	193fe016 	blt	r3,r4,8112b588 <__reset+0xfb10b588>
8112b608:	800b883a 	mov	r5,r16
8112b60c:	9009883a 	mov	r4,r18
8112b610:	112d3540 	call	8112d354 <_fflush_r>
8112b614:	1000071e 	bne	r2,zero,8112b634 <__swbuf_r+0x11c>
8112b618:	80800017 	ldw	r2,0(r16)
8112b61c:	00c00044 	movi	r3,1
8112b620:	003fda06 	br	8112b58c <__reset+0xfb10b58c>
8112b624:	800b883a 	mov	r5,r16
8112b628:	9009883a 	mov	r4,r18
8112b62c:	112d3540 	call	8112d354 <_fflush_r>
8112b630:	103fe326 	beq	r2,zero,8112b5c0 <__reset+0xfb10b5c0>
8112b634:	00bfffc4 	movi	r2,-1
8112b638:	003fe206 	br	8112b5c4 <__reset+0xfb10b5c4>
8112b63c:	800b883a 	mov	r5,r16
8112b640:	9009883a 	mov	r4,r18
8112b644:	112b6e00 	call	8112b6e0 <__swsetup_r>
8112b648:	103ffa1e 	bne	r2,zero,8112b634 <__reset+0xfb10b634>
8112b64c:	8100030b 	ldhu	r4,12(r16)
8112b650:	80c00417 	ldw	r3,16(r16)
8112b654:	003fc506 	br	8112b56c <__reset+0xfb10b56c>
8112b658:	112d7500 	call	8112d750 <__sinit>
8112b65c:	003fbc06 	br	8112b550 <__reset+0xfb10b550>

8112b660 <__swbuf>:
8112b660:	00a04574 	movhi	r2,33045
8112b664:	10945c04 	addi	r2,r2,20848
8112b668:	280d883a 	mov	r6,r5
8112b66c:	200b883a 	mov	r5,r4
8112b670:	11000017 	ldw	r4,0(r2)
8112b674:	112b5181 	jmpi	8112b518 <__swbuf_r>

8112b678 <_write_r>:
8112b678:	defffd04 	addi	sp,sp,-12
8112b67c:	de00012e 	bgeu	sp,et,8112b684 <_write_r+0xc>
8112b680:	003b68fa 	trap	3
8112b684:	2805883a 	mov	r2,r5
8112b688:	dc000015 	stw	r16,0(sp)
8112b68c:	04204574 	movhi	r16,33045
8112b690:	dc400115 	stw	r17,4(sp)
8112b694:	300b883a 	mov	r5,r6
8112b698:	8414cf04 	addi	r16,r16,21308
8112b69c:	2023883a 	mov	r17,r4
8112b6a0:	380d883a 	mov	r6,r7
8112b6a4:	1009883a 	mov	r4,r2
8112b6a8:	dfc00215 	stw	ra,8(sp)
8112b6ac:	80000015 	stw	zero,0(r16)
8112b6b0:	1139e880 	call	81139e88 <write>
8112b6b4:	00ffffc4 	movi	r3,-1
8112b6b8:	10c00526 	beq	r2,r3,8112b6d0 <_write_r+0x58>
8112b6bc:	dfc00217 	ldw	ra,8(sp)
8112b6c0:	dc400117 	ldw	r17,4(sp)
8112b6c4:	dc000017 	ldw	r16,0(sp)
8112b6c8:	dec00304 	addi	sp,sp,12
8112b6cc:	f800283a 	ret
8112b6d0:	80c00017 	ldw	r3,0(r16)
8112b6d4:	183ff926 	beq	r3,zero,8112b6bc <__reset+0xfb10b6bc>
8112b6d8:	88c00015 	stw	r3,0(r17)
8112b6dc:	003ff706 	br	8112b6bc <__reset+0xfb10b6bc>

8112b6e0 <__swsetup_r>:
8112b6e0:	00a04574 	movhi	r2,33045
8112b6e4:	defffd04 	addi	sp,sp,-12
8112b6e8:	10945c04 	addi	r2,r2,20848
8112b6ec:	de00012e 	bgeu	sp,et,8112b6f4 <__swsetup_r+0x14>
8112b6f0:	003b68fa 	trap	3
8112b6f4:	dc400115 	stw	r17,4(sp)
8112b6f8:	2023883a 	mov	r17,r4
8112b6fc:	11000017 	ldw	r4,0(r2)
8112b700:	dc000015 	stw	r16,0(sp)
8112b704:	dfc00215 	stw	ra,8(sp)
8112b708:	2821883a 	mov	r16,r5
8112b70c:	20000226 	beq	r4,zero,8112b718 <__swsetup_r+0x38>
8112b710:	20800e17 	ldw	r2,56(r4)
8112b714:	10003126 	beq	r2,zero,8112b7dc <__swsetup_r+0xfc>
8112b718:	8080030b 	ldhu	r2,12(r16)
8112b71c:	10c0020c 	andi	r3,r2,8
8112b720:	1009883a 	mov	r4,r2
8112b724:	18000f26 	beq	r3,zero,8112b764 <__swsetup_r+0x84>
8112b728:	80c00417 	ldw	r3,16(r16)
8112b72c:	18001526 	beq	r3,zero,8112b784 <__swsetup_r+0xa4>
8112b730:	1100004c 	andi	r4,r2,1
8112b734:	20001c1e 	bne	r4,zero,8112b7a8 <__swsetup_r+0xc8>
8112b738:	1080008c 	andi	r2,r2,2
8112b73c:	1000291e 	bne	r2,zero,8112b7e4 <__swsetup_r+0x104>
8112b740:	80800517 	ldw	r2,20(r16)
8112b744:	80800215 	stw	r2,8(r16)
8112b748:	18001c26 	beq	r3,zero,8112b7bc <__swsetup_r+0xdc>
8112b74c:	0005883a 	mov	r2,zero
8112b750:	dfc00217 	ldw	ra,8(sp)
8112b754:	dc400117 	ldw	r17,4(sp)
8112b758:	dc000017 	ldw	r16,0(sp)
8112b75c:	dec00304 	addi	sp,sp,12
8112b760:	f800283a 	ret
8112b764:	2080040c 	andi	r2,r4,16
8112b768:	10002e26 	beq	r2,zero,8112b824 <__swsetup_r+0x144>
8112b76c:	2080010c 	andi	r2,r4,4
8112b770:	10001e1e 	bne	r2,zero,8112b7ec <__swsetup_r+0x10c>
8112b774:	80c00417 	ldw	r3,16(r16)
8112b778:	20800214 	ori	r2,r4,8
8112b77c:	8080030d 	sth	r2,12(r16)
8112b780:	183feb1e 	bne	r3,zero,8112b730 <__reset+0xfb10b730>
8112b784:	1100a00c 	andi	r4,r2,640
8112b788:	01408004 	movi	r5,512
8112b78c:	217fe826 	beq	r4,r5,8112b730 <__reset+0xfb10b730>
8112b790:	800b883a 	mov	r5,r16
8112b794:	8809883a 	mov	r4,r17
8112b798:	1123d280 	call	81123d28 <__smakebuf_r>
8112b79c:	8080030b 	ldhu	r2,12(r16)
8112b7a0:	80c00417 	ldw	r3,16(r16)
8112b7a4:	003fe206 	br	8112b730 <__reset+0xfb10b730>
8112b7a8:	80800517 	ldw	r2,20(r16)
8112b7ac:	80000215 	stw	zero,8(r16)
8112b7b0:	0085c83a 	sub	r2,zero,r2
8112b7b4:	80800615 	stw	r2,24(r16)
8112b7b8:	183fe41e 	bne	r3,zero,8112b74c <__reset+0xfb10b74c>
8112b7bc:	80c0030b 	ldhu	r3,12(r16)
8112b7c0:	0005883a 	mov	r2,zero
8112b7c4:	1900200c 	andi	r4,r3,128
8112b7c8:	203fe126 	beq	r4,zero,8112b750 <__reset+0xfb10b750>
8112b7cc:	18c01014 	ori	r3,r3,64
8112b7d0:	80c0030d 	sth	r3,12(r16)
8112b7d4:	00bfffc4 	movi	r2,-1
8112b7d8:	003fdd06 	br	8112b750 <__reset+0xfb10b750>
8112b7dc:	112d7500 	call	8112d750 <__sinit>
8112b7e0:	003fcd06 	br	8112b718 <__reset+0xfb10b718>
8112b7e4:	0005883a 	mov	r2,zero
8112b7e8:	003fd606 	br	8112b744 <__reset+0xfb10b744>
8112b7ec:	81400c17 	ldw	r5,48(r16)
8112b7f0:	28000626 	beq	r5,zero,8112b80c <__swsetup_r+0x12c>
8112b7f4:	80801004 	addi	r2,r16,64
8112b7f8:	28800326 	beq	r5,r2,8112b808 <__swsetup_r+0x128>
8112b7fc:	8809883a 	mov	r4,r17
8112b800:	112dbe80 	call	8112dbe8 <_free_r>
8112b804:	8100030b 	ldhu	r4,12(r16)
8112b808:	80000c15 	stw	zero,48(r16)
8112b80c:	80c00417 	ldw	r3,16(r16)
8112b810:	00bff6c4 	movi	r2,-37
8112b814:	1108703a 	and	r4,r2,r4
8112b818:	80000115 	stw	zero,4(r16)
8112b81c:	80c00015 	stw	r3,0(r16)
8112b820:	003fd506 	br	8112b778 <__reset+0xfb10b778>
8112b824:	00800244 	movi	r2,9
8112b828:	88800015 	stw	r2,0(r17)
8112b82c:	20801014 	ori	r2,r4,64
8112b830:	8080030d 	sth	r2,12(r16)
8112b834:	00bfffc4 	movi	r2,-1
8112b838:	003fc506 	br	8112b750 <__reset+0xfb10b750>

8112b83c <_close_r>:
8112b83c:	defffd04 	addi	sp,sp,-12
8112b840:	de00012e 	bgeu	sp,et,8112b848 <_close_r+0xc>
8112b844:	003b68fa 	trap	3
8112b848:	dc000015 	stw	r16,0(sp)
8112b84c:	04204574 	movhi	r16,33045
8112b850:	dc400115 	stw	r17,4(sp)
8112b854:	8414cf04 	addi	r16,r16,21308
8112b858:	2023883a 	mov	r17,r4
8112b85c:	2809883a 	mov	r4,r5
8112b860:	dfc00215 	stw	ra,8(sp)
8112b864:	80000015 	stw	zero,0(r16)
8112b868:	11384080 	call	81138408 <close>
8112b86c:	00ffffc4 	movi	r3,-1
8112b870:	10c00526 	beq	r2,r3,8112b888 <_close_r+0x4c>
8112b874:	dfc00217 	ldw	ra,8(sp)
8112b878:	dc400117 	ldw	r17,4(sp)
8112b87c:	dc000017 	ldw	r16,0(sp)
8112b880:	dec00304 	addi	sp,sp,12
8112b884:	f800283a 	ret
8112b888:	80c00017 	ldw	r3,0(r16)
8112b88c:	183ff926 	beq	r3,zero,8112b874 <__reset+0xfb10b874>
8112b890:	88c00015 	stw	r3,0(r17)
8112b894:	003ff706 	br	8112b874 <__reset+0xfb10b874>

8112b898 <quorem>:
8112b898:	defff704 	addi	sp,sp,-36
8112b89c:	de00012e 	bgeu	sp,et,8112b8a4 <quorem+0xc>
8112b8a0:	003b68fa 	trap	3
8112b8a4:	dc800215 	stw	r18,8(sp)
8112b8a8:	20800417 	ldw	r2,16(r4)
8112b8ac:	2c800417 	ldw	r18,16(r5)
8112b8b0:	dfc00815 	stw	ra,32(sp)
8112b8b4:	ddc00715 	stw	r23,28(sp)
8112b8b8:	dd800615 	stw	r22,24(sp)
8112b8bc:	dd400515 	stw	r21,20(sp)
8112b8c0:	dd000415 	stw	r20,16(sp)
8112b8c4:	dcc00315 	stw	r19,12(sp)
8112b8c8:	dc400115 	stw	r17,4(sp)
8112b8cc:	dc000015 	stw	r16,0(sp)
8112b8d0:	14807116 	blt	r2,r18,8112ba98 <quorem+0x200>
8112b8d4:	94bfffc4 	addi	r18,r18,-1
8112b8d8:	94ad883a 	add	r22,r18,r18
8112b8dc:	b5ad883a 	add	r22,r22,r22
8112b8e0:	2c400504 	addi	r17,r5,20
8112b8e4:	8da9883a 	add	r20,r17,r22
8112b8e8:	25400504 	addi	r21,r4,20
8112b8ec:	282f883a 	mov	r23,r5
8112b8f0:	adad883a 	add	r22,r21,r22
8112b8f4:	a1400017 	ldw	r5,0(r20)
8112b8f8:	2021883a 	mov	r16,r4
8112b8fc:	b1000017 	ldw	r4,0(r22)
8112b900:	29400044 	addi	r5,r5,1
8112b904:	1136c0c0 	call	81136c0c <__udivsi3>
8112b908:	1027883a 	mov	r19,r2
8112b90c:	10002c26 	beq	r2,zero,8112b9c0 <quorem+0x128>
8112b910:	a813883a 	mov	r9,r21
8112b914:	880b883a 	mov	r5,r17
8112b918:	0009883a 	mov	r4,zero
8112b91c:	000d883a 	mov	r6,zero
8112b920:	2a000017 	ldw	r8,0(r5)
8112b924:	49c00017 	ldw	r7,0(r9)
8112b928:	29400104 	addi	r5,r5,4
8112b92c:	40bfffcc 	andi	r2,r8,65535
8112b930:	14c5383a 	mul	r2,r2,r19
8112b934:	4010d43a 	srli	r8,r8,16
8112b938:	38ffffcc 	andi	r3,r7,65535
8112b93c:	1105883a 	add	r2,r2,r4
8112b940:	1008d43a 	srli	r4,r2,16
8112b944:	44d1383a 	mul	r8,r8,r19
8112b948:	198d883a 	add	r6,r3,r6
8112b94c:	10ffffcc 	andi	r3,r2,65535
8112b950:	30c7c83a 	sub	r3,r6,r3
8112b954:	380ed43a 	srli	r7,r7,16
8112b958:	4105883a 	add	r2,r8,r4
8112b95c:	180dd43a 	srai	r6,r3,16
8112b960:	113fffcc 	andi	r4,r2,65535
8112b964:	390fc83a 	sub	r7,r7,r4
8112b968:	398d883a 	add	r6,r7,r6
8112b96c:	300e943a 	slli	r7,r6,16
8112b970:	18ffffcc 	andi	r3,r3,65535
8112b974:	1008d43a 	srli	r4,r2,16
8112b978:	38ceb03a 	or	r7,r7,r3
8112b97c:	49c00015 	stw	r7,0(r9)
8112b980:	300dd43a 	srai	r6,r6,16
8112b984:	4a400104 	addi	r9,r9,4
8112b988:	a17fe52e 	bgeu	r20,r5,8112b920 <__reset+0xfb10b920>
8112b98c:	b0800017 	ldw	r2,0(r22)
8112b990:	10000b1e 	bne	r2,zero,8112b9c0 <quorem+0x128>
8112b994:	b0bfff04 	addi	r2,r22,-4
8112b998:	a880082e 	bgeu	r21,r2,8112b9bc <quorem+0x124>
8112b99c:	b0ffff17 	ldw	r3,-4(r22)
8112b9a0:	18000326 	beq	r3,zero,8112b9b0 <quorem+0x118>
8112b9a4:	00000506 	br	8112b9bc <quorem+0x124>
8112b9a8:	10c00017 	ldw	r3,0(r2)
8112b9ac:	1800031e 	bne	r3,zero,8112b9bc <quorem+0x124>
8112b9b0:	10bfff04 	addi	r2,r2,-4
8112b9b4:	94bfffc4 	addi	r18,r18,-1
8112b9b8:	a8bffb36 	bltu	r21,r2,8112b9a8 <__reset+0xfb10b9a8>
8112b9bc:	84800415 	stw	r18,16(r16)
8112b9c0:	b80b883a 	mov	r5,r23
8112b9c4:	8009883a 	mov	r4,r16
8112b9c8:	112f4b80 	call	8112f4b8 <__mcmp>
8112b9cc:	10002616 	blt	r2,zero,8112ba68 <quorem+0x1d0>
8112b9d0:	9cc00044 	addi	r19,r19,1
8112b9d4:	a805883a 	mov	r2,r21
8112b9d8:	000b883a 	mov	r5,zero
8112b9dc:	11000017 	ldw	r4,0(r2)
8112b9e0:	89800017 	ldw	r6,0(r17)
8112b9e4:	10800104 	addi	r2,r2,4
8112b9e8:	20ffffcc 	andi	r3,r4,65535
8112b9ec:	194b883a 	add	r5,r3,r5
8112b9f0:	30ffffcc 	andi	r3,r6,65535
8112b9f4:	28c7c83a 	sub	r3,r5,r3
8112b9f8:	300cd43a 	srli	r6,r6,16
8112b9fc:	2008d43a 	srli	r4,r4,16
8112ba00:	180bd43a 	srai	r5,r3,16
8112ba04:	18ffffcc 	andi	r3,r3,65535
8112ba08:	2189c83a 	sub	r4,r4,r6
8112ba0c:	2149883a 	add	r4,r4,r5
8112ba10:	200c943a 	slli	r6,r4,16
8112ba14:	8c400104 	addi	r17,r17,4
8112ba18:	200bd43a 	srai	r5,r4,16
8112ba1c:	30c6b03a 	or	r3,r6,r3
8112ba20:	10ffff15 	stw	r3,-4(r2)
8112ba24:	a47fed2e 	bgeu	r20,r17,8112b9dc <__reset+0xfb10b9dc>
8112ba28:	9485883a 	add	r2,r18,r18
8112ba2c:	1085883a 	add	r2,r2,r2
8112ba30:	a887883a 	add	r3,r21,r2
8112ba34:	18800017 	ldw	r2,0(r3)
8112ba38:	10000b1e 	bne	r2,zero,8112ba68 <quorem+0x1d0>
8112ba3c:	18bfff04 	addi	r2,r3,-4
8112ba40:	a880082e 	bgeu	r21,r2,8112ba64 <quorem+0x1cc>
8112ba44:	18ffff17 	ldw	r3,-4(r3)
8112ba48:	18000326 	beq	r3,zero,8112ba58 <quorem+0x1c0>
8112ba4c:	00000506 	br	8112ba64 <quorem+0x1cc>
8112ba50:	10c00017 	ldw	r3,0(r2)
8112ba54:	1800031e 	bne	r3,zero,8112ba64 <quorem+0x1cc>
8112ba58:	10bfff04 	addi	r2,r2,-4
8112ba5c:	94bfffc4 	addi	r18,r18,-1
8112ba60:	a8bffb36 	bltu	r21,r2,8112ba50 <__reset+0xfb10ba50>
8112ba64:	84800415 	stw	r18,16(r16)
8112ba68:	9805883a 	mov	r2,r19
8112ba6c:	dfc00817 	ldw	ra,32(sp)
8112ba70:	ddc00717 	ldw	r23,28(sp)
8112ba74:	dd800617 	ldw	r22,24(sp)
8112ba78:	dd400517 	ldw	r21,20(sp)
8112ba7c:	dd000417 	ldw	r20,16(sp)
8112ba80:	dcc00317 	ldw	r19,12(sp)
8112ba84:	dc800217 	ldw	r18,8(sp)
8112ba88:	dc400117 	ldw	r17,4(sp)
8112ba8c:	dc000017 	ldw	r16,0(sp)
8112ba90:	dec00904 	addi	sp,sp,36
8112ba94:	f800283a 	ret
8112ba98:	0005883a 	mov	r2,zero
8112ba9c:	003ff306 	br	8112ba6c <__reset+0xfb10ba6c>

8112baa0 <_dtoa_r>:
8112baa0:	deffde04 	addi	sp,sp,-136
8112baa4:	de00012e 	bgeu	sp,et,8112baac <_dtoa_r+0xc>
8112baa8:	003b68fa 	trap	3
8112baac:	20801017 	ldw	r2,64(r4)
8112bab0:	df002015 	stw	fp,128(sp)
8112bab4:	dcc01b15 	stw	r19,108(sp)
8112bab8:	dc801a15 	stw	r18,104(sp)
8112babc:	dc401915 	stw	r17,100(sp)
8112bac0:	dc001815 	stw	r16,96(sp)
8112bac4:	dfc02115 	stw	ra,132(sp)
8112bac8:	ddc01f15 	stw	r23,124(sp)
8112bacc:	dd801e15 	stw	r22,120(sp)
8112bad0:	dd401d15 	stw	r21,116(sp)
8112bad4:	dd001c15 	stw	r20,112(sp)
8112bad8:	d9c00315 	stw	r7,12(sp)
8112badc:	2039883a 	mov	fp,r4
8112bae0:	3023883a 	mov	r17,r6
8112bae4:	2825883a 	mov	r18,r5
8112bae8:	dc002417 	ldw	r16,144(sp)
8112baec:	3027883a 	mov	r19,r6
8112baf0:	10000826 	beq	r2,zero,8112bb14 <_dtoa_r+0x74>
8112baf4:	21801117 	ldw	r6,68(r4)
8112baf8:	00c00044 	movi	r3,1
8112bafc:	100b883a 	mov	r5,r2
8112bb00:	1986983a 	sll	r3,r3,r6
8112bb04:	11800115 	stw	r6,4(r2)
8112bb08:	10c00215 	stw	r3,8(r2)
8112bb0c:	112ec680 	call	8112ec68 <_Bfree>
8112bb10:	e0001015 	stw	zero,64(fp)
8112bb14:	88002e16 	blt	r17,zero,8112bbd0 <_dtoa_r+0x130>
8112bb18:	80000015 	stw	zero,0(r16)
8112bb1c:	889ffc2c 	andhi	r2,r17,32752
8112bb20:	00dffc34 	movhi	r3,32752
8112bb24:	10c01c26 	beq	r2,r3,8112bb98 <_dtoa_r+0xf8>
8112bb28:	000d883a 	mov	r6,zero
8112bb2c:	000f883a 	mov	r7,zero
8112bb30:	9009883a 	mov	r4,r18
8112bb34:	980b883a 	mov	r5,r19
8112bb38:	11380680 	call	81138068 <__eqdf2>
8112bb3c:	10002b1e 	bne	r2,zero,8112bbec <_dtoa_r+0x14c>
8112bb40:	d9c02317 	ldw	r7,140(sp)
8112bb44:	00800044 	movi	r2,1
8112bb48:	38800015 	stw	r2,0(r7)
8112bb4c:	d8802517 	ldw	r2,148(sp)
8112bb50:	10019e26 	beq	r2,zero,8112c1cc <_dtoa_r+0x72c>
8112bb54:	d8c02517 	ldw	r3,148(sp)
8112bb58:	00a04574 	movhi	r2,33045
8112bb5c:	108a9444 	addi	r2,r2,10833
8112bb60:	18800015 	stw	r2,0(r3)
8112bb64:	10bfffc4 	addi	r2,r2,-1
8112bb68:	dfc02117 	ldw	ra,132(sp)
8112bb6c:	df002017 	ldw	fp,128(sp)
8112bb70:	ddc01f17 	ldw	r23,124(sp)
8112bb74:	dd801e17 	ldw	r22,120(sp)
8112bb78:	dd401d17 	ldw	r21,116(sp)
8112bb7c:	dd001c17 	ldw	r20,112(sp)
8112bb80:	dcc01b17 	ldw	r19,108(sp)
8112bb84:	dc801a17 	ldw	r18,104(sp)
8112bb88:	dc401917 	ldw	r17,100(sp)
8112bb8c:	dc001817 	ldw	r16,96(sp)
8112bb90:	dec02204 	addi	sp,sp,136
8112bb94:	f800283a 	ret
8112bb98:	d8c02317 	ldw	r3,140(sp)
8112bb9c:	0089c3c4 	movi	r2,9999
8112bba0:	18800015 	stw	r2,0(r3)
8112bba4:	90017726 	beq	r18,zero,8112c184 <_dtoa_r+0x6e4>
8112bba8:	00a04574 	movhi	r2,33045
8112bbac:	108ab204 	addi	r2,r2,10952
8112bbb0:	d9002517 	ldw	r4,148(sp)
8112bbb4:	203fec26 	beq	r4,zero,8112bb68 <__reset+0xfb10bb68>
8112bbb8:	10c000c7 	ldb	r3,3(r2)
8112bbbc:	1801781e 	bne	r3,zero,8112c1a0 <_dtoa_r+0x700>
8112bbc0:	10c000c4 	addi	r3,r2,3
8112bbc4:	d9802517 	ldw	r6,148(sp)
8112bbc8:	30c00015 	stw	r3,0(r6)
8112bbcc:	003fe606 	br	8112bb68 <__reset+0xfb10bb68>
8112bbd0:	04e00034 	movhi	r19,32768
8112bbd4:	9cffffc4 	addi	r19,r19,-1
8112bbd8:	00800044 	movi	r2,1
8112bbdc:	8ce6703a 	and	r19,r17,r19
8112bbe0:	80800015 	stw	r2,0(r16)
8112bbe4:	9823883a 	mov	r17,r19
8112bbe8:	003fcc06 	br	8112bb1c <__reset+0xfb10bb1c>
8112bbec:	d8800204 	addi	r2,sp,8
8112bbf0:	d8800015 	stw	r2,0(sp)
8112bbf4:	d9c00104 	addi	r7,sp,4
8112bbf8:	900b883a 	mov	r5,r18
8112bbfc:	980d883a 	mov	r6,r19
8112bc00:	e009883a 	mov	r4,fp
8112bc04:	8820d53a 	srli	r16,r17,20
8112bc08:	112f8940 	call	8112f894 <__d2b>
8112bc0c:	d8800915 	stw	r2,36(sp)
8112bc10:	8001651e 	bne	r16,zero,8112c1a8 <_dtoa_r+0x708>
8112bc14:	dd800217 	ldw	r22,8(sp)
8112bc18:	dc000117 	ldw	r16,4(sp)
8112bc1c:	00800804 	movi	r2,32
8112bc20:	b421883a 	add	r16,r22,r16
8112bc24:	80c10c84 	addi	r3,r16,1074
8112bc28:	10c2d10e 	bge	r2,r3,8112c770 <_dtoa_r+0xcd0>
8112bc2c:	00801004 	movi	r2,64
8112bc30:	81010484 	addi	r4,r16,1042
8112bc34:	10c7c83a 	sub	r3,r2,r3
8112bc38:	9108d83a 	srl	r4,r18,r4
8112bc3c:	88e2983a 	sll	r17,r17,r3
8112bc40:	2448b03a 	or	r4,r4,r17
8112bc44:	11381e40 	call	811381e4 <__floatunsidf>
8112bc48:	017f8434 	movhi	r5,65040
8112bc4c:	01800044 	movi	r6,1
8112bc50:	1009883a 	mov	r4,r2
8112bc54:	194b883a 	add	r5,r3,r5
8112bc58:	843fffc4 	addi	r16,r16,-1
8112bc5c:	d9801115 	stw	r6,68(sp)
8112bc60:	000d883a 	mov	r6,zero
8112bc64:	01cffe34 	movhi	r7,16376
8112bc68:	11227500 	call	81122750 <__subdf3>
8112bc6c:	0198dbf4 	movhi	r6,25455
8112bc70:	01cff4f4 	movhi	r7,16339
8112bc74:	3190d844 	addi	r6,r6,17249
8112bc78:	39e1e9c4 	addi	r7,r7,-30809
8112bc7c:	1009883a 	mov	r4,r2
8112bc80:	180b883a 	mov	r5,r3
8112bc84:	11220300 	call	81122030 <__muldf3>
8112bc88:	01a2d874 	movhi	r6,35681
8112bc8c:	01cff1f4 	movhi	r7,16327
8112bc90:	31b22cc4 	addi	r6,r6,-14157
8112bc94:	39e28a04 	addi	r7,r7,-30168
8112bc98:	180b883a 	mov	r5,r3
8112bc9c:	1009883a 	mov	r4,r2
8112bca0:	1136ec40 	call	81136ec4 <__adddf3>
8112bca4:	8009883a 	mov	r4,r16
8112bca8:	1029883a 	mov	r20,r2
8112bcac:	1823883a 	mov	r17,r3
8112bcb0:	11230d40 	call	811230d4 <__floatsidf>
8112bcb4:	019427f4 	movhi	r6,20639
8112bcb8:	01cff4f4 	movhi	r7,16339
8112bcbc:	319e7ec4 	addi	r6,r6,31227
8112bcc0:	39d104c4 	addi	r7,r7,17427
8112bcc4:	1009883a 	mov	r4,r2
8112bcc8:	180b883a 	mov	r5,r3
8112bccc:	11220300 	call	81122030 <__muldf3>
8112bcd0:	100d883a 	mov	r6,r2
8112bcd4:	180f883a 	mov	r7,r3
8112bcd8:	a009883a 	mov	r4,r20
8112bcdc:	880b883a 	mov	r5,r17
8112bce0:	1136ec40 	call	81136ec4 <__adddf3>
8112bce4:	1009883a 	mov	r4,r2
8112bce8:	180b883a 	mov	r5,r3
8112bcec:	1029883a 	mov	r20,r2
8112bcf0:	1823883a 	mov	r17,r3
8112bcf4:	11230540 	call	81123054 <__fixdfsi>
8112bcf8:	000d883a 	mov	r6,zero
8112bcfc:	000f883a 	mov	r7,zero
8112bd00:	a009883a 	mov	r4,r20
8112bd04:	880b883a 	mov	r5,r17
8112bd08:	d8800515 	stw	r2,20(sp)
8112bd0c:	11380f00 	call	811380f0 <__ledf2>
8112bd10:	10028716 	blt	r2,zero,8112c730 <_dtoa_r+0xc90>
8112bd14:	d8c00517 	ldw	r3,20(sp)
8112bd18:	00800584 	movi	r2,22
8112bd1c:	10c27536 	bltu	r2,r3,8112c6f4 <_dtoa_r+0xc54>
8112bd20:	180490fa 	slli	r2,r3,3
8112bd24:	00e04574 	movhi	r3,33045
8112bd28:	18cacd04 	addi	r3,r3,11060
8112bd2c:	1885883a 	add	r2,r3,r2
8112bd30:	11000017 	ldw	r4,0(r2)
8112bd34:	11400117 	ldw	r5,4(r2)
8112bd38:	900d883a 	mov	r6,r18
8112bd3c:	980f883a 	mov	r7,r19
8112bd40:	1121f540 	call	81121f54 <__gedf2>
8112bd44:	00828d0e 	bge	zero,r2,8112c77c <_dtoa_r+0xcdc>
8112bd48:	d9000517 	ldw	r4,20(sp)
8112bd4c:	d8000e15 	stw	zero,56(sp)
8112bd50:	213fffc4 	addi	r4,r4,-1
8112bd54:	d9000515 	stw	r4,20(sp)
8112bd58:	b42dc83a 	sub	r22,r22,r16
8112bd5c:	b5bfffc4 	addi	r22,r22,-1
8112bd60:	b0026f16 	blt	r22,zero,8112c720 <_dtoa_r+0xc80>
8112bd64:	d8000815 	stw	zero,32(sp)
8112bd68:	d9c00517 	ldw	r7,20(sp)
8112bd6c:	38026416 	blt	r7,zero,8112c700 <_dtoa_r+0xc60>
8112bd70:	b1ed883a 	add	r22,r22,r7
8112bd74:	d9c00d15 	stw	r7,52(sp)
8112bd78:	d8000a15 	stw	zero,40(sp)
8112bd7c:	d9800317 	ldw	r6,12(sp)
8112bd80:	00800244 	movi	r2,9
8112bd84:	11811436 	bltu	r2,r6,8112c1d8 <_dtoa_r+0x738>
8112bd88:	00800144 	movi	r2,5
8112bd8c:	1184e10e 	bge	r2,r6,8112d114 <_dtoa_r+0x1674>
8112bd90:	31bfff04 	addi	r6,r6,-4
8112bd94:	d9800315 	stw	r6,12(sp)
8112bd98:	0023883a 	mov	r17,zero
8112bd9c:	d9800317 	ldw	r6,12(sp)
8112bda0:	008000c4 	movi	r2,3
8112bda4:	30836726 	beq	r6,r2,8112cb44 <_dtoa_r+0x10a4>
8112bda8:	1183410e 	bge	r2,r6,8112cab0 <_dtoa_r+0x1010>
8112bdac:	d9c00317 	ldw	r7,12(sp)
8112bdb0:	00800104 	movi	r2,4
8112bdb4:	38827c26 	beq	r7,r2,8112c7a8 <_dtoa_r+0xd08>
8112bdb8:	00800144 	movi	r2,5
8112bdbc:	3884c41e 	bne	r7,r2,8112d0d0 <_dtoa_r+0x1630>
8112bdc0:	00800044 	movi	r2,1
8112bdc4:	d8800b15 	stw	r2,44(sp)
8112bdc8:	d8c00517 	ldw	r3,20(sp)
8112bdcc:	d9002217 	ldw	r4,136(sp)
8112bdd0:	1907883a 	add	r3,r3,r4
8112bdd4:	19800044 	addi	r6,r3,1
8112bdd8:	d8c00c15 	stw	r3,48(sp)
8112bddc:	d9800615 	stw	r6,24(sp)
8112bde0:	0183a40e 	bge	zero,r6,8112cc74 <_dtoa_r+0x11d4>
8112bde4:	d9800617 	ldw	r6,24(sp)
8112bde8:	3021883a 	mov	r16,r6
8112bdec:	e0001115 	stw	zero,68(fp)
8112bdf0:	008005c4 	movi	r2,23
8112bdf4:	1184c92e 	bgeu	r2,r6,8112d11c <_dtoa_r+0x167c>
8112bdf8:	00c00044 	movi	r3,1
8112bdfc:	00800104 	movi	r2,4
8112be00:	1085883a 	add	r2,r2,r2
8112be04:	11000504 	addi	r4,r2,20
8112be08:	180b883a 	mov	r5,r3
8112be0c:	18c00044 	addi	r3,r3,1
8112be10:	313ffb2e 	bgeu	r6,r4,8112be00 <__reset+0xfb10be00>
8112be14:	e1401115 	stw	r5,68(fp)
8112be18:	e009883a 	mov	r4,fp
8112be1c:	112ebb80 	call	8112ebb8 <_Balloc>
8112be20:	d8800715 	stw	r2,28(sp)
8112be24:	e0801015 	stw	r2,64(fp)
8112be28:	00800384 	movi	r2,14
8112be2c:	1400f736 	bltu	r2,r16,8112c20c <_dtoa_r+0x76c>
8112be30:	8800f626 	beq	r17,zero,8112c20c <_dtoa_r+0x76c>
8112be34:	d9c00517 	ldw	r7,20(sp)
8112be38:	01c39a0e 	bge	zero,r7,8112cca4 <_dtoa_r+0x1204>
8112be3c:	388003cc 	andi	r2,r7,15
8112be40:	100490fa 	slli	r2,r2,3
8112be44:	382bd13a 	srai	r21,r7,4
8112be48:	00e04574 	movhi	r3,33045
8112be4c:	18cacd04 	addi	r3,r3,11060
8112be50:	1885883a 	add	r2,r3,r2
8112be54:	a8c0040c 	andi	r3,r21,16
8112be58:	12400017 	ldw	r9,0(r2)
8112be5c:	12000117 	ldw	r8,4(r2)
8112be60:	18037926 	beq	r3,zero,8112cc48 <_dtoa_r+0x11a8>
8112be64:	00a04574 	movhi	r2,33045
8112be68:	108ac304 	addi	r2,r2,11020
8112be6c:	11800817 	ldw	r6,32(r2)
8112be70:	11c00917 	ldw	r7,36(r2)
8112be74:	9009883a 	mov	r4,r18
8112be78:	980b883a 	mov	r5,r19
8112be7c:	da001715 	stw	r8,92(sp)
8112be80:	da401615 	stw	r9,88(sp)
8112be84:	11377780 	call	81137778 <__divdf3>
8112be88:	da001717 	ldw	r8,92(sp)
8112be8c:	da401617 	ldw	r9,88(sp)
8112be90:	ad4003cc 	andi	r21,r21,15
8112be94:	040000c4 	movi	r16,3
8112be98:	1023883a 	mov	r17,r2
8112be9c:	1829883a 	mov	r20,r3
8112bea0:	a8001126 	beq	r21,zero,8112bee8 <_dtoa_r+0x448>
8112bea4:	05e04574 	movhi	r23,33045
8112bea8:	bdcac304 	addi	r23,r23,11020
8112beac:	4805883a 	mov	r2,r9
8112beb0:	4007883a 	mov	r3,r8
8112beb4:	a980004c 	andi	r6,r21,1
8112beb8:	1009883a 	mov	r4,r2
8112bebc:	a82bd07a 	srai	r21,r21,1
8112bec0:	180b883a 	mov	r5,r3
8112bec4:	30000426 	beq	r6,zero,8112bed8 <_dtoa_r+0x438>
8112bec8:	b9800017 	ldw	r6,0(r23)
8112becc:	b9c00117 	ldw	r7,4(r23)
8112bed0:	84000044 	addi	r16,r16,1
8112bed4:	11220300 	call	81122030 <__muldf3>
8112bed8:	bdc00204 	addi	r23,r23,8
8112bedc:	a83ff51e 	bne	r21,zero,8112beb4 <__reset+0xfb10beb4>
8112bee0:	1013883a 	mov	r9,r2
8112bee4:	1811883a 	mov	r8,r3
8112bee8:	480d883a 	mov	r6,r9
8112beec:	400f883a 	mov	r7,r8
8112bef0:	8809883a 	mov	r4,r17
8112bef4:	a00b883a 	mov	r5,r20
8112bef8:	11377780 	call	81137778 <__divdf3>
8112befc:	d8800f15 	stw	r2,60(sp)
8112bf00:	d8c01015 	stw	r3,64(sp)
8112bf04:	d8c00e17 	ldw	r3,56(sp)
8112bf08:	18000626 	beq	r3,zero,8112bf24 <_dtoa_r+0x484>
8112bf0c:	d9000f17 	ldw	r4,60(sp)
8112bf10:	d9401017 	ldw	r5,64(sp)
8112bf14:	000d883a 	mov	r6,zero
8112bf18:	01cffc34 	movhi	r7,16368
8112bf1c:	11380f00 	call	811380f0 <__ledf2>
8112bf20:	10040b16 	blt	r2,zero,8112cf50 <_dtoa_r+0x14b0>
8112bf24:	8009883a 	mov	r4,r16
8112bf28:	11230d40 	call	811230d4 <__floatsidf>
8112bf2c:	d9800f17 	ldw	r6,60(sp)
8112bf30:	d9c01017 	ldw	r7,64(sp)
8112bf34:	1009883a 	mov	r4,r2
8112bf38:	180b883a 	mov	r5,r3
8112bf3c:	11220300 	call	81122030 <__muldf3>
8112bf40:	000d883a 	mov	r6,zero
8112bf44:	01d00734 	movhi	r7,16412
8112bf48:	1009883a 	mov	r4,r2
8112bf4c:	180b883a 	mov	r5,r3
8112bf50:	1136ec40 	call	81136ec4 <__adddf3>
8112bf54:	1021883a 	mov	r16,r2
8112bf58:	d8800617 	ldw	r2,24(sp)
8112bf5c:	047f3034 	movhi	r17,64704
8112bf60:	1c63883a 	add	r17,r3,r17
8112bf64:	10031826 	beq	r2,zero,8112cbc8 <_dtoa_r+0x1128>
8112bf68:	d8c00517 	ldw	r3,20(sp)
8112bf6c:	db000617 	ldw	r12,24(sp)
8112bf70:	d8c01315 	stw	r3,76(sp)
8112bf74:	d9000b17 	ldw	r4,44(sp)
8112bf78:	20038f26 	beq	r4,zero,8112cdb8 <_dtoa_r+0x1318>
8112bf7c:	60bfffc4 	addi	r2,r12,-1
8112bf80:	100490fa 	slli	r2,r2,3
8112bf84:	00e04574 	movhi	r3,33045
8112bf88:	18cacd04 	addi	r3,r3,11060
8112bf8c:	1885883a 	add	r2,r3,r2
8112bf90:	11800017 	ldw	r6,0(r2)
8112bf94:	11c00117 	ldw	r7,4(r2)
8112bf98:	d8800717 	ldw	r2,28(sp)
8112bf9c:	0009883a 	mov	r4,zero
8112bfa0:	014ff834 	movhi	r5,16352
8112bfa4:	db001615 	stw	r12,88(sp)
8112bfa8:	15c00044 	addi	r23,r2,1
8112bfac:	11377780 	call	81137778 <__divdf3>
8112bfb0:	800d883a 	mov	r6,r16
8112bfb4:	880f883a 	mov	r7,r17
8112bfb8:	1009883a 	mov	r4,r2
8112bfbc:	180b883a 	mov	r5,r3
8112bfc0:	11227500 	call	81122750 <__subdf3>
8112bfc4:	d9401017 	ldw	r5,64(sp)
8112bfc8:	d9000f17 	ldw	r4,60(sp)
8112bfcc:	102b883a 	mov	r21,r2
8112bfd0:	d8c01215 	stw	r3,72(sp)
8112bfd4:	11230540 	call	81123054 <__fixdfsi>
8112bfd8:	1009883a 	mov	r4,r2
8112bfdc:	1029883a 	mov	r20,r2
8112bfe0:	11230d40 	call	811230d4 <__floatsidf>
8112bfe4:	d9000f17 	ldw	r4,60(sp)
8112bfe8:	d9401017 	ldw	r5,64(sp)
8112bfec:	100d883a 	mov	r6,r2
8112bff0:	180f883a 	mov	r7,r3
8112bff4:	11227500 	call	81122750 <__subdf3>
8112bff8:	1823883a 	mov	r17,r3
8112bffc:	d8c00717 	ldw	r3,28(sp)
8112c000:	d9401217 	ldw	r5,72(sp)
8112c004:	a2000c04 	addi	r8,r20,48
8112c008:	1021883a 	mov	r16,r2
8112c00c:	1a000005 	stb	r8,0(r3)
8112c010:	800d883a 	mov	r6,r16
8112c014:	880f883a 	mov	r7,r17
8112c018:	a809883a 	mov	r4,r21
8112c01c:	4029883a 	mov	r20,r8
8112c020:	1121f540 	call	81121f54 <__gedf2>
8112c024:	00841d16 	blt	zero,r2,8112d09c <_dtoa_r+0x15fc>
8112c028:	800d883a 	mov	r6,r16
8112c02c:	880f883a 	mov	r7,r17
8112c030:	0009883a 	mov	r4,zero
8112c034:	014ffc34 	movhi	r5,16368
8112c038:	11227500 	call	81122750 <__subdf3>
8112c03c:	d9401217 	ldw	r5,72(sp)
8112c040:	100d883a 	mov	r6,r2
8112c044:	180f883a 	mov	r7,r3
8112c048:	a809883a 	mov	r4,r21
8112c04c:	1121f540 	call	81121f54 <__gedf2>
8112c050:	db001617 	ldw	r12,88(sp)
8112c054:	00840e16 	blt	zero,r2,8112d090 <_dtoa_r+0x15f0>
8112c058:	00800044 	movi	r2,1
8112c05c:	13006b0e 	bge	r2,r12,8112c20c <_dtoa_r+0x76c>
8112c060:	d9000717 	ldw	r4,28(sp)
8112c064:	dd800f15 	stw	r22,60(sp)
8112c068:	dcc01015 	stw	r19,64(sp)
8112c06c:	2319883a 	add	r12,r4,r12
8112c070:	dcc01217 	ldw	r19,72(sp)
8112c074:	602d883a 	mov	r22,r12
8112c078:	dc801215 	stw	r18,72(sp)
8112c07c:	b825883a 	mov	r18,r23
8112c080:	00000906 	br	8112c0a8 <_dtoa_r+0x608>
8112c084:	11227500 	call	81122750 <__subdf3>
8112c088:	a80d883a 	mov	r6,r21
8112c08c:	980f883a 	mov	r7,r19
8112c090:	1009883a 	mov	r4,r2
8112c094:	180b883a 	mov	r5,r3
8112c098:	11380f00 	call	811380f0 <__ledf2>
8112c09c:	1003e816 	blt	r2,zero,8112d040 <_dtoa_r+0x15a0>
8112c0a0:	b825883a 	mov	r18,r23
8112c0a4:	bd83e926 	beq	r23,r22,8112d04c <_dtoa_r+0x15ac>
8112c0a8:	a809883a 	mov	r4,r21
8112c0ac:	980b883a 	mov	r5,r19
8112c0b0:	000d883a 	mov	r6,zero
8112c0b4:	01d00934 	movhi	r7,16420
8112c0b8:	11220300 	call	81122030 <__muldf3>
8112c0bc:	000d883a 	mov	r6,zero
8112c0c0:	01d00934 	movhi	r7,16420
8112c0c4:	8009883a 	mov	r4,r16
8112c0c8:	880b883a 	mov	r5,r17
8112c0cc:	102b883a 	mov	r21,r2
8112c0d0:	1827883a 	mov	r19,r3
8112c0d4:	11220300 	call	81122030 <__muldf3>
8112c0d8:	180b883a 	mov	r5,r3
8112c0dc:	1009883a 	mov	r4,r2
8112c0e0:	1821883a 	mov	r16,r3
8112c0e4:	1023883a 	mov	r17,r2
8112c0e8:	11230540 	call	81123054 <__fixdfsi>
8112c0ec:	1009883a 	mov	r4,r2
8112c0f0:	1029883a 	mov	r20,r2
8112c0f4:	11230d40 	call	811230d4 <__floatsidf>
8112c0f8:	8809883a 	mov	r4,r17
8112c0fc:	800b883a 	mov	r5,r16
8112c100:	100d883a 	mov	r6,r2
8112c104:	180f883a 	mov	r7,r3
8112c108:	11227500 	call	81122750 <__subdf3>
8112c10c:	a5000c04 	addi	r20,r20,48
8112c110:	a80d883a 	mov	r6,r21
8112c114:	980f883a 	mov	r7,r19
8112c118:	1009883a 	mov	r4,r2
8112c11c:	180b883a 	mov	r5,r3
8112c120:	95000005 	stb	r20,0(r18)
8112c124:	1021883a 	mov	r16,r2
8112c128:	1823883a 	mov	r17,r3
8112c12c:	11380f00 	call	811380f0 <__ledf2>
8112c130:	bdc00044 	addi	r23,r23,1
8112c134:	800d883a 	mov	r6,r16
8112c138:	880f883a 	mov	r7,r17
8112c13c:	0009883a 	mov	r4,zero
8112c140:	014ffc34 	movhi	r5,16368
8112c144:	103fcf0e 	bge	r2,zero,8112c084 <__reset+0xfb10c084>
8112c148:	d8c01317 	ldw	r3,76(sp)
8112c14c:	d8c00515 	stw	r3,20(sp)
8112c150:	d9400917 	ldw	r5,36(sp)
8112c154:	e009883a 	mov	r4,fp
8112c158:	112ec680 	call	8112ec68 <_Bfree>
8112c15c:	d9000517 	ldw	r4,20(sp)
8112c160:	d9802317 	ldw	r6,140(sp)
8112c164:	d9c02517 	ldw	r7,148(sp)
8112c168:	b8000005 	stb	zero,0(r23)
8112c16c:	20800044 	addi	r2,r4,1
8112c170:	30800015 	stw	r2,0(r6)
8112c174:	3802aa26 	beq	r7,zero,8112cc20 <_dtoa_r+0x1180>
8112c178:	3dc00015 	stw	r23,0(r7)
8112c17c:	d8800717 	ldw	r2,28(sp)
8112c180:	003e7906 	br	8112bb68 <__reset+0xfb10bb68>
8112c184:	00800434 	movhi	r2,16
8112c188:	10bfffc4 	addi	r2,r2,-1
8112c18c:	88a2703a 	and	r17,r17,r2
8112c190:	883e851e 	bne	r17,zero,8112bba8 <__reset+0xfb10bba8>
8112c194:	00a04574 	movhi	r2,33045
8112c198:	108aaf04 	addi	r2,r2,10940
8112c19c:	003e8406 	br	8112bbb0 <__reset+0xfb10bbb0>
8112c1a0:	10c00204 	addi	r3,r2,8
8112c1a4:	003e8706 	br	8112bbc4 <__reset+0xfb10bbc4>
8112c1a8:	01400434 	movhi	r5,16
8112c1ac:	297fffc4 	addi	r5,r5,-1
8112c1b0:	994a703a 	and	r5,r19,r5
8112c1b4:	9009883a 	mov	r4,r18
8112c1b8:	843f0044 	addi	r16,r16,-1023
8112c1bc:	294ffc34 	orhi	r5,r5,16368
8112c1c0:	dd800217 	ldw	r22,8(sp)
8112c1c4:	d8001115 	stw	zero,68(sp)
8112c1c8:	003ea506 	br	8112bc60 <__reset+0xfb10bc60>
8112c1cc:	00a04574 	movhi	r2,33045
8112c1d0:	108a9404 	addi	r2,r2,10832
8112c1d4:	003e6406 	br	8112bb68 <__reset+0xfb10bb68>
8112c1d8:	e0001115 	stw	zero,68(fp)
8112c1dc:	000b883a 	mov	r5,zero
8112c1e0:	e009883a 	mov	r4,fp
8112c1e4:	112ebb80 	call	8112ebb8 <_Balloc>
8112c1e8:	01bfffc4 	movi	r6,-1
8112c1ec:	01c00044 	movi	r7,1
8112c1f0:	d8800715 	stw	r2,28(sp)
8112c1f4:	d9800c15 	stw	r6,48(sp)
8112c1f8:	e0801015 	stw	r2,64(fp)
8112c1fc:	d8000315 	stw	zero,12(sp)
8112c200:	d9c00b15 	stw	r7,44(sp)
8112c204:	d9800615 	stw	r6,24(sp)
8112c208:	d8002215 	stw	zero,136(sp)
8112c20c:	d8800117 	ldw	r2,4(sp)
8112c210:	10008916 	blt	r2,zero,8112c438 <_dtoa_r+0x998>
8112c214:	d9000517 	ldw	r4,20(sp)
8112c218:	00c00384 	movi	r3,14
8112c21c:	19008616 	blt	r3,r4,8112c438 <_dtoa_r+0x998>
8112c220:	200490fa 	slli	r2,r4,3
8112c224:	00e04574 	movhi	r3,33045
8112c228:	d9802217 	ldw	r6,136(sp)
8112c22c:	18cacd04 	addi	r3,r3,11060
8112c230:	1885883a 	add	r2,r3,r2
8112c234:	14000017 	ldw	r16,0(r2)
8112c238:	14400117 	ldw	r17,4(r2)
8112c23c:	30016316 	blt	r6,zero,8112c7cc <_dtoa_r+0xd2c>
8112c240:	800d883a 	mov	r6,r16
8112c244:	880f883a 	mov	r7,r17
8112c248:	9009883a 	mov	r4,r18
8112c24c:	980b883a 	mov	r5,r19
8112c250:	11377780 	call	81137778 <__divdf3>
8112c254:	180b883a 	mov	r5,r3
8112c258:	1009883a 	mov	r4,r2
8112c25c:	11230540 	call	81123054 <__fixdfsi>
8112c260:	1009883a 	mov	r4,r2
8112c264:	102b883a 	mov	r21,r2
8112c268:	11230d40 	call	811230d4 <__floatsidf>
8112c26c:	800d883a 	mov	r6,r16
8112c270:	880f883a 	mov	r7,r17
8112c274:	1009883a 	mov	r4,r2
8112c278:	180b883a 	mov	r5,r3
8112c27c:	11220300 	call	81122030 <__muldf3>
8112c280:	100d883a 	mov	r6,r2
8112c284:	180f883a 	mov	r7,r3
8112c288:	9009883a 	mov	r4,r18
8112c28c:	980b883a 	mov	r5,r19
8112c290:	11227500 	call	81122750 <__subdf3>
8112c294:	d9c00717 	ldw	r7,28(sp)
8112c298:	1009883a 	mov	r4,r2
8112c29c:	a8800c04 	addi	r2,r21,48
8112c2a0:	38800005 	stb	r2,0(r7)
8112c2a4:	3dc00044 	addi	r23,r7,1
8112c2a8:	d9c00617 	ldw	r7,24(sp)
8112c2ac:	01800044 	movi	r6,1
8112c2b0:	180b883a 	mov	r5,r3
8112c2b4:	2005883a 	mov	r2,r4
8112c2b8:	39803826 	beq	r7,r6,8112c39c <_dtoa_r+0x8fc>
8112c2bc:	000d883a 	mov	r6,zero
8112c2c0:	01d00934 	movhi	r7,16420
8112c2c4:	11220300 	call	81122030 <__muldf3>
8112c2c8:	000d883a 	mov	r6,zero
8112c2cc:	000f883a 	mov	r7,zero
8112c2d0:	1009883a 	mov	r4,r2
8112c2d4:	180b883a 	mov	r5,r3
8112c2d8:	1025883a 	mov	r18,r2
8112c2dc:	1827883a 	mov	r19,r3
8112c2e0:	11380680 	call	81138068 <__eqdf2>
8112c2e4:	103f9a26 	beq	r2,zero,8112c150 <__reset+0xfb10c150>
8112c2e8:	d9c00617 	ldw	r7,24(sp)
8112c2ec:	d8c00717 	ldw	r3,28(sp)
8112c2f0:	b829883a 	mov	r20,r23
8112c2f4:	38bfffc4 	addi	r2,r7,-1
8112c2f8:	18ad883a 	add	r22,r3,r2
8112c2fc:	00000a06 	br	8112c328 <_dtoa_r+0x888>
8112c300:	11220300 	call	81122030 <__muldf3>
8112c304:	000d883a 	mov	r6,zero
8112c308:	000f883a 	mov	r7,zero
8112c30c:	1009883a 	mov	r4,r2
8112c310:	180b883a 	mov	r5,r3
8112c314:	1025883a 	mov	r18,r2
8112c318:	1827883a 	mov	r19,r3
8112c31c:	b829883a 	mov	r20,r23
8112c320:	11380680 	call	81138068 <__eqdf2>
8112c324:	103f8a26 	beq	r2,zero,8112c150 <__reset+0xfb10c150>
8112c328:	800d883a 	mov	r6,r16
8112c32c:	880f883a 	mov	r7,r17
8112c330:	9009883a 	mov	r4,r18
8112c334:	980b883a 	mov	r5,r19
8112c338:	11377780 	call	81137778 <__divdf3>
8112c33c:	180b883a 	mov	r5,r3
8112c340:	1009883a 	mov	r4,r2
8112c344:	11230540 	call	81123054 <__fixdfsi>
8112c348:	1009883a 	mov	r4,r2
8112c34c:	102b883a 	mov	r21,r2
8112c350:	11230d40 	call	811230d4 <__floatsidf>
8112c354:	800d883a 	mov	r6,r16
8112c358:	880f883a 	mov	r7,r17
8112c35c:	1009883a 	mov	r4,r2
8112c360:	180b883a 	mov	r5,r3
8112c364:	11220300 	call	81122030 <__muldf3>
8112c368:	100d883a 	mov	r6,r2
8112c36c:	180f883a 	mov	r7,r3
8112c370:	9009883a 	mov	r4,r18
8112c374:	980b883a 	mov	r5,r19
8112c378:	11227500 	call	81122750 <__subdf3>
8112c37c:	aa000c04 	addi	r8,r21,48
8112c380:	a2000005 	stb	r8,0(r20)
8112c384:	000d883a 	mov	r6,zero
8112c388:	01d00934 	movhi	r7,16420
8112c38c:	1009883a 	mov	r4,r2
8112c390:	180b883a 	mov	r5,r3
8112c394:	a5c00044 	addi	r23,r20,1
8112c398:	b53fd91e 	bne	r22,r20,8112c300 <__reset+0xfb10c300>
8112c39c:	100d883a 	mov	r6,r2
8112c3a0:	180f883a 	mov	r7,r3
8112c3a4:	1009883a 	mov	r4,r2
8112c3a8:	180b883a 	mov	r5,r3
8112c3ac:	1136ec40 	call	81136ec4 <__adddf3>
8112c3b0:	100d883a 	mov	r6,r2
8112c3b4:	180f883a 	mov	r7,r3
8112c3b8:	8009883a 	mov	r4,r16
8112c3bc:	880b883a 	mov	r5,r17
8112c3c0:	1027883a 	mov	r19,r2
8112c3c4:	1825883a 	mov	r18,r3
8112c3c8:	11380f00 	call	811380f0 <__ledf2>
8112c3cc:	10000816 	blt	r2,zero,8112c3f0 <_dtoa_r+0x950>
8112c3d0:	980d883a 	mov	r6,r19
8112c3d4:	900f883a 	mov	r7,r18
8112c3d8:	8009883a 	mov	r4,r16
8112c3dc:	880b883a 	mov	r5,r17
8112c3e0:	11380680 	call	81138068 <__eqdf2>
8112c3e4:	103f5a1e 	bne	r2,zero,8112c150 <__reset+0xfb10c150>
8112c3e8:	ad40004c 	andi	r21,r21,1
8112c3ec:	a83f5826 	beq	r21,zero,8112c150 <__reset+0xfb10c150>
8112c3f0:	bd3fffc3 	ldbu	r20,-1(r23)
8112c3f4:	b8bfffc4 	addi	r2,r23,-1
8112c3f8:	1007883a 	mov	r3,r2
8112c3fc:	01400e44 	movi	r5,57
8112c400:	d9800717 	ldw	r6,28(sp)
8112c404:	00000506 	br	8112c41c <_dtoa_r+0x97c>
8112c408:	18ffffc4 	addi	r3,r3,-1
8112c40c:	11824726 	beq	r2,r6,8112cd2c <_dtoa_r+0x128c>
8112c410:	1d000003 	ldbu	r20,0(r3)
8112c414:	102f883a 	mov	r23,r2
8112c418:	10bfffc4 	addi	r2,r2,-1
8112c41c:	a1003fcc 	andi	r4,r20,255
8112c420:	2100201c 	xori	r4,r4,128
8112c424:	213fe004 	addi	r4,r4,-128
8112c428:	217ff726 	beq	r4,r5,8112c408 <__reset+0xfb10c408>
8112c42c:	a2000044 	addi	r8,r20,1
8112c430:	12000005 	stb	r8,0(r2)
8112c434:	003f4606 	br	8112c150 <__reset+0xfb10c150>
8112c438:	d9000b17 	ldw	r4,44(sp)
8112c43c:	2000c826 	beq	r4,zero,8112c760 <_dtoa_r+0xcc0>
8112c440:	d9800317 	ldw	r6,12(sp)
8112c444:	00c00044 	movi	r3,1
8112c448:	1980f90e 	bge	r3,r6,8112c830 <_dtoa_r+0xd90>
8112c44c:	d8800617 	ldw	r2,24(sp)
8112c450:	d8c00a17 	ldw	r3,40(sp)
8112c454:	157fffc4 	addi	r21,r2,-1
8112c458:	1d41f316 	blt	r3,r21,8112cc28 <_dtoa_r+0x1188>
8112c45c:	1d6bc83a 	sub	r21,r3,r21
8112c460:	d9c00617 	ldw	r7,24(sp)
8112c464:	3802aa16 	blt	r7,zero,8112cf10 <_dtoa_r+0x1470>
8112c468:	dd000817 	ldw	r20,32(sp)
8112c46c:	d8800617 	ldw	r2,24(sp)
8112c470:	d8c00817 	ldw	r3,32(sp)
8112c474:	01400044 	movi	r5,1
8112c478:	e009883a 	mov	r4,fp
8112c47c:	1887883a 	add	r3,r3,r2
8112c480:	d8c00815 	stw	r3,32(sp)
8112c484:	b0ad883a 	add	r22,r22,r2
8112c488:	112efdc0 	call	8112efdc <__i2b>
8112c48c:	1023883a 	mov	r17,r2
8112c490:	a0000826 	beq	r20,zero,8112c4b4 <_dtoa_r+0xa14>
8112c494:	0580070e 	bge	zero,r22,8112c4b4 <_dtoa_r+0xa14>
8112c498:	a005883a 	mov	r2,r20
8112c49c:	b500b916 	blt	r22,r20,8112c784 <_dtoa_r+0xce4>
8112c4a0:	d9000817 	ldw	r4,32(sp)
8112c4a4:	a0a9c83a 	sub	r20,r20,r2
8112c4a8:	b0adc83a 	sub	r22,r22,r2
8112c4ac:	2089c83a 	sub	r4,r4,r2
8112c4b0:	d9000815 	stw	r4,32(sp)
8112c4b4:	d9800a17 	ldw	r6,40(sp)
8112c4b8:	0181810e 	bge	zero,r6,8112cac0 <_dtoa_r+0x1020>
8112c4bc:	d9c00b17 	ldw	r7,44(sp)
8112c4c0:	3800b326 	beq	r7,zero,8112c790 <_dtoa_r+0xcf0>
8112c4c4:	a800b226 	beq	r21,zero,8112c790 <_dtoa_r+0xcf0>
8112c4c8:	880b883a 	mov	r5,r17
8112c4cc:	a80d883a 	mov	r6,r21
8112c4d0:	e009883a 	mov	r4,fp
8112c4d4:	112f2200 	call	8112f220 <__pow5mult>
8112c4d8:	d9800917 	ldw	r6,36(sp)
8112c4dc:	100b883a 	mov	r5,r2
8112c4e0:	e009883a 	mov	r4,fp
8112c4e4:	1023883a 	mov	r17,r2
8112c4e8:	112f0200 	call	8112f020 <__multiply>
8112c4ec:	1021883a 	mov	r16,r2
8112c4f0:	d8800a17 	ldw	r2,40(sp)
8112c4f4:	d9400917 	ldw	r5,36(sp)
8112c4f8:	e009883a 	mov	r4,fp
8112c4fc:	1545c83a 	sub	r2,r2,r21
8112c500:	d8800a15 	stw	r2,40(sp)
8112c504:	112ec680 	call	8112ec68 <_Bfree>
8112c508:	d8c00a17 	ldw	r3,40(sp)
8112c50c:	18009f1e 	bne	r3,zero,8112c78c <_dtoa_r+0xcec>
8112c510:	05c00044 	movi	r23,1
8112c514:	e009883a 	mov	r4,fp
8112c518:	b80b883a 	mov	r5,r23
8112c51c:	112efdc0 	call	8112efdc <__i2b>
8112c520:	d9000d17 	ldw	r4,52(sp)
8112c524:	102b883a 	mov	r21,r2
8112c528:	2000ce26 	beq	r4,zero,8112c864 <_dtoa_r+0xdc4>
8112c52c:	200d883a 	mov	r6,r4
8112c530:	100b883a 	mov	r5,r2
8112c534:	e009883a 	mov	r4,fp
8112c538:	112f2200 	call	8112f220 <__pow5mult>
8112c53c:	d9800317 	ldw	r6,12(sp)
8112c540:	102b883a 	mov	r21,r2
8112c544:	b981810e 	bge	r23,r6,8112cb4c <_dtoa_r+0x10ac>
8112c548:	0027883a 	mov	r19,zero
8112c54c:	a8800417 	ldw	r2,16(r21)
8112c550:	05c00804 	movi	r23,32
8112c554:	10800104 	addi	r2,r2,4
8112c558:	1085883a 	add	r2,r2,r2
8112c55c:	1085883a 	add	r2,r2,r2
8112c560:	a885883a 	add	r2,r21,r2
8112c564:	11000017 	ldw	r4,0(r2)
8112c568:	112eec40 	call	8112eec4 <__hi0bits>
8112c56c:	b885c83a 	sub	r2,r23,r2
8112c570:	1585883a 	add	r2,r2,r22
8112c574:	108007cc 	andi	r2,r2,31
8112c578:	1000b326 	beq	r2,zero,8112c848 <_dtoa_r+0xda8>
8112c57c:	00c00804 	movi	r3,32
8112c580:	1887c83a 	sub	r3,r3,r2
8112c584:	01000104 	movi	r4,4
8112c588:	20c2cd0e 	bge	r4,r3,8112d0c0 <_dtoa_r+0x1620>
8112c58c:	00c00704 	movi	r3,28
8112c590:	1885c83a 	sub	r2,r3,r2
8112c594:	d8c00817 	ldw	r3,32(sp)
8112c598:	a0a9883a 	add	r20,r20,r2
8112c59c:	b0ad883a 	add	r22,r22,r2
8112c5a0:	1887883a 	add	r3,r3,r2
8112c5a4:	d8c00815 	stw	r3,32(sp)
8112c5a8:	d9800817 	ldw	r6,32(sp)
8112c5ac:	0180040e 	bge	zero,r6,8112c5c0 <_dtoa_r+0xb20>
8112c5b0:	800b883a 	mov	r5,r16
8112c5b4:	e009883a 	mov	r4,fp
8112c5b8:	112f3680 	call	8112f368 <__lshift>
8112c5bc:	1021883a 	mov	r16,r2
8112c5c0:	0580050e 	bge	zero,r22,8112c5d8 <_dtoa_r+0xb38>
8112c5c4:	a80b883a 	mov	r5,r21
8112c5c8:	b00d883a 	mov	r6,r22
8112c5cc:	e009883a 	mov	r4,fp
8112c5d0:	112f3680 	call	8112f368 <__lshift>
8112c5d4:	102b883a 	mov	r21,r2
8112c5d8:	d9c00e17 	ldw	r7,56(sp)
8112c5dc:	3801211e 	bne	r7,zero,8112ca64 <_dtoa_r+0xfc4>
8112c5e0:	d9800617 	ldw	r6,24(sp)
8112c5e4:	0181380e 	bge	zero,r6,8112cac8 <_dtoa_r+0x1028>
8112c5e8:	d8c00b17 	ldw	r3,44(sp)
8112c5ec:	1800ab1e 	bne	r3,zero,8112c89c <_dtoa_r+0xdfc>
8112c5f0:	dc800717 	ldw	r18,28(sp)
8112c5f4:	dcc00617 	ldw	r19,24(sp)
8112c5f8:	9029883a 	mov	r20,r18
8112c5fc:	00000206 	br	8112c608 <_dtoa_r+0xb68>
8112c600:	112ec900 	call	8112ec90 <__multadd>
8112c604:	1021883a 	mov	r16,r2
8112c608:	a80b883a 	mov	r5,r21
8112c60c:	8009883a 	mov	r4,r16
8112c610:	112b8980 	call	8112b898 <quorem>
8112c614:	10800c04 	addi	r2,r2,48
8112c618:	90800005 	stb	r2,0(r18)
8112c61c:	94800044 	addi	r18,r18,1
8112c620:	9507c83a 	sub	r3,r18,r20
8112c624:	000f883a 	mov	r7,zero
8112c628:	01800284 	movi	r6,10
8112c62c:	800b883a 	mov	r5,r16
8112c630:	e009883a 	mov	r4,fp
8112c634:	1cfff216 	blt	r3,r19,8112c600 <__reset+0xfb10c600>
8112c638:	1011883a 	mov	r8,r2
8112c63c:	d8800617 	ldw	r2,24(sp)
8112c640:	0082370e 	bge	zero,r2,8112cf20 <_dtoa_r+0x1480>
8112c644:	d9000717 	ldw	r4,28(sp)
8112c648:	0025883a 	mov	r18,zero
8112c64c:	20af883a 	add	r23,r4,r2
8112c650:	01800044 	movi	r6,1
8112c654:	800b883a 	mov	r5,r16
8112c658:	e009883a 	mov	r4,fp
8112c65c:	da001715 	stw	r8,92(sp)
8112c660:	112f3680 	call	8112f368 <__lshift>
8112c664:	a80b883a 	mov	r5,r21
8112c668:	1009883a 	mov	r4,r2
8112c66c:	d8800915 	stw	r2,36(sp)
8112c670:	112f4b80 	call	8112f4b8 <__mcmp>
8112c674:	da001717 	ldw	r8,92(sp)
8112c678:	0081800e 	bge	zero,r2,8112cc7c <_dtoa_r+0x11dc>
8112c67c:	b93fffc3 	ldbu	r4,-1(r23)
8112c680:	b8bfffc4 	addi	r2,r23,-1
8112c684:	1007883a 	mov	r3,r2
8112c688:	01800e44 	movi	r6,57
8112c68c:	d9c00717 	ldw	r7,28(sp)
8112c690:	00000506 	br	8112c6a8 <_dtoa_r+0xc08>
8112c694:	18ffffc4 	addi	r3,r3,-1
8112c698:	11c12326 	beq	r2,r7,8112cb28 <_dtoa_r+0x1088>
8112c69c:	19000003 	ldbu	r4,0(r3)
8112c6a0:	102f883a 	mov	r23,r2
8112c6a4:	10bfffc4 	addi	r2,r2,-1
8112c6a8:	21403fcc 	andi	r5,r4,255
8112c6ac:	2940201c 	xori	r5,r5,128
8112c6b0:	297fe004 	addi	r5,r5,-128
8112c6b4:	29bff726 	beq	r5,r6,8112c694 <__reset+0xfb10c694>
8112c6b8:	21000044 	addi	r4,r4,1
8112c6bc:	11000005 	stb	r4,0(r2)
8112c6c0:	a80b883a 	mov	r5,r21
8112c6c4:	e009883a 	mov	r4,fp
8112c6c8:	112ec680 	call	8112ec68 <_Bfree>
8112c6cc:	883ea026 	beq	r17,zero,8112c150 <__reset+0xfb10c150>
8112c6d0:	90000426 	beq	r18,zero,8112c6e4 <_dtoa_r+0xc44>
8112c6d4:	94400326 	beq	r18,r17,8112c6e4 <_dtoa_r+0xc44>
8112c6d8:	900b883a 	mov	r5,r18
8112c6dc:	e009883a 	mov	r4,fp
8112c6e0:	112ec680 	call	8112ec68 <_Bfree>
8112c6e4:	880b883a 	mov	r5,r17
8112c6e8:	e009883a 	mov	r4,fp
8112c6ec:	112ec680 	call	8112ec68 <_Bfree>
8112c6f0:	003e9706 	br	8112c150 <__reset+0xfb10c150>
8112c6f4:	01800044 	movi	r6,1
8112c6f8:	d9800e15 	stw	r6,56(sp)
8112c6fc:	003d9606 	br	8112bd58 <__reset+0xfb10bd58>
8112c700:	d8800817 	ldw	r2,32(sp)
8112c704:	d8c00517 	ldw	r3,20(sp)
8112c708:	d8000d15 	stw	zero,52(sp)
8112c70c:	10c5c83a 	sub	r2,r2,r3
8112c710:	00c9c83a 	sub	r4,zero,r3
8112c714:	d8800815 	stw	r2,32(sp)
8112c718:	d9000a15 	stw	r4,40(sp)
8112c71c:	003d9706 	br	8112bd7c <__reset+0xfb10bd7c>
8112c720:	05adc83a 	sub	r22,zero,r22
8112c724:	dd800815 	stw	r22,32(sp)
8112c728:	002d883a 	mov	r22,zero
8112c72c:	003d8e06 	br	8112bd68 <__reset+0xfb10bd68>
8112c730:	d9000517 	ldw	r4,20(sp)
8112c734:	11230d40 	call	811230d4 <__floatsidf>
8112c738:	100d883a 	mov	r6,r2
8112c73c:	180f883a 	mov	r7,r3
8112c740:	a009883a 	mov	r4,r20
8112c744:	880b883a 	mov	r5,r17
8112c748:	11380680 	call	81138068 <__eqdf2>
8112c74c:	103d7126 	beq	r2,zero,8112bd14 <__reset+0xfb10bd14>
8112c750:	d9c00517 	ldw	r7,20(sp)
8112c754:	39ffffc4 	addi	r7,r7,-1
8112c758:	d9c00515 	stw	r7,20(sp)
8112c75c:	003d6d06 	br	8112bd14 <__reset+0xfb10bd14>
8112c760:	dd400a17 	ldw	r21,40(sp)
8112c764:	dd000817 	ldw	r20,32(sp)
8112c768:	0023883a 	mov	r17,zero
8112c76c:	003f4806 	br	8112c490 <__reset+0xfb10c490>
8112c770:	10e3c83a 	sub	r17,r2,r3
8112c774:	9448983a 	sll	r4,r18,r17
8112c778:	003d3206 	br	8112bc44 <__reset+0xfb10bc44>
8112c77c:	d8000e15 	stw	zero,56(sp)
8112c780:	003d7506 	br	8112bd58 <__reset+0xfb10bd58>
8112c784:	b005883a 	mov	r2,r22
8112c788:	003f4506 	br	8112c4a0 <__reset+0xfb10c4a0>
8112c78c:	dc000915 	stw	r16,36(sp)
8112c790:	d9800a17 	ldw	r6,40(sp)
8112c794:	d9400917 	ldw	r5,36(sp)
8112c798:	e009883a 	mov	r4,fp
8112c79c:	112f2200 	call	8112f220 <__pow5mult>
8112c7a0:	1021883a 	mov	r16,r2
8112c7a4:	003f5a06 	br	8112c510 <__reset+0xfb10c510>
8112c7a8:	01c00044 	movi	r7,1
8112c7ac:	d9c00b15 	stw	r7,44(sp)
8112c7b0:	d8802217 	ldw	r2,136(sp)
8112c7b4:	0081280e 	bge	zero,r2,8112cc58 <_dtoa_r+0x11b8>
8112c7b8:	100d883a 	mov	r6,r2
8112c7bc:	1021883a 	mov	r16,r2
8112c7c0:	d8800c15 	stw	r2,48(sp)
8112c7c4:	d8800615 	stw	r2,24(sp)
8112c7c8:	003d8806 	br	8112bdec <__reset+0xfb10bdec>
8112c7cc:	d8800617 	ldw	r2,24(sp)
8112c7d0:	00be9b16 	blt	zero,r2,8112c240 <__reset+0xfb10c240>
8112c7d4:	10010f1e 	bne	r2,zero,8112cc14 <_dtoa_r+0x1174>
8112c7d8:	880b883a 	mov	r5,r17
8112c7dc:	000d883a 	mov	r6,zero
8112c7e0:	01d00534 	movhi	r7,16404
8112c7e4:	8009883a 	mov	r4,r16
8112c7e8:	11220300 	call	81122030 <__muldf3>
8112c7ec:	900d883a 	mov	r6,r18
8112c7f0:	980f883a 	mov	r7,r19
8112c7f4:	1009883a 	mov	r4,r2
8112c7f8:	180b883a 	mov	r5,r3
8112c7fc:	1121f540 	call	81121f54 <__gedf2>
8112c800:	002b883a 	mov	r21,zero
8112c804:	0023883a 	mov	r17,zero
8112c808:	1000bf16 	blt	r2,zero,8112cb08 <_dtoa_r+0x1068>
8112c80c:	d9802217 	ldw	r6,136(sp)
8112c810:	ddc00717 	ldw	r23,28(sp)
8112c814:	018c303a 	nor	r6,zero,r6
8112c818:	d9800515 	stw	r6,20(sp)
8112c81c:	a80b883a 	mov	r5,r21
8112c820:	e009883a 	mov	r4,fp
8112c824:	112ec680 	call	8112ec68 <_Bfree>
8112c828:	883e4926 	beq	r17,zero,8112c150 <__reset+0xfb10c150>
8112c82c:	003fad06 	br	8112c6e4 <__reset+0xfb10c6e4>
8112c830:	d9c01117 	ldw	r7,68(sp)
8112c834:	3801bc26 	beq	r7,zero,8112cf28 <_dtoa_r+0x1488>
8112c838:	10810cc4 	addi	r2,r2,1075
8112c83c:	dd400a17 	ldw	r21,40(sp)
8112c840:	dd000817 	ldw	r20,32(sp)
8112c844:	003f0a06 	br	8112c470 <__reset+0xfb10c470>
8112c848:	00800704 	movi	r2,28
8112c84c:	d9000817 	ldw	r4,32(sp)
8112c850:	a0a9883a 	add	r20,r20,r2
8112c854:	b0ad883a 	add	r22,r22,r2
8112c858:	2089883a 	add	r4,r4,r2
8112c85c:	d9000815 	stw	r4,32(sp)
8112c860:	003f5106 	br	8112c5a8 <__reset+0xfb10c5a8>
8112c864:	d8c00317 	ldw	r3,12(sp)
8112c868:	b8c1fc0e 	bge	r23,r3,8112d05c <_dtoa_r+0x15bc>
8112c86c:	0027883a 	mov	r19,zero
8112c870:	b805883a 	mov	r2,r23
8112c874:	003f3e06 	br	8112c570 <__reset+0xfb10c570>
8112c878:	880b883a 	mov	r5,r17
8112c87c:	e009883a 	mov	r4,fp
8112c880:	000f883a 	mov	r7,zero
8112c884:	01800284 	movi	r6,10
8112c888:	112ec900 	call	8112ec90 <__multadd>
8112c88c:	d9000c17 	ldw	r4,48(sp)
8112c890:	1023883a 	mov	r17,r2
8112c894:	0102040e 	bge	zero,r4,8112d0a8 <_dtoa_r+0x1608>
8112c898:	d9000615 	stw	r4,24(sp)
8112c89c:	0500050e 	bge	zero,r20,8112c8b4 <_dtoa_r+0xe14>
8112c8a0:	880b883a 	mov	r5,r17
8112c8a4:	a00d883a 	mov	r6,r20
8112c8a8:	e009883a 	mov	r4,fp
8112c8ac:	112f3680 	call	8112f368 <__lshift>
8112c8b0:	1023883a 	mov	r17,r2
8112c8b4:	9801241e 	bne	r19,zero,8112cd48 <_dtoa_r+0x12a8>
8112c8b8:	8829883a 	mov	r20,r17
8112c8bc:	d9000617 	ldw	r4,24(sp)
8112c8c0:	dcc00717 	ldw	r19,28(sp)
8112c8c4:	9480004c 	andi	r18,r18,1
8112c8c8:	20bfffc4 	addi	r2,r4,-1
8112c8cc:	9885883a 	add	r2,r19,r2
8112c8d0:	d8800415 	stw	r2,16(sp)
8112c8d4:	dc800615 	stw	r18,24(sp)
8112c8d8:	a80b883a 	mov	r5,r21
8112c8dc:	8009883a 	mov	r4,r16
8112c8e0:	112b8980 	call	8112b898 <quorem>
8112c8e4:	880b883a 	mov	r5,r17
8112c8e8:	8009883a 	mov	r4,r16
8112c8ec:	102f883a 	mov	r23,r2
8112c8f0:	112f4b80 	call	8112f4b8 <__mcmp>
8112c8f4:	a80b883a 	mov	r5,r21
8112c8f8:	a00d883a 	mov	r6,r20
8112c8fc:	e009883a 	mov	r4,fp
8112c900:	102d883a 	mov	r22,r2
8112c904:	112f5180 	call	8112f518 <__mdiff>
8112c908:	1007883a 	mov	r3,r2
8112c90c:	10800317 	ldw	r2,12(r2)
8112c910:	bc800c04 	addi	r18,r23,48
8112c914:	180b883a 	mov	r5,r3
8112c918:	10004e1e 	bne	r2,zero,8112ca54 <_dtoa_r+0xfb4>
8112c91c:	8009883a 	mov	r4,r16
8112c920:	d8c01615 	stw	r3,88(sp)
8112c924:	112f4b80 	call	8112f4b8 <__mcmp>
8112c928:	d8c01617 	ldw	r3,88(sp)
8112c92c:	e009883a 	mov	r4,fp
8112c930:	d8801615 	stw	r2,88(sp)
8112c934:	180b883a 	mov	r5,r3
8112c938:	112ec680 	call	8112ec68 <_Bfree>
8112c93c:	d8801617 	ldw	r2,88(sp)
8112c940:	1000041e 	bne	r2,zero,8112c954 <_dtoa_r+0xeb4>
8112c944:	d9800317 	ldw	r6,12(sp)
8112c948:	3000021e 	bne	r6,zero,8112c954 <_dtoa_r+0xeb4>
8112c94c:	d8c00617 	ldw	r3,24(sp)
8112c950:	18003726 	beq	r3,zero,8112ca30 <_dtoa_r+0xf90>
8112c954:	b0002016 	blt	r22,zero,8112c9d8 <_dtoa_r+0xf38>
8112c958:	b000041e 	bne	r22,zero,8112c96c <_dtoa_r+0xecc>
8112c95c:	d9000317 	ldw	r4,12(sp)
8112c960:	2000021e 	bne	r4,zero,8112c96c <_dtoa_r+0xecc>
8112c964:	d8c00617 	ldw	r3,24(sp)
8112c968:	18001b26 	beq	r3,zero,8112c9d8 <_dtoa_r+0xf38>
8112c96c:	00810716 	blt	zero,r2,8112cd8c <_dtoa_r+0x12ec>
8112c970:	d8c00417 	ldw	r3,16(sp)
8112c974:	9d800044 	addi	r22,r19,1
8112c978:	9c800005 	stb	r18,0(r19)
8112c97c:	b02f883a 	mov	r23,r22
8112c980:	98c10626 	beq	r19,r3,8112cd9c <_dtoa_r+0x12fc>
8112c984:	800b883a 	mov	r5,r16
8112c988:	000f883a 	mov	r7,zero
8112c98c:	01800284 	movi	r6,10
8112c990:	e009883a 	mov	r4,fp
8112c994:	112ec900 	call	8112ec90 <__multadd>
8112c998:	1021883a 	mov	r16,r2
8112c99c:	000f883a 	mov	r7,zero
8112c9a0:	01800284 	movi	r6,10
8112c9a4:	880b883a 	mov	r5,r17
8112c9a8:	e009883a 	mov	r4,fp
8112c9ac:	8d002526 	beq	r17,r20,8112ca44 <_dtoa_r+0xfa4>
8112c9b0:	112ec900 	call	8112ec90 <__multadd>
8112c9b4:	a00b883a 	mov	r5,r20
8112c9b8:	000f883a 	mov	r7,zero
8112c9bc:	01800284 	movi	r6,10
8112c9c0:	e009883a 	mov	r4,fp
8112c9c4:	1023883a 	mov	r17,r2
8112c9c8:	112ec900 	call	8112ec90 <__multadd>
8112c9cc:	1029883a 	mov	r20,r2
8112c9d0:	b027883a 	mov	r19,r22
8112c9d4:	003fc006 	br	8112c8d8 <__reset+0xfb10c8d8>
8112c9d8:	9011883a 	mov	r8,r18
8112c9dc:	00800e0e 	bge	zero,r2,8112ca18 <_dtoa_r+0xf78>
8112c9e0:	800b883a 	mov	r5,r16
8112c9e4:	01800044 	movi	r6,1
8112c9e8:	e009883a 	mov	r4,fp
8112c9ec:	da001715 	stw	r8,92(sp)
8112c9f0:	112f3680 	call	8112f368 <__lshift>
8112c9f4:	a80b883a 	mov	r5,r21
8112c9f8:	1009883a 	mov	r4,r2
8112c9fc:	1021883a 	mov	r16,r2
8112ca00:	112f4b80 	call	8112f4b8 <__mcmp>
8112ca04:	da001717 	ldw	r8,92(sp)
8112ca08:	0081960e 	bge	zero,r2,8112d064 <_dtoa_r+0x15c4>
8112ca0c:	00800e44 	movi	r2,57
8112ca10:	40817026 	beq	r8,r2,8112cfd4 <_dtoa_r+0x1534>
8112ca14:	ba000c44 	addi	r8,r23,49
8112ca18:	8825883a 	mov	r18,r17
8112ca1c:	9dc00044 	addi	r23,r19,1
8112ca20:	9a000005 	stb	r8,0(r19)
8112ca24:	a023883a 	mov	r17,r20
8112ca28:	dc000915 	stw	r16,36(sp)
8112ca2c:	003f2406 	br	8112c6c0 <__reset+0xfb10c6c0>
8112ca30:	00800e44 	movi	r2,57
8112ca34:	9011883a 	mov	r8,r18
8112ca38:	90816626 	beq	r18,r2,8112cfd4 <_dtoa_r+0x1534>
8112ca3c:	05bff516 	blt	zero,r22,8112ca14 <__reset+0xfb10ca14>
8112ca40:	003ff506 	br	8112ca18 <__reset+0xfb10ca18>
8112ca44:	112ec900 	call	8112ec90 <__multadd>
8112ca48:	1023883a 	mov	r17,r2
8112ca4c:	1029883a 	mov	r20,r2
8112ca50:	003fdf06 	br	8112c9d0 <__reset+0xfb10c9d0>
8112ca54:	e009883a 	mov	r4,fp
8112ca58:	112ec680 	call	8112ec68 <_Bfree>
8112ca5c:	00800044 	movi	r2,1
8112ca60:	003fbc06 	br	8112c954 <__reset+0xfb10c954>
8112ca64:	a80b883a 	mov	r5,r21
8112ca68:	8009883a 	mov	r4,r16
8112ca6c:	112f4b80 	call	8112f4b8 <__mcmp>
8112ca70:	103edb0e 	bge	r2,zero,8112c5e0 <__reset+0xfb10c5e0>
8112ca74:	800b883a 	mov	r5,r16
8112ca78:	000f883a 	mov	r7,zero
8112ca7c:	01800284 	movi	r6,10
8112ca80:	e009883a 	mov	r4,fp
8112ca84:	112ec900 	call	8112ec90 <__multadd>
8112ca88:	1021883a 	mov	r16,r2
8112ca8c:	d8800517 	ldw	r2,20(sp)
8112ca90:	d8c00b17 	ldw	r3,44(sp)
8112ca94:	10bfffc4 	addi	r2,r2,-1
8112ca98:	d8800515 	stw	r2,20(sp)
8112ca9c:	183f761e 	bne	r3,zero,8112c878 <__reset+0xfb10c878>
8112caa0:	d9000c17 	ldw	r4,48(sp)
8112caa4:	0101730e 	bge	zero,r4,8112d074 <_dtoa_r+0x15d4>
8112caa8:	d9000615 	stw	r4,24(sp)
8112caac:	003ed006 	br	8112c5f0 <__reset+0xfb10c5f0>
8112cab0:	00800084 	movi	r2,2
8112cab4:	3081861e 	bne	r6,r2,8112d0d0 <_dtoa_r+0x1630>
8112cab8:	d8000b15 	stw	zero,44(sp)
8112cabc:	003f3c06 	br	8112c7b0 <__reset+0xfb10c7b0>
8112cac0:	dc000917 	ldw	r16,36(sp)
8112cac4:	003e9206 	br	8112c510 <__reset+0xfb10c510>
8112cac8:	d9c00317 	ldw	r7,12(sp)
8112cacc:	00800084 	movi	r2,2
8112cad0:	11fec50e 	bge	r2,r7,8112c5e8 <__reset+0xfb10c5e8>
8112cad4:	d9000617 	ldw	r4,24(sp)
8112cad8:	20013c1e 	bne	r4,zero,8112cfcc <_dtoa_r+0x152c>
8112cadc:	a80b883a 	mov	r5,r21
8112cae0:	000f883a 	mov	r7,zero
8112cae4:	01800144 	movi	r6,5
8112cae8:	e009883a 	mov	r4,fp
8112caec:	112ec900 	call	8112ec90 <__multadd>
8112caf0:	100b883a 	mov	r5,r2
8112caf4:	8009883a 	mov	r4,r16
8112caf8:	102b883a 	mov	r21,r2
8112cafc:	112f4b80 	call	8112f4b8 <__mcmp>
8112cb00:	dc000915 	stw	r16,36(sp)
8112cb04:	00bf410e 	bge	zero,r2,8112c80c <__reset+0xfb10c80c>
8112cb08:	d9c00717 	ldw	r7,28(sp)
8112cb0c:	00800c44 	movi	r2,49
8112cb10:	38800005 	stb	r2,0(r7)
8112cb14:	d8800517 	ldw	r2,20(sp)
8112cb18:	3dc00044 	addi	r23,r7,1
8112cb1c:	10800044 	addi	r2,r2,1
8112cb20:	d8800515 	stw	r2,20(sp)
8112cb24:	003f3d06 	br	8112c81c <__reset+0xfb10c81c>
8112cb28:	d9800517 	ldw	r6,20(sp)
8112cb2c:	d9c00717 	ldw	r7,28(sp)
8112cb30:	00800c44 	movi	r2,49
8112cb34:	31800044 	addi	r6,r6,1
8112cb38:	d9800515 	stw	r6,20(sp)
8112cb3c:	38800005 	stb	r2,0(r7)
8112cb40:	003edf06 	br	8112c6c0 <__reset+0xfb10c6c0>
8112cb44:	d8000b15 	stw	zero,44(sp)
8112cb48:	003c9f06 	br	8112bdc8 <__reset+0xfb10bdc8>
8112cb4c:	903e7e1e 	bne	r18,zero,8112c548 <__reset+0xfb10c548>
8112cb50:	00800434 	movhi	r2,16
8112cb54:	10bfffc4 	addi	r2,r2,-1
8112cb58:	9884703a 	and	r2,r19,r2
8112cb5c:	1000ea1e 	bne	r2,zero,8112cf08 <_dtoa_r+0x1468>
8112cb60:	9cdffc2c 	andhi	r19,r19,32752
8112cb64:	9800e826 	beq	r19,zero,8112cf08 <_dtoa_r+0x1468>
8112cb68:	d9c00817 	ldw	r7,32(sp)
8112cb6c:	b5800044 	addi	r22,r22,1
8112cb70:	04c00044 	movi	r19,1
8112cb74:	39c00044 	addi	r7,r7,1
8112cb78:	d9c00815 	stw	r7,32(sp)
8112cb7c:	d8800d17 	ldw	r2,52(sp)
8112cb80:	103e721e 	bne	r2,zero,8112c54c <__reset+0xfb10c54c>
8112cb84:	00800044 	movi	r2,1
8112cb88:	003e7906 	br	8112c570 <__reset+0xfb10c570>
8112cb8c:	8009883a 	mov	r4,r16
8112cb90:	11230d40 	call	811230d4 <__floatsidf>
8112cb94:	d9800f17 	ldw	r6,60(sp)
8112cb98:	d9c01017 	ldw	r7,64(sp)
8112cb9c:	1009883a 	mov	r4,r2
8112cba0:	180b883a 	mov	r5,r3
8112cba4:	11220300 	call	81122030 <__muldf3>
8112cba8:	000d883a 	mov	r6,zero
8112cbac:	01d00734 	movhi	r7,16412
8112cbb0:	1009883a 	mov	r4,r2
8112cbb4:	180b883a 	mov	r5,r3
8112cbb8:	1136ec40 	call	81136ec4 <__adddf3>
8112cbbc:	047f3034 	movhi	r17,64704
8112cbc0:	1021883a 	mov	r16,r2
8112cbc4:	1c63883a 	add	r17,r3,r17
8112cbc8:	d9000f17 	ldw	r4,60(sp)
8112cbcc:	d9401017 	ldw	r5,64(sp)
8112cbd0:	000d883a 	mov	r6,zero
8112cbd4:	01d00534 	movhi	r7,16404
8112cbd8:	11227500 	call	81122750 <__subdf3>
8112cbdc:	800d883a 	mov	r6,r16
8112cbe0:	880f883a 	mov	r7,r17
8112cbe4:	1009883a 	mov	r4,r2
8112cbe8:	180b883a 	mov	r5,r3
8112cbec:	102b883a 	mov	r21,r2
8112cbf0:	1829883a 	mov	r20,r3
8112cbf4:	1121f540 	call	81121f54 <__gedf2>
8112cbf8:	00806c16 	blt	zero,r2,8112cdac <_dtoa_r+0x130c>
8112cbfc:	89e0003c 	xorhi	r7,r17,32768
8112cc00:	800d883a 	mov	r6,r16
8112cc04:	a809883a 	mov	r4,r21
8112cc08:	a00b883a 	mov	r5,r20
8112cc0c:	11380f00 	call	811380f0 <__ledf2>
8112cc10:	103d7e0e 	bge	r2,zero,8112c20c <__reset+0xfb10c20c>
8112cc14:	002b883a 	mov	r21,zero
8112cc18:	0023883a 	mov	r17,zero
8112cc1c:	003efb06 	br	8112c80c <__reset+0xfb10c80c>
8112cc20:	d8800717 	ldw	r2,28(sp)
8112cc24:	003bd006 	br	8112bb68 <__reset+0xfb10bb68>
8112cc28:	d9000a17 	ldw	r4,40(sp)
8112cc2c:	d9800d17 	ldw	r6,52(sp)
8112cc30:	dd400a15 	stw	r21,40(sp)
8112cc34:	a905c83a 	sub	r2,r21,r4
8112cc38:	308d883a 	add	r6,r6,r2
8112cc3c:	d9800d15 	stw	r6,52(sp)
8112cc40:	002b883a 	mov	r21,zero
8112cc44:	003e0606 	br	8112c460 <__reset+0xfb10c460>
8112cc48:	9023883a 	mov	r17,r18
8112cc4c:	9829883a 	mov	r20,r19
8112cc50:	04000084 	movi	r16,2
8112cc54:	003c9206 	br	8112bea0 <__reset+0xfb10bea0>
8112cc58:	04000044 	movi	r16,1
8112cc5c:	dc000c15 	stw	r16,48(sp)
8112cc60:	dc000615 	stw	r16,24(sp)
8112cc64:	dc002215 	stw	r16,136(sp)
8112cc68:	e0001115 	stw	zero,68(fp)
8112cc6c:	000b883a 	mov	r5,zero
8112cc70:	003c6906 	br	8112be18 <__reset+0xfb10be18>
8112cc74:	3021883a 	mov	r16,r6
8112cc78:	003ffb06 	br	8112cc68 <__reset+0xfb10cc68>
8112cc7c:	1000021e 	bne	r2,zero,8112cc88 <_dtoa_r+0x11e8>
8112cc80:	4200004c 	andi	r8,r8,1
8112cc84:	403e7d1e 	bne	r8,zero,8112c67c <__reset+0xfb10c67c>
8112cc88:	01000c04 	movi	r4,48
8112cc8c:	00000106 	br	8112cc94 <_dtoa_r+0x11f4>
8112cc90:	102f883a 	mov	r23,r2
8112cc94:	b8bfffc4 	addi	r2,r23,-1
8112cc98:	10c00007 	ldb	r3,0(r2)
8112cc9c:	193ffc26 	beq	r3,r4,8112cc90 <__reset+0xfb10cc90>
8112cca0:	003e8706 	br	8112c6c0 <__reset+0xfb10c6c0>
8112cca4:	d8800517 	ldw	r2,20(sp)
8112cca8:	00a3c83a 	sub	r17,zero,r2
8112ccac:	8800a426 	beq	r17,zero,8112cf40 <_dtoa_r+0x14a0>
8112ccb0:	888003cc 	andi	r2,r17,15
8112ccb4:	100490fa 	slli	r2,r2,3
8112ccb8:	00e04574 	movhi	r3,33045
8112ccbc:	18cacd04 	addi	r3,r3,11060
8112ccc0:	1885883a 	add	r2,r3,r2
8112ccc4:	11800017 	ldw	r6,0(r2)
8112ccc8:	11c00117 	ldw	r7,4(r2)
8112cccc:	9009883a 	mov	r4,r18
8112ccd0:	980b883a 	mov	r5,r19
8112ccd4:	8823d13a 	srai	r17,r17,4
8112ccd8:	11220300 	call	81122030 <__muldf3>
8112ccdc:	d8800f15 	stw	r2,60(sp)
8112cce0:	d8c01015 	stw	r3,64(sp)
8112cce4:	8800e826 	beq	r17,zero,8112d088 <_dtoa_r+0x15e8>
8112cce8:	05204574 	movhi	r20,33045
8112ccec:	a50ac304 	addi	r20,r20,11020
8112ccf0:	04000084 	movi	r16,2
8112ccf4:	8980004c 	andi	r6,r17,1
8112ccf8:	1009883a 	mov	r4,r2
8112ccfc:	8823d07a 	srai	r17,r17,1
8112cd00:	180b883a 	mov	r5,r3
8112cd04:	30000426 	beq	r6,zero,8112cd18 <_dtoa_r+0x1278>
8112cd08:	a1800017 	ldw	r6,0(r20)
8112cd0c:	a1c00117 	ldw	r7,4(r20)
8112cd10:	84000044 	addi	r16,r16,1
8112cd14:	11220300 	call	81122030 <__muldf3>
8112cd18:	a5000204 	addi	r20,r20,8
8112cd1c:	883ff51e 	bne	r17,zero,8112ccf4 <__reset+0xfb10ccf4>
8112cd20:	d8800f15 	stw	r2,60(sp)
8112cd24:	d8c01015 	stw	r3,64(sp)
8112cd28:	003c7606 	br	8112bf04 <__reset+0xfb10bf04>
8112cd2c:	00c00c04 	movi	r3,48
8112cd30:	10c00005 	stb	r3,0(r2)
8112cd34:	d8c00517 	ldw	r3,20(sp)
8112cd38:	bd3fffc3 	ldbu	r20,-1(r23)
8112cd3c:	18c00044 	addi	r3,r3,1
8112cd40:	d8c00515 	stw	r3,20(sp)
8112cd44:	003db906 	br	8112c42c <__reset+0xfb10c42c>
8112cd48:	89400117 	ldw	r5,4(r17)
8112cd4c:	e009883a 	mov	r4,fp
8112cd50:	112ebb80 	call	8112ebb8 <_Balloc>
8112cd54:	89800417 	ldw	r6,16(r17)
8112cd58:	89400304 	addi	r5,r17,12
8112cd5c:	11000304 	addi	r4,r2,12
8112cd60:	31800084 	addi	r6,r6,2
8112cd64:	318d883a 	add	r6,r6,r6
8112cd68:	318d883a 	add	r6,r6,r6
8112cd6c:	1027883a 	mov	r19,r2
8112cd70:	11247000 	call	81124700 <memcpy>
8112cd74:	01800044 	movi	r6,1
8112cd78:	980b883a 	mov	r5,r19
8112cd7c:	e009883a 	mov	r4,fp
8112cd80:	112f3680 	call	8112f368 <__lshift>
8112cd84:	1029883a 	mov	r20,r2
8112cd88:	003ecc06 	br	8112c8bc <__reset+0xfb10c8bc>
8112cd8c:	00800e44 	movi	r2,57
8112cd90:	90809026 	beq	r18,r2,8112cfd4 <_dtoa_r+0x1534>
8112cd94:	92000044 	addi	r8,r18,1
8112cd98:	003f1f06 	br	8112ca18 <__reset+0xfb10ca18>
8112cd9c:	9011883a 	mov	r8,r18
8112cda0:	8825883a 	mov	r18,r17
8112cda4:	a023883a 	mov	r17,r20
8112cda8:	003e2906 	br	8112c650 <__reset+0xfb10c650>
8112cdac:	002b883a 	mov	r21,zero
8112cdb0:	0023883a 	mov	r17,zero
8112cdb4:	003f5406 	br	8112cb08 <__reset+0xfb10cb08>
8112cdb8:	61bfffc4 	addi	r6,r12,-1
8112cdbc:	300490fa 	slli	r2,r6,3
8112cdc0:	00e04574 	movhi	r3,33045
8112cdc4:	18cacd04 	addi	r3,r3,11060
8112cdc8:	1885883a 	add	r2,r3,r2
8112cdcc:	11000017 	ldw	r4,0(r2)
8112cdd0:	11400117 	ldw	r5,4(r2)
8112cdd4:	d8800717 	ldw	r2,28(sp)
8112cdd8:	880f883a 	mov	r7,r17
8112cddc:	d9801215 	stw	r6,72(sp)
8112cde0:	800d883a 	mov	r6,r16
8112cde4:	db001615 	stw	r12,88(sp)
8112cde8:	15c00044 	addi	r23,r2,1
8112cdec:	11220300 	call	81122030 <__muldf3>
8112cdf0:	d9401017 	ldw	r5,64(sp)
8112cdf4:	d9000f17 	ldw	r4,60(sp)
8112cdf8:	d8c01515 	stw	r3,84(sp)
8112cdfc:	d8801415 	stw	r2,80(sp)
8112ce00:	11230540 	call	81123054 <__fixdfsi>
8112ce04:	1009883a 	mov	r4,r2
8112ce08:	1021883a 	mov	r16,r2
8112ce0c:	11230d40 	call	811230d4 <__floatsidf>
8112ce10:	d9000f17 	ldw	r4,60(sp)
8112ce14:	d9401017 	ldw	r5,64(sp)
8112ce18:	100d883a 	mov	r6,r2
8112ce1c:	180f883a 	mov	r7,r3
8112ce20:	11227500 	call	81122750 <__subdf3>
8112ce24:	1829883a 	mov	r20,r3
8112ce28:	d8c00717 	ldw	r3,28(sp)
8112ce2c:	84000c04 	addi	r16,r16,48
8112ce30:	1023883a 	mov	r17,r2
8112ce34:	1c000005 	stb	r16,0(r3)
8112ce38:	db001617 	ldw	r12,88(sp)
8112ce3c:	00800044 	movi	r2,1
8112ce40:	60802226 	beq	r12,r2,8112cecc <_dtoa_r+0x142c>
8112ce44:	d9c00717 	ldw	r7,28(sp)
8112ce48:	8805883a 	mov	r2,r17
8112ce4c:	b82b883a 	mov	r21,r23
8112ce50:	3b19883a 	add	r12,r7,r12
8112ce54:	6023883a 	mov	r17,r12
8112ce58:	a007883a 	mov	r3,r20
8112ce5c:	dc800f15 	stw	r18,60(sp)
8112ce60:	000d883a 	mov	r6,zero
8112ce64:	01d00934 	movhi	r7,16420
8112ce68:	1009883a 	mov	r4,r2
8112ce6c:	180b883a 	mov	r5,r3
8112ce70:	11220300 	call	81122030 <__muldf3>
8112ce74:	180b883a 	mov	r5,r3
8112ce78:	1009883a 	mov	r4,r2
8112ce7c:	1829883a 	mov	r20,r3
8112ce80:	1025883a 	mov	r18,r2
8112ce84:	11230540 	call	81123054 <__fixdfsi>
8112ce88:	1009883a 	mov	r4,r2
8112ce8c:	1021883a 	mov	r16,r2
8112ce90:	11230d40 	call	811230d4 <__floatsidf>
8112ce94:	100d883a 	mov	r6,r2
8112ce98:	180f883a 	mov	r7,r3
8112ce9c:	9009883a 	mov	r4,r18
8112cea0:	a00b883a 	mov	r5,r20
8112cea4:	84000c04 	addi	r16,r16,48
8112cea8:	11227500 	call	81122750 <__subdf3>
8112ceac:	ad400044 	addi	r21,r21,1
8112ceb0:	ac3fffc5 	stb	r16,-1(r21)
8112ceb4:	ac7fea1e 	bne	r21,r17,8112ce60 <__reset+0xfb10ce60>
8112ceb8:	1023883a 	mov	r17,r2
8112cebc:	d8801217 	ldw	r2,72(sp)
8112cec0:	dc800f17 	ldw	r18,60(sp)
8112cec4:	1829883a 	mov	r20,r3
8112cec8:	b8af883a 	add	r23,r23,r2
8112cecc:	d9001417 	ldw	r4,80(sp)
8112ced0:	d9401517 	ldw	r5,84(sp)
8112ced4:	000d883a 	mov	r6,zero
8112ced8:	01cff834 	movhi	r7,16352
8112cedc:	1136ec40 	call	81136ec4 <__adddf3>
8112cee0:	880d883a 	mov	r6,r17
8112cee4:	a00f883a 	mov	r7,r20
8112cee8:	1009883a 	mov	r4,r2
8112ceec:	180b883a 	mov	r5,r3
8112cef0:	11380f00 	call	811380f0 <__ledf2>
8112cef4:	10003e0e 	bge	r2,zero,8112cff0 <_dtoa_r+0x1550>
8112cef8:	d9001317 	ldw	r4,76(sp)
8112cefc:	bd3fffc3 	ldbu	r20,-1(r23)
8112cf00:	d9000515 	stw	r4,20(sp)
8112cf04:	003d3b06 	br	8112c3f4 <__reset+0xfb10c3f4>
8112cf08:	0027883a 	mov	r19,zero
8112cf0c:	003f1b06 	br	8112cb7c <__reset+0xfb10cb7c>
8112cf10:	d8800817 	ldw	r2,32(sp)
8112cf14:	11e9c83a 	sub	r20,r2,r7
8112cf18:	0005883a 	mov	r2,zero
8112cf1c:	003d5406 	br	8112c470 <__reset+0xfb10c470>
8112cf20:	00800044 	movi	r2,1
8112cf24:	003dc706 	br	8112c644 <__reset+0xfb10c644>
8112cf28:	d8c00217 	ldw	r3,8(sp)
8112cf2c:	00800d84 	movi	r2,54
8112cf30:	dd400a17 	ldw	r21,40(sp)
8112cf34:	10c5c83a 	sub	r2,r2,r3
8112cf38:	dd000817 	ldw	r20,32(sp)
8112cf3c:	003d4c06 	br	8112c470 <__reset+0xfb10c470>
8112cf40:	dc800f15 	stw	r18,60(sp)
8112cf44:	dcc01015 	stw	r19,64(sp)
8112cf48:	04000084 	movi	r16,2
8112cf4c:	003bed06 	br	8112bf04 <__reset+0xfb10bf04>
8112cf50:	d9000617 	ldw	r4,24(sp)
8112cf54:	203f0d26 	beq	r4,zero,8112cb8c <__reset+0xfb10cb8c>
8112cf58:	d9800c17 	ldw	r6,48(sp)
8112cf5c:	01bcab0e 	bge	zero,r6,8112c20c <__reset+0xfb10c20c>
8112cf60:	d9401017 	ldw	r5,64(sp)
8112cf64:	d9000f17 	ldw	r4,60(sp)
8112cf68:	000d883a 	mov	r6,zero
8112cf6c:	01d00934 	movhi	r7,16420
8112cf70:	11220300 	call	81122030 <__muldf3>
8112cf74:	81000044 	addi	r4,r16,1
8112cf78:	d8800f15 	stw	r2,60(sp)
8112cf7c:	d8c01015 	stw	r3,64(sp)
8112cf80:	11230d40 	call	811230d4 <__floatsidf>
8112cf84:	d9800f17 	ldw	r6,60(sp)
8112cf88:	d9c01017 	ldw	r7,64(sp)
8112cf8c:	1009883a 	mov	r4,r2
8112cf90:	180b883a 	mov	r5,r3
8112cf94:	11220300 	call	81122030 <__muldf3>
8112cf98:	01d00734 	movhi	r7,16412
8112cf9c:	000d883a 	mov	r6,zero
8112cfa0:	1009883a 	mov	r4,r2
8112cfa4:	180b883a 	mov	r5,r3
8112cfa8:	1136ec40 	call	81136ec4 <__adddf3>
8112cfac:	d9c00517 	ldw	r7,20(sp)
8112cfb0:	047f3034 	movhi	r17,64704
8112cfb4:	1021883a 	mov	r16,r2
8112cfb8:	39ffffc4 	addi	r7,r7,-1
8112cfbc:	d9c01315 	stw	r7,76(sp)
8112cfc0:	1c63883a 	add	r17,r3,r17
8112cfc4:	db000c17 	ldw	r12,48(sp)
8112cfc8:	003bea06 	br	8112bf74 <__reset+0xfb10bf74>
8112cfcc:	dc000915 	stw	r16,36(sp)
8112cfd0:	003e0e06 	br	8112c80c <__reset+0xfb10c80c>
8112cfd4:	01000e44 	movi	r4,57
8112cfd8:	8825883a 	mov	r18,r17
8112cfdc:	9dc00044 	addi	r23,r19,1
8112cfe0:	99000005 	stb	r4,0(r19)
8112cfe4:	a023883a 	mov	r17,r20
8112cfe8:	dc000915 	stw	r16,36(sp)
8112cfec:	003da406 	br	8112c680 <__reset+0xfb10c680>
8112cff0:	d9801417 	ldw	r6,80(sp)
8112cff4:	d9c01517 	ldw	r7,84(sp)
8112cff8:	0009883a 	mov	r4,zero
8112cffc:	014ff834 	movhi	r5,16352
8112d000:	11227500 	call	81122750 <__subdf3>
8112d004:	880d883a 	mov	r6,r17
8112d008:	a00f883a 	mov	r7,r20
8112d00c:	1009883a 	mov	r4,r2
8112d010:	180b883a 	mov	r5,r3
8112d014:	1121f540 	call	81121f54 <__gedf2>
8112d018:	00bc7c0e 	bge	zero,r2,8112c20c <__reset+0xfb10c20c>
8112d01c:	01000c04 	movi	r4,48
8112d020:	00000106 	br	8112d028 <_dtoa_r+0x1588>
8112d024:	102f883a 	mov	r23,r2
8112d028:	b8bfffc4 	addi	r2,r23,-1
8112d02c:	10c00007 	ldb	r3,0(r2)
8112d030:	193ffc26 	beq	r3,r4,8112d024 <__reset+0xfb10d024>
8112d034:	d9801317 	ldw	r6,76(sp)
8112d038:	d9800515 	stw	r6,20(sp)
8112d03c:	003c4406 	br	8112c150 <__reset+0xfb10c150>
8112d040:	d9801317 	ldw	r6,76(sp)
8112d044:	d9800515 	stw	r6,20(sp)
8112d048:	003cea06 	br	8112c3f4 <__reset+0xfb10c3f4>
8112d04c:	dd800f17 	ldw	r22,60(sp)
8112d050:	dcc01017 	ldw	r19,64(sp)
8112d054:	dc801217 	ldw	r18,72(sp)
8112d058:	003c6c06 	br	8112c20c <__reset+0xfb10c20c>
8112d05c:	903e031e 	bne	r18,zero,8112c86c <__reset+0xfb10c86c>
8112d060:	003ebb06 	br	8112cb50 <__reset+0xfb10cb50>
8112d064:	103e6c1e 	bne	r2,zero,8112ca18 <__reset+0xfb10ca18>
8112d068:	4080004c 	andi	r2,r8,1
8112d06c:	103e6a26 	beq	r2,zero,8112ca18 <__reset+0xfb10ca18>
8112d070:	003e6606 	br	8112ca0c <__reset+0xfb10ca0c>
8112d074:	d8c00317 	ldw	r3,12(sp)
8112d078:	00800084 	movi	r2,2
8112d07c:	10c02916 	blt	r2,r3,8112d124 <_dtoa_r+0x1684>
8112d080:	d9000c17 	ldw	r4,48(sp)
8112d084:	003e8806 	br	8112caa8 <__reset+0xfb10caa8>
8112d088:	04000084 	movi	r16,2
8112d08c:	003b9d06 	br	8112bf04 <__reset+0xfb10bf04>
8112d090:	d9001317 	ldw	r4,76(sp)
8112d094:	d9000515 	stw	r4,20(sp)
8112d098:	003cd606 	br	8112c3f4 <__reset+0xfb10c3f4>
8112d09c:	d8801317 	ldw	r2,76(sp)
8112d0a0:	d8800515 	stw	r2,20(sp)
8112d0a4:	003c2a06 	br	8112c150 <__reset+0xfb10c150>
8112d0a8:	d9800317 	ldw	r6,12(sp)
8112d0ac:	00800084 	movi	r2,2
8112d0b0:	11801516 	blt	r2,r6,8112d108 <_dtoa_r+0x1668>
8112d0b4:	d9c00c17 	ldw	r7,48(sp)
8112d0b8:	d9c00615 	stw	r7,24(sp)
8112d0bc:	003df706 	br	8112c89c <__reset+0xfb10c89c>
8112d0c0:	193d3926 	beq	r3,r4,8112c5a8 <__reset+0xfb10c5a8>
8112d0c4:	00c00f04 	movi	r3,60
8112d0c8:	1885c83a 	sub	r2,r3,r2
8112d0cc:	003ddf06 	br	8112c84c <__reset+0xfb10c84c>
8112d0d0:	e009883a 	mov	r4,fp
8112d0d4:	e0001115 	stw	zero,68(fp)
8112d0d8:	000b883a 	mov	r5,zero
8112d0dc:	112ebb80 	call	8112ebb8 <_Balloc>
8112d0e0:	d8800715 	stw	r2,28(sp)
8112d0e4:	d8c00717 	ldw	r3,28(sp)
8112d0e8:	00bfffc4 	movi	r2,-1
8112d0ec:	01000044 	movi	r4,1
8112d0f0:	d8800c15 	stw	r2,48(sp)
8112d0f4:	e0c01015 	stw	r3,64(fp)
8112d0f8:	d9000b15 	stw	r4,44(sp)
8112d0fc:	d8800615 	stw	r2,24(sp)
8112d100:	d8002215 	stw	zero,136(sp)
8112d104:	003c4106 	br	8112c20c <__reset+0xfb10c20c>
8112d108:	d8c00c17 	ldw	r3,48(sp)
8112d10c:	d8c00615 	stw	r3,24(sp)
8112d110:	003e7006 	br	8112cad4 <__reset+0xfb10cad4>
8112d114:	04400044 	movi	r17,1
8112d118:	003b2006 	br	8112bd9c <__reset+0xfb10bd9c>
8112d11c:	000b883a 	mov	r5,zero
8112d120:	003b3d06 	br	8112be18 <__reset+0xfb10be18>
8112d124:	d8800c17 	ldw	r2,48(sp)
8112d128:	d8800615 	stw	r2,24(sp)
8112d12c:	003e6906 	br	8112cad4 <__reset+0xfb10cad4>

8112d130 <__sflush_r>:
8112d130:	defffb04 	addi	sp,sp,-20
8112d134:	de00012e 	bgeu	sp,et,8112d13c <__sflush_r+0xc>
8112d138:	003b68fa 	trap	3
8112d13c:	2880030b 	ldhu	r2,12(r5)
8112d140:	dcc00315 	stw	r19,12(sp)
8112d144:	dc400115 	stw	r17,4(sp)
8112d148:	dfc00415 	stw	ra,16(sp)
8112d14c:	dc800215 	stw	r18,8(sp)
8112d150:	dc000015 	stw	r16,0(sp)
8112d154:	10c0020c 	andi	r3,r2,8
8112d158:	2823883a 	mov	r17,r5
8112d15c:	2027883a 	mov	r19,r4
8112d160:	1800311e 	bne	r3,zero,8112d228 <__sflush_r+0xf8>
8112d164:	28c00117 	ldw	r3,4(r5)
8112d168:	10820014 	ori	r2,r2,2048
8112d16c:	2880030d 	sth	r2,12(r5)
8112d170:	00c04b0e 	bge	zero,r3,8112d2a0 <__sflush_r+0x170>
8112d174:	8a000a17 	ldw	r8,40(r17)
8112d178:	40002326 	beq	r8,zero,8112d208 <__sflush_r+0xd8>
8112d17c:	9c000017 	ldw	r16,0(r19)
8112d180:	10c4000c 	andi	r3,r2,4096
8112d184:	98000015 	stw	zero,0(r19)
8112d188:	18004826 	beq	r3,zero,8112d2ac <__sflush_r+0x17c>
8112d18c:	89801417 	ldw	r6,80(r17)
8112d190:	10c0010c 	andi	r3,r2,4
8112d194:	18000626 	beq	r3,zero,8112d1b0 <__sflush_r+0x80>
8112d198:	88c00117 	ldw	r3,4(r17)
8112d19c:	88800c17 	ldw	r2,48(r17)
8112d1a0:	30cdc83a 	sub	r6,r6,r3
8112d1a4:	10000226 	beq	r2,zero,8112d1b0 <__sflush_r+0x80>
8112d1a8:	88800f17 	ldw	r2,60(r17)
8112d1ac:	308dc83a 	sub	r6,r6,r2
8112d1b0:	89400717 	ldw	r5,28(r17)
8112d1b4:	000f883a 	mov	r7,zero
8112d1b8:	9809883a 	mov	r4,r19
8112d1bc:	403ee83a 	callr	r8
8112d1c0:	00ffffc4 	movi	r3,-1
8112d1c4:	10c04426 	beq	r2,r3,8112d2d8 <__sflush_r+0x1a8>
8112d1c8:	88c0030b 	ldhu	r3,12(r17)
8112d1cc:	89000417 	ldw	r4,16(r17)
8112d1d0:	88000115 	stw	zero,4(r17)
8112d1d4:	197dffcc 	andi	r5,r3,63487
8112d1d8:	8940030d 	sth	r5,12(r17)
8112d1dc:	89000015 	stw	r4,0(r17)
8112d1e0:	18c4000c 	andi	r3,r3,4096
8112d1e4:	18002c1e 	bne	r3,zero,8112d298 <__sflush_r+0x168>
8112d1e8:	89400c17 	ldw	r5,48(r17)
8112d1ec:	9c000015 	stw	r16,0(r19)
8112d1f0:	28000526 	beq	r5,zero,8112d208 <__sflush_r+0xd8>
8112d1f4:	88801004 	addi	r2,r17,64
8112d1f8:	28800226 	beq	r5,r2,8112d204 <__sflush_r+0xd4>
8112d1fc:	9809883a 	mov	r4,r19
8112d200:	112dbe80 	call	8112dbe8 <_free_r>
8112d204:	88000c15 	stw	zero,48(r17)
8112d208:	0005883a 	mov	r2,zero
8112d20c:	dfc00417 	ldw	ra,16(sp)
8112d210:	dcc00317 	ldw	r19,12(sp)
8112d214:	dc800217 	ldw	r18,8(sp)
8112d218:	dc400117 	ldw	r17,4(sp)
8112d21c:	dc000017 	ldw	r16,0(sp)
8112d220:	dec00504 	addi	sp,sp,20
8112d224:	f800283a 	ret
8112d228:	2c800417 	ldw	r18,16(r5)
8112d22c:	903ff626 	beq	r18,zero,8112d208 <__reset+0xfb10d208>
8112d230:	2c000017 	ldw	r16,0(r5)
8112d234:	108000cc 	andi	r2,r2,3
8112d238:	2c800015 	stw	r18,0(r5)
8112d23c:	84a1c83a 	sub	r16,r16,r18
8112d240:	1000131e 	bne	r2,zero,8112d290 <__sflush_r+0x160>
8112d244:	28800517 	ldw	r2,20(r5)
8112d248:	88800215 	stw	r2,8(r17)
8112d24c:	04000316 	blt	zero,r16,8112d25c <__sflush_r+0x12c>
8112d250:	003fed06 	br	8112d208 <__reset+0xfb10d208>
8112d254:	90a5883a 	add	r18,r18,r2
8112d258:	043feb0e 	bge	zero,r16,8112d208 <__reset+0xfb10d208>
8112d25c:	88800917 	ldw	r2,36(r17)
8112d260:	89400717 	ldw	r5,28(r17)
8112d264:	800f883a 	mov	r7,r16
8112d268:	900d883a 	mov	r6,r18
8112d26c:	9809883a 	mov	r4,r19
8112d270:	103ee83a 	callr	r2
8112d274:	80a1c83a 	sub	r16,r16,r2
8112d278:	00bff616 	blt	zero,r2,8112d254 <__reset+0xfb10d254>
8112d27c:	88c0030b 	ldhu	r3,12(r17)
8112d280:	00bfffc4 	movi	r2,-1
8112d284:	18c01014 	ori	r3,r3,64
8112d288:	88c0030d 	sth	r3,12(r17)
8112d28c:	003fdf06 	br	8112d20c <__reset+0xfb10d20c>
8112d290:	0005883a 	mov	r2,zero
8112d294:	003fec06 	br	8112d248 <__reset+0xfb10d248>
8112d298:	88801415 	stw	r2,80(r17)
8112d29c:	003fd206 	br	8112d1e8 <__reset+0xfb10d1e8>
8112d2a0:	28c00f17 	ldw	r3,60(r5)
8112d2a4:	00ffb316 	blt	zero,r3,8112d174 <__reset+0xfb10d174>
8112d2a8:	003fd706 	br	8112d208 <__reset+0xfb10d208>
8112d2ac:	89400717 	ldw	r5,28(r17)
8112d2b0:	000d883a 	mov	r6,zero
8112d2b4:	01c00044 	movi	r7,1
8112d2b8:	9809883a 	mov	r4,r19
8112d2bc:	403ee83a 	callr	r8
8112d2c0:	100d883a 	mov	r6,r2
8112d2c4:	00bfffc4 	movi	r2,-1
8112d2c8:	30801426 	beq	r6,r2,8112d31c <__sflush_r+0x1ec>
8112d2cc:	8880030b 	ldhu	r2,12(r17)
8112d2d0:	8a000a17 	ldw	r8,40(r17)
8112d2d4:	003fae06 	br	8112d190 <__reset+0xfb10d190>
8112d2d8:	98c00017 	ldw	r3,0(r19)
8112d2dc:	183fba26 	beq	r3,zero,8112d1c8 <__reset+0xfb10d1c8>
8112d2e0:	01000744 	movi	r4,29
8112d2e4:	19000626 	beq	r3,r4,8112d300 <__sflush_r+0x1d0>
8112d2e8:	01000584 	movi	r4,22
8112d2ec:	19000426 	beq	r3,r4,8112d300 <__sflush_r+0x1d0>
8112d2f0:	88c0030b 	ldhu	r3,12(r17)
8112d2f4:	18c01014 	ori	r3,r3,64
8112d2f8:	88c0030d 	sth	r3,12(r17)
8112d2fc:	003fc306 	br	8112d20c <__reset+0xfb10d20c>
8112d300:	8880030b 	ldhu	r2,12(r17)
8112d304:	88c00417 	ldw	r3,16(r17)
8112d308:	88000115 	stw	zero,4(r17)
8112d30c:	10bdffcc 	andi	r2,r2,63487
8112d310:	8880030d 	sth	r2,12(r17)
8112d314:	88c00015 	stw	r3,0(r17)
8112d318:	003fb306 	br	8112d1e8 <__reset+0xfb10d1e8>
8112d31c:	98800017 	ldw	r2,0(r19)
8112d320:	103fea26 	beq	r2,zero,8112d2cc <__reset+0xfb10d2cc>
8112d324:	00c00744 	movi	r3,29
8112d328:	10c00226 	beq	r2,r3,8112d334 <__sflush_r+0x204>
8112d32c:	00c00584 	movi	r3,22
8112d330:	10c0031e 	bne	r2,r3,8112d340 <__sflush_r+0x210>
8112d334:	9c000015 	stw	r16,0(r19)
8112d338:	0005883a 	mov	r2,zero
8112d33c:	003fb306 	br	8112d20c <__reset+0xfb10d20c>
8112d340:	88c0030b 	ldhu	r3,12(r17)
8112d344:	3005883a 	mov	r2,r6
8112d348:	18c01014 	ori	r3,r3,64
8112d34c:	88c0030d 	sth	r3,12(r17)
8112d350:	003fae06 	br	8112d20c <__reset+0xfb10d20c>

8112d354 <_fflush_r>:
8112d354:	defffd04 	addi	sp,sp,-12
8112d358:	de00012e 	bgeu	sp,et,8112d360 <_fflush_r+0xc>
8112d35c:	003b68fa 	trap	3
8112d360:	dc000115 	stw	r16,4(sp)
8112d364:	dfc00215 	stw	ra,8(sp)
8112d368:	2021883a 	mov	r16,r4
8112d36c:	20000226 	beq	r4,zero,8112d378 <_fflush_r+0x24>
8112d370:	20800e17 	ldw	r2,56(r4)
8112d374:	10000c26 	beq	r2,zero,8112d3a8 <_fflush_r+0x54>
8112d378:	2880030f 	ldh	r2,12(r5)
8112d37c:	1000051e 	bne	r2,zero,8112d394 <_fflush_r+0x40>
8112d380:	0005883a 	mov	r2,zero
8112d384:	dfc00217 	ldw	ra,8(sp)
8112d388:	dc000117 	ldw	r16,4(sp)
8112d38c:	dec00304 	addi	sp,sp,12
8112d390:	f800283a 	ret
8112d394:	8009883a 	mov	r4,r16
8112d398:	dfc00217 	ldw	ra,8(sp)
8112d39c:	dc000117 	ldw	r16,4(sp)
8112d3a0:	dec00304 	addi	sp,sp,12
8112d3a4:	112d1301 	jmpi	8112d130 <__sflush_r>
8112d3a8:	d9400015 	stw	r5,0(sp)
8112d3ac:	112d7500 	call	8112d750 <__sinit>
8112d3b0:	d9400017 	ldw	r5,0(sp)
8112d3b4:	003ff006 	br	8112d378 <__reset+0xfb10d378>

8112d3b8 <fflush>:
8112d3b8:	20000526 	beq	r4,zero,8112d3d0 <fflush+0x18>
8112d3bc:	00a04574 	movhi	r2,33045
8112d3c0:	10945c04 	addi	r2,r2,20848
8112d3c4:	200b883a 	mov	r5,r4
8112d3c8:	11000017 	ldw	r4,0(r2)
8112d3cc:	112d3541 	jmpi	8112d354 <_fflush_r>
8112d3d0:	00a04574 	movhi	r2,33045
8112d3d4:	10945b04 	addi	r2,r2,20844
8112d3d8:	11000017 	ldw	r4,0(r2)
8112d3dc:	016044f4 	movhi	r5,33043
8112d3e0:	2974d504 	addi	r5,r5,-11436
8112d3e4:	112e4901 	jmpi	8112e490 <_fwalk_reent>

8112d3e8 <__fp_unlock>:
8112d3e8:	0005883a 	mov	r2,zero
8112d3ec:	f800283a 	ret

8112d3f0 <_cleanup_r>:
8112d3f0:	016044f4 	movhi	r5,33043
8112d3f4:	2953b104 	addi	r5,r5,20164
8112d3f8:	112e4901 	jmpi	8112e490 <_fwalk_reent>

8112d3fc <__sinit.part.1>:
8112d3fc:	defff704 	addi	sp,sp,-36
8112d400:	00e044f4 	movhi	r3,33043
8112d404:	de00012e 	bgeu	sp,et,8112d40c <__sinit.part.1+0x10>
8112d408:	003b68fa 	trap	3
8112d40c:	18f4fc04 	addi	r3,r3,-11280
8112d410:	dfc00815 	stw	ra,32(sp)
8112d414:	ddc00715 	stw	r23,28(sp)
8112d418:	dd800615 	stw	r22,24(sp)
8112d41c:	dd400515 	stw	r21,20(sp)
8112d420:	dd000415 	stw	r20,16(sp)
8112d424:	dcc00315 	stw	r19,12(sp)
8112d428:	dc800215 	stw	r18,8(sp)
8112d42c:	dc400115 	stw	r17,4(sp)
8112d430:	dc000015 	stw	r16,0(sp)
8112d434:	24000117 	ldw	r16,4(r4)
8112d438:	20c00f15 	stw	r3,60(r4)
8112d43c:	2080bb04 	addi	r2,r4,748
8112d440:	00c000c4 	movi	r3,3
8112d444:	20c0b915 	stw	r3,740(r4)
8112d448:	2080ba15 	stw	r2,744(r4)
8112d44c:	2000b815 	stw	zero,736(r4)
8112d450:	05c00204 	movi	r23,8
8112d454:	00800104 	movi	r2,4
8112d458:	2025883a 	mov	r18,r4
8112d45c:	b80d883a 	mov	r6,r23
8112d460:	81001704 	addi	r4,r16,92
8112d464:	000b883a 	mov	r5,zero
8112d468:	80000015 	stw	zero,0(r16)
8112d46c:	80000115 	stw	zero,4(r16)
8112d470:	80000215 	stw	zero,8(r16)
8112d474:	8080030d 	sth	r2,12(r16)
8112d478:	80001915 	stw	zero,100(r16)
8112d47c:	8000038d 	sth	zero,14(r16)
8112d480:	80000415 	stw	zero,16(r16)
8112d484:	80000515 	stw	zero,20(r16)
8112d488:	80000615 	stw	zero,24(r16)
8112d48c:	11248500 	call	81124850 <memset>
8112d490:	05a044b4 	movhi	r22,33042
8112d494:	94400217 	ldw	r17,8(r18)
8112d498:	056044b4 	movhi	r21,33042
8112d49c:	052044b4 	movhi	r20,33042
8112d4a0:	04e044b4 	movhi	r19,33042
8112d4a4:	b593f604 	addi	r22,r22,20440
8112d4a8:	ad540f04 	addi	r21,r21,20540
8112d4ac:	a5143004 	addi	r20,r20,20672
8112d4b0:	9cd44904 	addi	r19,r19,20772
8112d4b4:	85800815 	stw	r22,32(r16)
8112d4b8:	85400915 	stw	r21,36(r16)
8112d4bc:	85000a15 	stw	r20,40(r16)
8112d4c0:	84c00b15 	stw	r19,44(r16)
8112d4c4:	84000715 	stw	r16,28(r16)
8112d4c8:	00800284 	movi	r2,10
8112d4cc:	8880030d 	sth	r2,12(r17)
8112d4d0:	00800044 	movi	r2,1
8112d4d4:	b80d883a 	mov	r6,r23
8112d4d8:	89001704 	addi	r4,r17,92
8112d4dc:	000b883a 	mov	r5,zero
8112d4e0:	88000015 	stw	zero,0(r17)
8112d4e4:	88000115 	stw	zero,4(r17)
8112d4e8:	88000215 	stw	zero,8(r17)
8112d4ec:	88001915 	stw	zero,100(r17)
8112d4f0:	8880038d 	sth	r2,14(r17)
8112d4f4:	88000415 	stw	zero,16(r17)
8112d4f8:	88000515 	stw	zero,20(r17)
8112d4fc:	88000615 	stw	zero,24(r17)
8112d500:	11248500 	call	81124850 <memset>
8112d504:	94000317 	ldw	r16,12(r18)
8112d508:	00800484 	movi	r2,18
8112d50c:	8c400715 	stw	r17,28(r17)
8112d510:	8d800815 	stw	r22,32(r17)
8112d514:	8d400915 	stw	r21,36(r17)
8112d518:	8d000a15 	stw	r20,40(r17)
8112d51c:	8cc00b15 	stw	r19,44(r17)
8112d520:	8080030d 	sth	r2,12(r16)
8112d524:	00800084 	movi	r2,2
8112d528:	80000015 	stw	zero,0(r16)
8112d52c:	80000115 	stw	zero,4(r16)
8112d530:	80000215 	stw	zero,8(r16)
8112d534:	80001915 	stw	zero,100(r16)
8112d538:	8080038d 	sth	r2,14(r16)
8112d53c:	80000415 	stw	zero,16(r16)
8112d540:	80000515 	stw	zero,20(r16)
8112d544:	80000615 	stw	zero,24(r16)
8112d548:	b80d883a 	mov	r6,r23
8112d54c:	000b883a 	mov	r5,zero
8112d550:	81001704 	addi	r4,r16,92
8112d554:	11248500 	call	81124850 <memset>
8112d558:	00800044 	movi	r2,1
8112d55c:	84000715 	stw	r16,28(r16)
8112d560:	85800815 	stw	r22,32(r16)
8112d564:	85400915 	stw	r21,36(r16)
8112d568:	85000a15 	stw	r20,40(r16)
8112d56c:	84c00b15 	stw	r19,44(r16)
8112d570:	90800e15 	stw	r2,56(r18)
8112d574:	dfc00817 	ldw	ra,32(sp)
8112d578:	ddc00717 	ldw	r23,28(sp)
8112d57c:	dd800617 	ldw	r22,24(sp)
8112d580:	dd400517 	ldw	r21,20(sp)
8112d584:	dd000417 	ldw	r20,16(sp)
8112d588:	dcc00317 	ldw	r19,12(sp)
8112d58c:	dc800217 	ldw	r18,8(sp)
8112d590:	dc400117 	ldw	r17,4(sp)
8112d594:	dc000017 	ldw	r16,0(sp)
8112d598:	dec00904 	addi	sp,sp,36
8112d59c:	f800283a 	ret

8112d5a0 <__fp_lock>:
8112d5a0:	0005883a 	mov	r2,zero
8112d5a4:	f800283a 	ret

8112d5a8 <__sfmoreglue>:
8112d5a8:	defffc04 	addi	sp,sp,-16
8112d5ac:	de00012e 	bgeu	sp,et,8112d5b4 <__sfmoreglue+0xc>
8112d5b0:	003b68fa 	trap	3
8112d5b4:	dc400115 	stw	r17,4(sp)
8112d5b8:	2c7fffc4 	addi	r17,r5,-1
8112d5bc:	8c401a24 	muli	r17,r17,104
8112d5c0:	dc800215 	stw	r18,8(sp)
8112d5c4:	2825883a 	mov	r18,r5
8112d5c8:	89401d04 	addi	r5,r17,116
8112d5cc:	dc000015 	stw	r16,0(sp)
8112d5d0:	dfc00315 	stw	ra,12(sp)
8112d5d4:	1123eec0 	call	81123eec <_malloc_r>
8112d5d8:	1021883a 	mov	r16,r2
8112d5dc:	10000726 	beq	r2,zero,8112d5fc <__sfmoreglue+0x54>
8112d5e0:	11000304 	addi	r4,r2,12
8112d5e4:	10000015 	stw	zero,0(r2)
8112d5e8:	14800115 	stw	r18,4(r2)
8112d5ec:	11000215 	stw	r4,8(r2)
8112d5f0:	89801a04 	addi	r6,r17,104
8112d5f4:	000b883a 	mov	r5,zero
8112d5f8:	11248500 	call	81124850 <memset>
8112d5fc:	8005883a 	mov	r2,r16
8112d600:	dfc00317 	ldw	ra,12(sp)
8112d604:	dc800217 	ldw	r18,8(sp)
8112d608:	dc400117 	ldw	r17,4(sp)
8112d60c:	dc000017 	ldw	r16,0(sp)
8112d610:	dec00404 	addi	sp,sp,16
8112d614:	f800283a 	ret

8112d618 <__sfp>:
8112d618:	defffb04 	addi	sp,sp,-20
8112d61c:	de00012e 	bgeu	sp,et,8112d624 <__sfp+0xc>
8112d620:	003b68fa 	trap	3
8112d624:	dc000015 	stw	r16,0(sp)
8112d628:	04204574 	movhi	r16,33045
8112d62c:	84145b04 	addi	r16,r16,20844
8112d630:	dcc00315 	stw	r19,12(sp)
8112d634:	2027883a 	mov	r19,r4
8112d638:	81000017 	ldw	r4,0(r16)
8112d63c:	dfc00415 	stw	ra,16(sp)
8112d640:	dc800215 	stw	r18,8(sp)
8112d644:	20800e17 	ldw	r2,56(r4)
8112d648:	dc400115 	stw	r17,4(sp)
8112d64c:	1000021e 	bne	r2,zero,8112d658 <__sfp+0x40>
8112d650:	112d3fc0 	call	8112d3fc <__sinit.part.1>
8112d654:	81000017 	ldw	r4,0(r16)
8112d658:	2480b804 	addi	r18,r4,736
8112d65c:	047fffc4 	movi	r17,-1
8112d660:	91000117 	ldw	r4,4(r18)
8112d664:	94000217 	ldw	r16,8(r18)
8112d668:	213fffc4 	addi	r4,r4,-1
8112d66c:	20000a16 	blt	r4,zero,8112d698 <__sfp+0x80>
8112d670:	8080030f 	ldh	r2,12(r16)
8112d674:	10000c26 	beq	r2,zero,8112d6a8 <__sfp+0x90>
8112d678:	80c01d04 	addi	r3,r16,116
8112d67c:	00000206 	br	8112d688 <__sfp+0x70>
8112d680:	18bfe60f 	ldh	r2,-104(r3)
8112d684:	10000826 	beq	r2,zero,8112d6a8 <__sfp+0x90>
8112d688:	213fffc4 	addi	r4,r4,-1
8112d68c:	1c3ffd04 	addi	r16,r3,-12
8112d690:	18c01a04 	addi	r3,r3,104
8112d694:	247ffa1e 	bne	r4,r17,8112d680 <__reset+0xfb10d680>
8112d698:	90800017 	ldw	r2,0(r18)
8112d69c:	10001d26 	beq	r2,zero,8112d714 <__sfp+0xfc>
8112d6a0:	1025883a 	mov	r18,r2
8112d6a4:	003fee06 	br	8112d660 <__reset+0xfb10d660>
8112d6a8:	00bfffc4 	movi	r2,-1
8112d6ac:	8080038d 	sth	r2,14(r16)
8112d6b0:	00800044 	movi	r2,1
8112d6b4:	8080030d 	sth	r2,12(r16)
8112d6b8:	80001915 	stw	zero,100(r16)
8112d6bc:	80000015 	stw	zero,0(r16)
8112d6c0:	80000215 	stw	zero,8(r16)
8112d6c4:	80000115 	stw	zero,4(r16)
8112d6c8:	80000415 	stw	zero,16(r16)
8112d6cc:	80000515 	stw	zero,20(r16)
8112d6d0:	80000615 	stw	zero,24(r16)
8112d6d4:	01800204 	movi	r6,8
8112d6d8:	000b883a 	mov	r5,zero
8112d6dc:	81001704 	addi	r4,r16,92
8112d6e0:	11248500 	call	81124850 <memset>
8112d6e4:	8005883a 	mov	r2,r16
8112d6e8:	80000c15 	stw	zero,48(r16)
8112d6ec:	80000d15 	stw	zero,52(r16)
8112d6f0:	80001115 	stw	zero,68(r16)
8112d6f4:	80001215 	stw	zero,72(r16)
8112d6f8:	dfc00417 	ldw	ra,16(sp)
8112d6fc:	dcc00317 	ldw	r19,12(sp)
8112d700:	dc800217 	ldw	r18,8(sp)
8112d704:	dc400117 	ldw	r17,4(sp)
8112d708:	dc000017 	ldw	r16,0(sp)
8112d70c:	dec00504 	addi	sp,sp,20
8112d710:	f800283a 	ret
8112d714:	01400104 	movi	r5,4
8112d718:	9809883a 	mov	r4,r19
8112d71c:	112d5a80 	call	8112d5a8 <__sfmoreglue>
8112d720:	90800015 	stw	r2,0(r18)
8112d724:	103fde1e 	bne	r2,zero,8112d6a0 <__reset+0xfb10d6a0>
8112d728:	00800304 	movi	r2,12
8112d72c:	98800015 	stw	r2,0(r19)
8112d730:	0005883a 	mov	r2,zero
8112d734:	003ff006 	br	8112d6f8 <__reset+0xfb10d6f8>

8112d738 <_cleanup>:
8112d738:	00a04574 	movhi	r2,33045
8112d73c:	10945b04 	addi	r2,r2,20844
8112d740:	11000017 	ldw	r4,0(r2)
8112d744:	016044f4 	movhi	r5,33043
8112d748:	2953b104 	addi	r5,r5,20164
8112d74c:	112e4901 	jmpi	8112e490 <_fwalk_reent>

8112d750 <__sinit>:
8112d750:	20800e17 	ldw	r2,56(r4)
8112d754:	10000126 	beq	r2,zero,8112d75c <__sinit+0xc>
8112d758:	f800283a 	ret
8112d75c:	112d3fc1 	jmpi	8112d3fc <__sinit.part.1>

8112d760 <__sfp_lock_acquire>:
8112d760:	f800283a 	ret

8112d764 <__sfp_lock_release>:
8112d764:	f800283a 	ret

8112d768 <__sinit_lock_acquire>:
8112d768:	f800283a 	ret

8112d76c <__sinit_lock_release>:
8112d76c:	f800283a 	ret

8112d770 <__fp_lock_all>:
8112d770:	00a04574 	movhi	r2,33045
8112d774:	10945c04 	addi	r2,r2,20848
8112d778:	11000017 	ldw	r4,0(r2)
8112d77c:	016044f4 	movhi	r5,33043
8112d780:	29756804 	addi	r5,r5,-10848
8112d784:	112e3c41 	jmpi	8112e3c4 <_fwalk>

8112d788 <__fp_unlock_all>:
8112d788:	00a04574 	movhi	r2,33045
8112d78c:	10945c04 	addi	r2,r2,20848
8112d790:	11000017 	ldw	r4,0(r2)
8112d794:	016044f4 	movhi	r5,33043
8112d798:	2974fa04 	addi	r5,r5,-11288
8112d79c:	112e3c41 	jmpi	8112e3c4 <_fwalk>

8112d7a0 <__sflags>:
8112d7a0:	28800007 	ldb	r2,0(r5)
8112d7a4:	00c01c84 	movi	r3,114
8112d7a8:	10c02426 	beq	r2,r3,8112d83c <__sflags+0x9c>
8112d7ac:	00c01dc4 	movi	r3,119
8112d7b0:	10c01e26 	beq	r2,r3,8112d82c <__sflags+0x8c>
8112d7b4:	00c01844 	movi	r3,97
8112d7b8:	10c00426 	beq	r2,r3,8112d7cc <__sflags+0x2c>
8112d7bc:	00800584 	movi	r2,22
8112d7c0:	20800015 	stw	r2,0(r4)
8112d7c4:	0005883a 	mov	r2,zero
8112d7c8:	f800283a 	ret
8112d7cc:	02c08204 	movi	r11,520
8112d7d0:	01000044 	movi	r4,1
8112d7d4:	00804204 	movi	r2,264
8112d7d8:	01c00ac4 	movi	r7,43
8112d7dc:	02bff8c4 	movi	r10,-29
8112d7e0:	027fff04 	movi	r9,-4
8112d7e4:	02001e04 	movi	r8,120
8112d7e8:	29400044 	addi	r5,r5,1
8112d7ec:	28c00007 	ldb	r3,0(r5)
8112d7f0:	18000626 	beq	r3,zero,8112d80c <__sflags+0x6c>
8112d7f4:	19c00826 	beq	r3,r7,8112d818 <__sflags+0x78>
8112d7f8:	1a3ffb1e 	bne	r3,r8,8112d7e8 <__reset+0xfb10d7e8>
8112d7fc:	29400044 	addi	r5,r5,1
8112d800:	28c00007 	ldb	r3,0(r5)
8112d804:	21020014 	ori	r4,r4,2048
8112d808:	183ffa1e 	bne	r3,zero,8112d7f4 <__reset+0xfb10d7f4>
8112d80c:	22c8b03a 	or	r4,r4,r11
8112d810:	31000015 	stw	r4,0(r6)
8112d814:	f800283a 	ret
8112d818:	1284703a 	and	r2,r2,r10
8112d81c:	2248703a 	and	r4,r4,r9
8112d820:	10800414 	ori	r2,r2,16
8112d824:	21000094 	ori	r4,r4,2
8112d828:	003fef06 	br	8112d7e8 <__reset+0xfb10d7e8>
8112d82c:	02c18004 	movi	r11,1536
8112d830:	01000044 	movi	r4,1
8112d834:	00800204 	movi	r2,8
8112d838:	003fe706 	br	8112d7d8 <__reset+0xfb10d7d8>
8112d83c:	0017883a 	mov	r11,zero
8112d840:	0009883a 	mov	r4,zero
8112d844:	00800104 	movi	r2,4
8112d848:	003fe306 	br	8112d7d8 <__reset+0xfb10d7d8>

8112d84c <_fread_r>:
8112d84c:	defff404 	addi	sp,sp,-48
8112d850:	de00012e 	bgeu	sp,et,8112d858 <_fread_r+0xc>
8112d854:	003b68fa 	trap	3
8112d858:	dd800815 	stw	r22,32(sp)
8112d85c:	39ad383a 	mul	r22,r7,r6
8112d860:	dc000215 	stw	r16,8(sp)
8112d864:	dfc00b15 	stw	ra,44(sp)
8112d868:	df000a15 	stw	fp,40(sp)
8112d86c:	ddc00915 	stw	r23,36(sp)
8112d870:	dd400715 	stw	r21,28(sp)
8112d874:	dd000615 	stw	r20,24(sp)
8112d878:	dcc00515 	stw	r19,20(sp)
8112d87c:	dc800415 	stw	r18,16(sp)
8112d880:	dc400315 	stw	r17,12(sp)
8112d884:	dc000c17 	ldw	r16,48(sp)
8112d888:	b0003b26 	beq	r22,zero,8112d978 <_fread_r+0x12c>
8112d88c:	302f883a 	mov	r23,r6
8112d890:	382b883a 	mov	r21,r7
8112d894:	2029883a 	mov	r20,r4
8112d898:	2827883a 	mov	r19,r5
8112d89c:	20000226 	beq	r4,zero,8112d8a8 <_fread_r+0x5c>
8112d8a0:	20800e17 	ldw	r2,56(r4)
8112d8a4:	10006e26 	beq	r2,zero,8112da60 <_fread_r+0x214>
8112d8a8:	8080030b 	ldhu	r2,12(r16)
8112d8ac:	10c8000c 	andi	r3,r2,8192
8112d8b0:	1800061e 	bne	r3,zero,8112d8cc <_fread_r+0x80>
8112d8b4:	81001917 	ldw	r4,100(r16)
8112d8b8:	00f7ffc4 	movi	r3,-8193
8112d8bc:	10880014 	ori	r2,r2,8192
8112d8c0:	20c6703a 	and	r3,r4,r3
8112d8c4:	8080030d 	sth	r2,12(r16)
8112d8c8:	80c01915 	stw	r3,100(r16)
8112d8cc:	84400117 	ldw	r17,4(r16)
8112d8d0:	88005f16 	blt	r17,zero,8112da50 <_fread_r+0x204>
8112d8d4:	8809883a 	mov	r4,r17
8112d8d8:	1080008c 	andi	r2,r2,2
8112d8dc:	1000281e 	bne	r2,zero,8112d980 <_fread_r+0x134>
8112d8e0:	b025883a 	mov	r18,r22
8112d8e4:	00000b06 	br	8112d914 <_fread_r+0xc8>
8112d8e8:	11247000 	call	81124700 <memcpy>
8112d8ec:	80800017 	ldw	r2,0(r16)
8112d8f0:	9c67883a 	add	r19,r19,r17
8112d8f4:	9465c83a 	sub	r18,r18,r17
8112d8f8:	1463883a 	add	r17,r2,r17
8112d8fc:	800b883a 	mov	r5,r16
8112d900:	a009883a 	mov	r4,r20
8112d904:	84400015 	stw	r17,0(r16)
8112d908:	1124c500 	call	81124c50 <__srefill_r>
8112d90c:	10004c1e 	bne	r2,zero,8112da40 <_fread_r+0x1f4>
8112d910:	84400117 	ldw	r17,4(r16)
8112d914:	880d883a 	mov	r6,r17
8112d918:	9809883a 	mov	r4,r19
8112d91c:	81400017 	ldw	r5,0(r16)
8112d920:	8cbff136 	bltu	r17,r18,8112d8e8 <__reset+0xfb10d8e8>
8112d924:	900d883a 	mov	r6,r18
8112d928:	11247000 	call	81124700 <memcpy>
8112d92c:	80c00117 	ldw	r3,4(r16)
8112d930:	81000017 	ldw	r4,0(r16)
8112d934:	a805883a 	mov	r2,r21
8112d938:	1c87c83a 	sub	r3,r3,r18
8112d93c:	24a5883a 	add	r18,r4,r18
8112d940:	80c00115 	stw	r3,4(r16)
8112d944:	84800015 	stw	r18,0(r16)
8112d948:	dfc00b17 	ldw	ra,44(sp)
8112d94c:	df000a17 	ldw	fp,40(sp)
8112d950:	ddc00917 	ldw	r23,36(sp)
8112d954:	dd800817 	ldw	r22,32(sp)
8112d958:	dd400717 	ldw	r21,28(sp)
8112d95c:	dd000617 	ldw	r20,24(sp)
8112d960:	dcc00517 	ldw	r19,20(sp)
8112d964:	dc800417 	ldw	r18,16(sp)
8112d968:	dc400317 	ldw	r17,12(sp)
8112d96c:	dc000217 	ldw	r16,8(sp)
8112d970:	dec00c04 	addi	sp,sp,48
8112d974:	f800283a 	ret
8112d978:	0005883a 	mov	r2,zero
8112d97c:	003ff206 	br	8112d948 <__reset+0xfb10d948>
8112d980:	b007883a 	mov	r3,r22
8112d984:	2580012e 	bgeu	r4,r22,8112d98c <_fread_r+0x140>
8112d988:	2007883a 	mov	r3,r4
8112d98c:	81400017 	ldw	r5,0(r16)
8112d990:	180d883a 	mov	r6,r3
8112d994:	9809883a 	mov	r4,r19
8112d998:	d8c00115 	stw	r3,4(sp)
8112d99c:	11247000 	call	81124700 <memcpy>
8112d9a0:	d8c00117 	ldw	r3,4(sp)
8112d9a4:	84400017 	ldw	r17,0(r16)
8112d9a8:	80800117 	ldw	r2,4(r16)
8112d9ac:	81400c17 	ldw	r5,48(r16)
8112d9b0:	88e3883a 	add	r17,r17,r3
8112d9b4:	10c5c83a 	sub	r2,r2,r3
8112d9b8:	84400015 	stw	r17,0(r16)
8112d9bc:	80800115 	stw	r2,4(r16)
8112d9c0:	b0e5c83a 	sub	r18,r22,r3
8112d9c4:	28002b26 	beq	r5,zero,8112da74 <_fread_r+0x228>
8112d9c8:	90002b26 	beq	r18,zero,8112da78 <_fread_r+0x22c>
8112d9cc:	80801004 	addi	r2,r16,64
8112d9d0:	28800526 	beq	r5,r2,8112d9e8 <_fread_r+0x19c>
8112d9d4:	a009883a 	mov	r4,r20
8112d9d8:	d8c00115 	stw	r3,4(sp)
8112d9dc:	112dbe80 	call	8112dbe8 <_free_r>
8112d9e0:	d8c00117 	ldw	r3,4(sp)
8112d9e4:	84400017 	ldw	r17,0(r16)
8112d9e8:	80000c15 	stw	zero,48(r16)
8112d9ec:	80800517 	ldw	r2,20(r16)
8112d9f0:	87000417 	ldw	fp,16(r16)
8112d9f4:	98e7883a 	add	r19,r19,r3
8112d9f8:	d8800015 	stw	r2,0(sp)
8112d9fc:	00000106 	br	8112da04 <_fread_r+0x1b8>
8112da00:	90001d26 	beq	r18,zero,8112da78 <_fread_r+0x22c>
8112da04:	84c00415 	stw	r19,16(r16)
8112da08:	84800515 	stw	r18,20(r16)
8112da0c:	84c00015 	stw	r19,0(r16)
8112da10:	a009883a 	mov	r4,r20
8112da14:	800b883a 	mov	r5,r16
8112da18:	1124c500 	call	81124c50 <__srefill_r>
8112da1c:	d9000017 	ldw	r4,0(sp)
8112da20:	80c00117 	ldw	r3,4(r16)
8112da24:	87000415 	stw	fp,16(r16)
8112da28:	81000515 	stw	r4,20(r16)
8112da2c:	84400015 	stw	r17,0(r16)
8112da30:	80000115 	stw	zero,4(r16)
8112da34:	90e5c83a 	sub	r18,r18,r3
8112da38:	98e7883a 	add	r19,r19,r3
8112da3c:	103ff026 	beq	r2,zero,8112da00 <__reset+0xfb10da00>
8112da40:	b80b883a 	mov	r5,r23
8112da44:	b489c83a 	sub	r4,r22,r18
8112da48:	1136c0c0 	call	81136c0c <__udivsi3>
8112da4c:	003fbe06 	br	8112d948 <__reset+0xfb10d948>
8112da50:	80000115 	stw	zero,4(r16)
8112da54:	0009883a 	mov	r4,zero
8112da58:	0023883a 	mov	r17,zero
8112da5c:	003f9e06 	br	8112d8d8 <__reset+0xfb10d8d8>
8112da60:	112d7500 	call	8112d750 <__sinit>
8112da64:	8080030b 	ldhu	r2,12(r16)
8112da68:	10c8000c 	andi	r3,r2,8192
8112da6c:	183f971e 	bne	r3,zero,8112d8cc <__reset+0xfb10d8cc>
8112da70:	003f9006 	br	8112d8b4 <__reset+0xfb10d8b4>
8112da74:	903fdd1e 	bne	r18,zero,8112d9ec <__reset+0xfb10d9ec>
8112da78:	a805883a 	mov	r2,r21
8112da7c:	003fb206 	br	8112d948 <__reset+0xfb10d948>

8112da80 <fread>:
8112da80:	defffe04 	addi	sp,sp,-8
8112da84:	00a04574 	movhi	r2,33045
8112da88:	de00012e 	bgeu	sp,et,8112da90 <fread+0x10>
8112da8c:	003b68fa 	trap	3
8112da90:	10945c04 	addi	r2,r2,20848
8112da94:	d9c00015 	stw	r7,0(sp)
8112da98:	300f883a 	mov	r7,r6
8112da9c:	280d883a 	mov	r6,r5
8112daa0:	200b883a 	mov	r5,r4
8112daa4:	11000017 	ldw	r4,0(r2)
8112daa8:	dfc00115 	stw	ra,4(sp)
8112daac:	112d84c0 	call	8112d84c <_fread_r>
8112dab0:	dfc00117 	ldw	ra,4(sp)
8112dab4:	dec00204 	addi	sp,sp,8
8112dab8:	f800283a 	ret

8112dabc <_malloc_trim_r>:
8112dabc:	defffb04 	addi	sp,sp,-20
8112dac0:	de00012e 	bgeu	sp,et,8112dac8 <_malloc_trim_r+0xc>
8112dac4:	003b68fa 	trap	3
8112dac8:	dcc00315 	stw	r19,12(sp)
8112dacc:	04e04574 	movhi	r19,33045
8112dad0:	dc800215 	stw	r18,8(sp)
8112dad4:	dc400115 	stw	r17,4(sp)
8112dad8:	dc000015 	stw	r16,0(sp)
8112dadc:	dfc00415 	stw	ra,16(sp)
8112dae0:	2821883a 	mov	r16,r5
8112dae4:	9cce1a04 	addi	r19,r19,14440
8112dae8:	2025883a 	mov	r18,r4
8112daec:	113a0c80 	call	8113a0c8 <__malloc_lock>
8112daf0:	98800217 	ldw	r2,8(r19)
8112daf4:	14400117 	ldw	r17,4(r2)
8112daf8:	00bfff04 	movi	r2,-4
8112dafc:	88a2703a 	and	r17,r17,r2
8112db00:	8c21c83a 	sub	r16,r17,r16
8112db04:	8403fbc4 	addi	r16,r16,4079
8112db08:	8020d33a 	srli	r16,r16,12
8112db0c:	0083ffc4 	movi	r2,4095
8112db10:	843fffc4 	addi	r16,r16,-1
8112db14:	8020933a 	slli	r16,r16,12
8112db18:	1400060e 	bge	r2,r16,8112db34 <_malloc_trim_r+0x78>
8112db1c:	000b883a 	mov	r5,zero
8112db20:	9009883a 	mov	r4,r18
8112db24:	1124e2c0 	call	81124e2c <_sbrk_r>
8112db28:	98c00217 	ldw	r3,8(r19)
8112db2c:	1c47883a 	add	r3,r3,r17
8112db30:	10c00a26 	beq	r2,r3,8112db5c <_malloc_trim_r+0xa0>
8112db34:	9009883a 	mov	r4,r18
8112db38:	113a1f00 	call	8113a1f0 <__malloc_unlock>
8112db3c:	0005883a 	mov	r2,zero
8112db40:	dfc00417 	ldw	ra,16(sp)
8112db44:	dcc00317 	ldw	r19,12(sp)
8112db48:	dc800217 	ldw	r18,8(sp)
8112db4c:	dc400117 	ldw	r17,4(sp)
8112db50:	dc000017 	ldw	r16,0(sp)
8112db54:	dec00504 	addi	sp,sp,20
8112db58:	f800283a 	ret
8112db5c:	040bc83a 	sub	r5,zero,r16
8112db60:	9009883a 	mov	r4,r18
8112db64:	1124e2c0 	call	81124e2c <_sbrk_r>
8112db68:	00ffffc4 	movi	r3,-1
8112db6c:	10c00d26 	beq	r2,r3,8112dba4 <_malloc_trim_r+0xe8>
8112db70:	00e04574 	movhi	r3,33045
8112db74:	18d55f04 	addi	r3,r3,21884
8112db78:	18800017 	ldw	r2,0(r3)
8112db7c:	99000217 	ldw	r4,8(r19)
8112db80:	8c23c83a 	sub	r17,r17,r16
8112db84:	8c400054 	ori	r17,r17,1
8112db88:	1421c83a 	sub	r16,r2,r16
8112db8c:	24400115 	stw	r17,4(r4)
8112db90:	9009883a 	mov	r4,r18
8112db94:	1c000015 	stw	r16,0(r3)
8112db98:	113a1f00 	call	8113a1f0 <__malloc_unlock>
8112db9c:	00800044 	movi	r2,1
8112dba0:	003fe706 	br	8112db40 <__reset+0xfb10db40>
8112dba4:	000b883a 	mov	r5,zero
8112dba8:	9009883a 	mov	r4,r18
8112dbac:	1124e2c0 	call	81124e2c <_sbrk_r>
8112dbb0:	99000217 	ldw	r4,8(r19)
8112dbb4:	014003c4 	movi	r5,15
8112dbb8:	1107c83a 	sub	r3,r2,r4
8112dbbc:	28ffdd0e 	bge	r5,r3,8112db34 <__reset+0xfb10db34>
8112dbc0:	01604574 	movhi	r5,33045
8112dbc4:	29545d04 	addi	r5,r5,20852
8112dbc8:	29400017 	ldw	r5,0(r5)
8112dbcc:	18c00054 	ori	r3,r3,1
8112dbd0:	20c00115 	stw	r3,4(r4)
8112dbd4:	00e04574 	movhi	r3,33045
8112dbd8:	1145c83a 	sub	r2,r2,r5
8112dbdc:	18d55f04 	addi	r3,r3,21884
8112dbe0:	18800015 	stw	r2,0(r3)
8112dbe4:	003fd306 	br	8112db34 <__reset+0xfb10db34>

8112dbe8 <_free_r>:
8112dbe8:	28004326 	beq	r5,zero,8112dcf8 <_free_r+0x110>
8112dbec:	defffd04 	addi	sp,sp,-12
8112dbf0:	de00012e 	bgeu	sp,et,8112dbf8 <_free_r+0x10>
8112dbf4:	003b68fa 	trap	3
8112dbf8:	dc400115 	stw	r17,4(sp)
8112dbfc:	dc000015 	stw	r16,0(sp)
8112dc00:	2023883a 	mov	r17,r4
8112dc04:	2821883a 	mov	r16,r5
8112dc08:	dfc00215 	stw	ra,8(sp)
8112dc0c:	113a0c80 	call	8113a0c8 <__malloc_lock>
8112dc10:	81ffff17 	ldw	r7,-4(r16)
8112dc14:	00bfff84 	movi	r2,-2
8112dc18:	01204574 	movhi	r4,33045
8112dc1c:	81bffe04 	addi	r6,r16,-8
8112dc20:	3884703a 	and	r2,r7,r2
8112dc24:	210e1a04 	addi	r4,r4,14440
8112dc28:	308b883a 	add	r5,r6,r2
8112dc2c:	2a400117 	ldw	r9,4(r5)
8112dc30:	22000217 	ldw	r8,8(r4)
8112dc34:	00ffff04 	movi	r3,-4
8112dc38:	48c6703a 	and	r3,r9,r3
8112dc3c:	2a005726 	beq	r5,r8,8112dd9c <_free_r+0x1b4>
8112dc40:	28c00115 	stw	r3,4(r5)
8112dc44:	39c0004c 	andi	r7,r7,1
8112dc48:	3800091e 	bne	r7,zero,8112dc70 <_free_r+0x88>
8112dc4c:	823ffe17 	ldw	r8,-8(r16)
8112dc50:	22400204 	addi	r9,r4,8
8112dc54:	320dc83a 	sub	r6,r6,r8
8112dc58:	31c00217 	ldw	r7,8(r6)
8112dc5c:	1205883a 	add	r2,r2,r8
8112dc60:	3a406526 	beq	r7,r9,8112ddf8 <_free_r+0x210>
8112dc64:	32000317 	ldw	r8,12(r6)
8112dc68:	3a000315 	stw	r8,12(r7)
8112dc6c:	41c00215 	stw	r7,8(r8)
8112dc70:	28cf883a 	add	r7,r5,r3
8112dc74:	39c00117 	ldw	r7,4(r7)
8112dc78:	39c0004c 	andi	r7,r7,1
8112dc7c:	38003a26 	beq	r7,zero,8112dd68 <_free_r+0x180>
8112dc80:	10c00054 	ori	r3,r2,1
8112dc84:	30c00115 	stw	r3,4(r6)
8112dc88:	3087883a 	add	r3,r6,r2
8112dc8c:	18800015 	stw	r2,0(r3)
8112dc90:	00c07fc4 	movi	r3,511
8112dc94:	18801936 	bltu	r3,r2,8112dcfc <_free_r+0x114>
8112dc98:	1004d0fa 	srli	r2,r2,3
8112dc9c:	01c00044 	movi	r7,1
8112dca0:	21400117 	ldw	r5,4(r4)
8112dca4:	10c00044 	addi	r3,r2,1
8112dca8:	18c7883a 	add	r3,r3,r3
8112dcac:	1005d0ba 	srai	r2,r2,2
8112dcb0:	18c7883a 	add	r3,r3,r3
8112dcb4:	18c7883a 	add	r3,r3,r3
8112dcb8:	1907883a 	add	r3,r3,r4
8112dcbc:	3884983a 	sll	r2,r7,r2
8112dcc0:	19c00017 	ldw	r7,0(r3)
8112dcc4:	1a3ffe04 	addi	r8,r3,-8
8112dcc8:	1144b03a 	or	r2,r2,r5
8112dccc:	32000315 	stw	r8,12(r6)
8112dcd0:	31c00215 	stw	r7,8(r6)
8112dcd4:	20800115 	stw	r2,4(r4)
8112dcd8:	19800015 	stw	r6,0(r3)
8112dcdc:	39800315 	stw	r6,12(r7)
8112dce0:	8809883a 	mov	r4,r17
8112dce4:	dfc00217 	ldw	ra,8(sp)
8112dce8:	dc400117 	ldw	r17,4(sp)
8112dcec:	dc000017 	ldw	r16,0(sp)
8112dcf0:	dec00304 	addi	sp,sp,12
8112dcf4:	113a1f01 	jmpi	8113a1f0 <__malloc_unlock>
8112dcf8:	f800283a 	ret
8112dcfc:	100ad27a 	srli	r5,r2,9
8112dd00:	00c00104 	movi	r3,4
8112dd04:	19404a36 	bltu	r3,r5,8112de30 <_free_r+0x248>
8112dd08:	100ad1ba 	srli	r5,r2,6
8112dd0c:	28c00e44 	addi	r3,r5,57
8112dd10:	18c7883a 	add	r3,r3,r3
8112dd14:	29400e04 	addi	r5,r5,56
8112dd18:	18c7883a 	add	r3,r3,r3
8112dd1c:	18c7883a 	add	r3,r3,r3
8112dd20:	1909883a 	add	r4,r3,r4
8112dd24:	20c00017 	ldw	r3,0(r4)
8112dd28:	01e04574 	movhi	r7,33045
8112dd2c:	213ffe04 	addi	r4,r4,-8
8112dd30:	39ce1a04 	addi	r7,r7,14440
8112dd34:	20c04426 	beq	r4,r3,8112de48 <_free_r+0x260>
8112dd38:	01ffff04 	movi	r7,-4
8112dd3c:	19400117 	ldw	r5,4(r3)
8112dd40:	29ca703a 	and	r5,r5,r7
8112dd44:	1140022e 	bgeu	r2,r5,8112dd50 <_free_r+0x168>
8112dd48:	18c00217 	ldw	r3,8(r3)
8112dd4c:	20fffb1e 	bne	r4,r3,8112dd3c <__reset+0xfb10dd3c>
8112dd50:	19000317 	ldw	r4,12(r3)
8112dd54:	31000315 	stw	r4,12(r6)
8112dd58:	30c00215 	stw	r3,8(r6)
8112dd5c:	21800215 	stw	r6,8(r4)
8112dd60:	19800315 	stw	r6,12(r3)
8112dd64:	003fde06 	br	8112dce0 <__reset+0xfb10dce0>
8112dd68:	29c00217 	ldw	r7,8(r5)
8112dd6c:	10c5883a 	add	r2,r2,r3
8112dd70:	00e04574 	movhi	r3,33045
8112dd74:	18ce1c04 	addi	r3,r3,14448
8112dd78:	38c03b26 	beq	r7,r3,8112de68 <_free_r+0x280>
8112dd7c:	2a000317 	ldw	r8,12(r5)
8112dd80:	11400054 	ori	r5,r2,1
8112dd84:	3087883a 	add	r3,r6,r2
8112dd88:	3a000315 	stw	r8,12(r7)
8112dd8c:	41c00215 	stw	r7,8(r8)
8112dd90:	31400115 	stw	r5,4(r6)
8112dd94:	18800015 	stw	r2,0(r3)
8112dd98:	003fbd06 	br	8112dc90 <__reset+0xfb10dc90>
8112dd9c:	39c0004c 	andi	r7,r7,1
8112dda0:	10c5883a 	add	r2,r2,r3
8112dda4:	3800071e 	bne	r7,zero,8112ddc4 <_free_r+0x1dc>
8112dda8:	81fffe17 	ldw	r7,-8(r16)
8112ddac:	31cdc83a 	sub	r6,r6,r7
8112ddb0:	30c00317 	ldw	r3,12(r6)
8112ddb4:	31400217 	ldw	r5,8(r6)
8112ddb8:	11c5883a 	add	r2,r2,r7
8112ddbc:	28c00315 	stw	r3,12(r5)
8112ddc0:	19400215 	stw	r5,8(r3)
8112ddc4:	10c00054 	ori	r3,r2,1
8112ddc8:	30c00115 	stw	r3,4(r6)
8112ddcc:	00e04574 	movhi	r3,33045
8112ddd0:	18d45e04 	addi	r3,r3,20856
8112ddd4:	18c00017 	ldw	r3,0(r3)
8112ddd8:	21800215 	stw	r6,8(r4)
8112dddc:	10ffc036 	bltu	r2,r3,8112dce0 <__reset+0xfb10dce0>
8112dde0:	00a04574 	movhi	r2,33045
8112dde4:	1094d204 	addi	r2,r2,21320
8112dde8:	11400017 	ldw	r5,0(r2)
8112ddec:	8809883a 	mov	r4,r17
8112ddf0:	112dabc0 	call	8112dabc <_malloc_trim_r>
8112ddf4:	003fba06 	br	8112dce0 <__reset+0xfb10dce0>
8112ddf8:	28c9883a 	add	r4,r5,r3
8112ddfc:	21000117 	ldw	r4,4(r4)
8112de00:	2100004c 	andi	r4,r4,1
8112de04:	2000391e 	bne	r4,zero,8112deec <_free_r+0x304>
8112de08:	29c00217 	ldw	r7,8(r5)
8112de0c:	29000317 	ldw	r4,12(r5)
8112de10:	1885883a 	add	r2,r3,r2
8112de14:	10c00054 	ori	r3,r2,1
8112de18:	39000315 	stw	r4,12(r7)
8112de1c:	21c00215 	stw	r7,8(r4)
8112de20:	30c00115 	stw	r3,4(r6)
8112de24:	308d883a 	add	r6,r6,r2
8112de28:	30800015 	stw	r2,0(r6)
8112de2c:	003fac06 	br	8112dce0 <__reset+0xfb10dce0>
8112de30:	00c00504 	movi	r3,20
8112de34:	19401536 	bltu	r3,r5,8112de8c <_free_r+0x2a4>
8112de38:	28c01704 	addi	r3,r5,92
8112de3c:	18c7883a 	add	r3,r3,r3
8112de40:	294016c4 	addi	r5,r5,91
8112de44:	003fb406 	br	8112dd18 <__reset+0xfb10dd18>
8112de48:	280bd0ba 	srai	r5,r5,2
8112de4c:	00c00044 	movi	r3,1
8112de50:	38800117 	ldw	r2,4(r7)
8112de54:	194a983a 	sll	r5,r3,r5
8112de58:	2007883a 	mov	r3,r4
8112de5c:	2884b03a 	or	r2,r5,r2
8112de60:	38800115 	stw	r2,4(r7)
8112de64:	003fbb06 	br	8112dd54 <__reset+0xfb10dd54>
8112de68:	21800515 	stw	r6,20(r4)
8112de6c:	21800415 	stw	r6,16(r4)
8112de70:	10c00054 	ori	r3,r2,1
8112de74:	31c00315 	stw	r7,12(r6)
8112de78:	31c00215 	stw	r7,8(r6)
8112de7c:	30c00115 	stw	r3,4(r6)
8112de80:	308d883a 	add	r6,r6,r2
8112de84:	30800015 	stw	r2,0(r6)
8112de88:	003f9506 	br	8112dce0 <__reset+0xfb10dce0>
8112de8c:	00c01504 	movi	r3,84
8112de90:	19400536 	bltu	r3,r5,8112dea8 <_free_r+0x2c0>
8112de94:	100ad33a 	srli	r5,r2,12
8112de98:	28c01bc4 	addi	r3,r5,111
8112de9c:	18c7883a 	add	r3,r3,r3
8112dea0:	29401b84 	addi	r5,r5,110
8112dea4:	003f9c06 	br	8112dd18 <__reset+0xfb10dd18>
8112dea8:	00c05504 	movi	r3,340
8112deac:	19400536 	bltu	r3,r5,8112dec4 <_free_r+0x2dc>
8112deb0:	100ad3fa 	srli	r5,r2,15
8112deb4:	28c01e04 	addi	r3,r5,120
8112deb8:	18c7883a 	add	r3,r3,r3
8112debc:	29401dc4 	addi	r5,r5,119
8112dec0:	003f9506 	br	8112dd18 <__reset+0xfb10dd18>
8112dec4:	00c15504 	movi	r3,1364
8112dec8:	19400536 	bltu	r3,r5,8112dee0 <_free_r+0x2f8>
8112decc:	100ad4ba 	srli	r5,r2,18
8112ded0:	28c01f44 	addi	r3,r5,125
8112ded4:	18c7883a 	add	r3,r3,r3
8112ded8:	29401f04 	addi	r5,r5,124
8112dedc:	003f8e06 	br	8112dd18 <__reset+0xfb10dd18>
8112dee0:	00c03f84 	movi	r3,254
8112dee4:	01401f84 	movi	r5,126
8112dee8:	003f8b06 	br	8112dd18 <__reset+0xfb10dd18>
8112deec:	10c00054 	ori	r3,r2,1
8112def0:	30c00115 	stw	r3,4(r6)
8112def4:	308d883a 	add	r6,r6,r2
8112def8:	30800015 	stw	r2,0(r6)
8112defc:	003f7806 	br	8112dce0 <__reset+0xfb10dce0>

8112df00 <__sfvwrite_r>:
8112df00:	30800217 	ldw	r2,8(r6)
8112df04:	10006926 	beq	r2,zero,8112e0ac <__sfvwrite_r+0x1ac>
8112df08:	defff404 	addi	sp,sp,-48
8112df0c:	de00012e 	bgeu	sp,et,8112df14 <__sfvwrite_r+0x14>
8112df10:	003b68fa 	trap	3
8112df14:	28c0030b 	ldhu	r3,12(r5)
8112df18:	dd400715 	stw	r21,28(sp)
8112df1c:	dd000615 	stw	r20,24(sp)
8112df20:	dc000215 	stw	r16,8(sp)
8112df24:	dfc00b15 	stw	ra,44(sp)
8112df28:	df000a15 	stw	fp,40(sp)
8112df2c:	ddc00915 	stw	r23,36(sp)
8112df30:	dd800815 	stw	r22,32(sp)
8112df34:	dcc00515 	stw	r19,20(sp)
8112df38:	dc800415 	stw	r18,16(sp)
8112df3c:	dc400315 	stw	r17,12(sp)
8112df40:	1880020c 	andi	r2,r3,8
8112df44:	2821883a 	mov	r16,r5
8112df48:	202b883a 	mov	r21,r4
8112df4c:	3029883a 	mov	r20,r6
8112df50:	10002726 	beq	r2,zero,8112dff0 <__sfvwrite_r+0xf0>
8112df54:	28800417 	ldw	r2,16(r5)
8112df58:	10002526 	beq	r2,zero,8112dff0 <__sfvwrite_r+0xf0>
8112df5c:	1880008c 	andi	r2,r3,2
8112df60:	a4400017 	ldw	r17,0(r20)
8112df64:	10002a26 	beq	r2,zero,8112e010 <__sfvwrite_r+0x110>
8112df68:	05a00034 	movhi	r22,32768
8112df6c:	0027883a 	mov	r19,zero
8112df70:	0025883a 	mov	r18,zero
8112df74:	b5bf0004 	addi	r22,r22,-1024
8112df78:	980d883a 	mov	r6,r19
8112df7c:	a809883a 	mov	r4,r21
8112df80:	90004626 	beq	r18,zero,8112e09c <__sfvwrite_r+0x19c>
8112df84:	900f883a 	mov	r7,r18
8112df88:	b480022e 	bgeu	r22,r18,8112df94 <__sfvwrite_r+0x94>
8112df8c:	01e00034 	movhi	r7,32768
8112df90:	39ff0004 	addi	r7,r7,-1024
8112df94:	80800917 	ldw	r2,36(r16)
8112df98:	81400717 	ldw	r5,28(r16)
8112df9c:	103ee83a 	callr	r2
8112dfa0:	0080570e 	bge	zero,r2,8112e100 <__sfvwrite_r+0x200>
8112dfa4:	a0c00217 	ldw	r3,8(r20)
8112dfa8:	98a7883a 	add	r19,r19,r2
8112dfac:	90a5c83a 	sub	r18,r18,r2
8112dfb0:	1885c83a 	sub	r2,r3,r2
8112dfb4:	a0800215 	stw	r2,8(r20)
8112dfb8:	103fef1e 	bne	r2,zero,8112df78 <__reset+0xfb10df78>
8112dfbc:	0005883a 	mov	r2,zero
8112dfc0:	dfc00b17 	ldw	ra,44(sp)
8112dfc4:	df000a17 	ldw	fp,40(sp)
8112dfc8:	ddc00917 	ldw	r23,36(sp)
8112dfcc:	dd800817 	ldw	r22,32(sp)
8112dfd0:	dd400717 	ldw	r21,28(sp)
8112dfd4:	dd000617 	ldw	r20,24(sp)
8112dfd8:	dcc00517 	ldw	r19,20(sp)
8112dfdc:	dc800417 	ldw	r18,16(sp)
8112dfe0:	dc400317 	ldw	r17,12(sp)
8112dfe4:	dc000217 	ldw	r16,8(sp)
8112dfe8:	dec00c04 	addi	sp,sp,48
8112dfec:	f800283a 	ret
8112dff0:	800b883a 	mov	r5,r16
8112dff4:	a809883a 	mov	r4,r21
8112dff8:	112b6e00 	call	8112b6e0 <__swsetup_r>
8112dffc:	1000eb1e 	bne	r2,zero,8112e3ac <__sfvwrite_r+0x4ac>
8112e000:	80c0030b 	ldhu	r3,12(r16)
8112e004:	a4400017 	ldw	r17,0(r20)
8112e008:	1880008c 	andi	r2,r3,2
8112e00c:	103fd61e 	bne	r2,zero,8112df68 <__reset+0xfb10df68>
8112e010:	1880004c 	andi	r2,r3,1
8112e014:	10003f1e 	bne	r2,zero,8112e114 <__sfvwrite_r+0x214>
8112e018:	0039883a 	mov	fp,zero
8112e01c:	0025883a 	mov	r18,zero
8112e020:	90001a26 	beq	r18,zero,8112e08c <__sfvwrite_r+0x18c>
8112e024:	1880800c 	andi	r2,r3,512
8112e028:	84c00217 	ldw	r19,8(r16)
8112e02c:	10002126 	beq	r2,zero,8112e0b4 <__sfvwrite_r+0x1b4>
8112e030:	982f883a 	mov	r23,r19
8112e034:	94c09336 	bltu	r18,r19,8112e284 <__sfvwrite_r+0x384>
8112e038:	1881200c 	andi	r2,r3,1152
8112e03c:	10009e1e 	bne	r2,zero,8112e2b8 <__sfvwrite_r+0x3b8>
8112e040:	81000017 	ldw	r4,0(r16)
8112e044:	b80d883a 	mov	r6,r23
8112e048:	e00b883a 	mov	r5,fp
8112e04c:	112ea5c0 	call	8112ea5c <memmove>
8112e050:	80c00217 	ldw	r3,8(r16)
8112e054:	81000017 	ldw	r4,0(r16)
8112e058:	9005883a 	mov	r2,r18
8112e05c:	1ce7c83a 	sub	r19,r3,r19
8112e060:	25cf883a 	add	r7,r4,r23
8112e064:	84c00215 	stw	r19,8(r16)
8112e068:	81c00015 	stw	r7,0(r16)
8112e06c:	a0c00217 	ldw	r3,8(r20)
8112e070:	e0b9883a 	add	fp,fp,r2
8112e074:	90a5c83a 	sub	r18,r18,r2
8112e078:	18a7c83a 	sub	r19,r3,r2
8112e07c:	a4c00215 	stw	r19,8(r20)
8112e080:	983fce26 	beq	r19,zero,8112dfbc <__reset+0xfb10dfbc>
8112e084:	80c0030b 	ldhu	r3,12(r16)
8112e088:	903fe61e 	bne	r18,zero,8112e024 <__reset+0xfb10e024>
8112e08c:	8f000017 	ldw	fp,0(r17)
8112e090:	8c800117 	ldw	r18,4(r17)
8112e094:	8c400204 	addi	r17,r17,8
8112e098:	003fe106 	br	8112e020 <__reset+0xfb10e020>
8112e09c:	8cc00017 	ldw	r19,0(r17)
8112e0a0:	8c800117 	ldw	r18,4(r17)
8112e0a4:	8c400204 	addi	r17,r17,8
8112e0a8:	003fb306 	br	8112df78 <__reset+0xfb10df78>
8112e0ac:	0005883a 	mov	r2,zero
8112e0b0:	f800283a 	ret
8112e0b4:	81000017 	ldw	r4,0(r16)
8112e0b8:	80800417 	ldw	r2,16(r16)
8112e0bc:	11005736 	bltu	r2,r4,8112e21c <__sfvwrite_r+0x31c>
8112e0c0:	85c00517 	ldw	r23,20(r16)
8112e0c4:	95c05536 	bltu	r18,r23,8112e21c <__sfvwrite_r+0x31c>
8112e0c8:	00a00034 	movhi	r2,32768
8112e0cc:	10bfffc4 	addi	r2,r2,-1
8112e0d0:	9009883a 	mov	r4,r18
8112e0d4:	1480012e 	bgeu	r2,r18,8112e0dc <__sfvwrite_r+0x1dc>
8112e0d8:	1009883a 	mov	r4,r2
8112e0dc:	b80b883a 	mov	r5,r23
8112e0e0:	1136b140 	call	81136b14 <__divsi3>
8112e0e4:	15cf383a 	mul	r7,r2,r23
8112e0e8:	81400717 	ldw	r5,28(r16)
8112e0ec:	80800917 	ldw	r2,36(r16)
8112e0f0:	e00d883a 	mov	r6,fp
8112e0f4:	a809883a 	mov	r4,r21
8112e0f8:	103ee83a 	callr	r2
8112e0fc:	00bfdb16 	blt	zero,r2,8112e06c <__reset+0xfb10e06c>
8112e100:	8080030b 	ldhu	r2,12(r16)
8112e104:	10801014 	ori	r2,r2,64
8112e108:	8080030d 	sth	r2,12(r16)
8112e10c:	00bfffc4 	movi	r2,-1
8112e110:	003fab06 	br	8112dfc0 <__reset+0xfb10dfc0>
8112e114:	0027883a 	mov	r19,zero
8112e118:	0011883a 	mov	r8,zero
8112e11c:	0039883a 	mov	fp,zero
8112e120:	0025883a 	mov	r18,zero
8112e124:	90001f26 	beq	r18,zero,8112e1a4 <__sfvwrite_r+0x2a4>
8112e128:	40005a26 	beq	r8,zero,8112e294 <__sfvwrite_r+0x394>
8112e12c:	982d883a 	mov	r22,r19
8112e130:	94c0012e 	bgeu	r18,r19,8112e138 <__sfvwrite_r+0x238>
8112e134:	902d883a 	mov	r22,r18
8112e138:	81000017 	ldw	r4,0(r16)
8112e13c:	80800417 	ldw	r2,16(r16)
8112e140:	b02f883a 	mov	r23,r22
8112e144:	81c00517 	ldw	r7,20(r16)
8112e148:	1100032e 	bgeu	r2,r4,8112e158 <__sfvwrite_r+0x258>
8112e14c:	80c00217 	ldw	r3,8(r16)
8112e150:	38c7883a 	add	r3,r7,r3
8112e154:	1d801816 	blt	r3,r22,8112e1b8 <__sfvwrite_r+0x2b8>
8112e158:	b1c03e16 	blt	r22,r7,8112e254 <__sfvwrite_r+0x354>
8112e15c:	80800917 	ldw	r2,36(r16)
8112e160:	81400717 	ldw	r5,28(r16)
8112e164:	e00d883a 	mov	r6,fp
8112e168:	da000115 	stw	r8,4(sp)
8112e16c:	a809883a 	mov	r4,r21
8112e170:	103ee83a 	callr	r2
8112e174:	102f883a 	mov	r23,r2
8112e178:	da000117 	ldw	r8,4(sp)
8112e17c:	00bfe00e 	bge	zero,r2,8112e100 <__reset+0xfb10e100>
8112e180:	9de7c83a 	sub	r19,r19,r23
8112e184:	98001f26 	beq	r19,zero,8112e204 <__sfvwrite_r+0x304>
8112e188:	a0800217 	ldw	r2,8(r20)
8112e18c:	e5f9883a 	add	fp,fp,r23
8112e190:	95e5c83a 	sub	r18,r18,r23
8112e194:	15efc83a 	sub	r23,r2,r23
8112e198:	a5c00215 	stw	r23,8(r20)
8112e19c:	b83f8726 	beq	r23,zero,8112dfbc <__reset+0xfb10dfbc>
8112e1a0:	903fe11e 	bne	r18,zero,8112e128 <__reset+0xfb10e128>
8112e1a4:	8f000017 	ldw	fp,0(r17)
8112e1a8:	8c800117 	ldw	r18,4(r17)
8112e1ac:	0011883a 	mov	r8,zero
8112e1b0:	8c400204 	addi	r17,r17,8
8112e1b4:	003fdb06 	br	8112e124 <__reset+0xfb10e124>
8112e1b8:	180d883a 	mov	r6,r3
8112e1bc:	e00b883a 	mov	r5,fp
8112e1c0:	da000115 	stw	r8,4(sp)
8112e1c4:	d8c00015 	stw	r3,0(sp)
8112e1c8:	112ea5c0 	call	8112ea5c <memmove>
8112e1cc:	d8c00017 	ldw	r3,0(sp)
8112e1d0:	80800017 	ldw	r2,0(r16)
8112e1d4:	800b883a 	mov	r5,r16
8112e1d8:	a809883a 	mov	r4,r21
8112e1dc:	10c5883a 	add	r2,r2,r3
8112e1e0:	80800015 	stw	r2,0(r16)
8112e1e4:	d8c00015 	stw	r3,0(sp)
8112e1e8:	112d3540 	call	8112d354 <_fflush_r>
8112e1ec:	d8c00017 	ldw	r3,0(sp)
8112e1f0:	da000117 	ldw	r8,4(sp)
8112e1f4:	103fc21e 	bne	r2,zero,8112e100 <__reset+0xfb10e100>
8112e1f8:	182f883a 	mov	r23,r3
8112e1fc:	9de7c83a 	sub	r19,r19,r23
8112e200:	983fe11e 	bne	r19,zero,8112e188 <__reset+0xfb10e188>
8112e204:	800b883a 	mov	r5,r16
8112e208:	a809883a 	mov	r4,r21
8112e20c:	112d3540 	call	8112d354 <_fflush_r>
8112e210:	103fbb1e 	bne	r2,zero,8112e100 <__reset+0xfb10e100>
8112e214:	0011883a 	mov	r8,zero
8112e218:	003fdb06 	br	8112e188 <__reset+0xfb10e188>
8112e21c:	94c0012e 	bgeu	r18,r19,8112e224 <__sfvwrite_r+0x324>
8112e220:	9027883a 	mov	r19,r18
8112e224:	980d883a 	mov	r6,r19
8112e228:	e00b883a 	mov	r5,fp
8112e22c:	112ea5c0 	call	8112ea5c <memmove>
8112e230:	80800217 	ldw	r2,8(r16)
8112e234:	80c00017 	ldw	r3,0(r16)
8112e238:	14c5c83a 	sub	r2,r2,r19
8112e23c:	1cc7883a 	add	r3,r3,r19
8112e240:	80800215 	stw	r2,8(r16)
8112e244:	80c00015 	stw	r3,0(r16)
8112e248:	10004326 	beq	r2,zero,8112e358 <__sfvwrite_r+0x458>
8112e24c:	9805883a 	mov	r2,r19
8112e250:	003f8606 	br	8112e06c <__reset+0xfb10e06c>
8112e254:	b00d883a 	mov	r6,r22
8112e258:	e00b883a 	mov	r5,fp
8112e25c:	da000115 	stw	r8,4(sp)
8112e260:	112ea5c0 	call	8112ea5c <memmove>
8112e264:	80800217 	ldw	r2,8(r16)
8112e268:	80c00017 	ldw	r3,0(r16)
8112e26c:	da000117 	ldw	r8,4(sp)
8112e270:	1585c83a 	sub	r2,r2,r22
8112e274:	1dad883a 	add	r22,r3,r22
8112e278:	80800215 	stw	r2,8(r16)
8112e27c:	85800015 	stw	r22,0(r16)
8112e280:	003fbf06 	br	8112e180 <__reset+0xfb10e180>
8112e284:	81000017 	ldw	r4,0(r16)
8112e288:	9027883a 	mov	r19,r18
8112e28c:	902f883a 	mov	r23,r18
8112e290:	003f6c06 	br	8112e044 <__reset+0xfb10e044>
8112e294:	900d883a 	mov	r6,r18
8112e298:	01400284 	movi	r5,10
8112e29c:	e009883a 	mov	r4,fp
8112e2a0:	112e9780 	call	8112e978 <memchr>
8112e2a4:	10003e26 	beq	r2,zero,8112e3a0 <__sfvwrite_r+0x4a0>
8112e2a8:	10800044 	addi	r2,r2,1
8112e2ac:	1727c83a 	sub	r19,r2,fp
8112e2b0:	02000044 	movi	r8,1
8112e2b4:	003f9d06 	br	8112e12c <__reset+0xfb10e12c>
8112e2b8:	80800517 	ldw	r2,20(r16)
8112e2bc:	81400417 	ldw	r5,16(r16)
8112e2c0:	81c00017 	ldw	r7,0(r16)
8112e2c4:	10a7883a 	add	r19,r2,r2
8112e2c8:	9885883a 	add	r2,r19,r2
8112e2cc:	1026d7fa 	srli	r19,r2,31
8112e2d0:	396dc83a 	sub	r22,r7,r5
8112e2d4:	b1000044 	addi	r4,r22,1
8112e2d8:	9885883a 	add	r2,r19,r2
8112e2dc:	1027d07a 	srai	r19,r2,1
8112e2e0:	2485883a 	add	r2,r4,r18
8112e2e4:	980d883a 	mov	r6,r19
8112e2e8:	9880022e 	bgeu	r19,r2,8112e2f4 <__sfvwrite_r+0x3f4>
8112e2ec:	1027883a 	mov	r19,r2
8112e2f0:	100d883a 	mov	r6,r2
8112e2f4:	18c1000c 	andi	r3,r3,1024
8112e2f8:	18001c26 	beq	r3,zero,8112e36c <__sfvwrite_r+0x46c>
8112e2fc:	300b883a 	mov	r5,r6
8112e300:	a809883a 	mov	r4,r21
8112e304:	1123eec0 	call	81123eec <_malloc_r>
8112e308:	102f883a 	mov	r23,r2
8112e30c:	10002926 	beq	r2,zero,8112e3b4 <__sfvwrite_r+0x4b4>
8112e310:	81400417 	ldw	r5,16(r16)
8112e314:	b00d883a 	mov	r6,r22
8112e318:	1009883a 	mov	r4,r2
8112e31c:	11247000 	call	81124700 <memcpy>
8112e320:	8080030b 	ldhu	r2,12(r16)
8112e324:	00fedfc4 	movi	r3,-1153
8112e328:	10c4703a 	and	r2,r2,r3
8112e32c:	10802014 	ori	r2,r2,128
8112e330:	8080030d 	sth	r2,12(r16)
8112e334:	bd89883a 	add	r4,r23,r22
8112e338:	9d8fc83a 	sub	r7,r19,r22
8112e33c:	85c00415 	stw	r23,16(r16)
8112e340:	84c00515 	stw	r19,20(r16)
8112e344:	81000015 	stw	r4,0(r16)
8112e348:	9027883a 	mov	r19,r18
8112e34c:	81c00215 	stw	r7,8(r16)
8112e350:	902f883a 	mov	r23,r18
8112e354:	003f3b06 	br	8112e044 <__reset+0xfb10e044>
8112e358:	800b883a 	mov	r5,r16
8112e35c:	a809883a 	mov	r4,r21
8112e360:	112d3540 	call	8112d354 <_fflush_r>
8112e364:	103fb926 	beq	r2,zero,8112e24c <__reset+0xfb10e24c>
8112e368:	003f6506 	br	8112e100 <__reset+0xfb10e100>
8112e36c:	a809883a 	mov	r4,r21
8112e370:	112fc7c0 	call	8112fc7c <_realloc_r>
8112e374:	102f883a 	mov	r23,r2
8112e378:	103fee1e 	bne	r2,zero,8112e334 <__reset+0xfb10e334>
8112e37c:	81400417 	ldw	r5,16(r16)
8112e380:	a809883a 	mov	r4,r21
8112e384:	112dbe80 	call	8112dbe8 <_free_r>
8112e388:	8080030b 	ldhu	r2,12(r16)
8112e38c:	00ffdfc4 	movi	r3,-129
8112e390:	1884703a 	and	r2,r3,r2
8112e394:	00c00304 	movi	r3,12
8112e398:	a8c00015 	stw	r3,0(r21)
8112e39c:	003f5906 	br	8112e104 <__reset+0xfb10e104>
8112e3a0:	94c00044 	addi	r19,r18,1
8112e3a4:	02000044 	movi	r8,1
8112e3a8:	003f6006 	br	8112e12c <__reset+0xfb10e12c>
8112e3ac:	00bfffc4 	movi	r2,-1
8112e3b0:	003f0306 	br	8112dfc0 <__reset+0xfb10dfc0>
8112e3b4:	00800304 	movi	r2,12
8112e3b8:	a8800015 	stw	r2,0(r21)
8112e3bc:	8080030b 	ldhu	r2,12(r16)
8112e3c0:	003f5006 	br	8112e104 <__reset+0xfb10e104>

8112e3c4 <_fwalk>:
8112e3c4:	defff704 	addi	sp,sp,-36
8112e3c8:	de00012e 	bgeu	sp,et,8112e3d0 <_fwalk+0xc>
8112e3cc:	003b68fa 	trap	3
8112e3d0:	dd000415 	stw	r20,16(sp)
8112e3d4:	dfc00815 	stw	ra,32(sp)
8112e3d8:	ddc00715 	stw	r23,28(sp)
8112e3dc:	dd800615 	stw	r22,24(sp)
8112e3e0:	dd400515 	stw	r21,20(sp)
8112e3e4:	dcc00315 	stw	r19,12(sp)
8112e3e8:	dc800215 	stw	r18,8(sp)
8112e3ec:	dc400115 	stw	r17,4(sp)
8112e3f0:	dc000015 	stw	r16,0(sp)
8112e3f4:	2500b804 	addi	r20,r4,736
8112e3f8:	a0002326 	beq	r20,zero,8112e488 <_fwalk+0xc4>
8112e3fc:	282b883a 	mov	r21,r5
8112e400:	002f883a 	mov	r23,zero
8112e404:	05800044 	movi	r22,1
8112e408:	04ffffc4 	movi	r19,-1
8112e40c:	a4400117 	ldw	r17,4(r20)
8112e410:	a4800217 	ldw	r18,8(r20)
8112e414:	8c7fffc4 	addi	r17,r17,-1
8112e418:	88000d16 	blt	r17,zero,8112e450 <_fwalk+0x8c>
8112e41c:	94000304 	addi	r16,r18,12
8112e420:	94800384 	addi	r18,r18,14
8112e424:	8080000b 	ldhu	r2,0(r16)
8112e428:	8c7fffc4 	addi	r17,r17,-1
8112e42c:	813ffd04 	addi	r4,r16,-12
8112e430:	b080042e 	bgeu	r22,r2,8112e444 <_fwalk+0x80>
8112e434:	9080000f 	ldh	r2,0(r18)
8112e438:	14c00226 	beq	r2,r19,8112e444 <_fwalk+0x80>
8112e43c:	a83ee83a 	callr	r21
8112e440:	b8aeb03a 	or	r23,r23,r2
8112e444:	84001a04 	addi	r16,r16,104
8112e448:	94801a04 	addi	r18,r18,104
8112e44c:	8cfff51e 	bne	r17,r19,8112e424 <__reset+0xfb10e424>
8112e450:	a5000017 	ldw	r20,0(r20)
8112e454:	a03fed1e 	bne	r20,zero,8112e40c <__reset+0xfb10e40c>
8112e458:	b805883a 	mov	r2,r23
8112e45c:	dfc00817 	ldw	ra,32(sp)
8112e460:	ddc00717 	ldw	r23,28(sp)
8112e464:	dd800617 	ldw	r22,24(sp)
8112e468:	dd400517 	ldw	r21,20(sp)
8112e46c:	dd000417 	ldw	r20,16(sp)
8112e470:	dcc00317 	ldw	r19,12(sp)
8112e474:	dc800217 	ldw	r18,8(sp)
8112e478:	dc400117 	ldw	r17,4(sp)
8112e47c:	dc000017 	ldw	r16,0(sp)
8112e480:	dec00904 	addi	sp,sp,36
8112e484:	f800283a 	ret
8112e488:	002f883a 	mov	r23,zero
8112e48c:	003ff206 	br	8112e458 <__reset+0xfb10e458>

8112e490 <_fwalk_reent>:
8112e490:	defff704 	addi	sp,sp,-36
8112e494:	de00012e 	bgeu	sp,et,8112e49c <_fwalk_reent+0xc>
8112e498:	003b68fa 	trap	3
8112e49c:	dd000415 	stw	r20,16(sp)
8112e4a0:	dfc00815 	stw	ra,32(sp)
8112e4a4:	ddc00715 	stw	r23,28(sp)
8112e4a8:	dd800615 	stw	r22,24(sp)
8112e4ac:	dd400515 	stw	r21,20(sp)
8112e4b0:	dcc00315 	stw	r19,12(sp)
8112e4b4:	dc800215 	stw	r18,8(sp)
8112e4b8:	dc400115 	stw	r17,4(sp)
8112e4bc:	dc000015 	stw	r16,0(sp)
8112e4c0:	2500b804 	addi	r20,r4,736
8112e4c4:	a0002326 	beq	r20,zero,8112e554 <_fwalk_reent+0xc4>
8112e4c8:	282b883a 	mov	r21,r5
8112e4cc:	2027883a 	mov	r19,r4
8112e4d0:	002f883a 	mov	r23,zero
8112e4d4:	05800044 	movi	r22,1
8112e4d8:	04bfffc4 	movi	r18,-1
8112e4dc:	a4400117 	ldw	r17,4(r20)
8112e4e0:	a4000217 	ldw	r16,8(r20)
8112e4e4:	8c7fffc4 	addi	r17,r17,-1
8112e4e8:	88000c16 	blt	r17,zero,8112e51c <_fwalk_reent+0x8c>
8112e4ec:	84000304 	addi	r16,r16,12
8112e4f0:	8080000b 	ldhu	r2,0(r16)
8112e4f4:	8c7fffc4 	addi	r17,r17,-1
8112e4f8:	817ffd04 	addi	r5,r16,-12
8112e4fc:	b080052e 	bgeu	r22,r2,8112e514 <_fwalk_reent+0x84>
8112e500:	8080008f 	ldh	r2,2(r16)
8112e504:	9809883a 	mov	r4,r19
8112e508:	14800226 	beq	r2,r18,8112e514 <_fwalk_reent+0x84>
8112e50c:	a83ee83a 	callr	r21
8112e510:	b8aeb03a 	or	r23,r23,r2
8112e514:	84001a04 	addi	r16,r16,104
8112e518:	8cbff51e 	bne	r17,r18,8112e4f0 <__reset+0xfb10e4f0>
8112e51c:	a5000017 	ldw	r20,0(r20)
8112e520:	a03fee1e 	bne	r20,zero,8112e4dc <__reset+0xfb10e4dc>
8112e524:	b805883a 	mov	r2,r23
8112e528:	dfc00817 	ldw	ra,32(sp)
8112e52c:	ddc00717 	ldw	r23,28(sp)
8112e530:	dd800617 	ldw	r22,24(sp)
8112e534:	dd400517 	ldw	r21,20(sp)
8112e538:	dd000417 	ldw	r20,16(sp)
8112e53c:	dcc00317 	ldw	r19,12(sp)
8112e540:	dc800217 	ldw	r18,8(sp)
8112e544:	dc400117 	ldw	r17,4(sp)
8112e548:	dc000017 	ldw	r16,0(sp)
8112e54c:	dec00904 	addi	sp,sp,36
8112e550:	f800283a 	ret
8112e554:	002f883a 	mov	r23,zero
8112e558:	003ff206 	br	8112e524 <__reset+0xfb10e524>

8112e55c <_isatty_r>:
8112e55c:	defffd04 	addi	sp,sp,-12
8112e560:	de00012e 	bgeu	sp,et,8112e568 <_isatty_r+0xc>
8112e564:	003b68fa 	trap	3
8112e568:	dc000015 	stw	r16,0(sp)
8112e56c:	04204574 	movhi	r16,33045
8112e570:	dc400115 	stw	r17,4(sp)
8112e574:	8414cf04 	addi	r16,r16,21308
8112e578:	2023883a 	mov	r17,r4
8112e57c:	2809883a 	mov	r4,r5
8112e580:	dfc00215 	stw	ra,8(sp)
8112e584:	80000015 	stw	zero,0(r16)
8112e588:	11388040 	call	81138804 <isatty>
8112e58c:	00ffffc4 	movi	r3,-1
8112e590:	10c00526 	beq	r2,r3,8112e5a8 <_isatty_r+0x4c>
8112e594:	dfc00217 	ldw	ra,8(sp)
8112e598:	dc400117 	ldw	r17,4(sp)
8112e59c:	dc000017 	ldw	r16,0(sp)
8112e5a0:	dec00304 	addi	sp,sp,12
8112e5a4:	f800283a 	ret
8112e5a8:	80c00017 	ldw	r3,0(r16)
8112e5ac:	183ff926 	beq	r3,zero,8112e594 <__reset+0xfb10e594>
8112e5b0:	88c00015 	stw	r3,0(r17)
8112e5b4:	003ff706 	br	8112e594 <__reset+0xfb10e594>

8112e5b8 <iswspace>:
8112e5b8:	00803fc4 	movi	r2,255
8112e5bc:	11000836 	bltu	r2,r4,8112e5e0 <iswspace+0x28>
8112e5c0:	00a04574 	movhi	r2,33045
8112e5c4:	10945a04 	addi	r2,r2,20840
8112e5c8:	10800017 	ldw	r2,0(r2)
8112e5cc:	1109883a 	add	r4,r2,r4
8112e5d0:	20800043 	ldbu	r2,1(r4)
8112e5d4:	1080020c 	andi	r2,r2,8
8112e5d8:	10803fcc 	andi	r2,r2,255
8112e5dc:	f800283a 	ret
8112e5e0:	0005883a 	mov	r2,zero
8112e5e4:	f800283a 	ret

8112e5e8 <_setlocale_r>:
8112e5e8:	30001d26 	beq	r6,zero,8112e660 <_setlocale_r+0x78>
8112e5ec:	01604574 	movhi	r5,33045
8112e5f0:	defffe04 	addi	sp,sp,-8
8112e5f4:	294ab304 	addi	r5,r5,10956
8112e5f8:	3009883a 	mov	r4,r6
8112e5fc:	de00012e 	bgeu	sp,et,8112e604 <_setlocale_r+0x1c>
8112e600:	003b68fa 	trap	3
8112e604:	dc000015 	stw	r16,0(sp)
8112e608:	dfc00115 	stw	ra,4(sp)
8112e60c:	3021883a 	mov	r16,r6
8112e610:	11303340 	call	81130334 <strcmp>
8112e614:	1000061e 	bne	r2,zero,8112e630 <_setlocale_r+0x48>
8112e618:	00a04574 	movhi	r2,33045
8112e61c:	108a8204 	addi	r2,r2,10760
8112e620:	dfc00117 	ldw	ra,4(sp)
8112e624:	dc000017 	ldw	r16,0(sp)
8112e628:	dec00204 	addi	sp,sp,8
8112e62c:	f800283a 	ret
8112e630:	01604574 	movhi	r5,33045
8112e634:	294a8204 	addi	r5,r5,10760
8112e638:	8009883a 	mov	r4,r16
8112e63c:	11303340 	call	81130334 <strcmp>
8112e640:	103ff526 	beq	r2,zero,8112e618 <__reset+0xfb10e618>
8112e644:	01604574 	movhi	r5,33045
8112e648:	294a8c04 	addi	r5,r5,10800
8112e64c:	8009883a 	mov	r4,r16
8112e650:	11303340 	call	81130334 <strcmp>
8112e654:	103ff026 	beq	r2,zero,8112e618 <__reset+0xfb10e618>
8112e658:	0005883a 	mov	r2,zero
8112e65c:	003ff006 	br	8112e620 <__reset+0xfb10e620>
8112e660:	00a04574 	movhi	r2,33045
8112e664:	108a8204 	addi	r2,r2,10760
8112e668:	f800283a 	ret

8112e66c <__locale_charset>:
8112e66c:	00a04574 	movhi	r2,33045
8112e670:	108f2404 	addi	r2,r2,15504
8112e674:	f800283a 	ret

8112e678 <__locale_mb_cur_max>:
8112e678:	00a04574 	movhi	r2,33045
8112e67c:	10945f04 	addi	r2,r2,20860
8112e680:	10800017 	ldw	r2,0(r2)
8112e684:	f800283a 	ret

8112e688 <__locale_msgcharset>:
8112e688:	00a04574 	movhi	r2,33045
8112e68c:	108f1c04 	addi	r2,r2,15472
8112e690:	f800283a 	ret

8112e694 <__locale_cjk_lang>:
8112e694:	0005883a 	mov	r2,zero
8112e698:	f800283a 	ret

8112e69c <_localeconv_r>:
8112e69c:	00a04574 	movhi	r2,33045
8112e6a0:	108f2c04 	addi	r2,r2,15536
8112e6a4:	f800283a 	ret

8112e6a8 <setlocale>:
8112e6a8:	00a04574 	movhi	r2,33045
8112e6ac:	10945c04 	addi	r2,r2,20848
8112e6b0:	280d883a 	mov	r6,r5
8112e6b4:	200b883a 	mov	r5,r4
8112e6b8:	11000017 	ldw	r4,0(r2)
8112e6bc:	112e5e81 	jmpi	8112e5e8 <_setlocale_r>

8112e6c0 <localeconv>:
8112e6c0:	00a04574 	movhi	r2,33045
8112e6c4:	108f2c04 	addi	r2,r2,15536
8112e6c8:	f800283a 	ret

8112e6cc <_lseek_r>:
8112e6cc:	defffd04 	addi	sp,sp,-12
8112e6d0:	de00012e 	bgeu	sp,et,8112e6d8 <_lseek_r+0xc>
8112e6d4:	003b68fa 	trap	3
8112e6d8:	2805883a 	mov	r2,r5
8112e6dc:	dc000015 	stw	r16,0(sp)
8112e6e0:	04204574 	movhi	r16,33045
8112e6e4:	dc400115 	stw	r17,4(sp)
8112e6e8:	300b883a 	mov	r5,r6
8112e6ec:	8414cf04 	addi	r16,r16,21308
8112e6f0:	2023883a 	mov	r17,r4
8112e6f4:	380d883a 	mov	r6,r7
8112e6f8:	1009883a 	mov	r4,r2
8112e6fc:	dfc00215 	stw	ra,8(sp)
8112e700:	80000015 	stw	zero,0(r16)
8112e704:	11394000 	call	81139400 <lseek>
8112e708:	00ffffc4 	movi	r3,-1
8112e70c:	10c00526 	beq	r2,r3,8112e724 <_lseek_r+0x58>
8112e710:	dfc00217 	ldw	ra,8(sp)
8112e714:	dc400117 	ldw	r17,4(sp)
8112e718:	dc000017 	ldw	r16,0(sp)
8112e71c:	dec00304 	addi	sp,sp,12
8112e720:	f800283a 	ret
8112e724:	80c00017 	ldw	r3,0(r16)
8112e728:	183ff926 	beq	r3,zero,8112e710 <__reset+0xfb10e710>
8112e72c:	88c00015 	stw	r3,0(r17)
8112e730:	003ff706 	br	8112e710 <__reset+0xfb10e710>

8112e734 <_mbrtowc_r>:
8112e734:	defff704 	addi	sp,sp,-36
8112e738:	00a04574 	movhi	r2,33045
8112e73c:	de00012e 	bgeu	sp,et,8112e744 <_mbrtowc_r+0x10>
8112e740:	003b68fa 	trap	3
8112e744:	10946004 	addi	r2,r2,20864
8112e748:	dc800715 	stw	r18,28(sp)
8112e74c:	dc400615 	stw	r17,24(sp)
8112e750:	dc000515 	stw	r16,20(sp)
8112e754:	dfc00815 	stw	ra,32(sp)
8112e758:	2021883a 	mov	r16,r4
8112e75c:	dc400917 	ldw	r17,36(sp)
8112e760:	14800017 	ldw	r18,0(r2)
8112e764:	30001626 	beq	r6,zero,8112e7c0 <_mbrtowc_r+0x8c>
8112e768:	d9400215 	stw	r5,8(sp)
8112e76c:	d9800315 	stw	r6,12(sp)
8112e770:	d9c00415 	stw	r7,16(sp)
8112e774:	112e66c0 	call	8112e66c <__locale_charset>
8112e778:	d9c00417 	ldw	r7,16(sp)
8112e77c:	d9800317 	ldw	r6,12(sp)
8112e780:	d9400217 	ldw	r5,8(sp)
8112e784:	d8800015 	stw	r2,0(sp)
8112e788:	dc400115 	stw	r17,4(sp)
8112e78c:	8009883a 	mov	r4,r16
8112e790:	903ee83a 	callr	r18
8112e794:	00ffffc4 	movi	r3,-1
8112e798:	10c0031e 	bne	r2,r3,8112e7a8 <_mbrtowc_r+0x74>
8112e79c:	88000015 	stw	zero,0(r17)
8112e7a0:	00c02284 	movi	r3,138
8112e7a4:	80c00015 	stw	r3,0(r16)
8112e7a8:	dfc00817 	ldw	ra,32(sp)
8112e7ac:	dc800717 	ldw	r18,28(sp)
8112e7b0:	dc400617 	ldw	r17,24(sp)
8112e7b4:	dc000517 	ldw	r16,20(sp)
8112e7b8:	dec00904 	addi	sp,sp,36
8112e7bc:	f800283a 	ret
8112e7c0:	112e66c0 	call	8112e66c <__locale_charset>
8112e7c4:	01a04574 	movhi	r6,33045
8112e7c8:	318a8c04 	addi	r6,r6,10800
8112e7cc:	dc400115 	stw	r17,4(sp)
8112e7d0:	d8800015 	stw	r2,0(sp)
8112e7d4:	01c00044 	movi	r7,1
8112e7d8:	000b883a 	mov	r5,zero
8112e7dc:	8009883a 	mov	r4,r16
8112e7e0:	903ee83a 	callr	r18
8112e7e4:	003feb06 	br	8112e794 <__reset+0xfb10e794>

8112e7e8 <mbrtowc>:
8112e7e8:	defff704 	addi	sp,sp,-36
8112e7ec:	00a04574 	movhi	r2,33045
8112e7f0:	de00012e 	bgeu	sp,et,8112e7f8 <mbrtowc+0x10>
8112e7f4:	003b68fa 	trap	3
8112e7f8:	10945c04 	addi	r2,r2,20848
8112e7fc:	dc800415 	stw	r18,16(sp)
8112e800:	dc400315 	stw	r17,12(sp)
8112e804:	dfc00815 	stw	ra,32(sp)
8112e808:	dd400715 	stw	r21,28(sp)
8112e80c:	dd000615 	stw	r20,24(sp)
8112e810:	dcc00515 	stw	r19,20(sp)
8112e814:	dc000215 	stw	r16,8(sp)
8112e818:	3825883a 	mov	r18,r7
8112e81c:	14400017 	ldw	r17,0(r2)
8112e820:	28001c26 	beq	r5,zero,8112e894 <mbrtowc+0xac>
8112e824:	00a04574 	movhi	r2,33045
8112e828:	10946004 	addi	r2,r2,20864
8112e82c:	15400017 	ldw	r21,0(r2)
8112e830:	2821883a 	mov	r16,r5
8112e834:	2027883a 	mov	r19,r4
8112e838:	3029883a 	mov	r20,r6
8112e83c:	112e66c0 	call	8112e66c <__locale_charset>
8112e840:	d8800015 	stw	r2,0(sp)
8112e844:	dc800115 	stw	r18,4(sp)
8112e848:	a00f883a 	mov	r7,r20
8112e84c:	800d883a 	mov	r6,r16
8112e850:	980b883a 	mov	r5,r19
8112e854:	8809883a 	mov	r4,r17
8112e858:	a83ee83a 	callr	r21
8112e85c:	00ffffc4 	movi	r3,-1
8112e860:	10c0031e 	bne	r2,r3,8112e870 <mbrtowc+0x88>
8112e864:	90000015 	stw	zero,0(r18)
8112e868:	00c02284 	movi	r3,138
8112e86c:	88c00015 	stw	r3,0(r17)
8112e870:	dfc00817 	ldw	ra,32(sp)
8112e874:	dd400717 	ldw	r21,28(sp)
8112e878:	dd000617 	ldw	r20,24(sp)
8112e87c:	dcc00517 	ldw	r19,20(sp)
8112e880:	dc800417 	ldw	r18,16(sp)
8112e884:	dc400317 	ldw	r17,12(sp)
8112e888:	dc000217 	ldw	r16,8(sp)
8112e88c:	dec00904 	addi	sp,sp,36
8112e890:	f800283a 	ret
8112e894:	00a04574 	movhi	r2,33045
8112e898:	10946004 	addi	r2,r2,20864
8112e89c:	14000017 	ldw	r16,0(r2)
8112e8a0:	112e66c0 	call	8112e66c <__locale_charset>
8112e8a4:	01a04574 	movhi	r6,33045
8112e8a8:	318a8c04 	addi	r6,r6,10800
8112e8ac:	dc800115 	stw	r18,4(sp)
8112e8b0:	d8800015 	stw	r2,0(sp)
8112e8b4:	01c00044 	movi	r7,1
8112e8b8:	000b883a 	mov	r5,zero
8112e8bc:	8809883a 	mov	r4,r17
8112e8c0:	803ee83a 	callr	r16
8112e8c4:	003fe506 	br	8112e85c <__reset+0xfb10e85c>

8112e8c8 <__ascii_mbtowc>:
8112e8c8:	deffff04 	addi	sp,sp,-4
8112e8cc:	de00012e 	bgeu	sp,et,8112e8d4 <__ascii_mbtowc+0xc>
8112e8d0:	003b68fa 	trap	3
8112e8d4:	28000826 	beq	r5,zero,8112e8f8 <__ascii_mbtowc+0x30>
8112e8d8:	30000926 	beq	r6,zero,8112e900 <__ascii_mbtowc+0x38>
8112e8dc:	38000b26 	beq	r7,zero,8112e90c <__ascii_mbtowc+0x44>
8112e8e0:	30800003 	ldbu	r2,0(r6)
8112e8e4:	28800015 	stw	r2,0(r5)
8112e8e8:	30800003 	ldbu	r2,0(r6)
8112e8ec:	1004c03a 	cmpne	r2,r2,zero
8112e8f0:	dec00104 	addi	sp,sp,4
8112e8f4:	f800283a 	ret
8112e8f8:	d80b883a 	mov	r5,sp
8112e8fc:	303ff71e 	bne	r6,zero,8112e8dc <__reset+0xfb10e8dc>
8112e900:	0005883a 	mov	r2,zero
8112e904:	dec00104 	addi	sp,sp,4
8112e908:	f800283a 	ret
8112e90c:	00bfff84 	movi	r2,-2
8112e910:	003ff706 	br	8112e8f0 <__reset+0xfb10e8f0>

8112e914 <_mbtowc_r>:
8112e914:	00a04574 	movhi	r2,33045
8112e918:	defff804 	addi	sp,sp,-32
8112e91c:	10946004 	addi	r2,r2,20864
8112e920:	de00012e 	bgeu	sp,et,8112e928 <_mbtowc_r+0x14>
8112e924:	003b68fa 	trap	3
8112e928:	dfc00715 	stw	ra,28(sp)
8112e92c:	dc000615 	stw	r16,24(sp)
8112e930:	14000017 	ldw	r16,0(r2)
8112e934:	d9000215 	stw	r4,8(sp)
8112e938:	d9400315 	stw	r5,12(sp)
8112e93c:	d9800415 	stw	r6,16(sp)
8112e940:	d9c00515 	stw	r7,20(sp)
8112e944:	112e66c0 	call	8112e66c <__locale_charset>
8112e948:	d8800015 	stw	r2,0(sp)
8112e94c:	d8800817 	ldw	r2,32(sp)
8112e950:	d9c00517 	ldw	r7,20(sp)
8112e954:	d9800417 	ldw	r6,16(sp)
8112e958:	d9400317 	ldw	r5,12(sp)
8112e95c:	d9000217 	ldw	r4,8(sp)
8112e960:	d8800115 	stw	r2,4(sp)
8112e964:	803ee83a 	callr	r16
8112e968:	dfc00717 	ldw	ra,28(sp)
8112e96c:	dc000617 	ldw	r16,24(sp)
8112e970:	dec00804 	addi	sp,sp,32
8112e974:	f800283a 	ret

8112e978 <memchr>:
8112e978:	208000cc 	andi	r2,r4,3
8112e97c:	280f883a 	mov	r7,r5
8112e980:	10003426 	beq	r2,zero,8112ea54 <memchr+0xdc>
8112e984:	30bfffc4 	addi	r2,r6,-1
8112e988:	30001a26 	beq	r6,zero,8112e9f4 <memchr+0x7c>
8112e98c:	20c00003 	ldbu	r3,0(r4)
8112e990:	29803fcc 	andi	r6,r5,255
8112e994:	30c0051e 	bne	r6,r3,8112e9ac <memchr+0x34>
8112e998:	00001806 	br	8112e9fc <memchr+0x84>
8112e99c:	10001526 	beq	r2,zero,8112e9f4 <memchr+0x7c>
8112e9a0:	20c00003 	ldbu	r3,0(r4)
8112e9a4:	10bfffc4 	addi	r2,r2,-1
8112e9a8:	30c01426 	beq	r6,r3,8112e9fc <memchr+0x84>
8112e9ac:	21000044 	addi	r4,r4,1
8112e9b0:	20c000cc 	andi	r3,r4,3
8112e9b4:	183ff91e 	bne	r3,zero,8112e99c <__reset+0xfb10e99c>
8112e9b8:	020000c4 	movi	r8,3
8112e9bc:	40801136 	bltu	r8,r2,8112ea04 <memchr+0x8c>
8112e9c0:	10000c26 	beq	r2,zero,8112e9f4 <memchr+0x7c>
8112e9c4:	20c00003 	ldbu	r3,0(r4)
8112e9c8:	29403fcc 	andi	r5,r5,255
8112e9cc:	28c00b26 	beq	r5,r3,8112e9fc <memchr+0x84>
8112e9d0:	20c00044 	addi	r3,r4,1
8112e9d4:	39803fcc 	andi	r6,r7,255
8112e9d8:	2089883a 	add	r4,r4,r2
8112e9dc:	00000306 	br	8112e9ec <memchr+0x74>
8112e9e0:	18c00044 	addi	r3,r3,1
8112e9e4:	197fffc3 	ldbu	r5,-1(r3)
8112e9e8:	31400526 	beq	r6,r5,8112ea00 <memchr+0x88>
8112e9ec:	1805883a 	mov	r2,r3
8112e9f0:	20fffb1e 	bne	r4,r3,8112e9e0 <__reset+0xfb10e9e0>
8112e9f4:	0005883a 	mov	r2,zero
8112e9f8:	f800283a 	ret
8112e9fc:	2005883a 	mov	r2,r4
8112ea00:	f800283a 	ret
8112ea04:	28c03fcc 	andi	r3,r5,255
8112ea08:	1812923a 	slli	r9,r3,8
8112ea0c:	02ffbff4 	movhi	r11,65279
8112ea10:	02a02074 	movhi	r10,32897
8112ea14:	48d2b03a 	or	r9,r9,r3
8112ea18:	4806943a 	slli	r3,r9,16
8112ea1c:	5affbfc4 	addi	r11,r11,-257
8112ea20:	52a02004 	addi	r10,r10,-32640
8112ea24:	48d2b03a 	or	r9,r9,r3
8112ea28:	20c00017 	ldw	r3,0(r4)
8112ea2c:	48c6f03a 	xor	r3,r9,r3
8112ea30:	1acd883a 	add	r6,r3,r11
8112ea34:	00c6303a 	nor	r3,zero,r3
8112ea38:	30c6703a 	and	r3,r6,r3
8112ea3c:	1a86703a 	and	r3,r3,r10
8112ea40:	183fe01e 	bne	r3,zero,8112e9c4 <__reset+0xfb10e9c4>
8112ea44:	10bfff04 	addi	r2,r2,-4
8112ea48:	21000104 	addi	r4,r4,4
8112ea4c:	40bff636 	bltu	r8,r2,8112ea28 <__reset+0xfb10ea28>
8112ea50:	003fdb06 	br	8112e9c0 <__reset+0xfb10e9c0>
8112ea54:	3005883a 	mov	r2,r6
8112ea58:	003fd706 	br	8112e9b8 <__reset+0xfb10e9b8>

8112ea5c <memmove>:
8112ea5c:	2005883a 	mov	r2,r4
8112ea60:	29000b2e 	bgeu	r5,r4,8112ea90 <memmove+0x34>
8112ea64:	298f883a 	add	r7,r5,r6
8112ea68:	21c0092e 	bgeu	r4,r7,8112ea90 <memmove+0x34>
8112ea6c:	2187883a 	add	r3,r4,r6
8112ea70:	198bc83a 	sub	r5,r3,r6
8112ea74:	30004826 	beq	r6,zero,8112eb98 <memmove+0x13c>
8112ea78:	39ffffc4 	addi	r7,r7,-1
8112ea7c:	39000003 	ldbu	r4,0(r7)
8112ea80:	18ffffc4 	addi	r3,r3,-1
8112ea84:	19000005 	stb	r4,0(r3)
8112ea88:	28fffb1e 	bne	r5,r3,8112ea78 <__reset+0xfb10ea78>
8112ea8c:	f800283a 	ret
8112ea90:	00c003c4 	movi	r3,15
8112ea94:	1980412e 	bgeu	r3,r6,8112eb9c <memmove+0x140>
8112ea98:	2886b03a 	or	r3,r5,r2
8112ea9c:	18c000cc 	andi	r3,r3,3
8112eaa0:	1800401e 	bne	r3,zero,8112eba4 <memmove+0x148>
8112eaa4:	33fffc04 	addi	r15,r6,-16
8112eaa8:	781ed13a 	srli	r15,r15,4
8112eaac:	28c00104 	addi	r3,r5,4
8112eab0:	13400104 	addi	r13,r2,4
8112eab4:	781c913a 	slli	r14,r15,4
8112eab8:	2b000204 	addi	r12,r5,8
8112eabc:	12c00204 	addi	r11,r2,8
8112eac0:	73800504 	addi	r14,r14,20
8112eac4:	2a800304 	addi	r10,r5,12
8112eac8:	12400304 	addi	r9,r2,12
8112eacc:	2b9d883a 	add	r14,r5,r14
8112ead0:	2811883a 	mov	r8,r5
8112ead4:	100f883a 	mov	r7,r2
8112ead8:	41000017 	ldw	r4,0(r8)
8112eadc:	39c00404 	addi	r7,r7,16
8112eae0:	18c00404 	addi	r3,r3,16
8112eae4:	393ffc15 	stw	r4,-16(r7)
8112eae8:	193ffc17 	ldw	r4,-16(r3)
8112eaec:	6b400404 	addi	r13,r13,16
8112eaf0:	5ac00404 	addi	r11,r11,16
8112eaf4:	693ffc15 	stw	r4,-16(r13)
8112eaf8:	61000017 	ldw	r4,0(r12)
8112eafc:	4a400404 	addi	r9,r9,16
8112eb00:	42000404 	addi	r8,r8,16
8112eb04:	593ffc15 	stw	r4,-16(r11)
8112eb08:	51000017 	ldw	r4,0(r10)
8112eb0c:	63000404 	addi	r12,r12,16
8112eb10:	52800404 	addi	r10,r10,16
8112eb14:	493ffc15 	stw	r4,-16(r9)
8112eb18:	1bbfef1e 	bne	r3,r14,8112ead8 <__reset+0xfb10ead8>
8112eb1c:	79000044 	addi	r4,r15,1
8112eb20:	2008913a 	slli	r4,r4,4
8112eb24:	328003cc 	andi	r10,r6,15
8112eb28:	02c000c4 	movi	r11,3
8112eb2c:	1107883a 	add	r3,r2,r4
8112eb30:	290b883a 	add	r5,r5,r4
8112eb34:	5a801e2e 	bgeu	r11,r10,8112ebb0 <memmove+0x154>
8112eb38:	1813883a 	mov	r9,r3
8112eb3c:	2811883a 	mov	r8,r5
8112eb40:	500f883a 	mov	r7,r10
8112eb44:	41000017 	ldw	r4,0(r8)
8112eb48:	4a400104 	addi	r9,r9,4
8112eb4c:	39ffff04 	addi	r7,r7,-4
8112eb50:	493fff15 	stw	r4,-4(r9)
8112eb54:	42000104 	addi	r8,r8,4
8112eb58:	59fffa36 	bltu	r11,r7,8112eb44 <__reset+0xfb10eb44>
8112eb5c:	513fff04 	addi	r4,r10,-4
8112eb60:	2008d0ba 	srli	r4,r4,2
8112eb64:	318000cc 	andi	r6,r6,3
8112eb68:	21000044 	addi	r4,r4,1
8112eb6c:	2109883a 	add	r4,r4,r4
8112eb70:	2109883a 	add	r4,r4,r4
8112eb74:	1907883a 	add	r3,r3,r4
8112eb78:	290b883a 	add	r5,r5,r4
8112eb7c:	30000b26 	beq	r6,zero,8112ebac <memmove+0x150>
8112eb80:	198d883a 	add	r6,r3,r6
8112eb84:	29c00003 	ldbu	r7,0(r5)
8112eb88:	18c00044 	addi	r3,r3,1
8112eb8c:	29400044 	addi	r5,r5,1
8112eb90:	19ffffc5 	stb	r7,-1(r3)
8112eb94:	19bffb1e 	bne	r3,r6,8112eb84 <__reset+0xfb10eb84>
8112eb98:	f800283a 	ret
8112eb9c:	1007883a 	mov	r3,r2
8112eba0:	003ff606 	br	8112eb7c <__reset+0xfb10eb7c>
8112eba4:	1007883a 	mov	r3,r2
8112eba8:	003ff506 	br	8112eb80 <__reset+0xfb10eb80>
8112ebac:	f800283a 	ret
8112ebb0:	500d883a 	mov	r6,r10
8112ebb4:	003ff106 	br	8112eb7c <__reset+0xfb10eb7c>

8112ebb8 <_Balloc>:
8112ebb8:	defffc04 	addi	sp,sp,-16
8112ebbc:	de00012e 	bgeu	sp,et,8112ebc4 <_Balloc+0xc>
8112ebc0:	003b68fa 	trap	3
8112ebc4:	20801317 	ldw	r2,76(r4)
8112ebc8:	dc400115 	stw	r17,4(sp)
8112ebcc:	dc000015 	stw	r16,0(sp)
8112ebd0:	dfc00315 	stw	ra,12(sp)
8112ebd4:	dc800215 	stw	r18,8(sp)
8112ebd8:	2023883a 	mov	r17,r4
8112ebdc:	2821883a 	mov	r16,r5
8112ebe0:	10000f26 	beq	r2,zero,8112ec20 <_Balloc+0x68>
8112ebe4:	8407883a 	add	r3,r16,r16
8112ebe8:	18c7883a 	add	r3,r3,r3
8112ebec:	10c7883a 	add	r3,r2,r3
8112ebf0:	18800017 	ldw	r2,0(r3)
8112ebf4:	10001126 	beq	r2,zero,8112ec3c <_Balloc+0x84>
8112ebf8:	11000017 	ldw	r4,0(r2)
8112ebfc:	19000015 	stw	r4,0(r3)
8112ec00:	10000415 	stw	zero,16(r2)
8112ec04:	10000315 	stw	zero,12(r2)
8112ec08:	dfc00317 	ldw	ra,12(sp)
8112ec0c:	dc800217 	ldw	r18,8(sp)
8112ec10:	dc400117 	ldw	r17,4(sp)
8112ec14:	dc000017 	ldw	r16,0(sp)
8112ec18:	dec00404 	addi	sp,sp,16
8112ec1c:	f800283a 	ret
8112ec20:	01800844 	movi	r6,33
8112ec24:	01400104 	movi	r5,4
8112ec28:	1134df80 	call	81134df8 <_calloc_r>
8112ec2c:	88801315 	stw	r2,76(r17)
8112ec30:	103fec1e 	bne	r2,zero,8112ebe4 <__reset+0xfb10ebe4>
8112ec34:	0005883a 	mov	r2,zero
8112ec38:	003ff306 	br	8112ec08 <__reset+0xfb10ec08>
8112ec3c:	01400044 	movi	r5,1
8112ec40:	2c24983a 	sll	r18,r5,r16
8112ec44:	8809883a 	mov	r4,r17
8112ec48:	91800144 	addi	r6,r18,5
8112ec4c:	318d883a 	add	r6,r6,r6
8112ec50:	318d883a 	add	r6,r6,r6
8112ec54:	1134df80 	call	81134df8 <_calloc_r>
8112ec58:	103ff626 	beq	r2,zero,8112ec34 <__reset+0xfb10ec34>
8112ec5c:	14000115 	stw	r16,4(r2)
8112ec60:	14800215 	stw	r18,8(r2)
8112ec64:	003fe606 	br	8112ec00 <__reset+0xfb10ec00>

8112ec68 <_Bfree>:
8112ec68:	28000826 	beq	r5,zero,8112ec8c <_Bfree+0x24>
8112ec6c:	28c00117 	ldw	r3,4(r5)
8112ec70:	20801317 	ldw	r2,76(r4)
8112ec74:	18c7883a 	add	r3,r3,r3
8112ec78:	18c7883a 	add	r3,r3,r3
8112ec7c:	10c5883a 	add	r2,r2,r3
8112ec80:	10c00017 	ldw	r3,0(r2)
8112ec84:	28c00015 	stw	r3,0(r5)
8112ec88:	11400015 	stw	r5,0(r2)
8112ec8c:	f800283a 	ret

8112ec90 <__multadd>:
8112ec90:	defffa04 	addi	sp,sp,-24
8112ec94:	de00012e 	bgeu	sp,et,8112ec9c <__multadd+0xc>
8112ec98:	003b68fa 	trap	3
8112ec9c:	0011883a 	mov	r8,zero
8112eca0:	dc800315 	stw	r18,12(sp)
8112eca4:	dc400215 	stw	r17,8(sp)
8112eca8:	dc000115 	stw	r16,4(sp)
8112ecac:	2823883a 	mov	r17,r5
8112ecb0:	2c000417 	ldw	r16,16(r5)
8112ecb4:	dfc00515 	stw	ra,20(sp)
8112ecb8:	dcc00415 	stw	r19,16(sp)
8112ecbc:	2025883a 	mov	r18,r4
8112ecc0:	29400504 	addi	r5,r5,20
8112ecc4:	28c00017 	ldw	r3,0(r5)
8112ecc8:	29400104 	addi	r5,r5,4
8112eccc:	42000044 	addi	r8,r8,1
8112ecd0:	18bfffcc 	andi	r2,r3,65535
8112ecd4:	1185383a 	mul	r2,r2,r6
8112ecd8:	1806d43a 	srli	r3,r3,16
8112ecdc:	11cf883a 	add	r7,r2,r7
8112ece0:	3808d43a 	srli	r4,r7,16
8112ece4:	1987383a 	mul	r3,r3,r6
8112ece8:	38bfffcc 	andi	r2,r7,65535
8112ecec:	1907883a 	add	r3,r3,r4
8112ecf0:	1808943a 	slli	r4,r3,16
8112ecf4:	180ed43a 	srli	r7,r3,16
8112ecf8:	2085883a 	add	r2,r4,r2
8112ecfc:	28bfff15 	stw	r2,-4(r5)
8112ed00:	443ff016 	blt	r8,r16,8112ecc4 <__reset+0xfb10ecc4>
8112ed04:	38000926 	beq	r7,zero,8112ed2c <__multadd+0x9c>
8112ed08:	88800217 	ldw	r2,8(r17)
8112ed0c:	80800f0e 	bge	r16,r2,8112ed4c <__multadd+0xbc>
8112ed10:	80800144 	addi	r2,r16,5
8112ed14:	1085883a 	add	r2,r2,r2
8112ed18:	1085883a 	add	r2,r2,r2
8112ed1c:	8885883a 	add	r2,r17,r2
8112ed20:	11c00015 	stw	r7,0(r2)
8112ed24:	84000044 	addi	r16,r16,1
8112ed28:	8c000415 	stw	r16,16(r17)
8112ed2c:	8805883a 	mov	r2,r17
8112ed30:	dfc00517 	ldw	ra,20(sp)
8112ed34:	dcc00417 	ldw	r19,16(sp)
8112ed38:	dc800317 	ldw	r18,12(sp)
8112ed3c:	dc400217 	ldw	r17,8(sp)
8112ed40:	dc000117 	ldw	r16,4(sp)
8112ed44:	dec00604 	addi	sp,sp,24
8112ed48:	f800283a 	ret
8112ed4c:	89400117 	ldw	r5,4(r17)
8112ed50:	9009883a 	mov	r4,r18
8112ed54:	d9c00015 	stw	r7,0(sp)
8112ed58:	29400044 	addi	r5,r5,1
8112ed5c:	112ebb80 	call	8112ebb8 <_Balloc>
8112ed60:	89800417 	ldw	r6,16(r17)
8112ed64:	89400304 	addi	r5,r17,12
8112ed68:	11000304 	addi	r4,r2,12
8112ed6c:	31800084 	addi	r6,r6,2
8112ed70:	318d883a 	add	r6,r6,r6
8112ed74:	318d883a 	add	r6,r6,r6
8112ed78:	1027883a 	mov	r19,r2
8112ed7c:	11247000 	call	81124700 <memcpy>
8112ed80:	d9c00017 	ldw	r7,0(sp)
8112ed84:	88000a26 	beq	r17,zero,8112edb0 <__multadd+0x120>
8112ed88:	88c00117 	ldw	r3,4(r17)
8112ed8c:	90801317 	ldw	r2,76(r18)
8112ed90:	18c7883a 	add	r3,r3,r3
8112ed94:	18c7883a 	add	r3,r3,r3
8112ed98:	10c5883a 	add	r2,r2,r3
8112ed9c:	10c00017 	ldw	r3,0(r2)
8112eda0:	88c00015 	stw	r3,0(r17)
8112eda4:	14400015 	stw	r17,0(r2)
8112eda8:	9823883a 	mov	r17,r19
8112edac:	003fd806 	br	8112ed10 <__reset+0xfb10ed10>
8112edb0:	9823883a 	mov	r17,r19
8112edb4:	003fd606 	br	8112ed10 <__reset+0xfb10ed10>

8112edb8 <__s2b>:
8112edb8:	defff904 	addi	sp,sp,-28
8112edbc:	de00012e 	bgeu	sp,et,8112edc4 <__s2b+0xc>
8112edc0:	003b68fa 	trap	3
8112edc4:	dc400115 	stw	r17,4(sp)
8112edc8:	dc000015 	stw	r16,0(sp)
8112edcc:	2023883a 	mov	r17,r4
8112edd0:	2821883a 	mov	r16,r5
8112edd4:	39000204 	addi	r4,r7,8
8112edd8:	01400244 	movi	r5,9
8112eddc:	dcc00315 	stw	r19,12(sp)
8112ede0:	dc800215 	stw	r18,8(sp)
8112ede4:	dfc00615 	stw	ra,24(sp)
8112ede8:	dd400515 	stw	r21,20(sp)
8112edec:	dd000415 	stw	r20,16(sp)
8112edf0:	3825883a 	mov	r18,r7
8112edf4:	3027883a 	mov	r19,r6
8112edf8:	1136b140 	call	81136b14 <__divsi3>
8112edfc:	00c00044 	movi	r3,1
8112ee00:	000b883a 	mov	r5,zero
8112ee04:	1880030e 	bge	r3,r2,8112ee14 <__s2b+0x5c>
8112ee08:	18c7883a 	add	r3,r3,r3
8112ee0c:	29400044 	addi	r5,r5,1
8112ee10:	18bffd16 	blt	r3,r2,8112ee08 <__reset+0xfb10ee08>
8112ee14:	8809883a 	mov	r4,r17
8112ee18:	112ebb80 	call	8112ebb8 <_Balloc>
8112ee1c:	d8c00717 	ldw	r3,28(sp)
8112ee20:	10c00515 	stw	r3,20(r2)
8112ee24:	00c00044 	movi	r3,1
8112ee28:	10c00415 	stw	r3,16(r2)
8112ee2c:	00c00244 	movi	r3,9
8112ee30:	1cc0210e 	bge	r3,r19,8112eeb8 <__s2b+0x100>
8112ee34:	80eb883a 	add	r21,r16,r3
8112ee38:	a829883a 	mov	r20,r21
8112ee3c:	84e1883a 	add	r16,r16,r19
8112ee40:	a1c00007 	ldb	r7,0(r20)
8112ee44:	01800284 	movi	r6,10
8112ee48:	a5000044 	addi	r20,r20,1
8112ee4c:	100b883a 	mov	r5,r2
8112ee50:	39fff404 	addi	r7,r7,-48
8112ee54:	8809883a 	mov	r4,r17
8112ee58:	112ec900 	call	8112ec90 <__multadd>
8112ee5c:	a43ff81e 	bne	r20,r16,8112ee40 <__reset+0xfb10ee40>
8112ee60:	ace1883a 	add	r16,r21,r19
8112ee64:	843ffe04 	addi	r16,r16,-8
8112ee68:	9c800a0e 	bge	r19,r18,8112ee94 <__s2b+0xdc>
8112ee6c:	94e5c83a 	sub	r18,r18,r19
8112ee70:	84a5883a 	add	r18,r16,r18
8112ee74:	81c00007 	ldb	r7,0(r16)
8112ee78:	01800284 	movi	r6,10
8112ee7c:	84000044 	addi	r16,r16,1
8112ee80:	100b883a 	mov	r5,r2
8112ee84:	39fff404 	addi	r7,r7,-48
8112ee88:	8809883a 	mov	r4,r17
8112ee8c:	112ec900 	call	8112ec90 <__multadd>
8112ee90:	84bff81e 	bne	r16,r18,8112ee74 <__reset+0xfb10ee74>
8112ee94:	dfc00617 	ldw	ra,24(sp)
8112ee98:	dd400517 	ldw	r21,20(sp)
8112ee9c:	dd000417 	ldw	r20,16(sp)
8112eea0:	dcc00317 	ldw	r19,12(sp)
8112eea4:	dc800217 	ldw	r18,8(sp)
8112eea8:	dc400117 	ldw	r17,4(sp)
8112eeac:	dc000017 	ldw	r16,0(sp)
8112eeb0:	dec00704 	addi	sp,sp,28
8112eeb4:	f800283a 	ret
8112eeb8:	84000284 	addi	r16,r16,10
8112eebc:	1827883a 	mov	r19,r3
8112eec0:	003fe906 	br	8112ee68 <__reset+0xfb10ee68>

8112eec4 <__hi0bits>:
8112eec4:	20bfffec 	andhi	r2,r4,65535
8112eec8:	1000141e 	bne	r2,zero,8112ef1c <__hi0bits+0x58>
8112eecc:	2008943a 	slli	r4,r4,16
8112eed0:	00800404 	movi	r2,16
8112eed4:	20ffc02c 	andhi	r3,r4,65280
8112eed8:	1800021e 	bne	r3,zero,8112eee4 <__hi0bits+0x20>
8112eedc:	2008923a 	slli	r4,r4,8
8112eee0:	10800204 	addi	r2,r2,8
8112eee4:	20fc002c 	andhi	r3,r4,61440
8112eee8:	1800021e 	bne	r3,zero,8112eef4 <__hi0bits+0x30>
8112eeec:	2008913a 	slli	r4,r4,4
8112eef0:	10800104 	addi	r2,r2,4
8112eef4:	20f0002c 	andhi	r3,r4,49152
8112eef8:	1800031e 	bne	r3,zero,8112ef08 <__hi0bits+0x44>
8112eefc:	2109883a 	add	r4,r4,r4
8112ef00:	10800084 	addi	r2,r2,2
8112ef04:	2109883a 	add	r4,r4,r4
8112ef08:	20000316 	blt	r4,zero,8112ef18 <__hi0bits+0x54>
8112ef0c:	2110002c 	andhi	r4,r4,16384
8112ef10:	2000041e 	bne	r4,zero,8112ef24 <__hi0bits+0x60>
8112ef14:	00800804 	movi	r2,32
8112ef18:	f800283a 	ret
8112ef1c:	0005883a 	mov	r2,zero
8112ef20:	003fec06 	br	8112eed4 <__reset+0xfb10eed4>
8112ef24:	10800044 	addi	r2,r2,1
8112ef28:	f800283a 	ret

8112ef2c <__lo0bits>:
8112ef2c:	20c00017 	ldw	r3,0(r4)
8112ef30:	188001cc 	andi	r2,r3,7
8112ef34:	10000826 	beq	r2,zero,8112ef58 <__lo0bits+0x2c>
8112ef38:	1880004c 	andi	r2,r3,1
8112ef3c:	1000211e 	bne	r2,zero,8112efc4 <__lo0bits+0x98>
8112ef40:	1880008c 	andi	r2,r3,2
8112ef44:	1000211e 	bne	r2,zero,8112efcc <__lo0bits+0xa0>
8112ef48:	1806d0ba 	srli	r3,r3,2
8112ef4c:	00800084 	movi	r2,2
8112ef50:	20c00015 	stw	r3,0(r4)
8112ef54:	f800283a 	ret
8112ef58:	18bfffcc 	andi	r2,r3,65535
8112ef5c:	10001326 	beq	r2,zero,8112efac <__lo0bits+0x80>
8112ef60:	0005883a 	mov	r2,zero
8112ef64:	19403fcc 	andi	r5,r3,255
8112ef68:	2800021e 	bne	r5,zero,8112ef74 <__lo0bits+0x48>
8112ef6c:	1806d23a 	srli	r3,r3,8
8112ef70:	10800204 	addi	r2,r2,8
8112ef74:	194003cc 	andi	r5,r3,15
8112ef78:	2800021e 	bne	r5,zero,8112ef84 <__lo0bits+0x58>
8112ef7c:	1806d13a 	srli	r3,r3,4
8112ef80:	10800104 	addi	r2,r2,4
8112ef84:	194000cc 	andi	r5,r3,3
8112ef88:	2800021e 	bne	r5,zero,8112ef94 <__lo0bits+0x68>
8112ef8c:	1806d0ba 	srli	r3,r3,2
8112ef90:	10800084 	addi	r2,r2,2
8112ef94:	1940004c 	andi	r5,r3,1
8112ef98:	2800081e 	bne	r5,zero,8112efbc <__lo0bits+0x90>
8112ef9c:	1806d07a 	srli	r3,r3,1
8112efa0:	1800051e 	bne	r3,zero,8112efb8 <__lo0bits+0x8c>
8112efa4:	00800804 	movi	r2,32
8112efa8:	f800283a 	ret
8112efac:	1806d43a 	srli	r3,r3,16
8112efb0:	00800404 	movi	r2,16
8112efb4:	003feb06 	br	8112ef64 <__reset+0xfb10ef64>
8112efb8:	10800044 	addi	r2,r2,1
8112efbc:	20c00015 	stw	r3,0(r4)
8112efc0:	f800283a 	ret
8112efc4:	0005883a 	mov	r2,zero
8112efc8:	f800283a 	ret
8112efcc:	1806d07a 	srli	r3,r3,1
8112efd0:	00800044 	movi	r2,1
8112efd4:	20c00015 	stw	r3,0(r4)
8112efd8:	f800283a 	ret

8112efdc <__i2b>:
8112efdc:	defffd04 	addi	sp,sp,-12
8112efe0:	de00012e 	bgeu	sp,et,8112efe8 <__i2b+0xc>
8112efe4:	003b68fa 	trap	3
8112efe8:	dc000015 	stw	r16,0(sp)
8112efec:	04000044 	movi	r16,1
8112eff0:	dc400115 	stw	r17,4(sp)
8112eff4:	2823883a 	mov	r17,r5
8112eff8:	800b883a 	mov	r5,r16
8112effc:	dfc00215 	stw	ra,8(sp)
8112f000:	112ebb80 	call	8112ebb8 <_Balloc>
8112f004:	14400515 	stw	r17,20(r2)
8112f008:	14000415 	stw	r16,16(r2)
8112f00c:	dfc00217 	ldw	ra,8(sp)
8112f010:	dc400117 	ldw	r17,4(sp)
8112f014:	dc000017 	ldw	r16,0(sp)
8112f018:	dec00304 	addi	sp,sp,12
8112f01c:	f800283a 	ret

8112f020 <__multiply>:
8112f020:	defffa04 	addi	sp,sp,-24
8112f024:	de00012e 	bgeu	sp,et,8112f02c <__multiply+0xc>
8112f028:	003b68fa 	trap	3
8112f02c:	dcc00315 	stw	r19,12(sp)
8112f030:	dc800215 	stw	r18,8(sp)
8112f034:	34c00417 	ldw	r19,16(r6)
8112f038:	2c800417 	ldw	r18,16(r5)
8112f03c:	dd000415 	stw	r20,16(sp)
8112f040:	dc400115 	stw	r17,4(sp)
8112f044:	dfc00515 	stw	ra,20(sp)
8112f048:	dc000015 	stw	r16,0(sp)
8112f04c:	2829883a 	mov	r20,r5
8112f050:	3023883a 	mov	r17,r6
8112f054:	94c0050e 	bge	r18,r19,8112f06c <__multiply+0x4c>
8112f058:	9007883a 	mov	r3,r18
8112f05c:	3029883a 	mov	r20,r6
8112f060:	9825883a 	mov	r18,r19
8112f064:	2823883a 	mov	r17,r5
8112f068:	1827883a 	mov	r19,r3
8112f06c:	a0800217 	ldw	r2,8(r20)
8112f070:	94e1883a 	add	r16,r18,r19
8112f074:	a1400117 	ldw	r5,4(r20)
8112f078:	1400010e 	bge	r2,r16,8112f080 <__multiply+0x60>
8112f07c:	29400044 	addi	r5,r5,1
8112f080:	112ebb80 	call	8112ebb8 <_Balloc>
8112f084:	8415883a 	add	r10,r16,r16
8112f088:	12c00504 	addi	r11,r2,20
8112f08c:	5295883a 	add	r10,r10,r10
8112f090:	5a95883a 	add	r10,r11,r10
8112f094:	5807883a 	mov	r3,r11
8112f098:	5a80032e 	bgeu	r11,r10,8112f0a8 <__multiply+0x88>
8112f09c:	18000015 	stw	zero,0(r3)
8112f0a0:	18c00104 	addi	r3,r3,4
8112f0a4:	1abffd36 	bltu	r3,r10,8112f09c <__reset+0xfb10f09c>
8112f0a8:	9ce7883a 	add	r19,r19,r19
8112f0ac:	94a5883a 	add	r18,r18,r18
8112f0b0:	89800504 	addi	r6,r17,20
8112f0b4:	9ce7883a 	add	r19,r19,r19
8112f0b8:	a3400504 	addi	r13,r20,20
8112f0bc:	94a5883a 	add	r18,r18,r18
8112f0c0:	34d9883a 	add	r12,r6,r19
8112f0c4:	6c93883a 	add	r9,r13,r18
8112f0c8:	3300422e 	bgeu	r6,r12,8112f1d4 <__multiply+0x1b4>
8112f0cc:	37c00017 	ldw	ra,0(r6)
8112f0d0:	fbffffcc 	andi	r15,ra,65535
8112f0d4:	78001b26 	beq	r15,zero,8112f144 <__multiply+0x124>
8112f0d8:	5811883a 	mov	r8,r11
8112f0dc:	681d883a 	mov	r14,r13
8112f0e0:	000f883a 	mov	r7,zero
8112f0e4:	71000017 	ldw	r4,0(r14)
8112f0e8:	40c00017 	ldw	r3,0(r8)
8112f0ec:	73800104 	addi	r14,r14,4
8112f0f0:	217fffcc 	andi	r5,r4,65535
8112f0f4:	2bcb383a 	mul	r5,r5,r15
8112f0f8:	2008d43a 	srli	r4,r4,16
8112f0fc:	1c7fffcc 	andi	r17,r3,65535
8112f100:	2c4b883a 	add	r5,r5,r17
8112f104:	29cb883a 	add	r5,r5,r7
8112f108:	23c9383a 	mul	r4,r4,r15
8112f10c:	1806d43a 	srli	r3,r3,16
8112f110:	280ed43a 	srli	r7,r5,16
8112f114:	297fffcc 	andi	r5,r5,65535
8112f118:	20c7883a 	add	r3,r4,r3
8112f11c:	19c7883a 	add	r3,r3,r7
8112f120:	1808943a 	slli	r4,r3,16
8112f124:	4023883a 	mov	r17,r8
8112f128:	180ed43a 	srli	r7,r3,16
8112f12c:	214ab03a 	or	r5,r4,r5
8112f130:	41400015 	stw	r5,0(r8)
8112f134:	42000104 	addi	r8,r8,4
8112f138:	727fea36 	bltu	r14,r9,8112f0e4 <__reset+0xfb10f0e4>
8112f13c:	89c00115 	stw	r7,4(r17)
8112f140:	37c00017 	ldw	ra,0(r6)
8112f144:	f83ed43a 	srli	ra,ra,16
8112f148:	f8001f26 	beq	ra,zero,8112f1c8 <__multiply+0x1a8>
8112f14c:	58c00017 	ldw	r3,0(r11)
8112f150:	681d883a 	mov	r14,r13
8112f154:	581f883a 	mov	r15,r11
8112f158:	1811883a 	mov	r8,r3
8112f15c:	5825883a 	mov	r18,r11
8112f160:	000f883a 	mov	r7,zero
8112f164:	00000106 	br	8112f16c <__multiply+0x14c>
8112f168:	8825883a 	mov	r18,r17
8112f16c:	7140000b 	ldhu	r5,0(r14)
8112f170:	4010d43a 	srli	r8,r8,16
8112f174:	193fffcc 	andi	r4,r3,65535
8112f178:	2fcb383a 	mul	r5,r5,ra
8112f17c:	7bc00104 	addi	r15,r15,4
8112f180:	73800104 	addi	r14,r14,4
8112f184:	2a0b883a 	add	r5,r5,r8
8112f188:	29cb883a 	add	r5,r5,r7
8112f18c:	2806943a 	slli	r3,r5,16
8112f190:	94400104 	addi	r17,r18,4
8112f194:	280ad43a 	srli	r5,r5,16
8112f198:	1908b03a 	or	r4,r3,r4
8112f19c:	793fff15 	stw	r4,-4(r15)
8112f1a0:	70ffff17 	ldw	r3,-4(r14)
8112f1a4:	8a000017 	ldw	r8,0(r17)
8112f1a8:	1806d43a 	srli	r3,r3,16
8112f1ac:	413fffcc 	andi	r4,r8,65535
8112f1b0:	1fc7383a 	mul	r3,r3,ra
8112f1b4:	1907883a 	add	r3,r3,r4
8112f1b8:	1947883a 	add	r3,r3,r5
8112f1bc:	180ed43a 	srli	r7,r3,16
8112f1c0:	727fe936 	bltu	r14,r9,8112f168 <__reset+0xfb10f168>
8112f1c4:	90c00115 	stw	r3,4(r18)
8112f1c8:	31800104 	addi	r6,r6,4
8112f1cc:	5ac00104 	addi	r11,r11,4
8112f1d0:	333fbe36 	bltu	r6,r12,8112f0cc <__reset+0xfb10f0cc>
8112f1d4:	0400090e 	bge	zero,r16,8112f1fc <__multiply+0x1dc>
8112f1d8:	50ffff17 	ldw	r3,-4(r10)
8112f1dc:	52bfff04 	addi	r10,r10,-4
8112f1e0:	18000326 	beq	r3,zero,8112f1f0 <__multiply+0x1d0>
8112f1e4:	00000506 	br	8112f1fc <__multiply+0x1dc>
8112f1e8:	50c00017 	ldw	r3,0(r10)
8112f1ec:	1800031e 	bne	r3,zero,8112f1fc <__multiply+0x1dc>
8112f1f0:	843fffc4 	addi	r16,r16,-1
8112f1f4:	52bfff04 	addi	r10,r10,-4
8112f1f8:	803ffb1e 	bne	r16,zero,8112f1e8 <__reset+0xfb10f1e8>
8112f1fc:	14000415 	stw	r16,16(r2)
8112f200:	dfc00517 	ldw	ra,20(sp)
8112f204:	dd000417 	ldw	r20,16(sp)
8112f208:	dcc00317 	ldw	r19,12(sp)
8112f20c:	dc800217 	ldw	r18,8(sp)
8112f210:	dc400117 	ldw	r17,4(sp)
8112f214:	dc000017 	ldw	r16,0(sp)
8112f218:	dec00604 	addi	sp,sp,24
8112f21c:	f800283a 	ret

8112f220 <__pow5mult>:
8112f220:	defffa04 	addi	sp,sp,-24
8112f224:	de00012e 	bgeu	sp,et,8112f22c <__pow5mult+0xc>
8112f228:	003b68fa 	trap	3
8112f22c:	308000cc 	andi	r2,r6,3
8112f230:	dcc00315 	stw	r19,12(sp)
8112f234:	dc000015 	stw	r16,0(sp)
8112f238:	dfc00515 	stw	ra,20(sp)
8112f23c:	dd000415 	stw	r20,16(sp)
8112f240:	dc800215 	stw	r18,8(sp)
8112f244:	dc400115 	stw	r17,4(sp)
8112f248:	3021883a 	mov	r16,r6
8112f24c:	2027883a 	mov	r19,r4
8112f250:	10002f1e 	bne	r2,zero,8112f310 <__pow5mult+0xf0>
8112f254:	2825883a 	mov	r18,r5
8112f258:	8021d0ba 	srai	r16,r16,2
8112f25c:	80001a26 	beq	r16,zero,8112f2c8 <__pow5mult+0xa8>
8112f260:	9c401217 	ldw	r17,72(r19)
8112f264:	8800061e 	bne	r17,zero,8112f280 <__pow5mult+0x60>
8112f268:	00003406 	br	8112f33c <__pow5mult+0x11c>
8112f26c:	8021d07a 	srai	r16,r16,1
8112f270:	80001526 	beq	r16,zero,8112f2c8 <__pow5mult+0xa8>
8112f274:	88800017 	ldw	r2,0(r17)
8112f278:	10001c26 	beq	r2,zero,8112f2ec <__pow5mult+0xcc>
8112f27c:	1023883a 	mov	r17,r2
8112f280:	8080004c 	andi	r2,r16,1
8112f284:	103ff926 	beq	r2,zero,8112f26c <__reset+0xfb10f26c>
8112f288:	880d883a 	mov	r6,r17
8112f28c:	900b883a 	mov	r5,r18
8112f290:	9809883a 	mov	r4,r19
8112f294:	112f0200 	call	8112f020 <__multiply>
8112f298:	90001b26 	beq	r18,zero,8112f308 <__pow5mult+0xe8>
8112f29c:	91000117 	ldw	r4,4(r18)
8112f2a0:	98c01317 	ldw	r3,76(r19)
8112f2a4:	8021d07a 	srai	r16,r16,1
8112f2a8:	2109883a 	add	r4,r4,r4
8112f2ac:	2109883a 	add	r4,r4,r4
8112f2b0:	1907883a 	add	r3,r3,r4
8112f2b4:	19000017 	ldw	r4,0(r3)
8112f2b8:	91000015 	stw	r4,0(r18)
8112f2bc:	1c800015 	stw	r18,0(r3)
8112f2c0:	1025883a 	mov	r18,r2
8112f2c4:	803feb1e 	bne	r16,zero,8112f274 <__reset+0xfb10f274>
8112f2c8:	9005883a 	mov	r2,r18
8112f2cc:	dfc00517 	ldw	ra,20(sp)
8112f2d0:	dd000417 	ldw	r20,16(sp)
8112f2d4:	dcc00317 	ldw	r19,12(sp)
8112f2d8:	dc800217 	ldw	r18,8(sp)
8112f2dc:	dc400117 	ldw	r17,4(sp)
8112f2e0:	dc000017 	ldw	r16,0(sp)
8112f2e4:	dec00604 	addi	sp,sp,24
8112f2e8:	f800283a 	ret
8112f2ec:	880d883a 	mov	r6,r17
8112f2f0:	880b883a 	mov	r5,r17
8112f2f4:	9809883a 	mov	r4,r19
8112f2f8:	112f0200 	call	8112f020 <__multiply>
8112f2fc:	88800015 	stw	r2,0(r17)
8112f300:	10000015 	stw	zero,0(r2)
8112f304:	003fdd06 	br	8112f27c <__reset+0xfb10f27c>
8112f308:	1025883a 	mov	r18,r2
8112f30c:	003fd706 	br	8112f26c <__reset+0xfb10f26c>
8112f310:	10bfffc4 	addi	r2,r2,-1
8112f314:	1085883a 	add	r2,r2,r2
8112f318:	00e04574 	movhi	r3,33045
8112f31c:	18cab604 	addi	r3,r3,10968
8112f320:	1085883a 	add	r2,r2,r2
8112f324:	1885883a 	add	r2,r3,r2
8112f328:	11800017 	ldw	r6,0(r2)
8112f32c:	000f883a 	mov	r7,zero
8112f330:	112ec900 	call	8112ec90 <__multadd>
8112f334:	1025883a 	mov	r18,r2
8112f338:	003fc706 	br	8112f258 <__reset+0xfb10f258>
8112f33c:	05000044 	movi	r20,1
8112f340:	a00b883a 	mov	r5,r20
8112f344:	9809883a 	mov	r4,r19
8112f348:	112ebb80 	call	8112ebb8 <_Balloc>
8112f34c:	1023883a 	mov	r17,r2
8112f350:	00809c44 	movi	r2,625
8112f354:	88800515 	stw	r2,20(r17)
8112f358:	8d000415 	stw	r20,16(r17)
8112f35c:	9c401215 	stw	r17,72(r19)
8112f360:	88000015 	stw	zero,0(r17)
8112f364:	003fc606 	br	8112f280 <__reset+0xfb10f280>

8112f368 <__lshift>:
8112f368:	defff904 	addi	sp,sp,-28
8112f36c:	de00012e 	bgeu	sp,et,8112f374 <__lshift+0xc>
8112f370:	003b68fa 	trap	3
8112f374:	dd400515 	stw	r21,20(sp)
8112f378:	dcc00315 	stw	r19,12(sp)
8112f37c:	302bd17a 	srai	r21,r6,5
8112f380:	2cc00417 	ldw	r19,16(r5)
8112f384:	28800217 	ldw	r2,8(r5)
8112f388:	dd000415 	stw	r20,16(sp)
8112f38c:	ace7883a 	add	r19,r21,r19
8112f390:	dc800215 	stw	r18,8(sp)
8112f394:	dc400115 	stw	r17,4(sp)
8112f398:	dc000015 	stw	r16,0(sp)
8112f39c:	dfc00615 	stw	ra,24(sp)
8112f3a0:	9c000044 	addi	r16,r19,1
8112f3a4:	2823883a 	mov	r17,r5
8112f3a8:	3029883a 	mov	r20,r6
8112f3ac:	2025883a 	mov	r18,r4
8112f3b0:	29400117 	ldw	r5,4(r5)
8112f3b4:	1400030e 	bge	r2,r16,8112f3c4 <__lshift+0x5c>
8112f3b8:	1085883a 	add	r2,r2,r2
8112f3bc:	29400044 	addi	r5,r5,1
8112f3c0:	143ffd16 	blt	r2,r16,8112f3b8 <__reset+0xfb10f3b8>
8112f3c4:	9009883a 	mov	r4,r18
8112f3c8:	112ebb80 	call	8112ebb8 <_Balloc>
8112f3cc:	10c00504 	addi	r3,r2,20
8112f3d0:	0540070e 	bge	zero,r21,8112f3f0 <__lshift+0x88>
8112f3d4:	ad6b883a 	add	r21,r21,r21
8112f3d8:	ad6b883a 	add	r21,r21,r21
8112f3dc:	1809883a 	mov	r4,r3
8112f3e0:	1d47883a 	add	r3,r3,r21
8112f3e4:	20000015 	stw	zero,0(r4)
8112f3e8:	21000104 	addi	r4,r4,4
8112f3ec:	193ffd1e 	bne	r3,r4,8112f3e4 <__reset+0xfb10f3e4>
8112f3f0:	8a000417 	ldw	r8,16(r17)
8112f3f4:	89000504 	addi	r4,r17,20
8112f3f8:	a18007cc 	andi	r6,r20,31
8112f3fc:	4211883a 	add	r8,r8,r8
8112f400:	4211883a 	add	r8,r8,r8
8112f404:	2211883a 	add	r8,r4,r8
8112f408:	30002326 	beq	r6,zero,8112f498 <__lshift+0x130>
8112f40c:	02400804 	movi	r9,32
8112f410:	4993c83a 	sub	r9,r9,r6
8112f414:	000b883a 	mov	r5,zero
8112f418:	21c00017 	ldw	r7,0(r4)
8112f41c:	1815883a 	mov	r10,r3
8112f420:	18c00104 	addi	r3,r3,4
8112f424:	398e983a 	sll	r7,r7,r6
8112f428:	21000104 	addi	r4,r4,4
8112f42c:	394ab03a 	or	r5,r7,r5
8112f430:	197fff15 	stw	r5,-4(r3)
8112f434:	217fff17 	ldw	r5,-4(r4)
8112f438:	2a4ad83a 	srl	r5,r5,r9
8112f43c:	223ff636 	bltu	r4,r8,8112f418 <__reset+0xfb10f418>
8112f440:	51400115 	stw	r5,4(r10)
8112f444:	28001a1e 	bne	r5,zero,8112f4b0 <__lshift+0x148>
8112f448:	843fffc4 	addi	r16,r16,-1
8112f44c:	14000415 	stw	r16,16(r2)
8112f450:	88000826 	beq	r17,zero,8112f474 <__lshift+0x10c>
8112f454:	89000117 	ldw	r4,4(r17)
8112f458:	90c01317 	ldw	r3,76(r18)
8112f45c:	2109883a 	add	r4,r4,r4
8112f460:	2109883a 	add	r4,r4,r4
8112f464:	1907883a 	add	r3,r3,r4
8112f468:	19000017 	ldw	r4,0(r3)
8112f46c:	89000015 	stw	r4,0(r17)
8112f470:	1c400015 	stw	r17,0(r3)
8112f474:	dfc00617 	ldw	ra,24(sp)
8112f478:	dd400517 	ldw	r21,20(sp)
8112f47c:	dd000417 	ldw	r20,16(sp)
8112f480:	dcc00317 	ldw	r19,12(sp)
8112f484:	dc800217 	ldw	r18,8(sp)
8112f488:	dc400117 	ldw	r17,4(sp)
8112f48c:	dc000017 	ldw	r16,0(sp)
8112f490:	dec00704 	addi	sp,sp,28
8112f494:	f800283a 	ret
8112f498:	21400017 	ldw	r5,0(r4)
8112f49c:	18c00104 	addi	r3,r3,4
8112f4a0:	21000104 	addi	r4,r4,4
8112f4a4:	197fff15 	stw	r5,-4(r3)
8112f4a8:	223ffb36 	bltu	r4,r8,8112f498 <__reset+0xfb10f498>
8112f4ac:	003fe606 	br	8112f448 <__reset+0xfb10f448>
8112f4b0:	9c000084 	addi	r16,r19,2
8112f4b4:	003fe406 	br	8112f448 <__reset+0xfb10f448>

8112f4b8 <__mcmp>:
8112f4b8:	20800417 	ldw	r2,16(r4)
8112f4bc:	28c00417 	ldw	r3,16(r5)
8112f4c0:	10c5c83a 	sub	r2,r2,r3
8112f4c4:	1000111e 	bne	r2,zero,8112f50c <__mcmp+0x54>
8112f4c8:	18c7883a 	add	r3,r3,r3
8112f4cc:	18c7883a 	add	r3,r3,r3
8112f4d0:	21000504 	addi	r4,r4,20
8112f4d4:	29400504 	addi	r5,r5,20
8112f4d8:	20c5883a 	add	r2,r4,r3
8112f4dc:	28cb883a 	add	r5,r5,r3
8112f4e0:	00000106 	br	8112f4e8 <__mcmp+0x30>
8112f4e4:	20800a2e 	bgeu	r4,r2,8112f510 <__mcmp+0x58>
8112f4e8:	10bfff04 	addi	r2,r2,-4
8112f4ec:	297fff04 	addi	r5,r5,-4
8112f4f0:	11800017 	ldw	r6,0(r2)
8112f4f4:	28c00017 	ldw	r3,0(r5)
8112f4f8:	30fffa26 	beq	r6,r3,8112f4e4 <__reset+0xfb10f4e4>
8112f4fc:	30c00236 	bltu	r6,r3,8112f508 <__mcmp+0x50>
8112f500:	00800044 	movi	r2,1
8112f504:	f800283a 	ret
8112f508:	00bfffc4 	movi	r2,-1
8112f50c:	f800283a 	ret
8112f510:	0005883a 	mov	r2,zero
8112f514:	f800283a 	ret

8112f518 <__mdiff>:
8112f518:	defffa04 	addi	sp,sp,-24
8112f51c:	de00012e 	bgeu	sp,et,8112f524 <__mdiff+0xc>
8112f520:	003b68fa 	trap	3
8112f524:	28c00417 	ldw	r3,16(r5)
8112f528:	30800417 	ldw	r2,16(r6)
8112f52c:	dcc00315 	stw	r19,12(sp)
8112f530:	dc800215 	stw	r18,8(sp)
8112f534:	dfc00515 	stw	ra,20(sp)
8112f538:	dd000415 	stw	r20,16(sp)
8112f53c:	dc400115 	stw	r17,4(sp)
8112f540:	dc000015 	stw	r16,0(sp)
8112f544:	1887c83a 	sub	r3,r3,r2
8112f548:	2825883a 	mov	r18,r5
8112f54c:	3027883a 	mov	r19,r6
8112f550:	1800141e 	bne	r3,zero,8112f5a4 <__mdiff+0x8c>
8112f554:	1085883a 	add	r2,r2,r2
8112f558:	1085883a 	add	r2,r2,r2
8112f55c:	2a000504 	addi	r8,r5,20
8112f560:	34000504 	addi	r16,r6,20
8112f564:	4087883a 	add	r3,r8,r2
8112f568:	8085883a 	add	r2,r16,r2
8112f56c:	00000106 	br	8112f574 <__mdiff+0x5c>
8112f570:	40c0592e 	bgeu	r8,r3,8112f6d8 <__mdiff+0x1c0>
8112f574:	18ffff04 	addi	r3,r3,-4
8112f578:	10bfff04 	addi	r2,r2,-4
8112f57c:	19c00017 	ldw	r7,0(r3)
8112f580:	11400017 	ldw	r5,0(r2)
8112f584:	397ffa26 	beq	r7,r5,8112f570 <__reset+0xfb10f570>
8112f588:	3940592e 	bgeu	r7,r5,8112f6f0 <__mdiff+0x1d8>
8112f58c:	9005883a 	mov	r2,r18
8112f590:	4023883a 	mov	r17,r8
8112f594:	9825883a 	mov	r18,r19
8112f598:	05000044 	movi	r20,1
8112f59c:	1027883a 	mov	r19,r2
8112f5a0:	00000406 	br	8112f5b4 <__mdiff+0x9c>
8112f5a4:	18005616 	blt	r3,zero,8112f700 <__mdiff+0x1e8>
8112f5a8:	34400504 	addi	r17,r6,20
8112f5ac:	2c000504 	addi	r16,r5,20
8112f5b0:	0029883a 	mov	r20,zero
8112f5b4:	91400117 	ldw	r5,4(r18)
8112f5b8:	112ebb80 	call	8112ebb8 <_Balloc>
8112f5bc:	92400417 	ldw	r9,16(r18)
8112f5c0:	9b000417 	ldw	r12,16(r19)
8112f5c4:	12c00504 	addi	r11,r2,20
8112f5c8:	4a51883a 	add	r8,r9,r9
8112f5cc:	6319883a 	add	r12,r12,r12
8112f5d0:	4211883a 	add	r8,r8,r8
8112f5d4:	6319883a 	add	r12,r12,r12
8112f5d8:	15000315 	stw	r20,12(r2)
8112f5dc:	8211883a 	add	r8,r16,r8
8112f5e0:	8b19883a 	add	r12,r17,r12
8112f5e4:	0007883a 	mov	r3,zero
8112f5e8:	81400017 	ldw	r5,0(r16)
8112f5ec:	89c00017 	ldw	r7,0(r17)
8112f5f0:	59800104 	addi	r6,r11,4
8112f5f4:	293fffcc 	andi	r4,r5,65535
8112f5f8:	20c7883a 	add	r3,r4,r3
8112f5fc:	393fffcc 	andi	r4,r7,65535
8112f600:	1909c83a 	sub	r4,r3,r4
8112f604:	280ad43a 	srli	r5,r5,16
8112f608:	380ed43a 	srli	r7,r7,16
8112f60c:	2007d43a 	srai	r3,r4,16
8112f610:	213fffcc 	andi	r4,r4,65535
8112f614:	29cbc83a 	sub	r5,r5,r7
8112f618:	28c7883a 	add	r3,r5,r3
8112f61c:	180a943a 	slli	r5,r3,16
8112f620:	8c400104 	addi	r17,r17,4
8112f624:	84000104 	addi	r16,r16,4
8112f628:	2908b03a 	or	r4,r5,r4
8112f62c:	59000015 	stw	r4,0(r11)
8112f630:	1807d43a 	srai	r3,r3,16
8112f634:	3015883a 	mov	r10,r6
8112f638:	3017883a 	mov	r11,r6
8112f63c:	8b3fea36 	bltu	r17,r12,8112f5e8 <__reset+0xfb10f5e8>
8112f640:	8200162e 	bgeu	r16,r8,8112f69c <__mdiff+0x184>
8112f644:	8017883a 	mov	r11,r16
8112f648:	59400017 	ldw	r5,0(r11)
8112f64c:	31800104 	addi	r6,r6,4
8112f650:	5ac00104 	addi	r11,r11,4
8112f654:	293fffcc 	andi	r4,r5,65535
8112f658:	20c7883a 	add	r3,r4,r3
8112f65c:	280ed43a 	srli	r7,r5,16
8112f660:	180bd43a 	srai	r5,r3,16
8112f664:	193fffcc 	andi	r4,r3,65535
8112f668:	3947883a 	add	r3,r7,r5
8112f66c:	180a943a 	slli	r5,r3,16
8112f670:	1807d43a 	srai	r3,r3,16
8112f674:	2908b03a 	or	r4,r5,r4
8112f678:	313fff15 	stw	r4,-4(r6)
8112f67c:	5a3ff236 	bltu	r11,r8,8112f648 <__reset+0xfb10f648>
8112f680:	0406303a 	nor	r3,zero,r16
8112f684:	1a07883a 	add	r3,r3,r8
8112f688:	1806d0ba 	srli	r3,r3,2
8112f68c:	18c00044 	addi	r3,r3,1
8112f690:	18c7883a 	add	r3,r3,r3
8112f694:	18c7883a 	add	r3,r3,r3
8112f698:	50d5883a 	add	r10,r10,r3
8112f69c:	50ffff04 	addi	r3,r10,-4
8112f6a0:	2000041e 	bne	r4,zero,8112f6b4 <__mdiff+0x19c>
8112f6a4:	18ffff04 	addi	r3,r3,-4
8112f6a8:	19000017 	ldw	r4,0(r3)
8112f6ac:	4a7fffc4 	addi	r9,r9,-1
8112f6b0:	203ffc26 	beq	r4,zero,8112f6a4 <__reset+0xfb10f6a4>
8112f6b4:	12400415 	stw	r9,16(r2)
8112f6b8:	dfc00517 	ldw	ra,20(sp)
8112f6bc:	dd000417 	ldw	r20,16(sp)
8112f6c0:	dcc00317 	ldw	r19,12(sp)
8112f6c4:	dc800217 	ldw	r18,8(sp)
8112f6c8:	dc400117 	ldw	r17,4(sp)
8112f6cc:	dc000017 	ldw	r16,0(sp)
8112f6d0:	dec00604 	addi	sp,sp,24
8112f6d4:	f800283a 	ret
8112f6d8:	000b883a 	mov	r5,zero
8112f6dc:	112ebb80 	call	8112ebb8 <_Balloc>
8112f6e0:	00c00044 	movi	r3,1
8112f6e4:	10c00415 	stw	r3,16(r2)
8112f6e8:	10000515 	stw	zero,20(r2)
8112f6ec:	003ff206 	br	8112f6b8 <__reset+0xfb10f6b8>
8112f6f0:	8023883a 	mov	r17,r16
8112f6f4:	0029883a 	mov	r20,zero
8112f6f8:	4021883a 	mov	r16,r8
8112f6fc:	003fad06 	br	8112f5b4 <__reset+0xfb10f5b4>
8112f700:	9005883a 	mov	r2,r18
8112f704:	94400504 	addi	r17,r18,20
8112f708:	9c000504 	addi	r16,r19,20
8112f70c:	9825883a 	mov	r18,r19
8112f710:	05000044 	movi	r20,1
8112f714:	1027883a 	mov	r19,r2
8112f718:	003fa606 	br	8112f5b4 <__reset+0xfb10f5b4>

8112f71c <__ulp>:
8112f71c:	295ffc2c 	andhi	r5,r5,32752
8112f720:	00bf3034 	movhi	r2,64704
8112f724:	2887883a 	add	r3,r5,r2
8112f728:	00c0020e 	bge	zero,r3,8112f734 <__ulp+0x18>
8112f72c:	0005883a 	mov	r2,zero
8112f730:	f800283a 	ret
8112f734:	00c7c83a 	sub	r3,zero,r3
8112f738:	1807d53a 	srai	r3,r3,20
8112f73c:	008004c4 	movi	r2,19
8112f740:	10c00b0e 	bge	r2,r3,8112f770 <__ulp+0x54>
8112f744:	18bffb04 	addi	r2,r3,-20
8112f748:	01000784 	movi	r4,30
8112f74c:	0007883a 	mov	r3,zero
8112f750:	20800516 	blt	r4,r2,8112f768 <__ulp+0x4c>
8112f754:	010007c4 	movi	r4,31
8112f758:	2089c83a 	sub	r4,r4,r2
8112f75c:	00800044 	movi	r2,1
8112f760:	1104983a 	sll	r2,r2,r4
8112f764:	f800283a 	ret
8112f768:	00800044 	movi	r2,1
8112f76c:	f800283a 	ret
8112f770:	01400234 	movhi	r5,8
8112f774:	28c7d83a 	sra	r3,r5,r3
8112f778:	0005883a 	mov	r2,zero
8112f77c:	f800283a 	ret

8112f780 <__b2d>:
8112f780:	defffa04 	addi	sp,sp,-24
8112f784:	de00012e 	bgeu	sp,et,8112f78c <__b2d+0xc>
8112f788:	003b68fa 	trap	3
8112f78c:	dc000015 	stw	r16,0(sp)
8112f790:	24000417 	ldw	r16,16(r4)
8112f794:	dc400115 	stw	r17,4(sp)
8112f798:	24400504 	addi	r17,r4,20
8112f79c:	8421883a 	add	r16,r16,r16
8112f7a0:	8421883a 	add	r16,r16,r16
8112f7a4:	8c21883a 	add	r16,r17,r16
8112f7a8:	dc800215 	stw	r18,8(sp)
8112f7ac:	84bfff17 	ldw	r18,-4(r16)
8112f7b0:	dd000415 	stw	r20,16(sp)
8112f7b4:	dcc00315 	stw	r19,12(sp)
8112f7b8:	9009883a 	mov	r4,r18
8112f7bc:	2829883a 	mov	r20,r5
8112f7c0:	dfc00515 	stw	ra,20(sp)
8112f7c4:	112eec40 	call	8112eec4 <__hi0bits>
8112f7c8:	00c00804 	movi	r3,32
8112f7cc:	1889c83a 	sub	r4,r3,r2
8112f7d0:	a1000015 	stw	r4,0(r20)
8112f7d4:	01000284 	movi	r4,10
8112f7d8:	84ffff04 	addi	r19,r16,-4
8112f7dc:	20801216 	blt	r4,r2,8112f828 <__b2d+0xa8>
8112f7e0:	018002c4 	movi	r6,11
8112f7e4:	308dc83a 	sub	r6,r6,r2
8112f7e8:	9186d83a 	srl	r3,r18,r6
8112f7ec:	18cffc34 	orhi	r3,r3,16368
8112f7f0:	8cc0212e 	bgeu	r17,r19,8112f878 <__b2d+0xf8>
8112f7f4:	813ffe17 	ldw	r4,-8(r16)
8112f7f8:	218cd83a 	srl	r6,r4,r6
8112f7fc:	10800544 	addi	r2,r2,21
8112f800:	9084983a 	sll	r2,r18,r2
8112f804:	1184b03a 	or	r2,r2,r6
8112f808:	dfc00517 	ldw	ra,20(sp)
8112f80c:	dd000417 	ldw	r20,16(sp)
8112f810:	dcc00317 	ldw	r19,12(sp)
8112f814:	dc800217 	ldw	r18,8(sp)
8112f818:	dc400117 	ldw	r17,4(sp)
8112f81c:	dc000017 	ldw	r16,0(sp)
8112f820:	dec00604 	addi	sp,sp,24
8112f824:	f800283a 	ret
8112f828:	8cc00f2e 	bgeu	r17,r19,8112f868 <__b2d+0xe8>
8112f82c:	117ffd44 	addi	r5,r2,-11
8112f830:	80bffe17 	ldw	r2,-8(r16)
8112f834:	28000e26 	beq	r5,zero,8112f870 <__b2d+0xf0>
8112f838:	1949c83a 	sub	r4,r3,r5
8112f83c:	9164983a 	sll	r18,r18,r5
8112f840:	1106d83a 	srl	r3,r2,r4
8112f844:	81bffe04 	addi	r6,r16,-8
8112f848:	948ffc34 	orhi	r18,r18,16368
8112f84c:	90c6b03a 	or	r3,r18,r3
8112f850:	89800e2e 	bgeu	r17,r6,8112f88c <__b2d+0x10c>
8112f854:	81bffd17 	ldw	r6,-12(r16)
8112f858:	1144983a 	sll	r2,r2,r5
8112f85c:	310ad83a 	srl	r5,r6,r4
8112f860:	2884b03a 	or	r2,r5,r2
8112f864:	003fe806 	br	8112f808 <__reset+0xfb10f808>
8112f868:	10bffd44 	addi	r2,r2,-11
8112f86c:	1000041e 	bne	r2,zero,8112f880 <__b2d+0x100>
8112f870:	90cffc34 	orhi	r3,r18,16368
8112f874:	003fe406 	br	8112f808 <__reset+0xfb10f808>
8112f878:	000d883a 	mov	r6,zero
8112f87c:	003fdf06 	br	8112f7fc <__reset+0xfb10f7fc>
8112f880:	90a4983a 	sll	r18,r18,r2
8112f884:	0005883a 	mov	r2,zero
8112f888:	003ff906 	br	8112f870 <__reset+0xfb10f870>
8112f88c:	1144983a 	sll	r2,r2,r5
8112f890:	003fdd06 	br	8112f808 <__reset+0xfb10f808>

8112f894 <__d2b>:
8112f894:	defff804 	addi	sp,sp,-32
8112f898:	de00012e 	bgeu	sp,et,8112f8a0 <__d2b+0xc>
8112f89c:	003b68fa 	trap	3
8112f8a0:	dc000215 	stw	r16,8(sp)
8112f8a4:	3021883a 	mov	r16,r6
8112f8a8:	dc400315 	stw	r17,12(sp)
8112f8ac:	8022907a 	slli	r17,r16,1
8112f8b0:	dd000615 	stw	r20,24(sp)
8112f8b4:	2829883a 	mov	r20,r5
8112f8b8:	01400044 	movi	r5,1
8112f8bc:	dcc00515 	stw	r19,20(sp)
8112f8c0:	dc800415 	stw	r18,16(sp)
8112f8c4:	dfc00715 	stw	ra,28(sp)
8112f8c8:	3825883a 	mov	r18,r7
8112f8cc:	8822d57a 	srli	r17,r17,21
8112f8d0:	112ebb80 	call	8112ebb8 <_Balloc>
8112f8d4:	1027883a 	mov	r19,r2
8112f8d8:	00800434 	movhi	r2,16
8112f8dc:	10bfffc4 	addi	r2,r2,-1
8112f8e0:	808c703a 	and	r6,r16,r2
8112f8e4:	88000126 	beq	r17,zero,8112f8ec <__d2b+0x58>
8112f8e8:	31800434 	orhi	r6,r6,16
8112f8ec:	d9800015 	stw	r6,0(sp)
8112f8f0:	a0002426 	beq	r20,zero,8112f984 <__d2b+0xf0>
8112f8f4:	d9000104 	addi	r4,sp,4
8112f8f8:	dd000115 	stw	r20,4(sp)
8112f8fc:	112ef2c0 	call	8112ef2c <__lo0bits>
8112f900:	d8c00017 	ldw	r3,0(sp)
8112f904:	10002f1e 	bne	r2,zero,8112f9c4 <__d2b+0x130>
8112f908:	d9000117 	ldw	r4,4(sp)
8112f90c:	99000515 	stw	r4,20(r19)
8112f910:	1821003a 	cmpeq	r16,r3,zero
8112f914:	01000084 	movi	r4,2
8112f918:	2421c83a 	sub	r16,r4,r16
8112f91c:	98c00615 	stw	r3,24(r19)
8112f920:	9c000415 	stw	r16,16(r19)
8112f924:	88001f1e 	bne	r17,zero,8112f9a4 <__d2b+0x110>
8112f928:	10bef384 	addi	r2,r2,-1074
8112f92c:	90800015 	stw	r2,0(r18)
8112f930:	00900034 	movhi	r2,16384
8112f934:	10bfffc4 	addi	r2,r2,-1
8112f938:	8085883a 	add	r2,r16,r2
8112f93c:	1085883a 	add	r2,r2,r2
8112f940:	1085883a 	add	r2,r2,r2
8112f944:	9885883a 	add	r2,r19,r2
8112f948:	11000517 	ldw	r4,20(r2)
8112f94c:	8020917a 	slli	r16,r16,5
8112f950:	112eec40 	call	8112eec4 <__hi0bits>
8112f954:	d8c00817 	ldw	r3,32(sp)
8112f958:	8085c83a 	sub	r2,r16,r2
8112f95c:	18800015 	stw	r2,0(r3)
8112f960:	9805883a 	mov	r2,r19
8112f964:	dfc00717 	ldw	ra,28(sp)
8112f968:	dd000617 	ldw	r20,24(sp)
8112f96c:	dcc00517 	ldw	r19,20(sp)
8112f970:	dc800417 	ldw	r18,16(sp)
8112f974:	dc400317 	ldw	r17,12(sp)
8112f978:	dc000217 	ldw	r16,8(sp)
8112f97c:	dec00804 	addi	sp,sp,32
8112f980:	f800283a 	ret
8112f984:	d809883a 	mov	r4,sp
8112f988:	112ef2c0 	call	8112ef2c <__lo0bits>
8112f98c:	d8c00017 	ldw	r3,0(sp)
8112f990:	04000044 	movi	r16,1
8112f994:	9c000415 	stw	r16,16(r19)
8112f998:	98c00515 	stw	r3,20(r19)
8112f99c:	10800804 	addi	r2,r2,32
8112f9a0:	883fe126 	beq	r17,zero,8112f928 <__reset+0xfb10f928>
8112f9a4:	00c00d44 	movi	r3,53
8112f9a8:	8c7ef344 	addi	r17,r17,-1075
8112f9ac:	88a3883a 	add	r17,r17,r2
8112f9b0:	1885c83a 	sub	r2,r3,r2
8112f9b4:	d8c00817 	ldw	r3,32(sp)
8112f9b8:	94400015 	stw	r17,0(r18)
8112f9bc:	18800015 	stw	r2,0(r3)
8112f9c0:	003fe706 	br	8112f960 <__reset+0xfb10f960>
8112f9c4:	01000804 	movi	r4,32
8112f9c8:	2089c83a 	sub	r4,r4,r2
8112f9cc:	1908983a 	sll	r4,r3,r4
8112f9d0:	d9400117 	ldw	r5,4(sp)
8112f9d4:	1886d83a 	srl	r3,r3,r2
8112f9d8:	2148b03a 	or	r4,r4,r5
8112f9dc:	99000515 	stw	r4,20(r19)
8112f9e0:	d8c00015 	stw	r3,0(sp)
8112f9e4:	003fca06 	br	8112f910 <__reset+0xfb10f910>

8112f9e8 <__ratio>:
8112f9e8:	defff904 	addi	sp,sp,-28
8112f9ec:	de00012e 	bgeu	sp,et,8112f9f4 <__ratio+0xc>
8112f9f0:	003b68fa 	trap	3
8112f9f4:	dc400315 	stw	r17,12(sp)
8112f9f8:	2823883a 	mov	r17,r5
8112f9fc:	d9400104 	addi	r5,sp,4
8112fa00:	dfc00615 	stw	ra,24(sp)
8112fa04:	dcc00515 	stw	r19,20(sp)
8112fa08:	dc800415 	stw	r18,16(sp)
8112fa0c:	2027883a 	mov	r19,r4
8112fa10:	dc000215 	stw	r16,8(sp)
8112fa14:	112f7800 	call	8112f780 <__b2d>
8112fa18:	d80b883a 	mov	r5,sp
8112fa1c:	8809883a 	mov	r4,r17
8112fa20:	1025883a 	mov	r18,r2
8112fa24:	1821883a 	mov	r16,r3
8112fa28:	112f7800 	call	8112f780 <__b2d>
8112fa2c:	8a000417 	ldw	r8,16(r17)
8112fa30:	99000417 	ldw	r4,16(r19)
8112fa34:	d9400117 	ldw	r5,4(sp)
8112fa38:	2209c83a 	sub	r4,r4,r8
8112fa3c:	2010917a 	slli	r8,r4,5
8112fa40:	d9000017 	ldw	r4,0(sp)
8112fa44:	2909c83a 	sub	r4,r5,r4
8112fa48:	4109883a 	add	r4,r8,r4
8112fa4c:	01000e0e 	bge	zero,r4,8112fa88 <__ratio+0xa0>
8112fa50:	2008953a 	slli	r4,r4,20
8112fa54:	2421883a 	add	r16,r4,r16
8112fa58:	100d883a 	mov	r6,r2
8112fa5c:	180f883a 	mov	r7,r3
8112fa60:	9009883a 	mov	r4,r18
8112fa64:	800b883a 	mov	r5,r16
8112fa68:	11377780 	call	81137778 <__divdf3>
8112fa6c:	dfc00617 	ldw	ra,24(sp)
8112fa70:	dcc00517 	ldw	r19,20(sp)
8112fa74:	dc800417 	ldw	r18,16(sp)
8112fa78:	dc400317 	ldw	r17,12(sp)
8112fa7c:	dc000217 	ldw	r16,8(sp)
8112fa80:	dec00704 	addi	sp,sp,28
8112fa84:	f800283a 	ret
8112fa88:	2008953a 	slli	r4,r4,20
8112fa8c:	1907c83a 	sub	r3,r3,r4
8112fa90:	003ff106 	br	8112fa58 <__reset+0xfb10fa58>

8112fa94 <_mprec_log10>:
8112fa94:	defffe04 	addi	sp,sp,-8
8112fa98:	de00012e 	bgeu	sp,et,8112faa0 <_mprec_log10+0xc>
8112fa9c:	003b68fa 	trap	3
8112faa0:	008005c4 	movi	r2,23
8112faa4:	dc000015 	stw	r16,0(sp)
8112faa8:	dfc00115 	stw	ra,4(sp)
8112faac:	2021883a 	mov	r16,r4
8112fab0:	11000d0e 	bge	r2,r4,8112fae8 <_mprec_log10+0x54>
8112fab4:	0005883a 	mov	r2,zero
8112fab8:	00cffc34 	movhi	r3,16368
8112fabc:	843fffc4 	addi	r16,r16,-1
8112fac0:	000d883a 	mov	r6,zero
8112fac4:	01d00934 	movhi	r7,16420
8112fac8:	1009883a 	mov	r4,r2
8112facc:	180b883a 	mov	r5,r3
8112fad0:	11220300 	call	81122030 <__muldf3>
8112fad4:	803ff91e 	bne	r16,zero,8112fabc <__reset+0xfb10fabc>
8112fad8:	dfc00117 	ldw	ra,4(sp)
8112fadc:	dc000017 	ldw	r16,0(sp)
8112fae0:	dec00204 	addi	sp,sp,8
8112fae4:	f800283a 	ret
8112fae8:	202090fa 	slli	r16,r4,3
8112faec:	00a04574 	movhi	r2,33045
8112faf0:	108acd04 	addi	r2,r2,11060
8112faf4:	1421883a 	add	r16,r2,r16
8112faf8:	80800017 	ldw	r2,0(r16)
8112fafc:	80c00117 	ldw	r3,4(r16)
8112fb00:	dfc00117 	ldw	ra,4(sp)
8112fb04:	dc000017 	ldw	r16,0(sp)
8112fb08:	dec00204 	addi	sp,sp,8
8112fb0c:	f800283a 	ret

8112fb10 <__copybits>:
8112fb10:	297fffc4 	addi	r5,r5,-1
8112fb14:	280fd17a 	srai	r7,r5,5
8112fb18:	30c00417 	ldw	r3,16(r6)
8112fb1c:	30800504 	addi	r2,r6,20
8112fb20:	39c00044 	addi	r7,r7,1
8112fb24:	18c7883a 	add	r3,r3,r3
8112fb28:	39cf883a 	add	r7,r7,r7
8112fb2c:	18c7883a 	add	r3,r3,r3
8112fb30:	39cf883a 	add	r7,r7,r7
8112fb34:	10c7883a 	add	r3,r2,r3
8112fb38:	21cf883a 	add	r7,r4,r7
8112fb3c:	10c00d2e 	bgeu	r2,r3,8112fb74 <__copybits+0x64>
8112fb40:	200b883a 	mov	r5,r4
8112fb44:	12000017 	ldw	r8,0(r2)
8112fb48:	29400104 	addi	r5,r5,4
8112fb4c:	10800104 	addi	r2,r2,4
8112fb50:	2a3fff15 	stw	r8,-4(r5)
8112fb54:	10fffb36 	bltu	r2,r3,8112fb44 <__reset+0xfb10fb44>
8112fb58:	1985c83a 	sub	r2,r3,r6
8112fb5c:	10bffac4 	addi	r2,r2,-21
8112fb60:	1004d0ba 	srli	r2,r2,2
8112fb64:	10800044 	addi	r2,r2,1
8112fb68:	1085883a 	add	r2,r2,r2
8112fb6c:	1085883a 	add	r2,r2,r2
8112fb70:	2089883a 	add	r4,r4,r2
8112fb74:	21c0032e 	bgeu	r4,r7,8112fb84 <__copybits+0x74>
8112fb78:	20000015 	stw	zero,0(r4)
8112fb7c:	21000104 	addi	r4,r4,4
8112fb80:	21fffd36 	bltu	r4,r7,8112fb78 <__reset+0xfb10fb78>
8112fb84:	f800283a 	ret

8112fb88 <__any_on>:
8112fb88:	20c00417 	ldw	r3,16(r4)
8112fb8c:	2805d17a 	srai	r2,r5,5
8112fb90:	21000504 	addi	r4,r4,20
8112fb94:	18800d0e 	bge	r3,r2,8112fbcc <__any_on+0x44>
8112fb98:	18c7883a 	add	r3,r3,r3
8112fb9c:	18c7883a 	add	r3,r3,r3
8112fba0:	20c7883a 	add	r3,r4,r3
8112fba4:	20c0192e 	bgeu	r4,r3,8112fc0c <__any_on+0x84>
8112fba8:	18bfff17 	ldw	r2,-4(r3)
8112fbac:	18ffff04 	addi	r3,r3,-4
8112fbb0:	1000041e 	bne	r2,zero,8112fbc4 <__any_on+0x3c>
8112fbb4:	20c0142e 	bgeu	r4,r3,8112fc08 <__any_on+0x80>
8112fbb8:	18ffff04 	addi	r3,r3,-4
8112fbbc:	19400017 	ldw	r5,0(r3)
8112fbc0:	283ffc26 	beq	r5,zero,8112fbb4 <__reset+0xfb10fbb4>
8112fbc4:	00800044 	movi	r2,1
8112fbc8:	f800283a 	ret
8112fbcc:	10c00a0e 	bge	r2,r3,8112fbf8 <__any_on+0x70>
8112fbd0:	1085883a 	add	r2,r2,r2
8112fbd4:	1085883a 	add	r2,r2,r2
8112fbd8:	294007cc 	andi	r5,r5,31
8112fbdc:	2087883a 	add	r3,r4,r2
8112fbe0:	283ff026 	beq	r5,zero,8112fba4 <__reset+0xfb10fba4>
8112fbe4:	19800017 	ldw	r6,0(r3)
8112fbe8:	3144d83a 	srl	r2,r6,r5
8112fbec:	114a983a 	sll	r5,r2,r5
8112fbf0:	317ff41e 	bne	r6,r5,8112fbc4 <__reset+0xfb10fbc4>
8112fbf4:	003feb06 	br	8112fba4 <__reset+0xfb10fba4>
8112fbf8:	1085883a 	add	r2,r2,r2
8112fbfc:	1085883a 	add	r2,r2,r2
8112fc00:	2087883a 	add	r3,r4,r2
8112fc04:	003fe706 	br	8112fba4 <__reset+0xfb10fba4>
8112fc08:	f800283a 	ret
8112fc0c:	0005883a 	mov	r2,zero
8112fc10:	f800283a 	ret

8112fc14 <_read_r>:
8112fc14:	defffd04 	addi	sp,sp,-12
8112fc18:	de00012e 	bgeu	sp,et,8112fc20 <_read_r+0xc>
8112fc1c:	003b68fa 	trap	3
8112fc20:	2805883a 	mov	r2,r5
8112fc24:	dc000015 	stw	r16,0(sp)
8112fc28:	04204574 	movhi	r16,33045
8112fc2c:	dc400115 	stw	r17,4(sp)
8112fc30:	300b883a 	mov	r5,r6
8112fc34:	8414cf04 	addi	r16,r16,21308
8112fc38:	2023883a 	mov	r17,r4
8112fc3c:	380d883a 	mov	r6,r7
8112fc40:	1009883a 	mov	r4,r2
8112fc44:	dfc00215 	stw	ra,8(sp)
8112fc48:	80000015 	stw	zero,0(r16)
8112fc4c:	11398e80 	call	811398e8 <read>
8112fc50:	00ffffc4 	movi	r3,-1
8112fc54:	10c00526 	beq	r2,r3,8112fc6c <_read_r+0x58>
8112fc58:	dfc00217 	ldw	ra,8(sp)
8112fc5c:	dc400117 	ldw	r17,4(sp)
8112fc60:	dc000017 	ldw	r16,0(sp)
8112fc64:	dec00304 	addi	sp,sp,12
8112fc68:	f800283a 	ret
8112fc6c:	80c00017 	ldw	r3,0(r16)
8112fc70:	183ff926 	beq	r3,zero,8112fc58 <__reset+0xfb10fc58>
8112fc74:	88c00015 	stw	r3,0(r17)
8112fc78:	003ff706 	br	8112fc58 <__reset+0xfb10fc58>

8112fc7c <_realloc_r>:
8112fc7c:	defff604 	addi	sp,sp,-40
8112fc80:	de00012e 	bgeu	sp,et,8112fc88 <_realloc_r+0xc>
8112fc84:	003b68fa 	trap	3
8112fc88:	dc800215 	stw	r18,8(sp)
8112fc8c:	dfc00915 	stw	ra,36(sp)
8112fc90:	df000815 	stw	fp,32(sp)
8112fc94:	ddc00715 	stw	r23,28(sp)
8112fc98:	dd800615 	stw	r22,24(sp)
8112fc9c:	dd400515 	stw	r21,20(sp)
8112fca0:	dd000415 	stw	r20,16(sp)
8112fca4:	dcc00315 	stw	r19,12(sp)
8112fca8:	dc400115 	stw	r17,4(sp)
8112fcac:	dc000015 	stw	r16,0(sp)
8112fcb0:	3025883a 	mov	r18,r6
8112fcb4:	2800b726 	beq	r5,zero,8112ff94 <_realloc_r+0x318>
8112fcb8:	282b883a 	mov	r21,r5
8112fcbc:	2029883a 	mov	r20,r4
8112fcc0:	113a0c80 	call	8113a0c8 <__malloc_lock>
8112fcc4:	a8bfff17 	ldw	r2,-4(r21)
8112fcc8:	043fff04 	movi	r16,-4
8112fccc:	90c002c4 	addi	r3,r18,11
8112fcd0:	01000584 	movi	r4,22
8112fcd4:	acfffe04 	addi	r19,r21,-8
8112fcd8:	1420703a 	and	r16,r2,r16
8112fcdc:	20c0332e 	bgeu	r4,r3,8112fdac <_realloc_r+0x130>
8112fce0:	047ffe04 	movi	r17,-8
8112fce4:	1c62703a 	and	r17,r3,r17
8112fce8:	8807883a 	mov	r3,r17
8112fcec:	88005816 	blt	r17,zero,8112fe50 <_realloc_r+0x1d4>
8112fcf0:	8c805736 	bltu	r17,r18,8112fe50 <_realloc_r+0x1d4>
8112fcf4:	80c0300e 	bge	r16,r3,8112fdb8 <_realloc_r+0x13c>
8112fcf8:	07204574 	movhi	fp,33045
8112fcfc:	e70e1a04 	addi	fp,fp,14440
8112fd00:	e1c00217 	ldw	r7,8(fp)
8112fd04:	9c09883a 	add	r4,r19,r16
8112fd08:	22000117 	ldw	r8,4(r4)
8112fd0c:	21c06326 	beq	r4,r7,8112fe9c <_realloc_r+0x220>
8112fd10:	017fff84 	movi	r5,-2
8112fd14:	414a703a 	and	r5,r8,r5
8112fd18:	214b883a 	add	r5,r4,r5
8112fd1c:	29800117 	ldw	r6,4(r5)
8112fd20:	3180004c 	andi	r6,r6,1
8112fd24:	30003f26 	beq	r6,zero,8112fe24 <_realloc_r+0x1a8>
8112fd28:	1080004c 	andi	r2,r2,1
8112fd2c:	10008326 	beq	r2,zero,8112ff3c <_realloc_r+0x2c0>
8112fd30:	900b883a 	mov	r5,r18
8112fd34:	a009883a 	mov	r4,r20
8112fd38:	1123eec0 	call	81123eec <_malloc_r>
8112fd3c:	1025883a 	mov	r18,r2
8112fd40:	10011e26 	beq	r2,zero,811301bc <_realloc_r+0x540>
8112fd44:	a93fff17 	ldw	r4,-4(r21)
8112fd48:	10fffe04 	addi	r3,r2,-8
8112fd4c:	00bfff84 	movi	r2,-2
8112fd50:	2084703a 	and	r2,r4,r2
8112fd54:	9885883a 	add	r2,r19,r2
8112fd58:	1880ee26 	beq	r3,r2,81130114 <_realloc_r+0x498>
8112fd5c:	81bfff04 	addi	r6,r16,-4
8112fd60:	00800904 	movi	r2,36
8112fd64:	1180b836 	bltu	r2,r6,81130048 <_realloc_r+0x3cc>
8112fd68:	00c004c4 	movi	r3,19
8112fd6c:	19809636 	bltu	r3,r6,8112ffc8 <_realloc_r+0x34c>
8112fd70:	9005883a 	mov	r2,r18
8112fd74:	a807883a 	mov	r3,r21
8112fd78:	19000017 	ldw	r4,0(r3)
8112fd7c:	11000015 	stw	r4,0(r2)
8112fd80:	19000117 	ldw	r4,4(r3)
8112fd84:	11000115 	stw	r4,4(r2)
8112fd88:	18c00217 	ldw	r3,8(r3)
8112fd8c:	10c00215 	stw	r3,8(r2)
8112fd90:	a80b883a 	mov	r5,r21
8112fd94:	a009883a 	mov	r4,r20
8112fd98:	112dbe80 	call	8112dbe8 <_free_r>
8112fd9c:	a009883a 	mov	r4,r20
8112fda0:	113a1f00 	call	8113a1f0 <__malloc_unlock>
8112fda4:	9005883a 	mov	r2,r18
8112fda8:	00001206 	br	8112fdf4 <_realloc_r+0x178>
8112fdac:	00c00404 	movi	r3,16
8112fdb0:	1823883a 	mov	r17,r3
8112fdb4:	003fce06 	br	8112fcf0 <__reset+0xfb10fcf0>
8112fdb8:	a825883a 	mov	r18,r21
8112fdbc:	8445c83a 	sub	r2,r16,r17
8112fdc0:	00c003c4 	movi	r3,15
8112fdc4:	18802636 	bltu	r3,r2,8112fe60 <_realloc_r+0x1e4>
8112fdc8:	99800117 	ldw	r6,4(r19)
8112fdcc:	9c07883a 	add	r3,r19,r16
8112fdd0:	3180004c 	andi	r6,r6,1
8112fdd4:	3420b03a 	or	r16,r6,r16
8112fdd8:	9c000115 	stw	r16,4(r19)
8112fddc:	18800117 	ldw	r2,4(r3)
8112fde0:	10800054 	ori	r2,r2,1
8112fde4:	18800115 	stw	r2,4(r3)
8112fde8:	a009883a 	mov	r4,r20
8112fdec:	113a1f00 	call	8113a1f0 <__malloc_unlock>
8112fdf0:	9005883a 	mov	r2,r18
8112fdf4:	dfc00917 	ldw	ra,36(sp)
8112fdf8:	df000817 	ldw	fp,32(sp)
8112fdfc:	ddc00717 	ldw	r23,28(sp)
8112fe00:	dd800617 	ldw	r22,24(sp)
8112fe04:	dd400517 	ldw	r21,20(sp)
8112fe08:	dd000417 	ldw	r20,16(sp)
8112fe0c:	dcc00317 	ldw	r19,12(sp)
8112fe10:	dc800217 	ldw	r18,8(sp)
8112fe14:	dc400117 	ldw	r17,4(sp)
8112fe18:	dc000017 	ldw	r16,0(sp)
8112fe1c:	dec00a04 	addi	sp,sp,40
8112fe20:	f800283a 	ret
8112fe24:	017fff04 	movi	r5,-4
8112fe28:	414a703a 	and	r5,r8,r5
8112fe2c:	814d883a 	add	r6,r16,r5
8112fe30:	30c01f16 	blt	r6,r3,8112feb0 <_realloc_r+0x234>
8112fe34:	20800317 	ldw	r2,12(r4)
8112fe38:	20c00217 	ldw	r3,8(r4)
8112fe3c:	a825883a 	mov	r18,r21
8112fe40:	3021883a 	mov	r16,r6
8112fe44:	18800315 	stw	r2,12(r3)
8112fe48:	10c00215 	stw	r3,8(r2)
8112fe4c:	003fdb06 	br	8112fdbc <__reset+0xfb10fdbc>
8112fe50:	00800304 	movi	r2,12
8112fe54:	a0800015 	stw	r2,0(r20)
8112fe58:	0005883a 	mov	r2,zero
8112fe5c:	003fe506 	br	8112fdf4 <__reset+0xfb10fdf4>
8112fe60:	98c00117 	ldw	r3,4(r19)
8112fe64:	9c4b883a 	add	r5,r19,r17
8112fe68:	11000054 	ori	r4,r2,1
8112fe6c:	18c0004c 	andi	r3,r3,1
8112fe70:	1c62b03a 	or	r17,r3,r17
8112fe74:	9c400115 	stw	r17,4(r19)
8112fe78:	29000115 	stw	r4,4(r5)
8112fe7c:	2885883a 	add	r2,r5,r2
8112fe80:	10c00117 	ldw	r3,4(r2)
8112fe84:	29400204 	addi	r5,r5,8
8112fe88:	a009883a 	mov	r4,r20
8112fe8c:	18c00054 	ori	r3,r3,1
8112fe90:	10c00115 	stw	r3,4(r2)
8112fe94:	112dbe80 	call	8112dbe8 <_free_r>
8112fe98:	003fd306 	br	8112fde8 <__reset+0xfb10fde8>
8112fe9c:	017fff04 	movi	r5,-4
8112fea0:	414a703a 	and	r5,r8,r5
8112fea4:	89800404 	addi	r6,r17,16
8112fea8:	8151883a 	add	r8,r16,r5
8112feac:	4180590e 	bge	r8,r6,81130014 <_realloc_r+0x398>
8112feb0:	1080004c 	andi	r2,r2,1
8112feb4:	103f9e1e 	bne	r2,zero,8112fd30 <__reset+0xfb10fd30>
8112feb8:	adbffe17 	ldw	r22,-8(r21)
8112febc:	00bfff04 	movi	r2,-4
8112fec0:	9dadc83a 	sub	r22,r19,r22
8112fec4:	b1800117 	ldw	r6,4(r22)
8112fec8:	3084703a 	and	r2,r6,r2
8112fecc:	20002026 	beq	r4,zero,8112ff50 <_realloc_r+0x2d4>
8112fed0:	80af883a 	add	r23,r16,r2
8112fed4:	b96f883a 	add	r23,r23,r5
8112fed8:	21c05f26 	beq	r4,r7,81130058 <_realloc_r+0x3dc>
8112fedc:	b8c01c16 	blt	r23,r3,8112ff50 <_realloc_r+0x2d4>
8112fee0:	20800317 	ldw	r2,12(r4)
8112fee4:	20c00217 	ldw	r3,8(r4)
8112fee8:	81bfff04 	addi	r6,r16,-4
8112feec:	01000904 	movi	r4,36
8112fef0:	18800315 	stw	r2,12(r3)
8112fef4:	10c00215 	stw	r3,8(r2)
8112fef8:	b0c00217 	ldw	r3,8(r22)
8112fefc:	b0800317 	ldw	r2,12(r22)
8112ff00:	b4800204 	addi	r18,r22,8
8112ff04:	18800315 	stw	r2,12(r3)
8112ff08:	10c00215 	stw	r3,8(r2)
8112ff0c:	21801b36 	bltu	r4,r6,8112ff7c <_realloc_r+0x300>
8112ff10:	008004c4 	movi	r2,19
8112ff14:	1180352e 	bgeu	r2,r6,8112ffec <_realloc_r+0x370>
8112ff18:	a8800017 	ldw	r2,0(r21)
8112ff1c:	b0800215 	stw	r2,8(r22)
8112ff20:	a8800117 	ldw	r2,4(r21)
8112ff24:	b0800315 	stw	r2,12(r22)
8112ff28:	008006c4 	movi	r2,27
8112ff2c:	11807f36 	bltu	r2,r6,8113012c <_realloc_r+0x4b0>
8112ff30:	b0800404 	addi	r2,r22,16
8112ff34:	ad400204 	addi	r21,r21,8
8112ff38:	00002d06 	br	8112fff0 <_realloc_r+0x374>
8112ff3c:	adbffe17 	ldw	r22,-8(r21)
8112ff40:	00bfff04 	movi	r2,-4
8112ff44:	9dadc83a 	sub	r22,r19,r22
8112ff48:	b1000117 	ldw	r4,4(r22)
8112ff4c:	2084703a 	and	r2,r4,r2
8112ff50:	b03f7726 	beq	r22,zero,8112fd30 <__reset+0xfb10fd30>
8112ff54:	80af883a 	add	r23,r16,r2
8112ff58:	b8ff7516 	blt	r23,r3,8112fd30 <__reset+0xfb10fd30>
8112ff5c:	b0800317 	ldw	r2,12(r22)
8112ff60:	b0c00217 	ldw	r3,8(r22)
8112ff64:	81bfff04 	addi	r6,r16,-4
8112ff68:	01000904 	movi	r4,36
8112ff6c:	18800315 	stw	r2,12(r3)
8112ff70:	10c00215 	stw	r3,8(r2)
8112ff74:	b4800204 	addi	r18,r22,8
8112ff78:	21bfe52e 	bgeu	r4,r6,8112ff10 <__reset+0xfb10ff10>
8112ff7c:	a80b883a 	mov	r5,r21
8112ff80:	9009883a 	mov	r4,r18
8112ff84:	112ea5c0 	call	8112ea5c <memmove>
8112ff88:	b821883a 	mov	r16,r23
8112ff8c:	b027883a 	mov	r19,r22
8112ff90:	003f8a06 	br	8112fdbc <__reset+0xfb10fdbc>
8112ff94:	300b883a 	mov	r5,r6
8112ff98:	dfc00917 	ldw	ra,36(sp)
8112ff9c:	df000817 	ldw	fp,32(sp)
8112ffa0:	ddc00717 	ldw	r23,28(sp)
8112ffa4:	dd800617 	ldw	r22,24(sp)
8112ffa8:	dd400517 	ldw	r21,20(sp)
8112ffac:	dd000417 	ldw	r20,16(sp)
8112ffb0:	dcc00317 	ldw	r19,12(sp)
8112ffb4:	dc800217 	ldw	r18,8(sp)
8112ffb8:	dc400117 	ldw	r17,4(sp)
8112ffbc:	dc000017 	ldw	r16,0(sp)
8112ffc0:	dec00a04 	addi	sp,sp,40
8112ffc4:	1123eec1 	jmpi	81123eec <_malloc_r>
8112ffc8:	a8c00017 	ldw	r3,0(r21)
8112ffcc:	90c00015 	stw	r3,0(r18)
8112ffd0:	a8c00117 	ldw	r3,4(r21)
8112ffd4:	90c00115 	stw	r3,4(r18)
8112ffd8:	00c006c4 	movi	r3,27
8112ffdc:	19804536 	bltu	r3,r6,811300f4 <_realloc_r+0x478>
8112ffe0:	90800204 	addi	r2,r18,8
8112ffe4:	a8c00204 	addi	r3,r21,8
8112ffe8:	003f6306 	br	8112fd78 <__reset+0xfb10fd78>
8112ffec:	9005883a 	mov	r2,r18
8112fff0:	a8c00017 	ldw	r3,0(r21)
8112fff4:	b821883a 	mov	r16,r23
8112fff8:	b027883a 	mov	r19,r22
8112fffc:	10c00015 	stw	r3,0(r2)
81130000:	a8c00117 	ldw	r3,4(r21)
81130004:	10c00115 	stw	r3,4(r2)
81130008:	a8c00217 	ldw	r3,8(r21)
8113000c:	10c00215 	stw	r3,8(r2)
81130010:	003f6a06 	br	8112fdbc <__reset+0xfb10fdbc>
81130014:	9c67883a 	add	r19,r19,r17
81130018:	4445c83a 	sub	r2,r8,r17
8113001c:	e4c00215 	stw	r19,8(fp)
81130020:	10800054 	ori	r2,r2,1
81130024:	98800115 	stw	r2,4(r19)
81130028:	a8bfff17 	ldw	r2,-4(r21)
8113002c:	a009883a 	mov	r4,r20
81130030:	1080004c 	andi	r2,r2,1
81130034:	1462b03a 	or	r17,r2,r17
81130038:	ac7fff15 	stw	r17,-4(r21)
8113003c:	113a1f00 	call	8113a1f0 <__malloc_unlock>
81130040:	a805883a 	mov	r2,r21
81130044:	003f6b06 	br	8112fdf4 <__reset+0xfb10fdf4>
81130048:	a80b883a 	mov	r5,r21
8113004c:	9009883a 	mov	r4,r18
81130050:	112ea5c0 	call	8112ea5c <memmove>
81130054:	003f4e06 	br	8112fd90 <__reset+0xfb10fd90>
81130058:	89000404 	addi	r4,r17,16
8113005c:	b93fbc16 	blt	r23,r4,8112ff50 <__reset+0xfb10ff50>
81130060:	b0800317 	ldw	r2,12(r22)
81130064:	b0c00217 	ldw	r3,8(r22)
81130068:	81bfff04 	addi	r6,r16,-4
8113006c:	01000904 	movi	r4,36
81130070:	18800315 	stw	r2,12(r3)
81130074:	10c00215 	stw	r3,8(r2)
81130078:	b4800204 	addi	r18,r22,8
8113007c:	21804336 	bltu	r4,r6,8113018c <_realloc_r+0x510>
81130080:	008004c4 	movi	r2,19
81130084:	11803f2e 	bgeu	r2,r6,81130184 <_realloc_r+0x508>
81130088:	a8800017 	ldw	r2,0(r21)
8113008c:	b0800215 	stw	r2,8(r22)
81130090:	a8800117 	ldw	r2,4(r21)
81130094:	b0800315 	stw	r2,12(r22)
81130098:	008006c4 	movi	r2,27
8113009c:	11803f36 	bltu	r2,r6,8113019c <_realloc_r+0x520>
811300a0:	b0800404 	addi	r2,r22,16
811300a4:	ad400204 	addi	r21,r21,8
811300a8:	a8c00017 	ldw	r3,0(r21)
811300ac:	10c00015 	stw	r3,0(r2)
811300b0:	a8c00117 	ldw	r3,4(r21)
811300b4:	10c00115 	stw	r3,4(r2)
811300b8:	a8c00217 	ldw	r3,8(r21)
811300bc:	10c00215 	stw	r3,8(r2)
811300c0:	b447883a 	add	r3,r22,r17
811300c4:	bc45c83a 	sub	r2,r23,r17
811300c8:	e0c00215 	stw	r3,8(fp)
811300cc:	10800054 	ori	r2,r2,1
811300d0:	18800115 	stw	r2,4(r3)
811300d4:	b0800117 	ldw	r2,4(r22)
811300d8:	a009883a 	mov	r4,r20
811300dc:	1080004c 	andi	r2,r2,1
811300e0:	1462b03a 	or	r17,r2,r17
811300e4:	b4400115 	stw	r17,4(r22)
811300e8:	113a1f00 	call	8113a1f0 <__malloc_unlock>
811300ec:	9005883a 	mov	r2,r18
811300f0:	003f4006 	br	8112fdf4 <__reset+0xfb10fdf4>
811300f4:	a8c00217 	ldw	r3,8(r21)
811300f8:	90c00215 	stw	r3,8(r18)
811300fc:	a8c00317 	ldw	r3,12(r21)
81130100:	90c00315 	stw	r3,12(r18)
81130104:	30801126 	beq	r6,r2,8113014c <_realloc_r+0x4d0>
81130108:	90800404 	addi	r2,r18,16
8113010c:	a8c00404 	addi	r3,r21,16
81130110:	003f1906 	br	8112fd78 <__reset+0xfb10fd78>
81130114:	90ffff17 	ldw	r3,-4(r18)
81130118:	00bfff04 	movi	r2,-4
8113011c:	a825883a 	mov	r18,r21
81130120:	1884703a 	and	r2,r3,r2
81130124:	80a1883a 	add	r16,r16,r2
81130128:	003f2406 	br	8112fdbc <__reset+0xfb10fdbc>
8113012c:	a8800217 	ldw	r2,8(r21)
81130130:	b0800415 	stw	r2,16(r22)
81130134:	a8800317 	ldw	r2,12(r21)
81130138:	b0800515 	stw	r2,20(r22)
8113013c:	31000a26 	beq	r6,r4,81130168 <_realloc_r+0x4ec>
81130140:	b0800604 	addi	r2,r22,24
81130144:	ad400404 	addi	r21,r21,16
81130148:	003fa906 	br	8112fff0 <__reset+0xfb10fff0>
8113014c:	a9000417 	ldw	r4,16(r21)
81130150:	90800604 	addi	r2,r18,24
81130154:	a8c00604 	addi	r3,r21,24
81130158:	91000415 	stw	r4,16(r18)
8113015c:	a9000517 	ldw	r4,20(r21)
81130160:	91000515 	stw	r4,20(r18)
81130164:	003f0406 	br	8112fd78 <__reset+0xfb10fd78>
81130168:	a8c00417 	ldw	r3,16(r21)
8113016c:	ad400604 	addi	r21,r21,24
81130170:	b0800804 	addi	r2,r22,32
81130174:	b0c00615 	stw	r3,24(r22)
81130178:	a8ffff17 	ldw	r3,-4(r21)
8113017c:	b0c00715 	stw	r3,28(r22)
81130180:	003f9b06 	br	8112fff0 <__reset+0xfb10fff0>
81130184:	9005883a 	mov	r2,r18
81130188:	003fc706 	br	811300a8 <__reset+0xfb1100a8>
8113018c:	a80b883a 	mov	r5,r21
81130190:	9009883a 	mov	r4,r18
81130194:	112ea5c0 	call	8112ea5c <memmove>
81130198:	003fc906 	br	811300c0 <__reset+0xfb1100c0>
8113019c:	a8800217 	ldw	r2,8(r21)
811301a0:	b0800415 	stw	r2,16(r22)
811301a4:	a8800317 	ldw	r2,12(r21)
811301a8:	b0800515 	stw	r2,20(r22)
811301ac:	31000726 	beq	r6,r4,811301cc <_realloc_r+0x550>
811301b0:	b0800604 	addi	r2,r22,24
811301b4:	ad400404 	addi	r21,r21,16
811301b8:	003fbb06 	br	811300a8 <__reset+0xfb1100a8>
811301bc:	a009883a 	mov	r4,r20
811301c0:	113a1f00 	call	8113a1f0 <__malloc_unlock>
811301c4:	0005883a 	mov	r2,zero
811301c8:	003f0a06 	br	8112fdf4 <__reset+0xfb10fdf4>
811301cc:	a8c00417 	ldw	r3,16(r21)
811301d0:	ad400604 	addi	r21,r21,24
811301d4:	b0800804 	addi	r2,r22,32
811301d8:	b0c00615 	stw	r3,24(r22)
811301dc:	a8ffff17 	ldw	r3,-4(r21)
811301e0:	b0c00715 	stw	r3,28(r22)
811301e4:	003fb006 	br	811300a8 <__reset+0xfb1100a8>

811301e8 <__fpclassifyd>:
811301e8:	00a00034 	movhi	r2,32768
811301ec:	10bfffc4 	addi	r2,r2,-1
811301f0:	2884703a 	and	r2,r5,r2
811301f4:	10000726 	beq	r2,zero,81130214 <__fpclassifyd+0x2c>
811301f8:	00fffc34 	movhi	r3,65520
811301fc:	019ff834 	movhi	r6,32736
81130200:	28c7883a 	add	r3,r5,r3
81130204:	31bfffc4 	addi	r6,r6,-1
81130208:	30c00536 	bltu	r6,r3,81130220 <__fpclassifyd+0x38>
8113020c:	00800104 	movi	r2,4
81130210:	f800283a 	ret
81130214:	2000021e 	bne	r4,zero,81130220 <__fpclassifyd+0x38>
81130218:	00800084 	movi	r2,2
8113021c:	f800283a 	ret
81130220:	00dffc34 	movhi	r3,32752
81130224:	019ff834 	movhi	r6,32736
81130228:	28cb883a 	add	r5,r5,r3
8113022c:	31bfffc4 	addi	r6,r6,-1
81130230:	317ff62e 	bgeu	r6,r5,8113020c <__reset+0xfb11020c>
81130234:	01400434 	movhi	r5,16
81130238:	297fffc4 	addi	r5,r5,-1
8113023c:	28800236 	bltu	r5,r2,81130248 <__fpclassifyd+0x60>
81130240:	008000c4 	movi	r2,3
81130244:	f800283a 	ret
81130248:	10c00226 	beq	r2,r3,81130254 <__fpclassifyd+0x6c>
8113024c:	0005883a 	mov	r2,zero
81130250:	f800283a 	ret
81130254:	2005003a 	cmpeq	r2,r4,zero
81130258:	f800283a 	ret

8113025c <__sccl>:
8113025c:	2a000003 	ldbu	r8,0(r5)
81130260:	00801784 	movi	r2,94
81130264:	40802a26 	beq	r8,r2,81130310 <__sccl+0xb4>
81130268:	29400044 	addi	r5,r5,1
8113026c:	000f883a 	mov	r7,zero
81130270:	0013883a 	mov	r9,zero
81130274:	2007883a 	mov	r3,r4
81130278:	21804004 	addi	r6,r4,256
8113027c:	19c00005 	stb	r7,0(r3)
81130280:	18c00044 	addi	r3,r3,1
81130284:	19bffd1e 	bne	r3,r6,8113027c <__reset+0xfb11027c>
81130288:	40001126 	beq	r8,zero,811302d0 <__sccl+0x74>
8113028c:	00800044 	movi	r2,1
81130290:	124fc83a 	sub	r7,r2,r9
81130294:	02800b44 	movi	r10,45
81130298:	02c01744 	movi	r11,93
8113029c:	2205883a 	add	r2,r4,r8
811302a0:	11c00005 	stb	r7,0(r2)
811302a4:	28800044 	addi	r2,r5,1
811302a8:	28c00003 	ldbu	r3,0(r5)
811302ac:	1a800a26 	beq	r3,r10,811302d8 <__sccl+0x7c>
811302b0:	1ac00426 	beq	r3,r11,811302c4 <__sccl+0x68>
811302b4:	18000426 	beq	r3,zero,811302c8 <__sccl+0x6c>
811302b8:	1811883a 	mov	r8,r3
811302bc:	100b883a 	mov	r5,r2
811302c0:	003ff606 	br	8113029c <__reset+0xfb11029c>
811302c4:	f800283a 	ret
811302c8:	2805883a 	mov	r2,r5
811302cc:	f800283a 	ret
811302d0:	28bfffc4 	addi	r2,r5,-1
811302d4:	f800283a 	ret
811302d8:	12400003 	ldbu	r9,0(r2)
811302dc:	4ac01126 	beq	r9,r11,81130324 <__sccl+0xc8>
811302e0:	4a001016 	blt	r9,r8,81130324 <__sccl+0xc8>
811302e4:	41800044 	addi	r6,r8,1
811302e8:	29400084 	addi	r5,r5,2
811302ec:	2187883a 	add	r3,r4,r6
811302f0:	00000106 	br	811302f8 <__sccl+0x9c>
811302f4:	31800044 	addi	r6,r6,1
811302f8:	19c00005 	stb	r7,0(r3)
811302fc:	3011883a 	mov	r8,r6
81130300:	18c00044 	addi	r3,r3,1
81130304:	327ffb16 	blt	r6,r9,811302f4 <__reset+0xfb1102f4>
81130308:	10800084 	addi	r2,r2,2
8113030c:	003fe606 	br	811302a8 <__reset+0xfb1102a8>
81130310:	2a000043 	ldbu	r8,1(r5)
81130314:	01c00044 	movi	r7,1
81130318:	29400084 	addi	r5,r5,2
8113031c:	02400044 	movi	r9,1
81130320:	003fd406 	br	81130274 <__reset+0xfb110274>
81130324:	5011883a 	mov	r8,r10
81130328:	003fe406 	br	811302bc <__reset+0xfb1102bc>

8113032c <nanf>:
8113032c:	009ff034 	movhi	r2,32704
81130330:	f800283a 	ret

81130334 <strcmp>:
81130334:	2144b03a 	or	r2,r4,r5
81130338:	108000cc 	andi	r2,r2,3
8113033c:	1000171e 	bne	r2,zero,8113039c <strcmp+0x68>
81130340:	20800017 	ldw	r2,0(r4)
81130344:	28c00017 	ldw	r3,0(r5)
81130348:	10c0141e 	bne	r2,r3,8113039c <strcmp+0x68>
8113034c:	027fbff4 	movhi	r9,65279
81130350:	4a7fbfc4 	addi	r9,r9,-257
81130354:	0086303a 	nor	r3,zero,r2
81130358:	02202074 	movhi	r8,32897
8113035c:	1245883a 	add	r2,r2,r9
81130360:	42202004 	addi	r8,r8,-32640
81130364:	10c4703a 	and	r2,r2,r3
81130368:	1204703a 	and	r2,r2,r8
8113036c:	10000226 	beq	r2,zero,81130378 <strcmp+0x44>
81130370:	00002306 	br	81130400 <strcmp+0xcc>
81130374:	1000221e 	bne	r2,zero,81130400 <strcmp+0xcc>
81130378:	21000104 	addi	r4,r4,4
8113037c:	20c00017 	ldw	r3,0(r4)
81130380:	29400104 	addi	r5,r5,4
81130384:	29800017 	ldw	r6,0(r5)
81130388:	1a4f883a 	add	r7,r3,r9
8113038c:	00c4303a 	nor	r2,zero,r3
81130390:	3884703a 	and	r2,r7,r2
81130394:	1204703a 	and	r2,r2,r8
81130398:	19bff626 	beq	r3,r6,81130374 <__reset+0xfb110374>
8113039c:	20800003 	ldbu	r2,0(r4)
811303a0:	10c03fcc 	andi	r3,r2,255
811303a4:	18c0201c 	xori	r3,r3,128
811303a8:	18ffe004 	addi	r3,r3,-128
811303ac:	18000c26 	beq	r3,zero,811303e0 <strcmp+0xac>
811303b0:	29800007 	ldb	r6,0(r5)
811303b4:	19800326 	beq	r3,r6,811303c4 <strcmp+0x90>
811303b8:	00001306 	br	81130408 <strcmp+0xd4>
811303bc:	29800007 	ldb	r6,0(r5)
811303c0:	11800b1e 	bne	r2,r6,811303f0 <strcmp+0xbc>
811303c4:	21000044 	addi	r4,r4,1
811303c8:	20c00003 	ldbu	r3,0(r4)
811303cc:	29400044 	addi	r5,r5,1
811303d0:	18803fcc 	andi	r2,r3,255
811303d4:	1080201c 	xori	r2,r2,128
811303d8:	10bfe004 	addi	r2,r2,-128
811303dc:	103ff71e 	bne	r2,zero,811303bc <__reset+0xfb1103bc>
811303e0:	0007883a 	mov	r3,zero
811303e4:	28800003 	ldbu	r2,0(r5)
811303e8:	1885c83a 	sub	r2,r3,r2
811303ec:	f800283a 	ret
811303f0:	28800003 	ldbu	r2,0(r5)
811303f4:	18c03fcc 	andi	r3,r3,255
811303f8:	1885c83a 	sub	r2,r3,r2
811303fc:	f800283a 	ret
81130400:	0005883a 	mov	r2,zero
81130404:	f800283a 	ret
81130408:	10c03fcc 	andi	r3,r2,255
8113040c:	003ff506 	br	811303e4 <__reset+0xfb1103e4>

81130410 <sulp>:
81130410:	defffd04 	addi	sp,sp,-12
81130414:	de00012e 	bgeu	sp,et,8113041c <sulp+0xc>
81130418:	003b68fa 	trap	3
8113041c:	dc400115 	stw	r17,4(sp)
81130420:	3023883a 	mov	r17,r6
81130424:	dc000015 	stw	r16,0(sp)
81130428:	dfc00215 	stw	ra,8(sp)
8113042c:	2821883a 	mov	r16,r5
81130430:	112f71c0 	call	8112f71c <__ulp>
81130434:	88000c26 	beq	r17,zero,81130468 <sulp+0x58>
81130438:	841ffc2c 	andhi	r16,r16,32752
8113043c:	8020d53a 	srli	r16,r16,20
81130440:	01c01ac4 	movi	r7,107
81130444:	3c21c83a 	sub	r16,r7,r16
81130448:	0400070e 	bge	zero,r16,81130468 <sulp+0x58>
8113044c:	8020953a 	slli	r16,r16,20
81130450:	01cffc34 	movhi	r7,16368
81130454:	000d883a 	mov	r6,zero
81130458:	81cf883a 	add	r7,r16,r7
8113045c:	1009883a 	mov	r4,r2
81130460:	180b883a 	mov	r5,r3
81130464:	11220300 	call	81122030 <__muldf3>
81130468:	dfc00217 	ldw	ra,8(sp)
8113046c:	dc400117 	ldw	r17,4(sp)
81130470:	dc000017 	ldw	r16,0(sp)
81130474:	dec00304 	addi	sp,sp,12
81130478:	f800283a 	ret

8113047c <_strtod_r>:
8113047c:	deffe204 	addi	sp,sp,-120
81130480:	de00012e 	bgeu	sp,et,81130488 <_strtod_r+0xc>
81130484:	003b68fa 	trap	3
81130488:	ddc01b15 	stw	r23,108(sp)
8113048c:	dd001815 	stw	r20,96(sp)
81130490:	dc801615 	stw	r18,88(sp)
81130494:	dc401515 	stw	r17,84(sp)
81130498:	dc001415 	stw	r16,80(sp)
8113049c:	d9400615 	stw	r5,24(sp)
811304a0:	dfc01d15 	stw	ra,116(sp)
811304a4:	df001c15 	stw	fp,112(sp)
811304a8:	dd801a15 	stw	r22,104(sp)
811304ac:	dd401915 	stw	r21,100(sp)
811304b0:	dcc01715 	stw	r19,92(sp)
811304b4:	2021883a 	mov	r16,r4
811304b8:	d8000515 	stw	zero,20(sp)
811304bc:	2809883a 	mov	r4,r5
811304c0:	20800003 	ldbu	r2,0(r4)
811304c4:	01e044f4 	movhi	r7,33043
811304c8:	282f883a 	mov	r23,r5
811304cc:	10c03fcc 	andi	r3,r2,255
811304d0:	01400b44 	movi	r5,45
811304d4:	39c13e04 	addi	r7,r7,1272
811304d8:	3029883a 	mov	r20,r6
811304dc:	0025883a 	mov	r18,zero
811304e0:	0023883a 	mov	r17,zero
811304e4:	28c0ba36 	bltu	r5,r3,811307d0 <_strtod_r+0x354>
811304e8:	180690ba 	slli	r3,r3,2
811304ec:	19c7883a 	add	r3,r3,r7
811304f0:	18c00017 	ldw	r3,0(r3)
811304f4:	1800683a 	jmp	r3
811304f8:	811305b8 	rdprs	r4,r16,19478
811304fc:	811307d0 	cmplti	r4,r16,19487
81130500:	811307d0 	cmplti	r4,r16,19487
81130504:	811307d0 	cmplti	r4,r16,19487
81130508:	811307d0 	cmplti	r4,r16,19487
8113050c:	811307d0 	cmplti	r4,r16,19487
81130510:	811307d0 	cmplti	r4,r16,19487
81130514:	811307d0 	cmplti	r4,r16,19487
81130518:	811307d0 	cmplti	r4,r16,19487
8113051c:	811307bc 	xorhi	r4,r16,19486
81130520:	811307bc 	xorhi	r4,r16,19486
81130524:	811307bc 	xorhi	r4,r16,19486
81130528:	811307bc 	xorhi	r4,r16,19486
8113052c:	811307bc 	xorhi	r4,r16,19486
81130530:	811307d0 	cmplti	r4,r16,19487
81130534:	811307d0 	cmplti	r4,r16,19487
81130538:	811307d0 	cmplti	r4,r16,19487
8113053c:	811307d0 	cmplti	r4,r16,19487
81130540:	811307d0 	cmplti	r4,r16,19487
81130544:	811307d0 	cmplti	r4,r16,19487
81130548:	811307d0 	cmplti	r4,r16,19487
8113054c:	811307d0 	cmplti	r4,r16,19487
81130550:	811307d0 	cmplti	r4,r16,19487
81130554:	811307d0 	cmplti	r4,r16,19487
81130558:	811307d0 	cmplti	r4,r16,19487
8113055c:	811307d0 	cmplti	r4,r16,19487
81130560:	811307d0 	cmplti	r4,r16,19487
81130564:	811307d0 	cmplti	r4,r16,19487
81130568:	811307d0 	cmplti	r4,r16,19487
8113056c:	811307d0 	cmplti	r4,r16,19487
81130570:	811307d0 	cmplti	r4,r16,19487
81130574:	811307d0 	cmplti	r4,r16,19487
81130578:	811307bc 	xorhi	r4,r16,19486
8113057c:	811307d0 	cmplti	r4,r16,19487
81130580:	811307d0 	cmplti	r4,r16,19487
81130584:	811307d0 	cmplti	r4,r16,19487
81130588:	811307d0 	cmplti	r4,r16,19487
8113058c:	811307d0 	cmplti	r4,r16,19487
81130590:	811307d0 	cmplti	r4,r16,19487
81130594:	811307d0 	cmplti	r4,r16,19487
81130598:	811307d0 	cmplti	r4,r16,19487
8113059c:	811307d0 	cmplti	r4,r16,19487
811305a0:	811307d0 	cmplti	r4,r16,19487
811305a4:	81130610 	cmplti	r4,r16,19480
811305a8:	811307d0 	cmplti	r4,r16,19487
811305ac:	811307b0 	cmpltui	r4,r16,19486
811305b0:	00801244 	movi	r2,73
811305b4:	88843526 	beq	r17,r2,8113168c <_strtod_r+0x1210>
811305b8:	002b883a 	mov	r21,zero
811305bc:	002d883a 	mov	r22,zero
811305c0:	a0000526 	beq	r20,zero,811305d8 <_strtod_r+0x15c>
811305c4:	d8000715 	stw	zero,28(sp)
811305c8:	a5c00015 	stw	r23,0(r20)
811305cc:	d9000717 	ldw	r4,28(sp)
811305d0:	20000126 	beq	r4,zero,811305d8 <_strtod_r+0x15c>
811305d4:	b5a0003c 	xorhi	r22,r22,32768
811305d8:	a805883a 	mov	r2,r21
811305dc:	b007883a 	mov	r3,r22
811305e0:	dfc01d17 	ldw	ra,116(sp)
811305e4:	df001c17 	ldw	fp,112(sp)
811305e8:	ddc01b17 	ldw	r23,108(sp)
811305ec:	dd801a17 	ldw	r22,104(sp)
811305f0:	dd401917 	ldw	r21,100(sp)
811305f4:	dd001817 	ldw	r20,96(sp)
811305f8:	dcc01717 	ldw	r19,92(sp)
811305fc:	dc801617 	ldw	r18,88(sp)
81130600:	dc401517 	ldw	r17,84(sp)
81130604:	dc001417 	ldw	r16,80(sp)
81130608:	dec01e04 	addi	sp,sp,120
8113060c:	f800283a 	ret
81130610:	d8000715 	stw	zero,28(sp)
81130614:	24c00044 	addi	r19,r4,1
81130618:	dcc00615 	stw	r19,24(sp)
8113061c:	20800043 	ldbu	r2,1(r4)
81130620:	10c03fcc 	andi	r3,r2,255
81130624:	18c0201c 	xori	r3,r3,128
81130628:	18ffe004 	addi	r3,r3,-128
8113062c:	183fe226 	beq	r3,zero,811305b8 <__reset+0xfb1105b8>
81130630:	11403fcc 	andi	r5,r2,255
81130634:	2940201c 	xori	r5,r5,128
81130638:	297fe004 	addi	r5,r5,-128
8113063c:	00c00c04 	movi	r3,48
81130640:	28c0e526 	beq	r5,r3,811309d8 <_strtod_r+0x55c>
81130644:	dcc00815 	stw	r19,32(sp)
81130648:	0025883a 	mov	r18,zero
8113064c:	10fff404 	addi	r3,r2,-48
81130650:	18c03fcc 	andi	r3,r3,255
81130654:	01000244 	movi	r4,9
81130658:	20c37536 	bltu	r4,r3,81131430 <_strtod_r+0xfb4>
8113065c:	dd400817 	ldw	r21,32(sp)
81130660:	0027883a 	mov	r19,zero
81130664:	0039883a 	mov	fp,zero
81130668:	002d883a 	mov	r22,zero
8113066c:	01400204 	movi	r5,8
81130670:	2d805a16 	blt	r5,r22,811307dc <_strtod_r+0x360>
81130674:	e70002a4 	muli	fp,fp,10
81130678:	10c03fcc 	andi	r3,r2,255
8113067c:	18c0201c 	xori	r3,r3,128
81130680:	18ffe004 	addi	r3,r3,-128
81130684:	e0f9883a 	add	fp,fp,r3
81130688:	e73ff404 	addi	fp,fp,-48
8113068c:	ad400044 	addi	r21,r21,1
81130690:	dd400615 	stw	r21,24(sp)
81130694:	a8800003 	ldbu	r2,0(r21)
81130698:	b5800044 	addi	r22,r22,1
8113069c:	10fff404 	addi	r3,r2,-48
811306a0:	18c03fcc 	andi	r3,r3,255
811306a4:	20fff22e 	bgeu	r4,r3,81130670 <__reset+0xfb110670>
811306a8:	14403fcc 	andi	r17,r2,255
811306ac:	8c40201c 	xori	r17,r17,128
811306b0:	8c7fe004 	addi	r17,r17,-128
811306b4:	8009883a 	mov	r4,r16
811306b8:	112e69c0 	call	8112e69c <_localeconv_r>
811306bc:	11400017 	ldw	r5,0(r2)
811306c0:	8009883a 	mov	r4,r16
811306c4:	d9401315 	stw	r5,76(sp)
811306c8:	112e69c0 	call	8112e69c <_localeconv_r>
811306cc:	11000017 	ldw	r4,0(r2)
811306d0:	11251780 	call	81125178 <strlen>
811306d4:	d9401317 	ldw	r5,76(sp)
811306d8:	100d883a 	mov	r6,r2
811306dc:	a809883a 	mov	r4,r21
811306e0:	1135d840 	call	81135d84 <strncmp>
811306e4:	1000ce26 	beq	r2,zero,81130a20 <_strtod_r+0x5a4>
811306e8:	b013883a 	mov	r9,r22
811306ec:	000b883a 	mov	r5,zero
811306f0:	0015883a 	mov	r10,zero
811306f4:	0017883a 	mov	r11,zero
811306f8:	00801944 	movi	r2,101
811306fc:	88807826 	beq	r17,r2,811308e0 <_strtod_r+0x464>
81130700:	00801144 	movi	r2,69
81130704:	88807626 	beq	r17,r2,811308e0 <_strtod_r+0x464>
81130708:	002b883a 	mov	r21,zero
8113070c:	48003d1e 	bne	r9,zero,81130804 <_strtod_r+0x388>
81130710:	2800391e 	bne	r5,zero,811307f8 <_strtod_r+0x37c>
81130714:	9000381e 	bne	r18,zero,811307f8 <_strtod_r+0x37c>
81130718:	583fa71e 	bne	r11,zero,811305b8 <__reset+0xfb1105b8>
8113071c:	00801384 	movi	r2,78
81130720:	88800526 	beq	r17,r2,81130738 <_strtod_r+0x2bc>
81130724:	147fa20e 	bge	r2,r17,811305b0 <__reset+0xfb1105b0>
81130728:	00801a44 	movi	r2,105
8113072c:	8883d726 	beq	r17,r2,8113168c <_strtod_r+0x1210>
81130730:	00801b84 	movi	r2,110
81130734:	88bfa01e 	bne	r17,r2,811305b8 <__reset+0xfb1105b8>
81130738:	01604574 	movhi	r5,33045
8113073c:	d9000617 	ldw	r4,24(sp)
81130740:	294b0204 	addi	r5,r5,11272
81130744:	01c00644 	movi	r7,25
81130748:	00000b06 	br	81130778 <_strtod_r+0x2fc>
8113074c:	21000044 	addi	r4,r4,1
81130750:	20800003 	ldbu	r2,0(r4)
81130754:	10ffefc4 	addi	r3,r2,-65
81130758:	10803fcc 	andi	r2,r2,255
8113075c:	1080201c 	xori	r2,r2,128
81130760:	18c03fcc 	andi	r3,r3,255
81130764:	10bfe004 	addi	r2,r2,-128
81130768:	38c00136 	bltu	r7,r3,81130770 <_strtod_r+0x2f4>
8113076c:	10800804 	addi	r2,r2,32
81130770:	29400044 	addi	r5,r5,1
81130774:	11bf901e 	bne	r2,r6,811305b8 <__reset+0xfb1105b8>
81130778:	29800007 	ldb	r6,0(r5)
8113077c:	303ff31e 	bne	r6,zero,8113074c <__reset+0xfb11074c>
81130780:	20800044 	addi	r2,r4,1
81130784:	d8800615 	stw	r2,24(sp)
81130788:	20c00047 	ldb	r3,1(r4)
8113078c:	00800a04 	movi	r2,40
81130790:	18849d26 	beq	r3,r2,81131a08 <_strtod_r+0x158c>
81130794:	047ffe34 	movhi	r17,65528
81130798:	0025883a 	mov	r18,zero
8113079c:	902b883a 	mov	r21,r18
811307a0:	882d883a 	mov	r22,r17
811307a4:	a03f8926 	beq	r20,zero,811305cc <__reset+0xfb1105cc>
811307a8:	ddc00617 	ldw	r23,24(sp)
811307ac:	003f8606 	br	811305c8 <__reset+0xfb1105c8>
811307b0:	00800044 	movi	r2,1
811307b4:	d8800715 	stw	r2,28(sp)
811307b8:	003f9606 	br	81130614 <__reset+0xfb110614>
811307bc:	21000044 	addi	r4,r4,1
811307c0:	d9000615 	stw	r4,24(sp)
811307c4:	20800003 	ldbu	r2,0(r4)
811307c8:	10c03fcc 	andi	r3,r2,255
811307cc:	28ff462e 	bgeu	r5,r3,811304e8 <__reset+0xfb1104e8>
811307d0:	2027883a 	mov	r19,r4
811307d4:	d8000715 	stw	zero,28(sp)
811307d8:	003f9506 	br	81130630 <__reset+0xfb110630>
811307dc:	9cc002a4 	muli	r19,r19,10
811307e0:	10803fcc 	andi	r2,r2,255
811307e4:	1080201c 	xori	r2,r2,128
811307e8:	10bfe004 	addi	r2,r2,-128
811307ec:	9885883a 	add	r2,r19,r2
811307f0:	14fff404 	addi	r19,r2,-48
811307f4:	003fa506 	br	8113068c <__reset+0xfb11068c>
811307f8:	002b883a 	mov	r21,zero
811307fc:	002d883a 	mov	r22,zero
81130800:	003fe806 	br	811307a4 <__reset+0xfb1107a4>
81130804:	aaabc83a 	sub	r21,r21,r10
81130808:	b000011e 	bne	r22,zero,81130810 <_strtod_r+0x394>
8113080c:	482d883a 	mov	r22,r9
81130810:	00800404 	movi	r2,16
81130814:	482f883a 	mov	r23,r9
81130818:	1240010e 	bge	r2,r9,81130820 <_strtod_r+0x3a4>
8113081c:	102f883a 	mov	r23,r2
81130820:	e009883a 	mov	r4,fp
81130824:	da401315 	stw	r9,76(sp)
81130828:	11381e40 	call	811381e4 <__floatunsidf>
8113082c:	1025883a 	mov	r18,r2
81130830:	00800244 	movi	r2,9
81130834:	1823883a 	mov	r17,r3
81130838:	da401317 	ldw	r9,76(sp)
8113083c:	15c0160e 	bge	r2,r23,81130898 <_strtod_r+0x41c>
81130840:	b8bffdc4 	addi	r2,r23,-9
81130844:	100490fa 	slli	r2,r2,3
81130848:	180b883a 	mov	r5,r3
8113084c:	00e04574 	movhi	r3,33045
81130850:	18cacd04 	addi	r3,r3,11060
81130854:	1885883a 	add	r2,r3,r2
81130858:	11800017 	ldw	r6,0(r2)
8113085c:	11c00117 	ldw	r7,4(r2)
81130860:	9009883a 	mov	r4,r18
81130864:	11220300 	call	81122030 <__muldf3>
81130868:	9809883a 	mov	r4,r19
8113086c:	1025883a 	mov	r18,r2
81130870:	1823883a 	mov	r17,r3
81130874:	11381e40 	call	811381e4 <__floatunsidf>
81130878:	9009883a 	mov	r4,r18
8113087c:	880b883a 	mov	r5,r17
81130880:	100d883a 	mov	r6,r2
81130884:	180f883a 	mov	r7,r3
81130888:	1136ec40 	call	81136ec4 <__adddf3>
8113088c:	da401317 	ldw	r9,76(sp)
81130890:	1025883a 	mov	r18,r2
81130894:	1823883a 	mov	r17,r3
81130898:	008003c4 	movi	r2,15
8113089c:	12407b16 	blt	r2,r9,81130a8c <_strtod_r+0x610>
811308a0:	a83fbe26 	beq	r21,zero,8113079c <__reset+0xfb11079c>
811308a4:	0543670e 	bge	zero,r21,81131644 <_strtod_r+0x11c8>
811308a8:	00c00584 	movi	r3,22
811308ac:	1d42e816 	blt	r3,r21,81131450 <_strtod_r+0xfd4>
811308b0:	a82a90fa 	slli	r21,r21,3
811308b4:	00a04574 	movhi	r2,33045
811308b8:	108acd04 	addi	r2,r2,11060
811308bc:	1545883a 	add	r2,r2,r21
811308c0:	11000017 	ldw	r4,0(r2)
811308c4:	11400117 	ldw	r5,4(r2)
811308c8:	900d883a 	mov	r6,r18
811308cc:	880f883a 	mov	r7,r17
811308d0:	11220300 	call	81122030 <__muldf3>
811308d4:	102b883a 	mov	r21,r2
811308d8:	182d883a 	mov	r22,r3
811308dc:	003fb106 	br	811307a4 <__reset+0xfb1107a4>
811308e0:	4801b526 	beq	r9,zero,81130fb8 <_strtod_r+0xb3c>
811308e4:	ddc00617 	ldw	r23,24(sp)
811308e8:	00c00ac4 	movi	r3,43
811308ec:	b8800044 	addi	r2,r23,1
811308f0:	d8800615 	stw	r2,24(sp)
811308f4:	b8800047 	ldb	r2,1(r23)
811308f8:	10c1e926 	beq	r2,r3,811310a0 <_strtod_r+0xc24>
811308fc:	00c00b44 	movi	r3,45
81130900:	10c1ec26 	beq	r2,r3,811310b4 <_strtod_r+0xc38>
81130904:	1023883a 	mov	r17,r2
81130908:	0019883a 	mov	r12,zero
8113090c:	88bff404 	addi	r2,r17,-48
81130910:	00c00244 	movi	r3,9
81130914:	1881b736 	bltu	r3,r2,81130ff4 <_strtod_r+0xb78>
81130918:	00800c04 	movi	r2,48
8113091c:	8880071e 	bne	r17,r2,8113093c <_strtod_r+0x4c0>
81130920:	d8800617 	ldw	r2,24(sp)
81130924:	8807883a 	mov	r3,r17
81130928:	10800044 	addi	r2,r2,1
8113092c:	d8800615 	stw	r2,24(sp)
81130930:	14400007 	ldb	r17,0(r2)
81130934:	10800044 	addi	r2,r2,1
81130938:	88fffc26 	beq	r17,r3,8113092c <__reset+0xfb11092c>
8113093c:	88bff3c4 	addi	r2,r17,-49
81130940:	00c00204 	movi	r3,8
81130944:	18bf7036 	bltu	r3,r2,81130708 <__reset+0xfb110708>
81130948:	db800617 	ldw	r14,24(sp)
8113094c:	88bff404 	addi	r2,r17,-48
81130950:	03400244 	movi	r13,9
81130954:	71c00044 	addi	r7,r14,1
81130958:	d9c00615 	stw	r7,24(sp)
8113095c:	74400043 	ldbu	r17,1(r14)
81130960:	88fff404 	addi	r3,r17,-48
81130964:	8c403fcc 	andi	r17,r17,255
81130968:	8c40201c 	xori	r17,r17,128
8113096c:	18c03fcc 	andi	r3,r3,255
81130970:	8c7fe004 	addi	r17,r17,-128
81130974:	68c00e36 	bltu	r13,r3,811309b0 <_strtod_r+0x534>
81130978:	71000084 	addi	r4,r14,2
8113097c:	d9000615 	stw	r4,24(sp)
81130980:	108002a4 	muli	r2,r2,10
81130984:	21800003 	ldbu	r6,0(r4)
81130988:	200f883a 	mov	r7,r4
8113098c:	1463883a 	add	r17,r2,r17
81130990:	30fff404 	addi	r3,r6,-48
81130994:	88bff404 	addi	r2,r17,-48
81130998:	34403fcc 	andi	r17,r6,255
8113099c:	8c40201c 	xori	r17,r17,128
811309a0:	18c03fcc 	andi	r3,r3,255
811309a4:	8c7fe004 	addi	r17,r17,-128
811309a8:	21000044 	addi	r4,r4,1
811309ac:	68fff32e 	bgeu	r13,r3,8113097c <__reset+0xfb11097c>
811309b0:	3b8fc83a 	sub	r7,r7,r14
811309b4:	00c00204 	movi	r3,8
811309b8:	19c29716 	blt	r3,r7,81131418 <_strtod_r+0xf9c>
811309bc:	102b883a 	mov	r21,r2
811309c0:	009387c4 	movi	r2,19999
811309c4:	1540010e 	bge	r2,r21,811309cc <_strtod_r+0x550>
811309c8:	102b883a 	mov	r21,r2
811309cc:	603f4f26 	beq	r12,zero,8113070c <__reset+0xfb11070c>
811309d0:	056bc83a 	sub	r21,zero,r21
811309d4:	003f4d06 	br	8113070c <__reset+0xfb11070c>
811309d8:	98800047 	ldb	r2,1(r19)
811309dc:	00c01604 	movi	r3,88
811309e0:	10c1de26 	beq	r2,r3,8113115c <_strtod_r+0xce0>
811309e4:	00c01e04 	movi	r3,120
811309e8:	10c1dc26 	beq	r2,r3,8113115c <_strtod_r+0xce0>
811309ec:	98c00044 	addi	r3,r19,1
811309f0:	1827883a 	mov	r19,r3
811309f4:	d8c00615 	stw	r3,24(sp)
811309f8:	18c00044 	addi	r3,r3,1
811309fc:	18bfffc3 	ldbu	r2,-1(r3)
81130a00:	11003fcc 	andi	r4,r2,255
81130a04:	2100201c 	xori	r4,r4,128
81130a08:	213fe004 	addi	r4,r4,-128
81130a0c:	217ff826 	beq	r4,r5,811309f0 <__reset+0xfb1109f0>
81130a10:	203f7926 	beq	r4,zero,811307f8 <__reset+0xfb1107f8>
81130a14:	dcc00815 	stw	r19,32(sp)
81130a18:	04800044 	movi	r18,1
81130a1c:	003f0b06 	br	8113064c <__reset+0xfb11064c>
81130a20:	8009883a 	mov	r4,r16
81130a24:	112e69c0 	call	8112e69c <_localeconv_r>
81130a28:	11000017 	ldw	r4,0(r2)
81130a2c:	11251780 	call	81125178 <strlen>
81130a30:	d8c00617 	ldw	r3,24(sp)
81130a34:	1885883a 	add	r2,r3,r2
81130a38:	d8800615 	stw	r2,24(sp)
81130a3c:	14400007 	ldb	r17,0(r2)
81130a40:	b001881e 	bne	r22,zero,81131064 <_strtod_r+0xbe8>
81130a44:	00c00c04 	movi	r3,48
81130a48:	88c3391e 	bne	r17,r3,81131730 <_strtod_r+0x12b4>
81130a4c:	10c00044 	addi	r3,r2,1
81130a50:	8809883a 	mov	r4,r17
81130a54:	d8c00615 	stw	r3,24(sp)
81130a58:	1c400007 	ldb	r17,0(r3)
81130a5c:	188bc83a 	sub	r5,r3,r2
81130a60:	18c00044 	addi	r3,r3,1
81130a64:	893ffb26 	beq	r17,r4,81130a54 <__reset+0xfb110a54>
81130a68:	88bff3c4 	addi	r2,r17,-49
81130a6c:	00c00204 	movi	r3,8
81130a70:	1882e72e 	bgeu	r3,r2,81131610 <_strtod_r+0x1194>
81130a74:	00801944 	movi	r2,101
81130a78:	88814d26 	beq	r17,r2,81130fb0 <_strtod_r+0xb34>
81130a7c:	0013883a 	mov	r9,zero
81130a80:	0015883a 	mov	r10,zero
81130a84:	02c00044 	movi	r11,1
81130a88:	003f1d06 	br	81130700 <__reset+0xfb110700>
81130a8c:	4defc83a 	sub	r23,r9,r23
81130a90:	bd6f883a 	add	r23,r23,r21
81130a94:	05c21e0e 	bge	zero,r23,81131310 <_strtod_r+0xe94>
81130a98:	b88003cc 	andi	r2,r23,15
81130a9c:	10000d26 	beq	r2,zero,81130ad4 <_strtod_r+0x658>
81130aa0:	100490fa 	slli	r2,r2,3
81130aa4:	00e04574 	movhi	r3,33045
81130aa8:	18cacd04 	addi	r3,r3,11060
81130aac:	1885883a 	add	r2,r3,r2
81130ab0:	11000017 	ldw	r4,0(r2)
81130ab4:	11400117 	ldw	r5,4(r2)
81130ab8:	900d883a 	mov	r6,r18
81130abc:	880f883a 	mov	r7,r17
81130ac0:	da401315 	stw	r9,76(sp)
81130ac4:	11220300 	call	81122030 <__muldf3>
81130ac8:	da401317 	ldw	r9,76(sp)
81130acc:	1025883a 	mov	r18,r2
81130ad0:	1823883a 	mov	r17,r3
81130ad4:	023ffc04 	movi	r8,-16
81130ad8:	ba10703a 	and	r8,r23,r8
81130adc:	40003c26 	beq	r8,zero,81130bd0 <_strtod_r+0x754>
81130ae0:	00804d04 	movi	r2,308
81130ae4:	1201cd16 	blt	r2,r8,8113121c <_strtod_r+0xda0>
81130ae8:	4011d13a 	srai	r8,r8,4
81130aec:	03000044 	movi	r12,1
81130af0:	62037c0e 	bge	r12,r8,811318e4 <_strtod_r+0x1468>
81130af4:	01204574 	movhi	r4,33045
81130af8:	210ac304 	addi	r4,r4,11020
81130afc:	2015883a 	mov	r10,r4
81130b00:	0027883a 	mov	r19,zero
81130b04:	d9000915 	stw	r4,36(sp)
81130b08:	9005883a 	mov	r2,r18
81130b0c:	8807883a 	mov	r3,r17
81130b10:	dc000c15 	stw	r16,48(sp)
81130b14:	dc800e15 	stw	r18,56(sp)
81130b18:	9821883a 	mov	r16,r19
81130b1c:	0009883a 	mov	r4,zero
81130b20:	8827883a 	mov	r19,r17
81130b24:	602f883a 	mov	r23,r12
81130b28:	da400a15 	stw	r9,40(sp)
81130b2c:	5025883a 	mov	r18,r10
81130b30:	4023883a 	mov	r17,r8
81130b34:	8980004c 	andi	r6,r17,1
81130b38:	30000626 	beq	r6,zero,81130b54 <_strtod_r+0x6d8>
81130b3c:	91800017 	ldw	r6,0(r18)
81130b40:	91c00117 	ldw	r7,4(r18)
81130b44:	1009883a 	mov	r4,r2
81130b48:	180b883a 	mov	r5,r3
81130b4c:	11220300 	call	81122030 <__muldf3>
81130b50:	01000044 	movi	r4,1
81130b54:	8823d07a 	srai	r17,r17,1
81130b58:	84000044 	addi	r16,r16,1
81130b5c:	94800204 	addi	r18,r18,8
81130b60:	8dfff41e 	bne	r17,r23,81130b34 <__reset+0xfb110b34>
81130b64:	21003fcc 	andi	r4,r4,255
81130b68:	9823883a 	mov	r17,r19
81130b6c:	da400a17 	ldw	r9,40(sp)
81130b70:	8027883a 	mov	r19,r16
81130b74:	dc800e17 	ldw	r18,56(sp)
81130b78:	dc000c17 	ldw	r16,48(sp)
81130b7c:	2003b11e 	bne	r4,zero,81131a44 <_strtod_r+0x15c8>
81130b80:	981690fa 	slli	r11,r19,3
81130b84:	d8800917 	ldw	r2,36(sp)
81130b88:	01ff2c34 	movhi	r7,64688
81130b8c:	900d883a 	mov	r6,r18
81130b90:	12ef883a 	add	r23,r2,r11
81130b94:	b9000017 	ldw	r4,0(r23)
81130b98:	b9400117 	ldw	r5,4(r23)
81130b9c:	89cf883a 	add	r7,r17,r7
81130ba0:	da401315 	stw	r9,76(sp)
81130ba4:	11220300 	call	81122030 <__muldf3>
81130ba8:	1025883a 	mov	r18,r2
81130bac:	011f2834 	movhi	r4,31904
81130bb0:	189ffc2c 	andhi	r2,r3,32752
81130bb4:	da401317 	ldw	r9,76(sp)
81130bb8:	20819836 	bltu	r4,r2,8113121c <_strtod_r+0xda0>
81130bbc:	011f2434 	movhi	r4,31888
81130bc0:	2083382e 	bgeu	r4,r2,811318a4 <_strtod_r+0x1428>
81130bc4:	045ffc34 	movhi	r17,32752
81130bc8:	8c7fffc4 	addi	r17,r17,-1
81130bcc:	04bfffc4 	movi	r18,-1
81130bd0:	d8000915 	stw	zero,36(sp)
81130bd4:	d9400817 	ldw	r5,32(sp)
81130bd8:	df000015 	stw	fp,0(sp)
81130bdc:	480f883a 	mov	r7,r9
81130be0:	b00d883a 	mov	r6,r22
81130be4:	8009883a 	mov	r4,r16
81130be8:	112edb80 	call	8112edb8 <__s2b>
81130bec:	d8800815 	stw	r2,32(sp)
81130bf0:	10018a26 	beq	r2,zero,8113121c <_strtod_r+0xda0>
81130bf4:	a807d7fa 	srai	r3,r21,31
81130bf8:	0545c83a 	sub	r2,zero,r21
81130bfc:	dd400a15 	stw	r21,40(sp)
81130c00:	1886703a 	and	r3,r3,r2
81130c04:	d8c00c15 	stw	r3,48(sp)
81130c08:	a8013516 	blt	r21,zero,811310e0 <_strtod_r+0xc64>
81130c0c:	d9400817 	ldw	r5,32(sp)
81130c10:	0011883a 	mov	r8,zero
81130c14:	0027883a 	mov	r19,zero
81130c18:	29400304 	addi	r5,r5,12
81130c1c:	d9400f15 	stw	r5,60(sp)
81130c20:	402b883a 	mov	r21,r8
81130c24:	dd001215 	stw	r20,72(sp)
81130c28:	d8800817 	ldw	r2,32(sp)
81130c2c:	8009883a 	mov	r4,r16
81130c30:	11400117 	ldw	r5,4(r2)
81130c34:	112ebb80 	call	8112ebb8 <_Balloc>
81130c38:	1029883a 	mov	r20,r2
81130c3c:	10012d26 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130c40:	d8c00817 	ldw	r3,32(sp)
81130c44:	d9400f17 	ldw	r5,60(sp)
81130c48:	11000304 	addi	r4,r2,12
81130c4c:	19800417 	ldw	r6,16(r3)
81130c50:	31800084 	addi	r6,r6,2
81130c54:	318d883a 	add	r6,r6,r6
81130c58:	318d883a 	add	r6,r6,r6
81130c5c:	11247000 	call	81124700 <memcpy>
81130c60:	d9000204 	addi	r4,sp,8
81130c64:	d9000015 	stw	r4,0(sp)
81130c68:	d9c00404 	addi	r7,sp,16
81130c6c:	900b883a 	mov	r5,r18
81130c70:	880d883a 	mov	r6,r17
81130c74:	8009883a 	mov	r4,r16
81130c78:	112f8940 	call	8112f894 <__d2b>
81130c7c:	d8800515 	stw	r2,20(sp)
81130c80:	dc801115 	stw	r18,68(sp)
81130c84:	dc401015 	stw	r17,64(sp)
81130c88:	10027c26 	beq	r2,zero,8113167c <_strtod_r+0x1200>
81130c8c:	01400044 	movi	r5,1
81130c90:	8009883a 	mov	r4,r16
81130c94:	112efdc0 	call	8112efdc <__i2b>
81130c98:	1027883a 	mov	r19,r2
81130c9c:	10011526 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130ca0:	d8800417 	ldw	r2,16(sp)
81130ca4:	1000c816 	blt	r2,zero,81130fc8 <_strtod_r+0xb4c>
81130ca8:	d9400c17 	ldw	r5,48(sp)
81130cac:	d9000a17 	ldw	r4,40(sp)
81130cb0:	28ad883a 	add	r22,r5,r2
81130cb4:	d9400917 	ldw	r5,36(sp)
81130cb8:	df000217 	ldw	fp,8(sp)
81130cbc:	05ff0084 	movi	r23,-1022
81130cc0:	1147c83a 	sub	r3,r2,r5
81130cc4:	1f07883a 	add	r3,r3,fp
81130cc8:	00800d84 	movi	r2,54
81130ccc:	18ffffc4 	addi	r3,r3,-1
81130cd0:	1739c83a 	sub	fp,r2,fp
81130cd4:	1dc0a50e 	bge	r3,r23,81130f6c <_strtod_r+0xaf0>
81130cd8:	b8efc83a 	sub	r23,r23,r3
81130cdc:	008007c4 	movi	r2,31
81130ce0:	e5f9c83a 	sub	fp,fp,r23
81130ce4:	15c0bc16 	blt	r2,r23,81130fd8 <_strtod_r+0xb5c>
81130ce8:	00800044 	movi	r2,1
81130cec:	15c4983a 	sll	r2,r2,r23
81130cf0:	d8000b15 	stw	zero,44(sp)
81130cf4:	d8800d15 	stw	r2,52(sp)
81130cf8:	2707883a 	add	r3,r4,fp
81130cfc:	d9000917 	ldw	r4,36(sp)
81130d00:	b739883a 	add	fp,r22,fp
81130d04:	20ef883a 	add	r23,r4,r3
81130d08:	b009883a 	mov	r4,r22
81130d0c:	e580010e 	bge	fp,r22,81130d14 <_strtod_r+0x898>
81130d10:	e009883a 	mov	r4,fp
81130d14:	b805883a 	mov	r2,r23
81130d18:	25c0010e 	bge	r4,r23,81130d20 <_strtod_r+0x8a4>
81130d1c:	2005883a 	mov	r2,r4
81130d20:	0080030e 	bge	zero,r2,81130d30 <_strtod_r+0x8b4>
81130d24:	e0b9c83a 	sub	fp,fp,r2
81130d28:	b8afc83a 	sub	r23,r23,r2
81130d2c:	b0adc83a 	sub	r22,r22,r2
81130d30:	d9400c17 	ldw	r5,48(sp)
81130d34:	28001126 	beq	r5,zero,81130d7c <_strtod_r+0x900>
81130d38:	280d883a 	mov	r6,r5
81130d3c:	8009883a 	mov	r4,r16
81130d40:	980b883a 	mov	r5,r19
81130d44:	112f2200 	call	8112f220 <__pow5mult>
81130d48:	1027883a 	mov	r19,r2
81130d4c:	1000e926 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130d50:	d9800517 	ldw	r6,20(sp)
81130d54:	100b883a 	mov	r5,r2
81130d58:	8009883a 	mov	r4,r16
81130d5c:	112f0200 	call	8112f020 <__multiply>
81130d60:	1000e426 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130d64:	d9400517 	ldw	r5,20(sp)
81130d68:	8009883a 	mov	r4,r16
81130d6c:	d8801315 	stw	r2,76(sp)
81130d70:	112ec680 	call	8112ec68 <_Bfree>
81130d74:	d8801317 	ldw	r2,76(sp)
81130d78:	d8800515 	stw	r2,20(sp)
81130d7c:	0700060e 	bge	zero,fp,81130d98 <_strtod_r+0x91c>
81130d80:	d9400517 	ldw	r5,20(sp)
81130d84:	e00d883a 	mov	r6,fp
81130d88:	8009883a 	mov	r4,r16
81130d8c:	112f3680 	call	8112f368 <__lshift>
81130d90:	d8800515 	stw	r2,20(sp)
81130d94:	10023926 	beq	r2,zero,8113167c <_strtod_r+0x1200>
81130d98:	d8800a17 	ldw	r2,40(sp)
81130d9c:	10000626 	beq	r2,zero,81130db8 <_strtod_r+0x93c>
81130da0:	d9800a17 	ldw	r6,40(sp)
81130da4:	a00b883a 	mov	r5,r20
81130da8:	8009883a 	mov	r4,r16
81130dac:	112f2200 	call	8112f220 <__pow5mult>
81130db0:	1029883a 	mov	r20,r2
81130db4:	1000cf26 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130db8:	05c0060e 	bge	zero,r23,81130dd4 <_strtod_r+0x958>
81130dbc:	a00b883a 	mov	r5,r20
81130dc0:	b80d883a 	mov	r6,r23
81130dc4:	8009883a 	mov	r4,r16
81130dc8:	112f3680 	call	8112f368 <__lshift>
81130dcc:	1029883a 	mov	r20,r2
81130dd0:	1000c826 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130dd4:	0580060e 	bge	zero,r22,81130df0 <_strtod_r+0x974>
81130dd8:	980b883a 	mov	r5,r19
81130ddc:	b00d883a 	mov	r6,r22
81130de0:	8009883a 	mov	r4,r16
81130de4:	112f3680 	call	8112f368 <__lshift>
81130de8:	1027883a 	mov	r19,r2
81130dec:	1000c126 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130df0:	d9400517 	ldw	r5,20(sp)
81130df4:	a00d883a 	mov	r6,r20
81130df8:	8009883a 	mov	r4,r16
81130dfc:	112f5180 	call	8112f518 <__mdiff>
81130e00:	102b883a 	mov	r21,r2
81130e04:	1000bb26 	beq	r2,zero,811310f4 <_strtod_r+0xc78>
81130e08:	10c00317 	ldw	r3,12(r2)
81130e0c:	980b883a 	mov	r5,r19
81130e10:	10000315 	stw	zero,12(r2)
81130e14:	1009883a 	mov	r4,r2
81130e18:	d8c00e15 	stw	r3,56(sp)
81130e1c:	112f4b80 	call	8112f4b8 <__mcmp>
81130e20:	10027616 	blt	r2,zero,811317fc <_strtod_r+0x1380>
81130e24:	10024426 	beq	r2,zero,81131738 <_strtod_r+0x12bc>
81130e28:	980b883a 	mov	r5,r19
81130e2c:	a809883a 	mov	r4,r21
81130e30:	112f9e80 	call	8112f9e8 <__ratio>
81130e34:	000d883a 	mov	r6,zero
81130e38:	01d00034 	movhi	r7,16384
81130e3c:	1009883a 	mov	r4,r2
81130e40:	180b883a 	mov	r5,r3
81130e44:	102f883a 	mov	r23,r2
81130e48:	182d883a 	mov	r22,r3
81130e4c:	11380f00 	call	811380f0 <__ledf2>
81130e50:	00804a16 	blt	zero,r2,81130f7c <_strtod_r+0xb00>
81130e54:	d9400e17 	ldw	r5,56(sp)
81130e58:	28006b26 	beq	r5,zero,81131008 <_strtod_r+0xb8c>
81130e5c:	058ffc34 	movhi	r22,16368
81130e60:	d8000b15 	stw	zero,44(sp)
81130e64:	d8000d15 	stw	zero,52(sp)
81130e68:	b02f883a 	mov	r23,r22
81130e6c:	8f1ffc2c 	andhi	fp,r17,32752
81130e70:	009ff834 	movhi	r2,32736
81130e74:	e080cd26 	beq	fp,r2,811311ac <_strtod_r+0xd30>
81130e78:	d9400917 	ldw	r5,36(sp)
81130e7c:	28001a26 	beq	r5,zero,81130ee8 <_strtod_r+0xa6c>
81130e80:	0081a834 	movhi	r2,1696
81130e84:	17001836 	bltu	r2,fp,81130ee8 <_strtod_r+0xa6c>
81130e88:	d9000d17 	ldw	r4,52(sp)
81130e8c:	01d07834 	movhi	r7,16864
81130e90:	39ffffc4 	addi	r7,r7,-1
81130e94:	01bff034 	movhi	r6,65472
81130e98:	b80b883a 	mov	r5,r23
81130e9c:	11380f00 	call	811380f0 <__ledf2>
81130ea0:	00800e16 	blt	zero,r2,81130edc <_strtod_r+0xa60>
81130ea4:	d9000d17 	ldw	r4,52(sp)
81130ea8:	b80b883a 	mov	r5,r23
81130eac:	11214680 	call	81121468 <__fixunsdfsi>
81130eb0:	10018126 	beq	r2,zero,811314b8 <_strtod_r+0x103c>
81130eb4:	1009883a 	mov	r4,r2
81130eb8:	11381e40 	call	811381e4 <__floatunsidf>
81130ebc:	d8800d15 	stw	r2,52(sp)
81130ec0:	182f883a 	mov	r23,r3
81130ec4:	d8800e17 	ldw	r2,56(sp)
81130ec8:	1001791e 	bne	r2,zero,811314b0 <_strtod_r+0x1034>
81130ecc:	ba20003c 	xorhi	r8,r23,32768
81130ed0:	d8c00d17 	ldw	r3,52(sp)
81130ed4:	402d883a 	mov	r22,r8
81130ed8:	d8c00b15 	stw	r3,44(sp)
81130edc:	0081ac34 	movhi	r2,1712
81130ee0:	b091883a 	add	r8,r22,r2
81130ee4:	472dc83a 	sub	r22,r8,fp
81130ee8:	9009883a 	mov	r4,r18
81130eec:	880b883a 	mov	r5,r17
81130ef0:	112f71c0 	call	8112f71c <__ulp>
81130ef4:	d9000b17 	ldw	r4,44(sp)
81130ef8:	b00b883a 	mov	r5,r22
81130efc:	100d883a 	mov	r6,r2
81130f00:	180f883a 	mov	r7,r3
81130f04:	11220300 	call	81122030 <__muldf3>
81130f08:	900d883a 	mov	r6,r18
81130f0c:	880f883a 	mov	r7,r17
81130f10:	1009883a 	mov	r4,r2
81130f14:	180b883a 	mov	r5,r3
81130f18:	1136ec40 	call	81136ec4 <__adddf3>
81130f1c:	1025883a 	mov	r18,r2
81130f20:	1823883a 	mov	r17,r3
81130f24:	182d883a 	mov	r22,r3
81130f28:	d9000917 	ldw	r4,36(sp)
81130f2c:	2000021e 	bne	r4,zero,81130f38 <_strtod_r+0xabc>
81130f30:	b09ffc2c 	andhi	r2,r22,32752
81130f34:	e080be26 	beq	fp,r2,81131230 <_strtod_r+0xdb4>
81130f38:	d9400517 	ldw	r5,20(sp)
81130f3c:	8009883a 	mov	r4,r16
81130f40:	112ec680 	call	8112ec68 <_Bfree>
81130f44:	a00b883a 	mov	r5,r20
81130f48:	8009883a 	mov	r4,r16
81130f4c:	112ec680 	call	8112ec68 <_Bfree>
81130f50:	980b883a 	mov	r5,r19
81130f54:	8009883a 	mov	r4,r16
81130f58:	112ec680 	call	8112ec68 <_Bfree>
81130f5c:	a80b883a 	mov	r5,r21
81130f60:	8009883a 	mov	r4,r16
81130f64:	112ec680 	call	8112ec68 <_Bfree>
81130f68:	003f2f06 	br	81130c28 <__reset+0xfb110c28>
81130f6c:	00c00044 	movi	r3,1
81130f70:	d8000b15 	stw	zero,44(sp)
81130f74:	d8c00d15 	stw	r3,52(sp)
81130f78:	003f5f06 	br	81130cf8 <__reset+0xfb110cf8>
81130f7c:	b809883a 	mov	r4,r23
81130f80:	000d883a 	mov	r6,zero
81130f84:	01cff834 	movhi	r7,16352
81130f88:	b00b883a 	mov	r5,r22
81130f8c:	11220300 	call	81122030 <__muldf3>
81130f90:	d9000e17 	ldw	r4,56(sp)
81130f94:	d8800d15 	stw	r2,52(sp)
81130f98:	182f883a 	mov	r23,r3
81130f9c:	2000181e 	bne	r4,zero,81131000 <_strtod_r+0xb84>
81130fa0:	1a20003c 	xorhi	r8,r3,32768
81130fa4:	d8800b15 	stw	r2,44(sp)
81130fa8:	402d883a 	mov	r22,r8
81130fac:	003faf06 	br	81130e6c <__reset+0xfb110e6c>
81130fb0:	0015883a 	mov	r10,zero
81130fb4:	02c00044 	movi	r11,1
81130fb8:	2800011e 	bne	r5,zero,81130fc0 <_strtod_r+0xb44>
81130fbc:	903d7e26 	beq	r18,zero,811305b8 <__reset+0xfb1105b8>
81130fc0:	0013883a 	mov	r9,zero
81130fc4:	003e4706 	br	811308e4 <__reset+0xfb1108e4>
81130fc8:	d8c00a17 	ldw	r3,40(sp)
81130fcc:	dd800c17 	ldw	r22,48(sp)
81130fd0:	1889c83a 	sub	r4,r3,r2
81130fd4:	003f3706 	br	81130cb4 <__reset+0xfb110cb4>
81130fd8:	00bef884 	movi	r2,-1054
81130fdc:	05c00044 	movi	r23,1
81130fe0:	10c5c83a 	sub	r2,r2,r3
81130fe4:	b884983a 	sll	r2,r23,r2
81130fe8:	ddc00d15 	stw	r23,52(sp)
81130fec:	d8800b15 	stw	r2,44(sp)
81130ff0:	003f4106 	br	81130cf8 <__reset+0xfb110cf8>
81130ff4:	ddc00615 	stw	r23,24(sp)
81130ff8:	002b883a 	mov	r21,zero
81130ffc:	003dc306 	br	8113070c <__reset+0xfb11070c>
81131000:	1811883a 	mov	r8,r3
81131004:	003fe706 	br	81130fa4 <__reset+0xfb110fa4>
81131008:	90002e1e 	bne	r18,zero,811310c4 <_strtod_r+0xc48>
8113100c:	00c00434 	movhi	r3,16
81131010:	18ffffc4 	addi	r3,r3,-1
81131014:	88c4703a 	and	r2,r17,r3
81131018:	10002c1e 	bne	r2,zero,811310cc <_strtod_r+0xc50>
8113101c:	000d883a 	mov	r6,zero
81131020:	01cffc34 	movhi	r7,16368
81131024:	b809883a 	mov	r4,r23
81131028:	b00b883a 	mov	r5,r22
8113102c:	11380f00 	call	811380f0 <__ledf2>
81131030:	10021716 	blt	r2,zero,81131890 <_strtod_r+0x1414>
81131034:	b809883a 	mov	r4,r23
81131038:	b00b883a 	mov	r5,r22
8113103c:	000d883a 	mov	r6,zero
81131040:	01cff834 	movhi	r7,16352
81131044:	11220300 	call	81122030 <__muldf3>
81131048:	d8800d15 	stw	r2,52(sp)
8113104c:	182f883a 	mov	r23,r3
81131050:	102d883a 	mov	r22,r2
81131054:	1a20003c 	xorhi	r8,r3,32768
81131058:	dd800b15 	stw	r22,44(sp)
8113105c:	402d883a 	mov	r22,r8
81131060:	003f8206 	br	81130e6c <__reset+0xfb110e6c>
81131064:	b013883a 	mov	r9,r22
81131068:	000b883a 	mov	r5,zero
8113106c:	0015883a 	mov	r10,zero
81131070:	893ff404 	addi	r4,r17,-48
81131074:	00800244 	movi	r2,9
81131078:	11001036 	bltu	r2,r4,811310bc <_strtod_r+0xc40>
8113107c:	28c00044 	addi	r3,r5,1
81131080:	2023883a 	mov	r17,r4
81131084:	20014d1e 	bne	r4,zero,811315bc <_strtod_r+0x1140>
81131088:	d9800617 	ldw	r6,24(sp)
8113108c:	180b883a 	mov	r5,r3
81131090:	30800044 	addi	r2,r6,1
81131094:	d8800615 	stw	r2,24(sp)
81131098:	34400047 	ldb	r17,1(r6)
8113109c:	003ff406 	br	81131070 <__reset+0xfb111070>
811310a0:	0019883a 	mov	r12,zero
811310a4:	b8800084 	addi	r2,r23,2
811310a8:	d8800615 	stw	r2,24(sp)
811310ac:	bc400087 	ldb	r17,2(r23)
811310b0:	003e1606 	br	8113090c <__reset+0xfb11090c>
811310b4:	03000044 	movi	r12,1
811310b8:	003ffa06 	br	811310a4 <__reset+0xfb1110a4>
811310bc:	02c00044 	movi	r11,1
811310c0:	003d8d06 	br	811306f8 <__reset+0xfb1106f8>
811310c4:	00800044 	movi	r2,1
811310c8:	9080fe26 	beq	r18,r2,811314c4 <_strtod_r+0x1048>
811310cc:	d8000b15 	stw	zero,44(sp)
811310d0:	05affc34 	movhi	r22,49136
811310d4:	d8000d15 	stw	zero,52(sp)
811310d8:	05cffc34 	movhi	r23,16368
811310dc:	003f6306 	br	81130e6c <__reset+0xfb110e6c>
811310e0:	d8000a15 	stw	zero,40(sp)
811310e4:	003ec906 	br	81130c0c <__reset+0xfb110c0c>
811310e8:	d9001117 	ldw	r4,68(sp)
811310ec:	00bfffc4 	movi	r2,-1
811310f0:	2080461e 	bne	r4,r2,8113120c <_strtod_r+0xd90>
811310f4:	dd000a15 	stw	r20,40(sp)
811310f8:	dd001217 	ldw	r20,72(sp)
811310fc:	a811883a 	mov	r8,r21
81131100:	d8800517 	ldw	r2,20(sp)
81131104:	00c00884 	movi	r3,34
81131108:	80c00015 	stw	r3,0(r16)
8113110c:	002b883a 	mov	r21,zero
81131110:	059ffc34 	movhi	r22,32752
81131114:	100b883a 	mov	r5,r2
81131118:	8009883a 	mov	r4,r16
8113111c:	da001315 	stw	r8,76(sp)
81131120:	112ec680 	call	8112ec68 <_Bfree>
81131124:	d9400a17 	ldw	r5,40(sp)
81131128:	8009883a 	mov	r4,r16
8113112c:	112ec680 	call	8112ec68 <_Bfree>
81131130:	980b883a 	mov	r5,r19
81131134:	8009883a 	mov	r4,r16
81131138:	112ec680 	call	8112ec68 <_Bfree>
8113113c:	d9400817 	ldw	r5,32(sp)
81131140:	8009883a 	mov	r4,r16
81131144:	112ec680 	call	8112ec68 <_Bfree>
81131148:	da001317 	ldw	r8,76(sp)
8113114c:	8009883a 	mov	r4,r16
81131150:	400b883a 	mov	r5,r8
81131154:	112ec680 	call	8112ec68 <_Bfree>
81131158:	003d9206 	br	811307a4 <__reset+0xfb1107a4>
8113115c:	d8c00717 	ldw	r3,28(sp)
81131160:	d8800504 	addi	r2,sp,20
81131164:	01a04574 	movhi	r6,33045
81131168:	318b0804 	addi	r6,r6,11296
8113116c:	d8c00115 	stw	r3,4(sp)
81131170:	d8800015 	stw	r2,0(sp)
81131174:	d9c00404 	addi	r7,sp,16
81131178:	d9400604 	addi	r5,sp,24
8113117c:	8009883a 	mov	r4,r16
81131180:	11352e80 	call	811352e8 <__gethex>
81131184:	154001cc 	andi	r21,r2,7
81131188:	a83d9b26 	beq	r21,zero,811307f8 <__reset+0xfb1107f8>
8113118c:	00c00184 	movi	r3,6
81131190:	a8c0d61e 	bne	r21,r3,811314ec <_strtod_r+0x1070>
81131194:	9cc00044 	addi	r19,r19,1
81131198:	dcc00615 	stw	r19,24(sp)
8113119c:	002b883a 	mov	r21,zero
811311a0:	002d883a 	mov	r22,zero
811311a4:	d8000715 	stw	zero,28(sp)
811311a8:	003d7e06 	br	811307a4 <__reset+0xfb1107a4>
811311ac:	00bf2c34 	movhi	r2,64688
811311b0:	88a3883a 	add	r17,r17,r2
811311b4:	9009883a 	mov	r4,r18
811311b8:	880b883a 	mov	r5,r17
811311bc:	112f71c0 	call	8112f71c <__ulp>
811311c0:	d9000b17 	ldw	r4,44(sp)
811311c4:	100d883a 	mov	r6,r2
811311c8:	180f883a 	mov	r7,r3
811311cc:	b00b883a 	mov	r5,r22
811311d0:	11220300 	call	81122030 <__muldf3>
811311d4:	900d883a 	mov	r6,r18
811311d8:	180b883a 	mov	r5,r3
811311dc:	880f883a 	mov	r7,r17
811311e0:	1009883a 	mov	r4,r2
811311e4:	1136ec40 	call	81136ec4 <__adddf3>
811311e8:	015f2834 	movhi	r5,31904
811311ec:	1025883a 	mov	r18,r2
811311f0:	297fffc4 	addi	r5,r5,-1
811311f4:	189ffc2c 	andhi	r2,r3,32752
811311f8:	2880892e 	bgeu	r5,r2,81131420 <_strtod_r+0xfa4>
811311fc:	d8801017 	ldw	r2,64(sp)
81131200:	00dffc34 	movhi	r3,32752
81131204:	18ffffc4 	addi	r3,r3,-1
81131208:	10ffb726 	beq	r2,r3,811310e8 <__reset+0xfb1110e8>
8113120c:	045ffc34 	movhi	r17,32752
81131210:	8c7fffc4 	addi	r17,r17,-1
81131214:	04bfffc4 	movi	r18,-1
81131218:	003f4706 	br	81130f38 <__reset+0xfb110f38>
8113121c:	00800884 	movi	r2,34
81131220:	80800015 	stw	r2,0(r16)
81131224:	002b883a 	mov	r21,zero
81131228:	059ffc34 	movhi	r22,32752
8113122c:	003d5d06 	br	811307a4 <__reset+0xfb1107a4>
81131230:	d9000d17 	ldw	r4,52(sp)
81131234:	b80b883a 	mov	r5,r23
81131238:	11230540 	call	81123054 <__fixdfsi>
8113123c:	1009883a 	mov	r4,r2
81131240:	11230d40 	call	811230d4 <__floatsidf>
81131244:	d9000d17 	ldw	r4,52(sp)
81131248:	b80b883a 	mov	r5,r23
8113124c:	100d883a 	mov	r6,r2
81131250:	180f883a 	mov	r7,r3
81131254:	11227500 	call	81122750 <__subdf3>
81131258:	d9400e17 	ldw	r5,56(sp)
8113125c:	1039883a 	mov	fp,r2
81131260:	182f883a 	mov	r23,r3
81131264:	2800141e 	bne	r5,zero,811312b8 <_strtod_r+0xe3c>
81131268:	9000131e 	bne	r18,zero,811312b8 <_strtod_r+0xe3c>
8113126c:	00800434 	movhi	r2,16
81131270:	10bfffc4 	addi	r2,r2,-1
81131274:	b0ac703a 	and	r22,r22,r2
81131278:	b0000f1e 	bne	r22,zero,811312b8 <_strtod_r+0xe3c>
8113127c:	01a52834 	movhi	r6,38048
81131280:	01cff434 	movhi	r7,16336
81131284:	318d6544 	addi	r6,r6,13717
81131288:	39ffffc4 	addi	r7,r7,-1
8113128c:	e009883a 	mov	r4,fp
81131290:	180b883a 	mov	r5,r3
81131294:	11380f00 	call	811380f0 <__ledf2>
81131298:	103f270e 	bge	r2,zero,81130f38 <__reset+0xfb110f38>
8113129c:	dd000a15 	stw	r20,40(sp)
811312a0:	a811883a 	mov	r8,r21
811312a4:	dd001217 	ldw	r20,72(sp)
811312a8:	d8800517 	ldw	r2,20(sp)
811312ac:	002b883a 	mov	r21,zero
811312b0:	882d883a 	mov	r22,r17
811312b4:	003f9706 	br	81131114 <__reset+0xfb111114>
811312b8:	01a52834 	movhi	r6,38048
811312bc:	01cff834 	movhi	r7,16352
811312c0:	318d6544 	addi	r6,r6,13717
811312c4:	39ffffc4 	addi	r7,r7,-1
811312c8:	e009883a 	mov	r4,fp
811312cc:	b80b883a 	mov	r5,r23
811312d0:	11380f00 	call	811380f0 <__ledf2>
811312d4:	10000716 	blt	r2,zero,811312f4 <_strtod_r+0xe78>
811312d8:	018d6c34 	movhi	r6,13744
811312dc:	31b94d44 	addi	r6,r6,-6859
811312e0:	01cff834 	movhi	r7,16352
811312e4:	e009883a 	mov	r4,fp
811312e8:	b80b883a 	mov	r5,r23
811312ec:	1121f540 	call	81121f54 <__gedf2>
811312f0:	00bf110e 	bge	zero,r2,81130f38 <__reset+0xfb110f38>
811312f4:	dd000a15 	stw	r20,40(sp)
811312f8:	a811883a 	mov	r8,r21
811312fc:	dd001217 	ldw	r20,72(sp)
81131300:	d8800517 	ldw	r2,20(sp)
81131304:	902b883a 	mov	r21,r18
81131308:	882d883a 	mov	r22,r17
8113130c:	003f8106 	br	81131114 <__reset+0xfb111114>
81131310:	b83e2f26 	beq	r23,zero,81130bd0 <__reset+0xfb110bd0>
81131314:	05efc83a 	sub	r23,zero,r23
81131318:	b88003cc 	andi	r2,r23,15
8113131c:	10000d26 	beq	r2,zero,81131354 <_strtod_r+0xed8>
81131320:	100490fa 	slli	r2,r2,3
81131324:	00e04574 	movhi	r3,33045
81131328:	18cacd04 	addi	r3,r3,11060
8113132c:	1885883a 	add	r2,r3,r2
81131330:	11800017 	ldw	r6,0(r2)
81131334:	11c00117 	ldw	r7,4(r2)
81131338:	9009883a 	mov	r4,r18
8113133c:	880b883a 	mov	r5,r17
81131340:	da401315 	stw	r9,76(sp)
81131344:	11377780 	call	81137778 <__divdf3>
81131348:	da401317 	ldw	r9,76(sp)
8113134c:	1025883a 	mov	r18,r2
81131350:	1823883a 	mov	r17,r3
81131354:	b82fd13a 	srai	r23,r23,4
81131358:	b83e1d26 	beq	r23,zero,81130bd0 <__reset+0xfb110bd0>
8113135c:	008007c4 	movi	r2,31
81131360:	15c02816 	blt	r2,r23,81131404 <_strtod_r+0xf88>
81131364:	b880040c 	andi	r2,r23,16
81131368:	10019726 	beq	r2,zero,811319c8 <_strtod_r+0x154c>
8113136c:	05c1880e 	bge	zero,r23,81131990 <_strtod_r+0x1514>
81131370:	00c01a84 	movi	r3,106
81131374:	d8c00915 	stw	r3,36(sp)
81131378:	04e04574 	movhi	r19,33045
8113137c:	9ccb0d04 	addi	r19,r19,11316
81131380:	8807883a 	mov	r3,r17
81131384:	9005883a 	mov	r2,r18
81131388:	8023883a 	mov	r17,r16
8113138c:	0009883a 	mov	r4,zero
81131390:	9821883a 	mov	r16,r19
81131394:	da400a15 	stw	r9,40(sp)
81131398:	1827883a 	mov	r19,r3
8113139c:	b980004c 	andi	r6,r23,1
811313a0:	30000626 	beq	r6,zero,811313bc <_strtod_r+0xf40>
811313a4:	81800017 	ldw	r6,0(r16)
811313a8:	81c00117 	ldw	r7,4(r16)
811313ac:	1009883a 	mov	r4,r2
811313b0:	180b883a 	mov	r5,r3
811313b4:	11220300 	call	81122030 <__muldf3>
811313b8:	01000044 	movi	r4,1
811313bc:	b82fd07a 	srai	r23,r23,1
811313c0:	84000204 	addi	r16,r16,8
811313c4:	b83ff51e 	bne	r23,zero,8113139c <__reset+0xfb11139c>
811313c8:	21003fcc 	andi	r4,r4,255
811313cc:	8821883a 	mov	r16,r17
811313d0:	da400a17 	ldw	r9,40(sp)
811313d4:	9823883a 	mov	r17,r19
811313d8:	2001a51e 	bne	r4,zero,81131a70 <_strtod_r+0x15f4>
811313dc:	d9000917 	ldw	r4,36(sp)
811313e0:	20016d1e 	bne	r4,zero,81131998 <_strtod_r+0x151c>
811313e4:	000d883a 	mov	r6,zero
811313e8:	000f883a 	mov	r7,zero
811313ec:	9009883a 	mov	r4,r18
811313f0:	880b883a 	mov	r5,r17
811313f4:	da401315 	stw	r9,76(sp)
811313f8:	11380680 	call	81138068 <__eqdf2>
811313fc:	da401317 	ldw	r9,76(sp)
81131400:	103df41e 	bne	r2,zero,81130bd4 <__reset+0xfb110bd4>
81131404:	00800884 	movi	r2,34
81131408:	80800015 	stw	r2,0(r16)
8113140c:	002b883a 	mov	r21,zero
81131410:	002d883a 	mov	r22,zero
81131414:	003ce306 	br	811307a4 <__reset+0xfb1107a4>
81131418:	055387c4 	movi	r21,19999
8113141c:	003d6b06 	br	811309cc <__reset+0xfb1109cc>
81131420:	0440d434 	movhi	r17,848
81131424:	1c63883a 	add	r17,r3,r17
81131428:	882d883a 	mov	r22,r17
8113142c:	003ebe06 	br	81130f28 <__reset+0xfb110f28>
81131430:	14403fcc 	andi	r17,r2,255
81131434:	8c40201c 	xori	r17,r17,128
81131438:	8c7fe004 	addi	r17,r17,-128
8113143c:	dd400817 	ldw	r21,32(sp)
81131440:	0027883a 	mov	r19,zero
81131444:	0039883a 	mov	fp,zero
81131448:	002d883a 	mov	r22,zero
8113144c:	003c9906 	br	811306b4 <__reset+0xfb1106b4>
81131450:	00c00944 	movi	r3,37
81131454:	1a47c83a 	sub	r3,r3,r9
81131458:	1d7d8c16 	blt	r3,r21,81130a8c <__reset+0xfb110a8c>
8113145c:	1261c83a 	sub	r16,r2,r9
81131460:	800490fa 	slli	r2,r16,3
81131464:	04e04574 	movhi	r19,33045
81131468:	9ccacd04 	addi	r19,r19,11060
8113146c:	9885883a 	add	r2,r19,r2
81131470:	11000017 	ldw	r4,0(r2)
81131474:	11400117 	ldw	r5,4(r2)
81131478:	900d883a 	mov	r6,r18
8113147c:	880f883a 	mov	r7,r17
81131480:	11220300 	call	81122030 <__muldf3>
81131484:	ac0dc83a 	sub	r6,r21,r16
81131488:	300c90fa 	slli	r6,r6,3
8113148c:	1009883a 	mov	r4,r2
81131490:	180b883a 	mov	r5,r3
81131494:	9985883a 	add	r2,r19,r6
81131498:	11800017 	ldw	r6,0(r2)
8113149c:	11c00117 	ldw	r7,4(r2)
811314a0:	11220300 	call	81122030 <__muldf3>
811314a4:	102b883a 	mov	r21,r2
811314a8:	182d883a 	mov	r22,r3
811314ac:	003cbd06 	br	811307a4 <__reset+0xfb1107a4>
811314b0:	b811883a 	mov	r8,r23
811314b4:	003e8606 	br	81130ed0 <__reset+0xfb110ed0>
811314b8:	d8000d15 	stw	zero,52(sp)
811314bc:	05cffc34 	movhi	r23,16368
811314c0:	003e8006 	br	81130ec4 <__reset+0xfb110ec4>
811314c4:	883f011e 	bne	r17,zero,811310cc <__reset+0xfb1110cc>
811314c8:	dd000a15 	stw	r20,40(sp)
811314cc:	dd001217 	ldw	r20,72(sp)
811314d0:	a811883a 	mov	r8,r21
811314d4:	00800884 	movi	r2,34
811314d8:	80800015 	stw	r2,0(r16)
811314dc:	002b883a 	mov	r21,zero
811314e0:	d8800517 	ldw	r2,20(sp)
811314e4:	002d883a 	mov	r22,zero
811314e8:	003f0a06 	br	81131114 <__reset+0xfb111114>
811314ec:	d9800517 	ldw	r6,20(sp)
811314f0:	30000826 	beq	r6,zero,81131514 <_strtod_r+0x1098>
811314f4:	01400d44 	movi	r5,53
811314f8:	d9000204 	addi	r4,sp,8
811314fc:	d8801315 	stw	r2,76(sp)
81131500:	112fb100 	call	8112fb10 <__copybits>
81131504:	d9400517 	ldw	r5,20(sp)
81131508:	8009883a 	mov	r4,r16
8113150c:	112ec680 	call	8112ec68 <_Bfree>
81131510:	d8801317 	ldw	r2,76(sp)
81131514:	00c00184 	movi	r3,6
81131518:	1d400f36 	bltu	r3,r21,81131558 <_strtod_r+0x10dc>
8113151c:	a82a90ba 	slli	r21,r21,2
81131520:	00e044f4 	movhi	r3,33043
81131524:	18c54d04 	addi	r3,r3,5428
81131528:	a8eb883a 	add	r21,r21,r3
8113152c:	a8c00017 	ldw	r3,0(r21)
81131530:	1800683a 	jmp	r3
81131534:	811315b0 	cmpltui	r4,r16,19542
81131538:	81131588 	cmpgei	r4,r16,19542
8113153c:	8113156c 	andhi	r4,r16,19541
81131540:	81131550 	cmplti	r4,r16,19541
81131544:	81131578 	rdprs	r4,r16,19541
81131548:	81131588 	cmpgei	r4,r16,19542
8113154c:	811315b0 	cmpltui	r4,r16,19542
81131550:	045ffc34 	movhi	r17,32752
81131554:	0025883a 	mov	r18,zero
81131558:	1080020c 	andi	r2,r2,8
8113155c:	902b883a 	mov	r21,r18
81131560:	103c8f26 	beq	r2,zero,811307a0 <__reset+0xfb1107a0>
81131564:	8da00034 	orhi	r22,r17,32768
81131568:	003c8e06 	br	811307a4 <__reset+0xfb1107a4>
8113156c:	dc800217 	ldw	r18,8(sp)
81131570:	dc400317 	ldw	r17,12(sp)
81131574:	003ff806 	br	81131558 <__reset+0xfb111558>
81131578:	04600034 	movhi	r17,32768
8113157c:	8c7fffc4 	addi	r17,r17,-1
81131580:	04bfffc4 	movi	r18,-1
81131584:	003ff406 	br	81131558 <__reset+0xfb111558>
81131588:	d8c00417 	ldw	r3,16(sp)
8113158c:	dc400317 	ldw	r17,12(sp)
81131590:	013ffc34 	movhi	r4,65520
81131594:	18c10cc4 	addi	r3,r3,1075
81131598:	1806953a 	slli	r3,r3,20
8113159c:	213fffc4 	addi	r4,r4,-1
811315a0:	8922703a 	and	r17,r17,r4
811315a4:	dc800217 	ldw	r18,8(sp)
811315a8:	88e2b03a 	or	r17,r17,r3
811315ac:	003fea06 	br	81131558 <__reset+0xfb111558>
811315b0:	0023883a 	mov	r17,zero
811315b4:	0025883a 	mov	r18,zero
811315b8:	003fe706 	br	81131558 <__reset+0xfb111558>
811315bc:	01800044 	movi	r6,1
811315c0:	50d5883a 	add	r10,r10,r3
811315c4:	2a4b883a 	add	r5,r5,r9
811315c8:	19811a26 	beq	r3,r6,81131a34 <_strtod_r+0x15b8>
811315cc:	01800204 	movi	r6,8
811315d0:	01c00404 	movi	r7,16
811315d4:	4a400044 	addi	r9,r9,1
811315d8:	48bfffc4 	addi	r2,r9,-1
811315dc:	30801616 	blt	r6,r2,81131638 <_strtod_r+0x11bc>
811315e0:	e70002a4 	muli	fp,fp,10
811315e4:	497ffb1e 	bne	r9,r5,811315d4 <__reset+0xfb1115d4>
811315e8:	d9800617 	ldw	r6,24(sp)
811315ec:	4a400044 	addi	r9,r9,1
811315f0:	00c00204 	movi	r3,8
811315f4:	19400c0e 	bge	r3,r5,81131628 <_strtod_r+0x11ac>
811315f8:	00800404 	movi	r2,16
811315fc:	000b883a 	mov	r5,zero
81131600:	127ea316 	blt	r2,r9,81131090 <__reset+0xfb111090>
81131604:	988002a4 	muli	r2,r19,10
81131608:	20a7883a 	add	r19,r4,r2
8113160c:	003ea006 	br	81131090 <__reset+0xfb111090>
81131610:	d8800617 	ldw	r2,24(sp)
81131614:	8c7ff404 	addi	r17,r17,-48
81131618:	2a800044 	addi	r10,r5,1
8113161c:	d8800815 	stw	r2,32(sp)
81131620:	100d883a 	mov	r6,r2
81131624:	02400044 	movi	r9,1
81131628:	e08002a4 	muli	r2,fp,10
8113162c:	000b883a 	mov	r5,zero
81131630:	88b9883a 	add	fp,r17,r2
81131634:	003e9606 	br	81131090 <__reset+0xfb111090>
81131638:	3a7fea16 	blt	r7,r9,811315e4 <__reset+0xfb1115e4>
8113163c:	9cc002a4 	muli	r19,r19,10
81131640:	003fe806 	br	811315e4 <__reset+0xfb1115e4>
81131644:	00bffa84 	movi	r2,-22
81131648:	a8bd1016 	blt	r21,r2,81130a8c <__reset+0xfb110a8c>
8113164c:	a82a90fa 	slli	r21,r21,3
81131650:	00a04574 	movhi	r2,33045
81131654:	108acd04 	addi	r2,r2,11060
81131658:	1545c83a 	sub	r2,r2,r21
8113165c:	11800017 	ldw	r6,0(r2)
81131660:	11c00117 	ldw	r7,4(r2)
81131664:	9009883a 	mov	r4,r18
81131668:	880b883a 	mov	r5,r17
8113166c:	11377780 	call	81137778 <__divdf3>
81131670:	102b883a 	mov	r21,r2
81131674:	182d883a 	mov	r22,r3
81131678:	003c4a06 	br	811307a4 <__reset+0xfb1107a4>
8113167c:	dd000a15 	stw	r20,40(sp)
81131680:	a811883a 	mov	r8,r21
81131684:	dd001217 	ldw	r20,72(sp)
81131688:	003e9e06 	br	81131104 <__reset+0xfb111104>
8113168c:	01604574 	movhi	r5,33045
81131690:	d9000617 	ldw	r4,24(sp)
81131694:	294aff04 	addi	r5,r5,11260
81131698:	01c00644 	movi	r7,25
8113169c:	00000b06 	br	811316cc <_strtod_r+0x1250>
811316a0:	21000044 	addi	r4,r4,1
811316a4:	20800003 	ldbu	r2,0(r4)
811316a8:	10ffefc4 	addi	r3,r2,-65
811316ac:	10803fcc 	andi	r2,r2,255
811316b0:	1080201c 	xori	r2,r2,128
811316b4:	18c03fcc 	andi	r3,r3,255
811316b8:	10bfe004 	addi	r2,r2,-128
811316bc:	38c00136 	bltu	r7,r3,811316c4 <_strtod_r+0x1248>
811316c0:	10800804 	addi	r2,r2,32
811316c4:	29400044 	addi	r5,r5,1
811316c8:	11bbbb1e 	bne	r2,r6,811305b8 <__reset+0xfb1105b8>
811316cc:	29800007 	ldb	r6,0(r5)
811316d0:	303ff31e 	bne	r6,zero,811316a0 <__reset+0xfb1116a0>
811316d4:	01a04574 	movhi	r6,33045
811316d8:	d9000615 	stw	r4,24(sp)
811316dc:	318b0004 	addi	r6,r6,11264
811316e0:	200b883a 	mov	r5,r4
811316e4:	02000644 	movi	r8,25
811316e8:	00000a06 	br	81131714 <_strtod_r+0x1298>
811316ec:	28800003 	ldbu	r2,0(r5)
811316f0:	10ffefc4 	addi	r3,r2,-65
811316f4:	10803fcc 	andi	r2,r2,255
811316f8:	1080201c 	xori	r2,r2,128
811316fc:	18c03fcc 	andi	r3,r3,255
81131700:	10bfe004 	addi	r2,r2,-128
81131704:	40c00136 	bltu	r8,r3,8113170c <_strtod_r+0x1290>
81131708:	10800804 	addi	r2,r2,32
8113170c:	31800044 	addi	r6,r6,1
81131710:	11c0711e 	bne	r2,r7,811318d8 <_strtod_r+0x145c>
81131714:	31c00007 	ldb	r7,0(r6)
81131718:	29400044 	addi	r5,r5,1
8113171c:	383ff31e 	bne	r7,zero,811316ec <__reset+0xfb1116ec>
81131720:	d9400615 	stw	r5,24(sp)
81131724:	045ffc34 	movhi	r17,32752
81131728:	0025883a 	mov	r18,zero
8113172c:	003c1b06 	br	8113079c <__reset+0xfb11079c>
81131730:	000b883a 	mov	r5,zero
81131734:	003ccc06 	br	81130a68 <__reset+0xfb110a68>
81131738:	d9400e17 	ldw	r5,56(sp)
8113173c:	dd000a15 	stw	r20,40(sp)
81131740:	00800434 	movhi	r2,16
81131744:	a811883a 	mov	r8,r21
81131748:	dd001217 	ldw	r20,72(sp)
8113174c:	dd401117 	ldw	r21,68(sp)
81131750:	dd801017 	ldw	r22,64(sp)
81131754:	10bfffc4 	addi	r2,r2,-1
81131758:	28005626 	beq	r5,zero,811318b4 <_strtod_r+0x1438>
8113175c:	8886703a 	and	r3,r17,r2
81131760:	18807826 	beq	r3,r2,81131944 <_strtod_r+0x14c8>
81131764:	d8c00b17 	ldw	r3,44(sp)
81131768:	18005726 	beq	r3,zero,811318c8 <_strtod_r+0x144c>
8113176c:	1c44703a 	and	r2,r3,r17
81131770:	10000f26 	beq	r2,zero,811317b0 <_strtod_r+0x1334>
81131774:	d9000e17 	ldw	r4,56(sp)
81131778:	d9800917 	ldw	r6,36(sp)
8113177c:	20005e26 	beq	r4,zero,811318f8 <_strtod_r+0x147c>
81131780:	9009883a 	mov	r4,r18
81131784:	880b883a 	mov	r5,r17
81131788:	da001315 	stw	r8,76(sp)
8113178c:	11304100 	call	81130410 <sulp>
81131790:	100d883a 	mov	r6,r2
81131794:	180f883a 	mov	r7,r3
81131798:	9009883a 	mov	r4,r18
8113179c:	880b883a 	mov	r5,r17
811317a0:	1136ec40 	call	81136ec4 <__adddf3>
811317a4:	da001317 	ldw	r8,76(sp)
811317a8:	102b883a 	mov	r21,r2
811317ac:	182d883a 	mov	r22,r3
811317b0:	d8c00917 	ldw	r3,36(sp)
811317b4:	18000f26 	beq	r3,zero,811317f4 <_strtod_r+0x1378>
811317b8:	a809883a 	mov	r4,r21
811317bc:	b00b883a 	mov	r5,r22
811317c0:	000d883a 	mov	r6,zero
811317c4:	01ce5434 	movhi	r7,14672
811317c8:	da001315 	stw	r8,76(sp)
811317cc:	11220300 	call	81122030 <__muldf3>
811317d0:	102b883a 	mov	r21,r2
811317d4:	182d883a 	mov	r22,r3
811317d8:	da001317 	ldw	r8,76(sp)
811317dc:	1800051e 	bne	r3,zero,811317f4 <_strtod_r+0x1378>
811317e0:	d8800517 	ldw	r2,20(sp)
811317e4:	a83e4b1e 	bne	r21,zero,81131114 <__reset+0xfb111114>
811317e8:	00c00884 	movi	r3,34
811317ec:	80c00015 	stw	r3,0(r16)
811317f0:	003e4806 	br	81131114 <__reset+0xfb111114>
811317f4:	d8800517 	ldw	r2,20(sp)
811317f8:	003e4606 	br	81131114 <__reset+0xfb111114>
811317fc:	d9000e17 	ldw	r4,56(sp)
81131800:	dd000a15 	stw	r20,40(sp)
81131804:	a811883a 	mov	r8,r21
81131808:	dd001217 	ldw	r20,72(sp)
8113180c:	dd401117 	ldw	r21,68(sp)
81131810:	dd801017 	ldw	r22,64(sp)
81131814:	203fe61e 	bne	r4,zero,811317b0 <__reset+0xfb1117b0>
81131818:	903fe51e 	bne	r18,zero,811317b0 <__reset+0xfb1117b0>
8113181c:	00800434 	movhi	r2,16
81131820:	10bfffc4 	addi	r2,r2,-1
81131824:	8884703a 	and	r2,r17,r2
81131828:	103fe11e 	bne	r2,zero,811317b0 <__reset+0xfb1117b0>
8113182c:	8ddffc2c 	andhi	r23,r17,32752
81131830:	0081ac34 	movhi	r2,1712
81131834:	15ffde2e 	bgeu	r2,r23,811317b0 <__reset+0xfb1117b0>
81131838:	40800517 	ldw	r2,20(r8)
8113183c:	1000031e 	bne	r2,zero,8113184c <_strtod_r+0x13d0>
81131840:	40800417 	ldw	r2,16(r8)
81131844:	00c00044 	movi	r3,1
81131848:	18bfd90e 	bge	r3,r2,811317b0 <__reset+0xfb1117b0>
8113184c:	400b883a 	mov	r5,r8
81131850:	01800044 	movi	r6,1
81131854:	8009883a 	mov	r4,r16
81131858:	112f3680 	call	8112f368 <__lshift>
8113185c:	980b883a 	mov	r5,r19
81131860:	1009883a 	mov	r4,r2
81131864:	d8801315 	stw	r2,76(sp)
81131868:	112f4b80 	call	8112f4b8 <__mcmp>
8113186c:	da001317 	ldw	r8,76(sp)
81131870:	00bfcf0e 	bge	zero,r2,811317b0 <__reset+0xfb1117b0>
81131874:	d8c00917 	ldw	r3,36(sp)
81131878:	18005c26 	beq	r3,zero,811319ec <_strtod_r+0x1570>
8113187c:	0081ac34 	movhi	r2,1712
81131880:	15c05a16 	blt	r2,r23,811319ec <_strtod_r+0x1570>
81131884:	0080dc34 	movhi	r2,880
81131888:	15ffcb16 	blt	r2,r23,811317b8 <__reset+0xfb1117b8>
8113188c:	003f1106 	br	811314d4 <__reset+0xfb1114d4>
81131890:	002d883a 	mov	r22,zero
81131894:	022ff834 	movhi	r8,49120
81131898:	d8000d15 	stw	zero,52(sp)
8113189c:	05cff834 	movhi	r23,16352
811318a0:	003ded06 	br	81131058 <__reset+0xfb111058>
811318a4:	0440d434 	movhi	r17,848
811318a8:	1c63883a 	add	r17,r3,r17
811318ac:	d8000915 	stw	zero,36(sp)
811318b0:	003cc806 	br	81130bd4 <__reset+0xfb110bd4>
811318b4:	8884703a 	and	r2,r17,r2
811318b8:	103faa1e 	bne	r2,zero,81131764 <__reset+0xfb111764>
811318bc:	903fa91e 	bne	r18,zero,81131764 <__reset+0xfb111764>
811318c0:	8ddffc2c 	andhi	r23,r17,32752
811318c4:	003feb06 	br	81131874 <__reset+0xfb111874>
811318c8:	d8c00d17 	ldw	r3,52(sp)
811318cc:	1cae703a 	and	r23,r3,r18
811318d0:	b83fb726 	beq	r23,zero,811317b0 <__reset+0xfb1117b0>
811318d4:	003fa706 	br	81131774 <__reset+0xfb111774>
811318d8:	21000044 	addi	r4,r4,1
811318dc:	d9000615 	stw	r4,24(sp)
811318e0:	003f9006 	br	81131724 <__reset+0xfb111724>
811318e4:	01604574 	movhi	r5,33045
811318e8:	294ac304 	addi	r5,r5,11020
811318ec:	d9400915 	stw	r5,36(sp)
811318f0:	0027883a 	mov	r19,zero
811318f4:	003ca206 	br	81130b80 <__reset+0xfb110b80>
811318f8:	9009883a 	mov	r4,r18
811318fc:	880b883a 	mov	r5,r17
81131900:	da001315 	stw	r8,76(sp)
81131904:	11304100 	call	81130410 <sulp>
81131908:	100d883a 	mov	r6,r2
8113190c:	180f883a 	mov	r7,r3
81131910:	9009883a 	mov	r4,r18
81131914:	880b883a 	mov	r5,r17
81131918:	11227500 	call	81122750 <__subdf3>
8113191c:	000d883a 	mov	r6,zero
81131920:	000f883a 	mov	r7,zero
81131924:	1009883a 	mov	r4,r2
81131928:	180b883a 	mov	r5,r3
8113192c:	102b883a 	mov	r21,r2
81131930:	182d883a 	mov	r22,r3
81131934:	11380680 	call	81138068 <__eqdf2>
81131938:	da001317 	ldw	r8,76(sp)
8113193c:	103ee526 	beq	r2,zero,811314d4 <__reset+0xfb1114d4>
81131940:	003f9b06 	br	811317b0 <__reset+0xfb1117b0>
81131944:	d8800917 	ldw	r2,36(sp)
81131948:	10002226 	beq	r2,zero,811319d4 <_strtod_r+0x1558>
8113194c:	889ffc2c 	andhi	r2,r17,32752
81131950:	00c1a834 	movhi	r3,1696
81131954:	18801f36 	bltu	r3,r2,811319d4 <_strtod_r+0x1558>
81131958:	1004d53a 	srli	r2,r2,20
8113195c:	00c01ac4 	movi	r3,107
81131960:	1887c83a 	sub	r3,r3,r2
81131964:	00bfffc4 	movi	r2,-1
81131968:	10c4983a 	sll	r2,r2,r3
8113196c:	14bf7d1e 	bne	r2,r18,81131764 <__reset+0xfb111764>
81131970:	00dffc34 	movhi	r3,32752
81131974:	18ffffc4 	addi	r3,r3,-1
81131978:	88c03526 	beq	r17,r3,81131a50 <_strtod_r+0x15d4>
8113197c:	8c5ffc2c 	andhi	r17,r17,32752
81131980:	00800434 	movhi	r2,16
81131984:	002b883a 	mov	r21,zero
81131988:	88ad883a 	add	r22,r17,r2
8113198c:	003f8806 	br	811317b0 <__reset+0xfb1117b0>
81131990:	01401a84 	movi	r5,106
81131994:	d9400915 	stw	r5,36(sp)
81131998:	8ddffc2c 	andhi	r23,r17,32752
8113199c:	b82ed53a 	srli	r23,r23,20
811319a0:	00801ac4 	movi	r2,107
811319a4:	15c5c83a 	sub	r2,r2,r23
811319a8:	00be8e0e 	bge	zero,r2,811313e4 <__reset+0xfb1113e4>
811319ac:	00c007c4 	movi	r3,31
811319b0:	18800a0e 	bge	r3,r2,811319dc <_strtod_r+0x1560>
811319b4:	00c00d04 	movi	r3,52
811319b8:	0025883a 	mov	r18,zero
811319bc:	1880270e 	bge	r3,r2,81131a5c <_strtod_r+0x15e0>
811319c0:	0440dc34 	movhi	r17,880
811319c4:	003e8706 	br	811313e4 <__reset+0xfb1113e4>
811319c8:	d8000915 	stw	zero,36(sp)
811319cc:	05fe6a16 	blt	zero,r23,81131378 <__reset+0xfb111378>
811319d0:	003e8406 	br	811313e4 <__reset+0xfb1113e4>
811319d4:	00bfffc4 	movi	r2,-1
811319d8:	003fe406 	br	8113196c <__reset+0xfb11196c>
811319dc:	00ffffc4 	movi	r3,-1
811319e0:	1884983a 	sll	r2,r3,r2
811319e4:	14a4703a 	and	r18,r2,r18
811319e8:	003e7e06 	br	811313e4 <__reset+0xfb1113e4>
811319ec:	00bffc34 	movhi	r2,65520
811319f0:	b8af883a 	add	r23,r23,r2
811319f4:	057fffc4 	movi	r21,-1
811319f8:	00800434 	movhi	r2,16
811319fc:	1545883a 	add	r2,r2,r21
81131a00:	b8acb03a 	or	r22,r23,r2
81131a04:	003f6a06 	br	811317b0 <__reset+0xfb1117b0>
81131a08:	01604574 	movhi	r5,33045
81131a0c:	294b0304 	addi	r5,r5,11276
81131a10:	d9800204 	addi	r6,sp,8
81131a14:	d9000604 	addi	r4,sp,24
81131a18:	1135b200 	call	81135b20 <__hexnan>
81131a1c:	00c00144 	movi	r3,5
81131a20:	10fb5c1e 	bne	r2,r3,81130794 <__reset+0xfb110794>
81131a24:	dc400317 	ldw	r17,12(sp)
81131a28:	dc800217 	ldw	r18,8(sp)
81131a2c:	8c5ffc34 	orhi	r17,r17,32752
81131a30:	003b5a06 	br	8113079c <__reset+0xfb11079c>
81131a34:	480b883a 	mov	r5,r9
81131a38:	d9800617 	ldw	r6,24(sp)
81131a3c:	4a400044 	addi	r9,r9,1
81131a40:	003eeb06 	br	811315f0 <__reset+0xfb1115f0>
81131a44:	1025883a 	mov	r18,r2
81131a48:	1823883a 	mov	r17,r3
81131a4c:	003c4c06 	br	81130b80 <__reset+0xfb110b80>
81131a50:	00ffffc4 	movi	r3,-1
81131a54:	10ffc91e 	bne	r2,r3,8113197c <__reset+0xfb11197c>
81131a58:	003da906 	br	81131100 <__reset+0xfb111100>
81131a5c:	10bff804 	addi	r2,r2,-32
81131a60:	00ffffc4 	movi	r3,-1
81131a64:	1884983a 	sll	r2,r3,r2
81131a68:	1462703a 	and	r17,r2,r17
81131a6c:	003e5d06 	br	811313e4 <__reset+0xfb1113e4>
81131a70:	1025883a 	mov	r18,r2
81131a74:	1823883a 	mov	r17,r3
81131a78:	003e5806 	br	811313dc <__reset+0xfb1113dc>

81131a7c <strtod>:
81131a7c:	00a04574 	movhi	r2,33045
81131a80:	10945c04 	addi	r2,r2,20848
81131a84:	280d883a 	mov	r6,r5
81131a88:	200b883a 	mov	r5,r4
81131a8c:	11000017 	ldw	r4,0(r2)
81131a90:	113047c1 	jmpi	8113047c <_strtod_r>

81131a94 <strtof>:
81131a94:	defffb04 	addi	sp,sp,-20
81131a98:	de00012e 	bgeu	sp,et,81131aa0 <strtof+0xc>
81131a9c:	003b68fa 	trap	3
81131aa0:	dcc00315 	stw	r19,12(sp)
81131aa4:	04e04574 	movhi	r19,33045
81131aa8:	9cd45c04 	addi	r19,r19,20848
81131aac:	280d883a 	mov	r6,r5
81131ab0:	200b883a 	mov	r5,r4
81131ab4:	99000017 	ldw	r4,0(r19)
81131ab8:	dfc00415 	stw	ra,16(sp)
81131abc:	dc800215 	stw	r18,8(sp)
81131ac0:	dc400115 	stw	r17,4(sp)
81131ac4:	dc000015 	stw	r16,0(sp)
81131ac8:	113047c0 	call	8113047c <_strtod_r>
81131acc:	1009883a 	mov	r4,r2
81131ad0:	180b883a 	mov	r5,r3
81131ad4:	1025883a 	mov	r18,r2
81131ad8:	1823883a 	mov	r17,r3
81131adc:	11232d00 	call	811232d0 <__truncdfsf2>
81131ae0:	000b883a 	mov	r5,zero
81131ae4:	1009883a 	mov	r4,r2
81131ae8:	1021883a 	mov	r16,r2
81131aec:	1136cc80 	call	81136cc8 <__eqsf2>
81131af0:	1000111e 	bne	r2,zero,81131b38 <strtof+0xa4>
81131af4:	000d883a 	mov	r6,zero
81131af8:	000f883a 	mov	r7,zero
81131afc:	9009883a 	mov	r4,r18
81131b00:	880b883a 	mov	r5,r17
81131b04:	11380680 	call	81138068 <__eqdf2>
81131b08:	10000b26 	beq	r2,zero,81131b38 <strtof+0xa4>
81131b0c:	98800017 	ldw	r2,0(r19)
81131b10:	00c00884 	movi	r3,34
81131b14:	10c00015 	stw	r3,0(r2)
81131b18:	8005883a 	mov	r2,r16
81131b1c:	dfc00417 	ldw	ra,16(sp)
81131b20:	dcc00317 	ldw	r19,12(sp)
81131b24:	dc800217 	ldw	r18,8(sp)
81131b28:	dc400117 	ldw	r17,4(sp)
81131b2c:	dc000017 	ldw	r16,0(sp)
81131b30:	dec00504 	addi	sp,sp,20
81131b34:	f800283a 	ret
81131b38:	015fe034 	movhi	r5,32640
81131b3c:	297fffc4 	addi	r5,r5,-1
81131b40:	8009883a 	mov	r4,r16
81131b44:	1136d400 	call	81136d40 <__gesf2>
81131b48:	0080070e 	bge	zero,r2,81131b68 <strtof+0xd4>
81131b4c:	01dffc34 	movhi	r7,32752
81131b50:	39ffffc4 	addi	r7,r7,-1
81131b54:	01bfffc4 	movi	r6,-1
81131b58:	9009883a 	mov	r4,r18
81131b5c:	880b883a 	mov	r5,r17
81131b60:	1121f540 	call	81121f54 <__gedf2>
81131b64:	00bfe90e 	bge	zero,r2,81131b0c <__reset+0xfb111b0c>
81131b68:	017fe034 	movhi	r5,65408
81131b6c:	297fffc4 	addi	r5,r5,-1
81131b70:	8009883a 	mov	r4,r16
81131b74:	1136dfc0 	call	81136dfc <__lesf2>
81131b78:	103fe70e 	bge	r2,zero,81131b18 <__reset+0xfb111b18>
81131b7c:	01fffc34 	movhi	r7,65520
81131b80:	39ffffc4 	addi	r7,r7,-1
81131b84:	01bfffc4 	movi	r6,-1
81131b88:	9009883a 	mov	r4,r18
81131b8c:	880b883a 	mov	r5,r17
81131b90:	11380f00 	call	811380f0 <__ledf2>
81131b94:	103fdd0e 	bge	r2,zero,81131b0c <__reset+0xfb111b0c>
81131b98:	003fdf06 	br	81131b18 <__reset+0xfb111b18>

81131b9c <_strtoul_r>:
81131b9c:	00a04574 	movhi	r2,33045
81131ba0:	defff604 	addi	sp,sp,-40
81131ba4:	10945a04 	addi	r2,r2,20840
81131ba8:	de00012e 	bgeu	sp,et,81131bb0 <_strtoul_r+0x14>
81131bac:	003b68fa 	trap	3
81131bb0:	dc800315 	stw	r18,12(sp)
81131bb4:	14800017 	ldw	r18,0(r2)
81131bb8:	dd400615 	stw	r21,24(sp)
81131bbc:	dd000515 	stw	r20,20(sp)
81131bc0:	dcc00415 	stw	r19,16(sp)
81131bc4:	2029883a 	mov	r20,r4
81131bc8:	dfc00915 	stw	ra,36(sp)
81131bcc:	ddc00815 	stw	r23,32(sp)
81131bd0:	dd800715 	stw	r22,28(sp)
81131bd4:	dc400215 	stw	r17,8(sp)
81131bd8:	dc000115 	stw	r16,4(sp)
81131bdc:	2827883a 	mov	r19,r5
81131be0:	382b883a 	mov	r21,r7
81131be4:	2809883a 	mov	r4,r5
81131be8:	24000003 	ldbu	r16,0(r4)
81131bec:	24400044 	addi	r17,r4,1
81131bf0:	2007883a 	mov	r3,r4
81131bf4:	9405883a 	add	r2,r18,r16
81131bf8:	10800043 	ldbu	r2,1(r2)
81131bfc:	8809883a 	mov	r4,r17
81131c00:	1080020c 	andi	r2,r2,8
81131c04:	103ff81e 	bne	r2,zero,81131be8 <__reset+0xfb111be8>
81131c08:	00800b44 	movi	r2,45
81131c0c:	80805326 	beq	r16,r2,81131d5c <_strtoul_r+0x1c0>
81131c10:	00800ac4 	movi	r2,43
81131c14:	80805526 	beq	r16,r2,81131d6c <_strtoul_r+0x1d0>
81131c18:	002f883a 	mov	r23,zero
81131c1c:	a8000f26 	beq	r21,zero,81131c5c <_strtoul_r+0xc0>
81131c20:	00800404 	movi	r2,16
81131c24:	a8805f26 	beq	r21,r2,81131da4 <_strtoul_r+0x208>
81131c28:	013fffc4 	movi	r4,-1
81131c2c:	a80b883a 	mov	r5,r21
81131c30:	d9800015 	stw	r6,0(sp)
81131c34:	1136c0c0 	call	81136c0c <__udivsi3>
81131c38:	a80b883a 	mov	r5,r21
81131c3c:	013fffc4 	movi	r4,-1
81131c40:	102d883a 	mov	r22,r2
81131c44:	1136c700 	call	81136c70 <__umodsi3>
81131c48:	d9800017 	ldw	r6,0(sp)
81131c4c:	1019883a 	mov	r12,r2
81131c50:	a817883a 	mov	r11,r21
81131c54:	b00f883a 	mov	r7,r22
81131c58:	00000706 	br	81131c78 <_strtoul_r+0xdc>
81131c5c:	00800c04 	movi	r2,48
81131c60:	80804626 	beq	r16,r2,81131d7c <_strtoul_r+0x1e0>
81131c64:	05400284 	movi	r21,10
81131c68:	01c666b4 	movhi	r7,6554
81131c6c:	03000144 	movi	r12,5
81131c70:	39e66644 	addi	r7,r7,-26215
81131c74:	a817883a 	mov	r11,r21
81131c78:	9407883a 	add	r3,r18,r16
81131c7c:	18c00043 	ldbu	r3,1(r3)
81131c80:	8809883a 	mov	r4,r17
81131c84:	0011883a 	mov	r8,zero
81131c88:	1940010c 	andi	r5,r3,4
81131c8c:	0005883a 	mov	r2,zero
81131c90:	02800044 	movi	r10,1
81131c94:	027fffc4 	movi	r9,-1
81131c98:	28000e26 	beq	r5,zero,81131cd4 <_strtoul_r+0x138>
81131c9c:	843ff404 	addi	r16,r16,-48
81131ca0:	8540120e 	bge	r16,r21,81131cec <_strtoul_r+0x150>
81131ca4:	42400526 	beq	r8,r9,81131cbc <_strtoul_r+0x120>
81131ca8:	38802236 	bltu	r7,r2,81131d34 <_strtoul_r+0x198>
81131cac:	11c02026 	beq	r2,r7,81131d30 <_strtoul_r+0x194>
81131cb0:	12c5383a 	mul	r2,r2,r11
81131cb4:	02000044 	movi	r8,1
81131cb8:	8085883a 	add	r2,r16,r2
81131cbc:	24000003 	ldbu	r16,0(r4)
81131cc0:	21000044 	addi	r4,r4,1
81131cc4:	9407883a 	add	r3,r18,r16
81131cc8:	18c00043 	ldbu	r3,1(r3)
81131ccc:	1940010c 	andi	r5,r3,4
81131cd0:	283ff21e 	bne	r5,zero,81131c9c <__reset+0xfb111c9c>
81131cd4:	18c000cc 	andi	r3,r3,3
81131cd8:	18000426 	beq	r3,zero,81131cec <_strtoul_r+0x150>
81131cdc:	1a801726 	beq	r3,r10,81131d3c <_strtoul_r+0x1a0>
81131ce0:	00c015c4 	movi	r3,87
81131ce4:	80e1c83a 	sub	r16,r16,r3
81131ce8:	857fee16 	blt	r16,r21,81131ca4 <__reset+0xfb111ca4>
81131cec:	40001516 	blt	r8,zero,81131d44 <_strtoul_r+0x1a8>
81131cf0:	b8000126 	beq	r23,zero,81131cf8 <_strtoul_r+0x15c>
81131cf4:	0085c83a 	sub	r2,zero,r2
81131cf8:	30000226 	beq	r6,zero,81131d04 <_strtoul_r+0x168>
81131cfc:	4000151e 	bne	r8,zero,81131d54 <_strtoul_r+0x1b8>
81131d00:	34c00015 	stw	r19,0(r6)
81131d04:	dfc00917 	ldw	ra,36(sp)
81131d08:	ddc00817 	ldw	r23,32(sp)
81131d0c:	dd800717 	ldw	r22,28(sp)
81131d10:	dd400617 	ldw	r21,24(sp)
81131d14:	dd000517 	ldw	r20,20(sp)
81131d18:	dcc00417 	ldw	r19,16(sp)
81131d1c:	dc800317 	ldw	r18,12(sp)
81131d20:	dc400217 	ldw	r17,8(sp)
81131d24:	dc000117 	ldw	r16,4(sp)
81131d28:	dec00a04 	addi	sp,sp,40
81131d2c:	f800283a 	ret
81131d30:	643fdf0e 	bge	r12,r16,81131cb0 <__reset+0xfb111cb0>
81131d34:	023fffc4 	movi	r8,-1
81131d38:	003fe006 	br	81131cbc <__reset+0xfb111cbc>
81131d3c:	00c00dc4 	movi	r3,55
81131d40:	003fe806 	br	81131ce4 <__reset+0xfb111ce4>
81131d44:	00800884 	movi	r2,34
81131d48:	a0800015 	stw	r2,0(r20)
81131d4c:	00bfffc4 	movi	r2,-1
81131d50:	303fec26 	beq	r6,zero,81131d04 <__reset+0xfb111d04>
81131d54:	24ffffc4 	addi	r19,r4,-1
81131d58:	003fe906 	br	81131d00 <__reset+0xfb111d00>
81131d5c:	1c400084 	addi	r17,r3,2
81131d60:	1c000043 	ldbu	r16,1(r3)
81131d64:	05c00044 	movi	r23,1
81131d68:	003fac06 	br	81131c1c <__reset+0xfb111c1c>
81131d6c:	1c400084 	addi	r17,r3,2
81131d70:	1c000043 	ldbu	r16,1(r3)
81131d74:	002f883a 	mov	r23,zero
81131d78:	003fa806 	br	81131c1c <__reset+0xfb111c1c>
81131d7c:	88800003 	ldbu	r2,0(r17)
81131d80:	00c01604 	movi	r3,88
81131d84:	108037cc 	andi	r2,r2,223
81131d88:	10c00c26 	beq	r2,r3,81131dbc <_strtoul_r+0x220>
81131d8c:	05400204 	movi	r21,8
81131d90:	01c80034 	movhi	r7,8192
81131d94:	030001c4 	movi	r12,7
81131d98:	39ffffc4 	addi	r7,r7,-1
81131d9c:	a817883a 	mov	r11,r21
81131da0:	003fb506 	br	81131c78 <__reset+0xfb111c78>
81131da4:	00800c04 	movi	r2,48
81131da8:	80800c1e 	bne	r16,r2,81131ddc <_strtoul_r+0x240>
81131dac:	88800003 	ldbu	r2,0(r17)
81131db0:	00c01604 	movi	r3,88
81131db4:	108037cc 	andi	r2,r2,223
81131db8:	10c0081e 	bne	r2,r3,81131ddc <_strtoul_r+0x240>
81131dbc:	02c00404 	movi	r11,16
81131dc0:	05840034 	movhi	r22,4096
81131dc4:	8c000043 	ldbu	r16,1(r17)
81131dc8:	030003c4 	movi	r12,15
81131dcc:	8c400084 	addi	r17,r17,2
81131dd0:	b5bfffc4 	addi	r22,r22,-1
81131dd4:	582b883a 	mov	r21,r11
81131dd8:	003f9e06 	br	81131c54 <__reset+0xfb111c54>
81131ddc:	01c40034 	movhi	r7,4096
81131de0:	030003c4 	movi	r12,15
81131de4:	39ffffc4 	addi	r7,r7,-1
81131de8:	a817883a 	mov	r11,r21
81131dec:	003fa206 	br	81131c78 <__reset+0xfb111c78>

81131df0 <strtoul>:
81131df0:	00a04574 	movhi	r2,33045
81131df4:	10945c04 	addi	r2,r2,20848
81131df8:	300f883a 	mov	r7,r6
81131dfc:	280d883a 	mov	r6,r5
81131e00:	200b883a 	mov	r5,r4
81131e04:	11000017 	ldw	r4,0(r2)
81131e08:	1131b9c1 	jmpi	81131b9c <_strtoul_r>

81131e0c <_strtoull_r>:
81131e0c:	00a04574 	movhi	r2,33045
81131e10:	defff404 	addi	sp,sp,-48
81131e14:	10945a04 	addi	r2,r2,20840
81131e18:	de00012e 	bgeu	sp,et,81131e20 <_strtoull_r+0x14>
81131e1c:	003b68fa 	trap	3
81131e20:	dc400315 	stw	r17,12(sp)
81131e24:	14400017 	ldw	r17,0(r2)
81131e28:	dd400715 	stw	r21,28(sp)
81131e2c:	dd000615 	stw	r20,24(sp)
81131e30:	dcc00515 	stw	r19,20(sp)
81131e34:	dc800415 	stw	r18,16(sp)
81131e38:	dfc00b15 	stw	ra,44(sp)
81131e3c:	df000a15 	stw	fp,40(sp)
81131e40:	ddc00915 	stw	r23,36(sp)
81131e44:	dd800815 	stw	r22,32(sp)
81131e48:	dc000215 	stw	r16,8(sp)
81131e4c:	2827883a 	mov	r19,r5
81131e50:	202b883a 	mov	r21,r4
81131e54:	3029883a 	mov	r20,r6
81131e58:	3825883a 	mov	r18,r7
81131e5c:	2807883a 	mov	r3,r5
81131e60:	1c000003 	ldbu	r16,0(r3)
81131e64:	1f000044 	addi	fp,r3,1
81131e68:	1809883a 	mov	r4,r3
81131e6c:	8c05883a 	add	r2,r17,r16
81131e70:	10800043 	ldbu	r2,1(r2)
81131e74:	e007883a 	mov	r3,fp
81131e78:	1080020c 	andi	r2,r2,8
81131e7c:	103ff81e 	bne	r2,zero,81131e60 <__reset+0xfb111e60>
81131e80:	00800b44 	movi	r2,45
81131e84:	80806e26 	beq	r16,r2,81132040 <_strtoull_r+0x234>
81131e88:	00800ac4 	movi	r2,43
81131e8c:	80807026 	beq	r16,r2,81132050 <_strtoull_r+0x244>
81131e90:	002f883a 	mov	r23,zero
81131e94:	90001426 	beq	r18,zero,81131ee8 <_strtoull_r+0xdc>
81131e98:	00800404 	movi	r2,16
81131e9c:	90807c26 	beq	r18,r2,81132090 <_strtoull_r+0x284>
81131ea0:	902dd7fa 	srai	r22,r18,31
81131ea4:	013fffc4 	movi	r4,-1
81131ea8:	200b883a 	mov	r5,r4
81131eac:	900d883a 	mov	r6,r18
81131eb0:	b00f883a 	mov	r7,r22
81131eb4:	11360540 	call	81136054 <__udivdi3>
81131eb8:	013fffc4 	movi	r4,-1
81131ebc:	900d883a 	mov	r6,r18
81131ec0:	b00f883a 	mov	r7,r22
81131ec4:	200b883a 	mov	r5,r4
81131ec8:	d8c00115 	stw	r3,4(sp)
81131ecc:	d8800015 	stw	r2,0(sp)
81131ed0:	11365d40 	call	811365d4 <__umoddi3>
81131ed4:	101b883a 	mov	r13,r2
81131ed8:	9015883a 	mov	r10,r18
81131edc:	dac00017 	ldw	r11,0(sp)
81131ee0:	da000117 	ldw	r8,4(sp)
81131ee4:	00000a06 	br	81131f10 <_strtoull_r+0x104>
81131ee8:	00800c04 	movi	r2,48
81131eec:	80805c26 	beq	r16,r2,81132060 <_strtoull_r+0x254>
81131ef0:	02800284 	movi	r10,10
81131ef4:	02e666b4 	movhi	r11,39322
81131ef8:	020666b4 	movhi	r8,6554
81131efc:	03400144 	movi	r13,5
81131f00:	5ae66644 	addi	r11,r11,-26215
81131f04:	42266644 	addi	r8,r8,-26215
81131f08:	002d883a 	mov	r22,zero
81131f0c:	5025883a 	mov	r18,r10
81131f10:	8c0b883a 	add	r5,r17,r16
81131f14:	29400043 	ldbu	r5,1(r5)
81131f18:	e009883a 	mov	r4,fp
81131f1c:	000f883a 	mov	r7,zero
81131f20:	2980010c 	andi	r6,r5,4
81131f24:	0005883a 	mov	r2,zero
81131f28:	0007883a 	mov	r3,zero
81131f2c:	03000044 	movi	r12,1
81131f30:	027fffc4 	movi	r9,-1
81131f34:	30000d26 	beq	r6,zero,81131f6c <_strtoull_r+0x160>
81131f38:	843ff404 	addi	r16,r16,-48
81131f3c:	8480110e 	bge	r16,r18,81131f84 <_strtoull_r+0x178>
81131f40:	3a400426 	beq	r7,r9,81131f54 <_strtoull_r+0x148>
81131f44:	40c00236 	bltu	r8,r3,81131f50 <_strtoull_r+0x144>
81131f48:	1a00231e 	bne	r3,r8,81131fd8 <_strtoull_r+0x1cc>
81131f4c:	5880222e 	bgeu	r11,r2,81131fd8 <_strtoull_r+0x1cc>
81131f50:	01ffffc4 	movi	r7,-1
81131f54:	24000003 	ldbu	r16,0(r4)
81131f58:	21000044 	addi	r4,r4,1
81131f5c:	8c0b883a 	add	r5,r17,r16
81131f60:	29400043 	ldbu	r5,1(r5)
81131f64:	2980010c 	andi	r6,r5,4
81131f68:	303ff31e 	bne	r6,zero,81131f38 <__reset+0xfb111f38>
81131f6c:	294000cc 	andi	r5,r5,3
81131f70:	28000426 	beq	r5,zero,81131f84 <_strtoull_r+0x178>
81131f74:	2b002626 	beq	r5,r12,81132010 <_strtoull_r+0x204>
81131f78:	014015c4 	movi	r5,87
81131f7c:	8161c83a 	sub	r16,r16,r5
81131f80:	84bfef16 	blt	r16,r18,81131f40 <__reset+0xfb111f40>
81131f84:	38002716 	blt	r7,zero,81132024 <_strtoull_r+0x218>
81131f88:	b8000426 	beq	r23,zero,81131f9c <_strtoull_r+0x190>
81131f8c:	0085c83a 	sub	r2,zero,r2
81131f90:	100ac03a 	cmpne	r5,r2,zero
81131f94:	00e1c83a 	sub	r16,zero,r3
81131f98:	8147c83a 	sub	r3,r16,r5
81131f9c:	a0000226 	beq	r20,zero,81131fa8 <_strtoull_r+0x19c>
81131fa0:	3800251e 	bne	r7,zero,81132038 <_strtoull_r+0x22c>
81131fa4:	a4c00015 	stw	r19,0(r20)
81131fa8:	dfc00b17 	ldw	ra,44(sp)
81131fac:	df000a17 	ldw	fp,40(sp)
81131fb0:	ddc00917 	ldw	r23,36(sp)
81131fb4:	dd800817 	ldw	r22,32(sp)
81131fb8:	dd400717 	ldw	r21,28(sp)
81131fbc:	dd000617 	ldw	r20,24(sp)
81131fc0:	dcc00517 	ldw	r19,20(sp)
81131fc4:	dc800417 	ldw	r18,16(sp)
81131fc8:	dc400317 	ldw	r17,12(sp)
81131fcc:	dc000217 	ldw	r16,8(sp)
81131fd0:	dec00c04 	addi	sp,sp,48
81131fd4:	f800283a 	ret
81131fd8:	12c00f26 	beq	r2,r11,81132018 <_strtoull_r+0x20c>
81131fdc:	b08d383a 	mul	r6,r22,r2
81131fe0:	1a87383a 	mul	r3,r3,r10
81131fe4:	128a383a 	mulxuu	r5,r2,r10
81131fe8:	1285383a 	mul	r2,r2,r10
81131fec:	800fd7fa 	srai	r7,r16,31
81131ff0:	1987883a 	add	r3,r3,r6
81131ff4:	8085883a 	add	r2,r16,r2
81131ff8:	1947883a 	add	r3,r3,r5
81131ffc:	38c7883a 	add	r3,r7,r3
81132000:	1421803a 	cmpltu	r16,r2,r16
81132004:	80c7883a 	add	r3,r16,r3
81132008:	01c00044 	movi	r7,1
8113200c:	003fd106 	br	81131f54 <__reset+0xfb111f54>
81132010:	01400dc4 	movi	r5,55
81132014:	003fd906 	br	81131f7c <__reset+0xfb111f7c>
81132018:	1a3ff01e 	bne	r3,r8,81131fdc <__reset+0xfb111fdc>
8113201c:	6c3fcc16 	blt	r13,r16,81131f50 <__reset+0xfb111f50>
81132020:	003fee06 	br	81131fdc <__reset+0xfb111fdc>
81132024:	00800884 	movi	r2,34
81132028:	a8800015 	stw	r2,0(r21)
8113202c:	00bfffc4 	movi	r2,-1
81132030:	1007883a 	mov	r3,r2
81132034:	a03fdc26 	beq	r20,zero,81131fa8 <__reset+0xfb111fa8>
81132038:	24ffffc4 	addi	r19,r4,-1
8113203c:	003fd906 	br	81131fa4 <__reset+0xfb111fa4>
81132040:	27000084 	addi	fp,r4,2
81132044:	24000043 	ldbu	r16,1(r4)
81132048:	05c00044 	movi	r23,1
8113204c:	003f9106 	br	81131e94 <__reset+0xfb111e94>
81132050:	27000084 	addi	fp,r4,2
81132054:	24000043 	ldbu	r16,1(r4)
81132058:	002f883a 	mov	r23,zero
8113205c:	003f8d06 	br	81131e94 <__reset+0xfb111e94>
81132060:	e0800003 	ldbu	r2,0(fp)
81132064:	00c01604 	movi	r3,88
81132068:	108037cc 	andi	r2,r2,223
8113206c:	10c00e26 	beq	r2,r3,811320a8 <_strtoull_r+0x29c>
81132070:	02800204 	movi	r10,8
81132074:	02ffffc4 	movi	r11,-1
81132078:	02080034 	movhi	r8,8192
8113207c:	034001c4 	movi	r13,7
81132080:	42d1883a 	add	r8,r8,r11
81132084:	002d883a 	mov	r22,zero
81132088:	5025883a 	mov	r18,r10
8113208c:	003fa006 	br	81131f10 <__reset+0xfb111f10>
81132090:	00800c04 	movi	r2,48
81132094:	80800e1e 	bne	r16,r2,811320d0 <_strtoull_r+0x2c4>
81132098:	e0800003 	ldbu	r2,0(fp)
8113209c:	00c01604 	movi	r3,88
811320a0:	108037cc 	andi	r2,r2,223
811320a4:	10c00a1e 	bne	r2,r3,811320d0 <_strtoull_r+0x2c4>
811320a8:	02800404 	movi	r10,16
811320ac:	02ffffc4 	movi	r11,-1
811320b0:	02040034 	movhi	r8,4096
811320b4:	e4000043 	ldbu	r16,1(fp)
811320b8:	034003c4 	movi	r13,15
811320bc:	e7000084 	addi	fp,fp,2
811320c0:	42d1883a 	add	r8,r8,r11
811320c4:	002d883a 	mov	r22,zero
811320c8:	5025883a 	mov	r18,r10
811320cc:	003f9006 	br	81131f10 <__reset+0xfb111f10>
811320d0:	02ffffc4 	movi	r11,-1
811320d4:	02040034 	movhi	r8,4096
811320d8:	034003c4 	movi	r13,15
811320dc:	42d1883a 	add	r8,r8,r11
811320e0:	9015883a 	mov	r10,r18
811320e4:	002d883a 	mov	r22,zero
811320e8:	003f8906 	br	81131f10 <__reset+0xfb111f10>

811320ec <__ssprint_r>:
811320ec:	defff604 	addi	sp,sp,-40
811320f0:	de00012e 	bgeu	sp,et,811320f8 <__ssprint_r+0xc>
811320f4:	003b68fa 	trap	3
811320f8:	30800217 	ldw	r2,8(r6)
811320fc:	dc800215 	stw	r18,8(sp)
81132100:	dfc00915 	stw	ra,36(sp)
81132104:	df000815 	stw	fp,32(sp)
81132108:	ddc00715 	stw	r23,28(sp)
8113210c:	dd800615 	stw	r22,24(sp)
81132110:	dd400515 	stw	r21,20(sp)
81132114:	dd000415 	stw	r20,16(sp)
81132118:	dcc00315 	stw	r19,12(sp)
8113211c:	dc400115 	stw	r17,4(sp)
81132120:	dc000015 	stw	r16,0(sp)
81132124:	3025883a 	mov	r18,r6
81132128:	10005826 	beq	r2,zero,8113228c <__ssprint_r+0x1a0>
8113212c:	2027883a 	mov	r19,r4
81132130:	35c00017 	ldw	r23,0(r6)
81132134:	29000017 	ldw	r4,0(r5)
81132138:	28800217 	ldw	r2,8(r5)
8113213c:	2823883a 	mov	r17,r5
81132140:	0039883a 	mov	fp,zero
81132144:	0021883a 	mov	r16,zero
81132148:	80003926 	beq	r16,zero,81132230 <__ssprint_r+0x144>
8113214c:	102b883a 	mov	r21,r2
81132150:	102d883a 	mov	r22,r2
81132154:	80803a36 	bltu	r16,r2,81132240 <__ssprint_r+0x154>
81132158:	88c0030b 	ldhu	r3,12(r17)
8113215c:	1881200c 	andi	r2,r3,1152
81132160:	10002626 	beq	r2,zero,811321fc <__ssprint_r+0x110>
81132164:	88800517 	ldw	r2,20(r17)
81132168:	89400417 	ldw	r5,16(r17)
8113216c:	81800044 	addi	r6,r16,1
81132170:	108f883a 	add	r7,r2,r2
81132174:	3885883a 	add	r2,r7,r2
81132178:	100ed7fa 	srli	r7,r2,31
8113217c:	216dc83a 	sub	r22,r4,r5
81132180:	3589883a 	add	r4,r6,r22
81132184:	3885883a 	add	r2,r7,r2
81132188:	102bd07a 	srai	r21,r2,1
8113218c:	a80d883a 	mov	r6,r21
81132190:	a900022e 	bgeu	r21,r4,8113219c <__ssprint_r+0xb0>
81132194:	202b883a 	mov	r21,r4
81132198:	200d883a 	mov	r6,r4
8113219c:	18c1000c 	andi	r3,r3,1024
811321a0:	18002a26 	beq	r3,zero,8113224c <__ssprint_r+0x160>
811321a4:	300b883a 	mov	r5,r6
811321a8:	9809883a 	mov	r4,r19
811321ac:	1123eec0 	call	81123eec <_malloc_r>
811321b0:	1029883a 	mov	r20,r2
811321b4:	10002c26 	beq	r2,zero,81132268 <__ssprint_r+0x17c>
811321b8:	89400417 	ldw	r5,16(r17)
811321bc:	b00d883a 	mov	r6,r22
811321c0:	1009883a 	mov	r4,r2
811321c4:	11247000 	call	81124700 <memcpy>
811321c8:	8880030b 	ldhu	r2,12(r17)
811321cc:	00fedfc4 	movi	r3,-1153
811321d0:	10c4703a 	and	r2,r2,r3
811321d4:	10802014 	ori	r2,r2,128
811321d8:	8880030d 	sth	r2,12(r17)
811321dc:	a589883a 	add	r4,r20,r22
811321e0:	adadc83a 	sub	r22,r21,r22
811321e4:	8d400515 	stw	r21,20(r17)
811321e8:	8d800215 	stw	r22,8(r17)
811321ec:	8d000415 	stw	r20,16(r17)
811321f0:	89000015 	stw	r4,0(r17)
811321f4:	802b883a 	mov	r21,r16
811321f8:	802d883a 	mov	r22,r16
811321fc:	b00d883a 	mov	r6,r22
81132200:	e00b883a 	mov	r5,fp
81132204:	112ea5c0 	call	8112ea5c <memmove>
81132208:	88800217 	ldw	r2,8(r17)
8113220c:	89000017 	ldw	r4,0(r17)
81132210:	90c00217 	ldw	r3,8(r18)
81132214:	1545c83a 	sub	r2,r2,r21
81132218:	2589883a 	add	r4,r4,r22
8113221c:	88800215 	stw	r2,8(r17)
81132220:	89000015 	stw	r4,0(r17)
81132224:	1c21c83a 	sub	r16,r3,r16
81132228:	94000215 	stw	r16,8(r18)
8113222c:	80001726 	beq	r16,zero,8113228c <__ssprint_r+0x1a0>
81132230:	bf000017 	ldw	fp,0(r23)
81132234:	bc000117 	ldw	r16,4(r23)
81132238:	bdc00204 	addi	r23,r23,8
8113223c:	003fc206 	br	81132148 <__reset+0xfb112148>
81132240:	802b883a 	mov	r21,r16
81132244:	802d883a 	mov	r22,r16
81132248:	003fec06 	br	811321fc <__reset+0xfb1121fc>
8113224c:	9809883a 	mov	r4,r19
81132250:	112fc7c0 	call	8112fc7c <_realloc_r>
81132254:	1029883a 	mov	r20,r2
81132258:	103fe01e 	bne	r2,zero,811321dc <__reset+0xfb1121dc>
8113225c:	89400417 	ldw	r5,16(r17)
81132260:	9809883a 	mov	r4,r19
81132264:	112dbe80 	call	8112dbe8 <_free_r>
81132268:	88c0030b 	ldhu	r3,12(r17)
8113226c:	00800304 	movi	r2,12
81132270:	98800015 	stw	r2,0(r19)
81132274:	18c01014 	ori	r3,r3,64
81132278:	88c0030d 	sth	r3,12(r17)
8113227c:	00bfffc4 	movi	r2,-1
81132280:	90000215 	stw	zero,8(r18)
81132284:	90000115 	stw	zero,4(r18)
81132288:	00000206 	br	81132294 <__ssprint_r+0x1a8>
8113228c:	90000115 	stw	zero,4(r18)
81132290:	0005883a 	mov	r2,zero
81132294:	dfc00917 	ldw	ra,36(sp)
81132298:	df000817 	ldw	fp,32(sp)
8113229c:	ddc00717 	ldw	r23,28(sp)
811322a0:	dd800617 	ldw	r22,24(sp)
811322a4:	dd400517 	ldw	r21,20(sp)
811322a8:	dd000417 	ldw	r20,16(sp)
811322ac:	dcc00317 	ldw	r19,12(sp)
811322b0:	dc800217 	ldw	r18,8(sp)
811322b4:	dc400117 	ldw	r17,4(sp)
811322b8:	dc000017 	ldw	r16,0(sp)
811322bc:	dec00a04 	addi	sp,sp,40
811322c0:	f800283a 	ret

811322c4 <___svfiprintf_internal_r>:
811322c4:	deffc804 	addi	sp,sp,-224
811322c8:	de00012e 	bgeu	sp,et,811322d0 <___svfiprintf_internal_r+0xc>
811322cc:	003b68fa 	trap	3
811322d0:	2880030b 	ldhu	r2,12(r5)
811322d4:	dcc03115 	stw	r19,196(sp)
811322d8:	dfc03715 	stw	ra,220(sp)
811322dc:	df003615 	stw	fp,216(sp)
811322e0:	ddc03515 	stw	r23,212(sp)
811322e4:	dd803415 	stw	r22,208(sp)
811322e8:	dd403315 	stw	r21,204(sp)
811322ec:	dd003215 	stw	r20,200(sp)
811322f0:	dc803015 	stw	r18,192(sp)
811322f4:	dc402f15 	stw	r17,188(sp)
811322f8:	dc002e15 	stw	r16,184(sp)
811322fc:	d9402715 	stw	r5,156(sp)
81132300:	d9002a15 	stw	r4,168(sp)
81132304:	1080200c 	andi	r2,r2,128
81132308:	d9c02315 	stw	r7,140(sp)
8113230c:	3027883a 	mov	r19,r6
81132310:	10000226 	beq	r2,zero,8113231c <___svfiprintf_internal_r+0x58>
81132314:	28800417 	ldw	r2,16(r5)
81132318:	10041d26 	beq	r2,zero,81133390 <___svfiprintf_internal_r+0x10cc>
8113231c:	dac01a04 	addi	r11,sp,104
81132320:	dac01e15 	stw	r11,120(sp)
81132324:	d8801e17 	ldw	r2,120(sp)
81132328:	dac019c4 	addi	r11,sp,103
8113232c:	dd402a17 	ldw	r21,168(sp)
81132330:	ddc02717 	ldw	r23,156(sp)
81132334:	05a04574 	movhi	r22,33045
81132338:	05204574 	movhi	r20,33045
8113233c:	dac01f15 	stw	r11,124(sp)
81132340:	12d7c83a 	sub	r11,r2,r11
81132344:	b58b1b04 	addi	r22,r22,11372
81132348:	a50b1704 	addi	r20,r20,11356
8113234c:	dec01a15 	stw	sp,104(sp)
81132350:	d8001c15 	stw	zero,112(sp)
81132354:	d8001b15 	stw	zero,108(sp)
81132358:	d811883a 	mov	r8,sp
8113235c:	d8002915 	stw	zero,164(sp)
81132360:	d8002515 	stw	zero,148(sp)
81132364:	dac02b15 	stw	r11,172(sp)
81132368:	98800007 	ldb	r2,0(r19)
8113236c:	1002dd26 	beq	r2,zero,81132ee4 <___svfiprintf_internal_r+0xc20>
81132370:	00c00944 	movi	r3,37
81132374:	9823883a 	mov	r17,r19
81132378:	10c0021e 	bne	r2,r3,81132384 <___svfiprintf_internal_r+0xc0>
8113237c:	00001406 	br	811323d0 <___svfiprintf_internal_r+0x10c>
81132380:	10c00326 	beq	r2,r3,81132390 <___svfiprintf_internal_r+0xcc>
81132384:	8c400044 	addi	r17,r17,1
81132388:	88800007 	ldb	r2,0(r17)
8113238c:	103ffc1e 	bne	r2,zero,81132380 <__reset+0xfb112380>
81132390:	8ce1c83a 	sub	r16,r17,r19
81132394:	80000e26 	beq	r16,zero,811323d0 <___svfiprintf_internal_r+0x10c>
81132398:	d8c01c17 	ldw	r3,112(sp)
8113239c:	d8801b17 	ldw	r2,108(sp)
811323a0:	44c00015 	stw	r19,0(r8)
811323a4:	1c07883a 	add	r3,r3,r16
811323a8:	10800044 	addi	r2,r2,1
811323ac:	d8c01c15 	stw	r3,112(sp)
811323b0:	44000115 	stw	r16,4(r8)
811323b4:	d8801b15 	stw	r2,108(sp)
811323b8:	00c001c4 	movi	r3,7
811323bc:	18831e16 	blt	r3,r2,81133038 <___svfiprintf_internal_r+0xd74>
811323c0:	42000204 	addi	r8,r8,8
811323c4:	dac02517 	ldw	r11,148(sp)
811323c8:	5c17883a 	add	r11,r11,r16
811323cc:	dac02515 	stw	r11,148(sp)
811323d0:	88800007 	ldb	r2,0(r17)
811323d4:	1002c526 	beq	r2,zero,81132eec <___svfiprintf_internal_r+0xc28>
811323d8:	88c00047 	ldb	r3,1(r17)
811323dc:	8cc00044 	addi	r19,r17,1
811323e0:	d8001d85 	stb	zero,118(sp)
811323e4:	0009883a 	mov	r4,zero
811323e8:	000f883a 	mov	r7,zero
811323ec:	043fffc4 	movi	r16,-1
811323f0:	d8002415 	stw	zero,144(sp)
811323f4:	0025883a 	mov	r18,zero
811323f8:	01401604 	movi	r5,88
811323fc:	01800244 	movi	r6,9
81132400:	02800a84 	movi	r10,42
81132404:	02401b04 	movi	r9,108
81132408:	9cc00044 	addi	r19,r19,1
8113240c:	18bff804 	addi	r2,r3,-32
81132410:	2881dd36 	bltu	r5,r2,81132b88 <___svfiprintf_internal_r+0x8c4>
81132414:	100490ba 	slli	r2,r2,2
81132418:	02e044f4 	movhi	r11,33043
8113241c:	5ac90b04 	addi	r11,r11,9260
81132420:	12c5883a 	add	r2,r2,r11
81132424:	10800017 	ldw	r2,0(r2)
81132428:	1000683a 	jmp	r2
8113242c:	81132628 	cmpgeui	r4,r16,19608
81132430:	81132b88 	cmpgei	r4,r16,19630
81132434:	81132b88 	cmpgei	r4,r16,19630
81132438:	8113261c 	xori	r4,r16,19608
8113243c:	81132b88 	cmpgei	r4,r16,19630
81132440:	81132b88 	cmpgei	r4,r16,19630
81132444:	81132b88 	cmpgei	r4,r16,19630
81132448:	81132b88 	cmpgei	r4,r16,19630
8113244c:	81132b88 	cmpgei	r4,r16,19630
81132450:	81132b88 	cmpgei	r4,r16,19630
81132454:	81132590 	cmplti	r4,r16,19606
81132458:	8113276c 	andhi	r4,r16,19613
8113245c:	81132b88 	cmpgei	r4,r16,19630
81132460:	811325bc 	xorhi	r4,r16,19606
81132464:	81132bbc 	xorhi	r4,r16,19630
81132468:	81132b88 	cmpgei	r4,r16,19630
8113246c:	81132bb0 	cmpltui	r4,r16,19630
81132470:	81132b50 	cmplti	r4,r16,19629
81132474:	81132b50 	cmplti	r4,r16,19629
81132478:	81132b50 	cmplti	r4,r16,19629
8113247c:	81132b50 	cmplti	r4,r16,19629
81132480:	81132b50 	cmplti	r4,r16,19629
81132484:	81132b50 	cmplti	r4,r16,19629
81132488:	81132b50 	cmplti	r4,r16,19629
8113248c:	81132b50 	cmplti	r4,r16,19629
81132490:	81132b50 	cmplti	r4,r16,19629
81132494:	81132b88 	cmpgei	r4,r16,19630
81132498:	81132b88 	cmpgei	r4,r16,19630
8113249c:	81132b88 	cmpgei	r4,r16,19630
811324a0:	81132b88 	cmpgei	r4,r16,19630
811324a4:	81132b88 	cmpgei	r4,r16,19630
811324a8:	81132b88 	cmpgei	r4,r16,19630
811324ac:	81132b88 	cmpgei	r4,r16,19630
811324b0:	81132b88 	cmpgei	r4,r16,19630
811324b4:	81132b88 	cmpgei	r4,r16,19630
811324b8:	81132b88 	cmpgei	r4,r16,19630
811324bc:	81132aec 	andhi	r4,r16,19627
811324c0:	81132b88 	cmpgei	r4,r16,19630
811324c4:	81132b88 	cmpgei	r4,r16,19630
811324c8:	81132b88 	cmpgei	r4,r16,19630
811324cc:	81132b88 	cmpgei	r4,r16,19630
811324d0:	81132b88 	cmpgei	r4,r16,19630
811324d4:	81132b88 	cmpgei	r4,r16,19630
811324d8:	81132b88 	cmpgei	r4,r16,19630
811324dc:	81132b88 	cmpgei	r4,r16,19630
811324e0:	81132b88 	cmpgei	r4,r16,19630
811324e4:	81132b88 	cmpgei	r4,r16,19630
811324e8:	81132c64 	muli	r4,r16,19633
811324ec:	81132b88 	cmpgei	r4,r16,19630
811324f0:	81132b88 	cmpgei	r4,r16,19630
811324f4:	81132b88 	cmpgei	r4,r16,19630
811324f8:	81132b88 	cmpgei	r4,r16,19630
811324fc:	81132b88 	cmpgei	r4,r16,19630
81132500:	81132bfc 	xorhi	r4,r16,19631
81132504:	81132b88 	cmpgei	r4,r16,19630
81132508:	81132b88 	cmpgei	r4,r16,19630
8113250c:	81132930 	cmpltui	r4,r16,19620
81132510:	81132b88 	cmpgei	r4,r16,19630
81132514:	81132b88 	cmpgei	r4,r16,19630
81132518:	81132b88 	cmpgei	r4,r16,19630
8113251c:	81132b88 	cmpgei	r4,r16,19630
81132520:	81132b88 	cmpgei	r4,r16,19630
81132524:	81132b88 	cmpgei	r4,r16,19630
81132528:	81132b88 	cmpgei	r4,r16,19630
8113252c:	81132b88 	cmpgei	r4,r16,19630
81132530:	81132b88 	cmpgei	r4,r16,19630
81132534:	81132b88 	cmpgei	r4,r16,19630
81132538:	81132820 	cmpeqi	r4,r16,19616
8113253c:	811329cc 	andi	r4,r16,19623
81132540:	81132b88 	cmpgei	r4,r16,19630
81132544:	81132b88 	cmpgei	r4,r16,19630
81132548:	81132b88 	cmpgei	r4,r16,19630
8113254c:	811329c0 	call	8811329c <__reset+0x20f329c>
81132550:	811329cc 	andi	r4,r16,19623
81132554:	81132b88 	cmpgei	r4,r16,19630
81132558:	81132b88 	cmpgei	r4,r16,19630
8113255c:	811329b0 	cmpltui	r4,r16,19622
81132560:	81132b88 	cmpgei	r4,r16,19630
81132564:	81132974 	orhi	r4,r16,19621
81132568:	8113277c 	xorhi	r4,r16,19613
8113256c:	811325c8 	cmpgei	r4,r16,19607
81132570:	81132ae0 	cmpeqi	r4,r16,19627
81132574:	81132b88 	cmpgei	r4,r16,19630
81132578:	81132a94 	ori	r4,r16,19626
8113257c:	81132b88 	cmpgei	r4,r16,19630
81132580:	811326ec 	andhi	r4,r16,19611
81132584:	81132b88 	cmpgei	r4,r16,19630
81132588:	81132b88 	cmpgei	r4,r16,19630
8113258c:	81132648 	cmpgei	r4,r16,19609
81132590:	dac02317 	ldw	r11,140(sp)
81132594:	5ac00017 	ldw	r11,0(r11)
81132598:	dac02415 	stw	r11,144(sp)
8113259c:	dac02317 	ldw	r11,140(sp)
811325a0:	58800104 	addi	r2,r11,4
811325a4:	dac02417 	ldw	r11,144(sp)
811325a8:	5802e90e 	bge	r11,zero,81133150 <___svfiprintf_internal_r+0xe8c>
811325ac:	dac02417 	ldw	r11,144(sp)
811325b0:	d8802315 	stw	r2,140(sp)
811325b4:	02d7c83a 	sub	r11,zero,r11
811325b8:	dac02415 	stw	r11,144(sp)
811325bc:	94800114 	ori	r18,r18,4
811325c0:	98c00007 	ldb	r3,0(r19)
811325c4:	003f9006 	br	81132408 <__reset+0xfb112408>
811325c8:	00800c04 	movi	r2,48
811325cc:	dac02317 	ldw	r11,140(sp)
811325d0:	d8801d05 	stb	r2,116(sp)
811325d4:	00801e04 	movi	r2,120
811325d8:	d8801d45 	stb	r2,117(sp)
811325dc:	d8001d85 	stb	zero,118(sp)
811325e0:	58c00104 	addi	r3,r11,4
811325e4:	5f000017 	ldw	fp,0(r11)
811325e8:	0013883a 	mov	r9,zero
811325ec:	90800094 	ori	r2,r18,2
811325f0:	80032b16 	blt	r16,zero,811332a0 <___svfiprintf_internal_r+0xfdc>
811325f4:	00bfdfc4 	movi	r2,-129
811325f8:	90a4703a 	and	r18,r18,r2
811325fc:	d8c02315 	stw	r3,140(sp)
81132600:	94800094 	ori	r18,r18,2
81132604:	e002dc26 	beq	fp,zero,81133178 <___svfiprintf_internal_r+0xeb4>
81132608:	01204574 	movhi	r4,33045
8113260c:	210a8d04 	addi	r4,r4,10804
81132610:	0015883a 	mov	r10,zero
81132614:	d9002915 	stw	r4,164(sp)
81132618:	00002306 	br	811326a8 <___svfiprintf_internal_r+0x3e4>
8113261c:	94800054 	ori	r18,r18,1
81132620:	98c00007 	ldb	r3,0(r19)
81132624:	003f7806 	br	81132408 <__reset+0xfb112408>
81132628:	38803fcc 	andi	r2,r7,255
8113262c:	1080201c 	xori	r2,r2,128
81132630:	10bfe004 	addi	r2,r2,-128
81132634:	1002f31e 	bne	r2,zero,81133204 <___svfiprintf_internal_r+0xf40>
81132638:	01000044 	movi	r4,1
8113263c:	01c00804 	movi	r7,32
81132640:	98c00007 	ldb	r3,0(r19)
81132644:	003f7006 	br	81132408 <__reset+0xfb112408>
81132648:	21003fcc 	andi	r4,r4,255
8113264c:	2003aa1e 	bne	r4,zero,811334f8 <___svfiprintf_internal_r+0x1234>
81132650:	00a04574 	movhi	r2,33045
81132654:	108a8d04 	addi	r2,r2,10804
81132658:	d8802915 	stw	r2,164(sp)
8113265c:	9080080c 	andi	r2,r18,32
81132660:	1000ba26 	beq	r2,zero,8113294c <___svfiprintf_internal_r+0x688>
81132664:	dac02317 	ldw	r11,140(sp)
81132668:	5f000017 	ldw	fp,0(r11)
8113266c:	5a400117 	ldw	r9,4(r11)
81132670:	5ac00204 	addi	r11,r11,8
81132674:	dac02315 	stw	r11,140(sp)
81132678:	9080004c 	andi	r2,r18,1
8113267c:	10029026 	beq	r2,zero,811330c0 <___svfiprintf_internal_r+0xdfc>
81132680:	e244b03a 	or	r2,fp,r9
81132684:	1002d41e 	bne	r2,zero,811331d8 <___svfiprintf_internal_r+0xf14>
81132688:	d8001d85 	stb	zero,118(sp)
8113268c:	80030b16 	blt	r16,zero,811332bc <___svfiprintf_internal_r+0xff8>
81132690:	00bfdfc4 	movi	r2,-129
81132694:	90a4703a 	and	r18,r18,r2
81132698:	0015883a 	mov	r10,zero
8113269c:	80002426 	beq	r16,zero,81132730 <___svfiprintf_internal_r+0x46c>
811326a0:	0039883a 	mov	fp,zero
811326a4:	0013883a 	mov	r9,zero
811326a8:	d9002917 	ldw	r4,164(sp)
811326ac:	dc401a04 	addi	r17,sp,104
811326b0:	e08003cc 	andi	r2,fp,15
811326b4:	4806973a 	slli	r3,r9,28
811326b8:	2085883a 	add	r2,r4,r2
811326bc:	e038d13a 	srli	fp,fp,4
811326c0:	10800003 	ldbu	r2,0(r2)
811326c4:	4812d13a 	srli	r9,r9,4
811326c8:	8c7fffc4 	addi	r17,r17,-1
811326cc:	1f38b03a 	or	fp,r3,fp
811326d0:	88800005 	stb	r2,0(r17)
811326d4:	e244b03a 	or	r2,fp,r9
811326d8:	103ff51e 	bne	r2,zero,811326b0 <__reset+0xfb1126b0>
811326dc:	dac01e17 	ldw	r11,120(sp)
811326e0:	5c57c83a 	sub	r11,r11,r17
811326e4:	dac02115 	stw	r11,132(sp)
811326e8:	00001406 	br	8113273c <___svfiprintf_internal_r+0x478>
811326ec:	21003fcc 	andi	r4,r4,255
811326f0:	2003741e 	bne	r4,zero,811334c4 <___svfiprintf_internal_r+0x1200>
811326f4:	9080080c 	andi	r2,r18,32
811326f8:	10014526 	beq	r2,zero,81132c10 <___svfiprintf_internal_r+0x94c>
811326fc:	dac02317 	ldw	r11,140(sp)
81132700:	d8001d85 	stb	zero,118(sp)
81132704:	58c00204 	addi	r3,r11,8
81132708:	5f000017 	ldw	fp,0(r11)
8113270c:	5a400117 	ldw	r9,4(r11)
81132710:	8002d916 	blt	r16,zero,81133278 <___svfiprintf_internal_r+0xfb4>
81132714:	013fdfc4 	movi	r4,-129
81132718:	e244b03a 	or	r2,fp,r9
8113271c:	d8c02315 	stw	r3,140(sp)
81132720:	9124703a 	and	r18,r18,r4
81132724:	0015883a 	mov	r10,zero
81132728:	1000b91e 	bne	r2,zero,81132a10 <___svfiprintf_internal_r+0x74c>
8113272c:	8002e61e 	bne	r16,zero,811332c8 <___svfiprintf_internal_r+0x1004>
81132730:	0021883a 	mov	r16,zero
81132734:	d8002115 	stw	zero,132(sp)
81132738:	dc401a04 	addi	r17,sp,104
8113273c:	d8c02117 	ldw	r3,132(sp)
81132740:	dc002015 	stw	r16,128(sp)
81132744:	80c0010e 	bge	r16,r3,8113274c <___svfiprintf_internal_r+0x488>
81132748:	d8c02015 	stw	r3,128(sp)
8113274c:	52803fcc 	andi	r10,r10,255
81132750:	5280201c 	xori	r10,r10,128
81132754:	52bfe004 	addi	r10,r10,-128
81132758:	50003c26 	beq	r10,zero,8113284c <___svfiprintf_internal_r+0x588>
8113275c:	dac02017 	ldw	r11,128(sp)
81132760:	5ac00044 	addi	r11,r11,1
81132764:	dac02015 	stw	r11,128(sp)
81132768:	00003806 	br	8113284c <___svfiprintf_internal_r+0x588>
8113276c:	01000044 	movi	r4,1
81132770:	01c00ac4 	movi	r7,43
81132774:	98c00007 	ldb	r3,0(r19)
81132778:	003f2306 	br	81132408 <__reset+0xfb112408>
8113277c:	21003fcc 	andi	r4,r4,255
81132780:	2003481e 	bne	r4,zero,811334a4 <___svfiprintf_internal_r+0x11e0>
81132784:	9080080c 	andi	r2,r18,32
81132788:	10013b26 	beq	r2,zero,81132c78 <___svfiprintf_internal_r+0x9b4>
8113278c:	dac02317 	ldw	r11,140(sp)
81132790:	d8001d85 	stb	zero,118(sp)
81132794:	58800204 	addi	r2,r11,8
81132798:	5f000017 	ldw	fp,0(r11)
8113279c:	5a400117 	ldw	r9,4(r11)
811327a0:	8002a816 	blt	r16,zero,81133244 <___svfiprintf_internal_r+0xf80>
811327a4:	013fdfc4 	movi	r4,-129
811327a8:	e246b03a 	or	r3,fp,r9
811327ac:	d8802315 	stw	r2,140(sp)
811327b0:	9124703a 	and	r18,r18,r4
811327b4:	18013c26 	beq	r3,zero,81132ca8 <___svfiprintf_internal_r+0x9e4>
811327b8:	0015883a 	mov	r10,zero
811327bc:	dc401a04 	addi	r17,sp,104
811327c0:	e006d0fa 	srli	r3,fp,3
811327c4:	4808977a 	slli	r4,r9,29
811327c8:	4812d0fa 	srli	r9,r9,3
811327cc:	e70001cc 	andi	fp,fp,7
811327d0:	e0800c04 	addi	r2,fp,48
811327d4:	8c7fffc4 	addi	r17,r17,-1
811327d8:	20f8b03a 	or	fp,r4,r3
811327dc:	88800005 	stb	r2,0(r17)
811327e0:	e246b03a 	or	r3,fp,r9
811327e4:	183ff61e 	bne	r3,zero,811327c0 <__reset+0xfb1127c0>
811327e8:	90c0004c 	andi	r3,r18,1
811327ec:	1800a526 	beq	r3,zero,81132a84 <___svfiprintf_internal_r+0x7c0>
811327f0:	10803fcc 	andi	r2,r2,255
811327f4:	1080201c 	xori	r2,r2,128
811327f8:	10bfe004 	addi	r2,r2,-128
811327fc:	00c00c04 	movi	r3,48
81132800:	10ffb626 	beq	r2,r3,811326dc <__reset+0xfb1126dc>
81132804:	88ffffc5 	stb	r3,-1(r17)
81132808:	d8c01e17 	ldw	r3,120(sp)
8113280c:	88bfffc4 	addi	r2,r17,-1
81132810:	1023883a 	mov	r17,r2
81132814:	1887c83a 	sub	r3,r3,r2
81132818:	d8c02115 	stw	r3,132(sp)
8113281c:	003fc706 	br	8113273c <__reset+0xfb11273c>
81132820:	dac02317 	ldw	r11,140(sp)
81132824:	00c00044 	movi	r3,1
81132828:	d8c02015 	stw	r3,128(sp)
8113282c:	58800017 	ldw	r2,0(r11)
81132830:	5ac00104 	addi	r11,r11,4
81132834:	d8001d85 	stb	zero,118(sp)
81132838:	d8801005 	stb	r2,64(sp)
8113283c:	dac02315 	stw	r11,140(sp)
81132840:	d8c02115 	stw	r3,132(sp)
81132844:	dc401004 	addi	r17,sp,64
81132848:	0021883a 	mov	r16,zero
8113284c:	90c0008c 	andi	r3,r18,2
81132850:	d8c02215 	stw	r3,136(sp)
81132854:	18000326 	beq	r3,zero,81132864 <___svfiprintf_internal_r+0x5a0>
81132858:	dac02017 	ldw	r11,128(sp)
8113285c:	5ac00084 	addi	r11,r11,2
81132860:	dac02015 	stw	r11,128(sp)
81132864:	90c0210c 	andi	r3,r18,132
81132868:	d8c02615 	stw	r3,152(sp)
8113286c:	1801131e 	bne	r3,zero,81132cbc <___svfiprintf_internal_r+0x9f8>
81132870:	dac02417 	ldw	r11,144(sp)
81132874:	d8c02017 	ldw	r3,128(sp)
81132878:	58f9c83a 	sub	fp,r11,r3
8113287c:	07010f0e 	bge	zero,fp,81132cbc <___svfiprintf_internal_r+0x9f8>
81132880:	02400404 	movi	r9,16
81132884:	d8c01c17 	ldw	r3,112(sp)
81132888:	d8801b17 	ldw	r2,108(sp)
8113288c:	4f02d60e 	bge	r9,fp,811333e8 <___svfiprintf_internal_r+0x1124>
81132890:	01604574 	movhi	r5,33045
81132894:	294b1b04 	addi	r5,r5,11372
81132898:	d9402815 	stw	r5,160(sp)
8113289c:	028001c4 	movi	r10,7
811328a0:	00000306 	br	811328b0 <___svfiprintf_internal_r+0x5ec>
811328a4:	e73ffc04 	addi	fp,fp,-16
811328a8:	42000204 	addi	r8,r8,8
811328ac:	4f00150e 	bge	r9,fp,81132904 <___svfiprintf_internal_r+0x640>
811328b0:	18c00404 	addi	r3,r3,16
811328b4:	10800044 	addi	r2,r2,1
811328b8:	45800015 	stw	r22,0(r8)
811328bc:	42400115 	stw	r9,4(r8)
811328c0:	d8c01c15 	stw	r3,112(sp)
811328c4:	d8801b15 	stw	r2,108(sp)
811328c8:	50bff60e 	bge	r10,r2,811328a4 <__reset+0xfb1128a4>
811328cc:	d9801a04 	addi	r6,sp,104
811328d0:	b80b883a 	mov	r5,r23
811328d4:	a809883a 	mov	r4,r21
811328d8:	da402c15 	stw	r9,176(sp)
811328dc:	da802d15 	stw	r10,180(sp)
811328e0:	11320ec0 	call	811320ec <__ssprint_r>
811328e4:	da402c17 	ldw	r9,176(sp)
811328e8:	da802d17 	ldw	r10,180(sp)
811328ec:	1001851e 	bne	r2,zero,81132f04 <___svfiprintf_internal_r+0xc40>
811328f0:	e73ffc04 	addi	fp,fp,-16
811328f4:	d8c01c17 	ldw	r3,112(sp)
811328f8:	d8801b17 	ldw	r2,108(sp)
811328fc:	d811883a 	mov	r8,sp
81132900:	4f3feb16 	blt	r9,fp,811328b0 <__reset+0xfb1128b0>
81132904:	dac02817 	ldw	r11,160(sp)
81132908:	e0c7883a 	add	r3,fp,r3
8113290c:	10800044 	addi	r2,r2,1
81132910:	42c00015 	stw	r11,0(r8)
81132914:	47000115 	stw	fp,4(r8)
81132918:	d8c01c15 	stw	r3,112(sp)
8113291c:	d8801b15 	stw	r2,108(sp)
81132920:	010001c4 	movi	r4,7
81132924:	2081ee16 	blt	r4,r2,811330e0 <___svfiprintf_internal_r+0xe1c>
81132928:	42000204 	addi	r8,r8,8
8113292c:	0000e506 	br	81132cc4 <___svfiprintf_internal_r+0xa00>
81132930:	21003fcc 	andi	r4,r4,255
81132934:	2002dd1e 	bne	r4,zero,811334ac <___svfiprintf_internal_r+0x11e8>
81132938:	00a04574 	movhi	r2,33045
8113293c:	108a8804 	addi	r2,r2,10784
81132940:	d8802915 	stw	r2,164(sp)
81132944:	9080080c 	andi	r2,r18,32
81132948:	103f461e 	bne	r2,zero,81132664 <__reset+0xfb112664>
8113294c:	9080040c 	andi	r2,r18,16
81132950:	10022e1e 	bne	r2,zero,8113320c <___svfiprintf_internal_r+0xf48>
81132954:	9080100c 	andi	r2,r18,64
81132958:	dac02317 	ldw	r11,140(sp)
8113295c:	10027326 	beq	r2,zero,8113332c <___svfiprintf_internal_r+0x1068>
81132960:	5f00000b 	ldhu	fp,0(r11)
81132964:	5ac00104 	addi	r11,r11,4
81132968:	0013883a 	mov	r9,zero
8113296c:	dac02315 	stw	r11,140(sp)
81132970:	003f4106 	br	81132678 <__reset+0xfb112678>
81132974:	21003fcc 	andi	r4,r4,255
81132978:	2002e11e 	bne	r4,zero,81133500 <___svfiprintf_internal_r+0x123c>
8113297c:	9080080c 	andi	r2,r18,32
81132980:	1002011e 	bne	r2,zero,81133188 <___svfiprintf_internal_r+0xec4>
81132984:	9080040c 	andi	r2,r18,16
81132988:	10023e1e 	bne	r2,zero,81133284 <___svfiprintf_internal_r+0xfc0>
8113298c:	9480100c 	andi	r18,r18,64
81132990:	90023c26 	beq	r18,zero,81133284 <___svfiprintf_internal_r+0xfc0>
81132994:	dac02317 	ldw	r11,140(sp)
81132998:	58800017 	ldw	r2,0(r11)
8113299c:	5ac00104 	addi	r11,r11,4
811329a0:	dac02315 	stw	r11,140(sp)
811329a4:	dac02517 	ldw	r11,148(sp)
811329a8:	12c0000d 	sth	r11,0(r2)
811329ac:	003e6e06 	br	81132368 <__reset+0xfb112368>
811329b0:	98c00007 	ldb	r3,0(r19)
811329b4:	1a422926 	beq	r3,r9,8113325c <___svfiprintf_internal_r+0xf98>
811329b8:	94800414 	ori	r18,r18,16
811329bc:	003e9206 	br	81132408 <__reset+0xfb112408>
811329c0:	94801014 	ori	r18,r18,64
811329c4:	98c00007 	ldb	r3,0(r19)
811329c8:	003e8f06 	br	81132408 <__reset+0xfb112408>
811329cc:	21003fcc 	andi	r4,r4,255
811329d0:	2002c71e 	bne	r4,zero,811334f0 <___svfiprintf_internal_r+0x122c>
811329d4:	9080080c 	andi	r2,r18,32
811329d8:	10004926 	beq	r2,zero,81132b00 <___svfiprintf_internal_r+0x83c>
811329dc:	dac02317 	ldw	r11,140(sp)
811329e0:	58800117 	ldw	r2,4(r11)
811329e4:	5f000017 	ldw	fp,0(r11)
811329e8:	5ac00204 	addi	r11,r11,8
811329ec:	dac02315 	stw	r11,140(sp)
811329f0:	1013883a 	mov	r9,r2
811329f4:	10004b16 	blt	r2,zero,81132b24 <___svfiprintf_internal_r+0x860>
811329f8:	da801d83 	ldbu	r10,118(sp)
811329fc:	8001cb16 	blt	r16,zero,8113312c <___svfiprintf_internal_r+0xe68>
81132a00:	00ffdfc4 	movi	r3,-129
81132a04:	e244b03a 	or	r2,fp,r9
81132a08:	90e4703a 	and	r18,r18,r3
81132a0c:	103f4726 	beq	r2,zero,8113272c <__reset+0xfb11272c>
81132a10:	48008c26 	beq	r9,zero,81132c44 <___svfiprintf_internal_r+0x980>
81132a14:	dc802015 	stw	r18,128(sp)
81132a18:	dc002115 	stw	r16,132(sp)
81132a1c:	dc401a04 	addi	r17,sp,104
81132a20:	e021883a 	mov	r16,fp
81132a24:	da002215 	stw	r8,136(sp)
81132a28:	5039883a 	mov	fp,r10
81132a2c:	4825883a 	mov	r18,r9
81132a30:	8009883a 	mov	r4,r16
81132a34:	900b883a 	mov	r5,r18
81132a38:	01800284 	movi	r6,10
81132a3c:	000f883a 	mov	r7,zero
81132a40:	11365d40 	call	811365d4 <__umoddi3>
81132a44:	10800c04 	addi	r2,r2,48
81132a48:	8c7fffc4 	addi	r17,r17,-1
81132a4c:	8009883a 	mov	r4,r16
81132a50:	900b883a 	mov	r5,r18
81132a54:	88800005 	stb	r2,0(r17)
81132a58:	01800284 	movi	r6,10
81132a5c:	000f883a 	mov	r7,zero
81132a60:	11360540 	call	81136054 <__udivdi3>
81132a64:	1021883a 	mov	r16,r2
81132a68:	10c4b03a 	or	r2,r2,r3
81132a6c:	1825883a 	mov	r18,r3
81132a70:	103fef1e 	bne	r2,zero,81132a30 <__reset+0xfb112a30>
81132a74:	dc802017 	ldw	r18,128(sp)
81132a78:	dc002117 	ldw	r16,132(sp)
81132a7c:	da002217 	ldw	r8,136(sp)
81132a80:	e015883a 	mov	r10,fp
81132a84:	d8c01e17 	ldw	r3,120(sp)
81132a88:	1c47c83a 	sub	r3,r3,r17
81132a8c:	d8c02115 	stw	r3,132(sp)
81132a90:	003f2a06 	br	8113273c <__reset+0xfb11273c>
81132a94:	dac02317 	ldw	r11,140(sp)
81132a98:	d8001d85 	stb	zero,118(sp)
81132a9c:	5c400017 	ldw	r17,0(r11)
81132aa0:	5f000104 	addi	fp,r11,4
81132aa4:	88022f26 	beq	r17,zero,81133364 <___svfiprintf_internal_r+0x10a0>
81132aa8:	80022516 	blt	r16,zero,81133340 <___svfiprintf_internal_r+0x107c>
81132aac:	800d883a 	mov	r6,r16
81132ab0:	000b883a 	mov	r5,zero
81132ab4:	8809883a 	mov	r4,r17
81132ab8:	da002c15 	stw	r8,176(sp)
81132abc:	112e9780 	call	8112e978 <memchr>
81132ac0:	da002c17 	ldw	r8,176(sp)
81132ac4:	10026426 	beq	r2,zero,81133458 <___svfiprintf_internal_r+0x1194>
81132ac8:	1445c83a 	sub	r2,r2,r17
81132acc:	d8802115 	stw	r2,132(sp)
81132ad0:	da801d83 	ldbu	r10,118(sp)
81132ad4:	df002315 	stw	fp,140(sp)
81132ad8:	0021883a 	mov	r16,zero
81132adc:	003f1706 	br	8113273c <__reset+0xfb11273c>
81132ae0:	94800814 	ori	r18,r18,32
81132ae4:	98c00007 	ldb	r3,0(r19)
81132ae8:	003e4706 	br	81132408 <__reset+0xfb112408>
81132aec:	21003fcc 	andi	r4,r4,255
81132af0:	2002701e 	bne	r4,zero,811334b4 <___svfiprintf_internal_r+0x11f0>
81132af4:	94800414 	ori	r18,r18,16
81132af8:	9080080c 	andi	r2,r18,32
81132afc:	103fb71e 	bne	r2,zero,811329dc <__reset+0xfb1129dc>
81132b00:	9080040c 	andi	r2,r18,16
81132b04:	1001ab26 	beq	r2,zero,811331b4 <___svfiprintf_internal_r+0xef0>
81132b08:	dac02317 	ldw	r11,140(sp)
81132b0c:	5f000017 	ldw	fp,0(r11)
81132b10:	5ac00104 	addi	r11,r11,4
81132b14:	dac02315 	stw	r11,140(sp)
81132b18:	e013d7fa 	srai	r9,fp,31
81132b1c:	4805883a 	mov	r2,r9
81132b20:	103fb50e 	bge	r2,zero,811329f8 <__reset+0xfb1129f8>
81132b24:	0739c83a 	sub	fp,zero,fp
81132b28:	02800b44 	movi	r10,45
81132b2c:	e004c03a 	cmpne	r2,fp,zero
81132b30:	0253c83a 	sub	r9,zero,r9
81132b34:	da801d85 	stb	r10,118(sp)
81132b38:	4893c83a 	sub	r9,r9,r2
81132b3c:	80023016 	blt	r16,zero,81133400 <___svfiprintf_internal_r+0x113c>
81132b40:	00bfdfc4 	movi	r2,-129
81132b44:	90a4703a 	and	r18,r18,r2
81132b48:	483fb21e 	bne	r9,zero,81132a14 <__reset+0xfb112a14>
81132b4c:	00003d06 	br	81132c44 <___svfiprintf_internal_r+0x980>
81132b50:	9817883a 	mov	r11,r19
81132b54:	d8002415 	stw	zero,144(sp)
81132b58:	18bff404 	addi	r2,r3,-48
81132b5c:	0019883a 	mov	r12,zero
81132b60:	58c00007 	ldb	r3,0(r11)
81132b64:	630002a4 	muli	r12,r12,10
81132b68:	9cc00044 	addi	r19,r19,1
81132b6c:	9817883a 	mov	r11,r19
81132b70:	1319883a 	add	r12,r2,r12
81132b74:	18bff404 	addi	r2,r3,-48
81132b78:	30bff92e 	bgeu	r6,r2,81132b60 <__reset+0xfb112b60>
81132b7c:	db002415 	stw	r12,144(sp)
81132b80:	18bff804 	addi	r2,r3,-32
81132b84:	28be232e 	bgeu	r5,r2,81132414 <__reset+0xfb112414>
81132b88:	21003fcc 	andi	r4,r4,255
81132b8c:	20024b1e 	bne	r4,zero,811334bc <___svfiprintf_internal_r+0x11f8>
81132b90:	1800d626 	beq	r3,zero,81132eec <___svfiprintf_internal_r+0xc28>
81132b94:	02c00044 	movi	r11,1
81132b98:	dac02015 	stw	r11,128(sp)
81132b9c:	d8c01005 	stb	r3,64(sp)
81132ba0:	d8001d85 	stb	zero,118(sp)
81132ba4:	dac02115 	stw	r11,132(sp)
81132ba8:	dc401004 	addi	r17,sp,64
81132bac:	003f2606 	br	81132848 <__reset+0xfb112848>
81132bb0:	94802014 	ori	r18,r18,128
81132bb4:	98c00007 	ldb	r3,0(r19)
81132bb8:	003e1306 	br	81132408 <__reset+0xfb112408>
81132bbc:	98c00007 	ldb	r3,0(r19)
81132bc0:	9ac00044 	addi	r11,r19,1
81132bc4:	1a822b26 	beq	r3,r10,81133474 <___svfiprintf_internal_r+0x11b0>
81132bc8:	18bff404 	addi	r2,r3,-48
81132bcc:	0021883a 	mov	r16,zero
81132bd0:	30821e36 	bltu	r6,r2,8113344c <___svfiprintf_internal_r+0x1188>
81132bd4:	58c00007 	ldb	r3,0(r11)
81132bd8:	840002a4 	muli	r16,r16,10
81132bdc:	5cc00044 	addi	r19,r11,1
81132be0:	9817883a 	mov	r11,r19
81132be4:	80a1883a 	add	r16,r16,r2
81132be8:	18bff404 	addi	r2,r3,-48
81132bec:	30bff92e 	bgeu	r6,r2,81132bd4 <__reset+0xfb112bd4>
81132bf0:	803e060e 	bge	r16,zero,8113240c <__reset+0xfb11240c>
81132bf4:	043fffc4 	movi	r16,-1
81132bf8:	003e0406 	br	8113240c <__reset+0xfb11240c>
81132bfc:	21003fcc 	andi	r4,r4,255
81132c00:	2002371e 	bne	r4,zero,811334e0 <___svfiprintf_internal_r+0x121c>
81132c04:	94800414 	ori	r18,r18,16
81132c08:	9080080c 	andi	r2,r18,32
81132c0c:	103ebb1e 	bne	r2,zero,811326fc <__reset+0xfb1126fc>
81132c10:	9080040c 	andi	r2,r18,16
81132c14:	10013b26 	beq	r2,zero,81133104 <___svfiprintf_internal_r+0xe40>
81132c18:	dac02317 	ldw	r11,140(sp)
81132c1c:	d8001d85 	stb	zero,118(sp)
81132c20:	0013883a 	mov	r9,zero
81132c24:	58800104 	addi	r2,r11,4
81132c28:	5f000017 	ldw	fp,0(r11)
81132c2c:	80013d16 	blt	r16,zero,81133124 <___svfiprintf_internal_r+0xe60>
81132c30:	00ffdfc4 	movi	r3,-129
81132c34:	d8802315 	stw	r2,140(sp)
81132c38:	90e4703a 	and	r18,r18,r3
81132c3c:	0015883a 	mov	r10,zero
81132c40:	e03eba26 	beq	fp,zero,8113272c <__reset+0xfb11272c>
81132c44:	00800244 	movi	r2,9
81132c48:	173f7236 	bltu	r2,fp,81132a14 <__reset+0xfb112a14>
81132c4c:	dac02b17 	ldw	r11,172(sp)
81132c50:	e7000c04 	addi	fp,fp,48
81132c54:	df0019c5 	stb	fp,103(sp)
81132c58:	dac02115 	stw	r11,132(sp)
81132c5c:	dc4019c4 	addi	r17,sp,103
81132c60:	003eb606 	br	8113273c <__reset+0xfb11273c>
81132c64:	21003fcc 	andi	r4,r4,255
81132c68:	20021f1e 	bne	r4,zero,811334e8 <___svfiprintf_internal_r+0x1224>
81132c6c:	94800414 	ori	r18,r18,16
81132c70:	9080080c 	andi	r2,r18,32
81132c74:	103ec51e 	bne	r2,zero,8113278c <__reset+0xfb11278c>
81132c78:	9080040c 	andi	r2,r18,16
81132c7c:	10016926 	beq	r2,zero,81133224 <___svfiprintf_internal_r+0xf60>
81132c80:	dac02317 	ldw	r11,140(sp)
81132c84:	d8001d85 	stb	zero,118(sp)
81132c88:	0013883a 	mov	r9,zero
81132c8c:	58800104 	addi	r2,r11,4
81132c90:	5f000017 	ldw	fp,0(r11)
81132c94:	80016b16 	blt	r16,zero,81133244 <___svfiprintf_internal_r+0xf80>
81132c98:	00ffdfc4 	movi	r3,-129
81132c9c:	d8802315 	stw	r2,140(sp)
81132ca0:	90e4703a 	and	r18,r18,r3
81132ca4:	e03ec41e 	bne	fp,zero,811327b8 <__reset+0xfb1127b8>
81132ca8:	0015883a 	mov	r10,zero
81132cac:	8001c226 	beq	r16,zero,811333b8 <___svfiprintf_internal_r+0x10f4>
81132cb0:	0039883a 	mov	fp,zero
81132cb4:	0013883a 	mov	r9,zero
81132cb8:	003ec006 	br	811327bc <__reset+0xfb1127bc>
81132cbc:	d8c01c17 	ldw	r3,112(sp)
81132cc0:	d8801b17 	ldw	r2,108(sp)
81132cc4:	d9001d87 	ldb	r4,118(sp)
81132cc8:	20000b26 	beq	r4,zero,81132cf8 <___svfiprintf_internal_r+0xa34>
81132ccc:	d9001d84 	addi	r4,sp,118
81132cd0:	18c00044 	addi	r3,r3,1
81132cd4:	10800044 	addi	r2,r2,1
81132cd8:	41000015 	stw	r4,0(r8)
81132cdc:	01000044 	movi	r4,1
81132ce0:	41000115 	stw	r4,4(r8)
81132ce4:	d8c01c15 	stw	r3,112(sp)
81132ce8:	d8801b15 	stw	r2,108(sp)
81132cec:	010001c4 	movi	r4,7
81132cf0:	2080e116 	blt	r4,r2,81133078 <___svfiprintf_internal_r+0xdb4>
81132cf4:	42000204 	addi	r8,r8,8
81132cf8:	dac02217 	ldw	r11,136(sp)
81132cfc:	58000b26 	beq	r11,zero,81132d2c <___svfiprintf_internal_r+0xa68>
81132d00:	d9001d04 	addi	r4,sp,116
81132d04:	18c00084 	addi	r3,r3,2
81132d08:	10800044 	addi	r2,r2,1
81132d0c:	41000015 	stw	r4,0(r8)
81132d10:	01000084 	movi	r4,2
81132d14:	41000115 	stw	r4,4(r8)
81132d18:	d8c01c15 	stw	r3,112(sp)
81132d1c:	d8801b15 	stw	r2,108(sp)
81132d20:	010001c4 	movi	r4,7
81132d24:	2080dd16 	blt	r4,r2,8113309c <___svfiprintf_internal_r+0xdd8>
81132d28:	42000204 	addi	r8,r8,8
81132d2c:	dac02617 	ldw	r11,152(sp)
81132d30:	01002004 	movi	r4,128
81132d34:	59008426 	beq	r11,r4,81132f48 <___svfiprintf_internal_r+0xc84>
81132d38:	dac02117 	ldw	r11,132(sp)
81132d3c:	82e1c83a 	sub	r16,r16,r11
81132d40:	0400270e 	bge	zero,r16,81132de0 <___svfiprintf_internal_r+0xb1c>
81132d44:	01c00404 	movi	r7,16
81132d48:	3c016a0e 	bge	r7,r16,811332f4 <___svfiprintf_internal_r+0x1030>
81132d4c:	01604574 	movhi	r5,33045
81132d50:	294b1704 	addi	r5,r5,11356
81132d54:	d9402215 	stw	r5,136(sp)
81132d58:	070001c4 	movi	fp,7
81132d5c:	00000306 	br	81132d6c <___svfiprintf_internal_r+0xaa8>
81132d60:	843ffc04 	addi	r16,r16,-16
81132d64:	42000204 	addi	r8,r8,8
81132d68:	3c00130e 	bge	r7,r16,81132db8 <___svfiprintf_internal_r+0xaf4>
81132d6c:	18c00404 	addi	r3,r3,16
81132d70:	10800044 	addi	r2,r2,1
81132d74:	45000015 	stw	r20,0(r8)
81132d78:	41c00115 	stw	r7,4(r8)
81132d7c:	d8c01c15 	stw	r3,112(sp)
81132d80:	d8801b15 	stw	r2,108(sp)
81132d84:	e0bff60e 	bge	fp,r2,81132d60 <__reset+0xfb112d60>
81132d88:	d9801a04 	addi	r6,sp,104
81132d8c:	b80b883a 	mov	r5,r23
81132d90:	a809883a 	mov	r4,r21
81132d94:	d9c02c15 	stw	r7,176(sp)
81132d98:	11320ec0 	call	811320ec <__ssprint_r>
81132d9c:	d9c02c17 	ldw	r7,176(sp)
81132da0:	1000581e 	bne	r2,zero,81132f04 <___svfiprintf_internal_r+0xc40>
81132da4:	843ffc04 	addi	r16,r16,-16
81132da8:	d8c01c17 	ldw	r3,112(sp)
81132dac:	d8801b17 	ldw	r2,108(sp)
81132db0:	d811883a 	mov	r8,sp
81132db4:	3c3fed16 	blt	r7,r16,81132d6c <__reset+0xfb112d6c>
81132db8:	dac02217 	ldw	r11,136(sp)
81132dbc:	1c07883a 	add	r3,r3,r16
81132dc0:	10800044 	addi	r2,r2,1
81132dc4:	42c00015 	stw	r11,0(r8)
81132dc8:	44000115 	stw	r16,4(r8)
81132dcc:	d8c01c15 	stw	r3,112(sp)
81132dd0:	d8801b15 	stw	r2,108(sp)
81132dd4:	010001c4 	movi	r4,7
81132dd8:	20809e16 	blt	r4,r2,81133054 <___svfiprintf_internal_r+0xd90>
81132ddc:	42000204 	addi	r8,r8,8
81132de0:	dac02117 	ldw	r11,132(sp)
81132de4:	10800044 	addi	r2,r2,1
81132de8:	44400015 	stw	r17,0(r8)
81132dec:	58c7883a 	add	r3,r11,r3
81132df0:	42c00115 	stw	r11,4(r8)
81132df4:	d8c01c15 	stw	r3,112(sp)
81132df8:	d8801b15 	stw	r2,108(sp)
81132dfc:	010001c4 	movi	r4,7
81132e00:	20807f16 	blt	r4,r2,81133000 <___svfiprintf_internal_r+0xd3c>
81132e04:	42000204 	addi	r8,r8,8
81132e08:	9480010c 	andi	r18,r18,4
81132e0c:	90002926 	beq	r18,zero,81132eb4 <___svfiprintf_internal_r+0xbf0>
81132e10:	dac02417 	ldw	r11,144(sp)
81132e14:	d8802017 	ldw	r2,128(sp)
81132e18:	58a1c83a 	sub	r16,r11,r2
81132e1c:	0400250e 	bge	zero,r16,81132eb4 <___svfiprintf_internal_r+0xbf0>
81132e20:	04400404 	movi	r17,16
81132e24:	d8801b17 	ldw	r2,108(sp)
81132e28:	8c017c0e 	bge	r17,r16,8113341c <___svfiprintf_internal_r+0x1158>
81132e2c:	01604574 	movhi	r5,33045
81132e30:	294b1b04 	addi	r5,r5,11372
81132e34:	d9402815 	stw	r5,160(sp)
81132e38:	048001c4 	movi	r18,7
81132e3c:	00000306 	br	81132e4c <___svfiprintf_internal_r+0xb88>
81132e40:	843ffc04 	addi	r16,r16,-16
81132e44:	42000204 	addi	r8,r8,8
81132e48:	8c00110e 	bge	r17,r16,81132e90 <___svfiprintf_internal_r+0xbcc>
81132e4c:	18c00404 	addi	r3,r3,16
81132e50:	10800044 	addi	r2,r2,1
81132e54:	45800015 	stw	r22,0(r8)
81132e58:	44400115 	stw	r17,4(r8)
81132e5c:	d8c01c15 	stw	r3,112(sp)
81132e60:	d8801b15 	stw	r2,108(sp)
81132e64:	90bff60e 	bge	r18,r2,81132e40 <__reset+0xfb112e40>
81132e68:	d9801a04 	addi	r6,sp,104
81132e6c:	b80b883a 	mov	r5,r23
81132e70:	a809883a 	mov	r4,r21
81132e74:	11320ec0 	call	811320ec <__ssprint_r>
81132e78:	1000221e 	bne	r2,zero,81132f04 <___svfiprintf_internal_r+0xc40>
81132e7c:	843ffc04 	addi	r16,r16,-16
81132e80:	d8c01c17 	ldw	r3,112(sp)
81132e84:	d8801b17 	ldw	r2,108(sp)
81132e88:	d811883a 	mov	r8,sp
81132e8c:	8c3fef16 	blt	r17,r16,81132e4c <__reset+0xfb112e4c>
81132e90:	dac02817 	ldw	r11,160(sp)
81132e94:	1c07883a 	add	r3,r3,r16
81132e98:	10800044 	addi	r2,r2,1
81132e9c:	42c00015 	stw	r11,0(r8)
81132ea0:	44000115 	stw	r16,4(r8)
81132ea4:	d8c01c15 	stw	r3,112(sp)
81132ea8:	d8801b15 	stw	r2,108(sp)
81132eac:	010001c4 	movi	r4,7
81132eb0:	2080aa16 	blt	r4,r2,8113315c <___svfiprintf_internal_r+0xe98>
81132eb4:	d8802417 	ldw	r2,144(sp)
81132eb8:	dac02017 	ldw	r11,128(sp)
81132ebc:	12c0010e 	bge	r2,r11,81132ec4 <___svfiprintf_internal_r+0xc00>
81132ec0:	5805883a 	mov	r2,r11
81132ec4:	dac02517 	ldw	r11,148(sp)
81132ec8:	5897883a 	add	r11,r11,r2
81132ecc:	dac02515 	stw	r11,148(sp)
81132ed0:	1800531e 	bne	r3,zero,81133020 <___svfiprintf_internal_r+0xd5c>
81132ed4:	98800007 	ldb	r2,0(r19)
81132ed8:	d8001b15 	stw	zero,108(sp)
81132edc:	d811883a 	mov	r8,sp
81132ee0:	103d231e 	bne	r2,zero,81132370 <__reset+0xfb112370>
81132ee4:	9823883a 	mov	r17,r19
81132ee8:	003d3906 	br	811323d0 <__reset+0xfb1123d0>
81132eec:	d8801c17 	ldw	r2,112(sp)
81132ef0:	10000426 	beq	r2,zero,81132f04 <___svfiprintf_internal_r+0xc40>
81132ef4:	d9402717 	ldw	r5,156(sp)
81132ef8:	d9002a17 	ldw	r4,168(sp)
81132efc:	d9801a04 	addi	r6,sp,104
81132f00:	11320ec0 	call	811320ec <__ssprint_r>
81132f04:	dac02717 	ldw	r11,156(sp)
81132f08:	d8802517 	ldw	r2,148(sp)
81132f0c:	58c0030b 	ldhu	r3,12(r11)
81132f10:	18c0100c 	andi	r3,r3,64
81132f14:	1801381e 	bne	r3,zero,811333f8 <___svfiprintf_internal_r+0x1134>
81132f18:	dfc03717 	ldw	ra,220(sp)
81132f1c:	df003617 	ldw	fp,216(sp)
81132f20:	ddc03517 	ldw	r23,212(sp)
81132f24:	dd803417 	ldw	r22,208(sp)
81132f28:	dd403317 	ldw	r21,204(sp)
81132f2c:	dd003217 	ldw	r20,200(sp)
81132f30:	dcc03117 	ldw	r19,196(sp)
81132f34:	dc803017 	ldw	r18,192(sp)
81132f38:	dc402f17 	ldw	r17,188(sp)
81132f3c:	dc002e17 	ldw	r16,184(sp)
81132f40:	dec03804 	addi	sp,sp,224
81132f44:	f800283a 	ret
81132f48:	dac02417 	ldw	r11,144(sp)
81132f4c:	d9002017 	ldw	r4,128(sp)
81132f50:	5939c83a 	sub	fp,r11,r4
81132f54:	073f780e 	bge	zero,fp,81132d38 <__reset+0xfb112d38>
81132f58:	02400404 	movi	r9,16
81132f5c:	4f01370e 	bge	r9,fp,8113343c <___svfiprintf_internal_r+0x1178>
81132f60:	02e04574 	movhi	r11,33045
81132f64:	5acb1704 	addi	r11,r11,11356
81132f68:	dac02215 	stw	r11,136(sp)
81132f6c:	028001c4 	movi	r10,7
81132f70:	00000306 	br	81132f80 <___svfiprintf_internal_r+0xcbc>
81132f74:	e73ffc04 	addi	fp,fp,-16
81132f78:	42000204 	addi	r8,r8,8
81132f7c:	4f00150e 	bge	r9,fp,81132fd4 <___svfiprintf_internal_r+0xd10>
81132f80:	18c00404 	addi	r3,r3,16
81132f84:	10800044 	addi	r2,r2,1
81132f88:	45000015 	stw	r20,0(r8)
81132f8c:	42400115 	stw	r9,4(r8)
81132f90:	d8c01c15 	stw	r3,112(sp)
81132f94:	d8801b15 	stw	r2,108(sp)
81132f98:	50bff60e 	bge	r10,r2,81132f74 <__reset+0xfb112f74>
81132f9c:	d9801a04 	addi	r6,sp,104
81132fa0:	b80b883a 	mov	r5,r23
81132fa4:	a809883a 	mov	r4,r21
81132fa8:	da402c15 	stw	r9,176(sp)
81132fac:	da802d15 	stw	r10,180(sp)
81132fb0:	11320ec0 	call	811320ec <__ssprint_r>
81132fb4:	da402c17 	ldw	r9,176(sp)
81132fb8:	da802d17 	ldw	r10,180(sp)
81132fbc:	103fd11e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
81132fc0:	e73ffc04 	addi	fp,fp,-16
81132fc4:	d8c01c17 	ldw	r3,112(sp)
81132fc8:	d8801b17 	ldw	r2,108(sp)
81132fcc:	d811883a 	mov	r8,sp
81132fd0:	4f3feb16 	blt	r9,fp,81132f80 <__reset+0xfb112f80>
81132fd4:	dac02217 	ldw	r11,136(sp)
81132fd8:	1f07883a 	add	r3,r3,fp
81132fdc:	10800044 	addi	r2,r2,1
81132fe0:	42c00015 	stw	r11,0(r8)
81132fe4:	47000115 	stw	fp,4(r8)
81132fe8:	d8c01c15 	stw	r3,112(sp)
81132fec:	d8801b15 	stw	r2,108(sp)
81132ff0:	010001c4 	movi	r4,7
81132ff4:	2080b616 	blt	r4,r2,811332d0 <___svfiprintf_internal_r+0x100c>
81132ff8:	42000204 	addi	r8,r8,8
81132ffc:	003f4e06 	br	81132d38 <__reset+0xfb112d38>
81133000:	d9801a04 	addi	r6,sp,104
81133004:	b80b883a 	mov	r5,r23
81133008:	a809883a 	mov	r4,r21
8113300c:	11320ec0 	call	811320ec <__ssprint_r>
81133010:	103fbc1e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
81133014:	d8c01c17 	ldw	r3,112(sp)
81133018:	d811883a 	mov	r8,sp
8113301c:	003f7a06 	br	81132e08 <__reset+0xfb112e08>
81133020:	d9801a04 	addi	r6,sp,104
81133024:	b80b883a 	mov	r5,r23
81133028:	a809883a 	mov	r4,r21
8113302c:	11320ec0 	call	811320ec <__ssprint_r>
81133030:	103fa826 	beq	r2,zero,81132ed4 <__reset+0xfb112ed4>
81133034:	003fb306 	br	81132f04 <__reset+0xfb112f04>
81133038:	d9801a04 	addi	r6,sp,104
8113303c:	b80b883a 	mov	r5,r23
81133040:	a809883a 	mov	r4,r21
81133044:	11320ec0 	call	811320ec <__ssprint_r>
81133048:	103fae1e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
8113304c:	d811883a 	mov	r8,sp
81133050:	003cdc06 	br	811323c4 <__reset+0xfb1123c4>
81133054:	d9801a04 	addi	r6,sp,104
81133058:	b80b883a 	mov	r5,r23
8113305c:	a809883a 	mov	r4,r21
81133060:	11320ec0 	call	811320ec <__ssprint_r>
81133064:	103fa71e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
81133068:	d8c01c17 	ldw	r3,112(sp)
8113306c:	d8801b17 	ldw	r2,108(sp)
81133070:	d811883a 	mov	r8,sp
81133074:	003f5a06 	br	81132de0 <__reset+0xfb112de0>
81133078:	d9801a04 	addi	r6,sp,104
8113307c:	b80b883a 	mov	r5,r23
81133080:	a809883a 	mov	r4,r21
81133084:	11320ec0 	call	811320ec <__ssprint_r>
81133088:	103f9e1e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
8113308c:	d8c01c17 	ldw	r3,112(sp)
81133090:	d8801b17 	ldw	r2,108(sp)
81133094:	d811883a 	mov	r8,sp
81133098:	003f1706 	br	81132cf8 <__reset+0xfb112cf8>
8113309c:	d9801a04 	addi	r6,sp,104
811330a0:	b80b883a 	mov	r5,r23
811330a4:	a809883a 	mov	r4,r21
811330a8:	11320ec0 	call	811320ec <__ssprint_r>
811330ac:	103f951e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
811330b0:	d8c01c17 	ldw	r3,112(sp)
811330b4:	d8801b17 	ldw	r2,108(sp)
811330b8:	d811883a 	mov	r8,sp
811330bc:	003f1b06 	br	81132d2c <__reset+0xfb112d2c>
811330c0:	d8001d85 	stb	zero,118(sp)
811330c4:	80007b16 	blt	r16,zero,811332b4 <___svfiprintf_internal_r+0xff0>
811330c8:	00ffdfc4 	movi	r3,-129
811330cc:	e244b03a 	or	r2,fp,r9
811330d0:	90e4703a 	and	r18,r18,r3
811330d4:	103d7026 	beq	r2,zero,81132698 <__reset+0xfb112698>
811330d8:	0015883a 	mov	r10,zero
811330dc:	003d7206 	br	811326a8 <__reset+0xfb1126a8>
811330e0:	d9801a04 	addi	r6,sp,104
811330e4:	b80b883a 	mov	r5,r23
811330e8:	a809883a 	mov	r4,r21
811330ec:	11320ec0 	call	811320ec <__ssprint_r>
811330f0:	103f841e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
811330f4:	d8c01c17 	ldw	r3,112(sp)
811330f8:	d8801b17 	ldw	r2,108(sp)
811330fc:	d811883a 	mov	r8,sp
81133100:	003ef006 	br	81132cc4 <__reset+0xfb112cc4>
81133104:	9080100c 	andi	r2,r18,64
81133108:	d8001d85 	stb	zero,118(sp)
8113310c:	dac02317 	ldw	r11,140(sp)
81133110:	10008126 	beq	r2,zero,81133318 <___svfiprintf_internal_r+0x1054>
81133114:	58800104 	addi	r2,r11,4
81133118:	5f00000b 	ldhu	fp,0(r11)
8113311c:	0013883a 	mov	r9,zero
81133120:	803ec30e 	bge	r16,zero,81132c30 <__reset+0xfb112c30>
81133124:	d8802315 	stw	r2,140(sp)
81133128:	0015883a 	mov	r10,zero
8113312c:	e244b03a 	or	r2,fp,r9
81133130:	103e371e 	bne	r2,zero,81132a10 <__reset+0xfb112a10>
81133134:	00800044 	movi	r2,1
81133138:	10803fcc 	andi	r2,r2,255
8113313c:	00c00044 	movi	r3,1
81133140:	10c06126 	beq	r2,r3,811332c8 <___svfiprintf_internal_r+0x1004>
81133144:	00c00084 	movi	r3,2
81133148:	10fd5526 	beq	r2,r3,811326a0 <__reset+0xfb1126a0>
8113314c:	003ed806 	br	81132cb0 <__reset+0xfb112cb0>
81133150:	d8802315 	stw	r2,140(sp)
81133154:	98c00007 	ldb	r3,0(r19)
81133158:	003cab06 	br	81132408 <__reset+0xfb112408>
8113315c:	d9801a04 	addi	r6,sp,104
81133160:	b80b883a 	mov	r5,r23
81133164:	a809883a 	mov	r4,r21
81133168:	11320ec0 	call	811320ec <__ssprint_r>
8113316c:	103f651e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
81133170:	d8c01c17 	ldw	r3,112(sp)
81133174:	003f4f06 	br	81132eb4 <__reset+0xfb112eb4>
81133178:	00a04574 	movhi	r2,33045
8113317c:	108a8d04 	addi	r2,r2,10804
81133180:	d8802915 	stw	r2,164(sp)
81133184:	003d4406 	br	81132698 <__reset+0xfb112698>
81133188:	dac02317 	ldw	r11,140(sp)
8113318c:	58800017 	ldw	r2,0(r11)
81133190:	dac02517 	ldw	r11,148(sp)
81133194:	5807d7fa 	srai	r3,r11,31
81133198:	dac02317 	ldw	r11,140(sp)
8113319c:	10c00115 	stw	r3,4(r2)
811331a0:	5ac00104 	addi	r11,r11,4
811331a4:	dac02315 	stw	r11,140(sp)
811331a8:	dac02517 	ldw	r11,148(sp)
811331ac:	12c00015 	stw	r11,0(r2)
811331b0:	003c6d06 	br	81132368 <__reset+0xfb112368>
811331b4:	9080100c 	andi	r2,r18,64
811331b8:	dac02317 	ldw	r11,140(sp)
811331bc:	103e5326 	beq	r2,zero,81132b0c <__reset+0xfb112b0c>
811331c0:	5f00000f 	ldh	fp,0(r11)
811331c4:	5ac00104 	addi	r11,r11,4
811331c8:	dac02315 	stw	r11,140(sp)
811331cc:	e013d7fa 	srai	r9,fp,31
811331d0:	4805883a 	mov	r2,r9
811331d4:	003e0706 	br	811329f4 <__reset+0xfb1129f4>
811331d8:	00800c04 	movi	r2,48
811331dc:	d8801d05 	stb	r2,116(sp)
811331e0:	d8c01d45 	stb	r3,117(sp)
811331e4:	d8001d85 	stb	zero,118(sp)
811331e8:	90800094 	ori	r2,r18,2
811331ec:	80008f16 	blt	r16,zero,8113342c <___svfiprintf_internal_r+0x1168>
811331f0:	00bfdfc4 	movi	r2,-129
811331f4:	90a4703a 	and	r18,r18,r2
811331f8:	94800094 	ori	r18,r18,2
811331fc:	0015883a 	mov	r10,zero
81133200:	003d2906 	br	811326a8 <__reset+0xfb1126a8>
81133204:	98c00007 	ldb	r3,0(r19)
81133208:	003c7f06 	br	81132408 <__reset+0xfb112408>
8113320c:	dac02317 	ldw	r11,140(sp)
81133210:	0013883a 	mov	r9,zero
81133214:	5f000017 	ldw	fp,0(r11)
81133218:	5ac00104 	addi	r11,r11,4
8113321c:	dac02315 	stw	r11,140(sp)
81133220:	003d1506 	br	81132678 <__reset+0xfb112678>
81133224:	9080100c 	andi	r2,r18,64
81133228:	d8001d85 	stb	zero,118(sp)
8113322c:	dac02317 	ldw	r11,140(sp)
81133230:	10003426 	beq	r2,zero,81133304 <___svfiprintf_internal_r+0x1040>
81133234:	58800104 	addi	r2,r11,4
81133238:	5f00000b 	ldhu	fp,0(r11)
8113323c:	0013883a 	mov	r9,zero
81133240:	803e950e 	bge	r16,zero,81132c98 <__reset+0xfb112c98>
81133244:	e246b03a 	or	r3,fp,r9
81133248:	d8802315 	stw	r2,140(sp)
8113324c:	183d5a1e 	bne	r3,zero,811327b8 <__reset+0xfb1127b8>
81133250:	0015883a 	mov	r10,zero
81133254:	0005883a 	mov	r2,zero
81133258:	003fb706 	br	81133138 <__reset+0xfb113138>
8113325c:	98c00043 	ldbu	r3,1(r19)
81133260:	94800814 	ori	r18,r18,32
81133264:	9cc00044 	addi	r19,r19,1
81133268:	18c03fcc 	andi	r3,r3,255
8113326c:	18c0201c 	xori	r3,r3,128
81133270:	18ffe004 	addi	r3,r3,-128
81133274:	003c6406 	br	81132408 <__reset+0xfb112408>
81133278:	d8c02315 	stw	r3,140(sp)
8113327c:	0015883a 	mov	r10,zero
81133280:	003faa06 	br	8113312c <__reset+0xfb11312c>
81133284:	dac02317 	ldw	r11,140(sp)
81133288:	58800017 	ldw	r2,0(r11)
8113328c:	5ac00104 	addi	r11,r11,4
81133290:	dac02315 	stw	r11,140(sp)
81133294:	dac02517 	ldw	r11,148(sp)
81133298:	12c00015 	stw	r11,0(r2)
8113329c:	003c3206 	br	81132368 <__reset+0xfb112368>
811332a0:	01204574 	movhi	r4,33045
811332a4:	210a8d04 	addi	r4,r4,10804
811332a8:	d9002915 	stw	r4,164(sp)
811332ac:	d8c02315 	stw	r3,140(sp)
811332b0:	1025883a 	mov	r18,r2
811332b4:	e244b03a 	or	r2,fp,r9
811332b8:	103f871e 	bne	r2,zero,811330d8 <__reset+0xfb1130d8>
811332bc:	0015883a 	mov	r10,zero
811332c0:	00800084 	movi	r2,2
811332c4:	003f9c06 	br	81133138 <__reset+0xfb113138>
811332c8:	0039883a 	mov	fp,zero
811332cc:	003e5f06 	br	81132c4c <__reset+0xfb112c4c>
811332d0:	d9801a04 	addi	r6,sp,104
811332d4:	b80b883a 	mov	r5,r23
811332d8:	a809883a 	mov	r4,r21
811332dc:	11320ec0 	call	811320ec <__ssprint_r>
811332e0:	103f081e 	bne	r2,zero,81132f04 <__reset+0xfb112f04>
811332e4:	d8c01c17 	ldw	r3,112(sp)
811332e8:	d8801b17 	ldw	r2,108(sp)
811332ec:	d811883a 	mov	r8,sp
811332f0:	003e9106 	br	81132d38 <__reset+0xfb112d38>
811332f4:	01204574 	movhi	r4,33045
811332f8:	210b1704 	addi	r4,r4,11356
811332fc:	d9002215 	stw	r4,136(sp)
81133300:	003ead06 	br	81132db8 <__reset+0xfb112db8>
81133304:	58800104 	addi	r2,r11,4
81133308:	5f000017 	ldw	fp,0(r11)
8113330c:	0013883a 	mov	r9,zero
81133310:	803e610e 	bge	r16,zero,81132c98 <__reset+0xfb112c98>
81133314:	003fcb06 	br	81133244 <__reset+0xfb113244>
81133318:	58800104 	addi	r2,r11,4
8113331c:	5f000017 	ldw	fp,0(r11)
81133320:	0013883a 	mov	r9,zero
81133324:	803e420e 	bge	r16,zero,81132c30 <__reset+0xfb112c30>
81133328:	003f7e06 	br	81133124 <__reset+0xfb113124>
8113332c:	5f000017 	ldw	fp,0(r11)
81133330:	5ac00104 	addi	r11,r11,4
81133334:	0013883a 	mov	r9,zero
81133338:	dac02315 	stw	r11,140(sp)
8113333c:	003cce06 	br	81132678 <__reset+0xfb112678>
81133340:	8809883a 	mov	r4,r17
81133344:	da002c15 	stw	r8,176(sp)
81133348:	11251780 	call	81125178 <strlen>
8113334c:	d8802115 	stw	r2,132(sp)
81133350:	da801d83 	ldbu	r10,118(sp)
81133354:	df002315 	stw	fp,140(sp)
81133358:	0021883a 	mov	r16,zero
8113335c:	da002c17 	ldw	r8,176(sp)
81133360:	003cf606 	br	8113273c <__reset+0xfb11273c>
81133364:	00800184 	movi	r2,6
81133368:	1400012e 	bgeu	r2,r16,81133370 <___svfiprintf_internal_r+0x10ac>
8113336c:	1021883a 	mov	r16,r2
81133370:	dc002115 	stw	r16,132(sp)
81133374:	8005883a 	mov	r2,r16
81133378:	80003c16 	blt	r16,zero,8113346c <___svfiprintf_internal_r+0x11a8>
8113337c:	04604574 	movhi	r17,33045
81133380:	d8802015 	stw	r2,128(sp)
81133384:	df002315 	stw	fp,140(sp)
81133388:	8c4a9204 	addi	r17,r17,10824
8113338c:	003d2e06 	br	81132848 <__reset+0xfb112848>
81133390:	04001004 	movi	r16,64
81133394:	800b883a 	mov	r5,r16
81133398:	1123eec0 	call	81123eec <_malloc_r>
8113339c:	dac02717 	ldw	r11,156(sp)
811333a0:	58800015 	stw	r2,0(r11)
811333a4:	58800415 	stw	r2,16(r11)
811333a8:	10004826 	beq	r2,zero,811334cc <___svfiprintf_internal_r+0x1208>
811333ac:	dac02717 	ldw	r11,156(sp)
811333b0:	5c000515 	stw	r16,20(r11)
811333b4:	003bd906 	br	8113231c <__reset+0xfb11231c>
811333b8:	9080004c 	andi	r2,r18,1
811333bc:	0015883a 	mov	r10,zero
811333c0:	10000626 	beq	r2,zero,811333dc <___svfiprintf_internal_r+0x1118>
811333c4:	dac02b17 	ldw	r11,172(sp)
811333c8:	00800c04 	movi	r2,48
811333cc:	d88019c5 	stb	r2,103(sp)
811333d0:	dac02115 	stw	r11,132(sp)
811333d4:	dc4019c4 	addi	r17,sp,103
811333d8:	003cd806 	br	8113273c <__reset+0xfb11273c>
811333dc:	d8002115 	stw	zero,132(sp)
811333e0:	dc401a04 	addi	r17,sp,104
811333e4:	003cd506 	br	8113273c <__reset+0xfb11273c>
811333e8:	01204574 	movhi	r4,33045
811333ec:	210b1b04 	addi	r4,r4,11372
811333f0:	d9002815 	stw	r4,160(sp)
811333f4:	003d4306 	br	81132904 <__reset+0xfb112904>
811333f8:	00bfffc4 	movi	r2,-1
811333fc:	003ec606 	br	81132f18 <__reset+0xfb112f18>
81133400:	00800044 	movi	r2,1
81133404:	10803fcc 	andi	r2,r2,255
81133408:	00c00044 	movi	r3,1
8113340c:	10fd8026 	beq	r2,r3,81132a10 <__reset+0xfb112a10>
81133410:	00c00084 	movi	r3,2
81133414:	10fca426 	beq	r2,r3,811326a8 <__reset+0xfb1126a8>
81133418:	003ce806 	br	811327bc <__reset+0xfb1127bc>
8113341c:	01204574 	movhi	r4,33045
81133420:	210b1b04 	addi	r4,r4,11372
81133424:	d9002815 	stw	r4,160(sp)
81133428:	003e9906 	br	81132e90 <__reset+0xfb112e90>
8113342c:	1025883a 	mov	r18,r2
81133430:	0015883a 	mov	r10,zero
81133434:	00800084 	movi	r2,2
81133438:	003ff206 	br	81133404 <__reset+0xfb113404>
8113343c:	01604574 	movhi	r5,33045
81133440:	294b1704 	addi	r5,r5,11356
81133444:	d9402215 	stw	r5,136(sp)
81133448:	003ee206 	br	81132fd4 <__reset+0xfb112fd4>
8113344c:	5827883a 	mov	r19,r11
81133450:	0021883a 	mov	r16,zero
81133454:	003bed06 	br	8113240c <__reset+0xfb11240c>
81133458:	dc002115 	stw	r16,132(sp)
8113345c:	da801d83 	ldbu	r10,118(sp)
81133460:	df002315 	stw	fp,140(sp)
81133464:	0021883a 	mov	r16,zero
81133468:	003cb406 	br	8113273c <__reset+0xfb11273c>
8113346c:	0005883a 	mov	r2,zero
81133470:	003fc206 	br	8113337c <__reset+0xfb11337c>
81133474:	d8802317 	ldw	r2,140(sp)
81133478:	98c00043 	ldbu	r3,1(r19)
8113347c:	5827883a 	mov	r19,r11
81133480:	14000017 	ldw	r16,0(r2)
81133484:	10800104 	addi	r2,r2,4
81133488:	d8802315 	stw	r2,140(sp)
8113348c:	803f760e 	bge	r16,zero,81133268 <__reset+0xfb113268>
81133490:	18c03fcc 	andi	r3,r3,255
81133494:	18c0201c 	xori	r3,r3,128
81133498:	043fffc4 	movi	r16,-1
8113349c:	18ffe004 	addi	r3,r3,-128
811334a0:	003bd906 	br	81132408 <__reset+0xfb112408>
811334a4:	d9c01d85 	stb	r7,118(sp)
811334a8:	003cb606 	br	81132784 <__reset+0xfb112784>
811334ac:	d9c01d85 	stb	r7,118(sp)
811334b0:	003d2106 	br	81132938 <__reset+0xfb112938>
811334b4:	d9c01d85 	stb	r7,118(sp)
811334b8:	003d8e06 	br	81132af4 <__reset+0xfb112af4>
811334bc:	d9c01d85 	stb	r7,118(sp)
811334c0:	003db306 	br	81132b90 <__reset+0xfb112b90>
811334c4:	d9c01d85 	stb	r7,118(sp)
811334c8:	003c8a06 	br	811326f4 <__reset+0xfb1126f4>
811334cc:	dac02a17 	ldw	r11,168(sp)
811334d0:	00800304 	movi	r2,12
811334d4:	58800015 	stw	r2,0(r11)
811334d8:	00bfffc4 	movi	r2,-1
811334dc:	003e8e06 	br	81132f18 <__reset+0xfb112f18>
811334e0:	d9c01d85 	stb	r7,118(sp)
811334e4:	003dc706 	br	81132c04 <__reset+0xfb112c04>
811334e8:	d9c01d85 	stb	r7,118(sp)
811334ec:	003ddf06 	br	81132c6c <__reset+0xfb112c6c>
811334f0:	d9c01d85 	stb	r7,118(sp)
811334f4:	003d3706 	br	811329d4 <__reset+0xfb1129d4>
811334f8:	d9c01d85 	stb	r7,118(sp)
811334fc:	003c5406 	br	81132650 <__reset+0xfb112650>
81133500:	d9c01d85 	stb	r7,118(sp)
81133504:	003d1d06 	br	8113297c <__reset+0xfb11297c>

81133508 <__submore>:
81133508:	defffa04 	addi	sp,sp,-24
8113350c:	de00012e 	bgeu	sp,et,81133514 <__submore+0xc>
81133510:	003b68fa 	trap	3
81133514:	dc000015 	stw	r16,0(sp)
81133518:	2821883a 	mov	r16,r5
8113351c:	29400c17 	ldw	r5,48(r5)
81133520:	dfc00515 	stw	ra,20(sp)
81133524:	dd000415 	stw	r20,16(sp)
81133528:	dcc00315 	stw	r19,12(sp)
8113352c:	dc800215 	stw	r18,8(sp)
81133530:	dc400115 	stw	r17,4(sp)
81133534:	80801004 	addi	r2,r16,64
81133538:	28801726 	beq	r5,r2,81133598 <__submore+0x90>
8113353c:	84400d17 	ldw	r17,52(r16)
81133540:	8c67883a 	add	r19,r17,r17
81133544:	980d883a 	mov	r6,r19
81133548:	112fc7c0 	call	8112fc7c <_realloc_r>
8113354c:	1025883a 	mov	r18,r2
81133550:	10002226 	beq	r2,zero,811335dc <__submore+0xd4>
81133554:	1469883a 	add	r20,r2,r17
81133558:	880d883a 	mov	r6,r17
8113355c:	100b883a 	mov	r5,r2
81133560:	a009883a 	mov	r4,r20
81133564:	11247000 	call	81124700 <memcpy>
81133568:	0005883a 	mov	r2,zero
8113356c:	85000015 	stw	r20,0(r16)
81133570:	84800c15 	stw	r18,48(r16)
81133574:	84c00d15 	stw	r19,52(r16)
81133578:	dfc00517 	ldw	ra,20(sp)
8113357c:	dd000417 	ldw	r20,16(sp)
81133580:	dcc00317 	ldw	r19,12(sp)
81133584:	dc800217 	ldw	r18,8(sp)
81133588:	dc400117 	ldw	r17,4(sp)
8113358c:	dc000017 	ldw	r16,0(sp)
81133590:	dec00604 	addi	sp,sp,24
81133594:	f800283a 	ret
81133598:	04410004 	movi	r17,1024
8113359c:	880b883a 	mov	r5,r17
811335a0:	1123eec0 	call	81123eec <_malloc_r>
811335a4:	1007883a 	mov	r3,r2
811335a8:	10000c26 	beq	r2,zero,811335dc <__submore+0xd4>
811335ac:	80801083 	ldbu	r2,66(r16)
811335b0:	80c00c15 	stw	r3,48(r16)
811335b4:	84400d15 	stw	r17,52(r16)
811335b8:	1880ffc5 	stb	r2,1023(r3)
811335bc:	81401043 	ldbu	r5,65(r16)
811335c0:	1900ff44 	addi	r4,r3,1021
811335c4:	0005883a 	mov	r2,zero
811335c8:	1940ff85 	stb	r5,1022(r3)
811335cc:	81401003 	ldbu	r5,64(r16)
811335d0:	1940ff45 	stb	r5,1021(r3)
811335d4:	81000015 	stw	r4,0(r16)
811335d8:	003fe706 	br	81133578 <__reset+0xfb113578>
811335dc:	00bfffc4 	movi	r2,-1
811335e0:	003fe506 	br	81133578 <__reset+0xfb113578>

811335e4 <_ungetc_r>:
811335e4:	00bfffc4 	movi	r2,-1
811335e8:	28806326 	beq	r5,r2,81133778 <_ungetc_r+0x194>
811335ec:	defffb04 	addi	sp,sp,-20
811335f0:	de00012e 	bgeu	sp,et,811335f8 <_ungetc_r+0x14>
811335f4:	003b68fa 	trap	3
811335f8:	dcc00315 	stw	r19,12(sp)
811335fc:	dc400115 	stw	r17,4(sp)
81133600:	dc000015 	stw	r16,0(sp)
81133604:	dfc00415 	stw	ra,16(sp)
81133608:	dc800215 	stw	r18,8(sp)
8113360c:	2023883a 	mov	r17,r4
81133610:	3021883a 	mov	r16,r6
81133614:	2827883a 	mov	r19,r5
81133618:	20000226 	beq	r4,zero,81133624 <_ungetc_r+0x40>
8113361c:	20800e17 	ldw	r2,56(r4)
81133620:	10002e26 	beq	r2,zero,811336dc <_ungetc_r+0xf8>
81133624:	80c0030b 	ldhu	r3,12(r16)
81133628:	1888000c 	andi	r2,r3,8192
8113362c:	1000051e 	bne	r2,zero,81133644 <_ungetc_r+0x60>
81133630:	81001917 	ldw	r4,100(r16)
81133634:	00b7ffc4 	movi	r2,-8193
81133638:	18c80014 	ori	r3,r3,8192
8113363c:	2084703a 	and	r2,r4,r2
81133640:	80801915 	stw	r2,100(r16)
81133644:	00bff7c4 	movi	r2,-33
81133648:	1884703a 	and	r2,r3,r2
8113364c:	8080030d 	sth	r2,12(r16)
81133650:	1900010c 	andi	r4,r3,4
81133654:	2000061e 	bne	r4,zero,81133670 <_ungetc_r+0x8c>
81133658:	1900040c 	andi	r4,r3,16
8113365c:	20001d26 	beq	r4,zero,811336d4 <_ungetc_r+0xf0>
81133660:	18c0020c 	andi	r3,r3,8
81133664:	1800331e 	bne	r3,zero,81133734 <_ungetc_r+0x150>
81133668:	10800114 	ori	r2,r2,4
8113366c:	8080030d 	sth	r2,12(r16)
81133670:	80800c17 	ldw	r2,48(r16)
81133674:	9c803fcc 	andi	r18,r19,255
81133678:	10001a26 	beq	r2,zero,811336e4 <_ungetc_r+0x100>
8113367c:	80c00117 	ldw	r3,4(r16)
81133680:	80800d17 	ldw	r2,52(r16)
81133684:	18800f0e 	bge	r3,r2,811336c4 <_ungetc_r+0xe0>
81133688:	80c00017 	ldw	r3,0(r16)
8113368c:	9005883a 	mov	r2,r18
81133690:	193fffc4 	addi	r4,r3,-1
81133694:	81000015 	stw	r4,0(r16)
81133698:	1cffffc5 	stb	r19,-1(r3)
8113369c:	80c00117 	ldw	r3,4(r16)
811336a0:	18c00044 	addi	r3,r3,1
811336a4:	80c00115 	stw	r3,4(r16)
811336a8:	dfc00417 	ldw	ra,16(sp)
811336ac:	dcc00317 	ldw	r19,12(sp)
811336b0:	dc800217 	ldw	r18,8(sp)
811336b4:	dc400117 	ldw	r17,4(sp)
811336b8:	dc000017 	ldw	r16,0(sp)
811336bc:	dec00504 	addi	sp,sp,20
811336c0:	f800283a 	ret
811336c4:	800b883a 	mov	r5,r16
811336c8:	8809883a 	mov	r4,r17
811336cc:	11335080 	call	81133508 <__submore>
811336d0:	103fed26 	beq	r2,zero,81133688 <__reset+0xfb113688>
811336d4:	00bfffc4 	movi	r2,-1
811336d8:	003ff306 	br	811336a8 <__reset+0xfb1136a8>
811336dc:	112d7500 	call	8112d750 <__sinit>
811336e0:	003fd006 	br	81133624 <__reset+0xfb113624>
811336e4:	80c00417 	ldw	r3,16(r16)
811336e8:	80800017 	ldw	r2,0(r16)
811336ec:	18000326 	beq	r3,zero,811336fc <_ungetc_r+0x118>
811336f0:	1880022e 	bgeu	r3,r2,811336fc <_ungetc_r+0x118>
811336f4:	10ffffc3 	ldbu	r3,-1(r2)
811336f8:	90c01826 	beq	r18,r3,8113375c <_ungetc_r+0x178>
811336fc:	81400117 	ldw	r5,4(r16)
81133700:	80800e15 	stw	r2,56(r16)
81133704:	008000c4 	movi	r2,3
81133708:	81001004 	addi	r4,r16,64
8113370c:	80c01084 	addi	r3,r16,66
81133710:	80800d15 	stw	r2,52(r16)
81133714:	00800044 	movi	r2,1
81133718:	80800115 	stw	r2,4(r16)
8113371c:	81400f15 	stw	r5,60(r16)
81133720:	81000c15 	stw	r4,48(r16)
81133724:	84c01085 	stb	r19,66(r16)
81133728:	80c00015 	stw	r3,0(r16)
8113372c:	9005883a 	mov	r2,r18
81133730:	003fdd06 	br	811336a8 <__reset+0xfb1136a8>
81133734:	800b883a 	mov	r5,r16
81133738:	8809883a 	mov	r4,r17
8113373c:	112d3540 	call	8112d354 <_fflush_r>
81133740:	103fe41e 	bne	r2,zero,811336d4 <__reset+0xfb1136d4>
81133744:	8080030b 	ldhu	r2,12(r16)
81133748:	00fffdc4 	movi	r3,-9
8113374c:	80000215 	stw	zero,8(r16)
81133750:	1884703a 	and	r2,r3,r2
81133754:	80000615 	stw	zero,24(r16)
81133758:	003fc306 	br	81133668 <__reset+0xfb113668>
8113375c:	80c00117 	ldw	r3,4(r16)
81133760:	10bfffc4 	addi	r2,r2,-1
81133764:	80800015 	stw	r2,0(r16)
81133768:	18800044 	addi	r2,r3,1
8113376c:	80800115 	stw	r2,4(r16)
81133770:	9005883a 	mov	r2,r18
81133774:	003fcc06 	br	811336a8 <__reset+0xfb1136a8>
81133778:	00bfffc4 	movi	r2,-1
8113377c:	f800283a 	ret

81133780 <ungetc>:
81133780:	00a04574 	movhi	r2,33045
81133784:	10945c04 	addi	r2,r2,20848
81133788:	280d883a 	mov	r6,r5
8113378c:	200b883a 	mov	r5,r4
81133790:	11000017 	ldw	r4,0(r2)
81133794:	11335e41 	jmpi	811335e4 <_ungetc_r>

81133798 <__sprint_r.part.0>:
81133798:	defff604 	addi	sp,sp,-40
8113379c:	de00012e 	bgeu	sp,et,811337a4 <__sprint_r.part.0+0xc>
811337a0:	003b68fa 	trap	3
811337a4:	28801917 	ldw	r2,100(r5)
811337a8:	dd400515 	stw	r21,20(sp)
811337ac:	dfc00915 	stw	ra,36(sp)
811337b0:	df000815 	stw	fp,32(sp)
811337b4:	ddc00715 	stw	r23,28(sp)
811337b8:	dd800615 	stw	r22,24(sp)
811337bc:	dd000415 	stw	r20,16(sp)
811337c0:	dcc00315 	stw	r19,12(sp)
811337c4:	dc800215 	stw	r18,8(sp)
811337c8:	dc400115 	stw	r17,4(sp)
811337cc:	dc000015 	stw	r16,0(sp)
811337d0:	1088000c 	andi	r2,r2,8192
811337d4:	302b883a 	mov	r21,r6
811337d8:	10002e26 	beq	r2,zero,81133894 <__sprint_r.part.0+0xfc>
811337dc:	30800217 	ldw	r2,8(r6)
811337e0:	35800017 	ldw	r22,0(r6)
811337e4:	10002926 	beq	r2,zero,8113388c <__sprint_r.part.0+0xf4>
811337e8:	2827883a 	mov	r19,r5
811337ec:	2029883a 	mov	r20,r4
811337f0:	b5c00104 	addi	r23,r22,4
811337f4:	04bfffc4 	movi	r18,-1
811337f8:	bc400017 	ldw	r17,0(r23)
811337fc:	b4000017 	ldw	r16,0(r22)
81133800:	0039883a 	mov	fp,zero
81133804:	8822d0ba 	srli	r17,r17,2
81133808:	8800031e 	bne	r17,zero,81133818 <__sprint_r.part.0+0x80>
8113380c:	00001806 	br	81133870 <__sprint_r.part.0+0xd8>
81133810:	84000104 	addi	r16,r16,4
81133814:	8f001526 	beq	r17,fp,8113386c <__sprint_r.part.0+0xd4>
81133818:	81400017 	ldw	r5,0(r16)
8113381c:	980d883a 	mov	r6,r19
81133820:	a009883a 	mov	r4,r20
81133824:	113513c0 	call	8113513c <_fputwc_r>
81133828:	e7000044 	addi	fp,fp,1
8113382c:	14bff81e 	bne	r2,r18,81133810 <__reset+0xfb113810>
81133830:	9005883a 	mov	r2,r18
81133834:	a8000215 	stw	zero,8(r21)
81133838:	a8000115 	stw	zero,4(r21)
8113383c:	dfc00917 	ldw	ra,36(sp)
81133840:	df000817 	ldw	fp,32(sp)
81133844:	ddc00717 	ldw	r23,28(sp)
81133848:	dd800617 	ldw	r22,24(sp)
8113384c:	dd400517 	ldw	r21,20(sp)
81133850:	dd000417 	ldw	r20,16(sp)
81133854:	dcc00317 	ldw	r19,12(sp)
81133858:	dc800217 	ldw	r18,8(sp)
8113385c:	dc400117 	ldw	r17,4(sp)
81133860:	dc000017 	ldw	r16,0(sp)
81133864:	dec00a04 	addi	sp,sp,40
81133868:	f800283a 	ret
8113386c:	a8800217 	ldw	r2,8(r21)
81133870:	8c63883a 	add	r17,r17,r17
81133874:	8c63883a 	add	r17,r17,r17
81133878:	1445c83a 	sub	r2,r2,r17
8113387c:	a8800215 	stw	r2,8(r21)
81133880:	b5800204 	addi	r22,r22,8
81133884:	bdc00204 	addi	r23,r23,8
81133888:	103fdb1e 	bne	r2,zero,811337f8 <__reset+0xfb1137f8>
8113388c:	0005883a 	mov	r2,zero
81133890:	003fe806 	br	81133834 <__reset+0xfb113834>
81133894:	112df000 	call	8112df00 <__sfvwrite_r>
81133898:	003fe606 	br	81133834 <__reset+0xfb113834>

8113389c <__sprint_r>:
8113389c:	30c00217 	ldw	r3,8(r6)
811338a0:	18000126 	beq	r3,zero,811338a8 <__sprint_r+0xc>
811338a4:	11337981 	jmpi	81133798 <__sprint_r.part.0>
811338a8:	30000115 	stw	zero,4(r6)
811338ac:	0005883a 	mov	r2,zero
811338b0:	f800283a 	ret

811338b4 <___vfiprintf_internal_r>:
811338b4:	deffc904 	addi	sp,sp,-220
811338b8:	de00012e 	bgeu	sp,et,811338c0 <___vfiprintf_internal_r+0xc>
811338bc:	003b68fa 	trap	3
811338c0:	df003515 	stw	fp,212(sp)
811338c4:	dd003115 	stw	r20,196(sp)
811338c8:	dfc03615 	stw	ra,216(sp)
811338cc:	ddc03415 	stw	r23,208(sp)
811338d0:	dd803315 	stw	r22,204(sp)
811338d4:	dd403215 	stw	r21,200(sp)
811338d8:	dcc03015 	stw	r19,192(sp)
811338dc:	dc802f15 	stw	r18,188(sp)
811338e0:	dc402e15 	stw	r17,184(sp)
811338e4:	dc002d15 	stw	r16,180(sp)
811338e8:	d9002015 	stw	r4,128(sp)
811338ec:	d9c02215 	stw	r7,136(sp)
811338f0:	2829883a 	mov	r20,r5
811338f4:	3039883a 	mov	fp,r6
811338f8:	20000226 	beq	r4,zero,81133904 <___vfiprintf_internal_r+0x50>
811338fc:	20800e17 	ldw	r2,56(r4)
81133900:	1000cf26 	beq	r2,zero,81133c40 <___vfiprintf_internal_r+0x38c>
81133904:	a080030b 	ldhu	r2,12(r20)
81133908:	10c8000c 	andi	r3,r2,8192
8113390c:	1800061e 	bne	r3,zero,81133928 <___vfiprintf_internal_r+0x74>
81133910:	a1001917 	ldw	r4,100(r20)
81133914:	00f7ffc4 	movi	r3,-8193
81133918:	10880014 	ori	r2,r2,8192
8113391c:	20c6703a 	and	r3,r4,r3
81133920:	a080030d 	sth	r2,12(r20)
81133924:	a0c01915 	stw	r3,100(r20)
81133928:	10c0020c 	andi	r3,r2,8
8113392c:	1800a926 	beq	r3,zero,81133bd4 <___vfiprintf_internal_r+0x320>
81133930:	a0c00417 	ldw	r3,16(r20)
81133934:	1800a726 	beq	r3,zero,81133bd4 <___vfiprintf_internal_r+0x320>
81133938:	1080068c 	andi	r2,r2,26
8113393c:	00c00284 	movi	r3,10
81133940:	10c0ac26 	beq	r2,r3,81133bf4 <___vfiprintf_internal_r+0x340>
81133944:	da801a04 	addi	r10,sp,104
81133948:	da801e15 	stw	r10,120(sp)
8113394c:	d8801e17 	ldw	r2,120(sp)
81133950:	da8019c4 	addi	r10,sp,103
81133954:	05a04574 	movhi	r22,33045
81133958:	05e04574 	movhi	r23,33045
8113395c:	da801f15 	stw	r10,124(sp)
81133960:	1295c83a 	sub	r10,r2,r10
81133964:	b58b2304 	addi	r22,r22,11404
81133968:	bdcb1f04 	addi	r23,r23,11388
8113396c:	dec01a15 	stw	sp,104(sp)
81133970:	d8001c15 	stw	zero,112(sp)
81133974:	d8001b15 	stw	zero,108(sp)
81133978:	d8002615 	stw	zero,152(sp)
8113397c:	d8002315 	stw	zero,140(sp)
81133980:	da802715 	stw	r10,156(sp)
81133984:	d811883a 	mov	r8,sp
81133988:	dd002115 	stw	r20,132(sp)
8113398c:	e021883a 	mov	r16,fp
81133990:	80800007 	ldb	r2,0(r16)
81133994:	1003ea26 	beq	r2,zero,81134940 <___vfiprintf_internal_r+0x108c>
81133998:	00c00944 	movi	r3,37
8113399c:	8025883a 	mov	r18,r16
811339a0:	10c0021e 	bne	r2,r3,811339ac <___vfiprintf_internal_r+0xf8>
811339a4:	00001606 	br	81133a00 <___vfiprintf_internal_r+0x14c>
811339a8:	10c00326 	beq	r2,r3,811339b8 <___vfiprintf_internal_r+0x104>
811339ac:	94800044 	addi	r18,r18,1
811339b0:	90800007 	ldb	r2,0(r18)
811339b4:	103ffc1e 	bne	r2,zero,811339a8 <__reset+0xfb1139a8>
811339b8:	9423c83a 	sub	r17,r18,r16
811339bc:	88001026 	beq	r17,zero,81133a00 <___vfiprintf_internal_r+0x14c>
811339c0:	d8c01c17 	ldw	r3,112(sp)
811339c4:	d8801b17 	ldw	r2,108(sp)
811339c8:	44000015 	stw	r16,0(r8)
811339cc:	88c7883a 	add	r3,r17,r3
811339d0:	10800044 	addi	r2,r2,1
811339d4:	44400115 	stw	r17,4(r8)
811339d8:	d8c01c15 	stw	r3,112(sp)
811339dc:	d8801b15 	stw	r2,108(sp)
811339e0:	010001c4 	movi	r4,7
811339e4:	2080760e 	bge	r4,r2,81133bc0 <___vfiprintf_internal_r+0x30c>
811339e8:	1803821e 	bne	r3,zero,811347f4 <___vfiprintf_internal_r+0xf40>
811339ec:	da802317 	ldw	r10,140(sp)
811339f0:	d8001b15 	stw	zero,108(sp)
811339f4:	d811883a 	mov	r8,sp
811339f8:	5455883a 	add	r10,r10,r17
811339fc:	da802315 	stw	r10,140(sp)
81133a00:	90800007 	ldb	r2,0(r18)
81133a04:	10044626 	beq	r2,zero,81134b20 <___vfiprintf_internal_r+0x126c>
81133a08:	90c00047 	ldb	r3,1(r18)
81133a0c:	94000044 	addi	r16,r18,1
81133a10:	d8001d85 	stb	zero,118(sp)
81133a14:	0009883a 	mov	r4,zero
81133a18:	000f883a 	mov	r7,zero
81133a1c:	027fffc4 	movi	r9,-1
81133a20:	0023883a 	mov	r17,zero
81133a24:	0029883a 	mov	r20,zero
81133a28:	01401604 	movi	r5,88
81133a2c:	01800244 	movi	r6,9
81133a30:	03400a84 	movi	r13,42
81133a34:	03001b04 	movi	r12,108
81133a38:	84000044 	addi	r16,r16,1
81133a3c:	18bff804 	addi	r2,r3,-32
81133a40:	28827336 	bltu	r5,r2,81134410 <___vfiprintf_internal_r+0xb5c>
81133a44:	100490ba 	slli	r2,r2,2
81133a48:	02a044f4 	movhi	r10,33043
81133a4c:	528e9704 	addi	r10,r10,14940
81133a50:	1285883a 	add	r2,r2,r10
81133a54:	10800017 	ldw	r2,0(r2)
81133a58:	1000683a 	jmp	r2
81133a5c:	81134144 	addi	r4,r16,19717
81133a60:	81134410 	cmplti	r4,r16,19728
81133a64:	81134410 	cmplti	r4,r16,19728
81133a68:	81134164 	muli	r4,r16,19717
81133a6c:	81134410 	cmplti	r4,r16,19728
81133a70:	81134410 	cmplti	r4,r16,19728
81133a74:	81134410 	cmplti	r4,r16,19728
81133a78:	81134410 	cmplti	r4,r16,19728
81133a7c:	81134410 	cmplti	r4,r16,19728
81133a80:	81134410 	cmplti	r4,r16,19728
81133a84:	8113434c 	andi	r4,r16,19725
81133a88:	81134368 	cmpgeui	r4,r16,19725
81133a8c:	81134410 	cmplti	r4,r16,19728
81133a90:	81133c50 	cmplti	r4,r16,19697
81133a94:	81134378 	rdprs	r4,r16,19725
81133a98:	81134410 	cmplti	r4,r16,19728
81133a9c:	81134170 	cmpltui	r4,r16,19717
81133aa0:	8113417c 	xorhi	r4,r16,19717
81133aa4:	8113417c 	xorhi	r4,r16,19717
81133aa8:	8113417c 	xorhi	r4,r16,19717
81133aac:	8113417c 	xorhi	r4,r16,19717
81133ab0:	8113417c 	xorhi	r4,r16,19717
81133ab4:	8113417c 	xorhi	r4,r16,19717
81133ab8:	8113417c 	xorhi	r4,r16,19717
81133abc:	8113417c 	xorhi	r4,r16,19717
81133ac0:	8113417c 	xorhi	r4,r16,19717
81133ac4:	81134410 	cmplti	r4,r16,19728
81133ac8:	81134410 	cmplti	r4,r16,19728
81133acc:	81134410 	cmplti	r4,r16,19728
81133ad0:	81134410 	cmplti	r4,r16,19728
81133ad4:	81134410 	cmplti	r4,r16,19728
81133ad8:	81134410 	cmplti	r4,r16,19728
81133adc:	81134410 	cmplti	r4,r16,19728
81133ae0:	81134410 	cmplti	r4,r16,19728
81133ae4:	81134410 	cmplti	r4,r16,19728
81133ae8:	81134410 	cmplti	r4,r16,19728
81133aec:	811341a8 	cmpgeui	r4,r16,19718
81133af0:	81134410 	cmplti	r4,r16,19728
81133af4:	81134410 	cmplti	r4,r16,19728
81133af8:	81134410 	cmplti	r4,r16,19728
81133afc:	81134410 	cmplti	r4,r16,19728
81133b00:	81134410 	cmplti	r4,r16,19728
81133b04:	81134410 	cmplti	r4,r16,19728
81133b08:	81134410 	cmplti	r4,r16,19728
81133b0c:	81134410 	cmplti	r4,r16,19728
81133b10:	81134410 	cmplti	r4,r16,19728
81133b14:	81134410 	cmplti	r4,r16,19728
81133b18:	811341e0 	cmpeqi	r4,r16,19719
81133b1c:	81134410 	cmplti	r4,r16,19728
81133b20:	81134410 	cmplti	r4,r16,19728
81133b24:	81134410 	cmplti	r4,r16,19728
81133b28:	81134410 	cmplti	r4,r16,19728
81133b2c:	81134410 	cmplti	r4,r16,19728
81133b30:	81134238 	rdprs	r4,r16,19720
81133b34:	81134410 	cmplti	r4,r16,19728
81133b38:	81134410 	cmplti	r4,r16,19728
81133b3c:	811342a8 	cmpgeui	r4,r16,19722
81133b40:	81134410 	cmplti	r4,r16,19728
81133b44:	81134410 	cmplti	r4,r16,19728
81133b48:	81134410 	cmplti	r4,r16,19728
81133b4c:	81134410 	cmplti	r4,r16,19728
81133b50:	81134410 	cmplti	r4,r16,19728
81133b54:	81134410 	cmplti	r4,r16,19728
81133b58:	81134410 	cmplti	r4,r16,19728
81133b5c:	81134410 	cmplti	r4,r16,19728
81133b60:	81134410 	cmplti	r4,r16,19728
81133b64:	81134410 	cmplti	r4,r16,19728
81133b68:	81134054 	ori	r4,r16,19713
81133b6c:	81134080 	call	88113408 <__reset+0x20f3408>
81133b70:	81134410 	cmplti	r4,r16,19728
81133b74:	81134410 	cmplti	r4,r16,19728
81133b78:	81134410 	cmplti	r4,r16,19728
81133b7c:	811343b8 	rdprs	r4,r16,19726
81133b80:	81134080 	call	88113408 <__reset+0x20f3408>
81133b84:	81134410 	cmplti	r4,r16,19728
81133b88:	81134410 	cmplti	r4,r16,19728
81133b8c:	81133f14 	ori	r4,r16,19708
81133b90:	81134410 	cmplti	r4,r16,19728
81133b94:	81133f24 	muli	r4,r16,19708
81133b98:	81133f60 	cmpeqi	r4,r16,19709
81133b9c:	81133c5c 	xori	r4,r16,19697
81133ba0:	81133f08 	cmpgei	r4,r16,19708
81133ba4:	81134410 	cmplti	r4,r16,19728
81133ba8:	811342e4 	muli	r4,r16,19723
81133bac:	81134410 	cmplti	r4,r16,19728
81133bb0:	8113433c 	xorhi	r4,r16,19724
81133bb4:	81134410 	cmplti	r4,r16,19728
81133bb8:	81134410 	cmplti	r4,r16,19728
81133bbc:	81134000 	call	88113400 <__reset+0x20f3400>
81133bc0:	42000204 	addi	r8,r8,8
81133bc4:	da802317 	ldw	r10,140(sp)
81133bc8:	5455883a 	add	r10,r10,r17
81133bcc:	da802315 	stw	r10,140(sp)
81133bd0:	003f8b06 	br	81133a00 <__reset+0xfb113a00>
81133bd4:	d9002017 	ldw	r4,128(sp)
81133bd8:	a00b883a 	mov	r5,r20
81133bdc:	112b6e00 	call	8112b6e0 <__swsetup_r>
81133be0:	1003b11e 	bne	r2,zero,81134aa8 <___vfiprintf_internal_r+0x11f4>
81133be4:	a080030b 	ldhu	r2,12(r20)
81133be8:	00c00284 	movi	r3,10
81133bec:	1080068c 	andi	r2,r2,26
81133bf0:	10ff541e 	bne	r2,r3,81133944 <__reset+0xfb113944>
81133bf4:	a080038f 	ldh	r2,14(r20)
81133bf8:	103f5216 	blt	r2,zero,81133944 <__reset+0xfb113944>
81133bfc:	d9c02217 	ldw	r7,136(sp)
81133c00:	d9002017 	ldw	r4,128(sp)
81133c04:	e00d883a 	mov	r6,fp
81133c08:	a00b883a 	mov	r5,r20
81133c0c:	1134d340 	call	81134d34 <__sbprintf>
81133c10:	dfc03617 	ldw	ra,216(sp)
81133c14:	df003517 	ldw	fp,212(sp)
81133c18:	ddc03417 	ldw	r23,208(sp)
81133c1c:	dd803317 	ldw	r22,204(sp)
81133c20:	dd403217 	ldw	r21,200(sp)
81133c24:	dd003117 	ldw	r20,196(sp)
81133c28:	dcc03017 	ldw	r19,192(sp)
81133c2c:	dc802f17 	ldw	r18,188(sp)
81133c30:	dc402e17 	ldw	r17,184(sp)
81133c34:	dc002d17 	ldw	r16,180(sp)
81133c38:	dec03704 	addi	sp,sp,220
81133c3c:	f800283a 	ret
81133c40:	112d7500 	call	8112d750 <__sinit>
81133c44:	003f2f06 	br	81133904 <__reset+0xfb113904>
81133c48:	0463c83a 	sub	r17,zero,r17
81133c4c:	d8802215 	stw	r2,136(sp)
81133c50:	a5000114 	ori	r20,r20,4
81133c54:	80c00007 	ldb	r3,0(r16)
81133c58:	003f7706 	br	81133a38 <__reset+0xfb113a38>
81133c5c:	00800c04 	movi	r2,48
81133c60:	da802217 	ldw	r10,136(sp)
81133c64:	d8801d05 	stb	r2,116(sp)
81133c68:	00801e04 	movi	r2,120
81133c6c:	d8801d45 	stb	r2,117(sp)
81133c70:	d8001d85 	stb	zero,118(sp)
81133c74:	50c00104 	addi	r3,r10,4
81133c78:	54800017 	ldw	r18,0(r10)
81133c7c:	0027883a 	mov	r19,zero
81133c80:	a0800094 	ori	r2,r20,2
81133c84:	48030b16 	blt	r9,zero,811348b4 <___vfiprintf_internal_r+0x1000>
81133c88:	00bfdfc4 	movi	r2,-129
81133c8c:	a096703a 	and	r11,r20,r2
81133c90:	d8c02215 	stw	r3,136(sp)
81133c94:	5d000094 	ori	r20,r11,2
81133c98:	90032b1e 	bne	r18,zero,81134948 <___vfiprintf_internal_r+0x1094>
81133c9c:	00a04574 	movhi	r2,33045
81133ca0:	108a8d04 	addi	r2,r2,10804
81133ca4:	d8802615 	stw	r2,152(sp)
81133ca8:	0039883a 	mov	fp,zero
81133cac:	48017b1e 	bne	r9,zero,8113429c <___vfiprintf_internal_r+0x9e8>
81133cb0:	0013883a 	mov	r9,zero
81133cb4:	0027883a 	mov	r19,zero
81133cb8:	dd401a04 	addi	r21,sp,104
81133cbc:	4825883a 	mov	r18,r9
81133cc0:	4cc0010e 	bge	r9,r19,81133cc8 <___vfiprintf_internal_r+0x414>
81133cc4:	9825883a 	mov	r18,r19
81133cc8:	e7003fcc 	andi	fp,fp,255
81133ccc:	e700201c 	xori	fp,fp,128
81133cd0:	e73fe004 	addi	fp,fp,-128
81133cd4:	e0000126 	beq	fp,zero,81133cdc <___vfiprintf_internal_r+0x428>
81133cd8:	94800044 	addi	r18,r18,1
81133cdc:	a380008c 	andi	r14,r20,2
81133ce0:	70000126 	beq	r14,zero,81133ce8 <___vfiprintf_internal_r+0x434>
81133ce4:	94800084 	addi	r18,r18,2
81133ce8:	a700210c 	andi	fp,r20,132
81133cec:	e001df1e 	bne	fp,zero,8113446c <___vfiprintf_internal_r+0xbb8>
81133cf0:	8c87c83a 	sub	r3,r17,r18
81133cf4:	00c1dd0e 	bge	zero,r3,8113446c <___vfiprintf_internal_r+0xbb8>
81133cf8:	01c00404 	movi	r7,16
81133cfc:	d8801c17 	ldw	r2,112(sp)
81133d00:	38c3ad0e 	bge	r7,r3,81134bb8 <___vfiprintf_internal_r+0x1304>
81133d04:	02a04574 	movhi	r10,33045
81133d08:	528b2304 	addi	r10,r10,11404
81133d0c:	dc002915 	stw	r16,164(sp)
81133d10:	d9801b17 	ldw	r6,108(sp)
81133d14:	da802415 	stw	r10,144(sp)
81133d18:	03c001c4 	movi	r15,7
81133d1c:	da402515 	stw	r9,148(sp)
81133d20:	db802815 	stw	r14,160(sp)
81133d24:	1821883a 	mov	r16,r3
81133d28:	00000506 	br	81133d40 <___vfiprintf_internal_r+0x48c>
81133d2c:	31400084 	addi	r5,r6,2
81133d30:	42000204 	addi	r8,r8,8
81133d34:	200d883a 	mov	r6,r4
81133d38:	843ffc04 	addi	r16,r16,-16
81133d3c:	3c000d0e 	bge	r7,r16,81133d74 <___vfiprintf_internal_r+0x4c0>
81133d40:	10800404 	addi	r2,r2,16
81133d44:	31000044 	addi	r4,r6,1
81133d48:	45800015 	stw	r22,0(r8)
81133d4c:	41c00115 	stw	r7,4(r8)
81133d50:	d8801c15 	stw	r2,112(sp)
81133d54:	d9001b15 	stw	r4,108(sp)
81133d58:	793ff40e 	bge	r15,r4,81133d2c <__reset+0xfb113d2c>
81133d5c:	1001b51e 	bne	r2,zero,81134434 <___vfiprintf_internal_r+0xb80>
81133d60:	843ffc04 	addi	r16,r16,-16
81133d64:	000d883a 	mov	r6,zero
81133d68:	01400044 	movi	r5,1
81133d6c:	d811883a 	mov	r8,sp
81133d70:	3c3ff316 	blt	r7,r16,81133d40 <__reset+0xfb113d40>
81133d74:	8007883a 	mov	r3,r16
81133d78:	da402517 	ldw	r9,148(sp)
81133d7c:	db802817 	ldw	r14,160(sp)
81133d80:	dc002917 	ldw	r16,164(sp)
81133d84:	da802417 	ldw	r10,144(sp)
81133d88:	1885883a 	add	r2,r3,r2
81133d8c:	40c00115 	stw	r3,4(r8)
81133d90:	42800015 	stw	r10,0(r8)
81133d94:	d8801c15 	stw	r2,112(sp)
81133d98:	d9401b15 	stw	r5,108(sp)
81133d9c:	00c001c4 	movi	r3,7
81133da0:	19426016 	blt	r3,r5,81134724 <___vfiprintf_internal_r+0xe70>
81133da4:	d8c01d87 	ldb	r3,118(sp)
81133da8:	42000204 	addi	r8,r8,8
81133dac:	29000044 	addi	r4,r5,1
81133db0:	1801b31e 	bne	r3,zero,81134480 <___vfiprintf_internal_r+0xbcc>
81133db4:	7001c026 	beq	r14,zero,811344b8 <___vfiprintf_internal_r+0xc04>
81133db8:	d8c01d04 	addi	r3,sp,116
81133dbc:	10800084 	addi	r2,r2,2
81133dc0:	40c00015 	stw	r3,0(r8)
81133dc4:	00c00084 	movi	r3,2
81133dc8:	40c00115 	stw	r3,4(r8)
81133dcc:	d8801c15 	stw	r2,112(sp)
81133dd0:	d9001b15 	stw	r4,108(sp)
81133dd4:	00c001c4 	movi	r3,7
81133dd8:	1902650e 	bge	r3,r4,81134770 <___vfiprintf_internal_r+0xebc>
81133ddc:	10029a1e 	bne	r2,zero,81134848 <___vfiprintf_internal_r+0xf94>
81133de0:	00c02004 	movi	r3,128
81133de4:	01000044 	movi	r4,1
81133de8:	000b883a 	mov	r5,zero
81133dec:	d811883a 	mov	r8,sp
81133df0:	e0c1b31e 	bne	fp,r3,811344c0 <___vfiprintf_internal_r+0xc0c>
81133df4:	8cb9c83a 	sub	fp,r17,r18
81133df8:	0701b10e 	bge	zero,fp,811344c0 <___vfiprintf_internal_r+0xc0c>
81133dfc:	01c00404 	movi	r7,16
81133e00:	3f03890e 	bge	r7,fp,81134c28 <___vfiprintf_internal_r+0x1374>
81133e04:	00e04574 	movhi	r3,33045
81133e08:	18cb1f04 	addi	r3,r3,11388
81133e0c:	d8c02415 	stw	r3,144(sp)
81133e10:	8007883a 	mov	r3,r16
81133e14:	034001c4 	movi	r13,7
81133e18:	e021883a 	mov	r16,fp
81133e1c:	da402515 	stw	r9,148(sp)
81133e20:	1839883a 	mov	fp,r3
81133e24:	00000506 	br	81133e3c <___vfiprintf_internal_r+0x588>
81133e28:	29800084 	addi	r6,r5,2
81133e2c:	42000204 	addi	r8,r8,8
81133e30:	180b883a 	mov	r5,r3
81133e34:	843ffc04 	addi	r16,r16,-16
81133e38:	3c000d0e 	bge	r7,r16,81133e70 <___vfiprintf_internal_r+0x5bc>
81133e3c:	10800404 	addi	r2,r2,16
81133e40:	28c00044 	addi	r3,r5,1
81133e44:	45c00015 	stw	r23,0(r8)
81133e48:	41c00115 	stw	r7,4(r8)
81133e4c:	d8801c15 	stw	r2,112(sp)
81133e50:	d8c01b15 	stw	r3,108(sp)
81133e54:	68fff40e 	bge	r13,r3,81133e28 <__reset+0xfb113e28>
81133e58:	1002241e 	bne	r2,zero,811346ec <___vfiprintf_internal_r+0xe38>
81133e5c:	843ffc04 	addi	r16,r16,-16
81133e60:	01800044 	movi	r6,1
81133e64:	000b883a 	mov	r5,zero
81133e68:	d811883a 	mov	r8,sp
81133e6c:	3c3ff316 	blt	r7,r16,81133e3c <__reset+0xfb113e3c>
81133e70:	da402517 	ldw	r9,148(sp)
81133e74:	e007883a 	mov	r3,fp
81133e78:	8039883a 	mov	fp,r16
81133e7c:	1821883a 	mov	r16,r3
81133e80:	d8c02417 	ldw	r3,144(sp)
81133e84:	1705883a 	add	r2,r2,fp
81133e88:	47000115 	stw	fp,4(r8)
81133e8c:	40c00015 	stw	r3,0(r8)
81133e90:	d8801c15 	stw	r2,112(sp)
81133e94:	d9801b15 	stw	r6,108(sp)
81133e98:	00c001c4 	movi	r3,7
81133e9c:	19827616 	blt	r3,r6,81134878 <___vfiprintf_internal_r+0xfc4>
81133ea0:	4cf9c83a 	sub	fp,r9,r19
81133ea4:	42000204 	addi	r8,r8,8
81133ea8:	31000044 	addi	r4,r6,1
81133eac:	300b883a 	mov	r5,r6
81133eb0:	07018516 	blt	zero,fp,811344c8 <___vfiprintf_internal_r+0xc14>
81133eb4:	9885883a 	add	r2,r19,r2
81133eb8:	45400015 	stw	r21,0(r8)
81133ebc:	44c00115 	stw	r19,4(r8)
81133ec0:	d8801c15 	stw	r2,112(sp)
81133ec4:	d9001b15 	stw	r4,108(sp)
81133ec8:	00c001c4 	movi	r3,7
81133ecc:	1901dd0e 	bge	r3,r4,81134644 <___vfiprintf_internal_r+0xd90>
81133ed0:	1002401e 	bne	r2,zero,811347d4 <___vfiprintf_internal_r+0xf20>
81133ed4:	d8001b15 	stw	zero,108(sp)
81133ed8:	a2c0010c 	andi	r11,r20,4
81133edc:	58000226 	beq	r11,zero,81133ee8 <___vfiprintf_internal_r+0x634>
81133ee0:	8ca7c83a 	sub	r19,r17,r18
81133ee4:	04c2f216 	blt	zero,r19,81134ab0 <___vfiprintf_internal_r+0x11fc>
81133ee8:	8c80010e 	bge	r17,r18,81133ef0 <___vfiprintf_internal_r+0x63c>
81133eec:	9023883a 	mov	r17,r18
81133ef0:	da802317 	ldw	r10,140(sp)
81133ef4:	5455883a 	add	r10,r10,r17
81133ef8:	da802315 	stw	r10,140(sp)
81133efc:	d8001b15 	stw	zero,108(sp)
81133f00:	d811883a 	mov	r8,sp
81133f04:	003ea206 	br	81133990 <__reset+0xfb113990>
81133f08:	a5000814 	ori	r20,r20,32
81133f0c:	80c00007 	ldb	r3,0(r16)
81133f10:	003ec906 	br	81133a38 <__reset+0xfb113a38>
81133f14:	80c00007 	ldb	r3,0(r16)
81133f18:	1b030926 	beq	r3,r12,81134b40 <___vfiprintf_internal_r+0x128c>
81133f1c:	a5000414 	ori	r20,r20,16
81133f20:	003ec506 	br	81133a38 <__reset+0xfb113a38>
81133f24:	21003fcc 	andi	r4,r4,255
81133f28:	20035e1e 	bne	r4,zero,81134ca4 <___vfiprintf_internal_r+0x13f0>
81133f2c:	a080080c 	andi	r2,r20,32
81133f30:	1002a526 	beq	r2,zero,811349c8 <___vfiprintf_internal_r+0x1114>
81133f34:	da802217 	ldw	r10,136(sp)
81133f38:	50800017 	ldw	r2,0(r10)
81133f3c:	da802317 	ldw	r10,140(sp)
81133f40:	5007d7fa 	srai	r3,r10,31
81133f44:	da802217 	ldw	r10,136(sp)
81133f48:	10c00115 	stw	r3,4(r2)
81133f4c:	52800104 	addi	r10,r10,4
81133f50:	da802215 	stw	r10,136(sp)
81133f54:	da802317 	ldw	r10,140(sp)
81133f58:	12800015 	stw	r10,0(r2)
81133f5c:	003e8c06 	br	81133990 <__reset+0xfb113990>
81133f60:	21003fcc 	andi	r4,r4,255
81133f64:	2003511e 	bne	r4,zero,81134cac <___vfiprintf_internal_r+0x13f8>
81133f68:	a080080c 	andi	r2,r20,32
81133f6c:	1000a126 	beq	r2,zero,811341f4 <___vfiprintf_internal_r+0x940>
81133f70:	da802217 	ldw	r10,136(sp)
81133f74:	d8001d85 	stb	zero,118(sp)
81133f78:	50800204 	addi	r2,r10,8
81133f7c:	54800017 	ldw	r18,0(r10)
81133f80:	54c00117 	ldw	r19,4(r10)
81133f84:	4802b416 	blt	r9,zero,81134a58 <___vfiprintf_internal_r+0x11a4>
81133f88:	013fdfc4 	movi	r4,-129
81133f8c:	94c6b03a 	or	r3,r18,r19
81133f90:	d8802215 	stw	r2,136(sp)
81133f94:	a128703a 	and	r20,r20,r4
81133f98:	1800a226 	beq	r3,zero,81134224 <___vfiprintf_internal_r+0x970>
81133f9c:	0039883a 	mov	fp,zero
81133fa0:	dd401a04 	addi	r21,sp,104
81133fa4:	9006d0fa 	srli	r3,r18,3
81133fa8:	9808977a 	slli	r4,r19,29
81133fac:	9826d0fa 	srli	r19,r19,3
81133fb0:	948001cc 	andi	r18,r18,7
81133fb4:	90800c04 	addi	r2,r18,48
81133fb8:	ad7fffc4 	addi	r21,r21,-1
81133fbc:	20e4b03a 	or	r18,r4,r3
81133fc0:	a8800005 	stb	r2,0(r21)
81133fc4:	94c6b03a 	or	r3,r18,r19
81133fc8:	183ff61e 	bne	r3,zero,81133fa4 <__reset+0xfb113fa4>
81133fcc:	a0c0004c 	andi	r3,r20,1
81133fd0:	18005926 	beq	r3,zero,81134138 <___vfiprintf_internal_r+0x884>
81133fd4:	10803fcc 	andi	r2,r2,255
81133fd8:	1080201c 	xori	r2,r2,128
81133fdc:	10bfe004 	addi	r2,r2,-128
81133fe0:	00c00c04 	movi	r3,48
81133fe4:	10c05426 	beq	r2,r3,81134138 <___vfiprintf_internal_r+0x884>
81133fe8:	da801e17 	ldw	r10,120(sp)
81133fec:	a8bfffc4 	addi	r2,r21,-1
81133ff0:	a8ffffc5 	stb	r3,-1(r21)
81133ff4:	50a7c83a 	sub	r19,r10,r2
81133ff8:	102b883a 	mov	r21,r2
81133ffc:	003f2f06 	br	81133cbc <__reset+0xfb113cbc>
81134000:	21003fcc 	andi	r4,r4,255
81134004:	2003421e 	bne	r4,zero,81134d10 <___vfiprintf_internal_r+0x145c>
81134008:	00a04574 	movhi	r2,33045
8113400c:	108a8d04 	addi	r2,r2,10804
81134010:	d8802615 	stw	r2,152(sp)
81134014:	a080080c 	andi	r2,r20,32
81134018:	1000aa26 	beq	r2,zero,811342c4 <___vfiprintf_internal_r+0xa10>
8113401c:	da802217 	ldw	r10,136(sp)
81134020:	54800017 	ldw	r18,0(r10)
81134024:	54c00117 	ldw	r19,4(r10)
81134028:	52800204 	addi	r10,r10,8
8113402c:	da802215 	stw	r10,136(sp)
81134030:	a080004c 	andi	r2,r20,1
81134034:	1001d226 	beq	r2,zero,81134780 <___vfiprintf_internal_r+0xecc>
81134038:	94c4b03a 	or	r2,r18,r19
8113403c:	1002351e 	bne	r2,zero,81134914 <___vfiprintf_internal_r+0x1060>
81134040:	d8001d85 	stb	zero,118(sp)
81134044:	48022216 	blt	r9,zero,811348d0 <___vfiprintf_internal_r+0x101c>
81134048:	00bfdfc4 	movi	r2,-129
8113404c:	a0a8703a 	and	r20,r20,r2
81134050:	003f1506 	br	81133ca8 <__reset+0xfb113ca8>
81134054:	da802217 	ldw	r10,136(sp)
81134058:	04800044 	movi	r18,1
8113405c:	d8001d85 	stb	zero,118(sp)
81134060:	50800017 	ldw	r2,0(r10)
81134064:	52800104 	addi	r10,r10,4
81134068:	da802215 	stw	r10,136(sp)
8113406c:	d8801005 	stb	r2,64(sp)
81134070:	9027883a 	mov	r19,r18
81134074:	dd401004 	addi	r21,sp,64
81134078:	0013883a 	mov	r9,zero
8113407c:	003f1706 	br	81133cdc <__reset+0xfb113cdc>
81134080:	21003fcc 	andi	r4,r4,255
81134084:	2003201e 	bne	r4,zero,81134d08 <___vfiprintf_internal_r+0x1454>
81134088:	a080080c 	andi	r2,r20,32
8113408c:	10004b26 	beq	r2,zero,811341bc <___vfiprintf_internal_r+0x908>
81134090:	da802217 	ldw	r10,136(sp)
81134094:	50800117 	ldw	r2,4(r10)
81134098:	54800017 	ldw	r18,0(r10)
8113409c:	52800204 	addi	r10,r10,8
811340a0:	da802215 	stw	r10,136(sp)
811340a4:	1027883a 	mov	r19,r2
811340a8:	10022c16 	blt	r2,zero,8113495c <___vfiprintf_internal_r+0x10a8>
811340ac:	df001d83 	ldbu	fp,118(sp)
811340b0:	48007216 	blt	r9,zero,8113427c <___vfiprintf_internal_r+0x9c8>
811340b4:	00ffdfc4 	movi	r3,-129
811340b8:	94c4b03a 	or	r2,r18,r19
811340bc:	a0e8703a 	and	r20,r20,r3
811340c0:	1000cc26 	beq	r2,zero,811343f4 <___vfiprintf_internal_r+0xb40>
811340c4:	98021026 	beq	r19,zero,81134908 <___vfiprintf_internal_r+0x1054>
811340c8:	dc402415 	stw	r17,144(sp)
811340cc:	dc002515 	stw	r16,148(sp)
811340d0:	9823883a 	mov	r17,r19
811340d4:	9021883a 	mov	r16,r18
811340d8:	dd401a04 	addi	r21,sp,104
811340dc:	4825883a 	mov	r18,r9
811340e0:	4027883a 	mov	r19,r8
811340e4:	8009883a 	mov	r4,r16
811340e8:	880b883a 	mov	r5,r17
811340ec:	01800284 	movi	r6,10
811340f0:	000f883a 	mov	r7,zero
811340f4:	11365d40 	call	811365d4 <__umoddi3>
811340f8:	10800c04 	addi	r2,r2,48
811340fc:	ad7fffc4 	addi	r21,r21,-1
81134100:	8009883a 	mov	r4,r16
81134104:	880b883a 	mov	r5,r17
81134108:	a8800005 	stb	r2,0(r21)
8113410c:	01800284 	movi	r6,10
81134110:	000f883a 	mov	r7,zero
81134114:	11360540 	call	81136054 <__udivdi3>
81134118:	1021883a 	mov	r16,r2
8113411c:	10c4b03a 	or	r2,r2,r3
81134120:	1823883a 	mov	r17,r3
81134124:	103fef1e 	bne	r2,zero,811340e4 <__reset+0xfb1140e4>
81134128:	dc402417 	ldw	r17,144(sp)
8113412c:	dc002517 	ldw	r16,148(sp)
81134130:	9013883a 	mov	r9,r18
81134134:	9811883a 	mov	r8,r19
81134138:	da801e17 	ldw	r10,120(sp)
8113413c:	5567c83a 	sub	r19,r10,r21
81134140:	003ede06 	br	81133cbc <__reset+0xfb113cbc>
81134144:	38803fcc 	andi	r2,r7,255
81134148:	1080201c 	xori	r2,r2,128
8113414c:	10bfe004 	addi	r2,r2,-128
81134150:	1002371e 	bne	r2,zero,81134a30 <___vfiprintf_internal_r+0x117c>
81134154:	01000044 	movi	r4,1
81134158:	01c00804 	movi	r7,32
8113415c:	80c00007 	ldb	r3,0(r16)
81134160:	003e3506 	br	81133a38 <__reset+0xfb113a38>
81134164:	a5000054 	ori	r20,r20,1
81134168:	80c00007 	ldb	r3,0(r16)
8113416c:	003e3206 	br	81133a38 <__reset+0xfb113a38>
81134170:	a5002014 	ori	r20,r20,128
81134174:	80c00007 	ldb	r3,0(r16)
81134178:	003e2f06 	br	81133a38 <__reset+0xfb113a38>
8113417c:	8015883a 	mov	r10,r16
81134180:	0023883a 	mov	r17,zero
81134184:	18bff404 	addi	r2,r3,-48
81134188:	50c00007 	ldb	r3,0(r10)
8113418c:	8c4002a4 	muli	r17,r17,10
81134190:	84000044 	addi	r16,r16,1
81134194:	8015883a 	mov	r10,r16
81134198:	1463883a 	add	r17,r2,r17
8113419c:	18bff404 	addi	r2,r3,-48
811341a0:	30bff92e 	bgeu	r6,r2,81134188 <__reset+0xfb114188>
811341a4:	003e2506 	br	81133a3c <__reset+0xfb113a3c>
811341a8:	21003fcc 	andi	r4,r4,255
811341ac:	2002d41e 	bne	r4,zero,81134d00 <___vfiprintf_internal_r+0x144c>
811341b0:	a5000414 	ori	r20,r20,16
811341b4:	a080080c 	andi	r2,r20,32
811341b8:	103fb51e 	bne	r2,zero,81134090 <__reset+0xfb114090>
811341bc:	a080040c 	andi	r2,r20,16
811341c0:	1001f826 	beq	r2,zero,811349a4 <___vfiprintf_internal_r+0x10f0>
811341c4:	da802217 	ldw	r10,136(sp)
811341c8:	54800017 	ldw	r18,0(r10)
811341cc:	52800104 	addi	r10,r10,4
811341d0:	da802215 	stw	r10,136(sp)
811341d4:	9027d7fa 	srai	r19,r18,31
811341d8:	9805883a 	mov	r2,r19
811341dc:	003fb206 	br	811340a8 <__reset+0xfb1140a8>
811341e0:	21003fcc 	andi	r4,r4,255
811341e4:	2002c41e 	bne	r4,zero,81134cf8 <___vfiprintf_internal_r+0x1444>
811341e8:	a5000414 	ori	r20,r20,16
811341ec:	a080080c 	andi	r2,r20,32
811341f0:	103f5f1e 	bne	r2,zero,81133f70 <__reset+0xfb113f70>
811341f4:	a080040c 	andi	r2,r20,16
811341f8:	10020f26 	beq	r2,zero,81134a38 <___vfiprintf_internal_r+0x1184>
811341fc:	da802217 	ldw	r10,136(sp)
81134200:	d8001d85 	stb	zero,118(sp)
81134204:	0027883a 	mov	r19,zero
81134208:	50800104 	addi	r2,r10,4
8113420c:	54800017 	ldw	r18,0(r10)
81134210:	48021116 	blt	r9,zero,81134a58 <___vfiprintf_internal_r+0x11a4>
81134214:	00ffdfc4 	movi	r3,-129
81134218:	d8802215 	stw	r2,136(sp)
8113421c:	a0e8703a 	and	r20,r20,r3
81134220:	903f5e1e 	bne	r18,zero,81133f9c <__reset+0xfb113f9c>
81134224:	0039883a 	mov	fp,zero
81134228:	4802a626 	beq	r9,zero,81134cc4 <___vfiprintf_internal_r+0x1410>
8113422c:	0025883a 	mov	r18,zero
81134230:	0027883a 	mov	r19,zero
81134234:	003f5a06 	br	81133fa0 <__reset+0xfb113fa0>
81134238:	21003fcc 	andi	r4,r4,255
8113423c:	20029f1e 	bne	r4,zero,81134cbc <___vfiprintf_internal_r+0x1408>
81134240:	a5000414 	ori	r20,r20,16
81134244:	a080080c 	andi	r2,r20,32
81134248:	10005e1e 	bne	r2,zero,811343c4 <___vfiprintf_internal_r+0xb10>
8113424c:	a080040c 	andi	r2,r20,16
81134250:	1001a21e 	bne	r2,zero,811348dc <___vfiprintf_internal_r+0x1028>
81134254:	a080100c 	andi	r2,r20,64
81134258:	d8001d85 	stb	zero,118(sp)
8113425c:	da802217 	ldw	r10,136(sp)
81134260:	1002231e 	bne	r2,zero,81134af0 <___vfiprintf_internal_r+0x123c>
81134264:	50800104 	addi	r2,r10,4
81134268:	54800017 	ldw	r18,0(r10)
8113426c:	0027883a 	mov	r19,zero
81134270:	4801a00e 	bge	r9,zero,811348f4 <___vfiprintf_internal_r+0x1040>
81134274:	d8802215 	stw	r2,136(sp)
81134278:	0039883a 	mov	fp,zero
8113427c:	94c4b03a 	or	r2,r18,r19
81134280:	103f901e 	bne	r2,zero,811340c4 <__reset+0xfb1140c4>
81134284:	00800044 	movi	r2,1
81134288:	10803fcc 	andi	r2,r2,255
8113428c:	00c00044 	movi	r3,1
81134290:	10c05926 	beq	r2,r3,811343f8 <___vfiprintf_internal_r+0xb44>
81134294:	00c00084 	movi	r3,2
81134298:	10ffe41e 	bne	r2,r3,8113422c <__reset+0xfb11422c>
8113429c:	0025883a 	mov	r18,zero
811342a0:	0027883a 	mov	r19,zero
811342a4:	00013d06 	br	8113479c <___vfiprintf_internal_r+0xee8>
811342a8:	21003fcc 	andi	r4,r4,255
811342ac:	2002811e 	bne	r4,zero,81134cb4 <___vfiprintf_internal_r+0x1400>
811342b0:	00a04574 	movhi	r2,33045
811342b4:	108a8804 	addi	r2,r2,10784
811342b8:	d8802615 	stw	r2,152(sp)
811342bc:	a080080c 	andi	r2,r20,32
811342c0:	103f561e 	bne	r2,zero,8113401c <__reset+0xfb11401c>
811342c4:	a080040c 	andi	r2,r20,16
811342c8:	1001d126 	beq	r2,zero,81134a10 <___vfiprintf_internal_r+0x115c>
811342cc:	da802217 	ldw	r10,136(sp)
811342d0:	0027883a 	mov	r19,zero
811342d4:	54800017 	ldw	r18,0(r10)
811342d8:	52800104 	addi	r10,r10,4
811342dc:	da802215 	stw	r10,136(sp)
811342e0:	003f5306 	br	81134030 <__reset+0xfb114030>
811342e4:	da802217 	ldw	r10,136(sp)
811342e8:	d8001d85 	stb	zero,118(sp)
811342ec:	55400017 	ldw	r21,0(r10)
811342f0:	50c00104 	addi	r3,r10,4
811342f4:	a8024226 	beq	r21,zero,81134c00 <___vfiprintf_internal_r+0x134c>
811342f8:	48021816 	blt	r9,zero,81134b5c <___vfiprintf_internal_r+0x12a8>
811342fc:	480d883a 	mov	r6,r9
81134300:	000b883a 	mov	r5,zero
81134304:	a809883a 	mov	r4,r21
81134308:	d8c02a15 	stw	r3,168(sp)
8113430c:	da002b15 	stw	r8,172(sp)
81134310:	da402c15 	stw	r9,176(sp)
81134314:	112e9780 	call	8112e978 <memchr>
81134318:	d8c02a17 	ldw	r3,168(sp)
8113431c:	da002b17 	ldw	r8,172(sp)
81134320:	da402c17 	ldw	r9,176(sp)
81134324:	10024826 	beq	r2,zero,81134c48 <___vfiprintf_internal_r+0x1394>
81134328:	1567c83a 	sub	r19,r2,r21
8113432c:	df001d83 	ldbu	fp,118(sp)
81134330:	d8c02215 	stw	r3,136(sp)
81134334:	0013883a 	mov	r9,zero
81134338:	003e6006 	br	81133cbc <__reset+0xfb113cbc>
8113433c:	21003fcc 	andi	r4,r4,255
81134340:	203fc026 	beq	r4,zero,81134244 <__reset+0xfb114244>
81134344:	d9c01d85 	stb	r7,118(sp)
81134348:	003fbe06 	br	81134244 <__reset+0xfb114244>
8113434c:	da802217 	ldw	r10,136(sp)
81134350:	54400017 	ldw	r17,0(r10)
81134354:	50800104 	addi	r2,r10,4
81134358:	883e3b16 	blt	r17,zero,81133c48 <__reset+0xfb113c48>
8113435c:	d8802215 	stw	r2,136(sp)
81134360:	80c00007 	ldb	r3,0(r16)
81134364:	003db406 	br	81133a38 <__reset+0xfb113a38>
81134368:	01000044 	movi	r4,1
8113436c:	01c00ac4 	movi	r7,43
81134370:	80c00007 	ldb	r3,0(r16)
81134374:	003db006 	br	81133a38 <__reset+0xfb113a38>
81134378:	80c00007 	ldb	r3,0(r16)
8113437c:	82800044 	addi	r10,r16,1
81134380:	1b423c26 	beq	r3,r13,81134c74 <___vfiprintf_internal_r+0x13c0>
81134384:	18bff404 	addi	r2,r3,-48
81134388:	0013883a 	mov	r9,zero
8113438c:	30822b36 	bltu	r6,r2,81134c3c <___vfiprintf_internal_r+0x1388>
81134390:	50c00007 	ldb	r3,0(r10)
81134394:	4a4002a4 	muli	r9,r9,10
81134398:	54000044 	addi	r16,r10,1
8113439c:	8015883a 	mov	r10,r16
811343a0:	4893883a 	add	r9,r9,r2
811343a4:	18bff404 	addi	r2,r3,-48
811343a8:	30bff92e 	bgeu	r6,r2,81134390 <__reset+0xfb114390>
811343ac:	483da30e 	bge	r9,zero,81133a3c <__reset+0xfb113a3c>
811343b0:	027fffc4 	movi	r9,-1
811343b4:	003da106 	br	81133a3c <__reset+0xfb113a3c>
811343b8:	a5001014 	ori	r20,r20,64
811343bc:	80c00007 	ldb	r3,0(r16)
811343c0:	003d9d06 	br	81133a38 <__reset+0xfb113a38>
811343c4:	da802217 	ldw	r10,136(sp)
811343c8:	d8001d85 	stb	zero,118(sp)
811343cc:	50c00204 	addi	r3,r10,8
811343d0:	54800017 	ldw	r18,0(r10)
811343d4:	54c00117 	ldw	r19,4(r10)
811343d8:	4801ca16 	blt	r9,zero,81134b04 <___vfiprintf_internal_r+0x1250>
811343dc:	013fdfc4 	movi	r4,-129
811343e0:	94c4b03a 	or	r2,r18,r19
811343e4:	d8c02215 	stw	r3,136(sp)
811343e8:	a128703a 	and	r20,r20,r4
811343ec:	0039883a 	mov	fp,zero
811343f0:	103f341e 	bne	r2,zero,811340c4 <__reset+0xfb1140c4>
811343f4:	483e2e26 	beq	r9,zero,81133cb0 <__reset+0xfb113cb0>
811343f8:	0025883a 	mov	r18,zero
811343fc:	94800c04 	addi	r18,r18,48
81134400:	dc8019c5 	stb	r18,103(sp)
81134404:	dcc02717 	ldw	r19,156(sp)
81134408:	dd4019c4 	addi	r21,sp,103
8113440c:	003e2b06 	br	81133cbc <__reset+0xfb113cbc>
81134410:	21003fcc 	andi	r4,r4,255
81134414:	2002361e 	bne	r4,zero,81134cf0 <___vfiprintf_internal_r+0x143c>
81134418:	1801c126 	beq	r3,zero,81134b20 <___vfiprintf_internal_r+0x126c>
8113441c:	04800044 	movi	r18,1
81134420:	d8c01005 	stb	r3,64(sp)
81134424:	d8001d85 	stb	zero,118(sp)
81134428:	9027883a 	mov	r19,r18
8113442c:	dd401004 	addi	r21,sp,64
81134430:	003f1106 	br	81134078 <__reset+0xfb114078>
81134434:	d9402117 	ldw	r5,132(sp)
81134438:	d9002017 	ldw	r4,128(sp)
8113443c:	d9801a04 	addi	r6,sp,104
81134440:	d9c02b15 	stw	r7,172(sp)
81134444:	dbc02a15 	stw	r15,168(sp)
81134448:	11337980 	call	81133798 <__sprint_r.part.0>
8113444c:	d9c02b17 	ldw	r7,172(sp)
81134450:	dbc02a17 	ldw	r15,168(sp)
81134454:	10006d1e 	bne	r2,zero,8113460c <___vfiprintf_internal_r+0xd58>
81134458:	d9801b17 	ldw	r6,108(sp)
8113445c:	d8801c17 	ldw	r2,112(sp)
81134460:	d811883a 	mov	r8,sp
81134464:	31400044 	addi	r5,r6,1
81134468:	003e3306 	br	81133d38 <__reset+0xfb113d38>
8113446c:	d9401b17 	ldw	r5,108(sp)
81134470:	d8801c17 	ldw	r2,112(sp)
81134474:	29000044 	addi	r4,r5,1
81134478:	d8c01d87 	ldb	r3,118(sp)
8113447c:	183e4d26 	beq	r3,zero,81133db4 <__reset+0xfb113db4>
81134480:	00c00044 	movi	r3,1
81134484:	d9401d84 	addi	r5,sp,118
81134488:	10c5883a 	add	r2,r2,r3
8113448c:	41400015 	stw	r5,0(r8)
81134490:	40c00115 	stw	r3,4(r8)
81134494:	d8801c15 	stw	r2,112(sp)
81134498:	d9001b15 	stw	r4,108(sp)
8113449c:	014001c4 	movi	r5,7
811344a0:	2900a90e 	bge	r5,r4,81134748 <___vfiprintf_internal_r+0xe94>
811344a4:	1000da1e 	bne	r2,zero,81134810 <___vfiprintf_internal_r+0xf5c>
811344a8:	7000ab1e 	bne	r14,zero,81134758 <___vfiprintf_internal_r+0xea4>
811344ac:	000b883a 	mov	r5,zero
811344b0:	1809883a 	mov	r4,r3
811344b4:	d811883a 	mov	r8,sp
811344b8:	00c02004 	movi	r3,128
811344bc:	e0fe4d26 	beq	fp,r3,81133df4 <__reset+0xfb113df4>
811344c0:	4cf9c83a 	sub	fp,r9,r19
811344c4:	073e7b0e 	bge	zero,fp,81133eb4 <__reset+0xfb113eb4>
811344c8:	01c00404 	movi	r7,16
811344cc:	3f01900e 	bge	r7,fp,81134b10 <___vfiprintf_internal_r+0x125c>
811344d0:	00e04574 	movhi	r3,33045
811344d4:	18cb1f04 	addi	r3,r3,11388
811344d8:	d8c02415 	stw	r3,144(sp)
811344dc:	034001c4 	movi	r13,7
811344e0:	00000506 	br	811344f8 <___vfiprintf_internal_r+0xc44>
811344e4:	29000084 	addi	r4,r5,2
811344e8:	42000204 	addi	r8,r8,8
811344ec:	180b883a 	mov	r5,r3
811344f0:	e73ffc04 	addi	fp,fp,-16
811344f4:	3f000d0e 	bge	r7,fp,8113452c <___vfiprintf_internal_r+0xc78>
811344f8:	10800404 	addi	r2,r2,16
811344fc:	28c00044 	addi	r3,r5,1
81134500:	45c00015 	stw	r23,0(r8)
81134504:	41c00115 	stw	r7,4(r8)
81134508:	d8801c15 	stw	r2,112(sp)
8113450c:	d8c01b15 	stw	r3,108(sp)
81134510:	68fff40e 	bge	r13,r3,811344e4 <__reset+0xfb1144e4>
81134514:	1000101e 	bne	r2,zero,81134558 <___vfiprintf_internal_r+0xca4>
81134518:	e73ffc04 	addi	fp,fp,-16
8113451c:	01000044 	movi	r4,1
81134520:	000b883a 	mov	r5,zero
81134524:	d811883a 	mov	r8,sp
81134528:	3f3ff316 	blt	r7,fp,811344f8 <__reset+0xfb1144f8>
8113452c:	da802417 	ldw	r10,144(sp)
81134530:	1705883a 	add	r2,r2,fp
81134534:	47000115 	stw	fp,4(r8)
81134538:	42800015 	stw	r10,0(r8)
8113453c:	d8801c15 	stw	r2,112(sp)
81134540:	d9001b15 	stw	r4,108(sp)
81134544:	00c001c4 	movi	r3,7
81134548:	19003616 	blt	r3,r4,81134624 <___vfiprintf_internal_r+0xd70>
8113454c:	42000204 	addi	r8,r8,8
81134550:	21000044 	addi	r4,r4,1
81134554:	003e5706 	br	81133eb4 <__reset+0xfb113eb4>
81134558:	d9402117 	ldw	r5,132(sp)
8113455c:	d9002017 	ldw	r4,128(sp)
81134560:	d9801a04 	addi	r6,sp,104
81134564:	d9c02b15 	stw	r7,172(sp)
81134568:	db402a15 	stw	r13,168(sp)
8113456c:	11337980 	call	81133798 <__sprint_r.part.0>
81134570:	d9c02b17 	ldw	r7,172(sp)
81134574:	db402a17 	ldw	r13,168(sp)
81134578:	1000241e 	bne	r2,zero,8113460c <___vfiprintf_internal_r+0xd58>
8113457c:	d9401b17 	ldw	r5,108(sp)
81134580:	d8801c17 	ldw	r2,112(sp)
81134584:	d811883a 	mov	r8,sp
81134588:	29000044 	addi	r4,r5,1
8113458c:	003fd806 	br	811344f0 <__reset+0xfb1144f0>
81134590:	d9401b17 	ldw	r5,108(sp)
81134594:	00e04574 	movhi	r3,33045
81134598:	18cb2304 	addi	r3,r3,11404
8113459c:	d8c02415 	stw	r3,144(sp)
811345a0:	29400044 	addi	r5,r5,1
811345a4:	d8c02417 	ldw	r3,144(sp)
811345a8:	14c5883a 	add	r2,r2,r19
811345ac:	44c00115 	stw	r19,4(r8)
811345b0:	40c00015 	stw	r3,0(r8)
811345b4:	d8801c15 	stw	r2,112(sp)
811345b8:	d9401b15 	stw	r5,108(sp)
811345bc:	00c001c4 	movi	r3,7
811345c0:	1940070e 	bge	r3,r5,811345e0 <___vfiprintf_internal_r+0xd2c>
811345c4:	103e4826 	beq	r2,zero,81133ee8 <__reset+0xfb113ee8>
811345c8:	d9402117 	ldw	r5,132(sp)
811345cc:	d9002017 	ldw	r4,128(sp)
811345d0:	d9801a04 	addi	r6,sp,104
811345d4:	11337980 	call	81133798 <__sprint_r.part.0>
811345d8:	10000c1e 	bne	r2,zero,8113460c <___vfiprintf_internal_r+0xd58>
811345dc:	d8801c17 	ldw	r2,112(sp)
811345e0:	8c80010e 	bge	r17,r18,811345e8 <___vfiprintf_internal_r+0xd34>
811345e4:	9023883a 	mov	r17,r18
811345e8:	da802317 	ldw	r10,140(sp)
811345ec:	5455883a 	add	r10,r10,r17
811345f0:	da802315 	stw	r10,140(sp)
811345f4:	103e4126 	beq	r2,zero,81133efc <__reset+0xfb113efc>
811345f8:	d9402117 	ldw	r5,132(sp)
811345fc:	d9002017 	ldw	r4,128(sp)
81134600:	d9801a04 	addi	r6,sp,104
81134604:	11337980 	call	81133798 <__sprint_r.part.0>
81134608:	103e3c26 	beq	r2,zero,81133efc <__reset+0xfb113efc>
8113460c:	dd002117 	ldw	r20,132(sp)
81134610:	a080030b 	ldhu	r2,12(r20)
81134614:	1080100c 	andi	r2,r2,64
81134618:	1001231e 	bne	r2,zero,81134aa8 <___vfiprintf_internal_r+0x11f4>
8113461c:	d8802317 	ldw	r2,140(sp)
81134620:	003d7b06 	br	81133c10 <__reset+0xfb113c10>
81134624:	1000991e 	bne	r2,zero,8113488c <___vfiprintf_internal_r+0xfd8>
81134628:	00c00044 	movi	r3,1
8113462c:	9805883a 	mov	r2,r19
81134630:	dd400015 	stw	r21,0(sp)
81134634:	dcc00115 	stw	r19,4(sp)
81134638:	dcc01c15 	stw	r19,112(sp)
8113463c:	d8c01b15 	stw	r3,108(sp)
81134640:	d811883a 	mov	r8,sp
81134644:	42000204 	addi	r8,r8,8
81134648:	a2c0010c 	andi	r11,r20,4
8113464c:	583fe426 	beq	r11,zero,811345e0 <__reset+0xfb1145e0>
81134650:	8ca7c83a 	sub	r19,r17,r18
81134654:	04ffe20e 	bge	zero,r19,811345e0 <__reset+0xfb1145e0>
81134658:	01c00404 	movi	r7,16
8113465c:	3cffcc0e 	bge	r7,r19,81134590 <__reset+0xfb114590>
81134660:	02a04574 	movhi	r10,33045
81134664:	528b2304 	addi	r10,r10,11404
81134668:	d9001b17 	ldw	r4,108(sp)
8113466c:	da802415 	stw	r10,144(sp)
81134670:	382b883a 	mov	r21,r7
81134674:	050001c4 	movi	r20,7
81134678:	df002017 	ldw	fp,128(sp)
8113467c:	00000506 	br	81134694 <___vfiprintf_internal_r+0xde0>
81134680:	21400084 	addi	r5,r4,2
81134684:	42000204 	addi	r8,r8,8
81134688:	1809883a 	mov	r4,r3
8113468c:	9cfffc04 	addi	r19,r19,-16
81134690:	acffc40e 	bge	r21,r19,811345a4 <__reset+0xfb1145a4>
81134694:	10800404 	addi	r2,r2,16
81134698:	20c00044 	addi	r3,r4,1
8113469c:	45800015 	stw	r22,0(r8)
811346a0:	45400115 	stw	r21,4(r8)
811346a4:	d8801c15 	stw	r2,112(sp)
811346a8:	d8c01b15 	stw	r3,108(sp)
811346ac:	a0fff40e 	bge	r20,r3,81134680 <__reset+0xfb114680>
811346b0:	1000041e 	bne	r2,zero,811346c4 <___vfiprintf_internal_r+0xe10>
811346b4:	01400044 	movi	r5,1
811346b8:	0009883a 	mov	r4,zero
811346bc:	d811883a 	mov	r8,sp
811346c0:	003ff206 	br	8113468c <__reset+0xfb11468c>
811346c4:	d9402117 	ldw	r5,132(sp)
811346c8:	d9801a04 	addi	r6,sp,104
811346cc:	e009883a 	mov	r4,fp
811346d0:	11337980 	call	81133798 <__sprint_r.part.0>
811346d4:	103fcd1e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
811346d8:	d9001b17 	ldw	r4,108(sp)
811346dc:	d8801c17 	ldw	r2,112(sp)
811346e0:	d811883a 	mov	r8,sp
811346e4:	21400044 	addi	r5,r4,1
811346e8:	003fe806 	br	8113468c <__reset+0xfb11468c>
811346ec:	d9402117 	ldw	r5,132(sp)
811346f0:	d9002017 	ldw	r4,128(sp)
811346f4:	d9801a04 	addi	r6,sp,104
811346f8:	d9c02b15 	stw	r7,172(sp)
811346fc:	db402a15 	stw	r13,168(sp)
81134700:	11337980 	call	81133798 <__sprint_r.part.0>
81134704:	d9c02b17 	ldw	r7,172(sp)
81134708:	db402a17 	ldw	r13,168(sp)
8113470c:	103fbf1e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
81134710:	d9401b17 	ldw	r5,108(sp)
81134714:	d8801c17 	ldw	r2,112(sp)
81134718:	d811883a 	mov	r8,sp
8113471c:	29800044 	addi	r6,r5,1
81134720:	003dc406 	br	81133e34 <__reset+0xfb113e34>
81134724:	1000d21e 	bne	r2,zero,81134a70 <___vfiprintf_internal_r+0x11bc>
81134728:	d8c01d87 	ldb	r3,118(sp)
8113472c:	18009526 	beq	r3,zero,81134984 <___vfiprintf_internal_r+0x10d0>
81134730:	00800044 	movi	r2,1
81134734:	d8c01d84 	addi	r3,sp,118
81134738:	1009883a 	mov	r4,r2
8113473c:	d8c00015 	stw	r3,0(sp)
81134740:	d8800115 	stw	r2,4(sp)
81134744:	d811883a 	mov	r8,sp
81134748:	200b883a 	mov	r5,r4
8113474c:	42000204 	addi	r8,r8,8
81134750:	21000044 	addi	r4,r4,1
81134754:	003d9706 	br	81133db4 <__reset+0xfb113db4>
81134758:	d9001d04 	addi	r4,sp,116
8113475c:	00800084 	movi	r2,2
81134760:	d9000015 	stw	r4,0(sp)
81134764:	d8800115 	stw	r2,4(sp)
81134768:	1809883a 	mov	r4,r3
8113476c:	d811883a 	mov	r8,sp
81134770:	200b883a 	mov	r5,r4
81134774:	42000204 	addi	r8,r8,8
81134778:	21000044 	addi	r4,r4,1
8113477c:	003f4e06 	br	811344b8 <__reset+0xfb1144b8>
81134780:	d8001d85 	stb	zero,118(sp)
81134784:	48005016 	blt	r9,zero,811348c8 <___vfiprintf_internal_r+0x1014>
81134788:	00ffdfc4 	movi	r3,-129
8113478c:	94c4b03a 	or	r2,r18,r19
81134790:	a0e8703a 	and	r20,r20,r3
81134794:	103d4426 	beq	r2,zero,81133ca8 <__reset+0xfb113ca8>
81134798:	0039883a 	mov	fp,zero
8113479c:	d9002617 	ldw	r4,152(sp)
811347a0:	dd401a04 	addi	r21,sp,104
811347a4:	908003cc 	andi	r2,r18,15
811347a8:	9806973a 	slli	r3,r19,28
811347ac:	2085883a 	add	r2,r4,r2
811347b0:	9024d13a 	srli	r18,r18,4
811347b4:	10800003 	ldbu	r2,0(r2)
811347b8:	9826d13a 	srli	r19,r19,4
811347bc:	ad7fffc4 	addi	r21,r21,-1
811347c0:	1ca4b03a 	or	r18,r3,r18
811347c4:	a8800005 	stb	r2,0(r21)
811347c8:	94c4b03a 	or	r2,r18,r19
811347cc:	103ff51e 	bne	r2,zero,811347a4 <__reset+0xfb1147a4>
811347d0:	003e5906 	br	81134138 <__reset+0xfb114138>
811347d4:	d9402117 	ldw	r5,132(sp)
811347d8:	d9002017 	ldw	r4,128(sp)
811347dc:	d9801a04 	addi	r6,sp,104
811347e0:	11337980 	call	81133798 <__sprint_r.part.0>
811347e4:	103f891e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
811347e8:	d8801c17 	ldw	r2,112(sp)
811347ec:	d811883a 	mov	r8,sp
811347f0:	003f9506 	br	81134648 <__reset+0xfb114648>
811347f4:	d9402117 	ldw	r5,132(sp)
811347f8:	d9002017 	ldw	r4,128(sp)
811347fc:	d9801a04 	addi	r6,sp,104
81134800:	11337980 	call	81133798 <__sprint_r.part.0>
81134804:	103f811e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
81134808:	d811883a 	mov	r8,sp
8113480c:	003ced06 	br	81133bc4 <__reset+0xfb113bc4>
81134810:	d9402117 	ldw	r5,132(sp)
81134814:	d9002017 	ldw	r4,128(sp)
81134818:	d9801a04 	addi	r6,sp,104
8113481c:	da402c15 	stw	r9,176(sp)
81134820:	db802a15 	stw	r14,168(sp)
81134824:	11337980 	call	81133798 <__sprint_r.part.0>
81134828:	da402c17 	ldw	r9,176(sp)
8113482c:	db802a17 	ldw	r14,168(sp)
81134830:	103f761e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
81134834:	d9401b17 	ldw	r5,108(sp)
81134838:	d8801c17 	ldw	r2,112(sp)
8113483c:	d811883a 	mov	r8,sp
81134840:	29000044 	addi	r4,r5,1
81134844:	003d5b06 	br	81133db4 <__reset+0xfb113db4>
81134848:	d9402117 	ldw	r5,132(sp)
8113484c:	d9002017 	ldw	r4,128(sp)
81134850:	d9801a04 	addi	r6,sp,104
81134854:	da402c15 	stw	r9,176(sp)
81134858:	11337980 	call	81133798 <__sprint_r.part.0>
8113485c:	da402c17 	ldw	r9,176(sp)
81134860:	103f6a1e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
81134864:	d9401b17 	ldw	r5,108(sp)
81134868:	d8801c17 	ldw	r2,112(sp)
8113486c:	d811883a 	mov	r8,sp
81134870:	29000044 	addi	r4,r5,1
81134874:	003f1006 	br	811344b8 <__reset+0xfb1144b8>
81134878:	1000c31e 	bne	r2,zero,81134b88 <___vfiprintf_internal_r+0x12d4>
8113487c:	01000044 	movi	r4,1
81134880:	000b883a 	mov	r5,zero
81134884:	d811883a 	mov	r8,sp
81134888:	003f0d06 	br	811344c0 <__reset+0xfb1144c0>
8113488c:	d9402117 	ldw	r5,132(sp)
81134890:	d9002017 	ldw	r4,128(sp)
81134894:	d9801a04 	addi	r6,sp,104
81134898:	11337980 	call	81133798 <__sprint_r.part.0>
8113489c:	103f5b1e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
811348a0:	d9001b17 	ldw	r4,108(sp)
811348a4:	d8801c17 	ldw	r2,112(sp)
811348a8:	d811883a 	mov	r8,sp
811348ac:	21000044 	addi	r4,r4,1
811348b0:	003d8006 	br	81133eb4 <__reset+0xfb113eb4>
811348b4:	01204574 	movhi	r4,33045
811348b8:	210a8d04 	addi	r4,r4,10804
811348bc:	d9002615 	stw	r4,152(sp)
811348c0:	d8c02215 	stw	r3,136(sp)
811348c4:	1029883a 	mov	r20,r2
811348c8:	94c4b03a 	or	r2,r18,r19
811348cc:	103fb21e 	bne	r2,zero,81134798 <__reset+0xfb114798>
811348d0:	0039883a 	mov	fp,zero
811348d4:	00800084 	movi	r2,2
811348d8:	003e6b06 	br	81134288 <__reset+0xfb114288>
811348dc:	da802217 	ldw	r10,136(sp)
811348e0:	d8001d85 	stb	zero,118(sp)
811348e4:	0027883a 	mov	r19,zero
811348e8:	50800104 	addi	r2,r10,4
811348ec:	54800017 	ldw	r18,0(r10)
811348f0:	483e6016 	blt	r9,zero,81134274 <__reset+0xfb114274>
811348f4:	00ffdfc4 	movi	r3,-129
811348f8:	d8802215 	stw	r2,136(sp)
811348fc:	a0e8703a 	and	r20,r20,r3
81134900:	0039883a 	mov	fp,zero
81134904:	903ebb26 	beq	r18,zero,811343f4 <__reset+0xfb1143f4>
81134908:	00800244 	movi	r2,9
8113490c:	14bdee36 	bltu	r2,r18,811340c8 <__reset+0xfb1140c8>
81134910:	003eba06 	br	811343fc <__reset+0xfb1143fc>
81134914:	00800c04 	movi	r2,48
81134918:	d8c01d45 	stb	r3,117(sp)
8113491c:	d8801d05 	stb	r2,116(sp)
81134920:	d8001d85 	stb	zero,118(sp)
81134924:	a0c00094 	ori	r3,r20,2
81134928:	4800a916 	blt	r9,zero,81134bd0 <___vfiprintf_internal_r+0x131c>
8113492c:	00bfdfc4 	movi	r2,-129
81134930:	a096703a 	and	r11,r20,r2
81134934:	5d000094 	ori	r20,r11,2
81134938:	0039883a 	mov	fp,zero
8113493c:	003f9706 	br	8113479c <__reset+0xfb11479c>
81134940:	8025883a 	mov	r18,r16
81134944:	003c2e06 	br	81133a00 <__reset+0xfb113a00>
81134948:	00a04574 	movhi	r2,33045
8113494c:	108a8d04 	addi	r2,r2,10804
81134950:	0039883a 	mov	fp,zero
81134954:	d8802615 	stw	r2,152(sp)
81134958:	003f9006 	br	8113479c <__reset+0xfb11479c>
8113495c:	04a5c83a 	sub	r18,zero,r18
81134960:	07000b44 	movi	fp,45
81134964:	9004c03a 	cmpne	r2,r18,zero
81134968:	04e7c83a 	sub	r19,zero,r19
8113496c:	df001d85 	stb	fp,118(sp)
81134970:	98a7c83a 	sub	r19,r19,r2
81134974:	48009f16 	blt	r9,zero,81134bf4 <___vfiprintf_internal_r+0x1340>
81134978:	00bfdfc4 	movi	r2,-129
8113497c:	a0a8703a 	and	r20,r20,r2
81134980:	003dd006 	br	811340c4 <__reset+0xfb1140c4>
81134984:	70004c26 	beq	r14,zero,81134ab8 <___vfiprintf_internal_r+0x1204>
81134988:	00800084 	movi	r2,2
8113498c:	d8c01d04 	addi	r3,sp,116
81134990:	d8c00015 	stw	r3,0(sp)
81134994:	d8800115 	stw	r2,4(sp)
81134998:	01000044 	movi	r4,1
8113499c:	d811883a 	mov	r8,sp
811349a0:	003f7306 	br	81134770 <__reset+0xfb114770>
811349a4:	a080100c 	andi	r2,r20,64
811349a8:	da802217 	ldw	r10,136(sp)
811349ac:	103e0626 	beq	r2,zero,811341c8 <__reset+0xfb1141c8>
811349b0:	5480000f 	ldh	r18,0(r10)
811349b4:	52800104 	addi	r10,r10,4
811349b8:	da802215 	stw	r10,136(sp)
811349bc:	9027d7fa 	srai	r19,r18,31
811349c0:	9805883a 	mov	r2,r19
811349c4:	003db806 	br	811340a8 <__reset+0xfb1140a8>
811349c8:	a080040c 	andi	r2,r20,16
811349cc:	1000091e 	bne	r2,zero,811349f4 <___vfiprintf_internal_r+0x1140>
811349d0:	a2c0100c 	andi	r11,r20,64
811349d4:	58000726 	beq	r11,zero,811349f4 <___vfiprintf_internal_r+0x1140>
811349d8:	da802217 	ldw	r10,136(sp)
811349dc:	50800017 	ldw	r2,0(r10)
811349e0:	52800104 	addi	r10,r10,4
811349e4:	da802215 	stw	r10,136(sp)
811349e8:	da802317 	ldw	r10,140(sp)
811349ec:	1280000d 	sth	r10,0(r2)
811349f0:	003be706 	br	81133990 <__reset+0xfb113990>
811349f4:	da802217 	ldw	r10,136(sp)
811349f8:	50800017 	ldw	r2,0(r10)
811349fc:	52800104 	addi	r10,r10,4
81134a00:	da802215 	stw	r10,136(sp)
81134a04:	da802317 	ldw	r10,140(sp)
81134a08:	12800015 	stw	r10,0(r2)
81134a0c:	003be006 	br	81133990 <__reset+0xfb113990>
81134a10:	a080100c 	andi	r2,r20,64
81134a14:	da802217 	ldw	r10,136(sp)
81134a18:	10003026 	beq	r2,zero,81134adc <___vfiprintf_internal_r+0x1228>
81134a1c:	5480000b 	ldhu	r18,0(r10)
81134a20:	52800104 	addi	r10,r10,4
81134a24:	0027883a 	mov	r19,zero
81134a28:	da802215 	stw	r10,136(sp)
81134a2c:	003d8006 	br	81134030 <__reset+0xfb114030>
81134a30:	80c00007 	ldb	r3,0(r16)
81134a34:	003c0006 	br	81133a38 <__reset+0xfb113a38>
81134a38:	a080100c 	andi	r2,r20,64
81134a3c:	d8001d85 	stb	zero,118(sp)
81134a40:	da802217 	ldw	r10,136(sp)
81134a44:	1000201e 	bne	r2,zero,81134ac8 <___vfiprintf_internal_r+0x1214>
81134a48:	50800104 	addi	r2,r10,4
81134a4c:	54800017 	ldw	r18,0(r10)
81134a50:	0027883a 	mov	r19,zero
81134a54:	483def0e 	bge	r9,zero,81134214 <__reset+0xfb114214>
81134a58:	94c6b03a 	or	r3,r18,r19
81134a5c:	d8802215 	stw	r2,136(sp)
81134a60:	183d4e1e 	bne	r3,zero,81133f9c <__reset+0xfb113f9c>
81134a64:	0039883a 	mov	fp,zero
81134a68:	0005883a 	mov	r2,zero
81134a6c:	003e0606 	br	81134288 <__reset+0xfb114288>
81134a70:	d9402117 	ldw	r5,132(sp)
81134a74:	d9002017 	ldw	r4,128(sp)
81134a78:	d9801a04 	addi	r6,sp,104
81134a7c:	da402c15 	stw	r9,176(sp)
81134a80:	db802a15 	stw	r14,168(sp)
81134a84:	11337980 	call	81133798 <__sprint_r.part.0>
81134a88:	da402c17 	ldw	r9,176(sp)
81134a8c:	db802a17 	ldw	r14,168(sp)
81134a90:	103ede1e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
81134a94:	d9401b17 	ldw	r5,108(sp)
81134a98:	d8801c17 	ldw	r2,112(sp)
81134a9c:	d811883a 	mov	r8,sp
81134aa0:	29000044 	addi	r4,r5,1
81134aa4:	003e7406 	br	81134478 <__reset+0xfb114478>
81134aa8:	00bfffc4 	movi	r2,-1
81134aac:	003c5806 	br	81133c10 <__reset+0xfb113c10>
81134ab0:	d811883a 	mov	r8,sp
81134ab4:	003ee806 	br	81134658 <__reset+0xfb114658>
81134ab8:	000b883a 	mov	r5,zero
81134abc:	01000044 	movi	r4,1
81134ac0:	d811883a 	mov	r8,sp
81134ac4:	003e7c06 	br	811344b8 <__reset+0xfb1144b8>
81134ac8:	50800104 	addi	r2,r10,4
81134acc:	5480000b 	ldhu	r18,0(r10)
81134ad0:	0027883a 	mov	r19,zero
81134ad4:	483dcf0e 	bge	r9,zero,81134214 <__reset+0xfb114214>
81134ad8:	003fdf06 	br	81134a58 <__reset+0xfb114a58>
81134adc:	54800017 	ldw	r18,0(r10)
81134ae0:	52800104 	addi	r10,r10,4
81134ae4:	0027883a 	mov	r19,zero
81134ae8:	da802215 	stw	r10,136(sp)
81134aec:	003d5006 	br	81134030 <__reset+0xfb114030>
81134af0:	50800104 	addi	r2,r10,4
81134af4:	5480000b 	ldhu	r18,0(r10)
81134af8:	0027883a 	mov	r19,zero
81134afc:	483f7d0e 	bge	r9,zero,811348f4 <__reset+0xfb1148f4>
81134b00:	003ddc06 	br	81134274 <__reset+0xfb114274>
81134b04:	d8c02215 	stw	r3,136(sp)
81134b08:	0039883a 	mov	fp,zero
81134b0c:	003ddb06 	br	8113427c <__reset+0xfb11427c>
81134b10:	02a04574 	movhi	r10,33045
81134b14:	528b1f04 	addi	r10,r10,11388
81134b18:	da802415 	stw	r10,144(sp)
81134b1c:	003e8306 	br	8113452c <__reset+0xfb11452c>
81134b20:	d8801c17 	ldw	r2,112(sp)
81134b24:	dd002117 	ldw	r20,132(sp)
81134b28:	103eb926 	beq	r2,zero,81134610 <__reset+0xfb114610>
81134b2c:	d9002017 	ldw	r4,128(sp)
81134b30:	d9801a04 	addi	r6,sp,104
81134b34:	a00b883a 	mov	r5,r20
81134b38:	11337980 	call	81133798 <__sprint_r.part.0>
81134b3c:	003eb406 	br	81134610 <__reset+0xfb114610>
81134b40:	80c00043 	ldbu	r3,1(r16)
81134b44:	a5000814 	ori	r20,r20,32
81134b48:	84000044 	addi	r16,r16,1
81134b4c:	18c03fcc 	andi	r3,r3,255
81134b50:	18c0201c 	xori	r3,r3,128
81134b54:	18ffe004 	addi	r3,r3,-128
81134b58:	003bb706 	br	81133a38 <__reset+0xfb113a38>
81134b5c:	a809883a 	mov	r4,r21
81134b60:	d8c02a15 	stw	r3,168(sp)
81134b64:	da002b15 	stw	r8,172(sp)
81134b68:	11251780 	call	81125178 <strlen>
81134b6c:	d8c02a17 	ldw	r3,168(sp)
81134b70:	1027883a 	mov	r19,r2
81134b74:	df001d83 	ldbu	fp,118(sp)
81134b78:	d8c02215 	stw	r3,136(sp)
81134b7c:	0013883a 	mov	r9,zero
81134b80:	da002b17 	ldw	r8,172(sp)
81134b84:	003c4d06 	br	81133cbc <__reset+0xfb113cbc>
81134b88:	d9402117 	ldw	r5,132(sp)
81134b8c:	d9002017 	ldw	r4,128(sp)
81134b90:	d9801a04 	addi	r6,sp,104
81134b94:	da402c15 	stw	r9,176(sp)
81134b98:	11337980 	call	81133798 <__sprint_r.part.0>
81134b9c:	da402c17 	ldw	r9,176(sp)
81134ba0:	103e9a1e 	bne	r2,zero,8113460c <__reset+0xfb11460c>
81134ba4:	d9401b17 	ldw	r5,108(sp)
81134ba8:	d8801c17 	ldw	r2,112(sp)
81134bac:	d811883a 	mov	r8,sp
81134bb0:	29000044 	addi	r4,r5,1
81134bb4:	003e4206 	br	811344c0 <__reset+0xfb1144c0>
81134bb8:	d9401b17 	ldw	r5,108(sp)
81134bbc:	01204574 	movhi	r4,33045
81134bc0:	210b2304 	addi	r4,r4,11404
81134bc4:	d9002415 	stw	r4,144(sp)
81134bc8:	29400044 	addi	r5,r5,1
81134bcc:	003c6d06 	br	81133d84 <__reset+0xfb113d84>
81134bd0:	0039883a 	mov	fp,zero
81134bd4:	00800084 	movi	r2,2
81134bd8:	10803fcc 	andi	r2,r2,255
81134bdc:	01000044 	movi	r4,1
81134be0:	11001e26 	beq	r2,r4,81134c5c <___vfiprintf_internal_r+0x13a8>
81134be4:	01000084 	movi	r4,2
81134be8:	11001e1e 	bne	r2,r4,81134c64 <___vfiprintf_internal_r+0x13b0>
81134bec:	1829883a 	mov	r20,r3
81134bf0:	003eea06 	br	8113479c <__reset+0xfb11479c>
81134bf4:	a007883a 	mov	r3,r20
81134bf8:	00800044 	movi	r2,1
81134bfc:	003ff606 	br	81134bd8 <__reset+0xfb114bd8>
81134c00:	00800184 	movi	r2,6
81134c04:	1240012e 	bgeu	r2,r9,81134c0c <___vfiprintf_internal_r+0x1358>
81134c08:	1013883a 	mov	r9,r2
81134c0c:	4827883a 	mov	r19,r9
81134c10:	4825883a 	mov	r18,r9
81134c14:	48001516 	blt	r9,zero,81134c6c <___vfiprintf_internal_r+0x13b8>
81134c18:	05604574 	movhi	r21,33045
81134c1c:	d8c02215 	stw	r3,136(sp)
81134c20:	ad4a9204 	addi	r21,r21,10824
81134c24:	003d1406 	br	81134078 <__reset+0xfb114078>
81134c28:	02a04574 	movhi	r10,33045
81134c2c:	528b1f04 	addi	r10,r10,11388
81134c30:	da802415 	stw	r10,144(sp)
81134c34:	200d883a 	mov	r6,r4
81134c38:	003c9106 	br	81133e80 <__reset+0xfb113e80>
81134c3c:	5021883a 	mov	r16,r10
81134c40:	0013883a 	mov	r9,zero
81134c44:	003b7d06 	br	81133a3c <__reset+0xfb113a3c>
81134c48:	4827883a 	mov	r19,r9
81134c4c:	df001d83 	ldbu	fp,118(sp)
81134c50:	d8c02215 	stw	r3,136(sp)
81134c54:	0013883a 	mov	r9,zero
81134c58:	003c1806 	br	81133cbc <__reset+0xfb113cbc>
81134c5c:	1829883a 	mov	r20,r3
81134c60:	003d1806 	br	811340c4 <__reset+0xfb1140c4>
81134c64:	1829883a 	mov	r20,r3
81134c68:	003ccd06 	br	81133fa0 <__reset+0xfb113fa0>
81134c6c:	0025883a 	mov	r18,zero
81134c70:	003fe906 	br	81134c18 <__reset+0xfb114c18>
81134c74:	d8802217 	ldw	r2,136(sp)
81134c78:	80c00043 	ldbu	r3,1(r16)
81134c7c:	5021883a 	mov	r16,r10
81134c80:	12400017 	ldw	r9,0(r2)
81134c84:	10800104 	addi	r2,r2,4
81134c88:	d8802215 	stw	r2,136(sp)
81134c8c:	483faf0e 	bge	r9,zero,81134b4c <__reset+0xfb114b4c>
81134c90:	18c03fcc 	andi	r3,r3,255
81134c94:	18c0201c 	xori	r3,r3,128
81134c98:	027fffc4 	movi	r9,-1
81134c9c:	18ffe004 	addi	r3,r3,-128
81134ca0:	003b6506 	br	81133a38 <__reset+0xfb113a38>
81134ca4:	d9c01d85 	stb	r7,118(sp)
81134ca8:	003ca006 	br	81133f2c <__reset+0xfb113f2c>
81134cac:	d9c01d85 	stb	r7,118(sp)
81134cb0:	003cad06 	br	81133f68 <__reset+0xfb113f68>
81134cb4:	d9c01d85 	stb	r7,118(sp)
81134cb8:	003d7d06 	br	811342b0 <__reset+0xfb1142b0>
81134cbc:	d9c01d85 	stb	r7,118(sp)
81134cc0:	003d5f06 	br	81134240 <__reset+0xfb114240>
81134cc4:	a080004c 	andi	r2,r20,1
81134cc8:	0039883a 	mov	fp,zero
81134ccc:	10000526 	beq	r2,zero,81134ce4 <___vfiprintf_internal_r+0x1430>
81134cd0:	00800c04 	movi	r2,48
81134cd4:	d88019c5 	stb	r2,103(sp)
81134cd8:	dcc02717 	ldw	r19,156(sp)
81134cdc:	dd4019c4 	addi	r21,sp,103
81134ce0:	003bf606 	br	81133cbc <__reset+0xfb113cbc>
81134ce4:	0027883a 	mov	r19,zero
81134ce8:	dd401a04 	addi	r21,sp,104
81134cec:	003bf306 	br	81133cbc <__reset+0xfb113cbc>
81134cf0:	d9c01d85 	stb	r7,118(sp)
81134cf4:	003dc806 	br	81134418 <__reset+0xfb114418>
81134cf8:	d9c01d85 	stb	r7,118(sp)
81134cfc:	003d3a06 	br	811341e8 <__reset+0xfb1141e8>
81134d00:	d9c01d85 	stb	r7,118(sp)
81134d04:	003d2a06 	br	811341b0 <__reset+0xfb1141b0>
81134d08:	d9c01d85 	stb	r7,118(sp)
81134d0c:	003cde06 	br	81134088 <__reset+0xfb114088>
81134d10:	d9c01d85 	stb	r7,118(sp)
81134d14:	003cbc06 	br	81134008 <__reset+0xfb114008>

81134d18 <__vfiprintf_internal>:
81134d18:	00a04574 	movhi	r2,33045
81134d1c:	10945c04 	addi	r2,r2,20848
81134d20:	300f883a 	mov	r7,r6
81134d24:	280d883a 	mov	r6,r5
81134d28:	200b883a 	mov	r5,r4
81134d2c:	11000017 	ldw	r4,0(r2)
81134d30:	11338b41 	jmpi	811338b4 <___vfiprintf_internal_r>

81134d34 <__sbprintf>:
81134d34:	defee204 	addi	sp,sp,-1144
81134d38:	de00012e 	bgeu	sp,et,81134d40 <__sbprintf+0xc>
81134d3c:	003b68fa 	trap	3
81134d40:	2880030b 	ldhu	r2,12(r5)
81134d44:	2ac01917 	ldw	r11,100(r5)
81134d48:	2a80038b 	ldhu	r10,14(r5)
81134d4c:	2a400717 	ldw	r9,28(r5)
81134d50:	2a000917 	ldw	r8,36(r5)
81134d54:	00c10004 	movi	r3,1024
81134d58:	dc011a15 	stw	r16,1128(sp)
81134d5c:	10bfff4c 	andi	r2,r2,65533
81134d60:	2821883a 	mov	r16,r5
81134d64:	d8cb883a 	add	r5,sp,r3
81134d68:	dc811c15 	stw	r18,1136(sp)
81134d6c:	dc411b15 	stw	r17,1132(sp)
81134d70:	dfc11d15 	stw	ra,1140(sp)
81134d74:	2025883a 	mov	r18,r4
81134d78:	d881030d 	sth	r2,1036(sp)
81134d7c:	dac11915 	stw	r11,1124(sp)
81134d80:	da81038d 	sth	r10,1038(sp)
81134d84:	da410715 	stw	r9,1052(sp)
81134d88:	da010915 	stw	r8,1060(sp)
81134d8c:	dec10015 	stw	sp,1024(sp)
81134d90:	dec10415 	stw	sp,1040(sp)
81134d94:	d8c10215 	stw	r3,1032(sp)
81134d98:	d8c10515 	stw	r3,1044(sp)
81134d9c:	d8010615 	stw	zero,1048(sp)
81134da0:	11338b40 	call	811338b4 <___vfiprintf_internal_r>
81134da4:	1023883a 	mov	r17,r2
81134da8:	10000416 	blt	r2,zero,81134dbc <__sbprintf+0x88>
81134dac:	d9410004 	addi	r5,sp,1024
81134db0:	9009883a 	mov	r4,r18
81134db4:	112d3540 	call	8112d354 <_fflush_r>
81134db8:	10000d1e 	bne	r2,zero,81134df0 <__sbprintf+0xbc>
81134dbc:	d881030b 	ldhu	r2,1036(sp)
81134dc0:	1080100c 	andi	r2,r2,64
81134dc4:	10000326 	beq	r2,zero,81134dd4 <__sbprintf+0xa0>
81134dc8:	8080030b 	ldhu	r2,12(r16)
81134dcc:	10801014 	ori	r2,r2,64
81134dd0:	8080030d 	sth	r2,12(r16)
81134dd4:	8805883a 	mov	r2,r17
81134dd8:	dfc11d17 	ldw	ra,1140(sp)
81134ddc:	dc811c17 	ldw	r18,1136(sp)
81134de0:	dc411b17 	ldw	r17,1132(sp)
81134de4:	dc011a17 	ldw	r16,1128(sp)
81134de8:	dec11e04 	addi	sp,sp,1144
81134dec:	f800283a 	ret
81134df0:	047fffc4 	movi	r17,-1
81134df4:	003ff106 	br	81134dbc <__reset+0xfb114dbc>

81134df8 <_calloc_r>:
81134df8:	298b383a 	mul	r5,r5,r6
81134dfc:	defffe04 	addi	sp,sp,-8
81134e00:	de00012e 	bgeu	sp,et,81134e08 <_calloc_r+0x10>
81134e04:	003b68fa 	trap	3
81134e08:	dfc00115 	stw	ra,4(sp)
81134e0c:	dc000015 	stw	r16,0(sp)
81134e10:	1123eec0 	call	81123eec <_malloc_r>
81134e14:	10002926 	beq	r2,zero,81134ebc <_calloc_r+0xc4>
81134e18:	11bfff17 	ldw	r6,-4(r2)
81134e1c:	1021883a 	mov	r16,r2
81134e20:	00bfff04 	movi	r2,-4
81134e24:	308c703a 	and	r6,r6,r2
81134e28:	00c00904 	movi	r3,36
81134e2c:	308d883a 	add	r6,r6,r2
81134e30:	19801636 	bltu	r3,r6,81134e8c <_calloc_r+0x94>
81134e34:	008004c4 	movi	r2,19
81134e38:	11800b2e 	bgeu	r2,r6,81134e68 <_calloc_r+0x70>
81134e3c:	80000015 	stw	zero,0(r16)
81134e40:	80000115 	stw	zero,4(r16)
81134e44:	008006c4 	movi	r2,27
81134e48:	11801a2e 	bgeu	r2,r6,81134eb4 <_calloc_r+0xbc>
81134e4c:	80000215 	stw	zero,8(r16)
81134e50:	80000315 	stw	zero,12(r16)
81134e54:	30c0151e 	bne	r6,r3,81134eac <_calloc_r+0xb4>
81134e58:	80000415 	stw	zero,16(r16)
81134e5c:	80800604 	addi	r2,r16,24
81134e60:	80000515 	stw	zero,20(r16)
81134e64:	00000106 	br	81134e6c <_calloc_r+0x74>
81134e68:	8005883a 	mov	r2,r16
81134e6c:	10000015 	stw	zero,0(r2)
81134e70:	10000115 	stw	zero,4(r2)
81134e74:	10000215 	stw	zero,8(r2)
81134e78:	8005883a 	mov	r2,r16
81134e7c:	dfc00117 	ldw	ra,4(sp)
81134e80:	dc000017 	ldw	r16,0(sp)
81134e84:	dec00204 	addi	sp,sp,8
81134e88:	f800283a 	ret
81134e8c:	000b883a 	mov	r5,zero
81134e90:	8009883a 	mov	r4,r16
81134e94:	11248500 	call	81124850 <memset>
81134e98:	8005883a 	mov	r2,r16
81134e9c:	dfc00117 	ldw	ra,4(sp)
81134ea0:	dc000017 	ldw	r16,0(sp)
81134ea4:	dec00204 	addi	sp,sp,8
81134ea8:	f800283a 	ret
81134eac:	80800404 	addi	r2,r16,16
81134eb0:	003fee06 	br	81134e6c <__reset+0xfb114e6c>
81134eb4:	80800204 	addi	r2,r16,8
81134eb8:	003fec06 	br	81134e6c <__reset+0xfb114e6c>
81134ebc:	0005883a 	mov	r2,zero
81134ec0:	003fee06 	br	81134e7c <__reset+0xfb114e7c>

81134ec4 <_fclose_r>:
81134ec4:	28003b26 	beq	r5,zero,81134fb4 <_fclose_r+0xf0>
81134ec8:	defffc04 	addi	sp,sp,-16
81134ecc:	de00012e 	bgeu	sp,et,81134ed4 <_fclose_r+0x10>
81134ed0:	003b68fa 	trap	3
81134ed4:	dc400115 	stw	r17,4(sp)
81134ed8:	dc000015 	stw	r16,0(sp)
81134edc:	dfc00315 	stw	ra,12(sp)
81134ee0:	dc800215 	stw	r18,8(sp)
81134ee4:	2023883a 	mov	r17,r4
81134ee8:	2821883a 	mov	r16,r5
81134eec:	20000226 	beq	r4,zero,81134ef8 <_fclose_r+0x34>
81134ef0:	20800e17 	ldw	r2,56(r4)
81134ef4:	10002726 	beq	r2,zero,81134f94 <_fclose_r+0xd0>
81134ef8:	8080030f 	ldh	r2,12(r16)
81134efc:	1000071e 	bne	r2,zero,81134f1c <_fclose_r+0x58>
81134f00:	0005883a 	mov	r2,zero
81134f04:	dfc00317 	ldw	ra,12(sp)
81134f08:	dc800217 	ldw	r18,8(sp)
81134f0c:	dc400117 	ldw	r17,4(sp)
81134f10:	dc000017 	ldw	r16,0(sp)
81134f14:	dec00404 	addi	sp,sp,16
81134f18:	f800283a 	ret
81134f1c:	800b883a 	mov	r5,r16
81134f20:	8809883a 	mov	r4,r17
81134f24:	112d1300 	call	8112d130 <__sflush_r>
81134f28:	1025883a 	mov	r18,r2
81134f2c:	80800b17 	ldw	r2,44(r16)
81134f30:	10000426 	beq	r2,zero,81134f44 <_fclose_r+0x80>
81134f34:	81400717 	ldw	r5,28(r16)
81134f38:	8809883a 	mov	r4,r17
81134f3c:	103ee83a 	callr	r2
81134f40:	10001616 	blt	r2,zero,81134f9c <_fclose_r+0xd8>
81134f44:	8080030b 	ldhu	r2,12(r16)
81134f48:	1080200c 	andi	r2,r2,128
81134f4c:	1000151e 	bne	r2,zero,81134fa4 <_fclose_r+0xe0>
81134f50:	81400c17 	ldw	r5,48(r16)
81134f54:	28000526 	beq	r5,zero,81134f6c <_fclose_r+0xa8>
81134f58:	80801004 	addi	r2,r16,64
81134f5c:	28800226 	beq	r5,r2,81134f68 <_fclose_r+0xa4>
81134f60:	8809883a 	mov	r4,r17
81134f64:	112dbe80 	call	8112dbe8 <_free_r>
81134f68:	80000c15 	stw	zero,48(r16)
81134f6c:	81401117 	ldw	r5,68(r16)
81134f70:	28000326 	beq	r5,zero,81134f80 <_fclose_r+0xbc>
81134f74:	8809883a 	mov	r4,r17
81134f78:	112dbe80 	call	8112dbe8 <_free_r>
81134f7c:	80001115 	stw	zero,68(r16)
81134f80:	112d7600 	call	8112d760 <__sfp_lock_acquire>
81134f84:	8000030d 	sth	zero,12(r16)
81134f88:	112d7640 	call	8112d764 <__sfp_lock_release>
81134f8c:	9005883a 	mov	r2,r18
81134f90:	003fdc06 	br	81134f04 <__reset+0xfb114f04>
81134f94:	112d7500 	call	8112d750 <__sinit>
81134f98:	003fd706 	br	81134ef8 <__reset+0xfb114ef8>
81134f9c:	04bfffc4 	movi	r18,-1
81134fa0:	003fe806 	br	81134f44 <__reset+0xfb114f44>
81134fa4:	81400417 	ldw	r5,16(r16)
81134fa8:	8809883a 	mov	r4,r17
81134fac:	112dbe80 	call	8112dbe8 <_free_r>
81134fb0:	003fe706 	br	81134f50 <__reset+0xfb114f50>
81134fb4:	0005883a 	mov	r2,zero
81134fb8:	f800283a 	ret

81134fbc <fclose>:
81134fbc:	00a04574 	movhi	r2,33045
81134fc0:	10945c04 	addi	r2,r2,20848
81134fc4:	200b883a 	mov	r5,r4
81134fc8:	11000017 	ldw	r4,0(r2)
81134fcc:	1134ec41 	jmpi	81134ec4 <_fclose_r>

81134fd0 <__fputwc>:
81134fd0:	defff804 	addi	sp,sp,-32
81134fd4:	de00012e 	bgeu	sp,et,81134fdc <__fputwc+0xc>
81134fd8:	003b68fa 	trap	3
81134fdc:	dcc00415 	stw	r19,16(sp)
81134fe0:	dc800315 	stw	r18,12(sp)
81134fe4:	dc000115 	stw	r16,4(sp)
81134fe8:	dfc00715 	stw	ra,28(sp)
81134fec:	dd400615 	stw	r21,24(sp)
81134ff0:	dd000515 	stw	r20,20(sp)
81134ff4:	dc400215 	stw	r17,8(sp)
81134ff8:	2027883a 	mov	r19,r4
81134ffc:	2825883a 	mov	r18,r5
81135000:	3021883a 	mov	r16,r6
81135004:	112e6780 	call	8112e678 <__locale_mb_cur_max>
81135008:	00c00044 	movi	r3,1
8113500c:	10c03e26 	beq	r2,r3,81135108 <__fputwc+0x138>
81135010:	81c01704 	addi	r7,r16,92
81135014:	900d883a 	mov	r6,r18
81135018:	d80b883a 	mov	r5,sp
8113501c:	9809883a 	mov	r4,r19
81135020:	1135e540 	call	81135e54 <_wcrtomb_r>
81135024:	1029883a 	mov	r20,r2
81135028:	00bfffc4 	movi	r2,-1
8113502c:	a0802026 	beq	r20,r2,811350b0 <__fputwc+0xe0>
81135030:	d9400003 	ldbu	r5,0(sp)
81135034:	a0001c26 	beq	r20,zero,811350a8 <__fputwc+0xd8>
81135038:	0023883a 	mov	r17,zero
8113503c:	05400284 	movi	r21,10
81135040:	00000906 	br	81135068 <__fputwc+0x98>
81135044:	80800017 	ldw	r2,0(r16)
81135048:	11400005 	stb	r5,0(r2)
8113504c:	80c00017 	ldw	r3,0(r16)
81135050:	18c00044 	addi	r3,r3,1
81135054:	80c00015 	stw	r3,0(r16)
81135058:	8c400044 	addi	r17,r17,1
8113505c:	dc45883a 	add	r2,sp,r17
81135060:	8d00112e 	bgeu	r17,r20,811350a8 <__fputwc+0xd8>
81135064:	11400003 	ldbu	r5,0(r2)
81135068:	80c00217 	ldw	r3,8(r16)
8113506c:	18ffffc4 	addi	r3,r3,-1
81135070:	80c00215 	stw	r3,8(r16)
81135074:	183ff30e 	bge	r3,zero,81135044 <__reset+0xfb115044>
81135078:	80800617 	ldw	r2,24(r16)
8113507c:	18801916 	blt	r3,r2,811350e4 <__fputwc+0x114>
81135080:	80800017 	ldw	r2,0(r16)
81135084:	11400005 	stb	r5,0(r2)
81135088:	80800017 	ldw	r2,0(r16)
8113508c:	10c00003 	ldbu	r3,0(r2)
81135090:	10800044 	addi	r2,r2,1
81135094:	1d402326 	beq	r3,r21,81135124 <__fputwc+0x154>
81135098:	80800015 	stw	r2,0(r16)
8113509c:	8c400044 	addi	r17,r17,1
811350a0:	dc45883a 	add	r2,sp,r17
811350a4:	8d3fef36 	bltu	r17,r20,81135064 <__reset+0xfb115064>
811350a8:	9005883a 	mov	r2,r18
811350ac:	00000406 	br	811350c0 <__fputwc+0xf0>
811350b0:	80c0030b 	ldhu	r3,12(r16)
811350b4:	a005883a 	mov	r2,r20
811350b8:	18c01014 	ori	r3,r3,64
811350bc:	80c0030d 	sth	r3,12(r16)
811350c0:	dfc00717 	ldw	ra,28(sp)
811350c4:	dd400617 	ldw	r21,24(sp)
811350c8:	dd000517 	ldw	r20,20(sp)
811350cc:	dcc00417 	ldw	r19,16(sp)
811350d0:	dc800317 	ldw	r18,12(sp)
811350d4:	dc400217 	ldw	r17,8(sp)
811350d8:	dc000117 	ldw	r16,4(sp)
811350dc:	dec00804 	addi	sp,sp,32
811350e0:	f800283a 	ret
811350e4:	800d883a 	mov	r6,r16
811350e8:	29403fcc 	andi	r5,r5,255
811350ec:	9809883a 	mov	r4,r19
811350f0:	112b5180 	call	8112b518 <__swbuf_r>
811350f4:	10bfffe0 	cmpeqi	r2,r2,-1
811350f8:	10803fcc 	andi	r2,r2,255
811350fc:	103fd626 	beq	r2,zero,81135058 <__reset+0xfb115058>
81135100:	00bfffc4 	movi	r2,-1
81135104:	003fee06 	br	811350c0 <__reset+0xfb1150c0>
81135108:	90ffffc4 	addi	r3,r18,-1
8113510c:	01003f84 	movi	r4,254
81135110:	20ffbf36 	bltu	r4,r3,81135010 <__reset+0xfb115010>
81135114:	900b883a 	mov	r5,r18
81135118:	dc800005 	stb	r18,0(sp)
8113511c:	1029883a 	mov	r20,r2
81135120:	003fc506 	br	81135038 <__reset+0xfb115038>
81135124:	800d883a 	mov	r6,r16
81135128:	a80b883a 	mov	r5,r21
8113512c:	9809883a 	mov	r4,r19
81135130:	112b5180 	call	8112b518 <__swbuf_r>
81135134:	10bfffe0 	cmpeqi	r2,r2,-1
81135138:	003fef06 	br	811350f8 <__reset+0xfb1150f8>

8113513c <_fputwc_r>:
8113513c:	3080030b 	ldhu	r2,12(r6)
81135140:	10c8000c 	andi	r3,r2,8192
81135144:	1800051e 	bne	r3,zero,8113515c <_fputwc_r+0x20>
81135148:	30c01917 	ldw	r3,100(r6)
8113514c:	10880014 	ori	r2,r2,8192
81135150:	3080030d 	sth	r2,12(r6)
81135154:	18880014 	ori	r2,r3,8192
81135158:	30801915 	stw	r2,100(r6)
8113515c:	1134fd01 	jmpi	81134fd0 <__fputwc>

81135160 <fputwc>:
81135160:	00a04574 	movhi	r2,33045
81135164:	defffc04 	addi	sp,sp,-16
81135168:	10945c04 	addi	r2,r2,20848
8113516c:	de00012e 	bgeu	sp,et,81135174 <fputwc+0x14>
81135170:	003b68fa 	trap	3
81135174:	dc000115 	stw	r16,4(sp)
81135178:	14000017 	ldw	r16,0(r2)
8113517c:	dc400215 	stw	r17,8(sp)
81135180:	dfc00315 	stw	ra,12(sp)
81135184:	2023883a 	mov	r17,r4
81135188:	80000226 	beq	r16,zero,81135194 <fputwc+0x34>
8113518c:	80800e17 	ldw	r2,56(r16)
81135190:	10001026 	beq	r2,zero,811351d4 <fputwc+0x74>
81135194:	2880030b 	ldhu	r2,12(r5)
81135198:	10c8000c 	andi	r3,r2,8192
8113519c:	1800051e 	bne	r3,zero,811351b4 <fputwc+0x54>
811351a0:	28c01917 	ldw	r3,100(r5)
811351a4:	10880014 	ori	r2,r2,8192
811351a8:	2880030d 	sth	r2,12(r5)
811351ac:	18880014 	ori	r2,r3,8192
811351b0:	28801915 	stw	r2,100(r5)
811351b4:	280d883a 	mov	r6,r5
811351b8:	8009883a 	mov	r4,r16
811351bc:	880b883a 	mov	r5,r17
811351c0:	dfc00317 	ldw	ra,12(sp)
811351c4:	dc400217 	ldw	r17,8(sp)
811351c8:	dc000117 	ldw	r16,4(sp)
811351cc:	dec00404 	addi	sp,sp,16
811351d0:	1134fd01 	jmpi	81134fd0 <__fputwc>
811351d4:	8009883a 	mov	r4,r16
811351d8:	d9400015 	stw	r5,0(sp)
811351dc:	112d7500 	call	8112d750 <__sinit>
811351e0:	d9400017 	ldw	r5,0(sp)
811351e4:	003feb06 	br	81135194 <__reset+0xfb115194>

811351e8 <rshift>:
811351e8:	2807d17a 	srai	r3,r5,5
811351ec:	20800417 	ldw	r2,16(r4)
811351f0:	22000504 	addi	r8,r4,20
811351f4:	1880250e 	bge	r3,r2,8113528c <rshift+0xa4>
811351f8:	1085883a 	add	r2,r2,r2
811351fc:	18c7883a 	add	r3,r3,r3
81135200:	1085883a 	add	r2,r2,r2
81135204:	18c7883a 	add	r3,r3,r3
81135208:	294007cc 	andi	r5,r5,31
8113520c:	4085883a 	add	r2,r8,r2
81135210:	40c7883a 	add	r3,r8,r3
81135214:	28002026 	beq	r5,zero,81135298 <rshift+0xb0>
81135218:	19800017 	ldw	r6,0(r3)
8113521c:	02c00804 	movi	r11,32
81135220:	19c00104 	addi	r7,r3,4
81135224:	5957c83a 	sub	r11,r11,r5
81135228:	314cd83a 	srl	r6,r6,r5
8113522c:	38802c2e 	bgeu	r7,r2,811352e0 <rshift+0xf8>
81135230:	4015883a 	mov	r10,r8
81135234:	3a400017 	ldw	r9,0(r7)
81135238:	52800104 	addi	r10,r10,4
8113523c:	39c00104 	addi	r7,r7,4
81135240:	4ad2983a 	sll	r9,r9,r11
81135244:	498cb03a 	or	r6,r9,r6
81135248:	51bfff15 	stw	r6,-4(r10)
8113524c:	39bfff17 	ldw	r6,-4(r7)
81135250:	314cd83a 	srl	r6,r6,r5
81135254:	38bff736 	bltu	r7,r2,81135234 <__reset+0xfb115234>
81135258:	10c7c83a 	sub	r3,r2,r3
8113525c:	18fffec4 	addi	r3,r3,-5
81135260:	1806d0ba 	srli	r3,r3,2
81135264:	18c00044 	addi	r3,r3,1
81135268:	18c7883a 	add	r3,r3,r3
8113526c:	18c7883a 	add	r3,r3,r3
81135270:	40c7883a 	add	r3,r8,r3
81135274:	19800015 	stw	r6,0(r3)
81135278:	30000126 	beq	r6,zero,81135280 <rshift+0x98>
8113527c:	18c00104 	addi	r3,r3,4
81135280:	1a05c83a 	sub	r2,r3,r8
81135284:	1005d0ba 	srai	r2,r2,2
81135288:	00001206 	br	811352d4 <rshift+0xec>
8113528c:	20000415 	stw	zero,16(r4)
81135290:	20000515 	stw	zero,20(r4)
81135294:	f800283a 	ret
81135298:	18bffc2e 	bgeu	r3,r2,8113528c <__reset+0xfb11528c>
8113529c:	180d883a 	mov	r6,r3
811352a0:	400b883a 	mov	r5,r8
811352a4:	31c00017 	ldw	r7,0(r6)
811352a8:	29400104 	addi	r5,r5,4
811352ac:	31800104 	addi	r6,r6,4
811352b0:	29ffff15 	stw	r7,-4(r5)
811352b4:	30bffb36 	bltu	r6,r2,811352a4 <__reset+0xfb1152a4>
811352b8:	00c6303a 	nor	r3,zero,r3
811352bc:	1885883a 	add	r2,r3,r2
811352c0:	1004d0ba 	srli	r2,r2,2
811352c4:	10800044 	addi	r2,r2,1
811352c8:	1085883a 	add	r2,r2,r2
811352cc:	1085883a 	add	r2,r2,r2
811352d0:	1005d0ba 	srai	r2,r2,2
811352d4:	20800415 	stw	r2,16(r4)
811352d8:	103fed26 	beq	r2,zero,81135290 <__reset+0xfb115290>
811352dc:	f800283a 	ret
811352e0:	4007883a 	mov	r3,r8
811352e4:	003fe306 	br	81135274 <__reset+0xfb115274>

811352e8 <__gethex>:
811352e8:	deffeb04 	addi	sp,sp,-84
811352ec:	de00012e 	bgeu	sp,et,811352f4 <__gethex+0xc>
811352f0:	003b68fa 	trap	3
811352f4:	dfc01415 	stw	ra,80(sp)
811352f8:	dd801115 	stw	r22,68(sp)
811352fc:	dcc00e15 	stw	r19,56(sp)
81135300:	dc800d15 	stw	r18,52(sp)
81135304:	2827883a 	mov	r19,r5
81135308:	d9000115 	stw	r4,4(sp)
8113530c:	d9800015 	stw	r6,0(sp)
81135310:	d9c00415 	stw	r7,16(sp)
81135314:	df001315 	stw	fp,76(sp)
81135318:	ddc01215 	stw	r23,72(sp)
8113531c:	dd401015 	stw	r21,64(sp)
81135320:	dd000f15 	stw	r20,60(sp)
81135324:	dc400c15 	stw	r17,48(sp)
81135328:	dc000b15 	stw	r16,44(sp)
8113532c:	112e69c0 	call	8112e69c <_localeconv_r>
81135330:	14800017 	ldw	r18,0(r2)
81135334:	9009883a 	mov	r4,r18
81135338:	11251780 	call	81125178 <strlen>
8113533c:	98c00017 	ldw	r3,0(r19)
81135340:	102d883a 	mov	r22,r2
81135344:	9085883a 	add	r2,r18,r2
81135348:	10bfffc3 	ldbu	r2,-1(r2)
8113534c:	19000083 	ldbu	r4,2(r3)
81135350:	d8800305 	stb	r2,12(sp)
81135354:	00800c04 	movi	r2,48
81135358:	2081521e 	bne	r4,r2,811358a4 <__gethex+0x5bc>
8113535c:	017fff84 	movi	r5,-2
81135360:	188000c4 	addi	r2,r3,3
81135364:	28cbc83a 	sub	r5,r5,r3
81135368:	200d883a 	mov	r6,r4
8113536c:	28a3883a 	add	r17,r5,r2
81135370:	102b883a 	mov	r21,r2
81135374:	10800044 	addi	r2,r2,1
81135378:	113fffc3 	ldbu	r4,-1(r2)
8113537c:	21bffb26 	beq	r4,r6,8113536c <__reset+0xfb11536c>
81135380:	05204574 	movhi	r20,33045
81135384:	a50b2704 	addi	r20,r20,11420
81135388:	a109883a 	add	r4,r20,r4
8113538c:	20800003 	ldbu	r2,0(r4)
81135390:	10008826 	beq	r2,zero,811355b4 <__gethex+0x2cc>
81135394:	a8800003 	ldbu	r2,0(r21)
81135398:	0015883a 	mov	r10,zero
8113539c:	002f883a 	mov	r23,zero
811353a0:	a085883a 	add	r2,r20,r2
811353a4:	10800003 	ldbu	r2,0(r2)
811353a8:	a821883a 	mov	r16,r21
811353ac:	10000526 	beq	r2,zero,811353c4 <__gethex+0xdc>
811353b0:	84000044 	addi	r16,r16,1
811353b4:	80800003 	ldbu	r2,0(r16)
811353b8:	a085883a 	add	r2,r20,r2
811353bc:	10800003 	ldbu	r2,0(r2)
811353c0:	103ffb1e 	bne	r2,zero,811353b0 <__reset+0xfb1153b0>
811353c4:	b00d883a 	mov	r6,r22
811353c8:	900b883a 	mov	r5,r18
811353cc:	8009883a 	mov	r4,r16
811353d0:	da800a15 	stw	r10,40(sp)
811353d4:	1135d840 	call	81135d84 <strncmp>
811353d8:	da800a17 	ldw	r10,40(sp)
811353dc:	1000031e 	bne	r2,zero,811353ec <__gethex+0x104>
811353e0:	b8015226 	beq	r23,zero,8113592c <__gethex+0x644>
811353e4:	80800003 	ldbu	r2,0(r16)
811353e8:	00000206 	br	811353f4 <__gethex+0x10c>
811353ec:	80800003 	ldbu	r2,0(r16)
811353f0:	b8011f26 	beq	r23,zero,81135870 <__gethex+0x588>
811353f4:	85efc83a 	sub	r23,r16,r23
811353f8:	bdef883a 	add	r23,r23,r23
811353fc:	bdef883a 	add	r23,r23,r23
81135400:	05efc83a 	sub	r23,zero,r23
81135404:	10803fcc 	andi	r2,r2,255
81135408:	01001404 	movi	r4,80
8113540c:	11008626 	beq	r2,r4,81135628 <__gethex+0x340>
81135410:	01001c04 	movi	r4,112
81135414:	11008426 	beq	r2,r4,81135628 <__gethex+0x340>
81135418:	8039883a 	mov	fp,r16
8113541c:	9c000015 	stw	r16,0(r19)
81135420:	5000711e 	bne	r10,zero,811355e8 <__gethex+0x300>
81135424:	e545c83a 	sub	r2,fp,r21
81135428:	10bfffc4 	addi	r2,r2,-1
8113542c:	010001c4 	movi	r4,7
81135430:	000b883a 	mov	r5,zero
81135434:	2080030e 	bge	r4,r2,81135444 <__gethex+0x15c>
81135438:	1005d07a 	srai	r2,r2,1
8113543c:	29400044 	addi	r5,r5,1
81135440:	20bffd16 	blt	r4,r2,81135438 <__reset+0xfb115438>
81135444:	d9000117 	ldw	r4,4(sp)
81135448:	112ebb80 	call	8112ebb8 <_Balloc>
8113544c:	10c00504 	addi	r3,r2,20
81135450:	d8c00215 	stw	r3,8(sp)
81135454:	1021883a 	mov	r16,r2
81135458:	af01732e 	bgeu	r21,fp,81135a28 <__gethex+0x740>
8113545c:	dc400303 	ldbu	r17,12(sp)
81135460:	03400044 	movi	r13,1
81135464:	1815883a 	mov	r10,r3
81135468:	0013883a 	mov	r9,zero
8113546c:	0027883a 	mov	r19,zero
81135470:	6d9bc83a 	sub	r13,r13,r22
81135474:	02c00804 	movi	r11,32
81135478:	e0bfffc3 	ldbu	r2,-1(fp)
8113547c:	e3bfffc4 	addi	r14,fp,-1
81135480:	88803026 	beq	r17,r2,81135544 <__gethex+0x25c>
81135484:	9ac04526 	beq	r19,r11,8113559c <__gethex+0x2b4>
81135488:	980b883a 	mov	r5,r19
8113548c:	9cc00104 	addi	r19,r19,4
81135490:	e13fffc3 	ldbu	r4,-1(fp)
81135494:	7039883a 	mov	fp,r14
81135498:	a109883a 	add	r4,r20,r4
8113549c:	20800003 	ldbu	r2,0(r4)
811354a0:	108003cc 	andi	r2,r2,15
811354a4:	1144983a 	sll	r2,r2,r5
811354a8:	4892b03a 	or	r9,r9,r2
811354ac:	af3ff236 	bltu	r21,fp,81135478 <__reset+0xfb115478>
811354b0:	d8c00217 	ldw	r3,8(sp)
811354b4:	50800104 	addi	r2,r10,4
811354b8:	52400015 	stw	r9,0(r10)
811354bc:	10c5c83a 	sub	r2,r2,r3
811354c0:	1005d0ba 	srai	r2,r2,2
811354c4:	4809883a 	mov	r4,r9
811354c8:	80800415 	stw	r2,16(r16)
811354cc:	1022917a 	slli	r17,r2,5
811354d0:	112eec40 	call	8112eec4 <__hi0bits>
811354d4:	d8c00017 	ldw	r3,0(sp)
811354d8:	8885c83a 	sub	r2,r17,r2
811354dc:	1c800017 	ldw	r18,0(r3)
811354e0:	9080c716 	blt	r18,r2,81135800 <__gethex+0x518>
811354e4:	1480e416 	blt	r2,r18,81135878 <__gethex+0x590>
811354e8:	0027883a 	mov	r19,zero
811354ec:	d8c00017 	ldw	r3,0(sp)
811354f0:	18800217 	ldw	r2,8(r3)
811354f4:	15c08d16 	blt	r2,r23,8113572c <__gethex+0x444>
811354f8:	d8c00017 	ldw	r3,0(sp)
811354fc:	18800117 	ldw	r2,4(r3)
81135500:	b880aa0e 	bge	r23,r2,811357ac <__gethex+0x4c4>
81135504:	15efc83a 	sub	r23,r2,r23
81135508:	bc80ed16 	blt	r23,r18,811358c0 <__gethex+0x5d8>
8113550c:	18c00317 	ldw	r3,12(r3)
81135510:	01000084 	movi	r4,2
81135514:	19014926 	beq	r3,r4,81135a3c <__gethex+0x754>
81135518:	010000c4 	movi	r4,3
8113551c:	19012e26 	beq	r3,r4,811359d8 <__gethex+0x6f0>
81135520:	01000044 	movi	r4,1
81135524:	19014826 	beq	r3,r4,81135a48 <__gethex+0x760>
81135528:	d9000117 	ldw	r4,4(sp)
8113552c:	800b883a 	mov	r5,r16
81135530:	112ec680 	call	8112ec68 <_Bfree>
81135534:	d8801517 	ldw	r2,84(sp)
81135538:	10000015 	stw	zero,0(r2)
8113553c:	00801404 	movi	r2,80
81135540:	00002b06 	br	811355f0 <__gethex+0x308>
81135544:	735f883a 	add	r15,r14,r13
81135548:	7d7fce36 	bltu	r15,r21,81135484 <__reset+0xfb115484>
8113554c:	7809883a 	mov	r4,r15
81135550:	b00d883a 	mov	r6,r22
81135554:	900b883a 	mov	r5,r18
81135558:	da400515 	stw	r9,20(sp)
8113555c:	da800a15 	stw	r10,40(sp)
81135560:	dac00915 	stw	r11,36(sp)
81135564:	db400815 	stw	r13,32(sp)
81135568:	db800615 	stw	r14,24(sp)
8113556c:	dbc00715 	stw	r15,28(sp)
81135570:	1135d840 	call	81135d84 <strncmp>
81135574:	da400517 	ldw	r9,20(sp)
81135578:	da800a17 	ldw	r10,40(sp)
8113557c:	dac00917 	ldw	r11,36(sp)
81135580:	db400817 	ldw	r13,32(sp)
81135584:	db800617 	ldw	r14,24(sp)
81135588:	dbc00717 	ldw	r15,28(sp)
8113558c:	103fbd1e 	bne	r2,zero,81135484 <__reset+0xfb115484>
81135590:	7839883a 	mov	fp,r15
81135594:	af3fb836 	bltu	r21,fp,81135478 <__reset+0xfb115478>
81135598:	003fc506 	br	811354b0 <__reset+0xfb1154b0>
8113559c:	04c00104 	movi	r19,4
811355a0:	52400015 	stw	r9,0(r10)
811355a4:	000b883a 	mov	r5,zero
811355a8:	54d5883a 	add	r10,r10,r19
811355ac:	0013883a 	mov	r9,zero
811355b0:	003fb706 	br	81135490 <__reset+0xfb115490>
811355b4:	b00d883a 	mov	r6,r22
811355b8:	900b883a 	mov	r5,r18
811355bc:	a809883a 	mov	r4,r21
811355c0:	1135d840 	call	81135d84 <strncmp>
811355c4:	10006426 	beq	r2,zero,81135758 <__gethex+0x470>
811355c8:	a8800003 	ldbu	r2,0(r21)
811355cc:	a821883a 	mov	r16,r21
811355d0:	10803fcc 	andi	r2,r2,255
811355d4:	01001404 	movi	r4,80
811355d8:	11001126 	beq	r2,r4,81135620 <__gethex+0x338>
811355dc:	01001c04 	movi	r4,112
811355e0:	11000f26 	beq	r2,r4,81135620 <__gethex+0x338>
811355e4:	9c000015 	stw	r16,0(r19)
811355e8:	8800831e 	bne	r17,zero,811357f8 <__gethex+0x510>
811355ec:	00800184 	movi	r2,6
811355f0:	dfc01417 	ldw	ra,80(sp)
811355f4:	df001317 	ldw	fp,76(sp)
811355f8:	ddc01217 	ldw	r23,72(sp)
811355fc:	dd801117 	ldw	r22,68(sp)
81135600:	dd401017 	ldw	r21,64(sp)
81135604:	dd000f17 	ldw	r20,60(sp)
81135608:	dcc00e17 	ldw	r19,56(sp)
8113560c:	dc800d17 	ldw	r18,52(sp)
81135610:	dc400c17 	ldw	r17,48(sp)
81135614:	dc000b17 	ldw	r16,44(sp)
81135618:	dec01504 	addi	sp,sp,84
8113561c:	f800283a 	ret
81135620:	002f883a 	mov	r23,zero
81135624:	02800044 	movi	r10,1
81135628:	80800043 	ldbu	r2,1(r16)
8113562c:	01400ac4 	movi	r5,43
81135630:	11003fcc 	andi	r4,r2,255
81135634:	21406e26 	beq	r4,r5,811357f0 <__gethex+0x508>
81135638:	01400b44 	movi	r5,45
8113563c:	21404226 	beq	r4,r5,81135748 <__gethex+0x460>
81135640:	81400044 	addi	r5,r16,1
81135644:	000d883a 	mov	r6,zero
81135648:	10803fcc 	andi	r2,r2,255
8113564c:	a085883a 	add	r2,r20,r2
81135650:	11000003 	ldbu	r4,0(r2)
81135654:	03000604 	movi	r12,24
81135658:	20bfffc4 	addi	r2,r4,-1
8113565c:	10803fcc 	andi	r2,r2,255
81135660:	60bf6d36 	bltu	r12,r2,81135418 <__reset+0xfb115418>
81135664:	2ac00043 	ldbu	r11,1(r5)
81135668:	20803fcc 	andi	r2,r4,255
8113566c:	01204574 	movhi	r4,33045
81135670:	210b2704 	addi	r4,r4,11420
81135674:	22c9883a 	add	r4,r4,r11
81135678:	23400003 	ldbu	r13,0(r4)
8113567c:	10bffc04 	addi	r2,r2,-16
81135680:	29400044 	addi	r5,r5,1
81135684:	693fffc4 	addi	r4,r13,-1
81135688:	21003fcc 	andi	r4,r4,255
8113568c:	6b403fcc 	andi	r13,r13,255
81135690:	61000b36 	bltu	r12,r4,811356c0 <__gethex+0x3d8>
81135694:	29400044 	addi	r5,r5,1
81135698:	29000003 	ldbu	r4,0(r5)
8113569c:	108002a4 	muli	r2,r2,10
811356a0:	a109883a 	add	r4,r20,r4
811356a4:	22c00003 	ldbu	r11,0(r4)
811356a8:	1345883a 	add	r2,r2,r13
811356ac:	10bffc04 	addi	r2,r2,-16
811356b0:	593fffc4 	addi	r4,r11,-1
811356b4:	21003fcc 	andi	r4,r4,255
811356b8:	5b403fcc 	andi	r13,r11,255
811356bc:	613ff52e 	bgeu	r12,r4,81135694 <__reset+0xfb115694>
811356c0:	30000126 	beq	r6,zero,811356c8 <__gethex+0x3e0>
811356c4:	0085c83a 	sub	r2,zero,r2
811356c8:	8039883a 	mov	fp,r16
811356cc:	b8af883a 	add	r23,r23,r2
811356d0:	2821883a 	mov	r16,r5
811356d4:	003f5106 	br	8113541c <__reset+0xfb11541c>
811356d8:	80800217 	ldw	r2,8(r16)
811356dc:	e080f00e 	bge	fp,r2,81135aa0 <__gethex+0x7b8>
811356e0:	e007883a 	mov	r3,fp
811356e4:	18800144 	addi	r2,r3,5
811356e8:	1085883a 	add	r2,r2,r2
811356ec:	18c00044 	addi	r3,r3,1
811356f0:	1085883a 	add	r2,r2,r2
811356f4:	8085883a 	add	r2,r16,r2
811356f8:	80c00415 	stw	r3,16(r16)
811356fc:	01000044 	movi	r4,1
81135700:	11000015 	stw	r4,0(r2)
81135704:	00800084 	movi	r2,2
81135708:	8880d826 	beq	r17,r2,81135a6c <__gethex+0x784>
8113570c:	e0c0ac0e 	bge	fp,r3,811359c0 <__gethex+0x6d8>
81135710:	01400044 	movi	r5,1
81135714:	8009883a 	mov	r4,r16
81135718:	11351e80 	call	811351e8 <rshift>
8113571c:	d8c00017 	ldw	r3,0(sp)
81135720:	bdc00044 	addi	r23,r23,1
81135724:	18800217 	ldw	r2,8(r3)
81135728:	15c0a70e 	bge	r2,r23,811359c8 <__gethex+0x6e0>
8113572c:	d9000117 	ldw	r4,4(sp)
81135730:	800b883a 	mov	r5,r16
81135734:	112ec680 	call	8112ec68 <_Bfree>
81135738:	d9001517 	ldw	r4,84(sp)
8113573c:	008028c4 	movi	r2,163
81135740:	20000015 	stw	zero,0(r4)
81135744:	003faa06 	br	811355f0 <__reset+0xfb1155f0>
81135748:	01800044 	movi	r6,1
8113574c:	80800083 	ldbu	r2,2(r16)
81135750:	81400084 	addi	r5,r16,2
81135754:	003fbc06 	br	81135648 <__reset+0xfb115648>
81135758:	ada1883a 	add	r16,r21,r22
8113575c:	81000003 	ldbu	r4,0(r16)
81135760:	21403fcc 	andi	r5,r4,255
81135764:	a145883a 	add	r2,r20,r5
81135768:	10800003 	ldbu	r2,0(r2)
8113576c:	11803fcc 	andi	r6,r2,255
81135770:	30004f26 	beq	r6,zero,811358b0 <__gethex+0x5c8>
81135774:	00c00c04 	movi	r3,48
81135778:	802b883a 	mov	r21,r16
8113577c:	28c0061e 	bne	r5,r3,81135798 <__gethex+0x4b0>
81135780:	2809883a 	mov	r4,r5
81135784:	ad400044 	addi	r21,r21,1
81135788:	a8800003 	ldbu	r2,0(r21)
8113578c:	113ffd26 	beq	r2,r4,81135784 <__reset+0xfb115784>
81135790:	a085883a 	add	r2,r20,r2
81135794:	10800003 	ldbu	r2,0(r2)
81135798:	10803fcc 	andi	r2,r2,255
8113579c:	1015003a 	cmpeq	r10,r2,zero
811357a0:	802f883a 	mov	r23,r16
811357a4:	04400044 	movi	r17,1
811357a8:	003eff06 	br	811353a8 <__reset+0xfb1153a8>
811357ac:	04400044 	movi	r17,1
811357b0:	98000926 	beq	r19,zero,811357d8 <__gethex+0x4f0>
811357b4:	d8c00017 	ldw	r3,0(sp)
811357b8:	18800317 	ldw	r2,12(r3)
811357bc:	00c00084 	movi	r3,2
811357c0:	10c06826 	beq	r2,r3,81135964 <__gethex+0x67c>
811357c4:	00c000c4 	movi	r3,3
811357c8:	10c06a26 	beq	r2,r3,81135974 <__gethex+0x68c>
811357cc:	00c00044 	movi	r3,1
811357d0:	10c08d26 	beq	r2,r3,81135a08 <__gethex+0x720>
811357d4:	8c400414 	ori	r17,r17,16
811357d8:	d9001517 	ldw	r4,84(sp)
811357dc:	d8c00417 	ldw	r3,16(sp)
811357e0:	8805883a 	mov	r2,r17
811357e4:	24000015 	stw	r16,0(r4)
811357e8:	1dc00015 	stw	r23,0(r3)
811357ec:	003f8006 	br	811355f0 <__reset+0xfb1155f0>
811357f0:	000d883a 	mov	r6,zero
811357f4:	003fd506 	br	8113574c <__reset+0xfb11574c>
811357f8:	0005883a 	mov	r2,zero
811357fc:	003f7c06 	br	811355f0 <__reset+0xfb1155f0>
81135800:	14a3c83a 	sub	r17,r2,r18
81135804:	880b883a 	mov	r5,r17
81135808:	8009883a 	mov	r4,r16
8113580c:	112fb880 	call	8112fb88 <__any_on>
81135810:	10002926 	beq	r2,zero,811358b8 <__gethex+0x5d0>
81135814:	897fffc4 	addi	r5,r17,-1
81135818:	2807d17a 	srai	r3,r5,5
8113581c:	d8800217 	ldw	r2,8(sp)
81135820:	290007cc 	andi	r4,r5,31
81135824:	18c7883a 	add	r3,r3,r3
81135828:	18c7883a 	add	r3,r3,r3
8113582c:	04c00044 	movi	r19,1
81135830:	10c7883a 	add	r3,r2,r3
81135834:	9908983a 	sll	r4,r19,r4
81135838:	18c00017 	ldw	r3,0(r3)
8113583c:	20c6703a 	and	r3,r4,r3
81135840:	18000626 	beq	r3,zero,8113585c <__gethex+0x574>
81135844:	99407b0e 	bge	r19,r5,81135a34 <__gethex+0x74c>
81135848:	897fff84 	addi	r5,r17,-2
8113584c:	8009883a 	mov	r4,r16
81135850:	112fb880 	call	8112fb88 <__any_on>
81135854:	10007726 	beq	r2,zero,81135a34 <__gethex+0x74c>
81135858:	04c000c4 	movi	r19,3
8113585c:	880b883a 	mov	r5,r17
81135860:	8009883a 	mov	r4,r16
81135864:	11351e80 	call	811351e8 <rshift>
81135868:	bc6f883a 	add	r23,r23,r17
8113586c:	003f1f06 	br	811354ec <__reset+0xfb1154ec>
81135870:	002f883a 	mov	r23,zero
81135874:	003ee306 	br	81135404 <__reset+0xfb115404>
81135878:	d9000117 	ldw	r4,4(sp)
8113587c:	90a3c83a 	sub	r17,r18,r2
81135880:	800b883a 	mov	r5,r16
81135884:	880d883a 	mov	r6,r17
81135888:	112f3680 	call	8112f368 <__lshift>
8113588c:	10c00504 	addi	r3,r2,20
81135890:	1021883a 	mov	r16,r2
81135894:	bc6fc83a 	sub	r23,r23,r17
81135898:	d8c00215 	stw	r3,8(sp)
8113589c:	0027883a 	mov	r19,zero
811358a0:	003f1206 	br	811354ec <__reset+0xfb1154ec>
811358a4:	1d400084 	addi	r21,r3,2
811358a8:	0023883a 	mov	r17,zero
811358ac:	003eb406 	br	81135380 <__reset+0xfb115380>
811358b0:	2005883a 	mov	r2,r4
811358b4:	003f4606 	br	811355d0 <__reset+0xfb1155d0>
811358b8:	0027883a 	mov	r19,zero
811358bc:	003fe706 	br	8113585c <__reset+0xfb11585c>
811358c0:	bc7fffc4 	addi	r17,r23,-1
811358c4:	9800421e 	bne	r19,zero,811359d0 <__gethex+0x6e8>
811358c8:	88000426 	beq	r17,zero,811358dc <__gethex+0x5f4>
811358cc:	880b883a 	mov	r5,r17
811358d0:	8009883a 	mov	r4,r16
811358d4:	112fb880 	call	8112fb88 <__any_on>
811358d8:	1027883a 	mov	r19,r2
811358dc:	8805d17a 	srai	r2,r17,5
811358e0:	d8c00217 	ldw	r3,8(sp)
811358e4:	8c4007cc 	andi	r17,r17,31
811358e8:	1085883a 	add	r2,r2,r2
811358ec:	1085883a 	add	r2,r2,r2
811358f0:	1885883a 	add	r2,r3,r2
811358f4:	00c00044 	movi	r3,1
811358f8:	1c62983a 	sll	r17,r3,r17
811358fc:	10800017 	ldw	r2,0(r2)
81135900:	8884703a 	and	r2,r17,r2
81135904:	10000126 	beq	r2,zero,8113590c <__gethex+0x624>
81135908:	9cc00094 	ori	r19,r19,2
8113590c:	b80b883a 	mov	r5,r23
81135910:	8009883a 	mov	r4,r16
81135914:	11351e80 	call	811351e8 <rshift>
81135918:	d8c00017 	ldw	r3,0(sp)
8113591c:	95e5c83a 	sub	r18,r18,r23
81135920:	04400084 	movi	r17,2
81135924:	1dc00117 	ldw	r23,4(r3)
81135928:	003fa106 	br	811357b0 <__reset+0xfb1157b0>
8113592c:	85af883a 	add	r23,r16,r22
81135930:	b8800003 	ldbu	r2,0(r23)
81135934:	b821883a 	mov	r16,r23
81135938:	11003fcc 	andi	r4,r2,255
8113593c:	a109883a 	add	r4,r20,r4
81135940:	21000003 	ldbu	r4,0(r4)
81135944:	203eaa26 	beq	r4,zero,811353f0 <__reset+0xfb1153f0>
81135948:	84000044 	addi	r16,r16,1
8113594c:	80800003 	ldbu	r2,0(r16)
81135950:	11003fcc 	andi	r4,r2,255
81135954:	a109883a 	add	r4,r20,r4
81135958:	21000003 	ldbu	r4,0(r4)
8113595c:	203ffa1e 	bne	r4,zero,81135948 <__reset+0xfb115948>
81135960:	003ea306 	br	811353f0 <__reset+0xfb1153f0>
81135964:	d9001617 	ldw	r4,88(sp)
81135968:	00800044 	movi	r2,1
8113596c:	1109c83a 	sub	r4,r2,r4
81135970:	d9001615 	stw	r4,88(sp)
81135974:	d8801617 	ldw	r2,88(sp)
81135978:	103f9626 	beq	r2,zero,811357d4 <__reset+0xfb1157d4>
8113597c:	87000417 	ldw	fp,16(r16)
81135980:	d9800217 	ldw	r6,8(sp)
81135984:	013fffc4 	movi	r4,-1
81135988:	e727883a 	add	r19,fp,fp
8113598c:	9ce7883a 	add	r19,r19,r19
81135990:	3005883a 	mov	r2,r6
81135994:	34cb883a 	add	r5,r6,r19
81135998:	00000306 	br	811359a8 <__gethex+0x6c0>
8113599c:	10000015 	stw	zero,0(r2)
811359a0:	10800104 	addi	r2,r2,4
811359a4:	117f4c2e 	bgeu	r2,r5,811356d8 <__reset+0xfb1156d8>
811359a8:	10c00017 	ldw	r3,0(r2)
811359ac:	193ffb26 	beq	r3,r4,8113599c <__reset+0xfb11599c>
811359b0:	18c00044 	addi	r3,r3,1
811359b4:	10c00015 	stw	r3,0(r2)
811359b8:	00800084 	movi	r2,2
811359bc:	88802b26 	beq	r17,r2,81135a6c <__gethex+0x784>
811359c0:	948007cc 	andi	r18,r18,31
811359c4:	90002f1e 	bne	r18,zero,81135a84 <__gethex+0x79c>
811359c8:	04400844 	movi	r17,33
811359cc:	003f8206 	br	811357d8 <__reset+0xfb1157d8>
811359d0:	04c00044 	movi	r19,1
811359d4:	003fc106 	br	811358dc <__reset+0xfb1158dc>
811359d8:	d8c01617 	ldw	r3,88(sp)
811359dc:	183ed226 	beq	r3,zero,81135528 <__reset+0xfb115528>
811359e0:	d8c00417 	ldw	r3,16(sp)
811359e4:	d9001517 	ldw	r4,84(sp)
811359e8:	18800015 	stw	r2,0(r3)
811359ec:	d8c00217 	ldw	r3,8(sp)
811359f0:	00800044 	movi	r2,1
811359f4:	80800415 	stw	r2,16(r16)
811359f8:	18800015 	stw	r2,0(r3)
811359fc:	24000015 	stw	r16,0(r4)
81135a00:	00801884 	movi	r2,98
81135a04:	003efa06 	br	811355f0 <__reset+0xfb1155f0>
81135a08:	9880008c 	andi	r2,r19,2
81135a0c:	103f7126 	beq	r2,zero,811357d4 <__reset+0xfb1157d4>
81135a10:	d8c00217 	ldw	r3,8(sp)
81135a14:	18800017 	ldw	r2,0(r3)
81135a18:	9884b03a 	or	r2,r19,r2
81135a1c:	1080004c 	andi	r2,r2,1
81135a20:	103fd61e 	bne	r2,zero,8113597c <__reset+0xfb11597c>
81135a24:	003f6b06 	br	811357d4 <__reset+0xfb1157d4>
81135a28:	da800217 	ldw	r10,8(sp)
81135a2c:	0013883a 	mov	r9,zero
81135a30:	003e9f06 	br	811354b0 <__reset+0xfb1154b0>
81135a34:	04c00084 	movi	r19,2
81135a38:	003f8806 	br	8113585c <__reset+0xfb11585c>
81135a3c:	d9001617 	ldw	r4,88(sp)
81135a40:	203fe726 	beq	r4,zero,811359e0 <__reset+0xfb1159e0>
81135a44:	003eb806 	br	81135528 <__reset+0xfb115528>
81135a48:	95feb71e 	bne	r18,r23,81135528 <__reset+0xfb115528>
81135a4c:	1cbfe40e 	bge	r3,r18,811359e0 <__reset+0xfb1159e0>
81135a50:	917fffc4 	addi	r5,r18,-1
81135a54:	8009883a 	mov	r4,r16
81135a58:	112fb880 	call	8112fb88 <__any_on>
81135a5c:	103eb226 	beq	r2,zero,81135528 <__reset+0xfb115528>
81135a60:	d8c00017 	ldw	r3,0(sp)
81135a64:	18800117 	ldw	r2,4(r3)
81135a68:	003fdd06 	br	811359e0 <__reset+0xfb1159e0>
81135a6c:	d8c00017 	ldw	r3,0(sp)
81135a70:	18800017 	ldw	r2,0(r3)
81135a74:	10bfffc4 	addi	r2,r2,-1
81135a78:	90801c26 	beq	r18,r2,81135aec <__gethex+0x804>
81135a7c:	04400884 	movi	r17,34
81135a80:	003f5506 	br	811357d8 <__reset+0xfb1157d8>
81135a84:	34c5883a 	add	r2,r6,r19
81135a88:	113fff17 	ldw	r4,-4(r2)
81135a8c:	112eec40 	call	8112eec4 <__hi0bits>
81135a90:	00c00804 	movi	r3,32
81135a94:	1ca5c83a 	sub	r18,r3,r18
81135a98:	14bfcb0e 	bge	r2,r18,811359c8 <__reset+0xfb1159c8>
81135a9c:	003f1c06 	br	81135710 <__reset+0xfb115710>
81135aa0:	81400117 	ldw	r5,4(r16)
81135aa4:	d9000117 	ldw	r4,4(sp)
81135aa8:	29400044 	addi	r5,r5,1
81135aac:	112ebb80 	call	8112ebb8 <_Balloc>
81135ab0:	81800417 	ldw	r6,16(r16)
81135ab4:	81400304 	addi	r5,r16,12
81135ab8:	11000304 	addi	r4,r2,12
81135abc:	31800084 	addi	r6,r6,2
81135ac0:	318d883a 	add	r6,r6,r6
81135ac4:	318d883a 	add	r6,r6,r6
81135ac8:	1029883a 	mov	r20,r2
81135acc:	11247000 	call	81124700 <memcpy>
81135ad0:	d9000117 	ldw	r4,4(sp)
81135ad4:	800b883a 	mov	r5,r16
81135ad8:	a021883a 	mov	r16,r20
81135adc:	112ec680 	call	8112ec68 <_Bfree>
81135ae0:	a0c00417 	ldw	r3,16(r20)
81135ae4:	a1800504 	addi	r6,r20,20
81135ae8:	003efe06 	br	811356e4 <__reset+0xfb1156e4>
81135aec:	9005d17a 	srai	r2,r18,5
81135af0:	944007cc 	andi	r17,r18,31
81135af4:	1085883a 	add	r2,r2,r2
81135af8:	1085883a 	add	r2,r2,r2
81135afc:	3087883a 	add	r3,r6,r2
81135b00:	00800044 	movi	r2,1
81135b04:	1462983a 	sll	r17,r2,r17
81135b08:	18800017 	ldw	r2,0(r3)
81135b0c:	8884703a 	and	r2,r17,r2
81135b10:	1022c03a 	cmpne	r17,r2,zero
81135b14:	00800884 	movi	r2,34
81135b18:	1463c83a 	sub	r17,r2,r17
81135b1c:	003f2e06 	br	811357d8 <__reset+0xfb1157d8>

81135b20 <__hexnan>:
81135b20:	defff904 	addi	sp,sp,-28
81135b24:	de00012e 	bgeu	sp,et,81135b2c <__hexnan+0xc>
81135b28:	003b68fa 	trap	3
81135b2c:	dc800215 	stw	r18,8(sp)
81135b30:	2c800017 	ldw	r18,0(r5)
81135b34:	dfc00615 	stw	ra,24(sp)
81135b38:	dd400515 	stw	r21,20(sp)
81135b3c:	901fd17a 	srai	r15,r18,5
81135b40:	dd000415 	stw	r20,16(sp)
81135b44:	dcc00315 	stw	r19,12(sp)
81135b48:	7bdf883a 	add	r15,r15,r15
81135b4c:	7bdf883a 	add	r15,r15,r15
81135b50:	dc400115 	stw	r17,4(sp)
81135b54:	dc000015 	stw	r16,0(sp)
81135b58:	948007cc 	andi	r18,r18,31
81135b5c:	33df883a 	add	r15,r6,r15
81135b60:	90000126 	beq	r18,zero,81135b68 <__hexnan+0x48>
81135b64:	7bc00104 	addi	r15,r15,4
81135b68:	22000017 	ldw	r8,0(r4)
81135b6c:	7affff04 	addi	r11,r15,-4
81135b70:	03a04574 	movhi	r14,33045
81135b74:	783fff15 	stw	zero,-4(r15)
81135b78:	581b883a 	mov	r13,r11
81135b7c:	580b883a 	mov	r5,r11
81135b80:	000f883a 	mov	r7,zero
81135b84:	003f883a 	mov	ra,zero
81135b88:	0019883a 	mov	r12,zero
81135b8c:	738b2704 	addi	r14,r14,11420
81135b90:	04400204 	movi	r17,8
81135b94:	04000804 	movi	r16,32
81135b98:	04c001c4 	movi	r19,7
81135b9c:	42000044 	addi	r8,r8,1
81135ba0:	40c00003 	ldbu	r3,0(r8)
81135ba4:	18001d26 	beq	r3,zero,81135c1c <__hexnan+0xfc>
81135ba8:	70c5883a 	add	r2,r14,r3
81135bac:	10800003 	ldbu	r2,0(r2)
81135bb0:	12403fcc 	andi	r9,r2,255
81135bb4:	4800301e 	bne	r9,zero,81135c78 <__hexnan+0x158>
81135bb8:	80c04236 	bltu	r16,r3,81135cc4 <__hexnan+0x1a4>
81135bbc:	fb3ff70e 	bge	ra,r12,81135b9c <__reset+0xfb115b9c>
81135bc0:	2b40112e 	bgeu	r5,r13,81135c08 <__hexnan+0xe8>
81135bc4:	99c01016 	blt	r19,r7,81135c08 <__hexnan+0xe8>
81135bc8:	89e9c83a 	sub	r20,r17,r7
81135bcc:	a529883a 	add	r20,r20,r20
81135bd0:	2a800017 	ldw	r10,0(r5)
81135bd4:	a529883a 	add	r20,r20,r20
81135bd8:	852bc83a 	sub	r21,r16,r20
81135bdc:	28c00104 	addi	r3,r5,4
81135be0:	2805883a 	mov	r2,r5
81135be4:	19c00017 	ldw	r7,0(r3)
81135be8:	10800104 	addi	r2,r2,4
81135bec:	18c00104 	addi	r3,r3,4
81135bf0:	3d52983a 	sll	r9,r7,r21
81135bf4:	4a92b03a 	or	r9,r9,r10
81135bf8:	3d14d83a 	srl	r10,r7,r20
81135bfc:	127fff15 	stw	r9,-4(r2)
81135c00:	1abfff15 	stw	r10,-4(r3)
81135c04:	137ff736 	bltu	r2,r13,81135be4 <__reset+0xfb115be4>
81135c08:	31402836 	bltu	r6,r5,81135cac <__hexnan+0x18c>
81135c0c:	42000044 	addi	r8,r8,1
81135c10:	40c00003 	ldbu	r3,0(r8)
81135c14:	01c00204 	movi	r7,8
81135c18:	183fe31e 	bne	r3,zero,81135ba8 <__reset+0xfb115ba8>
81135c1c:	60002b26 	beq	r12,zero,81135ccc <__hexnan+0x1ac>
81135c20:	2b40022e 	bgeu	r5,r13,81135c2c <__hexnan+0x10c>
81135c24:	008001c4 	movi	r2,7
81135c28:	11c0430e 	bge	r2,r7,81135d38 <__hexnan+0x218>
81135c2c:	3140312e 	bgeu	r6,r5,81135cf4 <__hexnan+0x1d4>
81135c30:	3007883a 	mov	r3,r6
81135c34:	29000017 	ldw	r4,0(r5)
81135c38:	18800104 	addi	r2,r3,4
81135c3c:	29400104 	addi	r5,r5,4
81135c40:	19000015 	stw	r4,0(r3)
81135c44:	1007883a 	mov	r3,r2
81135c48:	597ffa2e 	bgeu	r11,r5,81135c34 <__reset+0xfb115c34>
81135c4c:	10000015 	stw	zero,0(r2)
81135c50:	10800104 	addi	r2,r2,4
81135c54:	58bffd2e 	bgeu	r11,r2,81135c4c <__reset+0xfb115c4c>
81135c58:	78bfff17 	ldw	r2,-4(r15)
81135c5c:	1000041e 	bne	r2,zero,81135c70 <__hexnan+0x150>
81135c60:	32c02d26 	beq	r6,r11,81135d18 <__hexnan+0x1f8>
81135c64:	5affff04 	addi	r11,r11,-4
81135c68:	58800017 	ldw	r2,0(r11)
81135c6c:	103ffc26 	beq	r2,zero,81135c60 <__reset+0xfb115c60>
81135c70:	00800144 	movi	r2,5
81135c74:	00001606 	br	81135cd0 <__hexnan+0x1b0>
81135c78:	39c00044 	addi	r7,r7,1
81135c7c:	63000044 	addi	r12,r12,1
81135c80:	89c0040e 	bge	r17,r7,81135c94 <__hexnan+0x174>
81135c84:	317fc52e 	bgeu	r6,r5,81135b9c <__reset+0xfb115b9c>
81135c88:	283fff15 	stw	zero,-4(r5)
81135c8c:	01c00044 	movi	r7,1
81135c90:	297fff04 	addi	r5,r5,-4
81135c94:	28c00017 	ldw	r3,0(r5)
81135c98:	108003cc 	andi	r2,r2,15
81135c9c:	1806913a 	slli	r3,r3,4
81135ca0:	1884b03a 	or	r2,r3,r2
81135ca4:	28800015 	stw	r2,0(r5)
81135ca8:	003fbc06 	br	81135b9c <__reset+0xfb115b9c>
81135cac:	2b7fff04 	addi	r13,r5,-4
81135cb0:	283fff15 	stw	zero,-4(r5)
81135cb4:	603f883a 	mov	ra,r12
81135cb8:	680b883a 	mov	r5,r13
81135cbc:	000f883a 	mov	r7,zero
81135cc0:	003fb606 	br	81135b9c <__reset+0xfb115b9c>
81135cc4:	00800a44 	movi	r2,41
81135cc8:	18801726 	beq	r3,r2,81135d28 <__hexnan+0x208>
81135ccc:	00800104 	movi	r2,4
81135cd0:	dfc00617 	ldw	ra,24(sp)
81135cd4:	dd400517 	ldw	r21,20(sp)
81135cd8:	dd000417 	ldw	r20,16(sp)
81135cdc:	dcc00317 	ldw	r19,12(sp)
81135ce0:	dc800217 	ldw	r18,8(sp)
81135ce4:	dc400117 	ldw	r17,4(sp)
81135ce8:	dc000017 	ldw	r16,0(sp)
81135cec:	dec00704 	addi	sp,sp,28
81135cf0:	f800283a 	ret
81135cf4:	903fd826 	beq	r18,zero,81135c58 <__reset+0xfb115c58>
81135cf8:	00c00804 	movi	r3,32
81135cfc:	1ca5c83a 	sub	r18,r3,r18
81135d00:	00ffffc4 	movi	r3,-1
81135d04:	78bfff17 	ldw	r2,-4(r15)
81135d08:	1c86d83a 	srl	r3,r3,r18
81135d0c:	1884703a 	and	r2,r3,r2
81135d10:	78bfff15 	stw	r2,-4(r15)
81135d14:	003fd106 	br	81135c5c <__reset+0xfb115c5c>
81135d18:	00800044 	movi	r2,1
81135d1c:	58800015 	stw	r2,0(r11)
81135d20:	00800144 	movi	r2,5
81135d24:	003fea06 	br	81135cd0 <__reset+0xfb115cd0>
81135d28:	42000044 	addi	r8,r8,1
81135d2c:	22000015 	stw	r8,0(r4)
81135d30:	603fbb1e 	bne	r12,zero,81135c20 <__reset+0xfb115c20>
81135d34:	003fe506 	br	81135ccc <__reset+0xfb115ccc>
81135d38:	02400204 	movi	r9,8
81135d3c:	49d3c83a 	sub	r9,r9,r7
81135d40:	4a53883a 	add	r9,r9,r9
81135d44:	2a000017 	ldw	r8,0(r5)
81135d48:	4a53883a 	add	r9,r9,r9
81135d4c:	02800804 	movi	r10,32
81135d50:	5255c83a 	sub	r10,r10,r9
81135d54:	28c00104 	addi	r3,r5,4
81135d58:	2805883a 	mov	r2,r5
81135d5c:	19c00017 	ldw	r7,0(r3)
81135d60:	10800104 	addi	r2,r2,4
81135d64:	18c00104 	addi	r3,r3,4
81135d68:	3a88983a 	sll	r4,r7,r10
81135d6c:	2208b03a 	or	r4,r4,r8
81135d70:	3a50d83a 	srl	r8,r7,r9
81135d74:	113fff15 	stw	r4,-4(r2)
81135d78:	1a3fff15 	stw	r8,-4(r3)
81135d7c:	137ff736 	bltu	r2,r13,81135d5c <__reset+0xfb115d5c>
81135d80:	003faa06 	br	81135c2c <__reset+0xfb115c2c>

81135d84 <strncmp>:
81135d84:	30003126 	beq	r6,zero,81135e4c <strncmp+0xc8>
81135d88:	2144b03a 	or	r2,r4,r5
81135d8c:	108000cc 	andi	r2,r2,3
81135d90:	10001e1e 	bne	r2,zero,81135e0c <strncmp+0x88>
81135d94:	024000c4 	movi	r9,3
81135d98:	49801c2e 	bgeu	r9,r6,81135e0c <strncmp+0x88>
81135d9c:	20800017 	ldw	r2,0(r4)
81135da0:	28c00017 	ldw	r3,0(r5)
81135da4:	10c0191e 	bne	r2,r3,81135e0c <strncmp+0x88>
81135da8:	31bfff04 	addi	r6,r6,-4
81135dac:	30002726 	beq	r6,zero,81135e4c <strncmp+0xc8>
81135db0:	02ffbff4 	movhi	r11,65279
81135db4:	5affbfc4 	addi	r11,r11,-257
81135db8:	0086303a 	nor	r3,zero,r2
81135dbc:	02a02074 	movhi	r10,32897
81135dc0:	12c5883a 	add	r2,r2,r11
81135dc4:	52a02004 	addi	r10,r10,-32640
81135dc8:	10c4703a 	and	r2,r2,r3
81135dcc:	1284703a 	and	r2,r2,r10
81135dd0:	10000b26 	beq	r2,zero,81135e00 <strncmp+0x7c>
81135dd4:	00001d06 	br	81135e4c <strncmp+0xc8>
81135dd8:	20c00017 	ldw	r3,0(r4)
81135ddc:	29c00017 	ldw	r7,0(r5)
81135de0:	1ad1883a 	add	r8,r3,r11
81135de4:	00c4303a 	nor	r2,zero,r3
81135de8:	4084703a 	and	r2,r8,r2
81135dec:	1284703a 	and	r2,r2,r10
81135df0:	19c0061e 	bne	r3,r7,81135e0c <strncmp+0x88>
81135df4:	31bfff04 	addi	r6,r6,-4
81135df8:	30001426 	beq	r6,zero,81135e4c <strncmp+0xc8>
81135dfc:	1000131e 	bne	r2,zero,81135e4c <strncmp+0xc8>
81135e00:	21000104 	addi	r4,r4,4
81135e04:	29400104 	addi	r5,r5,4
81135e08:	49bff336 	bltu	r9,r6,81135dd8 <__reset+0xfb115dd8>
81135e0c:	28800007 	ldb	r2,0(r5)
81135e10:	20c00007 	ldb	r3,0(r4)
81135e14:	31bfffc4 	addi	r6,r6,-1
81135e18:	10c0081e 	bne	r2,r3,81135e3c <strncmp+0xb8>
81135e1c:	30000b26 	beq	r6,zero,81135e4c <strncmp+0xc8>
81135e20:	10000a26 	beq	r2,zero,81135e4c <strncmp+0xc8>
81135e24:	21000044 	addi	r4,r4,1
81135e28:	29400044 	addi	r5,r5,1
81135e2c:	20800007 	ldb	r2,0(r4)
81135e30:	28c00007 	ldb	r3,0(r5)
81135e34:	31bfffc4 	addi	r6,r6,-1
81135e38:	10fff826 	beq	r2,r3,81135e1c <__reset+0xfb115e1c>
81135e3c:	20800003 	ldbu	r2,0(r4)
81135e40:	28c00003 	ldbu	r3,0(r5)
81135e44:	10c5c83a 	sub	r2,r2,r3
81135e48:	f800283a 	ret
81135e4c:	0005883a 	mov	r2,zero
81135e50:	f800283a 	ret

81135e54 <_wcrtomb_r>:
81135e54:	defff604 	addi	sp,sp,-40
81135e58:	00a04574 	movhi	r2,33045
81135e5c:	de00012e 	bgeu	sp,et,81135e64 <_wcrtomb_r+0x10>
81135e60:	003b68fa 	trap	3
81135e64:	10946104 	addi	r2,r2,20868
81135e68:	dc800815 	stw	r18,32(sp)
81135e6c:	dc400715 	stw	r17,28(sp)
81135e70:	dc000615 	stw	r16,24(sp)
81135e74:	dfc00915 	stw	ra,36(sp)
81135e78:	2021883a 	mov	r16,r4
81135e7c:	3823883a 	mov	r17,r7
81135e80:	14800017 	ldw	r18,0(r2)
81135e84:	28001426 	beq	r5,zero,81135ed8 <_wcrtomb_r+0x84>
81135e88:	d9400415 	stw	r5,16(sp)
81135e8c:	d9800515 	stw	r6,20(sp)
81135e90:	112e66c0 	call	8112e66c <__locale_charset>
81135e94:	d9800517 	ldw	r6,20(sp)
81135e98:	d9400417 	ldw	r5,16(sp)
81135e9c:	100f883a 	mov	r7,r2
81135ea0:	dc400015 	stw	r17,0(sp)
81135ea4:	8009883a 	mov	r4,r16
81135ea8:	903ee83a 	callr	r18
81135eac:	00ffffc4 	movi	r3,-1
81135eb0:	10c0031e 	bne	r2,r3,81135ec0 <_wcrtomb_r+0x6c>
81135eb4:	88000015 	stw	zero,0(r17)
81135eb8:	00c02284 	movi	r3,138
81135ebc:	80c00015 	stw	r3,0(r16)
81135ec0:	dfc00917 	ldw	ra,36(sp)
81135ec4:	dc800817 	ldw	r18,32(sp)
81135ec8:	dc400717 	ldw	r17,28(sp)
81135ecc:	dc000617 	ldw	r16,24(sp)
81135ed0:	dec00a04 	addi	sp,sp,40
81135ed4:	f800283a 	ret
81135ed8:	112e66c0 	call	8112e66c <__locale_charset>
81135edc:	100f883a 	mov	r7,r2
81135ee0:	dc400015 	stw	r17,0(sp)
81135ee4:	000d883a 	mov	r6,zero
81135ee8:	d9400104 	addi	r5,sp,4
81135eec:	8009883a 	mov	r4,r16
81135ef0:	903ee83a 	callr	r18
81135ef4:	003fed06 	br	81135eac <__reset+0xfb115eac>

81135ef8 <wcrtomb>:
81135ef8:	defff604 	addi	sp,sp,-40
81135efc:	00a04574 	movhi	r2,33045
81135f00:	de00012e 	bgeu	sp,et,81135f08 <wcrtomb+0x10>
81135f04:	003b68fa 	trap	3
81135f08:	10945c04 	addi	r2,r2,20848
81135f0c:	dc800615 	stw	r18,24(sp)
81135f10:	dc400515 	stw	r17,20(sp)
81135f14:	dfc00915 	stw	ra,36(sp)
81135f18:	dd000815 	stw	r20,32(sp)
81135f1c:	dcc00715 	stw	r19,28(sp)
81135f20:	dc000415 	stw	r16,16(sp)
81135f24:	3025883a 	mov	r18,r6
81135f28:	14400017 	ldw	r17,0(r2)
81135f2c:	20001926 	beq	r4,zero,81135f94 <wcrtomb+0x9c>
81135f30:	00a04574 	movhi	r2,33045
81135f34:	10946104 	addi	r2,r2,20868
81135f38:	15000017 	ldw	r20,0(r2)
81135f3c:	2021883a 	mov	r16,r4
81135f40:	2827883a 	mov	r19,r5
81135f44:	112e66c0 	call	8112e66c <__locale_charset>
81135f48:	100f883a 	mov	r7,r2
81135f4c:	dc800015 	stw	r18,0(sp)
81135f50:	980d883a 	mov	r6,r19
81135f54:	800b883a 	mov	r5,r16
81135f58:	8809883a 	mov	r4,r17
81135f5c:	a03ee83a 	callr	r20
81135f60:	00ffffc4 	movi	r3,-1
81135f64:	10c0031e 	bne	r2,r3,81135f74 <wcrtomb+0x7c>
81135f68:	90000015 	stw	zero,0(r18)
81135f6c:	00c02284 	movi	r3,138
81135f70:	88c00015 	stw	r3,0(r17)
81135f74:	dfc00917 	ldw	ra,36(sp)
81135f78:	dd000817 	ldw	r20,32(sp)
81135f7c:	dcc00717 	ldw	r19,28(sp)
81135f80:	dc800617 	ldw	r18,24(sp)
81135f84:	dc400517 	ldw	r17,20(sp)
81135f88:	dc000417 	ldw	r16,16(sp)
81135f8c:	dec00a04 	addi	sp,sp,40
81135f90:	f800283a 	ret
81135f94:	00a04574 	movhi	r2,33045
81135f98:	10946104 	addi	r2,r2,20868
81135f9c:	14000017 	ldw	r16,0(r2)
81135fa0:	112e66c0 	call	8112e66c <__locale_charset>
81135fa4:	100f883a 	mov	r7,r2
81135fa8:	dc800015 	stw	r18,0(sp)
81135fac:	000d883a 	mov	r6,zero
81135fb0:	d9400104 	addi	r5,sp,4
81135fb4:	8809883a 	mov	r4,r17
81135fb8:	803ee83a 	callr	r16
81135fbc:	003fe806 	br	81135f60 <__reset+0xfb115f60>

81135fc0 <__ascii_wctomb>:
81135fc0:	28000526 	beq	r5,zero,81135fd8 <__ascii_wctomb+0x18>
81135fc4:	00803fc4 	movi	r2,255
81135fc8:	11800536 	bltu	r2,r6,81135fe0 <__ascii_wctomb+0x20>
81135fcc:	29800005 	stb	r6,0(r5)
81135fd0:	00800044 	movi	r2,1
81135fd4:	f800283a 	ret
81135fd8:	0005883a 	mov	r2,zero
81135fdc:	f800283a 	ret
81135fe0:	00802284 	movi	r2,138
81135fe4:	20800015 	stw	r2,0(r4)
81135fe8:	00bfffc4 	movi	r2,-1
81135fec:	f800283a 	ret

81135ff0 <_wctomb_r>:
81135ff0:	00a04574 	movhi	r2,33045
81135ff4:	defff904 	addi	sp,sp,-28
81135ff8:	10946104 	addi	r2,r2,20868
81135ffc:	de00012e 	bgeu	sp,et,81136004 <_wctomb_r+0x14>
81136000:	003b68fa 	trap	3
81136004:	dfc00615 	stw	ra,24(sp)
81136008:	dc400515 	stw	r17,20(sp)
8113600c:	dc000415 	stw	r16,16(sp)
81136010:	3823883a 	mov	r17,r7
81136014:	14000017 	ldw	r16,0(r2)
81136018:	d9000115 	stw	r4,4(sp)
8113601c:	d9400215 	stw	r5,8(sp)
81136020:	d9800315 	stw	r6,12(sp)
81136024:	112e66c0 	call	8112e66c <__locale_charset>
81136028:	d9800317 	ldw	r6,12(sp)
8113602c:	d9400217 	ldw	r5,8(sp)
81136030:	d9000117 	ldw	r4,4(sp)
81136034:	100f883a 	mov	r7,r2
81136038:	dc400015 	stw	r17,0(sp)
8113603c:	803ee83a 	callr	r16
81136040:	dfc00617 	ldw	ra,24(sp)
81136044:	dc400517 	ldw	r17,20(sp)
81136048:	dc000417 	ldw	r16,16(sp)
8113604c:	dec00704 	addi	sp,sp,28
81136050:	f800283a 	ret

81136054 <__udivdi3>:
81136054:	defff504 	addi	sp,sp,-44
81136058:	de00012e 	bgeu	sp,et,81136060 <__udivdi3+0xc>
8113605c:	003b68fa 	trap	3
81136060:	dcc00415 	stw	r19,16(sp)
81136064:	dc000115 	stw	r16,4(sp)
81136068:	dfc00a15 	stw	ra,40(sp)
8113606c:	df000915 	stw	fp,36(sp)
81136070:	ddc00815 	stw	r23,32(sp)
81136074:	dd800715 	stw	r22,28(sp)
81136078:	dd400615 	stw	r21,24(sp)
8113607c:	dd000515 	stw	r20,20(sp)
81136080:	dc800315 	stw	r18,12(sp)
81136084:	dc400215 	stw	r17,8(sp)
81136088:	2027883a 	mov	r19,r4
8113608c:	2821883a 	mov	r16,r5
81136090:	3800411e 	bne	r7,zero,81136198 <__udivdi3+0x144>
81136094:	3023883a 	mov	r17,r6
81136098:	2025883a 	mov	r18,r4
8113609c:	2980522e 	bgeu	r5,r6,811361e8 <__udivdi3+0x194>
811360a0:	00bfffd4 	movui	r2,65535
811360a4:	282d883a 	mov	r22,r5
811360a8:	1180a836 	bltu	r2,r6,8113634c <__udivdi3+0x2f8>
811360ac:	00803fc4 	movi	r2,255
811360b0:	1185803a 	cmpltu	r2,r2,r6
811360b4:	100490fa 	slli	r2,r2,3
811360b8:	3086d83a 	srl	r3,r6,r2
811360bc:	01204574 	movhi	r4,33045
811360c0:	2109a104 	addi	r4,r4,9860
811360c4:	20c7883a 	add	r3,r4,r3
811360c8:	18c00003 	ldbu	r3,0(r3)
811360cc:	1885883a 	add	r2,r3,r2
811360d0:	00c00804 	movi	r3,32
811360d4:	1887c83a 	sub	r3,r3,r2
811360d8:	18000526 	beq	r3,zero,811360f0 <__udivdi3+0x9c>
811360dc:	80e0983a 	sll	r16,r16,r3
811360e0:	9884d83a 	srl	r2,r19,r2
811360e4:	30e2983a 	sll	r17,r6,r3
811360e8:	98e4983a 	sll	r18,r19,r3
811360ec:	142cb03a 	or	r22,r2,r16
811360f0:	882ad43a 	srli	r21,r17,16
811360f4:	b009883a 	mov	r4,r22
811360f8:	8d3fffcc 	andi	r20,r17,65535
811360fc:	a80b883a 	mov	r5,r21
81136100:	1136c700 	call	81136c70 <__umodsi3>
81136104:	b009883a 	mov	r4,r22
81136108:	a80b883a 	mov	r5,r21
8113610c:	1027883a 	mov	r19,r2
81136110:	1136c0c0 	call	81136c0c <__udivsi3>
81136114:	102d883a 	mov	r22,r2
81136118:	9826943a 	slli	r19,r19,16
8113611c:	9004d43a 	srli	r2,r18,16
81136120:	a5a1383a 	mul	r16,r20,r22
81136124:	14c4b03a 	or	r2,r2,r19
81136128:	1400052e 	bgeu	r2,r16,81136140 <__udivdi3+0xec>
8113612c:	1445883a 	add	r2,r2,r17
81136130:	b0ffffc4 	addi	r3,r22,-1
81136134:	14400136 	bltu	r2,r17,8113613c <__udivdi3+0xe8>
81136138:	14012336 	bltu	r2,r16,811365c8 <__udivdi3+0x574>
8113613c:	182d883a 	mov	r22,r3
81136140:	1421c83a 	sub	r16,r2,r16
81136144:	a80b883a 	mov	r5,r21
81136148:	8009883a 	mov	r4,r16
8113614c:	1136c700 	call	81136c70 <__umodsi3>
81136150:	1027883a 	mov	r19,r2
81136154:	a80b883a 	mov	r5,r21
81136158:	8009883a 	mov	r4,r16
8113615c:	1136c0c0 	call	81136c0c <__udivsi3>
81136160:	9826943a 	slli	r19,r19,16
81136164:	a0a9383a 	mul	r20,r20,r2
81136168:	94bfffcc 	andi	r18,r18,65535
8113616c:	94e4b03a 	or	r18,r18,r19
81136170:	9500052e 	bgeu	r18,r20,81136188 <__udivdi3+0x134>
81136174:	8ca5883a 	add	r18,r17,r18
81136178:	10ffffc4 	addi	r3,r2,-1
8113617c:	9440f136 	bltu	r18,r17,81136544 <__udivdi3+0x4f0>
81136180:	9500f02e 	bgeu	r18,r20,81136544 <__udivdi3+0x4f0>
81136184:	10bfff84 	addi	r2,r2,-2
81136188:	b00c943a 	slli	r6,r22,16
8113618c:	0007883a 	mov	r3,zero
81136190:	3084b03a 	or	r2,r6,r2
81136194:	00005906 	br	811362fc <__udivdi3+0x2a8>
81136198:	29c05636 	bltu	r5,r7,811362f4 <__udivdi3+0x2a0>
8113619c:	00bfffd4 	movui	r2,65535
811361a0:	11c0622e 	bgeu	r2,r7,8113632c <__udivdi3+0x2d8>
811361a4:	00804034 	movhi	r2,256
811361a8:	10bfffc4 	addi	r2,r2,-1
811361ac:	11c0ee36 	bltu	r2,r7,81136568 <__udivdi3+0x514>
811361b0:	00800404 	movi	r2,16
811361b4:	3886d83a 	srl	r3,r7,r2
811361b8:	01204574 	movhi	r4,33045
811361bc:	2109a104 	addi	r4,r4,9860
811361c0:	20c7883a 	add	r3,r4,r3
811361c4:	18c00003 	ldbu	r3,0(r3)
811361c8:	05400804 	movi	r21,32
811361cc:	1885883a 	add	r2,r3,r2
811361d0:	a8abc83a 	sub	r21,r21,r2
811361d4:	a800621e 	bne	r21,zero,81136360 <__udivdi3+0x30c>
811361d8:	3c00e936 	bltu	r7,r16,81136580 <__udivdi3+0x52c>
811361dc:	9985403a 	cmpgeu	r2,r19,r6
811361e0:	0007883a 	mov	r3,zero
811361e4:	00004506 	br	811362fc <__udivdi3+0x2a8>
811361e8:	3000041e 	bne	r6,zero,811361fc <__udivdi3+0x1a8>
811361ec:	000b883a 	mov	r5,zero
811361f0:	01000044 	movi	r4,1
811361f4:	1136c0c0 	call	81136c0c <__udivsi3>
811361f8:	1023883a 	mov	r17,r2
811361fc:	00bfffd4 	movui	r2,65535
81136200:	14404e2e 	bgeu	r2,r17,8113633c <__udivdi3+0x2e8>
81136204:	00804034 	movhi	r2,256
81136208:	10bfffc4 	addi	r2,r2,-1
8113620c:	1440d836 	bltu	r2,r17,81136570 <__udivdi3+0x51c>
81136210:	00800404 	movi	r2,16
81136214:	8886d83a 	srl	r3,r17,r2
81136218:	01204574 	movhi	r4,33045
8113621c:	2109a104 	addi	r4,r4,9860
81136220:	20c7883a 	add	r3,r4,r3
81136224:	18c00003 	ldbu	r3,0(r3)
81136228:	1885883a 	add	r2,r3,r2
8113622c:	00c00804 	movi	r3,32
81136230:	1887c83a 	sub	r3,r3,r2
81136234:	18008f1e 	bne	r3,zero,81136474 <__udivdi3+0x420>
81136238:	882ad43a 	srli	r21,r17,16
8113623c:	8461c83a 	sub	r16,r16,r17
81136240:	8d3fffcc 	andi	r20,r17,65535
81136244:	00c00044 	movi	r3,1
81136248:	8009883a 	mov	r4,r16
8113624c:	a80b883a 	mov	r5,r21
81136250:	d8c00015 	stw	r3,0(sp)
81136254:	1136c700 	call	81136c70 <__umodsi3>
81136258:	8009883a 	mov	r4,r16
8113625c:	a80b883a 	mov	r5,r21
81136260:	1027883a 	mov	r19,r2
81136264:	1136c0c0 	call	81136c0c <__udivsi3>
81136268:	9826943a 	slli	r19,r19,16
8113626c:	9008d43a 	srli	r4,r18,16
81136270:	1521383a 	mul	r16,r2,r20
81136274:	102d883a 	mov	r22,r2
81136278:	24c8b03a 	or	r4,r4,r19
8113627c:	d8c00017 	ldw	r3,0(sp)
81136280:	2400052e 	bgeu	r4,r16,81136298 <__udivdi3+0x244>
81136284:	2449883a 	add	r4,r4,r17
81136288:	b0bfffc4 	addi	r2,r22,-1
8113628c:	24400136 	bltu	r4,r17,81136294 <__udivdi3+0x240>
81136290:	2400ca36 	bltu	r4,r16,811365bc <__udivdi3+0x568>
81136294:	102d883a 	mov	r22,r2
81136298:	2421c83a 	sub	r16,r4,r16
8113629c:	a80b883a 	mov	r5,r21
811362a0:	8009883a 	mov	r4,r16
811362a4:	d8c00015 	stw	r3,0(sp)
811362a8:	1136c700 	call	81136c70 <__umodsi3>
811362ac:	1027883a 	mov	r19,r2
811362b0:	a80b883a 	mov	r5,r21
811362b4:	8009883a 	mov	r4,r16
811362b8:	1136c0c0 	call	81136c0c <__udivsi3>
811362bc:	9826943a 	slli	r19,r19,16
811362c0:	1529383a 	mul	r20,r2,r20
811362c4:	94bfffcc 	andi	r18,r18,65535
811362c8:	94e4b03a 	or	r18,r18,r19
811362cc:	d8c00017 	ldw	r3,0(sp)
811362d0:	9500052e 	bgeu	r18,r20,811362e8 <__udivdi3+0x294>
811362d4:	8ca5883a 	add	r18,r17,r18
811362d8:	113fffc4 	addi	r4,r2,-1
811362dc:	94409736 	bltu	r18,r17,8113653c <__udivdi3+0x4e8>
811362e0:	9500962e 	bgeu	r18,r20,8113653c <__udivdi3+0x4e8>
811362e4:	10bfff84 	addi	r2,r2,-2
811362e8:	b00c943a 	slli	r6,r22,16
811362ec:	3084b03a 	or	r2,r6,r2
811362f0:	00000206 	br	811362fc <__udivdi3+0x2a8>
811362f4:	0007883a 	mov	r3,zero
811362f8:	0005883a 	mov	r2,zero
811362fc:	dfc00a17 	ldw	ra,40(sp)
81136300:	df000917 	ldw	fp,36(sp)
81136304:	ddc00817 	ldw	r23,32(sp)
81136308:	dd800717 	ldw	r22,28(sp)
8113630c:	dd400617 	ldw	r21,24(sp)
81136310:	dd000517 	ldw	r20,20(sp)
81136314:	dcc00417 	ldw	r19,16(sp)
81136318:	dc800317 	ldw	r18,12(sp)
8113631c:	dc400217 	ldw	r17,8(sp)
81136320:	dc000117 	ldw	r16,4(sp)
81136324:	dec00b04 	addi	sp,sp,44
81136328:	f800283a 	ret
8113632c:	00803fc4 	movi	r2,255
81136330:	11c5803a 	cmpltu	r2,r2,r7
81136334:	100490fa 	slli	r2,r2,3
81136338:	003f9e06 	br	811361b4 <__reset+0xfb1161b4>
8113633c:	00803fc4 	movi	r2,255
81136340:	1445803a 	cmpltu	r2,r2,r17
81136344:	100490fa 	slli	r2,r2,3
81136348:	003fb206 	br	81136214 <__reset+0xfb116214>
8113634c:	00804034 	movhi	r2,256
81136350:	10bfffc4 	addi	r2,r2,-1
81136354:	11808836 	bltu	r2,r6,81136578 <__udivdi3+0x524>
81136358:	00800404 	movi	r2,16
8113635c:	003f5606 	br	811360b8 <__reset+0xfb1160b8>
81136360:	30aed83a 	srl	r23,r6,r2
81136364:	3d4e983a 	sll	r7,r7,r21
81136368:	80acd83a 	srl	r22,r16,r2
8113636c:	9884d83a 	srl	r2,r19,r2
81136370:	3deeb03a 	or	r23,r7,r23
81136374:	b824d43a 	srli	r18,r23,16
81136378:	8560983a 	sll	r16,r16,r21
8113637c:	b009883a 	mov	r4,r22
81136380:	900b883a 	mov	r5,r18
81136384:	3568983a 	sll	r20,r6,r21
81136388:	1420b03a 	or	r16,r2,r16
8113638c:	1136c700 	call	81136c70 <__umodsi3>
81136390:	b009883a 	mov	r4,r22
81136394:	900b883a 	mov	r5,r18
81136398:	1023883a 	mov	r17,r2
8113639c:	1136c0c0 	call	81136c0c <__udivsi3>
811363a0:	8808943a 	slli	r4,r17,16
811363a4:	bf3fffcc 	andi	fp,r23,65535
811363a8:	8006d43a 	srli	r3,r16,16
811363ac:	e0a3383a 	mul	r17,fp,r2
811363b0:	100d883a 	mov	r6,r2
811363b4:	1906b03a 	or	r3,r3,r4
811363b8:	1c40042e 	bgeu	r3,r17,811363cc <__udivdi3+0x378>
811363bc:	1dc7883a 	add	r3,r3,r23
811363c0:	10bfffc4 	addi	r2,r2,-1
811363c4:	1dc0752e 	bgeu	r3,r23,8113659c <__udivdi3+0x548>
811363c8:	100d883a 	mov	r6,r2
811363cc:	1c63c83a 	sub	r17,r3,r17
811363d0:	900b883a 	mov	r5,r18
811363d4:	8809883a 	mov	r4,r17
811363d8:	d9800015 	stw	r6,0(sp)
811363dc:	1136c700 	call	81136c70 <__umodsi3>
811363e0:	102d883a 	mov	r22,r2
811363e4:	8809883a 	mov	r4,r17
811363e8:	900b883a 	mov	r5,r18
811363ec:	1136c0c0 	call	81136c0c <__udivsi3>
811363f0:	b02c943a 	slli	r22,r22,16
811363f4:	e089383a 	mul	r4,fp,r2
811363f8:	843fffcc 	andi	r16,r16,65535
811363fc:	85a0b03a 	or	r16,r16,r22
81136400:	d9800017 	ldw	r6,0(sp)
81136404:	8100042e 	bgeu	r16,r4,81136418 <__udivdi3+0x3c4>
81136408:	85e1883a 	add	r16,r16,r23
8113640c:	10ffffc4 	addi	r3,r2,-1
81136410:	85c05e2e 	bgeu	r16,r23,8113658c <__udivdi3+0x538>
81136414:	1805883a 	mov	r2,r3
81136418:	300c943a 	slli	r6,r6,16
8113641c:	a17fffcc 	andi	r5,r20,65535
81136420:	a028d43a 	srli	r20,r20,16
81136424:	3084b03a 	or	r2,r6,r2
81136428:	10ffffcc 	andi	r3,r2,65535
8113642c:	100cd43a 	srli	r6,r2,16
81136430:	194f383a 	mul	r7,r3,r5
81136434:	1d07383a 	mul	r3,r3,r20
81136438:	314b383a 	mul	r5,r6,r5
8113643c:	3810d43a 	srli	r8,r7,16
81136440:	8121c83a 	sub	r16,r16,r4
81136444:	1947883a 	add	r3,r3,r5
81136448:	40c7883a 	add	r3,r8,r3
8113644c:	350d383a 	mul	r6,r6,r20
81136450:	1940022e 	bgeu	r3,r5,8113645c <__udivdi3+0x408>
81136454:	01000074 	movhi	r4,1
81136458:	310d883a 	add	r6,r6,r4
8113645c:	1828d43a 	srli	r20,r3,16
81136460:	a18d883a 	add	r6,r20,r6
81136464:	81803e36 	bltu	r16,r6,81136560 <__udivdi3+0x50c>
81136468:	81803826 	beq	r16,r6,8113654c <__udivdi3+0x4f8>
8113646c:	0007883a 	mov	r3,zero
81136470:	003fa206 	br	811362fc <__reset+0xfb1162fc>
81136474:	88e2983a 	sll	r17,r17,r3
81136478:	80a8d83a 	srl	r20,r16,r2
8113647c:	80e0983a 	sll	r16,r16,r3
81136480:	882ad43a 	srli	r21,r17,16
81136484:	9884d83a 	srl	r2,r19,r2
81136488:	a009883a 	mov	r4,r20
8113648c:	a80b883a 	mov	r5,r21
81136490:	142eb03a 	or	r23,r2,r16
81136494:	98e4983a 	sll	r18,r19,r3
81136498:	1136c700 	call	81136c70 <__umodsi3>
8113649c:	a009883a 	mov	r4,r20
811364a0:	a80b883a 	mov	r5,r21
811364a4:	1021883a 	mov	r16,r2
811364a8:	1136c0c0 	call	81136c0c <__udivsi3>
811364ac:	1039883a 	mov	fp,r2
811364b0:	8d3fffcc 	andi	r20,r17,65535
811364b4:	8020943a 	slli	r16,r16,16
811364b8:	b804d43a 	srli	r2,r23,16
811364bc:	a72d383a 	mul	r22,r20,fp
811364c0:	1404b03a 	or	r2,r2,r16
811364c4:	1580062e 	bgeu	r2,r22,811364e0 <__udivdi3+0x48c>
811364c8:	1445883a 	add	r2,r2,r17
811364cc:	e0ffffc4 	addi	r3,fp,-1
811364d0:	14403836 	bltu	r2,r17,811365b4 <__udivdi3+0x560>
811364d4:	1580372e 	bgeu	r2,r22,811365b4 <__udivdi3+0x560>
811364d8:	e73fff84 	addi	fp,fp,-2
811364dc:	1445883a 	add	r2,r2,r17
811364e0:	15adc83a 	sub	r22,r2,r22
811364e4:	a80b883a 	mov	r5,r21
811364e8:	b009883a 	mov	r4,r22
811364ec:	1136c700 	call	81136c70 <__umodsi3>
811364f0:	1027883a 	mov	r19,r2
811364f4:	b009883a 	mov	r4,r22
811364f8:	a80b883a 	mov	r5,r21
811364fc:	1136c0c0 	call	81136c0c <__udivsi3>
81136500:	9826943a 	slli	r19,r19,16
81136504:	a0a1383a 	mul	r16,r20,r2
81136508:	b93fffcc 	andi	r4,r23,65535
8113650c:	24c8b03a 	or	r4,r4,r19
81136510:	2400062e 	bgeu	r4,r16,8113652c <__udivdi3+0x4d8>
81136514:	2449883a 	add	r4,r4,r17
81136518:	10ffffc4 	addi	r3,r2,-1
8113651c:	24402336 	bltu	r4,r17,811365ac <__udivdi3+0x558>
81136520:	2400222e 	bgeu	r4,r16,811365ac <__udivdi3+0x558>
81136524:	10bfff84 	addi	r2,r2,-2
81136528:	2449883a 	add	r4,r4,r17
8113652c:	e038943a 	slli	fp,fp,16
81136530:	2421c83a 	sub	r16,r4,r16
81136534:	e086b03a 	or	r3,fp,r2
81136538:	003f4306 	br	81136248 <__reset+0xfb116248>
8113653c:	2005883a 	mov	r2,r4
81136540:	003f6906 	br	811362e8 <__reset+0xfb1162e8>
81136544:	1805883a 	mov	r2,r3
81136548:	003f0f06 	br	81136188 <__reset+0xfb116188>
8113654c:	1806943a 	slli	r3,r3,16
81136550:	9d66983a 	sll	r19,r19,r21
81136554:	39ffffcc 	andi	r7,r7,65535
81136558:	19c7883a 	add	r3,r3,r7
8113655c:	98ffc32e 	bgeu	r19,r3,8113646c <__reset+0xfb11646c>
81136560:	10bfffc4 	addi	r2,r2,-1
81136564:	003fc106 	br	8113646c <__reset+0xfb11646c>
81136568:	00800604 	movi	r2,24
8113656c:	003f1106 	br	811361b4 <__reset+0xfb1161b4>
81136570:	00800604 	movi	r2,24
81136574:	003f2706 	br	81136214 <__reset+0xfb116214>
81136578:	00800604 	movi	r2,24
8113657c:	003ece06 	br	811360b8 <__reset+0xfb1160b8>
81136580:	0007883a 	mov	r3,zero
81136584:	00800044 	movi	r2,1
81136588:	003f5c06 	br	811362fc <__reset+0xfb1162fc>
8113658c:	813fa12e 	bgeu	r16,r4,81136414 <__reset+0xfb116414>
81136590:	10bfff84 	addi	r2,r2,-2
81136594:	85e1883a 	add	r16,r16,r23
81136598:	003f9f06 	br	81136418 <__reset+0xfb116418>
8113659c:	1c7f8a2e 	bgeu	r3,r17,811363c8 <__reset+0xfb1163c8>
811365a0:	31bfff84 	addi	r6,r6,-2
811365a4:	1dc7883a 	add	r3,r3,r23
811365a8:	003f8806 	br	811363cc <__reset+0xfb1163cc>
811365ac:	1805883a 	mov	r2,r3
811365b0:	003fde06 	br	8113652c <__reset+0xfb11652c>
811365b4:	1839883a 	mov	fp,r3
811365b8:	003fc906 	br	811364e0 <__reset+0xfb1164e0>
811365bc:	b5bfff84 	addi	r22,r22,-2
811365c0:	2449883a 	add	r4,r4,r17
811365c4:	003f3406 	br	81136298 <__reset+0xfb116298>
811365c8:	b5bfff84 	addi	r22,r22,-2
811365cc:	1445883a 	add	r2,r2,r17
811365d0:	003edb06 	br	81136140 <__reset+0xfb116140>

811365d4 <__umoddi3>:
811365d4:	defff404 	addi	sp,sp,-48
811365d8:	de00012e 	bgeu	sp,et,811365e0 <__umoddi3+0xc>
811365dc:	003b68fa 	trap	3
811365e0:	df000a15 	stw	fp,40(sp)
811365e4:	dc400315 	stw	r17,12(sp)
811365e8:	dc000215 	stw	r16,8(sp)
811365ec:	dfc00b15 	stw	ra,44(sp)
811365f0:	ddc00915 	stw	r23,36(sp)
811365f4:	dd800815 	stw	r22,32(sp)
811365f8:	dd400715 	stw	r21,28(sp)
811365fc:	dd000615 	stw	r20,24(sp)
81136600:	dcc00515 	stw	r19,20(sp)
81136604:	dc800415 	stw	r18,16(sp)
81136608:	2021883a 	mov	r16,r4
8113660c:	2823883a 	mov	r17,r5
81136610:	2839883a 	mov	fp,r5
81136614:	38003c1e 	bne	r7,zero,81136708 <__umoddi3+0x134>
81136618:	3027883a 	mov	r19,r6
8113661c:	2029883a 	mov	r20,r4
81136620:	2980512e 	bgeu	r5,r6,81136768 <__umoddi3+0x194>
81136624:	00bfffd4 	movui	r2,65535
81136628:	11809a36 	bltu	r2,r6,81136894 <__umoddi3+0x2c0>
8113662c:	01003fc4 	movi	r4,255
81136630:	2189803a 	cmpltu	r4,r4,r6
81136634:	200890fa 	slli	r4,r4,3
81136638:	3104d83a 	srl	r2,r6,r4
8113663c:	00e04574 	movhi	r3,33045
81136640:	18c9a104 	addi	r3,r3,9860
81136644:	1885883a 	add	r2,r3,r2
81136648:	10c00003 	ldbu	r3,0(r2)
8113664c:	00800804 	movi	r2,32
81136650:	1909883a 	add	r4,r3,r4
81136654:	1125c83a 	sub	r18,r2,r4
81136658:	90000526 	beq	r18,zero,81136670 <__umoddi3+0x9c>
8113665c:	8ca2983a 	sll	r17,r17,r18
81136660:	8108d83a 	srl	r4,r16,r4
81136664:	34a6983a 	sll	r19,r6,r18
81136668:	84a8983a 	sll	r20,r16,r18
8113666c:	2478b03a 	or	fp,r4,r17
81136670:	982ed43a 	srli	r23,r19,16
81136674:	e009883a 	mov	r4,fp
81136678:	9dbfffcc 	andi	r22,r19,65535
8113667c:	b80b883a 	mov	r5,r23
81136680:	1136c700 	call	81136c70 <__umodsi3>
81136684:	e009883a 	mov	r4,fp
81136688:	b80b883a 	mov	r5,r23
8113668c:	102b883a 	mov	r21,r2
81136690:	1136c0c0 	call	81136c0c <__udivsi3>
81136694:	a806943a 	slli	r3,r21,16
81136698:	a008d43a 	srli	r4,r20,16
8113669c:	b085383a 	mul	r2,r22,r2
811366a0:	20c8b03a 	or	r4,r4,r3
811366a4:	2080032e 	bgeu	r4,r2,811366b4 <__umoddi3+0xe0>
811366a8:	24c9883a 	add	r4,r4,r19
811366ac:	24c00136 	bltu	r4,r19,811366b4 <__umoddi3+0xe0>
811366b0:	20811036 	bltu	r4,r2,81136af4 <__umoddi3+0x520>
811366b4:	20abc83a 	sub	r21,r4,r2
811366b8:	b80b883a 	mov	r5,r23
811366bc:	a809883a 	mov	r4,r21
811366c0:	1136c700 	call	81136c70 <__umodsi3>
811366c4:	1023883a 	mov	r17,r2
811366c8:	b80b883a 	mov	r5,r23
811366cc:	a809883a 	mov	r4,r21
811366d0:	1136c0c0 	call	81136c0c <__udivsi3>
811366d4:	8822943a 	slli	r17,r17,16
811366d8:	b085383a 	mul	r2,r22,r2
811366dc:	a0ffffcc 	andi	r3,r20,65535
811366e0:	1c46b03a 	or	r3,r3,r17
811366e4:	1880042e 	bgeu	r3,r2,811366f8 <__umoddi3+0x124>
811366e8:	1cc7883a 	add	r3,r3,r19
811366ec:	1cc00236 	bltu	r3,r19,811366f8 <__umoddi3+0x124>
811366f0:	1880012e 	bgeu	r3,r2,811366f8 <__umoddi3+0x124>
811366f4:	1cc7883a 	add	r3,r3,r19
811366f8:	1885c83a 	sub	r2,r3,r2
811366fc:	1484d83a 	srl	r2,r2,r18
81136700:	0007883a 	mov	r3,zero
81136704:	00004f06 	br	81136844 <__umoddi3+0x270>
81136708:	29c04c36 	bltu	r5,r7,8113683c <__umoddi3+0x268>
8113670c:	00bfffd4 	movui	r2,65535
81136710:	11c0582e 	bgeu	r2,r7,81136874 <__umoddi3+0x2a0>
81136714:	00804034 	movhi	r2,256
81136718:	10bfffc4 	addi	r2,r2,-1
8113671c:	11c0e736 	bltu	r2,r7,81136abc <__umoddi3+0x4e8>
81136720:	01000404 	movi	r4,16
81136724:	3904d83a 	srl	r2,r7,r4
81136728:	00e04574 	movhi	r3,33045
8113672c:	18c9a104 	addi	r3,r3,9860
81136730:	1885883a 	add	r2,r3,r2
81136734:	14c00003 	ldbu	r19,0(r2)
81136738:	00c00804 	movi	r3,32
8113673c:	9927883a 	add	r19,r19,r4
81136740:	1ce9c83a 	sub	r20,r3,r19
81136744:	a000581e 	bne	r20,zero,811368a8 <__umoddi3+0x2d4>
81136748:	3c400136 	bltu	r7,r17,81136750 <__umoddi3+0x17c>
8113674c:	8180eb36 	bltu	r16,r6,81136afc <__umoddi3+0x528>
81136750:	8185c83a 	sub	r2,r16,r6
81136754:	89e3c83a 	sub	r17,r17,r7
81136758:	8089803a 	cmpltu	r4,r16,r2
8113675c:	8939c83a 	sub	fp,r17,r4
81136760:	e007883a 	mov	r3,fp
81136764:	00003706 	br	81136844 <__umoddi3+0x270>
81136768:	3000041e 	bne	r6,zero,8113677c <__umoddi3+0x1a8>
8113676c:	000b883a 	mov	r5,zero
81136770:	01000044 	movi	r4,1
81136774:	1136c0c0 	call	81136c0c <__udivsi3>
81136778:	1027883a 	mov	r19,r2
8113677c:	00bfffd4 	movui	r2,65535
81136780:	14c0402e 	bgeu	r2,r19,81136884 <__umoddi3+0x2b0>
81136784:	00804034 	movhi	r2,256
81136788:	10bfffc4 	addi	r2,r2,-1
8113678c:	14c0cd36 	bltu	r2,r19,81136ac4 <__umoddi3+0x4f0>
81136790:	00800404 	movi	r2,16
81136794:	9886d83a 	srl	r3,r19,r2
81136798:	01204574 	movhi	r4,33045
8113679c:	2109a104 	addi	r4,r4,9860
811367a0:	20c7883a 	add	r3,r4,r3
811367a4:	18c00003 	ldbu	r3,0(r3)
811367a8:	1887883a 	add	r3,r3,r2
811367ac:	00800804 	movi	r2,32
811367b0:	10e5c83a 	sub	r18,r2,r3
811367b4:	9000901e 	bne	r18,zero,811369f8 <__umoddi3+0x424>
811367b8:	982cd43a 	srli	r22,r19,16
811367bc:	8ce3c83a 	sub	r17,r17,r19
811367c0:	9d7fffcc 	andi	r21,r19,65535
811367c4:	b00b883a 	mov	r5,r22
811367c8:	8809883a 	mov	r4,r17
811367cc:	1136c700 	call	81136c70 <__umodsi3>
811367d0:	8809883a 	mov	r4,r17
811367d4:	b00b883a 	mov	r5,r22
811367d8:	1021883a 	mov	r16,r2
811367dc:	1136c0c0 	call	81136c0c <__udivsi3>
811367e0:	8006943a 	slli	r3,r16,16
811367e4:	a008d43a 	srli	r4,r20,16
811367e8:	1545383a 	mul	r2,r2,r21
811367ec:	20c8b03a 	or	r4,r4,r3
811367f0:	2080042e 	bgeu	r4,r2,81136804 <__umoddi3+0x230>
811367f4:	24c9883a 	add	r4,r4,r19
811367f8:	24c00236 	bltu	r4,r19,81136804 <__umoddi3+0x230>
811367fc:	2080012e 	bgeu	r4,r2,81136804 <__umoddi3+0x230>
81136800:	24c9883a 	add	r4,r4,r19
81136804:	20a1c83a 	sub	r16,r4,r2
81136808:	b00b883a 	mov	r5,r22
8113680c:	8009883a 	mov	r4,r16
81136810:	1136c700 	call	81136c70 <__umodsi3>
81136814:	1023883a 	mov	r17,r2
81136818:	b00b883a 	mov	r5,r22
8113681c:	8009883a 	mov	r4,r16
81136820:	1136c0c0 	call	81136c0c <__udivsi3>
81136824:	8822943a 	slli	r17,r17,16
81136828:	1545383a 	mul	r2,r2,r21
8113682c:	a53fffcc 	andi	r20,r20,65535
81136830:	a446b03a 	or	r3,r20,r17
81136834:	18bfb02e 	bgeu	r3,r2,811366f8 <__reset+0xfb1166f8>
81136838:	003fab06 	br	811366e8 <__reset+0xfb1166e8>
8113683c:	2005883a 	mov	r2,r4
81136840:	2807883a 	mov	r3,r5
81136844:	dfc00b17 	ldw	ra,44(sp)
81136848:	df000a17 	ldw	fp,40(sp)
8113684c:	ddc00917 	ldw	r23,36(sp)
81136850:	dd800817 	ldw	r22,32(sp)
81136854:	dd400717 	ldw	r21,28(sp)
81136858:	dd000617 	ldw	r20,24(sp)
8113685c:	dcc00517 	ldw	r19,20(sp)
81136860:	dc800417 	ldw	r18,16(sp)
81136864:	dc400317 	ldw	r17,12(sp)
81136868:	dc000217 	ldw	r16,8(sp)
8113686c:	dec00c04 	addi	sp,sp,48
81136870:	f800283a 	ret
81136874:	04c03fc4 	movi	r19,255
81136878:	99c9803a 	cmpltu	r4,r19,r7
8113687c:	200890fa 	slli	r4,r4,3
81136880:	003fa806 	br	81136724 <__reset+0xfb116724>
81136884:	00803fc4 	movi	r2,255
81136888:	14c5803a 	cmpltu	r2,r2,r19
8113688c:	100490fa 	slli	r2,r2,3
81136890:	003fc006 	br	81136794 <__reset+0xfb116794>
81136894:	00804034 	movhi	r2,256
81136898:	10bfffc4 	addi	r2,r2,-1
8113689c:	11808b36 	bltu	r2,r6,81136acc <__umoddi3+0x4f8>
811368a0:	01000404 	movi	r4,16
811368a4:	003f6406 	br	81136638 <__reset+0xfb116638>
811368a8:	34c4d83a 	srl	r2,r6,r19
811368ac:	3d0e983a 	sll	r7,r7,r20
811368b0:	8cf8d83a 	srl	fp,r17,r19
811368b4:	8d10983a 	sll	r8,r17,r20
811368b8:	38aab03a 	or	r21,r7,r2
811368bc:	a82cd43a 	srli	r22,r21,16
811368c0:	84e2d83a 	srl	r17,r16,r19
811368c4:	e009883a 	mov	r4,fp
811368c8:	b00b883a 	mov	r5,r22
811368cc:	8a22b03a 	or	r17,r17,r8
811368d0:	3524983a 	sll	r18,r6,r20
811368d4:	1136c700 	call	81136c70 <__umodsi3>
811368d8:	e009883a 	mov	r4,fp
811368dc:	b00b883a 	mov	r5,r22
811368e0:	102f883a 	mov	r23,r2
811368e4:	1136c0c0 	call	81136c0c <__udivsi3>
811368e8:	100d883a 	mov	r6,r2
811368ec:	b808943a 	slli	r4,r23,16
811368f0:	aa3fffcc 	andi	r8,r21,65535
811368f4:	8804d43a 	srli	r2,r17,16
811368f8:	41af383a 	mul	r23,r8,r6
811368fc:	8520983a 	sll	r16,r16,r20
81136900:	1104b03a 	or	r2,r2,r4
81136904:	15c0042e 	bgeu	r2,r23,81136918 <__umoddi3+0x344>
81136908:	1545883a 	add	r2,r2,r21
8113690c:	30ffffc4 	addi	r3,r6,-1
81136910:	1540742e 	bgeu	r2,r21,81136ae4 <__umoddi3+0x510>
81136914:	180d883a 	mov	r6,r3
81136918:	15efc83a 	sub	r23,r2,r23
8113691c:	b00b883a 	mov	r5,r22
81136920:	b809883a 	mov	r4,r23
81136924:	d9800115 	stw	r6,4(sp)
81136928:	da000015 	stw	r8,0(sp)
8113692c:	1136c700 	call	81136c70 <__umodsi3>
81136930:	b00b883a 	mov	r5,r22
81136934:	b809883a 	mov	r4,r23
81136938:	1039883a 	mov	fp,r2
8113693c:	1136c0c0 	call	81136c0c <__udivsi3>
81136940:	da000017 	ldw	r8,0(sp)
81136944:	e038943a 	slli	fp,fp,16
81136948:	100b883a 	mov	r5,r2
8113694c:	4089383a 	mul	r4,r8,r2
81136950:	8a3fffcc 	andi	r8,r17,65535
81136954:	4710b03a 	or	r8,r8,fp
81136958:	d9800117 	ldw	r6,4(sp)
8113695c:	4100042e 	bgeu	r8,r4,81136970 <__umoddi3+0x39c>
81136960:	4551883a 	add	r8,r8,r21
81136964:	10bfffc4 	addi	r2,r2,-1
81136968:	45405a2e 	bgeu	r8,r21,81136ad4 <__umoddi3+0x500>
8113696c:	100b883a 	mov	r5,r2
81136970:	300c943a 	slli	r6,r6,16
81136974:	91ffffcc 	andi	r7,r18,65535
81136978:	9004d43a 	srli	r2,r18,16
8113697c:	314cb03a 	or	r6,r6,r5
81136980:	317fffcc 	andi	r5,r6,65535
81136984:	300cd43a 	srli	r6,r6,16
81136988:	29d3383a 	mul	r9,r5,r7
8113698c:	288b383a 	mul	r5,r5,r2
81136990:	31cf383a 	mul	r7,r6,r7
81136994:	4806d43a 	srli	r3,r9,16
81136998:	4111c83a 	sub	r8,r8,r4
8113699c:	29cb883a 	add	r5,r5,r7
811369a0:	194b883a 	add	r5,r3,r5
811369a4:	3085383a 	mul	r2,r6,r2
811369a8:	29c0022e 	bgeu	r5,r7,811369b4 <__umoddi3+0x3e0>
811369ac:	00c00074 	movhi	r3,1
811369b0:	10c5883a 	add	r2,r2,r3
811369b4:	2808d43a 	srli	r4,r5,16
811369b8:	280a943a 	slli	r5,r5,16
811369bc:	4a7fffcc 	andi	r9,r9,65535
811369c0:	2085883a 	add	r2,r4,r2
811369c4:	2a4b883a 	add	r5,r5,r9
811369c8:	40803636 	bltu	r8,r2,81136aa4 <__umoddi3+0x4d0>
811369cc:	40804d26 	beq	r8,r2,81136b04 <__umoddi3+0x530>
811369d0:	4089c83a 	sub	r4,r8,r2
811369d4:	280f883a 	mov	r7,r5
811369d8:	81cfc83a 	sub	r7,r16,r7
811369dc:	81c7803a 	cmpltu	r3,r16,r7
811369e0:	20c7c83a 	sub	r3,r4,r3
811369e4:	1cc4983a 	sll	r2,r3,r19
811369e8:	3d0ed83a 	srl	r7,r7,r20
811369ec:	1d06d83a 	srl	r3,r3,r20
811369f0:	11c4b03a 	or	r2,r2,r7
811369f4:	003f9306 	br	81136844 <__reset+0xfb116844>
811369f8:	9ca6983a 	sll	r19,r19,r18
811369fc:	88e8d83a 	srl	r20,r17,r3
81136a00:	80c4d83a 	srl	r2,r16,r3
81136a04:	982cd43a 	srli	r22,r19,16
81136a08:	8ca2983a 	sll	r17,r17,r18
81136a0c:	a009883a 	mov	r4,r20
81136a10:	b00b883a 	mov	r5,r22
81136a14:	1478b03a 	or	fp,r2,r17
81136a18:	1136c700 	call	81136c70 <__umodsi3>
81136a1c:	a009883a 	mov	r4,r20
81136a20:	b00b883a 	mov	r5,r22
81136a24:	1023883a 	mov	r17,r2
81136a28:	1136c0c0 	call	81136c0c <__udivsi3>
81136a2c:	9d7fffcc 	andi	r21,r19,65535
81136a30:	880a943a 	slli	r5,r17,16
81136a34:	e008d43a 	srli	r4,fp,16
81136a38:	a885383a 	mul	r2,r21,r2
81136a3c:	84a8983a 	sll	r20,r16,r18
81136a40:	2148b03a 	or	r4,r4,r5
81136a44:	2080042e 	bgeu	r4,r2,81136a58 <__umoddi3+0x484>
81136a48:	24c9883a 	add	r4,r4,r19
81136a4c:	24c00236 	bltu	r4,r19,81136a58 <__umoddi3+0x484>
81136a50:	2080012e 	bgeu	r4,r2,81136a58 <__umoddi3+0x484>
81136a54:	24c9883a 	add	r4,r4,r19
81136a58:	20a3c83a 	sub	r17,r4,r2
81136a5c:	b00b883a 	mov	r5,r22
81136a60:	8809883a 	mov	r4,r17
81136a64:	1136c700 	call	81136c70 <__umodsi3>
81136a68:	102f883a 	mov	r23,r2
81136a6c:	8809883a 	mov	r4,r17
81136a70:	b00b883a 	mov	r5,r22
81136a74:	1136c0c0 	call	81136c0c <__udivsi3>
81136a78:	b82e943a 	slli	r23,r23,16
81136a7c:	a885383a 	mul	r2,r21,r2
81136a80:	e13fffcc 	andi	r4,fp,65535
81136a84:	25c8b03a 	or	r4,r4,r23
81136a88:	2080042e 	bgeu	r4,r2,81136a9c <__umoddi3+0x4c8>
81136a8c:	24c9883a 	add	r4,r4,r19
81136a90:	24c00236 	bltu	r4,r19,81136a9c <__umoddi3+0x4c8>
81136a94:	2080012e 	bgeu	r4,r2,81136a9c <__umoddi3+0x4c8>
81136a98:	24c9883a 	add	r4,r4,r19
81136a9c:	20a3c83a 	sub	r17,r4,r2
81136aa0:	003f4806 	br	811367c4 <__reset+0xfb1167c4>
81136aa4:	2c8fc83a 	sub	r7,r5,r18
81136aa8:	1545c83a 	sub	r2,r2,r21
81136aac:	29cb803a 	cmpltu	r5,r5,r7
81136ab0:	1145c83a 	sub	r2,r2,r5
81136ab4:	4089c83a 	sub	r4,r8,r2
81136ab8:	003fc706 	br	811369d8 <__reset+0xfb1169d8>
81136abc:	01000604 	movi	r4,24
81136ac0:	003f1806 	br	81136724 <__reset+0xfb116724>
81136ac4:	00800604 	movi	r2,24
81136ac8:	003f3206 	br	81136794 <__reset+0xfb116794>
81136acc:	01000604 	movi	r4,24
81136ad0:	003ed906 	br	81136638 <__reset+0xfb116638>
81136ad4:	413fa52e 	bgeu	r8,r4,8113696c <__reset+0xfb11696c>
81136ad8:	297fff84 	addi	r5,r5,-2
81136adc:	4551883a 	add	r8,r8,r21
81136ae0:	003fa306 	br	81136970 <__reset+0xfb116970>
81136ae4:	15ff8b2e 	bgeu	r2,r23,81136914 <__reset+0xfb116914>
81136ae8:	31bfff84 	addi	r6,r6,-2
81136aec:	1545883a 	add	r2,r2,r21
81136af0:	003f8906 	br	81136918 <__reset+0xfb116918>
81136af4:	24c9883a 	add	r4,r4,r19
81136af8:	003eee06 	br	811366b4 <__reset+0xfb1166b4>
81136afc:	8005883a 	mov	r2,r16
81136b00:	003f1706 	br	81136760 <__reset+0xfb116760>
81136b04:	817fe736 	bltu	r16,r5,81136aa4 <__reset+0xfb116aa4>
81136b08:	280f883a 	mov	r7,r5
81136b0c:	0009883a 	mov	r4,zero
81136b10:	003fb106 	br	811369d8 <__reset+0xfb1169d8>

81136b14 <__divsi3>:
81136b14:	20001b16 	blt	r4,zero,81136b84 <__divsi3+0x70>
81136b18:	000f883a 	mov	r7,zero
81136b1c:	28001616 	blt	r5,zero,81136b78 <__divsi3+0x64>
81136b20:	200d883a 	mov	r6,r4
81136b24:	29001a2e 	bgeu	r5,r4,81136b90 <__divsi3+0x7c>
81136b28:	00800804 	movi	r2,32
81136b2c:	00c00044 	movi	r3,1
81136b30:	00000106 	br	81136b38 <__divsi3+0x24>
81136b34:	10000d26 	beq	r2,zero,81136b6c <__divsi3+0x58>
81136b38:	294b883a 	add	r5,r5,r5
81136b3c:	10bfffc4 	addi	r2,r2,-1
81136b40:	18c7883a 	add	r3,r3,r3
81136b44:	293ffb36 	bltu	r5,r4,81136b34 <__reset+0xfb116b34>
81136b48:	0005883a 	mov	r2,zero
81136b4c:	18000726 	beq	r3,zero,81136b6c <__divsi3+0x58>
81136b50:	0005883a 	mov	r2,zero
81136b54:	31400236 	bltu	r6,r5,81136b60 <__divsi3+0x4c>
81136b58:	314dc83a 	sub	r6,r6,r5
81136b5c:	10c4b03a 	or	r2,r2,r3
81136b60:	1806d07a 	srli	r3,r3,1
81136b64:	280ad07a 	srli	r5,r5,1
81136b68:	183ffa1e 	bne	r3,zero,81136b54 <__reset+0xfb116b54>
81136b6c:	38000126 	beq	r7,zero,81136b74 <__divsi3+0x60>
81136b70:	0085c83a 	sub	r2,zero,r2
81136b74:	f800283a 	ret
81136b78:	014bc83a 	sub	r5,zero,r5
81136b7c:	39c0005c 	xori	r7,r7,1
81136b80:	003fe706 	br	81136b20 <__reset+0xfb116b20>
81136b84:	0109c83a 	sub	r4,zero,r4
81136b88:	01c00044 	movi	r7,1
81136b8c:	003fe306 	br	81136b1c <__reset+0xfb116b1c>
81136b90:	00c00044 	movi	r3,1
81136b94:	003fee06 	br	81136b50 <__reset+0xfb116b50>

81136b98 <__modsi3>:
81136b98:	20001716 	blt	r4,zero,81136bf8 <__modsi3+0x60>
81136b9c:	000f883a 	mov	r7,zero
81136ba0:	2005883a 	mov	r2,r4
81136ba4:	28001216 	blt	r5,zero,81136bf0 <__modsi3+0x58>
81136ba8:	2900162e 	bgeu	r5,r4,81136c04 <__modsi3+0x6c>
81136bac:	01800804 	movi	r6,32
81136bb0:	00c00044 	movi	r3,1
81136bb4:	00000106 	br	81136bbc <__modsi3+0x24>
81136bb8:	30000a26 	beq	r6,zero,81136be4 <__modsi3+0x4c>
81136bbc:	294b883a 	add	r5,r5,r5
81136bc0:	31bfffc4 	addi	r6,r6,-1
81136bc4:	18c7883a 	add	r3,r3,r3
81136bc8:	293ffb36 	bltu	r5,r4,81136bb8 <__reset+0xfb116bb8>
81136bcc:	18000526 	beq	r3,zero,81136be4 <__modsi3+0x4c>
81136bd0:	1806d07a 	srli	r3,r3,1
81136bd4:	11400136 	bltu	r2,r5,81136bdc <__modsi3+0x44>
81136bd8:	1145c83a 	sub	r2,r2,r5
81136bdc:	280ad07a 	srli	r5,r5,1
81136be0:	183ffb1e 	bne	r3,zero,81136bd0 <__reset+0xfb116bd0>
81136be4:	38000126 	beq	r7,zero,81136bec <__modsi3+0x54>
81136be8:	0085c83a 	sub	r2,zero,r2
81136bec:	f800283a 	ret
81136bf0:	014bc83a 	sub	r5,zero,r5
81136bf4:	003fec06 	br	81136ba8 <__reset+0xfb116ba8>
81136bf8:	0109c83a 	sub	r4,zero,r4
81136bfc:	01c00044 	movi	r7,1
81136c00:	003fe706 	br	81136ba0 <__reset+0xfb116ba0>
81136c04:	00c00044 	movi	r3,1
81136c08:	003ff106 	br	81136bd0 <__reset+0xfb116bd0>

81136c0c <__udivsi3>:
81136c0c:	200d883a 	mov	r6,r4
81136c10:	2900152e 	bgeu	r5,r4,81136c68 <__udivsi3+0x5c>
81136c14:	28001416 	blt	r5,zero,81136c68 <__udivsi3+0x5c>
81136c18:	00800804 	movi	r2,32
81136c1c:	00c00044 	movi	r3,1
81136c20:	00000206 	br	81136c2c <__udivsi3+0x20>
81136c24:	10000e26 	beq	r2,zero,81136c60 <__udivsi3+0x54>
81136c28:	28000516 	blt	r5,zero,81136c40 <__udivsi3+0x34>
81136c2c:	294b883a 	add	r5,r5,r5
81136c30:	10bfffc4 	addi	r2,r2,-1
81136c34:	18c7883a 	add	r3,r3,r3
81136c38:	293ffa36 	bltu	r5,r4,81136c24 <__reset+0xfb116c24>
81136c3c:	18000826 	beq	r3,zero,81136c60 <__udivsi3+0x54>
81136c40:	0005883a 	mov	r2,zero
81136c44:	31400236 	bltu	r6,r5,81136c50 <__udivsi3+0x44>
81136c48:	314dc83a 	sub	r6,r6,r5
81136c4c:	10c4b03a 	or	r2,r2,r3
81136c50:	1806d07a 	srli	r3,r3,1
81136c54:	280ad07a 	srli	r5,r5,1
81136c58:	183ffa1e 	bne	r3,zero,81136c44 <__reset+0xfb116c44>
81136c5c:	f800283a 	ret
81136c60:	0005883a 	mov	r2,zero
81136c64:	f800283a 	ret
81136c68:	00c00044 	movi	r3,1
81136c6c:	003ff406 	br	81136c40 <__reset+0xfb116c40>

81136c70 <__umodsi3>:
81136c70:	2005883a 	mov	r2,r4
81136c74:	2900122e 	bgeu	r5,r4,81136cc0 <__umodsi3+0x50>
81136c78:	28001116 	blt	r5,zero,81136cc0 <__umodsi3+0x50>
81136c7c:	01800804 	movi	r6,32
81136c80:	00c00044 	movi	r3,1
81136c84:	00000206 	br	81136c90 <__umodsi3+0x20>
81136c88:	30000c26 	beq	r6,zero,81136cbc <__umodsi3+0x4c>
81136c8c:	28000516 	blt	r5,zero,81136ca4 <__umodsi3+0x34>
81136c90:	294b883a 	add	r5,r5,r5
81136c94:	31bfffc4 	addi	r6,r6,-1
81136c98:	18c7883a 	add	r3,r3,r3
81136c9c:	293ffa36 	bltu	r5,r4,81136c88 <__reset+0xfb116c88>
81136ca0:	18000626 	beq	r3,zero,81136cbc <__umodsi3+0x4c>
81136ca4:	1806d07a 	srli	r3,r3,1
81136ca8:	11400136 	bltu	r2,r5,81136cb0 <__umodsi3+0x40>
81136cac:	1145c83a 	sub	r2,r2,r5
81136cb0:	280ad07a 	srli	r5,r5,1
81136cb4:	183ffb1e 	bne	r3,zero,81136ca4 <__reset+0xfb116ca4>
81136cb8:	f800283a 	ret
81136cbc:	f800283a 	ret
81136cc0:	00c00044 	movi	r3,1
81136cc4:	003ff706 	br	81136ca4 <__reset+0xfb116ca4>

81136cc8 <__eqsf2>:
81136cc8:	2006d5fa 	srli	r3,r4,23
81136ccc:	280cd5fa 	srli	r6,r5,23
81136cd0:	01c02034 	movhi	r7,128
81136cd4:	39ffffc4 	addi	r7,r7,-1
81136cd8:	18c03fcc 	andi	r3,r3,255
81136cdc:	02003fc4 	movi	r8,255
81136ce0:	3904703a 	and	r2,r7,r4
81136ce4:	31803fcc 	andi	r6,r6,255
81136ce8:	394e703a 	and	r7,r7,r5
81136cec:	2008d7fa 	srli	r4,r4,31
81136cf0:	280ad7fa 	srli	r5,r5,31
81136cf4:	1a000d26 	beq	r3,r8,81136d2c <__eqsf2+0x64>
81136cf8:	02003fc4 	movi	r8,255
81136cfc:	32000826 	beq	r6,r8,81136d20 <__eqsf2+0x58>
81136d00:	19800226 	beq	r3,r6,81136d0c <__eqsf2+0x44>
81136d04:	00800044 	movi	r2,1
81136d08:	f800283a 	ret
81136d0c:	11fffd1e 	bne	r2,r7,81136d04 <__reset+0xfb116d04>
81136d10:	21400926 	beq	r4,r5,81136d38 <__eqsf2+0x70>
81136d14:	183ffb1e 	bne	r3,zero,81136d04 <__reset+0xfb116d04>
81136d18:	1004c03a 	cmpne	r2,r2,zero
81136d1c:	f800283a 	ret
81136d20:	383ff726 	beq	r7,zero,81136d00 <__reset+0xfb116d00>
81136d24:	00800044 	movi	r2,1
81136d28:	f800283a 	ret
81136d2c:	103ff226 	beq	r2,zero,81136cf8 <__reset+0xfb116cf8>
81136d30:	00800044 	movi	r2,1
81136d34:	f800283a 	ret
81136d38:	0005883a 	mov	r2,zero
81136d3c:	f800283a 	ret

81136d40 <__gesf2>:
81136d40:	2004d5fa 	srli	r2,r4,23
81136d44:	2806d5fa 	srli	r3,r5,23
81136d48:	01802034 	movhi	r6,128
81136d4c:	31bfffc4 	addi	r6,r6,-1
81136d50:	10803fcc 	andi	r2,r2,255
81136d54:	01c03fc4 	movi	r7,255
81136d58:	3110703a 	and	r8,r6,r4
81136d5c:	18c03fcc 	andi	r3,r3,255
81136d60:	314c703a 	and	r6,r6,r5
81136d64:	2008d7fa 	srli	r4,r4,31
81136d68:	280ad7fa 	srli	r5,r5,31
81136d6c:	11c01926 	beq	r2,r7,81136dd4 <__gesf2+0x94>
81136d70:	01c03fc4 	movi	r7,255
81136d74:	19c00f26 	beq	r3,r7,81136db4 <__gesf2+0x74>
81136d78:	1000061e 	bne	r2,zero,81136d94 <__gesf2+0x54>
81136d7c:	400f003a 	cmpeq	r7,r8,zero
81136d80:	1800071e 	bne	r3,zero,81136da0 <__gesf2+0x60>
81136d84:	3000061e 	bne	r6,zero,81136da0 <__gesf2+0x60>
81136d88:	0005883a 	mov	r2,zero
81136d8c:	40000e1e 	bne	r8,zero,81136dc8 <__gesf2+0x88>
81136d90:	f800283a 	ret
81136d94:	18000a1e 	bne	r3,zero,81136dc0 <__gesf2+0x80>
81136d98:	30000b26 	beq	r6,zero,81136dc8 <__gesf2+0x88>
81136d9c:	000f883a 	mov	r7,zero
81136da0:	29403fcc 	andi	r5,r5,255
81136da4:	38000726 	beq	r7,zero,81136dc4 <__gesf2+0x84>
81136da8:	28000826 	beq	r5,zero,81136dcc <__gesf2+0x8c>
81136dac:	00800044 	movi	r2,1
81136db0:	f800283a 	ret
81136db4:	303ff026 	beq	r6,zero,81136d78 <__reset+0xfb116d78>
81136db8:	00bfff84 	movi	r2,-2
81136dbc:	f800283a 	ret
81136dc0:	29403fcc 	andi	r5,r5,255
81136dc4:	21400526 	beq	r4,r5,81136ddc <__gesf2+0x9c>
81136dc8:	203ff826 	beq	r4,zero,81136dac <__reset+0xfb116dac>
81136dcc:	00bfffc4 	movi	r2,-1
81136dd0:	f800283a 	ret
81136dd4:	403fe626 	beq	r8,zero,81136d70 <__reset+0xfb116d70>
81136dd8:	003ff706 	br	81136db8 <__reset+0xfb116db8>
81136ddc:	18bffa16 	blt	r3,r2,81136dc8 <__reset+0xfb116dc8>
81136de0:	10c00216 	blt	r2,r3,81136dec <__gesf2+0xac>
81136de4:	323ff836 	bltu	r6,r8,81136dc8 <__reset+0xfb116dc8>
81136de8:	4180022e 	bgeu	r8,r6,81136df4 <__gesf2+0xb4>
81136dec:	203fef1e 	bne	r4,zero,81136dac <__reset+0xfb116dac>
81136df0:	003ff606 	br	81136dcc <__reset+0xfb116dcc>
81136df4:	0005883a 	mov	r2,zero
81136df8:	f800283a 	ret

81136dfc <__lesf2>:
81136dfc:	2004d5fa 	srli	r2,r4,23
81136e00:	280cd5fa 	srli	r6,r5,23
81136e04:	00c02034 	movhi	r3,128
81136e08:	18ffffc4 	addi	r3,r3,-1
81136e0c:	10803fcc 	andi	r2,r2,255
81136e10:	01c03fc4 	movi	r7,255
81136e14:	1910703a 	and	r8,r3,r4
81136e18:	31803fcc 	andi	r6,r6,255
81136e1c:	1946703a 	and	r3,r3,r5
81136e20:	2008d7fa 	srli	r4,r4,31
81136e24:	280ad7fa 	srli	r5,r5,31
81136e28:	11c01b26 	beq	r2,r7,81136e98 <__lesf2+0x9c>
81136e2c:	01c03fc4 	movi	r7,255
81136e30:	31c01126 	beq	r6,r7,81136e78 <__lesf2+0x7c>
81136e34:	1000071e 	bne	r2,zero,81136e54 <__lesf2+0x58>
81136e38:	400f003a 	cmpeq	r7,r8,zero
81136e3c:	21003fcc 	andi	r4,r4,255
81136e40:	3000081e 	bne	r6,zero,81136e64 <__lesf2+0x68>
81136e44:	1800071e 	bne	r3,zero,81136e64 <__lesf2+0x68>
81136e48:	0005883a 	mov	r2,zero
81136e4c:	40000f1e 	bne	r8,zero,81136e8c <__lesf2+0x90>
81136e50:	f800283a 	ret
81136e54:	21003fcc 	andi	r4,r4,255
81136e58:	30000a1e 	bne	r6,zero,81136e84 <__lesf2+0x88>
81136e5c:	18000b26 	beq	r3,zero,81136e8c <__lesf2+0x90>
81136e60:	000f883a 	mov	r7,zero
81136e64:	29403fcc 	andi	r5,r5,255
81136e68:	38000726 	beq	r7,zero,81136e88 <__lesf2+0x8c>
81136e6c:	28000826 	beq	r5,zero,81136e90 <__lesf2+0x94>
81136e70:	00800044 	movi	r2,1
81136e74:	f800283a 	ret
81136e78:	183fee26 	beq	r3,zero,81136e34 <__reset+0xfb116e34>
81136e7c:	00800084 	movi	r2,2
81136e80:	f800283a 	ret
81136e84:	29403fcc 	andi	r5,r5,255
81136e88:	21400626 	beq	r4,r5,81136ea4 <__lesf2+0xa8>
81136e8c:	203ff826 	beq	r4,zero,81136e70 <__reset+0xfb116e70>
81136e90:	00bfffc4 	movi	r2,-1
81136e94:	f800283a 	ret
81136e98:	403fe426 	beq	r8,zero,81136e2c <__reset+0xfb116e2c>
81136e9c:	00800084 	movi	r2,2
81136ea0:	f800283a 	ret
81136ea4:	30bff916 	blt	r6,r2,81136e8c <__reset+0xfb116e8c>
81136ea8:	11800216 	blt	r2,r6,81136eb4 <__lesf2+0xb8>
81136eac:	1a3ff736 	bltu	r3,r8,81136e8c <__reset+0xfb116e8c>
81136eb0:	40c0022e 	bgeu	r8,r3,81136ebc <__lesf2+0xc0>
81136eb4:	203fee1e 	bne	r4,zero,81136e70 <__reset+0xfb116e70>
81136eb8:	003ff506 	br	81136e90 <__reset+0xfb116e90>
81136ebc:	0005883a 	mov	r2,zero
81136ec0:	f800283a 	ret

81136ec4 <__adddf3>:
81136ec4:	02c00434 	movhi	r11,16
81136ec8:	5affffc4 	addi	r11,r11,-1
81136ecc:	2806d7fa 	srli	r3,r5,31
81136ed0:	2ad4703a 	and	r10,r5,r11
81136ed4:	3ad2703a 	and	r9,r7,r11
81136ed8:	3804d53a 	srli	r2,r7,20
81136edc:	3018d77a 	srli	r12,r6,29
81136ee0:	280ad53a 	srli	r5,r5,20
81136ee4:	501490fa 	slli	r10,r10,3
81136ee8:	2010d77a 	srli	r8,r4,29
81136eec:	481290fa 	slli	r9,r9,3
81136ef0:	380ed7fa 	srli	r7,r7,31
81136ef4:	defffb04 	addi	sp,sp,-20
81136ef8:	de00012e 	bgeu	sp,et,81136f00 <__adddf3+0x3c>
81136efc:	003b68fa 	trap	3
81136f00:	dc800215 	stw	r18,8(sp)
81136f04:	dc400115 	stw	r17,4(sp)
81136f08:	dc000015 	stw	r16,0(sp)
81136f0c:	dfc00415 	stw	ra,16(sp)
81136f10:	dcc00315 	stw	r19,12(sp)
81136f14:	1c803fcc 	andi	r18,r3,255
81136f18:	2c01ffcc 	andi	r16,r5,2047
81136f1c:	5210b03a 	or	r8,r10,r8
81136f20:	202290fa 	slli	r17,r4,3
81136f24:	1081ffcc 	andi	r2,r2,2047
81136f28:	4b12b03a 	or	r9,r9,r12
81136f2c:	300c90fa 	slli	r6,r6,3
81136f30:	91c07526 	beq	r18,r7,81137108 <__adddf3+0x244>
81136f34:	8087c83a 	sub	r3,r16,r2
81136f38:	00c0ab0e 	bge	zero,r3,811371e8 <__adddf3+0x324>
81136f3c:	10002a1e 	bne	r2,zero,81136fe8 <__adddf3+0x124>
81136f40:	4984b03a 	or	r2,r9,r6
81136f44:	1000961e 	bne	r2,zero,811371a0 <__adddf3+0x2dc>
81136f48:	888001cc 	andi	r2,r17,7
81136f4c:	10000726 	beq	r2,zero,81136f6c <__adddf3+0xa8>
81136f50:	888003cc 	andi	r2,r17,15
81136f54:	00c00104 	movi	r3,4
81136f58:	10c00426 	beq	r2,r3,81136f6c <__adddf3+0xa8>
81136f5c:	88c7883a 	add	r3,r17,r3
81136f60:	1c63803a 	cmpltu	r17,r3,r17
81136f64:	4451883a 	add	r8,r8,r17
81136f68:	1823883a 	mov	r17,r3
81136f6c:	4080202c 	andhi	r2,r8,128
81136f70:	10005926 	beq	r2,zero,811370d8 <__adddf3+0x214>
81136f74:	84000044 	addi	r16,r16,1
81136f78:	0081ffc4 	movi	r2,2047
81136f7c:	8080ba26 	beq	r16,r2,81137268 <__adddf3+0x3a4>
81136f80:	00bfe034 	movhi	r2,65408
81136f84:	10bfffc4 	addi	r2,r2,-1
81136f88:	4090703a 	and	r8,r8,r2
81136f8c:	4004977a 	slli	r2,r8,29
81136f90:	4010927a 	slli	r8,r8,9
81136f94:	8822d0fa 	srli	r17,r17,3
81136f98:	8401ffcc 	andi	r16,r16,2047
81136f9c:	4010d33a 	srli	r8,r8,12
81136fa0:	9007883a 	mov	r3,r18
81136fa4:	1444b03a 	or	r2,r2,r17
81136fa8:	8401ffcc 	andi	r16,r16,2047
81136fac:	8020953a 	slli	r16,r16,20
81136fb0:	18c03fcc 	andi	r3,r3,255
81136fb4:	01000434 	movhi	r4,16
81136fb8:	213fffc4 	addi	r4,r4,-1
81136fbc:	180697fa 	slli	r3,r3,31
81136fc0:	4110703a 	and	r8,r8,r4
81136fc4:	4410b03a 	or	r8,r8,r16
81136fc8:	40c6b03a 	or	r3,r8,r3
81136fcc:	dfc00417 	ldw	ra,16(sp)
81136fd0:	dcc00317 	ldw	r19,12(sp)
81136fd4:	dc800217 	ldw	r18,8(sp)
81136fd8:	dc400117 	ldw	r17,4(sp)
81136fdc:	dc000017 	ldw	r16,0(sp)
81136fe0:	dec00504 	addi	sp,sp,20
81136fe4:	f800283a 	ret
81136fe8:	0081ffc4 	movi	r2,2047
81136fec:	80bfd626 	beq	r16,r2,81136f48 <__reset+0xfb116f48>
81136ff0:	4a402034 	orhi	r9,r9,128
81136ff4:	00800e04 	movi	r2,56
81136ff8:	10c09f16 	blt	r2,r3,81137278 <__adddf3+0x3b4>
81136ffc:	008007c4 	movi	r2,31
81137000:	10c0c216 	blt	r2,r3,8113730c <__adddf3+0x448>
81137004:	00800804 	movi	r2,32
81137008:	10c5c83a 	sub	r2,r2,r3
8113700c:	488a983a 	sll	r5,r9,r2
81137010:	30c8d83a 	srl	r4,r6,r3
81137014:	3084983a 	sll	r2,r6,r2
81137018:	48c6d83a 	srl	r3,r9,r3
8113701c:	290cb03a 	or	r6,r5,r4
81137020:	1004c03a 	cmpne	r2,r2,zero
81137024:	308cb03a 	or	r6,r6,r2
81137028:	898dc83a 	sub	r6,r17,r6
8113702c:	89a3803a 	cmpltu	r17,r17,r6
81137030:	40d1c83a 	sub	r8,r8,r3
81137034:	4451c83a 	sub	r8,r8,r17
81137038:	3023883a 	mov	r17,r6
8113703c:	4080202c 	andhi	r2,r8,128
81137040:	10002326 	beq	r2,zero,811370d0 <__adddf3+0x20c>
81137044:	04c02034 	movhi	r19,128
81137048:	9cffffc4 	addi	r19,r19,-1
8113704c:	44e6703a 	and	r19,r8,r19
81137050:	98007626 	beq	r19,zero,8113722c <__adddf3+0x368>
81137054:	9809883a 	mov	r4,r19
81137058:	11234780 	call	81123478 <__clzsi2>
8113705c:	10fffe04 	addi	r3,r2,-8
81137060:	010007c4 	movi	r4,31
81137064:	20c07716 	blt	r4,r3,81137244 <__adddf3+0x380>
81137068:	00800804 	movi	r2,32
8113706c:	10c5c83a 	sub	r2,r2,r3
81137070:	8884d83a 	srl	r2,r17,r2
81137074:	98d0983a 	sll	r8,r19,r3
81137078:	88e2983a 	sll	r17,r17,r3
8113707c:	1204b03a 	or	r2,r2,r8
81137080:	1c007416 	blt	r3,r16,81137254 <__adddf3+0x390>
81137084:	1c21c83a 	sub	r16,r3,r16
81137088:	82000044 	addi	r8,r16,1
8113708c:	00c007c4 	movi	r3,31
81137090:	1a009116 	blt	r3,r8,811372d8 <__adddf3+0x414>
81137094:	00c00804 	movi	r3,32
81137098:	1a07c83a 	sub	r3,r3,r8
8113709c:	8a08d83a 	srl	r4,r17,r8
811370a0:	88e2983a 	sll	r17,r17,r3
811370a4:	10c6983a 	sll	r3,r2,r3
811370a8:	1210d83a 	srl	r8,r2,r8
811370ac:	8804c03a 	cmpne	r2,r17,zero
811370b0:	1906b03a 	or	r3,r3,r4
811370b4:	18a2b03a 	or	r17,r3,r2
811370b8:	0021883a 	mov	r16,zero
811370bc:	003fa206 	br	81136f48 <__reset+0xfb116f48>
811370c0:	1890b03a 	or	r8,r3,r2
811370c4:	40017d26 	beq	r8,zero,811376bc <__adddf3+0x7f8>
811370c8:	1011883a 	mov	r8,r2
811370cc:	1823883a 	mov	r17,r3
811370d0:	888001cc 	andi	r2,r17,7
811370d4:	103f9e1e 	bne	r2,zero,81136f50 <__reset+0xfb116f50>
811370d8:	4004977a 	slli	r2,r8,29
811370dc:	8822d0fa 	srli	r17,r17,3
811370e0:	4010d0fa 	srli	r8,r8,3
811370e4:	9007883a 	mov	r3,r18
811370e8:	1444b03a 	or	r2,r2,r17
811370ec:	0101ffc4 	movi	r4,2047
811370f0:	81002426 	beq	r16,r4,81137184 <__adddf3+0x2c0>
811370f4:	8120703a 	and	r16,r16,r4
811370f8:	01000434 	movhi	r4,16
811370fc:	213fffc4 	addi	r4,r4,-1
81137100:	4110703a 	and	r8,r8,r4
81137104:	003fa806 	br	81136fa8 <__reset+0xfb116fa8>
81137108:	8089c83a 	sub	r4,r16,r2
8113710c:	01005e0e 	bge	zero,r4,81137288 <__adddf3+0x3c4>
81137110:	10002b26 	beq	r2,zero,811371c0 <__adddf3+0x2fc>
81137114:	0081ffc4 	movi	r2,2047
81137118:	80bf8b26 	beq	r16,r2,81136f48 <__reset+0xfb116f48>
8113711c:	4a402034 	orhi	r9,r9,128
81137120:	00800e04 	movi	r2,56
81137124:	1100a40e 	bge	r2,r4,811373b8 <__adddf3+0x4f4>
81137128:	498cb03a 	or	r6,r9,r6
8113712c:	300ac03a 	cmpne	r5,r6,zero
81137130:	0013883a 	mov	r9,zero
81137134:	2c4b883a 	add	r5,r5,r17
81137138:	2c63803a 	cmpltu	r17,r5,r17
8113713c:	4a11883a 	add	r8,r9,r8
81137140:	8a11883a 	add	r8,r17,r8
81137144:	2823883a 	mov	r17,r5
81137148:	4080202c 	andhi	r2,r8,128
8113714c:	103fe026 	beq	r2,zero,811370d0 <__reset+0xfb1170d0>
81137150:	84000044 	addi	r16,r16,1
81137154:	0081ffc4 	movi	r2,2047
81137158:	8080d226 	beq	r16,r2,811374a4 <__adddf3+0x5e0>
8113715c:	00bfe034 	movhi	r2,65408
81137160:	10bfffc4 	addi	r2,r2,-1
81137164:	4090703a 	and	r8,r8,r2
81137168:	880ad07a 	srli	r5,r17,1
8113716c:	400897fa 	slli	r4,r8,31
81137170:	88c0004c 	andi	r3,r17,1
81137174:	28e2b03a 	or	r17,r5,r3
81137178:	4010d07a 	srli	r8,r8,1
8113717c:	2462b03a 	or	r17,r4,r17
81137180:	003f7106 	br	81136f48 <__reset+0xfb116f48>
81137184:	4088b03a 	or	r4,r8,r2
81137188:	20014526 	beq	r4,zero,811376a0 <__adddf3+0x7dc>
8113718c:	01000434 	movhi	r4,16
81137190:	42000234 	orhi	r8,r8,8
81137194:	213fffc4 	addi	r4,r4,-1
81137198:	4110703a 	and	r8,r8,r4
8113719c:	003f8206 	br	81136fa8 <__reset+0xfb116fa8>
811371a0:	18ffffc4 	addi	r3,r3,-1
811371a4:	1800491e 	bne	r3,zero,811372cc <__adddf3+0x408>
811371a8:	898bc83a 	sub	r5,r17,r6
811371ac:	8963803a 	cmpltu	r17,r17,r5
811371b0:	4251c83a 	sub	r8,r8,r9
811371b4:	4451c83a 	sub	r8,r8,r17
811371b8:	2823883a 	mov	r17,r5
811371bc:	003f9f06 	br	8113703c <__reset+0xfb11703c>
811371c0:	4984b03a 	or	r2,r9,r6
811371c4:	103f6026 	beq	r2,zero,81136f48 <__reset+0xfb116f48>
811371c8:	213fffc4 	addi	r4,r4,-1
811371cc:	2000931e 	bne	r4,zero,8113741c <__adddf3+0x558>
811371d0:	898d883a 	add	r6,r17,r6
811371d4:	3463803a 	cmpltu	r17,r6,r17
811371d8:	4251883a 	add	r8,r8,r9
811371dc:	8a11883a 	add	r8,r17,r8
811371e0:	3023883a 	mov	r17,r6
811371e4:	003fd806 	br	81137148 <__reset+0xfb117148>
811371e8:	1800541e 	bne	r3,zero,8113733c <__adddf3+0x478>
811371ec:	80800044 	addi	r2,r16,1
811371f0:	1081ffcc 	andi	r2,r2,2047
811371f4:	00c00044 	movi	r3,1
811371f8:	1880a00e 	bge	r3,r2,8113747c <__adddf3+0x5b8>
811371fc:	8989c83a 	sub	r4,r17,r6
81137200:	8905803a 	cmpltu	r2,r17,r4
81137204:	4267c83a 	sub	r19,r8,r9
81137208:	98a7c83a 	sub	r19,r19,r2
8113720c:	9880202c 	andhi	r2,r19,128
81137210:	10006326 	beq	r2,zero,811373a0 <__adddf3+0x4dc>
81137214:	3463c83a 	sub	r17,r6,r17
81137218:	4a07c83a 	sub	r3,r9,r8
8113721c:	344d803a 	cmpltu	r6,r6,r17
81137220:	19a7c83a 	sub	r19,r3,r6
81137224:	3825883a 	mov	r18,r7
81137228:	983f8a1e 	bne	r19,zero,81137054 <__reset+0xfb117054>
8113722c:	8809883a 	mov	r4,r17
81137230:	11234780 	call	81123478 <__clzsi2>
81137234:	10800804 	addi	r2,r2,32
81137238:	10fffe04 	addi	r3,r2,-8
8113723c:	010007c4 	movi	r4,31
81137240:	20ff890e 	bge	r4,r3,81137068 <__reset+0xfb117068>
81137244:	10bff604 	addi	r2,r2,-40
81137248:	8884983a 	sll	r2,r17,r2
8113724c:	0023883a 	mov	r17,zero
81137250:	1c3f8c0e 	bge	r3,r16,81137084 <__reset+0xfb117084>
81137254:	023fe034 	movhi	r8,65408
81137258:	423fffc4 	addi	r8,r8,-1
8113725c:	80e1c83a 	sub	r16,r16,r3
81137260:	1210703a 	and	r8,r2,r8
81137264:	003f3806 	br	81136f48 <__reset+0xfb116f48>
81137268:	9007883a 	mov	r3,r18
8113726c:	0011883a 	mov	r8,zero
81137270:	0005883a 	mov	r2,zero
81137274:	003f4c06 	br	81136fa8 <__reset+0xfb116fa8>
81137278:	498cb03a 	or	r6,r9,r6
8113727c:	300cc03a 	cmpne	r6,r6,zero
81137280:	0007883a 	mov	r3,zero
81137284:	003f6806 	br	81137028 <__reset+0xfb117028>
81137288:	20009c1e 	bne	r4,zero,811374fc <__adddf3+0x638>
8113728c:	80800044 	addi	r2,r16,1
81137290:	1141ffcc 	andi	r5,r2,2047
81137294:	01000044 	movi	r4,1
81137298:	2140670e 	bge	r4,r5,81137438 <__adddf3+0x574>
8113729c:	0101ffc4 	movi	r4,2047
811372a0:	11007f26 	beq	r2,r4,811374a0 <__adddf3+0x5dc>
811372a4:	898d883a 	add	r6,r17,r6
811372a8:	4247883a 	add	r3,r8,r9
811372ac:	3451803a 	cmpltu	r8,r6,r17
811372b0:	40d1883a 	add	r8,r8,r3
811372b4:	402297fa 	slli	r17,r8,31
811372b8:	300cd07a 	srli	r6,r6,1
811372bc:	4010d07a 	srli	r8,r8,1
811372c0:	1021883a 	mov	r16,r2
811372c4:	89a2b03a 	or	r17,r17,r6
811372c8:	003f1f06 	br	81136f48 <__reset+0xfb116f48>
811372cc:	0081ffc4 	movi	r2,2047
811372d0:	80bf481e 	bne	r16,r2,81136ff4 <__reset+0xfb116ff4>
811372d4:	003f1c06 	br	81136f48 <__reset+0xfb116f48>
811372d8:	843ff844 	addi	r16,r16,-31
811372dc:	01000804 	movi	r4,32
811372e0:	1406d83a 	srl	r3,r2,r16
811372e4:	41005026 	beq	r8,r4,81137428 <__adddf3+0x564>
811372e8:	01001004 	movi	r4,64
811372ec:	2211c83a 	sub	r8,r4,r8
811372f0:	1204983a 	sll	r2,r2,r8
811372f4:	88a2b03a 	or	r17,r17,r2
811372f8:	8822c03a 	cmpne	r17,r17,zero
811372fc:	1c62b03a 	or	r17,r3,r17
81137300:	0011883a 	mov	r8,zero
81137304:	0021883a 	mov	r16,zero
81137308:	003f7106 	br	811370d0 <__reset+0xfb1170d0>
8113730c:	193ff804 	addi	r4,r3,-32
81137310:	00800804 	movi	r2,32
81137314:	4908d83a 	srl	r4,r9,r4
81137318:	18804526 	beq	r3,r2,81137430 <__adddf3+0x56c>
8113731c:	00801004 	movi	r2,64
81137320:	10c5c83a 	sub	r2,r2,r3
81137324:	4886983a 	sll	r3,r9,r2
81137328:	198cb03a 	or	r6,r3,r6
8113732c:	300cc03a 	cmpne	r6,r6,zero
81137330:	218cb03a 	or	r6,r4,r6
81137334:	0007883a 	mov	r3,zero
81137338:	003f3b06 	br	81137028 <__reset+0xfb117028>
8113733c:	80002a26 	beq	r16,zero,811373e8 <__adddf3+0x524>
81137340:	0101ffc4 	movi	r4,2047
81137344:	11006826 	beq	r2,r4,811374e8 <__adddf3+0x624>
81137348:	00c7c83a 	sub	r3,zero,r3
8113734c:	42002034 	orhi	r8,r8,128
81137350:	01000e04 	movi	r4,56
81137354:	20c07c16 	blt	r4,r3,81137548 <__adddf3+0x684>
81137358:	010007c4 	movi	r4,31
8113735c:	20c0da16 	blt	r4,r3,811376c8 <__adddf3+0x804>
81137360:	01000804 	movi	r4,32
81137364:	20c9c83a 	sub	r4,r4,r3
81137368:	4114983a 	sll	r10,r8,r4
8113736c:	88cad83a 	srl	r5,r17,r3
81137370:	8908983a 	sll	r4,r17,r4
81137374:	40c6d83a 	srl	r3,r8,r3
81137378:	5162b03a 	or	r17,r10,r5
8113737c:	2008c03a 	cmpne	r4,r4,zero
81137380:	8922b03a 	or	r17,r17,r4
81137384:	3463c83a 	sub	r17,r6,r17
81137388:	48c7c83a 	sub	r3,r9,r3
8113738c:	344d803a 	cmpltu	r6,r6,r17
81137390:	1991c83a 	sub	r8,r3,r6
81137394:	1021883a 	mov	r16,r2
81137398:	3825883a 	mov	r18,r7
8113739c:	003f2706 	br	8113703c <__reset+0xfb11703c>
811373a0:	24d0b03a 	or	r8,r4,r19
811373a4:	40001b1e 	bne	r8,zero,81137414 <__adddf3+0x550>
811373a8:	0005883a 	mov	r2,zero
811373ac:	0007883a 	mov	r3,zero
811373b0:	0021883a 	mov	r16,zero
811373b4:	003f4d06 	br	811370ec <__reset+0xfb1170ec>
811373b8:	008007c4 	movi	r2,31
811373bc:	11003c16 	blt	r2,r4,811374b0 <__adddf3+0x5ec>
811373c0:	00800804 	movi	r2,32
811373c4:	1105c83a 	sub	r2,r2,r4
811373c8:	488e983a 	sll	r7,r9,r2
811373cc:	310ad83a 	srl	r5,r6,r4
811373d0:	3084983a 	sll	r2,r6,r2
811373d4:	4912d83a 	srl	r9,r9,r4
811373d8:	394ab03a 	or	r5,r7,r5
811373dc:	1004c03a 	cmpne	r2,r2,zero
811373e0:	288ab03a 	or	r5,r5,r2
811373e4:	003f5306 	br	81137134 <__reset+0xfb117134>
811373e8:	4448b03a 	or	r4,r8,r17
811373ec:	20003e26 	beq	r4,zero,811374e8 <__adddf3+0x624>
811373f0:	00c6303a 	nor	r3,zero,r3
811373f4:	18003a1e 	bne	r3,zero,811374e0 <__adddf3+0x61c>
811373f8:	3463c83a 	sub	r17,r6,r17
811373fc:	4a07c83a 	sub	r3,r9,r8
81137400:	344d803a 	cmpltu	r6,r6,r17
81137404:	1991c83a 	sub	r8,r3,r6
81137408:	1021883a 	mov	r16,r2
8113740c:	3825883a 	mov	r18,r7
81137410:	003f0a06 	br	8113703c <__reset+0xfb11703c>
81137414:	2023883a 	mov	r17,r4
81137418:	003f0d06 	br	81137050 <__reset+0xfb117050>
8113741c:	0081ffc4 	movi	r2,2047
81137420:	80bf3f1e 	bne	r16,r2,81137120 <__reset+0xfb117120>
81137424:	003ec806 	br	81136f48 <__reset+0xfb116f48>
81137428:	0005883a 	mov	r2,zero
8113742c:	003fb106 	br	811372f4 <__reset+0xfb1172f4>
81137430:	0007883a 	mov	r3,zero
81137434:	003fbc06 	br	81137328 <__reset+0xfb117328>
81137438:	4444b03a 	or	r2,r8,r17
8113743c:	8000871e 	bne	r16,zero,8113765c <__adddf3+0x798>
81137440:	1000ba26 	beq	r2,zero,8113772c <__adddf3+0x868>
81137444:	4984b03a 	or	r2,r9,r6
81137448:	103ebf26 	beq	r2,zero,81136f48 <__reset+0xfb116f48>
8113744c:	8985883a 	add	r2,r17,r6
81137450:	4247883a 	add	r3,r8,r9
81137454:	1451803a 	cmpltu	r8,r2,r17
81137458:	40d1883a 	add	r8,r8,r3
8113745c:	40c0202c 	andhi	r3,r8,128
81137460:	1023883a 	mov	r17,r2
81137464:	183f1a26 	beq	r3,zero,811370d0 <__reset+0xfb1170d0>
81137468:	00bfe034 	movhi	r2,65408
8113746c:	10bfffc4 	addi	r2,r2,-1
81137470:	2021883a 	mov	r16,r4
81137474:	4090703a 	and	r8,r8,r2
81137478:	003eb306 	br	81136f48 <__reset+0xfb116f48>
8113747c:	4444b03a 	or	r2,r8,r17
81137480:	8000291e 	bne	r16,zero,81137528 <__adddf3+0x664>
81137484:	10004b1e 	bne	r2,zero,811375b4 <__adddf3+0x6f0>
81137488:	4990b03a 	or	r8,r9,r6
8113748c:	40008b26 	beq	r8,zero,811376bc <__adddf3+0x7f8>
81137490:	4811883a 	mov	r8,r9
81137494:	3023883a 	mov	r17,r6
81137498:	3825883a 	mov	r18,r7
8113749c:	003eaa06 	br	81136f48 <__reset+0xfb116f48>
811374a0:	1021883a 	mov	r16,r2
811374a4:	0011883a 	mov	r8,zero
811374a8:	0005883a 	mov	r2,zero
811374ac:	003f0f06 	br	811370ec <__reset+0xfb1170ec>
811374b0:	217ff804 	addi	r5,r4,-32
811374b4:	00800804 	movi	r2,32
811374b8:	494ad83a 	srl	r5,r9,r5
811374bc:	20807d26 	beq	r4,r2,811376b4 <__adddf3+0x7f0>
811374c0:	00801004 	movi	r2,64
811374c4:	1109c83a 	sub	r4,r2,r4
811374c8:	4912983a 	sll	r9,r9,r4
811374cc:	498cb03a 	or	r6,r9,r6
811374d0:	300cc03a 	cmpne	r6,r6,zero
811374d4:	298ab03a 	or	r5,r5,r6
811374d8:	0013883a 	mov	r9,zero
811374dc:	003f1506 	br	81137134 <__reset+0xfb117134>
811374e0:	0101ffc4 	movi	r4,2047
811374e4:	113f9a1e 	bne	r2,r4,81137350 <__reset+0xfb117350>
811374e8:	4811883a 	mov	r8,r9
811374ec:	3023883a 	mov	r17,r6
811374f0:	1021883a 	mov	r16,r2
811374f4:	3825883a 	mov	r18,r7
811374f8:	003e9306 	br	81136f48 <__reset+0xfb116f48>
811374fc:	8000161e 	bne	r16,zero,81137558 <__adddf3+0x694>
81137500:	444ab03a 	or	r5,r8,r17
81137504:	28005126 	beq	r5,zero,8113764c <__adddf3+0x788>
81137508:	0108303a 	nor	r4,zero,r4
8113750c:	20004d1e 	bne	r4,zero,81137644 <__adddf3+0x780>
81137510:	89a3883a 	add	r17,r17,r6
81137514:	4253883a 	add	r9,r8,r9
81137518:	898d803a 	cmpltu	r6,r17,r6
8113751c:	3251883a 	add	r8,r6,r9
81137520:	1021883a 	mov	r16,r2
81137524:	003f0806 	br	81137148 <__reset+0xfb117148>
81137528:	1000301e 	bne	r2,zero,811375ec <__adddf3+0x728>
8113752c:	4984b03a 	or	r2,r9,r6
81137530:	10007126 	beq	r2,zero,811376f8 <__adddf3+0x834>
81137534:	4811883a 	mov	r8,r9
81137538:	3023883a 	mov	r17,r6
8113753c:	3825883a 	mov	r18,r7
81137540:	0401ffc4 	movi	r16,2047
81137544:	003e8006 	br	81136f48 <__reset+0xfb116f48>
81137548:	4462b03a 	or	r17,r8,r17
8113754c:	8822c03a 	cmpne	r17,r17,zero
81137550:	0007883a 	mov	r3,zero
81137554:	003f8b06 	br	81137384 <__reset+0xfb117384>
81137558:	0141ffc4 	movi	r5,2047
8113755c:	11403b26 	beq	r2,r5,8113764c <__adddf3+0x788>
81137560:	0109c83a 	sub	r4,zero,r4
81137564:	42002034 	orhi	r8,r8,128
81137568:	01400e04 	movi	r5,56
8113756c:	29006716 	blt	r5,r4,8113770c <__adddf3+0x848>
81137570:	014007c4 	movi	r5,31
81137574:	29007016 	blt	r5,r4,81137738 <__adddf3+0x874>
81137578:	01400804 	movi	r5,32
8113757c:	290bc83a 	sub	r5,r5,r4
81137580:	4154983a 	sll	r10,r8,r5
81137584:	890ed83a 	srl	r7,r17,r4
81137588:	894a983a 	sll	r5,r17,r5
8113758c:	4108d83a 	srl	r4,r8,r4
81137590:	51e2b03a 	or	r17,r10,r7
81137594:	280ac03a 	cmpne	r5,r5,zero
81137598:	8962b03a 	or	r17,r17,r5
8113759c:	89a3883a 	add	r17,r17,r6
811375a0:	2253883a 	add	r9,r4,r9
811375a4:	898d803a 	cmpltu	r6,r17,r6
811375a8:	3251883a 	add	r8,r6,r9
811375ac:	1021883a 	mov	r16,r2
811375b0:	003ee506 	br	81137148 <__reset+0xfb117148>
811375b4:	4984b03a 	or	r2,r9,r6
811375b8:	103e6326 	beq	r2,zero,81136f48 <__reset+0xfb116f48>
811375bc:	8987c83a 	sub	r3,r17,r6
811375c0:	88c9803a 	cmpltu	r4,r17,r3
811375c4:	4245c83a 	sub	r2,r8,r9
811375c8:	1105c83a 	sub	r2,r2,r4
811375cc:	1100202c 	andhi	r4,r2,128
811375d0:	203ebb26 	beq	r4,zero,811370c0 <__reset+0xfb1170c0>
811375d4:	3463c83a 	sub	r17,r6,r17
811375d8:	4a07c83a 	sub	r3,r9,r8
811375dc:	344d803a 	cmpltu	r6,r6,r17
811375e0:	1991c83a 	sub	r8,r3,r6
811375e4:	3825883a 	mov	r18,r7
811375e8:	003e5706 	br	81136f48 <__reset+0xfb116f48>
811375ec:	4984b03a 	or	r2,r9,r6
811375f0:	10002e26 	beq	r2,zero,811376ac <__adddf3+0x7e8>
811375f4:	4004d0fa 	srli	r2,r8,3
811375f8:	8822d0fa 	srli	r17,r17,3
811375fc:	4010977a 	slli	r8,r8,29
81137600:	10c0022c 	andhi	r3,r2,8
81137604:	4462b03a 	or	r17,r8,r17
81137608:	18000826 	beq	r3,zero,8113762c <__adddf3+0x768>
8113760c:	4808d0fa 	srli	r4,r9,3
81137610:	20c0022c 	andhi	r3,r4,8
81137614:	1800051e 	bne	r3,zero,8113762c <__adddf3+0x768>
81137618:	300cd0fa 	srli	r6,r6,3
8113761c:	4806977a 	slli	r3,r9,29
81137620:	2005883a 	mov	r2,r4
81137624:	3825883a 	mov	r18,r7
81137628:	19a2b03a 	or	r17,r3,r6
8113762c:	8810d77a 	srli	r8,r17,29
81137630:	100490fa 	slli	r2,r2,3
81137634:	882290fa 	slli	r17,r17,3
81137638:	0401ffc4 	movi	r16,2047
8113763c:	4090b03a 	or	r8,r8,r2
81137640:	003e4106 	br	81136f48 <__reset+0xfb116f48>
81137644:	0141ffc4 	movi	r5,2047
81137648:	117fc71e 	bne	r2,r5,81137568 <__reset+0xfb117568>
8113764c:	4811883a 	mov	r8,r9
81137650:	3023883a 	mov	r17,r6
81137654:	1021883a 	mov	r16,r2
81137658:	003e3b06 	br	81136f48 <__reset+0xfb116f48>
8113765c:	10002f26 	beq	r2,zero,8113771c <__adddf3+0x858>
81137660:	4984b03a 	or	r2,r9,r6
81137664:	10001126 	beq	r2,zero,811376ac <__adddf3+0x7e8>
81137668:	4004d0fa 	srli	r2,r8,3
8113766c:	8822d0fa 	srli	r17,r17,3
81137670:	4010977a 	slli	r8,r8,29
81137674:	10c0022c 	andhi	r3,r2,8
81137678:	4462b03a 	or	r17,r8,r17
8113767c:	183feb26 	beq	r3,zero,8113762c <__reset+0xfb11762c>
81137680:	4808d0fa 	srli	r4,r9,3
81137684:	20c0022c 	andhi	r3,r4,8
81137688:	183fe81e 	bne	r3,zero,8113762c <__reset+0xfb11762c>
8113768c:	300cd0fa 	srli	r6,r6,3
81137690:	4806977a 	slli	r3,r9,29
81137694:	2005883a 	mov	r2,r4
81137698:	19a2b03a 	or	r17,r3,r6
8113769c:	003fe306 	br	8113762c <__reset+0xfb11762c>
811376a0:	0011883a 	mov	r8,zero
811376a4:	0005883a 	mov	r2,zero
811376a8:	003e3f06 	br	81136fa8 <__reset+0xfb116fa8>
811376ac:	0401ffc4 	movi	r16,2047
811376b0:	003e2506 	br	81136f48 <__reset+0xfb116f48>
811376b4:	0013883a 	mov	r9,zero
811376b8:	003f8406 	br	811374cc <__reset+0xfb1174cc>
811376bc:	0005883a 	mov	r2,zero
811376c0:	0007883a 	mov	r3,zero
811376c4:	003e8906 	br	811370ec <__reset+0xfb1170ec>
811376c8:	197ff804 	addi	r5,r3,-32
811376cc:	01000804 	movi	r4,32
811376d0:	414ad83a 	srl	r5,r8,r5
811376d4:	19002426 	beq	r3,r4,81137768 <__adddf3+0x8a4>
811376d8:	01001004 	movi	r4,64
811376dc:	20c7c83a 	sub	r3,r4,r3
811376e0:	40c6983a 	sll	r3,r8,r3
811376e4:	1c46b03a 	or	r3,r3,r17
811376e8:	1806c03a 	cmpne	r3,r3,zero
811376ec:	28e2b03a 	or	r17,r5,r3
811376f0:	0007883a 	mov	r3,zero
811376f4:	003f2306 	br	81137384 <__reset+0xfb117384>
811376f8:	0007883a 	mov	r3,zero
811376fc:	5811883a 	mov	r8,r11
81137700:	00bfffc4 	movi	r2,-1
81137704:	0401ffc4 	movi	r16,2047
81137708:	003e7806 	br	811370ec <__reset+0xfb1170ec>
8113770c:	4462b03a 	or	r17,r8,r17
81137710:	8822c03a 	cmpne	r17,r17,zero
81137714:	0009883a 	mov	r4,zero
81137718:	003fa006 	br	8113759c <__reset+0xfb11759c>
8113771c:	4811883a 	mov	r8,r9
81137720:	3023883a 	mov	r17,r6
81137724:	0401ffc4 	movi	r16,2047
81137728:	003e0706 	br	81136f48 <__reset+0xfb116f48>
8113772c:	4811883a 	mov	r8,r9
81137730:	3023883a 	mov	r17,r6
81137734:	003e0406 	br	81136f48 <__reset+0xfb116f48>
81137738:	21fff804 	addi	r7,r4,-32
8113773c:	01400804 	movi	r5,32
81137740:	41ced83a 	srl	r7,r8,r7
81137744:	21400a26 	beq	r4,r5,81137770 <__adddf3+0x8ac>
81137748:	01401004 	movi	r5,64
8113774c:	2909c83a 	sub	r4,r5,r4
81137750:	4108983a 	sll	r4,r8,r4
81137754:	2448b03a 	or	r4,r4,r17
81137758:	2008c03a 	cmpne	r4,r4,zero
8113775c:	3922b03a 	or	r17,r7,r4
81137760:	0009883a 	mov	r4,zero
81137764:	003f8d06 	br	8113759c <__reset+0xfb11759c>
81137768:	0007883a 	mov	r3,zero
8113776c:	003fdd06 	br	811376e4 <__reset+0xfb1176e4>
81137770:	0009883a 	mov	r4,zero
81137774:	003ff706 	br	81137754 <__reset+0xfb117754>

81137778 <__divdf3>:
81137778:	defff204 	addi	sp,sp,-56
8113777c:	de00012e 	bgeu	sp,et,81137784 <__divdf3+0xc>
81137780:	003b68fa 	trap	3
81137784:	dd400915 	stw	r21,36(sp)
81137788:	282ad53a 	srli	r21,r5,20
8113778c:	dd000815 	stw	r20,32(sp)
81137790:	2828d7fa 	srli	r20,r5,31
81137794:	dc000415 	stw	r16,16(sp)
81137798:	04000434 	movhi	r16,16
8113779c:	df000c15 	stw	fp,48(sp)
811377a0:	843fffc4 	addi	r16,r16,-1
811377a4:	dfc00d15 	stw	ra,52(sp)
811377a8:	ddc00b15 	stw	r23,44(sp)
811377ac:	dd800a15 	stw	r22,40(sp)
811377b0:	dcc00715 	stw	r19,28(sp)
811377b4:	dc800615 	stw	r18,24(sp)
811377b8:	dc400515 	stw	r17,20(sp)
811377bc:	ad41ffcc 	andi	r21,r21,2047
811377c0:	2c20703a 	and	r16,r5,r16
811377c4:	a7003fcc 	andi	fp,r20,255
811377c8:	a8006126 	beq	r21,zero,81137950 <__divdf3+0x1d8>
811377cc:	0081ffc4 	movi	r2,2047
811377d0:	2025883a 	mov	r18,r4
811377d4:	a8803726 	beq	r21,r2,811378b4 <__divdf3+0x13c>
811377d8:	80800434 	orhi	r2,r16,16
811377dc:	100490fa 	slli	r2,r2,3
811377e0:	2020d77a 	srli	r16,r4,29
811377e4:	202490fa 	slli	r18,r4,3
811377e8:	ad7f0044 	addi	r21,r21,-1023
811377ec:	80a0b03a 	or	r16,r16,r2
811377f0:	0027883a 	mov	r19,zero
811377f4:	0013883a 	mov	r9,zero
811377f8:	3804d53a 	srli	r2,r7,20
811377fc:	382cd7fa 	srli	r22,r7,31
81137800:	04400434 	movhi	r17,16
81137804:	8c7fffc4 	addi	r17,r17,-1
81137808:	1081ffcc 	andi	r2,r2,2047
8113780c:	3011883a 	mov	r8,r6
81137810:	3c62703a 	and	r17,r7,r17
81137814:	b5c03fcc 	andi	r23,r22,255
81137818:	10006c26 	beq	r2,zero,811379cc <__divdf3+0x254>
8113781c:	00c1ffc4 	movi	r3,2047
81137820:	10c06426 	beq	r2,r3,811379b4 <__divdf3+0x23c>
81137824:	88c00434 	orhi	r3,r17,16
81137828:	180690fa 	slli	r3,r3,3
8113782c:	3022d77a 	srli	r17,r6,29
81137830:	301090fa 	slli	r8,r6,3
81137834:	10bf0044 	addi	r2,r2,-1023
81137838:	88e2b03a 	or	r17,r17,r3
8113783c:	000f883a 	mov	r7,zero
81137840:	a58cf03a 	xor	r6,r20,r22
81137844:	3cc8b03a 	or	r4,r7,r19
81137848:	a8abc83a 	sub	r21,r21,r2
8113784c:	008003c4 	movi	r2,15
81137850:	3007883a 	mov	r3,r6
81137854:	34c03fcc 	andi	r19,r6,255
81137858:	11009036 	bltu	r2,r4,81137a9c <__divdf3+0x324>
8113785c:	200890ba 	slli	r4,r4,2
81137860:	00a044f4 	movhi	r2,33043
81137864:	109e1d04 	addi	r2,r2,30836
81137868:	2089883a 	add	r4,r4,r2
8113786c:	20800017 	ldw	r2,0(r4)
81137870:	1000683a 	jmp	r2
81137874:	81137a9c 	xori	r4,r16,19946
81137878:	811378ec 	andhi	r4,r16,19939
8113787c:	81137a8c 	andi	r4,r16,19946
81137880:	811378e0 	cmpeqi	r4,r16,19939
81137884:	81137a8c 	andi	r4,r16,19946
81137888:	81137a60 	cmpeqi	r4,r16,19945
8113788c:	81137a8c 	andi	r4,r16,19946
81137890:	811378e0 	cmpeqi	r4,r16,19939
81137894:	811378ec 	andhi	r4,r16,19939
81137898:	811378ec 	andhi	r4,r16,19939
8113789c:	81137a60 	cmpeqi	r4,r16,19945
811378a0:	811378e0 	cmpeqi	r4,r16,19939
811378a4:	811378d0 	cmplti	r4,r16,19939
811378a8:	811378d0 	cmplti	r4,r16,19939
811378ac:	811378d0 	cmplti	r4,r16,19939
811378b0:	81137d80 	call	881137d8 <__reset+0x20f37d8>
811378b4:	2404b03a 	or	r2,r4,r16
811378b8:	1000661e 	bne	r2,zero,81137a54 <__divdf3+0x2dc>
811378bc:	04c00204 	movi	r19,8
811378c0:	0021883a 	mov	r16,zero
811378c4:	0025883a 	mov	r18,zero
811378c8:	02400084 	movi	r9,2
811378cc:	003fca06 	br	811377f8 <__reset+0xfb1177f8>
811378d0:	8023883a 	mov	r17,r16
811378d4:	9011883a 	mov	r8,r18
811378d8:	e02f883a 	mov	r23,fp
811378dc:	480f883a 	mov	r7,r9
811378e0:	00800084 	movi	r2,2
811378e4:	3881311e 	bne	r7,r2,81137dac <__divdf3+0x634>
811378e8:	b827883a 	mov	r19,r23
811378ec:	98c0004c 	andi	r3,r19,1
811378f0:	0081ffc4 	movi	r2,2047
811378f4:	000b883a 	mov	r5,zero
811378f8:	0025883a 	mov	r18,zero
811378fc:	1004953a 	slli	r2,r2,20
81137900:	18c03fcc 	andi	r3,r3,255
81137904:	04400434 	movhi	r17,16
81137908:	8c7fffc4 	addi	r17,r17,-1
8113790c:	180697fa 	slli	r3,r3,31
81137910:	2c4a703a 	and	r5,r5,r17
81137914:	288ab03a 	or	r5,r5,r2
81137918:	28c6b03a 	or	r3,r5,r3
8113791c:	9005883a 	mov	r2,r18
81137920:	dfc00d17 	ldw	ra,52(sp)
81137924:	df000c17 	ldw	fp,48(sp)
81137928:	ddc00b17 	ldw	r23,44(sp)
8113792c:	dd800a17 	ldw	r22,40(sp)
81137930:	dd400917 	ldw	r21,36(sp)
81137934:	dd000817 	ldw	r20,32(sp)
81137938:	dcc00717 	ldw	r19,28(sp)
8113793c:	dc800617 	ldw	r18,24(sp)
81137940:	dc400517 	ldw	r17,20(sp)
81137944:	dc000417 	ldw	r16,16(sp)
81137948:	dec00e04 	addi	sp,sp,56
8113794c:	f800283a 	ret
81137950:	2404b03a 	or	r2,r4,r16
81137954:	2027883a 	mov	r19,r4
81137958:	10003926 	beq	r2,zero,81137a40 <__divdf3+0x2c8>
8113795c:	80012e26 	beq	r16,zero,81137e18 <__divdf3+0x6a0>
81137960:	8009883a 	mov	r4,r16
81137964:	d9800315 	stw	r6,12(sp)
81137968:	d9c00215 	stw	r7,8(sp)
8113796c:	11234780 	call	81123478 <__clzsi2>
81137970:	d9800317 	ldw	r6,12(sp)
81137974:	d9c00217 	ldw	r7,8(sp)
81137978:	113ffd44 	addi	r4,r2,-11
8113797c:	00c00704 	movi	r3,28
81137980:	19012116 	blt	r3,r4,81137e08 <__divdf3+0x690>
81137984:	00c00744 	movi	r3,29
81137988:	147ffe04 	addi	r17,r2,-8
8113798c:	1907c83a 	sub	r3,r3,r4
81137990:	8460983a 	sll	r16,r16,r17
81137994:	98c6d83a 	srl	r3,r19,r3
81137998:	9c64983a 	sll	r18,r19,r17
8113799c:	1c20b03a 	or	r16,r3,r16
811379a0:	1080fcc4 	addi	r2,r2,1011
811379a4:	00abc83a 	sub	r21,zero,r2
811379a8:	0027883a 	mov	r19,zero
811379ac:	0013883a 	mov	r9,zero
811379b0:	003f9106 	br	811377f8 <__reset+0xfb1177f8>
811379b4:	3446b03a 	or	r3,r6,r17
811379b8:	18001f1e 	bne	r3,zero,81137a38 <__divdf3+0x2c0>
811379bc:	0023883a 	mov	r17,zero
811379c0:	0011883a 	mov	r8,zero
811379c4:	01c00084 	movi	r7,2
811379c8:	003f9d06 	br	81137840 <__reset+0xfb117840>
811379cc:	3446b03a 	or	r3,r6,r17
811379d0:	18001526 	beq	r3,zero,81137a28 <__divdf3+0x2b0>
811379d4:	88011b26 	beq	r17,zero,81137e44 <__divdf3+0x6cc>
811379d8:	8809883a 	mov	r4,r17
811379dc:	d9800315 	stw	r6,12(sp)
811379e0:	da400115 	stw	r9,4(sp)
811379e4:	11234780 	call	81123478 <__clzsi2>
811379e8:	d9800317 	ldw	r6,12(sp)
811379ec:	da400117 	ldw	r9,4(sp)
811379f0:	113ffd44 	addi	r4,r2,-11
811379f4:	00c00704 	movi	r3,28
811379f8:	19010e16 	blt	r3,r4,81137e34 <__divdf3+0x6bc>
811379fc:	00c00744 	movi	r3,29
81137a00:	123ffe04 	addi	r8,r2,-8
81137a04:	1907c83a 	sub	r3,r3,r4
81137a08:	8a22983a 	sll	r17,r17,r8
81137a0c:	30c6d83a 	srl	r3,r6,r3
81137a10:	3210983a 	sll	r8,r6,r8
81137a14:	1c62b03a 	or	r17,r3,r17
81137a18:	1080fcc4 	addi	r2,r2,1011
81137a1c:	0085c83a 	sub	r2,zero,r2
81137a20:	000f883a 	mov	r7,zero
81137a24:	003f8606 	br	81137840 <__reset+0xfb117840>
81137a28:	0023883a 	mov	r17,zero
81137a2c:	0011883a 	mov	r8,zero
81137a30:	01c00044 	movi	r7,1
81137a34:	003f8206 	br	81137840 <__reset+0xfb117840>
81137a38:	01c000c4 	movi	r7,3
81137a3c:	003f8006 	br	81137840 <__reset+0xfb117840>
81137a40:	04c00104 	movi	r19,4
81137a44:	0021883a 	mov	r16,zero
81137a48:	0025883a 	mov	r18,zero
81137a4c:	02400044 	movi	r9,1
81137a50:	003f6906 	br	811377f8 <__reset+0xfb1177f8>
81137a54:	04c00304 	movi	r19,12
81137a58:	024000c4 	movi	r9,3
81137a5c:	003f6606 	br	811377f8 <__reset+0xfb1177f8>
81137a60:	01400434 	movhi	r5,16
81137a64:	0007883a 	mov	r3,zero
81137a68:	297fffc4 	addi	r5,r5,-1
81137a6c:	04bfffc4 	movi	r18,-1
81137a70:	0081ffc4 	movi	r2,2047
81137a74:	003fa106 	br	811378fc <__reset+0xfb1178fc>
81137a78:	00c00044 	movi	r3,1
81137a7c:	1887c83a 	sub	r3,r3,r2
81137a80:	01000e04 	movi	r4,56
81137a84:	20c1210e 	bge	r4,r3,81137f0c <__divdf3+0x794>
81137a88:	98c0004c 	andi	r3,r19,1
81137a8c:	0005883a 	mov	r2,zero
81137a90:	000b883a 	mov	r5,zero
81137a94:	0025883a 	mov	r18,zero
81137a98:	003f9806 	br	811378fc <__reset+0xfb1178fc>
81137a9c:	8c00fd36 	bltu	r17,r16,81137e94 <__divdf3+0x71c>
81137aa0:	8440fb26 	beq	r16,r17,81137e90 <__divdf3+0x718>
81137aa4:	8007883a 	mov	r3,r16
81137aa8:	ad7fffc4 	addi	r21,r21,-1
81137aac:	0021883a 	mov	r16,zero
81137ab0:	4004d63a 	srli	r2,r8,24
81137ab4:	8822923a 	slli	r17,r17,8
81137ab8:	1809883a 	mov	r4,r3
81137abc:	402c923a 	slli	r22,r8,8
81137ac0:	88b8b03a 	or	fp,r17,r2
81137ac4:	e028d43a 	srli	r20,fp,16
81137ac8:	d8c00015 	stw	r3,0(sp)
81137acc:	e5ffffcc 	andi	r23,fp,65535
81137ad0:	a00b883a 	mov	r5,r20
81137ad4:	1136c0c0 	call	81136c0c <__udivsi3>
81137ad8:	d8c00017 	ldw	r3,0(sp)
81137adc:	a00b883a 	mov	r5,r20
81137ae0:	d8800315 	stw	r2,12(sp)
81137ae4:	1809883a 	mov	r4,r3
81137ae8:	1136c700 	call	81136c70 <__umodsi3>
81137aec:	d9800317 	ldw	r6,12(sp)
81137af0:	1006943a 	slli	r3,r2,16
81137af4:	9004d43a 	srli	r2,r18,16
81137af8:	b9a3383a 	mul	r17,r23,r6
81137afc:	10c4b03a 	or	r2,r2,r3
81137b00:	1440062e 	bgeu	r2,r17,81137b1c <__divdf3+0x3a4>
81137b04:	1705883a 	add	r2,r2,fp
81137b08:	30ffffc4 	addi	r3,r6,-1
81137b0c:	1700ee36 	bltu	r2,fp,81137ec8 <__divdf3+0x750>
81137b10:	1440ed2e 	bgeu	r2,r17,81137ec8 <__divdf3+0x750>
81137b14:	31bfff84 	addi	r6,r6,-2
81137b18:	1705883a 	add	r2,r2,fp
81137b1c:	1463c83a 	sub	r17,r2,r17
81137b20:	a00b883a 	mov	r5,r20
81137b24:	8809883a 	mov	r4,r17
81137b28:	d9800315 	stw	r6,12(sp)
81137b2c:	1136c0c0 	call	81136c0c <__udivsi3>
81137b30:	a00b883a 	mov	r5,r20
81137b34:	8809883a 	mov	r4,r17
81137b38:	d8800215 	stw	r2,8(sp)
81137b3c:	1136c700 	call	81136c70 <__umodsi3>
81137b40:	d9c00217 	ldw	r7,8(sp)
81137b44:	1004943a 	slli	r2,r2,16
81137b48:	94bfffcc 	andi	r18,r18,65535
81137b4c:	b9d1383a 	mul	r8,r23,r7
81137b50:	90a4b03a 	or	r18,r18,r2
81137b54:	d9800317 	ldw	r6,12(sp)
81137b58:	9200062e 	bgeu	r18,r8,81137b74 <__divdf3+0x3fc>
81137b5c:	9725883a 	add	r18,r18,fp
81137b60:	38bfffc4 	addi	r2,r7,-1
81137b64:	9700d636 	bltu	r18,fp,81137ec0 <__divdf3+0x748>
81137b68:	9200d52e 	bgeu	r18,r8,81137ec0 <__divdf3+0x748>
81137b6c:	39ffff84 	addi	r7,r7,-2
81137b70:	9725883a 	add	r18,r18,fp
81137b74:	3004943a 	slli	r2,r6,16
81137b78:	b012d43a 	srli	r9,r22,16
81137b7c:	b1bfffcc 	andi	r6,r22,65535
81137b80:	11e2b03a 	or	r17,r2,r7
81137b84:	8806d43a 	srli	r3,r17,16
81137b88:	893fffcc 	andi	r4,r17,65535
81137b8c:	218b383a 	mul	r5,r4,r6
81137b90:	30c5383a 	mul	r2,r6,r3
81137b94:	2249383a 	mul	r4,r4,r9
81137b98:	280ed43a 	srli	r7,r5,16
81137b9c:	9225c83a 	sub	r18,r18,r8
81137ba0:	2089883a 	add	r4,r4,r2
81137ba4:	3909883a 	add	r4,r7,r4
81137ba8:	1a47383a 	mul	r3,r3,r9
81137bac:	2080022e 	bgeu	r4,r2,81137bb8 <__divdf3+0x440>
81137bb0:	00800074 	movhi	r2,1
81137bb4:	1887883a 	add	r3,r3,r2
81137bb8:	2004d43a 	srli	r2,r4,16
81137bbc:	2008943a 	slli	r4,r4,16
81137bc0:	297fffcc 	andi	r5,r5,65535
81137bc4:	10c7883a 	add	r3,r2,r3
81137bc8:	2149883a 	add	r4,r4,r5
81137bcc:	90c0a536 	bltu	r18,r3,81137e64 <__divdf3+0x6ec>
81137bd0:	90c0bf26 	beq	r18,r3,81137ed0 <__divdf3+0x758>
81137bd4:	90c7c83a 	sub	r3,r18,r3
81137bd8:	810fc83a 	sub	r7,r16,r4
81137bdc:	81e5803a 	cmpltu	r18,r16,r7
81137be0:	1ca5c83a 	sub	r18,r3,r18
81137be4:	e480c126 	beq	fp,r18,81137eec <__divdf3+0x774>
81137be8:	a00b883a 	mov	r5,r20
81137bec:	9009883a 	mov	r4,r18
81137bf0:	d9800315 	stw	r6,12(sp)
81137bf4:	d9c00215 	stw	r7,8(sp)
81137bf8:	da400115 	stw	r9,4(sp)
81137bfc:	1136c0c0 	call	81136c0c <__udivsi3>
81137c00:	a00b883a 	mov	r5,r20
81137c04:	9009883a 	mov	r4,r18
81137c08:	d8800015 	stw	r2,0(sp)
81137c0c:	1136c700 	call	81136c70 <__umodsi3>
81137c10:	d9c00217 	ldw	r7,8(sp)
81137c14:	da000017 	ldw	r8,0(sp)
81137c18:	1006943a 	slli	r3,r2,16
81137c1c:	3804d43a 	srli	r2,r7,16
81137c20:	ba21383a 	mul	r16,r23,r8
81137c24:	d9800317 	ldw	r6,12(sp)
81137c28:	10c4b03a 	or	r2,r2,r3
81137c2c:	da400117 	ldw	r9,4(sp)
81137c30:	1400062e 	bgeu	r2,r16,81137c4c <__divdf3+0x4d4>
81137c34:	1705883a 	add	r2,r2,fp
81137c38:	40ffffc4 	addi	r3,r8,-1
81137c3c:	1700ad36 	bltu	r2,fp,81137ef4 <__divdf3+0x77c>
81137c40:	1400ac2e 	bgeu	r2,r16,81137ef4 <__divdf3+0x77c>
81137c44:	423fff84 	addi	r8,r8,-2
81137c48:	1705883a 	add	r2,r2,fp
81137c4c:	1421c83a 	sub	r16,r2,r16
81137c50:	a00b883a 	mov	r5,r20
81137c54:	8009883a 	mov	r4,r16
81137c58:	d9800315 	stw	r6,12(sp)
81137c5c:	d9c00215 	stw	r7,8(sp)
81137c60:	da000015 	stw	r8,0(sp)
81137c64:	da400115 	stw	r9,4(sp)
81137c68:	1136c0c0 	call	81136c0c <__udivsi3>
81137c6c:	8009883a 	mov	r4,r16
81137c70:	a00b883a 	mov	r5,r20
81137c74:	1025883a 	mov	r18,r2
81137c78:	1136c700 	call	81136c70 <__umodsi3>
81137c7c:	d9c00217 	ldw	r7,8(sp)
81137c80:	1004943a 	slli	r2,r2,16
81137c84:	bcaf383a 	mul	r23,r23,r18
81137c88:	393fffcc 	andi	r4,r7,65535
81137c8c:	2088b03a 	or	r4,r4,r2
81137c90:	d9800317 	ldw	r6,12(sp)
81137c94:	da000017 	ldw	r8,0(sp)
81137c98:	da400117 	ldw	r9,4(sp)
81137c9c:	25c0062e 	bgeu	r4,r23,81137cb8 <__divdf3+0x540>
81137ca0:	2709883a 	add	r4,r4,fp
81137ca4:	90bfffc4 	addi	r2,r18,-1
81137ca8:	27009436 	bltu	r4,fp,81137efc <__divdf3+0x784>
81137cac:	25c0932e 	bgeu	r4,r23,81137efc <__divdf3+0x784>
81137cb0:	94bfff84 	addi	r18,r18,-2
81137cb4:	2709883a 	add	r4,r4,fp
81137cb8:	4004943a 	slli	r2,r8,16
81137cbc:	25efc83a 	sub	r23,r4,r23
81137cc0:	1490b03a 	or	r8,r2,r18
81137cc4:	4008d43a 	srli	r4,r8,16
81137cc8:	40ffffcc 	andi	r3,r8,65535
81137ccc:	30c5383a 	mul	r2,r6,r3
81137cd0:	1a47383a 	mul	r3,r3,r9
81137cd4:	310d383a 	mul	r6,r6,r4
81137cd8:	100ad43a 	srli	r5,r2,16
81137cdc:	4913383a 	mul	r9,r9,r4
81137ce0:	1987883a 	add	r3,r3,r6
81137ce4:	28c7883a 	add	r3,r5,r3
81137ce8:	1980022e 	bgeu	r3,r6,81137cf4 <__divdf3+0x57c>
81137cec:	01000074 	movhi	r4,1
81137cf0:	4913883a 	add	r9,r9,r4
81137cf4:	1808d43a 	srli	r4,r3,16
81137cf8:	1806943a 	slli	r3,r3,16
81137cfc:	10bfffcc 	andi	r2,r2,65535
81137d00:	2253883a 	add	r9,r4,r9
81137d04:	1887883a 	add	r3,r3,r2
81137d08:	ba403836 	bltu	r23,r9,81137dec <__divdf3+0x674>
81137d0c:	ba403626 	beq	r23,r9,81137de8 <__divdf3+0x670>
81137d10:	42000054 	ori	r8,r8,1
81137d14:	a880ffc4 	addi	r2,r21,1023
81137d18:	00bf570e 	bge	zero,r2,81137a78 <__reset+0xfb117a78>
81137d1c:	40c001cc 	andi	r3,r8,7
81137d20:	18000726 	beq	r3,zero,81137d40 <__divdf3+0x5c8>
81137d24:	40c003cc 	andi	r3,r8,15
81137d28:	01000104 	movi	r4,4
81137d2c:	19000426 	beq	r3,r4,81137d40 <__divdf3+0x5c8>
81137d30:	4107883a 	add	r3,r8,r4
81137d34:	1a11803a 	cmpltu	r8,r3,r8
81137d38:	8a23883a 	add	r17,r17,r8
81137d3c:	1811883a 	mov	r8,r3
81137d40:	88c0402c 	andhi	r3,r17,256
81137d44:	18000426 	beq	r3,zero,81137d58 <__divdf3+0x5e0>
81137d48:	00ffc034 	movhi	r3,65280
81137d4c:	18ffffc4 	addi	r3,r3,-1
81137d50:	a8810004 	addi	r2,r21,1024
81137d54:	88e2703a 	and	r17,r17,r3
81137d58:	00c1ff84 	movi	r3,2046
81137d5c:	18bee316 	blt	r3,r2,811378ec <__reset+0xfb1178ec>
81137d60:	8824977a 	slli	r18,r17,29
81137d64:	4010d0fa 	srli	r8,r8,3
81137d68:	8822927a 	slli	r17,r17,9
81137d6c:	1081ffcc 	andi	r2,r2,2047
81137d70:	9224b03a 	or	r18,r18,r8
81137d74:	880ad33a 	srli	r5,r17,12
81137d78:	98c0004c 	andi	r3,r19,1
81137d7c:	003edf06 	br	811378fc <__reset+0xfb1178fc>
81137d80:	8080022c 	andhi	r2,r16,8
81137d84:	10001226 	beq	r2,zero,81137dd0 <__divdf3+0x658>
81137d88:	8880022c 	andhi	r2,r17,8
81137d8c:	1000101e 	bne	r2,zero,81137dd0 <__divdf3+0x658>
81137d90:	00800434 	movhi	r2,16
81137d94:	89400234 	orhi	r5,r17,8
81137d98:	10bfffc4 	addi	r2,r2,-1
81137d9c:	b007883a 	mov	r3,r22
81137da0:	288a703a 	and	r5,r5,r2
81137da4:	4025883a 	mov	r18,r8
81137da8:	003f3106 	br	81137a70 <__reset+0xfb117a70>
81137dac:	008000c4 	movi	r2,3
81137db0:	3880a626 	beq	r7,r2,8113804c <__divdf3+0x8d4>
81137db4:	00800044 	movi	r2,1
81137db8:	3880521e 	bne	r7,r2,81137f04 <__divdf3+0x78c>
81137dbc:	b807883a 	mov	r3,r23
81137dc0:	0005883a 	mov	r2,zero
81137dc4:	000b883a 	mov	r5,zero
81137dc8:	0025883a 	mov	r18,zero
81137dcc:	003ecb06 	br	811378fc <__reset+0xfb1178fc>
81137dd0:	00800434 	movhi	r2,16
81137dd4:	81400234 	orhi	r5,r16,8
81137dd8:	10bfffc4 	addi	r2,r2,-1
81137ddc:	a007883a 	mov	r3,r20
81137de0:	288a703a 	and	r5,r5,r2
81137de4:	003f2206 	br	81137a70 <__reset+0xfb117a70>
81137de8:	183fca26 	beq	r3,zero,81137d14 <__reset+0xfb117d14>
81137dec:	e5ef883a 	add	r23,fp,r23
81137df0:	40bfffc4 	addi	r2,r8,-1
81137df4:	bf00392e 	bgeu	r23,fp,81137edc <__divdf3+0x764>
81137df8:	1011883a 	mov	r8,r2
81137dfc:	ba7fc41e 	bne	r23,r9,81137d10 <__reset+0xfb117d10>
81137e00:	b0ffc31e 	bne	r22,r3,81137d10 <__reset+0xfb117d10>
81137e04:	003fc306 	br	81137d14 <__reset+0xfb117d14>
81137e08:	143ff604 	addi	r16,r2,-40
81137e0c:	9c20983a 	sll	r16,r19,r16
81137e10:	0025883a 	mov	r18,zero
81137e14:	003ee206 	br	811379a0 <__reset+0xfb1179a0>
81137e18:	d9800315 	stw	r6,12(sp)
81137e1c:	d9c00215 	stw	r7,8(sp)
81137e20:	11234780 	call	81123478 <__clzsi2>
81137e24:	10800804 	addi	r2,r2,32
81137e28:	d9c00217 	ldw	r7,8(sp)
81137e2c:	d9800317 	ldw	r6,12(sp)
81137e30:	003ed106 	br	81137978 <__reset+0xfb117978>
81137e34:	147ff604 	addi	r17,r2,-40
81137e38:	3462983a 	sll	r17,r6,r17
81137e3c:	0011883a 	mov	r8,zero
81137e40:	003ef506 	br	81137a18 <__reset+0xfb117a18>
81137e44:	3009883a 	mov	r4,r6
81137e48:	d9800315 	stw	r6,12(sp)
81137e4c:	da400115 	stw	r9,4(sp)
81137e50:	11234780 	call	81123478 <__clzsi2>
81137e54:	10800804 	addi	r2,r2,32
81137e58:	da400117 	ldw	r9,4(sp)
81137e5c:	d9800317 	ldw	r6,12(sp)
81137e60:	003ee306 	br	811379f0 <__reset+0xfb1179f0>
81137e64:	85a1883a 	add	r16,r16,r22
81137e68:	8585803a 	cmpltu	r2,r16,r22
81137e6c:	1705883a 	add	r2,r2,fp
81137e70:	14a5883a 	add	r18,r2,r18
81137e74:	88bfffc4 	addi	r2,r17,-1
81137e78:	e4800c2e 	bgeu	fp,r18,81137eac <__divdf3+0x734>
81137e7c:	90c03e36 	bltu	r18,r3,81137f78 <__divdf3+0x800>
81137e80:	1c806926 	beq	r3,r18,81138028 <__divdf3+0x8b0>
81137e84:	90c7c83a 	sub	r3,r18,r3
81137e88:	1023883a 	mov	r17,r2
81137e8c:	003f5206 	br	81137bd8 <__reset+0xfb117bd8>
81137e90:	923f0436 	bltu	r18,r8,81137aa4 <__reset+0xfb117aa4>
81137e94:	800897fa 	slli	r4,r16,31
81137e98:	9004d07a 	srli	r2,r18,1
81137e9c:	8006d07a 	srli	r3,r16,1
81137ea0:	902097fa 	slli	r16,r18,31
81137ea4:	20a4b03a 	or	r18,r4,r2
81137ea8:	003f0106 	br	81137ab0 <__reset+0xfb117ab0>
81137eac:	e4bff51e 	bne	fp,r18,81137e84 <__reset+0xfb117e84>
81137eb0:	85bff22e 	bgeu	r16,r22,81137e7c <__reset+0xfb117e7c>
81137eb4:	e0c7c83a 	sub	r3,fp,r3
81137eb8:	1023883a 	mov	r17,r2
81137ebc:	003f4606 	br	81137bd8 <__reset+0xfb117bd8>
81137ec0:	100f883a 	mov	r7,r2
81137ec4:	003f2b06 	br	81137b74 <__reset+0xfb117b74>
81137ec8:	180d883a 	mov	r6,r3
81137ecc:	003f1306 	br	81137b1c <__reset+0xfb117b1c>
81137ed0:	813fe436 	bltu	r16,r4,81137e64 <__reset+0xfb117e64>
81137ed4:	0007883a 	mov	r3,zero
81137ed8:	003f3f06 	br	81137bd8 <__reset+0xfb117bd8>
81137edc:	ba402c36 	bltu	r23,r9,81137f90 <__divdf3+0x818>
81137ee0:	4dc05426 	beq	r9,r23,81138034 <__divdf3+0x8bc>
81137ee4:	1011883a 	mov	r8,r2
81137ee8:	003f8906 	br	81137d10 <__reset+0xfb117d10>
81137eec:	023fffc4 	movi	r8,-1
81137ef0:	003f8806 	br	81137d14 <__reset+0xfb117d14>
81137ef4:	1811883a 	mov	r8,r3
81137ef8:	003f5406 	br	81137c4c <__reset+0xfb117c4c>
81137efc:	1025883a 	mov	r18,r2
81137f00:	003f6d06 	br	81137cb8 <__reset+0xfb117cb8>
81137f04:	b827883a 	mov	r19,r23
81137f08:	003f8206 	br	81137d14 <__reset+0xfb117d14>
81137f0c:	010007c4 	movi	r4,31
81137f10:	20c02616 	blt	r4,r3,81137fac <__divdf3+0x834>
81137f14:	00800804 	movi	r2,32
81137f18:	10c5c83a 	sub	r2,r2,r3
81137f1c:	888a983a 	sll	r5,r17,r2
81137f20:	40c8d83a 	srl	r4,r8,r3
81137f24:	4084983a 	sll	r2,r8,r2
81137f28:	88e2d83a 	srl	r17,r17,r3
81137f2c:	2906b03a 	or	r3,r5,r4
81137f30:	1004c03a 	cmpne	r2,r2,zero
81137f34:	1886b03a 	or	r3,r3,r2
81137f38:	188001cc 	andi	r2,r3,7
81137f3c:	10000726 	beq	r2,zero,81137f5c <__divdf3+0x7e4>
81137f40:	188003cc 	andi	r2,r3,15
81137f44:	01000104 	movi	r4,4
81137f48:	11000426 	beq	r2,r4,81137f5c <__divdf3+0x7e4>
81137f4c:	1805883a 	mov	r2,r3
81137f50:	10c00104 	addi	r3,r2,4
81137f54:	1885803a 	cmpltu	r2,r3,r2
81137f58:	88a3883a 	add	r17,r17,r2
81137f5c:	8880202c 	andhi	r2,r17,128
81137f60:	10002726 	beq	r2,zero,81138000 <__divdf3+0x888>
81137f64:	98c0004c 	andi	r3,r19,1
81137f68:	00800044 	movi	r2,1
81137f6c:	000b883a 	mov	r5,zero
81137f70:	0025883a 	mov	r18,zero
81137f74:	003e6106 	br	811378fc <__reset+0xfb1178fc>
81137f78:	85a1883a 	add	r16,r16,r22
81137f7c:	8585803a 	cmpltu	r2,r16,r22
81137f80:	1705883a 	add	r2,r2,fp
81137f84:	14a5883a 	add	r18,r2,r18
81137f88:	8c7fff84 	addi	r17,r17,-2
81137f8c:	003f1106 	br	81137bd4 <__reset+0xfb117bd4>
81137f90:	b589883a 	add	r4,r22,r22
81137f94:	25ad803a 	cmpltu	r22,r4,r22
81137f98:	b739883a 	add	fp,r22,fp
81137f9c:	40bfff84 	addi	r2,r8,-2
81137fa0:	bf2f883a 	add	r23,r23,fp
81137fa4:	202d883a 	mov	r22,r4
81137fa8:	003f9306 	br	81137df8 <__reset+0xfb117df8>
81137fac:	013ff844 	movi	r4,-31
81137fb0:	2085c83a 	sub	r2,r4,r2
81137fb4:	8888d83a 	srl	r4,r17,r2
81137fb8:	00800804 	movi	r2,32
81137fbc:	18802126 	beq	r3,r2,81138044 <__divdf3+0x8cc>
81137fc0:	00801004 	movi	r2,64
81137fc4:	10c5c83a 	sub	r2,r2,r3
81137fc8:	8884983a 	sll	r2,r17,r2
81137fcc:	1204b03a 	or	r2,r2,r8
81137fd0:	1004c03a 	cmpne	r2,r2,zero
81137fd4:	2084b03a 	or	r2,r4,r2
81137fd8:	144001cc 	andi	r17,r2,7
81137fdc:	88000d1e 	bne	r17,zero,81138014 <__divdf3+0x89c>
81137fe0:	000b883a 	mov	r5,zero
81137fe4:	1024d0fa 	srli	r18,r2,3
81137fe8:	98c0004c 	andi	r3,r19,1
81137fec:	0005883a 	mov	r2,zero
81137ff0:	9464b03a 	or	r18,r18,r17
81137ff4:	003e4106 	br	811378fc <__reset+0xfb1178fc>
81137ff8:	1007883a 	mov	r3,r2
81137ffc:	0023883a 	mov	r17,zero
81138000:	880a927a 	slli	r5,r17,9
81138004:	1805883a 	mov	r2,r3
81138008:	8822977a 	slli	r17,r17,29
8113800c:	280ad33a 	srli	r5,r5,12
81138010:	003ff406 	br	81137fe4 <__reset+0xfb117fe4>
81138014:	10c003cc 	andi	r3,r2,15
81138018:	01000104 	movi	r4,4
8113801c:	193ff626 	beq	r3,r4,81137ff8 <__reset+0xfb117ff8>
81138020:	0023883a 	mov	r17,zero
81138024:	003fca06 	br	81137f50 <__reset+0xfb117f50>
81138028:	813fd336 	bltu	r16,r4,81137f78 <__reset+0xfb117f78>
8113802c:	1023883a 	mov	r17,r2
81138030:	003fa806 	br	81137ed4 <__reset+0xfb117ed4>
81138034:	b0ffd636 	bltu	r22,r3,81137f90 <__reset+0xfb117f90>
81138038:	1011883a 	mov	r8,r2
8113803c:	b0ff341e 	bne	r22,r3,81137d10 <__reset+0xfb117d10>
81138040:	003f3406 	br	81137d14 <__reset+0xfb117d14>
81138044:	0005883a 	mov	r2,zero
81138048:	003fe006 	br	81137fcc <__reset+0xfb117fcc>
8113804c:	00800434 	movhi	r2,16
81138050:	89400234 	orhi	r5,r17,8
81138054:	10bfffc4 	addi	r2,r2,-1
81138058:	b807883a 	mov	r3,r23
8113805c:	288a703a 	and	r5,r5,r2
81138060:	4025883a 	mov	r18,r8
81138064:	003e8206 	br	81137a70 <__reset+0xfb117a70>

81138068 <__eqdf2>:
81138068:	2804d53a 	srli	r2,r5,20
8113806c:	3806d53a 	srli	r3,r7,20
81138070:	02000434 	movhi	r8,16
81138074:	423fffc4 	addi	r8,r8,-1
81138078:	1081ffcc 	andi	r2,r2,2047
8113807c:	0281ffc4 	movi	r10,2047
81138080:	2a12703a 	and	r9,r5,r8
81138084:	18c1ffcc 	andi	r3,r3,2047
81138088:	3a10703a 	and	r8,r7,r8
8113808c:	280ad7fa 	srli	r5,r5,31
81138090:	380ed7fa 	srli	r7,r7,31
81138094:	12801026 	beq	r2,r10,811380d8 <__eqdf2+0x70>
81138098:	0281ffc4 	movi	r10,2047
8113809c:	1a800a26 	beq	r3,r10,811380c8 <__eqdf2+0x60>
811380a0:	10c00226 	beq	r2,r3,811380ac <__eqdf2+0x44>
811380a4:	00800044 	movi	r2,1
811380a8:	f800283a 	ret
811380ac:	4a3ffd1e 	bne	r9,r8,811380a4 <__reset+0xfb1180a4>
811380b0:	21bffc1e 	bne	r4,r6,811380a4 <__reset+0xfb1180a4>
811380b4:	29c00c26 	beq	r5,r7,811380e8 <__eqdf2+0x80>
811380b8:	103ffa1e 	bne	r2,zero,811380a4 <__reset+0xfb1180a4>
811380bc:	2244b03a 	or	r2,r4,r9
811380c0:	1004c03a 	cmpne	r2,r2,zero
811380c4:	f800283a 	ret
811380c8:	3214b03a 	or	r10,r6,r8
811380cc:	503ff426 	beq	r10,zero,811380a0 <__reset+0xfb1180a0>
811380d0:	00800044 	movi	r2,1
811380d4:	f800283a 	ret
811380d8:	2254b03a 	or	r10,r4,r9
811380dc:	503fee26 	beq	r10,zero,81138098 <__reset+0xfb118098>
811380e0:	00800044 	movi	r2,1
811380e4:	f800283a 	ret
811380e8:	0005883a 	mov	r2,zero
811380ec:	f800283a 	ret

811380f0 <__ledf2>:
811380f0:	2804d53a 	srli	r2,r5,20
811380f4:	3810d53a 	srli	r8,r7,20
811380f8:	00c00434 	movhi	r3,16
811380fc:	18ffffc4 	addi	r3,r3,-1
81138100:	1081ffcc 	andi	r2,r2,2047
81138104:	0241ffc4 	movi	r9,2047
81138108:	28d4703a 	and	r10,r5,r3
8113810c:	4201ffcc 	andi	r8,r8,2047
81138110:	38c6703a 	and	r3,r7,r3
81138114:	280ad7fa 	srli	r5,r5,31
81138118:	380ed7fa 	srli	r7,r7,31
8113811c:	12401f26 	beq	r2,r9,8113819c <__ledf2+0xac>
81138120:	0241ffc4 	movi	r9,2047
81138124:	42401426 	beq	r8,r9,81138178 <__ledf2+0x88>
81138128:	1000091e 	bne	r2,zero,81138150 <__ledf2+0x60>
8113812c:	2296b03a 	or	r11,r4,r10
81138130:	5813003a 	cmpeq	r9,r11,zero
81138134:	29403fcc 	andi	r5,r5,255
81138138:	40000a1e 	bne	r8,zero,81138164 <__ledf2+0x74>
8113813c:	30d8b03a 	or	r12,r6,r3
81138140:	6000081e 	bne	r12,zero,81138164 <__ledf2+0x74>
81138144:	0005883a 	mov	r2,zero
81138148:	5800111e 	bne	r11,zero,81138190 <__ledf2+0xa0>
8113814c:	f800283a 	ret
81138150:	29403fcc 	andi	r5,r5,255
81138154:	40000c1e 	bne	r8,zero,81138188 <__ledf2+0x98>
81138158:	30d2b03a 	or	r9,r6,r3
8113815c:	48000c26 	beq	r9,zero,81138190 <__ledf2+0xa0>
81138160:	0013883a 	mov	r9,zero
81138164:	39c03fcc 	andi	r7,r7,255
81138168:	48000826 	beq	r9,zero,8113818c <__ledf2+0x9c>
8113816c:	38001126 	beq	r7,zero,811381b4 <__ledf2+0xc4>
81138170:	00800044 	movi	r2,1
81138174:	f800283a 	ret
81138178:	30d2b03a 	or	r9,r6,r3
8113817c:	483fea26 	beq	r9,zero,81138128 <__reset+0xfb118128>
81138180:	00800084 	movi	r2,2
81138184:	f800283a 	ret
81138188:	39c03fcc 	andi	r7,r7,255
8113818c:	39400726 	beq	r7,r5,811381ac <__ledf2+0xbc>
81138190:	2800081e 	bne	r5,zero,811381b4 <__ledf2+0xc4>
81138194:	00800044 	movi	r2,1
81138198:	f800283a 	ret
8113819c:	2292b03a 	or	r9,r4,r10
811381a0:	483fdf26 	beq	r9,zero,81138120 <__reset+0xfb118120>
811381a4:	00800084 	movi	r2,2
811381a8:	f800283a 	ret
811381ac:	4080030e 	bge	r8,r2,811381bc <__ledf2+0xcc>
811381b0:	383fef26 	beq	r7,zero,81138170 <__reset+0xfb118170>
811381b4:	00bfffc4 	movi	r2,-1
811381b8:	f800283a 	ret
811381bc:	123feb16 	blt	r2,r8,8113816c <__reset+0xfb11816c>
811381c0:	1abff336 	bltu	r3,r10,81138190 <__reset+0xfb118190>
811381c4:	50c00326 	beq	r10,r3,811381d4 <__ledf2+0xe4>
811381c8:	50c0042e 	bgeu	r10,r3,811381dc <__ledf2+0xec>
811381cc:	283fe81e 	bne	r5,zero,81138170 <__reset+0xfb118170>
811381d0:	003ff806 	br	811381b4 <__reset+0xfb1181b4>
811381d4:	313fee36 	bltu	r6,r4,81138190 <__reset+0xfb118190>
811381d8:	21bffc36 	bltu	r4,r6,811381cc <__reset+0xfb1181cc>
811381dc:	0005883a 	mov	r2,zero
811381e0:	f800283a 	ret

811381e4 <__floatunsidf>:
811381e4:	defffe04 	addi	sp,sp,-8
811381e8:	de00012e 	bgeu	sp,et,811381f0 <__floatunsidf+0xc>
811381ec:	003b68fa 	trap	3
811381f0:	dc000015 	stw	r16,0(sp)
811381f4:	dfc00115 	stw	ra,4(sp)
811381f8:	2021883a 	mov	r16,r4
811381fc:	20002226 	beq	r4,zero,81138288 <__floatunsidf+0xa4>
81138200:	11234780 	call	81123478 <__clzsi2>
81138204:	01010784 	movi	r4,1054
81138208:	2089c83a 	sub	r4,r4,r2
8113820c:	01810cc4 	movi	r6,1075
81138210:	310dc83a 	sub	r6,r6,r4
81138214:	00c007c4 	movi	r3,31
81138218:	1980120e 	bge	r3,r6,81138264 <__floatunsidf+0x80>
8113821c:	00c104c4 	movi	r3,1043
81138220:	1907c83a 	sub	r3,r3,r4
81138224:	80ca983a 	sll	r5,r16,r3
81138228:	00800434 	movhi	r2,16
8113822c:	10bfffc4 	addi	r2,r2,-1
81138230:	2101ffcc 	andi	r4,r4,2047
81138234:	0021883a 	mov	r16,zero
81138238:	288a703a 	and	r5,r5,r2
8113823c:	2008953a 	slli	r4,r4,20
81138240:	00c00434 	movhi	r3,16
81138244:	18ffffc4 	addi	r3,r3,-1
81138248:	28c6703a 	and	r3,r5,r3
8113824c:	8005883a 	mov	r2,r16
81138250:	1906b03a 	or	r3,r3,r4
81138254:	dfc00117 	ldw	ra,4(sp)
81138258:	dc000017 	ldw	r16,0(sp)
8113825c:	dec00204 	addi	sp,sp,8
81138260:	f800283a 	ret
81138264:	00c002c4 	movi	r3,11
81138268:	188bc83a 	sub	r5,r3,r2
8113826c:	814ad83a 	srl	r5,r16,r5
81138270:	00c00434 	movhi	r3,16
81138274:	18ffffc4 	addi	r3,r3,-1
81138278:	81a0983a 	sll	r16,r16,r6
8113827c:	2101ffcc 	andi	r4,r4,2047
81138280:	28ca703a 	and	r5,r5,r3
81138284:	003fed06 	br	8113823c <__reset+0xfb11823c>
81138288:	0009883a 	mov	r4,zero
8113828c:	000b883a 	mov	r5,zero
81138290:	003fea06 	br	8113823c <__reset+0xfb11823c>

81138294 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81138294:	defffb04 	addi	sp,sp,-20
81138298:	de00012e 	bgeu	sp,et,811382a0 <alt_busy_sleep+0xc>
8113829c:	003b68fa 	trap	3
811382a0:	df000415 	stw	fp,16(sp)
811382a4:	df000404 	addi	fp,sp,16
811382a8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
811382ac:	008000c4 	movi	r2,3
811382b0:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
811382b4:	e0fffd17 	ldw	r3,-12(fp)
811382b8:	008003f4 	movhi	r2,15
811382bc:	10909004 	addi	r2,r2,16960
811382c0:	1887383a 	mul	r3,r3,r2
811382c4:	00817db4 	movhi	r2,1526
811382c8:	10b84004 	addi	r2,r2,-7936
811382cc:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
811382d0:	00a00034 	movhi	r2,32768
811382d4:	10bfffc4 	addi	r2,r2,-1
811382d8:	10c5203a 	divu	r2,r2,r3
811382dc:	e0ffff17 	ldw	r3,-4(fp)
811382e0:	1885203a 	divu	r2,r3,r2
811382e4:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811382e8:	e0bffe17 	ldw	r2,-8(fp)
811382ec:	10002526 	beq	r2,zero,81138384 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811382f0:	e03ffc15 	stw	zero,-16(fp)
811382f4:	00001406 	br	81138348 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
811382f8:	00a00034 	movhi	r2,32768
811382fc:	10bfffc4 	addi	r2,r2,-1
81138300:	10bfffc4 	addi	r2,r2,-1
81138304:	103ffe1e 	bne	r2,zero,81138300 <__reset+0xfb118300>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81138308:	e0fffd17 	ldw	r3,-12(fp)
8113830c:	008003f4 	movhi	r2,15
81138310:	10909004 	addi	r2,r2,16960
81138314:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81138318:	00817db4 	movhi	r2,1526
8113831c:	10b84004 	addi	r2,r2,-7936
81138320:	10c7203a 	divu	r3,r2,r3
81138324:	00a00034 	movhi	r2,32768
81138328:	10bfffc4 	addi	r2,r2,-1
8113832c:	10c5203a 	divu	r2,r2,r3
81138330:	e0ffff17 	ldw	r3,-4(fp)
81138334:	1885c83a 	sub	r2,r3,r2
81138338:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
8113833c:	e0bffc17 	ldw	r2,-16(fp)
81138340:	10800044 	addi	r2,r2,1
81138344:	e0bffc15 	stw	r2,-16(fp)
81138348:	e0fffc17 	ldw	r3,-16(fp)
8113834c:	e0bffe17 	ldw	r2,-8(fp)
81138350:	18bfe916 	blt	r3,r2,811382f8 <__reset+0xfb1182f8>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81138354:	e0fffd17 	ldw	r3,-12(fp)
81138358:	008003f4 	movhi	r2,15
8113835c:	10909004 	addi	r2,r2,16960
81138360:	1887383a 	mul	r3,r3,r2
81138364:	00817db4 	movhi	r2,1526
81138368:	10b84004 	addi	r2,r2,-7936
8113836c:	10c7203a 	divu	r3,r2,r3
81138370:	e0bfff17 	ldw	r2,-4(fp)
81138374:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81138378:	10bfffc4 	addi	r2,r2,-1
8113837c:	103ffe1e 	bne	r2,zero,81138378 <__reset+0xfb118378>
81138380:	00000b06 	br	811383b0 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81138384:	e0fffd17 	ldw	r3,-12(fp)
81138388:	008003f4 	movhi	r2,15
8113838c:	10909004 	addi	r2,r2,16960
81138390:	1887383a 	mul	r3,r3,r2
81138394:	00817db4 	movhi	r2,1526
81138398:	10b84004 	addi	r2,r2,-7936
8113839c:	10c7203a 	divu	r3,r2,r3
811383a0:	e0bfff17 	ldw	r2,-4(fp)
811383a4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811383a8:	10bfffc4 	addi	r2,r2,-1
811383ac:	00bffe16 	blt	zero,r2,811383a8 <__reset+0xfb1183a8>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
811383b0:	0005883a 	mov	r2,zero
}
811383b4:	e037883a 	mov	sp,fp
811383b8:	df000017 	ldw	fp,0(sp)
811383bc:	dec00104 	addi	sp,sp,4
811383c0:	f800283a 	ret

811383c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811383c4:	defffe04 	addi	sp,sp,-8
811383c8:	de00012e 	bgeu	sp,et,811383d0 <alt_get_errno+0xc>
811383cc:	003b68fa 	trap	3
811383d0:	dfc00115 	stw	ra,4(sp)
811383d4:	df000015 	stw	fp,0(sp)
811383d8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811383dc:	d0a01017 	ldw	r2,-32704(gp)
811383e0:	10000326 	beq	r2,zero,811383f0 <alt_get_errno+0x2c>
811383e4:	d0a01017 	ldw	r2,-32704(gp)
811383e8:	103ee83a 	callr	r2
811383ec:	00000106 	br	811383f4 <alt_get_errno+0x30>
811383f0:	d0a07804 	addi	r2,gp,-32288
}
811383f4:	e037883a 	mov	sp,fp
811383f8:	dfc00117 	ldw	ra,4(sp)
811383fc:	df000017 	ldw	fp,0(sp)
81138400:	dec00204 	addi	sp,sp,8
81138404:	f800283a 	ret

81138408 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81138408:	defffb04 	addi	sp,sp,-20
8113840c:	de00012e 	bgeu	sp,et,81138414 <close+0xc>
81138410:	003b68fa 	trap	3
81138414:	dfc00415 	stw	ra,16(sp)
81138418:	df000315 	stw	fp,12(sp)
8113841c:	df000304 	addi	fp,sp,12
81138420:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81138424:	e0bfff17 	ldw	r2,-4(fp)
81138428:	10000616 	blt	r2,zero,81138444 <close+0x3c>
8113842c:	e0bfff17 	ldw	r2,-4(fp)
81138430:	10c00324 	muli	r3,r2,12
81138434:	00a04574 	movhi	r2,33045
81138438:	108f4404 	addi	r2,r2,15632
8113843c:	1885883a 	add	r2,r3,r2
81138440:	00000106 	br	81138448 <close+0x40>
81138444:	0005883a 	mov	r2,zero
81138448:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8113844c:	e0bffd17 	ldw	r2,-12(fp)
81138450:	10001926 	beq	r2,zero,811384b8 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81138454:	e0bffd17 	ldw	r2,-12(fp)
81138458:	10800017 	ldw	r2,0(r2)
8113845c:	10800417 	ldw	r2,16(r2)
81138460:	10000626 	beq	r2,zero,8113847c <close+0x74>
81138464:	e0bffd17 	ldw	r2,-12(fp)
81138468:	10800017 	ldw	r2,0(r2)
8113846c:	10800417 	ldw	r2,16(r2)
81138470:	e13ffd17 	ldw	r4,-12(fp)
81138474:	103ee83a 	callr	r2
81138478:	00000106 	br	81138480 <close+0x78>
8113847c:	0005883a 	mov	r2,zero
81138480:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81138484:	e13fff17 	ldw	r4,-4(fp)
81138488:	11399ec0 	call	811399ec <alt_release_fd>
    if (rval < 0)
8113848c:	e0bffe17 	ldw	r2,-8(fp)
81138490:	1000070e 	bge	r2,zero,811384b0 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81138494:	11383c40 	call	811383c4 <alt_get_errno>
81138498:	1007883a 	mov	r3,r2
8113849c:	e0bffe17 	ldw	r2,-8(fp)
811384a0:	0085c83a 	sub	r2,zero,r2
811384a4:	18800015 	stw	r2,0(r3)
      return -1;
811384a8:	00bfffc4 	movi	r2,-1
811384ac:	00000706 	br	811384cc <close+0xc4>
    }
    return 0;
811384b0:	0005883a 	mov	r2,zero
811384b4:	00000506 	br	811384cc <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
811384b8:	11383c40 	call	811383c4 <alt_get_errno>
811384bc:	1007883a 	mov	r3,r2
811384c0:	00801444 	movi	r2,81
811384c4:	18800015 	stw	r2,0(r3)
    return -1;
811384c8:	00bfffc4 	movi	r2,-1
  }
}
811384cc:	e037883a 	mov	sp,fp
811384d0:	dfc00117 	ldw	ra,4(sp)
811384d4:	df000017 	ldw	fp,0(sp)
811384d8:	dec00204 	addi	sp,sp,8
811384dc:	f800283a 	ret

811384e0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811384e0:	deffff04 	addi	sp,sp,-4
811384e4:	de00012e 	bgeu	sp,et,811384ec <alt_dcache_flush_all+0xc>
811384e8:	003b68fa 	trap	3
811384ec:	df000015 	stw	fp,0(sp)
811384f0:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
811384f4:	0001883a 	nop
811384f8:	e037883a 	mov	sp,fp
811384fc:	df000017 	ldw	fp,0(sp)
81138500:	dec00104 	addi	sp,sp,4
81138504:	f800283a 	ret

81138508 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81138508:	defffc04 	addi	sp,sp,-16
8113850c:	de00012e 	bgeu	sp,et,81138514 <alt_dev_null_write+0xc>
81138510:	003b68fa 	trap	3
81138514:	df000315 	stw	fp,12(sp)
81138518:	df000304 	addi	fp,sp,12
8113851c:	e13ffd15 	stw	r4,-12(fp)
81138520:	e17ffe15 	stw	r5,-8(fp)
81138524:	e1bfff15 	stw	r6,-4(fp)
  return len;
81138528:	e0bfff17 	ldw	r2,-4(fp)
}
8113852c:	e037883a 	mov	sp,fp
81138530:	df000017 	ldw	fp,0(sp)
81138534:	dec00104 	addi	sp,sp,4
81138538:	f800283a 	ret

8113853c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113853c:	defffe04 	addi	sp,sp,-8
81138540:	de00012e 	bgeu	sp,et,81138548 <alt_get_errno+0xc>
81138544:	003b68fa 	trap	3
81138548:	dfc00115 	stw	ra,4(sp)
8113854c:	df000015 	stw	fp,0(sp)
81138550:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138554:	d0a01017 	ldw	r2,-32704(gp)
81138558:	10000326 	beq	r2,zero,81138568 <alt_get_errno+0x2c>
8113855c:	d0a01017 	ldw	r2,-32704(gp)
81138560:	103ee83a 	callr	r2
81138564:	00000106 	br	8113856c <alt_get_errno+0x30>
81138568:	d0a07804 	addi	r2,gp,-32288
}
8113856c:	e037883a 	mov	sp,fp
81138570:	dfc00117 	ldw	ra,4(sp)
81138574:	df000017 	ldw	fp,0(sp)
81138578:	dec00204 	addi	sp,sp,8
8113857c:	f800283a 	ret

81138580 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81138580:	defffb04 	addi	sp,sp,-20
81138584:	de00012e 	bgeu	sp,et,8113858c <fstat+0xc>
81138588:	003b68fa 	trap	3
8113858c:	dfc00415 	stw	ra,16(sp)
81138590:	df000315 	stw	fp,12(sp)
81138594:	df000304 	addi	fp,sp,12
81138598:	e13ffe15 	stw	r4,-8(fp)
8113859c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811385a0:	e0bffe17 	ldw	r2,-8(fp)
811385a4:	10000616 	blt	r2,zero,811385c0 <fstat+0x40>
811385a8:	e0bffe17 	ldw	r2,-8(fp)
811385ac:	10c00324 	muli	r3,r2,12
811385b0:	00a04574 	movhi	r2,33045
811385b4:	108f4404 	addi	r2,r2,15632
811385b8:	1885883a 	add	r2,r3,r2
811385bc:	00000106 	br	811385c4 <fstat+0x44>
811385c0:	0005883a 	mov	r2,zero
811385c4:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811385c8:	e0bffd17 	ldw	r2,-12(fp)
811385cc:	10001026 	beq	r2,zero,81138610 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
811385d0:	e0bffd17 	ldw	r2,-12(fp)
811385d4:	10800017 	ldw	r2,0(r2)
811385d8:	10800817 	ldw	r2,32(r2)
811385dc:	10000726 	beq	r2,zero,811385fc <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811385e0:	e0bffd17 	ldw	r2,-12(fp)
811385e4:	10800017 	ldw	r2,0(r2)
811385e8:	10800817 	ldw	r2,32(r2)
811385ec:	e17fff17 	ldw	r5,-4(fp)
811385f0:	e13ffd17 	ldw	r4,-12(fp)
811385f4:	103ee83a 	callr	r2
811385f8:	00000a06 	br	81138624 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
811385fc:	e0bfff17 	ldw	r2,-4(fp)
81138600:	00c80004 	movi	r3,8192
81138604:	10c00115 	stw	r3,4(r2)
      return 0;
81138608:	0005883a 	mov	r2,zero
8113860c:	00000506 	br	81138624 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81138610:	113853c0 	call	8113853c <alt_get_errno>
81138614:	1007883a 	mov	r3,r2
81138618:	00801444 	movi	r2,81
8113861c:	18800015 	stw	r2,0(r3)
    return -1;
81138620:	00bfffc4 	movi	r2,-1
  }
}
81138624:	e037883a 	mov	sp,fp
81138628:	dfc00117 	ldw	ra,4(sp)
8113862c:	df000017 	ldw	fp,0(sp)
81138630:	dec00204 	addi	sp,sp,8
81138634:	f800283a 	ret

81138638 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81138638:	defff004 	addi	sp,sp,-64
8113863c:	de00012e 	bgeu	sp,et,81138644 <alt_irq_register+0xc>
81138640:	003b68fa 	trap	3
81138644:	df000f15 	stw	fp,60(sp)
81138648:	df000f04 	addi	fp,sp,60
8113864c:	e13ffd15 	stw	r4,-12(fp)
81138650:	e17ffe15 	stw	r5,-8(fp)
81138654:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81138658:	00bffa84 	movi	r2,-22
8113865c:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81138660:	e0bffd17 	ldw	r2,-12(fp)
81138664:	10800828 	cmpgeui	r2,r2,32
81138668:	1000501e 	bne	r2,zero,811387ac <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113866c:	0005303a 	rdctl	r2,status
81138670:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138674:	e0fff617 	ldw	r3,-40(fp)
81138678:	00bfff84 	movi	r2,-2
8113867c:	1884703a 	and	r2,r3,r2
81138680:	1001703a 	wrctl	status,r2
  
  return context;
81138684:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81138688:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
8113868c:	00a045f4 	movhi	r2,33047
81138690:	10bce904 	addi	r2,r2,-3164
81138694:	e0fffd17 	ldw	r3,-12(fp)
81138698:	180690fa 	slli	r3,r3,3
8113869c:	10c5883a 	add	r2,r2,r3
811386a0:	e0ffff17 	ldw	r3,-4(fp)
811386a4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
811386a8:	00a045f4 	movhi	r2,33047
811386ac:	10bce904 	addi	r2,r2,-3164
811386b0:	e0fffd17 	ldw	r3,-12(fp)
811386b4:	180690fa 	slli	r3,r3,3
811386b8:	10c5883a 	add	r2,r2,r3
811386bc:	10800104 	addi	r2,r2,4
811386c0:	e0fffe17 	ldw	r3,-8(fp)
811386c4:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811386c8:	e0bfff17 	ldw	r2,-4(fp)
811386cc:	10001926 	beq	r2,zero,81138734 <alt_irq_register+0xfc>
811386d0:	e0bffd17 	ldw	r2,-12(fp)
811386d4:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811386d8:	0005303a 	rdctl	r2,status
811386dc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811386e0:	e0fff717 	ldw	r3,-36(fp)
811386e4:	00bfff84 	movi	r2,-2
811386e8:	1884703a 	and	r2,r3,r2
811386ec:	1001703a 	wrctl	status,r2
  
  return context;
811386f0:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811386f4:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
811386f8:	00c00044 	movi	r3,1
811386fc:	e0bff217 	ldw	r2,-56(fp)
81138700:	1884983a 	sll	r2,r3,r2
81138704:	1007883a 	mov	r3,r2
81138708:	d0a08017 	ldw	r2,-32256(gp)
8113870c:	1884b03a 	or	r2,r3,r2
81138710:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81138714:	d0a08017 	ldw	r2,-32256(gp)
81138718:	100170fa 	wrctl	ienable,r2
8113871c:	e0bff817 	ldw	r2,-32(fp)
81138720:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138724:	e0bff917 	ldw	r2,-28(fp)
81138728:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113872c:	0005883a 	mov	r2,zero
81138730:	00001906 	br	81138798 <alt_irq_register+0x160>
81138734:	e0bffd17 	ldw	r2,-12(fp)
81138738:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113873c:	0005303a 	rdctl	r2,status
81138740:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138744:	e0fffa17 	ldw	r3,-24(fp)
81138748:	00bfff84 	movi	r2,-2
8113874c:	1884703a 	and	r2,r3,r2
81138750:	1001703a 	wrctl	status,r2
  
  return context;
81138754:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81138758:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
8113875c:	00c00044 	movi	r3,1
81138760:	e0bff417 	ldw	r2,-48(fp)
81138764:	1884983a 	sll	r2,r3,r2
81138768:	0084303a 	nor	r2,zero,r2
8113876c:	1007883a 	mov	r3,r2
81138770:	d0a08017 	ldw	r2,-32256(gp)
81138774:	1884703a 	and	r2,r3,r2
81138778:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8113877c:	d0a08017 	ldw	r2,-32256(gp)
81138780:	100170fa 	wrctl	ienable,r2
81138784:	e0bffb17 	ldw	r2,-20(fp)
81138788:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113878c:	e0bffc17 	ldw	r2,-16(fp)
81138790:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81138794:	0005883a 	mov	r2,zero
81138798:	e0bff115 	stw	r2,-60(fp)
8113879c:	e0bff317 	ldw	r2,-52(fp)
811387a0:	e0bff515 	stw	r2,-44(fp)
811387a4:	e0bff517 	ldw	r2,-44(fp)
811387a8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
811387ac:	e0bff117 	ldw	r2,-60(fp)
}
811387b0:	e037883a 	mov	sp,fp
811387b4:	df000017 	ldw	fp,0(sp)
811387b8:	dec00104 	addi	sp,sp,4
811387bc:	f800283a 	ret

811387c0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811387c0:	defffe04 	addi	sp,sp,-8
811387c4:	de00012e 	bgeu	sp,et,811387cc <alt_get_errno+0xc>
811387c8:	003b68fa 	trap	3
811387cc:	dfc00115 	stw	ra,4(sp)
811387d0:	df000015 	stw	fp,0(sp)
811387d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811387d8:	d0a01017 	ldw	r2,-32704(gp)
811387dc:	10000326 	beq	r2,zero,811387ec <alt_get_errno+0x2c>
811387e0:	d0a01017 	ldw	r2,-32704(gp)
811387e4:	103ee83a 	callr	r2
811387e8:	00000106 	br	811387f0 <alt_get_errno+0x30>
811387ec:	d0a07804 	addi	r2,gp,-32288
}
811387f0:	e037883a 	mov	sp,fp
811387f4:	dfc00117 	ldw	ra,4(sp)
811387f8:	df000017 	ldw	fp,0(sp)
811387fc:	dec00204 	addi	sp,sp,8
81138800:	f800283a 	ret

81138804 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81138804:	deffed04 	addi	sp,sp,-76
81138808:	de00012e 	bgeu	sp,et,81138810 <isatty+0xc>
8113880c:	003b68fa 	trap	3
81138810:	dfc01215 	stw	ra,72(sp)
81138814:	df001115 	stw	fp,68(sp)
81138818:	df001104 	addi	fp,sp,68
8113881c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81138820:	e0bfff17 	ldw	r2,-4(fp)
81138824:	10000616 	blt	r2,zero,81138840 <isatty+0x3c>
81138828:	e0bfff17 	ldw	r2,-4(fp)
8113882c:	10c00324 	muli	r3,r2,12
81138830:	00a04574 	movhi	r2,33045
81138834:	108f4404 	addi	r2,r2,15632
81138838:	1885883a 	add	r2,r3,r2
8113883c:	00000106 	br	81138844 <isatty+0x40>
81138840:	0005883a 	mov	r2,zero
81138844:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81138848:	e0bfef17 	ldw	r2,-68(fp)
8113884c:	10000e26 	beq	r2,zero,81138888 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81138850:	e0bfef17 	ldw	r2,-68(fp)
81138854:	10800017 	ldw	r2,0(r2)
81138858:	10800817 	ldw	r2,32(r2)
8113885c:	1000021e 	bne	r2,zero,81138868 <isatty+0x64>
    {
      return 1;
81138860:	00800044 	movi	r2,1
81138864:	00000d06 	br	8113889c <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81138868:	e0bff004 	addi	r2,fp,-64
8113886c:	100b883a 	mov	r5,r2
81138870:	e13fff17 	ldw	r4,-4(fp)
81138874:	11385800 	call	81138580 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81138878:	e0bff117 	ldw	r2,-60(fp)
8113887c:	10880020 	cmpeqi	r2,r2,8192
81138880:	10803fcc 	andi	r2,r2,255
81138884:	00000506 	br	8113889c <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81138888:	11387c00 	call	811387c0 <alt_get_errno>
8113888c:	1007883a 	mov	r3,r2
81138890:	00801444 	movi	r2,81
81138894:	18800015 	stw	r2,0(r3)
    return 0;
81138898:	0005883a 	mov	r2,zero
  }
}
8113889c:	e037883a 	mov	sp,fp
811388a0:	dfc00117 	ldw	ra,4(sp)
811388a4:	df000017 	ldw	fp,0(sp)
811388a8:	dec00204 	addi	sp,sp,8
811388ac:	f800283a 	ret

811388b0 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
811388b0:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
811388b4:	318c2404 	addi	r6,r6,12432

811388b8 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
811388b8:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
811388bc:	01c00826 	beq	zero,r7,811388e0 <end_tx>

811388c0 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
811388c0:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
811388c4:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
811388c8:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
811388cc:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
811388d0:	283ffb26 	beq	r5,zero,811388c0 <__reset+0xfb1188c0>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
811388d4:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
811388d8:	21000044 	addi	r4,r4,1
	br tx_next_char
811388dc:	003ff606 	br	811388b8 <__reset+0xfb1188b8>

811388e0 <end_tx>:
end_tx:	
        ret
811388e0:	f800283a 	ret

811388e4 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
811388e4:	defffd04 	addi	sp,sp,-12
811388e8:	de00012e 	bgeu	sp,et,811388f0 <alt_log_txchar+0xc>
811388ec:	003b68fa 	trap	3
811388f0:	df000215 	stw	fp,8(sp)
811388f4:	df000204 	addi	fp,sp,8
811388f8:	e13ffe15 	stw	r4,-8(fp)
811388fc:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81138900:	0001883a 	nop
81138904:	e0bfff17 	ldw	r2,-4(fp)
81138908:	10800104 	addi	r2,r2,4
8113890c:	10800037 	ldwio	r2,0(r2)
81138910:	10bfffec 	andhi	r2,r2,65535
81138914:	103ffb26 	beq	r2,zero,81138904 <__reset+0xfb118904>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81138918:	e0bfff17 	ldw	r2,-4(fp)
8113891c:	e0fffe17 	ldw	r3,-8(fp)
81138920:	10c00035 	stwio	r3,0(r2)
}
81138924:	0001883a 	nop
81138928:	e037883a 	mov	sp,fp
8113892c:	df000017 	ldw	fp,0(sp)
81138930:	dec00104 	addi	sp,sp,4
81138934:	f800283a 	ret

81138938 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81138938:	defffb04 	addi	sp,sp,-20
8113893c:	de00012e 	bgeu	sp,et,81138944 <alt_log_repchar+0xc>
81138940:	003b68fa 	trap	3
81138944:	dfc00415 	stw	ra,16(sp)
81138948:	df000315 	stw	fp,12(sp)
8113894c:	df000304 	addi	fp,sp,12
81138950:	2005883a 	mov	r2,r4
81138954:	e17ffe15 	stw	r5,-8(fp)
81138958:	e1bfff15 	stw	r6,-4(fp)
8113895c:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81138960:	00000506 	br	81138978 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81138964:	e0bffd07 	ldb	r2,-12(fp)
81138968:	e0ffff17 	ldw	r3,-4(fp)
8113896c:	180b883a 	mov	r5,r3
81138970:	1009883a 	mov	r4,r2
81138974:	11388e40 	call	811388e4 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81138978:	e0bffe17 	ldw	r2,-8(fp)
8113897c:	10ffffc4 	addi	r3,r2,-1
81138980:	e0fffe15 	stw	r3,-8(fp)
81138984:	00bff716 	blt	zero,r2,81138964 <__reset+0xfb118964>
    alt_log_txchar(c,(char*) base);
}
81138988:	0001883a 	nop
8113898c:	e037883a 	mov	sp,fp
81138990:	dfc00117 	ldw	ra,4(sp)
81138994:	df000017 	ldw	fp,0(sp)
81138998:	dec00204 	addi	sp,sp,8
8113899c:	f800283a 	ret

811389a0 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
811389a0:	deffe904 	addi	sp,sp,-92
811389a4:	de00012e 	bgeu	sp,et,811389ac <alt_log_private_printf+0xc>
811389a8:	003b68fa 	trap	3
811389ac:	dfc01615 	stw	ra,88(sp)
811389b0:	df001515 	stw	fp,84(sp)
811389b4:	dc001415 	stw	r16,80(sp)
811389b8:	df001504 	addi	fp,sp,84
811389bc:	e13ffc15 	stw	r4,-16(fp)
811389c0:	e17ffd15 	stw	r5,-12(fp)
811389c4:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811389c8:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811389cc:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
811389d0:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
811389d4:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
811389d8:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
811389dc:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
811389e0:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
811389e4:	e0bffc17 	ldw	r2,-16(fp)
811389e8:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811389ec:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811389f0:	00014b06 	br	81138f20 <alt_log_private_printf+0x580>
    {
    switch(state)
811389f4:	e0bfec17 	ldw	r2,-80(fp)
811389f8:	10c00060 	cmpeqi	r3,r2,1
811389fc:	18001b1e 	bne	r3,zero,81138a6c <alt_log_private_printf+0xcc>
81138a00:	10c000a0 	cmpeqi	r3,r2,2
81138a04:	18002d1e 	bne	r3,zero,81138abc <alt_log_private_printf+0x11c>
81138a08:	10000126 	beq	r2,zero,81138a10 <alt_log_private_printf+0x70>
81138a0c:	00014406 	br	81138f20 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81138a10:	e0bffb07 	ldb	r2,-20(fp)
81138a14:	10800958 	cmpnei	r2,r2,37
81138a18:	10000e1e 	bne	r2,zero,81138a54 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81138a1c:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81138a20:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81138a24:	00800284 	movi	r2,10
81138a28:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81138a2c:	00800044 	movi	r2,1
81138a30:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81138a34:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81138a38:	00bfffc4 	movi	r2,-1
81138a3c:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81138a40:	00bfffc4 	movi	r2,-1
81138a44:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81138a48:	00800044 	movi	r2,1
81138a4c:	e0bfec15 	stw	r2,-80(fp)
81138a50:	00013306 	br	81138f20 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81138a54:	e0bffb07 	ldb	r2,-20(fp)
81138a58:	e0fffd17 	ldw	r3,-12(fp)
81138a5c:	180b883a 	mov	r5,r3
81138a60:	1009883a 	mov	r4,r2
81138a64:	11388e40 	call	811388e4 <alt_log_txchar>
        }
        break;
81138a68:	00012d06 	br	81138f20 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81138a6c:	e0bffb07 	ldb	r2,-20(fp)
81138a70:	10800c18 	cmpnei	r2,r2,48
81138a74:	1000051e 	bne	r2,zero,81138a8c <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81138a78:	00800044 	movi	r2,1
81138a7c:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81138a80:	00800084 	movi	r2,2
81138a84:	e0bfec15 	stw	r2,-80(fp)
81138a88:	00012506 	br	81138f20 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81138a8c:	e0bffb07 	ldb	r2,-20(fp)
81138a90:	10800958 	cmpnei	r2,r2,37
81138a94:	1000071e 	bne	r2,zero,81138ab4 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81138a98:	e0bffb07 	ldb	r2,-20(fp)
81138a9c:	e0fffd17 	ldw	r3,-12(fp)
81138aa0:	180b883a 	mov	r5,r3
81138aa4:	1009883a 	mov	r4,r2
81138aa8:	11388e40 	call	811388e4 <alt_log_txchar>
          state = pfState_chars;
81138aac:	e03fec15 	stw	zero,-80(fp)
81138ab0:	00011b06 	br	81138f20 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81138ab4:	00800084 	movi	r2,2
81138ab8:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81138abc:	e0bffb07 	ldb	r2,-20(fp)
81138ac0:	10800b98 	cmpnei	r2,r2,46
81138ac4:	1000021e 	bne	r2,zero,81138ad0 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81138ac8:	e03ff015 	stw	zero,-64(fp)
81138acc:	00011306 	br	81138f1c <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81138ad0:	e0bffb07 	ldb	r2,-20(fp)
81138ad4:	10800c10 	cmplti	r2,r2,48
81138ad8:	10001a1e 	bne	r2,zero,81138b44 <alt_log_private_printf+0x1a4>
81138adc:	e0bffb07 	ldb	r2,-20(fp)
81138ae0:	10800e88 	cmpgei	r2,r2,58
81138ae4:	1000171e 	bne	r2,zero,81138b44 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81138ae8:	e0bffb03 	ldbu	r2,-20(fp)
81138aec:	10bff404 	addi	r2,r2,-48
81138af0:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81138af4:	e0bff017 	ldw	r2,-64(fp)
81138af8:	10000c0e 	bge	r2,zero,81138b2c <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81138afc:	e0bfef17 	ldw	r2,-68(fp)
81138b00:	1000020e 	bge	r2,zero,81138b0c <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81138b04:	e03fef15 	stw	zero,-68(fp)
81138b08:	00000306 	br	81138b18 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81138b0c:	e0bfef17 	ldw	r2,-68(fp)
81138b10:	108002a4 	muli	r2,r2,10
81138b14:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81138b18:	e0bffb07 	ldb	r2,-20(fp)
81138b1c:	e0ffef17 	ldw	r3,-68(fp)
81138b20:	1885883a 	add	r2,r3,r2
81138b24:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81138b28:	0000fc06 	br	81138f1c <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81138b2c:	e0bff017 	ldw	r2,-64(fp)
81138b30:	10c002a4 	muli	r3,r2,10
81138b34:	e0bffb07 	ldb	r2,-20(fp)
81138b38:	1885883a 	add	r2,r3,r2
81138b3c:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81138b40:	0000f606 	br	81138f1c <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81138b44:	e0bffb07 	ldb	r2,-20(fp)
81138b48:	10801b18 	cmpnei	r2,r2,108
81138b4c:	1000031e 	bne	r2,zero,81138b5c <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81138b50:	00800044 	movi	r2,1
81138b54:	e0bfee15 	stw	r2,-72(fp)
81138b58:	0000f006 	br	81138f1c <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81138b5c:	e0bffb07 	ldb	r2,-20(fp)
81138b60:	10bfea04 	addi	r2,r2,-88
81138b64:	10c00868 	cmpgeui	r3,r2,33
81138b68:	1800eb1e 	bne	r3,zero,81138f18 <alt_log_private_printf+0x578>
81138b6c:	100690ba 	slli	r3,r2,2
81138b70:	00a04534 	movhi	r2,33044
81138b74:	10a2e104 	addi	r2,r2,-29820
81138b78:	1885883a 	add	r2,r3,r2
81138b7c:	10800017 	ldw	r2,0(r2)
81138b80:	1000683a 	jmp	r2
81138b84:	81138e44 	addi	r4,r16,20025
81138b88:	81138f18 	cmpnei	r4,r16,20028
81138b8c:	81138f18 	cmpnei	r4,r16,20028
81138b90:	81138f18 	cmpnei	r4,r16,20028
81138b94:	81138f18 	cmpnei	r4,r16,20028
81138b98:	81138f18 	cmpnei	r4,r16,20028
81138b9c:	81138f18 	cmpnei	r4,r16,20028
81138ba0:	81138f18 	cmpnei	r4,r16,20028
81138ba4:	81138f18 	cmpnei	r4,r16,20028
81138ba8:	81138f18 	cmpnei	r4,r16,20028
81138bac:	81138f18 	cmpnei	r4,r16,20028
81138bb0:	81138e5c 	xori	r4,r16,20025
81138bb4:	81138c08 	cmpgei	r4,r16,20016
81138bb8:	81138f18 	cmpnei	r4,r16,20028
81138bbc:	81138f18 	cmpnei	r4,r16,20028
81138bc0:	81138f18 	cmpnei	r4,r16,20028
81138bc4:	81138f18 	cmpnei	r4,r16,20028
81138bc8:	81138c08 	cmpgei	r4,r16,20016
81138bcc:	81138f18 	cmpnei	r4,r16,20028
81138bd0:	81138f18 	cmpnei	r4,r16,20028
81138bd4:	81138f18 	cmpnei	r4,r16,20028
81138bd8:	81138f18 	cmpnei	r4,r16,20028
81138bdc:	81138f18 	cmpnei	r4,r16,20028
81138be0:	81138e24 	muli	r4,r16,20024
81138be4:	81138f18 	cmpnei	r4,r16,20028
81138be8:	81138f18 	cmpnei	r4,r16,20028
81138bec:	81138f18 	cmpnei	r4,r16,20028
81138bf0:	81138e98 	cmpnei	r4,r16,20026
81138bf4:	81138f18 	cmpnei	r4,r16,20028
81138bf8:	81138e1c 	xori	r4,r16,20024
81138bfc:	81138f18 	cmpnei	r4,r16,20028
81138c00:	81138f18 	cmpnei	r4,r16,20028
81138c04:	81138e34 	orhi	r4,r16,20024
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81138c08:	e0bfee17 	ldw	r2,-72(fp)
81138c0c:	10000e26 	beq	r2,zero,81138c48 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81138c10:	e0bff217 	ldw	r2,-56(fp)
81138c14:	10000626 	beq	r2,zero,81138c30 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81138c18:	e0bffe17 	ldw	r2,-8(fp)
81138c1c:	10c00104 	addi	r3,r2,4
81138c20:	e0fffe15 	stw	r3,-8(fp)
81138c24:	10800017 	ldw	r2,0(r2)
81138c28:	e0bff415 	stw	r2,-48(fp)
81138c2c:	00001306 	br	81138c7c <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81138c30:	e0bffe17 	ldw	r2,-8(fp)
81138c34:	10c00104 	addi	r3,r2,4
81138c38:	e0fffe15 	stw	r3,-8(fp)
81138c3c:	10800017 	ldw	r2,0(r2)
81138c40:	e0bff415 	stw	r2,-48(fp)
81138c44:	00000d06 	br	81138c7c <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81138c48:	e0bff217 	ldw	r2,-56(fp)
81138c4c:	10000626 	beq	r2,zero,81138c68 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81138c50:	e0bffe17 	ldw	r2,-8(fp)
81138c54:	10c00104 	addi	r3,r2,4
81138c58:	e0fffe15 	stw	r3,-8(fp)
81138c5c:	10800017 	ldw	r2,0(r2)
81138c60:	e0bff415 	stw	r2,-48(fp)
81138c64:	00000506 	br	81138c7c <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81138c68:	e0bffe17 	ldw	r2,-8(fp)
81138c6c:	10c00104 	addi	r3,r2,4
81138c70:	e0fffe15 	stw	r3,-8(fp)
81138c74:	10800017 	ldw	r2,0(r2)
81138c78:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81138c7c:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81138c80:	e0bff217 	ldw	r2,-56(fp)
81138c84:	10000726 	beq	r2,zero,81138ca4 <alt_log_private_printf+0x304>
81138c88:	e0bff417 	ldw	r2,-48(fp)
81138c8c:	1000050e 	bge	r2,zero,81138ca4 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81138c90:	e0bff417 	ldw	r2,-48(fp)
81138c94:	0085c83a 	sub	r2,zero,r2
81138c98:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81138c9c:	00800044 	movi	r2,1
81138ca0:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81138ca4:	e0bff417 	ldw	r2,-48(fp)
81138ca8:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81138cac:	00800044 	movi	r2,1
81138cb0:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81138cb4:	00800044 	movi	r2,1
81138cb8:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81138cbc:	00000706 	br	81138cdc <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81138cc0:	e0bff817 	ldw	r2,-32(fp)
81138cc4:	10800044 	addi	r2,r2,1
81138cc8:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81138ccc:	e0bff117 	ldw	r2,-60(fp)
81138cd0:	e0fff517 	ldw	r3,-44(fp)
81138cd4:	1885383a 	mul	r2,r3,r2
81138cd8:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81138cdc:	e0bff117 	ldw	r2,-60(fp)
81138ce0:	e0fff617 	ldw	r3,-40(fp)
81138ce4:	1885203a 	divu	r2,r3,r2
81138ce8:	e0bff615 	stw	r2,-40(fp)
81138cec:	e0bff617 	ldw	r2,-40(fp)
81138cf0:	103ff31e 	bne	r2,zero,81138cc0 <__reset+0xfb118cc0>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81138cf4:	e0ffef17 	ldw	r3,-68(fp)
81138cf8:	e0bff817 	ldw	r2,-32(fp)
81138cfc:	1885c83a 	sub	r2,r3,r2
81138d00:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81138d04:	e0bfed17 	ldw	r2,-76(fp)
81138d08:	10000e26 	beq	r2,zero,81138d44 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81138d0c:	e0bff717 	ldw	r2,-36(fp)
81138d10:	10000726 	beq	r2,zero,81138d30 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81138d14:	e0bffd17 	ldw	r2,-12(fp)
81138d18:	100b883a 	mov	r5,r2
81138d1c:	01000b44 	movi	r4,45
81138d20:	11388e40 	call	811388e4 <alt_log_txchar>
                    fmtBeforeDecimal--;
81138d24:	e0bfef17 	ldw	r2,-68(fp)
81138d28:	10bfffc4 	addi	r2,r2,-1
81138d2c:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81138d30:	e1bffd17 	ldw	r6,-12(fp)
81138d34:	e17fef17 	ldw	r5,-68(fp)
81138d38:	01000c04 	movi	r4,48
81138d3c:	11389380 	call	81138938 <alt_log_repchar>
81138d40:	00003206 	br	81138e0c <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81138d44:	e0bff717 	ldw	r2,-36(fp)
81138d48:	10000326 	beq	r2,zero,81138d58 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81138d4c:	e0bfef17 	ldw	r2,-68(fp)
81138d50:	10bfffc4 	addi	r2,r2,-1
81138d54:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81138d58:	e1bffd17 	ldw	r6,-12(fp)
81138d5c:	e17fef17 	ldw	r5,-68(fp)
81138d60:	01000804 	movi	r4,32
81138d64:	11389380 	call	81138938 <alt_log_repchar>
                    if(sign)
81138d68:	e0bff717 	ldw	r2,-36(fp)
81138d6c:	10002726 	beq	r2,zero,81138e0c <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81138d70:	e0bffd17 	ldw	r2,-12(fp)
81138d74:	100b883a 	mov	r5,r2
81138d78:	01000b44 	movi	r4,45
81138d7c:	11388e40 	call	811388e4 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81138d80:	00002206 	br	81138e0c <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81138d84:	e0fff417 	ldw	r3,-48(fp)
81138d88:	e0bff517 	ldw	r2,-44(fp)
81138d8c:	1885203a 	divu	r2,r3,r2
81138d90:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81138d94:	e0bff903 	ldbu	r2,-28(fp)
81138d98:	10800c04 	addi	r2,r2,48
81138d9c:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81138da0:	e0bff903 	ldbu	r2,-28(fp)
81138da4:	10800eb0 	cmpltui	r2,r2,58
81138da8:	1000081e 	bne	r2,zero,81138dcc <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81138dac:	e0bff317 	ldw	r2,-52(fp)
81138db0:	10000226 	beq	r2,zero,81138dbc <alt_log_private_printf+0x41c>
81138db4:	008001c4 	movi	r2,7
81138db8:	00000106 	br	81138dc0 <alt_log_private_printf+0x420>
81138dbc:	008009c4 	movi	r2,39
81138dc0:	e0fff903 	ldbu	r3,-28(fp)
81138dc4:	10c5883a 	add	r2,r2,r3
81138dc8:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81138dcc:	e0bff903 	ldbu	r2,-28(fp)
81138dd0:	e0fffd17 	ldw	r3,-12(fp)
81138dd4:	180b883a 	mov	r5,r3
81138dd8:	1009883a 	mov	r4,r2
81138ddc:	11388e40 	call	811388e4 <alt_log_txchar>

                  v = v % p;
81138de0:	e0bff417 	ldw	r2,-48(fp)
81138de4:	e0fff517 	ldw	r3,-44(fp)
81138de8:	10c9203a 	divu	r4,r2,r3
81138dec:	e0fff517 	ldw	r3,-44(fp)
81138df0:	20c7383a 	mul	r3,r4,r3
81138df4:	10c5c83a 	sub	r2,r2,r3
81138df8:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81138dfc:	e0bff117 	ldw	r2,-60(fp)
81138e00:	e0fff517 	ldw	r3,-44(fp)
81138e04:	1885203a 	divu	r2,r3,r2
81138e08:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81138e0c:	e0bff517 	ldw	r2,-44(fp)
81138e10:	103fdc1e 	bne	r2,zero,81138d84 <__reset+0xfb118d84>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81138e14:	e03fec15 	stw	zero,-80(fp)
              break;
81138e18:	00003f06 	br	81138f18 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81138e1c:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81138e20:	003f7906 	br	81138c08 <__reset+0xfb118c08>
            case 'o':
              fmtSigned = 0;
81138e24:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81138e28:	00800204 	movi	r2,8
81138e2c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138e30:	003f7506 	br	81138c08 <__reset+0xfb118c08>
            case 'x':
              fmtSigned = 0;
81138e34:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138e38:	00800404 	movi	r2,16
81138e3c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138e40:	003f7106 	br	81138c08 <__reset+0xfb118c08>
            case 'X':
              fmtSigned = 0;
81138e44:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138e48:	00800404 	movi	r2,16
81138e4c:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81138e50:	00800044 	movi	r2,1
81138e54:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81138e58:	003f6b06 	br	81138c08 <__reset+0xfb118c08>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81138e5c:	e0bfef17 	ldw	r2,-68(fp)
81138e60:	10bfffc4 	addi	r2,r2,-1
81138e64:	e1bffd17 	ldw	r6,-12(fp)
81138e68:	100b883a 	mov	r5,r2
81138e6c:	01000804 	movi	r4,32
81138e70:	11389380 	call	81138938 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81138e74:	e0bffe17 	ldw	r2,-8(fp)
81138e78:	10c00104 	addi	r3,r2,4
81138e7c:	e0fffe15 	stw	r3,-8(fp)
81138e80:	10800017 	ldw	r2,0(r2)
81138e84:	e0fffd17 	ldw	r3,-12(fp)
81138e88:	180b883a 	mov	r5,r3
81138e8c:	1009883a 	mov	r4,r2
81138e90:	11388e40 	call	811388e4 <alt_log_txchar>
              break;
81138e94:	00002006 	br	81138f18 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81138e98:	e0bffe17 	ldw	r2,-8(fp)
81138e9c:	10c00104 	addi	r3,r2,4
81138ea0:	e0fffe15 	stw	r3,-8(fp)
81138ea4:	10800017 	ldw	r2,0(r2)
81138ea8:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81138eac:	e43fef17 	ldw	r16,-68(fp)
81138eb0:	e13ffa17 	ldw	r4,-24(fp)
81138eb4:	11251780 	call	81125178 <strlen>
81138eb8:	8085c83a 	sub	r2,r16,r2
81138ebc:	e1bffd17 	ldw	r6,-12(fp)
81138ec0:	100b883a 	mov	r5,r2
81138ec4:	01000804 	movi	r4,32
81138ec8:	11389380 	call	81138938 <alt_log_repchar>

                while(*s)
81138ecc:	00000b06 	br	81138efc <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81138ed0:	e0bffa17 	ldw	r2,-24(fp)
81138ed4:	10c00044 	addi	r3,r2,1
81138ed8:	e0fffa15 	stw	r3,-24(fp)
81138edc:	10800003 	ldbu	r2,0(r2)
81138ee0:	10803fcc 	andi	r2,r2,255
81138ee4:	1080201c 	xori	r2,r2,128
81138ee8:	10bfe004 	addi	r2,r2,-128
81138eec:	e0fffd17 	ldw	r3,-12(fp)
81138ef0:	180b883a 	mov	r5,r3
81138ef4:	1009883a 	mov	r4,r2
81138ef8:	11388e40 	call	811388e4 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81138efc:	e0bffa17 	ldw	r2,-24(fp)
81138f00:	10800003 	ldbu	r2,0(r2)
81138f04:	10803fcc 	andi	r2,r2,255
81138f08:	1080201c 	xori	r2,r2,128
81138f0c:	10bfe004 	addi	r2,r2,-128
81138f10:	103fef1e 	bne	r2,zero,81138ed0 <__reset+0xfb118ed0>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81138f14:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81138f18:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81138f1c:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81138f20:	e0bfeb17 	ldw	r2,-84(fp)
81138f24:	10c00044 	addi	r3,r2,1
81138f28:	e0ffeb15 	stw	r3,-84(fp)
81138f2c:	10800003 	ldbu	r2,0(r2)
81138f30:	e0bffb05 	stb	r2,-20(fp)
81138f34:	e0bffb07 	ldb	r2,-20(fp)
81138f38:	103eae1e 	bne	r2,zero,811389f4 <__reset+0xfb1189f4>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81138f3c:	0001883a 	nop
81138f40:	e6ffff04 	addi	sp,fp,-4
81138f44:	dfc00217 	ldw	ra,8(sp)
81138f48:	df000117 	ldw	fp,4(sp)
81138f4c:	dc000017 	ldw	r16,0(sp)
81138f50:	dec00304 	addi	sp,sp,12
81138f54:	f800283a 	ret

81138f58 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81138f58:	defff904 	addi	sp,sp,-28
81138f5c:	de00012e 	bgeu	sp,et,81138f64 <alt_log_printf_proc+0xc>
81138f60:	003b68fa 	trap	3
81138f64:	dfc00315 	stw	ra,12(sp)
81138f68:	df000215 	stw	fp,8(sp)
81138f6c:	df000204 	addi	fp,sp,8
81138f70:	e13fff15 	stw	r4,-4(fp)
81138f74:	e1400215 	stw	r5,8(fp)
81138f78:	e1800315 	stw	r6,12(fp)
81138f7c:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81138f80:	e0800204 	addi	r2,fp,8
81138f84:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81138f88:	e0bffe17 	ldw	r2,-8(fp)
81138f8c:	100d883a 	mov	r6,r2
81138f90:	01604834 	movhi	r5,33056
81138f94:	294c2404 	addi	r5,r5,12432
81138f98:	e13fff17 	ldw	r4,-4(fp)
81138f9c:	11389a00 	call	811389a0 <alt_log_private_printf>
    return (0);
81138fa0:	0005883a 	mov	r2,zero
}
81138fa4:	e037883a 	mov	sp,fp
81138fa8:	dfc00117 	ldw	ra,4(sp)
81138fac:	df000017 	ldw	fp,0(sp)
81138fb0:	dec00504 	addi	sp,sp,20
81138fb4:	f800283a 	ret

81138fb8 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81138fb8:	defff904 	addi	sp,sp,-28
81138fbc:	de00012e 	bgeu	sp,et,81138fc4 <altera_avalon_jtag_uart_report_log+0xc>
81138fc0:	003b68fa 	trap	3
81138fc4:	dfc00615 	stw	ra,24(sp)
81138fc8:	df000515 	stw	fp,20(sp)
81138fcc:	dc400415 	stw	r17,16(sp)
81138fd0:	dc000315 	stw	r16,12(sp)
81138fd4:	df000504 	addi	fp,sp,20
81138fd8:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81138fdc:	d0a08183 	ldbu	r2,-32250(gp)
81138fe0:	10803fcc 	andi	r2,r2,255
81138fe4:	10001426 	beq	r2,zero,81139038 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81138fe8:	e0bffd17 	ldw	r2,-12(fp)
81138fec:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81138ff0:	00a04574 	movhi	r2,33045
81138ff4:	108b6a04 	addi	r2,r2,11688
81138ff8:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81138ffc:	e0bffb17 	ldw	r2,-20(fp)
81139000:	10800017 	ldw	r2,0(r2)
81139004:	e1bffc17 	ldw	r6,-16(fp)
81139008:	100b883a 	mov	r5,r2
8113900c:	e13ffb17 	ldw	r4,-20(fp)
81139010:	11390580 	call	81139058 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81139014:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81139018:	00b33374 	movhi	r2,52429
8113901c:	10b33344 	addi	r2,r2,-13107
81139020:	1888383a 	mulxuu	r4,r3,r2
81139024:	1885383a 	mul	r2,r3,r2
81139028:	1021883a 	mov	r16,r2
8113902c:	2023883a 	mov	r17,r4
81139030:	8804d0fa 	srli	r2,r17,3
81139034:	00000106 	br	8113903c <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81139038:	0005883a 	mov	r2,zero
    }
}
8113903c:	e6fffe04 	addi	sp,fp,-8
81139040:	dfc00317 	ldw	ra,12(sp)
81139044:	df000217 	ldw	fp,8(sp)
81139048:	dc400117 	ldw	r17,4(sp)
8113904c:	dc000017 	ldw	r16,0(sp)
81139050:	dec00404 	addi	sp,sp,16
81139054:	f800283a 	ret

81139058 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81139058:	deffef04 	addi	sp,sp,-68
8113905c:	de00012e 	bgeu	sp,et,81139064 <alt_log_jtag_uart_print_control_reg+0xc>
81139060:	003b68fa 	trap	3
81139064:	dfc01015 	stw	ra,64(sp)
81139068:	df000f15 	stw	fp,60(sp)
8113906c:	df000f04 	addi	fp,sp,60
81139070:	e13ffd15 	stw	r4,-12(fp)
81139074:	e17ffe15 	stw	r5,-8(fp)
81139078:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113907c:	e0bffe17 	ldw	r2,-8(fp)
81139080:	10800104 	addi	r2,r2,4
81139084:	10800037 	ldwio	r2,0(r2)
81139088:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
8113908c:	e0bff617 	ldw	r2,-40(fp)
81139090:	1004d43a 	srli	r2,r2,16
81139094:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81139098:	e0bff617 	ldw	r2,-40(fp)
8113909c:	1080008c 	andi	r2,r2,2
811390a0:	1004d07a 	srli	r2,r2,1
811390a4:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
811390a8:	e0bff617 	ldw	r2,-40(fp)
811390ac:	1080004c 	andi	r2,r2,1
811390b0:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
811390b4:	e0bff617 	ldw	r2,-40(fp)
811390b8:	1080400c 	andi	r2,r2,256
811390bc:	1004d23a 	srli	r2,r2,8
811390c0:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
811390c4:	e0bff617 	ldw	r2,-40(fp)
811390c8:	1080800c 	andi	r2,r2,512
811390cc:	1004d27a 	srli	r2,r2,9
811390d0:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
811390d4:	e0bff617 	ldw	r2,-40(fp)
811390d8:	1081000c 	andi	r2,r2,1024
811390dc:	1004d2ba 	srli	r2,r2,10
811390e0:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811390e4:	e0bffd17 	ldw	r2,-12(fp)
811390e8:	10c01017 	ldw	r3,64(r2)
811390ec:	e0bffd17 	ldw	r2,-12(fp)
811390f0:	10800f17 	ldw	r2,60(r2)
811390f4:	1887c83a 	sub	r3,r3,r2
811390f8:	e0bff917 	ldw	r2,-28(fp)
811390fc:	d8800415 	stw	r2,16(sp)
81139100:	e0bff817 	ldw	r2,-32(fp)
81139104:	d8800315 	stw	r2,12(sp)
81139108:	e0bffa17 	ldw	r2,-24(fp)
8113910c:	d8800215 	stw	r2,8(sp)
81139110:	e0bffb17 	ldw	r2,-20(fp)
81139114:	d8800115 	stw	r2,4(sp)
81139118:	e0bffc17 	ldw	r2,-16(fp)
8113911c:	d8800015 	stw	r2,0(sp)
81139120:	e1fff717 	ldw	r7,-36(fp)
81139124:	180d883a 	mov	r6,r3
81139128:	e17fff17 	ldw	r5,-4(fp)
8113912c:	01204574 	movhi	r4,33045
81139130:	210b6d04 	addi	r4,r4,11700
81139134:	1138f580 	call	81138f58 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81139138:	0001883a 	nop

}
8113913c:	e037883a 	mov	sp,fp
81139140:	dfc00117 	ldw	ra,4(sp)
81139144:	df000017 	ldw	fp,0(sp)
81139148:	dec00204 	addi	sp,sp,8
8113914c:	f800283a 	ret

81139150 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81139150:	defffb04 	addi	sp,sp,-20
81139154:	de00012e 	bgeu	sp,et,8113915c <alt_log_jtag_uart_startup_info+0xc>
81139158:	003b68fa 	trap	3
8113915c:	dfc00415 	stw	ra,16(sp)
81139160:	df000315 	stw	fp,12(sp)
81139164:	df000304 	addi	fp,sp,12
81139168:	e13ffe15 	stw	r4,-8(fp)
8113916c:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81139170:	00a04574 	movhi	r2,33045
81139174:	108b7f04 	addi	r2,r2,11772
81139178:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
8113917c:	e1bffd17 	ldw	r6,-12(fp)
81139180:	e17fff17 	ldw	r5,-4(fp)
81139184:	e13ffe17 	ldw	r4,-8(fp)
81139188:	11390580 	call	81139058 <alt_log_jtag_uart_print_control_reg>
     return;
8113918c:	0001883a 	nop
}
81139190:	e037883a 	mov	sp,fp
81139194:	dfc00117 	ldw	ra,4(sp)
81139198:	df000017 	ldw	fp,0(sp)
8113919c:	dec00204 	addi	sp,sp,8
811391a0:	f800283a 	ret

811391a4 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
811391a4:	defffb04 	addi	sp,sp,-20
811391a8:	de00012e 	bgeu	sp,et,811391b0 <alt_log_jtag_uart_isr_proc+0xc>
811391ac:	003b68fa 	trap	3
811391b0:	dfc00415 	stw	ra,16(sp)
811391b4:	df000315 	stw	fp,12(sp)
811391b8:	df000304 	addi	fp,sp,12
811391bc:	e13ffe15 	stw	r4,-8(fp)
811391c0:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811391c4:	d0a081c3 	ldbu	r2,-32249(gp)
811391c8:	10803fcc 	andi	r2,r2,255
811391cc:	10000826 	beq	r2,zero,811391f0 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
811391d0:	00a04574 	movhi	r2,33045
811391d4:	108b8404 	addi	r2,r2,11792
811391d8:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
811391dc:	e1bffd17 	ldw	r6,-12(fp)
811391e0:	e17ffe17 	ldw	r5,-8(fp)
811391e4:	e13fff17 	ldw	r4,-4(fp)
811391e8:	11390580 	call	81139058 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811391ec:	0001883a 	nop
811391f0:	0001883a 	nop
}
811391f4:	e037883a 	mov	sp,fp
811391f8:	dfc00117 	ldw	ra,4(sp)
811391fc:	df000017 	ldw	fp,0(sp)
81139200:	dec00204 	addi	sp,sp,8
81139204:	f800283a 	ret

81139208 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81139208:	defffa04 	addi	sp,sp,-24
8113920c:	de00012e 	bgeu	sp,et,81139214 <alt_log_write+0xc>
81139210:	003b68fa 	trap	3
81139214:	dfc00515 	stw	ra,20(sp)
81139218:	df000415 	stw	fp,16(sp)
8113921c:	df000404 	addi	fp,sp,16
81139220:	e13ffe15 	stw	r4,-8(fp)
81139224:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81139228:	d0a08103 	ldbu	r2,-32252(gp)
8113922c:	10803fcc 	andi	r2,r2,255
81139230:	10004026 	beq	r2,zero,81139334 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81139234:	e0bfff17 	ldw	r2,-4(fp)
81139238:	10c00430 	cmpltui	r3,r2,16
8113923c:	1800011e 	bne	r3,zero,81139244 <alt_log_write+0x3c>
81139240:	008003c4 	movi	r2,15
81139244:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81139248:	e0bffd17 	ldw	r2,-12(fp)
8113924c:	10800088 	cmpgei	r2,r2,2
81139250:	10003726 	beq	r2,zero,81139330 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81139254:	e0bffd17 	ldw	r2,-12(fp)
81139258:	100d883a 	mov	r6,r2
8113925c:	e17ffe17 	ldw	r5,-8(fp)
81139260:	012045f4 	movhi	r4,33047
81139264:	21236304 	addi	r4,r4,-29300
81139268:	114d1d40 	call	8114d1d4 <strncpy>
    alt_log_write_buf[length-1]='\n';
8113926c:	e0bffd17 	ldw	r2,-12(fp)
81139270:	10ffffc4 	addi	r3,r2,-1
81139274:	00a045f4 	movhi	r2,33047
81139278:	10a36304 	addi	r2,r2,-29300
8113927c:	10c5883a 	add	r2,r2,r3
81139280:	00c00284 	movi	r3,10
81139284:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81139288:	00a045f4 	movhi	r2,33047
8113928c:	10a36304 	addi	r2,r2,-29300
81139290:	e0fffd17 	ldw	r3,-12(fp)
81139294:	10c5883a 	add	r2,r2,r3
81139298:	00c00344 	movi	r3,13
8113929c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
811392a0:	e0bffd17 	ldw	r2,-12(fp)
811392a4:	10c00044 	addi	r3,r2,1
811392a8:	00a045f4 	movhi	r2,33047
811392ac:	10a36304 	addi	r2,r2,-29300
811392b0:	10c5883a 	add	r2,r2,r3
811392b4:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811392b8:	e03ffc15 	stw	zero,-16(fp)
811392bc:	00001306 	br	8113930c <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811392c0:	00a045f4 	movhi	r2,33047
811392c4:	10a36304 	addi	r2,r2,-29300
811392c8:	e0fffc17 	ldw	r3,-16(fp)
811392cc:	10c5883a 	add	r2,r2,r3
811392d0:	10800003 	ldbu	r2,0(r2)
811392d4:	10803fcc 	andi	r2,r2,255
811392d8:	1080201c 	xori	r2,r2,128
811392dc:	10bfe004 	addi	r2,r2,-128
811392e0:	10800118 	cmpnei	r2,r2,4
811392e4:	1000061e 	bne	r2,zero,81139300 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811392e8:	00a045f4 	movhi	r2,33047
811392ec:	10a36304 	addi	r2,r2,-29300
811392f0:	e0fffc17 	ldw	r3,-16(fp)
811392f4:	10c5883a 	add	r2,r2,r3
811392f8:	00c01104 	movi	r3,68
811392fc:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81139300:	e0bffc17 	ldw	r2,-16(fp)
81139304:	10800044 	addi	r2,r2,1
81139308:	e0bffc15 	stw	r2,-16(fp)
8113930c:	e0fffc17 	ldw	r3,-16(fp)
81139310:	e0bffd17 	ldw	r2,-12(fp)
81139314:	18bfea16 	blt	r3,r2,811392c0 <__reset+0xfb1192c0>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81139318:	016045f4 	movhi	r5,33047
8113931c:	29636304 	addi	r5,r5,-29300
81139320:	01204574 	movhi	r4,33045
81139324:	210b8704 	addi	r4,r4,11804
81139328:	1138f580 	call	81138f58 <alt_log_printf_proc>
8113932c:	00000106 	br	81139334 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81139330:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81139334:	e037883a 	mov	sp,fp
81139338:	dfc00117 	ldw	ra,4(sp)
8113933c:	df000017 	ldw	fp,0(sp)
81139340:	dec00204 	addi	sp,sp,8
81139344:	f800283a 	ret

81139348 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81139348:	defffe04 	addi	sp,sp,-8
8113934c:	de00012e 	bgeu	sp,et,81139354 <alt_log_system_clock+0xc>
81139350:	003b68fa 	trap	3
81139354:	dfc00115 	stw	ra,4(sp)
81139358:	df000015 	stw	fp,0(sp)
8113935c:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81139360:	d0a08143 	ldbu	r2,-32251(gp)
81139364:	10803fcc 	andi	r2,r2,255
81139368:	10000e26 	beq	r2,zero,811393a4 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
8113936c:	d0a08417 	ldw	r2,-32240(gp)
81139370:	10800044 	addi	r2,r2,1
81139374:	d0a08415 	stw	r2,-32240(gp)
81139378:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
8113937c:	d0e08417 	ldw	r3,-32240(gp)
81139380:	10c0082e 	bgeu	r2,r3,811393a4 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81139384:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81139388:	d0a08317 	ldw	r2,-32244(gp)
8113938c:	10c00044 	addi	r3,r2,1
81139390:	d0e08315 	stw	r3,-32244(gp)
81139394:	100b883a 	mov	r5,r2
81139398:	01204574 	movhi	r4,33045
8113939c:	210b8b04 	addi	r4,r4,11820
811393a0:	1138f580 	call	81138f58 <alt_log_printf_proc>
        }
    }
}
811393a4:	0001883a 	nop
811393a8:	e037883a 	mov	sp,fp
811393ac:	dfc00117 	ldw	ra,4(sp)
811393b0:	df000017 	ldw	fp,0(sp)
811393b4:	dec00204 	addi	sp,sp,8
811393b8:	f800283a 	ret

811393bc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811393bc:	defffe04 	addi	sp,sp,-8
811393c0:	de00012e 	bgeu	sp,et,811393c8 <alt_get_errno+0xc>
811393c4:	003b68fa 	trap	3
811393c8:	dfc00115 	stw	ra,4(sp)
811393cc:	df000015 	stw	fp,0(sp)
811393d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811393d4:	d0a01017 	ldw	r2,-32704(gp)
811393d8:	10000326 	beq	r2,zero,811393e8 <alt_get_errno+0x2c>
811393dc:	d0a01017 	ldw	r2,-32704(gp)
811393e0:	103ee83a 	callr	r2
811393e4:	00000106 	br	811393ec <alt_get_errno+0x30>
811393e8:	d0a07804 	addi	r2,gp,-32288
}
811393ec:	e037883a 	mov	sp,fp
811393f0:	dfc00117 	ldw	ra,4(sp)
811393f4:	df000017 	ldw	fp,0(sp)
811393f8:	dec00204 	addi	sp,sp,8
811393fc:	f800283a 	ret

81139400 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81139400:	defff904 	addi	sp,sp,-28
81139404:	de00012e 	bgeu	sp,et,8113940c <lseek+0xc>
81139408:	003b68fa 	trap	3
8113940c:	dfc00615 	stw	ra,24(sp)
81139410:	df000515 	stw	fp,20(sp)
81139414:	df000504 	addi	fp,sp,20
81139418:	e13ffd15 	stw	r4,-12(fp)
8113941c:	e17ffe15 	stw	r5,-8(fp)
81139420:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81139424:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81139428:	e0bffd17 	ldw	r2,-12(fp)
8113942c:	10000616 	blt	r2,zero,81139448 <lseek+0x48>
81139430:	e0bffd17 	ldw	r2,-12(fp)
81139434:	10c00324 	muli	r3,r2,12
81139438:	00a04574 	movhi	r2,33045
8113943c:	108f4404 	addi	r2,r2,15632
81139440:	1885883a 	add	r2,r3,r2
81139444:	00000106 	br	8113944c <lseek+0x4c>
81139448:	0005883a 	mov	r2,zero
8113944c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81139450:	e0bffc17 	ldw	r2,-16(fp)
81139454:	10001026 	beq	r2,zero,81139498 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81139458:	e0bffc17 	ldw	r2,-16(fp)
8113945c:	10800017 	ldw	r2,0(r2)
81139460:	10800717 	ldw	r2,28(r2)
81139464:	10000926 	beq	r2,zero,8113948c <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81139468:	e0bffc17 	ldw	r2,-16(fp)
8113946c:	10800017 	ldw	r2,0(r2)
81139470:	10800717 	ldw	r2,28(r2)
81139474:	e1bfff17 	ldw	r6,-4(fp)
81139478:	e17ffe17 	ldw	r5,-8(fp)
8113947c:	e13ffc17 	ldw	r4,-16(fp)
81139480:	103ee83a 	callr	r2
81139484:	e0bffb15 	stw	r2,-20(fp)
81139488:	00000506 	br	811394a0 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
8113948c:	00bfde84 	movi	r2,-134
81139490:	e0bffb15 	stw	r2,-20(fp)
81139494:	00000206 	br	811394a0 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81139498:	00bfebc4 	movi	r2,-81
8113949c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
811394a0:	e0bffb17 	ldw	r2,-20(fp)
811394a4:	1000070e 	bge	r2,zero,811394c4 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
811394a8:	11393bc0 	call	811393bc <alt_get_errno>
811394ac:	1007883a 	mov	r3,r2
811394b0:	e0bffb17 	ldw	r2,-20(fp)
811394b4:	0085c83a 	sub	r2,zero,r2
811394b8:	18800015 	stw	r2,0(r3)
    rc = -1;
811394bc:	00bfffc4 	movi	r2,-1
811394c0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811394c4:	e0bffb17 	ldw	r2,-20(fp)
}
811394c8:	e037883a 	mov	sp,fp
811394cc:	dfc00117 	ldw	ra,4(sp)
811394d0:	df000017 	ldw	fp,0(sp)
811394d4:	dec00204 	addi	sp,sp,8
811394d8:	f800283a 	ret

811394dc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811394dc:	defff904 	addi	sp,sp,-28
811394e0:	de00012e 	bgeu	sp,et,811394e8 <alt_main+0xc>
811394e4:	003b68fa 	trap	3
811394e8:	dfc00615 	stw	ra,24(sp)
811394ec:	df000515 	stw	fp,20(sp)
811394f0:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
811394f4:	d0a01217 	ldw	r2,-32696(gp)
811394f8:	10800058 	cmpnei	r2,r2,1
811394fc:	1000031e 	bne	r2,zero,8113950c <alt_main+0x30>
81139500:	01204574 	movhi	r4,33045
81139504:	210b9104 	addi	r4,r4,11844
81139508:	1138f580 	call	81138f58 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
8113950c:	0009883a 	mov	r4,zero
81139510:	11440340 	call	81144034 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81139514:	d0a01217 	ldw	r2,-32696(gp)
81139518:	10800058 	cmpnei	r2,r2,1
8113951c:	1000031e 	bne	r2,zero,8113952c <alt_main+0x50>
81139520:	01204574 	movhi	r4,33045
81139524:	210b9f04 	addi	r4,r4,11900
81139528:	1138f580 	call	81138f58 <alt_log_printf_proc>
  ALT_OS_INIT();
8113952c:	113aac80 	call	8113aac8 <OSInit>
81139530:	01000044 	movi	r4,1
81139534:	11407e40 	call	811407e4 <OSSemCreate>
81139538:	d0a08b15 	stw	r2,-32212(gp)
8113953c:	01000044 	movi	r4,1
81139540:	11407e40 	call	811407e4 <OSSemCreate>
81139544:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81139548:	d0a01217 	ldw	r2,-32696(gp)
8113954c:	10800058 	cmpnei	r2,r2,1
81139550:	1000031e 	bne	r2,zero,81139560 <alt_main+0x84>
81139554:	01204574 	movhi	r4,33045
81139558:	210bad04 	addi	r4,r4,11956
8113955c:	1138f580 	call	81138f58 <alt_log_printf_proc>
81139560:	d0a07f04 	addi	r2,gp,-32260
81139564:	e0bffc15 	stw	r2,-16(fp)
81139568:	00800044 	movi	r2,1
8113956c:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81139570:	e0bffd0b 	ldhu	r2,-12(fp)
81139574:	1009883a 	mov	r4,r2
81139578:	11407e40 	call	811407e4 <OSSemCreate>
8113957c:	1007883a 	mov	r3,r2
81139580:	e0bffc17 	ldw	r2,-16(fp)
81139584:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81139588:	d0a01217 	ldw	r2,-32696(gp)
8113958c:	10800058 	cmpnei	r2,r2,1
81139590:	1000031e 	bne	r2,zero,811395a0 <alt_main+0xc4>
81139594:	01204574 	movhi	r4,33045
81139598:	210bbb04 	addi	r4,r4,12012
8113959c:	1138f580 	call	81138f58 <alt_log_printf_proc>
  alt_sys_init();
811395a0:	11440740 	call	81144074 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
811395a4:	d0a01217 	ldw	r2,-32696(gp)
811395a8:	10800058 	cmpnei	r2,r2,1
811395ac:	1000031e 	bne	r2,zero,811395bc <alt_main+0xe0>
811395b0:	01204574 	movhi	r4,33045
811395b4:	210bc504 	addi	r4,r4,12052
811395b8:	1138f580 	call	81138f58 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811395bc:	d0a01217 	ldw	r2,-32696(gp)
811395c0:	10800058 	cmpnei	r2,r2,1
811395c4:	1000031e 	bne	r2,zero,811395d4 <alt_main+0xf8>
811395c8:	01204574 	movhi	r4,33045
811395cc:	210bce04 	addi	r4,r4,12088
811395d0:	1138f580 	call	81138f58 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811395d4:	01a04574 	movhi	r6,33045
811395d8:	318bd604 	addi	r6,r6,12120
811395dc:	01604574 	movhi	r5,33045
811395e0:	294bdb04 	addi	r5,r5,12140
811395e4:	01204574 	movhi	r4,33045
811395e8:	210bdb04 	addi	r4,r4,12140
811395ec:	114c9640 	call	8114c964 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811395f0:	d0a01217 	ldw	r2,-32696(gp)
811395f4:	10800058 	cmpnei	r2,r2,1
811395f8:	1000031e 	bne	r2,zero,81139608 <alt_main+0x12c>
811395fc:	01204574 	movhi	r4,33045
81139600:	210bdf04 	addi	r4,r4,12156
81139604:	1138f580 	call	81138f58 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81139608:	d0a08517 	ldw	r2,-32236(gp)
8113960c:	d0e08617 	ldw	r3,-32232(gp)
81139610:	d1208717 	ldw	r4,-32228(gp)
81139614:	200d883a 	mov	r6,r4
81139618:	180b883a 	mov	r5,r3
8113961c:	1009883a 	mov	r4,r2
81139620:	11196bc0 	call	811196bc <main>
81139624:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81139628:	01000044 	movi	r4,1
8113962c:	11384080 	call	81138408 <close>
  exit (result);
81139630:	e13ffb17 	ldw	r4,-20(fp)
81139634:	114d1180 	call	8114d118 <exit>

81139638 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81139638:	defffe04 	addi	sp,sp,-8
8113963c:	de00012e 	bgeu	sp,et,81139644 <alt_get_errno+0xc>
81139640:	003b68fa 	trap	3
81139644:	dfc00115 	stw	ra,4(sp)
81139648:	df000015 	stw	fp,0(sp)
8113964c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81139650:	d0a01017 	ldw	r2,-32704(gp)
81139654:	10000326 	beq	r2,zero,81139664 <alt_get_errno+0x2c>
81139658:	d0a01017 	ldw	r2,-32704(gp)
8113965c:	103ee83a 	callr	r2
81139660:	00000106 	br	81139668 <alt_get_errno+0x30>
81139664:	d0a07804 	addi	r2,gp,-32288
}
81139668:	e037883a 	mov	sp,fp
8113966c:	dfc00117 	ldw	ra,4(sp)
81139670:	df000017 	ldw	fp,0(sp)
81139674:	dec00204 	addi	sp,sp,8
81139678:	f800283a 	ret

8113967c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
8113967c:	defffd04 	addi	sp,sp,-12
81139680:	de00012e 	bgeu	sp,et,81139688 <alt_file_locked+0xc>
81139684:	003b68fa 	trap	3
81139688:	df000215 	stw	fp,8(sp)
8113968c:	df000204 	addi	fp,sp,8
81139690:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81139694:	e0bfff17 	ldw	r2,-4(fp)
81139698:	10800217 	ldw	r2,8(r2)
8113969c:	10d00034 	orhi	r3,r2,16384
811396a0:	e0bfff17 	ldw	r2,-4(fp)
811396a4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811396a8:	e03ffe15 	stw	zero,-8(fp)
811396ac:	00001d06 	br	81139724 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811396b0:	00a04574 	movhi	r2,33045
811396b4:	108f4404 	addi	r2,r2,15632
811396b8:	e0fffe17 	ldw	r3,-8(fp)
811396bc:	18c00324 	muli	r3,r3,12
811396c0:	10c5883a 	add	r2,r2,r3
811396c4:	10c00017 	ldw	r3,0(r2)
811396c8:	e0bfff17 	ldw	r2,-4(fp)
811396cc:	10800017 	ldw	r2,0(r2)
811396d0:	1880111e 	bne	r3,r2,81139718 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811396d4:	00a04574 	movhi	r2,33045
811396d8:	108f4404 	addi	r2,r2,15632
811396dc:	e0fffe17 	ldw	r3,-8(fp)
811396e0:	18c00324 	muli	r3,r3,12
811396e4:	10c5883a 	add	r2,r2,r3
811396e8:	10800204 	addi	r2,r2,8
811396ec:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811396f0:	1000090e 	bge	r2,zero,81139718 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811396f4:	e0bffe17 	ldw	r2,-8(fp)
811396f8:	10c00324 	muli	r3,r2,12
811396fc:	00a04574 	movhi	r2,33045
81139700:	108f4404 	addi	r2,r2,15632
81139704:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81139708:	e0bfff17 	ldw	r2,-4(fp)
8113970c:	18800226 	beq	r3,r2,81139718 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81139710:	00bffcc4 	movi	r2,-13
81139714:	00000806 	br	81139738 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81139718:	e0bffe17 	ldw	r2,-8(fp)
8113971c:	10800044 	addi	r2,r2,1
81139720:	e0bffe15 	stw	r2,-8(fp)
81139724:	d0a00f17 	ldw	r2,-32708(gp)
81139728:	1007883a 	mov	r3,r2
8113972c:	e0bffe17 	ldw	r2,-8(fp)
81139730:	18bfdf2e 	bgeu	r3,r2,811396b0 <__reset+0xfb1196b0>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81139734:	0005883a 	mov	r2,zero
}
81139738:	e037883a 	mov	sp,fp
8113973c:	df000017 	ldw	fp,0(sp)
81139740:	dec00104 	addi	sp,sp,4
81139744:	f800283a 	ret

81139748 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81139748:	defff604 	addi	sp,sp,-40
8113974c:	de00012e 	bgeu	sp,et,81139754 <open+0xc>
81139750:	003b68fa 	trap	3
81139754:	dfc00915 	stw	ra,36(sp)
81139758:	df000815 	stw	fp,32(sp)
8113975c:	df000804 	addi	fp,sp,32
81139760:	e13ffd15 	stw	r4,-12(fp)
81139764:	e17ffe15 	stw	r5,-8(fp)
81139768:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
8113976c:	00bfffc4 	movi	r2,-1
81139770:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81139774:	00bffb44 	movi	r2,-19
81139778:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
8113977c:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81139780:	d1600d04 	addi	r5,gp,-32716
81139784:	e13ffd17 	ldw	r4,-12(fp)
81139788:	114c3440 	call	8114c344 <alt_find_dev>
8113978c:	e0bff815 	stw	r2,-32(fp)
81139790:	e0bff817 	ldw	r2,-32(fp)
81139794:	1000051e 	bne	r2,zero,811397ac <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81139798:	e13ffd17 	ldw	r4,-12(fp)
8113979c:	114c3dc0 	call	8114c3dc <alt_find_file>
811397a0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
811397a4:	00800044 	movi	r2,1
811397a8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
811397ac:	e0bff817 	ldw	r2,-32(fp)
811397b0:	10002926 	beq	r2,zero,81139858 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
811397b4:	e13ff817 	ldw	r4,-32(fp)
811397b8:	114c4ec0 	call	8114c4ec <alt_get_fd>
811397bc:	e0bff915 	stw	r2,-28(fp)
811397c0:	e0bff917 	ldw	r2,-28(fp)
811397c4:	1000030e 	bge	r2,zero,811397d4 <open+0x8c>
    {
      status = index;
811397c8:	e0bff917 	ldw	r2,-28(fp)
811397cc:	e0bffa15 	stw	r2,-24(fp)
811397d0:	00002306 	br	81139860 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811397d4:	e0bff917 	ldw	r2,-28(fp)
811397d8:	10c00324 	muli	r3,r2,12
811397dc:	00a04574 	movhi	r2,33045
811397e0:	108f4404 	addi	r2,r2,15632
811397e4:	1885883a 	add	r2,r3,r2
811397e8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811397ec:	e0fffe17 	ldw	r3,-8(fp)
811397f0:	00900034 	movhi	r2,16384
811397f4:	10bfffc4 	addi	r2,r2,-1
811397f8:	1886703a 	and	r3,r3,r2
811397fc:	e0bffc17 	ldw	r2,-16(fp)
81139800:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81139804:	e0bffb17 	ldw	r2,-20(fp)
81139808:	1000051e 	bne	r2,zero,81139820 <open+0xd8>
8113980c:	e13ffc17 	ldw	r4,-16(fp)
81139810:	113967c0 	call	8113967c <alt_file_locked>
81139814:	e0bffa15 	stw	r2,-24(fp)
81139818:	e0bffa17 	ldw	r2,-24(fp)
8113981c:	10001016 	blt	r2,zero,81139860 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81139820:	e0bff817 	ldw	r2,-32(fp)
81139824:	10800317 	ldw	r2,12(r2)
81139828:	10000826 	beq	r2,zero,8113984c <open+0x104>
8113982c:	e0bff817 	ldw	r2,-32(fp)
81139830:	10800317 	ldw	r2,12(r2)
81139834:	e1ffff17 	ldw	r7,-4(fp)
81139838:	e1bffe17 	ldw	r6,-8(fp)
8113983c:	e17ffd17 	ldw	r5,-12(fp)
81139840:	e13ffc17 	ldw	r4,-16(fp)
81139844:	103ee83a 	callr	r2
81139848:	00000106 	br	81139850 <open+0x108>
8113984c:	0005883a 	mov	r2,zero
81139850:	e0bffa15 	stw	r2,-24(fp)
81139854:	00000206 	br	81139860 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81139858:	00bffb44 	movi	r2,-19
8113985c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81139860:	e0bffa17 	ldw	r2,-24(fp)
81139864:	1000090e 	bge	r2,zero,8113988c <open+0x144>
  {
    alt_release_fd (index);  
81139868:	e13ff917 	ldw	r4,-28(fp)
8113986c:	11399ec0 	call	811399ec <alt_release_fd>
    ALT_ERRNO = -status;
81139870:	11396380 	call	81139638 <alt_get_errno>
81139874:	1007883a 	mov	r3,r2
81139878:	e0bffa17 	ldw	r2,-24(fp)
8113987c:	0085c83a 	sub	r2,zero,r2
81139880:	18800015 	stw	r2,0(r3)
    return -1;
81139884:	00bfffc4 	movi	r2,-1
81139888:	00000106 	br	81139890 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
8113988c:	e0bff917 	ldw	r2,-28(fp)
}
81139890:	e037883a 	mov	sp,fp
81139894:	dfc00117 	ldw	ra,4(sp)
81139898:	df000017 	ldw	fp,0(sp)
8113989c:	dec00204 	addi	sp,sp,8
811398a0:	f800283a 	ret

811398a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811398a4:	defffe04 	addi	sp,sp,-8
811398a8:	de00012e 	bgeu	sp,et,811398b0 <alt_get_errno+0xc>
811398ac:	003b68fa 	trap	3
811398b0:	dfc00115 	stw	ra,4(sp)
811398b4:	df000015 	stw	fp,0(sp)
811398b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811398bc:	d0a01017 	ldw	r2,-32704(gp)
811398c0:	10000326 	beq	r2,zero,811398d0 <alt_get_errno+0x2c>
811398c4:	d0a01017 	ldw	r2,-32704(gp)
811398c8:	103ee83a 	callr	r2
811398cc:	00000106 	br	811398d4 <alt_get_errno+0x30>
811398d0:	d0a07804 	addi	r2,gp,-32288
}
811398d4:	e037883a 	mov	sp,fp
811398d8:	dfc00117 	ldw	ra,4(sp)
811398dc:	df000017 	ldw	fp,0(sp)
811398e0:	dec00204 	addi	sp,sp,8
811398e4:	f800283a 	ret

811398e8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
811398e8:	defff904 	addi	sp,sp,-28
811398ec:	de00012e 	bgeu	sp,et,811398f4 <read+0xc>
811398f0:	003b68fa 	trap	3
811398f4:	dfc00615 	stw	ra,24(sp)
811398f8:	df000515 	stw	fp,20(sp)
811398fc:	df000504 	addi	fp,sp,20
81139900:	e13ffd15 	stw	r4,-12(fp)
81139904:	e17ffe15 	stw	r5,-8(fp)
81139908:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113990c:	e0bffd17 	ldw	r2,-12(fp)
81139910:	10000616 	blt	r2,zero,8113992c <read+0x44>
81139914:	e0bffd17 	ldw	r2,-12(fp)
81139918:	10c00324 	muli	r3,r2,12
8113991c:	00a04574 	movhi	r2,33045
81139920:	108f4404 	addi	r2,r2,15632
81139924:	1885883a 	add	r2,r3,r2
81139928:	00000106 	br	81139930 <read+0x48>
8113992c:	0005883a 	mov	r2,zero
81139930:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81139934:	e0bffb17 	ldw	r2,-20(fp)
81139938:	10002226 	beq	r2,zero,811399c4 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8113993c:	e0bffb17 	ldw	r2,-20(fp)
81139940:	10800217 	ldw	r2,8(r2)
81139944:	108000cc 	andi	r2,r2,3
81139948:	10800060 	cmpeqi	r2,r2,1
8113994c:	1000181e 	bne	r2,zero,811399b0 <read+0xc8>
        (fd->dev->read))
81139950:	e0bffb17 	ldw	r2,-20(fp)
81139954:	10800017 	ldw	r2,0(r2)
81139958:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8113995c:	10001426 	beq	r2,zero,811399b0 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81139960:	e0bffb17 	ldw	r2,-20(fp)
81139964:	10800017 	ldw	r2,0(r2)
81139968:	10800517 	ldw	r2,20(r2)
8113996c:	e0ffff17 	ldw	r3,-4(fp)
81139970:	180d883a 	mov	r6,r3
81139974:	e17ffe17 	ldw	r5,-8(fp)
81139978:	e13ffb17 	ldw	r4,-20(fp)
8113997c:	103ee83a 	callr	r2
81139980:	e0bffc15 	stw	r2,-16(fp)
81139984:	e0bffc17 	ldw	r2,-16(fp)
81139988:	1000070e 	bge	r2,zero,811399a8 <read+0xc0>
        {
          ALT_ERRNO = -rval;
8113998c:	11398a40 	call	811398a4 <alt_get_errno>
81139990:	1007883a 	mov	r3,r2
81139994:	e0bffc17 	ldw	r2,-16(fp)
81139998:	0085c83a 	sub	r2,zero,r2
8113999c:	18800015 	stw	r2,0(r3)
          return -1;
811399a0:	00bfffc4 	movi	r2,-1
811399a4:	00000c06 	br	811399d8 <read+0xf0>
        }
        return rval;
811399a8:	e0bffc17 	ldw	r2,-16(fp)
811399ac:	00000a06 	br	811399d8 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
811399b0:	11398a40 	call	811398a4 <alt_get_errno>
811399b4:	1007883a 	mov	r3,r2
811399b8:	00800344 	movi	r2,13
811399bc:	18800015 	stw	r2,0(r3)
811399c0:	00000406 	br	811399d4 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811399c4:	11398a40 	call	811398a4 <alt_get_errno>
811399c8:	1007883a 	mov	r3,r2
811399cc:	00801444 	movi	r2,81
811399d0:	18800015 	stw	r2,0(r3)
  }
  return -1;
811399d4:	00bfffc4 	movi	r2,-1
}
811399d8:	e037883a 	mov	sp,fp
811399dc:	dfc00117 	ldw	ra,4(sp)
811399e0:	df000017 	ldw	fp,0(sp)
811399e4:	dec00204 	addi	sp,sp,8
811399e8:	f800283a 	ret

811399ec <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811399ec:	defffe04 	addi	sp,sp,-8
811399f0:	de00012e 	bgeu	sp,et,811399f8 <alt_release_fd+0xc>
811399f4:	003b68fa 	trap	3
811399f8:	df000115 	stw	fp,4(sp)
811399fc:	df000104 	addi	fp,sp,4
81139a00:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81139a04:	e0bfff17 	ldw	r2,-4(fp)
81139a08:	108000d0 	cmplti	r2,r2,3
81139a0c:	10000d1e 	bne	r2,zero,81139a44 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81139a10:	00a04574 	movhi	r2,33045
81139a14:	108f4404 	addi	r2,r2,15632
81139a18:	e0ffff17 	ldw	r3,-4(fp)
81139a1c:	18c00324 	muli	r3,r3,12
81139a20:	10c5883a 	add	r2,r2,r3
81139a24:	10800204 	addi	r2,r2,8
81139a28:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81139a2c:	00a04574 	movhi	r2,33045
81139a30:	108f4404 	addi	r2,r2,15632
81139a34:	e0ffff17 	ldw	r3,-4(fp)
81139a38:	18c00324 	muli	r3,r3,12
81139a3c:	10c5883a 	add	r2,r2,r3
81139a40:	10000015 	stw	zero,0(r2)
  }
}
81139a44:	0001883a 	nop
81139a48:	e037883a 	mov	sp,fp
81139a4c:	df000017 	ldw	fp,0(sp)
81139a50:	dec00104 	addi	sp,sp,4
81139a54:	f800283a 	ret

81139a58 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81139a58:	defff604 	addi	sp,sp,-40
81139a5c:	de00012e 	bgeu	sp,et,81139a64 <sbrk+0xc>
81139a60:	003b68fa 	trap	3
81139a64:	df000915 	stw	fp,36(sp)
81139a68:	df000904 	addi	fp,sp,36
81139a6c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139a70:	0005303a 	rdctl	r2,status
81139a74:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139a78:	e0fffe17 	ldw	r3,-8(fp)
81139a7c:	00bfff84 	movi	r2,-2
81139a80:	1884703a 	and	r2,r3,r2
81139a84:	1001703a 	wrctl	status,r2
  
  return context;
81139a88:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81139a8c:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81139a90:	d0a01317 	ldw	r2,-32692(gp)
81139a94:	10c000c4 	addi	r3,r2,3
81139a98:	00bfff04 	movi	r2,-4
81139a9c:	1884703a 	and	r2,r3,r2
81139aa0:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81139aa4:	d0e01317 	ldw	r3,-32692(gp)
81139aa8:	e0bfff17 	ldw	r2,-4(fp)
81139aac:	1887883a 	add	r3,r3,r2
81139ab0:	00a04834 	movhi	r2,33056
81139ab4:	10a80004 	addi	r2,r2,-24576
81139ab8:	10c0062e 	bgeu	r2,r3,81139ad4 <sbrk+0x7c>
81139abc:	e0bff817 	ldw	r2,-32(fp)
81139ac0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139ac4:	e0bff717 	ldw	r2,-36(fp)
81139ac8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81139acc:	00bfffc4 	movi	r2,-1
81139ad0:	00001c06 	br	81139b44 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81139ad4:	d0a01317 	ldw	r2,-32692(gp)
81139ad8:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81139adc:	d0e01317 	ldw	r3,-32692(gp)
81139ae0:	e0bfff17 	ldw	r2,-4(fp)
81139ae4:	1885883a 	add	r2,r3,r2
81139ae8:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81139aec:	c005883a 	mov	r2,et
81139af0:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81139af4:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81139af8:	e0bffa17 	ldw	r2,-24(fp)
81139afc:	18800c1e 	bne	r3,r2,81139b30 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81139b00:	d805883a 	mov	r2,sp
81139b04:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81139b08:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81139b0c:	d0e01317 	ldw	r3,-32692(gp)
81139b10:	18800136 	bltu	r3,r2,81139b18 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81139b14:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81139b18:	d0a01317 	ldw	r2,-32692(gp)
81139b1c:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81139b20:	e0bffc17 	ldw	r2,-16(fp)
81139b24:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81139b28:	e0bffc17 	ldw	r2,-16(fp)
81139b2c:	1031883a 	mov	et,r2
81139b30:	e0bff817 	ldw	r2,-32(fp)
81139b34:	e0bffd15 	stw	r2,-12(fp)
81139b38:	e0bffd17 	ldw	r2,-12(fp)
81139b3c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81139b40:	e0bffa17 	ldw	r2,-24(fp)
} 
81139b44:	e037883a 	mov	sp,fp
81139b48:	df000017 	ldw	fp,0(sp)
81139b4c:	dec00104 	addi	sp,sp,4
81139b50:	f800283a 	ret

81139b54 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81139b54:	defffa04 	addi	sp,sp,-24
81139b58:	de00012e 	bgeu	sp,et,81139b60 <alt_alarm_stop+0xc>
81139b5c:	003b68fa 	trap	3
81139b60:	df000515 	stw	fp,20(sp)
81139b64:	df000504 	addi	fp,sp,20
81139b68:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139b6c:	0005303a 	rdctl	r2,status
81139b70:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139b74:	e0fffc17 	ldw	r3,-16(fp)
81139b78:	00bfff84 	movi	r2,-2
81139b7c:	1884703a 	and	r2,r3,r2
81139b80:	1001703a 	wrctl	status,r2
  
  return context;
81139b84:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81139b88:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81139b8c:	e0bfff17 	ldw	r2,-4(fp)
81139b90:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81139b94:	e0bffd17 	ldw	r2,-12(fp)
81139b98:	10800017 	ldw	r2,0(r2)
81139b9c:	e0fffd17 	ldw	r3,-12(fp)
81139ba0:	18c00117 	ldw	r3,4(r3)
81139ba4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81139ba8:	e0bffd17 	ldw	r2,-12(fp)
81139bac:	10800117 	ldw	r2,4(r2)
81139bb0:	e0fffd17 	ldw	r3,-12(fp)
81139bb4:	18c00017 	ldw	r3,0(r3)
81139bb8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81139bbc:	e0bffd17 	ldw	r2,-12(fp)
81139bc0:	e0fffd17 	ldw	r3,-12(fp)
81139bc4:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81139bc8:	e0bffd17 	ldw	r2,-12(fp)
81139bcc:	e0fffd17 	ldw	r3,-12(fp)
81139bd0:	10c00015 	stw	r3,0(r2)
81139bd4:	e0bffb17 	ldw	r2,-20(fp)
81139bd8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139bdc:	e0bffe17 	ldw	r2,-8(fp)
81139be0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81139be4:	0001883a 	nop
81139be8:	e037883a 	mov	sp,fp
81139bec:	df000017 	ldw	fp,0(sp)
81139bf0:	dec00104 	addi	sp,sp,4
81139bf4:	f800283a 	ret

81139bf8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81139bf8:	defffb04 	addi	sp,sp,-20
81139bfc:	de00012e 	bgeu	sp,et,81139c04 <alt_tick+0xc>
81139c00:	003b68fa 	trap	3
81139c04:	dfc00415 	stw	ra,16(sp)
81139c08:	df000315 	stw	fp,12(sp)
81139c0c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81139c10:	d0a01417 	ldw	r2,-32688(gp)
81139c14:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81139c18:	d0a08917 	ldw	r2,-32220(gp)
81139c1c:	10800044 	addi	r2,r2,1
81139c20:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81139c24:	00002e06 	br	81139ce0 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81139c28:	e0bffd17 	ldw	r2,-12(fp)
81139c2c:	10800017 	ldw	r2,0(r2)
81139c30:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81139c34:	e0bffd17 	ldw	r2,-12(fp)
81139c38:	10800403 	ldbu	r2,16(r2)
81139c3c:	10803fcc 	andi	r2,r2,255
81139c40:	10000426 	beq	r2,zero,81139c54 <alt_tick+0x5c>
81139c44:	d0a08917 	ldw	r2,-32220(gp)
81139c48:	1000021e 	bne	r2,zero,81139c54 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81139c4c:	e0bffd17 	ldw	r2,-12(fp)
81139c50:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81139c54:	e0bffd17 	ldw	r2,-12(fp)
81139c58:	10800217 	ldw	r2,8(r2)
81139c5c:	d0e08917 	ldw	r3,-32220(gp)
81139c60:	18801d36 	bltu	r3,r2,81139cd8 <alt_tick+0xe0>
81139c64:	e0bffd17 	ldw	r2,-12(fp)
81139c68:	10800403 	ldbu	r2,16(r2)
81139c6c:	10803fcc 	andi	r2,r2,255
81139c70:	1000191e 	bne	r2,zero,81139cd8 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81139c74:	e0bffd17 	ldw	r2,-12(fp)
81139c78:	10800317 	ldw	r2,12(r2)
81139c7c:	e0fffd17 	ldw	r3,-12(fp)
81139c80:	18c00517 	ldw	r3,20(r3)
81139c84:	1809883a 	mov	r4,r3
81139c88:	103ee83a 	callr	r2
81139c8c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81139c90:	e0bfff17 	ldw	r2,-4(fp)
81139c94:	1000031e 	bne	r2,zero,81139ca4 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81139c98:	e13ffd17 	ldw	r4,-12(fp)
81139c9c:	1139b540 	call	81139b54 <alt_alarm_stop>
81139ca0:	00000d06 	br	81139cd8 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81139ca4:	e0bffd17 	ldw	r2,-12(fp)
81139ca8:	10c00217 	ldw	r3,8(r2)
81139cac:	e0bfff17 	ldw	r2,-4(fp)
81139cb0:	1887883a 	add	r3,r3,r2
81139cb4:	e0bffd17 	ldw	r2,-12(fp)
81139cb8:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81139cbc:	e0bffd17 	ldw	r2,-12(fp)
81139cc0:	10c00217 	ldw	r3,8(r2)
81139cc4:	d0a08917 	ldw	r2,-32220(gp)
81139cc8:	1880032e 	bgeu	r3,r2,81139cd8 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81139ccc:	e0bffd17 	ldw	r2,-12(fp)
81139cd0:	00c00044 	movi	r3,1
81139cd4:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81139cd8:	e0bffe17 	ldw	r2,-8(fp)
81139cdc:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81139ce0:	e0fffd17 	ldw	r3,-12(fp)
81139ce4:	d0a01404 	addi	r2,gp,-32688
81139ce8:	18bfcf1e 	bne	r3,r2,81139c28 <__reset+0xfb119c28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81139cec:	113af280 	call	8113af28 <OSTimeTick>
}
81139cf0:	0001883a 	nop
81139cf4:	e037883a 	mov	sp,fp
81139cf8:	dfc00117 	ldw	ra,4(sp)
81139cfc:	df000017 	ldw	fp,0(sp)
81139d00:	dec00204 	addi	sp,sp,8
81139d04:	f800283a 	ret

81139d08 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81139d08:	defffb04 	addi	sp,sp,-20
81139d0c:	de00012e 	bgeu	sp,et,81139d14 <usleep+0xc>
81139d10:	003b68fa 	trap	3
81139d14:	dfc00415 	stw	ra,16(sp)
81139d18:	df000315 	stw	fp,12(sp)
81139d1c:	df000304 	addi	fp,sp,12
81139d20:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81139d24:	d0a09103 	ldbu	r2,-32188(gp)
81139d28:	10803fcc 	andi	r2,r2,255
81139d2c:	1000031e 	bne	r2,zero,81139d3c <usleep+0x34>
  {
    return alt_busy_sleep (us);
81139d30:	e13fff17 	ldw	r4,-4(fp)
81139d34:	11382940 	call	81138294 <alt_busy_sleep>
81139d38:	00003d06 	br	81139e30 <usleep+0x128>
81139d3c:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81139d40:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81139d44:	e0ffff17 	ldw	r3,-4(fp)
81139d48:	0090c734 	movhi	r2,17180
81139d4c:	10b7a0c4 	addi	r2,r2,-8573
81139d50:	1888383a 	mulxuu	r4,r3,r2
81139d54:	1885383a 	mul	r2,r3,r2
81139d58:	1013883a 	mov	r9,r2
81139d5c:	2015883a 	mov	r10,r4
81139d60:	5006d4ba 	srli	r3,r10,18
81139d64:	e0bffe17 	ldw	r2,-8(fp)
81139d68:	1893383a 	mul	r9,r3,r2
81139d6c:	e0ffff17 	ldw	r3,-4(fp)
81139d70:	0090c734 	movhi	r2,17180
81139d74:	10b7a0c4 	addi	r2,r2,-8573
81139d78:	1888383a 	mulxuu	r4,r3,r2
81139d7c:	1885383a 	mul	r2,r3,r2
81139d80:	100f883a 	mov	r7,r2
81139d84:	2011883a 	mov	r8,r4
81139d88:	4004d4ba 	srli	r2,r8,18
81139d8c:	010003f4 	movhi	r4,15
81139d90:	21109004 	addi	r4,r4,16960
81139d94:	1105383a 	mul	r2,r2,r4
81139d98:	1885c83a 	sub	r2,r3,r2
81139d9c:	e0fffe17 	ldw	r3,-8(fp)
81139da0:	10c7383a 	mul	r3,r2,r3
81139da4:	0090c734 	movhi	r2,17180
81139da8:	10b7a0c4 	addi	r2,r2,-8573
81139dac:	1888383a 	mulxuu	r4,r3,r2
81139db0:	1885383a 	mul	r2,r3,r2
81139db4:	100b883a 	mov	r5,r2
81139db8:	200d883a 	mov	r6,r4
81139dbc:	3004d4ba 	srli	r2,r6,18
81139dc0:	4885883a 	add	r2,r9,r2
81139dc4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81139dc8:	00000706 	br	81139de8 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81139dcc:	013fffd4 	movui	r4,65535
81139dd0:	11429980 	call	81142998 <OSTimeDly>
    ticks -= 0xffff;
81139dd4:	e0fffd17 	ldw	r3,-12(fp)
81139dd8:	00bffff4 	movhi	r2,65535
81139ddc:	10800044 	addi	r2,r2,1
81139de0:	1885883a 	add	r2,r3,r2
81139de4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81139de8:	e0bffd17 	ldw	r2,-12(fp)
81139dec:	00ffffd4 	movui	r3,65535
81139df0:	18bff636 	bltu	r3,r2,81139dcc <__reset+0xfb119dcc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81139df4:	e0bffd17 	ldw	r2,-12(fp)
81139df8:	10bfffcc 	andi	r2,r2,65535
81139dfc:	1009883a 	mov	r4,r2
81139e00:	11429980 	call	81142998 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81139e04:	008003f4 	movhi	r2,15
81139e08:	10909004 	addi	r2,r2,16960
81139e0c:	e0fffe17 	ldw	r3,-8(fp)
81139e10:	10c7203a 	divu	r3,r2,r3
81139e14:	e0bfff17 	ldw	r2,-4(fp)
81139e18:	10c9203a 	divu	r4,r2,r3
81139e1c:	20c7383a 	mul	r3,r4,r3
81139e20:	10c5c83a 	sub	r2,r2,r3
81139e24:	1009883a 	mov	r4,r2
81139e28:	11382940 	call	81138294 <alt_busy_sleep>

  return 0;  
81139e2c:	0005883a 	mov	r2,zero
}
81139e30:	e037883a 	mov	sp,fp
81139e34:	dfc00117 	ldw	ra,4(sp)
81139e38:	df000017 	ldw	fp,0(sp)
81139e3c:	dec00204 	addi	sp,sp,8
81139e40:	f800283a 	ret

81139e44 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81139e44:	defffe04 	addi	sp,sp,-8
81139e48:	de00012e 	bgeu	sp,et,81139e50 <alt_get_errno+0xc>
81139e4c:	003b68fa 	trap	3
81139e50:	dfc00115 	stw	ra,4(sp)
81139e54:	df000015 	stw	fp,0(sp)
81139e58:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81139e5c:	d0a01017 	ldw	r2,-32704(gp)
81139e60:	10000326 	beq	r2,zero,81139e70 <alt_get_errno+0x2c>
81139e64:	d0a01017 	ldw	r2,-32704(gp)
81139e68:	103ee83a 	callr	r2
81139e6c:	00000106 	br	81139e74 <alt_get_errno+0x30>
81139e70:	d0a07804 	addi	r2,gp,-32288
}
81139e74:	e037883a 	mov	sp,fp
81139e78:	dfc00117 	ldw	ra,4(sp)
81139e7c:	df000017 	ldw	fp,0(sp)
81139e80:	dec00204 	addi	sp,sp,8
81139e84:	f800283a 	ret

81139e88 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81139e88:	defff904 	addi	sp,sp,-28
81139e8c:	de00012e 	bgeu	sp,et,81139e94 <write+0xc>
81139e90:	003b68fa 	trap	3
81139e94:	dfc00615 	stw	ra,24(sp)
81139e98:	df000515 	stw	fp,20(sp)
81139e9c:	df000504 	addi	fp,sp,20
81139ea0:	e13ffd15 	stw	r4,-12(fp)
81139ea4:	e17ffe15 	stw	r5,-8(fp)
81139ea8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81139eac:	e0bffd17 	ldw	r2,-12(fp)
81139eb0:	10000616 	blt	r2,zero,81139ecc <write+0x44>
81139eb4:	e0bffd17 	ldw	r2,-12(fp)
81139eb8:	10c00324 	muli	r3,r2,12
81139ebc:	00a04574 	movhi	r2,33045
81139ec0:	108f4404 	addi	r2,r2,15632
81139ec4:	1885883a 	add	r2,r3,r2
81139ec8:	00000106 	br	81139ed0 <write+0x48>
81139ecc:	0005883a 	mov	r2,zero
81139ed0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81139ed4:	e0bffb17 	ldw	r2,-20(fp)
81139ed8:	10002426 	beq	r2,zero,81139f6c <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81139edc:	e0bffb17 	ldw	r2,-20(fp)
81139ee0:	10800217 	ldw	r2,8(r2)
81139ee4:	108000cc 	andi	r2,r2,3
81139ee8:	10001b26 	beq	r2,zero,81139f58 <write+0xd0>
81139eec:	e0bffb17 	ldw	r2,-20(fp)
81139ef0:	10800017 	ldw	r2,0(r2)
81139ef4:	10800617 	ldw	r2,24(r2)
81139ef8:	10001726 	beq	r2,zero,81139f58 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81139efc:	e17fff17 	ldw	r5,-4(fp)
81139f00:	e13ffe17 	ldw	r4,-8(fp)
81139f04:	11392080 	call	81139208 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81139f08:	e0bffb17 	ldw	r2,-20(fp)
81139f0c:	10800017 	ldw	r2,0(r2)
81139f10:	10800617 	ldw	r2,24(r2)
81139f14:	e0ffff17 	ldw	r3,-4(fp)
81139f18:	180d883a 	mov	r6,r3
81139f1c:	e17ffe17 	ldw	r5,-8(fp)
81139f20:	e13ffb17 	ldw	r4,-20(fp)
81139f24:	103ee83a 	callr	r2
81139f28:	e0bffc15 	stw	r2,-16(fp)
81139f2c:	e0bffc17 	ldw	r2,-16(fp)
81139f30:	1000070e 	bge	r2,zero,81139f50 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81139f34:	1139e440 	call	81139e44 <alt_get_errno>
81139f38:	1007883a 	mov	r3,r2
81139f3c:	e0bffc17 	ldw	r2,-16(fp)
81139f40:	0085c83a 	sub	r2,zero,r2
81139f44:	18800015 	stw	r2,0(r3)
        return -1;
81139f48:	00bfffc4 	movi	r2,-1
81139f4c:	00000c06 	br	81139f80 <write+0xf8>
      }
      return rval;
81139f50:	e0bffc17 	ldw	r2,-16(fp)
81139f54:	00000a06 	br	81139f80 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81139f58:	1139e440 	call	81139e44 <alt_get_errno>
81139f5c:	1007883a 	mov	r3,r2
81139f60:	00800344 	movi	r2,13
81139f64:	18800015 	stw	r2,0(r3)
81139f68:	00000406 	br	81139f7c <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81139f6c:	1139e440 	call	81139e44 <alt_get_errno>
81139f70:	1007883a 	mov	r3,r2
81139f74:	00801444 	movi	r2,81
81139f78:	18800015 	stw	r2,0(r3)
  }
  return -1;
81139f7c:	00bfffc4 	movi	r2,-1
}
81139f80:	e037883a 	mov	sp,fp
81139f84:	dfc00117 	ldw	ra,4(sp)
81139f88:	df000017 	ldw	fp,0(sp)
81139f8c:	dec00204 	addi	sp,sp,8
81139f90:	f800283a 	ret

81139f94 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81139f94:	deffde04 	addi	sp,sp,-136
81139f98:	de00012e 	bgeu	sp,et,81139fa0 <__env_lock+0xc>
81139f9c:	003b68fa 	trap	3
81139fa0:	dfc02115 	stw	ra,132(sp)
81139fa4:	df002015 	stw	fp,128(sp)
81139fa8:	df002004 	addi	fp,sp,128
81139fac:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81139fb0:	e0bfe104 	addi	r2,fp,-124
81139fb4:	100b883a 	mov	r5,r2
81139fb8:	01003fc4 	movi	r4,255
81139fbc:	11427f40 	call	811427f4 <OSTaskQuery>
81139fc0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81139fc4:	e0bffe83 	ldbu	r2,-6(fp)
81139fc8:	10803fcc 	andi	r2,r2,255
81139fcc:	10001e1e 	bne	r2,zero,8113a048 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81139fd0:	e0bfed83 	ldbu	r2,-74(fp)
81139fd4:	10803fcc 	andi	r2,r2,255
81139fd8:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81139fdc:	d0a08b17 	ldw	r2,-32212(gp)
81139fe0:	e0fffc04 	addi	r3,fp,-16
81139fe4:	180b883a 	mov	r5,r3
81139fe8:	1009883a 	mov	r4,r2
81139fec:	1140fac0 	call	81140fac <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81139ff0:	e0bffe03 	ldbu	r2,-8(fp)
81139ff4:	10803fcc 	andi	r2,r2,255
81139ff8:	10000726 	beq	r2,zero,8113a018 <__env_lock+0x84>
81139ffc:	d0a01617 	ldw	r2,-32680(gp)
8113a000:	e0ffe017 	ldw	r3,-128(fp)
8113a004:	1880041e 	bne	r3,r2,8113a018 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
8113a008:	d0a08a17 	ldw	r2,-32216(gp)
8113a00c:	10800044 	addi	r2,r2,1
8113a010:	d0a08a15 	stw	r2,-32216(gp)
8113a014:	00000a06 	br	8113a040 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
8113a018:	d0a08b17 	ldw	r2,-32212(gp)
8113a01c:	e0fffe84 	addi	r3,fp,-6
8113a020:	180d883a 	mov	r6,r3
8113a024:	000b883a 	mov	r5,zero
8113a028:	1009883a 	mov	r4,r2
8113a02c:	1140b0c0 	call	81140b0c <OSSemPend>
    locks  = 1;
8113a030:	00800044 	movi	r2,1
8113a034:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
8113a038:	e0bfe017 	ldw	r2,-128(fp)
8113a03c:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8113a040:	0001883a 	nop
8113a044:	00000106 	br	8113a04c <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
8113a048:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8113a04c:	e037883a 	mov	sp,fp
8113a050:	dfc00117 	ldw	ra,4(sp)
8113a054:	df000017 	ldw	fp,0(sp)
8113a058:	dec00204 	addi	sp,sp,8
8113a05c:	f800283a 	ret

8113a060 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
8113a060:	defffd04 	addi	sp,sp,-12
8113a064:	de00012e 	bgeu	sp,et,8113a06c <__env_unlock+0xc>
8113a068:	003b68fa 	trap	3
8113a06c:	dfc00215 	stw	ra,8(sp)
8113a070:	df000115 	stw	fp,4(sp)
8113a074:	df000104 	addi	fp,sp,4
8113a078:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
8113a07c:	d0a08a17 	ldw	r2,-32216(gp)
8113a080:	10000b26 	beq	r2,zero,8113a0b0 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
8113a084:	d0a08a17 	ldw	r2,-32216(gp)
8113a088:	10bfffc4 	addi	r2,r2,-1
8113a08c:	d0a08a15 	stw	r2,-32216(gp)
8113a090:	d0a08a17 	ldw	r2,-32216(gp)
8113a094:	1000071e 	bne	r2,zero,8113a0b4 <__env_unlock+0x54>
  {
    lockid = -1;
8113a098:	00bfffc4 	movi	r2,-1
8113a09c:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
8113a0a0:	d0a08b17 	ldw	r2,-32212(gp)
8113a0a4:	1009883a 	mov	r4,r2
8113a0a8:	1140e940 	call	81140e94 <OSSemPost>
8113a0ac:	00000106 	br	8113a0b4 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
8113a0b0:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8113a0b4:	e037883a 	mov	sp,fp
8113a0b8:	dfc00117 	ldw	ra,4(sp)
8113a0bc:	df000017 	ldw	fp,0(sp)
8113a0c0:	dec00204 	addi	sp,sp,8
8113a0c4:	f800283a 	ret

8113a0c8 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
8113a0c8:	deffda04 	addi	sp,sp,-152
8113a0cc:	de00012e 	bgeu	sp,et,8113a0d4 <__malloc_lock+0xc>
8113a0d0:	003b68fa 	trap	3
8113a0d4:	dfc02515 	stw	ra,148(sp)
8113a0d8:	df002415 	stw	fp,144(sp)
8113a0dc:	df002404 	addi	fp,sp,144
8113a0e0:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a0e4:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
8113a0e8:	d0a09103 	ldbu	r2,-32188(gp)
8113a0ec:	10803fcc 	andi	r2,r2,255
8113a0f0:	10800060 	cmpeqi	r2,r2,1
8113a0f4:	10003626 	beq	r2,zero,8113a1d0 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8113a0f8:	e0bfe104 	addi	r2,fp,-124
8113a0fc:	100b883a 	mov	r5,r2
8113a100:	01003fc4 	movi	r4,255
8113a104:	11427f40 	call	811427f4 <OSTaskQuery>
8113a108:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8113a10c:	e0bffe83 	ldbu	r2,-6(fp)
8113a110:	10803fcc 	andi	r2,r2,255
8113a114:	1000301e 	bne	r2,zero,8113a1d8 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
8113a118:	e0bfed83 	ldbu	r2,-74(fp)
8113a11c:	10803fcc 	andi	r2,r2,255
8113a120:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
8113a124:	d0a08d17 	ldw	r2,-32204(gp)
8113a128:	e0fffc04 	addi	r3,fp,-16
8113a12c:	180b883a 	mov	r5,r3
8113a130:	1009883a 	mov	r4,r2
8113a134:	1140fac0 	call	81140fac <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a138:	0005303a 	rdctl	r2,status
8113a13c:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a140:	e0ffe017 	ldw	r3,-128(fp)
8113a144:	00bfff84 	movi	r2,-2
8113a148:	1884703a 	and	r2,r3,r2
8113a14c:	1001703a 	wrctl	status,r2
  
  return context;
8113a150:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8113a154:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
8113a158:	e0bffc0b 	ldhu	r2,-16(fp)
8113a15c:	10bfffcc 	andi	r2,r2,65535
8113a160:	10000b1e 	bne	r2,zero,8113a190 <__malloc_lock+0xc8>
8113a164:	d0a01717 	ldw	r2,-32676(gp)
8113a168:	e0ffdd17 	ldw	r3,-140(fp)
8113a16c:	1880081e 	bne	r3,r2,8113a190 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
8113a170:	d0a08c17 	ldw	r2,-32208(gp)
8113a174:	10800044 	addi	r2,r2,1
8113a178:	d0a08c15 	stw	r2,-32208(gp)
8113a17c:	e0bfdc17 	ldw	r2,-144(fp)
8113a180:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a184:	e0bfde17 	ldw	r2,-136(fp)
8113a188:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
8113a18c:	00000e06 	br	8113a1c8 <__malloc_lock+0x100>
8113a190:	e0bfdc17 	ldw	r2,-144(fp)
8113a194:	e0bfdf15 	stw	r2,-132(fp)
8113a198:	e0bfdf17 	ldw	r2,-132(fp)
8113a19c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
8113a1a0:	d0a08d17 	ldw	r2,-32204(gp)
8113a1a4:	e0fffe84 	addi	r3,fp,-6
8113a1a8:	180d883a 	mov	r6,r3
8113a1ac:	000b883a 	mov	r5,zero
8113a1b0:	1009883a 	mov	r4,r2
8113a1b4:	1140b0c0 	call	81140b0c <OSSemPend>
    locks  = 1;
8113a1b8:	00800044 	movi	r2,1
8113a1bc:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
8113a1c0:	e0bfdd17 	ldw	r2,-140(fp)
8113a1c4:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8113a1c8:	0001883a 	nop
8113a1cc:	00000306 	br	8113a1dc <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
8113a1d0:	0001883a 	nop
8113a1d4:	00000106 	br	8113a1dc <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
8113a1d8:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8113a1dc:	e037883a 	mov	sp,fp
8113a1e0:	dfc00117 	ldw	ra,4(sp)
8113a1e4:	df000017 	ldw	fp,0(sp)
8113a1e8:	dec00204 	addi	sp,sp,8
8113a1ec:	f800283a 	ret

8113a1f0 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
8113a1f0:	defff804 	addi	sp,sp,-32
8113a1f4:	de00012e 	bgeu	sp,et,8113a1fc <__malloc_unlock+0xc>
8113a1f8:	003b68fa 	trap	3
8113a1fc:	dfc00715 	stw	ra,28(sp)
8113a200:	df000615 	stw	fp,24(sp)
8113a204:	df000604 	addi	fp,sp,24
8113a208:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a20c:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
8113a210:	d0a09103 	ldbu	r2,-32188(gp)
8113a214:	10803fcc 	andi	r2,r2,255
8113a218:	10800060 	cmpeqi	r2,r2,1
8113a21c:	10002326 	beq	r2,zero,8113a2ac <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a220:	0005303a 	rdctl	r2,status
8113a224:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a228:	e0fffe17 	ldw	r3,-8(fp)
8113a22c:	00bfff84 	movi	r2,-2
8113a230:	1884703a 	and	r2,r3,r2
8113a234:	1001703a 	wrctl	status,r2
  
  return context;
8113a238:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
8113a23c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
8113a240:	d0a08c17 	ldw	r2,-32208(gp)
8113a244:	1000051e 	bne	r2,zero,8113a25c <__malloc_unlock+0x6c>
8113a248:	e0bffa17 	ldw	r2,-24(fp)
8113a24c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a250:	e0bffb17 	ldw	r2,-20(fp)
8113a254:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
8113a258:	00001506 	br	8113a2b0 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
8113a25c:	d0a08c17 	ldw	r2,-32208(gp)
8113a260:	10bfffc4 	addi	r2,r2,-1
8113a264:	d0a08c15 	stw	r2,-32208(gp)
8113a268:	d0a08c17 	ldw	r2,-32208(gp)
8113a26c:	10000a1e 	bne	r2,zero,8113a298 <__malloc_unlock+0xa8>
  {
    lockid = -1;
8113a270:	00bfffc4 	movi	r2,-1
8113a274:	d0a01715 	stw	r2,-32676(gp)
8113a278:	e0bffa17 	ldw	r2,-24(fp)
8113a27c:	e0bffc15 	stw	r2,-16(fp)
8113a280:	e0bffc17 	ldw	r2,-16(fp)
8113a284:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
8113a288:	d0a08d17 	ldw	r2,-32204(gp)
8113a28c:	1009883a 	mov	r4,r2
8113a290:	1140e940 	call	81140e94 <OSSemPost>
8113a294:	00000606 	br	8113a2b0 <__malloc_unlock+0xc0>
8113a298:	e0bffa17 	ldw	r2,-24(fp)
8113a29c:	e0bffd15 	stw	r2,-12(fp)
8113a2a0:	e0bffd17 	ldw	r2,-12(fp)
8113a2a4:	1001703a 	wrctl	status,r2
8113a2a8:	00000106 	br	8113a2b0 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
8113a2ac:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8113a2b0:	e037883a 	mov	sp,fp
8113a2b4:	dfc00117 	ldw	ra,4(sp)
8113a2b8:	df000017 	ldw	fp,0(sp)
8113a2bc:	dec00204 	addi	sp,sp,8
8113a2c0:	f800283a 	ret

8113a2c4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8113a2c4:	defff704 	addi	sp,sp,-36
8113a2c8:	de00012e 	bgeu	sp,et,8113a2d0 <OSEventNameGet+0xc>
8113a2cc:	003b68fa 	trap	3
8113a2d0:	dfc00815 	stw	ra,32(sp)
8113a2d4:	df000715 	stw	fp,28(sp)
8113a2d8:	df000704 	addi	fp,sp,28
8113a2dc:	e13ffd15 	stw	r4,-12(fp)
8113a2e0:	e17ffe15 	stw	r5,-8(fp)
8113a2e4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a2e8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a2ec:	e0bfff17 	ldw	r2,-4(fp)
8113a2f0:	1000021e 	bne	r2,zero,8113a2fc <OSEventNameGet+0x38>
        return (0);
8113a2f4:	0005883a 	mov	r2,zero
8113a2f8:	00003706 	br	8113a3d8 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113a2fc:	e0bffd17 	ldw	r2,-12(fp)
8113a300:	1000051e 	bne	r2,zero,8113a318 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
8113a304:	e0bfff17 	ldw	r2,-4(fp)
8113a308:	00c00104 	movi	r3,4
8113a30c:	10c00005 	stb	r3,0(r2)
        return (0);
8113a310:	0005883a 	mov	r2,zero
8113a314:	00003006 	br	8113a3d8 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a318:	e0bffe17 	ldw	r2,-8(fp)
8113a31c:	1000051e 	bne	r2,zero,8113a334 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113a320:	e0bfff17 	ldw	r2,-4(fp)
8113a324:	00c00304 	movi	r3,12
8113a328:	10c00005 	stb	r3,0(r2)
        return (0);
8113a32c:	0005883a 	mov	r2,zero
8113a330:	00002906 	br	8113a3d8 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a334:	d0a0a103 	ldbu	r2,-32124(gp)
8113a338:	10803fcc 	andi	r2,r2,255
8113a33c:	10000526 	beq	r2,zero,8113a354 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
8113a340:	e0bfff17 	ldw	r2,-4(fp)
8113a344:	00c00444 	movi	r3,17
8113a348:	10c00005 	stb	r3,0(r2)
        return (0);
8113a34c:	0005883a 	mov	r2,zero
8113a350:	00002106 	br	8113a3d8 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8113a354:	e0bffd17 	ldw	r2,-12(fp)
8113a358:	10800003 	ldbu	r2,0(r2)
8113a35c:	10803fcc 	andi	r2,r2,255
8113a360:	10bfffc4 	addi	r2,r2,-1
8113a364:	10800128 	cmpgeui	r2,r2,4
8113a368:	10000526 	beq	r2,zero,8113a380 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113a36c:	e0bfff17 	ldw	r2,-4(fp)
8113a370:	00c00044 	movi	r3,1
8113a374:	10c00005 	stb	r3,0(r2)
             return (0);
8113a378:	0005883a 	mov	r2,zero
8113a37c:	00001606 	br	8113a3d8 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113a380:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a384:	0005303a 	rdctl	r2,status
8113a388:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a38c:	e0fffb17 	ldw	r3,-20(fp)
8113a390:	00bfff84 	movi	r2,-2
8113a394:	1884703a 	and	r2,r3,r2
8113a398:	1001703a 	wrctl	status,r2
  
  return context;
8113a39c:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
8113a3a0:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
8113a3a4:	e0bffd17 	ldw	r2,-12(fp)
8113a3a8:	10800444 	addi	r2,r2,17
8113a3ac:	100b883a 	mov	r5,r2
8113a3b0:	e13ffe17 	ldw	r4,-8(fp)
8113a3b4:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8113a3b8:	e0bffa05 	stb	r2,-24(fp)
8113a3bc:	e0bff917 	ldw	r2,-28(fp)
8113a3c0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a3c4:	e0bffc17 	ldw	r2,-16(fp)
8113a3c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a3cc:	e0bfff17 	ldw	r2,-4(fp)
8113a3d0:	10000005 	stb	zero,0(r2)
    return (len);
8113a3d4:	e0bffa03 	ldbu	r2,-24(fp)
}
8113a3d8:	e037883a 	mov	sp,fp
8113a3dc:	dfc00117 	ldw	ra,4(sp)
8113a3e0:	df000017 	ldw	fp,0(sp)
8113a3e4:	dec00204 	addi	sp,sp,8
8113a3e8:	f800283a 	ret

8113a3ec <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8113a3ec:	defff604 	addi	sp,sp,-40
8113a3f0:	de00012e 	bgeu	sp,et,8113a3f8 <OSEventNameSet+0xc>
8113a3f4:	003b68fa 	trap	3
8113a3f8:	dfc00915 	stw	ra,36(sp)
8113a3fc:	df000815 	stw	fp,32(sp)
8113a400:	df000804 	addi	fp,sp,32
8113a404:	e13ffd15 	stw	r4,-12(fp)
8113a408:	e17ffe15 	stw	r5,-8(fp)
8113a40c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a410:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a414:	e0bfff17 	ldw	r2,-4(fp)
8113a418:	10004026 	beq	r2,zero,8113a51c <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113a41c:	e0bffd17 	ldw	r2,-12(fp)
8113a420:	1000041e 	bne	r2,zero,8113a434 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113a424:	e0bfff17 	ldw	r2,-4(fp)
8113a428:	00c00104 	movi	r3,4
8113a42c:	10c00005 	stb	r3,0(r2)
        return;
8113a430:	00003b06 	br	8113a520 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a434:	e0bffe17 	ldw	r2,-8(fp)
8113a438:	1000041e 	bne	r2,zero,8113a44c <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113a43c:	e0bfff17 	ldw	r2,-4(fp)
8113a440:	00c00304 	movi	r3,12
8113a444:	10c00005 	stb	r3,0(r2)
        return;
8113a448:	00003506 	br	8113a520 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a44c:	d0a0a103 	ldbu	r2,-32124(gp)
8113a450:	10803fcc 	andi	r2,r2,255
8113a454:	10000426 	beq	r2,zero,8113a468 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113a458:	e0bfff17 	ldw	r2,-4(fp)
8113a45c:	00c00484 	movi	r3,18
8113a460:	10c00005 	stb	r3,0(r2)
        return;
8113a464:	00002e06 	br	8113a520 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
8113a468:	e0bffd17 	ldw	r2,-12(fp)
8113a46c:	10800003 	ldbu	r2,0(r2)
8113a470:	10803fcc 	andi	r2,r2,255
8113a474:	10bfffc4 	addi	r2,r2,-1
8113a478:	10800128 	cmpgeui	r2,r2,4
8113a47c:	10000426 	beq	r2,zero,8113a490 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113a480:	e0bfff17 	ldw	r2,-4(fp)
8113a484:	00c00044 	movi	r3,1
8113a488:	10c00005 	stb	r3,0(r2)
             return;
8113a48c:	00002406 	br	8113a520 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113a490:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a494:	0005303a 	rdctl	r2,status
8113a498:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a49c:	e0fffc17 	ldw	r3,-16(fp)
8113a4a0:	00bfff84 	movi	r2,-2
8113a4a4:	1884703a 	and	r2,r3,r2
8113a4a8:	1001703a 	wrctl	status,r2
  
  return context;
8113a4ac:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
8113a4b0:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8113a4b4:	e13ffe17 	ldw	r4,-8(fp)
8113a4b8:	113be2c0 	call	8113be2c <OS_StrLen>
8113a4bc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
8113a4c0:	e0bffa03 	ldbu	r2,-24(fp)
8113a4c4:	10800830 	cmpltui	r2,r2,32
8113a4c8:	1000081e 	bne	r2,zero,8113a4ec <OSEventNameSet+0x100>
8113a4cc:	e0bff817 	ldw	r2,-32(fp)
8113a4d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a4d4:	e0bff917 	ldw	r2,-28(fp)
8113a4d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8113a4dc:	e0bfff17 	ldw	r2,-4(fp)
8113a4e0:	00c002c4 	movi	r3,11
8113a4e4:	10c00005 	stb	r3,0(r2)
        return;
8113a4e8:	00000d06 	br	8113a520 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
8113a4ec:	e0bffd17 	ldw	r2,-12(fp)
8113a4f0:	10800444 	addi	r2,r2,17
8113a4f4:	e17ffe17 	ldw	r5,-8(fp)
8113a4f8:	1009883a 	mov	r4,r2
8113a4fc:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8113a500:	e0bff817 	ldw	r2,-32(fp)
8113a504:	e0bffb15 	stw	r2,-20(fp)
8113a508:	e0bffb17 	ldw	r2,-20(fp)
8113a50c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a510:	e0bfff17 	ldw	r2,-4(fp)
8113a514:	10000005 	stb	zero,0(r2)
8113a518:	00000106 	br	8113a520 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113a51c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113a520:	e037883a 	mov	sp,fp
8113a524:	dfc00117 	ldw	ra,4(sp)
8113a528:	df000017 	ldw	fp,0(sp)
8113a52c:	dec00204 	addi	sp,sp,8
8113a530:	f800283a 	ret

8113a534 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8113a534:	deffed04 	addi	sp,sp,-76
8113a538:	de00012e 	bgeu	sp,et,8113a540 <OSEventPendMulti+0xc>
8113a53c:	003b68fa 	trap	3
8113a540:	dfc01215 	stw	ra,72(sp)
8113a544:	df001115 	stw	fp,68(sp)
8113a548:	df001104 	addi	fp,sp,68
8113a54c:	e13ffc15 	stw	r4,-16(fp)
8113a550:	e17ffd15 	stw	r5,-12(fp)
8113a554:	e1bffe15 	stw	r6,-8(fp)
8113a558:	3805883a 	mov	r2,r7
8113a55c:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
8113a560:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8113a564:	e0800217 	ldw	r2,8(fp)
8113a568:	1000021e 	bne	r2,zero,8113a574 <OSEventPendMulti+0x40>
        return (0);
8113a56c:	0005883a 	mov	r2,zero
8113a570:	00015006 	br	8113aab4 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8113a574:	e0bffc17 	ldw	r2,-16(fp)
8113a578:	1000051e 	bne	r2,zero,8113a590 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
8113a57c:	e0800217 	ldw	r2,8(fp)
8113a580:	00c00104 	movi	r3,4
8113a584:	10c00005 	stb	r3,0(r2)
        return (0);
8113a588:	0005883a 	mov	r2,zero
8113a58c:	00014906 	br	8113aab4 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
8113a590:	e0bffd17 	ldw	r2,-12(fp)
8113a594:	1000051e 	bne	r2,zero,8113a5ac <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
8113a598:	e0800217 	ldw	r2,8(fp)
8113a59c:	00c00104 	movi	r3,4
8113a5a0:	10c00005 	stb	r3,0(r2)
        return (0);
8113a5a4:	0005883a 	mov	r2,zero
8113a5a8:	00014206 	br	8113aab4 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8113a5ac:	e0bffe17 	ldw	r2,-8(fp)
8113a5b0:	1000051e 	bne	r2,zero,8113a5c8 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8113a5b4:	e0800217 	ldw	r2,8(fp)
8113a5b8:	00c00104 	movi	r3,4
8113a5bc:	10c00005 	stb	r3,0(r2)
        return (0);
8113a5c0:	0005883a 	mov	r2,zero
8113a5c4:	00013b06 	br	8113aab4 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
8113a5c8:	e0bffd17 	ldw	r2,-12(fp)
8113a5cc:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
8113a5d0:	e0bffc17 	ldw	r2,-16(fp)
8113a5d4:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
8113a5d8:	e0bfef17 	ldw	r2,-68(fp)
8113a5dc:	10800017 	ldw	r2,0(r2)
8113a5e0:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
8113a5e4:	00001506 	br	8113a63c <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
8113a5e8:	e0bff017 	ldw	r2,-64(fp)
8113a5ec:	10800003 	ldbu	r2,0(r2)
8113a5f0:	10803fcc 	andi	r2,r2,255
8113a5f4:	10c000a0 	cmpeqi	r3,r2,2
8113a5f8:	1800071e 	bne	r3,zero,8113a618 <OSEventPendMulti+0xe4>
8113a5fc:	108000e0 	cmpeqi	r2,r2,3
8113a600:	1000071e 	bne	r2,zero,8113a620 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
8113a604:	e0800217 	ldw	r2,8(fp)
8113a608:	00c00044 	movi	r3,1
8113a60c:	10c00005 	stb	r3,0(r2)
                 return (0);
8113a610:	0005883a 	mov	r2,zero
8113a614:	00012706 	br	8113aab4 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
8113a618:	0001883a 	nop
8113a61c:	00000106 	br	8113a624 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8113a620:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8113a624:	e0bfef17 	ldw	r2,-68(fp)
8113a628:	10800104 	addi	r2,r2,4
8113a62c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113a630:	e0bfef17 	ldw	r2,-68(fp)
8113a634:	10800017 	ldw	r2,0(r2)
8113a638:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
8113a63c:	e0bff017 	ldw	r2,-64(fp)
8113a640:	103fe91e 	bne	r2,zero,8113a5e8 <__reset+0xfb11a5e8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8113a644:	d0a0a103 	ldbu	r2,-32124(gp)
8113a648:	10803fcc 	andi	r2,r2,255
8113a64c:	10000526 	beq	r2,zero,8113a664 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
8113a650:	e0800217 	ldw	r2,8(fp)
8113a654:	00c00084 	movi	r3,2
8113a658:	10c00005 	stb	r3,0(r2)
        return (0);
8113a65c:	0005883a 	mov	r2,zero
8113a660:	00011406 	br	8113aab4 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8113a664:	d0a08f03 	ldbu	r2,-32196(gp)
8113a668:	10803fcc 	andi	r2,r2,255
8113a66c:	10000526 	beq	r2,zero,8113a684 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
8113a670:	e0800217 	ldw	r2,8(fp)
8113a674:	00c00344 	movi	r3,13
8113a678:	10c00005 	stb	r3,0(r2)
        return (0);
8113a67c:	0005883a 	mov	r2,zero
8113a680:	00010c06 	br	8113aab4 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a684:	0005303a 	rdctl	r2,status
8113a688:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a68c:	e0fffb17 	ldw	r3,-20(fp)
8113a690:	00bfff84 	movi	r2,-2
8113a694:	1884703a 	and	r2,r3,r2
8113a698:	1001703a 	wrctl	status,r2
  
  return context;
8113a69c:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a6a0:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8113a6a4:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
8113a6a8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8113a6ac:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
8113a6b0:	e0bffc17 	ldw	r2,-16(fp)
8113a6b4:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
8113a6b8:	e0bfef17 	ldw	r2,-68(fp)
8113a6bc:	10800017 	ldw	r2,0(r2)
8113a6c0:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113a6c4:	00006406 	br	8113a858 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
8113a6c8:	e0bff017 	ldw	r2,-64(fp)
8113a6cc:	10800003 	ldbu	r2,0(r2)
8113a6d0:	10803fcc 	andi	r2,r2,255
8113a6d4:	10c000a0 	cmpeqi	r3,r2,2
8113a6d8:	18001f1e 	bne	r3,zero,8113a758 <OSEventPendMulti+0x224>
8113a6dc:	108000e0 	cmpeqi	r2,r2,3
8113a6e0:	10004c26 	beq	r2,zero,8113a814 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
8113a6e4:	e0bff017 	ldw	r2,-64(fp)
8113a6e8:	1080020b 	ldhu	r2,8(r2)
8113a6ec:	10bfffcc 	andi	r2,r2,65535
8113a6f0:	10001526 	beq	r2,zero,8113a748 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
8113a6f4:	e0bff017 	ldw	r2,-64(fp)
8113a6f8:	1080020b 	ldhu	r2,8(r2)
8113a6fc:	10bfffc4 	addi	r2,r2,-1
8113a700:	1007883a 	mov	r3,r2
8113a704:	e0bff017 	ldw	r2,-64(fp)
8113a708:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8113a70c:	e0bffd17 	ldw	r2,-12(fp)
8113a710:	10c00104 	addi	r3,r2,4
8113a714:	e0fffd15 	stw	r3,-12(fp)
8113a718:	e0fff017 	ldw	r3,-64(fp)
8113a71c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8113a720:	00800044 	movi	r2,1
8113a724:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
8113a728:	e0bffe17 	ldw	r2,-8(fp)
8113a72c:	10c00104 	addi	r3,r2,4
8113a730:	e0fffe15 	stw	r3,-8(fp)
8113a734:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
8113a738:	e0bff18b 	ldhu	r2,-58(fp)
8113a73c:	10800044 	addi	r2,r2,1
8113a740:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
8113a744:	00003e06 	br	8113a840 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
8113a748:	e0bff203 	ldbu	r2,-56(fp)
8113a74c:	10800054 	ori	r2,r2,1
8113a750:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113a754:	00003a06 	br	8113a840 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
8113a758:	e0bff017 	ldw	r2,-64(fp)
8113a75c:	10800117 	ldw	r2,4(r2)
8113a760:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
8113a764:	e0bff517 	ldw	r2,-44(fp)
8113a768:	1080058b 	ldhu	r2,22(r2)
8113a76c:	10bfffcc 	andi	r2,r2,65535
8113a770:	10002426 	beq	r2,zero,8113a804 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
8113a774:	e0bffe17 	ldw	r2,-8(fp)
8113a778:	10c00104 	addi	r3,r2,4
8113a77c:	e0fffe15 	stw	r3,-8(fp)
8113a780:	e0fff517 	ldw	r3,-44(fp)
8113a784:	18c00417 	ldw	r3,16(r3)
8113a788:	19400104 	addi	r5,r3,4
8113a78c:	e13ff517 	ldw	r4,-44(fp)
8113a790:	21400415 	stw	r5,16(r4)
8113a794:	18c00017 	ldw	r3,0(r3)
8113a798:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
8113a79c:	e0bff517 	ldw	r2,-44(fp)
8113a7a0:	10c00417 	ldw	r3,16(r2)
8113a7a4:	e0bff517 	ldw	r2,-44(fp)
8113a7a8:	10800217 	ldw	r2,8(r2)
8113a7ac:	1880041e 	bne	r3,r2,8113a7c0 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8113a7b0:	e0bff517 	ldw	r2,-44(fp)
8113a7b4:	10c00117 	ldw	r3,4(r2)
8113a7b8:	e0bff517 	ldw	r2,-44(fp)
8113a7bc:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8113a7c0:	e0bff517 	ldw	r2,-44(fp)
8113a7c4:	1080058b 	ldhu	r2,22(r2)
8113a7c8:	10bfffc4 	addi	r2,r2,-1
8113a7cc:	1007883a 	mov	r3,r2
8113a7d0:	e0bff517 	ldw	r2,-44(fp)
8113a7d4:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
8113a7d8:	e0bffd17 	ldw	r2,-12(fp)
8113a7dc:	10c00104 	addi	r3,r2,4
8113a7e0:	e0fffd15 	stw	r3,-12(fp)
8113a7e4:	e0fff017 	ldw	r3,-64(fp)
8113a7e8:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8113a7ec:	00800044 	movi	r2,1
8113a7f0:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
8113a7f4:	e0bff18b 	ldhu	r2,-58(fp)
8113a7f8:	10800044 	addi	r2,r2,1
8113a7fc:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8113a800:	00000f06 	br	8113a840 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
8113a804:	e0bff203 	ldbu	r2,-56(fp)
8113a808:	10800114 	ori	r2,r2,4
8113a80c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113a810:	00000b06 	br	8113a840 <OSEventPendMulti+0x30c>
8113a814:	e0bff317 	ldw	r2,-52(fp)
8113a818:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a81c:	e0bff417 	ldw	r2,-48(fp)
8113a820:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
8113a824:	e0bffd17 	ldw	r2,-12(fp)
8113a828:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8113a82c:	e0800217 	ldw	r2,8(fp)
8113a830:	00c00044 	movi	r3,1
8113a834:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
8113a838:	e0bff18b 	ldhu	r2,-58(fp)
8113a83c:	00009d06 	br	8113aab4 <OSEventPendMulti+0x580>
        }
        pevents++;
8113a840:	e0bfef17 	ldw	r2,-68(fp)
8113a844:	10800104 	addi	r2,r2,4
8113a848:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113a84c:	e0bfef17 	ldw	r2,-68(fp)
8113a850:	10800017 	ldw	r2,0(r2)
8113a854:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113a858:	e0bff017 	ldw	r2,-64(fp)
8113a85c:	103f9a1e 	bne	r2,zero,8113a6c8 <__reset+0xfb11a6c8>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
8113a860:	e0bff103 	ldbu	r2,-60(fp)
8113a864:	10800058 	cmpnei	r2,r2,1
8113a868:	10000a1e 	bne	r2,zero,8113a894 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
8113a86c:	e0bffd17 	ldw	r2,-12(fp)
8113a870:	10000015 	stw	zero,0(r2)
8113a874:	e0bff317 	ldw	r2,-52(fp)
8113a878:	e0bff615 	stw	r2,-40(fp)
8113a87c:	e0bff617 	ldw	r2,-40(fp)
8113a880:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
8113a884:	e0800217 	ldw	r2,8(fp)
8113a888:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
8113a88c:	e0bff18b 	ldhu	r2,-58(fp)
8113a890:	00008806 	br	8113aab4 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
8113a894:	d0a0a217 	ldw	r2,-32120(gp)
8113a898:	d0e0a217 	ldw	r3,-32120(gp)
8113a89c:	19000c03 	ldbu	r4,48(r3)
8113a8a0:	e0fff203 	ldbu	r3,-56(fp)
8113a8a4:	20c6b03a 	or	r3,r4,r3
8113a8a8:	1809883a 	mov	r4,r3
8113a8ac:	00ffe004 	movi	r3,-128
8113a8b0:	20c6b03a 	or	r3,r4,r3
8113a8b4:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113a8b8:	d0a0a217 	ldw	r2,-32120(gp)
8113a8bc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8113a8c0:	d0a0a217 	ldw	r2,-32120(gp)
8113a8c4:	e0ffff0b 	ldhu	r3,-4(fp)
8113a8c8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
8113a8cc:	e13ffc17 	ldw	r4,-16(fp)
8113a8d0:	113b4580 	call	8113b458 <OS_EventTaskWaitMulti>
8113a8d4:	e0bff317 	ldw	r2,-52(fp)
8113a8d8:	e0bff915 	stw	r2,-28(fp)
8113a8dc:	e0bff917 	ldw	r2,-28(fp)
8113a8e0:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
8113a8e4:	113bc5c0 	call	8113bc5c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8e8:	0005303a 	rdctl	r2,status
8113a8ec:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8f0:	e0fff717 	ldw	r3,-36(fp)
8113a8f4:	00bfff84 	movi	r2,-2
8113a8f8:	1884703a 	and	r2,r3,r2
8113a8fc:	1001703a 	wrctl	status,r2
  
  return context;
8113a900:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
8113a904:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
8113a908:	d0a0a217 	ldw	r2,-32120(gp)
8113a90c:	10800c43 	ldbu	r2,49(r2)
8113a910:	10803fcc 	andi	r2,r2,255
8113a914:	10000226 	beq	r2,zero,8113a920 <OSEventPendMulti+0x3ec>
8113a918:	108000a0 	cmpeqi	r2,r2,2
8113a91c:	10001826 	beq	r2,zero,8113a980 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113a920:	d0a0a217 	ldw	r2,-32120(gp)
8113a924:	10800717 	ldw	r2,28(r2)
8113a928:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8113a92c:	e0bff017 	ldw	r2,-64(fp)
8113a930:	10000b26 	beq	r2,zero,8113a960 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
8113a934:	e0bffd17 	ldw	r2,-12(fp)
8113a938:	10c00104 	addi	r3,r2,4
8113a93c:	e0fffd15 	stw	r3,-12(fp)
8113a940:	e0fff017 	ldw	r3,-64(fp)
8113a944:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
8113a948:	e0bffd17 	ldw	r2,-12(fp)
8113a94c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8113a950:	e0bff18b 	ldhu	r2,-58(fp)
8113a954:	10800044 	addi	r2,r2,1
8113a958:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
8113a95c:	00000d06 	br	8113a994 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8113a960:	d0a0a217 	ldw	r2,-32120(gp)
8113a964:	00c00044 	movi	r3,1
8113a968:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113a96c:	d0a0a217 	ldw	r2,-32120(gp)
8113a970:	e17ffc17 	ldw	r5,-16(fp)
8113a974:	1009883a 	mov	r4,r2
8113a978:	113b6700 	call	8113b670 <OS_EventTaskRemoveMulti>
             }
			 break;
8113a97c:	00000506 	br	8113a994 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113a980:	d0a0a217 	ldw	r2,-32120(gp)
8113a984:	e17ffc17 	ldw	r5,-16(fp)
8113a988:	1009883a 	mov	r4,r2
8113a98c:	113b6700 	call	8113b670 <OS_EventTaskRemoveMulti>
             break;
8113a990:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
8113a994:	d0a0a217 	ldw	r2,-32120(gp)
8113a998:	10800c43 	ldbu	r2,49(r2)
8113a99c:	10803fcc 	andi	r2,r2,255
8113a9a0:	10000326 	beq	r2,zero,8113a9b0 <OSEventPendMulti+0x47c>
8113a9a4:	108000a0 	cmpeqi	r2,r2,2
8113a9a8:	1000231e 	bne	r2,zero,8113aa38 <OSEventPendMulti+0x504>
8113a9ac:	00002a06 	br	8113aa58 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8113a9b0:	e0bff017 	ldw	r2,-64(fp)
8113a9b4:	10800003 	ldbu	r2,0(r2)
8113a9b8:	10803fcc 	andi	r2,r2,255
8113a9bc:	0080100e 	bge	zero,r2,8113aa00 <OSEventPendMulti+0x4cc>
8113a9c0:	10c000d0 	cmplti	r3,r2,3
8113a9c4:	1800071e 	bne	r3,zero,8113a9e4 <OSEventPendMulti+0x4b0>
8113a9c8:	108000e0 	cmpeqi	r2,r2,3
8113a9cc:	10000c26 	beq	r2,zero,8113aa00 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
8113a9d0:	e0bffe17 	ldw	r2,-8(fp)
8113a9d4:	10c00104 	addi	r3,r2,4
8113a9d8:	e0fffe15 	stw	r3,-8(fp)
8113a9dc:	10000015 	stw	zero,0(r2)
                      break;
8113a9e0:	00001206 	br	8113aa2c <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
8113a9e4:	e0bffe17 	ldw	r2,-8(fp)
8113a9e8:	10c00104 	addi	r3,r2,4
8113a9ec:	e0fffe15 	stw	r3,-8(fp)
8113a9f0:	d0e0a217 	ldw	r3,-32120(gp)
8113a9f4:	18c00917 	ldw	r3,36(r3)
8113a9f8:	10c00015 	stw	r3,0(r2)
                      break;
8113a9fc:	00000b06 	br	8113aa2c <OSEventPendMulti+0x4f8>
8113aa00:	e0bff317 	ldw	r2,-52(fp)
8113aa04:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aa08:	e0bff817 	ldw	r2,-32(fp)
8113aa0c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
8113aa10:	e0bffd17 	ldw	r2,-12(fp)
8113aa14:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
8113aa18:	e0800217 	ldw	r2,8(fp)
8113aa1c:	00c00044 	movi	r3,1
8113aa20:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
8113aa24:	e0bff18b 	ldhu	r2,-58(fp)
8113aa28:	00002206 	br	8113aab4 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8113aa2c:	e0800217 	ldw	r2,8(fp)
8113aa30:	10000005 	stb	zero,0(r2)
             break;
8113aa34:	00001006 	br	8113aa78 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
8113aa38:	e0bffe17 	ldw	r2,-8(fp)
8113aa3c:	10c00104 	addi	r3,r2,4
8113aa40:	e0fffe15 	stw	r3,-8(fp)
8113aa44:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
8113aa48:	e0800217 	ldw	r2,8(fp)
8113aa4c:	00c00384 	movi	r3,14
8113aa50:	10c00005 	stb	r3,0(r2)
             break;
8113aa54:	00000806 	br	8113aa78 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
8113aa58:	e0bffe17 	ldw	r2,-8(fp)
8113aa5c:	10c00104 	addi	r3,r2,4
8113aa60:	e0fffe15 	stw	r3,-8(fp)
8113aa64:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
8113aa68:	e0800217 	ldw	r2,8(fp)
8113aa6c:	00c00284 	movi	r3,10
8113aa70:	10c00005 	stb	r3,0(r2)
             break;
8113aa74:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
8113aa78:	d0a0a217 	ldw	r2,-32120(gp)
8113aa7c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
8113aa80:	d0a0a217 	ldw	r2,-32120(gp)
8113aa84:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
8113aa88:	d0a0a217 	ldw	r2,-32120(gp)
8113aa8c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113aa90:	d0a0a217 	ldw	r2,-32120(gp)
8113aa94:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
8113aa98:	d0a0a217 	ldw	r2,-32120(gp)
8113aa9c:	10000915 	stw	zero,36(r2)
8113aaa0:	e0bff317 	ldw	r2,-52(fp)
8113aaa4:	e0bffa15 	stw	r2,-24(fp)
8113aaa8:	e0bffa17 	ldw	r2,-24(fp)
8113aaac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
8113aab0:	e0bff18b 	ldhu	r2,-58(fp)
}
8113aab4:	e037883a 	mov	sp,fp
8113aab8:	dfc00117 	ldw	ra,4(sp)
8113aabc:	df000017 	ldw	fp,0(sp)
8113aac0:	dec00204 	addi	sp,sp,8
8113aac4:	f800283a 	ret

8113aac8 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
8113aac8:	defffe04 	addi	sp,sp,-8
8113aacc:	de00012e 	bgeu	sp,et,8113aad4 <OSInit+0xc>
8113aad0:	003b68fa 	trap	3
8113aad4:	dfc00115 	stw	ra,4(sp)
8113aad8:	df000015 	stw	fp,0(sp)
8113aadc:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
8113aae0:	114cfcc0 	call	8114cfcc <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
8113aae4:	113b8d00 	call	8113b8d0 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
8113aae8:	113b9200 	call	8113b920 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
8113aaec:	113baa40 	call	8113baa4 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
8113aaf0:	113b7e80 	call	8113b7e8 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
8113aaf4:	113da640 	call	8113da64 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
8113aaf8:	113e3ac0 	call	8113e3ac <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
8113aafc:	114067c0 	call	8114067c <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
8113ab00:	113b9940 	call	8113b994 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
8113ab04:	113ba1c0 	call	8113ba1c <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
8113ab08:	1143a200 	call	81143a20 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
8113ab0c:	114cff80 	call	8114cff8 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
8113ab10:	113c3800 	call	8113c380 <OSDebugInit>
#endif
}
8113ab14:	0001883a 	nop
8113ab18:	e037883a 	mov	sp,fp
8113ab1c:	dfc00117 	ldw	ra,4(sp)
8113ab20:	df000017 	ldw	fp,0(sp)
8113ab24:	dec00204 	addi	sp,sp,8
8113ab28:	f800283a 	ret

8113ab2c <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
8113ab2c:	deffff04 	addi	sp,sp,-4
8113ab30:	de00012e 	bgeu	sp,et,8113ab38 <OSIntEnter+0xc>
8113ab34:	003b68fa 	trap	3
8113ab38:	df000015 	stw	fp,0(sp)
8113ab3c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
8113ab40:	d0a09103 	ldbu	r2,-32188(gp)
8113ab44:	10803fcc 	andi	r2,r2,255
8113ab48:	10800058 	cmpnei	r2,r2,1
8113ab4c:	1000071e 	bne	r2,zero,8113ab6c <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
8113ab50:	d0a0a103 	ldbu	r2,-32124(gp)
8113ab54:	10803fcc 	andi	r2,r2,255
8113ab58:	10803fe0 	cmpeqi	r2,r2,255
8113ab5c:	1000031e 	bne	r2,zero,8113ab6c <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
8113ab60:	d0a0a103 	ldbu	r2,-32124(gp)
8113ab64:	10800044 	addi	r2,r2,1
8113ab68:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
8113ab6c:	0001883a 	nop
8113ab70:	e037883a 	mov	sp,fp
8113ab74:	df000017 	ldw	fp,0(sp)
8113ab78:	dec00104 	addi	sp,sp,4
8113ab7c:	f800283a 	ret

8113ab80 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
8113ab80:	defffb04 	addi	sp,sp,-20
8113ab84:	de00012e 	bgeu	sp,et,8113ab8c <OSIntExit+0xc>
8113ab88:	003b68fa 	trap	3
8113ab8c:	dfc00415 	stw	ra,16(sp)
8113ab90:	df000315 	stw	fp,12(sp)
8113ab94:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113ab98:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
8113ab9c:	d0a09103 	ldbu	r2,-32188(gp)
8113aba0:	10803fcc 	andi	r2,r2,255
8113aba4:	10800058 	cmpnei	r2,r2,1
8113aba8:	10002f1e 	bne	r2,zero,8113ac68 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113abac:	0005303a 	rdctl	r2,status
8113abb0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113abb4:	e0ffff17 	ldw	r3,-4(fp)
8113abb8:	00bfff84 	movi	r2,-2
8113abbc:	1884703a 	and	r2,r3,r2
8113abc0:	1001703a 	wrctl	status,r2
  
  return context;
8113abc4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113abc8:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
8113abcc:	d0a0a103 	ldbu	r2,-32124(gp)
8113abd0:	10803fcc 	andi	r2,r2,255
8113abd4:	10000326 	beq	r2,zero,8113abe4 <OSIntExit+0x64>
            OSIntNesting--;
8113abd8:	d0a0a103 	ldbu	r2,-32124(gp)
8113abdc:	10bfffc4 	addi	r2,r2,-1
8113abe0:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
8113abe4:	d0a0a103 	ldbu	r2,-32124(gp)
8113abe8:	10803fcc 	andi	r2,r2,255
8113abec:	10001a1e 	bne	r2,zero,8113ac58 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
8113abf0:	d0a08f03 	ldbu	r2,-32196(gp)
8113abf4:	10803fcc 	andi	r2,r2,255
8113abf8:	1000171e 	bne	r2,zero,8113ac58 <OSIntExit+0xd8>
                OS_SchedNew();
8113abfc:	113bd340 	call	8113bd34 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
8113ac00:	d0e09383 	ldbu	r3,-32178(gp)
8113ac04:	d0a093c3 	ldbu	r2,-32177(gp)
8113ac08:	18c03fcc 	andi	r3,r3,255
8113ac0c:	10803fcc 	andi	r2,r2,255
8113ac10:	18801126 	beq	r3,r2,8113ac58 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
8113ac14:	d0a09383 	ldbu	r2,-32178(gp)
8113ac18:	10c03fcc 	andi	r3,r2,255
8113ac1c:	00a045f4 	movhi	r2,33047
8113ac20:	10bb6404 	addi	r2,r2,-4720
8113ac24:	18c7883a 	add	r3,r3,r3
8113ac28:	18c7883a 	add	r3,r3,r3
8113ac2c:	10c5883a 	add	r2,r2,r3
8113ac30:	10800017 	ldw	r2,0(r2)
8113ac34:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
8113ac38:	d0a09c17 	ldw	r2,-32144(gp)
8113ac3c:	10c00e17 	ldw	r3,56(r2)
8113ac40:	18c00044 	addi	r3,r3,1
8113ac44:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
8113ac48:	d0a09617 	ldw	r2,-32168(gp)
8113ac4c:	10800044 	addi	r2,r2,1
8113ac50:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
8113ac54:	114cc8c0 	call	8114cc8c <OSCtxSw>
8113ac58:	e0bffd17 	ldw	r2,-12(fp)
8113ac5c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ac60:	e0bffe17 	ldw	r2,-8(fp)
8113ac64:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113ac68:	0001883a 	nop
8113ac6c:	e037883a 	mov	sp,fp
8113ac70:	dfc00117 	ldw	ra,4(sp)
8113ac74:	df000017 	ldw	fp,0(sp)
8113ac78:	dec00204 	addi	sp,sp,8
8113ac7c:	f800283a 	ret

8113ac80 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
8113ac80:	defffc04 	addi	sp,sp,-16
8113ac84:	de00012e 	bgeu	sp,et,8113ac8c <OSSchedLock+0xc>
8113ac88:	003b68fa 	trap	3
8113ac8c:	df000315 	stw	fp,12(sp)
8113ac90:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ac94:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
8113ac98:	d0a09103 	ldbu	r2,-32188(gp)
8113ac9c:	10803fcc 	andi	r2,r2,255
8113aca0:	10800058 	cmpnei	r2,r2,1
8113aca4:	1000161e 	bne	r2,zero,8113ad00 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aca8:	0005303a 	rdctl	r2,status
8113acac:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113acb0:	e0ffff17 	ldw	r3,-4(fp)
8113acb4:	00bfff84 	movi	r2,-2
8113acb8:	1884703a 	and	r2,r3,r2
8113acbc:	1001703a 	wrctl	status,r2
  
  return context;
8113acc0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113acc4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
8113acc8:	d0a0a103 	ldbu	r2,-32124(gp)
8113accc:	10803fcc 	andi	r2,r2,255
8113acd0:	1000071e 	bne	r2,zero,8113acf0 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
8113acd4:	d0a08f03 	ldbu	r2,-32196(gp)
8113acd8:	10803fcc 	andi	r2,r2,255
8113acdc:	10803fe0 	cmpeqi	r2,r2,255
8113ace0:	1000031e 	bne	r2,zero,8113acf0 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
8113ace4:	d0a08f03 	ldbu	r2,-32196(gp)
8113ace8:	10800044 	addi	r2,r2,1
8113acec:	d0a08f05 	stb	r2,-32196(gp)
8113acf0:	e0bffd17 	ldw	r2,-12(fp)
8113acf4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113acf8:	e0bffe17 	ldw	r2,-8(fp)
8113acfc:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113ad00:	0001883a 	nop
8113ad04:	e037883a 	mov	sp,fp
8113ad08:	df000017 	ldw	fp,0(sp)
8113ad0c:	dec00104 	addi	sp,sp,4
8113ad10:	f800283a 	ret

8113ad14 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
8113ad14:	defff804 	addi	sp,sp,-32
8113ad18:	de00012e 	bgeu	sp,et,8113ad20 <OSSchedUnlock+0xc>
8113ad1c:	003b68fa 	trap	3
8113ad20:	dfc00715 	stw	ra,28(sp)
8113ad24:	df000615 	stw	fp,24(sp)
8113ad28:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113ad2c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8113ad30:	d0a09103 	ldbu	r2,-32188(gp)
8113ad34:	10803fcc 	andi	r2,r2,255
8113ad38:	10800058 	cmpnei	r2,r2,1
8113ad3c:	1000281e 	bne	r2,zero,8113ade0 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ad40:	0005303a 	rdctl	r2,status
8113ad44:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ad48:	e0ffff17 	ldw	r3,-4(fp)
8113ad4c:	00bfff84 	movi	r2,-2
8113ad50:	1884703a 	and	r2,r3,r2
8113ad54:	1001703a 	wrctl	status,r2
  
  return context;
8113ad58:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113ad5c:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8113ad60:	d0a08f03 	ldbu	r2,-32196(gp)
8113ad64:	10803fcc 	andi	r2,r2,255
8113ad68:	10001926 	beq	r2,zero,8113add0 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8113ad6c:	d0a08f03 	ldbu	r2,-32196(gp)
8113ad70:	10bfffc4 	addi	r2,r2,-1
8113ad74:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8113ad78:	d0a08f03 	ldbu	r2,-32196(gp)
8113ad7c:	10803fcc 	andi	r2,r2,255
8113ad80:	10000e1e 	bne	r2,zero,8113adbc <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
8113ad84:	d0a0a103 	ldbu	r2,-32124(gp)
8113ad88:	10803fcc 	andi	r2,r2,255
8113ad8c:	1000061e 	bne	r2,zero,8113ada8 <OSSchedUnlock+0x94>
8113ad90:	e0bffa17 	ldw	r2,-24(fp)
8113ad94:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ad98:	e0bffb17 	ldw	r2,-20(fp)
8113ad9c:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8113ada0:	113bc5c0 	call	8113bc5c <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
8113ada4:	00000e06 	br	8113ade0 <OSSchedUnlock+0xcc>
8113ada8:	e0bffa17 	ldw	r2,-24(fp)
8113adac:	e0bffc15 	stw	r2,-16(fp)
8113adb0:	e0bffc17 	ldw	r2,-16(fp)
8113adb4:	1001703a 	wrctl	status,r2
8113adb8:	00000906 	br	8113ade0 <OSSchedUnlock+0xcc>
8113adbc:	e0bffa17 	ldw	r2,-24(fp)
8113adc0:	e0bffd15 	stw	r2,-12(fp)
8113adc4:	e0bffd17 	ldw	r2,-12(fp)
8113adc8:	1001703a 	wrctl	status,r2
8113adcc:	00000406 	br	8113ade0 <OSSchedUnlock+0xcc>
8113add0:	e0bffa17 	ldw	r2,-24(fp)
8113add4:	e0bffe15 	stw	r2,-8(fp)
8113add8:	e0bffe17 	ldw	r2,-8(fp)
8113addc:	1001703a 	wrctl	status,r2
8113ade0:	0001883a 	nop
8113ade4:	e037883a 	mov	sp,fp
8113ade8:	dfc00117 	ldw	ra,4(sp)
8113adec:	df000017 	ldw	fp,0(sp)
8113adf0:	dec00204 	addi	sp,sp,8
8113adf4:	f800283a 	ret

8113adf8 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
8113adf8:	defffe04 	addi	sp,sp,-8
8113adfc:	de00012e 	bgeu	sp,et,8113ae04 <OSStart+0xc>
8113ae00:	003b68fa 	trap	3
8113ae04:	dfc00115 	stw	ra,4(sp)
8113ae08:	df000015 	stw	fp,0(sp)
8113ae0c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8113ae10:	d0a09103 	ldbu	r2,-32188(gp)
8113ae14:	10803fcc 	andi	r2,r2,255
8113ae18:	10000f1e 	bne	r2,zero,8113ae58 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8113ae1c:	113bd340 	call	8113bd34 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8113ae20:	d0a09383 	ldbu	r2,-32178(gp)
8113ae24:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
8113ae28:	d0a09383 	ldbu	r2,-32178(gp)
8113ae2c:	10c03fcc 	andi	r3,r2,255
8113ae30:	00a045f4 	movhi	r2,33047
8113ae34:	10bb6404 	addi	r2,r2,-4720
8113ae38:	18c7883a 	add	r3,r3,r3
8113ae3c:	18c7883a 	add	r3,r3,r3
8113ae40:	10c5883a 	add	r2,r2,r3
8113ae44:	10800017 	ldw	r2,0(r2)
8113ae48:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
8113ae4c:	d0a09c17 	ldw	r2,-32144(gp)
8113ae50:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8113ae54:	114cd280 	call	8114cd28 <OSStartHighRdy>
    }
}
8113ae58:	0001883a 	nop
8113ae5c:	e037883a 	mov	sp,fp
8113ae60:	dfc00117 	ldw	ra,4(sp)
8113ae64:	df000017 	ldw	fp,0(sp)
8113ae68:	dec00204 	addi	sp,sp,8
8113ae6c:	f800283a 	ret

8113ae70 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8113ae70:	defff904 	addi	sp,sp,-28
8113ae74:	de00012e 	bgeu	sp,et,8113ae7c <OSStatInit+0xc>
8113ae78:	003b68fa 	trap	3
8113ae7c:	dfc00615 	stw	ra,24(sp)
8113ae80:	df000515 	stw	fp,20(sp)
8113ae84:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ae88:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8113ae8c:	01000084 	movi	r4,2
8113ae90:	11429980 	call	81142998 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ae94:	0005303a 	rdctl	r2,status
8113ae98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ae9c:	e0fffc17 	ldw	r3,-16(fp)
8113aea0:	00bfff84 	movi	r2,-2
8113aea4:	1884703a 	and	r2,r3,r2
8113aea8:	1001703a 	wrctl	status,r2
  
  return context;
8113aeac:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8113aeb0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8113aeb4:	d0209215 	stw	zero,-32184(gp)
8113aeb8:	e0bffb17 	ldw	r2,-20(fp)
8113aebc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aec0:	e0bffd17 	ldw	r2,-12(fp)
8113aec4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8113aec8:	01001904 	movi	r4,100
8113aecc:	11429980 	call	81142998 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aed0:	0005303a 	rdctl	r2,status
8113aed4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aed8:	e0fffe17 	ldw	r3,-8(fp)
8113aedc:	00bfff84 	movi	r2,-2
8113aee0:	1884703a 	and	r2,r3,r2
8113aee4:	1001703a 	wrctl	status,r2
  
  return context;
8113aee8:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8113aeec:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8113aef0:	d0a09217 	ldw	r2,-32184(gp)
8113aef4:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
8113aef8:	00800044 	movi	r2,1
8113aefc:	d0a0a705 	stb	r2,-32100(gp)
8113af00:	e0bffb17 	ldw	r2,-20(fp)
8113af04:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113af08:	e0bfff17 	ldw	r2,-4(fp)
8113af0c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113af10:	0001883a 	nop
8113af14:	e037883a 	mov	sp,fp
8113af18:	dfc00117 	ldw	ra,4(sp)
8113af1c:	df000017 	ldw	fp,0(sp)
8113af20:	dec00204 	addi	sp,sp,8
8113af24:	f800283a 	ret

8113af28 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
8113af28:	defff704 	addi	sp,sp,-36
8113af2c:	de00012e 	bgeu	sp,et,8113af34 <OSTimeTick+0xc>
8113af30:	003b68fa 	trap	3
8113af34:	dfc00815 	stw	ra,32(sp)
8113af38:	df000715 	stw	fp,28(sp)
8113af3c:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113af40:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8113af44:	114cf780 	call	8114cf78 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113af48:	0005303a 	rdctl	r2,status
8113af4c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113af50:	e0fffd17 	ldw	r3,-12(fp)
8113af54:	00bfff84 	movi	r2,-2
8113af58:	1884703a 	and	r2,r3,r2
8113af5c:	1001703a 	wrctl	status,r2
  
  return context;
8113af60:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8113af64:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8113af68:	d0a0a417 	ldw	r2,-32112(gp)
8113af6c:	10800044 	addi	r2,r2,1
8113af70:	d0a0a415 	stw	r2,-32112(gp)
8113af74:	e0bffb17 	ldw	r2,-20(fp)
8113af78:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113af7c:	e0bfff17 	ldw	r2,-4(fp)
8113af80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8113af84:	d0a09103 	ldbu	r2,-32188(gp)
8113af88:	10803fcc 	andi	r2,r2,255
8113af8c:	10800058 	cmpnei	r2,r2,1
8113af90:	10006a1e 	bne	r2,zero,8113b13c <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8113af94:	d0a09503 	ldbu	r2,-32172(gp)
8113af98:	10803fcc 	andi	r2,r2,255
8113af9c:	10c00060 	cmpeqi	r3,r2,1
8113afa0:	1800061e 	bne	r3,zero,8113afbc <OSTimeTick+0x94>
8113afa4:	10c000a0 	cmpeqi	r3,r2,2
8113afa8:	1800061e 	bne	r3,zero,8113afc4 <OSTimeTick+0x9c>
8113afac:	10000a1e 	bne	r2,zero,8113afd8 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8113afb0:	00800044 	movi	r2,1
8113afb4:	e0bffa05 	stb	r2,-24(fp)
                 break;
8113afb8:	00000b06 	br	8113afe8 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8113afbc:	e03ffa05 	stb	zero,-24(fp)
                 break;
8113afc0:	00000906 	br	8113afe8 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8113afc4:	00800044 	movi	r2,1
8113afc8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8113afcc:	00800044 	movi	r2,1
8113afd0:	d0a09505 	stb	r2,-32172(gp)
                 break;
8113afd4:	00000406 	br	8113afe8 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8113afd8:	00800044 	movi	r2,1
8113afdc:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8113afe0:	d0209505 	stb	zero,-32172(gp)
                 break;
8113afe4:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8113afe8:	e0bffa03 	ldbu	r2,-24(fp)
8113afec:	10005226 	beq	r2,zero,8113b138 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8113aff0:	d0a09417 	ldw	r2,-32176(gp)
8113aff4:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113aff8:	00004906 	br	8113b120 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113affc:	0005303a 	rdctl	r2,status
8113b000:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b004:	e0fffc17 	ldw	r3,-16(fp)
8113b008:	00bfff84 	movi	r2,-2
8113b00c:	1884703a 	and	r2,r3,r2
8113b010:	1001703a 	wrctl	status,r2
  
  return context;
8113b014:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
8113b018:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8113b01c:	e0bff917 	ldw	r2,-28(fp)
8113b020:	10800b8b 	ldhu	r2,46(r2)
8113b024:	10bfffcc 	andi	r2,r2,65535
8113b028:	10003626 	beq	r2,zero,8113b104 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8113b02c:	e0bff917 	ldw	r2,-28(fp)
8113b030:	10800b8b 	ldhu	r2,46(r2)
8113b034:	10bfffc4 	addi	r2,r2,-1
8113b038:	1007883a 	mov	r3,r2
8113b03c:	e0bff917 	ldw	r2,-28(fp)
8113b040:	10c00b8d 	sth	r3,46(r2)
8113b044:	e0bff917 	ldw	r2,-28(fp)
8113b048:	10800b8b 	ldhu	r2,46(r2)
8113b04c:	10bfffcc 	andi	r2,r2,65535
8113b050:	10002c1e 	bne	r2,zero,8113b104 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113b054:	e0bff917 	ldw	r2,-28(fp)
8113b058:	10800c03 	ldbu	r2,48(r2)
8113b05c:	10803fcc 	andi	r2,r2,255
8113b060:	10800dcc 	andi	r2,r2,55
8113b064:	10000b26 	beq	r2,zero,8113b094 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
8113b068:	e0bff917 	ldw	r2,-28(fp)
8113b06c:	10c00c03 	ldbu	r3,48(r2)
8113b070:	00bff204 	movi	r2,-56
8113b074:	1884703a 	and	r2,r3,r2
8113b078:	1007883a 	mov	r3,r2
8113b07c:	e0bff917 	ldw	r2,-28(fp)
8113b080:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8113b084:	e0bff917 	ldw	r2,-28(fp)
8113b088:	00c00044 	movi	r3,1
8113b08c:	10c00c45 	stb	r3,49(r2)
8113b090:	00000206 	br	8113b09c <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113b094:	e0bff917 	ldw	r2,-28(fp)
8113b098:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8113b09c:	e0bff917 	ldw	r2,-28(fp)
8113b0a0:	10800c03 	ldbu	r2,48(r2)
8113b0a4:	10803fcc 	andi	r2,r2,255
8113b0a8:	1080020c 	andi	r2,r2,8
8113b0ac:	1000151e 	bne	r2,zero,8113b104 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8113b0b0:	e0bff917 	ldw	r2,-28(fp)
8113b0b4:	10c00d83 	ldbu	r3,54(r2)
8113b0b8:	d0a09e03 	ldbu	r2,-32136(gp)
8113b0bc:	1884b03a 	or	r2,r3,r2
8113b0c0:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b0c4:	e0bff917 	ldw	r2,-28(fp)
8113b0c8:	10800d03 	ldbu	r2,52(r2)
8113b0cc:	10c03fcc 	andi	r3,r2,255
8113b0d0:	e0bff917 	ldw	r2,-28(fp)
8113b0d4:	10800d03 	ldbu	r2,52(r2)
8113b0d8:	11003fcc 	andi	r4,r2,255
8113b0dc:	d0a09e44 	addi	r2,gp,-32135
8113b0e0:	2085883a 	add	r2,r4,r2
8113b0e4:	11000003 	ldbu	r4,0(r2)
8113b0e8:	e0bff917 	ldw	r2,-28(fp)
8113b0ec:	10800d43 	ldbu	r2,53(r2)
8113b0f0:	2084b03a 	or	r2,r4,r2
8113b0f4:	1009883a 	mov	r4,r2
8113b0f8:	d0a09e44 	addi	r2,gp,-32135
8113b0fc:	1885883a 	add	r2,r3,r2
8113b100:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8113b104:	e0bff917 	ldw	r2,-28(fp)
8113b108:	10800517 	ldw	r2,20(r2)
8113b10c:	e0bff915 	stw	r2,-28(fp)
8113b110:	e0bffb17 	ldw	r2,-20(fp)
8113b114:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b118:	e0bffe17 	ldw	r2,-8(fp)
8113b11c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113b120:	e0bff917 	ldw	r2,-28(fp)
8113b124:	10800c83 	ldbu	r2,50(r2)
8113b128:	10803fcc 	andi	r2,r2,255
8113b12c:	10800a98 	cmpnei	r2,r2,42
8113b130:	103fb21e 	bne	r2,zero,8113affc <__reset+0xfb11affc>
8113b134:	00000106 	br	8113b13c <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8113b138:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8113b13c:	e037883a 	mov	sp,fp
8113b140:	dfc00117 	ldw	ra,4(sp)
8113b144:	df000017 	ldw	fp,0(sp)
8113b148:	dec00204 	addi	sp,sp,8
8113b14c:	f800283a 	ret

8113b150 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113b150:	deffff04 	addi	sp,sp,-4
8113b154:	de00012e 	bgeu	sp,et,8113b15c <OSVersion+0xc>
8113b158:	003b68fa 	trap	3
8113b15c:	df000015 	stw	fp,0(sp)
8113b160:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8113b164:	00804784 	movi	r2,286
}
8113b168:	e037883a 	mov	sp,fp
8113b16c:	df000017 	ldw	fp,0(sp)
8113b170:	dec00104 	addi	sp,sp,4
8113b174:	f800283a 	ret

8113b178 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8113b178:	deffff04 	addi	sp,sp,-4
8113b17c:	de00012e 	bgeu	sp,et,8113b184 <OS_Dummy+0xc>
8113b180:	003b68fa 	trap	3
8113b184:	df000015 	stw	fp,0(sp)
8113b188:	d839883a 	mov	fp,sp
}
8113b18c:	0001883a 	nop
8113b190:	e037883a 	mov	sp,fp
8113b194:	df000017 	ldw	fp,0(sp)
8113b198:	dec00104 	addi	sp,sp,4
8113b19c:	f800283a 	ret

8113b1a0 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8113b1a0:	defff804 	addi	sp,sp,-32
8113b1a4:	de00012e 	bgeu	sp,et,8113b1ac <OS_EventTaskRdy+0xc>
8113b1a8:	003b68fa 	trap	3
8113b1ac:	dfc00715 	stw	ra,28(sp)
8113b1b0:	df000615 	stw	fp,24(sp)
8113b1b4:	df000604 	addi	fp,sp,24
8113b1b8:	e13ffc15 	stw	r4,-16(fp)
8113b1bc:	e17ffd15 	stw	r5,-12(fp)
8113b1c0:	3007883a 	mov	r3,r6
8113b1c4:	3805883a 	mov	r2,r7
8113b1c8:	e0fffe05 	stb	r3,-8(fp)
8113b1cc:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8113b1d0:	e0bffc17 	ldw	r2,-16(fp)
8113b1d4:	10800283 	ldbu	r2,10(r2)
8113b1d8:	10c03fcc 	andi	r3,r2,255
8113b1dc:	00a04574 	movhi	r2,33045
8113b1e0:	108be704 	addi	r2,r2,12188
8113b1e4:	10c5883a 	add	r2,r2,r3
8113b1e8:	10800003 	ldbu	r2,0(r2)
8113b1ec:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8113b1f0:	e0bffa03 	ldbu	r2,-24(fp)
8113b1f4:	e0fffc17 	ldw	r3,-16(fp)
8113b1f8:	1885883a 	add	r2,r3,r2
8113b1fc:	108002c4 	addi	r2,r2,11
8113b200:	10800003 	ldbu	r2,0(r2)
8113b204:	10c03fcc 	andi	r3,r2,255
8113b208:	00a04574 	movhi	r2,33045
8113b20c:	108be704 	addi	r2,r2,12188
8113b210:	10c5883a 	add	r2,r2,r3
8113b214:	10800003 	ldbu	r2,0(r2)
8113b218:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8113b21c:	e0bffa03 	ldbu	r2,-24(fp)
8113b220:	100490fa 	slli	r2,r2,3
8113b224:	1007883a 	mov	r3,r2
8113b228:	e0bffa43 	ldbu	r2,-23(fp)
8113b22c:	1885883a 	add	r2,r3,r2
8113b230:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8113b234:	e0fffa83 	ldbu	r3,-22(fp)
8113b238:	00a045f4 	movhi	r2,33047
8113b23c:	10bb6404 	addi	r2,r2,-4720
8113b240:	18c7883a 	add	r3,r3,r3
8113b244:	18c7883a 	add	r3,r3,r3
8113b248:	10c5883a 	add	r2,r2,r3
8113b24c:	10800017 	ldw	r2,0(r2)
8113b250:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8113b254:	e0bffb17 	ldw	r2,-20(fp)
8113b258:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8113b25c:	e0bffb17 	ldw	r2,-20(fp)
8113b260:	e0fffd17 	ldw	r3,-12(fp)
8113b264:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8113b268:	e0bffb17 	ldw	r2,-20(fp)
8113b26c:	10800c03 	ldbu	r2,48(r2)
8113b270:	1007883a 	mov	r3,r2
8113b274:	e0bffe03 	ldbu	r2,-8(fp)
8113b278:	0084303a 	nor	r2,zero,r2
8113b27c:	1884703a 	and	r2,r3,r2
8113b280:	1007883a 	mov	r3,r2
8113b284:	e0bffb17 	ldw	r2,-20(fp)
8113b288:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8113b28c:	e0bffb17 	ldw	r2,-20(fp)
8113b290:	e0ffff03 	ldbu	r3,-4(fp)
8113b294:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8113b298:	e0bffb17 	ldw	r2,-20(fp)
8113b29c:	10800c03 	ldbu	r2,48(r2)
8113b2a0:	10803fcc 	andi	r2,r2,255
8113b2a4:	1080020c 	andi	r2,r2,8
8113b2a8:	1000111e 	bne	r2,zero,8113b2f0 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8113b2ac:	e0bffb17 	ldw	r2,-20(fp)
8113b2b0:	10c00d83 	ldbu	r3,54(r2)
8113b2b4:	d0a09e03 	ldbu	r2,-32136(gp)
8113b2b8:	1884b03a 	or	r2,r3,r2
8113b2bc:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8113b2c0:	e0fffa03 	ldbu	r3,-24(fp)
8113b2c4:	e13ffa03 	ldbu	r4,-24(fp)
8113b2c8:	d0a09e44 	addi	r2,gp,-32135
8113b2cc:	2085883a 	add	r2,r4,r2
8113b2d0:	11000003 	ldbu	r4,0(r2)
8113b2d4:	e0bffb17 	ldw	r2,-20(fp)
8113b2d8:	10800d43 	ldbu	r2,53(r2)
8113b2dc:	2084b03a 	or	r2,r4,r2
8113b2e0:	1009883a 	mov	r4,r2
8113b2e4:	d0a09e44 	addi	r2,gp,-32135
8113b2e8:	1885883a 	add	r2,r3,r2
8113b2ec:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8113b2f0:	e17ffc17 	ldw	r5,-16(fp)
8113b2f4:	e13ffb17 	ldw	r4,-20(fp)
8113b2f8:	113b5b00 	call	8113b5b0 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8113b2fc:	e0bffb17 	ldw	r2,-20(fp)
8113b300:	10800817 	ldw	r2,32(r2)
8113b304:	10000826 	beq	r2,zero,8113b328 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113b308:	e0bffb17 	ldw	r2,-20(fp)
8113b30c:	10800817 	ldw	r2,32(r2)
8113b310:	100b883a 	mov	r5,r2
8113b314:	e13ffb17 	ldw	r4,-20(fp)
8113b318:	113b6700 	call	8113b670 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8113b31c:	e0bffb17 	ldw	r2,-20(fp)
8113b320:	e0fffc17 	ldw	r3,-16(fp)
8113b324:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8113b328:	e0bffa83 	ldbu	r2,-22(fp)
}
8113b32c:	e037883a 	mov	sp,fp
8113b330:	dfc00117 	ldw	ra,4(sp)
8113b334:	df000017 	ldw	fp,0(sp)
8113b338:	dec00204 	addi	sp,sp,8
8113b33c:	f800283a 	ret

8113b340 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8113b340:	defffd04 	addi	sp,sp,-12
8113b344:	de00012e 	bgeu	sp,et,8113b34c <OS_EventTaskWait+0xc>
8113b348:	003b68fa 	trap	3
8113b34c:	df000215 	stw	fp,8(sp)
8113b350:	df000204 	addi	fp,sp,8
8113b354:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8113b358:	d0a0a217 	ldw	r2,-32120(gp)
8113b35c:	e0ffff17 	ldw	r3,-4(fp)
8113b360:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8113b364:	d0a0a217 	ldw	r2,-32120(gp)
8113b368:	10800d03 	ldbu	r2,52(r2)
8113b36c:	10803fcc 	andi	r2,r2,255
8113b370:	d0e0a217 	ldw	r3,-32120(gp)
8113b374:	18c00d03 	ldbu	r3,52(r3)
8113b378:	18c03fcc 	andi	r3,r3,255
8113b37c:	e13fff17 	ldw	r4,-4(fp)
8113b380:	20c7883a 	add	r3,r4,r3
8113b384:	18c002c4 	addi	r3,r3,11
8113b388:	19000003 	ldbu	r4,0(r3)
8113b38c:	d0e0a217 	ldw	r3,-32120(gp)
8113b390:	18c00d43 	ldbu	r3,53(r3)
8113b394:	20c6b03a 	or	r3,r4,r3
8113b398:	1809883a 	mov	r4,r3
8113b39c:	e0ffff17 	ldw	r3,-4(fp)
8113b3a0:	1885883a 	add	r2,r3,r2
8113b3a4:	108002c4 	addi	r2,r2,11
8113b3a8:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113b3ac:	e0bfff17 	ldw	r2,-4(fp)
8113b3b0:	10c00283 	ldbu	r3,10(r2)
8113b3b4:	d0a0a217 	ldw	r2,-32120(gp)
8113b3b8:	10800d83 	ldbu	r2,54(r2)
8113b3bc:	1884b03a 	or	r2,r3,r2
8113b3c0:	1007883a 	mov	r3,r2
8113b3c4:	e0bfff17 	ldw	r2,-4(fp)
8113b3c8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113b3cc:	d0a0a217 	ldw	r2,-32120(gp)
8113b3d0:	10800d03 	ldbu	r2,52(r2)
8113b3d4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113b3d8:	e0fffe03 	ldbu	r3,-8(fp)
8113b3dc:	e13ffe03 	ldbu	r4,-8(fp)
8113b3e0:	d0a09e44 	addi	r2,gp,-32135
8113b3e4:	2085883a 	add	r2,r4,r2
8113b3e8:	10800003 	ldbu	r2,0(r2)
8113b3ec:	1009883a 	mov	r4,r2
8113b3f0:	d0a0a217 	ldw	r2,-32120(gp)
8113b3f4:	10800d43 	ldbu	r2,53(r2)
8113b3f8:	0084303a 	nor	r2,zero,r2
8113b3fc:	2084703a 	and	r2,r4,r2
8113b400:	1009883a 	mov	r4,r2
8113b404:	d0a09e44 	addi	r2,gp,-32135
8113b408:	1885883a 	add	r2,r3,r2
8113b40c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113b410:	e0fffe03 	ldbu	r3,-8(fp)
8113b414:	d0a09e44 	addi	r2,gp,-32135
8113b418:	1885883a 	add	r2,r3,r2
8113b41c:	10800003 	ldbu	r2,0(r2)
8113b420:	10803fcc 	andi	r2,r2,255
8113b424:	1000071e 	bne	r2,zero,8113b444 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113b428:	d0a0a217 	ldw	r2,-32120(gp)
8113b42c:	10800d83 	ldbu	r2,54(r2)
8113b430:	0084303a 	nor	r2,zero,r2
8113b434:	1007883a 	mov	r3,r2
8113b438:	d0a09e03 	ldbu	r2,-32136(gp)
8113b43c:	1884703a 	and	r2,r3,r2
8113b440:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113b444:	0001883a 	nop
8113b448:	e037883a 	mov	sp,fp
8113b44c:	df000017 	ldw	fp,0(sp)
8113b450:	dec00104 	addi	sp,sp,4
8113b454:	f800283a 	ret

8113b458 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8113b458:	defffb04 	addi	sp,sp,-20
8113b45c:	de00012e 	bgeu	sp,et,8113b464 <OS_EventTaskWaitMulti+0xc>
8113b460:	003b68fa 	trap	3
8113b464:	df000415 	stw	fp,16(sp)
8113b468:	df000404 	addi	fp,sp,16
8113b46c:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8113b470:	d0a0a217 	ldw	r2,-32120(gp)
8113b474:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8113b478:	d0a0a217 	ldw	r2,-32120(gp)
8113b47c:	e0ffff17 	ldw	r3,-4(fp)
8113b480:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8113b484:	e0bfff17 	ldw	r2,-4(fp)
8113b488:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8113b48c:	e0bffc17 	ldw	r2,-16(fp)
8113b490:	10800017 	ldw	r2,0(r2)
8113b494:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113b498:	00002006 	br	8113b51c <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8113b49c:	d0a0a217 	ldw	r2,-32120(gp)
8113b4a0:	10800d03 	ldbu	r2,52(r2)
8113b4a4:	10803fcc 	andi	r2,r2,255
8113b4a8:	d0e0a217 	ldw	r3,-32120(gp)
8113b4ac:	18c00d03 	ldbu	r3,52(r3)
8113b4b0:	18c03fcc 	andi	r3,r3,255
8113b4b4:	e13ffd17 	ldw	r4,-12(fp)
8113b4b8:	20c7883a 	add	r3,r4,r3
8113b4bc:	18c002c4 	addi	r3,r3,11
8113b4c0:	19000003 	ldbu	r4,0(r3)
8113b4c4:	d0e0a217 	ldw	r3,-32120(gp)
8113b4c8:	18c00d43 	ldbu	r3,53(r3)
8113b4cc:	20c6b03a 	or	r3,r4,r3
8113b4d0:	1809883a 	mov	r4,r3
8113b4d4:	e0fffd17 	ldw	r3,-12(fp)
8113b4d8:	1885883a 	add	r2,r3,r2
8113b4dc:	108002c4 	addi	r2,r2,11
8113b4e0:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113b4e4:	e0bffd17 	ldw	r2,-12(fp)
8113b4e8:	10c00283 	ldbu	r3,10(r2)
8113b4ec:	d0a0a217 	ldw	r2,-32120(gp)
8113b4f0:	10800d83 	ldbu	r2,54(r2)
8113b4f4:	1884b03a 	or	r2,r3,r2
8113b4f8:	1007883a 	mov	r3,r2
8113b4fc:	e0bffd17 	ldw	r2,-12(fp)
8113b500:	10c00285 	stb	r3,10(r2)
        pevents++;
8113b504:	e0bffc17 	ldw	r2,-16(fp)
8113b508:	10800104 	addi	r2,r2,4
8113b50c:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113b510:	e0bffc17 	ldw	r2,-16(fp)
8113b514:	10800017 	ldw	r2,0(r2)
8113b518:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113b51c:	e0bffd17 	ldw	r2,-12(fp)
8113b520:	103fde1e 	bne	r2,zero,8113b49c <__reset+0xfb11b49c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113b524:	d0a0a217 	ldw	r2,-32120(gp)
8113b528:	10800d03 	ldbu	r2,52(r2)
8113b52c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113b530:	e0fffe03 	ldbu	r3,-8(fp)
8113b534:	e13ffe03 	ldbu	r4,-8(fp)
8113b538:	d0a09e44 	addi	r2,gp,-32135
8113b53c:	2085883a 	add	r2,r4,r2
8113b540:	10800003 	ldbu	r2,0(r2)
8113b544:	1009883a 	mov	r4,r2
8113b548:	d0a0a217 	ldw	r2,-32120(gp)
8113b54c:	10800d43 	ldbu	r2,53(r2)
8113b550:	0084303a 	nor	r2,zero,r2
8113b554:	2084703a 	and	r2,r4,r2
8113b558:	1009883a 	mov	r4,r2
8113b55c:	d0a09e44 	addi	r2,gp,-32135
8113b560:	1885883a 	add	r2,r3,r2
8113b564:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113b568:	e0fffe03 	ldbu	r3,-8(fp)
8113b56c:	d0a09e44 	addi	r2,gp,-32135
8113b570:	1885883a 	add	r2,r3,r2
8113b574:	10800003 	ldbu	r2,0(r2)
8113b578:	10803fcc 	andi	r2,r2,255
8113b57c:	1000071e 	bne	r2,zero,8113b59c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113b580:	d0a0a217 	ldw	r2,-32120(gp)
8113b584:	10800d83 	ldbu	r2,54(r2)
8113b588:	0084303a 	nor	r2,zero,r2
8113b58c:	1007883a 	mov	r3,r2
8113b590:	d0a09e03 	ldbu	r2,-32136(gp)
8113b594:	1884703a 	and	r2,r3,r2
8113b598:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113b59c:	0001883a 	nop
8113b5a0:	e037883a 	mov	sp,fp
8113b5a4:	df000017 	ldw	fp,0(sp)
8113b5a8:	dec00104 	addi	sp,sp,4
8113b5ac:	f800283a 	ret

8113b5b0 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8113b5b0:	defffc04 	addi	sp,sp,-16
8113b5b4:	de00012e 	bgeu	sp,et,8113b5bc <OS_EventTaskRemove+0xc>
8113b5b8:	003b68fa 	trap	3
8113b5bc:	df000315 	stw	fp,12(sp)
8113b5c0:	df000304 	addi	fp,sp,12
8113b5c4:	e13ffe15 	stw	r4,-8(fp)
8113b5c8:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8113b5cc:	e0bffe17 	ldw	r2,-8(fp)
8113b5d0:	10800d03 	ldbu	r2,52(r2)
8113b5d4:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8113b5d8:	e0bffd03 	ldbu	r2,-12(fp)
8113b5dc:	e0fffd03 	ldbu	r3,-12(fp)
8113b5e0:	e13fff17 	ldw	r4,-4(fp)
8113b5e4:	20c7883a 	add	r3,r4,r3
8113b5e8:	18c002c4 	addi	r3,r3,11
8113b5ec:	18c00003 	ldbu	r3,0(r3)
8113b5f0:	1809883a 	mov	r4,r3
8113b5f4:	e0fffe17 	ldw	r3,-8(fp)
8113b5f8:	18c00d43 	ldbu	r3,53(r3)
8113b5fc:	00c6303a 	nor	r3,zero,r3
8113b600:	20c6703a 	and	r3,r4,r3
8113b604:	1809883a 	mov	r4,r3
8113b608:	e0ffff17 	ldw	r3,-4(fp)
8113b60c:	1885883a 	add	r2,r3,r2
8113b610:	108002c4 	addi	r2,r2,11
8113b614:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8113b618:	e0bffd03 	ldbu	r2,-12(fp)
8113b61c:	e0ffff17 	ldw	r3,-4(fp)
8113b620:	1885883a 	add	r2,r3,r2
8113b624:	108002c4 	addi	r2,r2,11
8113b628:	10800003 	ldbu	r2,0(r2)
8113b62c:	10803fcc 	andi	r2,r2,255
8113b630:	10000a1e 	bne	r2,zero,8113b65c <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8113b634:	e0bfff17 	ldw	r2,-4(fp)
8113b638:	10800283 	ldbu	r2,10(r2)
8113b63c:	1007883a 	mov	r3,r2
8113b640:	e0bffe17 	ldw	r2,-8(fp)
8113b644:	10800d83 	ldbu	r2,54(r2)
8113b648:	0084303a 	nor	r2,zero,r2
8113b64c:	1884703a 	and	r2,r3,r2
8113b650:	1007883a 	mov	r3,r2
8113b654:	e0bfff17 	ldw	r2,-4(fp)
8113b658:	10c00285 	stb	r3,10(r2)
    }
}
8113b65c:	0001883a 	nop
8113b660:	e037883a 	mov	sp,fp
8113b664:	df000017 	ldw	fp,0(sp)
8113b668:	dec00104 	addi	sp,sp,4
8113b66c:	f800283a 	ret

8113b670 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8113b670:	defffa04 	addi	sp,sp,-24
8113b674:	de00012e 	bgeu	sp,et,8113b67c <OS_EventTaskRemoveMulti+0xc>
8113b678:	003b68fa 	trap	3
8113b67c:	df000515 	stw	fp,20(sp)
8113b680:	df000504 	addi	fp,sp,20
8113b684:	e13ffe15 	stw	r4,-8(fp)
8113b688:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8113b68c:	e0bffe17 	ldw	r2,-8(fp)
8113b690:	10800d03 	ldbu	r2,52(r2)
8113b694:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8113b698:	e0bffe17 	ldw	r2,-8(fp)
8113b69c:	10800d83 	ldbu	r2,54(r2)
8113b6a0:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8113b6a4:	e0bffe17 	ldw	r2,-8(fp)
8113b6a8:	10800d43 	ldbu	r2,53(r2)
8113b6ac:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8113b6b0:	e0bfff17 	ldw	r2,-4(fp)
8113b6b4:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8113b6b8:	e0bffb17 	ldw	r2,-20(fp)
8113b6bc:	10800017 	ldw	r2,0(r2)
8113b6c0:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113b6c4:	00002506 	br	8113b75c <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8113b6c8:	e0bffd03 	ldbu	r2,-12(fp)
8113b6cc:	e0fffd03 	ldbu	r3,-12(fp)
8113b6d0:	e13ffc17 	ldw	r4,-16(fp)
8113b6d4:	20c7883a 	add	r3,r4,r3
8113b6d8:	18c002c4 	addi	r3,r3,11
8113b6dc:	18c00003 	ldbu	r3,0(r3)
8113b6e0:	1809883a 	mov	r4,r3
8113b6e4:	e0fffd83 	ldbu	r3,-10(fp)
8113b6e8:	00c6303a 	nor	r3,zero,r3
8113b6ec:	20c6703a 	and	r3,r4,r3
8113b6f0:	1809883a 	mov	r4,r3
8113b6f4:	e0fffc17 	ldw	r3,-16(fp)
8113b6f8:	1885883a 	add	r2,r3,r2
8113b6fc:	108002c4 	addi	r2,r2,11
8113b700:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8113b704:	e0bffd03 	ldbu	r2,-12(fp)
8113b708:	e0fffc17 	ldw	r3,-16(fp)
8113b70c:	1885883a 	add	r2,r3,r2
8113b710:	108002c4 	addi	r2,r2,11
8113b714:	10800003 	ldbu	r2,0(r2)
8113b718:	10803fcc 	andi	r2,r2,255
8113b71c:	1000091e 	bne	r2,zero,8113b744 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113b720:	e0bffc17 	ldw	r2,-16(fp)
8113b724:	10800283 	ldbu	r2,10(r2)
8113b728:	1007883a 	mov	r3,r2
8113b72c:	e0bffd43 	ldbu	r2,-11(fp)
8113b730:	0084303a 	nor	r2,zero,r2
8113b734:	1884703a 	and	r2,r3,r2
8113b738:	1007883a 	mov	r3,r2
8113b73c:	e0bffc17 	ldw	r2,-16(fp)
8113b740:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8113b744:	e0bffb17 	ldw	r2,-20(fp)
8113b748:	10800104 	addi	r2,r2,4
8113b74c:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8113b750:	e0bffb17 	ldw	r2,-20(fp)
8113b754:	10800017 	ldw	r2,0(r2)
8113b758:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113b75c:	e0bffc17 	ldw	r2,-16(fp)
8113b760:	103fd91e 	bne	r2,zero,8113b6c8 <__reset+0xfb11b6c8>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8113b764:	0001883a 	nop
8113b768:	e037883a 	mov	sp,fp
8113b76c:	df000017 	ldw	fp,0(sp)
8113b770:	dec00104 	addi	sp,sp,4
8113b774:	f800283a 	ret

8113b778 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8113b778:	defffc04 	addi	sp,sp,-16
8113b77c:	de00012e 	bgeu	sp,et,8113b784 <OS_EventWaitListInit+0xc>
8113b780:	003b68fa 	trap	3
8113b784:	df000315 	stw	fp,12(sp)
8113b788:	df000304 	addi	fp,sp,12
8113b78c:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8113b790:	e0bfff17 	ldw	r2,-4(fp)
8113b794:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8113b798:	e0bfff17 	ldw	r2,-4(fp)
8113b79c:	108002c4 	addi	r2,r2,11
8113b7a0:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b7a4:	e03ffe05 	stb	zero,-8(fp)
8113b7a8:	00000706 	br	8113b7c8 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8113b7ac:	e0bffd17 	ldw	r2,-12(fp)
8113b7b0:	10c00044 	addi	r3,r2,1
8113b7b4:	e0fffd15 	stw	r3,-12(fp)
8113b7b8:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b7bc:	e0bffe03 	ldbu	r2,-8(fp)
8113b7c0:	10800044 	addi	r2,r2,1
8113b7c4:	e0bffe05 	stb	r2,-8(fp)
8113b7c8:	e0bffe03 	ldbu	r2,-8(fp)
8113b7cc:	108001b0 	cmpltui	r2,r2,6
8113b7d0:	103ff61e 	bne	r2,zero,8113b7ac <__reset+0xfb11b7ac>
        *ptbl++ = 0;
    }
}
8113b7d4:	0001883a 	nop
8113b7d8:	e037883a 	mov	sp,fp
8113b7dc:	df000017 	ldw	fp,0(sp)
8113b7e0:	dec00104 	addi	sp,sp,4
8113b7e4:	f800283a 	ret

8113b7e8 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8113b7e8:	defffb04 	addi	sp,sp,-20
8113b7ec:	de00012e 	bgeu	sp,et,8113b7f4 <OS_InitEventList+0xc>
8113b7f0:	003b68fa 	trap	3
8113b7f4:	dfc00415 	stw	ra,16(sp)
8113b7f8:	df000315 	stw	fp,12(sp)
8113b7fc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113b800:	01434004 	movi	r5,3328
8113b804:	012045f4 	movhi	r4,33047
8113b808:	2133b604 	addi	r4,r4,-12584
8113b80c:	113bb900 	call	8113bb90 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113b810:	00a045f4 	movhi	r2,33047
8113b814:	10b3b604 	addi	r2,r2,-12584
8113b818:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113b81c:	00a045f4 	movhi	r2,33047
8113b820:	10b3c304 	addi	r2,r2,-12532
8113b824:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113b828:	e03ffd0d 	sth	zero,-12(fp)
8113b82c:	00001306 	br	8113b87c <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113b830:	e0bffe17 	ldw	r2,-8(fp)
8113b834:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8113b838:	e0bffe17 	ldw	r2,-8(fp)
8113b83c:	e0ffff17 	ldw	r3,-4(fp)
8113b840:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8113b844:	e0bffe17 	ldw	r2,-8(fp)
8113b848:	00c00fc4 	movi	r3,63
8113b84c:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8113b850:	e0bffe17 	ldw	r2,-8(fp)
8113b854:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8113b858:	e0bffe17 	ldw	r2,-8(fp)
8113b85c:	10800d04 	addi	r2,r2,52
8113b860:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8113b864:	e0bfff17 	ldw	r2,-4(fp)
8113b868:	10800d04 	addi	r2,r2,52
8113b86c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113b870:	e0bffd0b 	ldhu	r2,-12(fp)
8113b874:	10800044 	addi	r2,r2,1
8113b878:	e0bffd0d 	sth	r2,-12(fp)
8113b87c:	e0bffd0b 	ldhu	r2,-12(fp)
8113b880:	10800ff0 	cmpltui	r2,r2,63
8113b884:	103fea1e 	bne	r2,zero,8113b830 <__reset+0xfb11b830>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8113b888:	e0bffe17 	ldw	r2,-8(fp)
8113b88c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8113b890:	e0bffe17 	ldw	r2,-8(fp)
8113b894:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8113b898:	e0bffe17 	ldw	r2,-8(fp)
8113b89c:	00c00fc4 	movi	r3,63
8113b8a0:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8113b8a4:	e0bffe17 	ldw	r2,-8(fp)
8113b8a8:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8113b8ac:	00a045f4 	movhi	r2,33047
8113b8b0:	10b3b604 	addi	r2,r2,-12584
8113b8b4:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8113b8b8:	0001883a 	nop
8113b8bc:	e037883a 	mov	sp,fp
8113b8c0:	dfc00117 	ldw	ra,4(sp)
8113b8c4:	df000017 	ldw	fp,0(sp)
8113b8c8:	dec00204 	addi	sp,sp,8
8113b8cc:	f800283a 	ret

8113b8d0 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8113b8d0:	deffff04 	addi	sp,sp,-4
8113b8d4:	de00012e 	bgeu	sp,et,8113b8dc <OS_InitMisc+0xc>
8113b8d8:	003b68fa 	trap	3
8113b8dc:	df000015 	stw	fp,0(sp)
8113b8e0:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8113b8e4:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8113b8e8:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113b8ec:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8113b8f0:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8113b8f4:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8113b8f8:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113b8fc:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113b900:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
8113b904:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8113b908:	d020a705 	stb	zero,-32100(gp)
#endif
}
8113b90c:	0001883a 	nop
8113b910:	e037883a 	mov	sp,fp
8113b914:	df000017 	ldw	fp,0(sp)
8113b918:	dec00104 	addi	sp,sp,4
8113b91c:	f800283a 	ret

8113b920 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113b920:	defffd04 	addi	sp,sp,-12
8113b924:	de00012e 	bgeu	sp,et,8113b92c <OS_InitRdyList+0xc>
8113b928:	003b68fa 	trap	3
8113b92c:	df000215 	stw	fp,8(sp)
8113b930:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8113b934:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
8113b938:	d0a09e44 	addi	r2,gp,-32135
8113b93c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113b940:	e03ffe05 	stb	zero,-8(fp)
8113b944:	00000706 	br	8113b964 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8113b948:	e0bfff17 	ldw	r2,-4(fp)
8113b94c:	10c00044 	addi	r3,r2,1
8113b950:	e0ffff15 	stw	r3,-4(fp)
8113b954:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113b958:	e0bffe03 	ldbu	r2,-8(fp)
8113b95c:	10800044 	addi	r2,r2,1
8113b960:	e0bffe05 	stb	r2,-8(fp)
8113b964:	e0bffe03 	ldbu	r2,-8(fp)
8113b968:	108001b0 	cmpltui	r2,r2,6
8113b96c:	103ff61e 	bne	r2,zero,8113b948 <__reset+0xfb11b948>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113b970:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
8113b974:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8113b978:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
8113b97c:	d020a215 	stw	zero,-32120(gp)
}
8113b980:	0001883a 	nop
8113b984:	e037883a 	mov	sp,fp
8113b988:	df000017 	ldw	fp,0(sp)
8113b98c:	dec00104 	addi	sp,sp,4
8113b990:	f800283a 	ret

8113b994 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8113b994:	defff804 	addi	sp,sp,-32
8113b998:	de00012e 	bgeu	sp,et,8113b9a0 <OS_InitTaskIdle+0xc>
8113b99c:	003b68fa 	trap	3
8113b9a0:	dfc00715 	stw	ra,28(sp)
8113b9a4:	df000615 	stw	fp,24(sp)
8113b9a8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8113b9ac:	008000c4 	movi	r2,3
8113b9b0:	d8800415 	stw	r2,16(sp)
8113b9b4:	d8000315 	stw	zero,12(sp)
8113b9b8:	00810004 	movi	r2,1024
8113b9bc:	d8800215 	stw	r2,8(sp)
8113b9c0:	00a045f4 	movhi	r2,33047
8113b9c4:	10afb604 	addi	r2,r2,-16680
8113b9c8:	d8800115 	stw	r2,4(sp)
8113b9cc:	00bfffd4 	movui	r2,65535
8113b9d0:	d8800015 	stw	r2,0(sp)
8113b9d4:	01c00a84 	movi	r7,42
8113b9d8:	01a045f4 	movhi	r6,33047
8113b9dc:	31b3b504 	addi	r6,r6,-12588
8113b9e0:	000b883a 	mov	r5,zero
8113b9e4:	01204534 	movhi	r4,33044
8113b9e8:	212fa204 	addi	r4,r4,-16760
8113b9ec:	11418780 	call	81141878 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8113b9f0:	e1bfff04 	addi	r6,fp,-4
8113b9f4:	01604574 	movhi	r5,33045
8113b9f8:	294c2704 	addi	r5,r5,12444
8113b9fc:	01000a84 	movi	r4,42
8113ba00:	11420a80 	call	811420a8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8113ba04:	0001883a 	nop
8113ba08:	e037883a 	mov	sp,fp
8113ba0c:	dfc00117 	ldw	ra,4(sp)
8113ba10:	df000017 	ldw	fp,0(sp)
8113ba14:	dec00204 	addi	sp,sp,8
8113ba18:	f800283a 	ret

8113ba1c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113ba1c:	defff804 	addi	sp,sp,-32
8113ba20:	de00012e 	bgeu	sp,et,8113ba28 <OS_InitTaskStat+0xc>
8113ba24:	003b68fa 	trap	3
8113ba28:	dfc00715 	stw	ra,28(sp)
8113ba2c:	df000615 	stw	fp,24(sp)
8113ba30:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8113ba34:	008000c4 	movi	r2,3
8113ba38:	d8800415 	stw	r2,16(sp)
8113ba3c:	d8000315 	stw	zero,12(sp)
8113ba40:	00810004 	movi	r2,1024
8113ba44:	d8800215 	stw	r2,8(sp)
8113ba48:	00a045f4 	movhi	r2,33047
8113ba4c:	10a8f604 	addi	r2,r2,-23592
8113ba50:	d8800115 	stw	r2,4(sp)
8113ba54:	00bfff94 	movui	r2,65534
8113ba58:	d8800015 	stw	r2,0(sp)
8113ba5c:	01c00a44 	movi	r7,41
8113ba60:	01a045f4 	movhi	r6,33047
8113ba64:	31acf504 	addi	r6,r6,-19500
8113ba68:	000b883a 	mov	r5,zero
8113ba6c:	01204534 	movhi	r4,33044
8113ba70:	212fbb04 	addi	r4,r4,-16660
8113ba74:	11418780 	call	81141878 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8113ba78:	e1bfff04 	addi	r6,fp,-4
8113ba7c:	01604574 	movhi	r5,33045
8113ba80:	294c2b04 	addi	r5,r5,12460
8113ba84:	01000a44 	movi	r4,41
8113ba88:	11420a80 	call	811420a8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8113ba8c:	0001883a 	nop
8113ba90:	e037883a 	mov	sp,fp
8113ba94:	dfc00117 	ldw	ra,4(sp)
8113ba98:	df000017 	ldw	fp,0(sp)
8113ba9c:	dec00204 	addi	sp,sp,8
8113baa0:	f800283a 	ret

8113baa4 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8113baa4:	defffb04 	addi	sp,sp,-20
8113baa8:	de00012e 	bgeu	sp,et,8113bab0 <OS_InitTCBList+0xc>
8113baac:	003b68fa 	trap	3
8113bab0:	dfc00415 	stw	ra,16(sp)
8113bab4:	df000315 	stw	fp,12(sp)
8113bab8:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8113babc:	01446e04 	movi	r5,4536
8113bac0:	012045f4 	movhi	r4,33047
8113bac4:	2136f604 	addi	r4,r4,-9256
8113bac8:	113bb900 	call	8113bb90 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8113bacc:	01402b04 	movi	r5,172
8113bad0:	012045f4 	movhi	r4,33047
8113bad4:	213b6404 	addi	r4,r4,-4720
8113bad8:	113bb900 	call	8113bb90 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8113badc:	00a045f4 	movhi	r2,33047
8113bae0:	10b6f604 	addi	r2,r2,-9256
8113bae4:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8113bae8:	00a045f4 	movhi	r2,33047
8113baec:	10b71104 	addi	r2,r2,-9148
8113baf0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113baf4:	e03ffd05 	stb	zero,-12(fp)
8113baf8:	00001106 	br	8113bb40 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8113bafc:	e0bffe17 	ldw	r2,-8(fp)
8113bb00:	e0ffff17 	ldw	r3,-4(fp)
8113bb04:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8113bb08:	e0bffe17 	ldw	r2,-8(fp)
8113bb0c:	00c00fc4 	movi	r3,63
8113bb10:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113bb14:	e0bffe17 	ldw	r2,-8(fp)
8113bb18:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8113bb1c:	e0bffe17 	ldw	r2,-8(fp)
8113bb20:	10801b04 	addi	r2,r2,108
8113bb24:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8113bb28:	e0bfff17 	ldw	r2,-4(fp)
8113bb2c:	10801b04 	addi	r2,r2,108
8113bb30:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113bb34:	e0bffd03 	ldbu	r2,-12(fp)
8113bb38:	10800044 	addi	r2,r2,1
8113bb3c:	e0bffd05 	stb	r2,-12(fp)
8113bb40:	e0bffd03 	ldbu	r2,-12(fp)
8113bb44:	10800a70 	cmpltui	r2,r2,41
8113bb48:	103fec1e 	bne	r2,zero,8113bafc <__reset+0xfb11bafc>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8113bb4c:	e0bffe17 	ldw	r2,-8(fp)
8113bb50:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8113bb54:	e0bffe17 	ldw	r2,-8(fp)
8113bb58:	00c00fc4 	movi	r3,63
8113bb5c:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113bb60:	e0bffe17 	ldw	r2,-8(fp)
8113bb64:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8113bb68:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8113bb6c:	00a045f4 	movhi	r2,33047
8113bb70:	10b6f604 	addi	r2,r2,-9256
8113bb74:	d0a09915 	stw	r2,-32156(gp)
}
8113bb78:	0001883a 	nop
8113bb7c:	e037883a 	mov	sp,fp
8113bb80:	dfc00117 	ldw	ra,4(sp)
8113bb84:	df000017 	ldw	fp,0(sp)
8113bb88:	dec00204 	addi	sp,sp,8
8113bb8c:	f800283a 	ret

8113bb90 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8113bb90:	defffd04 	addi	sp,sp,-12
8113bb94:	de00012e 	bgeu	sp,et,8113bb9c <OS_MemClr+0xc>
8113bb98:	003b68fa 	trap	3
8113bb9c:	df000215 	stw	fp,8(sp)
8113bba0:	df000204 	addi	fp,sp,8
8113bba4:	e13ffe15 	stw	r4,-8(fp)
8113bba8:	2805883a 	mov	r2,r5
8113bbac:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113bbb0:	00000706 	br	8113bbd0 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8113bbb4:	e0bffe17 	ldw	r2,-8(fp)
8113bbb8:	10c00044 	addi	r3,r2,1
8113bbbc:	e0fffe15 	stw	r3,-8(fp)
8113bbc0:	10000005 	stb	zero,0(r2)
        size--;
8113bbc4:	e0bfff0b 	ldhu	r2,-4(fp)
8113bbc8:	10bfffc4 	addi	r2,r2,-1
8113bbcc:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8113bbd0:	e0bfff0b 	ldhu	r2,-4(fp)
8113bbd4:	103ff71e 	bne	r2,zero,8113bbb4 <__reset+0xfb11bbb4>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8113bbd8:	0001883a 	nop
8113bbdc:	e037883a 	mov	sp,fp
8113bbe0:	df000017 	ldw	fp,0(sp)
8113bbe4:	dec00104 	addi	sp,sp,4
8113bbe8:	f800283a 	ret

8113bbec <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8113bbec:	defffc04 	addi	sp,sp,-16
8113bbf0:	de00012e 	bgeu	sp,et,8113bbf8 <OS_MemCopy+0xc>
8113bbf4:	003b68fa 	trap	3
8113bbf8:	df000315 	stw	fp,12(sp)
8113bbfc:	df000304 	addi	fp,sp,12
8113bc00:	e13ffd15 	stw	r4,-12(fp)
8113bc04:	e17ffe15 	stw	r5,-8(fp)
8113bc08:	3005883a 	mov	r2,r6
8113bc0c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113bc10:	00000b06 	br	8113bc40 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8113bc14:	e0bffd17 	ldw	r2,-12(fp)
8113bc18:	10c00044 	addi	r3,r2,1
8113bc1c:	e0fffd15 	stw	r3,-12(fp)
8113bc20:	e0fffe17 	ldw	r3,-8(fp)
8113bc24:	19000044 	addi	r4,r3,1
8113bc28:	e13ffe15 	stw	r4,-8(fp)
8113bc2c:	18c00003 	ldbu	r3,0(r3)
8113bc30:	10c00005 	stb	r3,0(r2)
        size--;
8113bc34:	e0bfff0b 	ldhu	r2,-4(fp)
8113bc38:	10bfffc4 	addi	r2,r2,-1
8113bc3c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8113bc40:	e0bfff0b 	ldhu	r2,-4(fp)
8113bc44:	103ff31e 	bne	r2,zero,8113bc14 <__reset+0xfb11bc14>
        *pdest++ = *psrc++;
        size--;
    }
}
8113bc48:	0001883a 	nop
8113bc4c:	e037883a 	mov	sp,fp
8113bc50:	df000017 	ldw	fp,0(sp)
8113bc54:	dec00104 	addi	sp,sp,4
8113bc58:	f800283a 	ret

8113bc5c <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8113bc5c:	defffb04 	addi	sp,sp,-20
8113bc60:	de00012e 	bgeu	sp,et,8113bc68 <OS_Sched+0xc>
8113bc64:	003b68fa 	trap	3
8113bc68:	dfc00415 	stw	ra,16(sp)
8113bc6c:	df000315 	stw	fp,12(sp)
8113bc70:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113bc74:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bc78:	0005303a 	rdctl	r2,status
8113bc7c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bc80:	e0ffff17 	ldw	r3,-4(fp)
8113bc84:	00bfff84 	movi	r2,-2
8113bc88:	1884703a 	and	r2,r3,r2
8113bc8c:	1001703a 	wrctl	status,r2
  
  return context;
8113bc90:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8113bc94:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8113bc98:	d0a0a103 	ldbu	r2,-32124(gp)
8113bc9c:	10803fcc 	andi	r2,r2,255
8113bca0:	10001a1e 	bne	r2,zero,8113bd0c <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8113bca4:	d0a08f03 	ldbu	r2,-32196(gp)
8113bca8:	10803fcc 	andi	r2,r2,255
8113bcac:	1000171e 	bne	r2,zero,8113bd0c <OS_Sched+0xb0>
            OS_SchedNew();
8113bcb0:	113bd340 	call	8113bd34 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8113bcb4:	d0e09383 	ldbu	r3,-32178(gp)
8113bcb8:	d0a093c3 	ldbu	r2,-32177(gp)
8113bcbc:	18c03fcc 	andi	r3,r3,255
8113bcc0:	10803fcc 	andi	r2,r2,255
8113bcc4:	18801126 	beq	r3,r2,8113bd0c <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8113bcc8:	d0a09383 	ldbu	r2,-32178(gp)
8113bccc:	10c03fcc 	andi	r3,r2,255
8113bcd0:	00a045f4 	movhi	r2,33047
8113bcd4:	10bb6404 	addi	r2,r2,-4720
8113bcd8:	18c7883a 	add	r3,r3,r3
8113bcdc:	18c7883a 	add	r3,r3,r3
8113bce0:	10c5883a 	add	r2,r2,r3
8113bce4:	10800017 	ldw	r2,0(r2)
8113bce8:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8113bcec:	d0a09c17 	ldw	r2,-32144(gp)
8113bcf0:	10c00e17 	ldw	r3,56(r2)
8113bcf4:	18c00044 	addi	r3,r3,1
8113bcf8:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8113bcfc:	d0a09617 	ldw	r2,-32168(gp)
8113bd00:	10800044 	addi	r2,r2,1
8113bd04:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8113bd08:	114cc8c0 	call	8114cc8c <OSCtxSw>
8113bd0c:	e0bffd17 	ldw	r2,-12(fp)
8113bd10:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd14:	e0bffe17 	ldw	r2,-8(fp)
8113bd18:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8113bd1c:	0001883a 	nop
8113bd20:	e037883a 	mov	sp,fp
8113bd24:	dfc00117 	ldw	ra,4(sp)
8113bd28:	df000017 	ldw	fp,0(sp)
8113bd2c:	dec00204 	addi	sp,sp,8
8113bd30:	f800283a 	ret

8113bd34 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8113bd34:	defffe04 	addi	sp,sp,-8
8113bd38:	de00012e 	bgeu	sp,et,8113bd40 <OS_SchedNew+0xc>
8113bd3c:	003b68fa 	trap	3
8113bd40:	df000115 	stw	fp,4(sp)
8113bd44:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8113bd48:	d0a09e03 	ldbu	r2,-32136(gp)
8113bd4c:	10c03fcc 	andi	r3,r2,255
8113bd50:	00a04574 	movhi	r2,33045
8113bd54:	108be704 	addi	r2,r2,12188
8113bd58:	10c5883a 	add	r2,r2,r3
8113bd5c:	10800003 	ldbu	r2,0(r2)
8113bd60:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8113bd64:	e0bfff03 	ldbu	r2,-4(fp)
8113bd68:	100490fa 	slli	r2,r2,3
8113bd6c:	1009883a 	mov	r4,r2
8113bd70:	e0ffff03 	ldbu	r3,-4(fp)
8113bd74:	d0a09e44 	addi	r2,gp,-32135
8113bd78:	1885883a 	add	r2,r3,r2
8113bd7c:	10800003 	ldbu	r2,0(r2)
8113bd80:	10c03fcc 	andi	r3,r2,255
8113bd84:	00a04574 	movhi	r2,33045
8113bd88:	108be704 	addi	r2,r2,12188
8113bd8c:	10c5883a 	add	r2,r2,r3
8113bd90:	10800003 	ldbu	r2,0(r2)
8113bd94:	2085883a 	add	r2,r4,r2
8113bd98:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8113bd9c:	0001883a 	nop
8113bda0:	e037883a 	mov	sp,fp
8113bda4:	df000017 	ldw	fp,0(sp)
8113bda8:	dec00104 	addi	sp,sp,4
8113bdac:	f800283a 	ret

8113bdb0 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8113bdb0:	defffc04 	addi	sp,sp,-16
8113bdb4:	de00012e 	bgeu	sp,et,8113bdbc <OS_StrCopy+0xc>
8113bdb8:	003b68fa 	trap	3
8113bdbc:	df000315 	stw	fp,12(sp)
8113bdc0:	df000304 	addi	fp,sp,12
8113bdc4:	e13ffe15 	stw	r4,-8(fp)
8113bdc8:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8113bdcc:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8113bdd0:	00000b06 	br	8113be00 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8113bdd4:	e0bffe17 	ldw	r2,-8(fp)
8113bdd8:	10c00044 	addi	r3,r2,1
8113bddc:	e0fffe15 	stw	r3,-8(fp)
8113bde0:	e0ffff17 	ldw	r3,-4(fp)
8113bde4:	19000044 	addi	r4,r3,1
8113bde8:	e13fff15 	stw	r4,-4(fp)
8113bdec:	18c00003 	ldbu	r3,0(r3)
8113bdf0:	10c00005 	stb	r3,0(r2)
        len++;
8113bdf4:	e0bffd03 	ldbu	r2,-12(fp)
8113bdf8:	10800044 	addi	r2,r2,1
8113bdfc:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113be00:	e0bfff17 	ldw	r2,-4(fp)
8113be04:	10800003 	ldbu	r2,0(r2)
8113be08:	10803fcc 	andi	r2,r2,255
8113be0c:	103ff11e 	bne	r2,zero,8113bdd4 <__reset+0xfb11bdd4>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8113be10:	e0bffe17 	ldw	r2,-8(fp)
8113be14:	10000005 	stb	zero,0(r2)
    return (len);
8113be18:	e0bffd03 	ldbu	r2,-12(fp)
}
8113be1c:	e037883a 	mov	sp,fp
8113be20:	df000017 	ldw	fp,0(sp)
8113be24:	dec00104 	addi	sp,sp,4
8113be28:	f800283a 	ret

8113be2c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8113be2c:	defffd04 	addi	sp,sp,-12
8113be30:	de00012e 	bgeu	sp,et,8113be38 <OS_StrLen+0xc>
8113be34:	003b68fa 	trap	3
8113be38:	df000215 	stw	fp,8(sp)
8113be3c:	df000204 	addi	fp,sp,8
8113be40:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8113be44:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
8113be48:	00000606 	br	8113be64 <OS_StrLen+0x38>
        psrc++;
8113be4c:	e0bfff17 	ldw	r2,-4(fp)
8113be50:	10800044 	addi	r2,r2,1
8113be54:	e0bfff15 	stw	r2,-4(fp)
        len++;
8113be58:	e0bffe03 	ldbu	r2,-8(fp)
8113be5c:	10800044 	addi	r2,r2,1
8113be60:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113be64:	e0bfff17 	ldw	r2,-4(fp)
8113be68:	10800003 	ldbu	r2,0(r2)
8113be6c:	10803fcc 	andi	r2,r2,255
8113be70:	103ff61e 	bne	r2,zero,8113be4c <__reset+0xfb11be4c>
        psrc++;
        len++;
    }
    return (len);
8113be74:	e0bffe03 	ldbu	r2,-8(fp)
}
8113be78:	e037883a 	mov	sp,fp
8113be7c:	df000017 	ldw	fp,0(sp)
8113be80:	dec00104 	addi	sp,sp,4
8113be84:	f800283a 	ret

8113be88 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8113be88:	defffa04 	addi	sp,sp,-24
8113be8c:	de00012e 	bgeu	sp,et,8113be94 <OS_TaskIdle+0xc>
8113be90:	003b68fa 	trap	3
8113be94:	dfc00515 	stw	ra,20(sp)
8113be98:	df000415 	stw	fp,16(sp)
8113be9c:	df000404 	addi	fp,sp,16
8113bea0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bea4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bea8:	0005303a 	rdctl	r2,status
8113beac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113beb0:	e0fffd17 	ldw	r3,-12(fp)
8113beb4:	00bfff84 	movi	r2,-2
8113beb8:	1884703a 	and	r2,r3,r2
8113bebc:	1001703a 	wrctl	status,r2
  
  return context;
8113bec0:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8113bec4:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8113bec8:	d0a09217 	ldw	r2,-32184(gp)
8113becc:	10800044 	addi	r2,r2,1
8113bed0:	d0a09215 	stw	r2,-32184(gp)
8113bed4:	e0bffc17 	ldw	r2,-16(fp)
8113bed8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bedc:	e0bffe17 	ldw	r2,-8(fp)
8113bee0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
8113bee4:	114d0200 	call	8114d020 <OSTaskIdleHook>
    }
8113bee8:	003fef06 	br	8113bea8 <__reset+0xfb11bea8>

8113beec <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8113beec:	defff804 	addi	sp,sp,-32
8113bef0:	de00012e 	bgeu	sp,et,8113bef8 <OS_TaskStat+0xc>
8113bef4:	003b68fa 	trap	3
8113bef8:	dfc00715 	stw	ra,28(sp)
8113befc:	df000615 	stw	fp,24(sp)
8113bf00:	dc400515 	stw	r17,20(sp)
8113bf04:	dc000415 	stw	r16,16(sp)
8113bf08:	df000604 	addi	fp,sp,24
8113bf0c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bf10:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113bf14:	00000206 	br	8113bf20 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
8113bf18:	01003204 	movi	r4,200
8113bf1c:	11429980 	call	81142998 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113bf20:	d0a0a703 	ldbu	r2,-32100(gp)
8113bf24:	10803fcc 	andi	r2,r2,255
8113bf28:	103ffb26 	beq	r2,zero,8113bf18 <__reset+0xfb11bf18>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8113bf2c:	d0e09817 	ldw	r3,-32160(gp)
8113bf30:	00947b34 	movhi	r2,20972
8113bf34:	10a147c4 	addi	r2,r2,-31457
8113bf38:	1888383a 	mulxuu	r4,r3,r2
8113bf3c:	1885383a 	mul	r2,r3,r2
8113bf40:	1021883a 	mov	r16,r2
8113bf44:	2023883a 	mov	r17,r4
8113bf48:	8804d17a 	srli	r2,r17,5
8113bf4c:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
8113bf50:	d0a09817 	ldw	r2,-32160(gp)
8113bf54:	1000031e 	bne	r2,zero,8113bf64 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8113bf58:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8113bf5c:	01003fc4 	movi	r4,255
8113bf60:	11426080 	call	81142608 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf64:	0005303a 	rdctl	r2,status
8113bf68:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf6c:	e0fffb17 	ldw	r3,-20(fp)
8113bf70:	00bfff84 	movi	r2,-2
8113bf74:	1884703a 	and	r2,r3,r2
8113bf78:	1001703a 	wrctl	status,r2
  
  return context;
8113bf7c:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8113bf80:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8113bf84:	d0a09217 	ldw	r2,-32184(gp)
8113bf88:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8113bf8c:	d0209215 	stw	zero,-32184(gp)
8113bf90:	e0bffa17 	ldw	r2,-24(fp)
8113bf94:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bf98:	e0bffc17 	ldw	r2,-16(fp)
8113bf9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113bfa0:	d0e0a817 	ldw	r3,-32096(gp)
8113bfa4:	d0a09817 	ldw	r2,-32160(gp)
8113bfa8:	1885203a 	divu	r2,r3,r2
8113bfac:	1007883a 	mov	r3,r2
8113bfb0:	00801904 	movi	r2,100
8113bfb4:	10c5c83a 	sub	r2,r2,r3
8113bfb8:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8113bfbc:	114cf500 	call	8114cf50 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8113bfc0:	113bfd00 	call	8113bfd0 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8113bfc4:	01001904 	movi	r4,100
8113bfc8:	11429980 	call	81142998 <OSTimeDly>
    }
8113bfcc:	003fe506 	br	8113bf64 <__reset+0xfb11bf64>

8113bfd0 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8113bfd0:	defffa04 	addi	sp,sp,-24
8113bfd4:	de00012e 	bgeu	sp,et,8113bfdc <OS_TaskStatStkChk+0xc>
8113bfd8:	003b68fa 	trap	3
8113bfdc:	dfc00515 	stw	ra,20(sp)
8113bfe0:	df000415 	stw	fp,16(sp)
8113bfe4:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113bfe8:	e03ffc05 	stb	zero,-16(fp)
8113bfec:	00002406 	br	8113c080 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8113bff0:	e0bffc03 	ldbu	r2,-16(fp)
8113bff4:	e0fffe04 	addi	r3,fp,-8
8113bff8:	180b883a 	mov	r5,r3
8113bffc:	1009883a 	mov	r4,r2
8113c000:	11424400 	call	81142440 <OSTaskStkChk>
8113c004:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8113c008:	e0bffc43 	ldbu	r2,-15(fp)
8113c00c:	1000191e 	bne	r2,zero,8113c074 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113c010:	e0fffc03 	ldbu	r3,-16(fp)
8113c014:	00a045f4 	movhi	r2,33047
8113c018:	10bb6404 	addi	r2,r2,-4720
8113c01c:	18c7883a 	add	r3,r3,r3
8113c020:	18c7883a 	add	r3,r3,r3
8113c024:	10c5883a 	add	r2,r2,r3
8113c028:	10800017 	ldw	r2,0(r2)
8113c02c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113c030:	e0bffd17 	ldw	r2,-12(fp)
8113c034:	10000f26 	beq	r2,zero,8113c074 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8113c038:	e0bffd17 	ldw	r2,-12(fp)
8113c03c:	10800060 	cmpeqi	r2,r2,1
8113c040:	10000c1e 	bne	r2,zero,8113c074 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113c044:	e0bffd17 	ldw	r2,-12(fp)
8113c048:	10c00217 	ldw	r3,8(r2)
8113c04c:	e0bffd17 	ldw	r2,-12(fp)
8113c050:	10800317 	ldw	r2,12(r2)
8113c054:	1085883a 	add	r2,r2,r2
8113c058:	1085883a 	add	r2,r2,r2
8113c05c:	1887883a 	add	r3,r3,r2
8113c060:	e0bffd17 	ldw	r2,-12(fp)
8113c064:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8113c068:	e0ffff17 	ldw	r3,-4(fp)
8113c06c:	e0bffd17 	ldw	r2,-12(fp)
8113c070:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113c074:	e0bffc03 	ldbu	r2,-16(fp)
8113c078:	10800044 	addi	r2,r2,1
8113c07c:	e0bffc05 	stb	r2,-16(fp)
8113c080:	e0bffc03 	ldbu	r2,-16(fp)
8113c084:	10800af0 	cmpltui	r2,r2,43
8113c088:	103fd91e 	bne	r2,zero,8113bff0 <__reset+0xfb11bff0>
#endif
                }
            }
        }
    }
}
8113c08c:	0001883a 	nop
8113c090:	e037883a 	mov	sp,fp
8113c094:	dfc00117 	ldw	ra,4(sp)
8113c098:	df000017 	ldw	fp,0(sp)
8113c09c:	dec00204 	addi	sp,sp,8
8113c0a0:	f800283a 	ret

8113c0a4 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113c0a4:	defff204 	addi	sp,sp,-56
8113c0a8:	de00012e 	bgeu	sp,et,8113c0b0 <OS_TCBInit+0xc>
8113c0ac:	003b68fa 	trap	3
8113c0b0:	dfc00d15 	stw	ra,52(sp)
8113c0b4:	df000c15 	stw	fp,48(sp)
8113c0b8:	df000c04 	addi	fp,sp,48
8113c0bc:	e17ffc15 	stw	r5,-16(fp)
8113c0c0:	e1bffd15 	stw	r6,-12(fp)
8113c0c4:	3807883a 	mov	r3,r7
8113c0c8:	e0800417 	ldw	r2,16(fp)
8113c0cc:	e13ffb05 	stb	r4,-20(fp)
8113c0d0:	e0fffe0d 	sth	r3,-8(fp)
8113c0d4:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c0d8:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c0dc:	0005303a 	rdctl	r2,status
8113c0e0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c0e4:	e0fffa17 	ldw	r3,-24(fp)
8113c0e8:	00bfff84 	movi	r2,-2
8113c0ec:	1884703a 	and	r2,r3,r2
8113c0f0:	1001703a 	wrctl	status,r2
  
  return context;
8113c0f4:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8113c0f8:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8113c0fc:	d0a09917 	ldw	r2,-32156(gp)
8113c100:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8113c104:	e0bff617 	ldw	r2,-40(fp)
8113c108:	10009326 	beq	r2,zero,8113c358 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8113c10c:	e0bff617 	ldw	r2,-40(fp)
8113c110:	10800517 	ldw	r2,20(r2)
8113c114:	d0a09915 	stw	r2,-32156(gp)
8113c118:	e0bff417 	ldw	r2,-48(fp)
8113c11c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c120:	e0bff817 	ldw	r2,-32(fp)
8113c124:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8113c128:	e0bff617 	ldw	r2,-40(fp)
8113c12c:	e0fffc17 	ldw	r3,-16(fp)
8113c130:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8113c134:	e0bff617 	ldw	r2,-40(fp)
8113c138:	e0fffb03 	ldbu	r3,-20(fp)
8113c13c:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113c140:	e0bff617 	ldw	r2,-40(fp)
8113c144:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8113c148:	e0bff617 	ldw	r2,-40(fp)
8113c14c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113c150:	e0bff617 	ldw	r2,-40(fp)
8113c154:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8113c158:	e0bff617 	ldw	r2,-40(fp)
8113c15c:	e0c00317 	ldw	r3,12(fp)
8113c160:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113c164:	e0bff617 	ldw	r2,-40(fp)
8113c168:	e0c00217 	ldw	r3,8(fp)
8113c16c:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113c170:	e0bff617 	ldw	r2,-40(fp)
8113c174:	e0fffd17 	ldw	r3,-12(fp)
8113c178:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8113c17c:	e0bff617 	ldw	r2,-40(fp)
8113c180:	e0ffff0b 	ldhu	r3,-4(fp)
8113c184:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8113c188:	e0bff617 	ldw	r2,-40(fp)
8113c18c:	e0fffe0b 	ldhu	r3,-8(fp)
8113c190:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113c194:	e0bff617 	ldw	r2,-40(fp)
8113c198:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8113c19c:	e0bffb03 	ldbu	r2,-20(fp)
8113c1a0:	1004d0fa 	srli	r2,r2,3
8113c1a4:	1007883a 	mov	r3,r2
8113c1a8:	e0bff617 	ldw	r2,-40(fp)
8113c1ac:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113c1b0:	e0bffb03 	ldbu	r2,-20(fp)
8113c1b4:	108001cc 	andi	r2,r2,7
8113c1b8:	1007883a 	mov	r3,r2
8113c1bc:	e0bff617 	ldw	r2,-40(fp)
8113c1c0:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8113c1c4:	e0bff617 	ldw	r2,-40(fp)
8113c1c8:	10800d03 	ldbu	r2,52(r2)
8113c1cc:	10803fcc 	andi	r2,r2,255
8113c1d0:	00c00044 	movi	r3,1
8113c1d4:	1884983a 	sll	r2,r3,r2
8113c1d8:	1007883a 	mov	r3,r2
8113c1dc:	e0bff617 	ldw	r2,-40(fp)
8113c1e0:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8113c1e4:	e0bff617 	ldw	r2,-40(fp)
8113c1e8:	10800cc3 	ldbu	r2,51(r2)
8113c1ec:	10803fcc 	andi	r2,r2,255
8113c1f0:	00c00044 	movi	r3,1
8113c1f4:	1884983a 	sll	r2,r3,r2
8113c1f8:	1007883a 	mov	r3,r2
8113c1fc:	e0bff617 	ldw	r2,-40(fp)
8113c200:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8113c204:	e0bff617 	ldw	r2,-40(fp)
8113c208:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8113c20c:	e0bff617 	ldw	r2,-40(fp)
8113c210:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8113c214:	e0bff617 	ldw	r2,-40(fp)
8113c218:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8113c21c:	e0bff617 	ldw	r2,-40(fp)
8113c220:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8113c224:	e0bff617 	ldw	r2,-40(fp)
8113c228:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8113c22c:	e0bff617 	ldw	r2,-40(fp)
8113c230:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8113c234:	e0bff617 	ldw	r2,-40(fp)
8113c238:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8113c23c:	e0bff617 	ldw	r2,-40(fp)
8113c240:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113c244:	e0bff617 	ldw	r2,-40(fp)
8113c248:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8113c24c:	e0bff617 	ldw	r2,-40(fp)
8113c250:	00c00fc4 	movi	r3,63
8113c254:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113c258:	e0bff617 	ldw	r2,-40(fp)
8113c25c:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113c260:	e13ff617 	ldw	r4,-40(fp)
8113c264:	114d0480 	call	8114d048 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8113c268:	e13ff617 	ldw	r4,-40(fp)
8113c26c:	114ced00 	call	8114ced0 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c270:	0005303a 	rdctl	r2,status
8113c274:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c278:	e0fff517 	ldw	r3,-44(fp)
8113c27c:	00bfff84 	movi	r2,-2
8113c280:	1884703a 	and	r2,r3,r2
8113c284:	1001703a 	wrctl	status,r2
  
  return context;
8113c288:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8113c28c:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113c290:	e0fffb03 	ldbu	r3,-20(fp)
8113c294:	00a045f4 	movhi	r2,33047
8113c298:	10bb6404 	addi	r2,r2,-4720
8113c29c:	18c7883a 	add	r3,r3,r3
8113c2a0:	18c7883a 	add	r3,r3,r3
8113c2a4:	10c5883a 	add	r2,r2,r3
8113c2a8:	e0fff617 	ldw	r3,-40(fp)
8113c2ac:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113c2b0:	d0e09417 	ldw	r3,-32176(gp)
8113c2b4:	e0bff617 	ldw	r2,-40(fp)
8113c2b8:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8113c2bc:	e0bff617 	ldw	r2,-40(fp)
8113c2c0:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113c2c4:	d0a09417 	ldw	r2,-32176(gp)
8113c2c8:	10000326 	beq	r2,zero,8113c2d8 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8113c2cc:	d0a09417 	ldw	r2,-32176(gp)
8113c2d0:	e0fff617 	ldw	r3,-40(fp)
8113c2d4:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8113c2d8:	e0bff617 	ldw	r2,-40(fp)
8113c2dc:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113c2e0:	e0bff617 	ldw	r2,-40(fp)
8113c2e4:	10c00d83 	ldbu	r3,54(r2)
8113c2e8:	d0a09e03 	ldbu	r2,-32136(gp)
8113c2ec:	1884b03a 	or	r2,r3,r2
8113c2f0:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c2f4:	e0bff617 	ldw	r2,-40(fp)
8113c2f8:	10800d03 	ldbu	r2,52(r2)
8113c2fc:	10c03fcc 	andi	r3,r2,255
8113c300:	e0bff617 	ldw	r2,-40(fp)
8113c304:	10800d03 	ldbu	r2,52(r2)
8113c308:	11003fcc 	andi	r4,r2,255
8113c30c:	d0a09e44 	addi	r2,gp,-32135
8113c310:	2085883a 	add	r2,r4,r2
8113c314:	11000003 	ldbu	r4,0(r2)
8113c318:	e0bff617 	ldw	r2,-40(fp)
8113c31c:	10800d43 	ldbu	r2,53(r2)
8113c320:	2084b03a 	or	r2,r4,r2
8113c324:	1009883a 	mov	r4,r2
8113c328:	d0a09e44 	addi	r2,gp,-32135
8113c32c:	1885883a 	add	r2,r3,r2
8113c330:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113c334:	d0a09a43 	ldbu	r2,-32151(gp)
8113c338:	10800044 	addi	r2,r2,1
8113c33c:	d0a09a45 	stb	r2,-32151(gp)
8113c340:	e0bff417 	ldw	r2,-48(fp)
8113c344:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c348:	e0bff717 	ldw	r2,-36(fp)
8113c34c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113c350:	0005883a 	mov	r2,zero
8113c354:	00000506 	br	8113c36c <OS_TCBInit+0x2c8>
8113c358:	e0bff417 	ldw	r2,-48(fp)
8113c35c:	e0bff915 	stw	r2,-28(fp)
8113c360:	e0bff917 	ldw	r2,-28(fp)
8113c364:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8113c368:	00801084 	movi	r2,66
}
8113c36c:	e037883a 	mov	sp,fp
8113c370:	dfc00117 	ldw	ra,4(sp)
8113c374:	df000017 	ldw	fp,0(sp)
8113c378:	dec00204 	addi	sp,sp,8
8113c37c:	f800283a 	ret

8113c380 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113c380:	defffe04 	addi	sp,sp,-8
8113c384:	de00012e 	bgeu	sp,et,8113c38c <OSDebugInit+0xc>
8113c388:	003b68fa 	trap	3
8113c38c:	df000115 	stw	fp,4(sp)
8113c390:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113c394:	d0a01804 	addi	r2,gp,-32672
8113c398:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8113c39c:	d0a01904 	addi	r2,gp,-32668
8113c3a0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113c3a4:	d0a01a84 	addi	r2,gp,-32662
8113c3a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8113c3ac:	d0a01b04 	addi	r2,gp,-32660
8113c3b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113c3b4:	d0a01a04 	addi	r2,gp,-32664
8113c3b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8113c3bc:	d0a01b84 	addi	r2,gp,-32658
8113c3c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113c3c4:	d0a01c04 	addi	r2,gp,-32656
8113c3c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8113c3cc:	d0a01c84 	addi	r2,gp,-32654
8113c3d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113c3d4:	d0a01d04 	addi	r2,gp,-32652
8113c3d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113c3dc:	d0a01d84 	addi	r2,gp,-32650
8113c3e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8113c3e4:	d0a01e04 	addi	r2,gp,-32648
8113c3e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113c3ec:	d0a01e84 	addi	r2,gp,-32646
8113c3f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8113c3f4:	d0a01f04 	addi	r2,gp,-32644
8113c3f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113c3fc:	d0a01f84 	addi	r2,gp,-32642
8113c400:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8113c404:	d0a02004 	addi	r2,gp,-32640
8113c408:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113c40c:	d0a02084 	addi	r2,gp,-32638
8113c410:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8113c414:	d0a02104 	addi	r2,gp,-32636
8113c418:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113c41c:	d0a02184 	addi	r2,gp,-32634
8113c420:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113c424:	d0a02204 	addi	r2,gp,-32632
8113c428:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113c42c:	d0a02284 	addi	r2,gp,-32630
8113c430:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113c434:	d0a02304 	addi	r2,gp,-32628
8113c438:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113c43c:	d0a02384 	addi	r2,gp,-32626
8113c440:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113c444:	d0a02404 	addi	r2,gp,-32624
8113c448:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113c44c:	d0a02484 	addi	r2,gp,-32622
8113c450:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113c454:	d0a02504 	addi	r2,gp,-32620
8113c458:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113c45c:	d0a02584 	addi	r2,gp,-32618
8113c460:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113c464:	d0a02604 	addi	r2,gp,-32616
8113c468:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113c46c:	d0a02684 	addi	r2,gp,-32614
8113c470:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113c474:	d0a02704 	addi	r2,gp,-32612
8113c478:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8113c47c:	d0a02784 	addi	r2,gp,-32610
8113c480:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113c484:	d0a02804 	addi	r2,gp,-32608
8113c488:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8113c48c:	d0a02884 	addi	r2,gp,-32606
8113c490:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113c494:	d0a02904 	addi	r2,gp,-32604
8113c498:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8113c49c:	d0a02984 	addi	r2,gp,-32602
8113c4a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113c4a4:	d0a02a04 	addi	r2,gp,-32600
8113c4a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8113c4ac:	d0a02a84 	addi	r2,gp,-32598
8113c4b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113c4b4:	d0a02b04 	addi	r2,gp,-32596
8113c4b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8113c4bc:	d0a02b84 	addi	r2,gp,-32594
8113c4c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113c4c4:	d0a02c04 	addi	r2,gp,-32592
8113c4c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8113c4cc:	d0a02c84 	addi	r2,gp,-32590
8113c4d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113c4d4:	d0a02d04 	addi	r2,gp,-32588
8113c4d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113c4dc:	d0a02d84 	addi	r2,gp,-32586
8113c4e0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8113c4e4:	d0a02e04 	addi	r2,gp,-32584
8113c4e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113c4ec:	d0a02e84 	addi	r2,gp,-32582
8113c4f0:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8113c4f4:	00a045f4 	movhi	r2,33047
8113c4f8:	10a58204 	addi	r2,r2,-27128
8113c4fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113c500:	00a045f4 	movhi	r2,33047
8113c504:	10a36e04 	addi	r2,r2,-29256
8113c508:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113c50c:	d0a02f84 	addi	r2,gp,-32578
8113c510:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8113c514:	d0a03004 	addi	r2,gp,-32576
8113c518:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113c51c:	d0a03084 	addi	r2,gp,-32574
8113c520:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113c524:	d0a03104 	addi	r2,gp,-32572
8113c528:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113c52c:	d0a03184 	addi	r2,gp,-32570
8113c530:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113c534:	d0a03204 	addi	r2,gp,-32568
8113c538:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113c53c:	d0a03284 	addi	r2,gp,-32566
8113c540:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113c544:	d0a03304 	addi	r2,gp,-32564
8113c548:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113c54c:	d0a03384 	addi	r2,gp,-32562
8113c550:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113c554:	d0a02f04 	addi	r2,gp,-32580
8113c558:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113c55c:	d0a03404 	addi	r2,gp,-32560
8113c560:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113c564:	0001883a 	nop
8113c568:	e037883a 	mov	sp,fp
8113c56c:	df000017 	ldw	fp,0(sp)
8113c570:	dec00104 	addi	sp,sp,4
8113c574:	f800283a 	ret

8113c578 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113c578:	defff204 	addi	sp,sp,-56
8113c57c:	de00012e 	bgeu	sp,et,8113c584 <OSFlagAccept+0xc>
8113c580:	003b68fa 	trap	3
8113c584:	df000d15 	stw	fp,52(sp)
8113c588:	df000d04 	addi	fp,sp,52
8113c58c:	e13ffc15 	stw	r4,-16(fp)
8113c590:	2807883a 	mov	r3,r5
8113c594:	3005883a 	mov	r2,r6
8113c598:	e1ffff15 	stw	r7,-4(fp)
8113c59c:	e0fffd0d 	sth	r3,-12(fp)
8113c5a0:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c5a4:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c5a8:	e0bfff17 	ldw	r2,-4(fp)
8113c5ac:	1000021e 	bne	r2,zero,8113c5b8 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113c5b0:	0005883a 	mov	r2,zero
8113c5b4:	0000b006 	br	8113c878 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113c5b8:	e0bffc17 	ldw	r2,-16(fp)
8113c5bc:	1000051e 	bne	r2,zero,8113c5d4 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c5c0:	e0bfff17 	ldw	r2,-4(fp)
8113c5c4:	00c01b84 	movi	r3,110
8113c5c8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c5cc:	0005883a 	mov	r2,zero
8113c5d0:	0000a906 	br	8113c878 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113c5d4:	e0bffc17 	ldw	r2,-16(fp)
8113c5d8:	10800003 	ldbu	r2,0(r2)
8113c5dc:	10803fcc 	andi	r2,r2,255
8113c5e0:	10800160 	cmpeqi	r2,r2,5
8113c5e4:	1000051e 	bne	r2,zero,8113c5fc <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8113c5e8:	e0bfff17 	ldw	r2,-4(fp)
8113c5ec:	00c00044 	movi	r3,1
8113c5f0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c5f4:	0005883a 	mov	r2,zero
8113c5f8:	00009f06 	br	8113c878 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113c5fc:	e0fffe03 	ldbu	r3,-8(fp)
8113c600:	00bfe004 	movi	r2,-128
8113c604:	1884703a 	and	r2,r3,r2
8113c608:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113c60c:	e0bff503 	ldbu	r2,-44(fp)
8113c610:	10000626 	beq	r2,zero,8113c62c <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8113c614:	e0bffe03 	ldbu	r2,-8(fp)
8113c618:	10801fcc 	andi	r2,r2,127
8113c61c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113c620:	00800044 	movi	r2,1
8113c624:	e0bff385 	stb	r2,-50(fp)
8113c628:	00000106 	br	8113c630 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113c62c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113c630:	e0bfff17 	ldw	r2,-4(fp)
8113c634:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c638:	0005303a 	rdctl	r2,status
8113c63c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c640:	e0fffb17 	ldw	r3,-20(fp)
8113c644:	00bfff84 	movi	r2,-2
8113c648:	1884703a 	and	r2,r3,r2
8113c64c:	1001703a 	wrctl	status,r2
  
  return context;
8113c650:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113c654:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113c658:	e0bffe03 	ldbu	r2,-8(fp)
8113c65c:	10c00060 	cmpeqi	r3,r2,1
8113c660:	18005f1e 	bne	r3,zero,8113c7e0 <OSFlagAccept+0x268>
8113c664:	10c00088 	cmpgei	r3,r2,2
8113c668:	1800021e 	bne	r3,zero,8113c674 <OSFlagAccept+0xfc>
8113c66c:	10003f26 	beq	r2,zero,8113c76c <OSFlagAccept+0x1f4>
8113c670:	00007706 	br	8113c850 <OSFlagAccept+0x2d8>
8113c674:	10c000a0 	cmpeqi	r3,r2,2
8113c678:	1800031e 	bne	r3,zero,8113c688 <OSFlagAccept+0x110>
8113c67c:	108000e0 	cmpeqi	r2,r2,3
8113c680:	10001e1e 	bne	r2,zero,8113c6fc <OSFlagAccept+0x184>
8113c684:	00007206 	br	8113c850 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113c688:	e0bffc17 	ldw	r2,-16(fp)
8113c68c:	10c0020b 	ldhu	r3,8(r2)
8113c690:	e0bffd0b 	ldhu	r2,-12(fp)
8113c694:	1884703a 	and	r2,r3,r2
8113c698:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c69c:	e0fff30b 	ldhu	r3,-52(fp)
8113c6a0:	e0bffd0b 	ldhu	r2,-12(fp)
8113c6a4:	18800d1e 	bne	r3,r2,8113c6dc <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c6a8:	e0bff383 	ldbu	r2,-50(fp)
8113c6ac:	10800058 	cmpnei	r2,r2,1
8113c6b0:	10000d1e 	bne	r2,zero,8113c6e8 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113c6b4:	e0bffc17 	ldw	r2,-16(fp)
8113c6b8:	1080020b 	ldhu	r2,8(r2)
8113c6bc:	1007883a 	mov	r3,r2
8113c6c0:	e0bff30b 	ldhu	r2,-52(fp)
8113c6c4:	0084303a 	nor	r2,zero,r2
8113c6c8:	1884703a 	and	r2,r3,r2
8113c6cc:	1007883a 	mov	r3,r2
8113c6d0:	e0bffc17 	ldw	r2,-16(fp)
8113c6d4:	10c0020d 	sth	r3,8(r2)
8113c6d8:	00000306 	br	8113c6e8 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c6dc:	e0bfff17 	ldw	r2,-4(fp)
8113c6e0:	00c01c04 	movi	r3,112
8113c6e4:	10c00005 	stb	r3,0(r2)
8113c6e8:	e0bff417 	ldw	r2,-48(fp)
8113c6ec:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c6f0:	e0bff617 	ldw	r2,-40(fp)
8113c6f4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c6f8:	00005e06 	br	8113c874 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113c6fc:	e0bffc17 	ldw	r2,-16(fp)
8113c700:	10c0020b 	ldhu	r3,8(r2)
8113c704:	e0bffd0b 	ldhu	r2,-12(fp)
8113c708:	1884703a 	and	r2,r3,r2
8113c70c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113c710:	e0bff30b 	ldhu	r2,-52(fp)
8113c714:	10000d26 	beq	r2,zero,8113c74c <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c718:	e0bff383 	ldbu	r2,-50(fp)
8113c71c:	10800058 	cmpnei	r2,r2,1
8113c720:	10000d1e 	bne	r2,zero,8113c758 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113c724:	e0bffc17 	ldw	r2,-16(fp)
8113c728:	1080020b 	ldhu	r2,8(r2)
8113c72c:	1007883a 	mov	r3,r2
8113c730:	e0bff30b 	ldhu	r2,-52(fp)
8113c734:	0084303a 	nor	r2,zero,r2
8113c738:	1884703a 	and	r2,r3,r2
8113c73c:	1007883a 	mov	r3,r2
8113c740:	e0bffc17 	ldw	r2,-16(fp)
8113c744:	10c0020d 	sth	r3,8(r2)
8113c748:	00000306 	br	8113c758 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c74c:	e0bfff17 	ldw	r2,-4(fp)
8113c750:	00c01c04 	movi	r3,112
8113c754:	10c00005 	stb	r3,0(r2)
8113c758:	e0bff417 	ldw	r2,-48(fp)
8113c75c:	e0bff715 	stw	r2,-36(fp)
8113c760:	e0bff717 	ldw	r2,-36(fp)
8113c764:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c768:	00004206 	br	8113c874 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113c76c:	e0bffc17 	ldw	r2,-16(fp)
8113c770:	1080020b 	ldhu	r2,8(r2)
8113c774:	0084303a 	nor	r2,zero,r2
8113c778:	1007883a 	mov	r3,r2
8113c77c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c780:	1884703a 	and	r2,r3,r2
8113c784:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c788:	e0fff30b 	ldhu	r3,-52(fp)
8113c78c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c790:	18800b1e 	bne	r3,r2,8113c7c0 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c794:	e0bff383 	ldbu	r2,-50(fp)
8113c798:	10800058 	cmpnei	r2,r2,1
8113c79c:	10000b1e 	bne	r2,zero,8113c7cc <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113c7a0:	e0bffc17 	ldw	r2,-16(fp)
8113c7a4:	10c0020b 	ldhu	r3,8(r2)
8113c7a8:	e0bff30b 	ldhu	r2,-52(fp)
8113c7ac:	1884b03a 	or	r2,r3,r2
8113c7b0:	1007883a 	mov	r3,r2
8113c7b4:	e0bffc17 	ldw	r2,-16(fp)
8113c7b8:	10c0020d 	sth	r3,8(r2)
8113c7bc:	00000306 	br	8113c7cc <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c7c0:	e0bfff17 	ldw	r2,-4(fp)
8113c7c4:	00c01c04 	movi	r3,112
8113c7c8:	10c00005 	stb	r3,0(r2)
8113c7cc:	e0bff417 	ldw	r2,-48(fp)
8113c7d0:	e0bff815 	stw	r2,-32(fp)
8113c7d4:	e0bff817 	ldw	r2,-32(fp)
8113c7d8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c7dc:	00002506 	br	8113c874 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113c7e0:	e0bffc17 	ldw	r2,-16(fp)
8113c7e4:	1080020b 	ldhu	r2,8(r2)
8113c7e8:	0084303a 	nor	r2,zero,r2
8113c7ec:	1007883a 	mov	r3,r2
8113c7f0:	e0bffd0b 	ldhu	r2,-12(fp)
8113c7f4:	1884703a 	and	r2,r3,r2
8113c7f8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113c7fc:	e0bff30b 	ldhu	r2,-52(fp)
8113c800:	10000b26 	beq	r2,zero,8113c830 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c804:	e0bff383 	ldbu	r2,-50(fp)
8113c808:	10800058 	cmpnei	r2,r2,1
8113c80c:	10000b1e 	bne	r2,zero,8113c83c <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113c810:	e0bffc17 	ldw	r2,-16(fp)
8113c814:	10c0020b 	ldhu	r3,8(r2)
8113c818:	e0bff30b 	ldhu	r2,-52(fp)
8113c81c:	1884b03a 	or	r2,r3,r2
8113c820:	1007883a 	mov	r3,r2
8113c824:	e0bffc17 	ldw	r2,-16(fp)
8113c828:	10c0020d 	sth	r3,8(r2)
8113c82c:	00000306 	br	8113c83c <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c830:	e0bfff17 	ldw	r2,-4(fp)
8113c834:	00c01c04 	movi	r3,112
8113c838:	10c00005 	stb	r3,0(r2)
8113c83c:	e0bff417 	ldw	r2,-48(fp)
8113c840:	e0bff915 	stw	r2,-28(fp)
8113c844:	e0bff917 	ldw	r2,-28(fp)
8113c848:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c84c:	00000906 	br	8113c874 <OSFlagAccept+0x2fc>
8113c850:	e0bff417 	ldw	r2,-48(fp)
8113c854:	e0bffa15 	stw	r2,-24(fp)
8113c858:	e0bffa17 	ldw	r2,-24(fp)
8113c85c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113c860:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113c864:	e0bfff17 	ldw	r2,-4(fp)
8113c868:	00c01bc4 	movi	r3,111
8113c86c:	10c00005 	stb	r3,0(r2)
             break;
8113c870:	0001883a 	nop
    }
    return (flags_rdy);
8113c874:	e0bff30b 	ldhu	r2,-52(fp)
}
8113c878:	e037883a 	mov	sp,fp
8113c87c:	df000017 	ldw	fp,0(sp)
8113c880:	dec00104 	addi	sp,sp,4
8113c884:	f800283a 	ret

8113c888 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113c888:	defff804 	addi	sp,sp,-32
8113c88c:	de00012e 	bgeu	sp,et,8113c894 <OSFlagCreate+0xc>
8113c890:	003b68fa 	trap	3
8113c894:	df000715 	stw	fp,28(sp)
8113c898:	df000704 	addi	fp,sp,28
8113c89c:	2005883a 	mov	r2,r4
8113c8a0:	e17fff15 	stw	r5,-4(fp)
8113c8a4:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113c8a8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113c8ac:	e0bfff17 	ldw	r2,-4(fp)
8113c8b0:	1000021e 	bne	r2,zero,8113c8bc <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113c8b4:	0005883a 	mov	r2,zero
8113c8b8:	00003306 	br	8113c988 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113c8bc:	d0a0a103 	ldbu	r2,-32124(gp)
8113c8c0:	10803fcc 	andi	r2,r2,255
8113c8c4:	10000526 	beq	r2,zero,8113c8dc <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113c8c8:	e0bfff17 	ldw	r2,-4(fp)
8113c8cc:	00c00404 	movi	r3,16
8113c8d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113c8d4:	0005883a 	mov	r2,zero
8113c8d8:	00002b06 	br	8113c988 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c8dc:	0005303a 	rdctl	r2,status
8113c8e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c8e4:	e0fffd17 	ldw	r3,-12(fp)
8113c8e8:	00bfff84 	movi	r2,-2
8113c8ec:	1884703a 	and	r2,r3,r2
8113c8f0:	1001703a 	wrctl	status,r2
  
  return context;
8113c8f4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c8f8:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113c8fc:	d0a0a617 	ldw	r2,-32104(gp)
8113c900:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113c904:	e0bffb17 	ldw	r2,-20(fp)
8113c908:	10001726 	beq	r2,zero,8113c968 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113c90c:	d0a0a617 	ldw	r2,-32104(gp)
8113c910:	10800117 	ldw	r2,4(r2)
8113c914:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113c918:	e0bffb17 	ldw	r2,-20(fp)
8113c91c:	00c00144 	movi	r3,5
8113c920:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113c924:	e0bffb17 	ldw	r2,-20(fp)
8113c928:	e0fffe0b 	ldhu	r3,-8(fp)
8113c92c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113c930:	e0bffb17 	ldw	r2,-20(fp)
8113c934:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113c938:	e0bffb17 	ldw	r2,-20(fp)
8113c93c:	00c00fc4 	movi	r3,63
8113c940:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113c944:	e0bffb17 	ldw	r2,-20(fp)
8113c948:	100002c5 	stb	zero,11(r2)
8113c94c:	e0bff917 	ldw	r2,-28(fp)
8113c950:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c954:	e0bffa17 	ldw	r2,-24(fp)
8113c958:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113c95c:	e0bfff17 	ldw	r2,-4(fp)
8113c960:	10000005 	stb	zero,0(r2)
8113c964:	00000706 	br	8113c984 <OSFlagCreate+0xfc>
8113c968:	e0bff917 	ldw	r2,-28(fp)
8113c96c:	e0bffc15 	stw	r2,-16(fp)
8113c970:	e0bffc17 	ldw	r2,-16(fp)
8113c974:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113c978:	e0bfff17 	ldw	r2,-4(fp)
8113c97c:	00c01c84 	movi	r3,114
8113c980:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113c984:	e0bffb17 	ldw	r2,-20(fp)
}
8113c988:	e037883a 	mov	sp,fp
8113c98c:	df000017 	ldw	fp,0(sp)
8113c990:	dec00104 	addi	sp,sp,4
8113c994:	f800283a 	ret

8113c998 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113c998:	defff204 	addi	sp,sp,-56
8113c99c:	de00012e 	bgeu	sp,et,8113c9a4 <OSFlagDel+0xc>
8113c9a0:	003b68fa 	trap	3
8113c9a4:	dfc00d15 	stw	ra,52(sp)
8113c9a8:	df000c15 	stw	fp,48(sp)
8113c9ac:	df000c04 	addi	fp,sp,48
8113c9b0:	e13ffd15 	stw	r4,-12(fp)
8113c9b4:	2805883a 	mov	r2,r5
8113c9b8:	e1bfff15 	stw	r6,-4(fp)
8113c9bc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c9c0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c9c4:	e0bfff17 	ldw	r2,-4(fp)
8113c9c8:	1000021e 	bne	r2,zero,8113c9d4 <OSFlagDel+0x3c>
        return (pgrp);
8113c9cc:	e0bffd17 	ldw	r2,-12(fp)
8113c9d0:	00008006 	br	8113cbd4 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113c9d4:	e0bffd17 	ldw	r2,-12(fp)
8113c9d8:	1000051e 	bne	r2,zero,8113c9f0 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c9dc:	e0bfff17 	ldw	r2,-4(fp)
8113c9e0:	00c01b84 	movi	r3,110
8113c9e4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113c9e8:	e0bffd17 	ldw	r2,-12(fp)
8113c9ec:	00007906 	br	8113cbd4 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c9f0:	d0a0a103 	ldbu	r2,-32124(gp)
8113c9f4:	10803fcc 	andi	r2,r2,255
8113c9f8:	10000526 	beq	r2,zero,8113ca10 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113c9fc:	e0bfff17 	ldw	r2,-4(fp)
8113ca00:	00c003c4 	movi	r3,15
8113ca04:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113ca08:	e0bffd17 	ldw	r2,-12(fp)
8113ca0c:	00007106 	br	8113cbd4 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113ca10:	e0bffd17 	ldw	r2,-12(fp)
8113ca14:	10800003 	ldbu	r2,0(r2)
8113ca18:	10803fcc 	andi	r2,r2,255
8113ca1c:	10800160 	cmpeqi	r2,r2,5
8113ca20:	1000051e 	bne	r2,zero,8113ca38 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113ca24:	e0bfff17 	ldw	r2,-4(fp)
8113ca28:	00c00044 	movi	r3,1
8113ca2c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113ca30:	e0bffd17 	ldw	r2,-12(fp)
8113ca34:	00006706 	br	8113cbd4 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ca38:	0005303a 	rdctl	r2,status
8113ca3c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ca40:	e0fffc17 	ldw	r3,-16(fp)
8113ca44:	00bfff84 	movi	r2,-2
8113ca48:	1884703a 	and	r2,r3,r2
8113ca4c:	1001703a 	wrctl	status,r2
  
  return context;
8113ca50:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ca54:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113ca58:	e0bffd17 	ldw	r2,-12(fp)
8113ca5c:	10800117 	ldw	r2,4(r2)
8113ca60:	10000326 	beq	r2,zero,8113ca70 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113ca64:	00800044 	movi	r2,1
8113ca68:	e0bff405 	stb	r2,-48(fp)
8113ca6c:	00000106 	br	8113ca74 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113ca70:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113ca74:	e0bffe03 	ldbu	r2,-8(fp)
8113ca78:	10000326 	beq	r2,zero,8113ca88 <OSFlagDel+0xf0>
8113ca7c:	10800060 	cmpeqi	r2,r2,1
8113ca80:	1000231e 	bne	r2,zero,8113cb10 <OSFlagDel+0x178>
8113ca84:	00004806 	br	8113cba8 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113ca88:	e0bff403 	ldbu	r2,-48(fp)
8113ca8c:	1000161e 	bne	r2,zero,8113cae8 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113ca90:	e0bffd17 	ldw	r2,-12(fp)
8113ca94:	00c00fc4 	movi	r3,63
8113ca98:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113ca9c:	e0bffd17 	ldw	r2,-12(fp)
8113caa0:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113caa4:	e0bffd17 	ldw	r2,-12(fp)
8113caa8:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113caac:	d0e0a617 	ldw	r3,-32104(gp)
8113cab0:	e0bffd17 	ldw	r2,-12(fp)
8113cab4:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113cab8:	e0bffd17 	ldw	r2,-12(fp)
8113cabc:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113cac0:	e0bffd17 	ldw	r2,-12(fp)
8113cac4:	d0a0a615 	stw	r2,-32104(gp)
8113cac8:	e0bff717 	ldw	r2,-36(fp)
8113cacc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cad0:	e0bff817 	ldw	r2,-32(fp)
8113cad4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113cad8:	e0bfff17 	ldw	r2,-4(fp)
8113cadc:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113cae0:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113cae4:	00003a06 	br	8113cbd0 <OSFlagDel+0x238>
8113cae8:	e0bff717 	ldw	r2,-36(fp)
8113caec:	e0bff915 	stw	r2,-28(fp)
8113caf0:	e0bff917 	ldw	r2,-28(fp)
8113caf4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113caf8:	e0bfff17 	ldw	r2,-4(fp)
8113cafc:	00c01244 	movi	r3,73
8113cb00:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113cb04:	e0bffd17 	ldw	r2,-12(fp)
8113cb08:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113cb0c:	00003006 	br	8113cbd0 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113cb10:	e0bffd17 	ldw	r2,-12(fp)
8113cb14:	10800117 	ldw	r2,4(r2)
8113cb18:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113cb1c:	00000606 	br	8113cb38 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113cb20:	000b883a 	mov	r5,zero
8113cb24:	e13ff517 	ldw	r4,-44(fp)
8113cb28:	113db4c0 	call	8113db4c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113cb2c:	e0bff517 	ldw	r2,-44(fp)
8113cb30:	10800017 	ldw	r2,0(r2)
8113cb34:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113cb38:	e0bff517 	ldw	r2,-44(fp)
8113cb3c:	103ff81e 	bne	r2,zero,8113cb20 <__reset+0xfb11cb20>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113cb40:	e0bffd17 	ldw	r2,-12(fp)
8113cb44:	00c00fc4 	movi	r3,63
8113cb48:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113cb4c:	e0bffd17 	ldw	r2,-12(fp)
8113cb50:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113cb54:	e0bffd17 	ldw	r2,-12(fp)
8113cb58:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113cb5c:	d0e0a617 	ldw	r3,-32104(gp)
8113cb60:	e0bffd17 	ldw	r2,-12(fp)
8113cb64:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113cb68:	e0bffd17 	ldw	r2,-12(fp)
8113cb6c:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113cb70:	e0bffd17 	ldw	r2,-12(fp)
8113cb74:	d0a0a615 	stw	r2,-32104(gp)
8113cb78:	e0bff717 	ldw	r2,-36(fp)
8113cb7c:	e0bffa15 	stw	r2,-24(fp)
8113cb80:	e0bffa17 	ldw	r2,-24(fp)
8113cb84:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113cb88:	e0bff403 	ldbu	r2,-48(fp)
8113cb8c:	10800058 	cmpnei	r2,r2,1
8113cb90:	1000011e 	bne	r2,zero,8113cb98 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113cb94:	113bc5c0 	call	8113bc5c <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113cb98:	e0bfff17 	ldw	r2,-4(fp)
8113cb9c:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113cba0:	e03ff615 	stw	zero,-40(fp)
             break;
8113cba4:	00000a06 	br	8113cbd0 <OSFlagDel+0x238>
8113cba8:	e0bff717 	ldw	r2,-36(fp)
8113cbac:	e0bffb15 	stw	r2,-20(fp)
8113cbb0:	e0bffb17 	ldw	r2,-20(fp)
8113cbb4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113cbb8:	e0bfff17 	ldw	r2,-4(fp)
8113cbbc:	00c001c4 	movi	r3,7
8113cbc0:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113cbc4:	e0bffd17 	ldw	r2,-12(fp)
8113cbc8:	e0bff615 	stw	r2,-40(fp)
             break;
8113cbcc:	0001883a 	nop
    }
    return (pgrp_return);
8113cbd0:	e0bff617 	ldw	r2,-40(fp)
}
8113cbd4:	e037883a 	mov	sp,fp
8113cbd8:	dfc00117 	ldw	ra,4(sp)
8113cbdc:	df000017 	ldw	fp,0(sp)
8113cbe0:	dec00204 	addi	sp,sp,8
8113cbe4:	f800283a 	ret

8113cbe8 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113cbe8:	defff604 	addi	sp,sp,-40
8113cbec:	de00012e 	bgeu	sp,et,8113cbf4 <OSFlagNameGet+0xc>
8113cbf0:	003b68fa 	trap	3
8113cbf4:	dfc00915 	stw	ra,36(sp)
8113cbf8:	df000815 	stw	fp,32(sp)
8113cbfc:	df000804 	addi	fp,sp,32
8113cc00:	e13ffd15 	stw	r4,-12(fp)
8113cc04:	e17ffe15 	stw	r5,-8(fp)
8113cc08:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113cc0c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113cc10:	e0bfff17 	ldw	r2,-4(fp)
8113cc14:	1000021e 	bne	r2,zero,8113cc20 <OSFlagNameGet+0x38>
        return (0);
8113cc18:	0005883a 	mov	r2,zero
8113cc1c:	00003906 	br	8113cd04 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113cc20:	e0bffd17 	ldw	r2,-12(fp)
8113cc24:	1000051e 	bne	r2,zero,8113cc3c <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113cc28:	e0bfff17 	ldw	r2,-4(fp)
8113cc2c:	00c01b84 	movi	r3,110
8113cc30:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc34:	0005883a 	mov	r2,zero
8113cc38:	00003206 	br	8113cd04 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113cc3c:	e0bffe17 	ldw	r2,-8(fp)
8113cc40:	1000051e 	bne	r2,zero,8113cc58 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113cc44:	e0bfff17 	ldw	r2,-4(fp)
8113cc48:	00c00304 	movi	r3,12
8113cc4c:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc50:	0005883a 	mov	r2,zero
8113cc54:	00002b06 	br	8113cd04 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113cc58:	d0a0a103 	ldbu	r2,-32124(gp)
8113cc5c:	10803fcc 	andi	r2,r2,255
8113cc60:	10000526 	beq	r2,zero,8113cc78 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113cc64:	e0bfff17 	ldw	r2,-4(fp)
8113cc68:	00c00444 	movi	r3,17
8113cc6c:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc70:	0005883a 	mov	r2,zero
8113cc74:	00002306 	br	8113cd04 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cc78:	0005303a 	rdctl	r2,status
8113cc7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cc80:	e0fffc17 	ldw	r3,-16(fp)
8113cc84:	00bfff84 	movi	r2,-2
8113cc88:	1884703a 	and	r2,r3,r2
8113cc8c:	1001703a 	wrctl	status,r2
  
  return context;
8113cc90:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cc94:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113cc98:	e0bffd17 	ldw	r2,-12(fp)
8113cc9c:	10800003 	ldbu	r2,0(r2)
8113cca0:	10803fcc 	andi	r2,r2,255
8113cca4:	10800160 	cmpeqi	r2,r2,5
8113cca8:	1000091e 	bne	r2,zero,8113ccd0 <OSFlagNameGet+0xe8>
8113ccac:	e0bff817 	ldw	r2,-32(fp)
8113ccb0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ccb4:	e0bff917 	ldw	r2,-28(fp)
8113ccb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113ccbc:	e0bfff17 	ldw	r2,-4(fp)
8113ccc0:	00c00044 	movi	r3,1
8113ccc4:	10c00005 	stb	r3,0(r2)
        return (0);
8113ccc8:	0005883a 	mov	r2,zero
8113cccc:	00000d06 	br	8113cd04 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113ccd0:	e0bffd17 	ldw	r2,-12(fp)
8113ccd4:	10800284 	addi	r2,r2,10
8113ccd8:	100b883a 	mov	r5,r2
8113ccdc:	e13ffe17 	ldw	r4,-8(fp)
8113cce0:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8113cce4:	e0bffb05 	stb	r2,-20(fp)
8113cce8:	e0bff817 	ldw	r2,-32(fp)
8113ccec:	e0bffa15 	stw	r2,-24(fp)
8113ccf0:	e0bffa17 	ldw	r2,-24(fp)
8113ccf4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ccf8:	e0bfff17 	ldw	r2,-4(fp)
8113ccfc:	10000005 	stb	zero,0(r2)
    return (len);
8113cd00:	e0bffb03 	ldbu	r2,-20(fp)
}
8113cd04:	e037883a 	mov	sp,fp
8113cd08:	dfc00117 	ldw	ra,4(sp)
8113cd0c:	df000017 	ldw	fp,0(sp)
8113cd10:	dec00204 	addi	sp,sp,8
8113cd14:	f800283a 	ret

8113cd18 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113cd18:	defff504 	addi	sp,sp,-44
8113cd1c:	de00012e 	bgeu	sp,et,8113cd24 <OSFlagNameSet+0xc>
8113cd20:	003b68fa 	trap	3
8113cd24:	dfc00a15 	stw	ra,40(sp)
8113cd28:	df000915 	stw	fp,36(sp)
8113cd2c:	df000904 	addi	fp,sp,36
8113cd30:	e13ffd15 	stw	r4,-12(fp)
8113cd34:	e17ffe15 	stw	r5,-8(fp)
8113cd38:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113cd3c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113cd40:	e0bfff17 	ldw	r2,-4(fp)
8113cd44:	10004326 	beq	r2,zero,8113ce54 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113cd48:	e0bffd17 	ldw	r2,-12(fp)
8113cd4c:	1000041e 	bne	r2,zero,8113cd60 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113cd50:	e0bfff17 	ldw	r2,-4(fp)
8113cd54:	00c01b84 	movi	r3,110
8113cd58:	10c00005 	stb	r3,0(r2)
        return;
8113cd5c:	00003e06 	br	8113ce58 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113cd60:	e0bffe17 	ldw	r2,-8(fp)
8113cd64:	1000041e 	bne	r2,zero,8113cd78 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113cd68:	e0bfff17 	ldw	r2,-4(fp)
8113cd6c:	00c00304 	movi	r3,12
8113cd70:	10c00005 	stb	r3,0(r2)
        return;
8113cd74:	00003806 	br	8113ce58 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113cd78:	d0a0a103 	ldbu	r2,-32124(gp)
8113cd7c:	10803fcc 	andi	r2,r2,255
8113cd80:	10000426 	beq	r2,zero,8113cd94 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113cd84:	e0bfff17 	ldw	r2,-4(fp)
8113cd88:	00c00484 	movi	r3,18
8113cd8c:	10c00005 	stb	r3,0(r2)
        return;
8113cd90:	00003106 	br	8113ce58 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cd94:	0005303a 	rdctl	r2,status
8113cd98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cd9c:	e0fffc17 	ldw	r3,-16(fp)
8113cda0:	00bfff84 	movi	r2,-2
8113cda4:	1884703a 	and	r2,r3,r2
8113cda8:	1001703a 	wrctl	status,r2
  
  return context;
8113cdac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cdb0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113cdb4:	e0bffd17 	ldw	r2,-12(fp)
8113cdb8:	10800003 	ldbu	r2,0(r2)
8113cdbc:	10803fcc 	andi	r2,r2,255
8113cdc0:	10800160 	cmpeqi	r2,r2,5
8113cdc4:	1000081e 	bne	r2,zero,8113cde8 <OSFlagNameSet+0xd0>
8113cdc8:	e0bff717 	ldw	r2,-36(fp)
8113cdcc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cdd0:	e0bff817 	ldw	r2,-32(fp)
8113cdd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113cdd8:	e0bfff17 	ldw	r2,-4(fp)
8113cddc:	00c00044 	movi	r3,1
8113cde0:	10c00005 	stb	r3,0(r2)
        return;
8113cde4:	00001c06 	br	8113ce58 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113cde8:	e13ffe17 	ldw	r4,-8(fp)
8113cdec:	113be2c0 	call	8113be2c <OS_StrLen>
8113cdf0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113cdf4:	e0bffa03 	ldbu	r2,-24(fp)
8113cdf8:	10800830 	cmpltui	r2,r2,32
8113cdfc:	1000081e 	bne	r2,zero,8113ce20 <OSFlagNameSet+0x108>
8113ce00:	e0bff717 	ldw	r2,-36(fp)
8113ce04:	e0bff915 	stw	r2,-28(fp)
8113ce08:	e0bff917 	ldw	r2,-28(fp)
8113ce0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113ce10:	e0bfff17 	ldw	r2,-4(fp)
8113ce14:	00c01cc4 	movi	r3,115
8113ce18:	10c00005 	stb	r3,0(r2)
        return;
8113ce1c:	00000e06 	br	8113ce58 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113ce20:	e0bffd17 	ldw	r2,-12(fp)
8113ce24:	10800284 	addi	r2,r2,10
8113ce28:	e17ffe17 	ldw	r5,-8(fp)
8113ce2c:	1009883a 	mov	r4,r2
8113ce30:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8113ce34:	e0bff717 	ldw	r2,-36(fp)
8113ce38:	e0bffb15 	stw	r2,-20(fp)
8113ce3c:	e0bffb17 	ldw	r2,-20(fp)
8113ce40:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ce44:	e0bfff17 	ldw	r2,-4(fp)
8113ce48:	10000005 	stb	zero,0(r2)
    return;
8113ce4c:	0001883a 	nop
8113ce50:	00000106 	br	8113ce58 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113ce54:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113ce58:	e037883a 	mov	sp,fp
8113ce5c:	dfc00117 	ldw	ra,4(sp)
8113ce60:	df000017 	ldw	fp,0(sp)
8113ce64:	dec00204 	addi	sp,sp,8
8113ce68:	f800283a 	ret

8113ce6c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113ce6c:	deffe104 	addi	sp,sp,-124
8113ce70:	de00012e 	bgeu	sp,et,8113ce78 <OSFlagPend+0xc>
8113ce74:	003b68fa 	trap	3
8113ce78:	dfc01e15 	stw	ra,120(sp)
8113ce7c:	df001d15 	stw	fp,116(sp)
8113ce80:	df001d04 	addi	fp,sp,116
8113ce84:	e13ffc15 	stw	r4,-16(fp)
8113ce88:	2809883a 	mov	r4,r5
8113ce8c:	3007883a 	mov	r3,r6
8113ce90:	3805883a 	mov	r2,r7
8113ce94:	e13ffd0d 	sth	r4,-12(fp)
8113ce98:	e0fffe05 	stb	r3,-8(fp)
8113ce9c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113cea0:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113cea4:	e0800217 	ldw	r2,8(fp)
8113cea8:	1000021e 	bne	r2,zero,8113ceb4 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113ceac:	0005883a 	mov	r2,zero
8113ceb0:	00015906 	br	8113d418 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113ceb4:	e0bffc17 	ldw	r2,-16(fp)
8113ceb8:	1000051e 	bne	r2,zero,8113ced0 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113cebc:	e0800217 	ldw	r2,8(fp)
8113cec0:	00c01b84 	movi	r3,110
8113cec4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cec8:	0005883a 	mov	r2,zero
8113cecc:	00015206 	br	8113d418 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ced0:	d0a0a103 	ldbu	r2,-32124(gp)
8113ced4:	10803fcc 	andi	r2,r2,255
8113ced8:	10000526 	beq	r2,zero,8113cef0 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113cedc:	e0800217 	ldw	r2,8(fp)
8113cee0:	00c00084 	movi	r3,2
8113cee4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cee8:	0005883a 	mov	r2,zero
8113ceec:	00014a06 	br	8113d418 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113cef0:	d0a08f03 	ldbu	r2,-32196(gp)
8113cef4:	10803fcc 	andi	r2,r2,255
8113cef8:	10000526 	beq	r2,zero,8113cf10 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113cefc:	e0800217 	ldw	r2,8(fp)
8113cf00:	00c00344 	movi	r3,13
8113cf04:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cf08:	0005883a 	mov	r2,zero
8113cf0c:	00014206 	br	8113d418 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113cf10:	e0bffc17 	ldw	r2,-16(fp)
8113cf14:	10800003 	ldbu	r2,0(r2)
8113cf18:	10803fcc 	andi	r2,r2,255
8113cf1c:	10800160 	cmpeqi	r2,r2,5
8113cf20:	1000051e 	bne	r2,zero,8113cf38 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113cf24:	e0800217 	ldw	r2,8(fp)
8113cf28:	00c00044 	movi	r3,1
8113cf2c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cf30:	0005883a 	mov	r2,zero
8113cf34:	00013806 	br	8113d418 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113cf38:	e0fffe03 	ldbu	r3,-8(fp)
8113cf3c:	00bfe004 	movi	r2,-128
8113cf40:	1884703a 	and	r2,r3,r2
8113cf44:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113cf48:	e0bfe603 	ldbu	r2,-104(fp)
8113cf4c:	10000626 	beq	r2,zero,8113cf68 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113cf50:	e0bffe03 	ldbu	r2,-8(fp)
8113cf54:	10801fcc 	andi	r2,r2,127
8113cf58:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113cf5c:	00800044 	movi	r2,1
8113cf60:	e0bfe405 	stb	r2,-112(fp)
8113cf64:	00000106 	br	8113cf6c <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113cf68:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cf6c:	0005303a 	rdctl	r2,status
8113cf70:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cf74:	e0fff617 	ldw	r3,-40(fp)
8113cf78:	00bfff84 	movi	r2,-2
8113cf7c:	1884703a 	and	r2,r3,r2
8113cf80:	1001703a 	wrctl	status,r2
  
  return context;
8113cf84:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113cf88:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113cf8c:	e0bffe03 	ldbu	r2,-8(fp)
8113cf90:	10c00060 	cmpeqi	r3,r2,1
8113cf94:	1800921e 	bne	r3,zero,8113d1e0 <OSFlagPend+0x374>
8113cf98:	10c00088 	cmpgei	r3,r2,2
8113cf9c:	1800021e 	bne	r3,zero,8113cfa8 <OSFlagPend+0x13c>
8113cfa0:	10006126 	beq	r2,zero,8113d128 <OSFlagPend+0x2bc>
8113cfa4:	0000bb06 	br	8113d294 <OSFlagPend+0x428>
8113cfa8:	10c000a0 	cmpeqi	r3,r2,2
8113cfac:	1800031e 	bne	r3,zero,8113cfbc <OSFlagPend+0x150>
8113cfb0:	108000e0 	cmpeqi	r2,r2,3
8113cfb4:	10002f1e 	bne	r2,zero,8113d074 <OSFlagPend+0x208>
8113cfb8:	0000b606 	br	8113d294 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113cfbc:	e0bffc17 	ldw	r2,-16(fp)
8113cfc0:	10c0020b 	ldhu	r3,8(r2)
8113cfc4:	e0bffd0b 	ldhu	r2,-12(fp)
8113cfc8:	1884703a 	and	r2,r3,r2
8113cfcc:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113cfd0:	e0ffe80b 	ldhu	r3,-96(fp)
8113cfd4:	e0bffd0b 	ldhu	r2,-12(fp)
8113cfd8:	1880171e 	bne	r3,r2,8113d038 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113cfdc:	e0bfe403 	ldbu	r2,-112(fp)
8113cfe0:	10800058 	cmpnei	r2,r2,1
8113cfe4:	1000091e 	bne	r2,zero,8113d00c <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113cfe8:	e0bffc17 	ldw	r2,-16(fp)
8113cfec:	1080020b 	ldhu	r2,8(r2)
8113cff0:	1007883a 	mov	r3,r2
8113cff4:	e0bfe80b 	ldhu	r2,-96(fp)
8113cff8:	0084303a 	nor	r2,zero,r2
8113cffc:	1884703a 	and	r2,r3,r2
8113d000:	1007883a 	mov	r3,r2
8113d004:	e0bffc17 	ldw	r2,-16(fp)
8113d008:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113d00c:	d0a0a217 	ldw	r2,-32120(gp)
8113d010:	e0ffe80b 	ldhu	r3,-96(fp)
8113d014:	10c00b0d 	sth	r3,44(r2)
8113d018:	e0bfe517 	ldw	r2,-108(fp)
8113d01c:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d020:	e0bfe717 	ldw	r2,-100(fp)
8113d024:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113d028:	e0800217 	ldw	r2,8(fp)
8113d02c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113d030:	e0bfe80b 	ldhu	r2,-96(fp)
8113d034:	0000f806 	br	8113d418 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113d038:	e13ffd0b 	ldhu	r4,-12(fp)
8113d03c:	e17ffe03 	ldbu	r5,-8(fp)
8113d040:	e0bfff0b 	ldhu	r2,-4(fp)
8113d044:	e0fff704 	addi	r3,fp,-36
8113d048:	d8800015 	stw	r2,0(sp)
8113d04c:	280f883a 	mov	r7,r5
8113d050:	200d883a 	mov	r6,r4
8113d054:	180b883a 	mov	r5,r3
8113d058:	e13ffc17 	ldw	r4,-16(fp)
8113d05c:	113d8fc0 	call	8113d8fc <OS_FlagBlock>
8113d060:	e0bfe517 	ldw	r2,-108(fp)
8113d064:	e0bfe915 	stw	r2,-92(fp)
8113d068:	e0bfe917 	ldw	r2,-92(fp)
8113d06c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113d070:	00009206 	br	8113d2bc <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113d074:	e0bffc17 	ldw	r2,-16(fp)
8113d078:	10c0020b 	ldhu	r3,8(r2)
8113d07c:	e0bffd0b 	ldhu	r2,-12(fp)
8113d080:	1884703a 	and	r2,r3,r2
8113d084:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113d088:	e0bfe80b 	ldhu	r2,-96(fp)
8113d08c:	10001726 	beq	r2,zero,8113d0ec <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113d090:	e0bfe403 	ldbu	r2,-112(fp)
8113d094:	10800058 	cmpnei	r2,r2,1
8113d098:	1000091e 	bne	r2,zero,8113d0c0 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113d09c:	e0bffc17 	ldw	r2,-16(fp)
8113d0a0:	1080020b 	ldhu	r2,8(r2)
8113d0a4:	1007883a 	mov	r3,r2
8113d0a8:	e0bfe80b 	ldhu	r2,-96(fp)
8113d0ac:	0084303a 	nor	r2,zero,r2
8113d0b0:	1884703a 	and	r2,r3,r2
8113d0b4:	1007883a 	mov	r3,r2
8113d0b8:	e0bffc17 	ldw	r2,-16(fp)
8113d0bc:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113d0c0:	d0a0a217 	ldw	r2,-32120(gp)
8113d0c4:	e0ffe80b 	ldhu	r3,-96(fp)
8113d0c8:	10c00b0d 	sth	r3,44(r2)
8113d0cc:	e0bfe517 	ldw	r2,-108(fp)
8113d0d0:	e0bfea15 	stw	r2,-88(fp)
8113d0d4:	e0bfea17 	ldw	r2,-88(fp)
8113d0d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113d0dc:	e0800217 	ldw	r2,8(fp)
8113d0e0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113d0e4:	e0bfe80b 	ldhu	r2,-96(fp)
8113d0e8:	0000cb06 	br	8113d418 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113d0ec:	e13ffd0b 	ldhu	r4,-12(fp)
8113d0f0:	e17ffe03 	ldbu	r5,-8(fp)
8113d0f4:	e0bfff0b 	ldhu	r2,-4(fp)
8113d0f8:	e0fff704 	addi	r3,fp,-36
8113d0fc:	d8800015 	stw	r2,0(sp)
8113d100:	280f883a 	mov	r7,r5
8113d104:	200d883a 	mov	r6,r4
8113d108:	180b883a 	mov	r5,r3
8113d10c:	e13ffc17 	ldw	r4,-16(fp)
8113d110:	113d8fc0 	call	8113d8fc <OS_FlagBlock>
8113d114:	e0bfe517 	ldw	r2,-108(fp)
8113d118:	e0bfeb15 	stw	r2,-84(fp)
8113d11c:	e0bfeb17 	ldw	r2,-84(fp)
8113d120:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113d124:	00006506 	br	8113d2bc <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113d128:	e0bffc17 	ldw	r2,-16(fp)
8113d12c:	1080020b 	ldhu	r2,8(r2)
8113d130:	0084303a 	nor	r2,zero,r2
8113d134:	1007883a 	mov	r3,r2
8113d138:	e0bffd0b 	ldhu	r2,-12(fp)
8113d13c:	1884703a 	and	r2,r3,r2
8113d140:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113d144:	e0ffe80b 	ldhu	r3,-96(fp)
8113d148:	e0bffd0b 	ldhu	r2,-12(fp)
8113d14c:	1880151e 	bne	r3,r2,8113d1a4 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113d150:	e0bfe403 	ldbu	r2,-112(fp)
8113d154:	10800058 	cmpnei	r2,r2,1
8113d158:	1000071e 	bne	r2,zero,8113d178 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113d15c:	e0bffc17 	ldw	r2,-16(fp)
8113d160:	10c0020b 	ldhu	r3,8(r2)
8113d164:	e0bfe80b 	ldhu	r2,-96(fp)
8113d168:	1884b03a 	or	r2,r3,r2
8113d16c:	1007883a 	mov	r3,r2
8113d170:	e0bffc17 	ldw	r2,-16(fp)
8113d174:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113d178:	d0a0a217 	ldw	r2,-32120(gp)
8113d17c:	e0ffe80b 	ldhu	r3,-96(fp)
8113d180:	10c00b0d 	sth	r3,44(r2)
8113d184:	e0bfe517 	ldw	r2,-108(fp)
8113d188:	e0bfec15 	stw	r2,-80(fp)
8113d18c:	e0bfec17 	ldw	r2,-80(fp)
8113d190:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113d194:	e0800217 	ldw	r2,8(fp)
8113d198:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113d19c:	e0bfe80b 	ldhu	r2,-96(fp)
8113d1a0:	00009d06 	br	8113d418 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113d1a4:	e13ffd0b 	ldhu	r4,-12(fp)
8113d1a8:	e17ffe03 	ldbu	r5,-8(fp)
8113d1ac:	e0bfff0b 	ldhu	r2,-4(fp)
8113d1b0:	e0fff704 	addi	r3,fp,-36
8113d1b4:	d8800015 	stw	r2,0(sp)
8113d1b8:	280f883a 	mov	r7,r5
8113d1bc:	200d883a 	mov	r6,r4
8113d1c0:	180b883a 	mov	r5,r3
8113d1c4:	e13ffc17 	ldw	r4,-16(fp)
8113d1c8:	113d8fc0 	call	8113d8fc <OS_FlagBlock>
8113d1cc:	e0bfe517 	ldw	r2,-108(fp)
8113d1d0:	e0bfed15 	stw	r2,-76(fp)
8113d1d4:	e0bfed17 	ldw	r2,-76(fp)
8113d1d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113d1dc:	00003706 	br	8113d2bc <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113d1e0:	e0bffc17 	ldw	r2,-16(fp)
8113d1e4:	1080020b 	ldhu	r2,8(r2)
8113d1e8:	0084303a 	nor	r2,zero,r2
8113d1ec:	1007883a 	mov	r3,r2
8113d1f0:	e0bffd0b 	ldhu	r2,-12(fp)
8113d1f4:	1884703a 	and	r2,r3,r2
8113d1f8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113d1fc:	e0bfe80b 	ldhu	r2,-96(fp)
8113d200:	10001526 	beq	r2,zero,8113d258 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113d204:	e0bfe403 	ldbu	r2,-112(fp)
8113d208:	10800058 	cmpnei	r2,r2,1
8113d20c:	1000071e 	bne	r2,zero,8113d22c <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113d210:	e0bffc17 	ldw	r2,-16(fp)
8113d214:	10c0020b 	ldhu	r3,8(r2)
8113d218:	e0bfe80b 	ldhu	r2,-96(fp)
8113d21c:	1884b03a 	or	r2,r3,r2
8113d220:	1007883a 	mov	r3,r2
8113d224:	e0bffc17 	ldw	r2,-16(fp)
8113d228:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113d22c:	d0a0a217 	ldw	r2,-32120(gp)
8113d230:	e0ffe80b 	ldhu	r3,-96(fp)
8113d234:	10c00b0d 	sth	r3,44(r2)
8113d238:	e0bfe517 	ldw	r2,-108(fp)
8113d23c:	e0bfee15 	stw	r2,-72(fp)
8113d240:	e0bfee17 	ldw	r2,-72(fp)
8113d244:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113d248:	e0800217 	ldw	r2,8(fp)
8113d24c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113d250:	e0bfe80b 	ldhu	r2,-96(fp)
8113d254:	00007006 	br	8113d418 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113d258:	e13ffd0b 	ldhu	r4,-12(fp)
8113d25c:	e17ffe03 	ldbu	r5,-8(fp)
8113d260:	e0bfff0b 	ldhu	r2,-4(fp)
8113d264:	e0fff704 	addi	r3,fp,-36
8113d268:	d8800015 	stw	r2,0(sp)
8113d26c:	280f883a 	mov	r7,r5
8113d270:	200d883a 	mov	r6,r4
8113d274:	180b883a 	mov	r5,r3
8113d278:	e13ffc17 	ldw	r4,-16(fp)
8113d27c:	113d8fc0 	call	8113d8fc <OS_FlagBlock>
8113d280:	e0bfe517 	ldw	r2,-108(fp)
8113d284:	e0bfef15 	stw	r2,-68(fp)
8113d288:	e0bfef17 	ldw	r2,-68(fp)
8113d28c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113d290:	00000a06 	br	8113d2bc <OSFlagPend+0x450>
8113d294:	e0bfe517 	ldw	r2,-108(fp)
8113d298:	e0bff015 	stw	r2,-64(fp)
8113d29c:	e0bff017 	ldw	r2,-64(fp)
8113d2a0:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113d2a4:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113d2a8:	e0800217 	ldw	r2,8(fp)
8113d2ac:	00c01bc4 	movi	r3,111
8113d2b0:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113d2b4:	e0bfe80b 	ldhu	r2,-96(fp)
8113d2b8:	00005706 	br	8113d418 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113d2bc:	113bc5c0 	call	8113bc5c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d2c0:	0005303a 	rdctl	r2,status
8113d2c4:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d2c8:	e0fff117 	ldw	r3,-60(fp)
8113d2cc:	00bfff84 	movi	r2,-2
8113d2d0:	1884703a 	and	r2,r3,r2
8113d2d4:	1001703a 	wrctl	status,r2
  
  return context;
8113d2d8:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113d2dc:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113d2e0:	d0a0a217 	ldw	r2,-32120(gp)
8113d2e4:	10800c43 	ldbu	r2,49(r2)
8113d2e8:	10803fcc 	andi	r2,r2,255
8113d2ec:	10001c26 	beq	r2,zero,8113d360 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113d2f0:	d0a0a217 	ldw	r2,-32120(gp)
8113d2f4:	10800c43 	ldbu	r2,49(r2)
8113d2f8:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113d2fc:	d0a0a217 	ldw	r2,-32120(gp)
8113d300:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113d304:	e0bff704 	addi	r2,fp,-36
8113d308:	1009883a 	mov	r4,r2
8113d30c:	113dc480 	call	8113dc48 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113d310:	d0a0a217 	ldw	r2,-32120(gp)
8113d314:	10000c05 	stb	zero,48(r2)
8113d318:	e0bfe517 	ldw	r2,-108(fp)
8113d31c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d320:	e0bff217 	ldw	r2,-56(fp)
8113d324:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113d328:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113d32c:	e0bff303 	ldbu	r2,-52(fp)
8113d330:	108000a0 	cmpeqi	r2,r2,2
8113d334:	10000426 	beq	r2,zero,8113d348 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113d338:	e0800217 	ldw	r2,8(fp)
8113d33c:	00c00384 	movi	r3,14
8113d340:	10c00005 	stb	r3,0(r2)
                 break;
8113d344:	00000406 	br	8113d358 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113d348:	e0800217 	ldw	r2,8(fp)
8113d34c:	00c00284 	movi	r3,10
8113d350:	10c00005 	stb	r3,0(r2)
                 break;
8113d354:	0001883a 	nop
        }
        return (flags_rdy);
8113d358:	e0bfe80b 	ldhu	r2,-96(fp)
8113d35c:	00002e06 	br	8113d418 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113d360:	d0a0a217 	ldw	r2,-32120(gp)
8113d364:	10800b0b 	ldhu	r2,44(r2)
8113d368:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113d36c:	e0bfe403 	ldbu	r2,-112(fp)
8113d370:	10800058 	cmpnei	r2,r2,1
8113d374:	1000211e 	bne	r2,zero,8113d3fc <OSFlagPend+0x590>
        switch (wait_type) {
8113d378:	e0bffe03 	ldbu	r2,-8(fp)
8113d37c:	10001616 	blt	r2,zero,8113d3d8 <OSFlagPend+0x56c>
8113d380:	10c00090 	cmplti	r3,r2,2
8113d384:	18000c1e 	bne	r3,zero,8113d3b8 <OSFlagPend+0x54c>
8113d388:	10800108 	cmpgei	r2,r2,4
8113d38c:	1000121e 	bne	r2,zero,8113d3d8 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113d390:	e0bffc17 	ldw	r2,-16(fp)
8113d394:	1080020b 	ldhu	r2,8(r2)
8113d398:	1007883a 	mov	r3,r2
8113d39c:	e0bfe80b 	ldhu	r2,-96(fp)
8113d3a0:	0084303a 	nor	r2,zero,r2
8113d3a4:	1884703a 	and	r2,r3,r2
8113d3a8:	1007883a 	mov	r3,r2
8113d3ac:	e0bffc17 	ldw	r2,-16(fp)
8113d3b0:	10c0020d 	sth	r3,8(r2)
                 break;
8113d3b4:	00001106 	br	8113d3fc <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113d3b8:	e0bffc17 	ldw	r2,-16(fp)
8113d3bc:	10c0020b 	ldhu	r3,8(r2)
8113d3c0:	e0bfe80b 	ldhu	r2,-96(fp)
8113d3c4:	1884b03a 	or	r2,r3,r2
8113d3c8:	1007883a 	mov	r3,r2
8113d3cc:	e0bffc17 	ldw	r2,-16(fp)
8113d3d0:	10c0020d 	sth	r3,8(r2)
                 break;
8113d3d4:	00000906 	br	8113d3fc <OSFlagPend+0x590>
8113d3d8:	e0bfe517 	ldw	r2,-108(fp)
8113d3dc:	e0bff415 	stw	r2,-48(fp)
8113d3e0:	e0bff417 	ldw	r2,-48(fp)
8113d3e4:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113d3e8:	e0800217 	ldw	r2,8(fp)
8113d3ec:	00c01bc4 	movi	r3,111
8113d3f0:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113d3f4:	0005883a 	mov	r2,zero
8113d3f8:	00000706 	br	8113d418 <OSFlagPend+0x5ac>
8113d3fc:	e0bfe517 	ldw	r2,-108(fp)
8113d400:	e0bff515 	stw	r2,-44(fp)
8113d404:	e0bff517 	ldw	r2,-44(fp)
8113d408:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113d40c:	e0800217 	ldw	r2,8(fp)
8113d410:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113d414:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113d418:	e037883a 	mov	sp,fp
8113d41c:	dfc00117 	ldw	ra,4(sp)
8113d420:	df000017 	ldw	fp,0(sp)
8113d424:	dec00204 	addi	sp,sp,8
8113d428:	f800283a 	ret

8113d42c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113d42c:	defffb04 	addi	sp,sp,-20
8113d430:	de00012e 	bgeu	sp,et,8113d438 <OSFlagPendGetFlagsRdy+0xc>
8113d434:	003b68fa 	trap	3
8113d438:	df000415 	stw	fp,16(sp)
8113d43c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113d440:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d444:	0005303a 	rdctl	r2,status
8113d448:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d44c:	e0fffe17 	ldw	r3,-8(fp)
8113d450:	00bfff84 	movi	r2,-2
8113d454:	1884703a 	and	r2,r3,r2
8113d458:	1001703a 	wrctl	status,r2
  
  return context;
8113d45c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113d460:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113d464:	d0a0a217 	ldw	r2,-32120(gp)
8113d468:	10800b0b 	ldhu	r2,44(r2)
8113d46c:	e0bffd0d 	sth	r2,-12(fp)
8113d470:	e0bffc17 	ldw	r2,-16(fp)
8113d474:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d478:	e0bfff17 	ldw	r2,-4(fp)
8113d47c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113d480:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113d484:	e037883a 	mov	sp,fp
8113d488:	df000017 	ldw	fp,0(sp)
8113d48c:	dec00104 	addi	sp,sp,4
8113d490:	f800283a 	ret

8113d494 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113d494:	deffef04 	addi	sp,sp,-68
8113d498:	de00012e 	bgeu	sp,et,8113d4a0 <OSFlagPost+0xc>
8113d49c:	003b68fa 	trap	3
8113d4a0:	dfc01015 	stw	ra,64(sp)
8113d4a4:	df000f15 	stw	fp,60(sp)
8113d4a8:	df000f04 	addi	fp,sp,60
8113d4ac:	e13ffc15 	stw	r4,-16(fp)
8113d4b0:	2807883a 	mov	r3,r5
8113d4b4:	3005883a 	mov	r2,r6
8113d4b8:	e1ffff15 	stw	r7,-4(fp)
8113d4bc:	e0fffd0d 	sth	r3,-12(fp)
8113d4c0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113d4c4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113d4c8:	e0bfff17 	ldw	r2,-4(fp)
8113d4cc:	1000021e 	bne	r2,zero,8113d4d8 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113d4d0:	0005883a 	mov	r2,zero
8113d4d4:	0000d106 	br	8113d81c <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113d4d8:	e0bffc17 	ldw	r2,-16(fp)
8113d4dc:	1000051e 	bne	r2,zero,8113d4f4 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113d4e0:	e0bfff17 	ldw	r2,-4(fp)
8113d4e4:	00c01b84 	movi	r3,110
8113d4e8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d4ec:	0005883a 	mov	r2,zero
8113d4f0:	0000ca06 	br	8113d81c <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113d4f4:	e0bffc17 	ldw	r2,-16(fp)
8113d4f8:	10800003 	ldbu	r2,0(r2)
8113d4fc:	10803fcc 	andi	r2,r2,255
8113d500:	10800160 	cmpeqi	r2,r2,5
8113d504:	1000051e 	bne	r2,zero,8113d51c <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113d508:	e0bfff17 	ldw	r2,-4(fp)
8113d50c:	00c00044 	movi	r3,1
8113d510:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d514:	0005883a 	mov	r2,zero
8113d518:	0000c006 	br	8113d81c <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d51c:	0005303a 	rdctl	r2,status
8113d520:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d524:	e0fffb17 	ldw	r3,-20(fp)
8113d528:	00bfff84 	movi	r2,-2
8113d52c:	1884703a 	and	r2,r3,r2
8113d530:	1001703a 	wrctl	status,r2
  
  return context;
8113d534:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113d538:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113d53c:	e0bffe03 	ldbu	r2,-8(fp)
8113d540:	10000326 	beq	r2,zero,8113d550 <OSFlagPost+0xbc>
8113d544:	10800060 	cmpeqi	r2,r2,1
8113d548:	10000b1e 	bne	r2,zero,8113d578 <OSFlagPost+0xe4>
8113d54c:	00001206 	br	8113d598 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113d550:	e0bffc17 	ldw	r2,-16(fp)
8113d554:	1080020b 	ldhu	r2,8(r2)
8113d558:	1007883a 	mov	r3,r2
8113d55c:	e0bffd0b 	ldhu	r2,-12(fp)
8113d560:	0084303a 	nor	r2,zero,r2
8113d564:	1884703a 	and	r2,r3,r2
8113d568:	1007883a 	mov	r3,r2
8113d56c:	e0bffc17 	ldw	r2,-16(fp)
8113d570:	10c0020d 	sth	r3,8(r2)
             break;
8113d574:	00001106 	br	8113d5bc <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113d578:	e0bffc17 	ldw	r2,-16(fp)
8113d57c:	10c0020b 	ldhu	r3,8(r2)
8113d580:	e0bffd0b 	ldhu	r2,-12(fp)
8113d584:	1884b03a 	or	r2,r3,r2
8113d588:	1007883a 	mov	r3,r2
8113d58c:	e0bffc17 	ldw	r2,-16(fp)
8113d590:	10c0020d 	sth	r3,8(r2)
             break;
8113d594:	00000906 	br	8113d5bc <OSFlagPost+0x128>
8113d598:	e0bff317 	ldw	r2,-52(fp)
8113d59c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d5a0:	e0bff417 	ldw	r2,-48(fp)
8113d5a4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113d5a8:	e0bfff17 	ldw	r2,-4(fp)
8113d5ac:	00c01c44 	movi	r3,113
8113d5b0:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113d5b4:	0005883a 	mov	r2,zero
8113d5b8:	00009806 	br	8113d81c <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113d5bc:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113d5c0:	e0bffc17 	ldw	r2,-16(fp)
8113d5c4:	10800117 	ldw	r2,4(r2)
8113d5c8:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113d5cc:	00007706 	br	8113d7ac <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113d5d0:	e0bff117 	ldw	r2,-60(fp)
8113d5d4:	10800483 	ldbu	r2,18(r2)
8113d5d8:	10803fcc 	andi	r2,r2,255
8113d5dc:	10c00060 	cmpeqi	r3,r2,1
8113d5e0:	18004a1e 	bne	r3,zero,8113d70c <OSFlagPost+0x278>
8113d5e4:	10c00088 	cmpgei	r3,r2,2
8113d5e8:	1800021e 	bne	r3,zero,8113d5f4 <OSFlagPost+0x160>
8113d5ec:	10002f26 	beq	r2,zero,8113d6ac <OSFlagPost+0x218>
8113d5f0:	00005b06 	br	8113d760 <OSFlagPost+0x2cc>
8113d5f4:	10c000a0 	cmpeqi	r3,r2,2
8113d5f8:	1800031e 	bne	r3,zero,8113d608 <OSFlagPost+0x174>
8113d5fc:	108000e0 	cmpeqi	r2,r2,3
8113d600:	1000171e 	bne	r2,zero,8113d660 <OSFlagPost+0x1cc>
8113d604:	00005606 	br	8113d760 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d608:	e0bffc17 	ldw	r2,-16(fp)
8113d60c:	10c0020b 	ldhu	r3,8(r2)
8113d610:	e0bff117 	ldw	r2,-60(fp)
8113d614:	1080040b 	ldhu	r2,16(r2)
8113d618:	1884703a 	and	r2,r3,r2
8113d61c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113d620:	e0bff117 	ldw	r2,-60(fp)
8113d624:	1080040b 	ldhu	r2,16(r2)
8113d628:	10ffffcc 	andi	r3,r2,65535
8113d62c:	e0bff60b 	ldhu	r2,-40(fp)
8113d630:	1880541e 	bne	r3,r2,8113d784 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d634:	e0bff60b 	ldhu	r2,-40(fp)
8113d638:	100b883a 	mov	r5,r2
8113d63c:	e13ff117 	ldw	r4,-60(fp)
8113d640:	113db4c0 	call	8113db4c <OS_FlagTaskRdy>
8113d644:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d648:	e0bff683 	ldbu	r2,-38(fp)
8113d64c:	10800058 	cmpnei	r2,r2,1
8113d650:	10004c1e 	bne	r2,zero,8113d784 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d654:	00800044 	movi	r2,1
8113d658:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d65c:	00004906 	br	8113d784 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d660:	e0bffc17 	ldw	r2,-16(fp)
8113d664:	10c0020b 	ldhu	r3,8(r2)
8113d668:	e0bff117 	ldw	r2,-60(fp)
8113d66c:	1080040b 	ldhu	r2,16(r2)
8113d670:	1884703a 	and	r2,r3,r2
8113d674:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113d678:	e0bff60b 	ldhu	r2,-40(fp)
8113d67c:	10004326 	beq	r2,zero,8113d78c <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d680:	e0bff60b 	ldhu	r2,-40(fp)
8113d684:	100b883a 	mov	r5,r2
8113d688:	e13ff117 	ldw	r4,-60(fp)
8113d68c:	113db4c0 	call	8113db4c <OS_FlagTaskRdy>
8113d690:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d694:	e0bff683 	ldbu	r2,-38(fp)
8113d698:	10800058 	cmpnei	r2,r2,1
8113d69c:	10003b1e 	bne	r2,zero,8113d78c <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d6a0:	00800044 	movi	r2,1
8113d6a4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d6a8:	00003806 	br	8113d78c <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d6ac:	e0bffc17 	ldw	r2,-16(fp)
8113d6b0:	1080020b 	ldhu	r2,8(r2)
8113d6b4:	0084303a 	nor	r2,zero,r2
8113d6b8:	1007883a 	mov	r3,r2
8113d6bc:	e0bff117 	ldw	r2,-60(fp)
8113d6c0:	1080040b 	ldhu	r2,16(r2)
8113d6c4:	1884703a 	and	r2,r3,r2
8113d6c8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113d6cc:	e0bff117 	ldw	r2,-60(fp)
8113d6d0:	1080040b 	ldhu	r2,16(r2)
8113d6d4:	10ffffcc 	andi	r3,r2,65535
8113d6d8:	e0bff60b 	ldhu	r2,-40(fp)
8113d6dc:	18802d1e 	bne	r3,r2,8113d794 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d6e0:	e0bff60b 	ldhu	r2,-40(fp)
8113d6e4:	100b883a 	mov	r5,r2
8113d6e8:	e13ff117 	ldw	r4,-60(fp)
8113d6ec:	113db4c0 	call	8113db4c <OS_FlagTaskRdy>
8113d6f0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d6f4:	e0bff683 	ldbu	r2,-38(fp)
8113d6f8:	10800058 	cmpnei	r2,r2,1
8113d6fc:	1000251e 	bne	r2,zero,8113d794 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d700:	00800044 	movi	r2,1
8113d704:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d708:	00002206 	br	8113d794 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d70c:	e0bffc17 	ldw	r2,-16(fp)
8113d710:	1080020b 	ldhu	r2,8(r2)
8113d714:	0084303a 	nor	r2,zero,r2
8113d718:	1007883a 	mov	r3,r2
8113d71c:	e0bff117 	ldw	r2,-60(fp)
8113d720:	1080040b 	ldhu	r2,16(r2)
8113d724:	1884703a 	and	r2,r3,r2
8113d728:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113d72c:	e0bff60b 	ldhu	r2,-40(fp)
8113d730:	10001a26 	beq	r2,zero,8113d79c <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d734:	e0bff60b 	ldhu	r2,-40(fp)
8113d738:	100b883a 	mov	r5,r2
8113d73c:	e13ff117 	ldw	r4,-60(fp)
8113d740:	113db4c0 	call	8113db4c <OS_FlagTaskRdy>
8113d744:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d748:	e0bff683 	ldbu	r2,-38(fp)
8113d74c:	10800058 	cmpnei	r2,r2,1
8113d750:	1000121e 	bne	r2,zero,8113d79c <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d754:	00800044 	movi	r2,1
8113d758:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d75c:	00000f06 	br	8113d79c <OSFlagPost+0x308>
8113d760:	e0bff317 	ldw	r2,-52(fp)
8113d764:	e0bff515 	stw	r2,-44(fp)
8113d768:	e0bff517 	ldw	r2,-44(fp)
8113d76c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113d770:	e0bfff17 	ldw	r2,-4(fp)
8113d774:	00c01bc4 	movi	r3,111
8113d778:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113d77c:	0005883a 	mov	r2,zero
8113d780:	00002606 	br	8113d81c <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d784:	0001883a 	nop
8113d788:	00000506 	br	8113d7a0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d78c:	0001883a 	nop
8113d790:	00000306 	br	8113d7a0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d794:	0001883a 	nop
8113d798:	00000106 	br	8113d7a0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d79c:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113d7a0:	e0bff117 	ldw	r2,-60(fp)
8113d7a4:	10800017 	ldw	r2,0(r2)
8113d7a8:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113d7ac:	e0bff117 	ldw	r2,-60(fp)
8113d7b0:	103f871e 	bne	r2,zero,8113d5d0 <__reset+0xfb11d5d0>
8113d7b4:	e0bff317 	ldw	r2,-52(fp)
8113d7b8:	e0bff715 	stw	r2,-36(fp)
8113d7bc:	e0bff717 	ldw	r2,-36(fp)
8113d7c0:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113d7c4:	e0bff203 	ldbu	r2,-56(fp)
8113d7c8:	10800058 	cmpnei	r2,r2,1
8113d7cc:	1000011e 	bne	r2,zero,8113d7d4 <OSFlagPost+0x340>
        OS_Sched();
8113d7d0:	113bc5c0 	call	8113bc5c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d7d4:	0005303a 	rdctl	r2,status
8113d7d8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d7dc:	e0fffa17 	ldw	r3,-24(fp)
8113d7e0:	00bfff84 	movi	r2,-2
8113d7e4:	1884703a 	and	r2,r3,r2
8113d7e8:	1001703a 	wrctl	status,r2
  
  return context;
8113d7ec:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113d7f0:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113d7f4:	e0bffc17 	ldw	r2,-16(fp)
8113d7f8:	1080020b 	ldhu	r2,8(r2)
8113d7fc:	e0bff90d 	sth	r2,-28(fp)
8113d800:	e0bff317 	ldw	r2,-52(fp)
8113d804:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d808:	e0bff817 	ldw	r2,-32(fp)
8113d80c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113d810:	e0bfff17 	ldw	r2,-4(fp)
8113d814:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113d818:	e0bff90b 	ldhu	r2,-28(fp)
}
8113d81c:	e037883a 	mov	sp,fp
8113d820:	dfc00117 	ldw	ra,4(sp)
8113d824:	df000017 	ldw	fp,0(sp)
8113d828:	dec00204 	addi	sp,sp,8
8113d82c:	f800283a 	ret

8113d830 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113d830:	defff904 	addi	sp,sp,-28
8113d834:	de00012e 	bgeu	sp,et,8113d83c <OSFlagQuery+0xc>
8113d838:	003b68fa 	trap	3
8113d83c:	df000615 	stw	fp,24(sp)
8113d840:	df000604 	addi	fp,sp,24
8113d844:	e13ffe15 	stw	r4,-8(fp)
8113d848:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113d84c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113d850:	e0bfff17 	ldw	r2,-4(fp)
8113d854:	1000021e 	bne	r2,zero,8113d860 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113d858:	0005883a 	mov	r2,zero
8113d85c:	00002306 	br	8113d8ec <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113d860:	e0bffe17 	ldw	r2,-8(fp)
8113d864:	1000051e 	bne	r2,zero,8113d87c <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113d868:	e0bfff17 	ldw	r2,-4(fp)
8113d86c:	00c01b84 	movi	r3,110
8113d870:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d874:	0005883a 	mov	r2,zero
8113d878:	00001c06 	br	8113d8ec <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113d87c:	e0bffe17 	ldw	r2,-8(fp)
8113d880:	10800003 	ldbu	r2,0(r2)
8113d884:	10803fcc 	andi	r2,r2,255
8113d888:	10800160 	cmpeqi	r2,r2,5
8113d88c:	1000051e 	bne	r2,zero,8113d8a4 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113d890:	e0bfff17 	ldw	r2,-4(fp)
8113d894:	00c00044 	movi	r3,1
8113d898:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d89c:	0005883a 	mov	r2,zero
8113d8a0:	00001206 	br	8113d8ec <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d8a4:	0005303a 	rdctl	r2,status
8113d8a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d8ac:	e0fffc17 	ldw	r3,-16(fp)
8113d8b0:	00bfff84 	movi	r2,-2
8113d8b4:	1884703a 	and	r2,r3,r2
8113d8b8:	1001703a 	wrctl	status,r2
  
  return context;
8113d8bc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d8c0:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113d8c4:	e0bffe17 	ldw	r2,-8(fp)
8113d8c8:	1080020b 	ldhu	r2,8(r2)
8113d8cc:	e0bffb0d 	sth	r2,-20(fp)
8113d8d0:	e0bffa17 	ldw	r2,-24(fp)
8113d8d4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d8d8:	e0bffd17 	ldw	r2,-12(fp)
8113d8dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d8e0:	e0bfff17 	ldw	r2,-4(fp)
8113d8e4:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113d8e8:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113d8ec:	e037883a 	mov	sp,fp
8113d8f0:	df000017 	ldw	fp,0(sp)
8113d8f4:	dec00104 	addi	sp,sp,4
8113d8f8:	f800283a 	ret

8113d8fc <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113d8fc:	defff804 	addi	sp,sp,-32
8113d900:	de00012e 	bgeu	sp,et,8113d908 <OS_FlagBlock+0xc>
8113d904:	003b68fa 	trap	3
8113d908:	df000715 	stw	fp,28(sp)
8113d90c:	df000704 	addi	fp,sp,28
8113d910:	e13ffb15 	stw	r4,-20(fp)
8113d914:	e17ffc15 	stw	r5,-16(fp)
8113d918:	3009883a 	mov	r4,r6
8113d91c:	3807883a 	mov	r3,r7
8113d920:	e0800117 	ldw	r2,4(fp)
8113d924:	e13ffd0d 	sth	r4,-12(fp)
8113d928:	e0fffe05 	stb	r3,-8(fp)
8113d92c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113d930:	d0a0a217 	ldw	r2,-32120(gp)
8113d934:	d0e0a217 	ldw	r3,-32120(gp)
8113d938:	18c00c03 	ldbu	r3,48(r3)
8113d93c:	18c00814 	ori	r3,r3,32
8113d940:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113d944:	d0a0a217 	ldw	r2,-32120(gp)
8113d948:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113d94c:	d0a0a217 	ldw	r2,-32120(gp)
8113d950:	e0ffff0b 	ldhu	r3,-4(fp)
8113d954:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113d958:	d0a0a217 	ldw	r2,-32120(gp)
8113d95c:	e0fffc17 	ldw	r3,-16(fp)
8113d960:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113d964:	e0bffc17 	ldw	r2,-16(fp)
8113d968:	e0fffd0b 	ldhu	r3,-12(fp)
8113d96c:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113d970:	e0bffc17 	ldw	r2,-16(fp)
8113d974:	e0fffe03 	ldbu	r3,-8(fp)
8113d978:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113d97c:	d0e0a217 	ldw	r3,-32120(gp)
8113d980:	e0bffc17 	ldw	r2,-16(fp)
8113d984:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113d988:	e0bffb17 	ldw	r2,-20(fp)
8113d98c:	10c00117 	ldw	r3,4(r2)
8113d990:	e0bffc17 	ldw	r2,-16(fp)
8113d994:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113d998:	e0bffc17 	ldw	r2,-16(fp)
8113d99c:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113d9a0:	e0bffc17 	ldw	r2,-16(fp)
8113d9a4:	e0fffb17 	ldw	r3,-20(fp)
8113d9a8:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113d9ac:	e0bffb17 	ldw	r2,-20(fp)
8113d9b0:	10800117 	ldw	r2,4(r2)
8113d9b4:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113d9b8:	e0bff917 	ldw	r2,-28(fp)
8113d9bc:	10000326 	beq	r2,zero,8113d9cc <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113d9c0:	e0bff917 	ldw	r2,-28(fp)
8113d9c4:	e0fffc17 	ldw	r3,-16(fp)
8113d9c8:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113d9cc:	e0bffb17 	ldw	r2,-20(fp)
8113d9d0:	e0fffc17 	ldw	r3,-16(fp)
8113d9d4:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113d9d8:	d0a0a217 	ldw	r2,-32120(gp)
8113d9dc:	10800d03 	ldbu	r2,52(r2)
8113d9e0:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113d9e4:	e0fffa03 	ldbu	r3,-24(fp)
8113d9e8:	e13ffa03 	ldbu	r4,-24(fp)
8113d9ec:	d0a09e44 	addi	r2,gp,-32135
8113d9f0:	2085883a 	add	r2,r4,r2
8113d9f4:	10800003 	ldbu	r2,0(r2)
8113d9f8:	1009883a 	mov	r4,r2
8113d9fc:	d0a0a217 	ldw	r2,-32120(gp)
8113da00:	10800d43 	ldbu	r2,53(r2)
8113da04:	0084303a 	nor	r2,zero,r2
8113da08:	2084703a 	and	r2,r4,r2
8113da0c:	1009883a 	mov	r4,r2
8113da10:	d0a09e44 	addi	r2,gp,-32135
8113da14:	1885883a 	add	r2,r3,r2
8113da18:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113da1c:	e0fffa03 	ldbu	r3,-24(fp)
8113da20:	d0a09e44 	addi	r2,gp,-32135
8113da24:	1885883a 	add	r2,r3,r2
8113da28:	10800003 	ldbu	r2,0(r2)
8113da2c:	10803fcc 	andi	r2,r2,255
8113da30:	1000071e 	bne	r2,zero,8113da50 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113da34:	d0a0a217 	ldw	r2,-32120(gp)
8113da38:	10800d83 	ldbu	r2,54(r2)
8113da3c:	0084303a 	nor	r2,zero,r2
8113da40:	1007883a 	mov	r3,r2
8113da44:	d0a09e03 	ldbu	r2,-32136(gp)
8113da48:	1884703a 	and	r2,r3,r2
8113da4c:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113da50:	0001883a 	nop
8113da54:	e037883a 	mov	sp,fp
8113da58:	df000017 	ldw	fp,0(sp)
8113da5c:	dec00104 	addi	sp,sp,4
8113da60:	f800283a 	ret

8113da64 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113da64:	defffb04 	addi	sp,sp,-20
8113da68:	de00012e 	bgeu	sp,et,8113da70 <OS_FlagInit+0xc>
8113da6c:	003b68fa 	trap	3
8113da70:	dfc00415 	stw	ra,16(sp)
8113da74:	df000315 	stw	fp,12(sp)
8113da78:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113da7c:	01421004 	movi	r5,2112
8113da80:	012045f4 	movhi	r4,33047
8113da84:	21237204 	addi	r4,r4,-29240
8113da88:	113bb900 	call	8113bb90 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113da8c:	00a045f4 	movhi	r2,33047
8113da90:	10a37204 	addi	r2,r2,-29240
8113da94:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113da98:	00a045f4 	movhi	r2,33047
8113da9c:	10a37d04 	addi	r2,r2,-29196
8113daa0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113daa4:	e03ffd0d 	sth	zero,-12(fp)
8113daa8:	00001306 	br	8113daf8 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113daac:	e0bffe17 	ldw	r2,-8(fp)
8113dab0:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113dab4:	e0bffe17 	ldw	r2,-8(fp)
8113dab8:	e0ffff17 	ldw	r3,-4(fp)
8113dabc:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113dac0:	e0bffe17 	ldw	r2,-8(fp)
8113dac4:	00c00fc4 	movi	r3,63
8113dac8:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113dacc:	e0bffe17 	ldw	r2,-8(fp)
8113dad0:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113dad4:	e0bffe17 	ldw	r2,-8(fp)
8113dad8:	10800b04 	addi	r2,r2,44
8113dadc:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113dae0:	e0bfff17 	ldw	r2,-4(fp)
8113dae4:	10800b04 	addi	r2,r2,44
8113dae8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113daec:	e0bffd0b 	ldhu	r2,-12(fp)
8113daf0:	10800044 	addi	r2,r2,1
8113daf4:	e0bffd0d 	sth	r2,-12(fp)
8113daf8:	e0bffd0b 	ldhu	r2,-12(fp)
8113dafc:	10800bf0 	cmpltui	r2,r2,47
8113db00:	103fea1e 	bne	r2,zero,8113daac <__reset+0xfb11daac>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113db04:	e0bffe17 	ldw	r2,-8(fp)
8113db08:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113db0c:	e0bffe17 	ldw	r2,-8(fp)
8113db10:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113db14:	e0bffe17 	ldw	r2,-8(fp)
8113db18:	00c00fc4 	movi	r3,63
8113db1c:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113db20:	e0bffe17 	ldw	r2,-8(fp)
8113db24:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113db28:	00a045f4 	movhi	r2,33047
8113db2c:	10a37204 	addi	r2,r2,-29240
8113db30:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113db34:	0001883a 	nop
8113db38:	e037883a 	mov	sp,fp
8113db3c:	dfc00117 	ldw	ra,4(sp)
8113db40:	df000017 	ldw	fp,0(sp)
8113db44:	dec00204 	addi	sp,sp,8
8113db48:	f800283a 	ret

8113db4c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113db4c:	defffa04 	addi	sp,sp,-24
8113db50:	de00012e 	bgeu	sp,et,8113db58 <OS_FlagTaskRdy+0xc>
8113db54:	003b68fa 	trap	3
8113db58:	dfc00515 	stw	ra,20(sp)
8113db5c:	df000415 	stw	fp,16(sp)
8113db60:	df000404 	addi	fp,sp,16
8113db64:	e13ffe15 	stw	r4,-8(fp)
8113db68:	2805883a 	mov	r2,r5
8113db6c:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113db70:	e0bffe17 	ldw	r2,-8(fp)
8113db74:	10800217 	ldw	r2,8(r2)
8113db78:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113db7c:	e0bffd17 	ldw	r2,-12(fp)
8113db80:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113db84:	e0bffd17 	ldw	r2,-12(fp)
8113db88:	e0ffff0b 	ldhu	r3,-4(fp)
8113db8c:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113db90:	e0bffd17 	ldw	r2,-12(fp)
8113db94:	10c00c03 	ldbu	r3,48(r2)
8113db98:	00bff7c4 	movi	r2,-33
8113db9c:	1884703a 	and	r2,r3,r2
8113dba0:	1007883a 	mov	r3,r2
8113dba4:	e0bffd17 	ldw	r2,-12(fp)
8113dba8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113dbac:	e0bffd17 	ldw	r2,-12(fp)
8113dbb0:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113dbb4:	e0bffd17 	ldw	r2,-12(fp)
8113dbb8:	10800c03 	ldbu	r2,48(r2)
8113dbbc:	10803fcc 	andi	r2,r2,255
8113dbc0:	1000181e 	bne	r2,zero,8113dc24 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113dbc4:	e0bffd17 	ldw	r2,-12(fp)
8113dbc8:	10c00d83 	ldbu	r3,54(r2)
8113dbcc:	d0a09e03 	ldbu	r2,-32136(gp)
8113dbd0:	1884b03a 	or	r2,r3,r2
8113dbd4:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113dbd8:	e0bffd17 	ldw	r2,-12(fp)
8113dbdc:	10800d03 	ldbu	r2,52(r2)
8113dbe0:	10c03fcc 	andi	r3,r2,255
8113dbe4:	e0bffd17 	ldw	r2,-12(fp)
8113dbe8:	10800d03 	ldbu	r2,52(r2)
8113dbec:	11003fcc 	andi	r4,r2,255
8113dbf0:	d0a09e44 	addi	r2,gp,-32135
8113dbf4:	2085883a 	add	r2,r4,r2
8113dbf8:	11000003 	ldbu	r4,0(r2)
8113dbfc:	e0bffd17 	ldw	r2,-12(fp)
8113dc00:	10800d43 	ldbu	r2,53(r2)
8113dc04:	2084b03a 	or	r2,r4,r2
8113dc08:	1009883a 	mov	r4,r2
8113dc0c:	d0a09e44 	addi	r2,gp,-32135
8113dc10:	1885883a 	add	r2,r3,r2
8113dc14:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113dc18:	00800044 	movi	r2,1
8113dc1c:	e0bffc05 	stb	r2,-16(fp)
8113dc20:	00000106 	br	8113dc28 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113dc24:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113dc28:	e13ffe17 	ldw	r4,-8(fp)
8113dc2c:	113dc480 	call	8113dc48 <OS_FlagUnlink>
    return (sched);
8113dc30:	e0bffc03 	ldbu	r2,-16(fp)
}
8113dc34:	e037883a 	mov	sp,fp
8113dc38:	dfc00117 	ldw	ra,4(sp)
8113dc3c:	df000017 	ldw	fp,0(sp)
8113dc40:	dec00204 	addi	sp,sp,8
8113dc44:	f800283a 	ret

8113dc48 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113dc48:	defffa04 	addi	sp,sp,-24
8113dc4c:	de00012e 	bgeu	sp,et,8113dc54 <OS_FlagUnlink+0xc>
8113dc50:	003b68fa 	trap	3
8113dc54:	df000515 	stw	fp,20(sp)
8113dc58:	df000504 	addi	fp,sp,20
8113dc5c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113dc60:	e0bfff17 	ldw	r2,-4(fp)
8113dc64:	10800117 	ldw	r2,4(r2)
8113dc68:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113dc6c:	e0bfff17 	ldw	r2,-4(fp)
8113dc70:	10800017 	ldw	r2,0(r2)
8113dc74:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113dc78:	e0bffb17 	ldw	r2,-20(fp)
8113dc7c:	10000b1e 	bne	r2,zero,8113dcac <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113dc80:	e0bfff17 	ldw	r2,-4(fp)
8113dc84:	10800317 	ldw	r2,12(r2)
8113dc88:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113dc8c:	e0bffd17 	ldw	r2,-12(fp)
8113dc90:	e0fffc17 	ldw	r3,-16(fp)
8113dc94:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113dc98:	e0bffc17 	ldw	r2,-16(fp)
8113dc9c:	10000b26 	beq	r2,zero,8113dccc <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113dca0:	e0bffc17 	ldw	r2,-16(fp)
8113dca4:	10000115 	stw	zero,4(r2)
8113dca8:	00000806 	br	8113dccc <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113dcac:	e0bffb17 	ldw	r2,-20(fp)
8113dcb0:	e0fffc17 	ldw	r3,-16(fp)
8113dcb4:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113dcb8:	e0bffc17 	ldw	r2,-16(fp)
8113dcbc:	10000326 	beq	r2,zero,8113dccc <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113dcc0:	e0bffc17 	ldw	r2,-16(fp)
8113dcc4:	e0fffb17 	ldw	r3,-20(fp)
8113dcc8:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113dccc:	e0bfff17 	ldw	r2,-4(fp)
8113dcd0:	10800217 	ldw	r2,8(r2)
8113dcd4:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113dcd8:	e0bffe17 	ldw	r2,-8(fp)
8113dcdc:	10000a15 	stw	zero,40(r2)
#endif
}
8113dce0:	0001883a 	nop
8113dce4:	e037883a 	mov	sp,fp
8113dce8:	df000017 	ldw	fp,0(sp)
8113dcec:	dec00104 	addi	sp,sp,4
8113dcf0:	f800283a 	ret

8113dcf4 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113dcf4:	defff404 	addi	sp,sp,-48
8113dcf8:	de00012e 	bgeu	sp,et,8113dd00 <OSMemCreate+0xc>
8113dcfc:	003b68fa 	trap	3
8113dd00:	df000b15 	stw	fp,44(sp)
8113dd04:	df000b04 	addi	fp,sp,44
8113dd08:	e13ffc15 	stw	r4,-16(fp)
8113dd0c:	e17ffd15 	stw	r5,-12(fp)
8113dd10:	e1bffe15 	stw	r6,-8(fp)
8113dd14:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113dd18:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113dd1c:	e0bfff17 	ldw	r2,-4(fp)
8113dd20:	1000021e 	bne	r2,zero,8113dd2c <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113dd24:	0005883a 	mov	r2,zero
8113dd28:	00006506 	br	8113dec0 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113dd2c:	e0bffc17 	ldw	r2,-16(fp)
8113dd30:	1000051e 	bne	r2,zero,8113dd48 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113dd34:	e0bfff17 	ldw	r2,-4(fp)
8113dd38:	00c01884 	movi	r3,98
8113dd3c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113dd40:	0005883a 	mov	r2,zero
8113dd44:	00005e06 	br	8113dec0 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113dd48:	e0bffc17 	ldw	r2,-16(fp)
8113dd4c:	108000cc 	andi	r2,r2,3
8113dd50:	10000526 	beq	r2,zero,8113dd68 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113dd54:	e0bfff17 	ldw	r2,-4(fp)
8113dd58:	00c01884 	movi	r3,98
8113dd5c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113dd60:	0005883a 	mov	r2,zero
8113dd64:	00005606 	br	8113dec0 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113dd68:	e0bffd17 	ldw	r2,-12(fp)
8113dd6c:	108000a8 	cmpgeui	r2,r2,2
8113dd70:	1000051e 	bne	r2,zero,8113dd88 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113dd74:	e0bfff17 	ldw	r2,-4(fp)
8113dd78:	00c016c4 	movi	r3,91
8113dd7c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113dd80:	0005883a 	mov	r2,zero
8113dd84:	00004e06 	br	8113dec0 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113dd88:	e0bffe17 	ldw	r2,-8(fp)
8113dd8c:	10800128 	cmpgeui	r2,r2,4
8113dd90:	1000051e 	bne	r2,zero,8113dda8 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113dd94:	e0bfff17 	ldw	r2,-4(fp)
8113dd98:	00c01704 	movi	r3,92
8113dd9c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113dda0:	0005883a 	mov	r2,zero
8113dda4:	00004606 	br	8113dec0 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dda8:	0005303a 	rdctl	r2,status
8113ddac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ddb0:	e0fffb17 	ldw	r3,-20(fp)
8113ddb4:	00bfff84 	movi	r2,-2
8113ddb8:	1884703a 	and	r2,r3,r2
8113ddbc:	1001703a 	wrctl	status,r2
  
  return context;
8113ddc0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113ddc4:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113ddc8:	d0a09b17 	ldw	r2,-32148(gp)
8113ddcc:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113ddd0:	d0a09b17 	ldw	r2,-32148(gp)
8113ddd4:	10000326 	beq	r2,zero,8113dde4 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113ddd8:	d0a09b17 	ldw	r2,-32148(gp)
8113dddc:	10800117 	ldw	r2,4(r2)
8113dde0:	d0a09b15 	stw	r2,-32148(gp)
8113dde4:	e0bff817 	ldw	r2,-32(fp)
8113dde8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ddec:	e0bff917 	ldw	r2,-28(fp)
8113ddf0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113ddf4:	e0bffa17 	ldw	r2,-24(fp)
8113ddf8:	1000051e 	bne	r2,zero,8113de10 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113ddfc:	e0bfff17 	ldw	r2,-4(fp)
8113de00:	00c01684 	movi	r3,90
8113de04:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113de08:	0005883a 	mov	r2,zero
8113de0c:	00002c06 	br	8113dec0 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113de10:	e0bffc17 	ldw	r2,-16(fp)
8113de14:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113de18:	e0fffc17 	ldw	r3,-16(fp)
8113de1c:	e0bffe17 	ldw	r2,-8(fp)
8113de20:	1885883a 	add	r2,r3,r2
8113de24:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113de28:	e03ff715 	stw	zero,-36(fp)
8113de2c:	00000c06 	br	8113de60 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113de30:	e0bff617 	ldw	r2,-40(fp)
8113de34:	e0fff517 	ldw	r3,-44(fp)
8113de38:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113de3c:	e0bff517 	ldw	r2,-44(fp)
8113de40:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113de44:	e0fff517 	ldw	r3,-44(fp)
8113de48:	e0bffe17 	ldw	r2,-8(fp)
8113de4c:	1885883a 	add	r2,r3,r2
8113de50:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113de54:	e0bff717 	ldw	r2,-36(fp)
8113de58:	10800044 	addi	r2,r2,1
8113de5c:	e0bff715 	stw	r2,-36(fp)
8113de60:	e0bffd17 	ldw	r2,-12(fp)
8113de64:	10bfffc4 	addi	r2,r2,-1
8113de68:	e0fff717 	ldw	r3,-36(fp)
8113de6c:	18bff036 	bltu	r3,r2,8113de30 <__reset+0xfb11de30>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113de70:	e0bff617 	ldw	r2,-40(fp)
8113de74:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113de78:	e0bffa17 	ldw	r2,-24(fp)
8113de7c:	e0fffc17 	ldw	r3,-16(fp)
8113de80:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113de84:	e0bffa17 	ldw	r2,-24(fp)
8113de88:	e0fffc17 	ldw	r3,-16(fp)
8113de8c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113de90:	e0bffa17 	ldw	r2,-24(fp)
8113de94:	e0fffd17 	ldw	r3,-12(fp)
8113de98:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113de9c:	e0bffa17 	ldw	r2,-24(fp)
8113dea0:	e0fffd17 	ldw	r3,-12(fp)
8113dea4:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113dea8:	e0bffa17 	ldw	r2,-24(fp)
8113deac:	e0fffe17 	ldw	r3,-8(fp)
8113deb0:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113deb4:	e0bfff17 	ldw	r2,-4(fp)
8113deb8:	10000005 	stb	zero,0(r2)
    return (pmem);
8113debc:	e0bffa17 	ldw	r2,-24(fp)
}
8113dec0:	e037883a 	mov	sp,fp
8113dec4:	df000017 	ldw	fp,0(sp)
8113dec8:	dec00104 	addi	sp,sp,4
8113decc:	f800283a 	ret

8113ded0 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113ded0:	defff804 	addi	sp,sp,-32
8113ded4:	de00012e 	bgeu	sp,et,8113dedc <OSMemGet+0xc>
8113ded8:	003b68fa 	trap	3
8113dedc:	df000715 	stw	fp,28(sp)
8113dee0:	df000704 	addi	fp,sp,28
8113dee4:	e13ffe15 	stw	r4,-8(fp)
8113dee8:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113deec:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113def0:	e0bfff17 	ldw	r2,-4(fp)
8113def4:	1000021e 	bne	r2,zero,8113df00 <OSMemGet+0x30>
        return ((void *)0);
8113def8:	0005883a 	mov	r2,zero
8113defc:	00002e06 	br	8113dfb8 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113df00:	e0bffe17 	ldw	r2,-8(fp)
8113df04:	1000051e 	bne	r2,zero,8113df1c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113df08:	e0bfff17 	ldw	r2,-4(fp)
8113df0c:	00c01804 	movi	r3,96
8113df10:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113df14:	0005883a 	mov	r2,zero
8113df18:	00002706 	br	8113dfb8 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113df1c:	0005303a 	rdctl	r2,status
8113df20:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113df24:	e0fffd17 	ldw	r3,-12(fp)
8113df28:	00bfff84 	movi	r2,-2
8113df2c:	1884703a 	and	r2,r3,r2
8113df30:	1001703a 	wrctl	status,r2
  
  return context;
8113df34:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113df38:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113df3c:	e0bffe17 	ldw	r2,-8(fp)
8113df40:	10800417 	ldw	r2,16(r2)
8113df44:	10001426 	beq	r2,zero,8113df98 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113df48:	e0bffe17 	ldw	r2,-8(fp)
8113df4c:	10800117 	ldw	r2,4(r2)
8113df50:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113df54:	e0bffb17 	ldw	r2,-20(fp)
8113df58:	10c00017 	ldw	r3,0(r2)
8113df5c:	e0bffe17 	ldw	r2,-8(fp)
8113df60:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113df64:	e0bffe17 	ldw	r2,-8(fp)
8113df68:	10800417 	ldw	r2,16(r2)
8113df6c:	10ffffc4 	addi	r3,r2,-1
8113df70:	e0bffe17 	ldw	r2,-8(fp)
8113df74:	10c00415 	stw	r3,16(r2)
8113df78:	e0bff917 	ldw	r2,-28(fp)
8113df7c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113df80:	e0bffa17 	ldw	r2,-24(fp)
8113df84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113df88:	e0bfff17 	ldw	r2,-4(fp)
8113df8c:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113df90:	e0bffb17 	ldw	r2,-20(fp)
8113df94:	00000806 	br	8113dfb8 <OSMemGet+0xe8>
8113df98:	e0bff917 	ldw	r2,-28(fp)
8113df9c:	e0bffc15 	stw	r2,-16(fp)
8113dfa0:	e0bffc17 	ldw	r2,-16(fp)
8113dfa4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113dfa8:	e0bfff17 	ldw	r2,-4(fp)
8113dfac:	00c01744 	movi	r3,93
8113dfb0:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113dfb4:	0005883a 	mov	r2,zero
}
8113dfb8:	e037883a 	mov	sp,fp
8113dfbc:	df000017 	ldw	fp,0(sp)
8113dfc0:	dec00104 	addi	sp,sp,4
8113dfc4:	f800283a 	ret

8113dfc8 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113dfc8:	defff704 	addi	sp,sp,-36
8113dfcc:	de00012e 	bgeu	sp,et,8113dfd4 <OSMemNameGet+0xc>
8113dfd0:	003b68fa 	trap	3
8113dfd4:	dfc00815 	stw	ra,32(sp)
8113dfd8:	df000715 	stw	fp,28(sp)
8113dfdc:	df000704 	addi	fp,sp,28
8113dfe0:	e13ffd15 	stw	r4,-12(fp)
8113dfe4:	e17ffe15 	stw	r5,-8(fp)
8113dfe8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113dfec:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113dff0:	e0bfff17 	ldw	r2,-4(fp)
8113dff4:	1000021e 	bne	r2,zero,8113e000 <OSMemNameGet+0x38>
        return (0);
8113dff8:	0005883a 	mov	r2,zero
8113dffc:	00002b06 	br	8113e0ac <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113e000:	e0bffd17 	ldw	r2,-12(fp)
8113e004:	1000051e 	bne	r2,zero,8113e01c <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113e008:	e0bfff17 	ldw	r2,-4(fp)
8113e00c:	00c01804 	movi	r3,96
8113e010:	10c00005 	stb	r3,0(r2)
        return (0);
8113e014:	0005883a 	mov	r2,zero
8113e018:	00002406 	br	8113e0ac <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113e01c:	e0bffe17 	ldw	r2,-8(fp)
8113e020:	1000051e 	bne	r2,zero,8113e038 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113e024:	e0bfff17 	ldw	r2,-4(fp)
8113e028:	00c00304 	movi	r3,12
8113e02c:	10c00005 	stb	r3,0(r2)
        return (0);
8113e030:	0005883a 	mov	r2,zero
8113e034:	00001d06 	br	8113e0ac <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113e038:	d0a0a103 	ldbu	r2,-32124(gp)
8113e03c:	10803fcc 	andi	r2,r2,255
8113e040:	10000526 	beq	r2,zero,8113e058 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113e044:	e0bfff17 	ldw	r2,-4(fp)
8113e048:	00c00444 	movi	r3,17
8113e04c:	10c00005 	stb	r3,0(r2)
        return (0);
8113e050:	0005883a 	mov	r2,zero
8113e054:	00001506 	br	8113e0ac <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e058:	0005303a 	rdctl	r2,status
8113e05c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e060:	e0fffb17 	ldw	r3,-20(fp)
8113e064:	00bfff84 	movi	r2,-2
8113e068:	1884703a 	and	r2,r3,r2
8113e06c:	1001703a 	wrctl	status,r2
  
  return context;
8113e070:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113e074:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113e078:	e0bffd17 	ldw	r2,-12(fp)
8113e07c:	10800504 	addi	r2,r2,20
8113e080:	100b883a 	mov	r5,r2
8113e084:	e13ffe17 	ldw	r4,-8(fp)
8113e088:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8113e08c:	e0bffa05 	stb	r2,-24(fp)
8113e090:	e0bff917 	ldw	r2,-28(fp)
8113e094:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e098:	e0bffc17 	ldw	r2,-16(fp)
8113e09c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e0a0:	e0bfff17 	ldw	r2,-4(fp)
8113e0a4:	10000005 	stb	zero,0(r2)
    return (len);
8113e0a8:	e0bffa03 	ldbu	r2,-24(fp)
}
8113e0ac:	e037883a 	mov	sp,fp
8113e0b0:	dfc00117 	ldw	ra,4(sp)
8113e0b4:	df000017 	ldw	fp,0(sp)
8113e0b8:	dec00204 	addi	sp,sp,8
8113e0bc:	f800283a 	ret

8113e0c0 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113e0c0:	defff604 	addi	sp,sp,-40
8113e0c4:	de00012e 	bgeu	sp,et,8113e0cc <OSMemNameSet+0xc>
8113e0c8:	003b68fa 	trap	3
8113e0cc:	dfc00915 	stw	ra,36(sp)
8113e0d0:	df000815 	stw	fp,32(sp)
8113e0d4:	df000804 	addi	fp,sp,32
8113e0d8:	e13ffd15 	stw	r4,-12(fp)
8113e0dc:	e17ffe15 	stw	r5,-8(fp)
8113e0e0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e0e4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113e0e8:	e0bfff17 	ldw	r2,-4(fp)
8113e0ec:	10003526 	beq	r2,zero,8113e1c4 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113e0f0:	e0bffd17 	ldw	r2,-12(fp)
8113e0f4:	1000041e 	bne	r2,zero,8113e108 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113e0f8:	e0bfff17 	ldw	r2,-4(fp)
8113e0fc:	00c01804 	movi	r3,96
8113e100:	10c00005 	stb	r3,0(r2)
        return;
8113e104:	00003006 	br	8113e1c8 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113e108:	e0bffe17 	ldw	r2,-8(fp)
8113e10c:	1000041e 	bne	r2,zero,8113e120 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113e110:	e0bfff17 	ldw	r2,-4(fp)
8113e114:	00c00304 	movi	r3,12
8113e118:	10c00005 	stb	r3,0(r2)
        return;
8113e11c:	00002a06 	br	8113e1c8 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113e120:	d0a0a103 	ldbu	r2,-32124(gp)
8113e124:	10803fcc 	andi	r2,r2,255
8113e128:	10000426 	beq	r2,zero,8113e13c <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113e12c:	e0bfff17 	ldw	r2,-4(fp)
8113e130:	00c00484 	movi	r3,18
8113e134:	10c00005 	stb	r3,0(r2)
        return;
8113e138:	00002306 	br	8113e1c8 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e13c:	0005303a 	rdctl	r2,status
8113e140:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e144:	e0fffc17 	ldw	r3,-16(fp)
8113e148:	00bfff84 	movi	r2,-2
8113e14c:	1884703a 	and	r2,r3,r2
8113e150:	1001703a 	wrctl	status,r2
  
  return context;
8113e154:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e158:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113e15c:	e13ffe17 	ldw	r4,-8(fp)
8113e160:	113be2c0 	call	8113be2c <OS_StrLen>
8113e164:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113e168:	e0bffa03 	ldbu	r2,-24(fp)
8113e16c:	10800830 	cmpltui	r2,r2,32
8113e170:	1000081e 	bne	r2,zero,8113e194 <OSMemNameSet+0xd4>
8113e174:	e0bff817 	ldw	r2,-32(fp)
8113e178:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e17c:	e0bff917 	ldw	r2,-28(fp)
8113e180:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113e184:	e0bfff17 	ldw	r2,-4(fp)
8113e188:	00c018c4 	movi	r3,99
8113e18c:	10c00005 	stb	r3,0(r2)
        return;
8113e190:	00000d06 	br	8113e1c8 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113e194:	e0bffd17 	ldw	r2,-12(fp)
8113e198:	10800504 	addi	r2,r2,20
8113e19c:	e17ffe17 	ldw	r5,-8(fp)
8113e1a0:	1009883a 	mov	r4,r2
8113e1a4:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8113e1a8:	e0bff817 	ldw	r2,-32(fp)
8113e1ac:	e0bffb15 	stw	r2,-20(fp)
8113e1b0:	e0bffb17 	ldw	r2,-20(fp)
8113e1b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e1b8:	e0bfff17 	ldw	r2,-4(fp)
8113e1bc:	10000005 	stb	zero,0(r2)
8113e1c0:	00000106 	br	8113e1c8 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113e1c4:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113e1c8:	e037883a 	mov	sp,fp
8113e1cc:	dfc00117 	ldw	ra,4(sp)
8113e1d0:	df000017 	ldw	fp,0(sp)
8113e1d4:	dec00204 	addi	sp,sp,8
8113e1d8:	f800283a 	ret

8113e1dc <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113e1dc:	defff904 	addi	sp,sp,-28
8113e1e0:	de00012e 	bgeu	sp,et,8113e1e8 <OSMemPut+0xc>
8113e1e4:	003b68fa 	trap	3
8113e1e8:	df000615 	stw	fp,24(sp)
8113e1ec:	df000604 	addi	fp,sp,24
8113e1f0:	e13ffe15 	stw	r4,-8(fp)
8113e1f4:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e1f8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113e1fc:	e0bffe17 	ldw	r2,-8(fp)
8113e200:	1000021e 	bne	r2,zero,8113e20c <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113e204:	00801804 	movi	r2,96
8113e208:	00002806 	br	8113e2ac <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113e20c:	e0bfff17 	ldw	r2,-4(fp)
8113e210:	1000021e 	bne	r2,zero,8113e21c <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113e214:	008017c4 	movi	r2,95
8113e218:	00002406 	br	8113e2ac <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e21c:	0005303a 	rdctl	r2,status
8113e220:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e224:	e0fffd17 	ldw	r3,-12(fp)
8113e228:	00bfff84 	movi	r2,-2
8113e22c:	1884703a 	and	r2,r3,r2
8113e230:	1001703a 	wrctl	status,r2
  
  return context;
8113e234:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113e238:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113e23c:	e0bffe17 	ldw	r2,-8(fp)
8113e240:	10c00417 	ldw	r3,16(r2)
8113e244:	e0bffe17 	ldw	r2,-8(fp)
8113e248:	10800317 	ldw	r2,12(r2)
8113e24c:	18800636 	bltu	r3,r2,8113e268 <OSMemPut+0x8c>
8113e250:	e0bffa17 	ldw	r2,-24(fp)
8113e254:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e258:	e0bffb17 	ldw	r2,-20(fp)
8113e25c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113e260:	00801784 	movi	r2,94
8113e264:	00001106 	br	8113e2ac <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113e268:	e0bffe17 	ldw	r2,-8(fp)
8113e26c:	10c00117 	ldw	r3,4(r2)
8113e270:	e0bfff17 	ldw	r2,-4(fp)
8113e274:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113e278:	e0bffe17 	ldw	r2,-8(fp)
8113e27c:	e0ffff17 	ldw	r3,-4(fp)
8113e280:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113e284:	e0bffe17 	ldw	r2,-8(fp)
8113e288:	10800417 	ldw	r2,16(r2)
8113e28c:	10c00044 	addi	r3,r2,1
8113e290:	e0bffe17 	ldw	r2,-8(fp)
8113e294:	10c00415 	stw	r3,16(r2)
8113e298:	e0bffa17 	ldw	r2,-24(fp)
8113e29c:	e0bffc15 	stw	r2,-16(fp)
8113e2a0:	e0bffc17 	ldw	r2,-16(fp)
8113e2a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113e2a8:	0005883a 	mov	r2,zero
}
8113e2ac:	e037883a 	mov	sp,fp
8113e2b0:	df000017 	ldw	fp,0(sp)
8113e2b4:	dec00104 	addi	sp,sp,4
8113e2b8:	f800283a 	ret

8113e2bc <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113e2bc:	defffa04 	addi	sp,sp,-24
8113e2c0:	de00012e 	bgeu	sp,et,8113e2c8 <OSMemQuery+0xc>
8113e2c4:	003b68fa 	trap	3
8113e2c8:	df000515 	stw	fp,20(sp)
8113e2cc:	df000504 	addi	fp,sp,20
8113e2d0:	e13ffe15 	stw	r4,-8(fp)
8113e2d4:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e2d8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113e2dc:	e0bffe17 	ldw	r2,-8(fp)
8113e2e0:	1000021e 	bne	r2,zero,8113e2ec <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113e2e4:	00801804 	movi	r2,96
8113e2e8:	00002c06 	br	8113e39c <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113e2ec:	e0bfff17 	ldw	r2,-4(fp)
8113e2f0:	1000021e 	bne	r2,zero,8113e2fc <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113e2f4:	00801844 	movi	r2,97
8113e2f8:	00002806 	br	8113e39c <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e2fc:	0005303a 	rdctl	r2,status
8113e300:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e304:	e0fffc17 	ldw	r3,-16(fp)
8113e308:	00bfff84 	movi	r2,-2
8113e30c:	1884703a 	and	r2,r3,r2
8113e310:	1001703a 	wrctl	status,r2
  
  return context;
8113e314:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113e318:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113e31c:	e0bffe17 	ldw	r2,-8(fp)
8113e320:	10c00017 	ldw	r3,0(r2)
8113e324:	e0bfff17 	ldw	r2,-4(fp)
8113e328:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113e32c:	e0bffe17 	ldw	r2,-8(fp)
8113e330:	10c00117 	ldw	r3,4(r2)
8113e334:	e0bfff17 	ldw	r2,-4(fp)
8113e338:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113e33c:	e0bffe17 	ldw	r2,-8(fp)
8113e340:	10c00217 	ldw	r3,8(r2)
8113e344:	e0bfff17 	ldw	r2,-4(fp)
8113e348:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113e34c:	e0bffe17 	ldw	r2,-8(fp)
8113e350:	10c00317 	ldw	r3,12(r2)
8113e354:	e0bfff17 	ldw	r2,-4(fp)
8113e358:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113e35c:	e0bffe17 	ldw	r2,-8(fp)
8113e360:	10c00417 	ldw	r3,16(r2)
8113e364:	e0bfff17 	ldw	r2,-4(fp)
8113e368:	10c00415 	stw	r3,16(r2)
8113e36c:	e0bffb17 	ldw	r2,-20(fp)
8113e370:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e374:	e0bffd17 	ldw	r2,-12(fp)
8113e378:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113e37c:	e0bfff17 	ldw	r2,-4(fp)
8113e380:	10c00317 	ldw	r3,12(r2)
8113e384:	e0bfff17 	ldw	r2,-4(fp)
8113e388:	10800417 	ldw	r2,16(r2)
8113e38c:	1887c83a 	sub	r3,r3,r2
8113e390:	e0bfff17 	ldw	r2,-4(fp)
8113e394:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113e398:	0005883a 	mov	r2,zero
}
8113e39c:	e037883a 	mov	sp,fp
8113e3a0:	df000017 	ldw	fp,0(sp)
8113e3a4:	dec00104 	addi	sp,sp,4
8113e3a8:	f800283a 	ret

8113e3ac <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113e3ac:	defffc04 	addi	sp,sp,-16
8113e3b0:	de00012e 	bgeu	sp,et,8113e3b8 <OS_MemInit+0xc>
8113e3b4:	003b68fa 	trap	3
8113e3b8:	dfc00315 	stw	ra,12(sp)
8113e3bc:	df000215 	stw	fp,8(sp)
8113e3c0:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113e3c4:	01430c04 	movi	r5,3120
8113e3c8:	012045f4 	movhi	r4,33047
8113e3cc:	2125ea04 	addi	r4,r4,-26712
8113e3d0:	113bb900 	call	8113bb90 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113e3d4:	00a045f4 	movhi	r2,33047
8113e3d8:	10a5ea04 	addi	r2,r2,-26712
8113e3dc:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113e3e0:	e03fff0d 	sth	zero,-4(fp)
8113e3e4:	00001306 	br	8113e434 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113e3e8:	e0bfff0b 	ldhu	r2,-4(fp)
8113e3ec:	10800044 	addi	r2,r2,1
8113e3f0:	10c00d24 	muli	r3,r2,52
8113e3f4:	00a045f4 	movhi	r2,33047
8113e3f8:	10a5ea04 	addi	r2,r2,-26712
8113e3fc:	1887883a 	add	r3,r3,r2
8113e400:	e0bffe17 	ldw	r2,-8(fp)
8113e404:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113e408:	e0bffe17 	ldw	r2,-8(fp)
8113e40c:	00c00fc4 	movi	r3,63
8113e410:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113e414:	e0bffe17 	ldw	r2,-8(fp)
8113e418:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113e41c:	e0bffe17 	ldw	r2,-8(fp)
8113e420:	10800d04 	addi	r2,r2,52
8113e424:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113e428:	e0bfff0b 	ldhu	r2,-4(fp)
8113e42c:	10800044 	addi	r2,r2,1
8113e430:	e0bfff0d 	sth	r2,-4(fp)
8113e434:	e0bfff0b 	ldhu	r2,-4(fp)
8113e438:	10800ef0 	cmpltui	r2,r2,59
8113e43c:	103fea1e 	bne	r2,zero,8113e3e8 <__reset+0xfb11e3e8>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113e440:	e0bffe17 	ldw	r2,-8(fp)
8113e444:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113e448:	e0bffe17 	ldw	r2,-8(fp)
8113e44c:	00c00fc4 	movi	r3,63
8113e450:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113e454:	e0bffe17 	ldw	r2,-8(fp)
8113e458:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113e45c:	00a045f4 	movhi	r2,33047
8113e460:	10a5ea04 	addi	r2,r2,-26712
8113e464:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113e468:	0001883a 	nop
8113e46c:	e037883a 	mov	sp,fp
8113e470:	dfc00117 	ldw	ra,4(sp)
8113e474:	df000017 	ldw	fp,0(sp)
8113e478:	dec00204 	addi	sp,sp,8
8113e47c:	f800283a 	ret

8113e480 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113e480:	defff704 	addi	sp,sp,-36
8113e484:	de00012e 	bgeu	sp,et,8113e48c <OSMutexAccept+0xc>
8113e488:	003b68fa 	trap	3
8113e48c:	df000815 	stw	fp,32(sp)
8113e490:	df000804 	addi	fp,sp,32
8113e494:	e13ffe15 	stw	r4,-8(fp)
8113e498:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113e49c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113e4a0:	e0bfff17 	ldw	r2,-4(fp)
8113e4a4:	1000021e 	bne	r2,zero,8113e4b0 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113e4a8:	0005883a 	mov	r2,zero
8113e4ac:	00005b06 	br	8113e61c <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113e4b0:	e0bffe17 	ldw	r2,-8(fp)
8113e4b4:	1000051e 	bne	r2,zero,8113e4cc <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e4b8:	e0bfff17 	ldw	r2,-4(fp)
8113e4bc:	00c00104 	movi	r3,4
8113e4c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e4c4:	0005883a 	mov	r2,zero
8113e4c8:	00005406 	br	8113e61c <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113e4cc:	e0bffe17 	ldw	r2,-8(fp)
8113e4d0:	10800003 	ldbu	r2,0(r2)
8113e4d4:	10803fcc 	andi	r2,r2,255
8113e4d8:	10800120 	cmpeqi	r2,r2,4
8113e4dc:	1000051e 	bne	r2,zero,8113e4f4 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113e4e0:	e0bfff17 	ldw	r2,-4(fp)
8113e4e4:	00c00044 	movi	r3,1
8113e4e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e4ec:	0005883a 	mov	r2,zero
8113e4f0:	00004a06 	br	8113e61c <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113e4f4:	d0a0a103 	ldbu	r2,-32124(gp)
8113e4f8:	10803fcc 	andi	r2,r2,255
8113e4fc:	10000526 	beq	r2,zero,8113e514 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113e500:	e0bfff17 	ldw	r2,-4(fp)
8113e504:	00c00084 	movi	r3,2
8113e508:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e50c:	0005883a 	mov	r2,zero
8113e510:	00004206 	br	8113e61c <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e514:	0005303a 	rdctl	r2,status
8113e518:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e51c:	e0fffd17 	ldw	r3,-12(fp)
8113e520:	00bfff84 	movi	r2,-2
8113e524:	1884703a 	and	r2,r3,r2
8113e528:	1001703a 	wrctl	status,r2
  
  return context;
8113e52c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113e530:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113e534:	e0bffe17 	ldw	r2,-8(fp)
8113e538:	1080020b 	ldhu	r2,8(r2)
8113e53c:	10bfffcc 	andi	r2,r2,65535
8113e540:	1004d23a 	srli	r2,r2,8
8113e544:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113e548:	e0bffe17 	ldw	r2,-8(fp)
8113e54c:	1080020b 	ldhu	r2,8(r2)
8113e550:	10bfffcc 	andi	r2,r2,65535
8113e554:	10803fcc 	andi	r2,r2,255
8113e558:	10803fd8 	cmpnei	r2,r2,255
8113e55c:	1000281e 	bne	r2,zero,8113e600 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113e560:	e0bffe17 	ldw	r2,-8(fp)
8113e564:	10c0020b 	ldhu	r3,8(r2)
8113e568:	00bfc004 	movi	r2,-256
8113e56c:	1884703a 	and	r2,r3,r2
8113e570:	1007883a 	mov	r3,r2
8113e574:	e0bffe17 	ldw	r2,-8(fp)
8113e578:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113e57c:	e0bffe17 	ldw	r2,-8(fp)
8113e580:	10c0020b 	ldhu	r3,8(r2)
8113e584:	d0a0a217 	ldw	r2,-32120(gp)
8113e588:	10800c83 	ldbu	r2,50(r2)
8113e58c:	10803fcc 	andi	r2,r2,255
8113e590:	1884b03a 	or	r2,r3,r2
8113e594:	1007883a 	mov	r3,r2
8113e598:	e0bffe17 	ldw	r2,-8(fp)
8113e59c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113e5a0:	d0e0a217 	ldw	r3,-32120(gp)
8113e5a4:	e0bffe17 	ldw	r2,-8(fp)
8113e5a8:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113e5ac:	d0a0a217 	ldw	r2,-32120(gp)
8113e5b0:	10800c83 	ldbu	r2,50(r2)
8113e5b4:	10803fcc 	andi	r2,r2,255
8113e5b8:	e0fffa03 	ldbu	r3,-24(fp)
8113e5bc:	18800836 	bltu	r3,r2,8113e5e0 <OSMutexAccept+0x160>
8113e5c0:	e0bff817 	ldw	r2,-32(fp)
8113e5c4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e5c8:	e0bff917 	ldw	r2,-28(fp)
8113e5cc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113e5d0:	e0bfff17 	ldw	r2,-4(fp)
8113e5d4:	00c01e04 	movi	r3,120
8113e5d8:	10c00005 	stb	r3,0(r2)
8113e5dc:	00000606 	br	8113e5f8 <OSMutexAccept+0x178>
8113e5e0:	e0bff817 	ldw	r2,-32(fp)
8113e5e4:	e0bffb15 	stw	r2,-20(fp)
8113e5e8:	e0bffb17 	ldw	r2,-20(fp)
8113e5ec:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113e5f0:	e0bfff17 	ldw	r2,-4(fp)
8113e5f4:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113e5f8:	00800044 	movi	r2,1
8113e5fc:	00000706 	br	8113e61c <OSMutexAccept+0x19c>
8113e600:	e0bff817 	ldw	r2,-32(fp)
8113e604:	e0bffc15 	stw	r2,-16(fp)
8113e608:	e0bffc17 	ldw	r2,-16(fp)
8113e60c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e610:	e0bfff17 	ldw	r2,-4(fp)
8113e614:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113e618:	0005883a 	mov	r2,zero
}
8113e61c:	e037883a 	mov	sp,fp
8113e620:	df000017 	ldw	fp,0(sp)
8113e624:	dec00104 	addi	sp,sp,4
8113e628:	f800283a 	ret

8113e62c <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113e62c:	defff604 	addi	sp,sp,-40
8113e630:	de00012e 	bgeu	sp,et,8113e638 <OSMutexCreate+0xc>
8113e634:	003b68fa 	trap	3
8113e638:	dfc00915 	stw	ra,36(sp)
8113e63c:	df000815 	stw	fp,32(sp)
8113e640:	df000804 	addi	fp,sp,32
8113e644:	2005883a 	mov	r2,r4
8113e648:	e17fff15 	stw	r5,-4(fp)
8113e64c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e650:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e654:	e0bfff17 	ldw	r2,-4(fp)
8113e658:	1000021e 	bne	r2,zero,8113e664 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113e65c:	0005883a 	mov	r2,zero
8113e660:	00006106 	br	8113e7e8 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113e664:	e0bffe03 	ldbu	r2,-8(fp)
8113e668:	10800ab0 	cmpltui	r2,r2,42
8113e66c:	1000051e 	bne	r2,zero,8113e684 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113e670:	e0bfff17 	ldw	r2,-4(fp)
8113e674:	00c00a84 	movi	r3,42
8113e678:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113e67c:	0005883a 	mov	r2,zero
8113e680:	00005906 	br	8113e7e8 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e684:	d0a0a103 	ldbu	r2,-32124(gp)
8113e688:	10803fcc 	andi	r2,r2,255
8113e68c:	10000526 	beq	r2,zero,8113e6a4 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113e690:	e0bfff17 	ldw	r2,-4(fp)
8113e694:	00c00404 	movi	r3,16
8113e698:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113e69c:	0005883a 	mov	r2,zero
8113e6a0:	00005106 	br	8113e7e8 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e6a4:	0005303a 	rdctl	r2,status
8113e6a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e6ac:	e0fffd17 	ldw	r3,-12(fp)
8113e6b0:	00bfff84 	movi	r2,-2
8113e6b4:	1884703a 	and	r2,r3,r2
8113e6b8:	1001703a 	wrctl	status,r2
  
  return context;
8113e6bc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e6c0:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113e6c4:	e0fffe03 	ldbu	r3,-8(fp)
8113e6c8:	00a045f4 	movhi	r2,33047
8113e6cc:	10bb6404 	addi	r2,r2,-4720
8113e6d0:	18c7883a 	add	r3,r3,r3
8113e6d4:	18c7883a 	add	r3,r3,r3
8113e6d8:	10c5883a 	add	r2,r2,r3
8113e6dc:	10800017 	ldw	r2,0(r2)
8113e6e0:	10000926 	beq	r2,zero,8113e708 <OSMutexCreate+0xdc>
8113e6e4:	e0bff817 	ldw	r2,-32(fp)
8113e6e8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e6ec:	e0bff917 	ldw	r2,-28(fp)
8113e6f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113e6f4:	e0bfff17 	ldw	r2,-4(fp)
8113e6f8:	00c00a04 	movi	r3,40
8113e6fc:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113e700:	0005883a 	mov	r2,zero
8113e704:	00003806 	br	8113e7e8 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113e708:	e0fffe03 	ldbu	r3,-8(fp)
8113e70c:	00a045f4 	movhi	r2,33047
8113e710:	10bb6404 	addi	r2,r2,-4720
8113e714:	18c7883a 	add	r3,r3,r3
8113e718:	18c7883a 	add	r3,r3,r3
8113e71c:	10c5883a 	add	r2,r2,r3
8113e720:	00c00044 	movi	r3,1
8113e724:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113e728:	d0a0a017 	ldw	r2,-32128(gp)
8113e72c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113e730:	e0bffb17 	ldw	r2,-20(fp)
8113e734:	1000101e 	bne	r2,zero,8113e778 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113e738:	e0fffe03 	ldbu	r3,-8(fp)
8113e73c:	00a045f4 	movhi	r2,33047
8113e740:	10bb6404 	addi	r2,r2,-4720
8113e744:	18c7883a 	add	r3,r3,r3
8113e748:	18c7883a 	add	r3,r3,r3
8113e74c:	10c5883a 	add	r2,r2,r3
8113e750:	10000015 	stw	zero,0(r2)
8113e754:	e0bff817 	ldw	r2,-32(fp)
8113e758:	e0bffa15 	stw	r2,-24(fp)
8113e75c:	e0bffa17 	ldw	r2,-24(fp)
8113e760:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113e764:	e0bfff17 	ldw	r2,-4(fp)
8113e768:	00c00104 	movi	r3,4
8113e76c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e770:	e0bffb17 	ldw	r2,-20(fp)
8113e774:	00001c06 	br	8113e7e8 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113e778:	d0a0a017 	ldw	r2,-32128(gp)
8113e77c:	10800117 	ldw	r2,4(r2)
8113e780:	d0a0a015 	stw	r2,-32128(gp)
8113e784:	e0bff817 	ldw	r2,-32(fp)
8113e788:	e0bffc15 	stw	r2,-16(fp)
8113e78c:	e0bffc17 	ldw	r2,-16(fp)
8113e790:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113e794:	e0bffb17 	ldw	r2,-20(fp)
8113e798:	00c00104 	movi	r3,4
8113e79c:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113e7a0:	e0bffe03 	ldbu	r2,-8(fp)
8113e7a4:	1004923a 	slli	r2,r2,8
8113e7a8:	10803fd4 	ori	r2,r2,255
8113e7ac:	1007883a 	mov	r3,r2
8113e7b0:	e0bffb17 	ldw	r2,-20(fp)
8113e7b4:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113e7b8:	e0bffb17 	ldw	r2,-20(fp)
8113e7bc:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113e7c0:	e0bffb17 	ldw	r2,-20(fp)
8113e7c4:	00c00fc4 	movi	r3,63
8113e7c8:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113e7cc:	e0bffb17 	ldw	r2,-20(fp)
8113e7d0:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113e7d4:	e13ffb17 	ldw	r4,-20(fp)
8113e7d8:	113b7780 	call	8113b778 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113e7dc:	e0bfff17 	ldw	r2,-4(fp)
8113e7e0:	10000005 	stb	zero,0(r2)
    return (pevent);
8113e7e4:	e0bffb17 	ldw	r2,-20(fp)
}
8113e7e8:	e037883a 	mov	sp,fp
8113e7ec:	dfc00117 	ldw	ra,4(sp)
8113e7f0:	df000017 	ldw	fp,0(sp)
8113e7f4:	dec00204 	addi	sp,sp,8
8113e7f8:	f800283a 	ret

8113e7fc <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113e7fc:	defff004 	addi	sp,sp,-64
8113e800:	de00012e 	bgeu	sp,et,8113e808 <OSMutexDel+0xc>
8113e804:	003b68fa 	trap	3
8113e808:	dfc00f15 	stw	ra,60(sp)
8113e80c:	df000e15 	stw	fp,56(sp)
8113e810:	df000e04 	addi	fp,sp,56
8113e814:	e13ffd15 	stw	r4,-12(fp)
8113e818:	2805883a 	mov	r2,r5
8113e81c:	e1bfff15 	stw	r6,-4(fp)
8113e820:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e824:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e828:	e0bfff17 	ldw	r2,-4(fp)
8113e82c:	1000021e 	bne	r2,zero,8113e838 <OSMutexDel+0x3c>
        return (pevent);
8113e830:	e0bffd17 	ldw	r2,-12(fp)
8113e834:	0000ad06 	br	8113eaec <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e838:	e0bffd17 	ldw	r2,-12(fp)
8113e83c:	1000051e 	bne	r2,zero,8113e854 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113e840:	e0bfff17 	ldw	r2,-4(fp)
8113e844:	00c00104 	movi	r3,4
8113e848:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e84c:	e0bffd17 	ldw	r2,-12(fp)
8113e850:	0000a606 	br	8113eaec <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113e854:	e0bffd17 	ldw	r2,-12(fp)
8113e858:	10800003 	ldbu	r2,0(r2)
8113e85c:	10803fcc 	andi	r2,r2,255
8113e860:	10800120 	cmpeqi	r2,r2,4
8113e864:	1000051e 	bne	r2,zero,8113e87c <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113e868:	e0bfff17 	ldw	r2,-4(fp)
8113e86c:	00c00044 	movi	r3,1
8113e870:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e874:	e0bffd17 	ldw	r2,-12(fp)
8113e878:	00009c06 	br	8113eaec <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e87c:	d0a0a103 	ldbu	r2,-32124(gp)
8113e880:	10803fcc 	andi	r2,r2,255
8113e884:	10000526 	beq	r2,zero,8113e89c <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113e888:	e0bfff17 	ldw	r2,-4(fp)
8113e88c:	00c003c4 	movi	r3,15
8113e890:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e894:	e0bffd17 	ldw	r2,-12(fp)
8113e898:	00009406 	br	8113eaec <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e89c:	0005303a 	rdctl	r2,status
8113e8a0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e8a4:	e0fffc17 	ldw	r3,-16(fp)
8113e8a8:	00bfff84 	movi	r2,-2
8113e8ac:	1884703a 	and	r2,r3,r2
8113e8b0:	1001703a 	wrctl	status,r2
  
  return context;
8113e8b4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e8b8:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113e8bc:	e0bffd17 	ldw	r2,-12(fp)
8113e8c0:	10800283 	ldbu	r2,10(r2)
8113e8c4:	10803fcc 	andi	r2,r2,255
8113e8c8:	10000326 	beq	r2,zero,8113e8d8 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113e8cc:	00800044 	movi	r2,1
8113e8d0:	e0bff205 	stb	r2,-56(fp)
8113e8d4:	00000106 	br	8113e8dc <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113e8d8:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113e8dc:	e0bffe03 	ldbu	r2,-8(fp)
8113e8e0:	10000326 	beq	r2,zero,8113e8f0 <OSMutexDel+0xf4>
8113e8e4:	10800060 	cmpeqi	r2,r2,1
8113e8e8:	10002f1e 	bne	r2,zero,8113e9a8 <OSMutexDel+0x1ac>
8113e8ec:	00007406 	br	8113eac0 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113e8f0:	e0bff203 	ldbu	r2,-56(fp)
8113e8f4:	1000221e 	bne	r2,zero,8113e980 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113e8f8:	e0bffd17 	ldw	r2,-12(fp)
8113e8fc:	00c00fc4 	movi	r3,63
8113e900:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113e904:	e0bffd17 	ldw	r2,-12(fp)
8113e908:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113e90c:	e0bffd17 	ldw	r2,-12(fp)
8113e910:	1080020b 	ldhu	r2,8(r2)
8113e914:	10bfffcc 	andi	r2,r2,65535
8113e918:	1004d23a 	srli	r2,r2,8
8113e91c:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113e920:	e0fff603 	ldbu	r3,-40(fp)
8113e924:	00a045f4 	movhi	r2,33047
8113e928:	10bb6404 	addi	r2,r2,-4720
8113e92c:	18c7883a 	add	r3,r3,r3
8113e930:	18c7883a 	add	r3,r3,r3
8113e934:	10c5883a 	add	r2,r2,r3
8113e938:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113e93c:	e0bffd17 	ldw	r2,-12(fp)
8113e940:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113e944:	d0e0a017 	ldw	r3,-32128(gp)
8113e948:	e0bffd17 	ldw	r2,-12(fp)
8113e94c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113e950:	e0bffd17 	ldw	r2,-12(fp)
8113e954:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113e958:	e0bffd17 	ldw	r2,-12(fp)
8113e95c:	d0a0a015 	stw	r2,-32128(gp)
8113e960:	e0bff417 	ldw	r2,-48(fp)
8113e964:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e968:	e0bff517 	ldw	r2,-44(fp)
8113e96c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113e970:	e0bfff17 	ldw	r2,-4(fp)
8113e974:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113e978:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113e97c:	00005a06 	br	8113eae8 <OSMutexDel+0x2ec>
8113e980:	e0bff417 	ldw	r2,-48(fp)
8113e984:	e0bff715 	stw	r2,-36(fp)
8113e988:	e0bff717 	ldw	r2,-36(fp)
8113e98c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113e990:	e0bfff17 	ldw	r2,-4(fp)
8113e994:	00c01244 	movi	r3,73
8113e998:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113e99c:	e0bffd17 	ldw	r2,-12(fp)
8113e9a0:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113e9a4:	00005006 	br	8113eae8 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113e9a8:	e0bffd17 	ldw	r2,-12(fp)
8113e9ac:	1080020b 	ldhu	r2,8(r2)
8113e9b0:	10bfffcc 	andi	r2,r2,65535
8113e9b4:	1004d23a 	srli	r2,r2,8
8113e9b8:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113e9bc:	e0bffd17 	ldw	r2,-12(fp)
8113e9c0:	1080020b 	ldhu	r2,8(r2)
8113e9c4:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113e9c8:	e0bffd17 	ldw	r2,-12(fp)
8113e9cc:	10800117 	ldw	r2,4(r2)
8113e9d0:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113e9d4:	e0bffa17 	ldw	r2,-24(fp)
8113e9d8:	10000f26 	beq	r2,zero,8113ea18 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113e9dc:	e0bffa17 	ldw	r2,-24(fp)
8113e9e0:	10800c83 	ldbu	r2,50(r2)
8113e9e4:	10c03fcc 	andi	r3,r2,255
8113e9e8:	e0bff603 	ldbu	r2,-40(fp)
8113e9ec:	18800a1e 	bne	r3,r2,8113ea18 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113e9f0:	e0bff903 	ldbu	r2,-28(fp)
8113e9f4:	100b883a 	mov	r5,r2
8113e9f8:	e13ffa17 	ldw	r4,-24(fp)
8113e9fc:	113f4380 	call	8113f438 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113ea00:	00000506 	br	8113ea18 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113ea04:	000f883a 	mov	r7,zero
8113ea08:	01800404 	movi	r6,16
8113ea0c:	000b883a 	mov	r5,zero
8113ea10:	e13ffd17 	ldw	r4,-12(fp)
8113ea14:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113ea18:	e0bffd17 	ldw	r2,-12(fp)
8113ea1c:	10800283 	ldbu	r2,10(r2)
8113ea20:	10803fcc 	andi	r2,r2,255
8113ea24:	103ff71e 	bne	r2,zero,8113ea04 <__reset+0xfb11ea04>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113ea28:	e0bffd17 	ldw	r2,-12(fp)
8113ea2c:	00c00fc4 	movi	r3,63
8113ea30:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113ea34:	e0bffd17 	ldw	r2,-12(fp)
8113ea38:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113ea3c:	e0bffd17 	ldw	r2,-12(fp)
8113ea40:	1080020b 	ldhu	r2,8(r2)
8113ea44:	10bfffcc 	andi	r2,r2,65535
8113ea48:	1004d23a 	srli	r2,r2,8
8113ea4c:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113ea50:	e0fff603 	ldbu	r3,-40(fp)
8113ea54:	00a045f4 	movhi	r2,33047
8113ea58:	10bb6404 	addi	r2,r2,-4720
8113ea5c:	18c7883a 	add	r3,r3,r3
8113ea60:	18c7883a 	add	r3,r3,r3
8113ea64:	10c5883a 	add	r2,r2,r3
8113ea68:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113ea6c:	e0bffd17 	ldw	r2,-12(fp)
8113ea70:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113ea74:	d0e0a017 	ldw	r3,-32128(gp)
8113ea78:	e0bffd17 	ldw	r2,-12(fp)
8113ea7c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113ea80:	e0bffd17 	ldw	r2,-12(fp)
8113ea84:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113ea88:	e0bffd17 	ldw	r2,-12(fp)
8113ea8c:	d0a0a015 	stw	r2,-32128(gp)
8113ea90:	e0bff417 	ldw	r2,-48(fp)
8113ea94:	e0bff815 	stw	r2,-32(fp)
8113ea98:	e0bff817 	ldw	r2,-32(fp)
8113ea9c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113eaa0:	e0bff203 	ldbu	r2,-56(fp)
8113eaa4:	10800058 	cmpnei	r2,r2,1
8113eaa8:	1000011e 	bne	r2,zero,8113eab0 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113eaac:	113bc5c0 	call	8113bc5c <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113eab0:	e0bfff17 	ldw	r2,-4(fp)
8113eab4:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113eab8:	e03ff315 	stw	zero,-52(fp)
             break;
8113eabc:	00000a06 	br	8113eae8 <OSMutexDel+0x2ec>
8113eac0:	e0bff417 	ldw	r2,-48(fp)
8113eac4:	e0bffb15 	stw	r2,-20(fp)
8113eac8:	e0bffb17 	ldw	r2,-20(fp)
8113eacc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113ead0:	e0bfff17 	ldw	r2,-4(fp)
8113ead4:	00c001c4 	movi	r3,7
8113ead8:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113eadc:	e0bffd17 	ldw	r2,-12(fp)
8113eae0:	e0bff315 	stw	r2,-52(fp)
             break;
8113eae4:	0001883a 	nop
    }
    return (pevent_return);
8113eae8:	e0bff317 	ldw	r2,-52(fp)
}
8113eaec:	e037883a 	mov	sp,fp
8113eaf0:	dfc00117 	ldw	ra,4(sp)
8113eaf4:	df000017 	ldw	fp,0(sp)
8113eaf8:	dec00204 	addi	sp,sp,8
8113eafc:	f800283a 	ret

8113eb00 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113eb00:	deffee04 	addi	sp,sp,-72
8113eb04:	de00012e 	bgeu	sp,et,8113eb0c <OSMutexPend+0xc>
8113eb08:	003b68fa 	trap	3
8113eb0c:	dfc01115 	stw	ra,68(sp)
8113eb10:	df001015 	stw	fp,64(sp)
8113eb14:	df001004 	addi	fp,sp,64
8113eb18:	e13ffd15 	stw	r4,-12(fp)
8113eb1c:	2805883a 	mov	r2,r5
8113eb20:	e1bfff15 	stw	r6,-4(fp)
8113eb24:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113eb28:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113eb2c:	e0bfff17 	ldw	r2,-4(fp)
8113eb30:	10015626 	beq	r2,zero,8113f08c <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113eb34:	e0bffd17 	ldw	r2,-12(fp)
8113eb38:	1000041e 	bne	r2,zero,8113eb4c <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113eb3c:	e0bfff17 	ldw	r2,-4(fp)
8113eb40:	00c00104 	movi	r3,4
8113eb44:	10c00005 	stb	r3,0(r2)
        return;
8113eb48:	00015106 	br	8113f090 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113eb4c:	e0bffd17 	ldw	r2,-12(fp)
8113eb50:	10800003 	ldbu	r2,0(r2)
8113eb54:	10803fcc 	andi	r2,r2,255
8113eb58:	10800120 	cmpeqi	r2,r2,4
8113eb5c:	1000041e 	bne	r2,zero,8113eb70 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113eb60:	e0bfff17 	ldw	r2,-4(fp)
8113eb64:	00c00044 	movi	r3,1
8113eb68:	10c00005 	stb	r3,0(r2)
        return;
8113eb6c:	00014806 	br	8113f090 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113eb70:	d0a0a103 	ldbu	r2,-32124(gp)
8113eb74:	10803fcc 	andi	r2,r2,255
8113eb78:	10000426 	beq	r2,zero,8113eb8c <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113eb7c:	e0bfff17 	ldw	r2,-4(fp)
8113eb80:	00c00084 	movi	r3,2
8113eb84:	10c00005 	stb	r3,0(r2)
        return;
8113eb88:	00014106 	br	8113f090 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113eb8c:	d0a08f03 	ldbu	r2,-32196(gp)
8113eb90:	10803fcc 	andi	r2,r2,255
8113eb94:	10000426 	beq	r2,zero,8113eba8 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113eb98:	e0bfff17 	ldw	r2,-4(fp)
8113eb9c:	00c00344 	movi	r3,13
8113eba0:	10c00005 	stb	r3,0(r2)
        return;
8113eba4:	00013a06 	br	8113f090 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113eba8:	0005303a 	rdctl	r2,status
8113ebac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ebb0:	e0fffc17 	ldw	r3,-16(fp)
8113ebb4:	00bfff84 	movi	r2,-2
8113ebb8:	1884703a 	and	r2,r3,r2
8113ebbc:	1001703a 	wrctl	status,r2
  
  return context;
8113ebc0:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113ebc4:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113ebc8:	e0bffd17 	ldw	r2,-12(fp)
8113ebcc:	1080020b 	ldhu	r2,8(r2)
8113ebd0:	10bfffcc 	andi	r2,r2,65535
8113ebd4:	1004d23a 	srli	r2,r2,8
8113ebd8:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113ebdc:	e0bffd17 	ldw	r2,-12(fp)
8113ebe0:	1080020b 	ldhu	r2,8(r2)
8113ebe4:	10803fcc 	andi	r2,r2,255
8113ebe8:	10803fd8 	cmpnei	r2,r2,255
8113ebec:	1000271e 	bne	r2,zero,8113ec8c <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113ebf0:	e0bffd17 	ldw	r2,-12(fp)
8113ebf4:	10c0020b 	ldhu	r3,8(r2)
8113ebf8:	00bfc004 	movi	r2,-256
8113ebfc:	1884703a 	and	r2,r3,r2
8113ec00:	1007883a 	mov	r3,r2
8113ec04:	e0bffd17 	ldw	r2,-12(fp)
8113ec08:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113ec0c:	e0bffd17 	ldw	r2,-12(fp)
8113ec10:	10c0020b 	ldhu	r3,8(r2)
8113ec14:	d0a0a217 	ldw	r2,-32120(gp)
8113ec18:	10800c83 	ldbu	r2,50(r2)
8113ec1c:	10803fcc 	andi	r2,r2,255
8113ec20:	1884b03a 	or	r2,r3,r2
8113ec24:	1007883a 	mov	r3,r2
8113ec28:	e0bffd17 	ldw	r2,-12(fp)
8113ec2c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113ec30:	d0e0a217 	ldw	r3,-32120(gp)
8113ec34:	e0bffd17 	ldw	r2,-12(fp)
8113ec38:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113ec3c:	d0a0a217 	ldw	r2,-32120(gp)
8113ec40:	10800c83 	ldbu	r2,50(r2)
8113ec44:	10803fcc 	andi	r2,r2,255
8113ec48:	e0fff303 	ldbu	r3,-52(fp)
8113ec4c:	18800836 	bltu	r3,r2,8113ec70 <OSMutexPend+0x170>
8113ec50:	e0bff117 	ldw	r2,-60(fp)
8113ec54:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ec58:	e0bff217 	ldw	r2,-56(fp)
8113ec5c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113ec60:	e0bfff17 	ldw	r2,-4(fp)
8113ec64:	00c01e04 	movi	r3,120
8113ec68:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113ec6c:	00010806 	br	8113f090 <OSMutexPend+0x590>
8113ec70:	e0bff117 	ldw	r2,-60(fp)
8113ec74:	e0bff415 	stw	r2,-48(fp)
8113ec78:	e0bff417 	ldw	r2,-48(fp)
8113ec7c:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113ec80:	e0bfff17 	ldw	r2,-4(fp)
8113ec84:	10000005 	stb	zero,0(r2)
        }
        return;
8113ec88:	00010106 	br	8113f090 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113ec8c:	e0bffd17 	ldw	r2,-12(fp)
8113ec90:	1080020b 	ldhu	r2,8(r2)
8113ec94:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113ec98:	e0bffd17 	ldw	r2,-12(fp)
8113ec9c:	10800117 	ldw	r2,4(r2)
8113eca0:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113eca4:	e0bff717 	ldw	r2,-36(fp)
8113eca8:	10800c83 	ldbu	r2,50(r2)
8113ecac:	10803fcc 	andi	r2,r2,255
8113ecb0:	e0fff303 	ldbu	r3,-52(fp)
8113ecb4:	1880b92e 	bgeu	r3,r2,8113ef9c <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113ecb8:	d0a0a217 	ldw	r2,-32120(gp)
8113ecbc:	10800c83 	ldbu	r2,50(r2)
8113ecc0:	10c03fcc 	andi	r3,r2,255
8113ecc4:	e0bff603 	ldbu	r2,-40(fp)
8113ecc8:	1880b42e 	bgeu	r3,r2,8113ef9c <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113eccc:	e0bff717 	ldw	r2,-36(fp)
8113ecd0:	10800d03 	ldbu	r2,52(r2)
8113ecd4:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113ecd8:	e0fff803 	ldbu	r3,-32(fp)
8113ecdc:	d0a09e44 	addi	r2,gp,-32135
8113ece0:	1885883a 	add	r2,r3,r2
8113ece4:	10c00003 	ldbu	r3,0(r2)
8113ece8:	e0bff717 	ldw	r2,-36(fp)
8113ecec:	10800d43 	ldbu	r2,53(r2)
8113ecf0:	1884703a 	and	r2,r3,r2
8113ecf4:	10803fcc 	andi	r2,r2,255
8113ecf8:	10001e26 	beq	r2,zero,8113ed74 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113ecfc:	e0fff803 	ldbu	r3,-32(fp)
8113ed00:	e13ff803 	ldbu	r4,-32(fp)
8113ed04:	d0a09e44 	addi	r2,gp,-32135
8113ed08:	2085883a 	add	r2,r4,r2
8113ed0c:	10800003 	ldbu	r2,0(r2)
8113ed10:	1009883a 	mov	r4,r2
8113ed14:	e0bff717 	ldw	r2,-36(fp)
8113ed18:	10800d43 	ldbu	r2,53(r2)
8113ed1c:	0084303a 	nor	r2,zero,r2
8113ed20:	2084703a 	and	r2,r4,r2
8113ed24:	1009883a 	mov	r4,r2
8113ed28:	d0a09e44 	addi	r2,gp,-32135
8113ed2c:	1885883a 	add	r2,r3,r2
8113ed30:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113ed34:	e0fff803 	ldbu	r3,-32(fp)
8113ed38:	d0a09e44 	addi	r2,gp,-32135
8113ed3c:	1885883a 	add	r2,r3,r2
8113ed40:	10800003 	ldbu	r2,0(r2)
8113ed44:	10803fcc 	andi	r2,r2,255
8113ed48:	1000071e 	bne	r2,zero,8113ed68 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113ed4c:	e0bff717 	ldw	r2,-36(fp)
8113ed50:	10800d83 	ldbu	r2,54(r2)
8113ed54:	0084303a 	nor	r2,zero,r2
8113ed58:	1007883a 	mov	r3,r2
8113ed5c:	d0a09e03 	ldbu	r2,-32136(gp)
8113ed60:	1884703a 	and	r2,r3,r2
8113ed64:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113ed68:	00800044 	movi	r2,1
8113ed6c:	e0bff005 	stb	r2,-64(fp)
8113ed70:	00002a06 	br	8113ee1c <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113ed74:	e0bff717 	ldw	r2,-36(fp)
8113ed78:	10800717 	ldw	r2,28(r2)
8113ed7c:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113ed80:	e0bff917 	ldw	r2,-28(fp)
8113ed84:	10002426 	beq	r2,zero,8113ee18 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113ed88:	e0bff717 	ldw	r2,-36(fp)
8113ed8c:	10800d03 	ldbu	r2,52(r2)
8113ed90:	10803fcc 	andi	r2,r2,255
8113ed94:	e0fff717 	ldw	r3,-36(fp)
8113ed98:	18c00d03 	ldbu	r3,52(r3)
8113ed9c:	18c03fcc 	andi	r3,r3,255
8113eda0:	e13ff917 	ldw	r4,-28(fp)
8113eda4:	20c7883a 	add	r3,r4,r3
8113eda8:	18c002c4 	addi	r3,r3,11
8113edac:	18c00003 	ldbu	r3,0(r3)
8113edb0:	1809883a 	mov	r4,r3
8113edb4:	e0fff717 	ldw	r3,-36(fp)
8113edb8:	18c00d43 	ldbu	r3,53(r3)
8113edbc:	00c6303a 	nor	r3,zero,r3
8113edc0:	20c6703a 	and	r3,r4,r3
8113edc4:	1809883a 	mov	r4,r3
8113edc8:	e0fff917 	ldw	r3,-28(fp)
8113edcc:	1887883a 	add	r3,r3,r2
8113edd0:	18c002c4 	addi	r3,r3,11
8113edd4:	19000005 	stb	r4,0(r3)
8113edd8:	e0fff917 	ldw	r3,-28(fp)
8113eddc:	1885883a 	add	r2,r3,r2
8113ede0:	108002c4 	addi	r2,r2,11
8113ede4:	10800003 	ldbu	r2,0(r2)
8113ede8:	10803fcc 	andi	r2,r2,255
8113edec:	10000a1e 	bne	r2,zero,8113ee18 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113edf0:	e0bff917 	ldw	r2,-28(fp)
8113edf4:	10800283 	ldbu	r2,10(r2)
8113edf8:	1007883a 	mov	r3,r2
8113edfc:	e0bff717 	ldw	r2,-36(fp)
8113ee00:	10800d83 	ldbu	r2,54(r2)
8113ee04:	0084303a 	nor	r2,zero,r2
8113ee08:	1884703a 	and	r2,r3,r2
8113ee0c:	1007883a 	mov	r3,r2
8113ee10:	e0bff917 	ldw	r2,-28(fp)
8113ee14:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113ee18:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113ee1c:	e0bff717 	ldw	r2,-36(fp)
8113ee20:	e0fff303 	ldbu	r3,-52(fp)
8113ee24:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113ee28:	e0bff717 	ldw	r2,-36(fp)
8113ee2c:	10800c83 	ldbu	r2,50(r2)
8113ee30:	10803fcc 	andi	r2,r2,255
8113ee34:	1004d0fa 	srli	r2,r2,3
8113ee38:	1007883a 	mov	r3,r2
8113ee3c:	e0bff717 	ldw	r2,-36(fp)
8113ee40:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113ee44:	e0bff717 	ldw	r2,-36(fp)
8113ee48:	10800c83 	ldbu	r2,50(r2)
8113ee4c:	108001cc 	andi	r2,r2,7
8113ee50:	1007883a 	mov	r3,r2
8113ee54:	e0bff717 	ldw	r2,-36(fp)
8113ee58:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113ee5c:	e0bff717 	ldw	r2,-36(fp)
8113ee60:	10800d03 	ldbu	r2,52(r2)
8113ee64:	10803fcc 	andi	r2,r2,255
8113ee68:	00c00044 	movi	r3,1
8113ee6c:	1884983a 	sll	r2,r3,r2
8113ee70:	1007883a 	mov	r3,r2
8113ee74:	e0bff717 	ldw	r2,-36(fp)
8113ee78:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113ee7c:	e0bff717 	ldw	r2,-36(fp)
8113ee80:	10800cc3 	ldbu	r2,51(r2)
8113ee84:	10803fcc 	andi	r2,r2,255
8113ee88:	00c00044 	movi	r3,1
8113ee8c:	1884983a 	sll	r2,r3,r2
8113ee90:	1007883a 	mov	r3,r2
8113ee94:	e0bff717 	ldw	r2,-36(fp)
8113ee98:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113ee9c:	e0bff003 	ldbu	r2,-64(fp)
8113eea0:	10800058 	cmpnei	r2,r2,1
8113eea4:	1000161e 	bne	r2,zero,8113ef00 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113eea8:	e0bff717 	ldw	r2,-36(fp)
8113eeac:	10c00d83 	ldbu	r3,54(r2)
8113eeb0:	d0a09e03 	ldbu	r2,-32136(gp)
8113eeb4:	1884b03a 	or	r2,r3,r2
8113eeb8:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113eebc:	e0bff717 	ldw	r2,-36(fp)
8113eec0:	10800d03 	ldbu	r2,52(r2)
8113eec4:	10c03fcc 	andi	r3,r2,255
8113eec8:	e0bff717 	ldw	r2,-36(fp)
8113eecc:	10800d03 	ldbu	r2,52(r2)
8113eed0:	11003fcc 	andi	r4,r2,255
8113eed4:	d0a09e44 	addi	r2,gp,-32135
8113eed8:	2085883a 	add	r2,r4,r2
8113eedc:	11000003 	ldbu	r4,0(r2)
8113eee0:	e0bff717 	ldw	r2,-36(fp)
8113eee4:	10800d43 	ldbu	r2,53(r2)
8113eee8:	2084b03a 	or	r2,r4,r2
8113eeec:	1009883a 	mov	r4,r2
8113eef0:	d0a09e44 	addi	r2,gp,-32135
8113eef4:	1885883a 	add	r2,r3,r2
8113eef8:	11000005 	stb	r4,0(r2)
8113eefc:	00001f06 	br	8113ef7c <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113ef00:	e0bff717 	ldw	r2,-36(fp)
8113ef04:	10800717 	ldw	r2,28(r2)
8113ef08:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113ef0c:	e0bff917 	ldw	r2,-28(fp)
8113ef10:	10001a26 	beq	r2,zero,8113ef7c <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113ef14:	e0bff917 	ldw	r2,-28(fp)
8113ef18:	10c00283 	ldbu	r3,10(r2)
8113ef1c:	e0bff717 	ldw	r2,-36(fp)
8113ef20:	10800d83 	ldbu	r2,54(r2)
8113ef24:	1884b03a 	or	r2,r3,r2
8113ef28:	1007883a 	mov	r3,r2
8113ef2c:	e0bff917 	ldw	r2,-28(fp)
8113ef30:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ef34:	e0bff717 	ldw	r2,-36(fp)
8113ef38:	10800d03 	ldbu	r2,52(r2)
8113ef3c:	10803fcc 	andi	r2,r2,255
8113ef40:	e0fff717 	ldw	r3,-36(fp)
8113ef44:	18c00d03 	ldbu	r3,52(r3)
8113ef48:	18c03fcc 	andi	r3,r3,255
8113ef4c:	e13ff917 	ldw	r4,-28(fp)
8113ef50:	20c7883a 	add	r3,r4,r3
8113ef54:	18c002c4 	addi	r3,r3,11
8113ef58:	19000003 	ldbu	r4,0(r3)
8113ef5c:	e0fff717 	ldw	r3,-36(fp)
8113ef60:	18c00d43 	ldbu	r3,53(r3)
8113ef64:	20c6b03a 	or	r3,r4,r3
8113ef68:	1809883a 	mov	r4,r3
8113ef6c:	e0fff917 	ldw	r3,-28(fp)
8113ef70:	1885883a 	add	r2,r3,r2
8113ef74:	108002c4 	addi	r2,r2,11
8113ef78:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113ef7c:	e0fff303 	ldbu	r3,-52(fp)
8113ef80:	00a045f4 	movhi	r2,33047
8113ef84:	10bb6404 	addi	r2,r2,-4720
8113ef88:	18c7883a 	add	r3,r3,r3
8113ef8c:	18c7883a 	add	r3,r3,r3
8113ef90:	10c5883a 	add	r2,r2,r3
8113ef94:	e0fff717 	ldw	r3,-36(fp)
8113ef98:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113ef9c:	d0a0a217 	ldw	r2,-32120(gp)
8113efa0:	d0e0a217 	ldw	r3,-32120(gp)
8113efa4:	18c00c03 	ldbu	r3,48(r3)
8113efa8:	18c00414 	ori	r3,r3,16
8113efac:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113efb0:	d0a0a217 	ldw	r2,-32120(gp)
8113efb4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113efb8:	d0a0a217 	ldw	r2,-32120(gp)
8113efbc:	e0fffe0b 	ldhu	r3,-8(fp)
8113efc0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113efc4:	e13ffd17 	ldw	r4,-12(fp)
8113efc8:	113b3400 	call	8113b340 <OS_EventTaskWait>
8113efcc:	e0bff117 	ldw	r2,-60(fp)
8113efd0:	e0bffb15 	stw	r2,-20(fp)
8113efd4:	e0bffb17 	ldw	r2,-20(fp)
8113efd8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113efdc:	113bc5c0 	call	8113bc5c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113efe0:	0005303a 	rdctl	r2,status
8113efe4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113efe8:	e0fff517 	ldw	r3,-44(fp)
8113efec:	00bfff84 	movi	r2,-2
8113eff0:	1884703a 	and	r2,r3,r2
8113eff4:	1001703a 	wrctl	status,r2
  
  return context;
8113eff8:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113effc:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113f000:	d0a0a217 	ldw	r2,-32120(gp)
8113f004:	10800c43 	ldbu	r2,49(r2)
8113f008:	10803fcc 	andi	r2,r2,255
8113f00c:	10000326 	beq	r2,zero,8113f01c <OSMutexPend+0x51c>
8113f010:	108000a0 	cmpeqi	r2,r2,2
8113f014:	1000041e 	bne	r2,zero,8113f028 <OSMutexPend+0x528>
8113f018:	00000706 	br	8113f038 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113f01c:	e0bfff17 	ldw	r2,-4(fp)
8113f020:	10000005 	stb	zero,0(r2)
             break;
8113f024:	00000c06 	br	8113f058 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113f028:	e0bfff17 	ldw	r2,-4(fp)
8113f02c:	00c00384 	movi	r3,14
8113f030:	10c00005 	stb	r3,0(r2)
             break;
8113f034:	00000806 	br	8113f058 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113f038:	d0a0a217 	ldw	r2,-32120(gp)
8113f03c:	e17ffd17 	ldw	r5,-12(fp)
8113f040:	1009883a 	mov	r4,r2
8113f044:	113b5b00 	call	8113b5b0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113f048:	e0bfff17 	ldw	r2,-4(fp)
8113f04c:	00c00284 	movi	r3,10
8113f050:	10c00005 	stb	r3,0(r2)
             break;
8113f054:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113f058:	d0a0a217 	ldw	r2,-32120(gp)
8113f05c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113f060:	d0a0a217 	ldw	r2,-32120(gp)
8113f064:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113f068:	d0a0a217 	ldw	r2,-32120(gp)
8113f06c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113f070:	d0a0a217 	ldw	r2,-32120(gp)
8113f074:	10000815 	stw	zero,32(r2)
8113f078:	e0bff117 	ldw	r2,-60(fp)
8113f07c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f080:	e0bffa17 	ldw	r2,-24(fp)
8113f084:	1001703a 	wrctl	status,r2
8113f088:	00000106 	br	8113f090 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113f08c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113f090:	e037883a 	mov	sp,fp
8113f094:	dfc00117 	ldw	ra,4(sp)
8113f098:	df000017 	ldw	fp,0(sp)
8113f09c:	dec00204 	addi	sp,sp,8
8113f0a0:	f800283a 	ret

8113f0a4 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113f0a4:	defff604 	addi	sp,sp,-40
8113f0a8:	de00012e 	bgeu	sp,et,8113f0b0 <OSMutexPost+0xc>
8113f0ac:	003b68fa 	trap	3
8113f0b0:	dfc00915 	stw	ra,36(sp)
8113f0b4:	df000815 	stw	fp,32(sp)
8113f0b8:	df000804 	addi	fp,sp,32
8113f0bc:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f0c0:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113f0c4:	d0a0a103 	ldbu	r2,-32124(gp)
8113f0c8:	10803fcc 	andi	r2,r2,255
8113f0cc:	10000226 	beq	r2,zero,8113f0d8 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113f0d0:	00800144 	movi	r2,5
8113f0d4:	00007606 	br	8113f2b0 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f0d8:	e0bfff17 	ldw	r2,-4(fp)
8113f0dc:	1000021e 	bne	r2,zero,8113f0e8 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113f0e0:	00800104 	movi	r2,4
8113f0e4:	00007206 	br	8113f2b0 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113f0e8:	e0bfff17 	ldw	r2,-4(fp)
8113f0ec:	10800003 	ldbu	r2,0(r2)
8113f0f0:	10803fcc 	andi	r2,r2,255
8113f0f4:	10800120 	cmpeqi	r2,r2,4
8113f0f8:	1000021e 	bne	r2,zero,8113f104 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113f0fc:	00800044 	movi	r2,1
8113f100:	00006b06 	br	8113f2b0 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f104:	0005303a 	rdctl	r2,status
8113f108:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f10c:	e0fffe17 	ldw	r3,-8(fp)
8113f110:	00bfff84 	movi	r2,-2
8113f114:	1884703a 	and	r2,r3,r2
8113f118:	1001703a 	wrctl	status,r2
  
  return context;
8113f11c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113f120:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113f124:	e0bfff17 	ldw	r2,-4(fp)
8113f128:	1080020b 	ldhu	r2,8(r2)
8113f12c:	10bfffcc 	andi	r2,r2,65535
8113f130:	1004d23a 	srli	r2,r2,8
8113f134:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113f138:	e0bfff17 	ldw	r2,-4(fp)
8113f13c:	1080020b 	ldhu	r2,8(r2)
8113f140:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113f144:	e0bfff17 	ldw	r2,-4(fp)
8113f148:	10c00117 	ldw	r3,4(r2)
8113f14c:	d0a0a217 	ldw	r2,-32120(gp)
8113f150:	18800626 	beq	r3,r2,8113f16c <OSMutexPost+0xc8>
8113f154:	e0bff817 	ldw	r2,-32(fp)
8113f158:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f15c:	e0bff917 	ldw	r2,-28(fp)
8113f160:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113f164:	00801904 	movi	r2,100
8113f168:	00005106 	br	8113f2b0 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113f16c:	d0a0a217 	ldw	r2,-32120(gp)
8113f170:	10800c83 	ldbu	r2,50(r2)
8113f174:	10c03fcc 	andi	r3,r2,255
8113f178:	e0bffa03 	ldbu	r2,-24(fp)
8113f17c:	1880051e 	bne	r3,r2,8113f194 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113f180:	d0a0a217 	ldw	r2,-32120(gp)
8113f184:	e0fffa43 	ldbu	r3,-23(fp)
8113f188:	180b883a 	mov	r5,r3
8113f18c:	1009883a 	mov	r4,r2
8113f190:	113f4380 	call	8113f438 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113f194:	e0fffa03 	ldbu	r3,-24(fp)
8113f198:	00a045f4 	movhi	r2,33047
8113f19c:	10bb6404 	addi	r2,r2,-4720
8113f1a0:	18c7883a 	add	r3,r3,r3
8113f1a4:	18c7883a 	add	r3,r3,r3
8113f1a8:	10c5883a 	add	r2,r2,r3
8113f1ac:	00c00044 	movi	r3,1
8113f1b0:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113f1b4:	e0bfff17 	ldw	r2,-4(fp)
8113f1b8:	10800283 	ldbu	r2,10(r2)
8113f1bc:	10803fcc 	andi	r2,r2,255
8113f1c0:	10002e26 	beq	r2,zero,8113f27c <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113f1c4:	000f883a 	mov	r7,zero
8113f1c8:	01800404 	movi	r6,16
8113f1cc:	000b883a 	mov	r5,zero
8113f1d0:	e13fff17 	ldw	r4,-4(fp)
8113f1d4:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
8113f1d8:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113f1dc:	e0bfff17 	ldw	r2,-4(fp)
8113f1e0:	10c0020b 	ldhu	r3,8(r2)
8113f1e4:	00bfc004 	movi	r2,-256
8113f1e8:	1884703a 	and	r2,r3,r2
8113f1ec:	1007883a 	mov	r3,r2
8113f1f0:	e0bfff17 	ldw	r2,-4(fp)
8113f1f4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113f1f8:	e0bfff17 	ldw	r2,-4(fp)
8113f1fc:	10c0020b 	ldhu	r3,8(r2)
8113f200:	e0bffa43 	ldbu	r2,-23(fp)
8113f204:	1884b03a 	or	r2,r3,r2
8113f208:	1007883a 	mov	r3,r2
8113f20c:	e0bfff17 	ldw	r2,-4(fp)
8113f210:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113f214:	e0fffa43 	ldbu	r3,-23(fp)
8113f218:	00a045f4 	movhi	r2,33047
8113f21c:	10bb6404 	addi	r2,r2,-4720
8113f220:	18c7883a 	add	r3,r3,r3
8113f224:	18c7883a 	add	r3,r3,r3
8113f228:	10c5883a 	add	r2,r2,r3
8113f22c:	10c00017 	ldw	r3,0(r2)
8113f230:	e0bfff17 	ldw	r2,-4(fp)
8113f234:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113f238:	e0bffa43 	ldbu	r2,-23(fp)
8113f23c:	e0fffa03 	ldbu	r3,-24(fp)
8113f240:	18800736 	bltu	r3,r2,8113f260 <OSMutexPost+0x1bc>
8113f244:	e0bff817 	ldw	r2,-32(fp)
8113f248:	e0bffb15 	stw	r2,-20(fp)
8113f24c:	e0bffb17 	ldw	r2,-20(fp)
8113f250:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113f254:	113bc5c0 	call	8113bc5c <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113f258:	00801e04 	movi	r2,120
8113f25c:	00001406 	br	8113f2b0 <OSMutexPost+0x20c>
8113f260:	e0bff817 	ldw	r2,-32(fp)
8113f264:	e0bffc15 	stw	r2,-16(fp)
8113f268:	e0bffc17 	ldw	r2,-16(fp)
8113f26c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113f270:	113bc5c0 	call	8113bc5c <OS_Sched>
            return (OS_ERR_NONE);
8113f274:	0005883a 	mov	r2,zero
8113f278:	00000d06 	br	8113f2b0 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113f27c:	e0bfff17 	ldw	r2,-4(fp)
8113f280:	1080020b 	ldhu	r2,8(r2)
8113f284:	10803fd4 	ori	r2,r2,255
8113f288:	1007883a 	mov	r3,r2
8113f28c:	e0bfff17 	ldw	r2,-4(fp)
8113f290:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113f294:	e0bfff17 	ldw	r2,-4(fp)
8113f298:	10000115 	stw	zero,4(r2)
8113f29c:	e0bff817 	ldw	r2,-32(fp)
8113f2a0:	e0bffd15 	stw	r2,-12(fp)
8113f2a4:	e0bffd17 	ldw	r2,-12(fp)
8113f2a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f2ac:	0005883a 	mov	r2,zero
}
8113f2b0:	e037883a 	mov	sp,fp
8113f2b4:	dfc00117 	ldw	ra,4(sp)
8113f2b8:	df000017 	ldw	fp,0(sp)
8113f2bc:	dec00204 	addi	sp,sp,8
8113f2c0:	f800283a 	ret

8113f2c4 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113f2c4:	defff704 	addi	sp,sp,-36
8113f2c8:	de00012e 	bgeu	sp,et,8113f2d0 <OSMutexQuery+0xc>
8113f2cc:	003b68fa 	trap	3
8113f2d0:	df000815 	stw	fp,32(sp)
8113f2d4:	df000804 	addi	fp,sp,32
8113f2d8:	e13ffe15 	stw	r4,-8(fp)
8113f2dc:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f2e0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113f2e4:	d0a0a103 	ldbu	r2,-32124(gp)
8113f2e8:	10803fcc 	andi	r2,r2,255
8113f2ec:	10000226 	beq	r2,zero,8113f2f8 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113f2f0:	00800184 	movi	r2,6
8113f2f4:	00004c06 	br	8113f428 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113f2f8:	e0bffe17 	ldw	r2,-8(fp)
8113f2fc:	1000021e 	bne	r2,zero,8113f308 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113f300:	00800104 	movi	r2,4
8113f304:	00004806 	br	8113f428 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113f308:	e0bfff17 	ldw	r2,-4(fp)
8113f30c:	1000021e 	bne	r2,zero,8113f318 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113f310:	00800244 	movi	r2,9
8113f314:	00004406 	br	8113f428 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113f318:	e0bffe17 	ldw	r2,-8(fp)
8113f31c:	10800003 	ldbu	r2,0(r2)
8113f320:	10803fcc 	andi	r2,r2,255
8113f324:	10800120 	cmpeqi	r2,r2,4
8113f328:	1000021e 	bne	r2,zero,8113f334 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113f32c:	00800044 	movi	r2,1
8113f330:	00003d06 	br	8113f428 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f334:	0005303a 	rdctl	r2,status
8113f338:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f33c:	e0fffd17 	ldw	r3,-12(fp)
8113f340:	00bfff84 	movi	r2,-2
8113f344:	1884703a 	and	r2,r3,r2
8113f348:	1001703a 	wrctl	status,r2
  
  return context;
8113f34c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f350:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113f354:	e0bffe17 	ldw	r2,-8(fp)
8113f358:	1080020b 	ldhu	r2,8(r2)
8113f35c:	10bfffcc 	andi	r2,r2,65535
8113f360:	1004d23a 	srli	r2,r2,8
8113f364:	1007883a 	mov	r3,r2
8113f368:	e0bfff17 	ldw	r2,-4(fp)
8113f36c:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113f370:	e0bffe17 	ldw	r2,-8(fp)
8113f374:	1080020b 	ldhu	r2,8(r2)
8113f378:	1007883a 	mov	r3,r2
8113f37c:	e0bfff17 	ldw	r2,-4(fp)
8113f380:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113f384:	e0bfff17 	ldw	r2,-4(fp)
8113f388:	10800203 	ldbu	r2,8(r2)
8113f38c:	10803fcc 	andi	r2,r2,255
8113f390:	10803fd8 	cmpnei	r2,r2,255
8113f394:	1000041e 	bne	r2,zero,8113f3a8 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113f398:	e0bfff17 	ldw	r2,-4(fp)
8113f39c:	00c00044 	movi	r3,1
8113f3a0:	10c001c5 	stb	r3,7(r2)
8113f3a4:	00000206 	br	8113f3b0 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113f3a8:	e0bfff17 	ldw	r2,-4(fp)
8113f3ac:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113f3b0:	e0bffe17 	ldw	r2,-8(fp)
8113f3b4:	10c00283 	ldbu	r3,10(r2)
8113f3b8:	e0bfff17 	ldw	r2,-4(fp)
8113f3bc:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113f3c0:	e0bffe17 	ldw	r2,-8(fp)
8113f3c4:	108002c4 	addi	r2,r2,11
8113f3c8:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113f3cc:	e0bfff17 	ldw	r2,-4(fp)
8113f3d0:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f3d4:	e03ff805 	stb	zero,-32(fp)
8113f3d8:	00000b06 	br	8113f408 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113f3dc:	e0bffa17 	ldw	r2,-24(fp)
8113f3e0:	10c00044 	addi	r3,r2,1
8113f3e4:	e0fffa15 	stw	r3,-24(fp)
8113f3e8:	e0fff917 	ldw	r3,-28(fp)
8113f3ec:	19000044 	addi	r4,r3,1
8113f3f0:	e13ff915 	stw	r4,-28(fp)
8113f3f4:	18c00003 	ldbu	r3,0(r3)
8113f3f8:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f3fc:	e0bff803 	ldbu	r2,-32(fp)
8113f400:	10800044 	addi	r2,r2,1
8113f404:	e0bff805 	stb	r2,-32(fp)
8113f408:	e0bff803 	ldbu	r2,-32(fp)
8113f40c:	108001b0 	cmpltui	r2,r2,6
8113f410:	103ff21e 	bne	r2,zero,8113f3dc <__reset+0xfb11f3dc>
8113f414:	e0bffb17 	ldw	r2,-20(fp)
8113f418:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f41c:	e0bffc17 	ldw	r2,-16(fp)
8113f420:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f424:	0005883a 	mov	r2,zero
}
8113f428:	e037883a 	mov	sp,fp
8113f42c:	df000017 	ldw	fp,0(sp)
8113f430:	dec00104 	addi	sp,sp,4
8113f434:	f800283a 	ret

8113f438 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113f438:	defffc04 	addi	sp,sp,-16
8113f43c:	de00012e 	bgeu	sp,et,8113f444 <OSMutex_RdyAtPrio+0xc>
8113f440:	003b68fa 	trap	3
8113f444:	df000315 	stw	fp,12(sp)
8113f448:	df000304 	addi	fp,sp,12
8113f44c:	e13ffe15 	stw	r4,-8(fp)
8113f450:	2805883a 	mov	r2,r5
8113f454:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113f458:	e0bffe17 	ldw	r2,-8(fp)
8113f45c:	10800d03 	ldbu	r2,52(r2)
8113f460:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113f464:	e0fffd03 	ldbu	r3,-12(fp)
8113f468:	e13ffd03 	ldbu	r4,-12(fp)
8113f46c:	d0a09e44 	addi	r2,gp,-32135
8113f470:	2085883a 	add	r2,r4,r2
8113f474:	10800003 	ldbu	r2,0(r2)
8113f478:	1009883a 	mov	r4,r2
8113f47c:	e0bffe17 	ldw	r2,-8(fp)
8113f480:	10800d43 	ldbu	r2,53(r2)
8113f484:	0084303a 	nor	r2,zero,r2
8113f488:	2084703a 	and	r2,r4,r2
8113f48c:	1009883a 	mov	r4,r2
8113f490:	d0a09e44 	addi	r2,gp,-32135
8113f494:	1885883a 	add	r2,r3,r2
8113f498:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113f49c:	e0fffd03 	ldbu	r3,-12(fp)
8113f4a0:	d0a09e44 	addi	r2,gp,-32135
8113f4a4:	1885883a 	add	r2,r3,r2
8113f4a8:	10800003 	ldbu	r2,0(r2)
8113f4ac:	10803fcc 	andi	r2,r2,255
8113f4b0:	1000071e 	bne	r2,zero,8113f4d0 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113f4b4:	e0bffe17 	ldw	r2,-8(fp)
8113f4b8:	10800d83 	ldbu	r2,54(r2)
8113f4bc:	0084303a 	nor	r2,zero,r2
8113f4c0:	1007883a 	mov	r3,r2
8113f4c4:	d0a09e03 	ldbu	r2,-32136(gp)
8113f4c8:	1884703a 	and	r2,r3,r2
8113f4cc:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113f4d0:	e0bffe17 	ldw	r2,-8(fp)
8113f4d4:	e0ffff03 	ldbu	r3,-4(fp)
8113f4d8:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113f4dc:	e0bfff03 	ldbu	r2,-4(fp)
8113f4e0:	1004d0fa 	srli	r2,r2,3
8113f4e4:	108001cc 	andi	r2,r2,7
8113f4e8:	1007883a 	mov	r3,r2
8113f4ec:	e0bffe17 	ldw	r2,-8(fp)
8113f4f0:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113f4f4:	e0bfff03 	ldbu	r2,-4(fp)
8113f4f8:	108001cc 	andi	r2,r2,7
8113f4fc:	1007883a 	mov	r3,r2
8113f500:	e0bffe17 	ldw	r2,-8(fp)
8113f504:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113f508:	e0bffe17 	ldw	r2,-8(fp)
8113f50c:	10800d03 	ldbu	r2,52(r2)
8113f510:	10803fcc 	andi	r2,r2,255
8113f514:	00c00044 	movi	r3,1
8113f518:	1884983a 	sll	r2,r3,r2
8113f51c:	1007883a 	mov	r3,r2
8113f520:	e0bffe17 	ldw	r2,-8(fp)
8113f524:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113f528:	e0bffe17 	ldw	r2,-8(fp)
8113f52c:	10800cc3 	ldbu	r2,51(r2)
8113f530:	10803fcc 	andi	r2,r2,255
8113f534:	00c00044 	movi	r3,1
8113f538:	1884983a 	sll	r2,r3,r2
8113f53c:	1007883a 	mov	r3,r2
8113f540:	e0bffe17 	ldw	r2,-8(fp)
8113f544:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113f548:	e0bffe17 	ldw	r2,-8(fp)
8113f54c:	10c00d83 	ldbu	r3,54(r2)
8113f550:	d0a09e03 	ldbu	r2,-32136(gp)
8113f554:	1884b03a 	or	r2,r3,r2
8113f558:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113f55c:	e0bffe17 	ldw	r2,-8(fp)
8113f560:	10800d03 	ldbu	r2,52(r2)
8113f564:	10c03fcc 	andi	r3,r2,255
8113f568:	e0bffe17 	ldw	r2,-8(fp)
8113f56c:	10800d03 	ldbu	r2,52(r2)
8113f570:	11003fcc 	andi	r4,r2,255
8113f574:	d0a09e44 	addi	r2,gp,-32135
8113f578:	2085883a 	add	r2,r4,r2
8113f57c:	11000003 	ldbu	r4,0(r2)
8113f580:	e0bffe17 	ldw	r2,-8(fp)
8113f584:	10800d43 	ldbu	r2,53(r2)
8113f588:	2084b03a 	or	r2,r4,r2
8113f58c:	1009883a 	mov	r4,r2
8113f590:	d0a09e44 	addi	r2,gp,-32135
8113f594:	1885883a 	add	r2,r3,r2
8113f598:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113f59c:	e0ffff03 	ldbu	r3,-4(fp)
8113f5a0:	00a045f4 	movhi	r2,33047
8113f5a4:	10bb6404 	addi	r2,r2,-4720
8113f5a8:	18c7883a 	add	r3,r3,r3
8113f5ac:	18c7883a 	add	r3,r3,r3
8113f5b0:	10c5883a 	add	r2,r2,r3
8113f5b4:	e0fffe17 	ldw	r3,-8(fp)
8113f5b8:	10c00015 	stw	r3,0(r2)
}
8113f5bc:	0001883a 	nop
8113f5c0:	e037883a 	mov	sp,fp
8113f5c4:	df000017 	ldw	fp,0(sp)
8113f5c8:	dec00104 	addi	sp,sp,4
8113f5cc:	f800283a 	ret

8113f5d0 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113f5d0:	defff804 	addi	sp,sp,-32
8113f5d4:	de00012e 	bgeu	sp,et,8113f5dc <OSQAccept+0xc>
8113f5d8:	003b68fa 	trap	3
8113f5dc:	df000715 	stw	fp,28(sp)
8113f5e0:	df000704 	addi	fp,sp,28
8113f5e4:	e13ffe15 	stw	r4,-8(fp)
8113f5e8:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f5ec:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113f5f0:	e0bfff17 	ldw	r2,-4(fp)
8113f5f4:	1000021e 	bne	r2,zero,8113f600 <OSQAccept+0x30>
        return ((void *)0);
8113f5f8:	0005883a 	mov	r2,zero
8113f5fc:	00004206 	br	8113f708 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113f600:	e0bffe17 	ldw	r2,-8(fp)
8113f604:	1000051e 	bne	r2,zero,8113f61c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113f608:	e0bfff17 	ldw	r2,-4(fp)
8113f60c:	00c00104 	movi	r3,4
8113f610:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f614:	0005883a 	mov	r2,zero
8113f618:	00003b06 	br	8113f708 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113f61c:	e0bffe17 	ldw	r2,-8(fp)
8113f620:	10800003 	ldbu	r2,0(r2)
8113f624:	10803fcc 	andi	r2,r2,255
8113f628:	108000a0 	cmpeqi	r2,r2,2
8113f62c:	1000051e 	bne	r2,zero,8113f644 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113f630:	e0bfff17 	ldw	r2,-4(fp)
8113f634:	00c00044 	movi	r3,1
8113f638:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f63c:	0005883a 	mov	r2,zero
8113f640:	00003106 	br	8113f708 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f644:	0005303a 	rdctl	r2,status
8113f648:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f64c:	e0fffd17 	ldw	r3,-12(fp)
8113f650:	00bfff84 	movi	r2,-2
8113f654:	1884703a 	and	r2,r3,r2
8113f658:	1001703a 	wrctl	status,r2
  
  return context;
8113f65c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f660:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113f664:	e0bffe17 	ldw	r2,-8(fp)
8113f668:	10800117 	ldw	r2,4(r2)
8113f66c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113f670:	e0bffc17 	ldw	r2,-16(fp)
8113f674:	1080058b 	ldhu	r2,22(r2)
8113f678:	10bfffcc 	andi	r2,r2,65535
8113f67c:	10001926 	beq	r2,zero,8113f6e4 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113f680:	e0bffc17 	ldw	r2,-16(fp)
8113f684:	10800417 	ldw	r2,16(r2)
8113f688:	11000104 	addi	r4,r2,4
8113f68c:	e0fffc17 	ldw	r3,-16(fp)
8113f690:	19000415 	stw	r4,16(r3)
8113f694:	10800017 	ldw	r2,0(r2)
8113f698:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113f69c:	e0bffc17 	ldw	r2,-16(fp)
8113f6a0:	1080058b 	ldhu	r2,22(r2)
8113f6a4:	10bfffc4 	addi	r2,r2,-1
8113f6a8:	1007883a 	mov	r3,r2
8113f6ac:	e0bffc17 	ldw	r2,-16(fp)
8113f6b0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113f6b4:	e0bffc17 	ldw	r2,-16(fp)
8113f6b8:	10c00417 	ldw	r3,16(r2)
8113f6bc:	e0bffc17 	ldw	r2,-16(fp)
8113f6c0:	10800217 	ldw	r2,8(r2)
8113f6c4:	1880041e 	bne	r3,r2,8113f6d8 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113f6c8:	e0bffc17 	ldw	r2,-16(fp)
8113f6cc:	10c00117 	ldw	r3,4(r2)
8113f6d0:	e0bffc17 	ldw	r2,-16(fp)
8113f6d4:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113f6d8:	e0bfff17 	ldw	r2,-4(fp)
8113f6dc:	10000005 	stb	zero,0(r2)
8113f6e0:	00000406 	br	8113f6f4 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113f6e4:	e0bfff17 	ldw	r2,-4(fp)
8113f6e8:	00c007c4 	movi	r3,31
8113f6ec:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113f6f0:	e03ff915 	stw	zero,-28(fp)
8113f6f4:	e0bffa17 	ldw	r2,-24(fp)
8113f6f8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f6fc:	e0bffb17 	ldw	r2,-20(fp)
8113f700:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113f704:	e0bff917 	ldw	r2,-28(fp)
}
8113f708:	e037883a 	mov	sp,fp
8113f70c:	df000017 	ldw	fp,0(sp)
8113f710:	dec00104 	addi	sp,sp,4
8113f714:	f800283a 	ret

8113f718 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113f718:	defff404 	addi	sp,sp,-48
8113f71c:	de00012e 	bgeu	sp,et,8113f724 <OSQCreate+0xc>
8113f720:	003b68fa 	trap	3
8113f724:	dfc00b15 	stw	ra,44(sp)
8113f728:	df000a15 	stw	fp,40(sp)
8113f72c:	df000a04 	addi	fp,sp,40
8113f730:	e13ffe15 	stw	r4,-8(fp)
8113f734:	2805883a 	mov	r2,r5
8113f738:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f73c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113f740:	d0a0a103 	ldbu	r2,-32124(gp)
8113f744:	10803fcc 	andi	r2,r2,255
8113f748:	10000226 	beq	r2,zero,8113f754 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113f74c:	0005883a 	mov	r2,zero
8113f750:	00005906 	br	8113f8b8 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f754:	0005303a 	rdctl	r2,status
8113f758:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f75c:	e0fffd17 	ldw	r3,-12(fp)
8113f760:	00bfff84 	movi	r2,-2
8113f764:	1884703a 	and	r2,r3,r2
8113f768:	1001703a 	wrctl	status,r2
  
  return context;
8113f76c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f770:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113f774:	d0a0a017 	ldw	r2,-32128(gp)
8113f778:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113f77c:	d0a0a017 	ldw	r2,-32128(gp)
8113f780:	10000326 	beq	r2,zero,8113f790 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113f784:	d0a0a017 	ldw	r2,-32128(gp)
8113f788:	10800117 	ldw	r2,4(r2)
8113f78c:	d0a0a015 	stw	r2,-32128(gp)
8113f790:	e0bff717 	ldw	r2,-36(fp)
8113f794:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f798:	e0bff817 	ldw	r2,-32(fp)
8113f79c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113f7a0:	e0bff617 	ldw	r2,-40(fp)
8113f7a4:	10004326 	beq	r2,zero,8113f8b4 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f7a8:	0005303a 	rdctl	r2,status
8113f7ac:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f7b0:	e0fff917 	ldw	r3,-28(fp)
8113f7b4:	00bfff84 	movi	r2,-2
8113f7b8:	1884703a 	and	r2,r3,r2
8113f7bc:	1001703a 	wrctl	status,r2
  
  return context;
8113f7c0:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113f7c4:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113f7c8:	d0a09d17 	ldw	r2,-32140(gp)
8113f7cc:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113f7d0:	e0bffb17 	ldw	r2,-20(fp)
8113f7d4:	10002d26 	beq	r2,zero,8113f88c <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113f7d8:	d0a09d17 	ldw	r2,-32140(gp)
8113f7dc:	10800017 	ldw	r2,0(r2)
8113f7e0:	d0a09d15 	stw	r2,-32140(gp)
8113f7e4:	e0bff717 	ldw	r2,-36(fp)
8113f7e8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f7ec:	e0bffa17 	ldw	r2,-24(fp)
8113f7f0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113f7f4:	e0bffb17 	ldw	r2,-20(fp)
8113f7f8:	e0fffe17 	ldw	r3,-8(fp)
8113f7fc:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113f800:	e0bfff0b 	ldhu	r2,-4(fp)
8113f804:	1085883a 	add	r2,r2,r2
8113f808:	1085883a 	add	r2,r2,r2
8113f80c:	1007883a 	mov	r3,r2
8113f810:	e0bffe17 	ldw	r2,-8(fp)
8113f814:	10c7883a 	add	r3,r2,r3
8113f818:	e0bffb17 	ldw	r2,-20(fp)
8113f81c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113f820:	e0bffb17 	ldw	r2,-20(fp)
8113f824:	e0fffe17 	ldw	r3,-8(fp)
8113f828:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113f82c:	e0bffb17 	ldw	r2,-20(fp)
8113f830:	e0fffe17 	ldw	r3,-8(fp)
8113f834:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113f838:	e0bffb17 	ldw	r2,-20(fp)
8113f83c:	e0ffff0b 	ldhu	r3,-4(fp)
8113f840:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113f844:	e0bffb17 	ldw	r2,-20(fp)
8113f848:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113f84c:	e0bff617 	ldw	r2,-40(fp)
8113f850:	00c00084 	movi	r3,2
8113f854:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113f858:	e0bff617 	ldw	r2,-40(fp)
8113f85c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113f860:	e0bff617 	ldw	r2,-40(fp)
8113f864:	e0fffb17 	ldw	r3,-20(fp)
8113f868:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113f86c:	e0bff617 	ldw	r2,-40(fp)
8113f870:	00c00fc4 	movi	r3,63
8113f874:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113f878:	e0bff617 	ldw	r2,-40(fp)
8113f87c:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113f880:	e13ff617 	ldw	r4,-40(fp)
8113f884:	113b7780 	call	8113b778 <OS_EventWaitListInit>
8113f888:	00000a06 	br	8113f8b4 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113f88c:	d0e0a017 	ldw	r3,-32128(gp)
8113f890:	e0bff617 	ldw	r2,-40(fp)
8113f894:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113f898:	e0bff617 	ldw	r2,-40(fp)
8113f89c:	d0a0a015 	stw	r2,-32128(gp)
8113f8a0:	e0bff717 	ldw	r2,-36(fp)
8113f8a4:	e0bffc15 	stw	r2,-16(fp)
8113f8a8:	e0bffc17 	ldw	r2,-16(fp)
8113f8ac:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113f8b0:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113f8b4:	e0bff617 	ldw	r2,-40(fp)
}
8113f8b8:	e037883a 	mov	sp,fp
8113f8bc:	dfc00117 	ldw	ra,4(sp)
8113f8c0:	df000017 	ldw	fp,0(sp)
8113f8c4:	dec00204 	addi	sp,sp,8
8113f8c8:	f800283a 	ret

8113f8cc <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113f8cc:	defff204 	addi	sp,sp,-56
8113f8d0:	de00012e 	bgeu	sp,et,8113f8d8 <OSQDel+0xc>
8113f8d4:	003b68fa 	trap	3
8113f8d8:	dfc00d15 	stw	ra,52(sp)
8113f8dc:	df000c15 	stw	fp,48(sp)
8113f8e0:	df000c04 	addi	fp,sp,48
8113f8e4:	e13ffd15 	stw	r4,-12(fp)
8113f8e8:	2805883a 	mov	r2,r5
8113f8ec:	e1bfff15 	stw	r6,-4(fp)
8113f8f0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113f8f4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113f8f8:	e0bfff17 	ldw	r2,-4(fp)
8113f8fc:	1000021e 	bne	r2,zero,8113f908 <OSQDel+0x3c>
        return (pevent);
8113f900:	e0bffd17 	ldw	r2,-12(fp)
8113f904:	00008e06 	br	8113fb40 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113f908:	e0bffd17 	ldw	r2,-12(fp)
8113f90c:	1000051e 	bne	r2,zero,8113f924 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113f910:	e0bfff17 	ldw	r2,-4(fp)
8113f914:	00c00104 	movi	r3,4
8113f918:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113f91c:	e0bffd17 	ldw	r2,-12(fp)
8113f920:	00008706 	br	8113fb40 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113f924:	e0bffd17 	ldw	r2,-12(fp)
8113f928:	10800003 	ldbu	r2,0(r2)
8113f92c:	10803fcc 	andi	r2,r2,255
8113f930:	108000a0 	cmpeqi	r2,r2,2
8113f934:	1000051e 	bne	r2,zero,8113f94c <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113f938:	e0bfff17 	ldw	r2,-4(fp)
8113f93c:	00c00044 	movi	r3,1
8113f940:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113f944:	e0bffd17 	ldw	r2,-12(fp)
8113f948:	00007d06 	br	8113fb40 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113f94c:	d0a0a103 	ldbu	r2,-32124(gp)
8113f950:	10803fcc 	andi	r2,r2,255
8113f954:	10000526 	beq	r2,zero,8113f96c <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113f958:	e0bfff17 	ldw	r2,-4(fp)
8113f95c:	00c003c4 	movi	r3,15
8113f960:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113f964:	e0bffd17 	ldw	r2,-12(fp)
8113f968:	00007506 	br	8113fb40 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f96c:	0005303a 	rdctl	r2,status
8113f970:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f974:	e0fffc17 	ldw	r3,-16(fp)
8113f978:	00bfff84 	movi	r2,-2
8113f97c:	1884703a 	and	r2,r3,r2
8113f980:	1001703a 	wrctl	status,r2
  
  return context;
8113f984:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f988:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113f98c:	e0bffd17 	ldw	r2,-12(fp)
8113f990:	10800283 	ldbu	r2,10(r2)
8113f994:	10803fcc 	andi	r2,r2,255
8113f998:	10000326 	beq	r2,zero,8113f9a8 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113f99c:	00800044 	movi	r2,1
8113f9a0:	e0bff405 	stb	r2,-48(fp)
8113f9a4:	00000106 	br	8113f9ac <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113f9a8:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113f9ac:	e0bffe03 	ldbu	r2,-8(fp)
8113f9b0:	10000326 	beq	r2,zero,8113f9c0 <OSQDel+0xf4>
8113f9b4:	10800060 	cmpeqi	r2,r2,1
8113f9b8:	1000301e 	bne	r2,zero,8113fa7c <OSQDel+0x1b0>
8113f9bc:	00005506 	br	8113fb14 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113f9c0:	e0bff403 	ldbu	r2,-48(fp)
8113f9c4:	10001e1e 	bne	r2,zero,8113fa40 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113f9c8:	e0bffd17 	ldw	r2,-12(fp)
8113f9cc:	00c00fc4 	movi	r3,63
8113f9d0:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113f9d4:	e0bffd17 	ldw	r2,-12(fp)
8113f9d8:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113f9dc:	e0bffd17 	ldw	r2,-12(fp)
8113f9e0:	10800117 	ldw	r2,4(r2)
8113f9e4:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113f9e8:	d0e09d17 	ldw	r3,-32140(gp)
8113f9ec:	e0bff817 	ldw	r2,-32(fp)
8113f9f0:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113f9f4:	e0bff817 	ldw	r2,-32(fp)
8113f9f8:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113f9fc:	e0bffd17 	ldw	r2,-12(fp)
8113fa00:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113fa04:	d0e0a017 	ldw	r3,-32128(gp)
8113fa08:	e0bffd17 	ldw	r2,-12(fp)
8113fa0c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113fa10:	e0bffd17 	ldw	r2,-12(fp)
8113fa14:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113fa18:	e0bffd17 	ldw	r2,-12(fp)
8113fa1c:	d0a0a015 	stw	r2,-32128(gp)
8113fa20:	e0bff617 	ldw	r2,-40(fp)
8113fa24:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fa28:	e0bff717 	ldw	r2,-36(fp)
8113fa2c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113fa30:	e0bfff17 	ldw	r2,-4(fp)
8113fa34:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113fa38:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113fa3c:	00003f06 	br	8113fb3c <OSQDel+0x270>
8113fa40:	e0bff617 	ldw	r2,-40(fp)
8113fa44:	e0bff915 	stw	r2,-28(fp)
8113fa48:	e0bff917 	ldw	r2,-28(fp)
8113fa4c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113fa50:	e0bfff17 	ldw	r2,-4(fp)
8113fa54:	00c01244 	movi	r3,73
8113fa58:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113fa5c:	e0bffd17 	ldw	r2,-12(fp)
8113fa60:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113fa64:	00003506 	br	8113fb3c <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113fa68:	000f883a 	mov	r7,zero
8113fa6c:	01800104 	movi	r6,4
8113fa70:	000b883a 	mov	r5,zero
8113fa74:	e13ffd17 	ldw	r4,-12(fp)
8113fa78:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113fa7c:	e0bffd17 	ldw	r2,-12(fp)
8113fa80:	10800283 	ldbu	r2,10(r2)
8113fa84:	10803fcc 	andi	r2,r2,255
8113fa88:	103ff71e 	bne	r2,zero,8113fa68 <__reset+0xfb11fa68>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113fa8c:	e0bffd17 	ldw	r2,-12(fp)
8113fa90:	00c00fc4 	movi	r3,63
8113fa94:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113fa98:	e0bffd17 	ldw	r2,-12(fp)
8113fa9c:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113faa0:	e0bffd17 	ldw	r2,-12(fp)
8113faa4:	10800117 	ldw	r2,4(r2)
8113faa8:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113faac:	d0e09d17 	ldw	r3,-32140(gp)
8113fab0:	e0bff817 	ldw	r2,-32(fp)
8113fab4:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113fab8:	e0bff817 	ldw	r2,-32(fp)
8113fabc:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113fac0:	e0bffd17 	ldw	r2,-12(fp)
8113fac4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113fac8:	d0e0a017 	ldw	r3,-32128(gp)
8113facc:	e0bffd17 	ldw	r2,-12(fp)
8113fad0:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113fad4:	e0bffd17 	ldw	r2,-12(fp)
8113fad8:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113fadc:	e0bffd17 	ldw	r2,-12(fp)
8113fae0:	d0a0a015 	stw	r2,-32128(gp)
8113fae4:	e0bff617 	ldw	r2,-40(fp)
8113fae8:	e0bffa15 	stw	r2,-24(fp)
8113faec:	e0bffa17 	ldw	r2,-24(fp)
8113faf0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113faf4:	e0bff403 	ldbu	r2,-48(fp)
8113faf8:	10800058 	cmpnei	r2,r2,1
8113fafc:	1000011e 	bne	r2,zero,8113fb04 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113fb00:	113bc5c0 	call	8113bc5c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113fb04:	e0bfff17 	ldw	r2,-4(fp)
8113fb08:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113fb0c:	e03ff515 	stw	zero,-44(fp)
             break;
8113fb10:	00000a06 	br	8113fb3c <OSQDel+0x270>
8113fb14:	e0bff617 	ldw	r2,-40(fp)
8113fb18:	e0bffb15 	stw	r2,-20(fp)
8113fb1c:	e0bffb17 	ldw	r2,-20(fp)
8113fb20:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113fb24:	e0bfff17 	ldw	r2,-4(fp)
8113fb28:	00c001c4 	movi	r3,7
8113fb2c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113fb30:	e0bffd17 	ldw	r2,-12(fp)
8113fb34:	e0bff515 	stw	r2,-44(fp)
             break;
8113fb38:	0001883a 	nop
    }
    return (pevent_return);
8113fb3c:	e0bff517 	ldw	r2,-44(fp)
}
8113fb40:	e037883a 	mov	sp,fp
8113fb44:	dfc00117 	ldw	ra,4(sp)
8113fb48:	df000017 	ldw	fp,0(sp)
8113fb4c:	dec00204 	addi	sp,sp,8
8113fb50:	f800283a 	ret

8113fb54 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113fb54:	defffa04 	addi	sp,sp,-24
8113fb58:	de00012e 	bgeu	sp,et,8113fb60 <OSQFlush+0xc>
8113fb5c:	003b68fa 	trap	3
8113fb60:	df000515 	stw	fp,20(sp)
8113fb64:	df000504 	addi	fp,sp,20
8113fb68:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fb6c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113fb70:	e0bfff17 	ldw	r2,-4(fp)
8113fb74:	1000021e 	bne	r2,zero,8113fb80 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113fb78:	00800104 	movi	r2,4
8113fb7c:	00002106 	br	8113fc04 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113fb80:	e0bfff17 	ldw	r2,-4(fp)
8113fb84:	10800003 	ldbu	r2,0(r2)
8113fb88:	10803fcc 	andi	r2,r2,255
8113fb8c:	108000a0 	cmpeqi	r2,r2,2
8113fb90:	1000021e 	bne	r2,zero,8113fb9c <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113fb94:	00800044 	movi	r2,1
8113fb98:	00001a06 	br	8113fc04 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fb9c:	0005303a 	rdctl	r2,status
8113fba0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fba4:	e0fffd17 	ldw	r3,-12(fp)
8113fba8:	00bfff84 	movi	r2,-2
8113fbac:	1884703a 	and	r2,r3,r2
8113fbb0:	1001703a 	wrctl	status,r2
  
  return context;
8113fbb4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113fbb8:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113fbbc:	e0bfff17 	ldw	r2,-4(fp)
8113fbc0:	10800117 	ldw	r2,4(r2)
8113fbc4:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113fbc8:	e0bffc17 	ldw	r2,-16(fp)
8113fbcc:	10c00117 	ldw	r3,4(r2)
8113fbd0:	e0bffc17 	ldw	r2,-16(fp)
8113fbd4:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113fbd8:	e0bffc17 	ldw	r2,-16(fp)
8113fbdc:	10c00117 	ldw	r3,4(r2)
8113fbe0:	e0bffc17 	ldw	r2,-16(fp)
8113fbe4:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113fbe8:	e0bffc17 	ldw	r2,-16(fp)
8113fbec:	1000058d 	sth	zero,22(r2)
8113fbf0:	e0bffb17 	ldw	r2,-20(fp)
8113fbf4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fbf8:	e0bffe17 	ldw	r2,-8(fp)
8113fbfc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113fc00:	0005883a 	mov	r2,zero
}
8113fc04:	e037883a 	mov	sp,fp
8113fc08:	df000017 	ldw	fp,0(sp)
8113fc0c:	dec00104 	addi	sp,sp,4
8113fc10:	f800283a 	ret

8113fc14 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113fc14:	defff304 	addi	sp,sp,-52
8113fc18:	de00012e 	bgeu	sp,et,8113fc20 <OSQPend+0xc>
8113fc1c:	003b68fa 	trap	3
8113fc20:	dfc00c15 	stw	ra,48(sp)
8113fc24:	df000b15 	stw	fp,44(sp)
8113fc28:	df000b04 	addi	fp,sp,44
8113fc2c:	e13ffd15 	stw	r4,-12(fp)
8113fc30:	2805883a 	mov	r2,r5
8113fc34:	e1bfff15 	stw	r6,-4(fp)
8113fc38:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113fc3c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113fc40:	e0bfff17 	ldw	r2,-4(fp)
8113fc44:	1000021e 	bne	r2,zero,8113fc50 <OSQPend+0x3c>
        return ((void *)0);
8113fc48:	0005883a 	mov	r2,zero
8113fc4c:	00009106 	br	8113fe94 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113fc50:	e0bffd17 	ldw	r2,-12(fp)
8113fc54:	1000051e 	bne	r2,zero,8113fc6c <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113fc58:	e0bfff17 	ldw	r2,-4(fp)
8113fc5c:	00c00104 	movi	r3,4
8113fc60:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113fc64:	0005883a 	mov	r2,zero
8113fc68:	00008a06 	br	8113fe94 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113fc6c:	e0bffd17 	ldw	r2,-12(fp)
8113fc70:	10800003 	ldbu	r2,0(r2)
8113fc74:	10803fcc 	andi	r2,r2,255
8113fc78:	108000a0 	cmpeqi	r2,r2,2
8113fc7c:	1000051e 	bne	r2,zero,8113fc94 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113fc80:	e0bfff17 	ldw	r2,-4(fp)
8113fc84:	00c00044 	movi	r3,1
8113fc88:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113fc8c:	0005883a 	mov	r2,zero
8113fc90:	00008006 	br	8113fe94 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113fc94:	d0a0a103 	ldbu	r2,-32124(gp)
8113fc98:	10803fcc 	andi	r2,r2,255
8113fc9c:	10000526 	beq	r2,zero,8113fcb4 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113fca0:	e0bfff17 	ldw	r2,-4(fp)
8113fca4:	00c00084 	movi	r3,2
8113fca8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113fcac:	0005883a 	mov	r2,zero
8113fcb0:	00007806 	br	8113fe94 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113fcb4:	d0a08f03 	ldbu	r2,-32196(gp)
8113fcb8:	10803fcc 	andi	r2,r2,255
8113fcbc:	10000526 	beq	r2,zero,8113fcd4 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113fcc0:	e0bfff17 	ldw	r2,-4(fp)
8113fcc4:	00c00344 	movi	r3,13
8113fcc8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113fccc:	0005883a 	mov	r2,zero
8113fcd0:	00007006 	br	8113fe94 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fcd4:	0005303a 	rdctl	r2,status
8113fcd8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fcdc:	e0fffc17 	ldw	r3,-16(fp)
8113fce0:	00bfff84 	movi	r2,-2
8113fce4:	1884703a 	and	r2,r3,r2
8113fce8:	1001703a 	wrctl	status,r2
  
  return context;
8113fcec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fcf0:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113fcf4:	e0bffd17 	ldw	r2,-12(fp)
8113fcf8:	10800117 	ldw	r2,4(r2)
8113fcfc:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113fd00:	e0bff817 	ldw	r2,-32(fp)
8113fd04:	1080058b 	ldhu	r2,22(r2)
8113fd08:	10bfffcc 	andi	r2,r2,65535
8113fd0c:	10001e26 	beq	r2,zero,8113fd88 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113fd10:	e0bff817 	ldw	r2,-32(fp)
8113fd14:	10800417 	ldw	r2,16(r2)
8113fd18:	11000104 	addi	r4,r2,4
8113fd1c:	e0fff817 	ldw	r3,-32(fp)
8113fd20:	19000415 	stw	r4,16(r3)
8113fd24:	10800017 	ldw	r2,0(r2)
8113fd28:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113fd2c:	e0bff817 	ldw	r2,-32(fp)
8113fd30:	1080058b 	ldhu	r2,22(r2)
8113fd34:	10bfffc4 	addi	r2,r2,-1
8113fd38:	1007883a 	mov	r3,r2
8113fd3c:	e0bff817 	ldw	r2,-32(fp)
8113fd40:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113fd44:	e0bff817 	ldw	r2,-32(fp)
8113fd48:	10c00417 	ldw	r3,16(r2)
8113fd4c:	e0bff817 	ldw	r2,-32(fp)
8113fd50:	10800217 	ldw	r2,8(r2)
8113fd54:	1880041e 	bne	r3,r2,8113fd68 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113fd58:	e0bff817 	ldw	r2,-32(fp)
8113fd5c:	10c00117 	ldw	r3,4(r2)
8113fd60:	e0bff817 	ldw	r2,-32(fp)
8113fd64:	10c00415 	stw	r3,16(r2)
8113fd68:	e0bff617 	ldw	r2,-40(fp)
8113fd6c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fd70:	e0bff717 	ldw	r2,-36(fp)
8113fd74:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113fd78:	e0bfff17 	ldw	r2,-4(fp)
8113fd7c:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113fd80:	e0bff517 	ldw	r2,-44(fp)
8113fd84:	00004306 	br	8113fe94 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113fd88:	d0a0a217 	ldw	r2,-32120(gp)
8113fd8c:	d0e0a217 	ldw	r3,-32120(gp)
8113fd90:	18c00c03 	ldbu	r3,48(r3)
8113fd94:	18c00114 	ori	r3,r3,4
8113fd98:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113fd9c:	d0a0a217 	ldw	r2,-32120(gp)
8113fda0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113fda4:	d0a0a217 	ldw	r2,-32120(gp)
8113fda8:	e0fffe0b 	ldhu	r3,-8(fp)
8113fdac:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113fdb0:	e13ffd17 	ldw	r4,-12(fp)
8113fdb4:	113b3400 	call	8113b340 <OS_EventTaskWait>
8113fdb8:	e0bff617 	ldw	r2,-40(fp)
8113fdbc:	e0bffb15 	stw	r2,-20(fp)
8113fdc0:	e0bffb17 	ldw	r2,-20(fp)
8113fdc4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113fdc8:	113bc5c0 	call	8113bc5c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fdcc:	0005303a 	rdctl	r2,status
8113fdd0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fdd4:	e0fff917 	ldw	r3,-28(fp)
8113fdd8:	00bfff84 	movi	r2,-2
8113fddc:	1884703a 	and	r2,r3,r2
8113fde0:	1001703a 	wrctl	status,r2
  
  return context;
8113fde4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113fde8:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113fdec:	d0a0a217 	ldw	r2,-32120(gp)
8113fdf0:	10800c43 	ldbu	r2,49(r2)
8113fdf4:	10803fcc 	andi	r2,r2,255
8113fdf8:	10000326 	beq	r2,zero,8113fe08 <OSQPend+0x1f4>
8113fdfc:	108000a0 	cmpeqi	r2,r2,2
8113fe00:	1000071e 	bne	r2,zero,8113fe20 <OSQPend+0x20c>
8113fe04:	00000b06 	br	8113fe34 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113fe08:	d0a0a217 	ldw	r2,-32120(gp)
8113fe0c:	10800917 	ldw	r2,36(r2)
8113fe10:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113fe14:	e0bfff17 	ldw	r2,-4(fp)
8113fe18:	10000005 	stb	zero,0(r2)
             break;
8113fe1c:	00000e06 	br	8113fe58 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113fe20:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113fe24:	e0bfff17 	ldw	r2,-4(fp)
8113fe28:	00c00384 	movi	r3,14
8113fe2c:	10c00005 	stb	r3,0(r2)
             break;
8113fe30:	00000906 	br	8113fe58 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113fe34:	d0a0a217 	ldw	r2,-32120(gp)
8113fe38:	e17ffd17 	ldw	r5,-12(fp)
8113fe3c:	1009883a 	mov	r4,r2
8113fe40:	113b5b00 	call	8113b5b0 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113fe44:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113fe48:	e0bfff17 	ldw	r2,-4(fp)
8113fe4c:	00c00284 	movi	r3,10
8113fe50:	10c00005 	stb	r3,0(r2)
             break;
8113fe54:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113fe58:	d0a0a217 	ldw	r2,-32120(gp)
8113fe5c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113fe60:	d0a0a217 	ldw	r2,-32120(gp)
8113fe64:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113fe68:	d0a0a217 	ldw	r2,-32120(gp)
8113fe6c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113fe70:	d0a0a217 	ldw	r2,-32120(gp)
8113fe74:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113fe78:	d0a0a217 	ldw	r2,-32120(gp)
8113fe7c:	10000915 	stw	zero,36(r2)
8113fe80:	e0bff617 	ldw	r2,-40(fp)
8113fe84:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fe88:	e0bffa17 	ldw	r2,-24(fp)
8113fe8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113fe90:	e0bff517 	ldw	r2,-44(fp)
}
8113fe94:	e037883a 	mov	sp,fp
8113fe98:	dfc00117 	ldw	ra,4(sp)
8113fe9c:	df000017 	ldw	fp,0(sp)
8113fea0:	dec00204 	addi	sp,sp,8
8113fea4:	f800283a 	ret

8113fea8 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113fea8:	defff604 	addi	sp,sp,-40
8113feac:	de00012e 	bgeu	sp,et,8113feb4 <OSQPendAbort+0xc>
8113feb0:	003b68fa 	trap	3
8113feb4:	dfc00915 	stw	ra,36(sp)
8113feb8:	df000815 	stw	fp,32(sp)
8113febc:	df000804 	addi	fp,sp,32
8113fec0:	e13ffd15 	stw	r4,-12(fp)
8113fec4:	2805883a 	mov	r2,r5
8113fec8:	e1bfff15 	stw	r6,-4(fp)
8113fecc:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113fed0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113fed4:	e0bfff17 	ldw	r2,-4(fp)
8113fed8:	1000021e 	bne	r2,zero,8113fee4 <OSQPendAbort+0x3c>
        return (0);
8113fedc:	0005883a 	mov	r2,zero
8113fee0:	00004906 	br	81140008 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113fee4:	e0bffd17 	ldw	r2,-12(fp)
8113fee8:	1000051e 	bne	r2,zero,8113ff00 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113feec:	e0bfff17 	ldw	r2,-4(fp)
8113fef0:	00c00104 	movi	r3,4
8113fef4:	10c00005 	stb	r3,0(r2)
        return (0);
8113fef8:	0005883a 	mov	r2,zero
8113fefc:	00004206 	br	81140008 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113ff00:	e0bffd17 	ldw	r2,-12(fp)
8113ff04:	10800003 	ldbu	r2,0(r2)
8113ff08:	10803fcc 	andi	r2,r2,255
8113ff0c:	108000a0 	cmpeqi	r2,r2,2
8113ff10:	1000051e 	bne	r2,zero,8113ff28 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ff14:	e0bfff17 	ldw	r2,-4(fp)
8113ff18:	00c00044 	movi	r3,1
8113ff1c:	10c00005 	stb	r3,0(r2)
        return (0);
8113ff20:	0005883a 	mov	r2,zero
8113ff24:	00003806 	br	81140008 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ff28:	0005303a 	rdctl	r2,status
8113ff2c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ff30:	e0fffc17 	ldw	r3,-16(fp)
8113ff34:	00bfff84 	movi	r2,-2
8113ff38:	1884703a 	and	r2,r3,r2
8113ff3c:	1001703a 	wrctl	status,r2
  
  return context;
8113ff40:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ff44:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113ff48:	e0bffd17 	ldw	r2,-12(fp)
8113ff4c:	10800283 	ldbu	r2,10(r2)
8113ff50:	10803fcc 	andi	r2,r2,255
8113ff54:	10002526 	beq	r2,zero,8113ffec <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113ff58:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113ff5c:	e0bffe03 	ldbu	r2,-8(fp)
8113ff60:	10800060 	cmpeqi	r2,r2,1
8113ff64:	10000e26 	beq	r2,zero,8113ffa0 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113ff68:	00000806 	br	8113ff8c <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113ff6c:	01c00084 	movi	r7,2
8113ff70:	01800104 	movi	r6,4
8113ff74:	000b883a 	mov	r5,zero
8113ff78:	e13ffd17 	ldw	r4,-12(fp)
8113ff7c:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
                     nbr_tasks++;
8113ff80:	e0bff803 	ldbu	r2,-32(fp)
8113ff84:	10800044 	addi	r2,r2,1
8113ff88:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113ff8c:	e0bffd17 	ldw	r2,-12(fp)
8113ff90:	10800283 	ldbu	r2,10(r2)
8113ff94:	10803fcc 	andi	r2,r2,255
8113ff98:	103ff41e 	bne	r2,zero,8113ff6c <__reset+0xfb11ff6c>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113ff9c:	00000906 	br	8113ffc4 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113ffa0:	01c00084 	movi	r7,2
8113ffa4:	01800104 	movi	r6,4
8113ffa8:	000b883a 	mov	r5,zero
8113ffac:	e13ffd17 	ldw	r4,-12(fp)
8113ffb0:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
                 nbr_tasks++;
8113ffb4:	e0bff803 	ldbu	r2,-32(fp)
8113ffb8:	10800044 	addi	r2,r2,1
8113ffbc:	e0bff805 	stb	r2,-32(fp)
                 break;
8113ffc0:	0001883a 	nop
8113ffc4:	e0bff917 	ldw	r2,-28(fp)
8113ffc8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ffcc:	e0bffa17 	ldw	r2,-24(fp)
8113ffd0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113ffd4:	113bc5c0 	call	8113bc5c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113ffd8:	e0bfff17 	ldw	r2,-4(fp)
8113ffdc:	00c00384 	movi	r3,14
8113ffe0:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113ffe4:	e0bff803 	ldbu	r2,-32(fp)
8113ffe8:	00000706 	br	81140008 <OSQPendAbort+0x160>
8113ffec:	e0bff917 	ldw	r2,-28(fp)
8113fff0:	e0bffb15 	stw	r2,-20(fp)
8113fff4:	e0bffb17 	ldw	r2,-20(fp)
8113fff8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113fffc:	e0bfff17 	ldw	r2,-4(fp)
81140000:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81140004:	0005883a 	mov	r2,zero
}
81140008:	e037883a 	mov	sp,fp
8114000c:	dfc00117 	ldw	ra,4(sp)
81140010:	df000017 	ldw	fp,0(sp)
81140014:	dec00204 	addi	sp,sp,8
81140018:	f800283a 	ret

8114001c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8114001c:	defff604 	addi	sp,sp,-40
81140020:	de00012e 	bgeu	sp,et,81140028 <OSQPost+0xc>
81140024:	003b68fa 	trap	3
81140028:	dfc00915 	stw	ra,36(sp)
8114002c:	df000815 	stw	fp,32(sp)
81140030:	df000804 	addi	fp,sp,32
81140034:	e13ffe15 	stw	r4,-8(fp)
81140038:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8114003c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81140040:	e0bffe17 	ldw	r2,-8(fp)
81140044:	1000021e 	bne	r2,zero,81140050 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
81140048:	00800104 	movi	r2,4
8114004c:	00004a06 	br	81140178 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81140050:	e0bffe17 	ldw	r2,-8(fp)
81140054:	10800003 	ldbu	r2,0(r2)
81140058:	10803fcc 	andi	r2,r2,255
8114005c:	108000a0 	cmpeqi	r2,r2,2
81140060:	1000021e 	bne	r2,zero,8114006c <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
81140064:	00800044 	movi	r2,1
81140068:	00004306 	br	81140178 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114006c:	0005303a 	rdctl	r2,status
81140070:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140074:	e0fffd17 	ldw	r3,-12(fp)
81140078:	00bfff84 	movi	r2,-2
8114007c:	1884703a 	and	r2,r3,r2
81140080:	1001703a 	wrctl	status,r2
  
  return context;
81140084:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81140088:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8114008c:	e0bffe17 	ldw	r2,-8(fp)
81140090:	10800283 	ldbu	r2,10(r2)
81140094:	10803fcc 	andi	r2,r2,255
81140098:	10000c26 	beq	r2,zero,811400cc <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8114009c:	000f883a 	mov	r7,zero
811400a0:	01800104 	movi	r6,4
811400a4:	e17fff17 	ldw	r5,-4(fp)
811400a8:	e13ffe17 	ldw	r4,-8(fp)
811400ac:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
811400b0:	e0bff817 	ldw	r2,-32(fp)
811400b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811400b8:	e0bff917 	ldw	r2,-28(fp)
811400bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
811400c0:	113bc5c0 	call	8113bc5c <OS_Sched>
        return (OS_ERR_NONE);
811400c4:	0005883a 	mov	r2,zero
811400c8:	00002b06 	br	81140178 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
811400cc:	e0bffe17 	ldw	r2,-8(fp)
811400d0:	10800117 	ldw	r2,4(r2)
811400d4:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
811400d8:	e0bffb17 	ldw	r2,-20(fp)
811400dc:	10c0058b 	ldhu	r3,22(r2)
811400e0:	e0bffb17 	ldw	r2,-20(fp)
811400e4:	1080050b 	ldhu	r2,20(r2)
811400e8:	18ffffcc 	andi	r3,r3,65535
811400ec:	10bfffcc 	andi	r2,r2,65535
811400f0:	18800636 	bltu	r3,r2,8114010c <OSQPost+0xf0>
811400f4:	e0bff817 	ldw	r2,-32(fp)
811400f8:	e0bffa15 	stw	r2,-24(fp)
811400fc:	e0bffa17 	ldw	r2,-24(fp)
81140100:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81140104:	00800784 	movi	r2,30
81140108:	00001b06 	br	81140178 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8114010c:	e0bffb17 	ldw	r2,-20(fp)
81140110:	10800317 	ldw	r2,12(r2)
81140114:	11000104 	addi	r4,r2,4
81140118:	e0fffb17 	ldw	r3,-20(fp)
8114011c:	19000315 	stw	r4,12(r3)
81140120:	e0ffff17 	ldw	r3,-4(fp)
81140124:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81140128:	e0bffb17 	ldw	r2,-20(fp)
8114012c:	1080058b 	ldhu	r2,22(r2)
81140130:	10800044 	addi	r2,r2,1
81140134:	1007883a 	mov	r3,r2
81140138:	e0bffb17 	ldw	r2,-20(fp)
8114013c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
81140140:	e0bffb17 	ldw	r2,-20(fp)
81140144:	10c00317 	ldw	r3,12(r2)
81140148:	e0bffb17 	ldw	r2,-20(fp)
8114014c:	10800217 	ldw	r2,8(r2)
81140150:	1880041e 	bne	r3,r2,81140164 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81140154:	e0bffb17 	ldw	r2,-20(fp)
81140158:	10c00117 	ldw	r3,4(r2)
8114015c:	e0bffb17 	ldw	r2,-20(fp)
81140160:	10c00315 	stw	r3,12(r2)
81140164:	e0bff817 	ldw	r2,-32(fp)
81140168:	e0bffc15 	stw	r2,-16(fp)
8114016c:	e0bffc17 	ldw	r2,-16(fp)
81140170:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140174:	0005883a 	mov	r2,zero
}
81140178:	e037883a 	mov	sp,fp
8114017c:	dfc00117 	ldw	ra,4(sp)
81140180:	df000017 	ldw	fp,0(sp)
81140184:	dec00204 	addi	sp,sp,8
81140188:	f800283a 	ret

8114018c <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8114018c:	defff604 	addi	sp,sp,-40
81140190:	de00012e 	bgeu	sp,et,81140198 <OSQPostFront+0xc>
81140194:	003b68fa 	trap	3
81140198:	dfc00915 	stw	ra,36(sp)
8114019c:	df000815 	stw	fp,32(sp)
811401a0:	df000804 	addi	fp,sp,32
811401a4:	e13ffe15 	stw	r4,-8(fp)
811401a8:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811401ac:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811401b0:	e0bffe17 	ldw	r2,-8(fp)
811401b4:	1000021e 	bne	r2,zero,811401c0 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
811401b8:	00800104 	movi	r2,4
811401bc:	00004c06 	br	811402f0 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811401c0:	e0bffe17 	ldw	r2,-8(fp)
811401c4:	10800003 	ldbu	r2,0(r2)
811401c8:	10803fcc 	andi	r2,r2,255
811401cc:	108000a0 	cmpeqi	r2,r2,2
811401d0:	1000021e 	bne	r2,zero,811401dc <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
811401d4:	00800044 	movi	r2,1
811401d8:	00004506 	br	811402f0 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811401dc:	0005303a 	rdctl	r2,status
811401e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811401e4:	e0fffd17 	ldw	r3,-12(fp)
811401e8:	00bfff84 	movi	r2,-2
811401ec:	1884703a 	and	r2,r3,r2
811401f0:	1001703a 	wrctl	status,r2
  
  return context;
811401f4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811401f8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
811401fc:	e0bffe17 	ldw	r2,-8(fp)
81140200:	10800283 	ldbu	r2,10(r2)
81140204:	10803fcc 	andi	r2,r2,255
81140208:	10000c26 	beq	r2,zero,8114023c <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8114020c:	000f883a 	mov	r7,zero
81140210:	01800104 	movi	r6,4
81140214:	e17fff17 	ldw	r5,-4(fp)
81140218:	e13ffe17 	ldw	r4,-8(fp)
8114021c:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
81140220:	e0bff817 	ldw	r2,-32(fp)
81140224:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140228:	e0bff917 	ldw	r2,-28(fp)
8114022c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
81140230:	113bc5c0 	call	8113bc5c <OS_Sched>
        return (OS_ERR_NONE);
81140234:	0005883a 	mov	r2,zero
81140238:	00002d06 	br	811402f0 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8114023c:	e0bffe17 	ldw	r2,-8(fp)
81140240:	10800117 	ldw	r2,4(r2)
81140244:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81140248:	e0bffb17 	ldw	r2,-20(fp)
8114024c:	10c0058b 	ldhu	r3,22(r2)
81140250:	e0bffb17 	ldw	r2,-20(fp)
81140254:	1080050b 	ldhu	r2,20(r2)
81140258:	18ffffcc 	andi	r3,r3,65535
8114025c:	10bfffcc 	andi	r2,r2,65535
81140260:	18800636 	bltu	r3,r2,8114027c <OSQPostFront+0xf0>
81140264:	e0bff817 	ldw	r2,-32(fp)
81140268:	e0bffa15 	stw	r2,-24(fp)
8114026c:	e0bffa17 	ldw	r2,-24(fp)
81140270:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81140274:	00800784 	movi	r2,30
81140278:	00001d06 	br	811402f0 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8114027c:	e0bffb17 	ldw	r2,-20(fp)
81140280:	10c00417 	ldw	r3,16(r2)
81140284:	e0bffb17 	ldw	r2,-20(fp)
81140288:	10800117 	ldw	r2,4(r2)
8114028c:	1880041e 	bne	r3,r2,811402a0 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
81140290:	e0bffb17 	ldw	r2,-20(fp)
81140294:	10c00217 	ldw	r3,8(r2)
81140298:	e0bffb17 	ldw	r2,-20(fp)
8114029c:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
811402a0:	e0bffb17 	ldw	r2,-20(fp)
811402a4:	10800417 	ldw	r2,16(r2)
811402a8:	10ffff04 	addi	r3,r2,-4
811402ac:	e0bffb17 	ldw	r2,-20(fp)
811402b0:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
811402b4:	e0bffb17 	ldw	r2,-20(fp)
811402b8:	10800417 	ldw	r2,16(r2)
811402bc:	e0ffff17 	ldw	r3,-4(fp)
811402c0:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
811402c4:	e0bffb17 	ldw	r2,-20(fp)
811402c8:	1080058b 	ldhu	r2,22(r2)
811402cc:	10800044 	addi	r2,r2,1
811402d0:	1007883a 	mov	r3,r2
811402d4:	e0bffb17 	ldw	r2,-20(fp)
811402d8:	10c0058d 	sth	r3,22(r2)
811402dc:	e0bff817 	ldw	r2,-32(fp)
811402e0:	e0bffc15 	stw	r2,-16(fp)
811402e4:	e0bffc17 	ldw	r2,-16(fp)
811402e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811402ec:	0005883a 	mov	r2,zero
}
811402f0:	e037883a 	mov	sp,fp
811402f4:	dfc00117 	ldw	ra,4(sp)
811402f8:	df000017 	ldw	fp,0(sp)
811402fc:	dec00204 	addi	sp,sp,8
81140300:	f800283a 	ret

81140304 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
81140304:	defff504 	addi	sp,sp,-44
81140308:	de00012e 	bgeu	sp,et,81140310 <OSQPostOpt+0xc>
8114030c:	003b68fa 	trap	3
81140310:	dfc00a15 	stw	ra,40(sp)
81140314:	df000915 	stw	fp,36(sp)
81140318:	df000904 	addi	fp,sp,36
8114031c:	e13ffd15 	stw	r4,-12(fp)
81140320:	e17ffe15 	stw	r5,-8(fp)
81140324:	3005883a 	mov	r2,r6
81140328:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8114032c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140330:	e0bffd17 	ldw	r2,-12(fp)
81140334:	1000021e 	bne	r2,zero,81140340 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81140338:	00800104 	movi	r2,4
8114033c:	00007106 	br	81140504 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81140340:	e0bffd17 	ldw	r2,-12(fp)
81140344:	10800003 	ldbu	r2,0(r2)
81140348:	10803fcc 	andi	r2,r2,255
8114034c:	108000a0 	cmpeqi	r2,r2,2
81140350:	1000021e 	bne	r2,zero,8114035c <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81140354:	00800044 	movi	r2,1
81140358:	00006a06 	br	81140504 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114035c:	0005303a 	rdctl	r2,status
81140360:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140364:	e0fffc17 	ldw	r3,-16(fp)
81140368:	00bfff84 	movi	r2,-2
8114036c:	1884703a 	and	r2,r3,r2
81140370:	1001703a 	wrctl	status,r2
  
  return context;
81140374:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140378:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8114037c:	e0bffd17 	ldw	r2,-12(fp)
81140380:	10800283 	ldbu	r2,10(r2)
81140384:	10803fcc 	andi	r2,r2,255
81140388:	10001d26 	beq	r2,zero,81140400 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8114038c:	e0bfff03 	ldbu	r2,-4(fp)
81140390:	1080004c 	andi	r2,r2,1
81140394:	10000b26 	beq	r2,zero,811403c4 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81140398:	00000506 	br	811403b0 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8114039c:	000f883a 	mov	r7,zero
811403a0:	01800104 	movi	r6,4
811403a4:	e17ffe17 	ldw	r5,-8(fp)
811403a8:	e13ffd17 	ldw	r4,-12(fp)
811403ac:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
811403b0:	e0bffd17 	ldw	r2,-12(fp)
811403b4:	10800283 	ldbu	r2,10(r2)
811403b8:	10803fcc 	andi	r2,r2,255
811403bc:	103ff71e 	bne	r2,zero,8114039c <__reset+0xfb12039c>
811403c0:	00000506 	br	811403d8 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811403c4:	000f883a 	mov	r7,zero
811403c8:	01800104 	movi	r6,4
811403cc:	e17ffe17 	ldw	r5,-8(fp)
811403d0:	e13ffd17 	ldw	r4,-12(fp)
811403d4:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
811403d8:	e0bff717 	ldw	r2,-36(fp)
811403dc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811403e0:	e0bff817 	ldw	r2,-32(fp)
811403e4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
811403e8:	e0bfff03 	ldbu	r2,-4(fp)
811403ec:	1080010c 	andi	r2,r2,4
811403f0:	1000011e 	bne	r2,zero,811403f8 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
811403f4:	113bc5c0 	call	8113bc5c <OS_Sched>
        }
        return (OS_ERR_NONE);
811403f8:	0005883a 	mov	r2,zero
811403fc:	00004106 	br	81140504 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81140400:	e0bffd17 	ldw	r2,-12(fp)
81140404:	10800117 	ldw	r2,4(r2)
81140408:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8114040c:	e0bffa17 	ldw	r2,-24(fp)
81140410:	10c0058b 	ldhu	r3,22(r2)
81140414:	e0bffa17 	ldw	r2,-24(fp)
81140418:	1080050b 	ldhu	r2,20(r2)
8114041c:	18ffffcc 	andi	r3,r3,65535
81140420:	10bfffcc 	andi	r2,r2,65535
81140424:	18800636 	bltu	r3,r2,81140440 <OSQPostOpt+0x13c>
81140428:	e0bff717 	ldw	r2,-36(fp)
8114042c:	e0bff915 	stw	r2,-28(fp)
81140430:	e0bff917 	ldw	r2,-28(fp)
81140434:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81140438:	00800784 	movi	r2,30
8114043c:	00003106 	br	81140504 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81140440:	e0bfff03 	ldbu	r2,-4(fp)
81140444:	1080008c 	andi	r2,r2,2
81140448:	10001326 	beq	r2,zero,81140498 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8114044c:	e0bffa17 	ldw	r2,-24(fp)
81140450:	10c00417 	ldw	r3,16(r2)
81140454:	e0bffa17 	ldw	r2,-24(fp)
81140458:	10800117 	ldw	r2,4(r2)
8114045c:	1880041e 	bne	r3,r2,81140470 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
81140460:	e0bffa17 	ldw	r2,-24(fp)
81140464:	10c00217 	ldw	r3,8(r2)
81140468:	e0bffa17 	ldw	r2,-24(fp)
8114046c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
81140470:	e0bffa17 	ldw	r2,-24(fp)
81140474:	10800417 	ldw	r2,16(r2)
81140478:	10ffff04 	addi	r3,r2,-4
8114047c:	e0bffa17 	ldw	r2,-24(fp)
81140480:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
81140484:	e0bffa17 	ldw	r2,-24(fp)
81140488:	10800417 	ldw	r2,16(r2)
8114048c:	e0fffe17 	ldw	r3,-8(fp)
81140490:	10c00015 	stw	r3,0(r2)
81140494:	00001006 	br	811404d8 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
81140498:	e0bffa17 	ldw	r2,-24(fp)
8114049c:	10800317 	ldw	r2,12(r2)
811404a0:	11000104 	addi	r4,r2,4
811404a4:	e0fffa17 	ldw	r3,-24(fp)
811404a8:	19000315 	stw	r4,12(r3)
811404ac:	e0fffe17 	ldw	r3,-8(fp)
811404b0:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
811404b4:	e0bffa17 	ldw	r2,-24(fp)
811404b8:	10c00317 	ldw	r3,12(r2)
811404bc:	e0bffa17 	ldw	r2,-24(fp)
811404c0:	10800217 	ldw	r2,8(r2)
811404c4:	1880041e 	bne	r3,r2,811404d8 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
811404c8:	e0bffa17 	ldw	r2,-24(fp)
811404cc:	10c00117 	ldw	r3,4(r2)
811404d0:	e0bffa17 	ldw	r2,-24(fp)
811404d4:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
811404d8:	e0bffa17 	ldw	r2,-24(fp)
811404dc:	1080058b 	ldhu	r2,22(r2)
811404e0:	10800044 	addi	r2,r2,1
811404e4:	1007883a 	mov	r3,r2
811404e8:	e0bffa17 	ldw	r2,-24(fp)
811404ec:	10c0058d 	sth	r3,22(r2)
811404f0:	e0bff717 	ldw	r2,-36(fp)
811404f4:	e0bffb15 	stw	r2,-20(fp)
811404f8:	e0bffb17 	ldw	r2,-20(fp)
811404fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140500:	0005883a 	mov	r2,zero
}
81140504:	e037883a 	mov	sp,fp
81140508:	dfc00117 	ldw	ra,4(sp)
8114050c:	df000017 	ldw	fp,0(sp)
81140510:	dec00204 	addi	sp,sp,8
81140514:	f800283a 	ret

81140518 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81140518:	defff604 	addi	sp,sp,-40
8114051c:	de00012e 	bgeu	sp,et,81140524 <OSQQuery+0xc>
81140520:	003b68fa 	trap	3
81140524:	df000915 	stw	fp,36(sp)
81140528:	df000904 	addi	fp,sp,36
8114052c:	e13ffe15 	stw	r4,-8(fp)
81140530:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81140534:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81140538:	e0bffe17 	ldw	r2,-8(fp)
8114053c:	1000021e 	bne	r2,zero,81140548 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81140540:	00800104 	movi	r2,4
81140544:	00004906 	br	8114066c <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81140548:	e0bfff17 	ldw	r2,-4(fp)
8114054c:	1000021e 	bne	r2,zero,81140558 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81140550:	00800244 	movi	r2,9
81140554:	00004506 	br	8114066c <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81140558:	e0bffe17 	ldw	r2,-8(fp)
8114055c:	10800003 	ldbu	r2,0(r2)
81140560:	10803fcc 	andi	r2,r2,255
81140564:	108000a0 	cmpeqi	r2,r2,2
81140568:	1000021e 	bne	r2,zero,81140574 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8114056c:	00800044 	movi	r2,1
81140570:	00003e06 	br	8114066c <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140574:	0005303a 	rdctl	r2,status
81140578:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114057c:	e0fffd17 	ldw	r3,-12(fp)
81140580:	00bfff84 	movi	r2,-2
81140584:	1884703a 	and	r2,r3,r2
81140588:	1001703a 	wrctl	status,r2
  
  return context;
8114058c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81140590:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
81140594:	e0bffe17 	ldw	r2,-8(fp)
81140598:	10c00283 	ldbu	r3,10(r2)
8114059c:	e0bfff17 	ldw	r2,-4(fp)
811405a0:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
811405a4:	e0bffe17 	ldw	r2,-8(fp)
811405a8:	108002c4 	addi	r2,r2,11
811405ac:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
811405b0:	e0bfff17 	ldw	r2,-4(fp)
811405b4:	10800204 	addi	r2,r2,8
811405b8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811405bc:	e03ff705 	stb	zero,-36(fp)
811405c0:	00000b06 	br	811405f0 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
811405c4:	e0bff917 	ldw	r2,-28(fp)
811405c8:	10c00044 	addi	r3,r2,1
811405cc:	e0fff915 	stw	r3,-28(fp)
811405d0:	e0fff817 	ldw	r3,-32(fp)
811405d4:	19000044 	addi	r4,r3,1
811405d8:	e13ff815 	stw	r4,-32(fp)
811405dc:	18c00003 	ldbu	r3,0(r3)
811405e0:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811405e4:	e0bff703 	ldbu	r2,-36(fp)
811405e8:	10800044 	addi	r2,r2,1
811405ec:	e0bff705 	stb	r2,-36(fp)
811405f0:	e0bff703 	ldbu	r2,-36(fp)
811405f4:	108001b0 	cmpltui	r2,r2,6
811405f8:	103ff21e 	bne	r2,zero,811405c4 <__reset+0xfb1205c4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
811405fc:	e0bffe17 	ldw	r2,-8(fp)
81140600:	10800117 	ldw	r2,4(r2)
81140604:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81140608:	e0bffc17 	ldw	r2,-16(fp)
8114060c:	1080058b 	ldhu	r2,22(r2)
81140610:	10bfffcc 	andi	r2,r2,65535
81140614:	10000626 	beq	r2,zero,81140630 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81140618:	e0bffc17 	ldw	r2,-16(fp)
8114061c:	10800417 	ldw	r2,16(r2)
81140620:	10c00017 	ldw	r3,0(r2)
81140624:	e0bfff17 	ldw	r2,-4(fp)
81140628:	10c00015 	stw	r3,0(r2)
8114062c:	00000206 	br	81140638 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
81140630:	e0bfff17 	ldw	r2,-4(fp)
81140634:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
81140638:	e0bffc17 	ldw	r2,-16(fp)
8114063c:	10c0058b 	ldhu	r3,22(r2)
81140640:	e0bfff17 	ldw	r2,-4(fp)
81140644:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
81140648:	e0bffc17 	ldw	r2,-16(fp)
8114064c:	10c0050b 	ldhu	r3,20(r2)
81140650:	e0bfff17 	ldw	r2,-4(fp)
81140654:	10c0018d 	sth	r3,6(r2)
81140658:	e0bffa17 	ldw	r2,-24(fp)
8114065c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140660:	e0bffb17 	ldw	r2,-20(fp)
81140664:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140668:	0005883a 	mov	r2,zero
}
8114066c:	e037883a 	mov	sp,fp
81140670:	df000017 	ldw	fp,0(sp)
81140674:	dec00104 	addi	sp,sp,4
81140678:	f800283a 	ret

8114067c <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8114067c:	defffb04 	addi	sp,sp,-20
81140680:	de00012e 	bgeu	sp,et,81140688 <OS_QInit+0xc>
81140684:	003b68fa 	trap	3
81140688:	dfc00415 	stw	ra,16(sp)
8114068c:	df000315 	stw	fp,12(sp)
81140690:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
81140694:	0140c004 	movi	r5,768
81140698:	012045f4 	movhi	r4,33047
8114069c:	212cf604 	addi	r4,r4,-19496
811406a0:	113bb900 	call	8113bb90 <OS_MemClr>
    pq1 = &OSQTbl[0];
811406a4:	00a045f4 	movhi	r2,33047
811406a8:	10acf604 	addi	r2,r2,-19496
811406ac:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
811406b0:	00a045f4 	movhi	r2,33047
811406b4:	10acfc04 	addi	r2,r2,-19472
811406b8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
811406bc:	e03ffd0d 	sth	zero,-12(fp)
811406c0:	00000c06 	br	811406f4 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
811406c4:	e0bffe17 	ldw	r2,-8(fp)
811406c8:	e0ffff17 	ldw	r3,-4(fp)
811406cc:	10c00015 	stw	r3,0(r2)
        pq1++;
811406d0:	e0bffe17 	ldw	r2,-8(fp)
811406d4:	10800604 	addi	r2,r2,24
811406d8:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
811406dc:	e0bfff17 	ldw	r2,-4(fp)
811406e0:	10800604 	addi	r2,r2,24
811406e4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
811406e8:	e0bffd0b 	ldhu	r2,-12(fp)
811406ec:	10800044 	addi	r2,r2,1
811406f0:	e0bffd0d 	sth	r2,-12(fp)
811406f4:	e0bffd0b 	ldhu	r2,-12(fp)
811406f8:	108007f0 	cmpltui	r2,r2,31
811406fc:	103ff11e 	bne	r2,zero,811406c4 <__reset+0xfb1206c4>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
81140700:	e0bffe17 	ldw	r2,-8(fp)
81140704:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81140708:	00a045f4 	movhi	r2,33047
8114070c:	10acf604 	addi	r2,r2,-19496
81140710:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
81140714:	0001883a 	nop
81140718:	e037883a 	mov	sp,fp
8114071c:	dfc00117 	ldw	ra,4(sp)
81140720:	df000017 	ldw	fp,0(sp)
81140724:	dec00204 	addi	sp,sp,8
81140728:	f800283a 	ret

8114072c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8114072c:	defffa04 	addi	sp,sp,-24
81140730:	de00012e 	bgeu	sp,et,81140738 <OSSemAccept+0xc>
81140734:	003b68fa 	trap	3
81140738:	df000515 	stw	fp,20(sp)
8114073c:	df000504 	addi	fp,sp,20
81140740:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140744:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140748:	e0bfff17 	ldw	r2,-4(fp)
8114074c:	1000021e 	bne	r2,zero,81140758 <OSSemAccept+0x2c>
        return (0);
81140750:	0005883a 	mov	r2,zero
81140754:	00001f06 	br	811407d4 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140758:	e0bfff17 	ldw	r2,-4(fp)
8114075c:	10800003 	ldbu	r2,0(r2)
81140760:	10803fcc 	andi	r2,r2,255
81140764:	108000e0 	cmpeqi	r2,r2,3
81140768:	1000021e 	bne	r2,zero,81140774 <OSSemAccept+0x48>
        return (0);
8114076c:	0005883a 	mov	r2,zero
81140770:	00001806 	br	811407d4 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140774:	0005303a 	rdctl	r2,status
81140778:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114077c:	e0fffe17 	ldw	r3,-8(fp)
81140780:	00bfff84 	movi	r2,-2
81140784:	1884703a 	and	r2,r3,r2
81140788:	1001703a 	wrctl	status,r2
  
  return context;
8114078c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140790:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
81140794:	e0bfff17 	ldw	r2,-4(fp)
81140798:	1080020b 	ldhu	r2,8(r2)
8114079c:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
811407a0:	e0bffd0b 	ldhu	r2,-12(fp)
811407a4:	10000626 	beq	r2,zero,811407c0 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
811407a8:	e0bfff17 	ldw	r2,-4(fp)
811407ac:	1080020b 	ldhu	r2,8(r2)
811407b0:	10bfffc4 	addi	r2,r2,-1
811407b4:	1007883a 	mov	r3,r2
811407b8:	e0bfff17 	ldw	r2,-4(fp)
811407bc:	10c0020d 	sth	r3,8(r2)
811407c0:	e0bffb17 	ldw	r2,-20(fp)
811407c4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811407c8:	e0bffc17 	ldw	r2,-16(fp)
811407cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
811407d0:	e0bffd0b 	ldhu	r2,-12(fp)
}
811407d4:	e037883a 	mov	sp,fp
811407d8:	df000017 	ldw	fp,0(sp)
811407dc:	dec00104 	addi	sp,sp,4
811407e0:	f800283a 	ret

811407e4 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
811407e4:	defff904 	addi	sp,sp,-28
811407e8:	de00012e 	bgeu	sp,et,811407f0 <OSSemCreate+0xc>
811407ec:	003b68fa 	trap	3
811407f0:	dfc00615 	stw	ra,24(sp)
811407f4:	df000515 	stw	fp,20(sp)
811407f8:	df000504 	addi	fp,sp,20
811407fc:	2005883a 	mov	r2,r4
81140800:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81140804:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81140808:	d0a0a103 	ldbu	r2,-32124(gp)
8114080c:	10803fcc 	andi	r2,r2,255
81140810:	10000226 	beq	r2,zero,8114081c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81140814:	0005883a 	mov	r2,zero
81140818:	00002506 	br	811408b0 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114081c:	0005303a 	rdctl	r2,status
81140820:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140824:	e0fffe17 	ldw	r3,-8(fp)
81140828:	00bfff84 	movi	r2,-2
8114082c:	1884703a 	and	r2,r3,r2
81140830:	1001703a 	wrctl	status,r2
  
  return context;
81140834:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140838:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8114083c:	d0a0a017 	ldw	r2,-32128(gp)
81140840:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
81140844:	d0a0a017 	ldw	r2,-32128(gp)
81140848:	10000326 	beq	r2,zero,81140858 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8114084c:	d0a0a017 	ldw	r2,-32128(gp)
81140850:	10800117 	ldw	r2,4(r2)
81140854:	d0a0a015 	stw	r2,-32128(gp)
81140858:	e0bffb17 	ldw	r2,-20(fp)
8114085c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140860:	e0bffc17 	ldw	r2,-16(fp)
81140864:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
81140868:	e0bffd17 	ldw	r2,-12(fp)
8114086c:	10000f26 	beq	r2,zero,811408ac <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
81140870:	e0bffd17 	ldw	r2,-12(fp)
81140874:	00c000c4 	movi	r3,3
81140878:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8114087c:	e0bffd17 	ldw	r2,-12(fp)
81140880:	e0ffff0b 	ldhu	r3,-4(fp)
81140884:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
81140888:	e0bffd17 	ldw	r2,-12(fp)
8114088c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
81140890:	e0bffd17 	ldw	r2,-12(fp)
81140894:	00c00fc4 	movi	r3,63
81140898:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8114089c:	e0bffd17 	ldw	r2,-12(fp)
811408a0:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
811408a4:	e13ffd17 	ldw	r4,-12(fp)
811408a8:	113b7780 	call	8113b778 <OS_EventWaitListInit>
    }
    return (pevent);
811408ac:	e0bffd17 	ldw	r2,-12(fp)
}
811408b0:	e037883a 	mov	sp,fp
811408b4:	dfc00117 	ldw	ra,4(sp)
811408b8:	df000017 	ldw	fp,0(sp)
811408bc:	dec00204 	addi	sp,sp,8
811408c0:	f800283a 	ret

811408c4 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811408c4:	defff304 	addi	sp,sp,-52
811408c8:	de00012e 	bgeu	sp,et,811408d0 <OSSemDel+0xc>
811408cc:	003b68fa 	trap	3
811408d0:	dfc00c15 	stw	ra,48(sp)
811408d4:	df000b15 	stw	fp,44(sp)
811408d8:	df000b04 	addi	fp,sp,44
811408dc:	e13ffd15 	stw	r4,-12(fp)
811408e0:	2805883a 	mov	r2,r5
811408e4:	e1bfff15 	stw	r6,-4(fp)
811408e8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811408ec:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811408f0:	e0bfff17 	ldw	r2,-4(fp)
811408f4:	1000021e 	bne	r2,zero,81140900 <OSSemDel+0x3c>
        return (pevent);
811408f8:	e0bffd17 	ldw	r2,-12(fp)
811408fc:	00007e06 	br	81140af8 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81140900:	e0bffd17 	ldw	r2,-12(fp)
81140904:	1000051e 	bne	r2,zero,8114091c <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81140908:	e0bfff17 	ldw	r2,-4(fp)
8114090c:	00c00104 	movi	r3,4
81140910:	10c00005 	stb	r3,0(r2)
        return (pevent);
81140914:	e0bffd17 	ldw	r2,-12(fp)
81140918:	00007706 	br	81140af8 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8114091c:	e0bffd17 	ldw	r2,-12(fp)
81140920:	10800003 	ldbu	r2,0(r2)
81140924:	10803fcc 	andi	r2,r2,255
81140928:	108000e0 	cmpeqi	r2,r2,3
8114092c:	1000051e 	bne	r2,zero,81140944 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81140930:	e0bfff17 	ldw	r2,-4(fp)
81140934:	00c00044 	movi	r3,1
81140938:	10c00005 	stb	r3,0(r2)
        return (pevent);
8114093c:	e0bffd17 	ldw	r2,-12(fp)
81140940:	00006d06 	br	81140af8 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81140944:	d0a0a103 	ldbu	r2,-32124(gp)
81140948:	10803fcc 	andi	r2,r2,255
8114094c:	10000526 	beq	r2,zero,81140964 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
81140950:	e0bfff17 	ldw	r2,-4(fp)
81140954:	00c003c4 	movi	r3,15
81140958:	10c00005 	stb	r3,0(r2)
        return (pevent);
8114095c:	e0bffd17 	ldw	r2,-12(fp)
81140960:	00006506 	br	81140af8 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140964:	0005303a 	rdctl	r2,status
81140968:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114096c:	e0fffc17 	ldw	r3,-16(fp)
81140970:	00bfff84 	movi	r2,-2
81140974:	1884703a 	and	r2,r3,r2
81140978:	1001703a 	wrctl	status,r2
  
  return context;
8114097c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140980:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
81140984:	e0bffd17 	ldw	r2,-12(fp)
81140988:	10800283 	ldbu	r2,10(r2)
8114098c:	10803fcc 	andi	r2,r2,255
81140990:	10000326 	beq	r2,zero,811409a0 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81140994:	00800044 	movi	r2,1
81140998:	e0bff505 	stb	r2,-44(fp)
8114099c:	00000106 	br	811409a4 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811409a0:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
811409a4:	e0bffe03 	ldbu	r2,-8(fp)
811409a8:	10000326 	beq	r2,zero,811409b8 <OSSemDel+0xf4>
811409ac:	10800060 	cmpeqi	r2,r2,1
811409b0:	1000281e 	bne	r2,zero,81140a54 <OSSemDel+0x190>
811409b4:	00004506 	br	81140acc <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
811409b8:	e0bff503 	ldbu	r2,-44(fp)
811409bc:	1000161e 	bne	r2,zero,81140a18 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811409c0:	e0bffd17 	ldw	r2,-12(fp)
811409c4:	00c00fc4 	movi	r3,63
811409c8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
811409cc:	e0bffd17 	ldw	r2,-12(fp)
811409d0:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811409d4:	e0bffd17 	ldw	r2,-12(fp)
811409d8:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
811409dc:	d0e0a017 	ldw	r3,-32128(gp)
811409e0:	e0bffd17 	ldw	r2,-12(fp)
811409e4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
811409e8:	e0bffd17 	ldw	r2,-12(fp)
811409ec:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
811409f0:	e0bffd17 	ldw	r2,-12(fp)
811409f4:	d0a0a015 	stw	r2,-32128(gp)
811409f8:	e0bff717 	ldw	r2,-36(fp)
811409fc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140a00:	e0bff817 	ldw	r2,-32(fp)
81140a04:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81140a08:	e0bfff17 	ldw	r2,-4(fp)
81140a0c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81140a10:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81140a14:	00003706 	br	81140af4 <OSSemDel+0x230>
81140a18:	e0bff717 	ldw	r2,-36(fp)
81140a1c:	e0bff915 	stw	r2,-28(fp)
81140a20:	e0bff917 	ldw	r2,-28(fp)
81140a24:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81140a28:	e0bfff17 	ldw	r2,-4(fp)
81140a2c:	00c01244 	movi	r3,73
81140a30:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81140a34:	e0bffd17 	ldw	r2,-12(fp)
81140a38:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81140a3c:	00002d06 	br	81140af4 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81140a40:	000f883a 	mov	r7,zero
81140a44:	01800044 	movi	r6,1
81140a48:	000b883a 	mov	r5,zero
81140a4c:	e13ffd17 	ldw	r4,-12(fp)
81140a50:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
81140a54:	e0bffd17 	ldw	r2,-12(fp)
81140a58:	10800283 	ldbu	r2,10(r2)
81140a5c:	10803fcc 	andi	r2,r2,255
81140a60:	103ff71e 	bne	r2,zero,81140a40 <__reset+0xfb120a40>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81140a64:	e0bffd17 	ldw	r2,-12(fp)
81140a68:	00c00fc4 	movi	r3,63
81140a6c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81140a70:	e0bffd17 	ldw	r2,-12(fp)
81140a74:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81140a78:	e0bffd17 	ldw	r2,-12(fp)
81140a7c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81140a80:	d0e0a017 	ldw	r3,-32128(gp)
81140a84:	e0bffd17 	ldw	r2,-12(fp)
81140a88:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81140a8c:	e0bffd17 	ldw	r2,-12(fp)
81140a90:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81140a94:	e0bffd17 	ldw	r2,-12(fp)
81140a98:	d0a0a015 	stw	r2,-32128(gp)
81140a9c:	e0bff717 	ldw	r2,-36(fp)
81140aa0:	e0bffa15 	stw	r2,-24(fp)
81140aa4:	e0bffa17 	ldw	r2,-24(fp)
81140aa8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81140aac:	e0bff503 	ldbu	r2,-44(fp)
81140ab0:	10800058 	cmpnei	r2,r2,1
81140ab4:	1000011e 	bne	r2,zero,81140abc <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81140ab8:	113bc5c0 	call	8113bc5c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81140abc:	e0bfff17 	ldw	r2,-4(fp)
81140ac0:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81140ac4:	e03ff615 	stw	zero,-40(fp)
             break;
81140ac8:	00000a06 	br	81140af4 <OSSemDel+0x230>
81140acc:	e0bff717 	ldw	r2,-36(fp)
81140ad0:	e0bffb15 	stw	r2,-20(fp)
81140ad4:	e0bffb17 	ldw	r2,-20(fp)
81140ad8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81140adc:	e0bfff17 	ldw	r2,-4(fp)
81140ae0:	00c001c4 	movi	r3,7
81140ae4:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81140ae8:	e0bffd17 	ldw	r2,-12(fp)
81140aec:	e0bff615 	stw	r2,-40(fp)
             break;
81140af0:	0001883a 	nop
    }
    return (pevent_return);
81140af4:	e0bff617 	ldw	r2,-40(fp)
}
81140af8:	e037883a 	mov	sp,fp
81140afc:	dfc00117 	ldw	ra,4(sp)
81140b00:	df000017 	ldw	fp,0(sp)
81140b04:	dec00204 	addi	sp,sp,8
81140b08:	f800283a 	ret

81140b0c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81140b0c:	defff504 	addi	sp,sp,-44
81140b10:	de00012e 	bgeu	sp,et,81140b18 <OSSemPend+0xc>
81140b14:	003b68fa 	trap	3
81140b18:	dfc00a15 	stw	ra,40(sp)
81140b1c:	df000915 	stw	fp,36(sp)
81140b20:	df000904 	addi	fp,sp,36
81140b24:	e13ffd15 	stw	r4,-12(fp)
81140b28:	2805883a 	mov	r2,r5
81140b2c:	e1bfff15 	stw	r6,-4(fp)
81140b30:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140b34:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81140b38:	e0bfff17 	ldw	r2,-4(fp)
81140b3c:	10007226 	beq	r2,zero,81140d08 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140b40:	e0bffd17 	ldw	r2,-12(fp)
81140b44:	1000041e 	bne	r2,zero,81140b58 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81140b48:	e0bfff17 	ldw	r2,-4(fp)
81140b4c:	00c00104 	movi	r3,4
81140b50:	10c00005 	stb	r3,0(r2)
        return;
81140b54:	00006d06 	br	81140d0c <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140b58:	e0bffd17 	ldw	r2,-12(fp)
81140b5c:	10800003 	ldbu	r2,0(r2)
81140b60:	10803fcc 	andi	r2,r2,255
81140b64:	108000e0 	cmpeqi	r2,r2,3
81140b68:	1000041e 	bne	r2,zero,81140b7c <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81140b6c:	e0bfff17 	ldw	r2,-4(fp)
81140b70:	00c00044 	movi	r3,1
81140b74:	10c00005 	stb	r3,0(r2)
        return;
81140b78:	00006406 	br	81140d0c <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81140b7c:	d0a0a103 	ldbu	r2,-32124(gp)
81140b80:	10803fcc 	andi	r2,r2,255
81140b84:	10000426 	beq	r2,zero,81140b98 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
81140b88:	e0bfff17 	ldw	r2,-4(fp)
81140b8c:	00c00084 	movi	r3,2
81140b90:	10c00005 	stb	r3,0(r2)
        return;
81140b94:	00005d06 	br	81140d0c <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
81140b98:	d0a08f03 	ldbu	r2,-32196(gp)
81140b9c:	10803fcc 	andi	r2,r2,255
81140ba0:	10000426 	beq	r2,zero,81140bb4 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
81140ba4:	e0bfff17 	ldw	r2,-4(fp)
81140ba8:	00c00344 	movi	r3,13
81140bac:	10c00005 	stb	r3,0(r2)
        return;
81140bb0:	00005606 	br	81140d0c <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140bb4:	0005303a 	rdctl	r2,status
81140bb8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140bbc:	e0fffc17 	ldw	r3,-16(fp)
81140bc0:	00bfff84 	movi	r2,-2
81140bc4:	1884703a 	and	r2,r3,r2
81140bc8:	1001703a 	wrctl	status,r2
  
  return context;
81140bcc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140bd0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81140bd4:	e0bffd17 	ldw	r2,-12(fp)
81140bd8:	1080020b 	ldhu	r2,8(r2)
81140bdc:	10bfffcc 	andi	r2,r2,65535
81140be0:	10000d26 	beq	r2,zero,81140c18 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81140be4:	e0bffd17 	ldw	r2,-12(fp)
81140be8:	1080020b 	ldhu	r2,8(r2)
81140bec:	10bfffc4 	addi	r2,r2,-1
81140bf0:	1007883a 	mov	r3,r2
81140bf4:	e0bffd17 	ldw	r2,-12(fp)
81140bf8:	10c0020d 	sth	r3,8(r2)
81140bfc:	e0bff717 	ldw	r2,-36(fp)
81140c00:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140c04:	e0bff817 	ldw	r2,-32(fp)
81140c08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81140c0c:	e0bfff17 	ldw	r2,-4(fp)
81140c10:	10000005 	stb	zero,0(r2)
        return;
81140c14:	00003d06 	br	81140d0c <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81140c18:	d0a0a217 	ldw	r2,-32120(gp)
81140c1c:	d0e0a217 	ldw	r3,-32120(gp)
81140c20:	18c00c03 	ldbu	r3,48(r3)
81140c24:	18c00054 	ori	r3,r3,1
81140c28:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81140c2c:	d0a0a217 	ldw	r2,-32120(gp)
81140c30:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81140c34:	d0a0a217 	ldw	r2,-32120(gp)
81140c38:	e0fffe0b 	ldhu	r3,-8(fp)
81140c3c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81140c40:	e13ffd17 	ldw	r4,-12(fp)
81140c44:	113b3400 	call	8113b340 <OS_EventTaskWait>
81140c48:	e0bff717 	ldw	r2,-36(fp)
81140c4c:	e0bffb15 	stw	r2,-20(fp)
81140c50:	e0bffb17 	ldw	r2,-20(fp)
81140c54:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81140c58:	113bc5c0 	call	8113bc5c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140c5c:	0005303a 	rdctl	r2,status
81140c60:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140c64:	e0fff917 	ldw	r3,-28(fp)
81140c68:	00bfff84 	movi	r2,-2
81140c6c:	1884703a 	and	r2,r3,r2
81140c70:	1001703a 	wrctl	status,r2
  
  return context;
81140c74:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81140c78:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81140c7c:	d0a0a217 	ldw	r2,-32120(gp)
81140c80:	10800c43 	ldbu	r2,49(r2)
81140c84:	10803fcc 	andi	r2,r2,255
81140c88:	10000326 	beq	r2,zero,81140c98 <OSSemPend+0x18c>
81140c8c:	108000a0 	cmpeqi	r2,r2,2
81140c90:	1000041e 	bne	r2,zero,81140ca4 <OSSemPend+0x198>
81140c94:	00000706 	br	81140cb4 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81140c98:	e0bfff17 	ldw	r2,-4(fp)
81140c9c:	10000005 	stb	zero,0(r2)
             break;
81140ca0:	00000c06 	br	81140cd4 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81140ca4:	e0bfff17 	ldw	r2,-4(fp)
81140ca8:	00c00384 	movi	r3,14
81140cac:	10c00005 	stb	r3,0(r2)
             break;
81140cb0:	00000806 	br	81140cd4 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81140cb4:	d0a0a217 	ldw	r2,-32120(gp)
81140cb8:	e17ffd17 	ldw	r5,-12(fp)
81140cbc:	1009883a 	mov	r4,r2
81140cc0:	113b5b00 	call	8113b5b0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81140cc4:	e0bfff17 	ldw	r2,-4(fp)
81140cc8:	00c00284 	movi	r3,10
81140ccc:	10c00005 	stb	r3,0(r2)
             break;
81140cd0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81140cd4:	d0a0a217 	ldw	r2,-32120(gp)
81140cd8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81140cdc:	d0a0a217 	ldw	r2,-32120(gp)
81140ce0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81140ce4:	d0a0a217 	ldw	r2,-32120(gp)
81140ce8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81140cec:	d0a0a217 	ldw	r2,-32120(gp)
81140cf0:	10000815 	stw	zero,32(r2)
81140cf4:	e0bff717 	ldw	r2,-36(fp)
81140cf8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140cfc:	e0bffa17 	ldw	r2,-24(fp)
81140d00:	1001703a 	wrctl	status,r2
81140d04:	00000106 	br	81140d0c <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81140d08:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81140d0c:	e037883a 	mov	sp,fp
81140d10:	dfc00117 	ldw	ra,4(sp)
81140d14:	df000017 	ldw	fp,0(sp)
81140d18:	dec00204 	addi	sp,sp,8
81140d1c:	f800283a 	ret

81140d20 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81140d20:	defff604 	addi	sp,sp,-40
81140d24:	de00012e 	bgeu	sp,et,81140d2c <OSSemPendAbort+0xc>
81140d28:	003b68fa 	trap	3
81140d2c:	dfc00915 	stw	ra,36(sp)
81140d30:	df000815 	stw	fp,32(sp)
81140d34:	df000804 	addi	fp,sp,32
81140d38:	e13ffd15 	stw	r4,-12(fp)
81140d3c:	2805883a 	mov	r2,r5
81140d40:	e1bfff15 	stw	r6,-4(fp)
81140d44:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140d48:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81140d4c:	e0bfff17 	ldw	r2,-4(fp)
81140d50:	1000021e 	bne	r2,zero,81140d5c <OSSemPendAbort+0x3c>
        return (0);
81140d54:	0005883a 	mov	r2,zero
81140d58:	00004906 	br	81140e80 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140d5c:	e0bffd17 	ldw	r2,-12(fp)
81140d60:	1000051e 	bne	r2,zero,81140d78 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81140d64:	e0bfff17 	ldw	r2,-4(fp)
81140d68:	00c00104 	movi	r3,4
81140d6c:	10c00005 	stb	r3,0(r2)
        return (0);
81140d70:	0005883a 	mov	r2,zero
81140d74:	00004206 	br	81140e80 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140d78:	e0bffd17 	ldw	r2,-12(fp)
81140d7c:	10800003 	ldbu	r2,0(r2)
81140d80:	10803fcc 	andi	r2,r2,255
81140d84:	108000e0 	cmpeqi	r2,r2,3
81140d88:	1000051e 	bne	r2,zero,81140da0 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81140d8c:	e0bfff17 	ldw	r2,-4(fp)
81140d90:	00c00044 	movi	r3,1
81140d94:	10c00005 	stb	r3,0(r2)
        return (0);
81140d98:	0005883a 	mov	r2,zero
81140d9c:	00003806 	br	81140e80 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140da0:	0005303a 	rdctl	r2,status
81140da4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140da8:	e0fffc17 	ldw	r3,-16(fp)
81140dac:	00bfff84 	movi	r2,-2
81140db0:	1884703a 	and	r2,r3,r2
81140db4:	1001703a 	wrctl	status,r2
  
  return context;
81140db8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140dbc:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81140dc0:	e0bffd17 	ldw	r2,-12(fp)
81140dc4:	10800283 	ldbu	r2,10(r2)
81140dc8:	10803fcc 	andi	r2,r2,255
81140dcc:	10002526 	beq	r2,zero,81140e64 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81140dd0:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81140dd4:	e0bffe03 	ldbu	r2,-8(fp)
81140dd8:	10800060 	cmpeqi	r2,r2,1
81140ddc:	10000e26 	beq	r2,zero,81140e18 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81140de0:	00000806 	br	81140e04 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81140de4:	01c00084 	movi	r7,2
81140de8:	01800044 	movi	r6,1
81140dec:	000b883a 	mov	r5,zero
81140df0:	e13ffd17 	ldw	r4,-12(fp)
81140df4:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
                     nbr_tasks++;
81140df8:	e0bff803 	ldbu	r2,-32(fp)
81140dfc:	10800044 	addi	r2,r2,1
81140e00:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81140e04:	e0bffd17 	ldw	r2,-12(fp)
81140e08:	10800283 	ldbu	r2,10(r2)
81140e0c:	10803fcc 	andi	r2,r2,255
81140e10:	103ff41e 	bne	r2,zero,81140de4 <__reset+0xfb120de4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81140e14:	00000906 	br	81140e3c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81140e18:	01c00084 	movi	r7,2
81140e1c:	01800044 	movi	r6,1
81140e20:	000b883a 	mov	r5,zero
81140e24:	e13ffd17 	ldw	r4,-12(fp)
81140e28:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
                 nbr_tasks++;
81140e2c:	e0bff803 	ldbu	r2,-32(fp)
81140e30:	10800044 	addi	r2,r2,1
81140e34:	e0bff805 	stb	r2,-32(fp)
                 break;
81140e38:	0001883a 	nop
81140e3c:	e0bff917 	ldw	r2,-28(fp)
81140e40:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140e44:	e0bffa17 	ldw	r2,-24(fp)
81140e48:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81140e4c:	113bc5c0 	call	8113bc5c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81140e50:	e0bfff17 	ldw	r2,-4(fp)
81140e54:	00c00384 	movi	r3,14
81140e58:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81140e5c:	e0bff803 	ldbu	r2,-32(fp)
81140e60:	00000706 	br	81140e80 <OSSemPendAbort+0x160>
81140e64:	e0bff917 	ldw	r2,-28(fp)
81140e68:	e0bffb15 	stw	r2,-20(fp)
81140e6c:	e0bffb17 	ldw	r2,-20(fp)
81140e70:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81140e74:	e0bfff17 	ldw	r2,-4(fp)
81140e78:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
81140e7c:	0005883a 	mov	r2,zero
}
81140e80:	e037883a 	mov	sp,fp
81140e84:	dfc00117 	ldw	ra,4(sp)
81140e88:	df000017 	ldw	fp,0(sp)
81140e8c:	dec00204 	addi	sp,sp,8
81140e90:	f800283a 	ret

81140e94 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81140e94:	defff804 	addi	sp,sp,-32
81140e98:	de00012e 	bgeu	sp,et,81140ea0 <OSSemPost+0xc>
81140e9c:	003b68fa 	trap	3
81140ea0:	dfc00715 	stw	ra,28(sp)
81140ea4:	df000615 	stw	fp,24(sp)
81140ea8:	df000604 	addi	fp,sp,24
81140eac:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140eb0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140eb4:	e0bfff17 	ldw	r2,-4(fp)
81140eb8:	1000021e 	bne	r2,zero,81140ec4 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
81140ebc:	00800104 	movi	r2,4
81140ec0:	00003506 	br	81140f98 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140ec4:	e0bfff17 	ldw	r2,-4(fp)
81140ec8:	10800003 	ldbu	r2,0(r2)
81140ecc:	10803fcc 	andi	r2,r2,255
81140ed0:	108000e0 	cmpeqi	r2,r2,3
81140ed4:	1000021e 	bne	r2,zero,81140ee0 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81140ed8:	00800044 	movi	r2,1
81140edc:	00002e06 	br	81140f98 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140ee0:	0005303a 	rdctl	r2,status
81140ee4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140ee8:	e0fffe17 	ldw	r3,-8(fp)
81140eec:	00bfff84 	movi	r2,-2
81140ef0:	1884703a 	and	r2,r3,r2
81140ef4:	1001703a 	wrctl	status,r2
  
  return context;
81140ef8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140efc:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81140f00:	e0bfff17 	ldw	r2,-4(fp)
81140f04:	10800283 	ldbu	r2,10(r2)
81140f08:	10803fcc 	andi	r2,r2,255
81140f0c:	10000c26 	beq	r2,zero,81140f40 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81140f10:	000f883a 	mov	r7,zero
81140f14:	01800044 	movi	r6,1
81140f18:	000b883a 	mov	r5,zero
81140f1c:	e13fff17 	ldw	r4,-4(fp)
81140f20:	113b1a00 	call	8113b1a0 <OS_EventTaskRdy>
81140f24:	e0bffa17 	ldw	r2,-24(fp)
81140f28:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140f2c:	e0bffb17 	ldw	r2,-20(fp)
81140f30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81140f34:	113bc5c0 	call	8113bc5c <OS_Sched>
        return (OS_ERR_NONE);
81140f38:	0005883a 	mov	r2,zero
81140f3c:	00001606 	br	81140f98 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81140f40:	e0bfff17 	ldw	r2,-4(fp)
81140f44:	1080020b 	ldhu	r2,8(r2)
81140f48:	10ffffcc 	andi	r3,r2,65535
81140f4c:	00bfffd4 	movui	r2,65535
81140f50:	18800c26 	beq	r3,r2,81140f84 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81140f54:	e0bfff17 	ldw	r2,-4(fp)
81140f58:	1080020b 	ldhu	r2,8(r2)
81140f5c:	10800044 	addi	r2,r2,1
81140f60:	1007883a 	mov	r3,r2
81140f64:	e0bfff17 	ldw	r2,-4(fp)
81140f68:	10c0020d 	sth	r3,8(r2)
81140f6c:	e0bffa17 	ldw	r2,-24(fp)
81140f70:	e0bffc15 	stw	r2,-16(fp)
81140f74:	e0bffc17 	ldw	r2,-16(fp)
81140f78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81140f7c:	0005883a 	mov	r2,zero
81140f80:	00000506 	br	81140f98 <OSSemPost+0x104>
81140f84:	e0bffa17 	ldw	r2,-24(fp)
81140f88:	e0bffd15 	stw	r2,-12(fp)
81140f8c:	e0bffd17 	ldw	r2,-12(fp)
81140f90:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81140f94:	00800c84 	movi	r2,50
}
81140f98:	e037883a 	mov	sp,fp
81140f9c:	dfc00117 	ldw	ra,4(sp)
81140fa0:	df000017 	ldw	fp,0(sp)
81140fa4:	dec00204 	addi	sp,sp,8
81140fa8:	f800283a 	ret

81140fac <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
81140fac:	defff704 	addi	sp,sp,-36
81140fb0:	de00012e 	bgeu	sp,et,81140fb8 <OSSemQuery+0xc>
81140fb4:	003b68fa 	trap	3
81140fb8:	df000815 	stw	fp,32(sp)
81140fbc:	df000804 	addi	fp,sp,32
81140fc0:	e13ffe15 	stw	r4,-8(fp)
81140fc4:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81140fc8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81140fcc:	e0bffe17 	ldw	r2,-8(fp)
81140fd0:	1000021e 	bne	r2,zero,81140fdc <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81140fd4:	00800104 	movi	r2,4
81140fd8:	00003606 	br	811410b4 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
81140fdc:	e0bfff17 	ldw	r2,-4(fp)
81140fe0:	1000021e 	bne	r2,zero,81140fec <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81140fe4:	00800244 	movi	r2,9
81140fe8:	00003206 	br	811410b4 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81140fec:	e0bffe17 	ldw	r2,-8(fp)
81140ff0:	10800003 	ldbu	r2,0(r2)
81140ff4:	10803fcc 	andi	r2,r2,255
81140ff8:	108000e0 	cmpeqi	r2,r2,3
81140ffc:	1000021e 	bne	r2,zero,81141008 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81141000:	00800044 	movi	r2,1
81141004:	00002b06 	br	811410b4 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141008:	0005303a 	rdctl	r2,status
8114100c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141010:	e0fffd17 	ldw	r3,-12(fp)
81141014:	00bfff84 	movi	r2,-2
81141018:	1884703a 	and	r2,r3,r2
8114101c:	1001703a 	wrctl	status,r2
  
  return context;
81141020:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81141024:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81141028:	e0bffe17 	ldw	r2,-8(fp)
8114102c:	10c00283 	ldbu	r3,10(r2)
81141030:	e0bfff17 	ldw	r2,-4(fp)
81141034:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81141038:	e0bffe17 	ldw	r2,-8(fp)
8114103c:	108002c4 	addi	r2,r2,11
81141040:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81141044:	e0bfff17 	ldw	r2,-4(fp)
81141048:	10800084 	addi	r2,r2,2
8114104c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81141050:	e03ffa05 	stb	zero,-24(fp)
81141054:	00000b06 	br	81141084 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81141058:	e0bff917 	ldw	r2,-28(fp)
8114105c:	10c00044 	addi	r3,r2,1
81141060:	e0fff915 	stw	r3,-28(fp)
81141064:	e0fff817 	ldw	r3,-32(fp)
81141068:	19000044 	addi	r4,r3,1
8114106c:	e13ff815 	stw	r4,-32(fp)
81141070:	18c00003 	ldbu	r3,0(r3)
81141074:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81141078:	e0bffa03 	ldbu	r2,-24(fp)
8114107c:	10800044 	addi	r2,r2,1
81141080:	e0bffa05 	stb	r2,-24(fp)
81141084:	e0bffa03 	ldbu	r2,-24(fp)
81141088:	108001b0 	cmpltui	r2,r2,6
8114108c:	103ff21e 	bne	r2,zero,81141058 <__reset+0xfb121058>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
81141090:	e0bffe17 	ldw	r2,-8(fp)
81141094:	10c0020b 	ldhu	r3,8(r2)
81141098:	e0bfff17 	ldw	r2,-4(fp)
8114109c:	10c0000d 	sth	r3,0(r2)
811410a0:	e0bffb17 	ldw	r2,-20(fp)
811410a4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811410a8:	e0bffc17 	ldw	r2,-16(fp)
811410ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811410b0:	0005883a 	mov	r2,zero
}
811410b4:	e037883a 	mov	sp,fp
811410b8:	df000017 	ldw	fp,0(sp)
811410bc:	dec00104 	addi	sp,sp,4
811410c0:	f800283a 	ret

811410c4 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
811410c4:	defff904 	addi	sp,sp,-28
811410c8:	de00012e 	bgeu	sp,et,811410d0 <OSSemSet+0xc>
811410cc:	003b68fa 	trap	3
811410d0:	df000615 	stw	fp,24(sp)
811410d4:	df000604 	addi	fp,sp,24
811410d8:	e13ffd15 	stw	r4,-12(fp)
811410dc:	2805883a 	mov	r2,r5
811410e0:	e1bfff15 	stw	r6,-4(fp)
811410e4:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811410e8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811410ec:	e0bfff17 	ldw	r2,-4(fp)
811410f0:	10003126 	beq	r2,zero,811411b8 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811410f4:	e0bffd17 	ldw	r2,-12(fp)
811410f8:	1000041e 	bne	r2,zero,8114110c <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
811410fc:	e0bfff17 	ldw	r2,-4(fp)
81141100:	00c00104 	movi	r3,4
81141104:	10c00005 	stb	r3,0(r2)
        return;
81141108:	00002c06 	br	811411bc <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8114110c:	e0bffd17 	ldw	r2,-12(fp)
81141110:	10800003 	ldbu	r2,0(r2)
81141114:	10803fcc 	andi	r2,r2,255
81141118:	108000e0 	cmpeqi	r2,r2,3
8114111c:	1000041e 	bne	r2,zero,81141130 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81141120:	e0bfff17 	ldw	r2,-4(fp)
81141124:	00c00044 	movi	r3,1
81141128:	10c00005 	stb	r3,0(r2)
        return;
8114112c:	00002306 	br	811411bc <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141130:	0005303a 	rdctl	r2,status
81141134:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141138:	e0fffc17 	ldw	r3,-16(fp)
8114113c:	00bfff84 	movi	r2,-2
81141140:	1884703a 	and	r2,r3,r2
81141144:	1001703a 	wrctl	status,r2
  
  return context;
81141148:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8114114c:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81141150:	e0bfff17 	ldw	r2,-4(fp)
81141154:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81141158:	e0bffd17 	ldw	r2,-12(fp)
8114115c:	1080020b 	ldhu	r2,8(r2)
81141160:	10bfffcc 	andi	r2,r2,65535
81141164:	10000426 	beq	r2,zero,81141178 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81141168:	e0bffd17 	ldw	r2,-12(fp)
8114116c:	e0fffe0b 	ldhu	r3,-8(fp)
81141170:	10c0020d 	sth	r3,8(r2)
81141174:	00000b06 	br	811411a4 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81141178:	e0bffd17 	ldw	r2,-12(fp)
8114117c:	10800283 	ldbu	r2,10(r2)
81141180:	10803fcc 	andi	r2,r2,255
81141184:	1000041e 	bne	r2,zero,81141198 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81141188:	e0bffd17 	ldw	r2,-12(fp)
8114118c:	e0fffe0b 	ldhu	r3,-8(fp)
81141190:	10c0020d 	sth	r3,8(r2)
81141194:	00000306 	br	811411a4 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81141198:	e0bfff17 	ldw	r2,-4(fp)
8114119c:	00c01244 	movi	r3,73
811411a0:	10c00005 	stb	r3,0(r2)
811411a4:	e0bffa17 	ldw	r2,-24(fp)
811411a8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811411ac:	e0bffb17 	ldw	r2,-20(fp)
811411b0:	1001703a 	wrctl	status,r2
811411b4:	00000106 	br	811411bc <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
811411b8:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
811411bc:	e037883a 	mov	sp,fp
811411c0:	df000017 	ldw	fp,0(sp)
811411c4:	dec00104 	addi	sp,sp,4
811411c8:	f800283a 	ret

811411cc <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
811411cc:	defff104 	addi	sp,sp,-60
811411d0:	de00012e 	bgeu	sp,et,811411d8 <OSTaskChangePrio+0xc>
811411d4:	003b68fa 	trap	3
811411d8:	dfc00e15 	stw	ra,56(sp)
811411dc:	df000d15 	stw	fp,52(sp)
811411e0:	df000d04 	addi	fp,sp,52
811411e4:	2007883a 	mov	r3,r4
811411e8:	2805883a 	mov	r2,r5
811411ec:	e0fffe05 	stb	r3,-8(fp)
811411f0:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
811411f4:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
811411f8:	e0bffe03 	ldbu	r2,-8(fp)
811411fc:	10800ab0 	cmpltui	r2,r2,42
81141200:	1000051e 	bne	r2,zero,81141218 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81141204:	e0bffe03 	ldbu	r2,-8(fp)
81141208:	10803fe0 	cmpeqi	r2,r2,255
8114120c:	1000021e 	bne	r2,zero,81141218 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81141210:	00800a84 	movi	r2,42
81141214:	00012606 	br	811416b0 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81141218:	e0bfff03 	ldbu	r2,-4(fp)
8114121c:	10800ab0 	cmpltui	r2,r2,42
81141220:	1000021e 	bne	r2,zero,8114122c <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81141224:	00800a84 	movi	r2,42
81141228:	00012106 	br	811416b0 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114122c:	0005303a 	rdctl	r2,status
81141230:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141234:	e0fffd17 	ldw	r3,-12(fp)
81141238:	00bfff84 	movi	r2,-2
8114123c:	1884703a 	and	r2,r3,r2
81141240:	1001703a 	wrctl	status,r2
  
  return context;
81141244:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141248:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8114124c:	e0ffff03 	ldbu	r3,-4(fp)
81141250:	00a045f4 	movhi	r2,33047
81141254:	10bb6404 	addi	r2,r2,-4720
81141258:	18c7883a 	add	r3,r3,r3
8114125c:	18c7883a 	add	r3,r3,r3
81141260:	10c5883a 	add	r2,r2,r3
81141264:	10800017 	ldw	r2,0(r2)
81141268:	10000626 	beq	r2,zero,81141284 <OSTaskChangePrio+0xb8>
8114126c:	e0bff517 	ldw	r2,-44(fp)
81141270:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141274:	e0bff617 	ldw	r2,-40(fp)
81141278:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8114127c:	00800a04 	movi	r2,40
81141280:	00010b06 	br	811416b0 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81141284:	e0bffe03 	ldbu	r2,-8(fp)
81141288:	10803fd8 	cmpnei	r2,r2,255
8114128c:	1000031e 	bne	r2,zero,8114129c <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
81141290:	d0a0a217 	ldw	r2,-32120(gp)
81141294:	10800c83 	ldbu	r2,50(r2)
81141298:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8114129c:	e0fffe03 	ldbu	r3,-8(fp)
811412a0:	00a045f4 	movhi	r2,33047
811412a4:	10bb6404 	addi	r2,r2,-4720
811412a8:	18c7883a 	add	r3,r3,r3
811412ac:	18c7883a 	add	r3,r3,r3
811412b0:	10c5883a 	add	r2,r2,r3
811412b4:	10800017 	ldw	r2,0(r2)
811412b8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
811412bc:	e0bff817 	ldw	r2,-32(fp)
811412c0:	1000061e 	bne	r2,zero,811412dc <OSTaskChangePrio+0x110>
811412c4:	e0bff517 	ldw	r2,-44(fp)
811412c8:	e0bff715 	stw	r2,-36(fp)
811412cc:	e0bff717 	ldw	r2,-36(fp)
811412d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
811412d4:	00800a44 	movi	r2,41
811412d8:	0000f506 	br	811416b0 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
811412dc:	e0bff817 	ldw	r2,-32(fp)
811412e0:	10800058 	cmpnei	r2,r2,1
811412e4:	1000061e 	bne	r2,zero,81141300 <OSTaskChangePrio+0x134>
811412e8:	e0bff517 	ldw	r2,-44(fp)
811412ec:	e0bff915 	stw	r2,-28(fp)
811412f0:	e0bff917 	ldw	r2,-28(fp)
811412f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
811412f8:	008010c4 	movi	r2,67
811412fc:	0000ec06 	br	811416b0 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81141300:	e0bfff03 	ldbu	r2,-4(fp)
81141304:	1004d0fa 	srli	r2,r2,3
81141308:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8114130c:	e0bfff03 	ldbu	r2,-4(fp)
81141310:	108001cc 	andi	r2,r2,7
81141314:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81141318:	e0bffb03 	ldbu	r2,-20(fp)
8114131c:	00c00044 	movi	r3,1
81141320:	1884983a 	sll	r2,r3,r2
81141324:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81141328:	e0bffb43 	ldbu	r2,-19(fp)
8114132c:	00c00044 	movi	r3,1
81141330:	1884983a 	sll	r2,r3,r2
81141334:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81141338:	e0fffe03 	ldbu	r3,-8(fp)
8114133c:	00a045f4 	movhi	r2,33047
81141340:	10bb6404 	addi	r2,r2,-4720
81141344:	18c7883a 	add	r3,r3,r3
81141348:	18c7883a 	add	r3,r3,r3
8114134c:	10c5883a 	add	r2,r2,r3
81141350:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81141354:	e0ffff03 	ldbu	r3,-4(fp)
81141358:	00a045f4 	movhi	r2,33047
8114135c:	10bb6404 	addi	r2,r2,-4720
81141360:	18c7883a 	add	r3,r3,r3
81141364:	18c7883a 	add	r3,r3,r3
81141368:	10c5883a 	add	r2,r2,r3
8114136c:	e0fff817 	ldw	r3,-32(fp)
81141370:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81141374:	e0bff817 	ldw	r2,-32(fp)
81141378:	10800d03 	ldbu	r2,52(r2)
8114137c:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
81141380:	e0bff817 	ldw	r2,-32(fp)
81141384:	10800d83 	ldbu	r2,54(r2)
81141388:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8114138c:	e0bff817 	ldw	r2,-32(fp)
81141390:	10800d43 	ldbu	r2,53(r2)
81141394:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81141398:	e0fffc03 	ldbu	r3,-16(fp)
8114139c:	d0a09e44 	addi	r2,gp,-32135
811413a0:	1885883a 	add	r2,r3,r2
811413a4:	10c00003 	ldbu	r3,0(r2)
811413a8:	e0bffc83 	ldbu	r2,-14(fp)
811413ac:	1884703a 	and	r2,r3,r2
811413b0:	10803fcc 	andi	r2,r2,255
811413b4:	10002826 	beq	r2,zero,81141458 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
811413b8:	e0fffc03 	ldbu	r3,-16(fp)
811413bc:	e13ffc03 	ldbu	r4,-16(fp)
811413c0:	d0a09e44 	addi	r2,gp,-32135
811413c4:	2085883a 	add	r2,r4,r2
811413c8:	10800003 	ldbu	r2,0(r2)
811413cc:	1009883a 	mov	r4,r2
811413d0:	e0bffc83 	ldbu	r2,-14(fp)
811413d4:	0084303a 	nor	r2,zero,r2
811413d8:	2084703a 	and	r2,r4,r2
811413dc:	1009883a 	mov	r4,r2
811413e0:	d0a09e44 	addi	r2,gp,-32135
811413e4:	1885883a 	add	r2,r3,r2
811413e8:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
811413ec:	e0fffc03 	ldbu	r3,-16(fp)
811413f0:	d0a09e44 	addi	r2,gp,-32135
811413f4:	1885883a 	add	r2,r3,r2
811413f8:	10800003 	ldbu	r2,0(r2)
811413fc:	10803fcc 	andi	r2,r2,255
81141400:	1000061e 	bne	r2,zero,8114141c <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81141404:	e0bffc43 	ldbu	r2,-15(fp)
81141408:	0084303a 	nor	r2,zero,r2
8114140c:	1007883a 	mov	r3,r2
81141410:	d0a09e03 	ldbu	r2,-32136(gp)
81141414:	1884703a 	and	r2,r3,r2
81141418:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8114141c:	d0e09e03 	ldbu	r3,-32136(gp)
81141420:	e0bffb83 	ldbu	r2,-18(fp)
81141424:	1884b03a 	or	r2,r3,r2
81141428:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
8114142c:	e0fffb03 	ldbu	r3,-20(fp)
81141430:	e13ffb03 	ldbu	r4,-20(fp)
81141434:	d0a09e44 	addi	r2,gp,-32135
81141438:	2085883a 	add	r2,r4,r2
8114143c:	11000003 	ldbu	r4,0(r2)
81141440:	e0bffbc3 	ldbu	r2,-17(fp)
81141444:	2084b03a 	or	r2,r4,r2
81141448:	1009883a 	mov	r4,r2
8114144c:	d0a09e44 	addi	r2,gp,-32135
81141450:	1885883a 	add	r2,r3,r2
81141454:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81141458:	e0bff817 	ldw	r2,-32(fp)
8114145c:	10800717 	ldw	r2,28(r2)
81141460:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
81141464:	e0bff317 	ldw	r2,-52(fp)
81141468:	10003326 	beq	r2,zero,81141538 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8114146c:	e0bffc03 	ldbu	r2,-16(fp)
81141470:	e0fffc03 	ldbu	r3,-16(fp)
81141474:	e13ff317 	ldw	r4,-52(fp)
81141478:	20c7883a 	add	r3,r4,r3
8114147c:	18c002c4 	addi	r3,r3,11
81141480:	18c00003 	ldbu	r3,0(r3)
81141484:	1809883a 	mov	r4,r3
81141488:	e0fffc83 	ldbu	r3,-14(fp)
8114148c:	00c6303a 	nor	r3,zero,r3
81141490:	20c6703a 	and	r3,r4,r3
81141494:	1809883a 	mov	r4,r3
81141498:	e0fff317 	ldw	r3,-52(fp)
8114149c:	1885883a 	add	r2,r3,r2
811414a0:	108002c4 	addi	r2,r2,11
811414a4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
811414a8:	e0bffc03 	ldbu	r2,-16(fp)
811414ac:	e0fff317 	ldw	r3,-52(fp)
811414b0:	1885883a 	add	r2,r3,r2
811414b4:	108002c4 	addi	r2,r2,11
811414b8:	10800003 	ldbu	r2,0(r2)
811414bc:	10803fcc 	andi	r2,r2,255
811414c0:	1000091e 	bne	r2,zero,811414e8 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
811414c4:	e0bff317 	ldw	r2,-52(fp)
811414c8:	10800283 	ldbu	r2,10(r2)
811414cc:	1007883a 	mov	r3,r2
811414d0:	e0bffc43 	ldbu	r2,-15(fp)
811414d4:	0084303a 	nor	r2,zero,r2
811414d8:	1884703a 	and	r2,r3,r2
811414dc:	1007883a 	mov	r3,r2
811414e0:	e0bff317 	ldw	r2,-52(fp)
811414e4:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
811414e8:	e0bff317 	ldw	r2,-52(fp)
811414ec:	10c00283 	ldbu	r3,10(r2)
811414f0:	e0bffb83 	ldbu	r2,-18(fp)
811414f4:	1884b03a 	or	r2,r3,r2
811414f8:	1007883a 	mov	r3,r2
811414fc:	e0bff317 	ldw	r2,-52(fp)
81141500:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81141504:	e0bffb03 	ldbu	r2,-20(fp)
81141508:	e0fffb03 	ldbu	r3,-20(fp)
8114150c:	e13ff317 	ldw	r4,-52(fp)
81141510:	20c7883a 	add	r3,r4,r3
81141514:	18c002c4 	addi	r3,r3,11
81141518:	19000003 	ldbu	r4,0(r3)
8114151c:	e0fffbc3 	ldbu	r3,-17(fp)
81141520:	20c6b03a 	or	r3,r4,r3
81141524:	1809883a 	mov	r4,r3
81141528:	e0fff317 	ldw	r3,-52(fp)
8114152c:	1885883a 	add	r2,r3,r2
81141530:	108002c4 	addi	r2,r2,11
81141534:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81141538:	e0bff817 	ldw	r2,-32(fp)
8114153c:	10800817 	ldw	r2,32(r2)
81141540:	10004226 	beq	r2,zero,8114164c <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81141544:	e0bff817 	ldw	r2,-32(fp)
81141548:	10800817 	ldw	r2,32(r2)
8114154c:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
81141550:	e0bff417 	ldw	r2,-48(fp)
81141554:	10800017 	ldw	r2,0(r2)
81141558:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8114155c:	00003906 	br	81141644 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
81141560:	e0bffc03 	ldbu	r2,-16(fp)
81141564:	e0fffc03 	ldbu	r3,-16(fp)
81141568:	e13ff317 	ldw	r4,-52(fp)
8114156c:	20c7883a 	add	r3,r4,r3
81141570:	18c002c4 	addi	r3,r3,11
81141574:	18c00003 	ldbu	r3,0(r3)
81141578:	1809883a 	mov	r4,r3
8114157c:	e0fffc83 	ldbu	r3,-14(fp)
81141580:	00c6303a 	nor	r3,zero,r3
81141584:	20c6703a 	and	r3,r4,r3
81141588:	1809883a 	mov	r4,r3
8114158c:	e0fff317 	ldw	r3,-52(fp)
81141590:	1885883a 	add	r2,r3,r2
81141594:	108002c4 	addi	r2,r2,11
81141598:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8114159c:	e0bffc03 	ldbu	r2,-16(fp)
811415a0:	e0fff317 	ldw	r3,-52(fp)
811415a4:	1885883a 	add	r2,r3,r2
811415a8:	108002c4 	addi	r2,r2,11
811415ac:	10800003 	ldbu	r2,0(r2)
811415b0:	10803fcc 	andi	r2,r2,255
811415b4:	1000091e 	bne	r2,zero,811415dc <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
811415b8:	e0bff317 	ldw	r2,-52(fp)
811415bc:	10800283 	ldbu	r2,10(r2)
811415c0:	1007883a 	mov	r3,r2
811415c4:	e0bffc43 	ldbu	r2,-15(fp)
811415c8:	0084303a 	nor	r2,zero,r2
811415cc:	1884703a 	and	r2,r3,r2
811415d0:	1007883a 	mov	r3,r2
811415d4:	e0bff317 	ldw	r2,-52(fp)
811415d8:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
811415dc:	e0bff317 	ldw	r2,-52(fp)
811415e0:	10c00283 	ldbu	r3,10(r2)
811415e4:	e0bffb83 	ldbu	r2,-18(fp)
811415e8:	1884b03a 	or	r2,r3,r2
811415ec:	1007883a 	mov	r3,r2
811415f0:	e0bff317 	ldw	r2,-52(fp)
811415f4:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
811415f8:	e0bffb03 	ldbu	r2,-20(fp)
811415fc:	e0fffb03 	ldbu	r3,-20(fp)
81141600:	e13ff317 	ldw	r4,-52(fp)
81141604:	20c7883a 	add	r3,r4,r3
81141608:	18c002c4 	addi	r3,r3,11
8114160c:	19000003 	ldbu	r4,0(r3)
81141610:	e0fffbc3 	ldbu	r3,-17(fp)
81141614:	20c6b03a 	or	r3,r4,r3
81141618:	1809883a 	mov	r4,r3
8114161c:	e0fff317 	ldw	r3,-52(fp)
81141620:	1885883a 	add	r2,r3,r2
81141624:	108002c4 	addi	r2,r2,11
81141628:	11000005 	stb	r4,0(r2)
            pevents++;
8114162c:	e0bff417 	ldw	r2,-48(fp)
81141630:	10800104 	addi	r2,r2,4
81141634:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81141638:	e0bff417 	ldw	r2,-48(fp)
8114163c:	10800017 	ldw	r2,0(r2)
81141640:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81141644:	e0bff317 	ldw	r2,-52(fp)
81141648:	103fc51e 	bne	r2,zero,81141560 <__reset+0xfb121560>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8114164c:	e0bff817 	ldw	r2,-32(fp)
81141650:	e0ffff03 	ldbu	r3,-4(fp)
81141654:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
81141658:	e0bff817 	ldw	r2,-32(fp)
8114165c:	e0fffb03 	ldbu	r3,-20(fp)
81141660:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
81141664:	e0bff817 	ldw	r2,-32(fp)
81141668:	e0fffb43 	ldbu	r3,-19(fp)
8114166c:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
81141670:	e0bff817 	ldw	r2,-32(fp)
81141674:	e0fffb83 	ldbu	r3,-18(fp)
81141678:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8114167c:	e0bff817 	ldw	r2,-32(fp)
81141680:	e0fffbc3 	ldbu	r3,-17(fp)
81141684:	10c00d45 	stb	r3,53(r2)
81141688:	e0bff517 	ldw	r2,-44(fp)
8114168c:	e0bffa15 	stw	r2,-24(fp)
81141690:	e0bffa17 	ldw	r2,-24(fp)
81141694:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81141698:	d0a09103 	ldbu	r2,-32188(gp)
8114169c:	10803fcc 	andi	r2,r2,255
811416a0:	10800058 	cmpnei	r2,r2,1
811416a4:	1000011e 	bne	r2,zero,811416ac <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
811416a8:	113bc5c0 	call	8113bc5c <OS_Sched>
    }
    return (OS_ERR_NONE);
811416ac:	0005883a 	mov	r2,zero
}
811416b0:	e037883a 	mov	sp,fp
811416b4:	dfc00117 	ldw	ra,4(sp)
811416b8:	df000017 	ldw	fp,0(sp)
811416bc:	dec00204 	addi	sp,sp,8
811416c0:	f800283a 	ret

811416c4 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
811416c4:	deffee04 	addi	sp,sp,-72
811416c8:	de00012e 	bgeu	sp,et,811416d0 <OSTaskCreate+0xc>
811416cc:	003b68fa 	trap	3
811416d0:	dfc01115 	stw	ra,68(sp)
811416d4:	df001015 	stw	fp,64(sp)
811416d8:	df001004 	addi	fp,sp,64
811416dc:	e13ffc15 	stw	r4,-16(fp)
811416e0:	e17ffd15 	stw	r5,-12(fp)
811416e4:	e1bffe15 	stw	r6,-8(fp)
811416e8:	3805883a 	mov	r2,r7
811416ec:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
811416f0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
811416f4:	e0bfff03 	ldbu	r2,-4(fp)
811416f8:	10800af0 	cmpltui	r2,r2,43
811416fc:	1000021e 	bne	r2,zero,81141708 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
81141700:	00800a84 	movi	r2,42
81141704:	00005706 	br	81141864 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141708:	0005303a 	rdctl	r2,status
8114170c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141710:	e0fffb17 	ldw	r3,-20(fp)
81141714:	00bfff84 	movi	r2,-2
81141718:	1884703a 	and	r2,r3,r2
8114171c:	1001703a 	wrctl	status,r2
  
  return context;
81141720:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141724:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81141728:	d0a0a103 	ldbu	r2,-32124(gp)
8114172c:	10803fcc 	andi	r2,r2,255
81141730:	10000626 	beq	r2,zero,8114174c <OSTaskCreate+0x88>
81141734:	e0bff317 	ldw	r2,-52(fp)
81141738:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114173c:	e0bff417 	ldw	r2,-48(fp)
81141740:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81141744:	00800f04 	movi	r2,60
81141748:	00004606 	br	81141864 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8114174c:	e0ffff03 	ldbu	r3,-4(fp)
81141750:	00a045f4 	movhi	r2,33047
81141754:	10bb6404 	addi	r2,r2,-4720
81141758:	18c7883a 	add	r3,r3,r3
8114175c:	18c7883a 	add	r3,r3,r3
81141760:	10c5883a 	add	r2,r2,r3
81141764:	10800017 	ldw	r2,0(r2)
81141768:	1000391e 	bne	r2,zero,81141850 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8114176c:	e0ffff03 	ldbu	r3,-4(fp)
81141770:	00a045f4 	movhi	r2,33047
81141774:	10bb6404 	addi	r2,r2,-4720
81141778:	18c7883a 	add	r3,r3,r3
8114177c:	18c7883a 	add	r3,r3,r3
81141780:	10c5883a 	add	r2,r2,r3
81141784:	00c00044 	movi	r3,1
81141788:	10c00015 	stw	r3,0(r2)
8114178c:	e0bff317 	ldw	r2,-52(fp)
81141790:	e0bff515 	stw	r2,-44(fp)
81141794:	e0bff517 	ldw	r2,-44(fp)
81141798:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8114179c:	000f883a 	mov	r7,zero
811417a0:	e1bffe17 	ldw	r6,-8(fp)
811417a4:	e17ffd17 	ldw	r5,-12(fp)
811417a8:	e13ffc17 	ldw	r4,-16(fp)
811417ac:	114cd6c0 	call	8114cd6c <OSTaskStkInit>
811417b0:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
811417b4:	e0bfff03 	ldbu	r2,-4(fp)
811417b8:	d8000215 	stw	zero,8(sp)
811417bc:	d8000115 	stw	zero,4(sp)
811417c0:	d8000015 	stw	zero,0(sp)
811417c4:	000f883a 	mov	r7,zero
811417c8:	000d883a 	mov	r6,zero
811417cc:	e17ff717 	ldw	r5,-36(fp)
811417d0:	1009883a 	mov	r4,r2
811417d4:	113c0a40 	call	8113c0a4 <OS_TCBInit>
811417d8:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
811417dc:	e0bff803 	ldbu	r2,-32(fp)
811417e0:	1000061e 	bne	r2,zero,811417fc <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
811417e4:	d0a09103 	ldbu	r2,-32188(gp)
811417e8:	10803fcc 	andi	r2,r2,255
811417ec:	10800058 	cmpnei	r2,r2,1
811417f0:	1000151e 	bne	r2,zero,81141848 <OSTaskCreate+0x184>
                OS_Sched();
811417f4:	113bc5c0 	call	8113bc5c <OS_Sched>
811417f8:	00001306 	br	81141848 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811417fc:	0005303a 	rdctl	r2,status
81141800:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141804:	e0fffa17 	ldw	r3,-24(fp)
81141808:	00bfff84 	movi	r2,-2
8114180c:	1884703a 	and	r2,r3,r2
81141810:	1001703a 	wrctl	status,r2
  
  return context;
81141814:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81141818:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8114181c:	e0ffff03 	ldbu	r3,-4(fp)
81141820:	00a045f4 	movhi	r2,33047
81141824:	10bb6404 	addi	r2,r2,-4720
81141828:	18c7883a 	add	r3,r3,r3
8114182c:	18c7883a 	add	r3,r3,r3
81141830:	10c5883a 	add	r2,r2,r3
81141834:	10000015 	stw	zero,0(r2)
81141838:	e0bff317 	ldw	r2,-52(fp)
8114183c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141840:	e0bff617 	ldw	r2,-40(fp)
81141844:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81141848:	e0bff803 	ldbu	r2,-32(fp)
8114184c:	00000506 	br	81141864 <OSTaskCreate+0x1a0>
81141850:	e0bff317 	ldw	r2,-52(fp)
81141854:	e0bff915 	stw	r2,-28(fp)
81141858:	e0bff917 	ldw	r2,-28(fp)
8114185c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81141860:	00800a04 	movi	r2,40
}
81141864:	e037883a 	mov	sp,fp
81141868:	dfc00117 	ldw	ra,4(sp)
8114186c:	df000017 	ldw	fp,0(sp)
81141870:	dec00204 	addi	sp,sp,8
81141874:	f800283a 	ret

81141878 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
81141878:	deffec04 	addi	sp,sp,-80
8114187c:	de00012e 	bgeu	sp,et,81141884 <OSTaskCreateExt+0xc>
81141880:	003b68fa 	trap	3
81141884:	dfc01315 	stw	ra,76(sp)
81141888:	df001215 	stw	fp,72(sp)
8114188c:	df001204 	addi	fp,sp,72
81141890:	e13ffa15 	stw	r4,-24(fp)
81141894:	e17ffb15 	stw	r5,-20(fp)
81141898:	e1bffc15 	stw	r6,-16(fp)
8114189c:	3809883a 	mov	r4,r7
811418a0:	e0c00217 	ldw	r3,8(fp)
811418a4:	e0800617 	ldw	r2,24(fp)
811418a8:	e13ffd05 	stb	r4,-12(fp)
811418ac:	e0fffe0d 	sth	r3,-8(fp)
811418b0:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
811418b4:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
811418b8:	e0bffd03 	ldbu	r2,-12(fp)
811418bc:	10800af0 	cmpltui	r2,r2,43
811418c0:	1000021e 	bne	r2,zero,811418cc <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
811418c4:	00800a84 	movi	r2,42
811418c8:	00006106 	br	81141a50 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811418cc:	0005303a 	rdctl	r2,status
811418d0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811418d4:	e0fff917 	ldw	r3,-28(fp)
811418d8:	00bfff84 	movi	r2,-2
811418dc:	1884703a 	and	r2,r3,r2
811418e0:	1001703a 	wrctl	status,r2
  
  return context;
811418e4:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811418e8:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
811418ec:	d0a0a103 	ldbu	r2,-32124(gp)
811418f0:	10803fcc 	andi	r2,r2,255
811418f4:	10000626 	beq	r2,zero,81141910 <OSTaskCreateExt+0x98>
811418f8:	e0bff117 	ldw	r2,-60(fp)
811418fc:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141900:	e0bff217 	ldw	r2,-56(fp)
81141904:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81141908:	00800f04 	movi	r2,60
8114190c:	00005006 	br	81141a50 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81141910:	e0fffd03 	ldbu	r3,-12(fp)
81141914:	00a045f4 	movhi	r2,33047
81141918:	10bb6404 	addi	r2,r2,-4720
8114191c:	18c7883a 	add	r3,r3,r3
81141920:	18c7883a 	add	r3,r3,r3
81141924:	10c5883a 	add	r2,r2,r3
81141928:	10800017 	ldw	r2,0(r2)
8114192c:	1000431e 	bne	r2,zero,81141a3c <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81141930:	e0fffd03 	ldbu	r3,-12(fp)
81141934:	00a045f4 	movhi	r2,33047
81141938:	10bb6404 	addi	r2,r2,-4720
8114193c:	18c7883a 	add	r3,r3,r3
81141940:	18c7883a 	add	r3,r3,r3
81141944:	10c5883a 	add	r2,r2,r3
81141948:	00c00044 	movi	r3,1
8114194c:	10c00015 	stw	r3,0(r2)
81141950:	e0bff117 	ldw	r2,-60(fp)
81141954:	e0bff315 	stw	r2,-52(fp)
81141958:	e0bff317 	ldw	r2,-52(fp)
8114195c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
81141960:	e0bfff0b 	ldhu	r2,-4(fp)
81141964:	100d883a 	mov	r6,r2
81141968:	e1400417 	ldw	r5,16(fp)
8114196c:	e1000317 	ldw	r4,12(fp)
81141970:	11429200 	call	81142920 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
81141974:	e0bfff0b 	ldhu	r2,-4(fp)
81141978:	100f883a 	mov	r7,r2
8114197c:	e1bffc17 	ldw	r6,-16(fp)
81141980:	e17ffb17 	ldw	r5,-20(fp)
81141984:	e13ffa17 	ldw	r4,-24(fp)
81141988:	114cd6c0 	call	8114cd6c <OSTaskStkInit>
8114198c:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
81141990:	e0fffd03 	ldbu	r3,-12(fp)
81141994:	e13ffe0b 	ldhu	r4,-8(fp)
81141998:	e0bfff0b 	ldhu	r2,-4(fp)
8114199c:	d8800215 	stw	r2,8(sp)
811419a0:	e0800517 	ldw	r2,20(fp)
811419a4:	d8800115 	stw	r2,4(sp)
811419a8:	e0800417 	ldw	r2,16(fp)
811419ac:	d8800015 	stw	r2,0(sp)
811419b0:	200f883a 	mov	r7,r4
811419b4:	e1800317 	ldw	r6,12(fp)
811419b8:	e17ff517 	ldw	r5,-44(fp)
811419bc:	1809883a 	mov	r4,r3
811419c0:	113c0a40 	call	8113c0a4 <OS_TCBInit>
811419c4:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
811419c8:	e0bff603 	ldbu	r2,-40(fp)
811419cc:	1000061e 	bne	r2,zero,811419e8 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
811419d0:	d0a09103 	ldbu	r2,-32188(gp)
811419d4:	10803fcc 	andi	r2,r2,255
811419d8:	10800058 	cmpnei	r2,r2,1
811419dc:	1000151e 	bne	r2,zero,81141a34 <OSTaskCreateExt+0x1bc>
                OS_Sched();
811419e0:	113bc5c0 	call	8113bc5c <OS_Sched>
811419e4:	00001306 	br	81141a34 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811419e8:	0005303a 	rdctl	r2,status
811419ec:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811419f0:	e0fff817 	ldw	r3,-32(fp)
811419f4:	00bfff84 	movi	r2,-2
811419f8:	1884703a 	and	r2,r3,r2
811419fc:	1001703a 	wrctl	status,r2
  
  return context;
81141a00:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81141a04:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81141a08:	e0fffd03 	ldbu	r3,-12(fp)
81141a0c:	00a045f4 	movhi	r2,33047
81141a10:	10bb6404 	addi	r2,r2,-4720
81141a14:	18c7883a 	add	r3,r3,r3
81141a18:	18c7883a 	add	r3,r3,r3
81141a1c:	10c5883a 	add	r2,r2,r3
81141a20:	10000015 	stw	zero,0(r2)
81141a24:	e0bff117 	ldw	r2,-60(fp)
81141a28:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141a2c:	e0bff417 	ldw	r2,-48(fp)
81141a30:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81141a34:	e0bff603 	ldbu	r2,-40(fp)
81141a38:	00000506 	br	81141a50 <OSTaskCreateExt+0x1d8>
81141a3c:	e0bff117 	ldw	r2,-60(fp)
81141a40:	e0bff715 	stw	r2,-36(fp)
81141a44:	e0bff717 	ldw	r2,-36(fp)
81141a48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81141a4c:	00800a04 	movi	r2,40
}
81141a50:	e037883a 	mov	sp,fp
81141a54:	dfc00117 	ldw	ra,4(sp)
81141a58:	df000017 	ldw	fp,0(sp)
81141a5c:	dec00204 	addi	sp,sp,8
81141a60:	f800283a 	ret

81141a64 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
81141a64:	defff404 	addi	sp,sp,-48
81141a68:	de00012e 	bgeu	sp,et,81141a70 <OSTaskDel+0xc>
81141a6c:	003b68fa 	trap	3
81141a70:	dfc00b15 	stw	ra,44(sp)
81141a74:	df000a15 	stw	fp,40(sp)
81141a78:	df000a04 	addi	fp,sp,40
81141a7c:	2005883a 	mov	r2,r4
81141a80:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
81141a84:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
81141a88:	d0a0a103 	ldbu	r2,-32124(gp)
81141a8c:	10803fcc 	andi	r2,r2,255
81141a90:	10000226 	beq	r2,zero,81141a9c <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81141a94:	00801004 	movi	r2,64
81141a98:	0000c006 	br	81141d9c <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
81141a9c:	e0bfff03 	ldbu	r2,-4(fp)
81141aa0:	10800a98 	cmpnei	r2,r2,42
81141aa4:	1000021e 	bne	r2,zero,81141ab0 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81141aa8:	00800f84 	movi	r2,62
81141aac:	0000bb06 	br	81141d9c <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81141ab0:	e0bfff03 	ldbu	r2,-4(fp)
81141ab4:	10800ab0 	cmpltui	r2,r2,42
81141ab8:	1000051e 	bne	r2,zero,81141ad0 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81141abc:	e0bfff03 	ldbu	r2,-4(fp)
81141ac0:	10803fe0 	cmpeqi	r2,r2,255
81141ac4:	1000021e 	bne	r2,zero,81141ad0 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81141ac8:	00800a84 	movi	r2,42
81141acc:	0000b306 	br	81141d9c <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141ad0:	0005303a 	rdctl	r2,status
81141ad4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141ad8:	e0fffe17 	ldw	r3,-8(fp)
81141adc:	00bfff84 	movi	r2,-2
81141ae0:	1884703a 	and	r2,r3,r2
81141ae4:	1001703a 	wrctl	status,r2
  
  return context;
81141ae8:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81141aec:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81141af0:	e0bfff03 	ldbu	r2,-4(fp)
81141af4:	10803fd8 	cmpnei	r2,r2,255
81141af8:	1000031e 	bne	r2,zero,81141b08 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81141afc:	d0a0a217 	ldw	r2,-32120(gp)
81141b00:	10800c83 	ldbu	r2,50(r2)
81141b04:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141b08:	e0ffff03 	ldbu	r3,-4(fp)
81141b0c:	00a045f4 	movhi	r2,33047
81141b10:	10bb6404 	addi	r2,r2,-4720
81141b14:	18c7883a 	add	r3,r3,r3
81141b18:	18c7883a 	add	r3,r3,r3
81141b1c:	10c5883a 	add	r2,r2,r3
81141b20:	10800017 	ldw	r2,0(r2)
81141b24:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81141b28:	e0bff817 	ldw	r2,-32(fp)
81141b2c:	1000061e 	bne	r2,zero,81141b48 <OSTaskDel+0xe4>
81141b30:	e0bff617 	ldw	r2,-40(fp)
81141b34:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141b38:	e0bff717 	ldw	r2,-36(fp)
81141b3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141b40:	008010c4 	movi	r2,67
81141b44:	00009506 	br	81141d9c <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
81141b48:	e0bff817 	ldw	r2,-32(fp)
81141b4c:	10800058 	cmpnei	r2,r2,1
81141b50:	1000061e 	bne	r2,zero,81141b6c <OSTaskDel+0x108>
81141b54:	e0bff617 	ldw	r2,-40(fp)
81141b58:	e0bff915 	stw	r2,-28(fp)
81141b5c:	e0bff917 	ldw	r2,-28(fp)
81141b60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81141b64:	00800f44 	movi	r2,61
81141b68:	00008c06 	br	81141d9c <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
81141b6c:	e0bff817 	ldw	r2,-32(fp)
81141b70:	10800d03 	ldbu	r2,52(r2)
81141b74:	10c03fcc 	andi	r3,r2,255
81141b78:	e0bff817 	ldw	r2,-32(fp)
81141b7c:	10800d03 	ldbu	r2,52(r2)
81141b80:	11003fcc 	andi	r4,r2,255
81141b84:	d0a09e44 	addi	r2,gp,-32135
81141b88:	2085883a 	add	r2,r4,r2
81141b8c:	10800003 	ldbu	r2,0(r2)
81141b90:	1009883a 	mov	r4,r2
81141b94:	e0bff817 	ldw	r2,-32(fp)
81141b98:	10800d43 	ldbu	r2,53(r2)
81141b9c:	0084303a 	nor	r2,zero,r2
81141ba0:	2084703a 	and	r2,r4,r2
81141ba4:	1009883a 	mov	r4,r2
81141ba8:	d0a09e44 	addi	r2,gp,-32135
81141bac:	1885883a 	add	r2,r3,r2
81141bb0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81141bb4:	e0bff817 	ldw	r2,-32(fp)
81141bb8:	10800d03 	ldbu	r2,52(r2)
81141bbc:	10c03fcc 	andi	r3,r2,255
81141bc0:	d0a09e44 	addi	r2,gp,-32135
81141bc4:	1885883a 	add	r2,r3,r2
81141bc8:	10800003 	ldbu	r2,0(r2)
81141bcc:	10803fcc 	andi	r2,r2,255
81141bd0:	1000071e 	bne	r2,zero,81141bf0 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81141bd4:	e0bff817 	ldw	r2,-32(fp)
81141bd8:	10800d83 	ldbu	r2,54(r2)
81141bdc:	0084303a 	nor	r2,zero,r2
81141be0:	1007883a 	mov	r3,r2
81141be4:	d0a09e03 	ldbu	r2,-32136(gp)
81141be8:	1884703a 	and	r2,r3,r2
81141bec:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81141bf0:	e0bff817 	ldw	r2,-32(fp)
81141bf4:	10800717 	ldw	r2,28(r2)
81141bf8:	10000526 	beq	r2,zero,81141c10 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81141bfc:	e0bff817 	ldw	r2,-32(fp)
81141c00:	10800717 	ldw	r2,28(r2)
81141c04:	100b883a 	mov	r5,r2
81141c08:	e13ff817 	ldw	r4,-32(fp)
81141c0c:	113b5b00 	call	8113b5b0 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
81141c10:	e0bff817 	ldw	r2,-32(fp)
81141c14:	10800817 	ldw	r2,32(r2)
81141c18:	10000526 	beq	r2,zero,81141c30 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81141c1c:	e0bff817 	ldw	r2,-32(fp)
81141c20:	10800817 	ldw	r2,32(r2)
81141c24:	100b883a 	mov	r5,r2
81141c28:	e13ff817 	ldw	r4,-32(fp)
81141c2c:	113b6700 	call	8113b670 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
81141c30:	e0bff817 	ldw	r2,-32(fp)
81141c34:	10800a17 	ldw	r2,40(r2)
81141c38:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
81141c3c:	e0bffb17 	ldw	r2,-20(fp)
81141c40:	10000226 	beq	r2,zero,81141c4c <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
81141c44:	e13ffb17 	ldw	r4,-20(fp)
81141c48:	113dc480 	call	8113dc48 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
81141c4c:	e0bff817 	ldw	r2,-32(fp)
81141c50:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
81141c54:	e0bff817 	ldw	r2,-32(fp)
81141c58:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81141c5c:	e0bff817 	ldw	r2,-32(fp)
81141c60:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
81141c64:	d0a08f03 	ldbu	r2,-32196(gp)
81141c68:	10803fcc 	andi	r2,r2,255
81141c6c:	10803fe0 	cmpeqi	r2,r2,255
81141c70:	1000031e 	bne	r2,zero,81141c80 <OSTaskDel+0x21c>
        OSLockNesting++;
81141c74:	d0a08f03 	ldbu	r2,-32196(gp)
81141c78:	10800044 	addi	r2,r2,1
81141c7c:	d0a08f05 	stb	r2,-32196(gp)
81141c80:	e0bff617 	ldw	r2,-40(fp)
81141c84:	e0bffd15 	stw	r2,-12(fp)
81141c88:	e0bffd17 	ldw	r2,-12(fp)
81141c8c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81141c90:	113b1780 	call	8113b178 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141c94:	0005303a 	rdctl	r2,status
81141c98:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141c9c:	e0fffa17 	ldw	r3,-24(fp)
81141ca0:	00bfff84 	movi	r2,-2
81141ca4:	1884703a 	and	r2,r3,r2
81141ca8:	1001703a 	wrctl	status,r2
  
  return context;
81141cac:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81141cb0:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81141cb4:	d0a08f03 	ldbu	r2,-32196(gp)
81141cb8:	10803fcc 	andi	r2,r2,255
81141cbc:	10000326 	beq	r2,zero,81141ccc <OSTaskDel+0x268>
        OSLockNesting--;
81141cc0:	d0a08f03 	ldbu	r2,-32196(gp)
81141cc4:	10bfffc4 	addi	r2,r2,-1
81141cc8:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81141ccc:	e13ff817 	ldw	r4,-32(fp)
81141cd0:	114cefc0 	call	8114cefc <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81141cd4:	d0a09a43 	ldbu	r2,-32151(gp)
81141cd8:	10bfffc4 	addi	r2,r2,-1
81141cdc:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81141ce0:	e0ffff03 	ldbu	r3,-4(fp)
81141ce4:	00a045f4 	movhi	r2,33047
81141ce8:	10bb6404 	addi	r2,r2,-4720
81141cec:	18c7883a 	add	r3,r3,r3
81141cf0:	18c7883a 	add	r3,r3,r3
81141cf4:	10c5883a 	add	r2,r2,r3
81141cf8:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81141cfc:	e0bff817 	ldw	r2,-32(fp)
81141d00:	10800617 	ldw	r2,24(r2)
81141d04:	1000071e 	bne	r2,zero,81141d24 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81141d08:	e0bff817 	ldw	r2,-32(fp)
81141d0c:	10800517 	ldw	r2,20(r2)
81141d10:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81141d14:	e0bff817 	ldw	r2,-32(fp)
81141d18:	10800517 	ldw	r2,20(r2)
81141d1c:	d0a09415 	stw	r2,-32176(gp)
81141d20:	00000a06 	br	81141d4c <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81141d24:	e0bff817 	ldw	r2,-32(fp)
81141d28:	10800617 	ldw	r2,24(r2)
81141d2c:	e0fff817 	ldw	r3,-32(fp)
81141d30:	18c00517 	ldw	r3,20(r3)
81141d34:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81141d38:	e0bff817 	ldw	r2,-32(fp)
81141d3c:	10800517 	ldw	r2,20(r2)
81141d40:	e0fff817 	ldw	r3,-32(fp)
81141d44:	18c00617 	ldw	r3,24(r3)
81141d48:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
81141d4c:	d0e09917 	ldw	r3,-32156(gp)
81141d50:	e0bff817 	ldw	r2,-32(fp)
81141d54:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
81141d58:	e0bff817 	ldw	r2,-32(fp)
81141d5c:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81141d60:	e0bff817 	ldw	r2,-32(fp)
81141d64:	00c00fc4 	movi	r3,63
81141d68:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81141d6c:	e0bff817 	ldw	r2,-32(fp)
81141d70:	10001345 	stb	zero,77(r2)
81141d74:	e0bff617 	ldw	r2,-40(fp)
81141d78:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141d7c:	e0bffc17 	ldw	r2,-16(fp)
81141d80:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81141d84:	d0a09103 	ldbu	r2,-32188(gp)
81141d88:	10803fcc 	andi	r2,r2,255
81141d8c:	10800058 	cmpnei	r2,r2,1
81141d90:	1000011e 	bne	r2,zero,81141d98 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81141d94:	113bc5c0 	call	8113bc5c <OS_Sched>
    }
    return (OS_ERR_NONE);
81141d98:	0005883a 	mov	r2,zero
}
81141d9c:	e037883a 	mov	sp,fp
81141da0:	dfc00117 	ldw	ra,4(sp)
81141da4:	df000017 	ldw	fp,0(sp)
81141da8:	dec00204 	addi	sp,sp,8
81141dac:	f800283a 	ret

81141db0 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81141db0:	defff504 	addi	sp,sp,-44
81141db4:	de00012e 	bgeu	sp,et,81141dbc <OSTaskDelReq+0xc>
81141db8:	003b68fa 	trap	3
81141dbc:	df000a15 	stw	fp,40(sp)
81141dc0:	df000a04 	addi	fp,sp,40
81141dc4:	2005883a 	mov	r2,r4
81141dc8:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141dcc:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81141dd0:	e0bfff03 	ldbu	r2,-4(fp)
81141dd4:	10800a98 	cmpnei	r2,r2,42
81141dd8:	1000021e 	bne	r2,zero,81141de4 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81141ddc:	00800f84 	movi	r2,62
81141de0:	00004506 	br	81141ef8 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81141de4:	e0bfff03 	ldbu	r2,-4(fp)
81141de8:	10800ab0 	cmpltui	r2,r2,42
81141dec:	1000051e 	bne	r2,zero,81141e04 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81141df0:	e0bfff03 	ldbu	r2,-4(fp)
81141df4:	10803fe0 	cmpeqi	r2,r2,255
81141df8:	1000021e 	bne	r2,zero,81141e04 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81141dfc:	00800a84 	movi	r2,42
81141e00:	00003d06 	br	81141ef8 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
81141e04:	e0bfff03 	ldbu	r2,-4(fp)
81141e08:	10803fd8 	cmpnei	r2,r2,255
81141e0c:	1000111e 	bne	r2,zero,81141e54 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141e10:	0005303a 	rdctl	r2,status
81141e14:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141e18:	e0fff917 	ldw	r3,-28(fp)
81141e1c:	00bfff84 	movi	r2,-2
81141e20:	1884703a 	and	r2,r3,r2
81141e24:	1001703a 	wrctl	status,r2
  
  return context;
81141e28:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81141e2c:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
81141e30:	d0a0a217 	ldw	r2,-32120(gp)
81141e34:	10800dc3 	ldbu	r2,55(r2)
81141e38:	e0bff805 	stb	r2,-32(fp)
81141e3c:	e0bff617 	ldw	r2,-40(fp)
81141e40:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141e44:	e0bffe17 	ldw	r2,-8(fp)
81141e48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
81141e4c:	e0bff803 	ldbu	r2,-32(fp)
81141e50:	00002906 	br	81141ef8 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141e54:	0005303a 	rdctl	r2,status
81141e58:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141e5c:	e0fff717 	ldw	r3,-36(fp)
81141e60:	00bfff84 	movi	r2,-2
81141e64:	1884703a 	and	r2,r3,r2
81141e68:	1001703a 	wrctl	status,r2
  
  return context;
81141e6c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81141e70:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81141e74:	e0ffff03 	ldbu	r3,-4(fp)
81141e78:	00a045f4 	movhi	r2,33047
81141e7c:	10bb6404 	addi	r2,r2,-4720
81141e80:	18c7883a 	add	r3,r3,r3
81141e84:	18c7883a 	add	r3,r3,r3
81141e88:	10c5883a 	add	r2,r2,r3
81141e8c:	10800017 	ldw	r2,0(r2)
81141e90:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81141e94:	e0bffb17 	ldw	r2,-20(fp)
81141e98:	1000061e 	bne	r2,zero,81141eb4 <OSTaskDelReq+0x104>
81141e9c:	e0bff617 	ldw	r2,-40(fp)
81141ea0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141ea4:	e0bffa17 	ldw	r2,-24(fp)
81141ea8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
81141eac:	008010c4 	movi	r2,67
81141eb0:	00001106 	br	81141ef8 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81141eb4:	e0bffb17 	ldw	r2,-20(fp)
81141eb8:	10800058 	cmpnei	r2,r2,1
81141ebc:	1000061e 	bne	r2,zero,81141ed8 <OSTaskDelReq+0x128>
81141ec0:	e0bff617 	ldw	r2,-40(fp)
81141ec4:	e0bffc15 	stw	r2,-16(fp)
81141ec8:	e0bffc17 	ldw	r2,-16(fp)
81141ecc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81141ed0:	00800f44 	movi	r2,61
81141ed4:	00000806 	br	81141ef8 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81141ed8:	e0bffb17 	ldw	r2,-20(fp)
81141edc:	00c00fc4 	movi	r3,63
81141ee0:	10c00dc5 	stb	r3,55(r2)
81141ee4:	e0bff617 	ldw	r2,-40(fp)
81141ee8:	e0bffd15 	stw	r2,-12(fp)
81141eec:	e0bffd17 	ldw	r2,-12(fp)
81141ef0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81141ef4:	0005883a 	mov	r2,zero
}
81141ef8:	e037883a 	mov	sp,fp
81141efc:	df000017 	ldw	fp,0(sp)
81141f00:	dec00104 	addi	sp,sp,4
81141f04:	f800283a 	ret

81141f08 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81141f08:	defff404 	addi	sp,sp,-48
81141f0c:	de00012e 	bgeu	sp,et,81141f14 <OSTaskNameGet+0xc>
81141f10:	003b68fa 	trap	3
81141f14:	dfc00b15 	stw	ra,44(sp)
81141f18:	df000a15 	stw	fp,40(sp)
81141f1c:	df000a04 	addi	fp,sp,40
81141f20:	2005883a 	mov	r2,r4
81141f24:	e17ffe15 	stw	r5,-8(fp)
81141f28:	e1bfff15 	stw	r6,-4(fp)
81141f2c:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
81141f30:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
81141f34:	e0bfff17 	ldw	r2,-4(fp)
81141f38:	1000021e 	bne	r2,zero,81141f44 <OSTaskNameGet+0x3c>
        return (0);
81141f3c:	0005883a 	mov	r2,zero
81141f40:	00005406 	br	81142094 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
81141f44:	e0bffd03 	ldbu	r2,-12(fp)
81141f48:	10800af0 	cmpltui	r2,r2,43
81141f4c:	1000081e 	bne	r2,zero,81141f70 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81141f50:	e0bffd03 	ldbu	r2,-12(fp)
81141f54:	10803fe0 	cmpeqi	r2,r2,255
81141f58:	1000051e 	bne	r2,zero,81141f70 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
81141f5c:	e0bfff17 	ldw	r2,-4(fp)
81141f60:	00c00a84 	movi	r3,42
81141f64:	10c00005 	stb	r3,0(r2)
            return (0);
81141f68:	0005883a 	mov	r2,zero
81141f6c:	00004906 	br	81142094 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81141f70:	e0bffe17 	ldw	r2,-8(fp)
81141f74:	1000051e 	bne	r2,zero,81141f8c <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81141f78:	e0bfff17 	ldw	r2,-4(fp)
81141f7c:	00c00304 	movi	r3,12
81141f80:	10c00005 	stb	r3,0(r2)
        return (0);
81141f84:	0005883a 	mov	r2,zero
81141f88:	00004206 	br	81142094 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
81141f8c:	d0a0a103 	ldbu	r2,-32124(gp)
81141f90:	10803fcc 	andi	r2,r2,255
81141f94:	10000526 	beq	r2,zero,81141fac <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81141f98:	e0bfff17 	ldw	r2,-4(fp)
81141f9c:	00c00444 	movi	r3,17
81141fa0:	10c00005 	stb	r3,0(r2)
        return (0);
81141fa4:	0005883a 	mov	r2,zero
81141fa8:	00003a06 	br	81142094 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141fac:	0005303a 	rdctl	r2,status
81141fb0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141fb4:	e0fffc17 	ldw	r3,-16(fp)
81141fb8:	00bfff84 	movi	r2,-2
81141fbc:	1884703a 	and	r2,r3,r2
81141fc0:	1001703a 	wrctl	status,r2
  
  return context;
81141fc4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81141fc8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81141fcc:	e0bffd03 	ldbu	r2,-12(fp)
81141fd0:	10803fd8 	cmpnei	r2,r2,255
81141fd4:	1000031e 	bne	r2,zero,81141fe4 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81141fd8:	d0a0a217 	ldw	r2,-32120(gp)
81141fdc:	10800c83 	ldbu	r2,50(r2)
81141fe0:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141fe4:	e0fffd03 	ldbu	r3,-12(fp)
81141fe8:	00a045f4 	movhi	r2,33047
81141fec:	10bb6404 	addi	r2,r2,-4720
81141ff0:	18c7883a 	add	r3,r3,r3
81141ff4:	18c7883a 	add	r3,r3,r3
81141ff8:	10c5883a 	add	r2,r2,r3
81141ffc:	10800017 	ldw	r2,0(r2)
81142000:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81142004:	e0bff817 	ldw	r2,-32(fp)
81142008:	1000091e 	bne	r2,zero,81142030 <OSTaskNameGet+0x128>
8114200c:	e0bff617 	ldw	r2,-40(fp)
81142010:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142014:	e0bff717 	ldw	r2,-36(fp)
81142018:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8114201c:	e0bfff17 	ldw	r2,-4(fp)
81142020:	00c010c4 	movi	r3,67
81142024:	10c00005 	stb	r3,0(r2)
        return (0);
81142028:	0005883a 	mov	r2,zero
8114202c:	00001906 	br	81142094 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81142030:	e0bff817 	ldw	r2,-32(fp)
81142034:	10800058 	cmpnei	r2,r2,1
81142038:	1000091e 	bne	r2,zero,81142060 <OSTaskNameGet+0x158>
8114203c:	e0bff617 	ldw	r2,-40(fp)
81142040:	e0bff915 	stw	r2,-28(fp)
81142044:	e0bff917 	ldw	r2,-28(fp)
81142048:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8114204c:	e0bfff17 	ldw	r2,-4(fp)
81142050:	00c010c4 	movi	r3,67
81142054:	10c00005 	stb	r3,0(r2)
        return (0);
81142058:	0005883a 	mov	r2,zero
8114205c:	00000d06 	br	81142094 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81142060:	e0bff817 	ldw	r2,-32(fp)
81142064:	10801304 	addi	r2,r2,76
81142068:	100b883a 	mov	r5,r2
8114206c:	e13ffe17 	ldw	r4,-8(fp)
81142070:	113bdb00 	call	8113bdb0 <OS_StrCopy>
81142074:	e0bffb05 	stb	r2,-20(fp)
81142078:	e0bff617 	ldw	r2,-40(fp)
8114207c:	e0bffa15 	stw	r2,-24(fp)
81142080:	e0bffa17 	ldw	r2,-24(fp)
81142084:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81142088:	e0bfff17 	ldw	r2,-4(fp)
8114208c:	10000005 	stb	zero,0(r2)
    return (len);
81142090:	e0bffb03 	ldbu	r2,-20(fp)
}
81142094:	e037883a 	mov	sp,fp
81142098:	dfc00117 	ldw	ra,4(sp)
8114209c:	df000017 	ldw	fp,0(sp)
811420a0:	dec00204 	addi	sp,sp,8
811420a4:	f800283a 	ret

811420a8 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
811420a8:	defff304 	addi	sp,sp,-52
811420ac:	de00012e 	bgeu	sp,et,811420b4 <OSTaskNameSet+0xc>
811420b0:	003b68fa 	trap	3
811420b4:	dfc00c15 	stw	ra,48(sp)
811420b8:	df000b15 	stw	fp,44(sp)
811420bc:	df000b04 	addi	fp,sp,44
811420c0:	2005883a 	mov	r2,r4
811420c4:	e17ffe15 	stw	r5,-8(fp)
811420c8:	e1bfff15 	stw	r6,-4(fp)
811420cc:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
811420d0:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811420d4:	e0bfff17 	ldw	r2,-4(fp)
811420d8:	10005c26 	beq	r2,zero,8114224c <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
811420dc:	e0bffd03 	ldbu	r2,-12(fp)
811420e0:	10800af0 	cmpltui	r2,r2,43
811420e4:	1000071e 	bne	r2,zero,81142104 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
811420e8:	e0bffd03 	ldbu	r2,-12(fp)
811420ec:	10803fe0 	cmpeqi	r2,r2,255
811420f0:	1000041e 	bne	r2,zero,81142104 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
811420f4:	e0bfff17 	ldw	r2,-4(fp)
811420f8:	00c00a84 	movi	r3,42
811420fc:	10c00005 	stb	r3,0(r2)
            return;
81142100:	00005306 	br	81142250 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81142104:	e0bffe17 	ldw	r2,-8(fp)
81142108:	1000041e 	bne	r2,zero,8114211c <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8114210c:	e0bfff17 	ldw	r2,-4(fp)
81142110:	00c00304 	movi	r3,12
81142114:	10c00005 	stb	r3,0(r2)
        return;
81142118:	00004d06 	br	81142250 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8114211c:	d0a0a103 	ldbu	r2,-32124(gp)
81142120:	10803fcc 	andi	r2,r2,255
81142124:	10000426 	beq	r2,zero,81142138 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81142128:	e0bfff17 	ldw	r2,-4(fp)
8114212c:	00c00484 	movi	r3,18
81142130:	10c00005 	stb	r3,0(r2)
        return;
81142134:	00004606 	br	81142250 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142138:	0005303a 	rdctl	r2,status
8114213c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142140:	e0fffc17 	ldw	r3,-16(fp)
81142144:	00bfff84 	movi	r2,-2
81142148:	1884703a 	and	r2,r3,r2
8114214c:	1001703a 	wrctl	status,r2
  
  return context;
81142150:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81142154:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81142158:	e0bffd03 	ldbu	r2,-12(fp)
8114215c:	10803fd8 	cmpnei	r2,r2,255
81142160:	1000031e 	bne	r2,zero,81142170 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81142164:	d0a0a217 	ldw	r2,-32120(gp)
81142168:	10800c83 	ldbu	r2,50(r2)
8114216c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81142170:	e0fffd03 	ldbu	r3,-12(fp)
81142174:	00a045f4 	movhi	r2,33047
81142178:	10bb6404 	addi	r2,r2,-4720
8114217c:	18c7883a 	add	r3,r3,r3
81142180:	18c7883a 	add	r3,r3,r3
81142184:	10c5883a 	add	r2,r2,r3
81142188:	10800017 	ldw	r2,0(r2)
8114218c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
81142190:	e0bff717 	ldw	r2,-36(fp)
81142194:	1000081e 	bne	r2,zero,811421b8 <OSTaskNameSet+0x110>
81142198:	e0bff517 	ldw	r2,-44(fp)
8114219c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811421a0:	e0bff617 	ldw	r2,-40(fp)
811421a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
811421a8:	e0bfff17 	ldw	r2,-4(fp)
811421ac:	00c010c4 	movi	r3,67
811421b0:	10c00005 	stb	r3,0(r2)
        return;
811421b4:	00002606 	br	81142250 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
811421b8:	e0bff717 	ldw	r2,-36(fp)
811421bc:	10800058 	cmpnei	r2,r2,1
811421c0:	1000081e 	bne	r2,zero,811421e4 <OSTaskNameSet+0x13c>
811421c4:	e0bff517 	ldw	r2,-44(fp)
811421c8:	e0bff815 	stw	r2,-32(fp)
811421cc:	e0bff817 	ldw	r2,-32(fp)
811421d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
811421d4:	e0bfff17 	ldw	r2,-4(fp)
811421d8:	00c010c4 	movi	r3,67
811421dc:	10c00005 	stb	r3,0(r2)
        return;
811421e0:	00001b06 	br	81142250 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
811421e4:	e13ffe17 	ldw	r4,-8(fp)
811421e8:	113be2c0 	call	8113be2c <OS_StrLen>
811421ec:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
811421f0:	e0bffa03 	ldbu	r2,-24(fp)
811421f4:	10800830 	cmpltui	r2,r2,32
811421f8:	1000081e 	bne	r2,zero,8114221c <OSTaskNameSet+0x174>
811421fc:	e0bff517 	ldw	r2,-44(fp)
81142200:	e0bff915 	stw	r2,-28(fp)
81142204:	e0bff917 	ldw	r2,-28(fp)
81142208:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8114220c:	e0bfff17 	ldw	r2,-4(fp)
81142210:	00c01044 	movi	r3,65
81142214:	10c00005 	stb	r3,0(r2)
        return;
81142218:	00000d06 	br	81142250 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8114221c:	e0bff717 	ldw	r2,-36(fp)
81142220:	10801304 	addi	r2,r2,76
81142224:	e17ffe17 	ldw	r5,-8(fp)
81142228:	1009883a 	mov	r4,r2
8114222c:	113bdb00 	call	8113bdb0 <OS_StrCopy>
81142230:	e0bff517 	ldw	r2,-44(fp)
81142234:	e0bffb15 	stw	r2,-20(fp)
81142238:	e0bffb17 	ldw	r2,-20(fp)
8114223c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81142240:	e0bfff17 	ldw	r2,-4(fp)
81142244:	10000005 	stb	zero,0(r2)
81142248:	00000106 	br	81142250 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8114224c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81142250:	e037883a 	mov	sp,fp
81142254:	dfc00117 	ldw	ra,4(sp)
81142258:	df000017 	ldw	fp,0(sp)
8114225c:	dec00204 	addi	sp,sp,8
81142260:	f800283a 	ret

81142264 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81142264:	defff404 	addi	sp,sp,-48
81142268:	de00012e 	bgeu	sp,et,81142270 <OSTaskResume+0xc>
8114226c:	003b68fa 	trap	3
81142270:	dfc00b15 	stw	ra,44(sp)
81142274:	df000a15 	stw	fp,40(sp)
81142278:	df000a04 	addi	fp,sp,40
8114227c:	2005883a 	mov	r2,r4
81142280:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81142284:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
81142288:	e0bfff03 	ldbu	r2,-4(fp)
8114228c:	10800ab0 	cmpltui	r2,r2,42
81142290:	1000021e 	bne	r2,zero,8114229c <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81142294:	00800a84 	movi	r2,42
81142298:	00006406 	br	8114242c <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114229c:	0005303a 	rdctl	r2,status
811422a0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811422a4:	e0fffe17 	ldw	r3,-8(fp)
811422a8:	00bfff84 	movi	r2,-2
811422ac:	1884703a 	and	r2,r3,r2
811422b0:	1001703a 	wrctl	status,r2
  
  return context;
811422b4:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811422b8:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
811422bc:	e0ffff03 	ldbu	r3,-4(fp)
811422c0:	00a045f4 	movhi	r2,33047
811422c4:	10bb6404 	addi	r2,r2,-4720
811422c8:	18c7883a 	add	r3,r3,r3
811422cc:	18c7883a 	add	r3,r3,r3
811422d0:	10c5883a 	add	r2,r2,r3
811422d4:	10800017 	ldw	r2,0(r2)
811422d8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
811422dc:	e0bff817 	ldw	r2,-32(fp)
811422e0:	1000061e 	bne	r2,zero,811422fc <OSTaskResume+0x98>
811422e4:	e0bff617 	ldw	r2,-40(fp)
811422e8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811422ec:	e0bff717 	ldw	r2,-36(fp)
811422f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
811422f4:	00801184 	movi	r2,70
811422f8:	00004c06 	br	8114242c <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
811422fc:	e0bff817 	ldw	r2,-32(fp)
81142300:	10800058 	cmpnei	r2,r2,1
81142304:	1000061e 	bne	r2,zero,81142320 <OSTaskResume+0xbc>
81142308:	e0bff617 	ldw	r2,-40(fp)
8114230c:	e0bff915 	stw	r2,-28(fp)
81142310:	e0bff917 	ldw	r2,-28(fp)
81142314:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142318:	008010c4 	movi	r2,67
8114231c:	00004306 	br	8114242c <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81142320:	e0bff817 	ldw	r2,-32(fp)
81142324:	10800c03 	ldbu	r2,48(r2)
81142328:	10803fcc 	andi	r2,r2,255
8114232c:	1080020c 	andi	r2,r2,8
81142330:	10003926 	beq	r2,zero,81142418 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
81142334:	e0bff817 	ldw	r2,-32(fp)
81142338:	10c00c03 	ldbu	r3,48(r2)
8114233c:	00bffdc4 	movi	r2,-9
81142340:	1884703a 	and	r2,r3,r2
81142344:	1007883a 	mov	r3,r2
81142348:	e0bff817 	ldw	r2,-32(fp)
8114234c:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81142350:	e0bff817 	ldw	r2,-32(fp)
81142354:	10800c03 	ldbu	r2,48(r2)
81142358:	10803fcc 	andi	r2,r2,255
8114235c:	1000281e 	bne	r2,zero,81142400 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81142360:	e0bff817 	ldw	r2,-32(fp)
81142364:	10800b8b 	ldhu	r2,46(r2)
81142368:	10bfffcc 	andi	r2,r2,65535
8114236c:	10001f1e 	bne	r2,zero,811423ec <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
81142370:	e0bff817 	ldw	r2,-32(fp)
81142374:	10c00d83 	ldbu	r3,54(r2)
81142378:	d0a09e03 	ldbu	r2,-32136(gp)
8114237c:	1884b03a 	or	r2,r3,r2
81142380:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81142384:	e0bff817 	ldw	r2,-32(fp)
81142388:	10800d03 	ldbu	r2,52(r2)
8114238c:	10c03fcc 	andi	r3,r2,255
81142390:	e0bff817 	ldw	r2,-32(fp)
81142394:	10800d03 	ldbu	r2,52(r2)
81142398:	11003fcc 	andi	r4,r2,255
8114239c:	d0a09e44 	addi	r2,gp,-32135
811423a0:	2085883a 	add	r2,r4,r2
811423a4:	11000003 	ldbu	r4,0(r2)
811423a8:	e0bff817 	ldw	r2,-32(fp)
811423ac:	10800d43 	ldbu	r2,53(r2)
811423b0:	2084b03a 	or	r2,r4,r2
811423b4:	1009883a 	mov	r4,r2
811423b8:	d0a09e44 	addi	r2,gp,-32135
811423bc:	1885883a 	add	r2,r3,r2
811423c0:	11000005 	stb	r4,0(r2)
811423c4:	e0bff617 	ldw	r2,-40(fp)
811423c8:	e0bffa15 	stw	r2,-24(fp)
811423cc:	e0bffa17 	ldw	r2,-24(fp)
811423d0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
811423d4:	d0a09103 	ldbu	r2,-32188(gp)
811423d8:	10803fcc 	andi	r2,r2,255
811423dc:	10800058 	cmpnei	r2,r2,1
811423e0:	10000b1e 	bne	r2,zero,81142410 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
811423e4:	113bc5c0 	call	8113bc5c <OS_Sched>
811423e8:	00000906 	br	81142410 <OSTaskResume+0x1ac>
811423ec:	e0bff617 	ldw	r2,-40(fp)
811423f0:	e0bffb15 	stw	r2,-20(fp)
811423f4:	e0bffb17 	ldw	r2,-20(fp)
811423f8:	1001703a 	wrctl	status,r2
811423fc:	00000406 	br	81142410 <OSTaskResume+0x1ac>
81142400:	e0bff617 	ldw	r2,-40(fp)
81142404:	e0bffc15 	stw	r2,-16(fp)
81142408:	e0bffc17 	ldw	r2,-16(fp)
8114240c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81142410:	0005883a 	mov	r2,zero
81142414:	00000506 	br	8114242c <OSTaskResume+0x1c8>
81142418:	e0bff617 	ldw	r2,-40(fp)
8114241c:	e0bffd15 	stw	r2,-12(fp)
81142420:	e0bffd17 	ldw	r2,-12(fp)
81142424:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81142428:	00801104 	movi	r2,68
}
8114242c:	e037883a 	mov	sp,fp
81142430:	dfc00117 	ldw	ra,4(sp)
81142434:	df000017 	ldw	fp,0(sp)
81142438:	dec00204 	addi	sp,sp,8
8114243c:	f800283a 	ret

81142440 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81142440:	defff304 	addi	sp,sp,-52
81142444:	de00012e 	bgeu	sp,et,8114244c <OSTaskStkChk+0xc>
81142448:	003b68fa 	trap	3
8114244c:	df000c15 	stw	fp,48(sp)
81142450:	df000c04 	addi	fp,sp,48
81142454:	2005883a 	mov	r2,r4
81142458:	e17fff15 	stw	r5,-4(fp)
8114245c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81142460:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
81142464:	e0bffe03 	ldbu	r2,-8(fp)
81142468:	10800af0 	cmpltui	r2,r2,43
8114246c:	1000051e 	bne	r2,zero,81142484 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
81142470:	e0bffe03 	ldbu	r2,-8(fp)
81142474:	10803fe0 	cmpeqi	r2,r2,255
81142478:	1000021e 	bne	r2,zero,81142484 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8114247c:	00800a84 	movi	r2,42
81142480:	00005d06 	br	811425f8 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
81142484:	e0bfff17 	ldw	r2,-4(fp)
81142488:	1000021e 	bne	r2,zero,81142494 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8114248c:	00800244 	movi	r2,9
81142490:	00005906 	br	811425f8 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
81142494:	e0bfff17 	ldw	r2,-4(fp)
81142498:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8114249c:	e0bfff17 	ldw	r2,-4(fp)
811424a0:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811424a4:	0005303a 	rdctl	r2,status
811424a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811424ac:	e0fffd17 	ldw	r3,-12(fp)
811424b0:	00bfff84 	movi	r2,-2
811424b4:	1884703a 	and	r2,r3,r2
811424b8:	1001703a 	wrctl	status,r2
  
  return context;
811424bc:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
811424c0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
811424c4:	e0bffe03 	ldbu	r2,-8(fp)
811424c8:	10803fd8 	cmpnei	r2,r2,255
811424cc:	1000031e 	bne	r2,zero,811424dc <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811424d0:	d0a0a217 	ldw	r2,-32120(gp)
811424d4:	10800c83 	ldbu	r2,50(r2)
811424d8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811424dc:	e0fffe03 	ldbu	r3,-8(fp)
811424e0:	00a045f4 	movhi	r2,33047
811424e4:	10bb6404 	addi	r2,r2,-4720
811424e8:	18c7883a 	add	r3,r3,r3
811424ec:	18c7883a 	add	r3,r3,r3
811424f0:	10c5883a 	add	r2,r2,r3
811424f4:	10800017 	ldw	r2,0(r2)
811424f8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
811424fc:	e0bff817 	ldw	r2,-32(fp)
81142500:	1000061e 	bne	r2,zero,8114251c <OSTaskStkChk+0xdc>
81142504:	e0bff617 	ldw	r2,-40(fp)
81142508:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114250c:	e0bff717 	ldw	r2,-36(fp)
81142510:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142514:	008010c4 	movi	r2,67
81142518:	00003706 	br	811425f8 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8114251c:	e0bff817 	ldw	r2,-32(fp)
81142520:	10800058 	cmpnei	r2,r2,1
81142524:	1000061e 	bne	r2,zero,81142540 <OSTaskStkChk+0x100>
81142528:	e0bff617 	ldw	r2,-40(fp)
8114252c:	e0bff915 	stw	r2,-28(fp)
81142530:	e0bff917 	ldw	r2,-28(fp)
81142534:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142538:	008010c4 	movi	r2,67
8114253c:	00002e06 	br	811425f8 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81142540:	e0bff817 	ldw	r2,-32(fp)
81142544:	1080040b 	ldhu	r2,16(r2)
81142548:	10bfffcc 	andi	r2,r2,65535
8114254c:	1080004c 	andi	r2,r2,1
81142550:	1000061e 	bne	r2,zero,8114256c <OSTaskStkChk+0x12c>
81142554:	e0bff617 	ldw	r2,-40(fp)
81142558:	e0bffa15 	stw	r2,-24(fp)
8114255c:	e0bffa17 	ldw	r2,-24(fp)
81142560:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
81142564:	00801144 	movi	r2,69
81142568:	00002306 	br	811425f8 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8114256c:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
81142570:	e0bff817 	ldw	r2,-32(fp)
81142574:	10800317 	ldw	r2,12(r2)
81142578:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8114257c:	e0bff817 	ldw	r2,-32(fp)
81142580:	10800217 	ldw	r2,8(r2)
81142584:	e0bff415 	stw	r2,-48(fp)
81142588:	e0bff617 	ldw	r2,-40(fp)
8114258c:	e0bffb15 	stw	r2,-20(fp)
81142590:	e0bffb17 	ldw	r2,-20(fp)
81142594:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81142598:	00000306 	br	811425a8 <OSTaskStkChk+0x168>
        nfree++;
8114259c:	e0bff517 	ldw	r2,-44(fp)
811425a0:	10800044 	addi	r2,r2,1
811425a4:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811425a8:	e0bff417 	ldw	r2,-48(fp)
811425ac:	10c00104 	addi	r3,r2,4
811425b0:	e0fff415 	stw	r3,-48(fp)
811425b4:	10800017 	ldw	r2,0(r2)
811425b8:	103ff826 	beq	r2,zero,8114259c <__reset+0xfb12259c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
811425bc:	e0bff517 	ldw	r2,-44(fp)
811425c0:	1085883a 	add	r2,r2,r2
811425c4:	1085883a 	add	r2,r2,r2
811425c8:	1007883a 	mov	r3,r2
811425cc:	e0bfff17 	ldw	r2,-4(fp)
811425d0:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
811425d4:	e0fffc17 	ldw	r3,-16(fp)
811425d8:	e0bff517 	ldw	r2,-44(fp)
811425dc:	1885c83a 	sub	r2,r3,r2
811425e0:	1085883a 	add	r2,r2,r2
811425e4:	1085883a 	add	r2,r2,r2
811425e8:	1007883a 	mov	r3,r2
811425ec:	e0bfff17 	ldw	r2,-4(fp)
811425f0:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
811425f4:	0005883a 	mov	r2,zero
}
811425f8:	e037883a 	mov	sp,fp
811425fc:	df000017 	ldw	fp,0(sp)
81142600:	dec00104 	addi	sp,sp,4
81142604:	f800283a 	ret

81142608 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81142608:	defff504 	addi	sp,sp,-44
8114260c:	de00012e 	bgeu	sp,et,81142614 <OSTaskSuspend+0xc>
81142610:	003b68fa 	trap	3
81142614:	dfc00a15 	stw	ra,40(sp)
81142618:	df000915 	stw	fp,36(sp)
8114261c:	df000904 	addi	fp,sp,36
81142620:	2005883a 	mov	r2,r4
81142624:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142628:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8114262c:	e0bfff03 	ldbu	r2,-4(fp)
81142630:	10800a98 	cmpnei	r2,r2,42
81142634:	1000021e 	bne	r2,zero,81142640 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
81142638:	008011c4 	movi	r2,71
8114263c:	00006806 	br	811427e0 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81142640:	e0bfff03 	ldbu	r2,-4(fp)
81142644:	10800ab0 	cmpltui	r2,r2,42
81142648:	1000051e 	bne	r2,zero,81142660 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8114264c:	e0bfff03 	ldbu	r2,-4(fp)
81142650:	10803fe0 	cmpeqi	r2,r2,255
81142654:	1000021e 	bne	r2,zero,81142660 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
81142658:	00800a84 	movi	r2,42
8114265c:	00006006 	br	811427e0 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142660:	0005303a 	rdctl	r2,status
81142664:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142668:	e0fffe17 	ldw	r3,-8(fp)
8114266c:	00bfff84 	movi	r2,-2
81142670:	1884703a 	and	r2,r3,r2
81142674:	1001703a 	wrctl	status,r2
  
  return context;
81142678:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8114267c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
81142680:	e0bfff03 	ldbu	r2,-4(fp)
81142684:	10803fd8 	cmpnei	r2,r2,255
81142688:	1000061e 	bne	r2,zero,811426a4 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8114268c:	d0a0a217 	ldw	r2,-32120(gp)
81142690:	10800c83 	ldbu	r2,50(r2)
81142694:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
81142698:	00800044 	movi	r2,1
8114269c:	e0bff705 	stb	r2,-36(fp)
811426a0:	00000906 	br	811426c8 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
811426a4:	d0a0a217 	ldw	r2,-32120(gp)
811426a8:	10800c83 	ldbu	r2,50(r2)
811426ac:	10c03fcc 	andi	r3,r2,255
811426b0:	e0bfff03 	ldbu	r2,-4(fp)
811426b4:	1880031e 	bne	r3,r2,811426c4 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
811426b8:	00800044 	movi	r2,1
811426bc:	e0bff705 	stb	r2,-36(fp)
811426c0:	00000106 	br	811426c8 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
811426c4:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811426c8:	e0ffff03 	ldbu	r3,-4(fp)
811426cc:	00a045f4 	movhi	r2,33047
811426d0:	10bb6404 	addi	r2,r2,-4720
811426d4:	18c7883a 	add	r3,r3,r3
811426d8:	18c7883a 	add	r3,r3,r3
811426dc:	10c5883a 	add	r2,r2,r3
811426e0:	10800017 	ldw	r2,0(r2)
811426e4:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
811426e8:	e0bffa17 	ldw	r2,-24(fp)
811426ec:	1000061e 	bne	r2,zero,81142708 <OSTaskSuspend+0x100>
811426f0:	e0bff817 	ldw	r2,-32(fp)
811426f4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811426f8:	e0bff917 	ldw	r2,-28(fp)
811426fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
81142700:	00801204 	movi	r2,72
81142704:	00003606 	br	811427e0 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81142708:	e0bffa17 	ldw	r2,-24(fp)
8114270c:	10800058 	cmpnei	r2,r2,1
81142710:	1000061e 	bne	r2,zero,8114272c <OSTaskSuspend+0x124>
81142714:	e0bff817 	ldw	r2,-32(fp)
81142718:	e0bffb15 	stw	r2,-20(fp)
8114271c:	e0bffb17 	ldw	r2,-20(fp)
81142720:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142724:	008010c4 	movi	r2,67
81142728:	00002d06 	br	811427e0 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8114272c:	e0bffa17 	ldw	r2,-24(fp)
81142730:	10800d03 	ldbu	r2,52(r2)
81142734:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
81142738:	e0fffd03 	ldbu	r3,-12(fp)
8114273c:	e13ffd03 	ldbu	r4,-12(fp)
81142740:	d0a09e44 	addi	r2,gp,-32135
81142744:	2085883a 	add	r2,r4,r2
81142748:	10800003 	ldbu	r2,0(r2)
8114274c:	1009883a 	mov	r4,r2
81142750:	e0bffa17 	ldw	r2,-24(fp)
81142754:	10800d43 	ldbu	r2,53(r2)
81142758:	0084303a 	nor	r2,zero,r2
8114275c:	2084703a 	and	r2,r4,r2
81142760:	1009883a 	mov	r4,r2
81142764:	d0a09e44 	addi	r2,gp,-32135
81142768:	1885883a 	add	r2,r3,r2
8114276c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81142770:	e0fffd03 	ldbu	r3,-12(fp)
81142774:	d0a09e44 	addi	r2,gp,-32135
81142778:	1885883a 	add	r2,r3,r2
8114277c:	10800003 	ldbu	r2,0(r2)
81142780:	10803fcc 	andi	r2,r2,255
81142784:	1000071e 	bne	r2,zero,811427a4 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81142788:	e0bffa17 	ldw	r2,-24(fp)
8114278c:	10800d83 	ldbu	r2,54(r2)
81142790:	0084303a 	nor	r2,zero,r2
81142794:	1007883a 	mov	r3,r2
81142798:	d0a09e03 	ldbu	r2,-32136(gp)
8114279c:	1884703a 	and	r2,r3,r2
811427a0:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
811427a4:	e0bffa17 	ldw	r2,-24(fp)
811427a8:	10800c03 	ldbu	r2,48(r2)
811427ac:	10800214 	ori	r2,r2,8
811427b0:	1007883a 	mov	r3,r2
811427b4:	e0bffa17 	ldw	r2,-24(fp)
811427b8:	10c00c05 	stb	r3,48(r2)
811427bc:	e0bff817 	ldw	r2,-32(fp)
811427c0:	e0bffc15 	stw	r2,-16(fp)
811427c4:	e0bffc17 	ldw	r2,-16(fp)
811427c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
811427cc:	e0bff703 	ldbu	r2,-36(fp)
811427d0:	10800058 	cmpnei	r2,r2,1
811427d4:	1000011e 	bne	r2,zero,811427dc <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
811427d8:	113bc5c0 	call	8113bc5c <OS_Sched>
    }
    return (OS_ERR_NONE);
811427dc:	0005883a 	mov	r2,zero
}
811427e0:	e037883a 	mov	sp,fp
811427e4:	dfc00117 	ldw	ra,4(sp)
811427e8:	df000017 	ldw	fp,0(sp)
811427ec:	dec00204 	addi	sp,sp,8
811427f0:	f800283a 	ret

811427f4 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
811427f4:	defff604 	addi	sp,sp,-40
811427f8:	de00012e 	bgeu	sp,et,81142800 <OSTaskQuery+0xc>
811427fc:	003b68fa 	trap	3
81142800:	dfc00915 	stw	ra,36(sp)
81142804:	df000815 	stw	fp,32(sp)
81142808:	df000804 	addi	fp,sp,32
8114280c:	2005883a 	mov	r2,r4
81142810:	e17fff15 	stw	r5,-4(fp)
81142814:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142818:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8114281c:	e0bffe03 	ldbu	r2,-8(fp)
81142820:	10800af0 	cmpltui	r2,r2,43
81142824:	1000051e 	bne	r2,zero,8114283c <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81142828:	e0bffe03 	ldbu	r2,-8(fp)
8114282c:	10803fe0 	cmpeqi	r2,r2,255
81142830:	1000021e 	bne	r2,zero,8114283c <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
81142834:	00800a84 	movi	r2,42
81142838:	00003406 	br	8114290c <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8114283c:	e0bfff17 	ldw	r2,-4(fp)
81142840:	1000021e 	bne	r2,zero,8114284c <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
81142844:	00800244 	movi	r2,9
81142848:	00003006 	br	8114290c <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114284c:	0005303a 	rdctl	r2,status
81142850:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142854:	e0fffd17 	ldw	r3,-12(fp)
81142858:	00bfff84 	movi	r2,-2
8114285c:	1884703a 	and	r2,r3,r2
81142860:	1001703a 	wrctl	status,r2
  
  return context;
81142864:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81142868:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8114286c:	e0bffe03 	ldbu	r2,-8(fp)
81142870:	10803fd8 	cmpnei	r2,r2,255
81142874:	1000031e 	bne	r2,zero,81142884 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
81142878:	d0a0a217 	ldw	r2,-32120(gp)
8114287c:	10800c83 	ldbu	r2,50(r2)
81142880:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81142884:	e0fffe03 	ldbu	r3,-8(fp)
81142888:	00a045f4 	movhi	r2,33047
8114288c:	10bb6404 	addi	r2,r2,-4720
81142890:	18c7883a 	add	r3,r3,r3
81142894:	18c7883a 	add	r3,r3,r3
81142898:	10c5883a 	add	r2,r2,r3
8114289c:	10800017 	ldw	r2,0(r2)
811428a0:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
811428a4:	e0bffa17 	ldw	r2,-24(fp)
811428a8:	1000061e 	bne	r2,zero,811428c4 <OSTaskQuery+0xd0>
811428ac:	e0bff817 	ldw	r2,-32(fp)
811428b0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811428b4:	e0bff917 	ldw	r2,-28(fp)
811428b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
811428bc:	00800a44 	movi	r2,41
811428c0:	00001206 	br	8114290c <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
811428c4:	e0bffa17 	ldw	r2,-24(fp)
811428c8:	10800058 	cmpnei	r2,r2,1
811428cc:	1000061e 	bne	r2,zero,811428e8 <OSTaskQuery+0xf4>
811428d0:	e0bff817 	ldw	r2,-32(fp)
811428d4:	e0bffb15 	stw	r2,-20(fp)
811428d8:	e0bffb17 	ldw	r2,-20(fp)
811428dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811428e0:	008010c4 	movi	r2,67
811428e4:	00000906 	br	8114290c <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
811428e8:	01801b04 	movi	r6,108
811428ec:	e17ffa17 	ldw	r5,-24(fp)
811428f0:	e13fff17 	ldw	r4,-4(fp)
811428f4:	113bbec0 	call	8113bbec <OS_MemCopy>
811428f8:	e0bff817 	ldw	r2,-32(fp)
811428fc:	e0bffc15 	stw	r2,-16(fp)
81142900:	e0bffc17 	ldw	r2,-16(fp)
81142904:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81142908:	0005883a 	mov	r2,zero
}
8114290c:	e037883a 	mov	sp,fp
81142910:	dfc00117 	ldw	ra,4(sp)
81142914:	df000017 	ldw	fp,0(sp)
81142918:	dec00204 	addi	sp,sp,8
8114291c:	f800283a 	ret

81142920 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
81142920:	defffc04 	addi	sp,sp,-16
81142924:	de00012e 	bgeu	sp,et,8114292c <OS_TaskStkClr+0xc>
81142928:	003b68fa 	trap	3
8114292c:	df000315 	stw	fp,12(sp)
81142930:	df000304 	addi	fp,sp,12
81142934:	e13ffd15 	stw	r4,-12(fp)
81142938:	e17ffe15 	stw	r5,-8(fp)
8114293c:	3005883a 	mov	r2,r6
81142940:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
81142944:	e0bfff0b 	ldhu	r2,-4(fp)
81142948:	1080004c 	andi	r2,r2,1
8114294c:	10000d26 	beq	r2,zero,81142984 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
81142950:	e0bfff0b 	ldhu	r2,-4(fp)
81142954:	1080008c 	andi	r2,r2,2
81142958:	10000a26 	beq	r2,zero,81142984 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8114295c:	00000706 	br	8114297c <OS_TaskStkClr+0x5c>
                size--;
81142960:	e0bffe17 	ldw	r2,-8(fp)
81142964:	10bfffc4 	addi	r2,r2,-1
81142968:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8114296c:	e0bffd17 	ldw	r2,-12(fp)
81142970:	10c00104 	addi	r3,r2,4
81142974:	e0fffd15 	stw	r3,-12(fp)
81142978:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8114297c:	e0bffe17 	ldw	r2,-8(fp)
81142980:	103ff71e 	bne	r2,zero,81142960 <__reset+0xfb122960>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
81142984:	0001883a 	nop
81142988:	e037883a 	mov	sp,fp
8114298c:	df000017 	ldw	fp,0(sp)
81142990:	dec00104 	addi	sp,sp,4
81142994:	f800283a 	ret

81142998 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
81142998:	defff904 	addi	sp,sp,-28
8114299c:	de00012e 	bgeu	sp,et,811429a4 <OSTimeDly+0xc>
811429a0:	003b68fa 	trap	3
811429a4:	dfc00615 	stw	ra,24(sp)
811429a8:	df000515 	stw	fp,20(sp)
811429ac:	df000504 	addi	fp,sp,20
811429b0:	2005883a 	mov	r2,r4
811429b4:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811429b8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811429bc:	d0a0a103 	ldbu	r2,-32124(gp)
811429c0:	10803fcc 	andi	r2,r2,255
811429c4:	1000311e 	bne	r2,zero,81142a8c <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
811429c8:	e0bfff0b 	ldhu	r2,-4(fp)
811429cc:	10003026 	beq	r2,zero,81142a90 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811429d0:	0005303a 	rdctl	r2,status
811429d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811429d8:	e0fffe17 	ldw	r3,-8(fp)
811429dc:	00bfff84 	movi	r2,-2
811429e0:	1884703a 	and	r2,r3,r2
811429e4:	1001703a 	wrctl	status,r2
  
  return context;
811429e8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
811429ec:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
811429f0:	d0a0a217 	ldw	r2,-32120(gp)
811429f4:	10800d03 	ldbu	r2,52(r2)
811429f8:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
811429fc:	e0fffd03 	ldbu	r3,-12(fp)
81142a00:	e13ffd03 	ldbu	r4,-12(fp)
81142a04:	d0a09e44 	addi	r2,gp,-32135
81142a08:	2085883a 	add	r2,r4,r2
81142a0c:	10800003 	ldbu	r2,0(r2)
81142a10:	1009883a 	mov	r4,r2
81142a14:	d0a0a217 	ldw	r2,-32120(gp)
81142a18:	10800d43 	ldbu	r2,53(r2)
81142a1c:	0084303a 	nor	r2,zero,r2
81142a20:	2084703a 	and	r2,r4,r2
81142a24:	1009883a 	mov	r4,r2
81142a28:	d0a09e44 	addi	r2,gp,-32135
81142a2c:	1885883a 	add	r2,r3,r2
81142a30:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81142a34:	e0fffd03 	ldbu	r3,-12(fp)
81142a38:	d0a09e44 	addi	r2,gp,-32135
81142a3c:	1885883a 	add	r2,r3,r2
81142a40:	10800003 	ldbu	r2,0(r2)
81142a44:	10803fcc 	andi	r2,r2,255
81142a48:	1000071e 	bne	r2,zero,81142a68 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81142a4c:	d0a0a217 	ldw	r2,-32120(gp)
81142a50:	10800d83 	ldbu	r2,54(r2)
81142a54:	0084303a 	nor	r2,zero,r2
81142a58:	1007883a 	mov	r3,r2
81142a5c:	d0a09e03 	ldbu	r2,-32136(gp)
81142a60:	1884703a 	and	r2,r3,r2
81142a64:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
81142a68:	d0a0a217 	ldw	r2,-32120(gp)
81142a6c:	e0ffff0b 	ldhu	r3,-4(fp)
81142a70:	10c00b8d 	sth	r3,46(r2)
81142a74:	e0bffb17 	ldw	r2,-20(fp)
81142a78:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142a7c:	e0bffc17 	ldw	r2,-16(fp)
81142a80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81142a84:	113bc5c0 	call	8113bc5c <OS_Sched>
81142a88:	00000106 	br	81142a90 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
81142a8c:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81142a90:	e037883a 	mov	sp,fp
81142a94:	dfc00117 	ldw	ra,4(sp)
81142a98:	df000017 	ldw	fp,0(sp)
81142a9c:	dec00204 	addi	sp,sp,8
81142aa0:	f800283a 	ret

81142aa4 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81142aa4:	defff804 	addi	sp,sp,-32
81142aa8:	de00012e 	bgeu	sp,et,81142ab0 <OSTimeDlyHMSM+0xc>
81142aac:	003b68fa 	trap	3
81142ab0:	dfc00715 	stw	ra,28(sp)
81142ab4:	df000615 	stw	fp,24(sp)
81142ab8:	df000604 	addi	fp,sp,24
81142abc:	2015883a 	mov	r10,r4
81142ac0:	2809883a 	mov	r4,r5
81142ac4:	3007883a 	mov	r3,r6
81142ac8:	3805883a 	mov	r2,r7
81142acc:	e2bffc05 	stb	r10,-16(fp)
81142ad0:	e13ffd05 	stb	r4,-12(fp)
81142ad4:	e0fffe05 	stb	r3,-8(fp)
81142ad8:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81142adc:	d0a0a103 	ldbu	r2,-32124(gp)
81142ae0:	10803fcc 	andi	r2,r2,255
81142ae4:	10000226 	beq	r2,zero,81142af0 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81142ae8:	00801544 	movi	r2,85
81142aec:	00004106 	br	81142bf4 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81142af0:	e0bffc03 	ldbu	r2,-16(fp)
81142af4:	1000081e 	bne	r2,zero,81142b18 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81142af8:	e0bffd03 	ldbu	r2,-12(fp)
81142afc:	1000061e 	bne	r2,zero,81142b18 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81142b00:	e0bffe03 	ldbu	r2,-8(fp)
81142b04:	1000041e 	bne	r2,zero,81142b18 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81142b08:	e0bfff0b 	ldhu	r2,-4(fp)
81142b0c:	1000021e 	bne	r2,zero,81142b18 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81142b10:	00801504 	movi	r2,84
81142b14:	00003706 	br	81142bf4 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81142b18:	e0bffd03 	ldbu	r2,-12(fp)
81142b1c:	10800f30 	cmpltui	r2,r2,60
81142b20:	1000021e 	bne	r2,zero,81142b2c <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81142b24:	00801444 	movi	r2,81
81142b28:	00003206 	br	81142bf4 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81142b2c:	e0bffe03 	ldbu	r2,-8(fp)
81142b30:	10800f30 	cmpltui	r2,r2,60
81142b34:	1000021e 	bne	r2,zero,81142b40 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81142b38:	00801484 	movi	r2,82
81142b3c:	00002d06 	br	81142bf4 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81142b40:	e0bfff0b 	ldhu	r2,-4(fp)
81142b44:	1080fa30 	cmpltui	r2,r2,1000
81142b48:	1000021e 	bne	r2,zero,81142b54 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81142b4c:	008014c4 	movi	r2,83
81142b50:	00002806 	br	81142bf4 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81142b54:	e0bffc03 	ldbu	r2,-16(fp)
81142b58:	10c38424 	muli	r3,r2,3600
81142b5c:	e0bffd03 	ldbu	r2,-12(fp)
81142b60:	10800f24 	muli	r2,r2,60
81142b64:	1887883a 	add	r3,r3,r2
81142b68:	e0bffe03 	ldbu	r2,-8(fp)
81142b6c:	1885883a 	add	r2,r3,r2
81142b70:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81142b74:	e0bfff0b 	ldhu	r2,-4(fp)
81142b78:	10c0fa24 	muli	r3,r2,1000
81142b7c:	008418b4 	movhi	r2,4194
81142b80:	109374c4 	addi	r2,r2,19923
81142b84:	188a383a 	mulxuu	r5,r3,r2
81142b88:	1885383a 	mul	r2,r3,r2
81142b8c:	1011883a 	mov	r8,r2
81142b90:	2813883a 	mov	r9,r5
81142b94:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81142b98:	2085883a 	add	r2,r4,r2
81142b9c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81142ba0:	e0bffb17 	ldw	r2,-20(fp)
81142ba4:	1004d43a 	srli	r2,r2,16
81142ba8:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81142bac:	e0bffb17 	ldw	r2,-20(fp)
81142bb0:	10bfffcc 	andi	r2,r2,65535
81142bb4:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81142bb8:	e0bffb17 	ldw	r2,-20(fp)
81142bbc:	10bfffcc 	andi	r2,r2,65535
81142bc0:	1009883a 	mov	r4,r2
81142bc4:	11429980 	call	81142998 <OSTimeDly>
    while (loops > 0) {
81142bc8:	00000706 	br	81142be8 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81142bcc:	01200014 	movui	r4,32768
81142bd0:	11429980 	call	81142998 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81142bd4:	01200014 	movui	r4,32768
81142bd8:	11429980 	call	81142998 <OSTimeDly>
        loops--;
81142bdc:	e0bffa0b 	ldhu	r2,-24(fp)
81142be0:	10bfffc4 	addi	r2,r2,-1
81142be4:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81142be8:	e0bffa0b 	ldhu	r2,-24(fp)
81142bec:	103ff71e 	bne	r2,zero,81142bcc <__reset+0xfb122bcc>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81142bf0:	0005883a 	mov	r2,zero
}
81142bf4:	e037883a 	mov	sp,fp
81142bf8:	dfc00117 	ldw	ra,4(sp)
81142bfc:	df000017 	ldw	fp,0(sp)
81142c00:	dec00204 	addi	sp,sp,8
81142c04:	f800283a 	ret

81142c08 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81142c08:	defff504 	addi	sp,sp,-44
81142c0c:	de00012e 	bgeu	sp,et,81142c14 <OSTimeDlyResume+0xc>
81142c10:	003b68fa 	trap	3
81142c14:	dfc00a15 	stw	ra,40(sp)
81142c18:	df000915 	stw	fp,36(sp)
81142c1c:	df000904 	addi	fp,sp,36
81142c20:	2005883a 	mov	r2,r4
81142c24:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81142c28:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81142c2c:	e0bfff03 	ldbu	r2,-4(fp)
81142c30:	10800ab0 	cmpltui	r2,r2,42
81142c34:	1000021e 	bne	r2,zero,81142c40 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81142c38:	00800a84 	movi	r2,42
81142c3c:	00006406 	br	81142dd0 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142c40:	0005303a 	rdctl	r2,status
81142c44:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142c48:	e0fffe17 	ldw	r3,-8(fp)
81142c4c:	00bfff84 	movi	r2,-2
81142c50:	1884703a 	and	r2,r3,r2
81142c54:	1001703a 	wrctl	status,r2
  
  return context;
81142c58:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81142c5c:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81142c60:	e0ffff03 	ldbu	r3,-4(fp)
81142c64:	00a045f4 	movhi	r2,33047
81142c68:	10bb6404 	addi	r2,r2,-4720
81142c6c:	18c7883a 	add	r3,r3,r3
81142c70:	18c7883a 	add	r3,r3,r3
81142c74:	10c5883a 	add	r2,r2,r3
81142c78:	10800017 	ldw	r2,0(r2)
81142c7c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81142c80:	e0bff917 	ldw	r2,-28(fp)
81142c84:	1000061e 	bne	r2,zero,81142ca0 <OSTimeDlyResume+0x98>
81142c88:	e0bff717 	ldw	r2,-36(fp)
81142c8c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142c90:	e0bff817 	ldw	r2,-32(fp)
81142c94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81142c98:	008010c4 	movi	r2,67
81142c9c:	00004c06 	br	81142dd0 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81142ca0:	e0bff917 	ldw	r2,-28(fp)
81142ca4:	10800058 	cmpnei	r2,r2,1
81142ca8:	1000061e 	bne	r2,zero,81142cc4 <OSTimeDlyResume+0xbc>
81142cac:	e0bff717 	ldw	r2,-36(fp)
81142cb0:	e0bffa15 	stw	r2,-24(fp)
81142cb4:	e0bffa17 	ldw	r2,-24(fp)
81142cb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81142cbc:	008010c4 	movi	r2,67
81142cc0:	00004306 	br	81142dd0 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81142cc4:	e0bff917 	ldw	r2,-28(fp)
81142cc8:	10800b8b 	ldhu	r2,46(r2)
81142ccc:	10bfffcc 	andi	r2,r2,65535
81142cd0:	1000061e 	bne	r2,zero,81142cec <OSTimeDlyResume+0xe4>
81142cd4:	e0bff717 	ldw	r2,-36(fp)
81142cd8:	e0bffb15 	stw	r2,-20(fp)
81142cdc:	e0bffb17 	ldw	r2,-20(fp)
81142ce0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81142ce4:	00801404 	movi	r2,80
81142ce8:	00003906 	br	81142dd0 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81142cec:	e0bff917 	ldw	r2,-28(fp)
81142cf0:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81142cf4:	e0bff917 	ldw	r2,-28(fp)
81142cf8:	10800c03 	ldbu	r2,48(r2)
81142cfc:	10803fcc 	andi	r2,r2,255
81142d00:	10800dcc 	andi	r2,r2,55
81142d04:	10000b26 	beq	r2,zero,81142d34 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81142d08:	e0bff917 	ldw	r2,-28(fp)
81142d0c:	10c00c03 	ldbu	r3,48(r2)
81142d10:	00bff204 	movi	r2,-56
81142d14:	1884703a 	and	r2,r3,r2
81142d18:	1007883a 	mov	r3,r2
81142d1c:	e0bff917 	ldw	r2,-28(fp)
81142d20:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81142d24:	e0bff917 	ldw	r2,-28(fp)
81142d28:	00c00044 	movi	r3,1
81142d2c:	10c00c45 	stb	r3,49(r2)
81142d30:	00000206 	br	81142d3c <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81142d34:	e0bff917 	ldw	r2,-28(fp)
81142d38:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81142d3c:	e0bff917 	ldw	r2,-28(fp)
81142d40:	10800c03 	ldbu	r2,48(r2)
81142d44:	10803fcc 	andi	r2,r2,255
81142d48:	1080020c 	andi	r2,r2,8
81142d4c:	10001b1e 	bne	r2,zero,81142dbc <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81142d50:	e0bff917 	ldw	r2,-28(fp)
81142d54:	10c00d83 	ldbu	r3,54(r2)
81142d58:	d0a09e03 	ldbu	r2,-32136(gp)
81142d5c:	1884b03a 	or	r2,r3,r2
81142d60:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81142d64:	e0bff917 	ldw	r2,-28(fp)
81142d68:	10800d03 	ldbu	r2,52(r2)
81142d6c:	10c03fcc 	andi	r3,r2,255
81142d70:	e0bff917 	ldw	r2,-28(fp)
81142d74:	10800d03 	ldbu	r2,52(r2)
81142d78:	11003fcc 	andi	r4,r2,255
81142d7c:	d0a09e44 	addi	r2,gp,-32135
81142d80:	2085883a 	add	r2,r4,r2
81142d84:	11000003 	ldbu	r4,0(r2)
81142d88:	e0bff917 	ldw	r2,-28(fp)
81142d8c:	10800d43 	ldbu	r2,53(r2)
81142d90:	2084b03a 	or	r2,r4,r2
81142d94:	1009883a 	mov	r4,r2
81142d98:	d0a09e44 	addi	r2,gp,-32135
81142d9c:	1885883a 	add	r2,r3,r2
81142da0:	11000005 	stb	r4,0(r2)
81142da4:	e0bff717 	ldw	r2,-36(fp)
81142da8:	e0bffc15 	stw	r2,-16(fp)
81142dac:	e0bffc17 	ldw	r2,-16(fp)
81142db0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81142db4:	113bc5c0 	call	8113bc5c <OS_Sched>
81142db8:	00000406 	br	81142dcc <OSTimeDlyResume+0x1c4>
81142dbc:	e0bff717 	ldw	r2,-36(fp)
81142dc0:	e0bffd15 	stw	r2,-12(fp)
81142dc4:	e0bffd17 	ldw	r2,-12(fp)
81142dc8:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81142dcc:	0005883a 	mov	r2,zero
}
81142dd0:	e037883a 	mov	sp,fp
81142dd4:	dfc00117 	ldw	ra,4(sp)
81142dd8:	df000017 	ldw	fp,0(sp)
81142ddc:	dec00204 	addi	sp,sp,8
81142de0:	f800283a 	ret

81142de4 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81142de4:	defffb04 	addi	sp,sp,-20
81142de8:	de00012e 	bgeu	sp,et,81142df0 <OSTimeGet+0xc>
81142dec:	003b68fa 	trap	3
81142df0:	df000415 	stw	fp,16(sp)
81142df4:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142df8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142dfc:	0005303a 	rdctl	r2,status
81142e00:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142e04:	e0fffe17 	ldw	r3,-8(fp)
81142e08:	00bfff84 	movi	r2,-2
81142e0c:	1884703a 	and	r2,r3,r2
81142e10:	1001703a 	wrctl	status,r2
  
  return context;
81142e14:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81142e18:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81142e1c:	d0a0a417 	ldw	r2,-32112(gp)
81142e20:	e0bffd15 	stw	r2,-12(fp)
81142e24:	e0bffc17 	ldw	r2,-16(fp)
81142e28:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142e2c:	e0bfff17 	ldw	r2,-4(fp)
81142e30:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
81142e34:	e0bffd17 	ldw	r2,-12(fp)
}
81142e38:	e037883a 	mov	sp,fp
81142e3c:	df000017 	ldw	fp,0(sp)
81142e40:	dec00104 	addi	sp,sp,4
81142e44:	f800283a 	ret

81142e48 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81142e48:	defffb04 	addi	sp,sp,-20
81142e4c:	de00012e 	bgeu	sp,et,81142e54 <OSTimeSet+0xc>
81142e50:	003b68fa 	trap	3
81142e54:	df000415 	stw	fp,16(sp)
81142e58:	df000404 	addi	fp,sp,16
81142e5c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142e60:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142e64:	0005303a 	rdctl	r2,status
81142e68:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142e6c:	e0fffd17 	ldw	r3,-12(fp)
81142e70:	00bfff84 	movi	r2,-2
81142e74:	1884703a 	and	r2,r3,r2
81142e78:	1001703a 	wrctl	status,r2
  
  return context;
81142e7c:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81142e80:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81142e84:	e0bfff17 	ldw	r2,-4(fp)
81142e88:	d0a0a415 	stw	r2,-32112(gp)
81142e8c:	e0bffc17 	ldw	r2,-16(fp)
81142e90:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142e94:	e0bffe17 	ldw	r2,-8(fp)
81142e98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81142e9c:	0001883a 	nop
81142ea0:	e037883a 	mov	sp,fp
81142ea4:	df000017 	ldw	fp,0(sp)
81142ea8:	dec00104 	addi	sp,sp,4
81142eac:	f800283a 	ret

81142eb0 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81142eb0:	defff804 	addi	sp,sp,-32
81142eb4:	de00012e 	bgeu	sp,et,81142ebc <OSTmrCreate+0xc>
81142eb8:	003b68fa 	trap	3
81142ebc:	dfc00715 	stw	ra,28(sp)
81142ec0:	df000615 	stw	fp,24(sp)
81142ec4:	df000604 	addi	fp,sp,24
81142ec8:	e13ffc15 	stw	r4,-16(fp)
81142ecc:	e17ffd15 	stw	r5,-12(fp)
81142ed0:	3005883a 	mov	r2,r6
81142ed4:	e1ffff15 	stw	r7,-4(fp)
81142ed8:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81142edc:	e0800417 	ldw	r2,16(fp)
81142ee0:	1000021e 	bne	r2,zero,81142eec <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81142ee4:	0005883a 	mov	r2,zero
81142ee8:	00005d06 	br	81143060 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81142eec:	e0bffe03 	ldbu	r2,-8(fp)
81142ef0:	10c00060 	cmpeqi	r3,r2,1
81142ef4:	1800091e 	bne	r3,zero,81142f1c <OSTmrCreate+0x6c>
81142ef8:	108000a0 	cmpeqi	r2,r2,2
81142efc:	10000e26 	beq	r2,zero,81142f38 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81142f00:	e0bffd17 	ldw	r2,-12(fp)
81142f04:	1000111e 	bne	r2,zero,81142f4c <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81142f08:	e0800417 	ldw	r2,16(fp)
81142f0c:	00ffe0c4 	movi	r3,-125
81142f10:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81142f14:	0005883a 	mov	r2,zero
81142f18:	00005106 	br	81143060 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81142f1c:	e0bffc17 	ldw	r2,-16(fp)
81142f20:	10000c1e 	bne	r2,zero,81142f54 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81142f24:	e0800417 	ldw	r2,16(fp)
81142f28:	00ffe084 	movi	r3,-126
81142f2c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81142f30:	0005883a 	mov	r2,zero
81142f34:	00004a06 	br	81143060 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81142f38:	e0800417 	ldw	r2,16(fp)
81142f3c:	00ffe104 	movi	r3,-124
81142f40:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81142f44:	0005883a 	mov	r2,zero
81142f48:	00004506 	br	81143060 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81142f4c:	0001883a 	nop
81142f50:	00000106 	br	81142f58 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81142f54:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142f58:	d0a0a103 	ldbu	r2,-32124(gp)
81142f5c:	10803fcc 	andi	r2,r2,255
81142f60:	10000526 	beq	r2,zero,81142f78 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81142f64:	e0800417 	ldw	r2,16(fp)
81142f68:	00ffe2c4 	movi	r3,-117
81142f6c:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81142f70:	0005883a 	mov	r2,zero
81142f74:	00003a06 	br	81143060 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81142f78:	1143e680 	call	81143e68 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81142f7c:	11439080 	call	81143908 <OSTmr_Alloc>
81142f80:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81142f84:	e0bffa17 	ldw	r2,-24(fp)
81142f88:	1000061e 	bne	r2,zero,81142fa4 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81142f8c:	1143eac0 	call	81143eac <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81142f90:	e0800417 	ldw	r2,16(fp)
81142f94:	00ffe184 	movi	r3,-122
81142f98:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81142f9c:	0005883a 	mov	r2,zero
81142fa0:	00002f06 	br	81143060 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81142fa4:	e0bffa17 	ldw	r2,-24(fp)
81142fa8:	00c00044 	movi	r3,1
81142fac:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81142fb0:	e0bffa17 	ldw	r2,-24(fp)
81142fb4:	e0fffc17 	ldw	r3,-16(fp)
81142fb8:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81142fbc:	e0bffa17 	ldw	r2,-24(fp)
81142fc0:	e0fffd17 	ldw	r3,-12(fp)
81142fc4:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81142fc8:	e0bffa17 	ldw	r2,-24(fp)
81142fcc:	e0fffe03 	ldbu	r3,-8(fp)
81142fd0:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81142fd4:	e0bffa17 	ldw	r2,-24(fp)
81142fd8:	e0ffff17 	ldw	r3,-4(fp)
81142fdc:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81142fe0:	e0bffa17 	ldw	r2,-24(fp)
81142fe4:	e0c00217 	ldw	r3,8(fp)
81142fe8:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81142fec:	e0800317 	ldw	r2,12(fp)
81142ff0:	10001726 	beq	r2,zero,81143050 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81142ff4:	e1000317 	ldw	r4,12(fp)
81142ff8:	113be2c0 	call	8113be2c <OS_StrLen>
81142ffc:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81143000:	e0bffb03 	ldbu	r2,-20(fp)
81143004:	10800428 	cmpgeui	r2,r2,16
81143008:	1000061e 	bne	r2,zero,81143024 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8114300c:	e0bffa17 	ldw	r2,-24(fp)
81143010:	10800804 	addi	r2,r2,32
81143014:	e1400317 	ldw	r5,12(fp)
81143018:	1009883a 	mov	r4,r2
8114301c:	113bdb00 	call	8113bdb0 <OS_StrCopy>
81143020:	00000b06 	br	81143050 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81143024:	e0bffa17 	ldw	r2,-24(fp)
81143028:	00c008c4 	movi	r3,35
8114302c:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81143030:	e0bffa17 	ldw	r2,-24(fp)
81143034:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81143038:	e0800417 	ldw	r2,16(fp)
8114303c:	00ffe304 	movi	r3,-116
81143040:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81143044:	1143eac0 	call	81143eac <OSTmr_Unlock>
            return (ptmr);
81143048:	e0bffa17 	ldw	r2,-24(fp)
8114304c:	00000406 	br	81143060 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81143050:	1143eac0 	call	81143eac <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81143054:	e0800417 	ldw	r2,16(fp)
81143058:	10000005 	stb	zero,0(r2)
    return (ptmr);
8114305c:	e0bffa17 	ldw	r2,-24(fp)
}
81143060:	e037883a 	mov	sp,fp
81143064:	dfc00117 	ldw	ra,4(sp)
81143068:	df000017 	ldw	fp,0(sp)
8114306c:	dec00204 	addi	sp,sp,8
81143070:	f800283a 	ret

81143074 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81143074:	defffc04 	addi	sp,sp,-16
81143078:	de00012e 	bgeu	sp,et,81143080 <OSTmrDel+0xc>
8114307c:	003b68fa 	trap	3
81143080:	dfc00315 	stw	ra,12(sp)
81143084:	df000215 	stw	fp,8(sp)
81143088:	df000204 	addi	fp,sp,8
8114308c:	e13ffe15 	stw	r4,-8(fp)
81143090:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81143094:	e0bfff17 	ldw	r2,-4(fp)
81143098:	1000021e 	bne	r2,zero,811430a4 <OSTmrDel+0x30>
        return (OS_FALSE);
8114309c:	0005883a 	mov	r2,zero
811430a0:	00003f06 	br	811431a0 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
811430a4:	e0bffe17 	ldw	r2,-8(fp)
811430a8:	1000051e 	bne	r2,zero,811430c0 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811430ac:	e0bfff17 	ldw	r2,-4(fp)
811430b0:	00ffe284 	movi	r3,-118
811430b4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811430b8:	0005883a 	mov	r2,zero
811430bc:	00003806 	br	811431a0 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811430c0:	e0bffe17 	ldw	r2,-8(fp)
811430c4:	10800003 	ldbu	r2,0(r2)
811430c8:	10803fcc 	andi	r2,r2,255
811430cc:	10801920 	cmpeqi	r2,r2,100
811430d0:	1000051e 	bne	r2,zero,811430e8 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811430d4:	e0bfff17 	ldw	r2,-4(fp)
811430d8:	00ffe244 	movi	r3,-119
811430dc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811430e0:	0005883a 	mov	r2,zero
811430e4:	00002e06 	br	811431a0 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811430e8:	d0a0a103 	ldbu	r2,-32124(gp)
811430ec:	10803fcc 	andi	r2,r2,255
811430f0:	10000526 	beq	r2,zero,81143108 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
811430f4:	e0bfff17 	ldw	r2,-4(fp)
811430f8:	00ffe2c4 	movi	r3,-117
811430fc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143100:	0005883a 	mov	r2,zero
81143104:	00002606 	br	811431a0 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81143108:	1143e680 	call	81143e68 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114310c:	e0bffe17 	ldw	r2,-8(fp)
81143110:	10800c43 	ldbu	r2,49(r2)
81143114:	10803fcc 	andi	r2,r2,255
81143118:	10c000c8 	cmpgei	r3,r2,3
8114311c:	1800031e 	bne	r3,zero,8114312c <OSTmrDel+0xb8>
81143120:	00800d16 	blt	zero,r2,81143158 <OSTmrDel+0xe4>
81143124:	10001326 	beq	r2,zero,81143174 <OSTmrDel+0x100>
81143128:	00001806 	br	8114318c <OSTmrDel+0x118>
8114312c:	108000e0 	cmpeqi	r2,r2,3
81143130:	10001626 	beq	r2,zero,8114318c <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81143134:	e13ffe17 	ldw	r4,-8(fp)
81143138:	1143d6c0 	call	81143d6c <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8114313c:	e13ffe17 	ldw	r4,-8(fp)
81143140:	114397c0 	call	8114397c <OSTmr_Free>
             OSTmr_Unlock();
81143144:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81143148:	e0bfff17 	ldw	r2,-4(fp)
8114314c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81143150:	00800044 	movi	r2,1
81143154:	00001206 	br	811431a0 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81143158:	e13ffe17 	ldw	r4,-8(fp)
8114315c:	114397c0 	call	8114397c <OSTmr_Free>
             OSTmr_Unlock();
81143160:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81143164:	e0bfff17 	ldw	r2,-4(fp)
81143168:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8114316c:	00800044 	movi	r2,1
81143170:	00000b06 	br	811431a0 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81143174:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81143178:	e0bfff17 	ldw	r2,-4(fp)
8114317c:	00ffe1c4 	movi	r3,-121
81143180:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81143184:	0005883a 	mov	r2,zero
81143188:	00000506 	br	811431a0 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8114318c:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81143190:	e0bfff17 	ldw	r2,-4(fp)
81143194:	00ffe344 	movi	r3,-115
81143198:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8114319c:	0005883a 	mov	r2,zero
    }
}
811431a0:	e037883a 	mov	sp,fp
811431a4:	dfc00117 	ldw	ra,4(sp)
811431a8:	df000017 	ldw	fp,0(sp)
811431ac:	dec00204 	addi	sp,sp,8
811431b0:	f800283a 	ret

811431b4 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
811431b4:	defffa04 	addi	sp,sp,-24
811431b8:	de00012e 	bgeu	sp,et,811431c0 <OSTmrNameGet+0xc>
811431bc:	003b68fa 	trap	3
811431c0:	dfc00515 	stw	ra,20(sp)
811431c4:	df000415 	stw	fp,16(sp)
811431c8:	df000404 	addi	fp,sp,16
811431cc:	e13ffd15 	stw	r4,-12(fp)
811431d0:	e17ffe15 	stw	r5,-8(fp)
811431d4:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811431d8:	e0bfff17 	ldw	r2,-4(fp)
811431dc:	1000021e 	bne	r2,zero,811431e8 <OSTmrNameGet+0x34>
        return (0);
811431e0:	0005883a 	mov	r2,zero
811431e4:	00003e06 	br	811432e0 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
811431e8:	e0bffe17 	ldw	r2,-8(fp)
811431ec:	1000051e 	bne	r2,zero,81143204 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
811431f0:	e0bfff17 	ldw	r2,-4(fp)
811431f4:	00ffe204 	movi	r3,-120
811431f8:	10c00005 	stb	r3,0(r2)
        return (0);
811431fc:	0005883a 	mov	r2,zero
81143200:	00003706 	br	811432e0 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81143204:	e0bffd17 	ldw	r2,-12(fp)
81143208:	1000051e 	bne	r2,zero,81143220 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8114320c:	e0bfff17 	ldw	r2,-4(fp)
81143210:	00ffe284 	movi	r3,-118
81143214:	10c00005 	stb	r3,0(r2)
        return (0);
81143218:	0005883a 	mov	r2,zero
8114321c:	00003006 	br	811432e0 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81143220:	e0bffd17 	ldw	r2,-12(fp)
81143224:	10800003 	ldbu	r2,0(r2)
81143228:	10803fcc 	andi	r2,r2,255
8114322c:	10801920 	cmpeqi	r2,r2,100
81143230:	1000051e 	bne	r2,zero,81143248 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81143234:	e0bfff17 	ldw	r2,-4(fp)
81143238:	00ffe244 	movi	r3,-119
8114323c:	10c00005 	stb	r3,0(r2)
        return (0);
81143240:	0005883a 	mov	r2,zero
81143244:	00002606 	br	811432e0 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81143248:	d0a0a103 	ldbu	r2,-32124(gp)
8114324c:	10803fcc 	andi	r2,r2,255
81143250:	10000526 	beq	r2,zero,81143268 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81143254:	e0bfff17 	ldw	r2,-4(fp)
81143258:	00c00444 	movi	r3,17
8114325c:	10c00005 	stb	r3,0(r2)
        return (0);
81143260:	0005883a 	mov	r2,zero
81143264:	00001e06 	br	811432e0 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81143268:	1143e680 	call	81143e68 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114326c:	e0bffd17 	ldw	r2,-12(fp)
81143270:	10800c43 	ldbu	r2,49(r2)
81143274:	10803fcc 	andi	r2,r2,255
81143278:	10000e26 	beq	r2,zero,811432b4 <OSTmrNameGet+0x100>
8114327c:	10001316 	blt	r2,zero,811432cc <OSTmrNameGet+0x118>
81143280:	10800108 	cmpgei	r2,r2,4
81143284:	1000111e 	bne	r2,zero,811432cc <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81143288:	e0bffd17 	ldw	r2,-12(fp)
8114328c:	10800804 	addi	r2,r2,32
81143290:	100b883a 	mov	r5,r2
81143294:	e13ffe17 	ldw	r4,-8(fp)
81143298:	113bdb00 	call	8113bdb0 <OS_StrCopy>
8114329c:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
811432a0:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811432a4:	e0bfff17 	ldw	r2,-4(fp)
811432a8:	10000005 	stb	zero,0(r2)
             return (len);
811432ac:	e0bffc03 	ldbu	r2,-16(fp)
811432b0:	00000b06 	br	811432e0 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
811432b4:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811432b8:	e0bfff17 	ldw	r2,-4(fp)
811432bc:	00ffe1c4 	movi	r3,-121
811432c0:	10c00005 	stb	r3,0(r2)
             return (0);
811432c4:	0005883a 	mov	r2,zero
811432c8:	00000506 	br	811432e0 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
811432cc:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811432d0:	e0bfff17 	ldw	r2,-4(fp)
811432d4:	00ffe344 	movi	r3,-115
811432d8:	10c00005 	stb	r3,0(r2)
             return (0);
811432dc:	0005883a 	mov	r2,zero
    }
}
811432e0:	e037883a 	mov	sp,fp
811432e4:	dfc00117 	ldw	ra,4(sp)
811432e8:	df000017 	ldw	fp,0(sp)
811432ec:	dec00204 	addi	sp,sp,8
811432f0:	f800283a 	ret

811432f4 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
811432f4:	defffb04 	addi	sp,sp,-20
811432f8:	de00012e 	bgeu	sp,et,81143300 <OSTmrRemainGet+0xc>
811432fc:	003b68fa 	trap	3
81143300:	dfc00415 	stw	ra,16(sp)
81143304:	df000315 	stw	fp,12(sp)
81143308:	df000304 	addi	fp,sp,12
8114330c:	e13ffe15 	stw	r4,-8(fp)
81143310:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81143314:	e0bfff17 	ldw	r2,-4(fp)
81143318:	1000021e 	bne	r2,zero,81143324 <OSTmrRemainGet+0x30>
        return (0);
8114331c:	0005883a 	mov	r2,zero
81143320:	00005d06 	br	81143498 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81143324:	e0bffe17 	ldw	r2,-8(fp)
81143328:	1000051e 	bne	r2,zero,81143340 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8114332c:	e0bfff17 	ldw	r2,-4(fp)
81143330:	00ffe284 	movi	r3,-118
81143334:	10c00005 	stb	r3,0(r2)
        return (0);
81143338:	0005883a 	mov	r2,zero
8114333c:	00005606 	br	81143498 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81143340:	e0bffe17 	ldw	r2,-8(fp)
81143344:	10800003 	ldbu	r2,0(r2)
81143348:	10803fcc 	andi	r2,r2,255
8114334c:	10801920 	cmpeqi	r2,r2,100
81143350:	1000051e 	bne	r2,zero,81143368 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81143354:	e0bfff17 	ldw	r2,-4(fp)
81143358:	00ffe244 	movi	r3,-119
8114335c:	10c00005 	stb	r3,0(r2)
        return (0);
81143360:	0005883a 	mov	r2,zero
81143364:	00004c06 	br	81143498 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81143368:	d0a0a103 	ldbu	r2,-32124(gp)
8114336c:	10803fcc 	andi	r2,r2,255
81143370:	10000526 	beq	r2,zero,81143388 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81143374:	e0bfff17 	ldw	r2,-4(fp)
81143378:	00ffe2c4 	movi	r3,-117
8114337c:	10c00005 	stb	r3,0(r2)
        return (0);
81143380:	0005883a 	mov	r2,zero
81143384:	00004406 	br	81143498 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81143388:	1143e680 	call	81143e68 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114338c:	e0bffe17 	ldw	r2,-8(fp)
81143390:	10800c43 	ldbu	r2,49(r2)
81143394:	10803fcc 	andi	r2,r2,255
81143398:	10c00060 	cmpeqi	r3,r2,1
8114339c:	1800121e 	bne	r3,zero,811433e8 <OSTmrRemainGet+0xf4>
811433a0:	10c00088 	cmpgei	r3,r2,2
811433a4:	1800021e 	bne	r3,zero,811433b0 <OSTmrRemainGet+0xbc>
811433a8:	10003026 	beq	r2,zero,8114346c <OSTmrRemainGet+0x178>
811433ac:	00003506 	br	81143484 <OSTmrRemainGet+0x190>
811433b0:	10c000a0 	cmpeqi	r3,r2,2
811433b4:	1800281e 	bne	r3,zero,81143458 <OSTmrRemainGet+0x164>
811433b8:	108000e0 	cmpeqi	r2,r2,3
811433bc:	10003126 	beq	r2,zero,81143484 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
811433c0:	e0bffe17 	ldw	r2,-8(fp)
811433c4:	10c00517 	ldw	r3,20(r2)
811433c8:	d0a0a317 	ldw	r2,-32116(gp)
811433cc:	1885c83a 	sub	r2,r3,r2
811433d0:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
811433d4:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
811433d8:	e0bfff17 	ldw	r2,-4(fp)
811433dc:	10000005 	stb	zero,0(r2)
             return (remain);
811433e0:	e0bffd17 	ldw	r2,-12(fp)
811433e4:	00002c06 	br	81143498 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
811433e8:	e0bffe17 	ldw	r2,-8(fp)
811433ec:	10800c03 	ldbu	r2,48(r2)
811433f0:	10803fcc 	andi	r2,r2,255
811433f4:	108000a0 	cmpeqi	r2,r2,2
811433f8:	10000e26 	beq	r2,zero,81143434 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
811433fc:	e0bffe17 	ldw	r2,-8(fp)
81143400:	10800617 	ldw	r2,24(r2)
81143404:	1000041e 	bne	r2,zero,81143418 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81143408:	e0bffe17 	ldw	r2,-8(fp)
8114340c:	10800717 	ldw	r2,28(r2)
81143410:	e0bffd15 	stw	r2,-12(fp)
81143414:	00000306 	br	81143424 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81143418:	e0bffe17 	ldw	r2,-8(fp)
8114341c:	10800617 	ldw	r2,24(r2)
81143420:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81143424:	1143eac0 	call	81143eac <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81143428:	e0bfff17 	ldw	r2,-4(fp)
8114342c:	10000005 	stb	zero,0(r2)
                      break;
81143430:	00000706 	br	81143450 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81143434:	e0bffe17 	ldw	r2,-8(fp)
81143438:	10800617 	ldw	r2,24(r2)
8114343c:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81143440:	1143eac0 	call	81143eac <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81143444:	e0bfff17 	ldw	r2,-4(fp)
81143448:	10000005 	stb	zero,0(r2)
                      break;
8114344c:	0001883a 	nop
             }
             return (remain);
81143450:	e0bffd17 	ldw	r2,-12(fp)
81143454:	00001006 	br	81143498 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81143458:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114345c:	e0bfff17 	ldw	r2,-4(fp)
81143460:	10000005 	stb	zero,0(r2)
             return (0);
81143464:	0005883a 	mov	r2,zero
81143468:	00000b06 	br	81143498 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8114346c:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81143470:	e0bfff17 	ldw	r2,-4(fp)
81143474:	00ffe1c4 	movi	r3,-121
81143478:	10c00005 	stb	r3,0(r2)
             return (0);
8114347c:	0005883a 	mov	r2,zero
81143480:	00000506 	br	81143498 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
81143484:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81143488:	e0bfff17 	ldw	r2,-4(fp)
8114348c:	00ffe344 	movi	r3,-115
81143490:	10c00005 	stb	r3,0(r2)
             return (0);
81143494:	0005883a 	mov	r2,zero
    }
}
81143498:	e037883a 	mov	sp,fp
8114349c:	dfc00117 	ldw	ra,4(sp)
811434a0:	df000017 	ldw	fp,0(sp)
811434a4:	dec00204 	addi	sp,sp,8
811434a8:	f800283a 	ret

811434ac <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
811434ac:	defffb04 	addi	sp,sp,-20
811434b0:	de00012e 	bgeu	sp,et,811434b8 <OSTmrStateGet+0xc>
811434b4:	003b68fa 	trap	3
811434b8:	dfc00415 	stw	ra,16(sp)
811434bc:	df000315 	stw	fp,12(sp)
811434c0:	df000304 	addi	fp,sp,12
811434c4:	e13ffe15 	stw	r4,-8(fp)
811434c8:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811434cc:	e0bfff17 	ldw	r2,-4(fp)
811434d0:	1000021e 	bne	r2,zero,811434dc <OSTmrStateGet+0x30>
        return (0);
811434d4:	0005883a 	mov	r2,zero
811434d8:	00002a06 	br	81143584 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
811434dc:	e0bffe17 	ldw	r2,-8(fp)
811434e0:	1000051e 	bne	r2,zero,811434f8 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811434e4:	e0bfff17 	ldw	r2,-4(fp)
811434e8:	00ffe284 	movi	r3,-118
811434ec:	10c00005 	stb	r3,0(r2)
        return (0);
811434f0:	0005883a 	mov	r2,zero
811434f4:	00002306 	br	81143584 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
811434f8:	e0bffe17 	ldw	r2,-8(fp)
811434fc:	10800003 	ldbu	r2,0(r2)
81143500:	10803fcc 	andi	r2,r2,255
81143504:	10801920 	cmpeqi	r2,r2,100
81143508:	1000051e 	bne	r2,zero,81143520 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114350c:	e0bfff17 	ldw	r2,-4(fp)
81143510:	00ffe244 	movi	r3,-119
81143514:	10c00005 	stb	r3,0(r2)
        return (0);
81143518:	0005883a 	mov	r2,zero
8114351c:	00001906 	br	81143584 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81143520:	d0a0a103 	ldbu	r2,-32124(gp)
81143524:	10803fcc 	andi	r2,r2,255
81143528:	10000526 	beq	r2,zero,81143540 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8114352c:	e0bfff17 	ldw	r2,-4(fp)
81143530:	00ffe2c4 	movi	r3,-117
81143534:	10c00005 	stb	r3,0(r2)
        return (0);
81143538:	0005883a 	mov	r2,zero
8114353c:	00001106 	br	81143584 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81143540:	1143e680 	call	81143e68 <OSTmr_Lock>
    state = ptmr->OSTmrState;
81143544:	e0bffe17 	ldw	r2,-8(fp)
81143548:	10800c43 	ldbu	r2,49(r2)
8114354c:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81143550:	e0bffd03 	ldbu	r2,-12(fp)
81143554:	1005883a 	mov	r2,r2
81143558:	10800128 	cmpgeui	r2,r2,4
8114355c:	1000031e 	bne	r2,zero,8114356c <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81143560:	e0bfff17 	ldw	r2,-4(fp)
81143564:	10000005 	stb	zero,0(r2)
             break;
81143568:	00000406 	br	8114357c <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8114356c:	e0bfff17 	ldw	r2,-4(fp)
81143570:	00ffe344 	movi	r3,-115
81143574:	10c00005 	stb	r3,0(r2)
             break;
81143578:	0001883a 	nop
    }
    OSTmr_Unlock();
8114357c:	1143eac0 	call	81143eac <OSTmr_Unlock>
    return (state);
81143580:	e0bffd03 	ldbu	r2,-12(fp)
}
81143584:	e037883a 	mov	sp,fp
81143588:	dfc00117 	ldw	ra,4(sp)
8114358c:	df000017 	ldw	fp,0(sp)
81143590:	dec00204 	addi	sp,sp,8
81143594:	f800283a 	ret

81143598 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
81143598:	defffc04 	addi	sp,sp,-16
8114359c:	de00012e 	bgeu	sp,et,811435a4 <OSTmrStart+0xc>
811435a0:	003b68fa 	trap	3
811435a4:	dfc00315 	stw	ra,12(sp)
811435a8:	df000215 	stw	fp,8(sp)
811435ac:	df000204 	addi	fp,sp,8
811435b0:	e13ffe15 	stw	r4,-8(fp)
811435b4:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811435b8:	e0bfff17 	ldw	r2,-4(fp)
811435bc:	1000021e 	bne	r2,zero,811435c8 <OSTmrStart+0x30>
        return (OS_FALSE);
811435c0:	0005883a 	mov	r2,zero
811435c4:	00004106 	br	811436cc <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
811435c8:	e0bffe17 	ldw	r2,-8(fp)
811435cc:	1000051e 	bne	r2,zero,811435e4 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811435d0:	e0bfff17 	ldw	r2,-4(fp)
811435d4:	00ffe284 	movi	r3,-118
811435d8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811435dc:	0005883a 	mov	r2,zero
811435e0:	00003a06 	br	811436cc <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811435e4:	e0bffe17 	ldw	r2,-8(fp)
811435e8:	10800003 	ldbu	r2,0(r2)
811435ec:	10803fcc 	andi	r2,r2,255
811435f0:	10801920 	cmpeqi	r2,r2,100
811435f4:	1000051e 	bne	r2,zero,8114360c <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811435f8:	e0bfff17 	ldw	r2,-4(fp)
811435fc:	00ffe244 	movi	r3,-119
81143600:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143604:	0005883a 	mov	r2,zero
81143608:	00003006 	br	811436cc <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8114360c:	d0a0a103 	ldbu	r2,-32124(gp)
81143610:	10803fcc 	andi	r2,r2,255
81143614:	10000526 	beq	r2,zero,8114362c <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81143618:	e0bfff17 	ldw	r2,-4(fp)
8114361c:	00ffe2c4 	movi	r3,-117
81143620:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143624:	0005883a 	mov	r2,zero
81143628:	00002806 	br	811436cc <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8114362c:	1143e680 	call	81143e68 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81143630:	e0bffe17 	ldw	r2,-8(fp)
81143634:	10800c43 	ldbu	r2,49(r2)
81143638:	10803fcc 	andi	r2,r2,255
8114363c:	10c000c8 	cmpgei	r3,r2,3
81143640:	1800031e 	bne	r3,zero,81143650 <OSTmrStart+0xb8>
81143644:	00800e16 	blt	zero,r2,81143680 <OSTmrStart+0xe8>
81143648:	10001526 	beq	r2,zero,811436a0 <OSTmrStart+0x108>
8114364c:	00001a06 	br	811436b8 <OSTmrStart+0x120>
81143650:	108000e0 	cmpeqi	r2,r2,3
81143654:	10001826 	beq	r2,zero,811436b8 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
81143658:	e13ffe17 	ldw	r4,-8(fp)
8114365c:	1143d6c0 	call	81143d6c <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81143660:	000b883a 	mov	r5,zero
81143664:	e13ffe17 	ldw	r4,-8(fp)
81143668:	1143c1c0 	call	81143c1c <OSTmr_Link>
             OSTmr_Unlock();
8114366c:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81143670:	e0bfff17 	ldw	r2,-4(fp)
81143674:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81143678:	00800044 	movi	r2,1
8114367c:	00001306 	br	811436cc <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81143680:	000b883a 	mov	r5,zero
81143684:	e13ffe17 	ldw	r4,-8(fp)
81143688:	1143c1c0 	call	81143c1c <OSTmr_Link>
             OSTmr_Unlock();
8114368c:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81143690:	e0bfff17 	ldw	r2,-4(fp)
81143694:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81143698:	00800044 	movi	r2,1
8114369c:	00000b06 	br	811436cc <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
811436a0:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811436a4:	e0bfff17 	ldw	r2,-4(fp)
811436a8:	00ffe1c4 	movi	r3,-121
811436ac:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811436b0:	0005883a 	mov	r2,zero
811436b4:	00000506 	br	811436cc <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
811436b8:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811436bc:	e0bfff17 	ldw	r2,-4(fp)
811436c0:	00ffe344 	movi	r3,-115
811436c4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811436c8:	0005883a 	mov	r2,zero
    }
}
811436cc:	e037883a 	mov	sp,fp
811436d0:	dfc00117 	ldw	ra,4(sp)
811436d4:	df000017 	ldw	fp,0(sp)
811436d8:	dec00204 	addi	sp,sp,8
811436dc:	f800283a 	ret

811436e0 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
811436e0:	defff904 	addi	sp,sp,-28
811436e4:	de00012e 	bgeu	sp,et,811436ec <OSTmrStop+0xc>
811436e8:	003b68fa 	trap	3
811436ec:	dfc00615 	stw	ra,24(sp)
811436f0:	df000515 	stw	fp,20(sp)
811436f4:	df000504 	addi	fp,sp,20
811436f8:	e13ffc15 	stw	r4,-16(fp)
811436fc:	2805883a 	mov	r2,r5
81143700:	e1bffe15 	stw	r6,-8(fp)
81143704:	e1ffff15 	stw	r7,-4(fp)
81143708:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8114370c:	e0bfff17 	ldw	r2,-4(fp)
81143710:	1000021e 	bne	r2,zero,8114371c <OSTmrStop+0x3c>
        return (OS_FALSE);
81143714:	0005883a 	mov	r2,zero
81143718:	00006606 	br	811438b4 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8114371c:	e0bffc17 	ldw	r2,-16(fp)
81143720:	1000051e 	bne	r2,zero,81143738 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
81143724:	e0bfff17 	ldw	r2,-4(fp)
81143728:	00ffe284 	movi	r3,-118
8114372c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143730:	0005883a 	mov	r2,zero
81143734:	00005f06 	br	811438b4 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81143738:	e0bffc17 	ldw	r2,-16(fp)
8114373c:	10800003 	ldbu	r2,0(r2)
81143740:	10803fcc 	andi	r2,r2,255
81143744:	10801920 	cmpeqi	r2,r2,100
81143748:	1000051e 	bne	r2,zero,81143760 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114374c:	e0bfff17 	ldw	r2,-4(fp)
81143750:	00ffe244 	movi	r3,-119
81143754:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143758:	0005883a 	mov	r2,zero
8114375c:	00005506 	br	811438b4 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81143760:	d0a0a103 	ldbu	r2,-32124(gp)
81143764:	10803fcc 	andi	r2,r2,255
81143768:	10000526 	beq	r2,zero,81143780 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8114376c:	e0bfff17 	ldw	r2,-4(fp)
81143770:	00ffe2c4 	movi	r3,-117
81143774:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143778:	0005883a 	mov	r2,zero
8114377c:	00004d06 	br	811438b4 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
81143780:	1143e680 	call	81143e68 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81143784:	e0bffc17 	ldw	r2,-16(fp)
81143788:	10800c43 	ldbu	r2,49(r2)
8114378c:	10803fcc 	andi	r2,r2,255
81143790:	10c000c8 	cmpgei	r3,r2,3
81143794:	1800031e 	bne	r3,zero,811437a4 <OSTmrStop+0xc4>
81143798:	00803516 	blt	zero,r2,81143870 <OSTmrStop+0x190>
8114379c:	10003a26 	beq	r2,zero,81143888 <OSTmrStop+0x1a8>
811437a0:	00003f06 	br	811438a0 <OSTmrStop+0x1c0>
811437a4:	108000e0 	cmpeqi	r2,r2,3
811437a8:	10003d26 	beq	r2,zero,811438a0 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
811437ac:	e13ffc17 	ldw	r4,-16(fp)
811437b0:	1143d6c0 	call	81143d6c <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
811437b4:	e0bfff17 	ldw	r2,-4(fp)
811437b8:	10000005 	stb	zero,0(r2)
             switch (opt) {
811437bc:	e0bffd03 	ldbu	r2,-12(fp)
811437c0:	10c000e0 	cmpeqi	r3,r2,3
811437c4:	1800041e 	bne	r3,zero,811437d8 <OSTmrStop+0xf8>
811437c8:	10c00120 	cmpeqi	r3,r2,4
811437cc:	1800121e 	bne	r3,zero,81143818 <OSTmrStop+0x138>
811437d0:	10002326 	beq	r2,zero,81143860 <OSTmrStop+0x180>
811437d4:	00001e06 	br	81143850 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
811437d8:	e0bffc17 	ldw	r2,-16(fp)
811437dc:	10800117 	ldw	r2,4(r2)
811437e0:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
811437e4:	e0bffb17 	ldw	r2,-20(fp)
811437e8:	10000726 	beq	r2,zero,81143808 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
811437ec:	e0bffc17 	ldw	r2,-16(fp)
811437f0:	10c00217 	ldw	r3,8(r2)
811437f4:	e0bffb17 	ldw	r2,-20(fp)
811437f8:	180b883a 	mov	r5,r3
811437fc:	e13ffc17 	ldw	r4,-16(fp)
81143800:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81143804:	00001706 	br	81143864 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81143808:	e0bfff17 	ldw	r2,-4(fp)
8114380c:	00ffe3c4 	movi	r3,-113
81143810:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81143814:	00001306 	br	81143864 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81143818:	e0bffc17 	ldw	r2,-16(fp)
8114381c:	10800117 	ldw	r2,4(r2)
81143820:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81143824:	e0bffb17 	ldw	r2,-20(fp)
81143828:	10000526 	beq	r2,zero,81143840 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8114382c:	e0bffb17 	ldw	r2,-20(fp)
81143830:	e17ffe17 	ldw	r5,-8(fp)
81143834:	e13ffc17 	ldw	r4,-16(fp)
81143838:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8114383c:	00000906 	br	81143864 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81143840:	e0bfff17 	ldw	r2,-4(fp)
81143844:	00ffe3c4 	movi	r3,-113
81143848:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8114384c:	00000506 	br	81143864 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
81143850:	e0bfff17 	ldw	r2,-4(fp)
81143854:	00ffe104 	movi	r3,-124
81143858:	10c00005 	stb	r3,0(r2)
                     break;
8114385c:	00000106 	br	81143864 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81143860:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81143864:	1143eac0 	call	81143eac <OSTmr_Unlock>
             return (OS_TRUE);
81143868:	00800044 	movi	r2,1
8114386c:	00001106 	br	811438b4 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
81143870:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81143874:	e0bfff17 	ldw	r2,-4(fp)
81143878:	00ffe384 	movi	r3,-114
8114387c:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
81143880:	00800044 	movi	r2,1
81143884:	00000b06 	br	811438b4 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
81143888:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8114388c:	e0bfff17 	ldw	r2,-4(fp)
81143890:	00ffe1c4 	movi	r3,-121
81143894:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81143898:	0005883a 	mov	r2,zero
8114389c:	00000506 	br	811438b4 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
811438a0:	1143eac0 	call	81143eac <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811438a4:	e0bfff17 	ldw	r2,-4(fp)
811438a8:	00ffe344 	movi	r3,-115
811438ac:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811438b0:	0005883a 	mov	r2,zero
    }
}
811438b4:	e037883a 	mov	sp,fp
811438b8:	dfc00117 	ldw	ra,4(sp)
811438bc:	df000017 	ldw	fp,0(sp)
811438c0:	dec00204 	addi	sp,sp,8
811438c4:	f800283a 	ret

811438c8 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
811438c8:	defffd04 	addi	sp,sp,-12
811438cc:	de00012e 	bgeu	sp,et,811438d4 <OSTmrSignal+0xc>
811438d0:	003b68fa 	trap	3
811438d4:	dfc00215 	stw	ra,8(sp)
811438d8:	df000115 	stw	fp,4(sp)
811438dc:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
811438e0:	d0a09017 	ldw	r2,-32192(gp)
811438e4:	1009883a 	mov	r4,r2
811438e8:	1140e940 	call	81140e94 <OSSemPost>
811438ec:	e0bfff05 	stb	r2,-4(fp)
    return (err);
811438f0:	e0bfff03 	ldbu	r2,-4(fp)
}
811438f4:	e037883a 	mov	sp,fp
811438f8:	dfc00117 	ldw	ra,4(sp)
811438fc:	df000017 	ldw	fp,0(sp)
81143900:	dec00204 	addi	sp,sp,8
81143904:	f800283a 	ret

81143908 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81143908:	defffe04 	addi	sp,sp,-8
8114390c:	de00012e 	bgeu	sp,et,81143914 <OSTmr_Alloc+0xc>
81143910:	003b68fa 	trap	3
81143914:	df000115 	stw	fp,4(sp)
81143918:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8114391c:	d0a08e17 	ldw	r2,-32200(gp)
81143920:	1000021e 	bne	r2,zero,8114392c <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81143924:	0005883a 	mov	r2,zero
81143928:	00001006 	br	8114396c <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8114392c:	d0a08e17 	ldw	r2,-32200(gp)
81143930:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81143934:	e0bfff17 	ldw	r2,-4(fp)
81143938:	10800317 	ldw	r2,12(r2)
8114393c:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
81143940:	e0bfff17 	ldw	r2,-4(fp)
81143944:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81143948:	e0bfff17 	ldw	r2,-4(fp)
8114394c:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
81143950:	d0a0930b 	ldhu	r2,-32180(gp)
81143954:	10800044 	addi	r2,r2,1
81143958:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
8114395c:	d0a0970b 	ldhu	r2,-32164(gp)
81143960:	10bfffc4 	addi	r2,r2,-1
81143964:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
81143968:	e0bfff17 	ldw	r2,-4(fp)
}
8114396c:	e037883a 	mov	sp,fp
81143970:	df000017 	ldw	fp,0(sp)
81143974:	dec00104 	addi	sp,sp,4
81143978:	f800283a 	ret

8114397c <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8114397c:	defffe04 	addi	sp,sp,-8
81143980:	de00012e 	bgeu	sp,et,81143988 <OSTmr_Free+0xc>
81143984:	003b68fa 	trap	3
81143988:	df000115 	stw	fp,4(sp)
8114398c:	df000104 	addi	fp,sp,4
81143990:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81143994:	e0bfff17 	ldw	r2,-4(fp)
81143998:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8114399c:	e0bfff17 	ldw	r2,-4(fp)
811439a0:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
811439a4:	e0bfff17 	ldw	r2,-4(fp)
811439a8:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
811439ac:	e0bfff17 	ldw	r2,-4(fp)
811439b0:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
811439b4:	e0bfff17 	ldw	r2,-4(fp)
811439b8:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
811439bc:	e0bfff17 	ldw	r2,-4(fp)
811439c0:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
811439c4:	e0bfff17 	ldw	r2,-4(fp)
811439c8:	00c00fc4 	movi	r3,63
811439cc:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
811439d0:	e0bfff17 	ldw	r2,-4(fp)
811439d4:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
811439d8:	e0bfff17 	ldw	r2,-4(fp)
811439dc:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
811439e0:	d0e08e17 	ldw	r3,-32200(gp)
811439e4:	e0bfff17 	ldw	r2,-4(fp)
811439e8:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
811439ec:	e0bfff17 	ldw	r2,-4(fp)
811439f0:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
811439f4:	d0a0930b 	ldhu	r2,-32180(gp)
811439f8:	10bfffc4 	addi	r2,r2,-1
811439fc:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
81143a00:	d0a0970b 	ldhu	r2,-32164(gp)
81143a04:	10800044 	addi	r2,r2,1
81143a08:	d0a0970d 	sth	r2,-32164(gp)
}
81143a0c:	0001883a 	nop
81143a10:	e037883a 	mov	sp,fp
81143a14:	df000017 	ldw	fp,0(sp)
81143a18:	dec00104 	addi	sp,sp,4
81143a1c:	f800283a 	ret

81143a20 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81143a20:	defffa04 	addi	sp,sp,-24
81143a24:	de00012e 	bgeu	sp,et,81143a2c <OSTmr_Init+0xc>
81143a28:	003b68fa 	trap	3
81143a2c:	dfc00515 	stw	ra,20(sp)
81143a30:	df000415 	stw	fp,16(sp)
81143a34:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81143a38:	01406804 	movi	r5,416
81143a3c:	012045f4 	movhi	r4,33047
81143a40:	21258204 	addi	r4,r4,-27128
81143a44:	113bb900 	call	8113bb90 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81143a48:	01400404 	movi	r5,16
81143a4c:	012045f4 	movhi	r4,33047
81143a50:	21236e04 	addi	r4,r4,-29256
81143a54:	113bb900 	call	8113bb90 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
81143a58:	00a045f4 	movhi	r2,33047
81143a5c:	10a58204 	addi	r2,r2,-27128
81143a60:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81143a64:	00a045f4 	movhi	r2,33047
81143a68:	10a58f04 	addi	r2,r2,-27076
81143a6c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81143a70:	e03ffc0d 	sth	zero,-16(fp)
81143a74:	00001606 	br	81143ad0 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81143a78:	e0bffd17 	ldw	r2,-12(fp)
81143a7c:	00c01904 	movi	r3,100
81143a80:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81143a84:	e0bffd17 	ldw	r2,-12(fp)
81143a88:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81143a8c:	e0bffd17 	ldw	r2,-12(fp)
81143a90:	e0fffe17 	ldw	r3,-8(fp)
81143a94:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81143a98:	e0bffd17 	ldw	r2,-12(fp)
81143a9c:	00c00fc4 	movi	r3,63
81143aa0:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81143aa4:	e0bffd17 	ldw	r2,-12(fp)
81143aa8:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81143aac:	e0bffd17 	ldw	r2,-12(fp)
81143ab0:	10800d04 	addi	r2,r2,52
81143ab4:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81143ab8:	e0bffe17 	ldw	r2,-8(fp)
81143abc:	10800d04 	addi	r2,r2,52
81143ac0:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81143ac4:	e0bffc0b 	ldhu	r2,-16(fp)
81143ac8:	10800044 	addi	r2,r2,1
81143acc:	e0bffc0d 	sth	r2,-16(fp)
81143ad0:	e0bffc0b 	ldhu	r2,-16(fp)
81143ad4:	108001f0 	cmpltui	r2,r2,7
81143ad8:	103fe71e 	bne	r2,zero,81143a78 <__reset+0xfb123a78>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81143adc:	e0bffd17 	ldw	r2,-12(fp)
81143ae0:	00c01904 	movi	r3,100
81143ae4:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81143ae8:	e0bffd17 	ldw	r2,-12(fp)
81143aec:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81143af0:	e0bffd17 	ldw	r2,-12(fp)
81143af4:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81143af8:	e0bffd17 	ldw	r2,-12(fp)
81143afc:	00c00fc4 	movi	r3,63
81143b00:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81143b04:	e0bffd17 	ldw	r2,-12(fp)
81143b08:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81143b0c:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
81143b10:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81143b14:	00800204 	movi	r2,8
81143b18:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81143b1c:	00a045f4 	movhi	r2,33047
81143b20:	10a58204 	addi	r2,r2,-27128
81143b24:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
81143b28:	01000044 	movi	r4,1
81143b2c:	11407e40 	call	811407e4 <OSSemCreate>
81143b30:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81143b34:	0009883a 	mov	r4,zero
81143b38:	11407e40 	call	811407e4 <OSSemCreate>
81143b3c:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81143b40:	d0a0a517 	ldw	r2,-32108(gp)
81143b44:	e0ffff04 	addi	r3,fp,-4
81143b48:	180d883a 	mov	r6,r3
81143b4c:	01604574 	movhi	r5,33045
81143b50:	294c2f04 	addi	r5,r5,12476
81143b54:	1009883a 	mov	r4,r2
81143b58:	113a3ec0 	call	8113a3ec <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81143b5c:	d0a09017 	ldw	r2,-32192(gp)
81143b60:	e0ffff04 	addi	r3,fp,-4
81143b64:	180d883a 	mov	r6,r3
81143b68:	01604574 	movhi	r5,33045
81143b6c:	294c3404 	addi	r5,r5,12496
81143b70:	1009883a 	mov	r4,r2
81143b74:	113a3ec0 	call	8113a3ec <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81143b78:	1143b940 	call	81143b94 <OSTmr_InitTask>
}
81143b7c:	0001883a 	nop
81143b80:	e037883a 	mov	sp,fp
81143b84:	dfc00117 	ldw	ra,4(sp)
81143b88:	df000017 	ldw	fp,0(sp)
81143b8c:	dec00204 	addi	sp,sp,8
81143b90:	f800283a 	ret

81143b94 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81143b94:	defff804 	addi	sp,sp,-32
81143b98:	de00012e 	bgeu	sp,et,81143ba0 <OSTmr_InitTask+0xc>
81143b9c:	003b68fa 	trap	3
81143ba0:	dfc00715 	stw	ra,28(sp)
81143ba4:	df000615 	stw	fp,24(sp)
81143ba8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81143bac:	008000c4 	movi	r2,3
81143bb0:	d8800415 	stw	r2,16(sp)
81143bb4:	d8000315 	stw	zero,12(sp)
81143bb8:	00808004 	movi	r2,512
81143bbc:	d8800215 	stw	r2,8(sp)
81143bc0:	00a045f4 	movhi	r2,33047
81143bc4:	10adb604 	addi	r2,r2,-18728
81143bc8:	d8800115 	stw	r2,4(sp)
81143bcc:	00bfff54 	movui	r2,65533
81143bd0:	d8800015 	stw	r2,0(sp)
81143bd4:	01c00744 	movi	r7,29
81143bd8:	01a045f4 	movhi	r6,33047
81143bdc:	31afb504 	addi	r6,r6,-16684
81143be0:	000b883a 	mov	r5,zero
81143be4:	01204534 	movhi	r4,33044
81143be8:	210fba04 	addi	r4,r4,16104
81143bec:	11418780 	call	81141878 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81143bf0:	e1bfff04 	addi	r6,fp,-4
81143bf4:	01604574 	movhi	r5,33045
81143bf8:	294c3904 	addi	r5,r5,12516
81143bfc:	01000744 	movi	r4,29
81143c00:	11420a80 	call	811420a8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81143c04:	0001883a 	nop
81143c08:	e037883a 	mov	sp,fp
81143c0c:	dfc00117 	ldw	ra,4(sp)
81143c10:	df000017 	ldw	fp,0(sp)
81143c14:	dec00204 	addi	sp,sp,8
81143c18:	f800283a 	ret

81143c1c <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81143c1c:	defffa04 	addi	sp,sp,-24
81143c20:	de00012e 	bgeu	sp,et,81143c28 <OSTmr_Link+0xc>
81143c24:	003b68fa 	trap	3
81143c28:	df000515 	stw	fp,20(sp)
81143c2c:	df000504 	addi	fp,sp,20
81143c30:	e13ffe15 	stw	r4,-8(fp)
81143c34:	2805883a 	mov	r2,r5
81143c38:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81143c3c:	e0bffe17 	ldw	r2,-8(fp)
81143c40:	00c000c4 	movi	r3,3
81143c44:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81143c48:	e0bfff03 	ldbu	r2,-4(fp)
81143c4c:	10800058 	cmpnei	r2,r2,1
81143c50:	1000071e 	bne	r2,zero,81143c70 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81143c54:	e0bffe17 	ldw	r2,-8(fp)
81143c58:	10c00717 	ldw	r3,28(r2)
81143c5c:	d0a0a317 	ldw	r2,-32116(gp)
81143c60:	1887883a 	add	r3,r3,r2
81143c64:	e0bffe17 	ldw	r2,-8(fp)
81143c68:	10c00515 	stw	r3,20(r2)
81143c6c:	00001006 	br	81143cb0 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81143c70:	e0bffe17 	ldw	r2,-8(fp)
81143c74:	10800617 	ldw	r2,24(r2)
81143c78:	1000071e 	bne	r2,zero,81143c98 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81143c7c:	e0bffe17 	ldw	r2,-8(fp)
81143c80:	10c00717 	ldw	r3,28(r2)
81143c84:	d0a0a317 	ldw	r2,-32116(gp)
81143c88:	1887883a 	add	r3,r3,r2
81143c8c:	e0bffe17 	ldw	r2,-8(fp)
81143c90:	10c00515 	stw	r3,20(r2)
81143c94:	00000606 	br	81143cb0 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81143c98:	e0bffe17 	ldw	r2,-8(fp)
81143c9c:	10c00617 	ldw	r3,24(r2)
81143ca0:	d0a0a317 	ldw	r2,-32116(gp)
81143ca4:	1887883a 	add	r3,r3,r2
81143ca8:	e0bffe17 	ldw	r2,-8(fp)
81143cac:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81143cb0:	e0bffe17 	ldw	r2,-8(fp)
81143cb4:	10800517 	ldw	r2,20(r2)
81143cb8:	1080004c 	andi	r2,r2,1
81143cbc:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81143cc0:	e0bffb0b 	ldhu	r2,-20(fp)
81143cc4:	100690fa 	slli	r3,r2,3
81143cc8:	00a045f4 	movhi	r2,33047
81143ccc:	10a36e04 	addi	r2,r2,-29256
81143cd0:	1885883a 	add	r2,r3,r2
81143cd4:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81143cd8:	e0bffc17 	ldw	r2,-16(fp)
81143cdc:	10800017 	ldw	r2,0(r2)
81143ce0:	1000091e 	bne	r2,zero,81143d08 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81143ce4:	e0bffc17 	ldw	r2,-16(fp)
81143ce8:	e0fffe17 	ldw	r3,-8(fp)
81143cec:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81143cf0:	e0bffe17 	ldw	r2,-8(fp)
81143cf4:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81143cf8:	e0bffc17 	ldw	r2,-16(fp)
81143cfc:	00c00044 	movi	r3,1
81143d00:	10c0010d 	sth	r3,4(r2)
81143d04:	00001206 	br	81143d50 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81143d08:	e0bffc17 	ldw	r2,-16(fp)
81143d0c:	10800017 	ldw	r2,0(r2)
81143d10:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81143d14:	e0bffc17 	ldw	r2,-16(fp)
81143d18:	e0fffe17 	ldw	r3,-8(fp)
81143d1c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81143d20:	e0bffe17 	ldw	r2,-8(fp)
81143d24:	e0fffd17 	ldw	r3,-12(fp)
81143d28:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81143d2c:	e0bffd17 	ldw	r2,-12(fp)
81143d30:	e0fffe17 	ldw	r3,-8(fp)
81143d34:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81143d38:	e0bffc17 	ldw	r2,-16(fp)
81143d3c:	1080010b 	ldhu	r2,4(r2)
81143d40:	10800044 	addi	r2,r2,1
81143d44:	1007883a 	mov	r3,r2
81143d48:	e0bffc17 	ldw	r2,-16(fp)
81143d4c:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81143d50:	e0bffe17 	ldw	r2,-8(fp)
81143d54:	10000415 	stw	zero,16(r2)
}
81143d58:	0001883a 	nop
81143d5c:	e037883a 	mov	sp,fp
81143d60:	df000017 	ldw	fp,0(sp)
81143d64:	dec00104 	addi	sp,sp,4
81143d68:	f800283a 	ret

81143d6c <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81143d6c:	defffa04 	addi	sp,sp,-24
81143d70:	de00012e 	bgeu	sp,et,81143d78 <OSTmr_Unlink+0xc>
81143d74:	003b68fa 	trap	3
81143d78:	df000515 	stw	fp,20(sp)
81143d7c:	df000504 	addi	fp,sp,20
81143d80:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81143d84:	e0bfff17 	ldw	r2,-4(fp)
81143d88:	10800517 	ldw	r2,20(r2)
81143d8c:	1080004c 	andi	r2,r2,1
81143d90:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81143d94:	e0bffb0b 	ldhu	r2,-20(fp)
81143d98:	100690fa 	slli	r3,r2,3
81143d9c:	00a045f4 	movhi	r2,33047
81143da0:	10a36e04 	addi	r2,r2,-29256
81143da4:	1885883a 	add	r2,r3,r2
81143da8:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81143dac:	e0bffc17 	ldw	r2,-16(fp)
81143db0:	10c00017 	ldw	r3,0(r2)
81143db4:	e0bfff17 	ldw	r2,-4(fp)
81143db8:	18800b1e 	bne	r3,r2,81143de8 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81143dbc:	e0bfff17 	ldw	r2,-4(fp)
81143dc0:	10800317 	ldw	r2,12(r2)
81143dc4:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81143dc8:	e0bffc17 	ldw	r2,-16(fp)
81143dcc:	e0fffd17 	ldw	r3,-12(fp)
81143dd0:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81143dd4:	e0bffd17 	ldw	r2,-12(fp)
81143dd8:	10001126 	beq	r2,zero,81143e20 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81143ddc:	e0bffd17 	ldw	r2,-12(fp)
81143de0:	10000415 	stw	zero,16(r2)
81143de4:	00000e06 	br	81143e20 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81143de8:	e0bfff17 	ldw	r2,-4(fp)
81143dec:	10800417 	ldw	r2,16(r2)
81143df0:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81143df4:	e0bfff17 	ldw	r2,-4(fp)
81143df8:	10800317 	ldw	r2,12(r2)
81143dfc:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81143e00:	e0bffd17 	ldw	r2,-12(fp)
81143e04:	e0fffe17 	ldw	r3,-8(fp)
81143e08:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81143e0c:	e0bffe17 	ldw	r2,-8(fp)
81143e10:	10000326 	beq	r2,zero,81143e20 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81143e14:	e0bffe17 	ldw	r2,-8(fp)
81143e18:	e0fffd17 	ldw	r3,-12(fp)
81143e1c:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81143e20:	e0bfff17 	ldw	r2,-4(fp)
81143e24:	00c00044 	movi	r3,1
81143e28:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81143e2c:	e0bfff17 	ldw	r2,-4(fp)
81143e30:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81143e34:	e0bfff17 	ldw	r2,-4(fp)
81143e38:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81143e3c:	e0bffc17 	ldw	r2,-16(fp)
81143e40:	1080010b 	ldhu	r2,4(r2)
81143e44:	10bfffc4 	addi	r2,r2,-1
81143e48:	1007883a 	mov	r3,r2
81143e4c:	e0bffc17 	ldw	r2,-16(fp)
81143e50:	10c0010d 	sth	r3,4(r2)
}
81143e54:	0001883a 	nop
81143e58:	e037883a 	mov	sp,fp
81143e5c:	df000017 	ldw	fp,0(sp)
81143e60:	dec00104 	addi	sp,sp,4
81143e64:	f800283a 	ret

81143e68 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81143e68:	defffd04 	addi	sp,sp,-12
81143e6c:	de00012e 	bgeu	sp,et,81143e74 <OSTmr_Lock+0xc>
81143e70:	003b68fa 	trap	3
81143e74:	dfc00215 	stw	ra,8(sp)
81143e78:	df000115 	stw	fp,4(sp)
81143e7c:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81143e80:	d0a0a517 	ldw	r2,-32108(gp)
81143e84:	e1bfff04 	addi	r6,fp,-4
81143e88:	000b883a 	mov	r5,zero
81143e8c:	1009883a 	mov	r4,r2
81143e90:	1140b0c0 	call	81140b0c <OSSemPend>
    (void)err;
}
81143e94:	0001883a 	nop
81143e98:	e037883a 	mov	sp,fp
81143e9c:	dfc00117 	ldw	ra,4(sp)
81143ea0:	df000017 	ldw	fp,0(sp)
81143ea4:	dec00204 	addi	sp,sp,8
81143ea8:	f800283a 	ret

81143eac <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81143eac:	defffe04 	addi	sp,sp,-8
81143eb0:	de00012e 	bgeu	sp,et,81143eb8 <OSTmr_Unlock+0xc>
81143eb4:	003b68fa 	trap	3
81143eb8:	dfc00115 	stw	ra,4(sp)
81143ebc:	df000015 	stw	fp,0(sp)
81143ec0:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81143ec4:	d0a0a517 	ldw	r2,-32108(gp)
81143ec8:	1009883a 	mov	r4,r2
81143ecc:	1140e940 	call	81140e94 <OSSemPost>
}
81143ed0:	0001883a 	nop
81143ed4:	e037883a 	mov	sp,fp
81143ed8:	dfc00117 	ldw	ra,4(sp)
81143edc:	df000017 	ldw	fp,0(sp)
81143ee0:	dec00204 	addi	sp,sp,8
81143ee4:	f800283a 	ret

81143ee8 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81143ee8:	defff704 	addi	sp,sp,-36
81143eec:	de00012e 	bgeu	sp,et,81143ef4 <OSTmr_Task+0xc>
81143ef0:	003b68fa 	trap	3
81143ef4:	dfc00815 	stw	ra,32(sp)
81143ef8:	df000715 	stw	fp,28(sp)
81143efc:	df000704 	addi	fp,sp,28
81143f00:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
81143f04:	d0a09017 	ldw	r2,-32192(gp)
81143f08:	e0fffe04 	addi	r3,fp,-8
81143f0c:	180d883a 	mov	r6,r3
81143f10:	000b883a 	mov	r5,zero
81143f14:	1009883a 	mov	r4,r2
81143f18:	1140b0c0 	call	81140b0c <OSSemPend>
        OSTmr_Lock();
81143f1c:	1143e680 	call	81143e68 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81143f20:	d0a0a317 	ldw	r2,-32116(gp)
81143f24:	10800044 	addi	r2,r2,1
81143f28:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81143f2c:	d0a0a317 	ldw	r2,-32116(gp)
81143f30:	1080004c 	andi	r2,r2,1
81143f34:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81143f38:	e0bffa0b 	ldhu	r2,-24(fp)
81143f3c:	100690fa 	slli	r3,r2,3
81143f40:	00a045f4 	movhi	r2,33047
81143f44:	10a36e04 	addi	r2,r2,-29256
81143f48:	1885883a 	add	r2,r3,r2
81143f4c:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81143f50:	e0bffb17 	ldw	r2,-20(fp)
81143f54:	10800017 	ldw	r2,0(r2)
81143f58:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81143f5c:	00002206 	br	81143fe8 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81143f60:	e0bff917 	ldw	r2,-28(fp)
81143f64:	10800317 	ldw	r2,12(r2)
81143f68:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81143f6c:	e0bff917 	ldw	r2,-28(fp)
81143f70:	10c00517 	ldw	r3,20(r2)
81143f74:	d0a0a317 	ldw	r2,-32116(gp)
81143f78:	1880191e 	bne	r3,r2,81143fe0 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81143f7c:	e0bff917 	ldw	r2,-28(fp)
81143f80:	10800117 	ldw	r2,4(r2)
81143f84:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81143f88:	e0bffd17 	ldw	r2,-12(fp)
81143f8c:	10000626 	beq	r2,zero,81143fa8 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81143f90:	e0bff917 	ldw	r2,-28(fp)
81143f94:	10c00217 	ldw	r3,8(r2)
81143f98:	e0bffd17 	ldw	r2,-12(fp)
81143f9c:	180b883a 	mov	r5,r3
81143fa0:	e13ff917 	ldw	r4,-28(fp)
81143fa4:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81143fa8:	e13ff917 	ldw	r4,-28(fp)
81143fac:	1143d6c0 	call	81143d6c <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81143fb0:	e0bff917 	ldw	r2,-28(fp)
81143fb4:	10800c03 	ldbu	r2,48(r2)
81143fb8:	10803fcc 	andi	r2,r2,255
81143fbc:	10800098 	cmpnei	r2,r2,2
81143fc0:	1000041e 	bne	r2,zero,81143fd4 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81143fc4:	01400044 	movi	r5,1
81143fc8:	e13ff917 	ldw	r4,-28(fp)
81143fcc:	1143c1c0 	call	81143c1c <OSTmr_Link>
81143fd0:	00000306 	br	81143fe0 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81143fd4:	e0bff917 	ldw	r2,-28(fp)
81143fd8:	00c00084 	movi	r3,2
81143fdc:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81143fe0:	e0bffc17 	ldw	r2,-16(fp)
81143fe4:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81143fe8:	e0bff917 	ldw	r2,-28(fp)
81143fec:	103fdc1e 	bne	r2,zero,81143f60 <__reset+0xfb123f60>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81143ff0:	1143eac0 	call	81143eac <OSTmr_Unlock>
    }
81143ff4:	003fc306 	br	81143f04 <__reset+0xfb123f04>

81143ff8 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81143ff8:	defffd04 	addi	sp,sp,-12
81143ffc:	de00012e 	bgeu	sp,et,81144004 <alt_dev_reg+0xc>
81144000:	003b68fa 	trap	3
81144004:	dfc00215 	stw	ra,8(sp)
81144008:	df000115 	stw	fp,4(sp)
8114400c:	df000104 	addi	fp,sp,4
81144010:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81144014:	d1600d04 	addi	r5,gp,-32716
81144018:	e13fff17 	ldw	r4,-4(fp)
8114401c:	114c2980 	call	8114c298 <alt_dev_llist_insert>
}
81144020:	e037883a 	mov	sp,fp
81144024:	dfc00117 	ldw	ra,4(sp)
81144028:	df000017 	ldw	fp,0(sp)
8114402c:	dec00204 	addi	sp,sp,8
81144030:	f800283a 	ret

81144034 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81144034:	defffd04 	addi	sp,sp,-12
81144038:	de00012e 	bgeu	sp,et,81144040 <alt_irq_init+0xc>
8114403c:	003b68fa 	trap	3
81144040:	dfc00215 	stw	ra,8(sp)
81144044:	df000115 	stw	fp,4(sp)
81144048:	df000104 	addi	fp,sp,4
8114404c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81144050:	114cc600 	call	8114cc60 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81144054:	00800044 	movi	r2,1
81144058:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8114405c:	0001883a 	nop
81144060:	e037883a 	mov	sp,fp
81144064:	dfc00117 	ldw	ra,4(sp)
81144068:	df000017 	ldw	fp,0(sp)
8114406c:	dec00204 	addi	sp,sp,8
81144070:	f800283a 	ret

81144074 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81144074:	defffe04 	addi	sp,sp,-8
81144078:	de00012e 	bgeu	sp,et,81144080 <alt_sys_init+0xc>
8114407c:	003b68fa 	trap	3
81144080:	dfc00115 	stw	ra,4(sp)
81144084:	df000015 	stw	fp,0(sp)
81144088:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8114408c:	01c0fa04 	movi	r7,1000
81144090:	01800304 	movi	r6,12
81144094:	000b883a 	mov	r5,zero
81144098:	01200034 	movhi	r4,32768
8114409c:	21022004 	addi	r4,r4,2176
811440a0:	11493cc0 	call	811493cc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
811440a4:	018002c4 	movi	r6,11
811440a8:	000b883a 	mov	r5,zero
811440ac:	01204574 	movhi	r4,33045
811440b0:	210fd504 	addi	r4,r4,16212
811440b4:	11486b80 	call	811486b8 <altera_avalon_jtag_uart_init>
811440b8:	01204574 	movhi	r4,33045
811440bc:	210fcb04 	addi	r4,r4,16172
811440c0:	1143ff80 	call	81143ff8 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
811440c4:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
811440c8:	018003c4 	movi	r6,15
811440cc:	000b883a 	mov	r5,zero
811440d0:	01204574 	movhi	r4,33045
811440d4:	2113f004 	addi	r4,r4,20416
811440d8:	11495780 	call	81149578 <altera_avalon_uart_init>
811440dc:	01204574 	movhi	r4,33045
811440e0:	2113e604 	addi	r4,r4,20376
811440e4:	1143ff80 	call	81143ff8 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
811440e8:	00a04574 	movhi	r2,33045
811440ec:	10941a04 	addi	r2,r2,20584
811440f0:	10c00717 	ldw	r3,28(r2)
811440f4:	00a04574 	movhi	r2,33045
811440f8:	10941a04 	addi	r2,r2,20584
811440fc:	10800817 	ldw	r2,32(r2)
81144100:	100d883a 	mov	r6,r2
81144104:	180b883a 	mov	r5,r3
81144108:	01204574 	movhi	r4,33045
8114410c:	21141a04 	addi	r4,r4,20584
81144110:	114be000 	call	8114be00 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81144114:	00a04574 	movhi	r2,33045
81144118:	10943304 	addi	r2,r2,20684
8114411c:	10c00717 	ldw	r3,28(r2)
81144120:	00a04574 	movhi	r2,33045
81144124:	10943304 	addi	r2,r2,20684
81144128:	10800817 	ldw	r2,32(r2)
8114412c:	100d883a 	mov	r6,r2
81144130:	180b883a 	mov	r5,r3
81144134:	01204574 	movhi	r4,33045
81144138:	21143304 	addi	r4,r4,20684
8114413c:	114be000 	call	8114be00 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81144140:	01204574 	movhi	r4,33045
81144144:	21144c04 	addi	r4,r4,20784
81144148:	1143ff80 	call	81143ff8 <alt_dev_reg>
}
8114414c:	0001883a 	nop
81144150:	e037883a 	mov	sp,fp
81144154:	dfc00117 	ldw	ra,4(sp)
81144158:	df000017 	ldw	fp,0(sp)
8114415c:	dec00204 	addi	sp,sp,8
81144160:	f800283a 	ret

81144164 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81144164:	defffa04 	addi	sp,sp,-24
81144168:	de00012e 	bgeu	sp,et,81144170 <Write_Sector_Data+0xc>
8114416c:	003b68fa 	trap	3
81144170:	dfc00515 	stw	ra,20(sp)
81144174:	df000415 	stw	fp,16(sp)
81144178:	df000404 	addi	fp,sp,16
8114417c:	e13ffe15 	stw	r4,-8(fp)
81144180:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81144184:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81144188:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
8114418c:	10001e26 	beq	r2,zero,81144208 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81144190:	00803fc4 	movi	r2,255
81144194:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81144198:	d0a0af17 	ldw	r2,-32068(gp)
8114419c:	e13ffe17 	ldw	r4,-8(fp)
811441a0:	e0ffff17 	ldw	r3,-4(fp)
811441a4:	20c7883a 	add	r3,r4,r3
811441a8:	1806927a 	slli	r3,r3,9
811441ac:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
811441b0:	d0a0ae17 	ldw	r2,-32072(gp)
811441b4:	00c00604 	movi	r3,24
811441b8:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811441bc:	d0a0ab17 	ldw	r2,-32084(gp)
811441c0:	1080002b 	ldhuio	r2,0(r2)
811441c4:	10bfffcc 	andi	r2,r2,65535
811441c8:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
811441cc:	e0bffd0b 	ldhu	r2,-12(fp)
811441d0:	10bfffcc 	andi	r2,r2,65535
811441d4:	1080010c 	andi	r2,r2,4
811441d8:	103ff81e 	bne	r2,zero,811441bc <__reset+0xfb1241bc>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
811441dc:	e0bffd0b 	ldhu	r2,-12(fp)
811441e0:	10bfffcc 	andi	r2,r2,65535
811441e4:	1080040c 	andi	r2,r2,16
811441e8:	1000071e 	bne	r2,zero,81144208 <Write_Sector_Data+0xa4>
        {
            result = true;
811441ec:	00800044 	movi	r2,1
811441f0:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
811441f4:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
811441f8:	e0fffe17 	ldw	r3,-8(fp)
811441fc:	e0bfff17 	ldw	r2,-4(fp)
81144200:	1885883a 	add	r2,r3,r2
81144204:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
81144208:	e0bffc17 	ldw	r2,-16(fp)
}
8114420c:	e037883a 	mov	sp,fp
81144210:	dfc00117 	ldw	ra,4(sp)
81144214:	df000017 	ldw	fp,0(sp)
81144218:	dec00204 	addi	sp,sp,8
8114421c:	f800283a 	ret

81144220 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81144220:	defffd04 	addi	sp,sp,-12
81144224:	de00012e 	bgeu	sp,et,8114422c <Save_Modified_Sector+0xc>
81144228:	003b68fa 	trap	3
8114422c:	dfc00215 	stw	ra,8(sp)
81144230:	df000115 	stw	fp,4(sp)
81144234:	df000104 	addi	fp,sp,4
    bool result = true;
81144238:	00800044 	movi	r2,1
8114423c:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81144240:	d0a0b417 	ldw	r2,-32048(gp)
81144244:	10000526 	beq	r2,zero,8114425c <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81144248:	d0a0b517 	ldw	r2,-32044(gp)
8114424c:	000b883a 	mov	r5,zero
81144250:	1009883a 	mov	r4,r2
81144254:	11441640 	call	81144164 <Write_Sector_Data>
81144258:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8114425c:	e0bfff17 	ldw	r2,-4(fp)
}
81144260:	e037883a 	mov	sp,fp
81144264:	dfc00117 	ldw	ra,4(sp)
81144268:	df000017 	ldw	fp,0(sp)
8114426c:	dec00204 	addi	sp,sp,8
81144270:	f800283a 	ret

81144274 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81144274:	defffa04 	addi	sp,sp,-24
81144278:	de00012e 	bgeu	sp,et,81144280 <Read_Sector_Data+0xc>
8114427c:	003b68fa 	trap	3
81144280:	dfc00515 	stw	ra,20(sp)
81144284:	df000415 	stw	fp,16(sp)
81144288:	df000404 	addi	fp,sp,16
8114428c:	e13ffe15 	stw	r4,-8(fp)
81144290:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
81144294:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81144298:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
8114429c:	10002726 	beq	r2,zero,8114433c <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
811442a0:	00803fc4 	movi	r2,255
811442a4:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
811442a8:	d0a0b417 	ldw	r2,-32048(gp)
811442ac:	10000726 	beq	r2,zero,811442cc <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
811442b0:	d0a0b517 	ldw	r2,-32044(gp)
811442b4:	000b883a 	mov	r5,zero
811442b8:	1009883a 	mov	r4,r2
811442bc:	11441640 	call	81144164 <Write_Sector_Data>
811442c0:	1000021e 	bne	r2,zero,811442cc <Read_Sector_Data+0x58>
            {
                return false;
811442c4:	0005883a 	mov	r2,zero
811442c8:	00001d06 	br	81144340 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811442cc:	d0a0af17 	ldw	r2,-32068(gp)
811442d0:	e13ffe17 	ldw	r4,-8(fp)
811442d4:	e0ffff17 	ldw	r3,-4(fp)
811442d8:	20c7883a 	add	r3,r4,r3
811442dc:	1806927a 	slli	r3,r3,9
811442e0:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
811442e4:	d0a0ae17 	ldw	r2,-32072(gp)
811442e8:	00c00444 	movi	r3,17
811442ec:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811442f0:	d0a0ab17 	ldw	r2,-32084(gp)
811442f4:	1080002b 	ldhuio	r2,0(r2)
811442f8:	10bfffcc 	andi	r2,r2,65535
811442fc:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81144300:	e0bffd0b 	ldhu	r2,-12(fp)
81144304:	10bfffcc 	andi	r2,r2,65535
81144308:	1080010c 	andi	r2,r2,4
8114430c:	103ff81e 	bne	r2,zero,811442f0 <__reset+0xfb1242f0>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81144310:	e0bffd0b 	ldhu	r2,-12(fp)
81144314:	10bfffcc 	andi	r2,r2,65535
81144318:	1080040c 	andi	r2,r2,16
8114431c:	1000071e 	bne	r2,zero,8114433c <Read_Sector_Data+0xc8>
		{
			result = true;
81144320:	00800044 	movi	r2,1
81144324:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81144328:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
8114432c:	e0fffe17 	ldw	r3,-8(fp)
81144330:	e0bfff17 	ldw	r2,-4(fp)
81144334:	1885883a 	add	r2,r3,r2
81144338:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
8114433c:	e0bffc17 	ldw	r2,-16(fp)
}
81144340:	e037883a 	mov	sp,fp
81144344:	dfc00117 	ldw	ra,4(sp)
81144348:	df000017 	ldw	fp,0(sp)
8114434c:	dec00204 	addi	sp,sp,8
81144350:	f800283a 	ret

81144354 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81144354:	defffb04 	addi	sp,sp,-20
81144358:	de00012e 	bgeu	sp,et,81144360 <get_cluster_flag+0xc>
8114435c:	003b68fa 	trap	3
81144360:	dfc00415 	stw	ra,16(sp)
81144364:	df000315 	stw	fp,12(sp)
81144368:	df000304 	addi	fp,sp,12
8114436c:	e13ffe15 	stw	r4,-8(fp)
81144370:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81144374:	e0bffe17 	ldw	r2,-8(fp)
81144378:	1004d23a 	srli	r2,r2,8
8114437c:	d0e0b117 	ldw	r3,-32060(gp)
81144380:	10c5883a 	add	r2,r2,r3
81144384:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81144388:	00a045f4 	movhi	r2,33047
8114438c:	10bb9404 	addi	r2,r2,-4528
81144390:	10801117 	ldw	r2,68(r2)
81144394:	e0fffd17 	ldw	r3,-12(fp)
81144398:	1885883a 	add	r2,r3,r2
8114439c:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
811443a0:	d0a0b517 	ldw	r2,-32044(gp)
811443a4:	e0fffd17 	ldw	r3,-12(fp)
811443a8:	18800726 	beq	r3,r2,811443c8 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811443ac:	e0bffd17 	ldw	r2,-12(fp)
811443b0:	000b883a 	mov	r5,zero
811443b4:	1009883a 	mov	r4,r2
811443b8:	11442740 	call	81144274 <Read_Sector_Data>
811443bc:	1000021e 	bne	r2,zero,811443c8 <get_cluster_flag+0x74>
        {
            return false;
811443c0:	0005883a 	mov	r2,zero
811443c4:	00000d06 	br	811443fc <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
811443c8:	e0bffe17 	ldw	r2,-8(fp)
811443cc:	10803fcc 	andi	r2,r2,255
811443d0:	1085883a 	add	r2,r2,r2
811443d4:	1007883a 	mov	r3,r2
811443d8:	d0a0b317 	ldw	r2,-32052(gp)
811443dc:	10800a17 	ldw	r2,40(r2)
811443e0:	1885883a 	add	r2,r3,r2
811443e4:	1080002b 	ldhuio	r2,0(r2)
811443e8:	10bfffcc 	andi	r2,r2,65535
811443ec:	1007883a 	mov	r3,r2
811443f0:	e0bfff17 	ldw	r2,-4(fp)
811443f4:	10c0000d 	sth	r3,0(r2)
    return true;
811443f8:	00800044 	movi	r2,1
}
811443fc:	e037883a 	mov	sp,fp
81144400:	dfc00117 	ldw	ra,4(sp)
81144404:	df000017 	ldw	fp,0(sp)
81144408:	dec00204 	addi	sp,sp,8
8114440c:	f800283a 	ret

81144410 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81144410:	defffa04 	addi	sp,sp,-24
81144414:	de00012e 	bgeu	sp,et,8114441c <mark_cluster+0xc>
81144418:	003b68fa 	trap	3
8114441c:	dfc00515 	stw	ra,20(sp)
81144420:	df000415 	stw	fp,16(sp)
81144424:	df000404 	addi	fp,sp,16
81144428:	e13ffd15 	stw	r4,-12(fp)
8114442c:	2805883a 	mov	r2,r5
81144430:	e1bfff15 	stw	r6,-4(fp)
81144434:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81144438:	e0bffd17 	ldw	r2,-12(fp)
8114443c:	1004d23a 	srli	r2,r2,8
81144440:	d0e0b117 	ldw	r3,-32060(gp)
81144444:	10c5883a 	add	r2,r2,r3
81144448:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8114444c:	e0bfff17 	ldw	r2,-4(fp)
81144450:	10000726 	beq	r2,zero,81144470 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81144454:	00a045f4 	movhi	r2,33047
81144458:	10bb9404 	addi	r2,r2,-4528
8114445c:	10801117 	ldw	r2,68(r2)
81144460:	e0fffc17 	ldw	r3,-16(fp)
81144464:	1885883a 	add	r2,r3,r2
81144468:	e0bffc15 	stw	r2,-16(fp)
8114446c:	00000606 	br	81144488 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
81144470:	00a045f4 	movhi	r2,33047
81144474:	10bb9404 	addi	r2,r2,-4528
81144478:	10801217 	ldw	r2,72(r2)
8114447c:	e0fffc17 	ldw	r3,-16(fp)
81144480:	1885883a 	add	r2,r3,r2
81144484:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81144488:	d0a0b517 	ldw	r2,-32044(gp)
8114448c:	e0fffc17 	ldw	r3,-16(fp)
81144490:	18800726 	beq	r3,r2,811444b0 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81144494:	e0bffc17 	ldw	r2,-16(fp)
81144498:	000b883a 	mov	r5,zero
8114449c:	1009883a 	mov	r4,r2
811444a0:	11442740 	call	81144274 <Read_Sector_Data>
811444a4:	1000021e 	bne	r2,zero,811444b0 <mark_cluster+0xa0>
        {
            return false;
811444a8:	0005883a 	mov	r2,zero
811444ac:	00000d06 	br	811444e4 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
811444b0:	e0bffd17 	ldw	r2,-12(fp)
811444b4:	10803fcc 	andi	r2,r2,255
811444b8:	1085883a 	add	r2,r2,r2
811444bc:	1007883a 	mov	r3,r2
811444c0:	d0a0b317 	ldw	r2,-32052(gp)
811444c4:	10800a17 	ldw	r2,40(r2)
811444c8:	1885883a 	add	r2,r3,r2
811444cc:	1007883a 	mov	r3,r2
811444d0:	e0bffe0f 	ldh	r2,-8(fp)
811444d4:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
811444d8:	00800044 	movi	r2,1
811444dc:	d0a0b415 	stw	r2,-32048(gp)
    return true;
811444e0:	00800044 	movi	r2,1
}
811444e4:	e037883a 	mov	sp,fp
811444e8:	dfc00117 	ldw	ra,4(sp)
811444ec:	df000017 	ldw	fp,0(sp)
811444f0:	dec00204 	addi	sp,sp,8
811444f4:	f800283a 	ret

811444f8 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
811444f8:	defff704 	addi	sp,sp,-36
811444fc:	de00012e 	bgeu	sp,et,81144504 <Check_for_Master_Boot_Record+0xc>
81144500:	003b68fa 	trap	3
81144504:	dfc00815 	stw	ra,32(sp)
81144508:	df000715 	stw	fp,28(sp)
8114450c:	df000704 	addi	fp,sp,28
	bool result = false;
81144510:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81144514:	000b883a 	mov	r5,zero
81144518:	0009883a 	mov	r4,zero
8114451c:	11442740 	call	81144274 <Read_Sector_Data>
81144520:	10005a26 	beq	r2,zero,8114468c <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81144524:	d0a0b317 	ldw	r2,-32052(gp)
81144528:	10800a17 	ldw	r2,40(r2)
8114452c:	10807f84 	addi	r2,r2,510
81144530:	1080002b 	ldhuio	r2,0(r2)
81144534:	10bfffcc 	andi	r2,r2,65535
81144538:	10bfffcc 	andi	r2,r2,65535
8114453c:	10a0001c 	xori	r2,r2,32768
81144540:	10a00004 	addi	r2,r2,-32768
81144544:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81144548:	e0bffb17 	ldw	r2,-20(fp)
8114454c:	10ffffcc 	andi	r3,r2,65535
81144550:	00aa9554 	movui	r2,43605
81144554:	18804d1e 	bne	r3,r2,8114468c <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81144558:	e03ffa15 	stw	zero,-24(fp)
8114455c:	00004806 	br	81144680 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81144560:	e0bffa17 	ldw	r2,-24(fp)
81144564:	1004913a 	slli	r2,r2,4
81144568:	10806f84 	addi	r2,r2,446
8114456c:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
81144570:	d0a0b317 	ldw	r2,-32052(gp)
81144574:	10c00a17 	ldw	r3,40(r2)
81144578:	e0bffc17 	ldw	r2,-16(fp)
8114457c:	1885883a 	add	r2,r3,r2
81144580:	10800104 	addi	r2,r2,4
81144584:	10800023 	ldbuio	r2,0(r2)
81144588:	10803fcc 	andi	r2,r2,255
8114458c:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
81144590:	e0bffd07 	ldb	r2,-12(fp)
81144594:	10800060 	cmpeqi	r2,r2,1
81144598:	1000091e 	bne	r2,zero,811445c0 <Check_for_Master_Boot_Record+0xc8>
8114459c:	e0bffd07 	ldb	r2,-12(fp)
811445a0:	10800120 	cmpeqi	r2,r2,4
811445a4:	1000061e 	bne	r2,zero,811445c0 <Check_for_Master_Boot_Record+0xc8>
811445a8:	e0bffd07 	ldb	r2,-12(fp)
811445ac:	108001a0 	cmpeqi	r2,r2,6
811445b0:	1000031e 	bne	r2,zero,811445c0 <Check_for_Master_Boot_Record+0xc8>
811445b4:	e0bffd07 	ldb	r2,-12(fp)
811445b8:	10800398 	cmpnei	r2,r2,14
811445bc:	10002d1e 	bne	r2,zero,81144674 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
811445c0:	d0a0b317 	ldw	r2,-32052(gp)
811445c4:	10c00a17 	ldw	r3,40(r2)
811445c8:	e0bffc17 	ldw	r2,-16(fp)
811445cc:	1885883a 	add	r2,r3,r2
811445d0:	10800284 	addi	r2,r2,10
811445d4:	1080002b 	ldhuio	r2,0(r2)
811445d8:	10bfffcc 	andi	r2,r2,65535
811445dc:	1006943a 	slli	r3,r2,16
811445e0:	d0a0b317 	ldw	r2,-32052(gp)
811445e4:	11000a17 	ldw	r4,40(r2)
811445e8:	e0bffc17 	ldw	r2,-16(fp)
811445ec:	2085883a 	add	r2,r4,r2
811445f0:	10800204 	addi	r2,r2,8
811445f4:	1080002b 	ldhuio	r2,0(r2)
811445f8:	10bfffcc 	andi	r2,r2,65535
811445fc:	10bfffcc 	andi	r2,r2,65535
81144600:	1884b03a 	or	r2,r3,r2
81144604:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81144608:	d0a0b317 	ldw	r2,-32052(gp)
8114460c:	10c00a17 	ldw	r3,40(r2)
81144610:	e0bffc17 	ldw	r2,-16(fp)
81144614:	1885883a 	add	r2,r3,r2
81144618:	10800384 	addi	r2,r2,14
8114461c:	1080002b 	ldhuio	r2,0(r2)
81144620:	10bfffcc 	andi	r2,r2,65535
81144624:	1006943a 	slli	r3,r2,16
81144628:	d0a0b317 	ldw	r2,-32052(gp)
8114462c:	11000a17 	ldw	r4,40(r2)
81144630:	e0bffc17 	ldw	r2,-16(fp)
81144634:	2085883a 	add	r2,r4,r2
81144638:	10800304 	addi	r2,r2,12
8114463c:	1080002b 	ldhuio	r2,0(r2)
81144640:	10bfffcc 	andi	r2,r2,65535
81144644:	10bfffcc 	andi	r2,r2,65535
81144648:	1884b03a 	or	r2,r3,r2
8114464c:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
81144650:	e0bfff17 	ldw	r2,-4(fp)
81144654:	0080070e 	bge	zero,r2,81144674 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81144658:	00800044 	movi	r2,1
8114465c:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81144660:	e0bfff17 	ldw	r2,-4(fp)
81144664:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81144668:	e0bffe17 	ldw	r2,-8(fp)
8114466c:	d0a0b115 	stw	r2,-32060(gp)
						break;
81144670:	00000606 	br	8114468c <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81144674:	e0bffa17 	ldw	r2,-24(fp)
81144678:	10800044 	addi	r2,r2,1
8114467c:	e0bffa15 	stw	r2,-24(fp)
81144680:	e0bffa17 	ldw	r2,-24(fp)
81144684:	10800110 	cmplti	r2,r2,4
81144688:	103fb51e 	bne	r2,zero,81144560 <__reset+0xfb124560>
				}
			}
		}
	}

	return result;
8114468c:	e0bff917 	ldw	r2,-28(fp)
}
81144690:	e037883a 	mov	sp,fp
81144694:	dfc00117 	ldw	ra,4(sp)
81144698:	df000017 	ldw	fp,0(sp)
8114469c:	dec00204 	addi	sp,sp,8
811446a0:	f800283a 	ret

811446a4 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
811446a4:	defff804 	addi	sp,sp,-32
811446a8:	de00012e 	bgeu	sp,et,811446b0 <Read_File_Record_At_Offset+0xc>
811446ac:	003b68fa 	trap	3
811446b0:	dfc00715 	stw	ra,28(sp)
811446b4:	df000615 	stw	fp,24(sp)
811446b8:	df000604 	addi	fp,sp,24
811446bc:	e13ffc15 	stw	r4,-16(fp)
811446c0:	e17ffd15 	stw	r5,-12(fp)
811446c4:	e1bffe15 	stw	r6,-8(fp)
811446c8:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
811446cc:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811446d0:	e0bffc17 	ldw	r2,-16(fp)
811446d4:	108007cc 	andi	r2,r2,31
811446d8:	10008d1e 	bne	r2,zero,81144910 <Read_File_Record_At_Offset+0x26c>
811446dc:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
811446e0:	10008b26 	beq	r2,zero,81144910 <Read_File_Record_At_Offset+0x26c>
811446e4:	d0a0aa17 	ldw	r2,-32088(gp)
811446e8:	10008926 	beq	r2,zero,81144910 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811446ec:	e03ffb15 	stw	zero,-20(fp)
811446f0:	00001106 	br	81144738 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
811446f4:	e0fffc17 	ldw	r3,-16(fp)
811446f8:	e0bffb17 	ldw	r2,-20(fp)
811446fc:	1885883a 	add	r2,r3,r2
81144700:	1007883a 	mov	r3,r2
81144704:	d0a0b317 	ldw	r2,-32052(gp)
81144708:	10800a17 	ldw	r2,40(r2)
8114470c:	1885883a 	add	r2,r3,r2
81144710:	10800023 	ldbuio	r2,0(r2)
81144714:	10803fcc 	andi	r2,r2,255
81144718:	1009883a 	mov	r4,r2
8114471c:	e0fffd17 	ldw	r3,-12(fp)
81144720:	e0bffb17 	ldw	r2,-20(fp)
81144724:	1885883a 	add	r2,r3,r2
81144728:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8114472c:	e0bffb17 	ldw	r2,-20(fp)
81144730:	10800044 	addi	r2,r2,1
81144734:	e0bffb15 	stw	r2,-20(fp)
81144738:	e0bffb17 	ldw	r2,-20(fp)
8114473c:	10800210 	cmplti	r2,r2,8
81144740:	103fec1e 	bne	r2,zero,811446f4 <__reset+0xfb1246f4>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81144744:	e03ffb15 	stw	zero,-20(fp)
81144748:	00001306 	br	81144798 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8114474c:	e0fffc17 	ldw	r3,-16(fp)
81144750:	e0bffb17 	ldw	r2,-20(fp)
81144754:	1885883a 	add	r2,r3,r2
81144758:	1007883a 	mov	r3,r2
8114475c:	d0a0b317 	ldw	r2,-32052(gp)
81144760:	10800a17 	ldw	r2,40(r2)
81144764:	1885883a 	add	r2,r3,r2
81144768:	10800204 	addi	r2,r2,8
8114476c:	10800023 	ldbuio	r2,0(r2)
81144770:	10803fcc 	andi	r2,r2,255
81144774:	1009883a 	mov	r4,r2
81144778:	e0fffd17 	ldw	r3,-12(fp)
8114477c:	e0bffb17 	ldw	r2,-20(fp)
81144780:	1885883a 	add	r2,r3,r2
81144784:	10800204 	addi	r2,r2,8
81144788:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8114478c:	e0bffb17 	ldw	r2,-20(fp)
81144790:	10800044 	addi	r2,r2,1
81144794:	e0bffb15 	stw	r2,-20(fp)
81144798:	e0bffb17 	ldw	r2,-20(fp)
8114479c:	108000d0 	cmplti	r2,r2,3
811447a0:	103fea1e 	bne	r2,zero,8114474c <__reset+0xfb12474c>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
811447a4:	d0a0b317 	ldw	r2,-32052(gp)
811447a8:	10c00a17 	ldw	r3,40(r2)
811447ac:	e0bffc17 	ldw	r2,-16(fp)
811447b0:	1885883a 	add	r2,r3,r2
811447b4:	108002c4 	addi	r2,r2,11
811447b8:	10800023 	ldbuio	r2,0(r2)
811447bc:	10803fcc 	andi	r2,r2,255
811447c0:	1007883a 	mov	r3,r2
811447c4:	e0bffd17 	ldw	r2,-12(fp)
811447c8:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
811447cc:	d0a0b317 	ldw	r2,-32052(gp)
811447d0:	10c00a17 	ldw	r3,40(r2)
811447d4:	e0bffc17 	ldw	r2,-16(fp)
811447d8:	1885883a 	add	r2,r3,r2
811447dc:	10800384 	addi	r2,r2,14
811447e0:	1080002b 	ldhuio	r2,0(r2)
811447e4:	10bfffcc 	andi	r2,r2,65535
811447e8:	1007883a 	mov	r3,r2
811447ec:	e0bffd17 	ldw	r2,-12(fp)
811447f0:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
811447f4:	d0a0b317 	ldw	r2,-32052(gp)
811447f8:	10c00a17 	ldw	r3,40(r2)
811447fc:	e0bffc17 	ldw	r2,-16(fp)
81144800:	1885883a 	add	r2,r3,r2
81144804:	10800404 	addi	r2,r2,16
81144808:	1080002b 	ldhuio	r2,0(r2)
8114480c:	10bfffcc 	andi	r2,r2,65535
81144810:	1007883a 	mov	r3,r2
81144814:	e0bffd17 	ldw	r2,-12(fp)
81144818:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8114481c:	d0a0b317 	ldw	r2,-32052(gp)
81144820:	10c00a17 	ldw	r3,40(r2)
81144824:	e0bffc17 	ldw	r2,-16(fp)
81144828:	1885883a 	add	r2,r3,r2
8114482c:	10800484 	addi	r2,r2,18
81144830:	1080002b 	ldhuio	r2,0(r2)
81144834:	10bfffcc 	andi	r2,r2,65535
81144838:	1007883a 	mov	r3,r2
8114483c:	e0bffd17 	ldw	r2,-12(fp)
81144840:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81144844:	d0a0b317 	ldw	r2,-32052(gp)
81144848:	10c00a17 	ldw	r3,40(r2)
8114484c:	e0bffc17 	ldw	r2,-16(fp)
81144850:	1885883a 	add	r2,r3,r2
81144854:	10800584 	addi	r2,r2,22
81144858:	1080002b 	ldhuio	r2,0(r2)
8114485c:	10bfffcc 	andi	r2,r2,65535
81144860:	1007883a 	mov	r3,r2
81144864:	e0bffd17 	ldw	r2,-12(fp)
81144868:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8114486c:	d0a0b317 	ldw	r2,-32052(gp)
81144870:	10c00a17 	ldw	r3,40(r2)
81144874:	e0bffc17 	ldw	r2,-16(fp)
81144878:	1885883a 	add	r2,r3,r2
8114487c:	10800604 	addi	r2,r2,24
81144880:	1080002b 	ldhuio	r2,0(r2)
81144884:	10bfffcc 	andi	r2,r2,65535
81144888:	1007883a 	mov	r3,r2
8114488c:	e0bffd17 	ldw	r2,-12(fp)
81144890:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81144894:	d0a0b317 	ldw	r2,-32052(gp)
81144898:	10c00a17 	ldw	r3,40(r2)
8114489c:	e0bffc17 	ldw	r2,-16(fp)
811448a0:	1885883a 	add	r2,r3,r2
811448a4:	10800684 	addi	r2,r2,26
811448a8:	1080002b 	ldhuio	r2,0(r2)
811448ac:	10bfffcc 	andi	r2,r2,65535
811448b0:	1007883a 	mov	r3,r2
811448b4:	e0bffd17 	ldw	r2,-12(fp)
811448b8:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
811448bc:	d0a0b317 	ldw	r2,-32052(gp)
811448c0:	10c00a17 	ldw	r3,40(r2)
811448c4:	e0bffc17 	ldw	r2,-16(fp)
811448c8:	1885883a 	add	r2,r3,r2
811448cc:	10800704 	addi	r2,r2,28
811448d0:	10800037 	ldwio	r2,0(r2)
811448d4:	1007883a 	mov	r3,r2
811448d8:	e0bffd17 	ldw	r2,-12(fp)
811448dc:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
811448e0:	e0bffd17 	ldw	r2,-12(fp)
811448e4:	e0fffe17 	ldw	r3,-8(fp)
811448e8:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
811448ec:	e0bffd17 	ldw	r2,-12(fp)
811448f0:	e0ffff17 	ldw	r3,-4(fp)
811448f4:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
811448f8:	e0bffc17 	ldw	r2,-16(fp)
811448fc:	1007883a 	mov	r3,r2
81144900:	e0bffd17 	ldw	r2,-12(fp)
81144904:	10c00c0d 	sth	r3,48(r2)
		result = true;
81144908:	00800044 	movi	r2,1
8114490c:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81144910:	e0bffa17 	ldw	r2,-24(fp)
}
81144914:	e037883a 	mov	sp,fp
81144918:	dfc00117 	ldw	ra,4(sp)
8114491c:	df000017 	ldw	fp,0(sp)
81144920:	dec00204 	addi	sp,sp,8
81144924:	f800283a 	ret

81144928 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81144928:	defff904 	addi	sp,sp,-28
8114492c:	de00012e 	bgeu	sp,et,81144934 <Write_File_Record_At_Offset+0xc>
81144930:	003b68fa 	trap	3
81144934:	dfc00615 	stw	ra,24(sp)
81144938:	df000515 	stw	fp,20(sp)
8114493c:	df000504 	addi	fp,sp,20
81144940:	e13ffe15 	stw	r4,-8(fp)
81144944:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81144948:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114494c:	e0bffe17 	ldw	r2,-8(fp)
81144950:	108007cc 	andi	r2,r2,31
81144954:	1000931e 	bne	r2,zero,81144ba4 <Write_File_Record_At_Offset+0x27c>
81144958:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
8114495c:	10009126 	beq	r2,zero,81144ba4 <Write_File_Record_At_Offset+0x27c>
81144960:	d0a0aa17 	ldw	r2,-32088(gp)
81144964:	10008f26 	beq	r2,zero,81144ba4 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81144968:	e03ffc15 	stw	zero,-16(fp)
8114496c:	00001f06 	br	811449ec <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
81144970:	e0bffc17 	ldw	r2,-16(fp)
81144974:	10800044 	addi	r2,r2,1
81144978:	e0ffff17 	ldw	r3,-4(fp)
8114497c:	1885883a 	add	r2,r3,r2
81144980:	10800003 	ldbu	r2,0(r2)
81144984:	10803fcc 	andi	r2,r2,255
81144988:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8114498c:	e0bffd0f 	ldh	r2,-12(fp)
81144990:	1004923a 	slli	r2,r2,8
81144994:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
81144998:	e0ffff17 	ldw	r3,-4(fp)
8114499c:	e0bffc17 	ldw	r2,-16(fp)
811449a0:	1885883a 	add	r2,r3,r2
811449a4:	10800003 	ldbu	r2,0(r2)
811449a8:	10c03fcc 	andi	r3,r2,255
811449ac:	e0bffd0b 	ldhu	r2,-12(fp)
811449b0:	1884b03a 	or	r2,r3,r2
811449b4:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
811449b8:	e0fffe17 	ldw	r3,-8(fp)
811449bc:	e0bffc17 	ldw	r2,-16(fp)
811449c0:	1885883a 	add	r2,r3,r2
811449c4:	1007883a 	mov	r3,r2
811449c8:	d0a0b317 	ldw	r2,-32052(gp)
811449cc:	10800a17 	ldw	r2,40(r2)
811449d0:	1885883a 	add	r2,r3,r2
811449d4:	1007883a 	mov	r3,r2
811449d8:	e0bffd0f 	ldh	r2,-12(fp)
811449dc:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811449e0:	e0bffc17 	ldw	r2,-16(fp)
811449e4:	10800084 	addi	r2,r2,2
811449e8:	e0bffc15 	stw	r2,-16(fp)
811449ec:	e0bffc17 	ldw	r2,-16(fp)
811449f0:	10800210 	cmplti	r2,r2,8
811449f4:	103fde1e 	bne	r2,zero,81144970 <__reset+0xfb124970>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
811449f8:	e03ffc15 	stw	zero,-16(fp)
811449fc:	00001306 	br	81144a4c <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81144a00:	e0fffe17 	ldw	r3,-8(fp)
81144a04:	e0bffc17 	ldw	r2,-16(fp)
81144a08:	1885883a 	add	r2,r3,r2
81144a0c:	1007883a 	mov	r3,r2
81144a10:	d0a0b317 	ldw	r2,-32052(gp)
81144a14:	10800a17 	ldw	r2,40(r2)
81144a18:	1885883a 	add	r2,r3,r2
81144a1c:	10800204 	addi	r2,r2,8
81144a20:	1009883a 	mov	r4,r2
81144a24:	e0ffff17 	ldw	r3,-4(fp)
81144a28:	e0bffc17 	ldw	r2,-16(fp)
81144a2c:	1885883a 	add	r2,r3,r2
81144a30:	10800204 	addi	r2,r2,8
81144a34:	10800003 	ldbu	r2,0(r2)
81144a38:	10803fcc 	andi	r2,r2,255
81144a3c:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81144a40:	e0bffc17 	ldw	r2,-16(fp)
81144a44:	10800044 	addi	r2,r2,1
81144a48:	e0bffc15 	stw	r2,-16(fp)
81144a4c:	e0bffc17 	ldw	r2,-16(fp)
81144a50:	108000d0 	cmplti	r2,r2,3
81144a54:	103fea1e 	bne	r2,zero,81144a00 <__reset+0xfb124a00>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81144a58:	d0a0b317 	ldw	r2,-32052(gp)
81144a5c:	10c00a17 	ldw	r3,40(r2)
81144a60:	e0bffe17 	ldw	r2,-8(fp)
81144a64:	1885883a 	add	r2,r3,r2
81144a68:	108002c4 	addi	r2,r2,11
81144a6c:	1007883a 	mov	r3,r2
81144a70:	e0bfff17 	ldw	r2,-4(fp)
81144a74:	108002c3 	ldbu	r2,11(r2)
81144a78:	10803fcc 	andi	r2,r2,255
81144a7c:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81144a80:	d0a0b317 	ldw	r2,-32052(gp)
81144a84:	10c00a17 	ldw	r3,40(r2)
81144a88:	e0bffe17 	ldw	r2,-8(fp)
81144a8c:	1885883a 	add	r2,r3,r2
81144a90:	10800384 	addi	r2,r2,14
81144a94:	1007883a 	mov	r3,r2
81144a98:	e0bfff17 	ldw	r2,-4(fp)
81144a9c:	1080030b 	ldhu	r2,12(r2)
81144aa0:	10bfffcc 	andi	r2,r2,65535
81144aa4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81144aa8:	d0a0b317 	ldw	r2,-32052(gp)
81144aac:	10c00a17 	ldw	r3,40(r2)
81144ab0:	e0bffe17 	ldw	r2,-8(fp)
81144ab4:	1885883a 	add	r2,r3,r2
81144ab8:	10800404 	addi	r2,r2,16
81144abc:	1007883a 	mov	r3,r2
81144ac0:	e0bfff17 	ldw	r2,-4(fp)
81144ac4:	1080038b 	ldhu	r2,14(r2)
81144ac8:	10bfffcc 	andi	r2,r2,65535
81144acc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81144ad0:	d0a0b317 	ldw	r2,-32052(gp)
81144ad4:	10c00a17 	ldw	r3,40(r2)
81144ad8:	e0bffe17 	ldw	r2,-8(fp)
81144adc:	1885883a 	add	r2,r3,r2
81144ae0:	10800484 	addi	r2,r2,18
81144ae4:	1007883a 	mov	r3,r2
81144ae8:	e0bfff17 	ldw	r2,-4(fp)
81144aec:	1080040b 	ldhu	r2,16(r2)
81144af0:	10bfffcc 	andi	r2,r2,65535
81144af4:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81144af8:	d0a0b317 	ldw	r2,-32052(gp)
81144afc:	10c00a17 	ldw	r3,40(r2)
81144b00:	e0bffe17 	ldw	r2,-8(fp)
81144b04:	1885883a 	add	r2,r3,r2
81144b08:	10800584 	addi	r2,r2,22
81144b0c:	1007883a 	mov	r3,r2
81144b10:	e0bfff17 	ldw	r2,-4(fp)
81144b14:	1080048b 	ldhu	r2,18(r2)
81144b18:	10bfffcc 	andi	r2,r2,65535
81144b1c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81144b20:	d0a0b317 	ldw	r2,-32052(gp)
81144b24:	10c00a17 	ldw	r3,40(r2)
81144b28:	e0bffe17 	ldw	r2,-8(fp)
81144b2c:	1885883a 	add	r2,r3,r2
81144b30:	10800604 	addi	r2,r2,24
81144b34:	1007883a 	mov	r3,r2
81144b38:	e0bfff17 	ldw	r2,-4(fp)
81144b3c:	1080050b 	ldhu	r2,20(r2)
81144b40:	10bfffcc 	andi	r2,r2,65535
81144b44:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81144b48:	d0a0b317 	ldw	r2,-32052(gp)
81144b4c:	10c00a17 	ldw	r3,40(r2)
81144b50:	e0bffe17 	ldw	r2,-8(fp)
81144b54:	1885883a 	add	r2,r3,r2
81144b58:	10800684 	addi	r2,r2,26
81144b5c:	1007883a 	mov	r3,r2
81144b60:	e0bfff17 	ldw	r2,-4(fp)
81144b64:	1080058b 	ldhu	r2,22(r2)
81144b68:	10bfffcc 	andi	r2,r2,65535
81144b6c:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81144b70:	d0a0b317 	ldw	r2,-32052(gp)
81144b74:	10c00a17 	ldw	r3,40(r2)
81144b78:	e0bffe17 	ldw	r2,-8(fp)
81144b7c:	1885883a 	add	r2,r3,r2
81144b80:	10800704 	addi	r2,r2,28
81144b84:	1007883a 	mov	r3,r2
81144b88:	e0bfff17 	ldw	r2,-4(fp)
81144b8c:	10800617 	ldw	r2,24(r2)
81144b90:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81144b94:	00800044 	movi	r2,1
81144b98:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
81144b9c:	00800044 	movi	r2,1
81144ba0:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81144ba4:	e0bffb17 	ldw	r2,-20(fp)
}
81144ba8:	e037883a 	mov	sp,fp
81144bac:	dfc00117 	ldw	ra,4(sp)
81144bb0:	df000017 	ldw	fp,0(sp)
81144bb4:	dec00204 	addi	sp,sp,8
81144bb8:	f800283a 	ret

81144bbc <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81144bbc:	defff904 	addi	sp,sp,-28
81144bc0:	de00012e 	bgeu	sp,et,81144bc8 <Check_for_DOS_FAT+0xc>
81144bc4:	003b68fa 	trap	3
81144bc8:	dfc00615 	stw	ra,24(sp)
81144bcc:	df000515 	stw	fp,20(sp)
81144bd0:	df000504 	addi	fp,sp,20
81144bd4:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81144bd8:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81144bdc:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81144be0:	e17fff17 	ldw	r5,-4(fp)
81144be4:	0009883a 	mov	r4,zero
81144be8:	11442740 	call	81144274 <Read_Sector_Data>
81144bec:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81144bf0:	d0a0b317 	ldw	r2,-32052(gp)
81144bf4:	10800a17 	ldw	r2,40(r2)
81144bf8:	10807f84 	addi	r2,r2,510
81144bfc:	1080002b 	ldhuio	r2,0(r2)
81144c00:	10bfffcc 	andi	r2,r2,65535
81144c04:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81144c08:	e0bffe0f 	ldh	r2,-8(fp)
81144c0c:	10ffffcc 	andi	r3,r2,65535
81144c10:	00aa9554 	movui	r2,43605
81144c14:	1881841e 	bne	r3,r2,81145228 <Check_for_DOS_FAT+0x66c>
81144c18:	e0bffb17 	ldw	r2,-20(fp)
81144c1c:	10018226 	beq	r2,zero,81145228 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81144c20:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81144c24:	d0a0b317 	ldw	r2,-32052(gp)
81144c28:	10800a17 	ldw	r2,40(r2)
81144c2c:	10800023 	ldbuio	r2,0(r2)
81144c30:	10803fcc 	andi	r2,r2,255
81144c34:	1007883a 	mov	r3,r2
81144c38:	00a045f4 	movhi	r2,33047
81144c3c:	10bb9404 	addi	r2,r2,-4528
81144c40:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81144c44:	d0a0b317 	ldw	r2,-32052(gp)
81144c48:	10800a17 	ldw	r2,40(r2)
81144c4c:	10800044 	addi	r2,r2,1
81144c50:	10800023 	ldbuio	r2,0(r2)
81144c54:	10803fcc 	andi	r2,r2,255
81144c58:	1007883a 	mov	r3,r2
81144c5c:	00a045f4 	movhi	r2,33047
81144c60:	10bb9404 	addi	r2,r2,-4528
81144c64:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81144c68:	d0a0b317 	ldw	r2,-32052(gp)
81144c6c:	10800a17 	ldw	r2,40(r2)
81144c70:	10800084 	addi	r2,r2,2
81144c74:	10800023 	ldbuio	r2,0(r2)
81144c78:	10803fcc 	andi	r2,r2,255
81144c7c:	1007883a 	mov	r3,r2
81144c80:	00a045f4 	movhi	r2,33047
81144c84:	10bb9404 	addi	r2,r2,-4528
81144c88:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81144c8c:	e03ffc15 	stw	zero,-16(fp)
81144c90:	00001106 	br	81144cd8 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81144c94:	d0a0b317 	ldw	r2,-32052(gp)
81144c98:	10c00a17 	ldw	r3,40(r2)
81144c9c:	e0bffc17 	ldw	r2,-16(fp)
81144ca0:	1885883a 	add	r2,r3,r2
81144ca4:	108000c4 	addi	r2,r2,3
81144ca8:	10800023 	ldbuio	r2,0(r2)
81144cac:	10803fcc 	andi	r2,r2,255
81144cb0:	1009883a 	mov	r4,r2
81144cb4:	00a045f4 	movhi	r2,33047
81144cb8:	10bb9404 	addi	r2,r2,-4528
81144cbc:	e0fffc17 	ldw	r3,-16(fp)
81144cc0:	10c5883a 	add	r2,r2,r3
81144cc4:	108000c4 	addi	r2,r2,3
81144cc8:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81144ccc:	e0bffc17 	ldw	r2,-16(fp)
81144cd0:	10800044 	addi	r2,r2,1
81144cd4:	e0bffc15 	stw	r2,-16(fp)
81144cd8:	e0bffc17 	ldw	r2,-16(fp)
81144cdc:	10800210 	cmplti	r2,r2,8
81144ce0:	103fec1e 	bne	r2,zero,81144c94 <__reset+0xfb124c94>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81144ce4:	d0a0b317 	ldw	r2,-32052(gp)
81144ce8:	10800a17 	ldw	r2,40(r2)
81144cec:	10800304 	addi	r2,r2,12
81144cf0:	10800023 	ldbuio	r2,0(r2)
81144cf4:	10803fcc 	andi	r2,r2,255
81144cf8:	1004923a 	slli	r2,r2,8
81144cfc:	1007883a 	mov	r3,r2
81144d00:	d0a0b317 	ldw	r2,-32052(gp)
81144d04:	10800a17 	ldw	r2,40(r2)
81144d08:	108002c4 	addi	r2,r2,11
81144d0c:	10800023 	ldbuio	r2,0(r2)
81144d10:	10803fcc 	andi	r2,r2,255
81144d14:	10803fcc 	andi	r2,r2,255
81144d18:	1080201c 	xori	r2,r2,128
81144d1c:	10bfe004 	addi	r2,r2,-128
81144d20:	1884b03a 	or	r2,r3,r2
81144d24:	1007883a 	mov	r3,r2
81144d28:	00a045f4 	movhi	r2,33047
81144d2c:	10bb9404 	addi	r2,r2,-4528
81144d30:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81144d34:	d0a0b317 	ldw	r2,-32052(gp)
81144d38:	10800a17 	ldw	r2,40(r2)
81144d3c:	10800344 	addi	r2,r2,13
81144d40:	10800023 	ldbuio	r2,0(r2)
81144d44:	10803fcc 	andi	r2,r2,255
81144d48:	1007883a 	mov	r3,r2
81144d4c:	00a045f4 	movhi	r2,33047
81144d50:	10bb9404 	addi	r2,r2,-4528
81144d54:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81144d58:	d0a0b317 	ldw	r2,-32052(gp)
81144d5c:	10800a17 	ldw	r2,40(r2)
81144d60:	10800384 	addi	r2,r2,14
81144d64:	1080002b 	ldhuio	r2,0(r2)
81144d68:	10bfffcc 	andi	r2,r2,65535
81144d6c:	1007883a 	mov	r3,r2
81144d70:	00a045f4 	movhi	r2,33047
81144d74:	10bb9404 	addi	r2,r2,-4528
81144d78:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81144d7c:	d0a0b317 	ldw	r2,-32052(gp)
81144d80:	10800a17 	ldw	r2,40(r2)
81144d84:	10800404 	addi	r2,r2,16
81144d88:	10800023 	ldbuio	r2,0(r2)
81144d8c:	10803fcc 	andi	r2,r2,255
81144d90:	1007883a 	mov	r3,r2
81144d94:	00a045f4 	movhi	r2,33047
81144d98:	10bb9404 	addi	r2,r2,-4528
81144d9c:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81144da0:	d0a0b317 	ldw	r2,-32052(gp)
81144da4:	10800a17 	ldw	r2,40(r2)
81144da8:	10800484 	addi	r2,r2,18
81144dac:	10800023 	ldbuio	r2,0(r2)
81144db0:	10803fcc 	andi	r2,r2,255
81144db4:	1004923a 	slli	r2,r2,8
81144db8:	1007883a 	mov	r3,r2
81144dbc:	d0a0b317 	ldw	r2,-32052(gp)
81144dc0:	10800a17 	ldw	r2,40(r2)
81144dc4:	10800444 	addi	r2,r2,17
81144dc8:	10800023 	ldbuio	r2,0(r2)
81144dcc:	10803fcc 	andi	r2,r2,255
81144dd0:	10803fcc 	andi	r2,r2,255
81144dd4:	1884b03a 	or	r2,r3,r2
81144dd8:	1007883a 	mov	r3,r2
81144ddc:	00a045f4 	movhi	r2,33047
81144de0:	10bb9404 	addi	r2,r2,-4528
81144de4:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81144de8:	d0a0b317 	ldw	r2,-32052(gp)
81144dec:	10800a17 	ldw	r2,40(r2)
81144df0:	10800504 	addi	r2,r2,20
81144df4:	10800023 	ldbuio	r2,0(r2)
81144df8:	10803fcc 	andi	r2,r2,255
81144dfc:	1004923a 	slli	r2,r2,8
81144e00:	1007883a 	mov	r3,r2
81144e04:	d0a0b317 	ldw	r2,-32052(gp)
81144e08:	10800a17 	ldw	r2,40(r2)
81144e0c:	108004c4 	addi	r2,r2,19
81144e10:	10800023 	ldbuio	r2,0(r2)
81144e14:	10803fcc 	andi	r2,r2,255
81144e18:	10803fcc 	andi	r2,r2,255
81144e1c:	1884b03a 	or	r2,r3,r2
81144e20:	1007883a 	mov	r3,r2
81144e24:	00a045f4 	movhi	r2,33047
81144e28:	10bb9404 	addi	r2,r2,-4528
81144e2c:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81144e30:	d0a0b317 	ldw	r2,-32052(gp)
81144e34:	10800a17 	ldw	r2,40(r2)
81144e38:	10800544 	addi	r2,r2,21
81144e3c:	10800023 	ldbuio	r2,0(r2)
81144e40:	10803fcc 	andi	r2,r2,255
81144e44:	1007883a 	mov	r3,r2
81144e48:	00a045f4 	movhi	r2,33047
81144e4c:	10bb9404 	addi	r2,r2,-4528
81144e50:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81144e54:	d0a0b317 	ldw	r2,-32052(gp)
81144e58:	10800a17 	ldw	r2,40(r2)
81144e5c:	10800584 	addi	r2,r2,22
81144e60:	1080002b 	ldhuio	r2,0(r2)
81144e64:	10bfffcc 	andi	r2,r2,65535
81144e68:	1007883a 	mov	r3,r2
81144e6c:	00a045f4 	movhi	r2,33047
81144e70:	10bb9404 	addi	r2,r2,-4528
81144e74:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81144e78:	d0a0b317 	ldw	r2,-32052(gp)
81144e7c:	10800a17 	ldw	r2,40(r2)
81144e80:	10800604 	addi	r2,r2,24
81144e84:	1080002b 	ldhuio	r2,0(r2)
81144e88:	10bfffcc 	andi	r2,r2,65535
81144e8c:	1007883a 	mov	r3,r2
81144e90:	00a045f4 	movhi	r2,33047
81144e94:	10bb9404 	addi	r2,r2,-4528
81144e98:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81144e9c:	d0a0b317 	ldw	r2,-32052(gp)
81144ea0:	10800a17 	ldw	r2,40(r2)
81144ea4:	10800684 	addi	r2,r2,26
81144ea8:	1080002b 	ldhuio	r2,0(r2)
81144eac:	10bfffcc 	andi	r2,r2,65535
81144eb0:	1007883a 	mov	r3,r2
81144eb4:	00a045f4 	movhi	r2,33047
81144eb8:	10bb9404 	addi	r2,r2,-4528
81144ebc:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81144ec0:	d0a0b317 	ldw	r2,-32052(gp)
81144ec4:	10800a17 	ldw	r2,40(r2)
81144ec8:	10800704 	addi	r2,r2,28
81144ecc:	10800037 	ldwio	r2,0(r2)
81144ed0:	1007883a 	mov	r3,r2
81144ed4:	00a045f4 	movhi	r2,33047
81144ed8:	10bb9404 	addi	r2,r2,-4528
81144edc:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81144ee0:	d0a0b317 	ldw	r2,-32052(gp)
81144ee4:	10800a17 	ldw	r2,40(r2)
81144ee8:	10800804 	addi	r2,r2,32
81144eec:	10800037 	ldwio	r2,0(r2)
81144ef0:	1007883a 	mov	r3,r2
81144ef4:	00a045f4 	movhi	r2,33047
81144ef8:	10bb9404 	addi	r2,r2,-4528
81144efc:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81144f00:	d0a0b317 	ldw	r2,-32052(gp)
81144f04:	10800a17 	ldw	r2,40(r2)
81144f08:	10800904 	addi	r2,r2,36
81144f0c:	10800023 	ldbuio	r2,0(r2)
81144f10:	10803fcc 	andi	r2,r2,255
81144f14:	1007883a 	mov	r3,r2
81144f18:	00a045f4 	movhi	r2,33047
81144f1c:	10bb9404 	addi	r2,r2,-4528
81144f20:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81144f24:	d0a0b317 	ldw	r2,-32052(gp)
81144f28:	10800a17 	ldw	r2,40(r2)
81144f2c:	10800944 	addi	r2,r2,37
81144f30:	10800023 	ldbuio	r2,0(r2)
81144f34:	10803fcc 	andi	r2,r2,255
81144f38:	1007883a 	mov	r3,r2
81144f3c:	00a045f4 	movhi	r2,33047
81144f40:	10bb9404 	addi	r2,r2,-4528
81144f44:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81144f48:	d0a0b317 	ldw	r2,-32052(gp)
81144f4c:	10800a17 	ldw	r2,40(r2)
81144f50:	10800984 	addi	r2,r2,38
81144f54:	10800023 	ldbuio	r2,0(r2)
81144f58:	10803fcc 	andi	r2,r2,255
81144f5c:	1007883a 	mov	r3,r2
81144f60:	00a045f4 	movhi	r2,33047
81144f64:	10bb9404 	addi	r2,r2,-4528
81144f68:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81144f6c:	00a045f4 	movhi	r2,33047
81144f70:	10bb9404 	addi	r2,r2,-4528
81144f74:	1080040b 	ldhu	r2,16(r2)
81144f78:	10ffffcc 	andi	r3,r2,65535
81144f7c:	00a045f4 	movhi	r2,33047
81144f80:	10bb9404 	addi	r2,r2,-4528
81144f84:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81144f88:	00a045f4 	movhi	r2,33047
81144f8c:	10bb9404 	addi	r2,r2,-4528
81144f90:	10c01117 	ldw	r3,68(r2)
81144f94:	00a045f4 	movhi	r2,33047
81144f98:	10bb9404 	addi	r2,r2,-4528
81144f9c:	1080068b 	ldhu	r2,26(r2)
81144fa0:	10bfffcc 	andi	r2,r2,65535
81144fa4:	1887883a 	add	r3,r3,r2
81144fa8:	00a045f4 	movhi	r2,33047
81144fac:	10bb9404 	addi	r2,r2,-4528
81144fb0:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81144fb4:	00a045f4 	movhi	r2,33047
81144fb8:	10bb9404 	addi	r2,r2,-4528
81144fbc:	10c01217 	ldw	r3,72(r2)
81144fc0:	00a045f4 	movhi	r2,33047
81144fc4:	10bb9404 	addi	r2,r2,-4528
81144fc8:	1080068b 	ldhu	r2,26(r2)
81144fcc:	10bfffcc 	andi	r2,r2,65535
81144fd0:	1887883a 	add	r3,r3,r2
81144fd4:	00a045f4 	movhi	r2,33047
81144fd8:	10bb9404 	addi	r2,r2,-4528
81144fdc:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81144fe0:	00a045f4 	movhi	r2,33047
81144fe4:	10bb9404 	addi	r2,r2,-4528
81144fe8:	10c01317 	ldw	r3,76(r2)
81144fec:	00a045f4 	movhi	r2,33047
81144ff0:	10bb9404 	addi	r2,r2,-4528
81144ff4:	1080050b 	ldhu	r2,20(r2)
81144ff8:	10bfffcc 	andi	r2,r2,65535
81144ffc:	1008917a 	slli	r4,r2,5
81145000:	00a045f4 	movhi	r2,33047
81145004:	10bb9404 	addi	r2,r2,-4528
81145008:	1080030b 	ldhu	r2,12(r2)
8114500c:	10bfffcc 	andi	r2,r2,65535
81145010:	2085283a 	div	r2,r4,r2
81145014:	1887883a 	add	r3,r3,r2
81145018:	00a045f4 	movhi	r2,33047
8114501c:	10bb9404 	addi	r2,r2,-4528
81145020:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81145024:	00a045f4 	movhi	r2,33047
81145028:	10bb9404 	addi	r2,r2,-4528
8114502c:	1080058b 	ldhu	r2,22(r2)
81145030:	10bfffcc 	andi	r2,r2,65535
81145034:	10000b26 	beq	r2,zero,81145064 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81145038:	00a045f4 	movhi	r2,33047
8114503c:	10bb9404 	addi	r2,r2,-4528
81145040:	1080058b 	ldhu	r2,22(r2)
81145044:	10ffffcc 	andi	r3,r2,65535
81145048:	00a045f4 	movhi	r2,33047
8114504c:	10bb9404 	addi	r2,r2,-4528
81145050:	10800383 	ldbu	r2,14(r2)
81145054:	10803fcc 	andi	r2,r2,255
81145058:	1885283a 	div	r2,r3,r2
8114505c:	e0bffd15 	stw	r2,-12(fp)
81145060:	00000906 	br	81145088 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81145064:	00a045f4 	movhi	r2,33047
81145068:	10bb9404 	addi	r2,r2,-4528
8114506c:	10c00917 	ldw	r3,36(r2)
81145070:	00a045f4 	movhi	r2,33047
81145074:	10bb9404 	addi	r2,r2,-4528
81145078:	10800383 	ldbu	r2,14(r2)
8114507c:	10803fcc 	andi	r2,r2,255
81145080:	1885203a 	divu	r2,r3,r2
81145084:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81145088:	e0bffd17 	ldw	r2,-12(fp)
8114508c:	1083fdc8 	cmpgei	r2,r2,4087
81145090:	1000051e 	bne	r2,zero,811450a8 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81145094:	00a045f4 	movhi	r2,33047
81145098:	10bb9404 	addi	r2,r2,-4528
8114509c:	00c00304 	movi	r3,12
811450a0:	10c01085 	stb	r3,66(r2)
811450a4:	00000c06 	br	811450d8 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
811450a8:	e0bffd17 	ldw	r2,-12(fp)
811450ac:	00fffb54 	movui	r3,65517
811450b0:	18800516 	blt	r3,r2,811450c8 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
811450b4:	00a045f4 	movhi	r2,33047
811450b8:	10bb9404 	addi	r2,r2,-4528
811450bc:	00c00404 	movi	r3,16
811450c0:	10c01085 	stb	r3,66(r2)
811450c4:	00000406 	br	811450d8 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
811450c8:	00a045f4 	movhi	r2,33047
811450cc:	10bb9404 	addi	r2,r2,-4528
811450d0:	00c00804 	movi	r3,32
811450d4:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
811450d8:	e03ffc15 	stw	zero,-16(fp)
811450dc:	00001106 	br	81145124 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
811450e0:	d0a0b317 	ldw	r2,-32052(gp)
811450e4:	10c00a17 	ldw	r3,40(r2)
811450e8:	e0bffc17 	ldw	r2,-16(fp)
811450ec:	1885883a 	add	r2,r3,r2
811450f0:	108009c4 	addi	r2,r2,39
811450f4:	10800023 	ldbuio	r2,0(r2)
811450f8:	10803fcc 	andi	r2,r2,255
811450fc:	1009883a 	mov	r4,r2
81145100:	00a045f4 	movhi	r2,33047
81145104:	10bb9404 	addi	r2,r2,-4528
81145108:	e0fffc17 	ldw	r3,-16(fp)
8114510c:	10c5883a 	add	r2,r2,r3
81145110:	10800ac4 	addi	r2,r2,43
81145114:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81145118:	e0bffc17 	ldw	r2,-16(fp)
8114511c:	10800044 	addi	r2,r2,1
81145120:	e0bffc15 	stw	r2,-16(fp)
81145124:	e0bffc17 	ldw	r2,-16(fp)
81145128:	10800110 	cmplti	r2,r2,4
8114512c:	103fec1e 	bne	r2,zero,811450e0 <__reset+0xfb1250e0>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81145130:	e03ffc15 	stw	zero,-16(fp)
81145134:	00001106 	br	8114517c <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81145138:	d0a0b317 	ldw	r2,-32052(gp)
8114513c:	10c00a17 	ldw	r3,40(r2)
81145140:	e0bffc17 	ldw	r2,-16(fp)
81145144:	1885883a 	add	r2,r3,r2
81145148:	10800ac4 	addi	r2,r2,43
8114514c:	10800023 	ldbuio	r2,0(r2)
81145150:	10803fcc 	andi	r2,r2,255
81145154:	1009883a 	mov	r4,r2
81145158:	00a045f4 	movhi	r2,33047
8114515c:	10bb9404 	addi	r2,r2,-4528
81145160:	e0fffc17 	ldw	r3,-16(fp)
81145164:	10c5883a 	add	r2,r2,r3
81145168:	10800bc4 	addi	r2,r2,47
8114516c:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81145170:	e0bffc17 	ldw	r2,-16(fp)
81145174:	10800044 	addi	r2,r2,1
81145178:	e0bffc15 	stw	r2,-16(fp)
8114517c:	e0bffc17 	ldw	r2,-16(fp)
81145180:	108002d0 	cmplti	r2,r2,11
81145184:	103fec1e 	bne	r2,zero,81145138 <__reset+0xfb125138>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81145188:	e03ffc15 	stw	zero,-16(fp)
8114518c:	00001106 	br	811451d4 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81145190:	d0a0b317 	ldw	r2,-32052(gp)
81145194:	10c00a17 	ldw	r3,40(r2)
81145198:	e0bffc17 	ldw	r2,-16(fp)
8114519c:	1885883a 	add	r2,r3,r2
811451a0:	10800d84 	addi	r2,r2,54
811451a4:	10800023 	ldbuio	r2,0(r2)
811451a8:	10803fcc 	andi	r2,r2,255
811451ac:	1009883a 	mov	r4,r2
811451b0:	00a045f4 	movhi	r2,33047
811451b4:	10bb9404 	addi	r2,r2,-4528
811451b8:	e0fffc17 	ldw	r3,-16(fp)
811451bc:	10c5883a 	add	r2,r2,r3
811451c0:	10800e84 	addi	r2,r2,58
811451c4:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811451c8:	e0bffc17 	ldw	r2,-16(fp)
811451cc:	10800044 	addi	r2,r2,1
811451d0:	e0bffc15 	stw	r2,-16(fp)
811451d4:	e0bffc17 	ldw	r2,-16(fp)
811451d8:	10800210 	cmplti	r2,r2,8
811451dc:	103fec1e 	bne	r2,zero,81145190 <__reset+0xfb125190>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811451e0:	e03ffc15 	stw	zero,-16(fp)
811451e4:	00000a06 	br	81145210 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
811451e8:	00a045f4 	movhi	r2,33047
811451ec:	10bba904 	addi	r2,r2,-4444
811451f0:	e0fffc17 	ldw	r3,-16(fp)
811451f4:	180691ba 	slli	r3,r3,6
811451f8:	10c5883a 	add	r2,r2,r3
811451fc:	10800f04 	addi	r2,r2,60
81145200:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81145204:	e0bffc17 	ldw	r2,-16(fp)
81145208:	10800044 	addi	r2,r2,1
8114520c:	e0bffc15 	stw	r2,-16(fp)
81145210:	e0bffc17 	ldw	r2,-16(fp)
81145214:	10800510 	cmplti	r2,r2,20
81145218:	103ff31e 	bne	r2,zero,811451e8 <__reset+0xfb1251e8>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8114521c:	00800044 	movi	r2,1
81145220:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81145224:	00000106 	br	8114522c <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81145228:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8114522c:	e0bffb17 	ldw	r2,-20(fp)
}
81145230:	e037883a 	mov	sp,fp
81145234:	dfc00117 	ldw	ra,4(sp)
81145238:	df000017 	ldw	fp,0(sp)
8114523c:	dec00204 	addi	sp,sp,8
81145240:	f800283a 	ret

81145244 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81145244:	defffc04 	addi	sp,sp,-16
81145248:	de00012e 	bgeu	sp,et,81145250 <Look_for_FAT16+0xc>
8114524c:	003b68fa 	trap	3
81145250:	dfc00315 	stw	ra,12(sp)
81145254:	df000215 	stw	fp,8(sp)
81145258:	df000204 	addi	fp,sp,8
	bool result = false;
8114525c:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81145260:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
81145264:	10002e26 	beq	r2,zero,81145320 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81145268:	d0a0ad17 	ldw	r2,-32076(gp)
8114526c:	1080000b 	ldhu	r2,0(r2)
81145270:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81145274:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81145278:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8114527c:	e0bfff0f 	ldh	r2,-4(fp)
81145280:	10002716 	blt	r2,zero,81145320 <Look_for_FAT16+0xdc>
81145284:	e0bfff0b 	ldhu	r2,-4(fp)
81145288:	10bfffcc 	andi	r2,r2,65535
8114528c:	1083000c 	andi	r2,r2,3072
81145290:	10830020 	cmpeqi	r2,r2,3072
81145294:	1000221e 	bne	r2,zero,81145320 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81145298:	e0bfff0b 	ldhu	r2,-4(fp)
8114529c:	10bfffcc 	andi	r2,r2,65535
811452a0:	1083000c 	andi	r2,r2,3072
811452a4:	10810018 	cmpnei	r2,r2,1024
811452a8:	1000031e 	bne	r2,zero,811452b8 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
811452ac:	0009883a 	mov	r4,zero
811452b0:	1144bbc0 	call	81144bbc <Check_for_DOS_FAT>
811452b4:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
811452b8:	e0bfff0b 	ldhu	r2,-4(fp)
811452bc:	10bfffcc 	andi	r2,r2,65535
811452c0:	1083000c 	andi	r2,r2,3072
811452c4:	1000061e 	bne	r2,zero,811452e0 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
811452c8:	11444f80 	call	811444f8 <Check_for_Master_Boot_Record>
811452cc:	10000426 	beq	r2,zero,811452e0 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
811452d0:	d0a0b117 	ldw	r2,-32060(gp)
811452d4:	1009883a 	mov	r4,r2
811452d8:	1144bbc0 	call	81144bbc <Check_for_DOS_FAT>
811452dc:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
811452e0:	e0bffe17 	ldw	r2,-8(fp)
811452e4:	10800058 	cmpnei	r2,r2,1
811452e8:	10000d1e 	bne	r2,zero,81145320 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
811452ec:	00a045f4 	movhi	r2,33047
811452f0:	10bb9404 	addi	r2,r2,-4528
811452f4:	10801083 	ldbu	r2,66(r2)
811452f8:	10803fcc 	andi	r2,r2,255
811452fc:	10800420 	cmpeqi	r2,r2,16
81145300:	1000021e 	bne	r2,zero,8114530c <Look_for_FAT16+0xc8>
				{
					result = false;
81145304:	e03ffe15 	stw	zero,-8(fp)
81145308:	00000506 	br	81145320 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8114530c:	00a045f4 	movhi	r2,33047
81145310:	10bb9404 	addi	r2,r2,-4528
81145314:	1080058b 	ldhu	r2,22(r2)
81145318:	10bfffcc 	andi	r2,r2,65535
8114531c:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
81145320:	e0bffe17 	ldw	r2,-8(fp)
}
81145324:	e037883a 	mov	sp,fp
81145328:	dfc00117 	ldw	ra,4(sp)
8114532c:	df000017 	ldw	fp,0(sp)
81145330:	dec00204 	addi	sp,sp,8
81145334:	f800283a 	ret

81145338 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81145338:	defffb04 	addi	sp,sp,-20
8114533c:	de00012e 	bgeu	sp,et,81145344 <filename_to_upper_case+0xc>
81145340:	003b68fa 	trap	3
81145344:	dfc00415 	stw	ra,16(sp)
81145348:	df000315 	stw	fp,12(sp)
8114534c:	df000304 	addi	fp,sp,12
81145350:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81145354:	e13fff17 	ldw	r4,-4(fp)
81145358:	11251780 	call	81125178 <strlen>
8114535c:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81145360:	e03ffd15 	stw	zero,-12(fp)
81145364:	00001e06 	br	811453e0 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81145368:	e0bffd17 	ldw	r2,-12(fp)
8114536c:	e0ffff17 	ldw	r3,-4(fp)
81145370:	1885883a 	add	r2,r3,r2
81145374:	10800003 	ldbu	r2,0(r2)
81145378:	10803fcc 	andi	r2,r2,255
8114537c:	1080201c 	xori	r2,r2,128
81145380:	10bfe004 	addi	r2,r2,-128
81145384:	10801850 	cmplti	r2,r2,97
81145388:	1000121e 	bne	r2,zero,811453d4 <filename_to_upper_case+0x9c>
8114538c:	e0bffd17 	ldw	r2,-12(fp)
81145390:	e0ffff17 	ldw	r3,-4(fp)
81145394:	1885883a 	add	r2,r3,r2
81145398:	10800003 	ldbu	r2,0(r2)
8114539c:	10803fcc 	andi	r2,r2,255
811453a0:	1080201c 	xori	r2,r2,128
811453a4:	10bfe004 	addi	r2,r2,-128
811453a8:	10801ec8 	cmpgei	r2,r2,123
811453ac:	1000091e 	bne	r2,zero,811453d4 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
811453b0:	e0bffd17 	ldw	r2,-12(fp)
811453b4:	e0ffff17 	ldw	r3,-4(fp)
811453b8:	1885883a 	add	r2,r3,r2
811453bc:	e0fffd17 	ldw	r3,-12(fp)
811453c0:	e13fff17 	ldw	r4,-4(fp)
811453c4:	20c7883a 	add	r3,r4,r3
811453c8:	18c00003 	ldbu	r3,0(r3)
811453cc:	18fff804 	addi	r3,r3,-32
811453d0:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
811453d4:	e0bffd17 	ldw	r2,-12(fp)
811453d8:	10800044 	addi	r2,r2,1
811453dc:	e0bffd15 	stw	r2,-12(fp)
811453e0:	e0fffd17 	ldw	r3,-12(fp)
811453e4:	e0bffe17 	ldw	r2,-8(fp)
811453e8:	18bfdf16 	blt	r3,r2,81145368 <__reset+0xfb125368>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
811453ec:	0001883a 	nop
811453f0:	e037883a 	mov	sp,fp
811453f4:	dfc00117 	ldw	ra,4(sp)
811453f8:	df000017 	ldw	fp,0(sp)
811453fc:	dec00204 	addi	sp,sp,8
81145400:	f800283a 	ret

81145404 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81145404:	defff804 	addi	sp,sp,-32
81145408:	de00012e 	bgeu	sp,et,81145410 <check_file_name_for_FAT16_compliance+0xc>
8114540c:	003b68fa 	trap	3
81145410:	dfc00715 	stw	ra,28(sp)
81145414:	df000615 	stw	fp,24(sp)
81145418:	df000604 	addi	fp,sp,24
8114541c:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81145420:	e13fff17 	ldw	r4,-4(fp)
81145424:	11251780 	call	81125178 <strlen>
81145428:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8114542c:	00bfffc4 	movi	r2,-1
81145430:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81145434:	00bfffc4 	movi	r2,-1
81145438:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8114543c:	00800044 	movi	r2,1
81145440:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81145444:	e03ffa15 	stw	zero,-24(fp)
81145448:	00006d06 	br	81145600 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8114544c:	e0bffa17 	ldw	r2,-24(fp)
81145450:	e0ffff17 	ldw	r3,-4(fp)
81145454:	1885883a 	add	r2,r3,r2
81145458:	10800003 	ldbu	r2,0(r2)
8114545c:	10803fcc 	andi	r2,r2,255
81145460:	1080201c 	xori	r2,r2,128
81145464:	10bfe004 	addi	r2,r2,-128
81145468:	10800820 	cmpeqi	r2,r2,32
8114546c:	10003e1e 	bne	r2,zero,81145568 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81145470:	e0bffa17 	ldw	r2,-24(fp)
81145474:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81145478:	e0bffb17 	ldw	r2,-20(fp)
8114547c:	1880121e 	bne	r3,r2,811454c8 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81145480:	e0bffa17 	ldw	r2,-24(fp)
81145484:	e0ffff17 	ldw	r3,-4(fp)
81145488:	1885883a 	add	r2,r3,r2
8114548c:	10800003 	ldbu	r2,0(r2)
81145490:	10803fcc 	andi	r2,r2,255
81145494:	1080201c 	xori	r2,r2,128
81145498:	10bfe004 	addi	r2,r2,-128
8114549c:	10801720 	cmpeqi	r2,r2,92
811454a0:	1000311e 	bne	r2,zero,81145568 <check_file_name_for_FAT16_compliance+0x164>
811454a4:	e0bffa17 	ldw	r2,-24(fp)
811454a8:	e0ffff17 	ldw	r3,-4(fp)
811454ac:	1885883a 	add	r2,r3,r2
811454b0:	10800003 	ldbu	r2,0(r2)
811454b4:	10803fcc 	andi	r2,r2,255
811454b8:	1080201c 	xori	r2,r2,128
811454bc:	10bfe004 	addi	r2,r2,-128
811454c0:	10800be0 	cmpeqi	r2,r2,47
811454c4:	1000281e 	bne	r2,zero,81145568 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811454c8:	e0fffa17 	ldw	r3,-24(fp)
811454cc:	e0bffc17 	ldw	r2,-16(fp)
811454d0:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811454d4:	10800258 	cmpnei	r2,r2,9
811454d8:	1000091e 	bne	r2,zero,81145500 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811454dc:	e0bffa17 	ldw	r2,-24(fp)
811454e0:	e0ffff17 	ldw	r3,-4(fp)
811454e4:	1885883a 	add	r2,r3,r2
811454e8:	10800003 	ldbu	r2,0(r2)
811454ec:	10803fcc 	andi	r2,r2,255
811454f0:	1080201c 	xori	r2,r2,128
811454f4:	10bfe004 	addi	r2,r2,-128
811454f8:	10800b98 	cmpnei	r2,r2,46
811454fc:	10001a1e 	bne	r2,zero,81145568 <check_file_name_for_FAT16_compliance+0x164>
81145500:	e0fffb17 	ldw	r3,-20(fp)
81145504:	e0bffc17 	ldw	r2,-16(fp)
81145508:	18801926 	beq	r3,r2,81145570 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8114550c:	e0fffa17 	ldw	r3,-24(fp)
81145510:	e0bffc17 	ldw	r2,-16(fp)
81145514:	1885c83a 	sub	r2,r3,r2
81145518:	10800110 	cmplti	r2,r2,4
8114551c:	1000141e 	bne	r2,zero,81145570 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81145520:	e0bffa17 	ldw	r2,-24(fp)
81145524:	e0ffff17 	ldw	r3,-4(fp)
81145528:	1885883a 	add	r2,r3,r2
8114552c:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81145530:	10803fcc 	andi	r2,r2,255
81145534:	1080201c 	xori	r2,r2,128
81145538:	10bfe004 	addi	r2,r2,-128
8114553c:	10801720 	cmpeqi	r2,r2,92
81145540:	10000b1e 	bne	r2,zero,81145570 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81145544:	e0bffa17 	ldw	r2,-24(fp)
81145548:	e0ffff17 	ldw	r3,-4(fp)
8114554c:	1885883a 	add	r2,r3,r2
81145550:	10800003 	ldbu	r2,0(r2)
81145554:	10803fcc 	andi	r2,r2,255
81145558:	1080201c 	xori	r2,r2,128
8114555c:	10bfe004 	addi	r2,r2,-128
81145560:	10800be0 	cmpeqi	r2,r2,47
81145564:	1000021e 	bne	r2,zero,81145570 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81145568:	e03ffd15 	stw	zero,-12(fp)
            break;
8114556c:	00002706 	br	8114560c <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81145570:	e0bffa17 	ldw	r2,-24(fp)
81145574:	e0ffff17 	ldw	r3,-4(fp)
81145578:	1885883a 	add	r2,r3,r2
8114557c:	10800003 	ldbu	r2,0(r2)
81145580:	10803fcc 	andi	r2,r2,255
81145584:	1080201c 	xori	r2,r2,128
81145588:	10bfe004 	addi	r2,r2,-128
8114558c:	10801720 	cmpeqi	r2,r2,92
81145590:	1000091e 	bne	r2,zero,811455b8 <check_file_name_for_FAT16_compliance+0x1b4>
81145594:	e0bffa17 	ldw	r2,-24(fp)
81145598:	e0ffff17 	ldw	r3,-4(fp)
8114559c:	1885883a 	add	r2,r3,r2
811455a0:	10800003 	ldbu	r2,0(r2)
811455a4:	10803fcc 	andi	r2,r2,255
811455a8:	1080201c 	xori	r2,r2,128
811455ac:	10bfe004 	addi	r2,r2,-128
811455b0:	10800bd8 	cmpnei	r2,r2,47
811455b4:	1000041e 	bne	r2,zero,811455c8 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
811455b8:	e0bffa17 	ldw	r2,-24(fp)
811455bc:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
811455c0:	e0bffa17 	ldw	r2,-24(fp)
811455c4:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
811455c8:	e0bffa17 	ldw	r2,-24(fp)
811455cc:	e0ffff17 	ldw	r3,-4(fp)
811455d0:	1885883a 	add	r2,r3,r2
811455d4:	10800003 	ldbu	r2,0(r2)
811455d8:	10803fcc 	andi	r2,r2,255
811455dc:	1080201c 	xori	r2,r2,128
811455e0:	10bfe004 	addi	r2,r2,-128
811455e4:	10800b98 	cmpnei	r2,r2,46
811455e8:	1000021e 	bne	r2,zero,811455f4 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
811455ec:	e0bffa17 	ldw	r2,-24(fp)
811455f0:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
811455f4:	e0bffa17 	ldw	r2,-24(fp)
811455f8:	10800044 	addi	r2,r2,1
811455fc:	e0bffa15 	stw	r2,-24(fp)
81145600:	e0fffa17 	ldw	r3,-24(fp)
81145604:	e0bffe17 	ldw	r2,-8(fp)
81145608:	18bf9016 	blt	r3,r2,8114544c <__reset+0xfb12544c>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8114560c:	e0bffe17 	ldw	r2,-8(fp)
81145610:	10bfffc4 	addi	r2,r2,-1
81145614:	e0ffff17 	ldw	r3,-4(fp)
81145618:	1885883a 	add	r2,r3,r2
8114561c:	10800003 	ldbu	r2,0(r2)
81145620:	10803fcc 	andi	r2,r2,255
81145624:	1080201c 	xori	r2,r2,128
81145628:	10bfe004 	addi	r2,r2,-128
8114562c:	10801720 	cmpeqi	r2,r2,92
81145630:	10000a1e 	bne	r2,zero,8114565c <check_file_name_for_FAT16_compliance+0x258>
81145634:	e0bffe17 	ldw	r2,-8(fp)
81145638:	10bfffc4 	addi	r2,r2,-1
8114563c:	e0ffff17 	ldw	r3,-4(fp)
81145640:	1885883a 	add	r2,r3,r2
81145644:	10800003 	ldbu	r2,0(r2)
81145648:	10803fcc 	andi	r2,r2,255
8114564c:	1080201c 	xori	r2,r2,128
81145650:	10bfe004 	addi	r2,r2,-128
81145654:	10800bd8 	cmpnei	r2,r2,47
81145658:	1000011e 	bne	r2,zero,81145660 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8114565c:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81145660:	e0bffd17 	ldw	r2,-12(fp)
}
81145664:	e037883a 	mov	sp,fp
81145668:	dfc00117 	ldw	ra,4(sp)
8114566c:	df000017 	ldw	fp,0(sp)
81145670:	dec00204 	addi	sp,sp,8
81145674:	f800283a 	ret

81145678 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
81145678:	defffb04 	addi	sp,sp,-20
8114567c:	de00012e 	bgeu	sp,et,81145684 <get_dir_divider_location+0xc>
81145680:	003b68fa 	trap	3
81145684:	dfc00415 	stw	ra,16(sp)
81145688:	df000315 	stw	fp,12(sp)
8114568c:	df000304 	addi	fp,sp,12
81145690:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
81145694:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
81145698:	e13fff17 	ldw	r4,-4(fp)
8114569c:	11251780 	call	81125178 <strlen>
811456a0:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
811456a4:	e03ffd15 	stw	zero,-12(fp)
811456a8:	00001506 	br	81145700 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
811456ac:	e0bffd17 	ldw	r2,-12(fp)
811456b0:	e0ffff17 	ldw	r3,-4(fp)
811456b4:	1885883a 	add	r2,r3,r2
811456b8:	10800003 	ldbu	r2,0(r2)
811456bc:	10803fcc 	andi	r2,r2,255
811456c0:	1080201c 	xori	r2,r2,128
811456c4:	10bfe004 	addi	r2,r2,-128
811456c8:	10801720 	cmpeqi	r2,r2,92
811456cc:	10000f1e 	bne	r2,zero,8114570c <get_dir_divider_location+0x94>
811456d0:	e0bffd17 	ldw	r2,-12(fp)
811456d4:	e0ffff17 	ldw	r3,-4(fp)
811456d8:	1885883a 	add	r2,r3,r2
811456dc:	10800003 	ldbu	r2,0(r2)
811456e0:	10803fcc 	andi	r2,r2,255
811456e4:	1080201c 	xori	r2,r2,128
811456e8:	10bfe004 	addi	r2,r2,-128
811456ec:	10800be0 	cmpeqi	r2,r2,47
811456f0:	1000061e 	bne	r2,zero,8114570c <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
811456f4:	e0bffd17 	ldw	r2,-12(fp)
811456f8:	10800044 	addi	r2,r2,1
811456fc:	e0bffd15 	stw	r2,-12(fp)
81145700:	e0fffd17 	ldw	r3,-12(fp)
81145704:	e0bffe17 	ldw	r2,-8(fp)
81145708:	18bfe816 	blt	r3,r2,811456ac <__reset+0xfb1256ac>
        {
            break;
        }
    }
    
    if (index == length)
8114570c:	e0fffd17 	ldw	r3,-12(fp)
81145710:	e0bffe17 	ldw	r2,-8(fp)
81145714:	1880021e 	bne	r3,r2,81145720 <get_dir_divider_location+0xa8>
    {
        index = -1;
81145718:	00bfffc4 	movi	r2,-1
8114571c:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
81145720:	e0bffd17 	ldw	r2,-12(fp)
}
81145724:	e037883a 	mov	sp,fp
81145728:	dfc00117 	ldw	ra,4(sp)
8114572c:	df000017 	ldw	fp,0(sp)
81145730:	dec00204 	addi	sp,sp,8
81145734:	f800283a 	ret

81145738 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81145738:	defffa04 	addi	sp,sp,-24
8114573c:	de00012e 	bgeu	sp,et,81145744 <match_file_record_to_name_ext+0xc>
81145740:	003b68fa 	trap	3
81145744:	df000515 	stw	fp,20(sp)
81145748:	df000504 	addi	fp,sp,20
8114574c:	e13ffd15 	stw	r4,-12(fp)
81145750:	e17ffe15 	stw	r5,-8(fp)
81145754:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81145758:	00800044 	movi	r2,1
8114575c:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81145760:	e03ffc15 	stw	zero,-16(fp)
81145764:	00004606 	br	81145880 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81145768:	e0fffd17 	ldw	r3,-12(fp)
8114576c:	e0bffc17 	ldw	r2,-16(fp)
81145770:	1885883a 	add	r2,r3,r2
81145774:	10800003 	ldbu	r2,0(r2)
81145778:	10803fcc 	andi	r2,r2,255
8114577c:	10801870 	cmpltui	r2,r2,97
81145780:	1000101e 	bne	r2,zero,811457c4 <match_file_record_to_name_ext+0x8c>
81145784:	e0fffd17 	ldw	r3,-12(fp)
81145788:	e0bffc17 	ldw	r2,-16(fp)
8114578c:	1885883a 	add	r2,r3,r2
81145790:	10800003 	ldbu	r2,0(r2)
81145794:	10803fcc 	andi	r2,r2,255
81145798:	10801ee8 	cmpgeui	r2,r2,123
8114579c:	1000091e 	bne	r2,zero,811457c4 <match_file_record_to_name_ext+0x8c>
811457a0:	e0fffd17 	ldw	r3,-12(fp)
811457a4:	e0bffc17 	ldw	r2,-16(fp)
811457a8:	1885883a 	add	r2,r3,r2
811457ac:	10800003 	ldbu	r2,0(r2)
811457b0:	10bff804 	addi	r2,r2,-32
811457b4:	10c03fcc 	andi	r3,r2,255
811457b8:	18c0201c 	xori	r3,r3,128
811457bc:	18ffe004 	addi	r3,r3,-128
811457c0:	00000706 	br	811457e0 <match_file_record_to_name_ext+0xa8>
811457c4:	e0fffd17 	ldw	r3,-12(fp)
811457c8:	e0bffc17 	ldw	r2,-16(fp)
811457cc:	1885883a 	add	r2,r3,r2
811457d0:	10800003 	ldbu	r2,0(r2)
811457d4:	10c03fcc 	andi	r3,r2,255
811457d8:	18c0201c 	xori	r3,r3,128
811457dc:	18ffe004 	addi	r3,r3,-128
811457e0:	e0bffc17 	ldw	r2,-16(fp)
811457e4:	e13ffe17 	ldw	r4,-8(fp)
811457e8:	2085883a 	add	r2,r4,r2
811457ec:	10800003 	ldbu	r2,0(r2)
811457f0:	10803fcc 	andi	r2,r2,255
811457f4:	1080201c 	xori	r2,r2,128
811457f8:	10bfe004 	addi	r2,r2,-128
811457fc:	10801850 	cmplti	r2,r2,97
81145800:	1000121e 	bne	r2,zero,8114584c <match_file_record_to_name_ext+0x114>
81145804:	e0bffc17 	ldw	r2,-16(fp)
81145808:	e13ffe17 	ldw	r4,-8(fp)
8114580c:	2085883a 	add	r2,r4,r2
81145810:	10800003 	ldbu	r2,0(r2)
81145814:	10803fcc 	andi	r2,r2,255
81145818:	1080201c 	xori	r2,r2,128
8114581c:	10bfe004 	addi	r2,r2,-128
81145820:	10801ec8 	cmpgei	r2,r2,123
81145824:	1000091e 	bne	r2,zero,8114584c <match_file_record_to_name_ext+0x114>
81145828:	e0bffc17 	ldw	r2,-16(fp)
8114582c:	e13ffe17 	ldw	r4,-8(fp)
81145830:	2085883a 	add	r2,r4,r2
81145834:	10800003 	ldbu	r2,0(r2)
81145838:	10bff804 	addi	r2,r2,-32
8114583c:	10803fcc 	andi	r2,r2,255
81145840:	1080201c 	xori	r2,r2,128
81145844:	10bfe004 	addi	r2,r2,-128
81145848:	00000706 	br	81145868 <match_file_record_to_name_ext+0x130>
8114584c:	e0bffc17 	ldw	r2,-16(fp)
81145850:	e13ffe17 	ldw	r4,-8(fp)
81145854:	2085883a 	add	r2,r4,r2
81145858:	10800003 	ldbu	r2,0(r2)
8114585c:	10803fcc 	andi	r2,r2,255
81145860:	1080201c 	xori	r2,r2,128
81145864:	10bfe004 	addi	r2,r2,-128
81145868:	18800226 	beq	r3,r2,81145874 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8114586c:	e03ffb15 	stw	zero,-20(fp)
			break;
81145870:	00000606 	br	8114588c <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81145874:	e0bffc17 	ldw	r2,-16(fp)
81145878:	10800044 	addi	r2,r2,1
8114587c:	e0bffc15 	stw	r2,-16(fp)
81145880:	e0bffc17 	ldw	r2,-16(fp)
81145884:	10800210 	cmplti	r2,r2,8
81145888:	103fb71e 	bne	r2,zero,81145768 <__reset+0xfb125768>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8114588c:	e03ffc15 	stw	zero,-16(fp)
81145890:	00004a06 	br	811459bc <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81145894:	e0fffd17 	ldw	r3,-12(fp)
81145898:	e0bffc17 	ldw	r2,-16(fp)
8114589c:	1885883a 	add	r2,r3,r2
811458a0:	10800204 	addi	r2,r2,8
811458a4:	10800003 	ldbu	r2,0(r2)
811458a8:	10803fcc 	andi	r2,r2,255
811458ac:	10801870 	cmpltui	r2,r2,97
811458b0:	1000121e 	bne	r2,zero,811458fc <match_file_record_to_name_ext+0x1c4>
811458b4:	e0fffd17 	ldw	r3,-12(fp)
811458b8:	e0bffc17 	ldw	r2,-16(fp)
811458bc:	1885883a 	add	r2,r3,r2
811458c0:	10800204 	addi	r2,r2,8
811458c4:	10800003 	ldbu	r2,0(r2)
811458c8:	10803fcc 	andi	r2,r2,255
811458cc:	10801ee8 	cmpgeui	r2,r2,123
811458d0:	10000a1e 	bne	r2,zero,811458fc <match_file_record_to_name_ext+0x1c4>
811458d4:	e0fffd17 	ldw	r3,-12(fp)
811458d8:	e0bffc17 	ldw	r2,-16(fp)
811458dc:	1885883a 	add	r2,r3,r2
811458e0:	10800204 	addi	r2,r2,8
811458e4:	10800003 	ldbu	r2,0(r2)
811458e8:	10bff804 	addi	r2,r2,-32
811458ec:	10c03fcc 	andi	r3,r2,255
811458f0:	18c0201c 	xori	r3,r3,128
811458f4:	18ffe004 	addi	r3,r3,-128
811458f8:	00000806 	br	8114591c <match_file_record_to_name_ext+0x1e4>
811458fc:	e0fffd17 	ldw	r3,-12(fp)
81145900:	e0bffc17 	ldw	r2,-16(fp)
81145904:	1885883a 	add	r2,r3,r2
81145908:	10800204 	addi	r2,r2,8
8114590c:	10800003 	ldbu	r2,0(r2)
81145910:	10c03fcc 	andi	r3,r2,255
81145914:	18c0201c 	xori	r3,r3,128
81145918:	18ffe004 	addi	r3,r3,-128
8114591c:	e0bffc17 	ldw	r2,-16(fp)
81145920:	e13fff17 	ldw	r4,-4(fp)
81145924:	2085883a 	add	r2,r4,r2
81145928:	10800003 	ldbu	r2,0(r2)
8114592c:	10803fcc 	andi	r2,r2,255
81145930:	1080201c 	xori	r2,r2,128
81145934:	10bfe004 	addi	r2,r2,-128
81145938:	10801850 	cmplti	r2,r2,97
8114593c:	1000121e 	bne	r2,zero,81145988 <match_file_record_to_name_ext+0x250>
81145940:	e0bffc17 	ldw	r2,-16(fp)
81145944:	e13fff17 	ldw	r4,-4(fp)
81145948:	2085883a 	add	r2,r4,r2
8114594c:	10800003 	ldbu	r2,0(r2)
81145950:	10803fcc 	andi	r2,r2,255
81145954:	1080201c 	xori	r2,r2,128
81145958:	10bfe004 	addi	r2,r2,-128
8114595c:	10801ec8 	cmpgei	r2,r2,123
81145960:	1000091e 	bne	r2,zero,81145988 <match_file_record_to_name_ext+0x250>
81145964:	e0bffc17 	ldw	r2,-16(fp)
81145968:	e13fff17 	ldw	r4,-4(fp)
8114596c:	2085883a 	add	r2,r4,r2
81145970:	10800003 	ldbu	r2,0(r2)
81145974:	10bff804 	addi	r2,r2,-32
81145978:	10803fcc 	andi	r2,r2,255
8114597c:	1080201c 	xori	r2,r2,128
81145980:	10bfe004 	addi	r2,r2,-128
81145984:	00000706 	br	811459a4 <match_file_record_to_name_ext+0x26c>
81145988:	e0bffc17 	ldw	r2,-16(fp)
8114598c:	e13fff17 	ldw	r4,-4(fp)
81145990:	2085883a 	add	r2,r4,r2
81145994:	10800003 	ldbu	r2,0(r2)
81145998:	10803fcc 	andi	r2,r2,255
8114599c:	1080201c 	xori	r2,r2,128
811459a0:	10bfe004 	addi	r2,r2,-128
811459a4:	18800226 	beq	r3,r2,811459b0 <match_file_record_to_name_ext+0x278>
        {
            match = false;
811459a8:	e03ffb15 	stw	zero,-20(fp)
			break;
811459ac:	00000606 	br	811459c8 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811459b0:	e0bffc17 	ldw	r2,-16(fp)
811459b4:	10800044 	addi	r2,r2,1
811459b8:	e0bffc15 	stw	r2,-16(fp)
811459bc:	e0bffc17 	ldw	r2,-16(fp)
811459c0:	108000d0 	cmplti	r2,r2,3
811459c4:	103fb31e 	bne	r2,zero,81145894 <__reset+0xfb125894>
        {
            match = false;
			break;
        }
    }
	return match;
811459c8:	e0bffb17 	ldw	r2,-20(fp)
}
811459cc:	e037883a 	mov	sp,fp
811459d0:	df000017 	ldw	fp,0(sp)
811459d4:	dec00104 	addi	sp,sp,4
811459d8:	f800283a 	ret

811459dc <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
811459dc:	deffe704 	addi	sp,sp,-100
811459e0:	de00012e 	bgeu	sp,et,811459e8 <get_home_directory_cluster_for_file+0xc>
811459e4:	003b68fa 	trap	3
811459e8:	dfc01815 	stw	ra,96(sp)
811459ec:	df001715 	stw	fp,92(sp)
811459f0:	df001704 	addi	fp,sp,92
811459f4:	e13ffd15 	stw	r4,-12(fp)
811459f8:	e17ffe15 	stw	r5,-8(fp)
811459fc:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81145a00:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81145a04:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81145a08:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81145a0c:	e13ffd17 	ldw	r4,-12(fp)
81145a10:	11456780 	call	81145678 <get_dir_divider_location>
81145a14:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81145a18:	00012f06 	br	81145ed8 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81145a1c:	00800804 	movi	r2,32
81145a20:	e0bff905 	stb	r2,-28(fp)
81145a24:	00800804 	movi	r2,32
81145a28:	e0bff945 	stb	r2,-27(fp)
81145a2c:	00800804 	movi	r2,32
81145a30:	e0bff985 	stb	r2,-26(fp)
81145a34:	00800804 	movi	r2,32
81145a38:	e0bff9c5 	stb	r2,-25(fp)
81145a3c:	00800804 	movi	r2,32
81145a40:	e0bffa05 	stb	r2,-24(fp)
81145a44:	00800804 	movi	r2,32
81145a48:	e0bffa45 	stb	r2,-23(fp)
81145a4c:	00800804 	movi	r2,32
81145a50:	e0bffa85 	stb	r2,-22(fp)
81145a54:	00800804 	movi	r2,32
81145a58:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81145a5c:	00800804 	movi	r2,32
81145a60:	e0bffb05 	stb	r2,-20(fp)
81145a64:	00800804 	movi	r2,32
81145a68:	e0bffb45 	stb	r2,-19(fp)
81145a6c:	00800804 	movi	r2,32
81145a70:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81145a74:	00bfffc4 	movi	r2,-1
81145a78:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81145a7c:	e0bfea17 	ldw	r2,-88(fp)
81145a80:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81145a84:	e03fec15 	stw	zero,-80(fp)
81145a88:	00002d06 	br	81145b40 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81145a8c:	e0ffec17 	ldw	r3,-80(fp)
81145a90:	e0bfed17 	ldw	r2,-76(fp)
81145a94:	1885883a 	add	r2,r3,r2
81145a98:	1007883a 	mov	r3,r2
81145a9c:	e0bffd17 	ldw	r2,-12(fp)
81145aa0:	10c5883a 	add	r2,r2,r3
81145aa4:	10800003 	ldbu	r2,0(r2)
81145aa8:	10803fcc 	andi	r2,r2,255
81145aac:	1080201c 	xori	r2,r2,128
81145ab0:	10bfe004 	addi	r2,r2,-128
81145ab4:	10800b98 	cmpnei	r2,r2,46
81145ab8:	1000031e 	bne	r2,zero,81145ac8 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81145abc:	e0bfec17 	ldw	r2,-80(fp)
81145ac0:	e0bfee15 	stw	r2,-72(fp)
81145ac4:	00001b06 	br	81145b34 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81145ac8:	e0bfee17 	ldw	r2,-72(fp)
81145acc:	10000c0e 	bge	r2,zero,81145b00 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81145ad0:	e0ffec17 	ldw	r3,-80(fp)
81145ad4:	e0bfed17 	ldw	r2,-76(fp)
81145ad8:	1885883a 	add	r2,r3,r2
81145adc:	1007883a 	mov	r3,r2
81145ae0:	e0bffd17 	ldw	r2,-12(fp)
81145ae4:	10c5883a 	add	r2,r2,r3
81145ae8:	10c00003 	ldbu	r3,0(r2)
81145aec:	e13ff904 	addi	r4,fp,-28
81145af0:	e0bfec17 	ldw	r2,-80(fp)
81145af4:	2085883a 	add	r2,r4,r2
81145af8:	10c00005 	stb	r3,0(r2)
81145afc:	00000d06 	br	81145b34 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81145b00:	e0ffec17 	ldw	r3,-80(fp)
81145b04:	e0bfee17 	ldw	r2,-72(fp)
81145b08:	1885c83a 	sub	r2,r3,r2
81145b0c:	e13fec17 	ldw	r4,-80(fp)
81145b10:	e0ffed17 	ldw	r3,-76(fp)
81145b14:	20c7883a 	add	r3,r4,r3
81145b18:	1809883a 	mov	r4,r3
81145b1c:	e0fffd17 	ldw	r3,-12(fp)
81145b20:	1907883a 	add	r3,r3,r4
81145b24:	18c00003 	ldbu	r3,0(r3)
81145b28:	e13ffb04 	addi	r4,fp,-20
81145b2c:	2085883a 	add	r2,r4,r2
81145b30:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81145b34:	e0bfec17 	ldw	r2,-80(fp)
81145b38:	10800044 	addi	r2,r2,1
81145b3c:	e0bfec15 	stw	r2,-80(fp)
81145b40:	e0ffec17 	ldw	r3,-80(fp)
81145b44:	e0bfeb17 	ldw	r2,-84(fp)
81145b48:	18bfd016 	blt	r3,r2,81145a8c <__reset+0xfb125a8c>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81145b4c:	e0bfea17 	ldw	r2,-88(fp)
81145b50:	10005c1e 	bne	r2,zero,81145cc4 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81145b54:	00a045f4 	movhi	r2,33047
81145b58:	10bb9404 	addi	r2,r2,-4528
81145b5c:	1080050b 	ldhu	r2,20(r2)
81145b60:	10bfffcc 	andi	r2,r2,65535
81145b64:	1006917a 	slli	r3,r2,5
81145b68:	00a045f4 	movhi	r2,33047
81145b6c:	10bb9404 	addi	r2,r2,-4528
81145b70:	1080030b 	ldhu	r2,12(r2)
81145b74:	10bfffcc 	andi	r2,r2,65535
81145b78:	1885283a 	div	r2,r3,r2
81145b7c:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145b80:	e03ff015 	stw	zero,-64(fp)
81145b84:	00003b06 	br	81145c74 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81145b88:	00a045f4 	movhi	r2,33047
81145b8c:	10bb9404 	addi	r2,r2,-4528
81145b90:	10c01317 	ldw	r3,76(r2)
81145b94:	e0bff017 	ldw	r2,-64(fp)
81145b98:	1885883a 	add	r2,r3,r2
81145b9c:	1007883a 	mov	r3,r2
81145ba0:	d0a0b117 	ldw	r2,-32060(gp)
81145ba4:	100b883a 	mov	r5,r2
81145ba8:	1809883a 	mov	r4,r3
81145bac:	11442740 	call	81144274 <Read_Sector_Data>
81145bb0:	10003426 	beq	r2,zero,81145c84 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145bb4:	e03ff115 	stw	zero,-60(fp)
81145bb8:	00002506 	br	81145c50 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81145bbc:	e0bff117 	ldw	r2,-60(fp)
81145bc0:	1004917a 	slli	r2,r2,5
81145bc4:	e0fff017 	ldw	r3,-64(fp)
81145bc8:	180f883a 	mov	r7,r3
81145bcc:	000d883a 	mov	r6,zero
81145bd0:	e17fff17 	ldw	r5,-4(fp)
81145bd4:	1009883a 	mov	r4,r2
81145bd8:	11446a40 	call	811446a4 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145bdc:	e0bfff17 	ldw	r2,-4(fp)
81145be0:	10800003 	ldbu	r2,0(r2)
81145be4:	10803fcc 	andi	r2,r2,255
81145be8:	10803960 	cmpeqi	r2,r2,229
81145bec:	1000151e 	bne	r2,zero,81145c44 <get_home_directory_cluster_for_file+0x268>
81145bf0:	e0bfff17 	ldw	r2,-4(fp)
81145bf4:	10800003 	ldbu	r2,0(r2)
81145bf8:	10803fcc 	andi	r2,r2,255
81145bfc:	10001126 	beq	r2,zero,81145c44 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81145c00:	e0fffb04 	addi	r3,fp,-20
81145c04:	e0bff904 	addi	r2,fp,-28
81145c08:	180d883a 	mov	r6,r3
81145c0c:	100b883a 	mov	r5,r2
81145c10:	e13fff17 	ldw	r4,-4(fp)
81145c14:	11457380 	call	81145738 <match_file_record_to_name_ext>
81145c18:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81145c1c:	e0bff817 	ldw	r2,-32(fp)
81145c20:	10000826 	beq	r2,zero,81145c44 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81145c24:	e0bfff17 	ldw	r2,-4(fp)
81145c28:	1080058b 	ldhu	r2,22(r2)
81145c2c:	10bfffcc 	andi	r2,r2,65535
81145c30:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81145c34:	e0bfff17 	ldw	r2,-4(fp)
81145c38:	00c00044 	movi	r3,1
81145c3c:	10c00a15 	stw	r3,40(r2)
                                break;
81145c40:	00000606 	br	81145c5c <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145c44:	e0bff117 	ldw	r2,-60(fp)
81145c48:	10800044 	addi	r2,r2,1
81145c4c:	e0bff115 	stw	r2,-60(fp)
81145c50:	e0bff117 	ldw	r2,-60(fp)
81145c54:	10800410 	cmplti	r2,r2,16
81145c58:	103fd81e 	bne	r2,zero,81145bbc <__reset+0xfb125bbc>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81145c5c:	e0ffef17 	ldw	r3,-68(fp)
81145c60:	e0bfea17 	ldw	r2,-88(fp)
81145c64:	1880091e 	bne	r3,r2,81145c8c <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145c68:	e0bff017 	ldw	r2,-64(fp)
81145c6c:	10800044 	addi	r2,r2,1
81145c70:	e0bff015 	stw	r2,-64(fp)
81145c74:	e0fff017 	ldw	r3,-64(fp)
81145c78:	e0bff717 	ldw	r2,-36(fp)
81145c7c:	18bfc216 	blt	r3,r2,81145b88 <__reset+0xfb125b88>
81145c80:	00000306 	br	81145c90 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81145c84:	0001883a 	nop
81145c88:	00000106 	br	81145c90 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81145c8c:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81145c90:	e0ffef17 	ldw	r3,-68(fp)
81145c94:	e0bfea17 	ldw	r2,-88(fp)
81145c98:	18800826 	beq	r3,r2,81145cbc <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81145c9c:	e0bfef17 	ldw	r2,-68(fp)
81145ca0:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81145ca4:	e0ffed17 	ldw	r3,-76(fp)
81145ca8:	e0bfeb17 	ldw	r2,-84(fp)
81145cac:	1885883a 	add	r2,r3,r2
81145cb0:	10800044 	addi	r2,r2,1
81145cb4:	e0bfed15 	stw	r2,-76(fp)
81145cb8:	00007d06 	br	81145eb0 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81145cbc:	0005883a 	mov	r2,zero
81145cc0:	00009106 	br	81145f08 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81145cc4:	e0bfea17 	ldw	r2,-88(fp)
81145cc8:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81145ccc:	e0bff417 	ldw	r2,-48(fp)
81145cd0:	10ffff84 	addi	r3,r2,-2
81145cd4:	00a045f4 	movhi	r2,33047
81145cd8:	10bb9404 	addi	r2,r2,-4528
81145cdc:	10800383 	ldbu	r2,14(r2)
81145ce0:	10803fcc 	andi	r2,r2,255
81145ce4:	1885383a 	mul	r2,r3,r2
81145ce8:	1007883a 	mov	r3,r2
81145cec:	00a045f4 	movhi	r2,33047
81145cf0:	10bb9404 	addi	r2,r2,-4528
81145cf4:	10801417 	ldw	r2,80(r2)
81145cf8:	1885883a 	add	r2,r3,r2
81145cfc:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145d00:	e03ff215 	stw	zero,-56(fp)
81145d04:	00003606 	br	81145de0 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81145d08:	e0fff217 	ldw	r3,-56(fp)
81145d0c:	e0bff517 	ldw	r2,-44(fp)
81145d10:	1885883a 	add	r2,r3,r2
81145d14:	d0e0b117 	ldw	r3,-32060(gp)
81145d18:	180b883a 	mov	r5,r3
81145d1c:	1009883a 	mov	r4,r2
81145d20:	11442740 	call	81144274 <Read_Sector_Data>
81145d24:	10003526 	beq	r2,zero,81145dfc <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81145d28:	e03ff315 	stw	zero,-52(fp)
81145d2c:	00002306 	br	81145dbc <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81145d30:	e0bff317 	ldw	r2,-52(fp)
81145d34:	1004917a 	slli	r2,r2,5
81145d38:	e0fff417 	ldw	r3,-48(fp)
81145d3c:	e13ff217 	ldw	r4,-56(fp)
81145d40:	200f883a 	mov	r7,r4
81145d44:	180d883a 	mov	r6,r3
81145d48:	e17fff17 	ldw	r5,-4(fp)
81145d4c:	1009883a 	mov	r4,r2
81145d50:	11446a40 	call	811446a4 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145d54:	e0bfff17 	ldw	r2,-4(fp)
81145d58:	10800003 	ldbu	r2,0(r2)
81145d5c:	10803fcc 	andi	r2,r2,255
81145d60:	10803960 	cmpeqi	r2,r2,229
81145d64:	1000121e 	bne	r2,zero,81145db0 <get_home_directory_cluster_for_file+0x3d4>
81145d68:	e0bfff17 	ldw	r2,-4(fp)
81145d6c:	10800003 	ldbu	r2,0(r2)
81145d70:	10803fcc 	andi	r2,r2,255
81145d74:	10000e26 	beq	r2,zero,81145db0 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81145d78:	e0fffb04 	addi	r3,fp,-20
81145d7c:	e0bff904 	addi	r2,fp,-28
81145d80:	180d883a 	mov	r6,r3
81145d84:	100b883a 	mov	r5,r2
81145d88:	e13fff17 	ldw	r4,-4(fp)
81145d8c:	11457380 	call	81145738 <match_file_record_to_name_ext>
81145d90:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81145d94:	e0bff617 	ldw	r2,-40(fp)
81145d98:	10000526 	beq	r2,zero,81145db0 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81145d9c:	e0bfff17 	ldw	r2,-4(fp)
81145da0:	1080058b 	ldhu	r2,22(r2)
81145da4:	10bfffcc 	andi	r2,r2,65535
81145da8:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81145dac:	00000606 	br	81145dc8 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81145db0:	e0bff317 	ldw	r2,-52(fp)
81145db4:	10800044 	addi	r2,r2,1
81145db8:	e0bff315 	stw	r2,-52(fp)
81145dbc:	e0bff317 	ldw	r2,-52(fp)
81145dc0:	10800410 	cmplti	r2,r2,16
81145dc4:	103fda1e 	bne	r2,zero,81145d30 <__reset+0xfb125d30>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81145dc8:	e0ffef17 	ldw	r3,-68(fp)
81145dcc:	e0bfea17 	ldw	r2,-88(fp)
81145dd0:	18800c1e 	bne	r3,r2,81145e04 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145dd4:	e0bff217 	ldw	r2,-56(fp)
81145dd8:	10800044 	addi	r2,r2,1
81145ddc:	e0bff215 	stw	r2,-56(fp)
81145de0:	00a045f4 	movhi	r2,33047
81145de4:	10bb9404 	addi	r2,r2,-4528
81145de8:	10800383 	ldbu	r2,14(r2)
81145dec:	10803fcc 	andi	r2,r2,255
81145df0:	e0fff217 	ldw	r3,-56(fp)
81145df4:	18bfc416 	blt	r3,r2,81145d08 <__reset+0xfb125d08>
81145df8:	00000306 	br	81145e08 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81145dfc:	0001883a 	nop
81145e00:	00000106 	br	81145e08 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81145e04:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81145e08:	e0ffef17 	ldw	r3,-68(fp)
81145e0c:	e0bfea17 	ldw	r2,-88(fp)
81145e10:	1880141e 	bne	r3,r2,81145e64 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81145e14:	e0bfef17 	ldw	r2,-68(fp)
81145e18:	e0fffc04 	addi	r3,fp,-16
81145e1c:	180b883a 	mov	r5,r3
81145e20:	1009883a 	mov	r4,r2
81145e24:	11443540 	call	81144354 <get_cluster_flag>
81145e28:	10000c26 	beq	r2,zero,81145e5c <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81145e2c:	e0bffc0b 	ldhu	r2,-16(fp)
81145e30:	10bfffcc 	andi	r2,r2,65535
81145e34:	10fffe0c 	andi	r3,r2,65528
81145e38:	00bffe14 	movui	r2,65528
81145e3c:	1880021e 	bne	r3,r2,81145e48 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81145e40:	0005883a 	mov	r2,zero
81145e44:	00003006 	br	81145f08 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81145e48:	e0bffc0b 	ldhu	r2,-16(fp)
81145e4c:	10bfffcc 	andi	r2,r2,65535
81145e50:	10bffe0c 	andi	r2,r2,65528
81145e54:	e0bfef15 	stw	r2,-68(fp)
81145e58:	00000206 	br	81145e64 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81145e5c:	0005883a 	mov	r2,zero
81145e60:	00002906 	br	81145f08 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81145e64:	e0bff417 	ldw	r2,-48(fp)
81145e68:	00fffdd4 	movui	r3,65527
81145e6c:	18800316 	blt	r3,r2,81145e7c <get_home_directory_cluster_for_file+0x4a0>
81145e70:	e0ffef17 	ldw	r3,-68(fp)
81145e74:	e0bfea17 	ldw	r2,-88(fp)
81145e78:	18bf9426 	beq	r3,r2,81145ccc <__reset+0xfb125ccc>
            if (new_cluster != home_dir_cluster)
81145e7c:	e0ffef17 	ldw	r3,-68(fp)
81145e80:	e0bfea17 	ldw	r2,-88(fp)
81145e84:	18800826 	beq	r3,r2,81145ea8 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81145e88:	e0bfef17 	ldw	r2,-68(fp)
81145e8c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81145e90:	e0ffed17 	ldw	r3,-76(fp)
81145e94:	e0bfeb17 	ldw	r2,-84(fp)
81145e98:	1885883a 	add	r2,r3,r2
81145e9c:	10800044 	addi	r2,r2,1
81145ea0:	e0bfed15 	stw	r2,-76(fp)
81145ea4:	00000206 	br	81145eb0 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81145ea8:	0005883a 	mov	r2,zero
81145eac:	00001606 	br	81145f08 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81145eb0:	e0bfed17 	ldw	r2,-76(fp)
81145eb4:	e0fffd17 	ldw	r3,-12(fp)
81145eb8:	1885883a 	add	r2,r3,r2
81145ebc:	1009883a 	mov	r4,r2
81145ec0:	11456780 	call	81145678 <get_dir_divider_location>
81145ec4:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81145ec8:	e0bfeb17 	ldw	r2,-84(fp)
81145ecc:	1000020e 	bge	r2,zero,81145ed8 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81145ed0:	00800044 	movi	r2,1
81145ed4:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81145ed8:	e0bfeb17 	ldw	r2,-84(fp)
81145edc:	00becf16 	blt	zero,r2,81145a1c <__reset+0xfb125a1c>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81145ee0:	e0bffe17 	ldw	r2,-8(fp)
81145ee4:	e0ffea17 	ldw	r3,-88(fp)
81145ee8:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81145eec:	e0bfea17 	ldw	r2,-88(fp)
81145ef0:	1000041e 	bne	r2,zero,81145f04 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81145ef4:	e0bfff17 	ldw	r2,-4(fp)
81145ef8:	10000a15 	stw	zero,40(r2)
		result = true;
81145efc:	00800044 	movi	r2,1
81145f00:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81145f04:	e0bfe917 	ldw	r2,-92(fp)
}
81145f08:	e037883a 	mov	sp,fp
81145f0c:	dfc00117 	ldw	ra,4(sp)
81145f10:	df000017 	ldw	fp,0(sp)
81145f14:	dec00204 	addi	sp,sp,8
81145f18:	f800283a 	ret

81145f1c <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81145f1c:	deffe804 	addi	sp,sp,-96
81145f20:	de00012e 	bgeu	sp,et,81145f28 <find_file_in_directory+0xc>
81145f24:	003b68fa 	trap	3
81145f28:	dfc01715 	stw	ra,92(sp)
81145f2c:	df001615 	stw	fp,88(sp)
81145f30:	df001604 	addi	fp,sp,88
81145f34:	e13ffd15 	stw	r4,-12(fp)
81145f38:	e17ffe15 	stw	r5,-8(fp)
81145f3c:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81145f40:	e13ffe17 	ldw	r4,-8(fp)
81145f44:	11456780 	call	81145678 <get_dir_divider_location>
81145f48:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81145f4c:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81145f50:	00800804 	movi	r2,32
81145f54:	e0bff905 	stb	r2,-28(fp)
81145f58:	00800804 	movi	r2,32
81145f5c:	e0bff945 	stb	r2,-27(fp)
81145f60:	00800804 	movi	r2,32
81145f64:	e0bff985 	stb	r2,-26(fp)
81145f68:	00800804 	movi	r2,32
81145f6c:	e0bff9c5 	stb	r2,-25(fp)
81145f70:	00800804 	movi	r2,32
81145f74:	e0bffa05 	stb	r2,-24(fp)
81145f78:	00800804 	movi	r2,32
81145f7c:	e0bffa45 	stb	r2,-23(fp)
81145f80:	00800804 	movi	r2,32
81145f84:	e0bffa85 	stb	r2,-22(fp)
81145f88:	00800804 	movi	r2,32
81145f8c:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81145f90:	00800804 	movi	r2,32
81145f94:	e0bffb05 	stb	r2,-20(fp)
81145f98:	00800804 	movi	r2,32
81145f9c:	e0bffb45 	stb	r2,-19(fp)
81145fa0:	00800804 	movi	r2,32
81145fa4:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81145fa8:	00bfffc4 	movi	r2,-1
81145fac:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81145fb0:	e0bffd17 	ldw	r2,-12(fp)
81145fb4:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81145fb8:	e13ffe17 	ldw	r4,-8(fp)
81145fbc:	11251780 	call	81125178 <strlen>
81145fc0:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81145fc4:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81145fc8:	00000b06 	br	81145ff8 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81145fcc:	e0ffeb17 	ldw	r3,-84(fp)
81145fd0:	e0bfea17 	ldw	r2,-88(fp)
81145fd4:	1885883a 	add	r2,r3,r2
81145fd8:	10800044 	addi	r2,r2,1
81145fdc:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81145fe0:	e0bfeb17 	ldw	r2,-84(fp)
81145fe4:	e0fffe17 	ldw	r3,-8(fp)
81145fe8:	1885883a 	add	r2,r3,r2
81145fec:	1009883a 	mov	r4,r2
81145ff0:	11456780 	call	81145678 <get_dir_divider_location>
81145ff4:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81145ff8:	e0bfea17 	ldw	r2,-88(fp)
81145ffc:	00bff316 	blt	zero,r2,81145fcc <__reset+0xfb125fcc>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81146000:	e0bfeb17 	ldw	r2,-84(fp)
81146004:	e0bfee15 	stw	r2,-72(fp)
81146008:	00002706 	br	811460a8 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8114600c:	e0bfee17 	ldw	r2,-72(fp)
81146010:	e0fffe17 	ldw	r3,-8(fp)
81146014:	1885883a 	add	r2,r3,r2
81146018:	10800003 	ldbu	r2,0(r2)
8114601c:	10803fcc 	andi	r2,r2,255
81146020:	1080201c 	xori	r2,r2,128
81146024:	10bfe004 	addi	r2,r2,-128
81146028:	10800b98 	cmpnei	r2,r2,46
8114602c:	1000031e 	bne	r2,zero,8114603c <find_file_in_directory+0x120>
        {
            ext_index = index;
81146030:	e0bfee17 	ldw	r2,-72(fp)
81146034:	e0bfec15 	stw	r2,-80(fp)
81146038:	00001806 	br	8114609c <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8114603c:	e0bfec17 	ldw	r2,-80(fp)
81146040:	10000b0e 	bge	r2,zero,81146070 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81146044:	e0ffee17 	ldw	r3,-72(fp)
81146048:	e0bfeb17 	ldw	r2,-84(fp)
8114604c:	1885c83a 	sub	r2,r3,r2
81146050:	e0ffee17 	ldw	r3,-72(fp)
81146054:	e13ffe17 	ldw	r4,-8(fp)
81146058:	20c7883a 	add	r3,r4,r3
8114605c:	18c00003 	ldbu	r3,0(r3)
81146060:	e13ff904 	addi	r4,fp,-28
81146064:	2085883a 	add	r2,r4,r2
81146068:	10c00005 	stb	r3,0(r2)
8114606c:	00000b06 	br	8114609c <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81146070:	e0ffee17 	ldw	r3,-72(fp)
81146074:	e0bfec17 	ldw	r2,-80(fp)
81146078:	1885c83a 	sub	r2,r3,r2
8114607c:	10bfffc4 	addi	r2,r2,-1
81146080:	e0ffee17 	ldw	r3,-72(fp)
81146084:	e13ffe17 	ldw	r4,-8(fp)
81146088:	20c7883a 	add	r3,r4,r3
8114608c:	18c00003 	ldbu	r3,0(r3)
81146090:	e13ffb04 	addi	r4,fp,-20
81146094:	2085883a 	add	r2,r4,r2
81146098:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8114609c:	e0bfee17 	ldw	r2,-72(fp)
811460a0:	10800044 	addi	r2,r2,1
811460a4:	e0bfee15 	stw	r2,-72(fp)
811460a8:	e0ffee17 	ldw	r3,-72(fp)
811460ac:	e0bff417 	ldw	r2,-48(fp)
811460b0:	18bfd616 	blt	r3,r2,8114600c <__reset+0xfb12600c>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
811460b4:	e0bffd17 	ldw	r2,-12(fp)
811460b8:	1000461e 	bne	r2,zero,811461d4 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811460bc:	00a045f4 	movhi	r2,33047
811460c0:	10bb9404 	addi	r2,r2,-4528
811460c4:	1080050b 	ldhu	r2,20(r2)
811460c8:	10bfffcc 	andi	r2,r2,65535
811460cc:	1006917a 	slli	r3,r2,5
811460d0:	00a045f4 	movhi	r2,33047
811460d4:	10bb9404 	addi	r2,r2,-4528
811460d8:	1080030b 	ldhu	r2,12(r2)
811460dc:	10bfffcc 	andi	r2,r2,65535
811460e0:	1885283a 	div	r2,r3,r2
811460e4:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811460e8:	e03ff015 	stw	zero,-64(fp)
811460ec:	00003506 	br	811461c4 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811460f0:	00a045f4 	movhi	r2,33047
811460f4:	10bb9404 	addi	r2,r2,-4528
811460f8:	10c01317 	ldw	r3,76(r2)
811460fc:	e0bff017 	ldw	r2,-64(fp)
81146100:	1885883a 	add	r2,r3,r2
81146104:	1007883a 	mov	r3,r2
81146108:	d0a0b117 	ldw	r2,-32060(gp)
8114610c:	100b883a 	mov	r5,r2
81146110:	1809883a 	mov	r4,r3
81146114:	11442740 	call	81144274 <Read_Sector_Data>
81146118:	10009626 	beq	r2,zero,81146374 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8114611c:	e03ff115 	stw	zero,-60(fp)
81146120:	00002006 	br	811461a4 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81146124:	e0bff117 	ldw	r2,-60(fp)
81146128:	1004917a 	slli	r2,r2,5
8114612c:	e0fff017 	ldw	r3,-64(fp)
81146130:	180f883a 	mov	r7,r3
81146134:	000d883a 	mov	r6,zero
81146138:	e17fff17 	ldw	r5,-4(fp)
8114613c:	1009883a 	mov	r4,r2
81146140:	11446a40 	call	811446a4 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81146144:	e0bfff17 	ldw	r2,-4(fp)
81146148:	10800003 	ldbu	r2,0(r2)
8114614c:	10803fcc 	andi	r2,r2,255
81146150:	10803960 	cmpeqi	r2,r2,229
81146154:	1000101e 	bne	r2,zero,81146198 <find_file_in_directory+0x27c>
81146158:	e0bfff17 	ldw	r2,-4(fp)
8114615c:	10800003 	ldbu	r2,0(r2)
81146160:	10803fcc 	andi	r2,r2,255
81146164:	10000c26 	beq	r2,zero,81146198 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81146168:	e0fffb04 	addi	r3,fp,-20
8114616c:	e0bff904 	addi	r2,fp,-28
81146170:	180d883a 	mov	r6,r3
81146174:	100b883a 	mov	r5,r2
81146178:	e13fff17 	ldw	r4,-4(fp)
8114617c:	11457380 	call	81145738 <match_file_record_to_name_ext>
81146180:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81146184:	e0bff817 	ldw	r2,-32(fp)
81146188:	10000326 	beq	r2,zero,81146198 <find_file_in_directory+0x27c>
                        {
                            result = true;
8114618c:	00800044 	movi	r2,1
81146190:	e0bfef15 	stw	r2,-68(fp)
                            break;
81146194:	00000606 	br	811461b0 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81146198:	e0bff117 	ldw	r2,-60(fp)
8114619c:	10800044 	addi	r2,r2,1
811461a0:	e0bff115 	stw	r2,-60(fp)
811461a4:	e0bff117 	ldw	r2,-60(fp)
811461a8:	10800410 	cmplti	r2,r2,16
811461ac:	103fdd1e 	bne	r2,zero,81146124 <__reset+0xfb126124>
            }
            else
            {
                break;
            }
            if (result)
811461b0:	e0bfef17 	ldw	r2,-68(fp)
811461b4:	1000711e 	bne	r2,zero,8114637c <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811461b8:	e0bff017 	ldw	r2,-64(fp)
811461bc:	10800044 	addi	r2,r2,1
811461c0:	e0bff015 	stw	r2,-64(fp)
811461c4:	e0fff017 	ldw	r3,-64(fp)
811461c8:	e0bff717 	ldw	r2,-36(fp)
811461cc:	18bfc816 	blt	r3,r2,811460f0 <__reset+0xfb1260f0>
811461d0:	00006b06 	br	81146380 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811461d4:	e0bfed17 	ldw	r2,-76(fp)
811461d8:	10ffff84 	addi	r3,r2,-2
811461dc:	00a045f4 	movhi	r2,33047
811461e0:	10bb9404 	addi	r2,r2,-4528
811461e4:	10800383 	ldbu	r2,14(r2)
811461e8:	10803fcc 	andi	r2,r2,255
811461ec:	1885383a 	mul	r2,r3,r2
811461f0:	1007883a 	mov	r3,r2
811461f4:	00a045f4 	movhi	r2,33047
811461f8:	10bb9404 	addi	r2,r2,-4528
811461fc:	10801417 	ldw	r2,80(r2)
81146200:	1885883a 	add	r2,r3,r2
81146204:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81146208:	e03ff215 	stw	zero,-56(fp)
8114620c:	00003306 	br	811462dc <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81146210:	e0fff217 	ldw	r3,-56(fp)
81146214:	e0bff517 	ldw	r2,-44(fp)
81146218:	1885883a 	add	r2,r3,r2
8114621c:	d0e0b117 	ldw	r3,-32060(gp)
81146220:	180b883a 	mov	r5,r3
81146224:	1009883a 	mov	r4,r2
81146228:	11442740 	call	81144274 <Read_Sector_Data>
8114622c:	10003226 	beq	r2,zero,811462f8 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81146230:	e03ff315 	stw	zero,-52(fp)
81146234:	00002106 	br	811462bc <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81146238:	e0bff317 	ldw	r2,-52(fp)
8114623c:	1004917a 	slli	r2,r2,5
81146240:	e0ffed17 	ldw	r3,-76(fp)
81146244:	e13ff217 	ldw	r4,-56(fp)
81146248:	200f883a 	mov	r7,r4
8114624c:	180d883a 	mov	r6,r3
81146250:	e17fff17 	ldw	r5,-4(fp)
81146254:	1009883a 	mov	r4,r2
81146258:	11446a40 	call	811446a4 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114625c:	e0bfff17 	ldw	r2,-4(fp)
81146260:	10800003 	ldbu	r2,0(r2)
81146264:	10803fcc 	andi	r2,r2,255
81146268:	10803960 	cmpeqi	r2,r2,229
8114626c:	1000101e 	bne	r2,zero,811462b0 <find_file_in_directory+0x394>
81146270:	e0bfff17 	ldw	r2,-4(fp)
81146274:	10800003 	ldbu	r2,0(r2)
81146278:	10803fcc 	andi	r2,r2,255
8114627c:	10000c26 	beq	r2,zero,811462b0 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81146280:	e0fffb04 	addi	r3,fp,-20
81146284:	e0bff904 	addi	r2,fp,-28
81146288:	180d883a 	mov	r6,r3
8114628c:	100b883a 	mov	r5,r2
81146290:	e13fff17 	ldw	r4,-4(fp)
81146294:	11457380 	call	81145738 <match_file_record_to_name_ext>
81146298:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8114629c:	e0bff617 	ldw	r2,-40(fp)
811462a0:	10000326 	beq	r2,zero,811462b0 <find_file_in_directory+0x394>
                            {                               
                                result = true;
811462a4:	00800044 	movi	r2,1
811462a8:	e0bfef15 	stw	r2,-68(fp)
                                break;
811462ac:	00000606 	br	811462c8 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811462b0:	e0bff317 	ldw	r2,-52(fp)
811462b4:	10800044 	addi	r2,r2,1
811462b8:	e0bff315 	stw	r2,-52(fp)
811462bc:	e0bff317 	ldw	r2,-52(fp)
811462c0:	10800410 	cmplti	r2,r2,16
811462c4:	103fdc1e 	bne	r2,zero,81146238 <__reset+0xfb126238>
                }
                else
                {
                    break;
                }
                if (result)
811462c8:	e0bfef17 	ldw	r2,-68(fp)
811462cc:	10000c1e 	bne	r2,zero,81146300 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811462d0:	e0bff217 	ldw	r2,-56(fp)
811462d4:	10800044 	addi	r2,r2,1
811462d8:	e0bff215 	stw	r2,-56(fp)
811462dc:	00a045f4 	movhi	r2,33047
811462e0:	10bb9404 	addi	r2,r2,-4528
811462e4:	10800383 	ldbu	r2,14(r2)
811462e8:	10803fcc 	andi	r2,r2,255
811462ec:	e0fff217 	ldw	r3,-56(fp)
811462f0:	18bfc716 	blt	r3,r2,81146210 <__reset+0xfb126210>
811462f4:	00000306 	br	81146304 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
811462f8:	0001883a 	nop
811462fc:	00000106 	br	81146304 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81146300:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81146304:	e0bfef17 	ldw	r2,-68(fp)
81146308:	1000141e 	bne	r2,zero,8114635c <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8114630c:	e0bfed17 	ldw	r2,-76(fp)
81146310:	e0fffc04 	addi	r3,fp,-16
81146314:	180b883a 	mov	r5,r3
81146318:	1009883a 	mov	r4,r2
8114631c:	11443540 	call	81144354 <get_cluster_flag>
81146320:	10000c26 	beq	r2,zero,81146354 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81146324:	e0bffc0b 	ldhu	r2,-16(fp)
81146328:	10bfffcc 	andi	r2,r2,65535
8114632c:	10fffe0c 	andi	r3,r2,65528
81146330:	00bffe14 	movui	r2,65528
81146334:	1880021e 	bne	r3,r2,81146340 <find_file_in_directory+0x424>
					{
						return false;
81146338:	0005883a 	mov	r2,zero
8114633c:	00001106 	br	81146384 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81146340:	e0bffc0b 	ldhu	r2,-16(fp)
81146344:	10bfffcc 	andi	r2,r2,65535
81146348:	10bffe0c 	andi	r2,r2,65528
8114634c:	e0bfed15 	stw	r2,-76(fp)
81146350:	00000206 	br	8114635c <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81146354:	0005883a 	mov	r2,zero
81146358:	00000a06 	br	81146384 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8114635c:	e0bfed17 	ldw	r2,-76(fp)
81146360:	00fffdd4 	movui	r3,65527
81146364:	18800616 	blt	r3,r2,81146380 <find_file_in_directory+0x464>
81146368:	e0bfef17 	ldw	r2,-68(fp)
8114636c:	103f9926 	beq	r2,zero,811461d4 <__reset+0xfb1261d4>
81146370:	00000306 	br	81146380 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81146374:	0001883a 	nop
81146378:	00000106 	br	81146380 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8114637c:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81146380:	e0bfef17 	ldw	r2,-68(fp)
}
81146384:	e037883a 	mov	sp,fp
81146388:	dfc00117 	ldw	ra,4(sp)
8114638c:	df000017 	ldw	fp,0(sp)
81146390:	dec00204 	addi	sp,sp,8
81146394:	f800283a 	ret

81146398 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81146398:	defff504 	addi	sp,sp,-44
8114639c:	de00012e 	bgeu	sp,et,811463a4 <find_first_empty_cluster+0xc>
811463a0:	003b68fa 	trap	3
811463a4:	dfc00a15 	stw	ra,40(sp)
811463a8:	df000915 	stw	fp,36(sp)
811463ac:	df000904 	addi	fp,sp,36
811463b0:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
811463b4:	00a045f4 	movhi	r2,33047
811463b8:	10bb9404 	addi	r2,r2,-4528
811463bc:	10801117 	ldw	r2,68(r2)
811463c0:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
811463c4:	00800084 	movi	r2,2
811463c8:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
811463cc:	00bfffc4 	movi	r2,-1
811463d0:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
811463d4:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
811463d8:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
811463dc:	00a045f4 	movhi	r2,33047
811463e0:	10bb9404 	addi	r2,r2,-4528
811463e4:	10801417 	ldw	r2,80(r2)
811463e8:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
811463ec:	00a045f4 	movhi	r2,33047
811463f0:	10bb9404 	addi	r2,r2,-4528
811463f4:	1080058b 	ldhu	r2,22(r2)
811463f8:	10bfffcc 	andi	r2,r2,65535
811463fc:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81146400:	00a045f4 	movhi	r2,33047
81146404:	10bb9404 	addi	r2,r2,-4528
81146408:	10800917 	ldw	r2,36(r2)
8114640c:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81146410:	e0bffd17 	ldw	r2,-12(fp)
81146414:	e0fffe17 	ldw	r3,-8(fp)
81146418:	18800b2e 	bgeu	r3,r2,81146448 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8114641c:	e0fffd17 	ldw	r3,-12(fp)
81146420:	e0bffc17 	ldw	r2,-16(fp)
81146424:	1887c83a 	sub	r3,r3,r2
81146428:	00a045f4 	movhi	r2,33047
8114642c:	10bb9404 	addi	r2,r2,-4528
81146430:	10800383 	ldbu	r2,14(r2)
81146434:	10803fcc 	andi	r2,r2,255
81146438:	1885203a 	divu	r2,r3,r2
8114643c:	10800044 	addi	r2,r2,1
81146440:	e0bffb15 	stw	r2,-20(fp)
81146444:	00002a06 	br	811464f0 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81146448:	e0fffe17 	ldw	r3,-8(fp)
8114644c:	e0bffc17 	ldw	r2,-16(fp)
81146450:	1887c83a 	sub	r3,r3,r2
81146454:	00a045f4 	movhi	r2,33047
81146458:	10bb9404 	addi	r2,r2,-4528
8114645c:	10800383 	ldbu	r2,14(r2)
81146460:	10803fcc 	andi	r2,r2,255
81146464:	1885203a 	divu	r2,r3,r2
81146468:	10800044 	addi	r2,r2,1
8114646c:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81146470:	00001f06 	br	811464f0 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81146474:	e0bff717 	ldw	r2,-36(fp)
81146478:	d0e0b117 	ldw	r3,-32060(gp)
8114647c:	180b883a 	mov	r5,r3
81146480:	1009883a 	mov	r4,r2
81146484:	11442740 	call	81144274 <Read_Sector_Data>
81146488:	10001426 	beq	r2,zero,811464dc <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8114648c:	e0bff817 	ldw	r2,-32(fp)
81146490:	10803fcc 	andi	r2,r2,255
81146494:	1085883a 	add	r2,r2,r2
81146498:	1007883a 	mov	r3,r2
8114649c:	d0a0b317 	ldw	r2,-32052(gp)
811464a0:	10800a17 	ldw	r2,40(r2)
811464a4:	1885883a 	add	r2,r3,r2
811464a8:	1080002b 	ldhuio	r2,0(r2)
811464ac:	10bfffcc 	andi	r2,r2,65535
811464b0:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
811464b4:	e0bff90f 	ldh	r2,-28(fp)
811464b8:	10000726 	beq	r2,zero,811464d8 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
811464bc:	e0bff817 	ldw	r2,-32(fp)
811464c0:	10800044 	addi	r2,r2,1
811464c4:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
811464c8:	e0bff817 	ldw	r2,-32(fp)
811464cc:	10803fcc 	andi	r2,r2,255
811464d0:	103fee1e 	bne	r2,zero,8114648c <__reset+0xfb12648c>
811464d4:	00000106 	br	811464dc <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
811464d8:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
811464dc:	e0bff90f 	ldh	r2,-28(fp)
811464e0:	10000926 	beq	r2,zero,81146508 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811464e4:	e0bff717 	ldw	r2,-36(fp)
811464e8:	10800044 	addi	r2,r2,1
811464ec:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811464f0:	00a045f4 	movhi	r2,33047
811464f4:	10bb9404 	addi	r2,r2,-4528
811464f8:	10c01217 	ldw	r3,72(r2)
811464fc:	e0bff717 	ldw	r2,-36(fp)
81146500:	18bfdc1e 	bne	r3,r2,81146474 <__reset+0xfb126474>
81146504:	00000106 	br	8114650c <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81146508:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8114650c:	e0bff90f 	ldh	r2,-28(fp)
81146510:	1000081e 	bne	r2,zero,81146534 <find_first_empty_cluster+0x19c>
81146514:	e0bff90f 	ldh	r2,-28(fp)
81146518:	e0fffb17 	ldw	r3,-20(fp)
8114651c:	18800536 	bltu	r3,r2,81146534 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81146520:	e0bfff17 	ldw	r2,-4(fp)
81146524:	e0fff817 	ldw	r3,-32(fp)
81146528:	10c00015 	stw	r3,0(r2)
		result = true;
8114652c:	00800044 	movi	r2,1
81146530:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81146534:	e0bffa17 	ldw	r2,-24(fp)
}
81146538:	e037883a 	mov	sp,fp
8114653c:	dfc00117 	ldw	ra,4(sp)
81146540:	df000017 	ldw	fp,0(sp)
81146544:	dec00204 	addi	sp,sp,8
81146548:	f800283a 	ret

8114654c <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8114654c:	defff604 	addi	sp,sp,-40
81146550:	de00012e 	bgeu	sp,et,81146558 <find_first_empty_record_in_a_subdirectory+0xc>
81146554:	003b68fa 	trap	3
81146558:	dfc00915 	stw	ra,36(sp)
8114655c:	df000815 	stw	fp,32(sp)
81146560:	df000804 	addi	fp,sp,32
81146564:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81146568:	00bfffc4 	movi	r2,-1
8114656c:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81146570:	e0bfff17 	ldw	r2,-4(fp)
81146574:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81146578:	e0bff917 	ldw	r2,-28(fp)
8114657c:	10ffff84 	addi	r3,r2,-2
81146580:	00a045f4 	movhi	r2,33047
81146584:	10bb9404 	addi	r2,r2,-4528
81146588:	10800383 	ldbu	r2,14(r2)
8114658c:	10803fcc 	andi	r2,r2,255
81146590:	1885383a 	mul	r2,r3,r2
81146594:	1007883a 	mov	r3,r2
81146598:	00a045f4 	movhi	r2,33047
8114659c:	10bb9404 	addi	r2,r2,-4528
811465a0:	10801417 	ldw	r2,80(r2)
811465a4:	1885883a 	add	r2,r3,r2
811465a8:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811465ac:	e03ffa15 	stw	zero,-24(fp)
811465b0:	00002c06 	br	81146664 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811465b4:	e0fffa17 	ldw	r3,-24(fp)
811465b8:	e0bffc17 	ldw	r2,-16(fp)
811465bc:	1885883a 	add	r2,r3,r2
811465c0:	d0e0b117 	ldw	r3,-32060(gp)
811465c4:	180b883a 	mov	r5,r3
811465c8:	1009883a 	mov	r4,r2
811465cc:	11442740 	call	81144274 <Read_Sector_Data>
811465d0:	10002b26 	beq	r2,zero,81146680 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811465d4:	e03ffb15 	stw	zero,-20(fp)
811465d8:	00001c06 	br	8114664c <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811465dc:	e0bffb17 	ldw	r2,-20(fp)
811465e0:	1004917a 	slli	r2,r2,5
811465e4:	1007883a 	mov	r3,r2
811465e8:	d0a0b317 	ldw	r2,-32052(gp)
811465ec:	10800a17 	ldw	r2,40(r2)
811465f0:	1885883a 	add	r2,r3,r2
811465f4:	10800023 	ldbuio	r2,0(r2)
811465f8:	10803fcc 	andi	r2,r2,255
811465fc:	10803fcc 	andi	r2,r2,255
81146600:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81146604:	e0bffd0b 	ldhu	r2,-12(fp)
81146608:	10803960 	cmpeqi	r2,r2,229
8114660c:	1000021e 	bne	r2,zero,81146618 <find_first_empty_record_in_a_subdirectory+0xcc>
81146610:	e0bffd0b 	ldhu	r2,-12(fp)
81146614:	10000a1e 	bne	r2,zero,81146640 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81146618:	e0bffa17 	ldw	r2,-24(fp)
8114661c:	1006913a 	slli	r3,r2,4
81146620:	e0bffb17 	ldw	r2,-20(fp)
81146624:	1885883a 	add	r2,r3,r2
81146628:	1006943a 	slli	r3,r2,16
8114662c:	e0bff917 	ldw	r2,-28(fp)
81146630:	1884b03a 	or	r2,r3,r2
81146634:	e0bff815 	stw	r2,-32(fp)
                        return result;
81146638:	e0bff817 	ldw	r2,-32(fp)
8114663c:	00005306 	br	8114678c <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81146640:	e0bffb17 	ldw	r2,-20(fp)
81146644:	10800044 	addi	r2,r2,1
81146648:	e0bffb15 	stw	r2,-20(fp)
8114664c:	e0bffb17 	ldw	r2,-20(fp)
81146650:	10800410 	cmplti	r2,r2,16
81146654:	103fe11e 	bne	r2,zero,811465dc <__reset+0xfb1265dc>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81146658:	e0bffa17 	ldw	r2,-24(fp)
8114665c:	10800044 	addi	r2,r2,1
81146660:	e0bffa15 	stw	r2,-24(fp)
81146664:	00a045f4 	movhi	r2,33047
81146668:	10bb9404 	addi	r2,r2,-4528
8114666c:	10800383 	ldbu	r2,14(r2)
81146670:	10803fcc 	andi	r2,r2,255
81146674:	e0fffa17 	ldw	r3,-24(fp)
81146678:	18bfce16 	blt	r3,r2,811465b4 <__reset+0xfb1265b4>
8114667c:	00000106 	br	81146684 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81146680:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81146684:	e0bff817 	ldw	r2,-32(fp)
81146688:	1000390e 	bge	r2,zero,81146770 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8114668c:	e0bff917 	ldw	r2,-28(fp)
81146690:	e0fffd84 	addi	r3,fp,-10
81146694:	180b883a 	mov	r5,r3
81146698:	1009883a 	mov	r4,r2
8114669c:	11443540 	call	81144354 <get_cluster_flag>
811466a0:	10003126 	beq	r2,zero,81146768 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811466a4:	e0bffd8b 	ldhu	r2,-10(fp)
811466a8:	10bfffcc 	andi	r2,r2,65535
811466ac:	10fffe0c 	andi	r3,r2,65528
811466b0:	00bffe14 	movui	r2,65528
811466b4:	18802e1e 	bne	r3,r2,81146770 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
811466b8:	e0bffe04 	addi	r2,fp,-8
811466bc:	1009883a 	mov	r4,r2
811466c0:	11463980 	call	81146398 <find_first_empty_cluster>
811466c4:	10002326 	beq	r2,zero,81146754 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811466c8:	e0bff917 	ldw	r2,-28(fp)
811466cc:	e0fffe17 	ldw	r3,-8(fp)
811466d0:	18ffffcc 	andi	r3,r3,65535
811466d4:	18e0001c 	xori	r3,r3,32768
811466d8:	18e00004 	addi	r3,r3,-32768
811466dc:	01800044 	movi	r6,1
811466e0:	180b883a 	mov	r5,r3
811466e4:	1009883a 	mov	r4,r2
811466e8:	11444100 	call	81144410 <mark_cluster>
811466ec:	10001926 	beq	r2,zero,81146754 <find_first_empty_record_in_a_subdirectory+0x208>
811466f0:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811466f4:	01800044 	movi	r6,1
811466f8:	017fffc4 	movi	r5,-1
811466fc:	1009883a 	mov	r4,r2
81146700:	11444100 	call	81144410 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81146704:	10001326 	beq	r2,zero,81146754 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81146708:	e0bff917 	ldw	r2,-28(fp)
8114670c:	e0fffe17 	ldw	r3,-8(fp)
81146710:	18ffffcc 	andi	r3,r3,65535
81146714:	18e0001c 	xori	r3,r3,32768
81146718:	18e00004 	addi	r3,r3,-32768
8114671c:	000d883a 	mov	r6,zero
81146720:	180b883a 	mov	r5,r3
81146724:	1009883a 	mov	r4,r2
81146728:	11444100 	call	81144410 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8114672c:	10000926 	beq	r2,zero,81146754 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81146730:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81146734:	000d883a 	mov	r6,zero
81146738:	017fffc4 	movi	r5,-1
8114673c:	1009883a 	mov	r4,r2
81146740:	11444100 	call	81144410 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81146744:	10000326 	beq	r2,zero,81146754 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81146748:	11442200 	call	81144220 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8114674c:	e0bffe17 	ldw	r2,-8(fp)
81146750:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81146754:	e0bffd8b 	ldhu	r2,-10(fp)
81146758:	10bfffcc 	andi	r2,r2,65535
8114675c:	10bffe0c 	andi	r2,r2,65528
81146760:	e0bff915 	stw	r2,-28(fp)
81146764:	00000206 	br	81146770 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81146768:	00bfffc4 	movi	r2,-1
8114676c:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81146770:	e0bff917 	ldw	r2,-28(fp)
81146774:	00fffdd4 	movui	r3,65527
81146778:	18800316 	blt	r3,r2,81146788 <find_first_empty_record_in_a_subdirectory+0x23c>
8114677c:	e0bff817 	ldw	r2,-32(fp)
81146780:	10bfffe0 	cmpeqi	r2,r2,-1
81146784:	103f7c1e 	bne	r2,zero,81146578 <__reset+0xfb126578>
    return result; 
81146788:	e0bff817 	ldw	r2,-32(fp)
}
8114678c:	e037883a 	mov	sp,fp
81146790:	dfc00117 	ldw	ra,4(sp)
81146794:	df000017 	ldw	fp,0(sp)
81146798:	dec00204 	addi	sp,sp,8
8114679c:	f800283a 	ret

811467a0 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
811467a0:	defff904 	addi	sp,sp,-28
811467a4:	de00012e 	bgeu	sp,et,811467ac <find_first_empty_record_in_root_directory+0xc>
811467a8:	003b68fa 	trap	3
811467ac:	dfc00615 	stw	ra,24(sp)
811467b0:	df000515 	stw	fp,20(sp)
811467b4:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811467b8:	00a045f4 	movhi	r2,33047
811467bc:	10bb9404 	addi	r2,r2,-4528
811467c0:	1080050b 	ldhu	r2,20(r2)
811467c4:	10bfffcc 	andi	r2,r2,65535
811467c8:	1006917a 	slli	r3,r2,5
811467cc:	00a045f4 	movhi	r2,33047
811467d0:	10bb9404 	addi	r2,r2,-4528
811467d4:	1080030b 	ldhu	r2,12(r2)
811467d8:	10bfffcc 	andi	r2,r2,65535
811467dc:	1885283a 	div	r2,r3,r2
811467e0:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
811467e4:	00bfffc4 	movi	r2,-1
811467e8:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811467ec:	e03ffb15 	stw	zero,-20(fp)
811467f0:	00002d06 	br	811468a8 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811467f4:	00a045f4 	movhi	r2,33047
811467f8:	10bb9404 	addi	r2,r2,-4528
811467fc:	10c01317 	ldw	r3,76(r2)
81146800:	e0bffb17 	ldw	r2,-20(fp)
81146804:	1885883a 	add	r2,r3,r2
81146808:	1007883a 	mov	r3,r2
8114680c:	d0a0b117 	ldw	r2,-32060(gp)
81146810:	100b883a 	mov	r5,r2
81146814:	1809883a 	mov	r4,r3
81146818:	11442740 	call	81144274 <Read_Sector_Data>
8114681c:	10002626 	beq	r2,zero,811468b8 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81146820:	e03ffc15 	stw	zero,-16(fp)
81146824:	00001a06 	br	81146890 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81146828:	e0bffc17 	ldw	r2,-16(fp)
8114682c:	1004917a 	slli	r2,r2,5
81146830:	1007883a 	mov	r3,r2
81146834:	d0a0b317 	ldw	r2,-32052(gp)
81146838:	10800a17 	ldw	r2,40(r2)
8114683c:	1885883a 	add	r2,r3,r2
81146840:	10800023 	ldbuio	r2,0(r2)
81146844:	10803fcc 	andi	r2,r2,255
81146848:	10803fcc 	andi	r2,r2,255
8114684c:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81146850:	e0bfff0b 	ldhu	r2,-4(fp)
81146854:	10803960 	cmpeqi	r2,r2,229
81146858:	1000021e 	bne	r2,zero,81146864 <find_first_empty_record_in_root_directory+0xc4>
8114685c:	e0bfff0b 	ldhu	r2,-4(fp)
81146860:	1000081e 	bne	r2,zero,81146884 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81146864:	e0bffb17 	ldw	r2,-20(fp)
81146868:	1006913a 	slli	r3,r2,4
8114686c:	e0bffc17 	ldw	r2,-16(fp)
81146870:	1885883a 	add	r2,r3,r2
81146874:	1004943a 	slli	r2,r2,16
81146878:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8114687c:	e0bffe17 	ldw	r2,-8(fp)
81146880:	00000f06 	br	811468c0 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81146884:	e0bffc17 	ldw	r2,-16(fp)
81146888:	10800044 	addi	r2,r2,1
8114688c:	e0bffc15 	stw	r2,-16(fp)
81146890:	e0bffc17 	ldw	r2,-16(fp)
81146894:	10800410 	cmplti	r2,r2,16
81146898:	103fe31e 	bne	r2,zero,81146828 <__reset+0xfb126828>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8114689c:	e0bffb17 	ldw	r2,-20(fp)
811468a0:	10800044 	addi	r2,r2,1
811468a4:	e0bffb15 	stw	r2,-20(fp)
811468a8:	e0fffb17 	ldw	r3,-20(fp)
811468ac:	e0bffd17 	ldw	r2,-12(fp)
811468b0:	18bfd016 	blt	r3,r2,811467f4 <__reset+0xfb1267f4>
811468b4:	00000106 	br	811468bc <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
811468b8:	0001883a 	nop
        }
    }
    return result;
811468bc:	e0bffe17 	ldw	r2,-8(fp)
}
811468c0:	e037883a 	mov	sp,fp
811468c4:	dfc00117 	ldw	ra,4(sp)
811468c8:	df000017 	ldw	fp,0(sp)
811468cc:	dec00204 	addi	sp,sp,8
811468d0:	f800283a 	ret

811468d4 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
811468d4:	defffa04 	addi	sp,sp,-24
811468d8:	de00012e 	bgeu	sp,et,811468e0 <convert_filename_to_name_extension+0xc>
811468dc:	003b68fa 	trap	3
811468e0:	df000515 	stw	fp,20(sp)
811468e4:	df000504 	addi	fp,sp,20
811468e8:	e13ffd15 	stw	r4,-12(fp)
811468ec:	e17ffe15 	stw	r5,-8(fp)
811468f0:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
811468f4:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
811468f8:	e03ffb15 	stw	zero,-20(fp)
811468fc:	00002506 	br	81146994 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
81146900:	e0bffc17 	ldw	r2,-16(fp)
81146904:	e0fffd17 	ldw	r3,-12(fp)
81146908:	1885883a 	add	r2,r3,r2
8114690c:	10800003 	ldbu	r2,0(r2)
81146910:	10803fcc 	andi	r2,r2,255
81146914:	1080201c 	xori	r2,r2,128
81146918:	10bfe004 	addi	r2,r2,-128
8114691c:	10800ba0 	cmpeqi	r2,r2,46
81146920:	1000141e 	bne	r2,zero,81146974 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81146924:	e0bffb17 	ldw	r2,-20(fp)
81146928:	e0fffe17 	ldw	r3,-8(fp)
8114692c:	1885883a 	add	r2,r3,r2
81146930:	e0fffc17 	ldw	r3,-16(fp)
81146934:	e13ffd17 	ldw	r4,-12(fp)
81146938:	20c7883a 	add	r3,r4,r3
8114693c:	18c00003 	ldbu	r3,0(r3)
81146940:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81146944:	e0bffc17 	ldw	r2,-16(fp)
81146948:	e0fffd17 	ldw	r3,-12(fp)
8114694c:	1885883a 	add	r2,r3,r2
81146950:	10800003 	ldbu	r2,0(r2)
81146954:	10803fcc 	andi	r2,r2,255
81146958:	1080201c 	xori	r2,r2,128
8114695c:	10bfe004 	addi	r2,r2,-128
81146960:	10000926 	beq	r2,zero,81146988 <convert_filename_to_name_extension+0xb4>
81146964:	e0bffc17 	ldw	r2,-16(fp)
81146968:	10800044 	addi	r2,r2,1
8114696c:	e0bffc15 	stw	r2,-16(fp)
81146970:	00000506 	br	81146988 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81146974:	e0bffb17 	ldw	r2,-20(fp)
81146978:	e0fffe17 	ldw	r3,-8(fp)
8114697c:	1885883a 	add	r2,r3,r2
81146980:	00c00804 	movi	r3,32
81146984:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81146988:	e0bffb17 	ldw	r2,-20(fp)
8114698c:	10800044 	addi	r2,r2,1
81146990:	e0bffb15 	stw	r2,-20(fp)
81146994:	e0bffb17 	ldw	r2,-20(fp)
81146998:	10800210 	cmplti	r2,r2,8
8114699c:	103fd81e 	bne	r2,zero,81146900 <__reset+0xfb126900>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
811469a0:	e0bffc17 	ldw	r2,-16(fp)
811469a4:	e0fffd17 	ldw	r3,-12(fp)
811469a8:	1885883a 	add	r2,r3,r2
811469ac:	10800003 	ldbu	r2,0(r2)
811469b0:	10803fcc 	andi	r2,r2,255
811469b4:	1080201c 	xori	r2,r2,128
811469b8:	10bfe004 	addi	r2,r2,-128
811469bc:	10800b98 	cmpnei	r2,r2,46
811469c0:	1000031e 	bne	r2,zero,811469d0 <convert_filename_to_name_extension+0xfc>
811469c4:	e0bffc17 	ldw	r2,-16(fp)
811469c8:	10800044 	addi	r2,r2,1
811469cc:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
811469d0:	e03ffb15 	stw	zero,-20(fp)
811469d4:	00001c06 	br	81146a48 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
811469d8:	e0bffc17 	ldw	r2,-16(fp)
811469dc:	e0fffd17 	ldw	r3,-12(fp)
811469e0:	1885883a 	add	r2,r3,r2
811469e4:	10800003 	ldbu	r2,0(r2)
811469e8:	10803fcc 	andi	r2,r2,255
811469ec:	1080201c 	xori	r2,r2,128
811469f0:	10bfe004 	addi	r2,r2,-128
811469f4:	10000c26 	beq	r2,zero,81146a28 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
811469f8:	e0bffb17 	ldw	r2,-20(fp)
811469fc:	e0ffff17 	ldw	r3,-4(fp)
81146a00:	1885883a 	add	r2,r3,r2
81146a04:	e0fffc17 	ldw	r3,-16(fp)
81146a08:	e13ffd17 	ldw	r4,-12(fp)
81146a0c:	20c7883a 	add	r3,r4,r3
81146a10:	18c00003 	ldbu	r3,0(r3)
81146a14:	10c00005 	stb	r3,0(r2)
            local++;
81146a18:	e0bffc17 	ldw	r2,-16(fp)
81146a1c:	10800044 	addi	r2,r2,1
81146a20:	e0bffc15 	stw	r2,-16(fp)
81146a24:	00000506 	br	81146a3c <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81146a28:	e0bffb17 	ldw	r2,-20(fp)
81146a2c:	e0ffff17 	ldw	r3,-4(fp)
81146a30:	1885883a 	add	r2,r3,r2
81146a34:	00c00804 	movi	r3,32
81146a38:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81146a3c:	e0bffb17 	ldw	r2,-20(fp)
81146a40:	10800044 	addi	r2,r2,1
81146a44:	e0bffb15 	stw	r2,-20(fp)
81146a48:	e0bffb17 	ldw	r2,-20(fp)
81146a4c:	108000d0 	cmplti	r2,r2,3
81146a50:	103fe11e 	bne	r2,zero,811469d8 <__reset+0xfb1269d8>
        {
            extension[counter] = ' ';
        }
    }

}
81146a54:	0001883a 	nop
81146a58:	e037883a 	mov	sp,fp
81146a5c:	df000017 	ldw	fp,0(sp)
81146a60:	dec00104 	addi	sp,sp,4
81146a64:	f800283a 	ret

81146a68 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81146a68:	defff504 	addi	sp,sp,-44
81146a6c:	de00012e 	bgeu	sp,et,81146a74 <create_file+0xc>
81146a70:	003b68fa 	trap	3
81146a74:	dfc00a15 	stw	ra,40(sp)
81146a78:	df000915 	stw	fp,36(sp)
81146a7c:	df000904 	addi	fp,sp,36
81146a80:	e13ffd15 	stw	r4,-12(fp)
81146a84:	e17ffe15 	stw	r5,-8(fp)
81146a88:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81146a8c:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81146a90:	e0bffc04 	addi	r2,fp,-16
81146a94:	1009883a 	mov	r4,r2
81146a98:	11463980 	call	81146398 <find_first_empty_cluster>
81146a9c:	1000a026 	beq	r2,zero,81146d20 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81146aa0:	e0bfff17 	ldw	r2,-4(fp)
81146aa4:	10800a17 	ldw	r2,40(r2)
81146aa8:	1000031e 	bne	r2,zero,81146ab8 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81146aac:	11467a00 	call	811467a0 <find_first_empty_record_in_root_directory>
81146ab0:	e0bff815 	stw	r2,-32(fp)
81146ab4:	00000606 	br	81146ad0 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81146ab8:	e0bfff17 	ldw	r2,-4(fp)
81146abc:	1080058b 	ldhu	r2,22(r2)
81146ac0:	10bfffcc 	andi	r2,r2,65535
81146ac4:	1009883a 	mov	r4,r2
81146ac8:	114654c0 	call	8114654c <find_first_empty_record_in_a_subdirectory>
81146acc:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81146ad0:	e0bff817 	ldw	r2,-32(fp)
81146ad4:	10009216 	blt	r2,zero,81146d20 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81146ad8:	e13ffd17 	ldw	r4,-12(fp)
81146adc:	11456780 	call	81145678 <get_dir_divider_location>
81146ae0:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81146ae4:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81146ae8:	00000b06 	br	81146b18 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81146aec:	e0fffa17 	ldw	r3,-24(fp)
81146af0:	e0bff917 	ldw	r2,-28(fp)
81146af4:	1885883a 	add	r2,r3,r2
81146af8:	10800044 	addi	r2,r2,1
81146afc:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81146b00:	e0bffa17 	ldw	r2,-24(fp)
81146b04:	e0fffd17 	ldw	r3,-12(fp)
81146b08:	1885883a 	add	r2,r3,r2
81146b0c:	1009883a 	mov	r4,r2
81146b10:	11456780 	call	81145678 <get_dir_divider_location>
81146b14:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81146b18:	e0bff917 	ldw	r2,-28(fp)
81146b1c:	00bff316 	blt	zero,r2,81146aec <__reset+0xfb126aec>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81146b20:	e0bffa17 	ldw	r2,-24(fp)
81146b24:	e0fffd17 	ldw	r3,-12(fp)
81146b28:	1887883a 	add	r3,r3,r2
81146b2c:	e13ffe17 	ldw	r4,-8(fp)
81146b30:	e0bffe17 	ldw	r2,-8(fp)
81146b34:	10800204 	addi	r2,r2,8
81146b38:	100d883a 	mov	r6,r2
81146b3c:	200b883a 	mov	r5,r4
81146b40:	1809883a 	mov	r4,r3
81146b44:	11468d40 	call	811468d4 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81146b48:	e0bffe17 	ldw	r2,-8(fp)
81146b4c:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81146b50:	e0bffe17 	ldw	r2,-8(fp)
81146b54:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81146b58:	e0bffe17 	ldw	r2,-8(fp)
81146b5c:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81146b60:	e0bffe17 	ldw	r2,-8(fp)
81146b64:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81146b68:	e0bffe17 	ldw	r2,-8(fp)
81146b6c:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81146b70:	e0bffe17 	ldw	r2,-8(fp)
81146b74:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81146b78:	e0bffc17 	ldw	r2,-16(fp)
81146b7c:	1007883a 	mov	r3,r2
81146b80:	e0bffe17 	ldw	r2,-8(fp)
81146b84:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81146b88:	e0bffe17 	ldw	r2,-8(fp)
81146b8c:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81146b90:	e0fffc17 	ldw	r3,-16(fp)
81146b94:	e0bffe17 	ldw	r2,-8(fp)
81146b98:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81146b9c:	e0bffe17 	ldw	r2,-8(fp)
81146ba0:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81146ba4:	e0bffe17 	ldw	r2,-8(fp)
81146ba8:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81146bac:	e0bff817 	ldw	r2,-32(fp)
81146bb0:	10ffffcc 	andi	r3,r2,65535
81146bb4:	e0bffe17 	ldw	r2,-8(fp)
81146bb8:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81146bbc:	e0bff817 	ldw	r2,-32(fp)
81146bc0:	1004d43a 	srli	r2,r2,16
81146bc4:	1000010e 	bge	r2,zero,81146bcc <create_file+0x164>
81146bc8:	108003c4 	addi	r2,r2,15
81146bcc:	1005d13a 	srai	r2,r2,4
81146bd0:	1007883a 	mov	r3,r2
81146bd4:	e0bffe17 	ldw	r2,-8(fp)
81146bd8:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81146bdc:	e0bff817 	ldw	r2,-32(fp)
81146be0:	1004d43a 	srli	r2,r2,16
81146be4:	1007883a 	mov	r3,r2
81146be8:	00a00034 	movhi	r2,32768
81146bec:	108003c4 	addi	r2,r2,15
81146bf0:	1884703a 	and	r2,r3,r2
81146bf4:	1000040e 	bge	r2,zero,81146c08 <create_file+0x1a0>
81146bf8:	10bfffc4 	addi	r2,r2,-1
81146bfc:	00fffc04 	movi	r3,-16
81146c00:	10c4b03a 	or	r2,r2,r3
81146c04:	10800044 	addi	r2,r2,1
81146c08:	1004917a 	slli	r2,r2,5
81146c0c:	1007883a 	mov	r3,r2
81146c10:	e0bffe17 	ldw	r2,-8(fp)
81146c14:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81146c18:	e0bfff17 	ldw	r2,-4(fp)
81146c1c:	1080058b 	ldhu	r2,22(r2)
81146c20:	10ffffcc 	andi	r3,r2,65535
81146c24:	e0bffe17 	ldw	r2,-8(fp)
81146c28:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81146c2c:	e0bffe17 	ldw	r2,-8(fp)
81146c30:	00c00044 	movi	r3,1
81146c34:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81146c38:	e0bffe17 	ldw	r2,-8(fp)
81146c3c:	00c00044 	movi	r3,1
81146c40:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81146c44:	e0bffe17 	ldw	r2,-8(fp)
81146c48:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81146c4c:	1000071e 	bne	r2,zero,81146c6c <create_file+0x204>
81146c50:	00a045f4 	movhi	r2,33047
81146c54:	10bb9404 	addi	r2,r2,-4528
81146c58:	10c01317 	ldw	r3,76(r2)
81146c5c:	e0bffe17 	ldw	r2,-8(fp)
81146c60:	10800b17 	ldw	r2,44(r2)
81146c64:	1885883a 	add	r2,r3,r2
81146c68:	00000f06 	br	81146ca8 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81146c6c:	00a045f4 	movhi	r2,33047
81146c70:	10bb9404 	addi	r2,r2,-4528
81146c74:	10c01417 	ldw	r3,80(r2)
81146c78:	e0bffe17 	ldw	r2,-8(fp)
81146c7c:	10800a17 	ldw	r2,40(r2)
81146c80:	113fff84 	addi	r4,r2,-2
81146c84:	00a045f4 	movhi	r2,33047
81146c88:	10bb9404 	addi	r2,r2,-4528
81146c8c:	10800383 	ldbu	r2,14(r2)
81146c90:	10803fcc 	andi	r2,r2,255
81146c94:	2085383a 	mul	r2,r4,r2
81146c98:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81146c9c:	e0bffe17 	ldw	r2,-8(fp)
81146ca0:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81146ca4:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81146ca8:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81146cac:	e0bffb17 	ldw	r2,-20(fp)
81146cb0:	d0e0b117 	ldw	r3,-32060(gp)
81146cb4:	180b883a 	mov	r5,r3
81146cb8:	1009883a 	mov	r4,r2
81146cbc:	11442740 	call	81144274 <Read_Sector_Data>
81146cc0:	10001726 	beq	r2,zero,81146d20 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81146cc4:	e0bffe17 	ldw	r2,-8(fp)
81146cc8:	10800c0b 	ldhu	r2,48(r2)
81146ccc:	10bfffcc 	andi	r2,r2,65535
81146cd0:	10a0001c 	xori	r2,r2,32768
81146cd4:	10a00004 	addi	r2,r2,-32768
81146cd8:	e17ffe17 	ldw	r5,-8(fp)
81146cdc:	1009883a 	mov	r4,r2
81146ce0:	11449280 	call	81144928 <Write_File_Record_At_Offset>
81146ce4:	10000e26 	beq	r2,zero,81146d20 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81146ce8:	11442200 	call	81144220 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81146cec:	e0bffc17 	ldw	r2,-16(fp)
81146cf0:	01800044 	movi	r6,1
81146cf4:	017fffc4 	movi	r5,-1
81146cf8:	1009883a 	mov	r4,r2
81146cfc:	11444100 	call	81144410 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81146d00:	e0bffc17 	ldw	r2,-16(fp)
81146d04:	000d883a 	mov	r6,zero
81146d08:	017fffc4 	movi	r5,-1
81146d0c:	1009883a 	mov	r4,r2
81146d10:	11444100 	call	81144410 <mark_cluster>
81146d14:	10000226 	beq	r2,zero,81146d20 <create_file+0x2b8>
                    {
                        result = true;
81146d18:	00800044 	movi	r2,1
81146d1c:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81146d20:	e0bff717 	ldw	r2,-36(fp)
}
81146d24:	e037883a 	mov	sp,fp
81146d28:	dfc00117 	ldw	ra,4(sp)
81146d2c:	df000017 	ldw	fp,0(sp)
81146d30:	dec00204 	addi	sp,sp,8
81146d34:	f800283a 	ret

81146d38 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81146d38:	defffb04 	addi	sp,sp,-20
81146d3c:	de00012e 	bgeu	sp,et,81146d44 <copy_file_record_name_to_string+0xc>
81146d40:	003b68fa 	trap	3
81146d44:	df000415 	stw	fp,16(sp)
81146d48:	df000404 	addi	fp,sp,16
81146d4c:	e13ffe15 	stw	r4,-8(fp)
81146d50:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81146d54:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81146d58:	e03ffc15 	stw	zero,-16(fp)
81146d5c:	00001506 	br	81146db4 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81146d60:	e0fffe17 	ldw	r3,-8(fp)
81146d64:	e0bffc17 	ldw	r2,-16(fp)
81146d68:	1885883a 	add	r2,r3,r2
81146d6c:	10800003 	ldbu	r2,0(r2)
81146d70:	10803fcc 	andi	r2,r2,255
81146d74:	10800820 	cmpeqi	r2,r2,32
81146d78:	10000b1e 	bne	r2,zero,81146da8 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81146d7c:	e0bffd17 	ldw	r2,-12(fp)
81146d80:	e0ffff17 	ldw	r3,-4(fp)
81146d84:	1885883a 	add	r2,r3,r2
81146d88:	e13ffe17 	ldw	r4,-8(fp)
81146d8c:	e0fffc17 	ldw	r3,-16(fp)
81146d90:	20c7883a 	add	r3,r4,r3
81146d94:	18c00003 	ldbu	r3,0(r3)
81146d98:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81146d9c:	e0bffd17 	ldw	r2,-12(fp)
81146da0:	10800044 	addi	r2,r2,1
81146da4:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81146da8:	e0bffc17 	ldw	r2,-16(fp)
81146dac:	10800044 	addi	r2,r2,1
81146db0:	e0bffc15 	stw	r2,-16(fp)
81146db4:	e0bffc17 	ldw	r2,-16(fp)
81146db8:	10800210 	cmplti	r2,r2,8
81146dbc:	103fe81e 	bne	r2,zero,81146d60 <__reset+0xfb126d60>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81146dc0:	e0bffe17 	ldw	r2,-8(fp)
81146dc4:	10800203 	ldbu	r2,8(r2)
81146dc8:	10803fcc 	andi	r2,r2,255
81146dcc:	10800820 	cmpeqi	r2,r2,32
81146dd0:	1000241e 	bne	r2,zero,81146e64 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81146dd4:	e0bffd17 	ldw	r2,-12(fp)
81146dd8:	e0ffff17 	ldw	r3,-4(fp)
81146ddc:	1885883a 	add	r2,r3,r2
81146de0:	00c00b84 	movi	r3,46
81146de4:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81146de8:	e0bffd17 	ldw	r2,-12(fp)
81146dec:	10800044 	addi	r2,r2,1
81146df0:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81146df4:	e03ffc15 	stw	zero,-16(fp)
81146df8:	00001706 	br	81146e58 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81146dfc:	e0fffe17 	ldw	r3,-8(fp)
81146e00:	e0bffc17 	ldw	r2,-16(fp)
81146e04:	1885883a 	add	r2,r3,r2
81146e08:	10800204 	addi	r2,r2,8
81146e0c:	10800003 	ldbu	r2,0(r2)
81146e10:	10803fcc 	andi	r2,r2,255
81146e14:	10800820 	cmpeqi	r2,r2,32
81146e18:	10000c1e 	bne	r2,zero,81146e4c <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81146e1c:	e0bffd17 	ldw	r2,-12(fp)
81146e20:	e0ffff17 	ldw	r3,-4(fp)
81146e24:	1885883a 	add	r2,r3,r2
81146e28:	e13ffe17 	ldw	r4,-8(fp)
81146e2c:	e0fffc17 	ldw	r3,-16(fp)
81146e30:	20c7883a 	add	r3,r4,r3
81146e34:	18c00204 	addi	r3,r3,8
81146e38:	18c00003 	ldbu	r3,0(r3)
81146e3c:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81146e40:	e0bffd17 	ldw	r2,-12(fp)
81146e44:	10800044 	addi	r2,r2,1
81146e48:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81146e4c:	e0bffc17 	ldw	r2,-16(fp)
81146e50:	10800044 	addi	r2,r2,1
81146e54:	e0bffc15 	stw	r2,-16(fp)
81146e58:	e0bffc17 	ldw	r2,-16(fp)
81146e5c:	108000d0 	cmplti	r2,r2,3
81146e60:	103fe61e 	bne	r2,zero,81146dfc <__reset+0xfb126dfc>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81146e64:	e0bffd17 	ldw	r2,-12(fp)
81146e68:	e0ffff17 	ldw	r3,-4(fp)
81146e6c:	1885883a 	add	r2,r3,r2
81146e70:	10000005 	stb	zero,0(r2)
}
81146e74:	0001883a 	nop
81146e78:	e037883a 	mov	sp,fp
81146e7c:	df000017 	ldw	fp,0(sp)
81146e80:	dec00104 	addi	sp,sp,4
81146e84:	f800283a 	ret

81146e88 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81146e88:	defffc04 	addi	sp,sp,-16
81146e8c:	de00012e 	bgeu	sp,et,81146e94 <alt_up_sd_card_open_dev+0xc>
81146e90:	003b68fa 	trap	3
81146e94:	dfc00315 	stw	ra,12(sp)
81146e98:	df000215 	stw	fp,8(sp)
81146e9c:	df000204 	addi	fp,sp,8
81146ea0:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81146ea4:	d1600d04 	addi	r5,gp,-32716
81146ea8:	e13fff17 	ldw	r4,-4(fp)
81146eac:	114c3440 	call	8114c344 <alt_find_dev>
81146eb0:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81146eb4:	e0bffe17 	ldw	r2,-8(fp)
81146eb8:	10001e26 	beq	r2,zero,81146f34 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81146ebc:	e0bffe17 	ldw	r2,-8(fp)
81146ec0:	10800a17 	ldw	r2,40(r2)
81146ec4:	10808d04 	addi	r2,r2,564
81146ec8:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81146ecc:	e0bffe17 	ldw	r2,-8(fp)
81146ed0:	10800a17 	ldw	r2,40(r2)
81146ed4:	10808904 	addi	r2,r2,548
81146ed8:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81146edc:	e0bffe17 	ldw	r2,-8(fp)
81146ee0:	10800a17 	ldw	r2,40(r2)
81146ee4:	10808404 	addi	r2,r2,528
81146ee8:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81146eec:	e0bffe17 	ldw	r2,-8(fp)
81146ef0:	10800a17 	ldw	r2,40(r2)
81146ef4:	10808c04 	addi	r2,r2,560
81146ef8:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81146efc:	e0bffe17 	ldw	r2,-8(fp)
81146f00:	10800a17 	ldw	r2,40(r2)
81146f04:	10808b04 	addi	r2,r2,556
81146f08:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81146f0c:	e0bffe17 	ldw	r2,-8(fp)
81146f10:	10800a17 	ldw	r2,40(r2)
81146f14:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
81146f18:	e0bffe17 	ldw	r2,-8(fp)
81146f1c:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
81146f20:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81146f24:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
81146f28:	00a045f4 	movhi	r2,33047
81146f2c:	10bb8f04 	addi	r2,r2,-4548
81146f30:	10000415 	stw	zero,16(r2)
	}
	return dev;
81146f34:	e0bffe17 	ldw	r2,-8(fp)
}
81146f38:	e037883a 	mov	sp,fp
81146f3c:	dfc00117 	ldw	ra,4(sp)
81146f40:	df000017 	ldw	fp,0(sp)
81146f44:	dec00204 	addi	sp,sp,8
81146f48:	f800283a 	ret

81146f4c <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81146f4c:	defffd04 	addi	sp,sp,-12
81146f50:	de00012e 	bgeu	sp,et,81146f58 <alt_up_sd_card_is_Present+0xc>
81146f54:	003b68fa 	trap	3
81146f58:	df000215 	stw	fp,8(sp)
81146f5c:	df000204 	addi	fp,sp,8
    bool result = false;
81146f60:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81146f64:	d0a0b317 	ldw	r2,-32052(gp)
81146f68:	10000826 	beq	r2,zero,81146f8c <alt_up_sd_card_is_Present+0x40>
81146f6c:	d0a0ab17 	ldw	r2,-32084(gp)
81146f70:	1080002b 	ldhuio	r2,0(r2)
81146f74:	10bfffcc 	andi	r2,r2,65535
81146f78:	1080008c 	andi	r2,r2,2
81146f7c:	10000326 	beq	r2,zero,81146f8c <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81146f80:	00800044 	movi	r2,1
81146f84:	e0bffe15 	stw	r2,-8(fp)
81146f88:	00001e06 	br	81147004 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81146f8c:	d0a0a917 	ldw	r2,-32092(gp)
81146f90:	10800058 	cmpnei	r2,r2,1
81146f94:	10001b1e 	bne	r2,zero,81147004 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81146f98:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81146f9c:	00a045f4 	movhi	r2,33047
81146fa0:	10bb8f04 	addi	r2,r2,-4548
81146fa4:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81146fa8:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81146fac:	e03fff15 	stw	zero,-4(fp)
81146fb0:	00001106 	br	81146ff8 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81146fb4:	00a045f4 	movhi	r2,33047
81146fb8:	10bba904 	addi	r2,r2,-4444
81146fbc:	e0ffff17 	ldw	r3,-4(fp)
81146fc0:	180691ba 	slli	r3,r3,6
81146fc4:	10c5883a 	add	r2,r2,r3
81146fc8:	10800f04 	addi	r2,r2,60
81146fcc:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81146fd0:	00a045f4 	movhi	r2,33047
81146fd4:	10bba904 	addi	r2,r2,-4444
81146fd8:	e0ffff17 	ldw	r3,-4(fp)
81146fdc:	180691ba 	slli	r3,r3,6
81146fe0:	10c5883a 	add	r2,r2,r3
81146fe4:	10800e04 	addi	r2,r2,56
81146fe8:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81146fec:	e0bfff17 	ldw	r2,-4(fp)
81146ff0:	10800044 	addi	r2,r2,1
81146ff4:	e0bfff15 	stw	r2,-4(fp)
81146ff8:	e0bfff17 	ldw	r2,-4(fp)
81146ffc:	10800510 	cmplti	r2,r2,20
81147000:	103fec1e 	bne	r2,zero,81146fb4 <__reset+0xfb126fb4>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81147004:	e0bffe17 	ldw	r2,-8(fp)
}
81147008:	e037883a 	mov	sp,fp
8114700c:	df000017 	ldw	fp,0(sp)
81147010:	dec00104 	addi	sp,sp,4
81147014:	f800283a 	ret

81147018 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81147018:	defffd04 	addi	sp,sp,-12
8114701c:	de00012e 	bgeu	sp,et,81147024 <alt_up_sd_card_is_FAT16+0xc>
81147020:	003b68fa 	trap	3
81147024:	dfc00215 	stw	ra,8(sp)
81147028:	df000115 	stw	fp,4(sp)
8114702c:	df000104 	addi	fp,sp,4
	bool result = false;
81147030:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81147034:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
81147038:	10000c26 	beq	r2,zero,8114706c <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8114703c:	d0a0a917 	ldw	r2,-32092(gp)
81147040:	1000071e 	bne	r2,zero,81147060 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81147044:	11452440 	call	81145244 <Look_for_FAT16>
81147048:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
8114704c:	d0a0aa17 	ldw	r2,-32088(gp)
81147050:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
81147054:	00a045f4 	movhi	r2,33047
81147058:	10bb8f04 	addi	r2,r2,-4548
8114705c:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81147060:	d0a0aa17 	ldw	r2,-32088(gp)
81147064:	e0bfff15 	stw	r2,-4(fp)
81147068:	00000206 	br	81147074 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8114706c:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81147070:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
81147074:	e0bfff17 	ldw	r2,-4(fp)
}
81147078:	e037883a 	mov	sp,fp
8114707c:	dfc00117 	ldw	ra,4(sp)
81147080:	df000017 	ldw	fp,0(sp)
81147084:	dec00204 	addi	sp,sp,8
81147088:	f800283a 	ret

8114708c <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8114708c:	deffea04 	addi	sp,sp,-88
81147090:	de00012e 	bgeu	sp,et,81147098 <alt_up_sd_card_find_first+0xc>
81147094:	003b68fa 	trap	3
81147098:	dfc01515 	stw	ra,84(sp)
8114709c:	df001415 	stw	fp,80(sp)
811470a0:	df001404 	addi	fp,sp,80
811470a4:	e13ffe15 	stw	r4,-8(fp)
811470a8:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
811470ac:	00800084 	movi	r2,2
811470b0:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811470b4:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
811470b8:	10002426 	beq	r2,zero,8114714c <alt_up_sd_card_find_first+0xc0>
811470bc:	d0a0aa17 	ldw	r2,-32088(gp)
811470c0:	10002226 	beq	r2,zero,8114714c <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
811470c4:	e0ffee04 	addi	r3,fp,-72
811470c8:	e0bfed04 	addi	r2,fp,-76
811470cc:	180d883a 	mov	r6,r3
811470d0:	100b883a 	mov	r5,r2
811470d4:	e13ffe17 	ldw	r4,-8(fp)
811470d8:	11459dc0 	call	811459dc <get_home_directory_cluster_for_file>
811470dc:	10001926 	beq	r2,zero,81147144 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811470e0:	e0bfed17 	ldw	r2,-76(fp)
811470e4:	1007883a 	mov	r3,r2
811470e8:	00a045f4 	movhi	r2,33047
811470ec:	10bb8f04 	addi	r2,r2,-4548
811470f0:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
811470f4:	e0bfed17 	ldw	r2,-76(fp)
811470f8:	1007883a 	mov	r3,r2
811470fc:	00a045f4 	movhi	r2,33047
81147100:	10bb8f04 	addi	r2,r2,-4548
81147104:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81147108:	00a045f4 	movhi	r2,33047
8114710c:	10bb8f04 	addi	r2,r2,-4548
81147110:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81147114:	00a045f4 	movhi	r2,33047
81147118:	10bb8f04 	addi	r2,r2,-4548
8114711c:	00ffffc4 	movi	r3,-1
81147120:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81147124:	00a045f4 	movhi	r2,33047
81147128:	10bb8f04 	addi	r2,r2,-4548
8114712c:	00c00044 	movi	r3,1
81147130:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81147134:	e13fff17 	ldw	r4,-4(fp)
81147138:	11471640 	call	81147164 <alt_up_sd_card_find_next>
8114713c:	e0bfec0d 	sth	r2,-80(fp)
81147140:	00000206 	br	8114714c <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81147144:	00800044 	movi	r2,1
81147148:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8114714c:	e0bfec0b 	ldhu	r2,-80(fp)
}
81147150:	e037883a 	mov	sp,fp
81147154:	dfc00117 	ldw	ra,4(sp)
81147158:	df000017 	ldw	fp,0(sp)
8114715c:	dec00204 	addi	sp,sp,8
81147160:	f800283a 	ret

81147164 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81147164:	deffe404 	addi	sp,sp,-112
81147168:	de00012e 	bgeu	sp,et,81147170 <alt_up_sd_card_find_next+0xc>
8114716c:	003b68fa 	trap	3
81147170:	dfc01b15 	stw	ra,108(sp)
81147174:	df001a15 	stw	fp,104(sp)
81147178:	df001a04 	addi	fp,sp,104
8114717c:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81147180:	00800084 	movi	r2,2
81147184:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81147188:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
8114718c:	1000df26 	beq	r2,zero,8114750c <alt_up_sd_card_find_next+0x3a8>
81147190:	d0a0aa17 	ldw	r2,-32088(gp)
81147194:	1000dd26 	beq	r2,zero,8114750c <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81147198:	00a045f4 	movhi	r2,33047
8114719c:	10bb8f04 	addi	r2,r2,-4548
811471a0:	10800417 	ldw	r2,16(r2)
811471a4:	1000d726 	beq	r2,zero,81147504 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
811471a8:	00a045f4 	movhi	r2,33047
811471ac:	10bb8f04 	addi	r2,r2,-4548
811471b0:	10800117 	ldw	r2,4(r2)
811471b4:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
811471b8:	e0bfe717 	ldw	r2,-100(fp)
811471bc:	1000561e 	bne	r2,zero,81147318 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811471c0:	00a045f4 	movhi	r2,33047
811471c4:	10bb9404 	addi	r2,r2,-4528
811471c8:	1080050b 	ldhu	r2,20(r2)
811471cc:	10bfffcc 	andi	r2,r2,65535
811471d0:	1006917a 	slli	r3,r2,5
811471d4:	00a045f4 	movhi	r2,33047
811471d8:	10bb9404 	addi	r2,r2,-4528
811471dc:	1080030b 	ldhu	r2,12(r2)
811471e0:	10bfffcc 	andi	r2,r2,65535
811471e4:	1885283a 	div	r2,r3,r2
811471e8:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811471ec:	00a045f4 	movhi	r2,33047
811471f0:	10bb8f04 	addi	r2,r2,-4548
811471f4:	10800217 	ldw	r2,8(r2)
811471f8:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
811471fc:	00a045f4 	movhi	r2,33047
81147200:	10bb8f04 	addi	r2,r2,-4548
81147204:	1080030b 	ldhu	r2,12(r2)
81147208:	10bfffcc 	andi	r2,r2,65535
8114720c:	10a0001c 	xori	r2,r2,32768
81147210:	10a00004 	addi	r2,r2,-32768
81147214:	10800044 	addi	r2,r2,1
81147218:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8114721c:	00003606 	br	811472f8 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81147220:	00a045f4 	movhi	r2,33047
81147224:	10bb9404 	addi	r2,r2,-4528
81147228:	10c01317 	ldw	r3,76(r2)
8114722c:	e0bfe817 	ldw	r2,-96(fp)
81147230:	1885883a 	add	r2,r3,r2
81147234:	1007883a 	mov	r3,r2
81147238:	d0a0b117 	ldw	r2,-32060(gp)
8114723c:	100b883a 	mov	r5,r2
81147240:	1809883a 	mov	r4,r3
81147244:	11442740 	call	81144274 <Read_Sector_Data>
81147248:	10002f26 	beq	r2,zero,81147308 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8114724c:	00002306 	br	811472dc <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81147250:	e0bfe917 	ldw	r2,-92(fp)
81147254:	1004917a 	slli	r2,r2,5
81147258:	e13fe817 	ldw	r4,-96(fp)
8114725c:	e0ffef04 	addi	r3,fp,-68
81147260:	200f883a 	mov	r7,r4
81147264:	000d883a 	mov	r6,zero
81147268:	180b883a 	mov	r5,r3
8114726c:	1009883a 	mov	r4,r2
81147270:	11446a40 	call	811446a4 <Read_File_Record_At_Offset>
81147274:	10001626 	beq	r2,zero,811472d0 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81147278:	e0bfef03 	ldbu	r2,-68(fp)
8114727c:	10803fcc 	andi	r2,r2,255
81147280:	10001326 	beq	r2,zero,811472d0 <alt_up_sd_card_find_next+0x16c>
81147284:	e0bfef03 	ldbu	r2,-68(fp)
81147288:	10803fcc 	andi	r2,r2,255
8114728c:	10803960 	cmpeqi	r2,r2,229
81147290:	10000f1e 	bne	r2,zero,811472d0 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81147294:	e0bfe917 	ldw	r2,-92(fp)
81147298:	1007883a 	mov	r3,r2
8114729c:	00a045f4 	movhi	r2,33047
811472a0:	10bb8f04 	addi	r2,r2,-4548
811472a4:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
811472a8:	e0ffe817 	ldw	r3,-96(fp)
811472ac:	00a045f4 	movhi	r2,33047
811472b0:	10bb8f04 	addi	r2,r2,-4548
811472b4:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
811472b8:	e0bfef04 	addi	r2,fp,-68
811472bc:	e17fff17 	ldw	r5,-4(fp)
811472c0:	1009883a 	mov	r4,r2
811472c4:	1146d380 	call	81146d38 <copy_file_record_name_to_string>
									return 0;
811472c8:	0005883a 	mov	r2,zero
811472cc:	00009006 	br	81147510 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811472d0:	e0bfe917 	ldw	r2,-92(fp)
811472d4:	10800044 	addi	r2,r2,1
811472d8:	e0bfe915 	stw	r2,-92(fp)
811472dc:	e0bfe917 	ldw	r2,-92(fp)
811472e0:	10800410 	cmplti	r2,r2,16
811472e4:	103fda1e 	bne	r2,zero,81147250 <__reset+0xfb127250>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811472e8:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811472ec:	e0bfe817 	ldw	r2,-96(fp)
811472f0:	10800044 	addi	r2,r2,1
811472f4:	e0bfe815 	stw	r2,-96(fp)
811472f8:	e0ffe817 	ldw	r3,-96(fp)
811472fc:	e0bfec17 	ldw	r2,-80(fp)
81147300:	18bfc716 	blt	r3,r2,81147220 <__reset+0xfb127220>
81147304:	00000106 	br	8114730c <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81147308:	0001883a 	nop
					}
				}
				result = -1;
8114730c:	00bfffc4 	movi	r2,-1
81147310:	e0bfe60d 	sth	r2,-104(fp)
81147314:	00007d06 	br	8114750c <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81147318:	00a045f4 	movhi	r2,33047
8114731c:	10bb8f04 	addi	r2,r2,-4548
81147320:	1080030b 	ldhu	r2,12(r2)
81147324:	10bfffcc 	andi	r2,r2,65535
81147328:	10a0001c 	xori	r2,r2,32768
8114732c:	10a00004 	addi	r2,r2,-32768
81147330:	10800044 	addi	r2,r2,1
81147334:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81147338:	e0bfe717 	ldw	r2,-100(fp)
8114733c:	10ffff84 	addi	r3,r2,-2
81147340:	00a045f4 	movhi	r2,33047
81147344:	10bb9404 	addi	r2,r2,-4528
81147348:	10800383 	ldbu	r2,14(r2)
8114734c:	10803fcc 	andi	r2,r2,255
81147350:	1885383a 	mul	r2,r3,r2
81147354:	1007883a 	mov	r3,r2
81147358:	00a045f4 	movhi	r2,33047
8114735c:	10bb9404 	addi	r2,r2,-4528
81147360:	10801417 	ldw	r2,80(r2)
81147364:	1885883a 	add	r2,r3,r2
81147368:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8114736c:	00a045f4 	movhi	r2,33047
81147370:	10bb8f04 	addi	r2,r2,-4548
81147374:	10800217 	ldw	r2,8(r2)
81147378:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114737c:	00003806 	br	81147460 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81147380:	e0ffeb17 	ldw	r3,-84(fp)
81147384:	e0bfed17 	ldw	r2,-76(fp)
81147388:	1885883a 	add	r2,r3,r2
8114738c:	d0e0b117 	ldw	r3,-32060(gp)
81147390:	180b883a 	mov	r5,r3
81147394:	1009883a 	mov	r4,r2
81147398:	11442740 	call	81144274 <Read_Sector_Data>
8114739c:	10003726 	beq	r2,zero,8114747c <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
811473a0:	00002806 	br	81147444 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
811473a4:	e0bfea17 	ldw	r2,-88(fp)
811473a8:	1004917a 	slli	r2,r2,5
811473ac:	e13fe717 	ldw	r4,-100(fp)
811473b0:	e17feb17 	ldw	r5,-84(fp)
811473b4:	e0ffef04 	addi	r3,fp,-68
811473b8:	280f883a 	mov	r7,r5
811473bc:	200d883a 	mov	r6,r4
811473c0:	180b883a 	mov	r5,r3
811473c4:	1009883a 	mov	r4,r2
811473c8:	11446a40 	call	811446a4 <Read_File_Record_At_Offset>
811473cc:	10001a26 	beq	r2,zero,81147438 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811473d0:	e0bfef03 	ldbu	r2,-68(fp)
811473d4:	10803fcc 	andi	r2,r2,255
811473d8:	10001726 	beq	r2,zero,81147438 <alt_up_sd_card_find_next+0x2d4>
811473dc:	e0bfef03 	ldbu	r2,-68(fp)
811473e0:	10803fcc 	andi	r2,r2,255
811473e4:	10803960 	cmpeqi	r2,r2,229
811473e8:	1000131e 	bne	r2,zero,81147438 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811473ec:	e0ffe717 	ldw	r3,-100(fp)
811473f0:	00a045f4 	movhi	r2,33047
811473f4:	10bb8f04 	addi	r2,r2,-4548
811473f8:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
811473fc:	e0bfea17 	ldw	r2,-88(fp)
81147400:	1007883a 	mov	r3,r2
81147404:	00a045f4 	movhi	r2,33047
81147408:	10bb8f04 	addi	r2,r2,-4548
8114740c:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81147410:	e0ffeb17 	ldw	r3,-84(fp)
81147414:	00a045f4 	movhi	r2,33047
81147418:	10bb8f04 	addi	r2,r2,-4548
8114741c:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81147420:	e0bfef04 	addi	r2,fp,-68
81147424:	e17fff17 	ldw	r5,-4(fp)
81147428:	1009883a 	mov	r4,r2
8114742c:	1146d380 	call	81146d38 <copy_file_record_name_to_string>
										return 0;
81147430:	0005883a 	mov	r2,zero
81147434:	00003606 	br	81147510 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81147438:	e0bfea17 	ldw	r2,-88(fp)
8114743c:	10800044 	addi	r2,r2,1
81147440:	e0bfea15 	stw	r2,-88(fp)
81147444:	e0bfea17 	ldw	r2,-88(fp)
81147448:	10800410 	cmplti	r2,r2,16
8114744c:	103fd51e 	bne	r2,zero,811473a4 <__reset+0xfb1273a4>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81147450:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81147454:	e0bfeb17 	ldw	r2,-84(fp)
81147458:	10800044 	addi	r2,r2,1
8114745c:	e0bfeb15 	stw	r2,-84(fp)
81147460:	00a045f4 	movhi	r2,33047
81147464:	10bb9404 	addi	r2,r2,-4528
81147468:	10800383 	ldbu	r2,14(r2)
8114746c:	10803fcc 	andi	r2,r2,255
81147470:	e0ffeb17 	ldw	r3,-84(fp)
81147474:	18bfc216 	blt	r3,r2,81147380 <__reset+0xfb127380>
81147478:	00000106 	br	81147480 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8114747c:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81147480:	00a045f4 	movhi	r2,33047
81147484:	10bb9404 	addi	r2,r2,-4528
81147488:	10800383 	ldbu	r2,14(r2)
8114748c:	10803fcc 	andi	r2,r2,255
81147490:	e0ffeb17 	ldw	r3,-84(fp)
81147494:	18801716 	blt	r3,r2,811474f4 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81147498:	e0bfe717 	ldw	r2,-100(fp)
8114749c:	e0ffee04 	addi	r3,fp,-72
811474a0:	180b883a 	mov	r5,r3
811474a4:	1009883a 	mov	r4,r2
811474a8:	11443540 	call	81144354 <get_cluster_flag>
811474ac:	10000f26 	beq	r2,zero,811474ec <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811474b0:	e0bfee0b 	ldhu	r2,-72(fp)
811474b4:	10bfffcc 	andi	r2,r2,65535
811474b8:	10fffe0c 	andi	r3,r2,65528
811474bc:	00bffe14 	movui	r2,65528
811474c0:	1880051e 	bne	r3,r2,811474d8 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
811474c4:	00bfffc4 	movi	r2,-1
811474c8:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
811474cc:	00a045f4 	movhi	r2,33047
811474d0:	10bb8f04 	addi	r2,r2,-4548
811474d4:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
811474d8:	e0bfee0b 	ldhu	r2,-72(fp)
811474dc:	10bfffcc 	andi	r2,r2,65535
811474e0:	10bffe0c 	andi	r2,r2,65528
811474e4:	e0bfe715 	stw	r2,-100(fp)
811474e8:	00000206 	br	811474f4 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811474ec:	00bfffc4 	movi	r2,-1
811474f0:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
811474f4:	e0bfe717 	ldw	r2,-100(fp)
811474f8:	00fffdd4 	movui	r3,65527
811474fc:	18bf8e0e 	bge	r3,r2,81147338 <__reset+0xfb127338>
81147500:	00000206 	br	8114750c <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81147504:	008000c4 	movi	r2,3
81147508:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8114750c:	e0bfe60b 	ldhu	r2,-104(fp)
}
81147510:	e037883a 	mov	sp,fp
81147514:	dfc00117 	ldw	ra,4(sp)
81147518:	df000017 	ldw	fp,0(sp)
8114751c:	dec00204 	addi	sp,sp,8
81147520:	f800283a 	ret

81147524 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81147524:	deffe904 	addi	sp,sp,-92
81147528:	de00012e 	bgeu	sp,et,81147530 <alt_up_sd_card_fopen+0xc>
8114752c:	003b68fa 	trap	3
81147530:	dfc01615 	stw	ra,88(sp)
81147534:	df001515 	stw	fp,84(sp)
81147538:	df001504 	addi	fp,sp,84
8114753c:	e13ffe15 	stw	r4,-8(fp)
81147540:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81147544:	00bfffc4 	movi	r2,-1
81147548:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114754c:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
81147550:	1000cf26 	beq	r2,zero,81147890 <alt_up_sd_card_fopen+0x36c>
81147554:	d0a0aa17 	ldw	r2,-32088(gp)
81147558:	1000cd26 	beq	r2,zero,81147890 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8114755c:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81147560:	e13ffe17 	ldw	r4,-8(fp)
81147564:	11453380 	call	81145338 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81147568:	e13ffe17 	ldw	r4,-8(fp)
8114756c:	11454040 	call	81145404 <check_file_name_for_FAT16_compliance>
81147570:	1000c726 	beq	r2,zero,81147890 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81147574:	e0ffee04 	addi	r3,fp,-72
81147578:	e0bfed04 	addi	r2,fp,-76
8114757c:	180d883a 	mov	r6,r3
81147580:	100b883a 	mov	r5,r2
81147584:	e13ffe17 	ldw	r4,-8(fp)
81147588:	11459dc0 	call	811459dc <get_home_directory_cluster_for_file>
8114758c:	1000021e 	bne	r2,zero,81147598 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81147590:	e0bfeb0b 	ldhu	r2,-84(fp)
81147594:	0000bf06 	br	81147894 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81147598:	e03fec15 	stw	zero,-80(fp)
8114759c:	00000e06 	br	811475d8 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
811475a0:	00a045f4 	movhi	r2,33047
811475a4:	10bba904 	addi	r2,r2,-4444
811475a8:	e0ffec17 	ldw	r3,-80(fp)
811475ac:	180691ba 	slli	r3,r3,6
811475b0:	10c5883a 	add	r2,r2,r3
811475b4:	10800f04 	addi	r2,r2,60
811475b8:	10800017 	ldw	r2,0(r2)
811475bc:	1000031e 	bne	r2,zero,811475cc <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
811475c0:	e0bfec17 	ldw	r2,-80(fp)
811475c4:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
811475c8:	00000606 	br	811475e4 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811475cc:	e0bfec17 	ldw	r2,-80(fp)
811475d0:	10800044 	addi	r2,r2,1
811475d4:	e0bfec15 	stw	r2,-80(fp)
811475d8:	e0bfec17 	ldw	r2,-80(fp)
811475dc:	10800510 	cmplti	r2,r2,20
811475e0:	103fef1e 	bne	r2,zero,811475a0 <__reset+0xfb1275a0>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811475e4:	e0bfeb0f 	ldh	r2,-84(fp)
811475e8:	1000a916 	blt	r2,zero,81147890 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811475ec:	e0bfed17 	ldw	r2,-76(fp)
811475f0:	1009883a 	mov	r4,r2
811475f4:	e0bfeb0f 	ldh	r2,-84(fp)
811475f8:	100691ba 	slli	r3,r2,6
811475fc:	00a045f4 	movhi	r2,33047
81147600:	10bba904 	addi	r2,r2,-4444
81147604:	1885883a 	add	r2,r3,r2
81147608:	100d883a 	mov	r6,r2
8114760c:	e17ffe17 	ldw	r5,-8(fp)
81147610:	1145f1c0 	call	81145f1c <find_file_in_directory>
81147614:	10007b26 	beq	r2,zero,81147804 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81147618:	e0bfff17 	ldw	r2,-4(fp)
8114761c:	10000226 	beq	r2,zero,81147628 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81147620:	00bfffc4 	movi	r2,-1
81147624:	00009b06 	br	81147894 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81147628:	e13feb0f 	ldh	r4,-84(fp)
8114762c:	e0ffeb0f 	ldh	r3,-84(fp)
81147630:	00a045f4 	movhi	r2,33047
81147634:	10bba904 	addi	r2,r2,-4444
81147638:	180691ba 	slli	r3,r3,6
8114763c:	10c5883a 	add	r2,r2,r3
81147640:	10800584 	addi	r2,r2,22
81147644:	1080000b 	ldhu	r2,0(r2)
81147648:	10ffffcc 	andi	r3,r2,65535
8114764c:	00a045f4 	movhi	r2,33047
81147650:	10bba904 	addi	r2,r2,-4444
81147654:	200891ba 	slli	r4,r4,6
81147658:	1105883a 	add	r2,r2,r4
8114765c:	10800704 	addi	r2,r2,28
81147660:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81147664:	e0ffeb0f 	ldh	r3,-84(fp)
81147668:	00a045f4 	movhi	r2,33047
8114766c:	10bba904 	addi	r2,r2,-4444
81147670:	180691ba 	slli	r3,r3,6
81147674:	10c5883a 	add	r2,r2,r3
81147678:	10800804 	addi	r2,r2,32
8114767c:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81147680:	e0ffeb0f 	ldh	r3,-84(fp)
81147684:	00a045f4 	movhi	r2,33047
81147688:	10bba904 	addi	r2,r2,-4444
8114768c:	180691ba 	slli	r3,r3,6
81147690:	10c5883a 	add	r2,r2,r3
81147694:	10800904 	addi	r2,r2,36
81147698:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8114769c:	e0ffeb0f 	ldh	r3,-84(fp)
811476a0:	00a045f4 	movhi	r2,33047
811476a4:	10bba904 	addi	r2,r2,-4444
811476a8:	180691ba 	slli	r3,r3,6
811476ac:	10c5883a 	add	r2,r2,r3
811476b0:	10800f04 	addi	r2,r2,60
811476b4:	00c00044 	movi	r3,1
811476b8:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
811476bc:	e0ffeb0f 	ldh	r3,-84(fp)
811476c0:	00a045f4 	movhi	r2,33047
811476c4:	10bba904 	addi	r2,r2,-4444
811476c8:	180691ba 	slli	r3,r3,6
811476cc:	10c5883a 	add	r2,r2,r3
811476d0:	10800e04 	addi	r2,r2,56
811476d4:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811476d8:	e03fec15 	stw	zero,-80(fp)
811476dc:	00004506 	br	811477f4 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811476e0:	e0ffeb0f 	ldh	r3,-84(fp)
811476e4:	e0bfec17 	ldw	r2,-80(fp)
811476e8:	18803f26 	beq	r3,r2,811477e8 <alt_up_sd_card_fopen+0x2c4>
811476ec:	00a045f4 	movhi	r2,33047
811476f0:	10bba904 	addi	r2,r2,-4444
811476f4:	e0ffec17 	ldw	r3,-80(fp)
811476f8:	180691ba 	slli	r3,r3,6
811476fc:	10c5883a 	add	r2,r2,r3
81147700:	10800f04 	addi	r2,r2,60
81147704:	10800017 	ldw	r2,0(r2)
81147708:	10800058 	cmpnei	r2,r2,1
8114770c:	1000361e 	bne	r2,zero,811477e8 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81147710:	e0ffeb0f 	ldh	r3,-84(fp)
81147714:	00a045f4 	movhi	r2,33047
81147718:	10bba904 	addi	r2,r2,-4444
8114771c:	180691ba 	slli	r3,r3,6
81147720:	10c5883a 	add	r2,r2,r3
81147724:	10800a04 	addi	r2,r2,40
81147728:	10c00017 	ldw	r3,0(r2)
8114772c:	00a045f4 	movhi	r2,33047
81147730:	10bba904 	addi	r2,r2,-4444
81147734:	e13fec17 	ldw	r4,-80(fp)
81147738:	200891ba 	slli	r4,r4,6
8114773c:	1105883a 	add	r2,r2,r4
81147740:	10800a04 	addi	r2,r2,40
81147744:	10800017 	ldw	r2,0(r2)
81147748:	1880271e 	bne	r3,r2,811477e8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8114774c:	e0ffeb0f 	ldh	r3,-84(fp)
81147750:	00a045f4 	movhi	r2,33047
81147754:	10bba904 	addi	r2,r2,-4444
81147758:	180691ba 	slli	r3,r3,6
8114775c:	10c5883a 	add	r2,r2,r3
81147760:	10800b04 	addi	r2,r2,44
81147764:	10c00017 	ldw	r3,0(r2)
81147768:	00a045f4 	movhi	r2,33047
8114776c:	10bba904 	addi	r2,r2,-4444
81147770:	e13fec17 	ldw	r4,-80(fp)
81147774:	200891ba 	slli	r4,r4,6
81147778:	1105883a 	add	r2,r2,r4
8114777c:	10800b04 	addi	r2,r2,44
81147780:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81147784:	1880181e 	bne	r3,r2,811477e8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81147788:	e0ffeb0f 	ldh	r3,-84(fp)
8114778c:	00a045f4 	movhi	r2,33047
81147790:	10bba904 	addi	r2,r2,-4444
81147794:	180691ba 	slli	r3,r3,6
81147798:	10c5883a 	add	r2,r2,r3
8114779c:	10800c04 	addi	r2,r2,48
811477a0:	1100000b 	ldhu	r4,0(r2)
811477a4:	00a045f4 	movhi	r2,33047
811477a8:	10bba904 	addi	r2,r2,-4444
811477ac:	e0ffec17 	ldw	r3,-80(fp)
811477b0:	180691ba 	slli	r3,r3,6
811477b4:	10c5883a 	add	r2,r2,r3
811477b8:	10800c04 	addi	r2,r2,48
811477bc:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811477c0:	20ffffcc 	andi	r3,r4,65535
811477c4:	18e0001c 	xori	r3,r3,32768
811477c8:	18e00004 	addi	r3,r3,-32768
811477cc:	10bfffcc 	andi	r2,r2,65535
811477d0:	10a0001c 	xori	r2,r2,32768
811477d4:	10a00004 	addi	r2,r2,-32768
811477d8:	1880031e 	bne	r3,r2,811477e8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
811477dc:	00bfff84 	movi	r2,-2
811477e0:	e0bfeb0d 	sth	r2,-84(fp)
								break;
811477e4:	00002a06 	br	81147890 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811477e8:	e0bfec17 	ldw	r2,-80(fp)
811477ec:	10800044 	addi	r2,r2,1
811477f0:	e0bfec15 	stw	r2,-80(fp)
811477f4:	e0bfec17 	ldw	r2,-80(fp)
811477f8:	10800510 	cmplti	r2,r2,20
811477fc:	103fb81e 	bne	r2,zero,811476e0 <__reset+0xfb1276e0>
81147800:	00002306 	br	81147890 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81147804:	e0bfff17 	ldw	r2,-4(fp)
81147808:	10001f26 	beq	r2,zero,81147888 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8114780c:	e0bfeb0f 	ldh	r2,-84(fp)
81147810:	100691ba 	slli	r3,r2,6
81147814:	00a045f4 	movhi	r2,33047
81147818:	10bba904 	addi	r2,r2,-4444
8114781c:	1885883a 	add	r2,r3,r2
81147820:	e0ffee04 	addi	r3,fp,-72
81147824:	180d883a 	mov	r6,r3
81147828:	100b883a 	mov	r5,r2
8114782c:	e13ffe17 	ldw	r4,-8(fp)
81147830:	1146a680 	call	81146a68 <create_file>
81147834:	10001126 	beq	r2,zero,8114787c <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81147838:	e0ffeb0f 	ldh	r3,-84(fp)
8114783c:	00a045f4 	movhi	r2,33047
81147840:	10bba904 	addi	r2,r2,-4444
81147844:	180691ba 	slli	r3,r3,6
81147848:	10c5883a 	add	r2,r2,r3
8114784c:	10800f04 	addi	r2,r2,60
81147850:	00c00044 	movi	r3,1
81147854:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81147858:	e0ffeb0f 	ldh	r3,-84(fp)
8114785c:	00a045f4 	movhi	r2,33047
81147860:	10bba904 	addi	r2,r2,-4444
81147864:	180691ba 	slli	r3,r3,6
81147868:	10c5883a 	add	r2,r2,r3
8114786c:	10800e04 	addi	r2,r2,56
81147870:	00c00044 	movi	r3,1
81147874:	10c00015 	stw	r3,0(r2)
81147878:	00000506 	br	81147890 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
8114787c:	00bfffc4 	movi	r2,-1
81147880:	e0bfeb0d 	sth	r2,-84(fp)
81147884:	00000206 	br	81147890 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81147888:	00bfffc4 	movi	r2,-1
8114788c:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81147890:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81147894:	e037883a 	mov	sp,fp
81147898:	dfc00117 	ldw	ra,4(sp)
8114789c:	df000017 	ldw	fp,0(sp)
811478a0:	dec00204 	addi	sp,sp,8
811478a4:	f800283a 	ret

811478a8 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811478a8:	defffd04 	addi	sp,sp,-12
811478ac:	de00012e 	bgeu	sp,et,811478b4 <alt_up_sd_card_set_attributes+0xc>
811478b0:	003b68fa 	trap	3
811478b4:	df000215 	stw	fp,8(sp)
811478b8:	df000204 	addi	fp,sp,8
811478bc:	2007883a 	mov	r3,r4
811478c0:	2805883a 	mov	r2,r5
811478c4:	e0fffe0d 	sth	r3,-8(fp)
811478c8:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811478cc:	e0bffe0f 	ldh	r2,-8(fp)
811478d0:	10001416 	blt	r2,zero,81147924 <alt_up_sd_card_set_attributes+0x7c>
811478d4:	e0bffe0f 	ldh	r2,-8(fp)
811478d8:	10800508 	cmpgei	r2,r2,20
811478dc:	1000111e 	bne	r2,zero,81147924 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811478e0:	e0fffe0f 	ldh	r3,-8(fp)
811478e4:	00a045f4 	movhi	r2,33047
811478e8:	10bba904 	addi	r2,r2,-4444
811478ec:	180691ba 	slli	r3,r3,6
811478f0:	10c5883a 	add	r2,r2,r3
811478f4:	10800f04 	addi	r2,r2,60
811478f8:	10800017 	ldw	r2,0(r2)
811478fc:	10000926 	beq	r2,zero,81147924 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81147900:	e0fffe0f 	ldh	r3,-8(fp)
81147904:	e0bfff0b 	ldhu	r2,-4(fp)
81147908:	1009883a 	mov	r4,r2
8114790c:	00a045f4 	movhi	r2,33047
81147910:	10bba904 	addi	r2,r2,-4444
81147914:	180691ba 	slli	r3,r3,6
81147918:	10c5883a 	add	r2,r2,r3
8114791c:	108002c4 	addi	r2,r2,11
81147920:	11000005 	stb	r4,0(r2)
        }
    }
}
81147924:	0001883a 	nop
81147928:	e037883a 	mov	sp,fp
8114792c:	df000017 	ldw	fp,0(sp)
81147930:	dec00104 	addi	sp,sp,4
81147934:	f800283a 	ret

81147938 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81147938:	defffd04 	addi	sp,sp,-12
8114793c:	de00012e 	bgeu	sp,et,81147944 <alt_up_sd_card_get_attributes+0xc>
81147940:	003b68fa 	trap	3
81147944:	df000215 	stw	fp,8(sp)
81147948:	df000204 	addi	fp,sp,8
8114794c:	2005883a 	mov	r2,r4
81147950:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81147954:	00bfffc4 	movi	r2,-1
81147958:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8114795c:	e0bfff0f 	ldh	r2,-4(fp)
81147960:	10001416 	blt	r2,zero,811479b4 <alt_up_sd_card_get_attributes+0x7c>
81147964:	e0bfff0f 	ldh	r2,-4(fp)
81147968:	10800508 	cmpgei	r2,r2,20
8114796c:	1000111e 	bne	r2,zero,811479b4 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81147970:	e0ffff0f 	ldh	r3,-4(fp)
81147974:	00a045f4 	movhi	r2,33047
81147978:	10bba904 	addi	r2,r2,-4444
8114797c:	180691ba 	slli	r3,r3,6
81147980:	10c5883a 	add	r2,r2,r3
81147984:	10800f04 	addi	r2,r2,60
81147988:	10800017 	ldw	r2,0(r2)
8114798c:	10000926 	beq	r2,zero,811479b4 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81147990:	e0ffff0f 	ldh	r3,-4(fp)
81147994:	00a045f4 	movhi	r2,33047
81147998:	10bba904 	addi	r2,r2,-4444
8114799c:	180691ba 	slli	r3,r3,6
811479a0:	10c5883a 	add	r2,r2,r3
811479a4:	108002c4 	addi	r2,r2,11
811479a8:	10800003 	ldbu	r2,0(r2)
811479ac:	10803fcc 	andi	r2,r2,255
811479b0:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
811479b4:	e0bffe0b 	ldhu	r2,-8(fp)
}
811479b8:	e037883a 	mov	sp,fp
811479bc:	df000017 	ldw	fp,0(sp)
811479c0:	dec00104 	addi	sp,sp,4
811479c4:	f800283a 	ret

811479c8 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
811479c8:	defffa04 	addi	sp,sp,-24
811479cc:	de00012e 	bgeu	sp,et,811479d4 <alt_up_sd_card_read+0xc>
811479d0:	003b68fa 	trap	3
811479d4:	dfc00515 	stw	ra,20(sp)
811479d8:	df000415 	stw	fp,16(sp)
811479dc:	df000404 	addi	fp,sp,16
811479e0:	2005883a 	mov	r2,r4
811479e4:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811479e8:	00bfffc4 	movi	r2,-1
811479ec:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811479f0:	e0bfff0f 	ldh	r2,-4(fp)
811479f4:	1000ce16 	blt	r2,zero,81147d30 <alt_up_sd_card_read+0x368>
811479f8:	e0bfff0f 	ldh	r2,-4(fp)
811479fc:	10800508 	cmpgei	r2,r2,20
81147a00:	1000cb1e 	bne	r2,zero,81147d30 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81147a04:	e0ffff0f 	ldh	r3,-4(fp)
81147a08:	00a045f4 	movhi	r2,33047
81147a0c:	10bba904 	addi	r2,r2,-4444
81147a10:	180691ba 	slli	r3,r3,6
81147a14:	10c5883a 	add	r2,r2,r3
81147a18:	10800f04 	addi	r2,r2,60
81147a1c:	10800017 	ldw	r2,0(r2)
81147a20:	1000c326 	beq	r2,zero,81147d30 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81147a24:	e0ffff0f 	ldh	r3,-4(fp)
81147a28:	00a045f4 	movhi	r2,33047
81147a2c:	10bba904 	addi	r2,r2,-4444
81147a30:	180691ba 	slli	r3,r3,6
81147a34:	10c5883a 	add	r2,r2,r3
81147a38:	10800904 	addi	r2,r2,36
81147a3c:	10c00017 	ldw	r3,0(r2)
81147a40:	e13fff0f 	ldh	r4,-4(fp)
81147a44:	00a045f4 	movhi	r2,33047
81147a48:	10bba904 	addi	r2,r2,-4444
81147a4c:	200891ba 	slli	r4,r4,6
81147a50:	1105883a 	add	r2,r2,r4
81147a54:	10800604 	addi	r2,r2,24
81147a58:	10800017 	ldw	r2,0(r2)
81147a5c:	1880b42e 	bgeu	r3,r2,81147d30 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147a60:	00a045f4 	movhi	r2,33047
81147a64:	10bb9404 	addi	r2,r2,-4528
81147a68:	10c01417 	ldw	r3,80(r2)
81147a6c:	e13fff0f 	ldh	r4,-4(fp)
81147a70:	00a045f4 	movhi	r2,33047
81147a74:	10bba904 	addi	r2,r2,-4444
81147a78:	200891ba 	slli	r4,r4,6
81147a7c:	1105883a 	add	r2,r2,r4
81147a80:	10800704 	addi	r2,r2,28
81147a84:	10800017 	ldw	r2,0(r2)
81147a88:	113fff84 	addi	r4,r2,-2
81147a8c:	00a045f4 	movhi	r2,33047
81147a90:	10bb9404 	addi	r2,r2,-4528
81147a94:	10800383 	ldbu	r2,14(r2)
81147a98:	10803fcc 	andi	r2,r2,255
81147a9c:	2085383a 	mul	r2,r4,r2
81147aa0:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81147aa4:	e13fff0f 	ldh	r4,-4(fp)
81147aa8:	00a045f4 	movhi	r2,33047
81147aac:	10bba904 	addi	r2,r2,-4444
81147ab0:	200891ba 	slli	r4,r4,6
81147ab4:	1105883a 	add	r2,r2,r4
81147ab8:	10800804 	addi	r2,r2,32
81147abc:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147ac0:	1885883a 	add	r2,r3,r2
81147ac4:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81147ac8:	e0ffff0f 	ldh	r3,-4(fp)
81147acc:	00a045f4 	movhi	r2,33047
81147ad0:	10bba904 	addi	r2,r2,-4444
81147ad4:	180691ba 	slli	r3,r3,6
81147ad8:	10c5883a 	add	r2,r2,r3
81147adc:	10800904 	addi	r2,r2,36
81147ae0:	10800017 	ldw	r2,0(r2)
81147ae4:	10006826 	beq	r2,zero,81147c88 <alt_up_sd_card_read+0x2c0>
81147ae8:	e0ffff0f 	ldh	r3,-4(fp)
81147aec:	00a045f4 	movhi	r2,33047
81147af0:	10bba904 	addi	r2,r2,-4444
81147af4:	180691ba 	slli	r3,r3,6
81147af8:	10c5883a 	add	r2,r2,r3
81147afc:	10800904 	addi	r2,r2,36
81147b00:	10800017 	ldw	r2,0(r2)
81147b04:	10807fcc 	andi	r2,r2,511
81147b08:	10005f1e 	bne	r2,zero,81147c88 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81147b0c:	e0ffff0f 	ldh	r3,-4(fp)
81147b10:	00a045f4 	movhi	r2,33047
81147b14:	10bba904 	addi	r2,r2,-4444
81147b18:	180691ba 	slli	r3,r3,6
81147b1c:	10c5883a 	add	r2,r2,r3
81147b20:	10800804 	addi	r2,r2,32
81147b24:	10c00017 	ldw	r3,0(r2)
81147b28:	00a045f4 	movhi	r2,33047
81147b2c:	10bb9404 	addi	r2,r2,-4528
81147b30:	10800383 	ldbu	r2,14(r2)
81147b34:	10803fcc 	andi	r2,r2,255
81147b38:	10bfffc4 	addi	r2,r2,-1
81147b3c:	1880401e 	bne	r3,r2,81147c40 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81147b40:	e0ffff0f 	ldh	r3,-4(fp)
81147b44:	00a045f4 	movhi	r2,33047
81147b48:	10bba904 	addi	r2,r2,-4444
81147b4c:	180691ba 	slli	r3,r3,6
81147b50:	10c5883a 	add	r2,r2,r3
81147b54:	10800704 	addi	r2,r2,28
81147b58:	10800017 	ldw	r2,0(r2)
81147b5c:	e0fffe04 	addi	r3,fp,-8
81147b60:	180b883a 	mov	r5,r3
81147b64:	1009883a 	mov	r4,r2
81147b68:	11443540 	call	81144354 <get_cluster_flag>
81147b6c:	10003226 	beq	r2,zero,81147c38 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81147b70:	e0bffe0b 	ldhu	r2,-8(fp)
81147b74:	10bfffcc 	andi	r2,r2,65535
81147b78:	10fffe0c 	andi	r3,r2,65528
81147b7c:	00bffe14 	movui	r2,65528
81147b80:	1880021e 	bne	r3,r2,81147b8c <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81147b84:	00bfffc4 	movi	r2,-1
81147b88:	00006a06 	br	81147d34 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81147b8c:	e13fff0f 	ldh	r4,-4(fp)
81147b90:	e0bffe0b 	ldhu	r2,-8(fp)
81147b94:	10ffffcc 	andi	r3,r2,65535
81147b98:	00a045f4 	movhi	r2,33047
81147b9c:	10bba904 	addi	r2,r2,-4444
81147ba0:	200891ba 	slli	r4,r4,6
81147ba4:	1105883a 	add	r2,r2,r4
81147ba8:	10800704 	addi	r2,r2,28
81147bac:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81147bb0:	e0ffff0f 	ldh	r3,-4(fp)
81147bb4:	00a045f4 	movhi	r2,33047
81147bb8:	10bba904 	addi	r2,r2,-4444
81147bbc:	180691ba 	slli	r3,r3,6
81147bc0:	10c5883a 	add	r2,r2,r3
81147bc4:	10800804 	addi	r2,r2,32
81147bc8:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147bcc:	00a045f4 	movhi	r2,33047
81147bd0:	10bb9404 	addi	r2,r2,-4528
81147bd4:	10c01417 	ldw	r3,80(r2)
81147bd8:	e13fff0f 	ldh	r4,-4(fp)
81147bdc:	00a045f4 	movhi	r2,33047
81147be0:	10bba904 	addi	r2,r2,-4444
81147be4:	200891ba 	slli	r4,r4,6
81147be8:	1105883a 	add	r2,r2,r4
81147bec:	10800704 	addi	r2,r2,28
81147bf0:	10800017 	ldw	r2,0(r2)
81147bf4:	113fff84 	addi	r4,r2,-2
81147bf8:	00a045f4 	movhi	r2,33047
81147bfc:	10bb9404 	addi	r2,r2,-4528
81147c00:	10800383 	ldbu	r2,14(r2)
81147c04:	10803fcc 	andi	r2,r2,255
81147c08:	2085383a 	mul	r2,r4,r2
81147c0c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81147c10:	e13fff0f 	ldh	r4,-4(fp)
81147c14:	00a045f4 	movhi	r2,33047
81147c18:	10bba904 	addi	r2,r2,-4444
81147c1c:	200891ba 	slli	r4,r4,6
81147c20:	1105883a 	add	r2,r2,r4
81147c24:	10800804 	addi	r2,r2,32
81147c28:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147c2c:	1885883a 	add	r2,r3,r2
81147c30:	e0bffd15 	stw	r2,-12(fp)
81147c34:	00001406 	br	81147c88 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81147c38:	00bfff84 	movi	r2,-2
81147c3c:	00003d06 	br	81147d34 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81147c40:	e13fff0f 	ldh	r4,-4(fp)
81147c44:	e0ffff0f 	ldh	r3,-4(fp)
81147c48:	00a045f4 	movhi	r2,33047
81147c4c:	10bba904 	addi	r2,r2,-4444
81147c50:	180691ba 	slli	r3,r3,6
81147c54:	10c5883a 	add	r2,r2,r3
81147c58:	10800804 	addi	r2,r2,32
81147c5c:	10800017 	ldw	r2,0(r2)
81147c60:	10c00044 	addi	r3,r2,1
81147c64:	00a045f4 	movhi	r2,33047
81147c68:	10bba904 	addi	r2,r2,-4444
81147c6c:	200891ba 	slli	r4,r4,6
81147c70:	1105883a 	add	r2,r2,r4
81147c74:	10800804 	addi	r2,r2,32
81147c78:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81147c7c:	e0bffd17 	ldw	r2,-12(fp)
81147c80:	10800044 	addi	r2,r2,1
81147c84:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81147c88:	d0e0b117 	ldw	r3,-32060(gp)
81147c8c:	e0bffd17 	ldw	r2,-12(fp)
81147c90:	1885883a 	add	r2,r3,r2
81147c94:	1007883a 	mov	r3,r2
81147c98:	d0a0b517 	ldw	r2,-32044(gp)
81147c9c:	18800726 	beq	r3,r2,81147cbc <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81147ca0:	d0a0b117 	ldw	r2,-32060(gp)
81147ca4:	100b883a 	mov	r5,r2
81147ca8:	e13ffd17 	ldw	r4,-12(fp)
81147cac:	11442740 	call	81144274 <Read_Sector_Data>
81147cb0:	1000021e 	bne	r2,zero,81147cbc <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81147cb4:	00bfff84 	movi	r2,-2
81147cb8:	00001e06 	br	81147d34 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81147cbc:	d0e0b017 	ldw	r3,-32064(gp)
81147cc0:	e13fff0f 	ldh	r4,-4(fp)
81147cc4:	00a045f4 	movhi	r2,33047
81147cc8:	10bba904 	addi	r2,r2,-4444
81147ccc:	200891ba 	slli	r4,r4,6
81147cd0:	1105883a 	add	r2,r2,r4
81147cd4:	10800904 	addi	r2,r2,36
81147cd8:	10800017 	ldw	r2,0(r2)
81147cdc:	10807fcc 	andi	r2,r2,511
81147ce0:	1885883a 	add	r2,r3,r2
81147ce4:	10800023 	ldbuio	r2,0(r2)
81147ce8:	10803fcc 	andi	r2,r2,255
81147cec:	10803fcc 	andi	r2,r2,255
81147cf0:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81147cf4:	e13fff0f 	ldh	r4,-4(fp)
81147cf8:	e0ffff0f 	ldh	r3,-4(fp)
81147cfc:	00a045f4 	movhi	r2,33047
81147d00:	10bba904 	addi	r2,r2,-4444
81147d04:	180691ba 	slli	r3,r3,6
81147d08:	10c5883a 	add	r2,r2,r3
81147d0c:	10800904 	addi	r2,r2,36
81147d10:	10800017 	ldw	r2,0(r2)
81147d14:	10c00044 	addi	r3,r2,1
81147d18:	00a045f4 	movhi	r2,33047
81147d1c:	10bba904 	addi	r2,r2,-4444
81147d20:	200891ba 	slli	r4,r4,6
81147d24:	1105883a 	add	r2,r2,r4
81147d28:	10800904 	addi	r2,r2,36
81147d2c:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81147d30:	e0bffc0b 	ldhu	r2,-16(fp)
}
81147d34:	e037883a 	mov	sp,fp
81147d38:	dfc00117 	ldw	ra,4(sp)
81147d3c:	df000017 	ldw	fp,0(sp)
81147d40:	dec00204 	addi	sp,sp,8
81147d44:	f800283a 	ret

81147d48 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81147d48:	defff804 	addi	sp,sp,-32
81147d4c:	de00012e 	bgeu	sp,et,81147d54 <alt_up_sd_card_write+0xc>
81147d50:	003b68fa 	trap	3
81147d54:	dfc00715 	stw	ra,28(sp)
81147d58:	df000615 	stw	fp,24(sp)
81147d5c:	df000604 	addi	fp,sp,24
81147d60:	2007883a 	mov	r3,r4
81147d64:	2805883a 	mov	r2,r5
81147d68:	e0fffe0d 	sth	r3,-8(fp)
81147d6c:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81147d70:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81147d74:	e0bffe0f 	ldh	r2,-8(fp)
81147d78:	10017716 	blt	r2,zero,81148358 <alt_up_sd_card_write+0x610>
81147d7c:	e0bffe0f 	ldh	r2,-8(fp)
81147d80:	10800508 	cmpgei	r2,r2,20
81147d84:	1001741e 	bne	r2,zero,81148358 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81147d88:	e0fffe0f 	ldh	r3,-8(fp)
81147d8c:	00a045f4 	movhi	r2,33047
81147d90:	10bba904 	addi	r2,r2,-4444
81147d94:	180691ba 	slli	r3,r3,6
81147d98:	10c5883a 	add	r2,r2,r3
81147d9c:	10800f04 	addi	r2,r2,60
81147da0:	10800017 	ldw	r2,0(r2)
81147da4:	10016c26 	beq	r2,zero,81148358 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147da8:	00a045f4 	movhi	r2,33047
81147dac:	10bb9404 	addi	r2,r2,-4528
81147db0:	10c01417 	ldw	r3,80(r2)
81147db4:	e13ffe0f 	ldh	r4,-8(fp)
81147db8:	00a045f4 	movhi	r2,33047
81147dbc:	10bba904 	addi	r2,r2,-4444
81147dc0:	200891ba 	slli	r4,r4,6
81147dc4:	1105883a 	add	r2,r2,r4
81147dc8:	10800704 	addi	r2,r2,28
81147dcc:	10800017 	ldw	r2,0(r2)
81147dd0:	113fff84 	addi	r4,r2,-2
81147dd4:	00a045f4 	movhi	r2,33047
81147dd8:	10bb9404 	addi	r2,r2,-4528
81147ddc:	10800383 	ldbu	r2,14(r2)
81147de0:	10803fcc 	andi	r2,r2,255
81147de4:	2085383a 	mul	r2,r4,r2
81147de8:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81147dec:	e13ffe0f 	ldh	r4,-8(fp)
81147df0:	00a045f4 	movhi	r2,33047
81147df4:	10bba904 	addi	r2,r2,-4444
81147df8:	200891ba 	slli	r4,r4,6
81147dfc:	1105883a 	add	r2,r2,r4
81147e00:	10800804 	addi	r2,r2,32
81147e04:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147e08:	1885883a 	add	r2,r3,r2
81147e0c:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81147e10:	e0fffe0f 	ldh	r3,-8(fp)
81147e14:	00a045f4 	movhi	r2,33047
81147e18:	10bba904 	addi	r2,r2,-4444
81147e1c:	180691ba 	slli	r3,r3,6
81147e20:	10c5883a 	add	r2,r2,r3
81147e24:	10800904 	addi	r2,r2,36
81147e28:	10c00017 	ldw	r3,0(r2)
81147e2c:	00a045f4 	movhi	r2,33047
81147e30:	10bb9404 	addi	r2,r2,-4528
81147e34:	1080030b 	ldhu	r2,12(r2)
81147e38:	10bfffcc 	andi	r2,r2,65535
81147e3c:	1889203a 	divu	r4,r3,r2
81147e40:	2085383a 	mul	r2,r4,r2
81147e44:	1885c83a 	sub	r2,r3,r2
81147e48:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81147e4c:	e0fffe0f 	ldh	r3,-8(fp)
81147e50:	00a045f4 	movhi	r2,33047
81147e54:	10bba904 	addi	r2,r2,-4444
81147e58:	180691ba 	slli	r3,r3,6
81147e5c:	10c5883a 	add	r2,r2,r3
81147e60:	10800904 	addi	r2,r2,36
81147e64:	10c00017 	ldw	r3,0(r2)
81147e68:	e13ffe0f 	ldh	r4,-8(fp)
81147e6c:	00a045f4 	movhi	r2,33047
81147e70:	10bba904 	addi	r2,r2,-4444
81147e74:	200891ba 	slli	r4,r4,6
81147e78:	1105883a 	add	r2,r2,r4
81147e7c:	10800604 	addi	r2,r2,24
81147e80:	10800017 	ldw	r2,0(r2)
81147e84:	1880672e 	bgeu	r3,r2,81148024 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81147e88:	e0fffe0f 	ldh	r3,-8(fp)
81147e8c:	00a045f4 	movhi	r2,33047
81147e90:	10bba904 	addi	r2,r2,-4444
81147e94:	180691ba 	slli	r3,r3,6
81147e98:	10c5883a 	add	r2,r2,r3
81147e9c:	10800904 	addi	r2,r2,36
81147ea0:	10800017 	ldw	r2,0(r2)
81147ea4:	1000e126 	beq	r2,zero,8114822c <alt_up_sd_card_write+0x4e4>
81147ea8:	e0bffc0f 	ldh	r2,-16(fp)
81147eac:	1000df1e 	bne	r2,zero,8114822c <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81147eb0:	e0fffe0f 	ldh	r3,-8(fp)
81147eb4:	00a045f4 	movhi	r2,33047
81147eb8:	10bba904 	addi	r2,r2,-4444
81147ebc:	180691ba 	slli	r3,r3,6
81147ec0:	10c5883a 	add	r2,r2,r3
81147ec4:	10800804 	addi	r2,r2,32
81147ec8:	10c00017 	ldw	r3,0(r2)
81147ecc:	00a045f4 	movhi	r2,33047
81147ed0:	10bb9404 	addi	r2,r2,-4528
81147ed4:	10800383 	ldbu	r2,14(r2)
81147ed8:	10803fcc 	andi	r2,r2,255
81147edc:	10bfffc4 	addi	r2,r2,-1
81147ee0:	18803d1e 	bne	r3,r2,81147fd8 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81147ee4:	e0fffe0f 	ldh	r3,-8(fp)
81147ee8:	00a045f4 	movhi	r2,33047
81147eec:	10bba904 	addi	r2,r2,-4444
81147ef0:	180691ba 	slli	r3,r3,6
81147ef4:	10c5883a 	add	r2,r2,r3
81147ef8:	10800704 	addi	r2,r2,28
81147efc:	10800017 	ldw	r2,0(r2)
81147f00:	e0fffc84 	addi	r3,fp,-14
81147f04:	180b883a 	mov	r5,r3
81147f08:	1009883a 	mov	r4,r2
81147f0c:	11443540 	call	81144354 <get_cluster_flag>
81147f10:	10002f26 	beq	r2,zero,81147fd0 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81147f14:	e0bffc8b 	ldhu	r2,-14(fp)
81147f18:	10bfffcc 	andi	r2,r2,65535
81147f1c:	10bffe28 	cmpgeui	r2,r2,65528
81147f20:	1000c21e 	bne	r2,zero,8114822c <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81147f24:	e13ffe0f 	ldh	r4,-8(fp)
81147f28:	e0bffc8b 	ldhu	r2,-14(fp)
81147f2c:	10ffffcc 	andi	r3,r2,65535
81147f30:	00a045f4 	movhi	r2,33047
81147f34:	10bba904 	addi	r2,r2,-4444
81147f38:	200891ba 	slli	r4,r4,6
81147f3c:	1105883a 	add	r2,r2,r4
81147f40:	10800704 	addi	r2,r2,28
81147f44:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81147f48:	e0fffe0f 	ldh	r3,-8(fp)
81147f4c:	00a045f4 	movhi	r2,33047
81147f50:	10bba904 	addi	r2,r2,-4444
81147f54:	180691ba 	slli	r3,r3,6
81147f58:	10c5883a 	add	r2,r2,r3
81147f5c:	10800804 	addi	r2,r2,32
81147f60:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147f64:	00a045f4 	movhi	r2,33047
81147f68:	10bb9404 	addi	r2,r2,-4528
81147f6c:	10c01417 	ldw	r3,80(r2)
81147f70:	e13ffe0f 	ldh	r4,-8(fp)
81147f74:	00a045f4 	movhi	r2,33047
81147f78:	10bba904 	addi	r2,r2,-4444
81147f7c:	200891ba 	slli	r4,r4,6
81147f80:	1105883a 	add	r2,r2,r4
81147f84:	10800704 	addi	r2,r2,28
81147f88:	10800017 	ldw	r2,0(r2)
81147f8c:	113fff84 	addi	r4,r2,-2
81147f90:	00a045f4 	movhi	r2,33047
81147f94:	10bb9404 	addi	r2,r2,-4528
81147f98:	10800383 	ldbu	r2,14(r2)
81147f9c:	10803fcc 	andi	r2,r2,255
81147fa0:	2085383a 	mul	r2,r4,r2
81147fa4:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81147fa8:	e13ffe0f 	ldh	r4,-8(fp)
81147fac:	00a045f4 	movhi	r2,33047
81147fb0:	10bba904 	addi	r2,r2,-4444
81147fb4:	200891ba 	slli	r4,r4,6
81147fb8:	1105883a 	add	r2,r2,r4
81147fbc:	10800804 	addi	r2,r2,32
81147fc0:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147fc4:	1885883a 	add	r2,r3,r2
81147fc8:	e0bffb15 	stw	r2,-20(fp)
81147fcc:	00009706 	br	8114822c <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81147fd0:	0005883a 	mov	r2,zero
81147fd4:	0000e106 	br	8114835c <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81147fd8:	e13ffe0f 	ldh	r4,-8(fp)
81147fdc:	e0fffe0f 	ldh	r3,-8(fp)
81147fe0:	00a045f4 	movhi	r2,33047
81147fe4:	10bba904 	addi	r2,r2,-4444
81147fe8:	180691ba 	slli	r3,r3,6
81147fec:	10c5883a 	add	r2,r2,r3
81147ff0:	10800804 	addi	r2,r2,32
81147ff4:	10800017 	ldw	r2,0(r2)
81147ff8:	10c00044 	addi	r3,r2,1
81147ffc:	00a045f4 	movhi	r2,33047
81148000:	10bba904 	addi	r2,r2,-4444
81148004:	200891ba 	slli	r4,r4,6
81148008:	1105883a 	add	r2,r2,r4
8114800c:	10800804 	addi	r2,r2,32
81148010:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81148014:	e0bffb17 	ldw	r2,-20(fp)
81148018:	10800044 	addi	r2,r2,1
8114801c:	e0bffb15 	stw	r2,-20(fp)
81148020:	00008206 	br	8114822c <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81148024:	e0fffe0f 	ldh	r3,-8(fp)
81148028:	00a045f4 	movhi	r2,33047
8114802c:	10bba904 	addi	r2,r2,-4444
81148030:	180691ba 	slli	r3,r3,6
81148034:	10c5883a 	add	r2,r2,r3
81148038:	10800904 	addi	r2,r2,36
8114803c:	10800017 	ldw	r2,0(r2)
81148040:	10007a26 	beq	r2,zero,8114822c <alt_up_sd_card_write+0x4e4>
81148044:	e0bffc0f 	ldh	r2,-16(fp)
81148048:	1000781e 	bne	r2,zero,8114822c <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8114804c:	e0fffe0f 	ldh	r3,-8(fp)
81148050:	00a045f4 	movhi	r2,33047
81148054:	10bba904 	addi	r2,r2,-4444
81148058:	180691ba 	slli	r3,r3,6
8114805c:	10c5883a 	add	r2,r2,r3
81148060:	10800804 	addi	r2,r2,32
81148064:	10c00017 	ldw	r3,0(r2)
81148068:	00a045f4 	movhi	r2,33047
8114806c:	10bb9404 	addi	r2,r2,-4528
81148070:	10800383 	ldbu	r2,14(r2)
81148074:	10803fcc 	andi	r2,r2,255
81148078:	10bfffc4 	addi	r2,r2,-1
8114807c:	18803e1e 	bne	r3,r2,81148178 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81148080:	e0bffd04 	addi	r2,fp,-12
81148084:	1009883a 	mov	r4,r2
81148088:	11463980 	call	81146398 <find_first_empty_cluster>
8114808c:	10003826 	beq	r2,zero,81148170 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81148090:	e0fffe0f 	ldh	r3,-8(fp)
81148094:	00a045f4 	movhi	r2,33047
81148098:	10bba904 	addi	r2,r2,-4444
8114809c:	180691ba 	slli	r3,r3,6
811480a0:	10c5883a 	add	r2,r2,r3
811480a4:	10800704 	addi	r2,r2,28
811480a8:	10800017 	ldw	r2,0(r2)
811480ac:	e0fffd17 	ldw	r3,-12(fp)
811480b0:	18ffffcc 	andi	r3,r3,65535
811480b4:	18e0001c 	xori	r3,r3,32768
811480b8:	18e00004 	addi	r3,r3,-32768
811480bc:	01800044 	movi	r6,1
811480c0:	180b883a 	mov	r5,r3
811480c4:	1009883a 	mov	r4,r2
811480c8:	11444100 	call	81144410 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
811480cc:	e0bffd17 	ldw	r2,-12(fp)
811480d0:	01800044 	movi	r6,1
811480d4:	017fffc4 	movi	r5,-1
811480d8:	1009883a 	mov	r4,r2
811480dc:	11444100 	call	81144410 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811480e0:	e0fffe0f 	ldh	r3,-8(fp)
811480e4:	00a045f4 	movhi	r2,33047
811480e8:	10bba904 	addi	r2,r2,-4444
811480ec:	180691ba 	slli	r3,r3,6
811480f0:	10c5883a 	add	r2,r2,r3
811480f4:	10800704 	addi	r2,r2,28
811480f8:	10800017 	ldw	r2,0(r2)
811480fc:	e0fffd17 	ldw	r3,-12(fp)
81148100:	18ffffcc 	andi	r3,r3,65535
81148104:	18e0001c 	xori	r3,r3,32768
81148108:	18e00004 	addi	r3,r3,-32768
8114810c:	000d883a 	mov	r6,zero
81148110:	180b883a 	mov	r5,r3
81148114:	1009883a 	mov	r4,r2
81148118:	11444100 	call	81144410 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
8114811c:	e0bffd17 	ldw	r2,-12(fp)
81148120:	000d883a 	mov	r6,zero
81148124:	017fffc4 	movi	r5,-1
81148128:	1009883a 	mov	r4,r2
8114812c:	11444100 	call	81144410 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81148130:	e13ffe0f 	ldh	r4,-8(fp)
81148134:	e0fffd17 	ldw	r3,-12(fp)
81148138:	00a045f4 	movhi	r2,33047
8114813c:	10bba904 	addi	r2,r2,-4444
81148140:	200891ba 	slli	r4,r4,6
81148144:	1105883a 	add	r2,r2,r4
81148148:	10800704 	addi	r2,r2,28
8114814c:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81148150:	e0fffe0f 	ldh	r3,-8(fp)
81148154:	00a045f4 	movhi	r2,33047
81148158:	10bba904 	addi	r2,r2,-4444
8114815c:	180691ba 	slli	r3,r3,6
81148160:	10c5883a 	add	r2,r2,r3
81148164:	10800804 	addi	r2,r2,32
81148168:	10000015 	stw	zero,0(r2)
8114816c:	00001506 	br	811481c4 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81148170:	0005883a 	mov	r2,zero
81148174:	00007906 	br	8114835c <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81148178:	e13ffe0f 	ldh	r4,-8(fp)
8114817c:	e0fffe0f 	ldh	r3,-8(fp)
81148180:	00a045f4 	movhi	r2,33047
81148184:	10bba904 	addi	r2,r2,-4444
81148188:	180691ba 	slli	r3,r3,6
8114818c:	10c5883a 	add	r2,r2,r3
81148190:	10800904 	addi	r2,r2,36
81148194:	10c00017 	ldw	r3,0(r2)
81148198:	00a045f4 	movhi	r2,33047
8114819c:	10bb9404 	addi	r2,r2,-4528
811481a0:	1080030b 	ldhu	r2,12(r2)
811481a4:	10bfffcc 	andi	r2,r2,65535
811481a8:	1887203a 	divu	r3,r3,r2
811481ac:	00a045f4 	movhi	r2,33047
811481b0:	10bba904 	addi	r2,r2,-4444
811481b4:	200891ba 	slli	r4,r4,6
811481b8:	1105883a 	add	r2,r2,r4
811481bc:	10800804 	addi	r2,r2,32
811481c0:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811481c4:	00a045f4 	movhi	r2,33047
811481c8:	10bb9404 	addi	r2,r2,-4528
811481cc:	10c01417 	ldw	r3,80(r2)
811481d0:	e13ffe0f 	ldh	r4,-8(fp)
811481d4:	00a045f4 	movhi	r2,33047
811481d8:	10bba904 	addi	r2,r2,-4444
811481dc:	200891ba 	slli	r4,r4,6
811481e0:	1105883a 	add	r2,r2,r4
811481e4:	10800704 	addi	r2,r2,28
811481e8:	10800017 	ldw	r2,0(r2)
811481ec:	113fff84 	addi	r4,r2,-2
811481f0:	00a045f4 	movhi	r2,33047
811481f4:	10bb9404 	addi	r2,r2,-4528
811481f8:	10800383 	ldbu	r2,14(r2)
811481fc:	10803fcc 	andi	r2,r2,255
81148200:	2085383a 	mul	r2,r4,r2
81148204:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81148208:	e13ffe0f 	ldh	r4,-8(fp)
8114820c:	00a045f4 	movhi	r2,33047
81148210:	10bba904 	addi	r2,r2,-4444
81148214:	200891ba 	slli	r4,r4,6
81148218:	1105883a 	add	r2,r2,r4
8114821c:	10800804 	addi	r2,r2,32
81148220:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81148224:	1885883a 	add	r2,r3,r2
81148228:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
8114822c:	d0e0b117 	ldw	r3,-32060(gp)
81148230:	e0bffb17 	ldw	r2,-20(fp)
81148234:	1885883a 	add	r2,r3,r2
81148238:	1007883a 	mov	r3,r2
8114823c:	d0a0b517 	ldw	r2,-32044(gp)
81148240:	18800726 	beq	r3,r2,81148260 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81148244:	d0a0b117 	ldw	r2,-32060(gp)
81148248:	100b883a 	mov	r5,r2
8114824c:	e13ffb17 	ldw	r4,-20(fp)
81148250:	11442740 	call	81144274 <Read_Sector_Data>
81148254:	1000021e 	bne	r2,zero,81148260 <alt_up_sd_card_write+0x518>
                {
					return false;
81148258:	0005883a 	mov	r2,zero
8114825c:	00003f06 	br	8114835c <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81148260:	d0e0b017 	ldw	r3,-32064(gp)
81148264:	e0bffc0f 	ldh	r2,-16(fp)
81148268:	1885883a 	add	r2,r3,r2
8114826c:	e0ffff07 	ldb	r3,-4(fp)
81148270:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81148274:	e13ffe0f 	ldh	r4,-8(fp)
81148278:	e0fffe0f 	ldh	r3,-8(fp)
8114827c:	00a045f4 	movhi	r2,33047
81148280:	10bba904 	addi	r2,r2,-4444
81148284:	180691ba 	slli	r3,r3,6
81148288:	10c5883a 	add	r2,r2,r3
8114828c:	10800904 	addi	r2,r2,36
81148290:	10800017 	ldw	r2,0(r2)
81148294:	10c00044 	addi	r3,r2,1
81148298:	00a045f4 	movhi	r2,33047
8114829c:	10bba904 	addi	r2,r2,-4444
811482a0:	200891ba 	slli	r4,r4,6
811482a4:	1105883a 	add	r2,r2,r4
811482a8:	10800904 	addi	r2,r2,36
811482ac:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
811482b0:	e0fffe0f 	ldh	r3,-8(fp)
811482b4:	00a045f4 	movhi	r2,33047
811482b8:	10bba904 	addi	r2,r2,-4444
811482bc:	180691ba 	slli	r3,r3,6
811482c0:	10c5883a 	add	r2,r2,r3
811482c4:	10800904 	addi	r2,r2,36
811482c8:	10c00017 	ldw	r3,0(r2)
811482cc:	e13ffe0f 	ldh	r4,-8(fp)
811482d0:	00a045f4 	movhi	r2,33047
811482d4:	10bba904 	addi	r2,r2,-4444
811482d8:	200891ba 	slli	r4,r4,6
811482dc:	1105883a 	add	r2,r2,r4
811482e0:	10800604 	addi	r2,r2,24
811482e4:	10800017 	ldw	r2,0(r2)
811482e8:	18801736 	bltu	r3,r2,81148348 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811482ec:	e13ffe0f 	ldh	r4,-8(fp)
811482f0:	e0fffe0f 	ldh	r3,-8(fp)
811482f4:	00a045f4 	movhi	r2,33047
811482f8:	10bba904 	addi	r2,r2,-4444
811482fc:	180691ba 	slli	r3,r3,6
81148300:	10c5883a 	add	r2,r2,r3
81148304:	10800604 	addi	r2,r2,24
81148308:	10800017 	ldw	r2,0(r2)
8114830c:	10c00044 	addi	r3,r2,1
81148310:	00a045f4 	movhi	r2,33047
81148314:	10bba904 	addi	r2,r2,-4444
81148318:	200891ba 	slli	r4,r4,6
8114831c:	1105883a 	add	r2,r2,r4
81148320:	10800604 	addi	r2,r2,24
81148324:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81148328:	e0fffe0f 	ldh	r3,-8(fp)
8114832c:	00a045f4 	movhi	r2,33047
81148330:	10bba904 	addi	r2,r2,-4444
81148334:	180691ba 	slli	r3,r3,6
81148338:	10c5883a 	add	r2,r2,r3
8114833c:	10800e04 	addi	r2,r2,56
81148340:	00c00044 	movi	r3,1
81148344:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81148348:	00800044 	movi	r2,1
8114834c:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
81148350:	00800044 	movi	r2,1
81148354:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81148358:	e0bffa17 	ldw	r2,-24(fp)
}
8114835c:	e037883a 	mov	sp,fp
81148360:	dfc00117 	ldw	ra,4(sp)
81148364:	df000017 	ldw	fp,0(sp)
81148368:	dec00204 	addi	sp,sp,8
8114836c:	f800283a 	ret

81148370 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81148370:	defffb04 	addi	sp,sp,-20
81148374:	de00012e 	bgeu	sp,et,8114837c <alt_up_sd_card_fclose+0xc>
81148378:	003b68fa 	trap	3
8114837c:	dfc00415 	stw	ra,16(sp)
81148380:	df000315 	stw	fp,12(sp)
81148384:	df000304 	addi	fp,sp,12
81148388:	2005883a 	mov	r2,r4
8114838c:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81148390:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81148394:	1146f4c0 	call	81146f4c <alt_up_sd_card_is_Present>
81148398:	10006026 	beq	r2,zero,8114851c <alt_up_sd_card_fclose+0x1ac>
8114839c:	d0a0aa17 	ldw	r2,-32088(gp)
811483a0:	10005e26 	beq	r2,zero,8114851c <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
811483a4:	e0ffff0f 	ldh	r3,-4(fp)
811483a8:	00a045f4 	movhi	r2,33047
811483ac:	10bba904 	addi	r2,r2,-4444
811483b0:	180691ba 	slli	r3,r3,6
811483b4:	10c5883a 	add	r2,r2,r3
811483b8:	10800f04 	addi	r2,r2,60
811483bc:	10800017 	ldw	r2,0(r2)
811483c0:	10005626 	beq	r2,zero,8114851c <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
811483c4:	e0ffff0f 	ldh	r3,-4(fp)
811483c8:	00a045f4 	movhi	r2,33047
811483cc:	10bba904 	addi	r2,r2,-4444
811483d0:	180691ba 	slli	r3,r3,6
811483d4:	10c5883a 	add	r2,r2,r3
811483d8:	10800e04 	addi	r2,r2,56
811483dc:	10800017 	ldw	r2,0(r2)
811483e0:	10004526 	beq	r2,zero,811484f8 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
811483e4:	e0ffff0f 	ldh	r3,-4(fp)
811483e8:	00a045f4 	movhi	r2,33047
811483ec:	10bba904 	addi	r2,r2,-4444
811483f0:	180691ba 	slli	r3,r3,6
811483f4:	10c5883a 	add	r2,r2,r3
811483f8:	10800b04 	addi	r2,r2,44
811483fc:	10800017 	ldw	r2,0(r2)
81148400:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81148404:	e0ffff0f 	ldh	r3,-4(fp)
81148408:	00a045f4 	movhi	r2,33047
8114840c:	10bba904 	addi	r2,r2,-4444
81148410:	180691ba 	slli	r3,r3,6
81148414:	10c5883a 	add	r2,r2,r3
81148418:	10800a04 	addi	r2,r2,40
8114841c:	10800017 	ldw	r2,0(r2)
81148420:	1000071e 	bne	r2,zero,81148440 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81148424:	00a045f4 	movhi	r2,33047
81148428:	10bb9404 	addi	r2,r2,-4528
8114842c:	10801317 	ldw	r2,76(r2)
81148430:	e0fffe17 	ldw	r3,-8(fp)
81148434:	1885883a 	add	r2,r3,r2
81148438:	e0bffe15 	stw	r2,-8(fp)
8114843c:	00001406 	br	81148490 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81148440:	00a045f4 	movhi	r2,33047
81148444:	10bb9404 	addi	r2,r2,-4528
81148448:	10c01417 	ldw	r3,80(r2)
8114844c:	e0bffe17 	ldw	r2,-8(fp)
81148450:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81148454:	e13fff0f 	ldh	r4,-4(fp)
81148458:	00a045f4 	movhi	r2,33047
8114845c:	10bba904 	addi	r2,r2,-4444
81148460:	200891ba 	slli	r4,r4,6
81148464:	1105883a 	add	r2,r2,r4
81148468:	10800a04 	addi	r2,r2,40
8114846c:	10800017 	ldw	r2,0(r2)
81148470:	113fff84 	addi	r4,r2,-2
81148474:	00a045f4 	movhi	r2,33047
81148478:	10bb9404 	addi	r2,r2,-4528
8114847c:	10800383 	ldbu	r2,14(r2)
81148480:	10803fcc 	andi	r2,r2,255
81148484:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81148488:	1885883a 	add	r2,r3,r2
8114848c:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81148490:	e0bffe17 	ldw	r2,-8(fp)
81148494:	d0e0b117 	ldw	r3,-32060(gp)
81148498:	180b883a 	mov	r5,r3
8114849c:	1009883a 	mov	r4,r2
811484a0:	11442740 	call	81144274 <Read_Sector_Data>
811484a4:	10001426 	beq	r2,zero,811484f8 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
811484a8:	e0ffff0f 	ldh	r3,-4(fp)
811484ac:	00a045f4 	movhi	r2,33047
811484b0:	10bba904 	addi	r2,r2,-4444
811484b4:	180691ba 	slli	r3,r3,6
811484b8:	10c5883a 	add	r2,r2,r3
811484bc:	10800c04 	addi	r2,r2,48
811484c0:	1080000b 	ldhu	r2,0(r2)
811484c4:	113fffcc 	andi	r4,r2,65535
811484c8:	2120001c 	xori	r4,r4,32768
811484cc:	21200004 	addi	r4,r4,-32768
811484d0:	e0bfff0f 	ldh	r2,-4(fp)
811484d4:	100691ba 	slli	r3,r2,6
811484d8:	00a045f4 	movhi	r2,33047
811484dc:	10bba904 	addi	r2,r2,-4444
811484e0:	1885883a 	add	r2,r3,r2
811484e4:	100b883a 	mov	r5,r2
811484e8:	11449280 	call	81144928 <Write_File_Record_At_Offset>
811484ec:	10000226 	beq	r2,zero,811484f8 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811484f0:	11442200 	call	81144220 <Save_Modified_Sector>
811484f4:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
811484f8:	e0ffff0f 	ldh	r3,-4(fp)
811484fc:	00a045f4 	movhi	r2,33047
81148500:	10bba904 	addi	r2,r2,-4444
81148504:	180691ba 	slli	r3,r3,6
81148508:	10c5883a 	add	r2,r2,r3
8114850c:	10800f04 	addi	r2,r2,60
81148510:	10000015 	stw	zero,0(r2)
			result = true;
81148514:	00800044 	movi	r2,1
81148518:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8114851c:	e0bffd17 	ldw	r2,-12(fp)
}
81148520:	e037883a 	mov	sp,fp
81148524:	dfc00117 	ldw	ra,4(sp)
81148528:	df000017 	ldw	fp,0(sp)
8114852c:	dec00204 	addi	sp,sp,8
81148530:	f800283a 	ret

81148534 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81148534:	defffa04 	addi	sp,sp,-24
81148538:	de00012e 	bgeu	sp,et,81148540 <altera_avalon_jtag_uart_read_fd+0xc>
8114853c:	003b68fa 	trap	3
81148540:	dfc00515 	stw	ra,20(sp)
81148544:	df000415 	stw	fp,16(sp)
81148548:	df000404 	addi	fp,sp,16
8114854c:	e13ffd15 	stw	r4,-12(fp)
81148550:	e17ffe15 	stw	r5,-8(fp)
81148554:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81148558:	e0bffd17 	ldw	r2,-12(fp)
8114855c:	10800017 	ldw	r2,0(r2)
81148560:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81148564:	e0bffc17 	ldw	r2,-16(fp)
81148568:	10c00a04 	addi	r3,r2,40
8114856c:	e0bffd17 	ldw	r2,-12(fp)
81148570:	10800217 	ldw	r2,8(r2)
81148574:	100f883a 	mov	r7,r2
81148578:	e1bfff17 	ldw	r6,-4(fp)
8114857c:	e17ffe17 	ldw	r5,-8(fp)
81148580:	1809883a 	mov	r4,r3
81148584:	1148db80 	call	81148db8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81148588:	e037883a 	mov	sp,fp
8114858c:	dfc00117 	ldw	ra,4(sp)
81148590:	df000017 	ldw	fp,0(sp)
81148594:	dec00204 	addi	sp,sp,8
81148598:	f800283a 	ret

8114859c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8114859c:	defffa04 	addi	sp,sp,-24
811485a0:	de00012e 	bgeu	sp,et,811485a8 <altera_avalon_jtag_uart_write_fd+0xc>
811485a4:	003b68fa 	trap	3
811485a8:	dfc00515 	stw	ra,20(sp)
811485ac:	df000415 	stw	fp,16(sp)
811485b0:	df000404 	addi	fp,sp,16
811485b4:	e13ffd15 	stw	r4,-12(fp)
811485b8:	e17ffe15 	stw	r5,-8(fp)
811485bc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811485c0:	e0bffd17 	ldw	r2,-12(fp)
811485c4:	10800017 	ldw	r2,0(r2)
811485c8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
811485cc:	e0bffc17 	ldw	r2,-16(fp)
811485d0:	10c00a04 	addi	r3,r2,40
811485d4:	e0bffd17 	ldw	r2,-12(fp)
811485d8:	10800217 	ldw	r2,8(r2)
811485dc:	100f883a 	mov	r7,r2
811485e0:	e1bfff17 	ldw	r6,-4(fp)
811485e4:	e17ffe17 	ldw	r5,-8(fp)
811485e8:	1809883a 	mov	r4,r3
811485ec:	114907c0 	call	8114907c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811485f0:	e037883a 	mov	sp,fp
811485f4:	dfc00117 	ldw	ra,4(sp)
811485f8:	df000017 	ldw	fp,0(sp)
811485fc:	dec00204 	addi	sp,sp,8
81148600:	f800283a 	ret

81148604 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81148604:	defffc04 	addi	sp,sp,-16
81148608:	de00012e 	bgeu	sp,et,81148610 <altera_avalon_jtag_uart_close_fd+0xc>
8114860c:	003b68fa 	trap	3
81148610:	dfc00315 	stw	ra,12(sp)
81148614:	df000215 	stw	fp,8(sp)
81148618:	df000204 	addi	fp,sp,8
8114861c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81148620:	e0bfff17 	ldw	r2,-4(fp)
81148624:	10800017 	ldw	r2,0(r2)
81148628:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
8114862c:	e0bffe17 	ldw	r2,-8(fp)
81148630:	10c00a04 	addi	r3,r2,40
81148634:	e0bfff17 	ldw	r2,-4(fp)
81148638:	10800217 	ldw	r2,8(r2)
8114863c:	100b883a 	mov	r5,r2
81148640:	1809883a 	mov	r4,r3
81148644:	1148c500 	call	81148c50 <altera_avalon_jtag_uart_close>
}
81148648:	e037883a 	mov	sp,fp
8114864c:	dfc00117 	ldw	ra,4(sp)
81148650:	df000017 	ldw	fp,0(sp)
81148654:	dec00204 	addi	sp,sp,8
81148658:	f800283a 	ret

8114865c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
8114865c:	defffa04 	addi	sp,sp,-24
81148660:	de00012e 	bgeu	sp,et,81148668 <altera_avalon_jtag_uart_ioctl_fd+0xc>
81148664:	003b68fa 	trap	3
81148668:	dfc00515 	stw	ra,20(sp)
8114866c:	df000415 	stw	fp,16(sp)
81148670:	df000404 	addi	fp,sp,16
81148674:	e13ffd15 	stw	r4,-12(fp)
81148678:	e17ffe15 	stw	r5,-8(fp)
8114867c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81148680:	e0bffd17 	ldw	r2,-12(fp)
81148684:	10800017 	ldw	r2,0(r2)
81148688:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
8114868c:	e0bffc17 	ldw	r2,-16(fp)
81148690:	10800a04 	addi	r2,r2,40
81148694:	e1bfff17 	ldw	r6,-4(fp)
81148698:	e17ffe17 	ldw	r5,-8(fp)
8114869c:	1009883a 	mov	r4,r2
811486a0:	1148cc00 	call	81148cc0 <altera_avalon_jtag_uart_ioctl>
}
811486a4:	e037883a 	mov	sp,fp
811486a8:	dfc00117 	ldw	ra,4(sp)
811486ac:	df000017 	ldw	fp,0(sp)
811486b0:	dec00204 	addi	sp,sp,8
811486b4:	f800283a 	ret

811486b8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
811486b8:	deffef04 	addi	sp,sp,-68
811486bc:	de00012e 	bgeu	sp,et,811486c4 <altera_avalon_jtag_uart_init+0xc>
811486c0:	003b68fa 	trap	3
811486c4:	dfc01015 	stw	ra,64(sp)
811486c8:	df000f15 	stw	fp,60(sp)
811486cc:	dc400e15 	stw	r17,56(sp)
811486d0:	dc000d15 	stw	r16,52(sp)
811486d4:	df000f04 	addi	fp,sp,60
811486d8:	e13ff715 	stw	r4,-36(fp)
811486dc:	e17ff815 	stw	r5,-32(fp)
811486e0:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811486e4:	e0bff717 	ldw	r2,-36(fp)
811486e8:	10800c04 	addi	r2,r2,48
811486ec:	e0bff215 	stw	r2,-56(fp)
811486f0:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811486f4:	e0bff60b 	ldhu	r2,-40(fp)
811486f8:	e0fff684 	addi	r3,fp,-38
811486fc:	180b883a 	mov	r5,r3
81148700:	1009883a 	mov	r4,r2
81148704:	113c8880 	call	8113c888 <OSFlagCreate>
81148708:	1007883a 	mov	r3,r2
8114870c:	e0bff217 	ldw	r2,-56(fp)
81148710:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81148714:	e0bff717 	ldw	r2,-36(fp)
81148718:	10800a04 	addi	r2,r2,40
8114871c:	e0bff315 	stw	r2,-52(fp)
81148720:	00800044 	movi	r2,1
81148724:	e0bff58d 	sth	r2,-42(fp)
81148728:	e0bff58b 	ldhu	r2,-42(fp)
8114872c:	1009883a 	mov	r4,r2
81148730:	11407e40 	call	811407e4 <OSSemCreate>
81148734:	1007883a 	mov	r3,r2
81148738:	e0bff317 	ldw	r2,-52(fp)
8114873c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81148740:	e0bff717 	ldw	r2,-36(fp)
81148744:	10800b04 	addi	r2,r2,44
81148748:	e0bff415 	stw	r2,-48(fp)
8114874c:	00800044 	movi	r2,1
81148750:	e0bff50d 	sth	r2,-44(fp)
81148754:	e0bff50b 	ldhu	r2,-44(fp)
81148758:	1009883a 	mov	r4,r2
8114875c:	11407e40 	call	811407e4 <OSSemCreate>
81148760:	1007883a 	mov	r3,r2
81148764:	e0bff417 	ldw	r2,-48(fp)
81148768:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8114876c:	e0bff717 	ldw	r2,-36(fp)
81148770:	00c00044 	movi	r3,1
81148774:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81148778:	e0bff717 	ldw	r2,-36(fp)
8114877c:	10800017 	ldw	r2,0(r2)
81148780:	10800104 	addi	r2,r2,4
81148784:	1007883a 	mov	r3,r2
81148788:	e0bff717 	ldw	r2,-36(fp)
8114878c:	10800817 	ldw	r2,32(r2)
81148790:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81148794:	e0bff817 	ldw	r2,-32(fp)
81148798:	e0fff917 	ldw	r3,-28(fp)
8114879c:	d8000015 	stw	zero,0(sp)
811487a0:	e1fff717 	ldw	r7,-36(fp)
811487a4:	01a04574 	movhi	r6,33045
811487a8:	31a22204 	addi	r6,r6,-30584
811487ac:	180b883a 	mov	r5,r3
811487b0:	1009883a 	mov	r4,r2
811487b4:	114c5d00 	call	8114c5d0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
811487b8:	e0bff717 	ldw	r2,-36(fp)
811487bc:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
811487c0:	e0bff717 	ldw	r2,-36(fp)
811487c4:	10800204 	addi	r2,r2,8
811487c8:	d0e08817 	ldw	r3,-32224(gp)
811487cc:	e1fff717 	ldw	r7,-36(fp)
811487d0:	01a04574 	movhi	r6,33045
811487d4:	31a2d104 	addi	r6,r6,-29884
811487d8:	180b883a 	mov	r5,r3
811487dc:	1009883a 	mov	r4,r2
811487e0:	114c1200 	call	8114c120 <alt_alarm_start>
811487e4:	1000040e 	bge	r2,zero,811487f8 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811487e8:	e0fff717 	ldw	r3,-36(fp)
811487ec:	00a00034 	movhi	r2,32768
811487f0:	10bfffc4 	addi	r2,r2,-1
811487f4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
811487f8:	d0a08183 	ldbu	r2,-32250(gp)
811487fc:	10803fcc 	andi	r2,r2,255
81148800:	10800058 	cmpnei	r2,r2,1
81148804:	10000f1e 	bne	r2,zero,81148844 <altera_avalon_jtag_uart_init+0x18c>
81148808:	d0e08817 	ldw	r3,-32224(gp)
8114880c:	00b33374 	movhi	r2,52429
81148810:	10b33344 	addi	r2,r2,-13107
81148814:	1888383a 	mulxuu	r4,r3,r2
81148818:	1885383a 	mul	r2,r3,r2
8114881c:	1021883a 	mov	r16,r2
81148820:	2023883a 	mov	r17,r4
81148824:	8804d0fa 	srli	r2,r17,3
81148828:	e1fff717 	ldw	r7,-36(fp)
8114882c:	01a04534 	movhi	r6,33044
81148830:	31a3ee04 	addi	r6,r6,-28744
81148834:	100b883a 	mov	r5,r2
81148838:	012045f4 	movhi	r4,33047
8114883c:	21236804 	addi	r4,r4,-29280
81148840:	114c1200 	call	8114c120 <alt_alarm_start>
81148844:	d0a08203 	ldbu	r2,-32248(gp)
81148848:	10803fcc 	andi	r2,r2,255
8114884c:	10800058 	cmpnei	r2,r2,1
81148850:	1000051e 	bne	r2,zero,81148868 <altera_avalon_jtag_uart_init+0x1b0>
81148854:	e0bff717 	ldw	r2,-36(fp)
81148858:	10800017 	ldw	r2,0(r2)
8114885c:	100b883a 	mov	r5,r2
81148860:	e13ff717 	ldw	r4,-36(fp)
81148864:	11391500 	call	81139150 <alt_log_jtag_uart_startup_info>
}
81148868:	0001883a 	nop
8114886c:	e6fffe04 	addi	sp,fp,-8
81148870:	dfc00317 	ldw	ra,12(sp)
81148874:	df000217 	ldw	fp,8(sp)
81148878:	dc400117 	ldw	r17,4(sp)
8114887c:	dc000017 	ldw	r16,0(sp)
81148880:	dec00404 	addi	sp,sp,16
81148884:	f800283a 	ret

81148888 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81148888:	defff204 	addi	sp,sp,-56
8114888c:	de00012e 	bgeu	sp,et,81148894 <altera_avalon_jtag_uart_irq+0xc>
81148890:	003b68fa 	trap	3
81148894:	dfc00d15 	stw	ra,52(sp)
81148898:	df000c15 	stw	fp,48(sp)
8114889c:	df000c04 	addi	fp,sp,48
811488a0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
811488a4:	e0bfff17 	ldw	r2,-4(fp)
811488a8:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
811488ac:	e0bff617 	ldw	r2,-40(fp)
811488b0:	10800017 	ldw	r2,0(r2)
811488b4:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
811488b8:	e0bff717 	ldw	r2,-36(fp)
811488bc:	e17ff617 	ldw	r5,-40(fp)
811488c0:	1009883a 	mov	r4,r2
811488c4:	11391a40 	call	811391a4 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811488c8:	e0bff717 	ldw	r2,-36(fp)
811488cc:	10800104 	addi	r2,r2,4
811488d0:	10800037 	ldwio	r2,0(r2)
811488d4:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
811488d8:	e0bff817 	ldw	r2,-32(fp)
811488dc:	1080c00c 	andi	r2,r2,768
811488e0:	10009126 	beq	r2,zero,81148b28 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
811488e4:	e0bff817 	ldw	r2,-32(fp)
811488e8:	1080400c 	andi	r2,r2,256
811488ec:	10004726 	beq	r2,zero,81148a0c <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811488f0:	00800074 	movhi	r2,1
811488f4:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811488f8:	e0bff617 	ldw	r2,-40(fp)
811488fc:	10800d17 	ldw	r2,52(r2)
81148900:	10800044 	addi	r2,r2,1
81148904:	1081ffcc 	andi	r2,r2,2047
81148908:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
8114890c:	e0bff617 	ldw	r2,-40(fp)
81148910:	10c00e17 	ldw	r3,56(r2)
81148914:	e0bff917 	ldw	r2,-28(fp)
81148918:	18802726 	beq	r3,r2,811489b8 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
8114891c:	e0bff717 	ldw	r2,-36(fp)
81148920:	10800037 	ldwio	r2,0(r2)
81148924:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81148928:	e0bff417 	ldw	r2,-48(fp)
8114892c:	10a0000c 	andi	r2,r2,32768
81148930:	10002326 	beq	r2,zero,811489c0 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81148934:	e0bff617 	ldw	r2,-40(fp)
81148938:	10800d17 	ldw	r2,52(r2)
8114893c:	e0fff417 	ldw	r3,-48(fp)
81148940:	1809883a 	mov	r4,r3
81148944:	e0fff617 	ldw	r3,-40(fp)
81148948:	1885883a 	add	r2,r3,r2
8114894c:	10801104 	addi	r2,r2,68
81148950:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148954:	e0bff617 	ldw	r2,-40(fp)
81148958:	10800d17 	ldw	r2,52(r2)
8114895c:	10800044 	addi	r2,r2,1
81148960:	10c1ffcc 	andi	r3,r2,2047
81148964:	e0bff617 	ldw	r2,-40(fp)
81148968:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
8114896c:	e0bff617 	ldw	r2,-40(fp)
81148970:	10800c17 	ldw	r2,48(r2)
81148974:	e0bffb15 	stw	r2,-20(fp)
81148978:	00800044 	movi	r2,1
8114897c:	e0bffc0d 	sth	r2,-16(fp)
81148980:	00800044 	movi	r2,1
81148984:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148988:	d0a09103 	ldbu	r2,-32188(gp)
8114898c:	10803fcc 	andi	r2,r2,255
81148990:	103fd926 	beq	r2,zero,811488f8 <__reset+0xfb1288f8>
  {
    OSFlagPost (group, flags, opt, &err);
81148994:	e0bffc0b 	ldhu	r2,-16(fp)
81148998:	e0fffc83 	ldbu	r3,-14(fp)
8114899c:	e13ffdc4 	addi	r4,fp,-9
811489a0:	200f883a 	mov	r7,r4
811489a4:	180d883a 	mov	r6,r3
811489a8:	100b883a 	mov	r5,r2
811489ac:	e13ffb17 	ldw	r4,-20(fp)
811489b0:	113d4940 	call	8113d494 <OSFlagPost>
      }
811489b4:	003fd006 	br	811488f8 <__reset+0xfb1288f8>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
811489b8:	0001883a 	nop
811489bc:	00000106 	br	811489c4 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
811489c0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
811489c4:	e0bff417 	ldw	r2,-48(fp)
811489c8:	10bfffec 	andhi	r2,r2,65535
811489cc:	10000f26 	beq	r2,zero,81148a0c <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811489d0:	e0bff617 	ldw	r2,-40(fp)
811489d4:	10c00817 	ldw	r3,32(r2)
811489d8:	00bfff84 	movi	r2,-2
811489dc:	1886703a 	and	r3,r3,r2
811489e0:	e0bff617 	ldw	r2,-40(fp)
811489e4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811489e8:	e0bff717 	ldw	r2,-36(fp)
811489ec:	10800104 	addi	r2,r2,4
811489f0:	1007883a 	mov	r3,r2
811489f4:	e0bff617 	ldw	r2,-40(fp)
811489f8:	10800817 	ldw	r2,32(r2)
811489fc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81148a00:	e0bff717 	ldw	r2,-36(fp)
81148a04:	10800104 	addi	r2,r2,4
81148a08:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81148a0c:	e0bff817 	ldw	r2,-32(fp)
81148a10:	1080800c 	andi	r2,r2,512
81148a14:	103fac26 	beq	r2,zero,811488c8 <__reset+0xfb1288c8>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81148a18:	e0bff817 	ldw	r2,-32(fp)
81148a1c:	1004d43a 	srli	r2,r2,16
81148a20:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81148a24:	00002606 	br	81148ac0 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81148a28:	e0bff717 	ldw	r2,-36(fp)
81148a2c:	e0fff617 	ldw	r3,-40(fp)
81148a30:	18c01017 	ldw	r3,64(r3)
81148a34:	e13ff617 	ldw	r4,-40(fp)
81148a38:	20c7883a 	add	r3,r4,r3
81148a3c:	18c21104 	addi	r3,r3,2116
81148a40:	18c00003 	ldbu	r3,0(r3)
81148a44:	18c03fcc 	andi	r3,r3,255
81148a48:	18c0201c 	xori	r3,r3,128
81148a4c:	18ffe004 	addi	r3,r3,-128
81148a50:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148a54:	e0bff617 	ldw	r2,-40(fp)
81148a58:	10801017 	ldw	r2,64(r2)
81148a5c:	10800044 	addi	r2,r2,1
81148a60:	10c1ffcc 	andi	r3,r2,2047
81148a64:	e0bff617 	ldw	r2,-40(fp)
81148a68:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81148a6c:	e0bff617 	ldw	r2,-40(fp)
81148a70:	10800c17 	ldw	r2,48(r2)
81148a74:	e0bffa15 	stw	r2,-24(fp)
81148a78:	00800084 	movi	r2,2
81148a7c:	e0bffd0d 	sth	r2,-12(fp)
81148a80:	00800044 	movi	r2,1
81148a84:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148a88:	d0a09103 	ldbu	r2,-32188(gp)
81148a8c:	10803fcc 	andi	r2,r2,255
81148a90:	10000826 	beq	r2,zero,81148ab4 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81148a94:	e0bffd0b 	ldhu	r2,-12(fp)
81148a98:	e0fffd83 	ldbu	r3,-10(fp)
81148a9c:	e13ffe04 	addi	r4,fp,-8
81148aa0:	200f883a 	mov	r7,r4
81148aa4:	180d883a 	mov	r6,r3
81148aa8:	100b883a 	mov	r5,r2
81148aac:	e13ffa17 	ldw	r4,-24(fp)
81148ab0:	113d4940 	call	8113d494 <OSFlagPost>

        space--;
81148ab4:	e0bff517 	ldw	r2,-44(fp)
81148ab8:	10bfffc4 	addi	r2,r2,-1
81148abc:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81148ac0:	e0bff517 	ldw	r2,-44(fp)
81148ac4:	10000526 	beq	r2,zero,81148adc <altera_avalon_jtag_uart_irq+0x254>
81148ac8:	e0bff617 	ldw	r2,-40(fp)
81148acc:	10c01017 	ldw	r3,64(r2)
81148ad0:	e0bff617 	ldw	r2,-40(fp)
81148ad4:	10800f17 	ldw	r2,60(r2)
81148ad8:	18bfd31e 	bne	r3,r2,81148a28 <__reset+0xfb128a28>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81148adc:	e0bff517 	ldw	r2,-44(fp)
81148ae0:	103f7926 	beq	r2,zero,811488c8 <__reset+0xfb1288c8>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81148ae4:	e0bff617 	ldw	r2,-40(fp)
81148ae8:	10c00817 	ldw	r3,32(r2)
81148aec:	00bfff44 	movi	r2,-3
81148af0:	1886703a 	and	r3,r3,r2
81148af4:	e0bff617 	ldw	r2,-40(fp)
81148af8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81148afc:	e0bff617 	ldw	r2,-40(fp)
81148b00:	10800017 	ldw	r2,0(r2)
81148b04:	10800104 	addi	r2,r2,4
81148b08:	1007883a 	mov	r3,r2
81148b0c:	e0bff617 	ldw	r2,-40(fp)
81148b10:	10800817 	ldw	r2,32(r2)
81148b14:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81148b18:	e0bff717 	ldw	r2,-36(fp)
81148b1c:	10800104 	addi	r2,r2,4
81148b20:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81148b24:	003f6806 	br	811488c8 <__reset+0xfb1288c8>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81148b28:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81148b2c:	0001883a 	nop
81148b30:	e037883a 	mov	sp,fp
81148b34:	dfc00117 	ldw	ra,4(sp)
81148b38:	df000017 	ldw	fp,0(sp)
81148b3c:	dec00204 	addi	sp,sp,8
81148b40:	f800283a 	ret

81148b44 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81148b44:	defff904 	addi	sp,sp,-28
81148b48:	de00012e 	bgeu	sp,et,81148b50 <altera_avalon_jtag_uart_timeout+0xc>
81148b4c:	003b68fa 	trap	3
81148b50:	dfc00615 	stw	ra,24(sp)
81148b54:	df000515 	stw	fp,20(sp)
81148b58:	df000504 	addi	fp,sp,20
81148b5c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81148b60:	e0bfff17 	ldw	r2,-4(fp)
81148b64:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81148b68:	e0bffb17 	ldw	r2,-20(fp)
81148b6c:	10800017 	ldw	r2,0(r2)
81148b70:	10800104 	addi	r2,r2,4
81148b74:	10800037 	ldwio	r2,0(r2)
81148b78:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81148b7c:	e0bffc17 	ldw	r2,-16(fp)
81148b80:	1081000c 	andi	r2,r2,1024
81148b84:	10000b26 	beq	r2,zero,81148bb4 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81148b88:	e0bffb17 	ldw	r2,-20(fp)
81148b8c:	10800017 	ldw	r2,0(r2)
81148b90:	10800104 	addi	r2,r2,4
81148b94:	1007883a 	mov	r3,r2
81148b98:	e0bffb17 	ldw	r2,-20(fp)
81148b9c:	10800817 	ldw	r2,32(r2)
81148ba0:	10810014 	ori	r2,r2,1024
81148ba4:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81148ba8:	e0bffb17 	ldw	r2,-20(fp)
81148bac:	10000915 	stw	zero,36(r2)
81148bb0:	00002106 	br	81148c38 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81148bb4:	e0bffb17 	ldw	r2,-20(fp)
81148bb8:	10c00917 	ldw	r3,36(r2)
81148bbc:	00a00034 	movhi	r2,32768
81148bc0:	10bfff04 	addi	r2,r2,-4
81148bc4:	10c01c36 	bltu	r2,r3,81148c38 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81148bc8:	e0bffb17 	ldw	r2,-20(fp)
81148bcc:	10800917 	ldw	r2,36(r2)
81148bd0:	10c00044 	addi	r3,r2,1
81148bd4:	e0bffb17 	ldw	r2,-20(fp)
81148bd8:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81148bdc:	e0bffb17 	ldw	r2,-20(fp)
81148be0:	10c00917 	ldw	r3,36(r2)
81148be4:	e0bffb17 	ldw	r2,-20(fp)
81148be8:	10800117 	ldw	r2,4(r2)
81148bec:	18801236 	bltu	r3,r2,81148c38 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81148bf0:	e0bffb17 	ldw	r2,-20(fp)
81148bf4:	10800c17 	ldw	r2,48(r2)
81148bf8:	e0bffd15 	stw	r2,-12(fp)
81148bfc:	00800104 	movi	r2,4
81148c00:	e0bffe0d 	sth	r2,-8(fp)
81148c04:	00800044 	movi	r2,1
81148c08:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148c0c:	d0a09103 	ldbu	r2,-32188(gp)
81148c10:	10803fcc 	andi	r2,r2,255
81148c14:	10000826 	beq	r2,zero,81148c38 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81148c18:	e0bffe0b 	ldhu	r2,-8(fp)
81148c1c:	e0fffe83 	ldbu	r3,-6(fp)
81148c20:	e13ffec4 	addi	r4,fp,-5
81148c24:	200f883a 	mov	r7,r4
81148c28:	180d883a 	mov	r6,r3
81148c2c:	100b883a 	mov	r5,r2
81148c30:	e13ffd17 	ldw	r4,-12(fp)
81148c34:	113d4940 	call	8113d494 <OSFlagPost>
81148c38:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
81148c3c:	e037883a 	mov	sp,fp
81148c40:	dfc00117 	ldw	ra,4(sp)
81148c44:	df000017 	ldw	fp,0(sp)
81148c48:	dec00204 	addi	sp,sp,8
81148c4c:	f800283a 	ret

81148c50 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81148c50:	defffd04 	addi	sp,sp,-12
81148c54:	de00012e 	bgeu	sp,et,81148c5c <altera_avalon_jtag_uart_close+0xc>
81148c58:	003b68fa 	trap	3
81148c5c:	df000215 	stw	fp,8(sp)
81148c60:	df000204 	addi	fp,sp,8
81148c64:	e13ffe15 	stw	r4,-8(fp)
81148c68:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81148c6c:	00000506 	br	81148c84 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81148c70:	e0bfff17 	ldw	r2,-4(fp)
81148c74:	1090000c 	andi	r2,r2,16384
81148c78:	10000226 	beq	r2,zero,81148c84 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81148c7c:	00bffd44 	movi	r2,-11
81148c80:	00000b06 	br	81148cb0 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81148c84:	e0bffe17 	ldw	r2,-8(fp)
81148c88:	10c01017 	ldw	r3,64(r2)
81148c8c:	e0bffe17 	ldw	r2,-8(fp)
81148c90:	10800f17 	ldw	r2,60(r2)
81148c94:	18800526 	beq	r3,r2,81148cac <altera_avalon_jtag_uart_close+0x5c>
81148c98:	e0bffe17 	ldw	r2,-8(fp)
81148c9c:	10c00917 	ldw	r3,36(r2)
81148ca0:	e0bffe17 	ldw	r2,-8(fp)
81148ca4:	10800117 	ldw	r2,4(r2)
81148ca8:	18bff136 	bltu	r3,r2,81148c70 <__reset+0xfb128c70>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81148cac:	0005883a 	mov	r2,zero
}
81148cb0:	e037883a 	mov	sp,fp
81148cb4:	df000017 	ldw	fp,0(sp)
81148cb8:	dec00104 	addi	sp,sp,4
81148cbc:	f800283a 	ret

81148cc0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81148cc0:	defffa04 	addi	sp,sp,-24
81148cc4:	de00012e 	bgeu	sp,et,81148ccc <altera_avalon_jtag_uart_ioctl+0xc>
81148cc8:	003b68fa 	trap	3
81148ccc:	df000515 	stw	fp,20(sp)
81148cd0:	df000504 	addi	fp,sp,20
81148cd4:	e13ffd15 	stw	r4,-12(fp)
81148cd8:	e17ffe15 	stw	r5,-8(fp)
81148cdc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81148ce0:	00bff9c4 	movi	r2,-25
81148ce4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81148ce8:	e0bffe17 	ldw	r2,-8(fp)
81148cec:	10da8060 	cmpeqi	r3,r2,27137
81148cf0:	1800031e 	bne	r3,zero,81148d00 <altera_avalon_jtag_uart_ioctl+0x40>
81148cf4:	109a80a0 	cmpeqi	r2,r2,27138
81148cf8:	1000181e 	bne	r2,zero,81148d5c <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81148cfc:	00002906 	br	81148da4 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81148d00:	e0bffd17 	ldw	r2,-12(fp)
81148d04:	10c00117 	ldw	r3,4(r2)
81148d08:	00a00034 	movhi	r2,32768
81148d0c:	10bfffc4 	addi	r2,r2,-1
81148d10:	18802126 	beq	r3,r2,81148d98 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81148d14:	e0bfff17 	ldw	r2,-4(fp)
81148d18:	10800017 	ldw	r2,0(r2)
81148d1c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81148d20:	e0bffc17 	ldw	r2,-16(fp)
81148d24:	10800090 	cmplti	r2,r2,2
81148d28:	1000061e 	bne	r2,zero,81148d44 <altera_avalon_jtag_uart_ioctl+0x84>
81148d2c:	e0fffc17 	ldw	r3,-16(fp)
81148d30:	00a00034 	movhi	r2,32768
81148d34:	10bfffc4 	addi	r2,r2,-1
81148d38:	18800226 	beq	r3,r2,81148d44 <altera_avalon_jtag_uart_ioctl+0x84>
81148d3c:	e0bffc17 	ldw	r2,-16(fp)
81148d40:	00000206 	br	81148d4c <altera_avalon_jtag_uart_ioctl+0x8c>
81148d44:	00a00034 	movhi	r2,32768
81148d48:	10bfff84 	addi	r2,r2,-2
81148d4c:	e0fffd17 	ldw	r3,-12(fp)
81148d50:	18800115 	stw	r2,4(r3)
      rc = 0;
81148d54:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81148d58:	00000f06 	br	81148d98 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81148d5c:	e0bffd17 	ldw	r2,-12(fp)
81148d60:	10c00117 	ldw	r3,4(r2)
81148d64:	00a00034 	movhi	r2,32768
81148d68:	10bfffc4 	addi	r2,r2,-1
81148d6c:	18800c26 	beq	r3,r2,81148da0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81148d70:	e0bffd17 	ldw	r2,-12(fp)
81148d74:	10c00917 	ldw	r3,36(r2)
81148d78:	e0bffd17 	ldw	r2,-12(fp)
81148d7c:	10800117 	ldw	r2,4(r2)
81148d80:	1885803a 	cmpltu	r2,r3,r2
81148d84:	10c03fcc 	andi	r3,r2,255
81148d88:	e0bfff17 	ldw	r2,-4(fp)
81148d8c:	10c00015 	stw	r3,0(r2)
      rc = 0;
81148d90:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81148d94:	00000206 	br	81148da0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81148d98:	0001883a 	nop
81148d9c:	00000106 	br	81148da4 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81148da0:	0001883a 	nop

  default:
    break;
  }

  return rc;
81148da4:	e0bffb17 	ldw	r2,-20(fp)
}
81148da8:	e037883a 	mov	sp,fp
81148dac:	df000017 	ldw	fp,0(sp)
81148db0:	dec00104 	addi	sp,sp,4
81148db4:	f800283a 	ret

81148db8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81148db8:	deffed04 	addi	sp,sp,-76
81148dbc:	de00012e 	bgeu	sp,et,81148dc4 <altera_avalon_jtag_uart_read+0xc>
81148dc0:	003b68fa 	trap	3
81148dc4:	dfc01215 	stw	ra,72(sp)
81148dc8:	df001115 	stw	fp,68(sp)
81148dcc:	df001104 	addi	fp,sp,68
81148dd0:	e13ffc15 	stw	r4,-16(fp)
81148dd4:	e17ffd15 	stw	r5,-12(fp)
81148dd8:	e1bffe15 	stw	r6,-8(fp)
81148ddc:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81148de0:	e0bffd17 	ldw	r2,-12(fp)
81148de4:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81148de8:	e0bffc17 	ldw	r2,-16(fp)
81148dec:	10800a17 	ldw	r2,40(r2)
81148df0:	e0bff815 	stw	r2,-32(fp)
81148df4:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81148df8:	e0bff90b 	ldhu	r2,-28(fp)
81148dfc:	e0fffb04 	addi	r3,fp,-20
81148e00:	180d883a 	mov	r6,r3
81148e04:	100b883a 	mov	r5,r2
81148e08:	e13ff817 	ldw	r4,-32(fp)
81148e0c:	1140b0c0 	call	81140b0c <OSSemPend>

  while (space > 0)
81148e10:	00006106 	br	81148f98 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81148e14:	e0bffc17 	ldw	r2,-16(fp)
81148e18:	10800d17 	ldw	r2,52(r2)
81148e1c:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81148e20:	e0bffc17 	ldw	r2,-16(fp)
81148e24:	10800e17 	ldw	r2,56(r2)
81148e28:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81148e2c:	e0fff317 	ldw	r3,-52(fp)
81148e30:	e0bff417 	ldw	r2,-48(fp)
81148e34:	18800536 	bltu	r3,r2,81148e4c <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81148e38:	e0fff317 	ldw	r3,-52(fp)
81148e3c:	e0bff417 	ldw	r2,-48(fp)
81148e40:	1885c83a 	sub	r2,r3,r2
81148e44:	e0bff115 	stw	r2,-60(fp)
81148e48:	00000406 	br	81148e5c <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81148e4c:	00c20004 	movi	r3,2048
81148e50:	e0bff417 	ldw	r2,-48(fp)
81148e54:	1885c83a 	sub	r2,r3,r2
81148e58:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81148e5c:	e0bff117 	ldw	r2,-60(fp)
81148e60:	10001e26 	beq	r2,zero,81148edc <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81148e64:	e0fffe17 	ldw	r3,-8(fp)
81148e68:	e0bff117 	ldw	r2,-60(fp)
81148e6c:	1880022e 	bgeu	r3,r2,81148e78 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81148e70:	e0bffe17 	ldw	r2,-8(fp)
81148e74:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81148e78:	e0bffc17 	ldw	r2,-16(fp)
81148e7c:	10c01104 	addi	r3,r2,68
81148e80:	e0bff417 	ldw	r2,-48(fp)
81148e84:	1885883a 	add	r2,r3,r2
81148e88:	e1bff117 	ldw	r6,-60(fp)
81148e8c:	100b883a 	mov	r5,r2
81148e90:	e13ff017 	ldw	r4,-64(fp)
81148e94:	11247000 	call	81124700 <memcpy>
      ptr   += n;
81148e98:	e0fff017 	ldw	r3,-64(fp)
81148e9c:	e0bff117 	ldw	r2,-60(fp)
81148ea0:	1885883a 	add	r2,r3,r2
81148ea4:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81148ea8:	e0fffe17 	ldw	r3,-8(fp)
81148eac:	e0bff117 	ldw	r2,-60(fp)
81148eb0:	1885c83a 	sub	r2,r3,r2
81148eb4:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148eb8:	e0fff417 	ldw	r3,-48(fp)
81148ebc:	e0bff117 	ldw	r2,-60(fp)
81148ec0:	1885883a 	add	r2,r3,r2
81148ec4:	10c1ffcc 	andi	r3,r2,2047
81148ec8:	e0bffc17 	ldw	r2,-16(fp)
81148ecc:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81148ed0:	e0bffe17 	ldw	r2,-8(fp)
81148ed4:	00bfcf16 	blt	zero,r2,81148e14 <__reset+0xfb128e14>
81148ed8:	00000106 	br	81148ee0 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81148edc:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81148ee0:	e0fff017 	ldw	r3,-64(fp)
81148ee4:	e0bffd17 	ldw	r2,-12(fp)
81148ee8:	18802e1e 	bne	r3,r2,81148fa4 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81148eec:	e0bfff17 	ldw	r2,-4(fp)
81148ef0:	1090000c 	andi	r2,r2,16384
81148ef4:	10002d1e 	bne	r2,zero,81148fac <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81148ef8:	d0a09103 	ldbu	r2,-32188(gp)
81148efc:	10803fcc 	andi	r2,r2,255
81148f00:	10800058 	cmpnei	r2,r2,1
81148f04:	1000161e 	bne	r2,zero,81148f60 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81148f08:	e0bffc17 	ldw	r2,-16(fp)
81148f0c:	10800c17 	ldw	r2,48(r2)
81148f10:	e0bff215 	stw	r2,-56(fp)
81148f14:	00800144 	movi	r2,5
81148f18:	e0bff98d 	sth	r2,-26(fp)
81148f1c:	00bfe0c4 	movi	r2,-125
81148f20:	e0bffa05 	stb	r2,-24(fp)
81148f24:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148f28:	d0a09103 	ldbu	r2,-32188(gp)
81148f2c:	10803fcc 	andi	r2,r2,255
81148f30:	10001526 	beq	r2,zero,81148f88 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81148f34:	e0fff98b 	ldhu	r3,-26(fp)
81148f38:	e13ffa03 	ldbu	r4,-24(fp)
81148f3c:	e17ffa8b 	ldhu	r5,-22(fp)
81148f40:	e0bffb44 	addi	r2,fp,-19
81148f44:	d8800015 	stw	r2,0(sp)
81148f48:	280f883a 	mov	r7,r5
81148f4c:	200d883a 	mov	r6,r4
81148f50:	180b883a 	mov	r5,r3
81148f54:	e13ff217 	ldw	r4,-56(fp)
81148f58:	113ce6c0 	call	8113ce6c <OSFlagPend>
81148f5c:	00000a06 	br	81148f88 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81148f60:	0001883a 	nop
81148f64:	e0bffc17 	ldw	r2,-16(fp)
81148f68:	10c00d17 	ldw	r3,52(r2)
81148f6c:	e0bff317 	ldw	r2,-52(fp)
81148f70:	1880051e 	bne	r3,r2,81148f88 <altera_avalon_jtag_uart_read+0x1d0>
81148f74:	e0bffc17 	ldw	r2,-16(fp)
81148f78:	10c00917 	ldw	r3,36(r2)
81148f7c:	e0bffc17 	ldw	r2,-16(fp)
81148f80:	10800117 	ldw	r2,4(r2)
81148f84:	18bff736 	bltu	r3,r2,81148f64 <__reset+0xfb128f64>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81148f88:	e0bffc17 	ldw	r2,-16(fp)
81148f8c:	10c00d17 	ldw	r3,52(r2)
81148f90:	e0bff317 	ldw	r2,-52(fp)
81148f94:	18800726 	beq	r3,r2,81148fb4 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81148f98:	e0bffe17 	ldw	r2,-8(fp)
81148f9c:	00bf9d16 	blt	zero,r2,81148e14 <__reset+0xfb128e14>
81148fa0:	00000506 	br	81148fb8 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81148fa4:	0001883a 	nop
81148fa8:	00000306 	br	81148fb8 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81148fac:	0001883a 	nop
81148fb0:	00000106 	br	81148fb8 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81148fb4:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81148fb8:	e0bffc17 	ldw	r2,-16(fp)
81148fbc:	10800a17 	ldw	r2,40(r2)
81148fc0:	1009883a 	mov	r4,r2
81148fc4:	1140e940 	call	81140e94 <OSSemPost>

  if (ptr != buffer)
81148fc8:	e0fff017 	ldw	r3,-64(fp)
81148fcc:	e0bffd17 	ldw	r2,-12(fp)
81148fd0:	18801826 	beq	r3,r2,81149034 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148fd4:	0005303a 	rdctl	r2,status
81148fd8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148fdc:	e0fff717 	ldw	r3,-36(fp)
81148fe0:	00bfff84 	movi	r2,-2
81148fe4:	1884703a 	and	r2,r3,r2
81148fe8:	1001703a 	wrctl	status,r2
  
  return context;
81148fec:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81148ff0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81148ff4:	e0bffc17 	ldw	r2,-16(fp)
81148ff8:	10800817 	ldw	r2,32(r2)
81148ffc:	10c00054 	ori	r3,r2,1
81149000:	e0bffc17 	ldw	r2,-16(fp)
81149004:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81149008:	e0bffc17 	ldw	r2,-16(fp)
8114900c:	10800017 	ldw	r2,0(r2)
81149010:	10800104 	addi	r2,r2,4
81149014:	1007883a 	mov	r3,r2
81149018:	e0bffc17 	ldw	r2,-16(fp)
8114901c:	10800817 	ldw	r2,32(r2)
81149020:	18800035 	stwio	r2,0(r3)
81149024:	e0bff617 	ldw	r2,-40(fp)
81149028:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114902c:	e0bff517 	ldw	r2,-44(fp)
81149030:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81149034:	e0fff017 	ldw	r3,-64(fp)
81149038:	e0bffd17 	ldw	r2,-12(fp)
8114903c:	18800426 	beq	r3,r2,81149050 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81149040:	e0fff017 	ldw	r3,-64(fp)
81149044:	e0bffd17 	ldw	r2,-12(fp)
81149048:	1885c83a 	sub	r2,r3,r2
8114904c:	00000606 	br	81149068 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81149050:	e0bfff17 	ldw	r2,-4(fp)
81149054:	1090000c 	andi	r2,r2,16384
81149058:	10000226 	beq	r2,zero,81149064 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
8114905c:	00bffd44 	movi	r2,-11
81149060:	00000106 	br	81149068 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81149064:	00bffec4 	movi	r2,-5
}
81149068:	e037883a 	mov	sp,fp
8114906c:	dfc00117 	ldw	ra,4(sp)
81149070:	df000017 	ldw	fp,0(sp)
81149074:	dec00204 	addi	sp,sp,8
81149078:	f800283a 	ret

8114907c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
8114907c:	deffed04 	addi	sp,sp,-76
81149080:	de00012e 	bgeu	sp,et,81149088 <altera_avalon_jtag_uart_write+0xc>
81149084:	003b68fa 	trap	3
81149088:	dfc01215 	stw	ra,72(sp)
8114908c:	df001115 	stw	fp,68(sp)
81149090:	df001104 	addi	fp,sp,68
81149094:	e13ffc15 	stw	r4,-16(fp)
81149098:	e17ffd15 	stw	r5,-12(fp)
8114909c:	e1bffe15 	stw	r6,-8(fp)
811490a0:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
811490a4:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
811490a8:	e0bffd17 	ldw	r2,-12(fp)
811490ac:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
811490b0:	e0bffc17 	ldw	r2,-16(fp)
811490b4:	10800b17 	ldw	r2,44(r2)
811490b8:	e0bff815 	stw	r2,-32(fp)
811490bc:	e03ff90d 	sth	zero,-28(fp)
811490c0:	e0bff90b 	ldhu	r2,-28(fp)
811490c4:	e0fffb44 	addi	r3,fp,-19
811490c8:	180d883a 	mov	r6,r3
811490cc:	100b883a 	mov	r5,r2
811490d0:	e13ff817 	ldw	r4,-32(fp)
811490d4:	1140b0c0 	call	81140b0c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811490d8:	00003706 	br	811491b8 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
811490dc:	e0bffc17 	ldw	r2,-16(fp)
811490e0:	10800f17 	ldw	r2,60(r2)
811490e4:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811490e8:	e0bffc17 	ldw	r2,-16(fp)
811490ec:	10801017 	ldw	r2,64(r2)
811490f0:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
811490f4:	e0fff417 	ldw	r3,-48(fp)
811490f8:	e0bff017 	ldw	r2,-64(fp)
811490fc:	1880062e 	bgeu	r3,r2,81149118 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81149100:	e0fff017 	ldw	r3,-64(fp)
81149104:	e0bff417 	ldw	r2,-48(fp)
81149108:	1885c83a 	sub	r2,r3,r2
8114910c:	10bfffc4 	addi	r2,r2,-1
81149110:	e0bff115 	stw	r2,-60(fp)
81149114:	00000b06 	br	81149144 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81149118:	e0bff017 	ldw	r2,-64(fp)
8114911c:	10000526 	beq	r2,zero,81149134 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81149120:	00c20004 	movi	r3,2048
81149124:	e0bff417 	ldw	r2,-48(fp)
81149128:	1885c83a 	sub	r2,r3,r2
8114912c:	e0bff115 	stw	r2,-60(fp)
81149130:	00000406 	br	81149144 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81149134:	00c1ffc4 	movi	r3,2047
81149138:	e0bff417 	ldw	r2,-48(fp)
8114913c:	1885c83a 	sub	r2,r3,r2
81149140:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81149144:	e0bff117 	ldw	r2,-60(fp)
81149148:	10001e26 	beq	r2,zero,811491c4 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
8114914c:	e0fffe17 	ldw	r3,-8(fp)
81149150:	e0bff117 	ldw	r2,-60(fp)
81149154:	1880022e 	bgeu	r3,r2,81149160 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81149158:	e0bffe17 	ldw	r2,-8(fp)
8114915c:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81149160:	e0bffc17 	ldw	r2,-16(fp)
81149164:	10c21104 	addi	r3,r2,2116
81149168:	e0bff417 	ldw	r2,-48(fp)
8114916c:	1885883a 	add	r2,r3,r2
81149170:	e1bff117 	ldw	r6,-60(fp)
81149174:	e17ffd17 	ldw	r5,-12(fp)
81149178:	1009883a 	mov	r4,r2
8114917c:	11247000 	call	81124700 <memcpy>
      ptr   += n;
81149180:	e0fffd17 	ldw	r3,-12(fp)
81149184:	e0bff117 	ldw	r2,-60(fp)
81149188:	1885883a 	add	r2,r3,r2
8114918c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81149190:	e0fffe17 	ldw	r3,-8(fp)
81149194:	e0bff117 	ldw	r2,-60(fp)
81149198:	1885c83a 	sub	r2,r3,r2
8114919c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811491a0:	e0fff417 	ldw	r3,-48(fp)
811491a4:	e0bff117 	ldw	r2,-60(fp)
811491a8:	1885883a 	add	r2,r3,r2
811491ac:	10c1ffcc 	andi	r3,r2,2047
811491b0:	e0bffc17 	ldw	r2,-16(fp)
811491b4:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811491b8:	e0bffe17 	ldw	r2,-8(fp)
811491bc:	00bfc716 	blt	zero,r2,811490dc <__reset+0xfb1290dc>
811491c0:	00000106 	br	811491c8 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
811491c4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811491c8:	0005303a 	rdctl	r2,status
811491cc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811491d0:	e0fff717 	ldw	r3,-36(fp)
811491d4:	00bfff84 	movi	r2,-2
811491d8:	1884703a 	and	r2,r3,r2
811491dc:	1001703a 	wrctl	status,r2
  
  return context;
811491e0:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811491e4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811491e8:	e0bffc17 	ldw	r2,-16(fp)
811491ec:	10800817 	ldw	r2,32(r2)
811491f0:	10c00094 	ori	r3,r2,2
811491f4:	e0bffc17 	ldw	r2,-16(fp)
811491f8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811491fc:	e0bffc17 	ldw	r2,-16(fp)
81149200:	10800017 	ldw	r2,0(r2)
81149204:	10800104 	addi	r2,r2,4
81149208:	1007883a 	mov	r3,r2
8114920c:	e0bffc17 	ldw	r2,-16(fp)
81149210:	10800817 	ldw	r2,32(r2)
81149214:	18800035 	stwio	r2,0(r3)
81149218:	e0bff617 	ldw	r2,-40(fp)
8114921c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149220:	e0bff317 	ldw	r2,-52(fp)
81149224:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81149228:	e0bffe17 	ldw	r2,-8(fp)
8114922c:	00802a0e 	bge	zero,r2,811492d8 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81149230:	e0bfff17 	ldw	r2,-4(fp)
81149234:	1090000c 	andi	r2,r2,16384
81149238:	10002a1e 	bne	r2,zero,811492e4 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
8114923c:	d0a09103 	ldbu	r2,-32188(gp)
81149240:	10803fcc 	andi	r2,r2,255
81149244:	10800058 	cmpnei	r2,r2,1
81149248:	1000161e 	bne	r2,zero,811492a4 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
8114924c:	e0bffc17 	ldw	r2,-16(fp)
81149250:	10800c17 	ldw	r2,48(r2)
81149254:	e0bff515 	stw	r2,-44(fp)
81149258:	00800184 	movi	r2,6
8114925c:	e0bff98d 	sth	r2,-26(fp)
81149260:	00bfe0c4 	movi	r2,-125
81149264:	e0bffa05 	stb	r2,-24(fp)
81149268:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8114926c:	d0a09103 	ldbu	r2,-32188(gp)
81149270:	10803fcc 	andi	r2,r2,255
81149274:	10001526 	beq	r2,zero,811492cc <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81149278:	e0fff98b 	ldhu	r3,-26(fp)
8114927c:	e13ffa03 	ldbu	r4,-24(fp)
81149280:	e17ffa8b 	ldhu	r5,-22(fp)
81149284:	e0bffb04 	addi	r2,fp,-20
81149288:	d8800015 	stw	r2,0(sp)
8114928c:	280f883a 	mov	r7,r5
81149290:	200d883a 	mov	r6,r4
81149294:	180b883a 	mov	r5,r3
81149298:	e13ff517 	ldw	r4,-44(fp)
8114929c:	113ce6c0 	call	8113ce6c <OSFlagPend>
811492a0:	00000a06 	br	811492cc <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
811492a4:	0001883a 	nop
811492a8:	e0bffc17 	ldw	r2,-16(fp)
811492ac:	10c01017 	ldw	r3,64(r2)
811492b0:	e0bff017 	ldw	r2,-64(fp)
811492b4:	1880051e 	bne	r3,r2,811492cc <altera_avalon_jtag_uart_write+0x250>
811492b8:	e0bffc17 	ldw	r2,-16(fp)
811492bc:	10c00917 	ldw	r3,36(r2)
811492c0:	e0bffc17 	ldw	r2,-16(fp)
811492c4:	10800117 	ldw	r2,4(r2)
811492c8:	18bff736 	bltu	r3,r2,811492a8 <__reset+0xfb1292a8>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
811492cc:	e0bffc17 	ldw	r2,-16(fp)
811492d0:	10800917 	ldw	r2,36(r2)
811492d4:	1000051e 	bne	r2,zero,811492ec <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811492d8:	e0bffe17 	ldw	r2,-8(fp)
811492dc:	00bfb616 	blt	zero,r2,811491b8 <__reset+0xfb1291b8>
811492e0:	00000306 	br	811492f0 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811492e4:	0001883a 	nop
811492e8:	00000106 	br	811492f0 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811492ec:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811492f0:	e0bffc17 	ldw	r2,-16(fp)
811492f4:	10800b17 	ldw	r2,44(r2)
811492f8:	1009883a 	mov	r4,r2
811492fc:	1140e940 	call	81140e94 <OSSemPost>

  if (ptr != start)
81149300:	e0fffd17 	ldw	r3,-12(fp)
81149304:	e0bff217 	ldw	r2,-56(fp)
81149308:	18800426 	beq	r3,r2,8114931c <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
8114930c:	e0fffd17 	ldw	r3,-12(fp)
81149310:	e0bff217 	ldw	r2,-56(fp)
81149314:	1885c83a 	sub	r2,r3,r2
81149318:	00000606 	br	81149334 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
8114931c:	e0bfff17 	ldw	r2,-4(fp)
81149320:	1090000c 	andi	r2,r2,16384
81149324:	10000226 	beq	r2,zero,81149330 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81149328:	00bffd44 	movi	r2,-11
8114932c:	00000106 	br	81149334 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81149330:	00bffec4 	movi	r2,-5
}
81149334:	e037883a 	mov	sp,fp
81149338:	dfc00117 	ldw	ra,4(sp)
8114933c:	df000017 	ldw	fp,0(sp)
81149340:	dec00204 	addi	sp,sp,8
81149344:	f800283a 	ret

81149348 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81149348:	defffa04 	addi	sp,sp,-24
8114934c:	de00012e 	bgeu	sp,et,81149354 <alt_avalon_timer_sc_irq+0xc>
81149350:	003b68fa 	trap	3
81149354:	dfc00515 	stw	ra,20(sp)
81149358:	df000415 	stw	fp,16(sp)
8114935c:	df000404 	addi	fp,sp,16
81149360:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81149364:	0007883a 	mov	r3,zero
81149368:	e0bfff17 	ldw	r2,-4(fp)
8114936c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81149370:	e0bfff17 	ldw	r2,-4(fp)
81149374:	10800104 	addi	r2,r2,4
81149378:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
8114937c:	11393480 	call	81139348 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149380:	0005303a 	rdctl	r2,status
81149384:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149388:	e0fffd17 	ldw	r3,-12(fp)
8114938c:	00bfff84 	movi	r2,-2
81149390:	1884703a 	and	r2,r3,r2
81149394:	1001703a 	wrctl	status,r2
  
  return context;
81149398:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8114939c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
811493a0:	1139bf80 	call	81139bf8 <alt_tick>
811493a4:	e0bffc17 	ldw	r2,-16(fp)
811493a8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811493ac:	e0bffe17 	ldw	r2,-8(fp)
811493b0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
811493b4:	0001883a 	nop
811493b8:	e037883a 	mov	sp,fp
811493bc:	dfc00117 	ldw	ra,4(sp)
811493c0:	df000017 	ldw	fp,0(sp)
811493c4:	dec00204 	addi	sp,sp,8
811493c8:	f800283a 	ret

811493cc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
811493cc:	defff804 	addi	sp,sp,-32
811493d0:	de00012e 	bgeu	sp,et,811493d8 <alt_avalon_timer_sc_init+0xc>
811493d4:	003b68fa 	trap	3
811493d8:	dfc00715 	stw	ra,28(sp)
811493dc:	df000615 	stw	fp,24(sp)
811493e0:	df000604 	addi	fp,sp,24
811493e4:	e13ffc15 	stw	r4,-16(fp)
811493e8:	e17ffd15 	stw	r5,-12(fp)
811493ec:	e1bffe15 	stw	r6,-8(fp)
811493f0:	e1ffff15 	stw	r7,-4(fp)
811493f4:	e0bfff17 	ldw	r2,-4(fp)
811493f8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
811493fc:	d0a08817 	ldw	r2,-32224(gp)
81149400:	1000021e 	bne	r2,zero,8114940c <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81149404:	e0bffb17 	ldw	r2,-20(fp)
81149408:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
8114940c:	e0bffc17 	ldw	r2,-16(fp)
81149410:	10800104 	addi	r2,r2,4
81149414:	00c001c4 	movi	r3,7
81149418:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8114941c:	d8000015 	stw	zero,0(sp)
81149420:	e1fffc17 	ldw	r7,-16(fp)
81149424:	01a04574 	movhi	r6,33045
81149428:	31a4d204 	addi	r6,r6,-27832
8114942c:	e17ffe17 	ldw	r5,-8(fp)
81149430:	e13ffd17 	ldw	r4,-12(fp)
81149434:	114c5d00 	call	8114c5d0 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81149438:	0001883a 	nop
8114943c:	e037883a 	mov	sp,fp
81149440:	dfc00117 	ldw	ra,4(sp)
81149444:	df000017 	ldw	fp,0(sp)
81149448:	dec00204 	addi	sp,sp,8
8114944c:	f800283a 	ret

81149450 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81149450:	defffa04 	addi	sp,sp,-24
81149454:	de00012e 	bgeu	sp,et,8114945c <altera_avalon_uart_read_fd+0xc>
81149458:	003b68fa 	trap	3
8114945c:	dfc00515 	stw	ra,20(sp)
81149460:	df000415 	stw	fp,16(sp)
81149464:	df000404 	addi	fp,sp,16
81149468:	e13ffd15 	stw	r4,-12(fp)
8114946c:	e17ffe15 	stw	r5,-8(fp)
81149470:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81149474:	e0bffd17 	ldw	r2,-12(fp)
81149478:	10800017 	ldw	r2,0(r2)
8114947c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81149480:	e0bffc17 	ldw	r2,-16(fp)
81149484:	10c00a04 	addi	r3,r2,40
81149488:	e0bffd17 	ldw	r2,-12(fp)
8114948c:	10800217 	ldw	r2,8(r2)
81149490:	100f883a 	mov	r7,r2
81149494:	e1bfff17 	ldw	r6,-4(fp)
81149498:	e17ffe17 	ldw	r5,-8(fp)
8114949c:	1809883a 	mov	r4,r3
811494a0:	1149b100 	call	81149b10 <altera_avalon_uart_read>
      fd->fd_flags);
}
811494a4:	e037883a 	mov	sp,fp
811494a8:	dfc00117 	ldw	ra,4(sp)
811494ac:	df000017 	ldw	fp,0(sp)
811494b0:	dec00204 	addi	sp,sp,8
811494b4:	f800283a 	ret

811494b8 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811494b8:	defffa04 	addi	sp,sp,-24
811494bc:	de00012e 	bgeu	sp,et,811494c4 <altera_avalon_uart_write_fd+0xc>
811494c0:	003b68fa 	trap	3
811494c4:	dfc00515 	stw	ra,20(sp)
811494c8:	df000415 	stw	fp,16(sp)
811494cc:	df000404 	addi	fp,sp,16
811494d0:	e13ffd15 	stw	r4,-12(fp)
811494d4:	e17ffe15 	stw	r5,-8(fp)
811494d8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811494dc:	e0bffd17 	ldw	r2,-12(fp)
811494e0:	10800017 	ldw	r2,0(r2)
811494e4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811494e8:	e0bffc17 	ldw	r2,-16(fp)
811494ec:	10c00a04 	addi	r3,r2,40
811494f0:	e0bffd17 	ldw	r2,-12(fp)
811494f4:	10800217 	ldw	r2,8(r2)
811494f8:	100f883a 	mov	r7,r2
811494fc:	e1bfff17 	ldw	r6,-4(fp)
81149500:	e17ffe17 	ldw	r5,-8(fp)
81149504:	1809883a 	mov	r4,r3
81149508:	1149dc40 	call	81149dc4 <altera_avalon_uart_write>
      fd->fd_flags);
}
8114950c:	e037883a 	mov	sp,fp
81149510:	dfc00117 	ldw	ra,4(sp)
81149514:	df000017 	ldw	fp,0(sp)
81149518:	dec00204 	addi	sp,sp,8
8114951c:	f800283a 	ret

81149520 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81149520:	defffc04 	addi	sp,sp,-16
81149524:	de00012e 	bgeu	sp,et,8114952c <altera_avalon_uart_close_fd+0xc>
81149528:	003b68fa 	trap	3
8114952c:	dfc00315 	stw	ra,12(sp)
81149530:	df000215 	stw	fp,8(sp)
81149534:	df000204 	addi	fp,sp,8
81149538:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114953c:	e0bfff17 	ldw	r2,-4(fp)
81149540:	10800017 	ldw	r2,0(r2)
81149544:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81149548:	e0bffe17 	ldw	r2,-8(fp)
8114954c:	10c00a04 	addi	r3,r2,40
81149550:	e0bfff17 	ldw	r2,-4(fp)
81149554:	10800217 	ldw	r2,8(r2)
81149558:	100b883a 	mov	r5,r2
8114955c:	1809883a 	mov	r4,r3
81149560:	1149a700 	call	81149a70 <altera_avalon_uart_close>
}
81149564:	e037883a 	mov	sp,fp
81149568:	dfc00117 	ldw	ra,4(sp)
8114956c:	df000017 	ldw	fp,0(sp)
81149570:	dec00204 	addi	sp,sp,8
81149574:	f800283a 	ret

81149578 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81149578:	defff304 	addi	sp,sp,-52
8114957c:	de00012e 	bgeu	sp,et,81149584 <altera_avalon_uart_init+0xc>
81149580:	003b68fa 	trap	3
81149584:	dfc00c15 	stw	ra,48(sp)
81149588:	df000b15 	stw	fp,44(sp)
8114958c:	df000b04 	addi	fp,sp,44
81149590:	e13ffd15 	stw	r4,-12(fp)
81149594:	e17ffe15 	stw	r5,-8(fp)
81149598:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
8114959c:	e0bffd17 	ldw	r2,-12(fp)
811495a0:	10800017 	ldw	r2,0(r2)
811495a4:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811495a8:	e0bffd17 	ldw	r2,-12(fp)
811495ac:	10800704 	addi	r2,r2,28
811495b0:	e0bffa15 	stw	r2,-24(fp)
811495b4:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811495b8:	e0bffb0b 	ldhu	r2,-20(fp)
811495bc:	e0fffc84 	addi	r3,fp,-14
811495c0:	180b883a 	mov	r5,r3
811495c4:	1009883a 	mov	r4,r2
811495c8:	113c8880 	call	8113c888 <OSFlagCreate>
811495cc:	1007883a 	mov	r3,r2
811495d0:	e0bffa17 	ldw	r2,-24(fp)
811495d4:	10c00015 	stw	r3,0(r2)
  return err;
811495d8:	e0bffc83 	ldbu	r2,-14(fp)
811495dc:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811495e0:	1000241e 	bne	r2,zero,81149674 <altera_avalon_uart_init+0xfc>
811495e4:	e0bffd17 	ldw	r2,-12(fp)
811495e8:	10800804 	addi	r2,r2,32
811495ec:	e0bff715 	stw	r2,-36(fp)
811495f0:	00800044 	movi	r2,1
811495f4:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811495f8:	e0bffb8b 	ldhu	r2,-18(fp)
811495fc:	1009883a 	mov	r4,r2
81149600:	11407e40 	call	811407e4 <OSSemCreate>
81149604:	1007883a 	mov	r3,r2
81149608:	e0bff717 	ldw	r2,-36(fp)
8114960c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149610:	e0bff717 	ldw	r2,-36(fp)
81149614:	10800017 	ldw	r2,0(r2)
81149618:	10000226 	beq	r2,zero,81149624 <altera_avalon_uart_init+0xac>
8114961c:	0005883a 	mov	r2,zero
81149620:	00000106 	br	81149628 <altera_avalon_uart_init+0xb0>
81149624:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81149628:	1000121e 	bne	r2,zero,81149674 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
8114962c:	e0bffd17 	ldw	r2,-12(fp)
81149630:	10800904 	addi	r2,r2,36
81149634:	e0bff815 	stw	r2,-32(fp)
81149638:	00800044 	movi	r2,1
8114963c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81149640:	e0bffc0b 	ldhu	r2,-16(fp)
81149644:	1009883a 	mov	r4,r2
81149648:	11407e40 	call	811407e4 <OSSemCreate>
8114964c:	1007883a 	mov	r3,r2
81149650:	e0bff817 	ldw	r2,-32(fp)
81149654:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149658:	e0bff817 	ldw	r2,-32(fp)
8114965c:	10800017 	ldw	r2,0(r2)
81149660:	10000226 	beq	r2,zero,8114966c <altera_avalon_uart_init+0xf4>
81149664:	0005883a 	mov	r2,zero
81149668:	00000106 	br	81149670 <altera_avalon_uart_init+0xf8>
8114966c:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81149670:	10000226 	beq	r2,zero,8114967c <altera_avalon_uart_init+0x104>
81149674:	00800044 	movi	r2,1
81149678:	00000106 	br	81149680 <altera_avalon_uart_init+0x108>
8114967c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81149680:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81149684:	e0bff917 	ldw	r2,-28(fp)
81149688:	10000f1e 	bne	r2,zero,811496c8 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
8114968c:	e0bffd17 	ldw	r2,-12(fp)
81149690:	00c32004 	movi	r3,3200
81149694:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81149698:	e0bff617 	ldw	r2,-40(fp)
8114969c:	10800304 	addi	r2,r2,12
811496a0:	e0fffd17 	ldw	r3,-12(fp)
811496a4:	18c00117 	ldw	r3,4(r3)
811496a8:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
811496ac:	d8000015 	stw	zero,0(sp)
811496b0:	e1fffd17 	ldw	r7,-12(fp)
811496b4:	01a04574 	movhi	r6,33045
811496b8:	31a5b804 	addi	r6,r6,-26912
811496bc:	e17fff17 	ldw	r5,-4(fp)
811496c0:	e13ffe17 	ldw	r4,-8(fp)
811496c4:	114c5d00 	call	8114c5d0 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
811496c8:	0001883a 	nop
811496cc:	e037883a 	mov	sp,fp
811496d0:	dfc00117 	ldw	ra,4(sp)
811496d4:	df000017 	ldw	fp,0(sp)
811496d8:	dec00204 	addi	sp,sp,8
811496dc:	f800283a 	ret

811496e0 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811496e0:	defffa04 	addi	sp,sp,-24
811496e4:	de00012e 	bgeu	sp,et,811496ec <altera_avalon_uart_irq+0xc>
811496e8:	003b68fa 	trap	3
811496ec:	dfc00515 	stw	ra,20(sp)
811496f0:	df000415 	stw	fp,16(sp)
811496f4:	df000404 	addi	fp,sp,16
811496f8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811496fc:	e0bfff17 	ldw	r2,-4(fp)
81149700:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81149704:	e0bffc17 	ldw	r2,-16(fp)
81149708:	10800017 	ldw	r2,0(r2)
8114970c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
81149710:	e0bffd17 	ldw	r2,-12(fp)
81149714:	10800204 	addi	r2,r2,8
81149718:	10800037 	ldwio	r2,0(r2)
8114971c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81149720:	e0bffd17 	ldw	r2,-12(fp)
81149724:	10800204 	addi	r2,r2,8
81149728:	0007883a 	mov	r3,zero
8114972c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81149730:	e0bffd17 	ldw	r2,-12(fp)
81149734:	10800204 	addi	r2,r2,8
81149738:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
8114973c:	e0bffe17 	ldw	r2,-8(fp)
81149740:	1080200c 	andi	r2,r2,128
81149744:	10000326 	beq	r2,zero,81149754 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81149748:	e17ffe17 	ldw	r5,-8(fp)
8114974c:	e13ffc17 	ldw	r4,-16(fp)
81149750:	11497840 	call	81149784 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81149754:	e0bffe17 	ldw	r2,-8(fp)
81149758:	1081100c 	andi	r2,r2,1088
8114975c:	10000326 	beq	r2,zero,8114976c <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81149760:	e17ffe17 	ldw	r5,-8(fp)
81149764:	e13ffc17 	ldw	r4,-16(fp)
81149768:	11498c40 	call	811498c4 <altera_avalon_uart_txirq>
  }
  

}
8114976c:	0001883a 	nop
81149770:	e037883a 	mov	sp,fp
81149774:	dfc00117 	ldw	ra,4(sp)
81149778:	df000017 	ldw	fp,0(sp)
8114977c:	dec00204 	addi	sp,sp,8
81149780:	f800283a 	ret

81149784 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81149784:	defff904 	addi	sp,sp,-28
81149788:	de00012e 	bgeu	sp,et,81149790 <altera_avalon_uart_rxirq+0xc>
8114978c:	003b68fa 	trap	3
81149790:	dfc00615 	stw	ra,24(sp)
81149794:	df000515 	stw	fp,20(sp)
81149798:	df000504 	addi	fp,sp,20
8114979c:	e13ffe15 	stw	r4,-8(fp)
811497a0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
811497a4:	e0bfff17 	ldw	r2,-4(fp)
811497a8:	108000cc 	andi	r2,r2,3
811497ac:	10003f1e 	bne	r2,zero,811498ac <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
811497b0:	e0bffe17 	ldw	r2,-8(fp)
811497b4:	10c00317 	ldw	r3,12(r2)
811497b8:	e0bffe17 	ldw	r2,-8(fp)
811497bc:	10800217 	ldw	r2,8(r2)
811497c0:	1880121e 	bne	r3,r2,8114980c <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
811497c4:	e0bffe17 	ldw	r2,-8(fp)
811497c8:	10800717 	ldw	r2,28(r2)
811497cc:	e0bffc15 	stw	r2,-16(fp)
811497d0:	00800044 	movi	r2,1
811497d4:	e0bffd0d 	sth	r2,-12(fp)
811497d8:	00800044 	movi	r2,1
811497dc:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811497e0:	d0a09103 	ldbu	r2,-32188(gp)
811497e4:	10803fcc 	andi	r2,r2,255
811497e8:	10000826 	beq	r2,zero,8114980c <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811497ec:	e0bffd0b 	ldhu	r2,-12(fp)
811497f0:	e0fffd83 	ldbu	r3,-10(fp)
811497f4:	e13ffdc4 	addi	r4,fp,-9
811497f8:	200f883a 	mov	r7,r4
811497fc:	180d883a 	mov	r6,r3
81149800:	100b883a 	mov	r5,r2
81149804:	e13ffc17 	ldw	r4,-16(fp)
81149808:	113d4940 	call	8113d494 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8114980c:	e0bffe17 	ldw	r2,-8(fp)
81149810:	10800317 	ldw	r2,12(r2)
81149814:	10800044 	addi	r2,r2,1
81149818:	10800fcc 	andi	r2,r2,63
8114981c:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81149820:	e0bffe17 	ldw	r2,-8(fp)
81149824:	10800317 	ldw	r2,12(r2)
81149828:	e0fffe17 	ldw	r3,-8(fp)
8114982c:	18c00017 	ldw	r3,0(r3)
81149830:	18c00037 	ldwio	r3,0(r3)
81149834:	1809883a 	mov	r4,r3
81149838:	e0fffe17 	ldw	r3,-8(fp)
8114983c:	1885883a 	add	r2,r3,r2
81149840:	10800a04 	addi	r2,r2,40
81149844:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81149848:	e0bffe17 	ldw	r2,-8(fp)
8114984c:	e0fffb17 	ldw	r3,-20(fp)
81149850:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81149854:	e0bffe17 	ldw	r2,-8(fp)
81149858:	10800317 	ldw	r2,12(r2)
8114985c:	10800044 	addi	r2,r2,1
81149860:	10800fcc 	andi	r2,r2,63
81149864:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81149868:	e0bffe17 	ldw	r2,-8(fp)
8114986c:	10c00217 	ldw	r3,8(r2)
81149870:	e0bffb17 	ldw	r2,-20(fp)
81149874:	18800e1e 	bne	r3,r2,811498b0 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81149878:	e0bffe17 	ldw	r2,-8(fp)
8114987c:	10c00117 	ldw	r3,4(r2)
81149880:	00bfdfc4 	movi	r2,-129
81149884:	1886703a 	and	r3,r3,r2
81149888:	e0bffe17 	ldw	r2,-8(fp)
8114988c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81149890:	e0bffe17 	ldw	r2,-8(fp)
81149894:	10800017 	ldw	r2,0(r2)
81149898:	10800304 	addi	r2,r2,12
8114989c:	e0fffe17 	ldw	r3,-8(fp)
811498a0:	18c00117 	ldw	r3,4(r3)
811498a4:	10c00035 	stwio	r3,0(r2)
811498a8:	00000106 	br	811498b0 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
811498ac:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
811498b0:	e037883a 	mov	sp,fp
811498b4:	dfc00117 	ldw	ra,4(sp)
811498b8:	df000017 	ldw	fp,0(sp)
811498bc:	dec00204 	addi	sp,sp,8
811498c0:	f800283a 	ret

811498c4 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811498c4:	defffa04 	addi	sp,sp,-24
811498c8:	de00012e 	bgeu	sp,et,811498d0 <altera_avalon_uart_txirq+0xc>
811498cc:	003b68fa 	trap	3
811498d0:	dfc00515 	stw	ra,20(sp)
811498d4:	df000415 	stw	fp,16(sp)
811498d8:	df000404 	addi	fp,sp,16
811498dc:	e13ffe15 	stw	r4,-8(fp)
811498e0:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
811498e4:	e0bffe17 	ldw	r2,-8(fp)
811498e8:	10c00417 	ldw	r3,16(r2)
811498ec:	e0bffe17 	ldw	r2,-8(fp)
811498f0:	10800517 	ldw	r2,20(r2)
811498f4:	18804726 	beq	r3,r2,81149a14 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811498f8:	e0bffe17 	ldw	r2,-8(fp)
811498fc:	10800617 	ldw	r2,24(r2)
81149900:	1080008c 	andi	r2,r2,2
81149904:	10000326 	beq	r2,zero,81149914 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81149908:	e0bfff17 	ldw	r2,-4(fp)
8114990c:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81149910:	10003226 	beq	r2,zero,811499dc <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81149914:	e0bffe17 	ldw	r2,-8(fp)
81149918:	10c00417 	ldw	r3,16(r2)
8114991c:	e0bffe17 	ldw	r2,-8(fp)
81149920:	10800517 	ldw	r2,20(r2)
81149924:	10800044 	addi	r2,r2,1
81149928:	10800fcc 	andi	r2,r2,63
8114992c:	1880121e 	bne	r3,r2,81149978 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81149930:	e0bffe17 	ldw	r2,-8(fp)
81149934:	10800717 	ldw	r2,28(r2)
81149938:	e0bffc15 	stw	r2,-16(fp)
8114993c:	00800084 	movi	r2,2
81149940:	e0bffd0d 	sth	r2,-12(fp)
81149944:	00800044 	movi	r2,1
81149948:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114994c:	d0a09103 	ldbu	r2,-32188(gp)
81149950:	10803fcc 	andi	r2,r2,255
81149954:	10000826 	beq	r2,zero,81149978 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81149958:	e0bffd0b 	ldhu	r2,-12(fp)
8114995c:	e0fffd83 	ldbu	r3,-10(fp)
81149960:	e13ffdc4 	addi	r4,fp,-9
81149964:	200f883a 	mov	r7,r4
81149968:	180d883a 	mov	r6,r3
8114996c:	100b883a 	mov	r5,r2
81149970:	e13ffc17 	ldw	r4,-16(fp)
81149974:	113d4940 	call	8113d494 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81149978:	e0bffe17 	ldw	r2,-8(fp)
8114997c:	10800017 	ldw	r2,0(r2)
81149980:	10800104 	addi	r2,r2,4
81149984:	e0fffe17 	ldw	r3,-8(fp)
81149988:	18c00417 	ldw	r3,16(r3)
8114998c:	e13ffe17 	ldw	r4,-8(fp)
81149990:	20c7883a 	add	r3,r4,r3
81149994:	18c01a04 	addi	r3,r3,104
81149998:	18c00003 	ldbu	r3,0(r3)
8114999c:	18c03fcc 	andi	r3,r3,255
811499a0:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
811499a4:	e0bffe17 	ldw	r2,-8(fp)
811499a8:	10800417 	ldw	r2,16(r2)
811499ac:	10800044 	addi	r2,r2,1
811499b0:	e0fffe17 	ldw	r3,-8(fp)
811499b4:	18800415 	stw	r2,16(r3)
811499b8:	10c00fcc 	andi	r3,r2,63
811499bc:	e0bffe17 	ldw	r2,-8(fp)
811499c0:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811499c4:	e0bffe17 	ldw	r2,-8(fp)
811499c8:	10800117 	ldw	r2,4(r2)
811499cc:	10c01014 	ori	r3,r2,64
811499d0:	e0bffe17 	ldw	r2,-8(fp)
811499d4:	10c00115 	stw	r3,4(r2)
811499d8:	00000e06 	br	81149a14 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811499dc:	e0bffe17 	ldw	r2,-8(fp)
811499e0:	10800017 	ldw	r2,0(r2)
811499e4:	10800204 	addi	r2,r2,8
811499e8:	10800037 	ldwio	r2,0(r2)
811499ec:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811499f0:	e0bfff17 	ldw	r2,-4(fp)
811499f4:	1082000c 	andi	r2,r2,2048
811499f8:	1000061e 	bne	r2,zero,81149a14 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811499fc:	e0bffe17 	ldw	r2,-8(fp)
81149a00:	10c00117 	ldw	r3,4(r2)
81149a04:	00bfefc4 	movi	r2,-65
81149a08:	1886703a 	and	r3,r3,r2
81149a0c:	e0bffe17 	ldw	r2,-8(fp)
81149a10:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81149a14:	e0bffe17 	ldw	r2,-8(fp)
81149a18:	10c00417 	ldw	r3,16(r2)
81149a1c:	e0bffe17 	ldw	r2,-8(fp)
81149a20:	10800517 	ldw	r2,20(r2)
81149a24:	1880061e 	bne	r3,r2,81149a40 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149a28:	e0bffe17 	ldw	r2,-8(fp)
81149a2c:	10c00117 	ldw	r3,4(r2)
81149a30:	00beefc4 	movi	r2,-1089
81149a34:	1886703a 	and	r3,r3,r2
81149a38:	e0bffe17 	ldw	r2,-8(fp)
81149a3c:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149a40:	e0bffe17 	ldw	r2,-8(fp)
81149a44:	10800017 	ldw	r2,0(r2)
81149a48:	10800304 	addi	r2,r2,12
81149a4c:	e0fffe17 	ldw	r3,-8(fp)
81149a50:	18c00117 	ldw	r3,4(r3)
81149a54:	10c00035 	stwio	r3,0(r2)
}
81149a58:	0001883a 	nop
81149a5c:	e037883a 	mov	sp,fp
81149a60:	dfc00117 	ldw	ra,4(sp)
81149a64:	df000017 	ldw	fp,0(sp)
81149a68:	dec00204 	addi	sp,sp,8
81149a6c:	f800283a 	ret

81149a70 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81149a70:	defffd04 	addi	sp,sp,-12
81149a74:	de00012e 	bgeu	sp,et,81149a7c <altera_avalon_uart_close+0xc>
81149a78:	003b68fa 	trap	3
81149a7c:	df000215 	stw	fp,8(sp)
81149a80:	df000204 	addi	fp,sp,8
81149a84:	e13ffe15 	stw	r4,-8(fp)
81149a88:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81149a8c:	00000506 	br	81149aa4 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81149a90:	e0bfff17 	ldw	r2,-4(fp)
81149a94:	1090000c 	andi	r2,r2,16384
81149a98:	10000226 	beq	r2,zero,81149aa4 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81149a9c:	00bffd44 	movi	r2,-11
81149aa0:	00000606 	br	81149abc <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81149aa4:	e0bffe17 	ldw	r2,-8(fp)
81149aa8:	10c00417 	ldw	r3,16(r2)
81149aac:	e0bffe17 	ldw	r2,-8(fp)
81149ab0:	10800517 	ldw	r2,20(r2)
81149ab4:	18bff61e 	bne	r3,r2,81149a90 <__reset+0xfb129a90>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81149ab8:	0005883a 	mov	r2,zero
}
81149abc:	e037883a 	mov	sp,fp
81149ac0:	df000017 	ldw	fp,0(sp)
81149ac4:	dec00104 	addi	sp,sp,4
81149ac8:	f800283a 	ret

81149acc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81149acc:	defffe04 	addi	sp,sp,-8
81149ad0:	de00012e 	bgeu	sp,et,81149ad8 <alt_get_errno+0xc>
81149ad4:	003b68fa 	trap	3
81149ad8:	dfc00115 	stw	ra,4(sp)
81149adc:	df000015 	stw	fp,0(sp)
81149ae0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149ae4:	d0a01017 	ldw	r2,-32704(gp)
81149ae8:	10000326 	beq	r2,zero,81149af8 <alt_get_errno+0x2c>
81149aec:	d0a01017 	ldw	r2,-32704(gp)
81149af0:	103ee83a 	callr	r2
81149af4:	00000106 	br	81149afc <alt_get_errno+0x30>
81149af8:	d0a07804 	addi	r2,gp,-32288
}
81149afc:	e037883a 	mov	sp,fp
81149b00:	dfc00117 	ldw	ra,4(sp)
81149b04:	df000017 	ldw	fp,0(sp)
81149b08:	dec00204 	addi	sp,sp,8
81149b0c:	f800283a 	ret

81149b10 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81149b10:	deffec04 	addi	sp,sp,-80
81149b14:	de00012e 	bgeu	sp,et,81149b1c <altera_avalon_uart_read+0xc>
81149b18:	003b68fa 	trap	3
81149b1c:	dfc01315 	stw	ra,76(sp)
81149b20:	df001215 	stw	fp,72(sp)
81149b24:	df001204 	addi	fp,sp,72
81149b28:	e13ffc15 	stw	r4,-16(fp)
81149b2c:	e17ffd15 	stw	r5,-12(fp)
81149b30:	e1bffe15 	stw	r6,-8(fp)
81149b34:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81149b38:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81149b3c:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81149b40:	e0bfff17 	ldw	r2,-4(fp)
81149b44:	1090000c 	andi	r2,r2,16384
81149b48:	1005003a 	cmpeq	r2,r2,zero
81149b4c:	10803fcc 	andi	r2,r2,255
81149b50:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81149b54:	e0bffc17 	ldw	r2,-16(fp)
81149b58:	10800817 	ldw	r2,32(r2)
81149b5c:	e0bff815 	stw	r2,-32(fp)
81149b60:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81149b64:	e0bff90b 	ldhu	r2,-28(fp)
81149b68:	e0fffb44 	addi	r3,fp,-19
81149b6c:	180d883a 	mov	r6,r3
81149b70:	100b883a 	mov	r5,r2
81149b74:	e13ff817 	ldw	r4,-32(fp)
81149b78:	1140b0c0 	call	81140b0c <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81149b7c:	00001306 	br	81149bcc <altera_avalon_uart_read+0xbc>
    {
      count++;
81149b80:	e0bff017 	ldw	r2,-64(fp)
81149b84:	10800044 	addi	r2,r2,1
81149b88:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81149b8c:	e0bffd17 	ldw	r2,-12(fp)
81149b90:	10c00044 	addi	r3,r2,1
81149b94:	e0fffd15 	stw	r3,-12(fp)
81149b98:	e0fffc17 	ldw	r3,-16(fp)
81149b9c:	18c00217 	ldw	r3,8(r3)
81149ba0:	e13ffc17 	ldw	r4,-16(fp)
81149ba4:	20c7883a 	add	r3,r4,r3
81149ba8:	18c00a04 	addi	r3,r3,40
81149bac:	18c00003 	ldbu	r3,0(r3)
81149bb0:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81149bb4:	e0bffc17 	ldw	r2,-16(fp)
81149bb8:	10800217 	ldw	r2,8(r2)
81149bbc:	10800044 	addi	r2,r2,1
81149bc0:	10c00fcc 	andi	r3,r2,63
81149bc4:	e0bffc17 	ldw	r2,-16(fp)
81149bc8:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81149bcc:	e0fff017 	ldw	r3,-64(fp)
81149bd0:	e0bffe17 	ldw	r2,-8(fp)
81149bd4:	1880050e 	bge	r3,r2,81149bec <altera_avalon_uart_read+0xdc>
81149bd8:	e0bffc17 	ldw	r2,-16(fp)
81149bdc:	10c00217 	ldw	r3,8(r2)
81149be0:	e0bffc17 	ldw	r2,-16(fp)
81149be4:	10800317 	ldw	r2,12(r2)
81149be8:	18bfe51e 	bne	r3,r2,81149b80 <__reset+0xfb129b80>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81149bec:	e0bff017 	ldw	r2,-64(fp)
81149bf0:	10003a1e 	bne	r2,zero,81149cdc <altera_avalon_uart_read+0x1cc>
81149bf4:	e0bffc17 	ldw	r2,-16(fp)
81149bf8:	10c00217 	ldw	r3,8(r2)
81149bfc:	e0bffc17 	ldw	r2,-16(fp)
81149c00:	10800317 	ldw	r2,12(r2)
81149c04:	1880351e 	bne	r3,r2,81149cdc <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81149c08:	e0bff117 	ldw	r2,-60(fp)
81149c0c:	1000071e 	bne	r2,zero,81149c2c <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81149c10:	1149acc0 	call	81149acc <alt_get_errno>
81149c14:	1007883a 	mov	r3,r2
81149c18:	008002c4 	movi	r2,11
81149c1c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81149c20:	00800044 	movi	r2,1
81149c24:	e0bfef05 	stb	r2,-68(fp)
        break;
81149c28:	00003006 	br	81149cec <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149c2c:	0005303a 	rdctl	r2,status
81149c30:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149c34:	e0fff517 	ldw	r3,-44(fp)
81149c38:	00bfff84 	movi	r2,-2
81149c3c:	1884703a 	and	r2,r3,r2
81149c40:	1001703a 	wrctl	status,r2
  
  return context;
81149c44:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81149c48:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81149c4c:	e0bffc17 	ldw	r2,-16(fp)
81149c50:	10800117 	ldw	r2,4(r2)
81149c54:	10c02014 	ori	r3,r2,128
81149c58:	e0bffc17 	ldw	r2,-16(fp)
81149c5c:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149c60:	e0bffc17 	ldw	r2,-16(fp)
81149c64:	10800017 	ldw	r2,0(r2)
81149c68:	10800304 	addi	r2,r2,12
81149c6c:	e0fffc17 	ldw	r3,-16(fp)
81149c70:	18c00117 	ldw	r3,4(r3)
81149c74:	10c00035 	stwio	r3,0(r2)
81149c78:	e0bff417 	ldw	r2,-48(fp)
81149c7c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149c80:	e0bff617 	ldw	r2,-40(fp)
81149c84:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81149c88:	e0bffc17 	ldw	r2,-16(fp)
81149c8c:	10800717 	ldw	r2,28(r2)
81149c90:	e0bff215 	stw	r2,-56(fp)
81149c94:	00800044 	movi	r2,1
81149c98:	e0bff98d 	sth	r2,-26(fp)
81149c9c:	00bfe0c4 	movi	r2,-125
81149ca0:	e0bffa05 	stb	r2,-24(fp)
81149ca4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81149ca8:	d0a09103 	ldbu	r2,-32188(gp)
81149cac:	10803fcc 	andi	r2,r2,255
81149cb0:	10000a26 	beq	r2,zero,81149cdc <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81149cb4:	e0fff98b 	ldhu	r3,-26(fp)
81149cb8:	e13ffa03 	ldbu	r4,-24(fp)
81149cbc:	e17ffa8b 	ldhu	r5,-22(fp)
81149cc0:	e0bffb04 	addi	r2,fp,-20
81149cc4:	d8800015 	stw	r2,0(sp)
81149cc8:	280f883a 	mov	r7,r5
81149ccc:	200d883a 	mov	r6,r4
81149cd0:	180b883a 	mov	r5,r3
81149cd4:	e13ff217 	ldw	r4,-56(fp)
81149cd8:	113ce6c0 	call	8113ce6c <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81149cdc:	e0bff017 	ldw	r2,-64(fp)
81149ce0:	1000021e 	bne	r2,zero,81149cec <altera_avalon_uart_read+0x1dc>
81149ce4:	e0bffe17 	ldw	r2,-8(fp)
81149ce8:	103fb81e 	bne	r2,zero,81149bcc <__reset+0xfb129bcc>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81149cec:	e0bffc17 	ldw	r2,-16(fp)
81149cf0:	10800817 	ldw	r2,32(r2)
81149cf4:	1009883a 	mov	r4,r2
81149cf8:	1140e940 	call	81140e94 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149cfc:	0005303a 	rdctl	r2,status
81149d00:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149d04:	e0fff717 	ldw	r3,-36(fp)
81149d08:	00bfff84 	movi	r2,-2
81149d0c:	1884703a 	and	r2,r3,r2
81149d10:	1001703a 	wrctl	status,r2
  
  return context;
81149d14:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81149d18:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81149d1c:	e0bffc17 	ldw	r2,-16(fp)
81149d20:	10800117 	ldw	r2,4(r2)
81149d24:	10c02014 	ori	r3,r2,128
81149d28:	e0bffc17 	ldw	r2,-16(fp)
81149d2c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149d30:	e0bffc17 	ldw	r2,-16(fp)
81149d34:	10800017 	ldw	r2,0(r2)
81149d38:	10800304 	addi	r2,r2,12
81149d3c:	e0fffc17 	ldw	r3,-16(fp)
81149d40:	18c00117 	ldw	r3,4(r3)
81149d44:	10c00035 	stwio	r3,0(r2)
81149d48:	e0bff417 	ldw	r2,-48(fp)
81149d4c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149d50:	e0bff317 	ldw	r2,-52(fp)
81149d54:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81149d58:	e0bfef03 	ldbu	r2,-68(fp)
81149d5c:	10000226 	beq	r2,zero,81149d68 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81149d60:	00bffd44 	movi	r2,-11
81149d64:	00000106 	br	81149d6c <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81149d68:	e0bff017 	ldw	r2,-64(fp)
  }
}
81149d6c:	e037883a 	mov	sp,fp
81149d70:	dfc00117 	ldw	ra,4(sp)
81149d74:	df000017 	ldw	fp,0(sp)
81149d78:	dec00204 	addi	sp,sp,8
81149d7c:	f800283a 	ret

81149d80 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81149d80:	defffe04 	addi	sp,sp,-8
81149d84:	de00012e 	bgeu	sp,et,81149d8c <alt_get_errno+0xc>
81149d88:	003b68fa 	trap	3
81149d8c:	dfc00115 	stw	ra,4(sp)
81149d90:	df000015 	stw	fp,0(sp)
81149d94:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149d98:	d0a01017 	ldw	r2,-32704(gp)
81149d9c:	10000326 	beq	r2,zero,81149dac <alt_get_errno+0x2c>
81149da0:	d0a01017 	ldw	r2,-32704(gp)
81149da4:	103ee83a 	callr	r2
81149da8:	00000106 	br	81149db0 <alt_get_errno+0x30>
81149dac:	d0a07804 	addi	r2,gp,-32288
}
81149db0:	e037883a 	mov	sp,fp
81149db4:	dfc00117 	ldw	ra,4(sp)
81149db8:	df000017 	ldw	fp,0(sp)
81149dbc:	dec00204 	addi	sp,sp,8
81149dc0:	f800283a 	ret

81149dc4 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81149dc4:	deffec04 	addi	sp,sp,-80
81149dc8:	de00012e 	bgeu	sp,et,81149dd0 <altera_avalon_uart_write+0xc>
81149dcc:	003b68fa 	trap	3
81149dd0:	dfc01315 	stw	ra,76(sp)
81149dd4:	df001215 	stw	fp,72(sp)
81149dd8:	df001204 	addi	fp,sp,72
81149ddc:	e13ffc15 	stw	r4,-16(fp)
81149de0:	e17ffd15 	stw	r5,-12(fp)
81149de4:	e1bffe15 	stw	r6,-8(fp)
81149de8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81149dec:	e0bffe17 	ldw	r2,-8(fp)
81149df0:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81149df4:	e0bfff17 	ldw	r2,-4(fp)
81149df8:	1090000c 	andi	r2,r2,16384
81149dfc:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81149e00:	e0bffc17 	ldw	r2,-16(fp)
81149e04:	10800917 	ldw	r2,36(r2)
81149e08:	e0bff815 	stw	r2,-32(fp)
81149e0c:	e03ff90d 	sth	zero,-28(fp)
81149e10:	e0bff90b 	ldhu	r2,-28(fp)
81149e14:	e0fffb44 	addi	r3,fp,-19
81149e18:	180d883a 	mov	r6,r3
81149e1c:	100b883a 	mov	r5,r2
81149e20:	e13ff817 	ldw	r4,-32(fp)
81149e24:	1140b0c0 	call	81140b0c <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149e28:	00005106 	br	81149f70 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81149e2c:	e0bffc17 	ldw	r2,-16(fp)
81149e30:	10800517 	ldw	r2,20(r2)
81149e34:	10800044 	addi	r2,r2,1
81149e38:	10800fcc 	andi	r2,r2,63
81149e3c:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81149e40:	e0bffc17 	ldw	r2,-16(fp)
81149e44:	10c00417 	ldw	r3,16(r2)
81149e48:	e0bff217 	ldw	r2,-56(fp)
81149e4c:	1880371e 	bne	r3,r2,81149f2c <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81149e50:	e0bff017 	ldw	r2,-64(fp)
81149e54:	10000526 	beq	r2,zero,81149e6c <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81149e58:	1149d800 	call	81149d80 <alt_get_errno>
81149e5c:	1007883a 	mov	r3,r2
81149e60:	008002c4 	movi	r2,11
81149e64:	18800015 	stw	r2,0(r3)
        break;
81149e68:	00004306 	br	81149f78 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149e6c:	0005303a 	rdctl	r2,status
81149e70:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149e74:	e0fff517 	ldw	r3,-44(fp)
81149e78:	00bfff84 	movi	r2,-2
81149e7c:	1884703a 	and	r2,r3,r2
81149e80:	1001703a 	wrctl	status,r2
  
  return context;
81149e84:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81149e88:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149e8c:	e0bffc17 	ldw	r2,-16(fp)
81149e90:	10800117 	ldw	r2,4(r2)
81149e94:	10c11014 	ori	r3,r2,1088
81149e98:	e0bffc17 	ldw	r2,-16(fp)
81149e9c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149ea0:	e0bffc17 	ldw	r2,-16(fp)
81149ea4:	10800017 	ldw	r2,0(r2)
81149ea8:	10800304 	addi	r2,r2,12
81149eac:	e0fffc17 	ldw	r3,-16(fp)
81149eb0:	18c00117 	ldw	r3,4(r3)
81149eb4:	10c00035 	stwio	r3,0(r2)
81149eb8:	e0bff417 	ldw	r2,-48(fp)
81149ebc:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149ec0:	e0bff117 	ldw	r2,-60(fp)
81149ec4:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81149ec8:	e0bffc17 	ldw	r2,-16(fp)
81149ecc:	10800717 	ldw	r2,28(r2)
81149ed0:	e0bff315 	stw	r2,-52(fp)
81149ed4:	00800084 	movi	r2,2
81149ed8:	e0bff98d 	sth	r2,-26(fp)
81149edc:	00bfe0c4 	movi	r2,-125
81149ee0:	e0bffa05 	stb	r2,-24(fp)
81149ee4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81149ee8:	d0a09103 	ldbu	r2,-32188(gp)
81149eec:	10803fcc 	andi	r2,r2,255
81149ef0:	10000a26 	beq	r2,zero,81149f1c <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81149ef4:	e0fff98b 	ldhu	r3,-26(fp)
81149ef8:	e13ffa03 	ldbu	r4,-24(fp)
81149efc:	e17ffa8b 	ldhu	r5,-22(fp)
81149f00:	e0bffb04 	addi	r2,fp,-20
81149f04:	d8800015 	stw	r2,0(sp)
81149f08:	280f883a 	mov	r7,r5
81149f0c:	200d883a 	mov	r6,r4
81149f10:	180b883a 	mov	r5,r3
81149f14:	e13ff317 	ldw	r4,-52(fp)
81149f18:	113ce6c0 	call	8113ce6c <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81149f1c:	e0bffc17 	ldw	r2,-16(fp)
81149f20:	10c00417 	ldw	r3,16(r2)
81149f24:	e0bff217 	ldw	r2,-56(fp)
81149f28:	18bfe726 	beq	r3,r2,81149ec8 <__reset+0xfb129ec8>
      }
    }

    count--;
81149f2c:	e0bfef17 	ldw	r2,-68(fp)
81149f30:	10bfffc4 	addi	r2,r2,-1
81149f34:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81149f38:	e0bffc17 	ldw	r2,-16(fp)
81149f3c:	10c00517 	ldw	r3,20(r2)
81149f40:	e0bffd17 	ldw	r2,-12(fp)
81149f44:	11000044 	addi	r4,r2,1
81149f48:	e13ffd15 	stw	r4,-12(fp)
81149f4c:	10800003 	ldbu	r2,0(r2)
81149f50:	1009883a 	mov	r4,r2
81149f54:	e0bffc17 	ldw	r2,-16(fp)
81149f58:	10c5883a 	add	r2,r2,r3
81149f5c:	10801a04 	addi	r2,r2,104
81149f60:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81149f64:	e0bffc17 	ldw	r2,-16(fp)
81149f68:	e0fff217 	ldw	r3,-56(fp)
81149f6c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149f70:	e0bfef17 	ldw	r2,-68(fp)
81149f74:	103fad1e 	bne	r2,zero,81149e2c <__reset+0xfb129e2c>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81149f78:	e0bffc17 	ldw	r2,-16(fp)
81149f7c:	10800917 	ldw	r2,36(r2)
81149f80:	1009883a 	mov	r4,r2
81149f84:	1140e940 	call	81140e94 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149f88:	0005303a 	rdctl	r2,status
81149f8c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149f90:	e0fff717 	ldw	r3,-36(fp)
81149f94:	00bfff84 	movi	r2,-2
81149f98:	1884703a 	and	r2,r3,r2
81149f9c:	1001703a 	wrctl	status,r2
  
  return context;
81149fa0:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81149fa4:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149fa8:	e0bffc17 	ldw	r2,-16(fp)
81149fac:	10800117 	ldw	r2,4(r2)
81149fb0:	10c11014 	ori	r3,r2,1088
81149fb4:	e0bffc17 	ldw	r2,-16(fp)
81149fb8:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149fbc:	e0bffc17 	ldw	r2,-16(fp)
81149fc0:	10800017 	ldw	r2,0(r2)
81149fc4:	10800304 	addi	r2,r2,12
81149fc8:	e0fffc17 	ldw	r3,-16(fp)
81149fcc:	18c00117 	ldw	r3,4(r3)
81149fd0:	10c00035 	stwio	r3,0(r2)
81149fd4:	e0bff417 	ldw	r2,-48(fp)
81149fd8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149fdc:	e0bff617 	ldw	r2,-40(fp)
81149fe0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81149fe4:	e0fffe17 	ldw	r3,-8(fp)
81149fe8:	e0bfef17 	ldw	r2,-68(fp)
81149fec:	1885c83a 	sub	r2,r3,r2
}
81149ff0:	e037883a 	mov	sp,fp
81149ff4:	dfc00117 	ldw	ra,4(sp)
81149ff8:	df000017 	ldw	fp,0(sp)
81149ffc:	dec00204 	addi	sp,sp,8
8114a000:	f800283a 	ret

8114a004 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114a004:	defffe04 	addi	sp,sp,-8
8114a008:	de00012e 	bgeu	sp,et,8114a010 <alt_get_errno+0xc>
8114a00c:	003b68fa 	trap	3
8114a010:	dfc00115 	stw	ra,4(sp)
8114a014:	df000015 	stw	fp,0(sp)
8114a018:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114a01c:	d0a01017 	ldw	r2,-32704(gp)
8114a020:	10000326 	beq	r2,zero,8114a030 <alt_get_errno+0x2c>
8114a024:	d0a01017 	ldw	r2,-32704(gp)
8114a028:	103ee83a 	callr	r2
8114a02c:	00000106 	br	8114a034 <alt_get_errno+0x30>
8114a030:	d0a07804 	addi	r2,gp,-32288
}
8114a034:	e037883a 	mov	sp,fp
8114a038:	dfc00117 	ldw	ra,4(sp)
8114a03c:	df000017 	ldw	fp,0(sp)
8114a040:	dec00204 	addi	sp,sp,8
8114a044:	f800283a 	ret

8114a048 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
8114a048:	defffc04 	addi	sp,sp,-16
8114a04c:	de00012e 	bgeu	sp,et,8114a054 <alt_msgdma_write_standard_descriptor+0xc>
8114a050:	003b68fa 	trap	3
8114a054:	df000315 	stw	fp,12(sp)
8114a058:	df000304 	addi	fp,sp,12
8114a05c:	e13ffd15 	stw	r4,-12(fp)
8114a060:	e17ffe15 	stw	r5,-8(fp)
8114a064:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8114a068:	e0bffd17 	ldw	r2,-12(fp)
8114a06c:	10800037 	ldwio	r2,0(r2)
8114a070:	1080010c 	andi	r2,r2,4
8114a074:	10000226 	beq	r2,zero,8114a080 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
8114a078:	00bff904 	movi	r2,-28
8114a07c:	00001506 	br	8114a0d4 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8114a080:	e0bfff17 	ldw	r2,-4(fp)
8114a084:	10800017 	ldw	r2,0(r2)
8114a088:	1007883a 	mov	r3,r2
8114a08c:	e0bffe17 	ldw	r2,-8(fp)
8114a090:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
8114a094:	e0bffe17 	ldw	r2,-8(fp)
8114a098:	10800104 	addi	r2,r2,4
8114a09c:	e0ffff17 	ldw	r3,-4(fp)
8114a0a0:	18c00117 	ldw	r3,4(r3)
8114a0a4:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
8114a0a8:	e0bffe17 	ldw	r2,-8(fp)
8114a0ac:	10800204 	addi	r2,r2,8
8114a0b0:	e0ffff17 	ldw	r3,-4(fp)
8114a0b4:	18c00217 	ldw	r3,8(r3)
8114a0b8:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
8114a0bc:	e0bffe17 	ldw	r2,-8(fp)
8114a0c0:	10800304 	addi	r2,r2,12
8114a0c4:	e0ffff17 	ldw	r3,-4(fp)
8114a0c8:	18c00317 	ldw	r3,12(r3)
8114a0cc:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
8114a0d0:	0005883a 	mov	r2,zero
}
8114a0d4:	e037883a 	mov	sp,fp
8114a0d8:	df000017 	ldw	fp,0(sp)
8114a0dc:	dec00104 	addi	sp,sp,4
8114a0e0:	f800283a 	ret

8114a0e4 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
8114a0e4:	defffc04 	addi	sp,sp,-16
8114a0e8:	de00012e 	bgeu	sp,et,8114a0f0 <alt_msgdma_write_extended_descriptor+0xc>
8114a0ec:	003b68fa 	trap	3
8114a0f0:	df000315 	stw	fp,12(sp)
8114a0f4:	df000304 	addi	fp,sp,12
8114a0f8:	e13ffd15 	stw	r4,-12(fp)
8114a0fc:	e17ffe15 	stw	r5,-8(fp)
8114a100:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8114a104:	e0bffd17 	ldw	r2,-12(fp)
8114a108:	10800037 	ldwio	r2,0(r2)
8114a10c:	1080010c 	andi	r2,r2,4
8114a110:	10000226 	beq	r2,zero,8114a11c <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
8114a114:	00bff904 	movi	r2,-28
8114a118:	00003b06 	br	8114a208 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
8114a11c:	e0bfff17 	ldw	r2,-4(fp)
8114a120:	10800017 	ldw	r2,0(r2)
8114a124:	1007883a 	mov	r3,r2
8114a128:	e0bffe17 	ldw	r2,-8(fp)
8114a12c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
8114a130:	e0bffe17 	ldw	r2,-8(fp)
8114a134:	10800104 	addi	r2,r2,4
8114a138:	e0ffff17 	ldw	r3,-4(fp)
8114a13c:	18c00117 	ldw	r3,4(r3)
8114a140:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8114a144:	e0bffe17 	ldw	r2,-8(fp)
8114a148:	10800204 	addi	r2,r2,8
8114a14c:	e0ffff17 	ldw	r3,-4(fp)
8114a150:	18c00217 	ldw	r3,8(r3)
8114a154:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
8114a158:	e0bffe17 	ldw	r2,-8(fp)
8114a15c:	10800304 	addi	r2,r2,12
8114a160:	e0ffff17 	ldw	r3,-4(fp)
8114a164:	18c0030b 	ldhu	r3,12(r3)
8114a168:	18ffffcc 	andi	r3,r3,65535
8114a16c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8114a170:	e0bffe17 	ldw	r2,-8(fp)
8114a174:	10800384 	addi	r2,r2,14
8114a178:	e0ffff17 	ldw	r3,-4(fp)
8114a17c:	18c00383 	ldbu	r3,14(r3)
8114a180:	18c03fcc 	andi	r3,r3,255
8114a184:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
8114a188:	e0bffe17 	ldw	r2,-8(fp)
8114a18c:	108003c4 	addi	r2,r2,15
8114a190:	e0ffff17 	ldw	r3,-4(fp)
8114a194:	18c003c3 	ldbu	r3,15(r3)
8114a198:	18c03fcc 	andi	r3,r3,255
8114a19c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
8114a1a0:	e0bffe17 	ldw	r2,-8(fp)
8114a1a4:	10800404 	addi	r2,r2,16
8114a1a8:	e0ffff17 	ldw	r3,-4(fp)
8114a1ac:	18c0040b 	ldhu	r3,16(r3)
8114a1b0:	18ffffcc 	andi	r3,r3,65535
8114a1b4:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
8114a1b8:	e0bffe17 	ldw	r2,-8(fp)
8114a1bc:	10800484 	addi	r2,r2,18
8114a1c0:	e0ffff17 	ldw	r3,-4(fp)
8114a1c4:	18c0048b 	ldhu	r3,18(r3)
8114a1c8:	18ffffcc 	andi	r3,r3,65535
8114a1cc:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
8114a1d0:	e0bffe17 	ldw	r2,-8(fp)
8114a1d4:	10800504 	addi	r2,r2,20
8114a1d8:	0007883a 	mov	r3,zero
8114a1dc:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
8114a1e0:	e0bffe17 	ldw	r2,-8(fp)
8114a1e4:	10800604 	addi	r2,r2,24
8114a1e8:	0007883a 	mov	r3,zero
8114a1ec:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
8114a1f0:	e0bffe17 	ldw	r2,-8(fp)
8114a1f4:	10800704 	addi	r2,r2,28
8114a1f8:	e0ffff17 	ldw	r3,-4(fp)
8114a1fc:	18c00717 	ldw	r3,28(r3)
8114a200:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
8114a204:	0005883a 	mov	r2,zero
}
8114a208:	e037883a 	mov	sp,fp
8114a20c:	df000017 	ldw	fp,0(sp)
8114a210:	dec00104 	addi	sp,sp,4
8114a214:	f800283a 	ret

8114a218 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
8114a218:	defff804 	addi	sp,sp,-32
8114a21c:	de00012e 	bgeu	sp,et,8114a224 <alt_msgdma_irq+0xc>
8114a220:	003b68fa 	trap	3
8114a224:	dfc00715 	stw	ra,28(sp)
8114a228:	df000615 	stw	fp,24(sp)
8114a22c:	df000604 	addi	fp,sp,24
8114a230:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
8114a234:	e0bfff17 	ldw	r2,-4(fp)
8114a238:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
8114a23c:	e0bffa17 	ldw	r2,-24(fp)
8114a240:	10801783 	ldbu	r2,94(r2)
8114a244:	10803fcc 	andi	r2,r2,255
8114a248:	10001126 	beq	r2,zero,8114a290 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8114a24c:	e0bffa17 	ldw	r2,-24(fp)
8114a250:	10800617 	ldw	r2,24(r2)
8114a254:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
8114a258:	1007883a 	mov	r3,r2
8114a25c:	00bffdc4 	movi	r2,-9
8114a260:	1884703a 	and	r2,r3,r2
8114a264:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8114a268:	e0bffa17 	ldw	r2,-24(fp)
8114a26c:	10800617 	ldw	r2,24(r2)
8114a270:	e0fffb17 	ldw	r3,-20(fp)
8114a274:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
8114a278:	e0bffa17 	ldw	r2,-24(fp)
8114a27c:	10800617 	ldw	r2,24(r2)
8114a280:	10800404 	addi	r2,r2,16
8114a284:	00c00044 	movi	r3,1
8114a288:	10c00035 	stwio	r3,0(r2)
8114a28c:	00001106 	br	8114a2d4 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114a290:	e0bffa17 	ldw	r2,-24(fp)
8114a294:	10800317 	ldw	r2,12(r2)
8114a298:	10800104 	addi	r2,r2,4
8114a29c:	10800037 	ldwio	r2,0(r2)
8114a2a0:	1007883a 	mov	r3,r2
8114a2a4:	00bffbc4 	movi	r2,-17
8114a2a8:	1884703a 	and	r2,r3,r2
8114a2ac:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114a2b0:	e0bffa17 	ldw	r2,-24(fp)
8114a2b4:	10800317 	ldw	r2,12(r2)
8114a2b8:	10800104 	addi	r2,r2,4
8114a2bc:	e0fffb17 	ldw	r3,-20(fp)
8114a2c0:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8114a2c4:	e0bffa17 	ldw	r2,-24(fp)
8114a2c8:	10800317 	ldw	r2,12(r2)
8114a2cc:	00c08004 	movi	r3,512
8114a2d0:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
8114a2d4:	e0bffa17 	ldw	r2,-24(fp)
8114a2d8:	10800b17 	ldw	r2,44(r2)
8114a2dc:	10001226 	beq	r2,zero,8114a328 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a2e0:	0005303a 	rdctl	r2,status
8114a2e4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a2e8:	e0fffd17 	ldw	r3,-12(fp)
8114a2ec:	00bfff84 	movi	r2,-2
8114a2f0:	1884703a 	and	r2,r3,r2
8114a2f4:	1001703a 	wrctl	status,r2
  
  return context;
8114a2f8:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
8114a2fc:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
8114a300:	e0bffa17 	ldw	r2,-24(fp)
8114a304:	10800b17 	ldw	r2,44(r2)
8114a308:	e0fffa17 	ldw	r3,-24(fp)
8114a30c:	18c00c17 	ldw	r3,48(r3)
8114a310:	1809883a 	mov	r4,r3
8114a314:	103ee83a 	callr	r2
8114a318:	e0bffc17 	ldw	r2,-16(fp)
8114a31c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a320:	e0bffe17 	ldw	r2,-8(fp)
8114a324:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
8114a328:	e0bffa17 	ldw	r2,-24(fp)
8114a32c:	10801783 	ldbu	r2,94(r2)
8114a330:	10803fcc 	andi	r2,r2,255
8114a334:	10000a26 	beq	r2,zero,8114a360 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8114a338:	e0bffa17 	ldw	r2,-24(fp)
8114a33c:	10800617 	ldw	r2,24(r2)
8114a340:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114a344:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
8114a348:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8114a34c:	e0bffa17 	ldw	r2,-24(fp)
8114a350:	10800617 	ldw	r2,24(r2)
8114a354:	e0fffb17 	ldw	r3,-20(fp)
8114a358:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
8114a35c:	00000c06 	br	8114a390 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114a360:	e0bffa17 	ldw	r2,-24(fp)
8114a364:	10800317 	ldw	r2,12(r2)
8114a368:	10800104 	addi	r2,r2,4
8114a36c:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
8114a370:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114a374:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114a378:	e0bffa17 	ldw	r2,-24(fp)
8114a37c:	10800317 	ldw	r2,12(r2)
8114a380:	10800104 	addi	r2,r2,4
8114a384:	e0fffb17 	ldw	r3,-20(fp)
8114a388:	10c00035 	stwio	r3,0(r2)
    }

    return;
8114a38c:	0001883a 	nop
}
8114a390:	e037883a 	mov	sp,fp
8114a394:	dfc00117 	ldw	ra,4(sp)
8114a398:	df000017 	ldw	fp,0(sp)
8114a39c:	dec00204 	addi	sp,sp,8
8114a3a0:	f800283a 	ret

8114a3a4 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a3a4:	defffb04 	addi	sp,sp,-20
8114a3a8:	de00012e 	bgeu	sp,et,8114a3b0 <alt_msgdma_construct_standard_descriptor+0xc>
8114a3ac:	003b68fa 	trap	3
8114a3b0:	df000415 	stw	fp,16(sp)
8114a3b4:	df000404 	addi	fp,sp,16
8114a3b8:	e13ffc15 	stw	r4,-16(fp)
8114a3bc:	e17ffd15 	stw	r5,-12(fp)
8114a3c0:	e1bffe15 	stw	r6,-8(fp)
8114a3c4:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114a3c8:	e0bffc17 	ldw	r2,-16(fp)
8114a3cc:	10c01217 	ldw	r3,72(r2)
8114a3d0:	e0800117 	ldw	r2,4(fp)
8114a3d4:	18800436 	bltu	r3,r2,8114a3e8 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114a3d8:	e0bffc17 	ldw	r2,-16(fp)
8114a3dc:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114a3e0:	10803fcc 	andi	r2,r2,255
8114a3e4:	10000226 	beq	r2,zero,8114a3f0 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114a3e8:	00bffa84 	movi	r2,-22
8114a3ec:	00000e06 	br	8114a428 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
8114a3f0:	e0bffd17 	ldw	r2,-12(fp)
8114a3f4:	e0fffe17 	ldw	r3,-8(fp)
8114a3f8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114a3fc:	e0bffd17 	ldw	r2,-12(fp)
8114a400:	e0ffff17 	ldw	r3,-4(fp)
8114a404:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a408:	e0bffd17 	ldw	r2,-12(fp)
8114a40c:	e0c00117 	ldw	r3,4(fp)
8114a410:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a414:	e0800217 	ldw	r2,8(fp)
8114a418:	10e00034 	orhi	r3,r2,32768
8114a41c:	e0bffd17 	ldw	r2,-12(fp)
8114a420:	10c00315 	stw	r3,12(r2)
    
    return 0;
8114a424:	0005883a 	mov	r2,zero
}
8114a428:	e037883a 	mov	sp,fp
8114a42c:	df000017 	ldw	fp,0(sp)
8114a430:	dec00104 	addi	sp,sp,4
8114a434:	f800283a 	ret

8114a438 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114a438:	defff604 	addi	sp,sp,-40
8114a43c:	de00012e 	bgeu	sp,et,8114a444 <alt_msgdma_construct_extended_descriptor+0xc>
8114a440:	003b68fa 	trap	3
8114a444:	df000915 	stw	fp,36(sp)
8114a448:	df000904 	addi	fp,sp,36
8114a44c:	e13ff715 	stw	r4,-36(fp)
8114a450:	e17ff815 	stw	r5,-32(fp)
8114a454:	e1bff915 	stw	r6,-28(fp)
8114a458:	e1fffa15 	stw	r7,-24(fp)
8114a45c:	e1800317 	ldw	r6,12(fp)
8114a460:	e1400417 	ldw	r5,16(fp)
8114a464:	e1000517 	ldw	r4,20(fp)
8114a468:	e0c00617 	ldw	r3,24(fp)
8114a46c:	e0800717 	ldw	r2,28(fp)
8114a470:	e1bffb0d 	sth	r6,-20(fp)
8114a474:	e17ffc05 	stb	r5,-16(fp)
8114a478:	e13ffd05 	stb	r4,-12(fp)
8114a47c:	e0fffe0d 	sth	r3,-8(fp)
8114a480:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8114a484:	e0bff717 	ldw	r2,-36(fp)
8114a488:	10c01217 	ldw	r3,72(r2)
8114a48c:	e0800117 	ldw	r2,4(fp)
8114a490:	18801936 	bltu	r3,r2,8114a4f8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114a494:	e13ff717 	ldw	r4,-36(fp)
8114a498:	20801317 	ldw	r2,76(r4)
8114a49c:	20c01417 	ldw	r3,80(r4)
8114a4a0:	e13ffe0b 	ldhu	r4,-8(fp)
8114a4a4:	213fffcc 	andi	r4,r4,65535
8114a4a8:	2015883a 	mov	r10,r4
8114a4ac:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
8114a4b0:	1ac01136 	bltu	r3,r11,8114a4f8 <alt_msgdma_construct_extended_descriptor+0xc0>
8114a4b4:	58c0011e 	bne	r11,r3,8114a4bc <alt_msgdma_construct_extended_descriptor+0x84>
8114a4b8:	12800f36 	bltu	r2,r10,8114a4f8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a4bc:	e13ff717 	ldw	r4,-36(fp)
8114a4c0:	20801317 	ldw	r2,76(r4)
8114a4c4:	20c01417 	ldw	r3,80(r4)
8114a4c8:	e13fff0b 	ldhu	r4,-4(fp)
8114a4cc:	213fffcc 	andi	r4,r4,65535
8114a4d0:	2011883a 	mov	r8,r4
8114a4d4:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8114a4d8:	1a400736 	bltu	r3,r9,8114a4f8 <alt_msgdma_construct_extended_descriptor+0xc0>
8114a4dc:	48c0011e 	bne	r9,r3,8114a4e4 <alt_msgdma_construct_extended_descriptor+0xac>
8114a4e0:	12000536 	bltu	r2,r8,8114a4f8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114a4e4:	e0bff717 	ldw	r2,-36(fp)
8114a4e8:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a4ec:	10803fcc 	andi	r2,r2,255
8114a4f0:	10800060 	cmpeqi	r2,r2,1
8114a4f4:	1000021e 	bne	r2,zero,8114a500 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8114a4f8:	00bffa84 	movi	r2,-22
8114a4fc:	00002106 	br	8114a584 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8114a500:	e0bff817 	ldw	r2,-32(fp)
8114a504:	e0fff917 	ldw	r3,-28(fp)
8114a508:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
8114a50c:	e0bff817 	ldw	r2,-32(fp)
8114a510:	e0fffa17 	ldw	r3,-24(fp)
8114a514:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a518:	e0bff817 	ldw	r2,-32(fp)
8114a51c:	e0c00117 	ldw	r3,4(fp)
8114a520:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114a524:	e0bff817 	ldw	r2,-32(fp)
8114a528:	e0fffb0b 	ldhu	r3,-20(fp)
8114a52c:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
8114a530:	e0bff817 	ldw	r2,-32(fp)
8114a534:	e0fffc03 	ldbu	r3,-16(fp)
8114a538:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
8114a53c:	e0bff817 	ldw	r2,-32(fp)
8114a540:	e0fffd03 	ldbu	r3,-12(fp)
8114a544:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
8114a548:	e0bff817 	ldw	r2,-32(fp)
8114a54c:	e0fffe0b 	ldhu	r3,-8(fp)
8114a550:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8114a554:	e0bff817 	ldw	r2,-32(fp)
8114a558:	e0ffff0b 	ldhu	r3,-4(fp)
8114a55c:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
8114a560:	e0bff817 	ldw	r2,-32(fp)
8114a564:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
8114a568:	e0bff817 	ldw	r2,-32(fp)
8114a56c:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a570:	e0800217 	ldw	r2,8(fp)
8114a574:	10e00034 	orhi	r3,r2,32768
8114a578:	e0bff817 	ldw	r2,-32(fp)
8114a57c:	10c00715 	stw	r3,28(r2)

  return 0 ;
8114a580:	0005883a 	mov	r2,zero

}
8114a584:	e037883a 	mov	sp,fp
8114a588:	df000017 	ldw	fp,0(sp)
8114a58c:	dec00104 	addi	sp,sp,4
8114a590:	f800283a 	ret

8114a594 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114a594:	deffee04 	addi	sp,sp,-72
8114a598:	de00012e 	bgeu	sp,et,8114a5a0 <alt_msgdma_descriptor_async_transfer+0xc>
8114a59c:	003b68fa 	trap	3
8114a5a0:	dfc01115 	stw	ra,68(sp)
8114a5a4:	df001015 	stw	fp,64(sp)
8114a5a8:	df001004 	addi	fp,sp,64
8114a5ac:	e13ffd15 	stw	r4,-12(fp)
8114a5b0:	e17ffe15 	stw	r5,-8(fp)
8114a5b4:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
8114a5b8:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
8114a5bc:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
8114a5c0:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a5c4:	e0bffd17 	ldw	r2,-12(fp)
8114a5c8:	10800317 	ldw	r2,12(r2)
8114a5cc:	10800204 	addi	r2,r2,8
8114a5d0:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8114a5d4:	10bfffcc 	andi	r2,r2,65535
8114a5d8:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a5dc:	e0bffd17 	ldw	r2,-12(fp)
8114a5e0:	10800317 	ldw	r2,12(r2)
8114a5e4:	10800204 	addi	r2,r2,8
8114a5e8:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114a5ec:	1004d43a 	srli	r2,r2,16
8114a5f0:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a5f4:	e0bffd17 	ldw	r2,-12(fp)
8114a5f8:	10800917 	ldw	r2,36(r2)
8114a5fc:	e0fff417 	ldw	r3,-48(fp)
8114a600:	1880042e 	bgeu	r3,r2,8114a614 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114a604:	e0bffd17 	ldw	r2,-12(fp)
8114a608:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a60c:	e0fff317 	ldw	r3,-52(fp)
8114a610:	18800236 	bltu	r3,r2,8114a61c <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
8114a614:	00bff904 	movi	r2,-28
8114a618:	0000a906 	br	8114a8c0 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
8114a61c:	e0bffd17 	ldw	r2,-12(fp)
8114a620:	10801817 	ldw	r2,96(r2)
8114a624:	e0bff615 	stw	r2,-40(fp)
8114a628:	e03ffc0d 	sth	zero,-16(fp)
8114a62c:	e0bffc0b 	ldhu	r2,-16(fp)
8114a630:	e0fffc84 	addi	r3,fp,-14
8114a634:	180d883a 	mov	r6,r3
8114a638:	100b883a 	mov	r5,r2
8114a63c:	e13ff617 	ldw	r4,-40(fp)
8114a640:	1140b0c0 	call	81140b0c <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114a644:	00800804 	movi	r2,32
8114a648:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a64c:	0005303a 	rdctl	r2,status
8114a650:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a654:	e0fff717 	ldw	r3,-36(fp)
8114a658:	00bfff84 	movi	r2,-2
8114a65c:	1884703a 	and	r2,r3,r2
8114a660:	1001703a 	wrctl	status,r2
  
  return context;
8114a664:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114a668:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a66c:	e0bffd17 	ldw	r2,-12(fp)
8114a670:	10800317 	ldw	r2,12(r2)
8114a674:	10800104 	addi	r2,r2,4
8114a678:	e0fff117 	ldw	r3,-60(fp)
8114a67c:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114a680:	e0bffd17 	ldw	r2,-12(fp)
8114a684:	10800317 	ldw	r2,12(r2)
8114a688:	e0fffd17 	ldw	r3,-12(fp)
8114a68c:	18c00317 	ldw	r3,12(r3)
8114a690:	18c00037 	ldwio	r3,0(r3)
8114a694:	10c00035 	stwio	r3,0(r2)
8114a698:	e0bff217 	ldw	r2,-56(fp)
8114a69c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a6a0:	e0bffb17 	ldw	r2,-20(fp)
8114a6a4:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114a6a8:	e0bffe17 	ldw	r2,-8(fp)
8114a6ac:	10001e26 	beq	r2,zero,8114a728 <alt_msgdma_descriptor_async_transfer+0x194>
8114a6b0:	e0bfff17 	ldw	r2,-4(fp)
8114a6b4:	10001c1e 	bne	r2,zero,8114a728 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114a6b8:	00001106 	br	8114a700 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114a6bc:	01000044 	movi	r4,1
8114a6c0:	11382940 	call	81138294 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a6c4:	e0bff00b 	ldhu	r2,-64(fp)
8114a6c8:	1084e230 	cmpltui	r2,r2,5000
8114a6cc:	1000091e 	bne	r2,zero,8114a6f4 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
8114a6d0:	01204574 	movhi	r4,33045
8114a6d4:	210c6104 	addi	r4,r4,12676
8114a6d8:	114c9e80 	call	8114c9e8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114a6dc:	e0bffd17 	ldw	r2,-12(fp)
8114a6e0:	10801817 	ldw	r2,96(r2)
8114a6e4:	1009883a 	mov	r4,r2
8114a6e8:	1140e940 	call	81140e94 <OSSemPost>
				
                return -ETIME;
8114a6ec:	00bff084 	movi	r2,-62
8114a6f0:	00007306 	br	8114a8c0 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8114a6f4:	e0bff00b 	ldhu	r2,-64(fp)
8114a6f8:	10800044 	addi	r2,r2,1
8114a6fc:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114a700:	e0bffd17 	ldw	r2,-12(fp)
8114a704:	10c00317 	ldw	r3,12(r2)
8114a708:	e0bffd17 	ldw	r2,-12(fp)
8114a70c:	10800417 	ldw	r2,16(r2)
8114a710:	e1bffe17 	ldw	r6,-8(fp)
8114a714:	100b883a 	mov	r5,r2
8114a718:	1809883a 	mov	r4,r3
8114a71c:	114a0480 	call	8114a048 <alt_msgdma_write_standard_descriptor>
8114a720:	103fe61e 	bne	r2,zero,8114a6bc <__reset+0xfb12a6bc>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114a724:	00002706 	br	8114a7c4 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114a728:	e0bffe17 	ldw	r2,-8(fp)
8114a72c:	10001f1e 	bne	r2,zero,8114a7ac <alt_msgdma_descriptor_async_transfer+0x218>
8114a730:	e0bfff17 	ldw	r2,-4(fp)
8114a734:	10001d26 	beq	r2,zero,8114a7ac <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
8114a738:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114a73c:	00001106 	br	8114a784 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114a740:	01000044 	movi	r4,1
8114a744:	11382940 	call	81138294 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a748:	e0bff00b 	ldhu	r2,-64(fp)
8114a74c:	1084e230 	cmpltui	r2,r2,5000
8114a750:	1000091e 	bne	r2,zero,8114a778 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8114a754:	01204574 	movhi	r4,33045
8114a758:	210c7704 	addi	r4,r4,12764
8114a75c:	114c9e80 	call	8114c9e8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114a760:	e0bffd17 	ldw	r2,-12(fp)
8114a764:	10801817 	ldw	r2,96(r2)
8114a768:	1009883a 	mov	r4,r2
8114a76c:	1140e940 	call	81140e94 <OSSemPost>
				
                return -ETIME;
8114a770:	00bff084 	movi	r2,-62
8114a774:	00005206 	br	8114a8c0 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8114a778:	e0bff00b 	ldhu	r2,-64(fp)
8114a77c:	10800044 	addi	r2,r2,1
8114a780:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114a784:	e0bffd17 	ldw	r2,-12(fp)
8114a788:	10c00317 	ldw	r3,12(r2)
8114a78c:	e0bffd17 	ldw	r2,-12(fp)
8114a790:	10800417 	ldw	r2,16(r2)
8114a794:	e1bfff17 	ldw	r6,-4(fp)
8114a798:	100b883a 	mov	r5,r2
8114a79c:	1809883a 	mov	r4,r3
8114a7a0:	114a0e40 	call	8114a0e4 <alt_msgdma_write_extended_descriptor>
8114a7a4:	103fe61e 	bne	r2,zero,8114a740 <__reset+0xfb12a740>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114a7a8:	00000606 	br	8114a7c4 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114a7ac:	e0bffd17 	ldw	r2,-12(fp)
8114a7b0:	10801817 	ldw	r2,96(r2)
8114a7b4:	1009883a 	mov	r4,r2
8114a7b8:	1140e940 	call	81140e94 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8114a7bc:	00bfffc4 	movi	r2,-1
8114a7c0:	00003f06 	br	8114a8c0 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8114a7c4:	e0bffd17 	ldw	r2,-12(fp)
8114a7c8:	10800b17 	ldw	r2,44(r2)
8114a7cc:	10001c26 	beq	r2,zero,8114a840 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
8114a7d0:	e0bffd17 	ldw	r2,-12(fp)
8114a7d4:	10c00d17 	ldw	r3,52(r2)
8114a7d8:	e0bff117 	ldw	r2,-60(fp)
8114a7dc:	1884b03a 	or	r2,r3,r2
8114a7e0:	10800514 	ori	r2,r2,20
8114a7e4:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114a7e8:	e0fff117 	ldw	r3,-60(fp)
8114a7ec:	00bff7c4 	movi	r2,-33
8114a7f0:	1884703a 	and	r2,r3,r2
8114a7f4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a7f8:	0005303a 	rdctl	r2,status
8114a7fc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a800:	e0fff917 	ldw	r3,-28(fp)
8114a804:	00bfff84 	movi	r2,-2
8114a808:	1884703a 	and	r2,r3,r2
8114a80c:	1001703a 	wrctl	status,r2
  
  return context;
8114a810:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
8114a814:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a818:	e0bffd17 	ldw	r2,-12(fp)
8114a81c:	10800317 	ldw	r2,12(r2)
8114a820:	10800104 	addi	r2,r2,4
8114a824:	e0fff117 	ldw	r3,-60(fp)
8114a828:	10c00035 	stwio	r3,0(r2)
8114a82c:	e0bff217 	ldw	r2,-56(fp)
8114a830:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a834:	e0bff517 	ldw	r2,-44(fp)
8114a838:	1001703a 	wrctl	status,r2
8114a83c:	00001b06 	br	8114a8ac <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
8114a840:	e0bffd17 	ldw	r2,-12(fp)
8114a844:	10c00d17 	ldw	r3,52(r2)
8114a848:	e0bff117 	ldw	r2,-60(fp)
8114a84c:	1884b03a 	or	r2,r3,r2
8114a850:	10800114 	ori	r2,r2,4
8114a854:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
8114a858:	e0fff117 	ldw	r3,-60(fp)
8114a85c:	00bff3c4 	movi	r2,-49
8114a860:	1884703a 	and	r2,r3,r2
8114a864:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a868:	0005303a 	rdctl	r2,status
8114a86c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a870:	e0fffa17 	ldw	r3,-24(fp)
8114a874:	00bfff84 	movi	r2,-2
8114a878:	1884703a 	and	r2,r3,r2
8114a87c:	1001703a 	wrctl	status,r2
  
  return context;
8114a880:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8114a884:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a888:	e0bffd17 	ldw	r2,-12(fp)
8114a88c:	10800317 	ldw	r2,12(r2)
8114a890:	10800104 	addi	r2,r2,4
8114a894:	e0fff117 	ldw	r3,-60(fp)
8114a898:	10c00035 	stwio	r3,0(r2)
8114a89c:	e0bff217 	ldw	r2,-56(fp)
8114a8a0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a8a4:	e0bff817 	ldw	r2,-32(fp)
8114a8a8:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
8114a8ac:	e0bffd17 	ldw	r2,-12(fp)
8114a8b0:	10801817 	ldw	r2,96(r2)
8114a8b4:	1009883a 	mov	r4,r2
8114a8b8:	1140e940 	call	81140e94 <OSSemPost>
    
    return 0;
8114a8bc:	0005883a 	mov	r2,zero
}
8114a8c0:	e037883a 	mov	sp,fp
8114a8c4:	dfc00117 	ldw	ra,4(sp)
8114a8c8:	df000017 	ldw	fp,0(sp)
8114a8cc:	dec00204 	addi	sp,sp,8
8114a8d0:	f800283a 	ret

8114a8d4 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114a8d4:	deffee04 	addi	sp,sp,-72
8114a8d8:	de00012e 	bgeu	sp,et,8114a8e0 <alt_msgdma_descriptor_sync_transfer+0xc>
8114a8dc:	003b68fa 	trap	3
8114a8e0:	dfc01115 	stw	ra,68(sp)
8114a8e4:	df001015 	stw	fp,64(sp)
8114a8e8:	df001004 	addi	fp,sp,64
8114a8ec:	e13ffd15 	stw	r4,-12(fp)
8114a8f0:	e17ffe15 	stw	r5,-8(fp)
8114a8f4:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
8114a8f8:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
8114a8fc:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8114a900:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
8114a904:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a908:	e0bffd17 	ldw	r2,-12(fp)
8114a90c:	10800317 	ldw	r2,12(r2)
8114a910:	10800204 	addi	r2,r2,8
8114a914:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8114a918:	10bfffcc 	andi	r2,r2,65535
8114a91c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a920:	e0bffd17 	ldw	r2,-12(fp)
8114a924:	10800317 	ldw	r2,12(r2)
8114a928:	10800204 	addi	r2,r2,8
8114a92c:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114a930:	1004d43a 	srli	r2,r2,16
8114a934:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
8114a938:	00807804 	movi	r2,480
8114a93c:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a940:	00001906 	br	8114a9a8 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
8114a944:	01000044 	movi	r4,1
8114a948:	11382940 	call	81138294 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a94c:	e0bff10b 	ldhu	r2,-60(fp)
8114a950:	1084e230 	cmpltui	r2,r2,5000
8114a954:	1000051e 	bne	r2,zero,8114a96c <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
8114a958:	01204574 	movhi	r4,33045
8114a95c:	210c8d04 	addi	r4,r4,12852
8114a960:	114c9e80 	call	8114c9e8 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8114a964:	00bff084 	movi	r2,-62
8114a968:	0000d706 	br	8114acc8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
8114a96c:	e0bff10b 	ldhu	r2,-60(fp)
8114a970:	10800044 	addi	r2,r2,1
8114a974:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a978:	e0bffd17 	ldw	r2,-12(fp)
8114a97c:	10800317 	ldw	r2,12(r2)
8114a980:	10800204 	addi	r2,r2,8
8114a984:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
8114a988:	10bfffcc 	andi	r2,r2,65535
8114a98c:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a990:	e0bffd17 	ldw	r2,-12(fp)
8114a994:	10800317 	ldw	r2,12(r2)
8114a998:	10800204 	addi	r2,r2,8
8114a99c:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8114a9a0:	1004d43a 	srli	r2,r2,16
8114a9a4:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a9a8:	e0bffd17 	ldw	r2,-12(fp)
8114a9ac:	10800917 	ldw	r2,36(r2)
8114a9b0:	e0fff317 	ldw	r3,-52(fp)
8114a9b4:	18bfe32e 	bgeu	r3,r2,8114a944 <__reset+0xfb12a944>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114a9b8:	e0bffd17 	ldw	r2,-12(fp)
8114a9bc:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a9c0:	e0fff217 	ldw	r3,-56(fp)
8114a9c4:	18bfdf2e 	bgeu	r3,r2,8114a944 <__reset+0xfb12a944>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114a9c8:	e0bffd17 	ldw	r2,-12(fp)
8114a9cc:	10801817 	ldw	r2,96(r2)
8114a9d0:	e0bff815 	stw	r2,-32(fp)
8114a9d4:	e03ffc0d 	sth	zero,-16(fp)
8114a9d8:	e0bffc0b 	ldhu	r2,-16(fp)
8114a9dc:	e0fffc84 	addi	r3,fp,-14
8114a9e0:	180d883a 	mov	r6,r3
8114a9e4:	100b883a 	mov	r5,r2
8114a9e8:	e13ff817 	ldw	r4,-32(fp)
8114a9ec:	1140b0c0 	call	81140b0c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a9f0:	0005303a 	rdctl	r2,status
8114a9f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a9f8:	e0fffb17 	ldw	r3,-20(fp)
8114a9fc:	00bfff84 	movi	r2,-2
8114aa00:	1884703a 	and	r2,r3,r2
8114aa04:	1001703a 	wrctl	status,r2
  
  return context;
8114aa08:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
8114aa0c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8114aa10:	e0bffd17 	ldw	r2,-12(fp)
8114aa14:	10800317 	ldw	r2,12(r2)
8114aa18:	10800104 	addi	r2,r2,4
8114aa1c:	00c00804 	movi	r3,32
8114aa20:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114aa24:	e0bffd17 	ldw	r2,-12(fp)
8114aa28:	10800317 	ldw	r2,12(r2)
8114aa2c:	e0fffd17 	ldw	r3,-12(fp)
8114aa30:	18c00317 	ldw	r3,12(r3)
8114aa34:	18c00037 	ldwio	r3,0(r3)
8114aa38:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8114aa3c:	e0bffe17 	ldw	r2,-8(fp)
8114aa40:	10001f26 	beq	r2,zero,8114aac0 <alt_msgdma_descriptor_sync_transfer+0x1ec>
8114aa44:	e0bfff17 	ldw	r2,-4(fp)
8114aa48:	10001d1e 	bne	r2,zero,8114aac0 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
8114aa4c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114aa50:	00001106 	br	8114aa98 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
8114aa54:	01000044 	movi	r4,1
8114aa58:	11382940 	call	81138294 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114aa5c:	e0bff10b 	ldhu	r2,-60(fp)
8114aa60:	1084e230 	cmpltui	r2,r2,5000
8114aa64:	1000091e 	bne	r2,zero,8114aa8c <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
8114aa68:	01204574 	movhi	r4,33045
8114aa6c:	210ca104 	addi	r4,r4,12932
8114aa70:	114c9e80 	call	8114c9e8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114aa74:	e0bffd17 	ldw	r2,-12(fp)
8114aa78:	10801817 	ldw	r2,96(r2)
8114aa7c:	1009883a 	mov	r4,r2
8114aa80:	1140e940 	call	81140e94 <OSSemPost>
				
                return -ETIME;
8114aa84:	00bff084 	movi	r2,-62
8114aa88:	00008f06 	br	8114acc8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
8114aa8c:	e0bff10b 	ldhu	r2,-60(fp)
8114aa90:	10800044 	addi	r2,r2,1
8114aa94:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114aa98:	e0bffd17 	ldw	r2,-12(fp)
8114aa9c:	10c00317 	ldw	r3,12(r2)
8114aaa0:	e0bffd17 	ldw	r2,-12(fp)
8114aaa4:	10800417 	ldw	r2,16(r2)
8114aaa8:	e1bffe17 	ldw	r6,-8(fp)
8114aaac:	100b883a 	mov	r5,r2
8114aab0:	1809883a 	mov	r4,r3
8114aab4:	114a0480 	call	8114a048 <alt_msgdma_write_standard_descriptor>
8114aab8:	103fe61e 	bne	r2,zero,8114aa54 <__reset+0xfb12aa54>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8114aabc:	00002706 	br	8114ab5c <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114aac0:	e0bffe17 	ldw	r2,-8(fp)
8114aac4:	10001f1e 	bne	r2,zero,8114ab44 <alt_msgdma_descriptor_sync_transfer+0x270>
8114aac8:	e0bfff17 	ldw	r2,-4(fp)
8114aacc:	10001d26 	beq	r2,zero,8114ab44 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8114aad0:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114aad4:	00001106 	br	8114ab1c <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114aad8:	01000044 	movi	r4,1
8114aadc:	11382940 	call	81138294 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114aae0:	e0bff10b 	ldhu	r2,-60(fp)
8114aae4:	1084e230 	cmpltui	r2,r2,5000
8114aae8:	1000091e 	bne	r2,zero,8114ab10 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
8114aaec:	01204574 	movhi	r4,33045
8114aaf0:	210cb204 	addi	r4,r4,13000
8114aaf4:	114c9e80 	call	8114c9e8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114aaf8:	e0bffd17 	ldw	r2,-12(fp)
8114aafc:	10801817 	ldw	r2,96(r2)
8114ab00:	1009883a 	mov	r4,r2
8114ab04:	1140e940 	call	81140e94 <OSSemPost>
				
                return -ETIME;
8114ab08:	00bff084 	movi	r2,-62
8114ab0c:	00006e06 	br	8114acc8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
8114ab10:	e0bff10b 	ldhu	r2,-60(fp)
8114ab14:	10800044 	addi	r2,r2,1
8114ab18:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114ab1c:	e0bffd17 	ldw	r2,-12(fp)
8114ab20:	10c00317 	ldw	r3,12(r2)
8114ab24:	e0bffd17 	ldw	r2,-12(fp)
8114ab28:	10800417 	ldw	r2,16(r2)
8114ab2c:	e1bfff17 	ldw	r6,-4(fp)
8114ab30:	100b883a 	mov	r5,r2
8114ab34:	1809883a 	mov	r4,r3
8114ab38:	114a0e40 	call	8114a0e4 <alt_msgdma_write_extended_descriptor>
8114ab3c:	103fe61e 	bne	r2,zero,8114aad8 <__reset+0xfb12aad8>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114ab40:	00000606 	br	8114ab5c <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114ab44:	e0bffd17 	ldw	r2,-12(fp)
8114ab48:	10801817 	ldw	r2,96(r2)
8114ab4c:	1009883a 	mov	r4,r2
8114ab50:	1140e940 	call	81140e94 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8114ab54:	00bfffc4 	movi	r2,-1
8114ab58:	00005b06 	br	8114acc8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8114ab5c:	e0bffd17 	ldw	r2,-12(fp)
8114ab60:	10800317 	ldw	r2,12(r2)
8114ab64:	10800104 	addi	r2,r2,4
8114ab68:	e0fffd17 	ldw	r3,-12(fp)
8114ab6c:	19000d17 	ldw	r4,52(r3)
8114ab70:	00fff2c4 	movi	r3,-53
8114ab74:	20c6703a 	and	r3,r4,r3
8114ab78:	18c00114 	ori	r3,r3,4
8114ab7c:	10c00035 	stwio	r3,0(r2)
8114ab80:	e0bff517 	ldw	r2,-44(fp)
8114ab84:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ab88:	e0bff717 	ldw	r2,-36(fp)
8114ab8c:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8114ab90:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8114ab94:	e0bffd17 	ldw	r2,-12(fp)
8114ab98:	10800317 	ldw	r2,12(r2)
8114ab9c:	10800037 	ldwio	r2,0(r2)
8114aba0:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8114aba4:	00001506 	br	8114abfc <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
8114aba8:	01000044 	movi	r4,1
8114abac:	11382940 	call	81138294 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114abb0:	e0bff10b 	ldhu	r2,-60(fp)
8114abb4:	1084e230 	cmpltui	r2,r2,5000
8114abb8:	1000091e 	bne	r2,zero,8114abe0 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
8114abbc:	01204574 	movhi	r4,33045
8114abc0:	210cc304 	addi	r4,r4,13068
8114abc4:	114c9e80 	call	8114c9e8 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
8114abc8:	e0bffd17 	ldw	r2,-12(fp)
8114abcc:	10801817 	ldw	r2,96(r2)
8114abd0:	1009883a 	mov	r4,r2
8114abd4:	1140e940 	call	81140e94 <OSSemPost>
			
            return -ETIME;
8114abd8:	00bff084 	movi	r2,-62
8114abdc:	00003a06 	br	8114acc8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8114abe0:	e0bff10b 	ldhu	r2,-60(fp)
8114abe4:	10800044 	addi	r2,r2,1
8114abe8:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8114abec:	e0bffd17 	ldw	r2,-12(fp)
8114abf0:	10800317 	ldw	r2,12(r2)
8114abf4:	10800037 	ldwio	r2,0(r2)
8114abf8:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8114abfc:	e0fff017 	ldw	r3,-64(fp)
8114ac00:	e0bff617 	ldw	r2,-40(fp)
8114ac04:	1884703a 	and	r2,r3,r2
8114ac08:	1000031e 	bne	r2,zero,8114ac18 <alt_msgdma_descriptor_sync_transfer+0x344>
8114ac0c:	e0bff017 	ldw	r2,-64(fp)
8114ac10:	1080004c 	andi	r2,r2,1
8114ac14:	103fe41e 	bne	r2,zero,8114aba8 <__reset+0xfb12aba8>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
8114ac18:	e0fff017 	ldw	r3,-64(fp)
8114ac1c:	e0bff617 	ldw	r2,-40(fp)
8114ac20:	1884703a 	and	r2,r3,r2
8114ac24:	10000626 	beq	r2,zero,8114ac40 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114ac28:	e0bffd17 	ldw	r2,-12(fp)
8114ac2c:	10801817 	ldw	r2,96(r2)
8114ac30:	1009883a 	mov	r4,r2
8114ac34:	1140e940 	call	81140e94 <OSSemPost>
		
        return error;
8114ac38:	e0bff617 	ldw	r2,-40(fp)
8114ac3c:	00002206 	br	8114acc8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
8114ac40:	e0bffd17 	ldw	r2,-12(fp)
8114ac44:	10800317 	ldw	r2,12(r2)
8114ac48:	10800104 	addi	r2,r2,4
8114ac4c:	10800037 	ldwio	r2,0(r2)
8114ac50:	10800814 	ori	r2,r2,32
8114ac54:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ac58:	0005303a 	rdctl	r2,status
8114ac5c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ac60:	e0fffa17 	ldw	r3,-24(fp)
8114ac64:	00bfff84 	movi	r2,-2
8114ac68:	1884703a 	and	r2,r3,r2
8114ac6c:	1001703a 	wrctl	status,r2
  
  return context;
8114ac70:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
8114ac74:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114ac78:	e0bffd17 	ldw	r2,-12(fp)
8114ac7c:	10800317 	ldw	r2,12(r2)
8114ac80:	10800104 	addi	r2,r2,4
8114ac84:	e0fff417 	ldw	r3,-48(fp)
8114ac88:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114ac8c:	e0bffd17 	ldw	r2,-12(fp)
8114ac90:	10800317 	ldw	r2,12(r2)
8114ac94:	e0fffd17 	ldw	r3,-12(fp)
8114ac98:	18c00317 	ldw	r3,12(r3)
8114ac9c:	18c00037 	ldwio	r3,0(r3)
8114aca0:	10c00035 	stwio	r3,0(r2)
8114aca4:	e0bff517 	ldw	r2,-44(fp)
8114aca8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114acac:	e0bff917 	ldw	r2,-28(fp)
8114acb0:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
8114acb4:	e0bffd17 	ldw	r2,-12(fp)
8114acb8:	10801817 	ldw	r2,96(r2)
8114acbc:	1009883a 	mov	r4,r2
8114acc0:	1140e940 	call	81140e94 <OSSemPost>
    
    return 0;
8114acc4:	0005883a 	mov	r2,zero

}
8114acc8:	e037883a 	mov	sp,fp
8114accc:	dfc00117 	ldw	ra,4(sp)
8114acd0:	df000017 	ldw	fp,0(sp)
8114acd4:	dec00204 	addi	sp,sp,8
8114acd8:	f800283a 	ret

8114acdc <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
8114acdc:	defff804 	addi	sp,sp,-32
8114ace0:	de00012e 	bgeu	sp,et,8114ace8 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
8114ace4:	003b68fa 	trap	3
8114ace8:	dfc00715 	stw	ra,28(sp)
8114acec:	df000615 	stw	fp,24(sp)
8114acf0:	df000604 	addi	fp,sp,24
8114acf4:	e13ffc15 	stw	r4,-16(fp)
8114acf8:	e17ffd15 	stw	r5,-12(fp)
8114acfc:	e1bffe15 	stw	r6,-8(fp)
8114ad00:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
8114ad04:	e0800217 	ldw	r2,8(fp)
8114ad08:	d8800115 	stw	r2,4(sp)
8114ad0c:	e0bfff17 	ldw	r2,-4(fp)
8114ad10:	d8800015 	stw	r2,0(sp)
8114ad14:	e1fffe17 	ldw	r7,-8(fp)
8114ad18:	000d883a 	mov	r6,zero
8114ad1c:	e17ffd17 	ldw	r5,-12(fp)
8114ad20:	e13ffc17 	ldw	r4,-16(fp)
8114ad24:	114a3a40 	call	8114a3a4 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114ad28:	e037883a 	mov	sp,fp
8114ad2c:	dfc00117 	ldw	ra,4(sp)
8114ad30:	df000017 	ldw	fp,0(sp)
8114ad34:	dec00204 	addi	sp,sp,8
8114ad38:	f800283a 	ret

8114ad3c <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
8114ad3c:	defff804 	addi	sp,sp,-32
8114ad40:	de00012e 	bgeu	sp,et,8114ad48 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
8114ad44:	003b68fa 	trap	3
8114ad48:	dfc00715 	stw	ra,28(sp)
8114ad4c:	df000615 	stw	fp,24(sp)
8114ad50:	df000604 	addi	fp,sp,24
8114ad54:	e13ffc15 	stw	r4,-16(fp)
8114ad58:	e17ffd15 	stw	r5,-12(fp)
8114ad5c:	e1bffe15 	stw	r6,-8(fp)
8114ad60:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114ad64:	e0800217 	ldw	r2,8(fp)
8114ad68:	d8800115 	stw	r2,4(sp)
8114ad6c:	e0bfff17 	ldw	r2,-4(fp)
8114ad70:	d8800015 	stw	r2,0(sp)
8114ad74:	000f883a 	mov	r7,zero
8114ad78:	e1bffe17 	ldw	r6,-8(fp)
8114ad7c:	e17ffd17 	ldw	r5,-12(fp)
8114ad80:	e13ffc17 	ldw	r4,-16(fp)
8114ad84:	114a3a40 	call	8114a3a4 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8114ad88:	e037883a 	mov	sp,fp
8114ad8c:	dfc00117 	ldw	ra,4(sp)
8114ad90:	df000017 	ldw	fp,0(sp)
8114ad94:	dec00204 	addi	sp,sp,8
8114ad98:	f800283a 	ret

8114ad9c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114ad9c:	defff804 	addi	sp,sp,-32
8114ada0:	de00012e 	bgeu	sp,et,8114ada8 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
8114ada4:	003b68fa 	trap	3
8114ada8:	dfc00715 	stw	ra,28(sp)
8114adac:	df000615 	stw	fp,24(sp)
8114adb0:	df000604 	addi	fp,sp,24
8114adb4:	e13ffc15 	stw	r4,-16(fp)
8114adb8:	e17ffd15 	stw	r5,-12(fp)
8114adbc:	e1bffe15 	stw	r6,-8(fp)
8114adc0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114adc4:	e0800317 	ldw	r2,12(fp)
8114adc8:	d8800115 	stw	r2,4(sp)
8114adcc:	e0800217 	ldw	r2,8(fp)
8114add0:	d8800015 	stw	r2,0(sp)
8114add4:	e1ffff17 	ldw	r7,-4(fp)
8114add8:	e1bffe17 	ldw	r6,-8(fp)
8114addc:	e17ffd17 	ldw	r5,-12(fp)
8114ade0:	e13ffc17 	ldw	r4,-16(fp)
8114ade4:	114a3a40 	call	8114a3a4 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114ade8:	e037883a 	mov	sp,fp
8114adec:	dfc00117 	ldw	ra,4(sp)
8114adf0:	df000017 	ldw	fp,0(sp)
8114adf4:	dec00204 	addi	sp,sp,8
8114adf8:	f800283a 	ret

8114adfc <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
8114adfc:	defff004 	addi	sp,sp,-64
8114ae00:	de00012e 	bgeu	sp,et,8114ae08 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
8114ae04:	003b68fa 	trap	3
8114ae08:	dfc00f15 	stw	ra,60(sp)
8114ae0c:	df000e15 	stw	fp,56(sp)
8114ae10:	df000e04 	addi	fp,sp,56
8114ae14:	e13ff915 	stw	r4,-28(fp)
8114ae18:	e17ffa15 	stw	r5,-24(fp)
8114ae1c:	e1bffb15 	stw	r6,-20(fp)
8114ae20:	e1fffc15 	stw	r7,-16(fp)
8114ae24:	e1000317 	ldw	r4,12(fp)
8114ae28:	e0c00417 	ldw	r3,16(fp)
8114ae2c:	e0800517 	ldw	r2,20(fp)
8114ae30:	e13ffd0d 	sth	r4,-12(fp)
8114ae34:	e0fffe05 	stb	r3,-8(fp)
8114ae38:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114ae3c:	e0bffd0b 	ldhu	r2,-12(fp)
8114ae40:	e0fffe03 	ldbu	r3,-8(fp)
8114ae44:	e13fff0b 	ldhu	r4,-4(fp)
8114ae48:	d9000615 	stw	r4,24(sp)
8114ae4c:	d8000515 	stw	zero,20(sp)
8114ae50:	d8c00415 	stw	r3,16(sp)
8114ae54:	d8000315 	stw	zero,12(sp)
8114ae58:	d8800215 	stw	r2,8(sp)
8114ae5c:	e0800217 	ldw	r2,8(fp)
8114ae60:	d8800115 	stw	r2,4(sp)
8114ae64:	e0bffc17 	ldw	r2,-16(fp)
8114ae68:	d8800015 	stw	r2,0(sp)
8114ae6c:	e1fffb17 	ldw	r7,-20(fp)
8114ae70:	000d883a 	mov	r6,zero
8114ae74:	e17ffa17 	ldw	r5,-24(fp)
8114ae78:	e13ff917 	ldw	r4,-28(fp)
8114ae7c:	114a4380 	call	8114a438 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8114ae80:	e037883a 	mov	sp,fp
8114ae84:	dfc00117 	ldw	ra,4(sp)
8114ae88:	df000017 	ldw	fp,0(sp)
8114ae8c:	dec00204 	addi	sp,sp,8
8114ae90:	f800283a 	ret

8114ae94 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114ae94:	defff004 	addi	sp,sp,-64
8114ae98:	de00012e 	bgeu	sp,et,8114aea0 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8114ae9c:	003b68fa 	trap	3
8114aea0:	dfc00f15 	stw	ra,60(sp)
8114aea4:	df000e15 	stw	fp,56(sp)
8114aea8:	df000e04 	addi	fp,sp,56
8114aeac:	e13ff915 	stw	r4,-28(fp)
8114aeb0:	e17ffa15 	stw	r5,-24(fp)
8114aeb4:	e1bffb15 	stw	r6,-20(fp)
8114aeb8:	e1fffc15 	stw	r7,-16(fp)
8114aebc:	e1000317 	ldw	r4,12(fp)
8114aec0:	e0c00417 	ldw	r3,16(fp)
8114aec4:	e0800517 	ldw	r2,20(fp)
8114aec8:	e13ffd0d 	sth	r4,-12(fp)
8114aecc:	e0fffe05 	stb	r3,-8(fp)
8114aed0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8114aed4:	e0bffd0b 	ldhu	r2,-12(fp)
8114aed8:	e0fffe03 	ldbu	r3,-8(fp)
8114aedc:	e13fff0b 	ldhu	r4,-4(fp)
8114aee0:	d8000615 	stw	zero,24(sp)
8114aee4:	d9000515 	stw	r4,20(sp)
8114aee8:	d8000415 	stw	zero,16(sp)
8114aeec:	d8c00315 	stw	r3,12(sp)
8114aef0:	d8800215 	stw	r2,8(sp)
8114aef4:	e0800217 	ldw	r2,8(fp)
8114aef8:	d8800115 	stw	r2,4(sp)
8114aefc:	e0bffc17 	ldw	r2,-16(fp)
8114af00:	d8800015 	stw	r2,0(sp)
8114af04:	000f883a 	mov	r7,zero
8114af08:	e1bffb17 	ldw	r6,-20(fp)
8114af0c:	e17ffa17 	ldw	r5,-24(fp)
8114af10:	e13ff917 	ldw	r4,-28(fp)
8114af14:	114a4380 	call	8114a438 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
8114af18:	e037883a 	mov	sp,fp
8114af1c:	dfc00117 	ldw	ra,4(sp)
8114af20:	df000017 	ldw	fp,0(sp)
8114af24:	dec00204 	addi	sp,sp,8
8114af28:	f800283a 	ret

8114af2c <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8114af2c:	deffee04 	addi	sp,sp,-72
8114af30:	de00012e 	bgeu	sp,et,8114af38 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
8114af34:	003b68fa 	trap	3
8114af38:	dfc01115 	stw	ra,68(sp)
8114af3c:	df001015 	stw	fp,64(sp)
8114af40:	df001004 	addi	fp,sp,64
8114af44:	e13ff715 	stw	r4,-36(fp)
8114af48:	e17ff815 	stw	r5,-32(fp)
8114af4c:	e1bff915 	stw	r6,-28(fp)
8114af50:	e1fffa15 	stw	r7,-24(fp)
8114af54:	e1800417 	ldw	r6,16(fp)
8114af58:	e1400517 	ldw	r5,20(fp)
8114af5c:	e1000617 	ldw	r4,24(fp)
8114af60:	e0c00717 	ldw	r3,28(fp)
8114af64:	e0800817 	ldw	r2,32(fp)
8114af68:	e1bffb0d 	sth	r6,-20(fp)
8114af6c:	e17ffc05 	stb	r5,-16(fp)
8114af70:	e13ffd05 	stb	r4,-12(fp)
8114af74:	e0fffe0d 	sth	r3,-8(fp)
8114af78:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114af7c:	e0bffb0b 	ldhu	r2,-20(fp)
8114af80:	e0fffc03 	ldbu	r3,-16(fp)
8114af84:	e13ffd03 	ldbu	r4,-12(fp)
8114af88:	e17ffe0b 	ldhu	r5,-8(fp)
8114af8c:	e1bfff0b 	ldhu	r6,-4(fp)
8114af90:	d9800615 	stw	r6,24(sp)
8114af94:	d9400515 	stw	r5,20(sp)
8114af98:	d9000415 	stw	r4,16(sp)
8114af9c:	d8c00315 	stw	r3,12(sp)
8114afa0:	d8800215 	stw	r2,8(sp)
8114afa4:	e0800317 	ldw	r2,12(fp)
8114afa8:	d8800115 	stw	r2,4(sp)
8114afac:	e0800217 	ldw	r2,8(fp)
8114afb0:	d8800015 	stw	r2,0(sp)
8114afb4:	e1fffa17 	ldw	r7,-24(fp)
8114afb8:	e1bff917 	ldw	r6,-28(fp)
8114afbc:	e17ff817 	ldw	r5,-32(fp)
8114afc0:	e13ff717 	ldw	r4,-36(fp)
8114afc4:	114a4380 	call	8114a438 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8114afc8:	e037883a 	mov	sp,fp
8114afcc:	dfc00117 	ldw	ra,4(sp)
8114afd0:	df000017 	ldw	fp,0(sp)
8114afd4:	dec00204 	addi	sp,sp,8
8114afd8:	f800283a 	ret

8114afdc <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114afdc:	defffb04 	addi	sp,sp,-20
8114afe0:	de00012e 	bgeu	sp,et,8114afe8 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
8114afe4:	003b68fa 	trap	3
8114afe8:	df000415 	stw	fp,16(sp)
8114afec:	df000404 	addi	fp,sp,16
8114aff0:	e13ffc15 	stw	r4,-16(fp)
8114aff4:	e17ffd15 	stw	r5,-12(fp)
8114aff8:	e1bffe15 	stw	r6,-8(fp)
8114affc:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114b000:	e0bffc17 	ldw	r2,-16(fp)
8114b004:	10c01217 	ldw	r3,72(r2)
8114b008:	e0800117 	ldw	r2,4(fp)
8114b00c:	18800436 	bltu	r3,r2,8114b020 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114b010:	e0bffc17 	ldw	r2,-16(fp)
8114b014:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114b018:	10803fcc 	andi	r2,r2,255
8114b01c:	10000226 	beq	r2,zero,8114b028 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114b020:	00bffa84 	movi	r2,-22
8114b024:	00001406 	br	8114b078 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
8114b028:	e0bffd17 	ldw	r2,-12(fp)
8114b02c:	e0fffe17 	ldw	r3,-8(fp)
8114b030:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114b034:	e0bffd17 	ldw	r2,-12(fp)
8114b038:	e0ffff17 	ldw	r3,-4(fp)
8114b03c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114b040:	e0bffd17 	ldw	r2,-12(fp)
8114b044:	e0c00117 	ldw	r3,4(fp)
8114b048:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8114b04c:	e0fffd17 	ldw	r3,-12(fp)
8114b050:	e0bffd17 	ldw	r2,-12(fp)
8114b054:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114b058:	e0c00217 	ldw	r3,8(fp)
8114b05c:	00900034 	movhi	r2,16384
8114b060:	10bfffc4 	addi	r2,r2,-1
8114b064:	1884703a 	and	r2,r3,r2
8114b068:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8114b06c:	e0bffd17 	ldw	r2,-12(fp)
8114b070:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8114b074:	0005883a 	mov	r2,zero
}
8114b078:	e037883a 	mov	sp,fp
8114b07c:	df000017 	ldw	fp,0(sp)
8114b080:	dec00104 	addi	sp,sp,4
8114b084:	f800283a 	ret

8114b088 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114b088:	defff404 	addi	sp,sp,-48
8114b08c:	de00012e 	bgeu	sp,et,8114b094 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114b090:	003b68fa 	trap	3
8114b094:	df000b15 	stw	fp,44(sp)
8114b098:	df000b04 	addi	fp,sp,44
8114b09c:	e13ff715 	stw	r4,-36(fp)
8114b0a0:	e17ff815 	stw	r5,-32(fp)
8114b0a4:	e1bff915 	stw	r6,-28(fp)
8114b0a8:	e1fffa15 	stw	r7,-24(fp)
8114b0ac:	e1800517 	ldw	r6,20(fp)
8114b0b0:	e1400617 	ldw	r5,24(fp)
8114b0b4:	e1000717 	ldw	r4,28(fp)
8114b0b8:	e0c00817 	ldw	r3,32(fp)
8114b0bc:	e0800917 	ldw	r2,36(fp)
8114b0c0:	e1bffb0d 	sth	r6,-20(fp)
8114b0c4:	e17ffc05 	stb	r5,-16(fp)
8114b0c8:	e13ffd05 	stb	r4,-12(fp)
8114b0cc:	e0fffe0d 	sth	r3,-8(fp)
8114b0d0:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114b0d4:	e0bff717 	ldw	r2,-36(fp)
8114b0d8:	10c01217 	ldw	r3,72(r2)
8114b0dc:	e0800317 	ldw	r2,12(fp)
8114b0e0:	18801936 	bltu	r3,r2,8114b148 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114b0e4:	e13ff717 	ldw	r4,-36(fp)
8114b0e8:	20801317 	ldw	r2,76(r4)
8114b0ec:	20c01417 	ldw	r3,80(r4)
8114b0f0:	e13ffe0b 	ldhu	r4,-8(fp)
8114b0f4:	213fffcc 	andi	r4,r4,65535
8114b0f8:	2015883a 	mov	r10,r4
8114b0fc:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114b100:	1ac01136 	bltu	r3,r11,8114b148 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114b104:	58c0011e 	bne	r11,r3,8114b10c <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
8114b108:	12800f36 	bltu	r2,r10,8114b148 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114b10c:	e13ff717 	ldw	r4,-36(fp)
8114b110:	20801317 	ldw	r2,76(r4)
8114b114:	20c01417 	ldw	r3,80(r4)
8114b118:	e13fff0b 	ldhu	r4,-4(fp)
8114b11c:	213fffcc 	andi	r4,r4,65535
8114b120:	2011883a 	mov	r8,r4
8114b124:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8114b128:	1a400736 	bltu	r3,r9,8114b148 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114b12c:	48c0011e 	bne	r9,r3,8114b134 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114b130:	12000536 	bltu	r2,r8,8114b148 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114b134:	e0bff717 	ldw	r2,-36(fp)
8114b138:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114b13c:	10803fcc 	andi	r2,r2,255
8114b140:	10800060 	cmpeqi	r2,r2,1
8114b144:	1000021e 	bne	r2,zero,8114b150 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8114b148:	00bffa84 	movi	r2,-22
8114b14c:	00003106 	br	8114b214 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114b150:	e0bff817 	ldw	r2,-32(fp)
8114b154:	e0fff917 	ldw	r3,-28(fp)
8114b158:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8114b15c:	e0bff817 	ldw	r2,-32(fp)
8114b160:	e0fffa17 	ldw	r3,-24(fp)
8114b164:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8114b168:	e0bff817 	ldw	r2,-32(fp)
8114b16c:	e0c00117 	ldw	r3,4(fp)
8114b170:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114b174:	e0bff817 	ldw	r2,-32(fp)
8114b178:	e0c00217 	ldw	r3,8(fp)
8114b17c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114b180:	e0bff817 	ldw	r2,-32(fp)
8114b184:	e0c00317 	ldw	r3,12(fp)
8114b188:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114b18c:	e0bff817 	ldw	r2,-32(fp)
8114b190:	e0fffb0b 	ldhu	r3,-20(fp)
8114b194:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8114b198:	e0bff817 	ldw	r2,-32(fp)
8114b19c:	e0fffc03 	ldbu	r3,-16(fp)
8114b1a0:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114b1a4:	e0bff817 	ldw	r2,-32(fp)
8114b1a8:	e0fffd03 	ldbu	r3,-12(fp)
8114b1ac:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8114b1b0:	e0bff817 	ldw	r2,-32(fp)
8114b1b4:	e0fffe0b 	ldhu	r3,-8(fp)
8114b1b8:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8114b1bc:	e0bff817 	ldw	r2,-32(fp)
8114b1c0:	e0ffff0b 	ldhu	r3,-4(fp)
8114b1c4:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8114b1c8:	e0bff817 	ldw	r2,-32(fp)
8114b1cc:	1019883a 	mov	r12,r2
8114b1d0:	001b883a 	mov	r13,zero
8114b1d4:	e33ff515 	stw	r12,-44(fp)
8114b1d8:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8114b1dc:	e0fff517 	ldw	r3,-44(fp)
8114b1e0:	e0bff817 	ldw	r2,-32(fp)
8114b1e4:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8114b1e8:	e0fff617 	ldw	r3,-40(fp)
8114b1ec:	e0bff817 	ldw	r2,-32(fp)
8114b1f0:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114b1f4:	e0c00417 	ldw	r3,16(fp)
8114b1f8:	00900034 	movhi	r2,16384
8114b1fc:	10bfffc4 	addi	r2,r2,-1
8114b200:	1884703a 	and	r2,r3,r2
8114b204:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8114b208:	e0bff817 	ldw	r2,-32(fp)
8114b20c:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8114b210:	0005883a 	mov	r2,zero
}
8114b214:	e037883a 	mov	sp,fp
8114b218:	df000017 	ldw	fp,0(sp)
8114b21c:	dec00104 	addi	sp,sp,4
8114b220:	f800283a 	ret

8114b224 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8114b224:	defff804 	addi	sp,sp,-32
8114b228:	de00012e 	bgeu	sp,et,8114b230 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8114b22c:	003b68fa 	trap	3
8114b230:	dfc00715 	stw	ra,28(sp)
8114b234:	df000615 	stw	fp,24(sp)
8114b238:	df000604 	addi	fp,sp,24
8114b23c:	e13ffc15 	stw	r4,-16(fp)
8114b240:	e17ffd15 	stw	r5,-12(fp)
8114b244:	e1bffe15 	stw	r6,-8(fp)
8114b248:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114b24c:	e0800317 	ldw	r2,12(fp)
8114b250:	d8800115 	stw	r2,4(sp)
8114b254:	e0800217 	ldw	r2,8(fp)
8114b258:	d8800015 	stw	r2,0(sp)
8114b25c:	e1ffff17 	ldw	r7,-4(fp)
8114b260:	e1bffe17 	ldw	r6,-8(fp)
8114b264:	e17ffd17 	ldw	r5,-12(fp)
8114b268:	e13ffc17 	ldw	r4,-16(fp)
8114b26c:	114afdc0 	call	8114afdc <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114b270:	e037883a 	mov	sp,fp
8114b274:	dfc00117 	ldw	ra,4(sp)
8114b278:	df000017 	ldw	fp,0(sp)
8114b27c:	dec00204 	addi	sp,sp,8
8114b280:	f800283a 	ret

8114b284 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114b284:	defff804 	addi	sp,sp,-32
8114b288:	de00012e 	bgeu	sp,et,8114b290 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8114b28c:	003b68fa 	trap	3
8114b290:	dfc00715 	stw	ra,28(sp)
8114b294:	df000615 	stw	fp,24(sp)
8114b298:	df000604 	addi	fp,sp,24
8114b29c:	e13ffc15 	stw	r4,-16(fp)
8114b2a0:	e17ffd15 	stw	r5,-12(fp)
8114b2a4:	e1bffe15 	stw	r6,-8(fp)
8114b2a8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114b2ac:	e0800217 	ldw	r2,8(fp)
8114b2b0:	d8800115 	stw	r2,4(sp)
8114b2b4:	e0bfff17 	ldw	r2,-4(fp)
8114b2b8:	d8800015 	stw	r2,0(sp)
8114b2bc:	e1fffe17 	ldw	r7,-8(fp)
8114b2c0:	000d883a 	mov	r6,zero
8114b2c4:	e17ffd17 	ldw	r5,-12(fp)
8114b2c8:	e13ffc17 	ldw	r4,-16(fp)
8114b2cc:	114afdc0 	call	8114afdc <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8114b2d0:	e037883a 	mov	sp,fp
8114b2d4:	dfc00117 	ldw	ra,4(sp)
8114b2d8:	df000017 	ldw	fp,0(sp)
8114b2dc:	dec00204 	addi	sp,sp,8
8114b2e0:	f800283a 	ret

8114b2e4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114b2e4:	defff804 	addi	sp,sp,-32
8114b2e8:	de00012e 	bgeu	sp,et,8114b2f0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8114b2ec:	003b68fa 	trap	3
8114b2f0:	dfc00715 	stw	ra,28(sp)
8114b2f4:	df000615 	stw	fp,24(sp)
8114b2f8:	df000604 	addi	fp,sp,24
8114b2fc:	e13ffc15 	stw	r4,-16(fp)
8114b300:	e17ffd15 	stw	r5,-12(fp)
8114b304:	e1bffe15 	stw	r6,-8(fp)
8114b308:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114b30c:	e0800217 	ldw	r2,8(fp)
8114b310:	d8800115 	stw	r2,4(sp)
8114b314:	e0bfff17 	ldw	r2,-4(fp)
8114b318:	d8800015 	stw	r2,0(sp)
8114b31c:	000f883a 	mov	r7,zero
8114b320:	e1bffe17 	ldw	r6,-8(fp)
8114b324:	e17ffd17 	ldw	r5,-12(fp)
8114b328:	e13ffc17 	ldw	r4,-16(fp)
8114b32c:	114afdc0 	call	8114afdc <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8114b330:	e037883a 	mov	sp,fp
8114b334:	dfc00117 	ldw	ra,4(sp)
8114b338:	df000017 	ldw	fp,0(sp)
8114b33c:	dec00204 	addi	sp,sp,8
8114b340:	f800283a 	ret

8114b344 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8114b344:	deffee04 	addi	sp,sp,-72
8114b348:	de00012e 	bgeu	sp,et,8114b350 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8114b34c:	003b68fa 	trap	3
8114b350:	dfc01115 	stw	ra,68(sp)
8114b354:	df001015 	stw	fp,64(sp)
8114b358:	df001004 	addi	fp,sp,64
8114b35c:	e13ff915 	stw	r4,-28(fp)
8114b360:	e17ffa15 	stw	r5,-24(fp)
8114b364:	e1bffb15 	stw	r6,-20(fp)
8114b368:	e1fffc15 	stw	r7,-16(fp)
8114b36c:	e1000417 	ldw	r4,16(fp)
8114b370:	e0c00517 	ldw	r3,20(fp)
8114b374:	e0800617 	ldw	r2,24(fp)
8114b378:	e13ffd0d 	sth	r4,-12(fp)
8114b37c:	e0fffe05 	stb	r3,-8(fp)
8114b380:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114b384:	e0bffd0b 	ldhu	r2,-12(fp)
8114b388:	e0fffe03 	ldbu	r3,-8(fp)
8114b38c:	e13fff0b 	ldhu	r4,-4(fp)
8114b390:	d9000815 	stw	r4,32(sp)
8114b394:	d8000715 	stw	zero,28(sp)
8114b398:	d8c00615 	stw	r3,24(sp)
8114b39c:	d8000515 	stw	zero,20(sp)
8114b3a0:	d8800415 	stw	r2,16(sp)
8114b3a4:	e0800317 	ldw	r2,12(fp)
8114b3a8:	d8800315 	stw	r2,12(sp)
8114b3ac:	e0800217 	ldw	r2,8(fp)
8114b3b0:	d8800215 	stw	r2,8(sp)
8114b3b4:	e0bffc17 	ldw	r2,-16(fp)
8114b3b8:	d8800115 	stw	r2,4(sp)
8114b3bc:	e0bffb17 	ldw	r2,-20(fp)
8114b3c0:	d8800015 	stw	r2,0(sp)
8114b3c4:	000f883a 	mov	r7,zero
8114b3c8:	000d883a 	mov	r6,zero
8114b3cc:	e17ffa17 	ldw	r5,-24(fp)
8114b3d0:	e13ff917 	ldw	r4,-28(fp)
8114b3d4:	114b0880 	call	8114b088 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8114b3d8:	e037883a 	mov	sp,fp
8114b3dc:	dfc00117 	ldw	ra,4(sp)
8114b3e0:	df000017 	ldw	fp,0(sp)
8114b3e4:	dec00204 	addi	sp,sp,8
8114b3e8:	f800283a 	ret

8114b3ec <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114b3ec:	deffee04 	addi	sp,sp,-72
8114b3f0:	de00012e 	bgeu	sp,et,8114b3f8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8114b3f4:	003b68fa 	trap	3
8114b3f8:	dfc01115 	stw	ra,68(sp)
8114b3fc:	df001015 	stw	fp,64(sp)
8114b400:	df001004 	addi	fp,sp,64
8114b404:	e13ff915 	stw	r4,-28(fp)
8114b408:	e17ffa15 	stw	r5,-24(fp)
8114b40c:	e1bffb15 	stw	r6,-20(fp)
8114b410:	e1fffc15 	stw	r7,-16(fp)
8114b414:	e1000417 	ldw	r4,16(fp)
8114b418:	e0c00517 	ldw	r3,20(fp)
8114b41c:	e0800617 	ldw	r2,24(fp)
8114b420:	e13ffd0d 	sth	r4,-12(fp)
8114b424:	e0fffe05 	stb	r3,-8(fp)
8114b428:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114b42c:	e0bffd0b 	ldhu	r2,-12(fp)
8114b430:	e0fffe03 	ldbu	r3,-8(fp)
8114b434:	e13fff0b 	ldhu	r4,-4(fp)
8114b438:	d8000815 	stw	zero,32(sp)
8114b43c:	d9000715 	stw	r4,28(sp)
8114b440:	d8000615 	stw	zero,24(sp)
8114b444:	d8c00515 	stw	r3,20(sp)
8114b448:	d8800415 	stw	r2,16(sp)
8114b44c:	e0800317 	ldw	r2,12(fp)
8114b450:	d8800315 	stw	r2,12(sp)
8114b454:	e0800217 	ldw	r2,8(fp)
8114b458:	d8800215 	stw	r2,8(sp)
8114b45c:	d8000115 	stw	zero,4(sp)
8114b460:	d8000015 	stw	zero,0(sp)
8114b464:	e1fffc17 	ldw	r7,-16(fp)
8114b468:	e1bffb17 	ldw	r6,-20(fp)
8114b46c:	e17ffa17 	ldw	r5,-24(fp)
8114b470:	e13ff917 	ldw	r4,-28(fp)
8114b474:	114b0880 	call	8114b088 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8114b478:	e037883a 	mov	sp,fp
8114b47c:	dfc00117 	ldw	ra,4(sp)
8114b480:	df000017 	ldw	fp,0(sp)
8114b484:	dec00204 	addi	sp,sp,8
8114b488:	f800283a 	ret

8114b48c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114b48c:	deffec04 	addi	sp,sp,-80
8114b490:	de00012e 	bgeu	sp,et,8114b498 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114b494:	003b68fa 	trap	3
8114b498:	dfc01315 	stw	ra,76(sp)
8114b49c:	df001215 	stw	fp,72(sp)
8114b4a0:	df001204 	addi	fp,sp,72
8114b4a4:	e13ff715 	stw	r4,-36(fp)
8114b4a8:	e17ff815 	stw	r5,-32(fp)
8114b4ac:	e1bff915 	stw	r6,-28(fp)
8114b4b0:	e1fffa15 	stw	r7,-24(fp)
8114b4b4:	e1800617 	ldw	r6,24(fp)
8114b4b8:	e1400717 	ldw	r5,28(fp)
8114b4bc:	e1000817 	ldw	r4,32(fp)
8114b4c0:	e0c00917 	ldw	r3,36(fp)
8114b4c4:	e0800a17 	ldw	r2,40(fp)
8114b4c8:	e1bffb0d 	sth	r6,-20(fp)
8114b4cc:	e17ffc05 	stb	r5,-16(fp)
8114b4d0:	e13ffd05 	stb	r4,-12(fp)
8114b4d4:	e0fffe0d 	sth	r3,-8(fp)
8114b4d8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114b4dc:	e0bffb0b 	ldhu	r2,-20(fp)
8114b4e0:	e0fffc03 	ldbu	r3,-16(fp)
8114b4e4:	e13ffd03 	ldbu	r4,-12(fp)
8114b4e8:	e17ffe0b 	ldhu	r5,-8(fp)
8114b4ec:	e1bfff0b 	ldhu	r6,-4(fp)
8114b4f0:	d9800815 	stw	r6,32(sp)
8114b4f4:	d9400715 	stw	r5,28(sp)
8114b4f8:	d9000615 	stw	r4,24(sp)
8114b4fc:	d8c00515 	stw	r3,20(sp)
8114b500:	d8800415 	stw	r2,16(sp)
8114b504:	e0800517 	ldw	r2,20(fp)
8114b508:	d8800315 	stw	r2,12(sp)
8114b50c:	e0800417 	ldw	r2,16(fp)
8114b510:	d8800215 	stw	r2,8(sp)
8114b514:	e0800317 	ldw	r2,12(fp)
8114b518:	d8800115 	stw	r2,4(sp)
8114b51c:	e0800217 	ldw	r2,8(fp)
8114b520:	d8800015 	stw	r2,0(sp)
8114b524:	e1fffa17 	ldw	r7,-24(fp)
8114b528:	e1bff917 	ldw	r6,-28(fp)
8114b52c:	e17ff817 	ldw	r5,-32(fp)
8114b530:	e13ff717 	ldw	r4,-36(fp)
8114b534:	114b0880 	call	8114b088 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8114b538:	e037883a 	mov	sp,fp
8114b53c:	dfc00117 	ldw	ra,4(sp)
8114b540:	df000017 	ldw	fp,0(sp)
8114b544:	dec00204 	addi	sp,sp,8
8114b548:	f800283a 	ret

8114b54c <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8114b54c:	defffc04 	addi	sp,sp,-16
8114b550:	de00012e 	bgeu	sp,et,8114b558 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114b554:	003b68fa 	trap	3
8114b558:	df000315 	stw	fp,12(sp)
8114b55c:	df000304 	addi	fp,sp,12
8114b560:	e13ffe15 	stw	r4,-8(fp)
8114b564:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8114b568:	e0bfff17 	ldw	r2,-4(fp)
8114b56c:	1000021e 	bne	r2,zero,8114b578 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114b570:	00bffa84 	movi	r2,-22
8114b574:	00002f06 	br	8114b634 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8114b578:	e0bfff17 	ldw	r2,-4(fp)
8114b57c:	10c00317 	ldw	r3,12(r2)
8114b580:	e0bfff17 	ldw	r2,-4(fp)
8114b584:	18800226 	beq	r3,r2,8114b590 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114b588:	00bffa84 	movi	r2,-22
8114b58c:	00002906 	br	8114b634 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114b590:	e0bffe17 	ldw	r2,-8(fp)
8114b594:	10800017 	ldw	r2,0(r2)
8114b598:	1000051e 	bne	r2,zero,8114b5b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8114b59c:	e0bffe17 	ldw	r2,-8(fp)
8114b5a0:	e0ffff17 	ldw	r3,-4(fp)
8114b5a4:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8114b5a8:	0005883a 	mov	r2,zero
8114b5ac:	00002106 	br	8114b634 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8114b5b0:	e0bffe17 	ldw	r2,-8(fp)
8114b5b4:	10c00017 	ldw	r3,0(r2)
8114b5b8:	e0bfff17 	ldw	r2,-4(fp)
8114b5bc:	1880021e 	bne	r3,r2,8114b5c8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114b5c0:	00bffa84 	movi	r2,-22
8114b5c4:	00001b06 	br	8114b634 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114b5c8:	e0bffe17 	ldw	r2,-8(fp)
8114b5cc:	10800017 	ldw	r2,0(r2)
8114b5d0:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114b5d4:	00000906 	br	8114b5fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8114b5d8:	e0bffd17 	ldw	r2,-12(fp)
8114b5dc:	10c00317 	ldw	r3,12(r2)
8114b5e0:	e0bfff17 	ldw	r2,-4(fp)
8114b5e4:	1880021e 	bne	r3,r2,8114b5f0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114b5e8:	00bffa84 	movi	r2,-22
8114b5ec:	00001106 	br	8114b634 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114b5f0:	e0bffd17 	ldw	r2,-12(fp)
8114b5f4:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8114b5f8:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114b5fc:	e0bffd17 	ldw	r2,-12(fp)
8114b600:	10800317 	ldw	r2,12(r2)
8114b604:	e0fffe17 	ldw	r3,-8(fp)
8114b608:	18c00017 	ldw	r3,0(r3)
8114b60c:	10fff21e 	bne	r2,r3,8114b5d8 <__reset+0xfb12b5d8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114b610:	e0ffff17 	ldw	r3,-4(fp)
8114b614:	e0bffd17 	ldw	r2,-12(fp)
8114b618:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8114b61c:	e0bffe17 	ldw	r2,-8(fp)
8114b620:	10800017 	ldw	r2,0(r2)
8114b624:	1007883a 	mov	r3,r2
8114b628:	e0bfff17 	ldw	r2,-4(fp)
8114b62c:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114b630:	0005883a 	mov	r2,zero
}
8114b634:	e037883a 	mov	sp,fp
8114b638:	df000017 	ldw	fp,0(sp)
8114b63c:	dec00104 	addi	sp,sp,4
8114b640:	f800283a 	ret

8114b644 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8114b644:	defff804 	addi	sp,sp,-32
8114b648:	de00012e 	bgeu	sp,et,8114b650 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8114b64c:	003b68fa 	trap	3
8114b650:	df000715 	stw	fp,28(sp)
8114b654:	df000704 	addi	fp,sp,28
8114b658:	e13ffe15 	stw	r4,-8(fp)
8114b65c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8114b660:	e13fff17 	ldw	r4,-4(fp)
8114b664:	2000021e 	bne	r4,zero,8114b670 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114b668:	00bffa84 	movi	r2,-22
8114b66c:	00005906 	br	8114b7d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8114b670:	e13fff17 	ldw	r4,-4(fp)
8114b674:	2015883a 	mov	r10,r4
8114b678:	0017883a 	mov	r11,zero
8114b67c:	e2bffc15 	stw	r10,-16(fp)
8114b680:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114b684:	e13fff17 	ldw	r4,-4(fp)
8114b688:	21400317 	ldw	r5,12(r4)
8114b68c:	e13ffc17 	ldw	r4,-16(fp)
8114b690:	29000626 	beq	r5,r4,8114b6ac <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114b694:	e13fff17 	ldw	r4,-4(fp)
8114b698:	21400b17 	ldw	r5,44(r4)
8114b69c:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114b6a0:	29000226 	beq	r5,r4,8114b6ac <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114b6a4:	00bffa84 	movi	r2,-22
8114b6a8:	00004a06 	br	8114b7d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8114b6ac:	e13ffe17 	ldw	r4,-8(fp)
8114b6b0:	21000017 	ldw	r4,0(r4)
8114b6b4:	2000051e 	bne	r4,zero,8114b6cc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8114b6b8:	e0bffe17 	ldw	r2,-8(fp)
8114b6bc:	e0ffff17 	ldw	r3,-4(fp)
8114b6c0:	10c00015 	stw	r3,0(r2)
		return 0;
8114b6c4:	0005883a 	mov	r2,zero
8114b6c8:	00004206 	br	8114b7d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8114b6cc:	e13ffe17 	ldw	r4,-8(fp)
8114b6d0:	21400017 	ldw	r5,0(r4)
8114b6d4:	e13fff17 	ldw	r4,-4(fp)
8114b6d8:	2900021e 	bne	r5,r4,8114b6e4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114b6dc:	00bffa84 	movi	r2,-22
8114b6e0:	00003c06 	br	8114b7d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114b6e4:	e13ffe17 	ldw	r4,-8(fp)
8114b6e8:	21000017 	ldw	r4,0(r4)
8114b6ec:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8114b6f0:	e13ffe17 	ldw	r4,-8(fp)
8114b6f4:	21000017 	ldw	r4,0(r4)
8114b6f8:	2011883a 	mov	r8,r4
8114b6fc:	0013883a 	mov	r9,zero
8114b700:	e23ffa15 	stw	r8,-24(fp)
8114b704:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b708:	00001806 	br	8114b76c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8114b70c:	e13fff17 	ldw	r4,-4(fp)
8114b710:	200d883a 	mov	r6,r4
8114b714:	000f883a 	mov	r7,zero
8114b718:	e1bffc15 	stw	r6,-16(fp)
8114b71c:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114b720:	e13ff917 	ldw	r4,-28(fp)
8114b724:	21400317 	ldw	r5,12(r4)
8114b728:	e13ffc17 	ldw	r4,-16(fp)
8114b72c:	2900061e 	bne	r5,r4,8114b748 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114b730:	e13ff917 	ldw	r4,-28(fp)
8114b734:	21400b17 	ldw	r5,44(r4)
8114b738:	e13ffd17 	ldw	r4,-12(fp)
8114b73c:	2900021e 	bne	r5,r4,8114b748 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114b740:	00bffa84 	movi	r2,-22
8114b744:	00002306 	br	8114b7d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114b748:	e13ff917 	ldw	r4,-28(fp)
8114b74c:	21000317 	ldw	r4,12(r4)
8114b750:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114b754:	e13ff917 	ldw	r4,-28(fp)
8114b758:	21000b17 	ldw	r4,44(r4)
8114b75c:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114b760:	e13ffc17 	ldw	r4,-16(fp)
8114b764:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114b768:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b76c:	e13ff917 	ldw	r4,-28(fp)
8114b770:	21400317 	ldw	r5,12(r4)
8114b774:	e13ffa17 	ldw	r4,-24(fp)
8114b778:	29000426 	beq	r5,r4,8114b78c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114b77c:	e13ff917 	ldw	r4,-28(fp)
8114b780:	21400b17 	ldw	r5,44(r4)
8114b784:	e13ffb17 	ldw	r4,-20(fp)
8114b788:	293fe01e 	bne	r5,r4,8114b70c <__reset+0xfb12b70c>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8114b78c:	e13fff17 	ldw	r4,-4(fp)
8114b790:	2005883a 	mov	r2,r4
8114b794:	0007883a 	mov	r3,zero
8114b798:	e0bffc15 	stw	r2,-16(fp)
8114b79c:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8114b7a0:	e0fffc17 	ldw	r3,-16(fp)
8114b7a4:	e0bff917 	ldw	r2,-28(fp)
8114b7a8:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8114b7ac:	e0fffd17 	ldw	r3,-12(fp)
8114b7b0:	e0bff917 	ldw	r2,-28(fp)
8114b7b4:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8114b7b8:	e0fffa17 	ldw	r3,-24(fp)
8114b7bc:	e0bfff17 	ldw	r2,-4(fp)
8114b7c0:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8114b7c4:	e0fffb17 	ldw	r3,-20(fp)
8114b7c8:	e0bfff17 	ldw	r2,-4(fp)
8114b7cc:	10c00b15 	stw	r3,44(r2)
	return 0;
8114b7d0:	0005883a 	mov	r2,zero
}
8114b7d4:	e037883a 	mov	sp,fp
8114b7d8:	df000017 	ldw	fp,0(sp)
8114b7dc:	dec00104 	addi	sp,sp,4
8114b7e0:	f800283a 	ret

8114b7e4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8114b7e4:	defffc04 	addi	sp,sp,-16
8114b7e8:	de00012e 	bgeu	sp,et,8114b7f0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8114b7ec:	003b68fa 	trap	3
8114b7f0:	df000315 	stw	fp,12(sp)
8114b7f4:	df000304 	addi	fp,sp,12
8114b7f8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114b7fc:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114b800:	e0bfff17 	ldw	r2,-4(fp)
8114b804:	1000021e 	bne	r2,zero,8114b810 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114b808:	00bffa84 	movi	r2,-22
8114b80c:	00001906 	br	8114b874 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114b810:	e0bfff17 	ldw	r2,-4(fp)
8114b814:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114b818:	00000a06 	br	8114b844 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8114b81c:	e0bffd17 	ldw	r2,-12(fp)
8114b820:	10800717 	ldw	r2,28(r2)
8114b824:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b828:	e0bffe17 	ldw	r2,-8(fp)
8114b82c:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114b830:	e0bffd17 	ldw	r2,-12(fp)
8114b834:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114b838:	e0bffd17 	ldw	r2,-12(fp)
8114b83c:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8114b840:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114b844:	e0bffd17 	ldw	r2,-12(fp)
8114b848:	10c00317 	ldw	r3,12(r2)
8114b84c:	e0bfff17 	ldw	r2,-4(fp)
8114b850:	18bff21e 	bne	r3,r2,8114b81c <__reset+0xfb12b81c>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8114b854:	e0bffd17 	ldw	r2,-12(fp)
8114b858:	10800717 	ldw	r2,28(r2)
8114b85c:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b860:	e0bffe17 	ldw	r2,-8(fp)
8114b864:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114b868:	e0bffd17 	ldw	r2,-12(fp)
8114b86c:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114b870:	0005883a 	mov	r2,zero
}
8114b874:	e037883a 	mov	sp,fp
8114b878:	df000017 	ldw	fp,0(sp)
8114b87c:	dec00104 	addi	sp,sp,4
8114b880:	f800283a 	ret

8114b884 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8114b884:	defff804 	addi	sp,sp,-32
8114b888:	de00012e 	bgeu	sp,et,8114b890 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8114b88c:	003b68fa 	trap	3
8114b890:	df000715 	stw	fp,28(sp)
8114b894:	df000704 	addi	fp,sp,28
8114b898:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114b89c:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114b8a0:	e13fff17 	ldw	r4,-4(fp)
8114b8a4:	2000021e 	bne	r4,zero,8114b8b0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114b8a8:	00bffa84 	movi	r2,-22
8114b8ac:	00002806 	br	8114b950 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114b8b0:	e13fff17 	ldw	r4,-4(fp)
8114b8b4:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8114b8b8:	e13fff17 	ldw	r4,-4(fp)
8114b8bc:	2005883a 	mov	r2,r4
8114b8c0:	0007883a 	mov	r3,zero
8114b8c4:	e0bffb15 	stw	r2,-20(fp)
8114b8c8:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b8cc:	00001006 	br	8114b910 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114b8d0:	e0bff917 	ldw	r2,-28(fp)
8114b8d4:	10800f17 	ldw	r2,60(r2)
8114b8d8:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b8dc:	e0bffa17 	ldw	r2,-24(fp)
8114b8e0:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114b8e4:	e0bff917 	ldw	r2,-28(fp)
8114b8e8:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114b8ec:	e0bff917 	ldw	r2,-28(fp)
8114b8f0:	10800317 	ldw	r2,12(r2)
8114b8f4:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114b8f8:	e0bff917 	ldw	r2,-28(fp)
8114b8fc:	10800b17 	ldw	r2,44(r2)
8114b900:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114b904:	e0bffd17 	ldw	r2,-12(fp)
8114b908:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114b90c:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b910:	e0bff917 	ldw	r2,-28(fp)
8114b914:	10c00317 	ldw	r3,12(r2)
8114b918:	e0bffb17 	ldw	r2,-20(fp)
8114b91c:	18800426 	beq	r3,r2,8114b930 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114b920:	e0bff917 	ldw	r2,-28(fp)
8114b924:	10c00b17 	ldw	r3,44(r2)
8114b928:	e0bffc17 	ldw	r2,-16(fp)
8114b92c:	18bfe81e 	bne	r3,r2,8114b8d0 <__reset+0xfb12b8d0>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114b930:	e0bff917 	ldw	r2,-28(fp)
8114b934:	10800f17 	ldw	r2,60(r2)
8114b938:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b93c:	e0bffa17 	ldw	r2,-24(fp)
8114b940:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114b944:	e0bff917 	ldw	r2,-28(fp)
8114b948:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8114b94c:	0005883a 	mov	r2,zero
}
8114b950:	e037883a 	mov	sp,fp
8114b954:	df000017 	ldw	fp,0(sp)
8114b958:	dec00104 	addi	sp,sp,4
8114b95c:	f800283a 	ret

8114b960 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114b960:	deffeb04 	addi	sp,sp,-84
8114b964:	de00012e 	bgeu	sp,et,8114b96c <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8114b968:	003b68fa 	trap	3
8114b96c:	dfc01415 	stw	ra,80(sp)
8114b970:	df001315 	stw	fp,76(sp)
8114b974:	df001304 	addi	fp,sp,76
8114b978:	e13ffb15 	stw	r4,-20(fp)
8114b97c:	e17ffc15 	stw	r5,-16(fp)
8114b980:	e1bffd15 	stw	r6,-12(fp)
8114b984:	3807883a 	mov	r3,r7
8114b988:	e0800217 	ldw	r2,8(fp)
8114b98c:	e0fffe05 	stb	r3,-8(fp)
8114b990:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8114b994:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8114b998:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8114b99c:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114b9a0:	e0bffc17 	ldw	r2,-16(fp)
8114b9a4:	e0bff815 	stw	r2,-32(fp)
8114b9a8:	e0bffd17 	ldw	r2,-12(fp)
8114b9ac:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114b9b0:	e0bffb17 	ldw	r2,-20(fp)
8114b9b4:	10801817 	ldw	r2,96(r2)
8114b9b8:	e0bff615 	stw	r2,-40(fp)
8114b9bc:	e03ff70d 	sth	zero,-36(fp)
8114b9c0:	e0bff70b 	ldhu	r2,-36(fp)
8114b9c4:	e0fffa04 	addi	r3,fp,-24
8114b9c8:	180d883a 	mov	r6,r3
8114b9cc:	100b883a 	mov	r5,r2
8114b9d0:	e13ff617 	ldw	r4,-40(fp)
8114b9d4:	1140b0c0 	call	81140b0c <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8114b9d8:	e0bffb17 	ldw	r2,-20(fp)
8114b9dc:	10800617 	ldw	r2,24(r2)
8114b9e0:	10800037 	ldwio	r2,0(r2)
8114b9e4:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8114b9e8:	e0bfed17 	ldw	r2,-76(fp)
8114b9ec:	1080004c 	andi	r2,r2,1
8114b9f0:	10000626 	beq	r2,zero,8114ba0c <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8114b9f4:	e0bffb17 	ldw	r2,-20(fp)
8114b9f8:	10801817 	ldw	r2,96(r2)
8114b9fc:	1009883a 	mov	r4,r2
8114ba00:	1140e940 	call	81140e94 <OSSemPost>
		return -EBUSY;
8114ba04:	00bffc04 	movi	r2,-16
8114ba08:	00009606 	br	8114bc64 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114ba0c:	00800804 	movi	r2,32
8114ba10:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ba14:	0005303a 	rdctl	r2,status
8114ba18:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ba1c:	e0fff217 	ldw	r3,-56(fp)
8114ba20:	00bfff84 	movi	r2,-2
8114ba24:	1884703a 	and	r2,r3,r2
8114ba28:	1001703a 	wrctl	status,r2
  
  return context;
8114ba2c:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114ba30:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114ba34:	e0bffb17 	ldw	r2,-20(fp)
8114ba38:	10800317 	ldw	r2,12(r2)
8114ba3c:	10800104 	addi	r2,r2,4
8114ba40:	e0ffee17 	ldw	r3,-72(fp)
8114ba44:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8114ba48:	e0bffb17 	ldw	r2,-20(fp)
8114ba4c:	10800317 	ldw	r2,12(r2)
8114ba50:	e0fffb17 	ldw	r3,-20(fp)
8114ba54:	18c00317 	ldw	r3,12(r3)
8114ba58:	18c00037 	ldwio	r3,0(r3)
8114ba5c:	10c00035 	stwio	r3,0(r2)
8114ba60:	e0bfef17 	ldw	r2,-68(fp)
8114ba64:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ba68:	e0bff017 	ldw	r2,-64(fp)
8114ba6c:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8114ba70:	e0bffb17 	ldw	r2,-20(fp)
8114ba74:	10800b17 	ldw	r2,44(r2)
8114ba78:	10002326 	beq	r2,zero,8114bb08 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8114ba7c:	e0bffb17 	ldw	r2,-20(fp)
8114ba80:	10c00d17 	ldw	r3,52(r2)
8114ba84:	e0bfee17 	ldw	r2,-72(fp)
8114ba88:	1884b03a 	or	r2,r3,r2
8114ba8c:	10800514 	ori	r2,r2,20
8114ba90:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114ba94:	e0ffee17 	ldw	r3,-72(fp)
8114ba98:	00bff7c4 	movi	r2,-33
8114ba9c:	1884703a 	and	r2,r3,r2
8114baa0:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114baa4:	e0bfed17 	ldw	r2,-76(fp)
8114baa8:	10800214 	ori	r2,r2,8
8114baac:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114bab0:	0005303a 	rdctl	r2,status
8114bab4:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114bab8:	e0fff417 	ldw	r3,-48(fp)
8114babc:	00bfff84 	movi	r2,-2
8114bac0:	1884703a 	and	r2,r3,r2
8114bac4:	1001703a 	wrctl	status,r2
  
  return context;
8114bac8:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8114bacc:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114bad0:	e0bffb17 	ldw	r2,-20(fp)
8114bad4:	10800317 	ldw	r2,12(r2)
8114bad8:	10800104 	addi	r2,r2,4
8114badc:	e0ffee17 	ldw	r3,-72(fp)
8114bae0:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114bae4:	e0bffb17 	ldw	r2,-20(fp)
8114bae8:	10800617 	ldw	r2,24(r2)
8114baec:	e0ffed17 	ldw	r3,-76(fp)
8114baf0:	10c00035 	stwio	r3,0(r2)
8114baf4:	e0bfef17 	ldw	r2,-68(fp)
8114baf8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114bafc:	e0bff117 	ldw	r2,-60(fp)
8114bb00:	1001703a 	wrctl	status,r2
8114bb04:	00002306 	br	8114bb94 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8114bb08:	e0bffb17 	ldw	r2,-20(fp)
8114bb0c:	10c00d17 	ldw	r3,52(r2)
8114bb10:	e0bfee17 	ldw	r2,-72(fp)
8114bb14:	1884b03a 	or	r2,r3,r2
8114bb18:	10800114 	ori	r2,r2,4
8114bb1c:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114bb20:	e0ffee17 	ldw	r3,-72(fp)
8114bb24:	00bff3c4 	movi	r2,-49
8114bb28:	1884703a 	and	r2,r3,r2
8114bb2c:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8114bb30:	e0ffed17 	ldw	r3,-76(fp)
8114bb34:	00bffdc4 	movi	r2,-9
8114bb38:	1884703a 	and	r2,r3,r2
8114bb3c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114bb40:	0005303a 	rdctl	r2,status
8114bb44:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114bb48:	e0fff517 	ldw	r3,-44(fp)
8114bb4c:	00bfff84 	movi	r2,-2
8114bb50:	1884703a 	and	r2,r3,r2
8114bb54:	1001703a 	wrctl	status,r2
  
  return context;
8114bb58:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8114bb5c:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114bb60:	e0bffb17 	ldw	r2,-20(fp)
8114bb64:	10800317 	ldw	r2,12(r2)
8114bb68:	10800104 	addi	r2,r2,4
8114bb6c:	e0ffee17 	ldw	r3,-72(fp)
8114bb70:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114bb74:	e0bffb17 	ldw	r2,-20(fp)
8114bb78:	10800617 	ldw	r2,24(r2)
8114bb7c:	e0ffed17 	ldw	r3,-76(fp)
8114bb80:	10c00035 	stwio	r3,0(r2)
8114bb84:	e0bfef17 	ldw	r2,-68(fp)
8114bb88:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114bb8c:	e0bff317 	ldw	r2,-52(fp)
8114bb90:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8114bb94:	e0bffb17 	ldw	r2,-20(fp)
8114bb98:	10800617 	ldw	r2,24(r2)
8114bb9c:	10800104 	addi	r2,r2,4
8114bba0:	e0fff817 	ldw	r3,-32(fp)
8114bba4:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8114bba8:	e0bffb17 	ldw	r2,-20(fp)
8114bbac:	10800617 	ldw	r2,24(r2)
8114bbb0:	10800204 	addi	r2,r2,8
8114bbb4:	e0fff917 	ldw	r3,-28(fp)
8114bbb8:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8114bbbc:	e0bffe03 	ldbu	r2,-8(fp)
8114bbc0:	10000426 	beq	r2,zero,8114bbd4 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8114bbc4:	e0bfed17 	ldw	r2,-76(fp)
8114bbc8:	10800414 	ori	r2,r2,16
8114bbcc:	e0bfed15 	stw	r2,-76(fp)
8114bbd0:	00000406 	br	8114bbe4 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8114bbd4:	e0ffed17 	ldw	r3,-76(fp)
8114bbd8:	00bffbc4 	movi	r2,-17
8114bbdc:	1884703a 	and	r2,r3,r2
8114bbe0:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8114bbe4:	e0bfff03 	ldbu	r2,-4(fp)
8114bbe8:	10000e26 	beq	r2,zero,8114bc24 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8114bbec:	e0bfed17 	ldw	r2,-76(fp)
8114bbf0:	10800094 	ori	r2,r2,2
8114bbf4:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114bbf8:	e0bffb17 	ldw	r2,-20(fp)
8114bbfc:	10800617 	ldw	r2,24(r2)
8114bc00:	10800304 	addi	r2,r2,12
8114bc04:	10800037 	ldwio	r2,0(r2)
8114bc08:	10000a1e 	bne	r2,zero,8114bc34 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114bc0c:	e0bffb17 	ldw	r2,-20(fp)
8114bc10:	10800617 	ldw	r2,24(r2)
8114bc14:	10800304 	addi	r2,r2,12
8114bc18:	00c03fc4 	movi	r3,255
8114bc1c:	10c00035 	stwio	r3,0(r2)
8114bc20:	00000406 	br	8114bc34 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8114bc24:	e0ffed17 	ldw	r3,-76(fp)
8114bc28:	00bfff44 	movi	r2,-3
8114bc2c:	1884703a 	and	r2,r3,r2
8114bc30:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8114bc34:	e0bfed17 	ldw	r2,-76(fp)
8114bc38:	10800054 	ori	r2,r2,1
8114bc3c:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114bc40:	e0bffb17 	ldw	r2,-20(fp)
8114bc44:	10800617 	ldw	r2,24(r2)
8114bc48:	e0ffed17 	ldw	r3,-76(fp)
8114bc4c:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8114bc50:	e0bffb17 	ldw	r2,-20(fp)
8114bc54:	10801817 	ldw	r2,96(r2)
8114bc58:	1009883a 	mov	r4,r2
8114bc5c:	1140e940 	call	81140e94 <OSSemPost>
	 
	 return 0;
8114bc60:	0005883a 	mov	r2,zero
}
8114bc64:	e037883a 	mov	sp,fp
8114bc68:	dfc00117 	ldw	ra,4(sp)
8114bc6c:	df000017 	ldw	fp,0(sp)
8114bc70:	dec00204 	addi	sp,sp,8
8114bc74:	f800283a 	ret

8114bc78 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8114bc78:	defff704 	addi	sp,sp,-36
8114bc7c:	de00012e 	bgeu	sp,et,8114bc84 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8114bc80:	003b68fa 	trap	3
8114bc84:	dfc00815 	stw	ra,32(sp)
8114bc88:	df000715 	stw	fp,28(sp)
8114bc8c:	dc400615 	stw	r17,24(sp)
8114bc90:	dc000515 	stw	r16,20(sp)
8114bc94:	df000704 	addi	fp,sp,28
8114bc98:	e13ffa15 	stw	r4,-24(fp)
8114bc9c:	e17ffb15 	stw	r5,-20(fp)
8114bca0:	3007883a 	mov	r3,r6
8114bca4:	3805883a 	mov	r2,r7
8114bca8:	e0fffc05 	stb	r3,-16(fp)
8114bcac:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114bcb0:	e13ffb17 	ldw	r4,-20(fp)
8114bcb4:	114b7e40 	call	8114b7e4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8114bcb8:	10000226 	beq	r2,zero,8114bcc4 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8114bcbc:	00bffa84 	movi	r2,-22
8114bcc0:	00000b06 	br	8114bcf0 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8114bcc4:	e0bffb17 	ldw	r2,-20(fp)
8114bcc8:	1021883a 	mov	r16,r2
8114bccc:	0023883a 	mov	r17,zero
8114bcd0:	e0fffc03 	ldbu	r3,-16(fp)
8114bcd4:	e0bffd03 	ldbu	r2,-12(fp)
8114bcd8:	d8800015 	stw	r2,0(sp)
8114bcdc:	180f883a 	mov	r7,r3
8114bce0:	800b883a 	mov	r5,r16
8114bce4:	880d883a 	mov	r6,r17
8114bce8:	e13ffa17 	ldw	r4,-24(fp)
8114bcec:	114b9600 	call	8114b960 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114bcf0:	e6fffe04 	addi	sp,fp,-8
8114bcf4:	dfc00317 	ldw	ra,12(sp)
8114bcf8:	df000217 	ldw	fp,8(sp)
8114bcfc:	dc400117 	ldw	r17,4(sp)
8114bd00:	dc000017 	ldw	r16,0(sp)
8114bd04:	dec00404 	addi	sp,sp,16
8114bd08:	f800283a 	ret

8114bd0c <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114bd0c:	defff704 	addi	sp,sp,-36
8114bd10:	de00012e 	bgeu	sp,et,8114bd18 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8114bd14:	003b68fa 	trap	3
8114bd18:	dfc00815 	stw	ra,32(sp)
8114bd1c:	df000715 	stw	fp,28(sp)
8114bd20:	dc400615 	stw	r17,24(sp)
8114bd24:	dc000515 	stw	r16,20(sp)
8114bd28:	df000704 	addi	fp,sp,28
8114bd2c:	e13ffa15 	stw	r4,-24(fp)
8114bd30:	e17ffb15 	stw	r5,-20(fp)
8114bd34:	3007883a 	mov	r3,r6
8114bd38:	3805883a 	mov	r2,r7
8114bd3c:	e0fffc05 	stb	r3,-16(fp)
8114bd40:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8114bd44:	e13ffb17 	ldw	r4,-20(fp)
8114bd48:	114b8840 	call	8114b884 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8114bd4c:	10000226 	beq	r2,zero,8114bd58 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8114bd50:	00bffa84 	movi	r2,-22
8114bd54:	00000b06 	br	8114bd84 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8114bd58:	e0bffb17 	ldw	r2,-20(fp)
8114bd5c:	1021883a 	mov	r16,r2
8114bd60:	0023883a 	mov	r17,zero
8114bd64:	e0fffc03 	ldbu	r3,-16(fp)
8114bd68:	e0bffd03 	ldbu	r2,-12(fp)
8114bd6c:	d8800015 	stw	r2,0(sp)
8114bd70:	180f883a 	mov	r7,r3
8114bd74:	800b883a 	mov	r5,r16
8114bd78:	880d883a 	mov	r6,r17
8114bd7c:	e13ffa17 	ldw	r4,-24(fp)
8114bd80:	114b9600 	call	8114b960 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114bd84:	e6fffe04 	addi	sp,fp,-8
8114bd88:	dfc00317 	ldw	ra,12(sp)
8114bd8c:	df000217 	ldw	fp,8(sp)
8114bd90:	dc400117 	ldw	r17,4(sp)
8114bd94:	dc000017 	ldw	r16,0(sp)
8114bd98:	dec00404 	addi	sp,sp,16
8114bd9c:	f800283a 	ret

8114bda0 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114bda0:	defffc04 	addi	sp,sp,-16
8114bda4:	de00012e 	bgeu	sp,et,8114bdac <alt_msgdma_open+0xc>
8114bda8:	003b68fa 	trap	3
8114bdac:	dfc00315 	stw	ra,12(sp)
8114bdb0:	df000215 	stw	fp,8(sp)
8114bdb4:	df000204 	addi	fp,sp,8
8114bdb8:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8114bdbc:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8114bdc0:	d1603504 	addi	r5,gp,-32556
8114bdc4:	e13fff17 	ldw	r4,-4(fp)
8114bdc8:	114c3440 	call	8114c344 <alt_find_dev>
8114bdcc:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8114bdd0:	e0bffe17 	ldw	r2,-8(fp)
8114bdd4:	1000041e 	bne	r2,zero,8114bde8 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8114bdd8:	114a0040 	call	8114a004 <alt_get_errno>
8114bddc:	1007883a 	mov	r3,r2
8114bde0:	008004c4 	movi	r2,19
8114bde4:	18800015 	stw	r2,0(r3)
    }

    return dev;
8114bde8:	e0bffe17 	ldw	r2,-8(fp)
}
8114bdec:	e037883a 	mov	sp,fp
8114bdf0:	dfc00117 	ldw	ra,4(sp)
8114bdf4:	df000017 	ldw	fp,0(sp)
8114bdf8:	dec00204 	addi	sp,sp,8
8114bdfc:	f800283a 	ret

8114be00 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8114be00:	defff604 	addi	sp,sp,-40
8114be04:	de00012e 	bgeu	sp,et,8114be0c <alt_msgdma_init+0xc>
8114be08:	003b68fa 	trap	3
8114be0c:	dfc00915 	stw	ra,36(sp)
8114be10:	df000815 	stw	fp,32(sp)
8114be14:	df000804 	addi	fp,sp,32
8114be18:	e13ffd15 	stw	r4,-12(fp)
8114be1c:	e17ffe15 	stw	r5,-8(fp)
8114be20:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8114be24:	e0bffd17 	ldw	r2,-12(fp)
8114be28:	10801783 	ldbu	r2,94(r2)
8114be2c:	10803fcc 	andi	r2,r2,255
8114be30:	10000b26 	beq	r2,zero,8114be60 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8114be34:	e0bffd17 	ldw	r2,-12(fp)
8114be38:	10800617 	ldw	r2,24(r2)
8114be3c:	00c00104 	movi	r3,4
8114be40:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8114be44:	0001883a 	nop
8114be48:	e0bffd17 	ldw	r2,-12(fp)
8114be4c:	10800617 	ldw	r2,24(r2)
8114be50:	10800037 	ldwio	r2,0(r2)
8114be54:	1080010c 	andi	r2,r2,4
8114be58:	1005d0ba 	srai	r2,r2,2
8114be5c:	103ffa1e 	bne	r2,zero,8114be48 <__reset+0xfb12be48>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8114be60:	e0bffd17 	ldw	r2,-12(fp)
8114be64:	10800317 	ldw	r2,12(r2)
8114be68:	10800104 	addi	r2,r2,4
8114be6c:	00c00084 	movi	r3,2
8114be70:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114be74:	0001883a 	nop
8114be78:	e0bffd17 	ldw	r2,-12(fp)
8114be7c:	10800317 	ldw	r2,12(r2)
8114be80:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8114be84:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114be88:	103ffb1e 	bne	r2,zero,8114be78 <__reset+0xfb12be78>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114be8c:	e0bffd17 	ldw	r2,-12(fp)
8114be90:	10800317 	ldw	r2,12(r2)
8114be94:	10800104 	addi	r2,r2,4
8114be98:	10800037 	ldwio	r2,0(r2)
8114be9c:	1007883a 	mov	r3,r2
8114bea0:	00bffbc4 	movi	r2,-17
8114bea4:	1884703a 	and	r2,r3,r2
8114bea8:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114beac:	e0bff917 	ldw	r2,-28(fp)
8114beb0:	10800814 	ori	r2,r2,32
8114beb4:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114beb8:	e0bffd17 	ldw	r2,-12(fp)
8114bebc:	10800317 	ldw	r2,12(r2)
8114bec0:	10800104 	addi	r2,r2,4
8114bec4:	e0fff917 	ldw	r3,-28(fp)
8114bec8:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8114becc:	e0bffd17 	ldw	r2,-12(fp)
8114bed0:	10800317 	ldw	r2,12(r2)
8114bed4:	e0fffd17 	ldw	r3,-12(fp)
8114bed8:	18c00317 	ldw	r3,12(r3)
8114bedc:	18c00037 	ldwio	r3,0(r3)
8114bee0:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8114bee4:	e0bffd17 	ldw	r2,-12(fp)
8114bee8:	10801783 	ldbu	r2,94(r2)
8114beec:	10803fcc 	andi	r2,r2,255
8114bef0:	10000826 	beq	r2,zero,8114bf14 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8114bef4:	e0bffd17 	ldw	r2,-12(fp)
8114bef8:	10800617 	ldw	r2,24(r2)
8114befc:	10800404 	addi	r2,r2,16
8114bf00:	e0fffd17 	ldw	r3,-12(fp)
8114bf04:	18c00617 	ldw	r3,24(r3)
8114bf08:	18c00404 	addi	r3,r3,16
8114bf0c:	18c00037 	ldwio	r3,0(r3)
8114bf10:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8114bf14:	d1603504 	addi	r5,gp,-32556
8114bf18:	e13ffd17 	ldw	r4,-12(fp)
8114bf1c:	114c2980 	call	8114c298 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8114bf20:	e0bffd17 	ldw	r2,-12(fp)
8114bf24:	10801804 	addi	r2,r2,96
8114bf28:	e0bffb15 	stw	r2,-20(fp)
8114bf2c:	00800044 	movi	r2,1
8114bf30:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8114bf34:	e0bffc0b 	ldhu	r2,-16(fp)
8114bf38:	1009883a 	mov	r4,r2
8114bf3c:	11407e40 	call	811407e4 <OSSemCreate>
8114bf40:	1007883a 	mov	r3,r2
8114bf44:	e0bffb17 	ldw	r2,-20(fp)
8114bf48:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114bf4c:	e0bffb17 	ldw	r2,-20(fp)
8114bf50:	10800017 	ldw	r2,0(r2)
8114bf54:	10000226 	beq	r2,zero,8114bf60 <alt_msgdma_init+0x160>
8114bf58:	0005883a 	mov	r2,zero
8114bf5c:	00000106 	br	8114bf64 <alt_msgdma_init+0x164>
8114bf60:	00bfffc4 	movi	r2,-1
8114bf64:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8114bf68:	e0bffa17 	ldw	r2,-24(fp)
8114bf6c:	1000081e 	bne	r2,zero,8114bf90 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8114bf70:	d8000015 	stw	zero,0(sp)
8114bf74:	e1fffd17 	ldw	r7,-12(fp)
8114bf78:	01a04574 	movhi	r6,33045
8114bf7c:	31a88604 	addi	r6,r6,-24040
8114bf80:	e17fff17 	ldw	r5,-4(fp)
8114bf84:	e13ffe17 	ldw	r4,-8(fp)
8114bf88:	114c5d00 	call	8114c5d0 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8114bf8c:	00000406 	br	8114bfa0 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8114bf90:	01204574 	movhi	r4,33045
8114bf94:	210cd504 	addi	r4,r4,13140
8114bf98:	114c9e80 	call	8114c9e8 <alt_printf>
    }
    
    return;
8114bf9c:	0001883a 	nop

}
8114bfa0:	e037883a 	mov	sp,fp
8114bfa4:	dfc00117 	ldw	ra,4(sp)
8114bfa8:	df000017 	ldw	fp,0(sp)
8114bfac:	dec00204 	addi	sp,sp,8
8114bfb0:	f800283a 	ret

8114bfb4 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8114bfb4:	defffb04 	addi	sp,sp,-20
8114bfb8:	de00012e 	bgeu	sp,et,8114bfc0 <alt_msgdma_register_callback+0xc>
8114bfbc:	003b68fa 	trap	3
8114bfc0:	df000415 	stw	fp,16(sp)
8114bfc4:	df000404 	addi	fp,sp,16
8114bfc8:	e13ffc15 	stw	r4,-16(fp)
8114bfcc:	e17ffd15 	stw	r5,-12(fp)
8114bfd0:	e1bffe15 	stw	r6,-8(fp)
8114bfd4:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8114bfd8:	e0bffc17 	ldw	r2,-16(fp)
8114bfdc:	e0fffd17 	ldw	r3,-12(fp)
8114bfe0:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8114bfe4:	e0bffc17 	ldw	r2,-16(fp)
8114bfe8:	e0ffff17 	ldw	r3,-4(fp)
8114bfec:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8114bff0:	e0bffc17 	ldw	r2,-16(fp)
8114bff4:	e0fffe17 	ldw	r3,-8(fp)
8114bff8:	10c00d15 	stw	r3,52(r2)

    return ;
8114bffc:	0001883a 	nop
}
8114c000:	e037883a 	mov	sp,fp
8114c004:	df000017 	ldw	fp,0(sp)
8114c008:	dec00104 	addi	sp,sp,4
8114c00c:	f800283a 	ret

8114c010 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114c010:	defffc04 	addi	sp,sp,-16
8114c014:	de00012e 	bgeu	sp,et,8114c01c <alt_msgdma_standard_descriptor_async_transfer+0xc>
8114c018:	003b68fa 	trap	3
8114c01c:	dfc00315 	stw	ra,12(sp)
8114c020:	df000215 	stw	fp,8(sp)
8114c024:	df000204 	addi	fp,sp,8
8114c028:	e13ffe15 	stw	r4,-8(fp)
8114c02c:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114c030:	000d883a 	mov	r6,zero
8114c034:	e17fff17 	ldw	r5,-4(fp)
8114c038:	e13ffe17 	ldw	r4,-8(fp)
8114c03c:	114a5940 	call	8114a594 <alt_msgdma_descriptor_async_transfer>

}
8114c040:	e037883a 	mov	sp,fp
8114c044:	dfc00117 	ldw	ra,4(sp)
8114c048:	df000017 	ldw	fp,0(sp)
8114c04c:	dec00204 	addi	sp,sp,8
8114c050:	f800283a 	ret

8114c054 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114c054:	defffc04 	addi	sp,sp,-16
8114c058:	de00012e 	bgeu	sp,et,8114c060 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8114c05c:	003b68fa 	trap	3
8114c060:	dfc00315 	stw	ra,12(sp)
8114c064:	df000215 	stw	fp,8(sp)
8114c068:	df000204 	addi	fp,sp,8
8114c06c:	e13ffe15 	stw	r4,-8(fp)
8114c070:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114c074:	e1bfff17 	ldw	r6,-4(fp)
8114c078:	000b883a 	mov	r5,zero
8114c07c:	e13ffe17 	ldw	r4,-8(fp)
8114c080:	114a5940 	call	8114a594 <alt_msgdma_descriptor_async_transfer>
}
8114c084:	e037883a 	mov	sp,fp
8114c088:	dfc00117 	ldw	ra,4(sp)
8114c08c:	df000017 	ldw	fp,0(sp)
8114c090:	dec00204 	addi	sp,sp,8
8114c094:	f800283a 	ret

8114c098 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114c098:	defffc04 	addi	sp,sp,-16
8114c09c:	de00012e 	bgeu	sp,et,8114c0a4 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114c0a0:	003b68fa 	trap	3
8114c0a4:	dfc00315 	stw	ra,12(sp)
8114c0a8:	df000215 	stw	fp,8(sp)
8114c0ac:	df000204 	addi	fp,sp,8
8114c0b0:	e13ffe15 	stw	r4,-8(fp)
8114c0b4:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8114c0b8:	000d883a 	mov	r6,zero
8114c0bc:	e17fff17 	ldw	r5,-4(fp)
8114c0c0:	e13ffe17 	ldw	r4,-8(fp)
8114c0c4:	114a8d40 	call	8114a8d4 <alt_msgdma_descriptor_sync_transfer>
}
8114c0c8:	e037883a 	mov	sp,fp
8114c0cc:	dfc00117 	ldw	ra,4(sp)
8114c0d0:	df000017 	ldw	fp,0(sp)
8114c0d4:	dec00204 	addi	sp,sp,8
8114c0d8:	f800283a 	ret

8114c0dc <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114c0dc:	defffc04 	addi	sp,sp,-16
8114c0e0:	de00012e 	bgeu	sp,et,8114c0e8 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8114c0e4:	003b68fa 	trap	3
8114c0e8:	dfc00315 	stw	ra,12(sp)
8114c0ec:	df000215 	stw	fp,8(sp)
8114c0f0:	df000204 	addi	fp,sp,8
8114c0f4:	e13ffe15 	stw	r4,-8(fp)
8114c0f8:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8114c0fc:	e1bfff17 	ldw	r6,-4(fp)
8114c100:	000b883a 	mov	r5,zero
8114c104:	e13ffe17 	ldw	r4,-8(fp)
8114c108:	114a8d40 	call	8114a8d4 <alt_msgdma_descriptor_sync_transfer>
}
8114c10c:	e037883a 	mov	sp,fp
8114c110:	dfc00117 	ldw	ra,4(sp)
8114c114:	df000017 	ldw	fp,0(sp)
8114c118:	dec00204 	addi	sp,sp,8
8114c11c:	f800283a 	ret

8114c120 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114c120:	defff504 	addi	sp,sp,-44
8114c124:	de00012e 	bgeu	sp,et,8114c12c <alt_alarm_start+0xc>
8114c128:	003b68fa 	trap	3
8114c12c:	df000a15 	stw	fp,40(sp)
8114c130:	df000a04 	addi	fp,sp,40
8114c134:	e13ffc15 	stw	r4,-16(fp)
8114c138:	e17ffd15 	stw	r5,-12(fp)
8114c13c:	e1bffe15 	stw	r6,-8(fp)
8114c140:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114c144:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8114c148:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
8114c14c:	10003c26 	beq	r2,zero,8114c240 <alt_alarm_start+0x120>
  {
    if (alarm)
8114c150:	e0bffc17 	ldw	r2,-16(fp)
8114c154:	10003826 	beq	r2,zero,8114c238 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8114c158:	e0bffc17 	ldw	r2,-16(fp)
8114c15c:	e0fffe17 	ldw	r3,-8(fp)
8114c160:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114c164:	e0bffc17 	ldw	r2,-16(fp)
8114c168:	e0ffff17 	ldw	r3,-4(fp)
8114c16c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c170:	0005303a 	rdctl	r2,status
8114c174:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c178:	e0fff917 	ldw	r3,-28(fp)
8114c17c:	00bfff84 	movi	r2,-2
8114c180:	1884703a 	and	r2,r3,r2
8114c184:	1001703a 	wrctl	status,r2
  
  return context;
8114c188:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8114c18c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114c190:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
8114c194:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8114c198:	e0fffd17 	ldw	r3,-12(fp)
8114c19c:	e0bff617 	ldw	r2,-40(fp)
8114c1a0:	1885883a 	add	r2,r3,r2
8114c1a4:	10c00044 	addi	r3,r2,1
8114c1a8:	e0bffc17 	ldw	r2,-16(fp)
8114c1ac:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114c1b0:	e0bffc17 	ldw	r2,-16(fp)
8114c1b4:	10c00217 	ldw	r3,8(r2)
8114c1b8:	e0bff617 	ldw	r2,-40(fp)
8114c1bc:	1880042e 	bgeu	r3,r2,8114c1d0 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8114c1c0:	e0bffc17 	ldw	r2,-16(fp)
8114c1c4:	00c00044 	movi	r3,1
8114c1c8:	10c00405 	stb	r3,16(r2)
8114c1cc:	00000206 	br	8114c1d8 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8114c1d0:	e0bffc17 	ldw	r2,-16(fp)
8114c1d4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8114c1d8:	e0bffc17 	ldw	r2,-16(fp)
8114c1dc:	d0e01404 	addi	r3,gp,-32688
8114c1e0:	e0fffa15 	stw	r3,-24(fp)
8114c1e4:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114c1e8:	e0bffb17 	ldw	r2,-20(fp)
8114c1ec:	e0fffa17 	ldw	r3,-24(fp)
8114c1f0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114c1f4:	e0bffa17 	ldw	r2,-24(fp)
8114c1f8:	10c00017 	ldw	r3,0(r2)
8114c1fc:	e0bffb17 	ldw	r2,-20(fp)
8114c200:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114c204:	e0bffa17 	ldw	r2,-24(fp)
8114c208:	10800017 	ldw	r2,0(r2)
8114c20c:	e0fffb17 	ldw	r3,-20(fp)
8114c210:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114c214:	e0bffa17 	ldw	r2,-24(fp)
8114c218:	e0fffb17 	ldw	r3,-20(fp)
8114c21c:	10c00015 	stw	r3,0(r2)
8114c220:	e0bff817 	ldw	r2,-32(fp)
8114c224:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c228:	e0bff717 	ldw	r2,-36(fp)
8114c22c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114c230:	0005883a 	mov	r2,zero
8114c234:	00000306 	br	8114c244 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8114c238:	00bffa84 	movi	r2,-22
8114c23c:	00000106 	br	8114c244 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114c240:	00bfde84 	movi	r2,-134
  }
}
8114c244:	e037883a 	mov	sp,fp
8114c248:	df000017 	ldw	fp,0(sp)
8114c24c:	dec00104 	addi	sp,sp,4
8114c250:	f800283a 	ret

8114c254 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114c254:	defffe04 	addi	sp,sp,-8
8114c258:	de00012e 	bgeu	sp,et,8114c260 <alt_get_errno+0xc>
8114c25c:	003b68fa 	trap	3
8114c260:	dfc00115 	stw	ra,4(sp)
8114c264:	df000015 	stw	fp,0(sp)
8114c268:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114c26c:	d0a01017 	ldw	r2,-32704(gp)
8114c270:	10000326 	beq	r2,zero,8114c280 <alt_get_errno+0x2c>
8114c274:	d0a01017 	ldw	r2,-32704(gp)
8114c278:	103ee83a 	callr	r2
8114c27c:	00000106 	br	8114c284 <alt_get_errno+0x30>
8114c280:	d0a07804 	addi	r2,gp,-32288
}
8114c284:	e037883a 	mov	sp,fp
8114c288:	dfc00117 	ldw	ra,4(sp)
8114c28c:	df000017 	ldw	fp,0(sp)
8114c290:	dec00204 	addi	sp,sp,8
8114c294:	f800283a 	ret

8114c298 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8114c298:	defffa04 	addi	sp,sp,-24
8114c29c:	de00012e 	bgeu	sp,et,8114c2a4 <alt_dev_llist_insert+0xc>
8114c2a0:	003b68fa 	trap	3
8114c2a4:	dfc00515 	stw	ra,20(sp)
8114c2a8:	df000415 	stw	fp,16(sp)
8114c2ac:	df000404 	addi	fp,sp,16
8114c2b0:	e13ffe15 	stw	r4,-8(fp)
8114c2b4:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8114c2b8:	e0bffe17 	ldw	r2,-8(fp)
8114c2bc:	10000326 	beq	r2,zero,8114c2cc <alt_dev_llist_insert+0x34>
8114c2c0:	e0bffe17 	ldw	r2,-8(fp)
8114c2c4:	10800217 	ldw	r2,8(r2)
8114c2c8:	1000061e 	bne	r2,zero,8114c2e4 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8114c2cc:	114c2540 	call	8114c254 <alt_get_errno>
8114c2d0:	1007883a 	mov	r3,r2
8114c2d4:	00800584 	movi	r2,22
8114c2d8:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8114c2dc:	00bffa84 	movi	r2,-22
8114c2e0:	00001306 	br	8114c330 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114c2e4:	e0bffe17 	ldw	r2,-8(fp)
8114c2e8:	e0ffff17 	ldw	r3,-4(fp)
8114c2ec:	e0fffc15 	stw	r3,-16(fp)
8114c2f0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114c2f4:	e0bffd17 	ldw	r2,-12(fp)
8114c2f8:	e0fffc17 	ldw	r3,-16(fp)
8114c2fc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114c300:	e0bffc17 	ldw	r2,-16(fp)
8114c304:	10c00017 	ldw	r3,0(r2)
8114c308:	e0bffd17 	ldw	r2,-12(fp)
8114c30c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114c310:	e0bffc17 	ldw	r2,-16(fp)
8114c314:	10800017 	ldw	r2,0(r2)
8114c318:	e0fffd17 	ldw	r3,-12(fp)
8114c31c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114c320:	e0bffc17 	ldw	r2,-16(fp)
8114c324:	e0fffd17 	ldw	r3,-12(fp)
8114c328:	10c00015 	stw	r3,0(r2)

  return 0;  
8114c32c:	0005883a 	mov	r2,zero
}
8114c330:	e037883a 	mov	sp,fp
8114c334:	dfc00117 	ldw	ra,4(sp)
8114c338:	df000017 	ldw	fp,0(sp)
8114c33c:	dec00204 	addi	sp,sp,8
8114c340:	f800283a 	ret

8114c344 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114c344:	defffa04 	addi	sp,sp,-24
8114c348:	de00012e 	bgeu	sp,et,8114c350 <alt_find_dev+0xc>
8114c34c:	003b68fa 	trap	3
8114c350:	dfc00515 	stw	ra,20(sp)
8114c354:	df000415 	stw	fp,16(sp)
8114c358:	df000404 	addi	fp,sp,16
8114c35c:	e13ffe15 	stw	r4,-8(fp)
8114c360:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114c364:	e0bfff17 	ldw	r2,-4(fp)
8114c368:	10800017 	ldw	r2,0(r2)
8114c36c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114c370:	e13ffe17 	ldw	r4,-8(fp)
8114c374:	11251780 	call	81125178 <strlen>
8114c378:	10800044 	addi	r2,r2,1
8114c37c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114c380:	00000d06 	br	8114c3b8 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114c384:	e0bffc17 	ldw	r2,-16(fp)
8114c388:	10800217 	ldw	r2,8(r2)
8114c38c:	e0fffd17 	ldw	r3,-12(fp)
8114c390:	180d883a 	mov	r6,r3
8114c394:	e17ffe17 	ldw	r5,-8(fp)
8114c398:	1009883a 	mov	r4,r2
8114c39c:	114d1580 	call	8114d158 <memcmp>
8114c3a0:	1000021e 	bne	r2,zero,8114c3ac <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114c3a4:	e0bffc17 	ldw	r2,-16(fp)
8114c3a8:	00000706 	br	8114c3c8 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8114c3ac:	e0bffc17 	ldw	r2,-16(fp)
8114c3b0:	10800017 	ldw	r2,0(r2)
8114c3b4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114c3b8:	e0fffc17 	ldw	r3,-16(fp)
8114c3bc:	e0bfff17 	ldw	r2,-4(fp)
8114c3c0:	18bff01e 	bne	r3,r2,8114c384 <__reset+0xfb12c384>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114c3c4:	0005883a 	mov	r2,zero
}
8114c3c8:	e037883a 	mov	sp,fp
8114c3cc:	dfc00117 	ldw	ra,4(sp)
8114c3d0:	df000017 	ldw	fp,0(sp)
8114c3d4:	dec00204 	addi	sp,sp,8
8114c3d8:	f800283a 	ret

8114c3dc <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8114c3dc:	defffb04 	addi	sp,sp,-20
8114c3e0:	de00012e 	bgeu	sp,et,8114c3e8 <alt_find_file+0xc>
8114c3e4:	003b68fa 	trap	3
8114c3e8:	dfc00415 	stw	ra,16(sp)
8114c3ec:	df000315 	stw	fp,12(sp)
8114c3f0:	df000304 	addi	fp,sp,12
8114c3f4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8114c3f8:	d0a00b17 	ldw	r2,-32724(gp)
8114c3fc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114c400:	00003106 	br	8114c4c8 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114c404:	e0bffd17 	ldw	r2,-12(fp)
8114c408:	10800217 	ldw	r2,8(r2)
8114c40c:	1009883a 	mov	r4,r2
8114c410:	11251780 	call	81125178 <strlen>
8114c414:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8114c418:	e0bffd17 	ldw	r2,-12(fp)
8114c41c:	10c00217 	ldw	r3,8(r2)
8114c420:	e0bffe17 	ldw	r2,-8(fp)
8114c424:	10bfffc4 	addi	r2,r2,-1
8114c428:	1885883a 	add	r2,r3,r2
8114c42c:	10800003 	ldbu	r2,0(r2)
8114c430:	10803fcc 	andi	r2,r2,255
8114c434:	1080201c 	xori	r2,r2,128
8114c438:	10bfe004 	addi	r2,r2,-128
8114c43c:	10800bd8 	cmpnei	r2,r2,47
8114c440:	1000031e 	bne	r2,zero,8114c450 <alt_find_file+0x74>
    {
      len -= 1;
8114c444:	e0bffe17 	ldw	r2,-8(fp)
8114c448:	10bfffc4 	addi	r2,r2,-1
8114c44c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114c450:	e0bffe17 	ldw	r2,-8(fp)
8114c454:	e0ffff17 	ldw	r3,-4(fp)
8114c458:	1885883a 	add	r2,r3,r2
8114c45c:	10800003 	ldbu	r2,0(r2)
8114c460:	10803fcc 	andi	r2,r2,255
8114c464:	1080201c 	xori	r2,r2,128
8114c468:	10bfe004 	addi	r2,r2,-128
8114c46c:	10800be0 	cmpeqi	r2,r2,47
8114c470:	1000081e 	bne	r2,zero,8114c494 <alt_find_file+0xb8>
8114c474:	e0bffe17 	ldw	r2,-8(fp)
8114c478:	e0ffff17 	ldw	r3,-4(fp)
8114c47c:	1885883a 	add	r2,r3,r2
8114c480:	10800003 	ldbu	r2,0(r2)
8114c484:	10803fcc 	andi	r2,r2,255
8114c488:	1080201c 	xori	r2,r2,128
8114c48c:	10bfe004 	addi	r2,r2,-128
8114c490:	10000a1e 	bne	r2,zero,8114c4bc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114c494:	e0bffd17 	ldw	r2,-12(fp)
8114c498:	10800217 	ldw	r2,8(r2)
8114c49c:	e0fffe17 	ldw	r3,-8(fp)
8114c4a0:	180d883a 	mov	r6,r3
8114c4a4:	e17fff17 	ldw	r5,-4(fp)
8114c4a8:	1009883a 	mov	r4,r2
8114c4ac:	114d1580 	call	8114d158 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114c4b0:	1000021e 	bne	r2,zero,8114c4bc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114c4b4:	e0bffd17 	ldw	r2,-12(fp)
8114c4b8:	00000706 	br	8114c4d8 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8114c4bc:	e0bffd17 	ldw	r2,-12(fp)
8114c4c0:	10800017 	ldw	r2,0(r2)
8114c4c4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114c4c8:	e0fffd17 	ldw	r3,-12(fp)
8114c4cc:	d0a00b04 	addi	r2,gp,-32724
8114c4d0:	18bfcc1e 	bne	r3,r2,8114c404 <__reset+0xfb12c404>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114c4d4:	0005883a 	mov	r2,zero
}
8114c4d8:	e037883a 	mov	sp,fp
8114c4dc:	dfc00117 	ldw	ra,4(sp)
8114c4e0:	df000017 	ldw	fp,0(sp)
8114c4e4:	dec00204 	addi	sp,sp,8
8114c4e8:	f800283a 	ret

8114c4ec <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8114c4ec:	defff904 	addi	sp,sp,-28
8114c4f0:	de00012e 	bgeu	sp,et,8114c4f8 <alt_get_fd+0xc>
8114c4f4:	003b68fa 	trap	3
8114c4f8:	dfc00615 	stw	ra,24(sp)
8114c4fc:	df000515 	stw	fp,20(sp)
8114c500:	df000504 	addi	fp,sp,20
8114c504:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8114c508:	00bffa04 	movi	r2,-24
8114c50c:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114c510:	d0a07f17 	ldw	r2,-32260(gp)
8114c514:	e0bffd15 	stw	r2,-12(fp)
8114c518:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8114c51c:	e0bffe0b 	ldhu	r2,-8(fp)
8114c520:	e0fffe84 	addi	r3,fp,-6
8114c524:	180d883a 	mov	r6,r3
8114c528:	100b883a 	mov	r5,r2
8114c52c:	e13ffd17 	ldw	r4,-12(fp)
8114c530:	1140b0c0 	call	81140b0c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114c534:	e03ffb15 	stw	zero,-20(fp)
8114c538:	00001906 	br	8114c5a0 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8114c53c:	00a04574 	movhi	r2,33045
8114c540:	108f4404 	addi	r2,r2,15632
8114c544:	e0fffb17 	ldw	r3,-20(fp)
8114c548:	18c00324 	muli	r3,r3,12
8114c54c:	10c5883a 	add	r2,r2,r3
8114c550:	10800017 	ldw	r2,0(r2)
8114c554:	10000f1e 	bne	r2,zero,8114c594 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114c558:	00a04574 	movhi	r2,33045
8114c55c:	108f4404 	addi	r2,r2,15632
8114c560:	e0fffb17 	ldw	r3,-20(fp)
8114c564:	18c00324 	muli	r3,r3,12
8114c568:	10c5883a 	add	r2,r2,r3
8114c56c:	e0ffff17 	ldw	r3,-4(fp)
8114c570:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114c574:	d0e00f17 	ldw	r3,-32708(gp)
8114c578:	e0bffb17 	ldw	r2,-20(fp)
8114c57c:	1880020e 	bge	r3,r2,8114c588 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114c580:	e0bffb17 	ldw	r2,-20(fp)
8114c584:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114c588:	e0bffb17 	ldw	r2,-20(fp)
8114c58c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114c590:	00000606 	br	8114c5ac <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114c594:	e0bffb17 	ldw	r2,-20(fp)
8114c598:	10800044 	addi	r2,r2,1
8114c59c:	e0bffb15 	stw	r2,-20(fp)
8114c5a0:	e0bffb17 	ldw	r2,-20(fp)
8114c5a4:	10800810 	cmplti	r2,r2,32
8114c5a8:	103fe41e 	bne	r2,zero,8114c53c <__reset+0xfb12c53c>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8114c5ac:	d0a07f17 	ldw	r2,-32260(gp)
8114c5b0:	1009883a 	mov	r4,r2
8114c5b4:	1140e940 	call	81140e94 <OSSemPost>

  return rc;
8114c5b8:	e0bffc17 	ldw	r2,-16(fp)
}
8114c5bc:	e037883a 	mov	sp,fp
8114c5c0:	dfc00117 	ldw	ra,4(sp)
8114c5c4:	df000017 	ldw	fp,0(sp)
8114c5c8:	dec00204 	addi	sp,sp,8
8114c5cc:	f800283a 	ret

8114c5d0 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114c5d0:	defff904 	addi	sp,sp,-28
8114c5d4:	de00012e 	bgeu	sp,et,8114c5dc <alt_ic_isr_register+0xc>
8114c5d8:	003b68fa 	trap	3
8114c5dc:	dfc00615 	stw	ra,24(sp)
8114c5e0:	df000515 	stw	fp,20(sp)
8114c5e4:	df000504 	addi	fp,sp,20
8114c5e8:	e13ffc15 	stw	r4,-16(fp)
8114c5ec:	e17ffd15 	stw	r5,-12(fp)
8114c5f0:	e1bffe15 	stw	r6,-8(fp)
8114c5f4:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8114c5f8:	e0800217 	ldw	r2,8(fp)
8114c5fc:	d8800015 	stw	r2,0(sp)
8114c600:	e1ffff17 	ldw	r7,-4(fp)
8114c604:	e1bffe17 	ldw	r6,-8(fp)
8114c608:	e17ffd17 	ldw	r5,-12(fp)
8114c60c:	e13ffc17 	ldw	r4,-16(fp)
8114c610:	114c7a00 	call	8114c7a0 <alt_iic_isr_register>
}  
8114c614:	e037883a 	mov	sp,fp
8114c618:	dfc00117 	ldw	ra,4(sp)
8114c61c:	df000017 	ldw	fp,0(sp)
8114c620:	dec00204 	addi	sp,sp,8
8114c624:	f800283a 	ret

8114c628 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114c628:	defff904 	addi	sp,sp,-28
8114c62c:	de00012e 	bgeu	sp,et,8114c634 <alt_ic_irq_enable+0xc>
8114c630:	003b68fa 	trap	3
8114c634:	df000615 	stw	fp,24(sp)
8114c638:	df000604 	addi	fp,sp,24
8114c63c:	e13ffe15 	stw	r4,-8(fp)
8114c640:	e17fff15 	stw	r5,-4(fp)
8114c644:	e0bfff17 	ldw	r2,-4(fp)
8114c648:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c64c:	0005303a 	rdctl	r2,status
8114c650:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c654:	e0fffb17 	ldw	r3,-20(fp)
8114c658:	00bfff84 	movi	r2,-2
8114c65c:	1884703a 	and	r2,r3,r2
8114c660:	1001703a 	wrctl	status,r2
  
  return context;
8114c664:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114c668:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114c66c:	00c00044 	movi	r3,1
8114c670:	e0bffa17 	ldw	r2,-24(fp)
8114c674:	1884983a 	sll	r2,r3,r2
8114c678:	1007883a 	mov	r3,r2
8114c67c:	d0a08017 	ldw	r2,-32256(gp)
8114c680:	1884b03a 	or	r2,r3,r2
8114c684:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114c688:	d0a08017 	ldw	r2,-32256(gp)
8114c68c:	100170fa 	wrctl	ienable,r2
8114c690:	e0bffc17 	ldw	r2,-16(fp)
8114c694:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c698:	e0bffd17 	ldw	r2,-12(fp)
8114c69c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114c6a0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114c6a4:	0001883a 	nop
}
8114c6a8:	e037883a 	mov	sp,fp
8114c6ac:	df000017 	ldw	fp,0(sp)
8114c6b0:	dec00104 	addi	sp,sp,4
8114c6b4:	f800283a 	ret

8114c6b8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114c6b8:	defff904 	addi	sp,sp,-28
8114c6bc:	de00012e 	bgeu	sp,et,8114c6c4 <alt_ic_irq_disable+0xc>
8114c6c0:	003b68fa 	trap	3
8114c6c4:	df000615 	stw	fp,24(sp)
8114c6c8:	df000604 	addi	fp,sp,24
8114c6cc:	e13ffe15 	stw	r4,-8(fp)
8114c6d0:	e17fff15 	stw	r5,-4(fp)
8114c6d4:	e0bfff17 	ldw	r2,-4(fp)
8114c6d8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c6dc:	0005303a 	rdctl	r2,status
8114c6e0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c6e4:	e0fffb17 	ldw	r3,-20(fp)
8114c6e8:	00bfff84 	movi	r2,-2
8114c6ec:	1884703a 	and	r2,r3,r2
8114c6f0:	1001703a 	wrctl	status,r2
  
  return context;
8114c6f4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114c6f8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114c6fc:	00c00044 	movi	r3,1
8114c700:	e0bffa17 	ldw	r2,-24(fp)
8114c704:	1884983a 	sll	r2,r3,r2
8114c708:	0084303a 	nor	r2,zero,r2
8114c70c:	1007883a 	mov	r3,r2
8114c710:	d0a08017 	ldw	r2,-32256(gp)
8114c714:	1884703a 	and	r2,r3,r2
8114c718:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114c71c:	d0a08017 	ldw	r2,-32256(gp)
8114c720:	100170fa 	wrctl	ienable,r2
8114c724:	e0bffc17 	ldw	r2,-16(fp)
8114c728:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c72c:	e0bffd17 	ldw	r2,-12(fp)
8114c730:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114c734:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114c738:	0001883a 	nop
}
8114c73c:	e037883a 	mov	sp,fp
8114c740:	df000017 	ldw	fp,0(sp)
8114c744:	dec00104 	addi	sp,sp,4
8114c748:	f800283a 	ret

8114c74c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114c74c:	defffc04 	addi	sp,sp,-16
8114c750:	de00012e 	bgeu	sp,et,8114c758 <alt_ic_irq_enabled+0xc>
8114c754:	003b68fa 	trap	3
8114c758:	df000315 	stw	fp,12(sp)
8114c75c:	df000304 	addi	fp,sp,12
8114c760:	e13ffe15 	stw	r4,-8(fp)
8114c764:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114c768:	000530fa 	rdctl	r2,ienable
8114c76c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114c770:	00c00044 	movi	r3,1
8114c774:	e0bfff17 	ldw	r2,-4(fp)
8114c778:	1884983a 	sll	r2,r3,r2
8114c77c:	1007883a 	mov	r3,r2
8114c780:	e0bffd17 	ldw	r2,-12(fp)
8114c784:	1884703a 	and	r2,r3,r2
8114c788:	1004c03a 	cmpne	r2,r2,zero
8114c78c:	10803fcc 	andi	r2,r2,255
}
8114c790:	e037883a 	mov	sp,fp
8114c794:	df000017 	ldw	fp,0(sp)
8114c798:	dec00104 	addi	sp,sp,4
8114c79c:	f800283a 	ret

8114c7a0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114c7a0:	defff504 	addi	sp,sp,-44
8114c7a4:	de00012e 	bgeu	sp,et,8114c7ac <alt_iic_isr_register+0xc>
8114c7a8:	003b68fa 	trap	3
8114c7ac:	dfc00a15 	stw	ra,40(sp)
8114c7b0:	df000915 	stw	fp,36(sp)
8114c7b4:	df000904 	addi	fp,sp,36
8114c7b8:	e13ffc15 	stw	r4,-16(fp)
8114c7bc:	e17ffd15 	stw	r5,-12(fp)
8114c7c0:	e1bffe15 	stw	r6,-8(fp)
8114c7c4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114c7c8:	00bffa84 	movi	r2,-22
8114c7cc:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114c7d0:	e0bffd17 	ldw	r2,-12(fp)
8114c7d4:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114c7d8:	e0bff817 	ldw	r2,-32(fp)
8114c7dc:	10800808 	cmpgei	r2,r2,32
8114c7e0:	1000271e 	bne	r2,zero,8114c880 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c7e4:	0005303a 	rdctl	r2,status
8114c7e8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c7ec:	e0fffb17 	ldw	r3,-20(fp)
8114c7f0:	00bfff84 	movi	r2,-2
8114c7f4:	1884703a 	and	r2,r3,r2
8114c7f8:	1001703a 	wrctl	status,r2
  
  return context;
8114c7fc:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114c800:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114c804:	00a045f4 	movhi	r2,33047
8114c808:	10bce904 	addi	r2,r2,-3164
8114c80c:	e0fff817 	ldw	r3,-32(fp)
8114c810:	180690fa 	slli	r3,r3,3
8114c814:	10c5883a 	add	r2,r2,r3
8114c818:	e0fffe17 	ldw	r3,-8(fp)
8114c81c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114c820:	00a045f4 	movhi	r2,33047
8114c824:	10bce904 	addi	r2,r2,-3164
8114c828:	e0fff817 	ldw	r3,-32(fp)
8114c82c:	180690fa 	slli	r3,r3,3
8114c830:	10c5883a 	add	r2,r2,r3
8114c834:	10800104 	addi	r2,r2,4
8114c838:	e0ffff17 	ldw	r3,-4(fp)
8114c83c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114c840:	e0bffe17 	ldw	r2,-8(fp)
8114c844:	10000526 	beq	r2,zero,8114c85c <alt_iic_isr_register+0xbc>
8114c848:	e0bff817 	ldw	r2,-32(fp)
8114c84c:	100b883a 	mov	r5,r2
8114c850:	e13ffc17 	ldw	r4,-16(fp)
8114c854:	114c6280 	call	8114c628 <alt_ic_irq_enable>
8114c858:	00000406 	br	8114c86c <alt_iic_isr_register+0xcc>
8114c85c:	e0bff817 	ldw	r2,-32(fp)
8114c860:	100b883a 	mov	r5,r2
8114c864:	e13ffc17 	ldw	r4,-16(fp)
8114c868:	114c6b80 	call	8114c6b8 <alt_ic_irq_disable>
8114c86c:	e0bff715 	stw	r2,-36(fp)
8114c870:	e0bffa17 	ldw	r2,-24(fp)
8114c874:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c878:	e0bff917 	ldw	r2,-28(fp)
8114c87c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114c880:	e0bff717 	ldw	r2,-36(fp)
}
8114c884:	e037883a 	mov	sp,fp
8114c888:	dfc00117 	ldw	ra,4(sp)
8114c88c:	df000017 	ldw	fp,0(sp)
8114c890:	dec00204 	addi	sp,sp,8
8114c894:	f800283a 	ret

8114c898 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114c898:	defff904 	addi	sp,sp,-28
8114c89c:	de00012e 	bgeu	sp,et,8114c8a4 <alt_open_fd+0xc>
8114c8a0:	003b68fa 	trap	3
8114c8a4:	dfc00615 	stw	ra,24(sp)
8114c8a8:	df000515 	stw	fp,20(sp)
8114c8ac:	df000504 	addi	fp,sp,20
8114c8b0:	e13ffc15 	stw	r4,-16(fp)
8114c8b4:	e17ffd15 	stw	r5,-12(fp)
8114c8b8:	e1bffe15 	stw	r6,-8(fp)
8114c8bc:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114c8c0:	e1bfff17 	ldw	r6,-4(fp)
8114c8c4:	e17ffe17 	ldw	r5,-8(fp)
8114c8c8:	e13ffd17 	ldw	r4,-12(fp)
8114c8cc:	11397480 	call	81139748 <open>
8114c8d0:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114c8d4:	e0bffb17 	ldw	r2,-20(fp)
8114c8d8:	10001c16 	blt	r2,zero,8114c94c <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114c8dc:	00a04574 	movhi	r2,33045
8114c8e0:	108f4404 	addi	r2,r2,15632
8114c8e4:	e0fffb17 	ldw	r3,-20(fp)
8114c8e8:	18c00324 	muli	r3,r3,12
8114c8ec:	10c5883a 	add	r2,r2,r3
8114c8f0:	10c00017 	ldw	r3,0(r2)
8114c8f4:	e0bffc17 	ldw	r2,-16(fp)
8114c8f8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114c8fc:	00a04574 	movhi	r2,33045
8114c900:	108f4404 	addi	r2,r2,15632
8114c904:	e0fffb17 	ldw	r3,-20(fp)
8114c908:	18c00324 	muli	r3,r3,12
8114c90c:	10c5883a 	add	r2,r2,r3
8114c910:	10800104 	addi	r2,r2,4
8114c914:	10c00017 	ldw	r3,0(r2)
8114c918:	e0bffc17 	ldw	r2,-16(fp)
8114c91c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114c920:	00a04574 	movhi	r2,33045
8114c924:	108f4404 	addi	r2,r2,15632
8114c928:	e0fffb17 	ldw	r3,-20(fp)
8114c92c:	18c00324 	muli	r3,r3,12
8114c930:	10c5883a 	add	r2,r2,r3
8114c934:	10800204 	addi	r2,r2,8
8114c938:	10c00017 	ldw	r3,0(r2)
8114c93c:	e0bffc17 	ldw	r2,-16(fp)
8114c940:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114c944:	e13ffb17 	ldw	r4,-20(fp)
8114c948:	11399ec0 	call	811399ec <alt_release_fd>
  }
} 
8114c94c:	0001883a 	nop
8114c950:	e037883a 	mov	sp,fp
8114c954:	dfc00117 	ldw	ra,4(sp)
8114c958:	df000017 	ldw	fp,0(sp)
8114c95c:	dec00204 	addi	sp,sp,8
8114c960:	f800283a 	ret

8114c964 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114c964:	defffb04 	addi	sp,sp,-20
8114c968:	de00012e 	bgeu	sp,et,8114c970 <alt_io_redirect+0xc>
8114c96c:	003b68fa 	trap	3
8114c970:	dfc00415 	stw	ra,16(sp)
8114c974:	df000315 	stw	fp,12(sp)
8114c978:	df000304 	addi	fp,sp,12
8114c97c:	e13ffd15 	stw	r4,-12(fp)
8114c980:	e17ffe15 	stw	r5,-8(fp)
8114c984:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114c988:	01c07fc4 	movi	r7,511
8114c98c:	01800044 	movi	r6,1
8114c990:	e17ffd17 	ldw	r5,-12(fp)
8114c994:	01204574 	movhi	r4,33045
8114c998:	210f4704 	addi	r4,r4,15644
8114c99c:	114c8980 	call	8114c898 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114c9a0:	01c07fc4 	movi	r7,511
8114c9a4:	000d883a 	mov	r6,zero
8114c9a8:	e17ffe17 	ldw	r5,-8(fp)
8114c9ac:	01204574 	movhi	r4,33045
8114c9b0:	210f4404 	addi	r4,r4,15632
8114c9b4:	114c8980 	call	8114c898 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114c9b8:	01c07fc4 	movi	r7,511
8114c9bc:	01800044 	movi	r6,1
8114c9c0:	e17fff17 	ldw	r5,-4(fp)
8114c9c4:	01204574 	movhi	r4,33045
8114c9c8:	210f4a04 	addi	r4,r4,15656
8114c9cc:	114c8980 	call	8114c898 <alt_open_fd>
}  
8114c9d0:	0001883a 	nop
8114c9d4:	e037883a 	mov	sp,fp
8114c9d8:	dfc00117 	ldw	ra,4(sp)
8114c9dc:	df000017 	ldw	fp,0(sp)
8114c9e0:	dec00204 	addi	sp,sp,8
8114c9e4:	f800283a 	ret

8114c9e8 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114c9e8:	defff204 	addi	sp,sp,-56
8114c9ec:	de00012e 	bgeu	sp,et,8114c9f4 <alt_printf+0xc>
8114c9f0:	003b68fa 	trap	3
8114c9f4:	dfc00a15 	stw	ra,40(sp)
8114c9f8:	df000915 	stw	fp,36(sp)
8114c9fc:	df000904 	addi	fp,sp,36
8114ca00:	e13fff15 	stw	r4,-4(fp)
8114ca04:	e1400215 	stw	r5,8(fp)
8114ca08:	e1800315 	stw	r6,12(fp)
8114ca0c:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114ca10:	e0800204 	addi	r2,fp,8
8114ca14:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114ca18:	e0bfff17 	ldw	r2,-4(fp)
8114ca1c:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114ca20:	00006f06 	br	8114cbe0 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114ca24:	e0bff807 	ldb	r2,-32(fp)
8114ca28:	10800960 	cmpeqi	r2,r2,37
8114ca2c:	1000041e 	bne	r2,zero,8114ca40 <alt_printf+0x58>
        {
            alt_putchar(c);
8114ca30:	e0bff807 	ldb	r2,-32(fp)
8114ca34:	1009883a 	mov	r4,r2
8114ca38:	114cc1c0 	call	8114cc1c <alt_putchar>
8114ca3c:	00006806 	br	8114cbe0 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114ca40:	e0bff717 	ldw	r2,-36(fp)
8114ca44:	10c00044 	addi	r3,r2,1
8114ca48:	e0fff715 	stw	r3,-36(fp)
8114ca4c:	10800003 	ldbu	r2,0(r2)
8114ca50:	e0bff805 	stb	r2,-32(fp)
8114ca54:	e0bff807 	ldb	r2,-32(fp)
8114ca58:	10006926 	beq	r2,zero,8114cc00 <alt_printf+0x218>
            {
                if (c == '%')
8114ca5c:	e0bff807 	ldb	r2,-32(fp)
8114ca60:	10800958 	cmpnei	r2,r2,37
8114ca64:	1000041e 	bne	r2,zero,8114ca78 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114ca68:	e0bff807 	ldb	r2,-32(fp)
8114ca6c:	1009883a 	mov	r4,r2
8114ca70:	114cc1c0 	call	8114cc1c <alt_putchar>
8114ca74:	00005a06 	br	8114cbe0 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114ca78:	e0bff807 	ldb	r2,-32(fp)
8114ca7c:	108018d8 	cmpnei	r2,r2,99
8114ca80:	1000081e 	bne	r2,zero,8114caa4 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114ca84:	e0bffe17 	ldw	r2,-8(fp)
8114ca88:	10c00104 	addi	r3,r2,4
8114ca8c:	e0fffe15 	stw	r3,-8(fp)
8114ca90:	10800017 	ldw	r2,0(r2)
8114ca94:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114ca98:	e13ffd17 	ldw	r4,-12(fp)
8114ca9c:	114cc1c0 	call	8114cc1c <alt_putchar>
8114caa0:	00004f06 	br	8114cbe0 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114caa4:	e0bff807 	ldb	r2,-32(fp)
8114caa8:	10801e18 	cmpnei	r2,r2,120
8114caac:	1000341e 	bne	r2,zero,8114cb80 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114cab0:	e0bffe17 	ldw	r2,-8(fp)
8114cab4:	10c00104 	addi	r3,r2,4
8114cab8:	e0fffe15 	stw	r3,-8(fp)
8114cabc:	10800017 	ldw	r2,0(r2)
8114cac0:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114cac4:	e0bffb17 	ldw	r2,-20(fp)
8114cac8:	1000031e 	bne	r2,zero,8114cad8 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114cacc:	01000c04 	movi	r4,48
8114cad0:	114cc1c0 	call	8114cc1c <alt_putchar>
                        continue;
8114cad4:	00004206 	br	8114cbe0 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114cad8:	00800704 	movi	r2,28
8114cadc:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114cae0:	00000306 	br	8114caf0 <alt_printf+0x108>
                        digit_shift -= 4;
8114cae4:	e0bff917 	ldw	r2,-28(fp)
8114cae8:	10bfff04 	addi	r2,r2,-4
8114caec:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114caf0:	00c003c4 	movi	r3,15
8114caf4:	e0bff917 	ldw	r2,-28(fp)
8114caf8:	1884983a 	sll	r2,r3,r2
8114cafc:	1007883a 	mov	r3,r2
8114cb00:	e0bffb17 	ldw	r2,-20(fp)
8114cb04:	1884703a 	and	r2,r3,r2
8114cb08:	103ff626 	beq	r2,zero,8114cae4 <__reset+0xfb12cae4>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114cb0c:	00001906 	br	8114cb74 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114cb10:	00c003c4 	movi	r3,15
8114cb14:	e0bff917 	ldw	r2,-28(fp)
8114cb18:	1884983a 	sll	r2,r3,r2
8114cb1c:	1007883a 	mov	r3,r2
8114cb20:	e0bffb17 	ldw	r2,-20(fp)
8114cb24:	1886703a 	and	r3,r3,r2
8114cb28:	e0bff917 	ldw	r2,-28(fp)
8114cb2c:	1884d83a 	srl	r2,r3,r2
8114cb30:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114cb34:	e0bffc17 	ldw	r2,-16(fp)
8114cb38:	108002a8 	cmpgeui	r2,r2,10
8114cb3c:	1000041e 	bne	r2,zero,8114cb50 <alt_printf+0x168>
                            c = '0' + digit;
8114cb40:	e0bffc17 	ldw	r2,-16(fp)
8114cb44:	10800c04 	addi	r2,r2,48
8114cb48:	e0bff805 	stb	r2,-32(fp)
8114cb4c:	00000306 	br	8114cb5c <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114cb50:	e0bffc17 	ldw	r2,-16(fp)
8114cb54:	108015c4 	addi	r2,r2,87
8114cb58:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114cb5c:	e0bff807 	ldb	r2,-32(fp)
8114cb60:	1009883a 	mov	r4,r2
8114cb64:	114cc1c0 	call	8114cc1c <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114cb68:	e0bff917 	ldw	r2,-28(fp)
8114cb6c:	10bfff04 	addi	r2,r2,-4
8114cb70:	e0bff915 	stw	r2,-28(fp)
8114cb74:	e0bff917 	ldw	r2,-28(fp)
8114cb78:	103fe50e 	bge	r2,zero,8114cb10 <__reset+0xfb12cb10>
8114cb7c:	00001806 	br	8114cbe0 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114cb80:	e0bff807 	ldb	r2,-32(fp)
8114cb84:	10801cd8 	cmpnei	r2,r2,115
8114cb88:	1000151e 	bne	r2,zero,8114cbe0 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114cb8c:	e0bffe17 	ldw	r2,-8(fp)
8114cb90:	10c00104 	addi	r3,r2,4
8114cb94:	e0fffe15 	stw	r3,-8(fp)
8114cb98:	10800017 	ldw	r2,0(r2)
8114cb9c:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114cba0:	00000906 	br	8114cbc8 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114cba4:	e0bffa17 	ldw	r2,-24(fp)
8114cba8:	10c00044 	addi	r3,r2,1
8114cbac:	e0fffa15 	stw	r3,-24(fp)
8114cbb0:	10800003 	ldbu	r2,0(r2)
8114cbb4:	10803fcc 	andi	r2,r2,255
8114cbb8:	1080201c 	xori	r2,r2,128
8114cbbc:	10bfe004 	addi	r2,r2,-128
8114cbc0:	1009883a 	mov	r4,r2
8114cbc4:	114cc1c0 	call	8114cc1c <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114cbc8:	e0bffa17 	ldw	r2,-24(fp)
8114cbcc:	10800003 	ldbu	r2,0(r2)
8114cbd0:	10803fcc 	andi	r2,r2,255
8114cbd4:	1080201c 	xori	r2,r2,128
8114cbd8:	10bfe004 	addi	r2,r2,-128
8114cbdc:	103ff11e 	bne	r2,zero,8114cba4 <__reset+0xfb12cba4>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114cbe0:	e0bff717 	ldw	r2,-36(fp)
8114cbe4:	10c00044 	addi	r3,r2,1
8114cbe8:	e0fff715 	stw	r3,-36(fp)
8114cbec:	10800003 	ldbu	r2,0(r2)
8114cbf0:	e0bff805 	stb	r2,-32(fp)
8114cbf4:	e0bff807 	ldb	r2,-32(fp)
8114cbf8:	103f8a1e 	bne	r2,zero,8114ca24 <__reset+0xfb12ca24>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114cbfc:	00000106 	br	8114cc04 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114cc00:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114cc04:	0001883a 	nop
8114cc08:	e037883a 	mov	sp,fp
8114cc0c:	dfc00117 	ldw	ra,4(sp)
8114cc10:	df000017 	ldw	fp,0(sp)
8114cc14:	dec00504 	addi	sp,sp,20
8114cc18:	f800283a 	ret

8114cc1c <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114cc1c:	defffd04 	addi	sp,sp,-12
8114cc20:	de00012e 	bgeu	sp,et,8114cc28 <alt_putchar+0xc>
8114cc24:	003b68fa 	trap	3
8114cc28:	dfc00215 	stw	ra,8(sp)
8114cc2c:	df000115 	stw	fp,4(sp)
8114cc30:	df000104 	addi	fp,sp,4
8114cc34:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114cc38:	d0a00517 	ldw	r2,-32748(gp)
8114cc3c:	10800217 	ldw	r2,8(r2)
8114cc40:	100b883a 	mov	r5,r2
8114cc44:	e13fff17 	ldw	r4,-4(fp)
8114cc48:	1124a880 	call	81124a88 <putc>
#endif
#endif
}
8114cc4c:	e037883a 	mov	sp,fp
8114cc50:	dfc00117 	ldw	ra,4(sp)
8114cc54:	df000017 	ldw	fp,0(sp)
8114cc58:	dec00204 	addi	sp,sp,8
8114cc5c:	f800283a 	ret

8114cc60 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114cc60:	deffff04 	addi	sp,sp,-4
8114cc64:	de00012e 	bgeu	sp,et,8114cc6c <altera_nios2_gen2_irq_init+0xc>
8114cc68:	003b68fa 	trap	3
8114cc6c:	df000015 	stw	fp,0(sp)
8114cc70:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114cc74:	000170fa 	wrctl	ienable,zero
}
8114cc78:	0001883a 	nop
8114cc7c:	e037883a 	mov	sp,fp
8114cc80:	df000017 	ldw	fp,0(sp)
8114cc84:	dec00104 	addi	sp,sp,4
8114cc88:	f800283a 	ret

8114cc8c <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114cc8c:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114cc90:	de002436 	bltu	sp,et,8114cd24 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114cc94:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114cc98:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114cc9c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114cca0:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114cca4:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114cca8:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114ccac:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114ccb0:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114ccb4:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114ccb8:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114ccbc:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114ccc0:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114ccc4:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114ccc8:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114cccc:	114cf280 	call	8114cf28 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114ccd0:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114ccd4:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114ccd8:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114ccdc:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114cce0:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114cce4:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114cce8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114ccec:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114ccf0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114ccf4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114ccf8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114ccfc:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114cd00:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114cd04:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114cd08:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114cd0c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114cd10:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114cd14:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114cd18:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114cd1c:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114cd20:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114cd24:	003da0fa 	break	3

8114cd28 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114cd28:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114cd2c:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114cd30:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114cd34:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114cd38:	114cf280 	call	8114cf28 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114cd3c:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114cd40:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114cd44:	003fe206 	br	8114ccd0 <__reset+0xfb12ccd0>

8114cd48 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114cd48:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114cd4c:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114cd50:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114cd54:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114cd58:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114cd5c:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114cd60:	dec00204 	addi	sp,sp,8

      callr r2
8114cd64:	103ee83a 	callr	r2

      nop
8114cd68:	0001883a 	nop

8114cd6c <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114cd6c:	defff704 	addi	sp,sp,-36
8114cd70:	de00012e 	bgeu	sp,et,8114cd78 <OSTaskStkInit+0xc>
8114cd74:	003b68fa 	trap	3
8114cd78:	dfc00815 	stw	ra,32(sp)
8114cd7c:	df000715 	stw	fp,28(sp)
8114cd80:	df000704 	addi	fp,sp,28
8114cd84:	e13ffc15 	stw	r4,-16(fp)
8114cd88:	e17ffd15 	stw	r5,-12(fp)
8114cd8c:	e1bffe15 	stw	r6,-8(fp)
8114cd90:	3805883a 	mov	r2,r7
8114cd94:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114cd98:	e0fffe17 	ldw	r3,-8(fp)
8114cd9c:	00bfff04 	movi	r2,-4
8114cda0:	1884703a 	and	r2,r3,r2
8114cda4:	10bef704 	addi	r2,r2,-1060
8114cda8:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114cdac:	01810904 	movi	r6,1060
8114cdb0:	000b883a 	mov	r5,zero
8114cdb4:	e13ff917 	ldw	r4,-28(fp)
8114cdb8:	11248500 	call	81124850 <memset>
8114cdbc:	e0bff917 	ldw	r2,-28(fp)
8114cdc0:	10c0bb04 	addi	r3,r2,748
8114cdc4:	e0bff917 	ldw	r2,-28(fp)
8114cdc8:	10c00115 	stw	r3,4(r2)
8114cdcc:	e0bff917 	ldw	r2,-28(fp)
8114cdd0:	10c0d504 	addi	r3,r2,852
8114cdd4:	e0bff917 	ldw	r2,-28(fp)
8114cdd8:	10c00215 	stw	r3,8(r2)
8114cddc:	e0bff917 	ldw	r2,-28(fp)
8114cde0:	10c0ef04 	addi	r3,r2,956
8114cde4:	e0bff917 	ldw	r2,-28(fp)
8114cde8:	10c00315 	stw	r3,12(r2)
8114cdec:	e0fff917 	ldw	r3,-28(fp)
8114cdf0:	00a04574 	movhi	r2,33045
8114cdf4:	108cdd04 	addi	r2,r2,13172
8114cdf8:	18800d15 	stw	r2,52(r3)
8114cdfc:	e0bff917 	ldw	r2,-28(fp)
8114ce00:	00c00044 	movi	r3,1
8114ce04:	10c02915 	stw	r3,164(r2)
8114ce08:	10002a15 	stw	zero,168(r2)
8114ce0c:	e0bff917 	ldw	r2,-28(fp)
8114ce10:	00ccc384 	movi	r3,13070
8114ce14:	10c02b0d 	sth	r3,172(r2)
8114ce18:	e0bff917 	ldw	r2,-28(fp)
8114ce1c:	00eaf344 	movi	r3,-21555
8114ce20:	10c02b8d 	sth	r3,174(r2)
8114ce24:	e0bff917 	ldw	r2,-28(fp)
8114ce28:	00c48d04 	movi	r3,4660
8114ce2c:	10c02c0d 	sth	r3,176(r2)
8114ce30:	e0bff917 	ldw	r2,-28(fp)
8114ce34:	00f99b44 	movi	r3,-6547
8114ce38:	10c02c8d 	sth	r3,178(r2)
8114ce3c:	e0bff917 	ldw	r2,-28(fp)
8114ce40:	00f7bb04 	movi	r3,-8468
8114ce44:	10c02d0d 	sth	r3,180(r2)
8114ce48:	e0bff917 	ldw	r2,-28(fp)
8114ce4c:	00c00144 	movi	r3,5
8114ce50:	10c02d8d 	sth	r3,182(r2)
8114ce54:	e0bff917 	ldw	r2,-28(fp)
8114ce58:	00c002c4 	movi	r3,11
8114ce5c:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114ce60:	e0bff917 	ldw	r2,-28(fp)
8114ce64:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114ce68:	e0bffa17 	ldw	r2,-24(fp)
8114ce6c:	10bff304 	addi	r2,r2,-52
8114ce70:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114ce74:	e0bffb17 	ldw	r2,-20(fp)
8114ce78:	10800c04 	addi	r2,r2,48
8114ce7c:	e0fffc17 	ldw	r3,-16(fp)
8114ce80:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114ce84:	e0bffb17 	ldw	r2,-20(fp)
8114ce88:	10800b04 	addi	r2,r2,44
8114ce8c:	e0fffd17 	ldw	r3,-12(fp)
8114ce90:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114ce94:	e0bffb17 	ldw	r2,-20(fp)
8114ce98:	10800a04 	addi	r2,r2,40
8114ce9c:	e0fff917 	ldw	r3,-28(fp)
8114cea0:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114cea4:	00a04574 	movhi	r2,33045
8114cea8:	10b35204 	addi	r2,r2,-12984
8114ceac:	10c00104 	addi	r3,r2,4
8114ceb0:	e0bffb17 	ldw	r2,-20(fp)
8114ceb4:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114ceb8:	e0bffb17 	ldw	r2,-20(fp)
}
8114cebc:	e037883a 	mov	sp,fp
8114cec0:	dfc00117 	ldw	ra,4(sp)
8114cec4:	df000017 	ldw	fp,0(sp)
8114cec8:	dec00204 	addi	sp,sp,8
8114cecc:	f800283a 	ret

8114ced0 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114ced0:	defffe04 	addi	sp,sp,-8
8114ced4:	de00012e 	bgeu	sp,et,8114cedc <OSTaskCreateHook+0xc>
8114ced8:	003b68fa 	trap	3
8114cedc:	df000115 	stw	fp,4(sp)
8114cee0:	df000104 	addi	fp,sp,4
8114cee4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114cee8:	0001883a 	nop
8114ceec:	e037883a 	mov	sp,fp
8114cef0:	df000017 	ldw	fp,0(sp)
8114cef4:	dec00104 	addi	sp,sp,4
8114cef8:	f800283a 	ret

8114cefc <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114cefc:	defffe04 	addi	sp,sp,-8
8114cf00:	de00012e 	bgeu	sp,et,8114cf08 <OSTaskDelHook+0xc>
8114cf04:	003b68fa 	trap	3
8114cf08:	df000115 	stw	fp,4(sp)
8114cf0c:	df000104 	addi	fp,sp,4
8114cf10:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114cf14:	0001883a 	nop
8114cf18:	e037883a 	mov	sp,fp
8114cf1c:	df000017 	ldw	fp,0(sp)
8114cf20:	dec00104 	addi	sp,sp,4
8114cf24:	f800283a 	ret

8114cf28 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114cf28:	deffff04 	addi	sp,sp,-4
8114cf2c:	de00012e 	bgeu	sp,et,8114cf34 <OSTaskSwHook+0xc>
8114cf30:	003b68fa 	trap	3
8114cf34:	df000015 	stw	fp,0(sp)
8114cf38:	d839883a 	mov	fp,sp
}
8114cf3c:	0001883a 	nop
8114cf40:	e037883a 	mov	sp,fp
8114cf44:	df000017 	ldw	fp,0(sp)
8114cf48:	dec00104 	addi	sp,sp,4
8114cf4c:	f800283a 	ret

8114cf50 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114cf50:	deffff04 	addi	sp,sp,-4
8114cf54:	de00012e 	bgeu	sp,et,8114cf5c <OSTaskStatHook+0xc>
8114cf58:	003b68fa 	trap	3
8114cf5c:	df000015 	stw	fp,0(sp)
8114cf60:	d839883a 	mov	fp,sp
}
8114cf64:	0001883a 	nop
8114cf68:	e037883a 	mov	sp,fp
8114cf6c:	df000017 	ldw	fp,0(sp)
8114cf70:	dec00104 	addi	sp,sp,4
8114cf74:	f800283a 	ret

8114cf78 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114cf78:	defffe04 	addi	sp,sp,-8
8114cf7c:	de00012e 	bgeu	sp,et,8114cf84 <OSTimeTickHook+0xc>
8114cf80:	003b68fa 	trap	3
8114cf84:	dfc00115 	stw	ra,4(sp)
8114cf88:	df000015 	stw	fp,0(sp)
8114cf8c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114cf90:	d0a0b60b 	ldhu	r2,-32040(gp)
8114cf94:	10800044 	addi	r2,r2,1
8114cf98:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114cf9c:	d0a0b60b 	ldhu	r2,-32040(gp)
8114cfa0:	10bfffcc 	andi	r2,r2,65535
8114cfa4:	10807d30 	cmpltui	r2,r2,500
8114cfa8:	1000021e 	bne	r2,zero,8114cfb4 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114cfac:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114cfb0:	11438c80 	call	811438c8 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114cfb4:	0001883a 	nop
8114cfb8:	e037883a 	mov	sp,fp
8114cfbc:	dfc00117 	ldw	ra,4(sp)
8114cfc0:	df000017 	ldw	fp,0(sp)
8114cfc4:	dec00204 	addi	sp,sp,8
8114cfc8:	f800283a 	ret

8114cfcc <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114cfcc:	deffff04 	addi	sp,sp,-4
8114cfd0:	de00012e 	bgeu	sp,et,8114cfd8 <OSInitHookBegin+0xc>
8114cfd4:	003b68fa 	trap	3
8114cfd8:	df000015 	stw	fp,0(sp)
8114cfdc:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114cfe0:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114cfe4:	0001883a 	nop
8114cfe8:	e037883a 	mov	sp,fp
8114cfec:	df000017 	ldw	fp,0(sp)
8114cff0:	dec00104 	addi	sp,sp,4
8114cff4:	f800283a 	ret

8114cff8 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114cff8:	deffff04 	addi	sp,sp,-4
8114cffc:	de00012e 	bgeu	sp,et,8114d004 <OSInitHookEnd+0xc>
8114d000:	003b68fa 	trap	3
8114d004:	df000015 	stw	fp,0(sp)
8114d008:	d839883a 	mov	fp,sp
}
8114d00c:	0001883a 	nop
8114d010:	e037883a 	mov	sp,fp
8114d014:	df000017 	ldw	fp,0(sp)
8114d018:	dec00104 	addi	sp,sp,4
8114d01c:	f800283a 	ret

8114d020 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114d020:	deffff04 	addi	sp,sp,-4
8114d024:	de00012e 	bgeu	sp,et,8114d02c <OSTaskIdleHook+0xc>
8114d028:	003b68fa 	trap	3
8114d02c:	df000015 	stw	fp,0(sp)
8114d030:	d839883a 	mov	fp,sp
}
8114d034:	0001883a 	nop
8114d038:	e037883a 	mov	sp,fp
8114d03c:	df000017 	ldw	fp,0(sp)
8114d040:	dec00104 	addi	sp,sp,4
8114d044:	f800283a 	ret

8114d048 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114d048:	defffe04 	addi	sp,sp,-8
8114d04c:	de00012e 	bgeu	sp,et,8114d054 <OSTCBInitHook+0xc>
8114d050:	003b68fa 	trap	3
8114d054:	df000115 	stw	fp,4(sp)
8114d058:	df000104 	addi	fp,sp,4
8114d05c:	e13fff15 	stw	r4,-4(fp)
}
8114d060:	0001883a 	nop
8114d064:	e037883a 	mov	sp,fp
8114d068:	df000017 	ldw	fp,0(sp)
8114d06c:	dec00104 	addi	sp,sp,4
8114d070:	f800283a 	ret

8114d074 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114d074:	defffe04 	addi	sp,sp,-8
8114d078:	de00012e 	bgeu	sp,et,8114d080 <alt_exception_cause_generated_bad_addr+0xc>
8114d07c:	003b68fa 	trap	3
8114d080:	df000115 	stw	fp,4(sp)
8114d084:	df000104 	addi	fp,sp,4
8114d088:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114d08c:	e0bfff17 	ldw	r2,-4(fp)
8114d090:	10bffe84 	addi	r2,r2,-6
8114d094:	10c00428 	cmpgeui	r3,r2,16
8114d098:	18001a1e 	bne	r3,zero,8114d104 <alt_exception_cause_generated_bad_addr+0x90>
8114d09c:	100690ba 	slli	r3,r2,2
8114d0a0:	00a04574 	movhi	r2,33045
8114d0a4:	10b42d04 	addi	r2,r2,-12108
8114d0a8:	1885883a 	add	r2,r3,r2
8114d0ac:	10800017 	ldw	r2,0(r2)
8114d0b0:	1000683a 	jmp	r2
8114d0b4:	8114d0f4 	orhi	r4,r16,21315
8114d0b8:	8114d0f4 	orhi	r4,r16,21315
8114d0bc:	8114d104 	addi	r4,r16,21316
8114d0c0:	8114d104 	addi	r4,r16,21316
8114d0c4:	8114d104 	addi	r4,r16,21316
8114d0c8:	8114d0f4 	orhi	r4,r16,21315
8114d0cc:	8114d0fc 	xorhi	r4,r16,21315
8114d0d0:	8114d104 	addi	r4,r16,21316
8114d0d4:	8114d0f4 	orhi	r4,r16,21315
8114d0d8:	8114d0f4 	orhi	r4,r16,21315
8114d0dc:	8114d104 	addi	r4,r16,21316
8114d0e0:	8114d0f4 	orhi	r4,r16,21315
8114d0e4:	8114d0fc 	xorhi	r4,r16,21315
8114d0e8:	8114d104 	addi	r4,r16,21316
8114d0ec:	8114d104 	addi	r4,r16,21316
8114d0f0:	8114d0f4 	orhi	r4,r16,21315
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114d0f4:	00800044 	movi	r2,1
8114d0f8:	00000306 	br	8114d108 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114d0fc:	0005883a 	mov	r2,zero
8114d100:	00000106 	br	8114d108 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114d104:	0005883a 	mov	r2,zero
  }
}
8114d108:	e037883a 	mov	sp,fp
8114d10c:	df000017 	ldw	fp,0(sp)
8114d110:	dec00104 	addi	sp,sp,4
8114d114:	f800283a 	ret

8114d118 <exit>:
8114d118:	defffe04 	addi	sp,sp,-8
8114d11c:	000b883a 	mov	r5,zero
8114d120:	de00012e 	bgeu	sp,et,8114d128 <exit+0x10>
8114d124:	003b68fa 	trap	3
8114d128:	dc000015 	stw	r16,0(sp)
8114d12c:	dfc00115 	stw	ra,4(sp)
8114d130:	2021883a 	mov	r16,r4
8114d134:	114d2c00 	call	8114d2c0 <__call_exitprocs>
8114d138:	00a04574 	movhi	r2,33045
8114d13c:	10945b04 	addi	r2,r2,20844
8114d140:	11000017 	ldw	r4,0(r2)
8114d144:	20800f17 	ldw	r2,60(r4)
8114d148:	10000126 	beq	r2,zero,8114d150 <exit+0x38>
8114d14c:	103ee83a 	callr	r2
8114d150:	8009883a 	mov	r4,r16
8114d154:	114d4480 	call	8114d448 <_exit>

8114d158 <memcmp>:
8114d158:	01c000c4 	movi	r7,3
8114d15c:	3980192e 	bgeu	r7,r6,8114d1c4 <memcmp+0x6c>
8114d160:	2144b03a 	or	r2,r4,r5
8114d164:	11c4703a 	and	r2,r2,r7
8114d168:	10000f26 	beq	r2,zero,8114d1a8 <memcmp+0x50>
8114d16c:	20800003 	ldbu	r2,0(r4)
8114d170:	28c00003 	ldbu	r3,0(r5)
8114d174:	10c0151e 	bne	r2,r3,8114d1cc <memcmp+0x74>
8114d178:	31bfff84 	addi	r6,r6,-2
8114d17c:	01ffffc4 	movi	r7,-1
8114d180:	00000406 	br	8114d194 <memcmp+0x3c>
8114d184:	20800003 	ldbu	r2,0(r4)
8114d188:	28c00003 	ldbu	r3,0(r5)
8114d18c:	31bfffc4 	addi	r6,r6,-1
8114d190:	10c00e1e 	bne	r2,r3,8114d1cc <memcmp+0x74>
8114d194:	21000044 	addi	r4,r4,1
8114d198:	29400044 	addi	r5,r5,1
8114d19c:	31fff91e 	bne	r6,r7,8114d184 <__reset+0xfb12d184>
8114d1a0:	0005883a 	mov	r2,zero
8114d1a4:	f800283a 	ret
8114d1a8:	20c00017 	ldw	r3,0(r4)
8114d1ac:	28800017 	ldw	r2,0(r5)
8114d1b0:	18bfee1e 	bne	r3,r2,8114d16c <__reset+0xfb12d16c>
8114d1b4:	31bfff04 	addi	r6,r6,-4
8114d1b8:	21000104 	addi	r4,r4,4
8114d1bc:	29400104 	addi	r5,r5,4
8114d1c0:	39bff936 	bltu	r7,r6,8114d1a8 <__reset+0xfb12d1a8>
8114d1c4:	303fe91e 	bne	r6,zero,8114d16c <__reset+0xfb12d16c>
8114d1c8:	003ff506 	br	8114d1a0 <__reset+0xfb12d1a0>
8114d1cc:	10c5c83a 	sub	r2,r2,r3
8114d1d0:	f800283a 	ret

8114d1d4 <strncpy>:
8114d1d4:	2906b03a 	or	r3,r5,r4
8114d1d8:	18c000cc 	andi	r3,r3,3
8114d1dc:	2005883a 	mov	r2,r4
8114d1e0:	18002c1e 	bne	r3,zero,8114d294 <strncpy+0xc0>
8114d1e4:	010000c4 	movi	r4,3
8114d1e8:	21802a2e 	bgeu	r4,r6,8114d294 <strncpy+0xc0>
8114d1ec:	033fbff4 	movhi	r12,65279
8114d1f0:	02e02074 	movhi	r11,32897
8114d1f4:	633fbfc4 	addi	r12,r12,-257
8114d1f8:	5ae02004 	addi	r11,r11,-32640
8114d1fc:	100f883a 	mov	r7,r2
8114d200:	2a000017 	ldw	r8,0(r5)
8114d204:	3815883a 	mov	r10,r7
8114d208:	4313883a 	add	r9,r8,r12
8114d20c:	0206303a 	nor	r3,zero,r8
8114d210:	48c6703a 	and	r3,r9,r3
8114d214:	1ac6703a 	and	r3,r3,r11
8114d218:	1800261e 	bne	r3,zero,8114d2b4 <strncpy+0xe0>
8114d21c:	39c00104 	addi	r7,r7,4
8114d220:	52000015 	stw	r8,0(r10)
8114d224:	31bfff04 	addi	r6,r6,-4
8114d228:	3811883a 	mov	r8,r7
8114d22c:	29400104 	addi	r5,r5,4
8114d230:	21bff336 	bltu	r4,r6,8114d200 <__reset+0xfb12d200>
8114d234:	30001e26 	beq	r6,zero,8114d2b0 <strncpy+0xdc>
8114d238:	29c00003 	ldbu	r7,0(r5)
8114d23c:	31bfffc4 	addi	r6,r6,-1
8114d240:	40c00044 	addi	r3,r8,1
8114d244:	41c00005 	stb	r7,0(r8)
8114d248:	39c03fcc 	andi	r7,r7,255
8114d24c:	39c0201c 	xori	r7,r7,128
8114d250:	39ffe004 	addi	r7,r7,-128
8114d254:	29400044 	addi	r5,r5,1
8114d258:	38001026 	beq	r7,zero,8114d29c <strncpy+0xc8>
8114d25c:	1811883a 	mov	r8,r3
8114d260:	00000906 	br	8114d288 <strncpy+0xb4>
8114d264:	29c00003 	ldbu	r7,0(r5)
8114d268:	31bfffc4 	addi	r6,r6,-1
8114d26c:	29400044 	addi	r5,r5,1
8114d270:	41c00005 	stb	r7,0(r8)
8114d274:	39c03fcc 	andi	r7,r7,255
8114d278:	39c0201c 	xori	r7,r7,128
8114d27c:	39ffe004 	addi	r7,r7,-128
8114d280:	1811883a 	mov	r8,r3
8114d284:	38000526 	beq	r7,zero,8114d29c <strncpy+0xc8>
8114d288:	18c00044 	addi	r3,r3,1
8114d28c:	303ff51e 	bne	r6,zero,8114d264 <__reset+0xfb12d264>
8114d290:	f800283a 	ret
8114d294:	1011883a 	mov	r8,r2
8114d298:	003fe606 	br	8114d234 <__reset+0xfb12d234>
8114d29c:	30000726 	beq	r6,zero,8114d2bc <strncpy+0xe8>
8114d2a0:	198d883a 	add	r6,r3,r6
8114d2a4:	18000005 	stb	zero,0(r3)
8114d2a8:	18c00044 	addi	r3,r3,1
8114d2ac:	19bffd1e 	bne	r3,r6,8114d2a4 <__reset+0xfb12d2a4>
8114d2b0:	f800283a 	ret
8114d2b4:	3811883a 	mov	r8,r7
8114d2b8:	003fdf06 	br	8114d238 <__reset+0xfb12d238>
8114d2bc:	f800283a 	ret

8114d2c0 <__call_exitprocs>:
8114d2c0:	defff504 	addi	sp,sp,-44
8114d2c4:	de00012e 	bgeu	sp,et,8114d2cc <__call_exitprocs+0xc>
8114d2c8:	003b68fa 	trap	3
8114d2cc:	df000915 	stw	fp,36(sp)
8114d2d0:	dd400615 	stw	r21,24(sp)
8114d2d4:	dc800315 	stw	r18,12(sp)
8114d2d8:	dfc00a15 	stw	ra,40(sp)
8114d2dc:	ddc00815 	stw	r23,32(sp)
8114d2e0:	dd800715 	stw	r22,28(sp)
8114d2e4:	dd000515 	stw	r20,20(sp)
8114d2e8:	dcc00415 	stw	r19,16(sp)
8114d2ec:	dc400215 	stw	r17,8(sp)
8114d2f0:	dc000115 	stw	r16,4(sp)
8114d2f4:	d9000015 	stw	r4,0(sp)
8114d2f8:	2839883a 	mov	fp,r5
8114d2fc:	04800044 	movi	r18,1
8114d300:	057fffc4 	movi	r21,-1
8114d304:	00a04574 	movhi	r2,33045
8114d308:	10945b04 	addi	r2,r2,20844
8114d30c:	12000017 	ldw	r8,0(r2)
8114d310:	45005217 	ldw	r20,328(r8)
8114d314:	44c05204 	addi	r19,r8,328
8114d318:	a0001c26 	beq	r20,zero,8114d38c <__call_exitprocs+0xcc>
8114d31c:	a0800117 	ldw	r2,4(r20)
8114d320:	15ffffc4 	addi	r23,r2,-1
8114d324:	b8000d16 	blt	r23,zero,8114d35c <__call_exitprocs+0x9c>
8114d328:	14000044 	addi	r16,r2,1
8114d32c:	8421883a 	add	r16,r16,r16
8114d330:	8421883a 	add	r16,r16,r16
8114d334:	84402004 	addi	r17,r16,128
8114d338:	a463883a 	add	r17,r20,r17
8114d33c:	a421883a 	add	r16,r20,r16
8114d340:	e0001e26 	beq	fp,zero,8114d3bc <__call_exitprocs+0xfc>
8114d344:	80804017 	ldw	r2,256(r16)
8114d348:	e0801c26 	beq	fp,r2,8114d3bc <__call_exitprocs+0xfc>
8114d34c:	bdffffc4 	addi	r23,r23,-1
8114d350:	843fff04 	addi	r16,r16,-4
8114d354:	8c7fff04 	addi	r17,r17,-4
8114d358:	bd7ff91e 	bne	r23,r21,8114d340 <__reset+0xfb12d340>
8114d35c:	00800034 	movhi	r2,0
8114d360:	10800004 	addi	r2,r2,0
8114d364:	10000926 	beq	r2,zero,8114d38c <__call_exitprocs+0xcc>
8114d368:	a0800117 	ldw	r2,4(r20)
8114d36c:	1000301e 	bne	r2,zero,8114d430 <__call_exitprocs+0x170>
8114d370:	a0800017 	ldw	r2,0(r20)
8114d374:	10003226 	beq	r2,zero,8114d440 <__call_exitprocs+0x180>
8114d378:	a009883a 	mov	r4,r20
8114d37c:	98800015 	stw	r2,0(r19)
8114d380:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114d384:	9d000017 	ldw	r20,0(r19)
8114d388:	a03fe41e 	bne	r20,zero,8114d31c <__reset+0xfb12d31c>
8114d38c:	dfc00a17 	ldw	ra,40(sp)
8114d390:	df000917 	ldw	fp,36(sp)
8114d394:	ddc00817 	ldw	r23,32(sp)
8114d398:	dd800717 	ldw	r22,28(sp)
8114d39c:	dd400617 	ldw	r21,24(sp)
8114d3a0:	dd000517 	ldw	r20,20(sp)
8114d3a4:	dcc00417 	ldw	r19,16(sp)
8114d3a8:	dc800317 	ldw	r18,12(sp)
8114d3ac:	dc400217 	ldw	r17,8(sp)
8114d3b0:	dc000117 	ldw	r16,4(sp)
8114d3b4:	dec00b04 	addi	sp,sp,44
8114d3b8:	f800283a 	ret
8114d3bc:	a0800117 	ldw	r2,4(r20)
8114d3c0:	80c00017 	ldw	r3,0(r16)
8114d3c4:	10bfffc4 	addi	r2,r2,-1
8114d3c8:	15c01426 	beq	r2,r23,8114d41c <__call_exitprocs+0x15c>
8114d3cc:	80000015 	stw	zero,0(r16)
8114d3d0:	183fde26 	beq	r3,zero,8114d34c <__reset+0xfb12d34c>
8114d3d4:	95c8983a 	sll	r4,r18,r23
8114d3d8:	a0806217 	ldw	r2,392(r20)
8114d3dc:	a5800117 	ldw	r22,4(r20)
8114d3e0:	2084703a 	and	r2,r4,r2
8114d3e4:	10000b26 	beq	r2,zero,8114d414 <__call_exitprocs+0x154>
8114d3e8:	a0806317 	ldw	r2,396(r20)
8114d3ec:	2088703a 	and	r4,r4,r2
8114d3f0:	20000c1e 	bne	r4,zero,8114d424 <__call_exitprocs+0x164>
8114d3f4:	89400017 	ldw	r5,0(r17)
8114d3f8:	d9000017 	ldw	r4,0(sp)
8114d3fc:	183ee83a 	callr	r3
8114d400:	a0800117 	ldw	r2,4(r20)
8114d404:	15bfbf1e 	bne	r2,r22,8114d304 <__reset+0xfb12d304>
8114d408:	98800017 	ldw	r2,0(r19)
8114d40c:	153fcf26 	beq	r2,r20,8114d34c <__reset+0xfb12d34c>
8114d410:	003fbc06 	br	8114d304 <__reset+0xfb12d304>
8114d414:	183ee83a 	callr	r3
8114d418:	003ff906 	br	8114d400 <__reset+0xfb12d400>
8114d41c:	a5c00115 	stw	r23,4(r20)
8114d420:	003feb06 	br	8114d3d0 <__reset+0xfb12d3d0>
8114d424:	89000017 	ldw	r4,0(r17)
8114d428:	183ee83a 	callr	r3
8114d42c:	003ff406 	br	8114d400 <__reset+0xfb12d400>
8114d430:	a0800017 	ldw	r2,0(r20)
8114d434:	a027883a 	mov	r19,r20
8114d438:	1029883a 	mov	r20,r2
8114d43c:	003fb606 	br	8114d318 <__reset+0xfb12d318>
8114d440:	0005883a 	mov	r2,zero
8114d444:	003ffb06 	br	8114d434 <__reset+0xfb12d434>

8114d448 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114d448:	defffc04 	addi	sp,sp,-16
8114d44c:	de00012e 	bgeu	sp,et,8114d454 <_exit+0xc>
8114d450:	003b68fa 	trap	3
8114d454:	dfc00315 	stw	ra,12(sp)
8114d458:	df000215 	stw	fp,8(sp)
8114d45c:	df000204 	addi	fp,sp,8
8114d460:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114d464:	d0a01217 	ldw	r2,-32696(gp)
8114d468:	10800058 	cmpnei	r2,r2,1
8114d46c:	1000031e 	bne	r2,zero,8114d47c <_exit+0x34>
8114d470:	01204574 	movhi	r4,33045
8114d474:	210cde04 	addi	r4,r4,13176
8114d478:	1138f580 	call	81138f58 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114d47c:	d0a01217 	ldw	r2,-32696(gp)
8114d480:	10800058 	cmpnei	r2,r2,1
8114d484:	1000041e 	bne	r2,zero,8114d498 <_exit+0x50>
8114d488:	e17fff17 	ldw	r5,-4(fp)
8114d48c:	01204574 	movhi	r4,33045
8114d490:	210ce904 	addi	r4,r4,13220
8114d494:	1138f580 	call	81138f58 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114d498:	d0a01217 	ldw	r2,-32696(gp)
8114d49c:	10800058 	cmpnei	r2,r2,1
8114d4a0:	1000031e 	bne	r2,zero,8114d4b0 <_exit+0x68>
8114d4a4:	01204574 	movhi	r4,33045
8114d4a8:	210cf404 	addi	r4,r4,13264
8114d4ac:	1138f580 	call	81138f58 <alt_log_printf_proc>
  ALT_OS_STOP();
8114d4b0:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114d4b4:	d0a01217 	ldw	r2,-32696(gp)
8114d4b8:	10800058 	cmpnei	r2,r2,1
8114d4bc:	1000031e 	bne	r2,zero,8114d4cc <_exit+0x84>
8114d4c0:	01204574 	movhi	r4,33045
8114d4c4:	210cfe04 	addi	r4,r4,13304
8114d4c8:	1138f580 	call	81138f58 <alt_log_printf_proc>
8114d4cc:	e0bfff17 	ldw	r2,-4(fp)
8114d4d0:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114d4d4:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114d4d8:	10000226 	beq	r2,zero,8114d4e4 <_exit+0x9c>
    ALT_SIM_FAIL();
8114d4dc:	002af070 	cmpltui	zero,zero,43969
8114d4e0:	00000106 	br	8114d4e8 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114d4e4:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114d4e8:	d0a01217 	ldw	r2,-32696(gp)
8114d4ec:	10800058 	cmpnei	r2,r2,1
8114d4f0:	1000031e 	bne	r2,zero,8114d500 <_exit+0xb8>
8114d4f4:	01204574 	movhi	r4,33045
8114d4f8:	210d0804 	addi	r4,r4,13344
8114d4fc:	1138f580 	call	81138f58 <alt_log_printf_proc>
  while (1);
8114d500:	003fff06 	br	8114d500 <__reset+0xfb12d500>
