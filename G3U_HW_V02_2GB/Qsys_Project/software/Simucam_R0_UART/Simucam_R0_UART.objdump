
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x000544f4 memsz 0x0006e764 flags rwx
    LOAD off    0x00056000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00056000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004c5d0  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005ef4  8114c82c  8114c82c  0004d82c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81152720  81152720  00053720  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a270  81154514  81154514  00055514  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116e784  8116e784  00056000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00056000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00056000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d30  00000000  00000000  00056028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00071216  00000000  00000000  00057d58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016627  00000000  00000000  000c8f6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002307f  00000000  00000000  000df595  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009964  00000000  00000000  00102614  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cb1c  00000000  00000000  0010bf78  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026df9  00000000  00000000  00118a94  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013f890  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002378  00000000  00000000  0013f8d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0014e051  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014e057  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0014e063  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0014e064  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0014e065  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014e069  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0014e06d  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014e071  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0014e07c  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014e086  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014e090  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000043  00000000  00000000  0014e0a1  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0014e0e4  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114c82c l    d  .rodata	00000000 .rodata
81152720 l    d  .rwdata	00000000 .rwdata
81154514 l    d  .bss	00000000 .bss
8116e784 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811047f0 l     F .text	00000050 uliCommReadReg
8110479c l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105030 l     F .text	00000050 uliDpktReadReg
81104fdc l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81154538 l     O .bss	00000004 viCh1HoldContext
8115453c l     O .bss	00000004 viCh2HoldContext
81154540 l     O .bss	00000004 viCh3HoldContext
81154544 l     O .bss	00000004 viCh4HoldContext
81154548 l     O .bss	00000004 viCh5HoldContext
8115454c l     O .bss	00000004 viCh6HoldContext
81154550 l     O .bss	00000004 viCh7HoldContext
81154554 l     O .bss	00000004 viCh8HoldContext
81106b24 l     F .text	00000054 vFeebWriteReg
81106b78 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
81154558 l     O .bss	00000004 viCh1HoldContext
8115455c l     O .bss	00000004 viCh2HoldContext
81154560 l     O .bss	00000004 viCh3HoldContext
81154564 l     O .bss	00000004 viCh4HoldContext
81154568 l     O .bss	00000004 viCh5HoldContext
8115456c l     O .bss	00000004 viCh6HoldContext
81154570 l     O .bss	00000004 viCh7HoldContext
81154574 l     O .bss	00000004 viCh8HoldContext
81109db8 l     F .text	00000054 vRmapWriteReg
81109e5c l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110a790 l     F .text	00000050 uliSpwcReadReg
8110a73c l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8115443c l     O .rwdata	00000001 ucIoValue
8110a990 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b280 l     F .text	0000013c msgdma_write_extended_descriptor
8110b3bc l     F .text	00000164 msgdma_construct_extended_descriptor
8110b520 l     F .text	00000348 msgdma_descriptor_async_transfer
8110b868 l     F .text	00000490 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110c478 l     F .text	00000054 vRstcWriteReg
8110c4cc l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8115457c l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81154584 l     O .bss	00000004 pxNFee.5687
81154588 l     O .bss	00000004 incrementador.5692
8115458c l     O .bss	00000004 tCodFeeTask.5690
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81154592 l     O .bss	00000004 xRAckLocal.5617
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81154598 l     O .bss	00000004 bDmaBack.5658
8115459c l     O .bss	00000001 ucWhoGetDMA.5659
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8115459e l     O .bss	00000004 xSAckLocal.5602
00000000 l    df *ABS*	00000000 parser_comm_task.c
81154718 l     O .bss	0000004c PreParsedLocal.5655
81154764 l     O .bss	00000054 xTcPusL.5654
00000000 l    df *ABS*	00000000 receiver_uart_task.c
811547b8 l     O .bss	0000004c xPreParsedReader.5647
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81154804 l     O .bss	00000054 xPusLocal.5890
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81150032 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
81151b61 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81152720 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81123f78 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
81151d2e l     O .rodata	00000010 zeroes.4389
81151d3e l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81151d4e l     O .rodata	00000010 zeroes.4404
81128bf0 l     F .text	000000c4 __sbprintf
81151d5e l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81151d76 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8112a8d8 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112c428 l     F .text	00000008 __fp_unlock
8112c43c l     F .text	000001a4 __sinit.part.1
8112c5e0 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81152f6c l     O .rwdata	00000020 lc_ctype_charset
81152f4c l     O .rwdata	00000020 lc_message_charset
81152f8c l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
81151db4 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112f450 l     F .text	0000006c sulp
81151efc l     O .rodata	00000014 fpi.2737
81151f10 l     O .rodata	00000028 tinytens
81151ee8 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81151f48 l     O .rodata	00000010 blanks.4332
81151f38 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81132ac0 l     F .text	00000104 __sprint_r.part.0
81151f68 l     O .rodata	00000010 blanks.4348
81151f58 l     O .rodata	00000010 zeroes.4349
8113405c l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
81134510 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
811376ec l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81137830 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81137864 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81137ae8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81137be0 l       .text	00000000 tx_next_char
81137c08 l       .text	00000000 end_tx
81137be8 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
811386e4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81138960 l     F .text	00000044 alt_get_errno
811389a4 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81138bcc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81154484 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
8113916c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81154490 l     O .rwdata	00000004 lockid
81154660 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81154494 l     O .rwdata	00000004 lockid
81154668 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8113abf8 l     F .text	00000050 OS_InitMisc
8113ac48 l     F .text	00000074 OS_InitRdyList
8113adcc l     F .text	000000ec OS_InitTCBList
8113ab10 l     F .text	000000e8 OS_InitEventList
8113acbc l     F .text	00000088 OS_InitTaskIdle
8113ad44 l     F .text	00000088 OS_InitTaskStat
8113b05c l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113ce74 l     F .text	000000fc OS_FlagTaskRdy
8113cc24 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113e760 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81143190 l     F .text	00000044 OSTmr_Lock
81142c30 l     F .text	00000074 OSTmr_Alloc
811431d4 l     F .text	0000003c OSTmr_Unlock
81143094 l     F .text	000000fc OSTmr_Unlink
81142ca4 l     F .text	000000a4 OSTmr_Free
81142f44 l     F .text	00000150 OSTmr_Link
81142ebc l     F .text	00000088 OSTmr_InitTask
81143210 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81143320 l     F .text	0000003c alt_dev_reg
81153208 l     O .rwdata	0000106c jtag_uart_0
81154274 l     O .rwdata	000000d0 rs232_uart
81154344 l     O .rwdata	00000064 dma_DDR_M1
811543a8 l     O .rwdata	00000064 dma_DDR_M2
8115440c l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81147bb0 l     F .text	000002bc altera_avalon_jtag_uart_irq
81147e6c l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81148670 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81148a08 l     F .text	000000a4 altera_avalon_uart_irq
81148aac l     F .text	00000140 altera_avalon_uart_rxirq
81148bec l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81148df4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
811490a8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
8114932c l     F .text	00000044 alt_get_errno
81149370 l     F .text	0000009c alt_msgdma_write_standard_descriptor
8114940c l     F .text	00000134 alt_msgdma_write_extended_descriptor
81149540 l     F .text	0000018c alt_msgdma_irq
811496cc l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81149760 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
811498bc l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81149bfc l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
8114a304 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
8114a3b0 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114b57c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114bbc0 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81154710 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81154714 g     O .bss	00000004 alt_instruction_exception_handler
81107088 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81154f98 g     O .bss	00001000 vFeeTask0_stk
8111cca4 g     F .text	00000064 vFailDeleteInitialization
8111b47c g     F .text	00000e78 vLoadDebugConfs
811546e4 g     O .bss	00000004 aux_status_register
81155f98 g     O .bss	00001000 vInAckHandlerTask_stk
8114b338 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811073d0 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110cb0c g     F .text	0000004c vSyncInitIrq
81117c50 g     F .text	00000284 vCheckRetransmission128
8112ead4 g     F .text	0000007c _mprec_log10
8111e7a8 g     F .text	0000006c vFailRequestDMAFromIRQ
8110cd14 g     F .text	00000040 bSyncSetMbt
8110ab74 g     F .text	00000108 I2C_Read
811544e2 g     O .rwdata	00000002 OSTaskNameSize
811545a8 g     O .bss	00000004 xWaitSyncQFee
81156f98 g     O .bss	00000260 xBuffer64
8112ebc8 g     F .text	0000008c __any_on
8112d59c g     F .text	0000005c _isatty_r
81151dc0 g     O .rodata	00000028 __mprec_tinytens
81107378 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
81138804 g     F .text	0000015c alt_main
811063e0 g     F .text	00000078 bFeebGetRightBufferEmpty
81123e9c g     F .text	000000c8 _puts_r
81105628 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81154670 g     O .bss	00000004 OSTmrFreeList
8116e684 g     O .bss	00000100 alt_irq
8112d70c g     F .text	00000068 _lseek_r
8111fbe4 g     F .text	00000030 vChangeDefaultAutoResetSync
8113d6d4 g     F .text	000000d4 OS_MemInit
8111e73c g     F .text	0000006c vFailRequestDMA
81106458 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
8111a70c g     F .text	00000a40 vLoadDefaultETHConf
811128c8 g     F .text	0000014c bCheckInAck64
811571f8 g     O .bss	00000150 xPus
81142170 g     F .text	00000068 OSTimeSet
811167f4 g     F .text	000000ac vPusType250run
8112c7e0 g     F .text	000000ac __sflags
8111df90 g     F .text	00000080 vCoudlNotCreateNFee2Task
8111e46c g     F .text	00000064 vCouldNotGetMutexMebPus
81137390 g     F .text	00000088 .hidden __eqdf2
81116f90 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111fad0 g     F .text	00000034 vLoadDefaultSyncSource
8111c5bc g     F .text	00000064 vFailCreateMutexDMA
81143820 g     F .text	000001ac Check_for_Master_Boot_Record
81168098 g     O .bss	00000010 OSTmrWheelTbl
81107470 g     F .text	00000050 uliRmapCh3WriteCmdAddress
8114a0c4 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81157348 g     O .bss	00000020 xFeeQueueTBL3
8113985c g     F .text	00000594 OSEventPendMulti
811545ac g     O .bss	00000004 xNfeeSchedule
8116e784 g       *ABS*	00000000 __alt_heap_start
8114c1f8 g     F .text	0000002c OSTaskCreateHook
81147698 g     F .text	000001c4 alt_up_sd_card_fclose
811545b0 g     O .bss	00000004 xSemCountBuffer64
81104560 g     F .text	0000016c bCommSetGlobalIrqEn
81107874 g     F .text	00000088 bRmapGetIrqControl
81154579 g     O .bss	00000001 SspdConfigControl
8110d130 g     F .text	00000054 bSyncCtrReset
811544ba g     O .rwdata	00000002 OSMboxEn
81110848 g     F .text	00000584 vQCmdFeeRMAPWaitingSync
81120670 g     F .text	000000a4 aatoh
81139e54 g     F .text	00000054 OSIntEnter
8113517c g     F .text	000000a4 _wcrtomb_r
81105534 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111cbdc g     F .text	00000064 vFailReceiverCreate
811545b4 g     O .bss	00000004 xQMaskDataCtrl
811051d0 g     F .text	00000038 vFeebCh2HandleIrq
81124404 g     F .text	00000064 __sseek
8112c790 g     F .text	00000010 __sinit
8110bdb8 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8112a558 g     F .text	00000148 __swbuf_r
81118428 g     F .text	00000470 bResourcesInitRTOS
8110a2dc g     F .text	000000f4 bSpwcGetLinkError
811544ca g     O .rwdata	00000002 OSQEn
8110fbe0 g     F .text	00000684 vQCmdFeeRMAPinStandBy
81106dd8 g     F .text	00000038 vRmapCh4HandleIrq
8112d628 g     F .text	00000084 _setlocale_r
81157368 g     O .bss	00000020 SyncTBL2
81154440 g     O .rwdata	00000004 LedsPainelControl
81154880 g     O .bss	00000100 cDebugBuffer
8112c5e8 g     F .text	00000070 __sfmoreglue
81132aa8 g     F .text	00000018 ungetc
81105838 g     F .text	000000d4 bFeebCh1SetBufferSize
81139518 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114c278 g     F .text	00000028 OSTaskStatHook
81116dec g     F .text	00000088 vSendCmdQToNFeeCTRL
8111fb40 g     F .text	00000030 vChangeDefaultSyncSource
81154674 g     O .bss	00000001 OSLockNesting
81154678 g     O .bss	00000004 OSTmrSemSignal
8111ecdc g     F .text	00000284 vNFeeStructureInit
811545b8 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112f4bc g     F .text	00001600 _strtod_r
811545bc g     O .bss	00000004 xSemCountSenderACK
81120840 g     F .text	00000448 .hidden __divsf3
81154708 g     O .bss	00000004 current_sector_modified
81154508 g     O .rwdata	00000002 OSDataSize
8115467c g     O .bss	00000001 OSRunning
8110a5b8 g     F .text	00000184 bSpwcInitCh
811384cc g     F .text	00000064 alt_log_jtag_uart_isr_proc
81157388 g     O .bss	00001000 senderTask_stk
81108368 g     F .text	00000094 bRmapGetMemConfigStat
811545c0 g     O .bss	00000004 fp
81158388 g     O .bss	00000048 xNfeeScheduleTBL
81112780 g     F .text	00000148 bCheckInAck128
8112da9c g     F .text	0000015c memmove
8114c2f4 g     F .text	0000002c OSInitHookBegin
8110d5cc g     F .text	00000074 bSyncCtrCh8OutEnable
81110f38 g     F .text	00000098 bEnableDbBuffer
81154500 g     O .rwdata	00000002 OSTmrSize
8112c778 g     F .text	00000018 _cleanup
81120000 g     F .text	00000040 siCloseFile
811069a0 g     F .text	00000184 bFeebInitCh
8112dbf8 g     F .text	000000b0 _Balloc
8111fb70 g     F .text	00000038 vLoadDefaultAutoResetSync
81107984 g     F .text	000000d8 bRmapSetCodecConfig
81146274 g     F .text	000000cc alt_up_sd_card_is_Present
8114a004 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8115451c g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
81143548 g     F .text	00000054 Save_Modified_Sector
81105788 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81154680 g     O .bss	00000004 OSIdleCtr
8115463c g     O .bss	00000001 alt_log_write_on_flag
8110a7e0 g     F .text	0000003c bEnableIsoDrivers
811212b0 g     F .text	000000dc .hidden __gtdf2
8114bf88 g     F .text	0000002c altera_nios2_gen2_irq_init
8114c070 g       .text	00000000 OSStartTsk
8110ce88 g     F .text	00000070 bSyncSetNCycles
8113b3cc g     F .text	000002dc OS_TCBInit
8115463f g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111f758 g     F .text	00000078 vInitSimucamBasicHW
811583d0 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110d4e4 g     F .text	00000074 bSyncCtrCh6OutEnable
8110aef0 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81154700 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81154684 g     O .bss	00000002 OSTmrUsed
811545c4 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
811077cc g     F .text	000000a8 bRmapSetIrqControl
81105b88 g     F .text	000000d4 bFeebCh5SetBufferSize
811593d0 g     O .bss	00001000 vDataControlTask_stk
81105240 g     F .text	00000038 vFeebCh4HandleIrq
81154506 g     O .rwdata	00000002 OSTmrWheelTblSize
8111f400 g     F .text	0000002c cFeeSpwChannelDisable
811544a6 g     O .rwdata	00000002 OSEventSize
81154686 g     O .bss	00000001 OSPrioHighRdy
81122ef8 g     F .text	00000064 _fstat_r
8114c224 g     F .text	0000002c OSTaskDelHook
81154618 g     O .bss	00000004 errno
8110d8c0 g     F .text	0000003c uliSyncGetCtr
8112a4e8 g     F .text	0000001c __svfscanf
81124378 g     F .text	00000008 __seofread
8114c050 g       .text	00000000 OSStartHighRdy
8111ec3c g     F .text	00000028 vEvtChangeFeeControllerMode
81111184 g     F .text	00000968 vPrintConsoleNFee
811138a8 g     F .text	000000c8 bSendCmdQToNFeeInst
81106e80 g     F .text	00000038 vRmapCh7HandleIrq
81140ba0 g     F .text	000001ec OSTaskCreateExt
8116806c g     O .bss	00000011 alt_log_write_buf
81104a6c g     F .text	0000012c bDpktGetPacketConfig
81107600 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111d088 g     F .text	00000080 vFailGetCountSemaphorePreParsedBuffer
811315ec g     F .text	00001244 ___svfiprintf_internal_r
81115690 g     F .text	0000037c bPreParserV2
8113c754 g     F .text	00000068 OSFlagPendGetFlagsRdy
811544e6 g     O .rwdata	00000002 OSTaskStatStkSize
81106590 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
8113b8a0 g     F .text	00000310 OSFlagAccept
8113ee7c g     F .text	000000c0 OSQFlush
81154d80 g     O .bss	00000118 xRmap
8113e8f8 g     F .text	00000148 OSQAccept
81154650 g     O .bss	00000004 alt_argv
8115c438 g       *ABS*	00000000 _gp
8111c7cc g     F .text	00000064 vFailSendPreAckReceiverSemaphore
81139030 g     F .text	0000013c usleep
8114684c g     F .text	00000384 alt_up_sd_card_fopen
8111fe6c g     F .text	00000030 bSDcardIsPresent
81115a0c g     F .text	00000210 vSenderComTask
811463b4 g     F .text	000000d8 alt_up_sd_card_find_first
811409ec g     F .text	000001b4 OSTaskCreate
8111d288 g     F .text	00000080 vFailSendNack
811546f4 g     O .bss	00000004 command_argument_register
811404f4 g     F .text	000004f8 OSTaskChangePrio
811162f4 g     F .text	000000c4 vPusMebInTaskConfigMode
8111dbe0 g     F .text	000000a0 vCouldNotSendTMPusCommand
8115466c g     O .bss	00000004 alt_heapsem
8111f2a0 g     F .text	000000b0 vResetMemCCDFEE
8110b188 g     F .text	00000080 bSetBoardLeds
8113b6a8 g     F .text	000001f8 OSDebugInit
81140d8c g     F .text	0000034c OSTaskDel
8113d7a8 g     F .text	000001ac OSMutexAccept
8115a3d0 g     O .bss	000002b8 xSimMeb
8111f63c g     F .text	00000040 vSetTimeCode
8114abac g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
811545c8 g     O .bss	00000004 xSemCountPreParsed
81152fec g     O .rwdata	00000180 alt_fd_list
811056d8 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81153188 g     O .rwdata	0000001d alt_log_msg_alt_main
811680a8 g     O .bss	00000840 OSFlagTbl
81107110 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111c994 g     F .text	00000080 vFailGetCountSemaphoreReceiverTask
81107510 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111fa28 g     F .text	0000003c vLoadDefaultRTValue
8113a8d8 g     F .text	000000c0 OS_EventTaskRemove
8115a688 g     O .bss	00001000 vFeeTask5_stk
8115463e g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81145ac8 g     F .text	00000134 find_first_empty_record_in_root_directory
8114b66c g     F .text	00000098 alt_find_dev
81123a44 g     F .text	00000150 memcpy
81134e48 g     F .text	00000264 __hexnan
81104e68 g     F .text	00000174 bDpktInitCh
8115b688 g     O .bss	00000160 xBuffer32
811544d0 g     O .rwdata	00000002 OSRdyTblSize
811688e8 g     O .bss	000001a0 OSTmrTbl
8112c430 g     F .text	0000000c _cleanup_r
81122430 g     F .text	000000e4 .hidden __floatsidf
8111a334 g     F .text	000001a8 vSendPusTM64
8110cc84 g     F .text	0000004c ucSyncStatusErrorCode
81116efc g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111f4fc g     F .text	00000034 cFeeRMAPLogDisable
81113d60 g     F .text	00000fc0 vParserCommTask
8114bc8c g     F .text	00000084 alt_io_redirect
8111f490 g     F .text	00000034 cFeeRMAPEchoingDisable
81137418 g     F .text	000000f4 .hidden __ltdf2
8111e388 g     F .text	00000064 vFailSendPUStoMebTask
81107320 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81106054 g     F .text	000000d4 bFeebSetIrqControl
8111d960 g     F .text	00000080 vCouldNotRetransmitB128TimeoutTask
811545cc g     O .bss	00000004 xMutexReceivedACK
81103bec g     F .text	000000c4 bSdmaInitM2Dma
81154534 g     O .bss	00000004 EDpktMode
8114b034 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114b37c g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d1d8 g     F .text	00000054 bSyncCtrErrInj
8114b2dc g     F .text	0000005c alt_msgdma_register_callback
8111b14c g     F .text	00000330 vShowEthConfig
8111f7d0 g     F .text	00000030 bLogWriteSDCard
8111cd88 g     F .text	00000080 vFailSetCountSemaphorexBuffer64
81123f64 g     F .text	00000014 puts
81120080 g     F .text	000001b8 bInitSync
8114c39c g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110c9dc g     F .text	00000104 vSyncHandleIrq
811395ec g     F .text	00000128 OSEventNameGet
8110539c g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
811544b4 g     O .rwdata	00000002 OSFlagMax
8112d828 g     F .text	000000e0 mbrtowc
811456c0 g     F .text	000001b4 find_first_empty_cluster
81117018 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110d470 g     F .text	00000074 bSyncCtrCh5OutEnable
81154580 g     O .bss	00000001 vucN
8112f228 g     F .text	00000074 __fpclassifyd
8110cbe4 g     F .text	00000054 bSyncStatusExtnIrq
8112a504 g     F .text	00000054 _vfscanf_r
8113de28 g     F .text	000005a4 OSMutexPend
8112ea28 g     F .text	000000ac __ratio
811461b0 g     F .text	000000c4 alt_up_sd_card_open_dev
8111dc80 g     F .text	00000080 vWarnCouldNotgetMutexRetrans128
81139ea8 g     F .text	00000100 OSIntExit
8110cd54 g     F .text	00000040 bSyncSetBt
81134040 g     F .text	0000001c __vfiprintf_internal
8111e4d0 g     F .text	00000080 vCouldNotCreateQueueMaskNfeeCtrl
811544ee g     O .rwdata	00000002 OSTCBSize
81105358 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81154687 g     O .bss	00000001 OSPrioCur
811480e0 g     F .text	000002c4 altera_avalon_jtag_uart_read
8114a874 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81135f34 g     F .text	00000064 .hidden __udivsi3
81137b2c g     F .text	000000ac isatty
81154578 g     O .bss	00000001 LedsBoardControl
811545d0 g     O .bss	00000004 xSemCountReceivedACK
811544d4 g     O .rwdata	00000002 OSStkWidth
8112d5f8 g     F .text	00000030 iswspace
81151e10 g     O .rodata	000000c8 __mprec_tens
811544c8 g     O .rwdata	00000002 OSPtrSize
8111e814 g     F .text	0000006c vFailSendRMAPFromIRQ
8111e190 g     F .text	00000080 vCoudlNotCreateNFeeControllerTask
8112d6ac g     F .text	0000000c __locale_charset
8110d388 g     F .text	00000074 bSyncCtrCh3OutEnable
81136124 g     F .text	000000c8 .hidden __lesf2
811544a8 g     O .rwdata	00000002 OSEventTblSize
811207c4 g     F .text	0000007c .hidden __fixunsdfsi
8114bfb4 g       .text	00000000 OSCtxSw
8110ac7c g     F .text	00000160 I2C_MultipleRead
81138670 g     F .text	00000074 alt_log_system_clock
81154624 g     O .bss	00000004 __malloc_top_pad
81154688 g     O .bss	00000004 OSTCBList
81142bf0 g     F .text	00000040 OSTmrSignal
81154634 g     O .bss	00000004 alt_fd_list_lock
81131118 g     F .text	0000001c strtoul
81154458 g     O .rwdata	00000004 __mb_cur_max
8112d6dc g     F .text	0000000c _localeconv_r
81131134 g     F .text	000002e0 _strtoull_r
8110c408 g     F .text	00000070 vRstcHoldDeviceReset
8112e01c g     F .text	00000044 __i2b
8112cf40 g     F .text	000004c4 __sfvwrite_r
811449a0 g     F .text	000000c0 get_dir_divider_location
81106fbc g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81168a88 g     O .bss	00000c30 OSMemTbl
8115468c g     O .bss	00000001 OSTickStepState
81138280 g     F .text	00000060 alt_log_printf_proc
81104da4 g     F .text	000000c4 bDpktGetPixelDelay
8115b7e8 g     O .bss	00001800 vReceiverUartTask_stk
81124170 g     F .text	0000005c _sbrk_r
811545d4 g     O .bss	00000004 xSemTimeoutChecker
81144660 g     F .text	000000cc filename_to_upper_case
81154640 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
811544cc g     O .rwdata	00000002 OSQMax
81146bd0 g     F .text	00000090 alt_up_sd_card_set_attributes
8113db24 g     F .text	00000304 OSMutexDel
811696b8 g     O .bss	00001000 OSTaskStatStk
8111fe9c g     F .text	00000030 bSDcardFAT16Check
8113d2f0 g     F .text	000000f8 OSMemNameGet
8111c544 g     F .text	00000078 vFailCreateMutexSResources
811439cc g     F .text	00000284 Read_File_Record_At_Offset
8115cfe8 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
811544ac g     O .rwdata	00000002 OSFlagEn
8112ec54 g     F .text	00000068 _read_r
811544f2 g     O .rwdata	00000002 OSTimeTickHookEn
8113cf70 g     F .text	000000ac OS_FlagUnlink
8113f344 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
81154474 g     O .rwdata	00000004 alt_max_fd
8111d67c g     F .text	00000064 vFailTimeoutCheckerTaskCreate
8113af14 g     F .text	00000070 OS_MemCopy
8113af84 g     F .text	000000d8 OS_Sched
81145244 g     F .text	0000047c find_file_in_directory
811341ec g     F .text	000000f8 _fclose_r
8113d1f8 g     F .text	000000f8 OSMemGet
811413d0 g     F .text	000001bc OSTaskNameSet
8112c3f8 g     F .text	00000030 fflush
81154620 g     O .bss	00000004 __malloc_max_sbrked_mem
81154690 g     O .bss	00000004 OSCtxSwCtr
81105c5c g     F .text	000000d4 bFeebCh6SetBufferSize
8114c2a0 g     F .text	00000054 OSTimeTickHook
8115d028 g     O .bss	00001000 vOutAckHandlerTask_stk
81137960 g     F .text	00000188 alt_irq_register
811544b6 g     O .rwdata	00000002 OSFlagNameSize
81122514 g     F .text	00000118 .hidden __extendsfdf2
8113a998 g     F .text	00000108 OS_EventTaskRemoveMulti
8111de08 g     F .text	00000088 vFailCreateNFEESyncQueue
81146340 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110aa0c g     F .text	00000088 I2C_TestAdress
811361ec g     F .text	000008b4 .hidden __adddf3
81168080 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81135ff0 g     F .text	00000078 .hidden __nesf2
81106f78 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
8110510c g     F .text	0000008c usiLineTrDelayCalcPeriodNs
8113a780 g     F .text	00000158 OS_EventTaskWaitMulti
8115e028 g     O .bss	00000020 SyncTBL4
8112e7c0 g     F .text	00000114 __b2d
8114a5ac g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
811544ce g     O .rwdata	00000002 OSQSize
811358fc g     F .text	00000540 .hidden __umoddi3
81138728 g     F .text	000000dc lseek
8113fe34 g     F .text	00000214 OSSemPend
8111e3ec g     F .text	00000080 vCouldNotGetCmdQueueMeb
81107ae8 g     F .text	00000160 bRmapGetCodecStatus
8110a3d0 g     F .text	000000d0 bSpwcGetLinkStatus
81106780 g     F .text	00000088 bFeebGetWindowing
81154448 g     O .rwdata	00000004 _global_impure_ptr
8110c990 g     F .text	0000004c bSSDisplayUpdate
81144d04 g     F .text	00000540 get_home_directory_cluster_for_file
8112ecbc g     F .text	0000056c _realloc_r
811544b8 g     O .rwdata	00000002 OSLowestPrio
8116e784 g       *ABS*	00000000 __bss_end
8114bac8 g     F .text	000000f8 alt_iic_isr_register
8114c370 g     F .text	0000002c OSTCBInitHook
811544fe g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81138f20 g     F .text	00000110 alt_tick
81107650 g     F .text	0000017c vRmapInitIrq
8111c914 g     F .text	00000080 vFailGetMutexSenderTask
8110c328 g     F .text	0000006c vRstcSimucamReset
8111103c g     F .text	000000a4 bSendRequestNFeeCtrl
81151f78 g     O .rodata	00000100 __hexdig
8114b128 g     F .text	000001b4 alt_msgdma_init
8113537c g     F .text	00000580 .hidden __udivdi3
81115360 g     F .text	0000017c setPreAckSenderFreePos
81134464 g     F .text	00000024 _fputwc_r
811544a0 g     O .rwdata	00000002 OSEventEn
81151de8 g     O .rodata	00000028 __mprec_bigtens
8112ddf8 g     F .text	0000010c __s2b
811544fa g     O .rwdata	00000002 OSTmrCfgNameSize
8115e048 g     O .bss	00000020 xFeeQueueTBL4
8110ce14 g     F .text	00000074 bSyncSetPolarity
81117ed4 g     F .text	0000028c vCheckRetransmission64
8113750c g     F .text	000000b0 .hidden __floatunsidf
81154644 g     O .bss	00000004 alt_system_clock_in_sec
81138478 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111d008 g     F .text	00000080 vFailFoundBufferRetransmission
8112e4f8 g     F .text	00000060 __mcmp
8115470c g     O .bss	00000004 current_sector_index
811488a0 g     F .text	00000168 altera_avalon_uart_init
8114b404 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
81104104 g     F .text	0000045c bSdmaDmaM2Transfer
8111f67c g     F .text	00000034 vResetTimeCode
8111f3d4 g     F .text	0000002c cFeeSpwChannelEnable
8112c7b0 g     F .text	00000018 __fp_lock_all
8111ea20 g     F .text	00000064 vFailSendMsgDataCTRL
8114ba74 g     F .text	00000054 alt_ic_irq_enabled
8110aa94 g     F .text	000000e0 I2C_Write
811071c0 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
81154694 g     O .bss	00000002 OSTmrFree
8113cd8c g     F .text	000000e8 OS_FlagInit
81138e7c g     F .text	000000a4 alt_alarm_stop
811247d8 g     F .text	0000001c strtol
8115463d g     O .bss	00000001 alt_log_sys_clk_on_flag
8114239c g     F .text	00000140 OSTmrDel
81143738 g     F .text	000000e8 mark_cluster
811544dc g     O .rwdata	00000002 OSTaskIdleStkSize
81154638 g     O .bss	00000004 alt_irq_active
8113fa54 g     F .text	000000b8 OSSemAccept
81122a90 g     F .text	0000044c _fseeko_r
81118dcc g     F .text	00000354 vFillMemmoryPattern
81124554 g     F .text	00000044 strnlen
8113d504 g     F .text	000000e0 OSMemPut
8113d01c g     F .text	000001dc OSMemCreate
81154698 g     O .bss	00000004 OSIdleCtrMax
8111a4dc g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81137cc8 g     F .text	000005b8 alt_log_private_printf
81152fc4 g     O .rwdata	00000028 alt_dev_null
8114a1bc g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110cdd4 g     F .text	00000040 bSyncSetOst
811544f0 g     O .rwdata	00000002 OSTicksPerSec
8115316c g     O .rwdata	00000019 alt_log_msg_bss
81145bfc g     F .text	00000194 convert_filename_to_name_extension
811083fc g     F .text	0000104c bRmapSetRmapMemHKArea
811065f8 g     F .text	000000e0 bFeebSetBufferSize
81115c1c g     F .text	0000057c vSimMebTask
8110addc g     F .text	00000094 i2c_start
8114bfb4 g       .text	00000000 OSIntCtxSw
8111e880 g     F .text	0000006c vFailSendMsgSync
8110d3fc g     F .text	00000074 bSyncCtrCh4OutEnable
8114afa0 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81137808 g     F .text	00000028 alt_dcache_flush_all
8112df04 g     F .text	00000068 __hi0bits
811168a0 g     F .text	0000012c vPusType251run
81107560 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111fa64 g     F .text	0000003c vChangeRTValue
811546e0 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81117aac g     F .text	000001a4 vCheck
8111ec8c g     F .text	00000050 vNFeeNotInUse
811223b0 g     F .text	00000080 .hidden __fixdfsi
81113970 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81105e04 g     F .text	000000d4 bFeebCh8SetBufferSize
81106890 g     F .text	00000088 bFeebStopCh
8110d9ec g     F .text	00000084 uliPerCalcPeriodMs
811131ec g     F .text	00000450 vNFeeControlTask
8115e068 g     O .bss	00001000 vInitialTask_stk
811545d8 g     O .bss	00000002 usiIdCMD
8115f068 g     O .bss	00000020 SyncTBL3
8110d0dc g     F .text	00000054 bSyncCtrStart
81145874 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81130abc g     F .text	00000018 strtod
81106918 g     F .text	00000088 bFeebClrCh
8115469c g     O .bss	00000004 OSTCBFreeList
811072c8 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
81140048 g     F .text	00000174 OSSemPendAbort
8111cb14 g     F .text	00000064 vFailGetMacRTC
811074c0 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111d5b4 g     F .text	00000064 vFailCreateTimerRetransmisison
8111cf88 g     F .text	00000080 vFailGetCountSemaphorexBuffer32
81119314 g     F .text	00000320 bSendUART128v2
8111f898 g     F .text	000000ec vSimucamStructureInit
8115446c g     O .rwdata	00000008 alt_dev_list
811229c0 g     F .text	0000004c _fputc_r
811391b0 g     F .text	0000010c write
81123d24 g     F .text	000000a8 _putc_r
81154704 g     O .bss	00000004 device_pointer
811544f4 g     O .rwdata	00000002 OSVersionNbr
81136068 g     F .text	000000bc .hidden __gtsf2
8111eb4c g     F .text	00000064 vFailFlushMEBQueue
81114d20 g     F .text	00000118 getPreParsedPacket
81110ed8 g     F .text	00000060 bEnableSPWChannel
811378a8 g     F .text	000000b8 fstat
8111f6e4 g     F .text	00000040 vChangeIdNFEEMaster
81122994 g     F .text	0000002c fprintf
8111f4c4 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105730 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111d760 g     F .text	00000080 vFailPostBlockingSemTimeoutTask
81120338 g     F .text	00000058 _reg_write
8111f724 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81137418 g     F .text	000000f4 .hidden __ledf2
81106e10 g     F .text	00000038 vRmapCh5HandleIrq
81110dcc g     F .text	00000054 bDisableRmapIRQ
8115f088 g     O .bss	00001000 vStackMonitor_stk
8111db60 g     F .text	00000080 vCouldNotSendLog
8114261c g     F .text	000001b8 OSTmrRemainGet
8115449c g     O .rwdata	00000004 OSEndiannessTest
8110c51c g     F .text	00000058 v_spi_start
8112e260 g     F .text	00000148 __pow5mult
81107420 g     F .text	00000050 uliRmapCh2WriteCmdAddress
81132bdc g     F .text	00001464 ___vfiprintf_internal_r
81154630 g     O .bss	00000004 __nlocale_changed
81135f98 g     F .text	00000058 .hidden __umodsi3
8110d22c g     F .text	00000074 bSyncCtrSyncOutEnable
8111fecc g     F .text	000000f8 bInitializeSDCard
8111d488 g     F .text	00000064 vFailParserCommTaskCreate
8111dae0 g     F .text	00000080 vCouldNotSendReset
81124210 g     F .text	00000038 _scanf_r
8111d550 g     F .text	00000064 vFailOutAckHandlerTaskCreate
811544ae g     O .rwdata	00000002 OSFlagGrpSize
811163b8 g     F .text	000000ac vPusType250conf
81160088 g     O .bss	00000058 xInUseRetrans
8110cb94 g     F .text	00000050 bSyncIrqFlagSync
8114a60c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
811427d4 g     F .text	000000ec OSTmrStateGet
8116e784 g       *ABS*	00000000 end
811052b0 g     F .text	00000038 vFeebCh6HandleIrq
8111d188 g     F .text	00000080 vNoContentInPreParsedBuffer
81122edc g     F .text	0000001c fseeko
81114e38 g     F .text	00000168 bSendMessagePUStoMebTask
8111dd80 g     F .text	00000088 vFailCreateNFEEQueue
81122844 g     F .text	0000000c _atoi_r
811490ec g     F .text	00000240 altera_avalon_uart_write
81137c0c g     F .text	00000054 alt_log_txchar
81122a74 g     F .text	0000001c fseek
81119284 g     F .text	00000090 vCCDChangeValues
811479e0 g     F .text	000001d0 altera_avalon_jtag_uart_init
8113b214 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111c684 g     F .text	00000064 vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
811486f4 g     F .text	00000084 alt_avalon_timer_sc_init
811066d8 g     F .text	000000a8 bFeebSetWindowing
811487e0 g     F .text	00000068 altera_avalon_uart_write_fd
811227d4 g     F .text	00000064 .hidden __clzsi2
81148848 g     F .text	00000058 altera_avalon_uart_close_fd
811600e0 g     O .bss	00000020 xMebQTBL
811483a4 g     F .text	000002cc altera_avalon_jtag_uart_write
81142d48 g     F .text	00000174 OSTmr_Init
81160100 g     O .bss	00000348 xBuffer128
8112c7a0 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112d9b8 g     F .text	000000e4 memchr
8113aeb8 g     F .text	0000005c OS_MemClr
811269d4 g     F .text	00002200 ___vfprintf_internal_r
8114c094 g     F .text	00000164 OSTaskStkInit
81124248 g     F .text	00000060 _sprintf_r
81108094 g     F .text	000002d4 bRmapGetMemConfigArea
811545da g     O .bss	00000001 SemCount32
8112cc28 g     F .text	00000318 _free_r
8114bd10 g     F .text	00000234 alt_printf
8111a2e4 g     F .text	00000050 vTimeoutCheck
811203e8 g     F .text	00000214 _print_codec_status
8112d6b8 g     F .text	00000010 __locale_mb_cur_max
8113a4c8 g     F .text	000001a0 OS_EventTaskRdy
811078fc g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
8114c5e8 g     F .text	00000188 __call_exitprocs
81113740 g     F .text	00000168 vPerformActionNFCRunning
811546a0 g     O .bss	00000001 OSCPUUsage
8111e090 g     F .text	00000080 vCoudlNotCreateNFee4Task
8115462c g     O .bss	00000004 __mlocale_changed
8111363c g     F .text	00000104 vPerformActionNFCConfig
8110d184 g     F .text	00000054 bSyncCtrOneShot
81154450 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d8fc g     F .text	0000003c uliSyncReadStatus
81154658 g     O .bss	00000004 _alt_tick_rate
8113ef3c g     F .text	00000294 OSQPend
81130bdc g     F .text	000002e8 _strtoll_r
81160448 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81168010 g     O .bss	00000040 xDefaults
81141cc0 g     F .text	0000010c OSTimeDly
81116730 g     F .text	000000c4 vPusMebInTaskRunningMode
8110cb58 g     F .text	0000003c vSyncIrqFlagClrSync
8112e3a8 g     F .text	00000150 __lshift
81113a38 g     F .text	00000328 vOutAckHandlerTask
8114a064 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8115465c g     O .bss	00000004 _alt_nticks
81138c10 g     F .text	00000104 read
8114339c g     F .text	000000f0 alt_sys_init
8112108c g     F .text	0000012c .hidden __floatsisf
81106f34 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
81131414 g     F .text	000001d8 __ssprint_r
81123cbc g     F .text	00000068 _open_r
811202d8 g     F .text	00000060 bTestSimucamCriticalHW
8110625c g     F .text	0000010c bFeebGetBuffersStatus
8111c2f4 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
811546a1 g     O .bss	00000001 OSTaskCtr
81137bd8 g       .text	00000000 tx_log_str
81116198 g     F .text	0000015c vPusMebTask
8111a294 g     F .text	00000050 siPosStr
81116e74 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
811350ac g     F .text	000000d0 strncmp
8110d938 g     F .text	0000005c bSyncWriteReg
81107270 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81141dcc g     F .text	00000164 OSTimeDlyHMSM
8112e060 g     F .text	00000200 __multiply
81147f78 g     F .text	00000070 altera_avalon_jtag_uart_close
8110c6ec g     F .text	00000058 v_spi_end
81120040 g     F .text	00000040 cGetNextChar
8114c4fc g     F .text	000000ec strncpy
81154858 g     O .bss	00000028 __malloc_current_mallinfo
811544a2 g     O .rwdata	00000002 OSEventMax
81135ff0 g     F .text	00000078 .hidden __eqsf2
8112e8d4 g     F .text	00000154 __d2b
811401bc g     F .text	00000118 OSSemPost
81105424 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111faa0 g     F .text	00000030 vChangeDefaultRTValue
81105320 g     F .text	00000038 vFeebCh8HandleIrq
811546dc g     O .bss	00000004 initialized
8111a144 g     F .text	00000100 vSendLog
8113a03c g     F .text	000000e4 OSSchedUnlock
8110c744 g     F .text	0000017c RTCC_SPI_R_MAC
81154480 g     O .rwdata	00000004 alt_log_boot_on_flag
8114785c g     F .text	00000068 altera_avalon_jtag_uart_read_fd
81130ec4 g     F .text	00000254 _strtoul_r
81160488 g     O .bss	00000020 xFeeQueueTBL5
8114b814 g     F .text	000000e4 alt_get_fd
811546a4 g     O .bss	00000004 OSMemFreeList
8113a198 g     F .text	000000b8 OSStatInit
811202a4 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116e11c g     O .bss	00000014 search_data
8110a0c4 g     F .text	00000134 bSpwcSetLink
811375bc g     F .text	00000130 alt_busy_sleep
8113cb58 g     F .text	000000cc OSFlagQuery
8110d2a0 g     F .text	00000074 bSyncCtrCh1OutEnable
811544d8 g     O .rwdata	00000002 OSTaskCreateExtEn
811205fc g     F .text	00000074 _split_codec_status
8112a87c g     F .text	0000005c _close_r
8111d208 g     F .text	00000080 vCouldNotSendEthConfUART
81112b60 g     F .text	0000068c vInitialTask
81138380 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8114a54c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114c480 g     F .text	0000007c memcmp
8113a4a0 g     F .text	00000028 OS_Dummy
8114792c g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116e784 g       *ABS*	00000000 __alt_stack_base
81105d30 g     F .text	000000d4 bFeebCh7SetBufferSize
81147984 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105468 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81122f5c g     F .text	000000d4 _fwrite_r
811171a8 g     F .text	000000a4 vReleaseSyncMessages
8114a66c g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105578 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8112a720 g     F .text	0000015c __swsetup_r
8116a6b8 g     O .bss	00000300 OSQTbl
8111e5d0 g     F .text	00000080 vCouldNotGetQueueMaskNfeeCtrl
81168050 g     O .bss	0000001c xConfEth
81136aa0 g     F .text	000008f0 .hidden __divdf3
8111fb04 g     F .text	0000003c vChangeSyncSource
8112c658 g     F .text	00000120 __sfp
8116e130 g     O .bss	00000054 boot_sector_data
8111e550 g     F .text	00000080 vCouldNotCreateQueueMaskDataCtrl
8110a530 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112eb50 g     F .text	00000078 __copybits
81152b44 g     O .rwdata	00000408 __malloc_av_
8112c7ac g     F .text	00000004 __sinit_lock_release
81154514 g     O .bss	00000004 uliInitialState
8110ae70 g     F .text	00000080 i2c_stop
81120714 g     F .text	0000007c Verif_Error
81120790 g     F .text	00000034 toInt
8111c830 g     F .text	00000064 vFailSendPreAckSenderSemaphore
811546a8 g     O .bss	00000004 OSTCBHighRdy
8112138c g     F .text	00000720 .hidden __muldf3
8112431c g     F .text	0000005c __sread
8112cac0 g     F .text	0000003c fread
811546ac g     O .bss	00000004 OSQFreeList
8114b704 g     F .text	00000110 alt_find_file
8114b5c0 g     F .text	000000ac alt_dev_llist_insert
811393f0 g     F .text	00000128 __malloc_lock
81122964 g     F .text	00000030 _fprintf_r
81138d80 g     F .text	000000fc sbrk
8111f350 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111cf08 g     F .text	00000080 vFailGetCountSemaphorexBuffer64
811247f4 g     F .text	000021e0 ___svfprintf_internal_r
8111a684 g     F .text	00000088 vTMPusTestConnection
811545dc g     O .bss	00000004 xMebQ
81139714 g     F .text	00000148 OSEventNameSet
8112c394 g     F .text	00000064 _fflush_r
81134120 g     F .text	000000cc _calloc_r
811546b0 g     O .bss	00000001 OSRdyGrp
8111e9bc g     F .text	00000064 vFailSendMsgFeeCTRL
8110ccd0 g     F .text	00000044 ucSyncStatusCycleNumber
81107a5c g     F .text	0000008c bRmapGetCodecConfig
811428c0 g     F .text	00000148 OSTmrStart
81105278 g     F .text	00000038 vFeebCh5HandleIrq
8112294c g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
81154514 g       *ABS*	00000000 __bss_start
81105ab4 g     F .text	000000d4 bFeebCh4SetBufferSize
81123b94 g     F .text	00000128 memset
81115224 g     F .text	0000013c setPreParsedFreePos
8110f6fc g     F .text	0000025c vQCmdFEEinStandBy
8114b0c8 g     F .text	00000060 alt_msgdma_open
8111fc5c g     F .text	00000210 pattern_createPattern
81118bac g     F .text	00000220 main
8111ca14 g     F .text	00000080 vFailGetMutexReceiverTask
811604a8 g     O .bss	00001000 vNFeeControlTask_stk
811070cc g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111f9bc g     F .text	0000003c vChangeEPValue
81107218 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81154654 g     O .bss	00000004 alt_envp
8111ea84 g     F .text	00000064 vFailFlushQueue
8115461c g     O .bss	00000004 __malloc_max_total_mem
8114a96c g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111c398 g     F .text	0000005c ucCrc8wInit
8111d618 g     F .text	00000064 vCouldNotCheckBufferTimeOutFunction
811478c4 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110b028 g     F .text	00000160 i2c_read
811614a8 g     O .bss	00000020 SyncTBL5
8112a6a0 g     F .text	00000018 __swbuf
81152278 g     O .rodata	00000100 OSUnMapTbl
81136124 g     F .text	000000c8 .hidden __ltsf2
81146c60 g     F .text	00000090 alt_up_sd_card_get_attributes
8112c88c g     F .text	00000234 _fread_r
8111c894 g     F .text	00000080 vFailGetCountSemaphoreSenderTask
8110a81c g     F .text	0000003c bDisableIsoDrivers
811544d2 g     O .rwdata	00000002 OSSemEn
8114348c g     F .text	000000bc Write_Sector_Data
81147070 g     F .text	00000628 alt_up_sd_card_write
811545e0 g     O .bss	00000004 xFeeQ
811064c0 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113c7bc g     F .text	0000039c OSFlagPost
81124468 g     F .text	00000008 __sclose
8111d9e0 g     F .text	00000080 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
811342e4 g     F .text	00000014 fclose
8113a668 g     F .text	00000118 OS_EventTaskWait
8111d860 g     F .text	00000080 vCouldNotRetransmitB32TimeoutTask
81124598 g     F .text	00000240 _strtol_r
8112262c g     F .text	000001a8 .hidden __truncdfsf2
811614c8 g     O .bss	00000020 xFeeQueueTBL2
8113b2f8 g     F .text	000000d4 OS_TaskStatStkChk
811410d8 g     F .text	00000158 OSTaskDelReq
81104b98 g     F .text	000000c4 bDpktGetPacketHeader
81106bc8 g     F .text	000000ec vRmapCh1HandleIrq
8112aae0 g     F .text	00001690 _dtoa_r
8114ac88 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81123230 g     F .text	00000814 _malloc_r
811614e8 g     O .bss	00000020 SyncTBL0
811352e8 g     F .text	00000030 __ascii_wctomb
8113d954 g     F .text	000001d0 OSMutexCreate
8111d7e0 g     F .text	00000080 vFailCouldNotRetransmitTimeoutTask
81112a14 g     F .text	0000014c bCheckInAck32
81154478 g     O .rwdata	00000004 alt_errno
8114a7b4 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
8113a120 g     F .text	00000078 OSStart
8110a1f8 g     F .text	000000e4 bSpwcGetLink
8110be40 g     F .text	000004e8 POWER_SPI_RW
81132830 g     F .text	000000dc __submore
811382e0 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81139388 g     F .text	00000068 __env_unlock
8111df10 g     F .text	00000080 vCoudlNotCreateNFee1Task
8112d404 g     F .text	000000cc _fwalk
8114158c g     F .text	000001dc OSTaskResume
8113d5e4 g     F .text	000000f0 OSMemQuery
811544e4 g     O .rwdata	00000002 OSTaskStatEn
8116e784 g       *ABS*	00000000 __alt_stack_limit
81154524 g     O .bss	00000004 ECommSpwCh
8111fba8 g     F .text	0000003c vChangeAutoResetSync
8112d954 g     F .text	00000064 _mbtowc_r
81112400 g     F .text	00000380 vInAckHandlerTaskV2
811544be g     O .rwdata	00000002 OSMemMax
8113f4b4 g     F .text	00000178 OSQPostFront
81123dcc g     F .text	000000d0 putc
81135e3c g     F .text	00000084 .hidden __divsi3
811546b1 g     O .bss	00000006 OSRdyTbl
81154498 g     O .rwdata	00000002 OSDebugEn
811531dc g     O .rwdata	0000002a alt_log_msg_cache
8112cafc g     F .text	0000012c _malloc_trim_r
81109c14 g     F .text	000001a4 bRmapInitCh
81154610 g     O .bss	00000008 xSdHandle
81120c88 g     F .text	00000404 .hidden __mulsf3
811544b0 g     O .rwdata	00000002 OSFlagNodeSize
81154518 g     O .bss	00000004 pnt_memory
8111fc14 g     F .text	00000048 vSyncReset
81111ed8 g     F .text	00000528 vLoadCtemp
8110cd94 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
811546e8 g     O .bss	00000004 status_register
811544f8 g     O .rwdata	00000002 OSTmrCfgMax
8110d728 g     F .text	00000074 bSyncIrqFlagClrError
8111d308 g     F .text	00000080 vFailSetPreAckSenderBuffer
8112f374 g     F .text	000000dc strcmp
811546f0 g     O .bss	00000004 command_register
8113ea40 g     F .text	000001b4 OSQCreate
81141230 g     F .text	000001a0 OSTaskNameGet
81161508 g     O .bss	00001000 vFeeTask4_stk
81162508 g     O .bss	00000018 xReceivedACK
8113f62c g     F .text	00000214 OSQPostOpt
8113a250 g     F .text	00000228 OSTimeTick
811544e0 g     O .rwdata	00000002 OSTaskMax
8113fb0c g     F .text	000000e0 OSSemCreate
81154504 g     O .rwdata	00000002 OSTmrWheelSize
8111dd00 g     F .text	00000080 vFailCreateScheduleQueue
81120390 g     F .text	00000058 _reg_read
8113e5ec g     F .text	00000174 OSMutexQuery
811110e0 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81137390 g     F .text	00000088 .hidden __nedf2
811544da g     O .rwdata	00000002 OSTaskDelEn
8111f984 g     F .text	00000038 vLoadDefaultEPValue
81162520 g     O .bss	00001000 vFeeTask1_stk
8110d558 g     F .text	00000074 bSyncCtrCh7OutEnable
811402d4 g     F .text	00000118 OSSemQuery
8113ebf4 g     F .text	00000288 OSQDel
8113f1d0 g     F .text	00000174 OSQPendAbort
811545e4 g     O .bss	00000004 xMutexPreParsed
8114335c g     F .text	00000040 alt_irq_init
81138d14 g     F .text	0000006c alt_release_fd
8114367c g     F .text	000000bc get_cluster_flag
8110d79c g     F .text	00000074 bSyncIrqFlagClrBlank
8114b3c0 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110cae0 g     F .text	0000002c vSyncClearCounter
81111aec g     F .text	000003ec bPrepareDoubleBuffer
811531a8 g     O .rwdata	00000031 alt_log_msg_stackpointer
811242a8 g     F .text	00000074 sprintf
81151960 g     O .rodata	00000100 .hidden __clz_tab
81143c50 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111ca94 g     F .text	00000080 vFailGetMutexTxUARTSenderTask
81154628 g     O .bss	00000004 _PathLocale
8110d868 g     F .text	00000058 bSyncIrqFlagBlank
8110bcf8 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
81142a08 g     F .text	000001e8 OSTmrStop
81109e0c g     F .text	00000050 uliRmapReadReg
8111a244 g     F .text	00000050 usiGetIdCMD
8110d994 g     F .text	00000058 uliSyncReadReg
81130ad4 g     F .text	00000108 strtof
81105208 g     F .text	00000038 vFeebCh3HandleIrq
81136068 g     F .text	000000bc .hidden __gesf2
81124470 g     F .text	0000004c strcspn
8112a6b8 g     F .text	00000068 _write_r
8110c394 g     F .text	00000074 vRstcReleaseDeviceReset
8111d4ec g     F .text	00000064 vFailInAckHandlerTaskCreate
81139fa8 g     F .text	00000094 OSSchedLock
8111e010 g     F .text	00000080 vCoudlNotCreateNFee3Task
8112d6e8 g     F .text	00000018 setlocale
8114a714 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8116a9b8 g     O .bss	00000800 OSTmrTaskStk
811241cc g     F .text	00000044 scanf
8111e310 g     F .text	00000078 vFailCreateMutexSPUSQueueMeb
8113bbb0 g     F .text	00000110 OSFlagCreate
81143ee4 g     F .text	00000688 Check_for_DOS_FAT
811170a0 g     F .text	00000064 vMebInit
81145d90 g     F .text	000002d0 create_file
8112f36c g     F .text	00000008 nanf
8115444c g     O .rwdata	00000004 _impure_ptr
811546ec g     O .bss	00000004 CSD_register_w0
8115464c g     O .bss	00000004 alt_argc
8111ce88 g     F .text	00000080 vFailGetCountSemaphorexBuffer128
8112c170 g     F .text	00000224 __sflush_r
8112d774 g     F .text	000000b4 _mbrtowc_r
8110a4a0 g     F .text	00000090 bSpwcGetTimecode
8112d6d4 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
81154528 g     O .bss	00000004 ESdmaBufferSide
811544aa g     O .rwdata	00000002 OSEventMultiEn
81122a70 g     F .text	00000004 _fseek_r
81163520 g     O .bss	00001800 vParserCommTask_stk
8111c4d4 g     F .text	00000070 printErrorTask
8111f9f8 g     F .text	00000030 vChangeDefaultEPValue
81118160 g     F .text	000002c8 vCheckRetransmission32
811421d8 g     F .text	000001c4 OSTmrCreate
8111724c g     F .text	000007dc vStackMonitor
81123f94 g     F .text	000001dc __srefill_r
8110a858 g     F .text	0000003c bEnableLvdsBoard
811545e8 g     O .bss	00000004 xMutexBuffer32
81154590 g     O .bss	00000001 ucIterationSide
81106cb4 g     F .text	000000ec vRmapCh2HandleIrq
8113bcc0 g     F .text	00000250 OSFlagDel
811546b8 g     O .bss	00000004 OSEventFreeList
8110a8d0 g     F .text	000000c0 bSetPreEmphasys
8110f4b8 g     F .text	00000244 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112d908 g     F .text	0000004c __ascii_mbtowc
8110d064 g     F .text	00000078 bSyncCtrExtnIrq
81106528 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112e75c g     F .text	00000064 __ulp
8111f530 g     F .text	0000010c vNFeeControlInit
81117104 g     F .text	000000a4 vSwapMemmory
8113c194 g     F .text	000005c0 OSFlagPend
811544f6 g     O .rwdata	00000002 OSTmrEn
8112c7c8 g     F .text	00000018 __fp_unlock_all
81164d20 g     O .bss	00000010 xDma
81122a0c g     F .text	00000064 fputc
81110e20 g     F .text	00000058 bEnableRmapIRQ
8111995c g     F .text	00000328 bSendUART32v2
811154dc g     F .text	000001b4 setPreAckReceiverFreePos
8110d024 g     F .text	00000040 bSyncErrInj
81154464 g     O .rwdata	00000008 alt_fs_list
81164d30 g     O .bss	00001000 vSimMebTask_stk
8111e290 g     F .text	00000080 vCoudlNotCreateMebTask
8114472c g     F .text	00000274 check_file_name_for_FAT16_compliance
81165d30 g     O .bss	00001000 vFeeTask3_stk
811424dc g     F .text	00000140 OSTmrNameGet
81154980 g     O .bss	00000400 xSZData
8110f958 g     F .text	00000288 vQCmdFEEinFullPattern
8113b0d8 g     F .text	0000007c OS_StrCopy
811546f8 g     O .bss	00000004 buffer_memory
8111d108 g     F .text	00000080 vFailGetxMutexPreParsedParserRxTask
8111f800 g     F .text	00000098 vLogWriteNUC
811544c0 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000bc bSdmaInitM1Dma
8110d6b4 g     F .text	00000074 bSyncIrqEnableBlank
8114c320 g     F .text	00000028 OSInitHookEnd
8111ef60 g     F .text	00000340 vUpdateMemMapFEE
8111d408 g     F .text	00000080 vFailSetPreAckReceiverBuffer
811057e0 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
811544ec g     O .rwdata	00000002 OSTCBPrioTblMax
8112d700 g     F .text	0000000c localeconv
8111e210 g     F .text	00000080 vCoudlNotCreateDataControllerTask
811545ec g     O .bss	00000004 xTimerRetransmission
81114fa0 g     F .text	00000284 vReceiverUartTask
81154648 g     O .bss	00000004 alt_log_sys_clk_count
811544e8 g     O .rwdata	00000002 OSTaskStatStkChkEn
81138530 g     F .text	00000140 alt_log_write
81166d30 g     O .bss	00001000 vFeeTask2_stk
811545f0 g     O .bss	00000004 xMutexBuffer128
81105198 g     F .text	00000038 vFeebCh1HandleIrq
81120238 g     F .text	0000003c bStartSync
811052e8 g     F .text	00000038 vFeebCh7HandleIrq
81120274 g     F .text	00000030 bStopSync
8115452c g     O .bss	00000004 ECommBufferSide
8114b8f8 g     F .text	00000058 alt_ic_isr_register
811544bc g     O .rwdata	00000002 OSMemEn
81106da0 g     F .text	00000038 vRmapCh3HandleIrq
81154438 g     O .rwdata	00000004 alt_stack_limit_value
811169cc g     F .text	00000420 vPusType252run
8111e958 g     F .text	00000064 vFailSendMsgMasterSyncMeb
81123030 g     F .text	0000003c fwrite
811546fc g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
811544c6 g     O .rwdata	00000002 OSMutexEn
8111e650 g     F .text	00000080 vCouldNotGetQueueMaskDataCtrl
81154514 g       *ABS*	00000000 _edata
81148778 g     F .text	00000068 altera_avalon_uart_read_fd
8111f6b0 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105080 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116e784 g       *ABS*	00000000 _end
8116e184 g     O .bss	00000500 active_files
811546bc g     O .bss	00000001 OSIntNesting
8111cb78 g     F .text	00000064 vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111f42c g     F .text	0000002c cFeeRMAPDump
811059e0 g     F .text	000000d4 bFeebCh3SetBufferSize
811545f4 g     O .bss	00000004 xSemCountBuffer32
811342f8 g     F .text	0000016c __fputwc
811545f8 g     O .bss	00000004 xQMaskFeeCtrl
8111f37c g     F .text	0000002c vFeeSpwRMAPChangeConfig
8112a478 g     F .text	00000070 vfscanf
81146060 g     F .text	00000150 copy_file_record_name_to_string
81147fe8 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81141f30 g     F .text	000001dc OSTimeDlyResume
8114456c g     F .text	000000f4 Look_for_FAT16
81110e78 g     F .text	00000060 bDisableSPWChannel
8113c040 g     F .text	00000154 OSFlagNameSet
81110fd0 g     F .text	0000006c bDisAndClrDbBuffer
811545fc g     O .bss	00000004 xMutexBuffer64
81107c48 g     F .text	00000160 bRmapGetCodecError
81141768 g     F .text	000001c8 OSTaskStkChk
8114b9e0 g     F .text	00000094 alt_ic_irq_disable
81103cb0 g     F .text	00000454 bSdmaDmaM1Transfer
811544c2 g     O .rwdata	00000002 OSMemSize
811164d0 g     F .text	00000260 vPusType252conf
8111cd08 g     F .text	00000080 vFailSetCountSemaphorexBuffer32
81124380 g     F .text	00000084 __swrite
81154454 g     O .rwdata	00000004 __malloc_trim_threshold
8112d6c8 g     F .text	0000000c __locale_msgcharset
81167d30 g     O .bss	00000020 xFeeQueueTBL1
811546c0 g     O .bss	00000004 OSTCBCur
8111d8e0 g     F .text	00000080 vCouldNotRetransmitB64TimeoutTask
8110bdfc g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114c440 g     F .text	00000040 exit
8113e3cc g     F .text	00000220 OSMutexPost
8110d810 g     F .text	00000058 bSyncIrqFlagError
8114648c g     F .text	000003c0 alt_up_sd_card_find_next
811544c4 g     O .rwdata	00000002 OSMemTblSize
8112d4d0 g     F .text	000000cc _fwalk_reent
8114ab0c g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
811211b8 g     F .text	000000f8 .hidden __floatunsisf
8112e558 g     F .text	00000204 __mdiff
8111de90 g     F .text	00000080 vCoudlNotCreateNFee0Task
81105ed8 g     F .text	0000017c vFeebInitIrq
81104840 g     F .text	0000022c bDpktSetPacketConfig
8111cc40 g     F .text	00000064 vFailSenderCreate
81135ec0 g     F .text	00000074 .hidden __modsi3
8111e110 g     F .text	00000080 vCoudlNotCreateNFee5Task
8110cf70 g     F .text	0000003c uliSyncGetPer
81106e48 g     F .text	00000038 vRmapCh6HandleIrq
81154600 g     O .bss	00000004 xMutexSenderACK
8111d6e0 g     F .text	00000080 vFailGetBlockingSemTimeoutTask
81154444 g     O .rwdata	00000004 __ctype_ptr__
8111d388 g     F .text	00000080 vFailSetPreParsedBuffer
8114359c g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112c7a4 g     F .text	00000004 __sfp_lock_release
81106128 g     F .text	000000ac bFeebGetIrqControl
8111da60 g     F .text	00000080 vCouldNotSendTurnOff
81139df0 g     F .text	00000064 OSInit
8110b208 g     F .text	00000078 bSetPainelLeds
8114a254 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
811546c4 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107da8 g     F .text	000002ec bRmapSetMemConfigArea
81141b1c g     F .text	0000012c OSTaskQuery
8110d640 g     F .text	00000074 bSyncIrqEnableError
81154604 g     O .bss	00000004 xMutexPus
8113f9a4 g     F .text	000000b0 OS_QInit
8112f29c g     F .text	000000d0 __sccl
81122838 g     F .text	0000000c atoi
8110db28 g     F .text	00001778 vFeeTask
8113b154 g     F .text	0000005c OS_StrLen
8111ebb0 g     F .text	00000064 vFailFlushNFEEQueue
811055d0 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111c3f4 g     F .text	000000e0 vDataControllerInit
8113d3e8 g     F .text	0000011c OSMemNameSet
81151a60 g     O .rodata	00000101 _ctype_
8110cf34 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111ce08 g     F .text	00000080 vFailSetCountSemaphorexBuffer128
811544de g     O .rwdata	00000002 OSTaskProfileEn
8111ec14 g     F .text	00000028 vEvtChangeMebMode
8114a124 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81154608 g     O .bss	00000004 xTxUARTMutex
811546c8 g     O .bss	00000004 OSTime
8115445c g     O .rwdata	00000004 __mbtowc
81148d98 g     F .text	0000005c altera_avalon_uart_close
8110f2a0 g     F .text	00000218 vQCmdFEEinWaitingSync
811546cc g     O .bss	00000004 OSTmrSem
81116464 g     F .text	0000006c vPusType251conf
8116b1b8 g     O .bss	00001000 OSTaskIdleStk
81122850 g     F .text	000000fc _fopen_r
811545a4 g     O .bss	00000004 pdata
8114c770 g     F .text	000000bc _exit
81106368 g     F .text	00000078 bFeebGetLeftBufferEmpty
8114b448 g     F .text	00000134 alt_alarm_start
8113bf10 g     F .text	00000130 OSFlagNameGet
8114210c g     F .text	00000064 OSTimeGet
81154530 g     O .bss	00000004 ESdmaChBufferId
81146cf0 g     F .text	00000380 alt_up_sd_card_read
81107000 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8112306c g     F .text	000001c4 __smakebuf_r
8115460c g     O .bss	00000001 SemCount64
81119634 g     F .text	00000328 bSendUART64v2
8111eae8 g     F .text	00000064 vFailFlushQueueData
81105680 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8115450c g     O .rwdata	00000008 alt_msgdma_list
811244bc g     F .text	00000098 strlen
8110c638 g     F .text	000000b4 uc_spi_get_byte
81107044 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111e6d0 g     F .text	0000006c vFailSendMsgAccessDMA
8114c250 g     F .text	00000028 OSTaskSwHook
81138a70 g     F .text	0000015c open
81109448 g     F .text	000007cc bRmapGetRmapMemHKArea
8116c1b8 g     O .bss	00000d00 OSEventTbl
8111f3a8 g     F .text	0000002c vFeeSpwRMAPChangeDefault
811212b0 g     F .text	000000dc .hidden __gedf2
8111e8ec g     F .text	0000006c vFailSendMsgSyncRMAPTRIGGER
81167d50 g     O .bss	00000020 xSenderACK
8114bf44 g     F .text	00000044 alt_putchar
8116ceb8 g     O .bss	000011b8 OSTCBTbl
81134610 g     F .text	00000838 __gethex
811403ec g     F .text	00000108 OSSemSet
81117a28 g     F .text	00000084 vTimeoutCheckerTaskv2
8111f458 g     F .text	00000038 cFeeRMAPEchoingEnable
81154460 g     O .rwdata	00000004 __wctomb
81118898 g     F .text	00000314 vVariablesInitialization
81132bc4 g     F .text	00000018 __sprint_r
81110264 g     F .text	000005e4 vQCmdFeeRMAPinFullPattern
811061d4 g     F .text	00000088 bFeebGetIrqFlags
81154520 g     O .bss	00000004 pxDmaM2Dev
8111c620 g     F .text	00000064 vFailCreateSemaphoreResources
8115447c g     O .rwdata	00000004 alt_priority_mask
8110a894 g     F .text	0000003c bDisableLvdsBoard
8113fbec g     F .text	00000248 OSSemDel
8110590c g     F .text	000000d4 bFeebCh2SetBufferSize
811546d0 g     O .bss	00000004 OSFlagFreeList
8110c574 g     F .text	000000c4 v_spi_send_byte
8110c8c0 g     F .text	000000d0 bSSDisplayConfig
8114b950 g     F .text	00000090 alt_ic_irq_enable
811544a4 g     O .rwdata	00000002 OSEventNameSize
81128bd4 g     F .text	0000001c __vfprintf_internal
811546d4 g     O .bss	00000001 OSStatRdy
8110d314 g     F .text	00000074 bSyncCtrCh2OutEnable
8116e070 g     O .bss	000000ac OSTCBPrioTbl
81148e38 g     F .text	00000270 altera_avalon_uart_read
81135318 g     F .text	00000064 _wctomb_r
811392bc g     F .text	000000cc __env_lock
811544ea g     O .rwdata	00000002 OSTaskSwHookEn
81154e98 g     O .bss	00000100 cTemp
811053e0 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81121aac g     F .text	00000904 .hidden __subdf3
81167d70 g     O .bss	00000260 xPreParsed
8110cfac g     F .text	0000003c uliSyncGetOst
8115460d g     O .bss	00000001 SemCount128
81106eb8 g     F .text	00000038 vRmapCh8HandleIrq
811054ac g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81119c84 g     F .text	00000290 vSendEthConf
811046cc g     F .text	000000d0 bCommInitCh
8112df6c g     F .text	000000b0 __lo0bits
81128cb4 g     F .text	000017c4 __svfscanf_r
81154488 g     O .rwdata	00000008 alt_alarm_list
8113290c g     F .text	0000019c _ungetc_r
811544b2 g     O .rwdata	00000002 OSFlagWidth
81106ef0 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
81135220 g     F .text	000000c8 wcrtomb
81104c5c g     F .text	00000148 bDpktSetPixelDelay
81119120 g     F .text	00000164 vCCDLoadDefaultValues
81137730 g     F .text	000000d8 close
8110cfe8 g     F .text	0000003c uliSyncGetGeneral
8111ec64 g     F .text	00000028 vEvtChangeDataControllerMode
81154664 g     O .bss	00000004 alt_envsem
81137c60 g     F .text	00000068 alt_log_repchar
811546d8 g     O .bss	00000004 OSIdleCtrRun
8113a478 g     F .text	00000028 OSVersion
811544fc g     O .rwdata	00000002 OSTmrCfgWheelSize
81141c48 g     F .text	00000078 OS_TaskStkClr
8111ffc4 g     F .text	0000003c siOpenFile
8110da70 g     F .text	000000b8 vDataControlTask
811544d6 g     O .rwdata	00000002 OSTaskCreateEn
81107168 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
811075b0 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106808 g     F .text	00000088 bFeebStartCh
81119f14 g     F .text	00000118 vSendTurnOff
8111c768 g     F .text	00000064 vFailSendPreParsedSemaphore
81144a60 g     F .text	000002a4 match_file_record_to_name_ext
8113aaa0 g     F .text	00000070 OS_EventWaitListInit
81134488 g     F .text	00000088 fputwc
81167fd0 g     O .bss	00000020 xFeeQueueTBL0
8111c6e8 g     F .text	00000080 vFailSendxSemCommInit
8114c348 g     F .text	00000028 OSTaskIdleHook
8111a02c g     F .text	00000118 vSendReset
8112c7a8 g     F .text	00000004 __sinit_lock_acquire
8112dcd0 g     F .text	00000128 __multadd
81167ff0 g     O .bss	00000020 SyncTBL1
811054f0 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110cc38 g     F .text	0000004c ucSyncStatusState
81141930 g     F .text	000001ec OSTaskSuspend
8112dca8 g     F .text	00000028 _Bfree
8110cef8 g     F .text	0000003c uliSyncGetMbt
8113b1b0 g     F .text	00000064 OS_TaskIdle
81154502 g     O .rwdata	00000002 OSTmrTblSize
8113f840 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1139e540 	call	81139e54 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10b9a104 	addi	r2,r2,-6524
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10b9a104 	addi	r2,r2,-6524
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1139ea80 	call	81139ea8 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21112004 	addi	r4,r4,17536
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	210c7704 	addi	r4,r4,12764
81100274:	1137bd80 	call	81137bd8 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21112004 	addi	r4,r4,17536
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	210c6a04 	addi	r4,r4,12712
81100290:	1137bd80 	call	81137bd8 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6b10e14 	ori	gp,gp,50232
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21112004 	addi	r4,r4,17536
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	210c5b04 	addi	r4,r4,12652
811002bc:	1137bd80 	call	81137bd8 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	10914514 	ori	r2,r2,17684

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18f9e114 	ori	r3,r3,59268

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21112004 	addi	r4,r4,17536
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	210c6204 	addi	r4,r4,12680
811002fc:	1137bd80 	call	81137bd8 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11388040 	call	81138804 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18d22004 	addi	r3,r3,18560
81100330:	00a04574 	movhi	r2,33045
81100334:	10b20b04 	addi	r2,r2,-14292
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29522004 	addi	r5,r5,18560
8110035c:	1009883a 	mov	r4,r2
81100360:	11229940 	call	81122994 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18d22004 	addi	r3,r3,18560
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10b21404 	addi	r2,r2,-14256
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06217 	ldw	r2,-32376(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	29522004 	addi	r5,r5,18560
811003f8:	1009883a 	mov	r4,r2
811003fc:	11229940 	call	81122994 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18d22004 	addi	r3,r3,18560
81100410:	00a04574 	movhi	r2,33045
81100414:	10b22004 	addi	r2,r2,-14208
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06217 	ldw	r2,-32376(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	29522004 	addi	r5,r5,18560
8110043c:	1009883a 	mov	r4,r2
81100440:	11229940 	call	81122994 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	11390300 	call	81139030 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110ab740 	call	8110ab74 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#if DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	29722604 	addi	r5,r5,-14184
811004b4:	01204574 	movhi	r4,33045
811004b8:	21122004 	addi	r4,r4,18560
811004bc:	11242a80 	call	811242a8 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06217 	ldw	r2,-32376(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	29522004 	addi	r5,r5,18560
811004cc:	1009883a 	mov	r4,r2
811004d0:	11229940 	call	81122994 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18d22004 	addi	r3,r3,18560
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10b22b04 	addi	r2,r2,-14164
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	1123a440 	call	81123a44 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06217 	ldw	r2,-32376(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	29522004 	addi	r5,r5,18560
8110050c:	1009883a 	mov	r4,r2
81100510:	11229940 	call	81122994 <fprintf>
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18d22004 	addi	r3,r3,18560
81100544:	00a04574 	movhi	r2,33045
81100548:	10b23104 	addi	r2,r2,-14140
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06217 	ldw	r2,-32376(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	29522004 	addi	r5,r5,18560
81100570:	1009883a 	mov	r4,r2
81100574:	11229940 	call	81122994 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18d22004 	addi	r3,r3,18560
81100584:	00a04574 	movhi	r2,33045
81100588:	10b23a04 	addi	r2,r2,-14104
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06217 	ldw	r2,-32376(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	29522004 	addi	r5,r5,18560
811005b0:	1009883a 	mov	r4,r2
811005b4:	11229940 	call	81122994 <fprintf>
#endif
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18d22004 	addi	r3,r3,18560
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10b24204 	addi	r2,r2,-14072
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06217 	ldw	r2,-32376(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	29522004 	addi	r5,r5,18560
811005ec:	1009883a 	mov	r4,r2
811005f0:	11229940 	call	81122994 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	11390300 	call	81139030 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110aa940 	call	8110aa94 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18d22004 	addi	r3,r3,18560
81100650:	00a04574 	movhi	r2,33045
81100654:	10b24804 	addi	r2,r2,-14048
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06217 	ldw	r2,-32376(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	29522004 	addi	r5,r5,18560
8110067c:	1009883a 	mov	r4,r2
81100680:	11229940 	call	81122994 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110ab740 	call	8110ab74 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18d22004 	addi	r3,r3,18560
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10b24e04 	addi	r2,r2,-14024
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	1123a440 	call	81123a44 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06217 	ldw	r2,-32376(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	29522004 	addi	r5,r5,18560
811006f8:	1009883a 	mov	r4,r2
811006fc:	11229940 	call	81122994 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	29725704 	addi	r5,r5,-13988
81100734:	01204574 	movhi	r4,33045
81100738:	21122004 	addi	r4,r4,18560
8110073c:	11242a80 	call	811242a8 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06217 	ldw	r2,-32376(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	29522004 	addi	r5,r5,18560
8110074c:	1009883a 	mov	r4,r2
81100750:	11229940 	call	81122994 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18d22004 	addi	r3,r3,18560
81100764:	00a04574 	movhi	r2,33045
81100768:	10b26604 	addi	r2,r2,-13928
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06217 	ldw	r2,-32376(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	29522004 	addi	r5,r5,18560
81100790:	1009883a 	mov	r4,r2
81100794:	11229940 	call	81122994 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18d22004 	addi	r3,r3,18560
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10b26f04 	addi	r2,r2,-13892
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06217 	ldw	r2,-32376(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	29522004 	addi	r5,r5,18560
811007d0:	1009883a 	mov	r4,r2
811007d4:	11229940 	call	81122994 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10922004 	addi	r2,r2,18560
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06217 	ldw	r2,-32376(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	29522004 	addi	r5,r5,18560
811007f8:	1009883a 	mov	r4,r2
811007fc:	11229940 	call	81122994 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18d22004 	addi	r3,r3,18560
81100840:	00a04574 	movhi	r2,33045
81100844:	10b27704 	addi	r2,r2,-13860
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06217 	ldw	r2,-32376(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	29522004 	addi	r5,r5,18560
8110086c:	1009883a 	mov	r4,r2
81100870:	11229940 	call	81122994 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18d22004 	addi	r3,r3,18560
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10b28004 	addi	r2,r2,-13824
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06217 	ldw	r2,-32376(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	29522004 	addi	r5,r5,18560
81100908:	1009883a 	mov	r4,r2
8110090c:	11229940 	call	81122994 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110ac7c0 	call	8110ac7c <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	29728c04 	addi	r5,r5,-13776
81100988:	01204574 	movhi	r4,33045
8110098c:	21122004 	addi	r4,r4,18560
81100990:	11242a80 	call	811242a8 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06217 	ldw	r2,-32376(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	29522004 	addi	r5,r5,18560
811009a0:	1009883a 	mov	r4,r2
811009a4:	11229940 	call	81122994 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18d22004 	addi	r3,r3,18560
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10b29804 	addi	r2,r2,-13728
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	1123a440 	call	81123a44 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06217 	ldw	r2,-32376(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	29522004 	addi	r5,r5,18560
811009ec:	1009883a 	mov	r4,r2
811009f0:	11229940 	call	81122994 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18d22004 	addi	r3,r3,18560
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10b2a404 	addi	r2,r2,-13680
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06217 	ldw	r2,-32376(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	29522004 	addi	r5,r5,18560
81100a38:	1009883a 	mov	r4,r2
81100a3c:	11229940 	call	81122994 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18d22004 	addi	r3,r3,18560
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10b2ac04 	addi	r2,r2,-13648
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	1123a440 	call	81123a44 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06217 	ldw	r2,-32376(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	29522004 	addi	r5,r5,18560
81100a84:	1009883a 	mov	r4,r2
81100a88:	11229940 	call	81122994 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18d22004 	addi	r3,r3,18560
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10b2b604 	addi	r2,r2,-13608
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	1123a440 	call	81123a44 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06217 	ldw	r2,-32376(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	29522004 	addi	r5,r5,18560
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	11229940 	call	81122994 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18d22004 	addi	r3,r3,18560
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10b2c104 	addi	r2,r2,-13564
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	1123a440 	call	81123a44 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06217 	ldw	r2,-32376(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	29522004 	addi	r5,r5,18560
81100b1c:	1009883a 	mov	r4,r2
81100b20:	11229940 	call	81122994 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18d22004 	addi	r3,r3,18560
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10b2cd04 	addi	r2,r2,-13516
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06217 	ldw	r2,-32376(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	29522004 	addi	r5,r5,18560
81100b68:	1009883a 	mov	r4,r2
81100b6c:	11229940 	call	81122994 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18d22004 	addi	r3,r3,18560
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10b2d304 	addi	r2,r2,-13492
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06217 	ldw	r2,-32376(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	29522004 	addi	r5,r5,18560
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	11229940 	call	81122994 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18d22004 	addi	r3,r3,18560
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10b2db04 	addi	r2,r2,-13460
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	1123a440 	call	81123a44 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06217 	ldw	r2,-32376(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	29522004 	addi	r5,r5,18560
81100c00:	1009883a 	mov	r4,r2
81100c04:	11229940 	call	81122994 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18d22004 	addi	r3,r3,18560
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10b2e804 	addi	r2,r2,-13408
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06217 	ldw	r2,-32376(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	29522004 	addi	r5,r5,18560
81100c4c:	1009883a 	mov	r4,r2
81100c50:	11229940 	call	81122994 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18d22004 	addi	r3,r3,18560
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10b2ee04 	addi	r2,r2,-13384
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06217 	ldw	r2,-32376(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	29522004 	addi	r5,r5,18560
81100c98:	1009883a 	mov	r4,r2
81100c9c:	11229940 	call	81122994 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18d22004 	addi	r3,r3,18560
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10b2f304 	addi	r2,r2,-13364
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06217 	ldw	r2,-32376(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	29522004 	addi	r5,r5,18560
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	11229940 	call	81122994 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18d22004 	addi	r3,r3,18560
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10b2fa04 	addi	r2,r2,-13336
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	1123a440 	call	81123a44 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06217 	ldw	r2,-32376(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	29522004 	addi	r5,r5,18560
81100d30:	1009883a 	mov	r4,r2
81100d34:	11229940 	call	81122994 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18d22004 	addi	r3,r3,18560
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10b30804 	addi	r2,r2,-13280
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	1123a440 	call	81123a44 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06217 	ldw	r2,-32376(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	29522004 	addi	r5,r5,18560
81100d7c:	1009883a 	mov	r4,r2
81100d80:	11229940 	call	81122994 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18d22004 	addi	r3,r3,18560
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10b31a04 	addi	r2,r2,-13208
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06217 	ldw	r2,-32376(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	29522004 	addi	r5,r5,18560
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	11229940 	call	81122994 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18d22004 	addi	r3,r3,18560
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10b32204 	addi	r2,r2,-13176
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	1123a440 	call	81123a44 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06217 	ldw	r2,-32376(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	29522004 	addi	r5,r5,18560
81100e14:	1009883a 	mov	r4,r2
81100e18:	11229940 	call	81122994 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18d22004 	addi	r3,r3,18560
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10b32c04 	addi	r2,r2,-13136
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	1123a440 	call	81123a44 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06217 	ldw	r2,-32376(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	29522004 	addi	r5,r5,18560
81100e60:	1009883a 	mov	r4,r2
81100e64:	11229940 	call	81122994 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18d22004 	addi	r3,r3,18560
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10b33904 	addi	r2,r2,-13084
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	1123a440 	call	81123a44 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06217 	ldw	r2,-32376(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	29522004 	addi	r5,r5,18560
81100eac:	1009883a 	mov	r4,r2
81100eb0:	11229940 	call	81122994 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18d22004 	addi	r3,r3,18560
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10b34304 	addi	r2,r2,-13044
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	1123a440 	call	81123a44 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06217 	ldw	r2,-32376(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	29522004 	addi	r5,r5,18560
81100ef8:	1009883a 	mov	r4,r2
81100efc:	11229940 	call	81122994 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18d22004 	addi	r3,r3,18560
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10b34e04 	addi	r2,r2,-13000
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	1123a440 	call	81123a44 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06217 	ldw	r2,-32376(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	29522004 	addi	r5,r5,18560
81100f44:	1009883a 	mov	r4,r2
81100f48:	11229940 	call	81122994 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18d22004 	addi	r3,r3,18560
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10b35f04 	addi	r2,r2,-12932
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	1123a440 	call	81123a44 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06217 	ldw	r2,-32376(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	29522004 	addi	r5,r5,18560
81100f90:	1009883a 	mov	r4,r2
81100f94:	11229940 	call	81122994 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18d22004 	addi	r3,r3,18560
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10b36a04 	addi	r2,r2,-12888
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	1123a440 	call	81123a44 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06217 	ldw	r2,-32376(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	29522004 	addi	r5,r5,18560
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	11229940 	call	81122994 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18d22004 	addi	r3,r3,18560
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10b37704 	addi	r2,r2,-12836
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	1123a440 	call	81123a44 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06217 	ldw	r2,-32376(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	29522004 	addi	r5,r5,18560
81101028:	1009883a 	mov	r4,r2
8110102c:	11229940 	call	81122994 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18d22004 	addi	r3,r3,18560
81101048:	00a04574 	movhi	r2,33045
8110104c:	10b38504 	addi	r2,r2,-12780
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	1123a440 	call	81123a44 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06217 	ldw	r2,-32376(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	29522004 	addi	r5,r5,18560
81101074:	1009883a 	mov	r4,r2
81101078:	11229940 	call	81122994 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18d22004 	addi	r3,r3,18560
81101094:	00a04574 	movhi	r2,33045
81101098:	10b39204 	addi	r2,r2,-12728
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	1123a440 	call	81123a44 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06217 	ldw	r2,-32376(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	29522004 	addi	r5,r5,18560
811010c0:	1009883a 	mov	r4,r2
811010c4:	11229940 	call	81122994 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18d22004 	addi	r3,r3,18560
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10b39f04 	addi	r2,r2,-12676
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06217 	ldw	r2,-32376(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	29522004 	addi	r5,r5,18560
8110110c:	1009883a 	mov	r4,r2
81101110:	11229940 	call	81122994 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10922004 	addi	r2,r2,18560
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06217 	ldw	r2,-32376(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	29522004 	addi	r5,r5,18560
81101194:	1009883a 	mov	r4,r2
81101198:	11229940 	call	81122994 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18d22004 	addi	r3,r3,18560
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10b3a304 	addi	r2,r2,-12660
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06217 	ldw	r2,-32376(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	29522004 	addi	r5,r5,18560
811011e0:	1009883a 	mov	r4,r2
811011e4:	11229940 	call	81122994 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18d22004 	addi	r3,r3,18560
81101200:	00a04574 	movhi	r2,33045
81101204:	10b3ab04 	addi	r2,r2,-12628
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	1123a440 	call	81123a44 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06217 	ldw	r2,-32376(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	29522004 	addi	r5,r5,18560
8110122c:	1009883a 	mov	r4,r2
81101230:	11229940 	call	81122994 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18d22004 	addi	r3,r3,18560
8110124c:	00a04574 	movhi	r2,33045
81101250:	10b3b904 	addi	r2,r2,-12572
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06217 	ldw	r2,-32376(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	29522004 	addi	r5,r5,18560
81101278:	1009883a 	mov	r4,r2
8110127c:	11229940 	call	81122994 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18d22004 	addi	r3,r3,18560
81101298:	00a04574 	movhi	r2,33045
8110129c:	10b3c104 	addi	r2,r2,-12540
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06217 	ldw	r2,-32376(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	29522004 	addi	r5,r5,18560
811012c4:	1009883a 	mov	r4,r2
811012c8:	11229940 	call	81122994 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18d22004 	addi	r3,r3,18560
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10b3c904 	addi	r2,r2,-12508
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	1123a440 	call	81123a44 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06217 	ldw	r2,-32376(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	29522004 	addi	r5,r5,18560
81101310:	1009883a 	mov	r4,r2
81101314:	11229940 	call	81122994 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18d22004 	addi	r3,r3,18560
81101330:	00a04574 	movhi	r2,33045
81101334:	10b3d304 	addi	r2,r2,-12468
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06217 	ldw	r2,-32376(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	29522004 	addi	r5,r5,18560
8110135c:	1009883a 	mov	r4,r2
81101360:	11229940 	call	81122994 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18d22004 	addi	r3,r3,18560
8110137c:	00a04574 	movhi	r2,33045
81101380:	10b3da04 	addi	r2,r2,-12440
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	1123a440 	call	81123a44 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06217 	ldw	r2,-32376(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	29522004 	addi	r5,r5,18560
811013a8:	1009883a 	mov	r4,r2
811013ac:	11229940 	call	81122994 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18d22004 	addi	r3,r3,18560
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10b3e404 	addi	r2,r2,-12400
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06217 	ldw	r2,-32376(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	29522004 	addi	r5,r5,18560
811013f4:	1009883a 	mov	r4,r2
811013f8:	11229940 	call	81122994 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10922004 	addi	r2,r2,18560
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06217 	ldw	r2,-32376(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	29522004 	addi	r5,r5,18560
81101420:	1009883a 	mov	r4,r2
81101424:	11229940 	call	81122994 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18d22004 	addi	r3,r3,18560
81101454:	00a04574 	movhi	r2,33045
81101458:	10b3ee04 	addi	r2,r2,-12360
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06217 	ldw	r2,-32376(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	29522004 	addi	r5,r5,18560
81101480:	1009883a 	mov	r4,r2
81101484:	11229940 	call	81122994 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10922004 	addi	r2,r2,18560
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06217 	ldw	r2,-32376(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	29522004 	addi	r5,r5,18560
811014a8:	1009883a 	mov	r4,r2
811014ac:	11229940 	call	81122994 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18d22004 	addi	r3,r3,18560
81101538:	00a04574 	movhi	r2,33045
8110153c:	10b3f404 	addi	r2,r2,-12336
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06217 	ldw	r2,-32376(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	29522004 	addi	r5,r5,18560
81101564:	1009883a 	mov	r4,r2
81101568:	11229940 	call	81122994 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18d22004 	addi	r3,r3,18560
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10b40304 	addi	r2,r2,-12276
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06217 	ldw	r2,-32376(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	29522004 	addi	r5,r5,18560
811015e0:	1009883a 	mov	r4,r2
811015e4:	11229940 	call	81122994 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18d22004 	addi	r3,r3,18560
81101648:	00a04574 	movhi	r2,33045
8110164c:	10b21404 	addi	r2,r2,-14256
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06217 	ldw	r2,-32376(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	29522004 	addi	r5,r5,18560
81101674:	1009883a 	mov	r4,r2
81101678:	11229940 	call	81122994 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	29740d04 	addi	r5,r5,-12236
81101698:	01204574 	movhi	r4,33045
8110169c:	21122004 	addi	r4,r4,18560
811016a0:	11242a80 	call	811242a8 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06217 	ldw	r2,-32376(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	29522004 	addi	r5,r5,18560
811016b0:	1009883a 	mov	r4,r2
811016b4:	11229940 	call	81122994 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10926004 	addi	r2,r2,18816
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10926004 	addi	r2,r2,18816
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10926004 	addi	r2,r2,18816
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10926004 	addi	r2,r2,18816
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10926004 	addi	r2,r2,18816
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10926004 	addi	r2,r2,18816
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10926004 	addi	r2,r2,18816
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18d22004 	addi	r3,r3,18560
81101868:	00a04574 	movhi	r2,33045
8110186c:	10b41304 	addi	r2,r2,-12212
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06217 	ldw	r2,-32376(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	29522004 	addi	r5,r5,18560
81101894:	1009883a 	mov	r4,r2
81101898:	11229940 	call	81122994 <fprintf>
8110189c:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29526004 	addi	r5,r5,18816
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	1123a440 	call	81123a44 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	29741804 	addi	r5,r5,-12192
81101994:	01204574 	movhi	r4,33045
81101998:	21122004 	addi	r4,r4,18560
8110199c:	11242a80 	call	811242a8 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06217 	ldw	r2,-32376(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	29522004 	addi	r5,r5,18560
811019ac:	1009883a 	mov	r4,r2
811019b0:	11229940 	call	81122994 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11378080 	call	81137808 <alt_dcache_flush_all>
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10922004 	addi	r2,r2,18560
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06217 	ldw	r2,-32376(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	29522004 	addi	r5,r5,18560
811019e4:	1009883a 	mov	r4,r2
811019e8:	11229940 	call	81122994 <fprintf>
811019ec:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#if DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	112108c0 	call	8112108c <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08817 	ldw	r2,-32224(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	11211b80 	call	811211b8 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	11208400 	call	81120840 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	11225140 	call	81122514 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	29741a04 	addi	r5,r5,-12184
81101a58:	01204574 	movhi	r4,33045
81101a5c:	21122004 	addi	r4,r4,18560
81101a60:	11242a80 	call	811242a8 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06217 	ldw	r2,-32376(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	29522004 	addi	r5,r5,18560
81101a70:	1009883a 	mov	r4,r2
81101a74:	11229940 	call	81122994 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18d22004 	addi	r3,r3,18560
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10b42604 	addi	r2,r2,-12136
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06217 	ldw	r2,-32376(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	29522004 	addi	r5,r5,18560
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	11229940 	call	81122994 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10922004 	addi	r2,r2,18560
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06217 	ldw	r2,-32376(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	29522004 	addi	r5,r5,18560
81101ad8:	1009883a 	mov	r4,r2
81101adc:	11229940 	call	81122994 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18d22004 	addi	r3,r3,18560
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10b42c04 	addi	r2,r2,-12112
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06217 	ldw	r2,-32376(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	29522004 	addi	r5,r5,18560
81101b5c:	1009883a 	mov	r4,r2
81101b60:	11229940 	call	81122994 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18d22004 	addi	r3,r3,18560
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10b21404 	addi	r2,r2,-14256
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06217 	ldw	r2,-32376(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	29522004 	addi	r5,r5,18560
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	11229940 	call	81122994 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	29743604 	addi	r5,r5,-12072
81101c14:	01204574 	movhi	r4,33045
81101c18:	21122004 	addi	r4,r4,18560
81101c1c:	11242a80 	call	811242a8 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29522004 	addi	r5,r5,18560
81101c2c:	1009883a 	mov	r4,r2
81101c30:	11229940 	call	81122994 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18d22004 	addi	r3,r3,18560
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10b43c04 	addi	r2,r2,-12048
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06217 	ldw	r2,-32376(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	29522004 	addi	r5,r5,18560
81101cfc:	1009883a 	mov	r4,r2
81101d00:	11229940 	call	81122994 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10926004 	addi	r2,r2,18816
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10926004 	addi	r2,r2,18816
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	29744304 	addi	r5,r5,-12020
81101df8:	01204574 	movhi	r4,33045
81101dfc:	21122004 	addi	r4,r4,18560
81101e00:	11242a80 	call	811242a8 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06217 	ldw	r2,-32376(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	29522004 	addi	r5,r5,18560
81101e10:	1009883a 	mov	r4,r2
81101e14:	11229940 	call	81122994 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	29741804 	addi	r5,r5,-12192
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	21122004 	addi	r4,r4,18560
81101ea4:	11242a80 	call	811242a8 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06217 	ldw	r2,-32376(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	29522004 	addi	r5,r5,18560
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	11229940 	call	81122994 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10922004 	addi	r2,r2,18560
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29522004 	addi	r5,r5,18560
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	11229940 	call	81122994 <fprintf>
81101ef8:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	112108c0 	call	8112108c <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08817 	ldw	r2,-32224(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	11211b80 	call	811211b8 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	11208400 	call	81120840 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	11225140 	call	81122514 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	29745104 	addi	r5,r5,-11964
81101f64:	01204574 	movhi	r4,33045
81101f68:	21122004 	addi	r4,r4,18560
81101f6c:	11242a80 	call	811242a8 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06217 	ldw	r2,-32376(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	29522004 	addi	r5,r5,18560
81101f7c:	1009883a 	mov	r4,r2
81101f80:	11229940 	call	81122994 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18d22004 	addi	r3,r3,18560
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10b45d04 	addi	r2,r2,-11916
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06217 	ldw	r2,-32376(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	29522004 	addi	r5,r5,18560
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	11229940 	call	81122994 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10922004 	addi	r2,r2,18560
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06217 	ldw	r2,-32376(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	29522004 	addi	r5,r5,18560
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	11229940 	call	81122994 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18d22004 	addi	r3,r3,18560
8110204c:	00a04574 	movhi	r2,33045
81102050:	10b46304 	addi	r2,r2,-11892
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06217 	ldw	r2,-32376(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	29522004 	addi	r5,r5,18560
81102078:	1009883a 	mov	r4,r2
8110207c:	11229940 	call	81122994 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18d22004 	addi	r3,r3,18560
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10b21404 	addi	r2,r2,-14256
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06217 	ldw	r2,-32376(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	29522004 	addi	r5,r5,18560
8110210c:	1009883a 	mov	r4,r2
81102110:	11229940 	call	81122994 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	29740d04 	addi	r5,r5,-12236
81102130:	01204574 	movhi	r4,33045
81102134:	21122004 	addi	r4,r4,18560
81102138:	11242a80 	call	811242a8 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06217 	ldw	r2,-32376(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	29522004 	addi	r5,r5,18560
81102148:	1009883a 	mov	r4,r2
8110214c:	11229940 	call	81122994 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18d22004 	addi	r3,r3,18560
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10b46f04 	addi	r2,r2,-11844
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06217 	ldw	r2,-32376(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	29522004 	addi	r5,r5,18560
811021d8:	1009883a 	mov	r4,r2
811021dc:	11229940 	call	81122994 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	29747504 	addi	r5,r5,-11820
811021f4:	01204574 	movhi	r4,33045
811021f8:	21122004 	addi	r4,r4,18560
811021fc:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06217 	ldw	r2,-32376(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	29522004 	addi	r5,r5,18560
8110220c:	1009883a 	mov	r4,r2
81102210:	11229940 	call	81122994 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	29747704 	addi	r5,r5,-11812
81102278:	01204574 	movhi	r4,33045
8110227c:	21122004 	addi	r4,r4,18560
81102280:	11242a80 	call	811242a8 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06217 	ldw	r2,-32376(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	29522004 	addi	r5,r5,18560
81102290:	1009883a 	mov	r4,r2
81102294:	11229940 	call	81122994 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11378080 	call	81137808 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	29747a04 	addi	r5,r5,-11800
81102300:	01204574 	movhi	r4,33045
81102304:	21122004 	addi	r4,r4,18560
81102308:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06217 	ldw	r2,-32376(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	29522004 	addi	r5,r5,18560
81102318:	1009883a 	mov	r4,r2
8110231c:	11229940 	call	81122994 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	112108c0 	call	8112108c <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08817 	ldw	r2,-32224(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	11211b80 	call	811211b8 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	11208400 	call	81120840 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	11225140 	call	81122514 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	29747d04 	addi	r5,r5,-11788
81102398:	01204574 	movhi	r4,33045
8110239c:	21122004 	addi	r4,r4,18560
811023a0:	11242a80 	call	811242a8 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06217 	ldw	r2,-32376(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	29522004 	addi	r5,r5,18560
811023b0:	1009883a 	mov	r4,r2
811023b4:	11229940 	call	81122994 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	29748904 	addi	r5,r5,-11740
811023c8:	01204574 	movhi	r4,33045
811023cc:	21122004 	addi	r4,r4,18560
811023d0:	11242a80 	call	811242a8 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06217 	ldw	r2,-32376(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	29522004 	addi	r5,r5,18560
811023e0:	1009883a 	mov	r4,r2
811023e4:	11229940 	call	81122994 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18d22004 	addi	r3,r3,18560
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10b42604 	addi	r2,r2,-12136
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06217 	ldw	r2,-32376(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	29522004 	addi	r5,r5,18560
81102420:	1009883a 	mov	r4,r2
81102424:	11229940 	call	81122994 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10922004 	addi	r2,r2,18560
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06217 	ldw	r2,-32376(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	29522004 	addi	r5,r5,18560
81102448:	1009883a 	mov	r4,r2
8110244c:	11229940 	call	81122994 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18d22004 	addi	r3,r3,18560
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10b49304 	addi	r2,r2,-11700
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06217 	ldw	r2,-32376(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	29522004 	addi	r5,r5,18560
811024e4:	1009883a 	mov	r4,r2
811024e8:	11229940 	call	81122994 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18d22004 	addi	r3,r3,18560
8110254c:	00a04574 	movhi	r2,33045
81102550:	10b21404 	addi	r2,r2,-14256
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	1123a440 	call	81123a44 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06217 	ldw	r2,-32376(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	29522004 	addi	r5,r5,18560
81102578:	1009883a 	mov	r4,r2
8110257c:	11229940 	call	81122994 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	29740d04 	addi	r5,r5,-12236
8110259c:	01204574 	movhi	r4,33045
811025a0:	21122004 	addi	r4,r4,18560
811025a4:	11242a80 	call	811242a8 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06217 	ldw	r2,-32376(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	29522004 	addi	r5,r5,18560
811025b4:	1009883a 	mov	r4,r2
811025b8:	11229940 	call	81122994 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18d22004 	addi	r3,r3,18560
81102610:	00a04574 	movhi	r2,33045
81102614:	10b49f04 	addi	r2,r2,-11652
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	1123a440 	call	81123a44 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06217 	ldw	r2,-32376(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	29522004 	addi	r5,r5,18560
8110263c:	1009883a 	mov	r4,r2
81102640:	11229940 	call	81122994 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	29747504 	addi	r5,r5,-11820
81102658:	01204574 	movhi	r4,33045
8110265c:	21122004 	addi	r4,r4,18560
81102660:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06217 	ldw	r2,-32376(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	29522004 	addi	r5,r5,18560
81102670:	1009883a 	mov	r4,r2
81102674:	11229940 	call	81122994 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#if DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	2974a504 	addi	r5,r5,-11628
811026cc:	01204574 	movhi	r4,33045
811026d0:	21122004 	addi	r4,r4,18560
811026d4:	11242a80 	call	811242a8 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06217 	ldw	r2,-32376(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	29522004 	addi	r5,r5,18560
811026e4:	1009883a 	mov	r4,r2
811026e8:	11229940 	call	81122994 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	29747704 	addi	r5,r5,-11812
81102714:	01204574 	movhi	r4,33045
81102718:	21122004 	addi	r4,r4,18560
8110271c:	11242a80 	call	811242a8 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06217 	ldw	r2,-32376(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	29522004 	addi	r5,r5,18560
8110272c:	1009883a 	mov	r4,r2
81102730:	11229940 	call	81122994 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	29747a04 	addi	r5,r5,-11800
81102798:	01204574 	movhi	r4,33045
8110279c:	21122004 	addi	r4,r4,18560
811027a0:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06217 	ldw	r2,-32376(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	29522004 	addi	r5,r5,18560
811027b0:	1009883a 	mov	r4,r2
811027b4:	11229940 	call	81122994 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	112108c0 	call	8112108c <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08817 	ldw	r2,-32224(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	11211b80 	call	811211b8 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	11208400 	call	81120840 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	11225140 	call	81122514 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	2974ad04 	addi	r5,r5,-11596
81102830:	01204574 	movhi	r4,33045
81102834:	21122004 	addi	r4,r4,18560
81102838:	11242a80 	call	811242a8 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06217 	ldw	r2,-32376(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	29522004 	addi	r5,r5,18560
81102848:	1009883a 	mov	r4,r2
8110284c:	11229940 	call	81122994 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	2974b904 	addi	r5,r5,-11548
81102860:	01204574 	movhi	r4,33045
81102864:	21122004 	addi	r4,r4,18560
81102868:	11242a80 	call	811242a8 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06217 	ldw	r2,-32376(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	29522004 	addi	r5,r5,18560
81102878:	1009883a 	mov	r4,r2
8110287c:	11229940 	call	81122994 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18d22004 	addi	r3,r3,18560
8110288c:	00a04574 	movhi	r2,33045
81102890:	10b45d04 	addi	r2,r2,-11916
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06217 	ldw	r2,-32376(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	29522004 	addi	r5,r5,18560
811028b8:	1009883a 	mov	r4,r2
811028bc:	11229940 	call	81122994 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10922004 	addi	r2,r2,18560
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06217 	ldw	r2,-32376(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	29522004 	addi	r5,r5,18560
811028e0:	1009883a 	mov	r4,r2
811028e4:	11229940 	call	81122994 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	114b0c80 	call	8114b0c8 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	11390300 	call	81139030 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	11390300 	call	81139030 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	11390300 	call	81139030 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	11390300 	call	81139030 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	114a0c40 	call	8114a0c4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	114b3380 	call	8114b338 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	11390300 	call	81139030 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	11390300 	call	81139030 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	114a0c40 	call	8114a0c4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	114b3380 	call	8114b338 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	114a0c40 	call	8114a0c4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	114b3380 	call	8114b338 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	11390300 	call	81139030 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	11390300 	call	81139030 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110be400 	call	8110be40 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110be400 	call	8110be40 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	2974c304 	addi	r5,r5,-11508
811030d4:	01204574 	movhi	r4,33045
811030d8:	21122004 	addi	r4,r4,18560
811030dc:	11242a80 	call	811242a8 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06217 	ldw	r2,-32376(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	29522004 	addi	r5,r5,18560
811030ec:	1009883a 	mov	r4,r2
811030f0:	11229940 	call	81122994 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#if DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	2974c904 	addi	r5,r5,-11484
81103120:	01204574 	movhi	r4,33045
81103124:	21122004 	addi	r4,r4,18560
81103128:	11242a80 	call	811242a8 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06217 	ldw	r2,-32376(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	29522004 	addi	r5,r5,18560
81103138:	1009883a 	mov	r4,r2
8110313c:	11229940 	call	81122994 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	2974d504 	addi	r5,r5,-11436
81103160:	01204574 	movhi	r4,33045
81103164:	21122004 	addi	r4,r4,18560
81103168:	11242a80 	call	811242a8 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06217 	ldw	r2,-32376(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	29522004 	addi	r5,r5,18560
81103178:	1009883a 	mov	r4,r2
8110317c:	11229940 	call	81122994 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18d22004 	addi	r3,r3,18560
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10b4db04 	addi	r2,r2,-11412
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	1123a440 	call	81123a44 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06217 	ldw	r2,-32376(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	29522004 	addi	r5,r5,18560
811031ec:	1009883a 	mov	r4,r2
811031f0:	11229940 	call	81122994 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110ab740 	call	8110ab74 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110ab740 	call	8110ab74 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10b51204 	addi	r2,r2,-11192
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	1123a440 	call	81123a44 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	11211b80 	call	811211b8 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	11208400 	call	81120840 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	1120c880 	call	81120c88 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	11225140 	call	81122514 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	2974e004 	addi	r5,r5,-11392
8110365c:	01204574 	movhi	r4,33045
81103660:	21122004 	addi	r4,r4,18560
81103664:	11242a80 	call	811242a8 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06217 	ldw	r2,-32376(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	29522004 	addi	r5,r5,18560
81103674:	1009883a 	mov	r4,r2
81103678:	11229940 	call	81122994 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	11225140 	call	81122514 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	112138c0 	call	8112138c <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	11225140 	call	81122514 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	112138c0 	call	8112138c <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	112262c0 	call	8112262c <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	11208400 	call	81120840 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	1120c880 	call	81120c88 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	11225140 	call	81122514 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	11225140 	call	81122514 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	11225140 	call	81122514 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	2974e904 	addi	r5,r5,-11356
811037f4:	01204574 	movhi	r4,33045
811037f8:	21122004 	addi	r4,r4,18560
811037fc:	11242a80 	call	811242a8 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06217 	ldw	r2,-32376(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	29522004 	addi	r5,r5,18560
8110380c:	1009883a 	mov	r4,r2
81103810:	11229940 	call	81122994 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	11225140 	call	81122514 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	112138c0 	call	8112138c <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	11225140 	call	81122514 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	112138c0 	call	8112138c <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	112262c0 	call	8112262c <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	11208400 	call	81120840 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	1120c880 	call	81120c88 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	11225140 	call	81122514 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	11225140 	call	81122514 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	11225140 	call	81122514 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	2974f904 	addi	r5,r5,-11292
8110398c:	01204574 	movhi	r4,33045
81103990:	21122004 	addi	r4,r4,18560
81103994:	11242a80 	call	811242a8 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06217 	ldw	r2,-32376(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	29522004 	addi	r5,r5,18560
811039a4:	1009883a 	mov	r4,r2
811039a8:	11229940 	call	81122994 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	1120c880 	call	81120c88 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	11225140 	call	81122514 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	29750904 	addi	r5,r5,-11228
81103a34:	01204574 	movhi	r4,33045
81103a38:	21122004 	addi	r4,r4,18560
81103a3c:	11242a80 	call	811242a8 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06217 	ldw	r2,-32376(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	29522004 	addi	r5,r5,18560
81103a4c:	1009883a 	mov	r4,r2
81103a50:	11229940 	call	81122994 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#if DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10922004 	addi	r2,r2,18560
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06217 	ldw	r2,-32376(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	29522004 	addi	r5,r5,18560
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	11229940 	call	81122994 <fprintf>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10922004 	addi	r2,r2,18560
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06217 	ldw	r2,-32376(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	29522004 	addi	r5,r5,18560
81103af8:	1009883a 	mov	r4,r2
81103afc:	11229940 	call	81122994 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:
alt_msgdma_dev *pxDmaM1Dev = NULL;
alt_msgdma_dev *pxDmaM2Dev = NULL;
//! [data memory public global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffb04 	addi	sp,sp,-20
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00415 	stw	ra,16(sp)
81103b40:	df000315 	stw	fp,12(sp)
81103b44:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103b48:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103b4c:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	2135d204 	addi	r4,r4,-10424
81103b5c:	114b0c80 	call	8114b0c8 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	10001a26 	beq	r2,zero,81103bd4 <bSdmaInitM1Dma+0xa4>
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103b6c:	d0a03917 	ldw	r2,-32540(gp)
81103b70:	10800317 	ldw	r2,12(r2)
81103b74:	10800104 	addi	r2,r2,4
81103b78:	00c00084 	movi	r3,2
81103b7c:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103b80:	00000b06 	br	81103bb0 <bSdmaInitM1Dma+0x80>
			usleep(1);
81103b84:	01000044 	movi	r4,1
81103b88:	11390300 	call	81139030 <usleep>
			usiCounter++;
81103b8c:	e0bfff0b 	ldhu	r2,-4(fp)
81103b90:	10800044 	addi	r2,r2,1
81103b94:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103b98:	e0bfff0b 	ldhu	r2,-4(fp)
81103b9c:	1084e230 	cmpltui	r2,r2,5000
81103ba0:	1000031e 	bne	r2,zero,81103bb0 <bSdmaInitM1Dma+0x80>
				bFailDispatcher = TRUE;
81103ba4:	00800044 	movi	r2,1
81103ba8:	e0bffe15 	stw	r2,-8(fp)
				break;
81103bac:	00000506 	br	81103bc4 <bSdmaInitM1Dma+0x94>
	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bb0:	d0a03917 	ldw	r2,-32540(gp)
81103bb4:	10800317 	ldw	r2,12(r2)
81103bb8:	10800037 	ldwio	r2,0(r2)
81103bbc:	1080100c 	andi	r2,r2,64
81103bc0:	103ff01e 	bne	r2,zero,81103b84 <__reset+0xfb0e3b84>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103bc4:	e0bffe17 	ldw	r2,-8(fp)
81103bc8:	1000021e 	bne	r2,zero,81103bd4 <bSdmaInitM1Dma+0xa4>
			bStatus = TRUE;
81103bcc:	00800044 	movi	r2,1
81103bd0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81103bd4:	e0bffd17 	ldw	r2,-12(fp)
}
81103bd8:	e037883a 	mov	sp,fp
81103bdc:	dfc00117 	ldw	ra,4(sp)
81103be0:	df000017 	ldw	fp,0(sp)
81103be4:	dec00204 	addi	sp,sp,8
81103be8:	f800283a 	ret

81103bec <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103bec:	defffb04 	addi	sp,sp,-20
81103bf0:	de00012e 	bgeu	sp,et,81103bf8 <bSdmaInitM2Dma+0xc>
81103bf4:	003b68fa 	trap	3
81103bf8:	dfc00415 	stw	ra,16(sp)
81103bfc:	df000315 	stw	fp,12(sp)
81103c00:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103c04:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103c08:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103c0c:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c10:	01204574 	movhi	r4,33045
81103c14:	2135d704 	addi	r4,r4,-10404
81103c18:	114b0c80 	call	8114b0c8 <alt_msgdma_open>
81103c1c:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c20:	d0a03a17 	ldw	r2,-32536(gp)
81103c24:	1000021e 	bne	r2,zero,81103c30 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c28:	e03ffd15 	stw	zero,-12(fp)
81103c2c:	00001a06 	br	81103c98 <bSdmaInitM2Dma+0xac>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103c30:	d0a03a17 	ldw	r2,-32536(gp)
81103c34:	10800317 	ldw	r2,12(r2)
81103c38:	10800104 	addi	r2,r2,4
81103c3c:	00c00084 	movi	r3,2
81103c40:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c44:	00000b06 	br	81103c74 <bSdmaInitM2Dma+0x88>
			usleep(1);
81103c48:	01000044 	movi	r4,1
81103c4c:	11390300 	call	81139030 <usleep>
			usiCounter++;
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	10800044 	addi	r2,r2,1
81103c58:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c5c:	e0bfff0b 	ldhu	r2,-4(fp)
81103c60:	1084e230 	cmpltui	r2,r2,5000
81103c64:	1000031e 	bne	r2,zero,81103c74 <bSdmaInitM2Dma+0x88>
				bFailDispatcher = TRUE;
81103c68:	00800044 	movi	r2,1
81103c6c:	e0bffe15 	stw	r2,-8(fp)
				break;
81103c70:	00000506 	br	81103c88 <bSdmaInitM2Dma+0x9c>
		bStatus = FALSE;
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c74:	d0a03a17 	ldw	r2,-32536(gp)
81103c78:	10800317 	ldw	r2,12(r2)
81103c7c:	10800037 	ldwio	r2,0(r2)
81103c80:	1080100c 	andi	r2,r2,64
81103c84:	103ff01e 	bne	r2,zero,81103c48 <__reset+0xfb0e3c48>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103c88:	e0bffe17 	ldw	r2,-8(fp)
81103c8c:	1000021e 	bne	r2,zero,81103c98 <bSdmaInitM2Dma+0xac>
			bStatus = TRUE;
81103c90:	00800044 	movi	r2,1
81103c94:	e0bffd15 	stw	r2,-12(fp)
	}
	return bStatus;
81103c98:	e0bffd17 	ldw	r2,-12(fp)
}
81103c9c:	e037883a 	mov	sp,fp
81103ca0:	dfc00117 	ldw	ra,4(sp)
81103ca4:	df000017 	ldw	fp,0(sp)
81103ca8:	dec00204 	addi	sp,sp,8
81103cac:	f800283a 	ret

81103cb0 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81103cb0:	deffe804 	addi	sp,sp,-96
81103cb4:	de00012e 	bgeu	sp,et,81103cbc <bSdmaDmaM1Transfer+0xc>
81103cb8:	003b68fa 	trap	3
81103cbc:	dfc01715 	stw	ra,92(sp)
81103cc0:	df001615 	stw	fp,88(sp)
81103cc4:	dc001515 	stw	r16,84(sp)
81103cc8:	df001604 	addi	fp,sp,88
81103ccc:	e13ffb15 	stw	r4,-20(fp)
81103cd0:	2809883a 	mov	r4,r5
81103cd4:	3007883a 	mov	r3,r6
81103cd8:	3805883a 	mov	r2,r7
81103cdc:	e13ffc0d 	sth	r4,-16(fp)
81103ce0:	e0fffd05 	stb	r3,-12(fp)
81103ce4:	e0bffe05 	stb	r2,-8(fp)
81103ce8:	defff004 	addi	sp,sp,-64
81103cec:	d8800904 	addi	r2,sp,36
81103cf0:	108007c4 	addi	r2,r2,31
81103cf4:	1004d17a 	srli	r2,r2,5
81103cf8:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103cfc:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103d00:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103d04:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103d08:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103d0c:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;

	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81103d10:	00800044 	movi	r2,1
81103d14:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
81103d18:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
81103d1c:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
81103d20:	e0bffe03 	ldbu	r2,-8(fp)
81103d24:	10c00228 	cmpgeui	r3,r2,8
81103d28:	1800b81e 	bne	r3,zero,8110400c <bSdmaDmaM1Transfer+0x35c>
81103d2c:	100690ba 	slli	r3,r2,2
81103d30:	00a04434 	movhi	r2,33040
81103d34:	108f5104 	addi	r2,r2,15684
81103d38:	1885883a 	add	r2,r3,r2
81103d3c:	10800017 	ldw	r2,0(r2)
81103d40:	1000683a 	jmp	r2
81103d44:	81103d64 	muli	r4,r16,16629
81103d48:	81103db8 	rdprs	r4,r16,16630
81103d4c:	81103e14 	ori	r4,r16,16632
81103d50:	81103e68 	cmpgeui	r4,r16,16633
81103d54:	81103ebc 	xorhi	r4,r16,16634
81103d58:	81103f10 	cmplti	r4,r16,16636
81103d5c:	81103f64 	muli	r4,r16,16637
81103d60:	81103fb8 	rdprs	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d64:	e0bffd03 	ldbu	r2,-12(fp)
81103d68:	10000826 	beq	r2,zero,81103d8c <bSdmaDmaM1Transfer+0xdc>
81103d6c:	10800060 	cmpeqi	r2,r2,1
81103d70:	10000d26 	beq	r2,zero,81103da8 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d74:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d78:	00800044 	movi	r2,1
81103d7c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d80:	11064c00 	call	811064c0 <bFeebGetCh1RightBufferEmpty>
81103d84:	e0bff615 	stw	r2,-40(fp)
			break;
81103d88:	00000a06 	br	81103db4 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d8c:	00800074 	movhi	r2,1
81103d90:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d94:	00800044 	movi	r2,1
81103d98:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d9c:	11064580 	call	81106458 <bFeebGetCh1LeftBufferEmpty>
81103da0:	e0bff615 	stw	r2,-40(fp)
			break;
81103da4:	00000306 	br	81103db4 <bSdmaDmaM1Transfer+0x104>
		default:
			bChannelFlag = FALSE;
81103da8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103dac:	e03ff615 	stw	zero,-40(fp)
			break;
81103db0:	0001883a 	nop
		}
		break;
81103db4:	00009706 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103db8:	e0bffd03 	ldbu	r2,-12(fp)
81103dbc:	10000926 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x134>
81103dc0:	10800060 	cmpeqi	r2,r2,1
81103dc4:	10000f26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103dc8:	00880004 	movi	r2,8192
81103dcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103dd8:	11065900 	call	81106590 <bFeebGetCh2RightBufferEmpty>
81103ddc:	e0bff615 	stw	r2,-40(fp)
			break;
81103de0:	00000b06 	br	81103e10 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103de4:	00800074 	movhi	r2,1
81103de8:	10880004 	addi	r2,r2,8192
81103dec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103df0:	00800044 	movi	r2,1
81103df4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103df8:	11065280 	call	81106528 <bFeebGetCh2LeftBufferEmpty>
81103dfc:	e0bff615 	stw	r2,-40(fp)
			break;
81103e00:	00000306 	br	81103e10 <bSdmaDmaM1Transfer+0x160>
		default:
			bChannelFlag = FALSE;
81103e04:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e08:	e03ff615 	stw	zero,-40(fp)
			break;
81103e0c:	0001883a 	nop
		}
		break;
81103e10:	00008006 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103e14:	e0bffd03 	ldbu	r2,-12(fp)
81103e18:	10000826 	beq	r2,zero,81103e3c <bSdmaDmaM1Transfer+0x18c>
81103e1c:	10800060 	cmpeqi	r2,r2,1
81103e20:	10000d26 	beq	r2,zero,81103e58 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e24:	00900004 	movi	r2,16384
81103e28:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e2c:	00800044 	movi	r2,1
81103e30:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e34:	e03ff615 	stw	zero,-40(fp)
			break;
81103e38:	00000a06 	br	81103e64 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e3c:	00800074 	movhi	r2,1
81103e40:	10900004 	addi	r2,r2,16384
81103e44:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e48:	00800044 	movi	r2,1
81103e4c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e50:	e03ff615 	stw	zero,-40(fp)
			break;
81103e54:	00000306 	br	81103e64 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
81103e58:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e5c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e60:	0001883a 	nop
		}
		break;
81103e64:	00006b06 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e68:	e0bffd03 	ldbu	r2,-12(fp)
81103e6c:	10000826 	beq	r2,zero,81103e90 <bSdmaDmaM1Transfer+0x1e0>
81103e70:	10800060 	cmpeqi	r2,r2,1
81103e74:	10000d26 	beq	r2,zero,81103eac <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e78:	00980004 	movi	r2,24576
81103e7c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e80:	00800044 	movi	r2,1
81103e84:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e88:	e03ff615 	stw	zero,-40(fp)
			break;
81103e8c:	00000a06 	br	81103eb8 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e90:	00800074 	movhi	r2,1
81103e94:	10980004 	addi	r2,r2,24576
81103e98:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e9c:	00800044 	movi	r2,1
81103ea0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ea4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ea8:	00000306 	br	81103eb8 <bSdmaDmaM1Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81103eac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103eb0:	e03ff615 	stw	zero,-40(fp)
			break;
81103eb4:	0001883a 	nop
		}
		break;
81103eb8:	00005606 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103ebc:	e0bffd03 	ldbu	r2,-12(fp)
81103ec0:	10000826 	beq	r2,zero,81103ee4 <bSdmaDmaM1Transfer+0x234>
81103ec4:	10800060 	cmpeqi	r2,r2,1
81103ec8:	10000d26 	beq	r2,zero,81103f00 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103ecc:	00a00014 	movui	r2,32768
81103ed0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103ed4:	00800044 	movi	r2,1
81103ed8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103edc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee0:	00000a06 	br	81103f0c <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ee4:	008000b4 	movhi	r2,2
81103ee8:	10a00004 	addi	r2,r2,-32768
81103eec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ef0:	00800044 	movi	r2,1
81103ef4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ef8:	e03ff615 	stw	zero,-40(fp)
			break;
81103efc:	00000306 	br	81103f0c <bSdmaDmaM1Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
81103f00:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f04:	e03ff615 	stw	zero,-40(fp)
			break;
81103f08:	0001883a 	nop
		}
		break;
81103f0c:	00004106 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103f10:	e0bffd03 	ldbu	r2,-12(fp)
81103f14:	10000826 	beq	r2,zero,81103f38 <bSdmaDmaM1Transfer+0x288>
81103f18:	10800060 	cmpeqi	r2,r2,1
81103f1c:	10000d26 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f20:	00a80014 	movui	r2,40960
81103f24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f28:	00800044 	movi	r2,1
81103f2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f30:	e03ff615 	stw	zero,-40(fp)
			break;
81103f34:	00000a06 	br	81103f60 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f38:	008000b4 	movhi	r2,2
81103f3c:	10a80004 	addi	r2,r2,-24576
81103f40:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f44:	00800044 	movi	r2,1
81103f48:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f4c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f50:	00000306 	br	81103f60 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
81103f54:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f58:	e03ff615 	stw	zero,-40(fp)
			break;
81103f5c:	0001883a 	nop
		}
		break;
81103f60:	00002c06 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f64:	e0bffd03 	ldbu	r2,-12(fp)
81103f68:	10000826 	beq	r2,zero,81103f8c <bSdmaDmaM1Transfer+0x2dc>
81103f6c:	10800060 	cmpeqi	r2,r2,1
81103f70:	10000d26 	beq	r2,zero,81103fa8 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f74:	00b00014 	movui	r2,49152
81103f78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f7c:	00800044 	movi	r2,1
81103f80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f84:	e03ff615 	stw	zero,-40(fp)
			break;
81103f88:	00000a06 	br	81103fb4 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f8c:	008000b4 	movhi	r2,2
81103f90:	10b00004 	addi	r2,r2,-16384
81103f94:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f98:	00800044 	movi	r2,1
81103f9c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fa0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fa4:	00000306 	br	81103fb4 <bSdmaDmaM1Transfer+0x304>
		default:
			bChannelFlag = FALSE;
81103fa8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103fac:	e03ff615 	stw	zero,-40(fp)
			break;
81103fb0:	0001883a 	nop
		}
		break;
81103fb4:	00001706 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103fb8:	e0bffd03 	ldbu	r2,-12(fp)
81103fbc:	10000826 	beq	r2,zero,81103fe0 <bSdmaDmaM1Transfer+0x330>
81103fc0:	10800060 	cmpeqi	r2,r2,1
81103fc4:	10000d26 	beq	r2,zero,81103ffc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fc8:	00b80014 	movui	r2,57344
81103fcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fd0:	00800044 	movi	r2,1
81103fd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fdc:	00000a06 	br	81104008 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fe0:	008000b4 	movhi	r2,2
81103fe4:	10b80004 	addi	r2,r2,-8192
81103fe8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fec:	00800044 	movi	r2,1
81103ff0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ff4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ff8:	00000306 	br	81104008 <bSdmaDmaM1Transfer+0x358>
		default:
			bChannelFlag = FALSE;
81103ffc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104000:	e03ff615 	stw	zero,-40(fp)
			break;
81104004:	0001883a 	nop
		}
		break;
81104008:	00000206 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	default:
		bChannelFlag = FALSE;
8110400c:	e03ff715 	stw	zero,-36(fp)
		break;
81104010:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW	+ (alt_u32) uliDdrInitialAddr;
81104014:	e0bffb17 	ldw	r2,-20(fp)
81104018:	e0bff815 	stw	r2,-32(fp)
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
8110401c:	e03ff915 	stw	zero,-28(fp)

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104020:	e0bff717 	ldw	r2,-36(fp)
81104024:	10003026 	beq	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
81104028:	e0bff617 	ldw	r2,-40(fp)
8110402c:	10002e26 	beq	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
81104030:	e0bffc0b 	ldhu	r2,-16(fp)
81104034:	10800468 	cmpgeui	r2,r2,17
81104038:	10002b1e 	bne	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>

		if (pxDmaM1Dev != NULL) {
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	10002926 	beq	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104044:	00000206 	br	81104050 <bSdmaDmaM1Transfer+0x3a0>
				alt_busy_sleep(1); /* delay 1us */
81104048:	01000044 	movi	r4,1
8110404c:	11375bc0 	call	811375bc <alt_busy_sleep>

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {

		if (pxDmaM1Dev != NULL) {
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104050:	d0a03917 	ldw	r2,-32540(gp)
81104054:	10800317 	ldw	r2,12(r2)
81104058:	10800037 	ldwio	r2,0(r2)
8110405c:	1080010c 	andi	r2,r2,4
81104060:	103ff91e 	bne	r2,zero,81104048 <__reset+0xfb0e4048>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if (0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81104064:	d2203917 	ldw	r8,-32540(gp)
81104068:	e1bff817 	ldw	r6,-32(fp)
8110406c:	e1fff417 	ldw	r7,-48(fp)
81104070:	e0bffc0b 	ldhu	r2,-16(fp)
81104074:	10802224 	muli	r2,r2,136
81104078:	e0fff917 	ldw	r3,-28(fp)
8110407c:	e13ff517 	ldw	r4,-44(fp)
81104080:	01400044 	movi	r5,1
81104084:	d9400815 	stw	r5,32(sp)
81104088:	01400044 	movi	r5,1
8110408c:	d9400715 	stw	r5,28(sp)
81104090:	01400044 	movi	r5,1
81104094:	d9400615 	stw	r5,24(sp)
81104098:	01400044 	movi	r5,1
8110409c:	d9400515 	stw	r5,20(sp)
811040a0:	01400044 	movi	r5,1
811040a4:	d9400415 	stw	r5,16(sp)
811040a8:	d9000315 	stw	r4,12(sp)
811040ac:	d8c00215 	stw	r3,8(sp)
811040b0:	e0fffa17 	ldw	r3,-24(fp)
811040b4:	d8c00115 	stw	r3,4(sp)
811040b8:	d8800015 	stw	r2,0(sp)
811040bc:	800b883a 	mov	r5,r16
811040c0:	4009883a 	mov	r4,r8
811040c4:	110bcf80 	call	8110bcf8 <iMsgdmaConstructExtendedMmToMmDescriptor>
811040c8:	1000071e 	bne	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)	) {
				/* Success = 0 */
				if (0 == iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,	&xDmaExtendedDescriptor)) {
811040cc:	d0a03917 	ldw	r2,-32540(gp)
811040d0:	800b883a 	mov	r5,r16
811040d4:	1009883a 	mov	r4,r2
811040d8:	110bdb80 	call	8110bdb8 <iMsgdmaExtendedDescriptorAsyncTransfer>
811040dc:	1000021e 	bne	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
					bStatus = TRUE;
811040e0:	00800044 	movi	r2,1
811040e4:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
811040e8:	e0bff317 	ldw	r2,-52(fp)
}
811040ec:	e6ffff04 	addi	sp,fp,-4
811040f0:	dfc00217 	ldw	ra,8(sp)
811040f4:	df000117 	ldw	fp,4(sp)
811040f8:	dc000017 	ldw	r16,0(sp)
811040fc:	dec00304 	addi	sp,sp,12
81104100:	f800283a 	ret

81104104 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81104104:	deffe804 	addi	sp,sp,-96
81104108:	de00012e 	bgeu	sp,et,81104110 <bSdmaDmaM2Transfer+0xc>
8110410c:	003b68fa 	trap	3
81104110:	dfc01715 	stw	ra,92(sp)
81104114:	df001615 	stw	fp,88(sp)
81104118:	dc001515 	stw	r16,84(sp)
8110411c:	df001604 	addi	fp,sp,88
81104120:	e13ffb15 	stw	r4,-20(fp)
81104124:	2809883a 	mov	r4,r5
81104128:	3007883a 	mov	r3,r6
8110412c:	3805883a 	mov	r2,r7
81104130:	e13ffc0d 	sth	r4,-16(fp)
81104134:	e0fffd05 	stb	r3,-12(fp)
81104138:	e0bffe05 	stb	r2,-8(fp)
8110413c:	defff004 	addi	sp,sp,-64
81104140:	d8800904 	addi	r2,sp,36
81104144:	108007c4 	addi	r2,r2,31
81104148:	1004d17a 	srli	r2,r2,5
8110414c:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104150:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81104154:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81104158:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
8110415c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104160:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;


	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81104164:	00800044 	movi	r2,1
81104168:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
8110416c:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
81104170:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
81104174:	e0bffe03 	ldbu	r2,-8(fp)
81104178:	10c00228 	cmpgeui	r3,r2,8
8110417c:	1800b81e 	bne	r3,zero,81104460 <bSdmaDmaM2Transfer+0x35c>
81104180:	100690ba 	slli	r3,r2,2
81104184:	00a04434 	movhi	r2,33040
81104188:	10906604 	addi	r2,r2,16792
8110418c:	1885883a 	add	r2,r3,r2
81104190:	10800017 	ldw	r2,0(r2)
81104194:	1000683a 	jmp	r2
81104198:	811041b8 	rdprs	r4,r16,16646
8110419c:	8110420c 	andi	r4,r16,16648
811041a0:	81104268 	cmpgeui	r4,r16,16649
811041a4:	811042bc 	xorhi	r4,r16,16650
811041a8:	81104310 	cmplti	r4,r16,16652
811041ac:	81104364 	muli	r4,r16,16653
811041b0:	811043b8 	rdprs	r4,r16,16654
811041b4:	8110440c 	andi	r4,r16,16656
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
811041b8:	e0bffd03 	ldbu	r2,-12(fp)
811041bc:	10000826 	beq	r2,zero,811041e0 <bSdmaDmaM2Transfer+0xdc>
811041c0:	10800060 	cmpeqi	r2,r2,1
811041c4:	10000d26 	beq	r2,zero,811041fc <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811041c8:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811041cc:	00800044 	movi	r2,1
811041d0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
811041d4:	11064c00 	call	811064c0 <bFeebGetCh1RightBufferEmpty>
811041d8:	e0bff615 	stw	r2,-40(fp)
			break;
811041dc:	00000a06 	br	81104208 <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041e0:	00800074 	movhi	r2,1
811041e4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041e8:	00800044 	movi	r2,1
811041ec:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
811041f0:	11064580 	call	81106458 <bFeebGetCh1LeftBufferEmpty>
811041f4:	e0bff615 	stw	r2,-40(fp)
			break;
811041f8:	00000306 	br	81104208 <bSdmaDmaM2Transfer+0x104>
		default:
			bChannelFlag = FALSE;
811041fc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104200:	e03ff615 	stw	zero,-40(fp)
			break;
81104204:	0001883a 	nop
		}
		break;
81104208:	00009706 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110420c:	e0bffd03 	ldbu	r2,-12(fp)
81104210:	10000926 	beq	r2,zero,81104238 <bSdmaDmaM2Transfer+0x134>
81104214:	10800060 	cmpeqi	r2,r2,1
81104218:	10000f26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110421c:	00880004 	movi	r2,8192
81104220:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104224:	00800044 	movi	r2,1
81104228:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
8110422c:	11065900 	call	81106590 <bFeebGetCh2RightBufferEmpty>
81104230:	e0bff615 	stw	r2,-40(fp)
			break;
81104234:	00000b06 	br	81104264 <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81104238:	00800074 	movhi	r2,1
8110423c:	10880004 	addi	r2,r2,8192
81104240:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104244:	00800044 	movi	r2,1
81104248:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
8110424c:	11065280 	call	81106528 <bFeebGetCh2LeftBufferEmpty>
81104250:	e0bff615 	stw	r2,-40(fp)
			break;
81104254:	00000306 	br	81104264 <bSdmaDmaM2Transfer+0x160>
		default:
			bChannelFlag = FALSE;
81104258:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
8110425c:	e03ff615 	stw	zero,-40(fp)
			break;
81104260:	0001883a 	nop
		}
		break;
81104264:	00008006 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104268:	e0bffd03 	ldbu	r2,-12(fp)
8110426c:	10000826 	beq	r2,zero,81104290 <bSdmaDmaM2Transfer+0x18c>
81104270:	10800060 	cmpeqi	r2,r2,1
81104274:	10000d26 	beq	r2,zero,811042ac <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104278:	00900004 	movi	r2,16384
8110427c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104280:	00800044 	movi	r2,1
81104284:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104288:	e03ff615 	stw	zero,-40(fp)
			break;
8110428c:	00000a06 	br	811042b8 <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104290:	00800074 	movhi	r2,1
81104294:	10900004 	addi	r2,r2,16384
81104298:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
8110429c:	00800044 	movi	r2,1
811042a0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042a4:	e03ff615 	stw	zero,-40(fp)
			break;
811042a8:	00000306 	br	811042b8 <bSdmaDmaM2Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
811042ac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811042b0:	e03ff615 	stw	zero,-40(fp)
			break;
811042b4:	0001883a 	nop
		}
		break;
811042b8:	00006b06 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
811042bc:	e0bffd03 	ldbu	r2,-12(fp)
811042c0:	10000826 	beq	r2,zero,811042e4 <bSdmaDmaM2Transfer+0x1e0>
811042c4:	10800060 	cmpeqi	r2,r2,1
811042c8:	10000d26 	beq	r2,zero,81104300 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811042cc:	00980004 	movi	r2,24576
811042d0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811042d4:	00800044 	movi	r2,1
811042d8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042dc:	e03ff615 	stw	zero,-40(fp)
			break;
811042e0:	00000a06 	br	8110430c <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811042e4:	00800074 	movhi	r2,1
811042e8:	10980004 	addi	r2,r2,24576
811042ec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811042f0:	00800044 	movi	r2,1
811042f4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042f8:	e03ff615 	stw	zero,-40(fp)
			break;
811042fc:	00000306 	br	8110430c <bSdmaDmaM2Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81104300:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104304:	e03ff615 	stw	zero,-40(fp)
			break;
81104308:	0001883a 	nop
		}
		break;
8110430c:	00005606 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104310:	e0bffd03 	ldbu	r2,-12(fp)
81104314:	10000826 	beq	r2,zero,81104338 <bSdmaDmaM2Transfer+0x234>
81104318:	10800060 	cmpeqi	r2,r2,1
8110431c:	10000d26 	beq	r2,zero,81104354 <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104320:	00a00014 	movui	r2,32768
81104324:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81104328:	00800044 	movi	r2,1
8110432c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104330:	e03ff615 	stw	zero,-40(fp)
			break;
81104334:	00000a06 	br	81104360 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104338:	008000b4 	movhi	r2,2
8110433c:	10a00004 	addi	r2,r2,-32768
81104340:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104344:	00800044 	movi	r2,1
81104348:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110434c:	e03ff615 	stw	zero,-40(fp)
			break;
81104350:	00000306 	br	81104360 <bSdmaDmaM2Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
81104354:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104358:	e03ff615 	stw	zero,-40(fp)
			break;
8110435c:	0001883a 	nop
		}
		break;
81104360:	00004106 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81104364:	e0bffd03 	ldbu	r2,-12(fp)
81104368:	10000826 	beq	r2,zero,8110438c <bSdmaDmaM2Transfer+0x288>
8110436c:	10800060 	cmpeqi	r2,r2,1
81104370:	10000d26 	beq	r2,zero,811043a8 <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104374:	00a80014 	movui	r2,40960
81104378:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
8110437c:	00800044 	movi	r2,1
81104380:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104384:	e03ff615 	stw	zero,-40(fp)
			break;
81104388:	00000a06 	br	811043b4 <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110438c:	008000b4 	movhi	r2,2
81104390:	10a80004 	addi	r2,r2,-24576
81104394:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104398:	00800044 	movi	r2,1
8110439c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043a0:	e03ff615 	stw	zero,-40(fp)
			break;
811043a4:	00000306 	br	811043b4 <bSdmaDmaM2Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
811043a8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811043ac:	e03ff615 	stw	zero,-40(fp)
			break;
811043b0:	0001883a 	nop
		}
		break;
811043b4:	00002c06 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811043b8:	e0bffd03 	ldbu	r2,-12(fp)
811043bc:	10000826 	beq	r2,zero,811043e0 <bSdmaDmaM2Transfer+0x2dc>
811043c0:	10800060 	cmpeqi	r2,r2,1
811043c4:	10000d26 	beq	r2,zero,811043fc <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
811043c8:	00b00014 	movui	r2,49152
811043cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
811043d0:	00800044 	movi	r2,1
811043d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043d8:	e03ff615 	stw	zero,-40(fp)
			break;
811043dc:	00000a06 	br	81104408 <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811043e0:	008000b4 	movhi	r2,2
811043e4:	10b00004 	addi	r2,r2,-16384
811043e8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811043ec:	00800044 	movi	r2,1
811043f0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043f4:	e03ff615 	stw	zero,-40(fp)
			break;
811043f8:	00000306 	br	81104408 <bSdmaDmaM2Transfer+0x304>
		default:
			bChannelFlag = FALSE;
811043fc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104400:	e03ff615 	stw	zero,-40(fp)
			break;
81104404:	0001883a 	nop
		}
		break;
81104408:	00001706 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110440c:	e0bffd03 	ldbu	r2,-12(fp)
81104410:	10000826 	beq	r2,zero,81104434 <bSdmaDmaM2Transfer+0x330>
81104414:	10800060 	cmpeqi	r2,r2,1
81104418:	10000d26 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110441c:	00b80014 	movui	r2,57344
81104420:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104424:	00800044 	movi	r2,1
81104428:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110442c:	e03ff615 	stw	zero,-40(fp)
			break;
81104430:	00000a06 	br	8110445c <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104434:	008000b4 	movhi	r2,2
81104438:	10b80004 	addi	r2,r2,-8192
8110443c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104440:	00800044 	movi	r2,1
81104444:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104448:	e03ff615 	stw	zero,-40(fp)
			break;
8110444c:	00000306 	br	8110445c <bSdmaDmaM2Transfer+0x358>
		default:
			bChannelFlag = FALSE;
81104450:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104454:	e03ff615 	stw	zero,-40(fp)
			break;
81104458:	0001883a 	nop
		}
		break;
8110445c:	00000206 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	default:
		bChannelFlag = FALSE;
81104460:	e03ff715 	stw	zero,-36(fp)
		break;
81104464:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104468:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bChannelFlag = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
8110446c:	00a00034 	movhi	r2,32768
81104470:	1885883a 	add	r2,r3,r2
81104474:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
8110447c:	e0bff717 	ldw	r2,-36(fp)
81104480:	10003026 	beq	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
81104484:	e0bff617 	ldw	r2,-40(fp)
81104488:	10002e26 	beq	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	10800468 	cmpgeui	r2,r2,17
81104494:	10002b1e 	bne	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
		if (pxDmaM2Dev != NULL) {
81104498:	d0a03a17 	ldw	r2,-32536(gp)
8110449c:	10002926 	beq	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044a0:	00000206 	br	811044ac <bSdmaDmaM2Transfer+0x3a8>
				alt_busy_sleep(1); /* delay 1us */
811044a4:	01000044 	movi	r4,1
811044a8:	11375bc0 	call	811375bc <alt_busy_sleep>
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev != NULL) {

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044ac:	d0a03a17 	ldw	r2,-32536(gp)
811044b0:	10800317 	ldw	r2,12(r2)
811044b4:	10800037 	ldwio	r2,0(r2)
811044b8:	1080010c 	andi	r2,r2,4
811044bc:	103ff91e 	bne	r2,zero,811044a4 <__reset+0xfb0e44a4>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if ( 0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811044c0:	d2203a17 	ldw	r8,-32536(gp)
811044c4:	e1bff817 	ldw	r6,-32(fp)
811044c8:	e1fff417 	ldw	r7,-48(fp)
811044cc:	e0bffc0b 	ldhu	r2,-16(fp)
811044d0:	10802224 	muli	r2,r2,136
811044d4:	e0fff917 	ldw	r3,-28(fp)
811044d8:	e13ff517 	ldw	r4,-44(fp)
811044dc:	01400044 	movi	r5,1
811044e0:	d9400815 	stw	r5,32(sp)
811044e4:	01400044 	movi	r5,1
811044e8:	d9400715 	stw	r5,28(sp)
811044ec:	01400044 	movi	r5,1
811044f0:	d9400615 	stw	r5,24(sp)
811044f4:	01400044 	movi	r5,1
811044f8:	d9400515 	stw	r5,20(sp)
811044fc:	01400044 	movi	r5,1
81104500:	d9400415 	stw	r5,16(sp)
81104504:	d9000315 	stw	r4,12(sp)
81104508:	d8c00215 	stw	r3,8(sp)
8110450c:	e0fffa17 	ldw	r3,-24(fp)
81104510:	d8c00115 	stw	r3,4(sp)
81104514:	d8800015 	stw	r2,0(sp)
81104518:	800b883a 	mov	r5,r16
8110451c:	4009883a 	mov	r4,r8
81104520:	110bcf80 	call	8110bcf8 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104524:	1000071e 	bne	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)) {
				/* Success = 0 */
				if ( 0 == iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104528:	d0a03a17 	ldw	r2,-32536(gp)
8110452c:	800b883a 	mov	r5,r16
81104530:	1009883a 	mov	r4,r2
81104534:	110bdfc0 	call	8110bdfc <iMsgdmaExtendedDescriptorSyncTransfer>
81104538:	1000021e 	bne	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
						&xDmaExtendedDescriptor)) {
					bStatus = TRUE;
8110453c:	00800044 	movi	r2,1
81104540:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
81104544:	e0bff317 	ldw	r2,-52(fp)
}
81104548:	e6ffff04 	addi	sp,fp,-4
8110454c:	dfc00217 	ldw	ra,8(sp)
81104550:	df000117 	ldw	fp,4(sp)
81104554:	dc000017 	ldw	r16,0(sp)
81104558:	dec00304 	addi	sp,sp,12
8110455c:	f800283a 	ret

81104560 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
81104560:	defff904 	addi	sp,sp,-28
81104564:	de00012e 	bgeu	sp,et,8110456c <bCommSetGlobalIrqEn+0xc>
81104568:	003b68fa 	trap	3
8110456c:	dfc00615 	stw	ra,24(sp)
81104570:	df000515 	stw	fp,20(sp)
81104574:	df000504 	addi	fp,sp,20
81104578:	e13ffe15 	stw	r4,-8(fp)
8110457c:	2805883a 	mov	r2,r5
81104580:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104584:	00800044 	movi	r2,1
81104588:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110458c:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
81104590:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104594:	e0bfff03 	ldbu	r2,-4(fp)
81104598:	10c00228 	cmpgeui	r3,r2,8
8110459c:	18002e1e 	bne	r3,zero,81104658 <bCommSetGlobalIrqEn+0xf8>
811045a0:	100690ba 	slli	r3,r2,2
811045a4:	00a04434 	movhi	r2,33040
811045a8:	10916e04 	addi	r2,r2,17848
811045ac:	1885883a 	add	r2,r3,r2
811045b0:	10800017 	ldw	r2,0(r2)
811045b4:	1000683a 	jmp	r2
811045b8:	811045d8 	cmpnei	r4,r16,16663
811045bc:	811045e8 	cmpgeui	r4,r16,16663
811045c0:	811045f8 	rdprs	r4,r16,16663
811045c4:	81104608 	cmpgei	r4,r16,16664
811045c8:	81104618 	cmpnei	r4,r16,16664
811045cc:	81104628 	cmpgeui	r4,r16,16664
811045d0:	81104638 	rdprs	r4,r16,16664
811045d4:	81104648 	cmpgei	r4,r16,16665
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811045d8:	00a04834 	movhi	r2,33056
811045dc:	108b0004 	addi	r2,r2,11264
811045e0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045e4:	00001e06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811045e8:	00a04834 	movhi	r2,33056
811045ec:	108a0004 	addi	r2,r2,10240
811045f0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045f4:	00001a06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811045f8:	00a04834 	movhi	r2,33056
811045fc:	108b0004 	addi	r2,r2,11264
81104600:	e0bffd15 	stw	r2,-12(fp)
		break;
81104604:	00001606 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104608:	00a04834 	movhi	r2,33056
8110460c:	108a0004 	addi	r2,r2,10240
81104610:	e0bffd15 	stw	r2,-12(fp)
		break;
81104614:	00001206 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104618:	00a04834 	movhi	r2,33056
8110461c:	108b0004 	addi	r2,r2,11264
81104620:	e0bffd15 	stw	r2,-12(fp)
		break;
81104624:	00000e06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104628:	00a04834 	movhi	r2,33056
8110462c:	108a0004 	addi	r2,r2,10240
81104630:	e0bffd15 	stw	r2,-12(fp)
		break;
81104634:	00000a06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104638:	00a04834 	movhi	r2,33056
8110463c:	108b0004 	addi	r2,r2,11264
81104640:	e0bffd15 	stw	r2,-12(fp)
		break;
81104644:	00000606 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104648:	00a04834 	movhi	r2,33056
8110464c:	108a0004 	addi	r2,r2,10240
81104650:	e0bffd15 	stw	r2,-12(fp)
		break;
81104654:	00000206 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81104658:	e03ffb15 	stw	zero,-20(fp)
		break;
8110465c:	0001883a 	nop
	}

	if (bStatus) {
81104660:	e0bffb17 	ldw	r2,-20(fp)
81104664:	10001326 	beq	r2,zero,811046b4 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104668:	01400444 	movi	r5,17
8110466c:	e13ffd17 	ldw	r4,-12(fp)
81104670:	11047f00 	call	811047f0 <uliCommReadReg>
81104674:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104678:	e0bffe17 	ldw	r2,-8(fp)
8110467c:	10000426 	beq	r2,zero,81104690 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104680:	e0bffc17 	ldw	r2,-16(fp)
81104684:	10800074 	orhi	r2,r2,1
81104688:	e0bffc15 	stw	r2,-16(fp)
8110468c:	00000506 	br	811046a4 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104690:	e0fffc17 	ldw	r3,-16(fp)
81104694:	00bffff4 	movhi	r2,65535
81104698:	10bfffc4 	addi	r2,r2,-1
8110469c:	1884703a 	and	r2,r3,r2
811046a0:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
811046a4:	e1bffc17 	ldw	r6,-16(fp)
811046a8:	01400444 	movi	r5,17
811046ac:	e13ffd17 	ldw	r4,-12(fp)
811046b0:	110479c0 	call	8110479c <vCommWriteReg>
	}

	return bStatus;
811046b4:	e0bffb17 	ldw	r2,-20(fp)
}
811046b8:	e037883a 	mov	sp,fp
811046bc:	dfc00117 	ldw	ra,4(sp)
811046c0:	df000017 	ldw	fp,0(sp)
811046c4:	dec00204 	addi	sp,sp,8
811046c8:	f800283a 	ret

811046cc <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811046cc:	defffb04 	addi	sp,sp,-20
811046d0:	de00012e 	bgeu	sp,et,811046d8 <bCommInitCh+0xc>
811046d4:	003b68fa 	trap	3
811046d8:	dfc00415 	stw	ra,16(sp)
811046dc:	df000315 	stw	fp,12(sp)
811046e0:	df000304 	addi	fp,sp,12
811046e4:	e13ffe15 	stw	r4,-8(fp)
811046e8:	2805883a 	mov	r2,r5
811046ec:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811046f0:	00800044 	movi	r2,1
811046f4:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811046f8:	e0bffe17 	ldw	r2,-8(fp)
811046fc:	10805704 	addi	r2,r2,348
81104700:	e0ffff03 	ldbu	r3,-4(fp)
81104704:	180b883a 	mov	r5,r3
81104708:	1009883a 	mov	r4,r2
8110470c:	110a5b80 	call	8110a5b8 <bSpwcInitCh>
81104710:	1000011e 	bne	r2,zero,81104718 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104714:	e03ffd15 	stw	zero,-12(fp)
	}
	//vFeebInitIrq(ucCommCh);

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104718:	e0bffe17 	ldw	r2,-8(fp)
8110471c:	10800904 	addi	r2,r2,36
81104720:	e0ffff03 	ldbu	r3,-4(fp)
81104724:	180b883a 	mov	r5,r3
81104728:	1009883a 	mov	r4,r2
8110472c:	11069a00 	call	811069a0 <bFeebInitCh>
81104730:	1000011e 	bne	r2,zero,81104738 <bCommInitCh+0x6c>
		bStatus = FALSE;
81104734:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104738:	e0bffe17 	ldw	r2,-8(fp)
8110473c:	10801104 	addi	r2,r2,68
81104740:	e0ffff03 	ldbu	r3,-4(fp)
81104744:	180b883a 	mov	r5,r3
81104748:	1009883a 	mov	r4,r2
8110474c:	1109c140 	call	81109c14 <bRmapInitCh>
81104750:	1000011e 	bne	r2,zero,81104758 <bCommInitCh+0x8c>
		bStatus = FALSE;
81104754:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104758:	e0bfff03 	ldbu	r2,-4(fp)
8110475c:	1009883a 	mov	r4,r2
81104760:	11076500 	call	81107650 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104764:	e0bffe17 	ldw	r2,-8(fp)
81104768:	10800104 	addi	r2,r2,4
8110476c:	e0ffff03 	ldbu	r3,-4(fp)
81104770:	180b883a 	mov	r5,r3
81104774:	1009883a 	mov	r4,r2
81104778:	1104e680 	call	81104e68 <bDpktInitCh>
8110477c:	1000011e 	bne	r2,zero,81104784 <bCommInitCh+0xb8>
		bStatus = FALSE;
81104780:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104784:	e0bffd17 	ldw	r2,-12(fp)
}
81104788:	e037883a 	mov	sp,fp
8110478c:	dfc00117 	ldw	ra,4(sp)
81104790:	df000017 	ldw	fp,0(sp)
81104794:	dec00204 	addi	sp,sp,8
81104798:	f800283a 	ret

8110479c <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110479c:	defffc04 	addi	sp,sp,-16
811047a0:	de00012e 	bgeu	sp,et,811047a8 <vCommWriteReg+0xc>
811047a4:	003b68fa 	trap	3
811047a8:	df000315 	stw	fp,12(sp)
811047ac:	df000304 	addi	fp,sp,12
811047b0:	e13ffd15 	stw	r4,-12(fp)
811047b4:	e17ffe15 	stw	r5,-8(fp)
811047b8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811047bc:	e0bffe17 	ldw	r2,-8(fp)
811047c0:	1085883a 	add	r2,r2,r2
811047c4:	1085883a 	add	r2,r2,r2
811047c8:	1007883a 	mov	r3,r2
811047cc:	e0bffd17 	ldw	r2,-12(fp)
811047d0:	10c5883a 	add	r2,r2,r3
811047d4:	e0ffff17 	ldw	r3,-4(fp)
811047d8:	10c00015 	stw	r3,0(r2)
}
811047dc:	0001883a 	nop
811047e0:	e037883a 	mov	sp,fp
811047e4:	df000017 	ldw	fp,0(sp)
811047e8:	dec00104 	addi	sp,sp,4
811047ec:	f800283a 	ret

811047f0 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811047f0:	defffc04 	addi	sp,sp,-16
811047f4:	de00012e 	bgeu	sp,et,811047fc <uliCommReadReg+0xc>
811047f8:	003b68fa 	trap	3
811047fc:	df000315 	stw	fp,12(sp)
81104800:	df000304 	addi	fp,sp,12
81104804:	e13ffe15 	stw	r4,-8(fp)
81104808:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110480c:	e0bfff17 	ldw	r2,-4(fp)
81104810:	1085883a 	add	r2,r2,r2
81104814:	1085883a 	add	r2,r2,r2
81104818:	1007883a 	mov	r3,r2
8110481c:	e0bffe17 	ldw	r2,-8(fp)
81104820:	10c5883a 	add	r2,r2,r3
81104824:	10800017 	ldw	r2,0(r2)
81104828:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110482c:	e0bffd17 	ldw	r2,-12(fp)
}
81104830:	e037883a 	mov	sp,fp
81104834:	df000017 	ldw	fp,0(sp)
81104838:	dec00104 	addi	sp,sp,4
8110483c:	f800283a 	ret

81104840 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81104840:	defffb04 	addi	sp,sp,-20
81104844:	de00012e 	bgeu	sp,et,8110484c <bDpktSetPacketConfig+0xc>
81104848:	003b68fa 	trap	3
8110484c:	dfc00415 	stw	ra,16(sp)
81104850:	df000315 	stw	fp,12(sp)
81104854:	df000304 	addi	fp,sp,12
81104858:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110485c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104860:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104864:	e0bfff17 	ldw	r2,-4(fp)
81104868:	10007a26 	beq	r2,zero,81104a54 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110486c:	e0bfff17 	ldw	r2,-4(fp)
81104870:	10800017 	ldw	r2,0(r2)
81104874:	01400204 	movi	r5,8
81104878:	1009883a 	mov	r4,r2
8110487c:	11050300 	call	81105030 <uliDpktReadReg>
81104880:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104884:	e0bffe17 	ldw	r2,-8(fp)
81104888:	10bfffec 	andhi	r2,r2,65535
8110488c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104890:	e0bfff17 	ldw	r2,-4(fp)
81104894:	1080010b 	ldhu	r2,4(r2)
81104898:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
8110489c:	e0fffe17 	ldw	r3,-8(fp)
811048a0:	1884b03a 	or	r2,r3,r2
811048a4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
811048a8:	e0bffe17 	ldw	r2,-8(fp)
811048ac:	10bfffcc 	andi	r2,r2,65535
811048b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
811048b4:	e0bfff17 	ldw	r2,-4(fp)
811048b8:	1080018b 	ldhu	r2,6(r2)
811048bc:	10bfffcc 	andi	r2,r2,65535
811048c0:	1004943a 	slli	r2,r2,16
811048c4:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811048c8:	e0bffe17 	ldw	r2,-8(fp)
811048cc:	10c4b03a 	or	r2,r2,r3
811048d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811048d4:	e0bfff17 	ldw	r2,-4(fp)
811048d8:	10800017 	ldw	r2,0(r2)
811048dc:	e1bffe17 	ldw	r6,-8(fp)
811048e0:	01400204 	movi	r5,8
811048e4:	1009883a 	mov	r4,r2
811048e8:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048ec:	e0bfff17 	ldw	r2,-4(fp)
811048f0:	10800017 	ldw	r2,0(r2)
811048f4:	01400244 	movi	r5,9
811048f8:	1009883a 	mov	r4,r2
811048fc:	11050300 	call	81105030 <uliDpktReadReg>
81104900:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104904:	e0bffe17 	ldw	r2,-8(fp)
81104908:	10bfffec 	andhi	r2,r2,65535
8110490c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
81104910:	e0bfff17 	ldw	r2,-4(fp)
81104914:	1080020b 	ldhu	r2,8(r2)
81104918:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
8110491c:	e0fffe17 	ldw	r3,-8(fp)
81104920:	1884b03a 	or	r2,r3,r2
81104924:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104928:	e0bffe17 	ldw	r2,-8(fp)
8110492c:	10bfffcc 	andi	r2,r2,65535
81104930:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104934:	e0bfff17 	ldw	r2,-4(fp)
81104938:	1080028b 	ldhu	r2,10(r2)
										<< 16));
8110493c:	10bfffcc 	andi	r2,r2,65535
81104940:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104944:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104948:	e0bffe17 	ldw	r2,-8(fp)
8110494c:	10c4b03a 	or	r2,r2,r3
81104950:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104954:	e0bfff17 	ldw	r2,-4(fp)
81104958:	10800017 	ldw	r2,0(r2)
8110495c:	e1bffe17 	ldw	r6,-8(fp)
81104960:	01400244 	movi	r5,9
81104964:	1009883a 	mov	r4,r2
81104968:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110496c:	e0bfff17 	ldw	r2,-4(fp)
81104970:	10800017 	ldw	r2,0(r2)
81104974:	01400284 	movi	r5,10
81104978:	1009883a 	mov	r4,r2
8110497c:	11050300 	call	81105030 <uliDpktReadReg>
81104980:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104984:	e0bffe17 	ldw	r2,-8(fp)
81104988:	10bfffec 	andhi	r2,r2,65535
8110498c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104990:	e0bfff17 	ldw	r2,-4(fp)
81104994:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104998:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
8110499c:	e0fffe17 	ldw	r3,-8(fp)
811049a0:	1884b03a 	or	r2,r3,r2
811049a4:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
811049a8:	e0bfff17 	ldw	r2,-4(fp)
811049ac:	10800017 	ldw	r2,0(r2)
811049b0:	e1bffe17 	ldw	r6,-8(fp)
811049b4:	01400284 	movi	r5,10
811049b8:	1009883a 	mov	r4,r2
811049bc:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049c0:	e0bfff17 	ldw	r2,-4(fp)
811049c4:	10800017 	ldw	r2,0(r2)
811049c8:	014002c4 	movi	r5,11
811049cc:	1009883a 	mov	r4,r2
811049d0:	11050300 	call	81105030 <uliDpktReadReg>
811049d4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
811049d8:	e0fffe17 	ldw	r3,-8(fp)
811049dc:	00bfc004 	movi	r2,-256
811049e0:	1884703a 	and	r2,r3,r2
811049e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
811049e8:	e0bfff17 	ldw	r2,-4(fp)
811049ec:	10800383 	ldbu	r2,14(r2)
811049f0:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
811049f4:	e0fffe17 	ldw	r3,-8(fp)
811049f8:	1884b03a 	or	r2,r3,r2
811049fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81104a00:	e0fffe17 	ldw	r3,-8(fp)
81104a04:	00bffff4 	movhi	r2,65535
81104a08:	10803fc4 	addi	r2,r2,255
81104a0c:	1884703a 	and	r2,r3,r2
81104a10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104a14:	e0bfff17 	ldw	r2,-4(fp)
81104a18:	108003c3 	ldbu	r2,15(r2)
81104a1c:	10803fcc 	andi	r2,r2,255
81104a20:	1004923a 	slli	r2,r2,8
81104a24:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104a28:	e0fffe17 	ldw	r3,-8(fp)
81104a2c:	1884b03a 	or	r2,r3,r2
81104a30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104a34:	e0bfff17 	ldw	r2,-4(fp)
81104a38:	10800017 	ldw	r2,0(r2)
81104a3c:	e1bffe17 	ldw	r6,-8(fp)
81104a40:	014002c4 	movi	r5,11
81104a44:	1009883a 	mov	r4,r2
81104a48:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104a4c:	00800044 	movi	r2,1
81104a50:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104a54:	e0bffd17 	ldw	r2,-12(fp)
}
81104a58:	e037883a 	mov	sp,fp
81104a5c:	dfc00117 	ldw	ra,4(sp)
81104a60:	df000017 	ldw	fp,0(sp)
81104a64:	dec00204 	addi	sp,sp,8
81104a68:	f800283a 	ret

81104a6c <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104a6c:	defffb04 	addi	sp,sp,-20
81104a70:	de00012e 	bgeu	sp,et,81104a78 <bDpktGetPacketConfig+0xc>
81104a74:	003b68fa 	trap	3
81104a78:	dfc00415 	stw	ra,16(sp)
81104a7c:	df000315 	stw	fp,12(sp)
81104a80:	df000304 	addi	fp,sp,12
81104a84:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104a88:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a8c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a90:	e0bfff17 	ldw	r2,-4(fp)
81104a94:	10003a26 	beq	r2,zero,81104b80 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a98:	e0bfff17 	ldw	r2,-4(fp)
81104a9c:	10800017 	ldw	r2,0(r2)
81104aa0:	01400204 	movi	r5,8
81104aa4:	1009883a 	mov	r4,r2
81104aa8:	11050300 	call	81105030 <uliDpktReadReg>
81104aac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104ab0:	e0bffe17 	ldw	r2,-8(fp)
81104ab4:	1007883a 	mov	r3,r2
81104ab8:	e0bfff17 	ldw	r2,-4(fp)
81104abc:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104ac0:	e0bffe17 	ldw	r2,-8(fp)
81104ac4:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ad4:	e0bfff17 	ldw	r2,-4(fp)
81104ad8:	10800017 	ldw	r2,0(r2)
81104adc:	01400244 	movi	r5,9
81104ae0:	1009883a 	mov	r4,r2
81104ae4:	11050300 	call	81105030 <uliDpktReadReg>
81104ae8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104aec:	e0bffe17 	ldw	r2,-8(fp)
81104af0:	1007883a 	mov	r3,r2
81104af4:	e0bfff17 	ldw	r2,-4(fp)
81104af8:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104afc:	e0bffe17 	ldw	r2,-8(fp)
81104b00:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104b04:	1007883a 	mov	r3,r2
81104b08:	e0bfff17 	ldw	r2,-4(fp)
81104b0c:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b10:	e0bfff17 	ldw	r2,-4(fp)
81104b14:	10800017 	ldw	r2,0(r2)
81104b18:	01400284 	movi	r5,10
81104b1c:	1009883a 	mov	r4,r2
81104b20:	11050300 	call	81105030 <uliDpktReadReg>
81104b24:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104b28:	e0bffe17 	ldw	r2,-8(fp)
81104b2c:	1007883a 	mov	r3,r2
81104b30:	e0bfff17 	ldw	r2,-4(fp)
81104b34:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b38:	e0bfff17 	ldw	r2,-4(fp)
81104b3c:	10800017 	ldw	r2,0(r2)
81104b40:	014002c4 	movi	r5,11
81104b44:	1009883a 	mov	r4,r2
81104b48:	11050300 	call	81105030 <uliDpktReadReg>
81104b4c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104b50:	e0bffe17 	ldw	r2,-8(fp)
81104b54:	1007883a 	mov	r3,r2
81104b58:	e0bfff17 	ldw	r2,-4(fp)
81104b5c:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104b60:	e0bffe17 	ldw	r2,-8(fp)
81104b64:	10bfc00c 	andi	r2,r2,65280
81104b68:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104b6c:	1007883a 	mov	r3,r2
81104b70:	e0bfff17 	ldw	r2,-4(fp)
81104b74:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104b78:	00800044 	movi	r2,1
81104b7c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b80:	e0bffd17 	ldw	r2,-12(fp)
}
81104b84:	e037883a 	mov	sp,fp
81104b88:	dfc00117 	ldw	ra,4(sp)
81104b8c:	df000017 	ldw	fp,0(sp)
81104b90:	dec00204 	addi	sp,sp,8
81104b94:	f800283a 	ret

81104b98 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104b98:	defffb04 	addi	sp,sp,-20
81104b9c:	de00012e 	bgeu	sp,et,81104ba4 <bDpktGetPacketHeader+0xc>
81104ba0:	003b68fa 	trap	3
81104ba4:	dfc00415 	stw	ra,16(sp)
81104ba8:	df000315 	stw	fp,12(sp)
81104bac:	df000304 	addi	fp,sp,12
81104bb0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bb4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bb8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bbc:	e0bfff17 	ldw	r2,-4(fp)
81104bc0:	10002026 	beq	r2,zero,81104c44 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bc4:	e0bfff17 	ldw	r2,-4(fp)
81104bc8:	10800017 	ldw	r2,0(r2)
81104bcc:	01400304 	movi	r5,12
81104bd0:	1009883a 	mov	r4,r2
81104bd4:	11050300 	call	81105030 <uliDpktReadReg>
81104bd8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104bdc:	e0bffe17 	ldw	r2,-8(fp)
81104be0:	1007883a 	mov	r3,r2
81104be4:	e0bfff17 	ldw	r2,-4(fp)
81104be8:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104bec:	e0bffe17 	ldw	r2,-8(fp)
81104bf0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104bf4:	1007883a 	mov	r3,r2
81104bf8:	e0bfff17 	ldw	r2,-4(fp)
81104bfc:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c00:	e0bfff17 	ldw	r2,-4(fp)
81104c04:	10800017 	ldw	r2,0(r2)
81104c08:	01400344 	movi	r5,13
81104c0c:	1009883a 	mov	r4,r2
81104c10:	11050300 	call	81105030 <uliDpktReadReg>
81104c14:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104c18:	e0bffe17 	ldw	r2,-8(fp)
81104c1c:	1007883a 	mov	r3,r2
81104c20:	e0bfff17 	ldw	r2,-4(fp)
81104c24:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104c28:	e0bffe17 	ldw	r2,-8(fp)
81104c2c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104c30:	1007883a 	mov	r3,r2
81104c34:	e0bfff17 	ldw	r2,-4(fp)
81104c38:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104c3c:	00800044 	movi	r2,1
81104c40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c44:	e0bffd17 	ldw	r2,-12(fp)
}
81104c48:	e037883a 	mov	sp,fp
81104c4c:	dfc00117 	ldw	ra,4(sp)
81104c50:	df000017 	ldw	fp,0(sp)
81104c54:	dec00204 	addi	sp,sp,8
81104c58:	f800283a 	ret

81104c5c <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104c5c:	defffb04 	addi	sp,sp,-20
81104c60:	de00012e 	bgeu	sp,et,81104c68 <bDpktSetPixelDelay+0xc>
81104c64:	003b68fa 	trap	3
81104c68:	dfc00415 	stw	ra,16(sp)
81104c6c:	df000315 	stw	fp,12(sp)
81104c70:	df000304 	addi	fp,sp,12
81104c74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c78:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c80:	e0bfff17 	ldw	r2,-4(fp)
81104c84:	10004126 	beq	r2,zero,81104d8c <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c88:	e0bfff17 	ldw	r2,-4(fp)
81104c8c:	10800017 	ldw	r2,0(r2)
81104c90:	01400384 	movi	r5,14
81104c94:	1009883a 	mov	r4,r2
81104c98:	11050300 	call	81105030 <uliDpktReadReg>
81104c9c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104ca0:	e0bffe17 	ldw	r2,-8(fp)
81104ca4:	10bfffec 	andhi	r2,r2,65535
81104ca8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104cac:	e0bfff17 	ldw	r2,-4(fp)
81104cb0:	1080060b 	ldhu	r2,24(r2)
81104cb4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104cb8:	e0fffe17 	ldw	r3,-8(fp)
81104cbc:	1884b03a 	or	r2,r3,r2
81104cc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104cc4:	e0bfff17 	ldw	r2,-4(fp)
81104cc8:	10800017 	ldw	r2,0(r2)
81104ccc:	e1bffe17 	ldw	r6,-8(fp)
81104cd0:	01400384 	movi	r5,14
81104cd4:	1009883a 	mov	r4,r2
81104cd8:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cdc:	e0bfff17 	ldw	r2,-4(fp)
81104ce0:	10800017 	ldw	r2,0(r2)
81104ce4:	014003c4 	movi	r5,15
81104ce8:	1009883a 	mov	r4,r2
81104cec:	11050300 	call	81105030 <uliDpktReadReg>
81104cf0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104cf4:	e0bffe17 	ldw	r2,-8(fp)
81104cf8:	10bfffec 	andhi	r2,r2,65535
81104cfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104d00:	e0bfff17 	ldw	r2,-4(fp)
81104d04:	1080068b 	ldhu	r2,26(r2)
81104d08:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104d0c:	e0fffe17 	ldw	r3,-8(fp)
81104d10:	1884b03a 	or	r2,r3,r2
81104d14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104d18:	e0bfff17 	ldw	r2,-4(fp)
81104d1c:	10800017 	ldw	r2,0(r2)
81104d20:	e1bffe17 	ldw	r6,-8(fp)
81104d24:	014003c4 	movi	r5,15
81104d28:	1009883a 	mov	r4,r2
81104d2c:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d30:	e0bfff17 	ldw	r2,-4(fp)
81104d34:	10800017 	ldw	r2,0(r2)
81104d38:	01400404 	movi	r5,16
81104d3c:	1009883a 	mov	r4,r2
81104d40:	11050300 	call	81105030 <uliDpktReadReg>
81104d44:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104d48:	e0bffe17 	ldw	r2,-8(fp)
81104d4c:	10bfffec 	andhi	r2,r2,65535
81104d50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104d54:	e0bfff17 	ldw	r2,-4(fp)
81104d58:	1080070b 	ldhu	r2,28(r2)
81104d5c:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104d60:	e0fffe17 	ldw	r3,-8(fp)
81104d64:	1884b03a 	or	r2,r3,r2
81104d68:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104d6c:	e0bfff17 	ldw	r2,-4(fp)
81104d70:	10800017 	ldw	r2,0(r2)
81104d74:	e1bffe17 	ldw	r6,-8(fp)
81104d78:	01400404 	movi	r5,16
81104d7c:	1009883a 	mov	r4,r2
81104d80:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104d84:	00800044 	movi	r2,1
81104d88:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d8c:	e0bffd17 	ldw	r2,-12(fp)
}
81104d90:	e037883a 	mov	sp,fp
81104d94:	dfc00117 	ldw	ra,4(sp)
81104d98:	df000017 	ldw	fp,0(sp)
81104d9c:	dec00204 	addi	sp,sp,8
81104da0:	f800283a 	ret

81104da4 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104da4:	defffb04 	addi	sp,sp,-20
81104da8:	de00012e 	bgeu	sp,et,81104db0 <bDpktGetPixelDelay+0xc>
81104dac:	003b68fa 	trap	3
81104db0:	dfc00415 	stw	ra,16(sp)
81104db4:	df000315 	stw	fp,12(sp)
81104db8:	df000304 	addi	fp,sp,12
81104dbc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104dc0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104dc4:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104dc8:	e0bfff17 	ldw	r2,-4(fp)
81104dcc:	10002026 	beq	r2,zero,81104e50 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104dd0:	e0bfff17 	ldw	r2,-4(fp)
81104dd4:	10800017 	ldw	r2,0(r2)
81104dd8:	01400384 	movi	r5,14
81104ddc:	1009883a 	mov	r4,r2
81104de0:	11050300 	call	81105030 <uliDpktReadReg>
81104de4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104de8:	e0bffe17 	ldw	r2,-8(fp)
81104dec:	1007883a 	mov	r3,r2
81104df0:	e0bfff17 	ldw	r2,-4(fp)
81104df4:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104df8:	e0bfff17 	ldw	r2,-4(fp)
81104dfc:	10800017 	ldw	r2,0(r2)
81104e00:	014003c4 	movi	r5,15
81104e04:	1009883a 	mov	r4,r2
81104e08:	11050300 	call	81105030 <uliDpktReadReg>
81104e0c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104e10:	e0bffe17 	ldw	r2,-8(fp)
81104e14:	1007883a 	mov	r3,r2
81104e18:	e0bfff17 	ldw	r2,-4(fp)
81104e1c:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e20:	e0bfff17 	ldw	r2,-4(fp)
81104e24:	10800017 	ldw	r2,0(r2)
81104e28:	01400404 	movi	r5,16
81104e2c:	1009883a 	mov	r4,r2
81104e30:	11050300 	call	81105030 <uliDpktReadReg>
81104e34:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104e38:	e0bffe17 	ldw	r2,-8(fp)
81104e3c:	1007883a 	mov	r3,r2
81104e40:	e0bfff17 	ldw	r2,-4(fp)
81104e44:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104e48:	00800044 	movi	r2,1
81104e4c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e50:	e0bffd17 	ldw	r2,-12(fp)
}
81104e54:	e037883a 	mov	sp,fp
81104e58:	dfc00117 	ldw	ra,4(sp)
81104e5c:	df000017 	ldw	fp,0(sp)
81104e60:	dec00204 	addi	sp,sp,8
81104e64:	f800283a 	ret

81104e68 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104e68:	defffb04 	addi	sp,sp,-20
81104e6c:	de00012e 	bgeu	sp,et,81104e74 <bDpktInitCh+0xc>
81104e70:	003b68fa 	trap	3
81104e74:	dfc00415 	stw	ra,16(sp)
81104e78:	df000315 	stw	fp,12(sp)
81104e7c:	df000304 	addi	fp,sp,12
81104e80:	e13ffe15 	stw	r4,-8(fp)
81104e84:	2805883a 	mov	r2,r5
81104e88:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104e8c:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104e90:	e0bffe17 	ldw	r2,-8(fp)
81104e94:	10004b26 	beq	r2,zero,81104fc4 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104e98:	00800044 	movi	r2,1
81104e9c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104ea0:	e0bfff03 	ldbu	r2,-4(fp)
81104ea4:	10c00228 	cmpgeui	r3,r2,8
81104ea8:	1800361e 	bne	r3,zero,81104f84 <bDpktInitCh+0x11c>
81104eac:	100690ba 	slli	r3,r2,2
81104eb0:	00a04434 	movhi	r2,33040
81104eb4:	1093b104 	addi	r2,r2,20164
81104eb8:	1885883a 	add	r2,r3,r2
81104ebc:	10800017 	ldw	r2,0(r2)
81104ec0:	1000683a 	jmp	r2
81104ec4:	81104ee4 	muli	r4,r16,16699
81104ec8:	81104ef8 	rdprs	r4,r16,16699
81104ecc:	81104f0c 	andi	r4,r16,16700
81104ed0:	81104f20 	cmpeqi	r4,r16,16700
81104ed4:	81104f34 	orhi	r4,r16,16700
81104ed8:	81104f48 	cmpgei	r4,r16,16701
81104edc:	81104f5c 	xori	r4,r16,16701
81104ee0:	81104f70 	cmpltui	r4,r16,16701
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104ee4:	e0fffe17 	ldw	r3,-8(fp)
81104ee8:	00a04834 	movhi	r2,33056
81104eec:	108b0004 	addi	r2,r2,11264
81104ef0:	18800015 	stw	r2,0(r3)
			break;
81104ef4:	00002506 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104ef8:	e0fffe17 	ldw	r3,-8(fp)
81104efc:	00a04834 	movhi	r2,33056
81104f00:	108a0004 	addi	r2,r2,10240
81104f04:	18800015 	stw	r2,0(r3)
			break;
81104f08:	00002006 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104f0c:	e0fffe17 	ldw	r3,-8(fp)
81104f10:	00a04834 	movhi	r2,33056
81104f14:	108b0004 	addi	r2,r2,11264
81104f18:	18800015 	stw	r2,0(r3)
			break;
81104f1c:	00001b06 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104f20:	e0fffe17 	ldw	r3,-8(fp)
81104f24:	00a04834 	movhi	r2,33056
81104f28:	108a0004 	addi	r2,r2,10240
81104f2c:	18800015 	stw	r2,0(r3)
			break;
81104f30:	00001606 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104f34:	e0fffe17 	ldw	r3,-8(fp)
81104f38:	00a04834 	movhi	r2,33056
81104f3c:	108b0004 	addi	r2,r2,11264
81104f40:	18800015 	stw	r2,0(r3)
			break;
81104f44:	00001106 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104f48:	e0fffe17 	ldw	r3,-8(fp)
81104f4c:	00a04834 	movhi	r2,33056
81104f50:	108a0004 	addi	r2,r2,10240
81104f54:	18800015 	stw	r2,0(r3)
			break;
81104f58:	00000c06 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104f5c:	e0fffe17 	ldw	r3,-8(fp)
81104f60:	00a04834 	movhi	r2,33056
81104f64:	108b0004 	addi	r2,r2,11264
81104f68:	18800015 	stw	r2,0(r3)
			break;
81104f6c:	00000706 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104f70:	e0fffe17 	ldw	r3,-8(fp)
81104f74:	00a04834 	movhi	r2,33056
81104f78:	108a0004 	addi	r2,r2,10240
81104f7c:	18800015 	stw	r2,0(r3)
			break;
81104f80:	00000206 	br	81104f8c <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104f84:	e03ffd15 	stw	zero,-12(fp)
			break;
81104f88:	0001883a 	nop
		}

		if (bStatus) {
81104f8c:	e0bffd17 	ldw	r2,-12(fp)
81104f90:	10000c26 	beq	r2,zero,81104fc4 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104f94:	e13ffe17 	ldw	r4,-8(fp)
81104f98:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
81104f9c:	1000011e 	bne	r2,zero,81104fa4 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104fa0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104fa4:	e13ffe17 	ldw	r4,-8(fp)
81104fa8:	1104b980 	call	81104b98 <bDpktGetPacketHeader>
81104fac:	1000011e 	bne	r2,zero,81104fb4 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104fb0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104fb4:	e13ffe17 	ldw	r4,-8(fp)
81104fb8:	1104da40 	call	81104da4 <bDpktGetPixelDelay>
81104fbc:	1000011e 	bne	r2,zero,81104fc4 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104fc0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104fc4:	e0bffd17 	ldw	r2,-12(fp)
}
81104fc8:	e037883a 	mov	sp,fp
81104fcc:	dfc00117 	ldw	ra,4(sp)
81104fd0:	df000017 	ldw	fp,0(sp)
81104fd4:	dec00204 	addi	sp,sp,8
81104fd8:	f800283a 	ret

81104fdc <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104fdc:	defffc04 	addi	sp,sp,-16
81104fe0:	de00012e 	bgeu	sp,et,81104fe8 <vDpktWriteReg+0xc>
81104fe4:	003b68fa 	trap	3
81104fe8:	df000315 	stw	fp,12(sp)
81104fec:	df000304 	addi	fp,sp,12
81104ff0:	e13ffd15 	stw	r4,-12(fp)
81104ff4:	e17ffe15 	stw	r5,-8(fp)
81104ff8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104ffc:	e0bffe17 	ldw	r2,-8(fp)
81105000:	1085883a 	add	r2,r2,r2
81105004:	1085883a 	add	r2,r2,r2
81105008:	1007883a 	mov	r3,r2
8110500c:	e0bffd17 	ldw	r2,-12(fp)
81105010:	10c5883a 	add	r2,r2,r3
81105014:	e0ffff17 	ldw	r3,-4(fp)
81105018:	10c00015 	stw	r3,0(r2)
}
8110501c:	0001883a 	nop
81105020:	e037883a 	mov	sp,fp
81105024:	df000017 	ldw	fp,0(sp)
81105028:	dec00104 	addi	sp,sp,4
8110502c:	f800283a 	ret

81105030 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105030:	defffc04 	addi	sp,sp,-16
81105034:	de00012e 	bgeu	sp,et,8110503c <uliDpktReadReg+0xc>
81105038:	003b68fa 	trap	3
8110503c:	df000315 	stw	fp,12(sp)
81105040:	df000304 	addi	fp,sp,12
81105044:	e13ffe15 	stw	r4,-8(fp)
81105048:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110504c:	e0bfff17 	ldw	r2,-4(fp)
81105050:	1085883a 	add	r2,r2,r2
81105054:	1085883a 	add	r2,r2,r2
81105058:	1007883a 	mov	r3,r2
8110505c:	e0bffe17 	ldw	r2,-8(fp)
81105060:	10c5883a 	add	r2,r2,r3
81105064:	10800017 	ldw	r2,0(r2)
81105068:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110506c:	e0bffd17 	ldw	r2,-12(fp)
}
81105070:	e037883a 	mov	sp,fp
81105074:	df000017 	ldw	fp,0(sp)
81105078:	dec00104 	addi	sp,sp,4
8110507c:	f800283a 	ret

81105080 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105080:	defffc04 	addi	sp,sp,-16
81105084:	de00012e 	bgeu	sp,et,8110508c <usiAdcPxDelayCalcPeriodNs+0xc>
81105088:	003b68fa 	trap	3
8110508c:	dfc00315 	stw	ra,12(sp)
81105090:	df000215 	stw	fp,8(sp)
81105094:	df000204 	addi	fp,sp,8
81105098:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
8110509c:	e13fff17 	ldw	r4,-4(fp)
811050a0:	11211b80 	call	811211b8 <__floatunsisf>
811050a4:	1007883a 	mov	r3,r2
811050a8:	1809883a 	mov	r4,r3
811050ac:	11225140 	call	81122514 <__extendsfdf2>
811050b0:	1011883a 	mov	r8,r2
811050b4:	1813883a 	mov	r9,r3
811050b8:	01a666b4 	movhi	r6,39322
811050bc:	31a66684 	addi	r6,r6,-26214
811050c0:	01cfeeb4 	movhi	r7,16314
811050c4:	39e66644 	addi	r7,r7,-26215
811050c8:	4009883a 	mov	r4,r8
811050cc:	480b883a 	mov	r5,r9
811050d0:	112138c0 	call	8112138c <__muldf3>
811050d4:	1009883a 	mov	r4,r2
811050d8:	180b883a 	mov	r5,r3
811050dc:	2005883a 	mov	r2,r4
811050e0:	2807883a 	mov	r3,r5
811050e4:	1009883a 	mov	r4,r2
811050e8:	180b883a 	mov	r5,r3
811050ec:	11207c40 	call	811207c4 <__fixunsdfsi>
811050f0:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811050f4:	e0bffe0b 	ldhu	r2,-8(fp)
}
811050f8:	e037883a 	mov	sp,fp
811050fc:	dfc00117 	ldw	ra,4(sp)
81105100:	df000017 	ldw	fp,0(sp)
81105104:	dec00204 	addi	sp,sp,8
81105108:	f800283a 	ret

8110510c <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
8110510c:	defffc04 	addi	sp,sp,-16
81105110:	de00012e 	bgeu	sp,et,81105118 <usiLineTrDelayCalcPeriodNs+0xc>
81105114:	003b68fa 	trap	3
81105118:	dfc00315 	stw	ra,12(sp)
8110511c:	df000215 	stw	fp,8(sp)
81105120:	df000204 	addi	fp,sp,8
81105124:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105128:	e13fff17 	ldw	r4,-4(fp)
8110512c:	11211b80 	call	811211b8 <__floatunsisf>
81105130:	1007883a 	mov	r3,r2
81105134:	1809883a 	mov	r4,r3
81105138:	11225140 	call	81122514 <__extendsfdf2>
8110513c:	1011883a 	mov	r8,r2
81105140:	1813883a 	mov	r9,r3
81105144:	0191ebb4 	movhi	r6,18350
81105148:	31851ec4 	addi	r6,r6,5243
8110514c:	01cfe134 	movhi	r7,16260
81105150:	39deb844 	addi	r7,r7,31457
81105154:	4009883a 	mov	r4,r8
81105158:	480b883a 	mov	r5,r9
8110515c:	112138c0 	call	8112138c <__muldf3>
81105160:	1009883a 	mov	r4,r2
81105164:	180b883a 	mov	r5,r3
81105168:	2005883a 	mov	r2,r4
8110516c:	2807883a 	mov	r3,r5
81105170:	1009883a 	mov	r4,r2
81105174:	180b883a 	mov	r5,r3
81105178:	11207c40 	call	811207c4 <__fixunsdfsi>
8110517c:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105180:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105184:	e037883a 	mov	sp,fp
81105188:	dfc00117 	ldw	ra,4(sp)
8110518c:	df000017 	ldw	fp,0(sp)
81105190:	dec00204 	addi	sp,sp,8
81105194:	f800283a 	ret

81105198 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105198:	defffd04 	addi	sp,sp,-12
8110519c:	de00012e 	bgeu	sp,et,811051a4 <vFeebCh1HandleIrq+0xc>
811051a0:	003b68fa 	trap	3
811051a4:	dfc00215 	stw	ra,8(sp)
811051a8:	df000115 	stw	fp,4(sp)
811051ac:	df000104 	addi	fp,sp,4
811051b0:	e13fff15 	stw	r4,-4(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	//INT8U error_codel;
	//tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
811051b4:	11053580 	call	81105358 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
811051b8:	0001883a 	nop
811051bc:	e037883a 	mov	sp,fp
811051c0:	dfc00117 	ldw	ra,4(sp)
811051c4:	df000017 	ldw	fp,0(sp)
811051c8:	dec00204 	addi	sp,sp,8
811051cc:	f800283a 	ret

811051d0 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811051d0:	defffd04 	addi	sp,sp,-12
811051d4:	de00012e 	bgeu	sp,et,811051dc <vFeebCh2HandleIrq+0xc>
811051d8:	003b68fa 	trap	3
811051dc:	dfc00215 	stw	ra,8(sp)
811051e0:	df000115 	stw	fp,4(sp)
811051e4:	df000104 	addi	fp,sp,4
811051e8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	//INT8U error_codel;
	//tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
811051ec:	110539c0 	call	8110539c <vFeebCh2IrqFlagClrBufferEmpty>
	if ( error_codel != OS_ERR_NONE ) {
		vFailRequestDMAFromIRQ( 1 );
	}
*/

}
811051f0:	0001883a 	nop
811051f4:	e037883a 	mov	sp,fp
811051f8:	dfc00117 	ldw	ra,4(sp)
811051fc:	df000017 	ldw	fp,0(sp)
81105200:	dec00204 	addi	sp,sp,8
81105204:	f800283a 	ret

81105208 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81105208:	defffd04 	addi	sp,sp,-12
8110520c:	de00012e 	bgeu	sp,et,81105214 <vFeebCh3HandleIrq+0xc>
81105210:	003b68fa 	trap	3
81105214:	dfc00215 	stw	ra,8(sp)
81105218:	df000115 	stw	fp,4(sp)
8110521c:	df000104 	addi	fp,sp,4
81105220:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 2 );
//	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105224:	11053e00 	call	811053e0 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105228:	0001883a 	nop
8110522c:	e037883a 	mov	sp,fp
81105230:	dfc00117 	ldw	ra,4(sp)
81105234:	df000017 	ldw	fp,0(sp)
81105238:	dec00204 	addi	sp,sp,8
8110523c:	f800283a 	ret

81105240 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105240:	defffd04 	addi	sp,sp,-12
81105244:	de00012e 	bgeu	sp,et,8110524c <vFeebCh4HandleIrq+0xc>
81105248:	003b68fa 	trap	3
8110524c:	dfc00215 	stw	ra,8(sp)
81105250:	df000115 	stw	fp,4(sp)
81105254:	df000104 	addi	fp,sp,4
81105258:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 3 );
//	}

	vFeebCh4IrqFlagClrBufferEmpty();
8110525c:	11054240 	call	81105424 <vFeebCh4IrqFlagClrBufferEmpty>
}
81105260:	0001883a 	nop
81105264:	e037883a 	mov	sp,fp
81105268:	dfc00117 	ldw	ra,4(sp)
8110526c:	df000017 	ldw	fp,0(sp)
81105270:	dec00204 	addi	sp,sp,8
81105274:	f800283a 	ret

81105278 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105278:	defffd04 	addi	sp,sp,-12
8110527c:	de00012e 	bgeu	sp,et,81105284 <vFeebCh5HandleIrq+0xc>
81105280:	003b68fa 	trap	3
81105284:	dfc00215 	stw	ra,8(sp)
81105288:	df000115 	stw	fp,4(sp)
8110528c:	df000104 	addi	fp,sp,4
81105290:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 4 );
//	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105294:	11054680 	call	81105468 <vFeebCh5IrqFlagClrBufferEmpty>
}
81105298:	0001883a 	nop
8110529c:	e037883a 	mov	sp,fp
811052a0:	dfc00117 	ldw	ra,4(sp)
811052a4:	df000017 	ldw	fp,0(sp)
811052a8:	dec00204 	addi	sp,sp,8
811052ac:	f800283a 	ret

811052b0 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811052b0:	defffd04 	addi	sp,sp,-12
811052b4:	de00012e 	bgeu	sp,et,811052bc <vFeebCh6HandleIrq+0xc>
811052b8:	003b68fa 	trap	3
811052bc:	dfc00215 	stw	ra,8(sp)
811052c0:	df000115 	stw	fp,4(sp)
811052c4:	df000104 	addi	fp,sp,4
811052c8:	e13fff15 	stw	r4,-4(fp)
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 5 );
//	}


	vFeebCh6IrqFlagClrBufferEmpty();
811052cc:	11054ac0 	call	811054ac <vFeebCh6IrqFlagClrBufferEmpty>
}
811052d0:	0001883a 	nop
811052d4:	e037883a 	mov	sp,fp
811052d8:	dfc00117 	ldw	ra,4(sp)
811052dc:	df000017 	ldw	fp,0(sp)
811052e0:	dec00204 	addi	sp,sp,8
811052e4:	f800283a 	ret

811052e8 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811052e8:	defffd04 	addi	sp,sp,-12
811052ec:	de00012e 	bgeu	sp,et,811052f4 <vFeebCh7HandleIrq+0xc>
811052f0:	003b68fa 	trap	3
811052f4:	dfc00215 	stw	ra,8(sp)
811052f8:	df000115 	stw	fp,4(sp)
811052fc:	df000104 	addi	fp,sp,4
81105300:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;


	vFeebCh7IrqFlagClrBufferEmpty();
81105304:	11054f00 	call	811054f0 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105308:	0001883a 	nop
8110530c:	e037883a 	mov	sp,fp
81105310:	dfc00117 	ldw	ra,4(sp)
81105314:	df000017 	ldw	fp,0(sp)
81105318:	dec00204 	addi	sp,sp,8
8110531c:	f800283a 	ret

81105320 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105320:	defffd04 	addi	sp,sp,-12
81105324:	de00012e 	bgeu	sp,et,8110532c <vFeebCh8HandleIrq+0xc>
81105328:	003b68fa 	trap	3
8110532c:	dfc00215 	stw	ra,8(sp)
81105330:	df000115 	stw	fp,4(sp)
81105334:	df000104 	addi	fp,sp,4
81105338:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;


	vFeebCh8IrqFlagClrBufferEmpty();
8110533c:	11055340 	call	81105534 <vFeebCh8IrqFlagClrBufferEmpty>
}
81105340:	0001883a 	nop
81105344:	e037883a 	mov	sp,fp
81105348:	dfc00117 	ldw	ra,4(sp)
8110534c:	df000017 	ldw	fp,0(sp)
81105350:	dec00204 	addi	sp,sp,8
81105354:	f800283a 	ret

81105358 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105358:	defffe04 	addi	sp,sp,-8
8110535c:	de00012e 	bgeu	sp,et,81105364 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105360:	003b68fa 	trap	3
81105364:	dfc00115 	stw	ra,4(sp)
81105368:	df000015 	stw	fp,0(sp)
8110536c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105370:	01804004 	movi	r6,256
81105374:	014004c4 	movi	r5,19
81105378:	01204834 	movhi	r4,33056
8110537c:	210b0004 	addi	r4,r4,11264
81105380:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105384:	0001883a 	nop
81105388:	e037883a 	mov	sp,fp
8110538c:	dfc00117 	ldw	ra,4(sp)
81105390:	df000017 	ldw	fp,0(sp)
81105394:	dec00204 	addi	sp,sp,8
81105398:	f800283a 	ret

8110539c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
8110539c:	defffe04 	addi	sp,sp,-8
811053a0:	de00012e 	bgeu	sp,et,811053a8 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811053a4:	003b68fa 	trap	3
811053a8:	dfc00115 	stw	ra,4(sp)
811053ac:	df000015 	stw	fp,0(sp)
811053b0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811053b4:	01804004 	movi	r6,256
811053b8:	014004c4 	movi	r5,19
811053bc:	01204834 	movhi	r4,33056
811053c0:	210a0004 	addi	r4,r4,10240
811053c4:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053c8:	0001883a 	nop
811053cc:	e037883a 	mov	sp,fp
811053d0:	dfc00117 	ldw	ra,4(sp)
811053d4:	df000017 	ldw	fp,0(sp)
811053d8:	dec00204 	addi	sp,sp,8
811053dc:	f800283a 	ret

811053e0 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811053e0:	defffe04 	addi	sp,sp,-8
811053e4:	de00012e 	bgeu	sp,et,811053ec <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811053e8:	003b68fa 	trap	3
811053ec:	dfc00115 	stw	ra,4(sp)
811053f0:	df000015 	stw	fp,0(sp)
811053f4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811053f8:	01804004 	movi	r6,256
811053fc:	014004c4 	movi	r5,19
81105400:	01204834 	movhi	r4,33056
81105404:	210b0004 	addi	r4,r4,11264
81105408:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110540c:	0001883a 	nop
81105410:	e037883a 	mov	sp,fp
81105414:	dfc00117 	ldw	ra,4(sp)
81105418:	df000017 	ldw	fp,0(sp)
8110541c:	dec00204 	addi	sp,sp,8
81105420:	f800283a 	ret

81105424 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105424:	defffe04 	addi	sp,sp,-8
81105428:	de00012e 	bgeu	sp,et,81105430 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
8110542c:	003b68fa 	trap	3
81105430:	dfc00115 	stw	ra,4(sp)
81105434:	df000015 	stw	fp,0(sp)
81105438:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110543c:	01804004 	movi	r6,256
81105440:	014004c4 	movi	r5,19
81105444:	01204834 	movhi	r4,33056
81105448:	210a0004 	addi	r4,r4,10240
8110544c:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105450:	0001883a 	nop
81105454:	e037883a 	mov	sp,fp
81105458:	dfc00117 	ldw	ra,4(sp)
8110545c:	df000017 	ldw	fp,0(sp)
81105460:	dec00204 	addi	sp,sp,8
81105464:	f800283a 	ret

81105468 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105468:	defffe04 	addi	sp,sp,-8
8110546c:	de00012e 	bgeu	sp,et,81105474 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105470:	003b68fa 	trap	3
81105474:	dfc00115 	stw	ra,4(sp)
81105478:	df000015 	stw	fp,0(sp)
8110547c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105480:	01804004 	movi	r6,256
81105484:	014004c4 	movi	r5,19
81105488:	01204834 	movhi	r4,33056
8110548c:	210b0004 	addi	r4,r4,11264
81105490:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105494:	0001883a 	nop
81105498:	e037883a 	mov	sp,fp
8110549c:	dfc00117 	ldw	ra,4(sp)
811054a0:	df000017 	ldw	fp,0(sp)
811054a4:	dec00204 	addi	sp,sp,8
811054a8:	f800283a 	ret

811054ac <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811054ac:	defffe04 	addi	sp,sp,-8
811054b0:	de00012e 	bgeu	sp,et,811054b8 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811054b4:	003b68fa 	trap	3
811054b8:	dfc00115 	stw	ra,4(sp)
811054bc:	df000015 	stw	fp,0(sp)
811054c0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811054c4:	01804004 	movi	r6,256
811054c8:	014004c4 	movi	r5,19
811054cc:	01204834 	movhi	r4,33056
811054d0:	210a0004 	addi	r4,r4,10240
811054d4:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054d8:	0001883a 	nop
811054dc:	e037883a 	mov	sp,fp
811054e0:	dfc00117 	ldw	ra,4(sp)
811054e4:	df000017 	ldw	fp,0(sp)
811054e8:	dec00204 	addi	sp,sp,8
811054ec:	f800283a 	ret

811054f0 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811054f0:	defffe04 	addi	sp,sp,-8
811054f4:	de00012e 	bgeu	sp,et,811054fc <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811054f8:	003b68fa 	trap	3
811054fc:	dfc00115 	stw	ra,4(sp)
81105500:	df000015 	stw	fp,0(sp)
81105504:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105508:	01804004 	movi	r6,256
8110550c:	014004c4 	movi	r5,19
81105510:	01204834 	movhi	r4,33056
81105514:	210b0004 	addi	r4,r4,11264
81105518:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110551c:	0001883a 	nop
81105520:	e037883a 	mov	sp,fp
81105524:	dfc00117 	ldw	ra,4(sp)
81105528:	df000017 	ldw	fp,0(sp)
8110552c:	dec00204 	addi	sp,sp,8
81105530:	f800283a 	ret

81105534 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105534:	defffe04 	addi	sp,sp,-8
81105538:	de00012e 	bgeu	sp,et,81105540 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
8110553c:	003b68fa 	trap	3
81105540:	dfc00115 	stw	ra,4(sp)
81105544:	df000015 	stw	fp,0(sp)
81105548:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110554c:	01804004 	movi	r6,256
81105550:	014004c4 	movi	r5,19
81105554:	01204834 	movhi	r4,33056
81105558:	210a0004 	addi	r4,r4,10240
8110555c:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105560:	0001883a 	nop
81105564:	e037883a 	mov	sp,fp
81105568:	dfc00117 	ldw	ra,4(sp)
8110556c:	df000017 	ldw	fp,0(sp)
81105570:	dec00204 	addi	sp,sp,8
81105574:	f800283a 	ret

81105578 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105578:	defffd04 	addi	sp,sp,-12
8110557c:	de00012e 	bgeu	sp,et,81105584 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105580:	003b68fa 	trap	3
81105584:	dfc00215 	stw	ra,8(sp)
81105588:	df000115 	stw	fp,4(sp)
8110558c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105590:	01400484 	movi	r5,18
81105594:	01204834 	movhi	r4,33056
81105598:	210b0004 	addi	r4,r4,11264
8110559c:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055a0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811055a4:	10000326 	beq	r2,zero,811055b4 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055a8:	00800044 	movi	r2,1
811055ac:	e0bfff15 	stw	r2,-4(fp)
811055b0:	00000106 	br	811055b8 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811055b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055b8:	e0bfff17 	ldw	r2,-4(fp)
}
811055bc:	e037883a 	mov	sp,fp
811055c0:	dfc00117 	ldw	ra,4(sp)
811055c4:	df000017 	ldw	fp,0(sp)
811055c8:	dec00204 	addi	sp,sp,8
811055cc:	f800283a 	ret

811055d0 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811055d0:	defffd04 	addi	sp,sp,-12
811055d4:	de00012e 	bgeu	sp,et,811055dc <bFeebCh2IrqFlagBufferEmpty+0xc>
811055d8:	003b68fa 	trap	3
811055dc:	dfc00215 	stw	ra,8(sp)
811055e0:	df000115 	stw	fp,4(sp)
811055e4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055e8:	01400484 	movi	r5,18
811055ec:	01204834 	movhi	r4,33056
811055f0:	210a0004 	addi	r4,r4,10240
811055f4:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055f8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055fc:	10000326 	beq	r2,zero,8110560c <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105600:	00800044 	movi	r2,1
81105604:	e0bfff15 	stw	r2,-4(fp)
81105608:	00000106 	br	81105610 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110560c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105610:	e0bfff17 	ldw	r2,-4(fp)
}
81105614:	e037883a 	mov	sp,fp
81105618:	dfc00117 	ldw	ra,4(sp)
8110561c:	df000017 	ldw	fp,0(sp)
81105620:	dec00204 	addi	sp,sp,8
81105624:	f800283a 	ret

81105628 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105628:	defffd04 	addi	sp,sp,-12
8110562c:	de00012e 	bgeu	sp,et,81105634 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105630:	003b68fa 	trap	3
81105634:	dfc00215 	stw	ra,8(sp)
81105638:	df000115 	stw	fp,4(sp)
8110563c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105640:	01400484 	movi	r5,18
81105644:	01204834 	movhi	r4,33056
81105648:	210b0004 	addi	r4,r4,11264
8110564c:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105650:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105654:	10000326 	beq	r2,zero,81105664 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105658:	00800044 	movi	r2,1
8110565c:	e0bfff15 	stw	r2,-4(fp)
81105660:	00000106 	br	81105668 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105664:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105668:	e0bfff17 	ldw	r2,-4(fp)
}
8110566c:	e037883a 	mov	sp,fp
81105670:	dfc00117 	ldw	ra,4(sp)
81105674:	df000017 	ldw	fp,0(sp)
81105678:	dec00204 	addi	sp,sp,8
8110567c:	f800283a 	ret

81105680 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105680:	defffd04 	addi	sp,sp,-12
81105684:	de00012e 	bgeu	sp,et,8110568c <bFeebCh4IrqFlagBufferEmpty+0xc>
81105688:	003b68fa 	trap	3
8110568c:	dfc00215 	stw	ra,8(sp)
81105690:	df000115 	stw	fp,4(sp)
81105694:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105698:	01400484 	movi	r5,18
8110569c:	01204834 	movhi	r4,33056
811056a0:	210a0004 	addi	r4,r4,10240
811056a4:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056a8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811056ac:	10000326 	beq	r2,zero,811056bc <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056b0:	00800044 	movi	r2,1
811056b4:	e0bfff15 	stw	r2,-4(fp)
811056b8:	00000106 	br	811056c0 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056c0:	e0bfff17 	ldw	r2,-4(fp)
}
811056c4:	e037883a 	mov	sp,fp
811056c8:	dfc00117 	ldw	ra,4(sp)
811056cc:	df000017 	ldw	fp,0(sp)
811056d0:	dec00204 	addi	sp,sp,8
811056d4:	f800283a 	ret

811056d8 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811056d8:	defffd04 	addi	sp,sp,-12
811056dc:	de00012e 	bgeu	sp,et,811056e4 <bFeebCh5IrqFlagBufferEmpty+0xc>
811056e0:	003b68fa 	trap	3
811056e4:	dfc00215 	stw	ra,8(sp)
811056e8:	df000115 	stw	fp,4(sp)
811056ec:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811056f0:	01400484 	movi	r5,18
811056f4:	01204834 	movhi	r4,33056
811056f8:	210b0004 	addi	r4,r4,11264
811056fc:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105700:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105704:	10000326 	beq	r2,zero,81105714 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105708:	00800044 	movi	r2,1
8110570c:	e0bfff15 	stw	r2,-4(fp)
81105710:	00000106 	br	81105718 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105714:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105718:	e0bfff17 	ldw	r2,-4(fp)
}
8110571c:	e037883a 	mov	sp,fp
81105720:	dfc00117 	ldw	ra,4(sp)
81105724:	df000017 	ldw	fp,0(sp)
81105728:	dec00204 	addi	sp,sp,8
8110572c:	f800283a 	ret

81105730 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105730:	defffd04 	addi	sp,sp,-12
81105734:	de00012e 	bgeu	sp,et,8110573c <bFeebCh6IrqFlagBufferEmpty+0xc>
81105738:	003b68fa 	trap	3
8110573c:	dfc00215 	stw	ra,8(sp)
81105740:	df000115 	stw	fp,4(sp)
81105744:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105748:	01400484 	movi	r5,18
8110574c:	01204834 	movhi	r4,33056
81105750:	210a0004 	addi	r4,r4,10240
81105754:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105758:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110575c:	10000326 	beq	r2,zero,8110576c <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105760:	00800044 	movi	r2,1
81105764:	e0bfff15 	stw	r2,-4(fp)
81105768:	00000106 	br	81105770 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110576c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105770:	e0bfff17 	ldw	r2,-4(fp)
}
81105774:	e037883a 	mov	sp,fp
81105778:	dfc00117 	ldw	ra,4(sp)
8110577c:	df000017 	ldw	fp,0(sp)
81105780:	dec00204 	addi	sp,sp,8
81105784:	f800283a 	ret

81105788 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105788:	defffd04 	addi	sp,sp,-12
8110578c:	de00012e 	bgeu	sp,et,81105794 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105790:	003b68fa 	trap	3
81105794:	dfc00215 	stw	ra,8(sp)
81105798:	df000115 	stw	fp,4(sp)
8110579c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057a0:	01400484 	movi	r5,18
811057a4:	01204834 	movhi	r4,33056
811057a8:	210b0004 	addi	r4,r4,11264
811057ac:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057b0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057b4:	10000326 	beq	r2,zero,811057c4 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057b8:	00800044 	movi	r2,1
811057bc:	e0bfff15 	stw	r2,-4(fp)
811057c0:	00000106 	br	811057c8 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057c4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057c8:	e0bfff17 	ldw	r2,-4(fp)
}
811057cc:	e037883a 	mov	sp,fp
811057d0:	dfc00117 	ldw	ra,4(sp)
811057d4:	df000017 	ldw	fp,0(sp)
811057d8:	dec00204 	addi	sp,sp,8
811057dc:	f800283a 	ret

811057e0 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811057e0:	defffd04 	addi	sp,sp,-12
811057e4:	de00012e 	bgeu	sp,et,811057ec <bFeebCh8IrqFlagBufferEmpty+0xc>
811057e8:	003b68fa 	trap	3
811057ec:	dfc00215 	stw	ra,8(sp)
811057f0:	df000115 	stw	fp,4(sp)
811057f4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811057f8:	01400484 	movi	r5,18
811057fc:	01204834 	movhi	r4,33056
81105800:	210a0004 	addi	r4,r4,10240
81105804:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105808:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110580c:	10000326 	beq	r2,zero,8110581c <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105810:	00800044 	movi	r2,1
81105814:	e0bfff15 	stw	r2,-4(fp)
81105818:	00000106 	br	81105820 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110581c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105820:	e0bfff17 	ldw	r2,-4(fp)
}
81105824:	e037883a 	mov	sp,fp
81105828:	dfc00117 	ldw	ra,4(sp)
8110582c:	df000017 	ldw	fp,0(sp)
81105830:	dec00204 	addi	sp,sp,8
81105834:	f800283a 	ret

81105838 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105838:	defffa04 	addi	sp,sp,-24
8110583c:	de00012e 	bgeu	sp,et,81105844 <bFeebCh1SetBufferSize+0xc>
81105840:	003b68fa 	trap	3
81105844:	dfc00515 	stw	ra,20(sp)
81105848:	df000415 	stw	fp,16(sp)
8110584c:	df000404 	addi	fp,sp,16
81105850:	2007883a 	mov	r3,r4
81105854:	2805883a 	mov	r2,r5
81105858:	e0fffe05 	stb	r3,-8(fp)
8110585c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105860:	00800044 	movi	r2,1
81105864:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105868:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
8110586c:	e0bffe03 	ldbu	r2,-8(fp)
81105870:	10001f26 	beq	r2,zero,811058f0 <bFeebCh1SetBufferSize+0xb8>
81105874:	e0bffe03 	ldbu	r2,-8(fp)
81105878:	10800468 	cmpgeui	r2,r2,17
8110587c:	10001c1e 	bne	r2,zero,811058f0 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105880:	e0bfff03 	ldbu	r2,-4(fp)
81105884:	10000326 	beq	r2,zero,81105894 <bFeebCh1SetBufferSize+0x5c>
81105888:	10800060 	cmpeqi	r2,r2,1
8110588c:	10000b1e 	bne	r2,zero,811058bc <bFeebCh1SetBufferSize+0x84>
81105890:	00001406 	br	811058e4 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105894:	e0bffe03 	ldbu	r2,-8(fp)
81105898:	10bfffc4 	addi	r2,r2,-1
8110589c:	108003cc 	andi	r2,r2,15
811058a0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811058a4:	e1bffd17 	ldw	r6,-12(fp)
811058a8:	01400544 	movi	r5,21
811058ac:	01204834 	movhi	r4,33056
811058b0:	210b0004 	addi	r4,r4,11264
811058b4:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811058b8:	00000c06 	br	811058ec <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811058bc:	e0bffe03 	ldbu	r2,-8(fp)
811058c0:	10bfffc4 	addi	r2,r2,-1
811058c4:	108003cc 	andi	r2,r2,15
811058c8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811058cc:	e1bffd17 	ldw	r6,-12(fp)
811058d0:	01400504 	movi	r5,20
811058d4:	01204834 	movhi	r4,33056
811058d8:	210b0004 	addi	r4,r4,11264
811058dc:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811058e0:	00000206 	br	811058ec <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811058e4:	e03ffc15 	stw	zero,-16(fp)
			break;
811058e8:	0001883a 	nop
		}
	} else {
811058ec:	00000106 	br	811058f4 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
811058f0:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811058f4:	e0bffc17 	ldw	r2,-16(fp)
}
811058f8:	e037883a 	mov	sp,fp
811058fc:	dfc00117 	ldw	ra,4(sp)
81105900:	df000017 	ldw	fp,0(sp)
81105904:	dec00204 	addi	sp,sp,8
81105908:	f800283a 	ret

8110590c <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8110590c:	defffa04 	addi	sp,sp,-24
81105910:	de00012e 	bgeu	sp,et,81105918 <bFeebCh2SetBufferSize+0xc>
81105914:	003b68fa 	trap	3
81105918:	dfc00515 	stw	ra,20(sp)
8110591c:	df000415 	stw	fp,16(sp)
81105920:	df000404 	addi	fp,sp,16
81105924:	2007883a 	mov	r3,r4
81105928:	2805883a 	mov	r2,r5
8110592c:	e0fffe05 	stb	r3,-8(fp)
81105930:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105934:	00800044 	movi	r2,1
81105938:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
8110593c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105940:	e0bffe03 	ldbu	r2,-8(fp)
81105944:	10001f26 	beq	r2,zero,811059c4 <bFeebCh2SetBufferSize+0xb8>
81105948:	e0bffe03 	ldbu	r2,-8(fp)
8110594c:	10800468 	cmpgeui	r2,r2,17
81105950:	10001c1e 	bne	r2,zero,811059c4 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105954:	e0bfff03 	ldbu	r2,-4(fp)
81105958:	10000326 	beq	r2,zero,81105968 <bFeebCh2SetBufferSize+0x5c>
8110595c:	10800060 	cmpeqi	r2,r2,1
81105960:	10000b1e 	bne	r2,zero,81105990 <bFeebCh2SetBufferSize+0x84>
81105964:	00001406 	br	811059b8 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105968:	e0bffe03 	ldbu	r2,-8(fp)
8110596c:	10bfffc4 	addi	r2,r2,-1
81105970:	108003cc 	andi	r2,r2,15
81105974:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105978:	e1bffd17 	ldw	r6,-12(fp)
8110597c:	01400544 	movi	r5,21
81105980:	01204834 	movhi	r4,33056
81105984:	210a0004 	addi	r4,r4,10240
81105988:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110598c:	00000c06 	br	811059c0 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105990:	e0bffe03 	ldbu	r2,-8(fp)
81105994:	10bfffc4 	addi	r2,r2,-1
81105998:	108003cc 	andi	r2,r2,15
8110599c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811059a0:	e1bffd17 	ldw	r6,-12(fp)
811059a4:	01400504 	movi	r5,20
811059a8:	01204834 	movhi	r4,33056
811059ac:	210a0004 	addi	r4,r4,10240
811059b0:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811059b4:	00000206 	br	811059c0 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811059b8:	e03ffc15 	stw	zero,-16(fp)
			break;
811059bc:	0001883a 	nop
		}
	} else {
811059c0:	00000106 	br	811059c8 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
811059c4:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811059c8:	e0bffc17 	ldw	r2,-16(fp)
}
811059cc:	e037883a 	mov	sp,fp
811059d0:	dfc00117 	ldw	ra,4(sp)
811059d4:	df000017 	ldw	fp,0(sp)
811059d8:	dec00204 	addi	sp,sp,8
811059dc:	f800283a 	ret

811059e0 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811059e0:	defffa04 	addi	sp,sp,-24
811059e4:	de00012e 	bgeu	sp,et,811059ec <bFeebCh3SetBufferSize+0xc>
811059e8:	003b68fa 	trap	3
811059ec:	dfc00515 	stw	ra,20(sp)
811059f0:	df000415 	stw	fp,16(sp)
811059f4:	df000404 	addi	fp,sp,16
811059f8:	2007883a 	mov	r3,r4
811059fc:	2805883a 	mov	r2,r5
81105a00:	e0fffe05 	stb	r3,-8(fp)
81105a04:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105a08:	00800044 	movi	r2,1
81105a0c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105a10:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105a14:	e0bffe03 	ldbu	r2,-8(fp)
81105a18:	10001f26 	beq	r2,zero,81105a98 <bFeebCh3SetBufferSize+0xb8>
81105a1c:	e0bffe03 	ldbu	r2,-8(fp)
81105a20:	10800468 	cmpgeui	r2,r2,17
81105a24:	10001c1e 	bne	r2,zero,81105a98 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105a28:	e0bfff03 	ldbu	r2,-4(fp)
81105a2c:	10000326 	beq	r2,zero,81105a3c <bFeebCh3SetBufferSize+0x5c>
81105a30:	10800060 	cmpeqi	r2,r2,1
81105a34:	10000b1e 	bne	r2,zero,81105a64 <bFeebCh3SetBufferSize+0x84>
81105a38:	00001406 	br	81105a8c <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a3c:	e0bffe03 	ldbu	r2,-8(fp)
81105a40:	10bfffc4 	addi	r2,r2,-1
81105a44:	108003cc 	andi	r2,r2,15
81105a48:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105a4c:	e1bffd17 	ldw	r6,-12(fp)
81105a50:	01400544 	movi	r5,21
81105a54:	01204834 	movhi	r4,33056
81105a58:	210b0004 	addi	r4,r4,11264
81105a5c:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a60:	00000c06 	br	81105a94 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a64:	e0bffe03 	ldbu	r2,-8(fp)
81105a68:	10bfffc4 	addi	r2,r2,-1
81105a6c:	108003cc 	andi	r2,r2,15
81105a70:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105a74:	e1bffd17 	ldw	r6,-12(fp)
81105a78:	01400504 	movi	r5,20
81105a7c:	01204834 	movhi	r4,33056
81105a80:	210b0004 	addi	r4,r4,11264
81105a84:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a88:	00000206 	br	81105a94 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a8c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a90:	0001883a 	nop
		}
	} else {
81105a94:	00000106 	br	81105a9c <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105a98:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a9c:	e0bffc17 	ldw	r2,-16(fp)
}
81105aa0:	e037883a 	mov	sp,fp
81105aa4:	dfc00117 	ldw	ra,4(sp)
81105aa8:	df000017 	ldw	fp,0(sp)
81105aac:	dec00204 	addi	sp,sp,8
81105ab0:	f800283a 	ret

81105ab4 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105ab4:	defffa04 	addi	sp,sp,-24
81105ab8:	de00012e 	bgeu	sp,et,81105ac0 <bFeebCh4SetBufferSize+0xc>
81105abc:	003b68fa 	trap	3
81105ac0:	dfc00515 	stw	ra,20(sp)
81105ac4:	df000415 	stw	fp,16(sp)
81105ac8:	df000404 	addi	fp,sp,16
81105acc:	2007883a 	mov	r3,r4
81105ad0:	2805883a 	mov	r2,r5
81105ad4:	e0fffe05 	stb	r3,-8(fp)
81105ad8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105adc:	00800044 	movi	r2,1
81105ae0:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ae4:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ae8:	e0bffe03 	ldbu	r2,-8(fp)
81105aec:	10001f26 	beq	r2,zero,81105b6c <bFeebCh4SetBufferSize+0xb8>
81105af0:	e0bffe03 	ldbu	r2,-8(fp)
81105af4:	10800468 	cmpgeui	r2,r2,17
81105af8:	10001c1e 	bne	r2,zero,81105b6c <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105afc:	e0bfff03 	ldbu	r2,-4(fp)
81105b00:	10000326 	beq	r2,zero,81105b10 <bFeebCh4SetBufferSize+0x5c>
81105b04:	10800060 	cmpeqi	r2,r2,1
81105b08:	10000b1e 	bne	r2,zero,81105b38 <bFeebCh4SetBufferSize+0x84>
81105b0c:	00001406 	br	81105b60 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b10:	e0bffe03 	ldbu	r2,-8(fp)
81105b14:	10bfffc4 	addi	r2,r2,-1
81105b18:	108003cc 	andi	r2,r2,15
81105b1c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b20:	e1bffd17 	ldw	r6,-12(fp)
81105b24:	01400544 	movi	r5,21
81105b28:	01204834 	movhi	r4,33056
81105b2c:	210a0004 	addi	r4,r4,10240
81105b30:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b34:	00000c06 	br	81105b68 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b38:	e0bffe03 	ldbu	r2,-8(fp)
81105b3c:	10bfffc4 	addi	r2,r2,-1
81105b40:	108003cc 	andi	r2,r2,15
81105b44:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b48:	e1bffd17 	ldw	r6,-12(fp)
81105b4c:	01400504 	movi	r5,20
81105b50:	01204834 	movhi	r4,33056
81105b54:	210a0004 	addi	r4,r4,10240
81105b58:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b5c:	00000206 	br	81105b68 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105b60:	e03ffc15 	stw	zero,-16(fp)
			break;
81105b64:	0001883a 	nop
		}
	} else {
81105b68:	00000106 	br	81105b70 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105b6c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105b70:	e0bffc17 	ldw	r2,-16(fp)
}
81105b74:	e037883a 	mov	sp,fp
81105b78:	dfc00117 	ldw	ra,4(sp)
81105b7c:	df000017 	ldw	fp,0(sp)
81105b80:	dec00204 	addi	sp,sp,8
81105b84:	f800283a 	ret

81105b88 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b88:	defffa04 	addi	sp,sp,-24
81105b8c:	de00012e 	bgeu	sp,et,81105b94 <bFeebCh5SetBufferSize+0xc>
81105b90:	003b68fa 	trap	3
81105b94:	dfc00515 	stw	ra,20(sp)
81105b98:	df000415 	stw	fp,16(sp)
81105b9c:	df000404 	addi	fp,sp,16
81105ba0:	2007883a 	mov	r3,r4
81105ba4:	2805883a 	mov	r2,r5
81105ba8:	e0fffe05 	stb	r3,-8(fp)
81105bac:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105bb0:	00800044 	movi	r2,1
81105bb4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105bb8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105bbc:	e0bffe03 	ldbu	r2,-8(fp)
81105bc0:	10001f26 	beq	r2,zero,81105c40 <bFeebCh5SetBufferSize+0xb8>
81105bc4:	e0bffe03 	ldbu	r2,-8(fp)
81105bc8:	10800468 	cmpgeui	r2,r2,17
81105bcc:	10001c1e 	bne	r2,zero,81105c40 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105bd0:	e0bfff03 	ldbu	r2,-4(fp)
81105bd4:	10000326 	beq	r2,zero,81105be4 <bFeebCh5SetBufferSize+0x5c>
81105bd8:	10800060 	cmpeqi	r2,r2,1
81105bdc:	10000b1e 	bne	r2,zero,81105c0c <bFeebCh5SetBufferSize+0x84>
81105be0:	00001406 	br	81105c34 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105be4:	e0bffe03 	ldbu	r2,-8(fp)
81105be8:	10bfffc4 	addi	r2,r2,-1
81105bec:	108003cc 	andi	r2,r2,15
81105bf0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105bf4:	e1bffd17 	ldw	r6,-12(fp)
81105bf8:	01400544 	movi	r5,21
81105bfc:	01204834 	movhi	r4,33056
81105c00:	210b0004 	addi	r4,r4,11264
81105c04:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c08:	00000c06 	br	81105c3c <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c0c:	e0bffe03 	ldbu	r2,-8(fp)
81105c10:	10bfffc4 	addi	r2,r2,-1
81105c14:	108003cc 	andi	r2,r2,15
81105c18:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105c1c:	e1bffd17 	ldw	r6,-12(fp)
81105c20:	01400504 	movi	r5,20
81105c24:	01204834 	movhi	r4,33056
81105c28:	210b0004 	addi	r4,r4,11264
81105c2c:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c30:	00000206 	br	81105c3c <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105c34:	e03ffc15 	stw	zero,-16(fp)
			break;
81105c38:	0001883a 	nop
		}
	} else {
81105c3c:	00000106 	br	81105c44 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105c40:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105c44:	e0bffc17 	ldw	r2,-16(fp)
}
81105c48:	e037883a 	mov	sp,fp
81105c4c:	dfc00117 	ldw	ra,4(sp)
81105c50:	df000017 	ldw	fp,0(sp)
81105c54:	dec00204 	addi	sp,sp,8
81105c58:	f800283a 	ret

81105c5c <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105c5c:	defffa04 	addi	sp,sp,-24
81105c60:	de00012e 	bgeu	sp,et,81105c68 <bFeebCh6SetBufferSize+0xc>
81105c64:	003b68fa 	trap	3
81105c68:	dfc00515 	stw	ra,20(sp)
81105c6c:	df000415 	stw	fp,16(sp)
81105c70:	df000404 	addi	fp,sp,16
81105c74:	2007883a 	mov	r3,r4
81105c78:	2805883a 	mov	r2,r5
81105c7c:	e0fffe05 	stb	r3,-8(fp)
81105c80:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c84:	00800044 	movi	r2,1
81105c88:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c8c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c90:	e0bffe03 	ldbu	r2,-8(fp)
81105c94:	10001f26 	beq	r2,zero,81105d14 <bFeebCh6SetBufferSize+0xb8>
81105c98:	e0bffe03 	ldbu	r2,-8(fp)
81105c9c:	10800468 	cmpgeui	r2,r2,17
81105ca0:	10001c1e 	bne	r2,zero,81105d14 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ca4:	e0bfff03 	ldbu	r2,-4(fp)
81105ca8:	10000326 	beq	r2,zero,81105cb8 <bFeebCh6SetBufferSize+0x5c>
81105cac:	10800060 	cmpeqi	r2,r2,1
81105cb0:	10000b1e 	bne	r2,zero,81105ce0 <bFeebCh6SetBufferSize+0x84>
81105cb4:	00001406 	br	81105d08 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105cb8:	e0bffe03 	ldbu	r2,-8(fp)
81105cbc:	10bfffc4 	addi	r2,r2,-1
81105cc0:	108003cc 	andi	r2,r2,15
81105cc4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105cc8:	e1bffd17 	ldw	r6,-12(fp)
81105ccc:	01400544 	movi	r5,21
81105cd0:	01204834 	movhi	r4,33056
81105cd4:	210a0004 	addi	r4,r4,10240
81105cd8:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cdc:	00000c06 	br	81105d10 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ce0:	e0bffe03 	ldbu	r2,-8(fp)
81105ce4:	10bfffc4 	addi	r2,r2,-1
81105ce8:	108003cc 	andi	r2,r2,15
81105cec:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105cf0:	e1bffd17 	ldw	r6,-12(fp)
81105cf4:	01400504 	movi	r5,20
81105cf8:	01204834 	movhi	r4,33056
81105cfc:	210a0004 	addi	r4,r4,10240
81105d00:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d04:	00000206 	br	81105d10 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105d08:	e03ffc15 	stw	zero,-16(fp)
			break;
81105d0c:	0001883a 	nop
		}
	} else {
81105d10:	00000106 	br	81105d18 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105d14:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105d18:	e0bffc17 	ldw	r2,-16(fp)
}
81105d1c:	e037883a 	mov	sp,fp
81105d20:	dfc00117 	ldw	ra,4(sp)
81105d24:	df000017 	ldw	fp,0(sp)
81105d28:	dec00204 	addi	sp,sp,8
81105d2c:	f800283a 	ret

81105d30 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d30:	defffa04 	addi	sp,sp,-24
81105d34:	de00012e 	bgeu	sp,et,81105d3c <bFeebCh7SetBufferSize+0xc>
81105d38:	003b68fa 	trap	3
81105d3c:	dfc00515 	stw	ra,20(sp)
81105d40:	df000415 	stw	fp,16(sp)
81105d44:	df000404 	addi	fp,sp,16
81105d48:	2007883a 	mov	r3,r4
81105d4c:	2805883a 	mov	r2,r5
81105d50:	e0fffe05 	stb	r3,-8(fp)
81105d54:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105d58:	00800044 	movi	r2,1
81105d5c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105d60:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105d64:	e0bffe03 	ldbu	r2,-8(fp)
81105d68:	10001f26 	beq	r2,zero,81105de8 <bFeebCh7SetBufferSize+0xb8>
81105d6c:	e0bffe03 	ldbu	r2,-8(fp)
81105d70:	10800468 	cmpgeui	r2,r2,17
81105d74:	10001c1e 	bne	r2,zero,81105de8 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d78:	e0bfff03 	ldbu	r2,-4(fp)
81105d7c:	10000326 	beq	r2,zero,81105d8c <bFeebCh7SetBufferSize+0x5c>
81105d80:	10800060 	cmpeqi	r2,r2,1
81105d84:	10000b1e 	bne	r2,zero,81105db4 <bFeebCh7SetBufferSize+0x84>
81105d88:	00001406 	br	81105ddc <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d8c:	e0bffe03 	ldbu	r2,-8(fp)
81105d90:	10bfffc4 	addi	r2,r2,-1
81105d94:	108003cc 	andi	r2,r2,15
81105d98:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105d9c:	e1bffd17 	ldw	r6,-12(fp)
81105da0:	01400544 	movi	r5,21
81105da4:	01204834 	movhi	r4,33056
81105da8:	210b0004 	addi	r4,r4,11264
81105dac:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105db0:	00000c06 	br	81105de4 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105db4:	e0bffe03 	ldbu	r2,-8(fp)
81105db8:	10bfffc4 	addi	r2,r2,-1
81105dbc:	108003cc 	andi	r2,r2,15
81105dc0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105dc4:	e1bffd17 	ldw	r6,-12(fp)
81105dc8:	01400504 	movi	r5,20
81105dcc:	01204834 	movhi	r4,33056
81105dd0:	210b0004 	addi	r4,r4,11264
81105dd4:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105dd8:	00000206 	br	81105de4 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ddc:	e03ffc15 	stw	zero,-16(fp)
			break;
81105de0:	0001883a 	nop
		}
	} else {
81105de4:	00000106 	br	81105dec <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105de8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105dec:	e0bffc17 	ldw	r2,-16(fp)
}
81105df0:	e037883a 	mov	sp,fp
81105df4:	dfc00117 	ldw	ra,4(sp)
81105df8:	df000017 	ldw	fp,0(sp)
81105dfc:	dec00204 	addi	sp,sp,8
81105e00:	f800283a 	ret

81105e04 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e04:	defffa04 	addi	sp,sp,-24
81105e08:	de00012e 	bgeu	sp,et,81105e10 <bFeebCh8SetBufferSize+0xc>
81105e0c:	003b68fa 	trap	3
81105e10:	dfc00515 	stw	ra,20(sp)
81105e14:	df000415 	stw	fp,16(sp)
81105e18:	df000404 	addi	fp,sp,16
81105e1c:	2007883a 	mov	r3,r4
81105e20:	2805883a 	mov	r2,r5
81105e24:	e0fffe05 	stb	r3,-8(fp)
81105e28:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105e2c:	00800044 	movi	r2,1
81105e30:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105e34:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105e38:	e0bffe03 	ldbu	r2,-8(fp)
81105e3c:	10001f26 	beq	r2,zero,81105ebc <bFeebCh8SetBufferSize+0xb8>
81105e40:	e0bffe03 	ldbu	r2,-8(fp)
81105e44:	10800468 	cmpgeui	r2,r2,17
81105e48:	10001c1e 	bne	r2,zero,81105ebc <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105e4c:	e0bfff03 	ldbu	r2,-4(fp)
81105e50:	10000326 	beq	r2,zero,81105e60 <bFeebCh8SetBufferSize+0x5c>
81105e54:	10800060 	cmpeqi	r2,r2,1
81105e58:	10000b1e 	bne	r2,zero,81105e88 <bFeebCh8SetBufferSize+0x84>
81105e5c:	00001406 	br	81105eb0 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e60:	e0bffe03 	ldbu	r2,-8(fp)
81105e64:	10bfffc4 	addi	r2,r2,-1
81105e68:	108003cc 	andi	r2,r2,15
81105e6c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105e70:	e1bffd17 	ldw	r6,-12(fp)
81105e74:	01400544 	movi	r5,21
81105e78:	01204834 	movhi	r4,33056
81105e7c:	210a0004 	addi	r4,r4,10240
81105e80:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e84:	00000c06 	br	81105eb8 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e88:	e0bffe03 	ldbu	r2,-8(fp)
81105e8c:	10bfffc4 	addi	r2,r2,-1
81105e90:	108003cc 	andi	r2,r2,15
81105e94:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105e98:	e1bffd17 	ldw	r6,-12(fp)
81105e9c:	01400504 	movi	r5,20
81105ea0:	01204834 	movhi	r4,33056
81105ea4:	210a0004 	addi	r4,r4,10240
81105ea8:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105eac:	00000206 	br	81105eb8 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105eb0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105eb4:	0001883a 	nop
		}
	} else {
81105eb8:	00000106 	br	81105ec0 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
81105ebc:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105ec0:	e0bffc17 	ldw	r2,-16(fp)
}
81105ec4:	e037883a 	mov	sp,fp
81105ec8:	dfc00117 	ldw	ra,4(sp)
81105ecc:	df000017 	ldw	fp,0(sp)
81105ed0:	dec00204 	addi	sp,sp,8
81105ed4:	f800283a 	ret

81105ed8 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81105ed8:	defffc04 	addi	sp,sp,-16
81105edc:	de00012e 	bgeu	sp,et,81105ee4 <vFeebInitIrq+0xc>
81105ee0:	003b68fa 	trap	3
81105ee4:	dfc00315 	stw	ra,12(sp)
81105ee8:	df000215 	stw	fp,8(sp)
81105eec:	df000204 	addi	fp,sp,8
81105ef0:	2005883a 	mov	r2,r4
81105ef4:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105ef8:	e0bfff03 	ldbu	r2,-4(fp)
81105efc:	10c00228 	cmpgeui	r3,r2,8
81105f00:	18004e1e 	bne	r3,zero,8110603c <vFeebInitIrq+0x164>
81105f04:	100690ba 	slli	r3,r2,2
81105f08:	00a04434 	movhi	r2,33040
81105f0c:	1097c704 	addi	r2,r2,24348
81105f10:	1885883a 	add	r2,r3,r2
81105f14:	10800017 	ldw	r2,0(r2)
81105f18:	1000683a 	jmp	r2
81105f1c:	81105f3c 	xorhi	r4,r16,16764
81105f20:	81105f5c 	xori	r4,r16,16765
81105f24:	81105f7c 	xorhi	r4,r16,16765
81105f28:	81105f9c 	xori	r4,r16,16766
81105f2c:	81105fbc 	xorhi	r4,r16,16766
81105f30:	81105fdc 	xori	r4,r16,16767
81105f34:	81105ffc 	xorhi	r4,r16,16767
81105f38:	8110601c 	xori	r4,r16,16768
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105f3c:	d0a04004 	addi	r2,gp,-32512
81105f40:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105f44:	01a04434 	movhi	r6,33040
81105f48:	31946604 	addi	r6,r6,20888
81105f4c:	e17ffe17 	ldw	r5,-8(fp)
81105f50:	01000584 	movi	r4,22
81105f54:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81105f58:	00003806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81105f5c:	d0a04104 	addi	r2,gp,-32508
81105f60:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81105f64:	01a04434 	movhi	r6,33040
81105f68:	31947404 	addi	r6,r6,20944
81105f6c:	e17ffe17 	ldw	r5,-8(fp)
81105f70:	01000504 	movi	r4,20
81105f74:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81105f78:	00003006 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81105f7c:	d0a04204 	addi	r2,gp,-32504
81105f80:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81105f84:	01a04434 	movhi	r6,33040
81105f88:	31948204 	addi	r6,r6,21000
81105f8c:	e17ffe17 	ldw	r5,-8(fp)
81105f90:	01000484 	movi	r4,18
81105f94:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105f98:	00002806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105f9c:	d0a04304 	addi	r2,gp,-32500
81105fa0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81105fa4:	01a04434 	movhi	r6,33040
81105fa8:	31949004 	addi	r6,r6,21056
81105fac:	e17ffe17 	ldw	r5,-8(fp)
81105fb0:	01000404 	movi	r4,16
81105fb4:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81105fb8:	00002006 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105fbc:	d0a04404 	addi	r2,gp,-32496
81105fc0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81105fc4:	01a04434 	movhi	r6,33040
81105fc8:	31949e04 	addi	r6,r6,21112
81105fcc:	e17ffe17 	ldw	r5,-8(fp)
81105fd0:	01000204 	movi	r4,8
81105fd4:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81105fd8:	00001806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105fdc:	d0a04504 	addi	r2,gp,-32492
81105fe0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81105fe4:	01a04434 	movhi	r6,33040
81105fe8:	3194ac04 	addi	r6,r6,21168
81105fec:	e17ffe17 	ldw	r5,-8(fp)
81105ff0:	01000184 	movi	r4,6
81105ff4:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81105ff8:	00001006 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105ffc:	d0a04604 	addi	r2,gp,-32488
81106000:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106004:	01a04434 	movhi	r6,33040
81106008:	3194ba04 	addi	r6,r6,21224
8110600c:	e17ffe17 	ldw	r5,-8(fp)
81106010:	01000144 	movi	r4,5
81106014:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81106018:	00000806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110601c:	d0a04704 	addi	r2,gp,-32484
81106020:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106024:	01a04434 	movhi	r6,33040
81106028:	3194c804 	addi	r6,r6,21280
8110602c:	e17ffe17 	ldw	r5,-8(fp)
81106030:	01000084 	movi	r4,2
81106034:	11379600 	call	81137960 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81106038:	0001883a 	nop
	}
}
8110603c:	0001883a 	nop
81106040:	e037883a 	mov	sp,fp
81106044:	dfc00117 	ldw	ra,4(sp)
81106048:	df000017 	ldw	fp,0(sp)
8110604c:	dec00204 	addi	sp,sp,8
81106050:	f800283a 	ret

81106054 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81106054:	defffb04 	addi	sp,sp,-20
81106058:	de00012e 	bgeu	sp,et,81106060 <bFeebSetIrqControl+0xc>
8110605c:	003b68fa 	trap	3
81106060:	dfc00415 	stw	ra,16(sp)
81106064:	df000315 	stw	fp,12(sp)
81106068:	df000304 	addi	fp,sp,12
8110606c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106070:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106074:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106078:	e0bfff17 	ldw	r2,-4(fp)
8110607c:	10002426 	beq	r2,zero,81106110 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106080:	e0bfff17 	ldw	r2,-4(fp)
81106084:	10800017 	ldw	r2,0(r2)
81106088:	01400444 	movi	r5,17
8110608c:	1009883a 	mov	r4,r2
81106090:	1106b780 	call	81106b78 <uliFeebReadReg>
81106094:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81106098:	e0bfff17 	ldw	r2,-4(fp)
8110609c:	10800217 	ldw	r2,8(r2)
811060a0:	10000426 	beq	r2,zero,811060b4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811060a4:	e0bffe17 	ldw	r2,-8(fp)
811060a8:	10808014 	ori	r2,r2,512
811060ac:	e0bffe15 	stw	r2,-8(fp)
811060b0:	00000406 	br	811060c4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
811060b4:	e0fffe17 	ldw	r3,-8(fp)
811060b8:	00bf7fc4 	movi	r2,-513
811060bc:	1884703a 	and	r2,r3,r2
811060c0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
811060c4:	e0bfff17 	ldw	r2,-4(fp)
811060c8:	10800317 	ldw	r2,12(r2)
811060cc:	10000426 	beq	r2,zero,811060e0 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
811060d0:	e0bffe17 	ldw	r2,-8(fp)
811060d4:	10804014 	ori	r2,r2,256
811060d8:	e0bffe15 	stw	r2,-8(fp)
811060dc:	00000406 	br	811060f0 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
811060e0:	e0fffe17 	ldw	r3,-8(fp)
811060e4:	00bfbfc4 	movi	r2,-257
811060e8:	1884703a 	and	r2,r3,r2
811060ec:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
811060f0:	e0bfff17 	ldw	r2,-4(fp)
811060f4:	10800017 	ldw	r2,0(r2)
811060f8:	e1bffe17 	ldw	r6,-8(fp)
811060fc:	01400444 	movi	r5,17
81106100:	1009883a 	mov	r4,r2
81106104:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106108:	00800044 	movi	r2,1
8110610c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106110:	e0bffd17 	ldw	r2,-12(fp)
}
81106114:	e037883a 	mov	sp,fp
81106118:	dfc00117 	ldw	ra,4(sp)
8110611c:	df000017 	ldw	fp,0(sp)
81106120:	dec00204 	addi	sp,sp,8
81106124:	f800283a 	ret

81106128 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106128:	defffb04 	addi	sp,sp,-20
8110612c:	de00012e 	bgeu	sp,et,81106134 <bFeebGetIrqControl+0xc>
81106130:	003b68fa 	trap	3
81106134:	dfc00415 	stw	ra,16(sp)
81106138:	df000315 	stw	fp,12(sp)
8110613c:	df000304 	addi	fp,sp,12
81106140:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106144:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106148:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110614c:	e0bfff17 	ldw	r2,-4(fp)
81106150:	10001a26 	beq	r2,zero,811061bc <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106154:	e0bfff17 	ldw	r2,-4(fp)
81106158:	10800017 	ldw	r2,0(r2)
8110615c:	01400444 	movi	r5,17
81106160:	1009883a 	mov	r4,r2
81106164:	1106b780 	call	81106b78 <uliFeebReadReg>
81106168:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
8110616c:	e0bffe17 	ldw	r2,-8(fp)
81106170:	1080800c 	andi	r2,r2,512
81106174:	10000426 	beq	r2,zero,81106188 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81106178:	e0bfff17 	ldw	r2,-4(fp)
8110617c:	00c00044 	movi	r3,1
81106180:	10c00215 	stw	r3,8(r2)
81106184:	00000206 	br	81106190 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81106188:	e0bfff17 	ldw	r2,-4(fp)
8110618c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81106190:	e0bffe17 	ldw	r2,-8(fp)
81106194:	1080400c 	andi	r2,r2,256
81106198:	10000426 	beq	r2,zero,811061ac <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110619c:	e0bfff17 	ldw	r2,-4(fp)
811061a0:	00c00044 	movi	r3,1
811061a4:	10c00315 	stw	r3,12(r2)
811061a8:	00000206 	br	811061b4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811061ac:	e0bfff17 	ldw	r2,-4(fp)
811061b0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
811061b4:	00800044 	movi	r2,1
811061b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811061bc:	e0bffd17 	ldw	r2,-12(fp)
}
811061c0:	e037883a 	mov	sp,fp
811061c4:	dfc00117 	ldw	ra,4(sp)
811061c8:	df000017 	ldw	fp,0(sp)
811061cc:	dec00204 	addi	sp,sp,8
811061d0:	f800283a 	ret

811061d4 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
811061d4:	defffb04 	addi	sp,sp,-20
811061d8:	de00012e 	bgeu	sp,et,811061e0 <bFeebGetIrqFlags+0xc>
811061dc:	003b68fa 	trap	3
811061e0:	dfc00415 	stw	ra,16(sp)
811061e4:	df000315 	stw	fp,12(sp)
811061e8:	df000304 	addi	fp,sp,12
811061ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811061f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811061f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811061f8:	e0bfff17 	ldw	r2,-4(fp)
811061fc:	10001126 	beq	r2,zero,81106244 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106200:	e0bfff17 	ldw	r2,-4(fp)
81106204:	10800017 	ldw	r2,0(r2)
81106208:	01400484 	movi	r5,18
8110620c:	1009883a 	mov	r4,r2
81106210:	1106b780 	call	81106b78 <uliFeebReadReg>
81106214:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81106218:	e0bffe17 	ldw	r2,-8(fp)
8110621c:	1080400c 	andi	r2,r2,256
81106220:	10000426 	beq	r2,zero,81106234 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106224:	e0bfff17 	ldw	r2,-4(fp)
81106228:	00c00044 	movi	r3,1
8110622c:	10c00415 	stw	r3,16(r2)
81106230:	00000206 	br	8110623c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81106234:	e0bfff17 	ldw	r2,-4(fp)
81106238:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
8110623c:	00800044 	movi	r2,1
81106240:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106244:	e0bffd17 	ldw	r2,-12(fp)
}
81106248:	e037883a 	mov	sp,fp
8110624c:	dfc00117 	ldw	ra,4(sp)
81106250:	df000017 	ldw	fp,0(sp)
81106254:	dec00204 	addi	sp,sp,8
81106258:	f800283a 	ret

8110625c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110625c:	defffb04 	addi	sp,sp,-20
81106260:	de00012e 	bgeu	sp,et,81106268 <bFeebGetBuffersStatus+0xc>
81106264:	003b68fa 	trap	3
81106268:	dfc00415 	stw	ra,16(sp)
8110626c:	df000315 	stw	fp,12(sp)
81106270:	df000304 	addi	fp,sp,12
81106274:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106278:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110627c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106280:	e0bfff17 	ldw	r2,-4(fp)
81106284:	10003226 	beq	r2,zero,81106350 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106288:	e0bfff17 	ldw	r2,-4(fp)
8110628c:	10800017 	ldw	r2,0(r2)
81106290:	014000c4 	movi	r5,3
81106294:	1009883a 	mov	r4,r2
81106298:	1106b780 	call	81106b78 <uliFeebReadReg>
8110629c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811062a0:	e0bffe17 	ldw	r2,-8(fp)
811062a4:	1080008c 	andi	r2,r2,2
811062a8:	10000426 	beq	r2,zero,811062bc <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811062ac:	e0bfff17 	ldw	r2,-4(fp)
811062b0:	00c00044 	movi	r3,1
811062b4:	10c00515 	stw	r3,20(r2)
811062b8:	00000206 	br	811062c4 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811062bc:	e0bfff17 	ldw	r2,-4(fp)
811062c0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811062c4:	e0bffe17 	ldw	r2,-8(fp)
811062c8:	1080004c 	andi	r2,r2,1
811062cc:	10000426 	beq	r2,zero,811062e0 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811062d0:	e0bfff17 	ldw	r2,-4(fp)
811062d4:	00c00044 	movi	r3,1
811062d8:	10c00615 	stw	r3,24(r2)
811062dc:	00000206 	br	811062e8 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811062e0:	e0bfff17 	ldw	r2,-4(fp)
811062e4:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062e8:	e0bfff17 	ldw	r2,-4(fp)
811062ec:	10800017 	ldw	r2,0(r2)
811062f0:	01400504 	movi	r5,20
811062f4:	1009883a 	mov	r4,r2
811062f8:	1106b780 	call	81106b78 <uliFeebReadReg>
811062fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106300:	e0bffe17 	ldw	r2,-8(fp)
81106304:	108003cc 	andi	r2,r2,15
81106308:	10800044 	addi	r2,r2,1
8110630c:	1007883a 	mov	r3,r2
81106310:	e0bfff17 	ldw	r2,-4(fp)
81106314:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	10800017 	ldw	r2,0(r2)
81106320:	01400544 	movi	r5,21
81106324:	1009883a 	mov	r4,r2
81106328:	1106b780 	call	81106b78 <uliFeebReadReg>
8110632c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106330:	e0bffe17 	ldw	r2,-8(fp)
81106334:	108003cc 	andi	r2,r2,15
81106338:	10800044 	addi	r2,r2,1
8110633c:	1007883a 	mov	r3,r2
81106340:	e0bfff17 	ldw	r2,-4(fp)
81106344:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81106348:	00800044 	movi	r2,1
8110634c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106350:	e0bffd17 	ldw	r2,-12(fp)
}
81106354:	e037883a 	mov	sp,fp
81106358:	dfc00117 	ldw	ra,4(sp)
8110635c:	df000017 	ldw	fp,0(sp)
81106360:	dec00204 	addi	sp,sp,8
81106364:	f800283a 	ret

81106368 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
81106368:	defffb04 	addi	sp,sp,-20
8110636c:	de00012e 	bgeu	sp,et,81106374 <bFeebGetLeftBufferEmpty+0xc>
81106370:	003b68fa 	trap	3
81106374:	dfc00415 	stw	ra,16(sp)
81106378:	df000315 	stw	fp,12(sp)
8110637c:	df000304 	addi	fp,sp,12
81106380:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106384:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106388:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110638c:	e0bfff17 	ldw	r2,-4(fp)
81106390:	10000d26 	beq	r2,zero,811063c8 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106394:	e0bfff17 	ldw	r2,-4(fp)
81106398:	10800017 	ldw	r2,0(r2)
8110639c:	014000c4 	movi	r5,3
811063a0:	1009883a 	mov	r4,r2
811063a4:	1106b780 	call	81106b78 <uliFeebReadReg>
811063a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811063ac:	e0bffe17 	ldw	r2,-8(fp)
811063b0:	1080008c 	andi	r2,r2,2
811063b4:	10000326 	beq	r2,zero,811063c4 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
811063b8:	00800044 	movi	r2,1
811063bc:	e0bffd15 	stw	r2,-12(fp)
811063c0:	00000106 	br	811063c8 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
811063c4:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
811063c8:	e0bffd17 	ldw	r2,-12(fp)
}
811063cc:	e037883a 	mov	sp,fp
811063d0:	dfc00117 	ldw	ra,4(sp)
811063d4:	df000017 	ldw	fp,0(sp)
811063d8:	dec00204 	addi	sp,sp,8
811063dc:	f800283a 	ret

811063e0 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
811063e0:	defffb04 	addi	sp,sp,-20
811063e4:	de00012e 	bgeu	sp,et,811063ec <bFeebGetRightBufferEmpty+0xc>
811063e8:	003b68fa 	trap	3
811063ec:	dfc00415 	stw	ra,16(sp)
811063f0:	df000315 	stw	fp,12(sp)
811063f4:	df000304 	addi	fp,sp,12
811063f8:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811063fc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106400:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106404:	e0bfff17 	ldw	r2,-4(fp)
81106408:	10000d26 	beq	r2,zero,81106440 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110640c:	e0bfff17 	ldw	r2,-4(fp)
81106410:	10800017 	ldw	r2,0(r2)
81106414:	014000c4 	movi	r5,3
81106418:	1009883a 	mov	r4,r2
8110641c:	1106b780 	call	81106b78 <uliFeebReadReg>
81106420:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106424:	e0bffe17 	ldw	r2,-8(fp)
81106428:	1080004c 	andi	r2,r2,1
8110642c:	10000326 	beq	r2,zero,8110643c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106430:	00800044 	movi	r2,1
81106434:	e0bffd15 	stw	r2,-12(fp)
81106438:	00000106 	br	81106440 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
8110643c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106440:	e0bffd17 	ldw	r2,-12(fp)
}
81106444:	e037883a 	mov	sp,fp
81106448:	dfc00117 	ldw	ra,4(sp)
8110644c:	df000017 	ldw	fp,0(sp)
81106450:	dec00204 	addi	sp,sp,8
81106454:	f800283a 	ret

81106458 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81106458:	defffc04 	addi	sp,sp,-16
8110645c:	de00012e 	bgeu	sp,et,81106464 <bFeebGetCh1LeftBufferEmpty+0xc>
81106460:	003b68fa 	trap	3
81106464:	dfc00315 	stw	ra,12(sp)
81106468:	df000215 	stw	fp,8(sp)
8110646c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106470:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106474:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106478:	014000c4 	movi	r5,3
8110647c:	01204834 	movhi	r4,33056
81106480:	210b0004 	addi	r4,r4,11264
81106484:	1106b780 	call	81106b78 <uliFeebReadReg>
81106488:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110648c:	e0bfff17 	ldw	r2,-4(fp)
81106490:	1080008c 	andi	r2,r2,2
81106494:	10000326 	beq	r2,zero,811064a4 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106498:	00800044 	movi	r2,1
8110649c:	e0bffe15 	stw	r2,-8(fp)
811064a0:	00000106 	br	811064a8 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811064a4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811064a8:	e0bffe17 	ldw	r2,-8(fp)
}
811064ac:	e037883a 	mov	sp,fp
811064b0:	dfc00117 	ldw	ra,4(sp)
811064b4:	df000017 	ldw	fp,0(sp)
811064b8:	dec00204 	addi	sp,sp,8
811064bc:	f800283a 	ret

811064c0 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
811064c0:	defffc04 	addi	sp,sp,-16
811064c4:	de00012e 	bgeu	sp,et,811064cc <bFeebGetCh1RightBufferEmpty+0xc>
811064c8:	003b68fa 	trap	3
811064cc:	dfc00315 	stw	ra,12(sp)
811064d0:	df000215 	stw	fp,8(sp)
811064d4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811064d8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811064dc:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811064e0:	014000c4 	movi	r5,3
811064e4:	01204834 	movhi	r4,33056
811064e8:	210b0004 	addi	r4,r4,11264
811064ec:	1106b780 	call	81106b78 <uliFeebReadReg>
811064f0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811064f4:	e0bfff17 	ldw	r2,-4(fp)
811064f8:	1080004c 	andi	r2,r2,1
811064fc:	10000326 	beq	r2,zero,8110650c <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106500:	00800044 	movi	r2,1
81106504:	e0bffe15 	stw	r2,-8(fp)
81106508:	00000106 	br	81106510 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110650c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106510:	e0bffe17 	ldw	r2,-8(fp)
}
81106514:	e037883a 	mov	sp,fp
81106518:	dfc00117 	ldw	ra,4(sp)
8110651c:	df000017 	ldw	fp,0(sp)
81106520:	dec00204 	addi	sp,sp,8
81106524:	f800283a 	ret

81106528 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81106528:	defffc04 	addi	sp,sp,-16
8110652c:	de00012e 	bgeu	sp,et,81106534 <bFeebGetCh2LeftBufferEmpty+0xc>
81106530:	003b68fa 	trap	3
81106534:	dfc00315 	stw	ra,12(sp)
81106538:	df000215 	stw	fp,8(sp)
8110653c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106540:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106544:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106548:	014000c4 	movi	r5,3
8110654c:	01204834 	movhi	r4,33056
81106550:	210a0004 	addi	r4,r4,10240
81106554:	1106b780 	call	81106b78 <uliFeebReadReg>
81106558:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110655c:	e0bfff17 	ldw	r2,-4(fp)
81106560:	1080008c 	andi	r2,r2,2
81106564:	10000326 	beq	r2,zero,81106574 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106568:	00800044 	movi	r2,1
8110656c:	e0bffe15 	stw	r2,-8(fp)
81106570:	00000106 	br	81106578 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106574:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106578:	e0bffe17 	ldw	r2,-8(fp)
}
8110657c:	e037883a 	mov	sp,fp
81106580:	dfc00117 	ldw	ra,4(sp)
81106584:	df000017 	ldw	fp,0(sp)
81106588:	dec00204 	addi	sp,sp,8
8110658c:	f800283a 	ret

81106590 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
81106590:	defffc04 	addi	sp,sp,-16
81106594:	de00012e 	bgeu	sp,et,8110659c <bFeebGetCh2RightBufferEmpty+0xc>
81106598:	003b68fa 	trap	3
8110659c:	dfc00315 	stw	ra,12(sp)
811065a0:	df000215 	stw	fp,8(sp)
811065a4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811065a8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811065ac:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811065b0:	014000c4 	movi	r5,3
811065b4:	01204834 	movhi	r4,33056
811065b8:	210a0004 	addi	r4,r4,10240
811065bc:	1106b780 	call	81106b78 <uliFeebReadReg>
811065c0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811065c4:	e0bfff17 	ldw	r2,-4(fp)
811065c8:	1080004c 	andi	r2,r2,1
811065cc:	10000326 	beq	r2,zero,811065dc <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
811065d0:	00800044 	movi	r2,1
811065d4:	e0bffe15 	stw	r2,-8(fp)
811065d8:	00000106 	br	811065e0 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811065dc:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811065e0:	e0bffe17 	ldw	r2,-8(fp)
}
811065e4:	e037883a 	mov	sp,fp
811065e8:	dfc00117 	ldw	ra,4(sp)
811065ec:	df000017 	ldw	fp,0(sp)
811065f0:	dec00204 	addi	sp,sp,8
811065f4:	f800283a 	ret

811065f8 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
811065f8:	defff904 	addi	sp,sp,-28
811065fc:	de00012e 	bgeu	sp,et,81106604 <bFeebSetBufferSize+0xc>
81106600:	003b68fa 	trap	3
81106604:	dfc00615 	stw	ra,24(sp)
81106608:	df000515 	stw	fp,20(sp)
8110660c:	df000504 	addi	fp,sp,20
81106610:	e13ffd15 	stw	r4,-12(fp)
81106614:	2807883a 	mov	r3,r5
81106618:	3005883a 	mov	r2,r6
8110661c:	e0fffe05 	stb	r3,-8(fp)
81106620:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106624:	00800044 	movi	r2,1
81106628:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110662c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106630:	e0bffe03 	ldbu	r2,-8(fp)
81106634:	10002126 	beq	r2,zero,811066bc <bFeebSetBufferSize+0xc4>
81106638:	e0bffe03 	ldbu	r2,-8(fp)
8110663c:	10800468 	cmpgeui	r2,r2,17
81106640:	10001e1e 	bne	r2,zero,811066bc <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
81106644:	e0bfff03 	ldbu	r2,-4(fp)
81106648:	10000326 	beq	r2,zero,81106658 <bFeebSetBufferSize+0x60>
8110664c:	10800060 	cmpeqi	r2,r2,1
81106650:	10000c1e 	bne	r2,zero,81106684 <bFeebSetBufferSize+0x8c>
81106654:	00001606 	br	811066b0 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106658:	e0bffe03 	ldbu	r2,-8(fp)
8110665c:	10bfffc4 	addi	r2,r2,-1
81106660:	108003cc 	andi	r2,r2,15
81106664:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106668:	e0bffd17 	ldw	r2,-12(fp)
8110666c:	10800017 	ldw	r2,0(r2)
81106670:	e1bffc17 	ldw	r6,-16(fp)
81106674:	01400544 	movi	r5,21
81106678:	1009883a 	mov	r4,r2
8110667c:	1106b240 	call	81106b24 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106680:	00000d06 	br	811066b8 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106684:	e0bffe03 	ldbu	r2,-8(fp)
81106688:	10bfffc4 	addi	r2,r2,-1
8110668c:	108003cc 	andi	r2,r2,15
81106690:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106694:	e0bffd17 	ldw	r2,-12(fp)
81106698:	10800017 	ldw	r2,0(r2)
8110669c:	e1bffc17 	ldw	r6,-16(fp)
811066a0:	01400504 	movi	r5,20
811066a4:	1009883a 	mov	r4,r2
811066a8:	1106b240 	call	81106b24 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811066ac:	00000206 	br	811066b8 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
811066b0:	e03ffb15 	stw	zero,-20(fp)
			break;
811066b4:	0001883a 	nop
		}
	} else {
811066b8:	00000106 	br	811066c0 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
811066bc:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
811066c0:	e0bffb17 	ldw	r2,-20(fp)
}
811066c4:	e037883a 	mov	sp,fp
811066c8:	dfc00117 	ldw	ra,4(sp)
811066cc:	df000017 	ldw	fp,0(sp)
811066d0:	dec00204 	addi	sp,sp,8
811066d4:	f800283a 	ret

811066d8 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
811066d8:	defffb04 	addi	sp,sp,-20
811066dc:	de00012e 	bgeu	sp,et,811066e4 <bFeebSetWindowing+0xc>
811066e0:	003b68fa 	trap	3
811066e4:	dfc00415 	stw	ra,16(sp)
811066e8:	df000315 	stw	fp,12(sp)
811066ec:	df000304 	addi	fp,sp,12
811066f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811066f4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811066f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811066fc:	e0bfff17 	ldw	r2,-4(fp)
81106700:	10001926 	beq	r2,zero,81106768 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106704:	e0bfff17 	ldw	r2,-4(fp)
81106708:	10800017 	ldw	r2,0(r2)
8110670c:	01400084 	movi	r5,2
81106710:	1009883a 	mov	r4,r2
81106714:	1106b780 	call	81106b78 <uliFeebReadReg>
81106718:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
8110671c:	e0bfff17 	ldw	r2,-4(fp)
81106720:	10800117 	ldw	r2,4(r2)
81106724:	10000426 	beq	r2,zero,81106738 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106728:	e0bffe17 	ldw	r2,-8(fp)
8110672c:	10800214 	ori	r2,r2,8
81106730:	e0bffe15 	stw	r2,-8(fp)
81106734:	00000406 	br	81106748 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81106738:	e0fffe17 	ldw	r3,-8(fp)
8110673c:	00bffdc4 	movi	r2,-9
81106740:	1884703a 	and	r2,r3,r2
81106744:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106748:	e0bfff17 	ldw	r2,-4(fp)
8110674c:	10800017 	ldw	r2,0(r2)
81106750:	e1bffe17 	ldw	r6,-8(fp)
81106754:	01400084 	movi	r5,2
81106758:	1009883a 	mov	r4,r2
8110675c:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106760:	00800044 	movi	r2,1
81106764:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106768:	e0bffd17 	ldw	r2,-12(fp)
}
8110676c:	e037883a 	mov	sp,fp
81106770:	dfc00117 	ldw	ra,4(sp)
81106774:	df000017 	ldw	fp,0(sp)
81106778:	dec00204 	addi	sp,sp,8
8110677c:	f800283a 	ret

81106780 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81106780:	defffb04 	addi	sp,sp,-20
81106784:	de00012e 	bgeu	sp,et,8110678c <bFeebGetWindowing+0xc>
81106788:	003b68fa 	trap	3
8110678c:	dfc00415 	stw	ra,16(sp)
81106790:	df000315 	stw	fp,12(sp)
81106794:	df000304 	addi	fp,sp,12
81106798:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110679c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811067a0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811067a4:	e0bfff17 	ldw	r2,-4(fp)
811067a8:	10001126 	beq	r2,zero,811067f0 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811067ac:	e0bfff17 	ldw	r2,-4(fp)
811067b0:	10800017 	ldw	r2,0(r2)
811067b4:	01400084 	movi	r5,2
811067b8:	1009883a 	mov	r4,r2
811067bc:	1106b780 	call	81106b78 <uliFeebReadReg>
811067c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
811067c4:	e0bffe17 	ldw	r2,-8(fp)
811067c8:	1080020c 	andi	r2,r2,8
811067cc:	10000426 	beq	r2,zero,811067e0 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
811067d0:	e0bfff17 	ldw	r2,-4(fp)
811067d4:	00c00044 	movi	r3,1
811067d8:	10c00115 	stw	r3,4(r2)
811067dc:	00000206 	br	811067e8 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
811067e0:	e0bfff17 	ldw	r2,-4(fp)
811067e4:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
811067e8:	00800044 	movi	r2,1
811067ec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811067f0:	e0bffd17 	ldw	r2,-12(fp)
}
811067f4:	e037883a 	mov	sp,fp
811067f8:	dfc00117 	ldw	ra,4(sp)
811067fc:	df000017 	ldw	fp,0(sp)
81106800:	dec00204 	addi	sp,sp,8
81106804:	f800283a 	ret

81106808 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106808:	defffb04 	addi	sp,sp,-20
8110680c:	de00012e 	bgeu	sp,et,81106814 <bFeebStartCh+0xc>
81106810:	003b68fa 	trap	3
81106814:	dfc00415 	stw	ra,16(sp)
81106818:	df000315 	stw	fp,12(sp)
8110681c:	df000304 	addi	fp,sp,12
81106820:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106824:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106828:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110682c:	e0bfff17 	ldw	r2,-4(fp)
81106830:	10001126 	beq	r2,zero,81106878 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106834:	e0bfff17 	ldw	r2,-4(fp)
81106838:	10800017 	ldw	r2,0(r2)
8110683c:	01400084 	movi	r5,2
81106840:	1009883a 	mov	r4,r2
81106844:	1106b780 	call	81106b78 <uliFeebReadReg>
81106848:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
8110684c:	e0bffe17 	ldw	r2,-8(fp)
81106850:	10800114 	ori	r2,r2,4
81106854:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106858:	e0bfff17 	ldw	r2,-4(fp)
8110685c:	10800017 	ldw	r2,0(r2)
81106860:	e1bffe17 	ldw	r6,-8(fp)
81106864:	01400084 	movi	r5,2
81106868:	1009883a 	mov	r4,r2
8110686c:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106870:	00800044 	movi	r2,1
81106874:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106878:	e0bffd17 	ldw	r2,-12(fp)
}
8110687c:	e037883a 	mov	sp,fp
81106880:	dfc00117 	ldw	ra,4(sp)
81106884:	df000017 	ldw	fp,0(sp)
81106888:	dec00204 	addi	sp,sp,8
8110688c:	f800283a 	ret

81106890 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81106890:	defffb04 	addi	sp,sp,-20
81106894:	de00012e 	bgeu	sp,et,8110689c <bFeebStopCh+0xc>
81106898:	003b68fa 	trap	3
8110689c:	dfc00415 	stw	ra,16(sp)
811068a0:	df000315 	stw	fp,12(sp)
811068a4:	df000304 	addi	fp,sp,12
811068a8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811068ac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811068b0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811068b4:	e0bfff17 	ldw	r2,-4(fp)
811068b8:	10001126 	beq	r2,zero,81106900 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811068bc:	e0bfff17 	ldw	r2,-4(fp)
811068c0:	10800017 	ldw	r2,0(r2)
811068c4:	01400084 	movi	r5,2
811068c8:	1009883a 	mov	r4,r2
811068cc:	1106b780 	call	81106b78 <uliFeebReadReg>
811068d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
811068d4:	e0bffe17 	ldw	r2,-8(fp)
811068d8:	10800094 	ori	r2,r2,2
811068dc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811068e0:	e0bfff17 	ldw	r2,-4(fp)
811068e4:	10800017 	ldw	r2,0(r2)
811068e8:	e1bffe17 	ldw	r6,-8(fp)
811068ec:	01400084 	movi	r5,2
811068f0:	1009883a 	mov	r4,r2
811068f4:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811068f8:	00800044 	movi	r2,1
811068fc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106900:	e0bffd17 	ldw	r2,-12(fp)
}
81106904:	e037883a 	mov	sp,fp
81106908:	dfc00117 	ldw	ra,4(sp)
8110690c:	df000017 	ldw	fp,0(sp)
81106910:	dec00204 	addi	sp,sp,8
81106914:	f800283a 	ret

81106918 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106918:	defffb04 	addi	sp,sp,-20
8110691c:	de00012e 	bgeu	sp,et,81106924 <bFeebClrCh+0xc>
81106920:	003b68fa 	trap	3
81106924:	dfc00415 	stw	ra,16(sp)
81106928:	df000315 	stw	fp,12(sp)
8110692c:	df000304 	addi	fp,sp,12
81106930:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106934:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106938:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110693c:	e0bfff17 	ldw	r2,-4(fp)
81106940:	10001126 	beq	r2,zero,81106988 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106944:	e0bfff17 	ldw	r2,-4(fp)
81106948:	10800017 	ldw	r2,0(r2)
8110694c:	01400084 	movi	r5,2
81106950:	1009883a 	mov	r4,r2
81106954:	1106b780 	call	81106b78 <uliFeebReadReg>
81106958:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
8110695c:	e0bffe17 	ldw	r2,-8(fp)
81106960:	10800054 	ori	r2,r2,1
81106964:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106968:	e0bfff17 	ldw	r2,-4(fp)
8110696c:	10800017 	ldw	r2,0(r2)
81106970:	e1bffe17 	ldw	r6,-8(fp)
81106974:	01400084 	movi	r5,2
81106978:	1009883a 	mov	r4,r2
8110697c:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106980:	00800044 	movi	r2,1
81106984:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106988:	e0bffd17 	ldw	r2,-12(fp)
}
8110698c:	e037883a 	mov	sp,fp
81106990:	dfc00117 	ldw	ra,4(sp)
81106994:	df000017 	ldw	fp,0(sp)
81106998:	dec00204 	addi	sp,sp,8
8110699c:	f800283a 	ret

811069a0 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
811069a0:	defffb04 	addi	sp,sp,-20
811069a4:	de00012e 	bgeu	sp,et,811069ac <bFeebInitCh+0xc>
811069a8:	003b68fa 	trap	3
811069ac:	dfc00415 	stw	ra,16(sp)
811069b0:	df000315 	stw	fp,12(sp)
811069b4:	df000304 	addi	fp,sp,12
811069b8:	e13ffe15 	stw	r4,-8(fp)
811069bc:	2805883a 	mov	r2,r5
811069c0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811069c4:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
811069c8:	e0bffe17 	ldw	r2,-8(fp)
811069cc:	10004f26 	beq	r2,zero,81106b0c <bFeebInitCh+0x16c>
		bStatus = TRUE;
811069d0:	00800044 	movi	r2,1
811069d4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811069d8:	e0bfff03 	ldbu	r2,-4(fp)
811069dc:	10c00228 	cmpgeui	r3,r2,8
811069e0:	1800361e 	bne	r3,zero,81106abc <bFeebInitCh+0x11c>
811069e4:	100690ba 	slli	r3,r2,2
811069e8:	00a04434 	movhi	r2,33040
811069ec:	109a7f04 	addi	r2,r2,27132
811069f0:	1885883a 	add	r2,r3,r2
811069f4:	10800017 	ldw	r2,0(r2)
811069f8:	1000683a 	jmp	r2
811069fc:	81106a1c 	xori	r4,r16,16808
81106a00:	81106a30 	cmpltui	r4,r16,16808
81106a04:	81106a44 	addi	r4,r16,16809
81106a08:	81106a58 	cmpnei	r4,r16,16809
81106a0c:	81106a6c 	andhi	r4,r16,16809
81106a10:	81106a80 	call	881106a8 <__reset+0x20f06a8>
81106a14:	81106a94 	ori	r4,r16,16810
81106a18:	81106aa8 	cmpgeui	r4,r16,16810
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106a1c:	e0fffe17 	ldw	r3,-8(fp)
81106a20:	00a04834 	movhi	r2,33056
81106a24:	108b0004 	addi	r2,r2,11264
81106a28:	18800015 	stw	r2,0(r3)
			break;
81106a2c:	00002506 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106a30:	e0fffe17 	ldw	r3,-8(fp)
81106a34:	00a04834 	movhi	r2,33056
81106a38:	108a0004 	addi	r2,r2,10240
81106a3c:	18800015 	stw	r2,0(r3)
			break;
81106a40:	00002006 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106a44:	e0fffe17 	ldw	r3,-8(fp)
81106a48:	00a04834 	movhi	r2,33056
81106a4c:	108b0004 	addi	r2,r2,11264
81106a50:	18800015 	stw	r2,0(r3)
			break;
81106a54:	00001b06 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106a58:	e0fffe17 	ldw	r3,-8(fp)
81106a5c:	00a04834 	movhi	r2,33056
81106a60:	108a0004 	addi	r2,r2,10240
81106a64:	18800015 	stw	r2,0(r3)
			break;
81106a68:	00001606 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106a6c:	e0fffe17 	ldw	r3,-8(fp)
81106a70:	00a04834 	movhi	r2,33056
81106a74:	108b0004 	addi	r2,r2,11264
81106a78:	18800015 	stw	r2,0(r3)
			break;
81106a7c:	00001106 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106a80:	e0fffe17 	ldw	r3,-8(fp)
81106a84:	00a04834 	movhi	r2,33056
81106a88:	108a0004 	addi	r2,r2,10240
81106a8c:	18800015 	stw	r2,0(r3)
			break;
81106a90:	00000c06 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106a94:	e0fffe17 	ldw	r3,-8(fp)
81106a98:	00a04834 	movhi	r2,33056
81106a9c:	108b0004 	addi	r2,r2,11264
81106aa0:	18800015 	stw	r2,0(r3)
			break;
81106aa4:	00000706 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106aa8:	e0fffe17 	ldw	r3,-8(fp)
81106aac:	00a04834 	movhi	r2,33056
81106ab0:	108a0004 	addi	r2,r2,10240
81106ab4:	18800015 	stw	r2,0(r3)
			break;
81106ab8:	00000206 	br	81106ac4 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106abc:	e03ffd15 	stw	zero,-12(fp)
			break;
81106ac0:	0001883a 	nop
		}

		if (bStatus) {
81106ac4:	e0bffd17 	ldw	r2,-12(fp)
81106ac8:	10001026 	beq	r2,zero,81106b0c <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106acc:	e13ffe17 	ldw	r4,-8(fp)
81106ad0:	11061280 	call	81106128 <bFeebGetIrqControl>
81106ad4:	1000011e 	bne	r2,zero,81106adc <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106ad8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106adc:	e13ffe17 	ldw	r4,-8(fp)
81106ae0:	11061d40 	call	811061d4 <bFeebGetIrqFlags>
81106ae4:	1000011e 	bne	r2,zero,81106aec <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106ae8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106aec:	e13ffe17 	ldw	r4,-8(fp)
81106af0:	110625c0 	call	8110625c <bFeebGetBuffersStatus>
81106af4:	1000011e 	bne	r2,zero,81106afc <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106af8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106afc:	e13ffe17 	ldw	r4,-8(fp)
81106b00:	11067800 	call	81106780 <bFeebGetWindowing>
81106b04:	1000011e 	bne	r2,zero,81106b0c <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106b08:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106b0c:	e0bffd17 	ldw	r2,-12(fp)
}
81106b10:	e037883a 	mov	sp,fp
81106b14:	dfc00117 	ldw	ra,4(sp)
81106b18:	df000017 	ldw	fp,0(sp)
81106b1c:	dec00204 	addi	sp,sp,8
81106b20:	f800283a 	ret

81106b24 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106b24:	defffc04 	addi	sp,sp,-16
81106b28:	de00012e 	bgeu	sp,et,81106b30 <vFeebWriteReg+0xc>
81106b2c:	003b68fa 	trap	3
81106b30:	df000315 	stw	fp,12(sp)
81106b34:	df000304 	addi	fp,sp,12
81106b38:	e13ffd15 	stw	r4,-12(fp)
81106b3c:	e17ffe15 	stw	r5,-8(fp)
81106b40:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106b44:	e0bffe17 	ldw	r2,-8(fp)
81106b48:	1085883a 	add	r2,r2,r2
81106b4c:	1085883a 	add	r2,r2,r2
81106b50:	1007883a 	mov	r3,r2
81106b54:	e0bffd17 	ldw	r2,-12(fp)
81106b58:	10c5883a 	add	r2,r2,r3
81106b5c:	e0ffff17 	ldw	r3,-4(fp)
81106b60:	10c00015 	stw	r3,0(r2)
}
81106b64:	0001883a 	nop
81106b68:	e037883a 	mov	sp,fp
81106b6c:	df000017 	ldw	fp,0(sp)
81106b70:	dec00104 	addi	sp,sp,4
81106b74:	f800283a 	ret

81106b78 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106b78:	defffc04 	addi	sp,sp,-16
81106b7c:	de00012e 	bgeu	sp,et,81106b84 <uliFeebReadReg+0xc>
81106b80:	003b68fa 	trap	3
81106b84:	df000315 	stw	fp,12(sp)
81106b88:	df000304 	addi	fp,sp,12
81106b8c:	e13ffe15 	stw	r4,-8(fp)
81106b90:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106b94:	e0bfff17 	ldw	r2,-4(fp)
81106b98:	1085883a 	add	r2,r2,r2
81106b9c:	1085883a 	add	r2,r2,r2
81106ba0:	1007883a 	mov	r3,r2
81106ba4:	e0bffe17 	ldw	r2,-8(fp)
81106ba8:	10c5883a 	add	r2,r2,r3
81106bac:	10800017 	ldw	r2,0(r2)
81106bb0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106bb4:	e0bffd17 	ldw	r2,-12(fp)
}
81106bb8:	e037883a 	mov	sp,fp
81106bbc:	df000017 	ldw	fp,0(sp)
81106bc0:	dec00104 	addi	sp,sp,4
81106bc4:	f800283a 	ret

81106bc8 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106bc8:	defffb04 	addi	sp,sp,-20
81106bcc:	de00012e 	bgeu	sp,et,81106bd4 <vRmapCh1HandleIrq+0xc>
81106bd0:	003b68fa 	trap	3
81106bd4:	dfc00415 	stw	ra,16(sp)
81106bd8:	df000315 	stw	fp,12(sp)
81106bdc:	df000304 	addi	fp,sp,12
81106be0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106be4:	00a045f4 	movhi	r2,33047
81106be8:	10a00404 	addi	r2,r2,-32752
81106bec:	10800e8b 	ldhu	r2,58(r2)
81106bf0:	10bfffcc 	andi	r2,r2,65535
81106bf4:	108000e8 	cmpgeui	r2,r2,3
81106bf8:	1000071e 	bne	r2,zero,81106c18 <vRmapCh1HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
81106bfc:	d0a06217 	ldw	r2,-32376(gp)
81106c00:	100f883a 	mov	r7,r2
81106c04:	01800284 	movi	r6,10
81106c08:	01400044 	movi	r5,1
81106c0c:	01204574 	movhi	r4,33045
81106c10:	2135dc04 	addi	r4,r4,-10384
81106c14:	11230300 	call	81123030 <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106c18:	11073d00 	call	811073d0 <uliRmapCh1WriteCmdAddress>
81106c1c:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106c20:	00800444 	movi	r2,17
81106c24:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106c28:	00bffc04 	movi	r2,-16
81106c2c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106c30:	e0bffd03 	ldbu	r2,-12(fp)
81106c34:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106c38:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106c3c:	00a045f4 	movhi	r2,33047
81106c40:	10a00404 	addi	r2,r2,-32752
81106c44:	10800e8b 	ldhu	r2,58(r2)
81106c48:	10bfffcc 	andi	r2,r2,65535
81106c4c:	108000e8 	cmpgeui	r2,r2,3
81106c50:	1000071e 	bne	r2,zero,81106c70 <vRmapCh1HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106c54:	d0a06217 	ldw	r2,-32376(gp)
81106c58:	e0fffd03 	ldbu	r3,-12(fp)
81106c5c:	180d883a 	mov	r6,r3
81106c60:	01604574 	movhi	r5,33045
81106c64:	2975df04 	addi	r5,r5,-10372
81106c68:	1009883a 	mov	r4,r2
81106c6c:	11229940 	call	81122994 <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106c70:	d0a06a17 	ldw	r2,-32344(gp)
81106c74:	e0fffe17 	ldw	r3,-8(fp)
81106c78:	180b883a 	mov	r5,r3
81106c7c:	1009883a 	mov	r4,r2
81106c80:	113f4b40 	call	8113f4b4 <OSQPostFront>
81106c84:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106c88:	e0bffd43 	ldbu	r2,-11(fp)
81106c8c:	10000226 	beq	r2,zero,81106c98 <vRmapCh1HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81106c90:	0009883a 	mov	r4,zero
81106c94:	111e8140 	call	8111e814 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106c98:	1106ef00 	call	81106ef0 <vRmapCh1IrqFlagClrWriteCmd>
}
81106c9c:	0001883a 	nop
81106ca0:	e037883a 	mov	sp,fp
81106ca4:	dfc00117 	ldw	ra,4(sp)
81106ca8:	df000017 	ldw	fp,0(sp)
81106cac:	dec00204 	addi	sp,sp,8
81106cb0:	f800283a 	ret

81106cb4 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106cb4:	defffb04 	addi	sp,sp,-20
81106cb8:	de00012e 	bgeu	sp,et,81106cc0 <vRmapCh2HandleIrq+0xc>
81106cbc:	003b68fa 	trap	3
81106cc0:	dfc00415 	stw	ra,16(sp)
81106cc4:	df000315 	stw	fp,12(sp)
81106cc8:	df000304 	addi	fp,sp,12
81106ccc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT8U error_codel;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106cd0:	00a045f4 	movhi	r2,33047
81106cd4:	10a00404 	addi	r2,r2,-32752
81106cd8:	10800e8b 	ldhu	r2,58(r2)
81106cdc:	10bfffcc 	andi	r2,r2,65535
81106ce0:	108000e8 	cmpgeui	r2,r2,3
81106ce4:	1000071e 	bne	r2,zero,81106d04 <vRmapCh2HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
81106ce8:	d0a06217 	ldw	r2,-32376(gp)
81106cec:	100f883a 	mov	r7,r2
81106cf0:	01800284 	movi	r6,10
81106cf4:	01400044 	movi	r5,1
81106cf8:	01204574 	movhi	r4,33045
81106cfc:	2135dc04 	addi	r4,r4,-10384
81106d00:	11230300 	call	81123030 <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
81106d04:	11074200 	call	81107420 <uliRmapCh2WriteCmdAddress>
81106d08:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106d0c:	00800444 	movi	r2,17
81106d10:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106d14:	00bffc04 	movi	r2,-16
81106d18:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106d1c:	e0bffd03 	ldbu	r2,-12(fp)
81106d20:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106d24:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106d28:	00a045f4 	movhi	r2,33047
81106d2c:	10a00404 	addi	r2,r2,-32752
81106d30:	10800e8b 	ldhu	r2,58(r2)
81106d34:	10bfffcc 	andi	r2,r2,65535
81106d38:	108000e8 	cmpgeui	r2,r2,3
81106d3c:	1000071e 	bne	r2,zero,81106d5c <vRmapCh2HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106d40:	d0a06217 	ldw	r2,-32376(gp)
81106d44:	e0fffd03 	ldbu	r3,-12(fp)
81106d48:	180d883a 	mov	r6,r3
81106d4c:	01604574 	movhi	r5,33045
81106d50:	2975df04 	addi	r5,r5,-10372
81106d54:	1009883a 	mov	r4,r2
81106d58:	11229940 	call	81122994 <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106d5c:	d0a06a17 	ldw	r2,-32344(gp)
81106d60:	e0fffe17 	ldw	r3,-8(fp)
81106d64:	180b883a 	mov	r5,r3
81106d68:	1009883a 	mov	r4,r2
81106d6c:	113f4b40 	call	8113f4b4 <OSQPostFront>
81106d70:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106d74:	e0bffd43 	ldbu	r2,-11(fp)
81106d78:	10000226 	beq	r2,zero,81106d84 <vRmapCh2HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81106d7c:	0009883a 	mov	r4,zero
81106d80:	111e8140 	call	8111e814 <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
81106d84:	1106f340 	call	81106f34 <vRmapCh2IrqFlagClrWriteCmd>
}
81106d88:	0001883a 	nop
81106d8c:	e037883a 	mov	sp,fp
81106d90:	dfc00117 	ldw	ra,4(sp)
81106d94:	df000017 	ldw	fp,0(sp)
81106d98:	dec00204 	addi	sp,sp,8
81106d9c:	f800283a 	ret

81106da0 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106da0:	defffd04 	addi	sp,sp,-12
81106da4:	de00012e 	bgeu	sp,et,81106dac <vRmapCh3HandleIrq+0xc>
81106da8:	003b68fa 	trap	3
81106dac:	dfc00215 	stw	ra,8(sp)
81106db0:	df000115 	stw	fp,4(sp)
81106db4:	df000104 	addi	fp,sp,4
81106db8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106dbc:	1106f780 	call	81106f78 <vRmapCh3IrqFlagClrWriteCmd>
}
81106dc0:	0001883a 	nop
81106dc4:	e037883a 	mov	sp,fp
81106dc8:	dfc00117 	ldw	ra,4(sp)
81106dcc:	df000017 	ldw	fp,0(sp)
81106dd0:	dec00204 	addi	sp,sp,8
81106dd4:	f800283a 	ret

81106dd8 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106dd8:	defffd04 	addi	sp,sp,-12
81106ddc:	de00012e 	bgeu	sp,et,81106de4 <vRmapCh4HandleIrq+0xc>
81106de0:	003b68fa 	trap	3
81106de4:	dfc00215 	stw	ra,8(sp)
81106de8:	df000115 	stw	fp,4(sp)
81106dec:	df000104 	addi	fp,sp,4
81106df0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106df4:	1106fbc0 	call	81106fbc <vRmapCh4IrqFlagClrWriteCmd>
}
81106df8:	0001883a 	nop
81106dfc:	e037883a 	mov	sp,fp
81106e00:	dfc00117 	ldw	ra,4(sp)
81106e04:	df000017 	ldw	fp,0(sp)
81106e08:	dec00204 	addi	sp,sp,8
81106e0c:	f800283a 	ret

81106e10 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106e10:	defffd04 	addi	sp,sp,-12
81106e14:	de00012e 	bgeu	sp,et,81106e1c <vRmapCh5HandleIrq+0xc>
81106e18:	003b68fa 	trap	3
81106e1c:	dfc00215 	stw	ra,8(sp)
81106e20:	df000115 	stw	fp,4(sp)
81106e24:	df000104 	addi	fp,sp,4
81106e28:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106e2c:	11070000 	call	81107000 <vRmapCh5IrqFlagClrWriteCmd>
}
81106e30:	0001883a 	nop
81106e34:	e037883a 	mov	sp,fp
81106e38:	dfc00117 	ldw	ra,4(sp)
81106e3c:	df000017 	ldw	fp,0(sp)
81106e40:	dec00204 	addi	sp,sp,8
81106e44:	f800283a 	ret

81106e48 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106e48:	defffd04 	addi	sp,sp,-12
81106e4c:	de00012e 	bgeu	sp,et,81106e54 <vRmapCh6HandleIrq+0xc>
81106e50:	003b68fa 	trap	3
81106e54:	dfc00215 	stw	ra,8(sp)
81106e58:	df000115 	stw	fp,4(sp)
81106e5c:	df000104 	addi	fp,sp,4
81106e60:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106e64:	11070440 	call	81107044 <vRmapCh6IrqFlagClrWriteCmd>
}
81106e68:	0001883a 	nop
81106e6c:	e037883a 	mov	sp,fp
81106e70:	dfc00117 	ldw	ra,4(sp)
81106e74:	df000017 	ldw	fp,0(sp)
81106e78:	dec00204 	addi	sp,sp,8
81106e7c:	f800283a 	ret

81106e80 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106e80:	defffd04 	addi	sp,sp,-12
81106e84:	de00012e 	bgeu	sp,et,81106e8c <vRmapCh7HandleIrq+0xc>
81106e88:	003b68fa 	trap	3
81106e8c:	dfc00215 	stw	ra,8(sp)
81106e90:	df000115 	stw	fp,4(sp)
81106e94:	df000104 	addi	fp,sp,4
81106e98:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106e9c:	11070880 	call	81107088 <vRmapCh7IrqFlagClrWriteCmd>
}
81106ea0:	0001883a 	nop
81106ea4:	e037883a 	mov	sp,fp
81106ea8:	dfc00117 	ldw	ra,4(sp)
81106eac:	df000017 	ldw	fp,0(sp)
81106eb0:	dec00204 	addi	sp,sp,8
81106eb4:	f800283a 	ret

81106eb8 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106eb8:	defffd04 	addi	sp,sp,-12
81106ebc:	de00012e 	bgeu	sp,et,81106ec4 <vRmapCh8HandleIrq+0xc>
81106ec0:	003b68fa 	trap	3
81106ec4:	dfc00215 	stw	ra,8(sp)
81106ec8:	df000115 	stw	fp,4(sp)
81106ecc:	df000104 	addi	fp,sp,4
81106ed0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106ed4:	11070cc0 	call	811070cc <vRmapCh8IrqFlagClrWriteCmd>
}
81106ed8:	0001883a 	nop
81106edc:	e037883a 	mov	sp,fp
81106ee0:	dfc00117 	ldw	ra,4(sp)
81106ee4:	df000017 	ldw	fp,0(sp)
81106ee8:	dec00204 	addi	sp,sp,8
81106eec:	f800283a 	ret

81106ef0 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106ef0:	defffe04 	addi	sp,sp,-8
81106ef4:	de00012e 	bgeu	sp,et,81106efc <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106ef8:	003b68fa 	trap	3
81106efc:	dfc00115 	stw	ra,4(sp)
81106f00:	df000015 	stw	fp,0(sp)
81106f04:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106f08:	01800044 	movi	r6,1
81106f0c:	014004c4 	movi	r5,19
81106f10:	01204834 	movhi	r4,33056
81106f14:	210b0004 	addi	r4,r4,11264
81106f18:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f1c:	0001883a 	nop
81106f20:	e037883a 	mov	sp,fp
81106f24:	dfc00117 	ldw	ra,4(sp)
81106f28:	df000017 	ldw	fp,0(sp)
81106f2c:	dec00204 	addi	sp,sp,8
81106f30:	f800283a 	ret

81106f34 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106f34:	defffe04 	addi	sp,sp,-8
81106f38:	de00012e 	bgeu	sp,et,81106f40 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106f3c:	003b68fa 	trap	3
81106f40:	dfc00115 	stw	ra,4(sp)
81106f44:	df000015 	stw	fp,0(sp)
81106f48:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106f4c:	01800044 	movi	r6,1
81106f50:	014004c4 	movi	r5,19
81106f54:	01204834 	movhi	r4,33056
81106f58:	210a0004 	addi	r4,r4,10240
81106f5c:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f60:	0001883a 	nop
81106f64:	e037883a 	mov	sp,fp
81106f68:	dfc00117 	ldw	ra,4(sp)
81106f6c:	df000017 	ldw	fp,0(sp)
81106f70:	dec00204 	addi	sp,sp,8
81106f74:	f800283a 	ret

81106f78 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106f78:	defffe04 	addi	sp,sp,-8
81106f7c:	de00012e 	bgeu	sp,et,81106f84 <vRmapCh3IrqFlagClrWriteCmd+0xc>
81106f80:	003b68fa 	trap	3
81106f84:	dfc00115 	stw	ra,4(sp)
81106f88:	df000015 	stw	fp,0(sp)
81106f8c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106f90:	01800044 	movi	r6,1
81106f94:	014004c4 	movi	r5,19
81106f98:	01204834 	movhi	r4,33056
81106f9c:	210b0004 	addi	r4,r4,11264
81106fa0:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106fa4:	0001883a 	nop
81106fa8:	e037883a 	mov	sp,fp
81106fac:	dfc00117 	ldw	ra,4(sp)
81106fb0:	df000017 	ldw	fp,0(sp)
81106fb4:	dec00204 	addi	sp,sp,8
81106fb8:	f800283a 	ret

81106fbc <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106fbc:	defffe04 	addi	sp,sp,-8
81106fc0:	de00012e 	bgeu	sp,et,81106fc8 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106fc4:	003b68fa 	trap	3
81106fc8:	dfc00115 	stw	ra,4(sp)
81106fcc:	df000015 	stw	fp,0(sp)
81106fd0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106fd4:	01800044 	movi	r6,1
81106fd8:	014004c4 	movi	r5,19
81106fdc:	01204834 	movhi	r4,33056
81106fe0:	210a0004 	addi	r4,r4,10240
81106fe4:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106fe8:	0001883a 	nop
81106fec:	e037883a 	mov	sp,fp
81106ff0:	dfc00117 	ldw	ra,4(sp)
81106ff4:	df000017 	ldw	fp,0(sp)
81106ff8:	dec00204 	addi	sp,sp,8
81106ffc:	f800283a 	ret

81107000 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81107000:	defffe04 	addi	sp,sp,-8
81107004:	de00012e 	bgeu	sp,et,8110700c <vRmapCh5IrqFlagClrWriteCmd+0xc>
81107008:	003b68fa 	trap	3
8110700c:	dfc00115 	stw	ra,4(sp)
81107010:	df000015 	stw	fp,0(sp)
81107014:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107018:	01800044 	movi	r6,1
8110701c:	014004c4 	movi	r5,19
81107020:	01204834 	movhi	r4,33056
81107024:	210b0004 	addi	r4,r4,11264
81107028:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110702c:	0001883a 	nop
81107030:	e037883a 	mov	sp,fp
81107034:	dfc00117 	ldw	ra,4(sp)
81107038:	df000017 	ldw	fp,0(sp)
8110703c:	dec00204 	addi	sp,sp,8
81107040:	f800283a 	ret

81107044 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81107044:	defffe04 	addi	sp,sp,-8
81107048:	de00012e 	bgeu	sp,et,81107050 <vRmapCh6IrqFlagClrWriteCmd+0xc>
8110704c:	003b68fa 	trap	3
81107050:	dfc00115 	stw	ra,4(sp)
81107054:	df000015 	stw	fp,0(sp)
81107058:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110705c:	01800044 	movi	r6,1
81107060:	014004c4 	movi	r5,19
81107064:	01204834 	movhi	r4,33056
81107068:	210a0004 	addi	r4,r4,10240
8110706c:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107070:	0001883a 	nop
81107074:	e037883a 	mov	sp,fp
81107078:	dfc00117 	ldw	ra,4(sp)
8110707c:	df000017 	ldw	fp,0(sp)
81107080:	dec00204 	addi	sp,sp,8
81107084:	f800283a 	ret

81107088 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107088:	defffe04 	addi	sp,sp,-8
8110708c:	de00012e 	bgeu	sp,et,81107094 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107090:	003b68fa 	trap	3
81107094:	dfc00115 	stw	ra,4(sp)
81107098:	df000015 	stw	fp,0(sp)
8110709c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811070a0:	01800044 	movi	r6,1
811070a4:	014004c4 	movi	r5,19
811070a8:	01204834 	movhi	r4,33056
811070ac:	210b0004 	addi	r4,r4,11264
811070b0:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070b4:	0001883a 	nop
811070b8:	e037883a 	mov	sp,fp
811070bc:	dfc00117 	ldw	ra,4(sp)
811070c0:	df000017 	ldw	fp,0(sp)
811070c4:	dec00204 	addi	sp,sp,8
811070c8:	f800283a 	ret

811070cc <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811070cc:	defffe04 	addi	sp,sp,-8
811070d0:	de00012e 	bgeu	sp,et,811070d8 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811070d4:	003b68fa 	trap	3
811070d8:	dfc00115 	stw	ra,4(sp)
811070dc:	df000015 	stw	fp,0(sp)
811070e0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811070e4:	01800044 	movi	r6,1
811070e8:	014004c4 	movi	r5,19
811070ec:	01204834 	movhi	r4,33056
811070f0:	210a0004 	addi	r4,r4,10240
811070f4:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070f8:	0001883a 	nop
811070fc:	e037883a 	mov	sp,fp
81107100:	dfc00117 	ldw	ra,4(sp)
81107104:	df000017 	ldw	fp,0(sp)
81107108:	dec00204 	addi	sp,sp,8
8110710c:	f800283a 	ret

81107110 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
81107110:	defffd04 	addi	sp,sp,-12
81107114:	de00012e 	bgeu	sp,et,8110711c <bRmapCh1IrqFlagWriteCmd+0xc>
81107118:	003b68fa 	trap	3
8110711c:	dfc00215 	stw	ra,8(sp)
81107120:	df000115 	stw	fp,4(sp)
81107124:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107128:	01400484 	movi	r5,18
8110712c:	01204834 	movhi	r4,33056
81107130:	210b0004 	addi	r4,r4,11264
81107134:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107138:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110713c:	10000326 	beq	r2,zero,8110714c <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107140:	00800044 	movi	r2,1
81107144:	e0bfff15 	stw	r2,-4(fp)
81107148:	00000106 	br	81107150 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110714c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107150:	e0bfff17 	ldw	r2,-4(fp)
}
81107154:	e037883a 	mov	sp,fp
81107158:	dfc00117 	ldw	ra,4(sp)
8110715c:	df000017 	ldw	fp,0(sp)
81107160:	dec00204 	addi	sp,sp,8
81107164:	f800283a 	ret

81107168 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107168:	defffd04 	addi	sp,sp,-12
8110716c:	de00012e 	bgeu	sp,et,81107174 <bRmapCh2IrqFlagWriteCmd+0xc>
81107170:	003b68fa 	trap	3
81107174:	dfc00215 	stw	ra,8(sp)
81107178:	df000115 	stw	fp,4(sp)
8110717c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107180:	01400484 	movi	r5,18
81107184:	01204834 	movhi	r4,33056
81107188:	210a0004 	addi	r4,r4,10240
8110718c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107190:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107194:	10000326 	beq	r2,zero,811071a4 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107198:	00800044 	movi	r2,1
8110719c:	e0bfff15 	stw	r2,-4(fp)
811071a0:	00000106 	br	811071a8 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811071a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811071a8:	e0bfff17 	ldw	r2,-4(fp)
}
811071ac:	e037883a 	mov	sp,fp
811071b0:	dfc00117 	ldw	ra,4(sp)
811071b4:	df000017 	ldw	fp,0(sp)
811071b8:	dec00204 	addi	sp,sp,8
811071bc:	f800283a 	ret

811071c0 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
811071c0:	defffd04 	addi	sp,sp,-12
811071c4:	de00012e 	bgeu	sp,et,811071cc <bRmapCh3IrqFlagWriteCmd+0xc>
811071c8:	003b68fa 	trap	3
811071cc:	dfc00215 	stw	ra,8(sp)
811071d0:	df000115 	stw	fp,4(sp)
811071d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811071d8:	01400484 	movi	r5,18
811071dc:	01204834 	movhi	r4,33056
811071e0:	210b0004 	addi	r4,r4,11264
811071e4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811071e8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811071ec:	10000326 	beq	r2,zero,811071fc <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811071f0:	00800044 	movi	r2,1
811071f4:	e0bfff15 	stw	r2,-4(fp)
811071f8:	00000106 	br	81107200 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811071fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107200:	e0bfff17 	ldw	r2,-4(fp)
}
81107204:	e037883a 	mov	sp,fp
81107208:	dfc00117 	ldw	ra,4(sp)
8110720c:	df000017 	ldw	fp,0(sp)
81107210:	dec00204 	addi	sp,sp,8
81107214:	f800283a 	ret

81107218 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81107218:	defffd04 	addi	sp,sp,-12
8110721c:	de00012e 	bgeu	sp,et,81107224 <bRmapCh4IrqFlagWriteCmd+0xc>
81107220:	003b68fa 	trap	3
81107224:	dfc00215 	stw	ra,8(sp)
81107228:	df000115 	stw	fp,4(sp)
8110722c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107230:	01400484 	movi	r5,18
81107234:	01204834 	movhi	r4,33056
81107238:	210a0004 	addi	r4,r4,10240
8110723c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107240:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107244:	10000326 	beq	r2,zero,81107254 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107248:	00800044 	movi	r2,1
8110724c:	e0bfff15 	stw	r2,-4(fp)
81107250:	00000106 	br	81107258 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107254:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107258:	e0bfff17 	ldw	r2,-4(fp)
}
8110725c:	e037883a 	mov	sp,fp
81107260:	dfc00117 	ldw	ra,4(sp)
81107264:	df000017 	ldw	fp,0(sp)
81107268:	dec00204 	addi	sp,sp,8
8110726c:	f800283a 	ret

81107270 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107270:	defffd04 	addi	sp,sp,-12
81107274:	de00012e 	bgeu	sp,et,8110727c <bRmapCh5IrqFlagWriteCmd+0xc>
81107278:	003b68fa 	trap	3
8110727c:	dfc00215 	stw	ra,8(sp)
81107280:	df000115 	stw	fp,4(sp)
81107284:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107288:	01400484 	movi	r5,18
8110728c:	01204834 	movhi	r4,33056
81107290:	210b0004 	addi	r4,r4,11264
81107294:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107298:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110729c:	10000326 	beq	r2,zero,811072ac <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072a0:	00800044 	movi	r2,1
811072a4:	e0bfff15 	stw	r2,-4(fp)
811072a8:	00000106 	br	811072b0 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811072ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811072b0:	e0bfff17 	ldw	r2,-4(fp)
}
811072b4:	e037883a 	mov	sp,fp
811072b8:	dfc00117 	ldw	ra,4(sp)
811072bc:	df000017 	ldw	fp,0(sp)
811072c0:	dec00204 	addi	sp,sp,8
811072c4:	f800283a 	ret

811072c8 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811072c8:	defffd04 	addi	sp,sp,-12
811072cc:	de00012e 	bgeu	sp,et,811072d4 <bRmapCh6IrqFlagWriteCmd+0xc>
811072d0:	003b68fa 	trap	3
811072d4:	dfc00215 	stw	ra,8(sp)
811072d8:	df000115 	stw	fp,4(sp)
811072dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811072e0:	01400484 	movi	r5,18
811072e4:	01204834 	movhi	r4,33056
811072e8:	210a0004 	addi	r4,r4,10240
811072ec:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072f0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811072f4:	10000326 	beq	r2,zero,81107304 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072f8:	00800044 	movi	r2,1
811072fc:	e0bfff15 	stw	r2,-4(fp)
81107300:	00000106 	br	81107308 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107304:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107308:	e0bfff17 	ldw	r2,-4(fp)
}
8110730c:	e037883a 	mov	sp,fp
81107310:	dfc00117 	ldw	ra,4(sp)
81107314:	df000017 	ldw	fp,0(sp)
81107318:	dec00204 	addi	sp,sp,8
8110731c:	f800283a 	ret

81107320 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81107320:	defffd04 	addi	sp,sp,-12
81107324:	de00012e 	bgeu	sp,et,8110732c <bRmapCh7IrqFlagWriteCmd+0xc>
81107328:	003b68fa 	trap	3
8110732c:	dfc00215 	stw	ra,8(sp)
81107330:	df000115 	stw	fp,4(sp)
81107334:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107338:	01400484 	movi	r5,18
8110733c:	01204834 	movhi	r4,33056
81107340:	210b0004 	addi	r4,r4,11264
81107344:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107348:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110734c:	10000326 	beq	r2,zero,8110735c <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107350:	00800044 	movi	r2,1
81107354:	e0bfff15 	stw	r2,-4(fp)
81107358:	00000106 	br	81107360 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110735c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107360:	e0bfff17 	ldw	r2,-4(fp)
}
81107364:	e037883a 	mov	sp,fp
81107368:	dfc00117 	ldw	ra,4(sp)
8110736c:	df000017 	ldw	fp,0(sp)
81107370:	dec00204 	addi	sp,sp,8
81107374:	f800283a 	ret

81107378 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107378:	defffd04 	addi	sp,sp,-12
8110737c:	de00012e 	bgeu	sp,et,81107384 <bRmapCh8IrqFlagWriteCmd+0xc>
81107380:	003b68fa 	trap	3
81107384:	dfc00215 	stw	ra,8(sp)
81107388:	df000115 	stw	fp,4(sp)
8110738c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107390:	01400484 	movi	r5,18
81107394:	01204834 	movhi	r4,33056
81107398:	210a0004 	addi	r4,r4,10240
8110739c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811073a0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811073a4:	10000326 	beq	r2,zero,811073b4 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073a8:	00800044 	movi	r2,1
811073ac:	e0bfff15 	stw	r2,-4(fp)
811073b0:	00000106 	br	811073b8 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811073b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811073b8:	e0bfff17 	ldw	r2,-4(fp)
}
811073bc:	e037883a 	mov	sp,fp
811073c0:	dfc00117 	ldw	ra,4(sp)
811073c4:	df000017 	ldw	fp,0(sp)
811073c8:	dec00204 	addi	sp,sp,8
811073cc:	f800283a 	ret

811073d0 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811073d0:	defffd04 	addi	sp,sp,-12
811073d4:	de00012e 	bgeu	sp,et,811073dc <uliRmapCh1WriteCmdAddress+0xc>
811073d8:	003b68fa 	trap	3
811073dc:	dfc00215 	stw	ra,8(sp)
811073e0:	df000115 	stw	fp,4(sp)
811073e4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811073e8:	01400184 	movi	r5,6
811073ec:	01204834 	movhi	r4,33056
811073f0:	210b0004 	addi	r4,r4,11264
811073f4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811073f8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811073fc:	e13fff17 	ldw	r4,-4(fp)
81107400:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107404:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107408:	e0bfff17 	ldw	r2,-4(fp)
}
8110740c:	e037883a 	mov	sp,fp
81107410:	dfc00117 	ldw	ra,4(sp)
81107414:	df000017 	ldw	fp,0(sp)
81107418:	dec00204 	addi	sp,sp,8
8110741c:	f800283a 	ret

81107420 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81107420:	defffd04 	addi	sp,sp,-12
81107424:	de00012e 	bgeu	sp,et,8110742c <uliRmapCh2WriteCmdAddress+0xc>
81107428:	003b68fa 	trap	3
8110742c:	dfc00215 	stw	ra,8(sp)
81107430:	df000115 	stw	fp,4(sp)
81107434:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107438:	01400184 	movi	r5,6
8110743c:	01204834 	movhi	r4,33056
81107440:	210a0004 	addi	r4,r4,10240
81107444:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107448:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110744c:	e13fff17 	ldw	r4,-4(fp)
81107450:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107454:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107458:	e0bfff17 	ldw	r2,-4(fp)
}
8110745c:	e037883a 	mov	sp,fp
81107460:	dfc00117 	ldw	ra,4(sp)
81107464:	df000017 	ldw	fp,0(sp)
81107468:	dec00204 	addi	sp,sp,8
8110746c:	f800283a 	ret

81107470 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107470:	defffd04 	addi	sp,sp,-12
81107474:	de00012e 	bgeu	sp,et,8110747c <uliRmapCh3WriteCmdAddress+0xc>
81107478:	003b68fa 	trap	3
8110747c:	dfc00215 	stw	ra,8(sp)
81107480:	df000115 	stw	fp,4(sp)
81107484:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107488:	01400184 	movi	r5,6
8110748c:	01204834 	movhi	r4,33056
81107490:	210b0004 	addi	r4,r4,11264
81107494:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107498:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110749c:	e13fff17 	ldw	r4,-4(fp)
811074a0:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
811074a4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074a8:	e0bfff17 	ldw	r2,-4(fp)
}
811074ac:	e037883a 	mov	sp,fp
811074b0:	dfc00117 	ldw	ra,4(sp)
811074b4:	df000017 	ldw	fp,0(sp)
811074b8:	dec00204 	addi	sp,sp,8
811074bc:	f800283a 	ret

811074c0 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811074c0:	defffd04 	addi	sp,sp,-12
811074c4:	de00012e 	bgeu	sp,et,811074cc <uliRmapCh4WriteCmdAddress+0xc>
811074c8:	003b68fa 	trap	3
811074cc:	dfc00215 	stw	ra,8(sp)
811074d0:	df000115 	stw	fp,4(sp)
811074d4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811074d8:	01400184 	movi	r5,6
811074dc:	01204834 	movhi	r4,33056
811074e0:	210a0004 	addi	r4,r4,10240
811074e4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811074e8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811074ec:	e13fff17 	ldw	r4,-4(fp)
811074f0:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
811074f4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074f8:	e0bfff17 	ldw	r2,-4(fp)
}
811074fc:	e037883a 	mov	sp,fp
81107500:	dfc00117 	ldw	ra,4(sp)
81107504:	df000017 	ldw	fp,0(sp)
81107508:	dec00204 	addi	sp,sp,8
8110750c:	f800283a 	ret

81107510 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81107510:	defffd04 	addi	sp,sp,-12
81107514:	de00012e 	bgeu	sp,et,8110751c <uliRmapCh5WriteCmdAddress+0xc>
81107518:	003b68fa 	trap	3
8110751c:	dfc00215 	stw	ra,8(sp)
81107520:	df000115 	stw	fp,4(sp)
81107524:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107528:	01400184 	movi	r5,6
8110752c:	01204834 	movhi	r4,33056
81107530:	210b0004 	addi	r4,r4,11264
81107534:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107538:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110753c:	e13fff17 	ldw	r4,-4(fp)
81107540:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107544:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107548:	e0bfff17 	ldw	r2,-4(fp)
}
8110754c:	e037883a 	mov	sp,fp
81107550:	dfc00117 	ldw	ra,4(sp)
81107554:	df000017 	ldw	fp,0(sp)
81107558:	dec00204 	addi	sp,sp,8
8110755c:	f800283a 	ret

81107560 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107560:	defffd04 	addi	sp,sp,-12
81107564:	de00012e 	bgeu	sp,et,8110756c <uliRmapCh6WriteCmdAddress+0xc>
81107568:	003b68fa 	trap	3
8110756c:	dfc00215 	stw	ra,8(sp)
81107570:	df000115 	stw	fp,4(sp)
81107574:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107578:	01400184 	movi	r5,6
8110757c:	01204834 	movhi	r4,33056
81107580:	210a0004 	addi	r4,r4,10240
81107584:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107588:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110758c:	e13fff17 	ldw	r4,-4(fp)
81107590:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107594:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107598:	e0bfff17 	ldw	r2,-4(fp)
}
8110759c:	e037883a 	mov	sp,fp
811075a0:	dfc00117 	ldw	ra,4(sp)
811075a4:	df000017 	ldw	fp,0(sp)
811075a8:	dec00204 	addi	sp,sp,8
811075ac:	f800283a 	ret

811075b0 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
811075b0:	defffd04 	addi	sp,sp,-12
811075b4:	de00012e 	bgeu	sp,et,811075bc <uliRmapCh7WriteCmdAddress+0xc>
811075b8:	003b68fa 	trap	3
811075bc:	dfc00215 	stw	ra,8(sp)
811075c0:	df000115 	stw	fp,4(sp)
811075c4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075c8:	01400184 	movi	r5,6
811075cc:	01204834 	movhi	r4,33056
811075d0:	210b0004 	addi	r4,r4,11264
811075d4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811075d8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075dc:	e13fff17 	ldw	r4,-4(fp)
811075e0:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
811075e4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075e8:	e0bfff17 	ldw	r2,-4(fp)
}
811075ec:	e037883a 	mov	sp,fp
811075f0:	dfc00117 	ldw	ra,4(sp)
811075f4:	df000017 	ldw	fp,0(sp)
811075f8:	dec00204 	addi	sp,sp,8
811075fc:	f800283a 	ret

81107600 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81107600:	defffd04 	addi	sp,sp,-12
81107604:	de00012e 	bgeu	sp,et,8110760c <uliRmapCh8WriteCmdAddress+0xc>
81107608:	003b68fa 	trap	3
8110760c:	dfc00215 	stw	ra,8(sp)
81107610:	df000115 	stw	fp,4(sp)
81107614:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107618:	01400184 	movi	r5,6
8110761c:	01204834 	movhi	r4,33056
81107620:	210a0004 	addi	r4,r4,10240
81107624:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107628:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110762c:	e13fff17 	ldw	r4,-4(fp)
81107630:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107634:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107638:	e0bfff17 	ldw	r2,-4(fp)
}
8110763c:	e037883a 	mov	sp,fp
81107640:	dfc00117 	ldw	ra,4(sp)
81107644:	df000017 	ldw	fp,0(sp)
81107648:	dec00204 	addi	sp,sp,8
8110764c:	f800283a 	ret

81107650 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107650:	defffc04 	addi	sp,sp,-16
81107654:	de00012e 	bgeu	sp,et,8110765c <vRmapInitIrq+0xc>
81107658:	003b68fa 	trap	3
8110765c:	dfc00315 	stw	ra,12(sp)
81107660:	df000215 	stw	fp,8(sp)
81107664:	df000204 	addi	fp,sp,8
81107668:	2005883a 	mov	r2,r4
8110766c:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107670:	e0bfff03 	ldbu	r2,-4(fp)
81107674:	10c00228 	cmpgeui	r3,r2,8
81107678:	18004e1e 	bne	r3,zero,811077b4 <vRmapInitIrq+0x164>
8110767c:	100690ba 	slli	r3,r2,2
81107680:	00a04434 	movhi	r2,33040
81107684:	109da504 	addi	r2,r2,30356
81107688:	1885883a 	add	r2,r3,r2
8110768c:	10800017 	ldw	r2,0(r2)
81107690:	1000683a 	jmp	r2
81107694:	811076b4 	orhi	r4,r16,16858
81107698:	811076d4 	ori	r4,r16,16859
8110769c:	811076f4 	orhi	r4,r16,16859
811076a0:	81107714 	ori	r4,r16,16860
811076a4:	81107734 	orhi	r4,r16,16860
811076a8:	81107754 	ori	r4,r16,16861
811076ac:	81107774 	orhi	r4,r16,16861
811076b0:	81107794 	ori	r4,r16,16862
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811076b4:	d0a04804 	addi	r2,gp,-32480
811076b8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
811076bc:	01a04434 	movhi	r6,33040
811076c0:	319af204 	addi	r6,r6,27592
811076c4:	e17ffe17 	ldw	r5,-8(fp)
811076c8:	010005c4 	movi	r4,23
811076cc:	11379600 	call	81137960 <alt_irq_register>
		break;
811076d0:	00003806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811076d4:	d0a04904 	addi	r2,gp,-32476
811076d8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811076dc:	01a04434 	movhi	r6,33040
811076e0:	319b2d04 	addi	r6,r6,27828
811076e4:	e17ffe17 	ldw	r5,-8(fp)
811076e8:	01000544 	movi	r4,21
811076ec:	11379600 	call	81137960 <alt_irq_register>
		break;
811076f0:	00003006 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811076f4:	d0a04a04 	addi	r2,gp,-32472
811076f8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811076fc:	01a04434 	movhi	r6,33040
81107700:	319b6804 	addi	r6,r6,28064
81107704:	e17ffe17 	ldw	r5,-8(fp)
81107708:	010004c4 	movi	r4,19
8110770c:	11379600 	call	81137960 <alt_irq_register>
		break;
81107710:	00002806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81107714:	d0a04b04 	addi	r2,gp,-32468
81107718:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
8110771c:	01a04434 	movhi	r6,33040
81107720:	319b7604 	addi	r6,r6,28120
81107724:	e17ffe17 	ldw	r5,-8(fp)
81107728:	01000444 	movi	r4,17
8110772c:	11379600 	call	81137960 <alt_irq_register>
		break;
81107730:	00002006 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81107734:	d0a04c04 	addi	r2,gp,-32464
81107738:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
8110773c:	01a04434 	movhi	r6,33040
81107740:	319b8404 	addi	r6,r6,28176
81107744:	e17ffe17 	ldw	r5,-8(fp)
81107748:	01000244 	movi	r4,9
8110774c:	11379600 	call	81137960 <alt_irq_register>
		break;
81107750:	00001806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107754:	d0a04d04 	addi	r2,gp,-32460
81107758:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
8110775c:	01a04434 	movhi	r6,33040
81107760:	319b9204 	addi	r6,r6,28232
81107764:	e17ffe17 	ldw	r5,-8(fp)
81107768:	010001c4 	movi	r4,7
8110776c:	11379600 	call	81137960 <alt_irq_register>
		break;
81107770:	00001006 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107774:	d0a04e04 	addi	r2,gp,-32456
81107778:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
8110777c:	01a04434 	movhi	r6,33040
81107780:	319ba004 	addi	r6,r6,28288
81107784:	e17ffe17 	ldw	r5,-8(fp)
81107788:	01000104 	movi	r4,4
8110778c:	11379600 	call	81137960 <alt_irq_register>
		break;
81107790:	00000806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107794:	d0a04f04 	addi	r2,gp,-32452
81107798:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
8110779c:	01a04434 	movhi	r6,33040
811077a0:	319bae04 	addi	r6,r6,28344
811077a4:	e17ffe17 	ldw	r5,-8(fp)
811077a8:	010000c4 	movi	r4,3
811077ac:	11379600 	call	81137960 <alt_irq_register>
		break;
811077b0:	0001883a 	nop
	}
}
811077b4:	0001883a 	nop
811077b8:	e037883a 	mov	sp,fp
811077bc:	dfc00117 	ldw	ra,4(sp)
811077c0:	df000017 	ldw	fp,0(sp)
811077c4:	dec00204 	addi	sp,sp,8
811077c8:	f800283a 	ret

811077cc <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811077cc:	defffb04 	addi	sp,sp,-20
811077d0:	de00012e 	bgeu	sp,et,811077d8 <bRmapSetIrqControl+0xc>
811077d4:	003b68fa 	trap	3
811077d8:	dfc00415 	stw	ra,16(sp)
811077dc:	df000315 	stw	fp,12(sp)
811077e0:	df000304 	addi	fp,sp,12
811077e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811077e8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811077ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811077f0:	e0bfff17 	ldw	r2,-4(fp)
811077f4:	10001926 	beq	r2,zero,8110785c <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077f8:	e0bfff17 	ldw	r2,-4(fp)
811077fc:	10800017 	ldw	r2,0(r2)
81107800:	01400444 	movi	r5,17
81107804:	1009883a 	mov	r4,r2
81107808:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110780c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81107810:	e0bfff17 	ldw	r2,-4(fp)
81107814:	10801017 	ldw	r2,64(r2)
81107818:	10000426 	beq	r2,zero,8110782c <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
8110781c:	e0bffe17 	ldw	r2,-8(fp)
81107820:	10800054 	ori	r2,r2,1
81107824:	e0bffe15 	stw	r2,-8(fp)
81107828:	00000406 	br	8110783c <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
8110782c:	e0fffe17 	ldw	r3,-8(fp)
81107830:	00bfff84 	movi	r2,-2
81107834:	1884703a 	and	r2,r3,r2
81107838:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
8110783c:	e0bfff17 	ldw	r2,-4(fp)
81107840:	10800017 	ldw	r2,0(r2)
81107844:	e1bffe17 	ldw	r6,-8(fp)
81107848:	01400444 	movi	r5,17
8110784c:	1009883a 	mov	r4,r2
81107850:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107854:	00800044 	movi	r2,1
81107858:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110785c:	e0bffd17 	ldw	r2,-12(fp)
}
81107860:	e037883a 	mov	sp,fp
81107864:	dfc00117 	ldw	ra,4(sp)
81107868:	df000017 	ldw	fp,0(sp)
8110786c:	dec00204 	addi	sp,sp,8
81107870:	f800283a 	ret

81107874 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107874:	defffb04 	addi	sp,sp,-20
81107878:	de00012e 	bgeu	sp,et,81107880 <bRmapGetIrqControl+0xc>
8110787c:	003b68fa 	trap	3
81107880:	dfc00415 	stw	ra,16(sp)
81107884:	df000315 	stw	fp,12(sp)
81107888:	df000304 	addi	fp,sp,12
8110788c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107890:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107894:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107898:	e0bfff17 	ldw	r2,-4(fp)
8110789c:	10001126 	beq	r2,zero,811078e4 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078a0:	e0bfff17 	ldw	r2,-4(fp)
811078a4:	10800017 	ldw	r2,0(r2)
811078a8:	01400444 	movi	r5,17
811078ac:	1009883a 	mov	r4,r2
811078b0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811078b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811078b8:	e0bffe17 	ldw	r2,-8(fp)
811078bc:	1080004c 	andi	r2,r2,1
811078c0:	10000426 	beq	r2,zero,811078d4 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811078c4:	e0bfff17 	ldw	r2,-4(fp)
811078c8:	00c00044 	movi	r3,1
811078cc:	10c01015 	stw	r3,64(r2)
811078d0:	00000206 	br	811078dc <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811078d4:	e0bfff17 	ldw	r2,-4(fp)
811078d8:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811078dc:	00800044 	movi	r2,1
811078e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811078e4:	e0bffd17 	ldw	r2,-12(fp)
}
811078e8:	e037883a 	mov	sp,fp
811078ec:	dfc00117 	ldw	ra,4(sp)
811078f0:	df000017 	ldw	fp,0(sp)
811078f4:	dec00204 	addi	sp,sp,8
811078f8:	f800283a 	ret

811078fc <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
811078fc:	defffb04 	addi	sp,sp,-20
81107900:	de00012e 	bgeu	sp,et,81107908 <bRmapGetIrqFlags+0xc>
81107904:	003b68fa 	trap	3
81107908:	dfc00415 	stw	ra,16(sp)
8110790c:	df000315 	stw	fp,12(sp)
81107910:	df000304 	addi	fp,sp,12
81107914:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107918:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110791c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107920:	e0bfff17 	ldw	r2,-4(fp)
81107924:	10001126 	beq	r2,zero,8110796c <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107928:	e0bfff17 	ldw	r2,-4(fp)
8110792c:	10800017 	ldw	r2,0(r2)
81107930:	01400484 	movi	r5,18
81107934:	1009883a 	mov	r4,r2
81107938:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110793c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107940:	e0bffe17 	ldw	r2,-8(fp)
81107944:	1080004c 	andi	r2,r2,1
81107948:	10000426 	beq	r2,zero,8110795c <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
8110794c:	e0bfff17 	ldw	r2,-4(fp)
81107950:	00c00044 	movi	r3,1
81107954:	10c01115 	stw	r3,68(r2)
81107958:	00000206 	br	81107964 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
8110795c:	e0bfff17 	ldw	r2,-4(fp)
81107960:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107964:	00800044 	movi	r2,1
81107968:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110796c:	e0bffd17 	ldw	r2,-12(fp)
}
81107970:	e037883a 	mov	sp,fp
81107974:	dfc00117 	ldw	ra,4(sp)
81107978:	df000017 	ldw	fp,0(sp)
8110797c:	dec00204 	addi	sp,sp,8
81107980:	f800283a 	ret

81107984 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107984:	defffb04 	addi	sp,sp,-20
81107988:	de00012e 	bgeu	sp,et,81107990 <bRmapSetCodecConfig+0xc>
8110798c:	003b68fa 	trap	3
81107990:	dfc00415 	stw	ra,16(sp)
81107994:	df000315 	stw	fp,12(sp)
81107998:	df000304 	addi	fp,sp,12
8110799c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811079a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811079a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811079a8:	e0bfff17 	ldw	r2,-4(fp)
811079ac:	10002526 	beq	r2,zero,81107a44 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079b0:	e0bfff17 	ldw	r2,-4(fp)
811079b4:	10800017 	ldw	r2,0(r2)
811079b8:	01400104 	movi	r5,4
811079bc:	1009883a 	mov	r4,r2
811079c0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811079c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
811079c8:	e0fffe17 	ldw	r3,-8(fp)
811079cc:	00bfc004 	movi	r2,-256
811079d0:	1884703a 	and	r2,r3,r2
811079d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
811079d8:	e0bfff17 	ldw	r2,-4(fp)
811079dc:	10800143 	ldbu	r2,5(r2)
811079e0:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
811079e4:	e0fffe17 	ldw	r3,-8(fp)
811079e8:	1884b03a 	or	r2,r3,r2
811079ec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
811079f0:	e0fffe17 	ldw	r3,-8(fp)
811079f4:	00bffff4 	movhi	r2,65535
811079f8:	10803fc4 	addi	r2,r2,255
811079fc:	1884703a 	and	r2,r3,r2
81107a00:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107a04:	e0bfff17 	ldw	r2,-4(fp)
81107a08:	10800103 	ldbu	r2,4(r2)
81107a0c:	10803fcc 	andi	r2,r2,255
81107a10:	1004923a 	slli	r2,r2,8
81107a14:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107a18:	e0fffe17 	ldw	r3,-8(fp)
81107a1c:	1884b03a 	or	r2,r3,r2
81107a20:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107a24:	e0bfff17 	ldw	r2,-4(fp)
81107a28:	10800017 	ldw	r2,0(r2)
81107a2c:	e1bffe17 	ldw	r6,-8(fp)
81107a30:	01400104 	movi	r5,4
81107a34:	1009883a 	mov	r4,r2
81107a38:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107a3c:	00800044 	movi	r2,1
81107a40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107a44:	e0bffd17 	ldw	r2,-12(fp)
}
81107a48:	e037883a 	mov	sp,fp
81107a4c:	dfc00117 	ldw	ra,4(sp)
81107a50:	df000017 	ldw	fp,0(sp)
81107a54:	dec00204 	addi	sp,sp,8
81107a58:	f800283a 	ret

81107a5c <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107a5c:	defffb04 	addi	sp,sp,-20
81107a60:	de00012e 	bgeu	sp,et,81107a68 <bRmapGetCodecConfig+0xc>
81107a64:	003b68fa 	trap	3
81107a68:	dfc00415 	stw	ra,16(sp)
81107a6c:	df000315 	stw	fp,12(sp)
81107a70:	df000304 	addi	fp,sp,12
81107a74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a78:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a80:	e0bfff17 	ldw	r2,-4(fp)
81107a84:	10001226 	beq	r2,zero,81107ad0 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a88:	e0bfff17 	ldw	r2,-4(fp)
81107a8c:	10800017 	ldw	r2,0(r2)
81107a90:	01400104 	movi	r5,4
81107a94:	1009883a 	mov	r4,r2
81107a98:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107a9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107aa0:	e0bffe17 	ldw	r2,-8(fp)
81107aa4:	1007883a 	mov	r3,r2
81107aa8:	e0bfff17 	ldw	r2,-4(fp)
81107aac:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107ab0:	e0bffe17 	ldw	r2,-8(fp)
81107ab4:	10bfc00c 	andi	r2,r2,65280
81107ab8:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107abc:	1007883a 	mov	r3,r2
81107ac0:	e0bfff17 	ldw	r2,-4(fp)
81107ac4:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107ac8:	00800044 	movi	r2,1
81107acc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107ad0:	e0bffd17 	ldw	r2,-12(fp)
}
81107ad4:	e037883a 	mov	sp,fp
81107ad8:	dfc00117 	ldw	ra,4(sp)
81107adc:	df000017 	ldw	fp,0(sp)
81107ae0:	dec00204 	addi	sp,sp,8
81107ae4:	f800283a 	ret

81107ae8 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107ae8:	defffb04 	addi	sp,sp,-20
81107aec:	de00012e 	bgeu	sp,et,81107af4 <bRmapGetCodecStatus+0xc>
81107af0:	003b68fa 	trap	3
81107af4:	dfc00415 	stw	ra,16(sp)
81107af8:	df000315 	stw	fp,12(sp)
81107afc:	df000304 	addi	fp,sp,12
81107b00:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107b04:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107b08:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107b0c:	e0bfff17 	ldw	r2,-4(fp)
81107b10:	10004726 	beq	r2,zero,81107c30 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b14:	e0bfff17 	ldw	r2,-4(fp)
81107b18:	10800017 	ldw	r2,0(r2)
81107b1c:	01400144 	movi	r5,5
81107b20:	1009883a 	mov	r4,r2
81107b24:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107b28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107b2c:	e0bffe17 	ldw	r2,-8(fp)
81107b30:	1080004c 	andi	r2,r2,1
81107b34:	10000426 	beq	r2,zero,81107b48 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107b38:	e0bfff17 	ldw	r2,-4(fp)
81107b3c:	00c00044 	movi	r3,1
81107b40:	10c00215 	stw	r3,8(r2)
81107b44:	00000206 	br	81107b50 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107b48:	e0bfff17 	ldw	r2,-4(fp)
81107b4c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107b50:	e0bffe17 	ldw	r2,-8(fp)
81107b54:	1080008c 	andi	r2,r2,2
81107b58:	10000426 	beq	r2,zero,81107b6c <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107b5c:	e0bfff17 	ldw	r2,-4(fp)
81107b60:	00c00044 	movi	r3,1
81107b64:	10c00315 	stw	r3,12(r2)
81107b68:	00000206 	br	81107b74 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107b6c:	e0bfff17 	ldw	r2,-4(fp)
81107b70:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107b74:	e0bffe17 	ldw	r2,-8(fp)
81107b78:	1080010c 	andi	r2,r2,4
81107b7c:	10000426 	beq	r2,zero,81107b90 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107b80:	e0bfff17 	ldw	r2,-4(fp)
81107b84:	00c00044 	movi	r3,1
81107b88:	10c00415 	stw	r3,16(r2)
81107b8c:	00000206 	br	81107b98 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107b90:	e0bfff17 	ldw	r2,-4(fp)
81107b94:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107b98:	e0bffe17 	ldw	r2,-8(fp)
81107b9c:	1080020c 	andi	r2,r2,8
81107ba0:	10000426 	beq	r2,zero,81107bb4 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107ba4:	e0bfff17 	ldw	r2,-4(fp)
81107ba8:	00c00044 	movi	r3,1
81107bac:	10c00515 	stw	r3,20(r2)
81107bb0:	00000206 	br	81107bbc <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107bb4:	e0bfff17 	ldw	r2,-4(fp)
81107bb8:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107bbc:	e0bffe17 	ldw	r2,-8(fp)
81107bc0:	1080040c 	andi	r2,r2,16
81107bc4:	10000426 	beq	r2,zero,81107bd8 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107bc8:	e0bfff17 	ldw	r2,-4(fp)
81107bcc:	00c00044 	movi	r3,1
81107bd0:	10c00615 	stw	r3,24(r2)
81107bd4:	00000206 	br	81107be0 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107bd8:	e0bfff17 	ldw	r2,-4(fp)
81107bdc:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107be0:	e0bffe17 	ldw	r2,-8(fp)
81107be4:	1080080c 	andi	r2,r2,32
81107be8:	10000426 	beq	r2,zero,81107bfc <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107bec:	e0bfff17 	ldw	r2,-4(fp)
81107bf0:	00c00044 	movi	r3,1
81107bf4:	10c00715 	stw	r3,28(r2)
81107bf8:	00000206 	br	81107c04 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107bfc:	e0bfff17 	ldw	r2,-4(fp)
81107c00:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107c04:	e0bffe17 	ldw	r2,-8(fp)
81107c08:	1080100c 	andi	r2,r2,64
81107c0c:	10000426 	beq	r2,zero,81107c20 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107c10:	e0bfff17 	ldw	r2,-4(fp)
81107c14:	00c00044 	movi	r3,1
81107c18:	10c00815 	stw	r3,32(r2)
81107c1c:	00000206 	br	81107c28 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107c20:	e0bfff17 	ldw	r2,-4(fp)
81107c24:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107c28:	00800044 	movi	r2,1
81107c2c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107c30:	e0bffd17 	ldw	r2,-12(fp)
}
81107c34:	e037883a 	mov	sp,fp
81107c38:	dfc00117 	ldw	ra,4(sp)
81107c3c:	df000017 	ldw	fp,0(sp)
81107c40:	dec00204 	addi	sp,sp,8
81107c44:	f800283a 	ret

81107c48 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107c48:	defffb04 	addi	sp,sp,-20
81107c4c:	de00012e 	bgeu	sp,et,81107c54 <bRmapGetCodecError+0xc>
81107c50:	003b68fa 	trap	3
81107c54:	dfc00415 	stw	ra,16(sp)
81107c58:	df000315 	stw	fp,12(sp)
81107c5c:	df000304 	addi	fp,sp,12
81107c60:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107c64:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107c68:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	10004726 	beq	r2,zero,81107d90 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c74:	e0bfff17 	ldw	r2,-4(fp)
81107c78:	10800017 	ldw	r2,0(r2)
81107c7c:	01400144 	movi	r5,5
81107c80:	1009883a 	mov	r4,r2
81107c84:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107c88:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107c8c:	e0bffe17 	ldw	r2,-8(fp)
81107c90:	1080006c 	andhi	r2,r2,1
81107c94:	10000426 	beq	r2,zero,81107ca8 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107c98:	e0bfff17 	ldw	r2,-4(fp)
81107c9c:	00c00044 	movi	r3,1
81107ca0:	10c00915 	stw	r3,36(r2)
81107ca4:	00000206 	br	81107cb0 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107ca8:	e0bfff17 	ldw	r2,-4(fp)
81107cac:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107cb0:	e0bffe17 	ldw	r2,-8(fp)
81107cb4:	108000ac 	andhi	r2,r2,2
81107cb8:	10000426 	beq	r2,zero,81107ccc <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107cbc:	e0bfff17 	ldw	r2,-4(fp)
81107cc0:	00c00044 	movi	r3,1
81107cc4:	10c00a15 	stw	r3,40(r2)
81107cc8:	00000206 	br	81107cd4 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107ccc:	e0bfff17 	ldw	r2,-4(fp)
81107cd0:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107cd4:	e0bffe17 	ldw	r2,-8(fp)
81107cd8:	1080012c 	andhi	r2,r2,4
81107cdc:	10000426 	beq	r2,zero,81107cf0 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107ce0:	e0bfff17 	ldw	r2,-4(fp)
81107ce4:	00c00044 	movi	r3,1
81107ce8:	10c00b15 	stw	r3,44(r2)
81107cec:	00000206 	br	81107cf8 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107cf0:	e0bfff17 	ldw	r2,-4(fp)
81107cf4:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107cf8:	e0bffe17 	ldw	r2,-8(fp)
81107cfc:	1080022c 	andhi	r2,r2,8
81107d00:	10000426 	beq	r2,zero,81107d14 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107d04:	e0bfff17 	ldw	r2,-4(fp)
81107d08:	00c00044 	movi	r3,1
81107d0c:	10c00c15 	stw	r3,48(r2)
81107d10:	00000206 	br	81107d1c <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107d14:	e0bfff17 	ldw	r2,-4(fp)
81107d18:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107d1c:	e0bffe17 	ldw	r2,-8(fp)
81107d20:	1080042c 	andhi	r2,r2,16
81107d24:	10000426 	beq	r2,zero,81107d38 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107d28:	e0bfff17 	ldw	r2,-4(fp)
81107d2c:	00c00044 	movi	r3,1
81107d30:	10c00d15 	stw	r3,52(r2)
81107d34:	00000206 	br	81107d40 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107d38:	e0bfff17 	ldw	r2,-4(fp)
81107d3c:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107d40:	e0bffe17 	ldw	r2,-8(fp)
81107d44:	1080082c 	andhi	r2,r2,32
81107d48:	10000426 	beq	r2,zero,81107d5c <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107d4c:	e0bfff17 	ldw	r2,-4(fp)
81107d50:	00c00044 	movi	r3,1
81107d54:	10c00e15 	stw	r3,56(r2)
81107d58:	00000206 	br	81107d64 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107d5c:	e0bfff17 	ldw	r2,-4(fp)
81107d60:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107d64:	e0bffe17 	ldw	r2,-8(fp)
81107d68:	1080102c 	andhi	r2,r2,64
81107d6c:	10000426 	beq	r2,zero,81107d80 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107d70:	e0bfff17 	ldw	r2,-4(fp)
81107d74:	00c00044 	movi	r3,1
81107d78:	10c00f15 	stw	r3,60(r2)
81107d7c:	00000206 	br	81107d88 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81107d80:	e0bfff17 	ldw	r2,-4(fp)
81107d84:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107d88:	00800044 	movi	r2,1
81107d8c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107d90:	e0bffd17 	ldw	r2,-12(fp)
}
81107d94:	e037883a 	mov	sp,fp
81107d98:	dfc00117 	ldw	ra,4(sp)
81107d9c:	df000017 	ldw	fp,0(sp)
81107da0:	dec00204 	addi	sp,sp,8
81107da4:	f800283a 	ret

81107da8 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107da8:	defffb04 	addi	sp,sp,-20
81107dac:	de00012e 	bgeu	sp,et,81107db4 <bRmapSetMemConfigArea+0xc>
81107db0:	003b68fa 	trap	3
81107db4:	dfc00415 	stw	ra,16(sp)
81107db8:	df000315 	stw	fp,12(sp)
81107dbc:	df000304 	addi	fp,sp,12
81107dc0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107dc4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107dc8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107dcc:	e0bfff17 	ldw	r2,-4(fp)
81107dd0:	1000aa26 	beq	r2,zero,8110807c <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107dd4:	e0bfff17 	ldw	r2,-4(fp)
81107dd8:	10801217 	ldw	r2,72(r2)
81107ddc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107de0:	e0bfff17 	ldw	r2,-4(fp)
81107de4:	10800017 	ldw	r2,0(r2)
81107de8:	e1bffe17 	ldw	r6,-8(fp)
81107dec:	01401004 	movi	r5,64
81107df0:	1009883a 	mov	r4,r2
81107df4:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107df8:	e0bfff17 	ldw	r2,-4(fp)
81107dfc:	10801317 	ldw	r2,76(r2)
81107e00:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e04:	e0bfff17 	ldw	r2,-4(fp)
81107e08:	10800017 	ldw	r2,0(r2)
81107e0c:	e1bffe17 	ldw	r6,-8(fp)
81107e10:	01401044 	movi	r5,65
81107e14:	1009883a 	mov	r4,r2
81107e18:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107e1c:	e0bfff17 	ldw	r2,-4(fp)
81107e20:	10801417 	ldw	r2,80(r2)
81107e24:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e28:	e0bfff17 	ldw	r2,-4(fp)
81107e2c:	10800017 	ldw	r2,0(r2)
81107e30:	e1bffe17 	ldw	r6,-8(fp)
81107e34:	01401084 	movi	r5,66
81107e38:	1009883a 	mov	r4,r2
81107e3c:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107e40:	e0bfff17 	ldw	r2,-4(fp)
81107e44:	10801517 	ldw	r2,84(r2)
81107e48:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e4c:	e0bfff17 	ldw	r2,-4(fp)
81107e50:	10800017 	ldw	r2,0(r2)
81107e54:	e1bffe17 	ldw	r6,-8(fp)
81107e58:	014010c4 	movi	r5,67
81107e5c:	1009883a 	mov	r4,r2
81107e60:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107e64:	e0bfff17 	ldw	r2,-4(fp)
81107e68:	10802217 	ldw	r2,136(r2)
81107e6c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e70:	e0bfff17 	ldw	r2,-4(fp)
81107e74:	10800017 	ldw	r2,0(r2)
81107e78:	e1bffe17 	ldw	r6,-8(fp)
81107e7c:	01401104 	movi	r5,68
81107e80:	1009883a 	mov	r4,r2
81107e84:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107e88:	e0bfff17 	ldw	r2,-4(fp)
81107e8c:	10801717 	ldw	r2,92(r2)
81107e90:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e94:	e0bfff17 	ldw	r2,-4(fp)
81107e98:	10800017 	ldw	r2,0(r2)
81107e9c:	e1bffe17 	ldw	r6,-8(fp)
81107ea0:	01401144 	movi	r5,69
81107ea4:	1009883a 	mov	r4,r2
81107ea8:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107eac:	e0bfff17 	ldw	r2,-4(fp)
81107eb0:	10801817 	ldw	r2,96(r2)
81107eb4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107eb8:	e0bfff17 	ldw	r2,-4(fp)
81107ebc:	10800017 	ldw	r2,0(r2)
81107ec0:	e1bffe17 	ldw	r6,-8(fp)
81107ec4:	01401184 	movi	r5,70
81107ec8:	1009883a 	mov	r4,r2
81107ecc:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107ed0:	e0bfff17 	ldw	r2,-4(fp)
81107ed4:	10801917 	ldw	r2,100(r2)
81107ed8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107edc:	e0bfff17 	ldw	r2,-4(fp)
81107ee0:	10800017 	ldw	r2,0(r2)
81107ee4:	e1bffe17 	ldw	r6,-8(fp)
81107ee8:	014011c4 	movi	r5,71
81107eec:	1009883a 	mov	r4,r2
81107ef0:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107ef4:	e0bfff17 	ldw	r2,-4(fp)
81107ef8:	10801a17 	ldw	r2,104(r2)
81107efc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f00:	e0bfff17 	ldw	r2,-4(fp)
81107f04:	10800017 	ldw	r2,0(r2)
81107f08:	e1bffe17 	ldw	r6,-8(fp)
81107f0c:	01401204 	movi	r5,72
81107f10:	1009883a 	mov	r4,r2
81107f14:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107f18:	e0bfff17 	ldw	r2,-4(fp)
81107f1c:	10801b17 	ldw	r2,108(r2)
81107f20:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f24:	e0bfff17 	ldw	r2,-4(fp)
81107f28:	10800017 	ldw	r2,0(r2)
81107f2c:	e1bffe17 	ldw	r6,-8(fp)
81107f30:	01401244 	movi	r5,73
81107f34:	1009883a 	mov	r4,r2
81107f38:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f3c:	e0bfff17 	ldw	r2,-4(fp)
81107f40:	10800017 	ldw	r2,0(r2)
81107f44:	01401284 	movi	r5,74
81107f48:	1009883a 	mov	r4,r2
81107f4c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107f50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81107f54:	e0bfff17 	ldw	r2,-4(fp)
81107f58:	10801c17 	ldw	r2,112(r2)
81107f5c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f60:	e0bfff17 	ldw	r2,-4(fp)
81107f64:	10800017 	ldw	r2,0(r2)
81107f68:	e1bffe17 	ldw	r6,-8(fp)
81107f6c:	01401284 	movi	r5,74
81107f70:	1009883a 	mov	r4,r2
81107f74:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107f78:	e0bfff17 	ldw	r2,-4(fp)
81107f7c:	10801d17 	ldw	r2,116(r2)
81107f80:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f84:	e0bfff17 	ldw	r2,-4(fp)
81107f88:	10800017 	ldw	r2,0(r2)
81107f8c:	e1bffe17 	ldw	r6,-8(fp)
81107f90:	014012c4 	movi	r5,75
81107f94:	1009883a 	mov	r4,r2
81107f98:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81107f9c:	e0bfff17 	ldw	r2,-4(fp)
81107fa0:	10801e17 	ldw	r2,120(r2)
81107fa4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107fa8:	e0bfff17 	ldw	r2,-4(fp)
81107fac:	10800017 	ldw	r2,0(r2)
81107fb0:	e1bffe17 	ldw	r6,-8(fp)
81107fb4:	01401304 	movi	r5,76
81107fb8:	1009883a 	mov	r4,r2
81107fbc:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81107fc0:	e0bfff17 	ldw	r2,-4(fp)
81107fc4:	10801f17 	ldw	r2,124(r2)
81107fc8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81107fcc:	e0bfff17 	ldw	r2,-4(fp)
81107fd0:	10800017 	ldw	r2,0(r2)
81107fd4:	e1bffe17 	ldw	r6,-8(fp)
81107fd8:	01401344 	movi	r5,77
81107fdc:	1009883a 	mov	r4,r2
81107fe0:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81107fe4:	e0bfff17 	ldw	r2,-4(fp)
81107fe8:	10802017 	ldw	r2,128(r2)
81107fec:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81107ff0:	e0bfff17 	ldw	r2,-4(fp)
81107ff4:	10800017 	ldw	r2,0(r2)
81107ff8:	e1bffe17 	ldw	r6,-8(fp)
81107ffc:	01401384 	movi	r5,78
81108000:	1009883a 	mov	r4,r2
81108004:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81108008:	e0bfff17 	ldw	r2,-4(fp)
8110800c:	10802217 	ldw	r2,136(r2)
81108010:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108014:	e0bfff17 	ldw	r2,-4(fp)
81108018:	10800017 	ldw	r2,0(r2)
8110801c:	e1bffe17 	ldw	r6,-8(fp)
81108020:	014013c4 	movi	r5,79
81108024:	1009883a 	mov	r4,r2
81108028:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
8110802c:	e0bfff17 	ldw	r2,-4(fp)
81108030:	10802217 	ldw	r2,136(r2)
81108034:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81108038:	e0bfff17 	ldw	r2,-4(fp)
8110803c:	10800017 	ldw	r2,0(r2)
81108040:	e1bffe17 	ldw	r6,-8(fp)
81108044:	01401404 	movi	r5,80
81108048:	1009883a 	mov	r4,r2
8110804c:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81108050:	e0bfff17 	ldw	r2,-4(fp)
81108054:	10802317 	ldw	r2,140(r2)
81108058:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
8110805c:	e0bfff17 	ldw	r2,-4(fp)
81108060:	10800017 	ldw	r2,0(r2)
81108064:	e1bffe17 	ldw	r6,-8(fp)
81108068:	01401444 	movi	r5,81
8110806c:	1009883a 	mov	r4,r2
81108070:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108074:	00800044 	movi	r2,1
81108078:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110807c:	e0bffd17 	ldw	r2,-12(fp)
}
81108080:	e037883a 	mov	sp,fp
81108084:	dfc00117 	ldw	ra,4(sp)
81108088:	df000017 	ldw	fp,0(sp)
8110808c:	dec00204 	addi	sp,sp,8
81108090:	f800283a 	ret

81108094 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108094:	defffb04 	addi	sp,sp,-20
81108098:	de00012e 	bgeu	sp,et,811080a0 <bRmapGetMemConfigArea+0xc>
8110809c:	003b68fa 	trap	3
811080a0:	dfc00415 	stw	ra,16(sp)
811080a4:	df000315 	stw	fp,12(sp)
811080a8:	df000304 	addi	fp,sp,12
811080ac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811080b0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811080b4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	1000a426 	beq	r2,zero,81108350 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080c0:	e0bfff17 	ldw	r2,-4(fp)
811080c4:	10800017 	ldw	r2,0(r2)
811080c8:	01401004 	movi	r5,64
811080cc:	1009883a 	mov	r4,r2
811080d0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811080d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811080d8:	e0bfff17 	ldw	r2,-4(fp)
811080dc:	e0fffe17 	ldw	r3,-8(fp)
811080e0:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080e4:	e0bfff17 	ldw	r2,-4(fp)
811080e8:	10800017 	ldw	r2,0(r2)
811080ec:	01401044 	movi	r5,65
811080f0:	1009883a 	mov	r4,r2
811080f4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811080f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811080fc:	e0bfff17 	ldw	r2,-4(fp)
81108100:	e0fffe17 	ldw	r3,-8(fp)
81108104:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108108:	e0bfff17 	ldw	r2,-4(fp)
8110810c:	10800017 	ldw	r2,0(r2)
81108110:	01401084 	movi	r5,66
81108114:	1009883a 	mov	r4,r2
81108118:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110811c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81108120:	e0bfff17 	ldw	r2,-4(fp)
81108124:	e0fffe17 	ldw	r3,-8(fp)
81108128:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110812c:	e0bfff17 	ldw	r2,-4(fp)
81108130:	10800017 	ldw	r2,0(r2)
81108134:	014010c4 	movi	r5,67
81108138:	1009883a 	mov	r4,r2
8110813c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108140:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81108144:	e0bfff17 	ldw	r2,-4(fp)
81108148:	e0fffe17 	ldw	r3,-8(fp)
8110814c:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108150:	e0bfff17 	ldw	r2,-4(fp)
81108154:	10800017 	ldw	r2,0(r2)
81108158:	01401104 	movi	r5,68
8110815c:	1009883a 	mov	r4,r2
81108160:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108164:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108168:	e0bfff17 	ldw	r2,-4(fp)
8110816c:	e0fffe17 	ldw	r3,-8(fp)
81108170:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108174:	e0bfff17 	ldw	r2,-4(fp)
81108178:	10800017 	ldw	r2,0(r2)
8110817c:	01401144 	movi	r5,69
81108180:	1009883a 	mov	r4,r2
81108184:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108188:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
8110818c:	e0bfff17 	ldw	r2,-4(fp)
81108190:	e0fffe17 	ldw	r3,-8(fp)
81108194:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108198:	e0bfff17 	ldw	r2,-4(fp)
8110819c:	10800017 	ldw	r2,0(r2)
811081a0:	01401184 	movi	r5,70
811081a4:	1009883a 	mov	r4,r2
811081a8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811081ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
811081b0:	e0bfff17 	ldw	r2,-4(fp)
811081b4:	e0fffe17 	ldw	r3,-8(fp)
811081b8:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081bc:	e0bfff17 	ldw	r2,-4(fp)
811081c0:	10800017 	ldw	r2,0(r2)
811081c4:	014011c4 	movi	r5,71
811081c8:	1009883a 	mov	r4,r2
811081cc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811081d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811081d4:	e0bfff17 	ldw	r2,-4(fp)
811081d8:	e0fffe17 	ldw	r3,-8(fp)
811081dc:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081e0:	e0bfff17 	ldw	r2,-4(fp)
811081e4:	10800017 	ldw	r2,0(r2)
811081e8:	01401204 	movi	r5,72
811081ec:	1009883a 	mov	r4,r2
811081f0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811081f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811081f8:	e0bfff17 	ldw	r2,-4(fp)
811081fc:	e0fffe17 	ldw	r3,-8(fp)
81108200:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108204:	e0bfff17 	ldw	r2,-4(fp)
81108208:	10800017 	ldw	r2,0(r2)
8110820c:	01401244 	movi	r5,73
81108210:	1009883a 	mov	r4,r2
81108214:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108218:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
8110821c:	e0bfff17 	ldw	r2,-4(fp)
81108220:	e0fffe17 	ldw	r3,-8(fp)
81108224:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108228:	e0bfff17 	ldw	r2,-4(fp)
8110822c:	10800017 	ldw	r2,0(r2)
81108230:	01401284 	movi	r5,74
81108234:	1009883a 	mov	r4,r2
81108238:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110823c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81108240:	e0bfff17 	ldw	r2,-4(fp)
81108244:	e0fffe17 	ldw	r3,-8(fp)
81108248:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110824c:	e0bfff17 	ldw	r2,-4(fp)
81108250:	10800017 	ldw	r2,0(r2)
81108254:	014012c4 	movi	r5,75
81108258:	1009883a 	mov	r4,r2
8110825c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108260:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108264:	e0bfff17 	ldw	r2,-4(fp)
81108268:	e0fffe17 	ldw	r3,-8(fp)
8110826c:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108270:	e0bfff17 	ldw	r2,-4(fp)
81108274:	10800017 	ldw	r2,0(r2)
81108278:	01401304 	movi	r5,76
8110827c:	1009883a 	mov	r4,r2
81108280:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108284:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81108288:	e0bfff17 	ldw	r2,-4(fp)
8110828c:	e0fffe17 	ldw	r3,-8(fp)
81108290:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108294:	e0bfff17 	ldw	r2,-4(fp)
81108298:	10800017 	ldw	r2,0(r2)
8110829c:	01401344 	movi	r5,77
811082a0:	1009883a 	mov	r4,r2
811082a4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811082a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
811082ac:	e0bfff17 	ldw	r2,-4(fp)
811082b0:	e0fffe17 	ldw	r3,-8(fp)
811082b4:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082b8:	e0bfff17 	ldw	r2,-4(fp)
811082bc:	10800017 	ldw	r2,0(r2)
811082c0:	01401384 	movi	r5,78
811082c4:	1009883a 	mov	r4,r2
811082c8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811082cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
811082d0:	e0bfff17 	ldw	r2,-4(fp)
811082d4:	e0fffe17 	ldw	r3,-8(fp)
811082d8:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082dc:	e0bfff17 	ldw	r2,-4(fp)
811082e0:	10800017 	ldw	r2,0(r2)
811082e4:	014013c4 	movi	r5,79
811082e8:	1009883a 	mov	r4,r2
811082ec:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811082f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811082f4:	e0bfff17 	ldw	r2,-4(fp)
811082f8:	e0fffe17 	ldw	r3,-8(fp)
811082fc:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108300:	e0bfff17 	ldw	r2,-4(fp)
81108304:	10800017 	ldw	r2,0(r2)
81108308:	01401404 	movi	r5,80
8110830c:	1009883a 	mov	r4,r2
81108310:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108314:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108318:	e0bfff17 	ldw	r2,-4(fp)
8110831c:	e0fffe17 	ldw	r3,-8(fp)
81108320:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108324:	e0bfff17 	ldw	r2,-4(fp)
81108328:	10800017 	ldw	r2,0(r2)
8110832c:	01401444 	movi	r5,81
81108330:	1009883a 	mov	r4,r2
81108334:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108338:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
8110833c:	e0bfff17 	ldw	r2,-4(fp)
81108340:	e0fffe17 	ldw	r3,-8(fp)
81108344:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81108348:	00800044 	movi	r2,1
8110834c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108350:	e0bffd17 	ldw	r2,-12(fp)
}
81108354:	e037883a 	mov	sp,fp
81108358:	dfc00117 	ldw	ra,4(sp)
8110835c:	df000017 	ldw	fp,0(sp)
81108360:	dec00204 	addi	sp,sp,8
81108364:	f800283a 	ret

81108368 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81108368:	defffb04 	addi	sp,sp,-20
8110836c:	de00012e 	bgeu	sp,et,81108374 <bRmapGetMemConfigStat+0xc>
81108370:	003b68fa 	trap	3
81108374:	dfc00415 	stw	ra,16(sp)
81108378:	df000315 	stw	fp,12(sp)
8110837c:	df000304 	addi	fp,sp,12
81108380:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108384:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108388:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110838c:	e0bfff17 	ldw	r2,-4(fp)
81108390:	10001426 	beq	r2,zero,811083e4 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108394:	e0bfff17 	ldw	r2,-4(fp)
81108398:	10800017 	ldw	r2,0(r2)
8110839c:	014001c4 	movi	r5,7
811083a0:	1009883a 	mov	r4,r2
811083a4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811083a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
811083ac:	e0bfff17 	ldw	r2,-4(fp)
811083b0:	e0fffe17 	ldw	r3,-8(fp)
811083b4:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083b8:	e0bfff17 	ldw	r2,-4(fp)
811083bc:	10800017 	ldw	r2,0(r2)
811083c0:	01400184 	movi	r5,6
811083c4:	1009883a 	mov	r4,r2
811083c8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811083cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
811083d0:	e0bfff17 	ldw	r2,-4(fp)
811083d4:	e0fffe17 	ldw	r3,-8(fp)
811083d8:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811083dc:	00800044 	movi	r2,1
811083e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811083e4:	e0bffd17 	ldw	r2,-12(fp)
}
811083e8:	e037883a 	mov	sp,fp
811083ec:	dfc00117 	ldw	ra,4(sp)
811083f0:	df000017 	ldw	fp,0(sp)
811083f4:	dec00204 	addi	sp,sp,8
811083f8:	f800283a 	ret

811083fc <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811083fc:	defffb04 	addi	sp,sp,-20
81108400:	de00012e 	bgeu	sp,et,81108408 <bRmapSetRmapMemHKArea+0xc>
81108404:	003b68fa 	trap	3
81108408:	dfc00415 	stw	ra,16(sp)
8110840c:	df000315 	stw	fp,12(sp)
81108410:	df000304 	addi	fp,sp,12
81108414:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108418:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110841c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108420:	e0bfff17 	ldw	r2,-4(fp)
81108424:	10040226 	beq	r2,zero,81109430 <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108428:	e0bfff17 	ldw	r2,-4(fp)
8110842c:	10800017 	ldw	r2,0(r2)
81108430:	01402804 	movi	r5,160
81108434:	1009883a 	mov	r4,r2
81108438:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110843c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81108440:	e0bffe17 	ldw	r2,-8(fp)
81108444:	10bfffec 	andhi	r2,r2,65535
81108448:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
8110844c:	e0bfff17 	ldw	r2,-4(fp)
81108450:	1080260b 	ldhu	r2,152(r2)
81108454:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108458:	e0fffe17 	ldw	r3,-8(fp)
8110845c:	1884b03a 	or	r2,r3,r2
81108460:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108464:	e0bffe17 	ldw	r2,-8(fp)
81108468:	10bfffcc 	andi	r2,r2,65535
8110846c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108470:	e0bfff17 	ldw	r2,-4(fp)
81108474:	1080268b 	ldhu	r2,154(r2)
81108478:	10bfffcc 	andi	r2,r2,65535
8110847c:	1004943a 	slli	r2,r2,16
81108480:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108484:	e0bffe17 	ldw	r2,-8(fp)
81108488:	10c4b03a 	or	r2,r2,r3
8110848c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108490:	e0bfff17 	ldw	r2,-4(fp)
81108494:	10800017 	ldw	r2,0(r2)
81108498:	e1bffe17 	ldw	r6,-8(fp)
8110849c:	01402804 	movi	r5,160
811084a0:	1009883a 	mov	r4,r2
811084a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084a8:	e0bfff17 	ldw	r2,-4(fp)
811084ac:	10800017 	ldw	r2,0(r2)
811084b0:	01402844 	movi	r5,161
811084b4:	1009883a 	mov	r4,r2
811084b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811084bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811084c0:	e0bffe17 	ldw	r2,-8(fp)
811084c4:	10bfffec 	andhi	r2,r2,65535
811084c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
811084cc:	e0bfff17 	ldw	r2,-4(fp)
811084d0:	1080270b 	ldhu	r2,156(r2)
811084d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811084d8:	e0fffe17 	ldw	r3,-8(fp)
811084dc:	1884b03a 	or	r2,r3,r2
811084e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811084e4:	e0bffe17 	ldw	r2,-8(fp)
811084e8:	10bfffcc 	andi	r2,r2,65535
811084ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
811084f0:	e0bfff17 	ldw	r2,-4(fp)
811084f4:	1080278b 	ldhu	r2,158(r2)
811084f8:	10bfffcc 	andi	r2,r2,65535
811084fc:	1004943a 	slli	r2,r2,16
81108500:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
81108504:	e0bffe17 	ldw	r2,-8(fp)
81108508:	10c4b03a 	or	r2,r2,r3
8110850c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81108510:	e0bfff17 	ldw	r2,-4(fp)
81108514:	10800017 	ldw	r2,0(r2)
81108518:	e1bffe17 	ldw	r6,-8(fp)
8110851c:	01402844 	movi	r5,161
81108520:	1009883a 	mov	r4,r2
81108524:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108528:	e0bfff17 	ldw	r2,-4(fp)
8110852c:	10800017 	ldw	r2,0(r2)
81108530:	01402884 	movi	r5,162
81108534:	1009883a 	mov	r4,r2
81108538:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110853c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108540:	e0bffe17 	ldw	r2,-8(fp)
81108544:	10bfffec 	andhi	r2,r2,65535
81108548:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
8110854c:	e0bfff17 	ldw	r2,-4(fp)
81108550:	1080280b 	ldhu	r2,160(r2)
81108554:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108558:	e0fffe17 	ldw	r3,-8(fp)
8110855c:	1884b03a 	or	r2,r3,r2
81108560:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108564:	e0bffe17 	ldw	r2,-8(fp)
81108568:	10bfffcc 	andi	r2,r2,65535
8110856c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108570:	e0bfff17 	ldw	r2,-4(fp)
81108574:	1080288b 	ldhu	r2,162(r2)
81108578:	10bfffcc 	andi	r2,r2,65535
8110857c:	1004943a 	slli	r2,r2,16
81108580:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108584:	e0bffe17 	ldw	r2,-8(fp)
81108588:	10c4b03a 	or	r2,r2,r3
8110858c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108590:	e0bfff17 	ldw	r2,-4(fp)
81108594:	10800017 	ldw	r2,0(r2)
81108598:	e1bffe17 	ldw	r6,-8(fp)
8110859c:	01402884 	movi	r5,162
811085a0:	1009883a 	mov	r4,r2
811085a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085a8:	e0bfff17 	ldw	r2,-4(fp)
811085ac:	10800017 	ldw	r2,0(r2)
811085b0:	014028c4 	movi	r5,163
811085b4:	1009883a 	mov	r4,r2
811085b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811085bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
811085c0:	e0bffe17 	ldw	r2,-8(fp)
811085c4:	10bfffec 	andhi	r2,r2,65535
811085c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
811085cc:	e0bfff17 	ldw	r2,-4(fp)
811085d0:	1080290b 	ldhu	r2,164(r2)
811085d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811085d8:	e0fffe17 	ldw	r3,-8(fp)
811085dc:	1884b03a 	or	r2,r3,r2
811085e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811085e4:	e0bffe17 	ldw	r2,-8(fp)
811085e8:	10bfffcc 	andi	r2,r2,65535
811085ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	1080298b 	ldhu	r2,166(r2)
811085f8:	10bfffcc 	andi	r2,r2,65535
811085fc:	1004943a 	slli	r2,r2,16
81108600:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
81108604:	e0bffe17 	ldw	r2,-8(fp)
81108608:	10c4b03a 	or	r2,r2,r3
8110860c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81108610:	e0bfff17 	ldw	r2,-4(fp)
81108614:	10800017 	ldw	r2,0(r2)
81108618:	e1bffe17 	ldw	r6,-8(fp)
8110861c:	014028c4 	movi	r5,163
81108620:	1009883a 	mov	r4,r2
81108624:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108628:	e0bfff17 	ldw	r2,-4(fp)
8110862c:	10800017 	ldw	r2,0(r2)
81108630:	01402904 	movi	r5,164
81108634:	1009883a 	mov	r4,r2
81108638:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110863c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108640:	e0bffe17 	ldw	r2,-8(fp)
81108644:	10bfffec 	andhi	r2,r2,65535
81108648:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
8110864c:	e0bfff17 	ldw	r2,-4(fp)
81108650:	10802a0b 	ldhu	r2,168(r2)
81108654:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108658:	e0fffe17 	ldw	r3,-8(fp)
8110865c:	1884b03a 	or	r2,r3,r2
81108660:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108664:	e0bffe17 	ldw	r2,-8(fp)
81108668:	10bfffcc 	andi	r2,r2,65535
8110866c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108670:	e0bfff17 	ldw	r2,-4(fp)
81108674:	10802a8b 	ldhu	r2,170(r2)
81108678:	10bfffcc 	andi	r2,r2,65535
8110867c:	1004943a 	slli	r2,r2,16
81108680:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81108684:	e0bffe17 	ldw	r2,-8(fp)
81108688:	10c4b03a 	or	r2,r2,r3
8110868c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108690:	e0bfff17 	ldw	r2,-4(fp)
81108694:	10800017 	ldw	r2,0(r2)
81108698:	e1bffe17 	ldw	r6,-8(fp)
8110869c:	01402904 	movi	r5,164
811086a0:	1009883a 	mov	r4,r2
811086a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086a8:	e0bfff17 	ldw	r2,-4(fp)
811086ac:	10800017 	ldw	r2,0(r2)
811086b0:	01402944 	movi	r5,165
811086b4:	1009883a 	mov	r4,r2
811086b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811086bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
811086c0:	e0bffe17 	ldw	r2,-8(fp)
811086c4:	10bfffec 	andhi	r2,r2,65535
811086c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
811086cc:	e0bfff17 	ldw	r2,-4(fp)
811086d0:	10802b0b 	ldhu	r2,172(r2)
811086d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811086d8:	e0fffe17 	ldw	r3,-8(fp)
811086dc:	1884b03a 	or	r2,r3,r2
811086e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811086e4:	e0bffe17 	ldw	r2,-8(fp)
811086e8:	10bfffcc 	andi	r2,r2,65535
811086ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
811086f0:	e0bfff17 	ldw	r2,-4(fp)
811086f4:	10802b8b 	ldhu	r2,174(r2)
811086f8:	10bfffcc 	andi	r2,r2,65535
811086fc:	1004943a 	slli	r2,r2,16
81108700:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
81108704:	e0bffe17 	ldw	r2,-8(fp)
81108708:	10c4b03a 	or	r2,r2,r3
8110870c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81108710:	e0bfff17 	ldw	r2,-4(fp)
81108714:	10800017 	ldw	r2,0(r2)
81108718:	e1bffe17 	ldw	r6,-8(fp)
8110871c:	01402944 	movi	r5,165
81108720:	1009883a 	mov	r4,r2
81108724:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108728:	e0bfff17 	ldw	r2,-4(fp)
8110872c:	10800017 	ldw	r2,0(r2)
81108730:	01402984 	movi	r5,166
81108734:	1009883a 	mov	r4,r2
81108738:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110873c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81108740:	e0bffe17 	ldw	r2,-8(fp)
81108744:	10bfffec 	andhi	r2,r2,65535
81108748:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
8110874c:	e0bfff17 	ldw	r2,-4(fp)
81108750:	10802c0b 	ldhu	r2,176(r2)
81108754:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108758:	e0fffe17 	ldw	r3,-8(fp)
8110875c:	1884b03a 	or	r2,r3,r2
81108760:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108764:	e0bffe17 	ldw	r2,-8(fp)
81108768:	10bfffcc 	andi	r2,r2,65535
8110876c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81108770:	e0bfff17 	ldw	r2,-4(fp)
81108774:	10802c8b 	ldhu	r2,178(r2)
81108778:	10bfffcc 	andi	r2,r2,65535
8110877c:	1004943a 	slli	r2,r2,16
81108780:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81108784:	e0bffe17 	ldw	r2,-8(fp)
81108788:	10c4b03a 	or	r2,r2,r3
8110878c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108790:	e0bfff17 	ldw	r2,-4(fp)
81108794:	10800017 	ldw	r2,0(r2)
81108798:	e1bffe17 	ldw	r6,-8(fp)
8110879c:	01402984 	movi	r5,166
811087a0:	1009883a 	mov	r4,r2
811087a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087a8:	e0bfff17 	ldw	r2,-4(fp)
811087ac:	10800017 	ldw	r2,0(r2)
811087b0:	014029c4 	movi	r5,167
811087b4:	1009883a 	mov	r4,r2
811087b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811087bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
811087c0:	e0bffe17 	ldw	r2,-8(fp)
811087c4:	10bfffec 	andhi	r2,r2,65535
811087c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
811087cc:	e0bfff17 	ldw	r2,-4(fp)
811087d0:	10802d0b 	ldhu	r2,180(r2)
811087d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811087d8:	e0fffe17 	ldw	r3,-8(fp)
811087dc:	1884b03a 	or	r2,r3,r2
811087e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811087e4:	e0bffe17 	ldw	r2,-8(fp)
811087e8:	10bfffcc 	andi	r2,r2,65535
811087ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
811087f0:	e0bfff17 	ldw	r2,-4(fp)
811087f4:	10802d8b 	ldhu	r2,182(r2)
811087f8:	10bfffcc 	andi	r2,r2,65535
811087fc:	1004943a 	slli	r2,r2,16
81108800:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81108804:	e0bffe17 	ldw	r2,-8(fp)
81108808:	10c4b03a 	or	r2,r2,r3
8110880c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81108810:	e0bfff17 	ldw	r2,-4(fp)
81108814:	10800017 	ldw	r2,0(r2)
81108818:	e1bffe17 	ldw	r6,-8(fp)
8110881c:	014029c4 	movi	r5,167
81108820:	1009883a 	mov	r4,r2
81108824:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108828:	e0bfff17 	ldw	r2,-4(fp)
8110882c:	10800017 	ldw	r2,0(r2)
81108830:	01402a04 	movi	r5,168
81108834:	1009883a 	mov	r4,r2
81108838:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110883c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108840:	e0bffe17 	ldw	r2,-8(fp)
81108844:	10bfffec 	andhi	r2,r2,65535
81108848:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
8110884c:	e0bfff17 	ldw	r2,-4(fp)
81108850:	10802e0b 	ldhu	r2,184(r2)
81108854:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108858:	e0fffe17 	ldw	r3,-8(fp)
8110885c:	1884b03a 	or	r2,r3,r2
81108860:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108864:	e0bffe17 	ldw	r2,-8(fp)
81108868:	10bfffcc 	andi	r2,r2,65535
8110886c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81108870:	e0bfff17 	ldw	r2,-4(fp)
81108874:	10802e8b 	ldhu	r2,186(r2)
81108878:	10bfffcc 	andi	r2,r2,65535
8110887c:	1004943a 	slli	r2,r2,16
81108880:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81108884:	e0bffe17 	ldw	r2,-8(fp)
81108888:	10c4b03a 	or	r2,r2,r3
8110888c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108890:	e0bfff17 	ldw	r2,-4(fp)
81108894:	10800017 	ldw	r2,0(r2)
81108898:	e1bffe17 	ldw	r6,-8(fp)
8110889c:	01402a04 	movi	r5,168
811088a0:	1009883a 	mov	r4,r2
811088a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088a8:	e0bfff17 	ldw	r2,-4(fp)
811088ac:	10800017 	ldw	r2,0(r2)
811088b0:	01402a44 	movi	r5,169
811088b4:	1009883a 	mov	r4,r2
811088b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811088bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
811088c0:	e0bffe17 	ldw	r2,-8(fp)
811088c4:	10bfffec 	andhi	r2,r2,65535
811088c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
811088cc:	e0bfff17 	ldw	r2,-4(fp)
811088d0:	10802f0b 	ldhu	r2,188(r2)
811088d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811088d8:	e0fffe17 	ldw	r3,-8(fp)
811088dc:	1884b03a 	or	r2,r3,r2
811088e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811088e4:	e0bffe17 	ldw	r2,-8(fp)
811088e8:	10bfffcc 	andi	r2,r2,65535
811088ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
811088f0:	e0bfff17 	ldw	r2,-4(fp)
811088f4:	10802f8b 	ldhu	r2,190(r2)
811088f8:	10bfffcc 	andi	r2,r2,65535
811088fc:	1004943a 	slli	r2,r2,16
81108900:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
81108904:	e0bffe17 	ldw	r2,-8(fp)
81108908:	10c4b03a 	or	r2,r2,r3
8110890c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81108910:	e0bfff17 	ldw	r2,-4(fp)
81108914:	10800017 	ldw	r2,0(r2)
81108918:	e1bffe17 	ldw	r6,-8(fp)
8110891c:	01402a44 	movi	r5,169
81108920:	1009883a 	mov	r4,r2
81108924:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108928:	e0bfff17 	ldw	r2,-4(fp)
8110892c:	10800017 	ldw	r2,0(r2)
81108930:	01402a84 	movi	r5,170
81108934:	1009883a 	mov	r4,r2
81108938:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110893c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108940:	e0bffe17 	ldw	r2,-8(fp)
81108944:	10bfffec 	andhi	r2,r2,65535
81108948:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
8110894c:	e0bfff17 	ldw	r2,-4(fp)
81108950:	1080300b 	ldhu	r2,192(r2)
81108954:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108958:	e0fffe17 	ldw	r3,-8(fp)
8110895c:	1884b03a 	or	r2,r3,r2
81108960:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108964:	e0bffe17 	ldw	r2,-8(fp)
81108968:	10bfffcc 	andi	r2,r2,65535
8110896c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108970:	e0bfff17 	ldw	r2,-4(fp)
81108974:	1080308b 	ldhu	r2,194(r2)
81108978:	10bfffcc 	andi	r2,r2,65535
8110897c:	1004943a 	slli	r2,r2,16
81108980:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108984:	e0bffe17 	ldw	r2,-8(fp)
81108988:	10c4b03a 	or	r2,r2,r3
8110898c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108990:	e0bfff17 	ldw	r2,-4(fp)
81108994:	10800017 	ldw	r2,0(r2)
81108998:	e1bffe17 	ldw	r6,-8(fp)
8110899c:	01402a84 	movi	r5,170
811089a0:	1009883a 	mov	r4,r2
811089a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089a8:	e0bfff17 	ldw	r2,-4(fp)
811089ac:	10800017 	ldw	r2,0(r2)
811089b0:	01402ac4 	movi	r5,171
811089b4:	1009883a 	mov	r4,r2
811089b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811089bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
811089c0:	e0bffe17 	ldw	r2,-8(fp)
811089c4:	10bfffec 	andhi	r2,r2,65535
811089c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
811089cc:	e0bfff17 	ldw	r2,-4(fp)
811089d0:	1080310b 	ldhu	r2,196(r2)
811089d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
811089d8:	e0fffe17 	ldw	r3,-8(fp)
811089dc:	1884b03a 	or	r2,r3,r2
811089e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
811089e4:	e0bffe17 	ldw	r2,-8(fp)
811089e8:	10bfffcc 	andi	r2,r2,65535
811089ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
811089f0:	e0bfff17 	ldw	r2,-4(fp)
811089f4:	1080318b 	ldhu	r2,198(r2)
811089f8:	10bfffcc 	andi	r2,r2,65535
811089fc:	1004943a 	slli	r2,r2,16
81108a00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108a04:	e0bffe17 	ldw	r2,-8(fp)
81108a08:	10c4b03a 	or	r2,r2,r3
81108a0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108a10:	e0bfff17 	ldw	r2,-4(fp)
81108a14:	10800017 	ldw	r2,0(r2)
81108a18:	e1bffe17 	ldw	r6,-8(fp)
81108a1c:	01402ac4 	movi	r5,171
81108a20:	1009883a 	mov	r4,r2
81108a24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a28:	e0bfff17 	ldw	r2,-4(fp)
81108a2c:	10800017 	ldw	r2,0(r2)
81108a30:	01402b04 	movi	r5,172
81108a34:	1009883a 	mov	r4,r2
81108a38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108a3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108a40:	e0bffe17 	ldw	r2,-8(fp)
81108a44:	10bfffec 	andhi	r2,r2,65535
81108a48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81108a4c:	e0bfff17 	ldw	r2,-4(fp)
81108a50:	1080320b 	ldhu	r2,200(r2)
81108a54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108a58:	e0fffe17 	ldw	r3,-8(fp)
81108a5c:	1884b03a 	or	r2,r3,r2
81108a60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108a64:	e0bffe17 	ldw	r2,-8(fp)
81108a68:	10bfffcc 	andi	r2,r2,65535
81108a6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81108a70:	e0bfff17 	ldw	r2,-4(fp)
81108a74:	1080328b 	ldhu	r2,202(r2)
81108a78:	10bfffcc 	andi	r2,r2,65535
81108a7c:	1004943a 	slli	r2,r2,16
81108a80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81108a84:	e0bffe17 	ldw	r2,-8(fp)
81108a88:	10c4b03a 	or	r2,r2,r3
81108a8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108a90:	e0bfff17 	ldw	r2,-4(fp)
81108a94:	10800017 	ldw	r2,0(r2)
81108a98:	e1bffe17 	ldw	r6,-8(fp)
81108a9c:	01402b04 	movi	r5,172
81108aa0:	1009883a 	mov	r4,r2
81108aa4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aa8:	e0bfff17 	ldw	r2,-4(fp)
81108aac:	10800017 	ldw	r2,0(r2)
81108ab0:	01402b44 	movi	r5,173
81108ab4:	1009883a 	mov	r4,r2
81108ab8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108abc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108ac0:	e0bffe17 	ldw	r2,-8(fp)
81108ac4:	10bfffec 	andhi	r2,r2,65535
81108ac8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108acc:	e0bfff17 	ldw	r2,-4(fp)
81108ad0:	1080330b 	ldhu	r2,204(r2)
81108ad4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108ad8:	e0fffe17 	ldw	r3,-8(fp)
81108adc:	1884b03a 	or	r2,r3,r2
81108ae0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81108ae4:	e0bffe17 	ldw	r2,-8(fp)
81108ae8:	10bfffcc 	andi	r2,r2,65535
81108aec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81108af0:	e0bfff17 	ldw	r2,-4(fp)
81108af4:	1080338b 	ldhu	r2,206(r2)
81108af8:	10bfffcc 	andi	r2,r2,65535
81108afc:	1004943a 	slli	r2,r2,16
81108b00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81108b04:	e0bffe17 	ldw	r2,-8(fp)
81108b08:	10c4b03a 	or	r2,r2,r3
81108b0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108b10:	e0bfff17 	ldw	r2,-4(fp)
81108b14:	10800017 	ldw	r2,0(r2)
81108b18:	e1bffe17 	ldw	r6,-8(fp)
81108b1c:	01402b44 	movi	r5,173
81108b20:	1009883a 	mov	r4,r2
81108b24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b28:	e0bfff17 	ldw	r2,-4(fp)
81108b2c:	10800017 	ldw	r2,0(r2)
81108b30:	01402b84 	movi	r5,174
81108b34:	1009883a 	mov	r4,r2
81108b38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108b3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108b40:	e0bffe17 	ldw	r2,-8(fp)
81108b44:	10bfffec 	andhi	r2,r2,65535
81108b48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81108b4c:	e0bfff17 	ldw	r2,-4(fp)
81108b50:	1080340b 	ldhu	r2,208(r2)
81108b54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108b58:	e0fffe17 	ldw	r3,-8(fp)
81108b5c:	1884b03a 	or	r2,r3,r2
81108b60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108b64:	e0bffe17 	ldw	r2,-8(fp)
81108b68:	10bfffcc 	andi	r2,r2,65535
81108b6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81108b70:	e0bfff17 	ldw	r2,-4(fp)
81108b74:	1080348b 	ldhu	r2,210(r2)
81108b78:	10bfffcc 	andi	r2,r2,65535
81108b7c:	1004943a 	slli	r2,r2,16
81108b80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81108b84:	e0bffe17 	ldw	r2,-8(fp)
81108b88:	10c4b03a 	or	r2,r2,r3
81108b8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108b90:	e0bfff17 	ldw	r2,-4(fp)
81108b94:	10800017 	ldw	r2,0(r2)
81108b98:	e1bffe17 	ldw	r6,-8(fp)
81108b9c:	01402b84 	movi	r5,174
81108ba0:	1009883a 	mov	r4,r2
81108ba4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ba8:	e0bfff17 	ldw	r2,-4(fp)
81108bac:	10800017 	ldw	r2,0(r2)
81108bb0:	01402bc4 	movi	r5,175
81108bb4:	1009883a 	mov	r4,r2
81108bb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108bbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108bc0:	e0bffe17 	ldw	r2,-8(fp)
81108bc4:	10bfffec 	andhi	r2,r2,65535
81108bc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108bcc:	e0bfff17 	ldw	r2,-4(fp)
81108bd0:	1080350b 	ldhu	r2,212(r2)
81108bd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108bd8:	e0fffe17 	ldw	r3,-8(fp)
81108bdc:	1884b03a 	or	r2,r3,r2
81108be0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81108be4:	e0bffe17 	ldw	r2,-8(fp)
81108be8:	10bfffcc 	andi	r2,r2,65535
81108bec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81108bf0:	e0bfff17 	ldw	r2,-4(fp)
81108bf4:	1080358b 	ldhu	r2,214(r2)
81108bf8:	10bfffcc 	andi	r2,r2,65535
81108bfc:	1004943a 	slli	r2,r2,16
81108c00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81108c04:	e0bffe17 	ldw	r2,-8(fp)
81108c08:	10c4b03a 	or	r2,r2,r3
81108c0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108c10:	e0bfff17 	ldw	r2,-4(fp)
81108c14:	10800017 	ldw	r2,0(r2)
81108c18:	e1bffe17 	ldw	r6,-8(fp)
81108c1c:	01402bc4 	movi	r5,175
81108c20:	1009883a 	mov	r4,r2
81108c24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c28:	e0bfff17 	ldw	r2,-4(fp)
81108c2c:	10800017 	ldw	r2,0(r2)
81108c30:	01402c04 	movi	r5,176
81108c34:	1009883a 	mov	r4,r2
81108c38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108c3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108c40:	e0bffe17 	ldw	r2,-8(fp)
81108c44:	10bfffec 	andhi	r2,r2,65535
81108c48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108c4c:	e0bfff17 	ldw	r2,-4(fp)
81108c50:	1080360b 	ldhu	r2,216(r2)
81108c54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108c58:	e0fffe17 	ldw	r3,-8(fp)
81108c5c:	1884b03a 	or	r2,r3,r2
81108c60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108c64:	e0bffe17 	ldw	r2,-8(fp)
81108c68:	10bfffcc 	andi	r2,r2,65535
81108c6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81108c70:	e0bfff17 	ldw	r2,-4(fp)
81108c74:	1080368b 	ldhu	r2,218(r2)
81108c78:	10bfffcc 	andi	r2,r2,65535
81108c7c:	1004943a 	slli	r2,r2,16
81108c80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81108c84:	e0bffe17 	ldw	r2,-8(fp)
81108c88:	10c4b03a 	or	r2,r2,r3
81108c8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108c90:	e0bfff17 	ldw	r2,-4(fp)
81108c94:	10800017 	ldw	r2,0(r2)
81108c98:	e1bffe17 	ldw	r6,-8(fp)
81108c9c:	01402c04 	movi	r5,176
81108ca0:	1009883a 	mov	r4,r2
81108ca4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ca8:	e0bfff17 	ldw	r2,-4(fp)
81108cac:	10800017 	ldw	r2,0(r2)
81108cb0:	01402c44 	movi	r5,177
81108cb4:	1009883a 	mov	r4,r2
81108cb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108cbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108cc0:	e0bffe17 	ldw	r2,-8(fp)
81108cc4:	10bfffec 	andhi	r2,r2,65535
81108cc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108ccc:	e0bfff17 	ldw	r2,-4(fp)
81108cd0:	1080370b 	ldhu	r2,220(r2)
81108cd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108cd8:	e0fffe17 	ldw	r3,-8(fp)
81108cdc:	1884b03a 	or	r2,r3,r2
81108ce0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108ce4:	e0bffe17 	ldw	r2,-8(fp)
81108ce8:	10bfffcc 	andi	r2,r2,65535
81108cec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81108cf0:	e0bfff17 	ldw	r2,-4(fp)
81108cf4:	1080378b 	ldhu	r2,222(r2)
81108cf8:	10bfffcc 	andi	r2,r2,65535
81108cfc:	1004943a 	slli	r2,r2,16
81108d00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
81108d04:	e0bffe17 	ldw	r2,-8(fp)
81108d08:	10c4b03a 	or	r2,r2,r3
81108d0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108d10:	e0bfff17 	ldw	r2,-4(fp)
81108d14:	10800017 	ldw	r2,0(r2)
81108d18:	e1bffe17 	ldw	r6,-8(fp)
81108d1c:	01402c44 	movi	r5,177
81108d20:	1009883a 	mov	r4,r2
81108d24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d28:	e0bfff17 	ldw	r2,-4(fp)
81108d2c:	10800017 	ldw	r2,0(r2)
81108d30:	01402c84 	movi	r5,178
81108d34:	1009883a 	mov	r4,r2
81108d38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108d3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108d40:	e0bffe17 	ldw	r2,-8(fp)
81108d44:	10bfffec 	andhi	r2,r2,65535
81108d48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108d4c:	e0bfff17 	ldw	r2,-4(fp)
81108d50:	1080380b 	ldhu	r2,224(r2)
81108d54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108d58:	e0fffe17 	ldw	r3,-8(fp)
81108d5c:	1884b03a 	or	r2,r3,r2
81108d60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81108d64:	e0bffe17 	ldw	r2,-8(fp)
81108d68:	10bfffcc 	andi	r2,r2,65535
81108d6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81108d70:	e0bfff17 	ldw	r2,-4(fp)
81108d74:	1080388b 	ldhu	r2,226(r2)
81108d78:	10bfffcc 	andi	r2,r2,65535
81108d7c:	1004943a 	slli	r2,r2,16
81108d80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81108d84:	e0bffe17 	ldw	r2,-8(fp)
81108d88:	10c4b03a 	or	r2,r2,r3
81108d8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108d90:	e0bfff17 	ldw	r2,-4(fp)
81108d94:	10800017 	ldw	r2,0(r2)
81108d98:	e1bffe17 	ldw	r6,-8(fp)
81108d9c:	01402c84 	movi	r5,178
81108da0:	1009883a 	mov	r4,r2
81108da4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108da8:	e0bfff17 	ldw	r2,-4(fp)
81108dac:	10800017 	ldw	r2,0(r2)
81108db0:	01402cc4 	movi	r5,179
81108db4:	1009883a 	mov	r4,r2
81108db8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108dbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108dc0:	e0bffe17 	ldw	r2,-8(fp)
81108dc4:	10bfffec 	andhi	r2,r2,65535
81108dc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108dcc:	e0bfff17 	ldw	r2,-4(fp)
81108dd0:	1080390b 	ldhu	r2,228(r2)
81108dd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108dd8:	e0fffe17 	ldw	r3,-8(fp)
81108ddc:	1884b03a 	or	r2,r3,r2
81108de0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108de4:	e0bffe17 	ldw	r2,-8(fp)
81108de8:	10bfffcc 	andi	r2,r2,65535
81108dec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
81108df0:	e0bfff17 	ldw	r2,-4(fp)
81108df4:	1080398b 	ldhu	r2,230(r2)
81108df8:	10bfffcc 	andi	r2,r2,65535
81108dfc:	1004943a 	slli	r2,r2,16
81108e00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
81108e04:	e0bffe17 	ldw	r2,-8(fp)
81108e08:	10c4b03a 	or	r2,r2,r3
81108e0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81108e10:	e0bfff17 	ldw	r2,-4(fp)
81108e14:	10800017 	ldw	r2,0(r2)
81108e18:	e1bffe17 	ldw	r6,-8(fp)
81108e1c:	01402cc4 	movi	r5,179
81108e20:	1009883a 	mov	r4,r2
81108e24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e28:	e0bfff17 	ldw	r2,-4(fp)
81108e2c:	10800017 	ldw	r2,0(r2)
81108e30:	01402d04 	movi	r5,180
81108e34:	1009883a 	mov	r4,r2
81108e38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108e3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81108e40:	e0bffe17 	ldw	r2,-8(fp)
81108e44:	10bfffec 	andhi	r2,r2,65535
81108e48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108e4c:	e0bfff17 	ldw	r2,-4(fp)
81108e50:	10803a0b 	ldhu	r2,232(r2)
81108e54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108e58:	e0fffe17 	ldw	r3,-8(fp)
81108e5c:	1884b03a 	or	r2,r3,r2
81108e60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108e64:	e0bffe17 	ldw	r2,-8(fp)
81108e68:	10bfffcc 	andi	r2,r2,65535
81108e6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81108e70:	e0bfff17 	ldw	r2,-4(fp)
81108e74:	10803a8b 	ldhu	r2,234(r2)
81108e78:	10bfffcc 	andi	r2,r2,65535
81108e7c:	1004943a 	slli	r2,r2,16
81108e80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81108e84:	e0bffe17 	ldw	r2,-8(fp)
81108e88:	10c4b03a 	or	r2,r2,r3
81108e8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108e90:	e0bfff17 	ldw	r2,-4(fp)
81108e94:	10800017 	ldw	r2,0(r2)
81108e98:	e1bffe17 	ldw	r6,-8(fp)
81108e9c:	01402d04 	movi	r5,180
81108ea0:	1009883a 	mov	r4,r2
81108ea4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ea8:	e0bfff17 	ldw	r2,-4(fp)
81108eac:	10800017 	ldw	r2,0(r2)
81108eb0:	01402d44 	movi	r5,181
81108eb4:	1009883a 	mov	r4,r2
81108eb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108ebc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108ec0:	e0bffe17 	ldw	r2,-8(fp)
81108ec4:	10bfffec 	andhi	r2,r2,65535
81108ec8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108ecc:	e0bfff17 	ldw	r2,-4(fp)
81108ed0:	10803b0b 	ldhu	r2,236(r2)
81108ed4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108ed8:	e0fffe17 	ldw	r3,-8(fp)
81108edc:	1884b03a 	or	r2,r3,r2
81108ee0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108ee4:	e0bffe17 	ldw	r2,-8(fp)
81108ee8:	10bfffcc 	andi	r2,r2,65535
81108eec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
81108ef0:	e0bfff17 	ldw	r2,-4(fp)
81108ef4:	10803b8b 	ldhu	r2,238(r2)
81108ef8:	10bfffcc 	andi	r2,r2,65535
81108efc:	1004943a 	slli	r2,r2,16
81108f00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
81108f04:	e0bffe17 	ldw	r2,-8(fp)
81108f08:	10c4b03a 	or	r2,r2,r3
81108f0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81108f10:	e0bfff17 	ldw	r2,-4(fp)
81108f14:	10800017 	ldw	r2,0(r2)
81108f18:	e1bffe17 	ldw	r6,-8(fp)
81108f1c:	01402d44 	movi	r5,181
81108f20:	1009883a 	mov	r4,r2
81108f24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f28:	e0bfff17 	ldw	r2,-4(fp)
81108f2c:	10800017 	ldw	r2,0(r2)
81108f30:	01402d84 	movi	r5,182
81108f34:	1009883a 	mov	r4,r2
81108f38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108f3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81108f40:	e0bffe17 	ldw	r2,-8(fp)
81108f44:	10bfffec 	andhi	r2,r2,65535
81108f48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81108f4c:	e0bfff17 	ldw	r2,-4(fp)
81108f50:	10803c0b 	ldhu	r2,240(r2)
81108f54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81108f58:	e0fffe17 	ldw	r3,-8(fp)
81108f5c:	1884b03a 	or	r2,r3,r2
81108f60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81108f64:	e0bffe17 	ldw	r2,-8(fp)
81108f68:	10bfffcc 	andi	r2,r2,65535
81108f6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81108f70:	e0bfff17 	ldw	r2,-4(fp)
81108f74:	10803c8b 	ldhu	r2,242(r2)
81108f78:	10bfffcc 	andi	r2,r2,65535
81108f7c:	1004943a 	slli	r2,r2,16
81108f80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81108f84:	e0bffe17 	ldw	r2,-8(fp)
81108f88:	10c4b03a 	or	r2,r2,r3
81108f8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81108f90:	e0bfff17 	ldw	r2,-4(fp)
81108f94:	10800017 	ldw	r2,0(r2)
81108f98:	e1bffe17 	ldw	r6,-8(fp)
81108f9c:	01402d84 	movi	r5,182
81108fa0:	1009883a 	mov	r4,r2
81108fa4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fa8:	e0bfff17 	ldw	r2,-4(fp)
81108fac:	10800017 	ldw	r2,0(r2)
81108fb0:	01402dc4 	movi	r5,183
81108fb4:	1009883a 	mov	r4,r2
81108fb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108fbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81108fc0:	e0bffe17 	ldw	r2,-8(fp)
81108fc4:	10bfffec 	andhi	r2,r2,65535
81108fc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81108fcc:	e0bfff17 	ldw	r2,-4(fp)
81108fd0:	10803d0b 	ldhu	r2,244(r2)
81108fd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81108fd8:	e0fffe17 	ldw	r3,-8(fp)
81108fdc:	1884b03a 	or	r2,r3,r2
81108fe0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81108fe4:	e0bffe17 	ldw	r2,-8(fp)
81108fe8:	10bfffcc 	andi	r2,r2,65535
81108fec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
81108ff0:	e0bfff17 	ldw	r2,-4(fp)
81108ff4:	10803d8b 	ldhu	r2,246(r2)
81108ff8:	10bfffcc 	andi	r2,r2,65535
81108ffc:	1004943a 	slli	r2,r2,16
81109000:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
81109004:	e0bffe17 	ldw	r2,-8(fp)
81109008:	10c4b03a 	or	r2,r2,r3
8110900c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81109010:	e0bfff17 	ldw	r2,-4(fp)
81109014:	10800017 	ldw	r2,0(r2)
81109018:	e1bffe17 	ldw	r6,-8(fp)
8110901c:	01402dc4 	movi	r5,183
81109020:	1009883a 	mov	r4,r2
81109024:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109028:	e0bfff17 	ldw	r2,-4(fp)
8110902c:	10800017 	ldw	r2,0(r2)
81109030:	01402e04 	movi	r5,184
81109034:	1009883a 	mov	r4,r2
81109038:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110903c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81109040:	e0bffe17 	ldw	r2,-8(fp)
81109044:	10bfffec 	andhi	r2,r2,65535
81109048:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
8110904c:	e0bfff17 	ldw	r2,-4(fp)
81109050:	10803e0b 	ldhu	r2,248(r2)
81109054:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81109058:	e0fffe17 	ldw	r3,-8(fp)
8110905c:	1884b03a 	or	r2,r3,r2
81109060:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109064:	e0bffe17 	ldw	r2,-8(fp)
81109068:	10bfffcc 	andi	r2,r2,65535
8110906c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109070:	e0bfff17 	ldw	r2,-4(fp)
81109074:	10803e8b 	ldhu	r2,250(r2)
81109078:	10bfffcc 	andi	r2,r2,65535
8110907c:	1004943a 	slli	r2,r2,16
81109080:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109084:	e0bffe17 	ldw	r2,-8(fp)
81109088:	10c4b03a 	or	r2,r2,r3
8110908c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109090:	e0bfff17 	ldw	r2,-4(fp)
81109094:	10800017 	ldw	r2,0(r2)
81109098:	e1bffe17 	ldw	r6,-8(fp)
8110909c:	01402e04 	movi	r5,184
811090a0:	1009883a 	mov	r4,r2
811090a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090a8:	e0bfff17 	ldw	r2,-4(fp)
811090ac:	10800017 	ldw	r2,0(r2)
811090b0:	01402e44 	movi	r5,185
811090b4:	1009883a 	mov	r4,r2
811090b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811090bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811090c0:	e0bffe17 	ldw	r2,-8(fp)
811090c4:	10bfffec 	andhi	r2,r2,65535
811090c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
811090cc:	e0bfff17 	ldw	r2,-4(fp)
811090d0:	10803f0b 	ldhu	r2,252(r2)
811090d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811090d8:	e0fffe17 	ldw	r3,-8(fp)
811090dc:	1884b03a 	or	r2,r3,r2
811090e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811090e4:	e0bffe17 	ldw	r2,-8(fp)
811090e8:	10bfffcc 	andi	r2,r2,65535
811090ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811090f0:	e0bfff17 	ldw	r2,-4(fp)
811090f4:	10803f8b 	ldhu	r2,254(r2)
811090f8:	10bfffcc 	andi	r2,r2,65535
811090fc:	1004943a 	slli	r2,r2,16
81109100:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
81109104:	e0bffe17 	ldw	r2,-8(fp)
81109108:	10c4b03a 	or	r2,r2,r3
8110910c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81109110:	e0bfff17 	ldw	r2,-4(fp)
81109114:	10800017 	ldw	r2,0(r2)
81109118:	e1bffe17 	ldw	r6,-8(fp)
8110911c:	01402e44 	movi	r5,185
81109120:	1009883a 	mov	r4,r2
81109124:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109128:	e0bfff17 	ldw	r2,-4(fp)
8110912c:	10800017 	ldw	r2,0(r2)
81109130:	01402e84 	movi	r5,186
81109134:	1009883a 	mov	r4,r2
81109138:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110913c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81109140:	e0bffe17 	ldw	r2,-8(fp)
81109144:	10bfffec 	andhi	r2,r2,65535
81109148:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
8110914c:	e0bfff17 	ldw	r2,-4(fp)
81109150:	1080400b 	ldhu	r2,256(r2)
81109154:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81109158:	e0fffe17 	ldw	r3,-8(fp)
8110915c:	1884b03a 	or	r2,r3,r2
81109160:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109164:	e0bffe17 	ldw	r2,-8(fp)
81109168:	10bfffcc 	andi	r2,r2,65535
8110916c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81109170:	e0bfff17 	ldw	r2,-4(fp)
81109174:	1080408b 	ldhu	r2,258(r2)
81109178:	10bfffcc 	andi	r2,r2,65535
8110917c:	1004943a 	slli	r2,r2,16
81109180:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109184:	e0bffe17 	ldw	r2,-8(fp)
81109188:	10c4b03a 	or	r2,r2,r3
8110918c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81109190:	e0bfff17 	ldw	r2,-4(fp)
81109194:	10800017 	ldw	r2,0(r2)
81109198:	e1bffe17 	ldw	r6,-8(fp)
8110919c:	01402e84 	movi	r5,186
811091a0:	1009883a 	mov	r4,r2
811091a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091a8:	e0bfff17 	ldw	r2,-4(fp)
811091ac:	10800017 	ldw	r2,0(r2)
811091b0:	01402ec4 	movi	r5,187
811091b4:	1009883a 	mov	r4,r2
811091b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811091bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811091c0:	e0bffe17 	ldw	r2,-8(fp)
811091c4:	10bfffec 	andhi	r2,r2,65535
811091c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811091cc:	e0bfff17 	ldw	r2,-4(fp)
811091d0:	1080410b 	ldhu	r2,260(r2)
811091d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811091d8:	e0fffe17 	ldw	r3,-8(fp)
811091dc:	1884b03a 	or	r2,r3,r2
811091e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811091e4:	e0bffe17 	ldw	r2,-8(fp)
811091e8:	10bfffcc 	andi	r2,r2,65535
811091ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
811091f0:	e0bfff17 	ldw	r2,-4(fp)
811091f4:	1080418b 	ldhu	r2,262(r2)
811091f8:	10bfffcc 	andi	r2,r2,65535
811091fc:	1004943a 	slli	r2,r2,16
81109200:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
81109204:	e0bffe17 	ldw	r2,-8(fp)
81109208:	10c4b03a 	or	r2,r2,r3
8110920c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81109210:	e0bfff17 	ldw	r2,-4(fp)
81109214:	10800017 	ldw	r2,0(r2)
81109218:	e1bffe17 	ldw	r6,-8(fp)
8110921c:	01402ec4 	movi	r5,187
81109220:	1009883a 	mov	r4,r2
81109224:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109228:	e0bfff17 	ldw	r2,-4(fp)
8110922c:	10800017 	ldw	r2,0(r2)
81109230:	01402f04 	movi	r5,188
81109234:	1009883a 	mov	r4,r2
81109238:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110923c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81109240:	e0bffe17 	ldw	r2,-8(fp)
81109244:	10bfffec 	andhi	r2,r2,65535
81109248:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
8110924c:	e0bfff17 	ldw	r2,-4(fp)
81109250:	1080420b 	ldhu	r2,264(r2)
81109254:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81109258:	e0fffe17 	ldw	r3,-8(fp)
8110925c:	1884b03a 	or	r2,r3,r2
81109260:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109264:	e0bffe17 	ldw	r2,-8(fp)
81109268:	10bfffcc 	andi	r2,r2,65535
8110926c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109270:	e0bfff17 	ldw	r2,-4(fp)
81109274:	1080428b 	ldhu	r2,266(r2)
81109278:	10bfffcc 	andi	r2,r2,65535
8110927c:	1004943a 	slli	r2,r2,16
81109280:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109284:	e0bffe17 	ldw	r2,-8(fp)
81109288:	10c4b03a 	or	r2,r2,r3
8110928c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81109290:	e0bfff17 	ldw	r2,-4(fp)
81109294:	10800017 	ldw	r2,0(r2)
81109298:	e1bffe17 	ldw	r6,-8(fp)
8110929c:	01402f04 	movi	r5,188
811092a0:	1009883a 	mov	r4,r2
811092a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092a8:	e0bfff17 	ldw	r2,-4(fp)
811092ac:	10800017 	ldw	r2,0(r2)
811092b0:	01402f44 	movi	r5,189
811092b4:	1009883a 	mov	r4,r2
811092b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811092bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
811092c0:	e0bffe17 	ldw	r2,-8(fp)
811092c4:	10bfffec 	andhi	r2,r2,65535
811092c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
811092cc:	e0bfff17 	ldw	r2,-4(fp)
811092d0:	1080430b 	ldhu	r2,268(r2)
811092d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811092d8:	e0fffe17 	ldw	r3,-8(fp)
811092dc:	1884b03a 	or	r2,r3,r2
811092e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811092e4:	e0bffe17 	ldw	r2,-8(fp)
811092e8:	10bfffcc 	andi	r2,r2,65535
811092ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
811092f0:	e0bfff17 	ldw	r2,-4(fp)
811092f4:	1080438b 	ldhu	r2,270(r2)
811092f8:	10bfffcc 	andi	r2,r2,65535
811092fc:	1004943a 	slli	r2,r2,16
81109300:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
81109304:	e0bffe17 	ldw	r2,-8(fp)
81109308:	10c4b03a 	or	r2,r2,r3
8110930c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81109310:	e0bfff17 	ldw	r2,-4(fp)
81109314:	10800017 	ldw	r2,0(r2)
81109318:	e1bffe17 	ldw	r6,-8(fp)
8110931c:	01402f44 	movi	r5,189
81109320:	1009883a 	mov	r4,r2
81109324:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109328:	e0bfff17 	ldw	r2,-4(fp)
8110932c:	10800017 	ldw	r2,0(r2)
81109330:	01402f84 	movi	r5,190
81109334:	1009883a 	mov	r4,r2
81109338:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110933c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81109340:	e0bffe17 	ldw	r2,-8(fp)
81109344:	10bfffec 	andhi	r2,r2,65535
81109348:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
8110934c:	e0bfff17 	ldw	r2,-4(fp)
81109350:	1080440b 	ldhu	r2,272(r2)
81109354:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81109358:	e0fffe17 	ldw	r3,-8(fp)
8110935c:	1884b03a 	or	r2,r3,r2
81109360:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109364:	e0bffe17 	ldw	r2,-8(fp)
81109368:	10bfffcc 	andi	r2,r2,65535
8110936c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81109370:	e0bfff17 	ldw	r2,-4(fp)
81109374:	1080448b 	ldhu	r2,274(r2)
81109378:	10bfffcc 	andi	r2,r2,65535
8110937c:	1004943a 	slli	r2,r2,16
81109380:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81109384:	e0bffe17 	ldw	r2,-8(fp)
81109388:	10c4b03a 	or	r2,r2,r3
8110938c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81109390:	e0bfff17 	ldw	r2,-4(fp)
81109394:	10800017 	ldw	r2,0(r2)
81109398:	e1bffe17 	ldw	r6,-8(fp)
8110939c:	01402f84 	movi	r5,190
811093a0:	1009883a 	mov	r4,r2
811093a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093a8:	e0bfff17 	ldw	r2,-4(fp)
811093ac:	10800017 	ldw	r2,0(r2)
811093b0:	01402fc4 	movi	r5,191
811093b4:	1009883a 	mov	r4,r2
811093b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811093bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811093c0:	e0bffe17 	ldw	r2,-8(fp)
811093c4:	10bfffec 	andhi	r2,r2,65535
811093c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811093cc:	e0bfff17 	ldw	r2,-4(fp)
811093d0:	1080450b 	ldhu	r2,276(r2)
811093d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811093d8:	e0fffe17 	ldw	r3,-8(fp)
811093dc:	1884b03a 	or	r2,r3,r2
811093e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811093e4:	e0bffe17 	ldw	r2,-8(fp)
811093e8:	10bfffcc 	andi	r2,r2,65535
811093ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
811093f0:	e0bfff17 	ldw	r2,-4(fp)
811093f4:	1080458b 	ldhu	r2,278(r2)
811093f8:	10bfffcc 	andi	r2,r2,65535
811093fc:	1004943a 	slli	r2,r2,16
81109400:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
81109404:	e0bffe17 	ldw	r2,-8(fp)
81109408:	10c4b03a 	or	r2,r2,r3
8110940c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81109410:	e0bfff17 	ldw	r2,-4(fp)
81109414:	10800017 	ldw	r2,0(r2)
81109418:	e1bffe17 	ldw	r6,-8(fp)
8110941c:	01402fc4 	movi	r5,191
81109420:	1009883a 	mov	r4,r2
81109424:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81109428:	00800044 	movi	r2,1
8110942c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109430:	e0bffd17 	ldw	r2,-12(fp)
}
81109434:	e037883a 	mov	sp,fp
81109438:	dfc00117 	ldw	ra,4(sp)
8110943c:	df000017 	ldw	fp,0(sp)
81109440:	dec00204 	addi	sp,sp,8
81109444:	f800283a 	ret

81109448 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81109448:	defffb04 	addi	sp,sp,-20
8110944c:	de00012e 	bgeu	sp,et,81109454 <bRmapGetRmapMemHKArea+0xc>
81109450:	003b68fa 	trap	3
81109454:	dfc00415 	stw	ra,16(sp)
81109458:	df000315 	stw	fp,12(sp)
8110945c:	df000304 	addi	fp,sp,12
81109460:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109464:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109468:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110946c:	e0bfff17 	ldw	r2,-4(fp)
81109470:	1001e226 	beq	r2,zero,81109bfc <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109474:	e0bfff17 	ldw	r2,-4(fp)
81109478:	10800017 	ldw	r2,0(r2)
8110947c:	01402804 	movi	r5,160
81109480:	1009883a 	mov	r4,r2
81109484:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109488:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
8110948c:	e0bffe17 	ldw	r2,-8(fp)
81109490:	1007883a 	mov	r3,r2
81109494:	e0bfff17 	ldw	r2,-4(fp)
81109498:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
8110949c:	e0bffe17 	ldw	r2,-8(fp)
811094a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
811094a4:	1007883a 	mov	r3,r2
811094a8:	e0bfff17 	ldw	r2,-4(fp)
811094ac:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094b0:	e0bfff17 	ldw	r2,-4(fp)
811094b4:	10800017 	ldw	r2,0(r2)
811094b8:	01402844 	movi	r5,161
811094bc:	1009883a 	mov	r4,r2
811094c0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811094c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
811094c8:	e0bffe17 	ldw	r2,-8(fp)
811094cc:	1007883a 	mov	r3,r2
811094d0:	e0bfff17 	ldw	r2,-4(fp)
811094d4:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811094d8:	e0bffe17 	ldw	r2,-8(fp)
811094dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811094e0:	1007883a 	mov	r3,r2
811094e4:	e0bfff17 	ldw	r2,-4(fp)
811094e8:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094ec:	e0bfff17 	ldw	r2,-4(fp)
811094f0:	10800017 	ldw	r2,0(r2)
811094f4:	01402884 	movi	r5,162
811094f8:	1009883a 	mov	r4,r2
811094fc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109500:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81109504:	e0bffe17 	ldw	r2,-8(fp)
81109508:	1007883a 	mov	r3,r2
8110950c:	e0bfff17 	ldw	r2,-4(fp)
81109510:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81109514:	e0bffe17 	ldw	r2,-8(fp)
81109518:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
8110951c:	1007883a 	mov	r3,r2
81109520:	e0bfff17 	ldw	r2,-4(fp)
81109524:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109528:	e0bfff17 	ldw	r2,-4(fp)
8110952c:	10800017 	ldw	r2,0(r2)
81109530:	014028c4 	movi	r5,163
81109534:	1009883a 	mov	r4,r2
81109538:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110953c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81109540:	e0bffe17 	ldw	r2,-8(fp)
81109544:	1007883a 	mov	r3,r2
81109548:	e0bfff17 	ldw	r2,-4(fp)
8110954c:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109550:	e0bffe17 	ldw	r2,-8(fp)
81109554:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109558:	1007883a 	mov	r3,r2
8110955c:	e0bfff17 	ldw	r2,-4(fp)
81109560:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109564:	e0bfff17 	ldw	r2,-4(fp)
81109568:	10800017 	ldw	r2,0(r2)
8110956c:	01402904 	movi	r5,164
81109570:	1009883a 	mov	r4,r2
81109574:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109578:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
8110957c:	e0bffe17 	ldw	r2,-8(fp)
81109580:	1007883a 	mov	r3,r2
81109584:	e0bfff17 	ldw	r2,-4(fp)
81109588:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
8110958c:	e0bffe17 	ldw	r2,-8(fp)
81109590:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109594:	1007883a 	mov	r3,r2
81109598:	e0bfff17 	ldw	r2,-4(fp)
8110959c:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095a0:	e0bfff17 	ldw	r2,-4(fp)
811095a4:	10800017 	ldw	r2,0(r2)
811095a8:	01402944 	movi	r5,165
811095ac:	1009883a 	mov	r4,r2
811095b0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811095b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
811095b8:	e0bffe17 	ldw	r2,-8(fp)
811095bc:	1007883a 	mov	r3,r2
811095c0:	e0bfff17 	ldw	r2,-4(fp)
811095c4:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
811095c8:	e0bffe17 	ldw	r2,-8(fp)
811095cc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
811095d0:	1007883a 	mov	r3,r2
811095d4:	e0bfff17 	ldw	r2,-4(fp)
811095d8:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095dc:	e0bfff17 	ldw	r2,-4(fp)
811095e0:	10800017 	ldw	r2,0(r2)
811095e4:	01402984 	movi	r5,166
811095e8:	1009883a 	mov	r4,r2
811095ec:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811095f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811095f4:	e0bffe17 	ldw	r2,-8(fp)
811095f8:	1007883a 	mov	r3,r2
811095fc:	e0bfff17 	ldw	r2,-4(fp)
81109600:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81109604:	e0bffe17 	ldw	r2,-8(fp)
81109608:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
8110960c:	1007883a 	mov	r3,r2
81109610:	e0bfff17 	ldw	r2,-4(fp)
81109614:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109618:	e0bfff17 	ldw	r2,-4(fp)
8110961c:	10800017 	ldw	r2,0(r2)
81109620:	014029c4 	movi	r5,167
81109624:	1009883a 	mov	r4,r2
81109628:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110962c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
81109630:	e0bffe17 	ldw	r2,-8(fp)
81109634:	1007883a 	mov	r3,r2
81109638:	e0bfff17 	ldw	r2,-4(fp)
8110963c:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81109640:	e0bffe17 	ldw	r2,-8(fp)
81109644:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81109648:	1007883a 	mov	r3,r2
8110964c:	e0bfff17 	ldw	r2,-4(fp)
81109650:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109654:	e0bfff17 	ldw	r2,-4(fp)
81109658:	10800017 	ldw	r2,0(r2)
8110965c:	01402a04 	movi	r5,168
81109660:	1009883a 	mov	r4,r2
81109664:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109668:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
8110966c:	e0bffe17 	ldw	r2,-8(fp)
81109670:	1007883a 	mov	r3,r2
81109674:	e0bfff17 	ldw	r2,-4(fp)
81109678:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
8110967c:	e0bffe17 	ldw	r2,-8(fp)
81109680:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109684:	1007883a 	mov	r3,r2
81109688:	e0bfff17 	ldw	r2,-4(fp)
8110968c:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109690:	e0bfff17 	ldw	r2,-4(fp)
81109694:	10800017 	ldw	r2,0(r2)
81109698:	01402a44 	movi	r5,169
8110969c:	1009883a 	mov	r4,r2
811096a0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811096a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
811096a8:	e0bffe17 	ldw	r2,-8(fp)
811096ac:	1007883a 	mov	r3,r2
811096b0:	e0bfff17 	ldw	r2,-4(fp)
811096b4:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
811096b8:	e0bffe17 	ldw	r2,-8(fp)
811096bc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
811096c0:	1007883a 	mov	r3,r2
811096c4:	e0bfff17 	ldw	r2,-4(fp)
811096c8:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096cc:	e0bfff17 	ldw	r2,-4(fp)
811096d0:	10800017 	ldw	r2,0(r2)
811096d4:	01402a84 	movi	r5,170
811096d8:	1009883a 	mov	r4,r2
811096dc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811096e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811096e4:	e0bffe17 	ldw	r2,-8(fp)
811096e8:	1007883a 	mov	r3,r2
811096ec:	e0bfff17 	ldw	r2,-4(fp)
811096f0:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811096f4:	e0bffe17 	ldw	r2,-8(fp)
811096f8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811096fc:	1007883a 	mov	r3,r2
81109700:	e0bfff17 	ldw	r2,-4(fp)
81109704:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109708:	e0bfff17 	ldw	r2,-4(fp)
8110970c:	10800017 	ldw	r2,0(r2)
81109710:	01402ac4 	movi	r5,171
81109714:	1009883a 	mov	r4,r2
81109718:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110971c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81109720:	e0bffe17 	ldw	r2,-8(fp)
81109724:	1007883a 	mov	r3,r2
81109728:	e0bfff17 	ldw	r2,-4(fp)
8110972c:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81109730:	e0bffe17 	ldw	r2,-8(fp)
81109734:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81109738:	1007883a 	mov	r3,r2
8110973c:	e0bfff17 	ldw	r2,-4(fp)
81109740:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109744:	e0bfff17 	ldw	r2,-4(fp)
81109748:	10800017 	ldw	r2,0(r2)
8110974c:	01402b04 	movi	r5,172
81109750:	1009883a 	mov	r4,r2
81109754:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109758:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
8110975c:	e0bffe17 	ldw	r2,-8(fp)
81109760:	1007883a 	mov	r3,r2
81109764:	e0bfff17 	ldw	r2,-4(fp)
81109768:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
8110976c:	e0bffe17 	ldw	r2,-8(fp)
81109770:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109774:	1007883a 	mov	r3,r2
81109778:	e0bfff17 	ldw	r2,-4(fp)
8110977c:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109780:	e0bfff17 	ldw	r2,-4(fp)
81109784:	10800017 	ldw	r2,0(r2)
81109788:	01402b44 	movi	r5,173
8110978c:	1009883a 	mov	r4,r2
81109790:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109794:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109798:	e0bffe17 	ldw	r2,-8(fp)
8110979c:	1007883a 	mov	r3,r2
811097a0:	e0bfff17 	ldw	r2,-4(fp)
811097a4:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
811097a8:	e0bffe17 	ldw	r2,-8(fp)
811097ac:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
811097b0:	1007883a 	mov	r3,r2
811097b4:	e0bfff17 	ldw	r2,-4(fp)
811097b8:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097bc:	e0bfff17 	ldw	r2,-4(fp)
811097c0:	10800017 	ldw	r2,0(r2)
811097c4:	01402b84 	movi	r5,174
811097c8:	1009883a 	mov	r4,r2
811097cc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811097d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811097d4:	e0bffe17 	ldw	r2,-8(fp)
811097d8:	1007883a 	mov	r3,r2
811097dc:	e0bfff17 	ldw	r2,-4(fp)
811097e0:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811097e4:	e0bffe17 	ldw	r2,-8(fp)
811097e8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811097ec:	1007883a 	mov	r3,r2
811097f0:	e0bfff17 	ldw	r2,-4(fp)
811097f4:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097f8:	e0bfff17 	ldw	r2,-4(fp)
811097fc:	10800017 	ldw	r2,0(r2)
81109800:	01402bc4 	movi	r5,175
81109804:	1009883a 	mov	r4,r2
81109808:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110980c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81109810:	e0bffe17 	ldw	r2,-8(fp)
81109814:	1007883a 	mov	r3,r2
81109818:	e0bfff17 	ldw	r2,-4(fp)
8110981c:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81109820:	e0bffe17 	ldw	r2,-8(fp)
81109824:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81109828:	1007883a 	mov	r3,r2
8110982c:	e0bfff17 	ldw	r2,-4(fp)
81109830:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109834:	e0bfff17 	ldw	r2,-4(fp)
81109838:	10800017 	ldw	r2,0(r2)
8110983c:	01402c04 	movi	r5,176
81109840:	1009883a 	mov	r4,r2
81109844:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109848:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
8110984c:	e0bffe17 	ldw	r2,-8(fp)
81109850:	1007883a 	mov	r3,r2
81109854:	e0bfff17 	ldw	r2,-4(fp)
81109858:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
8110985c:	e0bffe17 	ldw	r2,-8(fp)
81109860:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109864:	1007883a 	mov	r3,r2
81109868:	e0bfff17 	ldw	r2,-4(fp)
8110986c:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109870:	e0bfff17 	ldw	r2,-4(fp)
81109874:	10800017 	ldw	r2,0(r2)
81109878:	01402c44 	movi	r5,177
8110987c:	1009883a 	mov	r4,r2
81109880:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109884:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109888:	e0bffe17 	ldw	r2,-8(fp)
8110988c:	1007883a 	mov	r3,r2
81109890:	e0bfff17 	ldw	r2,-4(fp)
81109894:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109898:	e0bffe17 	ldw	r2,-8(fp)
8110989c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
811098a0:	1007883a 	mov	r3,r2
811098a4:	e0bfff17 	ldw	r2,-4(fp)
811098a8:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098ac:	e0bfff17 	ldw	r2,-4(fp)
811098b0:	10800017 	ldw	r2,0(r2)
811098b4:	01402c84 	movi	r5,178
811098b8:	1009883a 	mov	r4,r2
811098bc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811098c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811098c4:	e0bffe17 	ldw	r2,-8(fp)
811098c8:	1007883a 	mov	r3,r2
811098cc:	e0bfff17 	ldw	r2,-4(fp)
811098d0:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811098d4:	e0bffe17 	ldw	r2,-8(fp)
811098d8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811098dc:	1007883a 	mov	r3,r2
811098e0:	e0bfff17 	ldw	r2,-4(fp)
811098e4:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098e8:	e0bfff17 	ldw	r2,-4(fp)
811098ec:	10800017 	ldw	r2,0(r2)
811098f0:	01402cc4 	movi	r5,179
811098f4:	1009883a 	mov	r4,r2
811098f8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811098fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81109900:	e0bffe17 	ldw	r2,-8(fp)
81109904:	1007883a 	mov	r3,r2
81109908:	e0bfff17 	ldw	r2,-4(fp)
8110990c:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81109910:	e0bffe17 	ldw	r2,-8(fp)
81109914:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109918:	1007883a 	mov	r3,r2
8110991c:	e0bfff17 	ldw	r2,-4(fp)
81109920:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109924:	e0bfff17 	ldw	r2,-4(fp)
81109928:	10800017 	ldw	r2,0(r2)
8110992c:	01402d04 	movi	r5,180
81109930:	1009883a 	mov	r4,r2
81109934:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109938:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
8110993c:	e0bffe17 	ldw	r2,-8(fp)
81109940:	1007883a 	mov	r3,r2
81109944:	e0bfff17 	ldw	r2,-4(fp)
81109948:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
8110994c:	e0bffe17 	ldw	r2,-8(fp)
81109950:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109954:	1007883a 	mov	r3,r2
81109958:	e0bfff17 	ldw	r2,-4(fp)
8110995c:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109960:	e0bfff17 	ldw	r2,-4(fp)
81109964:	10800017 	ldw	r2,0(r2)
81109968:	01402d44 	movi	r5,181
8110996c:	1009883a 	mov	r4,r2
81109970:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109974:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109978:	e0bffe17 	ldw	r2,-8(fp)
8110997c:	1007883a 	mov	r3,r2
81109980:	e0bfff17 	ldw	r2,-4(fp)
81109984:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109988:	e0bffe17 	ldw	r2,-8(fp)
8110998c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109990:	1007883a 	mov	r3,r2
81109994:	e0bfff17 	ldw	r2,-4(fp)
81109998:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110999c:	e0bfff17 	ldw	r2,-4(fp)
811099a0:	10800017 	ldw	r2,0(r2)
811099a4:	01402d84 	movi	r5,182
811099a8:	1009883a 	mov	r4,r2
811099ac:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811099b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
811099b4:	e0bffe17 	ldw	r2,-8(fp)
811099b8:	1007883a 	mov	r3,r2
811099bc:	e0bfff17 	ldw	r2,-4(fp)
811099c0:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
811099c4:	e0bffe17 	ldw	r2,-8(fp)
811099c8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
811099cc:	1007883a 	mov	r3,r2
811099d0:	e0bfff17 	ldw	r2,-4(fp)
811099d4:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099d8:	e0bfff17 	ldw	r2,-4(fp)
811099dc:	10800017 	ldw	r2,0(r2)
811099e0:	01402dc4 	movi	r5,183
811099e4:	1009883a 	mov	r4,r2
811099e8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811099ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
811099f0:	e0bffe17 	ldw	r2,-8(fp)
811099f4:	1007883a 	mov	r3,r2
811099f8:	e0bfff17 	ldw	r2,-4(fp)
811099fc:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109a00:	e0bffe17 	ldw	r2,-8(fp)
81109a04:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109a08:	1007883a 	mov	r3,r2
81109a0c:	e0bfff17 	ldw	r2,-4(fp)
81109a10:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a14:	e0bfff17 	ldw	r2,-4(fp)
81109a18:	10800017 	ldw	r2,0(r2)
81109a1c:	01402e04 	movi	r5,184
81109a20:	1009883a 	mov	r4,r2
81109a24:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109a28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109a2c:	e0bffe17 	ldw	r2,-8(fp)
81109a30:	1007883a 	mov	r3,r2
81109a34:	e0bfff17 	ldw	r2,-4(fp)
81109a38:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109a3c:	e0bffe17 	ldw	r2,-8(fp)
81109a40:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81109a44:	1007883a 	mov	r3,r2
81109a48:	e0bfff17 	ldw	r2,-4(fp)
81109a4c:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a50:	e0bfff17 	ldw	r2,-4(fp)
81109a54:	10800017 	ldw	r2,0(r2)
81109a58:	01402e44 	movi	r5,185
81109a5c:	1009883a 	mov	r4,r2
81109a60:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109a64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109a68:	e0bffe17 	ldw	r2,-8(fp)
81109a6c:	1007883a 	mov	r3,r2
81109a70:	e0bfff17 	ldw	r2,-4(fp)
81109a74:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109a78:	e0bffe17 	ldw	r2,-8(fp)
81109a7c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109a80:	1007883a 	mov	r3,r2
81109a84:	e0bfff17 	ldw	r2,-4(fp)
81109a88:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a8c:	e0bfff17 	ldw	r2,-4(fp)
81109a90:	10800017 	ldw	r2,0(r2)
81109a94:	01402e84 	movi	r5,186
81109a98:	1009883a 	mov	r4,r2
81109a9c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109aa0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109aa4:	e0bffe17 	ldw	r2,-8(fp)
81109aa8:	1007883a 	mov	r3,r2
81109aac:	e0bfff17 	ldw	r2,-4(fp)
81109ab0:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109ab4:	e0bffe17 	ldw	r2,-8(fp)
81109ab8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81109abc:	1007883a 	mov	r3,r2
81109ac0:	e0bfff17 	ldw	r2,-4(fp)
81109ac4:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ac8:	e0bfff17 	ldw	r2,-4(fp)
81109acc:	10800017 	ldw	r2,0(r2)
81109ad0:	01402ec4 	movi	r5,187
81109ad4:	1009883a 	mov	r4,r2
81109ad8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109adc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109ae0:	e0bffe17 	ldw	r2,-8(fp)
81109ae4:	1007883a 	mov	r3,r2
81109ae8:	e0bfff17 	ldw	r2,-4(fp)
81109aec:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109af0:	e0bffe17 	ldw	r2,-8(fp)
81109af4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109af8:	1007883a 	mov	r3,r2
81109afc:	e0bfff17 	ldw	r2,-4(fp)
81109b00:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b04:	e0bfff17 	ldw	r2,-4(fp)
81109b08:	10800017 	ldw	r2,0(r2)
81109b0c:	01402f04 	movi	r5,188
81109b10:	1009883a 	mov	r4,r2
81109b14:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109b18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109b1c:	e0bffe17 	ldw	r2,-8(fp)
81109b20:	1007883a 	mov	r3,r2
81109b24:	e0bfff17 	ldw	r2,-4(fp)
81109b28:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109b2c:	e0bffe17 	ldw	r2,-8(fp)
81109b30:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81109b34:	1007883a 	mov	r3,r2
81109b38:	e0bfff17 	ldw	r2,-4(fp)
81109b3c:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b40:	e0bfff17 	ldw	r2,-4(fp)
81109b44:	10800017 	ldw	r2,0(r2)
81109b48:	01402f44 	movi	r5,189
81109b4c:	1009883a 	mov	r4,r2
81109b50:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109b54:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109b58:	e0bffe17 	ldw	r2,-8(fp)
81109b5c:	1007883a 	mov	r3,r2
81109b60:	e0bfff17 	ldw	r2,-4(fp)
81109b64:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109b68:	e0bffe17 	ldw	r2,-8(fp)
81109b6c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109b70:	1007883a 	mov	r3,r2
81109b74:	e0bfff17 	ldw	r2,-4(fp)
81109b78:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b7c:	e0bfff17 	ldw	r2,-4(fp)
81109b80:	10800017 	ldw	r2,0(r2)
81109b84:	01402f84 	movi	r5,190
81109b88:	1009883a 	mov	r4,r2
81109b8c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109b90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109b94:	e0bffe17 	ldw	r2,-8(fp)
81109b98:	1007883a 	mov	r3,r2
81109b9c:	e0bfff17 	ldw	r2,-4(fp)
81109ba0:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109ba4:	e0bffe17 	ldw	r2,-8(fp)
81109ba8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81109bac:	1007883a 	mov	r3,r2
81109bb0:	e0bfff17 	ldw	r2,-4(fp)
81109bb4:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bb8:	e0bfff17 	ldw	r2,-4(fp)
81109bbc:	10800017 	ldw	r2,0(r2)
81109bc0:	01402fc4 	movi	r5,191
81109bc4:	1009883a 	mov	r4,r2
81109bc8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109bcc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109bd0:	e0bffe17 	ldw	r2,-8(fp)
81109bd4:	1007883a 	mov	r3,r2
81109bd8:	e0bfff17 	ldw	r2,-4(fp)
81109bdc:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109be0:	e0bffe17 	ldw	r2,-8(fp)
81109be4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109be8:	1007883a 	mov	r3,r2
81109bec:	e0bfff17 	ldw	r2,-4(fp)
81109bf0:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81109bf4:	00800044 	movi	r2,1
81109bf8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109bfc:	e0bffd17 	ldw	r2,-12(fp)
}
81109c00:	e037883a 	mov	sp,fp
81109c04:	dfc00117 	ldw	ra,4(sp)
81109c08:	df000017 	ldw	fp,0(sp)
81109c0c:	dec00204 	addi	sp,sp,8
81109c10:	f800283a 	ret

81109c14 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81109c14:	defffb04 	addi	sp,sp,-20
81109c18:	de00012e 	bgeu	sp,et,81109c20 <bRmapInitCh+0xc>
81109c1c:	003b68fa 	trap	3
81109c20:	dfc00415 	stw	ra,16(sp)
81109c24:	df000315 	stw	fp,12(sp)
81109c28:	df000304 	addi	fp,sp,12
81109c2c:	e13ffe15 	stw	r4,-8(fp)
81109c30:	2805883a 	mov	r2,r5
81109c34:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109c38:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109c3c:	e0bffe17 	ldw	r2,-8(fp)
81109c40:	10005726 	beq	r2,zero,81109da0 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81109c44:	00800044 	movi	r2,1
81109c48:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109c4c:	e0bfff03 	ldbu	r2,-4(fp)
81109c50:	10c00228 	cmpgeui	r3,r2,8
81109c54:	1800361e 	bne	r3,zero,81109d30 <bRmapInitCh+0x11c>
81109c58:	100690ba 	slli	r3,r2,2
81109c5c:	00a04474 	movhi	r2,33041
81109c60:	10a71c04 	addi	r2,r2,-25488
81109c64:	1885883a 	add	r2,r3,r2
81109c68:	10800017 	ldw	r2,0(r2)
81109c6c:	1000683a 	jmp	r2
81109c70:	81109c90 	cmplti	r4,r16,17010
81109c74:	81109ca4 	muli	r4,r16,17010
81109c78:	81109cb8 	rdprs	r4,r16,17010
81109c7c:	81109ccc 	andi	r4,r16,17011
81109c80:	81109ce0 	cmpeqi	r4,r16,17011
81109c84:	81109cf4 	orhi	r4,r16,17011
81109c88:	81109d08 	cmpgei	r4,r16,17012
81109c8c:	81109d1c 	xori	r4,r16,17012
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109c90:	e0fffe17 	ldw	r3,-8(fp)
81109c94:	00a04834 	movhi	r2,33056
81109c98:	108b0004 	addi	r2,r2,11264
81109c9c:	18800015 	stw	r2,0(r3)
			break;
81109ca0:	00002506 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109ca4:	e0fffe17 	ldw	r3,-8(fp)
81109ca8:	00a04834 	movhi	r2,33056
81109cac:	108a0004 	addi	r2,r2,10240
81109cb0:	18800015 	stw	r2,0(r3)
			break;
81109cb4:	00002006 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109cb8:	e0fffe17 	ldw	r3,-8(fp)
81109cbc:	00a04834 	movhi	r2,33056
81109cc0:	108b0004 	addi	r2,r2,11264
81109cc4:	18800015 	stw	r2,0(r3)
			break;
81109cc8:	00001b06 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109ccc:	e0fffe17 	ldw	r3,-8(fp)
81109cd0:	00a04834 	movhi	r2,33056
81109cd4:	108a0004 	addi	r2,r2,10240
81109cd8:	18800015 	stw	r2,0(r3)
			break;
81109cdc:	00001606 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109ce0:	e0fffe17 	ldw	r3,-8(fp)
81109ce4:	00a04834 	movhi	r2,33056
81109ce8:	108b0004 	addi	r2,r2,11264
81109cec:	18800015 	stw	r2,0(r3)
			break;
81109cf0:	00001106 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109cf4:	e0fffe17 	ldw	r3,-8(fp)
81109cf8:	00a04834 	movhi	r2,33056
81109cfc:	108a0004 	addi	r2,r2,10240
81109d00:	18800015 	stw	r2,0(r3)
			break;
81109d04:	00000c06 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109d08:	e0fffe17 	ldw	r3,-8(fp)
81109d0c:	00a04834 	movhi	r2,33056
81109d10:	108b0004 	addi	r2,r2,11264
81109d14:	18800015 	stw	r2,0(r3)
			break;
81109d18:	00000706 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109d1c:	e0fffe17 	ldw	r3,-8(fp)
81109d20:	00a04834 	movhi	r2,33056
81109d24:	108a0004 	addi	r2,r2,10240
81109d28:	18800015 	stw	r2,0(r3)
			break;
81109d2c:	00000206 	br	81109d38 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109d30:	e03ffd15 	stw	zero,-12(fp)
			break;
81109d34:	0001883a 	nop
		}

		if (bStatus) {
81109d38:	e0bffd17 	ldw	r2,-12(fp)
81109d3c:	10001826 	beq	r2,zero,81109da0 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109d40:	e13ffe17 	ldw	r4,-8(fp)
81109d44:	11078740 	call	81107874 <bRmapGetIrqControl>
81109d48:	1000011e 	bne	r2,zero,81109d50 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81109d4c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109d50:	e13ffe17 	ldw	r4,-8(fp)
81109d54:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
81109d58:	1000011e 	bne	r2,zero,81109d60 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81109d5c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109d60:	e13ffe17 	ldw	r4,-8(fp)
81109d64:	1107ae80 	call	81107ae8 <bRmapGetCodecStatus>
81109d68:	1000011e 	bne	r2,zero,81109d70 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81109d6c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109d70:	e13ffe17 	ldw	r4,-8(fp)
81109d74:	11080940 	call	81108094 <bRmapGetMemConfigArea>
81109d78:	1000011e 	bne	r2,zero,81109d80 <bRmapInitCh+0x16c>
				bStatus = FALSE;
81109d7c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81109d80:	e13ffe17 	ldw	r4,-8(fp)
81109d84:	11083680 	call	81108368 <bRmapGetMemConfigStat>
81109d88:	1000011e 	bne	r2,zero,81109d90 <bRmapInitCh+0x17c>
				bStatus = FALSE;
81109d8c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81109d90:	e13ffe17 	ldw	r4,-8(fp)
81109d94:	11094480 	call	81109448 <bRmapGetRmapMemHKArea>
81109d98:	1000011e 	bne	r2,zero,81109da0 <bRmapInitCh+0x18c>
				bStatus = FALSE;
81109d9c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109da0:	e0bffd17 	ldw	r2,-12(fp)
}
81109da4:	e037883a 	mov	sp,fp
81109da8:	dfc00117 	ldw	ra,4(sp)
81109dac:	df000017 	ldw	fp,0(sp)
81109db0:	dec00204 	addi	sp,sp,8
81109db4:	f800283a 	ret

81109db8 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109db8:	defffc04 	addi	sp,sp,-16
81109dbc:	de00012e 	bgeu	sp,et,81109dc4 <vRmapWriteReg+0xc>
81109dc0:	003b68fa 	trap	3
81109dc4:	df000315 	stw	fp,12(sp)
81109dc8:	df000304 	addi	fp,sp,12
81109dcc:	e13ffd15 	stw	r4,-12(fp)
81109dd0:	e17ffe15 	stw	r5,-8(fp)
81109dd4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109dd8:	e0bffe17 	ldw	r2,-8(fp)
81109ddc:	1085883a 	add	r2,r2,r2
81109de0:	1085883a 	add	r2,r2,r2
81109de4:	1007883a 	mov	r3,r2
81109de8:	e0bffd17 	ldw	r2,-12(fp)
81109dec:	10c5883a 	add	r2,r2,r3
81109df0:	e0ffff17 	ldw	r3,-4(fp)
81109df4:	10c00015 	stw	r3,0(r2)
}
81109df8:	0001883a 	nop
81109dfc:	e037883a 	mov	sp,fp
81109e00:	df000017 	ldw	fp,0(sp)
81109e04:	dec00104 	addi	sp,sp,4
81109e08:	f800283a 	ret

81109e0c <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109e0c:	defffc04 	addi	sp,sp,-16
81109e10:	de00012e 	bgeu	sp,et,81109e18 <uliRmapReadReg+0xc>
81109e14:	003b68fa 	trap	3
81109e18:	df000315 	stw	fp,12(sp)
81109e1c:	df000304 	addi	fp,sp,12
81109e20:	e13ffe15 	stw	r4,-8(fp)
81109e24:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109e28:	e0bfff17 	ldw	r2,-4(fp)
81109e2c:	1085883a 	add	r2,r2,r2
81109e30:	1085883a 	add	r2,r2,r2
81109e34:	1007883a 	mov	r3,r2
81109e38:	e0bffe17 	ldw	r2,-8(fp)
81109e3c:	10c5883a 	add	r2,r2,r3
81109e40:	10800017 	ldw	r2,0(r2)
81109e44:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109e48:	e0bffd17 	ldw	r2,-12(fp)
}
81109e4c:	e037883a 	mov	sp,fp
81109e50:	df000017 	ldw	fp,0(sp)
81109e54:	dec00104 	addi	sp,sp,4
81109e58:	f800283a 	ret

81109e5c <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109e5c:	defffd04 	addi	sp,sp,-12
81109e60:	de00012e 	bgeu	sp,et,81109e68 <uliConvRmapCfgAddr+0xc>
81109e64:	003b68fa 	trap	3
81109e68:	df000215 	stw	fp,8(sp)
81109e6c:	df000204 	addi	fp,sp,8
81109e70:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81109e74:	e0bfff17 	ldw	r2,-4(fp)
81109e78:	10801368 	cmpgeui	r2,r2,77
81109e7c:	10008a1e 	bne	r2,zero,8110a0a8 <uliConvRmapCfgAddr+0x24c>
81109e80:	e0bfff17 	ldw	r2,-4(fp)
81109e84:	100690ba 	slli	r3,r2,2
81109e88:	00a04474 	movhi	r2,33041
81109e8c:	10a7a704 	addi	r2,r2,-24932
81109e90:	1885883a 	add	r2,r3,r2
81109e94:	10800017 	ldw	r2,0(r2)
81109e98:	1000683a 	jmp	r2
81109e9c:	81109fd0 	cmplti	r4,r16,17023
81109ea0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ea4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ea8:	8110a0a8 	cmpgeui	r4,r16,17026
81109eac:	81109fdc 	xori	r4,r16,17023
81109eb0:	8110a0a8 	cmpgeui	r4,r16,17026
81109eb4:	8110a0a8 	cmpgeui	r4,r16,17026
81109eb8:	8110a0a8 	cmpgeui	r4,r16,17026
81109ebc:	81109fe8 	cmpgeui	r4,r16,17023
81109ec0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ec4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ec8:	8110a0a8 	cmpgeui	r4,r16,17026
81109ecc:	81109ff4 	orhi	r4,r16,17023
81109ed0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ed4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ed8:	8110a0a8 	cmpgeui	r4,r16,17026
81109edc:	8110a000 	call	88110a00 <__reset+0x20f0a00>
81109ee0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ee4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ee8:	8110a0a8 	cmpgeui	r4,r16,17026
81109eec:	8110a00c 	andi	r4,r16,17024
81109ef0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ef4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ef8:	8110a0a8 	cmpgeui	r4,r16,17026
81109efc:	8110a018 	cmpnei	r4,r16,17024
81109f00:	8110a0a8 	cmpgeui	r4,r16,17026
81109f04:	8110a0a8 	cmpgeui	r4,r16,17026
81109f08:	8110a0a8 	cmpgeui	r4,r16,17026
81109f0c:	8110a024 	muli	r4,r16,17024
81109f10:	8110a0a8 	cmpgeui	r4,r16,17026
81109f14:	8110a0a8 	cmpgeui	r4,r16,17026
81109f18:	8110a0a8 	cmpgeui	r4,r16,17026
81109f1c:	8110a030 	cmpltui	r4,r16,17024
81109f20:	8110a0a8 	cmpgeui	r4,r16,17026
81109f24:	8110a0a8 	cmpgeui	r4,r16,17026
81109f28:	8110a0a8 	cmpgeui	r4,r16,17026
81109f2c:	8110a03c 	xorhi	r4,r16,17024
81109f30:	8110a0a8 	cmpgeui	r4,r16,17026
81109f34:	8110a0a8 	cmpgeui	r4,r16,17026
81109f38:	8110a0a8 	cmpgeui	r4,r16,17026
81109f3c:	8110a048 	cmpgei	r4,r16,17025
81109f40:	8110a0a8 	cmpgeui	r4,r16,17026
81109f44:	8110a0a8 	cmpgeui	r4,r16,17026
81109f48:	8110a0a8 	cmpgeui	r4,r16,17026
81109f4c:	8110a054 	ori	r4,r16,17025
81109f50:	8110a0a8 	cmpgeui	r4,r16,17026
81109f54:	8110a0a8 	cmpgeui	r4,r16,17026
81109f58:	8110a0a8 	cmpgeui	r4,r16,17026
81109f5c:	8110a0a8 	cmpgeui	r4,r16,17026
81109f60:	8110a0a8 	cmpgeui	r4,r16,17026
81109f64:	8110a0a8 	cmpgeui	r4,r16,17026
81109f68:	8110a0a8 	cmpgeui	r4,r16,17026
81109f6c:	8110a0a8 	cmpgeui	r4,r16,17026
81109f70:	8110a0a8 	cmpgeui	r4,r16,17026
81109f74:	8110a0a8 	cmpgeui	r4,r16,17026
81109f78:	8110a0a8 	cmpgeui	r4,r16,17026
81109f7c:	8110a060 	cmpeqi	r4,r16,17025
81109f80:	8110a0a8 	cmpgeui	r4,r16,17026
81109f84:	8110a0a8 	cmpgeui	r4,r16,17026
81109f88:	8110a0a8 	cmpgeui	r4,r16,17026
81109f8c:	8110a06c 	andhi	r4,r16,17025
81109f90:	8110a0a8 	cmpgeui	r4,r16,17026
81109f94:	8110a0a8 	cmpgeui	r4,r16,17026
81109f98:	8110a0a8 	cmpgeui	r4,r16,17026
81109f9c:	8110a078 	rdprs	r4,r16,17025
81109fa0:	8110a0a8 	cmpgeui	r4,r16,17026
81109fa4:	8110a0a8 	cmpgeui	r4,r16,17026
81109fa8:	8110a0a8 	cmpgeui	r4,r16,17026
81109fac:	8110a084 	addi	r4,r16,17026
81109fb0:	8110a0a8 	cmpgeui	r4,r16,17026
81109fb4:	8110a0a8 	cmpgeui	r4,r16,17026
81109fb8:	8110a0a8 	cmpgeui	r4,r16,17026
81109fbc:	8110a090 	cmplti	r4,r16,17026
81109fc0:	8110a0a8 	cmpgeui	r4,r16,17026
81109fc4:	8110a0a8 	cmpgeui	r4,r16,17026
81109fc8:	8110a0a8 	cmpgeui	r4,r16,17026
81109fcc:	8110a09c 	xori	r4,r16,17026
	case 0x00000000:
		uliValue = 0x00000040;
81109fd0:	00801004 	movi	r2,64
81109fd4:	e0bffe15 	stw	r2,-8(fp)
		break;
81109fd8:	00003506 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81109fdc:	00801044 	movi	r2,65
81109fe0:	e0bffe15 	stw	r2,-8(fp)
		break;
81109fe4:	00003206 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81109fe8:	00801084 	movi	r2,66
81109fec:	e0bffe15 	stw	r2,-8(fp)
		break;
81109ff0:	00002f06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81109ff4:	008010c4 	movi	r2,67
81109ff8:	e0bffe15 	stw	r2,-8(fp)
		break;
81109ffc:	00002c06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a000:	00801104 	movi	r2,68
8110a004:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a008:	00002906 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a00c:	00801144 	movi	r2,69
8110a010:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a014:	00002606 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a018:	00801184 	movi	r2,70
8110a01c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a020:	00002306 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a024:	008011c4 	movi	r2,71
8110a028:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a02c:	00002006 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a030:	00801204 	movi	r2,72
8110a034:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a038:	00001d06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a03c:	00801244 	movi	r2,73
8110a040:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a044:	00001a06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a048:	00801284 	movi	r2,74
8110a04c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a050:	00001706 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a054:	008012c4 	movi	r2,75
8110a058:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a05c:	00001406 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a060:	00801304 	movi	r2,76
8110a064:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a068:	00001106 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a06c:	00801344 	movi	r2,77
8110a070:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a074:	00000e06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a078:	00801384 	movi	r2,78
8110a07c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a080:	00000b06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a084:	008013c4 	movi	r2,79
8110a088:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a08c:	00000806 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a090:	00801404 	movi	r2,80
8110a094:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a098:	00000506 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a09c:	00801444 	movi	r2,81
8110a0a0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0a4:	00000206 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a0a8:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a0ac:	0001883a 	nop
	}

	return uliValue;
8110a0b0:	e0bffe17 	ldw	r2,-8(fp)
}
8110a0b4:	e037883a 	mov	sp,fp
8110a0b8:	df000017 	ldw	fp,0(sp)
8110a0bc:	dec00104 	addi	sp,sp,4
8110a0c0:	f800283a 	ret

8110a0c4 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a0c4:	defffb04 	addi	sp,sp,-20
8110a0c8:	de00012e 	bgeu	sp,et,8110a0d0 <bSpwcSetLink+0xc>
8110a0cc:	003b68fa 	trap	3
8110a0d0:	dfc00415 	stw	ra,16(sp)
8110a0d4:	df000315 	stw	fp,12(sp)
8110a0d8:	df000304 	addi	fp,sp,12
8110a0dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a0e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a0e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a0e8:	e0bfff17 	ldw	r2,-4(fp)
8110a0ec:	10003c26 	beq	r2,zero,8110a1e0 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a0f0:	e0bfff17 	ldw	r2,-4(fp)
8110a0f4:	10800017 	ldw	r2,0(r2)
8110a0f8:	000b883a 	mov	r5,zero
8110a0fc:	1009883a 	mov	r4,r2
8110a100:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a104:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a108:	e0bfff17 	ldw	r2,-4(fp)
8110a10c:	10800117 	ldw	r2,4(r2)
8110a110:	10000426 	beq	r2,zero,8110a124 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a114:	e0bffe17 	ldw	r2,-8(fp)
8110a118:	10800114 	ori	r2,r2,4
8110a11c:	e0bffe15 	stw	r2,-8(fp)
8110a120:	00000406 	br	8110a134 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a124:	e0fffe17 	ldw	r3,-8(fp)
8110a128:	00bffec4 	movi	r2,-5
8110a12c:	1884703a 	and	r2,r3,r2
8110a130:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a134:	e0bfff17 	ldw	r2,-4(fp)
8110a138:	10800217 	ldw	r2,8(r2)
8110a13c:	10000426 	beq	r2,zero,8110a150 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a140:	e0bffe17 	ldw	r2,-8(fp)
8110a144:	10800094 	ori	r2,r2,2
8110a148:	e0bffe15 	stw	r2,-8(fp)
8110a14c:	00000406 	br	8110a160 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a150:	e0fffe17 	ldw	r3,-8(fp)
8110a154:	00bfff44 	movi	r2,-3
8110a158:	1884703a 	and	r2,r3,r2
8110a15c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a160:	e0bfff17 	ldw	r2,-4(fp)
8110a164:	10800317 	ldw	r2,12(r2)
8110a168:	10000426 	beq	r2,zero,8110a17c <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a16c:	e0bffe17 	ldw	r2,-8(fp)
8110a170:	10800054 	ori	r2,r2,1
8110a174:	e0bffe15 	stw	r2,-8(fp)
8110a178:	00000406 	br	8110a18c <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a17c:	e0fffe17 	ldw	r3,-8(fp)
8110a180:	00bfff84 	movi	r2,-2
8110a184:	1884703a 	and	r2,r3,r2
8110a188:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a18c:	e0fffe17 	ldw	r3,-8(fp)
8110a190:	00804034 	movhi	r2,256
8110a194:	10bfffc4 	addi	r2,r2,-1
8110a198:	1884703a 	and	r2,r3,r2
8110a19c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a1a0:	e0bfff17 	ldw	r2,-4(fp)
8110a1a4:	10800403 	ldbu	r2,16(r2)
8110a1a8:	10803fcc 	andi	r2,r2,255
8110a1ac:	1004963a 	slli	r2,r2,24
8110a1b0:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a1b4:	e0bffe17 	ldw	r2,-8(fp)
8110a1b8:	10c4b03a 	or	r2,r2,r3
8110a1bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a1c0:	e0bfff17 	ldw	r2,-4(fp)
8110a1c4:	10800017 	ldw	r2,0(r2)
8110a1c8:	e1bffe17 	ldw	r6,-8(fp)
8110a1cc:	000b883a 	mov	r5,zero
8110a1d0:	1009883a 	mov	r4,r2
8110a1d4:	110a73c0 	call	8110a73c <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a1d8:	00800044 	movi	r2,1
8110a1dc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a1e0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a1e4:	e037883a 	mov	sp,fp
8110a1e8:	dfc00117 	ldw	ra,4(sp)
8110a1ec:	df000017 	ldw	fp,0(sp)
8110a1f0:	dec00204 	addi	sp,sp,8
8110a1f4:	f800283a 	ret

8110a1f8 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a1f8:	defffb04 	addi	sp,sp,-20
8110a1fc:	de00012e 	bgeu	sp,et,8110a204 <bSpwcGetLink+0xc>
8110a200:	003b68fa 	trap	3
8110a204:	dfc00415 	stw	ra,16(sp)
8110a208:	df000315 	stw	fp,12(sp)
8110a20c:	df000304 	addi	fp,sp,12
8110a210:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a214:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a218:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a21c:	e0bfff17 	ldw	r2,-4(fp)
8110a220:	10002826 	beq	r2,zero,8110a2c4 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a224:	e0bfff17 	ldw	r2,-4(fp)
8110a228:	10800017 	ldw	r2,0(r2)
8110a22c:	000b883a 	mov	r5,zero
8110a230:	1009883a 	mov	r4,r2
8110a234:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a238:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a23c:	e0bffe17 	ldw	r2,-8(fp)
8110a240:	1080010c 	andi	r2,r2,4
8110a244:	10000426 	beq	r2,zero,8110a258 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a248:	e0bfff17 	ldw	r2,-4(fp)
8110a24c:	00c00044 	movi	r3,1
8110a250:	10c00115 	stw	r3,4(r2)
8110a254:	00000206 	br	8110a260 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a258:	e0bfff17 	ldw	r2,-4(fp)
8110a25c:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a260:	e0bffe17 	ldw	r2,-8(fp)
8110a264:	1080008c 	andi	r2,r2,2
8110a268:	10000426 	beq	r2,zero,8110a27c <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a26c:	e0bfff17 	ldw	r2,-4(fp)
8110a270:	00c00044 	movi	r3,1
8110a274:	10c00215 	stw	r3,8(r2)
8110a278:	00000206 	br	8110a284 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a27c:	e0bfff17 	ldw	r2,-4(fp)
8110a280:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a284:	e0bffe17 	ldw	r2,-8(fp)
8110a288:	1080004c 	andi	r2,r2,1
8110a28c:	10000426 	beq	r2,zero,8110a2a0 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a290:	e0bfff17 	ldw	r2,-4(fp)
8110a294:	00c00044 	movi	r3,1
8110a298:	10c00315 	stw	r3,12(r2)
8110a29c:	00000206 	br	8110a2a8 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a2a0:	e0bfff17 	ldw	r2,-4(fp)
8110a2a4:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a2a8:	e0bffe17 	ldw	r2,-8(fp)
8110a2ac:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a2b0:	1007883a 	mov	r3,r2
8110a2b4:	e0bfff17 	ldw	r2,-4(fp)
8110a2b8:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a2bc:	00800044 	movi	r2,1
8110a2c0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a2c4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a2c8:	e037883a 	mov	sp,fp
8110a2cc:	dfc00117 	ldw	ra,4(sp)
8110a2d0:	df000017 	ldw	fp,0(sp)
8110a2d4:	dec00204 	addi	sp,sp,8
8110a2d8:	f800283a 	ret

8110a2dc <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a2dc:	defffb04 	addi	sp,sp,-20
8110a2e0:	de00012e 	bgeu	sp,et,8110a2e8 <bSpwcGetLinkError+0xc>
8110a2e4:	003b68fa 	trap	3
8110a2e8:	dfc00415 	stw	ra,16(sp)
8110a2ec:	df000315 	stw	fp,12(sp)
8110a2f0:	df000304 	addi	fp,sp,12
8110a2f4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a2f8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a2fc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a300:	e0bfff17 	ldw	r2,-4(fp)
8110a304:	10002c26 	beq	r2,zero,8110a3b8 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a308:	e0bfff17 	ldw	r2,-4(fp)
8110a30c:	10800017 	ldw	r2,0(r2)
8110a310:	000b883a 	mov	r5,zero
8110a314:	1009883a 	mov	r4,r2
8110a318:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a31c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a320:	e0bffe17 	ldw	r2,-8(fp)
8110a324:	1080006c 	andhi	r2,r2,1
8110a328:	10000426 	beq	r2,zero,8110a33c <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a32c:	e0bfff17 	ldw	r2,-4(fp)
8110a330:	00c00044 	movi	r3,1
8110a334:	10c00515 	stw	r3,20(r2)
8110a338:	00000206 	br	8110a344 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a33c:	e0bfff17 	ldw	r2,-4(fp)
8110a340:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a344:	e0bffe17 	ldw	r2,-8(fp)
8110a348:	108000ac 	andhi	r2,r2,2
8110a34c:	10000426 	beq	r2,zero,8110a360 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a350:	e0bfff17 	ldw	r2,-4(fp)
8110a354:	00c00044 	movi	r3,1
8110a358:	10c00615 	stw	r3,24(r2)
8110a35c:	00000206 	br	8110a368 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a360:	e0bfff17 	ldw	r2,-4(fp)
8110a364:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a368:	e0bffe17 	ldw	r2,-8(fp)
8110a36c:	1080012c 	andhi	r2,r2,4
8110a370:	10000426 	beq	r2,zero,8110a384 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110a374:	e0bfff17 	ldw	r2,-4(fp)
8110a378:	00c00044 	movi	r3,1
8110a37c:	10c00715 	stw	r3,28(r2)
8110a380:	00000206 	br	8110a38c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110a384:	e0bfff17 	ldw	r2,-4(fp)
8110a388:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110a38c:	e0bffe17 	ldw	r2,-8(fp)
8110a390:	1080022c 	andhi	r2,r2,8
8110a394:	10000426 	beq	r2,zero,8110a3a8 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110a398:	e0bfff17 	ldw	r2,-4(fp)
8110a39c:	00c00044 	movi	r3,1
8110a3a0:	10c00815 	stw	r3,32(r2)
8110a3a4:	00000206 	br	8110a3b0 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110a3a8:	e0bfff17 	ldw	r2,-4(fp)
8110a3ac:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110a3b0:	00800044 	movi	r2,1
8110a3b4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a3b8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a3bc:	e037883a 	mov	sp,fp
8110a3c0:	dfc00117 	ldw	ra,4(sp)
8110a3c4:	df000017 	ldw	fp,0(sp)
8110a3c8:	dec00204 	addi	sp,sp,8
8110a3cc:	f800283a 	ret

8110a3d0 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110a3d0:	defffb04 	addi	sp,sp,-20
8110a3d4:	de00012e 	bgeu	sp,et,8110a3dc <bSpwcGetLinkStatus+0xc>
8110a3d8:	003b68fa 	trap	3
8110a3dc:	dfc00415 	stw	ra,16(sp)
8110a3e0:	df000315 	stw	fp,12(sp)
8110a3e4:	df000304 	addi	fp,sp,12
8110a3e8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a3ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a3f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a3f4:	e0bfff17 	ldw	r2,-4(fp)
8110a3f8:	10002326 	beq	r2,zero,8110a488 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a3fc:	e0bfff17 	ldw	r2,-4(fp)
8110a400:	10800017 	ldw	r2,0(r2)
8110a404:	000b883a 	mov	r5,zero
8110a408:	1009883a 	mov	r4,r2
8110a40c:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a410:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110a414:	e0bffe17 	ldw	r2,-8(fp)
8110a418:	1081000c 	andi	r2,r2,1024
8110a41c:	10000426 	beq	r2,zero,8110a430 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110a420:	e0bfff17 	ldw	r2,-4(fp)
8110a424:	00c00044 	movi	r3,1
8110a428:	10c00915 	stw	r3,36(r2)
8110a42c:	00000206 	br	8110a438 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110a430:	e0bfff17 	ldw	r2,-4(fp)
8110a434:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110a438:	e0bffe17 	ldw	r2,-8(fp)
8110a43c:	1080800c 	andi	r2,r2,512
8110a440:	10000426 	beq	r2,zero,8110a454 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110a444:	e0bfff17 	ldw	r2,-4(fp)
8110a448:	00c00044 	movi	r3,1
8110a44c:	10c00a15 	stw	r3,40(r2)
8110a450:	00000206 	br	8110a45c <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a454:	e0bfff17 	ldw	r2,-4(fp)
8110a458:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a45c:	e0bffe17 	ldw	r2,-8(fp)
8110a460:	1080400c 	andi	r2,r2,256
8110a464:	10000426 	beq	r2,zero,8110a478 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a468:	e0bfff17 	ldw	r2,-4(fp)
8110a46c:	00c00044 	movi	r3,1
8110a470:	10c00b15 	stw	r3,44(r2)
8110a474:	00000206 	br	8110a480 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a478:	e0bfff17 	ldw	r2,-4(fp)
8110a47c:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a480:	00800044 	movi	r2,1
8110a484:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a488:	e0bffd17 	ldw	r2,-12(fp)
}
8110a48c:	e037883a 	mov	sp,fp
8110a490:	dfc00117 	ldw	ra,4(sp)
8110a494:	df000017 	ldw	fp,0(sp)
8110a498:	dec00204 	addi	sp,sp,8
8110a49c:	f800283a 	ret

8110a4a0 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a4a0:	defffb04 	addi	sp,sp,-20
8110a4a4:	de00012e 	bgeu	sp,et,8110a4ac <bSpwcGetTimecode+0xc>
8110a4a8:	003b68fa 	trap	3
8110a4ac:	dfc00415 	stw	ra,16(sp)
8110a4b0:	df000315 	stw	fp,12(sp)
8110a4b4:	df000304 	addi	fp,sp,12
8110a4b8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a4bc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a4c0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a4c4:	e0bfff17 	ldw	r2,-4(fp)
8110a4c8:	10001326 	beq	r2,zero,8110a518 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a4cc:	e0bfff17 	ldw	r2,-4(fp)
8110a4d0:	10800017 	ldw	r2,0(r2)
8110a4d4:	01400044 	movi	r5,1
8110a4d8:	1009883a 	mov	r4,r2
8110a4dc:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a4e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a4e4:	e0bffe17 	ldw	r2,-8(fp)
8110a4e8:	1080300c 	andi	r2,r2,192
8110a4ec:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a4f0:	1007883a 	mov	r3,r2
8110a4f4:	e0bfff17 	ldw	r2,-4(fp)
8110a4f8:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a4fc:	e0bffe17 	ldw	r2,-8(fp)
8110a500:	10800fcc 	andi	r2,r2,63
8110a504:	1007883a 	mov	r3,r2
8110a508:	e0bfff17 	ldw	r2,-4(fp)
8110a50c:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a510:	00800044 	movi	r2,1
8110a514:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a518:	e0bffd17 	ldw	r2,-12(fp)
}
8110a51c:	e037883a 	mov	sp,fp
8110a520:	dfc00117 	ldw	ra,4(sp)
8110a524:	df000017 	ldw	fp,0(sp)
8110a528:	dec00204 	addi	sp,sp,8
8110a52c:	f800283a 	ret

8110a530 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a530:	defffb04 	addi	sp,sp,-20
8110a534:	de00012e 	bgeu	sp,et,8110a53c <bSpwcClearTimecode+0xc>
8110a538:	003b68fa 	trap	3
8110a53c:	dfc00415 	stw	ra,16(sp)
8110a540:	df000315 	stw	fp,12(sp)
8110a544:	df000304 	addi	fp,sp,12
8110a548:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a54c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a550:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a554:	e0bfff17 	ldw	r2,-4(fp)
8110a558:	10001126 	beq	r2,zero,8110a5a0 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a55c:	e0bfff17 	ldw	r2,-4(fp)
8110a560:	10800017 	ldw	r2,0(r2)
8110a564:	01400044 	movi	r5,1
8110a568:	1009883a 	mov	r4,r2
8110a56c:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a570:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a574:	e0bffe17 	ldw	r2,-8(fp)
8110a578:	10804014 	ori	r2,r2,256
8110a57c:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a580:	e0bfff17 	ldw	r2,-4(fp)
8110a584:	10800017 	ldw	r2,0(r2)
8110a588:	e1bffe17 	ldw	r6,-8(fp)
8110a58c:	01400044 	movi	r5,1
8110a590:	1009883a 	mov	r4,r2
8110a594:	110a73c0 	call	8110a73c <vSpwcWriteReg>
		bStatus = TRUE;
8110a598:	00800044 	movi	r2,1
8110a59c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a5a0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a5a4:	e037883a 	mov	sp,fp
8110a5a8:	dfc00117 	ldw	ra,4(sp)
8110a5ac:	df000017 	ldw	fp,0(sp)
8110a5b0:	dec00204 	addi	sp,sp,8
8110a5b4:	f800283a 	ret

8110a5b8 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a5b8:	defffb04 	addi	sp,sp,-20
8110a5bc:	de00012e 	bgeu	sp,et,8110a5c4 <bSpwcInitCh+0xc>
8110a5c0:	003b68fa 	trap	3
8110a5c4:	dfc00415 	stw	ra,16(sp)
8110a5c8:	df000315 	stw	fp,12(sp)
8110a5cc:	df000304 	addi	fp,sp,12
8110a5d0:	e13ffe15 	stw	r4,-8(fp)
8110a5d4:	2805883a 	mov	r2,r5
8110a5d8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a5dc:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a5e0:	e0bffe17 	ldw	r2,-8(fp)
8110a5e4:	10004f26 	beq	r2,zero,8110a724 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a5e8:	00800044 	movi	r2,1
8110a5ec:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a5f0:	e0bfff03 	ldbu	r2,-4(fp)
8110a5f4:	10c00228 	cmpgeui	r3,r2,8
8110a5f8:	1800361e 	bne	r3,zero,8110a6d4 <bSpwcInitCh+0x11c>
8110a5fc:	100690ba 	slli	r3,r2,2
8110a600:	00a04474 	movhi	r2,33041
8110a604:	10a98504 	addi	r2,r2,-23020
8110a608:	1885883a 	add	r2,r3,r2
8110a60c:	10800017 	ldw	r2,0(r2)
8110a610:	1000683a 	jmp	r2
8110a614:	8110a634 	orhi	r4,r16,17048
8110a618:	8110a648 	cmpgei	r4,r16,17049
8110a61c:	8110a65c 	xori	r4,r16,17049
8110a620:	8110a670 	cmpltui	r4,r16,17049
8110a624:	8110a684 	addi	r4,r16,17050
8110a628:	8110a698 	cmpnei	r4,r16,17050
8110a62c:	8110a6ac 	andhi	r4,r16,17050
8110a630:	8110a6c0 	call	88110a6c <__reset+0x20f0a6c>
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a634:	e0fffe17 	ldw	r3,-8(fp)
8110a638:	00a04834 	movhi	r2,33056
8110a63c:	108b0004 	addi	r2,r2,11264
8110a640:	18800015 	stw	r2,0(r3)
			break;
8110a644:	00002506 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a648:	e0fffe17 	ldw	r3,-8(fp)
8110a64c:	00a04834 	movhi	r2,33056
8110a650:	108a0004 	addi	r2,r2,10240
8110a654:	18800015 	stw	r2,0(r3)
			break;
8110a658:	00002006 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a65c:	e0fffe17 	ldw	r3,-8(fp)
8110a660:	00a04834 	movhi	r2,33056
8110a664:	108b0004 	addi	r2,r2,11264
8110a668:	18800015 	stw	r2,0(r3)
			break;
8110a66c:	00001b06 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a670:	e0fffe17 	ldw	r3,-8(fp)
8110a674:	00a04834 	movhi	r2,33056
8110a678:	108a0004 	addi	r2,r2,10240
8110a67c:	18800015 	stw	r2,0(r3)
			break;
8110a680:	00001606 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a684:	e0fffe17 	ldw	r3,-8(fp)
8110a688:	00a04834 	movhi	r2,33056
8110a68c:	108b0004 	addi	r2,r2,11264
8110a690:	18800015 	stw	r2,0(r3)
			break;
8110a694:	00001106 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a698:	e0fffe17 	ldw	r3,-8(fp)
8110a69c:	00a04834 	movhi	r2,33056
8110a6a0:	108a0004 	addi	r2,r2,10240
8110a6a4:	18800015 	stw	r2,0(r3)
			break;
8110a6a8:	00000c06 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a6ac:	e0fffe17 	ldw	r3,-8(fp)
8110a6b0:	00a04834 	movhi	r2,33056
8110a6b4:	108b0004 	addi	r2,r2,11264
8110a6b8:	18800015 	stw	r2,0(r3)
			break;
8110a6bc:	00000706 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a6c0:	e0fffe17 	ldw	r3,-8(fp)
8110a6c4:	00a04834 	movhi	r2,33056
8110a6c8:	108a0004 	addi	r2,r2,10240
8110a6cc:	18800015 	stw	r2,0(r3)
			break;
8110a6d0:	00000206 	br	8110a6dc <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a6d4:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a6d8:	0001883a 	nop
		}

		if (bStatus) {
8110a6dc:	e0bffd17 	ldw	r2,-12(fp)
8110a6e0:	10001026 	beq	r2,zero,8110a724 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a6e4:	e13ffe17 	ldw	r4,-8(fp)
8110a6e8:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
8110a6ec:	1000011e 	bne	r2,zero,8110a6f4 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a6f0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a6f4:	e13ffe17 	ldw	r4,-8(fp)
8110a6f8:	110a2dc0 	call	8110a2dc <bSpwcGetLinkError>
8110a6fc:	1000011e 	bne	r2,zero,8110a704 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a700:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a704:	e13ffe17 	ldw	r4,-8(fp)
8110a708:	110a3d00 	call	8110a3d0 <bSpwcGetLinkStatus>
8110a70c:	1000011e 	bne	r2,zero,8110a714 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a710:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a714:	e13ffe17 	ldw	r4,-8(fp)
8110a718:	110a4a00 	call	8110a4a0 <bSpwcGetTimecode>
8110a71c:	1000011e 	bne	r2,zero,8110a724 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a720:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a724:	e0bffd17 	ldw	r2,-12(fp)
}
8110a728:	e037883a 	mov	sp,fp
8110a72c:	dfc00117 	ldw	ra,4(sp)
8110a730:	df000017 	ldw	fp,0(sp)
8110a734:	dec00204 	addi	sp,sp,8
8110a738:	f800283a 	ret

8110a73c <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a73c:	defffc04 	addi	sp,sp,-16
8110a740:	de00012e 	bgeu	sp,et,8110a748 <vSpwcWriteReg+0xc>
8110a744:	003b68fa 	trap	3
8110a748:	df000315 	stw	fp,12(sp)
8110a74c:	df000304 	addi	fp,sp,12
8110a750:	e13ffd15 	stw	r4,-12(fp)
8110a754:	e17ffe15 	stw	r5,-8(fp)
8110a758:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a75c:	e0bffe17 	ldw	r2,-8(fp)
8110a760:	1085883a 	add	r2,r2,r2
8110a764:	1085883a 	add	r2,r2,r2
8110a768:	1007883a 	mov	r3,r2
8110a76c:	e0bffd17 	ldw	r2,-12(fp)
8110a770:	10c5883a 	add	r2,r2,r3
8110a774:	e0ffff17 	ldw	r3,-4(fp)
8110a778:	10c00015 	stw	r3,0(r2)
}
8110a77c:	0001883a 	nop
8110a780:	e037883a 	mov	sp,fp
8110a784:	df000017 	ldw	fp,0(sp)
8110a788:	dec00104 	addi	sp,sp,4
8110a78c:	f800283a 	ret

8110a790 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a790:	defffc04 	addi	sp,sp,-16
8110a794:	de00012e 	bgeu	sp,et,8110a79c <uliSpwcReadReg+0xc>
8110a798:	003b68fa 	trap	3
8110a79c:	df000315 	stw	fp,12(sp)
8110a7a0:	df000304 	addi	fp,sp,12
8110a7a4:	e13ffe15 	stw	r4,-8(fp)
8110a7a8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a7ac:	e0bfff17 	ldw	r2,-4(fp)
8110a7b0:	1085883a 	add	r2,r2,r2
8110a7b4:	1085883a 	add	r2,r2,r2
8110a7b8:	1007883a 	mov	r3,r2
8110a7bc:	e0bffe17 	ldw	r2,-8(fp)
8110a7c0:	10c5883a 	add	r2,r2,r3
8110a7c4:	10800017 	ldw	r2,0(r2)
8110a7c8:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a7cc:	e0bffd17 	ldw	r2,-12(fp)
}
8110a7d0:	e037883a 	mov	sp,fp
8110a7d4:	df000017 	ldw	fp,0(sp)
8110a7d8:	dec00104 	addi	sp,sp,4
8110a7dc:	f800283a 	ret

8110a7e0 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a7e0:	defffe04 	addi	sp,sp,-8
8110a7e4:	de00012e 	bgeu	sp,et,8110a7ec <bEnableIsoDrivers+0xc>
8110a7e8:	003b68fa 	trap	3
8110a7ec:	dfc00115 	stw	ra,4(sp)
8110a7f0:	df000015 	stw	fp,0(sp)
8110a7f4:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a7f8:	01400204 	movi	r5,8
8110a7fc:	01000044 	movi	r4,1
8110a800:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a804:	00800044 	movi	r2,1
}
8110a808:	e037883a 	mov	sp,fp
8110a80c:	dfc00117 	ldw	ra,4(sp)
8110a810:	df000017 	ldw	fp,0(sp)
8110a814:	dec00204 	addi	sp,sp,8
8110a818:	f800283a 	ret

8110a81c <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a81c:	defffe04 	addi	sp,sp,-8
8110a820:	de00012e 	bgeu	sp,et,8110a828 <bDisableIsoDrivers+0xc>
8110a824:	003b68fa 	trap	3
8110a828:	dfc00115 	stw	ra,4(sp)
8110a82c:	df000015 	stw	fp,0(sp)
8110a830:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a834:	01400204 	movi	r5,8
8110a838:	0009883a 	mov	r4,zero
8110a83c:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a840:	00800044 	movi	r2,1
}
8110a844:	e037883a 	mov	sp,fp
8110a848:	dfc00117 	ldw	ra,4(sp)
8110a84c:	df000017 	ldw	fp,0(sp)
8110a850:	dec00204 	addi	sp,sp,8
8110a854:	f800283a 	ret

8110a858 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a858:	defffe04 	addi	sp,sp,-8
8110a85c:	de00012e 	bgeu	sp,et,8110a864 <bEnableLvdsBoard+0xc>
8110a860:	003b68fa 	trap	3
8110a864:	dfc00115 	stw	ra,4(sp)
8110a868:	df000015 	stw	fp,0(sp)
8110a86c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a870:	01400104 	movi	r5,4
8110a874:	01000044 	movi	r4,1
8110a878:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a87c:	00800044 	movi	r2,1
}
8110a880:	e037883a 	mov	sp,fp
8110a884:	dfc00117 	ldw	ra,4(sp)
8110a888:	df000017 	ldw	fp,0(sp)
8110a88c:	dec00204 	addi	sp,sp,8
8110a890:	f800283a 	ret

8110a894 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a894:	defffe04 	addi	sp,sp,-8
8110a898:	de00012e 	bgeu	sp,et,8110a8a0 <bDisableLvdsBoard+0xc>
8110a89c:	003b68fa 	trap	3
8110a8a0:	dfc00115 	stw	ra,4(sp)
8110a8a4:	df000015 	stw	fp,0(sp)
8110a8a8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a8ac:	01400104 	movi	r5,4
8110a8b0:	0009883a 	mov	r4,zero
8110a8b4:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a8b8:	00800044 	movi	r2,1
}
8110a8bc:	e037883a 	mov	sp,fp
8110a8c0:	dfc00117 	ldw	ra,4(sp)
8110a8c4:	df000017 	ldw	fp,0(sp)
8110a8c8:	dec00204 	addi	sp,sp,8
8110a8cc:	f800283a 	ret

8110a8d0 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a8d0:	defffd04 	addi	sp,sp,-12
8110a8d4:	de00012e 	bgeu	sp,et,8110a8dc <bSetPreEmphasys+0xc>
8110a8d8:	003b68fa 	trap	3
8110a8dc:	dfc00215 	stw	ra,8(sp)
8110a8e0:	df000115 	stw	fp,4(sp)
8110a8e4:	df000104 	addi	fp,sp,4
8110a8e8:	2005883a 	mov	r2,r4
8110a8ec:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a8f0:	e0bfff03 	ldbu	r2,-4(fp)
8110a8f4:	10c00060 	cmpeqi	r3,r2,1
8110a8f8:	18000d1e 	bne	r3,zero,8110a930 <bSetPreEmphasys+0x60>
8110a8fc:	10c00088 	cmpgei	r3,r2,2
8110a900:	1800021e 	bne	r3,zero,8110a90c <bSetPreEmphasys+0x3c>
8110a904:	10000626 	beq	r2,zero,8110a920 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a908:	00001b06 	br	8110a978 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110a90c:	10c000a0 	cmpeqi	r3,r2,2
8110a910:	18000e1e 	bne	r3,zero,8110a94c <bSetPreEmphasys+0x7c>
8110a914:	108000e0 	cmpeqi	r2,r2,3
8110a918:	1000131e 	bne	r2,zero,8110a968 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a91c:	00001606 	br	8110a978 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a920:	014000c4 	movi	r5,3
8110a924:	0009883a 	mov	r4,zero
8110a928:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a92c:	00001206 	br	8110a978 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110a930:	01400084 	movi	r5,2
8110a934:	0009883a 	mov	r4,zero
8110a938:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110a93c:	01400044 	movi	r5,1
8110a940:	01000044 	movi	r4,1
8110a944:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a948:	00000b06 	br	8110a978 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110a94c:	01400044 	movi	r5,1
8110a950:	0009883a 	mov	r4,zero
8110a954:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110a958:	01400084 	movi	r5,2
8110a95c:	01000044 	movi	r4,1
8110a960:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a964:	00000406 	br	8110a978 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a968:	014000c4 	movi	r5,3
8110a96c:	01000044 	movi	r4,1
8110a970:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a974:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110a978:	00800044 	movi	r2,1
}
8110a97c:	e037883a 	mov	sp,fp
8110a980:	dfc00117 	ldw	ra,4(sp)
8110a984:	df000017 	ldw	fp,0(sp)
8110a988:	dec00204 	addi	sp,sp,8
8110a98c:	f800283a 	ret

8110a990 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110a990:	defffd04 	addi	sp,sp,-12
8110a994:	de00012e 	bgeu	sp,et,8110a99c <bCtrlIoLvdsDrive+0xc>
8110a998:	003b68fa 	trap	3
8110a99c:	df000215 	stw	fp,8(sp)
8110a9a0:	df000204 	addi	fp,sp,8
8110a9a4:	e13ffe15 	stw	r4,-8(fp)
8110a9a8:	2805883a 	mov	r2,r5
8110a9ac:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110a9b0:	e0bffe17 	ldw	r2,-8(fp)
8110a9b4:	1000071e 	bne	r2,zero,8110a9d4 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110a9b8:	e0bfff03 	ldbu	r2,-4(fp)
8110a9bc:	0084303a 	nor	r2,zero,r2
8110a9c0:	1007883a 	mov	r3,r2
8110a9c4:	d0a00103 	ldbu	r2,-32764(gp)
8110a9c8:	1884703a 	and	r2,r3,r2
8110a9cc:	d0a00105 	stb	r2,-32764(gp)
8110a9d0:	00000406 	br	8110a9e4 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110a9d4:	d0e00103 	ldbu	r3,-32764(gp)
8110a9d8:	e0bfff03 	ldbu	r2,-4(fp)
8110a9dc:	1884b03a 	or	r2,r3,r2
8110a9e0:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110a9e4:	d0a00103 	ldbu	r2,-32764(gp)
8110a9e8:	10c03fcc 	andi	r3,r2,255
8110a9ec:	00a00034 	movhi	r2,32768
8110a9f0:	10822804 	addi	r2,r2,2208
8110a9f4:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110a9f8:	00800044 	movi	r2,1
}
8110a9fc:	e037883a 	mov	sp,fp
8110aa00:	df000017 	ldw	fp,0(sp)
8110aa04:	dec00104 	addi	sp,sp,4
8110aa08:	f800283a 	ret

8110aa0c <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110aa0c:	defffa04 	addi	sp,sp,-24
8110aa10:	de00012e 	bgeu	sp,et,8110aa18 <I2C_TestAdress+0xc>
8110aa14:	003b68fa 	trap	3
8110aa18:	dfc00515 	stw	ra,20(sp)
8110aa1c:	df000415 	stw	fp,16(sp)
8110aa20:	df000404 	addi	fp,sp,16
8110aa24:	e13ffd15 	stw	r4,-12(fp)
8110aa28:	e17ffe15 	stw	r5,-8(fp)
8110aa2c:	3005883a 	mov	r2,r6
8110aa30:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aa34:	00800044 	movi	r2,1
8110aa38:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110aa3c:	e17ffe17 	ldw	r5,-8(fp)
8110aa40:	e13ffd17 	ldw	r4,-12(fp)
8110aa44:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110aa48:	e0bfff03 	ldbu	r2,-4(fp)
8110aa4c:	10803fcc 	andi	r2,r2,255
8110aa50:	100d883a 	mov	r6,r2
8110aa54:	e17ffe17 	ldw	r5,-8(fp)
8110aa58:	e13ffd17 	ldw	r4,-12(fp)
8110aa5c:	110aef00 	call	8110aef0 <i2c_write>
8110aa60:	1000011e 	bne	r2,zero,8110aa68 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110aa64:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110aa68:	e17ffe17 	ldw	r5,-8(fp)
8110aa6c:	e13ffd17 	ldw	r4,-12(fp)
8110aa70:	110ae700 	call	8110ae70 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110aa74:	0106d604 	movi	r4,7000
8110aa78:	11390300 	call	81139030 <usleep>
    
    return bSuccess;
8110aa7c:	e0bffc17 	ldw	r2,-16(fp)

}
8110aa80:	e037883a 	mov	sp,fp
8110aa84:	dfc00117 	ldw	ra,4(sp)
8110aa88:	df000017 	ldw	fp,0(sp)
8110aa8c:	dec00204 	addi	sp,sp,8
8110aa90:	f800283a 	ret

8110aa94 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110aa94:	defff804 	addi	sp,sp,-32
8110aa98:	de00012e 	bgeu	sp,et,8110aaa0 <I2C_Write+0xc>
8110aa9c:	003b68fa 	trap	3
8110aaa0:	dfc00715 	stw	ra,28(sp)
8110aaa4:	df000615 	stw	fp,24(sp)
8110aaa8:	df000604 	addi	fp,sp,24
8110aaac:	e13ffb15 	stw	r4,-20(fp)
8110aab0:	e17ffc15 	stw	r5,-16(fp)
8110aab4:	3009883a 	mov	r4,r6
8110aab8:	3807883a 	mov	r3,r7
8110aabc:	e0800217 	ldw	r2,8(fp)
8110aac0:	e13ffd05 	stb	r4,-12(fp)
8110aac4:	e0fffe05 	stb	r3,-8(fp)
8110aac8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aacc:	00800044 	movi	r2,1
8110aad0:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110aad4:	e17ffc17 	ldw	r5,-16(fp)
8110aad8:	e13ffb17 	ldw	r4,-20(fp)
8110aadc:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110aae0:	e0bffd03 	ldbu	r2,-12(fp)
8110aae4:	10803fcc 	andi	r2,r2,255
8110aae8:	100d883a 	mov	r6,r2
8110aaec:	e17ffc17 	ldw	r5,-16(fp)
8110aaf0:	e13ffb17 	ldw	r4,-20(fp)
8110aaf4:	110aef00 	call	8110aef0 <i2c_write>
8110aaf8:	1000011e 	bne	r2,zero,8110ab00 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110aafc:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110ab00:	e0bffa17 	ldw	r2,-24(fp)
8110ab04:	10000726 	beq	r2,zero,8110ab24 <I2C_Write+0x90>
8110ab08:	e0bffe03 	ldbu	r2,-8(fp)
8110ab0c:	100d883a 	mov	r6,r2
8110ab10:	e17ffc17 	ldw	r5,-16(fp)
8110ab14:	e13ffb17 	ldw	r4,-20(fp)
8110ab18:	110aef00 	call	8110aef0 <i2c_write>
8110ab1c:	1000011e 	bne	r2,zero,8110ab24 <I2C_Write+0x90>
        bSuccess = FALSE;
8110ab20:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110ab24:	e0bffa17 	ldw	r2,-24(fp)
8110ab28:	10000726 	beq	r2,zero,8110ab48 <I2C_Write+0xb4>
8110ab2c:	e0bfff03 	ldbu	r2,-4(fp)
8110ab30:	100d883a 	mov	r6,r2
8110ab34:	e17ffc17 	ldw	r5,-16(fp)
8110ab38:	e13ffb17 	ldw	r4,-20(fp)
8110ab3c:	110aef00 	call	8110aef0 <i2c_write>
8110ab40:	1000011e 	bne	r2,zero,8110ab48 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110ab44:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ab48:	e17ffc17 	ldw	r5,-16(fp)
8110ab4c:	e13ffb17 	ldw	r4,-20(fp)
8110ab50:	110ae700 	call	8110ae70 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ab54:	0106d604 	movi	r4,7000
8110ab58:	11390300 	call	81139030 <usleep>
    
    return bSuccess;
8110ab5c:	e0bffa17 	ldw	r2,-24(fp)

}
8110ab60:	e037883a 	mov	sp,fp
8110ab64:	dfc00117 	ldw	ra,4(sp)
8110ab68:	df000017 	ldw	fp,0(sp)
8110ab6c:	dec00204 	addi	sp,sp,8
8110ab70:	f800283a 	ret

8110ab74 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110ab74:	defff904 	addi	sp,sp,-28
8110ab78:	de00012e 	bgeu	sp,et,8110ab80 <I2C_Read+0xc>
8110ab7c:	003b68fa 	trap	3
8110ab80:	dfc00615 	stw	ra,24(sp)
8110ab84:	df000515 	stw	fp,20(sp)
8110ab88:	df000504 	addi	fp,sp,20
8110ab8c:	e13ffc15 	stw	r4,-16(fp)
8110ab90:	e17ffd15 	stw	r5,-12(fp)
8110ab94:	3007883a 	mov	r3,r6
8110ab98:	3805883a 	mov	r2,r7
8110ab9c:	e0fffe05 	stb	r3,-8(fp)
8110aba0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aba4:	00800044 	movi	r2,1
8110aba8:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110abac:	e17ffd17 	ldw	r5,-12(fp)
8110abb0:	e13ffc17 	ldw	r4,-16(fp)
8110abb4:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110abb8:	e0bffe03 	ldbu	r2,-8(fp)
8110abbc:	10803fcc 	andi	r2,r2,255
8110abc0:	100d883a 	mov	r6,r2
8110abc4:	e17ffd17 	ldw	r5,-12(fp)
8110abc8:	e13ffc17 	ldw	r4,-16(fp)
8110abcc:	110aef00 	call	8110aef0 <i2c_write>
8110abd0:	1000011e 	bne	r2,zero,8110abd8 <I2C_Read+0x64>
        bSuccess = FALSE;
8110abd4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110abd8:	e0bffb17 	ldw	r2,-20(fp)
8110abdc:	10000726 	beq	r2,zero,8110abfc <I2C_Read+0x88>
8110abe0:	e0bfff03 	ldbu	r2,-4(fp)
8110abe4:	100d883a 	mov	r6,r2
8110abe8:	e17ffd17 	ldw	r5,-12(fp)
8110abec:	e13ffc17 	ldw	r4,-16(fp)
8110abf0:	110aef00 	call	8110aef0 <i2c_write>
8110abf4:	1000011e 	bne	r2,zero,8110abfc <I2C_Read+0x88>
        bSuccess = FALSE;
8110abf8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110abfc:	e17ffd17 	ldw	r5,-12(fp)
8110ac00:	e13ffc17 	ldw	r4,-16(fp)
8110ac04:	110addc0 	call	8110addc <i2c_start>
    DeviceAddr |= 1; // Read
8110ac08:	e0bffe03 	ldbu	r2,-8(fp)
8110ac0c:	10800054 	ori	r2,r2,1
8110ac10:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ac14:	e0bffb17 	ldw	r2,-20(fp)
8110ac18:	10000826 	beq	r2,zero,8110ac3c <I2C_Read+0xc8>
8110ac1c:	e0bffe03 	ldbu	r2,-8(fp)
8110ac20:	10803fcc 	andi	r2,r2,255
8110ac24:	100d883a 	mov	r6,r2
8110ac28:	e17ffd17 	ldw	r5,-12(fp)
8110ac2c:	e13ffc17 	ldw	r4,-16(fp)
8110ac30:	110aef00 	call	8110aef0 <i2c_write>
8110ac34:	1000011e 	bne	r2,zero,8110ac3c <I2C_Read+0xc8>
        bSuccess = FALSE;
8110ac38:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ac3c:	e0bffb17 	ldw	r2,-20(fp)
8110ac40:	10000526 	beq	r2,zero,8110ac58 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110ac44:	000f883a 	mov	r7,zero
8110ac48:	e1800217 	ldw	r6,8(fp)
8110ac4c:	e17ffd17 	ldw	r5,-12(fp)
8110ac50:	e13ffc17 	ldw	r4,-16(fp)
8110ac54:	110b0280 	call	8110b028 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110ac58:	e17ffd17 	ldw	r5,-12(fp)
8110ac5c:	e13ffc17 	ldw	r4,-16(fp)
8110ac60:	110ae700 	call	8110ae70 <i2c_stop>
    
    return bSuccess;
8110ac64:	e0bffb17 	ldw	r2,-20(fp)
}
8110ac68:	e037883a 	mov	sp,fp
8110ac6c:	dfc00117 	ldw	ra,4(sp)
8110ac70:	df000017 	ldw	fp,0(sp)
8110ac74:	dec00204 	addi	sp,sp,8
8110ac78:	f800283a 	ret

8110ac7c <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110ac7c:	defff604 	addi	sp,sp,-40
8110ac80:	de00012e 	bgeu	sp,et,8110ac88 <I2C_MultipleRead+0xc>
8110ac84:	003b68fa 	trap	3
8110ac88:	dfc00915 	stw	ra,36(sp)
8110ac8c:	df000815 	stw	fp,32(sp)
8110ac90:	df000804 	addi	fp,sp,32
8110ac94:	e13ffb15 	stw	r4,-20(fp)
8110ac98:	e17ffc15 	stw	r5,-16(fp)
8110ac9c:	3007883a 	mov	r3,r6
8110aca0:	e1fffe15 	stw	r7,-8(fp)
8110aca4:	e0800217 	ldw	r2,8(fp)
8110aca8:	e0fffd05 	stb	r3,-12(fp)
8110acac:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110acb0:	00800044 	movi	r2,1
8110acb4:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110acb8:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110acbc:	e17ffc17 	ldw	r5,-16(fp)
8110acc0:	e13ffb17 	ldw	r4,-20(fp)
8110acc4:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110acc8:	e0bffd03 	ldbu	r2,-12(fp)
8110accc:	10803fcc 	andi	r2,r2,255
8110acd0:	100d883a 	mov	r6,r2
8110acd4:	e17ffc17 	ldw	r5,-16(fp)
8110acd8:	e13ffb17 	ldw	r4,-20(fp)
8110acdc:	110aef00 	call	8110aef0 <i2c_write>
8110ace0:	1000011e 	bne	r2,zero,8110ace8 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110ace4:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110ace8:	e0bff917 	ldw	r2,-28(fp)
8110acec:	10000726 	beq	r2,zero,8110ad0c <I2C_MultipleRead+0x90>
8110acf0:	e0bffa03 	ldbu	r2,-24(fp)
8110acf4:	100d883a 	mov	r6,r2
8110acf8:	e17ffc17 	ldw	r5,-16(fp)
8110acfc:	e13ffb17 	ldw	r4,-20(fp)
8110ad00:	110aef00 	call	8110aef0 <i2c_write>
8110ad04:	1000011e 	bne	r2,zero,8110ad0c <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110ad08:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110ad0c:	e0bff917 	ldw	r2,-28(fp)
8110ad10:	10000326 	beq	r2,zero,8110ad20 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110ad14:	e17ffc17 	ldw	r5,-16(fp)
8110ad18:	e13ffb17 	ldw	r4,-20(fp)
8110ad1c:	110addc0 	call	8110addc <i2c_start>
    DeviceAddr |= 1; // Read
8110ad20:	e0bffd03 	ldbu	r2,-12(fp)
8110ad24:	10800054 	ori	r2,r2,1
8110ad28:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ad2c:	e0bff917 	ldw	r2,-28(fp)
8110ad30:	10000826 	beq	r2,zero,8110ad54 <I2C_MultipleRead+0xd8>
8110ad34:	e0bffd03 	ldbu	r2,-12(fp)
8110ad38:	10803fcc 	andi	r2,r2,255
8110ad3c:	100d883a 	mov	r6,r2
8110ad40:	e17ffc17 	ldw	r5,-16(fp)
8110ad44:	e13ffb17 	ldw	r4,-20(fp)
8110ad48:	110aef00 	call	8110aef0 <i2c_write>
8110ad4c:	1000011e 	bne	r2,zero,8110ad54 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110ad50:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ad54:	e0bff917 	ldw	r2,-28(fp)
8110ad58:	10001726 	beq	r2,zero,8110adb8 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110ad5c:	e03ff815 	stw	zero,-32(fp)
8110ad60:	00001006 	br	8110ada4 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110ad64:	e0bff817 	ldw	r2,-32(fp)
8110ad68:	e0fffe17 	ldw	r3,-8(fp)
8110ad6c:	1889883a 	add	r4,r3,r2
8110ad70:	e0bfff0b 	ldhu	r2,-4(fp)
8110ad74:	10ffffc4 	addi	r3,r2,-1
8110ad78:	e0bff817 	ldw	r2,-32(fp)
8110ad7c:	1884c03a 	cmpne	r2,r3,r2
8110ad80:	10803fcc 	andi	r2,r2,255
8110ad84:	100f883a 	mov	r7,r2
8110ad88:	200d883a 	mov	r6,r4
8110ad8c:	e17ffc17 	ldw	r5,-16(fp)
8110ad90:	e13ffb17 	ldw	r4,-20(fp)
8110ad94:	110b0280 	call	8110b028 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110ad98:	e0bff817 	ldw	r2,-32(fp)
8110ad9c:	10800044 	addi	r2,r2,1
8110ada0:	e0bff815 	stw	r2,-32(fp)
8110ada4:	e0bfff0b 	ldhu	r2,-4(fp)
8110ada8:	e0fff817 	ldw	r3,-32(fp)
8110adac:	1880020e 	bge	r3,r2,8110adb8 <I2C_MultipleRead+0x13c>
8110adb0:	e0bff917 	ldw	r2,-28(fp)
8110adb4:	103feb1e 	bne	r2,zero,8110ad64 <__reset+0xfb0ead64>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110adb8:	e17ffc17 	ldw	r5,-16(fp)
8110adbc:	e13ffb17 	ldw	r4,-20(fp)
8110adc0:	110ae700 	call	8110ae70 <i2c_stop>
    
    return bSuccess;    
8110adc4:	e0bff917 	ldw	r2,-28(fp)
    
}
8110adc8:	e037883a 	mov	sp,fp
8110adcc:	dfc00117 	ldw	ra,4(sp)
8110add0:	df000017 	ldw	fp,0(sp)
8110add4:	dec00204 	addi	sp,sp,8
8110add8:	f800283a 	ret

8110addc <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110addc:	defffc04 	addi	sp,sp,-16
8110ade0:	de00012e 	bgeu	sp,et,8110ade8 <i2c_start+0xc>
8110ade4:	003b68fa 	trap	3
8110ade8:	dfc00315 	stw	ra,12(sp)
8110adec:	df000215 	stw	fp,8(sp)
8110adf0:	df000204 	addi	fp,sp,8
8110adf4:	e13ffe15 	stw	r4,-8(fp)
8110adf8:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110adfc:	e0bfff17 	ldw	r2,-4(fp)
8110ae00:	10800104 	addi	r2,r2,4
8110ae04:	1007883a 	mov	r3,r2
8110ae08:	00800044 	movi	r2,1
8110ae0c:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110ae10:	e0bfff17 	ldw	r2,-4(fp)
8110ae14:	00c00044 	movi	r3,1
8110ae18:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110ae1c:	e0bffe17 	ldw	r2,-8(fp)
8110ae20:	00c00044 	movi	r3,1
8110ae24:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110ae28:	01000044 	movi	r4,1
8110ae2c:	11390300 	call	81139030 <usleep>
     
    SDA_LOW(data_base); // data low
8110ae30:	e0bfff17 	ldw	r2,-4(fp)
8110ae34:	0007883a 	mov	r3,zero
8110ae38:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110ae3c:	01000044 	movi	r4,1
8110ae40:	11390300 	call	81139030 <usleep>
    SCL_LOW(clk_base); // clock low
8110ae44:	e0bffe17 	ldw	r2,-8(fp)
8110ae48:	0007883a 	mov	r3,zero
8110ae4c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110ae50:	01000044 	movi	r4,1
8110ae54:	11390300 	call	81139030 <usleep>
}
8110ae58:	0001883a 	nop
8110ae5c:	e037883a 	mov	sp,fp
8110ae60:	dfc00117 	ldw	ra,4(sp)
8110ae64:	df000017 	ldw	fp,0(sp)
8110ae68:	dec00204 	addi	sp,sp,8
8110ae6c:	f800283a 	ret

8110ae70 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110ae70:	defffc04 	addi	sp,sp,-16
8110ae74:	de00012e 	bgeu	sp,et,8110ae7c <i2c_stop+0xc>
8110ae78:	003b68fa 	trap	3
8110ae7c:	dfc00315 	stw	ra,12(sp)
8110ae80:	df000215 	stw	fp,8(sp)
8110ae84:	df000204 	addi	fp,sp,8
8110ae88:	e13ffe15 	stw	r4,-8(fp)
8110ae8c:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110ae90:	e0bfff17 	ldw	r2,-4(fp)
8110ae94:	10800104 	addi	r2,r2,4
8110ae98:	1007883a 	mov	r3,r2
8110ae9c:	00800044 	movi	r2,1
8110aea0:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110aea4:	e0bfff17 	ldw	r2,-4(fp)
8110aea8:	0007883a 	mov	r3,zero
8110aeac:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110aeb0:	e0bffe17 	ldw	r2,-8(fp)
8110aeb4:	00c00044 	movi	r3,1
8110aeb8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110aebc:	01000044 	movi	r4,1
8110aec0:	11390300 	call	81139030 <usleep>
    SDA_HIGH(data_base); // data high
8110aec4:	e0bfff17 	ldw	r2,-4(fp)
8110aec8:	00c00044 	movi	r3,1
8110aecc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110aed0:	01000044 	movi	r4,1
8110aed4:	11390300 	call	81139030 <usleep>
    

    
}
8110aed8:	0001883a 	nop
8110aedc:	e037883a 	mov	sp,fp
8110aee0:	dfc00117 	ldw	ra,4(sp)
8110aee4:	df000017 	ldw	fp,0(sp)
8110aee8:	dec00204 	addi	sp,sp,8
8110aeec:	f800283a 	ret

8110aef0 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110aef0:	defff804 	addi	sp,sp,-32
8110aef4:	de00012e 	bgeu	sp,et,8110aefc <i2c_write+0xc>
8110aef8:	003b68fa 	trap	3
8110aefc:	dfc00715 	stw	ra,28(sp)
8110af00:	df000615 	stw	fp,24(sp)
8110af04:	df000604 	addi	fp,sp,24
8110af08:	e13ffd15 	stw	r4,-12(fp)
8110af0c:	e17ffe15 	stw	r5,-8(fp)
8110af10:	3005883a 	mov	r2,r6
8110af14:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110af18:	00bfe004 	movi	r2,-128
8110af1c:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110af20:	e0bffe17 	ldw	r2,-8(fp)
8110af24:	10800104 	addi	r2,r2,4
8110af28:	1007883a 	mov	r3,r2
8110af2c:	00800044 	movi	r2,1
8110af30:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110af34:	e03ffb15 	stw	zero,-20(fp)
8110af38:	00001f06 	br	8110afb8 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110af3c:	e0bffd17 	ldw	r2,-12(fp)
8110af40:	0007883a 	mov	r3,zero
8110af44:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110af48:	e0ffff03 	ldbu	r3,-4(fp)
8110af4c:	e0bffa03 	ldbu	r2,-24(fp)
8110af50:	1884703a 	and	r2,r3,r2
8110af54:	10803fcc 	andi	r2,r2,255
8110af58:	10000426 	beq	r2,zero,8110af6c <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110af5c:	e0bffe17 	ldw	r2,-8(fp)
8110af60:	00c00044 	movi	r3,1
8110af64:	10c00035 	stwio	r3,0(r2)
8110af68:	00000306 	br	8110af78 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110af6c:	e0bffe17 	ldw	r2,-8(fp)
8110af70:	0007883a 	mov	r3,zero
8110af74:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110af78:	e0bffa03 	ldbu	r2,-24(fp)
8110af7c:	1004d07a 	srli	r2,r2,1
8110af80:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110af84:	e0bffd17 	ldw	r2,-12(fp)
8110af88:	00c00044 	movi	r3,1
8110af8c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110af90:	01000044 	movi	r4,1
8110af94:	11390300 	call	81139030 <usleep>
        SCL_LOW(clk_base);
8110af98:	e0bffd17 	ldw	r2,-12(fp)
8110af9c:	0007883a 	mov	r3,zero
8110afa0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110afa4:	01000044 	movi	r4,1
8110afa8:	11390300 	call	81139030 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110afac:	e0bffb17 	ldw	r2,-20(fp)
8110afb0:	10800044 	addi	r2,r2,1
8110afb4:	e0bffb15 	stw	r2,-20(fp)
8110afb8:	e0bffb17 	ldw	r2,-20(fp)
8110afbc:	10800210 	cmplti	r2,r2,8
8110afc0:	103fde1e 	bne	r2,zero,8110af3c <__reset+0xfb0eaf3c>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110afc4:	e0bffe17 	ldw	r2,-8(fp)
8110afc8:	10800104 	addi	r2,r2,4
8110afcc:	0007883a 	mov	r3,zero
8110afd0:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110afd4:	e0bffd17 	ldw	r2,-12(fp)
8110afd8:	00c00044 	movi	r3,1
8110afdc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110afe0:	01000044 	movi	r4,1
8110afe4:	11390300 	call	81139030 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110afe8:	e0bffe17 	ldw	r2,-8(fp)
8110afec:	10800037 	ldwio	r2,0(r2)
8110aff0:	1005003a 	cmpeq	r2,r2,zero
8110aff4:	10803fcc 	andi	r2,r2,255
8110aff8:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110affc:	e0bffd17 	ldw	r2,-12(fp)
8110b000:	0007883a 	mov	r3,zero
8110b004:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b008:	01000044 	movi	r4,1
8110b00c:	11390300 	call	81139030 <usleep>
    return bAck;
8110b010:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b014:	e037883a 	mov	sp,fp
8110b018:	dfc00117 	ldw	ra,4(sp)
8110b01c:	df000017 	ldw	fp,0(sp)
8110b020:	dec00204 	addi	sp,sp,8
8110b024:	f800283a 	ret

8110b028 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b028:	defff804 	addi	sp,sp,-32
8110b02c:	de00012e 	bgeu	sp,et,8110b034 <i2c_read+0xc>
8110b030:	003b68fa 	trap	3
8110b034:	dfc00715 	stw	ra,28(sp)
8110b038:	df000615 	stw	fp,24(sp)
8110b03c:	df000604 	addi	fp,sp,24
8110b040:	e13ffc15 	stw	r4,-16(fp)
8110b044:	e17ffd15 	stw	r5,-12(fp)
8110b048:	e1bffe15 	stw	r6,-8(fp)
8110b04c:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b050:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b054:	e0bffd17 	ldw	r2,-12(fp)
8110b058:	10800104 	addi	r2,r2,4
8110b05c:	0007883a 	mov	r3,zero
8110b060:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b064:	e0bffc17 	ldw	r2,-16(fp)
8110b068:	0007883a 	mov	r3,zero
8110b06c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b070:	01000044 	movi	r4,1
8110b074:	11390300 	call	81139030 <usleep>

    for(i=0;i<8;i++){
8110b078:	e03ffb15 	stw	zero,-20(fp)
8110b07c:	00001606 	br	8110b0d8 <i2c_read+0xb0>
        Data <<= 1;
8110b080:	e0bffa03 	ldbu	r2,-24(fp)
8110b084:	1085883a 	add	r2,r2,r2
8110b088:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b08c:	e0bffc17 	ldw	r2,-16(fp)
8110b090:	00c00044 	movi	r3,1
8110b094:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b098:	01000044 	movi	r4,1
8110b09c:	11390300 	call	81139030 <usleep>
        if (SDA_READ(data_base))  // read data   
8110b0a0:	e0bffd17 	ldw	r2,-12(fp)
8110b0a4:	10800037 	ldwio	r2,0(r2)
8110b0a8:	10000326 	beq	r2,zero,8110b0b8 <i2c_read+0x90>
            Data |= 0x01;
8110b0ac:	e0bffa03 	ldbu	r2,-24(fp)
8110b0b0:	10800054 	ori	r2,r2,1
8110b0b4:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b0b8:	e0bffc17 	ldw	r2,-16(fp)
8110b0bc:	0007883a 	mov	r3,zero
8110b0c0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b0c4:	01000044 	movi	r4,1
8110b0c8:	11390300 	call	81139030 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b0cc:	e0bffb17 	ldw	r2,-20(fp)
8110b0d0:	10800044 	addi	r2,r2,1
8110b0d4:	e0bffb15 	stw	r2,-20(fp)
8110b0d8:	e0bffb17 	ldw	r2,-20(fp)
8110b0dc:	10800210 	cmplti	r2,r2,8
8110b0e0:	103fe71e 	bne	r2,zero,8110b080 <__reset+0xfb0eb080>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b0e4:	e0bffc17 	ldw	r2,-16(fp)
8110b0e8:	0007883a 	mov	r3,zero
8110b0ec:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b0f0:	e0bffd17 	ldw	r2,-12(fp)
8110b0f4:	10800104 	addi	r2,r2,4
8110b0f8:	1007883a 	mov	r3,r2
8110b0fc:	00800044 	movi	r2,1
8110b100:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b104:	e0bfff17 	ldw	r2,-4(fp)
8110b108:	10000426 	beq	r2,zero,8110b11c <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b10c:	e0bffd17 	ldw	r2,-12(fp)
8110b110:	0007883a 	mov	r3,zero
8110b114:	10c00035 	stwio	r3,0(r2)
8110b118:	00000306 	br	8110b128 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b11c:	e0bffd17 	ldw	r2,-12(fp)
8110b120:	00c00044 	movi	r3,1
8110b124:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b128:	e0bffc17 	ldw	r2,-16(fp)
8110b12c:	00c00044 	movi	r3,1
8110b130:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b134:	01000044 	movi	r4,1
8110b138:	11390300 	call	81139030 <usleep>
    SCL_LOW(clk_base); // clock low
8110b13c:	e0bffc17 	ldw	r2,-16(fp)
8110b140:	0007883a 	mov	r3,zero
8110b144:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b148:	01000044 	movi	r4,1
8110b14c:	11390300 	call	81139030 <usleep>
    SDA_LOW(data_base);  // data low
8110b150:	e0bffd17 	ldw	r2,-12(fp)
8110b154:	0007883a 	mov	r3,zero
8110b158:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b15c:	01000044 	movi	r4,1
8110b160:	11390300 	call	81139030 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b164:	e0bffe17 	ldw	r2,-8(fp)
8110b168:	e0fffa03 	ldbu	r3,-24(fp)
8110b16c:	10c00005 	stb	r3,0(r2)
}
8110b170:	0001883a 	nop
8110b174:	e037883a 	mov	sp,fp
8110b178:	dfc00117 	ldw	ra,4(sp)
8110b17c:	df000017 	ldw	fp,0(sp)
8110b180:	dec00204 	addi	sp,sp,8
8110b184:	f800283a 	ret

8110b188 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b188:	defffd04 	addi	sp,sp,-12
8110b18c:	de00012e 	bgeu	sp,et,8110b194 <bSetBoardLeds+0xc>
8110b190:	003b68fa 	trap	3
8110b194:	df000215 	stw	fp,8(sp)
8110b198:	df000204 	addi	fp,sp,8
8110b19c:	e13ffe15 	stw	r4,-8(fp)
8110b1a0:	2805883a 	mov	r2,r5
8110b1a4:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b1a8:	e0bffe17 	ldw	r2,-8(fp)
8110b1ac:	10800058 	cmpnei	r2,r2,1
8110b1b0:	1000071e 	bne	r2,zero,8110b1d0 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b1b4:	e0bfff03 	ldbu	r2,-4(fp)
8110b1b8:	0084303a 	nor	r2,zero,r2
8110b1bc:	1007883a 	mov	r3,r2
8110b1c0:	d0a05003 	ldbu	r2,-32448(gp)
8110b1c4:	1884703a 	and	r2,r3,r2
8110b1c8:	d0a05005 	stb	r2,-32448(gp)
8110b1cc:	00000406 	br	8110b1e0 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b1d0:	d0e05003 	ldbu	r3,-32448(gp)
8110b1d4:	e0bfff03 	ldbu	r2,-4(fp)
8110b1d8:	1884b03a 	or	r2,r3,r2
8110b1dc:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b1e0:	d0a05003 	ldbu	r2,-32448(gp)
8110b1e4:	10c03fcc 	andi	r3,r2,255
8110b1e8:	00a00034 	movhi	r2,32768
8110b1ec:	10827404 	addi	r2,r2,2512
8110b1f0:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b1f4:	00800044 	movi	r2,1
}
8110b1f8:	e037883a 	mov	sp,fp
8110b1fc:	df000017 	ldw	fp,0(sp)
8110b200:	dec00104 	addi	sp,sp,4
8110b204:	f800283a 	ret

8110b208 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b208:	defffd04 	addi	sp,sp,-12
8110b20c:	de00012e 	bgeu	sp,et,8110b214 <bSetPainelLeds+0xc>
8110b210:	003b68fa 	trap	3
8110b214:	df000215 	stw	fp,8(sp)
8110b218:	df000204 	addi	fp,sp,8
8110b21c:	e13ffe15 	stw	r4,-8(fp)
8110b220:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b224:	e0bffe17 	ldw	r2,-8(fp)
8110b228:	10800058 	cmpnei	r2,r2,1
8110b22c:	1000051e 	bne	r2,zero,8110b244 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b230:	d0e00217 	ldw	r3,-32760(gp)
8110b234:	e0bfff17 	ldw	r2,-4(fp)
8110b238:	1884b03a 	or	r2,r3,r2
8110b23c:	d0a00215 	stw	r2,-32760(gp)
8110b240:	00000506 	br	8110b258 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b244:	e0bfff17 	ldw	r2,-4(fp)
8110b248:	0086303a 	nor	r3,zero,r2
8110b24c:	d0a00217 	ldw	r2,-32760(gp)
8110b250:	1884703a 	and	r2,r3,r2
8110b254:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b258:	d0a00217 	ldw	r2,-32760(gp)
8110b25c:	1007883a 	mov	r3,r2
8110b260:	00a00034 	movhi	r2,32768
8110b264:	10824004 	addi	r2,r2,2304
8110b268:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b26c:	00800044 	movi	r2,1
}
8110b270:	e037883a 	mov	sp,fp
8110b274:	df000017 	ldw	fp,0(sp)
8110b278:	dec00104 	addi	sp,sp,4
8110b27c:	f800283a 	ret

8110b280 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b280:	defffc04 	addi	sp,sp,-16
8110b284:	de00012e 	bgeu	sp,et,8110b28c <msgdma_write_extended_descriptor+0xc>
8110b288:	003b68fa 	trap	3
8110b28c:	df000315 	stw	fp,12(sp)
8110b290:	df000304 	addi	fp,sp,12
8110b294:	e13ffd15 	stw	r4,-12(fp)
8110b298:	e17ffe15 	stw	r5,-8(fp)
8110b29c:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b2a0:	e0bffd17 	ldw	r2,-12(fp)
8110b2a4:	10800037 	ldwio	r2,0(r2)
8110b2a8:	1080010c 	andi	r2,r2,4
8110b2ac:	10000226 	beq	r2,zero,8110b2b8 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b2b0:	00bff904 	movi	r2,-28
8110b2b4:	00003d06 	br	8110b3ac <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b2b8:	e0bfff17 	ldw	r2,-4(fp)
8110b2bc:	10800017 	ldw	r2,0(r2)
8110b2c0:	1007883a 	mov	r3,r2
8110b2c4:	e0bffe17 	ldw	r2,-8(fp)
8110b2c8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b2cc:	e0bffe17 	ldw	r2,-8(fp)
8110b2d0:	10800104 	addi	r2,r2,4
8110b2d4:	e0ffff17 	ldw	r3,-4(fp)
8110b2d8:	18c00117 	ldw	r3,4(r3)
8110b2dc:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b2e0:	e0bffe17 	ldw	r2,-8(fp)
8110b2e4:	10800204 	addi	r2,r2,8
8110b2e8:	e0ffff17 	ldw	r3,-4(fp)
8110b2ec:	18c00217 	ldw	r3,8(r3)
8110b2f0:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b2f4:	e0bffe17 	ldw	r2,-8(fp)
8110b2f8:	10800304 	addi	r2,r2,12
8110b2fc:	e0ffff17 	ldw	r3,-4(fp)
8110b300:	18c0030b 	ldhu	r3,12(r3)
8110b304:	18ffffcc 	andi	r3,r3,65535
8110b308:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110b30c:	e0bffe17 	ldw	r2,-8(fp)
8110b310:	10800384 	addi	r2,r2,14
8110b314:	e0ffff17 	ldw	r3,-4(fp)
8110b318:	18c00383 	ldbu	r3,14(r3)
8110b31c:	18c03fcc 	andi	r3,r3,255
8110b320:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110b324:	e0bffe17 	ldw	r2,-8(fp)
8110b328:	108003c4 	addi	r2,r2,15
8110b32c:	e0ffff17 	ldw	r3,-4(fp)
8110b330:	18c003c3 	ldbu	r3,15(r3)
8110b334:	18c03fcc 	andi	r3,r3,255
8110b338:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110b33c:	e0bffe17 	ldw	r2,-8(fp)
8110b340:	10800404 	addi	r2,r2,16
8110b344:	e0ffff17 	ldw	r3,-4(fp)
8110b348:	18c0040b 	ldhu	r3,16(r3)
8110b34c:	18ffffcc 	andi	r3,r3,65535
8110b350:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110b354:	e0bffe17 	ldw	r2,-8(fp)
8110b358:	10800484 	addi	r2,r2,18
8110b35c:	e0ffff17 	ldw	r3,-4(fp)
8110b360:	18c0048b 	ldhu	r3,18(r3)
8110b364:	18ffffcc 	andi	r3,r3,65535
8110b368:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110b36c:	e0bffe17 	ldw	r2,-8(fp)
8110b370:	10800504 	addi	r2,r2,20
8110b374:	e0ffff17 	ldw	r3,-4(fp)
8110b378:	18c00517 	ldw	r3,20(r3)
8110b37c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110b380:	e0bffe17 	ldw	r2,-8(fp)
8110b384:	10800604 	addi	r2,r2,24
8110b388:	e0ffff17 	ldw	r3,-4(fp)
8110b38c:	18c00617 	ldw	r3,24(r3)
8110b390:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110b394:	e0bffe17 	ldw	r2,-8(fp)
8110b398:	10800704 	addi	r2,r2,28
8110b39c:	e0ffff17 	ldw	r3,-4(fp)
8110b3a0:	18c00717 	ldw	r3,28(r3)
8110b3a4:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110b3a8:	0005883a 	mov	r2,zero
}
8110b3ac:	e037883a 	mov	sp,fp
8110b3b0:	df000017 	ldw	fp,0(sp)
8110b3b4:	dec00104 	addi	sp,sp,4
8110b3b8:	f800283a 	ret

8110b3bc <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110b3bc:	defff604 	addi	sp,sp,-40
8110b3c0:	de00012e 	bgeu	sp,et,8110b3c8 <msgdma_construct_extended_descriptor+0xc>
8110b3c4:	003b68fa 	trap	3
8110b3c8:	df000915 	stw	fp,36(sp)
8110b3cc:	df000904 	addi	fp,sp,36
8110b3d0:	e13ff715 	stw	r4,-36(fp)
8110b3d4:	e17ff815 	stw	r5,-32(fp)
8110b3d8:	e1bff915 	stw	r6,-28(fp)
8110b3dc:	e1fffa15 	stw	r7,-24(fp)
8110b3e0:	e1800517 	ldw	r6,20(fp)
8110b3e4:	e1400617 	ldw	r5,24(fp)
8110b3e8:	e1000717 	ldw	r4,28(fp)
8110b3ec:	e0c00817 	ldw	r3,32(fp)
8110b3f0:	e0800917 	ldw	r2,36(fp)
8110b3f4:	e1bffb0d 	sth	r6,-20(fp)
8110b3f8:	e17ffc05 	stb	r5,-16(fp)
8110b3fc:	e13ffd05 	stb	r4,-12(fp)
8110b400:	e0fffe0d 	sth	r3,-8(fp)
8110b404:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110b408:	e0bff717 	ldw	r2,-36(fp)
8110b40c:	10c01217 	ldw	r3,72(r2)
8110b410:	e0800117 	ldw	r2,4(fp)
8110b414:	18801936 	bltu	r3,r2,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b418:	e13ff717 	ldw	r4,-36(fp)
8110b41c:	20801317 	ldw	r2,76(r4)
8110b420:	20c01417 	ldw	r3,80(r4)
8110b424:	e13ffe0b 	ldhu	r4,-8(fp)
8110b428:	213fffcc 	andi	r4,r4,65535
8110b42c:	2015883a 	mov	r10,r4
8110b430:	0017883a 	mov	r11,zero
8110b434:	1ac01136 	bltu	r3,r11,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b438:	58c0011e 	bne	r11,r3,8110b440 <msgdma_construct_extended_descriptor+0x84>
8110b43c:	12800f36 	bltu	r2,r10,8110b47c <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110b440:	e13ff717 	ldw	r4,-36(fp)
8110b444:	20801317 	ldw	r2,76(r4)
8110b448:	20c01417 	ldw	r3,80(r4)
8110b44c:	e13fff0b 	ldhu	r4,-4(fp)
8110b450:	213fffcc 	andi	r4,r4,65535
8110b454:	2011883a 	mov	r8,r4
8110b458:	0013883a 	mov	r9,zero
8110b45c:	1a400736 	bltu	r3,r9,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b460:	48c0011e 	bne	r9,r3,8110b468 <msgdma_construct_extended_descriptor+0xac>
8110b464:	12000536 	bltu	r2,r8,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b468:	e0bff717 	ldw	r2,-36(fp)
8110b46c:	10801703 	ldbu	r2,92(r2)
8110b470:	10803fcc 	andi	r2,r2,255
8110b474:	10800060 	cmpeqi	r2,r2,1
8110b478:	1000021e 	bne	r2,zero,8110b484 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b47c:	00bffa84 	movi	r2,-22
8110b480:	00002306 	br	8110b510 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b484:	e0bff817 	ldw	r2,-32(fp)
8110b488:	e0fff917 	ldw	r3,-28(fp)
8110b48c:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b490:	e0bff817 	ldw	r2,-32(fp)
8110b494:	e0fffa17 	ldw	r3,-24(fp)
8110b498:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b49c:	e0bff817 	ldw	r2,-32(fp)
8110b4a0:	e0c00117 	ldw	r3,4(fp)
8110b4a4:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b4a8:	e0bff817 	ldw	r2,-32(fp)
8110b4ac:	e0fffb0b 	ldhu	r3,-20(fp)
8110b4b0:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b4b4:	e0bff817 	ldw	r2,-32(fp)
8110b4b8:	e0fffc03 	ldbu	r3,-16(fp)
8110b4bc:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b4c0:	e0bff817 	ldw	r2,-32(fp)
8110b4c4:	e0fffd03 	ldbu	r3,-12(fp)
8110b4c8:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b4cc:	e0bff817 	ldw	r2,-32(fp)
8110b4d0:	e0fffe0b 	ldhu	r3,-8(fp)
8110b4d4:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b4d8:	e0bff817 	ldw	r2,-32(fp)
8110b4dc:	e0ffff0b 	ldhu	r3,-4(fp)
8110b4e0:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b4e4:	e0bff817 	ldw	r2,-32(fp)
8110b4e8:	e0c00317 	ldw	r3,12(fp)
8110b4ec:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b4f0:	e0bff817 	ldw	r2,-32(fp)
8110b4f4:	e0c00417 	ldw	r3,16(fp)
8110b4f8:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b4fc:	e0800217 	ldw	r2,8(fp)
8110b500:	10e00034 	orhi	r3,r2,32768
8110b504:	e0bff817 	ldw	r2,-32(fp)
8110b508:	10c00715 	stw	r3,28(r2)

	return 0;
8110b50c:	0005883a 	mov	r2,zero

}
8110b510:	e037883a 	mov	sp,fp
8110b514:	df000017 	ldw	fp,0(sp)
8110b518:	dec00104 	addi	sp,sp,4
8110b51c:	f800283a 	ret

8110b520 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b520:	deffee04 	addi	sp,sp,-72
8110b524:	de00012e 	bgeu	sp,et,8110b52c <msgdma_descriptor_async_transfer+0xc>
8110b528:	003b68fa 	trap	3
8110b52c:	dfc01115 	stw	ra,68(sp)
8110b530:	df001015 	stw	fp,64(sp)
8110b534:	df001004 	addi	fp,sp,64
8110b538:	e13ffd15 	stw	r4,-12(fp)
8110b53c:	e17ffe15 	stw	r5,-8(fp)
8110b540:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b544:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110b548:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110b54c:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b550:	e0bffd17 	ldw	r2,-12(fp)
8110b554:	10800317 	ldw	r2,12(r2)
8110b558:	10800204 	addi	r2,r2,8
8110b55c:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b560:	10bfffcc 	andi	r2,r2,65535
8110b564:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b568:	e0bffd17 	ldw	r2,-12(fp)
8110b56c:	10800317 	ldw	r2,12(r2)
8110b570:	10800204 	addi	r2,r2,8
8110b574:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b578:	1004d43a 	srli	r2,r2,16
8110b57c:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b580:	e0bffd17 	ldw	r2,-12(fp)
8110b584:	10800917 	ldw	r2,36(r2)
8110b588:	e0fff417 	ldw	r3,-48(fp)
8110b58c:	1880042e 	bgeu	r3,r2,8110b5a0 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b590:	e0bffd17 	ldw	r2,-12(fp)
8110b594:	10800917 	ldw	r2,36(r2)
8110b598:	e0fff317 	ldw	r3,-52(fp)
8110b59c:	18800236 	bltu	r3,r2,8110b5a8 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b5a0:	00bff904 	movi	r2,-28
8110b5a4:	0000ab06 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b5a8:	e0bffd17 	ldw	r2,-12(fp)
8110b5ac:	10801817 	ldw	r2,96(r2)
8110b5b0:	e0bff615 	stw	r2,-40(fp)
8110b5b4:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110b5b8:	e0bffc0b 	ldhu	r2,-16(fp)
8110b5bc:	e0fffc84 	addi	r3,fp,-14
8110b5c0:	180d883a 	mov	r6,r3
8110b5c4:	100b883a 	mov	r5,r2
8110b5c8:	e13ff617 	ldw	r4,-40(fp)
8110b5cc:	113fe340 	call	8113fe34 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b5d0:	00800804 	movi	r2,32
8110b5d4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b5d8:	0005303a 	rdctl	r2,status
8110b5dc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b5e0:	e0fff717 	ldw	r3,-36(fp)
8110b5e4:	00bfff84 	movi	r2,-2
8110b5e8:	1884703a 	and	r2,r3,r2
8110b5ec:	1001703a 	wrctl	status,r2
  
  return context;
8110b5f0:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b5f4:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b5f8:	e0bffd17 	ldw	r2,-12(fp)
8110b5fc:	10800317 	ldw	r2,12(r2)
8110b600:	10800104 	addi	r2,r2,4
8110b604:	e0fff117 	ldw	r3,-60(fp)
8110b608:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b60c:	e0bffd17 	ldw	r2,-12(fp)
8110b610:	10800317 	ldw	r2,12(r2)
8110b614:	e0fffd17 	ldw	r3,-12(fp)
8110b618:	18c00317 	ldw	r3,12(r3)
8110b61c:	18c00037 	ldwio	r3,0(r3)
8110b620:	10c00035 	stwio	r3,0(r2)
8110b624:	e0bff217 	ldw	r2,-56(fp)
8110b628:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b62c:	e0bffb17 	ldw	r2,-20(fp)
8110b630:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b634:	e0bffe17 	ldw	r2,-8(fp)
8110b638:	10001626 	beq	r2,zero,8110b694 <msgdma_descriptor_async_transfer+0x174>
8110b63c:	e0bfff17 	ldw	r2,-4(fp)
8110b640:	1000141e 	bne	r2,zero,8110b694 <msgdma_descriptor_async_transfer+0x174>
		counter = 0; /* reset counter */
8110b644:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b648:	00a045f4 	movhi	r2,33047
8110b64c:	10a00404 	addi	r2,r2,-32752
8110b650:	10800e8b 	ldhu	r2,58(r2)
8110b654:	10bfffcc 	andi	r2,r2,65535
8110b658:	108001e8 	cmpgeui	r2,r2,7
8110b65c:	1000071e 	bne	r2,zero,8110b67c <msgdma_descriptor_async_transfer+0x15c>
		debug(fp, "invalid dma descriptor option\n");
8110b660:	d0a06217 	ldw	r2,-32376(gp)
8110b664:	100f883a 	mov	r7,r2
8110b668:	01800784 	movi	r6,30
8110b66c:	01400044 	movi	r5,1
8110b670:	01204574 	movhi	r4,33045
8110b674:	2135e304 	addi	r4,r4,-10356
8110b678:	11230300 	call	81123030 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b67c:	e0bffd17 	ldw	r2,-12(fp)
8110b680:	10801817 	ldw	r2,96(r2)
8110b684:	1009883a 	mov	r4,r2
8110b688:	11401bc0 	call	811401bc <OSSemPost>

		return -ETIME;
8110b68c:	00bff084 	movi	r2,-62
8110b690:	00007006 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b694:	e0bffe17 	ldw	r2,-8(fp)
8110b698:	1000291e 	bne	r2,zero,8110b740 <msgdma_descriptor_async_transfer+0x220>
8110b69c:	e0bfff17 	ldw	r2,-4(fp)
8110b6a0:	10002726 	beq	r2,zero,8110b740 <msgdma_descriptor_async_transfer+0x220>
		counter = 0; /* reset counter */
8110b6a4:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b6a8:	00001b06 	br	8110b718 <msgdma_descriptor_async_transfer+0x1f8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b6ac:	01000044 	movi	r4,1
8110b6b0:	11375bc0 	call	811375bc <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b6b4:	e0bff00b 	ldhu	r2,-64(fp)
8110b6b8:	1084e230 	cmpltui	r2,r2,5000
8110b6bc:	1000131e 	bne	r2,zero,8110b70c <msgdma_descriptor_async_transfer+0x1ec>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b6c0:	00a045f4 	movhi	r2,33047
8110b6c4:	10a00404 	addi	r2,r2,-32752
8110b6c8:	10800e8b 	ldhu	r2,58(r2)
8110b6cc:	10bfffcc 	andi	r2,r2,65535
8110b6d0:	108001e8 	cmpgeui	r2,r2,7
8110b6d4:	1000071e 	bne	r2,zero,8110b6f4 <msgdma_descriptor_async_transfer+0x1d4>
					debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing extended descriptor\n");
8110b6d8:	d0a06217 	ldw	r2,-32376(gp)
8110b6dc:	100f883a 	mov	r7,r2
8110b6e0:	01801544 	movi	r6,85
8110b6e4:	01400044 	movi	r5,1
8110b6e8:	01204574 	movhi	r4,33045
8110b6ec:	2135eb04 	addi	r4,r4,-10324
8110b6f0:	11230300 	call	81123030 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b6f4:	e0bffd17 	ldw	r2,-12(fp)
8110b6f8:	10801817 	ldw	r2,96(r2)
8110b6fc:	1009883a 	mov	r4,r2
8110b700:	11401bc0 	call	811401bc <OSSemPost>

				return -ETIME;
8110b704:	00bff084 	movi	r2,-62
8110b708:	00005206 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>
			}
			counter++;
8110b70c:	e0bff00b 	ldhu	r2,-64(fp)
8110b710:	10800044 	addi	r2,r2,1
8110b714:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b718:	e0bffd17 	ldw	r2,-12(fp)
8110b71c:	10c00317 	ldw	r3,12(r2)
8110b720:	e0bffd17 	ldw	r2,-12(fp)
8110b724:	10800417 	ldw	r2,16(r2)
8110b728:	e1bfff17 	ldw	r6,-4(fp)
8110b72c:	100b883a 	mov	r5,r2
8110b730:	1809883a 	mov	r4,r3
8110b734:	110b2800 	call	8110b280 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b738:	103fdc1e 	bne	r2,zero,8110b6ac <__reset+0xfb0eb6ac>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b73c:	00000606 	br	8110b758 <msgdma_descriptor_async_transfer+0x238>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b740:	e0bffd17 	ldw	r2,-12(fp)
8110b744:	10801817 	ldw	r2,96(r2)
8110b748:	1009883a 	mov	r4,r2
8110b74c:	11401bc0 	call	811401bc <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b750:	00bfffc4 	movi	r2,-1
8110b754:	00003f06 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b758:	e0bffd17 	ldw	r2,-12(fp)
8110b75c:	10800b17 	ldw	r2,44(r2)
8110b760:	10001c26 	beq	r2,zero,8110b7d4 <msgdma_descriptor_async_transfer+0x2b4>

		control |= (dev->control |
8110b764:	e0bffd17 	ldw	r2,-12(fp)
8110b768:	10c00d17 	ldw	r3,52(r2)
8110b76c:	e0bff117 	ldw	r2,-60(fp)
8110b770:	1884b03a 	or	r2,r3,r2
8110b774:	10800514 	ori	r2,r2,20
8110b778:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b77c:	e0fff117 	ldw	r3,-60(fp)
8110b780:	00bff7c4 	movi	r2,-33
8110b784:	1884703a 	and	r2,r3,r2
8110b788:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b78c:	0005303a 	rdctl	r2,status
8110b790:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b794:	e0fff917 	ldw	r3,-28(fp)
8110b798:	00bfff84 	movi	r2,-2
8110b79c:	1884703a 	and	r2,r3,r2
8110b7a0:	1001703a 	wrctl	status,r2
  
  return context;
8110b7a4:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b7a8:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b7ac:	e0bffd17 	ldw	r2,-12(fp)
8110b7b0:	10800317 	ldw	r2,12(r2)
8110b7b4:	10800104 	addi	r2,r2,4
8110b7b8:	e0fff117 	ldw	r3,-60(fp)
8110b7bc:	10c00035 	stwio	r3,0(r2)
8110b7c0:	e0bff217 	ldw	r2,-56(fp)
8110b7c4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b7c8:	e0bff517 	ldw	r2,-44(fp)
8110b7cc:	1001703a 	wrctl	status,r2
8110b7d0:	00001b06 	br	8110b840 <msgdma_descriptor_async_transfer+0x320>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b7d4:	e0bffd17 	ldw	r2,-12(fp)
8110b7d8:	10c00d17 	ldw	r3,52(r2)
8110b7dc:	e0bff117 	ldw	r2,-60(fp)
8110b7e0:	1884b03a 	or	r2,r3,r2
8110b7e4:	10800114 	ori	r2,r2,4
8110b7e8:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b7ec:	e0fff117 	ldw	r3,-60(fp)
8110b7f0:	00bff3c4 	movi	r2,-49
8110b7f4:	1884703a 	and	r2,r3,r2
8110b7f8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b7fc:	0005303a 	rdctl	r2,status
8110b800:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b804:	e0fffa17 	ldw	r3,-24(fp)
8110b808:	00bfff84 	movi	r2,-2
8110b80c:	1884703a 	and	r2,r3,r2
8110b810:	1001703a 	wrctl	status,r2
  
  return context;
8110b814:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b818:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b81c:	e0bffd17 	ldw	r2,-12(fp)
8110b820:	10800317 	ldw	r2,12(r2)
8110b824:	10800104 	addi	r2,r2,4
8110b828:	e0fff117 	ldw	r3,-60(fp)
8110b82c:	10c00035 	stwio	r3,0(r2)
8110b830:	e0bff217 	ldw	r2,-56(fp)
8110b834:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b838:	e0bff817 	ldw	r2,-32(fp)
8110b83c:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b840:	e0bffd17 	ldw	r2,-12(fp)
8110b844:	10801817 	ldw	r2,96(r2)
8110b848:	1009883a 	mov	r4,r2
8110b84c:	11401bc0 	call	811401bc <OSSemPost>

	return 0;
8110b850:	0005883a 	mov	r2,zero
}
8110b854:	e037883a 	mov	sp,fp
8110b858:	dfc00117 	ldw	ra,4(sp)
8110b85c:	df000017 	ldw	fp,0(sp)
8110b860:	dec00204 	addi	sp,sp,8
8110b864:	f800283a 	ret

8110b868 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b868:	deffee04 	addi	sp,sp,-72
8110b86c:	de00012e 	bgeu	sp,et,8110b874 <msgdma_descriptor_sync_transfer+0xc>
8110b870:	003b68fa 	trap	3
8110b874:	dfc01115 	stw	ra,68(sp)
8110b878:	df001015 	stw	fp,64(sp)
8110b87c:	df001004 	addi	fp,sp,64
8110b880:	e13ffd15 	stw	r4,-12(fp)
8110b884:	e17ffe15 	stw	r5,-8(fp)
8110b888:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b88c:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110b890:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110b894:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110b898:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b89c:	e0bffd17 	ldw	r2,-12(fp)
8110b8a0:	10800317 	ldw	r2,12(r2)
8110b8a4:	10800204 	addi	r2,r2,8
8110b8a8:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b8ac:	10bfffcc 	andi	r2,r2,65535
8110b8b0:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b8b4:	e0bffd17 	ldw	r2,-12(fp)
8110b8b8:	10800317 	ldw	r2,12(r2)
8110b8bc:	10800204 	addi	r2,r2,8
8110b8c0:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b8c4:	1004d43a 	srli	r2,r2,16
8110b8c8:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b8cc:	00807804 	movi	r2,480
8110b8d0:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b8d4:	00003006 	br	8110b998 <msgdma_descriptor_sync_transfer+0x130>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b8d8:	01000044 	movi	r4,1
8110b8dc:	11375bc0 	call	811375bc <alt_busy_sleep>
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b8e0:	00a045f4 	movhi	r2,33047
8110b8e4:	10a00404 	addi	r2,r2,-32752
8110b8e8:	10800e8b 	ldhu	r2,58(r2)
8110b8ec:	10bfffcc 	andi	r2,r2,65535
8110b8f0:	108001e8 	cmpgeui	r2,r2,7
8110b8f4:	1000071e 	bne	r2,zero,8110b914 <msgdma_descriptor_sync_transfer+0xac>
		fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110b8f8:	d0a06217 	ldw	r2,-32376(gp)
8110b8fc:	100f883a 	mov	r7,r2
8110b900:	01800a04 	movi	r6,40
8110b904:	01400044 	movi	r5,1
8110b908:	01204574 	movhi	r4,33045
8110b90c:	21360104 	addi	r4,r4,-10236
8110b910:	11230300 	call	81123030 <fwrite>
	}
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b914:	e0bff10b 	ldhu	r2,-60(fp)
8110b918:	1084e230 	cmpltui	r2,r2,5000
8110b91c:	10000f1e 	bne	r2,zero,8110b95c <msgdma_descriptor_sync_transfer+0xf4>
		{
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b920:	00a045f4 	movhi	r2,33047
8110b924:	10a00404 	addi	r2,r2,-32752
8110b928:	10800e8b 	ldhu	r2,58(r2)
8110b92c:	10bfffcc 	andi	r2,r2,65535
8110b930:	108001e8 	cmpgeui	r2,r2,7
8110b934:	1000071e 	bne	r2,zero,8110b954 <msgdma_descriptor_sync_transfer+0xec>
		debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
8110b938:	d0a06217 	ldw	r2,-32376(gp)
8110b93c:	100f883a 	mov	r7,r2
8110b940:	01801304 	movi	r6,76
8110b944:	01400044 	movi	r5,1
8110b948:	01204574 	movhi	r4,33045
8110b94c:	21360c04 	addi	r4,r4,-10192
8110b950:	11230300 	call	81123030 <fwrite>
	}
#endif
			return -ETIME;
8110b954:	00bff084 	movi	r2,-62
8110b958:	0000e206 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110b95c:	e0bff10b 	ldhu	r2,-60(fp)
8110b960:	10800044 	addi	r2,r2,1
8110b964:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b968:	e0bffd17 	ldw	r2,-12(fp)
8110b96c:	10800317 	ldw	r2,12(r2)
8110b970:	10800204 	addi	r2,r2,8
8110b974:	10800037 	ldwio	r2,0(r2)
	}
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110b978:	10bfffcc 	andi	r2,r2,65535
8110b97c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b980:	e0bffd17 	ldw	r2,-12(fp)
8110b984:	10800317 	ldw	r2,12(r2)
8110b988:	10800204 	addi	r2,r2,8
8110b98c:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110b990:	1004d43a 	srli	r2,r2,16
8110b994:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b998:	e0bffd17 	ldw	r2,-12(fp)
8110b99c:	10800917 	ldw	r2,36(r2)
8110b9a0:	e0fff317 	ldw	r3,-52(fp)
8110b9a4:	18bfcc2e 	bgeu	r3,r2,8110b8d8 <__reset+0xfb0eb8d8>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b9a8:	e0bffd17 	ldw	r2,-12(fp)
8110b9ac:	10800917 	ldw	r2,36(r2)
8110b9b0:	e0fff217 	ldw	r3,-56(fp)
8110b9b4:	18bfc82e 	bgeu	r3,r2,8110b8d8 <__reset+0xfb0eb8d8>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b9b8:	e0bffd17 	ldw	r2,-12(fp)
8110b9bc:	10801817 	ldw	r2,96(r2)
8110b9c0:	e0bff815 	stw	r2,-32(fp)
8110b9c4:	e03ffc0d 	sth	zero,-16(fp)
8110b9c8:	e0bffc0b 	ldhu	r2,-16(fp)
8110b9cc:	e0fffc84 	addi	r3,fp,-14
8110b9d0:	180d883a 	mov	r6,r3
8110b9d4:	100b883a 	mov	r5,r2
8110b9d8:	e13ff817 	ldw	r4,-32(fp)
8110b9dc:	113fe340 	call	8113fe34 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b9e0:	0005303a 	rdctl	r2,status
8110b9e4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b9e8:	e0fffb17 	ldw	r3,-20(fp)
8110b9ec:	00bfff84 	movi	r2,-2
8110b9f0:	1884703a 	and	r2,r3,r2
8110b9f4:	1001703a 	wrctl	status,r2
  
  return context;
8110b9f8:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b9fc:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ba00:	e0bffd17 	ldw	r2,-12(fp)
8110ba04:	10800317 	ldw	r2,12(r2)
8110ba08:	10800104 	addi	r2,r2,4
8110ba0c:	00c00804 	movi	r3,32
8110ba10:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110ba14:	e0bffd17 	ldw	r2,-12(fp)
8110ba18:	10800317 	ldw	r2,12(r2)
8110ba1c:	e0fffd17 	ldw	r3,-12(fp)
8110ba20:	18c00317 	ldw	r3,12(r3)
8110ba24:	18c00037 	ldwio	r3,0(r3)
8110ba28:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110ba2c:	e0bffe17 	ldw	r2,-8(fp)
8110ba30:	10001626 	beq	r2,zero,8110ba8c <msgdma_descriptor_sync_transfer+0x224>
8110ba34:	e0bfff17 	ldw	r2,-4(fp)
8110ba38:	1000141e 	bne	r2,zero,8110ba8c <msgdma_descriptor_sync_transfer+0x224>
		counter = 0; /* reset counter */
8110ba3c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ba40:	00a045f4 	movhi	r2,33047
8110ba44:	10a00404 	addi	r2,r2,-32752
8110ba48:	10800e8b 	ldhu	r2,58(r2)
8110ba4c:	10bfffcc 	andi	r2,r2,65535
8110ba50:	108001e8 	cmpgeui	r2,r2,7
8110ba54:	1000071e 	bne	r2,zero,8110ba74 <msgdma_descriptor_sync_transfer+0x20c>
			debug(fp, "invalid dma descriptor option\n");
8110ba58:	d0a06217 	ldw	r2,-32376(gp)
8110ba5c:	100f883a 	mov	r7,r2
8110ba60:	01800784 	movi	r6,30
8110ba64:	01400044 	movi	r5,1
8110ba68:	01204574 	movhi	r4,33045
8110ba6c:	2135e304 	addi	r4,r4,-10356
8110ba70:	11230300 	call	81123030 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110ba74:	e0bffd17 	ldw	r2,-12(fp)
8110ba78:	10801817 	ldw	r2,96(r2)
8110ba7c:	1009883a 	mov	r4,r2
8110ba80:	11401bc0 	call	811401bc <OSSemPost>

		return -ETIME;
8110ba84:	00bff084 	movi	r2,-62
8110ba88:	00009606 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110ba8c:	e0bffe17 	ldw	r2,-8(fp)
8110ba90:	1000291e 	bne	r2,zero,8110bb38 <msgdma_descriptor_sync_transfer+0x2d0>
8110ba94:	e0bfff17 	ldw	r2,-4(fp)
8110ba98:	10002726 	beq	r2,zero,8110bb38 <msgdma_descriptor_sync_transfer+0x2d0>
		counter = 0; /* reset counter */
8110ba9c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110baa0:	00001b06 	br	8110bb10 <msgdma_descriptor_sync_transfer+0x2a8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110baa4:	01000044 	movi	r4,1
8110baa8:	11375bc0 	call	811375bc <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110baac:	e0bff10b 	ldhu	r2,-60(fp)
8110bab0:	1084e230 	cmpltui	r2,r2,5000
8110bab4:	1000131e 	bne	r2,zero,8110bb04 <msgdma_descriptor_sync_transfer+0x29c>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bab8:	00a045f4 	movhi	r2,33047
8110babc:	10a00404 	addi	r2,r2,-32752
8110bac0:	10800e8b 	ldhu	r2,58(r2)
8110bac4:	10bfffcc 	andi	r2,r2,65535
8110bac8:	108001e8 	cmpgeui	r2,r2,7
8110bacc:	1000071e 	bne	r2,zero,8110baec <msgdma_descriptor_sync_transfer+0x284>
					debug(fp, "time out after 5 msec while writing extended descriptor to FIFO\n");
8110bad0:	d0a06217 	ldw	r2,-32376(gp)
8110bad4:	100f883a 	mov	r7,r2
8110bad8:	01801004 	movi	r6,64
8110badc:	01400044 	movi	r5,1
8110bae0:	01204574 	movhi	r4,33045
8110bae4:	21362004 	addi	r4,r4,-10112
8110bae8:	11230300 	call	81123030 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110baec:	e0bffd17 	ldw	r2,-12(fp)
8110baf0:	10801817 	ldw	r2,96(r2)
8110baf4:	1009883a 	mov	r4,r2
8110baf8:	11401bc0 	call	811401bc <OSSemPost>

				return -ETIME;
8110bafc:	00bff084 	movi	r2,-62
8110bb00:	00007806 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
			}
			counter++;
8110bb04:	e0bff10b 	ldhu	r2,-60(fp)
8110bb08:	10800044 	addi	r2,r2,1
8110bb0c:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110bb10:	e0bffd17 	ldw	r2,-12(fp)
8110bb14:	10c00317 	ldw	r3,12(r2)
8110bb18:	e0bffd17 	ldw	r2,-12(fp)
8110bb1c:	10800417 	ldw	r2,16(r2)
8110bb20:	e1bfff17 	ldw	r6,-4(fp)
8110bb24:	100b883a 	mov	r5,r2
8110bb28:	1809883a 	mov	r4,r3
8110bb2c:	110b2800 	call	8110b280 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bb30:	103fdc1e 	bne	r2,zero,8110baa4 <__reset+0xfb0ebaa4>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bb34:	00000606 	br	8110bb50 <msgdma_descriptor_sync_transfer+0x2e8>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bb38:	e0bffd17 	ldw	r2,-12(fp)
8110bb3c:	10801817 	ldw	r2,96(r2)
8110bb40:	1009883a 	mov	r4,r2
8110bb44:	11401bc0 	call	811401bc <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110bb48:	00bfffc4 	movi	r2,-1
8110bb4c:	00006506 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110bb50:	e0bffd17 	ldw	r2,-12(fp)
8110bb54:	10800317 	ldw	r2,12(r2)
8110bb58:	10800104 	addi	r2,r2,4
8110bb5c:	e0fffd17 	ldw	r3,-12(fp)
8110bb60:	19000d17 	ldw	r4,52(r3)
8110bb64:	00fff2c4 	movi	r3,-53
8110bb68:	20c6703a 	and	r3,r4,r3
8110bb6c:	18c00114 	ori	r3,r3,4
8110bb70:	10c00035 	stwio	r3,0(r2)
8110bb74:	e0bff517 	ldw	r2,-44(fp)
8110bb78:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bb7c:	e0bff717 	ldw	r2,-36(fp)
8110bb80:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110bb84:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bb88:	e0bffd17 	ldw	r2,-12(fp)
8110bb8c:	10800317 	ldw	r2,12(r2)
8110bb90:	10800037 	ldwio	r2,0(r2)
8110bb94:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bb98:	00001f06 	br	8110bc18 <msgdma_descriptor_sync_transfer+0x3b0>
		alt_busy_sleep(1); /* delay 1us */
8110bb9c:	01000044 	movi	r4,1
8110bba0:	11375bc0 	call	811375bc <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bba4:	e0bff10b 	ldhu	r2,-60(fp)
8110bba8:	1084e230 	cmpltui	r2,r2,5000
8110bbac:	1000131e 	bne	r2,zero,8110bbfc <msgdma_descriptor_sync_transfer+0x394>
		{
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bbb0:	00a045f4 	movhi	r2,33047
8110bbb4:	10a00404 	addi	r2,r2,-32752
8110bbb8:	10800e8b 	ldhu	r2,58(r2)
8110bbbc:	10bfffcc 	andi	r2,r2,65535
8110bbc0:	108001e8 	cmpgeui	r2,r2,7
8110bbc4:	1000071e 	bne	r2,zero,8110bbe4 <msgdma_descriptor_sync_transfer+0x37c>
				debug(fp, "time out after 5 msec while waiting for any pending transfer complete\n");
8110bbc8:	d0a06217 	ldw	r2,-32376(gp)
8110bbcc:	100f883a 	mov	r7,r2
8110bbd0:	01801184 	movi	r6,70
8110bbd4:	01400044 	movi	r5,1
8110bbd8:	01204574 	movhi	r4,33045
8110bbdc:	21363104 	addi	r4,r4,-10044
8110bbe0:	11230300 	call	81123030 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110bbe4:	e0bffd17 	ldw	r2,-12(fp)
8110bbe8:	10801817 	ldw	r2,96(r2)
8110bbec:	1009883a 	mov	r4,r2
8110bbf0:	11401bc0 	call	811401bc <OSSemPost>

			return -ETIME;
8110bbf4:	00bff084 	movi	r2,-62
8110bbf8:	00003a06 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110bbfc:	e0bff10b 	ldhu	r2,-60(fp)
8110bc00:	10800044 	addi	r2,r2,1
8110bc04:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bc08:	e0bffd17 	ldw	r2,-12(fp)
8110bc0c:	10800317 	ldw	r2,12(r2)
8110bc10:	10800037 	ldwio	r2,0(r2)
8110bc14:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bc18:	e0fff017 	ldw	r3,-64(fp)
8110bc1c:	e0bff617 	ldw	r2,-40(fp)
8110bc20:	1884703a 	and	r2,r3,r2
8110bc24:	1000031e 	bne	r2,zero,8110bc34 <msgdma_descriptor_sync_transfer+0x3cc>
8110bc28:	e0bff017 	ldw	r2,-64(fp)
8110bc2c:	1080004c 	andi	r2,r2,1
8110bc30:	103fda1e 	bne	r2,zero,8110bb9c <__reset+0xfb0ebb9c>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110bc34:	e0fff017 	ldw	r3,-64(fp)
8110bc38:	e0bff617 	ldw	r2,-40(fp)
8110bc3c:	1884703a 	and	r2,r3,r2
8110bc40:	10000626 	beq	r2,zero,8110bc5c <msgdma_descriptor_sync_transfer+0x3f4>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bc44:	e0bffd17 	ldw	r2,-12(fp)
8110bc48:	10801817 	ldw	r2,96(r2)
8110bc4c:	1009883a 	mov	r4,r2
8110bc50:	11401bc0 	call	811401bc <OSSemPost>

		return error;
8110bc54:	e0bff617 	ldw	r2,-40(fp)
8110bc58:	00002206 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110bc5c:	e0bffd17 	ldw	r2,-12(fp)
8110bc60:	10800317 	ldw	r2,12(r2)
8110bc64:	10800104 	addi	r2,r2,4
8110bc68:	10800037 	ldwio	r2,0(r2)
8110bc6c:	10800814 	ori	r2,r2,32
8110bc70:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bc74:	0005303a 	rdctl	r2,status
8110bc78:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bc7c:	e0fffa17 	ldw	r3,-24(fp)
8110bc80:	00bfff84 	movi	r2,-2
8110bc84:	1884703a 	and	r2,r3,r2
8110bc88:	1001703a 	wrctl	status,r2
  
  return context;
8110bc8c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bc90:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bc94:	e0bffd17 	ldw	r2,-12(fp)
8110bc98:	10800317 	ldw	r2,12(r2)
8110bc9c:	10800104 	addi	r2,r2,4
8110bca0:	e0fff417 	ldw	r3,-48(fp)
8110bca4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bca8:	e0bffd17 	ldw	r2,-12(fp)
8110bcac:	10800317 	ldw	r2,12(r2)
8110bcb0:	e0fffd17 	ldw	r3,-12(fp)
8110bcb4:	18c00317 	ldw	r3,12(r3)
8110bcb8:	18c00037 	ldwio	r3,0(r3)
8110bcbc:	10c00035 	stwio	r3,0(r2)
8110bcc0:	e0bff517 	ldw	r2,-44(fp)
8110bcc4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bcc8:	e0bff917 	ldw	r2,-28(fp)
8110bccc:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110bcd0:	e0bffd17 	ldw	r2,-12(fp)
8110bcd4:	10801817 	ldw	r2,96(r2)
8110bcd8:	1009883a 	mov	r4,r2
8110bcdc:	11401bc0 	call	811401bc <OSSemPost>

	return 0;
8110bce0:	0005883a 	mov	r2,zero

}
8110bce4:	e037883a 	mov	sp,fp
8110bce8:	dfc00117 	ldw	ra,4(sp)
8110bcec:	df000017 	ldw	fp,0(sp)
8110bcf0:	dec00204 	addi	sp,sp,8
8110bcf4:	f800283a 	ret

8110bcf8 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110bcf8:	deffec04 	addi	sp,sp,-80
8110bcfc:	de00012e 	bgeu	sp,et,8110bd04 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110bd00:	003b68fa 	trap	3
8110bd04:	dfc01315 	stw	ra,76(sp)
8110bd08:	df001215 	stw	fp,72(sp)
8110bd0c:	df001204 	addi	fp,sp,72
8110bd10:	e13ff715 	stw	r4,-36(fp)
8110bd14:	e17ff815 	stw	r5,-32(fp)
8110bd18:	e1bff915 	stw	r6,-28(fp)
8110bd1c:	e1fffa15 	stw	r7,-24(fp)
8110bd20:	e1800617 	ldw	r6,24(fp)
8110bd24:	e1400717 	ldw	r5,28(fp)
8110bd28:	e1000817 	ldw	r4,32(fp)
8110bd2c:	e0c00917 	ldw	r3,36(fp)
8110bd30:	e0800a17 	ldw	r2,40(fp)
8110bd34:	e1bffb0d 	sth	r6,-20(fp)
8110bd38:	e17ffc05 	stb	r5,-16(fp)
8110bd3c:	e13ffd05 	stb	r4,-12(fp)
8110bd40:	e0fffe0d 	sth	r3,-8(fp)
8110bd44:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110bd48:	e0bffb0b 	ldhu	r2,-20(fp)
8110bd4c:	e0fffc03 	ldbu	r3,-16(fp)
8110bd50:	e13ffd03 	ldbu	r4,-12(fp)
8110bd54:	e17ffe0b 	ldhu	r5,-8(fp)
8110bd58:	e1bfff0b 	ldhu	r6,-4(fp)
8110bd5c:	d9800815 	stw	r6,32(sp)
8110bd60:	d9400715 	stw	r5,28(sp)
8110bd64:	d9000615 	stw	r4,24(sp)
8110bd68:	d8c00515 	stw	r3,20(sp)
8110bd6c:	d8800415 	stw	r2,16(sp)
8110bd70:	e0800517 	ldw	r2,20(fp)
8110bd74:	d8800315 	stw	r2,12(sp)
8110bd78:	e0800417 	ldw	r2,16(fp)
8110bd7c:	d8800215 	stw	r2,8(sp)
8110bd80:	e0800317 	ldw	r2,12(fp)
8110bd84:	d8800115 	stw	r2,4(sp)
8110bd88:	e0800217 	ldw	r2,8(fp)
8110bd8c:	d8800015 	stw	r2,0(sp)
8110bd90:	e1fffa17 	ldw	r7,-24(fp)
8110bd94:	e1bff917 	ldw	r6,-28(fp)
8110bd98:	e17ff817 	ldw	r5,-32(fp)
8110bd9c:	e13ff717 	ldw	r4,-36(fp)
8110bda0:	110b3bc0 	call	8110b3bc <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110bda4:	e037883a 	mov	sp,fp
8110bda8:	dfc00117 	ldw	ra,4(sp)
8110bdac:	df000017 	ldw	fp,0(sp)
8110bdb0:	dec00204 	addi	sp,sp,8
8110bdb4:	f800283a 	ret

8110bdb8 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bdb8:	defffc04 	addi	sp,sp,-16
8110bdbc:	de00012e 	bgeu	sp,et,8110bdc4 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110bdc0:	003b68fa 	trap	3
8110bdc4:	dfc00315 	stw	ra,12(sp)
8110bdc8:	df000215 	stw	fp,8(sp)
8110bdcc:	df000204 	addi	fp,sp,8
8110bdd0:	e13ffe15 	stw	r4,-8(fp)
8110bdd4:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110bdd8:	e1bfff17 	ldw	r6,-4(fp)
8110bddc:	000b883a 	mov	r5,zero
8110bde0:	e13ffe17 	ldw	r4,-8(fp)
8110bde4:	110b5200 	call	8110b520 <msgdma_descriptor_async_transfer>
}
8110bde8:	e037883a 	mov	sp,fp
8110bdec:	dfc00117 	ldw	ra,4(sp)
8110bdf0:	df000017 	ldw	fp,0(sp)
8110bdf4:	dec00204 	addi	sp,sp,8
8110bdf8:	f800283a 	ret

8110bdfc <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bdfc:	defffc04 	addi	sp,sp,-16
8110be00:	de00012e 	bgeu	sp,et,8110be08 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110be04:	003b68fa 	trap	3
8110be08:	dfc00315 	stw	ra,12(sp)
8110be0c:	df000215 	stw	fp,8(sp)
8110be10:	df000204 	addi	fp,sp,8
8110be14:	e13ffe15 	stw	r4,-8(fp)
8110be18:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110be1c:	e1bfff17 	ldw	r6,-4(fp)
8110be20:	000b883a 	mov	r5,zero
8110be24:	e13ffe17 	ldw	r4,-8(fp)
8110be28:	110b8680 	call	8110b868 <msgdma_descriptor_sync_transfer>
}
8110be2c:	e037883a 	mov	sp,fp
8110be30:	dfc00117 	ldw	ra,4(sp)
8110be34:	df000017 	ldw	fp,0(sp)
8110be38:	dec00204 	addi	sp,sp,8
8110be3c:	f800283a 	ret

8110be40 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110be40:	defff204 	addi	sp,sp,-56
8110be44:	de00012e 	bgeu	sp,et,8110be4c <POWER_SPI_RW+0xc>
8110be48:	003b68fa 	trap	3
8110be4c:	dfc00d15 	stw	ra,52(sp)
8110be50:	df000c15 	stw	fp,48(sp)
8110be54:	df000c04 	addi	fp,sp,48
8110be58:	2007883a 	mov	r3,r4
8110be5c:	2805883a 	mov	r2,r5
8110be60:	e1bffe15 	stw	r6,-8(fp)
8110be64:	e1ffff15 	stw	r7,-4(fp)
8110be68:	e0fffc05 	stb	r3,-16(fp)
8110be6c:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110be70:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110be74:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110be78:	008003f4 	movhi	r2,15
8110be7c:	10909004 	addi	r2,r2,16960
8110be80:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110be84:	00bfe004 	movi	r2,-128
8110be88:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110be8c:	e0bffe17 	ldw	r2,-8(fp)
8110be90:	10000226 	beq	r2,zero,8110be9c <POWER_SPI_RW+0x5c>
8110be94:	00800804 	movi	r2,32
8110be98:	00000106 	br	8110bea0 <POWER_SPI_RW+0x60>
8110be9c:	0005883a 	mov	r2,zero
8110bea0:	e0fff403 	ldbu	r3,-48(fp)
8110bea4:	10c4b03a 	or	r2,r2,r3
8110bea8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110beac:	e0800217 	ldw	r2,8(fp)
8110beb0:	10000226 	beq	r2,zero,8110bebc <POWER_SPI_RW+0x7c>
8110beb4:	00800404 	movi	r2,16
8110beb8:	00000106 	br	8110bec0 <POWER_SPI_RW+0x80>
8110bebc:	0005883a 	mov	r2,zero
8110bec0:	e0fff403 	ldbu	r3,-48(fp)
8110bec4:	10c4b03a 	or	r2,r2,r3
8110bec8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110becc:	e0bfff17 	ldw	r2,-4(fp)
8110bed0:	10000226 	beq	r2,zero,8110bedc <POWER_SPI_RW+0x9c>
8110bed4:	00800204 	movi	r2,8
8110bed8:	00000106 	br	8110bee0 <POWER_SPI_RW+0xa0>
8110bedc:	0005883a 	mov	r2,zero
8110bee0:	e0fff403 	ldbu	r3,-48(fp)
8110bee4:	10c4b03a 	or	r2,r2,r3
8110bee8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110beec:	e0bffd03 	ldbu	r2,-12(fp)
8110bef0:	108001cc 	andi	r2,r2,7
8110bef4:	1007883a 	mov	r3,r2
8110bef8:	e0bff403 	ldbu	r2,-48(fp)
8110befc:	1884b03a 	or	r2,r3,r2
8110bf00:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110bf04:	0007883a 	mov	r3,zero
8110bf08:	00a00034 	movhi	r2,32768
8110bf0c:	10824404 	addi	r2,r2,2320
8110bf10:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110bf14:	0007883a 	mov	r3,zero
8110bf18:	00a00034 	movhi	r2,32768
8110bf1c:	10824c04 	addi	r2,r2,2352
8110bf20:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110bf24:	e0bffc03 	ldbu	r2,-16(fp)
8110bf28:	1000021e 	bne	r2,zero,8110bf34 <POWER_SPI_RW+0xf4>
8110bf2c:	00c00084 	movi	r3,2
8110bf30:	00000106 	br	8110bf38 <POWER_SPI_RW+0xf8>
8110bf34:	00c00044 	movi	r3,1
8110bf38:	00a00034 	movhi	r2,32768
8110bf3c:	10824804 	addi	r2,r2,2336
8110bf40:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110bf44:	010003c4 	movi	r4,15
8110bf48:	11390300 	call	81139030 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf4c:	00000306 	br	8110bf5c <POWER_SPI_RW+0x11c>
		nWait++;
8110bf50:	e0bff817 	ldw	r2,-32(fp)
8110bf54:	10800044 	addi	r2,r2,1
8110bf58:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf5c:	00a00034 	movhi	r2,32768
8110bf60:	10825404 	addi	r2,r2,2384
8110bf64:	10800037 	ldwio	r2,0(r2)
8110bf68:	1080004c 	andi	r2,r2,1
8110bf6c:	10000326 	beq	r2,zero,8110bf7c <POWER_SPI_RW+0x13c>
8110bf70:	e0fff817 	ldw	r3,-32(fp)
8110bf74:	e0bffa17 	ldw	r2,-24(fp)
8110bf78:	18bff516 	blt	r3,r2,8110bf50 <__reset+0xfb0ebf50>
		nWait++;
	}

	if (SPI_SDO) {
8110bf7c:	00a00034 	movhi	r2,32768
8110bf80:	10825404 	addi	r2,r2,2384
8110bf84:	10800037 	ldwio	r2,0(r2)
8110bf88:	1080004c 	andi	r2,r2,1
8110bf8c:	10000626 	beq	r2,zero,8110bfa8 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110bf90:	00c000c4 	movi	r3,3
8110bf94:	00a00034 	movhi	r2,32768
8110bf98:	10824804 	addi	r2,r2,2336
8110bf9c:	10c00035 	stwio	r3,0(r2)
		return FALSE;
8110bfa0:	0005883a 	mov	r2,zero
8110bfa4:	0000db06 	br	8110c314 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110bfa8:	e03ff715 	stw	zero,-36(fp)
8110bfac:	00002406 	br	8110c040 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110bfb0:	e0bff403 	ldbu	r2,-48(fp)
8110bfb4:	10803fcc 	andi	r2,r2,255
8110bfb8:	1004d1fa 	srli	r2,r2,7
8110bfbc:	10c03fcc 	andi	r3,r2,255
8110bfc0:	00a00034 	movhi	r2,32768
8110bfc4:	10825004 	addi	r2,r2,2368
8110bfc8:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110bfcc:	e0bff403 	ldbu	r2,-48(fp)
8110bfd0:	1085883a 	add	r2,r2,r2
8110bfd4:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110bfd8:	e0bff517 	ldw	r2,-44(fp)
8110bfdc:	1085883a 	add	r2,r2,r2
8110bfe0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110bfe4:	00a00034 	movhi	r2,32768
8110bfe8:	10825404 	addi	r2,r2,2384
8110bfec:	10800037 	ldwio	r2,0(r2)
8110bff0:	1080004c 	andi	r2,r2,1
8110bff4:	1007883a 	mov	r3,r2
8110bff8:	e0bff517 	ldw	r2,-44(fp)
8110bffc:	10c4b03a 	or	r2,r2,r3
8110c000:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c004:	00c00044 	movi	r3,1
8110c008:	00a00034 	movhi	r2,32768
8110c00c:	10824c04 	addi	r2,r2,2352
8110c010:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c014:	010003c4 	movi	r4,15
8110c018:	11390300 	call	81139030 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c01c:	0007883a 	mov	r3,zero
8110c020:	00a00034 	movhi	r2,32768
8110c024:	10824c04 	addi	r2,r2,2352
8110c028:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c02c:	010003c4 	movi	r4,15
8110c030:	11390300 	call	81139030 <usleep>
	if (SPI_SDO) {
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c034:	e0bff717 	ldw	r2,-36(fp)
8110c038:	10800044 	addi	r2,r2,1
8110c03c:	e0bff715 	stw	r2,-36(fp)
8110c040:	e0bff717 	ldw	r2,-36(fp)
8110c044:	10800090 	cmplti	r2,r2,2
8110c048:	103fd91e 	bne	r2,zero,8110bfb0 <__reset+0xfb0ebfb0>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c04c:	e03ff715 	stw	zero,-36(fp)
8110c050:	00002406 	br	8110c0e4 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110c054:	e0bff403 	ldbu	r2,-48(fp)
8110c058:	10803fcc 	andi	r2,r2,255
8110c05c:	1004d1fa 	srli	r2,r2,7
8110c060:	10c03fcc 	andi	r3,r2,255
8110c064:	00a00034 	movhi	r2,32768
8110c068:	10825004 	addi	r2,r2,2368
8110c06c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c070:	e0bff403 	ldbu	r2,-48(fp)
8110c074:	1085883a 	add	r2,r2,r2
8110c078:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110c07c:	e0bff517 	ldw	r2,-44(fp)
8110c080:	1085883a 	add	r2,r2,r2
8110c084:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110c088:	00a00034 	movhi	r2,32768
8110c08c:	10825404 	addi	r2,r2,2384
8110c090:	10800037 	ldwio	r2,0(r2)
8110c094:	1080004c 	andi	r2,r2,1
8110c098:	1007883a 	mov	r3,r2
8110c09c:	e0bff517 	ldw	r2,-44(fp)
8110c0a0:	10c4b03a 	or	r2,r2,r3
8110c0a4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c0a8:	00c00044 	movi	r3,1
8110c0ac:	00a00034 	movhi	r2,32768
8110c0b0:	10824c04 	addi	r2,r2,2352
8110c0b4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0b8:	010003c4 	movi	r4,15
8110c0bc:	11390300 	call	81139030 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c0c0:	0007883a 	mov	r3,zero
8110c0c4:	00a00034 	movhi	r2,32768
8110c0c8:	10824c04 	addi	r2,r2,2352
8110c0cc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0d0:	010003c4 	movi	r4,15
8110c0d4:	11390300 	call	81139030 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c0d8:	e0bff717 	ldw	r2,-36(fp)
8110c0dc:	10800044 	addi	r2,r2,1
8110c0e0:	e0bff715 	stw	r2,-36(fp)
8110c0e4:	e0bff717 	ldw	r2,-36(fp)
8110c0e8:	10800210 	cmplti	r2,r2,8
8110c0ec:	103fd91e 	bne	r2,zero,8110c054 <__reset+0xfb0ec054>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c0f0:	e03ff715 	stw	zero,-36(fp)
8110c0f4:	00001a06 	br	8110c160 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110c0f8:	e0bff517 	ldw	r2,-44(fp)
8110c0fc:	1085883a 	add	r2,r2,r2
8110c100:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110c104:	00a00034 	movhi	r2,32768
8110c108:	10825404 	addi	r2,r2,2384
8110c10c:	10800037 	ldwio	r2,0(r2)
8110c110:	1080004c 	andi	r2,r2,1
8110c114:	1007883a 	mov	r3,r2
8110c118:	e0bff517 	ldw	r2,-44(fp)
8110c11c:	10c4b03a 	or	r2,r2,r3
8110c120:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c124:	00c00044 	movi	r3,1
8110c128:	00a00034 	movhi	r2,32768
8110c12c:	10824c04 	addi	r2,r2,2352
8110c130:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c134:	010003c4 	movi	r4,15
8110c138:	11390300 	call	81139030 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c13c:	0007883a 	mov	r3,zero
8110c140:	00a00034 	movhi	r2,32768
8110c144:	10824c04 	addi	r2,r2,2352
8110c148:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c14c:	010003c4 	movi	r4,15
8110c150:	11390300 	call	81139030 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c154:	e0bff717 	ldw	r2,-36(fp)
8110c158:	10800044 	addi	r2,r2,1
8110c15c:	e0bff715 	stw	r2,-36(fp)
8110c160:	e0bff717 	ldw	r2,-36(fp)
8110c164:	10800210 	cmplti	r2,r2,8
8110c168:	103fe31e 	bne	r2,zero,8110c0f8 <__reset+0xfb0ec0f8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c16c:	e03ff715 	stw	zero,-36(fp)
8110c170:	00001a06 	br	8110c1dc <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c174:	e0bff517 	ldw	r2,-44(fp)
8110c178:	1085883a 	add	r2,r2,r2
8110c17c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c180:	00a00034 	movhi	r2,32768
8110c184:	10825404 	addi	r2,r2,2384
8110c188:	10800037 	ldwio	r2,0(r2)
8110c18c:	1080004c 	andi	r2,r2,1
8110c190:	1007883a 	mov	r3,r2
8110c194:	e0bff517 	ldw	r2,-44(fp)
8110c198:	10c4b03a 	or	r2,r2,r3
8110c19c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c1a0:	00c00044 	movi	r3,1
8110c1a4:	00a00034 	movhi	r2,32768
8110c1a8:	10824c04 	addi	r2,r2,2352
8110c1ac:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1b0:	010003c4 	movi	r4,15
8110c1b4:	11390300 	call	81139030 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c1b8:	0007883a 	mov	r3,zero
8110c1bc:	00a00034 	movhi	r2,32768
8110c1c0:	10824c04 	addi	r2,r2,2352
8110c1c4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1c8:	010003c4 	movi	r4,15
8110c1cc:	11390300 	call	81139030 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c1d0:	e0bff717 	ldw	r2,-36(fp)
8110c1d4:	10800044 	addi	r2,r2,1
8110c1d8:	e0bff715 	stw	r2,-36(fp)
8110c1dc:	e0bff717 	ldw	r2,-36(fp)
8110c1e0:	10800210 	cmplti	r2,r2,8
8110c1e4:	103fe31e 	bne	r2,zero,8110c174 <__reset+0xfb0ec174>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c1e8:	e03ff715 	stw	zero,-36(fp)
8110c1ec:	00001a06 	br	8110c258 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c1f0:	e0bff517 	ldw	r2,-44(fp)
8110c1f4:	1085883a 	add	r2,r2,r2
8110c1f8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c1fc:	00a00034 	movhi	r2,32768
8110c200:	10825404 	addi	r2,r2,2384
8110c204:	10800037 	ldwio	r2,0(r2)
8110c208:	1080004c 	andi	r2,r2,1
8110c20c:	1007883a 	mov	r3,r2
8110c210:	e0bff517 	ldw	r2,-44(fp)
8110c214:	10c4b03a 	or	r2,r2,r3
8110c218:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c21c:	00c00044 	movi	r3,1
8110c220:	00a00034 	movhi	r2,32768
8110c224:	10824c04 	addi	r2,r2,2352
8110c228:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c22c:	010003c4 	movi	r4,15
8110c230:	11390300 	call	81139030 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c234:	0007883a 	mov	r3,zero
8110c238:	00a00034 	movhi	r2,32768
8110c23c:	10824c04 	addi	r2,r2,2352
8110c240:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c244:	010003c4 	movi	r4,15
8110c248:	11390300 	call	81139030 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c24c:	e0bff717 	ldw	r2,-36(fp)
8110c250:	10800044 	addi	r2,r2,1
8110c254:	e0bff715 	stw	r2,-36(fp)
8110c258:	e0bff717 	ldw	r2,-36(fp)
8110c25c:	10800190 	cmplti	r2,r2,6
8110c260:	103fe31e 	bne	r2,zero,8110c1f0 <__reset+0xfb0ec1f0>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c264:	00c00044 	movi	r3,1
8110c268:	00a00034 	movhi	r2,32768
8110c26c:	10824c04 	addi	r2,r2,2352
8110c270:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c274:	010003c4 	movi	r4,15
8110c278:	11390300 	call	81139030 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c27c:	00c000c4 	movi	r3,3
8110c280:	00a00034 	movhi	r2,32768
8110c284:	10824804 	addi	r2,r2,2336
8110c288:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c28c:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c290:	00800044 	movi	r2,1
8110c294:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c298:	e03ff715 	stw	zero,-36(fp)
8110c29c:	00000d06 	br	8110c2d4 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c2a0:	e0fff517 	ldw	r3,-44(fp)
8110c2a4:	e0bff617 	ldw	r2,-40(fp)
8110c2a8:	1884703a 	and	r2,r3,r2
8110c2ac:	1000031e 	bne	r2,zero,8110c2bc <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c2b0:	e0bff917 	ldw	r2,-28(fp)
8110c2b4:	10800044 	addi	r2,r2,1
8110c2b8:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c2bc:	e0bff617 	ldw	r2,-40(fp)
8110c2c0:	1085883a 	add	r2,r2,r2
8110c2c4:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c2c8:	e0bff717 	ldw	r2,-36(fp)
8110c2cc:	10800044 	addi	r2,r2,1
8110c2d0:	e0bff715 	stw	r2,-36(fp)
8110c2d4:	e0bff717 	ldw	r2,-36(fp)
8110c2d8:	10800810 	cmplti	r2,r2,32
8110c2dc:	103ff01e 	bne	r2,zero,8110c2a0 <__reset+0xfb0ec2a0>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c2e0:	e0bff917 	ldw	r2,-28(fp)
8110c2e4:	1080004c 	andi	r2,r2,1
8110c2e8:	1005003a 	cmpeq	r2,r2,zero
8110c2ec:	10803fcc 	andi	r2,r2,255
8110c2f0:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c2f4:	e0bffb17 	ldw	r2,-20(fp)
8110c2f8:	1000021e 	bne	r2,zero,8110c304 <POWER_SPI_RW+0x4c4>
		return FALSE;
8110c2fc:	0005883a 	mov	r2,zero
8110c300:	00000406 	br	8110c314 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c304:	e0800317 	ldw	r2,12(fp)
8110c308:	e0fff517 	ldw	r3,-44(fp)
8110c30c:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110c310:	e0bffb17 	ldw	r2,-20(fp)
}
8110c314:	e037883a 	mov	sp,fp
8110c318:	dfc00117 	ldw	ra,4(sp)
8110c31c:	df000017 	ldw	fp,0(sp)
8110c320:	dec00204 	addi	sp,sp,8
8110c324:	f800283a 	ret

8110c328 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110c328:	defffc04 	addi	sp,sp,-16
8110c32c:	de00012e 	bgeu	sp,et,8110c334 <vRstcSimucamReset+0xc>
8110c330:	003b68fa 	trap	3
8110c334:	dfc00315 	stw	ra,12(sp)
8110c338:	df000215 	stw	fp,8(sp)
8110c33c:	df000204 	addi	fp,sp,8
8110c340:	2005883a 	mov	r2,r4
8110c344:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110c348:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110c34c:	e0bfff0b 	ldhu	r2,-4(fp)
8110c350:	e0fffe17 	ldw	r3,-8(fp)
8110c354:	1884b03a 	or	r2,r3,r2
8110c358:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110c35c:	e0bffe17 	ldw	r2,-8(fp)
8110c360:	10800074 	orhi	r2,r2,1
8110c364:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c368:	e1bffe17 	ldw	r6,-8(fp)
8110c36c:	000b883a 	mov	r5,zero
8110c370:	01200034 	movhi	r4,32768
8110c374:	21020004 	addi	r4,r4,2048
8110c378:	110c4780 	call	8110c478 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110c37c:	0001883a 	nop
8110c380:	e037883a 	mov	sp,fp
8110c384:	dfc00117 	ldw	ra,4(sp)
8110c388:	df000017 	ldw	fp,0(sp)
8110c38c:	dec00204 	addi	sp,sp,8
8110c390:	f800283a 	ret

8110c394 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110c394:	defffc04 	addi	sp,sp,-16
8110c398:	de00012e 	bgeu	sp,et,8110c3a0 <vRstcReleaseDeviceReset+0xc>
8110c39c:	003b68fa 	trap	3
8110c3a0:	dfc00315 	stw	ra,12(sp)
8110c3a4:	df000215 	stw	fp,8(sp)
8110c3a8:	df000204 	addi	fp,sp,8
8110c3ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c3b0:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3b4:	01400044 	movi	r5,1
8110c3b8:	01200034 	movhi	r4,32768
8110c3bc:	21020004 	addi	r4,r4,2048
8110c3c0:	110c4cc0 	call	8110c4cc <uliRstReadReg>
8110c3c4:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110c3c8:	e0bfff17 	ldw	r2,-4(fp)
8110c3cc:	0084303a 	nor	r2,zero,r2
8110c3d0:	e0fffe17 	ldw	r3,-8(fp)
8110c3d4:	1884703a 	and	r2,r3,r2
8110c3d8:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3dc:	e1bffe17 	ldw	r6,-8(fp)
8110c3e0:	01400044 	movi	r5,1
8110c3e4:	01200034 	movhi	r4,32768
8110c3e8:	21020004 	addi	r4,r4,2048
8110c3ec:	110c4780 	call	8110c478 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c3f0:	0001883a 	nop
8110c3f4:	e037883a 	mov	sp,fp
8110c3f8:	dfc00117 	ldw	ra,4(sp)
8110c3fc:	df000017 	ldw	fp,0(sp)
8110c400:	dec00204 	addi	sp,sp,8
8110c404:	f800283a 	ret

8110c408 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110c408:	defffc04 	addi	sp,sp,-16
8110c40c:	de00012e 	bgeu	sp,et,8110c414 <vRstcHoldDeviceReset+0xc>
8110c410:	003b68fa 	trap	3
8110c414:	dfc00315 	stw	ra,12(sp)
8110c418:	df000215 	stw	fp,8(sp)
8110c41c:	df000204 	addi	fp,sp,8
8110c420:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c424:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c428:	01400044 	movi	r5,1
8110c42c:	01200034 	movhi	r4,32768
8110c430:	21020004 	addi	r4,r4,2048
8110c434:	110c4cc0 	call	8110c4cc <uliRstReadReg>
8110c438:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110c43c:	e0fffe17 	ldw	r3,-8(fp)
8110c440:	e0bfff17 	ldw	r2,-4(fp)
8110c444:	1884b03a 	or	r2,r3,r2
8110c448:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c44c:	e1bffe17 	ldw	r6,-8(fp)
8110c450:	01400044 	movi	r5,1
8110c454:	01200034 	movhi	r4,32768
8110c458:	21020004 	addi	r4,r4,2048
8110c45c:	110c4780 	call	8110c478 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c460:	0001883a 	nop
8110c464:	e037883a 	mov	sp,fp
8110c468:	dfc00117 	ldw	ra,4(sp)
8110c46c:	df000017 	ldw	fp,0(sp)
8110c470:	dec00204 	addi	sp,sp,8
8110c474:	f800283a 	ret

8110c478 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110c478:	defffc04 	addi	sp,sp,-16
8110c47c:	de00012e 	bgeu	sp,et,8110c484 <vRstcWriteReg+0xc>
8110c480:	003b68fa 	trap	3
8110c484:	df000315 	stw	fp,12(sp)
8110c488:	df000304 	addi	fp,sp,12
8110c48c:	e13ffd15 	stw	r4,-12(fp)
8110c490:	e17ffe15 	stw	r5,-8(fp)
8110c494:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110c498:	e0bffe17 	ldw	r2,-8(fp)
8110c49c:	1085883a 	add	r2,r2,r2
8110c4a0:	1085883a 	add	r2,r2,r2
8110c4a4:	1007883a 	mov	r3,r2
8110c4a8:	e0bffd17 	ldw	r2,-12(fp)
8110c4ac:	10c5883a 	add	r2,r2,r3
8110c4b0:	e0ffff17 	ldw	r3,-4(fp)
8110c4b4:	10c00015 	stw	r3,0(r2)
}
8110c4b8:	0001883a 	nop
8110c4bc:	e037883a 	mov	sp,fp
8110c4c0:	df000017 	ldw	fp,0(sp)
8110c4c4:	dec00104 	addi	sp,sp,4
8110c4c8:	f800283a 	ret

8110c4cc <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110c4cc:	defffc04 	addi	sp,sp,-16
8110c4d0:	de00012e 	bgeu	sp,et,8110c4d8 <uliRstReadReg+0xc>
8110c4d4:	003b68fa 	trap	3
8110c4d8:	df000315 	stw	fp,12(sp)
8110c4dc:	df000304 	addi	fp,sp,12
8110c4e0:	e13ffe15 	stw	r4,-8(fp)
8110c4e4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110c4e8:	e0bfff17 	ldw	r2,-4(fp)
8110c4ec:	1085883a 	add	r2,r2,r2
8110c4f0:	1085883a 	add	r2,r2,r2
8110c4f4:	1007883a 	mov	r3,r2
8110c4f8:	e0bffe17 	ldw	r2,-8(fp)
8110c4fc:	10c5883a 	add	r2,r2,r3
8110c500:	10800017 	ldw	r2,0(r2)
8110c504:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110c508:	e0bffd17 	ldw	r2,-12(fp)
}
8110c50c:	e037883a 	mov	sp,fp
8110c510:	df000017 	ldw	fp,0(sp)
8110c514:	dec00104 	addi	sp,sp,4
8110c518:	f800283a 	ret

8110c51c <v_spi_start>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c51c:	defffe04 	addi	sp,sp,-8
8110c520:	de00012e 	bgeu	sp,et,8110c528 <v_spi_start+0xc>
8110c524:	003b68fa 	trap	3
8110c528:	dfc00115 	stw	ra,4(sp)
8110c52c:	df000015 	stw	fp,0(sp)
8110c530:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c534:	0007883a 	mov	r3,zero
8110c538:	00a00034 	movhi	r2,32768
8110c53c:	10823004 	addi	r2,r2,2240
8110c540:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c544:	0007883a 	mov	r3,zero
8110c548:	00a00034 	movhi	r2,32768
8110c54c:	10822c04 	addi	r2,r2,2224
8110c550:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c554:	01002584 	movi	r4,150
8110c558:	11390300 	call	81139030 <usleep>
}
8110c55c:	0001883a 	nop
8110c560:	e037883a 	mov	sp,fp
8110c564:	dfc00117 	ldw	ra,4(sp)
8110c568:	df000017 	ldw	fp,0(sp)
8110c56c:	dec00204 	addi	sp,sp,8
8110c570:	f800283a 	ret

8110c574 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c574:	defffc04 	addi	sp,sp,-16
8110c578:	de00012e 	bgeu	sp,et,8110c580 <v_spi_send_byte+0xc>
8110c57c:	003b68fa 	trap	3
8110c580:	dfc00315 	stw	ra,12(sp)
8110c584:	df000215 	stw	fp,8(sp)
8110c588:	df000204 	addi	fp,sp,8
8110c58c:	2005883a 	mov	r2,r4
8110c590:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c594:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c598:	00bfe004 	movi	r2,-128
8110c59c:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c5a0:	e03ffe05 	stb	zero,-8(fp)
8110c5a4:	00001b06 	br	8110c614 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c5a8:	e0ffff03 	ldbu	r3,-4(fp)
8110c5ac:	e0bffe43 	ldbu	r2,-7(fp)
8110c5b0:	1884703a 	and	r2,r3,r2
8110c5b4:	10803fcc 	andi	r2,r2,255
8110c5b8:	1004c03a 	cmpne	r2,r2,zero
8110c5bc:	10c03fcc 	andi	r3,r2,255
8110c5c0:	00a00034 	movhi	r2,32768
8110c5c4:	10823404 	addi	r2,r2,2256
8110c5c8:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c5cc:	e0bffe43 	ldbu	r2,-7(fp)
8110c5d0:	1004d07a 	srli	r2,r2,1
8110c5d4:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c5d8:	00c00044 	movi	r3,1
8110c5dc:	00a00034 	movhi	r2,32768
8110c5e0:	10823004 	addi	r2,r2,2240
8110c5e4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c5e8:	01002584 	movi	r4,150
8110c5ec:	11390300 	call	81139030 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c5f0:	0007883a 	mov	r3,zero
8110c5f4:	00a00034 	movhi	r2,32768
8110c5f8:	10823004 	addi	r2,r2,2240
8110c5fc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c600:	01002584 	movi	r4,150
8110c604:	11390300 	call	81139030 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c608:	e0bffe03 	ldbu	r2,-8(fp)
8110c60c:	10800044 	addi	r2,r2,1
8110c610:	e0bffe05 	stb	r2,-8(fp)
8110c614:	e0bffe03 	ldbu	r2,-8(fp)
8110c618:	10800230 	cmpltui	r2,r2,8
8110c61c:	103fe21e 	bne	r2,zero,8110c5a8 <__reset+0xfb0ec5a8>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c620:	0001883a 	nop
8110c624:	e037883a 	mov	sp,fp
8110c628:	dfc00117 	ldw	ra,4(sp)
8110c62c:	df000017 	ldw	fp,0(sp)
8110c630:	dec00204 	addi	sp,sp,8
8110c634:	f800283a 	ret

8110c638 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c638:	defffd04 	addi	sp,sp,-12
8110c63c:	de00012e 	bgeu	sp,et,8110c644 <uc_spi_get_byte+0xc>
8110c640:	003b68fa 	trap	3
8110c644:	dfc00215 	stw	ra,8(sp)
8110c648:	df000115 	stw	fp,4(sp)
8110c64c:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c650:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c654:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c658:	e03fff05 	stb	zero,-4(fp)
8110c65c:	00001a06 	br	8110c6c8 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c660:	e0bfff43 	ldbu	r2,-3(fp)
8110c664:	1085883a 	add	r2,r2,r2
8110c668:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c66c:	00a00034 	movhi	r2,32768
8110c670:	10823804 	addi	r2,r2,2272
8110c674:	10800037 	ldwio	r2,0(r2)
8110c678:	1080004c 	andi	r2,r2,1
8110c67c:	1007883a 	mov	r3,r2
8110c680:	e0bfff43 	ldbu	r2,-3(fp)
8110c684:	1884b03a 	or	r2,r3,r2
8110c688:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c68c:	00c00044 	movi	r3,1
8110c690:	00a00034 	movhi	r2,32768
8110c694:	10823004 	addi	r2,r2,2240
8110c698:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c69c:	01002584 	movi	r4,150
8110c6a0:	11390300 	call	81139030 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c6a4:	0007883a 	mov	r3,zero
8110c6a8:	00a00034 	movhi	r2,32768
8110c6ac:	10823004 	addi	r2,r2,2240
8110c6b0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c6b4:	01002584 	movi	r4,150
8110c6b8:	11390300 	call	81139030 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c6bc:	e0bfff03 	ldbu	r2,-4(fp)
8110c6c0:	10800044 	addi	r2,r2,1
8110c6c4:	e0bfff05 	stb	r2,-4(fp)
8110c6c8:	e0bfff03 	ldbu	r2,-4(fp)
8110c6cc:	10800230 	cmpltui	r2,r2,8
8110c6d0:	103fe31e 	bne	r2,zero,8110c660 <__reset+0xfb0ec660>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c6d4:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c6d8:	e037883a 	mov	sp,fp
8110c6dc:	dfc00117 	ldw	ra,4(sp)
8110c6e0:	df000017 	ldw	fp,0(sp)
8110c6e4:	dec00204 	addi	sp,sp,8
8110c6e8:	f800283a 	ret

8110c6ec <v_spi_end>:

void v_spi_end(void){
8110c6ec:	defffe04 	addi	sp,sp,-8
8110c6f0:	de00012e 	bgeu	sp,et,8110c6f8 <v_spi_end+0xc>
8110c6f4:	003b68fa 	trap	3
8110c6f8:	dfc00115 	stw	ra,4(sp)
8110c6fc:	df000015 	stw	fp,0(sp)
8110c700:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c704:	0007883a 	mov	r3,zero
8110c708:	00a00034 	movhi	r2,32768
8110c70c:	10823004 	addi	r2,r2,2240
8110c710:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c714:	01002584 	movi	r4,150
8110c718:	11390300 	call	81139030 <usleep>
    SPI_CS_N(1);
8110c71c:	00c00044 	movi	r3,1
8110c720:	00a00034 	movhi	r2,32768
8110c724:	10822c04 	addi	r2,r2,2224
8110c728:	10c00035 	stwio	r3,0(r2)
}
8110c72c:	0001883a 	nop
8110c730:	e037883a 	mov	sp,fp
8110c734:	dfc00117 	ldw	ra,4(sp)
8110c738:	df000017 	ldw	fp,0(sp)
8110c73c:	dec00204 	addi	sp,sp,8
8110c740:	f800283a 	ret

8110c744 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c744:	defff604 	addi	sp,sp,-40
8110c748:	de00012e 	bgeu	sp,et,8110c750 <RTCC_SPI_R_MAC+0xc>
8110c74c:	003b68fa 	trap	3
8110c750:	dfc00915 	stw	ra,36(sp)
8110c754:	df000815 	stw	fp,32(sp)
8110c758:	df000804 	addi	fp,sp,32
8110c75c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c760:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c764:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c768:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c76c:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c770:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c774:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c778:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c77c:	00800084 	movi	r2,2
8110c780:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c784:	00800cc4 	movi	r2,51
8110c788:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c78c:	110c51c0 	call	8110c51c <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c790:	e0bffec3 	ldbu	r2,-5(fp)
8110c794:	1009883a 	mov	r4,r2
8110c798:	110c5740 	call	8110c574 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c79c:	e0bffe83 	ldbu	r2,-6(fp)
8110c7a0:	1009883a 	mov	r4,r2
8110c7a4:	110c5740 	call	8110c574 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c7a8:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7ac:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c7b0:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7b4:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c7b8:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7bc:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c7c0:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7c4:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c7c8:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7cc:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c7d0:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7d4:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c7d8:	110c6ec0 	call	8110c6ec <v_spi_end>

    bSuccess = TRUE;
8110c7dc:	00800044 	movi	r2,1
8110c7e0:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c7e4:	e0bfff17 	ldw	r2,-4(fp)
8110c7e8:	e0fffd03 	ldbu	r3,-12(fp)
8110c7ec:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c7f0:	e0bfff17 	ldw	r2,-4(fp)
8110c7f4:	10800044 	addi	r2,r2,1
8110c7f8:	e0fffd43 	ldbu	r3,-11(fp)
8110c7fc:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c800:	e0bfff17 	ldw	r2,-4(fp)
8110c804:	10800084 	addi	r2,r2,2
8110c808:	e0fffd83 	ldbu	r3,-10(fp)
8110c80c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c810:	e0bfff17 	ldw	r2,-4(fp)
8110c814:	108000c4 	addi	r2,r2,3
8110c818:	e0fffdc3 	ldbu	r3,-9(fp)
8110c81c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c820:	e0bfff17 	ldw	r2,-4(fp)
8110c824:	10800104 	addi	r2,r2,4
8110c828:	e0fffe03 	ldbu	r3,-8(fp)
8110c82c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c830:	e0bfff17 	ldw	r2,-4(fp)
8110c834:	10800144 	addi	r2,r2,5
8110c838:	e0fffe43 	ldbu	r3,-7(fp)
8110c83c:	10c00005 	stb	r3,0(r2)

#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110c840:	00a045f4 	movhi	r2,33047
8110c844:	10a00404 	addi	r2,r2,-32752
8110c848:	10800e8b 	ldhu	r2,58(r2)
8110c84c:	10bfffcc 	andi	r2,r2,65535
8110c850:	108000e8 	cmpgeui	r2,r2,3
8110c854:	1000141e 	bne	r2,zero,8110c8a8 <RTCC_SPI_R_MAC+0x164>
		sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c858:	e1bffd03 	ldbu	r6,-12(fp)
8110c85c:	e1fffd43 	ldbu	r7,-11(fp)
8110c860:	e0bffd83 	ldbu	r2,-10(fp)
8110c864:	e0fffdc3 	ldbu	r3,-9(fp)
8110c868:	e13ffe03 	ldbu	r4,-8(fp)
8110c86c:	e17ffe43 	ldbu	r5,-7(fp)
8110c870:	d9400315 	stw	r5,12(sp)
8110c874:	d9000215 	stw	r4,8(sp)
8110c878:	d8c00115 	stw	r3,4(sp)
8110c87c:	d8800015 	stw	r2,0(sp)
8110c880:	01604574 	movhi	r5,33045
8110c884:	29764304 	addi	r5,r5,-9972
8110c888:	01204574 	movhi	r4,33045
8110c88c:	21122004 	addi	r4,r4,18560
8110c890:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
8110c894:	d0a06217 	ldw	r2,-32376(gp)
8110c898:	01604574 	movhi	r5,33045
8110c89c:	29522004 	addi	r5,r5,18560
8110c8a0:	1009883a 	mov	r4,r2
8110c8a4:	11229940 	call	81122994 <fprintf>
    }
#endif

    return bSuccess;
8110c8a8:	e0bffc17 	ldw	r2,-16(fp)
}
8110c8ac:	e037883a 	mov	sp,fp
8110c8b0:	dfc00117 	ldw	ra,4(sp)
8110c8b4:	df000017 	ldw	fp,0(sp)
8110c8b8:	dec00204 	addi	sp,sp,8
8110c8bc:	f800283a 	ret

8110c8c0 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c8c0:	defffd04 	addi	sp,sp,-12
8110c8c4:	de00012e 	bgeu	sp,et,8110c8cc <bSSDisplayConfig+0xc>
8110c8c8:	003b68fa 	trap	3
8110c8cc:	df000215 	stw	fp,8(sp)
8110c8d0:	df000204 	addi	fp,sp,8
8110c8d4:	2005883a 	mov	r2,r4
8110c8d8:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c8dc:	e0bfff03 	ldbu	r2,-4(fp)
8110c8e0:	10c00168 	cmpgeui	r3,r2,5
8110c8e4:	18001c1e 	bne	r3,zero,8110c958 <bSSDisplayConfig+0x98>
8110c8e8:	100690ba 	slli	r3,r2,2
8110c8ec:	00a04474 	movhi	r2,33041
8110c8f0:	10b24004 	addi	r2,r2,-14080
8110c8f4:	1885883a 	add	r2,r3,r2
8110c8f8:	10800017 	ldw	r2,0(r2)
8110c8fc:	1000683a 	jmp	r2
8110c900:	8110c914 	ori	r4,r16,17188
8110c904:	8110c920 	cmpeqi	r4,r16,17188
8110c908:	8110c92c 	andhi	r4,r16,17188
8110c90c:	8110c940 	call	88110c94 <__reset+0x20f0c94>
8110c910:	8110c950 	cmplti	r4,r16,17189
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c914:	00800cc4 	movi	r2,51
8110c918:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c91c:	00001006 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c920:	00801544 	movi	r2,85
8110c924:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c928:	00000d06 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c92c:	d0e05043 	ldbu	r3,-32447(gp)
8110c930:	00bff744 	movi	r2,-35
8110c934:	1884703a 	and	r2,r3,r2
8110c938:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c93c:	00000806 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c940:	d0a05043 	ldbu	r2,-32447(gp)
8110c944:	10800894 	ori	r2,r2,34
8110c948:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c94c:	00000406 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c950:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c954:	00000206 	br	8110c960 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c958:	0005883a 	mov	r2,zero
8110c95c:	00000806 	br	8110c980 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c960:	00a00034 	movhi	r2,32768
8110c964:	10828404 	addi	r2,r2,2576
8110c968:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c96c:	d0a05043 	ldbu	r2,-32447(gp)
8110c970:	10c03fcc 	andi	r3,r2,255
8110c974:	e0bffe17 	ldw	r2,-8(fp)
8110c978:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c97c:	00800044 	movi	r2,1
}
8110c980:	e037883a 	mov	sp,fp
8110c984:	df000017 	ldw	fp,0(sp)
8110c988:	dec00104 	addi	sp,sp,4
8110c98c:	f800283a 	ret

8110c990 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c990:	defffd04 	addi	sp,sp,-12
8110c994:	de00012e 	bgeu	sp,et,8110c99c <bSSDisplayUpdate+0xc>
8110c998:	003b68fa 	trap	3
8110c99c:	df000215 	stw	fp,8(sp)
8110c9a0:	df000204 	addi	fp,sp,8
8110c9a4:	2005883a 	mov	r2,r4
8110c9a8:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c9ac:	00a00034 	movhi	r2,32768
8110c9b0:	10828404 	addi	r2,r2,2576
8110c9b4:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c9b8:	e0bffe17 	ldw	r2,-8(fp)
8110c9bc:	10800104 	addi	r2,r2,4
8110c9c0:	e0ffff03 	ldbu	r3,-4(fp)
8110c9c4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c9c8:	00800044 	movi	r2,1
}
8110c9cc:	e037883a 	mov	sp,fp
8110c9d0:	df000017 	ldw	fp,0(sp)
8110c9d4:	dec00104 	addi	sp,sp,4
8110c9d8:	f800283a 	ret

8110c9dc <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110c9dc:	defffb04 	addi	sp,sp,-20
8110c9e0:	de00012e 	bgeu	sp,et,8110c9e8 <vSyncHandleIrq+0xc>
8110c9e4:	003b68fa 	trap	3
8110c9e8:	dfc00415 	stw	ra,16(sp)
8110c9ec:	df000315 	stw	fp,12(sp)
8110c9f0:	df000304 	addi	fp,sp,12
8110c9f4:	e13fff15 	stw	r4,-4(fp)
	tQMask uiCmdtoSend;

	//volatile int* pviHoldContext = (volatile int*) pvContext;


	uiCmdtoSend.ulWord = 0;
8110c9f8:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110c9fc:	d0a05203 	ldbu	r2,-32440(gp)
8110ca00:	108000cc 	andi	r2,r2,3
8110ca04:	e0bffd45 	stb	r2,-11(fp)
	if ( ucSyncL == 0 )
8110ca08:	e0bffd43 	ldbu	r2,-11(fp)
8110ca0c:	1000031e 	bne	r2,zero,8110ca1c <vSyncHandleIrq+0x40>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110ca10:	00bff804 	movi	r2,-32
8110ca14:	e0bffe85 	stb	r2,-6(fp)
8110ca18:	00000206 	br	8110ca24 <vSyncHandleIrq+0x48>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110ca1c:	00bff844 	movi	r2,-31
8110ca20:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110ca24:	00800044 	movi	r2,1
8110ca28:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110ca2c:	d0a06917 	ldw	r2,-32348(gp)
8110ca30:	e0fffe17 	ldw	r3,-8(fp)
8110ca34:	180b883a 	mov	r5,r3
8110ca38:	1009883a 	mov	r4,r2
8110ca3c:	113f4b40 	call	8113f4b4 <OSQPostFront>
8110ca40:	e0bffd85 	stb	r2,-10(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110ca44:	e0bffd83 	ldbu	r2,-10(fp)
8110ca48:	10000126 	beq	r2,zero,8110ca50 <vSyncHandleIrq+0x74>
		vFailSendMsgMasterSyncMeb( );
8110ca4c:	111e9580 	call	8111e958 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ca50:	e03ffd05 	stb	zero,-12(fp)
8110ca54:	00001606 	br	8110cab0 <vSyncHandleIrq+0xd4>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ca58:	e0bffd03 	ldbu	r2,-12(fp)
8110ca5c:	10800444 	addi	r2,r2,17
8110ca60:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ca64:	e0bffd03 	ldbu	r2,-12(fp)
8110ca68:	1085883a 	add	r2,r2,r2
8110ca6c:	1087883a 	add	r3,r2,r2
8110ca70:	d0a06a04 	addi	r2,gp,-32344
8110ca74:	1885883a 	add	r2,r3,r2
8110ca78:	10800017 	ldw	r2,0(r2)
8110ca7c:	e0fffe17 	ldw	r3,-8(fp)
8110ca80:	180b883a 	mov	r5,r3
8110ca84:	1009883a 	mov	r4,r2
8110ca88:	113f4b40 	call	8113f4b4 <OSQPostFront>
8110ca8c:	e0bffd85 	stb	r2,-10(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110ca90:	e0bffd83 	ldbu	r2,-10(fp)
8110ca94:	10000326 	beq	r2,zero,8110caa4 <vSyncHandleIrq+0xc8>
			vFailSendMsgSync( ucIL );
8110ca98:	e0bffd03 	ldbu	r2,-12(fp)
8110ca9c:	1009883a 	mov	r4,r2
8110caa0:	111e8800 	call	8111e880 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110caa4:	e0bffd03 	ldbu	r2,-12(fp)
8110caa8:	10800044 	addi	r2,r2,1
8110caac:	e0bffd05 	stb	r2,-12(fp)
8110cab0:	e0bffd03 	ldbu	r2,-12(fp)
8110cab4:	103fe826 	beq	r2,zero,8110ca58 <__reset+0xfb0eca58>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110cab8:	d0a05203 	ldbu	r2,-32440(gp)
8110cabc:	10800044 	addi	r2,r2,1
8110cac0:	d0a05205 	stb	r2,-32440(gp)

	vSyncIrqFlagClrSync();
8110cac4:	110cb580 	call	8110cb58 <vSyncIrqFlagClrSync>
}
8110cac8:	0001883a 	nop
8110cacc:	e037883a 	mov	sp,fp
8110cad0:	dfc00117 	ldw	ra,4(sp)
8110cad4:	df000017 	ldw	fp,0(sp)
8110cad8:	dec00204 	addi	sp,sp,8
8110cadc:	f800283a 	ret

8110cae0 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110cae0:	deffff04 	addi	sp,sp,-4
8110cae4:	de00012e 	bgeu	sp,et,8110caec <vSyncClearCounter+0xc>
8110cae8:	003b68fa 	trap	3
8110caec:	df000015 	stw	fp,0(sp)
8110caf0:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110caf4:	d0205205 	stb	zero,-32440(gp)
}
8110caf8:	0001883a 	nop
8110cafc:	e037883a 	mov	sp,fp
8110cb00:	df000017 	ldw	fp,0(sp)
8110cb04:	dec00104 	addi	sp,sp,4
8110cb08:	f800283a 	ret

8110cb0c <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110cb0c:	defffd04 	addi	sp,sp,-12
8110cb10:	de00012e 	bgeu	sp,et,8110cb18 <vSyncInitIrq+0xc>
8110cb14:	003b68fa 	trap	3
8110cb18:	dfc00215 	stw	ra,8(sp)
8110cb1c:	df000115 	stw	fp,4(sp)
8110cb20:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110cb24:	d0a05104 	addi	r2,gp,-32444
8110cb28:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110cb2c:	01a04474 	movhi	r6,33041
8110cb30:	31b27704 	addi	r6,r6,-13860
8110cb34:	e17fff17 	ldw	r5,-4(fp)
8110cb38:	01000284 	movi	r4,10
8110cb3c:	11379600 	call	81137960 <alt_irq_register>
}
8110cb40:	0001883a 	nop
8110cb44:	e037883a 	mov	sp,fp
8110cb48:	dfc00117 	ldw	ra,4(sp)
8110cb4c:	df000017 	ldw	fp,0(sp)
8110cb50:	dec00204 	addi	sp,sp,8
8110cb54:	f800283a 	ret

8110cb58 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110cb58:	defffe04 	addi	sp,sp,-8
8110cb5c:	de00012e 	bgeu	sp,et,8110cb64 <vSyncIrqFlagClrSync+0xc>
8110cb60:	003b68fa 	trap	3
8110cb64:	dfc00115 	stw	ra,4(sp)
8110cb68:	df000015 	stw	fp,0(sp)
8110cb6c:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110cb70:	01400044 	movi	r5,1
8110cb74:	010002c4 	movi	r4,11
8110cb78:	110d9380 	call	8110d938 <bSyncWriteReg>
}
8110cb7c:	0001883a 	nop
8110cb80:	e037883a 	mov	sp,fp
8110cb84:	dfc00117 	ldw	ra,4(sp)
8110cb88:	df000017 	ldw	fp,0(sp)
8110cb8c:	dec00204 	addi	sp,sp,8
8110cb90:	f800283a 	ret

8110cb94 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110cb94:	defffd04 	addi	sp,sp,-12
8110cb98:	de00012e 	bgeu	sp,et,8110cba0 <bSyncIrqFlagSync+0xc>
8110cb9c:	003b68fa 	trap	3
8110cba0:	dfc00215 	stw	ra,8(sp)
8110cba4:	df000115 	stw	fp,4(sp)
8110cba8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110cbac:	01000304 	movi	r4,12
8110cbb0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cbb4:	1080004c 	andi	r2,r2,1
8110cbb8:	10000326 	beq	r2,zero,8110cbc8 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110cbbc:	00800044 	movi	r2,1
8110cbc0:	e0bfff15 	stw	r2,-4(fp)
8110cbc4:	00000106 	br	8110cbcc <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110cbc8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110cbcc:	e0bfff17 	ldw	r2,-4(fp)
}
8110cbd0:	e037883a 	mov	sp,fp
8110cbd4:	dfc00117 	ldw	ra,4(sp)
8110cbd8:	df000017 	ldw	fp,0(sp)
8110cbdc:	dec00204 	addi	sp,sp,8
8110cbe0:	f800283a 	ret

8110cbe4 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110cbe4:	defffc04 	addi	sp,sp,-16
8110cbe8:	de00012e 	bgeu	sp,et,8110cbf0 <bSyncStatusExtnIrq+0xc>
8110cbec:	003b68fa 	trap	3
8110cbf0:	dfc00315 	stw	ra,12(sp)
8110cbf4:	df000215 	stw	fp,8(sp)
8110cbf8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cbfc:	0009883a 	mov	r4,zero
8110cc00:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cc04:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110cc08:	e0bfff17 	ldw	r2,-4(fp)
8110cc0c:	1000030e 	bge	r2,zero,8110cc1c <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110cc10:	00800044 	movi	r2,1
8110cc14:	e0bffe15 	stw	r2,-8(fp)
8110cc18:	00000106 	br	8110cc20 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110cc1c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110cc20:	e0bffe17 	ldw	r2,-8(fp)
}
8110cc24:	e037883a 	mov	sp,fp
8110cc28:	dfc00117 	ldw	ra,4(sp)
8110cc2c:	df000017 	ldw	fp,0(sp)
8110cc30:	dec00204 	addi	sp,sp,8
8110cc34:	f800283a 	ret

8110cc38 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110cc38:	defffc04 	addi	sp,sp,-16
8110cc3c:	de00012e 	bgeu	sp,et,8110cc44 <ucSyncStatusState+0xc>
8110cc40:	003b68fa 	trap	3
8110cc44:	dfc00315 	stw	ra,12(sp)
8110cc48:	df000215 	stw	fp,8(sp)
8110cc4c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc50:	0009883a 	mov	r4,zero
8110cc54:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cc58:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110cc5c:	e0bffe17 	ldw	r2,-8(fp)
8110cc60:	10803fec 	andhi	r2,r2,255
8110cc64:	1004d43a 	srli	r2,r2,16
8110cc68:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cc6c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cc70:	e037883a 	mov	sp,fp
8110cc74:	dfc00117 	ldw	ra,4(sp)
8110cc78:	df000017 	ldw	fp,0(sp)
8110cc7c:	dec00204 	addi	sp,sp,8
8110cc80:	f800283a 	ret

8110cc84 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110cc84:	defffc04 	addi	sp,sp,-16
8110cc88:	de00012e 	bgeu	sp,et,8110cc90 <ucSyncStatusErrorCode+0xc>
8110cc8c:	003b68fa 	trap	3
8110cc90:	dfc00315 	stw	ra,12(sp)
8110cc94:	df000215 	stw	fp,8(sp)
8110cc98:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc9c:	0009883a 	mov	r4,zero
8110cca0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cca4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110cca8:	e0bffe17 	ldw	r2,-8(fp)
8110ccac:	10bfc00c 	andi	r2,r2,65280
8110ccb0:	1004d23a 	srli	r2,r2,8
8110ccb4:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ccb8:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ccbc:	e037883a 	mov	sp,fp
8110ccc0:	dfc00117 	ldw	ra,4(sp)
8110ccc4:	df000017 	ldw	fp,0(sp)
8110ccc8:	dec00204 	addi	sp,sp,8
8110cccc:	f800283a 	ret

8110ccd0 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110ccd0:	defffc04 	addi	sp,sp,-16
8110ccd4:	de00012e 	bgeu	sp,et,8110ccdc <ucSyncStatusCycleNumber+0xc>
8110ccd8:	003b68fa 	trap	3
8110ccdc:	dfc00315 	stw	ra,12(sp)
8110cce0:	df000215 	stw	fp,8(sp)
8110cce4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cce8:	0009883a 	mov	r4,zero
8110ccec:	110d9940 	call	8110d994 <uliSyncReadReg>
8110ccf0:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110ccf4:	e0bffe17 	ldw	r2,-8(fp)
8110ccf8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ccfc:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd00:	e037883a 	mov	sp,fp
8110cd04:	dfc00117 	ldw	ra,4(sp)
8110cd08:	df000017 	ldw	fp,0(sp)
8110cd0c:	dec00204 	addi	sp,sp,8
8110cd10:	f800283a 	ret

8110cd14 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110cd14:	defffd04 	addi	sp,sp,-12
8110cd18:	de00012e 	bgeu	sp,et,8110cd20 <bSyncSetMbt+0xc>
8110cd1c:	003b68fa 	trap	3
8110cd20:	dfc00215 	stw	ra,8(sp)
8110cd24:	df000115 	stw	fp,4(sp)
8110cd28:	df000104 	addi	fp,sp,4
8110cd2c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110cd30:	e17fff17 	ldw	r5,-4(fp)
8110cd34:	01000104 	movi	r4,4
8110cd38:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cd3c:	00800044 	movi	r2,1
}
8110cd40:	e037883a 	mov	sp,fp
8110cd44:	dfc00117 	ldw	ra,4(sp)
8110cd48:	df000017 	ldw	fp,0(sp)
8110cd4c:	dec00204 	addi	sp,sp,8
8110cd50:	f800283a 	ret

8110cd54 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110cd54:	defffd04 	addi	sp,sp,-12
8110cd58:	de00012e 	bgeu	sp,et,8110cd60 <bSyncSetBt+0xc>
8110cd5c:	003b68fa 	trap	3
8110cd60:	dfc00215 	stw	ra,8(sp)
8110cd64:	df000115 	stw	fp,4(sp)
8110cd68:	df000104 	addi	fp,sp,4
8110cd6c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110cd70:	e17fff17 	ldw	r5,-4(fp)
8110cd74:	01000144 	movi	r4,5
8110cd78:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cd7c:	00800044 	movi	r2,1
}
8110cd80:	e037883a 	mov	sp,fp
8110cd84:	dfc00117 	ldw	ra,4(sp)
8110cd88:	df000017 	ldw	fp,0(sp)
8110cd8c:	dec00204 	addi	sp,sp,8
8110cd90:	f800283a 	ret

8110cd94 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110cd94:	defffd04 	addi	sp,sp,-12
8110cd98:	de00012e 	bgeu	sp,et,8110cda0 <bSyncSetPer+0xc>
8110cd9c:	003b68fa 	trap	3
8110cda0:	dfc00215 	stw	ra,8(sp)
8110cda4:	df000115 	stw	fp,4(sp)
8110cda8:	df000104 	addi	fp,sp,4
8110cdac:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110cdb0:	e17fff17 	ldw	r5,-4(fp)
8110cdb4:	01000184 	movi	r4,6
8110cdb8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cdbc:	00800044 	movi	r2,1
}
8110cdc0:	e037883a 	mov	sp,fp
8110cdc4:	dfc00117 	ldw	ra,4(sp)
8110cdc8:	df000017 	ldw	fp,0(sp)
8110cdcc:	dec00204 	addi	sp,sp,8
8110cdd0:	f800283a 	ret

8110cdd4 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110cdd4:	defffd04 	addi	sp,sp,-12
8110cdd8:	de00012e 	bgeu	sp,et,8110cde0 <bSyncSetOst+0xc>
8110cddc:	003b68fa 	trap	3
8110cde0:	dfc00215 	stw	ra,8(sp)
8110cde4:	df000115 	stw	fp,4(sp)
8110cde8:	df000104 	addi	fp,sp,4
8110cdec:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110cdf0:	e17fff17 	ldw	r5,-4(fp)
8110cdf4:	010001c4 	movi	r4,7
8110cdf8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cdfc:	00800044 	movi	r2,1
}
8110ce00:	e037883a 	mov	sp,fp
8110ce04:	dfc00117 	ldw	ra,4(sp)
8110ce08:	df000017 	ldw	fp,0(sp)
8110ce0c:	dec00204 	addi	sp,sp,8
8110ce10:	f800283a 	ret

8110ce14 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110ce14:	defffc04 	addi	sp,sp,-16
8110ce18:	de00012e 	bgeu	sp,et,8110ce20 <bSyncSetPolarity+0xc>
8110ce1c:	003b68fa 	trap	3
8110ce20:	dfc00315 	stw	ra,12(sp)
8110ce24:	df000215 	stw	fp,8(sp)
8110ce28:	df000204 	addi	fp,sp,8
8110ce2c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ce30:	01000204 	movi	r4,8
8110ce34:	110d9940 	call	8110d994 <uliSyncReadReg>
8110ce38:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce3c:	e0bfff17 	ldw	r2,-4(fp)
8110ce40:	1000051e 	bne	r2,zero,8110ce58 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce44:	e0fffe17 	ldw	r3,-8(fp)
8110ce48:	00bfbfc4 	movi	r2,-257
8110ce4c:	1884703a 	and	r2,r3,r2
8110ce50:	e0bffe15 	stw	r2,-8(fp)
8110ce54:	00000306 	br	8110ce64 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce58:	e0bffe17 	ldw	r2,-8(fp)
8110ce5c:	10804014 	ori	r2,r2,256
8110ce60:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ce64:	e17ffe17 	ldw	r5,-8(fp)
8110ce68:	01000204 	movi	r4,8
8110ce6c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110ce70:	00800044 	movi	r2,1
}
8110ce74:	e037883a 	mov	sp,fp
8110ce78:	dfc00117 	ldw	ra,4(sp)
8110ce7c:	df000017 	ldw	fp,0(sp)
8110ce80:	dec00204 	addi	sp,sp,8
8110ce84:	f800283a 	ret

8110ce88 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110ce88:	defffc04 	addi	sp,sp,-16
8110ce8c:	de00012e 	bgeu	sp,et,8110ce94 <bSyncSetNCycles+0xc>
8110ce90:	003b68fa 	trap	3
8110ce94:	dfc00315 	stw	ra,12(sp)
8110ce98:	df000215 	stw	fp,8(sp)
8110ce9c:	df000204 	addi	fp,sp,8
8110cea0:	2005883a 	mov	r2,r4
8110cea4:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cea8:	01000204 	movi	r4,8
8110ceac:	110d9940 	call	8110d994 <uliSyncReadReg>
8110ceb0:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110ceb4:	e0fffe17 	ldw	r3,-8(fp)
8110ceb8:	00bfc004 	movi	r2,-256
8110cebc:	1884703a 	and	r2,r3,r2
8110cec0:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110cec4:	e0bfff03 	ldbu	r2,-4(fp)
8110cec8:	e0fffe17 	ldw	r3,-8(fp)
8110cecc:	1884b03a 	or	r2,r3,r2
8110ced0:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ced4:	e17ffe17 	ldw	r5,-8(fp)
8110ced8:	01000204 	movi	r4,8
8110cedc:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cee0:	00800044 	movi	r2,1
}
8110cee4:	e037883a 	mov	sp,fp
8110cee8:	dfc00117 	ldw	ra,4(sp)
8110ceec:	df000017 	ldw	fp,0(sp)
8110cef0:	dec00204 	addi	sp,sp,8
8110cef4:	f800283a 	ret

8110cef8 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110cef8:	defffd04 	addi	sp,sp,-12
8110cefc:	de00012e 	bgeu	sp,et,8110cf04 <uliSyncGetMbt+0xc>
8110cf00:	003b68fa 	trap	3
8110cf04:	dfc00215 	stw	ra,8(sp)
8110cf08:	df000115 	stw	fp,4(sp)
8110cf0c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110cf10:	01000104 	movi	r4,4
8110cf14:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cf18:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf1c:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf20:	e037883a 	mov	sp,fp
8110cf24:	dfc00117 	ldw	ra,4(sp)
8110cf28:	df000017 	ldw	fp,0(sp)
8110cf2c:	dec00204 	addi	sp,sp,8
8110cf30:	f800283a 	ret

8110cf34 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110cf34:	defffd04 	addi	sp,sp,-12
8110cf38:	de00012e 	bgeu	sp,et,8110cf40 <uliSyncGetBt+0xc>
8110cf3c:	003b68fa 	trap	3
8110cf40:	dfc00215 	stw	ra,8(sp)
8110cf44:	df000115 	stw	fp,4(sp)
8110cf48:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110cf4c:	01000144 	movi	r4,5
8110cf50:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cf54:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf58:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf5c:	e037883a 	mov	sp,fp
8110cf60:	dfc00117 	ldw	ra,4(sp)
8110cf64:	df000017 	ldw	fp,0(sp)
8110cf68:	dec00204 	addi	sp,sp,8
8110cf6c:	f800283a 	ret

8110cf70 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110cf70:	defffd04 	addi	sp,sp,-12
8110cf74:	de00012e 	bgeu	sp,et,8110cf7c <uliSyncGetPer+0xc>
8110cf78:	003b68fa 	trap	3
8110cf7c:	dfc00215 	stw	ra,8(sp)
8110cf80:	df000115 	stw	fp,4(sp)
8110cf84:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110cf88:	01000184 	movi	r4,6
8110cf8c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cf90:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf94:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf98:	e037883a 	mov	sp,fp
8110cf9c:	dfc00117 	ldw	ra,4(sp)
8110cfa0:	df000017 	ldw	fp,0(sp)
8110cfa4:	dec00204 	addi	sp,sp,8
8110cfa8:	f800283a 	ret

8110cfac <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110cfac:	defffd04 	addi	sp,sp,-12
8110cfb0:	de00012e 	bgeu	sp,et,8110cfb8 <uliSyncGetOst+0xc>
8110cfb4:	003b68fa 	trap	3
8110cfb8:	dfc00215 	stw	ra,8(sp)
8110cfbc:	df000115 	stw	fp,4(sp)
8110cfc0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110cfc4:	010001c4 	movi	r4,7
8110cfc8:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cfcc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfd0:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfd4:	e037883a 	mov	sp,fp
8110cfd8:	dfc00117 	ldw	ra,4(sp)
8110cfdc:	df000017 	ldw	fp,0(sp)
8110cfe0:	dec00204 	addi	sp,sp,8
8110cfe4:	f800283a 	ret

8110cfe8 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110cfe8:	defffd04 	addi	sp,sp,-12
8110cfec:	de00012e 	bgeu	sp,et,8110cff4 <uliSyncGetGeneral+0xc>
8110cff0:	003b68fa 	trap	3
8110cff4:	dfc00215 	stw	ra,8(sp)
8110cff8:	df000115 	stw	fp,4(sp)
8110cffc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d000:	01000204 	movi	r4,8
8110d004:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d008:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d00c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d010:	e037883a 	mov	sp,fp
8110d014:	dfc00117 	ldw	ra,4(sp)
8110d018:	df000017 	ldw	fp,0(sp)
8110d01c:	dec00204 	addi	sp,sp,8
8110d020:	f800283a 	ret

8110d024 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110d024:	defffd04 	addi	sp,sp,-12
8110d028:	de00012e 	bgeu	sp,et,8110d030 <bSyncErrInj+0xc>
8110d02c:	003b68fa 	trap	3
8110d030:	dfc00215 	stw	ra,8(sp)
8110d034:	df000115 	stw	fp,4(sp)
8110d038:	df000104 	addi	fp,sp,4
8110d03c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110d040:	e17fff17 	ldw	r5,-4(fp)
8110d044:	01000244 	movi	r4,9
8110d048:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d04c:	00800044 	movi	r2,1
}
8110d050:	e037883a 	mov	sp,fp
8110d054:	dfc00117 	ldw	ra,4(sp)
8110d058:	df000017 	ldw	fp,0(sp)
8110d05c:	dec00204 	addi	sp,sp,8
8110d060:	f800283a 	ret

8110d064 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110d064:	defffc04 	addi	sp,sp,-16
8110d068:	de00012e 	bgeu	sp,et,8110d070 <bSyncCtrExtnIrq+0xc>
8110d06c:	003b68fa 	trap	3
8110d070:	dfc00315 	stw	ra,12(sp)
8110d074:	df000215 	stw	fp,8(sp)
8110d078:	df000204 	addi	fp,sp,8
8110d07c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d080:	01000284 	movi	r4,10
8110d084:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d088:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d08c:	e0bfff17 	ldw	r2,-4(fp)
8110d090:	1000061e 	bne	r2,zero,8110d0ac <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110d094:	e0fffe17 	ldw	r3,-8(fp)
8110d098:	00a00034 	movhi	r2,32768
8110d09c:	10bfffc4 	addi	r2,r2,-1
8110d0a0:	1884703a 	and	r2,r3,r2
8110d0a4:	e0bffe15 	stw	r2,-8(fp)
8110d0a8:	00000306 	br	8110d0b8 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110d0ac:	e0bffe17 	ldw	r2,-8(fp)
8110d0b0:	10a00034 	orhi	r2,r2,32768
8110d0b4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d0b8:	e17ffe17 	ldw	r5,-8(fp)
8110d0bc:	01000284 	movi	r4,10
8110d0c0:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d0c4:	00800044 	movi	r2,1
}
8110d0c8:	e037883a 	mov	sp,fp
8110d0cc:	dfc00117 	ldw	ra,4(sp)
8110d0d0:	df000017 	ldw	fp,0(sp)
8110d0d4:	dec00204 	addi	sp,sp,8
8110d0d8:	f800283a 	ret

8110d0dc <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110d0dc:	defffd04 	addi	sp,sp,-12
8110d0e0:	de00012e 	bgeu	sp,et,8110d0e8 <bSyncCtrStart+0xc>
8110d0e4:	003b68fa 	trap	3
8110d0e8:	dfc00215 	stw	ra,8(sp)
8110d0ec:	df000115 	stw	fp,4(sp)
8110d0f0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d0f4:	01000284 	movi	r4,10
8110d0f8:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d0fc:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110d100:	e0bfff17 	ldw	r2,-4(fp)
8110d104:	10800234 	orhi	r2,r2,8
8110d108:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d10c:	e17fff17 	ldw	r5,-4(fp)
8110d110:	01000284 	movi	r4,10
8110d114:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d118:	00800044 	movi	r2,1
}
8110d11c:	e037883a 	mov	sp,fp
8110d120:	dfc00117 	ldw	ra,4(sp)
8110d124:	df000017 	ldw	fp,0(sp)
8110d128:	dec00204 	addi	sp,sp,8
8110d12c:	f800283a 	ret

8110d130 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d130:	defffd04 	addi	sp,sp,-12
8110d134:	de00012e 	bgeu	sp,et,8110d13c <bSyncCtrReset+0xc>
8110d138:	003b68fa 	trap	3
8110d13c:	dfc00215 	stw	ra,8(sp)
8110d140:	df000115 	stw	fp,4(sp)
8110d144:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d148:	01000284 	movi	r4,10
8110d14c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d150:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d154:	e0bfff17 	ldw	r2,-4(fp)
8110d158:	10800134 	orhi	r2,r2,4
8110d15c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d160:	e17fff17 	ldw	r5,-4(fp)
8110d164:	01000284 	movi	r4,10
8110d168:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d16c:	00800044 	movi	r2,1
}
8110d170:	e037883a 	mov	sp,fp
8110d174:	dfc00117 	ldw	ra,4(sp)
8110d178:	df000017 	ldw	fp,0(sp)
8110d17c:	dec00204 	addi	sp,sp,8
8110d180:	f800283a 	ret

8110d184 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d184:	defffd04 	addi	sp,sp,-12
8110d188:	de00012e 	bgeu	sp,et,8110d190 <bSyncCtrOneShot+0xc>
8110d18c:	003b68fa 	trap	3
8110d190:	dfc00215 	stw	ra,8(sp)
8110d194:	df000115 	stw	fp,4(sp)
8110d198:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d19c:	01000284 	movi	r4,10
8110d1a0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d1a4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d1a8:	e0bfff17 	ldw	r2,-4(fp)
8110d1ac:	108000b4 	orhi	r2,r2,2
8110d1b0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d1b4:	e17fff17 	ldw	r5,-4(fp)
8110d1b8:	01000284 	movi	r4,10
8110d1bc:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d1c0:	00800044 	movi	r2,1
}
8110d1c4:	e037883a 	mov	sp,fp
8110d1c8:	dfc00117 	ldw	ra,4(sp)
8110d1cc:	df000017 	ldw	fp,0(sp)
8110d1d0:	dec00204 	addi	sp,sp,8
8110d1d4:	f800283a 	ret

8110d1d8 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d1d8:	defffd04 	addi	sp,sp,-12
8110d1dc:	de00012e 	bgeu	sp,et,8110d1e4 <bSyncCtrErrInj+0xc>
8110d1e0:	003b68fa 	trap	3
8110d1e4:	dfc00215 	stw	ra,8(sp)
8110d1e8:	df000115 	stw	fp,4(sp)
8110d1ec:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d1f0:	01000284 	movi	r4,10
8110d1f4:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d1f8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d1fc:	e0bfff17 	ldw	r2,-4(fp)
8110d200:	10800074 	orhi	r2,r2,1
8110d204:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d208:	e17fff17 	ldw	r5,-4(fp)
8110d20c:	01000284 	movi	r4,10
8110d210:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d214:	00800044 	movi	r2,1
}
8110d218:	e037883a 	mov	sp,fp
8110d21c:	dfc00117 	ldw	ra,4(sp)
8110d220:	df000017 	ldw	fp,0(sp)
8110d224:	dec00204 	addi	sp,sp,8
8110d228:	f800283a 	ret

8110d22c <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d22c:	defffc04 	addi	sp,sp,-16
8110d230:	de00012e 	bgeu	sp,et,8110d238 <bSyncCtrSyncOutEnable+0xc>
8110d234:	003b68fa 	trap	3
8110d238:	dfc00315 	stw	ra,12(sp)
8110d23c:	df000215 	stw	fp,8(sp)
8110d240:	df000204 	addi	fp,sp,8
8110d244:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d248:	01000284 	movi	r4,10
8110d24c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d250:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d254:	e0bfff17 	ldw	r2,-4(fp)
8110d258:	1000051e 	bne	r2,zero,8110d270 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d25c:	e0fffe17 	ldw	r3,-8(fp)
8110d260:	00bfbfc4 	movi	r2,-257
8110d264:	1884703a 	and	r2,r3,r2
8110d268:	e0bffe15 	stw	r2,-8(fp)
8110d26c:	00000306 	br	8110d27c <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d270:	e0bffe17 	ldw	r2,-8(fp)
8110d274:	10804014 	ori	r2,r2,256
8110d278:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d27c:	e17ffe17 	ldw	r5,-8(fp)
8110d280:	01000284 	movi	r4,10
8110d284:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d288:	00800044 	movi	r2,1
}
8110d28c:	e037883a 	mov	sp,fp
8110d290:	dfc00117 	ldw	ra,4(sp)
8110d294:	df000017 	ldw	fp,0(sp)
8110d298:	dec00204 	addi	sp,sp,8
8110d29c:	f800283a 	ret

8110d2a0 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d2a0:	defffc04 	addi	sp,sp,-16
8110d2a4:	de00012e 	bgeu	sp,et,8110d2ac <bSyncCtrCh1OutEnable+0xc>
8110d2a8:	003b68fa 	trap	3
8110d2ac:	dfc00315 	stw	ra,12(sp)
8110d2b0:	df000215 	stw	fp,8(sp)
8110d2b4:	df000204 	addi	fp,sp,8
8110d2b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d2bc:	01000284 	movi	r4,10
8110d2c0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d2c4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2c8:	e0bfff17 	ldw	r2,-4(fp)
8110d2cc:	1000051e 	bne	r2,zero,8110d2e4 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d2d0:	e0fffe17 	ldw	r3,-8(fp)
8110d2d4:	00bfff84 	movi	r2,-2
8110d2d8:	1884703a 	and	r2,r3,r2
8110d2dc:	e0bffe15 	stw	r2,-8(fp)
8110d2e0:	00000306 	br	8110d2f0 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d2e4:	e0bffe17 	ldw	r2,-8(fp)
8110d2e8:	10800054 	ori	r2,r2,1
8110d2ec:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d2f0:	e17ffe17 	ldw	r5,-8(fp)
8110d2f4:	01000284 	movi	r4,10
8110d2f8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d2fc:	00800044 	movi	r2,1
}
8110d300:	e037883a 	mov	sp,fp
8110d304:	dfc00117 	ldw	ra,4(sp)
8110d308:	df000017 	ldw	fp,0(sp)
8110d30c:	dec00204 	addi	sp,sp,8
8110d310:	f800283a 	ret

8110d314 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110d314:	defffc04 	addi	sp,sp,-16
8110d318:	de00012e 	bgeu	sp,et,8110d320 <bSyncCtrCh2OutEnable+0xc>
8110d31c:	003b68fa 	trap	3
8110d320:	dfc00315 	stw	ra,12(sp)
8110d324:	df000215 	stw	fp,8(sp)
8110d328:	df000204 	addi	fp,sp,8
8110d32c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d330:	01000284 	movi	r4,10
8110d334:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d338:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d33c:	e0bfff17 	ldw	r2,-4(fp)
8110d340:	1000051e 	bne	r2,zero,8110d358 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110d344:	e0fffe17 	ldw	r3,-8(fp)
8110d348:	00bfff44 	movi	r2,-3
8110d34c:	1884703a 	and	r2,r3,r2
8110d350:	e0bffe15 	stw	r2,-8(fp)
8110d354:	00000306 	br	8110d364 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110d358:	e0bffe17 	ldw	r2,-8(fp)
8110d35c:	10800094 	ori	r2,r2,2
8110d360:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d364:	e17ffe17 	ldw	r5,-8(fp)
8110d368:	01000284 	movi	r4,10
8110d36c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d370:	00800044 	movi	r2,1
}
8110d374:	e037883a 	mov	sp,fp
8110d378:	dfc00117 	ldw	ra,4(sp)
8110d37c:	df000017 	ldw	fp,0(sp)
8110d380:	dec00204 	addi	sp,sp,8
8110d384:	f800283a 	ret

8110d388 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110d388:	defffc04 	addi	sp,sp,-16
8110d38c:	de00012e 	bgeu	sp,et,8110d394 <bSyncCtrCh3OutEnable+0xc>
8110d390:	003b68fa 	trap	3
8110d394:	dfc00315 	stw	ra,12(sp)
8110d398:	df000215 	stw	fp,8(sp)
8110d39c:	df000204 	addi	fp,sp,8
8110d3a0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3a4:	01000284 	movi	r4,10
8110d3a8:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d3ac:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d3b0:	e0bfff17 	ldw	r2,-4(fp)
8110d3b4:	1000051e 	bne	r2,zero,8110d3cc <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110d3b8:	e0fffe17 	ldw	r3,-8(fp)
8110d3bc:	00bffec4 	movi	r2,-5
8110d3c0:	1884703a 	and	r2,r3,r2
8110d3c4:	e0bffe15 	stw	r2,-8(fp)
8110d3c8:	00000306 	br	8110d3d8 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110d3cc:	e0bffe17 	ldw	r2,-8(fp)
8110d3d0:	10800114 	ori	r2,r2,4
8110d3d4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d3d8:	e17ffe17 	ldw	r5,-8(fp)
8110d3dc:	01000284 	movi	r4,10
8110d3e0:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d3e4:	00800044 	movi	r2,1
}
8110d3e8:	e037883a 	mov	sp,fp
8110d3ec:	dfc00117 	ldw	ra,4(sp)
8110d3f0:	df000017 	ldw	fp,0(sp)
8110d3f4:	dec00204 	addi	sp,sp,8
8110d3f8:	f800283a 	ret

8110d3fc <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110d3fc:	defffc04 	addi	sp,sp,-16
8110d400:	de00012e 	bgeu	sp,et,8110d408 <bSyncCtrCh4OutEnable+0xc>
8110d404:	003b68fa 	trap	3
8110d408:	dfc00315 	stw	ra,12(sp)
8110d40c:	df000215 	stw	fp,8(sp)
8110d410:	df000204 	addi	fp,sp,8
8110d414:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d418:	01000284 	movi	r4,10
8110d41c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d420:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d424:	e0bfff17 	ldw	r2,-4(fp)
8110d428:	1000051e 	bne	r2,zero,8110d440 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110d42c:	e0fffe17 	ldw	r3,-8(fp)
8110d430:	00bffdc4 	movi	r2,-9
8110d434:	1884703a 	and	r2,r3,r2
8110d438:	e0bffe15 	stw	r2,-8(fp)
8110d43c:	00000306 	br	8110d44c <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110d440:	e0bffe17 	ldw	r2,-8(fp)
8110d444:	10800214 	ori	r2,r2,8
8110d448:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d44c:	e17ffe17 	ldw	r5,-8(fp)
8110d450:	01000284 	movi	r4,10
8110d454:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d458:	00800044 	movi	r2,1
}
8110d45c:	e037883a 	mov	sp,fp
8110d460:	dfc00117 	ldw	ra,4(sp)
8110d464:	df000017 	ldw	fp,0(sp)
8110d468:	dec00204 	addi	sp,sp,8
8110d46c:	f800283a 	ret

8110d470 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110d470:	defffc04 	addi	sp,sp,-16
8110d474:	de00012e 	bgeu	sp,et,8110d47c <bSyncCtrCh5OutEnable+0xc>
8110d478:	003b68fa 	trap	3
8110d47c:	dfc00315 	stw	ra,12(sp)
8110d480:	df000215 	stw	fp,8(sp)
8110d484:	df000204 	addi	fp,sp,8
8110d488:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d48c:	01000284 	movi	r4,10
8110d490:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d494:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d498:	e0bfff17 	ldw	r2,-4(fp)
8110d49c:	1000051e 	bne	r2,zero,8110d4b4 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110d4a0:	e0fffe17 	ldw	r3,-8(fp)
8110d4a4:	00bffbc4 	movi	r2,-17
8110d4a8:	1884703a 	and	r2,r3,r2
8110d4ac:	e0bffe15 	stw	r2,-8(fp)
8110d4b0:	00000306 	br	8110d4c0 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110d4b4:	e0bffe17 	ldw	r2,-8(fp)
8110d4b8:	10800414 	ori	r2,r2,16
8110d4bc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d4c0:	e17ffe17 	ldw	r5,-8(fp)
8110d4c4:	01000284 	movi	r4,10
8110d4c8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d4cc:	00800044 	movi	r2,1
}
8110d4d0:	e037883a 	mov	sp,fp
8110d4d4:	dfc00117 	ldw	ra,4(sp)
8110d4d8:	df000017 	ldw	fp,0(sp)
8110d4dc:	dec00204 	addi	sp,sp,8
8110d4e0:	f800283a 	ret

8110d4e4 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110d4e4:	defffc04 	addi	sp,sp,-16
8110d4e8:	de00012e 	bgeu	sp,et,8110d4f0 <bSyncCtrCh6OutEnable+0xc>
8110d4ec:	003b68fa 	trap	3
8110d4f0:	dfc00315 	stw	ra,12(sp)
8110d4f4:	df000215 	stw	fp,8(sp)
8110d4f8:	df000204 	addi	fp,sp,8
8110d4fc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d500:	01000284 	movi	r4,10
8110d504:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d508:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d50c:	e0bfff17 	ldw	r2,-4(fp)
8110d510:	1000051e 	bne	r2,zero,8110d528 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d514:	e0fffe17 	ldw	r3,-8(fp)
8110d518:	00bff7c4 	movi	r2,-33
8110d51c:	1884703a 	and	r2,r3,r2
8110d520:	e0bffe15 	stw	r2,-8(fp)
8110d524:	00000306 	br	8110d534 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d528:	e0bffe17 	ldw	r2,-8(fp)
8110d52c:	10800814 	ori	r2,r2,32
8110d530:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d534:	e17ffe17 	ldw	r5,-8(fp)
8110d538:	01000284 	movi	r4,10
8110d53c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d540:	00800044 	movi	r2,1
}
8110d544:	e037883a 	mov	sp,fp
8110d548:	dfc00117 	ldw	ra,4(sp)
8110d54c:	df000017 	ldw	fp,0(sp)
8110d550:	dec00204 	addi	sp,sp,8
8110d554:	f800283a 	ret

8110d558 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d558:	defffc04 	addi	sp,sp,-16
8110d55c:	de00012e 	bgeu	sp,et,8110d564 <bSyncCtrCh7OutEnable+0xc>
8110d560:	003b68fa 	trap	3
8110d564:	dfc00315 	stw	ra,12(sp)
8110d568:	df000215 	stw	fp,8(sp)
8110d56c:	df000204 	addi	fp,sp,8
8110d570:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d574:	01000284 	movi	r4,10
8110d578:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d57c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d580:	e0bfff17 	ldw	r2,-4(fp)
8110d584:	1000051e 	bne	r2,zero,8110d59c <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d588:	e0fffe17 	ldw	r3,-8(fp)
8110d58c:	00bfefc4 	movi	r2,-65
8110d590:	1884703a 	and	r2,r3,r2
8110d594:	e0bffe15 	stw	r2,-8(fp)
8110d598:	00000306 	br	8110d5a8 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d59c:	e0bffe17 	ldw	r2,-8(fp)
8110d5a0:	10801014 	ori	r2,r2,64
8110d5a4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d5a8:	e17ffe17 	ldw	r5,-8(fp)
8110d5ac:	01000284 	movi	r4,10
8110d5b0:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d5b4:	00800044 	movi	r2,1
}
8110d5b8:	e037883a 	mov	sp,fp
8110d5bc:	dfc00117 	ldw	ra,4(sp)
8110d5c0:	df000017 	ldw	fp,0(sp)
8110d5c4:	dec00204 	addi	sp,sp,8
8110d5c8:	f800283a 	ret

8110d5cc <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d5cc:	defffc04 	addi	sp,sp,-16
8110d5d0:	de00012e 	bgeu	sp,et,8110d5d8 <bSyncCtrCh8OutEnable+0xc>
8110d5d4:	003b68fa 	trap	3
8110d5d8:	dfc00315 	stw	ra,12(sp)
8110d5dc:	df000215 	stw	fp,8(sp)
8110d5e0:	df000204 	addi	fp,sp,8
8110d5e4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d5e8:	01000284 	movi	r4,10
8110d5ec:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d5f0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d5f4:	e0bfff17 	ldw	r2,-4(fp)
8110d5f8:	1000051e 	bne	r2,zero,8110d610 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d5fc:	e0fffe17 	ldw	r3,-8(fp)
8110d600:	00bfdfc4 	movi	r2,-129
8110d604:	1884703a 	and	r2,r3,r2
8110d608:	e0bffe15 	stw	r2,-8(fp)
8110d60c:	00000306 	br	8110d61c <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d610:	e0bffe17 	ldw	r2,-8(fp)
8110d614:	10802014 	ori	r2,r2,128
8110d618:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d61c:	e17ffe17 	ldw	r5,-8(fp)
8110d620:	01000284 	movi	r4,10
8110d624:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d628:	00800044 	movi	r2,1
}
8110d62c:	e037883a 	mov	sp,fp
8110d630:	dfc00117 	ldw	ra,4(sp)
8110d634:	df000017 	ldw	fp,0(sp)
8110d638:	dec00204 	addi	sp,sp,8
8110d63c:	f800283a 	ret

8110d640 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d640:	defffc04 	addi	sp,sp,-16
8110d644:	de00012e 	bgeu	sp,et,8110d64c <bSyncIrqEnableError+0xc>
8110d648:	003b68fa 	trap	3
8110d64c:	dfc00315 	stw	ra,12(sp)
8110d650:	df000215 	stw	fp,8(sp)
8110d654:	df000204 	addi	fp,sp,8
8110d658:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d65c:	01000044 	movi	r4,1
8110d660:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d664:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d668:	e0bfff17 	ldw	r2,-4(fp)
8110d66c:	1000051e 	bne	r2,zero,8110d684 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d670:	e0fffe17 	ldw	r3,-8(fp)
8110d674:	00bfff44 	movi	r2,-3
8110d678:	1884703a 	and	r2,r3,r2
8110d67c:	e0bffe15 	stw	r2,-8(fp)
8110d680:	00000306 	br	8110d690 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d684:	e0bffe17 	ldw	r2,-8(fp)
8110d688:	10800094 	ori	r2,r2,2
8110d68c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d690:	e17ffe17 	ldw	r5,-8(fp)
8110d694:	01000044 	movi	r4,1
8110d698:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d69c:	00800044 	movi	r2,1
}
8110d6a0:	e037883a 	mov	sp,fp
8110d6a4:	dfc00117 	ldw	ra,4(sp)
8110d6a8:	df000017 	ldw	fp,0(sp)
8110d6ac:	dec00204 	addi	sp,sp,8
8110d6b0:	f800283a 	ret

8110d6b4 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d6b4:	defffc04 	addi	sp,sp,-16
8110d6b8:	de00012e 	bgeu	sp,et,8110d6c0 <bSyncIrqEnableBlank+0xc>
8110d6bc:	003b68fa 	trap	3
8110d6c0:	dfc00315 	stw	ra,12(sp)
8110d6c4:	df000215 	stw	fp,8(sp)
8110d6c8:	df000204 	addi	fp,sp,8
8110d6cc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d6d0:	01000044 	movi	r4,1
8110d6d4:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d6d8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d6dc:	e0bfff17 	ldw	r2,-4(fp)
8110d6e0:	1000051e 	bne	r2,zero,8110d6f8 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d6e4:	e0fffe17 	ldw	r3,-8(fp)
8110d6e8:	00bfff84 	movi	r2,-2
8110d6ec:	1884703a 	and	r2,r3,r2
8110d6f0:	e0bffe15 	stw	r2,-8(fp)
8110d6f4:	00000306 	br	8110d704 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d6f8:	e0bffe17 	ldw	r2,-8(fp)
8110d6fc:	10800054 	ori	r2,r2,1
8110d700:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d704:	e17ffe17 	ldw	r5,-8(fp)
8110d708:	01000044 	movi	r4,1
8110d70c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d710:	00800044 	movi	r2,1
}
8110d714:	e037883a 	mov	sp,fp
8110d718:	dfc00117 	ldw	ra,4(sp)
8110d71c:	df000017 	ldw	fp,0(sp)
8110d720:	dec00204 	addi	sp,sp,8
8110d724:	f800283a 	ret

8110d728 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d728:	defffc04 	addi	sp,sp,-16
8110d72c:	de00012e 	bgeu	sp,et,8110d734 <bSyncIrqFlagClrError+0xc>
8110d730:	003b68fa 	trap	3
8110d734:	dfc00315 	stw	ra,12(sp)
8110d738:	df000215 	stw	fp,8(sp)
8110d73c:	df000204 	addi	fp,sp,8
8110d740:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d744:	01000084 	movi	r4,2
8110d748:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d74c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d750:	e0bfff17 	ldw	r2,-4(fp)
8110d754:	1000051e 	bne	r2,zero,8110d76c <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d758:	e0fffe17 	ldw	r3,-8(fp)
8110d75c:	00bfff44 	movi	r2,-3
8110d760:	1884703a 	and	r2,r3,r2
8110d764:	e0bffe15 	stw	r2,-8(fp)
8110d768:	00000306 	br	8110d778 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d76c:	e0bffe17 	ldw	r2,-8(fp)
8110d770:	10800094 	ori	r2,r2,2
8110d774:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d778:	e17ffe17 	ldw	r5,-8(fp)
8110d77c:	01000084 	movi	r4,2
8110d780:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d784:	00800044 	movi	r2,1
}
8110d788:	e037883a 	mov	sp,fp
8110d78c:	dfc00117 	ldw	ra,4(sp)
8110d790:	df000017 	ldw	fp,0(sp)
8110d794:	dec00204 	addi	sp,sp,8
8110d798:	f800283a 	ret

8110d79c <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d79c:	defffc04 	addi	sp,sp,-16
8110d7a0:	de00012e 	bgeu	sp,et,8110d7a8 <bSyncIrqFlagClrBlank+0xc>
8110d7a4:	003b68fa 	trap	3
8110d7a8:	dfc00315 	stw	ra,12(sp)
8110d7ac:	df000215 	stw	fp,8(sp)
8110d7b0:	df000204 	addi	fp,sp,8
8110d7b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d7b8:	01000084 	movi	r4,2
8110d7bc:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d7c0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d7c4:	e0bfff17 	ldw	r2,-4(fp)
8110d7c8:	1000051e 	bne	r2,zero,8110d7e0 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d7cc:	e0fffe17 	ldw	r3,-8(fp)
8110d7d0:	00bfff84 	movi	r2,-2
8110d7d4:	1884703a 	and	r2,r3,r2
8110d7d8:	e0bffe15 	stw	r2,-8(fp)
8110d7dc:	00000306 	br	8110d7ec <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d7e0:	e0bffe17 	ldw	r2,-8(fp)
8110d7e4:	10800054 	ori	r2,r2,1
8110d7e8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d7ec:	e17ffe17 	ldw	r5,-8(fp)
8110d7f0:	01000084 	movi	r4,2
8110d7f4:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d7f8:	00800044 	movi	r2,1
}
8110d7fc:	e037883a 	mov	sp,fp
8110d800:	dfc00117 	ldw	ra,4(sp)
8110d804:	df000017 	ldw	fp,0(sp)
8110d808:	dec00204 	addi	sp,sp,8
8110d80c:	f800283a 	ret

8110d810 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d810:	defffc04 	addi	sp,sp,-16
8110d814:	de00012e 	bgeu	sp,et,8110d81c <bSyncIrqFlagError+0xc>
8110d818:	003b68fa 	trap	3
8110d81c:	dfc00315 	stw	ra,12(sp)
8110d820:	df000215 	stw	fp,8(sp)
8110d824:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d828:	010000c4 	movi	r4,3
8110d82c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d830:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d834:	e0bfff17 	ldw	r2,-4(fp)
8110d838:	1080008c 	andi	r2,r2,2
8110d83c:	10000326 	beq	r2,zero,8110d84c <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d840:	00800044 	movi	r2,1
8110d844:	e0bffe15 	stw	r2,-8(fp)
8110d848:	00000106 	br	8110d850 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d84c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d850:	e0bffe17 	ldw	r2,-8(fp)
}
8110d854:	e037883a 	mov	sp,fp
8110d858:	dfc00117 	ldw	ra,4(sp)
8110d85c:	df000017 	ldw	fp,0(sp)
8110d860:	dec00204 	addi	sp,sp,8
8110d864:	f800283a 	ret

8110d868 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d868:	defffc04 	addi	sp,sp,-16
8110d86c:	de00012e 	bgeu	sp,et,8110d874 <bSyncIrqFlagBlank+0xc>
8110d870:	003b68fa 	trap	3
8110d874:	dfc00315 	stw	ra,12(sp)
8110d878:	df000215 	stw	fp,8(sp)
8110d87c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d880:	010000c4 	movi	r4,3
8110d884:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d888:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d88c:	e0bfff17 	ldw	r2,-4(fp)
8110d890:	1080004c 	andi	r2,r2,1
8110d894:	10000326 	beq	r2,zero,8110d8a4 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d898:	00800044 	movi	r2,1
8110d89c:	e0bffe15 	stw	r2,-8(fp)
8110d8a0:	00000106 	br	8110d8a8 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d8a4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d8a8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8ac:	e037883a 	mov	sp,fp
8110d8b0:	dfc00117 	ldw	ra,4(sp)
8110d8b4:	df000017 	ldw	fp,0(sp)
8110d8b8:	dec00204 	addi	sp,sp,8
8110d8bc:	f800283a 	ret

8110d8c0 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d8c0:	defffd04 	addi	sp,sp,-12
8110d8c4:	de00012e 	bgeu	sp,et,8110d8cc <uliSyncGetCtr+0xc>
8110d8c8:	003b68fa 	trap	3
8110d8cc:	dfc00215 	stw	ra,8(sp)
8110d8d0:	df000115 	stw	fp,4(sp)
8110d8d4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d8d8:	01000284 	movi	r4,10
8110d8dc:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d8e0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d8e4:	e0bfff17 	ldw	r2,-4(fp)
}
8110d8e8:	e037883a 	mov	sp,fp
8110d8ec:	dfc00117 	ldw	ra,4(sp)
8110d8f0:	df000017 	ldw	fp,0(sp)
8110d8f4:	dec00204 	addi	sp,sp,8
8110d8f8:	f800283a 	ret

8110d8fc <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d8fc:	defffd04 	addi	sp,sp,-12
8110d900:	de00012e 	bgeu	sp,et,8110d908 <uliSyncReadStatus+0xc>
8110d904:	003b68fa 	trap	3
8110d908:	dfc00215 	stw	ra,8(sp)
8110d90c:	df000115 	stw	fp,4(sp)
8110d910:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d914:	0009883a 	mov	r4,zero
8110d918:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d91c:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d920:	e0bfff17 	ldw	r2,-4(fp)
}
8110d924:	e037883a 	mov	sp,fp
8110d928:	dfc00117 	ldw	ra,4(sp)
8110d92c:	df000017 	ldw	fp,0(sp)
8110d930:	dec00204 	addi	sp,sp,8
8110d934:	f800283a 	ret

8110d938 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d938:	defffc04 	addi	sp,sp,-16
8110d93c:	de00012e 	bgeu	sp,et,8110d944 <bSyncWriteReg+0xc>
8110d940:	003b68fa 	trap	3
8110d944:	df000315 	stw	fp,12(sp)
8110d948:	df000304 	addi	fp,sp,12
8110d94c:	e13ffe15 	stw	r4,-8(fp)
8110d950:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d954:	00a00034 	movhi	r2,32768
8110d958:	10810004 	addi	r2,r2,1024
8110d95c:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d960:	e0bffe17 	ldw	r2,-8(fp)
8110d964:	1085883a 	add	r2,r2,r2
8110d968:	1085883a 	add	r2,r2,r2
8110d96c:	1007883a 	mov	r3,r2
8110d970:	e0bffd17 	ldw	r2,-12(fp)
8110d974:	10c5883a 	add	r2,r2,r3
8110d978:	e0ffff17 	ldw	r3,-4(fp)
8110d97c:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d980:	00800044 	movi	r2,1
}
8110d984:	e037883a 	mov	sp,fp
8110d988:	df000017 	ldw	fp,0(sp)
8110d98c:	dec00104 	addi	sp,sp,4
8110d990:	f800283a 	ret

8110d994 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d994:	defffc04 	addi	sp,sp,-16
8110d998:	de00012e 	bgeu	sp,et,8110d9a0 <uliSyncReadReg+0xc>
8110d99c:	003b68fa 	trap	3
8110d9a0:	df000315 	stw	fp,12(sp)
8110d9a4:	df000304 	addi	fp,sp,12
8110d9a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d9ac:	00a00034 	movhi	r2,32768
8110d9b0:	10810004 	addi	r2,r2,1024
8110d9b4:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110d9b8:	e0bfff17 	ldw	r2,-4(fp)
8110d9bc:	1085883a 	add	r2,r2,r2
8110d9c0:	1085883a 	add	r2,r2,r2
8110d9c4:	1007883a 	mov	r3,r2
8110d9c8:	e0bffd17 	ldw	r2,-12(fp)
8110d9cc:	10c5883a 	add	r2,r2,r3
8110d9d0:	10800017 	ldw	r2,0(r2)
8110d9d4:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110d9d8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d9dc:	e037883a 	mov	sp,fp
8110d9e0:	df000017 	ldw	fp,0(sp)
8110d9e4:	dec00104 	addi	sp,sp,4
8110d9e8:	f800283a 	ret

8110d9ec <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110d9ec:	defffc04 	addi	sp,sp,-16
8110d9f0:	de00012e 	bgeu	sp,et,8110d9f8 <uliPerCalcPeriodMs+0xc>
8110d9f4:	003b68fa 	trap	3
8110d9f8:	dfc00315 	stw	ra,12(sp)
8110d9fc:	df000215 	stw	fp,8(sp)
8110da00:	df000204 	addi	fp,sp,8
8110da04:	2005883a 	mov	r2,r4
8110da08:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110da0c:	e0bfff0b 	ldhu	r2,-4(fp)
8110da10:	1009883a 	mov	r4,r2
8110da14:	11224300 	call	81122430 <__floatsidf>
8110da18:	1011883a 	mov	r8,r2
8110da1c:	1813883a 	mov	r9,r3
8110da20:	000d883a 	mov	r6,zero
8110da24:	01d03a34 	movhi	r7,16616
8110da28:	39da8004 	addi	r7,r7,27136
8110da2c:	4009883a 	mov	r4,r8
8110da30:	480b883a 	mov	r5,r9
8110da34:	112138c0 	call	8112138c <__muldf3>
8110da38:	1009883a 	mov	r4,r2
8110da3c:	180b883a 	mov	r5,r3
8110da40:	2005883a 	mov	r2,r4
8110da44:	2807883a 	mov	r3,r5
8110da48:	1009883a 	mov	r4,r2
8110da4c:	180b883a 	mov	r5,r3
8110da50:	11207c40 	call	811207c4 <__fixunsdfsi>
8110da54:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110da58:	e0bffe17 	ldw	r2,-8(fp)
}
8110da5c:	e037883a 	mov	sp,fp
8110da60:	dfc00117 	ldw	ra,4(sp)
8110da64:	df000017 	ldw	fp,0(sp)
8110da68:	dec00204 	addi	sp,sp,8
8110da6c:	f800283a 	ret

8110da70 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110da70:	defff804 	addi	sp,sp,-32
8110da74:	de00012e 	bgeu	sp,et,8110da7c <vDataControlTask+0xc>
8110da78:	003b68fa 	trap	3
8110da7c:	dfc00715 	stw	ra,28(sp)
8110da80:	df000615 	stw	fp,24(sp)
8110da84:	df000604 	addi	fp,sp,24
8110da88:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110da8c:	e0bffd17 	ldw	r2,-12(fp)
8110da90:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110da94:	00a045f4 	movhi	r2,33047
8110da98:	10a00404 	addi	r2,r2,-32752
8110da9c:	10800e8b 	ldhu	r2,58(r2)
8110daa0:	10bfffcc 	andi	r2,r2,65535
8110daa4:	10800168 	cmpgeui	r2,r2,5
8110daa8:	1000071e 	bne	r2,zero,8110dac8 <vDataControlTask+0x58>
        debug(fp,"Data Controller Task. (Task on)\n");
8110daac:	d0a06217 	ldw	r2,-32376(gp)
8110dab0:	100f883a 	mov	r7,r2
8110dab4:	01800804 	movi	r6,32
8110dab8:	01400044 	movi	r5,1
8110dabc:	01204574 	movhi	r4,33045
8110dac0:	21365204 	addi	r4,r4,-9912
8110dac4:	11230300 	call	81123030 <fwrite>
	}
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110dac8:	e0bffa17 	ldw	r2,-24(fp)
8110dacc:	00c00044 	movi	r3,1
8110dad0:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110dad4:	d0a05f17 	ldw	r2,-32388(gp)
8110dad8:	1009883a 	mov	r4,r2
8110dadc:	113ee7c0 	call	8113ee7c <OSQFlush>
8110dae0:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110dae4:	e0bffc03 	ldbu	r2,-16(fp)
8110dae8:	10803fcc 	andi	r2,r2,255
8110daec:	10000126 	beq	r2,zero,8110daf4 <vDataControlTask+0x84>
		vFailFlushQueueData();
8110daf0:	111eae80 	call	8111eae8 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110daf4:	d0a05f17 	ldw	r2,-32388(gp)
8110daf8:	e0fffc04 	addi	r3,fp,-16
8110dafc:	180d883a 	mov	r6,r3
8110db00:	000b883a 	mov	r5,zero
8110db04:	1009883a 	mov	r4,r2
8110db08:	113ef3c0 	call	8113ef3c <OSQPend>
8110db0c:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110db10:	000f883a 	mov	r7,zero
8110db14:	01800144 	movi	r6,5
8110db18:	000b883a 	mov	r5,zero
8110db1c:	0009883a 	mov	r4,zero
8110db20:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
	}
8110db24:	003ff306 	br	8110daf4 <__reset+0xfb0edaf4>

8110db28 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110db28:	defff204 	addi	sp,sp,-56
8110db2c:	de00012e 	bgeu	sp,et,8110db34 <vFeeTask+0xc>
8110db30:	003b68fa 	trap	3
8110db34:	dfc00d15 	stw	ra,52(sp)
8110db38:	df000c15 	stw	fp,48(sp)
8110db3c:	df000c04 	addi	fp,sp,48
8110db40:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110db44:	e0bfff17 	ldw	r2,-4(fp)
8110db48:	d0a05315 	stw	r2,-32436(gp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110db4c:	00a045f4 	movhi	r2,33047
8110db50:	10a00404 	addi	r2,r2,-32752
8110db54:	10800e8b 	ldhu	r2,58(r2)
8110db58:	10bfffcc 	andi	r2,r2,65535
8110db5c:	10800168 	cmpgeui	r2,r2,5
8110db60:	1000091e 	bne	r2,zero,8110db88 <vFeeTask+0x60>
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110db64:	d0e06217 	ldw	r3,-32376(gp)
8110db68:	d0a05317 	ldw	r2,-32436(gp)
8110db6c:	10800003 	ldbu	r2,0(r2)
8110db70:	10803fcc 	andi	r2,r2,255
8110db74:	100d883a 	mov	r6,r2
8110db78:	01604574 	movhi	r5,33045
8110db7c:	29765b04 	addi	r5,r5,-9876
8110db80:	1809883a 	mov	r4,r3
8110db84:	11229940 	call	81122994 <fprintf>
	}
	#endif

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110db88:	00a045f4 	movhi	r2,33047
8110db8c:	10a00404 	addi	r2,r2,-32752
8110db90:	10800e8b 	ldhu	r2,58(r2)
8110db94:	10bfffcc 	andi	r2,r2,65535
8110db98:	108000e8 	cmpgeui	r2,r2,3
8110db9c:	1000031e 	bne	r2,zero,8110dbac <vFeeTask+0x84>
		vPrintConsoleNFee( pxNFee );
8110dba0:	d0a05317 	ldw	r2,-32436(gp)
8110dba4:	1009883a 	mov	r4,r2
8110dba8:	11111840 	call	81111184 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110dbac:	d0a05317 	ldw	r2,-32436(gp)
8110dbb0:	10802c17 	ldw	r2,176(r2)
8110dbb4:	10c00368 	cmpgeui	r3,r2,13
8110dbb8:	18059a1e 	bne	r3,zero,8110f224 <vFeeTask+0x16fc>
8110dbbc:	100690ba 	slli	r3,r2,2
8110dbc0:	00a04474 	movhi	r2,33041
8110dbc4:	10b6f504 	addi	r2,r2,-9260
8110dbc8:	1885883a 	add	r2,r3,r2
8110dbcc:	10800017 	ldw	r2,0(r2)
8110dbd0:	1000683a 	jmp	r2
8110dbd4:	8110dc08 	cmpgei	r4,r16,17264
8110dbd8:	8110e3d0 	cmplti	r4,r16,17295
8110dbdc:	8110e46c 	andhi	r4,r16,17297
8110dbe0:	8110e5e4 	muli	r4,r16,17303
8110dbe4:	8110ed1c 	xori	r4,r16,17332
8110dbe8:	8110e1f0 	cmpltui	r4,r16,17287
8110dbec:	8110e47c 	xorhi	r4,r16,17297
8110dbf0:	8110ebf4 	orhi	r4,r16,17327
8110dbf4:	8110f224 	muli	r4,r16,17352
8110dbf8:	8110f224 	muli	r4,r16,17352
8110dbfc:	8110e680 	call	88110e68 <__reset+0x20f0e68>
8110dc00:	8110f02c 	andhi	r4,r16,17344
8110dc04:	8110f14c 	andi	r4,r16,17349
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110dc08:	d0a05317 	ldw	r2,-32436(gp)
8110dc0c:	10800003 	ldbu	r2,0(r2)
8110dc10:	10803fcc 	andi	r2,r2,255
8110dc14:	1085883a 	add	r2,r2,r2
8110dc18:	1087883a 	add	r3,r2,r2
8110dc1c:	d0a06a04 	addi	r2,gp,-32344
8110dc20:	1885883a 	add	r2,r3,r2
8110dc24:	10800017 	ldw	r2,0(r2)
8110dc28:	1009883a 	mov	r4,r2
8110dc2c:	113ee7c0 	call	8113ee7c <OSQFlush>
8110dc30:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc34:	e0bffd03 	ldbu	r2,-12(fp)
8110dc38:	10803fcc 	andi	r2,r2,255
8110dc3c:	10000126 	beq	r2,zero,8110dc44 <vFeeTask+0x11c>
					vFailFlushNFEEQueue();
8110dc40:	111ebb00 	call	8111ebb0 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110dc44:	d0a05317 	ldw	r2,-32436(gp)
8110dc48:	10800003 	ldbu	r2,0(r2)
8110dc4c:	10803fcc 	andi	r2,r2,255
8110dc50:	1085883a 	add	r2,r2,r2
8110dc54:	1087883a 	add	r3,r2,r2
8110dc58:	d0a05c04 	addi	r2,gp,-32400
8110dc5c:	1885883a 	add	r2,r3,r2
8110dc60:	10800017 	ldw	r2,0(r2)
8110dc64:	1009883a 	mov	r4,r2
8110dc68:	113ee7c0 	call	8113ee7c <OSQFlush>
8110dc6c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc70:	e0bffd03 	ldbu	r2,-12(fp)
8110dc74:	10803fcc 	andi	r2,r2,255
8110dc78:	10000126 	beq	r2,zero,8110dc80 <vFeeTask+0x158>
					vFailFlushNFEEQueue();
8110dc7c:	111ebb00 	call	8111ebb0 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dc80:	d0a05317 	ldw	r2,-32436(gp)
8110dc84:	10803304 	addi	r2,r2,204
8110dc88:	1009883a 	mov	r4,r2
8110dc8c:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110dc90:	d0a05317 	ldw	r2,-32436(gp)
8110dc94:	d0e05317 	ldw	r3,-32436(gp)
8110dc98:	1900308b 	ldhu	r4,194(r3)
8110dc9c:	d0e05317 	ldw	r3,-32436(gp)
8110dca0:	18c02f0b 	ldhu	r3,188(r3)
8110dca4:	20c7883a 	add	r3,r4,r3
8110dca8:	1809883a 	mov	r4,r3
8110dcac:	d0e05317 	ldw	r3,-32436(gp)
8110dcb0:	18c02f8b 	ldhu	r3,190(r3)
8110dcb4:	20c7883a 	add	r3,r4,r3
8110dcb8:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110dcbc:	d0a05317 	ldw	r2,-32436(gp)
8110dcc0:	d0e05317 	ldw	r3,-32436(gp)
8110dcc4:	1900310b 	ldhu	r4,196(r3)
8110dcc8:	d0e05317 	ldw	r3,-32436(gp)
8110dccc:	18c0300b 	ldhu	r3,192(r3)
8110dcd0:	20c7883a 	add	r3,r4,r3
8110dcd4:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110dcd8:	d0a05317 	ldw	r2,-32436(gp)
8110dcdc:	d0e05317 	ldw	r3,-32436(gp)
8110dce0:	18c0310b 	ldhu	r3,196(r3)
8110dce4:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110dce8:	d0a05317 	ldw	r2,-32436(gp)
8110dcec:	d0e05317 	ldw	r3,-32436(gp)
8110dcf0:	18c0300b 	ldhu	r3,192(r3)
8110dcf4:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110dcf8:	d0a05317 	ldw	r2,-32436(gp)
8110dcfc:	00e00004 	movi	r3,-32768
8110dd00:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110dd04:	d0a05317 	ldw	r2,-32436(gp)
8110dd08:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110dd0c:	d0a05317 	ldw	r2,-32436(gp)
8110dd10:	00c00044 	movi	r3,1
8110dd14:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dd18:	d0a05317 	ldw	r2,-32436(gp)
8110dd1c:	10803304 	addi	r2,r2,204
8110dd20:	1009883a 	mov	r4,r2
8110dd24:	11048400 	call	81104840 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dd28:	d0a05317 	ldw	r2,-32436(gp)
8110dd2c:	10804304 	addi	r2,r2,268
8110dd30:	1009883a 	mov	r4,r2
8110dd34:	11094480 	call	81109448 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110dd38:	d0a05317 	ldw	r2,-32436(gp)
8110dd3c:	00ffc004 	movi	r3,-256
8110dd40:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110dd44:	d0a05317 	ldw	r2,-32436(gp)
8110dd48:	00ffc044 	movi	r3,-255
8110dd4c:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110dd50:	d0a05317 	ldw	r2,-32436(gp)
8110dd54:	00ffc084 	movi	r3,-254
8110dd58:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110dd5c:	d0a05317 	ldw	r2,-32436(gp)
8110dd60:	00ffc0c4 	movi	r3,-253
8110dd64:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110dd68:	d0a05317 	ldw	r2,-32436(gp)
8110dd6c:	00ffc104 	movi	r3,-252
8110dd70:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110dd74:	d0a05317 	ldw	r2,-32436(gp)
8110dd78:	00ffc144 	movi	r3,-251
8110dd7c:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110dd80:	d0a05317 	ldw	r2,-32436(gp)
8110dd84:	00ffc184 	movi	r3,-250
8110dd88:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110dd8c:	d0a05317 	ldw	r2,-32436(gp)
8110dd90:	00ffc1c4 	movi	r3,-249
8110dd94:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110dd98:	d0a05317 	ldw	r2,-32436(gp)
8110dd9c:	00ffc204 	movi	r3,-248
8110dda0:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110dda4:	d0a05317 	ldw	r2,-32436(gp)
8110dda8:	00ffc244 	movi	r3,-247
8110ddac:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110ddb0:	d0a05317 	ldw	r2,-32436(gp)
8110ddb4:	00ffc284 	movi	r3,-246
8110ddb8:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110ddbc:	d0a05317 	ldw	r2,-32436(gp)
8110ddc0:	00ffc2c4 	movi	r3,-245
8110ddc4:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110ddc8:	d0a05317 	ldw	r2,-32436(gp)
8110ddcc:	00ffc304 	movi	r3,-244
8110ddd0:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110ddd4:	d0a05317 	ldw	r2,-32436(gp)
8110ddd8:	00ffc344 	movi	r3,-243
8110dddc:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110dde0:	d0a05317 	ldw	r2,-32436(gp)
8110dde4:	00ffc384 	movi	r3,-242
8110dde8:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110ddec:	d0a05317 	ldw	r2,-32436(gp)
8110ddf0:	00ffc3c4 	movi	r3,-241
8110ddf4:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110ddf8:	d0a05317 	ldw	r2,-32436(gp)
8110ddfc:	00ffc404 	movi	r3,-240
8110de00:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110de04:	d0a05317 	ldw	r2,-32436(gp)
8110de08:	00ffc444 	movi	r3,-239
8110de0c:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110de10:	d0a05317 	ldw	r2,-32436(gp)
8110de14:	00ffc484 	movi	r3,-238
8110de18:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110de1c:	d0a05317 	ldw	r2,-32436(gp)
8110de20:	00ffc4c4 	movi	r3,-237
8110de24:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110de28:	d0a05317 	ldw	r2,-32436(gp)
8110de2c:	00ffc504 	movi	r3,-236
8110de30:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110de34:	d0a05317 	ldw	r2,-32436(gp)
8110de38:	00ffc544 	movi	r3,-235
8110de3c:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110de40:	d0a05317 	ldw	r2,-32436(gp)
8110de44:	00ffc584 	movi	r3,-234
8110de48:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110de4c:	d0a05317 	ldw	r2,-32436(gp)
8110de50:	00ffc5c4 	movi	r3,-233
8110de54:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110de58:	d0a05317 	ldw	r2,-32436(gp)
8110de5c:	00ffc604 	movi	r3,-232
8110de60:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110de64:	d0a05317 	ldw	r2,-32436(gp)
8110de68:	00ffc644 	movi	r3,-231
8110de6c:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110de70:	d0a05317 	ldw	r2,-32436(gp)
8110de74:	00ffc684 	movi	r3,-230
8110de78:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110de7c:	d0a05317 	ldw	r2,-32436(gp)
8110de80:	00ffc6c4 	movi	r3,-229
8110de84:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110de88:	d0a05317 	ldw	r2,-32436(gp)
8110de8c:	00ffc704 	movi	r3,-228
8110de90:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110de94:	d0a05317 	ldw	r2,-32436(gp)
8110de98:	00ffc744 	movi	r3,-227
8110de9c:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110dea0:	d0a05317 	ldw	r2,-32436(gp)
8110dea4:	00ffc784 	movi	r3,-226
8110dea8:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110deac:	d0a05317 	ldw	r2,-32436(gp)
8110deb0:	00ffc7c4 	movi	r3,-225
8110deb4:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110deb8:	d0a05317 	ldw	r2,-32436(gp)
8110debc:	00ffc804 	movi	r3,-224
8110dec0:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110dec4:	d0a05317 	ldw	r2,-32436(gp)
8110dec8:	00ffc844 	movi	r3,-223
8110decc:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110ded0:	d0a05317 	ldw	r2,-32436(gp)
8110ded4:	00ffc884 	movi	r3,-222
8110ded8:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110dedc:	d0a05317 	ldw	r2,-32436(gp)
8110dee0:	00ffc8c4 	movi	r3,-221
8110dee4:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110dee8:	d0a05317 	ldw	r2,-32436(gp)
8110deec:	00ffc904 	movi	r3,-220
8110def0:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110def4:	d0a05317 	ldw	r2,-32436(gp)
8110def8:	00ffc944 	movi	r3,-219
8110defc:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110df00:	d0a05317 	ldw	r2,-32436(gp)
8110df04:	00ffc984 	movi	r3,-218
8110df08:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110df0c:	d0a05317 	ldw	r2,-32436(gp)
8110df10:	00ffc9c4 	movi	r3,-217
8110df14:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110df18:	d0a05317 	ldw	r2,-32436(gp)
8110df1c:	00ffca04 	movi	r3,-216
8110df20:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110df24:	d0a05317 	ldw	r2,-32436(gp)
8110df28:	00ffca44 	movi	r3,-215
8110df2c:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110df30:	d0a05317 	ldw	r2,-32436(gp)
8110df34:	00ffca84 	movi	r3,-214
8110df38:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110df3c:	d0a05317 	ldw	r2,-32436(gp)
8110df40:	00ffcac4 	movi	r3,-213
8110df44:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110df48:	d0a05317 	ldw	r2,-32436(gp)
8110df4c:	00ffcb04 	movi	r3,-212
8110df50:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110df54:	d0a05317 	ldw	r2,-32436(gp)
8110df58:	00ffcb44 	movi	r3,-211
8110df5c:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110df60:	d0a05317 	ldw	r2,-32436(gp)
8110df64:	00ffcb84 	movi	r3,-210
8110df68:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110df6c:	d0a05317 	ldw	r2,-32436(gp)
8110df70:	00ffcbc4 	movi	r3,-209
8110df74:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110df78:	d0a05317 	ldw	r2,-32436(gp)
8110df7c:	00ffcc04 	movi	r3,-208
8110df80:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110df84:	d0a05317 	ldw	r2,-32436(gp)
8110df88:	00ffcc44 	movi	r3,-207
8110df8c:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110df90:	d0a05317 	ldw	r2,-32436(gp)
8110df94:	00ffcc84 	movi	r3,-206
8110df98:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110df9c:	d0a05317 	ldw	r2,-32436(gp)
8110dfa0:	00ffccc4 	movi	r3,-205
8110dfa4:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110dfa8:	d0a05317 	ldw	r2,-32436(gp)
8110dfac:	00ffcd04 	movi	r3,-204
8110dfb0:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110dfb4:	d0a05317 	ldw	r2,-32436(gp)
8110dfb8:	00ffcd44 	movi	r3,-203
8110dfbc:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110dfc0:	d0a05317 	ldw	r2,-32436(gp)
8110dfc4:	00ffcd84 	movi	r3,-202
8110dfc8:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110dfcc:	d0a05317 	ldw	r2,-32436(gp)
8110dfd0:	00ffcdc4 	movi	r3,-201
8110dfd4:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110dfd8:	d0a05317 	ldw	r2,-32436(gp)
8110dfdc:	00ffce04 	movi	r3,-200
8110dfe0:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110dfe4:	d0a05317 	ldw	r2,-32436(gp)
8110dfe8:	00ffce44 	movi	r3,-199
8110dfec:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110dff0:	d0a05317 	ldw	r2,-32436(gp)
8110dff4:	00ffce84 	movi	r3,-198
8110dff8:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110dffc:	d0a05317 	ldw	r2,-32436(gp)
8110e000:	00ffcec4 	movi	r3,-197
8110e004:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110e008:	d0a05317 	ldw	r2,-32436(gp)
8110e00c:	00ffcf04 	movi	r3,-196
8110e010:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110e014:	d0a05317 	ldw	r2,-32436(gp)
8110e018:	00ffcf44 	movi	r3,-195
8110e01c:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110e020:	d0a05317 	ldw	r2,-32436(gp)
8110e024:	00ffcf84 	movi	r3,-194
8110e028:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110e02c:	d0a05317 	ldw	r2,-32436(gp)
8110e030:	00ffcfc4 	movi	r3,-193
8110e034:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e038:	d0a05317 	ldw	r2,-32436(gp)
8110e03c:	10804304 	addi	r2,r2,268
8110e040:	1009883a 	mov	r4,r2
8110e044:	11083fc0 	call	811083fc <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110e048:	1111ed80 	call	81111ed8 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e04c:	d0a05317 	ldw	r2,-32436(gp)
8110e050:	10804304 	addi	r2,r2,268
8110e054:	1009883a 	mov	r4,r2
8110e058:	11094480 	call	81109448 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110e05c:	d0a05317 	ldw	r2,-32436(gp)
8110e060:	10806904 	addi	r2,r2,420
8110e064:	e0bffa15 	stw	r2,-24(fp)

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e068:	00a045f4 	movhi	r2,33047
8110e06c:	10a00404 	addi	r2,r2,-32752
8110e070:	10800e8b 	ldhu	r2,58(r2)
8110e074:	10bfffcc 	andi	r2,r2,65535
8110e078:	108000e8 	cmpgeui	r2,r2,3
8110e07c:	1000291e 	bne	r2,zero,8110e124 <vFeeTask+0x5fc>
					fprintf(fp,"\n\n================= H  K ==================\n");
8110e080:	d0a06217 	ldw	r2,-32376(gp)
8110e084:	100f883a 	mov	r7,r2
8110e088:	01800b04 	movi	r6,44
8110e08c:	01400044 	movi	r5,1
8110e090:	01204574 	movhi	r4,33045
8110e094:	21366204 	addi	r4,r4,-9848
8110e098:	11230300 	call	81123030 <fwrite>
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e09c:	e03ffb05 	stb	zero,-20(fp)
8110e0a0:	00001606 	br	8110e0fc <vFeeTask+0x5d4>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110e0a4:	d1206217 	ldw	r4,-32376(gp)
8110e0a8:	e0fffb03 	ldbu	r3,-20(fp)
8110e0ac:	00a04574 	movhi	r2,33045
8110e0b0:	1093a604 	addi	r2,r2,20120
8110e0b4:	18c7883a 	add	r3,r3,r3
8110e0b8:	18c7883a 	add	r3,r3,r3
8110e0bc:	10c5883a 	add	r2,r2,r3
8110e0c0:	10c00017 	ldw	r3,0(r2)
8110e0c4:	e0bffa17 	ldw	r2,-24(fp)
8110e0c8:	1080000b 	ldhu	r2,0(r2)
8110e0cc:	10bfffcc 	andi	r2,r2,65535
8110e0d0:	100f883a 	mov	r7,r2
8110e0d4:	180d883a 	mov	r6,r3
8110e0d8:	01604574 	movhi	r5,33045
8110e0dc:	29766e04 	addi	r5,r5,-9800
8110e0e0:	11229940 	call	81122994 <fprintf>
						pusiHK++;
8110e0e4:	e0bffa17 	ldw	r2,-24(fp)
8110e0e8:	10800084 	addi	r2,r2,2
8110e0ec:	e0bffa15 	stw	r2,-24(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"\n\n================= H  K ==================\n");
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e0f0:	e0bffb03 	ldbu	r2,-20(fp)
8110e0f4:	10800044 	addi	r2,r2,1
8110e0f8:	e0bffb05 	stb	r2,-20(fp)
8110e0fc:	e0bffb03 	ldbu	r2,-20(fp)
8110e100:	10801030 	cmpltui	r2,r2,64
8110e104:	103fe71e 	bne	r2,zero,8110e0a4 <__reset+0xfb0ee0a4>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110e108:	d0a06217 	ldw	r2,-32376(gp)
8110e10c:	100f883a 	mov	r7,r2
8110e110:	01800b04 	movi	r6,44
8110e114:	01400044 	movi	r5,1
8110e118:	01204574 	movhi	r4,33045
8110e11c:	21367304 	addi	r4,r4,-9780
8110e120:	11230300 	call	81123030 <fwrite>
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110e124:	d0a05317 	ldw	r2,-32436(gp)
8110e128:	10804304 	addi	r2,r2,268
8110e12c:	1009883a 	mov	r4,r2
8110e130:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110e134:	d0e05317 	ldw	r3,-32436(gp)
8110e138:	00a045f4 	movhi	r2,33047
8110e13c:	10a00404 	addi	r2,r2,-32752
8110e140:	10800c0b 	ldhu	r2,48(r2)
8110e144:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110e148:	d0e05317 	ldw	r3,-32436(gp)
8110e14c:	00a045f4 	movhi	r2,33047
8110e150:	10a00404 	addi	r2,r2,-32752
8110e154:	10800c8b 	ldhu	r2,50(r2)
8110e158:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110e15c:	d0a05317 	ldw	r2,-32436(gp)
8110e160:	10804304 	addi	r2,r2,268
8110e164:	1009883a 	mov	r4,r2
8110e168:	11079840 	call	81107984 <bRmapSetCodecConfig>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e16c:	00a045f4 	movhi	r2,33047
8110e170:	10a00404 	addi	r2,r2,-32752
8110e174:	10800e8b 	ldhu	r2,58(r2)
8110e178:	10bfffcc 	andi	r2,r2,65535
8110e17c:	108000e8 	cmpgeui	r2,r2,3
8110e180:	1000141e 	bne	r2,zero,8110e1d4 <vFeeTask+0x6ac>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", xDefaults.ucRmapKey );
8110e184:	d0e06217 	ldw	r3,-32376(gp)
8110e188:	00a045f4 	movhi	r2,33047
8110e18c:	10a00404 	addi	r2,r2,-32752
8110e190:	10800c0b 	ldhu	r2,48(r2)
8110e194:	10bfffcc 	andi	r2,r2,65535
8110e198:	100d883a 	mov	r6,r2
8110e19c:	01604574 	movhi	r5,33045
8110e1a0:	29767f04 	addi	r5,r5,-9732
8110e1a4:	1809883a 	mov	r4,r3
8110e1a8:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", xDefaults.ucLogicalAddr);
8110e1ac:	d0e06217 	ldw	r3,-32376(gp)
8110e1b0:	00a045f4 	movhi	r2,33047
8110e1b4:	10a00404 	addi	r2,r2,-32752
8110e1b8:	10800c8b 	ldhu	r2,50(r2)
8110e1bc:	10bfffcc 	andi	r2,r2,65535
8110e1c0:	100d883a 	mov	r6,r2
8110e1c4:	01604574 	movhi	r5,33045
8110e1c8:	29768704 	addi	r5,r5,-9700
8110e1cc:	1809883a 	mov	r4,r3
8110e1d0:	11229940 	call	81122994 <fprintf>
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e1d4:	d0a05317 	ldw	r2,-32436(gp)
8110e1d8:	00c00144 	movi	r3,5
8110e1dc:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e1e0:	d0a05317 	ldw	r2,-32436(gp)
8110e1e4:	10802e17 	ldw	r2,184(r2)
8110e1e8:	d0a05605 	stb	r2,-32424(gp)

				break;
8110e1ec:	00042b06 	br	8110f29c <vFeeTask+0x1774>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e1f0:	d0a05317 	ldw	r2,-32436(gp)
8110e1f4:	10804304 	addi	r2,r2,268
8110e1f8:	1009883a 	mov	r4,r2
8110e1fc:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e200:	d0a05317 	ldw	r2,-32436(gp)
8110e204:	00c00184 	movi	r3,6
8110e208:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e20c:	d0a05317 	ldw	r2,-32436(gp)
8110e210:	10804304 	addi	r2,r2,268
8110e214:	1009883a 	mov	r4,r2
8110e218:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e21c:	d0a05317 	ldw	r2,-32436(gp)
8110e220:	10808904 	addi	r2,r2,548
8110e224:	1009883a 	mov	r4,r2
8110e228:	1110e780 	call	81110e78 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e22c:	d0a05317 	ldw	r2,-32436(gp)
8110e230:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110e234:	d0a05317 	ldw	r2,-32436(gp)
8110e238:	10c04304 	addi	r3,r2,268
8110e23c:	d0a05317 	ldw	r2,-32436(gp)
8110e240:	10800043 	ldbu	r2,1(r2)
8110e244:	10803fcc 	andi	r2,r2,255
8110e248:	100b883a 	mov	r5,r2
8110e24c:	1809883a 	mov	r4,r3
8110e250:	1110dcc0 	call	81110dcc <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e254:	d0a05317 	ldw	r2,-32436(gp)
8110e258:	10803b04 	addi	r2,r2,236
8110e25c:	1009883a 	mov	r4,r2
8110e260:	1110fd00 	call	81110fd0 <bDisAndClrDbBuffer>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e264:	00a045f4 	movhi	r2,33047
8110e268:	10a00404 	addi	r2,r2,-32752
8110e26c:	10800e8b 	ldhu	r2,58(r2)
8110e270:	10bfffcc 	andi	r2,r2,65535
8110e274:	10800168 	cmpgeui	r2,r2,5
8110e278:	1000091e 	bne	r2,zero,8110e2a0 <vFeeTask+0x778>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e27c:	d0e06217 	ldw	r3,-32376(gp)
8110e280:	d0a05317 	ldw	r2,-32436(gp)
8110e284:	10800003 	ldbu	r2,0(r2)
8110e288:	10803fcc 	andi	r2,r2,255
8110e28c:	100d883a 	mov	r6,r2
8110e290:	01604574 	movhi	r5,33045
8110e294:	29769004 	addi	r5,r5,-9664
8110e298:	1809883a 	mov	r4,r3
8110e29c:	11229940 	call	81122994 <fprintf>
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e2a0:	d0a05317 	ldw	r2,-32436(gp)
8110e2a4:	10802217 	ldw	r2,136(r2)
8110e2a8:	10800058 	cmpnei	r2,r2,1
8110e2ac:	10000a1e 	bne	r2,zero,8110e2d8 <vFeeTask+0x7b0>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e2b0:	e0fff403 	ldbu	r3,-48(fp)
8110e2b4:	00a045b4 	movhi	r2,33046
8110e2b8:	10934804 	addi	r2,r2,19744
8110e2bc:	180690fa 	slli	r3,r3,3
8110e2c0:	10c5883a 	add	r2,r2,r3
8110e2c4:	10800017 	ldw	r2,0(r2)
8110e2c8:	1009883a 	mov	r4,r2
8110e2cc:	113e3cc0 	call	8113e3cc <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110e2d0:	d0a05317 	ldw	r2,-32436(gp)
8110e2d4:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e2d8:	d0a05317 	ldw	r2,-32436(gp)
8110e2dc:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e2e0:	d0a05317 	ldw	r2,-32436(gp)
8110e2e4:	10800003 	ldbu	r2,0(r2)
8110e2e8:	10803fcc 	andi	r2,r2,255
8110e2ec:	1085883a 	add	r2,r2,r2
8110e2f0:	1087883a 	add	r3,r2,r2
8110e2f4:	d0a05c04 	addi	r2,gp,-32400
8110e2f8:	1885883a 	add	r2,r3,r2
8110e2fc:	10800017 	ldw	r2,0(r2)
8110e300:	1009883a 	mov	r4,r2
8110e304:	113ee7c0 	call	8113ee7c <OSQFlush>
8110e308:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e30c:	e0bffd03 	ldbu	r2,-12(fp)
8110e310:	10803fcc 	andi	r2,r2,255
8110e314:	10000126 	beq	r2,zero,8110e31c <vFeeTask+0x7f4>
					vFailFlushNFEEQueue();
8110e318:	111ebb00 	call	8111ebb0 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e31c:	d0a05317 	ldw	r2,-32436(gp)
8110e320:	10800003 	ldbu	r2,0(r2)
8110e324:	10803fcc 	andi	r2,r2,255
8110e328:	100d883a 	mov	r6,r2
8110e32c:	000b883a 	mov	r5,zero
8110e330:	01002044 	movi	r4,129
8110e334:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110e338:	d0a05317 	ldw	r2,-32436(gp)
8110e33c:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110e340:	d0a05317 	ldw	r2,-32436(gp)
8110e344:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e348:	d0a05317 	ldw	r2,-32436(gp)
8110e34c:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e350:	d0a05317 	ldw	r2,-32436(gp)
8110e354:	00c00044 	movi	r3,1
8110e358:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110e35c:	d0a05317 	ldw	r2,-32436(gp)
8110e360:	1009883a 	mov	r4,r2
8110e364:	111f2a00 	call	8111f2a0 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e368:	d0a05317 	ldw	r2,-32436(gp)
8110e36c:	10800003 	ldbu	r2,0(r2)
8110e370:	10803fcc 	andi	r2,r2,255
8110e374:	1085883a 	add	r2,r2,r2
8110e378:	1087883a 	add	r3,r2,r2
8110e37c:	d0a06a04 	addi	r2,gp,-32344
8110e380:	1885883a 	add	r2,r3,r2
8110e384:	10800017 	ldw	r2,0(r2)
8110e388:	1009883a 	mov	r4,r2
8110e38c:	113ee7c0 	call	8113ee7c <OSQFlush>
8110e390:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e394:	e0bffd03 	ldbu	r2,-12(fp)
8110e398:	10803fcc 	andi	r2,r2,255
8110e39c:	10000126 	beq	r2,zero,8110e3a4 <vFeeTask+0x87c>
					vFailFlushNFEEQueue();
8110e3a0:	111ebb00 	call	8111ebb0 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110e3a4:	d0a05317 	ldw	r2,-32436(gp)
8110e3a8:	00c00044 	movi	r3,1
8110e3ac:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110e3b0:	d0a05317 	ldw	r2,-32436(gp)
8110e3b4:	00c00044 	movi	r3,1
8110e3b8:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e3bc:	d0a05317 	ldw	r2,-32436(gp)
8110e3c0:	10802e17 	ldw	r2,184(r2)
8110e3c4:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110e3c8:	e03ff915 	stw	zero,-28(fp)
				break;
8110e3cc:	0003b306 	br	8110f29c <vFeeTask+0x1774>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e3d0:	d0a05317 	ldw	r2,-32436(gp)
8110e3d4:	10800003 	ldbu	r2,0(r2)
8110e3d8:	10803fcc 	andi	r2,r2,255
8110e3dc:	1085883a 	add	r2,r2,r2
8110e3e0:	1087883a 	add	r3,r2,r2
8110e3e4:	d0a06a04 	addi	r2,gp,-32344
8110e3e8:	1885883a 	add	r2,r3,r2
8110e3ec:	10800017 	ldw	r2,0(r2)
8110e3f0:	e0fffd04 	addi	r3,fp,-12
8110e3f4:	180d883a 	mov	r6,r3
8110e3f8:	000b883a 	mov	r5,zero
8110e3fc:	1009883a 	mov	r4,r2
8110e400:	113ef3c0 	call	8113ef3c <OSQPend>
8110e404:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e408:	e0bffd03 	ldbu	r2,-12(fp)
8110e40c:	10803fcc 	andi	r2,r2,255
8110e410:	1000061e 	bne	r2,zero,8110e42c <vFeeTask+0x904>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110e414:	d0a05317 	ldw	r2,-32436(gp)
8110e418:	e0fffe17 	ldw	r3,-8(fp)
8110e41c:	180b883a 	mov	r5,r3
8110e420:	1009883a 	mov	r4,r2
8110e424:	110f4b80 	call	8110f4b8 <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110e428:	00039106 	br	8110f270 <vFeeTask+0x1748>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110e42c:	00a045f4 	movhi	r2,33047
8110e430:	10a00404 	addi	r2,r2,-32752
8110e434:	10800e8b 	ldhu	r2,58(r2)
8110e438:	10bfffcc 	andi	r2,r2,65535
8110e43c:	108001e8 	cmpgeui	r2,r2,7
8110e440:	10038b1e 	bne	r2,zero,8110f270 <vFeeTask+0x1748>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e444:	d0e06217 	ldw	r3,-32376(gp)
8110e448:	d0a05317 	ldw	r2,-32436(gp)
8110e44c:	10800003 	ldbu	r2,0(r2)
8110e450:	10803fcc 	andi	r2,r2,255
8110e454:	100d883a 	mov	r6,r2
8110e458:	01604574 	movhi	r5,33045
8110e45c:	29769704 	addi	r5,r5,-9636
8110e460:	1809883a 	mov	r4,r3
8110e464:	11229940 	call	81122994 <fprintf>
					}
					#endif
				}

				break;
8110e468:	00038106 	br	8110f270 <vFeeTask+0x1748>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110e46c:	d0a05317 	ldw	r2,-32436(gp)
8110e470:	00c00184 	movi	r3,6
8110e474:	10c02c15 	stw	r3,176(r2)
				break;
8110e478:	00038806 	br	8110f29c <vFeeTask+0x1774>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e47c:	d0a05317 	ldw	r2,-32436(gp)
8110e480:	10804304 	addi	r2,r2,268
8110e484:	1009883a 	mov	r4,r2
8110e488:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110e48c:	d0a05317 	ldw	r2,-32436(gp)
8110e490:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e494:	d0a05317 	ldw	r2,-32436(gp)
8110e498:	10804304 	addi	r2,r2,268
8110e49c:	1009883a 	mov	r4,r2
8110e4a0:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e4a4:	d0a05317 	ldw	r2,-32436(gp)
8110e4a8:	10803b04 	addi	r2,r2,236
8110e4ac:	1009883a 	mov	r4,r2
8110e4b0:	1110fd00 	call	81110fd0 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e4b4:	d0a05317 	ldw	r2,-32436(gp)
8110e4b8:	10c04304 	addi	r3,r2,268
8110e4bc:	d0a05317 	ldw	r2,-32436(gp)
8110e4c0:	10800003 	ldbu	r2,0(r2)
8110e4c4:	10803fcc 	andi	r2,r2,255
8110e4c8:	100b883a 	mov	r5,r2
8110e4cc:	1809883a 	mov	r4,r3
8110e4d0:	1110e200 	call	81110e20 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e4d4:	d0a05317 	ldw	r2,-32436(gp)
8110e4d8:	10808904 	addi	r2,r2,548
8110e4dc:	1009883a 	mov	r4,r2
8110e4e0:	1110ed80 	call	81110ed8 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110e4e4:	d0a05317 	ldw	r2,-32436(gp)
8110e4e8:	00c00044 	movi	r3,1
8110e4ec:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110e4f0:	d0a05317 	ldw	r2,-32436(gp)
8110e4f4:	00c00044 	movi	r3,1
8110e4f8:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e4fc:	d0a05317 	ldw	r2,-32436(gp)
8110e500:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e504:	d0a05317 	ldw	r2,-32436(gp)
8110e508:	00c00044 	movi	r3,1
8110e50c:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e510:	d0a05317 	ldw	r2,-32436(gp)
8110e514:	10800003 	ldbu	r2,0(r2)
8110e518:	10803fcc 	andi	r2,r2,255
8110e51c:	100d883a 	mov	r6,r2
8110e520:	000b883a 	mov	r5,zero
8110e524:	01002044 	movi	r4,129
8110e528:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e52c:	d0a05317 	ldw	r2,-32436(gp)
8110e530:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e534:	d0a05317 	ldw	r2,-32436(gp)
8110e538:	10800003 	ldbu	r2,0(r2)
8110e53c:	10803fcc 	andi	r2,r2,255
8110e540:	1085883a 	add	r2,r2,r2
8110e544:	1087883a 	add	r3,r2,r2
8110e548:	d0a05c04 	addi	r2,gp,-32400
8110e54c:	1885883a 	add	r2,r3,r2
8110e550:	10800017 	ldw	r2,0(r2)
8110e554:	1009883a 	mov	r4,r2
8110e558:	113ee7c0 	call	8113ee7c <OSQFlush>
8110e55c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e560:	e0bffd03 	ldbu	r2,-12(fp)
8110e564:	10803fcc 	andi	r2,r2,255
8110e568:	10000126 	beq	r2,zero,8110e570 <vFeeTask+0xa48>
					vFailFlushNFEEQueue();
8110e56c:	111ebb00 	call	8111ebb0 <vFailFlushNFEEQueue>
				}

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e570:	00a045f4 	movhi	r2,33047
8110e574:	10a00404 	addi	r2,r2,-32752
8110e578:	10800e8b 	ldhu	r2,58(r2)
8110e57c:	10bfffcc 	andi	r2,r2,65535
8110e580:	10800168 	cmpgeui	r2,r2,5
8110e584:	1000091e 	bne	r2,zero,8110e5ac <vFeeTask+0xa84>
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
8110e588:	d0e06217 	ldw	r3,-32376(gp)
8110e58c:	d0a05317 	ldw	r2,-32436(gp)
8110e590:	10800003 	ldbu	r2,0(r2)
8110e594:	10803fcc 	andi	r2,r2,255
8110e598:	100d883a 	mov	r6,r2
8110e59c:	01604574 	movhi	r5,33045
8110e5a0:	2976a304 	addi	r5,r5,-9588
8110e5a4:	1809883a 	mov	r4,r3
8110e5a8:	11229940 	call	81122994 <fprintf>
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110e5ac:	d0a05317 	ldw	r2,-32436(gp)
8110e5b0:	1009883a 	mov	r4,r2
8110e5b4:	111f2a00 	call	8111f2a0 <vResetMemCCDFEE>

				incrementador = 0;
8110e5b8:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110e5bc:	d0a05317 	ldw	r2,-32436(gp)
8110e5c0:	00c00044 	movi	r3,1
8110e5c4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110e5c8:	d0a05317 	ldw	r2,-32436(gp)
8110e5cc:	00c000c4 	movi	r3,3
8110e5d0:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e5d4:	d0a05317 	ldw	r2,-32436(gp)
8110e5d8:	10802e17 	ldw	r2,184(r2)
8110e5dc:	d0a05605 	stb	r2,-32424(gp)
				break;
8110e5e0:	00032e06 	br	8110f29c <vFeeTask+0x1774>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e5e4:	d0a05317 	ldw	r2,-32436(gp)
8110e5e8:	10800003 	ldbu	r2,0(r2)
8110e5ec:	10803fcc 	andi	r2,r2,255
8110e5f0:	1085883a 	add	r2,r2,r2
8110e5f4:	1087883a 	add	r3,r2,r2
8110e5f8:	d0a06a04 	addi	r2,gp,-32344
8110e5fc:	1885883a 	add	r2,r3,r2
8110e600:	10800017 	ldw	r2,0(r2)
8110e604:	e0fffd04 	addi	r3,fp,-12
8110e608:	180d883a 	mov	r6,r3
8110e60c:	000b883a 	mov	r5,zero
8110e610:	1009883a 	mov	r4,r2
8110e614:	113ef3c0 	call	8113ef3c <OSQPend>
8110e618:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e61c:	e0bffd03 	ldbu	r2,-12(fp)
8110e620:	10803fcc 	andi	r2,r2,255
8110e624:	1000061e 	bne	r2,zero,8110e640 <vFeeTask+0xb18>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110e628:	d0a05317 	ldw	r2,-32436(gp)
8110e62c:	e0fffe17 	ldw	r3,-8(fp)
8110e630:	180b883a 	mov	r5,r3
8110e634:	1009883a 	mov	r4,r2
8110e638:	110f6fc0 	call	8110f6fc <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110e63c:	00030e06 	br	8110f278 <vFeeTask+0x1750>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110e640:	00a045f4 	movhi	r2,33047
8110e644:	10a00404 	addi	r2,r2,-32752
8110e648:	10800e8b 	ldhu	r2,58(r2)
8110e64c:	10bfffcc 	andi	r2,r2,65535
8110e650:	108001e8 	cmpgeui	r2,r2,7
8110e654:	1003081e 	bne	r2,zero,8110f278 <vFeeTask+0x1750>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e658:	d0e06217 	ldw	r3,-32376(gp)
8110e65c:	d0a05317 	ldw	r2,-32436(gp)
8110e660:	10800003 	ldbu	r2,0(r2)
8110e664:	10803fcc 	andi	r2,r2,255
8110e668:	100d883a 	mov	r6,r2
8110e66c:	01604574 	movhi	r5,33045
8110e670:	29769704 	addi	r5,r5,-9636
8110e674:	1809883a 	mov	r4,r3
8110e678:	11229940 	call	81122994 <fprintf>
					}
					#endif
				}

				break;
8110e67c:	0002fe06 	br	8110f278 <vFeeTask+0x1750>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e680:	d0a05317 	ldw	r2,-32436(gp)
8110e684:	10800003 	ldbu	r2,0(r2)
8110e688:	10803fcc 	andi	r2,r2,255
8110e68c:	1085883a 	add	r2,r2,r2
8110e690:	1087883a 	add	r3,r2,r2
8110e694:	d0a05c04 	addi	r2,gp,-32400
8110e698:	1885883a 	add	r2,r3,r2
8110e69c:	10800017 	ldw	r2,0(r2)
8110e6a0:	1009883a 	mov	r4,r2
8110e6a4:	113ee7c0 	call	8113ee7c <OSQFlush>
8110e6a8:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e6ac:	e0bffd03 	ldbu	r2,-12(fp)
8110e6b0:	10803fcc 	andi	r2,r2,255
8110e6b4:	10000126 	beq	r2,zero,8110e6bc <vFeeTask+0xb94>
					vFailFlushNFEEQueue();
8110e6b8:	111ebb00 	call	8111ebb0 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110e6bc:	d0a05317 	ldw	r2,-32436(gp)
8110e6c0:	00c00044 	movi	r3,1
8110e6c4:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e6c8:	d0a05317 	ldw	r2,-32436(gp)
8110e6cc:	00c00044 	movi	r3,1
8110e6d0:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110e6d4:	d0a05317 	ldw	r2,-32436(gp)
8110e6d8:	1009883a 	mov	r4,r2
8110e6dc:	111f2a00 	call	8111f2a0 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				while ( (bFeebGetCh1LeftBufferEmpty()== FALSE) || (bFeebGetCh1RightBufferEmpty()== FALSE)  ) {}
8110e6e0:	0001883a 	nop
8110e6e4:	11064580 	call	81106458 <bFeebGetCh1LeftBufferEmpty>
8110e6e8:	103ffe26 	beq	r2,zero,8110e6e4 <__reset+0xfb0ee6e4>
8110e6ec:	11064c00 	call	811064c0 <bFeebGetCh1RightBufferEmpty>
8110e6f0:	103ffc26 	beq	r2,zero,8110e6e4 <__reset+0xfb0ee6e4>

				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
8110e6f4:	00a045f4 	movhi	r2,33047
8110e6f8:	10a00404 	addi	r2,r2,-32752
8110e6fc:	10800f8b 	ldhu	r2,62(r2)
8110e700:	10bfffcc 	andi	r2,r2,65535
8110e704:	100f883a 	mov	r7,r2
8110e708:	000d883a 	mov	r6,zero
8110e70c:	000b883a 	mov	r5,zero
8110e710:	0009883a 	mov	r4,zero
8110e714:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110e718:	00a045f4 	movhi	r2,33047
8110e71c:	10a00404 	addi	r2,r2,-32752
8110e720:	10800e0b 	ldhu	r2,56(r2)
8110e724:	10bfffcc 	andi	r2,r2,65535
8110e728:	1000071e 	bne	r2,zero,8110e748 <vFeeTask+0xc20>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e72c:	000b883a 	mov	r5,zero
8110e730:	01000404 	movi	r4,16
8110e734:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e738:	01400044 	movi	r5,1
8110e73c:	01000404 	movi	r4,16
8110e740:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
8110e744:	00000606 	br	8110e760 <vFeeTask+0xc38>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e748:	000b883a 	mov	r5,zero
8110e74c:	01000404 	movi	r4,16
8110e750:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e754:	01400044 	movi	r5,1
8110e758:	01000404 	movi	r4,16
8110e75c:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
				}

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e760:	d0a05317 	ldw	r2,-32436(gp)
8110e764:	10803b04 	addi	r2,r2,236
8110e768:	1009883a 	mov	r4,r2
8110e76c:	1110f380 	call	81110f38 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110e770:	d0a05317 	ldw	r2,-32436(gp)
8110e774:	10808904 	addi	r2,r2,548
8110e778:	1009883a 	mov	r4,r2
8110e77c:	110a4a00 	call	8110a4a0 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110e780:	d0a05317 	ldw	r2,-32436(gp)
8110e784:	10809543 	ldbu	r2,597(r2)
8110e788:	10803fcc 	andi	r2,r2,255
8110e78c:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110e790:	d0a05517 	ldw	r2,-32428(gp)
8110e794:	10800044 	addi	r2,r2,1
8110e798:	108000cc 	andi	r2,r2,3
8110e79c:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110e7a0:	e0bffc17 	ldw	r2,-16(fp)
8110e7a4:	10000e1e 	bne	r2,zero,8110e7e0 <vFeeTask+0xcb8>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110e7a8:	d0a05317 	ldw	r2,-32436(gp)
8110e7ac:	10802917 	ldw	r2,164(r2)
8110e7b0:	10800003 	ldbu	r2,0(r2)
8110e7b4:	10803fcc 	andi	r2,r2,255
8110e7b8:	10c00044 	addi	r3,r2,1
8110e7bc:	00a00034 	movhi	r2,32768
8110e7c0:	10800044 	addi	r2,r2,1
8110e7c4:	1884703a 	and	r2,r3,r2
8110e7c8:	1000040e 	bge	r2,zero,8110e7dc <vFeeTask+0xcb4>
8110e7cc:	10bfffc4 	addi	r2,r2,-1
8110e7d0:	00ffff84 	movi	r3,-2
8110e7d4:	10c4b03a 	or	r2,r2,r3
8110e7d8:	10800044 	addi	r2,r2,1
8110e7dc:	e0bff405 	stb	r2,-48(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110e7e0:	d0e05317 	ldw	r3,-32436(gp)
8110e7e4:	e0bffc17 	ldw	r2,-16(fp)
8110e7e8:	1885883a 	add	r2,r3,r2
8110e7ec:	10802a44 	addi	r2,r2,169
8110e7f0:	10800003 	ldbu	r2,0(r2)
8110e7f4:	e0bff605 	stb	r2,-40(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110e7f8:	d0a05317 	ldw	r2,-32436(gp)
8110e7fc:	10802e17 	ldw	r2,184(r2)
8110e800:	1000071e 	bne	r2,zero,8110e820 <vFeeTask+0xcf8>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110e804:	d0e05317 	ldw	r3,-32436(gp)
8110e808:	e0bff603 	ldbu	r2,-40(fp)
8110e80c:	10800624 	muli	r2,r2,24
8110e810:	10800904 	addi	r2,r2,36
8110e814:	1885883a 	add	r2,r3,r2
8110e818:	e0bff515 	stw	r2,-44(fp)
8110e81c:	00000606 	br	8110e838 <vFeeTask+0xd10>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110e820:	d0e05317 	ldw	r3,-32436(gp)
8110e824:	e0bff603 	ldbu	r2,-40(fp)
8110e828:	10800624 	muli	r2,r2,24
8110e82c:	10800c04 	addi	r2,r2,48
8110e830:	1885883a 	add	r2,r3,r2
8110e834:	e0bff515 	stw	r2,-44(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110e838:	d0a05317 	ldw	r2,-32436(gp)
8110e83c:	10802e17 	ldw	r2,184(r2)
8110e840:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e844:	d0a05317 	ldw	r2,-32436(gp)
8110e848:	10803304 	addi	r2,r2,204
8110e84c:	1009883a 	mov	r4,r2
8110e850:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110e854:	d0a05317 	ldw	r2,-32436(gp)
8110e858:	e0fff603 	ldbu	r3,-40(fp)
8110e85c:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
8110e860:	d0a05317 	ldw	r2,-32436(gp)
8110e864:	00c00044 	movi	r3,1
8110e868:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e86c:	d0a05317 	ldw	r2,-32436(gp)
8110e870:	10803304 	addi	r2,r2,204
8110e874:	1009883a 	mov	r4,r2
8110e878:	11048400 	call	81104840 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e87c:	d0a05317 	ldw	r2,-32436(gp)
8110e880:	10803304 	addi	r2,r2,204
8110e884:	1009883a 	mov	r4,r2
8110e888:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e88c:	00a045f4 	movhi	r2,33047
8110e890:	10a00404 	addi	r2,r2,-32752
8110e894:	10800e8b 	ldhu	r2,58(r2)
8110e898:	10bfffcc 	andi	r2,r2,65535
8110e89c:	108000e8 	cmpgeui	r2,r2,3
8110e8a0:	10004d1e 	bne	r2,zero,8110e9d8 <vFeeTask+0xeb0>
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110e8a4:	d0a06217 	ldw	r2,-32376(gp)
8110e8a8:	100f883a 	mov	r7,r2
8110e8ac:	01800904 	movi	r6,36
8110e8b0:	01400044 	movi	r5,1
8110e8b4:	01204574 	movhi	r4,33045
8110e8b8:	2136a904 	addi	r4,r4,-9564
8110e8bc:	11230300 	call	81123030 <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110e8c0:	d0e06217 	ldw	r3,-32376(gp)
8110e8c4:	d0a05317 	ldw	r2,-32436(gp)
8110e8c8:	1080340b 	ldhu	r2,208(r2)
8110e8cc:	10bfffcc 	andi	r2,r2,65535
8110e8d0:	100d883a 	mov	r6,r2
8110e8d4:	01604574 	movhi	r5,33045
8110e8d8:	2976b304 	addi	r5,r5,-9524
8110e8dc:	1809883a 	mov	r4,r3
8110e8e0:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110e8e4:	d0e06217 	ldw	r3,-32376(gp)
8110e8e8:	d0a05317 	ldw	r2,-32436(gp)
8110e8ec:	1080348b 	ldhu	r2,210(r2)
8110e8f0:	10bfffcc 	andi	r2,r2,65535
8110e8f4:	100d883a 	mov	r6,r2
8110e8f8:	01604574 	movhi	r5,33045
8110e8fc:	2976b804 	addi	r5,r5,-9504
8110e900:	1809883a 	mov	r4,r3
8110e904:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110e908:	d0e06217 	ldw	r3,-32376(gp)
8110e90c:	d0a05317 	ldw	r2,-32436(gp)
8110e910:	1080350b 	ldhu	r2,212(r2)
8110e914:	10bfffcc 	andi	r2,r2,65535
8110e918:	100d883a 	mov	r6,r2
8110e91c:	01604574 	movhi	r5,33045
8110e920:	2976bd04 	addi	r5,r5,-9484
8110e924:	1809883a 	mov	r4,r3
8110e928:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110e92c:	d0e06217 	ldw	r3,-32376(gp)
8110e930:	d0a05317 	ldw	r2,-32436(gp)
8110e934:	1080358b 	ldhu	r2,214(r2)
8110e938:	10bfffcc 	andi	r2,r2,65535
8110e93c:	100d883a 	mov	r6,r2
8110e940:	01604574 	movhi	r5,33045
8110e944:	2976c204 	addi	r5,r5,-9464
8110e948:	1809883a 	mov	r4,r3
8110e94c:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110e950:	d0e06217 	ldw	r3,-32376(gp)
8110e954:	d0a05317 	ldw	r2,-32436(gp)
8110e958:	1080360b 	ldhu	r2,216(r2)
8110e95c:	10bfffcc 	andi	r2,r2,65535
8110e960:	100d883a 	mov	r6,r2
8110e964:	01604574 	movhi	r5,33045
8110e968:	2976c804 	addi	r5,r5,-9440
8110e96c:	1809883a 	mov	r4,r3
8110e970:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110e974:	d0e06217 	ldw	r3,-32376(gp)
8110e978:	d0a05317 	ldw	r2,-32436(gp)
8110e97c:	108036c3 	ldbu	r2,219(r2)
8110e980:	10803fcc 	andi	r2,r2,255
8110e984:	100d883a 	mov	r6,r2
8110e988:	01604574 	movhi	r5,33045
8110e98c:	2976ce04 	addi	r5,r5,-9416
8110e990:	1809883a 	mov	r4,r3
8110e994:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110e998:	d0e06217 	ldw	r3,-32376(gp)
8110e99c:	d0a05317 	ldw	r2,-32436(gp)
8110e9a0:	10803683 	ldbu	r2,218(r2)
8110e9a4:	10803fcc 	andi	r2,r2,255
8110e9a8:	100d883a 	mov	r6,r2
8110e9ac:	01604574 	movhi	r5,33045
8110e9b0:	2976d304 	addi	r5,r5,-9396
8110e9b4:	1809883a 	mov	r4,r3
8110e9b8:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e9bc:	d0a06217 	ldw	r2,-32376(gp)
8110e9c0:	100f883a 	mov	r7,r2
8110e9c4:	01800884 	movi	r6,34
8110e9c8:	01400044 	movi	r5,1
8110e9cc:	01204574 	movhi	r4,33045
8110e9d0:	2136d704 	addi	r4,r4,-9380
8110e9d4:	11230300 	call	81123030 <fwrite>
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110e9d8:	d0a05317 	ldw	r2,-32436(gp)
8110e9dc:	10800003 	ldbu	r2,0(r2)
8110e9e0:	10803fcc 	andi	r2,r2,255
8110e9e4:	100d883a 	mov	r6,r2
8110e9e8:	000b883a 	mov	r5,zero
8110e9ec:	01002004 	movi	r4,128
8110e9f0:	111103c0 	call	8111103c <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110e9f4:	e03ff815 	stw	zero,-32(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e9f8:	d0a05317 	ldw	r2,-32436(gp)
8110e9fc:	10800003 	ldbu	r2,0(r2)
8110ea00:	10803fcc 	andi	r2,r2,255
8110ea04:	1085883a 	add	r2,r2,r2
8110ea08:	1087883a 	add	r3,r2,r2
8110ea0c:	d0a06a04 	addi	r2,gp,-32344
8110ea10:	1885883a 	add	r2,r3,r2
8110ea14:	10800017 	ldw	r2,0(r2)
8110ea18:	e0fffd04 	addi	r3,fp,-12
8110ea1c:	180d883a 	mov	r6,r3
8110ea20:	000b883a 	mov	r5,zero
8110ea24:	1009883a 	mov	r4,r2
8110ea28:	113ef3c0 	call	8113ef3c <OSQPend>
8110ea2c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ea30:	e0bffd03 	ldbu	r2,-12(fp)
8110ea34:	10803fcc 	andi	r2,r2,255
8110ea38:	10005e1e 	bne	r2,zero,8110ebb4 <vFeeTask+0x108c>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ea3c:	e0bffe83 	ldbu	r2,-6(fp)
8110ea40:	10803fcc 	andi	r2,r2,255
8110ea44:	108023d8 	cmpnei	r2,r2,143
8110ea48:	1000541e 	bne	r2,zero,8110eb9c <vFeeTask+0x1074>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ea4c:	e0fff403 	ldbu	r3,-48(fp)
8110ea50:	00a045b4 	movhi	r2,33046
8110ea54:	10934804 	addi	r2,r2,19744
8110ea58:	180690fa 	slli	r3,r3,3
8110ea5c:	10c5883a 	add	r2,r2,r3
8110ea60:	10800017 	ldw	r2,0(r2)
8110ea64:	e0fffd04 	addi	r3,fp,-12
8110ea68:	180d883a 	mov	r6,r3
8110ea6c:	000b883a 	mov	r5,zero
8110ea70:	1009883a 	mov	r4,r2
8110ea74:	113de280 	call	8113de28 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110ea78:	e0bffd03 	ldbu	r2,-12(fp)
8110ea7c:	10803fcc 	andi	r2,r2,255
8110ea80:	1000181e 	bne	r2,zero,8110eae4 <vFeeTask+0xfbc>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110ea84:	d0a05317 	ldw	r2,-32436(gp)
8110ea88:	00c00044 	movi	r3,1
8110ea8c:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110ea90:	e0fff403 	ldbu	r3,-48(fp)
8110ea94:	d0a05317 	ldw	r2,-32436(gp)
8110ea98:	10800003 	ldbu	r2,0(r2)
8110ea9c:	10803fcc 	andi	r2,r2,255
8110eaa0:	d1205317 	ldw	r4,-32436(gp)
8110eaa4:	200f883a 	mov	r7,r4
8110eaa8:	100d883a 	mov	r6,r2
8110eaac:	180b883a 	mov	r5,r3
8110eab0:	e13ff517 	ldw	r4,-44(fp)
8110eab4:	1111aec0 	call	81111aec <bPrepareDoubleBuffer>
8110eab8:	e0bff815 	stw	r2,-32(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110eabc:	e0fff403 	ldbu	r3,-48(fp)
8110eac0:	00a045b4 	movhi	r2,33046
8110eac4:	10934804 	addi	r2,r2,19744
8110eac8:	180690fa 	slli	r3,r3,3
8110eacc:	10c5883a 	add	r2,r2,r3
8110ead0:	10800017 	ldw	r2,0(r2)
8110ead4:	1009883a 	mov	r4,r2
8110ead8:	113e3cc0 	call	8113e3cc <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110eadc:	d0a05317 	ldw	r2,-32436(gp)
8110eae0:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110eae4:	d0a05317 	ldw	r2,-32436(gp)
8110eae8:	10800003 	ldbu	r2,0(r2)
8110eaec:	10803fcc 	andi	r2,r2,255
8110eaf0:	100d883a 	mov	r6,r2
8110eaf4:	000b883a 	mov	r5,zero
8110eaf8:	01002044 	movi	r4,129
8110eafc:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110eb00:	e0bff817 	ldw	r2,-32(fp)
8110eb04:	10800058 	cmpnei	r2,r2,1
8110eb08:	1000141e 	bne	r2,zero,8110eb5c <vFeeTask+0x1034>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110eb0c:	d0a05317 	ldw	r2,-32436(gp)
8110eb10:	10802817 	ldw	r2,160(r2)
8110eb14:	10800058 	cmpnei	r2,r2,1
8110eb18:	1000071e 	bne	r2,zero,8110eb38 <vFeeTask+0x1010>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110eb1c:	d0a05317 	ldw	r2,-32436(gp)
8110eb20:	00c001c4 	movi	r3,7
8110eb24:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110eb28:	d0a05317 	ldw	r2,-32436(gp)
8110eb2c:	00c00304 	movi	r3,12
8110eb30:	10c02c15 	stw	r3,176(r2)
8110eb34:	00000606 	br	8110eb50 <vFeeTask+0x1028>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110eb38:	d0a05317 	ldw	r2,-32436(gp)
8110eb3c:	00c001c4 	movi	r3,7
8110eb40:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110eb44:	d0a05317 	ldw	r2,-32436(gp)
8110eb48:	00c001c4 	movi	r3,7
8110eb4c:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110eb50:	d0a05417 	ldw	r2,-32432(gp)
8110eb54:	10800044 	addi	r2,r2,1
8110eb58:	d0a05415 	stw	r2,-32432(gp)
						}

						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110eb5c:	00a045f4 	movhi	r2,33047
8110eb60:	10a00404 	addi	r2,r2,-32752
8110eb64:	10800e8b 	ldhu	r2,58(r2)
8110eb68:	10bfffcc 	andi	r2,r2,65535
8110eb6c:	10800168 	cmpgeui	r2,r2,5
8110eb70:	1001c31e 	bne	r2,zero,8110f280 <vFeeTask+0x1758>
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
8110eb74:	d0e06217 	ldw	r3,-32376(gp)
8110eb78:	d0a05317 	ldw	r2,-32436(gp)
8110eb7c:	10800003 	ldbu	r2,0(r2)
8110eb80:	10803fcc 	andi	r2,r2,255
8110eb84:	100d883a 	mov	r6,r2
8110eb88:	01604574 	movhi	r5,33045
8110eb8c:	2976e004 	addi	r5,r5,-9344
8110eb90:	1809883a 	mov	r4,r3
8110eb94:	11229940 	call	81122994 <fprintf>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110eb98:	0001b906 	br	8110f280 <vFeeTask+0x1758>
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
						}
						#endif
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110eb9c:	d0a05317 	ldw	r2,-32436(gp)
8110eba0:	e0fffe17 	ldw	r3,-8(fp)
8110eba4:	180b883a 	mov	r5,r3
8110eba8:	1009883a 	mov	r4,r2
8110ebac:	110f9580 	call	8110f958 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110ebb0:	0001b306 	br	8110f280 <vFeeTask+0x1758>
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ebb4:	00a045f4 	movhi	r2,33047
8110ebb8:	10a00404 	addi	r2,r2,-32752
8110ebbc:	10800e8b 	ldhu	r2,58(r2)
8110ebc0:	10bfffcc 	andi	r2,r2,65535
8110ebc4:	108001e8 	cmpgeui	r2,r2,7
8110ebc8:	1001ad1e 	bne	r2,zero,8110f280 <vFeeTask+0x1758>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ebcc:	d0e06217 	ldw	r3,-32376(gp)
8110ebd0:	d0a05317 	ldw	r2,-32436(gp)
8110ebd4:	10800003 	ldbu	r2,0(r2)
8110ebd8:	10803fcc 	andi	r2,r2,255
8110ebdc:	100d883a 	mov	r6,r2
8110ebe0:	01604574 	movhi	r5,33045
8110ebe4:	29769704 	addi	r5,r5,-9636
8110ebe8:	1809883a 	mov	r4,r3
8110ebec:	11229940 	call	81122994 <fprintf>
					}
					#endif
				}	
				break;
8110ebf0:	0001a306 	br	8110f280 <vFeeTask+0x1758>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110ebf4:	e03ff915 	stw	zero,-28(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ebf8:	d0a05317 	ldw	r2,-32436(gp)
8110ebfc:	10804304 	addi	r2,r2,268
8110ec00:	1009883a 	mov	r4,r2
8110ec04:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110ec08:	d0a05317 	ldw	r2,-32436(gp)
8110ec0c:	00c00084 	movi	r3,2
8110ec10:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ec14:	d0a05317 	ldw	r2,-32436(gp)
8110ec18:	10804304 	addi	r2,r2,268
8110ec1c:	1009883a 	mov	r4,r2
8110ec20:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110ec24:	00a045f4 	movhi	r2,33047
8110ec28:	10a00404 	addi	r2,r2,-32752
8110ec2c:	10800e8b 	ldhu	r2,58(r2)
8110ec30:	10bfffcc 	andi	r2,r2,65535
8110ec34:	108000e8 	cmpgeui	r2,r2,3
8110ec38:	1000091e 	bne	r2,zero,8110ec60 <vFeeTask+0x1138>
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110ec3c:	d0e06217 	ldw	r3,-32376(gp)
8110ec40:	d0a05317 	ldw	r2,-32436(gp)
8110ec44:	10800003 	ldbu	r2,0(r2)
8110ec48:	10803fcc 	andi	r2,r2,255
8110ec4c:	100d883a 	mov	r6,r2
8110ec50:	01604574 	movhi	r5,33045
8110ec54:	2976ea04 	addi	r5,r5,-9304
8110ec58:	1809883a 	mov	r4,r3
8110ec5c:	11229940 	call	81122994 <fprintf>
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110ec60:	d0a05317 	ldw	r2,-32436(gp)
8110ec64:	10802e17 	ldw	r2,184(r2)
8110ec68:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110ec6c:	d0a05317 	ldw	r2,-32436(gp)
8110ec70:	00c00044 	movi	r3,1
8110ec74:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110ec78:	d0a05317 	ldw	r2,-32436(gp)
8110ec7c:	00c00104 	movi	r3,4
8110ec80:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110ec84:	d0a05317 	ldw	r2,-32436(gp)
8110ec88:	00c00104 	movi	r3,4
8110ec8c:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110ec90:	d0a05317 	ldw	r2,-32436(gp)
8110ec94:	00c00044 	movi	r3,1
8110ec98:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110ec9c:	d0a05317 	ldw	r2,-32436(gp)
8110eca0:	00c00044 	movi	r3,1
8110eca4:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110eca8:	d0a05317 	ldw	r2,-32436(gp)
8110ecac:	00c00044 	movi	r3,1
8110ecb0:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ecb4:	d0a05317 	ldw	r2,-32436(gp)
8110ecb8:	10800003 	ldbu	r2,0(r2)
8110ecbc:	10803fcc 	andi	r2,r2,255
8110ecc0:	100d883a 	mov	r6,r2
8110ecc4:	000b883a 	mov	r5,zero
8110ecc8:	01002004 	movi	r4,128
8110eccc:	111103c0 	call	8111103c <bSendRequestNFeeCtrl>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110ecd0:	00a045f4 	movhi	r2,33047
8110ecd4:	10a00404 	addi	r2,r2,-32752
8110ecd8:	10800e0b 	ldhu	r2,56(r2)
8110ecdc:	10bfffcc 	andi	r2,r2,65535
8110ece0:	1000071e 	bne	r2,zero,8110ed00 <vFeeTask+0x11d8>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ece4:	000b883a 	mov	r5,zero
8110ece8:	01000404 	movi	r4,16
8110ecec:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ecf0:	01400044 	movi	r5,1
8110ecf4:	01000404 	movi	r4,16
8110ecf8:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}

				break;
8110ecfc:	00016706 	br	8110f29c <vFeeTask+0x1774>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ed00:	000b883a 	mov	r5,zero
8110ed04:	01000404 	movi	r4,16
8110ed08:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ed0c:	01400044 	movi	r5,1
8110ed10:	01000404 	movi	r4,16
8110ed14:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
				}

				break;
8110ed18:	00016006 	br	8110f29c <vFeeTask+0x1774>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110ed1c:	e03ff915 	stw	zero,-28(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ed20:	d0a05317 	ldw	r2,-32436(gp)
8110ed24:	10800003 	ldbu	r2,0(r2)
8110ed28:	10803fcc 	andi	r2,r2,255
8110ed2c:	1085883a 	add	r2,r2,r2
8110ed30:	1087883a 	add	r3,r2,r2
8110ed34:	d0a06a04 	addi	r2,gp,-32344
8110ed38:	1885883a 	add	r2,r3,r2
8110ed3c:	10800017 	ldw	r2,0(r2)
8110ed40:	e0fffd04 	addi	r3,fp,-12
8110ed44:	180d883a 	mov	r6,r3
8110ed48:	000b883a 	mov	r5,zero
8110ed4c:	1009883a 	mov	r4,r2
8110ed50:	113ef3c0 	call	8113ef3c <OSQPend>
8110ed54:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ed58:	e0bffd03 	ldbu	r2,-12(fp)
8110ed5c:	10803fcc 	andi	r2,r2,255
8110ed60:	1000a21e 	bne	r2,zero,8110efec <vFeeTask+0x14c4>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ed64:	e0bffe83 	ldbu	r2,-6(fp)
8110ed68:	10803fcc 	andi	r2,r2,255
8110ed6c:	108023d8 	cmpnei	r2,r2,143
8110ed70:	1000911e 	bne	r2,zero,8110efb8 <vFeeTask+0x1490>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ed74:	e0fff403 	ldbu	r3,-48(fp)
8110ed78:	00a045b4 	movhi	r2,33046
8110ed7c:	10934804 	addi	r2,r2,19744
8110ed80:	180690fa 	slli	r3,r3,3
8110ed84:	10c5883a 	add	r2,r2,r3
8110ed88:	10800017 	ldw	r2,0(r2)
8110ed8c:	e0fffd04 	addi	r3,fp,-12
8110ed90:	180d883a 	mov	r6,r3
8110ed94:	000b883a 	mov	r5,zero
8110ed98:	1009883a 	mov	r4,r2
8110ed9c:	113de280 	call	8113de28 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
8110eda0:	e0bffd03 	ldbu	r2,-12(fp)
8110eda4:	10803fcc 	andi	r2,r2,255
8110eda8:	1001371e 	bne	r2,zero,8110f288 <vFeeTask+0x1760>
							pxNFee->xControl.bDMALocked = TRUE;
8110edac:	d0a05317 	ldw	r2,-32436(gp)
8110edb0:	00c00044 	movi	r3,1
8110edb4:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110edb8:	e0bff517 	ldw	r2,-44(fp)
8110edbc:	10800117 	ldw	r2,4(r2)
8110edc0:	10c00404 	addi	r3,r2,16
8110edc4:	d0a05317 	ldw	r2,-32436(gp)
8110edc8:	10800417 	ldw	r2,16(r2)
8110edcc:	18802336 	bltu	r3,r2,8110ee5c <vFeeTask+0x1334>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110edd0:	d0a05317 	ldw	r2,-32436(gp)
8110edd4:	10c00417 	ldw	r3,16(r2)
8110edd8:	e0bff517 	ldw	r2,-44(fp)
8110eddc:	10800117 	ldw	r2,4(r2)
8110ede0:	1885c83a 	sub	r2,r3,r2
8110ede4:	e0bff715 	stw	r2,-36(fp)

								if (xDefaults.usiLinkNFEE0 == 0) {
8110ede8:	00a045f4 	movhi	r2,33047
8110edec:	10a00404 	addi	r2,r2,-32752
8110edf0:	10800e0b 	ldhu	r2,56(r2)
8110edf4:	10bfffcc 	andi	r2,r2,65535
8110edf8:	10000b1e 	bne	r2,zero,8110ee28 <vFeeTask+0x1300>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110edfc:	e0bff717 	ldw	r2,-36(fp)
8110ee00:	10803fcc 	andi	r2,r2,255
8110ee04:	000b883a 	mov	r5,zero
8110ee08:	1009883a 	mov	r4,r2
8110ee0c:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ee10:	e0bff717 	ldw	r2,-36(fp)
8110ee14:	10803fcc 	andi	r2,r2,255
8110ee18:	01400044 	movi	r5,1
8110ee1c:	1009883a 	mov	r4,r2
8110ee20:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
8110ee24:	00000a06 	br	8110ee50 <vFeeTask+0x1328>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ee28:	e0bff717 	ldw	r2,-36(fp)
8110ee2c:	10803fcc 	andi	r2,r2,255
8110ee30:	000b883a 	mov	r5,zero
8110ee34:	1009883a 	mov	r4,r2
8110ee38:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ee3c:	e0bff717 	ldw	r2,-36(fp)
8110ee40:	10803fcc 	andi	r2,r2,255
8110ee44:	01400044 	movi	r5,1
8110ee48:	1009883a 	mov	r4,r2
8110ee4c:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
								}

								bFinal = TRUE;
8110ee50:	00800044 	movi	r2,1
8110ee54:	e0bff915 	stw	r2,-28(fp)
8110ee58:	00000206 	br	8110ee64 <vFeeTask+0x133c>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
8110ee5c:	00800404 	movi	r2,16
8110ee60:	e0bff715 	stw	r2,-36(fp)
							}


							if ( ucMemUsing == 0  ) {
8110ee64:	e0bff403 	ldbu	r2,-48(fp)
8110ee68:	1000111e 	bne	r2,zero,8110eeb0 <vFeeTask+0x1388>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110ee6c:	e0bff517 	ldw	r2,-44(fp)
8110ee70:	10800217 	ldw	r2,8(r2)
8110ee74:	1011883a 	mov	r8,r2
8110ee78:	e0bff717 	ldw	r2,-36(fp)
8110ee7c:	10ffffcc 	andi	r3,r2,65535
8110ee80:	d0a05603 	ldbu	r2,-32424(gp)
8110ee84:	11003fcc 	andi	r4,r2,255
8110ee88:	d0a05317 	ldw	r2,-32436(gp)
8110ee8c:	10800043 	ldbu	r2,1(r2)
8110ee90:	10803fcc 	andi	r2,r2,255
8110ee94:	100f883a 	mov	r7,r2
8110ee98:	200d883a 	mov	r6,r4
8110ee9c:	180b883a 	mov	r5,r3
8110eea0:	4009883a 	mov	r4,r8
8110eea4:	1103cb00 	call	81103cb0 <bSdmaDmaM1Transfer>
8110eea8:	e0bff815 	stw	r2,-32(fp)
8110eeac:	00001006 	br	8110eef0 <vFeeTask+0x13c8>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110eeb0:	e0bff517 	ldw	r2,-44(fp)
8110eeb4:	10800217 	ldw	r2,8(r2)
8110eeb8:	1011883a 	mov	r8,r2
8110eebc:	e0bff717 	ldw	r2,-36(fp)
8110eec0:	10ffffcc 	andi	r3,r2,65535
8110eec4:	d0a05603 	ldbu	r2,-32424(gp)
8110eec8:	11003fcc 	andi	r4,r2,255
8110eecc:	d0a05317 	ldw	r2,-32436(gp)
8110eed0:	10800043 	ldbu	r2,1(r2)
8110eed4:	10803fcc 	andi	r2,r2,255
8110eed8:	100f883a 	mov	r7,r2
8110eedc:	200d883a 	mov	r6,r4
8110eee0:	180b883a 	mov	r5,r3
8110eee4:	4009883a 	mov	r4,r8
8110eee8:	11041040 	call	81104104 <bSdmaDmaM2Transfer>
8110eeec:	e0bff815 	stw	r2,-32(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110eef0:	e0fff403 	ldbu	r3,-48(fp)
8110eef4:	00a045b4 	movhi	r2,33046
8110eef8:	10934804 	addi	r2,r2,19744
8110eefc:	180690fa 	slli	r3,r3,3
8110ef00:	10c5883a 	add	r2,r2,r3
8110ef04:	10800017 	ldw	r2,0(r2)
8110ef08:	1009883a 	mov	r4,r2
8110ef0c:	113e3cc0 	call	8113e3cc <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110ef10:	d0a05317 	ldw	r2,-32436(gp)
8110ef14:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
8110ef18:	e0bff817 	ldw	r2,-32(fp)
8110ef1c:	10800058 	cmpnei	r2,r2,1
8110ef20:	10000e1e 	bne	r2,zero,8110ef5c <vFeeTask+0x1434>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110ef24:	e0bff517 	ldw	r2,-44(fp)
8110ef28:	10c00217 	ldw	r3,8(r2)
8110ef2c:	e0bff717 	ldw	r2,-36(fp)
8110ef30:	10802224 	muli	r2,r2,136
8110ef34:	1887883a 	add	r3,r3,r2
8110ef38:	e0bff517 	ldw	r2,-44(fp)
8110ef3c:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110ef40:	e0bff517 	ldw	r2,-44(fp)
8110ef44:	10c00117 	ldw	r3,4(r2)
8110ef48:	e0bff717 	ldw	r2,-36(fp)
8110ef4c:	1887883a 	add	r3,r3,r2
8110ef50:	e0bff517 	ldw	r2,-44(fp)
8110ef54:	10c00115 	stw	r3,4(r2)
8110ef58:	00000106 	br	8110ef60 <vFeeTask+0x1438>
							} else {
								bFinal = FALSE;
8110ef5c:	e03ff915 	stw	zero,-28(fp)
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ef60:	d0a05317 	ldw	r2,-32436(gp)
8110ef64:	10800003 	ldbu	r2,0(r2)
8110ef68:	10803fcc 	andi	r2,r2,255
8110ef6c:	100d883a 	mov	r6,r2
8110ef70:	000b883a 	mov	r5,zero
8110ef74:	01002044 	movi	r4,129
8110ef78:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
8110ef7c:	e0bff917 	ldw	r2,-28(fp)
8110ef80:	10800058 	cmpnei	r2,r2,1
8110ef84:	1000041e 	bne	r2,zero,8110ef98 <vFeeTask+0x1470>
								pxNFee->xControl.eMode = sEndTransmission;
8110ef88:	d0a05317 	ldw	r2,-32436(gp)
8110ef8c:	00c002c4 	movi	r3,11
8110ef90:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110ef94:	0000bc06 	br	8110f288 <vFeeTask+0x1760>
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);

							if ( bFinal == TRUE ) {
								pxNFee->xControl.eMode = sEndTransmission;
							} else {
								bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ef98:	d0a05317 	ldw	r2,-32436(gp)
8110ef9c:	10800003 	ldbu	r2,0(r2)
8110efa0:	10803fcc 	andi	r2,r2,255
8110efa4:	100d883a 	mov	r6,r2
8110efa8:	000b883a 	mov	r5,zero
8110efac:	01002004 	movi	r4,128
8110efb0:	111103c0 	call	8111103c <bSendRequestNFeeCtrl>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110efb4:	0000b406 	br	8110f288 <vFeeTask+0x1760>
								bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110efb8:	d0a05317 	ldw	r2,-32436(gp)
8110efbc:	e0fffe17 	ldw	r3,-8(fp)
8110efc0:	180b883a 	mov	r5,r3
8110efc4:	1009883a 	mov	r4,r2
8110efc8:	110f9580 	call	8110f958 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110efcc:	d0a05317 	ldw	r2,-32436(gp)
8110efd0:	10802817 	ldw	r2,160(r2)
8110efd4:	1000ac1e 	bne	r2,zero,8110f288 <vFeeTask+0x1760>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110efd8:	d0a05317 	ldw	r2,-32436(gp)
8110efdc:	d0e05317 	ldw	r3,-32436(gp)
8110efe0:	18c02d17 	ldw	r3,180(r3)
8110efe4:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110efe8:	0000a706 	br	8110f288 <vFeeTask+0x1760>
						}
					}

				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110efec:	00a045f4 	movhi	r2,33047
8110eff0:	10a00404 	addi	r2,r2,-32752
8110eff4:	10800e8b 	ldhu	r2,58(r2)
8110eff8:	10bfffcc 	andi	r2,r2,65535
8110effc:	108001e8 	cmpgeui	r2,r2,7
8110f000:	1000a11e 	bne	r2,zero,8110f288 <vFeeTask+0x1760>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f004:	d0e06217 	ldw	r3,-32376(gp)
8110f008:	d0a05317 	ldw	r2,-32436(gp)
8110f00c:	10800003 	ldbu	r2,0(r2)
8110f010:	10803fcc 	andi	r2,r2,255
8110f014:	100d883a 	mov	r6,r2
8110f018:	01604574 	movhi	r5,33045
8110f01c:	29769704 	addi	r5,r5,-9636
8110f020:	1809883a 	mov	r4,r3
8110f024:	11229940 	call	81122994 <fprintf>
					}
					#endif
				}

				break;
8110f028:	00009706 	br	8110f288 <vFeeTask+0x1760>

			case sEndTransmission:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f02c:	00a045f4 	movhi	r2,33047
8110f030:	10a00404 	addi	r2,r2,-32752
8110f034:	10800e8b 	ldhu	r2,58(r2)
8110f038:	10bfffcc 	andi	r2,r2,65535
8110f03c:	10800168 	cmpgeui	r2,r2,5
8110f040:	1000121e 	bne	r2,zero,8110f08c <vFeeTask+0x1564>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
8110f044:	d0e06217 	ldw	r3,-32376(gp)
8110f048:	d0a05317 	ldw	r2,-32436(gp)
8110f04c:	10800003 	ldbu	r2,0(r2)
8110f050:	10803fcc 	andi	r2,r2,255
8110f054:	e13ff603 	ldbu	r4,-40(fp)
8110f058:	200f883a 	mov	r7,r4
8110f05c:	100d883a 	mov	r6,r2
8110f060:	01604574 	movhi	r5,33045
8110f064:	2976f404 	addi	r5,r5,-9264
8110f068:	1809883a 	mov	r4,r3
8110f06c:	11229940 	call	81122994 <fprintf>
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
8110f070:	d0a06217 	ldw	r2,-32376(gp)
8110f074:	e0fff403 	ldbu	r3,-48(fp)
8110f078:	180d883a 	mov	r6,r3
8110f07c:	01604574 	movhi	r5,33045
8110f080:	2976ff04 	addi	r5,r5,-9220
8110f084:	1009883a 	mov	r4,r2
8110f088:	11229940 	call	81122994 <fprintf>
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
8110f08c:	d0a05317 	ldw	r2,-32436(gp)
8110f090:	00c00044 	movi	r3,1
8110f094:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110f098:	d0a05317 	ldw	r2,-32436(gp)
8110f09c:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
8110f0a0:	00a045f4 	movhi	r2,33047
8110f0a4:	10a00404 	addi	r2,r2,-32752
8110f0a8:	10800d17 	ldw	r2,52(r2)
8110f0ac:	1000201e 	bne	r2,zero,8110f130 <vFeeTask+0x1608>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110f0b0:	d0a05317 	ldw	r2,-32436(gp)
8110f0b4:	10802d17 	ldw	r2,180(r2)
8110f0b8:	10800198 	cmpnei	r2,r2,6
8110f0bc:	1000151e 	bne	r2,zero,8110f114 <vFeeTask+0x15ec>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f0c0:	d0a05317 	ldw	r2,-32436(gp)
8110f0c4:	10803304 	addi	r2,r2,204
8110f0c8:	1009883a 	mov	r4,r2
8110f0cc:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110f0d0:	d0a05317 	ldw	r2,-32436(gp)
8110f0d4:	e0fff603 	ldbu	r3,-40(fp)
8110f0d8:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8110f0dc:	d0a05317 	ldw	r2,-32436(gp)
8110f0e0:	00c00144 	movi	r3,5
8110f0e4:	10c03685 	stb	r3,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f0e8:	d0a05317 	ldw	r2,-32436(gp)
8110f0ec:	10803304 	addi	r2,r2,204
8110f0f0:	1009883a 	mov	r4,r2
8110f0f4:	11048400 	call	81104840 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f0f8:	d0a05317 	ldw	r2,-32436(gp)
8110f0fc:	00c00304 	movi	r3,12
8110f100:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f104:	d0a05317 	ldw	r2,-32436(gp)
8110f108:	00c00184 	movi	r3,6
8110f10c:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110f110:	00006206 	br	8110f29c <vFeeTask+0x1774>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110f114:	d0a05317 	ldw	r2,-32436(gp)
8110f118:	00c00284 	movi	r3,10
8110f11c:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110f120:	d0a05317 	ldw	r2,-32436(gp)
8110f124:	00c00304 	movi	r3,12
8110f128:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110f12c:	00005b06 	br	8110f29c <vFeeTask+0x1774>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f130:	d0a05317 	ldw	r2,-32436(gp)
8110f134:	00c00304 	movi	r3,12
8110f138:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f13c:	d0a05317 	ldw	r2,-32436(gp)
8110f140:	00c00184 	movi	r3,6
8110f144:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f148:	00005406 	br	8110f29c <vFeeTask+0x1774>

			case sFeeWaitingSync:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f14c:	00a045f4 	movhi	r2,33047
8110f150:	10a00404 	addi	r2,r2,-32752
8110f154:	10800e8b 	ldhu	r2,58(r2)
8110f158:	10bfffcc 	andi	r2,r2,65535
8110f15c:	10800168 	cmpgeui	r2,r2,5
8110f160:	1000091e 	bne	r2,zero,8110f188 <vFeeTask+0x1660>
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110f164:	d0e06217 	ldw	r3,-32376(gp)
8110f168:	d0a05317 	ldw	r2,-32436(gp)
8110f16c:	10800003 	ldbu	r2,0(r2)
8110f170:	10803fcc 	andi	r2,r2,255
8110f174:	100d883a 	mov	r6,r2
8110f178:	01604574 	movhi	r5,33045
8110f17c:	29770404 	addi	r5,r5,-9200
8110f180:	1809883a 	mov	r4,r3
8110f184:	11229940 	call	81122994 <fprintf>
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f188:	d0a05317 	ldw	r2,-32436(gp)
8110f18c:	10800003 	ldbu	r2,0(r2)
8110f190:	10803fcc 	andi	r2,r2,255
8110f194:	1085883a 	add	r2,r2,r2
8110f198:	1087883a 	add	r3,r2,r2
8110f19c:	d0a06a04 	addi	r2,gp,-32344
8110f1a0:	1885883a 	add	r2,r3,r2
8110f1a4:	10800017 	ldw	r2,0(r2)
8110f1a8:	e0fffd04 	addi	r3,fp,-12
8110f1ac:	180d883a 	mov	r6,r3
8110f1b0:	000b883a 	mov	r5,zero
8110f1b4:	1009883a 	mov	r4,r2
8110f1b8:	113ef3c0 	call	8113ef3c <OSQPend>
8110f1bc:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110f1c0:	e0bffd03 	ldbu	r2,-12(fp)
8110f1c4:	10803fcc 	andi	r2,r2,255
8110f1c8:	10001026 	beq	r2,zero,8110f20c <vFeeTask+0x16e4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f1cc:	00a045f4 	movhi	r2,33047
8110f1d0:	10a00404 	addi	r2,r2,-32752
8110f1d4:	10800e8b 	ldhu	r2,58(r2)
8110f1d8:	10bfffcc 	andi	r2,r2,65535
8110f1dc:	108001e8 	cmpgeui	r2,r2,7
8110f1e0:	10002b1e 	bne	r2,zero,8110f290 <vFeeTask+0x1768>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110f1e4:	d0e06217 	ldw	r3,-32376(gp)
8110f1e8:	d0a05317 	ldw	r2,-32436(gp)
8110f1ec:	10800003 	ldbu	r2,0(r2)
8110f1f0:	10803fcc 	andi	r2,r2,255
8110f1f4:	100d883a 	mov	r6,r2
8110f1f8:	01604574 	movhi	r5,33045
8110f1fc:	29770d04 	addi	r5,r5,-9164
8110f200:	1809883a 	mov	r4,r3
8110f204:	11229940 	call	81122994 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f208:	00002106 	br	8110f290 <vFeeTask+0x1768>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110f20c:	d0a05317 	ldw	r2,-32436(gp)
8110f210:	e0fffe17 	ldw	r3,-8(fp)
8110f214:	180b883a 	mov	r5,r3
8110f218:	1009883a 	mov	r4,r2
8110f21c:	110f2a00 	call	8110f2a0 <vQCmdFEEinWaitingSync>
				}

				break;
8110f220:	00001b06 	br	8110f290 <vFeeTask+0x1768>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110f224:	d0a05317 	ldw	r2,-32436(gp)
8110f228:	00c00144 	movi	r3,5
8110f22c:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f230:	00a045f4 	movhi	r2,33047
8110f234:	10a00404 	addi	r2,r2,-32752
8110f238:	10800e8b 	ldhu	r2,58(r2)
8110f23c:	10bfffcc 	andi	r2,r2,65535
8110f240:	108001e8 	cmpgeui	r2,r2,7
8110f244:	1000141e 	bne	r2,zero,8110f298 <vFeeTask+0x1770>
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110f248:	d0e06217 	ldw	r3,-32376(gp)
8110f24c:	d0a05317 	ldw	r2,-32436(gp)
8110f250:	10800003 	ldbu	r2,0(r2)
8110f254:	10803fcc 	andi	r2,r2,255
8110f258:	100d883a 	mov	r6,r2
8110f25c:	01604574 	movhi	r5,33045
8110f260:	29771e04 	addi	r5,r5,-9096
8110f264:	1809883a 	mov	r4,r3
8110f268:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f26c:	00000a06 	br	8110f298 <vFeeTask+0x1770>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f270:	0001883a 	nop
8110f274:	003a4d06 	br	8110dbac <__reset+0xfb0edbac>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f278:	0001883a 	nop
8110f27c:	003a4b06 	br	8110dbac <__reset+0xfb0edbac>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f280:	0001883a 	nop
8110f284:	003a4906 	br	8110dbac <__reset+0xfb0edbac>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f288:	0001883a 	nop
8110f28c:	003a4706 	br	8110dbac <__reset+0xfb0edbac>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f290:	0001883a 	nop
8110f294:	003a4506 	br	8110dbac <__reset+0xfb0edbac>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
8110f298:	0001883a 	nop
		}

	}
8110f29c:	003a4306 	br	8110dbac <__reset+0xfb0edbac>

8110f2a0 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110f2a0:	defffb04 	addi	sp,sp,-20
8110f2a4:	de00012e 	bgeu	sp,et,8110f2ac <vQCmdFEEinWaitingSync+0xc>
8110f2a8:	003b68fa 	trap	3
8110f2ac:	dfc00415 	stw	ra,16(sp)
8110f2b0:	df000315 	stw	fp,12(sp)
8110f2b4:	df000304 	addi	fp,sp,12
8110f2b8:	e13ffe15 	stw	r4,-8(fp)
8110f2bc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f2c0:	e0bfff17 	ldw	r2,-4(fp)
8110f2c4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f2c8:	e0bffdc3 	ldbu	r2,-9(fp)
8110f2cc:	10c03fcc 	andi	r3,r2,255
8110f2d0:	e0bffe17 	ldw	r2,-8(fp)
8110f2d4:	10800003 	ldbu	r2,0(r2)
8110f2d8:	10803fcc 	andi	r2,r2,255
8110f2dc:	10800444 	addi	r2,r2,17
8110f2e0:	18806f1e 	bne	r3,r2,8110f4a0 <vQCmdFEEinWaitingSync+0x200>

		switch (uiCmdFEEL.ucByte[2]) {
8110f2e4:	e0bffd83 	ldbu	r2,-10(fp)
8110f2e8:	10803fcc 	andi	r2,r2,255
8110f2ec:	10c02860 	cmpeqi	r3,r2,161
8110f2f0:	18001a1e 	bne	r3,zero,8110f35c <vQCmdFEEinWaitingSync+0xbc>
8110f2f4:	10c02888 	cmpgei	r3,r2,162
8110f2f8:	18000c1e 	bne	r3,zero,8110f32c <vQCmdFEEinWaitingSync+0x8c>
8110f2fc:	10c00120 	cmpeqi	r3,r2,4
8110f300:	18001f1e 	bne	r3,zero,8110f380 <vQCmdFEEinWaitingSync+0xe0>
8110f304:	10c00148 	cmpgei	r3,r2,5
8110f308:	1800031e 	bne	r3,zero,8110f318 <vQCmdFEEinWaitingSync+0x78>
8110f30c:	10800060 	cmpeqi	r2,r2,1
8110f310:	1000121e 	bne	r2,zero,8110f35c <vQCmdFEEinWaitingSync+0xbc>
8110f314:	00005206 	br	8110f460 <vQCmdFEEinWaitingSync+0x1c0>
8110f318:	10c00220 	cmpeqi	r3,r2,8
8110f31c:	1800221e 	bne	r3,zero,8110f3a8 <vQCmdFEEinWaitingSync+0x108>
8110f320:	108023e0 	cmpeqi	r2,r2,143
8110f324:	1000441e 	bne	r2,zero,8110f438 <vQCmdFEEinWaitingSync+0x198>
8110f328:	00004d06 	br	8110f460 <vQCmdFEEinWaitingSync+0x1c0>
8110f32c:	10c03888 	cmpgei	r3,r2,226
8110f330:	1800071e 	bne	r3,zero,8110f350 <vQCmdFEEinWaitingSync+0xb0>
8110f334:	10c03808 	cmpgei	r3,r2,224
8110f338:	1800381e 	bne	r3,zero,8110f41c <vQCmdFEEinWaitingSync+0x17c>
8110f33c:	10c02920 	cmpeqi	r3,r2,164
8110f340:	18000f1e 	bne	r3,zero,8110f380 <vQCmdFEEinWaitingSync+0xe0>
8110f344:	10802a20 	cmpeqi	r2,r2,168
8110f348:	1000171e 	bne	r2,zero,8110f3a8 <vQCmdFEEinWaitingSync+0x108>
8110f34c:	00004406 	br	8110f460 <vQCmdFEEinWaitingSync+0x1c0>
8110f350:	10803c20 	cmpeqi	r2,r2,240
8110f354:	10001e1e 	bne	r2,zero,8110f3d0 <vQCmdFEEinWaitingSync+0x130>
8110f358:	00004106 	br	8110f460 <vQCmdFEEinWaitingSync+0x1c0>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f35c:	e0bffe17 	ldw	r2,-8(fp)
8110f360:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f364:	e0bffe17 	ldw	r2,-8(fp)
8110f368:	00c00144 	movi	r3,5
8110f36c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f370:	e0bffe17 	ldw	r2,-8(fp)
8110f374:	00c00144 	movi	r3,5
8110f378:	10c02d15 	stw	r3,180(r2)
				break;
8110f37c:	00004806 	br	8110f4a0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f380:	e0bffe17 	ldw	r2,-8(fp)
8110f384:	00c00044 	movi	r3,1
8110f388:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f38c:	e0bffe17 	ldw	r2,-8(fp)
8110f390:	00c00304 	movi	r3,12
8110f394:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f398:	e0bffe17 	ldw	r2,-8(fp)
8110f39c:	00c00184 	movi	r3,6
8110f3a0:	10c02d15 	stw	r3,180(r2)
				break;
8110f3a4:	00003e06 	br	8110f4a0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f3a8:	e0bffe17 	ldw	r2,-8(fp)
8110f3ac:	00c00044 	movi	r3,1
8110f3b0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f3b4:	e0bffe17 	ldw	r2,-8(fp)
8110f3b8:	00c00284 	movi	r3,10
8110f3bc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f3c0:	e0bffe17 	ldw	r2,-8(fp)
8110f3c4:	00c00304 	movi	r3,12
8110f3c8:	10c02d15 	stw	r3,180(r2)
				break;
8110f3cc:	00003406 	br	8110f4a0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110f3d0:	00a045f4 	movhi	r2,33047
8110f3d4:	10a00404 	addi	r2,r2,-32752
8110f3d8:	10800e8b 	ldhu	r2,58(r2)
8110f3dc:	10bfffcc 	andi	r2,r2,65535
8110f3e0:	108000e8 	cmpgeui	r2,r2,3
8110f3e4:	1000091e 	bne	r2,zero,8110f40c <vQCmdFEEinWaitingSync+0x16c>
					fprintf(fp,"\nNFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110f3e8:	d0e06217 	ldw	r3,-32376(gp)
8110f3ec:	e0bffe17 	ldw	r2,-8(fp)
8110f3f0:	10800003 	ldbu	r2,0(r2)
8110f3f4:	10803fcc 	andi	r2,r2,255
8110f3f8:	100d883a 	mov	r6,r2
8110f3fc:	01604574 	movhi	r5,33045
8110f400:	29772904 	addi	r5,r5,-9052
8110f404:	1809883a 	mov	r4,r3
8110f408:	11229940 	call	81122994 <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110f40c:	e17fff17 	ldw	r5,-4(fp)
8110f410:	e13ffe17 	ldw	r4,-8(fp)
8110f414:	11108480 	call	81110848 <vQCmdFeeRMAPWaitingSync>
				break;
8110f418:	00002106 	br	8110f4a0 <vQCmdFEEinWaitingSync+0x200>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f41c:	e0bffe17 	ldw	r2,-8(fp)
8110f420:	10c02d17 	ldw	r3,180(r2)
8110f424:	e0bffe17 	ldw	r2,-8(fp)
8110f428:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f42c:	e0bffe17 	ldw	r2,-8(fp)
8110f430:	10002815 	stw	zero,160(r2)

				break;
8110f434:	00001a06 	br	8110f4a0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f438:	e0bffe17 	ldw	r2,-8(fp)
8110f43c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f440:	e0bffe17 	ldw	r2,-8(fp)
8110f444:	10800003 	ldbu	r2,0(r2)
8110f448:	10803fcc 	andi	r2,r2,255
8110f44c:	100d883a 	mov	r6,r2
8110f450:	000b883a 	mov	r5,zero
8110f454:	01002044 	movi	r4,129
8110f458:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>
				break;
8110f45c:	00001006 	br	8110f4a0 <vQCmdFEEinWaitingSync+0x200>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f460:	00a045f4 	movhi	r2,33047
8110f464:	10a00404 	addi	r2,r2,-32752
8110f468:	10800e8b 	ldhu	r2,58(r2)
8110f46c:	10bfffcc 	andi	r2,r2,65535
8110f470:	108001e8 	cmpgeui	r2,r2,7
8110f474:	1000091e 	bne	r2,zero,8110f49c <vQCmdFEEinWaitingSync+0x1fc>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f478:	d0e06217 	ldw	r3,-32376(gp)
8110f47c:	e0bffe17 	ldw	r2,-8(fp)
8110f480:	10800003 	ldbu	r2,0(r2)
8110f484:	10803fcc 	andi	r2,r2,255
8110f488:	100d883a 	mov	r6,r2
8110f48c:	01604574 	movhi	r5,33045
8110f490:	29773104 	addi	r5,r5,-9020
8110f494:	1809883a 	mov	r4,r3
8110f498:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f49c:	0001883a 	nop
		}
	}
}
8110f4a0:	0001883a 	nop
8110f4a4:	e037883a 	mov	sp,fp
8110f4a8:	dfc00117 	ldw	ra,4(sp)
8110f4ac:	df000017 	ldw	fp,0(sp)
8110f4b0:	dec00204 	addi	sp,sp,8
8110f4b4:	f800283a 	ret

8110f4b8 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110f4b8:	defffb04 	addi	sp,sp,-20
8110f4bc:	de00012e 	bgeu	sp,et,8110f4c4 <vQCmdFEEinConfig+0xc>
8110f4c0:	003b68fa 	trap	3
8110f4c4:	dfc00415 	stw	ra,16(sp)
8110f4c8:	df000315 	stw	fp,12(sp)
8110f4cc:	df000304 	addi	fp,sp,12
8110f4d0:	e13ffe15 	stw	r4,-8(fp)
8110f4d4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f4d8:	e0bfff17 	ldw	r2,-4(fp)
8110f4dc:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f4e0:	e0bffdc3 	ldbu	r2,-9(fp)
8110f4e4:	10c03fcc 	andi	r3,r2,255
8110f4e8:	e0bffe17 	ldw	r2,-8(fp)
8110f4ec:	10800003 	ldbu	r2,0(r2)
8110f4f0:	10803fcc 	andi	r2,r2,255
8110f4f4:	10800444 	addi	r2,r2,17
8110f4f8:	18807a1e 	bne	r3,r2,8110f6e4 <vQCmdFEEinConfig+0x22c>

		switch (uiCmdFEEL.ucByte[2]) {
8110f4fc:	e0bffd83 	ldbu	r2,-10(fp)
8110f500:	10803fcc 	andi	r2,r2,255
8110f504:	10c02860 	cmpeqi	r3,r2,161
8110f508:	18001a1e 	bne	r3,zero,8110f574 <vQCmdFEEinConfig+0xbc>
8110f50c:	10c02888 	cmpgei	r3,r2,162
8110f510:	18000c1e 	bne	r3,zero,8110f544 <vQCmdFEEinConfig+0x8c>
8110f514:	10c00120 	cmpeqi	r3,r2,4
8110f518:	1800261e 	bne	r3,zero,8110f5b4 <vQCmdFEEinConfig+0xfc>
8110f51c:	10c00148 	cmpgei	r3,r2,5
8110f520:	1800031e 	bne	r3,zero,8110f530 <vQCmdFEEinConfig+0x78>
8110f524:	10800060 	cmpeqi	r2,r2,1
8110f528:	1000121e 	bne	r2,zero,8110f574 <vQCmdFEEinConfig+0xbc>
8110f52c:	00005406 	br	8110f680 <vQCmdFEEinConfig+0x1c8>
8110f530:	10c00220 	cmpeqi	r3,r2,8
8110f534:	1800281e 	bne	r3,zero,8110f5d8 <vQCmdFEEinConfig+0x120>
8110f538:	108023e0 	cmpeqi	r2,r2,143
8110f53c:	1000461e 	bne	r2,zero,8110f658 <vQCmdFEEinConfig+0x1a0>
8110f540:	00004f06 	br	8110f680 <vQCmdFEEinConfig+0x1c8>
8110f544:	10c03888 	cmpgei	r3,r2,226
8110f548:	1800071e 	bne	r3,zero,8110f568 <vQCmdFEEinConfig+0xb0>
8110f54c:	10c03808 	cmpgei	r3,r2,224
8110f550:	18005b1e 	bne	r3,zero,8110f6c0 <vQCmdFEEinConfig+0x208>
8110f554:	10c02920 	cmpeqi	r3,r2,164
8110f558:	1800161e 	bne	r3,zero,8110f5b4 <vQCmdFEEinConfig+0xfc>
8110f55c:	10802a20 	cmpeqi	r2,r2,168
8110f560:	10001d1e 	bne	r2,zero,8110f5d8 <vQCmdFEEinConfig+0x120>
8110f564:	00004606 	br	8110f680 <vQCmdFEEinConfig+0x1c8>
8110f568:	10803c20 	cmpeqi	r2,r2,240
8110f56c:	10002a1e 	bne	r2,zero,8110f618 <vQCmdFEEinConfig+0x160>
8110f570:	00004306 	br	8110f680 <vQCmdFEEinConfig+0x1c8>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f574:	00a045f4 	movhi	r2,33047
8110f578:	10a00404 	addi	r2,r2,-32752
8110f57c:	10800e8b 	ldhu	r2,58(r2)
8110f580:	10bfffcc 	andi	r2,r2,65535
8110f584:	10800168 	cmpgeui	r2,r2,5
8110f588:	10004f1e 	bne	r2,zero,8110f6c8 <vQCmdFEEinConfig+0x210>
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110f58c:	d0e06217 	ldw	r3,-32376(gp)
8110f590:	e0bffe17 	ldw	r2,-8(fp)
8110f594:	10800003 	ldbu	r2,0(r2)
8110f598:	10803fcc 	andi	r2,r2,255
8110f59c:	100d883a 	mov	r6,r2
8110f5a0:	01604574 	movhi	r5,33045
8110f5a4:	29774204 	addi	r5,r5,-8952
8110f5a8:	1809883a 	mov	r4,r3
8110f5ac:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f5b0:	00004506 	br	8110f6c8 <vQCmdFEEinConfig+0x210>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f5b4:	e0bffe17 	ldw	r2,-8(fp)
8110f5b8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f5bc:	e0bffe17 	ldw	r2,-8(fp)
8110f5c0:	00c00184 	movi	r3,6
8110f5c4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f5c8:	e0bffe17 	ldw	r2,-8(fp)
8110f5cc:	00c00184 	movi	r3,6
8110f5d0:	10c02d15 	stw	r3,180(r2)
				break;				
8110f5d4:	00004306 	br	8110f6e4 <vQCmdFEEinConfig+0x22c>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f5d8:	00a045f4 	movhi	r2,33047
8110f5dc:	10a00404 	addi	r2,r2,-32752
8110f5e0:	10800e8b 	ldhu	r2,58(r2)
8110f5e4:	10bfffcc 	andi	r2,r2,65535
8110f5e8:	10800168 	cmpgeui	r2,r2,5
8110f5ec:	1000381e 	bne	r2,zero,8110f6d0 <vQCmdFEEinConfig+0x218>
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110f5f0:	d0e06217 	ldw	r3,-32376(gp)
8110f5f4:	e0bffe17 	ldw	r2,-8(fp)
8110f5f8:	10800003 	ldbu	r2,0(r2)
8110f5fc:	10803fcc 	andi	r2,r2,255
8110f600:	100d883a 	mov	r6,r2
8110f604:	01604574 	movhi	r5,33045
8110f608:	29774d04 	addi	r5,r5,-8908
8110f60c:	1809883a 	mov	r4,r3
8110f610:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f614:	00002e06 	br	8110f6d0 <vQCmdFEEinConfig+0x218>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f618:	00a045f4 	movhi	r2,33047
8110f61c:	10a00404 	addi	r2,r2,-32752
8110f620:	10800e8b 	ldhu	r2,58(r2)
8110f624:	10bfffcc 	andi	r2,r2,65535
8110f628:	10800168 	cmpgeui	r2,r2,5
8110f62c:	10002a1e 	bne	r2,zero,8110f6d8 <vQCmdFEEinConfig+0x220>
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
8110f630:	d0e06217 	ldw	r3,-32376(gp)
8110f634:	e0bffe17 	ldw	r2,-8(fp)
8110f638:	10800003 	ldbu	r2,0(r2)
8110f63c:	10803fcc 	andi	r2,r2,255
8110f640:	100d883a 	mov	r6,r2
8110f644:	01604574 	movhi	r5,33045
8110f648:	29775e04 	addi	r5,r5,-8840
8110f64c:	1809883a 	mov	r4,r3
8110f650:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f654:	00002006 	br	8110f6d8 <vQCmdFEEinConfig+0x220>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f658:	e0bffe17 	ldw	r2,-8(fp)
8110f65c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f660:	e0bffe17 	ldw	r2,-8(fp)
8110f664:	10800003 	ldbu	r2,0(r2)
8110f668:	10803fcc 	andi	r2,r2,255
8110f66c:	100d883a 	mov	r6,r2
8110f670:	000b883a 	mov	r5,zero
8110f674:	01002044 	movi	r4,129
8110f678:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>
				break;
8110f67c:	00001906 	br	8110f6e4 <vQCmdFEEinConfig+0x22c>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f680:	00a045f4 	movhi	r2,33047
8110f684:	10a00404 	addi	r2,r2,-32752
8110f688:	10800e8b 	ldhu	r2,58(r2)
8110f68c:	10bfffcc 	andi	r2,r2,65535
8110f690:	108001e8 	cmpgeui	r2,r2,7
8110f694:	1000121e 	bne	r2,zero,8110f6e0 <vQCmdFEEinConfig+0x228>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
8110f698:	d0e06217 	ldw	r3,-32376(gp)
8110f69c:	e0bffe17 	ldw	r2,-8(fp)
8110f6a0:	10800003 	ldbu	r2,0(r2)
8110f6a4:	10803fcc 	andi	r2,r2,255
8110f6a8:	100d883a 	mov	r6,r2
8110f6ac:	01604574 	movhi	r5,33045
8110f6b0:	29776f04 	addi	r5,r5,-8772
8110f6b4:	1809883a 	mov	r4,r3
8110f6b8:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f6bc:	00000806 	br	8110f6e0 <vQCmdFEEinConfig+0x228>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110f6c0:	0001883a 	nop
8110f6c4:	00000706 	br	8110f6e4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6c8:	0001883a 	nop
8110f6cc:	00000506 	br	8110f6e4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6d0:	0001883a 	nop
8110f6d4:	00000306 	br	8110f6e4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6d8:	0001883a 	nop
8110f6dc:	00000106 	br	8110f6e4 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6e0:	0001883a 	nop
		}
	}
}
8110f6e4:	0001883a 	nop
8110f6e8:	e037883a 	mov	sp,fp
8110f6ec:	dfc00117 	ldw	ra,4(sp)
8110f6f0:	df000017 	ldw	fp,0(sp)
8110f6f4:	dec00204 	addi	sp,sp,8
8110f6f8:	f800283a 	ret

8110f6fc <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110f6fc:	defffb04 	addi	sp,sp,-20
8110f700:	de00012e 	bgeu	sp,et,8110f708 <vQCmdFEEinStandBy+0xc>
8110f704:	003b68fa 	trap	3
8110f708:	dfc00415 	stw	ra,16(sp)
8110f70c:	df000315 	stw	fp,12(sp)
8110f710:	df000304 	addi	fp,sp,12
8110f714:	e13ffe15 	stw	r4,-8(fp)
8110f718:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f71c:	e0bfff17 	ldw	r2,-4(fp)
8110f720:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f724:	e0bffdc3 	ldbu	r2,-9(fp)
8110f728:	10c03fcc 	andi	r3,r2,255
8110f72c:	e0bffe17 	ldw	r2,-8(fp)
8110f730:	10800003 	ldbu	r2,0(r2)
8110f734:	10803fcc 	andi	r2,r2,255
8110f738:	10800444 	addi	r2,r2,17
8110f73c:	1880801e 	bne	r3,r2,8110f940 <vQCmdFEEinStandBy+0x244>

		switch (uiCmdFEEL.ucByte[2]) {
8110f740:	e0bffd83 	ldbu	r2,-10(fp)
8110f744:	10803fcc 	andi	r2,r2,255
8110f748:	10c02860 	cmpeqi	r3,r2,161
8110f74c:	18001a1e 	bne	r3,zero,8110f7b8 <vQCmdFEEinStandBy+0xbc>
8110f750:	10c02888 	cmpgei	r3,r2,162
8110f754:	18000c1e 	bne	r3,zero,8110f788 <vQCmdFEEinStandBy+0x8c>
8110f758:	10c00120 	cmpeqi	r3,r2,4
8110f75c:	18001f1e 	bne	r3,zero,8110f7dc <vQCmdFEEinStandBy+0xe0>
8110f760:	10c00148 	cmpgei	r3,r2,5
8110f764:	1800031e 	bne	r3,zero,8110f774 <vQCmdFEEinStandBy+0x78>
8110f768:	10800060 	cmpeqi	r2,r2,1
8110f76c:	1000121e 	bne	r2,zero,8110f7b8 <vQCmdFEEinStandBy+0xbc>
8110f770:	00005c06 	br	8110f8e4 <vQCmdFEEinStandBy+0x1e8>
8110f774:	10c00220 	cmpeqi	r3,r2,8
8110f778:	1800281e 	bne	r3,zero,8110f81c <vQCmdFEEinStandBy+0x120>
8110f77c:	108023e0 	cmpeqi	r2,r2,143
8110f780:	10004e1e 	bne	r2,zero,8110f8bc <vQCmdFEEinStandBy+0x1c0>
8110f784:	00005706 	br	8110f8e4 <vQCmdFEEinStandBy+0x1e8>
8110f788:	10c03888 	cmpgei	r3,r2,226
8110f78c:	1800071e 	bne	r3,zero,8110f7ac <vQCmdFEEinStandBy+0xb0>
8110f790:	10c03808 	cmpgei	r3,r2,224
8110f794:	18003e1e 	bne	r3,zero,8110f890 <vQCmdFEEinStandBy+0x194>
8110f798:	10c02920 	cmpeqi	r3,r2,164
8110f79c:	18000f1e 	bne	r3,zero,8110f7dc <vQCmdFEEinStandBy+0xe0>
8110f7a0:	10802a20 	cmpeqi	r2,r2,168
8110f7a4:	10001d1e 	bne	r2,zero,8110f81c <vQCmdFEEinStandBy+0x120>
8110f7a8:	00004e06 	br	8110f8e4 <vQCmdFEEinStandBy+0x1e8>
8110f7ac:	10803c20 	cmpeqi	r2,r2,240
8110f7b0:	1000241e 	bne	r2,zero,8110f844 <vQCmdFEEinStandBy+0x148>
8110f7b4:	00004b06 	br	8110f8e4 <vQCmdFEEinStandBy+0x1e8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f7b8:	e0bffe17 	ldw	r2,-8(fp)
8110f7bc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f7c0:	e0bffe17 	ldw	r2,-8(fp)
8110f7c4:	00c00144 	movi	r3,5
8110f7c8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f7cc:	e0bffe17 	ldw	r2,-8(fp)
8110f7d0:	00c00144 	movi	r3,5
8110f7d4:	10c02d15 	stw	r3,180(r2)
				break;				
8110f7d8:	00005906 	br	8110f940 <vQCmdFEEinStandBy+0x244>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f7dc:	00a045f4 	movhi	r2,33047
8110f7e0:	10a00404 	addi	r2,r2,-32752
8110f7e4:	10800e8b 	ldhu	r2,58(r2)
8110f7e8:	10bfffcc 	andi	r2,r2,65535
8110f7ec:	10800168 	cmpgeui	r2,r2,5
8110f7f0:	10004c1e 	bne	r2,zero,8110f924 <vQCmdFEEinStandBy+0x228>
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
8110f7f4:	d0e06217 	ldw	r3,-32376(gp)
8110f7f8:	e0bffe17 	ldw	r2,-8(fp)
8110f7fc:	10800003 	ldbu	r2,0(r2)
8110f800:	10803fcc 	andi	r2,r2,255
8110f804:	100d883a 	mov	r6,r2
8110f808:	01604574 	movhi	r5,33045
8110f80c:	29777e04 	addi	r5,r5,-8712
8110f810:	1809883a 	mov	r4,r3
8110f814:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f818:	00004206 	br	8110f924 <vQCmdFEEinStandBy+0x228>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f81c:	e0bffe17 	ldw	r2,-8(fp)
8110f820:	00c00044 	movi	r3,1
8110f824:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f828:	e0bffe17 	ldw	r2,-8(fp)
8110f82c:	00c00284 	movi	r3,10
8110f830:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f834:	e0bffe17 	ldw	r2,-8(fp)
8110f838:	00c00304 	movi	r3,12
8110f83c:	10c02d15 	stw	r3,180(r2)
				break;
8110f840:	00003f06 	br	8110f940 <vQCmdFEEinStandBy+0x244>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110f844:	e17fff17 	ldw	r5,-4(fp)
8110f848:	e13ffe17 	ldw	r4,-8(fp)
8110f84c:	110fbe00 	call	8110fbe0 <vQCmdFeeRMAPinStandBy>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f850:	00a045f4 	movhi	r2,33047
8110f854:	10a00404 	addi	r2,r2,-32752
8110f858:	10800e8b 	ldhu	r2,58(r2)
8110f85c:	10bfffcc 	andi	r2,r2,65535
8110f860:	10800168 	cmpgeui	r2,r2,5
8110f864:	1000311e 	bne	r2,zero,8110f92c <vQCmdFEEinStandBy+0x230>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110f868:	d0e06217 	ldw	r3,-32376(gp)
8110f86c:	e0bffe17 	ldw	r2,-8(fp)
8110f870:	10800003 	ldbu	r2,0(r2)
8110f874:	10803fcc 	andi	r2,r2,255
8110f878:	100d883a 	mov	r6,r2
8110f87c:	01604574 	movhi	r5,33045
8110f880:	29778804 	addi	r5,r5,-8672
8110f884:	1809883a 	mov	r4,r3
8110f888:	11229940 	call	81122994 <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f88c:	00002706 	br	8110f92c <vQCmdFEEinStandBy+0x230>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f890:	e0bffe17 	ldw	r2,-8(fp)
8110f894:	10802c17 	ldw	r2,176(r2)
8110f898:	10800318 	cmpnei	r2,r2,12
8110f89c:	1000251e 	bne	r2,zero,8110f934 <vQCmdFEEinStandBy+0x238>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f8a0:	e0bffe17 	ldw	r2,-8(fp)
8110f8a4:	10c02d17 	ldw	r3,180(r2)
8110f8a8:	e0bffe17 	ldw	r2,-8(fp)
8110f8ac:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f8b0:	e0bffe17 	ldw	r2,-8(fp)
8110f8b4:	10002815 	stw	zero,160(r2)
				}
				break;
8110f8b8:	00001e06 	br	8110f934 <vQCmdFEEinStandBy+0x238>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f8bc:	e0bffe17 	ldw	r2,-8(fp)
8110f8c0:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f8c4:	e0bffe17 	ldw	r2,-8(fp)
8110f8c8:	10800003 	ldbu	r2,0(r2)
8110f8cc:	10803fcc 	andi	r2,r2,255
8110f8d0:	100d883a 	mov	r6,r2
8110f8d4:	000b883a 	mov	r5,zero
8110f8d8:	01002044 	movi	r4,129
8110f8dc:	11110e00 	call	811110e0 <bSendGiveBackNFeeCtrl>
				break;
8110f8e0:	00001706 	br	8110f940 <vQCmdFEEinStandBy+0x244>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f8e4:	00a045f4 	movhi	r2,33047
8110f8e8:	10a00404 	addi	r2,r2,-32752
8110f8ec:	10800e8b 	ldhu	r2,58(r2)
8110f8f0:	10bfffcc 	andi	r2,r2,65535
8110f8f4:	108001e8 	cmpgeui	r2,r2,7
8110f8f8:	1000101e 	bne	r2,zero,8110f93c <vQCmdFEEinStandBy+0x240>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f8fc:	d0e06217 	ldw	r3,-32376(gp)
8110f900:	e0bffe17 	ldw	r2,-8(fp)
8110f904:	10800003 	ldbu	r2,0(r2)
8110f908:	10803fcc 	andi	r2,r2,255
8110f90c:	100d883a 	mov	r6,r2
8110f910:	01604574 	movhi	r5,33045
8110f914:	29773104 	addi	r5,r5,-9020
8110f918:	1809883a 	mov	r4,r3
8110f91c:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110f920:	00000606 	br	8110f93c <vQCmdFEEinStandBy+0x240>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f924:	0001883a 	nop
8110f928:	00000506 	br	8110f940 <vQCmdFEEinStandBy+0x244>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f92c:	0001883a 	nop
8110f930:	00000306 	br	8110f940 <vQCmdFEEinStandBy+0x244>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110f934:	0001883a 	nop
8110f938:	00000106 	br	8110f940 <vQCmdFEEinStandBy+0x244>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f93c:	0001883a 	nop
		}
	}
}
8110f940:	0001883a 	nop
8110f944:	e037883a 	mov	sp,fp
8110f948:	dfc00117 	ldw	ra,4(sp)
8110f94c:	df000017 	ldw	fp,0(sp)
8110f950:	dec00204 	addi	sp,sp,8
8110f954:	f800283a 	ret

8110f958 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110f958:	defffb04 	addi	sp,sp,-20
8110f95c:	de00012e 	bgeu	sp,et,8110f964 <vQCmdFEEinFullPattern+0xc>
8110f960:	003b68fa 	trap	3
8110f964:	dfc00415 	stw	ra,16(sp)
8110f968:	df000315 	stw	fp,12(sp)
8110f96c:	df000304 	addi	fp,sp,12
8110f970:	e13ffe15 	stw	r4,-8(fp)
8110f974:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f978:	e0bfff17 	ldw	r2,-4(fp)
8110f97c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f980:	e0bffdc3 	ldbu	r2,-9(fp)
8110f984:	10c03fcc 	andi	r3,r2,255
8110f988:	e0bffe17 	ldw	r2,-8(fp)
8110f98c:	10800003 	ldbu	r2,0(r2)
8110f990:	10803fcc 	andi	r2,r2,255
8110f994:	10800444 	addi	r2,r2,17
8110f998:	18808b1e 	bne	r3,r2,8110fbc8 <vQCmdFEEinFullPattern+0x270>

		switch (uiCmdFEEL.ucByte[2]) {
8110f99c:	e0bffd83 	ldbu	r2,-10(fp)
8110f9a0:	10803fcc 	andi	r2,r2,255
8110f9a4:	10c02860 	cmpeqi	r3,r2,161
8110f9a8:	1800181e 	bne	r3,zero,8110fa0c <vQCmdFEEinFullPattern+0xb4>
8110f9ac:	10c02888 	cmpgei	r3,r2,162
8110f9b0:	18000c1e 	bne	r3,zero,8110f9e4 <vQCmdFEEinFullPattern+0x8c>
8110f9b4:	10c000a0 	cmpeqi	r3,r2,2
8110f9b8:	18007c1e 	bne	r3,zero,8110fbac <vQCmdFEEinFullPattern+0x254>
8110f9bc:	10c000c8 	cmpgei	r3,r2,3
8110f9c0:	1800031e 	bne	r3,zero,8110f9d0 <vQCmdFEEinFullPattern+0x78>
8110f9c4:	10800060 	cmpeqi	r2,r2,1
8110f9c8:	1000101e 	bne	r2,zero,8110fa0c <vQCmdFEEinFullPattern+0xb4>
8110f9cc:	00006706 	br	8110fb6c <vQCmdFEEinFullPattern+0x214>
8110f9d0:	10c00120 	cmpeqi	r3,r2,4
8110f9d4:	1800161e 	bne	r3,zero,8110fa30 <vQCmdFEEinFullPattern+0xd8>
8110f9d8:	10800220 	cmpeqi	r2,r2,8
8110f9dc:	1000351e 	bne	r2,zero,8110fab4 <vQCmdFEEinFullPattern+0x15c>
8110f9e0:	00006206 	br	8110fb6c <vQCmdFEEinFullPattern+0x214>
8110f9e4:	10c03888 	cmpgei	r3,r2,226
8110f9e8:	1800051e 	bne	r3,zero,8110fa00 <vQCmdFEEinFullPattern+0xa8>
8110f9ec:	10c03808 	cmpgei	r3,r2,224
8110f9f0:	1800531e 	bne	r3,zero,8110fb40 <vQCmdFEEinFullPattern+0x1e8>
8110f9f4:	10802920 	cmpeqi	r2,r2,164
8110f9f8:	1000251e 	bne	r2,zero,8110fa90 <vQCmdFEEinFullPattern+0x138>
8110f9fc:	00005b06 	br	8110fb6c <vQCmdFEEinFullPattern+0x214>
8110fa00:	10803c20 	cmpeqi	r2,r2,240
8110fa04:	10003b1e 	bne	r2,zero,8110faf4 <vQCmdFEEinFullPattern+0x19c>
8110fa08:	00005806 	br	8110fb6c <vQCmdFEEinFullPattern+0x214>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fa0c:	e0bffe17 	ldw	r2,-8(fp)
8110fa10:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110fa14:	e0bffe17 	ldw	r2,-8(fp)
8110fa18:	00c00144 	movi	r3,5
8110fa1c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110fa20:	e0bffe17 	ldw	r2,-8(fp)
8110fa24:	00c00144 	movi	r3,5
8110fa28:	10c02d15 	stw	r3,180(r2)
				break;				
8110fa2c:	00006606 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110fa30:	e0bffe17 	ldw	r2,-8(fp)
8110fa34:	10802c17 	ldw	r2,176(r2)
8110fa38:	10800298 	cmpnei	r2,r2,10
8110fa3c:	10000a1e 	bne	r2,zero,8110fa68 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110fa40:	e0bffe17 	ldw	r2,-8(fp)
8110fa44:	00c00044 	movi	r3,1
8110fa48:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110fa4c:	e0bffe17 	ldw	r2,-8(fp)
8110fa50:	00c00304 	movi	r3,12
8110fa54:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fa58:	e0bffe17 	ldw	r2,-8(fp)
8110fa5c:	00c00184 	movi	r3,6
8110fa60:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110fa64:	00005806 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110fa68:	e0bffe17 	ldw	r2,-8(fp)
8110fa6c:	00c00044 	movi	r3,1
8110fa70:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110fa74:	e0bffe17 	ldw	r2,-8(fp)
8110fa78:	00c00104 	movi	r3,4
8110fa7c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fa80:	e0bffe17 	ldw	r2,-8(fp)
8110fa84:	00c00184 	movi	r3,6
8110fa88:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110fa8c:	00004e06 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fa90:	e0bffe17 	ldw	r2,-8(fp)
8110fa94:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110fa98:	e0bffe17 	ldw	r2,-8(fp)
8110fa9c:	00c00184 	movi	r3,6
8110faa0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110faa4:	e0bffe17 	ldw	r2,-8(fp)
8110faa8:	00c00184 	movi	r3,6
8110faac:	10c02d15 	stw	r3,180(r2)
				break;				
8110fab0:	00004506 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fab4:	00a045f4 	movhi	r2,33047
8110fab8:	10a00404 	addi	r2,r2,-32752
8110fabc:	10800e8b 	ldhu	r2,58(r2)
8110fac0:	10bfffcc 	andi	r2,r2,65535
8110fac4:	10800168 	cmpgeui	r2,r2,5
8110fac8:	10003a1e 	bne	r2,zero,8110fbb4 <vQCmdFEEinFullPattern+0x25c>
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110facc:	d0e06217 	ldw	r3,-32376(gp)
8110fad0:	e0bffe17 	ldw	r2,-8(fp)
8110fad4:	10800003 	ldbu	r2,0(r2)
8110fad8:	10803fcc 	andi	r2,r2,255
8110fadc:	100d883a 	mov	r6,r2
8110fae0:	01604574 	movhi	r5,33045
8110fae4:	29779004 	addi	r5,r5,-8640
8110fae8:	1809883a 	mov	r4,r3
8110faec:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110faf0:	00003006 	br	8110fbb4 <vQCmdFEEinFullPattern+0x25c>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110faf4:	00a045f4 	movhi	r2,33047
8110faf8:	10a00404 	addi	r2,r2,-32752
8110fafc:	10800e8b 	ldhu	r2,58(r2)
8110fb00:	10bfffcc 	andi	r2,r2,65535
8110fb04:	10800168 	cmpgeui	r2,r2,5
8110fb08:	1000091e 	bne	r2,zero,8110fb30 <vQCmdFEEinFullPattern+0x1d8>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110fb0c:	d0e06217 	ldw	r3,-32376(gp)
8110fb10:	e0bffe17 	ldw	r2,-8(fp)
8110fb14:	10800003 	ldbu	r2,0(r2)
8110fb18:	10803fcc 	andi	r2,r2,255
8110fb1c:	100d883a 	mov	r6,r2
8110fb20:	01604574 	movhi	r5,33045
8110fb24:	29778804 	addi	r5,r5,-8672
8110fb28:	1809883a 	mov	r4,r3
8110fb2c:	11229940 	call	81122994 <fprintf>
				}
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110fb30:	e17fff17 	ldw	r5,-4(fp)
8110fb34:	e13ffe17 	ldw	r4,-8(fp)
8110fb38:	11102640 	call	81110264 <vQCmdFeeRMAPinFullPattern>

				break;
8110fb3c:	00002206 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110fb40:	e0bffe17 	ldw	r2,-8(fp)
8110fb44:	10802c17 	ldw	r2,176(r2)
8110fb48:	10800318 	cmpnei	r2,r2,12
8110fb4c:	10001b1e 	bne	r2,zero,8110fbbc <vQCmdFEEinFullPattern+0x264>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110fb50:	e0bffe17 	ldw	r2,-8(fp)
8110fb54:	10c02d17 	ldw	r3,180(r2)
8110fb58:	e0bffe17 	ldw	r2,-8(fp)
8110fb5c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110fb60:	e0bffe17 	ldw	r2,-8(fp)
8110fb64:	10002815 	stw	zero,160(r2)
				}

				break;
8110fb68:	00001406 	br	8110fbbc <vQCmdFEEinFullPattern+0x264>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fb6c:	00a045f4 	movhi	r2,33047
8110fb70:	10a00404 	addi	r2,r2,-32752
8110fb74:	10800e8b 	ldhu	r2,58(r2)
8110fb78:	10bfffcc 	andi	r2,r2,65535
8110fb7c:	108001e8 	cmpgeui	r2,r2,7
8110fb80:	1000101e 	bne	r2,zero,8110fbc4 <vQCmdFEEinFullPattern+0x26c>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110fb84:	d0e06217 	ldw	r3,-32376(gp)
8110fb88:	e0bffe17 	ldw	r2,-8(fp)
8110fb8c:	10800003 	ldbu	r2,0(r2)
8110fb90:	10803fcc 	andi	r2,r2,255
8110fb94:	100d883a 	mov	r6,r2
8110fb98:	01604574 	movhi	r5,33045
8110fb9c:	29779e04 	addi	r5,r5,-8584
8110fba0:	1809883a 	mov	r4,r3
8110fba4:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
8110fba8:	00000606 	br	8110fbc4 <vQCmdFEEinFullPattern+0x26c>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110fbac:	0001883a 	nop
8110fbb0:	00000506 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fbb4:	0001883a 	nop
8110fbb8:	00000306 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110fbbc:	0001883a 	nop
8110fbc0:	00000106 	br	8110fbc8 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fbc4:	0001883a 	nop
		}
	}
}
8110fbc8:	0001883a 	nop
8110fbcc:	e037883a 	mov	sp,fp
8110fbd0:	dfc00117 	ldw	ra,4(sp)
8110fbd4:	df000017 	ldw	fp,0(sp)
8110fbd8:	dec00204 	addi	sp,sp,8
8110fbdc:	f800283a 	ret

8110fbe0 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110fbe0:	defff704 	addi	sp,sp,-36
8110fbe4:	de00012e 	bgeu	sp,et,8110fbec <vQCmdFeeRMAPinStandBy+0xc>
8110fbe8:	003b68fa 	trap	3
8110fbec:	dfc00815 	stw	ra,32(sp)
8110fbf0:	df000715 	stw	fp,28(sp)
8110fbf4:	df000704 	addi	fp,sp,28
8110fbf8:	e13ffe15 	stw	r4,-8(fp)
8110fbfc:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fc00:	00a045f4 	movhi	r2,33047
8110fc04:	10a00404 	addi	r2,r2,-32752
8110fc08:	10800e8b 	ldhu	r2,58(r2)
8110fc0c:	10bfffcc 	andi	r2,r2,65535
8110fc10:	108000e8 	cmpgeui	r2,r2,3
8110fc14:	1000091e 	bne	r2,zero,8110fc3c <vQCmdFeeRMAPinStandBy+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110fc18:	d0e06217 	ldw	r3,-32376(gp)
8110fc1c:	e0bffe17 	ldw	r2,-8(fp)
8110fc20:	10800003 	ldbu	r2,0(r2)
8110fc24:	10803fcc 	andi	r2,r2,255
8110fc28:	100d883a 	mov	r6,r2
8110fc2c:	01604574 	movhi	r5,33045
8110fc30:	2977af04 	addi	r5,r5,-8516
8110fc34:	1809883a 	mov	r4,r3
8110fc38:	11229940 	call	81122994 <fprintf>
	}
#endif


	uiCmdFEEL.ulWord = cmd;
8110fc3c:	e0bfff17 	ldw	r2,-4(fp)
8110fc40:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110fc44:	e0bffd43 	ldbu	r2,-11(fp)
8110fc48:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110fc4c:	e0bffe17 	ldw	r2,-8(fp)
8110fc50:	10804317 	ldw	r2,268(r2)
8110fc54:	e0fff903 	ldbu	r3,-28(fp)
8110fc58:	180b883a 	mov	r5,r3
8110fc5c:	1009883a 	mov	r4,r2
8110fc60:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110fc64:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110fc68:	e0bff903 	ldbu	r2,-28(fp)
8110fc6c:	10bff004 	addi	r2,r2,-64
8110fc70:	10c003a8 	cmpgeui	r3,r2,14
8110fc74:	18015e1e 	bne	r3,zero,811101f0 <vQCmdFeeRMAPinStandBy+0x610>
8110fc78:	100690ba 	slli	r3,r2,2
8110fc7c:	00a04474 	movhi	r2,33041
8110fc80:	10bf2404 	addi	r2,r2,-880
8110fc84:	1885883a 	add	r2,r3,r2
8110fc88:	10800017 	ldw	r2,0(r2)
8110fc8c:	1000683a 	jmp	r2
8110fc90:	8110fcc8 	cmpgei	r4,r16,17395
8110fc94:	81110228 	cmpgeui	r4,r16,17416
8110fc98:	8110fdb4 	orhi	r4,r16,17398
8110fc9c:	8110fff0 	cmpltui	r4,r16,17407
8110fca0:	8110fff0 	cmpltui	r4,r16,17407
8110fca4:	8110fff0 	cmpltui	r4,r16,17407
8110fca8:	8110fff0 	cmpltui	r4,r16,17407
8110fcac:	8110fff0 	cmpltui	r4,r16,17407
8110fcb0:	8110fff0 	cmpltui	r4,r16,17407
8110fcb4:	8110fff0 	cmpltui	r4,r16,17407
8110fcb8:	8110fff0 	cmpltui	r4,r16,17407
8110fcbc:	8110fff0 	cmpltui	r4,r16,17407
8110fcc0:	81110028 	cmpgeui	r4,r16,17408
8110fcc4:	81110168 	cmpgeui	r4,r16,17413
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110fcc8:	e0fffa17 	ldw	r3,-24(fp)
8110fccc:	00800434 	movhi	r2,16
8110fcd0:	10bffc04 	addi	r2,r2,-16
8110fcd4:	1884703a 	and	r2,r3,r2
8110fcd8:	1004d13a 	srli	r2,r2,4
8110fcdc:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110fce0:	e0bffa17 	ldw	r2,-24(fp)
8110fce4:	1004d53a 	srli	r2,r2,20
8110fce8:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fcec:	e0bffb17 	ldw	r2,-20(fp)
8110fcf0:	1007883a 	mov	r3,r2
8110fcf4:	e0bffe17 	ldw	r2,-8(fp)
8110fcf8:	1080300b 	ldhu	r2,192(r2)
8110fcfc:	1885c83a 	sub	r2,r3,r2
8110fd00:	1007883a 	mov	r3,r2
8110fd04:	e0bffe17 	ldw	r2,-8(fp)
8110fd08:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8110fd0c:	e0bffc17 	ldw	r2,-16(fp)
8110fd10:	1009883a 	mov	r4,r2
8110fd14:	e0bffe17 	ldw	r2,-8(fp)
8110fd18:	10c02f8b 	ldhu	r3,190(r2)
8110fd1c:	e0bffe17 	ldw	r2,-8(fp)
8110fd20:	10802f0b 	ldhu	r2,188(r2)
8110fd24:	1885883a 	add	r2,r3,r2
8110fd28:	2085c83a 	sub	r2,r4,r2
8110fd2c:	1007883a 	mov	r3,r2
8110fd30:	e0bffe17 	ldw	r2,-8(fp)
8110fd34:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110fd38:	e13ffe17 	ldw	r4,-8(fp)
8110fd3c:	111ef600 	call	8111ef60 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fd40:	e0bffe17 	ldw	r2,-8(fp)
8110fd44:	10803304 	addi	r2,r2,204
8110fd48:	1009883a 	mov	r4,r2
8110fd4c:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8110fd50:	e0bffe17 	ldw	r2,-8(fp)
8110fd54:	10c0300b 	ldhu	r3,192(r2)
8110fd58:	e0bffe17 	ldw	r2,-8(fp)
8110fd5c:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8110fd60:	e0bffc17 	ldw	r2,-16(fp)
8110fd64:	1007883a 	mov	r3,r2
8110fd68:	e0bffe17 	ldw	r2,-8(fp)
8110fd6c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8110fd70:	e0bffb17 	ldw	r2,-20(fp)
8110fd74:	1007883a 	mov	r3,r2
8110fd78:	e0bffe17 	ldw	r2,-8(fp)
8110fd7c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fd80:	e0bffb17 	ldw	r2,-20(fp)
8110fd84:	1007883a 	mov	r3,r2
8110fd88:	e0bffe17 	ldw	r2,-8(fp)
8110fd8c:	1080300b 	ldhu	r2,192(r2)
8110fd90:	1885c83a 	sub	r2,r3,r2
8110fd94:	1007883a 	mov	r3,r2
8110fd98:	e0bffe17 	ldw	r2,-8(fp)
8110fd9c:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fda0:	e0bffe17 	ldw	r2,-8(fp)
8110fda4:	10803304 	addi	r2,r2,204
8110fda8:	1009883a 	mov	r4,r2
8110fdac:	11048400 	call	81104840 <bDpktSetPacketConfig>

			break;
8110fdb0:	00012606 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110fdb4:	e0fffa17 	ldw	r3,-24(fp)
8110fdb8:	00800434 	movhi	r2,16
8110fdbc:	10bffc04 	addi	r2,r2,-16
8110fdc0:	1884703a 	and	r2,r3,r2
8110fdc4:	1004d13a 	srli	r2,r2,4
8110fdc8:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fdcc:	e0bffe17 	ldw	r2,-8(fp)
8110fdd0:	10803304 	addi	r2,r2,204
8110fdd4:	1009883a 	mov	r4,r2
8110fdd8:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110fddc:	e0bffb17 	ldw	r2,-20(fp)
8110fde0:	1007883a 	mov	r3,r2
8110fde4:	e0bffe17 	ldw	r2,-8(fp)
8110fde8:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fdec:	e0bffe17 	ldw	r2,-8(fp)
8110fdf0:	10803304 	addi	r2,r2,204
8110fdf4:	1009883a 	mov	r4,r2
8110fdf8:	11048400 	call	81104840 <bDpktSetPacketConfig>

			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fdfc:	00a045f4 	movhi	r2,33047
8110fe00:	10a00404 	addi	r2,r2,-32752
8110fe04:	10800e8b 	ldhu	r2,58(r2)
8110fe08:	10bfffcc 	andi	r2,r2,65535
8110fe0c:	108000e8 	cmpgeui	r2,r2,3
8110fe10:	1000061e 	bne	r2,zero,8110fe2c <vQCmdFeeRMAPinStandBy+0x24c>
				fprintf(fp,"- Pckt Length: %lu\n", ucValueMasked);
8110fe14:	d0a06217 	ldw	r2,-32376(gp)
8110fe18:	e1bffb17 	ldw	r6,-20(fp)
8110fe1c:	01604574 	movhi	r5,33045
8110fe20:	2977bb04 	addi	r5,r5,-8468
8110fe24:	1009883a 	mov	r4,r2
8110fe28:	11229940 	call	81122994 <fprintf>
			}
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fe2c:	e0bffa17 	ldw	r2,-24(fp)
8110fe30:	1080030c 	andi	r2,r2,12
8110fe34:	1004d0ba 	srli	r2,r2,2
8110fe38:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110fe3c:	e0bffc17 	ldw	r2,-16(fp)
8110fe40:	10c000a0 	cmpeqi	r3,r2,2
8110fe44:	1800141e 	bne	r3,zero,8110fe98 <vQCmdFeeRMAPinStandBy+0x2b8>
8110fe48:	10c000e0 	cmpeqi	r3,r2,3
8110fe4c:	1800231e 	bne	r3,zero,8110fedc <vQCmdFeeRMAPinStandBy+0x2fc>
8110fe50:	10800060 	cmpeqi	r2,r2,1
8110fe54:	10003026 	beq	r2,zero,8110ff18 <vQCmdFeeRMAPinStandBy+0x338>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110fe58:	e0bffe17 	ldw	r2,-8(fp)
8110fe5c:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fe60:	00a045f4 	movhi	r2,33047
8110fe64:	10a00404 	addi	r2,r2,-32752
8110fe68:	10800e8b 	ldhu	r2,58(r2)
8110fe6c:	10bfffcc 	andi	r2,r2,65535
8110fe70:	108000e8 	cmpgeui	r2,r2,3
8110fe74:	1000461e 	bne	r2,zero,8110ff90 <vQCmdFeeRMAPinStandBy+0x3b0>
						fprintf(fp," - Left side\n");
8110fe78:	d0a06217 	ldw	r2,-32376(gp)
8110fe7c:	100f883a 	mov	r7,r2
8110fe80:	01800344 	movi	r6,13
8110fe84:	01400044 	movi	r5,1
8110fe88:	01204574 	movhi	r4,33045
8110fe8c:	2137c004 	addi	r4,r4,-8448
8110fe90:	11230300 	call	81123030 <fwrite>
					}
					#endif
					break;
8110fe94:	00003e06 	br	8110ff90 <vQCmdFeeRMAPinStandBy+0x3b0>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110fe98:	e0bffe17 	ldw	r2,-8(fp)
8110fe9c:	00c00044 	movi	r3,1
8110fea0:	10c02e15 	stw	r3,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fea4:	00a045f4 	movhi	r2,33047
8110fea8:	10a00404 	addi	r2,r2,-32752
8110feac:	10800e8b 	ldhu	r2,58(r2)
8110feb0:	10bfffcc 	andi	r2,r2,65535
8110feb4:	108000e8 	cmpgeui	r2,r2,3
8110feb8:	1000371e 	bne	r2,zero,8110ff98 <vQCmdFeeRMAPinStandBy+0x3b8>
						fprintf(fp," - Right side\n");
8110febc:	d0a06217 	ldw	r2,-32376(gp)
8110fec0:	100f883a 	mov	r7,r2
8110fec4:	01800384 	movi	r6,14
8110fec8:	01400044 	movi	r5,1
8110fecc:	01204574 	movhi	r4,33045
8110fed0:	2137c404 	addi	r4,r4,-8432
8110fed4:	11230300 	call	81123030 <fwrite>
					}
					#endif
					break;
8110fed8:	00002f06 	br	8110ff98 <vQCmdFeeRMAPinStandBy+0x3b8>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110fedc:	e0bffe17 	ldw	r2,-8(fp)
8110fee0:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fee4:	00a045f4 	movhi	r2,33047
8110fee8:	10a00404 	addi	r2,r2,-32752
8110feec:	10800e8b 	ldhu	r2,58(r2)
8110fef0:	10bfffcc 	andi	r2,r2,65535
8110fef4:	108000e8 	cmpgeui	r2,r2,3
8110fef8:	1000071e 	bne	r2,zero,8110ff18 <vQCmdFeeRMAPinStandBy+0x338>
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110fefc:	d0a06217 	ldw	r2,-32376(gp)
8110ff00:	100f883a 	mov	r7,r2
8110ff04:	01800f44 	movi	r6,61
8110ff08:	01400044 	movi	r5,1
8110ff0c:	01204574 	movhi	r4,33045
8110ff10:	2137c804 	addi	r4,r4,-8416
8110ff14:	11230300 	call	81123030 <fwrite>
					}
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110ff18:	e0bffe17 	ldw	r2,-8(fp)
8110ff1c:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ff20:	e0bffe17 	ldw	r2,-8(fp)
8110ff24:	10804304 	addi	r2,r2,268
8110ff28:	1009883a 	mov	r4,r2
8110ff2c:	11080940 	call	81108094 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110ff30:	e0bffe17 	ldw	r2,-8(fp)
8110ff34:	10c05717 	ldw	r3,348(r2)
8110ff38:	00bffdc4 	movi	r2,-9
8110ff3c:	1886703a 	and	r3,r3,r2
8110ff40:	e0bffe17 	ldw	r2,-8(fp)
8110ff44:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ff48:	e0bffe17 	ldw	r2,-8(fp)
8110ff4c:	10804304 	addi	r2,r2,268
8110ff50:	1009883a 	mov	r4,r2
8110ff54:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110ff58:	00a045f4 	movhi	r2,33047
8110ff5c:	10a00404 	addi	r2,r2,-32752
8110ff60:	10800e8b 	ldhu	r2,58(r2)
8110ff64:	10bfffcc 	andi	r2,r2,65535
8110ff68:	108000e8 	cmpgeui	r2,r2,3
8110ff6c:	10000c1e 	bne	r2,zero,8110ffa0 <vQCmdFeeRMAPinStandBy+0x3c0>
						fprintf(fp," - Switching to Left side\n");
8110ff70:	d0a06217 	ldw	r2,-32376(gp)
8110ff74:	100f883a 	mov	r7,r2
8110ff78:	01800684 	movi	r6,26
8110ff7c:	01400044 	movi	r5,1
8110ff80:	01204574 	movhi	r4,33045
8110ff84:	2137d804 	addi	r4,r4,-8352
8110ff88:	11230300 	call	81123030 <fwrite>
					}
					#endif
					break;
8110ff8c:	00000406 	br	8110ffa0 <vQCmdFeeRMAPinStandBy+0x3c0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Left side\n");
					}
					#endif
					break;
8110ff90:	0001883a 	nop
8110ff94:	00000306 	br	8110ffa4 <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Right side\n");
					}
					#endif
					break;
8110ff98:	0001883a 	nop
8110ff9c:	00000106 	br	8110ffa4 <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Switching to Left side\n");
					}
					#endif
					break;
8110ffa0:	0001883a 	nop
				}
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110ffa4:	00a045f4 	movhi	r2,33047
8110ffa8:	10a00404 	addi	r2,r2,-32752
8110ffac:	10800e8b 	ldhu	r2,58(r2)
8110ffb0:	10bfffcc 	andi	r2,r2,65535
8110ffb4:	10800168 	cmpgeui	r2,r2,5
8110ffb8:	10009d1e 	bne	r2,zero,81110230 <vQCmdFeeRMAPinStandBy+0x650>
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110ffbc:	d0e06217 	ldw	r3,-32376(gp)
8110ffc0:	e0bffe17 	ldw	r2,-8(fp)
8110ffc4:	10800003 	ldbu	r2,0(r2)
8110ffc8:	11003fcc 	andi	r4,r2,255
8110ffcc:	e0bffe17 	ldw	r2,-8(fp)
8110ffd0:	10802e17 	ldw	r2,184(r2)
8110ffd4:	100f883a 	mov	r7,r2
8110ffd8:	200d883a 	mov	r6,r4
8110ffdc:	01604574 	movhi	r5,33045
8110ffe0:	2977df04 	addi	r5,r5,-8324
8110ffe4:	1809883a 	mov	r4,r3
8110ffe8:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
8110ffec:	00009006 	br	81110230 <vQCmdFeeRMAPinStandBy+0x650>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fff0:	00a045f4 	movhi	r2,33047
8110fff4:	10a00404 	addi	r2,r2,-32752
8110fff8:	10800e8b 	ldhu	r2,58(r2)
8110fffc:	10bfffcc 	andi	r2,r2,65535
81110000:	10800168 	cmpgeui	r2,r2,5
81110004:	10008c1e 	bne	r2,zero,81110238 <vQCmdFeeRMAPinStandBy+0x658>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81110008:	d0a06217 	ldw	r2,-32376(gp)
8111000c:	e0fff903 	ldbu	r3,-28(fp)
81110010:	180d883a 	mov	r6,r3
81110014:	01604574 	movhi	r5,33045
81110018:	2977ed04 	addi	r5,r5,-8268
8111001c:	1009883a 	mov	r4,r2
81110020:	11229940 	call	81122994 <fprintf>
			}
			#endif
				break;
81110024:	00008406 	br	81110238 <vQCmdFeeRMAPinStandBy+0x658>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110028:	e0bffa17 	ldw	r2,-24(fp)
8111002c:	10803c0c 	andi	r2,r2,240
81110030:	1004d13a 	srli	r2,r2,4
81110034:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
81110038:	e0bffb17 	ldw	r2,-20(fp)
8111003c:	10c000a0 	cmpeqi	r3,r2,2
81110040:	1800111e 	bne	r3,zero,81110088 <vQCmdFeeRMAPinStandBy+0x4a8>
81110044:	10c001a0 	cmpeqi	r3,r2,6
81110048:	1800261e 	bne	r3,zero,811100e4 <vQCmdFeeRMAPinStandBy+0x504>
8111004c:	1000331e 	bne	r2,zero,8111011c <vQCmdFeeRMAPinStandBy+0x53c>
				case 0: /* Standby */

				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110050:	00a045f4 	movhi	r2,33047
81110054:	10a00404 	addi	r2,r2,-32752
81110058:	10800e8b 	ldhu	r2,58(r2)
8111005c:	10bfffcc 	andi	r2,r2,65535
81110060:	10800168 	cmpgeui	r2,r2,5
81110064:	10003a1e 	bne	r2,zero,81110150 <vQCmdFeeRMAPinStandBy+0x570>
						fprintf(fp,"- already in Stand by mode\n");
81110068:	d0a06217 	ldw	r2,-32376(gp)
8111006c:	100f883a 	mov	r7,r2
81110070:	018006c4 	movi	r6,27
81110074:	01400044 	movi	r5,1
81110078:	01204574 	movhi	r4,33045
8111007c:	2137f604 	addi	r4,r4,-8232
81110080:	11230300 	call	81123030 <fwrite>
					}
				#endif

					break;
81110084:	00003206 	br	81110150 <vQCmdFeeRMAPinStandBy+0x570>
				case 2: /* PAttern Full image */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110088:	00a045f4 	movhi	r2,33047
8111008c:	10a00404 	addi	r2,r2,-32752
81110090:	10800e8b 	ldhu	r2,58(r2)
81110094:	10bfffcc 	andi	r2,r2,65535
81110098:	10800168 	cmpgeui	r2,r2,5
8111009c:	1000071e 	bne	r2,zero,811100bc <vQCmdFeeRMAPinStandBy+0x4dc>
						fprintf(fp,"- to Full-Image-Pattern\n");
811100a0:	d0a06217 	ldw	r2,-32376(gp)
811100a4:	100f883a 	mov	r7,r2
811100a8:	01800604 	movi	r6,24
811100ac:	01400044 	movi	r5,1
811100b0:	01204574 	movhi	r4,33045
811100b4:	2137fd04 	addi	r4,r4,-8204
811100b8:	11230300 	call	81123030 <fwrite>
					}
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
811100bc:	e0bffe17 	ldw	r2,-8(fp)
811100c0:	00c00044 	movi	r3,1
811100c4:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
811100c8:	e0bffe17 	ldw	r2,-8(fp)
811100cc:	00c00284 	movi	r3,10
811100d0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
811100d4:	e0bffe17 	ldw	r2,-8(fp)
811100d8:	00c00304 	movi	r3,12
811100dc:	10c02d15 	stw	r3,180(r2)

					break;
811100e0:	00002006 	br	81110164 <vQCmdFeeRMAPinStandBy+0x584>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811100e4:	00a045f4 	movhi	r2,33047
811100e8:	10a00404 	addi	r2,r2,-32752
811100ec:	10800e8b 	ldhu	r2,58(r2)
811100f0:	10bfffcc 	andi	r2,r2,65535
811100f4:	10800168 	cmpgeui	r2,r2,5
811100f8:	1000171e 	bne	r2,zero,81110158 <vQCmdFeeRMAPinStandBy+0x578>
						fprintf(fp,"- Off-Mode not allowed.\n");
811100fc:	d0a06217 	ldw	r2,-32376(gp)
81110100:	100f883a 	mov	r7,r2
81110104:	01800604 	movi	r6,24
81110108:	01400044 	movi	r5,1
8111010c:	01204574 	movhi	r4,33045
81110110:	21380404 	addi	r4,r4,-8176
81110114:	11230300 	call	81123030 <fwrite>
					}
				#endif
					break;
81110118:	00000f06 	br	81110158 <vQCmdFeeRMAPinStandBy+0x578>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111011c:	00a045f4 	movhi	r2,33047
81110120:	10a00404 	addi	r2,r2,-32752
81110124:	10800e8b 	ldhu	r2,58(r2)
81110128:	10bfffcc 	andi	r2,r2,65535
8111012c:	108001e8 	cmpgeui	r2,r2,7
81110130:	10000b1e 	bne	r2,zero,81110160 <vQCmdFeeRMAPinStandBy+0x580>
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
81110134:	d0a06217 	ldw	r2,-32376(gp)
81110138:	e1bffb17 	ldw	r6,-20(fp)
8111013c:	01604574 	movhi	r5,33045
81110140:	29780b04 	addi	r5,r5,-8148
81110144:	1009883a 	mov	r4,r2
81110148:	11229940 	call	81122994 <fprintf>
					}
					#endif
					break;
8111014c:	00000406 	br	81110160 <vQCmdFeeRMAPinStandBy+0x580>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- already in Stand by mode\n");
					}
				#endif

					break;
81110150:	0001883a 	nop
81110154:	00003d06 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- Off-Mode not allowed.\n");
					}
				#endif
					break;
81110158:	0001883a 	nop
8111015c:	00003b06 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81110160:	0001883a 	nop
			}

			break;
81110164:	00003906 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110168:	e0bffa17 	ldw	r2,-24(fp)
8111016c:	1080010c 	andi	r2,r2,4
81110170:	1004d0ba 	srli	r2,r2,2
81110174:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
81110178:	e0bffb17 	ldw	r2,-20(fp)
8111017c:	10003026 	beq	r2,zero,81110240 <vQCmdFeeRMAPinStandBy+0x660>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110180:	00a045f4 	movhi	r2,33047
81110184:	10a00404 	addi	r2,r2,-32752
81110188:	10800e8b 	ldhu	r2,58(r2)
8111018c:	10bfffcc 	andi	r2,r2,65535
81110190:	10800168 	cmpgeui	r2,r2,5
81110194:	1000071e 	bne	r2,zero,811101b4 <vQCmdFeeRMAPinStandBy+0x5d4>
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
81110198:	d0a06217 	ldw	r2,-32376(gp)
8111019c:	100f883a 	mov	r7,r2
811101a0:	01800a04 	movi	r6,40
811101a4:	01400044 	movi	r5,1
811101a8:	01204574 	movhi	r4,33045
811101ac:	21381304 	addi	r4,r4,-8116
811101b0:	11230300 	call	81123030 <fwrite>
				}
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811101b4:	e0bffe17 	ldw	r2,-8(fp)
811101b8:	10804304 	addi	r2,r2,268
811101bc:	1009883a 	mov	r4,r2
811101c0:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
811101c4:	e0bffe17 	ldw	r2,-8(fp)
811101c8:	10c06217 	ldw	r3,392(r2)
811101cc:	00bffec4 	movi	r2,-5
811101d0:	1886703a 	and	r3,r3,r2
811101d4:	e0bffe17 	ldw	r2,-8(fp)
811101d8:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811101dc:	e0bffe17 	ldw	r2,-8(fp)
811101e0:	10804304 	addi	r2,r2,268
811101e4:	1009883a 	mov	r4,r2
811101e8:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
			}

			break;
811101ec:	00001406 	br	81110240 <vQCmdFeeRMAPinStandBy+0x660>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811101f0:	00a045f4 	movhi	r2,33047
811101f4:	10a00404 	addi	r2,r2,-32752
811101f8:	10800e8b 	ldhu	r2,58(r2)
811101fc:	10bfffcc 	andi	r2,r2,65535
81110200:	108001e8 	cmpgeui	r2,r2,7
81110204:	1000101e 	bne	r2,zero,81110248 <vQCmdFeeRMAPinStandBy+0x668>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110208:	d0a06217 	ldw	r2,-32376(gp)
8111020c:	e0fff903 	ldbu	r3,-28(fp)
81110210:	180d883a 	mov	r6,r3
81110214:	01604574 	movhi	r5,33045
81110218:	29781e04 	addi	r5,r5,-8072
8111021c:	1009883a 	mov	r4,r2
81110220:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
81110224:	00000806 	br	81110248 <vQCmdFeeRMAPinStandBy+0x668>
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
81110228:	0001883a 	nop
8111022c:	00000706 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
			}
			#endif
			break;
81110230:	0001883a 	nop
81110234:	00000506 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
81110238:	0001883a 	nop
8111023c:	00000306 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110240:	0001883a 	nop
81110244:	00000106 	br	8111024c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81110248:	0001883a 	nop
		}
}
8111024c:	0001883a 	nop
81110250:	e037883a 	mov	sp,fp
81110254:	dfc00117 	ldw	ra,4(sp)
81110258:	df000017 	ldw	fp,0(sp)
8111025c:	dec00204 	addi	sp,sp,8
81110260:	f800283a 	ret

81110264 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
81110264:	defff804 	addi	sp,sp,-32
81110268:	de00012e 	bgeu	sp,et,81110270 <vQCmdFeeRMAPinFullPattern+0xc>
8111026c:	003b68fa 	trap	3
81110270:	dfc00715 	stw	ra,28(sp)
81110274:	df000615 	stw	fp,24(sp)
81110278:	df000604 	addi	fp,sp,24
8111027c:	e13ffe15 	stw	r4,-8(fp)
81110280:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110284:	00a045f4 	movhi	r2,33047
81110288:	10a00404 	addi	r2,r2,-32752
8111028c:	10800e8b 	ldhu	r2,58(r2)
81110290:	10bfffcc 	andi	r2,r2,65535
81110294:	108000e8 	cmpgeui	r2,r2,3
81110298:	1000091e 	bne	r2,zero,811102c0 <vQCmdFeeRMAPinFullPattern+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
8111029c:	d0e06217 	ldw	r3,-32376(gp)
811102a0:	e0bffe17 	ldw	r2,-8(fp)
811102a4:	10800003 	ldbu	r2,0(r2)
811102a8:	10803fcc 	andi	r2,r2,255
811102ac:	100d883a 	mov	r6,r2
811102b0:	01604574 	movhi	r5,33045
811102b4:	29782704 	addi	r5,r5,-8036
811102b8:	1809883a 	mov	r4,r3
811102bc:	11229940 	call	81122994 <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
811102c0:	e0bfff17 	ldw	r2,-4(fp)
811102c4:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811102c8:	e0bffd43 	ldbu	r2,-11(fp)
811102cc:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811102d0:	e0bffe17 	ldw	r2,-8(fp)
811102d4:	10804317 	ldw	r2,268(r2)
811102d8:	e0fffa03 	ldbu	r3,-24(fp)
811102dc:	180b883a 	mov	r5,r3
811102e0:	1009883a 	mov	r4,r2
811102e4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811102e8:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
811102ec:	e0bffa03 	ldbu	r2,-24(fp)
811102f0:	10bff004 	addi	r2,r2,-64
811102f4:	10c003a8 	cmpgeui	r3,r2,14
811102f8:	1801381e 	bne	r3,zero,811107dc <vQCmdFeeRMAPinFullPattern+0x578>
811102fc:	100690ba 	slli	r3,r2,2
81110300:	00a04474 	movhi	r2,33041
81110304:	1080c504 	addi	r2,r2,788
81110308:	1885883a 	add	r2,r3,r2
8111030c:	10800017 	ldw	r2,0(r2)
81110310:	1000683a 	jmp	r2
81110314:	8111034c 	andi	r4,r16,17421
81110318:	8111034c 	andi	r4,r16,17421
8111031c:	8111034c 	andi	r4,r16,17421
81110320:	811105a4 	muli	r4,r16,17430
81110324:	811105a4 	muli	r4,r16,17430
81110328:	811105a4 	muli	r4,r16,17430
8111032c:	811105a4 	muli	r4,r16,17430
81110330:	811105a4 	muli	r4,r16,17430
81110334:	811105a4 	muli	r4,r16,17430
81110338:	811105a4 	muli	r4,r16,17430
8111033c:	811105a4 	muli	r4,r16,17430
81110340:	811105a4 	muli	r4,r16,17430
81110344:	811105dc 	xori	r4,r16,17431
81110348:	8111075c 	xori	r4,r16,17437
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8111034c:	e0bffe17 	ldw	r2,-8(fp)
81110350:	10802d17 	ldw	r2,180(r2)
81110354:	108001e0 	cmpeqi	r2,r2,7
81110358:	1000041e 	bne	r2,zero,8111036c <vQCmdFeeRMAPinFullPattern+0x108>
8111035c:	e0bffe17 	ldw	r2,-8(fp)
81110360:	10802d17 	ldw	r2,180(r2)
81110364:	10800318 	cmpnei	r2,r2,12
81110368:	1000771e 	bne	r2,zero,81110548 <vQCmdFeeRMAPinFullPattern+0x2e4>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8111036c:	e0bffa43 	ldbu	r2,-23(fp)
81110370:	1080030c 	andi	r2,r2,12
81110374:	1005d0ba 	srai	r2,r2,2
81110378:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8111037c:	e0bffb17 	ldw	r2,-20(fp)
81110380:	10c000a0 	cmpeqi	r3,r2,2
81110384:	1800141e 	bne	r3,zero,811103d8 <vQCmdFeeRMAPinFullPattern+0x174>
81110388:	10c000e0 	cmpeqi	r3,r2,3
8111038c:	1800231e 	bne	r3,zero,8111041c <vQCmdFeeRMAPinFullPattern+0x1b8>
81110390:	10800060 	cmpeqi	r2,r2,1
81110394:	10003026 	beq	r2,zero,81110458 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81110398:	e0bffe17 	ldw	r2,-8(fp)
8111039c:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811103a0:	00a045f4 	movhi	r2,33047
811103a4:	10a00404 	addi	r2,r2,-32752
811103a8:	10800e8b 	ldhu	r2,58(r2)
811103ac:	10bfffcc 	andi	r2,r2,65535
811103b0:	108000e8 	cmpgeui	r2,r2,3
811103b4:	1000461e 	bne	r2,zero,811104d0 <vQCmdFeeRMAPinFullPattern+0x26c>
							fprintf(fp," - Left side\n");
811103b8:	d0a06217 	ldw	r2,-32376(gp)
811103bc:	100f883a 	mov	r7,r2
811103c0:	01800344 	movi	r6,13
811103c4:	01400044 	movi	r5,1
811103c8:	01204574 	movhi	r4,33045
811103cc:	2137c004 	addi	r4,r4,-8448
811103d0:	11230300 	call	81123030 <fwrite>
						}
						#endif
						break;
811103d4:	00003e06 	br	811104d0 <vQCmdFeeRMAPinFullPattern+0x26c>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
811103d8:	e0bffe17 	ldw	r2,-8(fp)
811103dc:	00c00044 	movi	r3,1
811103e0:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811103e4:	00a045f4 	movhi	r2,33047
811103e8:	10a00404 	addi	r2,r2,-32752
811103ec:	10800e8b 	ldhu	r2,58(r2)
811103f0:	10bfffcc 	andi	r2,r2,65535
811103f4:	108000e8 	cmpgeui	r2,r2,3
811103f8:	1000371e 	bne	r2,zero,811104d8 <vQCmdFeeRMAPinFullPattern+0x274>
							fprintf(fp," - Right side\n");
811103fc:	d0a06217 	ldw	r2,-32376(gp)
81110400:	100f883a 	mov	r7,r2
81110404:	01800384 	movi	r6,14
81110408:	01400044 	movi	r5,1
8111040c:	01204574 	movhi	r4,33045
81110410:	2137c404 	addi	r4,r4,-8432
81110414:	11230300 	call	81123030 <fwrite>
						}
						#endif
						break;
81110418:	00002f06 	br	811104d8 <vQCmdFeeRMAPinFullPattern+0x274>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8111041c:	e0bffe17 	ldw	r2,-8(fp)
81110420:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110424:	00a045f4 	movhi	r2,33047
81110428:	10a00404 	addi	r2,r2,-32752
8111042c:	10800e8b 	ldhu	r2,58(r2)
81110430:	10bfffcc 	andi	r2,r2,65535
81110434:	108000e8 	cmpgeui	r2,r2,3
81110438:	1000071e 	bne	r2,zero,81110458 <vQCmdFeeRMAPinFullPattern+0x1f4>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8111043c:	d0a06217 	ldw	r2,-32376(gp)
81110440:	100f883a 	mov	r7,r2
81110444:	01800f44 	movi	r6,61
81110448:	01400044 	movi	r5,1
8111044c:	01204574 	movhi	r4,33045
81110450:	2137c804 	addi	r4,r4,-8416
81110454:	11230300 	call	81123030 <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110458:	e0bffe17 	ldw	r2,-8(fp)
8111045c:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110460:	e0bffe17 	ldw	r2,-8(fp)
81110464:	10804304 	addi	r2,r2,268
81110468:	1009883a 	mov	r4,r2
8111046c:	11080940 	call	81108094 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110470:	e0bffe17 	ldw	r2,-8(fp)
81110474:	10c05717 	ldw	r3,348(r2)
81110478:	00bffdc4 	movi	r2,-9
8111047c:	1886703a 	and	r3,r3,r2
81110480:	e0bffe17 	ldw	r2,-8(fp)
81110484:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110488:	e0bffe17 	ldw	r2,-8(fp)
8111048c:	10804304 	addi	r2,r2,268
81110490:	1009883a 	mov	r4,r2
81110494:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110498:	00a045f4 	movhi	r2,33047
8111049c:	10a00404 	addi	r2,r2,-32752
811104a0:	10800e8b 	ldhu	r2,58(r2)
811104a4:	10bfffcc 	andi	r2,r2,65535
811104a8:	108000e8 	cmpgeui	r2,r2,3
811104ac:	10000c1e 	bne	r2,zero,811104e0 <vQCmdFeeRMAPinFullPattern+0x27c>
							fprintf(fp," - Switching to Left side\n");
811104b0:	d0a06217 	ldw	r2,-32376(gp)
811104b4:	100f883a 	mov	r7,r2
811104b8:	01800684 	movi	r6,26
811104bc:	01400044 	movi	r5,1
811104c0:	01204574 	movhi	r4,33045
811104c4:	2137d804 	addi	r4,r4,-8352
811104c8:	11230300 	call	81123030 <fwrite>
						}
						#endif
					break;
811104cc:	00000406 	br	811104e0 <vQCmdFeeRMAPinFullPattern+0x27c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
811104d0:	0001883a 	nop
811104d4:	00000306 	br	811104e4 <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
811104d8:	0001883a 	nop
811104dc:	00000106 	br	811104e4 <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
811104e0:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811104e4:	00a045f4 	movhi	r2,33047
811104e8:	10a00404 	addi	r2,r2,-32752
811104ec:	10800e8b 	ldhu	r2,58(r2)
811104f0:	10bfffcc 	andi	r2,r2,65535
811104f4:	10800168 	cmpgeui	r2,r2,5
811104f8:	10000c1e 	bne	r2,zero,8111052c <vQCmdFeeRMAPinFullPattern+0x2c8>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
811104fc:	d0e06217 	ldw	r3,-32376(gp)
81110500:	e0bffe17 	ldw	r2,-8(fp)
81110504:	10800003 	ldbu	r2,0(r2)
81110508:	11003fcc 	andi	r4,r2,255
8111050c:	e0bffe17 	ldw	r2,-8(fp)
81110510:	10802e17 	ldw	r2,184(r2)
81110514:	100f883a 	mov	r7,r2
81110518:	200d883a 	mov	r6,r4
8111051c:	01604574 	movhi	r5,33045
81110520:	2977df04 	addi	r5,r5,-8324
81110524:	1809883a 	mov	r4,r3
81110528:	11229940 	call	81122994 <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8111052c:	e0bffe17 	ldw	r2,-8(fp)
81110530:	00c00284 	movi	r3,10
81110534:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110538:	e0bffe17 	ldw	r2,-8(fp)
8111053c:	00c00304 	movi	r3,12
81110540:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
81110544:	0000b306 	br	81110814 <vQCmdFeeRMAPinFullPattern+0x5b0>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110548:	e0bffe17 	ldw	r2,-8(fp)
8111054c:	10802d17 	ldw	r2,180(r2)
81110550:	10800118 	cmpnei	r2,r2,4
81110554:	1000af1e 	bne	r2,zero,81110814 <vQCmdFeeRMAPinFullPattern+0x5b0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110558:	00a045f4 	movhi	r2,33047
8111055c:	10a00404 	addi	r2,r2,-32752
81110560:	10800e8b 	ldhu	r2,58(r2)
81110564:	10bfffcc 	andi	r2,r2,65535
81110568:	10800168 	cmpgeui	r2,r2,5
8111056c:	1000a91e 	bne	r2,zero,81110814 <vQCmdFeeRMAPinFullPattern+0x5b0>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110570:	d0e06217 	ldw	r3,-32376(gp)
81110574:	e0bffe17 	ldw	r2,-8(fp)
81110578:	10800003 	ldbu	r2,0(r2)
8111057c:	11003fcc 	andi	r4,r2,255
81110580:	e0bffe17 	ldw	r2,-8(fp)
81110584:	10802e17 	ldw	r2,184(r2)
81110588:	100f883a 	mov	r7,r2
8111058c:	200d883a 	mov	r6,r4
81110590:	01604574 	movhi	r5,33045
81110594:	29783404 	addi	r5,r5,-7984
81110598:	1809883a 	mov	r4,r3
8111059c:	11229940 	call	81122994 <fprintf>
				}
			}



			break;
811105a0:	00009c06 	br	81110814 <vQCmdFeeRMAPinFullPattern+0x5b0>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811105a4:	00a045f4 	movhi	r2,33047
811105a8:	10a00404 	addi	r2,r2,-32752
811105ac:	10800e8b 	ldhu	r2,58(r2)
811105b0:	10bfffcc 	andi	r2,r2,65535
811105b4:	10800168 	cmpgeui	r2,r2,5
811105b8:	1000981e 	bne	r2,zero,8111081c <vQCmdFeeRMAPinFullPattern+0x5b8>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
811105bc:	d0a06217 	ldw	r2,-32376(gp)
811105c0:	e0fffa03 	ldbu	r3,-24(fp)
811105c4:	180d883a 	mov	r6,r3
811105c8:	01604574 	movhi	r5,33045
811105cc:	29781e04 	addi	r5,r5,-8072
811105d0:	1009883a 	mov	r4,r2
811105d4:	11229940 	call	81122994 <fprintf>
			}
			#endif
				break;
811105d8:	00009006 	br	8111081c <vQCmdFeeRMAPinFullPattern+0x5b8>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811105dc:	e0bffa43 	ldbu	r2,-23(fp)
811105e0:	1004d13a 	srli	r2,r2,4
811105e4:	10803fcc 	andi	r2,r2,255
811105e8:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
811105ec:	e0bffc17 	ldw	r2,-16(fp)
811105f0:	10c000a0 	cmpeqi	r3,r2,2
811105f4:	1800281e 	bne	r3,zero,81110698 <vQCmdFeeRMAPinFullPattern+0x434>
811105f8:	10c001a0 	cmpeqi	r3,r2,6
811105fc:	1800361e 	bne	r3,zero,811106d8 <vQCmdFeeRMAPinFullPattern+0x474>
81110600:	1000431e 	bne	r2,zero,81110710 <vQCmdFeeRMAPinFullPattern+0x4ac>
				case 0: /* Standby */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110604:	00a045f4 	movhi	r2,33047
81110608:	10a00404 	addi	r2,r2,-32752
8111060c:	10800e8b 	ldhu	r2,58(r2)
81110610:	10bfffcc 	andi	r2,r2,65535
81110614:	108000e8 	cmpgeui	r2,r2,3
81110618:	1000071e 	bne	r2,zero,81110638 <vQCmdFeeRMAPinFullPattern+0x3d4>
						fprintf(fp,"- to Stand-By\n");
8111061c:	d0a06217 	ldw	r2,-32376(gp)
81110620:	100f883a 	mov	r7,r2
81110624:	01800384 	movi	r6,14
81110628:	01400044 	movi	r5,1
8111062c:	01204574 	movhi	r4,33045
81110630:	21384b04 	addi	r4,r4,-7892
81110634:	11230300 	call	81123030 <fwrite>
					}
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
81110638:	e0bffe17 	ldw	r2,-8(fp)
8111063c:	10802c17 	ldw	r2,176(r2)
81110640:	10800298 	cmpnei	r2,r2,10
81110644:	10000a1e 	bne	r2,zero,81110670 <vQCmdFeeRMAPinFullPattern+0x40c>
						pxNFeeP->xControl.bWatingSync = TRUE;
81110648:	e0bffe17 	ldw	r2,-8(fp)
8111064c:	00c00044 	movi	r3,1
81110650:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110654:	e0bffe17 	ldw	r2,-8(fp)
81110658:	00c00304 	movi	r3,12
8111065c:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110660:	e0bffe17 	ldw	r2,-8(fp)
81110664:	00c00184 	movi	r3,6
81110668:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8111066c:	00003a06 	br	81110758 <vQCmdFeeRMAPinFullPattern+0x4f4>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
81110670:	e0bffe17 	ldw	r2,-8(fp)
81110674:	00c00044 	movi	r3,1
81110678:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8111067c:	e0bffe17 	ldw	r2,-8(fp)
81110680:	00c00104 	movi	r3,4
81110684:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110688:	e0bffe17 	ldw	r2,-8(fp)
8111068c:	00c00184 	movi	r3,6
81110690:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110694:	00003006 	br	81110758 <vQCmdFeeRMAPinFullPattern+0x4f4>
				case 2: /* PAttern Full image */
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110698:	00a045f4 	movhi	r2,33047
8111069c:	10a00404 	addi	r2,r2,-32752
811106a0:	10800e8b 	ldhu	r2,58(r2)
811106a4:	10bfffcc 	andi	r2,r2,65535
811106a8:	10800168 	cmpgeui	r2,r2,5
811106ac:	1000251e 	bne	r2,zero,81110744 <vQCmdFeeRMAPinFullPattern+0x4e0>
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811106b0:	d0e06217 	ldw	r3,-32376(gp)
811106b4:	e0bffe17 	ldw	r2,-8(fp)
811106b8:	10800003 	ldbu	r2,0(r2)
811106bc:	10803fcc 	andi	r2,r2,255
811106c0:	100d883a 	mov	r6,r2
811106c4:	01604574 	movhi	r5,33045
811106c8:	29779004 	addi	r5,r5,-8640
811106cc:	1809883a 	mov	r4,r3
811106d0:	11229940 	call	81122994 <fprintf>
					}
					#endif

					break;
811106d4:	00001b06 	br	81110744 <vQCmdFeeRMAPinFullPattern+0x4e0>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811106d8:	00a045f4 	movhi	r2,33047
811106dc:	10a00404 	addi	r2,r2,-32752
811106e0:	10800e8b 	ldhu	r2,58(r2)
811106e4:	10bfffcc 	andi	r2,r2,65535
811106e8:	10800168 	cmpgeui	r2,r2,5
811106ec:	1000171e 	bne	r2,zero,8111074c <vQCmdFeeRMAPinFullPattern+0x4e8>
						fprintf(fp," Off-Mode not allowed.\n");
811106f0:	d0a06217 	ldw	r2,-32376(gp)
811106f4:	100f883a 	mov	r7,r2
811106f8:	018005c4 	movi	r6,23
811106fc:	01400044 	movi	r5,1
81110700:	01204574 	movhi	r4,33045
81110704:	21384f04 	addi	r4,r4,-7876
81110708:	11230300 	call	81123030 <fwrite>
					}
				#endif
					break;
8111070c:	00000f06 	br	8111074c <vQCmdFeeRMAPinFullPattern+0x4e8>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110710:	00a045f4 	movhi	r2,33047
81110714:	10a00404 	addi	r2,r2,-32752
81110718:	10800e8b 	ldhu	r2,58(r2)
8111071c:	10bfffcc 	andi	r2,r2,65535
81110720:	10800168 	cmpgeui	r2,r2,5
81110724:	10000b1e 	bne	r2,zero,81110754 <vQCmdFeeRMAPinFullPattern+0x4f0>
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81110728:	d0a06217 	ldw	r2,-32376(gp)
8111072c:	e1bffc17 	ldw	r6,-16(fp)
81110730:	01604574 	movhi	r5,33045
81110734:	29785504 	addi	r5,r5,-7852
81110738:	1009883a 	mov	r4,r2
8111073c:	11229940 	call	81122994 <fprintf>
					}
					#endif
					break;
81110740:	00000406 	br	81110754 <vQCmdFeeRMAPinFullPattern+0x4f0>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
					}
					#endif

					break;
81110744:	0001883a 	nop
81110748:	00003906 	br	81110830 <vQCmdFeeRMAPinFullPattern+0x5cc>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," Off-Mode not allowed.\n");
					}
				#endif
					break;
8111074c:	0001883a 	nop
81110750:	00003706 	br	81110830 <vQCmdFeeRMAPinFullPattern+0x5cc>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81110754:	0001883a 	nop
			}

			break;
81110758:	00003506 	br	81110830 <vQCmdFeeRMAPinFullPattern+0x5cc>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8111075c:	e0bffa43 	ldbu	r2,-23(fp)
81110760:	1080010c 	andi	r2,r2,4
81110764:	10803fcc 	andi	r2,r2,255
81110768:	1004d0ba 	srli	r2,r2,2
8111076c:	10803fcc 	andi	r2,r2,255
81110770:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81110774:	e0bffc17 	ldw	r2,-16(fp)
81110778:	10002a26 	beq	r2,zero,81110824 <vQCmdFeeRMAPinFullPattern+0x5c0>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8111077c:	e0bffe17 	ldw	r2,-8(fp)
81110780:	10802d17 	ldw	r2,180(r2)
81110784:	10800198 	cmpnei	r2,r2,6
81110788:	1000261e 	bne	r2,zero,81110824 <vQCmdFeeRMAPinFullPattern+0x5c0>
					pxNFeeP->xControl.bWatingSync = FALSE;
8111078c:	e0bffe17 	ldw	r2,-8(fp)
81110790:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110794:	e0bffe17 	ldw	r2,-8(fp)
81110798:	10c02d17 	ldw	r3,180(r2)
8111079c:	e0bffe17 	ldw	r2,-8(fp)
811107a0:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811107a4:	00a045f4 	movhi	r2,33047
811107a8:	10a00404 	addi	r2,r2,-32752
811107ac:	10800e8b 	ldhu	r2,58(r2)
811107b0:	10bfffcc 	andi	r2,r2,65535
811107b4:	10800168 	cmpgeui	r2,r2,5
811107b8:	10001a1e 	bne	r2,zero,81110824 <vQCmdFeeRMAPinFullPattern+0x5c0>
						fprintf(fp," - Mode Forced.\n");
811107bc:	d0a06217 	ldw	r2,-32376(gp)
811107c0:	100f883a 	mov	r7,r2
811107c4:	01800404 	movi	r6,16
811107c8:	01400044 	movi	r5,1
811107cc:	01204574 	movhi	r4,33045
811107d0:	21385d04 	addi	r4,r4,-7820
811107d4:	11230300 	call	81123030 <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
811107d8:	00001206 	br	81110824 <vQCmdFeeRMAPinFullPattern+0x5c0>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811107dc:	00a045f4 	movhi	r2,33047
811107e0:	10a00404 	addi	r2,r2,-32752
811107e4:	10800e8b 	ldhu	r2,58(r2)
811107e8:	10bfffcc 	andi	r2,r2,65535
811107ec:	108001e8 	cmpgeui	r2,r2,7
811107f0:	10000e1e 	bne	r2,zero,8111082c <vQCmdFeeRMAPinFullPattern+0x5c8>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
811107f4:	d0a06217 	ldw	r2,-32376(gp)
811107f8:	e0fffa03 	ldbu	r3,-24(fp)
811107fc:	180d883a 	mov	r6,r3
81110800:	01604574 	movhi	r5,33045
81110804:	2977ed04 	addi	r5,r5,-8268
81110808:	1009883a 	mov	r4,r2
8111080c:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
81110810:	00000606 	br	8111082c <vQCmdFeeRMAPinFullPattern+0x5c8>
				}
			}



			break;
81110814:	0001883a 	nop
81110818:	00000506 	br	81110830 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
8111081c:	0001883a 	nop
81110820:	00000306 	br	81110830 <vQCmdFeeRMAPinFullPattern+0x5cc>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110824:	0001883a 	nop
81110828:	00000106 	br	81110830 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
8111082c:	0001883a 	nop
		}
}
81110830:	0001883a 	nop
81110834:	e037883a 	mov	sp,fp
81110838:	dfc00117 	ldw	ra,4(sp)
8111083c:	df000017 	ldw	fp,0(sp)
81110840:	dec00204 	addi	sp,sp,8
81110844:	f800283a 	ret

81110848 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
81110848:	defff804 	addi	sp,sp,-32
8111084c:	de00012e 	bgeu	sp,et,81110854 <vQCmdFeeRMAPWaitingSync+0xc>
81110850:	003b68fa 	trap	3
81110854:	dfc00715 	stw	ra,28(sp)
81110858:	df000615 	stw	fp,24(sp)
8111085c:	df000604 	addi	fp,sp,24
81110860:	e13ffe15 	stw	r4,-8(fp)
81110864:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110868:	00a045f4 	movhi	r2,33047
8111086c:	10a00404 	addi	r2,r2,-32752
81110870:	10800e8b 	ldhu	r2,58(r2)
81110874:	10bfffcc 	andi	r2,r2,65535
81110878:	108000e8 	cmpgeui	r2,r2,3
8111087c:	1000091e 	bne	r2,zero,811108a4 <vQCmdFeeRMAPWaitingSync+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
81110880:	d0e06217 	ldw	r3,-32376(gp)
81110884:	e0bffe17 	ldw	r2,-8(fp)
81110888:	10800003 	ldbu	r2,0(r2)
8111088c:	10803fcc 	andi	r2,r2,255
81110890:	100d883a 	mov	r6,r2
81110894:	01604574 	movhi	r5,33045
81110898:	29786204 	addi	r5,r5,-7800
8111089c:	1809883a 	mov	r4,r3
811108a0:	11229940 	call	81122994 <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
811108a4:	e0bfff17 	ldw	r2,-4(fp)
811108a8:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811108ac:	e0bffd43 	ldbu	r2,-11(fp)
811108b0:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811108b4:	e0bffe17 	ldw	r2,-8(fp)
811108b8:	10804317 	ldw	r2,268(r2)
811108bc:	e0fffa03 	ldbu	r3,-24(fp)
811108c0:	180b883a 	mov	r5,r3
811108c4:	1009883a 	mov	r4,r2
811108c8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811108cc:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
811108d0:	e0bffa03 	ldbu	r2,-24(fp)
811108d4:	10c010c8 	cmpgei	r3,r2,67
811108d8:	1800051e 	bne	r3,zero,811108f0 <vQCmdFeeRMAPWaitingSync+0xa8>
811108dc:	10c01008 	cmpgei	r3,r2,64
811108e0:	1800081e 	bne	r3,zero,81110904 <vQCmdFeeRMAPWaitingSync+0xbc>
811108e4:	108000a0 	cmpeqi	r2,r2,2
811108e8:	1000e61e 	bne	r2,zero,81110c84 <vQCmdFeeRMAPWaitingSync+0x43c>
811108ec:	00011e06 	br	81110d68 <vQCmdFeeRMAPWaitingSync+0x520>
811108f0:	10c01350 	cmplti	r3,r2,77
811108f4:	1800991e 	bne	r3,zero,81110b5c <vQCmdFeeRMAPWaitingSync+0x314>
811108f8:	10801360 	cmpeqi	r2,r2,77
811108fc:	1000fa1e 	bne	r2,zero,81110ce8 <vQCmdFeeRMAPWaitingSync+0x4a0>
81110900:	00011906 	br	81110d68 <vQCmdFeeRMAPWaitingSync+0x520>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81110904:	e0bffe17 	ldw	r2,-8(fp)
81110908:	10802d17 	ldw	r2,180(r2)
8111090c:	108001e0 	cmpeqi	r2,r2,7
81110910:	1000041e 	bne	r2,zero,81110924 <vQCmdFeeRMAPWaitingSync+0xdc>
81110914:	e0bffe17 	ldw	r2,-8(fp)
81110918:	10802d17 	ldw	r2,180(r2)
8111091c:	10800318 	cmpnei	r2,r2,12
81110920:	1000771e 	bne	r2,zero,81110b00 <vQCmdFeeRMAPWaitingSync+0x2b8>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81110924:	e0bffa43 	ldbu	r2,-23(fp)
81110928:	1080030c 	andi	r2,r2,12
8111092c:	1005d0ba 	srai	r2,r2,2
81110930:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110934:	e0bffb17 	ldw	r2,-20(fp)
81110938:	10c000a0 	cmpeqi	r3,r2,2
8111093c:	1800141e 	bne	r3,zero,81110990 <vQCmdFeeRMAPWaitingSync+0x148>
81110940:	10c000e0 	cmpeqi	r3,r2,3
81110944:	1800231e 	bne	r3,zero,811109d4 <vQCmdFeeRMAPWaitingSync+0x18c>
81110948:	10800060 	cmpeqi	r2,r2,1
8111094c:	10003026 	beq	r2,zero,81110a10 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81110950:	e0bffe17 	ldw	r2,-8(fp)
81110954:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110958:	00a045f4 	movhi	r2,33047
8111095c:	10a00404 	addi	r2,r2,-32752
81110960:	10800e8b 	ldhu	r2,58(r2)
81110964:	10bfffcc 	andi	r2,r2,65535
81110968:	108000e8 	cmpgeui	r2,r2,3
8111096c:	1000461e 	bne	r2,zero,81110a88 <vQCmdFeeRMAPWaitingSync+0x240>
							fprintf(fp," - Left side\n");
81110970:	d0a06217 	ldw	r2,-32376(gp)
81110974:	100f883a 	mov	r7,r2
81110978:	01800344 	movi	r6,13
8111097c:	01400044 	movi	r5,1
81110980:	01204574 	movhi	r4,33045
81110984:	2137c004 	addi	r4,r4,-8448
81110988:	11230300 	call	81123030 <fwrite>
						}
						#endif
						break;
8111098c:	00003e06 	br	81110a88 <vQCmdFeeRMAPWaitingSync+0x240>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110990:	e0bffe17 	ldw	r2,-8(fp)
81110994:	00c00044 	movi	r3,1
81110998:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111099c:	00a045f4 	movhi	r2,33047
811109a0:	10a00404 	addi	r2,r2,-32752
811109a4:	10800e8b 	ldhu	r2,58(r2)
811109a8:	10bfffcc 	andi	r2,r2,65535
811109ac:	108000e8 	cmpgeui	r2,r2,3
811109b0:	1000371e 	bne	r2,zero,81110a90 <vQCmdFeeRMAPWaitingSync+0x248>
							fprintf(fp," - Right side\n");
811109b4:	d0a06217 	ldw	r2,-32376(gp)
811109b8:	100f883a 	mov	r7,r2
811109bc:	01800384 	movi	r6,14
811109c0:	01400044 	movi	r5,1
811109c4:	01204574 	movhi	r4,33045
811109c8:	2137c404 	addi	r4,r4,-8432
811109cc:	11230300 	call	81123030 <fwrite>
						}
						#endif
						break;
811109d0:	00002f06 	br	81110a90 <vQCmdFeeRMAPWaitingSync+0x248>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
811109d4:	e0bffe17 	ldw	r2,-8(fp)
811109d8:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811109dc:	00a045f4 	movhi	r2,33047
811109e0:	10a00404 	addi	r2,r2,-32752
811109e4:	10800e8b 	ldhu	r2,58(r2)
811109e8:	10bfffcc 	andi	r2,r2,65535
811109ec:	10800168 	cmpgeui	r2,r2,5
811109f0:	1000071e 	bne	r2,zero,81110a10 <vQCmdFeeRMAPWaitingSync+0x1c8>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
811109f4:	d0a06217 	ldw	r2,-32376(gp)
811109f8:	100f883a 	mov	r7,r2
811109fc:	01800f44 	movi	r6,61
81110a00:	01400044 	movi	r5,1
81110a04:	01204574 	movhi	r4,33045
81110a08:	2137c804 	addi	r4,r4,-8416
81110a0c:	11230300 	call	81123030 <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110a10:	e0bffe17 	ldw	r2,-8(fp)
81110a14:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110a18:	e0bffe17 	ldw	r2,-8(fp)
81110a1c:	10804304 	addi	r2,r2,268
81110a20:	1009883a 	mov	r4,r2
81110a24:	11080940 	call	81108094 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110a28:	e0bffe17 	ldw	r2,-8(fp)
81110a2c:	10c05717 	ldw	r3,348(r2)
81110a30:	00bffdc4 	movi	r2,-9
81110a34:	1886703a 	and	r3,r3,r2
81110a38:	e0bffe17 	ldw	r2,-8(fp)
81110a3c:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110a40:	e0bffe17 	ldw	r2,-8(fp)
81110a44:	10804304 	addi	r2,r2,268
81110a48:	1009883a 	mov	r4,r2
81110a4c:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110a50:	00a045f4 	movhi	r2,33047
81110a54:	10a00404 	addi	r2,r2,-32752
81110a58:	10800e8b 	ldhu	r2,58(r2)
81110a5c:	10bfffcc 	andi	r2,r2,65535
81110a60:	108000e8 	cmpgeui	r2,r2,3
81110a64:	10000c1e 	bne	r2,zero,81110a98 <vQCmdFeeRMAPWaitingSync+0x250>
							fprintf(fp," - Switching to Left side\n");
81110a68:	d0a06217 	ldw	r2,-32376(gp)
81110a6c:	100f883a 	mov	r7,r2
81110a70:	01800684 	movi	r6,26
81110a74:	01400044 	movi	r5,1
81110a78:	01204574 	movhi	r4,33045
81110a7c:	2137d804 	addi	r4,r4,-8352
81110a80:	11230300 	call	81123030 <fwrite>
						}
						#endif
					break;
81110a84:	00000406 	br	81110a98 <vQCmdFeeRMAPWaitingSync+0x250>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
81110a88:	0001883a 	nop
81110a8c:	00000306 	br	81110a9c <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
81110a90:	0001883a 	nop
81110a94:	00000106 	br	81110a9c <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
81110a98:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110a9c:	00a045f4 	movhi	r2,33047
81110aa0:	10a00404 	addi	r2,r2,-32752
81110aa4:	10800e8b 	ldhu	r2,58(r2)
81110aa8:	10bfffcc 	andi	r2,r2,65535
81110aac:	10800168 	cmpgeui	r2,r2,5
81110ab0:	10000c1e 	bne	r2,zero,81110ae4 <vQCmdFeeRMAPWaitingSync+0x29c>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110ab4:	d0e06217 	ldw	r3,-32376(gp)
81110ab8:	e0bffe17 	ldw	r2,-8(fp)
81110abc:	10800003 	ldbu	r2,0(r2)
81110ac0:	11003fcc 	andi	r4,r2,255
81110ac4:	e0bffe17 	ldw	r2,-8(fp)
81110ac8:	10802e17 	ldw	r2,184(r2)
81110acc:	100f883a 	mov	r7,r2
81110ad0:	200d883a 	mov	r6,r4
81110ad4:	01604574 	movhi	r5,33045
81110ad8:	2977df04 	addi	r5,r5,-8324
81110adc:	1809883a 	mov	r4,r3
81110ae0:	11229940 	call	81122994 <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110ae4:	e0bffe17 	ldw	r2,-8(fp)
81110ae8:	00c00284 	movi	r3,10
81110aec:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110af0:	e0bffe17 	ldw	r2,-8(fp)
81110af4:	00c00304 	movi	r3,12
81110af8:	10c02d15 	stw	r3,180(r2)
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
81110afc:	0000a806 	br	81110da0 <vQCmdFeeRMAPWaitingSync+0x558>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110b00:	e0bffe17 	ldw	r2,-8(fp)
81110b04:	10802d17 	ldw	r2,180(r2)
81110b08:	10800118 	cmpnei	r2,r2,4
81110b0c:	1000a41e 	bne	r2,zero,81110da0 <vQCmdFeeRMAPWaitingSync+0x558>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110b10:	00a045f4 	movhi	r2,33047
81110b14:	10a00404 	addi	r2,r2,-32752
81110b18:	10800e8b 	ldhu	r2,58(r2)
81110b1c:	10bfffcc 	andi	r2,r2,65535
81110b20:	108001e8 	cmpgeui	r2,r2,7
81110b24:	10009e1e 	bne	r2,zero,81110da0 <vQCmdFeeRMAPWaitingSync+0x558>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110b28:	d0e06217 	ldw	r3,-32376(gp)
81110b2c:	e0bffe17 	ldw	r2,-8(fp)
81110b30:	10800003 	ldbu	r2,0(r2)
81110b34:	11003fcc 	andi	r4,r2,255
81110b38:	e0bffe17 	ldw	r2,-8(fp)
81110b3c:	10802e17 	ldw	r2,184(r2)
81110b40:	100f883a 	mov	r7,r2
81110b44:	200d883a 	mov	r6,r4
81110b48:	01604574 	movhi	r5,33045
81110b4c:	29783404 	addi	r5,r5,-7984
81110b50:	1809883a 	mov	r4,r3
81110b54:	11229940 	call	81122994 <fprintf>
					}
					#endif
				}
			}
			break;
81110b58:	00009106 	br	81110da0 <vQCmdFeeRMAPWaitingSync+0x558>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110b5c:	e0bffa43 	ldbu	r2,-23(fp)
81110b60:	1004d13a 	srli	r2,r2,4
81110b64:	10803fcc 	andi	r2,r2,255
81110b68:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
81110b6c:	e0bffc17 	ldw	r2,-16(fp)
81110b70:	10c000a0 	cmpeqi	r3,r2,2
81110b74:	18001a1e 	bne	r3,zero,81110be0 <vQCmdFeeRMAPWaitingSync+0x398>
81110b78:	10c001a0 	cmpeqi	r3,r2,6
81110b7c:	1800221e 	bne	r3,zero,81110c08 <vQCmdFeeRMAPWaitingSync+0x3c0>
81110b80:	10002f1e 	bne	r2,zero,81110c40 <vQCmdFeeRMAPWaitingSync+0x3f8>
			case 0: /* Standby */
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110b84:	00a045f4 	movhi	r2,33047
81110b88:	10a00404 	addi	r2,r2,-32752
81110b8c:	10800e8b 	ldhu	r2,58(r2)
81110b90:	10bfffcc 	andi	r2,r2,65535
81110b94:	108000e8 	cmpgeui	r2,r2,3
81110b98:	1000071e 	bne	r2,zero,81110bb8 <vQCmdFeeRMAPWaitingSync+0x370>
					fprintf(fp,"- to Stand-By\n");
81110b9c:	d0a06217 	ldw	r2,-32376(gp)
81110ba0:	100f883a 	mov	r7,r2
81110ba4:	01800384 	movi	r6,14
81110ba8:	01400044 	movi	r5,1
81110bac:	01204574 	movhi	r4,33045
81110bb0:	21384b04 	addi	r4,r4,-7892
81110bb4:	11230300 	call	81123030 <fwrite>
				}
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
81110bb8:	e0bffe17 	ldw	r2,-8(fp)
81110bbc:	00c00044 	movi	r3,1
81110bc0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110bc4:	e0bffe17 	ldw	r2,-8(fp)
81110bc8:	00c00304 	movi	r3,12
81110bcc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110bd0:	e0bffe17 	ldw	r2,-8(fp)
81110bd4:	00c00184 	movi	r3,6
81110bd8:	10c02d15 	stw	r3,180(r2)


				break;
81110bdc:	00002806 	br	81110c80 <vQCmdFeeRMAPWaitingSync+0x438>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
81110be0:	e0bffe17 	ldw	r2,-8(fp)
81110be4:	00c00044 	movi	r3,1
81110be8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
81110bec:	e0bffe17 	ldw	r2,-8(fp)
81110bf0:	00c00304 	movi	r3,12
81110bf4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81110bf8:	e0bffe17 	ldw	r2,-8(fp)
81110bfc:	00c00284 	movi	r3,10
81110c00:	10c02d15 	stw	r3,180(r2)

				break;
81110c04:	00001e06 	br	81110c80 <vQCmdFeeRMAPWaitingSync+0x438>
			case 6:
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c08:	00a045f4 	movhi	r2,33047
81110c0c:	10a00404 	addi	r2,r2,-32752
81110c10:	10800e8b 	ldhu	r2,58(r2)
81110c14:	10bfffcc 	andi	r2,r2,65535
81110c18:	10800168 	cmpgeui	r2,r2,5
81110c1c:	1000151e 	bne	r2,zero,81110c74 <vQCmdFeeRMAPWaitingSync+0x42c>
					fprintf(fp," Off-Mode not allowed.\n");
81110c20:	d0a06217 	ldw	r2,-32376(gp)
81110c24:	100f883a 	mov	r7,r2
81110c28:	018005c4 	movi	r6,23
81110c2c:	01400044 	movi	r5,1
81110c30:	01204574 	movhi	r4,33045
81110c34:	21384f04 	addi	r4,r4,-7876
81110c38:	11230300 	call	81123030 <fwrite>
				}
			#endif
				break;
81110c3c:	00000d06 	br	81110c74 <vQCmdFeeRMAPWaitingSync+0x42c>
			case 3:
			case 4:
			case 5:
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c40:	00a045f4 	movhi	r2,33047
81110c44:	10a00404 	addi	r2,r2,-32752
81110c48:	10800e8b 	ldhu	r2,58(r2)
81110c4c:	10bfffcc 	andi	r2,r2,65535
81110c50:	10800168 	cmpgeui	r2,r2,5
81110c54:	1000091e 	bne	r2,zero,81110c7c <vQCmdFeeRMAPWaitingSync+0x434>
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81110c58:	d0a06217 	ldw	r2,-32376(gp)
81110c5c:	e1bffc17 	ldw	r6,-16(fp)
81110c60:	01604574 	movhi	r5,33045
81110c64:	29785504 	addi	r5,r5,-7852
81110c68:	1009883a 	mov	r4,r2
81110c6c:	11229940 	call	81122994 <fprintf>
				}
				#endif
				break;
81110c70:	00000206 	br	81110c7c <vQCmdFeeRMAPWaitingSync+0x434>
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," Off-Mode not allowed.\n");
				}
			#endif
				break;
81110c74:	0001883a 	nop
81110c78:	00004e06 	br	81110db4 <vQCmdFeeRMAPWaitingSync+0x56c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
				}
				#endif
				break;
81110c7c:	0001883a 	nop
		}

			break;
81110c80:	00004c06 	br	81110db4 <vQCmdFeeRMAPWaitingSync+0x56c>
		case 2: /* PAttern Full image */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c84:	00a045f4 	movhi	r2,33047
81110c88:	10a00404 	addi	r2,r2,-32752
81110c8c:	10800e8b 	ldhu	r2,58(r2)
81110c90:	10bfffcc 	andi	r2,r2,65535
81110c94:	10800168 	cmpgeui	r2,r2,5
81110c98:	1000091e 	bne	r2,zero,81110cc0 <vQCmdFeeRMAPWaitingSync+0x478>
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110c9c:	d0e06217 	ldw	r3,-32376(gp)
81110ca0:	e0bffe17 	ldw	r2,-8(fp)
81110ca4:	10800003 	ldbu	r2,0(r2)
81110ca8:	10803fcc 	andi	r2,r2,255
81110cac:	100d883a 	mov	r6,r2
81110cb0:	01604574 	movhi	r5,33045
81110cb4:	29779004 	addi	r5,r5,-8640
81110cb8:	1809883a 	mov	r4,r3
81110cbc:	11229940 	call	81122994 <fprintf>
			}
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
81110cc0:	e0bffe17 	ldw	r2,-8(fp)
81110cc4:	00c00044 	movi	r3,1
81110cc8:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81110ccc:	e0bffe17 	ldw	r2,-8(fp)
81110cd0:	00c00284 	movi	r3,10
81110cd4:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
81110cd8:	e0bffe17 	ldw	r2,-8(fp)
81110cdc:	00c00304 	movi	r3,12
81110ce0:	10c02d15 	stw	r3,180(r2)

			break;
81110ce4:	00003306 	br	81110db4 <vQCmdFeeRMAPWaitingSync+0x56c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110ce8:	e0bffa43 	ldbu	r2,-23(fp)
81110cec:	1080010c 	andi	r2,r2,4
81110cf0:	10803fcc 	andi	r2,r2,255
81110cf4:	1004d0ba 	srli	r2,r2,2
81110cf8:	10803fcc 	andi	r2,r2,255
81110cfc:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81110d00:	e0bffc17 	ldw	r2,-16(fp)
81110d04:	10002826 	beq	r2,zero,81110da8 <vQCmdFeeRMAPWaitingSync+0x560>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110d08:	e0bffe17 	ldw	r2,-8(fp)
81110d0c:	10802d17 	ldw	r2,180(r2)
81110d10:	10800198 	cmpnei	r2,r2,6
81110d14:	1000241e 	bne	r2,zero,81110da8 <vQCmdFeeRMAPWaitingSync+0x560>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110d18:	e0bffe17 	ldw	r2,-8(fp)
81110d1c:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110d20:	e0bffe17 	ldw	r2,-8(fp)
81110d24:	10c02d17 	ldw	r3,180(r2)
81110d28:	e0bffe17 	ldw	r2,-8(fp)
81110d2c:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110d30:	00a045f4 	movhi	r2,33047
81110d34:	10a00404 	addi	r2,r2,-32752
81110d38:	10800e8b 	ldhu	r2,58(r2)
81110d3c:	10bfffcc 	andi	r2,r2,65535
81110d40:	10800168 	cmpgeui	r2,r2,5
81110d44:	1000181e 	bne	r2,zero,81110da8 <vQCmdFeeRMAPWaitingSync+0x560>
						fprintf(fp," - Mode Forced.\n");
81110d48:	d0a06217 	ldw	r2,-32376(gp)
81110d4c:	100f883a 	mov	r7,r2
81110d50:	01800404 	movi	r6,16
81110d54:	01400044 	movi	r5,1
81110d58:	01204574 	movhi	r4,33045
81110d5c:	21385d04 	addi	r4,r4,-7820
81110d60:	11230300 	call	81123030 <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110d64:	00001006 	br	81110da8 <vQCmdFeeRMAPWaitingSync+0x560>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110d68:	00a045f4 	movhi	r2,33047
81110d6c:	10a00404 	addi	r2,r2,-32752
81110d70:	10800e8b 	ldhu	r2,58(r2)
81110d74:	10bfffcc 	andi	r2,r2,65535
81110d78:	108001e8 	cmpgeui	r2,r2,7
81110d7c:	10000c1e 	bne	r2,zero,81110db0 <vQCmdFeeRMAPWaitingSync+0x568>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110d80:	d0a06217 	ldw	r2,-32376(gp)
81110d84:	e0fffa03 	ldbu	r3,-24(fp)
81110d88:	180d883a 	mov	r6,r3
81110d8c:	01604574 	movhi	r5,33045
81110d90:	29781e04 	addi	r5,r5,-8072
81110d94:	1009883a 	mov	r4,r2
81110d98:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
81110d9c:	00000406 	br	81110db0 <vQCmdFeeRMAPWaitingSync+0x568>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
81110da0:	0001883a 	nop
81110da4:	00000306 	br	81110db4 <vQCmdFeeRMAPWaitingSync+0x56c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110da8:	0001883a 	nop
81110dac:	00000106 	br	81110db4 <vQCmdFeeRMAPWaitingSync+0x56c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81110db0:	0001883a 	nop
		}
}
81110db4:	0001883a 	nop
81110db8:	e037883a 	mov	sp,fp
81110dbc:	dfc00117 	ldw	ra,4(sp)
81110dc0:	df000017 	ldw	fp,0(sp)
81110dc4:	dec00204 	addi	sp,sp,8
81110dc8:	f800283a 	ret

81110dcc <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110dcc:	defffc04 	addi	sp,sp,-16
81110dd0:	de00012e 	bgeu	sp,et,81110dd8 <bDisableRmapIRQ+0xc>
81110dd4:	003b68fa 	trap	3
81110dd8:	dfc00315 	stw	ra,12(sp)
81110ddc:	df000215 	stw	fp,8(sp)
81110de0:	df000204 	addi	fp,sp,8
81110de4:	e13ffe15 	stw	r4,-8(fp)
81110de8:	2805883a 	mov	r2,r5
81110dec:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
81110df0:	e13ffe17 	ldw	r4,-8(fp)
81110df4:	11078740 	call	81107874 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81110df8:	e0bffe17 	ldw	r2,-8(fp)
81110dfc:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110e00:	e13ffe17 	ldw	r4,-8(fp)
81110e04:	11077cc0 	call	811077cc <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110e08:	00800044 	movi	r2,1
}
81110e0c:	e037883a 	mov	sp,fp
81110e10:	dfc00117 	ldw	ra,4(sp)
81110e14:	df000017 	ldw	fp,0(sp)
81110e18:	dec00204 	addi	sp,sp,8
81110e1c:	f800283a 	ret

81110e20 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110e20:	defffc04 	addi	sp,sp,-16
81110e24:	de00012e 	bgeu	sp,et,81110e2c <bEnableRmapIRQ+0xc>
81110e28:	003b68fa 	trap	3
81110e2c:	dfc00315 	stw	ra,12(sp)
81110e30:	df000215 	stw	fp,8(sp)
81110e34:	df000204 	addi	fp,sp,8
81110e38:	e13ffe15 	stw	r4,-8(fp)
81110e3c:	2805883a 	mov	r2,r5
81110e40:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
81110e44:	e13ffe17 	ldw	r4,-8(fp)
81110e48:	11078740 	call	81107874 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81110e4c:	e0bffe17 	ldw	r2,-8(fp)
81110e50:	00c00044 	movi	r3,1
81110e54:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110e58:	e13ffe17 	ldw	r4,-8(fp)
81110e5c:	11077cc0 	call	811077cc <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110e60:	00800044 	movi	r2,1
}
81110e64:	e037883a 	mov	sp,fp
81110e68:	dfc00117 	ldw	ra,4(sp)
81110e6c:	df000017 	ldw	fp,0(sp)
81110e70:	dec00204 	addi	sp,sp,8
81110e74:	f800283a 	ret

81110e78 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
81110e78:	defffd04 	addi	sp,sp,-12
81110e7c:	de00012e 	bgeu	sp,et,81110e84 <bDisableSPWChannel+0xc>
81110e80:	003b68fa 	trap	3
81110e84:	dfc00215 	stw	ra,8(sp)
81110e88:	df000115 	stw	fp,4(sp)
81110e8c:	df000104 	addi	fp,sp,4
81110e90:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
81110e94:	e13fff17 	ldw	r4,-4(fp)
81110e98:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110e9c:	e0bfff17 	ldw	r2,-4(fp)
81110ea0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
81110ea4:	e0bfff17 	ldw	r2,-4(fp)
81110ea8:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
81110eac:	e0bfff17 	ldw	r2,-4(fp)
81110eb0:	00c00044 	movi	r3,1
81110eb4:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
81110eb8:	e13fff17 	ldw	r4,-4(fp)
81110ebc:	110a0c40 	call	8110a0c4 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110ec0:	00800044 	movi	r2,1
}
81110ec4:	e037883a 	mov	sp,fp
81110ec8:	dfc00117 	ldw	ra,4(sp)
81110ecc:	df000017 	ldw	fp,0(sp)
81110ed0:	dec00204 	addi	sp,sp,8
81110ed4:	f800283a 	ret

81110ed8 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
81110ed8:	defffd04 	addi	sp,sp,-12
81110edc:	de00012e 	bgeu	sp,et,81110ee4 <bEnableSPWChannel+0xc>
81110ee0:	003b68fa 	trap	3
81110ee4:	dfc00215 	stw	ra,8(sp)
81110ee8:	df000115 	stw	fp,4(sp)
81110eec:	df000104 	addi	fp,sp,4
81110ef0:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
81110ef4:	e13fff17 	ldw	r4,-4(fp)
81110ef8:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110efc:	e0bfff17 	ldw	r2,-4(fp)
81110f00:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
81110f04:	e0bfff17 	ldw	r2,-4(fp)
81110f08:	00c00044 	movi	r3,1
81110f0c:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
81110f10:	e0bfff17 	ldw	r2,-4(fp)
81110f14:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
81110f18:	e13fff17 	ldw	r4,-4(fp)
81110f1c:	110a0c40 	call	8110a0c4 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110f20:	00800044 	movi	r2,1
}
81110f24:	e037883a 	mov	sp,fp
81110f28:	dfc00117 	ldw	ra,4(sp)
81110f2c:	df000017 	ldw	fp,0(sp)
81110f30:	dec00204 	addi	sp,sp,8
81110f34:	f800283a 	ret

81110f38 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
81110f38:	defffd04 	addi	sp,sp,-12
81110f3c:	de00012e 	bgeu	sp,et,81110f44 <bEnableDbBuffer+0xc>
81110f40:	003b68fa 	trap	3
81110f44:	dfc00215 	stw	ra,8(sp)
81110f48:	df000115 	stw	fp,4(sp)
81110f4c:	df000104 	addi	fp,sp,4
81110f50:	e13fff15 	stw	r4,-4(fp)
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81110f54:	e13fff17 	ldw	r4,-4(fp)
81110f58:	11068900 	call	81106890 <bFeebStopCh>
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81110f5c:	e13fff17 	ldw	r4,-4(fp)
81110f60:	11069180 	call	81106918 <bFeebClrCh>
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
81110f64:	e13fff17 	ldw	r4,-4(fp)
81110f68:	11068080 	call	81106808 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
81110f6c:	e13fff17 	ldw	r4,-4(fp)
81110f70:	11067800 	call	81106780 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
81110f74:	00a045f4 	movhi	r2,33047
81110f78:	10a00404 	addi	r2,r2,-32752
81110f7c:	10c00817 	ldw	r3,32(r2)
81110f80:	e0bfff17 	ldw	r2,-4(fp)
81110f84:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81110f88:	e13fff17 	ldw	r4,-4(fp)
81110f8c:	11066d80 	call	811066d8 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81110f90:	e13fff17 	ldw	r4,-4(fp)
81110f94:	11061280 	call	81106128 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81110f98:	e0bfff17 	ldw	r2,-4(fp)
81110f9c:	00c00044 	movi	r3,1
81110fa0:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81110fa4:	e0bfff17 	ldw	r2,-4(fp)
81110fa8:	00c00044 	movi	r3,1
81110fac:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81110fb0:	e13fff17 	ldw	r4,-4(fp)
81110fb4:	11060540 	call	81106054 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110fb8:	00800044 	movi	r2,1
}
81110fbc:	e037883a 	mov	sp,fp
81110fc0:	dfc00117 	ldw	ra,4(sp)
81110fc4:	df000017 	ldw	fp,0(sp)
81110fc8:	dec00204 	addi	sp,sp,8
81110fcc:	f800283a 	ret

81110fd0 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
81110fd0:	defffd04 	addi	sp,sp,-12
81110fd4:	de00012e 	bgeu	sp,et,81110fdc <bDisAndClrDbBuffer+0xc>
81110fd8:	003b68fa 	trap	3
81110fdc:	dfc00215 	stw	ra,8(sp)
81110fe0:	df000115 	stw	fp,4(sp)
81110fe4:	df000104 	addi	fp,sp,4
81110fe8:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81110fec:	e13fff17 	ldw	r4,-4(fp)
81110ff0:	11061280 	call	81106128 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81110ff4:	e0bfff17 	ldw	r2,-4(fp)
81110ff8:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81110ffc:	e0bfff17 	ldw	r2,-4(fp)
81111000:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81111004:	e13fff17 	ldw	r4,-4(fp)
81111008:	11060540 	call	81106054 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8111100c:	e13fff17 	ldw	r4,-4(fp)
81111010:	11068900 	call	81106890 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81111014:	e13fff17 	ldw	r4,-4(fp)
81111018:	11069180 	call	81106918 <bFeebClrCh>
	bFeebStartCh(pxFeebCh);
8111101c:	e13fff17 	ldw	r4,-4(fp)
81111020:	11068080 	call	81106808 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
81111024:	00800044 	movi	r2,1
}
81111028:	e037883a 	mov	sp,fp
8111102c:	dfc00117 	ldw	ra,4(sp)
81111030:	df000017 	ldw	fp,0(sp)
81111034:	dec00204 	addi	sp,sp,8
81111038:	f800283a 	ret

8111103c <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111103c:	defff804 	addi	sp,sp,-32
81111040:	de00012e 	bgeu	sp,et,81111048 <bSendRequestNFeeCtrl+0xc>
81111044:	003b68fa 	trap	3
81111048:	dfc00715 	stw	ra,28(sp)
8111104c:	df000615 	stw	fp,24(sp)
81111050:	df000604 	addi	fp,sp,24
81111054:	2807883a 	mov	r3,r5
81111058:	3005883a 	mov	r2,r6
8111105c:	e13ffd05 	stb	r4,-12(fp)
81111060:	e0fffe05 	stb	r3,-8(fp)
81111064:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111068:	00800404 	movi	r2,16
8111106c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111070:	e0bffd03 	ldbu	r2,-12(fp)
81111074:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111078:	e0bffe03 	ldbu	r2,-8(fp)
8111107c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111080:	e0bfff03 	ldbu	r2,-4(fp)
81111084:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111088:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8111108c:	d0a05d17 	ldw	r2,-32396(gp)
81111090:	e0fffc17 	ldw	r3,-16(fp)
81111094:	180b883a 	mov	r5,r3
81111098:	1009883a 	mov	r4,r2
8111109c:	113f3440 	call	8113f344 <OSQPost>
811110a0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811110a4:	e0bffb03 	ldbu	r2,-20(fp)
811110a8:	10000526 	beq	r2,zero,811110c0 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
811110ac:	e0bfff03 	ldbu	r2,-4(fp)
811110b0:	1009883a 	mov	r4,r2
811110b4:	111e73c0 	call	8111e73c <vFailRequestDMA>
		bSuccesL = FALSE;
811110b8:	e03ffa15 	stw	zero,-24(fp)
811110bc:	00000206 	br	811110c8 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
811110c0:	00800044 	movi	r2,1
811110c4:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
811110c8:	e0bffa17 	ldw	r2,-24(fp)
}
811110cc:	e037883a 	mov	sp,fp
811110d0:	dfc00117 	ldw	ra,4(sp)
811110d4:	df000017 	ldw	fp,0(sp)
811110d8:	dec00204 	addi	sp,sp,8
811110dc:	f800283a 	ret

811110e0 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811110e0:	defff804 	addi	sp,sp,-32
811110e4:	de00012e 	bgeu	sp,et,811110ec <bSendGiveBackNFeeCtrl+0xc>
811110e8:	003b68fa 	trap	3
811110ec:	dfc00715 	stw	ra,28(sp)
811110f0:	df000615 	stw	fp,24(sp)
811110f4:	df000604 	addi	fp,sp,24
811110f8:	2807883a 	mov	r3,r5
811110fc:	3005883a 	mov	r2,r6
81111100:	e13ffd05 	stb	r4,-12(fp)
81111104:	e0fffe05 	stb	r3,-8(fp)
81111108:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111110c:	00800404 	movi	r2,16
81111110:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111114:	e0bffd03 	ldbu	r2,-12(fp)
81111118:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111111c:	e0bffe03 	ldbu	r2,-8(fp)
81111120:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111124:	e0bfff03 	ldbu	r2,-4(fp)
81111128:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8111112c:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111130:	d0a07017 	ldw	r2,-32320(gp)
81111134:	e0fffc17 	ldw	r3,-16(fp)
81111138:	180b883a 	mov	r5,r3
8111113c:	1009883a 	mov	r4,r2
81111140:	113f3440 	call	8113f344 <OSQPost>
81111144:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111148:	e0bffb03 	ldbu	r2,-20(fp)
8111114c:	10000526 	beq	r2,zero,81111164 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81111150:	e0bfff03 	ldbu	r2,-4(fp)
81111154:	1009883a 	mov	r4,r2
81111158:	111e73c0 	call	8111e73c <vFailRequestDMA>
		bSuccesL = FALSE;
8111115c:	e03ffa15 	stw	zero,-24(fp)
81111160:	00000206 	br	8111116c <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81111164:	00800044 	movi	r2,1
81111168:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8111116c:	e0bffa17 	ldw	r2,-24(fp)
}
81111170:	e037883a 	mov	sp,fp
81111174:	dfc00117 	ldw	ra,4(sp)
81111178:	df000017 	ldw	fp,0(sp)
8111117c:	dec00204 	addi	sp,sp,8
81111180:	f800283a 	ret

81111184 <vPrintConsoleNFee>:




#if DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81111184:	defffa04 	addi	sp,sp,-24
81111188:	de00012e 	bgeu	sp,et,81111190 <vPrintConsoleNFee+0xc>
8111118c:	003b68fa 	trap	3
81111190:	dfc00515 	stw	ra,20(sp)
81111194:	df000415 	stw	fp,16(sp)
81111198:	df000404 	addi	fp,sp,16
8111119c:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
811111a0:	e0bfff17 	ldw	r2,-4(fp)
811111a4:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
811111a8:	d0e06217 	ldw	r3,-32376(gp)
811111ac:	e0bffe17 	ldw	r2,-8(fp)
811111b0:	10800003 	ldbu	r2,0(r2)
811111b4:	10803fcc 	andi	r2,r2,255
811111b8:	100d883a 	mov	r6,r2
811111bc:	01604574 	movhi	r5,33045
811111c0:	29786f04 	addi	r5,r5,-7748
811111c4:	1809883a 	mov	r4,r3
811111c8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
811111cc:	d0a06217 	ldw	r2,-32376(gp)
811111d0:	100b883a 	mov	r5,r2
811111d4:	01000284 	movi	r4,10
811111d8:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
811111dc:	d0e06217 	ldw	r3,-32376(gp)
811111e0:	e0bffe17 	ldw	r2,-8(fp)
811111e4:	10800003 	ldbu	r2,0(r2)
811111e8:	10803fcc 	andi	r2,r2,255
811111ec:	100d883a 	mov	r6,r2
811111f0:	01604574 	movhi	r5,33045
811111f4:	29788404 	addi	r5,r5,-7664
811111f8:	1809883a 	mov	r4,r3
811111fc:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81111200:	d0e06217 	ldw	r3,-32376(gp)
81111204:	e0bffe17 	ldw	r2,-8(fp)
81111208:	10802f0b 	ldhu	r2,188(r2)
8111120c:	10bfffcc 	andi	r2,r2,65535
81111210:	100d883a 	mov	r6,r2
81111214:	01604574 	movhi	r5,33045
81111218:	29788a04 	addi	r5,r5,-7640
8111121c:	1809883a 	mov	r4,r3
81111220:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
81111224:	d0e06217 	ldw	r3,-32376(gp)
81111228:	e0bffe17 	ldw	r2,-8(fp)
8111122c:	10802f8b 	ldhu	r2,190(r2)
81111230:	10bfffcc 	andi	r2,r2,65535
81111234:	100d883a 	mov	r6,r2
81111238:	01604574 	movhi	r5,33045
8111123c:	29788f04 	addi	r5,r5,-7620
81111240:	1809883a 	mov	r4,r3
81111244:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81111248:	d0e06217 	ldw	r3,-32376(gp)
8111124c:	e0bffe17 	ldw	r2,-8(fp)
81111250:	1080300b 	ldhu	r2,192(r2)
81111254:	10bfffcc 	andi	r2,r2,65535
81111258:	100d883a 	mov	r6,r2
8111125c:	01604574 	movhi	r5,33045
81111260:	29789504 	addi	r5,r5,-7596
81111264:	1809883a 	mov	r4,r3
81111268:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8111126c:	d0e06217 	ldw	r3,-32376(gp)
81111270:	e0bffe17 	ldw	r2,-8(fp)
81111274:	1080308b 	ldhu	r2,194(r2)
81111278:	10bfffcc 	andi	r2,r2,65535
8111127c:	100d883a 	mov	r6,r2
81111280:	01604574 	movhi	r5,33045
81111284:	29789904 	addi	r5,r5,-7580
81111288:	1809883a 	mov	r4,r3
8111128c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81111290:	d0e06217 	ldw	r3,-32376(gp)
81111294:	e0bffe17 	ldw	r2,-8(fp)
81111298:	1080310b 	ldhu	r2,196(r2)
8111129c:	10bfffcc 	andi	r2,r2,65535
811112a0:	100d883a 	mov	r6,r2
811112a4:	01604574 	movhi	r5,33045
811112a8:	29789f04 	addi	r5,r5,-7556
811112ac:	1809883a 	mov	r4,r3
811112b0:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
811112b4:	d0a06217 	ldw	r2,-32376(gp)
811112b8:	100b883a 	mov	r5,r2
811112bc:	01000284 	movi	r4,10
811112c0:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
811112c4:	d0e06217 	ldw	r3,-32376(gp)
811112c8:	e0bffe17 	ldw	r2,-8(fp)
811112cc:	10800003 	ldbu	r2,0(r2)
811112d0:	10803fcc 	andi	r2,r2,255
811112d4:	100d883a 	mov	r6,r2
811112d8:	01604574 	movhi	r5,33045
811112dc:	2978a404 	addi	r5,r5,-7536
811112e0:	1809883a 	mov	r4,r3
811112e4:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
811112e8:	d0e06217 	ldw	r3,-32376(gp)
811112ec:	e0bffe17 	ldw	r2,-8(fp)
811112f0:	10802c17 	ldw	r2,176(r2)
811112f4:	100d883a 	mov	r6,r2
811112f8:	01604574 	movhi	r5,33045
811112fc:	2978aa04 	addi	r5,r5,-7512
81111300:	1809883a 	mov	r4,r3
81111304:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81111308:	d0e06217 	ldw	r3,-32376(gp)
8111130c:	e0bffe17 	ldw	r2,-8(fp)
81111310:	10802117 	ldw	r2,132(r2)
81111314:	100d883a 	mov	r6,r2
81111318:	01604574 	movhi	r5,33045
8111131c:	2978b004 	addi	r5,r5,-7488
81111320:	1809883a 	mov	r4,r3
81111324:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81111328:	d0e06217 	ldw	r3,-32376(gp)
8111132c:	e0bffe17 	ldw	r2,-8(fp)
81111330:	10802317 	ldw	r2,140(r2)
81111334:	100d883a 	mov	r6,r2
81111338:	01604574 	movhi	r5,33045
8111133c:	2978b704 	addi	r5,r5,-7460
81111340:	1809883a 	mov	r4,r3
81111344:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81111348:	d0e06217 	ldw	r3,-32376(gp)
8111134c:	e0bffe17 	ldw	r2,-8(fp)
81111350:	10802417 	ldw	r2,144(r2)
81111354:	100d883a 	mov	r6,r2
81111358:	01604574 	movhi	r5,33045
8111135c:	2978be04 	addi	r5,r5,-7432
81111360:	1809883a 	mov	r4,r3
81111364:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81111368:	d0e06217 	ldw	r3,-32376(gp)
8111136c:	e0bffe17 	ldw	r2,-8(fp)
81111370:	10802517 	ldw	r2,148(r2)
81111374:	100d883a 	mov	r6,r2
81111378:	01604574 	movhi	r5,33045
8111137c:	2978c504 	addi	r5,r5,-7404
81111380:	1809883a 	mov	r4,r3
81111384:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81111388:	d0e06217 	ldw	r3,-32376(gp)
8111138c:	e0bffe17 	ldw	r2,-8(fp)
81111390:	10802617 	ldw	r2,152(r2)
81111394:	100d883a 	mov	r6,r2
81111398:	01604574 	movhi	r5,33045
8111139c:	2978cc04 	addi	r5,r5,-7376
811113a0:	1809883a 	mov	r4,r3
811113a4:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
811113a8:	d1206217 	ldw	r4,-32376(gp)
811113ac:	e0bffe17 	ldw	r2,-8(fp)
811113b0:	10802a43 	ldbu	r2,169(r2)
811113b4:	11403fcc 	andi	r5,r2,255
811113b8:	e0bffe17 	ldw	r2,-8(fp)
811113bc:	10802a83 	ldbu	r2,170(r2)
811113c0:	11803fcc 	andi	r6,r2,255
811113c4:	e0bffe17 	ldw	r2,-8(fp)
811113c8:	10802ac3 	ldbu	r2,171(r2)
811113cc:	10803fcc 	andi	r2,r2,255
811113d0:	e0fffe17 	ldw	r3,-8(fp)
811113d4:	18c02b03 	ldbu	r3,172(r3)
811113d8:	18c03fcc 	andi	r3,r3,255
811113dc:	d8c00115 	stw	r3,4(sp)
811113e0:	d8800015 	stw	r2,0(sp)
811113e4:	300f883a 	mov	r7,r6
811113e8:	280d883a 	mov	r6,r5
811113ec:	01604574 	movhi	r5,33045
811113f0:	2978d304 	addi	r5,r5,-7348
811113f4:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
811113f8:	d0e06217 	ldw	r3,-32376(gp)
811113fc:	e0bffe17 	ldw	r2,-8(fp)
81111400:	10802e17 	ldw	r2,184(r2)
81111404:	100d883a 	mov	r6,r2
81111408:	01604574 	movhi	r5,33045
8111140c:	2978e004 	addi	r5,r5,-7296
81111410:	1809883a 	mov	r4,r3
81111414:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n\n");
81111418:	d0a06217 	ldw	r2,-32376(gp)
8111141c:	100f883a 	mov	r7,r2
81111420:	01800084 	movi	r6,2
81111424:	01400044 	movi	r5,1
81111428:	01204574 	movhi	r4,33045
8111142c:	2138e604 	addi	r4,r4,-7272
81111430:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81111434:	d0e06217 	ldw	r3,-32376(gp)
81111438:	e0bffe17 	ldw	r2,-8(fp)
8111143c:	10800003 	ldbu	r2,0(r2)
81111440:	10803fcc 	andi	r2,r2,255
81111444:	100d883a 	mov	r6,r2
81111448:	01604574 	movhi	r5,33045
8111144c:	2978e704 	addi	r5,r5,-7268
81111450:	1809883a 	mov	r4,r3
81111454:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    General Info: \n");
81111458:	d0a06217 	ldw	r2,-32376(gp)
8111145c:	100f883a 	mov	r7,r2
81111460:	018004c4 	movi	r6,19
81111464:	01400044 	movi	r5,1
81111468:	01204574 	movhi	r4,33045
8111146c:	2138ed04 	addi	r4,r4,-7244
81111470:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81111474:	d0e06217 	ldw	r3,-32376(gp)
81111478:	e0bffe17 	ldw	r2,-8(fp)
8111147c:	10800117 	ldw	r2,4(r2)
81111480:	100d883a 	mov	r6,r2
81111484:	01604574 	movhi	r5,33045
81111488:	2978f204 	addi	r5,r5,-7224
8111148c:	1809883a 	mov	r4,r3
81111490:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81111494:	d0e06217 	ldw	r3,-32376(gp)
81111498:	e0bffe17 	ldw	r2,-8(fp)
8111149c:	10800217 	ldw	r2,8(r2)
811114a0:	100d883a 	mov	r6,r2
811114a4:	01604574 	movhi	r5,33045
811114a8:	2978fa04 	addi	r5,r5,-7192
811114ac:	1809883a 	mov	r4,r3
811114b0:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
811114b4:	d0e06217 	ldw	r3,-32376(gp)
811114b8:	e0bffe17 	ldw	r2,-8(fp)
811114bc:	10800317 	ldw	r2,12(r2)
811114c0:	100d883a 	mov	r6,r2
811114c4:	01604574 	movhi	r5,33045
811114c8:	29790204 	addi	r5,r5,-7160
811114cc:	1809883a 	mov	r4,r3
811114d0:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
811114d4:	d0a06217 	ldw	r2,-32376(gp)
811114d8:	100f883a 	mov	r7,r2
811114dc:	01800644 	movi	r6,25
811114e0:	01400044 	movi	r5,1
811114e4:	01204574 	movhi	r4,33045
811114e8:	21390904 	addi	r4,r4,-7132
811114ec:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
811114f0:	d0e06217 	ldw	r3,-32376(gp)
811114f4:	e0bffe17 	ldw	r2,-8(fp)
811114f8:	10800517 	ldw	r2,20(r2)
811114fc:	100d883a 	mov	r6,r2
81111500:	01604574 	movhi	r5,33045
81111504:	29791004 	addi	r5,r5,-7104
81111508:	1809883a 	mov	r4,r3
8111150c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81111510:	d0e06217 	ldw	r3,-32376(gp)
81111514:	e0bffe17 	ldw	r2,-8(fp)
81111518:	10800417 	ldw	r2,16(r2)
8111151c:	100d883a 	mov	r6,r2
81111520:	01604574 	movhi	r5,33045
81111524:	29791804 	addi	r5,r5,-7072
81111528:	1809883a 	mov	r4,r3
8111152c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81111530:	d0e06217 	ldw	r3,-32376(gp)
81111534:	e0bffe17 	ldw	r2,-8(fp)
81111538:	10800603 	ldbu	r2,24(r2)
8111153c:	10803fcc 	andi	r2,r2,255
81111540:	100d883a 	mov	r6,r2
81111544:	01604574 	movhi	r5,33045
81111548:	29792004 	addi	r5,r5,-7040
8111154c:	1809883a 	mov	r4,r3
81111550:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81111554:	d2206217 	ldw	r8,-32376(gp)
81111558:	e13ffe17 	ldw	r4,-8(fp)
8111155c:	20800717 	ldw	r2,28(r4)
81111560:	20c00817 	ldw	r3,32(r4)
81111564:	100d883a 	mov	r6,r2
81111568:	180f883a 	mov	r7,r3
8111156c:	01604574 	movhi	r5,33045
81111570:	29792804 	addi	r5,r5,-7008
81111574:	4009883a 	mov	r4,r8
81111578:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
8111157c:	d0a06217 	ldw	r2,-32376(gp)
81111580:	100b883a 	mov	r5,r2
81111584:	01000284 	movi	r4,10
81111588:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8111158c:	d0e06217 	ldw	r3,-32376(gp)
81111590:	e0bffe17 	ldw	r2,-8(fp)
81111594:	10800003 	ldbu	r2,0(r2)
81111598:	10803fcc 	andi	r2,r2,255
8111159c:	100f883a 	mov	r7,r2
811115a0:	000d883a 	mov	r6,zero
811115a4:	01604574 	movhi	r5,33045
811115a8:	29793004 	addi	r5,r5,-6976
811115ac:	1809883a 	mov	r4,r3
811115b0:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Left side \n");
811115b4:	d0a06217 	ldw	r2,-32376(gp)
811115b8:	100f883a 	mov	r7,r2
811115bc:	018004c4 	movi	r6,19
811115c0:	01400044 	movi	r5,1
811115c4:	01204574 	movhi	r4,33045
811115c8:	21393a04 	addi	r4,r4,-6936
811115cc:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
811115d0:	d0e06217 	ldw	r3,-32376(gp)
811115d4:	e0bffe17 	ldw	r2,-8(fp)
811115d8:	10800917 	ldw	r2,36(r2)
811115dc:	100d883a 	mov	r6,r2
811115e0:	01604574 	movhi	r5,33045
811115e4:	29793f04 	addi	r5,r5,-6916
811115e8:	1809883a 	mov	r4,r3
811115ec:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
811115f0:	d0e06217 	ldw	r3,-32376(gp)
811115f4:	e0bffe17 	ldw	r2,-8(fp)
811115f8:	10800a17 	ldw	r2,40(r2)
811115fc:	100d883a 	mov	r6,r2
81111600:	01604574 	movhi	r5,33045
81111604:	29794804 	addi	r5,r5,-6880
81111608:	1809883a 	mov	r4,r3
8111160c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81111610:	d0e06217 	ldw	r3,-32376(gp)
81111614:	e0bffe17 	ldw	r2,-8(fp)
81111618:	10800b17 	ldw	r2,44(r2)
8111161c:	100d883a 	mov	r6,r2
81111620:	01604574 	movhi	r5,33045
81111624:	29795304 	addi	r5,r5,-6836
81111628:	1809883a 	mov	r4,r3
8111162c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Right side \n");
81111630:	d0a06217 	ldw	r2,-32376(gp)
81111634:	100f883a 	mov	r7,r2
81111638:	01800504 	movi	r6,20
8111163c:	01400044 	movi	r5,1
81111640:	01204574 	movhi	r4,33045
81111644:	21395f04 	addi	r4,r4,-6788
81111648:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8111164c:	d0e06217 	ldw	r3,-32376(gp)
81111650:	e0bffe17 	ldw	r2,-8(fp)
81111654:	10800c17 	ldw	r2,48(r2)
81111658:	100d883a 	mov	r6,r2
8111165c:	01604574 	movhi	r5,33045
81111660:	29793f04 	addi	r5,r5,-6916
81111664:	1809883a 	mov	r4,r3
81111668:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8111166c:	d0e06217 	ldw	r3,-32376(gp)
81111670:	e0bffe17 	ldw	r2,-8(fp)
81111674:	10800d17 	ldw	r2,52(r2)
81111678:	100d883a 	mov	r6,r2
8111167c:	01604574 	movhi	r5,33045
81111680:	29794804 	addi	r5,r5,-6880
81111684:	1809883a 	mov	r4,r3
81111688:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8111168c:	d0e06217 	ldw	r3,-32376(gp)
81111690:	e0bffe17 	ldw	r2,-8(fp)
81111694:	10800e17 	ldw	r2,56(r2)
81111698:	100d883a 	mov	r6,r2
8111169c:	01604574 	movhi	r5,33045
811116a0:	29795304 	addi	r5,r5,-6836
811116a4:	1809883a 	mov	r4,r3
811116a8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
811116ac:	d0a06217 	ldw	r2,-32376(gp)
811116b0:	100b883a 	mov	r5,r2
811116b4:	01000284 	movi	r4,10
811116b8:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
811116bc:	d0e06217 	ldw	r3,-32376(gp)
811116c0:	e0bffe17 	ldw	r2,-8(fp)
811116c4:	10800003 	ldbu	r2,0(r2)
811116c8:	10803fcc 	andi	r2,r2,255
811116cc:	100f883a 	mov	r7,r2
811116d0:	01800044 	movi	r6,1
811116d4:	01604574 	movhi	r5,33045
811116d8:	29793004 	addi	r5,r5,-6976
811116dc:	1809883a 	mov	r4,r3
811116e0:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Left side \n");
811116e4:	d0a06217 	ldw	r2,-32376(gp)
811116e8:	100f883a 	mov	r7,r2
811116ec:	018004c4 	movi	r6,19
811116f0:	01400044 	movi	r5,1
811116f4:	01204574 	movhi	r4,33045
811116f8:	21393a04 	addi	r4,r4,-6936
811116fc:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81111700:	d0e06217 	ldw	r3,-32376(gp)
81111704:	e0bffe17 	ldw	r2,-8(fp)
81111708:	10800f17 	ldw	r2,60(r2)
8111170c:	100d883a 	mov	r6,r2
81111710:	01604574 	movhi	r5,33045
81111714:	29793f04 	addi	r5,r5,-6916
81111718:	1809883a 	mov	r4,r3
8111171c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81111720:	d0e06217 	ldw	r3,-32376(gp)
81111724:	e0bffe17 	ldw	r2,-8(fp)
81111728:	10801017 	ldw	r2,64(r2)
8111172c:	100d883a 	mov	r6,r2
81111730:	01604574 	movhi	r5,33045
81111734:	29794804 	addi	r5,r5,-6880
81111738:	1809883a 	mov	r4,r3
8111173c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81111740:	d0e06217 	ldw	r3,-32376(gp)
81111744:	e0bffe17 	ldw	r2,-8(fp)
81111748:	10801117 	ldw	r2,68(r2)
8111174c:	100d883a 	mov	r6,r2
81111750:	01604574 	movhi	r5,33045
81111754:	29795304 	addi	r5,r5,-6836
81111758:	1809883a 	mov	r4,r3
8111175c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Right side \n");
81111760:	d0a06217 	ldw	r2,-32376(gp)
81111764:	100f883a 	mov	r7,r2
81111768:	01800504 	movi	r6,20
8111176c:	01400044 	movi	r5,1
81111770:	01204574 	movhi	r4,33045
81111774:	21395f04 	addi	r4,r4,-6788
81111778:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8111177c:	d0e06217 	ldw	r3,-32376(gp)
81111780:	e0bffe17 	ldw	r2,-8(fp)
81111784:	10801217 	ldw	r2,72(r2)
81111788:	100d883a 	mov	r6,r2
8111178c:	01604574 	movhi	r5,33045
81111790:	29793f04 	addi	r5,r5,-6916
81111794:	1809883a 	mov	r4,r3
81111798:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8111179c:	d0e06217 	ldw	r3,-32376(gp)
811117a0:	e0bffe17 	ldw	r2,-8(fp)
811117a4:	10801317 	ldw	r2,76(r2)
811117a8:	100d883a 	mov	r6,r2
811117ac:	01604574 	movhi	r5,33045
811117b0:	29794804 	addi	r5,r5,-6880
811117b4:	1809883a 	mov	r4,r3
811117b8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
811117bc:	d0e06217 	ldw	r3,-32376(gp)
811117c0:	e0bffe17 	ldw	r2,-8(fp)
811117c4:	10801417 	ldw	r2,80(r2)
811117c8:	100d883a 	mov	r6,r2
811117cc:	01604574 	movhi	r5,33045
811117d0:	29795304 	addi	r5,r5,-6836
811117d4:	1809883a 	mov	r4,r3
811117d8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
811117dc:	d0a06217 	ldw	r2,-32376(gp)
811117e0:	100b883a 	mov	r5,r2
811117e4:	01000284 	movi	r4,10
811117e8:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
811117ec:	d0e06217 	ldw	r3,-32376(gp)
811117f0:	e0bffe17 	ldw	r2,-8(fp)
811117f4:	10800003 	ldbu	r2,0(r2)
811117f8:	10803fcc 	andi	r2,r2,255
811117fc:	100f883a 	mov	r7,r2
81111800:	01800084 	movi	r6,2
81111804:	01604574 	movhi	r5,33045
81111808:	29793004 	addi	r5,r5,-6976
8111180c:	1809883a 	mov	r4,r3
81111810:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Left side \n");
81111814:	d0a06217 	ldw	r2,-32376(gp)
81111818:	100f883a 	mov	r7,r2
8111181c:	018004c4 	movi	r6,19
81111820:	01400044 	movi	r5,1
81111824:	01204574 	movhi	r4,33045
81111828:	21393a04 	addi	r4,r4,-6936
8111182c:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81111830:	d0e06217 	ldw	r3,-32376(gp)
81111834:	e0bffe17 	ldw	r2,-8(fp)
81111838:	10801517 	ldw	r2,84(r2)
8111183c:	100d883a 	mov	r6,r2
81111840:	01604574 	movhi	r5,33045
81111844:	29793f04 	addi	r5,r5,-6916
81111848:	1809883a 	mov	r4,r3
8111184c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81111850:	d0e06217 	ldw	r3,-32376(gp)
81111854:	e0bffe17 	ldw	r2,-8(fp)
81111858:	10801617 	ldw	r2,88(r2)
8111185c:	100d883a 	mov	r6,r2
81111860:	01604574 	movhi	r5,33045
81111864:	29794804 	addi	r5,r5,-6880
81111868:	1809883a 	mov	r4,r3
8111186c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81111870:	d0e06217 	ldw	r3,-32376(gp)
81111874:	e0bffe17 	ldw	r2,-8(fp)
81111878:	10801717 	ldw	r2,92(r2)
8111187c:	100d883a 	mov	r6,r2
81111880:	01604574 	movhi	r5,33045
81111884:	29795304 	addi	r5,r5,-6836
81111888:	1809883a 	mov	r4,r3
8111188c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Right side \n");
81111890:	d0a06217 	ldw	r2,-32376(gp)
81111894:	100f883a 	mov	r7,r2
81111898:	01800504 	movi	r6,20
8111189c:	01400044 	movi	r5,1
811118a0:	01204574 	movhi	r4,33045
811118a4:	21395f04 	addi	r4,r4,-6788
811118a8:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
811118ac:	d0e06217 	ldw	r3,-32376(gp)
811118b0:	e0bffe17 	ldw	r2,-8(fp)
811118b4:	10801817 	ldw	r2,96(r2)
811118b8:	100d883a 	mov	r6,r2
811118bc:	01604574 	movhi	r5,33045
811118c0:	29793f04 	addi	r5,r5,-6916
811118c4:	1809883a 	mov	r4,r3
811118c8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
811118cc:	d0e06217 	ldw	r3,-32376(gp)
811118d0:	e0bffe17 	ldw	r2,-8(fp)
811118d4:	10801917 	ldw	r2,100(r2)
811118d8:	100d883a 	mov	r6,r2
811118dc:	01604574 	movhi	r5,33045
811118e0:	29794804 	addi	r5,r5,-6880
811118e4:	1809883a 	mov	r4,r3
811118e8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
811118ec:	d0e06217 	ldw	r3,-32376(gp)
811118f0:	e0bffe17 	ldw	r2,-8(fp)
811118f4:	10801a17 	ldw	r2,104(r2)
811118f8:	100d883a 	mov	r6,r2
811118fc:	01604574 	movhi	r5,33045
81111900:	29795304 	addi	r5,r5,-6836
81111904:	1809883a 	mov	r4,r3
81111908:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
8111190c:	d0a06217 	ldw	r2,-32376(gp)
81111910:	100b883a 	mov	r5,r2
81111914:	01000284 	movi	r4,10
81111918:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8111191c:	d0e06217 	ldw	r3,-32376(gp)
81111920:	e0bffe17 	ldw	r2,-8(fp)
81111924:	10800003 	ldbu	r2,0(r2)
81111928:	10803fcc 	andi	r2,r2,255
8111192c:	100f883a 	mov	r7,r2
81111930:	018000c4 	movi	r6,3
81111934:	01604574 	movhi	r5,33045
81111938:	29793004 	addi	r5,r5,-6976
8111193c:	1809883a 	mov	r4,r3
81111940:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Left side \n");
81111944:	d0a06217 	ldw	r2,-32376(gp)
81111948:	100f883a 	mov	r7,r2
8111194c:	018004c4 	movi	r6,19
81111950:	01400044 	movi	r5,1
81111954:	01204574 	movhi	r4,33045
81111958:	21393a04 	addi	r4,r4,-6936
8111195c:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81111960:	d0e06217 	ldw	r3,-32376(gp)
81111964:	e0bffe17 	ldw	r2,-8(fp)
81111968:	10801b17 	ldw	r2,108(r2)
8111196c:	100d883a 	mov	r6,r2
81111970:	01604574 	movhi	r5,33045
81111974:	29793f04 	addi	r5,r5,-6916
81111978:	1809883a 	mov	r4,r3
8111197c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81111980:	d0e06217 	ldw	r3,-32376(gp)
81111984:	e0bffe17 	ldw	r2,-8(fp)
81111988:	10801c17 	ldw	r2,112(r2)
8111198c:	100d883a 	mov	r6,r2
81111990:	01604574 	movhi	r5,33045
81111994:	29794804 	addi	r5,r5,-6880
81111998:	1809883a 	mov	r4,r3
8111199c:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
811119a0:	d0e06217 	ldw	r3,-32376(gp)
811119a4:	e0bffe17 	ldw	r2,-8(fp)
811119a8:	10801d17 	ldw	r2,116(r2)
811119ac:	100d883a 	mov	r6,r2
811119b0:	01604574 	movhi	r5,33045
811119b4:	29795304 	addi	r5,r5,-6836
811119b8:	1809883a 	mov	r4,r3
811119bc:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"        Right side \n");
811119c0:	d0a06217 	ldw	r2,-32376(gp)
811119c4:	100f883a 	mov	r7,r2
811119c8:	01800504 	movi	r6,20
811119cc:	01400044 	movi	r5,1
811119d0:	01204574 	movhi	r4,33045
811119d4:	21395f04 	addi	r4,r4,-6788
811119d8:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
811119dc:	d0e06217 	ldw	r3,-32376(gp)
811119e0:	e0bffe17 	ldw	r2,-8(fp)
811119e4:	10801e17 	ldw	r2,120(r2)
811119e8:	100d883a 	mov	r6,r2
811119ec:	01604574 	movhi	r5,33045
811119f0:	29793f04 	addi	r5,r5,-6916
811119f4:	1809883a 	mov	r4,r3
811119f8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
811119fc:	d0e06217 	ldw	r3,-32376(gp)
81111a00:	e0bffe17 	ldw	r2,-8(fp)
81111a04:	10801f17 	ldw	r2,124(r2)
81111a08:	100d883a 	mov	r6,r2
81111a0c:	01604574 	movhi	r5,33045
81111a10:	29794804 	addi	r5,r5,-6880
81111a14:	1809883a 	mov	r4,r3
81111a18:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
81111a1c:	d0e06217 	ldw	r3,-32376(gp)
81111a20:	e0bffe17 	ldw	r2,-8(fp)
81111a24:	10802017 	ldw	r2,128(r2)
81111a28:	100d883a 	mov	r6,r2
81111a2c:	01604574 	movhi	r5,33045
81111a30:	29795304 	addi	r5,r5,-6836
81111a34:	1809883a 	mov	r4,r3
81111a38:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"\n");
81111a3c:	d0a06217 	ldw	r2,-32376(gp)
81111a40:	100b883a 	mov	r5,r2
81111a44:	01000284 	movi	r4,10
81111a48:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"==============================================================================\n");
81111a4c:	d0a06217 	ldw	r2,-32376(gp)
81111a50:	100f883a 	mov	r7,r2
81111a54:	018013c4 	movi	r6,79
81111a58:	01400044 	movi	r5,1
81111a5c:	01204574 	movhi	r4,33045
81111a60:	21396504 	addi	r4,r4,-6764
81111a64:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"==============================================================================\n");
81111a68:	d0a06217 	ldw	r2,-32376(gp)
81111a6c:	100f883a 	mov	r7,r2
81111a70:	018013c4 	movi	r6,79
81111a74:	01400044 	movi	r5,1
81111a78:	01204574 	movhi	r4,33045
81111a7c:	21396504 	addi	r4,r4,-6764
81111a80:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"\n");
81111a84:	d0a06217 	ldw	r2,-32376(gp)
81111a88:	100b883a 	mov	r5,r2
81111a8c:	01000284 	movi	r4,10
81111a90:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"\n");
81111a94:	d0a06217 	ldw	r2,-32376(gp)
81111a98:	100b883a 	mov	r5,r2
81111a9c:	01000284 	movi	r4,10
81111aa0:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"\n");
81111aa4:	d0a06217 	ldw	r2,-32376(gp)
81111aa8:	100b883a 	mov	r5,r2
81111aac:	01000284 	movi	r4,10
81111ab0:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"\n");
81111ab4:	d0a06217 	ldw	r2,-32376(gp)
81111ab8:	100b883a 	mov	r5,r2
81111abc:	01000284 	movi	r4,10
81111ac0:	1122a0c0 	call	81122a0c <fputc>
		fprintf(fp,"\n");
81111ac4:	d0a06217 	ldw	r2,-32376(gp)
81111ac8:	100b883a 	mov	r5,r2
81111acc:	01000284 	movi	r4,10
81111ad0:	1122a0c0 	call	81122a0c <fputc>
	}
81111ad4:	0001883a 	nop
81111ad8:	e037883a 	mov	sp,fp
81111adc:	dfc00117 	ldw	ra,4(sp)
81111ae0:	df000017 	ldw	fp,0(sp)
81111ae4:	dec00204 	addi	sp,sp,8
81111ae8:	f800283a 	ret

81111aec <bPrepareDoubleBuffer>:
#endif


bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
81111aec:	defff804 	addi	sp,sp,-32
81111af0:	de00012e 	bgeu	sp,et,81111af8 <bPrepareDoubleBuffer+0xc>
81111af4:	003b68fa 	trap	3
81111af8:	dfc00715 	stw	ra,28(sp)
81111afc:	df000615 	stw	fp,24(sp)
81111b00:	df000604 	addi	fp,sp,24
81111b04:	e13ffc15 	stw	r4,-16(fp)
81111b08:	2807883a 	mov	r3,r5
81111b0c:	3005883a 	mov	r2,r6
81111b10:	e1ffff15 	stw	r7,-4(fp)
81111b14:	e0fffd05 	stb	r3,-12(fp)
81111b18:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
81111b1c:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
81111b20:	e0bffc17 	ldw	r2,-16(fp)
81111b24:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
81111b28:	e0bffc17 	ldw	r2,-16(fp)
81111b2c:	10c00017 	ldw	r3,0(r2)
81111b30:	e0bffc17 	ldw	r2,-16(fp)
81111b34:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
81111b38:	e0bffc17 	ldw	r2,-16(fp)
81111b3c:	10800117 	ldw	r2,4(r2)
81111b40:	10c00404 	addi	r3,r2,16
81111b44:	e0bfff17 	ldw	r2,-4(fp)
81111b48:	10800417 	ldw	r2,16(r2)
81111b4c:	18800736 	bltu	r3,r2,81111b6c <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81111b50:	e0bfff17 	ldw	r2,-4(fp)
81111b54:	10c00417 	ldw	r3,16(r2)
81111b58:	e0bffc17 	ldw	r2,-16(fp)
81111b5c:	10800117 	ldw	r2,4(r2)
81111b60:	1885c83a 	sub	r2,r3,r2
81111b64:	e0bffb15 	stw	r2,-20(fp)
81111b68:	00000206 	br	81111b74 <bPrepareDoubleBuffer+0x88>

	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81111b6c:	00800404 	movi	r2,16
81111b70:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81111b74:	00a045f4 	movhi	r2,33047
81111b78:	10a00404 	addi	r2,r2,-32752
81111b7c:	10800e0b 	ldhu	r2,56(r2)
81111b80:	10bfffcc 	andi	r2,r2,65535
81111b84:	10000b1e 	bne	r2,zero,81111bb4 <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81111b88:	e0bffb17 	ldw	r2,-20(fp)
81111b8c:	10803fcc 	andi	r2,r2,255
81111b90:	000b883a 	mov	r5,zero
81111b94:	1009883a 	mov	r4,r2
81111b98:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111b9c:	e0bffb17 	ldw	r2,-20(fp)
81111ba0:	10803fcc 	andi	r2,r2,255
81111ba4:	01400044 	movi	r5,1
81111ba8:	1009883a 	mov	r4,r2
81111bac:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
81111bb0:	00000a06 	br	81111bdc <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111bb4:	e0bffb17 	ldw	r2,-20(fp)
81111bb8:	10803fcc 	andi	r2,r2,255
81111bbc:	000b883a 	mov	r5,zero
81111bc0:	1009883a 	mov	r4,r2
81111bc4:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81111bc8:	e0bffb17 	ldw	r2,-20(fp)
81111bcc:	10803fcc 	andi	r2,r2,255
81111bd0:	01400044 	movi	r5,1
81111bd4:	1009883a 	mov	r4,r2
81111bd8:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
81111bdc:	e0bffd03 	ldbu	r2,-12(fp)
81111be0:	1000231e 	bne	r2,zero,81111c70 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111be4:	e0bffc17 	ldw	r2,-16(fp)
81111be8:	10800217 	ldw	r2,8(r2)
81111bec:	1011883a 	mov	r8,r2
81111bf0:	e0bffb17 	ldw	r2,-20(fp)
81111bf4:	10ffffcc 	andi	r3,r2,65535
81111bf8:	d0a05603 	ldbu	r2,-32424(gp)
81111bfc:	11003fcc 	andi	r4,r2,255
81111c00:	e0bfff17 	ldw	r2,-4(fp)
81111c04:	10800043 	ldbu	r2,1(r2)
81111c08:	10803fcc 	andi	r2,r2,255
81111c0c:	100f883a 	mov	r7,r2
81111c10:	200d883a 	mov	r6,r4
81111c14:	180b883a 	mov	r5,r3
81111c18:	4009883a 	mov	r4,r8
81111c1c:	1103cb00 	call	81103cb0 <bSdmaDmaM1Transfer>
81111c20:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111c24:	e0bffa17 	ldw	r2,-24(fp)
81111c28:	10800058 	cmpnei	r2,r2,1
81111c2c:	10000e1e 	bne	r2,zero,81111c68 <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111c30:	e0bffc17 	ldw	r2,-16(fp)
81111c34:	10c00217 	ldw	r3,8(r2)
81111c38:	e0bffb17 	ldw	r2,-20(fp)
81111c3c:	10802224 	muli	r2,r2,136
81111c40:	1887883a 	add	r3,r3,r2
81111c44:	e0bffc17 	ldw	r2,-16(fp)
81111c48:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111c4c:	e0bffc17 	ldw	r2,-16(fp)
81111c50:	10c00117 	ldw	r3,4(r2)
81111c54:	e0bffb17 	ldw	r2,-20(fp)
81111c58:	1887883a 	add	r3,r3,r2
81111c5c:	e0bffc17 	ldw	r2,-16(fp)
81111c60:	10c00115 	stw	r3,4(r2)
81111c64:	00002506 	br	81111cfc <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81111c68:	e0bffa17 	ldw	r2,-24(fp)
81111c6c:	00009506 	br	81111ec4 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111c70:	e0bffc17 	ldw	r2,-16(fp)
81111c74:	10800217 	ldw	r2,8(r2)
81111c78:	1011883a 	mov	r8,r2
81111c7c:	e0bffb17 	ldw	r2,-20(fp)
81111c80:	10ffffcc 	andi	r3,r2,65535
81111c84:	d0a05603 	ldbu	r2,-32424(gp)
81111c88:	11003fcc 	andi	r4,r2,255
81111c8c:	e0bfff17 	ldw	r2,-4(fp)
81111c90:	10800043 	ldbu	r2,1(r2)
81111c94:	10803fcc 	andi	r2,r2,255
81111c98:	100f883a 	mov	r7,r2
81111c9c:	200d883a 	mov	r6,r4
81111ca0:	180b883a 	mov	r5,r3
81111ca4:	4009883a 	mov	r4,r8
81111ca8:	11041040 	call	81104104 <bSdmaDmaM2Transfer>
81111cac:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111cb0:	e0bffa17 	ldw	r2,-24(fp)
81111cb4:	10800058 	cmpnei	r2,r2,1
81111cb8:	10000e1e 	bne	r2,zero,81111cf4 <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111cbc:	e0bffc17 	ldw	r2,-16(fp)
81111cc0:	10c00217 	ldw	r3,8(r2)
81111cc4:	e0bffb17 	ldw	r2,-20(fp)
81111cc8:	10802224 	muli	r2,r2,136
81111ccc:	1887883a 	add	r3,r3,r2
81111cd0:	e0bffc17 	ldw	r2,-16(fp)
81111cd4:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111cd8:	e0bffc17 	ldw	r2,-16(fp)
81111cdc:	10c00117 	ldw	r3,4(r2)
81111ce0:	e0bffb17 	ldw	r2,-20(fp)
81111ce4:	1887883a 	add	r3,r3,r2
81111ce8:	e0bffc17 	ldw	r2,-16(fp)
81111cec:	10c00115 	stw	r3,4(r2)
81111cf0:	00000206 	br	81111cfc <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81111cf4:	e0bffa17 	ldw	r2,-24(fp)
81111cf8:	00007206 	br	81111ec4 <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
81111cfc:	e0bffc17 	ldw	r2,-16(fp)
81111d00:	10800117 	ldw	r2,4(r2)
81111d04:	10c00404 	addi	r3,r2,16
81111d08:	e0bfff17 	ldw	r2,-4(fp)
81111d0c:	10800417 	ldw	r2,16(r2)
81111d10:	18800736 	bltu	r3,r2,81111d30 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81111d14:	e0bfff17 	ldw	r2,-4(fp)
81111d18:	10c00417 	ldw	r3,16(r2)
81111d1c:	e0bffc17 	ldw	r2,-16(fp)
81111d20:	10800117 	ldw	r2,4(r2)
81111d24:	1885c83a 	sub	r2,r3,r2
81111d28:	e0bffb15 	stw	r2,-20(fp)
81111d2c:	00000206 	br	81111d38 <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81111d30:	00800404 	movi	r2,16
81111d34:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81111d38:	00a045f4 	movhi	r2,33047
81111d3c:	10a00404 	addi	r2,r2,-32752
81111d40:	10800e0b 	ldhu	r2,56(r2)
81111d44:	10bfffcc 	andi	r2,r2,65535
81111d48:	10000b1e 	bne	r2,zero,81111d78 <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81111d4c:	e0bffb17 	ldw	r2,-20(fp)
81111d50:	10803fcc 	andi	r2,r2,255
81111d54:	000b883a 	mov	r5,zero
81111d58:	1009883a 	mov	r4,r2
81111d5c:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111d60:	e0bffb17 	ldw	r2,-20(fp)
81111d64:	10803fcc 	andi	r2,r2,255
81111d68:	01400044 	movi	r5,1
81111d6c:	1009883a 	mov	r4,r2
81111d70:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
81111d74:	00000a06 	br	81111da0 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111d78:	e0bffb17 	ldw	r2,-20(fp)
81111d7c:	10803fcc 	andi	r2,r2,255
81111d80:	000b883a 	mov	r5,zero
81111d84:	1009883a 	mov	r4,r2
81111d88:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81111d8c:	e0bffb17 	ldw	r2,-20(fp)
81111d90:	10803fcc 	andi	r2,r2,255
81111d94:	01400044 	movi	r5,1
81111d98:	1009883a 	mov	r4,r2
81111d9c:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
81111da0:	e0bffd03 	ldbu	r2,-12(fp)
81111da4:	1000231e 	bne	r2,zero,81111e34 <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111da8:	e0bffc17 	ldw	r2,-16(fp)
81111dac:	10800217 	ldw	r2,8(r2)
81111db0:	1011883a 	mov	r8,r2
81111db4:	e0bffb17 	ldw	r2,-20(fp)
81111db8:	10ffffcc 	andi	r3,r2,65535
81111dbc:	d0a05603 	ldbu	r2,-32424(gp)
81111dc0:	11003fcc 	andi	r4,r2,255
81111dc4:	e0bfff17 	ldw	r2,-4(fp)
81111dc8:	10800043 	ldbu	r2,1(r2)
81111dcc:	10803fcc 	andi	r2,r2,255
81111dd0:	100f883a 	mov	r7,r2
81111dd4:	200d883a 	mov	r6,r4
81111dd8:	180b883a 	mov	r5,r3
81111ddc:	4009883a 	mov	r4,r8
81111de0:	1103cb00 	call	81103cb0 <bSdmaDmaM1Transfer>
81111de4:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111de8:	e0bffa17 	ldw	r2,-24(fp)
81111dec:	10800058 	cmpnei	r2,r2,1
81111df0:	10000e1e 	bne	r2,zero,81111e2c <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111df4:	e0bffc17 	ldw	r2,-16(fp)
81111df8:	10c00217 	ldw	r3,8(r2)
81111dfc:	e0bffb17 	ldw	r2,-20(fp)
81111e00:	10802224 	muli	r2,r2,136
81111e04:	1887883a 	add	r3,r3,r2
81111e08:	e0bffc17 	ldw	r2,-16(fp)
81111e0c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111e10:	e0bffc17 	ldw	r2,-16(fp)
81111e14:	10c00117 	ldw	r3,4(r2)
81111e18:	e0bffb17 	ldw	r2,-20(fp)
81111e1c:	1887883a 	add	r3,r3,r2
81111e20:	e0bffc17 	ldw	r2,-16(fp)
81111e24:	10c00115 	stw	r3,4(r2)
81111e28:	00002506 	br	81111ec0 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81111e2c:	e0bffa17 	ldw	r2,-24(fp)
81111e30:	00002406 	br	81111ec4 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111e34:	e0bffc17 	ldw	r2,-16(fp)
81111e38:	10800217 	ldw	r2,8(r2)
81111e3c:	1011883a 	mov	r8,r2
81111e40:	e0bffb17 	ldw	r2,-20(fp)
81111e44:	10ffffcc 	andi	r3,r2,65535
81111e48:	d0a05603 	ldbu	r2,-32424(gp)
81111e4c:	11003fcc 	andi	r4,r2,255
81111e50:	e0bfff17 	ldw	r2,-4(fp)
81111e54:	10800043 	ldbu	r2,1(r2)
81111e58:	10803fcc 	andi	r2,r2,255
81111e5c:	100f883a 	mov	r7,r2
81111e60:	200d883a 	mov	r6,r4
81111e64:	180b883a 	mov	r5,r3
81111e68:	4009883a 	mov	r4,r8
81111e6c:	11041040 	call	81104104 <bSdmaDmaM2Transfer>
81111e70:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111e74:	e0bffa17 	ldw	r2,-24(fp)
81111e78:	10800058 	cmpnei	r2,r2,1
81111e7c:	10000e1e 	bne	r2,zero,81111eb8 <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111e80:	e0bffc17 	ldw	r2,-16(fp)
81111e84:	10c00217 	ldw	r3,8(r2)
81111e88:	e0bffb17 	ldw	r2,-20(fp)
81111e8c:	10802224 	muli	r2,r2,136
81111e90:	1887883a 	add	r3,r3,r2
81111e94:	e0bffc17 	ldw	r2,-16(fp)
81111e98:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111e9c:	e0bffc17 	ldw	r2,-16(fp)
81111ea0:	10c00117 	ldw	r3,4(r2)
81111ea4:	e0bffb17 	ldw	r2,-20(fp)
81111ea8:	1887883a 	add	r3,r3,r2
81111eac:	e0bffc17 	ldw	r2,-16(fp)
81111eb0:	10c00115 	stw	r3,4(r2)
81111eb4:	00000206 	br	81111ec0 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81111eb8:	e0bffa17 	ldw	r2,-24(fp)
81111ebc:	00000106 	br	81111ec4 <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
81111ec0:	e0bffa17 	ldw	r2,-24(fp)

}
81111ec4:	e037883a 	mov	sp,fp
81111ec8:	dfc00117 	ldw	ra,4(sp)
81111ecc:	df000017 	ldw	fp,0(sp)
81111ed0:	dec00204 	addi	sp,sp,8
81111ed4:	f800283a 	ret

81111ed8 <vLoadCtemp>:


void vLoadCtemp(void) {
81111ed8:	deffff04 	addi	sp,sp,-4
81111edc:	de00012e 	bgeu	sp,et,81111ee4 <vLoadCtemp+0xc>
81111ee0:	003b68fa 	trap	3
81111ee4:	df000015 	stw	fp,0(sp)
81111ee8:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
81111eec:	00a04574 	movhi	r2,33045
81111ef0:	1093a604 	addi	r2,r2,20120
81111ef4:	00e04574 	movhi	r3,33045
81111ef8:	18f97904 	addi	r3,r3,-6684
81111efc:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
81111f00:	00a04574 	movhi	r2,33045
81111f04:	1093a604 	addi	r2,r2,20120
81111f08:	00e04574 	movhi	r3,33045
81111f0c:	18f97d04 	addi	r3,r3,-6668
81111f10:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
81111f14:	00a04574 	movhi	r2,33045
81111f18:	1093a604 	addi	r2,r2,20120
81111f1c:	00e04574 	movhi	r3,33045
81111f20:	18f98104 	addi	r3,r3,-6652
81111f24:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
81111f28:	00a04574 	movhi	r2,33045
81111f2c:	1093a604 	addi	r2,r2,20120
81111f30:	00e04574 	movhi	r3,33045
81111f34:	18f98504 	addi	r3,r3,-6636
81111f38:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
81111f3c:	00a04574 	movhi	r2,33045
81111f40:	1093a604 	addi	r2,r2,20120
81111f44:	00e04574 	movhi	r3,33045
81111f48:	18f98904 	addi	r3,r3,-6620
81111f4c:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
81111f50:	00a04574 	movhi	r2,33045
81111f54:	1093a604 	addi	r2,r2,20120
81111f58:	00e04574 	movhi	r3,33045
81111f5c:	18f98d04 	addi	r3,r3,-6604
81111f60:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
81111f64:	00a04574 	movhi	r2,33045
81111f68:	1093a604 	addi	r2,r2,20120
81111f6c:	00e04574 	movhi	r3,33045
81111f70:	18f99104 	addi	r3,r3,-6588
81111f74:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
81111f78:	00a04574 	movhi	r2,33045
81111f7c:	1093a604 	addi	r2,r2,20120
81111f80:	00e04574 	movhi	r3,33045
81111f84:	18f99504 	addi	r3,r3,-6572
81111f88:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81111f8c:	00a04574 	movhi	r2,33045
81111f90:	1093a604 	addi	r2,r2,20120
81111f94:	00e04574 	movhi	r3,33045
81111f98:	18f99904 	addi	r3,r3,-6556
81111f9c:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81111fa0:	00a04574 	movhi	r2,33045
81111fa4:	1093a604 	addi	r2,r2,20120
81111fa8:	00e04574 	movhi	r3,33045
81111fac:	18f99d04 	addi	r3,r3,-6540
81111fb0:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81111fb4:	00a04574 	movhi	r2,33045
81111fb8:	1093a604 	addi	r2,r2,20120
81111fbc:	00e04574 	movhi	r3,33045
81111fc0:	18f9a104 	addi	r3,r3,-6524
81111fc4:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81111fc8:	00a04574 	movhi	r2,33045
81111fcc:	1093a604 	addi	r2,r2,20120
81111fd0:	00e04574 	movhi	r3,33045
81111fd4:	18f9a504 	addi	r3,r3,-6508
81111fd8:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
81111fdc:	00a04574 	movhi	r2,33045
81111fe0:	1093a604 	addi	r2,r2,20120
81111fe4:	00e04574 	movhi	r3,33045
81111fe8:	18f9a904 	addi	r3,r3,-6492
81111fec:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
81111ff0:	00a04574 	movhi	r2,33045
81111ff4:	1093a604 	addi	r2,r2,20120
81111ff8:	00e04574 	movhi	r3,33045
81111ffc:	18f9ac04 	addi	r3,r3,-6480
81112000:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
81112004:	00a04574 	movhi	r2,33045
81112008:	1093a604 	addi	r2,r2,20120
8111200c:	00e04574 	movhi	r3,33045
81112010:	18f9af04 	addi	r3,r3,-6468
81112014:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
81112018:	00a04574 	movhi	r2,33045
8111201c:	1093a604 	addi	r2,r2,20120
81112020:	00e04574 	movhi	r3,33045
81112024:	18f9b204 	addi	r3,r3,-6456
81112028:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
8111202c:	00a04574 	movhi	r2,33045
81112030:	1093a604 	addi	r2,r2,20120
81112034:	00e04574 	movhi	r3,33045
81112038:	18f9b604 	addi	r3,r3,-6440
8111203c:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
81112040:	00a04574 	movhi	r2,33045
81112044:	1093a604 	addi	r2,r2,20120
81112048:	00e04574 	movhi	r3,33045
8111204c:	18f9b904 	addi	r3,r3,-6428
81112050:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
81112054:	00a04574 	movhi	r2,33045
81112058:	1093a604 	addi	r2,r2,20120
8111205c:	00e04574 	movhi	r3,33045
81112060:	18f9bc04 	addi	r3,r3,-6416
81112064:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
81112068:	00a04574 	movhi	r2,33045
8111206c:	1093a604 	addi	r2,r2,20120
81112070:	00e04574 	movhi	r3,33045
81112074:	18f9c004 	addi	r3,r3,-6400
81112078:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
8111207c:	00a04574 	movhi	r2,33045
81112080:	1093a604 	addi	r2,r2,20120
81112084:	00e04574 	movhi	r3,33045
81112088:	18f9c404 	addi	r3,r3,-6384
8111208c:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
81112090:	00a04574 	movhi	r2,33045
81112094:	1093a604 	addi	r2,r2,20120
81112098:	00e04574 	movhi	r3,33045
8111209c:	18f9c804 	addi	r3,r3,-6368
811120a0:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
811120a4:	00a04574 	movhi	r2,33045
811120a8:	1093a604 	addi	r2,r2,20120
811120ac:	00e04574 	movhi	r3,33045
811120b0:	18f9cc04 	addi	r3,r3,-6352
811120b4:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
811120b8:	00a04574 	movhi	r2,33045
811120bc:	1093a604 	addi	r2,r2,20120
811120c0:	00e04574 	movhi	r3,33045
811120c4:	18f9d004 	addi	r3,r3,-6336
811120c8:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
811120cc:	00a04574 	movhi	r2,33045
811120d0:	1093a604 	addi	r2,r2,20120
811120d4:	00e04574 	movhi	r3,33045
811120d8:	18f9d304 	addi	r3,r3,-6324
811120dc:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
811120e0:	00a04574 	movhi	r2,33045
811120e4:	1093a604 	addi	r2,r2,20120
811120e8:	00e04574 	movhi	r3,33045
811120ec:	18f9d704 	addi	r3,r3,-6308
811120f0:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
811120f4:	00a04574 	movhi	r2,33045
811120f8:	1093a604 	addi	r2,r2,20120
811120fc:	00e04574 	movhi	r3,33045
81112100:	18f9db04 	addi	r3,r3,-6292
81112104:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
81112108:	00a04574 	movhi	r2,33045
8111210c:	1093a604 	addi	r2,r2,20120
81112110:	00e04574 	movhi	r3,33045
81112114:	18f9df04 	addi	r3,r3,-6276
81112118:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
8111211c:	00a04574 	movhi	r2,33045
81112120:	1093a604 	addi	r2,r2,20120
81112124:	00e04574 	movhi	r3,33045
81112128:	18f9e304 	addi	r3,r3,-6260
8111212c:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
81112130:	00a04574 	movhi	r2,33045
81112134:	1093a604 	addi	r2,r2,20120
81112138:	00e04574 	movhi	r3,33045
8111213c:	18f9e704 	addi	r3,r3,-6244
81112140:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
81112144:	00a04574 	movhi	r2,33045
81112148:	1093a604 	addi	r2,r2,20120
8111214c:	00e04574 	movhi	r3,33045
81112150:	18f9ec04 	addi	r3,r3,-6224
81112154:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
81112158:	00a04574 	movhi	r2,33045
8111215c:	1093a604 	addi	r2,r2,20120
81112160:	00e04574 	movhi	r3,33045
81112164:	18f9f004 	addi	r3,r3,-6208
81112168:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
8111216c:	00a04574 	movhi	r2,33045
81112170:	1093a604 	addi	r2,r2,20120
81112174:	00e04574 	movhi	r3,33045
81112178:	18f9f404 	addi	r3,r3,-6192
8111217c:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
81112180:	00a04574 	movhi	r2,33045
81112184:	1093a604 	addi	r2,r2,20120
81112188:	00e04574 	movhi	r3,33045
8111218c:	18f9f804 	addi	r3,r3,-6176
81112190:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
81112194:	00a04574 	movhi	r2,33045
81112198:	1093a604 	addi	r2,r2,20120
8111219c:	00e04574 	movhi	r3,33045
811121a0:	18f9fc04 	addi	r3,r3,-6160
811121a4:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
811121a8:	00a04574 	movhi	r2,33045
811121ac:	1093a604 	addi	r2,r2,20120
811121b0:	00e04574 	movhi	r3,33045
811121b4:	18fa0004 	addi	r3,r3,-6144
811121b8:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
811121bc:	00a04574 	movhi	r2,33045
811121c0:	1093a604 	addi	r2,r2,20120
811121c4:	00e04574 	movhi	r3,33045
811121c8:	18fa0404 	addi	r3,r3,-6128
811121cc:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
811121d0:	00a04574 	movhi	r2,33045
811121d4:	1093a604 	addi	r2,r2,20120
811121d8:	00e04574 	movhi	r3,33045
811121dc:	18fa0804 	addi	r3,r3,-6112
811121e0:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
811121e4:	00a04574 	movhi	r2,33045
811121e8:	1093a604 	addi	r2,r2,20120
811121ec:	00e04574 	movhi	r3,33045
811121f0:	18fa0c04 	addi	r3,r3,-6096
811121f4:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
811121f8:	00a04574 	movhi	r2,33045
811121fc:	1093a604 	addi	r2,r2,20120
81112200:	00e04574 	movhi	r3,33045
81112204:	18fa1004 	addi	r3,r3,-6080
81112208:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
8111220c:	00a04574 	movhi	r2,33045
81112210:	1093a604 	addi	r2,r2,20120
81112214:	00e04574 	movhi	r3,33045
81112218:	18fa1404 	addi	r3,r3,-6064
8111221c:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
81112220:	00a04574 	movhi	r2,33045
81112224:	1093a604 	addi	r2,r2,20120
81112228:	00e04574 	movhi	r3,33045
8111222c:	18fa1804 	addi	r3,r3,-6048
81112230:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
81112234:	00a04574 	movhi	r2,33045
81112238:	1093a604 	addi	r2,r2,20120
8111223c:	00e04574 	movhi	r3,33045
81112240:	18fa1c04 	addi	r3,r3,-6032
81112244:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
81112248:	00a04574 	movhi	r2,33045
8111224c:	1093a604 	addi	r2,r2,20120
81112250:	00e04574 	movhi	r3,33045
81112254:	18fa2004 	addi	r3,r3,-6016
81112258:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
8111225c:	00a04574 	movhi	r2,33045
81112260:	1093a604 	addi	r2,r2,20120
81112264:	00e04574 	movhi	r3,33045
81112268:	18fa2404 	addi	r3,r3,-6000
8111226c:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
81112270:	00a04574 	movhi	r2,33045
81112274:	1093a604 	addi	r2,r2,20120
81112278:	00e04574 	movhi	r3,33045
8111227c:	18fa2804 	addi	r3,r3,-5984
81112280:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
81112284:	00a04574 	movhi	r2,33045
81112288:	1093a604 	addi	r2,r2,20120
8111228c:	00e04574 	movhi	r3,33045
81112290:	18fa2c04 	addi	r3,r3,-5968
81112294:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81112298:	00a04574 	movhi	r2,33045
8111229c:	1093a604 	addi	r2,r2,20120
811122a0:	00e04574 	movhi	r3,33045
811122a4:	18fa3004 	addi	r3,r3,-5952
811122a8:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
811122ac:	00a04574 	movhi	r2,33045
811122b0:	1093a604 	addi	r2,r2,20120
811122b4:	00e04574 	movhi	r3,33045
811122b8:	18fa3404 	addi	r3,r3,-5936
811122bc:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
811122c0:	00a04574 	movhi	r2,33045
811122c4:	1093a604 	addi	r2,r2,20120
811122c8:	00e04574 	movhi	r3,33045
811122cc:	18fa3804 	addi	r3,r3,-5920
811122d0:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
811122d4:	00a04574 	movhi	r2,33045
811122d8:	1093a604 	addi	r2,r2,20120
811122dc:	00e04574 	movhi	r3,33045
811122e0:	18fa3c04 	addi	r3,r3,-5904
811122e4:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
811122e8:	00a04574 	movhi	r2,33045
811122ec:	1093a604 	addi	r2,r2,20120
811122f0:	00e04574 	movhi	r3,33045
811122f4:	18fa4004 	addi	r3,r3,-5888
811122f8:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
811122fc:	00a04574 	movhi	r2,33045
81112300:	1093a604 	addi	r2,r2,20120
81112304:	00e04574 	movhi	r3,33045
81112308:	18fa4404 	addi	r3,r3,-5872
8111230c:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81112310:	00a04574 	movhi	r2,33045
81112314:	1093a604 	addi	r2,r2,20120
81112318:	00e04574 	movhi	r3,33045
8111231c:	18fa4804 	addi	r3,r3,-5856
81112320:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81112324:	00a04574 	movhi	r2,33045
81112328:	1093a604 	addi	r2,r2,20120
8111232c:	00e04574 	movhi	r3,33045
81112330:	18fa4c04 	addi	r3,r3,-5840
81112334:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81112338:	00a04574 	movhi	r2,33045
8111233c:	1093a604 	addi	r2,r2,20120
81112340:	00e04574 	movhi	r3,33045
81112344:	18fa5004 	addi	r3,r3,-5824
81112348:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
8111234c:	00a04574 	movhi	r2,33045
81112350:	1093a604 	addi	r2,r2,20120
81112354:	00e04574 	movhi	r3,33045
81112358:	18fa5404 	addi	r3,r3,-5808
8111235c:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81112360:	00a04574 	movhi	r2,33045
81112364:	1093a604 	addi	r2,r2,20120
81112368:	00e04574 	movhi	r3,33045
8111236c:	18fa5804 	addi	r3,r3,-5792
81112370:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81112374:	00a04574 	movhi	r2,33045
81112378:	1093a604 	addi	r2,r2,20120
8111237c:	00e04574 	movhi	r3,33045
81112380:	18fa5c04 	addi	r3,r3,-5776
81112384:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81112388:	00a04574 	movhi	r2,33045
8111238c:	1093a604 	addi	r2,r2,20120
81112390:	00e04574 	movhi	r3,33045
81112394:	18fa6004 	addi	r3,r3,-5760
81112398:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
8111239c:	00a04574 	movhi	r2,33045
811123a0:	1093a604 	addi	r2,r2,20120
811123a4:	00e04574 	movhi	r3,33045
811123a8:	18fa6404 	addi	r3,r3,-5744
811123ac:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
811123b0:	00a04574 	movhi	r2,33045
811123b4:	1093a604 	addi	r2,r2,20120
811123b8:	00e04574 	movhi	r3,33045
811123bc:	18fa6804 	addi	r3,r3,-5728
811123c0:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
811123c4:	00a04574 	movhi	r2,33045
811123c8:	1093a604 	addi	r2,r2,20120
811123cc:	00e04574 	movhi	r3,33045
811123d0:	18fa6c04 	addi	r3,r3,-5712
811123d4:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
811123d8:	00a04574 	movhi	r2,33045
811123dc:	1093a604 	addi	r2,r2,20120
811123e0:	00e04574 	movhi	r3,33045
811123e4:	18fa7004 	addi	r3,r3,-5696
811123e8:	10c03f15 	stw	r3,252(r2)
}
811123ec:	0001883a 	nop
811123f0:	e037883a 	mov	sp,fp
811123f4:	df000017 	ldw	fp,0(sp)
811123f8:	dec00104 	addi	sp,sp,4
811123fc:	f800283a 	ret

81112400 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81112400:	defff604 	addi	sp,sp,-40
81112404:	de00012e 	bgeu	sp,et,8111240c <vInAckHandlerTaskV2+0xc>
81112408:	003b68fa 	trap	3
8111240c:	dfc00915 	stw	ra,36(sp)
81112410:	df000815 	stw	fp,32(sp)
81112414:	df000804 	addi	fp,sp,32
81112418:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8111241c:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81112420:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81112424:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81112428:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8111242c:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81112430:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81112434:	e03ffa45 	stb	zero,-23(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81112438:	00a045f4 	movhi	r2,33047
8111243c:	10a00404 	addi	r2,r2,-32752
81112440:	10800e8b 	ldhu	r2,58(r2)
81112444:	10bfffcc 	andi	r2,r2,65535
81112448:	10800168 	cmpgeui	r2,r2,5
8111244c:	1000071e 	bne	r2,zero,8111246c <vInAckHandlerTaskV2+0x6c>
        debug(fp,"In Ack Handler Task. (Task on)\n");
81112450:	d0a06217 	ldw	r2,-32376(gp)
81112454:	100f883a 	mov	r7,r2
81112458:	018007c4 	movi	r6,31
8111245c:	01400044 	movi	r5,1
81112460:	01204574 	movhi	r4,33045
81112464:	213a7404 	addi	r4,r4,-5680
81112468:	11230300 	call	81123030 <fwrite>
    }
    #endif

	eReceiverAckState = sRAConfiguring;
8111246c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81112470:	e0bff917 	ldw	r2,-28(fp)
81112474:	10c00060 	cmpeqi	r3,r2,1
81112478:	1800071e 	bne	r3,zero,81112498 <vInAckHandlerTaskV2+0x98>
8111247c:	0080032e 	bgeu	zero,r2,8111248c <vInAckHandlerTaskV2+0x8c>
81112480:	108000a0 	cmpeqi	r2,r2,2
81112484:	10004a1e 	bne	r2,zero,811125b0 <vInAckHandlerTaskV2+0x1b0>
81112488:	0000ac06 	br	8111273c <vInAckHandlerTaskV2+0x33c>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8111248c:	00800044 	movi	r2,1
81112490:	e0bff915 	stw	r2,-28(fp)
				break;
81112494:	0000b906 	br	8111277c <vInAckHandlerTaskV2+0x37c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81112498:	00800044 	movi	r2,1
8111249c:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
811124a0:	d0a06617 	ldw	r2,-32360(gp)
811124a4:	e0fffe04 	addi	r3,fp,-8
811124a8:	180d883a 	mov	r6,r3
811124ac:	000b883a 	mov	r5,zero
811124b0:	1009883a 	mov	r4,r2
811124b4:	113fe340 	call	8113fe34 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811124b8:	e0bffe03 	ldbu	r2,-8(fp)
811124bc:	10803fcc 	andi	r2,r2,255
811124c0:	1000391e 	bne	r2,zero,811125a8 <vInAckHandlerTaskV2+0x1a8>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
811124c4:	d0a06517 	ldw	r2,-32364(gp)
811124c8:	e0fffe04 	addi	r3,fp,-8
811124cc:	180d883a 	mov	r6,r3
811124d0:	000b883a 	mov	r5,zero
811124d4:	1009883a 	mov	r4,r2
811124d8:	113de280 	call	8113de28 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
811124dc:	e0bffe03 	ldbu	r2,-8(fp)
811124e0:	10803fcc 	andi	r2,r2,255
811124e4:	10002b1e 	bne	r2,zero,81112594 <vInAckHandlerTaskV2+0x194>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
811124e8:	e03ffa45 	stb	zero,-23(fp)
811124ec:	00002206 	br	81112578 <vInAckHandlerTaskV2+0x178>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
811124f0:	e0fffa43 	ldbu	r3,-23(fp)
811124f4:	00a045b4 	movhi	r2,33046
811124f8:	10894204 	addi	r2,r2,9480
811124fc:	18c7883a 	add	r3,r3,r3
81112500:	18c7883a 	add	r3,r3,r3
81112504:	10c5883a 	add	r2,r2,r3
81112508:	10800003 	ldbu	r2,0(r2)
8111250c:	10803fcc 	andi	r2,r2,255
81112510:	1080201c 	xori	r2,r2,128
81112514:	10bfe004 	addi	r2,r2,-128
81112518:	10001426 	beq	r2,zero,8111256c <vInAckHandlerTaskV2+0x16c>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8111251c:	e0fffa43 	ldbu	r3,-23(fp)
81112520:	00a045b4 	movhi	r2,33046
81112524:	10894204 	addi	r2,r2,9480
81112528:	18c7883a 	add	r3,r3,r3
8111252c:	18c7883a 	add	r3,r3,r3
81112530:	10c5883a 	add	r2,r2,r3
81112534:	10c0000b 	ldhu	r3,0(r2)
81112538:	d0e0568d 	sth	r3,-32422(gp)
8111253c:	1080008b 	ldhu	r2,2(r2)
81112540:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81112544:	e0fffa43 	ldbu	r3,-23(fp)
81112548:	00a045b4 	movhi	r2,33046
8111254c:	10894204 	addi	r2,r2,9480
81112550:	18c7883a 	add	r3,r3,r3
81112554:	18c7883a 	add	r3,r3,r3
81112558:	10c5883a 	add	r2,r2,r3
8111255c:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81112560:	00800084 	movi	r2,2
81112564:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81112568:	00000606 	br	81112584 <vInAckHandlerTaskV2+0x184>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8111256c:	e0bffa43 	ldbu	r2,-23(fp)
81112570:	10800044 	addi	r2,r2,1
81112574:	e0bffa45 	stb	r2,-23(fp)
81112578:	e0bffa43 	ldbu	r2,-23(fp)
8111257c:	108001b0 	cmpltui	r2,r2,6
81112580:	103fdb1e 	bne	r2,zero,811124f0 <__reset+0xfb0f24f0>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81112584:	d0a06517 	ldw	r2,-32364(gp)
81112588:	1009883a 	mov	r4,r2
8111258c:	113e3cc0 	call	8113e3cc <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81112590:	00007a06 	br	8111277c <vInAckHandlerTaskV2+0x37c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81112594:	d0a06617 	ldw	r2,-32360(gp)
81112598:	1009883a 	mov	r4,r2
8111259c:	11401bc0 	call	811401bc <OSSemPost>
                    	vFailGetMutexReceiverTask();
811125a0:	111ca140 	call	8111ca14 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811125a4:	00007506 	br	8111277c <vInAckHandlerTaskV2+0x37c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
811125a8:	111c9940 	call	8111c994 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
811125ac:	00007306 	br	8111277c <vInAckHandlerTaskV2+0x37c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
811125b0:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
811125b4:	d0a06883 	ldbu	r2,-32350(gp)
811125b8:	10803fcc 	andi	r2,r2,255
811125bc:	10800218 	cmpnei	r2,r2,8
811125c0:	1000021e 	bne	r2,zero,811125cc <vInAckHandlerTaskV2+0x1cc>
811125c4:	00c00104 	movi	r3,4
811125c8:	00000106 	br	811125d0 <vInAckHandlerTaskV2+0x1d0>
811125cc:	0007883a 	mov	r3,zero
811125d0:	d0a07503 	ldbu	r2,-32300(gp)
811125d4:	10803fcc 	andi	r2,r2,255
811125d8:	10800218 	cmpnei	r2,r2,8
811125dc:	1000021e 	bne	r2,zero,811125e8 <vInAckHandlerTaskV2+0x1e8>
811125e0:	00800084 	movi	r2,2
811125e4:	00000106 	br	811125ec <vInAckHandlerTaskV2+0x1ec>
811125e8:	0005883a 	mov	r2,zero
811125ec:	1884b03a 	or	r2,r3,r2
811125f0:	1007883a 	mov	r3,r2
811125f4:	d0a07543 	ldbu	r2,-32299(gp)
811125f8:	10803fcc 	andi	r2,r2,255
811125fc:	108001a0 	cmpeqi	r2,r2,6
81112600:	1884b03a 	or	r2,r3,r2
81112604:	1007883a 	mov	r3,r2
81112608:	e0bffa83 	ldbu	r2,-22(fp)
8111260c:	1884b03a 	or	r2,r3,r2
81112610:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81112614:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81112618:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8111261c:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81112620:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81112624:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81112628:	e0bffa03 	ldbu	r2,-24(fp)
8111262c:	10800044 	addi	r2,r2,1
81112630:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81112634:	e0bffa83 	ldbu	r2,-22(fp)
81112638:	1080004c 	andi	r2,r2,1
8111263c:	10803fcc 	andi	r2,r2,255
81112640:	1000061e 	bne	r2,zero,8111265c <vInAckHandlerTaskV2+0x25c>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81112644:	e0bffd04 	addi	r2,fp,-12
81112648:	100b883a 	mov	r5,r2
8111264c:	d1205684 	addi	r4,gp,-32422
81112650:	11127800 	call	81112780 <bCheckInAck128>
81112654:	e0bff815 	stw	r2,-32(fp)
81112658:	00000206 	br	81112664 <vInAckHandlerTaskV2+0x264>
                    else
                        bFinished128 = TRUE;
8111265c:	00800044 	movi	r2,1
81112660:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81112664:	e0bffa83 	ldbu	r2,-22(fp)
81112668:	1080008c 	andi	r2,r2,2
8111266c:	10803fcc 	andi	r2,r2,255
81112670:	1000081e 	bne	r2,zero,81112694 <vInAckHandlerTaskV2+0x294>
81112674:	e0bff817 	ldw	r2,-32(fp)
81112678:	1000061e 	bne	r2,zero,81112694 <vInAckHandlerTaskV2+0x294>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8111267c:	e0bffc04 	addi	r2,fp,-16
81112680:	100b883a 	mov	r5,r2
81112684:	d1205684 	addi	r4,gp,-32422
81112688:	11128c80 	call	811128c8 <bCheckInAck64>
8111268c:	e0bff815 	stw	r2,-32(fp)
81112690:	00000206 	br	8111269c <vInAckHandlerTaskV2+0x29c>
                    else
                        bFinished64 = TRUE;
81112694:	00800044 	movi	r2,1
81112698:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8111269c:	e0bffa83 	ldbu	r2,-22(fp)
811126a0:	1080010c 	andi	r2,r2,4
811126a4:	10803fcc 	andi	r2,r2,255
811126a8:	1000081e 	bne	r2,zero,811126cc <vInAckHandlerTaskV2+0x2cc>
811126ac:	e0bff817 	ldw	r2,-32(fp)
811126b0:	1000061e 	bne	r2,zero,811126cc <vInAckHandlerTaskV2+0x2cc>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
811126b4:	e0bffb04 	addi	r2,fp,-20
811126b8:	100b883a 	mov	r5,r2
811126bc:	d1205684 	addi	r4,gp,-32422
811126c0:	1112a140 	call	81112a14 <bCheckInAck32>
811126c4:	e0bff815 	stw	r2,-32(fp)
811126c8:	00000206 	br	811126d4 <vInAckHandlerTaskV2+0x2d4>
                    else
                        bFinished32 = TRUE;
811126cc:	00800044 	movi	r2,1
811126d0:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
811126d4:	e0bffa03 	ldbu	r2,-24(fp)
811126d8:	10c00044 	addi	r3,r2,1
811126dc:	e0fffa05 	stb	r3,-24(fp)
811126e0:	10803fcc 	andi	r2,r2,255
811126e4:	10800ca8 	cmpgeui	r2,r2,50
811126e8:	10000e1e 	bne	r2,zero,81112724 <vInAckHandlerTaskV2+0x324>
811126ec:	e0bff817 	ldw	r2,-32(fp)
811126f0:	10000c1e 	bne	r2,zero,81112724 <vInAckHandlerTaskV2+0x324>
811126f4:	e0bffb17 	ldw	r2,-20(fp)
811126f8:	1005003a 	cmpeq	r2,r2,zero
811126fc:	1007883a 	mov	r3,r2
81112700:	e0bffc17 	ldw	r2,-16(fp)
81112704:	1005003a 	cmpeq	r2,r2,zero
81112708:	1884b03a 	or	r2,r3,r2
8111270c:	10c03fcc 	andi	r3,r2,255
81112710:	e0bffd17 	ldw	r2,-12(fp)
81112714:	1005003a 	cmpeq	r2,r2,zero
81112718:	10803fcc 	andi	r2,r2,255
8111271c:	1884b03a 	or	r2,r3,r2
81112720:	103fc11e 	bne	r2,zero,81112628 <__reset+0xfb0f2628>
                
                if (bFound == FALSE) {
81112724:	e0bff817 	ldw	r2,-32(fp)
81112728:	1000011e 	bne	r2,zero,81112730 <vInAckHandlerTaskV2+0x330>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8111272c:	111d0080 	call	8111d008 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81112730:	00800044 	movi	r2,1
81112734:	e0bff915 	stw	r2,-28(fp)
				break;
81112738:	00001006 	br	8111277c <vInAckHandlerTaskV2+0x37c>
			default:
                #if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly) {
8111273c:	00a045f4 	movhi	r2,33047
81112740:	10a00404 	addi	r2,r2,-32752
81112744:	10800e8b 	ldhu	r2,58(r2)
81112748:	10bfffcc 	andi	r2,r2,65535
8111274c:	108001e8 	cmpgeui	r2,r2,7
81112750:	1000071e 	bne	r2,zero,81112770 <vInAckHandlerTaskV2+0x370>
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81112754:	d0a06217 	ldw	r2,-32376(gp)
81112758:	100f883a 	mov	r7,r2
8111275c:	01801144 	movi	r6,69
81112760:	01400044 	movi	r5,1
81112764:	01204574 	movhi	r4,33045
81112768:	213a7c04 	addi	r4,r4,-5648
8111276c:	11230300 	call	81123030 <fwrite>
				}
	            #endif
                eReceiverAckState = sRAGettingACK;
81112770:	00800044 	movi	r2,1
81112774:	e0bff915 	stw	r2,-28(fp)
				break;
81112778:	0001883a 	nop
		}
	}
8111277c:	003f3c06 	br	81112470 <__reset+0xfb0f2470>

81112780 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81112780:	defffa04 	addi	sp,sp,-24
81112784:	de00012e 	bgeu	sp,et,8111278c <bCheckInAck128+0xc>
81112788:	003b68fa 	trap	3
8111278c:	dfc00515 	stw	ra,20(sp)
81112790:	df000415 	stw	fp,16(sp)
81112794:	df000404 	addi	fp,sp,16
81112798:	e13ffe15 	stw	r4,-8(fp)
8111279c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811127a0:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811127a4:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811127a8:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811127ac:	e0bfff17 	ldw	r2,-4(fp)
811127b0:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
811127b4:	d0a06e17 	ldw	r2,-32328(gp)
811127b8:	e0fffd44 	addi	r3,fp,-11
811127bc:	180d883a 	mov	r6,r3
811127c0:	01400144 	movi	r5,5
811127c4:	1009883a 	mov	r4,r2
811127c8:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811127cc:	e0bffd43 	ldbu	r2,-11(fp)
811127d0:	10803fcc 	andi	r2,r2,255
811127d4:	10000226 	beq	r2,zero,811127e0 <bCheckInAck128+0x60>
        return bFound;
811127d8:	e0bffc17 	ldw	r2,-16(fp)
811127dc:	00003506 	br	811128b4 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
811127e0:	e03ffd05 	stb	zero,-12(fp)
811127e4:	00002706 	br	81112884 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
811127e8:	e0fffd03 	ldbu	r3,-12(fp)
811127ec:	00a045b4 	movhi	r2,33046
811127f0:	10804004 	addi	r2,r2,256
811127f4:	18c02324 	muli	r3,r3,140
811127f8:	10c5883a 	add	r2,r2,r3
811127fc:	10802104 	addi	r2,r2,132
81112800:	10c0000b 	ldhu	r3,0(r2)
81112804:	e0bffe17 	ldw	r2,-8(fp)
81112808:	1080008b 	ldhu	r2,2(r2)
8111280c:	18ffffcc 	andi	r3,r3,65535
81112810:	10bfffcc 	andi	r2,r2,65535
81112814:	1880181e 	bne	r3,r2,81112878 <bCheckInAck128+0xf8>
            bFound = TRUE;
81112818:	00800044 	movi	r2,1
8111281c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81112820:	e0fffd03 	ldbu	r3,-12(fp)
81112824:	00a045b4 	movhi	r2,33046
81112828:	10802204 	addi	r2,r2,136
8111282c:	18c7883a 	add	r3,r3,r3
81112830:	18c7883a 	add	r3,r3,r3
81112834:	10c5883a 	add	r2,r2,r3
81112838:	10000015 	stw	zero,0(r2)
            SemCount128++;
8111283c:	d0a07543 	ldbu	r2,-32299(gp)
81112840:	10800044 	addi	r2,r2,1
81112844:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81112848:	d0a06317 	ldw	r2,-32372(gp)
8111284c:	1009883a 	mov	r4,r2
81112850:	11401bc0 	call	811401bc <OSSemPost>
81112854:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112858:	e0bffd43 	ldbu	r2,-11(fp)
8111285c:	10803fcc 	andi	r2,r2,255
81112860:	10000c26 	beq	r2,zero,81112894 <bCheckInAck128+0x114>
                SemCount128--;
81112864:	d0a07543 	ldbu	r2,-32299(gp)
81112868:	10bfffc4 	addi	r2,r2,-1
8111286c:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81112870:	111ce080 	call	8111ce08 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81112874:	00000706 	br	81112894 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112878:	e0bffd03 	ldbu	r2,-12(fp)
8111287c:	10800044 	addi	r2,r2,1
81112880:	e0bffd05 	stb	r2,-12(fp)
81112884:	e0bffd03 	ldbu	r2,-12(fp)
81112888:	108001b0 	cmpltui	r2,r2,6
8111288c:	103fd61e 	bne	r2,zero,811127e8 <__reset+0xfb0f27e8>
81112890:	00000106 	br	81112898 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81112894:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81112898:	d0a06e17 	ldw	r2,-32328(gp)
8111289c:	1009883a 	mov	r4,r2
811128a0:	113e3cc0 	call	8113e3cc <OSMutexPost>
    (*bFinished) = TRUE;
811128a4:	e0bfff17 	ldw	r2,-4(fp)
811128a8:	00c00044 	movi	r3,1
811128ac:	10c00015 	stw	r3,0(r2)

    return bFound;
811128b0:	e0bffc17 	ldw	r2,-16(fp)
}
811128b4:	e037883a 	mov	sp,fp
811128b8:	dfc00117 	ldw	ra,4(sp)
811128bc:	df000017 	ldw	fp,0(sp)
811128c0:	dec00204 	addi	sp,sp,8
811128c4:	f800283a 	ret

811128c8 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
811128c8:	defffa04 	addi	sp,sp,-24
811128cc:	de00012e 	bgeu	sp,et,811128d4 <bCheckInAck64+0xc>
811128d0:	003b68fa 	trap	3
811128d4:	dfc00515 	stw	ra,20(sp)
811128d8:	df000415 	stw	fp,16(sp)
811128dc:	df000404 	addi	fp,sp,16
811128e0:	e13ffe15 	stw	r4,-8(fp)
811128e4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811128e8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811128ec:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811128f0:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811128f4:	e0bfff17 	ldw	r2,-4(fp)
811128f8:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811128fc:	d0a07117 	ldw	r2,-32316(gp)
81112900:	e0fffd44 	addi	r3,fp,-11
81112904:	180d883a 	mov	r6,r3
81112908:	01400044 	movi	r5,1
8111290c:	1009883a 	mov	r4,r2
81112910:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112914:	e0bffd43 	ldbu	r2,-11(fp)
81112918:	10803fcc 	andi	r2,r2,255
8111291c:	10000226 	beq	r2,zero,81112928 <bCheckInAck64+0x60>
        return bFound;
81112920:	e0bffc17 	ldw	r2,-16(fp)
81112924:	00003606 	br	81112a00 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81112928:	e03ffd05 	stb	zero,-12(fp)
8111292c:	00002806 	br	811129d0 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
81112930:	e0fffd03 	ldbu	r3,-12(fp)
81112934:	00a04574 	movhi	r2,33045
81112938:	109be604 	addi	r2,r2,28568
8111293c:	18c01324 	muli	r3,r3,76
81112940:	10c5883a 	add	r2,r2,r3
81112944:	10801104 	addi	r2,r2,68
81112948:	10c0000b 	ldhu	r3,0(r2)
8111294c:	e0bffe17 	ldw	r2,-8(fp)
81112950:	1080008b 	ldhu	r2,2(r2)
81112954:	18ffffcc 	andi	r3,r3,65535
81112958:	10bfffcc 	andi	r2,r2,65535
8111295c:	1880191e 	bne	r3,r2,811129c4 <bCheckInAck64+0xfc>
            bFound = TRUE;
81112960:	00800044 	movi	r2,1
81112964:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
81112968:	e0fffd03 	ldbu	r3,-12(fp)
8111296c:	00a045b4 	movhi	r2,33046
81112970:	10802204 	addi	r2,r2,136
81112974:	18c00184 	addi	r3,r3,6
81112978:	18c7883a 	add	r3,r3,r3
8111297c:	18c7883a 	add	r3,r3,r3
81112980:	10c5883a 	add	r2,r2,r3
81112984:	10000015 	stw	zero,0(r2)
            SemCount64++;
81112988:	d0a07503 	ldbu	r2,-32300(gp)
8111298c:	10800044 	addi	r2,r2,1
81112990:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
81112994:	d0a05e17 	ldw	r2,-32392(gp)
81112998:	1009883a 	mov	r4,r2
8111299c:	11401bc0 	call	811401bc <OSSemPost>
811129a0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811129a4:	e0bffd43 	ldbu	r2,-11(fp)
811129a8:	10803fcc 	andi	r2,r2,255
811129ac:	10000c26 	beq	r2,zero,811129e0 <bCheckInAck64+0x118>
                SemCount64--;
811129b0:	d0a07503 	ldbu	r2,-32300(gp)
811129b4:	10bfffc4 	addi	r2,r2,-1
811129b8:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
811129bc:	111cd880 	call	8111cd88 <vFailSetCountSemaphorexBuffer64>
            }
            break;
811129c0:	00000706 	br	811129e0 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811129c4:	e0bffd03 	ldbu	r2,-12(fp)
811129c8:	10800044 	addi	r2,r2,1
811129cc:	e0bffd05 	stb	r2,-12(fp)
811129d0:	e0bffd03 	ldbu	r2,-12(fp)
811129d4:	10800230 	cmpltui	r2,r2,8
811129d8:	103fd51e 	bne	r2,zero,81112930 <__reset+0xfb0f2930>
811129dc:	00000106 	br	811129e4 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
811129e0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
811129e4:	d0a07117 	ldw	r2,-32316(gp)
811129e8:	1009883a 	mov	r4,r2
811129ec:	113e3cc0 	call	8113e3cc <OSMutexPost>
    (*bFinished) = TRUE;
811129f0:	e0bfff17 	ldw	r2,-4(fp)
811129f4:	00c00044 	movi	r3,1
811129f8:	10c00015 	stw	r3,0(r2)

    return bFound;
811129fc:	e0bffc17 	ldw	r2,-16(fp)
}
81112a00:	e037883a 	mov	sp,fp
81112a04:	dfc00117 	ldw	ra,4(sp)
81112a08:	df000017 	ldw	fp,0(sp)
81112a0c:	dec00204 	addi	sp,sp,8
81112a10:	f800283a 	ret

81112a14 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81112a14:	defffa04 	addi	sp,sp,-24
81112a18:	de00012e 	bgeu	sp,et,81112a20 <bCheckInAck32+0xc>
81112a1c:	003b68fa 	trap	3
81112a20:	dfc00515 	stw	ra,20(sp)
81112a24:	df000415 	stw	fp,16(sp)
81112a28:	df000404 	addi	fp,sp,16
81112a2c:	e13ffe15 	stw	r4,-8(fp)
81112a30:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112a34:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81112a38:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81112a3c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112a40:	e0bfff17 	ldw	r2,-4(fp)
81112a44:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81112a48:	d0a06c17 	ldw	r2,-32336(gp)
81112a4c:	e0fffd44 	addi	r3,fp,-11
81112a50:	180d883a 	mov	r6,r3
81112a54:	01400044 	movi	r5,1
81112a58:	1009883a 	mov	r4,r2
81112a5c:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112a60:	e0bffd43 	ldbu	r2,-11(fp)
81112a64:	10803fcc 	andi	r2,r2,255
81112a68:	10000226 	beq	r2,zero,81112a74 <bCheckInAck32+0x60>
        return bFound;
81112a6c:	e0bffc17 	ldw	r2,-16(fp)
81112a70:	00003606 	br	81112b4c <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81112a74:	e03ffd05 	stb	zero,-12(fp)
81112a78:	00002806 	br	81112b1c <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81112a7c:	e0fffd03 	ldbu	r3,-12(fp)
81112a80:	00a045b4 	movhi	r2,33046
81112a84:	10ada204 	addi	r2,r2,-18808
81112a88:	18c00b24 	muli	r3,r3,44
81112a8c:	10c5883a 	add	r2,r2,r3
81112a90:	10800904 	addi	r2,r2,36
81112a94:	10c0000b 	ldhu	r3,0(r2)
81112a98:	e0bffe17 	ldw	r2,-8(fp)
81112a9c:	1080008b 	ldhu	r2,2(r2)
81112aa0:	18ffffcc 	andi	r3,r3,65535
81112aa4:	10bfffcc 	andi	r2,r2,65535
81112aa8:	1880191e 	bne	r3,r2,81112b10 <bCheckInAck32+0xfc>
            bFound = TRUE;
81112aac:	00800044 	movi	r2,1
81112ab0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81112ab4:	e0fffd03 	ldbu	r3,-12(fp)
81112ab8:	00a045b4 	movhi	r2,33046
81112abc:	10802204 	addi	r2,r2,136
81112ac0:	18c00384 	addi	r3,r3,14
81112ac4:	18c7883a 	add	r3,r3,r3
81112ac8:	18c7883a 	add	r3,r3,r3
81112acc:	10c5883a 	add	r2,r2,r3
81112ad0:	10000015 	stw	zero,0(r2)
            SemCount32++;
81112ad4:	d0a06883 	ldbu	r2,-32350(gp)
81112ad8:	10800044 	addi	r2,r2,1
81112adc:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81112ae0:	d0a06f17 	ldw	r2,-32324(gp)
81112ae4:	1009883a 	mov	r4,r2
81112ae8:	11401bc0 	call	811401bc <OSSemPost>
81112aec:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112af0:	e0bffd43 	ldbu	r2,-11(fp)
81112af4:	10803fcc 	andi	r2,r2,255
81112af8:	10000c26 	beq	r2,zero,81112b2c <bCheckInAck32+0x118>
                SemCount32--;
81112afc:	d0a06883 	ldbu	r2,-32350(gp)
81112b00:	10bfffc4 	addi	r2,r2,-1
81112b04:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
81112b08:	111cd080 	call	8111cd08 <vFailSetCountSemaphorexBuffer32>
            }
            break;
81112b0c:	00000706 	br	81112b2c <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81112b10:	e0bffd03 	ldbu	r2,-12(fp)
81112b14:	10800044 	addi	r2,r2,1
81112b18:	e0bffd05 	stb	r2,-12(fp)
81112b1c:	e0bffd03 	ldbu	r2,-12(fp)
81112b20:	10800230 	cmpltui	r2,r2,8
81112b24:	103fd51e 	bne	r2,zero,81112a7c <__reset+0xfb0f2a7c>
81112b28:	00000106 	br	81112b30 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81112b2c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
81112b30:	d0a06c17 	ldw	r2,-32336(gp)
81112b34:	1009883a 	mov	r4,r2
81112b38:	113e3cc0 	call	8113e3cc <OSMutexPost>
    (*bFinished) = TRUE;
81112b3c:	e0bfff17 	ldw	r2,-4(fp)
81112b40:	00c00044 	movi	r3,1
81112b44:	10c00015 	stw	r3,0(r2)

    return bFound;
81112b48:	e0bffc17 	ldw	r2,-16(fp)
}
81112b4c:	e037883a 	mov	sp,fp
81112b50:	dfc00117 	ldw	ra,4(sp)
81112b54:	df000017 	ldw	fp,0(sp)
81112b58:	dec00204 	addi	sp,sp,8
81112b5c:	f800283a 	ret

81112b60 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81112b60:	defff704 	addi	sp,sp,-36
81112b64:	de00012e 	bgeu	sp,et,81112b6c <vInitialTask+0xc>
81112b68:	003b68fa 	trap	3
81112b6c:	dfc00815 	stw	ra,32(sp)
81112b70:	df000715 	stw	fp,28(sp)
81112b74:	df000704 	addi	fp,sp,28
81112b78:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81112b7c:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81112b80:	d8000415 	stw	zero,16(sp)
81112b84:	d8000315 	stw	zero,12(sp)
81112b88:	00810004 	movi	r2,1024
81112b8c:	d8800215 	stw	r2,8(sp)
81112b90:	00a04574 	movhi	r2,33045
81112b94:	1093e604 	addi	r2,r2,20376
81112b98:	d8800115 	stw	r2,4(sp)
81112b9c:	008002c4 	movi	r2,11
81112ba0:	d8800015 	stw	r2,0(sp)
81112ba4:	01c002c4 	movi	r7,11
81112ba8:	01a04574 	movhi	r6,33045
81112bac:	3197e504 	addi	r6,r6,24468
81112bb0:	016045b4 	movhi	r5,33046
81112bb4:	29690604 	addi	r5,r5,-23528
81112bb8:	01204474 	movhi	r4,33041
81112bbc:	2136ca04 	addi	r4,r4,-9432
81112bc0:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112bc4:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112bc8:	e0bffe03 	ldbu	r2,-8(fp)
81112bcc:	10803fcc 	andi	r2,r2,255
81112bd0:	10000b26 	beq	r2,zero,81112c00 <vInitialTask+0xa0>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112bd4:	00a045f4 	movhi	r2,33047
81112bd8:	10a00404 	addi	r2,r2,-32752
81112bdc:	10800e8b 	ldhu	r2,58(r2)
81112be0:	10bfffcc 	andi	r2,r2,65535
81112be4:	108001e8 	cmpgeui	r2,r2,7
81112be8:	1000041e 	bne	r2,zero,81112bfc <vInitialTask+0x9c>
			printErrorTask( error_code );
81112bec:	e0bffe03 	ldbu	r2,-8(fp)
81112bf0:	10803fcc 	andi	r2,r2,255
81112bf4:	1009883a 	mov	r4,r2
81112bf8:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFee0Task();
81112bfc:	111de900 	call	8111de90 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112c00:	01c17704 	movi	r7,1500
81112c04:	000d883a 	mov	r6,zero
81112c08:	000b883a 	mov	r5,zero
81112c0c:	0009883a 	mov	r4,zero
81112c10:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81112c14:	d8000415 	stw	zero,16(sp)
81112c18:	d8000315 	stw	zero,12(sp)
81112c1c:	00810004 	movi	r2,1024
81112c20:	d8800215 	stw	r2,8(sp)
81112c24:	00a045b4 	movhi	r2,33046
81112c28:	10a4f404 	addi	r2,r2,-27696
81112c2c:	d8800115 	stw	r2,4(sp)
81112c30:	00800284 	movi	r2,10
81112c34:	d8800015 	stw	r2,0(sp)
81112c38:	01c00284 	movi	r7,10
81112c3c:	01a045b4 	movhi	r6,33046
81112c40:	31a8f304 	addi	r6,r6,-23604
81112c44:	016045b4 	movhi	r5,33046
81112c48:	2968fe04 	addi	r5,r5,-23560
81112c4c:	01204474 	movhi	r4,33041
81112c50:	21369c04 	addi	r4,r4,-9616
81112c54:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112c58:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112c5c:	e0bffe03 	ldbu	r2,-8(fp)
81112c60:	10803fcc 	andi	r2,r2,255
81112c64:	10000b26 	beq	r2,zero,81112c94 <vInitialTask+0x134>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112c68:	00a045f4 	movhi	r2,33047
81112c6c:	10a00404 	addi	r2,r2,-32752
81112c70:	10800e8b 	ldhu	r2,58(r2)
81112c74:	10bfffcc 	andi	r2,r2,65535
81112c78:	108001e8 	cmpgeui	r2,r2,7
81112c7c:	1000041e 	bne	r2,zero,81112c90 <vInitialTask+0x130>
			printErrorTask( error_code );
81112c80:	e0bffe03 	ldbu	r2,-8(fp)
81112c84:	10803fcc 	andi	r2,r2,255
81112c88:	1009883a 	mov	r4,r2
81112c8c:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
			vCoudlNotCreateDataControllerTask();
81112c90:	111e2100 	call	8111e210 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112c94:	01c17704 	movi	r7,1500
81112c98:	000d883a 	mov	r6,zero
81112c9c:	000b883a 	mov	r5,zero
81112ca0:	0009883a 	mov	r4,zero
81112ca4:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81112ca8:	d8000415 	stw	zero,16(sp)
81112cac:	d8000315 	stw	zero,12(sp)
81112cb0:	00810004 	movi	r2,1024
81112cb4:	d8800215 	stw	r2,8(sp)
81112cb8:	00a045b4 	movhi	r2,33046
81112cbc:	10812a04 	addi	r2,r2,1192
81112cc0:	d8800115 	stw	r2,4(sp)
81112cc4:	00800244 	movi	r2,9
81112cc8:	d8800015 	stw	r2,0(sp)
81112ccc:	01c00244 	movi	r7,9
81112cd0:	01a045b4 	movhi	r6,33046
81112cd4:	31852904 	addi	r6,r6,5284
81112cd8:	016045b4 	movhi	r5,33046
81112cdc:	29690604 	addi	r5,r5,-23528
81112ce0:	01204474 	movhi	r4,33041
81112ce4:	210c7b04 	addi	r4,r4,12780
81112ce8:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112cec:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112cf0:	e0bffe03 	ldbu	r2,-8(fp)
81112cf4:	10803fcc 	andi	r2,r2,255
81112cf8:	10000b26 	beq	r2,zero,81112d28 <vInitialTask+0x1c8>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112cfc:	00a045f4 	movhi	r2,33047
81112d00:	10a00404 	addi	r2,r2,-32752
81112d04:	10800e8b 	ldhu	r2,58(r2)
81112d08:	10bfffcc 	andi	r2,r2,65535
81112d0c:	108001e8 	cmpgeui	r2,r2,7
81112d10:	1000041e 	bne	r2,zero,81112d24 <vInitialTask+0x1c4>
			printErrorTask( error_code );
81112d14:	e0bffe03 	ldbu	r2,-8(fp)
81112d18:	10803fcc 	andi	r2,r2,255
81112d1c:	1009883a 	mov	r4,r2
81112d20:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFeeControllerTask();
81112d24:	111e1900 	call	8111e190 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112d28:	01c17704 	movi	r7,1500
81112d2c:	000d883a 	mov	r6,zero
81112d30:	000b883a 	mov	r5,zero
81112d34:	0009883a 	mov	r4,zero
81112d38:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81112d3c:	d8000415 	stw	zero,16(sp)
81112d40:	d8000315 	stw	zero,12(sp)
81112d44:	00810004 	movi	r2,1024
81112d48:	d8800215 	stw	r2,8(sp)
81112d4c:	00a045b4 	movhi	r2,33046
81112d50:	10934c04 	addi	r2,r2,19760
81112d54:	d8800115 	stw	r2,4(sp)
81112d58:	00800204 	movi	r2,8
81112d5c:	d8800015 	stw	r2,0(sp)
81112d60:	01c00204 	movi	r7,8
81112d64:	01a045b4 	movhi	r6,33046
81112d68:	31974b04 	addi	r6,r6,23852
81112d6c:	016045b4 	movhi	r5,33046
81112d70:	2968f404 	addi	r5,r5,-23600
81112d74:	01204474 	movhi	r4,33041
81112d78:	21170704 	addi	r4,r4,23580
81112d7c:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112d80:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112d84:	e0bffe03 	ldbu	r2,-8(fp)
81112d88:	10803fcc 	andi	r2,r2,255
81112d8c:	10000b26 	beq	r2,zero,81112dbc <vInitialTask+0x25c>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112d90:	00a045f4 	movhi	r2,33047
81112d94:	10a00404 	addi	r2,r2,-32752
81112d98:	10800e8b 	ldhu	r2,58(r2)
81112d9c:	10bfffcc 	andi	r2,r2,65535
81112da0:	108001e8 	cmpgeui	r2,r2,7
81112da4:	1000041e 	bne	r2,zero,81112db8 <vInitialTask+0x258>
			printErrorTask( error_code );
81112da8:	e0bffe03 	ldbu	r2,-8(fp)
81112dac:	10803fcc 	andi	r2,r2,255
81112db0:	1009883a 	mov	r4,r2
81112db4:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
			vCoudlNotCreateMebTask();
81112db8:	111e2900 	call	8111e290 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112dbc:	01c17704 	movi	r7,1500
81112dc0:	000d883a 	mov	r6,zero
81112dc4:	000b883a 	mov	r5,zero
81112dc8:	0009883a 	mov	r4,zero
81112dcc:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81112dd0:	d8000415 	stw	zero,16(sp)
81112dd4:	d8000315 	stw	zero,12(sp)
81112dd8:	00810004 	movi	r2,1024
81112ddc:	d8800215 	stw	r2,8(sp)
81112de0:	00a045b4 	movhi	r2,33046
81112de4:	10a0f404 	addi	r2,r2,-31792
81112de8:	d8800115 	stw	r2,4(sp)
81112dec:	00800784 	movi	r2,30
81112df0:	d8800015 	stw	r2,0(sp)
81112df4:	01c00784 	movi	r7,30
81112df8:	01a045b4 	movhi	r6,33046
81112dfc:	31a4f304 	addi	r6,r6,-27700
81112e00:	000b883a 	mov	r5,zero
81112e04:	01204474 	movhi	r4,33041
81112e08:	211e8a04 	addi	r4,r4,31272
81112e0c:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112e10:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112e14:	e0bffe03 	ldbu	r2,-8(fp)
81112e18:	10803fcc 	andi	r2,r2,255
81112e1c:	10000b26 	beq	r2,zero,81112e4c <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112e20:	00a045f4 	movhi	r2,33047
81112e24:	10a00404 	addi	r2,r2,-32752
81112e28:	10800e8b 	ldhu	r2,58(r2)
81112e2c:	10bfffcc 	andi	r2,r2,65535
81112e30:	108001e8 	cmpgeui	r2,r2,7
81112e34:	1000041e 	bne	r2,zero,81112e48 <vInitialTask+0x2e8>
			printErrorTask( error_code );
81112e38:	e0bffe03 	ldbu	r2,-8(fp)
81112e3c:	10803fcc 	andi	r2,r2,255
81112e40:	1009883a 	mov	r4,r2
81112e44:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailTimeoutCheckerTaskCreate();
81112e48:	111d67c0 	call	8111d67c <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112e4c:	01c03204 	movi	r7,200
81112e50:	000d883a 	mov	r6,zero
81112e54:	000b883a 	mov	r5,zero
81112e58:	0009883a 	mov	r4,zero
81112e5c:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81112e60:	d8000415 	stw	zero,16(sp)
81112e64:	d8000315 	stw	zero,12(sp)
81112e68:	00810004 	movi	r2,1024
81112e6c:	d8800215 	stw	r2,8(sp)
81112e70:	00a045b4 	movhi	r2,33046
81112e74:	10b40a04 	addi	r2,r2,-12248
81112e78:	d8800115 	stw	r2,4(sp)
81112e7c:	008006c4 	movi	r2,27
81112e80:	d8800015 	stw	r2,0(sp)
81112e84:	01c006c4 	movi	r7,27
81112e88:	01a045b4 	movhi	r6,33046
81112e8c:	31b80904 	addi	r6,r6,-8156
81112e90:	000b883a 	mov	r5,zero
81112e94:	01204474 	movhi	r4,33041
81112e98:	210e8e04 	addi	r4,r4,14904
81112e9c:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112ea0:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112ea4:	e0bffe03 	ldbu	r2,-8(fp)
81112ea8:	10803fcc 	andi	r2,r2,255
81112eac:	10000b26 	beq	r2,zero,81112edc <vInitialTask+0x37c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112eb0:	00a045f4 	movhi	r2,33047
81112eb4:	10a00404 	addi	r2,r2,-32752
81112eb8:	10800e8b 	ldhu	r2,58(r2)
81112ebc:	10bfffcc 	andi	r2,r2,65535
81112ec0:	108001e8 	cmpgeui	r2,r2,7
81112ec4:	1000041e 	bne	r2,zero,81112ed8 <vInitialTask+0x378>
			printErrorTask( error_code );
81112ec8:	e0bffe03 	ldbu	r2,-8(fp)
81112ecc:	10803fcc 	andi	r2,r2,255
81112ed0:	1009883a 	mov	r4,r2
81112ed4:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailOutAckHandlerTaskCreate();
81112ed8:	111d5500 	call	8111d550 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112edc:	01c03204 	movi	r7,200
81112ee0:	000d883a 	mov	r6,zero
81112ee4:	000b883a 	mov	r5,zero
81112ee8:	0009883a 	mov	r4,zero
81112eec:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81112ef0:	d8000415 	stw	zero,16(sp)
81112ef4:	d8000315 	stw	zero,12(sp)
81112ef8:	00810004 	movi	r2,1024
81112efc:	d8800215 	stw	r2,8(sp)
81112f00:	00a04574 	movhi	r2,33045
81112f04:	1097e604 	addi	r2,r2,24472
81112f08:	d8800115 	stw	r2,4(sp)
81112f0c:	00800644 	movi	r2,25
81112f10:	d8800015 	stw	r2,0(sp)
81112f14:	01c00644 	movi	r7,25
81112f18:	01a04574 	movhi	r6,33045
81112f1c:	319be504 	addi	r6,r6,28564
81112f20:	000b883a 	mov	r5,zero
81112f24:	01204474 	movhi	r4,33041
81112f28:	21090004 	addi	r4,r4,9216
81112f2c:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112f30:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112f34:	e0bffe03 	ldbu	r2,-8(fp)
81112f38:	10803fcc 	andi	r2,r2,255
81112f3c:	10000b26 	beq	r2,zero,81112f6c <vInitialTask+0x40c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112f40:	00a045f4 	movhi	r2,33047
81112f44:	10a00404 	addi	r2,r2,-32752
81112f48:	10800e8b 	ldhu	r2,58(r2)
81112f4c:	10bfffcc 	andi	r2,r2,65535
81112f50:	108001e8 	cmpgeui	r2,r2,7
81112f54:	1000041e 	bne	r2,zero,81112f68 <vInitialTask+0x408>
			printErrorTask( error_code );
81112f58:	e0bffe03 	ldbu	r2,-8(fp)
81112f5c:	10803fcc 	andi	r2,r2,255
81112f60:	1009883a 	mov	r4,r2
81112f64:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailInAckHandlerTaskCreate();
81112f68:	111d4ec0 	call	8111d4ec <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112f6c:	01c03204 	movi	r7,200
81112f70:	000d883a 	mov	r6,zero
81112f74:	000b883a 	mov	r5,zero
81112f78:	0009883a 	mov	r4,zero
81112f7c:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81112f80:	d8000415 	stw	zero,16(sp)
81112f84:	d8000315 	stw	zero,12(sp)
81112f88:	00818004 	movi	r2,1536
81112f8c:	d8800215 	stw	r2,8(sp)
81112f90:	00a045b4 	movhi	r2,33046
81112f94:	108d4804 	addi	r2,r2,13600
81112f98:	d8800115 	stw	r2,4(sp)
81112f9c:	00800704 	movi	r2,28
81112fa0:	d8800015 	stw	r2,0(sp)
81112fa4:	01c00704 	movi	r7,28
81112fa8:	01a045b4 	movhi	r6,33046
81112fac:	31934704 	addi	r6,r6,19740
81112fb0:	000b883a 	mov	r5,zero
81112fb4:	01204474 	movhi	r4,33041
81112fb8:	210f5804 	addi	r4,r4,15712
81112fbc:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81112fc0:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112fc4:	e0bffe03 	ldbu	r2,-8(fp)
81112fc8:	10803fcc 	andi	r2,r2,255
81112fcc:	10000b26 	beq	r2,zero,81112ffc <vInitialTask+0x49c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112fd0:	00a045f4 	movhi	r2,33047
81112fd4:	10a00404 	addi	r2,r2,-32752
81112fd8:	10800e8b 	ldhu	r2,58(r2)
81112fdc:	10bfffcc 	andi	r2,r2,65535
81112fe0:	108001e8 	cmpgeui	r2,r2,7
81112fe4:	1000041e 	bne	r2,zero,81112ff8 <vInitialTask+0x498>
			printErrorTask( error_code );
81112fe8:	e0bffe03 	ldbu	r2,-8(fp)
81112fec:	10803fcc 	andi	r2,r2,255
81112ff0:	1009883a 	mov	r4,r2
81112ff4:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailParserCommTaskCreate();
81112ff8:	111d4880 	call	8111d488 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112ffc:	01c03204 	movi	r7,200
81113000:	000d883a 	mov	r6,zero
81113004:	000b883a 	mov	r5,zero
81113008:	0009883a 	mov	r4,zero
8111300c:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81113010:	d8000415 	stw	zero,16(sp)
81113014:	d8000315 	stw	zero,12(sp)
81113018:	00818004 	movi	r2,1536
8111301c:	d8800215 	stw	r2,8(sp)
81113020:	00a045b4 	movhi	r2,33046
81113024:	10adfa04 	addi	r2,r2,-18456
81113028:	d8800115 	stw	r2,4(sp)
8111302c:	00800804 	movi	r2,32
81113030:	d8800015 	stw	r2,0(sp)
81113034:	01c00804 	movi	r7,32
81113038:	01a045b4 	movhi	r6,33046
8111303c:	31b3f904 	addi	r6,r6,-12316
81113040:	000b883a 	mov	r5,zero
81113044:	01204474 	movhi	r4,33041
81113048:	2113e804 	addi	r4,r4,20384
8111304c:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81113050:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113054:	e0bffe03 	ldbu	r2,-8(fp)
81113058:	10803fcc 	andi	r2,r2,255
8111305c:	10000b26 	beq	r2,zero,8111308c <vInitialTask+0x52c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113060:	00a045f4 	movhi	r2,33047
81113064:	10a00404 	addi	r2,r2,-32752
81113068:	10800e8b 	ldhu	r2,58(r2)
8111306c:	10bfffcc 	andi	r2,r2,65535
81113070:	108001e8 	cmpgeui	r2,r2,7
81113074:	1000041e 	bne	r2,zero,81113088 <vInitialTask+0x528>
			printErrorTask( error_code );
81113078:	e0bffe03 	ldbu	r2,-8(fp)
8111307c:	10803fcc 	andi	r2,r2,255
81113080:	1009883a 	mov	r4,r2
81113084:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailReceiverCreate();
81113088:	111cbdc0 	call	8111cbdc <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8111308c:	01c03204 	movi	r7,200
81113090:	000d883a 	mov	r6,zero
81113094:	000b883a 	mov	r5,zero
81113098:	0009883a 	mov	r4,zero
8111309c:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
811130a0:	d8000415 	stw	zero,16(sp)
811130a4:	d8000315 	stw	zero,12(sp)
811130a8:	00810004 	movi	r2,1024
811130ac:	d8800215 	stw	r2,8(sp)
811130b0:	00a04574 	movhi	r2,33045
811130b4:	109ce204 	addi	r2,r2,29576
811130b8:	d8800115 	stw	r2,4(sp)
811130bc:	00800684 	movi	r2,26
811130c0:	d8800015 	stw	r2,0(sp)
811130c4:	01c00684 	movi	r7,26
811130c8:	01a045b4 	movhi	r6,33046
811130cc:	31a0e104 	addi	r6,r6,-31868
811130d0:	000b883a 	mov	r5,zero
811130d4:	01204474 	movhi	r4,33041
811130d8:	21168304 	addi	r4,r4,23052
811130dc:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
811130e0:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
811130e4:	01c03204 	movi	r7,200
811130e8:	000d883a 	mov	r6,zero
811130ec:	000b883a 	mov	r5,zero
811130f0:	0009883a 	mov	r4,zero
811130f4:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
811130f8:	e0bffe03 	ldbu	r2,-8(fp)
811130fc:	10803fcc 	andi	r2,r2,255
81113100:	10000b26 	beq	r2,zero,81113130 <vInitialTask+0x5d0>
		/* Can't create Task for sender comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113104:	00a045f4 	movhi	r2,33047
81113108:	10a00404 	addi	r2,r2,-32752
8111310c:	10800e8b 	ldhu	r2,58(r2)
81113110:	10bfffcc 	andi	r2,r2,65535
81113114:	108001e8 	cmpgeui	r2,r2,7
81113118:	1000041e 	bne	r2,zero,8111312c <vInitialTask+0x5cc>
			printErrorTask( error_code );
8111311c:	e0bffe03 	ldbu	r2,-8(fp)
81113120:	10803fcc 	andi	r2,r2,255
81113124:	1009883a 	mov	r4,r2
81113128:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailSenderCreate();
8111312c:	111cc400 	call	8111cc40 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
81113130:	d0a06d17 	ldw	r2,-32332(gp)
81113134:	e17ffe04 	addi	r5,fp,-8
81113138:	1009883a 	mov	r4,r2
8111313c:	11428c00 	call	811428c0 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81113140:	e0bffe03 	ldbu	r2,-8(fp)
81113144:	10803fcc 	andi	r2,r2,255
81113148:	10000126 	beq	r2,zero,81113150 <vInitialTask+0x5f0>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8111314c:	111d9e00 	call	8111d9e0 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
81113150:	01c00084 	movi	r7,2
81113154:	01800784 	movi	r6,30
81113158:	000b883a 	mov	r5,zero
8111315c:	0009883a 	mov	r4,zero
81113160:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
81113164:	01003fc4 	movi	r4,255
81113168:	1140d8c0 	call	81140d8c <OSTaskDel>
8111316c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81113170:	e0bffe03 	ldbu	r2,-8(fp)
81113174:	10803fcc 	andi	r2,r2,255
81113178:	10001626 	beq	r2,zero,811131d4 <vInitialTask+0x674>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111317c:	00a045f4 	movhi	r2,33047
81113180:	10a00404 	addi	r2,r2,-32752
81113184:	10800e8b 	ldhu	r2,58(r2)
81113188:	10bfffcc 	andi	r2,r2,65535
8111318c:	108001e8 	cmpgeui	r2,r2,7
81113190:	1000041e 	bne	r2,zero,811131a4 <vInitialTask+0x644>
			printErrorTask( error_code );		
81113194:	e0bffe03 	ldbu	r2,-8(fp)
81113198:	10803fcc 	andi	r2,r2,255
8111319c:	1009883a 	mov	r4,r2
811131a0:	111c4d40 	call	8111c4d4 <printErrorTask>
		}
		#endif
		vFailDeleteInitialization();
811131a4:	111cca40 	call	8111cca4 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
811131a8:	014009c4 	movi	r5,39
811131ac:	01000044 	movi	r4,1
811131b0:	11404f40 	call	811404f4 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
811131b4:	01003fc4 	movi	r4,255
811131b8:	1140d8c0 	call	81140d8c <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
811131bc:	000f883a 	mov	r7,zero
811131c0:	01800284 	movi	r6,10
811131c4:	000b883a 	mov	r5,zero
811131c8:	0009883a 	mov	r4,zero
811131cc:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
		}
811131d0:	003ff806 	br	811131b4 <__reset+0xfb0f31b4>
	}

}
811131d4:	0001883a 	nop
811131d8:	e037883a 	mov	sp,fp
811131dc:	dfc00117 	ldw	ra,4(sp)
811131e0:	df000017 	ldw	fp,0(sp)
811131e4:	dec00204 	addi	sp,sp,8
811131e8:	f800283a 	ret

811131ec <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
811131ec:	defff704 	addi	sp,sp,-36
811131f0:	de00012e 	bgeu	sp,et,811131f8 <vNFeeControlTask+0xc>
811131f4:	003b68fa 	trap	3
811131f8:	dfc00815 	stw	ra,32(sp)
811131fc:	df000715 	stw	fp,28(sp)
81113200:	df000704 	addi	fp,sp,28
81113204:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81113208:	e0bfff17 	ldw	r2,-4(fp)
8111320c:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113210:	00a045f4 	movhi	r2,33047
81113214:	10a00404 	addi	r2,r2,-32752
81113218:	10800e8b 	ldhu	r2,58(r2)
8111321c:	10bfffcc 	andi	r2,r2,65535
81113220:	10800168 	cmpgeui	r2,r2,5
81113224:	1000071e 	bne	r2,zero,81113244 <vNFeeControlTask+0x58>
        debug(fp,"NFee Controller Task. (Task on)\n");
81113228:	d0a06217 	ldw	r2,-32376(gp)
8111322c:	100f883a 	mov	r7,r2
81113230:	01800804 	movi	r6,32
81113234:	01400044 	movi	r5,1
81113238:	01204574 	movhi	r4,33045
8111323c:	213a8e04 	addi	r4,r4,-5576
81113240:	11230300 	call	81123030 <fwrite>
	}
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
81113244:	e0bffa17 	ldw	r2,-24(fp)
81113248:	10809a17 	ldw	r2,616(r2)
8111324c:	10c00168 	cmpgeui	r3,r2,5
81113250:	1800e71e 	bne	r3,zero,811135f0 <vNFeeControlTask+0x404>
81113254:	100690ba 	slli	r3,r2,2
81113258:	00a04474 	movhi	r2,33041
8111325c:	108c9b04 	addi	r2,r2,12908
81113260:	1885883a 	add	r2,r3,r2
81113264:	10800017 	ldw	r2,0(r2)
81113268:	1000683a 	jmp	r2
8111326c:	81113280 	call	88111328 <__reset+0x20f1328>
81113270:	811132b0 	cmpltui	r4,r16,17610
81113274:	81113328 	cmpgeui	r4,r16,17612
81113278:	811133f4 	orhi	r4,r16,17615
8111327c:	81113454 	ori	r4,r16,17617
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
81113280:	d0a07017 	ldw	r2,-32320(gp)
81113284:	1009883a 	mov	r4,r2
81113288:	113ee7c0 	call	8113ee7c <OSQFlush>
8111328c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113290:	e0bffe03 	ldbu	r2,-8(fp)
81113294:	10803fcc 	andi	r2,r2,255
81113298:	10000126 	beq	r2,zero,811132a0 <vNFeeControlTask+0xb4>
					vFailFlushQueue();
8111329c:	111ea840 	call	8111ea84 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
811132a0:	e0bffa17 	ldw	r2,-24(fp)
811132a4:	00c00044 	movi	r3,1
811132a8:	10c09a15 	stw	r3,616(r2)
				break;
811132ac:	0000e206 	br	81113638 <vNFeeControlTask+0x44c>


			case sMebToConfig:
				/* Transition state */
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811132b0:	00a045f4 	movhi	r2,33047
811132b4:	10a00404 	addi	r2,r2,-32752
811132b8:	10800e8b 	ldhu	r2,58(r2)
811132bc:	10bfffcc 	andi	r2,r2,65535
811132c0:	108000e8 	cmpgeui	r2,r2,3
811132c4:	1000071e 	bne	r2,zero,811132e4 <vNFeeControlTask+0xf8>
					debug(fp,"NFEE Controller Task: Config Mode\n");
811132c8:	d0a06217 	ldw	r2,-32376(gp)
811132cc:	100f883a 	mov	r7,r2
811132d0:	01800884 	movi	r6,34
811132d4:	01400044 	movi	r5,1
811132d8:	01204574 	movhi	r4,33045
811132dc:	213a9704 	addi	r4,r4,-5540
811132e0:	11230300 	call	81123030 <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
811132e4:	d0a05d17 	ldw	r2,-32396(gp)
811132e8:	1009883a 	mov	r4,r2
811132ec:	113ee7c0 	call	8113ee7c <OSQFlush>
811132f0:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811132f4:	e0bffe03 	ldbu	r2,-8(fp)
811132f8:	10803fcc 	andi	r2,r2,255
811132fc:	10000126 	beq	r2,zero,81113304 <vNFeeControlTask+0x118>
					vFailFlushQueue();
81113300:	111ea840 	call	8111ea84 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81113304:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81113308:	00800044 	movi	r2,1
8111330c:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81113310:	00bfffc4 	movi	r2,-1
81113314:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
81113318:	e0bffa17 	ldw	r2,-24(fp)
8111331c:	00c000c4 	movi	r3,3
81113320:	10c09a15 	stw	r3,616(r2)
				break;
81113324:	0000c406 	br	81113638 <vNFeeControlTask+0x44c>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81113328:	111ec3c0 	call	8111ec3c <vEvtChangeFeeControllerMode>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111332c:	00a045f4 	movhi	r2,33047
81113330:	10a00404 	addi	r2,r2,-32752
81113334:	10800e8b 	ldhu	r2,58(r2)
81113338:	10bfffcc 	andi	r2,r2,65535
8111333c:	108000e8 	cmpgeui	r2,r2,3
81113340:	1000071e 	bne	r2,zero,81113360 <vNFeeControlTask+0x174>
					debug(fp,"NFEE Controller Task: RUN Mode\n");
81113344:	d0a06217 	ldw	r2,-32376(gp)
81113348:	100f883a 	mov	r7,r2
8111334c:	018007c4 	movi	r6,31
81113350:	01400044 	movi	r5,1
81113354:	01204574 	movhi	r4,33045
81113358:	213aa004 	addi	r4,r4,-5504
8111335c:	11230300 	call	81123030 <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113360:	d0a05d17 	ldw	r2,-32396(gp)
81113364:	1009883a 	mov	r4,r2
81113368:	113ee7c0 	call	8113ee7c <OSQFlush>
8111336c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113370:	e0bffe03 	ldbu	r2,-8(fp)
81113374:	10803fcc 	andi	r2,r2,255
81113378:	10000126 	beq	r2,zero,81113380 <vNFeeControlTask+0x194>
					vFailFlushQueue();
8111337c:	111ea840 	call	8111ea84 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81113380:	e03ff905 	stb	zero,-28(fp)
81113384:	00001006 	br	811133c8 <vNFeeControlTask+0x1dc>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81113388:	e0bff903 	ldbu	r2,-28(fp)
8111338c:	1085883a 	add	r2,r2,r2
81113390:	1087883a 	add	r3,r2,r2
81113394:	d0a06a04 	addi	r2,gp,-32344
81113398:	1885883a 	add	r2,r3,r2
8111339c:	10800017 	ldw	r2,0(r2)
811133a0:	1009883a 	mov	r4,r2
811133a4:	113ee7c0 	call	8113ee7c <OSQFlush>
811133a8:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
811133ac:	e0bffe03 	ldbu	r2,-8(fp)
811133b0:	10803fcc 	andi	r2,r2,255
811133b4:	10000126 	beq	r2,zero,811133bc <vNFeeControlTask+0x1d0>
						vFailFlushQueue();
811133b8:	111ea840 	call	8111ea84 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811133bc:	e0bff903 	ldbu	r2,-28(fp)
811133c0:	10800044 	addi	r2,r2,1
811133c4:	e0bff905 	stb	r2,-28(fp)
811133c8:	e0bff903 	ldbu	r2,-28(fp)
811133cc:	103fee26 	beq	r2,zero,81113388 <__reset+0xfb0f3388>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
811133d0:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
811133d4:	00800044 	movi	r2,1
811133d8:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
811133dc:	00bfffc4 	movi	r2,-1
811133e0:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
811133e4:	e0bffa17 	ldw	r2,-24(fp)
811133e8:	00c00104 	movi	r3,4
811133ec:	10c09a15 	stw	r3,616(r2)
				break;
811133f0:	00009106 	br	81113638 <vNFeeControlTask+0x44c>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
811133f4:	d0a07017 	ldw	r2,-32320(gp)
811133f8:	e0fffe04 	addi	r3,fp,-8
811133fc:	180d883a 	mov	r6,r3
81113400:	000b883a 	mov	r5,zero
81113404:	1009883a 	mov	r4,r2
81113408:	113ef3c0 	call	8113ef3c <OSQPend>
8111340c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81113410:	e0bffe03 	ldbu	r2,-8(fp)
81113414:	10803fcc 	andi	r2,r2,255
81113418:	10000c1e 	bne	r2,zero,8111344c <vNFeeControlTask+0x260>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8111341c:	e0bffdc3 	ldbu	r2,-9(fp)
81113420:	10803fcc 	andi	r2,r2,255
81113424:	10800418 	cmpnei	r2,r2,16
81113428:	1000041e 	bne	r2,zero,8111343c <vNFeeControlTask+0x250>
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8111342c:	e0bffd17 	ldw	r2,-12(fp)
81113430:	e17ffa17 	ldw	r5,-24(fp)
81113434:	1009883a 	mov	r4,r2
81113438:	111363c0 	call	8111363c <vPerformActionNFCConfig>
					}
					bCmdSent = FALSE;
8111343c:	e03ffb15 	stw	zero,-20(fp)
					bDmaBack = TRUE;
81113440:	00800044 	movi	r2,1
81113444:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81113448:	00007b06 	br	81113638 <vNFeeControlTask+0x44c>
					}
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8111344c:	111e5d00 	call	8111e5d0 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81113450:	00007906 	br	81113638 <vNFeeControlTask+0x44c>
				/* 	We have 2 importantes Queues here.  
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fast way and
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				
				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81113454:	d0a05817 	ldw	r2,-32416(gp)
81113458:	10800058 	cmpnei	r2,r2,1
8111345c:	1000221e 	bne	r2,zero,811134e8 <vNFeeControlTask+0x2fc>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81113460:	d0a05d17 	ldw	r2,-32396(gp)
81113464:	e0fffe04 	addi	r3,fp,-8
81113468:	180d883a 	mov	r6,r3
8111346c:	01400104 	movi	r5,4
81113470:	1009883a 	mov	r4,r2
81113474:	113ef3c0 	call	8113ef3c <OSQPend>
81113478:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8111347c:	e0bffe03 	ldbu	r2,-8(fp)
81113480:	10803fcc 	andi	r2,r2,255
81113484:	1000181e 	bne	r2,zero,811134e8 <vNFeeControlTask+0x2fc>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81113488:	e0bffd03 	ldbu	r2,-12(fp)
8111348c:	e0bffc05 	stb	r2,-16(fp)

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81113490:	e0bffc03 	ldbu	r2,-16(fp)
81113494:	e0fffa17 	ldw	r3,-24(fp)
81113498:	10809624 	muli	r2,r2,600
8111349c:	1885883a 	add	r2,r3,r2
811134a0:	10802304 	addi	r2,r2,140
811134a4:	10800017 	ldw	r2,0(r2)
811134a8:	10800058 	cmpnei	r2,r2,1
811134ac:	10000e1e 	bne	r2,zero,811134e8 <vNFeeControlTask+0x2fc>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
811134b0:	e0bffc03 	ldbu	r2,-16(fp)
811134b4:	e0fffc03 	ldbu	r3,-16(fp)
811134b8:	180f883a 	mov	r7,r3
811134bc:	000d883a 	mov	r6,zero
811134c0:	014023c4 	movi	r5,143
811134c4:	1009883a 	mov	r4,r2
811134c8:	11138a80 	call	811138a8 <bSendCmdQToNFeeInst>
811134cc:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
811134d0:	e0bffb17 	ldw	r2,-20(fp)
811134d4:	10800058 	cmpnei	r2,r2,1
811134d8:	1000031e 	bne	r2,zero,811134e8 <vNFeeControlTask+0x2fc>
								bDmaBack = FALSE;
811134dc:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
811134e0:	e0bffc03 	ldbu	r2,-16(fp)
811134e4:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
811134e8:	d0a05817 	ldw	r2,-32416(gp)
811134ec:	1000081e 	bne	r2,zero,81113510 <vNFeeControlTask+0x324>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
811134f0:	d0a07017 	ldw	r2,-32320(gp)
811134f4:	e0fffe04 	addi	r3,fp,-8
811134f8:	180d883a 	mov	r6,r3
811134fc:	000b883a 	mov	r5,zero
81113500:	1009883a 	mov	r4,r2
81113504:	113ef3c0 	call	8113ef3c <OSQPend>
81113508:	e0bffd15 	stw	r2,-12(fp)
8111350c:	00000706 	br	8111352c <vNFeeControlTask+0x340>
				} else {
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81113510:	d0a07017 	ldw	r2,-32320(gp)
81113514:	e0fffe04 	addi	r3,fp,-8
81113518:	180d883a 	mov	r6,r3
8111351c:	01400104 	movi	r5,4
81113520:	1009883a 	mov	r4,r2
81113524:	113ef3c0 	call	8113ef3c <OSQPend>
81113528:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
8111352c:	e0bffe03 	ldbu	r2,-8(fp)
81113530:	10803fcc 	andi	r2,r2,255
81113534:	10003f1e 	bne	r2,zero,81113634 <vNFeeControlTask+0x448>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81113538:	e0bffd83 	ldbu	r2,-10(fp)
8111353c:	10803fcc 	andi	r2,r2,255
81113540:	10802058 	cmpnei	r2,r2,129
81113544:	10000a1e 	bne	r2,zero,81113570 <vNFeeControlTask+0x384>
						if ( uiCmdNFC.ucByte[0] == ucWhoGetDMA ){
81113548:	e0fffd03 	ldbu	r3,-12(fp)
8111354c:	d0a05903 	ldbu	r2,-32412(gp)
81113550:	18c03fcc 	andi	r3,r3,255
81113554:	10803fcc 	andi	r2,r2,255
81113558:	1880361e 	bne	r3,r2,81113634 <vNFeeControlTask+0x448>
							bDmaBack = TRUE;
8111355c:	00800044 	movi	r2,1
81113560:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81113564:	00bfffc4 	movi	r2,-1
81113568:	e0bffc05 	stb	r2,-16(fp)
							}
						}
					}
				}
				
				break;		
8111356c:	00003106 	br	81113634 <vNFeeControlTask+0x448>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81113570:	e0bffdc3 	ldbu	r2,-9(fp)
81113574:	10803fcc 	andi	r2,r2,255
81113578:	10800418 	cmpnei	r2,r2,16
8111357c:	1000051e 	bne	r2,zero,81113594 <vNFeeControlTask+0x3a8>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81113580:	e0bffd17 	ldw	r2,-12(fp)
81113584:	e17ffa17 	ldw	r5,-24(fp)
81113588:	1009883a 	mov	r4,r2
8111358c:	11137400 	call	81113740 <vPerformActionNFCRunning>
							}
						}
					}
				}
				
				break;		
81113590:	00002806 	br	81113634 <vNFeeControlTask+0x448>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81113594:	e0bffdc3 	ldbu	r2,-9(fp)
81113598:	10803fcc 	andi	r2,r2,255
8111359c:	10800470 	cmpltui	r2,r2,17
811135a0:	1000241e 	bne	r2,zero,81113634 <vNFeeControlTask+0x448>
811135a4:	e0bffdc3 	ldbu	r2,-9(fp)
811135a8:	10803fcc 	andi	r2,r2,255
811135ac:	108004e8 	cmpgeui	r2,r2,19
811135b0:	1000201e 	bne	r2,zero,81113634 <vNFeeControlTask+0x448>
								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
811135b4:	e0bffdc3 	ldbu	r2,-9(fp)
811135b8:	10bffbc4 	addi	r2,r2,-17
811135bc:	10803fcc 	andi	r2,r2,255
811135c0:	e0fffd83 	ldbu	r3,-10(fp)
811135c4:	18c03fcc 	andi	r3,r3,255
811135c8:	e13ffd43 	ldbu	r4,-11(fp)
811135cc:	21003fcc 	andi	r4,r4,255
811135d0:	e17ffd03 	ldbu	r5,-12(fp)
811135d4:	29403fcc 	andi	r5,r5,255
811135d8:	280f883a 	mov	r7,r5
811135dc:	200d883a 	mov	r6,r4
811135e0:	180b883a 	mov	r5,r3
811135e4:	1009883a 	mov	r4,r2
811135e8:	11138a80 	call	811138a8 <bSendCmdQToNFeeInst>
							}
						}
					}
				}
				
				break;		
811135ec:	00001106 	br	81113634 <vNFeeControlTask+0x448>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811135f0:	00a045f4 	movhi	r2,33047
811135f4:	10a00404 	addi	r2,r2,-32752
811135f8:	10800e8b 	ldhu	r2,58(r2)
811135fc:	10bfffcc 	andi	r2,r2,65535
81113600:	108001e8 	cmpgeui	r2,r2,7
81113604:	1000071e 	bne	r2,zero,81113624 <vNFeeControlTask+0x438>
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81113608:	d0a06217 	ldw	r2,-32376(gp)
8111360c:	100f883a 	mov	r7,r2
81113610:	01800f44 	movi	r6,61
81113614:	01400044 	movi	r5,1
81113618:	01204574 	movhi	r4,33045
8111361c:	213aa804 	addi	r4,r4,-5472
81113620:	11230300 	call	81123030 <fwrite>
				}
				#endif
				
				pxFeeC->sMode = sMebConfig;
81113624:	e0bffa17 	ldw	r2,-24(fp)
81113628:	00c000c4 	movi	r3,3
8111362c:	10c09a15 	stw	r3,616(r2)
				break;
81113630:	00000106 	br	81113638 <vNFeeControlTask+0x44c>
							}
						}
					}
				}
				
				break;		
81113634:	0001883a 	nop
				#endif
				
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81113638:	003f0206 	br	81113244 <__reset+0xfb0f3244>

8111363c <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8111363c:	defffb04 	addi	sp,sp,-20
81113640:	de00012e 	bgeu	sp,et,81113648 <vPerformActionNFCConfig+0xc>
81113644:	003b68fa 	trap	3
81113648:	dfc00415 	stw	ra,16(sp)
8111364c:	df000315 	stw	fp,12(sp)
81113650:	df000304 	addi	fp,sp,12
81113654:	e13ffe15 	stw	r4,-8(fp)
81113658:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;

	uiCmdLocal.ulWord = uiCmdParam;
8111365c:	e0bffe17 	ldw	r2,-8(fp)
81113660:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81113664:	e0bffd83 	ldbu	r2,-10(fp)
81113668:	10803fcc 	andi	r2,r2,255
8111366c:	10c000a0 	cmpeqi	r3,r2,2
81113670:	1800181e 	bne	r3,zero,811136d4 <vPerformActionNFCConfig+0x98>
81113674:	10c000c8 	cmpgei	r3,r2,3
81113678:	1800031e 	bne	r3,zero,81113688 <vPerformActionNFCConfig+0x4c>
8111367c:	10800060 	cmpeqi	r2,r2,1
81113680:	1000061e 	bne	r2,zero,8111369c <vPerformActionNFCConfig+0x60>
81113684:	00001706 	br	811136e4 <vPerformActionNFCConfig+0xa8>
81113688:	10c02860 	cmpeqi	r3,r2,161
8111368c:	1800031e 	bne	r3,zero,8111369c <vPerformActionNFCConfig+0x60>
81113690:	108028a0 	cmpeqi	r2,r2,162
81113694:	10000f1e 	bne	r2,zero,811136d4 <vPerformActionNFCConfig+0x98>
81113698:	00001206 	br	811136e4 <vPerformActionNFCConfig+0xa8>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111369c:	00a045f4 	movhi	r2,33047
811136a0:	10a00404 	addi	r2,r2,-32752
811136a4:	10800e8b 	ldhu	r2,58(r2)
811136a8:	10bfffcc 	andi	r2,r2,65535
811136ac:	108000e8 	cmpgeui	r2,r2,3
811136b0:	10001a1e 	bne	r2,zero,8111371c <vPerformActionNFCConfig+0xe0>
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
811136b4:	d0a06217 	ldw	r2,-32376(gp)
811136b8:	100f883a 	mov	r7,r2
811136bc:	01800d44 	movi	r6,53
811136c0:	01400044 	movi	r5,1
811136c4:	01204574 	movhi	r4,33045
811136c8:	213ab804 	addi	r4,r4,-5408
811136cc:	11230300 	call	81123030 <fwrite>
			}
			#endif
			/* Do nothing for now */
			break;
811136d0:	00001206 	br	8111371c <vPerformActionNFCConfig+0xe0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
811136d4:	e0bfff17 	ldw	r2,-4(fp)
811136d8:	00c00084 	movi	r3,2
811136dc:	10c09a15 	stw	r3,616(r2)
			break;
811136e0:	00001106 	br	81113728 <vPerformActionNFCConfig+0xec>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811136e4:	00a045f4 	movhi	r2,33047
811136e8:	10a00404 	addi	r2,r2,-32752
811136ec:	10800e8b 	ldhu	r2,58(r2)
811136f0:	10bfffcc 	andi	r2,r2,65535
811136f4:	108001e8 	cmpgeui	r2,r2,7
811136f8:	10000a1e 	bne	r2,zero,81113724 <vPerformActionNFCConfig+0xe8>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
811136fc:	d0a06217 	ldw	r2,-32376(gp)
81113700:	100f883a 	mov	r7,r2
81113704:	018009c4 	movi	r6,39
81113708:	01400044 	movi	r5,1
8111370c:	01204574 	movhi	r4,33045
81113710:	213ac604 	addi	r4,r4,-5352
81113714:	11230300 	call	81123030 <fwrite>
			}
			#endif	
			break;
81113718:	00000206 	br	81113724 <vPerformActionNFCConfig+0xe8>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
			}
			#endif
			/* Do nothing for now */
			break;
8111371c:	0001883a 	nop
81113720:	00000106 	br	81113728 <vPerformActionNFCConfig+0xec>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
81113724:	0001883a 	nop
	}

}
81113728:	0001883a 	nop
8111372c:	e037883a 	mov	sp,fp
81113730:	dfc00117 	ldw	ra,4(sp)
81113734:	df000017 	ldw	fp,0(sp)
81113738:	dec00204 	addi	sp,sp,8
8111373c:	f800283a 	ret

81113740 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81113740:	defffa04 	addi	sp,sp,-24
81113744:	de00012e 	bgeu	sp,et,8111374c <vPerformActionNFCRunning+0xc>
81113748:	003b68fa 	trap	3
8111374c:	dfc00515 	stw	ra,20(sp)
81113750:	df000415 	stw	fp,16(sp)
81113754:	df000404 	addi	fp,sp,16
81113758:	e13ffe15 	stw	r4,-8(fp)
8111375c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81113760:	e0bffe17 	ldw	r2,-8(fp)
81113764:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81113768:	e0bffd83 	ldbu	r2,-10(fp)
8111376c:	10803fcc 	andi	r2,r2,255
81113770:	10c02088 	cmpgei	r3,r2,130
81113774:	1800071e 	bne	r3,zero,81113794 <vPerformActionNFCRunning+0x54>
81113778:	10c02008 	cmpgei	r3,r2,128
8111377c:	18003f1e 	bne	r3,zero,8111387c <vPerformActionNFCRunning+0x13c>
81113780:	10c00060 	cmpeqi	r3,r2,1
81113784:	1800051e 	bne	r3,zero,8111379c <vPerformActionNFCRunning+0x5c>
81113788:	108000a0 	cmpeqi	r2,r2,2
8111378c:	10001f1e 	bne	r2,zero,8111380c <vPerformActionNFCRunning+0xcc>
81113790:	00002c06 	br	81113844 <vPerformActionNFCRunning+0x104>
81113794:	10802860 	cmpeqi	r2,r2,161
81113798:	10002a26 	beq	r2,zero,81113844 <vPerformActionNFCRunning+0x104>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
8111379c:	e0bfff17 	ldw	r2,-4(fp)
811137a0:	00c00044 	movi	r3,1
811137a4:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
811137a8:	e03ffc05 	stb	zero,-16(fp)
811137ac:	00001406 	br	81113800 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
811137b0:	e0bffc03 	ldbu	r2,-16(fp)
811137b4:	e0ffff17 	ldw	r3,-4(fp)
811137b8:	108025c4 	addi	r2,r2,151
811137bc:	1085883a 	add	r2,r2,r2
811137c0:	1085883a 	add	r2,r2,r2
811137c4:	1885883a 	add	r2,r3,r2
811137c8:	10800017 	ldw	r2,0(r2)
811137cc:	10800017 	ldw	r2,0(r2)
811137d0:	10800058 	cmpnei	r2,r2,1
811137d4:	1000071e 	bne	r2,zero,811137f4 <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
811137d8:	e0bffc03 	ldbu	r2,-16(fp)
811137dc:	e0fffc03 	ldbu	r3,-16(fp)
811137e0:	180f883a 	mov	r7,r3
811137e4:	000d883a 	mov	r6,zero
811137e8:	01402844 	movi	r5,161
811137ec:	1009883a 	mov	r4,r2
811137f0:	11139700 	call	81113970 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
811137f4:	e0bffc03 	ldbu	r2,-16(fp)
811137f8:	10800044 	addi	r2,r2,1
811137fc:	e0bffc05 	stb	r2,-16(fp)
81113800:	e0bffc03 	ldbu	r2,-16(fp)
81113804:	103fea26 	beq	r2,zero,811137b0 <__reset+0xfb0f37b0>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81113808:	00002106 	br	81113890 <vPerformActionNFCRunning+0x150>
		case M_NFC_RUN:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111380c:	00a045f4 	movhi	r2,33047
81113810:	10a00404 	addi	r2,r2,-32752
81113814:	10800e8b 	ldhu	r2,58(r2)
81113818:	10bfffcc 	andi	r2,r2,65535
8111381c:	108000e8 	cmpgeui	r2,r2,3
81113820:	1000181e 	bne	r2,zero,81113884 <vPerformActionNFCRunning+0x144>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81113824:	d0a06217 	ldw	r2,-32376(gp)
81113828:	100f883a 	mov	r7,r2
8111382c:	01800d84 	movi	r6,54
81113830:	01400044 	movi	r5,1
81113834:	01204574 	movhi	r4,33045
81113838:	213ad004 	addi	r4,r4,-5312
8111383c:	11230300 	call	81123030 <fwrite>
			}
			#endif		
			/* Do nothing for now */

			break;
81113840:	00001006 	br	81113884 <vPerformActionNFCRunning+0x144>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113844:	00a045f4 	movhi	r2,33047
81113848:	10a00404 	addi	r2,r2,-32752
8111384c:	10800e8b 	ldhu	r2,58(r2)
81113850:	10bfffcc 	andi	r2,r2,65535
81113854:	108001e8 	cmpgeui	r2,r2,7
81113858:	10000c1e 	bne	r2,zero,8111388c <vPerformActionNFCRunning+0x14c>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8111385c:	d0a06217 	ldw	r2,-32376(gp)
81113860:	100f883a 	mov	r7,r2
81113864:	018009c4 	movi	r6,39
81113868:	01400044 	movi	r5,1
8111386c:	01204574 	movhi	r4,33045
81113870:	213ac604 	addi	r4,r4,-5352
81113874:	11230300 	call	81123030 <fwrite>
			}
			#endif	
			break;
81113878:	00000406 	br	8111388c <vPerformActionNFCRunning+0x14c>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
8111387c:	0001883a 	nop
81113880:	00000306 	br	81113890 <vPerformActionNFCRunning+0x150>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
			}
			#endif		
			/* Do nothing for now */

			break;
81113884:	0001883a 	nop
81113888:	00000106 	br	81113890 <vPerformActionNFCRunning+0x150>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
8111388c:	0001883a 	nop
	}
}
81113890:	0001883a 	nop
81113894:	e037883a 	mov	sp,fp
81113898:	dfc00117 	ldw	ra,4(sp)
8111389c:	df000017 	ldw	fp,0(sp)
811138a0:	dec00204 	addi	sp,sp,8
811138a4:	f800283a 	ret

811138a8 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811138a8:	defff704 	addi	sp,sp,-36
811138ac:	de00012e 	bgeu	sp,et,811138b4 <bSendCmdQToNFeeInst+0xc>
811138b0:	003b68fa 	trap	3
811138b4:	dfc00815 	stw	ra,32(sp)
811138b8:	df000715 	stw	fp,28(sp)
811138bc:	df000704 	addi	fp,sp,28
811138c0:	2011883a 	mov	r8,r4
811138c4:	2809883a 	mov	r4,r5
811138c8:	3007883a 	mov	r3,r6
811138cc:	3805883a 	mov	r2,r7
811138d0:	e23ffc05 	stb	r8,-16(fp)
811138d4:	e13ffd05 	stb	r4,-12(fp)
811138d8:	e0fffe05 	stb	r3,-8(fp)
811138dc:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811138e0:	e0bffc03 	ldbu	r2,-16(fp)
811138e4:	10800444 	addi	r2,r2,17
811138e8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811138ec:	e0bffd03 	ldbu	r2,-12(fp)
811138f0:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811138f4:	e0bffe03 	ldbu	r2,-8(fp)
811138f8:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811138fc:	e0bfff03 	ldbu	r2,-4(fp)
81113900:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81113904:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81113908:	e0bffc03 	ldbu	r2,-16(fp)
8111390c:	1085883a 	add	r2,r2,r2
81113910:	1087883a 	add	r3,r2,r2
81113914:	d0a06a04 	addi	r2,gp,-32344
81113918:	1885883a 	add	r2,r3,r2
8111391c:	10800017 	ldw	r2,0(r2)
81113920:	e0fffb17 	ldw	r3,-20(fp)
81113924:	180b883a 	mov	r5,r3
81113928:	1009883a 	mov	r4,r2
8111392c:	113f3440 	call	8113f344 <OSQPost>
81113930:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113934:	e0bffa03 	ldbu	r2,-24(fp)
81113938:	10000526 	beq	r2,zero,81113950 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8111393c:	e0bffc03 	ldbu	r2,-16(fp)
81113940:	1009883a 	mov	r4,r2
81113944:	111e6d00 	call	8111e6d0 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81113948:	e03ff915 	stw	zero,-28(fp)
8111394c:	00000206 	br	81113958 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81113950:	00800044 	movi	r2,1
81113954:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81113958:	e0bff917 	ldw	r2,-28(fp)
}
8111395c:	e037883a 	mov	sp,fp
81113960:	dfc00117 	ldw	ra,4(sp)
81113964:	df000017 	ldw	fp,0(sp)
81113968:	dec00204 	addi	sp,sp,8
8111396c:	f800283a 	ret

81113970 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113970:	defff704 	addi	sp,sp,-36
81113974:	de00012e 	bgeu	sp,et,8111397c <bSendCmdQToNFeeInst_Prio+0xc>
81113978:	003b68fa 	trap	3
8111397c:	dfc00815 	stw	ra,32(sp)
81113980:	df000715 	stw	fp,28(sp)
81113984:	df000704 	addi	fp,sp,28
81113988:	2011883a 	mov	r8,r4
8111398c:	2809883a 	mov	r4,r5
81113990:	3007883a 	mov	r3,r6
81113994:	3805883a 	mov	r2,r7
81113998:	e23ffc05 	stb	r8,-16(fp)
8111399c:	e13ffd05 	stb	r4,-12(fp)
811139a0:	e0fffe05 	stb	r3,-8(fp)
811139a4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811139a8:	e0bffc03 	ldbu	r2,-16(fp)
811139ac:	10800444 	addi	r2,r2,17
811139b0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811139b4:	e0bffd03 	ldbu	r2,-12(fp)
811139b8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811139bc:	e0bffe03 	ldbu	r2,-8(fp)
811139c0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811139c4:	e0bfff03 	ldbu	r2,-4(fp)
811139c8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811139cc:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
811139d0:	e0bffc03 	ldbu	r2,-16(fp)
811139d4:	1085883a 	add	r2,r2,r2
811139d8:	1087883a 	add	r3,r2,r2
811139dc:	d0a06a04 	addi	r2,gp,-32344
811139e0:	1885883a 	add	r2,r3,r2
811139e4:	10800017 	ldw	r2,0(r2)
811139e8:	e0fffb17 	ldw	r3,-20(fp)
811139ec:	180b883a 	mov	r5,r3
811139f0:	1009883a 	mov	r4,r2
811139f4:	113f4b40 	call	8113f4b4 <OSQPostFront>
811139f8:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811139fc:	e0bffa03 	ldbu	r2,-24(fp)
81113a00:	10000526 	beq	r2,zero,81113a18 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81113a04:	e0bffc03 	ldbu	r2,-16(fp)
81113a08:	1009883a 	mov	r4,r2
81113a0c:	111e6d00 	call	8111e6d0 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81113a10:	e03ff915 	stw	zero,-28(fp)
81113a14:	00000206 	br	81113a20 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81113a18:	00800044 	movi	r2,1
81113a1c:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81113a20:	e0bff917 	ldw	r2,-28(fp)
}
81113a24:	e037883a 	mov	sp,fp
81113a28:	dfc00117 	ldw	ra,4(sp)
81113a2c:	df000017 	ldw	fp,0(sp)
81113a30:	dec00204 	addi	sp,sp,8
81113a34:	f800283a 	ret

81113a38 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81113a38:	defff704 	addi	sp,sp,-36
81113a3c:	de00012e 	bgeu	sp,et,81113a44 <vOutAckHandlerTask+0xc>
81113a40:	003b68fa 	trap	3
81113a44:	dfc00815 	stw	ra,32(sp)
81113a48:	df000715 	stw	fp,28(sp)
81113a4c:	df000704 	addi	fp,sp,28
81113a50:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81113a54:	e03ffac5 	stb	zero,-21(fp)
81113a58:	e03ffb05 	stb	zero,-20(fp)
81113a5c:	e03ffb45 	stb	zero,-19(fp)
81113a60:	e03ffb85 	stb	zero,-18(fp)
81113a64:	e03ffbc5 	stb	zero,-17(fp)
81113a68:	e03ffc05 	stb	zero,-16(fp)
81113a6c:	e03ffc45 	stb	zero,-15(fp)
81113a70:	e03ffc85 	stb	zero,-14(fp)
81113a74:	e03ffcc5 	stb	zero,-13(fp)
81113a78:	e03ffd05 	stb	zero,-12(fp)
81113a7c:	e03ffd45 	stb	zero,-11(fp)
81113a80:	e03ffd85 	stb	zero,-10(fp)
81113a84:	e03ffdc5 	stb	zero,-9(fp)
81113a88:	e03ffe05 	stb	zero,-8(fp)
81113a8c:	e03ffe45 	stb	zero,-7(fp)
81113a90:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
81113a94:	e03ffa45 	stb	zero,-23(fp)

	#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113a98:	00a045f4 	movhi	r2,33047
81113a9c:	10a00404 	addi	r2,r2,-32752
81113aa0:	10800e8b 	ldhu	r2,58(r2)
81113aa4:	10bfffcc 	andi	r2,r2,65535
81113aa8:	10800168 	cmpgeui	r2,r2,5
81113aac:	1000071e 	bne	r2,zero,81113acc <vOutAckHandlerTask+0x94>
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81113ab0:	d0a06217 	ldw	r2,-32376(gp)
81113ab4:	100f883a 	mov	r7,r2
81113ab8:	01800804 	movi	r6,32
81113abc:	01400044 	movi	r5,1
81113ac0:	01204574 	movhi	r4,33045
81113ac4:	213ade04 	addi	r4,r4,-5256
81113ac8:	11230300 	call	81123030 <fwrite>
    }
	#endif

	eSenderAckState = sSAConfiguring;
81113acc:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81113ad0:	e0bff917 	ldw	r2,-28(fp)
81113ad4:	10c00060 	cmpeqi	r3,r2,1
81113ad8:	1800071e 	bne	r3,zero,81113af8 <vOutAckHandlerTask+0xc0>
81113adc:	0080032e 	bgeu	zero,r2,81113aec <vOutAckHandlerTask+0xb4>
81113ae0:	108000a0 	cmpeqi	r2,r2,2
81113ae4:	1000471e 	bne	r2,zero,81113c04 <vOutAckHandlerTask+0x1cc>
81113ae8:	00008c06 	br	81113d1c <vOutAckHandlerTask+0x2e4>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81113aec:	00800044 	movi	r2,1
81113af0:	e0bff915 	stw	r2,-28(fp)
				break;
81113af4:	00009906 	br	81113d5c <vOutAckHandlerTask+0x324>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81113af8:	00800044 	movi	r2,1
81113afc:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81113b00:	d0a06117 	ldw	r2,-32380(gp)
81113b04:	e0fffa84 	addi	r3,fp,-22
81113b08:	180d883a 	mov	r6,r3
81113b0c:	000b883a 	mov	r5,zero
81113b10:	1009883a 	mov	r4,r2
81113b14:	113fe340 	call	8113fe34 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81113b18:	e0bffa83 	ldbu	r2,-22(fp)
81113b1c:	10803fcc 	andi	r2,r2,255
81113b20:	1000361e 	bne	r2,zero,81113bfc <vOutAckHandlerTask+0x1c4>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
81113b24:	d0a07217 	ldw	r2,-32312(gp)
81113b28:	e0fffa84 	addi	r3,fp,-22
81113b2c:	180d883a 	mov	r6,r3
81113b30:	000b883a 	mov	r5,zero
81113b34:	1009883a 	mov	r4,r2
81113b38:	113de280 	call	8113de28 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81113b3c:	e0bffa83 	ldbu	r2,-22(fp)
81113b40:	10803fcc 	andi	r2,r2,255
81113b44:	10002b1e 	bne	r2,zero,81113bf4 <vOutAckHandlerTask+0x1bc>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81113b48:	e03ffa05 	stb	zero,-24(fp)
81113b4c:	00002206 	br	81113bd8 <vOutAckHandlerTask+0x1a0>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81113b50:	e0fffa03 	ldbu	r3,-24(fp)
81113b54:	00a045b4 	movhi	r2,33046
81113b58:	109f5404 	addi	r2,r2,32080
81113b5c:	18c7883a 	add	r3,r3,r3
81113b60:	18c7883a 	add	r3,r3,r3
81113b64:	10c5883a 	add	r2,r2,r3
81113b68:	10800003 	ldbu	r2,0(r2)
81113b6c:	10803fcc 	andi	r2,r2,255
81113b70:	1080201c 	xori	r2,r2,128
81113b74:	10bfe004 	addi	r2,r2,-128
81113b78:	10001426 	beq	r2,zero,81113bcc <vOutAckHandlerTask+0x194>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
81113b7c:	e0fffa03 	ldbu	r3,-24(fp)
81113b80:	00a045b4 	movhi	r2,33046
81113b84:	109f5404 	addi	r2,r2,32080
81113b88:	18c7883a 	add	r3,r3,r3
81113b8c:	18c7883a 	add	r3,r3,r3
81113b90:	10c5883a 	add	r2,r2,r3
81113b94:	10c0000b 	ldhu	r3,0(r2)
81113b98:	d0e0598d 	sth	r3,-32410(gp)
81113b9c:	1080008b 	ldhu	r2,2(r2)
81113ba0:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
81113ba4:	00800084 	movi	r2,2
81113ba8:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81113bac:	e0fffa03 	ldbu	r3,-24(fp)
81113bb0:	00a045b4 	movhi	r2,33046
81113bb4:	109f5404 	addi	r2,r2,32080
81113bb8:	18c7883a 	add	r3,r3,r3
81113bbc:	18c7883a 	add	r3,r3,r3
81113bc0:	10c5883a 	add	r2,r2,r3
81113bc4:	10000005 	stb	zero,0(r2)
                                break;
81113bc8:	00000606 	br	81113be4 <vOutAckHandlerTask+0x1ac>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81113bcc:	e0bffa03 	ldbu	r2,-24(fp)
81113bd0:	10800044 	addi	r2,r2,1
81113bd4:	e0bffa05 	stb	r2,-24(fp)
81113bd8:	e0bffa03 	ldbu	r2,-24(fp)
81113bdc:	10800230 	cmpltui	r2,r2,8
81113be0:	103fdb1e 	bne	r2,zero,81113b50 <__reset+0xfb0f3b50>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81113be4:	d0a07217 	ldw	r2,-32312(gp)
81113be8:	1009883a 	mov	r4,r2
81113bec:	113e3cc0 	call	8113e3cc <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113bf0:	00005a06 	br	81113d5c <vOutAckHandlerTask+0x324>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81113bf4:	111c9140 	call	8111c914 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113bf8:	00005806 	br	81113d5c <vOutAckHandlerTask+0x324>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81113bfc:	111c8940 	call	8111c894 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81113c00:	00005606 	br	81113d5c <vOutAckHandlerTask+0x324>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81113c04:	d0a05983 	ldbu	r2,-32410(gp)
81113c08:	10803fcc 	andi	r2,r2,255
81113c0c:	1080201c 	xori	r2,r2,128
81113c10:	10bfe004 	addi	r2,r2,-128
81113c14:	108008e0 	cmpeqi	r2,r2,35
81113c18:	1000201e 	bne	r2,zero,81113c9c <vOutAckHandlerTask+0x264>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
81113c1c:	d0a059c3 	ldbu	r2,-32409(gp)
81113c20:	10c03fcc 	andi	r3,r2,255
81113c24:	18c0201c 	xori	r3,r3,128
81113c28:	18ffe004 	addi	r3,r3,-128
81113c2c:	d0a05a0b 	ldhu	r2,-32408(gp)
81113c30:	113fffcc 	andi	r4,r2,65535
81113c34:	e0bffac4 	addi	r2,fp,-21
81113c38:	200f883a 	mov	r7,r4
81113c3c:	180d883a 	mov	r6,r3
81113c40:	01604574 	movhi	r5,33045
81113c44:	297ae704 	addi	r5,r5,-5220
81113c48:	1009883a 	mov	r4,r2
81113c4c:	11242a80 	call	811242a8 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81113c50:	e0bffac4 	addi	r2,fp,-21
81113c54:	1009883a 	mov	r4,r2
81113c58:	11244bc0 	call	811244bc <strlen>
81113c5c:	1007883a 	mov	r3,r2
81113c60:	e0bffac4 	addi	r2,fp,-21
81113c64:	180b883a 	mov	r5,r3
81113c68:	1009883a 	mov	r4,r2
81113c6c:	111c3980 	call	8111c398 <ucCrc8wInit>
81113c70:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81113c74:	e13ffa43 	ldbu	r4,-23(fp)
81113c78:	e0fffac4 	addi	r3,fp,-21
81113c7c:	e0bffac4 	addi	r2,fp,-21
81113c80:	200f883a 	mov	r7,r4
81113c84:	180d883a 	mov	r6,r3
81113c88:	01604574 	movhi	r5,33045
81113c8c:	297ae904 	addi	r5,r5,-5212
81113c90:	1009883a 	mov	r4,r2
81113c94:	11242a80 	call	811242a8 <sprintf>
81113c98:	00000c06 	br	81113ccc <vOutAckHandlerTask+0x294>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81113c9c:	e0bffac4 	addi	r2,fp,-21
81113ca0:	00c008c4 	movi	r3,35
81113ca4:	10c00005 	stb	r3,0(r2)
81113ca8:	00c01f04 	movi	r3,124
81113cac:	10c00045 	stb	r3,1(r2)
81113cb0:	00c00d44 	movi	r3,53
81113cb4:	10c00085 	stb	r3,2(r2)
81113cb8:	00c00d04 	movi	r3,52
81113cbc:	10c000c5 	stb	r3,3(r2)
81113cc0:	00c00ec4 	movi	r3,59
81113cc4:	10c00105 	stb	r3,4(r2)
81113cc8:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81113ccc:	d0a07417 	ldw	r2,-32304(gp)
81113cd0:	e0fffa84 	addi	r3,fp,-22
81113cd4:	180d883a 	mov	r6,r3
81113cd8:	01401904 	movi	r5,100
81113cdc:	1009883a 	mov	r4,r2
81113ce0:	113de280 	call	8113de28 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81113ce4:	e0bffa83 	ldbu	r2,-22(fp)
81113ce8:	10803fcc 	andi	r2,r2,255
81113cec:	1000071e 	bne	r2,zero,81113d0c <vOutAckHandlerTask+0x2d4>
                    puts(cBufferAck);
81113cf0:	e0bffac4 	addi	r2,fp,-21
81113cf4:	1009883a 	mov	r4,r2
81113cf8:	1123f640 	call	81123f64 <puts>
                    OSMutexPost(xTxUARTMutex);
81113cfc:	d0a07417 	ldw	r2,-32304(gp)
81113d00:	1009883a 	mov	r4,r2
81113d04:	113e3cc0 	call	8113e3cc <OSMutexPost>
81113d08:	00000106 	br	81113d10 <vOutAckHandlerTask+0x2d8>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81113d0c:	111ca940 	call	8111ca94 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81113d10:	00800044 	movi	r2,1
81113d14:	e0bff915 	stw	r2,-28(fp)
                
				break;
81113d18:	00001006 	br	81113d5c <vOutAckHandlerTask+0x324>
			default:
            	#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113d1c:	00a045f4 	movhi	r2,33047
81113d20:	10a00404 	addi	r2,r2,-32752
81113d24:	10800e8b 	ldhu	r2,58(r2)
81113d28:	10bfffcc 	andi	r2,r2,65535
81113d2c:	108001e8 	cmpgeui	r2,r2,7
81113d30:	1000071e 	bne	r2,zero,81113d50 <vOutAckHandlerTask+0x318>
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81113d34:	d0a06217 	ldw	r2,-32376(gp)
81113d38:	100f883a 	mov	r7,r2
81113d3c:	01801104 	movi	r6,68
81113d40:	01400044 	movi	r5,1
81113d44:	01204574 	movhi	r4,33045
81113d48:	213aec04 	addi	r4,r4,-5200
81113d4c:	11230300 	call	81123030 <fwrite>
				}
	            #endif
                eSenderAckState = sSAGettingACK;
81113d50:	00800044 	movi	r2,1
81113d54:	e0bff915 	stw	r2,-28(fp)
				break;
81113d58:	0001883a 	nop
		}
	}
81113d5c:	003f5c06 	br	81113ad0 <__reset+0xfb0f3ad0>

81113d60 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81113d60:	deffd704 	addi	sp,sp,-164
81113d64:	de00012e 	bgeu	sp,et,81113d6c <vParserCommTask+0xc>
81113d68:	003b68fa 	trap	3
81113d6c:	dfc02815 	stw	ra,160(sp)
81113d70:	df002715 	stw	fp,156(sp)
81113d74:	df002704 	addi	fp,sp,156
81113d78:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81113d7c:	e03fdd15 	stw	zero,-140(fp)
	#if DEBUG_ON
		char cPUSDebug[128];
	#endif

    #if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113d80:	00a045f4 	movhi	r2,33047
81113d84:	10a00404 	addi	r2,r2,-32752
81113d88:	10800e8b 	ldhu	r2,58(r2)
81113d8c:	10bfffcc 	andi	r2,r2,65535
81113d90:	10800168 	cmpgeui	r2,r2,5
81113d94:	1000071e 	bne	r2,zero,81113db4 <vParserCommTask+0x54>
			debug(fp,"Parser Comm Task. (Task on)\n");
81113d98:	d0a06217 	ldw	r2,-32376(gp)
81113d9c:	100f883a 	mov	r7,r2
81113da0:	01800704 	movi	r6,28
81113da4:	01400044 	movi	r5,1
81113da8:	01204574 	movhi	r4,33045
81113dac:	213afe04 	addi	r4,r4,-5128
81113db0:	11230300 	call	81123030 <fwrite>
		}
    #endif

	eParserMode = sConfiguring;
81113db4:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81113db8:	e0bfdc17 	ldw	r2,-144(fp)
81113dbc:	10800168 	cmpgeui	r2,r2,5
81113dc0:	1003d31e 	bne	r2,zero,81114d10 <vParserCommTask+0xfb0>
81113dc4:	e0bfdc17 	ldw	r2,-144(fp)
81113dc8:	100690ba 	slli	r3,r2,2
81113dcc:	00a04474 	movhi	r2,33041
81113dd0:	108f7804 	addi	r2,r2,15840
81113dd4:	1885883a 	add	r2,r3,r2
81113dd8:	10800017 	ldw	r2,0(r2)
81113ddc:	1000683a 	jmp	r2
81113de0:	81113df4 	orhi	r4,r16,17655
81113de4:	81113e00 	call	881113e0 <__reset+0x20f13e0>
81113de8:	81113e94 	ori	r4,r16,17658
81113dec:	81114010 	cmplti	r4,r16,17664
81113df0:	81114054 	ori	r4,r16,17665
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81113df4:	00800044 	movi	r2,1
81113df8:	e0bfdc15 	stw	r2,-144(fp)
				break;
81113dfc:	0003c706 	br	81114d1c <vParserCommTask+0xfbc>
			case sWaitingMessage:

				bSuccess = FALSE;
81113e00:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81113e04:	00800044 	movi	r2,1
81113e08:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81113e0c:	d0a06417 	ldw	r2,-32368(gp)
81113e10:	e0ffde84 	addi	r3,fp,-134
81113e14:	180d883a 	mov	r6,r3
81113e18:	000b883a 	mov	r5,zero
81113e1c:	1009883a 	mov	r4,r2
81113e20:	113fe340 	call	8113fe34 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81113e24:	e0bfde83 	ldbu	r2,-134(fp)
81113e28:	10803fcc 	andi	r2,r2,255
81113e2c:	1000171e 	bne	r2,zero,81113e8c <vParserCommTask+0x12c>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81113e30:	01204574 	movhi	r4,33045
81113e34:	2111c604 	addi	r4,r4,18200
81113e38:	1114d200 	call	81114d20 <getPreParsedPacket>
81113e3c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81113e40:	e0bfdd17 	ldw	r2,-140(fp)
81113e44:	10800058 	cmpnei	r2,r2,1
81113e48:	10000e1e 	bne	r2,zero,81113e84 <vParserCommTask+0x124>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
81113e4c:	00a04574 	movhi	r2,33045
81113e50:	1091c604 	addi	r2,r2,18200
81113e54:	10800103 	ldbu	r2,4(r2)
81113e58:	10803fcc 	andi	r2,r2,255
81113e5c:	1080201c 	xori	r2,r2,128
81113e60:	10bfe004 	addi	r2,r2,-128
81113e64:	10800858 	cmpnei	r2,r2,33
81113e68:	1000031e 	bne	r2,zero,81113e78 <vParserCommTask+0x118>
							eParserMode = sReplyParsing;
81113e6c:	008000c4 	movi	r2,3
81113e70:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113e74:	0003a906 	br	81114d1c <vParserCommTask+0xfbc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81113e78:	00800084 	movi	r2,2
81113e7c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113e80:	0003a606 	br	81114d1c <vParserCommTask+0xfbc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81113e84:	111d1880 	call	8111d188 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113e88:	0003a406 	br	81114d1c <vParserCommTask+0xfbc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
81113e8c:	111d0880 	call	8111d088 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81113e90:	0003a206 	br	81114d1c <vParserCommTask+0xfbc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
81113e94:	00a04574 	movhi	r2,33045
81113e98:	1091c604 	addi	r2,r2,18200
81113e9c:	10800143 	ldbu	r2,5(r2)
81113ea0:	10803fcc 	andi	r2,r2,255
81113ea4:	1080201c 	xori	r2,r2,128
81113ea8:	10bfe004 	addi	r2,r2,-128
81113eac:	10c010e0 	cmpeqi	r3,r2,67
81113eb0:	1800031e 	bne	r3,zero,81113ec0 <vParserCommTask+0x160>
81113eb4:	10801420 	cmpeqi	r2,r2,80
81113eb8:	1000051e 	bne	r2,zero,81113ed0 <vParserCommTask+0x170>
81113ebc:	00005006 	br	81114000 <vParserCommTask+0x2a0>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81113ec0:	1119c840 	call	81119c84 <vSendEthConf>
						eParserMode = sWaitingMessage;
81113ec4:	00800044 	movi	r2,1
81113ec8:	e0bfdc15 	stw	r2,-144(fp)
						break;
81113ecc:	00004f06 	br	8111400c <vParserCommTask+0x2ac>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#if DEBUG_ON
                    	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113ed0:	00a045f4 	movhi	r2,33047
81113ed4:	10a00404 	addi	r2,r2,-32752
81113ed8:	10800e8b 	ldhu	r2,58(r2)
81113edc:	10bfffcc 	andi	r2,r2,65535
81113ee0:	108000e8 	cmpgeui	r2,r2,3
81113ee4:	1000281e 	bne	r2,zero,81113f88 <vParserCommTask+0x228>
							memset(cPUSDebug,0,128);
81113ee8:	e0bfdec4 	addi	r2,fp,-133
81113eec:	01802004 	movi	r6,128
81113ef0:	000b883a 	mov	r5,zero
81113ef4:	1009883a 	mov	r4,r2
81113ef8:	1123b940 	call	81123b94 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81113efc:	00a04574 	movhi	r2,33045
81113f00:	1091c604 	addi	r2,r2,18200
81113f04:	1080028b 	ldhu	r2,10(r2)
81113f08:	117fffcc 	andi	r5,r2,65535
81113f0c:	00a04574 	movhi	r2,33045
81113f10:	1091c604 	addi	r2,r2,18200
81113f14:	1080030b 	ldhu	r2,12(r2)
81113f18:	11bfffcc 	andi	r6,r2,65535
81113f1c:	00a04574 	movhi	r2,33045
81113f20:	1091c604 	addi	r2,r2,18200
81113f24:	1080038b 	ldhu	r2,14(r2)
81113f28:	10ffffcc 	andi	r3,r2,65535
81113f2c:	00a04574 	movhi	r2,33045
81113f30:	1091c604 	addi	r2,r2,18200
81113f34:	1080040b 	ldhu	r2,16(r2)
81113f38:	113fffcc 	andi	r4,r2,65535
81113f3c:	00a04574 	movhi	r2,33045
81113f40:	1091c604 	addi	r2,r2,18200
81113f44:	1080048b 	ldhu	r2,18(r2)
81113f48:	10bfffcc 	andi	r2,r2,65535
81113f4c:	e23fdec4 	addi	r8,fp,-133
81113f50:	d8800215 	stw	r2,8(sp)
81113f54:	d9000115 	stw	r4,4(sp)
81113f58:	d8c00015 	stw	r3,0(sp)
81113f5c:	300f883a 	mov	r7,r6
81113f60:	280d883a 	mov	r6,r5
81113f64:	01604574 	movhi	r5,33045
81113f68:	297b0604 	addi	r5,r5,-5096
81113f6c:	4009883a 	mov	r4,r8
81113f70:	11242a80 	call	811242a8 <sprintf>
							debug(fp, cPUSDebug );
81113f74:	d0a06217 	ldw	r2,-32376(gp)
81113f78:	e0ffdec4 	addi	r3,fp,-133
81113f7c:	180b883a 	mov	r5,r3
81113f80:	1009883a 	mov	r4,r2
81113f84:	11229940 	call	81122994 <fprintf>
                    	}
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81113f88:	00a04574 	movhi	r2,33045
81113f8c:	1091c604 	addi	r2,r2,18200
81113f90:	10c0030b 	ldhu	r3,12(r2)
81113f94:	00a04574 	movhi	r2,33045
81113f98:	1091d904 	addi	r2,r2,18276
81113f9c:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81113fa0:	00a04574 	movhi	r2,33045
81113fa4:	1091c604 	addi	r2,r2,18200
81113fa8:	10c0038b 	ldhu	r3,14(r2)
81113fac:	00a04574 	movhi	r2,33045
81113fb0:	1091d904 	addi	r2,r2,18276
81113fb4:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81113fb8:	00a04574 	movhi	r2,33045
81113fbc:	1091c604 	addi	r2,r2,18200
81113fc0:	10c0040b 	ldhu	r3,16(r2)
81113fc4:	00a04574 	movhi	r2,33045
81113fc8:	1091d904 	addi	r2,r2,18276
81113fcc:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81113fd0:	00a04574 	movhi	r2,33045
81113fd4:	1091c604 	addi	r2,r2,18200
81113fd8:	10c0048b 	ldhu	r3,18(r2)
81113fdc:	00a04574 	movhi	r2,33045
81113fe0:	1091d904 	addi	r2,r2,18276
81113fe4:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81113fe8:	00a04574 	movhi	r2,33045
81113fec:	1091d904 	addi	r2,r2,18276
81113ff0:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81113ff4:	00800104 	movi	r2,4
81113ff8:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81113ffc:	00000306 	br	8111400c <vParserCommTask+0x2ac>
					default:
						eParserMode = sWaitingMessage;
81114000:	00800044 	movi	r2,1
81114004:	e0bfdc15 	stw	r2,-144(fp)
						break;
81114008:	0001883a 	nop
				}
				break;
8111400c:	00034306 	br	81114d1c <vParserCommTask+0xfbc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81114010:	00800044 	movi	r2,1
81114014:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81114018:	00a04574 	movhi	r2,33045
8111401c:	1091d904 	addi	r2,r2,18276
81114020:	1080030b 	ldhu	r2,12(r2)
81114024:	10bfffcc 	andi	r2,r2,65535
81114028:	10c01220 	cmpeqi	r3,r2,72
8111402c:	1800051e 	bne	r3,zero,81114044 <vParserCommTask+0x2e4>
81114030:	108014e0 	cmpeqi	r2,r2,83
81114034:	1000051e 	bne	r2,zero,8111404c <vParserCommTask+0x2ec>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81114038:	00800044 	movi	r2,1
8111403c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81114040:	00000306 	br	81114050 <vParserCommTask+0x2f0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81114044:	0001883a 	nop
81114048:	00033406 	br	81114d1c <vParserCommTask+0xfbc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8111404c:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81114050:	00033206 	br	81114d1c <vParserCommTask+0xfbc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81114054:	00800044 	movi	r2,1
81114058:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8111405c:	00a04574 	movhi	r2,33045
81114060:	1091d904 	addi	r2,r2,18276
81114064:	1080030b 	ldhu	r2,12(r2)
81114068:	10bfffcc 	andi	r2,r2,65535
8111406c:	10c03ea0 	cmpeqi	r3,r2,250
81114070:	18004c1e 	bne	r3,zero,811141a4 <vParserCommTask+0x444>
81114074:	10c03ec8 	cmpgei	r3,r2,251
81114078:	1800031e 	bne	r3,zero,81114088 <vParserCommTask+0x328>
8111407c:	10800460 	cmpeqi	r2,r2,17
81114080:	1000061e 	bne	r2,zero,8111409c <vParserCommTask+0x33c>
81114084:	00031d06 	br	81114cfc <vParserCommTask+0xf9c>
81114088:	10c03ee0 	cmpeqi	r3,r2,251
8111408c:	1800c71e 	bne	r3,zero,811143ac <vParserCommTask+0x64c>
81114090:	10803f20 	cmpeqi	r2,r2,252
81114094:	10017a1e 	bne	r2,zero,81114680 <vParserCommTask+0x920>
81114098:	00031806 	br	81114cfc <vParserCommTask+0xf9c>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8111409c:	00a04574 	movhi	r2,33045
811140a0:	1091d904 	addi	r2,r2,18276
811140a4:	1080038b 	ldhu	r2,14(r2)
811140a8:	10bfffcc 	andi	r2,r2,65535
811140ac:	10800060 	cmpeqi	r2,r2,1
811140b0:	10001426 	beq	r2,zero,81114104 <vParserCommTask+0x3a4>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811140b4:	00a045f4 	movhi	r2,33047
811140b8:	10a00404 	addi	r2,r2,-32752
811140bc:	10800e8b 	ldhu	r2,58(r2)
811140c0:	10bfffcc 	andi	r2,r2,65535
811140c4:	10800168 	cmpgeui	r2,r2,5
811140c8:	1000071e 	bne	r2,zero,811140e8 <vParserCommTask+0x388>
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
811140cc:	d0a06217 	ldw	r2,-32376(gp)
811140d0:	100f883a 	mov	r7,r2
811140d4:	01800944 	movi	r6,37
811140d8:	01400044 	movi	r5,1
811140dc:	01204574 	movhi	r4,33045
811140e0:	213b1c04 	addi	r4,r4,-5008
811140e4:	11230300 	call	81123030 <fwrite>
								}
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
811140e8:	00a04574 	movhi	r2,33045
811140ec:	1091d904 	addi	r2,r2,18276
811140f0:	1080040b 	ldhu	r2,16(r2)
811140f4:	10bfffcc 	andi	r2,r2,65535
811140f8:	1009883a 	mov	r4,r2
811140fc:	111a6840 	call	8111a684 <vTMPusTestConnection>

								break;
81114100:	00002706 	br	811141a0 <vParserCommTask+0x440>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114104:	00a045f4 	movhi	r2,33047
81114108:	10a00404 	addi	r2,r2,-32752
8111410c:	10800e8b 	ldhu	r2,58(r2)
81114110:	10bfffcc 	andi	r2,r2,65535
81114114:	108000e8 	cmpgeui	r2,r2,3
81114118:	10001e1e 	bne	r2,zero,81114194 <vParserCommTask+0x434>
									memset(cPUSDebug,0,128);
8111411c:	e0bfdec4 	addi	r2,fp,-133
81114120:	01802004 	movi	r6,128
81114124:	000b883a 	mov	r5,zero
81114128:	1009883a 	mov	r4,r2
8111412c:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114130:	00a04574 	movhi	r2,33045
81114134:	1091d904 	addi	r2,r2,18276
81114138:	1080030b 	ldhu	r2,12(r2)
8111413c:	113fffcc 	andi	r4,r2,65535
81114140:	00a04574 	movhi	r2,33045
81114144:	1091d904 	addi	r2,r2,18276
81114148:	1080038b 	ldhu	r2,14(r2)
8111414c:	117fffcc 	andi	r5,r2,65535
81114150:	00a04574 	movhi	r2,33045
81114154:	1091d904 	addi	r2,r2,18276
81114158:	1080040b 	ldhu	r2,16(r2)
8111415c:	10bfffcc 	andi	r2,r2,65535
81114160:	e0ffdec4 	addi	r3,fp,-133
81114164:	d8800015 	stw	r2,0(sp)
81114168:	280f883a 	mov	r7,r5
8111416c:	200d883a 	mov	r6,r4
81114170:	01604574 	movhi	r5,33045
81114174:	297b2604 	addi	r5,r5,-4968
81114178:	1809883a 	mov	r4,r3
8111417c:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114180:	d0a06217 	ldw	r2,-32376(gp)
81114184:	e0ffdec4 	addi	r3,fp,-133
81114188:	180b883a 	mov	r5,r3
8111418c:	1009883a 	mov	r4,r2
81114190:	11229940 	call	81122994 <fprintf>
								}
								#endif
								eParserMode = sWaitingMessage;
81114194:	00800044 	movi	r2,1
81114198:	e0bfdc15 	stw	r2,-144(fp)
								break;
8111419c:	0001883a 	nop
						}
                        break;
811141a0:	0002da06 	br	81114d0c <vParserCommTask+0xfac>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
811141a4:	00a04574 	movhi	r2,33045
811141a8:	1091d904 	addi	r2,r2,18276
811141ac:	1080038b 	ldhu	r2,14(r2)
811141b0:	10bfffcc 	andi	r2,r2,65535
811141b4:	10c00f20 	cmpeqi	r3,r2,60
811141b8:	1800201e 	bne	r3,zero,8111423c <vParserCommTask+0x4dc>
811141bc:	10c00f48 	cmpgei	r3,r2,61
811141c0:	1800031e 	bne	r3,zero,811141d0 <vParserCommTask+0x470>
811141c4:	10800ee0 	cmpeqi	r2,r2,59
811141c8:	1000061e 	bne	r2,zero,811141e4 <vParserCommTask+0x484>
811141cc:	00004f06 	br	8111430c <vParserCommTask+0x5ac>
811141d0:	10c00f60 	cmpeqi	r3,r2,61
811141d4:	18002a1e 	bne	r3,zero,81114280 <vParserCommTask+0x520>
811141d8:	10800fa0 	cmpeqi	r2,r2,62
811141dc:	1000391e 	bne	r2,zero,811142c4 <vParserCommTask+0x564>
811141e0:	00004a06 	br	8111430c <vParserCommTask+0x5ac>
						{
							case 59: /* TC_SCAM_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811141e4:	00a045f4 	movhi	r2,33047
811141e8:	10a00404 	addi	r2,r2,-32752
811141ec:	10800e8b 	ldhu	r2,58(r2)
811141f0:	10bfffcc 	andi	r2,r2,65535
811141f4:	108000e8 	cmpgeui	r2,r2,3
811141f8:	1000071e 	bne	r2,zero,81114218 <vParserCommTask+0x4b8>
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
811141fc:	d0a06217 	ldw	r2,-32376(gp)
81114200:	100f883a 	mov	r7,r2
81114204:	018006c4 	movi	r6,27
81114208:	01400044 	movi	r5,1
8111420c:	01204574 	movhi	r4,33045
81114210:	213b3904 	addi	r4,r4,-4892
81114214:	11230300 	call	81123030 <fwrite>
								}
								#endif
								vSendReset();
81114218:	111a02c0 	call	8111a02c <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8111421c:	000f883a 	mov	r7,zero
81114220:	018000c4 	movi	r6,3
81114224:	000b883a 	mov	r5,zero
81114228:	0009883a 	mov	r4,zero
8111422c:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81114230:	0104e204 	movi	r4,5000
81114234:	110c3280 	call	8110c328 <vRstcSimucamReset>

								break;
81114238:	00005b06 	br	811143a8 <vParserCommTask+0x648>
							case 60: /* TC_SCAM_CONFIG */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111423c:	00a045f4 	movhi	r2,33047
81114240:	10a00404 	addi	r2,r2,-32752
81114244:	10800e8b 	ldhu	r2,58(r2)
81114248:	10bfffcc 	andi	r2,r2,65535
8111424c:	108000e8 	cmpgeui	r2,r2,3
81114250:	1000071e 	bne	r2,zero,81114270 <vParserCommTask+0x510>
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81114254:	d0a06217 	ldw	r2,-32376(gp)
81114258:	100f883a 	mov	r7,r2
8111425c:	01800704 	movi	r6,28
81114260:	01400044 	movi	r5,1
81114264:	01204574 	movhi	r4,33045
81114268:	213b4004 	addi	r4,r4,-4864
8111426c:	11230300 	call	81123030 <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114270:	01204574 	movhi	r4,33045
81114274:	2111d904 	addi	r4,r4,18276
81114278:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

								break;
8111427c:	00004a06 	br	811143a8 <vParserCommTask+0x648>
							case 61: /* TC_SCAM_RUN */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114280:	00a045f4 	movhi	r2,33047
81114284:	10a00404 	addi	r2,r2,-32752
81114288:	10800e8b 	ldhu	r2,58(r2)
8111428c:	10bfffcc 	andi	r2,r2,65535
81114290:	108000e8 	cmpgeui	r2,r2,3
81114294:	1000071e 	bne	r2,zero,811142b4 <vParserCommTask+0x554>
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81114298:	d0a06217 	ldw	r2,-32376(gp)
8111429c:	100f883a 	mov	r7,r2
811142a0:	01800644 	movi	r6,25
811142a4:	01400044 	movi	r5,1
811142a8:	01204574 	movhi	r4,33045
811142ac:	213b4804 	addi	r4,r4,-4832
811142b0:	11230300 	call	81123030 <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811142b4:	01204574 	movhi	r4,33045
811142b8:	2111d904 	addi	r4,r4,18276
811142bc:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

								break;
811142c0:	00003906 	br	811143a8 <vParserCommTask+0x648>
							case 62: /* TC_SCAM_TURNOFF */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811142c4:	00a045f4 	movhi	r2,33047
811142c8:	10a00404 	addi	r2,r2,-32752
811142cc:	10800e8b 	ldhu	r2,58(r2)
811142d0:	10bfffcc 	andi	r2,r2,65535
811142d4:	108000e8 	cmpgeui	r2,r2,3
811142d8:	1000071e 	bne	r2,zero,811142f8 <vParserCommTask+0x598>
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
811142dc:	d0a06217 	ldw	r2,-32376(gp)
811142e0:	100f883a 	mov	r7,r2
811142e4:	01800744 	movi	r6,29
811142e8:	01400044 	movi	r5,1
811142ec:	01204574 	movhi	r4,33045
811142f0:	213b4f04 	addi	r4,r4,-4804
811142f4:	11230300 	call	81123030 <fwrite>
								}
								#endif
								vSendTurnOff();
811142f8:	1119f140 	call	81119f14 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
811142fc:	01204574 	movhi	r4,33045
81114300:	2111d904 	addi	r4,r4,18276
81114304:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

								break;
81114308:	00002706 	br	811143a8 <vParserCommTask+0x648>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111430c:	00a045f4 	movhi	r2,33047
81114310:	10a00404 	addi	r2,r2,-32752
81114314:	10800e8b 	ldhu	r2,58(r2)
81114318:	10bfffcc 	andi	r2,r2,65535
8111431c:	108000e8 	cmpgeui	r2,r2,3
81114320:	10001e1e 	bne	r2,zero,8111439c <vParserCommTask+0x63c>
									memset(cPUSDebug,0,128);
81114324:	e0bfdec4 	addi	r2,fp,-133
81114328:	01802004 	movi	r6,128
8111432c:	000b883a 	mov	r5,zero
81114330:	1009883a 	mov	r4,r2
81114334:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114338:	00a04574 	movhi	r2,33045
8111433c:	1091d904 	addi	r2,r2,18276
81114340:	1080030b 	ldhu	r2,12(r2)
81114344:	113fffcc 	andi	r4,r2,65535
81114348:	00a04574 	movhi	r2,33045
8111434c:	1091d904 	addi	r2,r2,18276
81114350:	1080038b 	ldhu	r2,14(r2)
81114354:	117fffcc 	andi	r5,r2,65535
81114358:	00a04574 	movhi	r2,33045
8111435c:	1091d904 	addi	r2,r2,18276
81114360:	1080040b 	ldhu	r2,16(r2)
81114364:	10bfffcc 	andi	r2,r2,65535
81114368:	e0ffdec4 	addi	r3,fp,-133
8111436c:	d8800015 	stw	r2,0(sp)
81114370:	280f883a 	mov	r7,r5
81114374:	200d883a 	mov	r6,r4
81114378:	01604574 	movhi	r5,33045
8111437c:	297b2604 	addi	r5,r5,-4968
81114380:	1809883a 	mov	r4,r3
81114384:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114388:	d0a06217 	ldw	r2,-32376(gp)
8111438c:	e0ffdec4 	addi	r3,fp,-133
81114390:	180b883a 	mov	r5,r3
81114394:	1009883a 	mov	r4,r2
81114398:	11229940 	call	81122994 <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
8111439c:	00800044 	movi	r2,1
811143a0:	e0bfdc15 	stw	r2,-144(fp)
								break;
811143a4:	0001883a 	nop
						}
                        break;
811143a8:	00025806 	br	81114d0c <vParserCommTask+0xfac>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811143ac:	00a04574 	movhi	r2,33045
811143b0:	1091c604 	addi	r2,r2,18200
811143b4:	1080050b 	ldhu	r2,20(r2)
811143b8:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
811143bc:	e0bfde0b 	ldhu	r2,-136(fp)
811143c0:	108000b0 	cmpltui	r2,r2,2
811143c4:	1000181e 	bne	r2,zero,81114428 <vParserCommTask+0x6c8>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811143c8:	00a045f4 	movhi	r2,33047
811143cc:	10a00404 	addi	r2,r2,-32752
811143d0:	10800e8b 	ldhu	r2,58(r2)
811143d4:	10bfffcc 	andi	r2,r2,65535
811143d8:	108000e8 	cmpgeui	r2,r2,3
811143dc:	10024a1e 	bne	r2,zero,81114d08 <vParserCommTask+0xfa8>
								memset(cPUSDebug,0,128);
811143e0:	e0bfdec4 	addi	r2,fp,-133
811143e4:	01802004 	movi	r6,128
811143e8:	000b883a 	mov	r5,zero
811143ec:	1009883a 	mov	r4,r2
811143f0:	1123b940 	call	81123b94 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
811143f4:	e0ffde0b 	ldhu	r3,-136(fp)
811143f8:	e0bfdec4 	addi	r2,fp,-133
811143fc:	180d883a 	mov	r6,r3
81114400:	01604574 	movhi	r5,33045
81114404:	297b5704 	addi	r5,r5,-4772
81114408:	1009883a 	mov	r4,r2
8111440c:	11242a80 	call	811242a8 <sprintf>
								debug(fp, cPUSDebug );
81114410:	d0a06217 	ldw	r2,-32376(gp)
81114414:	e0ffdec4 	addi	r3,fp,-133
81114418:	180b883a 	mov	r5,r3
8111441c:	1009883a 	mov	r4,r2
81114420:	11229940 	call	81122994 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81114424:	00023806 	br	81114d08 <vParserCommTask+0xfa8>
								debug(fp, cPUSDebug );
							}
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81114428:	00a04574 	movhi	r2,33045
8111442c:	1091d904 	addi	r2,r2,18276
81114430:	10800483 	ldbu	r2,18(r2)
81114434:	10c03fcc 	andi	r3,r2,255
81114438:	00a04574 	movhi	r2,33045
8111443c:	1091d904 	addi	r2,r2,18276
81114440:	18c00284 	addi	r3,r3,10
81114444:	18c7883a 	add	r3,r3,r3
81114448:	10c5883a 	add	r2,r2,r3
8111444c:	e0ffde0b 	ldhu	r3,-136(fp)
81114450:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81114454:	00a04574 	movhi	r2,33045
81114458:	1091d904 	addi	r2,r2,18276
8111445c:	10800483 	ldbu	r2,18(r2)
81114460:	10800044 	addi	r2,r2,1
81114464:	1007883a 	mov	r3,r2
81114468:	00a04574 	movhi	r2,33045
8111446c:	1091d904 	addi	r2,r2,18276
81114470:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81114474:	00a04574 	movhi	r2,33045
81114478:	1091d904 	addi	r2,r2,18276
8111447c:	1080038b 	ldhu	r2,14(r2)
81114480:	10bfffcc 	andi	r2,r2,65535
81114484:	10c000a0 	cmpeqi	r3,r2,2
81114488:	18001f1e 	bne	r3,zero,81114508 <vParserCommTask+0x7a8>
8111448c:	10c00160 	cmpeqi	r3,r2,5
81114490:	1800381e 	bne	r3,zero,81114574 <vParserCommTask+0x814>
81114494:	10800060 	cmpeqi	r2,r2,1
81114498:	10005126 	beq	r2,zero,811145e0 <vParserCommTask+0x880>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111449c:	00a045f4 	movhi	r2,33047
811144a0:	10a00404 	addi	r2,r2,-32752
811144a4:	10800e8b 	ldhu	r2,58(r2)
811144a8:	10bfffcc 	andi	r2,r2,65535
811144ac:	108000e8 	cmpgeui	r2,r2,3
811144b0:	1000111e 	bne	r2,zero,811144f8 <vParserCommTask+0x798>
										memset(cPUSDebug,0,128);
811144b4:	e0bfdec4 	addi	r2,fp,-133
811144b8:	01802004 	movi	r6,128
811144bc:	000b883a 	mov	r5,zero
811144c0:	1009883a 	mov	r4,r2
811144c4:	1123b940 	call	81123b94 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811144c8:	e0ffde0b 	ldhu	r3,-136(fp)
811144cc:	e0bfdec4 	addi	r2,fp,-133
811144d0:	180d883a 	mov	r6,r3
811144d4:	01604574 	movhi	r5,33045
811144d8:	297b6604 	addi	r5,r5,-4712
811144dc:	1009883a 	mov	r4,r2
811144e0:	11242a80 	call	811242a8 <sprintf>
										debug(fp, cPUSDebug );
811144e4:	d0a06217 	ldw	r2,-32376(gp)
811144e8:	e0ffdec4 	addi	r3,fp,-133
811144ec:	180b883a 	mov	r5,r3
811144f0:	1009883a 	mov	r4,r2
811144f4:	11229940 	call	81122994 <fprintf>
									}
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
811144f8:	01204574 	movhi	r4,33045
811144fc:	2111d904 	addi	r4,r4,18276
81114500:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

									break;
81114504:	00005d06 	br	8111467c <vParserCommTask+0x91c>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114508:	00a045f4 	movhi	r2,33047
8111450c:	10a00404 	addi	r2,r2,-32752
81114510:	10800e8b 	ldhu	r2,58(r2)
81114514:	10bfffcc 	andi	r2,r2,65535
81114518:	108000e8 	cmpgeui	r2,r2,3
8111451c:	1000111e 	bne	r2,zero,81114564 <vParserCommTask+0x804>
										memset(cPUSDebug,0,128);
81114520:	e0bfdec4 	addi	r2,fp,-133
81114524:	01802004 	movi	r6,128
81114528:	000b883a 	mov	r5,zero
8111452c:	1009883a 	mov	r4,r2
81114530:	1123b940 	call	81123b94 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114534:	e0ffde0b 	ldhu	r3,-136(fp)
81114538:	e0bfdec4 	addi	r2,fp,-133
8111453c:	180d883a 	mov	r6,r3
81114540:	01604574 	movhi	r5,33045
81114544:	297b7604 	addi	r5,r5,-4648
81114548:	1009883a 	mov	r4,r2
8111454c:	11242a80 	call	811242a8 <sprintf>
										debug(fp, cPUSDebug );
81114550:	d0a06217 	ldw	r2,-32376(gp)
81114554:	e0ffdec4 	addi	r3,fp,-133
81114558:	180b883a 	mov	r5,r3
8111455c:	1009883a 	mov	r4,r2
81114560:	11229940 	call	81122994 <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81114564:	01204574 	movhi	r4,33045
81114568:	2111d904 	addi	r4,r4,18276
8111456c:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

									break;
81114570:	00004206 	br	8111467c <vParserCommTask+0x91c>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114574:	00a045f4 	movhi	r2,33047
81114578:	10a00404 	addi	r2,r2,-32752
8111457c:	10800e8b 	ldhu	r2,58(r2)
81114580:	10bfffcc 	andi	r2,r2,65535
81114584:	108000e8 	cmpgeui	r2,r2,3
81114588:	1000111e 	bne	r2,zero,811145d0 <vParserCommTask+0x870>
										memset(cPUSDebug,0,128);
8111458c:	e0bfdec4 	addi	r2,fp,-133
81114590:	01802004 	movi	r6,128
81114594:	000b883a 	mov	r5,zero
81114598:	1009883a 	mov	r4,r2
8111459c:	1123b940 	call	81123b94 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811145a0:	e0ffde0b 	ldhu	r3,-136(fp)
811145a4:	e0bfdec4 	addi	r2,fp,-133
811145a8:	180d883a 	mov	r6,r3
811145ac:	01604574 	movhi	r5,33045
811145b0:	297b8604 	addi	r5,r5,-4584
811145b4:	1009883a 	mov	r4,r2
811145b8:	11242a80 	call	811242a8 <sprintf>
										debug(fp, cPUSDebug );
811145bc:	d0a06217 	ldw	r2,-32376(gp)
811145c0:	e0ffdec4 	addi	r3,fp,-133
811145c4:	180b883a 	mov	r5,r3
811145c8:	1009883a 	mov	r4,r2
811145cc:	11229940 	call	81122994 <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811145d0:	01204574 	movhi	r4,33045
811145d4:	2111d904 	addi	r4,r4,18276
811145d8:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

									break;
811145dc:	00002706 	br	8111467c <vParserCommTask+0x91c>
								default:
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811145e0:	00a045f4 	movhi	r2,33047
811145e4:	10a00404 	addi	r2,r2,-32752
811145e8:	10800e8b 	ldhu	r2,58(r2)
811145ec:	10bfffcc 	andi	r2,r2,65535
811145f0:	108000e8 	cmpgeui	r2,r2,3
811145f4:	10001e1e 	bne	r2,zero,81114670 <vParserCommTask+0x910>
										memset(cPUSDebug,0,128);
811145f8:	e0bfdec4 	addi	r2,fp,-133
811145fc:	01802004 	movi	r6,128
81114600:	000b883a 	mov	r5,zero
81114604:	1009883a 	mov	r4,r2
81114608:	1123b940 	call	81123b94 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8111460c:	00a04574 	movhi	r2,33045
81114610:	1091d904 	addi	r2,r2,18276
81114614:	1080030b 	ldhu	r2,12(r2)
81114618:	113fffcc 	andi	r4,r2,65535
8111461c:	00a04574 	movhi	r2,33045
81114620:	1091d904 	addi	r2,r2,18276
81114624:	1080038b 	ldhu	r2,14(r2)
81114628:	117fffcc 	andi	r5,r2,65535
8111462c:	00a04574 	movhi	r2,33045
81114630:	1091d904 	addi	r2,r2,18276
81114634:	1080040b 	ldhu	r2,16(r2)
81114638:	10bfffcc 	andi	r2,r2,65535
8111463c:	e0ffdec4 	addi	r3,fp,-133
81114640:	d8800015 	stw	r2,0(sp)
81114644:	280f883a 	mov	r7,r5
81114648:	200d883a 	mov	r6,r4
8111464c:	01604574 	movhi	r5,33045
81114650:	297b2604 	addi	r5,r5,-4968
81114654:	1809883a 	mov	r4,r3
81114658:	11242a80 	call	811242a8 <sprintf>
										debug(fp, cPUSDebug );
8111465c:	d0a06217 	ldw	r2,-32376(gp)
81114660:	e0ffdec4 	addi	r3,fp,-133
81114664:	180b883a 	mov	r5,r3
81114668:	1009883a 	mov	r4,r2
8111466c:	11229940 	call	81122994 <fprintf>
									}
									#endif							
									eParserMode = sWaitingMessage;
81114670:	00800044 	movi	r2,1
81114674:	e0bfdc15 	stw	r2,-144(fp)
									break;
81114678:	0001883a 	nop
							}
						}
                        break;
8111467c:	0001a206 	br	81114d08 <vParserCommTask+0xfa8>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81114680:	00a04574 	movhi	r2,33045
81114684:	1091c604 	addi	r2,r2,18200
81114688:	1080050b 	ldhu	r2,20(r2)
8111468c:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81114690:	00a04574 	movhi	r2,33045
81114694:	1091d904 	addi	r2,r2,18276
81114698:	10800483 	ldbu	r2,18(r2)
8111469c:	10c03fcc 	andi	r3,r2,255
811146a0:	00a04574 	movhi	r2,33045
811146a4:	1091d904 	addi	r2,r2,18276
811146a8:	18c00284 	addi	r3,r3,10
811146ac:	18c7883a 	add	r3,r3,r3
811146b0:	10c5883a 	add	r2,r2,r3
811146b4:	e0ffde0b 	ldhu	r3,-136(fp)
811146b8:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
811146bc:	00a04574 	movhi	r2,33045
811146c0:	1091d904 	addi	r2,r2,18276
811146c4:	10800483 	ldbu	r2,18(r2)
811146c8:	10800044 	addi	r2,r2,1
811146cc:	1007883a 	mov	r3,r2
811146d0:	00a04574 	movhi	r2,33045
811146d4:	1091d904 	addi	r2,r2,18276
811146d8:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811146dc:	00a04574 	movhi	r2,33045
811146e0:	1091d904 	addi	r2,r2,18276
811146e4:	1080038b 	ldhu	r2,14(r2)
811146e8:	10bfffcc 	andi	r2,r2,65535
811146ec:	10c000e0 	cmpeqi	r3,r2,3
811146f0:	18000a1e 	bne	r3,zero,8111471c <vParserCommTask+0x9bc>
811146f4:	10c00108 	cmpgei	r3,r2,4
811146f8:	1800031e 	bne	r3,zero,81114708 <vParserCommTask+0x9a8>
811146fc:	108000a0 	cmpeqi	r2,r2,2
81114700:	1000571e 	bne	r2,zero,81114860 <vParserCommTask+0xb00>
81114704:	00015406 	br	81114c58 <vParserCommTask+0xef8>
81114708:	10c00120 	cmpeqi	r3,r2,4
8111470c:	18001e1e 	bne	r3,zero,81114788 <vParserCommTask+0xa28>
81114710:	10800160 	cmpeqi	r2,r2,5
81114714:	1000371e 	bne	r2,zero,811147f4 <vParserCommTask+0xa94>
81114718:	00014f06 	br	81114c58 <vParserCommTask+0xef8>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111471c:	00a045f4 	movhi	r2,33047
81114720:	10a00404 	addi	r2,r2,-32752
81114724:	10800e8b 	ldhu	r2,58(r2)
81114728:	10bfffcc 	andi	r2,r2,65535
8111472c:	108000e8 	cmpgeui	r2,r2,3
81114730:	1000111e 	bne	r2,zero,81114778 <vParserCommTask+0xa18>
									memset(cPUSDebug,0,128);
81114734:	e0bfdec4 	addi	r2,fp,-133
81114738:	01802004 	movi	r6,128
8111473c:	000b883a 	mov	r5,zero
81114740:	1009883a 	mov	r4,r2
81114744:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114748:	e0ffde0b 	ldhu	r3,-136(fp)
8111474c:	e0bfdec4 	addi	r2,fp,-133
81114750:	180d883a 	mov	r6,r3
81114754:	01604574 	movhi	r5,33045
81114758:	297b9804 	addi	r5,r5,-4512
8111475c:	1009883a 	mov	r4,r2
81114760:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114764:	d0a06217 	ldw	r2,-32376(gp)
81114768:	e0ffdec4 	addi	r3,fp,-133
8111476c:	180b883a 	mov	r5,r3
81114770:	1009883a 	mov	r4,r2
81114774:	11229940 	call	81122994 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114778:	01204574 	movhi	r4,33045
8111477c:	2111d904 	addi	r4,r4,18276
81114780:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

								break;
81114784:	00015c06 	br	81114cf8 <vParserCommTask+0xf98>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114788:	00a045f4 	movhi	r2,33047
8111478c:	10a00404 	addi	r2,r2,-32752
81114790:	10800e8b 	ldhu	r2,58(r2)
81114794:	10bfffcc 	andi	r2,r2,65535
81114798:	108000e8 	cmpgeui	r2,r2,3
8111479c:	1000111e 	bne	r2,zero,811147e4 <vParserCommTask+0xa84>
									memset(cPUSDebug,0,128);
811147a0:	e0bfdec4 	addi	r2,fp,-133
811147a4:	01802004 	movi	r6,128
811147a8:	000b883a 	mov	r5,zero
811147ac:	1009883a 	mov	r4,r2
811147b0:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811147b4:	e0ffde0b 	ldhu	r3,-136(fp)
811147b8:	e0bfdec4 	addi	r2,fp,-133
811147bc:	180d883a 	mov	r6,r3
811147c0:	01604574 	movhi	r5,33045
811147c4:	297ba804 	addi	r5,r5,-4448
811147c8:	1009883a 	mov	r4,r2
811147cc:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
811147d0:	d0a06217 	ldw	r2,-32376(gp)
811147d4:	e0ffdec4 	addi	r3,fp,-133
811147d8:	180b883a 	mov	r5,r3
811147dc:	1009883a 	mov	r4,r2
811147e0:	11229940 	call	81122994 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811147e4:	01204574 	movhi	r4,33045
811147e8:	2111d904 	addi	r4,r4,18276
811147ec:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

								break;
811147f0:	00014106 	br	81114cf8 <vParserCommTask+0xf98>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811147f4:	00a045f4 	movhi	r2,33047
811147f8:	10a00404 	addi	r2,r2,-32752
811147fc:	10800e8b 	ldhu	r2,58(r2)
81114800:	10bfffcc 	andi	r2,r2,65535
81114804:	108000e8 	cmpgeui	r2,r2,3
81114808:	1000111e 	bne	r2,zero,81114850 <vParserCommTask+0xaf0>
									memset(cPUSDebug,0,128);
8111480c:	e0bfdec4 	addi	r2,fp,-133
81114810:	01802004 	movi	r6,128
81114814:	000b883a 	mov	r5,zero
81114818:	1009883a 	mov	r4,r2
8111481c:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114820:	e0ffde0b 	ldhu	r3,-136(fp)
81114824:	e0bfdec4 	addi	r2,fp,-133
81114828:	180d883a 	mov	r6,r3
8111482c:	01604574 	movhi	r5,33045
81114830:	297bb804 	addi	r5,r5,-4384
81114834:	1009883a 	mov	r4,r2
81114838:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
8111483c:	d0a06217 	ldw	r2,-32376(gp)
81114840:	e0ffdec4 	addi	r3,fp,-133
81114844:	180b883a 	mov	r5,r3
81114848:	1009883a 	mov	r4,r2
8111484c:	11229940 	call	81122994 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114850:	01204574 	movhi	r4,33045
81114854:	2111d904 	addi	r4,r4,18276
81114858:	1114e380 	call	81114e38 <bSendMessagePUStoMebTask>

								break;
8111485c:	00012606 	br	81114cf8 <vParserCommTask+0xf98>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81114860:	00a04574 	movhi	r2,33045
81114864:	1091d904 	addi	r2,r2,18276
81114868:	10800483 	ldbu	r2,18(r2)
8111486c:	10c03fcc 	andi	r3,r2,255
81114870:	00a04574 	movhi	r2,33045
81114874:	1091c604 	addi	r2,r2,18200
81114878:	1100058b 	ldhu	r4,22(r2)
8111487c:	00a04574 	movhi	r2,33045
81114880:	1091d904 	addi	r2,r2,18276
81114884:	18c00284 	addi	r3,r3,10
81114888:	18c7883a 	add	r3,r3,r3
8111488c:	10c5883a 	add	r2,r2,r3
81114890:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114894:	00a04574 	movhi	r2,33045
81114898:	1091d904 	addi	r2,r2,18276
8111489c:	10800483 	ldbu	r2,18(r2)
811148a0:	10800044 	addi	r2,r2,1
811148a4:	1007883a 	mov	r3,r2
811148a8:	00a04574 	movhi	r2,33045
811148ac:	1091d904 	addi	r2,r2,18276
811148b0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
811148b4:	00a04574 	movhi	r2,33045
811148b8:	1091d904 	addi	r2,r2,18276
811148bc:	10800483 	ldbu	r2,18(r2)
811148c0:	10c03fcc 	andi	r3,r2,255
811148c4:	00a04574 	movhi	r2,33045
811148c8:	1091c604 	addi	r2,r2,18200
811148cc:	1100060b 	ldhu	r4,24(r2)
811148d0:	00a04574 	movhi	r2,33045
811148d4:	1091d904 	addi	r2,r2,18276
811148d8:	18c00284 	addi	r3,r3,10
811148dc:	18c7883a 	add	r3,r3,r3
811148e0:	10c5883a 	add	r2,r2,r3
811148e4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811148e8:	00a04574 	movhi	r2,33045
811148ec:	1091d904 	addi	r2,r2,18276
811148f0:	10800483 	ldbu	r2,18(r2)
811148f4:	10800044 	addi	r2,r2,1
811148f8:	1007883a 	mov	r3,r2
811148fc:	00a04574 	movhi	r2,33045
81114900:	1091d904 	addi	r2,r2,18276
81114904:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81114908:	00a04574 	movhi	r2,33045
8111490c:	1091d904 	addi	r2,r2,18276
81114910:	10800483 	ldbu	r2,18(r2)
81114914:	10c03fcc 	andi	r3,r2,255
81114918:	00a04574 	movhi	r2,33045
8111491c:	1091c604 	addi	r2,r2,18200
81114920:	1100068b 	ldhu	r4,26(r2)
81114924:	00a04574 	movhi	r2,33045
81114928:	1091d904 	addi	r2,r2,18276
8111492c:	18c00284 	addi	r3,r3,10
81114930:	18c7883a 	add	r3,r3,r3
81114934:	10c5883a 	add	r2,r2,r3
81114938:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111493c:	00a04574 	movhi	r2,33045
81114940:	1091d904 	addi	r2,r2,18276
81114944:	10800483 	ldbu	r2,18(r2)
81114948:	10800044 	addi	r2,r2,1
8111494c:	1007883a 	mov	r3,r2
81114950:	00a04574 	movhi	r2,33045
81114954:	1091d904 	addi	r2,r2,18276
81114958:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8111495c:	00a04574 	movhi	r2,33045
81114960:	1091d904 	addi	r2,r2,18276
81114964:	10800483 	ldbu	r2,18(r2)
81114968:	10c03fcc 	andi	r3,r2,255
8111496c:	00a04574 	movhi	r2,33045
81114970:	1091c604 	addi	r2,r2,18200
81114974:	1100070b 	ldhu	r4,28(r2)
81114978:	00a04574 	movhi	r2,33045
8111497c:	1091d904 	addi	r2,r2,18276
81114980:	18c00284 	addi	r3,r3,10
81114984:	18c7883a 	add	r3,r3,r3
81114988:	10c5883a 	add	r2,r2,r3
8111498c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114990:	00a04574 	movhi	r2,33045
81114994:	1091d904 	addi	r2,r2,18276
81114998:	10800483 	ldbu	r2,18(r2)
8111499c:	10800044 	addi	r2,r2,1
811149a0:	1007883a 	mov	r3,r2
811149a4:	00a04574 	movhi	r2,33045
811149a8:	1091d904 	addi	r2,r2,18276
811149ac:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
811149b0:	00a04574 	movhi	r2,33045
811149b4:	1091d904 	addi	r2,r2,18276
811149b8:	10800483 	ldbu	r2,18(r2)
811149bc:	10c03fcc 	andi	r3,r2,255
811149c0:	00a04574 	movhi	r2,33045
811149c4:	1091c604 	addi	r2,r2,18200
811149c8:	1100078b 	ldhu	r4,30(r2)
811149cc:	00a04574 	movhi	r2,33045
811149d0:	1091d904 	addi	r2,r2,18276
811149d4:	18c00284 	addi	r3,r3,10
811149d8:	18c7883a 	add	r3,r3,r3
811149dc:	10c5883a 	add	r2,r2,r3
811149e0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811149e4:	00a04574 	movhi	r2,33045
811149e8:	1091d904 	addi	r2,r2,18276
811149ec:	10800483 	ldbu	r2,18(r2)
811149f0:	10800044 	addi	r2,r2,1
811149f4:	1007883a 	mov	r3,r2
811149f8:	00a04574 	movhi	r2,33045
811149fc:	1091d904 	addi	r2,r2,18276
81114a00:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81114a04:	00a04574 	movhi	r2,33045
81114a08:	1091d904 	addi	r2,r2,18276
81114a0c:	10800483 	ldbu	r2,18(r2)
81114a10:	10c03fcc 	andi	r3,r2,255
81114a14:	00a04574 	movhi	r2,33045
81114a18:	1091c604 	addi	r2,r2,18200
81114a1c:	1100080b 	ldhu	r4,32(r2)
81114a20:	00a04574 	movhi	r2,33045
81114a24:	1091d904 	addi	r2,r2,18276
81114a28:	18c00284 	addi	r3,r3,10
81114a2c:	18c7883a 	add	r3,r3,r3
81114a30:	10c5883a 	add	r2,r2,r3
81114a34:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114a38:	00a04574 	movhi	r2,33045
81114a3c:	1091d904 	addi	r2,r2,18276
81114a40:	10800483 	ldbu	r2,18(r2)
81114a44:	10800044 	addi	r2,r2,1
81114a48:	1007883a 	mov	r3,r2
81114a4c:	00a04574 	movhi	r2,33045
81114a50:	1091d904 	addi	r2,r2,18276
81114a54:	10c00485 	stb	r3,18(r2)


								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114a58:	00a045f4 	movhi	r2,33047
81114a5c:	10a00404 	addi	r2,r2,-32752
81114a60:	10800e8b 	ldhu	r2,58(r2)
81114a64:	10bfffcc 	andi	r2,r2,65535
81114a68:	108000e8 	cmpgeui	r2,r2,3
81114a6c:	1000a11e 	bne	r2,zero,81114cf4 <vParserCommTask+0xf94>
									memset(cPUSDebug,0,128);
81114a70:	e0bfdec4 	addi	r2,fp,-133
81114a74:	01802004 	movi	r6,128
81114a78:	000b883a 	mov	r5,zero
81114a7c:	1009883a 	mov	r4,r2
81114a80:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81114a84:	e0ffdec4 	addi	r3,fp,-133
81114a88:	00a04574 	movhi	r2,33045
81114a8c:	10bbc704 	addi	r2,r2,-4324
81114a90:	1009883a 	mov	r4,r2
81114a94:	00800b84 	movi	r2,46
81114a98:	100d883a 	mov	r6,r2
81114a9c:	200b883a 	mov	r5,r4
81114aa0:	1809883a 	mov	r4,r3
81114aa4:	1123a440 	call	81123a44 <memcpy>
									debug(fp, cPUSDebug );
81114aa8:	d0a06217 	ldw	r2,-32376(gp)
81114aac:	e0ffdec4 	addi	r3,fp,-133
81114ab0:	180b883a 	mov	r5,r3
81114ab4:	1009883a 	mov	r4,r2
81114ab8:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81114abc:	e0ffde0b 	ldhu	r3,-136(fp)
81114ac0:	e0bfdec4 	addi	r2,fp,-133
81114ac4:	180d883a 	mov	r6,r3
81114ac8:	01604574 	movhi	r5,33045
81114acc:	297bd304 	addi	r5,r5,-4276
81114ad0:	1009883a 	mov	r4,r2
81114ad4:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114ad8:	d0a06217 	ldw	r2,-32376(gp)
81114adc:	e0ffdec4 	addi	r3,fp,-133
81114ae0:	180b883a 	mov	r5,r3
81114ae4:	1009883a 	mov	r4,r2
81114ae8:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81114aec:	00a04574 	movhi	r2,33045
81114af0:	1091c604 	addi	r2,r2,18200
81114af4:	1080058b 	ldhu	r2,22(r2)
81114af8:	10ffffcc 	andi	r3,r2,65535
81114afc:	e0bfdec4 	addi	r2,fp,-133
81114b00:	180d883a 	mov	r6,r3
81114b04:	01604574 	movhi	r5,33045
81114b08:	297bda04 	addi	r5,r5,-4248
81114b0c:	1009883a 	mov	r4,r2
81114b10:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114b14:	d0a06217 	ldw	r2,-32376(gp)
81114b18:	e0ffdec4 	addi	r3,fp,-133
81114b1c:	180b883a 	mov	r5,r3
81114b20:	1009883a 	mov	r4,r2
81114b24:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81114b28:	00a04574 	movhi	r2,33045
81114b2c:	1091c604 	addi	r2,r2,18200
81114b30:	1080060b 	ldhu	r2,24(r2)
81114b34:	10ffffcc 	andi	r3,r2,65535
81114b38:	e0bfdec4 	addi	r2,fp,-133
81114b3c:	180d883a 	mov	r6,r3
81114b40:	01604574 	movhi	r5,33045
81114b44:	297bde04 	addi	r5,r5,-4232
81114b48:	1009883a 	mov	r4,r2
81114b4c:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114b50:	d0a06217 	ldw	r2,-32376(gp)
81114b54:	e0ffdec4 	addi	r3,fp,-133
81114b58:	180b883a 	mov	r5,r3
81114b5c:	1009883a 	mov	r4,r2
81114b60:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81114b64:	00a04574 	movhi	r2,33045
81114b68:	1091c604 	addi	r2,r2,18200
81114b6c:	1080068b 	ldhu	r2,26(r2)
81114b70:	10ffffcc 	andi	r3,r2,65535
81114b74:	e0bfdec4 	addi	r2,fp,-133
81114b78:	180d883a 	mov	r6,r3
81114b7c:	01604574 	movhi	r5,33045
81114b80:	297be304 	addi	r5,r5,-4212
81114b84:	1009883a 	mov	r4,r2
81114b88:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114b8c:	d0a06217 	ldw	r2,-32376(gp)
81114b90:	e0ffdec4 	addi	r3,fp,-133
81114b94:	180b883a 	mov	r5,r3
81114b98:	1009883a 	mov	r4,r2
81114b9c:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81114ba0:	00a04574 	movhi	r2,33045
81114ba4:	1091c604 	addi	r2,r2,18200
81114ba8:	1080070b 	ldhu	r2,28(r2)
81114bac:	10ffffcc 	andi	r3,r2,65535
81114bb0:	e0bfdec4 	addi	r2,fp,-133
81114bb4:	180d883a 	mov	r6,r3
81114bb8:	01604574 	movhi	r5,33045
81114bbc:	297bea04 	addi	r5,r5,-4184
81114bc0:	1009883a 	mov	r4,r2
81114bc4:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114bc8:	d0a06217 	ldw	r2,-32376(gp)
81114bcc:	e0ffdec4 	addi	r3,fp,-133
81114bd0:	180b883a 	mov	r5,r3
81114bd4:	1009883a 	mov	r4,r2
81114bd8:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81114bdc:	00a04574 	movhi	r2,33045
81114be0:	1091c604 	addi	r2,r2,18200
81114be4:	1080078b 	ldhu	r2,30(r2)
81114be8:	10ffffcc 	andi	r3,r2,65535
81114bec:	e0bfdec4 	addi	r2,fp,-133
81114bf0:	180d883a 	mov	r6,r3
81114bf4:	01604574 	movhi	r5,33045
81114bf8:	297bf104 	addi	r5,r5,-4156
81114bfc:	1009883a 	mov	r4,r2
81114c00:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114c04:	d0a06217 	ldw	r2,-32376(gp)
81114c08:	e0ffdec4 	addi	r3,fp,-133
81114c0c:	180b883a 	mov	r5,r3
81114c10:	1009883a 	mov	r4,r2
81114c14:	11229940 	call	81122994 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81114c18:	00a04574 	movhi	r2,33045
81114c1c:	1091c604 	addi	r2,r2,18200
81114c20:	1080080b 	ldhu	r2,32(r2)
81114c24:	10ffffcc 	andi	r3,r2,65535
81114c28:	e0bfdec4 	addi	r2,fp,-133
81114c2c:	180d883a 	mov	r6,r3
81114c30:	01604574 	movhi	r5,33045
81114c34:	297bf704 	addi	r5,r5,-4132
81114c38:	1009883a 	mov	r4,r2
81114c3c:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114c40:	d0a06217 	ldw	r2,-32376(gp)
81114c44:	e0ffdec4 	addi	r3,fp,-133
81114c48:	180b883a 	mov	r5,r3
81114c4c:	1009883a 	mov	r4,r2
81114c50:	11229940 	call	81122994 <fprintf>
								}
								#endif

								break;
81114c54:	00002706 	br	81114cf4 <vParserCommTask+0xf94>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114c58:	00a045f4 	movhi	r2,33047
81114c5c:	10a00404 	addi	r2,r2,-32752
81114c60:	10800e8b 	ldhu	r2,58(r2)
81114c64:	10bfffcc 	andi	r2,r2,65535
81114c68:	108000e8 	cmpgeui	r2,r2,3
81114c6c:	10001e1e 	bne	r2,zero,81114ce8 <vParserCommTask+0xf88>
									memset(cPUSDebug,0,128);
81114c70:	e0bfdec4 	addi	r2,fp,-133
81114c74:	01802004 	movi	r6,128
81114c78:	000b883a 	mov	r5,zero
81114c7c:	1009883a 	mov	r4,r2
81114c80:	1123b940 	call	81123b94 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114c84:	00a04574 	movhi	r2,33045
81114c88:	1091d904 	addi	r2,r2,18276
81114c8c:	1080030b 	ldhu	r2,12(r2)
81114c90:	113fffcc 	andi	r4,r2,65535
81114c94:	00a04574 	movhi	r2,33045
81114c98:	1091d904 	addi	r2,r2,18276
81114c9c:	1080038b 	ldhu	r2,14(r2)
81114ca0:	117fffcc 	andi	r5,r2,65535
81114ca4:	00a04574 	movhi	r2,33045
81114ca8:	1091d904 	addi	r2,r2,18276
81114cac:	1080040b 	ldhu	r2,16(r2)
81114cb0:	10bfffcc 	andi	r2,r2,65535
81114cb4:	e0ffdec4 	addi	r3,fp,-133
81114cb8:	d8800015 	stw	r2,0(sp)
81114cbc:	280f883a 	mov	r7,r5
81114cc0:	200d883a 	mov	r6,r4
81114cc4:	01604574 	movhi	r5,33045
81114cc8:	297b2604 	addi	r5,r5,-4968
81114ccc:	1809883a 	mov	r4,r3
81114cd0:	11242a80 	call	811242a8 <sprintf>
									debug(fp, cPUSDebug );
81114cd4:	d0a06217 	ldw	r2,-32376(gp)
81114cd8:	e0ffdec4 	addi	r3,fp,-133
81114cdc:	180b883a 	mov	r5,r3
81114ce0:	1009883a 	mov	r4,r2
81114ce4:	11229940 	call	81122994 <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
81114ce8:	00800044 	movi	r2,1
81114cec:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114cf0:	00000106 	br	81114cf8 <vParserCommTask+0xf98>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
									debug(fp, cPUSDebug );
								}
								#endif

								break;
81114cf4:	0001883a 	nop
								}
								#endif							
								eParserMode = sWaitingMessage;
								break;
						}
                        break;
81114cf8:	00000406 	br	81114d0c <vParserCommTask+0xfac>
                    default:
						eParserMode = sWaitingMessage;
81114cfc:	00800044 	movi	r2,1
81114d00:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81114d04:	00000106 	br	81114d0c <vParserCommTask+0xfac>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81114d08:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;				
81114d0c:	00000306 	br	81114d1c <vParserCommTask+0xfbc>
			default:
				eParserMode = sWaitingMessage;
81114d10:	00800044 	movi	r2,1
81114d14:	e0bfdc15 	stw	r2,-144(fp)
				break;
81114d18:	0001883a 	nop
		}
	}
81114d1c:	003c2606 	br	81113db8 <__reset+0xfb0f3db8>

81114d20 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81114d20:	defffb04 	addi	sp,sp,-20
81114d24:	de00012e 	bgeu	sp,et,81114d2c <getPreParsedPacket+0xc>
81114d28:	003b68fa 	trap	3
81114d2c:	dfc00415 	stw	ra,16(sp)
81114d30:	df000315 	stw	fp,12(sp)
81114d34:	df000304 	addi	fp,sp,12
81114d38:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114d3c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81114d40:	d0a06b17 	ldw	r2,-32340(gp)
81114d44:	e0fffe44 	addi	r3,fp,-7
81114d48:	180d883a 	mov	r6,r3
81114d4c:	000b883a 	mov	r5,zero
81114d50:	1009883a 	mov	r4,r2
81114d54:	113de280 	call	8113de28 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81114d58:	e0bffe43 	ldbu	r2,-7(fp)
81114d5c:	10803fcc 	andi	r2,r2,255
81114d60:	10002e1e 	bne	r2,zero,81114e1c <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81114d64:	e03ffe05 	stb	zero,-8(fp)
81114d68:	00002506 	br	81114e00 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81114d6c:	e0fffe03 	ldbu	r3,-8(fp)
81114d70:	00a045b4 	movhi	r2,33046
81114d74:	109f5c04 	addi	r2,r2,32112
81114d78:	18c01324 	muli	r3,r3,76
81114d7c:	10c5883a 	add	r2,r2,r3
81114d80:	10800104 	addi	r2,r2,4
81114d84:	10800003 	ldbu	r2,0(r2)
81114d88:	10803fcc 	andi	r2,r2,255
81114d8c:	1080201c 	xori	r2,r2,128
81114d90:	10bfe004 	addi	r2,r2,-128
81114d94:	10001726 	beq	r2,zero,81114df4 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81114d98:	e0fffe03 	ldbu	r3,-8(fp)
81114d9c:	e13fff17 	ldw	r4,-4(fp)
81114da0:	00a045b4 	movhi	r2,33046
81114da4:	109f5c04 	addi	r2,r2,32112
81114da8:	18c01324 	muli	r3,r3,76
81114dac:	10c5883a 	add	r2,r2,r3
81114db0:	2007883a 	mov	r3,r4
81114db4:	1009883a 	mov	r4,r2
81114db8:	00801304 	movi	r2,76
81114dbc:	100d883a 	mov	r6,r2
81114dc0:	200b883a 	mov	r5,r4
81114dc4:	1809883a 	mov	r4,r3
81114dc8:	1123a440 	call	81123a44 <memcpy>
                bSuccess = TRUE;
81114dcc:	00800044 	movi	r2,1
81114dd0:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81114dd4:	e0fffe03 	ldbu	r3,-8(fp)
81114dd8:	00a045b4 	movhi	r2,33046
81114ddc:	109f5c04 	addi	r2,r2,32112
81114de0:	18c01324 	muli	r3,r3,76
81114de4:	10c5883a 	add	r2,r2,r3
81114de8:	10800104 	addi	r2,r2,4
81114dec:	10000005 	stb	zero,0(r2)
                break;
81114df0:	00000606 	br	81114e0c <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81114df4:	e0bffe03 	ldbu	r2,-8(fp)
81114df8:	10800044 	addi	r2,r2,1
81114dfc:	e0bffe05 	stb	r2,-8(fp)
81114e00:	e0bffe03 	ldbu	r2,-8(fp)
81114e04:	10800230 	cmpltui	r2,r2,8
81114e08:	103fd81e 	bne	r2,zero,81114d6c <__reset+0xfb0f4d6c>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81114e0c:	d0a06b17 	ldw	r2,-32340(gp)
81114e10:	1009883a 	mov	r4,r2
81114e14:	113e3cc0 	call	8113e3cc <OSMutexPost>
81114e18:	00000106 	br	81114e20 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81114e1c:	111d1080 	call	8111d108 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81114e20:	e0bffd17 	ldw	r2,-12(fp)
}
81114e24:	e037883a 	mov	sp,fp
81114e28:	dfc00117 	ldw	ra,4(sp)
81114e2c:	df000017 	ldw	fp,0(sp)
81114e30:	dec00204 	addi	sp,sp,8
81114e34:	f800283a 	ret

81114e38 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81114e38:	defffa04 	addi	sp,sp,-24
81114e3c:	de00012e 	bgeu	sp,et,81114e44 <bSendMessagePUStoMebTask+0xc>
81114e40:	003b68fa 	trap	3
81114e44:	dfc00515 	stw	ra,20(sp)
81114e48:	df000415 	stw	fp,16(sp)
81114e4c:	df000404 	addi	fp,sp,16
81114e50:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114e54:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81114e58:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81114e5c:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81114e60:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81114e64:	d0a07317 	ldw	r2,-32308(gp)
81114e68:	e0fffd44 	addi	r3,fp,-11
81114e6c:	180d883a 	mov	r6,r3
81114e70:	01400284 	movi	r5,10
81114e74:	1009883a 	mov	r4,r2
81114e78:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114e7c:	e0bffd43 	ldbu	r2,-11(fp)
81114e80:	10803fcc 	andi	r2,r2,255
81114e84:	1000401e 	bne	r2,zero,81114f88 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81114e88:	e03ffd05 	stb	zero,-12(fp)
81114e8c:	00003806 	br	81114f70 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81114e90:	e0fffd03 	ldbu	r3,-12(fp)
81114e94:	00a04574 	movhi	r2,33045
81114e98:	109c7e04 	addi	r2,r2,29176
81114e9c:	18c01524 	muli	r3,r3,84
81114ea0:	10c5883a 	add	r2,r2,r3
81114ea4:	10800104 	addi	r2,r2,4
81114ea8:	10800017 	ldw	r2,0(r2)
81114eac:	10002d1e 	bne	r2,zero,81114f64 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81114eb0:	e0fffd03 	ldbu	r3,-12(fp)
81114eb4:	00a04574 	movhi	r2,33045
81114eb8:	109c7e04 	addi	r2,r2,29176
81114ebc:	18c01524 	muli	r3,r3,84
81114ec0:	10c7883a 	add	r3,r2,r3
81114ec4:	e0bfff17 	ldw	r2,-4(fp)
81114ec8:	1009883a 	mov	r4,r2
81114ecc:	00801504 	movi	r2,84
81114ed0:	100d883a 	mov	r6,r2
81114ed4:	200b883a 	mov	r5,r4
81114ed8:	1809883a 	mov	r4,r3
81114edc:	1123a440 	call	81123a44 <memcpy>
            	xPus[i].bInUse = TRUE;
81114ee0:	e0fffd03 	ldbu	r3,-12(fp)
81114ee4:	00a04574 	movhi	r2,33045
81114ee8:	109c7e04 	addi	r2,r2,29176
81114eec:	18c01524 	muli	r3,r3,84
81114ef0:	10c5883a 	add	r2,r2,r3
81114ef4:	10800104 	addi	r2,r2,4
81114ef8:	00c00044 	movi	r3,1
81114efc:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81114f00:	00800044 	movi	r2,1
81114f04:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81114f08:	00800044 	movi	r2,1
81114f0c:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81114f10:	d0a06917 	ldw	r2,-32348(gp)
81114f14:	e0fffe17 	ldw	r3,-8(fp)
81114f18:	180b883a 	mov	r5,r3
81114f1c:	1009883a 	mov	r4,r2
81114f20:	113f3440 	call	8113f344 <OSQPost>
81114f24:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81114f28:	e0bffd43 	ldbu	r2,-11(fp)
81114f2c:	10803fcc 	andi	r2,r2,255
81114f30:	10000926 	beq	r2,zero,81114f58 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81114f34:	111e3880 	call	8111e388 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81114f38:	e0fffd03 	ldbu	r3,-12(fp)
81114f3c:	00a04574 	movhi	r2,33045
81114f40:	109c7e04 	addi	r2,r2,29176
81114f44:	18c01524 	muli	r3,r3,84
81114f48:	10c5883a 	add	r2,r2,r3
81114f4c:	10800104 	addi	r2,r2,4
81114f50:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114f54:	00000906 	br	81114f7c <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81114f58:	00800044 	movi	r2,1
81114f5c:	e0bffc15 	stw	r2,-16(fp)
                break;
81114f60:	00000606 	br	81114f7c <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81114f64:	e0bffd03 	ldbu	r2,-12(fp)
81114f68:	10800044 	addi	r2,r2,1
81114f6c:	e0bffd05 	stb	r2,-12(fp)
81114f70:	e0bffd03 	ldbu	r2,-12(fp)
81114f74:	10800130 	cmpltui	r2,r2,4
81114f78:	103fc51e 	bne	r2,zero,81114e90 <__reset+0xfb0f4e90>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81114f7c:	d0a07317 	ldw	r2,-32308(gp)
81114f80:	1009883a 	mov	r4,r2
81114f84:	113e3cc0 	call	8113e3cc <OSMutexPost>
    }

    return bSuccess;
81114f88:	e0bffc17 	ldw	r2,-16(fp)
}
81114f8c:	e037883a 	mov	sp,fp
81114f90:	dfc00117 	ldw	ra,4(sp)
81114f94:	df000017 	ldw	fp,0(sp)
81114f98:	dec00204 	addi	sp,sp,8
81114f9c:	f800283a 	ret

81114fa0 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81114fa0:	deffab04 	addi	sp,sp,-340
81114fa4:	de00012e 	bgeu	sp,et,81114fac <vReceiverUartTask+0xc>
81114fa8:	003b68fa 	trap	3
81114fac:	dfc05415 	stw	ra,336(sp)
81114fb0:	df005315 	stw	fp,332(sp)
81114fb4:	df005304 	addi	fp,sp,332
81114fb8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114fbc:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81114fc0:	00a045f4 	movhi	r2,33047
81114fc4:	10a00404 	addi	r2,r2,-32752
81114fc8:	10800e8b 	ldhu	r2,58(r2)
81114fcc:	10bfffcc 	andi	r2,r2,65535
81114fd0:	10800168 	cmpgeui	r2,r2,5
81114fd4:	1000071e 	bne	r2,zero,81114ff4 <vReceiverUartTask+0x54>
        debug(fp,"Receiver UART Task. (Task on)\n");
81114fd8:	d0a06217 	ldw	r2,-32376(gp)
81114fdc:	100f883a 	mov	r7,r2
81114fe0:	01800784 	movi	r6,30
81114fe4:	01400044 	movi	r5,1
81114fe8:	01204574 	movhi	r4,33045
81114fec:	213bfd04 	addi	r4,r4,-4108
81114ff0:	11230300 	call	81123030 <fwrite>
    }
    #endif

    eReaderRXMode = sRConfiguring;
81114ff4:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81114ff8:	e0bfad17 	ldw	r2,-332(fp)
81114ffc:	10c00060 	cmpeqi	r3,r2,1
81115000:	1800091e 	bne	r3,zero,81115028 <vReceiverUartTask+0x88>
81115004:	0080052e 	bgeu	zero,r2,8111501c <vReceiverUartTask+0x7c>
81115008:	10c000a0 	cmpeqi	r3,r2,2
8111500c:	1800631e 	bne	r3,zero,8111519c <vReceiverUartTask+0x1fc>
81115010:	108000e0 	cmpeqi	r2,r2,3
81115014:	1000741e 	bne	r2,zero,811151e8 <vReceiverUartTask+0x248>
81115018:	00007d06 	br	81115210 <vReceiverUartTask+0x270>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8111501c:	00800044 	movi	r2,1
81115020:	e0bfad15 	stw	r2,-332(fp)
                break;
81115024:	00007e06 	br	81115220 <vReceiverUartTask+0x280>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81115028:	e0bfaf04 	addi	r2,fp,-324
8111502c:	01802004 	movi	r6,128
81115030:	000b883a 	mov	r5,zero
81115034:	1009883a 	mov	r4,r2
81115038:	1123b940 	call	81123b94 <memset>
                scanf("%s", cReceive);
8111503c:	e0bfcf04 	addi	r2,fp,-196
81115040:	100b883a 	mov	r5,r2
81115044:	01204574 	movhi	r4,33045
81115048:	213c0504 	addi	r4,r4,-4076
8111504c:	11241cc0 	call	811241cc <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81115050:	e0ffcf04 	addi	r3,fp,-196
81115054:	e0bfaf04 	addi	r2,fp,-324
81115058:	01801fc4 	movi	r6,127
8111505c:	180b883a 	mov	r5,r3
81115060:	1009883a 	mov	r4,r2
81115064:	1123a440 	call	81123a44 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81115068:	e0bfaf04 	addi	r2,fp,-324
8111506c:	01604574 	movhi	r5,33045
81115070:	2951ee04 	addi	r5,r5,18360
81115074:	1009883a 	mov	r4,r2
81115078:	11156900 	call	81115690 <bPreParserV2>
8111507c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81115080:	e0bfae17 	ldw	r2,-328(fp)
81115084:	10800058 	cmpnei	r2,r2,1
81115088:	10002e1e 	bne	r2,zero,81115144 <vReceiverUartTask+0x1a4>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8111508c:	00a04574 	movhi	r2,33045
81115090:	1091ee04 	addi	r2,r2,18360
81115094:	10800103 	ldbu	r2,4(r2)
81115098:	10803fcc 	andi	r2,r2,255
8111509c:	1080201c 	xori	r2,r2,128
811150a0:	10bfe004 	addi	r2,r2,-128
811150a4:	10800fe0 	cmpeqi	r2,r2,63
811150a8:	1000081e 	bne	r2,zero,811150cc <vReceiverUartTask+0x12c>
811150ac:	00a04574 	movhi	r2,33045
811150b0:	1091ee04 	addi	r2,r2,18360
811150b4:	10800103 	ldbu	r2,4(r2)
811150b8:	10803fcc 	andi	r2,r2,255
811150bc:	1080201c 	xori	r2,r2,128
811150c0:	10bfe004 	addi	r2,r2,-128
811150c4:	10800858 	cmpnei	r2,r2,33
811150c8:	1000031e 	bne	r2,zero,811150d8 <vReceiverUartTask+0x138>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
811150cc:	00800084 	movi	r2,2
811150d0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811150d4:	00005106 	br	8111521c <vReceiverUartTask+0x27c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
811150d8:	00a04574 	movhi	r2,33045
811150dc:	1091ee04 	addi	r2,r2,18360
811150e0:	10800103 	ldbu	r2,4(r2)
811150e4:	10803fcc 	andi	r2,r2,255
811150e8:	1080201c 	xori	r2,r2,128
811150ec:	10bfe004 	addi	r2,r2,-128
811150f0:	108008d8 	cmpnei	r2,r2,35
811150f4:	1000101e 	bne	r2,zero,81115138 <vReceiverUartTask+0x198>
                            eReaderRXMode = sGetRxUart;
811150f8:	00800044 	movi	r2,1
811150fc:	e0bfad15 	stw	r2,-332(fp)
                            #if DEBUG_ON
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115100:	00a045f4 	movhi	r2,33047
81115104:	10a00404 	addi	r2,r2,-32752
81115108:	10800e8b 	ldhu	r2,58(r2)
8111510c:	10bfffcc 	andi	r2,r2,65535
81115110:	108000e8 	cmpgeui	r2,r2,3
81115114:	1000411e 	bne	r2,zero,8111521c <vReceiverUartTask+0x27c>
                                debug(fp,"Nack Received. Do nothing!\n");
81115118:	d0a06217 	ldw	r2,-32376(gp)
8111511c:	100f883a 	mov	r7,r2
81115120:	018006c4 	movi	r6,27
81115124:	01400044 	movi	r5,1
81115128:	01204574 	movhi	r4,33045
8111512c:	213c0604 	addi	r4,r4,-4072
81115130:	11230300 	call	81123030 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115134:	00003906 	br	8111521c <vReceiverUartTask+0x27c>
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                                debug(fp,"Nack Received. Do nothing!\n");
                            }
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81115138:	008000c4 	movi	r2,3
8111513c:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115140:	00003606 	br	8111521c <vReceiverUartTask+0x27c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81115144:	00a04574 	movhi	r2,33045
81115148:	1091ee04 	addi	r2,r2,18360
8111514c:	00c008c4 	movi	r3,35
81115150:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81115154:	00a04574 	movhi	r2,33045
81115158:	1091ee04 	addi	r2,r2,18360
8111515c:	00c00b84 	movi	r3,46
81115160:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81115164:	00a04574 	movhi	r2,33045
81115168:	1091ee04 	addi	r2,r2,18360
8111516c:	00c00044 	movi	r3,1
81115170:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81115174:	01204574 	movhi	r4,33045
81115178:	2111ee04 	addi	r4,r4,18360
8111517c:	11153600 	call	81115360 <setPreAckSenderFreePos>
81115180:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81115184:	e0bfae17 	ldw	r2,-328(fp)
81115188:	1000011e 	bne	r2,zero,81115190 <vReceiverUartTask+0x1f0>
                        vFailSendNack();
8111518c:	111d2880 	call	8111d288 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81115190:	00800044 	movi	r2,1
81115194:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81115198:	00002006 	br	8111521c <vReceiverUartTask+0x27c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8111519c:	01204574 	movhi	r4,33045
811151a0:	2111ee04 	addi	r4,r4,18360
811151a4:	11153600 	call	81115360 <setPreAckSenderFreePos>
811151a8:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
811151ac:	e0bfae17 	ldw	r2,-328(fp)
811151b0:	10800058 	cmpnei	r2,r2,1
811151b4:	1000081e 	bne	r2,zero,811151d8 <vReceiverUartTask+0x238>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811151b8:	01204574 	movhi	r4,33045
811151bc:	2111ee04 	addi	r4,r4,18360
811151c0:	11152240 	call	81115224 <setPreParsedFreePos>
811151c4:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811151c8:	e0bfae17 	ldw	r2,-328(fp)
811151cc:	1000031e 	bne	r2,zero,811151dc <vReceiverUartTask+0x23c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811151d0:	111d3880 	call	8111d388 <vFailSetPreParsedBuffer>
811151d4:	00000106 	br	811151dc <vReceiverUartTask+0x23c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811151d8:	111d3080 	call	8111d308 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811151dc:	00800044 	movi	r2,1
811151e0:	e0bfad15 	stw	r2,-332(fp)
                break;
811151e4:	00000e06 	br	81115220 <vReceiverUartTask+0x280>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
811151e8:	01204574 	movhi	r4,33045
811151ec:	2111ee04 	addi	r4,r4,18360
811151f0:	11154dc0 	call	811154dc <setPreAckReceiverFreePos>
811151f4:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
811151f8:	e0bfae17 	ldw	r2,-328(fp)
811151fc:	1000011e 	bne	r2,zero,81115204 <vReceiverUartTask+0x264>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81115200:	111d4080 	call	8111d408 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81115204:	00800044 	movi	r2,1
81115208:	e0bfad15 	stw	r2,-332(fp)
                break;
8111520c:	00000406 	br	81115220 <vReceiverUartTask+0x280>
            default:
                eReaderRXMode = sGetRxUart;
81115210:	00800044 	movi	r2,1
81115214:	e0bfad15 	stw	r2,-332(fp)
                break;
81115218:	00000106 	br	81115220 <vReceiverUartTask+0x280>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8111521c:	0001883a 	nop
            default:
                eReaderRXMode = sGetRxUart;
                break;
        }

    }
81115220:	003f7506 	br	81114ff8 <__reset+0xfb0f4ff8>

81115224 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81115224:	defffb04 	addi	sp,sp,-20
81115228:	de00012e 	bgeu	sp,et,81115230 <setPreParsedFreePos+0xc>
8111522c:	003b68fa 	trap	3
81115230:	dfc00415 	stw	ra,16(sp)
81115234:	df000315 	stw	fp,12(sp)
81115238:	df000304 	addi	fp,sp,12
8111523c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115240:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115244:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115248:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8111524c:	d0a06b17 	ldw	r2,-32340(gp)
81115250:	e0fffe44 	addi	r3,fp,-7
81115254:	180d883a 	mov	r6,r3
81115258:	01400284 	movi	r5,10
8111525c:	1009883a 	mov	r4,r2
81115260:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81115264:	e0bffe43 	ldbu	r2,-7(fp)
81115268:	10803fcc 	andi	r2,r2,255
8111526c:	1000361e 	bne	r2,zero,81115348 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115270:	e03ffe05 	stb	zero,-8(fp)
81115274:	00002e06 	br	81115330 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81115278:	e0fffe03 	ldbu	r3,-8(fp)
8111527c:	00a045b4 	movhi	r2,33046
81115280:	109f5c04 	addi	r2,r2,32112
81115284:	18c01324 	muli	r3,r3,76
81115288:	10c5883a 	add	r2,r2,r3
8111528c:	10800104 	addi	r2,r2,4
81115290:	10800003 	ldbu	r2,0(r2)
81115294:	10803fcc 	andi	r2,r2,255
81115298:	1080201c 	xori	r2,r2,128
8111529c:	10bfe004 	addi	r2,r2,-128
811152a0:	1000201e 	bne	r2,zero,81115324 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
811152a4:	e0fffe03 	ldbu	r3,-8(fp)
811152a8:	00a045b4 	movhi	r2,33046
811152ac:	109f5c04 	addi	r2,r2,32112
811152b0:	18c01324 	muli	r3,r3,76
811152b4:	10c7883a 	add	r3,r2,r3
811152b8:	e0bfff17 	ldw	r2,-4(fp)
811152bc:	1009883a 	mov	r4,r2
811152c0:	00801304 	movi	r2,76
811152c4:	100d883a 	mov	r6,r2
811152c8:	200b883a 	mov	r5,r4
811152cc:	1809883a 	mov	r4,r3
811152d0:	1123a440 	call	81123a44 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
811152d4:	d0a06417 	ldw	r2,-32368(gp)
811152d8:	1009883a 	mov	r4,r2
811152dc:	11401bc0 	call	811401bc <OSSemPost>
811152e0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811152e4:	e0bffe43 	ldbu	r2,-7(fp)
811152e8:	10803fcc 	andi	r2,r2,255
811152ec:	1000031e 	bne	r2,zero,811152fc <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
811152f0:	00800044 	movi	r2,1
811152f4:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
811152f8:	00001006 	br	8111533c <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
811152fc:	111c7680 	call	8111c768 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81115300:	e0fffe03 	ldbu	r3,-8(fp)
81115304:	00a045b4 	movhi	r2,33046
81115308:	109f5c04 	addi	r2,r2,32112
8111530c:	18c01324 	muli	r3,r3,76
81115310:	10c5883a 	add	r2,r2,r3
81115314:	10800104 	addi	r2,r2,4
81115318:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
8111531c:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81115320:	00000606 	br	8111533c <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115324:	e0bffe03 	ldbu	r2,-8(fp)
81115328:	10800044 	addi	r2,r2,1
8111532c:	e0bffe05 	stb	r2,-8(fp)
81115330:	e0bffe03 	ldbu	r2,-8(fp)
81115334:	10800230 	cmpltui	r2,r2,8
81115338:	103fcf1e 	bne	r2,zero,81115278 <__reset+0xfb0f5278>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
8111533c:	d0a06b17 	ldw	r2,-32340(gp)
81115340:	1009883a 	mov	r4,r2
81115344:	113e3cc0 	call	8113e3cc <OSMutexPost>
    }
    return bSuccess;
81115348:	e0bffd17 	ldw	r2,-12(fp)
}
8111534c:	e037883a 	mov	sp,fp
81115350:	dfc00117 	ldw	ra,4(sp)
81115354:	df000017 	ldw	fp,0(sp)
81115358:	dec00204 	addi	sp,sp,8
8111535c:	f800283a 	ret

81115360 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81115360:	defffb04 	addi	sp,sp,-20
81115364:	de00012e 	bgeu	sp,et,8111536c <setPreAckSenderFreePos+0xc>
81115368:	003b68fa 	trap	3
8111536c:	dfc00415 	stw	ra,16(sp)
81115370:	df000315 	stw	fp,12(sp)
81115374:	df000304 	addi	fp,sp,12
81115378:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111537c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115380:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115384:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81115388:	d0a07217 	ldw	r2,-32312(gp)
8111538c:	e0fffe44 	addi	r3,fp,-7
81115390:	180d883a 	mov	r6,r3
81115394:	01400284 	movi	r5,10
81115398:	1009883a 	mov	r4,r2
8111539c:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811153a0:	e0bffe43 	ldbu	r2,-7(fp)
811153a4:	10803fcc 	andi	r2,r2,255
811153a8:	1000461e 	bne	r2,zero,811154c4 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811153ac:	e03ffe05 	stb	zero,-8(fp)
811153b0:	00003e06 	br	811154ac <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
811153b4:	e0fffe03 	ldbu	r3,-8(fp)
811153b8:	00a045b4 	movhi	r2,33046
811153bc:	109f5404 	addi	r2,r2,32080
811153c0:	18c7883a 	add	r3,r3,r3
811153c4:	18c7883a 	add	r3,r3,r3
811153c8:	10c5883a 	add	r2,r2,r3
811153cc:	10800003 	ldbu	r2,0(r2)
811153d0:	10803fcc 	andi	r2,r2,255
811153d4:	1080201c 	xori	r2,r2,128
811153d8:	10bfe004 	addi	r2,r2,-128
811153dc:	1000301e 	bne	r2,zero,811154a0 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
811153e0:	e0fffe03 	ldbu	r3,-8(fp)
811153e4:	e0bfff17 	ldw	r2,-4(fp)
811153e8:	11000103 	ldbu	r4,4(r2)
811153ec:	00a045b4 	movhi	r2,33046
811153f0:	109f5404 	addi	r2,r2,32080
811153f4:	18c7883a 	add	r3,r3,r3
811153f8:	18c7883a 	add	r3,r3,r3
811153fc:	10c5883a 	add	r2,r2,r3
81115400:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81115404:	e0fffe03 	ldbu	r3,-8(fp)
81115408:	e0bfff17 	ldw	r2,-4(fp)
8111540c:	11000143 	ldbu	r4,5(r2)
81115410:	00a045b4 	movhi	r2,33046
81115414:	109f5404 	addi	r2,r2,32080
81115418:	18c7883a 	add	r3,r3,r3
8111541c:	18c7883a 	add	r3,r3,r3
81115420:	10c5883a 	add	r2,r2,r3
81115424:	10800044 	addi	r2,r2,1
81115428:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
8111542c:	e0fffe03 	ldbu	r3,-8(fp)
81115430:	e0bfff17 	ldw	r2,-4(fp)
81115434:	1100020b 	ldhu	r4,8(r2)
81115438:	00a045b4 	movhi	r2,33046
8111543c:	109f5404 	addi	r2,r2,32080
81115440:	18c7883a 	add	r3,r3,r3
81115444:	18c7883a 	add	r3,r3,r3
81115448:	10c5883a 	add	r2,r2,r3
8111544c:	10800084 	addi	r2,r2,2
81115450:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81115454:	d0a06117 	ldw	r2,-32380(gp)
81115458:	1009883a 	mov	r4,r2
8111545c:	11401bc0 	call	811401bc <OSSemPost>
81115460:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81115464:	e0bffe43 	ldbu	r2,-7(fp)
81115468:	10803fcc 	andi	r2,r2,255
8111546c:	10000926 	beq	r2,zero,81115494 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81115470:	111c8300 	call	8111c830 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81115474:	e0fffe03 	ldbu	r3,-8(fp)
81115478:	00a045b4 	movhi	r2,33046
8111547c:	109f5404 	addi	r2,r2,32080
81115480:	18c7883a 	add	r3,r3,r3
81115484:	18c7883a 	add	r3,r3,r3
81115488:	10c5883a 	add	r2,r2,r3
8111548c:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81115490:	00000906 	br	811154b8 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81115494:	00800044 	movi	r2,1
81115498:	e0bffd15 	stw	r2,-12(fp)
                break;
8111549c:	00000606 	br	811154b8 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811154a0:	e0bffe03 	ldbu	r2,-8(fp)
811154a4:	10800044 	addi	r2,r2,1
811154a8:	e0bffe05 	stb	r2,-8(fp)
811154ac:	e0bffe03 	ldbu	r2,-8(fp)
811154b0:	10800230 	cmpltui	r2,r2,8
811154b4:	103fbf1e 	bne	r2,zero,811153b4 <__reset+0xfb0f53b4>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
811154b8:	d0a07217 	ldw	r2,-32312(gp)
811154bc:	1009883a 	mov	r4,r2
811154c0:	113e3cc0 	call	8113e3cc <OSMutexPost>
    }

    return bSuccess;
811154c4:	e0bffd17 	ldw	r2,-12(fp)
}
811154c8:	e037883a 	mov	sp,fp
811154cc:	dfc00117 	ldw	ra,4(sp)
811154d0:	df000017 	ldw	fp,0(sp)
811154d4:	dec00204 	addi	sp,sp,8
811154d8:	f800283a 	ret

811154dc <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
811154dc:	defffb04 	addi	sp,sp,-20
811154e0:	de00012e 	bgeu	sp,et,811154e8 <setPreAckReceiverFreePos+0xc>
811154e4:	003b68fa 	trap	3
811154e8:	dfc00415 	stw	ra,16(sp)
811154ec:	df000315 	stw	fp,12(sp)
811154f0:	df000304 	addi	fp,sp,12
811154f4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811154f8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811154fc:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115500:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81115504:	d0a06517 	ldw	r2,-32364(gp)
81115508:	e0fffe44 	addi	r3,fp,-7
8111550c:	180d883a 	mov	r6,r3
81115510:	01400504 	movi	r5,20
81115514:	1009883a 	mov	r4,r2
81115518:	113de280 	call	8113de28 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8111551c:	e0bffe43 	ldbu	r2,-7(fp)
81115520:	10803fcc 	andi	r2,r2,255
81115524:	1000471e 	bne	r2,zero,81115644 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81115528:	e03ffe05 	stb	zero,-8(fp)
8111552c:	00003e06 	br	81115628 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81115530:	e0fffe03 	ldbu	r3,-8(fp)
81115534:	00a045b4 	movhi	r2,33046
81115538:	10894204 	addi	r2,r2,9480
8111553c:	18c7883a 	add	r3,r3,r3
81115540:	18c7883a 	add	r3,r3,r3
81115544:	10c5883a 	add	r2,r2,r3
81115548:	10800003 	ldbu	r2,0(r2)
8111554c:	10803fcc 	andi	r2,r2,255
81115550:	1080201c 	xori	r2,r2,128
81115554:	10bfe004 	addi	r2,r2,-128
81115558:	1000301e 	bne	r2,zero,8111561c <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
8111555c:	e0fffe03 	ldbu	r3,-8(fp)
81115560:	e0bfff17 	ldw	r2,-4(fp)
81115564:	11000103 	ldbu	r4,4(r2)
81115568:	00a045b4 	movhi	r2,33046
8111556c:	10894204 	addi	r2,r2,9480
81115570:	18c7883a 	add	r3,r3,r3
81115574:	18c7883a 	add	r3,r3,r3
81115578:	10c5883a 	add	r2,r2,r3
8111557c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81115580:	e0fffe03 	ldbu	r3,-8(fp)
81115584:	e0bfff17 	ldw	r2,-4(fp)
81115588:	11000143 	ldbu	r4,5(r2)
8111558c:	00a045b4 	movhi	r2,33046
81115590:	10894204 	addi	r2,r2,9480
81115594:	18c7883a 	add	r3,r3,r3
81115598:	18c7883a 	add	r3,r3,r3
8111559c:	10c5883a 	add	r2,r2,r3
811155a0:	10800044 	addi	r2,r2,1
811155a4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
811155a8:	e0fffe03 	ldbu	r3,-8(fp)
811155ac:	e0bfff17 	ldw	r2,-4(fp)
811155b0:	1100020b 	ldhu	r4,8(r2)
811155b4:	00a045b4 	movhi	r2,33046
811155b8:	10894204 	addi	r2,r2,9480
811155bc:	18c7883a 	add	r3,r3,r3
811155c0:	18c7883a 	add	r3,r3,r3
811155c4:	10c5883a 	add	r2,r2,r3
811155c8:	10800084 	addi	r2,r2,2
811155cc:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
811155d0:	d0a06617 	ldw	r2,-32360(gp)
811155d4:	1009883a 	mov	r4,r2
811155d8:	11401bc0 	call	811401bc <OSSemPost>
811155dc:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811155e0:	e0bffe43 	ldbu	r2,-7(fp)
811155e4:	10803fcc 	andi	r2,r2,255
811155e8:	1000031e 	bne	r2,zero,811155f8 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
811155ec:	00800044 	movi	r2,1
811155f0:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
811155f4:	00000f06 	br	81115634 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
811155f8:	111c7cc0 	call	8111c7cc <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
811155fc:	e0fffe03 	ldbu	r3,-8(fp)
81115600:	00a045b4 	movhi	r2,33046
81115604:	10894204 	addi	r2,r2,9480
81115608:	18c7883a 	add	r3,r3,r3
8111560c:	18c7883a 	add	r3,r3,r3
81115610:	10c5883a 	add	r2,r2,r3
81115614:	10000005 	stb	zero,0(r2)
                }
                break;
81115618:	00000606 	br	81115634 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111561c:	e0bffe03 	ldbu	r2,-8(fp)
81115620:	10800044 	addi	r2,r2,1
81115624:	e0bffe05 	stb	r2,-8(fp)
81115628:	e0bffe03 	ldbu	r2,-8(fp)
8111562c:	108001b0 	cmpltui	r2,r2,6
81115630:	103fbf1e 	bne	r2,zero,81115530 <__reset+0xfb0f5530>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81115634:	d0a06517 	ldw	r2,-32364(gp)
81115638:	1009883a 	mov	r4,r2
8111563c:	113e3cc0 	call	8113e3cc <OSMutexPost>
81115640:	00000d06 	br	81115678 <setPreAckReceiverFreePos+0x19c>
    } else {
        /* Could not  */
        #if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115644:	00a045f4 	movhi	r2,33047
81115648:	10a00404 	addi	r2,r2,-32752
8111564c:	10800e8b 	ldhu	r2,58(r2)
81115650:	10bfffcc 	andi	r2,r2,65535
81115654:	108001e8 	cmpgeui	r2,r2,7
81115658:	1000071e 	bne	r2,zero,81115678 <setPreAckReceiverFreePos+0x19c>
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8111565c:	d0a06217 	ldw	r2,-32376(gp)
81115660:	100f883a 	mov	r7,r2
81115664:	01801404 	movi	r6,80
81115668:	01400044 	movi	r5,1
8111566c:	01204574 	movhi	r4,33045
81115670:	213c0d04 	addi	r4,r4,-4044
81115674:	11230300 	call	81123030 <fwrite>
    	}
        #endif
    }

    return bSuccess;
81115678:	e0bffd17 	ldw	r2,-12(fp)
}
8111567c:	e037883a 	mov	sp,fp
81115680:	dfc00117 	ldw	ra,4(sp)
81115684:	df000017 	ldw	fp,0(sp)
81115688:	dec00204 	addi	sp,sp,8
8111568c:	f800283a 	ret

81115690 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81115690:	defff404 	addi	sp,sp,-48
81115694:	de00012e 	bgeu	sp,et,8111569c <bPreParserV2+0xc>
81115698:	003b68fa 	trap	3
8111569c:	dfc00b15 	stw	ra,44(sp)
811156a0:	df000a15 	stw	fp,40(sp)
811156a4:	dc000915 	stw	r16,36(sp)
811156a8:	df000a04 	addi	fp,sp,40
811156ac:	e13ffd15 	stw	r4,-12(fp)
811156b0:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
811156b4:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
811156b8:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
811156bc:	01402004 	movi	r5,128
811156c0:	e13ffd17 	ldw	r4,-12(fp)
811156c4:	11245540 	call	81124554 <strnlen>
811156c8:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
811156cc:	01400ec4 	movi	r5,59
811156d0:	e13ffd17 	ldw	r4,-12(fp)
811156d4:	111a2940 	call	8111a294 <siPosStr>
811156d8:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
811156dc:	e0fff98f 	ldh	r3,-26(fp)
811156e0:	e0bff90f 	ldh	r2,-28(fp)
811156e4:	10bfffc4 	addi	r2,r2,-1
811156e8:	18800226 	beq	r3,r2,811156f4 <bPreParserV2+0x64>
        return bSuccess;
811156ec:	e0bff617 	ldw	r2,-40(fp)
811156f0:	0000c006 	br	811159f4 <bPreParserV2+0x364>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
811156f4:	01401f04 	movi	r5,124
811156f8:	e13ffd17 	ldw	r4,-12(fp)
811156fc:	111a2940 	call	8111a294 <siPosStr>
81115700:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81115704:	e0bffa0f 	ldh	r2,-24(fp)
81115708:	e0fff98f 	ldh	r3,-26(fp)
8111570c:	1880020e 	bge	r3,r2,81115718 <bPreParserV2+0x88>
        return bSuccess;
81115710:	e0bff617 	ldw	r2,-40(fp)
81115714:	0000b706 	br	811159f4 <bPreParserV2+0x364>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81115718:	01604574 	movhi	r5,33045
8111571c:	297c2204 	addi	r5,r5,-3960
81115720:	e13ffd17 	ldw	r4,-12(fp)
81115724:	11244700 	call	81124470 <strcspn>
81115728:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8111572c:	e0bffa8f 	ldh	r2,-22(fp)
81115730:	e0fffa0f 	ldh	r3,-24(fp)
81115734:	1880020e 	bge	r3,r2,81115740 <bPreParserV2+0xb0>
        return bSuccess;
81115738:	e0bff617 	ldw	r2,-40(fp)
8111573c:	0000ad06 	br	811159f4 <bPreParserV2+0x364>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81115740:	e0bffa8f 	ldh	r2,-22(fp)
81115744:	e0fffd17 	ldw	r3,-12(fp)
81115748:	1885883a 	add	r2,r3,r2
8111574c:	10c00003 	ldbu	r3,0(r2)
81115750:	e0bffe17 	ldw	r2,-8(fp)
81115754:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81115758:	e0bffe17 	ldw	r2,-8(fp)
8111575c:	10800103 	ldbu	r2,4(r2)
81115760:	10803fcc 	andi	r2,r2,255
81115764:	1080201c 	xori	r2,r2,128
81115768:	10bfe004 	addi	r2,r2,-128
8111576c:	108008d8 	cmpnei	r2,r2,35
81115770:	1000041e 	bne	r2,zero,81115784 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81115774:	00800044 	movi	r2,1
81115778:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8111577c:	e0bff617 	ldw	r2,-40(fp)
81115780:	00009c06 	br	811159f4 <bPreParserV2+0x364>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81115784:	e0bffa8f 	ldh	r2,-22(fp)
81115788:	e0fffd17 	ldw	r3,-12(fp)
8111578c:	1889883a 	add	r4,r3,r2
81115790:	e0fffa0f 	ldh	r3,-24(fp)
81115794:	e0bffa8f 	ldh	r2,-22(fp)
81115798:	1885c83a 	sub	r2,r3,r2
8111579c:	100b883a 	mov	r5,r2
811157a0:	111c3980 	call	8111c398 <ucCrc8wInit>
811157a4:	1007883a 	mov	r3,r2
811157a8:	e0bffe17 	ldw	r2,-8(fp)
811157ac:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
811157b0:	e0bffa8f 	ldh	r2,-22(fp)
811157b4:	10800044 	addi	r2,r2,1
811157b8:	e0fffd17 	ldw	r3,-12(fp)
811157bc:	1885883a 	add	r2,r3,r2
811157c0:	10c00003 	ldbu	r3,0(r2)
811157c4:	e0bffe17 	ldw	r2,-8(fp)
811157c8:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
811157cc:	e0bffe17 	ldw	r2,-8(fp)
811157d0:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
811157d4:	e0bffe17 	ldw	r2,-8(fp)
811157d8:	10800204 	addi	r2,r2,8
811157dc:	01801004 	movi	r6,64
811157e0:	000b883a 	mov	r5,zero
811157e4:	1009883a 	mov	r4,r2
811157e8:	1123b940 	call	81123b94 <memset>

    i = siIni + 3; /* "?C:i..." */
811157ec:	e0bffa8b 	ldhu	r2,-22(fp)
811157f0:	108000c4 	addi	r2,r2,3
811157f4:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
811157f8:	e0bffb44 	addi	r2,fp,-19
811157fc:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81115800:	e0bffb44 	addi	r2,fp,-19
81115804:	01800184 	movi	r6,6
81115808:	000b883a 	mov	r5,zero
8111580c:	1009883a 	mov	r4,r2
81115810:	1123b940 	call	81123b94 <memset>
        do {
            c = buffer[i];
81115814:	e0bff703 	ldbu	r2,-36(fp)
81115818:	e0fffd17 	ldw	r3,-12(fp)
8111581c:	1885883a 	add	r2,r3,r2
81115820:	10800003 	ldbu	r2,0(r2)
81115824:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81115828:	d0e00317 	ldw	r3,-32756(gp)
8111582c:	e0bffb07 	ldb	r2,-20(fp)
81115830:	10800044 	addi	r2,r2,1
81115834:	1885883a 	add	r2,r3,r2
81115838:	10800003 	ldbu	r2,0(r2)
8111583c:	10803fcc 	andi	r2,r2,255
81115840:	1080010c 	andi	r2,r2,4
81115844:	10000626 	beq	r2,zero,81115860 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81115848:	e0bff817 	ldw	r2,-32(fp)
8111584c:	e0fffb03 	ldbu	r3,-20(fp)
81115850:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81115854:	e0bff817 	ldw	r2,-32(fp)
81115858:	10800044 	addi	r2,r2,1
8111585c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81115860:	e0bff703 	ldbu	r2,-36(fp)
81115864:	10800044 	addi	r2,r2,1
81115868:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8111586c:	e0bff90f 	ldh	r2,-28(fp)
81115870:	e0fff703 	ldbu	r3,-36(fp)
81115874:	1880090e 	bge	r3,r2,8111589c <bPreParserV2+0x20c>
81115878:	e0bffb07 	ldb	r2,-20(fp)
8111587c:	10800ea0 	cmpeqi	r2,r2,58
81115880:	1000061e 	bne	r2,zero,8111589c <bPreParserV2+0x20c>
81115884:	e0bffb07 	ldb	r2,-20(fp)
81115888:	10800ee0 	cmpeqi	r2,r2,59
8111588c:	1000031e 	bne	r2,zero,8111589c <bPreParserV2+0x20c>
81115890:	e0bffb07 	ldb	r2,-20(fp)
81115894:	10801f18 	cmpnei	r2,r2,124
81115898:	103fde1e 	bne	r2,zero,81115814 <__reset+0xfb0f5814>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111589c:	e0bff817 	ldw	r2,-32(fp)
811158a0:	00c00284 	movi	r3,10
811158a4:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
811158a8:	e0bffb07 	ldb	r2,-20(fp)
811158ac:	10800ea0 	cmpeqi	r2,r2,58
811158b0:	1000031e 	bne	r2,zero,811158c0 <bPreParserV2+0x230>
811158b4:	e0bffb07 	ldb	r2,-20(fp)
811158b8:	10801f18 	cmpnei	r2,r2,124
811158bc:	10001a1e 	bne	r2,zero,81115928 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
811158c0:	e0bffe17 	ldw	r2,-8(fp)
811158c4:	10800183 	ldbu	r2,6(r2)
811158c8:	10803fcc 	andi	r2,r2,255
811158cc:	10800828 	cmpgeui	r2,r2,32
811158d0:	1000041e 	bne	r2,zero,811158e4 <bPreParserV2+0x254>
811158d4:	e0bffe17 	ldw	r2,-8(fp)
811158d8:	10800183 	ldbu	r2,6(r2)
811158dc:	14003fcc 	andi	r16,r2,255
811158e0:	00000106 	br	811158e8 <bPreParserV2+0x258>
811158e4:	04000804 	movi	r16,32
811158e8:	e0bffb44 	addi	r2,fp,-19
811158ec:	1009883a 	mov	r4,r2
811158f0:	11228380 	call	81122838 <atoi>
811158f4:	1009883a 	mov	r4,r2
811158f8:	e0fffe17 	ldw	r3,-8(fp)
811158fc:	80800104 	addi	r2,r16,4
81115900:	1085883a 	add	r2,r2,r2
81115904:	1885883a 	add	r2,r3,r2
81115908:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8111590c:	e0bffe17 	ldw	r2,-8(fp)
81115910:	10800183 	ldbu	r2,6(r2)
81115914:	10800044 	addi	r2,r2,1
81115918:	1007883a 	mov	r3,r2
8111591c:	e0bffe17 	ldw	r2,-8(fp)
81115920:	10c00185 	stb	r3,6(r2)
81115924:	00000906 	br	8111594c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81115928:	e0bffb07 	ldb	r2,-20(fp)
8111592c:	10800ed8 	cmpnei	r2,r2,59
81115930:	1000061e 	bne	r2,zero,8111594c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81115934:	e0bffb44 	addi	r2,fp,-19
81115938:	1009883a 	mov	r4,r2
8111593c:	11228380 	call	81122838 <atoi>
81115940:	1007883a 	mov	r3,r2
81115944:	e0bffe17 	ldw	r2,-8(fp)
81115948:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8111594c:	e0bffb07 	ldb	r2,-20(fp)
81115950:	10800ee0 	cmpeqi	r2,r2,59
81115954:	1000031e 	bne	r2,zero,81115964 <bPreParserV2+0x2d4>
81115958:	e0bff90f 	ldh	r2,-28(fp)
8111595c:	e0fff703 	ldbu	r3,-36(fp)
81115960:	18bfa516 	blt	r3,r2,811157f8 <__reset+0xfb0f57f8>


    if ( c == FINAL_CHAR )
81115964:	e0bffb07 	ldb	r2,-20(fp)
81115968:	10800ed8 	cmpnei	r2,r2,59
8111596c:	10001f1e 	bne	r2,zero,811159ec <bPreParserV2+0x35c>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81115970:	e0bffe17 	ldw	r2,-8(fp)
81115974:	10c01243 	ldbu	r3,73(r2)
81115978:	e0bffe17 	ldw	r2,-8(fp)
8111597c:	10801203 	ldbu	r2,72(r2)
81115980:	18c03fcc 	andi	r3,r3,255
81115984:	10803fcc 	andi	r2,r2,255
81115988:	1880031e 	bne	r3,r2,81115998 <bPreParserV2+0x308>
            bSuccess = TRUE;
8111598c:	00800044 	movi	r2,1
81115990:	e0bff615 	stw	r2,-40(fp)
81115994:	00001606 	br	811159f0 <bPreParserV2+0x360>
        } else {
            /* Wrong CRC */
            #if DEBUG_ON
        	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115998:	00a045f4 	movhi	r2,33047
8111599c:	10a00404 	addi	r2,r2,-32752
811159a0:	10800e8b 	ldhu	r2,58(r2)
811159a4:	10bfffcc 	andi	r2,r2,65535
811159a8:	108001e8 	cmpgeui	r2,r2,7
811159ac:	10000d1e 	bne	r2,zero,811159e4 <bPreParserV2+0x354>
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
811159b0:	d0e06217 	ldw	r3,-32376(gp)
811159b4:	e0bffe17 	ldw	r2,-8(fp)
811159b8:	10801203 	ldbu	r2,72(r2)
811159bc:	11003fcc 	andi	r4,r2,255
811159c0:	e0bffe17 	ldw	r2,-8(fp)
811159c4:	10801243 	ldbu	r2,73(r2)
811159c8:	10803fcc 	andi	r2,r2,255
811159cc:	100f883a 	mov	r7,r2
811159d0:	200d883a 	mov	r6,r4
811159d4:	01604574 	movhi	r5,33045
811159d8:	297c2404 	addi	r5,r5,-3952
811159dc:	1809883a 	mov	r4,r3
811159e0:	11229940 	call	81122994 <fprintf>
        	}
            #endif
            bSuccess = FALSE;
811159e4:	e03ff615 	stw	zero,-40(fp)
811159e8:	00000106 	br	811159f0 <bPreParserV2+0x360>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
811159ec:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
811159f0:	e0bff617 	ldw	r2,-40(fp)
}
811159f4:	e6ffff04 	addi	sp,fp,-4
811159f8:	dfc00217 	ldw	ra,8(sp)
811159fc:	df000117 	ldw	fp,4(sp)
81115a00:	dc000017 	ldw	r16,0(sp)
81115a04:	dec00304 	addi	sp,sp,12
81115a08:	f800283a 	ret

81115a0c <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81115a0c:	defffb04 	addi	sp,sp,-20
81115a10:	de00012e 	bgeu	sp,et,81115a18 <vSenderComTask+0xc>
81115a14:	003b68fa 	trap	3
81115a18:	dfc00415 	stw	ra,16(sp)
81115a1c:	df000315 	stw	fp,12(sp)
81115a20:	df000304 	addi	fp,sp,12
81115a24:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81115a28:	e03ffd15 	stw	zero,-12(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115a2c:	00a045f4 	movhi	r2,33047
81115a30:	10a00404 	addi	r2,r2,-32752
81115a34:	10800e8b 	ldhu	r2,58(r2)
81115a38:	10bfffcc 	andi	r2,r2,65535
81115a3c:	10800168 	cmpgeui	r2,r2,5
81115a40:	1000071e 	bne	r2,zero,81115a60 <vSenderComTask+0x54>
        debug(fp,"Sender Comm Task. (Task on)\n");
81115a44:	d0a06217 	ldw	r2,-32376(gp)
81115a48:	100f883a 	mov	r7,r2
81115a4c:	01800704 	movi	r6,28
81115a50:	01400044 	movi	r5,1
81115a54:	01204574 	movhi	r4,33045
81115a58:	213c3004 	addi	r4,r4,-3904
81115a5c:	11230300 	call	81123030 <fwrite>
    }
    #endif

    for (;;){
        
        switch (eSenderMode)
81115a60:	e0bffd17 	ldw	r2,-12(fp)
81115a64:	10c00060 	cmpeqi	r3,r2,1
81115a68:	1800091e 	bne	r3,zero,81115a90 <vSenderComTask+0x84>
81115a6c:	0080052e 	bgeu	zero,r2,81115a84 <vSenderComTask+0x78>
81115a70:	10c000a0 	cmpeqi	r3,r2,2
81115a74:	1800651e 	bne	r3,zero,81115c0c <vSenderComTask+0x200>
81115a78:	10800160 	cmpeqi	r2,r2,5
81115a7c:	10003e1e 	bne	r2,zero,81115b78 <vSenderComTask+0x16c>
81115a80:	00005206 	br	81115bcc <vSenderComTask+0x1c0>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81115a84:	00800044 	movi	r2,1
81115a88:	e0bffd15 	stw	r2,-12(fp)
                break;
81115a8c:	00006206 	br	81115c18 <vSenderComTask+0x20c>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115a90:	00a045f4 	movhi	r2,33047
81115a94:	10a00404 	addi	r2,r2,-32752
81115a98:	10800e8b 	ldhu	r2,58(r2)
81115a9c:	10bfffcc 	andi	r2,r2,65535
81115aa0:	108000e8 	cmpgeui	r2,r2,3
81115aa4:	1000071e 	bne	r2,zero,81115ac4 <vSenderComTask+0xb8>
                    debug(fp,"Preparing the Start Sequence.\n");
81115aa8:	d0a06217 	ldw	r2,-32376(gp)
81115aac:	100f883a 	mov	r7,r2
81115ab0:	01800784 	movi	r6,30
81115ab4:	01400044 	movi	r5,1
81115ab8:	01204574 	movhi	r4,33045
81115abc:	213c3804 	addi	r4,r4,-3872
81115ac0:	11230300 	call	81123030 <fwrite>
            	}
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81115ac4:	01400044 	movi	r5,1
81115ac8:	01204574 	movhi	r4,33045
81115acc:	213c4004 	addi	r4,r4,-3840
81115ad0:	111995c0 	call	8111995c <bSendUART32v2>
81115ad4:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81115ad8:	e0bffe17 	ldw	r2,-8(fp)
81115adc:	10800058 	cmpnei	r2,r2,1
81115ae0:	1000101e 	bne	r2,zero,81115b24 <vSenderComTask+0x118>
                    eSenderMode = sDummySender;
81115ae4:	00800144 	movi	r2,5
81115ae8:	e0bffd15 	stw	r2,-12(fp)
                    #if DEBUG_ON
                    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115aec:	00a045f4 	movhi	r2,33047
81115af0:	10a00404 	addi	r2,r2,-32752
81115af4:	10800e8b 	ldhu	r2,58(r2)
81115af8:	10bfffcc 	andi	r2,r2,65535
81115afc:	108000e8 	cmpgeui	r2,r2,3
81115b00:	1000441e 	bne	r2,zero,81115c14 <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81115b04:	d0a06217 	ldw	r2,-32376(gp)
81115b08:	100f883a 	mov	r7,r2
81115b0c:	01800d44 	movi	r6,53
81115b10:	01400044 	movi	r5,1
81115b14:	01204574 	movhi	r4,33045
81115b18:	213c4304 	addi	r4,r4,-3828
81115b1c:	11230300 	call	81123030 <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81115b20:	00003c06 	br	81115c14 <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    }
                    #endif                    
                } else {
                    #if DEBUG_ON
                	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115b24:	00a045f4 	movhi	r2,33047
81115b28:	10a00404 	addi	r2,r2,-32752
81115b2c:	10800e8b 	ldhu	r2,58(r2)
81115b30:	10bfffcc 	andi	r2,r2,65535
81115b34:	108000e8 	cmpgeui	r2,r2,3
81115b38:	1000071e 	bne	r2,zero,81115b58 <vSenderComTask+0x14c>
                        debug(fp,"Fail, try again in 5 seconds.\n");
81115b3c:	d0a06217 	ldw	r2,-32376(gp)
81115b40:	100f883a 	mov	r7,r2
81115b44:	01800784 	movi	r6,30
81115b48:	01400044 	movi	r5,1
81115b4c:	01204574 	movhi	r4,33045
81115b50:	213c5104 	addi	r4,r4,-3772
81115b54:	11230300 	call	81123030 <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
81115b58:	00800044 	movi	r2,1
81115b5c:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81115b60:	000f883a 	mov	r7,zero
81115b64:	01800144 	movi	r6,5
81115b68:	000b883a 	mov	r5,zero
81115b6c:	0009883a 	mov	r4,zero
81115b70:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
                }
                break;
81115b74:	00002706 	br	81115c14 <vSenderComTask+0x208>
            case sReadingQueue:

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81115b78:	00800144 	movi	r2,5
81115b7c:	e0bffd15 	stw	r2,-12(fp)

                #if DEBUG_ON
                if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115b80:	00a045f4 	movhi	r2,33047
81115b84:	10a00404 	addi	r2,r2,-32752
81115b88:	10800e8b 	ldhu	r2,58(r2)
81115b8c:	10bfffcc 	andi	r2,r2,65535
81115b90:	108000e8 	cmpgeui	r2,r2,3
81115b94:	1000071e 	bne	r2,zero,81115bb4 <vSenderComTask+0x1a8>
                    debug(fp,"Working...\n");
81115b98:	d0a06217 	ldw	r2,-32376(gp)
81115b9c:	100f883a 	mov	r7,r2
81115ba0:	018002c4 	movi	r6,11
81115ba4:	01400044 	movi	r5,1
81115ba8:	01204574 	movhi	r4,33045
81115bac:	213c5904 	addi	r4,r4,-3740
81115bb0:	11230300 	call	81123030 <fwrite>
                }
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81115bb4:	000f883a 	mov	r7,zero
81115bb8:	01800644 	movi	r6,25
81115bbc:	000b883a 	mov	r5,zero
81115bc0:	0009883a 	mov	r4,zero
81115bc4:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>

                break;
81115bc8:	00001306 	br	81115c18 <vSenderComTask+0x20c>
            default:
                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115bcc:	00a045f4 	movhi	r2,33047
81115bd0:	10a00404 	addi	r2,r2,-32752
81115bd4:	10800e8b 	ldhu	r2,58(r2)
81115bd8:	10bfffcc 	andi	r2,r2,65535
81115bdc:	108001e8 	cmpgeui	r2,r2,7
81115be0:	1000071e 	bne	r2,zero,81115c00 <vSenderComTask+0x1f4>
                    debug(fp,"Sender default\n");
81115be4:	d0a06217 	ldw	r2,-32376(gp)
81115be8:	100f883a 	mov	r7,r2
81115bec:	018003c4 	movi	r6,15
81115bf0:	01400044 	movi	r5,1
81115bf4:	01204574 	movhi	r4,33045
81115bf8:	213c5c04 	addi	r4,r4,-3728
81115bfc:	11230300 	call	81123030 <fwrite>
            	}
                #endif
                eSenderMode = sDummySender;
81115c00:	00800144 	movi	r2,5
81115c04:	e0bffd15 	stw	r2,-12(fp)
                break;
81115c08:	00000306 	br	81115c18 <vSenderComTask+0x20c>
                break;


            case sReadingQueue:

                break;
81115c0c:	0001883a 	nop
81115c10:	003f9306 	br	81115a60 <__reset+0xfb0f5a60>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81115c14:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81115c18:	003f9106 	br	81115a60 <__reset+0xfb0f5a60>

81115c1c <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81115c1c:	defff804 	addi	sp,sp,-32
81115c20:	de00012e 	bgeu	sp,et,81115c28 <vSimMebTask+0xc>
81115c24:	003b68fa 	trap	3
81115c28:	dfc00715 	stw	ra,28(sp)
81115c2c:	df000615 	stw	fp,24(sp)
81115c30:	df000604 	addi	fp,sp,24
81115c34:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81115c38:	e0bfff17 	ldw	r2,-4(fp)
81115c3c:	e0bffb15 	stw	r2,-20(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115c40:	00a045f4 	movhi	r2,33047
81115c44:	10a00404 	addi	r2,r2,-32752
81115c48:	10800e8b 	ldhu	r2,58(r2)
81115c4c:	10bfffcc 	andi	r2,r2,65535
81115c50:	10800168 	cmpgeui	r2,r2,5
81115c54:	1000071e 	bne	r2,zero,81115c74 <vSimMebTask+0x58>
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81115c58:	d0a06217 	ldw	r2,-32376(gp)
81115c5c:	100f883a 	mov	r7,r2
81115c60:	018008c4 	movi	r6,35
81115c64:	01400044 	movi	r5,1
81115c68:	01204574 	movhi	r4,33045
81115c6c:	213c6004 	addi	r4,r4,-3712
81115c70:	11230300 	call	81123030 <fwrite>
	}
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81115c74:	e0bffb17 	ldw	r2,-20(fp)
81115c78:	10800117 	ldw	r2,4(r2)
81115c7c:	10c00168 	cmpgeui	r3,r2,5
81115c80:	1801301e 	bne	r3,zero,81116144 <vSimMebTask+0x528>
81115c84:	100690ba 	slli	r3,r2,2
81115c88:	00a04474 	movhi	r2,33041
81115c8c:	10972704 	addi	r2,r2,23708
81115c90:	1885883a 	add	r2,r3,r2
81115c94:	10800017 	ldw	r2,0(r2)
81115c98:	1000683a 	jmp	r2
81115c9c:	81115cb0 	cmpltui	r4,r16,17778
81115ca0:	81115cc8 	cmpgei	r4,r16,17779
81115ca4:	81115d60 	cmpeqi	r4,r16,17781
81115ca8:	81115e44 	addi	r4,r16,17785
81115cac:	81115f70 	cmpltui	r4,r16,17789
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81115cb0:	e13ffb17 	ldw	r4,-20(fp)
81115cb4:	11170a00 	call	811170a0 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81115cb8:	e0bffb17 	ldw	r2,-20(fp)
81115cbc:	00c00044 	movi	r3,1
81115cc0:	10c00115 	stw	r3,4(r2)
				break;
81115cc4:	00013306 	br	81116194 <vSimMebTask+0x578>


			case sMebToConfig:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115cc8:	00a045f4 	movhi	r2,33047
81115ccc:	10a00404 	addi	r2,r2,-32752
81115cd0:	10800e8b 	ldhu	r2,58(r2)
81115cd4:	10bfffcc 	andi	r2,r2,65535
81115cd8:	10800168 	cmpgeui	r2,r2,5
81115cdc:	1000071e 	bne	r2,zero,81115cfc <vSimMebTask+0xe0>
					debug(fp,"MEB Task: Config Mode\n");
81115ce0:	d0a06217 	ldw	r2,-32376(gp)
81115ce4:	100f883a 	mov	r7,r2
81115ce8:	01800584 	movi	r6,22
81115cec:	01400044 	movi	r5,1
81115cf0:	01204574 	movhi	r4,33045
81115cf4:	213c6904 	addi	r4,r4,-3676
81115cf8:	11230300 	call	81123030 <fwrite>
				}
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81115cfc:	11202740 	call	81120274 <bStopSync>
				vSyncClearCounter();
81115d00:	110cae00 	call	8110cae0 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81115d04:	11171a80 	call	811171a8 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81115d08:	01c00284 	movi	r7,10
81115d0c:	000d883a 	mov	r6,zero
81115d10:	000b883a 	mov	r5,zero
81115d14:	0009883a 	mov	r4,zero
81115d18:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81115d1c:	000d883a 	mov	r6,zero
81115d20:	000b883a 	mov	r5,zero
81115d24:	01002844 	movi	r4,161
81115d28:	1116e740 	call	81116e74 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81115d2c:	000d883a 	mov	r6,zero
81115d30:	000b883a 	mov	r5,zero
81115d34:	01002844 	movi	r4,161
81115d38:	11170180 	call	81117018 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81115d3c:	01c03e84 	movi	r7,250
81115d40:	000d883a 	mov	r6,zero
81115d44:	000b883a 	mov	r5,zero
81115d48:	0009883a 	mov	r4,zero
81115d4c:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81115d50:	e0bffb17 	ldw	r2,-20(fp)
81115d54:	00c000c4 	movi	r3,3
81115d58:	10c00115 	stw	r3,4(r2)
				break;
81115d5c:	00010d06 	br	81116194 <vSimMebTask+0x578>


			case sMebToRun:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115d60:	00a045f4 	movhi	r2,33047
81115d64:	10a00404 	addi	r2,r2,-32752
81115d68:	10800e8b 	ldhu	r2,58(r2)
81115d6c:	10bfffcc 	andi	r2,r2,65535
81115d70:	10800168 	cmpgeui	r2,r2,5
81115d74:	1000071e 	bne	r2,zero,81115d94 <vSimMebTask+0x178>
					debug(fp,"MEB Task: Run Mode\n");
81115d78:	d0a06217 	ldw	r2,-32376(gp)
81115d7c:	100f883a 	mov	r7,r2
81115d80:	018004c4 	movi	r6,19
81115d84:	01400044 	movi	r5,1
81115d88:	01204574 	movhi	r4,33045
81115d8c:	213c6f04 	addi	r4,r4,-3652
81115d90:	11230300 	call	81123030 <fwrite>
				}
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81115d94:	000d883a 	mov	r6,zero
81115d98:	000b883a 	mov	r5,zero
81115d9c:	01002884 	movi	r4,162
81115da0:	1116e740 	call	81116e74 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81115da4:	000d883a 	mov	r6,zero
81115da8:	000b883a 	mov	r5,zero
81115dac:	01002884 	movi	r4,162
81115db0:	11170180 	call	81117018 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
81115db4:	e0bffb17 	ldw	r2,-20(fp)
81115db8:	1080050b 	ldhu	r2,20(r2)
81115dbc:	10bfffcc 	andi	r2,r2,65535
81115dc0:	100f883a 	mov	r7,r2
81115dc4:	000d883a 	mov	r6,zero
81115dc8:	000b883a 	mov	r5,zero
81115dcc:	0009883a 	mov	r4,zero
81115dd0:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115dd4:	e03ffa05 	stb	zero,-24(fp)
81115dd8:	00001006 	br	81115e1c <vSimMebTask+0x200>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81115ddc:	e0bffa03 	ldbu	r2,-24(fp)
81115de0:	10809624 	muli	r2,r2,600
81115de4:	10809b04 	addi	r2,r2,620
81115de8:	e0fffb17 	ldw	r3,-20(fp)
81115dec:	1885883a 	add	r2,r3,r2
81115df0:	1009883a 	mov	r4,r2
81115df4:	110a5300 	call	8110a530 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81115df8:	e0bffa03 	ldbu	r2,-24(fp)
81115dfc:	e0fffb17 	ldw	r3,-20(fp)
81115e00:	10809624 	muli	r2,r2,600
81115e04:	1885883a 	add	r2,r3,r2
81115e08:	10803c04 	addi	r2,r2,240
81115e0c:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115e10:	e0bffa03 	ldbu	r2,-24(fp)
81115e14:	10800044 	addi	r2,r2,1
81115e18:	e0bffa05 	stb	r2,-24(fp)
81115e1c:	e0bffa03 	ldbu	r2,-24(fp)
81115e20:	103fee26 	beq	r2,zero,81115ddc <__reset+0xfb0f5ddc>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81115e24:	110d1300 	call	8110d130 <bSyncCtrReset>
				vSyncClearCounter();
81115e28:	110cae00 	call	8110cae0 <vSyncClearCounter>
				bStartSync();
81115e2c:	11202380 	call	81120238 <bStartSync>

				vEvtChangeMebMode();
81115e30:	111ec140 	call	8111ec14 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81115e34:	e0bffb17 	ldw	r2,-20(fp)
81115e38:	00c00104 	movi	r3,4
81115e3c:	10c00115 	stw	r3,4(r2)
				break;
81115e40:	0000d406 	br	81116194 <vSimMebTask+0x578>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115e44:	d0a06917 	ldw	r2,-32348(gp)
81115e48:	e0fffe04 	addi	r3,fp,-8
81115e4c:	180d883a 	mov	r6,r3
81115e50:	000b883a 	mov	r5,zero
81115e54:	1009883a 	mov	r4,r2
81115e58:	113ef3c0 	call	8113ef3c <OSQPend>
81115e5c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81115e60:	e0bffe03 	ldbu	r2,-8(fp)
81115e64:	10803fcc 	andi	r2,r2,255
81115e68:	10003b1e 	bne	r2,zero,81115f58 <vSimMebTask+0x33c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81115e6c:	e0bffdc3 	ldbu	r2,-9(fp)
81115e70:	10803fcc 	andi	r2,r2,255
81115e74:	10800058 	cmpnei	r2,r2,1
81115e78:	1000281e 	bne	r2,zero,81115f1c <vSimMebTask+0x300>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81115e7c:	e0bffd83 	ldbu	r2,-10(fp)
81115e80:	10803fcc 	andi	r2,r2,255
81115e84:	10c00060 	cmpeqi	r3,r2,1
81115e88:	1800031e 	bne	r3,zero,81115e98 <vSimMebTask+0x27c>
81115e8c:	10803820 	cmpeqi	r2,r2,224
81115e90:	1000041e 	bne	r2,zero,81115ea4 <vSimMebTask+0x288>
81115e94:	00001106 	br	81115edc <vSimMebTask+0x2c0>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115e98:	e13ffb17 	ldw	r4,-20(fp)
81115e9c:	11161980 	call	81116198 <vPusMebTask>
								break;
81115ea0:	00003206 	br	81115f6c <vSimMebTask+0x350>
							case M_MASTER_SYNC:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115ea4:	00a045f4 	movhi	r2,33047
81115ea8:	10a00404 	addi	r2,r2,-32752
81115eac:	10800e8b 	ldhu	r2,58(r2)
81115eb0:	10bfffcc 	andi	r2,r2,65535
81115eb4:	108001e8 	cmpgeui	r2,r2,7
81115eb8:	1000291e 	bne	r2,zero,81115f60 <vSimMebTask+0x344>
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81115ebc:	d0a06217 	ldw	r2,-32376(gp)
81115ec0:	100f883a 	mov	r7,r2
81115ec4:	018012c4 	movi	r6,75
81115ec8:	01400044 	movi	r5,1
81115ecc:	01204574 	movhi	r4,33045
81115ed0:	213c7404 	addi	r4,r4,-3632
81115ed4:	11230300 	call	81123030 <fwrite>
								}
								#endif
								break;
81115ed8:	00002106 	br	81115f60 <vSimMebTask+0x344>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115edc:	00a045f4 	movhi	r2,33047
81115ee0:	10a00404 	addi	r2,r2,-32752
81115ee4:	10800e8b 	ldhu	r2,58(r2)
81115ee8:	10bfffcc 	andi	r2,r2,65535
81115eec:	108001e8 	cmpgeui	r2,r2,7
81115ef0:	10001d1e 	bne	r2,zero,81115f68 <vSimMebTask+0x34c>
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81115ef4:	d0a06217 	ldw	r2,-32376(gp)
81115ef8:	e0fffd83 	ldbu	r3,-10(fp)
81115efc:	18c03fcc 	andi	r3,r3,255
81115f00:	180d883a 	mov	r6,r3
81115f04:	01604574 	movhi	r5,33045
81115f08:	297c8704 	addi	r5,r5,-3556
81115f0c:	1009883a 	mov	r4,r2
81115f10:	11229940 	call	81122994 <fprintf>
								}
								#endif
								break;
81115f14:	0001883a 	nop
81115f18:	00001306 	br	81115f68 <vSimMebTask+0x34c>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115f1c:	00a045f4 	movhi	r2,33047
81115f20:	10a00404 	addi	r2,r2,-32752
81115f24:	10800e8b 	ldhu	r2,58(r2)
81115f28:	10bfffcc 	andi	r2,r2,65535
81115f2c:	108001e8 	cmpgeui	r2,r2,7
81115f30:	1000951e 	bne	r2,zero,81116188 <vSimMebTask+0x56c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81115f34:	d0a06217 	ldw	r2,-32376(gp)
81115f38:	e0fffdc3 	ldbu	r3,-9(fp)
81115f3c:	18c03fcc 	andi	r3,r3,255
81115f40:	180d883a 	mov	r6,r3
81115f44:	01604574 	movhi	r5,33045
81115f48:	297c9904 	addi	r5,r5,-3484
81115f4c:	1009883a 	mov	r4,r2
81115f50:	11229940 	call	81122994 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115f54:	00008c06 	br	81116188 <vSimMebTask+0x56c>
						}
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81115f58:	111e3ec0 	call	8111e3ec <vCouldNotGetCmdQueueMeb>
				}

				break;
81115f5c:	00008a06 	br	81116188 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
								}
								#endif
								break;
81115f60:	0001883a 	nop
81115f64:	00008806 	br	81116188 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
81115f68:	0001883a 	nop
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115f6c:	00008606 	br	81116188 <vSimMebTask+0x56c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115f70:	d0a06917 	ldw	r2,-32348(gp)
81115f74:	e0fffe04 	addi	r3,fp,-8
81115f78:	180d883a 	mov	r6,r3
81115f7c:	000b883a 	mov	r5,zero
81115f80:	1009883a 	mov	r4,r2
81115f84:	113ef3c0 	call	8113ef3c <OSQPend>
81115f88:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81115f8c:	e0bffe03 	ldbu	r2,-8(fp)
81115f90:	10803fcc 	andi	r2,r2,255
81115f94:	1000651e 	bne	r2,zero,8111612c <vSimMebTask+0x510>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81115f98:	e0bffdc3 	ldbu	r2,-9(fp)
81115f9c:	10803fcc 	andi	r2,r2,255
81115fa0:	10800058 	cmpnei	r2,r2,1
81115fa4:	1000521e 	bne	r2,zero,811160f0 <vSimMebTask+0x4d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81115fa8:	e0bffd83 	ldbu	r2,-10(fp)
81115fac:	10803fcc 	andi	r2,r2,255
81115fb0:	10c03820 	cmpeqi	r3,r2,224
81115fb4:	1800071e 	bne	r3,zero,81115fd4 <vSimMebTask+0x3b8>
81115fb8:	10c03860 	cmpeqi	r3,r2,225
81115fbc:	1800071e 	bne	r3,zero,81115fdc <vSimMebTask+0x3c0>
81115fc0:	10800060 	cmpeqi	r2,r2,1
81115fc4:	10003a26 	beq	r2,zero,811160b0 <vSimMebTask+0x494>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115fc8:	e13ffb17 	ldw	r4,-20(fp)
81115fcc:	11161980 	call	81116198 <vPusMebTask>
								break;
81115fd0:	00005b06 	br	81116140 <vSimMebTask+0x524>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81115fd4:	e13ffb17 	ldw	r4,-20(fp)
81115fd8:	11171040 	call	81117104 <vSwapMemmory>
							case M_SYNC:
								#if DEBUG_ON

								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115fdc:	00a045f4 	movhi	r2,33047
81115fe0:	10a00404 	addi	r2,r2,-32752
81115fe4:	10800e8b 	ldhu	r2,58(r2)
81115fe8:	10bfffcc 	andi	r2,r2,65535
81115fec:	10800168 	cmpgeui	r2,r2,5
81115ff0:	1000501e 	bne	r2,zero,81116134 <vSimMebTask+0x518>
									fprintf(fp,"\n\nSync\n");
81115ff4:	d0a06217 	ldw	r2,-32376(gp)
81115ff8:	100f883a 	mov	r7,r2
81115ffc:	018001c4 	movi	r6,7
81116000:	01400044 	movi	r5,1
81116004:	01204574 	movhi	r4,33045
81116008:	213ca704 	addi	r4,r4,-3428
8111600c:	11230300 	call	81123030 <fwrite>
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116010:	00a045f4 	movhi	r2,33047
81116014:	10a00404 	addi	r2,r2,-32752
81116018:	10800e8b 	ldhu	r2,58(r2)
8111601c:	10bfffcc 	andi	r2,r2,65535
81116020:	108000e8 	cmpgeui	r2,r2,3
81116024:	1000431e 	bne	r2,zero,81116134 <vSimMebTask+0x518>
										bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
81116028:	e0bffb17 	ldw	r2,-20(fp)
8111602c:	10809b04 	addi	r2,r2,620
81116030:	1009883a 	mov	r4,r2
81116034:	110a4a00 	call	8110a4a0 <bSpwcGetTimecode>
										tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81116038:	e0bffb17 	ldw	r2,-20(fp)
8111603c:	1080a743 	ldbu	r2,669(r2)
81116040:	e0bffc05 	stb	r2,-16(fp)
										tCodeNext = ( tCode ) % 4;
81116044:	e0bffc03 	ldbu	r2,-16(fp)
81116048:	108000cc 	andi	r2,r2,3
8111604c:	e0bffc45 	stb	r2,-15(fp)
										fprintf(fp,"TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
81116050:	d0a06217 	ldw	r2,-32376(gp)
81116054:	e0fffc03 	ldbu	r3,-16(fp)
81116058:	e13ffc43 	ldbu	r4,-15(fp)
8111605c:	200f883a 	mov	r7,r4
81116060:	180d883a 	mov	r6,r3
81116064:	01604574 	movhi	r5,33045
81116068:	297ca904 	addi	r5,r5,-3420
8111606c:	1009883a 	mov	r4,r2
81116070:	11229940 	call	81122994 <fprintf>
										bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
81116074:	e0bffb17 	ldw	r2,-20(fp)
81116078:	10805504 	addi	r2,r2,340
8111607c:	1009883a 	mov	r4,r2
81116080:	11080940 	call	81108094 <bRmapGetMemConfigArea>
										ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
81116084:	e0bffb17 	ldw	r2,-20(fp)
81116088:	10807717 	ldw	r2,476(r2)
8111608c:	e0bffc85 	stb	r2,-14(fp)
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
81116090:	d0a06217 	ldw	r2,-32376(gp)
81116094:	e0fffc83 	ldbu	r3,-14(fp)
81116098:	180d883a 	mov	r6,r3
8111609c:	01604574 	movhi	r5,33045
811160a0:	297cae04 	addi	r5,r5,-3400
811160a4:	1009883a 	mov	r4,r2
811160a8:	11229940 	call	81122994 <fprintf>
									}
								}
								#endif

								break;
811160ac:	00002106 	br	81116134 <vSimMebTask+0x518>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811160b0:	00a045f4 	movhi	r2,33047
811160b4:	10a00404 	addi	r2,r2,-32752
811160b8:	10800e8b 	ldhu	r2,58(r2)
811160bc:	10bfffcc 	andi	r2,r2,65535
811160c0:	108001e8 	cmpgeui	r2,r2,7
811160c4:	10001d1e 	bne	r2,zero,8111613c <vSimMebTask+0x520>
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
811160c8:	d0a06217 	ldw	r2,-32376(gp)
811160cc:	e0fffd83 	ldbu	r3,-10(fp)
811160d0:	18c03fcc 	andi	r3,r3,255
811160d4:	180d883a 	mov	r6,r3
811160d8:	01604574 	movhi	r5,33045
811160dc:	297cb704 	addi	r5,r5,-3364
811160e0:	1009883a 	mov	r4,r2
811160e4:	11229940 	call	81122994 <fprintf>
								}
								#endif
								break;
811160e8:	0001883a 	nop
811160ec:	00001306 	br	8111613c <vSimMebTask+0x520>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811160f0:	00a045f4 	movhi	r2,33047
811160f4:	10a00404 	addi	r2,r2,-32752
811160f8:	10800e8b 	ldhu	r2,58(r2)
811160fc:	10bfffcc 	andi	r2,r2,65535
81116100:	108001e8 	cmpgeui	r2,r2,7
81116104:	1000221e 	bne	r2,zero,81116190 <vSimMebTask+0x574>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81116108:	d0a06217 	ldw	r2,-32376(gp)
8111610c:	e0fffdc3 	ldbu	r3,-9(fp)
81116110:	18c03fcc 	andi	r3,r3,255
81116114:	180d883a 	mov	r6,r3
81116118:	01604574 	movhi	r5,33045
8111611c:	297c9904 	addi	r5,r5,-3484
81116120:	1009883a 	mov	r4,r2
81116124:	11229940 	call	81122994 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116128:	00001906 	br	81116190 <vSimMebTask+0x574>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8111612c:	111e3ec0 	call	8111e3ec <vCouldNotGetCmdQueueMeb>
				}			
				break;
81116130:	00001706 	br	81116190 <vSimMebTask+0x574>
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
									}
								}
								#endif

								break;
81116134:	0001883a 	nop
81116138:	00001506 	br	81116190 <vSimMebTask+0x574>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
8111613c:	0001883a 	nop

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116140:	00001306 	br	81116190 <vSimMebTask+0x574>

			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116144:	00a045f4 	movhi	r2,33047
81116148:	10a00404 	addi	r2,r2,-32752
8111614c:	10800e8b 	ldhu	r2,58(r2)
81116150:	10bfffcc 	andi	r2,r2,65535
81116154:	108001e8 	cmpgeui	r2,r2,7
81116158:	1000071e 	bne	r2,zero,81116178 <vSimMebTask+0x55c>
					debug(fp,"MEB Task: Unknown state, backing to Config Mode\n");
8111615c:	d0a06217 	ldw	r2,-32376(gp)
81116160:	100f883a 	mov	r7,r2
81116164:	01800c04 	movi	r6,48
81116168:	01400044 	movi	r5,1
8111616c:	01204574 	movhi	r4,33045
81116170:	213cc004 	addi	r4,r4,-3328
81116174:	11230300 	call	81123030 <fwrite>
				}
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81116178:	e0bffb17 	ldw	r2,-20(fp)
8111617c:	00c00044 	movi	r3,1
81116180:	10c00115 	stw	r3,4(r2)
				break;
81116184:	00000306 	br	81116194 <vSimMebTask+0x578>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81116188:	0001883a 	nop
8111618c:	003eb906 	br	81115c74 <__reset+0xfb0f5c74>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116190:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
				break;
		}
	}
81116194:	003eb706 	br	81115c74 <__reset+0xfb0f5c74>

81116198 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81116198:	defffb04 	addi	sp,sp,-20
8111619c:	de00012e 	bgeu	sp,et,811161a4 <vPusMebTask+0xc>
811161a0:	003b68fa 	trap	3
811161a4:	dfc00415 	stw	ra,16(sp)
811161a8:	df000315 	stw	fp,12(sp)
811161ac:	df000304 	addi	fp,sp,12
811161b0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
811161b4:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
811161b8:	d0a07317 	ldw	r2,-32308(gp)
811161bc:	e0fffe44 	addi	r3,fp,-7
811161c0:	180d883a 	mov	r6,r3
811161c4:	01400084 	movi	r5,2
811161c8:	1009883a 	mov	r4,r2
811161cc:	113de280 	call	8113de28 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
811161d0:	e0bffe43 	ldbu	r2,-7(fp)
811161d4:	10803fcc 	andi	r2,r2,255
811161d8:	10002c1e 	bne	r2,zero,8111628c <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811161dc:	e03ffe05 	stb	zero,-8(fp)
811161e0:	00002306 	br	81116270 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
811161e4:	e0fffe03 	ldbu	r3,-8(fp)
811161e8:	00a04574 	movhi	r2,33045
811161ec:	109c7e04 	addi	r2,r2,29176
811161f0:	18c01524 	muli	r3,r3,84
811161f4:	10c5883a 	add	r2,r2,r3
811161f8:	10800104 	addi	r2,r2,4
811161fc:	10800017 	ldw	r2,0(r2)
81116200:	10800058 	cmpnei	r2,r2,1
81116204:	1000171e 	bne	r2,zero,81116264 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81116208:	e13ffe03 	ldbu	r4,-8(fp)
8111620c:	00e04574 	movhi	r3,33045
81116210:	18d20104 	addi	r3,r3,18436
81116214:	00a04574 	movhi	r2,33045
81116218:	109c7e04 	addi	r2,r2,29176
8111621c:	21001524 	muli	r4,r4,84
81116220:	1105883a 	add	r2,r2,r4
81116224:	1009883a 	mov	r4,r2
81116228:	00801504 	movi	r2,84
8111622c:	100d883a 	mov	r6,r2
81116230:	200b883a 	mov	r5,r4
81116234:	1809883a 	mov	r4,r3
81116238:	1123a440 	call	81123a44 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
8111623c:	e0fffe03 	ldbu	r3,-8(fp)
81116240:	00a04574 	movhi	r2,33045
81116244:	109c7e04 	addi	r2,r2,29176
81116248:	18c01524 	muli	r3,r3,84
8111624c:	10c5883a 	add	r2,r2,r3
81116250:	10800104 	addi	r2,r2,4
81116254:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81116258:	00800044 	movi	r2,1
8111625c:	e0bffd15 	stw	r2,-12(fp)
                break;
81116260:	00000606 	br	8111627c <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81116264:	e0bffe03 	ldbu	r2,-8(fp)
81116268:	10800044 	addi	r2,r2,1
8111626c:	e0bffe05 	stb	r2,-8(fp)
81116270:	e0bffe03 	ldbu	r2,-8(fp)
81116274:	10800130 	cmpltui	r2,r2,4
81116278:	103fda1e 	bne	r2,zero,811161e4 <__reset+0xfb0f61e4>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8111627c:	d0a07317 	ldw	r2,-32308(gp)
81116280:	1009883a 	mov	r4,r2
81116284:	113e3cc0 	call	8113e3cc <OSMutexPost>
81116288:	00000106 	br	81116290 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
8111628c:	111e46c0 	call	8111e46c <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81116290:	e0bffd17 	ldw	r2,-12(fp)
81116294:	10001126 	beq	r2,zero,811162dc <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81116298:	e0bfff17 	ldw	r2,-4(fp)
8111629c:	10800117 	ldw	r2,4(r2)
811162a0:	10c000e0 	cmpeqi	r3,r2,3
811162a4:	1800031e 	bne	r3,zero,811162b4 <vPusMebTask+0x11c>
811162a8:	10800120 	cmpeqi	r2,r2,4
811162ac:	1000061e 	bne	r2,zero,811162c8 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
811162b0:	00000a06 	br	811162dc <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
811162b4:	01604574 	movhi	r5,33045
811162b8:	29520104 	addi	r5,r5,18436
811162bc:	e13fff17 	ldw	r4,-4(fp)
811162c0:	11162f40 	call	811162f4 <vPusMebInTaskConfigMode>
				break;
811162c4:	00000506 	br	811162dc <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
811162c8:	01604574 	movhi	r5,33045
811162cc:	29520104 	addi	r5,r5,18436
811162d0:	e13fff17 	ldw	r4,-4(fp)
811162d4:	11167300 	call	81116730 <vPusMebInTaskRunningMode>
				break;
811162d8:	0001883a 	nop
			default:
				break;
		}
	}
}
811162dc:	0001883a 	nop
811162e0:	e037883a 	mov	sp,fp
811162e4:	dfc00117 	ldw	ra,4(sp)
811162e8:	df000017 	ldw	fp,0(sp)
811162ec:	dec00204 	addi	sp,sp,8
811162f0:	f800283a 	ret

811162f4 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811162f4:	defffc04 	addi	sp,sp,-16
811162f8:	de00012e 	bgeu	sp,et,81116300 <vPusMebInTaskConfigMode+0xc>
811162fc:	003b68fa 	trap	3
81116300:	dfc00315 	stw	ra,12(sp)
81116304:	df000215 	stw	fp,8(sp)
81116308:	df000204 	addi	fp,sp,8
8111630c:	e13ffe15 	stw	r4,-8(fp)
81116310:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116314:	e0bfff17 	ldw	r2,-4(fp)
81116318:	1080030b 	ldhu	r2,12(r2)
8111631c:	10bfffcc 	andi	r2,r2,65535
81116320:	10c03ee0 	cmpeqi	r3,r2,251
81116324:	1800081e 	bne	r3,zero,81116348 <vPusMebInTaskConfigMode+0x54>
81116328:	10c03f20 	cmpeqi	r3,r2,252
8111632c:	18000a1e 	bne	r3,zero,81116358 <vPusMebInTaskConfigMode+0x64>
81116330:	10803ea0 	cmpeqi	r2,r2,250
81116334:	10000c26 	beq	r2,zero,81116368 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81116338:	e17fff17 	ldw	r5,-4(fp)
8111633c:	e13ffe17 	ldw	r4,-8(fp)
81116340:	11163b80 	call	811163b8 <vPusType250conf>
			break;
81116344:	00001606 	br	811163a0 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81116348:	e17fff17 	ldw	r5,-4(fp)
8111634c:	e13ffe17 	ldw	r4,-8(fp)
81116350:	11164640 	call	81116464 <vPusType251conf>
			break;
81116354:	00001206 	br	811163a0 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81116358:	e17fff17 	ldw	r5,-4(fp)
8111635c:	e13ffe17 	ldw	r4,-8(fp)
81116360:	11164d00 	call	811164d0 <vPusType252conf>
			break;
81116364:	00000e06 	br	811163a0 <vPusMebInTaskConfigMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116368:	00a045f4 	movhi	r2,33047
8111636c:	10a00404 	addi	r2,r2,-32752
81116370:	10800e8b 	ldhu	r2,58(r2)
81116374:	10bfffcc 	andi	r2,r2,65535
81116378:	108001e8 	cmpgeui	r2,r2,7
8111637c:	1000071e 	bne	r2,zero,8111639c <vPusMebInTaskConfigMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81116380:	d0a06217 	ldw	r2,-32376(gp)
81116384:	100f883a 	mov	r7,r2
81116388:	01800d84 	movi	r6,54
8111638c:	01400044 	movi	r5,1
81116390:	01204574 	movhi	r4,33045
81116394:	213ccd04 	addi	r4,r4,-3276
81116398:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
8111639c:	0001883a 	nop
	}
}
811163a0:	0001883a 	nop
811163a4:	e037883a 	mov	sp,fp
811163a8:	dfc00117 	ldw	ra,4(sp)
811163ac:	df000017 	ldw	fp,0(sp)
811163b0:	dec00204 	addi	sp,sp,8
811163b4:	f800283a 	ret

811163b8 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811163b8:	defffc04 	addi	sp,sp,-16
811163bc:	de00012e 	bgeu	sp,et,811163c4 <vPusType250conf+0xc>
811163c0:	003b68fa 	trap	3
811163c4:	dfc00315 	stw	ra,12(sp)
811163c8:	df000215 	stw	fp,8(sp)
811163cc:	df000204 	addi	fp,sp,8
811163d0:	e13ffe15 	stw	r4,-8(fp)
811163d4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811163d8:	e0bfff17 	ldw	r2,-4(fp)
811163dc:	1080038b 	ldhu	r2,14(r2)
811163e0:	10bfffcc 	andi	r2,r2,65535
811163e4:	10c00f60 	cmpeqi	r3,r2,61
811163e8:	1800031e 	bne	r3,zero,811163f8 <vPusType250conf+0x40>
811163ec:	10800fa0 	cmpeqi	r2,r2,62
811163f0:	1000131e 	bne	r2,zero,81116440 <vPusType250conf+0x88>
811163f4:	00000406 	br	81116408 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
811163f8:	e0bffe17 	ldw	r2,-8(fp)
811163fc:	00c00084 	movi	r3,2
81116400:	10c00115 	stw	r3,4(r2)
			break;
81116404:	00001106 	br	8111644c <vPusType250conf+0x94>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116408:	00a045f4 	movhi	r2,33047
8111640c:	10a00404 	addi	r2,r2,-32752
81116410:	10800e8b 	ldhu	r2,58(r2)
81116414:	10bfffcc 	andi	r2,r2,65535
81116418:	108001e8 	cmpgeui	r2,r2,7
8111641c:	10000a1e 	bne	r2,zero,81116448 <vPusType250conf+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81116420:	d0a06217 	ldw	r2,-32376(gp)
81116424:	100f883a 	mov	r7,r2
81116428:	01800b04 	movi	r6,44
8111642c:	01400044 	movi	r5,1
81116430:	01204574 	movhi	r4,33045
81116434:	213cdb04 	addi	r4,r4,-3220
81116438:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
8111643c:	00000206 	br	81116448 <vPusType250conf+0x90>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81116440:	0001883a 	nop
81116444:	00000106 	br	8111644c <vPusType250conf+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116448:	0001883a 	nop
	}
}
8111644c:	0001883a 	nop
81116450:	e037883a 	mov	sp,fp
81116454:	dfc00117 	ldw	ra,4(sp)
81116458:	df000017 	ldw	fp,0(sp)
8111645c:	dec00204 	addi	sp,sp,8
81116460:	f800283a 	ret

81116464 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116464:	defffc04 	addi	sp,sp,-16
81116468:	de00012e 	bgeu	sp,et,81116470 <vPusType251conf+0xc>
8111646c:	003b68fa 	trap	3
81116470:	dfc00315 	stw	ra,12(sp)
81116474:	df000215 	stw	fp,8(sp)
81116478:	df000204 	addi	fp,sp,8
8111647c:	e13ffe15 	stw	r4,-8(fp)
81116480:	e17fff15 	stw	r5,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116484:	00a045f4 	movhi	r2,33047
81116488:	10a00404 	addi	r2,r2,-32752
8111648c:	10800e8b 	ldhu	r2,58(r2)
81116490:	10bfffcc 	andi	r2,r2,65535
81116494:	10800168 	cmpgeui	r2,r2,5
81116498:	1000071e 	bne	r2,zero,811164b8 <vPusType251conf+0x54>
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
8111649c:	d0a06217 	ldw	r2,-32376(gp)
811164a0:	100f883a 	mov	r7,r2
811164a4:	01801184 	movi	r6,70
811164a8:	01400044 	movi	r5,1
811164ac:	01204574 	movhi	r4,33045
811164b0:	213ce704 	addi	r4,r4,-3172
811164b4:	11230300 	call	81123030 <fwrite>
	}
	#endif
}
811164b8:	0001883a 	nop
811164bc:	e037883a 	mov	sp,fp
811164c0:	dfc00117 	ldw	ra,4(sp)
811164c4:	df000017 	ldw	fp,0(sp)
811164c8:	dec00204 	addi	sp,sp,8
811164cc:	f800283a 	ret

811164d0 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811164d0:	defffb04 	addi	sp,sp,-20
811164d4:	de00012e 	bgeu	sp,et,811164dc <vPusType252conf+0xc>
811164d8:	003b68fa 	trap	3
811164dc:	dfc00415 	stw	ra,16(sp)
811164e0:	df000315 	stw	fp,12(sp)
811164e4:	df000304 	addi	fp,sp,12
811164e8:	e13ffe15 	stw	r4,-8(fp)
811164ec:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811164f0:	e0bfff17 	ldw	r2,-4(fp)
811164f4:	1080050b 	ldhu	r2,20(r2)
811164f8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811164fc:	e0bfff17 	ldw	r2,-4(fp)
81116500:	1080038b 	ldhu	r2,14(r2)
81116504:	10bfffcc 	andi	r2,r2,65535
81116508:	10c000a0 	cmpeqi	r3,r2,2
8111650c:	1800121e 	bne	r3,zero,81116558 <vPusType252conf+0x88>
81116510:	10c00090 	cmplti	r3,r2,2
81116514:	18006d1e 	bne	r3,zero,811166cc <vPusType252conf+0x1fc>
81116518:	10800188 	cmpgei	r2,r2,6
8111651c:	10006b1e 	bne	r2,zero,811166cc <vPusType252conf+0x1fc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116520:	00a045f4 	movhi	r2,33047
81116524:	10a00404 	addi	r2,r2,-32752
81116528:	10800e8b 	ldhu	r2,58(r2)
8111652c:	10bfffcc 	andi	r2,r2,65535
81116530:	10800168 	cmpgeui	r2,r2,5
81116534:	1000731e 	bne	r2,zero,81116704 <vPusType252conf+0x234>
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81116538:	d0a06217 	ldw	r2,-32376(gp)
8111653c:	100f883a 	mov	r7,r2
81116540:	01801384 	movi	r6,78
81116544:	01400044 	movi	r5,1
81116548:	01204574 	movhi	r4,33045
8111654c:	213cf904 	addi	r4,r4,-3100
81116550:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
81116554:	00006b06 	br	81116704 <vPusType252conf+0x234>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116558:	e0bffd0b 	ldhu	r2,-12(fp)
8111655c:	10809624 	muli	r2,r2,600
81116560:	10805504 	addi	r2,r2,340
81116564:	e0fffe17 	ldw	r3,-8(fp)
81116568:	1885883a 	add	r2,r3,r2
8111656c:	1009883a 	mov	r4,r2
81116570:	11078740 	call	81107874 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81116574:	e0bffd0b 	ldhu	r2,-12(fp)
81116578:	e0fffe17 	ldw	r3,-8(fp)
8111657c:	10809624 	muli	r2,r2,600
81116580:	1885883a 	add	r2,r3,r2
81116584:	10806504 	addi	r2,r2,404
81116588:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111658c:	e0bffd0b 	ldhu	r2,-12(fp)
81116590:	10809624 	muli	r2,r2,600
81116594:	10805504 	addi	r2,r2,340
81116598:	e0fffe17 	ldw	r3,-8(fp)
8111659c:	1885883a 	add	r2,r3,r2
811165a0:	1009883a 	mov	r4,r2
811165a4:	11077cc0 	call	811077cc <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811165a8:	e0bffd0b 	ldhu	r2,-12(fp)
811165ac:	10809624 	muli	r2,r2,600
811165b0:	10805504 	addi	r2,r2,340
811165b4:	e0fffe17 	ldw	r3,-8(fp)
811165b8:	1885883a 	add	r2,r3,r2
811165bc:	1009883a 	mov	r4,r2
811165c0:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811165c4:	e0bffd0b 	ldhu	r2,-12(fp)
811165c8:	e0ffff17 	ldw	r3,-4(fp)
811165cc:	18c00b0b 	ldhu	r3,44(r3)
811165d0:	1809883a 	mov	r4,r3
811165d4:	e0fffe17 	ldw	r3,-8(fp)
811165d8:	10809624 	muli	r2,r2,600
811165dc:	1885883a 	add	r2,r3,r2
811165e0:	10805604 	addi	r2,r2,344
811165e4:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811165e8:	e0bffd0b 	ldhu	r2,-12(fp)
811165ec:	e0ffff17 	ldw	r3,-4(fp)
811165f0:	18c0098b 	ldhu	r3,38(r3)
811165f4:	1809883a 	mov	r4,r3
811165f8:	e0fffe17 	ldw	r3,-8(fp)
811165fc:	10809624 	muli	r2,r2,600
81116600:	1885883a 	add	r2,r3,r2
81116604:	10805644 	addi	r2,r2,345
81116608:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111660c:	e0bffd0b 	ldhu	r2,-12(fp)
81116610:	10809624 	muli	r2,r2,600
81116614:	10805504 	addi	r2,r2,340
81116618:	e0fffe17 	ldw	r3,-8(fp)
8111661c:	1885883a 	add	r2,r3,r2
81116620:	1009883a 	mov	r4,r2
81116624:	11079840 	call	81107984 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116628:	e0bffd0b 	ldhu	r2,-12(fp)
8111662c:	10809624 	muli	r2,r2,600
81116630:	10805504 	addi	r2,r2,340
81116634:	e0fffe17 	ldw	r3,-8(fp)
81116638:	1885883a 	add	r2,r3,r2
8111663c:	1009883a 	mov	r4,r2
81116640:	11078740 	call	81107874 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81116644:	e0bffd0b 	ldhu	r2,-12(fp)
81116648:	e0fffe17 	ldw	r3,-8(fp)
8111664c:	10809624 	muli	r2,r2,600
81116650:	1885883a 	add	r2,r3,r2
81116654:	10806504 	addi	r2,r2,404
81116658:	00c00044 	movi	r3,1
8111665c:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116660:	e0bffd0b 	ldhu	r2,-12(fp)
81116664:	10809624 	muli	r2,r2,600
81116668:	10805504 	addi	r2,r2,340
8111666c:	e0fffe17 	ldw	r3,-8(fp)
81116670:	1885883a 	add	r2,r3,r2
81116674:	1009883a 	mov	r4,r2
81116678:	11077cc0 	call	811077cc <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111667c:	00a045f4 	movhi	r2,33047
81116680:	10a00404 	addi	r2,r2,-32752
81116684:	10800e8b 	ldhu	r2,58(r2)
81116688:	10bfffcc 	andi	r2,r2,65535
8111668c:	108000e8 	cmpgeui	r2,r2,3
81116690:	10001e1e 	bne	r2,zero,8111670c <vPusType252conf+0x23c>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81116694:	d0e06217 	ldw	r3,-32376(gp)
81116698:	e0bfff17 	ldw	r2,-4(fp)
8111669c:	10800b0b 	ldhu	r2,44(r2)
811166a0:	113fffcc 	andi	r4,r2,65535
811166a4:	e0bfff17 	ldw	r2,-4(fp)
811166a8:	1080098b 	ldhu	r2,38(r2)
811166ac:	10bfffcc 	andi	r2,r2,65535
811166b0:	100f883a 	mov	r7,r2
811166b4:	200d883a 	mov	r6,r4
811166b8:	01604574 	movhi	r5,33045
811166bc:	297d0d04 	addi	r5,r5,-3020
811166c0:	1809883a 	mov	r4,r3
811166c4:	11229940 	call	81122994 <fprintf>
			}
			#endif

			break;
811166c8:	00001006 	br	8111670c <vPusType252conf+0x23c>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811166cc:	00a045f4 	movhi	r2,33047
811166d0:	10a00404 	addi	r2,r2,-32752
811166d4:	10800e8b 	ldhu	r2,58(r2)
811166d8:	10bfffcc 	andi	r2,r2,65535
811166dc:	108001e8 	cmpgeui	r2,r2,7
811166e0:	10000c1e 	bne	r2,zero,81116714 <vPusType252conf+0x244>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811166e4:	d0a06217 	ldw	r2,-32376(gp)
811166e8:	100f883a 	mov	r7,r2
811166ec:	01800b04 	movi	r6,44
811166f0:	01400044 	movi	r5,1
811166f4:	01204574 	movhi	r4,33045
811166f8:	213cdb04 	addi	r4,r4,-3220
811166fc:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
81116700:	00000406 	br	81116714 <vPusType252conf+0x244>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
			}
			#endif
			break;
81116704:	0001883a 	nop
81116708:	00000306 	br	81116718 <vPusType252conf+0x248>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif

			break;
8111670c:	0001883a 	nop
81116710:	00000106 	br	81116718 <vPusType252conf+0x248>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116714:	0001883a 	nop
	}
}
81116718:	0001883a 	nop
8111671c:	e037883a 	mov	sp,fp
81116720:	dfc00117 	ldw	ra,4(sp)
81116724:	df000017 	ldw	fp,0(sp)
81116728:	dec00204 	addi	sp,sp,8
8111672c:	f800283a 	ret

81116730 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116730:	defffc04 	addi	sp,sp,-16
81116734:	de00012e 	bgeu	sp,et,8111673c <vPusMebInTaskRunningMode+0xc>
81116738:	003b68fa 	trap	3
8111673c:	dfc00315 	stw	ra,12(sp)
81116740:	df000215 	stw	fp,8(sp)
81116744:	df000204 	addi	fp,sp,8
81116748:	e13ffe15 	stw	r4,-8(fp)
8111674c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116750:	e0bfff17 	ldw	r2,-4(fp)
81116754:	1080030b 	ldhu	r2,12(r2)
81116758:	10bfffcc 	andi	r2,r2,65535
8111675c:	10c03ee0 	cmpeqi	r3,r2,251
81116760:	1800081e 	bne	r3,zero,81116784 <vPusMebInTaskRunningMode+0x54>
81116764:	10c03f20 	cmpeqi	r3,r2,252
81116768:	18000a1e 	bne	r3,zero,81116794 <vPusMebInTaskRunningMode+0x64>
8111676c:	10803ea0 	cmpeqi	r2,r2,250
81116770:	10000c26 	beq	r2,zero,811167a4 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81116774:	e17fff17 	ldw	r5,-4(fp)
81116778:	e13ffe17 	ldw	r4,-8(fp)
8111677c:	11167f40 	call	811167f4 <vPusType250run>
			break;
81116780:	00001606 	br	811167dc <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81116784:	e17fff17 	ldw	r5,-4(fp)
81116788:	e13ffe17 	ldw	r4,-8(fp)
8111678c:	11168a00 	call	811168a0 <vPusType251run>
			break;
81116790:	00001206 	br	811167dc <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81116794:	e17fff17 	ldw	r5,-4(fp)
81116798:	e13ffe17 	ldw	r4,-8(fp)
8111679c:	11169cc0 	call	811169cc <vPusType252run>
			break;
811167a0:	00000e06 	br	811167dc <vPusMebInTaskRunningMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811167a4:	00a045f4 	movhi	r2,33047
811167a8:	10a00404 	addi	r2,r2,-32752
811167ac:	10800e8b 	ldhu	r2,58(r2)
811167b0:	10bfffcc 	andi	r2,r2,65535
811167b4:	108001e8 	cmpgeui	r2,r2,7
811167b8:	1000071e 	bne	r2,zero,811167d8 <vPusMebInTaskRunningMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
811167bc:	d0a06217 	ldw	r2,-32376(gp)
811167c0:	100f883a 	mov	r7,r2
811167c4:	01800cc4 	movi	r6,51
811167c8:	01400044 	movi	r5,1
811167cc:	01204574 	movhi	r4,33045
811167d0:	213d1d04 	addi	r4,r4,-2956
811167d4:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
811167d8:	0001883a 	nop
	}
}
811167dc:	0001883a 	nop
811167e0:	e037883a 	mov	sp,fp
811167e4:	dfc00117 	ldw	ra,4(sp)
811167e8:	df000017 	ldw	fp,0(sp)
811167ec:	dec00204 	addi	sp,sp,8
811167f0:	f800283a 	ret

811167f4 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811167f4:	defffc04 	addi	sp,sp,-16
811167f8:	de00012e 	bgeu	sp,et,81116800 <vPusType250run+0xc>
811167fc:	003b68fa 	trap	3
81116800:	dfc00315 	stw	ra,12(sp)
81116804:	df000215 	stw	fp,8(sp)
81116808:	df000204 	addi	fp,sp,8
8111680c:	e13ffe15 	stw	r4,-8(fp)
81116810:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81116814:	e0bfff17 	ldw	r2,-4(fp)
81116818:	1080038b 	ldhu	r2,14(r2)
8111681c:	10bfffcc 	andi	r2,r2,65535
81116820:	10c00f20 	cmpeqi	r3,r2,60
81116824:	1800031e 	bne	r3,zero,81116834 <vPusType250run+0x40>
81116828:	10800fa0 	cmpeqi	r2,r2,62
8111682c:	1000131e 	bne	r2,zero,8111687c <vPusType250run+0x88>
81116830:	00000406 	br	81116844 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81116834:	e0bffe17 	ldw	r2,-8(fp)
81116838:	00c00044 	movi	r3,1
8111683c:	10c00115 	stw	r3,4(r2)
			break;
81116840:	00001106 	br	81116888 <vPusType250run+0x94>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116844:	00a045f4 	movhi	r2,33047
81116848:	10a00404 	addi	r2,r2,-32752
8111684c:	10800e8b 	ldhu	r2,58(r2)
81116850:	10bfffcc 	andi	r2,r2,65535
81116854:	108001e8 	cmpgeui	r2,r2,7
81116858:	10000a1e 	bne	r2,zero,81116884 <vPusType250run+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
8111685c:	d0a06217 	ldw	r2,-32376(gp)
81116860:	100f883a 	mov	r7,r2
81116864:	01800c84 	movi	r6,50
81116868:	01400044 	movi	r5,1
8111686c:	01204574 	movhi	r4,33045
81116870:	213d2a04 	addi	r4,r4,-2904
81116874:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
81116878:	00000206 	br	81116884 <vPusType250run+0x90>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111687c:	0001883a 	nop
81116880:	00000106 	br	81116888 <vPusType250run+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
81116884:	0001883a 	nop
	}
}
81116888:	0001883a 	nop
8111688c:	e037883a 	mov	sp,fp
81116890:	dfc00117 	ldw	ra,4(sp)
81116894:	df000017 	ldw	fp,0(sp)
81116898:	dec00204 	addi	sp,sp,8
8111689c:	f800283a 	ret

811168a0 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811168a0:	defffb04 	addi	sp,sp,-20
811168a4:	de00012e 	bgeu	sp,et,811168ac <vPusType251run+0xc>
811168a8:	003b68fa 	trap	3
811168ac:	dfc00415 	stw	ra,16(sp)
811168b0:	df000315 	stw	fp,12(sp)
811168b4:	df000304 	addi	fp,sp,12
811168b8:	e13ffe15 	stw	r4,-8(fp)
811168bc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811168c0:	e0bfff17 	ldw	r2,-4(fp)
811168c4:	1080050b 	ldhu	r2,20(r2)
811168c8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811168cc:	e0bfff17 	ldw	r2,-4(fp)
811168d0:	1080038b 	ldhu	r2,14(r2)
811168d4:	10bfffcc 	andi	r2,r2,65535
811168d8:	10c000a0 	cmpeqi	r3,r2,2
811168dc:	18000f1e 	bne	r3,zero,8111691c <vPusType251run+0x7c>
811168e0:	10c00160 	cmpeqi	r3,r2,5
811168e4:	1800181e 	bne	r3,zero,81116948 <vPusType251run+0xa8>
811168e8:	10800060 	cmpeqi	r2,r2,1
811168ec:	10002126 	beq	r2,zero,81116974 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
811168f0:	e0bffd0b 	ldhu	r2,-12(fp)
811168f4:	10800444 	addi	r2,r2,17
811168f8:	10803fcc 	andi	r2,r2,255
811168fc:	e0fffd0b 	ldhu	r3,-12(fp)
81116900:	18c03fcc 	andi	r3,r3,255
81116904:	180f883a 	mov	r7,r3
81116908:	000d883a 	mov	r6,zero
8111690c:	01400044 	movi	r5,1
81116910:	1009883a 	mov	r4,r2
81116914:	1116efc0 	call	81116efc <vSendCmdQToNFeeCTRL_GEN>
			break;
81116918:	00002606 	br	811169b4 <vPusType251run+0x114>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
8111691c:	e0bffd0b 	ldhu	r2,-12(fp)
81116920:	10800444 	addi	r2,r2,17
81116924:	10803fcc 	andi	r2,r2,255
81116928:	e0fffd0b 	ldhu	r3,-12(fp)
8111692c:	18c03fcc 	andi	r3,r3,255
81116930:	180f883a 	mov	r7,r3
81116934:	000d883a 	mov	r6,zero
81116938:	01400104 	movi	r5,4
8111693c:	1009883a 	mov	r4,r2
81116940:	1116efc0 	call	81116efc <vSendCmdQToNFeeCTRL_GEN>
			break;
81116944:	00001b06 	br	811169b4 <vPusType251run+0x114>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81116948:	e0bffd0b 	ldhu	r2,-12(fp)
8111694c:	10800444 	addi	r2,r2,17
81116950:	10803fcc 	andi	r2,r2,255
81116954:	e0fffd0b 	ldhu	r3,-12(fp)
81116958:	18c03fcc 	andi	r3,r3,255
8111695c:	180f883a 	mov	r7,r3
81116960:	000d883a 	mov	r6,zero
81116964:	01400204 	movi	r5,8
81116968:	1009883a 	mov	r4,r2
8111696c:	1116efc0 	call	81116efc <vSendCmdQToNFeeCTRL_GEN>
			break;
81116970:	00001006 	br	811169b4 <vPusType251run+0x114>
		case 3:
		case 4:
		case 6:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116974:	00a045f4 	movhi	r2,33047
81116978:	10a00404 	addi	r2,r2,-32752
8111697c:	10800e8b 	ldhu	r2,58(r2)
81116980:	10bfffcc 	andi	r2,r2,65535
81116984:	108001e8 	cmpgeui	r2,r2,7
81116988:	1000091e 	bne	r2,zero,811169b0 <vPusType251run+0x110>
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
8111698c:	d0e06217 	ldw	r3,-32376(gp)
81116990:	e0bfff17 	ldw	r2,-4(fp)
81116994:	1080038b 	ldhu	r2,14(r2)
81116998:	10bfffcc 	andi	r2,r2,65535
8111699c:	100d883a 	mov	r6,r2
811169a0:	01604574 	movhi	r5,33045
811169a4:	297d3704 	addi	r5,r5,-2852
811169a8:	1809883a 	mov	r4,r3
811169ac:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
811169b0:	0001883a 	nop
	}
}
811169b4:	0001883a 	nop
811169b8:	e037883a 	mov	sp,fp
811169bc:	dfc00117 	ldw	ra,4(sp)
811169c0:	df000017 	ldw	fp,0(sp)
811169c4:	dec00204 	addi	sp,sp,8
811169c8:	f800283a 	ret

811169cc <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811169cc:	defffb04 	addi	sp,sp,-20
811169d0:	de00012e 	bgeu	sp,et,811169d8 <vPusType252run+0xc>
811169d4:	003b68fa 	trap	3
811169d8:	dfc00415 	stw	ra,16(sp)
811169dc:	df000315 	stw	fp,12(sp)
811169e0:	df000304 	addi	fp,sp,12
811169e4:	e13ffe15 	stw	r4,-8(fp)
811169e8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811169ec:	e0bfff17 	ldw	r2,-4(fp)
811169f0:	1080050b 	ldhu	r2,20(r2)
811169f4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811169f8:	e0bfff17 	ldw	r2,-4(fp)
811169fc:	1080038b 	ldhu	r2,14(r2)
81116a00:	10bfffcc 	andi	r2,r2,65535
81116a04:	10c000e0 	cmpeqi	r3,r2,3
81116a08:	18000a1e 	bne	r3,zero,81116a34 <vPusType252run+0x68>
81116a0c:	10c00108 	cmpgei	r3,r2,4
81116a10:	1800031e 	bne	r3,zero,81116a20 <vPusType252run+0x54>
81116a14:	108000a0 	cmpeqi	r2,r2,2
81116a18:	1000641e 	bne	r2,zero,81116bac <vPusType252run+0x1e0>
81116a1c:	0000d606 	br	81116d78 <vPusType252run+0x3ac>
81116a20:	10c00120 	cmpeqi	r3,r2,4
81116a24:	1800321e 	bne	r3,zero,81116af0 <vPusType252run+0x124>
81116a28:	10800160 	cmpeqi	r2,r2,5
81116a2c:	1000e01e 	bne	r2,zero,81116db0 <vPusType252run+0x3e4>
81116a30:	0000d106 	br	81116d78 <vPusType252run+0x3ac>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116a34:	e0bffd0b 	ldhu	r2,-12(fp)
81116a38:	10809624 	muli	r2,r2,600
81116a3c:	10809b04 	addi	r2,r2,620
81116a40:	e0fffe17 	ldw	r3,-8(fp)
81116a44:	1885883a 	add	r2,r3,r2
81116a48:	1009883a 	mov	r4,r2
81116a4c:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81116a50:	e0bffd0b 	ldhu	r2,-12(fp)
81116a54:	e0fffe17 	ldw	r3,-8(fp)
81116a58:	10809624 	muli	r2,r2,600
81116a5c:	1885883a 	add	r2,r3,r2
81116a60:	10809d04 	addi	r2,r2,628
81116a64:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81116a68:	e0bffd0b 	ldhu	r2,-12(fp)
81116a6c:	e0fffe17 	ldw	r3,-8(fp)
81116a70:	10809624 	muli	r2,r2,600
81116a74:	1885883a 	add	r2,r3,r2
81116a78:	10809c04 	addi	r2,r2,624
81116a7c:	00c00044 	movi	r3,1
81116a80:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81116a84:	e0bffd0b 	ldhu	r2,-12(fp)
81116a88:	e0fffe17 	ldw	r3,-8(fp)
81116a8c:	10809624 	muli	r2,r2,600
81116a90:	1885883a 	add	r2,r3,r2
81116a94:	10809e04 	addi	r2,r2,632
81116a98:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116a9c:	e0bffd0b 	ldhu	r2,-12(fp)
81116aa0:	10809624 	muli	r2,r2,600
81116aa4:	10809b04 	addi	r2,r2,620
81116aa8:	e0fffe17 	ldw	r3,-8(fp)
81116aac:	1885883a 	add	r2,r3,r2
81116ab0:	1009883a 	mov	r4,r2
81116ab4:	110a0c40 	call	8110a0c4 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116ab8:	00a045f4 	movhi	r2,33047
81116abc:	10a00404 	addi	r2,r2,-32752
81116ac0:	10800e8b 	ldhu	r2,58(r2)
81116ac4:	10bfffcc 	andi	r2,r2,65535
81116ac8:	108000e8 	cmpgeui	r2,r2,3
81116acc:	1000ba1e 	bne	r2,zero,81116db8 <vPusType252run+0x3ec>
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81116ad0:	d0a06217 	ldw	r2,-32376(gp)
81116ad4:	e0fffd0b 	ldhu	r3,-12(fp)
81116ad8:	180d883a 	mov	r6,r3
81116adc:	01604574 	movhi	r5,33045
81116ae0:	297d4504 	addi	r5,r5,-2796
81116ae4:	1009883a 	mov	r4,r2
81116ae8:	11229940 	call	81122994 <fprintf>
			}
			#endif

			break;
81116aec:	0000b206 	br	81116db8 <vPusType252run+0x3ec>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116af0:	e0bffd0b 	ldhu	r2,-12(fp)
81116af4:	10809624 	muli	r2,r2,600
81116af8:	10809b04 	addi	r2,r2,620
81116afc:	e0fffe17 	ldw	r3,-8(fp)
81116b00:	1885883a 	add	r2,r3,r2
81116b04:	1009883a 	mov	r4,r2
81116b08:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81116b0c:	e0bffd0b 	ldhu	r2,-12(fp)
81116b10:	e0fffe17 	ldw	r3,-8(fp)
81116b14:	10809624 	muli	r2,r2,600
81116b18:	1885883a 	add	r2,r3,r2
81116b1c:	10809d04 	addi	r2,r2,628
81116b20:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81116b24:	e0bffd0b 	ldhu	r2,-12(fp)
81116b28:	e0fffe17 	ldw	r3,-8(fp)
81116b2c:	10809624 	muli	r2,r2,600
81116b30:	1885883a 	add	r2,r3,r2
81116b34:	10809c04 	addi	r2,r2,624
81116b38:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81116b3c:	e0bffd0b 	ldhu	r2,-12(fp)
81116b40:	e0fffe17 	ldw	r3,-8(fp)
81116b44:	10809624 	muli	r2,r2,600
81116b48:	1885883a 	add	r2,r3,r2
81116b4c:	10809e04 	addi	r2,r2,632
81116b50:	00c00044 	movi	r3,1
81116b54:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116b58:	e0bffd0b 	ldhu	r2,-12(fp)
81116b5c:	10809624 	muli	r2,r2,600
81116b60:	10809b04 	addi	r2,r2,620
81116b64:	e0fffe17 	ldw	r3,-8(fp)
81116b68:	1885883a 	add	r2,r3,r2
81116b6c:	1009883a 	mov	r4,r2
81116b70:	110a0c40 	call	8110a0c4 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116b74:	00a045f4 	movhi	r2,33047
81116b78:	10a00404 	addi	r2,r2,-32752
81116b7c:	10800e8b 	ldhu	r2,58(r2)
81116b80:	10bfffcc 	andi	r2,r2,65535
81116b84:	108000e8 	cmpgeui	r2,r2,3
81116b88:	10008d1e 	bne	r2,zero,81116dc0 <vPusType252run+0x3f4>
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81116b8c:	d0a06217 	ldw	r2,-32376(gp)
81116b90:	e0fffd0b 	ldhu	r3,-12(fp)
81116b94:	180d883a 	mov	r6,r3
81116b98:	01604574 	movhi	r5,33045
81116b9c:	297d4e04 	addi	r5,r5,-2760
81116ba0:	1009883a 	mov	r4,r2
81116ba4:	11229940 	call	81122994 <fprintf>
			}
			#endif

			break;
81116ba8:	00008506 	br	81116dc0 <vPusType252run+0x3f4>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81116bac:	e0bffd0b 	ldhu	r2,-12(fp)
81116bb0:	e0fffe17 	ldw	r3,-8(fp)
81116bb4:	10809624 	muli	r2,r2,600
81116bb8:	1885883a 	add	r2,r3,r2
81116bbc:	10803e04 	addi	r2,r2,248
81116bc0:	10800017 	ldw	r2,0(r2)
81116bc4:	10800058 	cmpnei	r2,r2,1
81116bc8:	10004a1e 	bne	r2,zero,81116cf4 <vPusType252run+0x328>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116bcc:	e0bffd0b 	ldhu	r2,-12(fp)
81116bd0:	10809624 	muli	r2,r2,600
81116bd4:	10805504 	addi	r2,r2,340
81116bd8:	e0fffe17 	ldw	r3,-8(fp)
81116bdc:	1885883a 	add	r2,r3,r2
81116be0:	1009883a 	mov	r4,r2
81116be4:	11078740 	call	81107874 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81116be8:	e0bffd0b 	ldhu	r2,-12(fp)
81116bec:	e0fffe17 	ldw	r3,-8(fp)
81116bf0:	10809624 	muli	r2,r2,600
81116bf4:	1885883a 	add	r2,r3,r2
81116bf8:	10806504 	addi	r2,r2,404
81116bfc:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116c00:	e0bffd0b 	ldhu	r2,-12(fp)
81116c04:	10809624 	muli	r2,r2,600
81116c08:	10805504 	addi	r2,r2,340
81116c0c:	e0fffe17 	ldw	r3,-8(fp)
81116c10:	1885883a 	add	r2,r3,r2
81116c14:	1009883a 	mov	r4,r2
81116c18:	11077cc0 	call	811077cc <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81116c1c:	e0bffd0b 	ldhu	r2,-12(fp)
81116c20:	10809624 	muli	r2,r2,600
81116c24:	10805504 	addi	r2,r2,340
81116c28:	e0fffe17 	ldw	r3,-8(fp)
81116c2c:	1885883a 	add	r2,r3,r2
81116c30:	1009883a 	mov	r4,r2
81116c34:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81116c38:	e0bffd0b 	ldhu	r2,-12(fp)
81116c3c:	e0ffff17 	ldw	r3,-4(fp)
81116c40:	18c00b0b 	ldhu	r3,44(r3)
81116c44:	1809883a 	mov	r4,r3
81116c48:	e0fffe17 	ldw	r3,-8(fp)
81116c4c:	10809624 	muli	r2,r2,600
81116c50:	1885883a 	add	r2,r3,r2
81116c54:	10805604 	addi	r2,r2,344
81116c58:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81116c5c:	e0bffd0b 	ldhu	r2,-12(fp)
81116c60:	e0ffff17 	ldw	r3,-4(fp)
81116c64:	18c0098b 	ldhu	r3,38(r3)
81116c68:	1809883a 	mov	r4,r3
81116c6c:	e0fffe17 	ldw	r3,-8(fp)
81116c70:	10809624 	muli	r2,r2,600
81116c74:	1885883a 	add	r2,r3,r2
81116c78:	10805644 	addi	r2,r2,345
81116c7c:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81116c80:	e0bffd0b 	ldhu	r2,-12(fp)
81116c84:	10809624 	muli	r2,r2,600
81116c88:	10805504 	addi	r2,r2,340
81116c8c:	e0fffe17 	ldw	r3,-8(fp)
81116c90:	1885883a 	add	r2,r3,r2
81116c94:	1009883a 	mov	r4,r2
81116c98:	11079840 	call	81107984 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116c9c:	e0bffd0b 	ldhu	r2,-12(fp)
81116ca0:	10809624 	muli	r2,r2,600
81116ca4:	10805504 	addi	r2,r2,340
81116ca8:	e0fffe17 	ldw	r3,-8(fp)
81116cac:	1885883a 	add	r2,r3,r2
81116cb0:	1009883a 	mov	r4,r2
81116cb4:	11078740 	call	81107874 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81116cb8:	e0bffd0b 	ldhu	r2,-12(fp)
81116cbc:	e0fffe17 	ldw	r3,-8(fp)
81116cc0:	10809624 	muli	r2,r2,600
81116cc4:	1885883a 	add	r2,r3,r2
81116cc8:	10806504 	addi	r2,r2,404
81116ccc:	00c00044 	movi	r3,1
81116cd0:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116cd4:	e0bffd0b 	ldhu	r2,-12(fp)
81116cd8:	10809624 	muli	r2,r2,600
81116cdc:	10805504 	addi	r2,r2,340
81116ce0:	e0fffe17 	ldw	r3,-8(fp)
81116ce4:	1885883a 	add	r2,r3,r2
81116ce8:	1009883a 	mov	r4,r2
81116cec:	11077cc0 	call	811077cc <bRmapSetIrqControl>
81116cf0:	00000d06 	br	81116d28 <vPusType252run+0x35c>
			} else {
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116cf4:	00a045f4 	movhi	r2,33047
81116cf8:	10a00404 	addi	r2,r2,-32752
81116cfc:	10800e8b 	ldhu	r2,58(r2)
81116d00:	10bfffcc 	andi	r2,r2,65535
81116d04:	10800168 	cmpgeui	r2,r2,5
81116d08:	1000071e 	bne	r2,zero,81116d28 <vPusType252run+0x35c>
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81116d0c:	d0a06217 	ldw	r2,-32376(gp)
81116d10:	e0fffd0b 	ldhu	r3,-12(fp)
81116d14:	180d883a 	mov	r6,r3
81116d18:	01604574 	movhi	r5,33045
81116d1c:	297d5704 	addi	r5,r5,-2724
81116d20:	1009883a 	mov	r4,r2
81116d24:	11229940 	call	81122994 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116d28:	00a045f4 	movhi	r2,33047
81116d2c:	10a00404 	addi	r2,r2,-32752
81116d30:	10800e8b 	ldhu	r2,58(r2)
81116d34:	10bfffcc 	andi	r2,r2,65535
81116d38:	108000e8 	cmpgeui	r2,r2,3
81116d3c:	1000221e 	bne	r2,zero,81116dc8 <vPusType252run+0x3fc>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81116d40:	d0e06217 	ldw	r3,-32376(gp)
81116d44:	e0bfff17 	ldw	r2,-4(fp)
81116d48:	10800b0b 	ldhu	r2,44(r2)
81116d4c:	113fffcc 	andi	r4,r2,65535
81116d50:	e0bfff17 	ldw	r2,-4(fp)
81116d54:	1080098b 	ldhu	r2,38(r2)
81116d58:	10bfffcc 	andi	r2,r2,65535
81116d5c:	100f883a 	mov	r7,r2
81116d60:	200d883a 	mov	r6,r4
81116d64:	01604574 	movhi	r5,33045
81116d68:	297d0d04 	addi	r5,r5,-3020
81116d6c:	1809883a 	mov	r4,r3
81116d70:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
81116d74:	00001406 	br	81116dc8 <vPusType252run+0x3fc>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116d78:	00a045f4 	movhi	r2,33047
81116d7c:	10a00404 	addi	r2,r2,-32752
81116d80:	10800e8b 	ldhu	r2,58(r2)
81116d84:	10bfffcc 	andi	r2,r2,65535
81116d88:	10800168 	cmpgeui	r2,r2,5
81116d8c:	1000101e 	bne	r2,zero,81116dd0 <vPusType252run+0x404>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81116d90:	d0a06217 	ldw	r2,-32376(gp)
81116d94:	100f883a 	mov	r7,r2
81116d98:	01800c84 	movi	r6,50
81116d9c:	01400044 	movi	r5,1
81116da0:	01204574 	movhi	r4,33045
81116da4:	213d2a04 	addi	r4,r4,-2904
81116da8:	11230300 	call	81123030 <fwrite>
			}
			#endif
			break;
81116dac:	00000806 	br	81116dd0 <vPusType252run+0x404>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81116db0:	0001883a 	nop
81116db4:	00000706 	br	81116dd4 <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
81116db8:	0001883a 	nop
81116dbc:	00000506 	br	81116dd4 <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
81116dc0:	0001883a 	nop
81116dc4:	00000306 	br	81116dd4 <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif
			break;
81116dc8:	0001883a 	nop
81116dcc:	00000106 	br	81116dd4 <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
81116dd0:	0001883a 	nop
	}
}
81116dd4:	0001883a 	nop
81116dd8:	e037883a 	mov	sp,fp
81116ddc:	dfc00117 	ldw	ra,4(sp)
81116de0:	df000017 	ldw	fp,0(sp)
81116de4:	dec00204 	addi	sp,sp,8
81116de8:	f800283a 	ret

81116dec <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116dec:	defff904 	addi	sp,sp,-28
81116df0:	de00012e 	bgeu	sp,et,81116df8 <vSendCmdQToNFeeCTRL+0xc>
81116df4:	003b68fa 	trap	3
81116df8:	dfc00615 	stw	ra,24(sp)
81116dfc:	df000515 	stw	fp,20(sp)
81116e00:	df000504 	addi	fp,sp,20
81116e04:	2807883a 	mov	r3,r5
81116e08:	3005883a 	mov	r2,r6
81116e0c:	e13ffd05 	stb	r4,-12(fp)
81116e10:	e0fffe05 	stb	r3,-8(fp)
81116e14:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116e18:	00800404 	movi	r2,16
81116e1c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116e20:	e0bffd03 	ldbu	r2,-12(fp)
81116e24:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116e28:	e0bffe03 	ldbu	r2,-8(fp)
81116e2c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116e30:	e0bfff03 	ldbu	r2,-4(fp)
81116e34:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116e38:	d0a07017 	ldw	r2,-32320(gp)
81116e3c:	e0fffc17 	ldw	r3,-16(fp)
81116e40:	180b883a 	mov	r5,r3
81116e44:	1009883a 	mov	r4,r2
81116e48:	113f3440 	call	8113f344 <OSQPost>
81116e4c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116e50:	e0bffb03 	ldbu	r2,-20(fp)
81116e54:	10000126 	beq	r2,zero,81116e5c <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81116e58:	111e9bc0 	call	8111e9bc <vFailSendMsgFeeCTRL>
	}
}
81116e5c:	0001883a 	nop
81116e60:	e037883a 	mov	sp,fp
81116e64:	dfc00117 	ldw	ra,4(sp)
81116e68:	df000017 	ldw	fp,0(sp)
81116e6c:	dec00204 	addi	sp,sp,8
81116e70:	f800283a 	ret

81116e74 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116e74:	defff904 	addi	sp,sp,-28
81116e78:	de00012e 	bgeu	sp,et,81116e80 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81116e7c:	003b68fa 	trap	3
81116e80:	dfc00615 	stw	ra,24(sp)
81116e84:	df000515 	stw	fp,20(sp)
81116e88:	df000504 	addi	fp,sp,20
81116e8c:	2807883a 	mov	r3,r5
81116e90:	3005883a 	mov	r2,r6
81116e94:	e13ffd05 	stb	r4,-12(fp)
81116e98:	e0fffe05 	stb	r3,-8(fp)
81116e9c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116ea0:	00800404 	movi	r2,16
81116ea4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116ea8:	e0bffd03 	ldbu	r2,-12(fp)
81116eac:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116eb0:	e0bffe03 	ldbu	r2,-8(fp)
81116eb4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116eb8:	e0bfff03 	ldbu	r2,-4(fp)
81116ebc:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116ec0:	d0a07017 	ldw	r2,-32320(gp)
81116ec4:	e0fffc17 	ldw	r3,-16(fp)
81116ec8:	180b883a 	mov	r5,r3
81116ecc:	1009883a 	mov	r4,r2
81116ed0:	113f4b40 	call	8113f4b4 <OSQPostFront>
81116ed4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116ed8:	e0bffb03 	ldbu	r2,-20(fp)
81116edc:	10000126 	beq	r2,zero,81116ee4 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81116ee0:	111e9bc0 	call	8111e9bc <vFailSendMsgFeeCTRL>
	}
}
81116ee4:	0001883a 	nop
81116ee8:	e037883a 	mov	sp,fp
81116eec:	dfc00117 	ldw	ra,4(sp)
81116ef0:	df000017 	ldw	fp,0(sp)
81116ef4:	dec00204 	addi	sp,sp,8
81116ef8:	f800283a 	ret

81116efc <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116efc:	defff804 	addi	sp,sp,-32
81116f00:	de00012e 	bgeu	sp,et,81116f08 <vSendCmdQToNFeeCTRL_GEN+0xc>
81116f04:	003b68fa 	trap	3
81116f08:	dfc00715 	stw	ra,28(sp)
81116f0c:	df000615 	stw	fp,24(sp)
81116f10:	df000604 	addi	fp,sp,24
81116f14:	2011883a 	mov	r8,r4
81116f18:	2809883a 	mov	r4,r5
81116f1c:	3007883a 	mov	r3,r6
81116f20:	3805883a 	mov	r2,r7
81116f24:	e23ffc05 	stb	r8,-16(fp)
81116f28:	e13ffd05 	stb	r4,-12(fp)
81116f2c:	e0fffe05 	stb	r3,-8(fp)
81116f30:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81116f34:	e0bffc03 	ldbu	r2,-16(fp)
81116f38:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116f3c:	e0bffd03 	ldbu	r2,-12(fp)
81116f40:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116f44:	e0bffe03 	ldbu	r2,-8(fp)
81116f48:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116f4c:	e0bfff03 	ldbu	r2,-4(fp)
81116f50:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116f54:	d0a07017 	ldw	r2,-32320(gp)
81116f58:	e0fffb17 	ldw	r3,-20(fp)
81116f5c:	180b883a 	mov	r5,r3
81116f60:	1009883a 	mov	r4,r2
81116f64:	113f3440 	call	8113f344 <OSQPost>
81116f68:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116f6c:	e0bffa03 	ldbu	r2,-24(fp)
81116f70:	10000126 	beq	r2,zero,81116f78 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81116f74:	111e9bc0 	call	8111e9bc <vFailSendMsgFeeCTRL>
	}
}
81116f78:	0001883a 	nop
81116f7c:	e037883a 	mov	sp,fp
81116f80:	dfc00117 	ldw	ra,4(sp)
81116f84:	df000017 	ldw	fp,0(sp)
81116f88:	dec00204 	addi	sp,sp,8
81116f8c:	f800283a 	ret

81116f90 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116f90:	defff904 	addi	sp,sp,-28
81116f94:	de00012e 	bgeu	sp,et,81116f9c <vSendCmdQToDataCTRL+0xc>
81116f98:	003b68fa 	trap	3
81116f9c:	dfc00615 	stw	ra,24(sp)
81116fa0:	df000515 	stw	fp,20(sp)
81116fa4:	df000504 	addi	fp,sp,20
81116fa8:	2807883a 	mov	r3,r5
81116fac:	3005883a 	mov	r2,r6
81116fb0:	e13ffd05 	stb	r4,-12(fp)
81116fb4:	e0fffe05 	stb	r3,-8(fp)
81116fb8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81116fbc:	00800804 	movi	r2,32
81116fc0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116fc4:	e0bffd03 	ldbu	r2,-12(fp)
81116fc8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116fcc:	e0bffe03 	ldbu	r2,-8(fp)
81116fd0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116fd4:	e0bfff03 	ldbu	r2,-4(fp)
81116fd8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81116fdc:	d0a05f17 	ldw	r2,-32388(gp)
81116fe0:	e0fffc17 	ldw	r3,-16(fp)
81116fe4:	180b883a 	mov	r5,r3
81116fe8:	1009883a 	mov	r4,r2
81116fec:	113f3440 	call	8113f344 <OSQPost>
81116ff0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116ff4:	e0bffb03 	ldbu	r2,-20(fp)
81116ff8:	10000126 	beq	r2,zero,81117000 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81116ffc:	111ea200 	call	8111ea20 <vFailSendMsgDataCTRL>
	}
}
81117000:	0001883a 	nop
81117004:	e037883a 	mov	sp,fp
81117008:	dfc00117 	ldw	ra,4(sp)
8111700c:	df000017 	ldw	fp,0(sp)
81117010:	dec00204 	addi	sp,sp,8
81117014:	f800283a 	ret

81117018 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117018:	defff904 	addi	sp,sp,-28
8111701c:	de00012e 	bgeu	sp,et,81117024 <vSendCmdQToDataCTRL_PRIO+0xc>
81117020:	003b68fa 	trap	3
81117024:	dfc00615 	stw	ra,24(sp)
81117028:	df000515 	stw	fp,20(sp)
8111702c:	df000504 	addi	fp,sp,20
81117030:	2807883a 	mov	r3,r5
81117034:	3005883a 	mov	r2,r6
81117038:	e13ffd05 	stb	r4,-12(fp)
8111703c:	e0fffe05 	stb	r3,-8(fp)
81117040:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81117044:	00800404 	movi	r2,16
81117048:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111704c:	e0bffd03 	ldbu	r2,-12(fp)
81117050:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117054:	e0bffe03 	ldbu	r2,-8(fp)
81117058:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111705c:	e0bfff03 	ldbu	r2,-4(fp)
81117060:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81117064:	d0a05f17 	ldw	r2,-32388(gp)
81117068:	e0fffc17 	ldw	r3,-16(fp)
8111706c:	180b883a 	mov	r5,r3
81117070:	1009883a 	mov	r4,r2
81117074:	113f4b40 	call	8113f4b4 <OSQPostFront>
81117078:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111707c:	e0bffb03 	ldbu	r2,-20(fp)
81117080:	10000126 	beq	r2,zero,81117088 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81117084:	111e9bc0 	call	8111e9bc <vFailSendMsgFeeCTRL>
	}
}
81117088:	0001883a 	nop
8111708c:	e037883a 	mov	sp,fp
81117090:	dfc00117 	ldw	ra,4(sp)
81117094:	df000017 	ldw	fp,0(sp)
81117098:	dec00204 	addi	sp,sp,8
8111709c:	f800283a 	ret

811170a0 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
811170a0:	defffc04 	addi	sp,sp,-16
811170a4:	de00012e 	bgeu	sp,et,811170ac <vMebInit+0xc>
811170a8:	003b68fa 	trap	3
811170ac:	dfc00315 	stw	ra,12(sp)
811170b0:	df000215 	stw	fp,8(sp)
811170b4:	df000204 	addi	fp,sp,8
811170b8:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
811170bc:	e0bfff17 	ldw	r2,-4(fp)
811170c0:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
811170c4:	e0bfff17 	ldw	r2,-4(fp)
811170c8:	00c00044 	movi	r3,1
811170cc:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811170d0:	d0a06917 	ldw	r2,-32348(gp)
811170d4:	1009883a 	mov	r4,r2
811170d8:	113ee7c0 	call	8113ee7c <OSQFlush>
811170dc:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
811170e0:	e0bffe03 	ldbu	r2,-8(fp)
811170e4:	10000126 	beq	r2,zero,811170ec <vMebInit+0x4c>
		vFailFlushMEBQueue();
811170e8:	111eb4c0 	call	8111eb4c <vFailFlushMEBQueue>
	}
}
811170ec:	0001883a 	nop
811170f0:	e037883a 	mov	sp,fp
811170f4:	dfc00117 	ldw	ra,4(sp)
811170f8:	df000017 	ldw	fp,0(sp)
811170fc:	dec00204 	addi	sp,sp,8
81117100:	f800283a 	ret

81117104 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81117104:	defffe04 	addi	sp,sp,-8
81117108:	de00012e 	bgeu	sp,et,81117110 <vSwapMemmory+0xc>
8111710c:	003b68fa 	trap	3
81117110:	df000115 	stw	fp,4(sp)
81117114:	df000104 	addi	fp,sp,4
81117118:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
8111711c:	e0bfff17 	ldw	r2,-4(fp)
81117120:	10800203 	ldbu	r2,8(r2)
81117124:	10803fcc 	andi	r2,r2,255
81117128:	10c00044 	addi	r3,r2,1
8111712c:	00a00034 	movhi	r2,32768
81117130:	10800044 	addi	r2,r2,1
81117134:	1884703a 	and	r2,r3,r2
81117138:	1000040e 	bge	r2,zero,8111714c <vSwapMemmory+0x48>
8111713c:	10bfffc4 	addi	r2,r2,-1
81117140:	00ffff84 	movi	r3,-2
81117144:	10c4b03a 	or	r2,r2,r3
81117148:	10800044 	addi	r2,r2,1
8111714c:	1007883a 	mov	r3,r2
81117150:	e0bfff17 	ldw	r2,-4(fp)
81117154:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81117158:	e0bfff17 	ldw	r2,-4(fp)
8111715c:	10800243 	ldbu	r2,9(r2)
81117160:	10803fcc 	andi	r2,r2,255
81117164:	10c00044 	addi	r3,r2,1
81117168:	00a00034 	movhi	r2,32768
8111716c:	10800044 	addi	r2,r2,1
81117170:	1884703a 	and	r2,r3,r2
81117174:	1000040e 	bge	r2,zero,81117188 <vSwapMemmory+0x84>
81117178:	10bfffc4 	addi	r2,r2,-1
8111717c:	00ffff84 	movi	r3,-2
81117180:	10c4b03a 	or	r2,r2,r3
81117184:	10800044 	addi	r2,r2,1
81117188:	1007883a 	mov	r3,r2
8111718c:	e0bfff17 	ldw	r2,-4(fp)
81117190:	10c00245 	stb	r3,9(r2)

}
81117194:	0001883a 	nop
81117198:	e037883a 	mov	sp,fp
8111719c:	df000017 	ldw	fp,0(sp)
811171a0:	dec00104 	addi	sp,sp,4
811171a4:	f800283a 	ret

811171a8 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
811171a8:	defffc04 	addi	sp,sp,-16
811171ac:	de00012e 	bgeu	sp,et,811171b4 <vReleaseSyncMessages+0xc>
811171b0:	003b68fa 	trap	3
811171b4:	dfc00315 	stw	ra,12(sp)
811171b8:	df000215 	stw	fp,8(sp)
811171bc:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
811171c0:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
811171c4:	00bff844 	movi	r2,-31
811171c8:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811171cc:	e03ffe05 	stb	zero,-8(fp)
811171d0:	00001606 	br	8111722c <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811171d4:	e0bffe03 	ldbu	r2,-8(fp)
811171d8:	10800444 	addi	r2,r2,17
811171dc:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
811171e0:	e0bffe03 	ldbu	r2,-8(fp)
811171e4:	1085883a 	add	r2,r2,r2
811171e8:	1087883a 	add	r3,r2,r2
811171ec:	d0a05c04 	addi	r2,gp,-32400
811171f0:	1885883a 	add	r2,r3,r2
811171f4:	10800017 	ldw	r2,0(r2)
811171f8:	e0ffff17 	ldw	r3,-4(fp)
811171fc:	180b883a 	mov	r5,r3
81117200:	1009883a 	mov	r4,r2
81117204:	113f3440 	call	8113f344 <OSQPost>
81117208:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
8111720c:	e0bffe43 	ldbu	r2,-7(fp)
81117210:	10000326 	beq	r2,zero,81117220 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81117214:	e0bffe03 	ldbu	r2,-8(fp)
81117218:	1009883a 	mov	r4,r2
8111721c:	111e8800 	call	8111e880 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81117220:	e0bffe03 	ldbu	r2,-8(fp)
81117224:	10800044 	addi	r2,r2,1
81117228:	e0bffe05 	stb	r2,-8(fp)
8111722c:	e0bffe03 	ldbu	r2,-8(fp)
81117230:	103fe826 	beq	r2,zero,811171d4 <__reset+0xfb0f71d4>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81117234:	0001883a 	nop
81117238:	e037883a 	mov	sp,fp
8111723c:	dfc00117 	ldw	ra,4(sp)
81117240:	df000017 	ldw	fp,0(sp)
81117244:	dec00204 	addi	sp,sp,8
81117248:	f800283a 	ret

8111724c <vStackMonitor>:
    }
}

#else
#if DEBUG_ON
void vStackMonitor(void *task_data) {
8111724c:	defff804 	addi	sp,sp,-32
81117250:	de00012e 	bgeu	sp,et,81117258 <vStackMonitor+0xc>
81117254:	003b68fa 	trap	3
81117258:	dfc00715 	stw	ra,28(sp)
8111725c:	df000615 	stw	fp,24(sp)
81117260:	df000604 	addi	fp,sp,24
81117264:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81117268:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
8111726c:	d0a06217 	ldw	r2,-32376(gp)
81117270:	100f883a 	mov	r7,r2
81117274:	018006c4 	movi	r6,27
81117278:	01400044 	movi	r5,1
8111727c:	01204574 	movhi	r4,33045
81117280:	213d6a04 	addi	r4,r4,-2648
81117284:	11230300 	call	81123030 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81117288:	d0a06217 	ldw	r2,-32376(gp)
8111728c:	100f883a 	mov	r7,r2
81117290:	01800b04 	movi	r6,44
81117294:	01400044 	movi	r5,1
81117298:	01204574 	movhi	r4,33045
8111729c:	213d7104 	addi	r4,r4,-2620
811172a0:	11230300 	call	81123030 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
811172a4:	d0a06217 	ldw	r2,-32376(gp)
811172a8:	100f883a 	mov	r7,r2
811172ac:	01800f84 	movi	r6,62
811172b0:	01400044 	movi	r5,1
811172b4:	01204574 	movhi	r4,33045
811172b8:	213d7d04 	addi	r4,r4,-2572
811172bc:	11230300 	call	81123030 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
811172c0:	e0bffd04 	addi	r2,fp,-12
811172c4:	100b883a 	mov	r5,r2
811172c8:	01000804 	movi	r4,32
811172cc:	11417680 	call	81141768 <OSTaskStkChk>
811172d0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
811172d4:	e0bffc03 	ldbu	r2,-16(fp)
811172d8:	10000f1e 	bne	r2,zero,81117318 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811172dc:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
811172e0:	e0fffd17 	ldw	r3,-12(fp)
811172e4:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811172e8:	188b883a 	add	r5,r3,r2
811172ec:	e0bffd17 	ldw	r2,-12(fp)
811172f0:	e0fffe17 	ldw	r3,-8(fp)
811172f4:	d8c00115 	stw	r3,4(sp)
811172f8:	d8800015 	stw	r2,0(sp)
811172fc:	280f883a 	mov	r7,r5
81117300:	01a04574 	movhi	r6,33045
81117304:	31bd8d04 	addi	r6,r6,-2508
81117308:	01604574 	movhi	r5,33045
8111730c:	297d9104 	addi	r5,r5,-2492
81117310:	11229940 	call	81122994 <fprintf>
81117314:	00000706 	br	81117334 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81117318:	d0a06217 	ldw	r2,-32376(gp)
8111731c:	100f883a 	mov	r7,r2
81117320:	01800904 	movi	r6,36
81117324:	01400044 	movi	r5,1
81117328:	01204574 	movhi	r4,33045
8111732c:	213da004 	addi	r4,r4,-2432
81117330:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81117334:	e0bffd04 	addi	r2,fp,-12
81117338:	100b883a 	mov	r5,r2
8111733c:	01000784 	movi	r4,30
81117340:	11417680 	call	81141768 <OSTaskStkChk>
81117344:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117348:	e0bffc03 	ldbu	r2,-16(fp)
8111734c:	10000f1e 	bne	r2,zero,8111738c <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117350:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81117354:	e0fffd17 	ldw	r3,-12(fp)
81117358:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111735c:	188b883a 	add	r5,r3,r2
81117360:	e0bffd17 	ldw	r2,-12(fp)
81117364:	e0fffe17 	ldw	r3,-8(fp)
81117368:	d8c00115 	stw	r3,4(sp)
8111736c:	d8800015 	stw	r2,0(sp)
81117370:	280f883a 	mov	r7,r5
81117374:	01a04574 	movhi	r6,33045
81117378:	31bdaa04 	addi	r6,r6,-2392
8111737c:	01604574 	movhi	r5,33045
81117380:	297d9104 	addi	r5,r5,-2492
81117384:	11229940 	call	81122994 <fprintf>
81117388:	00000706 	br	811173a8 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
8111738c:	d0a06217 	ldw	r2,-32376(gp)
81117390:	100f883a 	mov	r7,r2
81117394:	01800984 	movi	r6,38
81117398:	01400044 	movi	r5,1
8111739c:	01204574 	movhi	r4,33045
811173a0:	213dae04 	addi	r4,r4,-2376
811173a4:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
811173a8:	e0bffd04 	addi	r2,fp,-12
811173ac:	100b883a 	mov	r5,r2
811173b0:	01000704 	movi	r4,28
811173b4:	11417680 	call	81141768 <OSTaskStkChk>
811173b8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811173bc:	e0bffc03 	ldbu	r2,-16(fp)
811173c0:	10000f1e 	bne	r2,zero,81117400 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811173c4:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
811173c8:	e0fffd17 	ldw	r3,-12(fp)
811173cc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811173d0:	188b883a 	add	r5,r3,r2
811173d4:	e0bffd17 	ldw	r2,-12(fp)
811173d8:	e0fffe17 	ldw	r3,-8(fp)
811173dc:	d8c00115 	stw	r3,4(sp)
811173e0:	d8800015 	stw	r2,0(sp)
811173e4:	280f883a 	mov	r7,r5
811173e8:	01a04574 	movhi	r6,33045
811173ec:	31bdb804 	addi	r6,r6,-2336
811173f0:	01604574 	movhi	r5,33045
811173f4:	297d9104 	addi	r5,r5,-2492
811173f8:	11229940 	call	81122994 <fprintf>
811173fc:	00000706 	br	8111741c <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81117400:	d0a06217 	ldw	r2,-32376(gp)
81117404:	100f883a 	mov	r7,r2
81117408:	01800884 	movi	r6,34
8111740c:	01400044 	movi	r5,1
81117410:	01204574 	movhi	r4,33045
81117414:	213dbb04 	addi	r4,r4,-2324
81117418:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
8111741c:	e0bffd04 	addi	r2,fp,-12
81117420:	100b883a 	mov	r5,r2
81117424:	010006c4 	movi	r4,27
81117428:	11417680 	call	81141768 <OSTaskStkChk>
8111742c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117430:	e0bffc03 	ldbu	r2,-16(fp)
81117434:	10000f1e 	bne	r2,zero,81117474 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117438:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
8111743c:	e0fffd17 	ldw	r3,-12(fp)
81117440:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117444:	188b883a 	add	r5,r3,r2
81117448:	e0bffd17 	ldw	r2,-12(fp)
8111744c:	e0fffe17 	ldw	r3,-8(fp)
81117450:	d8c00115 	stw	r3,4(sp)
81117454:	d8800015 	stw	r2,0(sp)
81117458:	280f883a 	mov	r7,r5
8111745c:	01a04574 	movhi	r6,33045
81117460:	31bdc404 	addi	r6,r6,-2288
81117464:	01604574 	movhi	r5,33045
81117468:	297d9104 	addi	r5,r5,-2492
8111746c:	11229940 	call	81122994 <fprintf>
81117470:	00000706 	br	81117490 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81117474:	d0a06217 	ldw	r2,-32376(gp)
81117478:	100f883a 	mov	r7,r2
8111747c:	018008c4 	movi	r6,35
81117480:	01400044 	movi	r5,1
81117484:	01204574 	movhi	r4,33045
81117488:	213dc804 	addi	r4,r4,-2272
8111748c:	11230300 	call	81123030 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81117490:	e0bffd04 	addi	r2,fp,-12
81117494:	100b883a 	mov	r5,r2
81117498:	01000684 	movi	r4,26
8111749c:	11417680 	call	81141768 <OSTaskStkChk>
811174a0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811174a4:	e0bffc03 	ldbu	r2,-16(fp)
811174a8:	10000f1e 	bne	r2,zero,811174e8 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811174ac:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
811174b0:	e0fffd17 	ldw	r3,-12(fp)
811174b4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811174b8:	188b883a 	add	r5,r3,r2
811174bc:	e0bffd17 	ldw	r2,-12(fp)
811174c0:	e0fffe17 	ldw	r3,-8(fp)
811174c4:	d8c00115 	stw	r3,4(sp)
811174c8:	d8800015 	stw	r2,0(sp)
811174cc:	280f883a 	mov	r7,r5
811174d0:	01a04574 	movhi	r6,33045
811174d4:	31bdd104 	addi	r6,r6,-2236
811174d8:	01604574 	movhi	r5,33045
811174dc:	297d9104 	addi	r5,r5,-2492
811174e0:	11229940 	call	81122994 <fprintf>
811174e4:	00000706 	br	81117504 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
811174e8:	d0a06217 	ldw	r2,-32376(gp)
811174ec:	100f883a 	mov	r7,r2
811174f0:	01800884 	movi	r6,34
811174f4:	01400044 	movi	r5,1
811174f8:	01204574 	movhi	r4,33045
811174fc:	213dd404 	addi	r4,r4,-2224
81117500:	11230300 	call	81123030 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81117504:	e0bffd04 	addi	r2,fp,-12
81117508:	100b883a 	mov	r5,r2
8111750c:	01000644 	movi	r4,25
81117510:	11417680 	call	81141768 <OSTaskStkChk>
81117514:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117518:	e0bffc03 	ldbu	r2,-16(fp)
8111751c:	10000f1e 	bne	r2,zero,8111755c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117520:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81117524:	e0fffd17 	ldw	r3,-12(fp)
81117528:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111752c:	188b883a 	add	r5,r3,r2
81117530:	e0bffd17 	ldw	r2,-12(fp)
81117534:	e0fffe17 	ldw	r3,-8(fp)
81117538:	d8c00115 	stw	r3,4(sp)
8111753c:	d8800015 	stw	r2,0(sp)
81117540:	280f883a 	mov	r7,r5
81117544:	01a04574 	movhi	r6,33045
81117548:	31bddd04 	addi	r6,r6,-2188
8111754c:	01604574 	movhi	r5,33045
81117550:	297d9104 	addi	r5,r5,-2492
81117554:	11229940 	call	81122994 <fprintf>
81117558:	00000706 	br	81117578 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8111755c:	d0a06217 	ldw	r2,-32376(gp)
81117560:	100f883a 	mov	r7,r2
81117564:	01800884 	movi	r6,34
81117568:	01400044 	movi	r5,1
8111756c:	01204574 	movhi	r4,33045
81117570:	213de004 	addi	r4,r4,-2176
81117574:	11230300 	call	81123030 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81117578:	e0bffd04 	addi	r2,fp,-12
8111757c:	100b883a 	mov	r5,r2
81117580:	01000044 	movi	r4,1
81117584:	11417680 	call	81141768 <OSTaskStkChk>
81117588:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111758c:	e0bffc03 	ldbu	r2,-16(fp)
81117590:	10000f1e 	bne	r2,zero,811175d0 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117594:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81117598:	e0fffd17 	ldw	r3,-12(fp)
8111759c:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811175a0:	188b883a 	add	r5,r3,r2
811175a4:	e0bffd17 	ldw	r2,-12(fp)
811175a8:	e0fffe17 	ldw	r3,-8(fp)
811175ac:	d8c00115 	stw	r3,4(sp)
811175b0:	d8800015 	stw	r2,0(sp)
811175b4:	280f883a 	mov	r7,r5
811175b8:	01a04574 	movhi	r6,33045
811175bc:	31bde904 	addi	r6,r6,-2140
811175c0:	01604574 	movhi	r5,33045
811175c4:	297d9104 	addi	r5,r5,-2492
811175c8:	11229940 	call	81122994 <fprintf>
811175cc:	00000706 	br	811175ec <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
811175d0:	d0a06217 	ldw	r2,-32376(gp)
811175d4:	100f883a 	mov	r7,r2
811175d8:	01800804 	movi	r6,32
811175dc:	01400044 	movi	r5,1
811175e0:	01204574 	movhi	r4,33045
811175e4:	213dec04 	addi	r4,r4,-2128
811175e8:	11230300 	call	81123030 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
811175ec:	e0bffd04 	addi	r2,fp,-12
811175f0:	100b883a 	mov	r5,r2
811175f4:	010002c4 	movi	r4,11
811175f8:	11417680 	call	81141768 <OSTaskStkChk>
811175fc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117600:	e0bffc03 	ldbu	r2,-16(fp)
81117604:	10000f1e 	bne	r2,zero,81117644 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117608:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
8111760c:	e0fffd17 	ldw	r3,-12(fp)
81117610:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117614:	188b883a 	add	r5,r3,r2
81117618:	e0bffd17 	ldw	r2,-12(fp)
8111761c:	e0fffe17 	ldw	r3,-8(fp)
81117620:	d8c00115 	stw	r3,4(sp)
81117624:	d8800015 	stw	r2,0(sp)
81117628:	280f883a 	mov	r7,r5
8111762c:	01a04574 	movhi	r6,33045
81117630:	31bdf504 	addi	r6,r6,-2092
81117634:	01604574 	movhi	r5,33045
81117638:	297d9104 	addi	r5,r5,-2492
8111763c:	11229940 	call	81122994 <fprintf>
81117640:	00000706 	br	81117660 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81117644:	d0a06217 	ldw	r2,-32376(gp)
81117648:	100f883a 	mov	r7,r2
8111764c:	018008c4 	movi	r6,35
81117650:	01400044 	movi	r5,1
81117654:	01204574 	movhi	r4,33045
81117658:	213df804 	addi	r4,r4,-2080
8111765c:	11230300 	call	81123030 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81117660:	e0bffd04 	addi	r2,fp,-12
81117664:	100b883a 	mov	r5,r2
81117668:	01000304 	movi	r4,12
8111766c:	11417680 	call	81141768 <OSTaskStkChk>
81117670:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117674:	e0bffc03 	ldbu	r2,-16(fp)
81117678:	10000f1e 	bne	r2,zero,811176b8 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111767c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81117680:	e0fffd17 	ldw	r3,-12(fp)
81117684:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117688:	188b883a 	add	r5,r3,r2
8111768c:	e0bffd17 	ldw	r2,-12(fp)
81117690:	e0fffe17 	ldw	r3,-8(fp)
81117694:	d8c00115 	stw	r3,4(sp)
81117698:	d8800015 	stw	r2,0(sp)
8111769c:	280f883a 	mov	r7,r5
811176a0:	01a04574 	movhi	r6,33045
811176a4:	31be0104 	addi	r6,r6,-2044
811176a8:	01604574 	movhi	r5,33045
811176ac:	297d9104 	addi	r5,r5,-2492
811176b0:	11229940 	call	81122994 <fprintf>
811176b4:	00000706 	br	811176d4 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
811176b8:	d0a06217 	ldw	r2,-32376(gp)
811176bc:	100f883a 	mov	r7,r2
811176c0:	018008c4 	movi	r6,35
811176c4:	01400044 	movi	r5,1
811176c8:	01204574 	movhi	r4,33045
811176cc:	213e0404 	addi	r4,r4,-2032
811176d0:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
811176d4:	e0bffd04 	addi	r2,fp,-12
811176d8:	100b883a 	mov	r5,r2
811176dc:	01000344 	movi	r4,13
811176e0:	11417680 	call	81141768 <OSTaskStkChk>
811176e4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811176e8:	e0bffc03 	ldbu	r2,-16(fp)
811176ec:	10000f1e 	bne	r2,zero,8111772c <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811176f0:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
811176f4:	e0fffd17 	ldw	r3,-12(fp)
811176f8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811176fc:	188b883a 	add	r5,r3,r2
81117700:	e0bffd17 	ldw	r2,-12(fp)
81117704:	e0fffe17 	ldw	r3,-8(fp)
81117708:	d8c00115 	stw	r3,4(sp)
8111770c:	d8800015 	stw	r2,0(sp)
81117710:	280f883a 	mov	r7,r5
81117714:	01a04574 	movhi	r6,33045
81117718:	31be0d04 	addi	r6,r6,-1996
8111771c:	01604574 	movhi	r5,33045
81117720:	297d9104 	addi	r5,r5,-2492
81117724:	11229940 	call	81122994 <fprintf>
81117728:	00000706 	br	81117748 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
8111772c:	d0a06217 	ldw	r2,-32376(gp)
81117730:	100f883a 	mov	r7,r2
81117734:	018008c4 	movi	r6,35
81117738:	01400044 	movi	r5,1
8111773c:	01204574 	movhi	r4,33045
81117740:	213e1004 	addi	r4,r4,-1984
81117744:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81117748:	e0bffd04 	addi	r2,fp,-12
8111774c:	100b883a 	mov	r5,r2
81117750:	01000384 	movi	r4,14
81117754:	11417680 	call	81141768 <OSTaskStkChk>
81117758:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111775c:	e0bffc03 	ldbu	r2,-16(fp)
81117760:	10000f1e 	bne	r2,zero,811177a0 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117764:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81117768:	e0fffd17 	ldw	r3,-12(fp)
8111776c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117770:	188b883a 	add	r5,r3,r2
81117774:	e0bffd17 	ldw	r2,-12(fp)
81117778:	e0fffe17 	ldw	r3,-8(fp)
8111777c:	d8c00115 	stw	r3,4(sp)
81117780:	d8800015 	stw	r2,0(sp)
81117784:	280f883a 	mov	r7,r5
81117788:	01a04574 	movhi	r6,33045
8111778c:	31be1904 	addi	r6,r6,-1948
81117790:	01604574 	movhi	r5,33045
81117794:	297d9104 	addi	r5,r5,-2492
81117798:	11229940 	call	81122994 <fprintf>
8111779c:	00000706 	br	811177bc <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
811177a0:	d0a06217 	ldw	r2,-32376(gp)
811177a4:	100f883a 	mov	r7,r2
811177a8:	018008c4 	movi	r6,35
811177ac:	01400044 	movi	r5,1
811177b0:	01204574 	movhi	r4,33045
811177b4:	213e1c04 	addi	r4,r4,-1936
811177b8:	11230300 	call	81123030 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
811177bc:	e0bffd04 	addi	r2,fp,-12
811177c0:	100b883a 	mov	r5,r2
811177c4:	010003c4 	movi	r4,15
811177c8:	11417680 	call	81141768 <OSTaskStkChk>
811177cc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811177d0:	e0bffc03 	ldbu	r2,-16(fp)
811177d4:	10000f1e 	bne	r2,zero,81117814 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811177d8:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
811177dc:	e0fffd17 	ldw	r3,-12(fp)
811177e0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811177e4:	188b883a 	add	r5,r3,r2
811177e8:	e0bffd17 	ldw	r2,-12(fp)
811177ec:	e0fffe17 	ldw	r3,-8(fp)
811177f0:	d8c00115 	stw	r3,4(sp)
811177f4:	d8800015 	stw	r2,0(sp)
811177f8:	280f883a 	mov	r7,r5
811177fc:	01a04574 	movhi	r6,33045
81117800:	31be2504 	addi	r6,r6,-1900
81117804:	01604574 	movhi	r5,33045
81117808:	297d9104 	addi	r5,r5,-2492
8111780c:	11229940 	call	81122994 <fprintf>
81117810:	00000706 	br	81117830 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81117814:	d0a06217 	ldw	r2,-32376(gp)
81117818:	100f883a 	mov	r7,r2
8111781c:	018008c4 	movi	r6,35
81117820:	01400044 	movi	r5,1
81117824:	01204574 	movhi	r4,33045
81117828:	213e2804 	addi	r4,r4,-1888
8111782c:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81117830:	e0bffd04 	addi	r2,fp,-12
81117834:	100b883a 	mov	r5,r2
81117838:	01000404 	movi	r4,16
8111783c:	11417680 	call	81141768 <OSTaskStkChk>
81117840:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117844:	e0bffc03 	ldbu	r2,-16(fp)
81117848:	10000f1e 	bne	r2,zero,81117888 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111784c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81117850:	e0fffd17 	ldw	r3,-12(fp)
81117854:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117858:	188b883a 	add	r5,r3,r2
8111785c:	e0bffd17 	ldw	r2,-12(fp)
81117860:	e0fffe17 	ldw	r3,-8(fp)
81117864:	d8c00115 	stw	r3,4(sp)
81117868:	d8800015 	stw	r2,0(sp)
8111786c:	280f883a 	mov	r7,r5
81117870:	01a04574 	movhi	r6,33045
81117874:	31be3104 	addi	r6,r6,-1852
81117878:	01604574 	movhi	r5,33045
8111787c:	297d9104 	addi	r5,r5,-2492
81117880:	11229940 	call	81122994 <fprintf>
81117884:	00000706 	br	811178a4 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81117888:	d0a06217 	ldw	r2,-32376(gp)
8111788c:	100f883a 	mov	r7,r2
81117890:	018008c4 	movi	r6,35
81117894:	01400044 	movi	r5,1
81117898:	01204574 	movhi	r4,33045
8111789c:	213e3404 	addi	r4,r4,-1840
811178a0:	11230300 	call	81123030 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
811178a4:	e0bffd04 	addi	r2,fp,-12
811178a8:	100b883a 	mov	r5,r2
811178ac:	01000284 	movi	r4,10
811178b0:	11417680 	call	81141768 <OSTaskStkChk>
811178b4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811178b8:	e0bffc03 	ldbu	r2,-16(fp)
811178bc:	10000f1e 	bne	r2,zero,811178fc <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811178c0:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
811178c4:	e0fffd17 	ldw	r3,-12(fp)
811178c8:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811178cc:	188b883a 	add	r5,r3,r2
811178d0:	e0bffd17 	ldw	r2,-12(fp)
811178d4:	e0fffe17 	ldw	r3,-8(fp)
811178d8:	d8c00115 	stw	r3,4(sp)
811178dc:	d8800015 	stw	r2,0(sp)
811178e0:	280f883a 	mov	r7,r5
811178e4:	01a04574 	movhi	r6,33045
811178e8:	31be3d04 	addi	r6,r6,-1804
811178ec:	01604574 	movhi	r5,33045
811178f0:	297d9104 	addi	r5,r5,-2492
811178f4:	11229940 	call	81122994 <fprintf>
811178f8:	00000706 	br	81117918 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
811178fc:	d0a06217 	ldw	r2,-32376(gp)
81117900:	100f883a 	mov	r7,r2
81117904:	01800884 	movi	r6,34
81117908:	01400044 	movi	r5,1
8111790c:	01204574 	movhi	r4,33045
81117910:	213e4004 	addi	r4,r4,-1792
81117914:	11230300 	call	81123030 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81117918:	e0bffd04 	addi	r2,fp,-12
8111791c:	100b883a 	mov	r5,r2
81117920:	01000244 	movi	r4,9
81117924:	11417680 	call	81141768 <OSTaskStkChk>
81117928:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111792c:	e0bffc03 	ldbu	r2,-16(fp)
81117930:	10000f1e 	bne	r2,zero,81117970 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117934:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81117938:	e0fffd17 	ldw	r3,-12(fp)
8111793c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117940:	188b883a 	add	r5,r3,r2
81117944:	e0bffd17 	ldw	r2,-12(fp)
81117948:	e0fffe17 	ldw	r3,-8(fp)
8111794c:	d8c00115 	stw	r3,4(sp)
81117950:	d8800015 	stw	r2,0(sp)
81117954:	280f883a 	mov	r7,r5
81117958:	01a04574 	movhi	r6,33045
8111795c:	31be4904 	addi	r6,r6,-1756
81117960:	01604574 	movhi	r5,33045
81117964:	297d9104 	addi	r5,r5,-2492
81117968:	11229940 	call	81122994 <fprintf>
8111796c:	00000706 	br	8111798c <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81117970:	d0a06217 	ldw	r2,-32376(gp)
81117974:	100f883a 	mov	r7,r2
81117978:	01800844 	movi	r6,33
8111797c:	01400044 	movi	r5,1
81117980:	01204574 	movhi	r4,33045
81117984:	213e4c04 	addi	r4,r4,-1744
81117988:	11230300 	call	81123030 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
8111798c:	e0bffd04 	addi	r2,fp,-12
81117990:	100b883a 	mov	r5,r2
81117994:	01000204 	movi	r4,8
81117998:	11417680 	call	81141768 <OSTaskStkChk>
8111799c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811179a0:	e0bffc03 	ldbu	r2,-16(fp)
811179a4:	10000f1e 	bne	r2,zero,811179e4 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811179a8:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
811179ac:	e0fffd17 	ldw	r3,-12(fp)
811179b0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811179b4:	188b883a 	add	r5,r3,r2
811179b8:	e0bffd17 	ldw	r2,-12(fp)
811179bc:	e0fffe17 	ldw	r3,-8(fp)
811179c0:	d8c00115 	stw	r3,4(sp)
811179c4:	d8800015 	stw	r2,0(sp)
811179c8:	280f883a 	mov	r7,r5
811179cc:	01a04574 	movhi	r6,33045
811179d0:	31be5504 	addi	r6,r6,-1708
811179d4:	01604574 	movhi	r5,33045
811179d8:	297d9104 	addi	r5,r5,-2492
811179dc:	11229940 	call	81122994 <fprintf>
811179e0:	00000706 	br	81117a00 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
811179e4:	d0a06217 	ldw	r2,-32376(gp)
811179e8:	100f883a 	mov	r7,r2
811179ec:	018007c4 	movi	r6,31
811179f0:	01400044 	movi	r5,1
811179f4:	01204574 	movhi	r4,33045
811179f8:	213e5804 	addi	r4,r4,-1696
811179fc:	11230300 	call	81123030 <fwrite>
    	}		


    	fprintf(fp, "\n" );
81117a00:	d0a06217 	ldw	r2,-32376(gp)
81117a04:	100b883a 	mov	r5,r2
81117a08:	01000284 	movi	r4,10
81117a0c:	1122a0c0 	call	81122a0c <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81117a10:	000f883a 	mov	r7,zero
81117a14:	01800284 	movi	r6,10
81117a18:	000b883a 	mov	r5,zero
81117a1c:	0009883a 	mov	r4,zero
81117a20:	1141dcc0 	call	81141dcc <OSTimeDlyHMSM>
    }
81117a24:	003e1806 	br	81117288 <__reset+0xfb0f7288>

81117a28 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81117a28:	defffc04 	addi	sp,sp,-16
81117a2c:	de00012e 	bgeu	sp,et,81117a34 <vTimeoutCheckerTaskv2+0xc>
81117a30:	003b68fa 	trap	3
81117a34:	dfc00315 	stw	ra,12(sp)
81117a38:	df000215 	stw	fp,8(sp)
81117a3c:	df000204 	addi	fp,sp,8
81117a40:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81117a44:	e03ffe05 	stb	zero,-8(fp)

    #if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81117a48:	00a045f4 	movhi	r2,33047
81117a4c:	10a00404 	addi	r2,r2,-32752
81117a50:	10800e8b 	ldhu	r2,58(r2)
81117a54:	10bfffcc 	andi	r2,r2,65535
81117a58:	10800168 	cmpgeui	r2,r2,5
81117a5c:	1000071e 	bne	r2,zero,81117a7c <vTimeoutCheckerTaskv2+0x54>
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81117a60:	d0a06217 	ldw	r2,-32376(gp)
81117a64:	100f883a 	mov	r7,r2
81117a68:	01800844 	movi	r6,33
81117a6c:	01400044 	movi	r5,1
81117a70:	01204574 	movhi	r4,33045
81117a74:	213e6004 	addi	r4,r4,-1664
81117a78:	11230300 	call	81123030 <fwrite>
	}
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81117a7c:	d0a06717 	ldw	r2,-32356(gp)
81117a80:	e1bffe04 	addi	r6,fp,-8
81117a84:	000b883a 	mov	r5,zero
81117a88:	1009883a 	mov	r4,r2
81117a8c:	113fe340 	call	8113fe34 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81117a90:	e0bffe03 	ldbu	r2,-8(fp)
81117a94:	10803fcc 	andi	r2,r2,255
81117a98:	1000021e 	bne	r2,zero,81117aa4 <vTimeoutCheckerTaskv2+0x7c>
            /* Just check the restransmission buffer */
            vCheck();
81117a9c:	1117aac0 	call	81117aac <vCheck>
81117aa0:	003ff606 	br	81117a7c <__reset+0xfb0f7a7c>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81117aa4:	111d6e00 	call	8111d6e0 <vFailGetBlockingSemTimeoutTask>
        }
    }
81117aa8:	003ff406 	br	81117a7c <__reset+0xfb0f7a7c>

81117aac <vCheck>:
}


void vCheck( void ) {
81117aac:	defffd04 	addi	sp,sp,-12
81117ab0:	de00012e 	bgeu	sp,et,81117ab8 <vCheck+0xc>
81117ab4:	003b68fa 	trap	3
81117ab8:	dfc00215 	stw	ra,8(sp)
81117abc:	df000115 	stw	fp,4(sp)
81117ac0:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81117ac4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81117ac8:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81117acc:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81117ad0:	d0a06883 	ldbu	r2,-32350(gp)
81117ad4:	10803fcc 	andi	r2,r2,255
81117ad8:	10800218 	cmpnei	r2,r2,8
81117adc:	1000021e 	bne	r2,zero,81117ae8 <vCheck+0x3c>
81117ae0:	00c00104 	movi	r3,4
81117ae4:	00000106 	br	81117aec <vCheck+0x40>
81117ae8:	0007883a 	mov	r3,zero
81117aec:	d0a07503 	ldbu	r2,-32300(gp)
81117af0:	10803fcc 	andi	r2,r2,255
81117af4:	10800218 	cmpnei	r2,r2,8
81117af8:	1000021e 	bne	r2,zero,81117b04 <vCheck+0x58>
81117afc:	00800084 	movi	r2,2
81117b00:	00000106 	br	81117b08 <vCheck+0x5c>
81117b04:	0005883a 	mov	r2,zero
81117b08:	1884b03a 	or	r2,r3,r2
81117b0c:	1007883a 	mov	r3,r2
81117b10:	d0a07543 	ldbu	r2,-32299(gp)
81117b14:	10803fcc 	andi	r2,r2,255
81117b18:	108001a0 	cmpeqi	r2,r2,6
81117b1c:	1884b03a 	or	r2,r3,r2
81117b20:	1007883a 	mov	r3,r2
81117b24:	e0bfff03 	ldbu	r2,-4(fp)
81117b28:	1884b03a 	or	r2,r3,r2
81117b2c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81117b30:	e0bfff03 	ldbu	r2,-4(fp)
81117b34:	108001d8 	cmpnei	r2,r2,7
81117b38:	10003d26 	beq	r2,zero,81117c30 <vCheck+0x184>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81117b3c:	d0a07417 	ldw	r2,-32304(gp)
81117b40:	e0ffff44 	addi	r3,fp,-3
81117b44:	180d883a 	mov	r6,r3
81117b48:	000b883a 	mov	r5,zero
81117b4c:	1009883a 	mov	r4,r2
81117b50:	113de280 	call	8113de28 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81117b54:	e0bfff43 	ldbu	r2,-3(fp)
81117b58:	10803fcc 	andi	r2,r2,255
81117b5c:	10000e26 	beq	r2,zero,81117b98 <vCheck+0xec>
        /* Should never get here, is a blocking operation */
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81117b60:	00a045f4 	movhi	r2,33047
81117b64:	10a00404 	addi	r2,r2,-32752
81117b68:	10800e8b 	ldhu	r2,58(r2)
81117b6c:	10bfffcc 	andi	r2,r2,65535
81117b70:	108001e8 	cmpgeui	r2,r2,7
81117b74:	1000301e 	bne	r2,zero,81117c38 <vCheck+0x18c>
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81117b78:	d0a06217 	ldw	r2,-32376(gp)
81117b7c:	100f883a 	mov	r7,r2
81117b80:	01800f04 	movi	r6,60
81117b84:	01400044 	movi	r5,1
81117b88:	01204574 	movhi	r4,33045
81117b8c:	213e6904 	addi	r4,r4,-1628
81117b90:	11230300 	call	81123030 <fwrite>
    	}
		#endif
        return;
81117b94:	00002806 	br	81117c38 <vCheck+0x18c>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81117b98:	e0bfff03 	ldbu	r2,-4(fp)
81117b9c:	1080004c 	andi	r2,r2,1
81117ba0:	10803fcc 	andi	r2,r2,255
81117ba4:	1000021e 	bne	r2,zero,81117bb0 <vCheck+0x104>
        vCheckRetransmission128();
81117ba8:	1117c500 	call	81117c50 <vCheckRetransmission128>
81117bac:	00000506 	br	81117bc4 <vCheck+0x118>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81117bb0:	01800604 	movi	r6,24
81117bb4:	000b883a 	mov	r5,zero
81117bb8:	012045b4 	movhi	r4,33046
81117bbc:	21002204 	addi	r4,r4,136
81117bc0:	1123b940 	call	81123b94 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81117bc4:	e0bfff03 	ldbu	r2,-4(fp)
81117bc8:	1080008c 	andi	r2,r2,2
81117bcc:	10803fcc 	andi	r2,r2,255
81117bd0:	1000021e 	bne	r2,zero,81117bdc <vCheck+0x130>
        vCheckRetransmission64();
81117bd4:	1117ed40 	call	81117ed4 <vCheckRetransmission64>
81117bd8:	00000506 	br	81117bf0 <vCheck+0x144>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81117bdc:	01800804 	movi	r6,32
81117be0:	000b883a 	mov	r5,zero
81117be4:	012045b4 	movhi	r4,33046
81117be8:	21002804 	addi	r4,r4,160
81117bec:	1123b940 	call	81123b94 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81117bf0:	e0bfff03 	ldbu	r2,-4(fp)
81117bf4:	1080010c 	andi	r2,r2,4
81117bf8:	10803fcc 	andi	r2,r2,255
81117bfc:	1000021e 	bne	r2,zero,81117c08 <vCheck+0x15c>
        vCheckRetransmission32();
81117c00:	11181600 	call	81118160 <vCheckRetransmission32>
81117c04:	00000506 	br	81117c1c <vCheck+0x170>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81117c08:	01800804 	movi	r6,32
81117c0c:	000b883a 	mov	r5,zero
81117c10:	012045b4 	movhi	r4,33046
81117c14:	21003004 	addi	r4,r4,192
81117c18:	1123b940 	call	81123b94 <memset>


    OSMutexPost(xTxUARTMutex);
81117c1c:	d0a07417 	ldw	r2,-32304(gp)
81117c20:	1009883a 	mov	r4,r2
81117c24:	113e3cc0 	call	8113e3cc <OSMutexPost>

    return;
81117c28:	0001883a 	nop
81117c2c:	00000306 	br	81117c3c <vCheck+0x190>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81117c30:	0001883a 	nop
81117c34:	00000106 	br	81117c3c <vCheck+0x190>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
    	}
		#endif
        return;
81117c38:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81117c3c:	e037883a 	mov	sp,fp
81117c40:	dfc00117 	ldw	ra,4(sp)
81117c44:	df000017 	ldw	fp,0(sp)
81117c48:	dec00204 	addi	sp,sp,8
81117c4c:	f800283a 	ret

81117c50 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81117c50:	defffd04 	addi	sp,sp,-12
81117c54:	de00012e 	bgeu	sp,et,81117c5c <vCheckRetransmission128+0xc>
81117c58:	003b68fa 	trap	3
81117c5c:	dfc00215 	stw	ra,8(sp)
81117c60:	df000115 	stw	fp,4(sp)
81117c64:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81117c68:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81117c6c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81117c70:	d0a06e17 	ldw	r2,-32328(gp)
81117c74:	e0ffff44 	addi	r3,fp,-3
81117c78:	180b883a 	mov	r5,r3
81117c7c:	1009883a 	mov	r4,r2
81117c80:	113d7a80 	call	8113d7a8 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117c84:	e0bfff43 	ldbu	r2,-3(fp)
81117c88:	10803fcc 	andi	r2,r2,255
81117c8c:	10008b1e 	bne	r2,zero,81117ebc <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81117c90:	e03fff05 	stb	zero,-4(fp)
81117c94:	00008106 	br	81117e9c <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81117c98:	e0ffff03 	ldbu	r3,-4(fp)
81117c9c:	00a045b4 	movhi	r2,33046
81117ca0:	10802204 	addi	r2,r2,136
81117ca4:	18c7883a 	add	r3,r3,r3
81117ca8:	18c7883a 	add	r3,r3,r3
81117cac:	10c5883a 	add	r2,r2,r3
81117cb0:	10800017 	ldw	r2,0(r2)
81117cb4:	10800058 	cmpnei	r2,r2,1
81117cb8:	1000751e 	bne	r2,zero,81117e90 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81117cbc:	e0ffff03 	ldbu	r3,-4(fp)
81117cc0:	00a045b4 	movhi	r2,33046
81117cc4:	10804004 	addi	r2,r2,256
81117cc8:	18c02324 	muli	r3,r3,140
81117ccc:	10c5883a 	add	r2,r2,r3
81117cd0:	10802004 	addi	r2,r2,128
81117cd4:	10800017 	ldw	r2,0(r2)
81117cd8:	10800058 	cmpnei	r2,r2,1
81117cdc:	1000211e 	bne	r2,zero,81117d64 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117ce0:	e0ffff03 	ldbu	r3,-4(fp)
81117ce4:	00a045b4 	movhi	r2,33046
81117ce8:	10804004 	addi	r2,r2,256
81117cec:	19002324 	muli	r4,r3,140
81117cf0:	1105883a 	add	r2,r2,r4
81117cf4:	10802184 	addi	r2,r2,134
81117cf8:	1080000b 	ldhu	r2,0(r2)
81117cfc:	10800044 	addi	r2,r2,1
81117d00:	100b883a 	mov	r5,r2
81117d04:	00a045b4 	movhi	r2,33046
81117d08:	10804004 	addi	r2,r2,256
81117d0c:	19002324 	muli	r4,r3,140
81117d10:	1105883a 	add	r2,r2,r4
81117d14:	10802184 	addi	r2,r2,134
81117d18:	1140000d 	sth	r5,0(r2)
81117d1c:	00a045b4 	movhi	r2,33046
81117d20:	10804004 	addi	r2,r2,256
81117d24:	18c02324 	muli	r3,r3,140
81117d28:	10c5883a 	add	r2,r2,r3
81117d2c:	10802184 	addi	r2,r2,134
81117d30:	1080000b 	ldhu	r2,0(r2)
81117d34:	10bfffcc 	andi	r2,r2,65535
81117d38:	10a0001c 	xori	r2,r2,32768
81117d3c:	10a00004 	addi	r2,r2,-32768
81117d40:	10800090 	cmplti	r2,r2,2
81117d44:	1000071e 	bne	r2,zero,81117d64 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81117d48:	e0ffff03 	ldbu	r3,-4(fp)
81117d4c:	00a045b4 	movhi	r2,33046
81117d50:	10804004 	addi	r2,r2,256
81117d54:	18c02324 	muli	r3,r3,140
81117d58:	10c5883a 	add	r2,r2,r3
81117d5c:	10802004 	addi	r2,r2,128
81117d60:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81117d64:	e0ffff03 	ldbu	r3,-4(fp)
81117d68:	00a045b4 	movhi	r2,33046
81117d6c:	10804004 	addi	r2,r2,256
81117d70:	18c02324 	muli	r3,r3,140
81117d74:	10c5883a 	add	r2,r2,r3
81117d78:	10802004 	addi	r2,r2,128
81117d7c:	10800017 	ldw	r2,0(r2)
81117d80:	1000431e 	bne	r2,zero,81117e90 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81117d84:	e0bfff03 	ldbu	r2,-4(fp)
81117d88:	10c02324 	muli	r3,r2,140
81117d8c:	00a045b4 	movhi	r2,33046
81117d90:	10804004 	addi	r2,r2,256
81117d94:	1885883a 	add	r2,r3,r2
81117d98:	1009883a 	mov	r4,r2
81117d9c:	1123f640 	call	81123f64 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81117da0:	e0ffff03 	ldbu	r3,-4(fp)
81117da4:	00a045b4 	movhi	r2,33046
81117da8:	10804004 	addi	r2,r2,256
81117dac:	18c02324 	muli	r3,r3,140
81117db0:	10c5883a 	add	r2,r2,r3
81117db4:	10802004 	addi	r2,r2,128
81117db8:	00c00044 	movi	r3,1
81117dbc:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81117dc0:	e0ffff03 	ldbu	r3,-4(fp)
81117dc4:	00a045b4 	movhi	r2,33046
81117dc8:	10804004 	addi	r2,r2,256
81117dcc:	18c02324 	muli	r3,r3,140
81117dd0:	10c5883a 	add	r2,r2,r3
81117dd4:	10802184 	addi	r2,r2,134
81117dd8:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81117ddc:	e0ffff03 	ldbu	r3,-4(fp)
81117de0:	00a045b4 	movhi	r2,33046
81117de4:	10804004 	addi	r2,r2,256
81117de8:	19002324 	muli	r4,r3,140
81117dec:	1105883a 	add	r2,r2,r4
81117df0:	10802204 	addi	r2,r2,136
81117df4:	10800003 	ldbu	r2,0(r2)
81117df8:	10800044 	addi	r2,r2,1
81117dfc:	100b883a 	mov	r5,r2
81117e00:	00a045b4 	movhi	r2,33046
81117e04:	10804004 	addi	r2,r2,256
81117e08:	19002324 	muli	r4,r3,140
81117e0c:	1105883a 	add	r2,r2,r4
81117e10:	10802204 	addi	r2,r2,136
81117e14:	11400005 	stb	r5,0(r2)
81117e18:	00a045b4 	movhi	r2,33046
81117e1c:	10804004 	addi	r2,r2,256
81117e20:	18c02324 	muli	r3,r3,140
81117e24:	10c5883a 	add	r2,r2,r3
81117e28:	10802204 	addi	r2,r2,136
81117e2c:	10800003 	ldbu	r2,0(r2)
81117e30:	10803fcc 	andi	r2,r2,255
81117e34:	108000b0 	cmpltui	r2,r2,2
81117e38:	1000151e 	bne	r2,zero,81117e90 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81117e3c:	e0ffff03 	ldbu	r3,-4(fp)
81117e40:	00a045b4 	movhi	r2,33046
81117e44:	10802204 	addi	r2,r2,136
81117e48:	18c7883a 	add	r3,r3,r3
81117e4c:	18c7883a 	add	r3,r3,r3
81117e50:	10c5883a 	add	r2,r2,r3
81117e54:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81117e58:	d0a07543 	ldbu	r2,-32299(gp)
81117e5c:	10800044 	addi	r2,r2,1
81117e60:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81117e64:	d0a06317 	ldw	r2,-32372(gp)
81117e68:	1009883a 	mov	r4,r2
81117e6c:	11401bc0 	call	811401bc <OSSemPost>
81117e70:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81117e74:	e0bfff43 	ldbu	r2,-3(fp)
81117e78:	10803fcc 	andi	r2,r2,255
81117e7c:	10000426 	beq	r2,zero,81117e90 <vCheckRetransmission128+0x240>
                        SemCount128--;
81117e80:	d0a07543 	ldbu	r2,-32299(gp)
81117e84:	10bfffc4 	addi	r2,r2,-1
81117e88:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81117e8c:	111ce080 	call	8111ce08 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81117e90:	e0bfff03 	ldbu	r2,-4(fp)
81117e94:	10800044 	addi	r2,r2,1
81117e98:	e0bfff05 	stb	r2,-4(fp)
81117e9c:	e0bfff03 	ldbu	r2,-4(fp)
81117ea0:	108001b0 	cmpltui	r2,r2,6
81117ea4:	103f7c1e 	bne	r2,zero,81117c98 <__reset+0xfb0f7c98>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81117ea8:	d0a06e17 	ldw	r2,-32328(gp)
81117eac:	1009883a 	mov	r4,r2
81117eb0:	113e3cc0 	call	8113e3cc <OSMutexPost>

    return;
81117eb4:	0001883a 	nop
81117eb8:	00000106 	br	81117ec0 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81117ebc:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81117ec0:	e037883a 	mov	sp,fp
81117ec4:	dfc00117 	ldw	ra,4(sp)
81117ec8:	df000017 	ldw	fp,0(sp)
81117ecc:	dec00204 	addi	sp,sp,8
81117ed0:	f800283a 	ret

81117ed4 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81117ed4:	defffd04 	addi	sp,sp,-12
81117ed8:	de00012e 	bgeu	sp,et,81117ee0 <vCheckRetransmission64+0xc>
81117edc:	003b68fa 	trap	3
81117ee0:	dfc00215 	stw	ra,8(sp)
81117ee4:	df000115 	stw	fp,4(sp)
81117ee8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81117eec:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81117ef0:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81117ef4:	d0a07117 	ldw	r2,-32316(gp)
81117ef8:	e0ffff44 	addi	r3,fp,-3
81117efc:	180b883a 	mov	r5,r3
81117f00:	1009883a 	mov	r4,r2
81117f04:	113d7a80 	call	8113d7a8 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117f08:	e0bfff43 	ldbu	r2,-3(fp)
81117f0c:	10803fcc 	andi	r2,r2,255
81117f10:	10008d1e 	bne	r2,zero,81118148 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81117f14:	e03fff05 	stb	zero,-4(fp)
81117f18:	00008306 	br	81118128 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81117f1c:	e0ffff03 	ldbu	r3,-4(fp)
81117f20:	00a045b4 	movhi	r2,33046
81117f24:	10802204 	addi	r2,r2,136
81117f28:	18c00184 	addi	r3,r3,6
81117f2c:	18c7883a 	add	r3,r3,r3
81117f30:	18c7883a 	add	r3,r3,r3
81117f34:	10c5883a 	add	r2,r2,r3
81117f38:	10800017 	ldw	r2,0(r2)
81117f3c:	10800058 	cmpnei	r2,r2,1
81117f40:	1000761e 	bne	r2,zero,8111811c <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81117f44:	e0ffff03 	ldbu	r3,-4(fp)
81117f48:	00a04574 	movhi	r2,33045
81117f4c:	109be604 	addi	r2,r2,28568
81117f50:	18c01324 	muli	r3,r3,76
81117f54:	10c5883a 	add	r2,r2,r3
81117f58:	10801004 	addi	r2,r2,64
81117f5c:	10800017 	ldw	r2,0(r2)
81117f60:	10800058 	cmpnei	r2,r2,1
81117f64:	1000211e 	bne	r2,zero,81117fec <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117f68:	e0ffff03 	ldbu	r3,-4(fp)
81117f6c:	00a04574 	movhi	r2,33045
81117f70:	109be604 	addi	r2,r2,28568
81117f74:	19001324 	muli	r4,r3,76
81117f78:	1105883a 	add	r2,r2,r4
81117f7c:	10801184 	addi	r2,r2,70
81117f80:	1080000b 	ldhu	r2,0(r2)
81117f84:	10800044 	addi	r2,r2,1
81117f88:	100b883a 	mov	r5,r2
81117f8c:	00a04574 	movhi	r2,33045
81117f90:	109be604 	addi	r2,r2,28568
81117f94:	19001324 	muli	r4,r3,76
81117f98:	1105883a 	add	r2,r2,r4
81117f9c:	10801184 	addi	r2,r2,70
81117fa0:	1140000d 	sth	r5,0(r2)
81117fa4:	00a04574 	movhi	r2,33045
81117fa8:	109be604 	addi	r2,r2,28568
81117fac:	18c01324 	muli	r3,r3,76
81117fb0:	10c5883a 	add	r2,r2,r3
81117fb4:	10801184 	addi	r2,r2,70
81117fb8:	1080000b 	ldhu	r2,0(r2)
81117fbc:	10bfffcc 	andi	r2,r2,65535
81117fc0:	10a0001c 	xori	r2,r2,32768
81117fc4:	10a00004 	addi	r2,r2,-32768
81117fc8:	10800090 	cmplti	r2,r2,2
81117fcc:	1000071e 	bne	r2,zero,81117fec <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81117fd0:	e0ffff03 	ldbu	r3,-4(fp)
81117fd4:	00a04574 	movhi	r2,33045
81117fd8:	109be604 	addi	r2,r2,28568
81117fdc:	18c01324 	muli	r3,r3,76
81117fe0:	10c5883a 	add	r2,r2,r3
81117fe4:	10801004 	addi	r2,r2,64
81117fe8:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81117fec:	e0ffff03 	ldbu	r3,-4(fp)
81117ff0:	00a04574 	movhi	r2,33045
81117ff4:	109be604 	addi	r2,r2,28568
81117ff8:	18c01324 	muli	r3,r3,76
81117ffc:	10c5883a 	add	r2,r2,r3
81118000:	10801004 	addi	r2,r2,64
81118004:	10800017 	ldw	r2,0(r2)
81118008:	1000441e 	bne	r2,zero,8111811c <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8111800c:	e0bfff03 	ldbu	r2,-4(fp)
81118010:	10c01324 	muli	r3,r2,76
81118014:	00a04574 	movhi	r2,33045
81118018:	109be604 	addi	r2,r2,28568
8111801c:	1885883a 	add	r2,r3,r2
81118020:	1009883a 	mov	r4,r2
81118024:	1123f640 	call	81123f64 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81118028:	e0ffff03 	ldbu	r3,-4(fp)
8111802c:	00a04574 	movhi	r2,33045
81118030:	109be604 	addi	r2,r2,28568
81118034:	18c01324 	muli	r3,r3,76
81118038:	10c5883a 	add	r2,r2,r3
8111803c:	10801004 	addi	r2,r2,64
81118040:	00c00044 	movi	r3,1
81118044:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81118048:	e0ffff03 	ldbu	r3,-4(fp)
8111804c:	00a04574 	movhi	r2,33045
81118050:	109be604 	addi	r2,r2,28568
81118054:	18c01324 	muli	r3,r3,76
81118058:	10c5883a 	add	r2,r2,r3
8111805c:	10801184 	addi	r2,r2,70
81118060:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81118064:	e0ffff03 	ldbu	r3,-4(fp)
81118068:	00a04574 	movhi	r2,33045
8111806c:	109be604 	addi	r2,r2,28568
81118070:	19001324 	muli	r4,r3,76
81118074:	1105883a 	add	r2,r2,r4
81118078:	10801204 	addi	r2,r2,72
8111807c:	10800003 	ldbu	r2,0(r2)
81118080:	10800044 	addi	r2,r2,1
81118084:	100b883a 	mov	r5,r2
81118088:	00a04574 	movhi	r2,33045
8111808c:	109be604 	addi	r2,r2,28568
81118090:	19001324 	muli	r4,r3,76
81118094:	1105883a 	add	r2,r2,r4
81118098:	10801204 	addi	r2,r2,72
8111809c:	11400005 	stb	r5,0(r2)
811180a0:	00a04574 	movhi	r2,33045
811180a4:	109be604 	addi	r2,r2,28568
811180a8:	18c01324 	muli	r3,r3,76
811180ac:	10c5883a 	add	r2,r2,r3
811180b0:	10801204 	addi	r2,r2,72
811180b4:	10800003 	ldbu	r2,0(r2)
811180b8:	10803fcc 	andi	r2,r2,255
811180bc:	108000b0 	cmpltui	r2,r2,2
811180c0:	1000161e 	bne	r2,zero,8111811c <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811180c4:	e0ffff03 	ldbu	r3,-4(fp)
811180c8:	00a045b4 	movhi	r2,33046
811180cc:	10802204 	addi	r2,r2,136
811180d0:	18c00184 	addi	r3,r3,6
811180d4:	18c7883a 	add	r3,r3,r3
811180d8:	18c7883a 	add	r3,r3,r3
811180dc:	10c5883a 	add	r2,r2,r3
811180e0:	10000015 	stw	zero,0(r2)
                    SemCount64++;
811180e4:	d0a07503 	ldbu	r2,-32300(gp)
811180e8:	10800044 	addi	r2,r2,1
811180ec:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
811180f0:	d0a05e17 	ldw	r2,-32392(gp)
811180f4:	1009883a 	mov	r4,r2
811180f8:	11401bc0 	call	811401bc <OSSemPost>
811180fc:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118100:	e0bfff43 	ldbu	r2,-3(fp)
81118104:	10803fcc 	andi	r2,r2,255
81118108:	10000426 	beq	r2,zero,8111811c <vCheckRetransmission64+0x248>
                        SemCount64--;
8111810c:	d0a07503 	ldbu	r2,-32300(gp)
81118110:	10bfffc4 	addi	r2,r2,-1
81118114:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118118:	111cd880 	call	8111cd88 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8111811c:	e0bfff03 	ldbu	r2,-4(fp)
81118120:	10800044 	addi	r2,r2,1
81118124:	e0bfff05 	stb	r2,-4(fp)
81118128:	e0bfff03 	ldbu	r2,-4(fp)
8111812c:	10800230 	cmpltui	r2,r2,8
81118130:	103f7a1e 	bne	r2,zero,81117f1c <__reset+0xfb0f7f1c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81118134:	d0a07117 	ldw	r2,-32316(gp)
81118138:	1009883a 	mov	r4,r2
8111813c:	113e3cc0 	call	8113e3cc <OSMutexPost>

    return;
81118140:	0001883a 	nop
81118144:	00000106 	br	8111814c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118148:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8111814c:	e037883a 	mov	sp,fp
81118150:	dfc00117 	ldw	ra,4(sp)
81118154:	df000017 	ldw	fp,0(sp)
81118158:	dec00204 	addi	sp,sp,8
8111815c:	f800283a 	ret

81118160 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81118160:	defffd04 	addi	sp,sp,-12
81118164:	de00012e 	bgeu	sp,et,8111816c <vCheckRetransmission32+0xc>
81118168:	003b68fa 	trap	3
8111816c:	dfc00215 	stw	ra,8(sp)
81118170:	df000115 	stw	fp,4(sp)
81118174:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81118178:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8111817c:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81118180:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81118184:	d0a06c17 	ldw	r2,-32336(gp)
81118188:	e0ffff84 	addi	r3,fp,-2
8111818c:	180b883a 	mov	r5,r3
81118190:	1009883a 	mov	r4,r2
81118194:	113d7a80 	call	8113d7a8 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81118198:	e0bfff83 	ldbu	r2,-2(fp)
8111819c:	10803fcc 	andi	r2,r2,255
811181a0:	10009b1e 	bne	r2,zero,81118410 <vCheckRetransmission32+0x2b0>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811181a4:	e03fff05 	stb	zero,-4(fp)
811181a8:	00009106 	br	811183f0 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811181ac:	e0ffff03 	ldbu	r3,-4(fp)
811181b0:	00a045b4 	movhi	r2,33046
811181b4:	10802204 	addi	r2,r2,136
811181b8:	18c00384 	addi	r3,r3,14
811181bc:	18c7883a 	add	r3,r3,r3
811181c0:	18c7883a 	add	r3,r3,r3
811181c4:	10c5883a 	add	r2,r2,r3
811181c8:	10800017 	ldw	r2,0(r2)
811181cc:	10800058 	cmpnei	r2,r2,1
811181d0:	1000841e 	bne	r2,zero,811183e4 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
811181d4:	e0ffff03 	ldbu	r3,-4(fp)
811181d8:	00a045b4 	movhi	r2,33046
811181dc:	10ada204 	addi	r2,r2,-18808
811181e0:	18c00b24 	muli	r3,r3,44
811181e4:	10c5883a 	add	r2,r2,r3
811181e8:	10800804 	addi	r2,r2,32
811181ec:	10800017 	ldw	r2,0(r2)
811181f0:	10800058 	cmpnei	r2,r2,1
811181f4:	1000211e 	bne	r2,zero,8111827c <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
811181f8:	e0ffff03 	ldbu	r3,-4(fp)
811181fc:	00a045b4 	movhi	r2,33046
81118200:	10ada204 	addi	r2,r2,-18808
81118204:	19000b24 	muli	r4,r3,44
81118208:	1105883a 	add	r2,r2,r4
8111820c:	10800984 	addi	r2,r2,38
81118210:	1080000b 	ldhu	r2,0(r2)
81118214:	10800044 	addi	r2,r2,1
81118218:	100b883a 	mov	r5,r2
8111821c:	00a045b4 	movhi	r2,33046
81118220:	10ada204 	addi	r2,r2,-18808
81118224:	19000b24 	muli	r4,r3,44
81118228:	1105883a 	add	r2,r2,r4
8111822c:	10800984 	addi	r2,r2,38
81118230:	1140000d 	sth	r5,0(r2)
81118234:	00a045b4 	movhi	r2,33046
81118238:	10ada204 	addi	r2,r2,-18808
8111823c:	18c00b24 	muli	r3,r3,44
81118240:	10c5883a 	add	r2,r2,r3
81118244:	10800984 	addi	r2,r2,38
81118248:	1080000b 	ldhu	r2,0(r2)
8111824c:	10bfffcc 	andi	r2,r2,65535
81118250:	10a0001c 	xori	r2,r2,32768
81118254:	10a00004 	addi	r2,r2,-32768
81118258:	10800090 	cmplti	r2,r2,2
8111825c:	1000071e 	bne	r2,zero,8111827c <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81118260:	e0ffff03 	ldbu	r3,-4(fp)
81118264:	00a045b4 	movhi	r2,33046
81118268:	10ada204 	addi	r2,r2,-18808
8111826c:	18c00b24 	muli	r3,r3,44
81118270:	10c5883a 	add	r2,r2,r3
81118274:	10800804 	addi	r2,r2,32
81118278:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
8111827c:	e0ffff03 	ldbu	r3,-4(fp)
81118280:	00a045b4 	movhi	r2,33046
81118284:	10ada204 	addi	r2,r2,-18808
81118288:	18c00b24 	muli	r3,r3,44
8111828c:	10c5883a 	add	r2,r2,r3
81118290:	10800804 	addi	r2,r2,32
81118294:	10800017 	ldw	r2,0(r2)
81118298:	1000521e 	bne	r2,zero,811183e4 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
8111829c:	e0bfff03 	ldbu	r2,-4(fp)
811182a0:	10c00b24 	muli	r3,r2,44
811182a4:	00a045b4 	movhi	r2,33046
811182a8:	10ada204 	addi	r2,r2,-18808
811182ac:	1885883a 	add	r2,r3,r2
811182b0:	1009883a 	mov	r4,r2
811182b4:	1123f640 	call	81123f64 <puts>
                xBuffer32[ucIL].bSent = TRUE;
811182b8:	e0ffff03 	ldbu	r3,-4(fp)
811182bc:	00a045b4 	movhi	r2,33046
811182c0:	10ada204 	addi	r2,r2,-18808
811182c4:	18c00b24 	muli	r3,r3,44
811182c8:	10c5883a 	add	r2,r2,r3
811182cc:	10800804 	addi	r2,r2,32
811182d0:	00c00044 	movi	r3,1
811182d4:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
811182d8:	e0ffff03 	ldbu	r3,-4(fp)
811182dc:	00a045b4 	movhi	r2,33046
811182e0:	10ada204 	addi	r2,r2,-18808
811182e4:	18c00b24 	muli	r3,r3,44
811182e8:	10c5883a 	add	r2,r2,r3
811182ec:	10800984 	addi	r2,r2,38
811182f0:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
811182f4:	e0ffff03 	ldbu	r3,-4(fp)
811182f8:	00a045b4 	movhi	r2,33046
811182fc:	10ada204 	addi	r2,r2,-18808
81118300:	18c00b24 	muli	r3,r3,44
81118304:	10c5883a 	add	r2,r2,r3
81118308:	10800904 	addi	r2,r2,36
8111830c:	1080000b 	ldhu	r2,0(r2)
81118310:	10bfffcc 	andi	r2,r2,65535
81118314:	10800058 	cmpnei	r2,r2,1
81118318:	1000021e 	bne	r2,zero,81118324 <vCheckRetransmission32+0x1c4>
8111831c:	00bffe84 	movi	r2,-6
81118320:	00000106 	br	81118328 <vCheckRetransmission32+0x1c8>
81118324:	00800044 	movi	r2,1
81118328:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
8111832c:	e0ffff03 	ldbu	r3,-4(fp)
81118330:	00a045b4 	movhi	r2,33046
81118334:	10ada204 	addi	r2,r2,-18808
81118338:	19000b24 	muli	r4,r3,44
8111833c:	1105883a 	add	r2,r2,r4
81118340:	10800a04 	addi	r2,r2,40
81118344:	10800003 	ldbu	r2,0(r2)
81118348:	10800044 	addi	r2,r2,1
8111834c:	100b883a 	mov	r5,r2
81118350:	00a045b4 	movhi	r2,33046
81118354:	10ada204 	addi	r2,r2,-18808
81118358:	19000b24 	muli	r4,r3,44
8111835c:	1105883a 	add	r2,r2,r4
81118360:	10800a04 	addi	r2,r2,40
81118364:	11400005 	stb	r5,0(r2)
81118368:	00a045b4 	movhi	r2,33046
8111836c:	10ada204 	addi	r2,r2,-18808
81118370:	18c00b24 	muli	r3,r3,44
81118374:	10c5883a 	add	r2,r2,r3
81118378:	10800a04 	addi	r2,r2,40
8111837c:	10800003 	ldbu	r2,0(r2)
81118380:	10803fcc 	andi	r2,r2,255
81118384:	e0ffff43 	ldbu	r3,-3(fp)
81118388:	1880162e 	bgeu	r3,r2,811183e4 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
8111838c:	e0ffff03 	ldbu	r3,-4(fp)
81118390:	00a045b4 	movhi	r2,33046
81118394:	10802204 	addi	r2,r2,136
81118398:	18c00384 	addi	r3,r3,14
8111839c:	18c7883a 	add	r3,r3,r3
811183a0:	18c7883a 	add	r3,r3,r3
811183a4:	10c5883a 	add	r2,r2,r3
811183a8:	10000015 	stw	zero,0(r2)
                    SemCount32++;
811183ac:	d0a06883 	ldbu	r2,-32350(gp)
811183b0:	10800044 	addi	r2,r2,1
811183b4:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
811183b8:	d0a06f17 	ldw	r2,-32324(gp)
811183bc:	1009883a 	mov	r4,r2
811183c0:	11401bc0 	call	811401bc <OSSemPost>
811183c4:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811183c8:	e0bfff83 	ldbu	r2,-2(fp)
811183cc:	10803fcc 	andi	r2,r2,255
811183d0:	10000426 	beq	r2,zero,811183e4 <vCheckRetransmission32+0x284>
                        SemCount32--;
811183d4:	d0a06883 	ldbu	r2,-32350(gp)
811183d8:	10bfffc4 	addi	r2,r2,-1
811183dc:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811183e0:	111cd080 	call	8111cd08 <vFailSetCountSemaphorexBuffer32>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811183e4:	e0bfff03 	ldbu	r2,-4(fp)
811183e8:	10800044 	addi	r2,r2,1
811183ec:	e0bfff05 	stb	r2,-4(fp)
811183f0:	e0bfff03 	ldbu	r2,-4(fp)
811183f4:	10800230 	cmpltui	r2,r2,8
811183f8:	103f6c1e 	bne	r2,zero,811181ac <__reset+0xfb0f81ac>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
811183fc:	d0a06c17 	ldw	r2,-32336(gp)
81118400:	1009883a 	mov	r4,r2
81118404:	113e3cc0 	call	8113e3cc <OSMutexPost>

    return;
81118408:	0001883a 	nop
8111840c:	00000106 	br	81118414 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118410:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81118414:	e037883a 	mov	sp,fp
81118418:	dfc00117 	ldw	ra,4(sp)
8111841c:	df000017 	ldw	fp,0(sp)
81118420:	dec00204 	addi	sp,sp,8
81118424:	f800283a 	ret

81118428 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81118428:	defff904 	addi	sp,sp,-28
8111842c:	de00012e 	bgeu	sp,et,81118434 <bResourcesInitRTOS+0xc>
81118430:	003b68fa 	trap	3
81118434:	dfc00615 	stw	ra,24(sp)
81118438:	df000515 	stw	fp,20(sp)
8111843c:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81118440:	00800044 	movi	r2,1
81118444:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81118448:	0009883a 	mov	r4,zero
8111844c:	113fb0c0 	call	8113fb0c <OSSemCreate>
81118450:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
81118454:	d0a06017 	ldw	r2,-32384(gp)
81118458:	1000021e 	bne	r2,zero,81118464 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8111845c:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118460:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81118464:	e0bfff04 	addi	r2,fp,-4
81118468:	100b883a 	mov	r5,r2
8111846c:	01000444 	movi	r4,17
81118470:	113d9540 	call	8113d954 <OSMutexCreate>
81118474:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81118478:	e0bfff03 	ldbu	r2,-4(fp)
8111847c:	10803fcc 	andi	r2,r2,255
81118480:	10000526 	beq	r2,zero,81118498 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81118484:	e0bfff03 	ldbu	r2,-4(fp)
81118488:	10803fcc 	andi	r2,r2,255
8111848c:	1009883a 	mov	r4,r2
81118490:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118494:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81118498:	e0bfff04 	addi	r2,fp,-4
8111849c:	100b883a 	mov	r5,r2
811184a0:	01000504 	movi	r4,20
811184a4:	113d9540 	call	8113d954 <OSMutexCreate>
811184a8:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
811184ac:	e0bfff03 	ldbu	r2,-4(fp)
811184b0:	10803fcc 	andi	r2,r2,255
811184b4:	10000526 	beq	r2,zero,811184cc <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
811184b8:	e0bfff03 	ldbu	r2,-4(fp)
811184bc:	10803fcc 	andi	r2,r2,255
811184c0:	1009883a 	mov	r4,r2
811184c4:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811184c8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
811184cc:	e0bfff04 	addi	r2,fp,-4
811184d0:	100b883a 	mov	r5,r2
811184d4:	01000544 	movi	r4,21
811184d8:	113d9540 	call	8113d954 <OSMutexCreate>
811184dc:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
811184e0:	e0bfff03 	ldbu	r2,-4(fp)
811184e4:	10803fcc 	andi	r2,r2,255
811184e8:	10000526 	beq	r2,zero,81118500 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
811184ec:	e0bfff03 	ldbu	r2,-4(fp)
811184f0:	10803fcc 	andi	r2,r2,255
811184f4:	1009883a 	mov	r4,r2
811184f8:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811184fc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81118500:	e0bfff04 	addi	r2,fp,-4
81118504:	100b883a 	mov	r5,r2
81118508:	01000584 	movi	r4,22
8111850c:	113d9540 	call	8113d954 <OSMutexCreate>
81118510:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81118514:	e0bfff03 	ldbu	r2,-4(fp)
81118518:	10803fcc 	andi	r2,r2,255
8111851c:	10000526 	beq	r2,zero,81118534 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81118520:	e0bfff03 	ldbu	r2,-4(fp)
81118524:	10803fcc 	andi	r2,r2,255
81118528:	1009883a 	mov	r4,r2
8111852c:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118530:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81118534:	00800184 	movi	r2,6
81118538:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8111853c:	01000184 	movi	r4,6
81118540:	113fb0c0 	call	8113fb0c <OSSemCreate>
81118544:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
81118548:	d0a06317 	ldw	r2,-32372(gp)
8111854c:	1000031e 	bne	r2,zero,8111855c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81118550:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
81118554:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118558:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8111855c:	00800204 	movi	r2,8
81118560:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81118564:	01000204 	movi	r4,8
81118568:	113fb0c0 	call	8113fb0c <OSSemCreate>
8111856c:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
81118570:	d0a05e17 	ldw	r2,-32392(gp)
81118574:	1000031e 	bne	r2,zero,81118584 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81118578:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
8111857c:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118580:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81118584:	00800204 	movi	r2,8
81118588:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
8111858c:	01000204 	movi	r4,8
81118590:	113fb0c0 	call	8113fb0c <OSSemCreate>
81118594:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
81118598:	d0a06f17 	ldw	r2,-32324(gp)
8111859c:	1000031e 	bne	r2,zero,811185ac <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
811185a0:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
811185a4:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811185a8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
811185ac:	e0bfff04 	addi	r2,fp,-4
811185b0:	100b883a 	mov	r5,r2
811185b4:	010004c4 	movi	r4,19
811185b8:	113d9540 	call	8113d954 <OSMutexCreate>
811185bc:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
811185c0:	e0bfff03 	ldbu	r2,-4(fp)
811185c4:	10803fcc 	andi	r2,r2,255
811185c8:	10000526 	beq	r2,zero,811185e0 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
811185cc:	e0bfff03 	ldbu	r2,-4(fp)
811185d0:	10803fcc 	andi	r2,r2,255
811185d4:	1009883a 	mov	r4,r2
811185d8:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811185dc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
811185e0:	e0bfff04 	addi	r2,fp,-4
811185e4:	100b883a 	mov	r5,r2
811185e8:	010005c4 	movi	r4,23
811185ec:	113d9540 	call	8113d954 <OSMutexCreate>
811185f0:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
811185f4:	e0bfff03 	ldbu	r2,-4(fp)
811185f8:	10803fcc 	andi	r2,r2,255
811185fc:	10000526 	beq	r2,zero,81118614 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81118600:	e0bfff03 	ldbu	r2,-4(fp)
81118604:	10803fcc 	andi	r2,r2,255
81118608:	1009883a 	mov	r4,r2
8111860c:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118610:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81118614:	0009883a 	mov	r4,zero
81118618:	113fb0c0 	call	8113fb0c <OSSemCreate>
8111861c:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
81118620:	d0a06617 	ldw	r2,-32360(gp)
81118624:	1000021e 	bne	r2,zero,81118630 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81118628:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111862c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81118630:	0009883a 	mov	r4,zero
81118634:	113fb0c0 	call	8113fb0c <OSSemCreate>
81118638:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
8111863c:	d0a06417 	ldw	r2,-32368(gp)
81118640:	1000021e 	bne	r2,zero,8111864c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81118644:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118648:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8111864c:	0009883a 	mov	r4,zero
81118650:	113fb0c0 	call	8113fb0c <OSSemCreate>
81118654:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
81118658:	d0a06117 	ldw	r2,-32380(gp)
8111865c:	1000021e 	bne	r2,zero,81118668 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81118660:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118664:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81118668:	e0bfff04 	addi	r2,fp,-4
8111866c:	100b883a 	mov	r5,r2
81118670:	01000484 	movi	r4,18
81118674:	113d9540 	call	8113d954 <OSMutexCreate>
81118678:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
8111867c:	e0bfff03 	ldbu	r2,-4(fp)
81118680:	10803fcc 	andi	r2,r2,255
81118684:	10000526 	beq	r2,zero,8111869c <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81118688:	e0bfff03 	ldbu	r2,-4(fp)
8111868c:	10803fcc 	andi	r2,r2,255
81118690:	1009883a 	mov	r4,r2
81118694:	111c5440 	call	8111c544 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118698:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
8111869c:	0009883a 	mov	r4,zero
811186a0:	113fb0c0 	call	8113fb0c <OSSemCreate>
811186a4:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
811186a8:	d0a06717 	ldw	r2,-32356(gp)
811186ac:	1000021e 	bne	r2,zero,811186b8 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
811186b0:	111c6200 	call	8111c620 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811186b4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
811186b8:	e0bfff04 	addi	r2,fp,-4
811186bc:	d8800215 	stw	r2,8(sp)
811186c0:	00a04574 	movhi	r2,33045
811186c4:	10be7904 	addi	r2,r2,-1564
811186c8:	d8800115 	stw	r2,4(sp)
811186cc:	d8000015 	stw	zero,0(sp)
811186d0:	01e044b4 	movhi	r7,33042
811186d4:	39e8b904 	addi	r7,r7,-23836
811186d8:	01800084 	movi	r6,2
811186dc:	01400104 	movi	r5,4
811186e0:	01000284 	movi	r4,10
811186e4:	11421d80 	call	811421d8 <OSTmrCreate>
811186e8:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
811186ec:	e0bfff03 	ldbu	r2,-4(fp)
811186f0:	10803fcc 	andi	r2,r2,255
811186f4:	10000226 	beq	r2,zero,81118700 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
811186f8:	111d5b40 	call	8111d5b4 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
811186fc:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81118700:	01400484 	movi	r5,18
81118704:	012045b4 	movhi	r4,33046
81118708:	2120e204 	addi	r4,r4,-31864
8111870c:	113ea400 	call	8113ea40 <OSQCreate>
81118710:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
81118714:	d0a05d17 	ldw	r2,-32396(gp)
81118718:	1000021e 	bne	r2,zero,81118724 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8111871c:	111dd000 	call	8111dd00 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81118720:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81118724:	01400204 	movi	r5,8
81118728:	012045b4 	movhi	r4,33046
8111872c:	211ff404 	addi	r4,r4,32720
81118730:	113ea400 	call	8113ea40 <OSQCreate>
81118734:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
81118738:	d0a06a17 	ldw	r2,-32344(gp)
8111873c:	1000031e 	bne	r2,zero,8111874c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81118740:	0009883a 	mov	r4,zero
81118744:	111dd800 	call	8111dd80 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81118748:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
8111874c:	01400204 	movi	r5,8
81118750:	012045b4 	movhi	r4,33046
81118754:	21053a04 	addi	r4,r4,5352
81118758:	113ea400 	call	8113ea40 <OSQCreate>
8111875c:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81118760:	d0a05c17 	ldw	r2,-32400(gp)
81118764:	1000031e 	bne	r2,zero,81118774 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81118768:	0009883a 	mov	r4,zero
8111876c:	111de080 	call	8111de08 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81118770:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81118774:	01400204 	movi	r5,8
81118778:	012045b4 	movhi	r4,33046
8111877c:	21003804 	addi	r4,r4,224
81118780:	113ea400 	call	8113ea40 <OSQCreate>
81118784:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
81118788:	d0a06917 	ldw	r2,-32348(gp)
8111878c:	1000031e 	bne	r2,zero,8111879c <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81118790:	01000144 	movi	r4,5
81118794:	111dd800 	call	8111dd80 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81118798:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
8111879c:	e0bfff04 	addi	r2,fp,-4
811187a0:	100b883a 	mov	r5,r2
811187a4:	010001c4 	movi	r4,7
811187a8:	113d9540 	call	8113d954 <OSMutexCreate>
811187ac:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
811187b0:	e0bfff03 	ldbu	r2,-4(fp)
811187b4:	10803fcc 	andi	r2,r2,255
811187b8:	10000526 	beq	r2,zero,811187d0 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
811187bc:	e0bfff03 	ldbu	r2,-4(fp)
811187c0:	10803fcc 	andi	r2,r2,255
811187c4:	1009883a 	mov	r4,r2
811187c8:	111e3100 	call	8111e310 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
811187cc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
811187d0:	01400404 	movi	r5,16
811187d4:	012045b4 	movhi	r4,33046
811187d8:	21011204 	addi	r4,r4,1096
811187dc:	113ea400 	call	8113ea40 <OSQCreate>
811187e0:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
811187e4:	d0a07017 	ldw	r2,-32320(gp)
811187e8:	1000021e 	bne	r2,zero,811187f4 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
811187ec:	111e4d00 	call	8111e4d0 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
811187f0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
811187f4:	01400404 	movi	r5,16
811187f8:	012045b4 	movhi	r4,33046
811187fc:	2133fa04 	addi	r4,r4,-12312
81118800:	113ea400 	call	8113ea40 <OSQCreate>
81118804:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
81118808:	d0a05f17 	ldw	r2,-32388(gp)
8111880c:	1000021e 	bne	r2,zero,81118818 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81118810:	111e5500 	call	8111e550 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81118814:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81118818:	e0bfff04 	addi	r2,fp,-4
8111881c:	100b883a 	mov	r5,r2
81118820:	01000104 	movi	r4,4
81118824:	113d9540 	call	8113d954 <OSMutexCreate>
81118828:	1007883a 	mov	r3,r2
8111882c:	00a045b4 	movhi	r2,33046
81118830:	10934804 	addi	r2,r2,19744
81118834:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81118838:	e0bfff03 	ldbu	r2,-4(fp)
8111883c:	10803fcc 	andi	r2,r2,255
81118840:	10000226 	beq	r2,zero,8111884c <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81118844:	111c5bc0 	call	8111c5bc <vFailCreateMutexDMA>
		bSuccess = FALSE;
81118848:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
8111884c:	e0bfff04 	addi	r2,fp,-4
81118850:	100b883a 	mov	r5,r2
81118854:	01000184 	movi	r4,6
81118858:	113d9540 	call	8113d954 <OSMutexCreate>
8111885c:	1007883a 	mov	r3,r2
81118860:	00a045b4 	movhi	r2,33046
81118864:	10934804 	addi	r2,r2,19744
81118868:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
8111886c:	e0bfff03 	ldbu	r2,-4(fp)
81118870:	10803fcc 	andi	r2,r2,255
81118874:	10000226 	beq	r2,zero,81118880 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81118878:	111c5bc0 	call	8111c5bc <vFailCreateMutexDMA>
		bSuccess = FALSE;
8111887c:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81118880:	e0bffe17 	ldw	r2,-8(fp)
}
81118884:	e037883a 	mov	sp,fp
81118888:	dfc00117 	ldw	ra,4(sp)
8111888c:	df000017 	ldw	fp,0(sp)
81118890:	dec00204 	addi	sp,sp,8
81118894:	f800283a 	ret

81118898 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81118898:	defffd04 	addi	sp,sp,-12
8111889c:	de00012e 	bgeu	sp,et,811188a4 <vVariablesInitialization+0xc>
811188a0:	003b68fa 	trap	3
811188a4:	dfc00215 	stw	ra,8(sp)
811188a8:	df000115 	stw	fp,4(sp)
811188ac:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
811188b0:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
811188b4:	00800084 	movi	r2,2
811188b8:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
811188bc:	01800604 	movi	r6,24
811188c0:	000b883a 	mov	r5,zero
811188c4:	012045b4 	movhi	r4,33046
811188c8:	21002204 	addi	r4,r4,136
811188cc:	1123b940 	call	81123b94 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
811188d0:	01800804 	movi	r6,32
811188d4:	000b883a 	mov	r5,zero
811188d8:	012045b4 	movhi	r4,33046
811188dc:	21002804 	addi	r4,r4,160
811188e0:	1123b940 	call	81123b94 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
811188e4:	01800804 	movi	r6,32
811188e8:	000b883a 	mov	r5,zero
811188ec:	012045b4 	movhi	r4,33046
811188f0:	21003004 	addi	r4,r4,192
811188f4:	1123b940 	call	81123b94 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811188f8:	e03fff05 	stb	zero,-4(fp)
811188fc:	00002806 	br	811189a0 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81118900:	e0bfff03 	ldbu	r2,-4(fp)
81118904:	10c02324 	muli	r3,r2,140
81118908:	00a045b4 	movhi	r2,33046
8111890c:	10804004 	addi	r2,r2,256
81118910:	1885883a 	add	r2,r3,r2
81118914:	01802004 	movi	r6,128
81118918:	000b883a 	mov	r5,zero
8111891c:	1009883a 	mov	r4,r2
81118920:	1123b940 	call	81123b94 <memset>
		xBuffer128[ucIL].bSent = FALSE;
81118924:	e0ffff03 	ldbu	r3,-4(fp)
81118928:	00a045b4 	movhi	r2,33046
8111892c:	10804004 	addi	r2,r2,256
81118930:	18c02324 	muli	r3,r3,140
81118934:	10c5883a 	add	r2,r2,r3
81118938:	10802004 	addi	r2,r2,128
8111893c:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81118940:	e0ffff03 	ldbu	r3,-4(fp)
81118944:	00a045b4 	movhi	r2,33046
81118948:	10804004 	addi	r2,r2,256
8111894c:	18c02324 	muli	r3,r3,140
81118950:	10c5883a 	add	r2,r2,r3
81118954:	10802104 	addi	r2,r2,132
81118958:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
8111895c:	e0ffff03 	ldbu	r3,-4(fp)
81118960:	00a045b4 	movhi	r2,33046
81118964:	10804004 	addi	r2,r2,256
81118968:	18c02324 	muli	r3,r3,140
8111896c:	10c5883a 	add	r2,r2,r3
81118970:	10802184 	addi	r2,r2,134
81118974:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81118978:	e0ffff03 	ldbu	r3,-4(fp)
8111897c:	00a045b4 	movhi	r2,33046
81118980:	10804004 	addi	r2,r2,256
81118984:	18c02324 	muli	r3,r3,140
81118988:	10c5883a 	add	r2,r2,r3
8111898c:	10802204 	addi	r2,r2,136
81118990:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118994:	e0bfff03 	ldbu	r2,-4(fp)
81118998:	10800044 	addi	r2,r2,1
8111899c:	e0bfff05 	stb	r2,-4(fp)
811189a0:	e0bfff03 	ldbu	r2,-4(fp)
811189a4:	108001b0 	cmpltui	r2,r2,6
811189a8:	103fd51e 	bne	r2,zero,81118900 <__reset+0xfb0f8900>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811189ac:	e03fff05 	stb	zero,-4(fp)
811189b0:	00002806 	br	81118a54 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
811189b4:	e0bfff03 	ldbu	r2,-4(fp)
811189b8:	10c01324 	muli	r3,r2,76
811189bc:	00a04574 	movhi	r2,33045
811189c0:	109be604 	addi	r2,r2,28568
811189c4:	1885883a 	add	r2,r3,r2
811189c8:	01801004 	movi	r6,64
811189cc:	000b883a 	mov	r5,zero
811189d0:	1009883a 	mov	r4,r2
811189d4:	1123b940 	call	81123b94 <memset>
		xBuffer64[ucIL].bSent = FALSE;
811189d8:	e0ffff03 	ldbu	r3,-4(fp)
811189dc:	00a04574 	movhi	r2,33045
811189e0:	109be604 	addi	r2,r2,28568
811189e4:	18c01324 	muli	r3,r3,76
811189e8:	10c5883a 	add	r2,r2,r3
811189ec:	10801004 	addi	r2,r2,64
811189f0:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
811189f4:	e0ffff03 	ldbu	r3,-4(fp)
811189f8:	00a04574 	movhi	r2,33045
811189fc:	109be604 	addi	r2,r2,28568
81118a00:	18c01324 	muli	r3,r3,76
81118a04:	10c5883a 	add	r2,r2,r3
81118a08:	10801104 	addi	r2,r2,68
81118a0c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81118a10:	e0ffff03 	ldbu	r3,-4(fp)
81118a14:	00a04574 	movhi	r2,33045
81118a18:	109be604 	addi	r2,r2,28568
81118a1c:	18c01324 	muli	r3,r3,76
81118a20:	10c5883a 	add	r2,r2,r3
81118a24:	10801184 	addi	r2,r2,70
81118a28:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81118a2c:	e0ffff03 	ldbu	r3,-4(fp)
81118a30:	00a04574 	movhi	r2,33045
81118a34:	109be604 	addi	r2,r2,28568
81118a38:	18c01324 	muli	r3,r3,76
81118a3c:	10c5883a 	add	r2,r2,r3
81118a40:	10801204 	addi	r2,r2,72
81118a44:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81118a48:	e0bfff03 	ldbu	r2,-4(fp)
81118a4c:	10800044 	addi	r2,r2,1
81118a50:	e0bfff05 	stb	r2,-4(fp)
81118a54:	e0bfff03 	ldbu	r2,-4(fp)
81118a58:	10800230 	cmpltui	r2,r2,8
81118a5c:	103fd51e 	bne	r2,zero,811189b4 <__reset+0xfb0f89b4>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81118a60:	e03fff05 	stb	zero,-4(fp)
81118a64:	00002806 	br	81118b08 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81118a68:	e0bfff03 	ldbu	r2,-4(fp)
81118a6c:	10c00b24 	muli	r3,r2,44
81118a70:	00a045b4 	movhi	r2,33046
81118a74:	10ada204 	addi	r2,r2,-18808
81118a78:	1885883a 	add	r2,r3,r2
81118a7c:	01800804 	movi	r6,32
81118a80:	000b883a 	mov	r5,zero
81118a84:	1009883a 	mov	r4,r2
81118a88:	1123b940 	call	81123b94 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81118a8c:	e0ffff03 	ldbu	r3,-4(fp)
81118a90:	00a045b4 	movhi	r2,33046
81118a94:	10ada204 	addi	r2,r2,-18808
81118a98:	18c00b24 	muli	r3,r3,44
81118a9c:	10c5883a 	add	r2,r2,r3
81118aa0:	10800804 	addi	r2,r2,32
81118aa4:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81118aa8:	e0ffff03 	ldbu	r3,-4(fp)
81118aac:	00a045b4 	movhi	r2,33046
81118ab0:	10ada204 	addi	r2,r2,-18808
81118ab4:	18c00b24 	muli	r3,r3,44
81118ab8:	10c5883a 	add	r2,r2,r3
81118abc:	10800904 	addi	r2,r2,36
81118ac0:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81118ac4:	e0ffff03 	ldbu	r3,-4(fp)
81118ac8:	00a045b4 	movhi	r2,33046
81118acc:	10ada204 	addi	r2,r2,-18808
81118ad0:	18c00b24 	muli	r3,r3,44
81118ad4:	10c5883a 	add	r2,r2,r3
81118ad8:	10800984 	addi	r2,r2,38
81118adc:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81118ae0:	e0ffff03 	ldbu	r3,-4(fp)
81118ae4:	00a045b4 	movhi	r2,33046
81118ae8:	10ada204 	addi	r2,r2,-18808
81118aec:	18c00b24 	muli	r3,r3,44
81118af0:	10c5883a 	add	r2,r2,r3
81118af4:	10800a04 	addi	r2,r2,40
81118af8:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81118afc:	e0bfff03 	ldbu	r2,-4(fp)
81118b00:	10800044 	addi	r2,r2,1
81118b04:	e0bfff05 	stb	r2,-4(fp)
81118b08:	e0bfff03 	ldbu	r2,-4(fp)
81118b0c:	10800230 	cmpltui	r2,r2,8
81118b10:	103fd51e 	bne	r2,zero,81118a68 <__reset+0xfb0f8a68>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81118b14:	e03fff05 	stb	zero,-4(fp)
81118b18:	00001b06 	br	81118b88 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81118b1c:	e0ffff03 	ldbu	r3,-4(fp)
81118b20:	00a04574 	movhi	r2,33045
81118b24:	109c7e04 	addi	r2,r2,29176
81118b28:	18c01524 	muli	r3,r3,84
81118b2c:	10c5883a 	add	r2,r2,r3
81118b30:	10800104 	addi	r2,r2,4
81118b34:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81118b38:	e0ffff03 	ldbu	r3,-4(fp)
81118b3c:	00a04574 	movhi	r2,33045
81118b40:	109c7e04 	addi	r2,r2,29176
81118b44:	18c01524 	muli	r3,r3,84
81118b48:	10c5883a 	add	r2,r2,r3
81118b4c:	10800484 	addi	r2,r2,18
81118b50:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81118b54:	e0bfff03 	ldbu	r2,-4(fp)
81118b58:	10801524 	muli	r2,r2,84
81118b5c:	10c00504 	addi	r3,r2,20
81118b60:	00a04574 	movhi	r2,33045
81118b64:	109c7e04 	addi	r2,r2,29176
81118b68:	1885883a 	add	r2,r3,r2
81118b6c:	01801004 	movi	r6,64
81118b70:	000b883a 	mov	r5,zero
81118b74:	1009883a 	mov	r4,r2
81118b78:	1123b940 	call	81123b94 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81118b7c:	e0bfff03 	ldbu	r2,-4(fp)
81118b80:	10800044 	addi	r2,r2,1
81118b84:	e0bfff05 	stb	r2,-4(fp)
81118b88:	e0bfff03 	ldbu	r2,-4(fp)
81118b8c:	10800130 	cmpltui	r2,r2,4
81118b90:	103fe21e 	bne	r2,zero,81118b1c <__reset+0xfb0f8b1c>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81118b94:	0001883a 	nop
81118b98:	e037883a 	mov	sp,fp
81118b9c:	dfc00117 	ldw	ra,4(sp)
81118ba0:	df000017 	ldw	fp,0(sp)
81118ba4:	dec00204 	addi	sp,sp,8
81118ba8:	f800283a 	ret

81118bac <main>:
void vFillMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81118bac:	defff704 	addi	sp,sp,-36
81118bb0:	de00012e 	bgeu	sp,et,81118bb8 <main+0xc>
81118bb4:	003b68fa 	trap	3
81118bb8:	dfc00815 	stw	ra,32(sp)
81118bbc:	df000715 	stw	fp,28(sp)
81118bc0:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81118bc4:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81118bc8:	1139df00 	call	81139df0 <OSInit>

	/* Debug device initialization - JTAG USB */
	#if DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81118bcc:	01604574 	movhi	r5,33045
81118bd0:	297e7d04 	addi	r5,r5,-1548
81118bd4:	01204574 	movhi	r4,33045
81118bd8:	213e7e04 	addi	r4,r4,-1544
81118bdc:	112294c0 	call	8112294c <fopen>
81118be0:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#if DEBUG_ON
		debug(fp, "Main entry point.\n");
81118be4:	d0a06217 	ldw	r2,-32376(gp)
81118be8:	100f883a 	mov	r7,r2
81118bec:	01800484 	movi	r6,18
81118bf0:	01400044 	movi	r5,1
81118bf4:	01204574 	movhi	r4,33045
81118bf8:	213e8304 	addi	r4,r4,-1524
81118bfc:	11230300 	call	81123030 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81118c00:	111f7580 	call	8111f758 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81118c04:	11202d80 	call	811202d8 <bTestSimucamCriticalHW>
81118c08:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c0c:	e0bffe17 	ldw	r2,-8(fp)
81118c10:	1000031e 	bne	r2,zero,81118c20 <main+0x74>
		vFailTestCriticasParts();
81118c14:	111c6840 	call	8111c684 <vFailTestCriticasParts>
		return -1;
81118c18:	00bfffc4 	movi	r2,-1
81118c1c:	00006606 	br	81118db8 <main+0x20c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81118c20:	111fecc0 	call	8111fecc <bInitializeSDCard>
81118c24:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c28:	e0bffe17 	ldw	r2,-8(fp)
81118c2c:	1000031e 	bne	r2,zero,81118c3c <main+0x90>
		vFailTestCriticasParts();
81118c30:	111c6840 	call	8111c684 <vFailTestCriticasParts>
		return -1;
81118c34:	00bfffc4 	movi	r2,-1
81118c38:	00005f06 	br	81118db8 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDebugConfs();
81118c3c:	111b47c0 	call	8111b47c <vLoadDebugConfs>
81118c40:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c44:	e0bffe17 	ldw	r2,-8(fp)
81118c48:	10000f1e 	bne	r2,zero,81118c88 <main+0xdc>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118c4c:	00a045f4 	movhi	r2,33047
81118c50:	10a00404 	addi	r2,r2,-32752
81118c54:	10800e8b 	ldhu	r2,58(r2)
81118c58:	10bfffcc 	andi	r2,r2,65535
81118c5c:	108001e8 	cmpgeui	r2,r2,7
81118c60:	1000071e 	bne	r2,zero,81118c80 <main+0xd4>
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81118c64:	d0a06217 	ldw	r2,-32376(gp)
81118c68:	100f883a 	mov	r7,r2
81118c6c:	01801504 	movi	r6,84
81118c70:	01400044 	movi	r5,1
81118c74:	01204574 	movhi	r4,33045
81118c78:	213e8804 	addi	r4,r4,-1504
81118c7c:	11230300 	call	81123030 <fwrite>
		}
		#endif
		return -1;
81118c80:	00bfffc4 	movi	r2,-1
81118c84:	00004c06 	br	81118db8 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81118c88:	111a70c0 	call	8111a70c <vLoadDefaultETHConf>
81118c8c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c90:	e0bffe17 	ldw	r2,-8(fp)
81118c94:	10000f1e 	bne	r2,zero,81118cd4 <main+0x128>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118c98:	00a045f4 	movhi	r2,33047
81118c9c:	10a00404 	addi	r2,r2,-32752
81118ca0:	10800e8b 	ldhu	r2,58(r2)
81118ca4:	10bfffcc 	andi	r2,r2,65535
81118ca8:	108001e8 	cmpgeui	r2,r2,7
81118cac:	1000071e 	bne	r2,zero,81118ccc <main+0x120>
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81118cb0:	d0a06217 	ldw	r2,-32376(gp)
81118cb4:	100f883a 	mov	r7,r2
81118cb8:	01801484 	movi	r6,82
81118cbc:	01400044 	movi	r5,1
81118cc0:	01204574 	movhi	r4,33045
81118cc4:	213e9e04 	addi	r4,r4,-1416
81118cc8:	11230300 	call	81123030 <fwrite>
		}
		#endif
		return -1;
81118ccc:	00bfffc4 	movi	r2,-1
81118cd0:	00003906 	br	81118db8 <main+0x20c>
	}


	/* If debug is enable, will print the eth configuration in the*/
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81118cd4:	00a045f4 	movhi	r2,33047
81118cd8:	10a00404 	addi	r2,r2,-32752
81118cdc:	10800e8b 	ldhu	r2,58(r2)
81118ce0:	10bfffcc 	andi	r2,r2,65535
81118ce4:	108000e8 	cmpgeui	r2,r2,3
81118ce8:	1000011e 	bne	r2,zero,81118cf0 <main+0x144>
		vShowEthConfig();
81118cec:	111b14c0 	call	8111b14c <vShowEthConfig>
	}
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81118cf0:	11184280 	call	81118428 <bResourcesInitRTOS>
81118cf4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118cf8:	e0bffe17 	ldw	r2,-8(fp)
81118cfc:	10000f1e 	bne	r2,zero,81118d3c <main+0x190>
		/* Default configuration for eth connection loaded */
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118d00:	00a045f4 	movhi	r2,33047
81118d04:	10a00404 	addi	r2,r2,-32752
81118d08:	10800e8b 	ldhu	r2,58(r2)
81118d0c:	10bfffcc 	andi	r2,r2,65535
81118d10:	108001e8 	cmpgeui	r2,r2,7
81118d14:	1000071e 	bne	r2,zero,81118d34 <main+0x188>
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81118d18:	d0a06217 	ldw	r2,-32376(gp)
81118d1c:	100f883a 	mov	r7,r2
81118d20:	01800ac4 	movi	r6,43
81118d24:	01400044 	movi	r5,1
81118d28:	01204574 	movhi	r4,33045
81118d2c:	213eb304 	addi	r4,r4,-1332
81118d30:	11230300 	call	81123030 <fwrite>
	}
	#endif
		return -1;
81118d34:	00bfffc4 	movi	r2,-1
81118d38:	00001f06 	br	81118db8 <main+0x20c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81118d3c:	012045b4 	movhi	r4,33046
81118d40:	2128f404 	addi	r4,r4,-23600
81118d44:	111f8980 	call	8111f898 <vSimucamStructureInit>

	vVariablesInitialization();
81118d48:	11188980 	call	81118898 <vVariablesInitialization>

	bInitSync();
81118d4c:	11200800 	call	81120080 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81118d50:	012045b4 	movhi	r4,33046
81118d54:	2128f404 	addi	r4,r4,-23600
81118d58:	1118dcc0 	call	81118dcc <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81118d5c:	d8000415 	stw	zero,16(sp)
81118d60:	d8000315 	stw	zero,12(sp)
81118d64:	00810004 	movi	r2,1024
81118d68:	d8800215 	stw	r2,8(sp)
81118d6c:	00a045b4 	movhi	r2,33046
81118d70:	10b81a04 	addi	r2,r2,-8088
81118d74:	d8800115 	stw	r2,4(sp)
81118d78:	00800044 	movi	r2,1
81118d7c:	d8800015 	stw	r2,0(sp)
81118d80:	01c00044 	movi	r7,1
81118d84:	01a045b4 	movhi	r6,33046
81118d88:	31bc1904 	addi	r6,r6,-3996
81118d8c:	000b883a 	mov	r5,zero
81118d90:	01204474 	movhi	r4,33041
81118d94:	210ad804 	addi	r4,r4,11104
81118d98:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
81118d9c:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81118da0:	e0bfff03 	ldbu	r2,-4(fp)
81118da4:	1000021e 	bne	r2,zero,81118db0 <main+0x204>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81118da8:	113a1200 	call	8113a120 <OSStart>
81118dac:	00000106 	br	81118db4 <main+0x208>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81118db0:	111cb780 	call	8111cb78 <vFailInitialization>
	}
  
	return 0;
81118db4:	0005883a 	mov	r2,zero
}
81118db8:	e037883a 	mov	sp,fp
81118dbc:	dfc00117 	ldw	ra,4(sp)
81118dc0:	df000017 	ldw	fp,0(sp)
81118dc4:	dec00204 	addi	sp,sp,8
81118dc8:	f800283a 	ret

81118dcc <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81118dcc:	defff604 	addi	sp,sp,-40
81118dd0:	de00012e 	bgeu	sp,et,81118dd8 <vFillMemmoryPattern+0xc>
81118dd4:	003b68fa 	trap	3
81118dd8:	dfc00915 	stw	ra,36(sp)
81118ddc:	df000815 	stw	fp,32(sp)
81118de0:	df000804 	addi	fp,sp,32
81118de4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81118de8:	00800044 	movi	r2,1
81118dec:	e0bffcc5 	stb	r2,-13(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118df0:	00a045f4 	movhi	r2,33047
81118df4:	10a00404 	addi	r2,r2,-32752
81118df8:	10800e8b 	ldhu	r2,58(r2)
81118dfc:	10bfffcc 	andi	r2,r2,65535
81118e00:	10800168 	cmpgeui	r2,r2,5
81118e04:	1000071e 	bne	r2,zero,81118e24 <vFillMemmoryPattern+0x58>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
81118e08:	d0a06217 	ldw	r2,-32376(gp)
81118e0c:	100f883a 	mov	r7,r2
81118e10:	01800a04 	movi	r6,40
81118e14:	01400044 	movi	r5,1
81118e18:	01204574 	movhi	r4,33045
81118e1c:	213ebe04 	addi	r4,r4,-1288
81118e20:	11230300 	call	81123030 <fwrite>
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81118e24:	e03ffa05 	stb	zero,-24(fp)
81118e28:	0000a706 	br	811190c8 <vFillMemmoryPattern+0x2fc>
		/* n NFEE */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118e2c:	00a045f4 	movhi	r2,33047
81118e30:	10a00404 	addi	r2,r2,-32752
81118e34:	10800e8b 	ldhu	r2,58(r2)
81118e38:	10bfffcc 	andi	r2,r2,65535
81118e3c:	10800168 	cmpgeui	r2,r2,5
81118e40:	1000071e 	bne	r2,zero,81118e60 <vFillMemmoryPattern+0x94>
			fprintf(fp, "Memory %i\n",mem_number);
81118e44:	d0a06217 	ldw	r2,-32376(gp)
81118e48:	e0fffa03 	ldbu	r3,-24(fp)
81118e4c:	180d883a 	mov	r6,r3
81118e50:	01604574 	movhi	r5,33045
81118e54:	297ec904 	addi	r5,r5,-1244
81118e58:	1009883a 	mov	r4,r2
81118e5c:	11229940 	call	81122994 <fprintf>
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81118e60:	e03ffc85 	stb	zero,-14(fp)
81118e64:	00009206 	br	811190b0 <vFillMemmoryPattern+0x2e4>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118e68:	00a045f4 	movhi	r2,33047
81118e6c:	10a00404 	addi	r2,r2,-32752
81118e70:	10800e8b 	ldhu	r2,58(r2)
81118e74:	10bfffcc 	andi	r2,r2,65535
81118e78:	10800168 	cmpgeui	r2,r2,5
81118e7c:	1000071e 	bne	r2,zero,81118e9c <vFillMemmoryPattern+0xd0>
				fprintf(fp, "--NFEE %i\n", NFee_i);
81118e80:	d0a06217 	ldw	r2,-32376(gp)
81118e84:	e0fffc83 	ldbu	r3,-14(fp)
81118e88:	180d883a 	mov	r6,r3
81118e8c:	01604574 	movhi	r5,33045
81118e90:	297ecc04 	addi	r5,r5,-1232
81118e94:	1009883a 	mov	r4,r2
81118e98:	11229940 	call	81122994 <fprintf>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81118e9c:	e0bffc83 	ldbu	r2,-14(fp)
81118ea0:	e0ffff17 	ldw	r3,-4(fp)
81118ea4:	10809624 	muli	r2,r2,600
81118ea8:	1885883a 	add	r2,r3,r2
81118eac:	10804304 	addi	r2,r2,268
81118eb0:	1080000b 	ldhu	r2,0(r2)
81118eb4:	10ffffcc 	andi	r3,r2,65535
81118eb8:	e0bffc83 	ldbu	r2,-14(fp)
81118ebc:	e13fff17 	ldw	r4,-4(fp)
81118ec0:	10809624 	muli	r2,r2,600
81118ec4:	2085883a 	add	r2,r4,r2
81118ec8:	10804204 	addi	r2,r2,264
81118ecc:	1080000b 	ldhu	r2,0(r2)
81118ed0:	10bfffcc 	andi	r2,r2,65535
81118ed4:	1885883a 	add	r2,r3,r2
81118ed8:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81118edc:	e0bffc83 	ldbu	r2,-14(fp)
81118ee0:	e0ffff17 	ldw	r3,-4(fp)
81118ee4:	10809624 	muli	r2,r2,600
81118ee8:	1885883a 	add	r2,r3,r2
81118eec:	10804284 	addi	r2,r2,266
81118ef0:	1080000b 	ldhu	r2,0(r2)
81118ef4:	10ffffcc 	andi	r3,r2,65535
81118ef8:	e0bffc83 	ldbu	r2,-14(fp)
81118efc:	e13fff17 	ldw	r4,-4(fp)
81118f00:	10809624 	muli	r2,r2,600
81118f04:	2085883a 	add	r2,r4,r2
81118f08:	10804184 	addi	r2,r2,262
81118f0c:	1080000b 	ldhu	r2,0(r2)
81118f10:	10bfffcc 	andi	r2,r2,65535
81118f14:	1887883a 	add	r3,r3,r2
81118f18:	e0bffc83 	ldbu	r2,-14(fp)
81118f1c:	e13fff17 	ldw	r4,-4(fp)
81118f20:	10809624 	muli	r2,r2,600
81118f24:	2085883a 	add	r2,r4,r2
81118f28:	10804104 	addi	r2,r2,260
81118f2c:	1080000b 	ldhu	r2,0(r2)
81118f30:	10bfffcc 	andi	r2,r2,65535
81118f34:	1885883a 	add	r2,r3,r2
81118f38:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118f3c:	e03ffc05 	stb	zero,-16(fp)
81118f40:	00005506 	br	81119098 <vFillMemmoryPattern+0x2cc>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118f44:	00a045f4 	movhi	r2,33047
81118f48:	10a00404 	addi	r2,r2,-32752
81118f4c:	10800e8b 	ldhu	r2,58(r2)
81118f50:	10bfffcc 	andi	r2,r2,65535
81118f54:	10800168 	cmpgeui	r2,r2,5
81118f58:	1000071e 	bne	r2,zero,81118f78 <vFillMemmoryPattern+0x1ac>
					fprintf(fp, "-----CCD %i\n", ccd_number);
81118f5c:	d0a06217 	ldw	r2,-32376(gp)
81118f60:	e0fffc03 	ldbu	r3,-16(fp)
81118f64:	180d883a 	mov	r6,r3
81118f68:	01604574 	movhi	r5,33045
81118f6c:	297ecf04 	addi	r5,r5,-1220
81118f70:	1009883a 	mov	r4,r2
81118f74:	11229940 	call	81122994 <fprintf>
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81118f78:	e03ffc45 	stb	zero,-15(fp)
81118f7c:	00004006 	br	81119080 <vFillMemmoryPattern+0x2b4>
					if (ccd_side == 0){
81118f80:	e0bffc43 	ldbu	r2,-15(fp)
81118f84:	1000181e 	bne	r2,zero,81118fe8 <vFillMemmoryPattern+0x21c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118f88:	00a045f4 	movhi	r2,33047
81118f8c:	10a00404 	addi	r2,r2,-32752
81118f90:	10800e8b 	ldhu	r2,58(r2)
81118f94:	10bfffcc 	andi	r2,r2,65535
81118f98:	10800168 	cmpgeui	r2,r2,5
81118f9c:	1000071e 	bne	r2,zero,81118fbc <vFillMemmoryPattern+0x1f0>
							fprintf(fp, "------Left side\n");
81118fa0:	d0a06217 	ldw	r2,-32376(gp)
81118fa4:	100f883a 	mov	r7,r2
81118fa8:	01800404 	movi	r6,16
81118fac:	01400044 	movi	r5,1
81118fb0:	01204574 	movhi	r4,33045
81118fb4:	213ed304 	addi	r4,r4,-1204
81118fb8:	11230300 	call	81123030 <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81118fbc:	e0bffc83 	ldbu	r2,-14(fp)
81118fc0:	e13ffc03 	ldbu	r4,-16(fp)
81118fc4:	e0ffff17 	ldw	r3,-4(fp)
81118fc8:	21000624 	muli	r4,r4,24
81118fcc:	10809624 	muli	r2,r2,600
81118fd0:	2085883a 	add	r2,r4,r2
81118fd4:	1885883a 	add	r2,r3,r2
81118fd8:	10801b04 	addi	r2,r2,108
81118fdc:	10800017 	ldw	r2,0(r2)
81118fe0:	e0bffb15 	stw	r2,-20(fp)
81118fe4:	00001706 	br	81119044 <vFillMemmoryPattern+0x278>
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118fe8:	00a045f4 	movhi	r2,33047
81118fec:	10a00404 	addi	r2,r2,-32752
81118ff0:	10800e8b 	ldhu	r2,58(r2)
81118ff4:	10bfffcc 	andi	r2,r2,65535
81118ff8:	10800168 	cmpgeui	r2,r2,5
81118ffc:	1000071e 	bne	r2,zero,8111901c <vFillMemmoryPattern+0x250>
							fprintf(fp, "------Right side\n");
81119000:	d0a06217 	ldw	r2,-32376(gp)
81119004:	100f883a 	mov	r7,r2
81119008:	01800444 	movi	r6,17
8111900c:	01400044 	movi	r5,1
81119010:	01204574 	movhi	r4,33045
81119014:	213ed804 	addi	r4,r4,-1184
81119018:	11230300 	call	81123030 <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8111901c:	e0bffc83 	ldbu	r2,-14(fp)
81119020:	e13ffc03 	ldbu	r4,-16(fp)
81119024:	e0ffff17 	ldw	r3,-4(fp)
81119028:	21000624 	muli	r4,r4,24
8111902c:	10809624 	muli	r2,r2,600
81119030:	2085883a 	add	r2,r4,r2
81119034:	1885883a 	add	r2,r3,r2
81119038:	10801e04 	addi	r2,r2,120
8111903c:	10800017 	ldw	r2,0(r2)
81119040:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81119044:	e0fffa03 	ldbu	r3,-24(fp)
81119048:	e13ffc03 	ldbu	r4,-16(fp)
8111904c:	e17ffc43 	ldbu	r5,-15(fp)
81119050:	e0bffd17 	ldw	r2,-12(fp)
81119054:	d8800115 	stw	r2,4(sp)
81119058:	e0bffe17 	ldw	r2,-8(fp)
8111905c:	d8800015 	stw	r2,0(sp)
81119060:	280f883a 	mov	r7,r5
81119064:	200d883a 	mov	r6,r4
81119068:	e17ffb17 	ldw	r5,-20(fp)
8111906c:	1809883a 	mov	r4,r3
81119070:	111fc5c0 	call	8111fc5c <pattern_createPattern>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp, "-----CCD %i\n", ccd_number);
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81119074:	e0bffc43 	ldbu	r2,-15(fp)
81119078:	10800044 	addi	r2,r2,1
8111907c:	e0bffc45 	stb	r2,-15(fp)
81119080:	e0bffc43 	ldbu	r2,-15(fp)
81119084:	108000b0 	cmpltui	r2,r2,2
81119088:	103fbd1e 	bne	r2,zero,81118f80 <__reset+0xfb0f8f80>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8111908c:	e0bffc03 	ldbu	r2,-16(fp)
81119090:	10800044 	addi	r2,r2,1
81119094:	e0bffc05 	stb	r2,-16(fp)
81119098:	e0bffc03 	ldbu	r2,-16(fp)
8111909c:	10800130 	cmpltui	r2,r2,4
811190a0:	103fa81e 	bne	r2,zero,81118f44 <__reset+0xfb0f8f44>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			fprintf(fp, "Memory %i\n",mem_number);
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811190a4:	e0bffc83 	ldbu	r2,-14(fp)
811190a8:	10800044 	addi	r2,r2,1
811190ac:	e0bffc85 	stb	r2,-14(fp)
811190b0:	e0fffc83 	ldbu	r3,-14(fp)
811190b4:	e0bffcc3 	ldbu	r2,-13(fp)
811190b8:	18bf6b36 	bltu	r3,r2,81118e68 <__reset+0xfb0f8e68>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811190bc:	e0bffa03 	ldbu	r2,-24(fp)
811190c0:	10800044 	addi	r2,r2,1
811190c4:	e0bffa05 	stb	r2,-24(fp)
811190c8:	e0bffa03 	ldbu	r2,-24(fp)
811190cc:	108000b0 	cmpltui	r2,r2,2
811190d0:	103f561e 	bne	r2,zero,81118e2c <__reset+0xfb0f8e2c>
			}
		}
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811190d4:	00a045f4 	movhi	r2,33047
811190d8:	10a00404 	addi	r2,r2,-32752
811190dc:	10800e8b 	ldhu	r2,58(r2)
811190e0:	10bfffcc 	andi	r2,r2,65535
811190e4:	10800168 	cmpgeui	r2,r2,5
811190e8:	1000071e 	bne	r2,zero,81119108 <vFillMemmoryPattern+0x33c>
	debug(fp, "\nMemory Filled\n");
811190ec:	d0a06217 	ldw	r2,-32376(gp)
811190f0:	100f883a 	mov	r7,r2
811190f4:	018003c4 	movi	r6,15
811190f8:	01400044 	movi	r5,1
811190fc:	01204574 	movhi	r4,33045
81119100:	213edd04 	addi	r4,r4,-1164
81119104:	11230300 	call	81123030 <fwrite>
	}
#endif

}
81119108:	0001883a 	nop
8111910c:	e037883a 	mov	sp,fp
81119110:	dfc00117 	ldw	ra,4(sp)
81119114:	df000017 	ldw	fp,0(sp)
81119118:	dec00204 	addi	sp,sp,8
8111911c:	f800283a 	ret

81119120 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81119120:	defffd04 	addi	sp,sp,-12
81119124:	de00012e 	bgeu	sp,et,8111912c <vCCDLoadDefaultValues+0xc>
81119128:	003b68fa 	trap	3
8111912c:	dfc00215 	stw	ra,8(sp)
81119130:	df000115 	stw	fp,4(sp)
81119134:	df000104 	addi	fp,sp,4
81119138:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
8111913c:	00a045f4 	movhi	r2,33047
81119140:	10a00404 	addi	r2,r2,-32752
81119144:	10c0060b 	ldhu	r3,24(r2)
81119148:	e0bfff17 	ldw	r2,-4(fp)
8111914c:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
81119150:	00a045f4 	movhi	r2,33047
81119154:	10a00404 	addi	r2,r2,-32752
81119158:	10c0050b 	ldhu	r3,20(r2)
8111915c:	e0bfff17 	ldw	r2,-4(fp)
81119160:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81119164:	00a045f4 	movhi	r2,33047
81119168:	10a00404 	addi	r2,r2,-32752
8111916c:	10c0058b 	ldhu	r3,22(r2)
81119170:	e0bfff17 	ldw	r2,-4(fp)
81119174:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81119178:	00a045f4 	movhi	r2,33047
8111917c:	10a00404 	addi	r2,r2,-32752
81119180:	10c0040b 	ldhu	r3,16(r2)
81119184:	e0bfff17 	ldw	r2,-4(fp)
81119188:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
8111918c:	00a045f4 	movhi	r2,33047
81119190:	10a00404 	addi	r2,r2,-32752
81119194:	10c0048b 	ldhu	r3,18(r2)
81119198:	e0bfff17 	ldw	r2,-4(fp)
8111919c:	10c0000d 	sth	r3,0(r2)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811191a0:	00a045f4 	movhi	r2,33047
811191a4:	10a00404 	addi	r2,r2,-32752
811191a8:	10800e8b 	ldhu	r2,58(r2)
811191ac:	10bfffcc 	andi	r2,r2,65535
811191b0:	108000e8 	cmpgeui	r2,r2,3
811191b4:	10002d1e 	bne	r2,zero,8111926c <vCCDLoadDefaultValues+0x14c>
		fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
811191b8:	d0e06217 	ldw	r3,-32376(gp)
811191bc:	e0bfff17 	ldw	r2,-4(fp)
811191c0:	1080020b 	ldhu	r2,8(r2)
811191c4:	10bfffcc 	andi	r2,r2,65535
811191c8:	100d883a 	mov	r6,r2
811191cc:	01604574 	movhi	r5,33045
811191d0:	297ee104 	addi	r5,r5,-1148
811191d4:	1809883a 	mov	r4,r3
811191d8:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
811191dc:	d0e06217 	ldw	r3,-32376(gp)
811191e0:	e0bfff17 	ldw	r2,-4(fp)
811191e4:	1080010b 	ldhu	r2,4(r2)
811191e8:	10bfffcc 	andi	r2,r2,65535
811191ec:	100d883a 	mov	r6,r2
811191f0:	01604574 	movhi	r5,33045
811191f4:	297ee504 	addi	r5,r5,-1132
811191f8:	1809883a 	mov	r4,r3
811191fc:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
81119200:	d0e06217 	ldw	r3,-32376(gp)
81119204:	e0bfff17 	ldw	r2,-4(fp)
81119208:	1080018b 	ldhu	r2,6(r2)
8111920c:	10bfffcc 	andi	r2,r2,65535
81119210:	100d883a 	mov	r6,r2
81119214:	01604574 	movhi	r5,33045
81119218:	297ee804 	addi	r5,r5,-1120
8111921c:	1809883a 	mov	r4,r3
81119220:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
81119224:	d0e06217 	ldw	r3,-32376(gp)
81119228:	e0bfff17 	ldw	r2,-4(fp)
8111922c:	1080008b 	ldhu	r2,2(r2)
81119230:	10bfffcc 	andi	r2,r2,65535
81119234:	100d883a 	mov	r6,r2
81119238:	01604574 	movhi	r5,33045
8111923c:	297eed04 	addi	r5,r5,-1100
81119240:	1809883a 	mov	r4,r3
81119244:	11229940 	call	81122994 <fprintf>
		fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
81119248:	d0e06217 	ldw	r3,-32376(gp)
8111924c:	e0bfff17 	ldw	r2,-4(fp)
81119250:	1080000b 	ldhu	r2,0(r2)
81119254:	10bfffcc 	andi	r2,r2,65535
81119258:	100d883a 	mov	r6,r2
8111925c:	01604574 	movhi	r5,33045
81119260:	297ef204 	addi	r5,r5,-1080
81119264:	1809883a 	mov	r4,r3
81119268:	11229940 	call	81122994 <fprintf>
	}
#endif

}
8111926c:	0001883a 	nop
81119270:	e037883a 	mov	sp,fp
81119274:	dfc00117 	ldw	ra,4(sp)
81119278:	df000017 	ldw	fp,0(sp)
8111927c:	dec00204 	addi	sp,sp,8
81119280:	f800283a 	ret

81119284 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81119284:	defff904 	addi	sp,sp,-28
81119288:	de00012e 	bgeu	sp,et,81119290 <vCCDChangeValues+0xc>
8111928c:	003b68fa 	trap	3
81119290:	df000615 	stw	fp,24(sp)
81119294:	df000604 	addi	fp,sp,24
81119298:	e13ffa15 	stw	r4,-24(fp)
8111929c:	2811883a 	mov	r8,r5
811192a0:	300b883a 	mov	r5,r6
811192a4:	3809883a 	mov	r4,r7
811192a8:	e0c00117 	ldw	r3,4(fp)
811192ac:	e0800217 	ldw	r2,8(fp)
811192b0:	e23ffb0d 	sth	r8,-20(fp)
811192b4:	e17ffc0d 	sth	r5,-16(fp)
811192b8:	e13ffd0d 	sth	r4,-12(fp)
811192bc:	e0fffe0d 	sth	r3,-8(fp)
811192c0:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
811192c4:	e0bffa17 	ldw	r2,-24(fp)
811192c8:	e0fffb0b 	ldhu	r3,-20(fp)
811192cc:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
811192d0:	e0bffa17 	ldw	r2,-24(fp)
811192d4:	e0fffc0b 	ldhu	r3,-16(fp)
811192d8:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
811192dc:	e0bffa17 	ldw	r2,-24(fp)
811192e0:	e0fffd0b 	ldhu	r3,-12(fp)
811192e4:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
811192e8:	e0bffa17 	ldw	r2,-24(fp)
811192ec:	e0fffe0b 	ldhu	r3,-8(fp)
811192f0:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
811192f4:	e0bffa17 	ldw	r2,-24(fp)
811192f8:	e0ffff0b 	ldhu	r3,-4(fp)
811192fc:	10c0000d 	sth	r3,0(r2)
}
81119300:	0001883a 	nop
81119304:	e037883a 	mov	sp,fp
81119308:	df000017 	ldw	fp,0(sp)
8111930c:	dec00104 	addi	sp,sp,4
81119310:	f800283a 	ret

81119314 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81119314:	defff904 	addi	sp,sp,-28
81119318:	de00012e 	bgeu	sp,et,81119320 <bSendUART128v2+0xc>
8111931c:	003b68fa 	trap	3
81119320:	dfc00615 	stw	ra,24(sp)
81119324:	df000515 	stw	fp,20(sp)
81119328:	df000504 	addi	fp,sp,20
8111932c:	e13ffe15 	stw	r4,-8(fp)
81119330:	2805883a 	mov	r2,r5
81119334:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81119338:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111933c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119340:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119344:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119348:	d0a06317 	ldw	r2,-32372(gp)
8111934c:	e0fffd04 	addi	r3,fp,-12
81119350:	180d883a 	mov	r6,r3
81119354:	01400504 	movi	r5,20
81119358:	1009883a 	mov	r4,r2
8111935c:	113fe340 	call	8113fe34 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81119360:	e0bffd03 	ldbu	r2,-12(fp)
81119364:	10803fcc 	andi	r2,r2,255
81119368:	10000326 	beq	r2,zero,81119378 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111936c:	111ce880 	call	8111ce88 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81119370:	e0bffc17 	ldw	r2,-16(fp)
81119374:	0000aa06 	br	81119620 <bSendUART128v2+0x30c>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81119378:	d0a06e17 	ldw	r2,-32328(gp)
8111937c:	e0fffd04 	addi	r3,fp,-12
81119380:	180d883a 	mov	r6,r3
81119384:	01400104 	movi	r5,4
81119388:	1009883a 	mov	r4,r2
8111938c:	113de280 	call	8113de28 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119390:	e0bffd03 	ldbu	r2,-12(fp)
81119394:	10803fcc 	andi	r2,r2,255
81119398:	10001726 	beq	r2,zero,811193f8 <bSendUART128v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111939c:	00a045f4 	movhi	r2,33047
811193a0:	10a00404 	addi	r2,r2,-32752
811193a4:	10800e8b 	ldhu	r2,58(r2)
811193a8:	10bfffcc 	andi	r2,r2,65535
811193ac:	108001e8 	cmpgeui	r2,r2,7
811193b0:	1000071e 	bne	r2,zero,811193d0 <bSendUART128v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
811193b4:	d0a06217 	ldw	r2,-32376(gp)
811193b8:	100f883a 	mov	r7,r2
811193bc:	01801484 	movi	r6,82
811193c0:	01400044 	movi	r5,1
811193c4:	01204574 	movhi	r4,33045
811193c8:	213ef704 	addi	r4,r4,-1060
811193cc:	11230300 	call	81123030 <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811193d0:	d0a06317 	ldw	r2,-32372(gp)
811193d4:	1009883a 	mov	r4,r2
811193d8:	11401bc0 	call	811401bc <OSSemPost>
811193dc:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811193e0:	e0bffd03 	ldbu	r2,-12(fp)
811193e4:	10803fcc 	andi	r2,r2,255
811193e8:	10000126 	beq	r2,zero,811193f0 <bSendUART128v2+0xdc>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811193ec:	111ce080 	call	8111ce08 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
811193f0:	e0bffc17 	ldw	r2,-16(fp)
811193f4:	00008a06 	br	81119620 <bSendUART128v2+0x30c>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
811193f8:	e03ffb05 	stb	zero,-20(fp)
811193fc:	00004306 	br	8111950c <bSendUART128v2+0x1f8>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81119400:	e0fffb03 	ldbu	r3,-20(fp)
81119404:	00a045b4 	movhi	r2,33046
81119408:	10802204 	addi	r2,r2,136
8111940c:	18c7883a 	add	r3,r3,r3
81119410:	18c7883a 	add	r3,r3,r3
81119414:	10c5883a 	add	r2,r2,r3
81119418:	10800017 	ldw	r2,0(r2)
8111941c:	1000381e 	bne	r2,zero,81119500 <bSendUART128v2+0x1ec>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81119420:	e0bffb03 	ldbu	r2,-20(fp)
81119424:	10c02324 	muli	r3,r2,140
81119428:	00a045b4 	movhi	r2,33046
8111942c:	10804004 	addi	r2,r2,256
81119430:	1885883a 	add	r2,r3,r2
81119434:	01802004 	movi	r6,128
81119438:	000b883a 	mov	r5,zero
8111943c:	1009883a 	mov	r4,r2
81119440:	1123b940 	call	81123b94 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81119444:	e0bffb03 	ldbu	r2,-20(fp)
81119448:	10c02324 	muli	r3,r2,140
8111944c:	00a045b4 	movhi	r2,33046
81119450:	10804004 	addi	r2,r2,256
81119454:	1885883a 	add	r2,r3,r2
81119458:	01801fc4 	movi	r6,127
8111945c:	e17ffe17 	ldw	r5,-8(fp)
81119460:	1009883a 	mov	r4,r2
81119464:	1123a440 	call	81123a44 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81119468:	e13ffb03 	ldbu	r4,-20(fp)
8111946c:	e0ffff0b 	ldhu	r3,-4(fp)
81119470:	00a045b4 	movhi	r2,33046
81119474:	10804004 	addi	r2,r2,256
81119478:	21002324 	muli	r4,r4,140
8111947c:	1105883a 	add	r2,r2,r4
81119480:	10802104 	addi	r2,r2,132
81119484:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81119488:	e0fffb03 	ldbu	r3,-20(fp)
8111948c:	00a045b4 	movhi	r2,33046
81119490:	10804004 	addi	r2,r2,256
81119494:	18c02324 	muli	r3,r3,140
81119498:	10c5883a 	add	r2,r2,r3
8111949c:	10802204 	addi	r2,r2,136
811194a0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
811194a4:	e0fffb03 	ldbu	r3,-20(fp)
811194a8:	00a045b4 	movhi	r2,33046
811194ac:	10804004 	addi	r2,r2,256
811194b0:	18c02324 	muli	r3,r3,140
811194b4:	10c5883a 	add	r2,r2,r3
811194b8:	10802184 	addi	r2,r2,134
811194bc:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
811194c0:	e0fffb03 	ldbu	r3,-20(fp)
811194c4:	00a045b4 	movhi	r2,33046
811194c8:	10804004 	addi	r2,r2,256
811194cc:	18c02324 	muli	r3,r3,140
811194d0:	10c5883a 	add	r2,r2,r3
811194d4:	10802004 	addi	r2,r2,128
811194d8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
811194dc:	e0fffb03 	ldbu	r3,-20(fp)
811194e0:	00a045b4 	movhi	r2,33046
811194e4:	10802204 	addi	r2,r2,136
811194e8:	18c7883a 	add	r3,r3,r3
811194ec:	18c7883a 	add	r3,r3,r3
811194f0:	10c5883a 	add	r2,r2,r3
811194f4:	00c00044 	movi	r3,1
811194f8:	10c00015 	stw	r3,0(r2)
			break;
811194fc:	00000606 	br	81119518 <bSendUART128v2+0x204>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119500:	e0bffb03 	ldbu	r2,-20(fp)
81119504:	10800044 	addi	r2,r2,1
81119508:	e0bffb05 	stb	r2,-20(fp)
8111950c:	e0bffb03 	ldbu	r2,-20(fp)
81119510:	108001b0 	cmpltui	r2,r2,6
81119514:	103fba1e 	bne	r2,zero,81119400 <__reset+0xfb0f9400>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81119518:	e0bffb03 	ldbu	r2,-20(fp)
8111951c:	108001b0 	cmpltui	r2,r2,6
81119520:	1000091e 	bne	r2,zero,81119548 <bSendUART128v2+0x234>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81119524:	d0a06317 	ldw	r2,-32372(gp)
81119528:	1009883a 	mov	r4,r2
8111952c:	11401bc0 	call	811401bc <OSSemPost>
81119530:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81119534:	d0a06e17 	ldw	r2,-32328(gp)
81119538:	1009883a 	mov	r4,r2
8111953c:	113e3cc0 	call	8113e3cc <OSMutexPost>
		return bSuccessL;
81119540:	e0bffc17 	ldw	r2,-16(fp)
81119544:	00003606 	br	81119620 <bSendUART128v2+0x30c>
	}

	bSuccessL = TRUE;
81119548:	00800044 	movi	r2,1
8111954c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81119550:	d0a07543 	ldbu	r2,-32299(gp)
81119554:	10bfffc4 	addi	r2,r2,-1
81119558:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111955c:	d0a07417 	ldw	r2,-32304(gp)
81119560:	e0fffd04 	addi	r3,fp,-12
81119564:	180d883a 	mov	r6,r3
81119568:	01400084 	movi	r5,2
8111956c:	1009883a 	mov	r4,r2
81119570:	113de280 	call	8113de28 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119574:	e0bffd03 	ldbu	r2,-12(fp)
81119578:	10803fcc 	andi	r2,r2,255
8111957c:	10001226 	beq	r2,zero,811195c8 <bSendUART128v2+0x2b4>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119580:	00a045f4 	movhi	r2,33047
81119584:	10a00404 	addi	r2,r2,-32752
81119588:	10800e8b 	ldhu	r2,58(r2)
8111958c:	10bfffcc 	andi	r2,r2,65535
81119590:	108001e8 	cmpgeui	r2,r2,7
81119594:	1000071e 	bne	r2,zero,811195b4 <bSendUART128v2+0x2a0>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81119598:	d0a06217 	ldw	r2,-32376(gp)
8111959c:	100f883a 	mov	r7,r2
811195a0:	01801c04 	movi	r6,112
811195a4:	01400044 	movi	r5,1
811195a8:	01204574 	movhi	r4,33045
811195ac:	213f0c04 	addi	r4,r4,-976
811195b0:	11230300 	call	81123030 <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811195b4:	d0a06e17 	ldw	r2,-32328(gp)
811195b8:	1009883a 	mov	r4,r2
811195bc:	113e3cc0 	call	8113e3cc <OSMutexPost>
		return bSuccessL;
811195c0:	e0bffc17 	ldw	r2,-16(fp)
811195c4:	00001606 	br	81119620 <bSendUART128v2+0x30c>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
811195c8:	e0bffb03 	ldbu	r2,-20(fp)
811195cc:	10c02324 	muli	r3,r2,140
811195d0:	00a045b4 	movhi	r2,33046
811195d4:	10804004 	addi	r2,r2,256
811195d8:	1885883a 	add	r2,r3,r2
811195dc:	1009883a 	mov	r4,r2
811195e0:	1123f640 	call	81123f64 <puts>
	xBuffer128[ucIL].bSent = TRUE;
811195e4:	e0fffb03 	ldbu	r3,-20(fp)
811195e8:	00a045b4 	movhi	r2,33046
811195ec:	10804004 	addi	r2,r2,256
811195f0:	18c02324 	muli	r3,r3,140
811195f4:	10c5883a 	add	r2,r2,r3
811195f8:	10802004 	addi	r2,r2,128
811195fc:	00c00044 	movi	r3,1
81119600:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81119604:	d0a07417 	ldw	r2,-32304(gp)
81119608:	1009883a 	mov	r4,r2
8111960c:	113e3cc0 	call	8113e3cc <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81119610:	d0a06e17 	ldw	r2,-32328(gp)
81119614:	1009883a 	mov	r4,r2
81119618:	113e3cc0 	call	8113e3cc <OSMutexPost>

	return bSuccessL;
8111961c:	e0bffc17 	ldw	r2,-16(fp)
}
81119620:	e037883a 	mov	sp,fp
81119624:	dfc00117 	ldw	ra,4(sp)
81119628:	df000017 	ldw	fp,0(sp)
8111962c:	dec00204 	addi	sp,sp,8
81119630:	f800283a 	ret

81119634 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81119634:	defff904 	addi	sp,sp,-28
81119638:	de00012e 	bgeu	sp,et,81119640 <bSendUART64v2+0xc>
8111963c:	003b68fa 	trap	3
81119640:	dfc00615 	stw	ra,24(sp)
81119644:	df000515 	stw	fp,20(sp)
81119648:	df000504 	addi	fp,sp,20
8111964c:	e13ffe15 	stw	r4,-8(fp)
81119650:	2805883a 	mov	r2,r5
81119654:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81119658:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111965c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119660:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119664:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119668:	d0a05e17 	ldw	r2,-32392(gp)
8111966c:	e0fffd04 	addi	r3,fp,-12
81119670:	180d883a 	mov	r6,r3
81119674:	01400504 	movi	r5,20
81119678:	1009883a 	mov	r4,r2
8111967c:	113fe340 	call	8113fe34 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81119680:	e0bffd03 	ldbu	r2,-12(fp)
81119684:	10803fcc 	andi	r2,r2,255
81119688:	10000326 	beq	r2,zero,81119698 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111968c:	111cf080 	call	8111cf08 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81119690:	e0bffc17 	ldw	r2,-16(fp)
81119694:	0000ac06 	br	81119948 <bSendUART64v2+0x314>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81119698:	d0a07117 	ldw	r2,-32316(gp)
8111969c:	e0fffd04 	addi	r3,fp,-12
811196a0:	180d883a 	mov	r6,r3
811196a4:	01400104 	movi	r5,4
811196a8:	1009883a 	mov	r4,r2
811196ac:	113de280 	call	8113de28 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811196b0:	e0bffd03 	ldbu	r2,-12(fp)
811196b4:	10803fcc 	andi	r2,r2,255
811196b8:	10001726 	beq	r2,zero,81119718 <bSendUART64v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811196bc:	00a045f4 	movhi	r2,33047
811196c0:	10a00404 	addi	r2,r2,-32752
811196c4:	10800e8b 	ldhu	r2,58(r2)
811196c8:	10bfffcc 	andi	r2,r2,65535
811196cc:	108001e8 	cmpgeui	r2,r2,7
811196d0:	1000071e 	bne	r2,zero,811196f0 <bSendUART64v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
811196d4:	d0a06217 	ldw	r2,-32376(gp)
811196d8:	100f883a 	mov	r7,r2
811196dc:	018013c4 	movi	r6,79
811196e0:	01400044 	movi	r5,1
811196e4:	01204574 	movhi	r4,33045
811196e8:	213f2904 	addi	r4,r4,-860
811196ec:	11230300 	call	81123030 <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
811196f0:	d0a05e17 	ldw	r2,-32392(gp)
811196f4:	1009883a 	mov	r4,r2
811196f8:	11401bc0 	call	811401bc <OSSemPost>
811196fc:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119700:	e0bffd03 	ldbu	r2,-12(fp)
81119704:	10803fcc 	andi	r2,r2,255
81119708:	10000126 	beq	r2,zero,81119710 <bSendUART64v2+0xdc>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111970c:	111cd880 	call	8111cd88 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81119710:	e0bffc17 	ldw	r2,-16(fp)
81119714:	00008c06 	br	81119948 <bSendUART64v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81119718:	e03ffb05 	stb	zero,-20(fp)
8111971c:	00004506 	br	81119834 <bSendUART64v2+0x200>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81119720:	e0fffb03 	ldbu	r3,-20(fp)
81119724:	00a045b4 	movhi	r2,33046
81119728:	10802204 	addi	r2,r2,136
8111972c:	18c00184 	addi	r3,r3,6
81119730:	18c7883a 	add	r3,r3,r3
81119734:	18c7883a 	add	r3,r3,r3
81119738:	10c5883a 	add	r2,r2,r3
8111973c:	10800017 	ldw	r2,0(r2)
81119740:	1000391e 	bne	r2,zero,81119828 <bSendUART64v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81119744:	e0bffb03 	ldbu	r2,-20(fp)
81119748:	10c01324 	muli	r3,r2,76
8111974c:	00a04574 	movhi	r2,33045
81119750:	109be604 	addi	r2,r2,28568
81119754:	1885883a 	add	r2,r3,r2
81119758:	01801004 	movi	r6,64
8111975c:	000b883a 	mov	r5,zero
81119760:	1009883a 	mov	r4,r2
81119764:	1123b940 	call	81123b94 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81119768:	e0bffb03 	ldbu	r2,-20(fp)
8111976c:	10c01324 	muli	r3,r2,76
81119770:	00a04574 	movhi	r2,33045
81119774:	109be604 	addi	r2,r2,28568
81119778:	1885883a 	add	r2,r3,r2
8111977c:	01800fc4 	movi	r6,63
81119780:	e17ffe17 	ldw	r5,-8(fp)
81119784:	1009883a 	mov	r4,r2
81119788:	1123a440 	call	81123a44 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
8111978c:	e13ffb03 	ldbu	r4,-20(fp)
81119790:	e0ffff0b 	ldhu	r3,-4(fp)
81119794:	00a04574 	movhi	r2,33045
81119798:	109be604 	addi	r2,r2,28568
8111979c:	21001324 	muli	r4,r4,76
811197a0:	1105883a 	add	r2,r2,r4
811197a4:	10801104 	addi	r2,r2,68
811197a8:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
811197ac:	e0fffb03 	ldbu	r3,-20(fp)
811197b0:	00a04574 	movhi	r2,33045
811197b4:	109be604 	addi	r2,r2,28568
811197b8:	18c01324 	muli	r3,r3,76
811197bc:	10c5883a 	add	r2,r2,r3
811197c0:	10801204 	addi	r2,r2,72
811197c4:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
811197c8:	e0fffb03 	ldbu	r3,-20(fp)
811197cc:	00a04574 	movhi	r2,33045
811197d0:	109be604 	addi	r2,r2,28568
811197d4:	18c01324 	muli	r3,r3,76
811197d8:	10c5883a 	add	r2,r2,r3
811197dc:	10801184 	addi	r2,r2,70
811197e0:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
811197e4:	e0fffb03 	ldbu	r3,-20(fp)
811197e8:	00a04574 	movhi	r2,33045
811197ec:	109be604 	addi	r2,r2,28568
811197f0:	18c01324 	muli	r3,r3,76
811197f4:	10c5883a 	add	r2,r2,r3
811197f8:	10801004 	addi	r2,r2,64
811197fc:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81119800:	e0fffb03 	ldbu	r3,-20(fp)
81119804:	00a045b4 	movhi	r2,33046
81119808:	10802204 	addi	r2,r2,136
8111980c:	18c00184 	addi	r3,r3,6
81119810:	18c7883a 	add	r3,r3,r3
81119814:	18c7883a 	add	r3,r3,r3
81119818:	10c5883a 	add	r2,r2,r3
8111981c:	00c00044 	movi	r3,1
81119820:	10c00015 	stw	r3,0(r2)
			break;
81119824:	00000606 	br	81119840 <bSendUART64v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81119828:	e0bffb03 	ldbu	r2,-20(fp)
8111982c:	10800044 	addi	r2,r2,1
81119830:	e0bffb05 	stb	r2,-20(fp)
81119834:	e0bffb03 	ldbu	r2,-20(fp)
81119838:	10800230 	cmpltui	r2,r2,8
8111983c:	103fb81e 	bne	r2,zero,81119720 <__reset+0xfb0f9720>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81119840:	e0bffb03 	ldbu	r2,-20(fp)
81119844:	10800230 	cmpltui	r2,r2,8
81119848:	1000091e 	bne	r2,zero,81119870 <bSendUART64v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8111984c:	d0a05e17 	ldw	r2,-32392(gp)
81119850:	1009883a 	mov	r4,r2
81119854:	11401bc0 	call	811401bc <OSSemPost>
81119858:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
8111985c:	d0a07117 	ldw	r2,-32316(gp)
81119860:	1009883a 	mov	r4,r2
81119864:	113e3cc0 	call	8113e3cc <OSMutexPost>
		return bSuccessL;
81119868:	e0bffc17 	ldw	r2,-16(fp)
8111986c:	00003606 	br	81119948 <bSendUART64v2+0x314>
	}

	bSuccessL = TRUE;
81119870:	00800044 	movi	r2,1
81119874:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81119878:	d0a07503 	ldbu	r2,-32300(gp)
8111987c:	10bfffc4 	addi	r2,r2,-1
81119880:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81119884:	d0a07417 	ldw	r2,-32304(gp)
81119888:	e0fffd04 	addi	r3,fp,-12
8111988c:	180d883a 	mov	r6,r3
81119890:	01400084 	movi	r5,2
81119894:	1009883a 	mov	r4,r2
81119898:	113de280 	call	8113de28 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111989c:	e0bffd03 	ldbu	r2,-12(fp)
811198a0:	10803fcc 	andi	r2,r2,255
811198a4:	10001226 	beq	r2,zero,811198f0 <bSendUART64v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811198a8:	00a045f4 	movhi	r2,33047
811198ac:	10a00404 	addi	r2,r2,-32752
811198b0:	10800e8b 	ldhu	r2,58(r2)
811198b4:	10bfffcc 	andi	r2,r2,65535
811198b8:	108001e8 	cmpgeui	r2,r2,7
811198bc:	1000071e 	bne	r2,zero,811198dc <bSendUART64v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
811198c0:	d0a06217 	ldw	r2,-32376(gp)
811198c4:	100f883a 	mov	r7,r2
811198c8:	01801bc4 	movi	r6,111
811198cc:	01400044 	movi	r5,1
811198d0:	01204574 	movhi	r4,33045
811198d4:	213f3d04 	addi	r4,r4,-780
811198d8:	11230300 	call	81123030 <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
811198dc:	d0a07117 	ldw	r2,-32316(gp)
811198e0:	1009883a 	mov	r4,r2
811198e4:	113e3cc0 	call	8113e3cc <OSMutexPost>
		return bSuccessL;
811198e8:	e0bffc17 	ldw	r2,-16(fp)
811198ec:	00001606 	br	81119948 <bSendUART64v2+0x314>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
811198f0:	e0bffb03 	ldbu	r2,-20(fp)
811198f4:	10c01324 	muli	r3,r2,76
811198f8:	00a04574 	movhi	r2,33045
811198fc:	109be604 	addi	r2,r2,28568
81119900:	1885883a 	add	r2,r3,r2
81119904:	1009883a 	mov	r4,r2
81119908:	1123f640 	call	81123f64 <puts>
	xBuffer64[ucIL].bSent = TRUE;
8111990c:	e0fffb03 	ldbu	r3,-20(fp)
81119910:	00a04574 	movhi	r2,33045
81119914:	109be604 	addi	r2,r2,28568
81119918:	18c01324 	muli	r3,r3,76
8111991c:	10c5883a 	add	r2,r2,r3
81119920:	10801004 	addi	r2,r2,64
81119924:	00c00044 	movi	r3,1
81119928:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
8111992c:	d0a07417 	ldw	r2,-32304(gp)
81119930:	1009883a 	mov	r4,r2
81119934:	113e3cc0 	call	8113e3cc <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81119938:	d0a07117 	ldw	r2,-32316(gp)
8111993c:	1009883a 	mov	r4,r2
81119940:	113e3cc0 	call	8113e3cc <OSMutexPost>

	return bSuccessL;
81119944:	e0bffc17 	ldw	r2,-16(fp)
}
81119948:	e037883a 	mov	sp,fp
8111994c:	dfc00117 	ldw	ra,4(sp)
81119950:	df000017 	ldw	fp,0(sp)
81119954:	dec00204 	addi	sp,sp,8
81119958:	f800283a 	ret

8111995c <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8111995c:	defff904 	addi	sp,sp,-28
81119960:	de00012e 	bgeu	sp,et,81119968 <bSendUART32v2+0xc>
81119964:	003b68fa 	trap	3
81119968:	dfc00615 	stw	ra,24(sp)
8111996c:	df000515 	stw	fp,20(sp)
81119970:	df000504 	addi	fp,sp,20
81119974:	e13ffe15 	stw	r4,-8(fp)
81119978:	2805883a 	mov	r2,r5
8111997c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81119980:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81119984:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119988:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111998c:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119990:	d0a06f17 	ldw	r2,-32324(gp)
81119994:	e0fffd04 	addi	r3,fp,-12
81119998:	180d883a 	mov	r6,r3
8111999c:	01400504 	movi	r5,20
811199a0:	1009883a 	mov	r4,r2
811199a4:	113fe340 	call	8113fe34 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811199a8:	e0bffd03 	ldbu	r2,-12(fp)
811199ac:	10803fcc 	andi	r2,r2,255
811199b0:	10000326 	beq	r2,zero,811199c0 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811199b4:	111cf880 	call	8111cf88 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811199b8:	e0bffc17 	ldw	r2,-16(fp)
811199bc:	0000ac06 	br	81119c70 <bSendUART32v2+0x314>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811199c0:	d0a06c17 	ldw	r2,-32336(gp)
811199c4:	e0fffd04 	addi	r3,fp,-12
811199c8:	180d883a 	mov	r6,r3
811199cc:	01400104 	movi	r5,4
811199d0:	1009883a 	mov	r4,r2
811199d4:	113de280 	call	8113de28 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811199d8:	e0bffd03 	ldbu	r2,-12(fp)
811199dc:	10803fcc 	andi	r2,r2,255
811199e0:	10001726 	beq	r2,zero,81119a40 <bSendUART32v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811199e4:	00a045f4 	movhi	r2,33047
811199e8:	10a00404 	addi	r2,r2,-32752
811199ec:	10800e8b 	ldhu	r2,58(r2)
811199f0:	10bfffcc 	andi	r2,r2,65535
811199f4:	108001e8 	cmpgeui	r2,r2,7
811199f8:	1000071e 	bne	r2,zero,81119a18 <bSendUART32v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
811199fc:	d0a06217 	ldw	r2,-32376(gp)
81119a00:	100f883a 	mov	r7,r2
81119a04:	018013c4 	movi	r6,79
81119a08:	01400044 	movi	r5,1
81119a0c:	01204574 	movhi	r4,33045
81119a10:	213f5904 	addi	r4,r4,-668
81119a14:	11230300 	call	81123030 <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81119a18:	d0a06f17 	ldw	r2,-32324(gp)
81119a1c:	1009883a 	mov	r4,r2
81119a20:	11401bc0 	call	811401bc <OSSemPost>
81119a24:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119a28:	e0bffd03 	ldbu	r2,-12(fp)
81119a2c:	10803fcc 	andi	r2,r2,255
81119a30:	10000126 	beq	r2,zero,81119a38 <bSendUART32v2+0xdc>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81119a34:	111cd080 	call	8111cd08 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81119a38:	e0bffc17 	ldw	r2,-16(fp)
81119a3c:	00008c06 	br	81119c70 <bSendUART32v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81119a40:	e03ffb05 	stb	zero,-20(fp)
81119a44:	00004506 	br	81119b5c <bSendUART32v2+0x200>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81119a48:	e0fffb03 	ldbu	r3,-20(fp)
81119a4c:	00a045b4 	movhi	r2,33046
81119a50:	10802204 	addi	r2,r2,136
81119a54:	18c00384 	addi	r3,r3,14
81119a58:	18c7883a 	add	r3,r3,r3
81119a5c:	18c7883a 	add	r3,r3,r3
81119a60:	10c5883a 	add	r2,r2,r3
81119a64:	10800017 	ldw	r2,0(r2)
81119a68:	1000391e 	bne	r2,zero,81119b50 <bSendUART32v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81119a6c:	e0bffb03 	ldbu	r2,-20(fp)
81119a70:	10c00b24 	muli	r3,r2,44
81119a74:	00a045b4 	movhi	r2,33046
81119a78:	10ada204 	addi	r2,r2,-18808
81119a7c:	1885883a 	add	r2,r3,r2
81119a80:	01800804 	movi	r6,32
81119a84:	000b883a 	mov	r5,zero
81119a88:	1009883a 	mov	r4,r2
81119a8c:	1123b940 	call	81123b94 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81119a90:	e0bffb03 	ldbu	r2,-20(fp)
81119a94:	10c00b24 	muli	r3,r2,44
81119a98:	00a045b4 	movhi	r2,33046
81119a9c:	10ada204 	addi	r2,r2,-18808
81119aa0:	1885883a 	add	r2,r3,r2
81119aa4:	018007c4 	movi	r6,31
81119aa8:	e17ffe17 	ldw	r5,-8(fp)
81119aac:	1009883a 	mov	r4,r2
81119ab0:	1123a440 	call	81123a44 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81119ab4:	e13ffb03 	ldbu	r4,-20(fp)
81119ab8:	e0ffff0b 	ldhu	r3,-4(fp)
81119abc:	00a045b4 	movhi	r2,33046
81119ac0:	10ada204 	addi	r2,r2,-18808
81119ac4:	21000b24 	muli	r4,r4,44
81119ac8:	1105883a 	add	r2,r2,r4
81119acc:	10800904 	addi	r2,r2,36
81119ad0:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81119ad4:	e0fffb03 	ldbu	r3,-20(fp)
81119ad8:	00a045b4 	movhi	r2,33046
81119adc:	10ada204 	addi	r2,r2,-18808
81119ae0:	18c00b24 	muli	r3,r3,44
81119ae4:	10c5883a 	add	r2,r2,r3
81119ae8:	10800a04 	addi	r2,r2,40
81119aec:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81119af0:	e0fffb03 	ldbu	r3,-20(fp)
81119af4:	00a045b4 	movhi	r2,33046
81119af8:	10ada204 	addi	r2,r2,-18808
81119afc:	18c00b24 	muli	r3,r3,44
81119b00:	10c5883a 	add	r2,r2,r3
81119b04:	10800984 	addi	r2,r2,38
81119b08:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81119b0c:	e0fffb03 	ldbu	r3,-20(fp)
81119b10:	00a045b4 	movhi	r2,33046
81119b14:	10ada204 	addi	r2,r2,-18808
81119b18:	18c00b24 	muli	r3,r3,44
81119b1c:	10c5883a 	add	r2,r2,r3
81119b20:	10800804 	addi	r2,r2,32
81119b24:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81119b28:	e0fffb03 	ldbu	r3,-20(fp)
81119b2c:	00a045b4 	movhi	r2,33046
81119b30:	10802204 	addi	r2,r2,136
81119b34:	18c00384 	addi	r3,r3,14
81119b38:	18c7883a 	add	r3,r3,r3
81119b3c:	18c7883a 	add	r3,r3,r3
81119b40:	10c5883a 	add	r2,r2,r3
81119b44:	00c00044 	movi	r3,1
81119b48:	10c00015 	stw	r3,0(r2)
			break;
81119b4c:	00000606 	br	81119b68 <bSendUART32v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81119b50:	e0bffb03 	ldbu	r2,-20(fp)
81119b54:	10800044 	addi	r2,r2,1
81119b58:	e0bffb05 	stb	r2,-20(fp)
81119b5c:	e0bffb03 	ldbu	r2,-20(fp)
81119b60:	10800230 	cmpltui	r2,r2,8
81119b64:	103fb81e 	bne	r2,zero,81119a48 <__reset+0xfb0f9a48>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81119b68:	e0bffb03 	ldbu	r2,-20(fp)
81119b6c:	10800230 	cmpltui	r2,r2,8
81119b70:	1000091e 	bne	r2,zero,81119b98 <bSendUART32v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81119b74:	d0a06f17 	ldw	r2,-32324(gp)
81119b78:	1009883a 	mov	r4,r2
81119b7c:	11401bc0 	call	811401bc <OSSemPost>
81119b80:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81119b84:	d0a06c17 	ldw	r2,-32336(gp)
81119b88:	1009883a 	mov	r4,r2
81119b8c:	113e3cc0 	call	8113e3cc <OSMutexPost>
		return bSuccessL;
81119b90:	e0bffc17 	ldw	r2,-16(fp)
81119b94:	00003606 	br	81119c70 <bSendUART32v2+0x314>
	}
	
	bSuccessL = TRUE;
81119b98:	00800044 	movi	r2,1
81119b9c:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81119ba0:	d0a06883 	ldbu	r2,-32350(gp)
81119ba4:	10bfffc4 	addi	r2,r2,-1
81119ba8:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81119bac:	d0a07417 	ldw	r2,-32304(gp)
81119bb0:	e0fffd04 	addi	r3,fp,-12
81119bb4:	180d883a 	mov	r6,r3
81119bb8:	01400084 	movi	r5,2
81119bbc:	1009883a 	mov	r4,r2
81119bc0:	113de280 	call	8113de28 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119bc4:	e0bffd03 	ldbu	r2,-12(fp)
81119bc8:	10803fcc 	andi	r2,r2,255
81119bcc:	10001226 	beq	r2,zero,81119c18 <bSendUART32v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119bd0:	00a045f4 	movhi	r2,33047
81119bd4:	10a00404 	addi	r2,r2,-32752
81119bd8:	10800e8b 	ldhu	r2,58(r2)
81119bdc:	10bfffcc 	andi	r2,r2,65535
81119be0:	108001e8 	cmpgeui	r2,r2,7
81119be4:	1000071e 	bne	r2,zero,81119c04 <bSendUART32v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81119be8:	d0a06217 	ldw	r2,-32376(gp)
81119bec:	100f883a 	mov	r7,r2
81119bf0:	01801bc4 	movi	r6,111
81119bf4:	01400044 	movi	r5,1
81119bf8:	01204574 	movhi	r4,33045
81119bfc:	213f6d04 	addi	r4,r4,-588
81119c00:	11230300 	call	81123030 <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81119c04:	d0a06c17 	ldw	r2,-32336(gp)
81119c08:	1009883a 	mov	r4,r2
81119c0c:	113e3cc0 	call	8113e3cc <OSMutexPost>
		return bSuccessL;
81119c10:	e0bffc17 	ldw	r2,-16(fp)
81119c14:	00001606 	br	81119c70 <bSendUART32v2+0x314>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81119c18:	e0bffb03 	ldbu	r2,-20(fp)
81119c1c:	10c00b24 	muli	r3,r2,44
81119c20:	00a045b4 	movhi	r2,33046
81119c24:	10ada204 	addi	r2,r2,-18808
81119c28:	1885883a 	add	r2,r3,r2
81119c2c:	1009883a 	mov	r4,r2
81119c30:	1123f640 	call	81123f64 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81119c34:	e0fffb03 	ldbu	r3,-20(fp)
81119c38:	00a045b4 	movhi	r2,33046
81119c3c:	10ada204 	addi	r2,r2,-18808
81119c40:	18c00b24 	muli	r3,r3,44
81119c44:	10c5883a 	add	r2,r2,r3
81119c48:	10800804 	addi	r2,r2,32
81119c4c:	00c00044 	movi	r3,1
81119c50:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81119c54:	d0a07417 	ldw	r2,-32304(gp)
81119c58:	1009883a 	mov	r4,r2
81119c5c:	113e3cc0 	call	8113e3cc <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81119c60:	d0a06c17 	ldw	r2,-32336(gp)
81119c64:	1009883a 	mov	r4,r2
81119c68:	113e3cc0 	call	8113e3cc <OSMutexPost>

	return bSuccessL;
81119c6c:	e0bffc17 	ldw	r2,-16(fp)
}
81119c70:	e037883a 	mov	sp,fp
81119c74:	dfc00117 	ldw	ra,4(sp)
81119c78:	df000017 	ldw	fp,0(sp)
81119c7c:	dec00204 	addi	sp,sp,8
81119c80:	f800283a 	ret

81119c84 <vSendEthConf>:


void vSendEthConf ( void ) {
81119c84:	deffc304 	addi	sp,sp,-244
81119c88:	de00012e 	bgeu	sp,et,81119c90 <vSendEthConf+0xc>
81119c8c:	003b68fa 	trap	3
81119c90:	dfc03c15 	stw	ra,240(sp)
81119c94:	df003b15 	stw	fp,236(sp)
81119c98:	dd403a15 	stw	r21,232(sp)
81119c9c:	dd003915 	stw	r20,228(sp)
81119ca0:	dcc03815 	stw	r19,224(sp)
81119ca4:	dc803715 	stw	r18,220(sp)
81119ca8:	dc403615 	stw	r17,216(sp)
81119cac:	dc003515 	stw	r16,212(sp)
81119cb0:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81119cb4:	e03fd98d 	sth	zero,-154(fp)
81119cb8:	e03fda0d 	sth	zero,-152(fp)
81119cbc:	e0bfda84 	addi	r2,fp,-150
81119cc0:	00c01f04 	movi	r3,124
81119cc4:	180d883a 	mov	r6,r3
81119cc8:	000b883a 	mov	r5,zero
81119ccc:	1009883a 	mov	r4,r2
81119cd0:	1123b940 	call	81123b94 <memset>
    unsigned char crc = 0;
81119cd4:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119cd8:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119cdc:	111a2440 	call	8111a244 <usiGetIdCMD>
81119ce0:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119ce4:	e57fd90b 	ldhu	r21,-156(fp)
81119ce8:	00a045f4 	movhi	r2,33047
81119cec:	10a01404 	addi	r2,r2,-32688
81119cf0:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119cf4:	00a045f4 	movhi	r2,33047
81119cf8:	10a01404 	addi	r2,r2,-32688
81119cfc:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d00:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d04:	00a045f4 	movhi	r2,33047
81119d08:	10a01404 	addi	r2,r2,-32688
81119d0c:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d10:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d14:	00a045f4 	movhi	r2,33047
81119d18:	10a01404 	addi	r2,r2,-32688
81119d1c:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d20:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d24:	00a045f4 	movhi	r2,33047
81119d28:	10a01404 	addi	r2,r2,-32688
81119d2c:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d30:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d34:	00a045f4 	movhi	r2,33047
81119d38:	10a01404 	addi	r2,r2,-32688
81119d3c:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d40:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d44:	00a045f4 	movhi	r2,33047
81119d48:	10a01404 	addi	r2,r2,-32688
81119d4c:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d50:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d54:	00a045f4 	movhi	r2,33047
81119d58:	10a01404 	addi	r2,r2,-32688
81119d5c:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d60:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d64:	00a045f4 	movhi	r2,33047
81119d68:	10a01404 	addi	r2,r2,-32688
81119d6c:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d70:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119d74:	00a045f4 	movhi	r2,33047
81119d78:	10a01404 	addi	r2,r2,-32688
81119d7c:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d80:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119d84:	00a045f4 	movhi	r2,33047
81119d88:	10a01404 	addi	r2,r2,-32688
81119d8c:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d90:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119d94:	00a045f4 	movhi	r2,33047
81119d98:	10a01404 	addi	r2,r2,-32688
81119d9c:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119da0:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119da4:	00a045f4 	movhi	r2,33047
81119da8:	10a01404 	addi	r2,r2,-32688
81119dac:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119db0:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119db4:	00a045f4 	movhi	r2,33047
81119db8:	10a01404 	addi	r2,r2,-32688
81119dbc:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119dc0:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119dc4:	00a045f4 	movhi	r2,33047
81119dc8:	10a01404 	addi	r2,r2,-32688
81119dcc:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119dd0:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119dd4:	00a045f4 	movhi	r2,33047
81119dd8:	10a01404 	addi	r2,r2,-32688
81119ddc:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119de0:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119de4:	00a045f4 	movhi	r2,33047
81119de8:	10a01404 	addi	r2,r2,-32688
81119dec:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119df0:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81119df4:	00a045f4 	movhi	r2,33047
81119df8:	10a01404 	addi	r2,r2,-32688
81119dfc:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119e00:	10bfffcc 	andi	r2,r2,65535
81119e04:	e53fd984 	addi	r20,fp,-154
81119e08:	d8801115 	stw	r2,68(sp)
81119e0c:	dcc01015 	stw	r19,64(sp)
81119e10:	dc800f15 	stw	r18,60(sp)
81119e14:	dc400e15 	stw	r17,56(sp)
81119e18:	dc000d15 	stw	r16,52(sp)
81119e1c:	dbc00c15 	stw	r15,48(sp)
81119e20:	db800b15 	stw	r14,44(sp)
81119e24:	db400a15 	stw	r13,40(sp)
81119e28:	db000915 	stw	r12,36(sp)
81119e2c:	dac00815 	stw	r11,32(sp)
81119e30:	da800715 	stw	r10,28(sp)
81119e34:	da400615 	stw	r9,24(sp)
81119e38:	da000515 	stw	r8,20(sp)
81119e3c:	d9c00415 	stw	r7,16(sp)
81119e40:	d9800315 	stw	r6,12(sp)
81119e44:	d9400215 	stw	r5,8(sp)
81119e48:	d9000115 	stw	r4,4(sp)
81119e4c:	d8c00015 	stw	r3,0(sp)
81119e50:	a80f883a 	mov	r7,r21
81119e54:	018010c4 	movi	r6,67
81119e58:	01604574 	movhi	r5,33045
81119e5c:	297f8904 	addi	r5,r5,-476
81119e60:	a009883a 	mov	r4,r20
81119e64:	11242a80 	call	811242a8 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81119e68:	e0bfd984 	addi	r2,fp,-154
81119e6c:	1009883a 	mov	r4,r2
81119e70:	11244bc0 	call	811244bc <strlen>
81119e74:	1007883a 	mov	r3,r2
81119e78:	e0bfd984 	addi	r2,fp,-154
81119e7c:	180b883a 	mov	r5,r3
81119e80:	1009883a 	mov	r4,r2
81119e84:	111c3980 	call	8111c398 <ucCrc8wInit>
81119e88:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81119e8c:	e13fd703 	ldbu	r4,-164(fp)
81119e90:	e0ffd984 	addi	r3,fp,-154
81119e94:	e0bfd984 	addi	r2,fp,-154
81119e98:	200f883a 	mov	r7,r4
81119e9c:	180d883a 	mov	r6,r3
81119ea0:	01604574 	movhi	r5,33045
81119ea4:	297fa104 	addi	r5,r5,-380
81119ea8:	1009883a 	mov	r4,r2
81119eac:	11242a80 	call	811242a8 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81119eb0:	e0bfd90b 	ldhu	r2,-156(fp)
81119eb4:	10ffffcc 	andi	r3,r2,65535
81119eb8:	18e0001c 	xori	r3,r3,32768
81119ebc:	18e00004 	addi	r3,r3,-32768
81119ec0:	e0bfd984 	addi	r2,fp,-154
81119ec4:	180b883a 	mov	r5,r3
81119ec8:	1009883a 	mov	r4,r2
81119ecc:	11193140 	call	81119314 <bSendUART128v2>
81119ed0:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81119ed4:	e0bfd817 	ldw	r2,-160(fp)
81119ed8:	10800060 	cmpeqi	r2,r2,1
81119edc:	1000011e 	bne	r2,zero,81119ee4 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81119ee0:	111d2080 	call	8111d208 <vCouldNotSendEthConfUART>
	}
}
81119ee4:	0001883a 	nop
81119ee8:	e6fffa04 	addi	sp,fp,-24
81119eec:	dfc00717 	ldw	ra,28(sp)
81119ef0:	df000617 	ldw	fp,24(sp)
81119ef4:	dd400517 	ldw	r21,20(sp)
81119ef8:	dd000417 	ldw	r20,16(sp)
81119efc:	dcc00317 	ldw	r19,12(sp)
81119f00:	dc800217 	ldw	r18,8(sp)
81119f04:	dc400117 	ldw	r17,4(sp)
81119f08:	dc000017 	ldw	r16,0(sp)
81119f0c:	dec00804 	addi	sp,sp,32
81119f10:	f800283a 	ret

81119f14 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81119f14:	defff304 	addi	sp,sp,-52
81119f18:	de00012e 	bgeu	sp,et,81119f20 <vSendTurnOff+0xc>
81119f1c:	003b68fa 	trap	3
81119f20:	dfc00c15 	stw	ra,48(sp)
81119f24:	df000b15 	stw	fp,44(sp)
81119f28:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81119f2c:	e03ff78d 	sth	zero,-34(fp)
81119f30:	e03ff80d 	sth	zero,-32(fp)
81119f34:	e03ff88d 	sth	zero,-30(fp)
81119f38:	e03ff90d 	sth	zero,-28(fp)
81119f3c:	e03ff98d 	sth	zero,-26(fp)
81119f40:	e03ffa0d 	sth	zero,-24(fp)
81119f44:	e03ffa8d 	sth	zero,-22(fp)
81119f48:	e03ffb0d 	sth	zero,-20(fp)
81119f4c:	e03ffb8d 	sth	zero,-18(fp)
81119f50:	e03ffc0d 	sth	zero,-16(fp)
81119f54:	e03ffc8d 	sth	zero,-14(fp)
81119f58:	e03ffd0d 	sth	zero,-12(fp)
81119f5c:	e03ffd8d 	sth	zero,-10(fp)
81119f60:	e03ffe0d 	sth	zero,-8(fp)
81119f64:	e03ffe8d 	sth	zero,-6(fp)
81119f68:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81119f6c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119f70:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119f74:	111a2440 	call	8111a244 <usiGetIdCMD>
81119f78:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81119f7c:	e0fff70b 	ldhu	r3,-36(fp)
81119f80:	e0bff784 	addi	r2,fp,-34
81119f84:	180d883a 	mov	r6,r3
81119f88:	01604574 	movhi	r5,33045
81119f8c:	297fa404 	addi	r5,r5,-368
81119f90:	1009883a 	mov	r4,r2
81119f94:	11242a80 	call	811242a8 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81119f98:	e0bff784 	addi	r2,fp,-34
81119f9c:	1009883a 	mov	r4,r2
81119fa0:	11244bc0 	call	811244bc <strlen>
81119fa4:	1007883a 	mov	r3,r2
81119fa8:	e0bff784 	addi	r2,fp,-34
81119fac:	180b883a 	mov	r5,r3
81119fb0:	1009883a 	mov	r4,r2
81119fb4:	111c3980 	call	8111c398 <ucCrc8wInit>
81119fb8:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81119fbc:	e13ff503 	ldbu	r4,-44(fp)
81119fc0:	e0fff784 	addi	r3,fp,-34
81119fc4:	e0bff784 	addi	r2,fp,-34
81119fc8:	200f883a 	mov	r7,r4
81119fcc:	180d883a 	mov	r6,r3
81119fd0:	01604574 	movhi	r5,33045
81119fd4:	297fa104 	addi	r5,r5,-380
81119fd8:	1009883a 	mov	r4,r2
81119fdc:	11242a80 	call	811242a8 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81119fe0:	e0bff70b 	ldhu	r2,-36(fp)
81119fe4:	10ffffcc 	andi	r3,r2,65535
81119fe8:	18e0001c 	xori	r3,r3,32768
81119fec:	18e00004 	addi	r3,r3,-32768
81119ff0:	e0bff784 	addi	r2,fp,-34
81119ff4:	180b883a 	mov	r5,r3
81119ff8:	1009883a 	mov	r4,r2
81119ffc:	111995c0 	call	8111995c <bSendUART32v2>
8111a000:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111a004:	e0bff617 	ldw	r2,-40(fp)
8111a008:	10800060 	cmpeqi	r2,r2,1
8111a00c:	1000011e 	bne	r2,zero,8111a014 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111a010:	111da600 	call	8111da60 <vCouldNotSendTurnOff>
	}
}
8111a014:	0001883a 	nop
8111a018:	e037883a 	mov	sp,fp
8111a01c:	dfc00117 	ldw	ra,4(sp)
8111a020:	df000017 	ldw	fp,0(sp)
8111a024:	dec00204 	addi	sp,sp,8
8111a028:	f800283a 	ret

8111a02c <vSendReset>:

void vSendReset ( void ) {
8111a02c:	defff304 	addi	sp,sp,-52
8111a030:	de00012e 	bgeu	sp,et,8111a038 <vSendReset+0xc>
8111a034:	003b68fa 	trap	3
8111a038:	dfc00c15 	stw	ra,48(sp)
8111a03c:	df000b15 	stw	fp,44(sp)
8111a040:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8111a044:	e03ff78d 	sth	zero,-34(fp)
8111a048:	e03ff80d 	sth	zero,-32(fp)
8111a04c:	e03ff88d 	sth	zero,-30(fp)
8111a050:	e03ff90d 	sth	zero,-28(fp)
8111a054:	e03ff98d 	sth	zero,-26(fp)
8111a058:	e03ffa0d 	sth	zero,-24(fp)
8111a05c:	e03ffa8d 	sth	zero,-22(fp)
8111a060:	e03ffb0d 	sth	zero,-20(fp)
8111a064:	e03ffb8d 	sth	zero,-18(fp)
8111a068:	e03ffc0d 	sth	zero,-16(fp)
8111a06c:	e03ffc8d 	sth	zero,-14(fp)
8111a070:	e03ffd0d 	sth	zero,-12(fp)
8111a074:	e03ffd8d 	sth	zero,-10(fp)
8111a078:	e03ffe0d 	sth	zero,-8(fp)
8111a07c:	e03ffe8d 	sth	zero,-6(fp)
8111a080:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111a084:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a088:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a08c:	111a2440 	call	8111a244 <usiGetIdCMD>
8111a090:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8111a094:	e0fff70b 	ldhu	r3,-36(fp)
8111a098:	e0bff784 	addi	r2,fp,-34
8111a09c:	180d883a 	mov	r6,r3
8111a0a0:	01604574 	movhi	r5,33045
8111a0a4:	297fa604 	addi	r5,r5,-360
8111a0a8:	1009883a 	mov	r4,r2
8111a0ac:	11242a80 	call	811242a8 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111a0b0:	e0bff784 	addi	r2,fp,-34
8111a0b4:	1009883a 	mov	r4,r2
8111a0b8:	11244bc0 	call	811244bc <strlen>
8111a0bc:	1007883a 	mov	r3,r2
8111a0c0:	e0bff784 	addi	r2,fp,-34
8111a0c4:	180b883a 	mov	r5,r3
8111a0c8:	1009883a 	mov	r4,r2
8111a0cc:	111c3980 	call	8111c398 <ucCrc8wInit>
8111a0d0:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111a0d4:	e13ff503 	ldbu	r4,-44(fp)
8111a0d8:	e0fff784 	addi	r3,fp,-34
8111a0dc:	e0bff784 	addi	r2,fp,-34
8111a0e0:	200f883a 	mov	r7,r4
8111a0e4:	180d883a 	mov	r6,r3
8111a0e8:	01604574 	movhi	r5,33045
8111a0ec:	297fa104 	addi	r5,r5,-380
8111a0f0:	1009883a 	mov	r4,r2
8111a0f4:	11242a80 	call	811242a8 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111a0f8:	e0bff70b 	ldhu	r2,-36(fp)
8111a0fc:	10ffffcc 	andi	r3,r2,65535
8111a100:	18e0001c 	xori	r3,r3,32768
8111a104:	18e00004 	addi	r3,r3,-32768
8111a108:	e0bff784 	addi	r2,fp,-34
8111a10c:	180b883a 	mov	r5,r3
8111a110:	1009883a 	mov	r4,r2
8111a114:	111995c0 	call	8111995c <bSendUART32v2>
8111a118:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111a11c:	e0bff617 	ldw	r2,-40(fp)
8111a120:	10800060 	cmpeqi	r2,r2,1
8111a124:	1000011e 	bne	r2,zero,8111a12c <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111a128:	111da600 	call	8111da60 <vCouldNotSendTurnOff>
	}
}
8111a12c:	0001883a 	nop
8111a130:	e037883a 	mov	sp,fp
8111a134:	dfc00117 	ldw	ra,4(sp)
8111a138:	df000017 	ldw	fp,0(sp)
8111a13c:	dec00204 	addi	sp,sp,8
8111a140:	f800283a 	ret

8111a144 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8111a144:	deffda04 	addi	sp,sp,-152
8111a148:	de00012e 	bgeu	sp,et,8111a150 <vSendLog+0xc>
8111a14c:	003b68fa 	trap	3
8111a150:	dfc02515 	stw	ra,148(sp)
8111a154:	df002415 	stw	fp,144(sp)
8111a158:	df002404 	addi	fp,sp,144
8111a15c:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8111a160:	e03fde8d 	sth	zero,-134(fp)
8111a164:	e03fdf0d 	sth	zero,-132(fp)
8111a168:	e0bfdf84 	addi	r2,fp,-130
8111a16c:	00c01f04 	movi	r3,124
8111a170:	180d883a 	mov	r6,r3
8111a174:	000b883a 	mov	r5,zero
8111a178:	1009883a 	mov	r4,r2
8111a17c:	1123b940 	call	81123b94 <memset>
    unsigned char crc = 0;
8111a180:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a184:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a188:	111a2440 	call	8111a244 <usiGetIdCMD>
8111a18c:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8111a190:	e0ffde0b 	ldhu	r3,-136(fp)
8111a194:	e0bfde84 	addi	r2,fp,-134
8111a198:	e1ffff17 	ldw	r7,-4(fp)
8111a19c:	180d883a 	mov	r6,r3
8111a1a0:	01604574 	movhi	r5,33045
8111a1a4:	297fa804 	addi	r5,r5,-352
8111a1a8:	1009883a 	mov	r4,r2
8111a1ac:	11242a80 	call	811242a8 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8111a1b0:	e0bfde84 	addi	r2,fp,-134
8111a1b4:	1009883a 	mov	r4,r2
8111a1b8:	11244bc0 	call	811244bc <strlen>
8111a1bc:	1007883a 	mov	r3,r2
8111a1c0:	e0bfde84 	addi	r2,fp,-134
8111a1c4:	180b883a 	mov	r5,r3
8111a1c8:	1009883a 	mov	r4,r2
8111a1cc:	111c3980 	call	8111c398 <ucCrc8wInit>
8111a1d0:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8111a1d4:	e13fdc03 	ldbu	r4,-144(fp)
8111a1d8:	e0ffde84 	addi	r3,fp,-134
8111a1dc:	e0bfde84 	addi	r2,fp,-134
8111a1e0:	200f883a 	mov	r7,r4
8111a1e4:	180d883a 	mov	r6,r3
8111a1e8:	01604574 	movhi	r5,33045
8111a1ec:	297fa104 	addi	r5,r5,-380
8111a1f0:	1009883a 	mov	r4,r2
8111a1f4:	11242a80 	call	811242a8 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111a1f8:	e0bfde0b 	ldhu	r2,-136(fp)
8111a1fc:	10ffffcc 	andi	r3,r2,65535
8111a200:	18e0001c 	xori	r3,r3,32768
8111a204:	18e00004 	addi	r3,r3,-32768
8111a208:	e0bfde84 	addi	r2,fp,-134
8111a20c:	180b883a 	mov	r5,r3
8111a210:	1009883a 	mov	r4,r2
8111a214:	11193140 	call	81119314 <bSendUART128v2>
8111a218:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8111a21c:	e0bfdd17 	ldw	r2,-140(fp)
8111a220:	10800060 	cmpeqi	r2,r2,1
8111a224:	1000011e 	bne	r2,zero,8111a22c <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111a228:	111db600 	call	8111db60 <vCouldNotSendLog>
	}
}
8111a22c:	0001883a 	nop
8111a230:	e037883a 	mov	sp,fp
8111a234:	dfc00117 	ldw	ra,4(sp)
8111a238:	df000017 	ldw	fp,0(sp)
8111a23c:	dec00204 	addi	sp,sp,8
8111a240:	f800283a 	ret

8111a244 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8111a244:	deffff04 	addi	sp,sp,-4
8111a248:	de00012e 	bgeu	sp,et,8111a250 <usiGetIdCMD+0xc>
8111a24c:	003b68fa 	trap	3
8111a250:	df000015 	stw	fp,0(sp)
8111a254:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8111a258:	d0a0680b 	ldhu	r2,-32352(gp)
8111a25c:	10ffffcc 	andi	r3,r2,65535
8111a260:	00bfffd4 	movui	r2,65535
8111a264:	1880031e 	bne	r3,r2,8111a274 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111a268:	00800084 	movi	r2,2
8111a26c:	d0a0680d 	sth	r2,-32352(gp)
8111a270:	00000306 	br	8111a280 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8111a274:	d0a0680b 	ldhu	r2,-32352(gp)
8111a278:	10800044 	addi	r2,r2,1
8111a27c:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
8111a280:	d0a0680b 	ldhu	r2,-32352(gp)
}
8111a284:	e037883a 	mov	sp,fp
8111a288:	df000017 	ldw	fp,0(sp)
8111a28c:	dec00104 	addi	sp,sp,4
8111a290:	f800283a 	ret

8111a294 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8111a294:	defffb04 	addi	sp,sp,-20
8111a298:	de00012e 	bgeu	sp,et,8111a2a0 <siPosStr+0xc>
8111a29c:	003b68fa 	trap	3
8111a2a0:	dfc00415 	stw	ra,16(sp)
8111a2a4:	df000315 	stw	fp,12(sp)
8111a2a8:	df000304 	addi	fp,sp,12
8111a2ac:	e13ffe15 	stw	r4,-8(fp)
8111a2b0:	2805883a 	mov	r2,r5
8111a2b4:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8111a2b8:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8111a2bc:	e0bfff03 	ldbu	r2,-4(fp)
8111a2c0:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8111a2c4:	e17ffd04 	addi	r5,fp,-12
8111a2c8:	e13ffe17 	ldw	r4,-8(fp)
8111a2cc:	11244700 	call	81124470 <strcspn>
}
8111a2d0:	e037883a 	mov	sp,fp
8111a2d4:	dfc00117 	ldw	ra,4(sp)
8111a2d8:	df000017 	ldw	fp,0(sp)
8111a2dc:	dec00204 	addi	sp,sp,8
8111a2e0:	f800283a 	ret

8111a2e4 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8111a2e4:	defffc04 	addi	sp,sp,-16
8111a2e8:	de00012e 	bgeu	sp,et,8111a2f0 <vTimeoutCheck+0xc>
8111a2ec:	003b68fa 	trap	3
8111a2f0:	dfc00315 	stw	ra,12(sp)
8111a2f4:	df000215 	stw	fp,8(sp)
8111a2f8:	df000204 	addi	fp,sp,8
8111a2fc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8111a300:	d0a06717 	ldw	r2,-32356(gp)
8111a304:	1009883a 	mov	r4,r2
8111a308:	11401bc0 	call	811401bc <OSSemPost>
8111a30c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111a310:	e0bffe03 	ldbu	r2,-8(fp)
8111a314:	10000126 	beq	r2,zero,8111a31c <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8111a318:	111d7600 	call	8111d760 <vFailPostBlockingSemTimeoutTask>
	}
}
8111a31c:	0001883a 	nop
8111a320:	e037883a 	mov	sp,fp
8111a324:	dfc00117 	ldw	ra,4(sp)
8111a328:	df000017 	ldw	fp,0(sp)
8111a32c:	dec00204 	addi	sp,sp,8
8111a330:	f800283a 	ret

8111a334 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8111a334:	deffe304 	addi	sp,sp,-116
8111a338:	de00012e 	bgeu	sp,et,8111a340 <vSendPusTM64+0xc>
8111a33c:	003b68fa 	trap	3
8111a340:	dfc01815 	stw	ra,96(sp)
8111a344:	df001715 	stw	fp,92(sp)
8111a348:	df001704 	addi	fp,sp,92
8111a34c:	e1000215 	stw	r4,8(fp)
8111a350:	e1400315 	stw	r5,12(fp)
8111a354:	e1800415 	stw	r6,16(fp)
8111a358:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8111a35c:	e03fef8d 	sth	zero,-66(fp)
8111a360:	e03ff00d 	sth	zero,-64(fp)
8111a364:	e0bff084 	addi	r2,fp,-62
8111a368:	00c00f04 	movi	r3,60
8111a36c:	180d883a 	mov	r6,r3
8111a370:	000b883a 	mov	r5,zero
8111a374:	1009883a 	mov	r4,r2
8111a378:	1123b940 	call	81123b94 <memset>
    unsigned char crc = 0;
8111a37c:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111a380:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a384:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a388:	111a2440 	call	8111a244 <usiGetIdCMD>
8111a38c:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111a390:	e1bfef0b 	ldhu	r6,-68(fp)
8111a394:	e080040b 	ldhu	r2,16(fp)
8111a398:	11ffffcc 	andi	r7,r2,65535
8111a39c:	e080048b 	ldhu	r2,18(fp)
8111a3a0:	10bfffcc 	andi	r2,r2,65535
8111a3a4:	e0c0050b 	ldhu	r3,20(fp)
8111a3a8:	18ffffcc 	andi	r3,r3,65535
8111a3ac:	e100058b 	ldhu	r4,22(fp)
8111a3b0:	213fffcc 	andi	r4,r4,65535
8111a3b4:	e140060b 	ldhu	r5,24(fp)
8111a3b8:	297fffcc 	andi	r5,r5,65535
8111a3bc:	e23fef84 	addi	r8,fp,-66
8111a3c0:	d9400315 	stw	r5,12(sp)
8111a3c4:	d9000215 	stw	r4,8(sp)
8111a3c8:	d8c00115 	stw	r3,4(sp)
8111a3cc:	d8800015 	stw	r2,0(sp)
8111a3d0:	01604574 	movhi	r5,33045
8111a3d4:	297fab04 	addi	r5,r5,-340
8111a3d8:	4009883a 	mov	r4,r8
8111a3dc:	11242a80 	call	811242a8 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a3e0:	e03fed05 	stb	zero,-76(fp)
8111a3e4:	00001206 	br	8111a430 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111a3e8:	e0bfed03 	ldbu	r2,-76(fp)
8111a3ec:	10800284 	addi	r2,r2,10
8111a3f0:	1085883a 	add	r2,r2,r2
8111a3f4:	e0c00204 	addi	r3,fp,8
8111a3f8:	1885883a 	add	r2,r3,r2
8111a3fc:	1080000b 	ldhu	r2,0(r2)
8111a400:	113fffcc 	andi	r4,r2,65535
8111a404:	e0ffef84 	addi	r3,fp,-66
8111a408:	e0bfef84 	addi	r2,fp,-66
8111a40c:	200f883a 	mov	r7,r4
8111a410:	180d883a 	mov	r6,r3
8111a414:	01604574 	movhi	r5,33045
8111a418:	297fb204 	addi	r5,r5,-312
8111a41c:	1009883a 	mov	r4,r2
8111a420:	11242a80 	call	811242a8 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a424:	e0bfed03 	ldbu	r2,-76(fp)
8111a428:	10800044 	addi	r2,r2,1
8111a42c:	e0bfed05 	stb	r2,-76(fp)
8111a430:	e0800683 	ldbu	r2,26(fp)
8111a434:	10803fcc 	andi	r2,r2,255
8111a438:	e0ffed03 	ldbu	r3,-76(fp)
8111a43c:	18bfea36 	bltu	r3,r2,8111a3e8 <__reset+0xfb0fa3e8>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111a440:	e0bfef84 	addi	r2,fp,-66
8111a444:	1009883a 	mov	r4,r2
8111a448:	11244bc0 	call	811244bc <strlen>
8111a44c:	1007883a 	mov	r3,r2
8111a450:	e0bfef84 	addi	r2,fp,-66
8111a454:	180b883a 	mov	r5,r3
8111a458:	1009883a 	mov	r4,r2
8111a45c:	111c3980 	call	8111c398 <ucCrc8wInit>
8111a460:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111a464:	e13fed43 	ldbu	r4,-75(fp)
8111a468:	e0ffef84 	addi	r3,fp,-66
8111a46c:	e0bfef84 	addi	r2,fp,-66
8111a470:	200f883a 	mov	r7,r4
8111a474:	180d883a 	mov	r6,r3
8111a478:	01604574 	movhi	r5,33045
8111a47c:	297fa104 	addi	r5,r5,-380
8111a480:	1009883a 	mov	r4,r2
8111a484:	11242a80 	call	811242a8 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8111a488:	e0bfef0b 	ldhu	r2,-68(fp)
8111a48c:	10ffffcc 	andi	r3,r2,65535
8111a490:	18e0001c 	xori	r3,r3,32768
8111a494:	18e00004 	addi	r3,r3,-32768
8111a498:	e0bfef84 	addi	r2,fp,-66
8111a49c:	180b883a 	mov	r5,r3
8111a4a0:	1009883a 	mov	r4,r2
8111a4a4:	11196340 	call	81119634 <bSendUART64v2>
8111a4a8:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8111a4ac:	e0bfee17 	ldw	r2,-72(fp)
8111a4b0:	10800060 	cmpeqi	r2,r2,1
8111a4b4:	1000031e 	bne	r2,zero,8111a4c4 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111a4b8:	e0bfef84 	addi	r2,fp,-66
8111a4bc:	1009883a 	mov	r4,r2
8111a4c0:	111dbe00 	call	8111dbe0 <vCouldNotSendTMPusCommand>
	}
}
8111a4c4:	0001883a 	nop
8111a4c8:	e037883a 	mov	sp,fp
8111a4cc:	dfc00117 	ldw	ra,4(sp)
8111a4d0:	df000017 	ldw	fp,0(sp)
8111a4d4:	dec00604 	addi	sp,sp,24
8111a4d8:	f800283a 	ret

8111a4dc <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8111a4dc:	deffd304 	addi	sp,sp,-180
8111a4e0:	de00012e 	bgeu	sp,et,8111a4e8 <vSendPusTM128+0xc>
8111a4e4:	003b68fa 	trap	3
8111a4e8:	dfc02815 	stw	ra,160(sp)
8111a4ec:	df002715 	stw	fp,156(sp)
8111a4f0:	df002704 	addi	fp,sp,156
8111a4f4:	e1000215 	stw	r4,8(fp)
8111a4f8:	e1400315 	stw	r5,12(fp)
8111a4fc:	e1800415 	stw	r6,16(fp)
8111a500:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8111a504:	e03fdf8d 	sth	zero,-130(fp)
8111a508:	e03fe00d 	sth	zero,-128(fp)
8111a50c:	e0bfe084 	addi	r2,fp,-126
8111a510:	00c01f04 	movi	r3,124
8111a514:	180d883a 	mov	r6,r3
8111a518:	000b883a 	mov	r5,zero
8111a51c:	1009883a 	mov	r4,r2
8111a520:	1123b940 	call	81123b94 <memset>
    unsigned char crc = 0;
8111a524:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8111a528:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a52c:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a530:	111a2440 	call	8111a244 <usiGetIdCMD>
8111a534:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111a538:	e1bfdf0b 	ldhu	r6,-132(fp)
8111a53c:	e080040b 	ldhu	r2,16(fp)
8111a540:	11ffffcc 	andi	r7,r2,65535
8111a544:	e080048b 	ldhu	r2,18(fp)
8111a548:	10bfffcc 	andi	r2,r2,65535
8111a54c:	e0c0050b 	ldhu	r3,20(fp)
8111a550:	18ffffcc 	andi	r3,r3,65535
8111a554:	e100058b 	ldhu	r4,22(fp)
8111a558:	213fffcc 	andi	r4,r4,65535
8111a55c:	e140060b 	ldhu	r5,24(fp)
8111a560:	297fffcc 	andi	r5,r5,65535
8111a564:	e23fdf84 	addi	r8,fp,-130
8111a568:	d9400315 	stw	r5,12(sp)
8111a56c:	d9000215 	stw	r4,8(sp)
8111a570:	d8c00115 	stw	r3,4(sp)
8111a574:	d8800015 	stw	r2,0(sp)
8111a578:	01604574 	movhi	r5,33045
8111a57c:	297fab04 	addi	r5,r5,-340
8111a580:	4009883a 	mov	r4,r8
8111a584:	11242a80 	call	811242a8 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a588:	e03fdd05 	stb	zero,-140(fp)
8111a58c:	00001206 	br	8111a5d8 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111a590:	e0bfdd03 	ldbu	r2,-140(fp)
8111a594:	10800284 	addi	r2,r2,10
8111a598:	1085883a 	add	r2,r2,r2
8111a59c:	e0c00204 	addi	r3,fp,8
8111a5a0:	1885883a 	add	r2,r3,r2
8111a5a4:	1080000b 	ldhu	r2,0(r2)
8111a5a8:	113fffcc 	andi	r4,r2,65535
8111a5ac:	e0ffdf84 	addi	r3,fp,-130
8111a5b0:	e0bfdf84 	addi	r2,fp,-130
8111a5b4:	200f883a 	mov	r7,r4
8111a5b8:	180d883a 	mov	r6,r3
8111a5bc:	01604574 	movhi	r5,33045
8111a5c0:	297fb204 	addi	r5,r5,-312
8111a5c4:	1009883a 	mov	r4,r2
8111a5c8:	11242a80 	call	811242a8 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a5cc:	e0bfdd03 	ldbu	r2,-140(fp)
8111a5d0:	10800044 	addi	r2,r2,1
8111a5d4:	e0bfdd05 	stb	r2,-140(fp)
8111a5d8:	e0800683 	ldbu	r2,26(fp)
8111a5dc:	10803fcc 	andi	r2,r2,255
8111a5e0:	e0ffdd03 	ldbu	r3,-140(fp)
8111a5e4:	18bfea36 	bltu	r3,r2,8111a590 <__reset+0xfb0fa590>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111a5e8:	e0bfdf84 	addi	r2,fp,-130
8111a5ec:	1009883a 	mov	r4,r2
8111a5f0:	11244bc0 	call	811244bc <strlen>
8111a5f4:	1007883a 	mov	r3,r2
8111a5f8:	e0bfdf84 	addi	r2,fp,-130
8111a5fc:	180b883a 	mov	r5,r3
8111a600:	1009883a 	mov	r4,r2
8111a604:	111c3980 	call	8111c398 <ucCrc8wInit>
8111a608:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111a60c:	e13fdd43 	ldbu	r4,-139(fp)
8111a610:	e0ffdf84 	addi	r3,fp,-130
8111a614:	e0bfdf84 	addi	r2,fp,-130
8111a618:	200f883a 	mov	r7,r4
8111a61c:	180d883a 	mov	r6,r3
8111a620:	01604574 	movhi	r5,33045
8111a624:	297fa104 	addi	r5,r5,-380
8111a628:	1009883a 	mov	r4,r2
8111a62c:	11242a80 	call	811242a8 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111a630:	e0bfdf0b 	ldhu	r2,-132(fp)
8111a634:	10ffffcc 	andi	r3,r2,65535
8111a638:	18e0001c 	xori	r3,r3,32768
8111a63c:	18e00004 	addi	r3,r3,-32768
8111a640:	e0bfdf84 	addi	r2,fp,-130
8111a644:	180b883a 	mov	r5,r3
8111a648:	1009883a 	mov	r4,r2
8111a64c:	11193140 	call	81119314 <bSendUART128v2>
8111a650:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8111a654:	e0bfde17 	ldw	r2,-136(fp)
8111a658:	10800060 	cmpeqi	r2,r2,1
8111a65c:	1000031e 	bne	r2,zero,8111a66c <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111a660:	e0bfdf84 	addi	r2,fp,-130
8111a664:	1009883a 	mov	r4,r2
8111a668:	111dbe00 	call	8111dbe0 <vCouldNotSendTMPusCommand>
	}
}
8111a66c:	0001883a 	nop
8111a670:	e037883a 	mov	sp,fp
8111a674:	dfc00117 	ldw	ra,4(sp)
8111a678:	df000017 	ldw	fp,0(sp)
8111a67c:	dec00604 	addi	sp,sp,24
8111a680:	f800283a 	ret

8111a684 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8111a684:	deffd704 	addi	sp,sp,-164
8111a688:	de00012e 	bgeu	sp,et,8111a690 <vTMPusTestConnection+0xc>
8111a68c:	003b68fa 	trap	3
8111a690:	dfc02815 	stw	ra,160(sp)
8111a694:	df002715 	stw	fp,156(sp)
8111a698:	df002704 	addi	fp,sp,156
8111a69c:	2005883a 	mov	r2,r4
8111a6a0:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8111a6a4:	e0bfff0b 	ldhu	r2,-4(fp)
8111a6a8:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
8111a6ac:	00801c04 	movi	r2,112
8111a6b0:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8111a6b4:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8111a6b8:	00800444 	movi	r2,17
8111a6bc:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
8111a6c0:	00800084 	movi	r2,2
8111a6c4:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8111a6c8:	d809883a 	mov	r4,sp
8111a6cc:	e0bfee04 	addi	r2,fp,-72
8111a6d0:	00c01104 	movi	r3,68
8111a6d4:	180d883a 	mov	r6,r3
8111a6d8:	100b883a 	mov	r5,r2
8111a6dc:	1123a440 	call	81123a44 <memcpy>
8111a6e0:	e13fea17 	ldw	r4,-88(fp)
8111a6e4:	e17feb17 	ldw	r5,-84(fp)
8111a6e8:	e1bfec17 	ldw	r6,-80(fp)
8111a6ec:	e1ffed17 	ldw	r7,-76(fp)
8111a6f0:	111a3340 	call	8111a334 <vSendPusTM64>
}
8111a6f4:	0001883a 	nop
8111a6f8:	e037883a 	mov	sp,fp
8111a6fc:	dfc00117 	ldw	ra,4(sp)
8111a700:	df000017 	ldw	fp,0(sp)
8111a704:	dec00204 	addi	sp,sp,8
8111a708:	f800283a 	ret

8111a70c <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
8111a70c:	defff504 	addi	sp,sp,-44
8111a710:	de00012e 	bgeu	sp,et,8111a718 <vLoadDefaultETHConf+0xc>
8111a714:	003b68fa 	trap	3
8111a718:	dfc00a15 	stw	ra,40(sp)
8111a71c:	df000915 	stw	fp,36(sp)
8111a720:	dc000815 	stw	r16,32(sp)
8111a724:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111a728:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8111a72c:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111a730:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111a734:	d0a07617 	ldw	r2,-32296(gp)
8111a738:	10800058 	cmpnei	r2,r2,1
8111a73c:	10021f1e 	bne	r2,zero,8111afbc <vLoadDefaultETHConf+0x8b0>
8111a740:	111fe6c0 	call	8111fe6c <bSDcardIsPresent>
8111a744:	10021d26 	beq	r2,zero,8111afbc <vLoadDefaultETHConf+0x8b0>
8111a748:	111fe9c0 	call	8111fe9c <bSDcardFAT16Check>
8111a74c:	10021b26 	beq	r2,zero,8111afbc <vLoadDefaultETHConf+0x8b0>

		siFile = siOpenFile( ETH_FILE_NAME );
8111a750:	01204574 	movhi	r4,33045
8111a754:	213fb404 	addi	r4,r4,-304
8111a758:	111ffc40 	call	8111ffc4 <siOpenFile>
8111a75c:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111a760:	e0bffc0f 	ldh	r2,-16(fp)
8111a764:	10020716 	blt	r2,zero,8111af84 <vLoadDefaultETHConf+0x878>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111a768:	e0bffd04 	addi	r2,fp,-12
8111a76c:	01800204 	movi	r6,8
8111a770:	01400284 	movi	r5,10
8111a774:	1009883a 	mov	r4,r2
8111a778:	1123b940 	call	81123b94 <memset>
			p_inteiro = inteiro;
8111a77c:	e0bffd04 	addi	r2,fp,-12
8111a780:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8111a784:	e0bffc0f 	ldh	r2,-16(fp)
8111a788:	1009883a 	mov	r4,r2
8111a78c:	11200400 	call	81120040 <cGetNextChar>
8111a790:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8111a794:	e0bff947 	ldb	r2,-27(fp)
8111a798:	10800084 	addi	r2,r2,2
8111a79c:	10c015a8 	cmpgeui	r3,r2,86
8111a7a0:	1801e41e 	bne	r3,zero,8111af34 <vLoadDefaultETHConf+0x828>
8111a7a4:	100690ba 	slli	r3,r2,2
8111a7a8:	00a044b4 	movhi	r2,33042
8111a7ac:	10a9ef04 	addi	r2,r2,-22596
8111a7b0:	1885883a 	add	r2,r3,r2
8111a7b4:	10800017 	ldw	r2,0(r2)
8111a7b8:	1000683a 	jmp	r2
8111a7bc:	8111a954 	ori	r4,r16,18085
8111a7c0:	8111a948 	cmpgei	r4,r16,18085
8111a7c4:	8111af34 	orhi	r4,r16,18108
8111a7c8:	8111af34 	orhi	r4,r16,18108
8111a7cc:	8111af34 	orhi	r4,r16,18108
8111a7d0:	8111af34 	orhi	r4,r16,18108
8111a7d4:	8111af34 	orhi	r4,r16,18108
8111a7d8:	8111af34 	orhi	r4,r16,18108
8111a7dc:	8111af34 	orhi	r4,r16,18108
8111a7e0:	8111af34 	orhi	r4,r16,18108
8111a7e4:	8111af34 	orhi	r4,r16,18108
8111a7e8:	8111af34 	orhi	r4,r16,18108
8111a7ec:	8111af6c 	andhi	r4,r16,18109
8111a7f0:	8111af34 	orhi	r4,r16,18108
8111a7f4:	8111af34 	orhi	r4,r16,18108
8111a7f8:	8111af6c 	andhi	r4,r16,18109
8111a7fc:	8111af34 	orhi	r4,r16,18108
8111a800:	8111af34 	orhi	r4,r16,18108
8111a804:	8111af34 	orhi	r4,r16,18108
8111a808:	8111af34 	orhi	r4,r16,18108
8111a80c:	8111af34 	orhi	r4,r16,18108
8111a810:	8111af34 	orhi	r4,r16,18108
8111a814:	8111af34 	orhi	r4,r16,18108
8111a818:	8111af34 	orhi	r4,r16,18108
8111a81c:	8111af34 	orhi	r4,r16,18108
8111a820:	8111af34 	orhi	r4,r16,18108
8111a824:	8111af34 	orhi	r4,r16,18108
8111a828:	8111af34 	orhi	r4,r16,18108
8111a82c:	8111af34 	orhi	r4,r16,18108
8111a830:	8111af34 	orhi	r4,r16,18108
8111a834:	8111af34 	orhi	r4,r16,18108
8111a838:	8111af34 	orhi	r4,r16,18108
8111a83c:	8111af34 	orhi	r4,r16,18108
8111a840:	8111af34 	orhi	r4,r16,18108
8111a844:	8111af6c 	andhi	r4,r16,18109
8111a848:	8111af34 	orhi	r4,r16,18108
8111a84c:	8111af34 	orhi	r4,r16,18108
8111a850:	8111af34 	orhi	r4,r16,18108
8111a854:	8111af34 	orhi	r4,r16,18108
8111a858:	8111af34 	orhi	r4,r16,18108
8111a85c:	8111af34 	orhi	r4,r16,18108
8111a860:	8111a914 	ori	r4,r16,18084
8111a864:	8111af34 	orhi	r4,r16,18108
8111a868:	8111af34 	orhi	r4,r16,18108
8111a86c:	8111af34 	orhi	r4,r16,18108
8111a870:	8111af34 	orhi	r4,r16,18108
8111a874:	8111af34 	orhi	r4,r16,18108
8111a878:	8111af34 	orhi	r4,r16,18108
8111a87c:	8111af34 	orhi	r4,r16,18108
8111a880:	8111af34 	orhi	r4,r16,18108
8111a884:	8111af34 	orhi	r4,r16,18108
8111a888:	8111af34 	orhi	r4,r16,18108
8111a88c:	8111af34 	orhi	r4,r16,18108
8111a890:	8111af34 	orhi	r4,r16,18108
8111a894:	8111af34 	orhi	r4,r16,18108
8111a898:	8111af34 	orhi	r4,r16,18108
8111a89c:	8111af34 	orhi	r4,r16,18108
8111a8a0:	8111af34 	orhi	r4,r16,18108
8111a8a4:	8111af34 	orhi	r4,r16,18108
8111a8a8:	8111af34 	orhi	r4,r16,18108
8111a8ac:	8111af34 	orhi	r4,r16,18108
8111a8b0:	8111af34 	orhi	r4,r16,18108
8111a8b4:	8111aed4 	ori	r4,r16,18107
8111a8b8:	8111af34 	orhi	r4,r16,18108
8111a8bc:	8111af34 	orhi	r4,r16,18108
8111a8c0:	8111af34 	orhi	r4,r16,18108
8111a8c4:	8111af34 	orhi	r4,r16,18108
8111a8c8:	8111af34 	orhi	r4,r16,18108
8111a8cc:	8111af34 	orhi	r4,r16,18108
8111a8d0:	8111af34 	orhi	r4,r16,18108
8111a8d4:	8111ae04 	addi	r4,r16,18104
8111a8d8:	8111af34 	orhi	r4,r16,18108
8111a8dc:	8111af34 	orhi	r4,r16,18108
8111a8e0:	8111ab30 	cmpltui	r4,r16,18092
8111a8e4:	8111ac8c 	andi	r4,r16,18098
8111a8e8:	8111aa64 	muli	r4,r16,18089
8111a8ec:	8111af34 	orhi	r4,r16,18108
8111a8f0:	8111af34 	orhi	r4,r16,18108
8111a8f4:	8111af34 	orhi	r4,r16,18108
8111a8f8:	8111a994 	ori	r4,r16,18086
8111a8fc:	8111af34 	orhi	r4,r16,18108
8111a900:	8111af34 	orhi	r4,r16,18108
8111a904:	8111ac00 	call	88111ac0 <__reset+0x20f1ac0>
8111a908:	8111af34 	orhi	r4,r16,18108
8111a90c:	8111af34 	orhi	r4,r16,18108
8111a910:	8111ad34 	orhi	r4,r16,18100
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111a914:	e0bffc0f 	ldh	r2,-16(fp)
8111a918:	1009883a 	mov	r4,r2
8111a91c:	11200400 	call	81120040 <cGetNextChar>
8111a920:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8111a924:	00000406 	br	8111a938 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111a928:	e0bffc0f 	ldh	r2,-16(fp)
8111a92c:	1009883a 	mov	r4,r2
8111a930:	11200400 	call	81120040 <cGetNextChar>
8111a934:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111a938:	e0bff947 	ldb	r2,-27(fp)
8111a93c:	108009d8 	cmpnei	r2,r2,39
8111a940:	103ff91e 	bne	r2,zero,8111a928 <__reset+0xfb0fa928>
							c = cGetNextChar(siFile);
						}
						break;
8111a944:	00018c06 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case -1: 	//EOF
						bEOF = TRUE;
8111a948:	00800044 	movi	r2,1
8111a94c:	e0bff815 	stw	r2,-32(fp)
						break;
8111a950:	00018906 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case -2: 	//EOF
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a954:	00a045f4 	movhi	r2,33047
8111a958:	10a00404 	addi	r2,r2,-32752
8111a95c:	10800e8b 	ldhu	r2,58(r2)
8111a960:	10bfffcc 	andi	r2,r2,65535
8111a964:	108001e8 	cmpgeui	r2,r2,7
8111a968:	1000071e 	bne	r2,zero,8111a988 <vLoadDefaultETHConf+0x27c>
							debug(fp,"SDCard: Problem with SDCard");
8111a96c:	d0a06217 	ldw	r2,-32376(gp)
8111a970:	100f883a 	mov	r7,r2
8111a974:	018006c4 	movi	r6,27
8111a978:	01400044 	movi	r5,1
8111a97c:	01204574 	movhi	r4,33045
8111a980:	213fb604 	addi	r4,r4,-296
8111a984:	11230300 	call	81123030 <fwrite>
						}
						#endif
						bEOF = TRUE;
8111a988:	00800044 	movi	r2,1
8111a98c:	e0bff815 	stw	r2,-32(fp)
						break;
8111a990:	00017906 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8111a994:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a998:	e0bffc0f 	ldh	r2,-16(fp)
8111a99c:	1009883a 	mov	r4,r2
8111a9a0:	11200400 	call	81120040 <cGetNextChar>
8111a9a4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a9a8:	d0e00317 	ldw	r3,-32756(gp)
8111a9ac:	e0bff947 	ldb	r2,-27(fp)
8111a9b0:	10800044 	addi	r2,r2,1
8111a9b4:	1885883a 	add	r2,r3,r2
8111a9b8:	10800003 	ldbu	r2,0(r2)
8111a9bc:	10803fcc 	andi	r2,r2,255
8111a9c0:	1080010c 	andi	r2,r2,4
8111a9c4:	10000626 	beq	r2,zero,8111a9e0 <vLoadDefaultETHConf+0x2d4>
									(*p_inteiro) = c;
8111a9c8:	e0bffa17 	ldw	r2,-24(fp)
8111a9cc:	e0fff943 	ldbu	r3,-27(fp)
8111a9d0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a9d4:	e0bffa17 	ldw	r2,-24(fp)
8111a9d8:	10800044 	addi	r2,r2,1
8111a9dc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111a9e0:	e0bff947 	ldb	r2,-27(fp)
8111a9e4:	10800ea0 	cmpeqi	r2,r2,58
8111a9e8:	1000031e 	bne	r2,zero,8111a9f8 <vLoadDefaultETHConf+0x2ec>
8111a9ec:	e0bff947 	ldb	r2,-27(fp)
8111a9f0:	10800ed8 	cmpnei	r2,r2,59
8111a9f4:	103fe81e 	bne	r2,zero,8111a998 <__reset+0xfb0fa998>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a9f8:	e0bffa17 	ldw	r2,-24(fp)
8111a9fc:	00c00284 	movi	r3,10
8111aa00:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
8111aa04:	e0bff903 	ldbu	r2,-28(fp)
8111aa08:	10800168 	cmpgeui	r2,r2,5
8111aa0c:	1000021e 	bne	r2,zero,8111aa18 <vLoadDefaultETHConf+0x30c>
8111aa10:	e43ff903 	ldbu	r16,-28(fp)
8111aa14:	00000106 	br	8111aa1c <vLoadDefaultETHConf+0x310>
8111aa18:	04000144 	movi	r16,5
8111aa1c:	e0bffd04 	addi	r2,fp,-12
8111aa20:	1009883a 	mov	r4,r2
8111aa24:	11228380 	call	81122838 <atoi>
8111aa28:	1007883a 	mov	r3,r2
8111aa2c:	00a045f4 	movhi	r2,33047
8111aa30:	10a01404 	addi	r2,r2,-32688
8111aa34:	1405883a 	add	r2,r2,r16
8111aa38:	10800404 	addi	r2,r2,16
8111aa3c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aa40:	e0bffd04 	addi	r2,fp,-12
8111aa44:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111aa48:	e0bff903 	ldbu	r2,-28(fp)
8111aa4c:	10800044 	addi	r2,r2,1
8111aa50:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111aa54:	e0bff947 	ldb	r2,-27(fp)
8111aa58:	10800ed8 	cmpnei	r2,r2,59
8111aa5c:	103fce1e 	bne	r2,zero,8111a998 <__reset+0xfb0fa998>

						break;
8111aa60:	00014506 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 'I':

						ucParser = 0;
8111aa64:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aa68:	e0bffc0f 	ldh	r2,-16(fp)
8111aa6c:	1009883a 	mov	r4,r2
8111aa70:	11200400 	call	81120040 <cGetNextChar>
8111aa74:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111aa78:	d0e00317 	ldw	r3,-32756(gp)
8111aa7c:	e0bff947 	ldb	r2,-27(fp)
8111aa80:	10800044 	addi	r2,r2,1
8111aa84:	1885883a 	add	r2,r3,r2
8111aa88:	10800003 	ldbu	r2,0(r2)
8111aa8c:	10803fcc 	andi	r2,r2,255
8111aa90:	1080010c 	andi	r2,r2,4
8111aa94:	10000626 	beq	r2,zero,8111aab0 <vLoadDefaultETHConf+0x3a4>
									(*p_inteiro) = c;
8111aa98:	e0bffa17 	ldw	r2,-24(fp)
8111aa9c:	e0fff943 	ldbu	r3,-27(fp)
8111aaa0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aaa4:	e0bffa17 	ldw	r2,-24(fp)
8111aaa8:	10800044 	addi	r2,r2,1
8111aaac:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aab0:	e0bff947 	ldb	r2,-27(fp)
8111aab4:	10800ba0 	cmpeqi	r2,r2,46
8111aab8:	1000031e 	bne	r2,zero,8111aac8 <vLoadDefaultETHConf+0x3bc>
8111aabc:	e0bff947 	ldb	r2,-27(fp)
8111aac0:	10800ed8 	cmpnei	r2,r2,59
8111aac4:	103fe81e 	bne	r2,zero,8111aa68 <__reset+0xfb0faa68>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aac8:	e0bffa17 	ldw	r2,-24(fp)
8111aacc:	00c00284 	movi	r3,10
8111aad0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
8111aad4:	e0bff903 	ldbu	r2,-28(fp)
8111aad8:	108000e8 	cmpgeui	r2,r2,3
8111aadc:	1000021e 	bne	r2,zero,8111aae8 <vLoadDefaultETHConf+0x3dc>
8111aae0:	e43ff903 	ldbu	r16,-28(fp)
8111aae4:	00000106 	br	8111aaec <vLoadDefaultETHConf+0x3e0>
8111aae8:	040000c4 	movi	r16,3
8111aaec:	e0bffd04 	addi	r2,fp,-12
8111aaf0:	1009883a 	mov	r4,r2
8111aaf4:	11228380 	call	81122838 <atoi>
8111aaf8:	1007883a 	mov	r3,r2
8111aafc:	00a045f4 	movhi	r2,33047
8111ab00:	10a01404 	addi	r2,r2,-32688
8111ab04:	1405883a 	add	r2,r2,r16
8111ab08:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ab0c:	e0bffd04 	addi	r2,fp,-12
8111ab10:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111ab14:	e0bff903 	ldbu	r2,-28(fp)
8111ab18:	10800044 	addi	r2,r2,1
8111ab1c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111ab20:	e0bff947 	ldb	r2,-27(fp)
8111ab24:	10800ed8 	cmpnei	r2,r2,59
8111ab28:	103fcf1e 	bne	r2,zero,8111aa68 <__reset+0xfb0faa68>

						break;
8111ab2c:	00011206 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 'G':

						ucParser = 0;
8111ab30:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ab34:	e0bffc0f 	ldh	r2,-16(fp)
8111ab38:	1009883a 	mov	r4,r2
8111ab3c:	11200400 	call	81120040 <cGetNextChar>
8111ab40:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ab44:	d0e00317 	ldw	r3,-32756(gp)
8111ab48:	e0bff947 	ldb	r2,-27(fp)
8111ab4c:	10800044 	addi	r2,r2,1
8111ab50:	1885883a 	add	r2,r3,r2
8111ab54:	10800003 	ldbu	r2,0(r2)
8111ab58:	10803fcc 	andi	r2,r2,255
8111ab5c:	1080010c 	andi	r2,r2,4
8111ab60:	10000626 	beq	r2,zero,8111ab7c <vLoadDefaultETHConf+0x470>
									(*p_inteiro) = c;
8111ab64:	e0bffa17 	ldw	r2,-24(fp)
8111ab68:	e0fff943 	ldbu	r3,-27(fp)
8111ab6c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ab70:	e0bffa17 	ldw	r2,-24(fp)
8111ab74:	10800044 	addi	r2,r2,1
8111ab78:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ab7c:	e0bff947 	ldb	r2,-27(fp)
8111ab80:	10800ba0 	cmpeqi	r2,r2,46
8111ab84:	1000031e 	bne	r2,zero,8111ab94 <vLoadDefaultETHConf+0x488>
8111ab88:	e0bff947 	ldb	r2,-27(fp)
8111ab8c:	10800ed8 	cmpnei	r2,r2,59
8111ab90:	103fe81e 	bne	r2,zero,8111ab34 <__reset+0xfb0fab34>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ab94:	e0bffa17 	ldw	r2,-24(fp)
8111ab98:	00c00284 	movi	r3,10
8111ab9c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
8111aba0:	e0bff903 	ldbu	r2,-28(fp)
8111aba4:	108000e8 	cmpgeui	r2,r2,3
8111aba8:	1000021e 	bne	r2,zero,8111abb4 <vLoadDefaultETHConf+0x4a8>
8111abac:	e43ff903 	ldbu	r16,-28(fp)
8111abb0:	00000106 	br	8111abb8 <vLoadDefaultETHConf+0x4ac>
8111abb4:	040000c4 	movi	r16,3
8111abb8:	e0bffd04 	addi	r2,fp,-12
8111abbc:	1009883a 	mov	r4,r2
8111abc0:	11228380 	call	81122838 <atoi>
8111abc4:	1007883a 	mov	r3,r2
8111abc8:	00a045f4 	movhi	r2,33047
8111abcc:	10a01404 	addi	r2,r2,-32688
8111abd0:	1405883a 	add	r2,r2,r16
8111abd4:	10800104 	addi	r2,r2,4
8111abd8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111abdc:	e0bffd04 	addi	r2,fp,-12
8111abe0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111abe4:	e0bff903 	ldbu	r2,-28(fp)
8111abe8:	10800044 	addi	r2,r2,1
8111abec:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111abf0:	e0bff947 	ldb	r2,-27(fp)
8111abf4:	10800ed8 	cmpnei	r2,r2,59
8111abf8:	103fce1e 	bne	r2,zero,8111ab34 <__reset+0xfb0fab34>

						break;
8111abfc:	0000de06 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 'P':
						ucParser = 0;
8111ac00:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
8111ac04:	e0bffc0f 	ldh	r2,-16(fp)
8111ac08:	1009883a 	mov	r4,r2
8111ac0c:	11200400 	call	81120040 <cGetNextChar>
8111ac10:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111ac14:	d0e00317 	ldw	r3,-32756(gp)
8111ac18:	e0bff947 	ldb	r2,-27(fp)
8111ac1c:	10800044 	addi	r2,r2,1
8111ac20:	1885883a 	add	r2,r3,r2
8111ac24:	10800003 	ldbu	r2,0(r2)
8111ac28:	10803fcc 	andi	r2,r2,255
8111ac2c:	1080010c 	andi	r2,r2,4
8111ac30:	10000626 	beq	r2,zero,8111ac4c <vLoadDefaultETHConf+0x540>
								(*p_inteiro) = c;
8111ac34:	e0bffa17 	ldw	r2,-24(fp)
8111ac38:	e0fff943 	ldbu	r3,-27(fp)
8111ac3c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ac40:	e0bffa17 	ldw	r2,-24(fp)
8111ac44:	10800044 	addi	r2,r2,1
8111ac48:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ac4c:	e0bff947 	ldb	r2,-27(fp)
8111ac50:	10800ed8 	cmpnei	r2,r2,59
8111ac54:	103feb1e 	bne	r2,zero,8111ac04 <__reset+0xfb0fac04>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ac58:	e0bffa17 	ldw	r2,-24(fp)
8111ac5c:	00c00284 	movi	r3,10
8111ac60:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
8111ac64:	e0bffd04 	addi	r2,fp,-12
8111ac68:	1009883a 	mov	r4,r2
8111ac6c:	11228380 	call	81122838 <atoi>
8111ac70:	1007883a 	mov	r3,r2
8111ac74:	00a045f4 	movhi	r2,33047
8111ac78:	10a01404 	addi	r2,r2,-32688
8111ac7c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ac80:	e0bffd04 	addi	r2,fp,-12
8111ac84:	e0bffa15 	stw	r2,-24(fp)

						break;
8111ac88:	0000bb06 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111ac8c:	e0bffc0f 	ldh	r2,-16(fp)
8111ac90:	1009883a 	mov	r4,r2
8111ac94:	11200400 	call	81120040 <cGetNextChar>
8111ac98:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111ac9c:	d0e00317 	ldw	r3,-32756(gp)
8111aca0:	e0bff947 	ldb	r2,-27(fp)
8111aca4:	10800044 	addi	r2,r2,1
8111aca8:	1885883a 	add	r2,r3,r2
8111acac:	10800003 	ldbu	r2,0(r2)
8111acb0:	10803fcc 	andi	r2,r2,255
8111acb4:	1080010c 	andi	r2,r2,4
8111acb8:	10000626 	beq	r2,zero,8111acd4 <vLoadDefaultETHConf+0x5c8>
								(*p_inteiro) = c;
8111acbc:	e0bffa17 	ldw	r2,-24(fp)
8111acc0:	e0fff943 	ldbu	r3,-27(fp)
8111acc4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111acc8:	e0bffa17 	ldw	r2,-24(fp)
8111accc:	10800044 	addi	r2,r2,1
8111acd0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111acd4:	e0bff947 	ldb	r2,-27(fp)
8111acd8:	10800ed8 	cmpnei	r2,r2,59
8111acdc:	103feb1e 	bne	r2,zero,8111ac8c <__reset+0xfb0fac8c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ace0:	e0bffa17 	ldw	r2,-24(fp)
8111ace4:	00c00284 	movi	r3,10
8111ace8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111acec:	e0bffd04 	addi	r2,fp,-12
8111acf0:	1009883a 	mov	r4,r2
8111acf4:	11228380 	call	81122838 <atoi>
8111acf8:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111acfc:	e0bffc8f 	ldh	r2,-14(fp)
8111ad00:	10800058 	cmpnei	r2,r2,1
8111ad04:	1000051e 	bne	r2,zero,8111ad1c <vLoadDefaultETHConf+0x610>
							xConfEth.bDHCP = TRUE;
8111ad08:	00a045f4 	movhi	r2,33047
8111ad0c:	10a01404 	addi	r2,r2,-32688
8111ad10:	00c00044 	movi	r3,1
8111ad14:	10c00615 	stw	r3,24(r2)
8111ad18:	00000306 	br	8111ad28 <vLoadDefaultETHConf+0x61c>
						else
							xConfEth.bDHCP = FALSE;
8111ad1c:	00a045f4 	movhi	r2,33047
8111ad20:	10a01404 	addi	r2,r2,-32688
8111ad24:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ad28:	e0bffd04 	addi	r2,fp,-12
8111ad2c:	e0bffa15 	stw	r2,-24(fp)

						break;
8111ad30:	00009106 	br	8111af78 <vLoadDefaultETHConf+0x86c>

					case 'S':

						ucParser = 0;
8111ad34:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ad38:	e0bffc0f 	ldh	r2,-16(fp)
8111ad3c:	1009883a 	mov	r4,r2
8111ad40:	11200400 	call	81120040 <cGetNextChar>
8111ad44:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ad48:	d0e00317 	ldw	r3,-32756(gp)
8111ad4c:	e0bff947 	ldb	r2,-27(fp)
8111ad50:	10800044 	addi	r2,r2,1
8111ad54:	1885883a 	add	r2,r3,r2
8111ad58:	10800003 	ldbu	r2,0(r2)
8111ad5c:	10803fcc 	andi	r2,r2,255
8111ad60:	1080010c 	andi	r2,r2,4
8111ad64:	10000626 	beq	r2,zero,8111ad80 <vLoadDefaultETHConf+0x674>
									(*p_inteiro) = c;
8111ad68:	e0bffa17 	ldw	r2,-24(fp)
8111ad6c:	e0fff943 	ldbu	r3,-27(fp)
8111ad70:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ad74:	e0bffa17 	ldw	r2,-24(fp)
8111ad78:	10800044 	addi	r2,r2,1
8111ad7c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ad80:	e0bff947 	ldb	r2,-27(fp)
8111ad84:	10800ba0 	cmpeqi	r2,r2,46
8111ad88:	1000031e 	bne	r2,zero,8111ad98 <vLoadDefaultETHConf+0x68c>
8111ad8c:	e0bff947 	ldb	r2,-27(fp)
8111ad90:	10800ed8 	cmpnei	r2,r2,59
8111ad94:	103fe81e 	bne	r2,zero,8111ad38 <__reset+0xfb0fad38>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ad98:	e0bffa17 	ldw	r2,-24(fp)
8111ad9c:	00c00284 	movi	r3,10
8111ada0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
8111ada4:	e0bff903 	ldbu	r2,-28(fp)
8111ada8:	108000e8 	cmpgeui	r2,r2,3
8111adac:	1000021e 	bne	r2,zero,8111adb8 <vLoadDefaultETHConf+0x6ac>
8111adb0:	e43ff903 	ldbu	r16,-28(fp)
8111adb4:	00000106 	br	8111adbc <vLoadDefaultETHConf+0x6b0>
8111adb8:	040000c4 	movi	r16,3
8111adbc:	e0bffd04 	addi	r2,fp,-12
8111adc0:	1009883a 	mov	r4,r2
8111adc4:	11228380 	call	81122838 <atoi>
8111adc8:	1007883a 	mov	r3,r2
8111adcc:	00a045f4 	movhi	r2,33047
8111add0:	10a01404 	addi	r2,r2,-32688
8111add4:	1405883a 	add	r2,r2,r16
8111add8:	10800204 	addi	r2,r2,8
8111addc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ade0:	e0bffd04 	addi	r2,fp,-12
8111ade4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111ade8:	e0bff903 	ldbu	r2,-28(fp)
8111adec:	10800044 	addi	r2,r2,1
8111adf0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111adf4:	e0bff947 	ldb	r2,-27(fp)
8111adf8:	10800ed8 	cmpnei	r2,r2,59
8111adfc:	103fce1e 	bne	r2,zero,8111ad38 <__reset+0xfb0fad38>

						break;
8111ae00:	00005d06 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 'D':

						ucParser = 0;
8111ae04:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ae08:	e0bffc0f 	ldh	r2,-16(fp)
8111ae0c:	1009883a 	mov	r4,r2
8111ae10:	11200400 	call	81120040 <cGetNextChar>
8111ae14:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ae18:	d0e00317 	ldw	r3,-32756(gp)
8111ae1c:	e0bff947 	ldb	r2,-27(fp)
8111ae20:	10800044 	addi	r2,r2,1
8111ae24:	1885883a 	add	r2,r3,r2
8111ae28:	10800003 	ldbu	r2,0(r2)
8111ae2c:	10803fcc 	andi	r2,r2,255
8111ae30:	1080010c 	andi	r2,r2,4
8111ae34:	10000626 	beq	r2,zero,8111ae50 <vLoadDefaultETHConf+0x744>
									(*p_inteiro) = c;
8111ae38:	e0bffa17 	ldw	r2,-24(fp)
8111ae3c:	e0fff943 	ldbu	r3,-27(fp)
8111ae40:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ae44:	e0bffa17 	ldw	r2,-24(fp)
8111ae48:	10800044 	addi	r2,r2,1
8111ae4c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ae50:	e0bff947 	ldb	r2,-27(fp)
8111ae54:	10800ba0 	cmpeqi	r2,r2,46
8111ae58:	1000031e 	bne	r2,zero,8111ae68 <vLoadDefaultETHConf+0x75c>
8111ae5c:	e0bff947 	ldb	r2,-27(fp)
8111ae60:	10800ed8 	cmpnei	r2,r2,59
8111ae64:	103fe81e 	bne	r2,zero,8111ae08 <__reset+0xfb0fae08>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ae68:	e0bffa17 	ldw	r2,-24(fp)
8111ae6c:	00c00284 	movi	r3,10
8111ae70:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
8111ae74:	e0bff903 	ldbu	r2,-28(fp)
8111ae78:	108000e8 	cmpgeui	r2,r2,3
8111ae7c:	1000021e 	bne	r2,zero,8111ae88 <vLoadDefaultETHConf+0x77c>
8111ae80:	e43ff903 	ldbu	r16,-28(fp)
8111ae84:	00000106 	br	8111ae8c <vLoadDefaultETHConf+0x780>
8111ae88:	040000c4 	movi	r16,3
8111ae8c:	e0bffd04 	addi	r2,fp,-12
8111ae90:	1009883a 	mov	r4,r2
8111ae94:	11228380 	call	81122838 <atoi>
8111ae98:	1007883a 	mov	r3,r2
8111ae9c:	00a045f4 	movhi	r2,33047
8111aea0:	10a01404 	addi	r2,r2,-32688
8111aea4:	1405883a 	add	r2,r2,r16
8111aea8:	10800304 	addi	r2,r2,12
8111aeac:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aeb0:	e0bffd04 	addi	r2,fp,-12
8111aeb4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111aeb8:	e0bff903 	ldbu	r2,-28(fp)
8111aebc:	10800044 	addi	r2,r2,1
8111aec0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111aec4:	e0bff947 	ldb	r2,-27(fp)
8111aec8:	10800ed8 	cmpnei	r2,r2,59
8111aecc:	103fce1e 	bne	r2,zero,8111ae08 <__reset+0xfb0fae08>

						break;						
8111aed0:	00002906 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111aed4:	e0bffc0f 	ldh	r2,-16(fp)
8111aed8:	1009883a 	mov	r4,r2
8111aedc:	11200000 	call	81120000 <siCloseFile>
8111aee0:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111aee4:	e0bffb17 	ldw	r2,-20(fp)
8111aee8:	10000d1e 	bne	r2,zero,8111af20 <vLoadDefaultETHConf+0x814>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111aeec:	00a045f4 	movhi	r2,33047
8111aef0:	10a00404 	addi	r2,r2,-32752
8111aef4:	10800e8b 	ldhu	r2,58(r2)
8111aef8:	10bfffcc 	andi	r2,r2,65535
8111aefc:	108001e8 	cmpgeui	r2,r2,7
8111af00:	1000071e 	bne	r2,zero,8111af20 <vLoadDefaultETHConf+0x814>
								debug(fp,"SDCard: Can't close the file.\n");
8111af04:	d0a06217 	ldw	r2,-32376(gp)
8111af08:	100f883a 	mov	r7,r2
8111af0c:	01800784 	movi	r6,30
8111af10:	01400044 	movi	r5,1
8111af14:	01204574 	movhi	r4,33045
8111af18:	213fbd04 	addi	r4,r4,-268
8111af1c:	11230300 	call	81123030 <fwrite>
							}
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111af20:	00800044 	movi	r2,1
8111af24:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111af28:	00800044 	movi	r2,1
8111af2c:	e0bff715 	stw	r2,-36(fp)
						break;
8111af30:	00001106 	br	8111af78 <vLoadDefaultETHConf+0x86c>
					default:
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111af34:	00a045f4 	movhi	r2,33047
8111af38:	10a00404 	addi	r2,r2,-32752
8111af3c:	10800e8b 	ldhu	r2,58(r2)
8111af40:	10bfffcc 	andi	r2,r2,65535
8111af44:	108001e8 	cmpgeui	r2,r2,7
8111af48:	10000a1e 	bne	r2,zero,8111af74 <vLoadDefaultETHConf+0x868>
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111af4c:	d0a06217 	ldw	r2,-32376(gp)
8111af50:	100f883a 	mov	r7,r2
8111af54:	01800844 	movi	r6,33
8111af58:	01400044 	movi	r5,1
8111af5c:	01204574 	movhi	r4,33045
8111af60:	213fc504 	addi	r4,r4,-236
8111af64:	11230300 	call	81123030 <fwrite>
						}
						#endif
						break;
8111af68:	00000206 	br	8111af74 <vLoadDefaultETHConf+0x868>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111af6c:	0001883a 	nop
8111af70:	00000106 	br	8111af78 <vLoadDefaultETHConf+0x86c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
							fprintf(fp,"SDCard: Problem with the parser.\n");
						}
						#endif
						break;
8111af74:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8111af78:	e0bff817 	ldw	r2,-32(fp)
8111af7c:	103e0126 	beq	r2,zero,8111a784 <__reset+0xfb0fa784>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111af80:	00001c06 	br	8111aff4 <vLoadDefaultETHConf+0x8e8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111af84:	00a045f4 	movhi	r2,33047
8111af88:	10a00404 	addi	r2,r2,-32752
8111af8c:	10800e8b 	ldhu	r2,58(r2)
8111af90:	10bfffcc 	andi	r2,r2,65535
8111af94:	108001e8 	cmpgeui	r2,r2,7
8111af98:	1000161e 	bne	r2,zero,8111aff4 <vLoadDefaultETHConf+0x8e8>
				fprintf(fp,"SDCard: File not found.\n");
8111af9c:	d0a06217 	ldw	r2,-32376(gp)
8111afa0:	100f883a 	mov	r7,r2
8111afa4:	01800604 	movi	r6,24
8111afa8:	01400044 	movi	r5,1
8111afac:	01204574 	movhi	r4,33045
8111afb0:	213fce04 	addi	r4,r4,-200
8111afb4:	11230300 	call	81123030 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111afb8:	00000e06 	br	8111aff4 <vLoadDefaultETHConf+0x8e8>
			}
			#endif
		}
	} else {
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111afbc:	00a045f4 	movhi	r2,33047
8111afc0:	10a00404 	addi	r2,r2,-32752
8111afc4:	10800e8b 	ldhu	r2,58(r2)
8111afc8:	10bfffcc 	andi	r2,r2,65535
8111afcc:	108001e8 	cmpgeui	r2,r2,7
8111afd0:	1000091e 	bne	r2,zero,8111aff8 <vLoadDefaultETHConf+0x8ec>
			fprintf(fp,"SDCard: No SDCard.\n");
8111afd4:	d0a06217 	ldw	r2,-32376(gp)
8111afd8:	100f883a 	mov	r7,r2
8111afdc:	018004c4 	movi	r6,19
8111afe0:	01400044 	movi	r5,1
8111afe4:	01204574 	movhi	r4,33045
8111afe8:	213fd504 	addi	r4,r4,-172
8111afec:	11230300 	call	81123030 <fwrite>
8111aff0:	00000106 	br	8111aff8 <vLoadDefaultETHConf+0x8ec>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111aff4:	0001883a 	nop
			fprintf(fp,"SDCard: No SDCard.\n");
		}
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111aff8:	e0bff717 	ldw	r2,-36(fp)
8111affc:	10004c1e 	bne	r2,zero,8111b130 <vLoadDefaultETHConf+0xa24>
		xConfEth.siPortPUS = 17000;
8111b000:	00a045f4 	movhi	r2,33047
8111b004:	10a01404 	addi	r2,r2,-32688
8111b008:	00d09a04 	movi	r3,17000
8111b00c:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111b010:	00a045f4 	movhi	r2,33047
8111b014:	10a01404 	addi	r2,r2,-32688
8111b018:	00fff004 	movi	r3,-64
8111b01c:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111b020:	00a045f4 	movhi	r2,33047
8111b024:	10a01404 	addi	r2,r2,-32688
8111b028:	00ffea04 	movi	r3,-88
8111b02c:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111b030:	00a045f4 	movhi	r2,33047
8111b034:	10a01404 	addi	r2,r2,-32688
8111b038:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8111b03c:	00a045f4 	movhi	r2,33047
8111b040:	10a01404 	addi	r2,r2,-32688
8111b044:	00c00144 	movi	r3,5
8111b048:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8111b04c:	00a045f4 	movhi	r2,33047
8111b050:	10a01404 	addi	r2,r2,-32688
8111b054:	00fff004 	movi	r3,-64
8111b058:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8111b05c:	00a045f4 	movhi	r2,33047
8111b060:	10a01404 	addi	r2,r2,-32688
8111b064:	00ffea04 	movi	r3,-88
8111b068:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111b06c:	00a045f4 	movhi	r2,33047
8111b070:	10a01404 	addi	r2,r2,-32688
8111b074:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111b078:	00a045f4 	movhi	r2,33047
8111b07c:	10a01404 	addi	r2,r2,-32688
8111b080:	00c00044 	movi	r3,1
8111b084:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111b088:	00a045f4 	movhi	r2,33047
8111b08c:	10a01404 	addi	r2,r2,-32688
8111b090:	00ffffc4 	movi	r3,-1
8111b094:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111b098:	00a045f4 	movhi	r2,33047
8111b09c:	10a01404 	addi	r2,r2,-32688
8111b0a0:	00ffffc4 	movi	r3,-1
8111b0a4:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111b0a8:	00a045f4 	movhi	r2,33047
8111b0ac:	10a01404 	addi	r2,r2,-32688
8111b0b0:	00ffffc4 	movi	r3,-1
8111b0b4:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111b0b8:	00a045f4 	movhi	r2,33047
8111b0bc:	10a01404 	addi	r2,r2,-32688
8111b0c0:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111b0c4:	00a045f4 	movhi	r2,33047
8111b0c8:	10a01404 	addi	r2,r2,-32688
8111b0cc:	00ffff04 	movi	r3,-4
8111b0d0:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111b0d4:	00a045f4 	movhi	r2,33047
8111b0d8:	10a01404 	addi	r2,r2,-32688
8111b0dc:	00fffdc4 	movi	r3,-9
8111b0e0:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111b0e4:	00a045f4 	movhi	r2,33047
8111b0e8:	10a01404 	addi	r2,r2,-32688
8111b0ec:	00c018c4 	movi	r3,99
8111b0f0:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111b0f4:	00a045f4 	movhi	r2,33047
8111b0f8:	10a01404 	addi	r2,r2,-32688
8111b0fc:	00c01344 	movi	r3,77
8111b100:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111b104:	00a045f4 	movhi	r2,33047
8111b108:	10a01404 	addi	r2,r2,-32688
8111b10c:	00c007c4 	movi	r3,31
8111b110:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111b114:	00a045f4 	movhi	r2,33047
8111b118:	10a01404 	addi	r2,r2,-32688
8111b11c:	00c01084 	movi	r3,66
8111b120:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111b124:	00a045f4 	movhi	r2,33047
8111b128:	10a01404 	addi	r2,r2,-32688
8111b12c:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111b130:	e0bff717 	ldw	r2,-36(fp)
}
8111b134:	e6ffff04 	addi	sp,fp,-4
8111b138:	dfc00217 	ldw	ra,8(sp)
8111b13c:	df000117 	ldw	fp,4(sp)
8111b140:	dc000017 	ldw	r16,0(sp)
8111b144:	dec00304 	addi	sp,sp,12
8111b148:	f800283a 	ret

8111b14c <vShowEthConfig>:

#if DEBUG_ON
	void vShowEthConfig( void ) {
8111b14c:	defff004 	addi	sp,sp,-64
8111b150:	de00012e 	bgeu	sp,et,8111b158 <vShowEthConfig+0xc>
8111b154:	003b68fa 	trap	3
8111b158:	dfc00f15 	stw	ra,60(sp)
8111b15c:	df000e15 	stw	fp,56(sp)
8111b160:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111b164:	d0a06217 	ldw	r2,-32376(gp)
8111b168:	100f883a 	mov	r7,r2
8111b16c:	018007c4 	movi	r6,31
8111b170:	01400044 	movi	r5,1
8111b174:	01204574 	movhi	r4,33045
8111b178:	213fda04 	addi	r4,r4,-152
8111b17c:	11230300 	call	81123030 <fwrite>

		memset(buffer,0,40);
8111b180:	01800a04 	movi	r6,40
8111b184:	000b883a 	mov	r5,zero
8111b188:	e13ff604 	addi	r4,fp,-40
8111b18c:	1123b940 	call	81123b94 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111b190:	00a045f4 	movhi	r2,33047
8111b194:	10a01404 	addi	r2,r2,-32688
8111b198:	10800403 	ldbu	r2,16(r2)
8111b19c:	11803fcc 	andi	r6,r2,255
8111b1a0:	00a045f4 	movhi	r2,33047
8111b1a4:	10a01404 	addi	r2,r2,-32688
8111b1a8:	10800443 	ldbu	r2,17(r2)
8111b1ac:	11c03fcc 	andi	r7,r2,255
8111b1b0:	00a045f4 	movhi	r2,33047
8111b1b4:	10a01404 	addi	r2,r2,-32688
8111b1b8:	10800483 	ldbu	r2,18(r2)
8111b1bc:	10c03fcc 	andi	r3,r2,255
8111b1c0:	00a045f4 	movhi	r2,33047
8111b1c4:	10a01404 	addi	r2,r2,-32688
8111b1c8:	108004c3 	ldbu	r2,19(r2)
8111b1cc:	11003fcc 	andi	r4,r2,255
8111b1d0:	00a045f4 	movhi	r2,33047
8111b1d4:	10a01404 	addi	r2,r2,-32688
8111b1d8:	10800503 	ldbu	r2,20(r2)
8111b1dc:	11403fcc 	andi	r5,r2,255
8111b1e0:	00a045f4 	movhi	r2,33047
8111b1e4:	10a01404 	addi	r2,r2,-32688
8111b1e8:	10800543 	ldbu	r2,21(r2)
8111b1ec:	10803fcc 	andi	r2,r2,255
8111b1f0:	d8800315 	stw	r2,12(sp)
8111b1f4:	d9400215 	stw	r5,8(sp)
8111b1f8:	d9000115 	stw	r4,4(sp)
8111b1fc:	d8c00015 	stw	r3,0(sp)
8111b200:	01604574 	movhi	r5,33045
8111b204:	297fe204 	addi	r5,r5,-120
8111b208:	e13ff604 	addi	r4,fp,-40
8111b20c:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer );
8111b210:	d0a06217 	ldw	r2,-32376(gp)
8111b214:	e17ff604 	addi	r5,fp,-40
8111b218:	1009883a 	mov	r4,r2
8111b21c:	11229940 	call	81122994 <fprintf>

		memset(buffer,0,40);
8111b220:	01800a04 	movi	r6,40
8111b224:	000b883a 	mov	r5,zero
8111b228:	e13ff604 	addi	r4,fp,-40
8111b22c:	1123b940 	call	81123b94 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111b230:	00a045f4 	movhi	r2,33047
8111b234:	10a01404 	addi	r2,r2,-32688
8111b238:	10800003 	ldbu	r2,0(r2)
8111b23c:	11003fcc 	andi	r4,r2,255
8111b240:	00a045f4 	movhi	r2,33047
8111b244:	10a01404 	addi	r2,r2,-32688
8111b248:	10800043 	ldbu	r2,1(r2)
8111b24c:	11403fcc 	andi	r5,r2,255
8111b250:	00a045f4 	movhi	r2,33047
8111b254:	10a01404 	addi	r2,r2,-32688
8111b258:	10800083 	ldbu	r2,2(r2)
8111b25c:	10c03fcc 	andi	r3,r2,255
8111b260:	00a045f4 	movhi	r2,33047
8111b264:	10a01404 	addi	r2,r2,-32688
8111b268:	108000c3 	ldbu	r2,3(r2)
8111b26c:	10803fcc 	andi	r2,r2,255
8111b270:	d8800115 	stw	r2,4(sp)
8111b274:	d8c00015 	stw	r3,0(sp)
8111b278:	280f883a 	mov	r7,r5
8111b27c:	200d883a 	mov	r6,r4
8111b280:	01604574 	movhi	r5,33045
8111b284:	297feb04 	addi	r5,r5,-84
8111b288:	e13ff604 	addi	r4,fp,-40
8111b28c:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer );
8111b290:	d0a06217 	ldw	r2,-32376(gp)
8111b294:	e17ff604 	addi	r5,fp,-40
8111b298:	1009883a 	mov	r4,r2
8111b29c:	11229940 	call	81122994 <fprintf>

		memset(buffer,0,40);
8111b2a0:	01800a04 	movi	r6,40
8111b2a4:	000b883a 	mov	r5,zero
8111b2a8:	e13ff604 	addi	r4,fp,-40
8111b2ac:	1123b940 	call	81123b94 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111b2b0:	00a045f4 	movhi	r2,33047
8111b2b4:	10a01404 	addi	r2,r2,-32688
8111b2b8:	10800103 	ldbu	r2,4(r2)
8111b2bc:	11003fcc 	andi	r4,r2,255
8111b2c0:	00a045f4 	movhi	r2,33047
8111b2c4:	10a01404 	addi	r2,r2,-32688
8111b2c8:	10800143 	ldbu	r2,5(r2)
8111b2cc:	11403fcc 	andi	r5,r2,255
8111b2d0:	00a045f4 	movhi	r2,33047
8111b2d4:	10a01404 	addi	r2,r2,-32688
8111b2d8:	10800183 	ldbu	r2,6(r2)
8111b2dc:	10c03fcc 	andi	r3,r2,255
8111b2e0:	00a045f4 	movhi	r2,33047
8111b2e4:	10a01404 	addi	r2,r2,-32688
8111b2e8:	108001c3 	ldbu	r2,7(r2)
8111b2ec:	10803fcc 	andi	r2,r2,255
8111b2f0:	d8800115 	stw	r2,4(sp)
8111b2f4:	d8c00015 	stw	r3,0(sp)
8111b2f8:	280f883a 	mov	r7,r5
8111b2fc:	200d883a 	mov	r6,r4
8111b300:	01604574 	movhi	r5,33045
8111b304:	297ff104 	addi	r5,r5,-60
8111b308:	e13ff604 	addi	r4,fp,-40
8111b30c:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer );
8111b310:	d0a06217 	ldw	r2,-32376(gp)
8111b314:	e17ff604 	addi	r5,fp,-40
8111b318:	1009883a 	mov	r4,r2
8111b31c:	11229940 	call	81122994 <fprintf>

		memset(buffer,0,40);
8111b320:	01800a04 	movi	r6,40
8111b324:	000b883a 	mov	r5,zero
8111b328:	e13ff604 	addi	r4,fp,-40
8111b32c:	1123b940 	call	81123b94 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111b330:	00a045f4 	movhi	r2,33047
8111b334:	10a01404 	addi	r2,r2,-32688
8111b338:	10800203 	ldbu	r2,8(r2)
8111b33c:	11003fcc 	andi	r4,r2,255
8111b340:	00a045f4 	movhi	r2,33047
8111b344:	10a01404 	addi	r2,r2,-32688
8111b348:	10800243 	ldbu	r2,9(r2)
8111b34c:	11403fcc 	andi	r5,r2,255
8111b350:	00a045f4 	movhi	r2,33047
8111b354:	10a01404 	addi	r2,r2,-32688
8111b358:	10800283 	ldbu	r2,10(r2)
8111b35c:	10c03fcc 	andi	r3,r2,255
8111b360:	00a045f4 	movhi	r2,33047
8111b364:	10a01404 	addi	r2,r2,-32688
8111b368:	108002c3 	ldbu	r2,11(r2)
8111b36c:	10803fcc 	andi	r2,r2,255
8111b370:	d8800115 	stw	r2,4(sp)
8111b374:	d8c00015 	stw	r3,0(sp)
8111b378:	280f883a 	mov	r7,r5
8111b37c:	200d883a 	mov	r6,r4
8111b380:	01604574 	movhi	r5,33045
8111b384:	297ff804 	addi	r5,r5,-32
8111b388:	e13ff604 	addi	r4,fp,-40
8111b38c:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer );
8111b390:	d0a06217 	ldw	r2,-32376(gp)
8111b394:	e17ff604 	addi	r5,fp,-40
8111b398:	1009883a 	mov	r4,r2
8111b39c:	11229940 	call	81122994 <fprintf>

		memset(buffer,0,40);
8111b3a0:	01800a04 	movi	r6,40
8111b3a4:	000b883a 	mov	r5,zero
8111b3a8:	e13ff604 	addi	r4,fp,-40
8111b3ac:	1123b940 	call	81123b94 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111b3b0:	00a045f4 	movhi	r2,33047
8111b3b4:	10a01404 	addi	r2,r2,-32688
8111b3b8:	10800303 	ldbu	r2,12(r2)
8111b3bc:	11003fcc 	andi	r4,r2,255
8111b3c0:	00a045f4 	movhi	r2,33047
8111b3c4:	10a01404 	addi	r2,r2,-32688
8111b3c8:	10800343 	ldbu	r2,13(r2)
8111b3cc:	11403fcc 	andi	r5,r2,255
8111b3d0:	00a045f4 	movhi	r2,33047
8111b3d4:	10a01404 	addi	r2,r2,-32688
8111b3d8:	10800383 	ldbu	r2,14(r2)
8111b3dc:	10c03fcc 	andi	r3,r2,255
8111b3e0:	00a045f4 	movhi	r2,33047
8111b3e4:	10a01404 	addi	r2,r2,-32688
8111b3e8:	108003c3 	ldbu	r2,15(r2)
8111b3ec:	10803fcc 	andi	r2,r2,255
8111b3f0:	d8800115 	stw	r2,4(sp)
8111b3f4:	d8c00015 	stw	r3,0(sp)
8111b3f8:	280f883a 	mov	r7,r5
8111b3fc:	200d883a 	mov	r6,r4
8111b400:	01604574 	movhi	r5,33045
8111b404:	297fff04 	addi	r5,r5,-4
8111b408:	e13ff604 	addi	r4,fp,-40
8111b40c:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer );
8111b410:	d0a06217 	ldw	r2,-32376(gp)
8111b414:	e17ff604 	addi	r5,fp,-40
8111b418:	1009883a 	mov	r4,r2
8111b41c:	11229940 	call	81122994 <fprintf>

		memset(buffer,0,40);
8111b420:	01800a04 	movi	r6,40
8111b424:	000b883a 	mov	r5,zero
8111b428:	e13ff604 	addi	r4,fp,-40
8111b42c:	1123b940 	call	81123b94 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111b430:	00a045f4 	movhi	r2,33047
8111b434:	10a01404 	addi	r2,r2,-32688
8111b438:	1080058b 	ldhu	r2,22(r2)
8111b43c:	10bfffcc 	andi	r2,r2,65535
8111b440:	100d883a 	mov	r6,r2
8111b444:	01604574 	movhi	r5,33045
8111b448:	29400604 	addi	r5,r5,24
8111b44c:	e13ff604 	addi	r4,fp,-40
8111b450:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer );
8111b454:	d0a06217 	ldw	r2,-32376(gp)
8111b458:	e17ff604 	addi	r5,fp,-40
8111b45c:	1009883a 	mov	r4,r2
8111b460:	11229940 	call	81122994 <fprintf>

	}
8111b464:	0001883a 	nop
8111b468:	e037883a 	mov	sp,fp
8111b46c:	dfc00117 	ldw	ra,4(sp)
8111b470:	df000017 	ldw	fp,0(sp)
8111b474:	dec00204 	addi	sp,sp,8
8111b478:	f800283a 	ret

8111b47c <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111b47c:	defff004 	addi	sp,sp,-64
8111b480:	de00012e 	bgeu	sp,et,8111b488 <vLoadDebugConfs+0xc>
8111b484:	003b68fa 	trap	3
8111b488:	dfc00f15 	stw	ra,60(sp)
8111b48c:	df000e15 	stw	fp,56(sp)
8111b490:	df000e04 	addi	fp,sp,56
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111b494:	e03ff215 	stw	zero,-56(fp)
	bool bEOF = FALSE;
8111b498:	e03ff315 	stw	zero,-52(fp)
	bool close = FALSE;
8111b49c:	e03ff615 	stw	zero,-40(fp)
	char c, *p_inteiro;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111b4a0:	d0a07617 	ldw	r2,-32296(gp)
8111b4a4:	10800058 	cmpnei	r2,r2,1
8111b4a8:	1003851e 	bne	r2,zero,8111c2c0 <vLoadDebugConfs+0xe44>
8111b4ac:	111fe6c0 	call	8111fe6c <bSDcardIsPresent>
8111b4b0:	10038326 	beq	r2,zero,8111c2c0 <vLoadDebugConfs+0xe44>
8111b4b4:	111fe9c0 	call	8111fe9c <bSDcardFAT16Check>
8111b4b8:	10038126 	beq	r2,zero,8111c2c0 <vLoadDebugConfs+0xe44>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111b4bc:	01204574 	movhi	r4,33045
8111b4c0:	21000a04 	addi	r4,r4,40
8111b4c4:	111ffc40 	call	8111ffc4 <siOpenFile>
8111b4c8:	e0bff70d 	sth	r2,-36(fp)

		if ( siFile >= 0 ){
8111b4cc:	e0bff70f 	ldh	r2,-36(fp)
8111b4d0:	10037316 	blt	r2,zero,8111c2a0 <vLoadDebugConfs+0xe24>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111b4d4:	e0bff804 	addi	r2,fp,-32
8111b4d8:	01800204 	movi	r6,8
8111b4dc:	01400284 	movi	r5,10
8111b4e0:	1009883a 	mov	r4,r2
8111b4e4:	1123b940 	call	81123b94 <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8111b4e8:	e0bffa04 	addi	r2,fp,-24
8111b4ec:	01800604 	movi	r6,24
8111b4f0:	01400284 	movi	r5,10
8111b4f4:	1009883a 	mov	r4,r2
8111b4f8:	1123b940 	call	81123b94 <memset>
			p_inteiro = inteiro;
8111b4fc:	e0bff804 	addi	r2,fp,-32
8111b500:	e0bff515 	stw	r2,-44(fp)

			do {
				c = cGetNextChar(siFile);
8111b504:	e0bff70f 	ldh	r2,-36(fp)
8111b508:	1009883a 	mov	r4,r2
8111b50c:	11200400 	call	81120040 <cGetNextChar>
8111b510:	e0bff445 	stb	r2,-47(fp)
				//printf("%c \n", c);
				switch (c) {
8111b514:	e0bff447 	ldb	r2,-47(fp)
8111b518:	10800084 	addi	r2,r2,2
8111b51c:	10c01768 	cmpgeui	r3,r2,93
8111b520:	1803531e 	bne	r3,zero,8111c270 <vLoadDebugConfs+0xdf4>
8111b524:	100690ba 	slli	r3,r2,2
8111b528:	00a044b4 	movhi	r2,33042
8111b52c:	10ad4f04 	addi	r2,r2,-19140
8111b530:	1885883a 	add	r2,r3,r2
8111b534:	10800017 	ldw	r2,0(r2)
8111b538:	1000683a 	jmp	r2
8111b53c:	8111b6f0 	cmpltui	r4,r16,18139
8111b540:	8111b6e4 	muli	r4,r16,18139
8111b544:	8111c270 	cmpltui	r4,r16,18185
8111b548:	8111c270 	cmpltui	r4,r16,18185
8111b54c:	8111c270 	cmpltui	r4,r16,18185
8111b550:	8111c270 	cmpltui	r4,r16,18185
8111b554:	8111c270 	cmpltui	r4,r16,18185
8111b558:	8111c270 	cmpltui	r4,r16,18185
8111b55c:	8111c270 	cmpltui	r4,r16,18185
8111b560:	8111c270 	cmpltui	r4,r16,18185
8111b564:	8111c270 	cmpltui	r4,r16,18185
8111b568:	8111c270 	cmpltui	r4,r16,18185
8111b56c:	8111c290 	cmplti	r4,r16,18186
8111b570:	8111c270 	cmpltui	r4,r16,18185
8111b574:	8111c270 	cmpltui	r4,r16,18185
8111b578:	8111c290 	cmplti	r4,r16,18186
8111b57c:	8111c270 	cmpltui	r4,r16,18185
8111b580:	8111c270 	cmpltui	r4,r16,18185
8111b584:	8111c270 	cmpltui	r4,r16,18185
8111b588:	8111c270 	cmpltui	r4,r16,18185
8111b58c:	8111c270 	cmpltui	r4,r16,18185
8111b590:	8111c270 	cmpltui	r4,r16,18185
8111b594:	8111c270 	cmpltui	r4,r16,18185
8111b598:	8111c270 	cmpltui	r4,r16,18185
8111b59c:	8111c270 	cmpltui	r4,r16,18185
8111b5a0:	8111c270 	cmpltui	r4,r16,18185
8111b5a4:	8111c270 	cmpltui	r4,r16,18185
8111b5a8:	8111c270 	cmpltui	r4,r16,18185
8111b5ac:	8111c270 	cmpltui	r4,r16,18185
8111b5b0:	8111c270 	cmpltui	r4,r16,18185
8111b5b4:	8111c270 	cmpltui	r4,r16,18185
8111b5b8:	8111c270 	cmpltui	r4,r16,18185
8111b5bc:	8111c270 	cmpltui	r4,r16,18185
8111b5c0:	8111c270 	cmpltui	r4,r16,18185
8111b5c4:	8111c290 	cmplti	r4,r16,18186
8111b5c8:	8111c270 	cmpltui	r4,r16,18185
8111b5cc:	8111c270 	cmpltui	r4,r16,18185
8111b5d0:	8111c270 	cmpltui	r4,r16,18185
8111b5d4:	8111c270 	cmpltui	r4,r16,18185
8111b5d8:	8111c270 	cmpltui	r4,r16,18185
8111b5dc:	8111c270 	cmpltui	r4,r16,18185
8111b5e0:	8111b6b0 	cmpltui	r4,r16,18138
8111b5e4:	8111c270 	cmpltui	r4,r16,18185
8111b5e8:	8111c270 	cmpltui	r4,r16,18185
8111b5ec:	8111c270 	cmpltui	r4,r16,18185
8111b5f0:	8111c270 	cmpltui	r4,r16,18185
8111b5f4:	8111c270 	cmpltui	r4,r16,18185
8111b5f8:	8111c270 	cmpltui	r4,r16,18185
8111b5fc:	8111c270 	cmpltui	r4,r16,18185
8111b600:	8111c270 	cmpltui	r4,r16,18185
8111b604:	8111c270 	cmpltui	r4,r16,18185
8111b608:	8111c270 	cmpltui	r4,r16,18185
8111b60c:	8111c270 	cmpltui	r4,r16,18185
8111b610:	8111c270 	cmpltui	r4,r16,18185
8111b614:	8111c270 	cmpltui	r4,r16,18185
8111b618:	8111c270 	cmpltui	r4,r16,18185
8111b61c:	8111c270 	cmpltui	r4,r16,18185
8111b620:	8111c270 	cmpltui	r4,r16,18185
8111b624:	8111c270 	cmpltui	r4,r16,18185
8111b628:	8111c270 	cmpltui	r4,r16,18185
8111b62c:	8111c270 	cmpltui	r4,r16,18185
8111b630:	8111c270 	cmpltui	r4,r16,18185
8111b634:	8111c228 	cmpgeui	r4,r16,18184
8111b638:	8111c270 	cmpltui	r4,r16,18185
8111b63c:	8111c270 	cmpltui	r4,r16,18185
8111b640:	8111c270 	cmpltui	r4,r16,18185
8111b644:	8111c270 	cmpltui	r4,r16,18185
8111b648:	8111b9d8 	cmpnei	r4,r16,18151
8111b64c:	8111beb8 	rdprs	r4,r16,18170
8111b650:	8111bbe8 	cmpgeui	r4,r16,18159
8111b654:	8111bc98 	cmpnei	r4,r16,18162
8111b658:	8111c270 	cmpltui	r4,r16,18185
8111b65c:	8111bf40 	call	88111bf4 <__reset+0x20f1bf4>
8111b660:	8111c270 	cmpltui	r4,r16,18185
8111b664:	8111c270 	cmpltui	r4,r16,18185
8111b668:	8111c270 	cmpltui	r4,r16,18185
8111b66c:	8111be30 	cmpltui	r4,r16,18168
8111b670:	8111bd20 	cmpeqi	r4,r16,18164
8111b674:	8111ba88 	cmpgei	r4,r16,18154
8111b678:	8111bda8 	cmpgeui	r4,r16,18166
8111b67c:	8111b878 	rdprs	r4,r16,18145
8111b680:	8111bb38 	rdprs	r4,r16,18156
8111b684:	8111b7c8 	cmpgei	r4,r16,18143
8111b688:	8111bfc8 	cmpgei	r4,r16,18175
8111b68c:	8111b928 	cmpgeui	r4,r16,18148
8111b690:	8111b718 	cmpnei	r4,r16,18140
8111b694:	8111c0d8 	cmpnei	r4,r16,18179
8111b698:	8111c270 	cmpltui	r4,r16,18185
8111b69c:	8111c270 	cmpltui	r4,r16,18185
8111b6a0:	8111c270 	cmpltui	r4,r16,18185
8111b6a4:	8111c270 	cmpltui	r4,r16,18185
8111b6a8:	8111c050 	cmplti	r4,r16,18177
8111b6ac:	8111c180 	call	88111c18 <__reset+0x20f1c18>
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111b6b0:	e0bff70f 	ldh	r2,-36(fp)
8111b6b4:	1009883a 	mov	r4,r2
8111b6b8:	11200400 	call	81120040 <cGetNextChar>
8111b6bc:	e0bff445 	stb	r2,-47(fp)
						while ( c != 39 ){
8111b6c0:	00000406 	br	8111b6d4 <vLoadDebugConfs+0x258>
							c = cGetNextChar(siFile);
8111b6c4:	e0bff70f 	ldh	r2,-36(fp)
8111b6c8:	1009883a 	mov	r4,r2
8111b6cc:	11200400 	call	81120040 <cGetNextChar>
8111b6d0:	e0bff445 	stb	r2,-47(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111b6d4:	e0bff447 	ldb	r2,-47(fp)
8111b6d8:	108009d8 	cmpnei	r2,r2,39
8111b6dc:	103ff91e 	bne	r2,zero,8111b6c4 <__reset+0xfb0fb6c4>
							c = cGetNextChar(siFile);
						}
						break;
8111b6e0:	0002ec06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case -1: 	//EOF
						bEOF = TRUE;
8111b6e4:	00800044 	movi	r2,1
8111b6e8:	e0bff315 	stw	r2,-52(fp)
						break;
8111b6ec:	0002e906 	br	8111c294 <vLoadDebugConfs+0xe18>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111b6f0:	d0a06217 	ldw	r2,-32376(gp)
8111b6f4:	100f883a 	mov	r7,r2
8111b6f8:	018006c4 	movi	r6,27
8111b6fc:	01400044 	movi	r5,1
8111b700:	01204574 	movhi	r4,33045
8111b704:	213fb604 	addi	r4,r4,-296
8111b708:	11230300 	call	81123030 <fwrite>
						#endif
						bEOF = TRUE;
8111b70c:	00800044 	movi	r2,1
8111b710:	e0bff315 	stw	r2,-52(fp)
						break;
8111b714:	0002df06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111b718:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b71c:	e0bff70f 	ldh	r2,-36(fp)
8111b720:	1009883a 	mov	r4,r2
8111b724:	11200400 	call	81120040 <cGetNextChar>
8111b728:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b72c:	d0e00317 	ldw	r3,-32756(gp)
8111b730:	e0bff447 	ldb	r2,-47(fp)
8111b734:	10800044 	addi	r2,r2,1
8111b738:	1885883a 	add	r2,r3,r2
8111b73c:	10800003 	ldbu	r2,0(r2)
8111b740:	10803fcc 	andi	r2,r2,255
8111b744:	1080010c 	andi	r2,r2,4
8111b748:	10000626 	beq	r2,zero,8111b764 <vLoadDebugConfs+0x2e8>
									(*p_inteiro) = c;
8111b74c:	e0bff517 	ldw	r2,-44(fp)
8111b750:	e0fff443 	ldbu	r3,-47(fp)
8111b754:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b758:	e0bff517 	ldw	r2,-44(fp)
8111b75c:	10800044 	addi	r2,r2,1
8111b760:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b764:	e0bff447 	ldb	r2,-47(fp)
8111b768:	10800ba0 	cmpeqi	r2,r2,46
8111b76c:	1000031e 	bne	r2,zero,8111b77c <vLoadDebugConfs+0x300>
8111b770:	e0bff447 	ldb	r2,-47(fp)
8111b774:	10800ed8 	cmpnei	r2,r2,59
8111b778:	103fe81e 	bne	r2,zero,8111b71c <__reset+0xfb0fb71c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b77c:	e0bff517 	ldw	r2,-44(fp)
8111b780:	00c00284 	movi	r3,10
8111b784:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
8111b788:	e0bff804 	addi	r2,fp,-32
8111b78c:	1009883a 	mov	r4,r2
8111b790:	11228380 	call	81122838 <atoi>
8111b794:	1007883a 	mov	r3,r2
8111b798:	00a045f4 	movhi	r2,33047
8111b79c:	10a00404 	addi	r2,r2,-32752
8111b7a0:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b7a4:	e0bff804 	addi	r2,fp,-32
8111b7a8:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b7ac:	e0bff403 	ldbu	r2,-48(fp)
8111b7b0:	10800044 	addi	r2,r2,1
8111b7b4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b7b8:	e0bff447 	ldb	r2,-47(fp)
8111b7bc:	10800ed8 	cmpnei	r2,r2,59
8111b7c0:	103fd61e 	bne	r2,zero,8111b71c <__reset+0xfb0fb71c>

						break;
8111b7c4:	0002b306 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'P':
						ucParser = 0;
8111b7c8:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b7cc:	e0bff70f 	ldh	r2,-36(fp)
8111b7d0:	1009883a 	mov	r4,r2
8111b7d4:	11200400 	call	81120040 <cGetNextChar>
8111b7d8:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b7dc:	d0e00317 	ldw	r3,-32756(gp)
8111b7e0:	e0bff447 	ldb	r2,-47(fp)
8111b7e4:	10800044 	addi	r2,r2,1
8111b7e8:	1885883a 	add	r2,r3,r2
8111b7ec:	10800003 	ldbu	r2,0(r2)
8111b7f0:	10803fcc 	andi	r2,r2,255
8111b7f4:	1080010c 	andi	r2,r2,4
8111b7f8:	10000626 	beq	r2,zero,8111b814 <vLoadDebugConfs+0x398>
									(*p_inteiro) = c;
8111b7fc:	e0bff517 	ldw	r2,-44(fp)
8111b800:	e0fff443 	ldbu	r3,-47(fp)
8111b804:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b808:	e0bff517 	ldw	r2,-44(fp)
8111b80c:	10800044 	addi	r2,r2,1
8111b810:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b814:	e0bff447 	ldb	r2,-47(fp)
8111b818:	10800ba0 	cmpeqi	r2,r2,46
8111b81c:	1000031e 	bne	r2,zero,8111b82c <vLoadDebugConfs+0x3b0>
8111b820:	e0bff447 	ldb	r2,-47(fp)
8111b824:	10800ed8 	cmpnei	r2,r2,59
8111b828:	103fe81e 	bne	r2,zero,8111b7cc <__reset+0xfb0fb7cc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b82c:	e0bff517 	ldw	r2,-44(fp)
8111b830:	00c00284 	movi	r3,10
8111b834:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
8111b838:	e0bff804 	addi	r2,fp,-32
8111b83c:	1009883a 	mov	r4,r2
8111b840:	11228380 	call	81122838 <atoi>
8111b844:	1007883a 	mov	r3,r2
8111b848:	00a045f4 	movhi	r2,33047
8111b84c:	10a00404 	addi	r2,r2,-32752
8111b850:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b854:	e0bff804 	addi	r2,fp,-32
8111b858:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b85c:	e0bff403 	ldbu	r2,-48(fp)
8111b860:	10800044 	addi	r2,r2,1
8111b864:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b868:	e0bff447 	ldb	r2,-47(fp)
8111b86c:	10800ed8 	cmpnei	r2,r2,59
8111b870:	103fd61e 	bne	r2,zero,8111b7cc <__reset+0xfb0fb7cc>

						break;
8111b874:	00028706 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'N':
						ucParser = 0;
8111b878:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b87c:	e0bff70f 	ldh	r2,-36(fp)
8111b880:	1009883a 	mov	r4,r2
8111b884:	11200400 	call	81120040 <cGetNextChar>
8111b888:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b88c:	d0e00317 	ldw	r3,-32756(gp)
8111b890:	e0bff447 	ldb	r2,-47(fp)
8111b894:	10800044 	addi	r2,r2,1
8111b898:	1885883a 	add	r2,r3,r2
8111b89c:	10800003 	ldbu	r2,0(r2)
8111b8a0:	10803fcc 	andi	r2,r2,255
8111b8a4:	1080010c 	andi	r2,r2,4
8111b8a8:	10000626 	beq	r2,zero,8111b8c4 <vLoadDebugConfs+0x448>
									(*p_inteiro) = c;
8111b8ac:	e0bff517 	ldw	r2,-44(fp)
8111b8b0:	e0fff443 	ldbu	r3,-47(fp)
8111b8b4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b8b8:	e0bff517 	ldw	r2,-44(fp)
8111b8bc:	10800044 	addi	r2,r2,1
8111b8c0:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b8c4:	e0bff447 	ldb	r2,-47(fp)
8111b8c8:	10800ba0 	cmpeqi	r2,r2,46
8111b8cc:	1000031e 	bne	r2,zero,8111b8dc <vLoadDebugConfs+0x460>
8111b8d0:	e0bff447 	ldb	r2,-47(fp)
8111b8d4:	10800ed8 	cmpnei	r2,r2,59
8111b8d8:	103fe81e 	bne	r2,zero,8111b87c <__reset+0xfb0fb87c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b8dc:	e0bff517 	ldw	r2,-44(fp)
8111b8e0:	00c00284 	movi	r3,10
8111b8e4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
8111b8e8:	e0bff804 	addi	r2,fp,-32
8111b8ec:	1009883a 	mov	r4,r2
8111b8f0:	11228380 	call	81122838 <atoi>
8111b8f4:	1007883a 	mov	r3,r2
8111b8f8:	00a045f4 	movhi	r2,33047
8111b8fc:	10a00404 	addi	r2,r2,-32752
8111b900:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b904:	e0bff804 	addi	r2,fp,-32
8111b908:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b90c:	e0bff403 	ldbu	r2,-48(fp)
8111b910:	10800044 	addi	r2,r2,1
8111b914:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b918:	e0bff447 	ldb	r2,-47(fp)
8111b91c:	10800ed8 	cmpnei	r2,r2,59
8111b920:	103fd61e 	bne	r2,zero,8111b87c <__reset+0xfb0fb87c>

						break;
8111b924:	00025b06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'R':
						ucParser = 0;
8111b928:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b92c:	e0bff70f 	ldh	r2,-36(fp)
8111b930:	1009883a 	mov	r4,r2
8111b934:	11200400 	call	81120040 <cGetNextChar>
8111b938:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b93c:	d0e00317 	ldw	r3,-32756(gp)
8111b940:	e0bff447 	ldb	r2,-47(fp)
8111b944:	10800044 	addi	r2,r2,1
8111b948:	1885883a 	add	r2,r3,r2
8111b94c:	10800003 	ldbu	r2,0(r2)
8111b950:	10803fcc 	andi	r2,r2,255
8111b954:	1080010c 	andi	r2,r2,4
8111b958:	10000626 	beq	r2,zero,8111b974 <vLoadDebugConfs+0x4f8>
									(*p_inteiro) = c;
8111b95c:	e0bff517 	ldw	r2,-44(fp)
8111b960:	e0fff443 	ldbu	r3,-47(fp)
8111b964:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b968:	e0bff517 	ldw	r2,-44(fp)
8111b96c:	10800044 	addi	r2,r2,1
8111b970:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b974:	e0bff447 	ldb	r2,-47(fp)
8111b978:	10800ba0 	cmpeqi	r2,r2,46
8111b97c:	1000031e 	bne	r2,zero,8111b98c <vLoadDebugConfs+0x510>
8111b980:	e0bff447 	ldb	r2,-47(fp)
8111b984:	10800ed8 	cmpnei	r2,r2,59
8111b988:	103fe81e 	bne	r2,zero,8111b92c <__reset+0xfb0fb92c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b98c:	e0bff517 	ldw	r2,-44(fp)
8111b990:	00c00284 	movi	r3,10
8111b994:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
8111b998:	e0bff804 	addi	r2,fp,-32
8111b99c:	1009883a 	mov	r4,r2
8111b9a0:	11228380 	call	81122838 <atoi>
8111b9a4:	1007883a 	mov	r3,r2
8111b9a8:	00a045f4 	movhi	r2,33047
8111b9ac:	10a00404 	addi	r2,r2,-32752
8111b9b0:	10c00c0d 	sth	r3,48(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b9b4:	e0bff804 	addi	r2,fp,-32
8111b9b8:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b9bc:	e0bff403 	ldbu	r2,-48(fp)
8111b9c0:	10800044 	addi	r2,r2,1
8111b9c4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b9c8:	e0bff447 	ldb	r2,-47(fp)
8111b9cc:	10800ed8 	cmpnei	r2,r2,59
8111b9d0:	103fd61e 	bne	r2,zero,8111b92c <__reset+0xfb0fb92c>

						break;
8111b9d4:	00022f06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'A':
						ucParser = 0;
8111b9d8:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b9dc:	e0bff70f 	ldh	r2,-36(fp)
8111b9e0:	1009883a 	mov	r4,r2
8111b9e4:	11200400 	call	81120040 <cGetNextChar>
8111b9e8:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b9ec:	d0e00317 	ldw	r3,-32756(gp)
8111b9f0:	e0bff447 	ldb	r2,-47(fp)
8111b9f4:	10800044 	addi	r2,r2,1
8111b9f8:	1885883a 	add	r2,r3,r2
8111b9fc:	10800003 	ldbu	r2,0(r2)
8111ba00:	10803fcc 	andi	r2,r2,255
8111ba04:	1080010c 	andi	r2,r2,4
8111ba08:	10000626 	beq	r2,zero,8111ba24 <vLoadDebugConfs+0x5a8>
									(*p_inteiro) = c;
8111ba0c:	e0bff517 	ldw	r2,-44(fp)
8111ba10:	e0fff443 	ldbu	r3,-47(fp)
8111ba14:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ba18:	e0bff517 	ldw	r2,-44(fp)
8111ba1c:	10800044 	addi	r2,r2,1
8111ba20:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ba24:	e0bff447 	ldb	r2,-47(fp)
8111ba28:	10800ba0 	cmpeqi	r2,r2,46
8111ba2c:	1000031e 	bne	r2,zero,8111ba3c <vLoadDebugConfs+0x5c0>
8111ba30:	e0bff447 	ldb	r2,-47(fp)
8111ba34:	10800ed8 	cmpnei	r2,r2,59
8111ba38:	103fe81e 	bne	r2,zero,8111b9dc <__reset+0xfb0fb9dc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ba3c:	e0bff517 	ldw	r2,-44(fp)
8111ba40:	00c00284 	movi	r3,10
8111ba44:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
8111ba48:	e0bff804 	addi	r2,fp,-32
8111ba4c:	1009883a 	mov	r4,r2
8111ba50:	11228380 	call	81122838 <atoi>
8111ba54:	1007883a 	mov	r3,r2
8111ba58:	00a045f4 	movhi	r2,33047
8111ba5c:	10a00404 	addi	r2,r2,-32752
8111ba60:	10c00c8d 	sth	r3,50(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ba64:	e0bff804 	addi	r2,fp,-32
8111ba68:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111ba6c:	e0bff403 	ldbu	r2,-48(fp)
8111ba70:	10800044 	addi	r2,r2,1
8111ba74:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111ba78:	e0bff447 	ldb	r2,-47(fp)
8111ba7c:	10800ed8 	cmpnei	r2,r2,59
8111ba80:	103fd61e 	bne	r2,zero,8111b9dc <__reset+0xfb0fb9dc>

						break;
8111ba84:	00020306 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'L':
						ucParser = 0;
8111ba88:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ba8c:	e0bff70f 	ldh	r2,-36(fp)
8111ba90:	1009883a 	mov	r4,r2
8111ba94:	11200400 	call	81120040 <cGetNextChar>
8111ba98:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111ba9c:	d0e00317 	ldw	r3,-32756(gp)
8111baa0:	e0bff447 	ldb	r2,-47(fp)
8111baa4:	10800044 	addi	r2,r2,1
8111baa8:	1885883a 	add	r2,r3,r2
8111baac:	10800003 	ldbu	r2,0(r2)
8111bab0:	10803fcc 	andi	r2,r2,255
8111bab4:	1080010c 	andi	r2,r2,4
8111bab8:	10000626 	beq	r2,zero,8111bad4 <vLoadDebugConfs+0x658>
									(*p_inteiro) = c;
8111babc:	e0bff517 	ldw	r2,-44(fp)
8111bac0:	e0fff443 	ldbu	r3,-47(fp)
8111bac4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bac8:	e0bff517 	ldw	r2,-44(fp)
8111bacc:	10800044 	addi	r2,r2,1
8111bad0:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bad4:	e0bff447 	ldb	r2,-47(fp)
8111bad8:	10800ba0 	cmpeqi	r2,r2,46
8111badc:	1000031e 	bne	r2,zero,8111baec <vLoadDebugConfs+0x670>
8111bae0:	e0bff447 	ldb	r2,-47(fp)
8111bae4:	10800ed8 	cmpnei	r2,r2,59
8111bae8:	103fe81e 	bne	r2,zero,8111ba8c <__reset+0xfb0fba8c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111baec:	e0bff517 	ldw	r2,-44(fp)
8111baf0:	00c00284 	movi	r3,10
8111baf4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
8111baf8:	e0bff804 	addi	r2,fp,-32
8111bafc:	1009883a 	mov	r4,r2
8111bb00:	11228380 	call	81122838 <atoi>
8111bb04:	1007883a 	mov	r3,r2
8111bb08:	00a045f4 	movhi	r2,33047
8111bb0c:	10a00404 	addi	r2,r2,-32752
8111bb10:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bb14:	e0bff804 	addi	r2,fp,-32
8111bb18:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111bb1c:	e0bff403 	ldbu	r2,-48(fp)
8111bb20:	10800044 	addi	r2,r2,1
8111bb24:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111bb28:	e0bff447 	ldb	r2,-47(fp)
8111bb2c:	10800ed8 	cmpnei	r2,r2,59
8111bb30:	103fd61e 	bne	r2,zero,8111ba8c <__reset+0xfb0fba8c>

						break;
8111bb34:	0001d706 	br	8111c294 <vLoadDebugConfs+0xe18>

					case 'O':
						ucParser = 0;
8111bb38:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111bb3c:	e0bff70f 	ldh	r2,-36(fp)
8111bb40:	1009883a 	mov	r4,r2
8111bb44:	11200400 	call	81120040 <cGetNextChar>
8111bb48:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111bb4c:	d0e00317 	ldw	r3,-32756(gp)
8111bb50:	e0bff447 	ldb	r2,-47(fp)
8111bb54:	10800044 	addi	r2,r2,1
8111bb58:	1885883a 	add	r2,r3,r2
8111bb5c:	10800003 	ldbu	r2,0(r2)
8111bb60:	10803fcc 	andi	r2,r2,255
8111bb64:	1080010c 	andi	r2,r2,4
8111bb68:	10000626 	beq	r2,zero,8111bb84 <vLoadDebugConfs+0x708>
									(*p_inteiro) = c;
8111bb6c:	e0bff517 	ldw	r2,-44(fp)
8111bb70:	e0fff443 	ldbu	r3,-47(fp)
8111bb74:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bb78:	e0bff517 	ldw	r2,-44(fp)
8111bb7c:	10800044 	addi	r2,r2,1
8111bb80:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bb84:	e0bff447 	ldb	r2,-47(fp)
8111bb88:	10800ba0 	cmpeqi	r2,r2,46
8111bb8c:	1000031e 	bne	r2,zero,8111bb9c <vLoadDebugConfs+0x720>
8111bb90:	e0bff447 	ldb	r2,-47(fp)
8111bb94:	10800ed8 	cmpnei	r2,r2,59
8111bb98:	103fe81e 	bne	r2,zero,8111bb3c <__reset+0xfb0fbb3c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bb9c:	e0bff517 	ldw	r2,-44(fp)
8111bba0:	00c00284 	movi	r3,10
8111bba4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
8111bba8:	e0bff804 	addi	r2,fp,-32
8111bbac:	1009883a 	mov	r4,r2
8111bbb0:	11228380 	call	81122838 <atoi>
8111bbb4:	1007883a 	mov	r3,r2
8111bbb8:	00a045f4 	movhi	r2,33047
8111bbbc:	10a00404 	addi	r2,r2,-32752
8111bbc0:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bbc4:	e0bff804 	addi	r2,fp,-32
8111bbc8:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111bbcc:	e0bff403 	ldbu	r2,-48(fp)
8111bbd0:	10800044 	addi	r2,r2,1
8111bbd4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111bbd8:	e0bff447 	ldb	r2,-47(fp)
8111bbdc:	10800ed8 	cmpnei	r2,r2,59
8111bbe0:	103fd61e 	bne	r2,zero,8111bb3c <__reset+0xfb0fbb3c>

						break;
8111bbe4:	0001ab06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'C':
						ucParser = 0;
8111bbe8:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111bbec:	e0bff70f 	ldh	r2,-36(fp)
8111bbf0:	1009883a 	mov	r4,r2
8111bbf4:	11200400 	call	81120040 <cGetNextChar>
8111bbf8:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111bbfc:	d0e00317 	ldw	r3,-32756(gp)
8111bc00:	e0bff447 	ldb	r2,-47(fp)
8111bc04:	10800044 	addi	r2,r2,1
8111bc08:	1885883a 	add	r2,r3,r2
8111bc0c:	10800003 	ldbu	r2,0(r2)
8111bc10:	10803fcc 	andi	r2,r2,255
8111bc14:	1080010c 	andi	r2,r2,4
8111bc18:	10000626 	beq	r2,zero,8111bc34 <vLoadDebugConfs+0x7b8>
									(*p_inteiro) = c;
8111bc1c:	e0bff517 	ldw	r2,-44(fp)
8111bc20:	e0fff443 	ldbu	r3,-47(fp)
8111bc24:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bc28:	e0bff517 	ldw	r2,-44(fp)
8111bc2c:	10800044 	addi	r2,r2,1
8111bc30:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bc34:	e0bff447 	ldb	r2,-47(fp)
8111bc38:	10800ba0 	cmpeqi	r2,r2,46
8111bc3c:	1000031e 	bne	r2,zero,8111bc4c <vLoadDebugConfs+0x7d0>
8111bc40:	e0bff447 	ldb	r2,-47(fp)
8111bc44:	10800ed8 	cmpnei	r2,r2,59
8111bc48:	103fe81e 	bne	r2,zero,8111bbec <__reset+0xfb0fbbec>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bc4c:	e0bff517 	ldw	r2,-44(fp)
8111bc50:	00c00284 	movi	r3,10
8111bc54:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
8111bc58:	e0bff804 	addi	r2,fp,-32
8111bc5c:	1009883a 	mov	r4,r2
8111bc60:	11228380 	call	81122838 <atoi>
8111bc64:	1007883a 	mov	r3,r2
8111bc68:	00a045f4 	movhi	r2,33047
8111bc6c:	10a00404 	addi	r2,r2,-32752
8111bc70:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bc74:	e0bff804 	addi	r2,fp,-32
8111bc78:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111bc7c:	e0bff403 	ldbu	r2,-48(fp)
8111bc80:	10800044 	addi	r2,r2,1
8111bc84:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111bc88:	e0bff447 	ldb	r2,-47(fp)
8111bc8c:	10800ed8 	cmpnei	r2,r2,59
8111bc90:	103fd61e 	bne	r2,zero,8111bbec <__reset+0xfb0fbbec>

						break;
8111bc94:	00017f06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111bc98:	e0bff70f 	ldh	r2,-36(fp)
8111bc9c:	1009883a 	mov	r4,r2
8111bca0:	11200400 	call	81120040 <cGetNextChar>
8111bca4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bca8:	d0e00317 	ldw	r3,-32756(gp)
8111bcac:	e0bff447 	ldb	r2,-47(fp)
8111bcb0:	10800044 	addi	r2,r2,1
8111bcb4:	1885883a 	add	r2,r3,r2
8111bcb8:	10800003 	ldbu	r2,0(r2)
8111bcbc:	10803fcc 	andi	r2,r2,255
8111bcc0:	1080010c 	andi	r2,r2,4
8111bcc4:	10000626 	beq	r2,zero,8111bce0 <vLoadDebugConfs+0x864>
								(*p_inteiro) = c;
8111bcc8:	e0bff517 	ldw	r2,-44(fp)
8111bccc:	e0fff443 	ldbu	r3,-47(fp)
8111bcd0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bcd4:	e0bff517 	ldw	r2,-44(fp)
8111bcd8:	10800044 	addi	r2,r2,1
8111bcdc:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bce0:	e0bff447 	ldb	r2,-47(fp)
8111bce4:	10800ed8 	cmpnei	r2,r2,59
8111bce8:	103feb1e 	bne	r2,zero,8111bc98 <__reset+0xfb0fbc98>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bcec:	e0bff517 	ldw	r2,-44(fp)
8111bcf0:	00c00284 	movi	r3,10
8111bcf4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
8111bcf8:	e0bff804 	addi	r2,fp,-32
8111bcfc:	1009883a 	mov	r4,r2
8111bd00:	11228380 	call	81122838 <atoi>
8111bd04:	1007883a 	mov	r3,r2
8111bd08:	00a045f4 	movhi	r2,33047
8111bd0c:	10a00404 	addi	r2,r2,-32752
8111bd10:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bd14:	e0bff804 	addi	r2,fp,-32
8111bd18:	e0bff515 	stw	r2,-44(fp)

						break;
8111bd1c:	00015d06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111bd20:	e0bff70f 	ldh	r2,-36(fp)
8111bd24:	1009883a 	mov	r4,r2
8111bd28:	11200400 	call	81120040 <cGetNextChar>
8111bd2c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bd30:	d0e00317 	ldw	r3,-32756(gp)
8111bd34:	e0bff447 	ldb	r2,-47(fp)
8111bd38:	10800044 	addi	r2,r2,1
8111bd3c:	1885883a 	add	r2,r3,r2
8111bd40:	10800003 	ldbu	r2,0(r2)
8111bd44:	10803fcc 	andi	r2,r2,255
8111bd48:	1080010c 	andi	r2,r2,4
8111bd4c:	10000626 	beq	r2,zero,8111bd68 <vLoadDebugConfs+0x8ec>
								(*p_inteiro) = c;
8111bd50:	e0bff517 	ldw	r2,-44(fp)
8111bd54:	e0fff443 	ldbu	r3,-47(fp)
8111bd58:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bd5c:	e0bff517 	ldw	r2,-44(fp)
8111bd60:	10800044 	addi	r2,r2,1
8111bd64:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bd68:	e0bff447 	ldb	r2,-47(fp)
8111bd6c:	10800ed8 	cmpnei	r2,r2,59
8111bd70:	103feb1e 	bne	r2,zero,8111bd20 <__reset+0xfb0fbd20>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bd74:	e0bff517 	ldw	r2,-44(fp)
8111bd78:	00c00284 	movi	r3,10
8111bd7c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
8111bd80:	e0bff804 	addi	r2,fp,-32
8111bd84:	1009883a 	mov	r4,r2
8111bd88:	11228380 	call	81122838 <atoi>
8111bd8c:	1007883a 	mov	r3,r2
8111bd90:	00a045f4 	movhi	r2,33047
8111bd94:	10a00404 	addi	r2,r2,-32752
8111bd98:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bd9c:	e0bff804 	addi	r2,fp,-32
8111bda0:	e0bff515 	stw	r2,-44(fp)

						break;
8111bda4:	00013b06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111bda8:	e0bff70f 	ldh	r2,-36(fp)
8111bdac:	1009883a 	mov	r4,r2
8111bdb0:	11200400 	call	81120040 <cGetNextChar>
8111bdb4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bdb8:	d0e00317 	ldw	r3,-32756(gp)
8111bdbc:	e0bff447 	ldb	r2,-47(fp)
8111bdc0:	10800044 	addi	r2,r2,1
8111bdc4:	1885883a 	add	r2,r3,r2
8111bdc8:	10800003 	ldbu	r2,0(r2)
8111bdcc:	10803fcc 	andi	r2,r2,255
8111bdd0:	1080010c 	andi	r2,r2,4
8111bdd4:	10000626 	beq	r2,zero,8111bdf0 <vLoadDebugConfs+0x974>
								(*p_inteiro) = c;
8111bdd8:	e0bff517 	ldw	r2,-44(fp)
8111bddc:	e0fff443 	ldbu	r3,-47(fp)
8111bde0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bde4:	e0bff517 	ldw	r2,-44(fp)
8111bde8:	10800044 	addi	r2,r2,1
8111bdec:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bdf0:	e0bff447 	ldb	r2,-47(fp)
8111bdf4:	10800ed8 	cmpnei	r2,r2,59
8111bdf8:	103feb1e 	bne	r2,zero,8111bda8 <__reset+0xfb0fbda8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bdfc:	e0bff517 	ldw	r2,-44(fp)
8111be00:	00c00284 	movi	r3,10
8111be04:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
8111be08:	e0bff804 	addi	r2,fp,-32
8111be0c:	1009883a 	mov	r4,r2
8111be10:	11228380 	call	81122838 <atoi>
8111be14:	1007883a 	mov	r3,r2
8111be18:	00a045f4 	movhi	r2,33047
8111be1c:	10a00404 	addi	r2,r2,-32752
8111be20:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111be24:	e0bff804 	addi	r2,fp,-32
8111be28:	e0bff515 	stw	r2,-44(fp)

						break;
8111be2c:	00011906 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111be30:	e0bff70f 	ldh	r2,-36(fp)
8111be34:	1009883a 	mov	r4,r2
8111be38:	11200400 	call	81120040 <cGetNextChar>
8111be3c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111be40:	d0e00317 	ldw	r3,-32756(gp)
8111be44:	e0bff447 	ldb	r2,-47(fp)
8111be48:	10800044 	addi	r2,r2,1
8111be4c:	1885883a 	add	r2,r3,r2
8111be50:	10800003 	ldbu	r2,0(r2)
8111be54:	10803fcc 	andi	r2,r2,255
8111be58:	1080010c 	andi	r2,r2,4
8111be5c:	10000626 	beq	r2,zero,8111be78 <vLoadDebugConfs+0x9fc>
								(*p_inteiro) = c;
8111be60:	e0bff517 	ldw	r2,-44(fp)
8111be64:	e0fff443 	ldbu	r3,-47(fp)
8111be68:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111be6c:	e0bff517 	ldw	r2,-44(fp)
8111be70:	10800044 	addi	r2,r2,1
8111be74:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111be78:	e0bff447 	ldb	r2,-47(fp)
8111be7c:	10800ed8 	cmpnei	r2,r2,59
8111be80:	103feb1e 	bne	r2,zero,8111be30 <__reset+0xfb0fbe30>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111be84:	e0bff517 	ldw	r2,-44(fp)
8111be88:	00c00284 	movi	r3,10
8111be8c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111be90:	e0bff804 	addi	r2,fp,-32
8111be94:	1009883a 	mov	r4,r2
8111be98:	11228380 	call	81122838 <atoi>
8111be9c:	1007883a 	mov	r3,r2
8111bea0:	00a045f4 	movhi	r2,33047
8111bea4:	10a00404 	addi	r2,r2,-32752
8111bea8:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111beac:	e0bff804 	addi	r2,fp,-32
8111beb0:	e0bff515 	stw	r2,-44(fp)

						break;
8111beb4:	0000f706 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8111beb8:	e0bff70f 	ldh	r2,-36(fp)
8111bebc:	1009883a 	mov	r4,r2
8111bec0:	11200400 	call	81120040 <cGetNextChar>
8111bec4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bec8:	d0e00317 	ldw	r3,-32756(gp)
8111becc:	e0bff447 	ldb	r2,-47(fp)
8111bed0:	10800044 	addi	r2,r2,1
8111bed4:	1885883a 	add	r2,r3,r2
8111bed8:	10800003 	ldbu	r2,0(r2)
8111bedc:	10803fcc 	andi	r2,r2,255
8111bee0:	1080010c 	andi	r2,r2,4
8111bee4:	10000626 	beq	r2,zero,8111bf00 <vLoadDebugConfs+0xa84>
								(*p_inteiro) = c;
8111bee8:	e0bff517 	ldw	r2,-44(fp)
8111beec:	e0fff443 	ldbu	r3,-47(fp)
8111bef0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bef4:	e0bff517 	ldw	r2,-44(fp)
8111bef8:	10800044 	addi	r2,r2,1
8111befc:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bf00:	e0bff447 	ldb	r2,-47(fp)
8111bf04:	10800ed8 	cmpnei	r2,r2,59
8111bf08:	103feb1e 	bne	r2,zero,8111beb8 <__reset+0xfb0fbeb8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bf0c:	e0bff517 	ldw	r2,-44(fp)
8111bf10:	00c00284 	movi	r3,10
8111bf14:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = atoi( inteiro );
8111bf18:	e0bff804 	addi	r2,fp,-32
8111bf1c:	1009883a 	mov	r4,r2
8111bf20:	11228380 	call	81122838 <atoi>
8111bf24:	1007883a 	mov	r3,r2
8111bf28:	00a045f4 	movhi	r2,33047
8111bf2c:	10a00404 	addi	r2,r2,-32752
8111bf30:	10c00e0d 	sth	r3,56(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bf34:	e0bff804 	addi	r2,fp,-32
8111bf38:	e0bff515 	stw	r2,-44(fp)

						break;
8111bf3c:	0000d506 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'F':

						do {
							c = cGetNextChar(siFile);
8111bf40:	e0bff70f 	ldh	r2,-36(fp)
8111bf44:	1009883a 	mov	r4,r2
8111bf48:	11200400 	call	81120040 <cGetNextChar>
8111bf4c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bf50:	d0e00317 	ldw	r3,-32756(gp)
8111bf54:	e0bff447 	ldb	r2,-47(fp)
8111bf58:	10800044 	addi	r2,r2,1
8111bf5c:	1885883a 	add	r2,r3,r2
8111bf60:	10800003 	ldbu	r2,0(r2)
8111bf64:	10803fcc 	andi	r2,r2,255
8111bf68:	1080010c 	andi	r2,r2,4
8111bf6c:	10000626 	beq	r2,zero,8111bf88 <vLoadDebugConfs+0xb0c>
								(*p_inteiro) = c;
8111bf70:	e0bff517 	ldw	r2,-44(fp)
8111bf74:	e0fff443 	ldbu	r3,-47(fp)
8111bf78:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bf7c:	e0bff517 	ldw	r2,-44(fp)
8111bf80:	10800044 	addi	r2,r2,1
8111bf84:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bf88:	e0bff447 	ldb	r2,-47(fp)
8111bf8c:	10800ed8 	cmpnei	r2,r2,59
8111bf90:	103feb1e 	bne	r2,zero,8111bf40 <__reset+0xfb0fbf40>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bf94:	e0bff517 	ldw	r2,-44(fp)
8111bf98:	00c00284 	movi	r3,10
8111bf9c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDebugLevel = atoi( inteiro );
8111bfa0:	e0bff804 	addi	r2,fp,-32
8111bfa4:	1009883a 	mov	r4,r2
8111bfa8:	11228380 	call	81122838 <atoi>
8111bfac:	1007883a 	mov	r3,r2
8111bfb0:	00a045f4 	movhi	r2,33047
8111bfb4:	10a00404 	addi	r2,r2,-32752
8111bfb8:	10c00e8d 	sth	r3,58(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bfbc:	e0bff804 	addi	r2,fp,-32
8111bfc0:	e0bff515 	stw	r2,-44(fp)

						break;
8111bfc4:	0000b306 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'Q':

						do {
							c = cGetNextChar(siFile);
8111bfc8:	e0bff70f 	ldh	r2,-36(fp)
8111bfcc:	1009883a 	mov	r4,r2
8111bfd0:	11200400 	call	81120040 <cGetNextChar>
8111bfd4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bfd8:	d0e00317 	ldw	r3,-32756(gp)
8111bfdc:	e0bff447 	ldb	r2,-47(fp)
8111bfe0:	10800044 	addi	r2,r2,1
8111bfe4:	1885883a 	add	r2,r3,r2
8111bfe8:	10800003 	ldbu	r2,0(r2)
8111bfec:	10803fcc 	andi	r2,r2,255
8111bff0:	1080010c 	andi	r2,r2,4
8111bff4:	10000626 	beq	r2,zero,8111c010 <vLoadDebugConfs+0xb94>
								(*p_inteiro) = c;
8111bff8:	e0bff517 	ldw	r2,-44(fp)
8111bffc:	e0fff443 	ldbu	r3,-47(fp)
8111c000:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c004:	e0bff517 	ldw	r2,-44(fp)
8111c008:	10800044 	addi	r2,r2,1
8111c00c:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c010:	e0bff447 	ldb	r2,-47(fp)
8111c014:	10800ed8 	cmpnei	r2,r2,59
8111c018:	103feb1e 	bne	r2,zero,8111bfc8 <__reset+0xfb0fbfc8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c01c:	e0bff517 	ldw	r2,-44(fp)
8111c020:	00c00284 	movi	r3,10
8111c024:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiPatternType = atoi( inteiro );
8111c028:	e0bff804 	addi	r2,fp,-32
8111c02c:	1009883a 	mov	r4,r2
8111c030:	11228380 	call	81122838 <atoi>
8111c034:	1007883a 	mov	r3,r2
8111c038:	00a045f4 	movhi	r2,33047
8111c03c:	10a00404 	addi	r2,r2,-32752
8111c040:	10c00f0d 	sth	r3,60(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c044:	e0bff804 	addi	r2,fp,-32
8111c048:	e0bff515 	stw	r2,-44(fp)

						break;
8111c04c:	00009106 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'Y':

						do {
							c = cGetNextChar(siFile);
8111c050:	e0bff70f 	ldh	r2,-36(fp)
8111c054:	1009883a 	mov	r4,r2
8111c058:	11200400 	call	81120040 <cGetNextChar>
8111c05c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111c060:	d0e00317 	ldw	r3,-32756(gp)
8111c064:	e0bff447 	ldb	r2,-47(fp)
8111c068:	10800044 	addi	r2,r2,1
8111c06c:	1885883a 	add	r2,r3,r2
8111c070:	10800003 	ldbu	r2,0(r2)
8111c074:	10803fcc 	andi	r2,r2,255
8111c078:	1080010c 	andi	r2,r2,4
8111c07c:	10000626 	beq	r2,zero,8111c098 <vLoadDebugConfs+0xc1c>
								(*p_inteiro) = c;
8111c080:	e0bff517 	ldw	r2,-44(fp)
8111c084:	e0fff443 	ldbu	r3,-47(fp)
8111c088:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c08c:	e0bff517 	ldw	r2,-44(fp)
8111c090:	10800044 	addi	r2,r2,1
8111c094:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c098:	e0bff447 	ldb	r2,-47(fp)
8111c09c:	10800ed8 	cmpnei	r2,r2,59
8111c0a0:	103feb1e 	bne	r2,zero,8111c050 <__reset+0xfb0fc050>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c0a4:	e0bff517 	ldw	r2,-44(fp)
8111c0a8:	00c00284 	movi	r3,10
8111c0ac:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiGuardNFEEDelay = atoi( inteiro );
8111c0b0:	e0bff804 	addi	r2,fp,-32
8111c0b4:	1009883a 	mov	r4,r2
8111c0b8:	11228380 	call	81122838 <atoi>
8111c0bc:	1007883a 	mov	r3,r2
8111c0c0:	00a045f4 	movhi	r2,33047
8111c0c4:	10a00404 	addi	r2,r2,-32752
8111c0c8:	10c00f8d 	sth	r3,62(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c0cc:	e0bff804 	addi	r2,fp,-32
8111c0d0:	e0bff515 	stw	r2,-44(fp)

						break;
8111c0d4:	00006f06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111c0d8:	e0bff70f 	ldh	r2,-36(fp)
8111c0dc:	1009883a 	mov	r4,r2
8111c0e0:	11200400 	call	81120040 <cGetNextChar>
8111c0e4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111c0e8:	d0e00317 	ldw	r3,-32756(gp)
8111c0ec:	e0bff447 	ldb	r2,-47(fp)
8111c0f0:	10800044 	addi	r2,r2,1
8111c0f4:	1885883a 	add	r2,r3,r2
8111c0f8:	10800003 	ldbu	r2,0(r2)
8111c0fc:	10803fcc 	andi	r2,r2,255
8111c100:	1080010c 	andi	r2,r2,4
8111c104:	10000626 	beq	r2,zero,8111c120 <vLoadDebugConfs+0xca4>
								(*p_inteiro) = c;
8111c108:	e0bff517 	ldw	r2,-44(fp)
8111c10c:	e0fff443 	ldbu	r3,-47(fp)
8111c110:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c114:	e0bff517 	ldw	r2,-44(fp)
8111c118:	10800044 	addi	r2,r2,1
8111c11c:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c120:	e0bff447 	ldb	r2,-47(fp)
8111c124:	10800ed8 	cmpnei	r2,r2,59
8111c128:	103feb1e 	bne	r2,zero,8111c0d8 <__reset+0xfb0fc0d8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c12c:	e0bff517 	ldw	r2,-44(fp)
8111c130:	00c00284 	movi	r3,10
8111c134:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111c138:	e0bff804 	addi	r2,fp,-32
8111c13c:	1009883a 	mov	r4,r2
8111c140:	11228380 	call	81122838 <atoi>
8111c144:	e0bff78d 	sth	r2,-34(fp)
						if (sidhcpTemp == 1)
8111c148:	e0bff78f 	ldh	r2,-34(fp)
8111c14c:	10800058 	cmpnei	r2,r2,1
8111c150:	1000051e 	bne	r2,zero,8111c168 <vLoadDebugConfs+0xcec>
							xDefaults.bDataPacket = TRUE;
8111c154:	00a045f4 	movhi	r2,33047
8111c158:	10a00404 	addi	r2,r2,-32752
8111c15c:	00c00044 	movi	r3,1
8111c160:	10c00815 	stw	r3,32(r2)
8111c164:	00000306 	br	8111c174 <vLoadDebugConfs+0xcf8>
						else
							xDefaults.bDataPacket = FALSE;
8111c168:	00a045f4 	movhi	r2,33047
8111c16c:	10a00404 	addi	r2,r2,-32752
8111c170:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c174:	e0bff804 	addi	r2,fp,-32
8111c178:	e0bff515 	stw	r2,-44(fp)

						break;
8111c17c:	00004506 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8111c180:	e0bff70f 	ldh	r2,-36(fp)
8111c184:	1009883a 	mov	r4,r2
8111c188:	11200400 	call	81120040 <cGetNextChar>
8111c18c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111c190:	d0e00317 	ldw	r3,-32756(gp)
8111c194:	e0bff447 	ldb	r2,-47(fp)
8111c198:	10800044 	addi	r2,r2,1
8111c19c:	1885883a 	add	r2,r3,r2
8111c1a0:	10800003 	ldbu	r2,0(r2)
8111c1a4:	10803fcc 	andi	r2,r2,255
8111c1a8:	1080010c 	andi	r2,r2,4
8111c1ac:	10000626 	beq	r2,zero,8111c1c8 <vLoadDebugConfs+0xd4c>
								(*p_inteiro) = c;
8111c1b0:	e0bff517 	ldw	r2,-44(fp)
8111c1b4:	e0fff443 	ldbu	r3,-47(fp)
8111c1b8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c1bc:	e0bff517 	ldw	r2,-44(fp)
8111c1c0:	10800044 	addi	r2,r2,1
8111c1c4:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c1c8:	e0bff447 	ldb	r2,-47(fp)
8111c1cc:	10800ed8 	cmpnei	r2,r2,59
8111c1d0:	103feb1e 	bne	r2,zero,8111c180 <__reset+0xfb0fc180>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c1d4:	e0bff517 	ldw	r2,-44(fp)
8111c1d8:	00c00284 	movi	r3,10
8111c1dc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111c1e0:	e0bff804 	addi	r2,fp,-32
8111c1e4:	1009883a 	mov	r4,r2
8111c1e8:	11228380 	call	81122838 <atoi>
8111c1ec:	e0bff78d 	sth	r2,-34(fp)
						if (sidhcpTemp == 1)
8111c1f0:	e0bff78f 	ldh	r2,-34(fp)
8111c1f4:	10800058 	cmpnei	r2,r2,1
8111c1f8:	1000051e 	bne	r2,zero,8111c210 <vLoadDebugConfs+0xd94>
							xDefaults.bOneShot = TRUE;
8111c1fc:	00a045f4 	movhi	r2,33047
8111c200:	10a00404 	addi	r2,r2,-32752
8111c204:	00c00044 	movi	r3,1
8111c208:	10c00d15 	stw	r3,52(r2)
8111c20c:	00000306 	br	8111c21c <vLoadDebugConfs+0xda0>
						else
							xDefaults.bOneShot = FALSE;
8111c210:	00a045f4 	movhi	r2,33047
8111c214:	10a00404 	addi	r2,r2,-32752
8111c218:	10000d15 	stw	zero,52(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c21c:	e0bff804 	addi	r2,fp,-32
8111c220:	e0bff515 	stw	r2,-44(fp)

						break;
8111c224:	00001b06 	br	8111c294 <vLoadDebugConfs+0xe18>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111c228:	e0bff70f 	ldh	r2,-36(fp)
8111c22c:	1009883a 	mov	r4,r2
8111c230:	11200000 	call	81120000 <siCloseFile>
8111c234:	e0bff615 	stw	r2,-40(fp)
						if (close == FALSE){
8111c238:	e0bff617 	ldw	r2,-40(fp)
8111c23c:	1000071e 	bne	r2,zero,8111c25c <vLoadDebugConfs+0xde0>
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111c240:	d0a06217 	ldw	r2,-32376(gp)
8111c244:	100f883a 	mov	r7,r2
8111c248:	01800784 	movi	r6,30
8111c24c:	01400044 	movi	r5,1
8111c250:	01204574 	movhi	r4,33045
8111c254:	213fbd04 	addi	r4,r4,-268
8111c258:	11230300 	call	81123030 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111c25c:	00800044 	movi	r2,1
8111c260:	e0bff315 	stw	r2,-52(fp)
						bSuccess = TRUE; //pensar melhor
8111c264:	00800044 	movi	r2,1
8111c268:	e0bff215 	stw	r2,-56(fp)
						break;
8111c26c:	00000906 	br	8111c294 <vLoadDebugConfs+0xe18>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111c270:	d0a06217 	ldw	r2,-32376(gp)
8111c274:	100f883a 	mov	r7,r2
8111c278:	01800844 	movi	r6,33
8111c27c:	01400044 	movi	r5,1
8111c280:	01204574 	movhi	r4,33045
8111c284:	213fc504 	addi	r4,r4,-236
8111c288:	11230300 	call	81123030 <fwrite>
						#endif
						break;
8111c28c:	00000106 	br	8111c294 <vLoadDebugConfs+0xe18>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111c290:	0001883a 	nop
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111c294:	e0bff317 	ldw	r2,-52(fp)
8111c298:	103c9a26 	beq	r2,zero,8111b504 <__reset+0xfb0fb504>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111c29c:	00000f06 	br	8111c2dc <vLoadDebugConfs+0xe60>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111c2a0:	d0a06217 	ldw	r2,-32376(gp)
8111c2a4:	100f883a 	mov	r7,r2
8111c2a8:	01800604 	movi	r6,24
8111c2ac:	01400044 	movi	r5,1
8111c2b0:	01204574 	movhi	r4,33045
8111c2b4:	213fce04 	addi	r4,r4,-200
8111c2b8:	11230300 	call	81123030 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111c2bc:	00000706 	br	8111c2dc <vLoadDebugConfs+0xe60>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#if DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111c2c0:	d0a06217 	ldw	r2,-32376(gp)
8111c2c4:	100f883a 	mov	r7,r2
8111c2c8:	018004c4 	movi	r6,19
8111c2cc:	01400044 	movi	r5,1
8111c2d0:	01204574 	movhi	r4,33045
8111c2d4:	213fd504 	addi	r4,r4,-172
8111c2d8:	11230300 	call	81123030 <fwrite>
	if ( bSuccess == FALSE ) {
		/* Load default? */

	}

	return bSuccess;
8111c2dc:	e0bff217 	ldw	r2,-56(fp)
}
8111c2e0:	e037883a 	mov	sp,fp
8111c2e4:	dfc00117 	ldw	ra,4(sp)
8111c2e8:	df000017 	ldw	fp,0(sp)
8111c2ec:	dec00204 	addi	sp,sp,8
8111c2f0:	f800283a 	ret

8111c2f4 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111c2f4:	defffb04 	addi	sp,sp,-20
8111c2f8:	de00012e 	bgeu	sp,et,8111c300 <ucCrc8+0xc>
8111c2fc:	003b68fa 	trap	3
8111c300:	df000415 	stw	fp,16(sp)
8111c304:	df000404 	addi	fp,sp,16
8111c308:	e13ffd15 	stw	r4,-12(fp)
8111c30c:	e17ffe15 	stw	r5,-8(fp)
8111c310:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111c314:	e0bffe17 	ldw	r2,-8(fp)
8111c318:	1000021e 	bne	r2,zero,8111c324 <ucCrc8+0x30>
        return 0;
8111c31c:	0005883a 	mov	r2,zero
8111c320:	00001906 	br	8111c388 <ucCrc8+0x94>
    crc &= 0xff;
8111c324:	e0bffd17 	ldw	r2,-12(fp)
8111c328:	10803fcc 	andi	r2,r2,255
8111c32c:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111c330:	e0fffe17 	ldw	r3,-8(fp)
8111c334:	e0bfff17 	ldw	r2,-4(fp)
8111c338:	1885883a 	add	r2,r3,r2
8111c33c:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111c340:	00000d06 	br	8111c378 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111c344:	e0bffe17 	ldw	r2,-8(fp)
8111c348:	10c00044 	addi	r3,r2,1
8111c34c:	e0fffe15 	stw	r3,-8(fp)
8111c350:	10800003 	ldbu	r2,0(r2)
8111c354:	10c03fcc 	andi	r3,r2,255
8111c358:	e0bffd17 	ldw	r2,-12(fp)
8111c35c:	1886f03a 	xor	r3,r3,r2
8111c360:	00a04574 	movhi	r2,33045
8111c364:	10800c84 	addi	r2,r2,50
8111c368:	10c5883a 	add	r2,r2,r3
8111c36c:	10800003 	ldbu	r2,0(r2)
8111c370:	10803fcc 	andi	r2,r2,255
8111c374:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111c378:	e0fffe17 	ldw	r3,-8(fp)
8111c37c:	e0bffc17 	ldw	r2,-16(fp)
8111c380:	18bff036 	bltu	r3,r2,8111c344 <__reset+0xfb0fc344>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111c384:	e0bffd17 	ldw	r2,-12(fp)
}
8111c388:	e037883a 	mov	sp,fp
8111c38c:	df000017 	ldw	fp,0(sp)
8111c390:	dec00104 	addi	sp,sp,4
8111c394:	f800283a 	ret

8111c398 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111c398:	defffb04 	addi	sp,sp,-20
8111c39c:	de00012e 	bgeu	sp,et,8111c3a4 <ucCrc8wInit+0xc>
8111c3a0:	003b68fa 	trap	3
8111c3a4:	dfc00415 	stw	ra,16(sp)
8111c3a8:	df000315 	stw	fp,12(sp)
8111c3ac:	df000304 	addi	fp,sp,12
8111c3b0:	e13ffe15 	stw	r4,-8(fp)
8111c3b4:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111c3b8:	000d883a 	mov	r6,zero
8111c3bc:	000b883a 	mov	r5,zero
8111c3c0:	0009883a 	mov	r4,zero
8111c3c4:	111c2f40 	call	8111c2f4 <ucCrc8>
8111c3c8:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111c3cc:	e0bffd03 	ldbu	r2,-12(fp)
8111c3d0:	e1bfff17 	ldw	r6,-4(fp)
8111c3d4:	e17ffe17 	ldw	r5,-8(fp)
8111c3d8:	1009883a 	mov	r4,r2
8111c3dc:	111c2f40 	call	8111c2f4 <ucCrc8>
}
8111c3e0:	e037883a 	mov	sp,fp
8111c3e4:	dfc00117 	ldw	ra,4(sp)
8111c3e8:	df000017 	ldw	fp,0(sp)
8111c3ec:	dec00204 	addi	sp,sp,8
8111c3f0:	f800283a 	ret

8111c3f4 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111c3f4:	defffc04 	addi	sp,sp,-16
8111c3f8:	de00012e 	bgeu	sp,et,8111c400 <vDataControllerInit+0xc>
8111c3fc:	003b68fa 	trap	3
8111c400:	df000315 	stw	fp,12(sp)
8111c404:	df000304 	addi	fp,sp,12
8111c408:	e13ffe15 	stw	r4,-8(fp)
8111c40c:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111c410:	e0bffe17 	ldw	r2,-8(fp)
8111c414:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111c418:	e03ffd05 	stb	zero,-12(fp)
8111c41c:	00001c06 	br	8111c490 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111c420:	e0bffd03 	ldbu	r2,-12(fp)
8111c424:	e0fffd03 	ldbu	r3,-12(fp)
8111c428:	18c09624 	muli	r3,r3,600
8111c42c:	e13fff17 	ldw	r4,-4(fp)
8111c430:	20c7883a 	add	r3,r4,r3
8111c434:	e13ffe17 	ldw	r4,-8(fp)
8111c438:	10800084 	addi	r2,r2,2
8111c43c:	1085883a 	add	r2,r2,r2
8111c440:	1085883a 	add	r2,r2,r2
8111c444:	2085883a 	add	r2,r4,r2
8111c448:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111c44c:	e17ffd03 	ldbu	r5,-12(fp)
8111c450:	e0bffd03 	ldbu	r2,-12(fp)
8111c454:	e0ffff17 	ldw	r3,-4(fp)
8111c458:	108025c4 	addi	r2,r2,151
8111c45c:	1085883a 	add	r2,r2,r2
8111c460:	1085883a 	add	r2,r2,r2
8111c464:	1885883a 	add	r2,r3,r2
8111c468:	10c00017 	ldw	r3,0(r2)
8111c46c:	e13ffe17 	ldw	r4,-8(fp)
8111c470:	288000c4 	addi	r2,r5,3
8111c474:	1085883a 	add	r2,r2,r2
8111c478:	1085883a 	add	r2,r2,r2
8111c47c:	2085883a 	add	r2,r4,r2
8111c480:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111c484:	e0bffd03 	ldbu	r2,-12(fp)
8111c488:	10800044 	addi	r2,r2,1
8111c48c:	e0bffd05 	stb	r2,-12(fp)
8111c490:	e0bffd03 	ldbu	r2,-12(fp)
8111c494:	103fe226 	beq	r2,zero,8111c420 <__reset+0xfb0fc420>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111c498:	e0bfff17 	ldw	r2,-4(fp)
8111c49c:	10c09904 	addi	r3,r2,612
8111c4a0:	e0bffe17 	ldw	r2,-8(fp)
8111c4a4:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111c4a8:	e0bffe17 	ldw	r2,-8(fp)
8111c4ac:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111c4b0:	e0bffe17 	ldw	r2,-8(fp)
8111c4b4:	10c00504 	addi	r3,r2,20
8111c4b8:	e0bfff17 	ldw	r2,-4(fp)
8111c4bc:	10c09b15 	stw	r3,620(r2)
}
8111c4c0:	0001883a 	nop
8111c4c4:	e037883a 	mov	sp,fp
8111c4c8:	df000017 	ldw	fp,0(sp)
8111c4cc:	dec00104 	addi	sp,sp,4
8111c4d0:	f800283a 	ret

8111c4d4 <printErrorTask>:

#include "error_handler_simucam.h"


#if DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111c4d4:	defff904 	addi	sp,sp,-28
8111c4d8:	de00012e 	bgeu	sp,et,8111c4e0 <printErrorTask+0xc>
8111c4dc:	003b68fa 	trap	3
8111c4e0:	dfc00615 	stw	ra,24(sp)
8111c4e4:	df000515 	stw	fp,20(sp)
8111c4e8:	df000504 	addi	fp,sp,20
8111c4ec:	2005883a 	mov	r2,r4
8111c4f0:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111c4f4:	e03ffb15 	stw	zero,-20(fp)
8111c4f8:	e03ffc15 	stw	zero,-16(fp)
8111c4fc:	e03ffd15 	stw	zero,-12(fp)
8111c500:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111c504:	e0bfff03 	ldbu	r2,-4(fp)
8111c508:	100d883a 	mov	r6,r2
8111c50c:	01604574 	movhi	r5,33045
8111c510:	29404d04 	addi	r5,r5,308
8111c514:	e13ffb04 	addi	r4,fp,-20
8111c518:	11242a80 	call	811242a8 <sprintf>
		debug(fp, buffer);
8111c51c:	d0a06217 	ldw	r2,-32376(gp)
8111c520:	e17ffb04 	addi	r5,fp,-20
8111c524:	1009883a 	mov	r4,r2
8111c528:	11229940 	call	81122994 <fprintf>
	}
8111c52c:	0001883a 	nop
8111c530:	e037883a 	mov	sp,fp
8111c534:	dfc00117 	ldw	ra,4(sp)
8111c538:	df000017 	ldw	fp,0(sp)
8111c53c:	dec00204 	addi	sp,sp,8
8111c540:	f800283a 	ret

8111c544 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111c544:	defffd04 	addi	sp,sp,-12
8111c548:	de00012e 	bgeu	sp,et,8111c550 <vFailCreateMutexSResources+0xc>
8111c54c:	003b68fa 	trap	3
8111c550:	dfc00215 	stw	ra,8(sp)
8111c554:	df000115 	stw	fp,4(sp)
8111c558:	df000104 	addi	fp,sp,4
8111c55c:	2005883a 	mov	r2,r4
8111c560:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c564:	00a045f4 	movhi	r2,33047
8111c568:	10a00404 	addi	r2,r2,-32752
8111c56c:	10800e8b 	ldhu	r2,58(r2)
8111c570:	10bfffcc 	andi	r2,r2,65535
8111c574:	108001e8 	cmpgeui	r2,r2,7
8111c578:	10000a1e 	bne	r2,zero,8111c5a4 <vFailCreateMutexSResources+0x60>
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111c57c:	d0a06217 	ldw	r2,-32376(gp)
8111c580:	100f883a 	mov	r7,r2
8111c584:	018008c4 	movi	r6,35
8111c588:	01400044 	movi	r5,1
8111c58c:	01204574 	movhi	r4,33045
8111c590:	21005004 	addi	r4,r4,320
8111c594:	11230300 	call	81123030 <fwrite>
		printErrorTask(error_code);
8111c598:	e0bfff03 	ldbu	r2,-4(fp)
8111c59c:	1009883a 	mov	r4,r2
8111c5a0:	111c4d40 	call	8111c4d4 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c5a4:	0001883a 	nop
8111c5a8:	e037883a 	mov	sp,fp
8111c5ac:	dfc00117 	ldw	ra,4(sp)
8111c5b0:	df000017 	ldw	fp,0(sp)
8111c5b4:	dec00204 	addi	sp,sp,8
8111c5b8:	f800283a 	ret

8111c5bc <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111c5bc:	defffe04 	addi	sp,sp,-8
8111c5c0:	de00012e 	bgeu	sp,et,8111c5c8 <vFailCreateMutexDMA+0xc>
8111c5c4:	003b68fa 	trap	3
8111c5c8:	dfc00115 	stw	ra,4(sp)
8111c5cc:	df000015 	stw	fp,0(sp)
8111c5d0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c5d4:	00a045f4 	movhi	r2,33047
8111c5d8:	10a00404 	addi	r2,r2,-32752
8111c5dc:	10800e8b 	ldhu	r2,58(r2)
8111c5e0:	10bfffcc 	andi	r2,r2,65535
8111c5e4:	108001e8 	cmpgeui	r2,r2,7
8111c5e8:	1000071e 	bne	r2,zero,8111c608 <vFailCreateMutexDMA+0x4c>
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111c5ec:	d0a06217 	ldw	r2,-32376(gp)
8111c5f0:	100f883a 	mov	r7,r2
8111c5f4:	018009c4 	movi	r6,39
8111c5f8:	01400044 	movi	r5,1
8111c5fc:	01204574 	movhi	r4,33045
8111c600:	21005904 	addi	r4,r4,356
8111c604:	11230300 	call	81123030 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c608:	0001883a 	nop
8111c60c:	e037883a 	mov	sp,fp
8111c610:	dfc00117 	ldw	ra,4(sp)
8111c614:	df000017 	ldw	fp,0(sp)
8111c618:	dec00204 	addi	sp,sp,8
8111c61c:	f800283a 	ret

8111c620 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111c620:	defffe04 	addi	sp,sp,-8
8111c624:	de00012e 	bgeu	sp,et,8111c62c <vFailCreateSemaphoreResources+0xc>
8111c628:	003b68fa 	trap	3
8111c62c:	dfc00115 	stw	ra,4(sp)
8111c630:	df000015 	stw	fp,0(sp)
8111c634:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c638:	00a045f4 	movhi	r2,33047
8111c63c:	10a00404 	addi	r2,r2,-32752
8111c640:	10800e8b 	ldhu	r2,58(r2)
8111c644:	10bfffcc 	andi	r2,r2,65535
8111c648:	108001e8 	cmpgeui	r2,r2,7
8111c64c:	1000071e 	bne	r2,zero,8111c66c <vFailCreateSemaphoreResources+0x4c>
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111c650:	d0a06217 	ldw	r2,-32376(gp)
8111c654:	100f883a 	mov	r7,r2
8111c658:	01800984 	movi	r6,38
8111c65c:	01400044 	movi	r5,1
8111c660:	01204574 	movhi	r4,33045
8111c664:	21006304 	addi	r4,r4,396
8111c668:	11230300 	call	81123030 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c66c:	0001883a 	nop
8111c670:	e037883a 	mov	sp,fp
8111c674:	dfc00117 	ldw	ra,4(sp)
8111c678:	df000017 	ldw	fp,0(sp)
8111c67c:	dec00204 	addi	sp,sp,8
8111c680:	f800283a 	ret

8111c684 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111c684:	defffe04 	addi	sp,sp,-8
8111c688:	de00012e 	bgeu	sp,et,8111c690 <vFailTestCriticasParts+0xc>
8111c68c:	003b68fa 	trap	3
8111c690:	dfc00115 	stw	ra,4(sp)
8111c694:	df000015 	stw	fp,0(sp)
8111c698:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c69c:	00a045f4 	movhi	r2,33047
8111c6a0:	10a00404 	addi	r2,r2,-32752
8111c6a4:	10800e8b 	ldhu	r2,58(r2)
8111c6a8:	10bfffcc 	andi	r2,r2,65535
8111c6ac:	108001e8 	cmpgeui	r2,r2,7
8111c6b0:	1000071e 	bne	r2,zero,8111c6d0 <vFailTestCriticasParts+0x4c>
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111c6b4:	d0a06217 	ldw	r2,-32376(gp)
8111c6b8:	100f883a 	mov	r7,r2
8111c6bc:	018007c4 	movi	r6,31
8111c6c0:	01400044 	movi	r5,1
8111c6c4:	01204574 	movhi	r4,33045
8111c6c8:	21006d04 	addi	r4,r4,436
8111c6cc:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c6d0:	0001883a 	nop
8111c6d4:	e037883a 	mov	sp,fp
8111c6d8:	dfc00117 	ldw	ra,4(sp)
8111c6dc:	df000017 	ldw	fp,0(sp)
8111c6e0:	dec00204 	addi	sp,sp,8
8111c6e4:	f800283a 	ret

8111c6e8 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111c6e8:	defffe04 	addi	sp,sp,-8
8111c6ec:	de00012e 	bgeu	sp,et,8111c6f4 <vFailSendxSemCommInit+0xc>
8111c6f0:	003b68fa 	trap	3
8111c6f4:	dfc00115 	stw	ra,4(sp)
8111c6f8:	df000015 	stw	fp,0(sp)
8111c6fc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c700:	00a045f4 	movhi	r2,33047
8111c704:	10a00404 	addi	r2,r2,-32752
8111c708:	10800e8b 	ldhu	r2,58(r2)
8111c70c:	10bfffcc 	andi	r2,r2,65535
8111c710:	108001e8 	cmpgeui	r2,r2,7
8111c714:	10000e1e 	bne	r2,zero,8111c750 <vFailSendxSemCommInit+0x68>
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111c718:	d0a06217 	ldw	r2,-32376(gp)
8111c71c:	100f883a 	mov	r7,r2
8111c720:	01800744 	movi	r6,29
8111c724:	01400044 	movi	r5,1
8111c728:	01204574 	movhi	r4,33045
8111c72c:	21007504 	addi	r4,r4,468
8111c730:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111c734:	d0a06217 	ldw	r2,-32376(gp)
8111c738:	100f883a 	mov	r7,r2
8111c73c:	01800a44 	movi	r6,41
8111c740:	01400044 	movi	r5,1
8111c744:	01204574 	movhi	r4,33045
8111c748:	21007d04 	addi	r4,r4,500
8111c74c:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c750:	0001883a 	nop
8111c754:	e037883a 	mov	sp,fp
8111c758:	dfc00117 	ldw	ra,4(sp)
8111c75c:	df000017 	ldw	fp,0(sp)
8111c760:	dec00204 	addi	sp,sp,8
8111c764:	f800283a 	ret

8111c768 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111c768:	defffe04 	addi	sp,sp,-8
8111c76c:	de00012e 	bgeu	sp,et,8111c774 <vFailSendPreParsedSemaphore+0xc>
8111c770:	003b68fa 	trap	3
8111c774:	dfc00115 	stw	ra,4(sp)
8111c778:	df000015 	stw	fp,0(sp)
8111c77c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c780:	00a045f4 	movhi	r2,33047
8111c784:	10a00404 	addi	r2,r2,-32752
8111c788:	10800e8b 	ldhu	r2,58(r2)
8111c78c:	10bfffcc 	andi	r2,r2,65535
8111c790:	108001e8 	cmpgeui	r2,r2,7
8111c794:	1000071e 	bne	r2,zero,8111c7b4 <vFailSendPreParsedSemaphore+0x4c>
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111c798:	d0a06217 	ldw	r2,-32376(gp)
8111c79c:	100f883a 	mov	r7,r2
8111c7a0:	01800904 	movi	r6,36
8111c7a4:	01400044 	movi	r5,1
8111c7a8:	01204574 	movhi	r4,33045
8111c7ac:	21008804 	addi	r4,r4,544
8111c7b0:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c7b4:	0001883a 	nop
8111c7b8:	e037883a 	mov	sp,fp
8111c7bc:	dfc00117 	ldw	ra,4(sp)
8111c7c0:	df000017 	ldw	fp,0(sp)
8111c7c4:	dec00204 	addi	sp,sp,8
8111c7c8:	f800283a 	ret

8111c7cc <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111c7cc:	defffe04 	addi	sp,sp,-8
8111c7d0:	de00012e 	bgeu	sp,et,8111c7d8 <vFailSendPreAckReceiverSemaphore+0xc>
8111c7d4:	003b68fa 	trap	3
8111c7d8:	dfc00115 	stw	ra,4(sp)
8111c7dc:	df000015 	stw	fp,0(sp)
8111c7e0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c7e4:	00a045f4 	movhi	r2,33047
8111c7e8:	10a00404 	addi	r2,r2,-32752
8111c7ec:	10800e8b 	ldhu	r2,58(r2)
8111c7f0:	10bfffcc 	andi	r2,r2,65535
8111c7f4:	108001e8 	cmpgeui	r2,r2,7
8111c7f8:	1000071e 	bne	r2,zero,8111c818 <vFailSendPreAckReceiverSemaphore+0x4c>
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111c7fc:	d0a06217 	ldw	r2,-32376(gp)
8111c800:	100f883a 	mov	r7,r2
8111c804:	01800a44 	movi	r6,41
8111c808:	01400044 	movi	r5,1
8111c80c:	01204574 	movhi	r4,33045
8111c810:	21009204 	addi	r4,r4,584
8111c814:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c818:	0001883a 	nop
8111c81c:	e037883a 	mov	sp,fp
8111c820:	dfc00117 	ldw	ra,4(sp)
8111c824:	df000017 	ldw	fp,0(sp)
8111c828:	dec00204 	addi	sp,sp,8
8111c82c:	f800283a 	ret

8111c830 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111c830:	defffe04 	addi	sp,sp,-8
8111c834:	de00012e 	bgeu	sp,et,8111c83c <vFailSendPreAckSenderSemaphore+0xc>
8111c838:	003b68fa 	trap	3
8111c83c:	dfc00115 	stw	ra,4(sp)
8111c840:	df000015 	stw	fp,0(sp)
8111c844:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c848:	00a045f4 	movhi	r2,33047
8111c84c:	10a00404 	addi	r2,r2,-32752
8111c850:	10800e8b 	ldhu	r2,58(r2)
8111c854:	10bfffcc 	andi	r2,r2,65535
8111c858:	108001e8 	cmpgeui	r2,r2,7
8111c85c:	1000071e 	bne	r2,zero,8111c87c <vFailSendPreAckSenderSemaphore+0x4c>
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111c860:	d0a06217 	ldw	r2,-32376(gp)
8111c864:	100f883a 	mov	r7,r2
8111c868:	018009c4 	movi	r6,39
8111c86c:	01400044 	movi	r5,1
8111c870:	01204574 	movhi	r4,33045
8111c874:	21009d04 	addi	r4,r4,628
8111c878:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c87c:	0001883a 	nop
8111c880:	e037883a 	mov	sp,fp
8111c884:	dfc00117 	ldw	ra,4(sp)
8111c888:	df000017 	ldw	fp,0(sp)
8111c88c:	dec00204 	addi	sp,sp,8
8111c890:	f800283a 	ret

8111c894 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111c894:	defffe04 	addi	sp,sp,-8
8111c898:	de00012e 	bgeu	sp,et,8111c8a0 <vFailGetCountSemaphoreSenderTask+0xc>
8111c89c:	003b68fa 	trap	3
8111c8a0:	dfc00115 	stw	ra,4(sp)
8111c8a4:	df000015 	stw	fp,0(sp)
8111c8a8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c8ac:	00a045f4 	movhi	r2,33047
8111c8b0:	10a00404 	addi	r2,r2,-32752
8111c8b4:	10800e8b 	ldhu	r2,58(r2)
8111c8b8:	10bfffcc 	andi	r2,r2,65535
8111c8bc:	108001e8 	cmpgeui	r2,r2,7
8111c8c0:	10000e1e 	bne	r2,zero,8111c8fc <vFailGetCountSemaphoreSenderTask+0x68>
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111c8c4:	d0a06217 	ldw	r2,-32376(gp)
8111c8c8:	100f883a 	mov	r7,r2
8111c8cc:	01800a44 	movi	r6,41
8111c8d0:	01400044 	movi	r5,1
8111c8d4:	01204574 	movhi	r4,33045
8111c8d8:	2100a704 	addi	r4,r4,668
8111c8dc:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111c8e0:	d0a06217 	ldw	r2,-32376(gp)
8111c8e4:	100f883a 	mov	r7,r2
8111c8e8:	01801104 	movi	r6,68
8111c8ec:	01400044 	movi	r5,1
8111c8f0:	01204574 	movhi	r4,33045
8111c8f4:	2100b204 	addi	r4,r4,712
8111c8f8:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c8fc:	0001883a 	nop
8111c900:	e037883a 	mov	sp,fp
8111c904:	dfc00117 	ldw	ra,4(sp)
8111c908:	df000017 	ldw	fp,0(sp)
8111c90c:	dec00204 	addi	sp,sp,8
8111c910:	f800283a 	ret

8111c914 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111c914:	defffe04 	addi	sp,sp,-8
8111c918:	de00012e 	bgeu	sp,et,8111c920 <vFailGetMutexSenderTask+0xc>
8111c91c:	003b68fa 	trap	3
8111c920:	dfc00115 	stw	ra,4(sp)
8111c924:	df000015 	stw	fp,0(sp)
8111c928:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c92c:	00a045f4 	movhi	r2,33047
8111c930:	10a00404 	addi	r2,r2,-32752
8111c934:	10800e8b 	ldhu	r2,58(r2)
8111c938:	10bfffcc 	andi	r2,r2,65535
8111c93c:	108001e8 	cmpgeui	r2,r2,7
8111c940:	10000e1e 	bne	r2,zero,8111c97c <vFailGetMutexSenderTask+0x68>
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111c944:	d0a06217 	ldw	r2,-32376(gp)
8111c948:	100f883a 	mov	r7,r2
8111c94c:	01800804 	movi	r6,32
8111c950:	01400044 	movi	r5,1
8111c954:	01204574 	movhi	r4,33045
8111c958:	2100c404 	addi	r4,r4,784
8111c95c:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111c960:	d0a06217 	ldw	r2,-32376(gp)
8111c964:	100f883a 	mov	r7,r2
8111c968:	01801084 	movi	r6,66
8111c96c:	01400044 	movi	r5,1
8111c970:	01204574 	movhi	r4,33045
8111c974:	2100cd04 	addi	r4,r4,820
8111c978:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c97c:	0001883a 	nop
8111c980:	e037883a 	mov	sp,fp
8111c984:	dfc00117 	ldw	ra,4(sp)
8111c988:	df000017 	ldw	fp,0(sp)
8111c98c:	dec00204 	addi	sp,sp,8
8111c990:	f800283a 	ret

8111c994 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111c994:	defffe04 	addi	sp,sp,-8
8111c998:	de00012e 	bgeu	sp,et,8111c9a0 <vFailGetCountSemaphoreReceiverTask+0xc>
8111c99c:	003b68fa 	trap	3
8111c9a0:	dfc00115 	stw	ra,4(sp)
8111c9a4:	df000015 	stw	fp,0(sp)
8111c9a8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c9ac:	00a045f4 	movhi	r2,33047
8111c9b0:	10a00404 	addi	r2,r2,-32752
8111c9b4:	10800e8b 	ldhu	r2,58(r2)
8111c9b8:	10bfffcc 	andi	r2,r2,65535
8111c9bc:	108001e8 	cmpgeui	r2,r2,7
8111c9c0:	10000e1e 	bne	r2,zero,8111c9fc <vFailGetCountSemaphoreReceiverTask+0x68>
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111c9c4:	d0a06217 	ldw	r2,-32376(gp)
8111c9c8:	100f883a 	mov	r7,r2
8111c9cc:	01800ac4 	movi	r6,43
8111c9d0:	01400044 	movi	r5,1
8111c9d4:	01204574 	movhi	r4,33045
8111c9d8:	2100de04 	addi	r4,r4,888
8111c9dc:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111c9e0:	d0a06217 	ldw	r2,-32376(gp)
8111c9e4:	100f883a 	mov	r7,r2
8111c9e8:	01801184 	movi	r6,70
8111c9ec:	01400044 	movi	r5,1
8111c9f0:	01204574 	movhi	r4,33045
8111c9f4:	2100e904 	addi	r4,r4,932
8111c9f8:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c9fc:	0001883a 	nop
8111ca00:	e037883a 	mov	sp,fp
8111ca04:	dfc00117 	ldw	ra,4(sp)
8111ca08:	df000017 	ldw	fp,0(sp)
8111ca0c:	dec00204 	addi	sp,sp,8
8111ca10:	f800283a 	ret

8111ca14 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111ca14:	defffe04 	addi	sp,sp,-8
8111ca18:	de00012e 	bgeu	sp,et,8111ca20 <vFailGetMutexReceiverTask+0xc>
8111ca1c:	003b68fa 	trap	3
8111ca20:	dfc00115 	stw	ra,4(sp)
8111ca24:	df000015 	stw	fp,0(sp)
8111ca28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ca2c:	00a045f4 	movhi	r2,33047
8111ca30:	10a00404 	addi	r2,r2,-32752
8111ca34:	10800e8b 	ldhu	r2,58(r2)
8111ca38:	10bfffcc 	andi	r2,r2,65535
8111ca3c:	108001e8 	cmpgeui	r2,r2,7
8111ca40:	10000e1e 	bne	r2,zero,8111ca7c <vFailGetMutexReceiverTask+0x68>
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111ca44:	d0a06217 	ldw	r2,-32376(gp)
8111ca48:	100f883a 	mov	r7,r2
8111ca4c:	01800884 	movi	r6,34
8111ca50:	01400044 	movi	r5,1
8111ca54:	01204574 	movhi	r4,33045
8111ca58:	2100fb04 	addi	r4,r4,1004
8111ca5c:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111ca60:	d0a06217 	ldw	r2,-32376(gp)
8111ca64:	100f883a 	mov	r7,r2
8111ca68:	01801104 	movi	r6,68
8111ca6c:	01400044 	movi	r5,1
8111ca70:	01204574 	movhi	r4,33045
8111ca74:	21010404 	addi	r4,r4,1040
8111ca78:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ca7c:	0001883a 	nop
8111ca80:	e037883a 	mov	sp,fp
8111ca84:	dfc00117 	ldw	ra,4(sp)
8111ca88:	df000017 	ldw	fp,0(sp)
8111ca8c:	dec00204 	addi	sp,sp,8
8111ca90:	f800283a 	ret

8111ca94 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111ca94:	defffe04 	addi	sp,sp,-8
8111ca98:	de00012e 	bgeu	sp,et,8111caa0 <vFailGetMutexTxUARTSenderTask+0xc>
8111ca9c:	003b68fa 	trap	3
8111caa0:	dfc00115 	stw	ra,4(sp)
8111caa4:	df000015 	stw	fp,0(sp)
8111caa8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111caac:	00a045f4 	movhi	r2,33047
8111cab0:	10a00404 	addi	r2,r2,-32752
8111cab4:	10800e8b 	ldhu	r2,58(r2)
8111cab8:	10bfffcc 	andi	r2,r2,65535
8111cabc:	108001e8 	cmpgeui	r2,r2,7
8111cac0:	10000e1e 	bne	r2,zero,8111cafc <vFailGetMutexTxUARTSenderTask+0x68>
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111cac4:	d0a06217 	ldw	r2,-32376(gp)
8111cac8:	100f883a 	mov	r7,r2
8111cacc:	01800984 	movi	r6,38
8111cad0:	01400044 	movi	r5,1
8111cad4:	01204574 	movhi	r4,33045
8111cad8:	21011604 	addi	r4,r4,1112
8111cadc:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111cae0:	d0a06217 	ldw	r2,-32376(gp)
8111cae4:	100f883a 	mov	r7,r2
8111cae8:	01801044 	movi	r6,65
8111caec:	01400044 	movi	r5,1
8111caf0:	01204574 	movhi	r4,33045
8111caf4:	21012004 	addi	r4,r4,1152
8111caf8:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cafc:	0001883a 	nop
8111cb00:	e037883a 	mov	sp,fp
8111cb04:	dfc00117 	ldw	ra,4(sp)
8111cb08:	df000017 	ldw	fp,0(sp)
8111cb0c:	dec00204 	addi	sp,sp,8
8111cb10:	f800283a 	ret

8111cb14 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111cb14:	defffe04 	addi	sp,sp,-8
8111cb18:	de00012e 	bgeu	sp,et,8111cb20 <vFailGetMacRTC+0xc>
8111cb1c:	003b68fa 	trap	3
8111cb20:	dfc00115 	stw	ra,4(sp)
8111cb24:	df000015 	stw	fp,0(sp)
8111cb28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cb2c:	00a045f4 	movhi	r2,33047
8111cb30:	10a00404 	addi	r2,r2,-32752
8111cb34:	10800e8b 	ldhu	r2,58(r2)
8111cb38:	10bfffcc 	andi	r2,r2,65535
8111cb3c:	108001e8 	cmpgeui	r2,r2,7
8111cb40:	1000071e 	bne	r2,zero,8111cb60 <vFailGetMacRTC+0x4c>
		debug(fp,"vFailGetMacRTC\n");
8111cb44:	d0a06217 	ldw	r2,-32376(gp)
8111cb48:	100f883a 	mov	r7,r2
8111cb4c:	018003c4 	movi	r6,15
8111cb50:	01400044 	movi	r5,1
8111cb54:	01204574 	movhi	r4,33045
8111cb58:	21013104 	addi	r4,r4,1220
8111cb5c:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb60:	0001883a 	nop
8111cb64:	e037883a 	mov	sp,fp
8111cb68:	dfc00117 	ldw	ra,4(sp)
8111cb6c:	df000017 	ldw	fp,0(sp)
8111cb70:	dec00204 	addi	sp,sp,8
8111cb74:	f800283a 	ret

8111cb78 <vFailInitialization>:


void vFailInitialization( void )
{
8111cb78:	defffe04 	addi	sp,sp,-8
8111cb7c:	de00012e 	bgeu	sp,et,8111cb84 <vFailInitialization+0xc>
8111cb80:	003b68fa 	trap	3
8111cb84:	dfc00115 	stw	ra,4(sp)
8111cb88:	df000015 	stw	fp,0(sp)
8111cb8c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cb90:	00a045f4 	movhi	r2,33047
8111cb94:	10a00404 	addi	r2,r2,-32752
8111cb98:	10800e8b 	ldhu	r2,58(r2)
8111cb9c:	10bfffcc 	andi	r2,r2,65535
8111cba0:	108001e8 	cmpgeui	r2,r2,7
8111cba4:	1000071e 	bne	r2,zero,8111cbc4 <vFailInitialization+0x4c>
		debug(fp,"vFailInitialization\n");
8111cba8:	d0a06217 	ldw	r2,-32376(gp)
8111cbac:	100f883a 	mov	r7,r2
8111cbb0:	01800504 	movi	r6,20
8111cbb4:	01400044 	movi	r5,1
8111cbb8:	01204574 	movhi	r4,33045
8111cbbc:	21013504 	addi	r4,r4,1236
8111cbc0:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cbc4:	0001883a 	nop
8111cbc8:	e037883a 	mov	sp,fp
8111cbcc:	dfc00117 	ldw	ra,4(sp)
8111cbd0:	df000017 	ldw	fp,0(sp)
8111cbd4:	dec00204 	addi	sp,sp,8
8111cbd8:	f800283a 	ret

8111cbdc <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111cbdc:	defffe04 	addi	sp,sp,-8
8111cbe0:	de00012e 	bgeu	sp,et,8111cbe8 <vFailReceiverCreate+0xc>
8111cbe4:	003b68fa 	trap	3
8111cbe8:	dfc00115 	stw	ra,4(sp)
8111cbec:	df000015 	stw	fp,0(sp)
8111cbf0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cbf4:	00a045f4 	movhi	r2,33047
8111cbf8:	10a00404 	addi	r2,r2,-32752
8111cbfc:	10800e8b 	ldhu	r2,58(r2)
8111cc00:	10bfffcc 	andi	r2,r2,65535
8111cc04:	108001e8 	cmpgeui	r2,r2,7
8111cc08:	1000071e 	bne	r2,zero,8111cc28 <vFailReceiverCreate+0x4c>
		debug(fp,"vReceiverUartTask\n");
8111cc0c:	d0a06217 	ldw	r2,-32376(gp)
8111cc10:	100f883a 	mov	r7,r2
8111cc14:	01800484 	movi	r6,18
8111cc18:	01400044 	movi	r5,1
8111cc1c:	01204574 	movhi	r4,33045
8111cc20:	21013b04 	addi	r4,r4,1260
8111cc24:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc28:	0001883a 	nop
8111cc2c:	e037883a 	mov	sp,fp
8111cc30:	dfc00117 	ldw	ra,4(sp)
8111cc34:	df000017 	ldw	fp,0(sp)
8111cc38:	dec00204 	addi	sp,sp,8
8111cc3c:	f800283a 	ret

8111cc40 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111cc40:	defffe04 	addi	sp,sp,-8
8111cc44:	de00012e 	bgeu	sp,et,8111cc4c <vFailSenderCreate+0xc>
8111cc48:	003b68fa 	trap	3
8111cc4c:	dfc00115 	stw	ra,4(sp)
8111cc50:	df000015 	stw	fp,0(sp)
8111cc54:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cc58:	00a045f4 	movhi	r2,33047
8111cc5c:	10a00404 	addi	r2,r2,-32752
8111cc60:	10800e8b 	ldhu	r2,58(r2)
8111cc64:	10bfffcc 	andi	r2,r2,65535
8111cc68:	108001e8 	cmpgeui	r2,r2,7
8111cc6c:	1000071e 	bne	r2,zero,8111cc8c <vFailSenderCreate+0x4c>
		debug(fp,"vFailSenderCreate\n");
8111cc70:	d0a06217 	ldw	r2,-32376(gp)
8111cc74:	100f883a 	mov	r7,r2
8111cc78:	01800484 	movi	r6,18
8111cc7c:	01400044 	movi	r5,1
8111cc80:	01204574 	movhi	r4,33045
8111cc84:	21014004 	addi	r4,r4,1280
8111cc88:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc8c:	0001883a 	nop
8111cc90:	e037883a 	mov	sp,fp
8111cc94:	dfc00117 	ldw	ra,4(sp)
8111cc98:	df000017 	ldw	fp,0(sp)
8111cc9c:	dec00204 	addi	sp,sp,8
8111cca0:	f800283a 	ret

8111cca4 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111cca4:	defffe04 	addi	sp,sp,-8
8111cca8:	de00012e 	bgeu	sp,et,8111ccb0 <vFailDeleteInitialization+0xc>
8111ccac:	003b68fa 	trap	3
8111ccb0:	dfc00115 	stw	ra,4(sp)
8111ccb4:	df000015 	stw	fp,0(sp)
8111ccb8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ccbc:	00a045f4 	movhi	r2,33047
8111ccc0:	10a00404 	addi	r2,r2,-32752
8111ccc4:	10800e8b 	ldhu	r2,58(r2)
8111ccc8:	10bfffcc 	andi	r2,r2,65535
8111cccc:	108001e8 	cmpgeui	r2,r2,7
8111ccd0:	1000071e 	bne	r2,zero,8111ccf0 <vFailDeleteInitialization+0x4c>
		debug(fp,"vFailDeleteInitialization\n");
8111ccd4:	d0a06217 	ldw	r2,-32376(gp)
8111ccd8:	100f883a 	mov	r7,r2
8111ccdc:	01800684 	movi	r6,26
8111cce0:	01400044 	movi	r5,1
8111cce4:	01204574 	movhi	r4,33045
8111cce8:	21014504 	addi	r4,r4,1300
8111ccec:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ccf0:	0001883a 	nop
8111ccf4:	e037883a 	mov	sp,fp
8111ccf8:	dfc00117 	ldw	ra,4(sp)
8111ccfc:	df000017 	ldw	fp,0(sp)
8111cd00:	dec00204 	addi	sp,sp,8
8111cd04:	f800283a 	ret

8111cd08 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111cd08:	defffe04 	addi	sp,sp,-8
8111cd0c:	de00012e 	bgeu	sp,et,8111cd14 <vFailSetCountSemaphorexBuffer32+0xc>
8111cd10:	003b68fa 	trap	3
8111cd14:	dfc00115 	stw	ra,4(sp)
8111cd18:	df000015 	stw	fp,0(sp)
8111cd1c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cd20:	00a045f4 	movhi	r2,33047
8111cd24:	10a00404 	addi	r2,r2,-32752
8111cd28:	10800e8b 	ldhu	r2,58(r2)
8111cd2c:	10bfffcc 	andi	r2,r2,65535
8111cd30:	108001e8 	cmpgeui	r2,r2,7
8111cd34:	10000e1e 	bne	r2,zero,8111cd70 <vFailSetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111cd38:	d0a06217 	ldw	r2,-32376(gp)
8111cd3c:	100f883a 	mov	r7,r2
8111cd40:	01800a04 	movi	r6,40
8111cd44:	01400044 	movi	r5,1
8111cd48:	01204574 	movhi	r4,33045
8111cd4c:	21014c04 	addi	r4,r4,1328
8111cd50:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111cd54:	d0a06217 	ldw	r2,-32376(gp)
8111cd58:	100f883a 	mov	r7,r2
8111cd5c:	018008c4 	movi	r6,35
8111cd60:	01400044 	movi	r5,1
8111cd64:	01204574 	movhi	r4,33045
8111cd68:	21015704 	addi	r4,r4,1372
8111cd6c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd70:	0001883a 	nop
8111cd74:	e037883a 	mov	sp,fp
8111cd78:	dfc00117 	ldw	ra,4(sp)
8111cd7c:	df000017 	ldw	fp,0(sp)
8111cd80:	dec00204 	addi	sp,sp,8
8111cd84:	f800283a 	ret

8111cd88 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111cd88:	defffe04 	addi	sp,sp,-8
8111cd8c:	de00012e 	bgeu	sp,et,8111cd94 <vFailSetCountSemaphorexBuffer64+0xc>
8111cd90:	003b68fa 	trap	3
8111cd94:	dfc00115 	stw	ra,4(sp)
8111cd98:	df000015 	stw	fp,0(sp)
8111cd9c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cda0:	00a045f4 	movhi	r2,33047
8111cda4:	10a00404 	addi	r2,r2,-32752
8111cda8:	10800e8b 	ldhu	r2,58(r2)
8111cdac:	10bfffcc 	andi	r2,r2,65535
8111cdb0:	108001e8 	cmpgeui	r2,r2,7
8111cdb4:	10000e1e 	bne	r2,zero,8111cdf0 <vFailSetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111cdb8:	d0a06217 	ldw	r2,-32376(gp)
8111cdbc:	100f883a 	mov	r7,r2
8111cdc0:	01800a04 	movi	r6,40
8111cdc4:	01400044 	movi	r5,1
8111cdc8:	01204574 	movhi	r4,33045
8111cdcc:	21016004 	addi	r4,r4,1408
8111cdd0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111cdd4:	d0a06217 	ldw	r2,-32376(gp)
8111cdd8:	100f883a 	mov	r7,r2
8111cddc:	018008c4 	movi	r6,35
8111cde0:	01400044 	movi	r5,1
8111cde4:	01204574 	movhi	r4,33045
8111cde8:	21015704 	addi	r4,r4,1372
8111cdec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cdf0:	0001883a 	nop
8111cdf4:	e037883a 	mov	sp,fp
8111cdf8:	dfc00117 	ldw	ra,4(sp)
8111cdfc:	df000017 	ldw	fp,0(sp)
8111ce00:	dec00204 	addi	sp,sp,8
8111ce04:	f800283a 	ret

8111ce08 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111ce08:	defffe04 	addi	sp,sp,-8
8111ce0c:	de00012e 	bgeu	sp,et,8111ce14 <vFailSetCountSemaphorexBuffer128+0xc>
8111ce10:	003b68fa 	trap	3
8111ce14:	dfc00115 	stw	ra,4(sp)
8111ce18:	df000015 	stw	fp,0(sp)
8111ce1c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ce20:	00a045f4 	movhi	r2,33047
8111ce24:	10a00404 	addi	r2,r2,-32752
8111ce28:	10800e8b 	ldhu	r2,58(r2)
8111ce2c:	10bfffcc 	andi	r2,r2,65535
8111ce30:	108001e8 	cmpgeui	r2,r2,7
8111ce34:	10000e1e 	bne	r2,zero,8111ce70 <vFailSetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111ce38:	d0a06217 	ldw	r2,-32376(gp)
8111ce3c:	100f883a 	mov	r7,r2
8111ce40:	01800a44 	movi	r6,41
8111ce44:	01400044 	movi	r5,1
8111ce48:	01204574 	movhi	r4,33045
8111ce4c:	21016b04 	addi	r4,r4,1452
8111ce50:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111ce54:	d0a06217 	ldw	r2,-32376(gp)
8111ce58:	100f883a 	mov	r7,r2
8111ce5c:	018008c4 	movi	r6,35
8111ce60:	01400044 	movi	r5,1
8111ce64:	01204574 	movhi	r4,33045
8111ce68:	21015704 	addi	r4,r4,1372
8111ce6c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce70:	0001883a 	nop
8111ce74:	e037883a 	mov	sp,fp
8111ce78:	dfc00117 	ldw	ra,4(sp)
8111ce7c:	df000017 	ldw	fp,0(sp)
8111ce80:	dec00204 	addi	sp,sp,8
8111ce84:	f800283a 	ret

8111ce88 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111ce88:	defffe04 	addi	sp,sp,-8
8111ce8c:	de00012e 	bgeu	sp,et,8111ce94 <vFailGetCountSemaphorexBuffer128+0xc>
8111ce90:	003b68fa 	trap	3
8111ce94:	dfc00115 	stw	ra,4(sp)
8111ce98:	df000015 	stw	fp,0(sp)
8111ce9c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cea0:	00a045f4 	movhi	r2,33047
8111cea4:	10a00404 	addi	r2,r2,-32752
8111cea8:	10800e8b 	ldhu	r2,58(r2)
8111ceac:	10bfffcc 	andi	r2,r2,65535
8111ceb0:	108001e8 	cmpgeui	r2,r2,7
8111ceb4:	10000e1e 	bne	r2,zero,8111cef0 <vFailGetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111ceb8:	d0a06217 	ldw	r2,-32376(gp)
8111cebc:	100f883a 	mov	r7,r2
8111cec0:	01800a44 	movi	r6,41
8111cec4:	01400044 	movi	r5,1
8111cec8:	01204574 	movhi	r4,33045
8111cecc:	21017604 	addi	r4,r4,1496
8111ced0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111ced4:	d0a06217 	ldw	r2,-32376(gp)
8111ced8:	100f883a 	mov	r7,r2
8111cedc:	01800884 	movi	r6,34
8111cee0:	01400044 	movi	r5,1
8111cee4:	01204574 	movhi	r4,33045
8111cee8:	21018104 	addi	r4,r4,1540
8111ceec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cef0:	0001883a 	nop
8111cef4:	e037883a 	mov	sp,fp
8111cef8:	dfc00117 	ldw	ra,4(sp)
8111cefc:	df000017 	ldw	fp,0(sp)
8111cf00:	dec00204 	addi	sp,sp,8
8111cf04:	f800283a 	ret

8111cf08 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111cf08:	defffe04 	addi	sp,sp,-8
8111cf0c:	de00012e 	bgeu	sp,et,8111cf14 <vFailGetCountSemaphorexBuffer64+0xc>
8111cf10:	003b68fa 	trap	3
8111cf14:	dfc00115 	stw	ra,4(sp)
8111cf18:	df000015 	stw	fp,0(sp)
8111cf1c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cf20:	00a045f4 	movhi	r2,33047
8111cf24:	10a00404 	addi	r2,r2,-32752
8111cf28:	10800e8b 	ldhu	r2,58(r2)
8111cf2c:	10bfffcc 	andi	r2,r2,65535
8111cf30:	108001e8 	cmpgeui	r2,r2,7
8111cf34:	10000e1e 	bne	r2,zero,8111cf70 <vFailGetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111cf38:	d0a06217 	ldw	r2,-32376(gp)
8111cf3c:	100f883a 	mov	r7,r2
8111cf40:	01800a04 	movi	r6,40
8111cf44:	01400044 	movi	r5,1
8111cf48:	01204574 	movhi	r4,33045
8111cf4c:	21018a04 	addi	r4,r4,1576
8111cf50:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111cf54:	d0a06217 	ldw	r2,-32376(gp)
8111cf58:	100f883a 	mov	r7,r2
8111cf5c:	01800884 	movi	r6,34
8111cf60:	01400044 	movi	r5,1
8111cf64:	01204574 	movhi	r4,33045
8111cf68:	21018104 	addi	r4,r4,1540
8111cf6c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf70:	0001883a 	nop
8111cf74:	e037883a 	mov	sp,fp
8111cf78:	dfc00117 	ldw	ra,4(sp)
8111cf7c:	df000017 	ldw	fp,0(sp)
8111cf80:	dec00204 	addi	sp,sp,8
8111cf84:	f800283a 	ret

8111cf88 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111cf88:	defffe04 	addi	sp,sp,-8
8111cf8c:	de00012e 	bgeu	sp,et,8111cf94 <vFailGetCountSemaphorexBuffer32+0xc>
8111cf90:	003b68fa 	trap	3
8111cf94:	dfc00115 	stw	ra,4(sp)
8111cf98:	df000015 	stw	fp,0(sp)
8111cf9c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cfa0:	00a045f4 	movhi	r2,33047
8111cfa4:	10a00404 	addi	r2,r2,-32752
8111cfa8:	10800e8b 	ldhu	r2,58(r2)
8111cfac:	10bfffcc 	andi	r2,r2,65535
8111cfb0:	108001e8 	cmpgeui	r2,r2,7
8111cfb4:	10000e1e 	bne	r2,zero,8111cff0 <vFailGetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111cfb8:	d0a06217 	ldw	r2,-32376(gp)
8111cfbc:	100f883a 	mov	r7,r2
8111cfc0:	01800a04 	movi	r6,40
8111cfc4:	01400044 	movi	r5,1
8111cfc8:	01204574 	movhi	r4,33045
8111cfcc:	21019504 	addi	r4,r4,1620
8111cfd0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111cfd4:	d0a06217 	ldw	r2,-32376(gp)
8111cfd8:	100f883a 	mov	r7,r2
8111cfdc:	01800884 	movi	r6,34
8111cfe0:	01400044 	movi	r5,1
8111cfe4:	01204574 	movhi	r4,33045
8111cfe8:	21018104 	addi	r4,r4,1540
8111cfec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cff0:	0001883a 	nop
8111cff4:	e037883a 	mov	sp,fp
8111cff8:	dfc00117 	ldw	ra,4(sp)
8111cffc:	df000017 	ldw	fp,0(sp)
8111d000:	dec00204 	addi	sp,sp,8
8111d004:	f800283a 	ret

8111d008 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111d008:	defffe04 	addi	sp,sp,-8
8111d00c:	de00012e 	bgeu	sp,et,8111d014 <vFailFoundBufferRetransmission+0xc>
8111d010:	003b68fa 	trap	3
8111d014:	dfc00115 	stw	ra,4(sp)
8111d018:	df000015 	stw	fp,0(sp)
8111d01c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d020:	00a045f4 	movhi	r2,33047
8111d024:	10a00404 	addi	r2,r2,-32752
8111d028:	10800e8b 	ldhu	r2,58(r2)
8111d02c:	10bfffcc 	andi	r2,r2,65535
8111d030:	108001e8 	cmpgeui	r2,r2,7
8111d034:	10000e1e 	bne	r2,zero,8111d070 <vFailFoundBufferRetransmission+0x68>
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111d038:	d0a06217 	ldw	r2,-32376(gp)
8111d03c:	100f883a 	mov	r7,r2
8111d040:	01800a84 	movi	r6,42
8111d044:	01400044 	movi	r5,1
8111d048:	01204574 	movhi	r4,33045
8111d04c:	2101a004 	addi	r4,r4,1664
8111d050:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111d054:	d0a06217 	ldw	r2,-32376(gp)
8111d058:	100f883a 	mov	r7,r2
8111d05c:	01801204 	movi	r6,72
8111d060:	01400044 	movi	r5,1
8111d064:	01204574 	movhi	r4,33045
8111d068:	2101ab04 	addi	r4,r4,1708
8111d06c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d070:	0001883a 	nop
8111d074:	e037883a 	mov	sp,fp
8111d078:	dfc00117 	ldw	ra,4(sp)
8111d07c:	df000017 	ldw	fp,0(sp)
8111d080:	dec00204 	addi	sp,sp,8
8111d084:	f800283a 	ret

8111d088 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111d088:	defffe04 	addi	sp,sp,-8
8111d08c:	de00012e 	bgeu	sp,et,8111d094 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111d090:	003b68fa 	trap	3
8111d094:	dfc00115 	stw	ra,4(sp)
8111d098:	df000015 	stw	fp,0(sp)
8111d09c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d0a0:	00a045f4 	movhi	r2,33047
8111d0a4:	10a00404 	addi	r2,r2,-32752
8111d0a8:	10800e8b 	ldhu	r2,58(r2)
8111d0ac:	10bfffcc 	andi	r2,r2,65535
8111d0b0:	108001e8 	cmpgeui	r2,r2,7
8111d0b4:	10000e1e 	bne	r2,zero,8111d0f0 <vFailGetCountSemaphorePreParsedBuffer+0x68>
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111d0b8:	d0a06217 	ldw	r2,-32376(gp)
8111d0bc:	100f883a 	mov	r7,r2
8111d0c0:	01800b84 	movi	r6,46
8111d0c4:	01400044 	movi	r5,1
8111d0c8:	01204574 	movhi	r4,33045
8111d0cc:	2101be04 	addi	r4,r4,1784
8111d0d0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111d0d4:	d0a06217 	ldw	r2,-32376(gp)
8111d0d8:	100f883a 	mov	r7,r2
8111d0dc:	018010c4 	movi	r6,67
8111d0e0:	01400044 	movi	r5,1
8111d0e4:	01204574 	movhi	r4,33045
8111d0e8:	2101ca04 	addi	r4,r4,1832
8111d0ec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d0f0:	0001883a 	nop
8111d0f4:	e037883a 	mov	sp,fp
8111d0f8:	dfc00117 	ldw	ra,4(sp)
8111d0fc:	df000017 	ldw	fp,0(sp)
8111d100:	dec00204 	addi	sp,sp,8
8111d104:	f800283a 	ret

8111d108 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111d108:	defffe04 	addi	sp,sp,-8
8111d10c:	de00012e 	bgeu	sp,et,8111d114 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111d110:	003b68fa 	trap	3
8111d114:	dfc00115 	stw	ra,4(sp)
8111d118:	df000015 	stw	fp,0(sp)
8111d11c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d120:	00a045f4 	movhi	r2,33047
8111d124:	10a00404 	addi	r2,r2,-32752
8111d128:	10800e8b 	ldhu	r2,58(r2)
8111d12c:	10bfffcc 	andi	r2,r2,65535
8111d130:	108001e8 	cmpgeui	r2,r2,7
8111d134:	10000e1e 	bne	r2,zero,8111d170 <vFailGetxMutexPreParsedParserRxTask+0x68>
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111d138:	d0a06217 	ldw	r2,-32376(gp)
8111d13c:	100f883a 	mov	r7,r2
8111d140:	01800b04 	movi	r6,44
8111d144:	01400044 	movi	r5,1
8111d148:	01204574 	movhi	r4,33045
8111d14c:	2101db04 	addi	r4,r4,1900
8111d150:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111d154:	d0a06217 	ldw	r2,-32376(gp)
8111d158:	100f883a 	mov	r7,r2
8111d15c:	01800fc4 	movi	r6,63
8111d160:	01400044 	movi	r5,1
8111d164:	01204574 	movhi	r4,33045
8111d168:	2101e704 	addi	r4,r4,1948
8111d16c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d170:	0001883a 	nop
8111d174:	e037883a 	mov	sp,fp
8111d178:	dfc00117 	ldw	ra,4(sp)
8111d17c:	df000017 	ldw	fp,0(sp)
8111d180:	dec00204 	addi	sp,sp,8
8111d184:	f800283a 	ret

8111d188 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111d188:	defffe04 	addi	sp,sp,-8
8111d18c:	de00012e 	bgeu	sp,et,8111d194 <vNoContentInPreParsedBuffer+0xc>
8111d190:	003b68fa 	trap	3
8111d194:	dfc00115 	stw	ra,4(sp)
8111d198:	df000015 	stw	fp,0(sp)
8111d19c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d1a0:	00a045f4 	movhi	r2,33047
8111d1a4:	10a00404 	addi	r2,r2,-32752
8111d1a8:	10800e8b 	ldhu	r2,58(r2)
8111d1ac:	10bfffcc 	andi	r2,r2,65535
8111d1b0:	108001e8 	cmpgeui	r2,r2,7
8111d1b4:	10000e1e 	bne	r2,zero,8111d1f0 <vNoContentInPreParsedBuffer+0x68>
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111d1b8:	d0a06217 	ldw	r2,-32376(gp)
8111d1bc:	100f883a 	mov	r7,r2
8111d1c0:	01800904 	movi	r6,36
8111d1c4:	01400044 	movi	r5,1
8111d1c8:	01204574 	movhi	r4,33045
8111d1cc:	2101f704 	addi	r4,r4,2012
8111d1d0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111d1d4:	d0a06217 	ldw	r2,-32376(gp)
8111d1d8:	100f883a 	mov	r7,r2
8111d1dc:	01801684 	movi	r6,90
8111d1e0:	01400044 	movi	r5,1
8111d1e4:	01204574 	movhi	r4,33045
8111d1e8:	21020104 	addi	r4,r4,2052
8111d1ec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1f0:	0001883a 	nop
8111d1f4:	e037883a 	mov	sp,fp
8111d1f8:	dfc00117 	ldw	ra,4(sp)
8111d1fc:	df000017 	ldw	fp,0(sp)
8111d200:	dec00204 	addi	sp,sp,8
8111d204:	f800283a 	ret

8111d208 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111d208:	defffe04 	addi	sp,sp,-8
8111d20c:	de00012e 	bgeu	sp,et,8111d214 <vCouldNotSendEthConfUART+0xc>
8111d210:	003b68fa 	trap	3
8111d214:	dfc00115 	stw	ra,4(sp)
8111d218:	df000015 	stw	fp,0(sp)
8111d21c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d220:	00a045f4 	movhi	r2,33047
8111d224:	10a00404 	addi	r2,r2,-32752
8111d228:	10800e8b 	ldhu	r2,58(r2)
8111d22c:	10bfffcc 	andi	r2,r2,65535
8111d230:	108001e8 	cmpgeui	r2,r2,7
8111d234:	10000e1e 	bne	r2,zero,8111d270 <vCouldNotSendEthConfUART+0x68>
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111d238:	d0a06217 	ldw	r2,-32376(gp)
8111d23c:	100f883a 	mov	r7,r2
8111d240:	01800844 	movi	r6,33
8111d244:	01400044 	movi	r5,1
8111d248:	01204574 	movhi	r4,33045
8111d24c:	21021804 	addi	r4,r4,2144
8111d250:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111d254:	d0a06217 	ldw	r2,-32376(gp)
8111d258:	100f883a 	mov	r7,r2
8111d25c:	01801784 	movi	r6,94
8111d260:	01400044 	movi	r5,1
8111d264:	01204574 	movhi	r4,33045
8111d268:	21022104 	addi	r4,r4,2180
8111d26c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d270:	0001883a 	nop
8111d274:	e037883a 	mov	sp,fp
8111d278:	dfc00117 	ldw	ra,4(sp)
8111d27c:	df000017 	ldw	fp,0(sp)
8111d280:	dec00204 	addi	sp,sp,8
8111d284:	f800283a 	ret

8111d288 <vFailSendNack>:

void vFailSendNack( void )
{
8111d288:	defffe04 	addi	sp,sp,-8
8111d28c:	de00012e 	bgeu	sp,et,8111d294 <vFailSendNack+0xc>
8111d290:	003b68fa 	trap	3
8111d294:	dfc00115 	stw	ra,4(sp)
8111d298:	df000015 	stw	fp,0(sp)
8111d29c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d2a0:	00a045f4 	movhi	r2,33047
8111d2a4:	10a00404 	addi	r2,r2,-32752
8111d2a8:	10800e8b 	ldhu	r2,58(r2)
8111d2ac:	10bfffcc 	andi	r2,r2,65535
8111d2b0:	108001e8 	cmpgeui	r2,r2,7
8111d2b4:	10000e1e 	bne	r2,zero,8111d2f0 <vFailSendNack+0x68>
		debug(fp,"vFailSendNack. (exit)\n");
8111d2b8:	d0a06217 	ldw	r2,-32376(gp)
8111d2bc:	100f883a 	mov	r7,r2
8111d2c0:	01800584 	movi	r6,22
8111d2c4:	01400044 	movi	r5,1
8111d2c8:	01204574 	movhi	r4,33045
8111d2cc:	21023904 	addi	r4,r4,2276
8111d2d0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111d2d4:	d0a06217 	ldw	r2,-32376(gp)
8111d2d8:	100f883a 	mov	r7,r2
8111d2dc:	01800a84 	movi	r6,42
8111d2e0:	01400044 	movi	r5,1
8111d2e4:	01204574 	movhi	r4,33045
8111d2e8:	21023f04 	addi	r4,r4,2300
8111d2ec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d2f0:	0001883a 	nop
8111d2f4:	e037883a 	mov	sp,fp
8111d2f8:	dfc00117 	ldw	ra,4(sp)
8111d2fc:	df000017 	ldw	fp,0(sp)
8111d300:	dec00204 	addi	sp,sp,8
8111d304:	f800283a 	ret

8111d308 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111d308:	defffe04 	addi	sp,sp,-8
8111d30c:	de00012e 	bgeu	sp,et,8111d314 <vFailSetPreAckSenderBuffer+0xc>
8111d310:	003b68fa 	trap	3
8111d314:	dfc00115 	stw	ra,4(sp)
8111d318:	df000015 	stw	fp,0(sp)
8111d31c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d320:	00a045f4 	movhi	r2,33047
8111d324:	10a00404 	addi	r2,r2,-32752
8111d328:	10800e8b 	ldhu	r2,58(r2)
8111d32c:	10bfffcc 	andi	r2,r2,65535
8111d330:	108001e8 	cmpgeui	r2,r2,7
8111d334:	10000e1e 	bne	r2,zero,8111d370 <vFailSetPreAckSenderBuffer+0x68>
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111d338:	d0a06217 	ldw	r2,-32376(gp)
8111d33c:	100f883a 	mov	r7,r2
8111d340:	018008c4 	movi	r6,35
8111d344:	01400044 	movi	r5,1
8111d348:	01204574 	movhi	r4,33045
8111d34c:	21024a04 	addi	r4,r4,2344
8111d350:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111d354:	d0a06217 	ldw	r2,-32376(gp)
8111d358:	100f883a 	mov	r7,r2
8111d35c:	01801584 	movi	r6,86
8111d360:	01400044 	movi	r5,1
8111d364:	01204574 	movhi	r4,33045
8111d368:	21025304 	addi	r4,r4,2380
8111d36c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d370:	0001883a 	nop
8111d374:	e037883a 	mov	sp,fp
8111d378:	dfc00117 	ldw	ra,4(sp)
8111d37c:	df000017 	ldw	fp,0(sp)
8111d380:	dec00204 	addi	sp,sp,8
8111d384:	f800283a 	ret

8111d388 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111d388:	defffe04 	addi	sp,sp,-8
8111d38c:	de00012e 	bgeu	sp,et,8111d394 <vFailSetPreParsedBuffer+0xc>
8111d390:	003b68fa 	trap	3
8111d394:	dfc00115 	stw	ra,4(sp)
8111d398:	df000015 	stw	fp,0(sp)
8111d39c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d3a0:	00a045f4 	movhi	r2,33047
8111d3a4:	10a00404 	addi	r2,r2,-32752
8111d3a8:	10800e8b 	ldhu	r2,58(r2)
8111d3ac:	10bfffcc 	andi	r2,r2,65535
8111d3b0:	108001e8 	cmpgeui	r2,r2,7
8111d3b4:	10000e1e 	bne	r2,zero,8111d3f0 <vFailSetPreParsedBuffer+0x68>
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111d3b8:	d0a06217 	ldw	r2,-32376(gp)
8111d3bc:	100f883a 	mov	r7,r2
8111d3c0:	01800804 	movi	r6,32
8111d3c4:	01400044 	movi	r5,1
8111d3c8:	01204574 	movhi	r4,33045
8111d3cc:	21026904 	addi	r4,r4,2468
8111d3d0:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111d3d4:	d0a06217 	ldw	r2,-32376(gp)
8111d3d8:	100f883a 	mov	r7,r2
8111d3dc:	018013c4 	movi	r6,79
8111d3e0:	01400044 	movi	r5,1
8111d3e4:	01204574 	movhi	r4,33045
8111d3e8:	21027204 	addi	r4,r4,2504
8111d3ec:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d3f0:	0001883a 	nop
8111d3f4:	e037883a 	mov	sp,fp
8111d3f8:	dfc00117 	ldw	ra,4(sp)
8111d3fc:	df000017 	ldw	fp,0(sp)
8111d400:	dec00204 	addi	sp,sp,8
8111d404:	f800283a 	ret

8111d408 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111d408:	defffe04 	addi	sp,sp,-8
8111d40c:	de00012e 	bgeu	sp,et,8111d414 <vFailSetPreAckReceiverBuffer+0xc>
8111d410:	003b68fa 	trap	3
8111d414:	dfc00115 	stw	ra,4(sp)
8111d418:	df000015 	stw	fp,0(sp)
8111d41c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d420:	00a045f4 	movhi	r2,33047
8111d424:	10a00404 	addi	r2,r2,-32752
8111d428:	10800e8b 	ldhu	r2,58(r2)
8111d42c:	10bfffcc 	andi	r2,r2,65535
8111d430:	108001e8 	cmpgeui	r2,r2,7
8111d434:	10000e1e 	bne	r2,zero,8111d470 <vFailSetPreAckReceiverBuffer+0x68>
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111d438:	d0a06217 	ldw	r2,-32376(gp)
8111d43c:	100f883a 	mov	r7,r2
8111d440:	01800944 	movi	r6,37
8111d444:	01400044 	movi	r5,1
8111d448:	01204574 	movhi	r4,33045
8111d44c:	21028604 	addi	r4,r4,2584
8111d450:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111d454:	d0a06217 	ldw	r2,-32376(gp)
8111d458:	100f883a 	mov	r7,r2
8111d45c:	018015c4 	movi	r6,87
8111d460:	01400044 	movi	r5,1
8111d464:	01204574 	movhi	r4,33045
8111d468:	21029004 	addi	r4,r4,2624
8111d46c:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d470:	0001883a 	nop
8111d474:	e037883a 	mov	sp,fp
8111d478:	dfc00117 	ldw	ra,4(sp)
8111d47c:	df000017 	ldw	fp,0(sp)
8111d480:	dec00204 	addi	sp,sp,8
8111d484:	f800283a 	ret

8111d488 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111d488:	defffe04 	addi	sp,sp,-8
8111d48c:	de00012e 	bgeu	sp,et,8111d494 <vFailParserCommTaskCreate+0xc>
8111d490:	003b68fa 	trap	3
8111d494:	dfc00115 	stw	ra,4(sp)
8111d498:	df000015 	stw	fp,0(sp)
8111d49c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d4a0:	00a045f4 	movhi	r2,33047
8111d4a4:	10a00404 	addi	r2,r2,-32752
8111d4a8:	10800e8b 	ldhu	r2,58(r2)
8111d4ac:	10bfffcc 	andi	r2,r2,65535
8111d4b0:	108001e8 	cmpgeui	r2,r2,7
8111d4b4:	1000071e 	bne	r2,zero,8111d4d4 <vFailParserCommTaskCreate+0x4c>
		debug(fp,"vFailParserCommTaskCreate\n");
8111d4b8:	d0a06217 	ldw	r2,-32376(gp)
8111d4bc:	100f883a 	mov	r7,r2
8111d4c0:	01800684 	movi	r6,26
8111d4c4:	01400044 	movi	r5,1
8111d4c8:	01204574 	movhi	r4,33045
8111d4cc:	2102a604 	addi	r4,r4,2712
8111d4d0:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d4d4:	0001883a 	nop
8111d4d8:	e037883a 	mov	sp,fp
8111d4dc:	dfc00117 	ldw	ra,4(sp)
8111d4e0:	df000017 	ldw	fp,0(sp)
8111d4e4:	dec00204 	addi	sp,sp,8
8111d4e8:	f800283a 	ret

8111d4ec <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111d4ec:	defffe04 	addi	sp,sp,-8
8111d4f0:	de00012e 	bgeu	sp,et,8111d4f8 <vFailInAckHandlerTaskCreate+0xc>
8111d4f4:	003b68fa 	trap	3
8111d4f8:	dfc00115 	stw	ra,4(sp)
8111d4fc:	df000015 	stw	fp,0(sp)
8111d500:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d504:	00a045f4 	movhi	r2,33047
8111d508:	10a00404 	addi	r2,r2,-32752
8111d50c:	10800e8b 	ldhu	r2,58(r2)
8111d510:	10bfffcc 	andi	r2,r2,65535
8111d514:	108001e8 	cmpgeui	r2,r2,7
8111d518:	1000071e 	bne	r2,zero,8111d538 <vFailInAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111d51c:	d0a06217 	ldw	r2,-32376(gp)
8111d520:	100f883a 	mov	r7,r2
8111d524:	01800704 	movi	r6,28
8111d528:	01400044 	movi	r5,1
8111d52c:	01204574 	movhi	r4,33045
8111d530:	2102ad04 	addi	r4,r4,2740
8111d534:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d538:	0001883a 	nop
8111d53c:	e037883a 	mov	sp,fp
8111d540:	dfc00117 	ldw	ra,4(sp)
8111d544:	df000017 	ldw	fp,0(sp)
8111d548:	dec00204 	addi	sp,sp,8
8111d54c:	f800283a 	ret

8111d550 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111d550:	defffe04 	addi	sp,sp,-8
8111d554:	de00012e 	bgeu	sp,et,8111d55c <vFailOutAckHandlerTaskCreate+0xc>
8111d558:	003b68fa 	trap	3
8111d55c:	dfc00115 	stw	ra,4(sp)
8111d560:	df000015 	stw	fp,0(sp)
8111d564:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d568:	00a045f4 	movhi	r2,33047
8111d56c:	10a00404 	addi	r2,r2,-32752
8111d570:	10800e8b 	ldhu	r2,58(r2)
8111d574:	10bfffcc 	andi	r2,r2,65535
8111d578:	108001e8 	cmpgeui	r2,r2,7
8111d57c:	1000071e 	bne	r2,zero,8111d59c <vFailOutAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111d580:	d0a06217 	ldw	r2,-32376(gp)
8111d584:	100f883a 	mov	r7,r2
8111d588:	01800704 	movi	r6,28
8111d58c:	01400044 	movi	r5,1
8111d590:	01204574 	movhi	r4,33045
8111d594:	2102ad04 	addi	r4,r4,2740
8111d598:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d59c:	0001883a 	nop
8111d5a0:	e037883a 	mov	sp,fp
8111d5a4:	dfc00117 	ldw	ra,4(sp)
8111d5a8:	df000017 	ldw	fp,0(sp)
8111d5ac:	dec00204 	addi	sp,sp,8
8111d5b0:	f800283a 	ret

8111d5b4 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111d5b4:	defffe04 	addi	sp,sp,-8
8111d5b8:	de00012e 	bgeu	sp,et,8111d5c0 <vFailCreateTimerRetransmisison+0xc>
8111d5bc:	003b68fa 	trap	3
8111d5c0:	dfc00115 	stw	ra,4(sp)
8111d5c4:	df000015 	stw	fp,0(sp)
8111d5c8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d5cc:	00a045f4 	movhi	r2,33047
8111d5d0:	10a00404 	addi	r2,r2,-32752
8111d5d4:	10800e8b 	ldhu	r2,58(r2)
8111d5d8:	10bfffcc 	andi	r2,r2,65535
8111d5dc:	108001e8 	cmpgeui	r2,r2,7
8111d5e0:	1000071e 	bne	r2,zero,8111d600 <vFailCreateTimerRetransmisison+0x4c>
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111d5e4:	d0a06217 	ldw	r2,-32376(gp)
8111d5e8:	100f883a 	mov	r7,r2
8111d5ec:	018007c4 	movi	r6,31
8111d5f0:	01400044 	movi	r5,1
8111d5f4:	01204574 	movhi	r4,33045
8111d5f8:	2102b504 	addi	r4,r4,2772
8111d5fc:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d600:	0001883a 	nop
8111d604:	e037883a 	mov	sp,fp
8111d608:	dfc00117 	ldw	ra,4(sp)
8111d60c:	df000017 	ldw	fp,0(sp)
8111d610:	dec00204 	addi	sp,sp,8
8111d614:	f800283a 	ret

8111d618 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111d618:	defffe04 	addi	sp,sp,-8
8111d61c:	de00012e 	bgeu	sp,et,8111d624 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111d620:	003b68fa 	trap	3
8111d624:	dfc00115 	stw	ra,4(sp)
8111d628:	df000015 	stw	fp,0(sp)
8111d62c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d630:	00a045f4 	movhi	r2,33047
8111d634:	10a00404 	addi	r2,r2,-32752
8111d638:	10800e8b 	ldhu	r2,58(r2)
8111d63c:	10bfffcc 	andi	r2,r2,65535
8111d640:	108001e8 	cmpgeui	r2,r2,7
8111d644:	1000071e 	bne	r2,zero,8111d664 <vCouldNotCheckBufferTimeOutFunction+0x4c>
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111d648:	d0a06217 	ldw	r2,-32376(gp)
8111d64c:	100f883a 	mov	r7,r2
8111d650:	01800904 	movi	r6,36
8111d654:	01400044 	movi	r5,1
8111d658:	01204574 	movhi	r4,33045
8111d65c:	2102bd04 	addi	r4,r4,2804
8111d660:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d664:	0001883a 	nop
8111d668:	e037883a 	mov	sp,fp
8111d66c:	dfc00117 	ldw	ra,4(sp)
8111d670:	df000017 	ldw	fp,0(sp)
8111d674:	dec00204 	addi	sp,sp,8
8111d678:	f800283a 	ret

8111d67c <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111d67c:	defffe04 	addi	sp,sp,-8
8111d680:	de00012e 	bgeu	sp,et,8111d688 <vFailTimeoutCheckerTaskCreate+0xc>
8111d684:	003b68fa 	trap	3
8111d688:	dfc00115 	stw	ra,4(sp)
8111d68c:	df000015 	stw	fp,0(sp)
8111d690:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d694:	00a045f4 	movhi	r2,33047
8111d698:	10a00404 	addi	r2,r2,-32752
8111d69c:	10800e8b 	ldhu	r2,58(r2)
8111d6a0:	10bfffcc 	andi	r2,r2,65535
8111d6a4:	108001e8 	cmpgeui	r2,r2,7
8111d6a8:	1000071e 	bne	r2,zero,8111d6c8 <vFailTimeoutCheckerTaskCreate+0x4c>
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111d6ac:	d0a06217 	ldw	r2,-32376(gp)
8111d6b0:	100f883a 	mov	r7,r2
8111d6b4:	01800a04 	movi	r6,40
8111d6b8:	01400044 	movi	r5,1
8111d6bc:	01204574 	movhi	r4,33045
8111d6c0:	2102c704 	addi	r4,r4,2844
8111d6c4:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d6c8:	0001883a 	nop
8111d6cc:	e037883a 	mov	sp,fp
8111d6d0:	dfc00117 	ldw	ra,4(sp)
8111d6d4:	df000017 	ldw	fp,0(sp)
8111d6d8:	dec00204 	addi	sp,sp,8
8111d6dc:	f800283a 	ret

8111d6e0 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111d6e0:	defffe04 	addi	sp,sp,-8
8111d6e4:	de00012e 	bgeu	sp,et,8111d6ec <vFailGetBlockingSemTimeoutTask+0xc>
8111d6e8:	003b68fa 	trap	3
8111d6ec:	dfc00115 	stw	ra,4(sp)
8111d6f0:	df000015 	stw	fp,0(sp)
8111d6f4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d6f8:	00a045f4 	movhi	r2,33047
8111d6fc:	10a00404 	addi	r2,r2,-32752
8111d700:	10800e8b 	ldhu	r2,58(r2)
8111d704:	10bfffcc 	andi	r2,r2,65535
8111d708:	108001e8 	cmpgeui	r2,r2,7
8111d70c:	10000e1e 	bne	r2,zero,8111d748 <vFailGetBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111d710:	d0a06217 	ldw	r2,-32376(gp)
8111d714:	100f883a 	mov	r7,r2
8111d718:	018009c4 	movi	r6,39
8111d71c:	01400044 	movi	r5,1
8111d720:	01204574 	movhi	r4,33045
8111d724:	2102d204 	addi	r4,r4,2888
8111d728:	11230300 	call	81123030 <fwrite>
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111d72c:	d0a06217 	ldw	r2,-32376(gp)
8111d730:	100f883a 	mov	r7,r2
8111d734:	01800cc4 	movi	r6,51
8111d738:	01400044 	movi	r5,1
8111d73c:	01204574 	movhi	r4,33045
8111d740:	2102dc04 	addi	r4,r4,2928
8111d744:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d748:	0001883a 	nop
8111d74c:	e037883a 	mov	sp,fp
8111d750:	dfc00117 	ldw	ra,4(sp)
8111d754:	df000017 	ldw	fp,0(sp)
8111d758:	dec00204 	addi	sp,sp,8
8111d75c:	f800283a 	ret

8111d760 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111d760:	defffe04 	addi	sp,sp,-8
8111d764:	de00012e 	bgeu	sp,et,8111d76c <vFailPostBlockingSemTimeoutTask+0xc>
8111d768:	003b68fa 	trap	3
8111d76c:	dfc00115 	stw	ra,4(sp)
8111d770:	df000015 	stw	fp,0(sp)
8111d774:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d778:	00a045f4 	movhi	r2,33047
8111d77c:	10a00404 	addi	r2,r2,-32752
8111d780:	10800e8b 	ldhu	r2,58(r2)
8111d784:	10bfffcc 	andi	r2,r2,65535
8111d788:	108001e8 	cmpgeui	r2,r2,7
8111d78c:	10000e1e 	bne	r2,zero,8111d7c8 <vFailPostBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111d790:	d0a06217 	ldw	r2,-32376(gp)
8111d794:	100f883a 	mov	r7,r2
8111d798:	01800a04 	movi	r6,40
8111d79c:	01400044 	movi	r5,1
8111d7a0:	01204574 	movhi	r4,33045
8111d7a4:	2102e904 	addi	r4,r4,2980
8111d7a8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111d7ac:	d0a06217 	ldw	r2,-32376(gp)
8111d7b0:	100f883a 	mov	r7,r2
8111d7b4:	01800c84 	movi	r6,50
8111d7b8:	01400044 	movi	r5,1
8111d7bc:	01204574 	movhi	r4,33045
8111d7c0:	2102f404 	addi	r4,r4,3024
8111d7c4:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d7c8:	0001883a 	nop
8111d7cc:	e037883a 	mov	sp,fp
8111d7d0:	dfc00117 	ldw	ra,4(sp)
8111d7d4:	df000017 	ldw	fp,0(sp)
8111d7d8:	dec00204 	addi	sp,sp,8
8111d7dc:	f800283a 	ret

8111d7e0 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111d7e0:	defffe04 	addi	sp,sp,-8
8111d7e4:	de00012e 	bgeu	sp,et,8111d7ec <vFailCouldNotRetransmitTimeoutTask+0xc>
8111d7e8:	003b68fa 	trap	3
8111d7ec:	dfc00115 	stw	ra,4(sp)
8111d7f0:	df000015 	stw	fp,0(sp)
8111d7f4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d7f8:	00a045f4 	movhi	r2,33047
8111d7fc:	10a00404 	addi	r2,r2,-32752
8111d800:	10800e8b 	ldhu	r2,58(r2)
8111d804:	10bfffcc 	andi	r2,r2,65535
8111d808:	108001e8 	cmpgeui	r2,r2,7
8111d80c:	10000e1e 	bne	r2,zero,8111d848 <vFailCouldNotRetransmitTimeoutTask+0x68>
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111d810:	d0a06217 	ldw	r2,-32376(gp)
8111d814:	100f883a 	mov	r7,r2
8111d818:	01800ac4 	movi	r6,43
8111d81c:	01400044 	movi	r5,1
8111d820:	01204574 	movhi	r4,33045
8111d824:	21030104 	addi	r4,r4,3076
8111d828:	11230300 	call	81123030 <fwrite>
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111d82c:	d0a06217 	ldw	r2,-32376(gp)
8111d830:	100f883a 	mov	r7,r2
8111d834:	01801644 	movi	r6,89
8111d838:	01400044 	movi	r5,1
8111d83c:	01204574 	movhi	r4,33045
8111d840:	21030c04 	addi	r4,r4,3120
8111d844:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d848:	0001883a 	nop
8111d84c:	e037883a 	mov	sp,fp
8111d850:	dfc00117 	ldw	ra,4(sp)
8111d854:	df000017 	ldw	fp,0(sp)
8111d858:	dec00204 	addi	sp,sp,8
8111d85c:	f800283a 	ret

8111d860 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111d860:	defffe04 	addi	sp,sp,-8
8111d864:	de00012e 	bgeu	sp,et,8111d86c <vCouldNotRetransmitB32TimeoutTask+0xc>
8111d868:	003b68fa 	trap	3
8111d86c:	dfc00115 	stw	ra,4(sp)
8111d870:	df000015 	stw	fp,0(sp)
8111d874:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d878:	00a045f4 	movhi	r2,33047
8111d87c:	10a00404 	addi	r2,r2,-32752
8111d880:	10800e8b 	ldhu	r2,58(r2)
8111d884:	10bfffcc 	andi	r2,r2,65535
8111d888:	108001e8 	cmpgeui	r2,r2,7
8111d88c:	10000e1e 	bne	r2,zero,8111d8c8 <vCouldNotRetransmitB32TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111d890:	d0a06217 	ldw	r2,-32376(gp)
8111d894:	100f883a 	mov	r7,r2
8111d898:	01800a84 	movi	r6,42
8111d89c:	01400044 	movi	r5,1
8111d8a0:	01204574 	movhi	r4,33045
8111d8a4:	21032304 	addi	r4,r4,3212
8111d8a8:	11230300 	call	81123030 <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111d8ac:	d0a06217 	ldw	r2,-32376(gp)
8111d8b0:	100f883a 	mov	r7,r2
8111d8b4:	01801444 	movi	r6,81
8111d8b8:	01400044 	movi	r5,1
8111d8bc:	01204574 	movhi	r4,33045
8111d8c0:	21032e04 	addi	r4,r4,3256
8111d8c4:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d8c8:	0001883a 	nop
8111d8cc:	e037883a 	mov	sp,fp
8111d8d0:	dfc00117 	ldw	ra,4(sp)
8111d8d4:	df000017 	ldw	fp,0(sp)
8111d8d8:	dec00204 	addi	sp,sp,8
8111d8dc:	f800283a 	ret

8111d8e0 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111d8e0:	defffe04 	addi	sp,sp,-8
8111d8e4:	de00012e 	bgeu	sp,et,8111d8ec <vCouldNotRetransmitB64TimeoutTask+0xc>
8111d8e8:	003b68fa 	trap	3
8111d8ec:	dfc00115 	stw	ra,4(sp)
8111d8f0:	df000015 	stw	fp,0(sp)
8111d8f4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d8f8:	00a045f4 	movhi	r2,33047
8111d8fc:	10a00404 	addi	r2,r2,-32752
8111d900:	10800e8b 	ldhu	r2,58(r2)
8111d904:	10bfffcc 	andi	r2,r2,65535
8111d908:	108001e8 	cmpgeui	r2,r2,7
8111d90c:	10000e1e 	bne	r2,zero,8111d948 <vCouldNotRetransmitB64TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111d910:	d0a06217 	ldw	r2,-32376(gp)
8111d914:	100f883a 	mov	r7,r2
8111d918:	01800a84 	movi	r6,42
8111d91c:	01400044 	movi	r5,1
8111d920:	01204574 	movhi	r4,33045
8111d924:	21034304 	addi	r4,r4,3340
8111d928:	11230300 	call	81123030 <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111d92c:	d0a06217 	ldw	r2,-32376(gp)
8111d930:	100f883a 	mov	r7,r2
8111d934:	01801444 	movi	r6,81
8111d938:	01400044 	movi	r5,1
8111d93c:	01204574 	movhi	r4,33045
8111d940:	21034e04 	addi	r4,r4,3384
8111d944:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d948:	0001883a 	nop
8111d94c:	e037883a 	mov	sp,fp
8111d950:	dfc00117 	ldw	ra,4(sp)
8111d954:	df000017 	ldw	fp,0(sp)
8111d958:	dec00204 	addi	sp,sp,8
8111d95c:	f800283a 	ret

8111d960 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111d960:	defffe04 	addi	sp,sp,-8
8111d964:	de00012e 	bgeu	sp,et,8111d96c <vCouldNotRetransmitB128TimeoutTask+0xc>
8111d968:	003b68fa 	trap	3
8111d96c:	dfc00115 	stw	ra,4(sp)
8111d970:	df000015 	stw	fp,0(sp)
8111d974:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d978:	00a045f4 	movhi	r2,33047
8111d97c:	10a00404 	addi	r2,r2,-32752
8111d980:	10800e8b 	ldhu	r2,58(r2)
8111d984:	10bfffcc 	andi	r2,r2,65535
8111d988:	108001e8 	cmpgeui	r2,r2,7
8111d98c:	10000e1e 	bne	r2,zero,8111d9c8 <vCouldNotRetransmitB128TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111d990:	d0a06217 	ldw	r2,-32376(gp)
8111d994:	100f883a 	mov	r7,r2
8111d998:	01800ac4 	movi	r6,43
8111d99c:	01400044 	movi	r5,1
8111d9a0:	01204574 	movhi	r4,33045
8111d9a4:	21036304 	addi	r4,r4,3468
8111d9a8:	11230300 	call	81123030 <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111d9ac:	d0a06217 	ldw	r2,-32376(gp)
8111d9b0:	100f883a 	mov	r7,r2
8111d9b4:	01801484 	movi	r6,82
8111d9b8:	01400044 	movi	r5,1
8111d9bc:	01204574 	movhi	r4,33045
8111d9c0:	21036e04 	addi	r4,r4,3512
8111d9c4:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d9c8:	0001883a 	nop
8111d9cc:	e037883a 	mov	sp,fp
8111d9d0:	dfc00117 	ldw	ra,4(sp)
8111d9d4:	df000017 	ldw	fp,0(sp)
8111d9d8:	dec00204 	addi	sp,sp,8
8111d9dc:	f800283a 	ret

8111d9e0 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111d9e0:	defffe04 	addi	sp,sp,-8
8111d9e4:	de00012e 	bgeu	sp,et,8111d9ec <vFailStartTimerRetransmission+0xc>
8111d9e8:	003b68fa 	trap	3
8111d9ec:	dfc00115 	stw	ra,4(sp)
8111d9f0:	df000015 	stw	fp,0(sp)
8111d9f4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d9f8:	00a045f4 	movhi	r2,33047
8111d9fc:	10a00404 	addi	r2,r2,-32752
8111da00:	10800e8b 	ldhu	r2,58(r2)
8111da04:	10bfffcc 	andi	r2,r2,65535
8111da08:	108001e8 	cmpgeui	r2,r2,7
8111da0c:	10000e1e 	bne	r2,zero,8111da48 <vFailStartTimerRetransmission+0x68>
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111da10:	d0a06217 	ldw	r2,-32376(gp)
8111da14:	100f883a 	mov	r7,r2
8111da18:	01800984 	movi	r6,38
8111da1c:	01400044 	movi	r5,1
8111da20:	01204574 	movhi	r4,33045
8111da24:	21038304 	addi	r4,r4,3596
8111da28:	11230300 	call	81123030 <fwrite>
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111da2c:	d0a06217 	ldw	r2,-32376(gp)
8111da30:	100f883a 	mov	r7,r2
8111da34:	01800d44 	movi	r6,53
8111da38:	01400044 	movi	r5,1
8111da3c:	01204574 	movhi	r4,33045
8111da40:	21038d04 	addi	r4,r4,3636
8111da44:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111da48:	0001883a 	nop
8111da4c:	e037883a 	mov	sp,fp
8111da50:	dfc00117 	ldw	ra,4(sp)
8111da54:	df000017 	ldw	fp,0(sp)
8111da58:	dec00204 	addi	sp,sp,8
8111da5c:	f800283a 	ret

8111da60 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111da60:	defffe04 	addi	sp,sp,-8
8111da64:	de00012e 	bgeu	sp,et,8111da6c <vCouldNotSendTurnOff+0xc>
8111da68:	003b68fa 	trap	3
8111da6c:	dfc00115 	stw	ra,4(sp)
8111da70:	df000015 	stw	fp,0(sp)
8111da74:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111da78:	00a045f4 	movhi	r2,33047
8111da7c:	10a00404 	addi	r2,r2,-32752
8111da80:	10800e8b 	ldhu	r2,58(r2)
8111da84:	10bfffcc 	andi	r2,r2,65535
8111da88:	108001e8 	cmpgeui	r2,r2,7
8111da8c:	10000e1e 	bne	r2,zero,8111dac8 <vCouldNotSendTurnOff+0x68>
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111da90:	d0a06217 	ldw	r2,-32376(gp)
8111da94:	100f883a 	mov	r7,r2
8111da98:	01800744 	movi	r6,29
8111da9c:	01400044 	movi	r5,1
8111daa0:	01204574 	movhi	r4,33045
8111daa4:	21039b04 	addi	r4,r4,3692
8111daa8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the turn off command. \n");
8111daac:	d0a06217 	ldw	r2,-32376(gp)
8111dab0:	100f883a 	mov	r7,r2
8111dab4:	01800984 	movi	r6,38
8111dab8:	01400044 	movi	r5,1
8111dabc:	01204574 	movhi	r4,33045
8111dac0:	2103a304 	addi	r4,r4,3724
8111dac4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dac8:	0001883a 	nop
8111dacc:	e037883a 	mov	sp,fp
8111dad0:	dfc00117 	ldw	ra,4(sp)
8111dad4:	df000017 	ldw	fp,0(sp)
8111dad8:	dec00204 	addi	sp,sp,8
8111dadc:	f800283a 	ret

8111dae0 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111dae0:	defffe04 	addi	sp,sp,-8
8111dae4:	de00012e 	bgeu	sp,et,8111daec <vCouldNotSendReset+0xc>
8111dae8:	003b68fa 	trap	3
8111daec:	dfc00115 	stw	ra,4(sp)
8111daf0:	df000015 	stw	fp,0(sp)
8111daf4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111daf8:	00a045f4 	movhi	r2,33047
8111dafc:	10a00404 	addi	r2,r2,-32752
8111db00:	10800e8b 	ldhu	r2,58(r2)
8111db04:	10bfffcc 	andi	r2,r2,65535
8111db08:	108001e8 	cmpgeui	r2,r2,7
8111db0c:	10000e1e 	bne	r2,zero,8111db48 <vCouldNotSendReset+0x68>
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111db10:	d0a06217 	ldw	r2,-32376(gp)
8111db14:	100f883a 	mov	r7,r2
8111db18:	018006c4 	movi	r6,27
8111db1c:	01400044 	movi	r5,1
8111db20:	01204574 	movhi	r4,33045
8111db24:	2103ad04 	addi	r4,r4,3764
8111db28:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the reset command. \n");
8111db2c:	d0a06217 	ldw	r2,-32376(gp)
8111db30:	100f883a 	mov	r7,r2
8111db34:	018008c4 	movi	r6,35
8111db38:	01400044 	movi	r5,1
8111db3c:	01204574 	movhi	r4,33045
8111db40:	2103b404 	addi	r4,r4,3792
8111db44:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111db48:	0001883a 	nop
8111db4c:	e037883a 	mov	sp,fp
8111db50:	dfc00117 	ldw	ra,4(sp)
8111db54:	df000017 	ldw	fp,0(sp)
8111db58:	dec00204 	addi	sp,sp,8
8111db5c:	f800283a 	ret

8111db60 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111db60:	defffe04 	addi	sp,sp,-8
8111db64:	de00012e 	bgeu	sp,et,8111db6c <vCouldNotSendLog+0xc>
8111db68:	003b68fa 	trap	3
8111db6c:	dfc00115 	stw	ra,4(sp)
8111db70:	df000015 	stw	fp,0(sp)
8111db74:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111db78:	00a045f4 	movhi	r2,33047
8111db7c:	10a00404 	addi	r2,r2,-32752
8111db80:	10800e8b 	ldhu	r2,58(r2)
8111db84:	10bfffcc 	andi	r2,r2,65535
8111db88:	108001e8 	cmpgeui	r2,r2,7
8111db8c:	10000e1e 	bne	r2,zero,8111dbc8 <vCouldNotSendLog+0x68>
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111db90:	d0a06217 	ldw	r2,-32376(gp)
8111db94:	100f883a 	mov	r7,r2
8111db98:	01800644 	movi	r6,25
8111db9c:	01400044 	movi	r5,1
8111dba0:	01204574 	movhi	r4,33045
8111dba4:	2103bd04 	addi	r4,r4,3828
8111dba8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send log packet to NUC. \n");
8111dbac:	d0a06217 	ldw	r2,-32376(gp)
8111dbb0:	100f883a 	mov	r7,r2
8111dbb4:	018008c4 	movi	r6,35
8111dbb8:	01400044 	movi	r5,1
8111dbbc:	01204574 	movhi	r4,33045
8111dbc0:	2103c404 	addi	r4,r4,3856
8111dbc4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dbc8:	0001883a 	nop
8111dbcc:	e037883a 	mov	sp,fp
8111dbd0:	dfc00117 	ldw	ra,4(sp)
8111dbd4:	df000017 	ldw	fp,0(sp)
8111dbd8:	dec00204 	addi	sp,sp,8
8111dbdc:	f800283a 	ret

8111dbe0 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111dbe0:	defffd04 	addi	sp,sp,-12
8111dbe4:	de00012e 	bgeu	sp,et,8111dbec <vCouldNotSendTMPusCommand+0xc>
8111dbe8:	003b68fa 	trap	3
8111dbec:	dfc00215 	stw	ra,8(sp)
8111dbf0:	df000115 	stw	fp,4(sp)
8111dbf4:	df000104 	addi	fp,sp,4
8111dbf8:	e13fff15 	stw	r4,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dbfc:	00a045f4 	movhi	r2,33047
8111dc00:	10a00404 	addi	r2,r2,-32752
8111dc04:	10800e8b 	ldhu	r2,58(r2)
8111dc08:	10bfffcc 	andi	r2,r2,65535
8111dc0c:	108001e8 	cmpgeui	r2,r2,7
8111dc10:	1000151e 	bne	r2,zero,8111dc68 <vCouldNotSendTMPusCommand+0x88>
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111dc14:	d0a06217 	ldw	r2,-32376(gp)
8111dc18:	100f883a 	mov	r7,r2
8111dc1c:	01800884 	movi	r6,34
8111dc20:	01400044 	movi	r5,1
8111dc24:	01204574 	movhi	r4,33045
8111dc28:	2103cd04 	addi	r4,r4,3892
8111dc2c:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111dc30:	d0a06217 	ldw	r2,-32376(gp)
8111dc34:	100f883a 	mov	r7,r2
8111dc38:	01800ac4 	movi	r6,43
8111dc3c:	01400044 	movi	r5,1
8111dc40:	01204574 	movhi	r4,33045
8111dc44:	2103d604 	addi	r4,r4,3928
8111dc48:	11230300 	call	81123030 <fwrite>
		debug(fp,"cData");
8111dc4c:	d0a06217 	ldw	r2,-32376(gp)
8111dc50:	100f883a 	mov	r7,r2
8111dc54:	01800144 	movi	r6,5
8111dc58:	01400044 	movi	r5,1
8111dc5c:	01204574 	movhi	r4,33045
8111dc60:	2103e104 	addi	r4,r4,3972
8111dc64:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dc68:	0001883a 	nop
8111dc6c:	e037883a 	mov	sp,fp
8111dc70:	dfc00117 	ldw	ra,4(sp)
8111dc74:	df000017 	ldw	fp,0(sp)
8111dc78:	dec00204 	addi	sp,sp,8
8111dc7c:	f800283a 	ret

8111dc80 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111dc80:	defffe04 	addi	sp,sp,-8
8111dc84:	de00012e 	bgeu	sp,et,8111dc8c <vWarnCouldNotgetMutexRetrans128+0xc>
8111dc88:	003b68fa 	trap	3
8111dc8c:	dfc00115 	stw	ra,4(sp)
8111dc90:	df000015 	stw	fp,0(sp)
8111dc94:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dc98:	00a045f4 	movhi	r2,33047
8111dc9c:	10a00404 	addi	r2,r2,-32752
8111dca0:	10800e8b 	ldhu	r2,58(r2)
8111dca4:	10bfffcc 	andi	r2,r2,65535
8111dca8:	108001e8 	cmpgeui	r2,r2,7
8111dcac:	10000e1e 	bne	r2,zero,8111dce8 <vWarnCouldNotgetMutexRetrans128+0x68>
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111dcb0:	d0a06217 	ldw	r2,-32376(gp)
8111dcb4:	100f883a 	mov	r7,r2
8111dcb8:	01800a04 	movi	r6,40
8111dcbc:	01400044 	movi	r5,1
8111dcc0:	01204574 	movhi	r4,33045
8111dcc4:	2103e304 	addi	r4,r4,3980
8111dcc8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111dccc:	d0a06217 	ldw	r2,-32376(gp)
8111dcd0:	100f883a 	mov	r7,r2
8111dcd4:	018014c4 	movi	r6,83
8111dcd8:	01400044 	movi	r5,1
8111dcdc:	01204574 	movhi	r4,33045
8111dce0:	2103ee04 	addi	r4,r4,4024
8111dce4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dce8:	0001883a 	nop
8111dcec:	e037883a 	mov	sp,fp
8111dcf0:	dfc00117 	ldw	ra,4(sp)
8111dcf4:	df000017 	ldw	fp,0(sp)
8111dcf8:	dec00204 	addi	sp,sp,8
8111dcfc:	f800283a 	ret

8111dd00 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111dd00:	defffe04 	addi	sp,sp,-8
8111dd04:	de00012e 	bgeu	sp,et,8111dd0c <vFailCreateScheduleQueue+0xc>
8111dd08:	003b68fa 	trap	3
8111dd0c:	dfc00115 	stw	ra,4(sp)
8111dd10:	df000015 	stw	fp,0(sp)
8111dd14:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dd18:	00a045f4 	movhi	r2,33047
8111dd1c:	10a00404 	addi	r2,r2,-32752
8111dd20:	10800e8b 	ldhu	r2,58(r2)
8111dd24:	10bfffcc 	andi	r2,r2,65535
8111dd28:	108001e8 	cmpgeui	r2,r2,7
8111dd2c:	10000e1e 	bne	r2,zero,8111dd68 <vFailCreateScheduleQueue+0x68>
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111dd30:	d0a06217 	ldw	r2,-32376(gp)
8111dd34:	100f883a 	mov	r7,r2
8111dd38:	01800844 	movi	r6,33
8111dd3c:	01400044 	movi	r5,1
8111dd40:	01204574 	movhi	r4,33045
8111dd44:	21040304 	addi	r4,r4,4108
8111dd48:	11230300 	call	81123030 <fwrite>
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111dd4c:	d0a06217 	ldw	r2,-32376(gp)
8111dd50:	100f883a 	mov	r7,r2
8111dd54:	01801204 	movi	r6,72
8111dd58:	01400044 	movi	r5,1
8111dd5c:	01204574 	movhi	r4,33045
8111dd60:	21040c04 	addi	r4,r4,4144
8111dd64:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dd68:	0001883a 	nop
8111dd6c:	e037883a 	mov	sp,fp
8111dd70:	dfc00117 	ldw	ra,4(sp)
8111dd74:	df000017 	ldw	fp,0(sp)
8111dd78:	dec00204 	addi	sp,sp,8
8111dd7c:	f800283a 	ret

8111dd80 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111dd80:	defffd04 	addi	sp,sp,-12
8111dd84:	de00012e 	bgeu	sp,et,8111dd8c <vFailCreateNFEEQueue+0xc>
8111dd88:	003b68fa 	trap	3
8111dd8c:	dfc00215 	stw	ra,8(sp)
8111dd90:	df000115 	stw	fp,4(sp)
8111dd94:	df000104 	addi	fp,sp,4
8111dd98:	2005883a 	mov	r2,r4
8111dd9c:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dda0:	00a045f4 	movhi	r2,33047
8111dda4:	10a00404 	addi	r2,r2,-32752
8111dda8:	10800e8b 	ldhu	r2,58(r2)
8111ddac:	10bfffcc 	andi	r2,r2,65535
8111ddb0:	108001e8 	cmpgeui	r2,r2,7
8111ddb4:	10000e1e 	bne	r2,zero,8111ddf0 <vFailCreateNFEEQueue+0x70>
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111ddb8:	d0a06217 	ldw	r2,-32376(gp)
8111ddbc:	100f883a 	mov	r7,r2
8111ddc0:	01800744 	movi	r6,29
8111ddc4:	01400044 	movi	r5,1
8111ddc8:	01204574 	movhi	r4,33045
8111ddcc:	21041f04 	addi	r4,r4,4220
8111ddd0:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111ddd4:	d0a06217 	ldw	r2,-32376(gp)
8111ddd8:	e0ffff03 	ldbu	r3,-4(fp)
8111dddc:	180d883a 	mov	r6,r3
8111dde0:	01604574 	movhi	r5,33045
8111dde4:	29442704 	addi	r5,r5,4252
8111dde8:	1009883a 	mov	r4,r2
8111ddec:	11229940 	call	81122994 <fprintf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ddf0:	0001883a 	nop
8111ddf4:	e037883a 	mov	sp,fp
8111ddf8:	dfc00117 	ldw	ra,4(sp)
8111ddfc:	df000017 	ldw	fp,0(sp)
8111de00:	dec00204 	addi	sp,sp,8
8111de04:	f800283a 	ret

8111de08 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111de08:	defffd04 	addi	sp,sp,-12
8111de0c:	de00012e 	bgeu	sp,et,8111de14 <vFailCreateNFEESyncQueue+0xc>
8111de10:	003b68fa 	trap	3
8111de14:	dfc00215 	stw	ra,8(sp)
8111de18:	df000115 	stw	fp,4(sp)
8111de1c:	df000104 	addi	fp,sp,4
8111de20:	2005883a 	mov	r2,r4
8111de24:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111de28:	00a045f4 	movhi	r2,33047
8111de2c:	10a00404 	addi	r2,r2,-32752
8111de30:	10800e8b 	ldhu	r2,58(r2)
8111de34:	10bfffcc 	andi	r2,r2,65535
8111de38:	108001e8 	cmpgeui	r2,r2,7
8111de3c:	10000e1e 	bne	r2,zero,8111de78 <vFailCreateNFEESyncQueue+0x70>
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111de40:	d0a06217 	ldw	r2,-32376(gp)
8111de44:	100f883a 	mov	r7,r2
8111de48:	01800844 	movi	r6,33
8111de4c:	01400044 	movi	r5,1
8111de50:	01204574 	movhi	r4,33045
8111de54:	21043504 	addi	r4,r4,4308
8111de58:	11230300 	call	81123030 <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111de5c:	d0a06217 	ldw	r2,-32376(gp)
8111de60:	e0ffff03 	ldbu	r3,-4(fp)
8111de64:	180d883a 	mov	r6,r3
8111de68:	01604574 	movhi	r5,33045
8111de6c:	29443e04 	addi	r5,r5,4344
8111de70:	1009883a 	mov	r4,r2
8111de74:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111de78:	0001883a 	nop
8111de7c:	e037883a 	mov	sp,fp
8111de80:	dfc00117 	ldw	ra,4(sp)
8111de84:	df000017 	ldw	fp,0(sp)
8111de88:	dec00204 	addi	sp,sp,8
8111de8c:	f800283a 	ret

8111de90 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111de90:	defffe04 	addi	sp,sp,-8
8111de94:	de00012e 	bgeu	sp,et,8111de9c <vCoudlNotCreateNFee0Task+0xc>
8111de98:	003b68fa 	trap	3
8111de9c:	dfc00115 	stw	ra,4(sp)
8111dea0:	df000015 	stw	fp,0(sp)
8111dea4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dea8:	00a045f4 	movhi	r2,33047
8111deac:	10a00404 	addi	r2,r2,-32752
8111deb0:	10800e8b 	ldhu	r2,58(r2)
8111deb4:	10bfffcc 	andi	r2,r2,65535
8111deb8:	108001e8 	cmpgeui	r2,r2,7
8111debc:	10000e1e 	bne	r2,zero,8111def8 <vCoudlNotCreateNFee0Task+0x68>
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111dec0:	d0a06217 	ldw	r2,-32376(gp)
8111dec4:	100f883a 	mov	r7,r2
8111dec8:	01800844 	movi	r6,33
8111decc:	01400044 	movi	r5,1
8111ded0:	01204574 	movhi	r4,33045
8111ded4:	21044c04 	addi	r4,r4,4400
8111ded8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE 0 Task.\n");
8111dedc:	d0a06217 	ldw	r2,-32376(gp)
8111dee0:	100f883a 	mov	r7,r2
8111dee4:	01800784 	movi	r6,30
8111dee8:	01400044 	movi	r5,1
8111deec:	01204574 	movhi	r4,33045
8111def0:	21045504 	addi	r4,r4,4436
8111def4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111def8:	0001883a 	nop
8111defc:	e037883a 	mov	sp,fp
8111df00:	dfc00117 	ldw	ra,4(sp)
8111df04:	df000017 	ldw	fp,0(sp)
8111df08:	dec00204 	addi	sp,sp,8
8111df0c:	f800283a 	ret

8111df10 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111df10:	defffe04 	addi	sp,sp,-8
8111df14:	de00012e 	bgeu	sp,et,8111df1c <vCoudlNotCreateNFee1Task+0xc>
8111df18:	003b68fa 	trap	3
8111df1c:	dfc00115 	stw	ra,4(sp)
8111df20:	df000015 	stw	fp,0(sp)
8111df24:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111df28:	00a045f4 	movhi	r2,33047
8111df2c:	10a00404 	addi	r2,r2,-32752
8111df30:	10800e8b 	ldhu	r2,58(r2)
8111df34:	10bfffcc 	andi	r2,r2,65535
8111df38:	108001e8 	cmpgeui	r2,r2,7
8111df3c:	10000e1e 	bne	r2,zero,8111df78 <vCoudlNotCreateNFee1Task+0x68>
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111df40:	d0a06217 	ldw	r2,-32376(gp)
8111df44:	100f883a 	mov	r7,r2
8111df48:	01800844 	movi	r6,33
8111df4c:	01400044 	movi	r5,1
8111df50:	01204574 	movhi	r4,33045
8111df54:	21045d04 	addi	r4,r4,4468
8111df58:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE 1 Task.\n");
8111df5c:	d0a06217 	ldw	r2,-32376(gp)
8111df60:	100f883a 	mov	r7,r2
8111df64:	01800784 	movi	r6,30
8111df68:	01400044 	movi	r5,1
8111df6c:	01204574 	movhi	r4,33045
8111df70:	21046604 	addi	r4,r4,4504
8111df74:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111df78:	0001883a 	nop
8111df7c:	e037883a 	mov	sp,fp
8111df80:	dfc00117 	ldw	ra,4(sp)
8111df84:	df000017 	ldw	fp,0(sp)
8111df88:	dec00204 	addi	sp,sp,8
8111df8c:	f800283a 	ret

8111df90 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111df90:	defffe04 	addi	sp,sp,-8
8111df94:	de00012e 	bgeu	sp,et,8111df9c <vCoudlNotCreateNFee2Task+0xc>
8111df98:	003b68fa 	trap	3
8111df9c:	dfc00115 	stw	ra,4(sp)
8111dfa0:	df000015 	stw	fp,0(sp)
8111dfa4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dfa8:	00a045f4 	movhi	r2,33047
8111dfac:	10a00404 	addi	r2,r2,-32752
8111dfb0:	10800e8b 	ldhu	r2,58(r2)
8111dfb4:	10bfffcc 	andi	r2,r2,65535
8111dfb8:	108001e8 	cmpgeui	r2,r2,7
8111dfbc:	10000e1e 	bne	r2,zero,8111dff8 <vCoudlNotCreateNFee2Task+0x68>
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111dfc0:	d0a06217 	ldw	r2,-32376(gp)
8111dfc4:	100f883a 	mov	r7,r2
8111dfc8:	01800844 	movi	r6,33
8111dfcc:	01400044 	movi	r5,1
8111dfd0:	01204574 	movhi	r4,33045
8111dfd4:	21046e04 	addi	r4,r4,4536
8111dfd8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE 2 Task.\n");
8111dfdc:	d0a06217 	ldw	r2,-32376(gp)
8111dfe0:	100f883a 	mov	r7,r2
8111dfe4:	01800784 	movi	r6,30
8111dfe8:	01400044 	movi	r5,1
8111dfec:	01204574 	movhi	r4,33045
8111dff0:	21047704 	addi	r4,r4,4572
8111dff4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dff8:	0001883a 	nop
8111dffc:	e037883a 	mov	sp,fp
8111e000:	dfc00117 	ldw	ra,4(sp)
8111e004:	df000017 	ldw	fp,0(sp)
8111e008:	dec00204 	addi	sp,sp,8
8111e00c:	f800283a 	ret

8111e010 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111e010:	defffe04 	addi	sp,sp,-8
8111e014:	de00012e 	bgeu	sp,et,8111e01c <vCoudlNotCreateNFee3Task+0xc>
8111e018:	003b68fa 	trap	3
8111e01c:	dfc00115 	stw	ra,4(sp)
8111e020:	df000015 	stw	fp,0(sp)
8111e024:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e028:	00a045f4 	movhi	r2,33047
8111e02c:	10a00404 	addi	r2,r2,-32752
8111e030:	10800e8b 	ldhu	r2,58(r2)
8111e034:	10bfffcc 	andi	r2,r2,65535
8111e038:	108001e8 	cmpgeui	r2,r2,7
8111e03c:	10000e1e 	bne	r2,zero,8111e078 <vCoudlNotCreateNFee3Task+0x68>
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111e040:	d0a06217 	ldw	r2,-32376(gp)
8111e044:	100f883a 	mov	r7,r2
8111e048:	01800844 	movi	r6,33
8111e04c:	01400044 	movi	r5,1
8111e050:	01204574 	movhi	r4,33045
8111e054:	21047f04 	addi	r4,r4,4604
8111e058:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE 3 Task.\n");
8111e05c:	d0a06217 	ldw	r2,-32376(gp)
8111e060:	100f883a 	mov	r7,r2
8111e064:	01800784 	movi	r6,30
8111e068:	01400044 	movi	r5,1
8111e06c:	01204574 	movhi	r4,33045
8111e070:	21048804 	addi	r4,r4,4640
8111e074:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e078:	0001883a 	nop
8111e07c:	e037883a 	mov	sp,fp
8111e080:	dfc00117 	ldw	ra,4(sp)
8111e084:	df000017 	ldw	fp,0(sp)
8111e088:	dec00204 	addi	sp,sp,8
8111e08c:	f800283a 	ret

8111e090 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111e090:	defffe04 	addi	sp,sp,-8
8111e094:	de00012e 	bgeu	sp,et,8111e09c <vCoudlNotCreateNFee4Task+0xc>
8111e098:	003b68fa 	trap	3
8111e09c:	dfc00115 	stw	ra,4(sp)
8111e0a0:	df000015 	stw	fp,0(sp)
8111e0a4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e0a8:	00a045f4 	movhi	r2,33047
8111e0ac:	10a00404 	addi	r2,r2,-32752
8111e0b0:	10800e8b 	ldhu	r2,58(r2)
8111e0b4:	10bfffcc 	andi	r2,r2,65535
8111e0b8:	108001e8 	cmpgeui	r2,r2,7
8111e0bc:	10000e1e 	bne	r2,zero,8111e0f8 <vCoudlNotCreateNFee4Task+0x68>
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111e0c0:	d0a06217 	ldw	r2,-32376(gp)
8111e0c4:	100f883a 	mov	r7,r2
8111e0c8:	01800844 	movi	r6,33
8111e0cc:	01400044 	movi	r5,1
8111e0d0:	01204574 	movhi	r4,33045
8111e0d4:	21049004 	addi	r4,r4,4672
8111e0d8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE 4 Task.\n");
8111e0dc:	d0a06217 	ldw	r2,-32376(gp)
8111e0e0:	100f883a 	mov	r7,r2
8111e0e4:	01800784 	movi	r6,30
8111e0e8:	01400044 	movi	r5,1
8111e0ec:	01204574 	movhi	r4,33045
8111e0f0:	21049904 	addi	r4,r4,4708
8111e0f4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e0f8:	0001883a 	nop
8111e0fc:	e037883a 	mov	sp,fp
8111e100:	dfc00117 	ldw	ra,4(sp)
8111e104:	df000017 	ldw	fp,0(sp)
8111e108:	dec00204 	addi	sp,sp,8
8111e10c:	f800283a 	ret

8111e110 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111e110:	defffe04 	addi	sp,sp,-8
8111e114:	de00012e 	bgeu	sp,et,8111e11c <vCoudlNotCreateNFee5Task+0xc>
8111e118:	003b68fa 	trap	3
8111e11c:	dfc00115 	stw	ra,4(sp)
8111e120:	df000015 	stw	fp,0(sp)
8111e124:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e128:	00a045f4 	movhi	r2,33047
8111e12c:	10a00404 	addi	r2,r2,-32752
8111e130:	10800e8b 	ldhu	r2,58(r2)
8111e134:	10bfffcc 	andi	r2,r2,65535
8111e138:	108001e8 	cmpgeui	r2,r2,7
8111e13c:	10000e1e 	bne	r2,zero,8111e178 <vCoudlNotCreateNFee5Task+0x68>
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111e140:	d0a06217 	ldw	r2,-32376(gp)
8111e144:	100f883a 	mov	r7,r2
8111e148:	01800844 	movi	r6,33
8111e14c:	01400044 	movi	r5,1
8111e150:	01204574 	movhi	r4,33045
8111e154:	2104a104 	addi	r4,r4,4740
8111e158:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE 5 Task.\n");
8111e15c:	d0a06217 	ldw	r2,-32376(gp)
8111e160:	100f883a 	mov	r7,r2
8111e164:	01800784 	movi	r6,30
8111e168:	01400044 	movi	r5,1
8111e16c:	01204574 	movhi	r4,33045
8111e170:	2104aa04 	addi	r4,r4,4776
8111e174:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e178:	0001883a 	nop
8111e17c:	e037883a 	mov	sp,fp
8111e180:	dfc00117 	ldw	ra,4(sp)
8111e184:	df000017 	ldw	fp,0(sp)
8111e188:	dec00204 	addi	sp,sp,8
8111e18c:	f800283a 	ret

8111e190 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111e190:	defffe04 	addi	sp,sp,-8
8111e194:	de00012e 	bgeu	sp,et,8111e19c <vCoudlNotCreateNFeeControllerTask+0xc>
8111e198:	003b68fa 	trap	3
8111e19c:	dfc00115 	stw	ra,4(sp)
8111e1a0:	df000015 	stw	fp,0(sp)
8111e1a4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e1a8:	00a045f4 	movhi	r2,33047
8111e1ac:	10a00404 	addi	r2,r2,-32752
8111e1b0:	10800e8b 	ldhu	r2,58(r2)
8111e1b4:	10bfffcc 	andi	r2,r2,65535
8111e1b8:	108001e8 	cmpgeui	r2,r2,7
8111e1bc:	10000e1e 	bne	r2,zero,8111e1f8 <vCoudlNotCreateNFeeControllerTask+0x68>
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111e1c0:	d0a06217 	ldw	r2,-32376(gp)
8111e1c4:	100f883a 	mov	r7,r2
8111e1c8:	01800a84 	movi	r6,42
8111e1cc:	01400044 	movi	r5,1
8111e1d0:	01204574 	movhi	r4,33045
8111e1d4:	2104b204 	addi	r4,r4,4808
8111e1d8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create NFEE Controller Task.\n");
8111e1dc:	d0a06217 	ldw	r2,-32376(gp)
8111e1e0:	100f883a 	mov	r7,r2
8111e1e4:	018009c4 	movi	r6,39
8111e1e8:	01400044 	movi	r5,1
8111e1ec:	01204574 	movhi	r4,33045
8111e1f0:	2104bd04 	addi	r4,r4,4852
8111e1f4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e1f8:	0001883a 	nop
8111e1fc:	e037883a 	mov	sp,fp
8111e200:	dfc00117 	ldw	ra,4(sp)
8111e204:	df000017 	ldw	fp,0(sp)
8111e208:	dec00204 	addi	sp,sp,8
8111e20c:	f800283a 	ret

8111e210 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111e210:	defffe04 	addi	sp,sp,-8
8111e214:	de00012e 	bgeu	sp,et,8111e21c <vCoudlNotCreateDataControllerTask+0xc>
8111e218:	003b68fa 	trap	3
8111e21c:	dfc00115 	stw	ra,4(sp)
8111e220:	df000015 	stw	fp,0(sp)
8111e224:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e228:	00a045f4 	movhi	r2,33047
8111e22c:	10a00404 	addi	r2,r2,-32752
8111e230:	10800e8b 	ldhu	r2,58(r2)
8111e234:	10bfffcc 	andi	r2,r2,65535
8111e238:	108001e8 	cmpgeui	r2,r2,7
8111e23c:	10000e1e 	bne	r2,zero,8111e278 <vCoudlNotCreateDataControllerTask+0x68>
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111e240:	d0a06217 	ldw	r2,-32376(gp)
8111e244:	100f883a 	mov	r7,r2
8111e248:	01800a84 	movi	r6,42
8111e24c:	01400044 	movi	r5,1
8111e250:	01204574 	movhi	r4,33045
8111e254:	2104c704 	addi	r4,r4,4892
8111e258:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create Data Controller Task.\n");
8111e25c:	d0a06217 	ldw	r2,-32376(gp)
8111e260:	100f883a 	mov	r7,r2
8111e264:	018009c4 	movi	r6,39
8111e268:	01400044 	movi	r5,1
8111e26c:	01204574 	movhi	r4,33045
8111e270:	2104d204 	addi	r4,r4,4936
8111e274:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e278:	0001883a 	nop
8111e27c:	e037883a 	mov	sp,fp
8111e280:	dfc00117 	ldw	ra,4(sp)
8111e284:	df000017 	ldw	fp,0(sp)
8111e288:	dec00204 	addi	sp,sp,8
8111e28c:	f800283a 	ret

8111e290 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111e290:	defffe04 	addi	sp,sp,-8
8111e294:	de00012e 	bgeu	sp,et,8111e29c <vCoudlNotCreateMebTask+0xc>
8111e298:	003b68fa 	trap	3
8111e29c:	dfc00115 	stw	ra,4(sp)
8111e2a0:	df000015 	stw	fp,0(sp)
8111e2a4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e2a8:	00a045f4 	movhi	r2,33047
8111e2ac:	10a00404 	addi	r2,r2,-32752
8111e2b0:	10800e8b 	ldhu	r2,58(r2)
8111e2b4:	10bfffcc 	andi	r2,r2,65535
8111e2b8:	108001e8 	cmpgeui	r2,r2,7
8111e2bc:	10000e1e 	bne	r2,zero,8111e2f8 <vCoudlNotCreateMebTask+0x68>
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111e2c0:	d0a06217 	ldw	r2,-32376(gp)
8111e2c4:	100f883a 	mov	r7,r2
8111e2c8:	018007c4 	movi	r6,31
8111e2cc:	01400044 	movi	r5,1
8111e2d0:	01204574 	movhi	r4,33045
8111e2d4:	2104dc04 	addi	r4,r4,4976
8111e2d8:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not create Meb Task.\n");
8111e2dc:	d0a06217 	ldw	r2,-32376(gp)
8111e2e0:	100f883a 	mov	r7,r2
8111e2e4:	018006c4 	movi	r6,27
8111e2e8:	01400044 	movi	r5,1
8111e2ec:	01204574 	movhi	r4,33045
8111e2f0:	2104e404 	addi	r4,r4,5008
8111e2f4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e2f8:	0001883a 	nop
8111e2fc:	e037883a 	mov	sp,fp
8111e300:	dfc00117 	ldw	ra,4(sp)
8111e304:	df000017 	ldw	fp,0(sp)
8111e308:	dec00204 	addi	sp,sp,8
8111e30c:	f800283a 	ret

8111e310 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111e310:	defffd04 	addi	sp,sp,-12
8111e314:	de00012e 	bgeu	sp,et,8111e31c <vFailCreateMutexSPUSQueueMeb+0xc>
8111e318:	003b68fa 	trap	3
8111e31c:	dfc00215 	stw	ra,8(sp)
8111e320:	df000115 	stw	fp,4(sp)
8111e324:	df000104 	addi	fp,sp,4
8111e328:	2005883a 	mov	r2,r4
8111e32c:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e330:	00a045f4 	movhi	r2,33047
8111e334:	10a00404 	addi	r2,r2,-32752
8111e338:	10800e8b 	ldhu	r2,58(r2)
8111e33c:	10bfffcc 	andi	r2,r2,65535
8111e340:	108001e8 	cmpgeui	r2,r2,7
8111e344:	10000a1e 	bne	r2,zero,8111e370 <vFailCreateMutexSPUSQueueMeb+0x60>
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111e348:	d0a06217 	ldw	r2,-32376(gp)
8111e34c:	100f883a 	mov	r7,r2
8111e350:	01800944 	movi	r6,37
8111e354:	01400044 	movi	r5,1
8111e358:	01204574 	movhi	r4,33045
8111e35c:	2104eb04 	addi	r4,r4,5036
8111e360:	11230300 	call	81123030 <fwrite>
		printErrorTask(error_code);
8111e364:	e0bfff03 	ldbu	r2,-4(fp)
8111e368:	1009883a 	mov	r4,r2
8111e36c:	111c4d40 	call	8111c4d4 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e370:	0001883a 	nop
8111e374:	e037883a 	mov	sp,fp
8111e378:	dfc00117 	ldw	ra,4(sp)
8111e37c:	df000017 	ldw	fp,0(sp)
8111e380:	dec00204 	addi	sp,sp,8
8111e384:	f800283a 	ret

8111e388 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111e388:	defffe04 	addi	sp,sp,-8
8111e38c:	de00012e 	bgeu	sp,et,8111e394 <vFailSendPUStoMebTask+0xc>
8111e390:	003b68fa 	trap	3
8111e394:	dfc00115 	stw	ra,4(sp)
8111e398:	df000015 	stw	fp,0(sp)
8111e39c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e3a0:	00a045f4 	movhi	r2,33047
8111e3a4:	10a00404 	addi	r2,r2,-32752
8111e3a8:	10800e8b 	ldhu	r2,58(r2)
8111e3ac:	10bfffcc 	andi	r2,r2,65535
8111e3b0:	108001e8 	cmpgeui	r2,r2,7
8111e3b4:	1000071e 	bne	r2,zero,8111e3d4 <vFailSendPUStoMebTask+0x4c>
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111e3b8:	d0a06217 	ldw	r2,-32376(gp)
8111e3bc:	100f883a 	mov	r7,r2
8111e3c0:	01800784 	movi	r6,30
8111e3c4:	01400044 	movi	r5,1
8111e3c8:	01204574 	movhi	r4,33045
8111e3cc:	2104f504 	addi	r4,r4,5076
8111e3d0:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e3d4:	0001883a 	nop
8111e3d8:	e037883a 	mov	sp,fp
8111e3dc:	dfc00117 	ldw	ra,4(sp)
8111e3e0:	df000017 	ldw	fp,0(sp)
8111e3e4:	dec00204 	addi	sp,sp,8
8111e3e8:	f800283a 	ret

8111e3ec <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111e3ec:	defffe04 	addi	sp,sp,-8
8111e3f0:	de00012e 	bgeu	sp,et,8111e3f8 <vCouldNotGetCmdQueueMeb+0xc>
8111e3f4:	003b68fa 	trap	3
8111e3f8:	dfc00115 	stw	ra,4(sp)
8111e3fc:	df000015 	stw	fp,0(sp)
8111e400:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e404:	00a045f4 	movhi	r2,33047
8111e408:	10a00404 	addi	r2,r2,-32752
8111e40c:	10800e8b 	ldhu	r2,58(r2)
8111e410:	10bfffcc 	andi	r2,r2,65535
8111e414:	108001e8 	cmpgeui	r2,r2,7
8111e418:	10000e1e 	bne	r2,zero,8111e454 <vCouldNotGetCmdQueueMeb+0x68>
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111e41c:	d0a06217 	ldw	r2,-32376(gp)
8111e420:	100f883a 	mov	r7,r2
8111e424:	01800a84 	movi	r6,42
8111e428:	01400044 	movi	r5,1
8111e42c:	01204574 	movhi	r4,33045
8111e430:	2104fd04 	addi	r4,r4,5108
8111e434:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111e438:	d0a06217 	ldw	r2,-32376(gp)
8111e43c:	100f883a 	mov	r7,r2
8111e440:	01800cc4 	movi	r6,51
8111e444:	01400044 	movi	r5,1
8111e448:	01204574 	movhi	r4,33045
8111e44c:	21050804 	addi	r4,r4,5152
8111e450:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e454:	0001883a 	nop
8111e458:	e037883a 	mov	sp,fp
8111e45c:	dfc00117 	ldw	ra,4(sp)
8111e460:	df000017 	ldw	fp,0(sp)
8111e464:	dec00204 	addi	sp,sp,8
8111e468:	f800283a 	ret

8111e46c <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111e46c:	defffe04 	addi	sp,sp,-8
8111e470:	de00012e 	bgeu	sp,et,8111e478 <vCouldNotGetMutexMebPus+0xc>
8111e474:	003b68fa 	trap	3
8111e478:	dfc00115 	stw	ra,4(sp)
8111e47c:	df000015 	stw	fp,0(sp)
8111e480:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e484:	00a045f4 	movhi	r2,33047
8111e488:	10a00404 	addi	r2,r2,-32752
8111e48c:	10800e8b 	ldhu	r2,58(r2)
8111e490:	10bfffcc 	andi	r2,r2,65535
8111e494:	108001e8 	cmpgeui	r2,r2,7
8111e498:	1000071e 	bne	r2,zero,8111e4b8 <vCouldNotGetMutexMebPus+0x4c>
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111e49c:	d0a06217 	ldw	r2,-32376(gp)
8111e4a0:	100f883a 	mov	r7,r2
8111e4a4:	01800804 	movi	r6,32
8111e4a8:	01400044 	movi	r5,1
8111e4ac:	01204574 	movhi	r4,33045
8111e4b0:	21051504 	addi	r4,r4,5204
8111e4b4:	11230300 	call	81123030 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e4b8:	0001883a 	nop
8111e4bc:	e037883a 	mov	sp,fp
8111e4c0:	dfc00117 	ldw	ra,4(sp)
8111e4c4:	df000017 	ldw	fp,0(sp)
8111e4c8:	dec00204 	addi	sp,sp,8
8111e4cc:	f800283a 	ret

8111e4d0 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111e4d0:	defffe04 	addi	sp,sp,-8
8111e4d4:	de00012e 	bgeu	sp,et,8111e4dc <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111e4d8:	003b68fa 	trap	3
8111e4dc:	dfc00115 	stw	ra,4(sp)
8111e4e0:	df000015 	stw	fp,0(sp)
8111e4e4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e4e8:	00a045f4 	movhi	r2,33047
8111e4ec:	10a00404 	addi	r2,r2,-32752
8111e4f0:	10800e8b 	ldhu	r2,58(r2)
8111e4f4:	10bfffcc 	andi	r2,r2,65535
8111e4f8:	108001e8 	cmpgeui	r2,r2,7
8111e4fc:	10000e1e 	bne	r2,zero,8111e538 <vCouldNotCreateQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111e500:	d0a06217 	ldw	r2,-32376(gp)
8111e504:	100f883a 	mov	r7,r2
8111e508:	01800a44 	movi	r6,41
8111e50c:	01400044 	movi	r5,1
8111e510:	01204574 	movhi	r4,33045
8111e514:	21051e04 	addi	r4,r4,5240
8111e518:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111e51c:	d0a06217 	ldw	r2,-32376(gp)
8111e520:	100f883a 	mov	r7,r2
8111e524:	01800c84 	movi	r6,50
8111e528:	01400044 	movi	r5,1
8111e52c:	01204574 	movhi	r4,33045
8111e530:	21052904 	addi	r4,r4,5284
8111e534:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e538:	0001883a 	nop
8111e53c:	e037883a 	mov	sp,fp
8111e540:	dfc00117 	ldw	ra,4(sp)
8111e544:	df000017 	ldw	fp,0(sp)
8111e548:	dec00204 	addi	sp,sp,8
8111e54c:	f800283a 	ret

8111e550 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111e550:	defffe04 	addi	sp,sp,-8
8111e554:	de00012e 	bgeu	sp,et,8111e55c <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111e558:	003b68fa 	trap	3
8111e55c:	dfc00115 	stw	ra,4(sp)
8111e560:	df000015 	stw	fp,0(sp)
8111e564:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e568:	00a045f4 	movhi	r2,33047
8111e56c:	10a00404 	addi	r2,r2,-32752
8111e570:	10800e8b 	ldhu	r2,58(r2)
8111e574:	10bfffcc 	andi	r2,r2,65535
8111e578:	108001e8 	cmpgeui	r2,r2,7
8111e57c:	10000e1e 	bne	r2,zero,8111e5b8 <vCouldNotCreateQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111e580:	d0a06217 	ldw	r2,-32376(gp)
8111e584:	100f883a 	mov	r7,r2
8111e588:	01800a44 	movi	r6,41
8111e58c:	01400044 	movi	r5,1
8111e590:	01204574 	movhi	r4,33045
8111e594:	21053604 	addi	r4,r4,5336
8111e598:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111e59c:	d0a06217 	ldw	r2,-32376(gp)
8111e5a0:	100f883a 	mov	r7,r2
8111e5a4:	01800c84 	movi	r6,50
8111e5a8:	01400044 	movi	r5,1
8111e5ac:	01204574 	movhi	r4,33045
8111e5b0:	21054104 	addi	r4,r4,5380
8111e5b4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e5b8:	0001883a 	nop
8111e5bc:	e037883a 	mov	sp,fp
8111e5c0:	dfc00117 	ldw	ra,4(sp)
8111e5c4:	df000017 	ldw	fp,0(sp)
8111e5c8:	dec00204 	addi	sp,sp,8
8111e5cc:	f800283a 	ret

8111e5d0 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111e5d0:	defffe04 	addi	sp,sp,-8
8111e5d4:	de00012e 	bgeu	sp,et,8111e5dc <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111e5d8:	003b68fa 	trap	3
8111e5dc:	dfc00115 	stw	ra,4(sp)
8111e5e0:	df000015 	stw	fp,0(sp)
8111e5e4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e5e8:	00a045f4 	movhi	r2,33047
8111e5ec:	10a00404 	addi	r2,r2,-32752
8111e5f0:	10800e8b 	ldhu	r2,58(r2)
8111e5f4:	10bfffcc 	andi	r2,r2,65535
8111e5f8:	108001e8 	cmpgeui	r2,r2,7
8111e5fc:	10000e1e 	bne	r2,zero,8111e638 <vCouldNotGetQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111e600:	d0a06217 	ldw	r2,-32376(gp)
8111e604:	100f883a 	mov	r7,r2
8111e608:	01800984 	movi	r6,38
8111e60c:	01400044 	movi	r5,1
8111e610:	01204574 	movhi	r4,33045
8111e614:	21054e04 	addi	r4,r4,5432
8111e618:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111e61c:	d0a06217 	ldw	r2,-32376(gp)
8111e620:	100f883a 	mov	r7,r2
8111e624:	01800bc4 	movi	r6,47
8111e628:	01400044 	movi	r5,1
8111e62c:	01204574 	movhi	r4,33045
8111e630:	21055804 	addi	r4,r4,5472
8111e634:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e638:	0001883a 	nop
8111e63c:	e037883a 	mov	sp,fp
8111e640:	dfc00117 	ldw	ra,4(sp)
8111e644:	df000017 	ldw	fp,0(sp)
8111e648:	dec00204 	addi	sp,sp,8
8111e64c:	f800283a 	ret

8111e650 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111e650:	defffe04 	addi	sp,sp,-8
8111e654:	de00012e 	bgeu	sp,et,8111e65c <vCouldNotGetQueueMaskDataCtrl+0xc>
8111e658:	003b68fa 	trap	3
8111e65c:	dfc00115 	stw	ra,4(sp)
8111e660:	df000015 	stw	fp,0(sp)
8111e664:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e668:	00a045f4 	movhi	r2,33047
8111e66c:	10a00404 	addi	r2,r2,-32752
8111e670:	10800e8b 	ldhu	r2,58(r2)
8111e674:	10bfffcc 	andi	r2,r2,65535
8111e678:	108001e8 	cmpgeui	r2,r2,7
8111e67c:	10000e1e 	bne	r2,zero,8111e6b8 <vCouldNotGetQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111e680:	d0a06217 	ldw	r2,-32376(gp)
8111e684:	100f883a 	mov	r7,r2
8111e688:	01800984 	movi	r6,38
8111e68c:	01400044 	movi	r5,1
8111e690:	01204574 	movhi	r4,33045
8111e694:	21056404 	addi	r4,r4,5520
8111e698:	11230300 	call	81123030 <fwrite>
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111e69c:	d0a06217 	ldw	r2,-32376(gp)
8111e6a0:	100f883a 	mov	r7,r2
8111e6a4:	01800bc4 	movi	r6,47
8111e6a8:	01400044 	movi	r5,1
8111e6ac:	01204574 	movhi	r4,33045
8111e6b0:	21056e04 	addi	r4,r4,5560
8111e6b4:	11230300 	call	81123030 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e6b8:	0001883a 	nop
8111e6bc:	e037883a 	mov	sp,fp
8111e6c0:	dfc00117 	ldw	ra,4(sp)
8111e6c4:	df000017 	ldw	fp,0(sp)
8111e6c8:	dec00204 	addi	sp,sp,8
8111e6cc:	f800283a 	ret

8111e6d0 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111e6d0:	defffd04 	addi	sp,sp,-12
8111e6d4:	de00012e 	bgeu	sp,et,8111e6dc <vFailSendMsgAccessDMA+0xc>
8111e6d8:	003b68fa 	trap	3
8111e6dc:	dfc00215 	stw	ra,8(sp)
8111e6e0:	df000115 	stw	fp,4(sp)
8111e6e4:	df000104 	addi	fp,sp,4
8111e6e8:	2005883a 	mov	r2,r4
8111e6ec:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e6f0:	00a045f4 	movhi	r2,33047
8111e6f4:	10a00404 	addi	r2,r2,-32752
8111e6f8:	10800e8b 	ldhu	r2,58(r2)
8111e6fc:	10bfffcc 	andi	r2,r2,65535
8111e700:	108001e8 	cmpgeui	r2,r2,7
8111e704:	1000071e 	bne	r2,zero,8111e724 <vFailSendMsgAccessDMA+0x54>
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n:%hhu \n", ucTemp);
8111e708:	d0a06217 	ldw	r2,-32376(gp)
8111e70c:	e0ffff03 	ldbu	r3,-4(fp)
8111e710:	180d883a 	mov	r6,r3
8111e714:	01604574 	movhi	r5,33045
8111e718:	29457a04 	addi	r5,r5,5608
8111e71c:	1009883a 	mov	r4,r2
8111e720:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e724:	0001883a 	nop
8111e728:	e037883a 	mov	sp,fp
8111e72c:	dfc00117 	ldw	ra,4(sp)
8111e730:	df000017 	ldw	fp,0(sp)
8111e734:	dec00204 	addi	sp,sp,8
8111e738:	f800283a 	ret

8111e73c <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111e73c:	defffd04 	addi	sp,sp,-12
8111e740:	de00012e 	bgeu	sp,et,8111e748 <vFailRequestDMA+0xc>
8111e744:	003b68fa 	trap	3
8111e748:	dfc00215 	stw	ra,8(sp)
8111e74c:	df000115 	stw	fp,4(sp)
8111e750:	df000104 	addi	fp,sp,4
8111e754:	2005883a 	mov	r2,r4
8111e758:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e75c:	00a045f4 	movhi	r2,33047
8111e760:	10a00404 	addi	r2,r2,-32752
8111e764:	10800e8b 	ldhu	r2,58(r2)
8111e768:	10bfffcc 	andi	r2,r2,65535
8111e76c:	108001e8 	cmpgeui	r2,r2,7
8111e770:	1000071e 	bne	r2,zero,8111e790 <vFailRequestDMA+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111e774:	d0a06217 	ldw	r2,-32376(gp)
8111e778:	e0ffff03 	ldbu	r3,-4(fp)
8111e77c:	180d883a 	mov	r6,r3
8111e780:	01604574 	movhi	r5,33045
8111e784:	29458304 	addi	r5,r5,5644
8111e788:	1009883a 	mov	r4,r2
8111e78c:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e790:	0001883a 	nop
8111e794:	e037883a 	mov	sp,fp
8111e798:	dfc00117 	ldw	ra,4(sp)
8111e79c:	df000017 	ldw	fp,0(sp)
8111e7a0:	dec00204 	addi	sp,sp,8
8111e7a4:	f800283a 	ret

8111e7a8 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111e7a8:	defffd04 	addi	sp,sp,-12
8111e7ac:	de00012e 	bgeu	sp,et,8111e7b4 <vFailRequestDMAFromIRQ+0xc>
8111e7b0:	003b68fa 	trap	3
8111e7b4:	dfc00215 	stw	ra,8(sp)
8111e7b8:	df000115 	stw	fp,4(sp)
8111e7bc:	df000104 	addi	fp,sp,4
8111e7c0:	2005883a 	mov	r2,r4
8111e7c4:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e7c8:	00a045f4 	movhi	r2,33047
8111e7cc:	10a00404 	addi	r2,r2,-32752
8111e7d0:	10800e8b 	ldhu	r2,58(r2)
8111e7d4:	10bfffcc 	andi	r2,r2,65535
8111e7d8:	108001e8 	cmpgeui	r2,r2,7
8111e7dc:	1000071e 	bne	r2,zero,8111e7fc <vFailRequestDMAFromIRQ+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111e7e0:	d0a06217 	ldw	r2,-32376(gp)
8111e7e4:	e0ffff03 	ldbu	r3,-4(fp)
8111e7e8:	180d883a 	mov	r6,r3
8111e7ec:	01604574 	movhi	r5,33045
8111e7f0:	29458304 	addi	r5,r5,5644
8111e7f4:	1009883a 	mov	r4,r2
8111e7f8:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e7fc:	0001883a 	nop
8111e800:	e037883a 	mov	sp,fp
8111e804:	dfc00117 	ldw	ra,4(sp)
8111e808:	df000017 	ldw	fp,0(sp)
8111e80c:	dec00204 	addi	sp,sp,8
8111e810:	f800283a 	ret

8111e814 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111e814:	defffd04 	addi	sp,sp,-12
8111e818:	de00012e 	bgeu	sp,et,8111e820 <vFailSendRMAPFromIRQ+0xc>
8111e81c:	003b68fa 	trap	3
8111e820:	dfc00215 	stw	ra,8(sp)
8111e824:	df000115 	stw	fp,4(sp)
8111e828:	df000104 	addi	fp,sp,4
8111e82c:	2005883a 	mov	r2,r4
8111e830:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e834:	00a045f4 	movhi	r2,33047
8111e838:	10a00404 	addi	r2,r2,-32752
8111e83c:	10800e8b 	ldhu	r2,58(r2)
8111e840:	10bfffcc 	andi	r2,r2,65535
8111e844:	108001e8 	cmpgeui	r2,r2,7
8111e848:	1000071e 	bne	r2,zero,8111e868 <vFailSendRMAPFromIRQ+0x54>
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n:%hhu \n", ucTemp);
8111e84c:	d0a06217 	ldw	r2,-32376(gp)
8111e850:	e0ffff03 	ldbu	r3,-4(fp)
8111e854:	180d883a 	mov	r6,r3
8111e858:	01604574 	movhi	r5,33045
8111e85c:	29458b04 	addi	r5,r5,5676
8111e860:	1009883a 	mov	r4,r2
8111e864:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e868:	0001883a 	nop
8111e86c:	e037883a 	mov	sp,fp
8111e870:	dfc00117 	ldw	ra,4(sp)
8111e874:	df000017 	ldw	fp,0(sp)
8111e878:	dec00204 	addi	sp,sp,8
8111e87c:	f800283a 	ret

8111e880 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111e880:	defffd04 	addi	sp,sp,-12
8111e884:	de00012e 	bgeu	sp,et,8111e88c <vFailSendMsgSync+0xc>
8111e888:	003b68fa 	trap	3
8111e88c:	dfc00215 	stw	ra,8(sp)
8111e890:	df000115 	stw	fp,4(sp)
8111e894:	df000104 	addi	fp,sp,4
8111e898:	2005883a 	mov	r2,r4
8111e89c:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e8a0:	00a045f4 	movhi	r2,33047
8111e8a4:	10a00404 	addi	r2,r2,-32752
8111e8a8:	10800e8b 	ldhu	r2,58(r2)
8111e8ac:	10bfffcc 	andi	r2,r2,65535
8111e8b0:	108001e8 	cmpgeui	r2,r2,7
8111e8b4:	1000071e 	bne	r2,zero,8111e8d4 <vFailSendMsgSync+0x54>
		fprintf(fp,"vFailSendMsgSync. FEE n:%hhu \n", ucTemp);
8111e8b8:	d0a06217 	ldw	r2,-32376(gp)
8111e8bc:	e0ffff03 	ldbu	r3,-4(fp)
8111e8c0:	180d883a 	mov	r6,r3
8111e8c4:	01604574 	movhi	r5,33045
8111e8c8:	29459404 	addi	r5,r5,5712
8111e8cc:	1009883a 	mov	r4,r2
8111e8d0:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e8d4:	0001883a 	nop
8111e8d8:	e037883a 	mov	sp,fp
8111e8dc:	dfc00117 	ldw	ra,4(sp)
8111e8e0:	df000017 	ldw	fp,0(sp)
8111e8e4:	dec00204 	addi	sp,sp,8
8111e8e8:	f800283a 	ret

8111e8ec <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111e8ec:	defffd04 	addi	sp,sp,-12
8111e8f0:	de00012e 	bgeu	sp,et,8111e8f8 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111e8f4:	003b68fa 	trap	3
8111e8f8:	dfc00215 	stw	ra,8(sp)
8111e8fc:	df000115 	stw	fp,4(sp)
8111e900:	df000104 	addi	fp,sp,4
8111e904:	2005883a 	mov	r2,r4
8111e908:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e90c:	00a045f4 	movhi	r2,33047
8111e910:	10a00404 	addi	r2,r2,-32752
8111e914:	10800e8b 	ldhu	r2,58(r2)
8111e918:	10bfffcc 	andi	r2,r2,65535
8111e91c:	108001e8 	cmpgeui	r2,r2,7
8111e920:	1000071e 	bne	r2,zero,8111e940 <vFailSendMsgSyncRMAPTRIGGER+0x54>
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n:%hhu \n", ucTemp);
8111e924:	d0a06217 	ldw	r2,-32376(gp)
8111e928:	e0ffff03 	ldbu	r3,-4(fp)
8111e92c:	180d883a 	mov	r6,r3
8111e930:	01604574 	movhi	r5,33045
8111e934:	29459c04 	addi	r5,r5,5744
8111e938:	1009883a 	mov	r4,r2
8111e93c:	11229940 	call	81122994 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e940:	0001883a 	nop
8111e944:	e037883a 	mov	sp,fp
8111e948:	dfc00117 	ldw	ra,4(sp)
8111e94c:	df000017 	ldw	fp,0(sp)
8111e950:	dec00204 	addi	sp,sp,8
8111e954:	f800283a 	ret

8111e958 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111e958:	defffe04 	addi	sp,sp,-8
8111e95c:	de00012e 	bgeu	sp,et,8111e964 <vFailSendMsgMasterSyncMeb+0xc>
8111e960:	003b68fa 	trap	3
8111e964:	dfc00115 	stw	ra,4(sp)
8111e968:	df000015 	stw	fp,0(sp)
8111e96c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e970:	00a045f4 	movhi	r2,33047
8111e974:	10a00404 	addi	r2,r2,-32752
8111e978:	10800e8b 	ldhu	r2,58(r2)
8111e97c:	10bfffcc 	andi	r2,r2,65535
8111e980:	108001e8 	cmpgeui	r2,r2,7
8111e984:	1000071e 	bne	r2,zero,8111e9a4 <vFailSendMsgMasterSyncMeb+0x4c>
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111e988:	d0a06217 	ldw	r2,-32376(gp)
8111e98c:	100f883a 	mov	r7,r2
8111e990:	018006c4 	movi	r6,27
8111e994:	01400044 	movi	r5,1
8111e998:	01204574 	movhi	r4,33045
8111e99c:	2105aa04 	addi	r4,r4,5800
8111e9a0:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e9a4:	0001883a 	nop
8111e9a8:	e037883a 	mov	sp,fp
8111e9ac:	dfc00117 	ldw	ra,4(sp)
8111e9b0:	df000017 	ldw	fp,0(sp)
8111e9b4:	dec00204 	addi	sp,sp,8
8111e9b8:	f800283a 	ret

8111e9bc <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111e9bc:	defffe04 	addi	sp,sp,-8
8111e9c0:	de00012e 	bgeu	sp,et,8111e9c8 <vFailSendMsgFeeCTRL+0xc>
8111e9c4:	003b68fa 	trap	3
8111e9c8:	dfc00115 	stw	ra,4(sp)
8111e9cc:	df000015 	stw	fp,0(sp)
8111e9d0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e9d4:	00a045f4 	movhi	r2,33047
8111e9d8:	10a00404 	addi	r2,r2,-32752
8111e9dc:	10800e8b 	ldhu	r2,58(r2)
8111e9e0:	10bfffcc 	andi	r2,r2,65535
8111e9e4:	108001e8 	cmpgeui	r2,r2,7
8111e9e8:	1000071e 	bne	r2,zero,8111ea08 <vFailSendMsgFeeCTRL+0x4c>
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111e9ec:	d0a06217 	ldw	r2,-32376(gp)
8111e9f0:	100f883a 	mov	r7,r2
8111e9f4:	018005c4 	movi	r6,23
8111e9f8:	01400044 	movi	r5,1
8111e9fc:	01204574 	movhi	r4,33045
8111ea00:	2105b104 	addi	r4,r4,5828
8111ea04:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ea08:	0001883a 	nop
8111ea0c:	e037883a 	mov	sp,fp
8111ea10:	dfc00117 	ldw	ra,4(sp)
8111ea14:	df000017 	ldw	fp,0(sp)
8111ea18:	dec00204 	addi	sp,sp,8
8111ea1c:	f800283a 	ret

8111ea20 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111ea20:	defffe04 	addi	sp,sp,-8
8111ea24:	de00012e 	bgeu	sp,et,8111ea2c <vFailSendMsgDataCTRL+0xc>
8111ea28:	003b68fa 	trap	3
8111ea2c:	dfc00115 	stw	ra,4(sp)
8111ea30:	df000015 	stw	fp,0(sp)
8111ea34:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea38:	00a045f4 	movhi	r2,33047
8111ea3c:	10a00404 	addi	r2,r2,-32752
8111ea40:	10800e8b 	ldhu	r2,58(r2)
8111ea44:	10bfffcc 	andi	r2,r2,65535
8111ea48:	108001e8 	cmpgeui	r2,r2,7
8111ea4c:	1000071e 	bne	r2,zero,8111ea6c <vFailSendMsgDataCTRL+0x4c>
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111ea50:	d0a06217 	ldw	r2,-32376(gp)
8111ea54:	100f883a 	mov	r7,r2
8111ea58:	01800604 	movi	r6,24
8111ea5c:	01400044 	movi	r5,1
8111ea60:	01204574 	movhi	r4,33045
8111ea64:	2105b704 	addi	r4,r4,5852
8111ea68:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ea6c:	0001883a 	nop
8111ea70:	e037883a 	mov	sp,fp
8111ea74:	dfc00117 	ldw	ra,4(sp)
8111ea78:	df000017 	ldw	fp,0(sp)
8111ea7c:	dec00204 	addi	sp,sp,8
8111ea80:	f800283a 	ret

8111ea84 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111ea84:	defffe04 	addi	sp,sp,-8
8111ea88:	de00012e 	bgeu	sp,et,8111ea90 <vFailFlushQueue+0xc>
8111ea8c:	003b68fa 	trap	3
8111ea90:	dfc00115 	stw	ra,4(sp)
8111ea94:	df000015 	stw	fp,0(sp)
8111ea98:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea9c:	00a045f4 	movhi	r2,33047
8111eaa0:	10a00404 	addi	r2,r2,-32752
8111eaa4:	10800e8b 	ldhu	r2,58(r2)
8111eaa8:	10bfffcc 	andi	r2,r2,65535
8111eaac:	108001e8 	cmpgeui	r2,r2,7
8111eab0:	1000071e 	bne	r2,zero,8111ead0 <vFailFlushQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111eab4:	d0a06217 	ldw	r2,-32376(gp)
8111eab8:	100f883a 	mov	r7,r2
8111eabc:	01800744 	movi	r6,29
8111eac0:	01400044 	movi	r5,1
8111eac4:	01204574 	movhi	r4,33045
8111eac8:	2105be04 	addi	r4,r4,5880
8111eacc:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ead0:	0001883a 	nop
8111ead4:	e037883a 	mov	sp,fp
8111ead8:	dfc00117 	ldw	ra,4(sp)
8111eadc:	df000017 	ldw	fp,0(sp)
8111eae0:	dec00204 	addi	sp,sp,8
8111eae4:	f800283a 	ret

8111eae8 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111eae8:	defffe04 	addi	sp,sp,-8
8111eaec:	de00012e 	bgeu	sp,et,8111eaf4 <vFailFlushQueueData+0xc>
8111eaf0:	003b68fa 	trap	3
8111eaf4:	dfc00115 	stw	ra,4(sp)
8111eaf8:	df000015 	stw	fp,0(sp)
8111eafc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eb00:	00a045f4 	movhi	r2,33047
8111eb04:	10a00404 	addi	r2,r2,-32752
8111eb08:	10800e8b 	ldhu	r2,58(r2)
8111eb0c:	10bfffcc 	andi	r2,r2,65535
8111eb10:	108001e8 	cmpgeui	r2,r2,7
8111eb14:	1000071e 	bne	r2,zero,8111eb34 <vFailFlushQueueData+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111eb18:	d0a06217 	ldw	r2,-32376(gp)
8111eb1c:	100f883a 	mov	r7,r2
8111eb20:	01800844 	movi	r6,33
8111eb24:	01400044 	movi	r5,1
8111eb28:	01204574 	movhi	r4,33045
8111eb2c:	2105c604 	addi	r4,r4,5912
8111eb30:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb34:	0001883a 	nop
8111eb38:	e037883a 	mov	sp,fp
8111eb3c:	dfc00117 	ldw	ra,4(sp)
8111eb40:	df000017 	ldw	fp,0(sp)
8111eb44:	dec00204 	addi	sp,sp,8
8111eb48:	f800283a 	ret

8111eb4c <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111eb4c:	defffe04 	addi	sp,sp,-8
8111eb50:	de00012e 	bgeu	sp,et,8111eb58 <vFailFlushMEBQueue+0xc>
8111eb54:	003b68fa 	trap	3
8111eb58:	dfc00115 	stw	ra,4(sp)
8111eb5c:	df000015 	stw	fp,0(sp)
8111eb60:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eb64:	00a045f4 	movhi	r2,33047
8111eb68:	10a00404 	addi	r2,r2,-32752
8111eb6c:	10800e8b 	ldhu	r2,58(r2)
8111eb70:	10bfffcc 	andi	r2,r2,65535
8111eb74:	108001e8 	cmpgeui	r2,r2,7
8111eb78:	1000071e 	bne	r2,zero,8111eb98 <vFailFlushMEBQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111eb7c:	d0a06217 	ldw	r2,-32376(gp)
8111eb80:	100f883a 	mov	r7,r2
8111eb84:	01800804 	movi	r6,32
8111eb88:	01400044 	movi	r5,1
8111eb8c:	01204574 	movhi	r4,33045
8111eb90:	2105cf04 	addi	r4,r4,5948
8111eb94:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb98:	0001883a 	nop
8111eb9c:	e037883a 	mov	sp,fp
8111eba0:	dfc00117 	ldw	ra,4(sp)
8111eba4:	df000017 	ldw	fp,0(sp)
8111eba8:	dec00204 	addi	sp,sp,8
8111ebac:	f800283a 	ret

8111ebb0 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111ebb0:	defffe04 	addi	sp,sp,-8
8111ebb4:	de00012e 	bgeu	sp,et,8111ebbc <vFailFlushNFEEQueue+0xc>
8111ebb8:	003b68fa 	trap	3
8111ebbc:	dfc00115 	stw	ra,4(sp)
8111ebc0:	df000015 	stw	fp,0(sp)
8111ebc4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ebc8:	00a045f4 	movhi	r2,33047
8111ebcc:	10a00404 	addi	r2,r2,-32752
8111ebd0:	10800e8b 	ldhu	r2,58(r2)
8111ebd4:	10bfffcc 	andi	r2,r2,65535
8111ebd8:	108001e8 	cmpgeui	r2,r2,7
8111ebdc:	1000071e 	bne	r2,zero,8111ebfc <vFailFlushNFEEQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111ebe0:	d0a06217 	ldw	r2,-32376(gp)
8111ebe4:	100f883a 	mov	r7,r2
8111ebe8:	01800844 	movi	r6,33
8111ebec:	01400044 	movi	r5,1
8111ebf0:	01204574 	movhi	r4,33045
8111ebf4:	2105d804 	addi	r4,r4,5984
8111ebf8:	11230300 	call	81123030 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ebfc:	0001883a 	nop
8111ec00:	e037883a 	mov	sp,fp
8111ec04:	dfc00117 	ldw	ra,4(sp)
8111ec08:	df000017 	ldw	fp,0(sp)
8111ec0c:	dec00204 	addi	sp,sp,8
8111ec10:	f800283a 	ret

8111ec14 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111ec14:	deffff04 	addi	sp,sp,-4
8111ec18:	de00012e 	bgeu	sp,et,8111ec20 <vEvtChangeMebMode+0xc>
8111ec1c:	003b68fa 	trap	3
8111ec20:	df000015 	stw	fp,0(sp)
8111ec24:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ec28:	0001883a 	nop
8111ec2c:	e037883a 	mov	sp,fp
8111ec30:	df000017 	ldw	fp,0(sp)
8111ec34:	dec00104 	addi	sp,sp,4
8111ec38:	f800283a 	ret

8111ec3c <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111ec3c:	deffff04 	addi	sp,sp,-4
8111ec40:	de00012e 	bgeu	sp,et,8111ec48 <vEvtChangeFeeControllerMode+0xc>
8111ec44:	003b68fa 	trap	3
8111ec48:	df000015 	stw	fp,0(sp)
8111ec4c:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ec50:	0001883a 	nop
8111ec54:	e037883a 	mov	sp,fp
8111ec58:	df000017 	ldw	fp,0(sp)
8111ec5c:	dec00104 	addi	sp,sp,4
8111ec60:	f800283a 	ret

8111ec64 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111ec64:	deffff04 	addi	sp,sp,-4
8111ec68:	de00012e 	bgeu	sp,et,8111ec70 <vEvtChangeDataControllerMode+0xc>
8111ec6c:	003b68fa 	trap	3
8111ec70:	df000015 	stw	fp,0(sp)
8111ec74:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ec78:	0001883a 	nop
8111ec7c:	e037883a 	mov	sp,fp
8111ec80:	df000017 	ldw	fp,0(sp)
8111ec84:	dec00104 	addi	sp,sp,4
8111ec88:	f800283a 	ret

8111ec8c <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111ec8c:	defffd04 	addi	sp,sp,-12
8111ec90:	de00012e 	bgeu	sp,et,8111ec98 <vNFeeNotInUse+0xc>
8111ec94:	003b68fa 	trap	3
8111ec98:	df000215 	stw	fp,8(sp)
8111ec9c:	df000204 	addi	fp,sp,8
8111eca0:	e13ffe15 	stw	r4,-8(fp)
8111eca4:	2805883a 	mov	r2,r5
8111eca8:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111ecac:	e0bffe17 	ldw	r2,-8(fp)
8111ecb0:	e0ffff03 	ldbu	r3,-4(fp)
8111ecb4:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111ecb8:	e0bffe17 	ldw	r2,-8(fp)
8111ecbc:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111ecc0:	e0bffe17 	ldw	r2,-8(fp)
8111ecc4:	10002315 	stw	zero,140(r2)
}
8111ecc8:	0001883a 	nop
8111eccc:	e037883a 	mov	sp,fp
8111ecd0:	df000017 	ldw	fp,0(sp)
8111ecd4:	dec00104 	addi	sp,sp,4
8111ecd8:	f800283a 	ret

8111ecdc <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111ecdc:	defffb04 	addi	sp,sp,-20
8111ece0:	de00012e 	bgeu	sp,et,8111ece8 <vNFeeStructureInit+0xc>
8111ece4:	003b68fa 	trap	3
8111ece8:	dfc00415 	stw	ra,16(sp)
8111ecec:	df000315 	stw	fp,12(sp)
8111ecf0:	df000304 	addi	fp,sp,12
8111ecf4:	e13ffe15 	stw	r4,-8(fp)
8111ecf8:	2805883a 	mov	r2,r5
8111ecfc:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111ed00:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111ed04:	e0bffe17 	ldw	r2,-8(fp)
8111ed08:	e0ffff03 	ldbu	r3,-4(fp)
8111ed0c:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111ed10:	e0bffe17 	ldw	r2,-8(fp)
8111ed14:	10802f04 	addi	r2,r2,188
8111ed18:	1009883a 	mov	r4,r2
8111ed1c:	11191200 	call	81119120 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111ed20:	e13ffe17 	ldw	r4,-8(fp)
8111ed24:	111ef600 	call	8111ef60 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111ed28:	e0bffe17 	ldw	r2,-8(fp)
8111ed2c:	00c00044 	movi	r3,1
8111ed30:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111ed34:	e0bffe17 	ldw	r2,-8(fp)
8111ed38:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111ed3c:	e0bffe17 	ldw	r2,-8(fp)
8111ed40:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111ed44:	e0bffe17 	ldw	r2,-8(fp)
8111ed48:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111ed4c:	e0bffe17 	ldw	r2,-8(fp)
8111ed50:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111ed54:	e0bffe17 	ldw	r2,-8(fp)
8111ed58:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111ed5c:	e0bffe17 	ldw	r2,-8(fp)
8111ed60:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111ed64:	e0bffe17 	ldw	r2,-8(fp)
8111ed68:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111ed6c:	e0bffe17 	ldw	r2,-8(fp)
8111ed70:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111ed74:	e0bffe17 	ldw	r2,-8(fp)
8111ed78:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111ed7c:	e0bffe17 	ldw	r2,-8(fp)
8111ed80:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111ed84:	e0bffe17 	ldw	r2,-8(fp)
8111ed88:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
8111ed8c:	e0bfff03 	ldbu	r2,-4(fp)
8111ed90:	1000071e 	bne	r2,zero,8111edb0 <vNFeeStructureInit+0xd4>
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
8111ed94:	00a045f4 	movhi	r2,33047
8111ed98:	10a00404 	addi	r2,r2,-32752
8111ed9c:	10800e0b 	ldhu	r2,56(r2)
8111eda0:	1007883a 	mov	r3,r2
8111eda4:	e0bffe17 	ldw	r2,-8(fp)
8111eda8:	10c00045 	stb	r3,1(r2)
			break;
8111edac:	00001006 	br	8111edf0 <vNFeeStructureInit+0x114>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111edb0:	00a045f4 	movhi	r2,33047
8111edb4:	10a00404 	addi	r2,r2,-32752
8111edb8:	10800e8b 	ldhu	r2,58(r2)
8111edbc:	10bfffcc 	andi	r2,r2,65535
8111edc0:	108001e8 	cmpgeui	r2,r2,7
8111edc4:	1000091e 	bne	r2,zero,8111edec <vNFeeStructureInit+0x110>
				fprintf(fp, "\n CRITICAL! Can't bind the SPW channel with the NFEE %i \n", pxNfeeL->ucId);
8111edc8:	d0e06217 	ldw	r3,-32376(gp)
8111edcc:	e0bffe17 	ldw	r2,-8(fp)
8111edd0:	10800003 	ldbu	r2,0(r2)
8111edd4:	10803fcc 	andi	r2,r2,255
8111edd8:	100d883a 	mov	r6,r2
8111eddc:	01604574 	movhi	r5,33045
8111ede0:	2945e104 	addi	r5,r5,6020
8111ede4:	1809883a 	mov	r4,r3
8111ede8:	11229940 	call	81122994 <fprintf>
			}
			#endif
			break;
8111edec:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111edf0:	e03ffd05 	stb	zero,-12(fp)
8111edf4:	00000906 	br	8111ee1c <vNFeeStructureInit+0x140>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111edf8:	e0bffd03 	ldbu	r2,-12(fp)
8111edfc:	e0fffe17 	ldw	r3,-8(fp)
8111ee00:	1885883a 	add	r2,r3,r2
8111ee04:	10802a44 	addi	r2,r2,169
8111ee08:	e0fffd03 	ldbu	r3,-12(fp)
8111ee0c:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111ee10:	e0bffd03 	ldbu	r2,-12(fp)
8111ee14:	10800044 	addi	r2,r2,1
8111ee18:	e0bffd05 	stb	r2,-12(fp)
8111ee1c:	e0bffd03 	ldbu	r2,-12(fp)
8111ee20:	10800130 	cmpltui	r2,r2,4
8111ee24:	103ff41e 	bne	r2,zero,8111edf8 <__reset+0xfb0fedf8>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8111ee28:	e0bffe17 	ldw	r2,-8(fp)
8111ee2c:	10c03204 	addi	r3,r2,200
8111ee30:	e0bffe17 	ldw	r2,-8(fp)
8111ee34:	10800043 	ldbu	r2,1(r2)
8111ee38:	10803fcc 	andi	r2,r2,255
8111ee3c:	100b883a 	mov	r5,r2
8111ee40:	1809883a 	mov	r4,r3
8111ee44:	11046cc0 	call	811046cc <bCommInitCh>
8111ee48:	10000f1e 	bne	r2,zero,8111ee88 <vNFeeStructureInit+0x1ac>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ee4c:	00a045f4 	movhi	r2,33047
8111ee50:	10a00404 	addi	r2,r2,-32752
8111ee54:	10800e8b 	ldhu	r2,58(r2)
8111ee58:	10bfffcc 	andi	r2,r2,65535
8111ee5c:	108001e8 	cmpgeui	r2,r2,7
8111ee60:	1000091e 	bne	r2,zero,8111ee88 <vNFeeStructureInit+0x1ac>
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111ee64:	d0e06217 	ldw	r3,-32376(gp)
8111ee68:	e0bffe17 	ldw	r2,-8(fp)
8111ee6c:	10800003 	ldbu	r2,0(r2)
8111ee70:	10803fcc 	andi	r2,r2,255
8111ee74:	100d883a 	mov	r6,r2
8111ee78:	01604574 	movhi	r5,33045
8111ee7c:	2945f004 	addi	r5,r5,6080
8111ee80:	1809883a 	mov	r4,r3
8111ee84:	11229940 	call	81122994 <fprintf>
    	}
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8111ee88:	e0bffe17 	ldw	r2,-8(fp)
8111ee8c:	10800043 	ldbu	r2,1(r2)
8111ee90:	10803fcc 	andi	r2,r2,255
8111ee94:	100b883a 	mov	r5,r2
8111ee98:	01000044 	movi	r4,1
8111ee9c:	11045600 	call	81104560 <bCommSetGlobalIrqEn>
8111eea0:	10000f1e 	bne	r2,zero,8111eee0 <vNFeeStructureInit+0x204>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eea4:	00a045f4 	movhi	r2,33047
8111eea8:	10a00404 	addi	r2,r2,-32752
8111eeac:	10800e8b 	ldhu	r2,58(r2)
8111eeb0:	10bfffcc 	andi	r2,r2,65535
8111eeb4:	108001e8 	cmpgeui	r2,r2,7
8111eeb8:	1000091e 	bne	r2,zero,8111eee0 <vNFeeStructureInit+0x204>
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111eebc:	d0e06217 	ldw	r3,-32376(gp)
8111eec0:	e0bffe17 	ldw	r2,-8(fp)
8111eec4:	10800003 	ldbu	r2,0(r2)
8111eec8:	10803fcc 	andi	r2,r2,255
8111eecc:	100d883a 	mov	r6,r2
8111eed0:	01604574 	movhi	r5,33045
8111eed4:	2945fc04 	addi	r5,r5,6128
8111eed8:	1809883a 	mov	r4,r3
8111eedc:	11229940 	call	81122994 <fprintf>
    	}
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111eee0:	e0bffe17 	ldw	r2,-8(fp)
8111eee4:	10803304 	addi	r2,r2,204
8111eee8:	1009883a 	mov	r4,r2
8111eeec:	1104da40 	call	81104da4 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111eef0:	00a045f4 	movhi	r2,33047
8111eef4:	10a00404 	addi	r2,r2,-32752
8111eef8:	10800b17 	ldw	r2,44(r2)
8111eefc:	1009883a 	mov	r4,r2
8111ef00:	11050800 	call	81105080 <usiAdcPxDelayCalcPeriodNs>
8111ef04:	1007883a 	mov	r3,r2
8111ef08:	e0bffe17 	ldw	r2,-8(fp)
8111ef0c:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111ef10:	e0bffe17 	ldw	r2,-8(fp)
8111ef14:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111ef18:	00a045f4 	movhi	r2,33047
8111ef1c:	10a00404 	addi	r2,r2,-32752
8111ef20:	10800917 	ldw	r2,36(r2)
8111ef24:	1009883a 	mov	r4,r2
8111ef28:	110510c0 	call	8110510c <usiLineTrDelayCalcPeriodNs>
8111ef2c:	1007883a 	mov	r3,r2
8111ef30:	e0bffe17 	ldw	r2,-8(fp)
8111ef34:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111ef38:	e0bffe17 	ldw	r2,-8(fp)
8111ef3c:	10803304 	addi	r2,r2,204
8111ef40:	1009883a 	mov	r4,r2
8111ef44:	1104c5c0 	call	81104c5c <bDpktSetPixelDelay>

}
8111ef48:	0001883a 	nop
8111ef4c:	e037883a 	mov	sp,fp
8111ef50:	dfc00117 	ldw	ra,4(sp)
8111ef54:	df000017 	ldw	fp,0(sp)
8111ef58:	dec00204 	addi	sp,sp,8
8111ef5c:	f800283a 	ret

8111ef60 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111ef60:	defff404 	addi	sp,sp,-48
8111ef64:	de00012e 	bgeu	sp,et,8111ef6c <vUpdateMemMapFEE+0xc>
8111ef68:	003b68fa 	trap	3
8111ef6c:	df000b15 	stw	fp,44(sp)
8111ef70:	df000b04 	addi	fp,sp,44
8111ef74:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111ef78:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111ef7c:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111ef80:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111ef84:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111ef88:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111ef8c:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111ef90:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111ef94:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111ef98:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111ef9c:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111efa0:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111efa4:	e17fff17 	ldw	r5,-4(fp)
8111efa8:	01035a34 	movhi	r4,3432
8111efac:	21348c04 	addi	r4,r4,-11728
8111efb0:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111efb4:	e13fff17 	ldw	r4,-4(fp)
8111efb8:	21000003 	ldbu	r4,0(r4)
8111efbc:	21403fcc 	andi	r5,r4,255
8111efc0:	01035a34 	movhi	r4,3432
8111efc4:	21348c04 	addi	r4,r4,-11728
8111efc8:	2909383a 	mul	r4,r5,r4
8111efcc:	200b883a 	mov	r5,r4
8111efd0:	e13fff17 	ldw	r4,-4(fp)
8111efd4:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111efd8:	e13fff17 	ldw	r4,-4(fp)
8111efdc:	21400117 	ldw	r5,4(r4)
8111efe0:	01033234 	movhi	r4,3272
8111efe4:	21348c04 	addi	r4,r4,-11728
8111efe8:	290b883a 	add	r5,r5,r4
8111efec:	e13fff17 	ldw	r4,-4(fp)
8111eff0:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111eff4:	e13fff17 	ldw	r4,-4(fp)
8111eff8:	2100310b 	ldhu	r4,196(r4)
8111effc:	217fffcc 	andi	r5,r4,65535
8111f000:	e13fff17 	ldw	r4,-4(fp)
8111f004:	2100300b 	ldhu	r4,192(r4)
8111f008:	213fffcc 	andi	r4,r4,65535
8111f00c:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111f010:	e13fff17 	ldw	r4,-4(fp)
8111f014:	2100308b 	ldhu	r4,194(r4)
8111f018:	21bfffcc 	andi	r6,r4,65535
8111f01c:	e13fff17 	ldw	r4,-4(fp)
8111f020:	21002f8b 	ldhu	r4,190(r4)
8111f024:	213fffcc 	andi	r4,r4,65535
8111f028:	310d883a 	add	r6,r6,r4
8111f02c:	e13fff17 	ldw	r4,-4(fp)
8111f030:	21002f0b 	ldhu	r4,188(r4)
8111f034:	213fffcc 	andi	r4,r4,65535
8111f038:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111f03c:	2909383a 	mul	r4,r5,r4
8111f040:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111f044:	e13ffa17 	ldw	r4,-24(fp)
8111f048:	2109883a 	add	r4,r4,r4
8111f04c:	200b883a 	mov	r5,r4
8111f050:	e13fff17 	ldw	r4,-4(fp)
8111f054:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111f058:	e13fff17 	ldw	r4,-4(fp)
8111f05c:	21000517 	ldw	r4,20(r4)
8111f060:	2008d0fa 	srli	r4,r4,3
8111f064:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111f068:	e13fff17 	ldw	r4,-4(fp)
8111f06c:	21000517 	ldw	r4,20(r4)
8111f070:	210001cc 	andi	r4,r4,7
8111f074:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111f078:	e13ffb17 	ldw	r4,-20(fp)
8111f07c:	20001226 	beq	r4,zero,8111f0c8 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111f080:	e13ff517 	ldw	r4,-44(fp)
8111f084:	21000044 	addi	r4,r4,1
8111f088:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111f08c:	e13fff17 	ldw	r4,-4(fp)
8111f090:	21400517 	ldw	r5,20(r4)
8111f094:	e13ffb17 	ldw	r4,-20(fp)
8111f098:	2909c83a 	sub	r4,r5,r4
8111f09c:	21400204 	addi	r5,r4,8
8111f0a0:	e13fff17 	ldw	r4,-4(fp)
8111f0a4:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111f0a8:	e13ffb17 	ldw	r4,-20(fp)
8111f0ac:	200b883a 	mov	r5,r4
8111f0b0:	01000204 	movi	r4,8
8111f0b4:	2149c83a 	sub	r4,r4,r5
8111f0b8:	200b883a 	mov	r5,r4
8111f0bc:	e13fff17 	ldw	r4,-4(fp)
8111f0c0:	21400605 	stb	r5,24(r4)
8111f0c4:	00000206 	br	8111f0d0 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111f0c8:	e13fff17 	ldw	r4,-4(fp)
8111f0cc:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111f0d0:	e13ff517 	ldw	r4,-44(fp)
8111f0d4:	2008d13a 	srli	r4,r4,4
8111f0d8:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111f0dc:	e13ff517 	ldw	r4,-44(fp)
8111f0e0:	210003cc 	andi	r4,r4,15
8111f0e4:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111f0e8:	e13ffc17 	ldw	r4,-16(fp)
8111f0ec:	20000b26 	beq	r4,zero,8111f11c <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111f0f0:	e13ff717 	ldw	r4,-36(fp)
8111f0f4:	21000044 	addi	r4,r4,1
8111f0f8:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111f0fc:	e17ff517 	ldw	r5,-44(fp)
8111f100:	e13ffc17 	ldw	r4,-16(fp)
8111f104:	290bc83a 	sub	r5,r5,r4
8111f108:	e13ff717 	ldw	r4,-36(fp)
8111f10c:	2909883a 	add	r4,r5,r4
8111f110:	21000404 	addi	r4,r4,16
8111f114:	e13ff615 	stw	r4,-40(fp)
8111f118:	00000406 	br	8111f12c <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111f11c:	e17ff517 	ldw	r5,-44(fp)
8111f120:	e13ff717 	ldw	r4,-36(fp)
8111f124:	2909883a 	add	r4,r5,r4
8111f128:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111f12c:	e13ff617 	ldw	r4,-40(fp)
8111f130:	200a90fa 	slli	r5,r4,3
8111f134:	e13fff17 	ldw	r4,-4(fp)
8111f138:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111f13c:	e13ffb17 	ldw	r4,-20(fp)
8111f140:	20000926 	beq	r4,zero,8111f168 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111f144:	e13ffc17 	ldw	r4,-16(fp)
8111f148:	2109883a 	add	r4,r4,r4
8111f14c:	2109883a 	add	r4,r4,r4
8111f150:	200b883a 	mov	r5,r4
8111f154:	e13ffb17 	ldw	r4,-20(fp)
8111f158:	2008d07a 	srli	r4,r4,1
8111f15c:	2909883a 	add	r4,r5,r4
8111f160:	e13ff805 	stb	r4,-32(fp)
8111f164:	00000406 	br	8111f178 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111f168:	e13ffc17 	ldw	r4,-16(fp)
8111f16c:	2109883a 	add	r4,r4,r4
8111f170:	2109883a 	add	r4,r4,r4
8111f174:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111f178:	e13ff803 	ldbu	r4,-32(fp)
8111f17c:	01401004 	movi	r5,64
8111f180:	2909c83a 	sub	r4,r5,r4
8111f184:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8111f188:	e13ffd03 	ldbu	r4,-12(fp)
8111f18c:	217ff804 	addi	r5,r4,-32
8111f190:	28000416 	blt	r5,zero,8111f1a4 <vUpdateMemMapFEE+0x244>
8111f194:	013fffc4 	movi	r4,-1
8111f198:	2146983a 	sll	r3,r4,r5
8111f19c:	0005883a 	mov	r2,zero
8111f1a0:	00000a06 	br	8111f1cc <vUpdateMemMapFEE+0x26c>
8111f1a4:	017fffc4 	movi	r5,-1
8111f1a8:	280cd07a 	srli	r6,r5,1
8111f1ac:	014007c4 	movi	r5,31
8111f1b0:	290bc83a 	sub	r5,r5,r4
8111f1b4:	314ad83a 	srl	r5,r6,r5
8111f1b8:	01bfffc4 	movi	r6,-1
8111f1bc:	3106983a 	sll	r3,r6,r4
8111f1c0:	28c6b03a 	or	r3,r5,r3
8111f1c4:	017fffc4 	movi	r5,-1
8111f1c8:	2904983a 	sll	r2,r5,r4
8111f1cc:	e13fff17 	ldw	r4,-4(fp)
8111f1d0:	20800715 	stw	r2,28(r4)
8111f1d4:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111f1d8:	e0bfff17 	ldw	r2,-4(fp)
8111f1dc:	e0fff717 	ldw	r3,-36(fp)
8111f1e0:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111f1e4:	e0bfff17 	ldw	r2,-4(fp)
8111f1e8:	10c00117 	ldw	r3,4(r2)
8111f1ec:	008004b4 	movhi	r2,18
8111f1f0:	10a40004 	addi	r2,r2,-28672
8111f1f4:	1885883a 	add	r2,r3,r2
8111f1f8:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111f1fc:	e0bfff17 	ldw	r2,-4(fp)
8111f200:	10c00517 	ldw	r3,20(r2)
8111f204:	008000b4 	movhi	r2,2
8111f208:	10a40004 	addi	r2,r2,-28672
8111f20c:	1885883a 	add	r2,r3,r2
8111f210:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f214:	e03ff845 	stb	zero,-31(fp)
8111f218:	00001906 	br	8111f280 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111f21c:	e0bff843 	ldbu	r2,-31(fp)
8111f220:	e0ffff17 	ldw	r3,-4(fp)
8111f224:	10800624 	muli	r2,r2,24
8111f228:	1885883a 	add	r2,r3,r2
8111f22c:	10800904 	addi	r2,r2,36
8111f230:	e0fff917 	ldw	r3,-28(fp)
8111f234:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111f238:	e0fff917 	ldw	r3,-28(fp)
8111f23c:	e0bffe17 	ldw	r2,-8(fp)
8111f240:	1885883a 	add	r2,r3,r2
8111f244:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111f248:	e0bff843 	ldbu	r2,-31(fp)
8111f24c:	e0ffff17 	ldw	r3,-4(fp)
8111f250:	10800624 	muli	r2,r2,24
8111f254:	1885883a 	add	r2,r3,r2
8111f258:	10800c04 	addi	r2,r2,48
8111f25c:	e0fff917 	ldw	r3,-28(fp)
8111f260:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111f264:	e0fff917 	ldw	r3,-28(fp)
8111f268:	e0bffe17 	ldw	r2,-8(fp)
8111f26c:	1885883a 	add	r2,r3,r2
8111f270:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f274:	e0bff843 	ldbu	r2,-31(fp)
8111f278:	10800044 	addi	r2,r2,1
8111f27c:	e0bff845 	stb	r2,-31(fp)
8111f280:	e0bff843 	ldbu	r2,-31(fp)
8111f284:	10800130 	cmpltui	r2,r2,4
8111f288:	103fe41e 	bne	r2,zero,8111f21c <__reset+0xfb0ff21c>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111f28c:	0001883a 	nop
8111f290:	e037883a 	mov	sp,fp
8111f294:	df000017 	ldw	fp,0(sp)
8111f298:	dec00104 	addi	sp,sp,4
8111f29c:	f800283a 	ret

8111f2a0 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111f2a0:	defffd04 	addi	sp,sp,-12
8111f2a4:	de00012e 	bgeu	sp,et,8111f2ac <vResetMemCCDFEE+0xc>
8111f2a8:	003b68fa 	trap	3
8111f2ac:	df000215 	stw	fp,8(sp)
8111f2b0:	df000204 	addi	fp,sp,8
8111f2b4:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111f2b8:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f2bc:	e03ffe05 	stb	zero,-8(fp)
8111f2c0:	00001b06 	br	8111f330 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111f2c4:	e0bffe03 	ldbu	r2,-8(fp)
8111f2c8:	e0ffff17 	ldw	r3,-4(fp)
8111f2cc:	10800624 	muli	r2,r2,24
8111f2d0:	1885883a 	add	r2,r3,r2
8111f2d4:	10800b04 	addi	r2,r2,44
8111f2d8:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111f2dc:	e0bffe03 	ldbu	r2,-8(fp)
8111f2e0:	e0ffff17 	ldw	r3,-4(fp)
8111f2e4:	10800624 	muli	r2,r2,24
8111f2e8:	1885883a 	add	r2,r3,r2
8111f2ec:	10800a04 	addi	r2,r2,40
8111f2f0:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111f2f4:	e0bffe03 	ldbu	r2,-8(fp)
8111f2f8:	e0ffff17 	ldw	r3,-4(fp)
8111f2fc:	10800624 	muli	r2,r2,24
8111f300:	1885883a 	add	r2,r3,r2
8111f304:	10800e04 	addi	r2,r2,56
8111f308:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111f30c:	e0bffe03 	ldbu	r2,-8(fp)
8111f310:	e0ffff17 	ldw	r3,-4(fp)
8111f314:	10800624 	muli	r2,r2,24
8111f318:	1885883a 	add	r2,r3,r2
8111f31c:	10800d04 	addi	r2,r2,52
8111f320:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f324:	e0bffe03 	ldbu	r2,-8(fp)
8111f328:	10800044 	addi	r2,r2,1
8111f32c:	e0bffe05 	stb	r2,-8(fp)
8111f330:	e0bffe03 	ldbu	r2,-8(fp)
8111f334:	10800130 	cmpltui	r2,r2,4
8111f338:	103fe21e 	bne	r2,zero,8111f2c4 <__reset+0xfb0ff2c4>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111f33c:	0001883a 	nop
8111f340:	e037883a 	mov	sp,fp
8111f344:	df000017 	ldw	fp,0(sp)
8111f348:	dec00104 	addi	sp,sp,4
8111f34c:	f800283a 	ret

8111f350 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111f350:	defffe04 	addi	sp,sp,-8
8111f354:	de00012e 	bgeu	sp,et,8111f35c <vFeeSpwRMAPLoadDefault+0xc>
8111f358:	003b68fa 	trap	3
8111f35c:	df000115 	stw	fp,4(sp)
8111f360:	df000104 	addi	fp,sp,4
8111f364:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111f368:	0001883a 	nop
8111f36c:	e037883a 	mov	sp,fp
8111f370:	df000017 	ldw	fp,0(sp)
8111f374:	dec00104 	addi	sp,sp,4
8111f378:	f800283a 	ret

8111f37c <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111f37c:	defffe04 	addi	sp,sp,-8
8111f380:	de00012e 	bgeu	sp,et,8111f388 <vFeeSpwRMAPChangeConfig+0xc>
8111f384:	003b68fa 	trap	3
8111f388:	df000115 	stw	fp,4(sp)
8111f38c:	df000104 	addi	fp,sp,4
8111f390:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111f394:	0001883a 	nop
8111f398:	e037883a 	mov	sp,fp
8111f39c:	df000017 	ldw	fp,0(sp)
8111f3a0:	dec00104 	addi	sp,sp,4
8111f3a4:	f800283a 	ret

8111f3a8 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111f3a8:	defffe04 	addi	sp,sp,-8
8111f3ac:	de00012e 	bgeu	sp,et,8111f3b4 <vFeeSpwRMAPChangeDefault+0xc>
8111f3b0:	003b68fa 	trap	3
8111f3b4:	df000115 	stw	fp,4(sp)
8111f3b8:	df000104 	addi	fp,sp,4
8111f3bc:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111f3c0:	0001883a 	nop
8111f3c4:	e037883a 	mov	sp,fp
8111f3c8:	df000017 	ldw	fp,0(sp)
8111f3cc:	dec00104 	addi	sp,sp,4
8111f3d0:	f800283a 	ret

8111f3d4 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111f3d4:	defffe04 	addi	sp,sp,-8
8111f3d8:	de00012e 	bgeu	sp,et,8111f3e0 <cFeeSpwChannelEnable+0xc>
8111f3dc:	003b68fa 	trap	3
8111f3e0:	df000115 	stw	fp,4(sp)
8111f3e4:	df000104 	addi	fp,sp,4
8111f3e8:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111f3ec:	0001883a 	nop
8111f3f0:	e037883a 	mov	sp,fp
8111f3f4:	df000017 	ldw	fp,0(sp)
8111f3f8:	dec00104 	addi	sp,sp,4
8111f3fc:	f800283a 	ret

8111f400 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111f400:	defffe04 	addi	sp,sp,-8
8111f404:	de00012e 	bgeu	sp,et,8111f40c <cFeeSpwChannelDisable+0xc>
8111f408:	003b68fa 	trap	3
8111f40c:	df000115 	stw	fp,4(sp)
8111f410:	df000104 	addi	fp,sp,4
8111f414:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111f418:	0001883a 	nop
8111f41c:	e037883a 	mov	sp,fp
8111f420:	df000017 	ldw	fp,0(sp)
8111f424:	dec00104 	addi	sp,sp,4
8111f428:	f800283a 	ret

8111f42c <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111f42c:	defffe04 	addi	sp,sp,-8
8111f430:	de00012e 	bgeu	sp,et,8111f438 <cFeeRMAPDump+0xc>
8111f434:	003b68fa 	trap	3
8111f438:	df000115 	stw	fp,4(sp)
8111f43c:	df000104 	addi	fp,sp,4
8111f440:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111f444:	0001883a 	nop
8111f448:	e037883a 	mov	sp,fp
8111f44c:	df000017 	ldw	fp,0(sp)
8111f450:	dec00104 	addi	sp,sp,4
8111f454:	f800283a 	ret

8111f458 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111f458:	defffe04 	addi	sp,sp,-8
8111f45c:	de00012e 	bgeu	sp,et,8111f464 <cFeeRMAPEchoingEnable+0xc>
8111f460:	003b68fa 	trap	3
8111f464:	df000115 	stw	fp,4(sp)
8111f468:	df000104 	addi	fp,sp,4
8111f46c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111f470:	e0bfff17 	ldw	r2,-4(fp)
8111f474:	00c00044 	movi	r3,1
8111f478:	10c02515 	stw	r3,148(r2)
}
8111f47c:	0001883a 	nop
8111f480:	e037883a 	mov	sp,fp
8111f484:	df000017 	ldw	fp,0(sp)
8111f488:	dec00104 	addi	sp,sp,4
8111f48c:	f800283a 	ret

8111f490 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111f490:	defffe04 	addi	sp,sp,-8
8111f494:	de00012e 	bgeu	sp,et,8111f49c <cFeeRMAPEchoingDisable+0xc>
8111f498:	003b68fa 	trap	3
8111f49c:	df000115 	stw	fp,4(sp)
8111f4a0:	df000104 	addi	fp,sp,4
8111f4a4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111f4a8:	e0bfff17 	ldw	r2,-4(fp)
8111f4ac:	10002515 	stw	zero,148(r2)
}
8111f4b0:	0001883a 	nop
8111f4b4:	e037883a 	mov	sp,fp
8111f4b8:	df000017 	ldw	fp,0(sp)
8111f4bc:	dec00104 	addi	sp,sp,4
8111f4c0:	f800283a 	ret

8111f4c4 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111f4c4:	defffe04 	addi	sp,sp,-8
8111f4c8:	de00012e 	bgeu	sp,et,8111f4d0 <cFeeRMAPLogEnable+0xc>
8111f4cc:	003b68fa 	trap	3
8111f4d0:	df000115 	stw	fp,4(sp)
8111f4d4:	df000104 	addi	fp,sp,4
8111f4d8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111f4dc:	e0bfff17 	ldw	r2,-4(fp)
8111f4e0:	00c00044 	movi	r3,1
8111f4e4:	10c02415 	stw	r3,144(r2)
}
8111f4e8:	0001883a 	nop
8111f4ec:	e037883a 	mov	sp,fp
8111f4f0:	df000017 	ldw	fp,0(sp)
8111f4f4:	dec00104 	addi	sp,sp,4
8111f4f8:	f800283a 	ret

8111f4fc <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111f4fc:	defffe04 	addi	sp,sp,-8
8111f500:	de00012e 	bgeu	sp,et,8111f508 <cFeeRMAPLogDisable+0xc>
8111f504:	003b68fa 	trap	3
8111f508:	df000115 	stw	fp,4(sp)
8111f50c:	df000104 	addi	fp,sp,4
8111f510:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111f514:	e0bfff17 	ldw	r2,-4(fp)
8111f518:	10002415 	stw	zero,144(r2)
}
8111f51c:	0001883a 	nop
8111f520:	e037883a 	mov	sp,fp
8111f524:	df000017 	ldw	fp,0(sp)
8111f528:	dec00104 	addi	sp,sp,4
8111f52c:	f800283a 	ret

8111f530 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111f530:	defffc04 	addi	sp,sp,-16
8111f534:	de00012e 	bgeu	sp,et,8111f53c <vNFeeControlInit+0xc>
8111f538:	003b68fa 	trap	3
8111f53c:	dfc00315 	stw	ra,12(sp)
8111f540:	df000215 	stw	fp,8(sp)
8111f544:	df000204 	addi	fp,sp,8
8111f548:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111f54c:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111f550:	e13fff17 	ldw	r4,-4(fp)
8111f554:	111f67c0 	call	8111f67c <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111f558:	e13fff17 	ldw	r4,-4(fp)
8111f55c:	111f6b00 	call	8111f6b0 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111f560:	e0bfff17 	ldw	r2,-4(fp)
8111f564:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111f568:	e03ffe05 	stb	zero,-8(fp)
8111f56c:	00002b06 	br	8111f61c <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111f570:	e0bffe03 	ldbu	r2,-8(fp)
8111f574:	10809624 	muli	r2,r2,600
8111f578:	e0ffff17 	ldw	r3,-4(fp)
8111f57c:	1885883a 	add	r2,r3,r2
8111f580:	e0fffe03 	ldbu	r3,-8(fp)
8111f584:	180b883a 	mov	r5,r3
8111f588:	1009883a 	mov	r4,r2
8111f58c:	111ecdc0 	call	8111ecdc <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111f590:	e0bffe03 	ldbu	r2,-8(fp)
8111f594:	e0fffe03 	ldbu	r3,-8(fp)
8111f598:	18c09624 	muli	r3,r3,600
8111f59c:	18c02104 	addi	r3,r3,132
8111f5a0:	e13fff17 	ldw	r4,-4(fp)
8111f5a4:	20c7883a 	add	r3,r4,r3
8111f5a8:	e13fff17 	ldw	r4,-4(fp)
8111f5ac:	108025c4 	addi	r2,r2,151
8111f5b0:	1085883a 	add	r2,r2,r2
8111f5b4:	1085883a 	add	r2,r2,r2
8111f5b8:	2085883a 	add	r2,r4,r2
8111f5bc:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111f5c0:	e0bffe03 	ldbu	r2,-8(fp)
8111f5c4:	e0fffe03 	ldbu	r3,-8(fp)
8111f5c8:	18c09624 	muli	r3,r3,600
8111f5cc:	18c02704 	addi	r3,r3,156
8111f5d0:	e13fff17 	ldw	r4,-4(fp)
8111f5d4:	20c7883a 	add	r3,r4,r3
8111f5d8:	e13fff17 	ldw	r4,-4(fp)
8111f5dc:	10802604 	addi	r2,r2,152
8111f5e0:	1085883a 	add	r2,r2,r2
8111f5e4:	1085883a 	add	r2,r2,r2
8111f5e8:	2085883a 	add	r2,r4,r2
8111f5ec:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111f5f0:	e0bffe03 	ldbu	r2,-8(fp)
8111f5f4:	e0ffff17 	ldw	r3,-4(fp)
8111f5f8:	18c09617 	ldw	r3,600(r3)
8111f5fc:	e13fff17 	ldw	r4,-4(fp)
8111f600:	10809624 	muli	r2,r2,600
8111f604:	2085883a 	add	r2,r4,r2
8111f608:	10802904 	addi	r2,r2,164
8111f60c:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111f610:	e0bffe03 	ldbu	r2,-8(fp)
8111f614:	10800044 	addi	r2,r2,1
8111f618:	e0bffe05 	stb	r2,-8(fp)
8111f61c:	e0bffe03 	ldbu	r2,-8(fp)
8111f620:	103fd326 	beq	r2,zero,8111f570 <__reset+0xfb0ff570>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111f624:	0001883a 	nop
8111f628:	e037883a 	mov	sp,fp
8111f62c:	dfc00117 	ldw	ra,4(sp)
8111f630:	df000017 	ldw	fp,0(sp)
8111f634:	dec00204 	addi	sp,sp,8
8111f638:	f800283a 	ret

8111f63c <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111f63c:	defffd04 	addi	sp,sp,-12
8111f640:	de00012e 	bgeu	sp,et,8111f648 <vSetTimeCode+0xc>
8111f644:	003b68fa 	trap	3
8111f648:	df000215 	stw	fp,8(sp)
8111f64c:	df000204 	addi	fp,sp,8
8111f650:	e13ffe15 	stw	r4,-8(fp)
8111f654:	2805883a 	mov	r2,r5
8111f658:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111f65c:	e0bffe17 	ldw	r2,-8(fp)
8111f660:	e0ffff03 	ldbu	r3,-4(fp)
8111f664:	10c09905 	stb	r3,612(r2)
}
8111f668:	0001883a 	nop
8111f66c:	e037883a 	mov	sp,fp
8111f670:	df000017 	ldw	fp,0(sp)
8111f674:	dec00104 	addi	sp,sp,4
8111f678:	f800283a 	ret

8111f67c <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111f67c:	defffe04 	addi	sp,sp,-8
8111f680:	de00012e 	bgeu	sp,et,8111f688 <vResetTimeCode+0xc>
8111f684:	003b68fa 	trap	3
8111f688:	df000115 	stw	fp,4(sp)
8111f68c:	df000104 	addi	fp,sp,4
8111f690:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111f694:	e0bfff17 	ldw	r2,-4(fp)
8111f698:	10009905 	stb	zero,612(r2)
}
8111f69c:	0001883a 	nop
8111f6a0:	e037883a 	mov	sp,fp
8111f6a4:	df000017 	ldw	fp,0(sp)
8111f6a8:	dec00104 	addi	sp,sp,4
8111f6ac:	f800283a 	ret

8111f6b0 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111f6b0:	defffe04 	addi	sp,sp,-8
8111f6b4:	de00012e 	bgeu	sp,et,8111f6bc <vLoadDefaultIdNFEEMaster+0xc>
8111f6b8:	003b68fa 	trap	3
8111f6bc:	df000115 	stw	fp,4(sp)
8111f6c0:	df000104 	addi	fp,sp,4
8111f6c4:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111f6c8:	e0bfff17 	ldw	r2,-4(fp)
8111f6cc:	10009945 	stb	zero,613(r2)
}
8111f6d0:	0001883a 	nop
8111f6d4:	e037883a 	mov	sp,fp
8111f6d8:	df000017 	ldw	fp,0(sp)
8111f6dc:	dec00104 	addi	sp,sp,4
8111f6e0:	f800283a 	ret

8111f6e4 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111f6e4:	defffd04 	addi	sp,sp,-12
8111f6e8:	de00012e 	bgeu	sp,et,8111f6f0 <vChangeIdNFEEMaster+0xc>
8111f6ec:	003b68fa 	trap	3
8111f6f0:	df000215 	stw	fp,8(sp)
8111f6f4:	df000204 	addi	fp,sp,8
8111f6f8:	e13ffe15 	stw	r4,-8(fp)
8111f6fc:	2805883a 	mov	r2,r5
8111f700:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111f704:	e0bffe17 	ldw	r2,-8(fp)
8111f708:	e0ffff03 	ldbu	r3,-4(fp)
8111f70c:	10c09945 	stb	r3,613(r2)
}
8111f710:	0001883a 	nop
8111f714:	e037883a 	mov	sp,fp
8111f718:	df000017 	ldw	fp,0(sp)
8111f71c:	dec00104 	addi	sp,sp,4
8111f720:	f800283a 	ret

8111f724 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111f724:	defffd04 	addi	sp,sp,-12
8111f728:	de00012e 	bgeu	sp,et,8111f730 <vChangeDefaultIdNFEEMaster+0xc>
8111f72c:	003b68fa 	trap	3
8111f730:	df000215 	stw	fp,8(sp)
8111f734:	df000204 	addi	fp,sp,8
8111f738:	e13ffe15 	stw	r4,-8(fp)
8111f73c:	2805883a 	mov	r2,r5
8111f740:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111f744:	0001883a 	nop
8111f748:	e037883a 	mov	sp,fp
8111f74c:	df000017 	ldw	fp,0(sp)
8111f750:	dec00104 	addi	sp,sp,4
8111f754:	f800283a 	ret

8111f758 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111f758:	defffe04 	addi	sp,sp,-8
8111f75c:	de00012e 	bgeu	sp,et,8111f764 <vInitSimucamBasicHW+0xc>
8111f760:	003b68fa 	trap	3
8111f764:	dfc00115 	stw	ra,4(sp)
8111f768:	df000015 	stw	fp,0(sp)
8111f76c:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111f770:	01403fc4 	movi	r5,255
8111f774:	0009883a 	mov	r4,zero
8111f778:	110b1880 	call	8110b188 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111f77c:	01400834 	movhi	r5,32
8111f780:	297fffc4 	addi	r5,r5,-1
8111f784:	0009883a 	mov	r4,zero
8111f788:	110b2080 	call	8110b208 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111f78c:	01400074 	movhi	r5,1
8111f790:	01000044 	movi	r4,1
8111f794:	110b2080 	call	8110b208 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111f798:	0009883a 	mov	r4,zero
8111f79c:	110c8c00 	call	8110c8c0 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111f7a0:	0009883a 	mov	r4,zero
8111f7a4:	110c9900 	call	8110c990 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111f7a8:	01008004 	movi	r4,512
8111f7ac:	110c4080 	call	8110c408 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111f7b0:	01008004 	movi	r4,512
8111f7b4:	110c3940 	call	8110c394 <vRstcReleaseDeviceReset>

}
8111f7b8:	0001883a 	nop
8111f7bc:	e037883a 	mov	sp,fp
8111f7c0:	dfc00117 	ldw	ra,4(sp)
8111f7c4:	df000017 	ldw	fp,0(sp)
8111f7c8:	dec00204 	addi	sp,sp,8
8111f7cc:	f800283a 	ret

8111f7d0 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111f7d0:	defffd04 	addi	sp,sp,-12
8111f7d4:	de00012e 	bgeu	sp,et,8111f7dc <bLogWriteSDCard+0xc>
8111f7d8:	003b68fa 	trap	3
8111f7dc:	df000215 	stw	fp,8(sp)
8111f7e0:	df000204 	addi	fp,sp,8
8111f7e4:	e13ffe15 	stw	r4,-8(fp)
8111f7e8:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111f7ec:	00800044 	movi	r2,1
}
8111f7f0:	e037883a 	mov	sp,fp
8111f7f4:	df000017 	ldw	fp,0(sp)
8111f7f8:	dec00104 	addi	sp,sp,4
8111f7fc:	f800283a 	ret

8111f800 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111f800:	deffe004 	addi	sp,sp,-128
8111f804:	de00012e 	bgeu	sp,et,8111f80c <vLogWriteNUC+0xc>
8111f808:	003b68fa 	trap	3
8111f80c:	dfc01f15 	stw	ra,124(sp)
8111f810:	df001e15 	stw	fp,120(sp)
8111f814:	df001e04 	addi	fp,sp,120
8111f818:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111f81c:	e03fe215 	stw	zero,-120(fp)
8111f820:	e0bfe304 	addi	r2,fp,-116
8111f824:	00c01b84 	movi	r3,110
8111f828:	180d883a 	mov	r6,r3
8111f82c:	000b883a 	mov	r5,zero
8111f830:	1009883a 	mov	r4,r2
8111f834:	1123b940 	call	81123b94 <memset>
	memset(cTemp,0,114);
8111f838:	01801c84 	movi	r6,114
8111f83c:	000b883a 	mov	r5,zero
8111f840:	e13fe204 	addi	r4,fp,-120
8111f844:	1123b940 	call	81123b94 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111f848:	e13fff17 	ldw	r4,-4(fp)
8111f84c:	11244bc0 	call	811244bc <strlen>
8111f850:	10801c68 	cmpgeui	r2,r2,113
8111f854:	1000031e 	bne	r2,zero,8111f864 <vLogWriteNUC+0x64>
8111f858:	e13fff17 	ldw	r4,-4(fp)
8111f85c:	11244bc0 	call	811244bc <strlen>
8111f860:	00000106 	br	8111f868 <vLogWriteNUC+0x68>
8111f864:	00801c44 	movi	r2,113
8111f868:	100d883a 	mov	r6,r2
8111f86c:	e17fff17 	ldw	r5,-4(fp)
8111f870:	e13fe204 	addi	r4,fp,-120
8111f874:	1123a440 	call	81123a44 <memcpy>
	vSendLog ( cDataIn );
8111f878:	e13fff17 	ldw	r4,-4(fp)
8111f87c:	111a1440 	call	8111a144 <vSendLog>
}
8111f880:	0001883a 	nop
8111f884:	e037883a 	mov	sp,fp
8111f888:	dfc00117 	ldw	ra,4(sp)
8111f88c:	df000017 	ldw	fp,0(sp)
8111f890:	dec00204 	addi	sp,sp,8
8111f894:	f800283a 	ret

8111f898 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111f898:	defffd04 	addi	sp,sp,-12
8111f89c:	de00012e 	bgeu	sp,et,8111f8a4 <vSimucamStructureInit+0xc>
8111f8a0:	003b68fa 	trap	3
8111f8a4:	dfc00215 	stw	ra,8(sp)
8111f8a8:	df000115 	stw	fp,4(sp)
8111f8ac:	df000104 	addi	fp,sp,4
8111f8b0:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111f8b4:	e0bfff17 	ldw	r2,-4(fp)
8111f8b8:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111f8bc:	e0bfff17 	ldw	r2,-4(fp)
8111f8c0:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111f8c4:	e13fff17 	ldw	r4,-4(fp)
8111f8c8:	111f9840 	call	8111f984 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111f8cc:	e13fff17 	ldw	r4,-4(fp)
8111f8d0:	111fa280 	call	8111fa28 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111f8d4:	e13fff17 	ldw	r4,-4(fp)
8111f8d8:	111fad00 	call	8111fad0 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111f8dc:	e13fff17 	ldw	r4,-4(fp)
8111f8e0:	111fb700 	call	8111fb70 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111f8e4:	e0bfff17 	ldw	r2,-4(fp)
8111f8e8:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111f8ec:	e0bfff17 	ldw	r2,-4(fp)
8111f8f0:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111f8f4:	e0bfff17 	ldw	r2,-4(fp)
8111f8f8:	00c07d04 	movi	r3,500
8111f8fc:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111f900:	e0bfff17 	ldw	r2,-4(fp)
8111f904:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111f908:	e0bfff17 	ldw	r2,-4(fp)
8111f90c:	00c00044 	movi	r3,1
8111f910:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111f914:	e0bfff17 	ldw	r2,-4(fp)
8111f918:	10c00204 	addi	r3,r2,8
8111f91c:	e0bfff17 	ldw	r2,-4(fp)
8111f920:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111f924:	e0bfff17 	ldw	r2,-4(fp)
8111f928:	10c00244 	addi	r3,r2,9
8111f92c:	e0bfff17 	ldw	r2,-4(fp)
8111f930:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111f934:	e0bfff17 	ldw	r2,-4(fp)
8111f938:	10800017 	ldw	r2,0(r2)
8111f93c:	10000b1e 	bne	r2,zero,8111f96c <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111f940:	e0bfff17 	ldw	r2,-4(fp)
8111f944:	10801204 	addi	r2,r2,72
8111f948:	1009883a 	mov	r4,r2
8111f94c:	111f5300 	call	8111f530 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111f950:	e0bfff17 	ldw	r2,-4(fp)
8111f954:	10c00a04 	addi	r3,r2,40
8111f958:	e0bfff17 	ldw	r2,-4(fp)
8111f95c:	10801204 	addi	r2,r2,72
8111f960:	100b883a 	mov	r5,r2
8111f964:	1809883a 	mov	r4,r3
8111f968:	111c3f40 	call	8111c3f4 <vDataControllerInit>
        /* Are Fast Fee instances */
        /* todo: Not in use yet */
    }

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */
}
8111f96c:	0001883a 	nop
8111f970:	e037883a 	mov	sp,fp
8111f974:	dfc00117 	ldw	ra,4(sp)
8111f978:	df000017 	ldw	fp,0(sp)
8111f97c:	dec00204 	addi	sp,sp,8
8111f980:	f800283a 	ret

8111f984 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111f984:	defffe04 	addi	sp,sp,-8
8111f988:	de00012e 	bgeu	sp,et,8111f990 <vLoadDefaultEPValue+0xc>
8111f98c:	003b68fa 	trap	3
8111f990:	df000115 	stw	fp,4(sp)
8111f994:	df000104 	addi	fp,sp,4
8111f998:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111f99c:	e0bfff17 	ldw	r2,-4(fp)
8111f9a0:	00d07234 	movhi	r3,16840
8111f9a4:	10c00315 	stw	r3,12(r2)
}
8111f9a8:	0001883a 	nop
8111f9ac:	e037883a 	mov	sp,fp
8111f9b0:	df000017 	ldw	fp,0(sp)
8111f9b4:	dec00104 	addi	sp,sp,4
8111f9b8:	f800283a 	ret

8111f9bc <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111f9bc:	defffd04 	addi	sp,sp,-12
8111f9c0:	de00012e 	bgeu	sp,et,8111f9c8 <vChangeEPValue+0xc>
8111f9c4:	003b68fa 	trap	3
8111f9c8:	df000215 	stw	fp,8(sp)
8111f9cc:	df000204 	addi	fp,sp,8
8111f9d0:	e13ffe15 	stw	r4,-8(fp)
8111f9d4:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111f9d8:	e0bffe17 	ldw	r2,-8(fp)
8111f9dc:	e0ffff17 	ldw	r3,-4(fp)
8111f9e0:	10c00315 	stw	r3,12(r2)
}
8111f9e4:	0001883a 	nop
8111f9e8:	e037883a 	mov	sp,fp
8111f9ec:	df000017 	ldw	fp,0(sp)
8111f9f0:	dec00104 	addi	sp,sp,4
8111f9f4:	f800283a 	ret

8111f9f8 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111f9f8:	defffd04 	addi	sp,sp,-12
8111f9fc:	de00012e 	bgeu	sp,et,8111fa04 <vChangeDefaultEPValue+0xc>
8111fa00:	003b68fa 	trap	3
8111fa04:	df000215 	stw	fp,8(sp)
8111fa08:	df000204 	addi	fp,sp,8
8111fa0c:	e13ffe15 	stw	r4,-8(fp)
8111fa10:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111fa14:	0001883a 	nop
8111fa18:	e037883a 	mov	sp,fp
8111fa1c:	df000017 	ldw	fp,0(sp)
8111fa20:	dec00104 	addi	sp,sp,4
8111fa24:	f800283a 	ret

8111fa28 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111fa28:	defffe04 	addi	sp,sp,-8
8111fa2c:	de00012e 	bgeu	sp,et,8111fa34 <vLoadDefaultRTValue+0xc>
8111fa30:	003b68fa 	trap	3
8111fa34:	df000115 	stw	fp,4(sp)
8111fa38:	df000104 	addi	fp,sp,4
8111fa3c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111fa40:	e0ffff17 	ldw	r3,-4(fp)
8111fa44:	00901eb4 	movhi	r2,16506
8111fa48:	10a66684 	addi	r2,r2,-26214
8111fa4c:	18800415 	stw	r2,16(r3)
}
8111fa50:	0001883a 	nop
8111fa54:	e037883a 	mov	sp,fp
8111fa58:	df000017 	ldw	fp,0(sp)
8111fa5c:	dec00104 	addi	sp,sp,4
8111fa60:	f800283a 	ret

8111fa64 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111fa64:	defffd04 	addi	sp,sp,-12
8111fa68:	de00012e 	bgeu	sp,et,8111fa70 <vChangeRTValue+0xc>
8111fa6c:	003b68fa 	trap	3
8111fa70:	df000215 	stw	fp,8(sp)
8111fa74:	df000204 	addi	fp,sp,8
8111fa78:	e13ffe15 	stw	r4,-8(fp)
8111fa7c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111fa80:	e0bffe17 	ldw	r2,-8(fp)
8111fa84:	e0ffff17 	ldw	r3,-4(fp)
8111fa88:	10c00415 	stw	r3,16(r2)
}
8111fa8c:	0001883a 	nop
8111fa90:	e037883a 	mov	sp,fp
8111fa94:	df000017 	ldw	fp,0(sp)
8111fa98:	dec00104 	addi	sp,sp,4
8111fa9c:	f800283a 	ret

8111faa0 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111faa0:	defffd04 	addi	sp,sp,-12
8111faa4:	de00012e 	bgeu	sp,et,8111faac <vChangeDefaultRTValue+0xc>
8111faa8:	003b68fa 	trap	3
8111faac:	df000215 	stw	fp,8(sp)
8111fab0:	df000204 	addi	fp,sp,8
8111fab4:	e13ffe15 	stw	r4,-8(fp)
8111fab8:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111fabc:	0001883a 	nop
8111fac0:	e037883a 	mov	sp,fp
8111fac4:	df000017 	ldw	fp,0(sp)
8111fac8:	dec00104 	addi	sp,sp,4
8111facc:	f800283a 	ret

8111fad0 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111fad0:	defffe04 	addi	sp,sp,-8
8111fad4:	de00012e 	bgeu	sp,et,8111fadc <vLoadDefaultSyncSource+0xc>
8111fad8:	003b68fa 	trap	3
8111fadc:	df000115 	stw	fp,4(sp)
8111fae0:	df000104 	addi	fp,sp,4
8111fae4:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111fae8:	e0bfff17 	ldw	r2,-4(fp)
8111faec:	10000815 	stw	zero,32(r2)
}
8111faf0:	0001883a 	nop
8111faf4:	e037883a 	mov	sp,fp
8111faf8:	df000017 	ldw	fp,0(sp)
8111fafc:	dec00104 	addi	sp,sp,4
8111fb00:	f800283a 	ret

8111fb04 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111fb04:	defffd04 	addi	sp,sp,-12
8111fb08:	de00012e 	bgeu	sp,et,8111fb10 <vChangeSyncSource+0xc>
8111fb0c:	003b68fa 	trap	3
8111fb10:	df000215 	stw	fp,8(sp)
8111fb14:	df000204 	addi	fp,sp,8
8111fb18:	e13ffe15 	stw	r4,-8(fp)
8111fb1c:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111fb20:	e0bffe17 	ldw	r2,-8(fp)
8111fb24:	e0ffff17 	ldw	r3,-4(fp)
8111fb28:	10c00815 	stw	r3,32(r2)
}
8111fb2c:	0001883a 	nop
8111fb30:	e037883a 	mov	sp,fp
8111fb34:	df000017 	ldw	fp,0(sp)
8111fb38:	dec00104 	addi	sp,sp,4
8111fb3c:	f800283a 	ret

8111fb40 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111fb40:	defffd04 	addi	sp,sp,-12
8111fb44:	de00012e 	bgeu	sp,et,8111fb4c <vChangeDefaultSyncSource+0xc>
8111fb48:	003b68fa 	trap	3
8111fb4c:	df000215 	stw	fp,8(sp)
8111fb50:	df000204 	addi	fp,sp,8
8111fb54:	e13ffe15 	stw	r4,-8(fp)
8111fb58:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111fb5c:	0001883a 	nop
8111fb60:	e037883a 	mov	sp,fp
8111fb64:	df000017 	ldw	fp,0(sp)
8111fb68:	dec00104 	addi	sp,sp,4
8111fb6c:	f800283a 	ret

8111fb70 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111fb70:	defffe04 	addi	sp,sp,-8
8111fb74:	de00012e 	bgeu	sp,et,8111fb7c <vLoadDefaultAutoResetSync+0xc>
8111fb78:	003b68fa 	trap	3
8111fb7c:	df000115 	stw	fp,4(sp)
8111fb80:	df000104 	addi	fp,sp,4
8111fb84:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111fb88:	e0bfff17 	ldw	r2,-4(fp)
8111fb8c:	00c00044 	movi	r3,1
8111fb90:	10c00915 	stw	r3,36(r2)
}
8111fb94:	0001883a 	nop
8111fb98:	e037883a 	mov	sp,fp
8111fb9c:	df000017 	ldw	fp,0(sp)
8111fba0:	dec00104 	addi	sp,sp,4
8111fba4:	f800283a 	ret

8111fba8 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111fba8:	defffd04 	addi	sp,sp,-12
8111fbac:	de00012e 	bgeu	sp,et,8111fbb4 <vChangeAutoResetSync+0xc>
8111fbb0:	003b68fa 	trap	3
8111fbb4:	df000215 	stw	fp,8(sp)
8111fbb8:	df000204 	addi	fp,sp,8
8111fbbc:	e13ffe15 	stw	r4,-8(fp)
8111fbc0:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111fbc4:	e0bffe17 	ldw	r2,-8(fp)
8111fbc8:	e0ffff17 	ldw	r3,-4(fp)
8111fbcc:	10c00915 	stw	r3,36(r2)
}
8111fbd0:	0001883a 	nop
8111fbd4:	e037883a 	mov	sp,fp
8111fbd8:	df000017 	ldw	fp,0(sp)
8111fbdc:	dec00104 	addi	sp,sp,4
8111fbe0:	f800283a 	ret

8111fbe4 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111fbe4:	defffd04 	addi	sp,sp,-12
8111fbe8:	de00012e 	bgeu	sp,et,8111fbf0 <vChangeDefaultAutoResetSync+0xc>
8111fbec:	003b68fa 	trap	3
8111fbf0:	df000215 	stw	fp,8(sp)
8111fbf4:	df000204 	addi	fp,sp,8
8111fbf8:	e13ffe15 	stw	r4,-8(fp)
8111fbfc:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111fc00:	0001883a 	nop
8111fc04:	e037883a 	mov	sp,fp
8111fc08:	df000017 	ldw	fp,0(sp)
8111fc0c:	dec00104 	addi	sp,sp,4
8111fc10:	f800283a 	ret

8111fc14 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111fc14:	defffc04 	addi	sp,sp,-16
8111fc18:	de00012e 	bgeu	sp,et,8111fc20 <vSyncReset+0xc>
8111fc1c:	003b68fa 	trap	3
8111fc20:	dfc00315 	stw	ra,12(sp)
8111fc24:	df000215 	stw	fp,8(sp)
8111fc28:	df000204 	addi	fp,sp,8
8111fc2c:	e13ffe15 	stw	r4,-8(fp)
8111fc30:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111fc34:	e0bffe17 	ldw	r2,-8(fp)
8111fc38:	10801204 	addi	r2,r2,72
8111fc3c:	1009883a 	mov	r4,r2
8111fc40:	111f67c0 	call	8111f67c <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111fc44:	0001883a 	nop
8111fc48:	e037883a 	mov	sp,fp
8111fc4c:	dfc00117 	ldw	ra,4(sp)
8111fc50:	df000017 	ldw	fp,0(sp)
8111fc54:	dec00204 	addi	sp,sp,8
8111fc58:	f800283a 	ret

8111fc5c <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111fc5c:	defff004 	addi	sp,sp,-64
8111fc60:	de00012e 	bgeu	sp,et,8111fc68 <pattern_createPattern+0xc>
8111fc64:	003b68fa 	trap	3
8111fc68:	dfc00f15 	stw	ra,60(sp)
8111fc6c:	df000e15 	stw	fp,56(sp)
8111fc70:	dcc00d15 	stw	r19,52(sp)
8111fc74:	dc800c15 	stw	r18,48(sp)
8111fc78:	dc400b15 	stw	r17,44(sp)
8111fc7c:	dc000a15 	stw	r16,40(sp)
8111fc80:	df000e04 	addi	fp,sp,56
8111fc84:	e17ff915 	stw	r5,-28(fp)
8111fc88:	3007883a 	mov	r3,r6
8111fc8c:	3805883a 	mov	r2,r7
8111fc90:	e13ff805 	stb	r4,-32(fp)
8111fc94:	e0fffa05 	stb	r3,-24(fp)
8111fc98:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111fc9c:	e0bff803 	ldbu	r2,-32(fp)
8111fca0:	1009883a 	mov	r4,r2
8111fca4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111fca8:	e0bff917 	ldw	r2,-28(fp)
8111fcac:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111fcb0:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111fcb4:	e0bff217 	ldw	r2,-56(fp)
8111fcb8:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111fcbc:	e03ff515 	stw	zero,-44(fp)
8111fcc0:	00003606 	br	8111fd9c <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111fcc4:	e03ff615 	stw	zero,-40(fp)
8111fcc8:	00002e06 	br	8111fd84 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111fccc:	e0bff303 	ldbu	r2,-52(fp)
8111fcd0:	10801018 	cmpnei	r2,r2,64
8111fcd4:	10000b1e 	bne	r2,zero,8111fd04 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111fcd8:	e0bff417 	ldw	r2,-48(fp)
8111fcdc:	00ffffc4 	movi	r3,-1
8111fce0:	10c02015 	stw	r3,128(r2)
8111fce4:	00ffffc4 	movi	r3,-1
8111fce8:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111fcec:	e0bff217 	ldw	r2,-56(fp)
8111fcf0:	10802204 	addi	r2,r2,136
8111fcf4:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111fcf8:	e0bff217 	ldw	r2,-56(fp)
8111fcfc:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111fd00:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111fd04:	e0bff303 	ldbu	r2,-52(fp)
8111fd08:	10c00044 	addi	r3,r2,1
8111fd0c:	e0fff305 	stb	r3,-52(fp)
8111fd10:	10803fcc 	andi	r2,r2,255
8111fd14:	e0fffa03 	ldbu	r3,-24(fp)
8111fd18:	18c000cc 	andi	r3,r3,3
8111fd1c:	180692fa 	slli	r3,r3,11
8111fd20:	1809883a 	mov	r4,r3
8111fd24:	00f80004 	movi	r3,-8192
8111fd28:	20c6b03a 	or	r3,r4,r3
8111fd2c:	1809883a 	mov	r4,r3
8111fd30:	e0fffb03 	ldbu	r3,-20(fp)
8111fd34:	18c0004c 	andi	r3,r3,1
8111fd38:	180692ba 	slli	r3,r3,10
8111fd3c:	20c6b03a 	or	r3,r4,r3
8111fd40:	1809883a 	mov	r4,r3
8111fd44:	e0fff517 	ldw	r3,-44(fp)
8111fd48:	18c007cc 	andi	r3,r3,31
8111fd4c:	1806917a 	slli	r3,r3,5
8111fd50:	20c6b03a 	or	r3,r4,r3
8111fd54:	1809883a 	mov	r4,r3
8111fd58:	e0fff617 	ldw	r3,-40(fp)
8111fd5c:	18c007cc 	andi	r3,r3,31
8111fd60:	20c6b03a 	or	r3,r4,r3
8111fd64:	1809883a 	mov	r4,r3
8111fd68:	e0fff417 	ldw	r3,-48(fp)
8111fd6c:	1085883a 	add	r2,r2,r2
8111fd70:	1885883a 	add	r2,r3,r2
8111fd74:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111fd78:	e0bff617 	ldw	r2,-40(fp)
8111fd7c:	10800044 	addi	r2,r2,1
8111fd80:	e0bff615 	stw	r2,-40(fp)
8111fd84:	e0fff617 	ldw	r3,-40(fp)
8111fd88:	e0800217 	ldw	r2,8(fp)
8111fd8c:	18bfcf36 	bltu	r3,r2,8111fccc <__reset+0xfb0ffccc>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111fd90:	e0bff517 	ldw	r2,-44(fp)
8111fd94:	10800044 	addi	r2,r2,1
8111fd98:	e0bff515 	stw	r2,-44(fp)
8111fd9c:	e0fff517 	ldw	r3,-44(fp)
8111fda0:	e0800317 	ldw	r2,12(fp)
8111fda4:	18bfc736 	bltu	r3,r2,8111fcc4 <__reset+0xfb0ffcc4>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
8111fda8:	e0bff417 	ldw	r2,-48(fp)
8111fdac:	10002015 	stw	zero,128(r2)
8111fdb0:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111fdb4:	e03ff705 	stb	zero,-36(fp)
8111fdb8:	00001c06 	br	8111fe2c <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
8111fdbc:	e13ff417 	ldw	r4,-48(fp)
8111fdc0:	20802017 	ldw	r2,128(r4)
8111fdc4:	20c02117 	ldw	r3,132(r4)
8111fdc8:	e13ff703 	ldbu	r4,-36(fp)
8111fdcc:	217ff804 	addi	r5,r4,-32
8111fdd0:	28000416 	blt	r5,zero,8111fde4 <pattern_createPattern+0x188>
8111fdd4:	01200034 	movhi	r4,32768
8111fdd8:	2160d83a 	srl	r16,r4,r5
8111fddc:	0023883a 	mov	r17,zero
8111fde0:	00000a06 	br	8111fe0c <pattern_createPattern+0x1b0>
8111fde4:	01600034 	movhi	r5,32768
8111fde8:	280c907a 	slli	r6,r5,1
8111fdec:	014007c4 	movi	r5,31
8111fdf0:	290bc83a 	sub	r5,r5,r4
8111fdf4:	314a983a 	sll	r5,r6,r5
8111fdf8:	000d883a 	mov	r6,zero
8111fdfc:	3120d83a 	srl	r16,r6,r4
8111fe00:	2c20b03a 	or	r16,r5,r16
8111fe04:	01600034 	movhi	r5,32768
8111fe08:	2922d83a 	srl	r17,r5,r4
8111fe0c:	1424b03a 	or	r18,r2,r16
8111fe10:	1c66b03a 	or	r19,r3,r17
8111fe14:	e0bff417 	ldw	r2,-48(fp)
8111fe18:	14802015 	stw	r18,128(r2)
8111fe1c:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111fe20:	e0bff703 	ldbu	r2,-36(fp)
8111fe24:	10800044 	addi	r2,r2,1
8111fe28:	e0bff705 	stb	r2,-36(fp)
8111fe2c:	e0fff703 	ldbu	r3,-36(fp)
8111fe30:	e0bff303 	ldbu	r2,-52(fp)
8111fe34:	18bfe136 	bltu	r3,r2,8111fdbc <__reset+0xfb0ffdbc>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}

	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111fe38:	e0bff217 	ldw	r2,-56(fp)
8111fe3c:	10802204 	addi	r2,r2,136
8111fe40:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111fe44:	e0bff217 	ldw	r2,-56(fp)
}
8111fe48:	e6fffc04 	addi	sp,fp,-16
8111fe4c:	dfc00517 	ldw	ra,20(sp)
8111fe50:	df000417 	ldw	fp,16(sp)
8111fe54:	dcc00317 	ldw	r19,12(sp)
8111fe58:	dc800217 	ldw	r18,8(sp)
8111fe5c:	dc400117 	ldw	r17,4(sp)
8111fe60:	dc000017 	ldw	r16,0(sp)
8111fe64:	dec00604 	addi	sp,sp,24
8111fe68:	f800283a 	ret

8111fe6c <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111fe6c:	defffe04 	addi	sp,sp,-8
8111fe70:	de00012e 	bgeu	sp,et,8111fe78 <bSDcardIsPresent+0xc>
8111fe74:	003b68fa 	trap	3
8111fe78:	dfc00115 	stw	ra,4(sp)
8111fe7c:	df000015 	stw	fp,0(sp)
8111fe80:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111fe84:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
}
8111fe88:	e037883a 	mov	sp,fp
8111fe8c:	dfc00117 	ldw	ra,4(sp)
8111fe90:	df000017 	ldw	fp,0(sp)
8111fe94:	dec00204 	addi	sp,sp,8
8111fe98:	f800283a 	ret

8111fe9c <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111fe9c:	defffe04 	addi	sp,sp,-8
8111fea0:	de00012e 	bgeu	sp,et,8111fea8 <bSDcardFAT16Check+0xc>
8111fea4:	003b68fa 	trap	3
8111fea8:	dfc00115 	stw	ra,4(sp)
8111feac:	df000015 	stw	fp,0(sp)
8111feb0:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111feb4:	11463400 	call	81146340 <alt_up_sd_card_is_FAT16>
}
8111feb8:	e037883a 	mov	sp,fp
8111febc:	dfc00117 	ldw	ra,4(sp)
8111fec0:	df000017 	ldw	fp,0(sp)
8111fec4:	dec00204 	addi	sp,sp,8
8111fec8:	f800283a 	ret

8111fecc <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111fecc:	defffd04 	addi	sp,sp,-12
8111fed0:	de00012e 	bgeu	sp,et,8111fed8 <bInitializeSDCard+0xc>
8111fed4:	003b68fa 	trap	3
8111fed8:	dfc00215 	stw	ra,8(sp)
8111fedc:	df000115 	stw	fp,4(sp)
8111fee0:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111fee4:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111fee8:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111feec:	01204574 	movhi	r4,33045
8111fef0:	21060c04 	addi	r4,r4,6192
8111fef4:	11461b00 	call	811461b0 <alt_up_sd_card_open_dev>
8111fef8:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111fefc:	d0a07717 	ldw	r2,-32292(gp)
8111ff00:	10002226 	beq	r2,zero,8111ff8c <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111ff04:	111fe6c0 	call	8111fe6c <bSDcardIsPresent>
8111ff08:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111ff0c:	e0bfff17 	ldw	r2,-4(fp)
8111ff10:	10001626 	beq	r2,zero,8111ff6c <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111ff14:	111fe9c0 	call	8111fe9c <bSDcardFAT16Check>
8111ff18:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111ff1c:	e0bfff17 	ldw	r2,-4(fp)
8111ff20:	10000a26 	beq	r2,zero,8111ff4c <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111ff24:	00800044 	movi	r2,1
8111ff28:	d0a07615 	stw	r2,-32296(gp)
				#if DEBUG_ON
					debug(fp, "SD is up.\r\n");
8111ff2c:	d0a06217 	ldw	r2,-32376(gp)
8111ff30:	100f883a 	mov	r7,r2
8111ff34:	018002c4 	movi	r6,11
8111ff38:	01400044 	movi	r5,1
8111ff3c:	01204574 	movhi	r4,33045
8111ff40:	21061704 	addi	r4,r4,6236
8111ff44:	11230300 	call	81123030 <fwrite>
8111ff48:	00001806 	br	8111ffac <bInitializeSDCard+0xe0>
				#endif

			} else {
				/* SD isn't in FAT16 format*/
				#if DEBUG_ON
					debug(fp, "SD Card should be formated in FAT16.\r\n");
8111ff4c:	d0a06217 	ldw	r2,-32376(gp)
8111ff50:	100f883a 	mov	r7,r2
8111ff54:	01800984 	movi	r6,38
8111ff58:	01400044 	movi	r5,1
8111ff5c:	01204574 	movhi	r4,33045
8111ff60:	21061a04 	addi	r4,r4,6248
8111ff64:	11230300 	call	81123030 <fwrite>
8111ff68:	00001006 	br	8111ffac <bInitializeSDCard+0xe0>
				#endif
			}
		} else {
			/* There's no SDCard in the slot */
			#if DEBUG_ON
				debug(fp, "There is no SD in the slot.\r\n");
8111ff6c:	d0a06217 	ldw	r2,-32376(gp)
8111ff70:	100f883a 	mov	r7,r2
8111ff74:	01800744 	movi	r6,29
8111ff78:	01400044 	movi	r5,1
8111ff7c:	01204574 	movhi	r4,33045
8111ff80:	21062404 	addi	r4,r4,6288
8111ff84:	11230300 	call	81123030 <fwrite>
8111ff88:	00000806 	br	8111ffac <bInitializeSDCard+0xe0>
			#endif
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111ff8c:	e03fff15 	stw	zero,-4(fp)
		#if DEBUG_ON
			debug(fp, "Unable to open the SDCard device.\r\n");
8111ff90:	d0a06217 	ldw	r2,-32376(gp)
8111ff94:	100f883a 	mov	r7,r2
8111ff98:	018008c4 	movi	r6,35
8111ff9c:	01400044 	movi	r5,1
8111ffa0:	01204574 	movhi	r4,33045
8111ffa4:	21062c04 	addi	r4,r4,6320
8111ffa8:	11230300 	call	81123030 <fwrite>
		#endif
	}

	return bSucess;
8111ffac:	e0bfff17 	ldw	r2,-4(fp)
}
8111ffb0:	e037883a 	mov	sp,fp
8111ffb4:	dfc00117 	ldw	ra,4(sp)
8111ffb8:	df000017 	ldw	fp,0(sp)
8111ffbc:	dec00204 	addi	sp,sp,8
8111ffc0:	f800283a 	ret

8111ffc4 <siOpenFile>:

short int siOpenFile( char *filename ) {
8111ffc4:	defffd04 	addi	sp,sp,-12
8111ffc8:	de00012e 	bgeu	sp,et,8111ffd0 <siOpenFile+0xc>
8111ffcc:	003b68fa 	trap	3
8111ffd0:	dfc00215 	stw	ra,8(sp)
8111ffd4:	df000115 	stw	fp,4(sp)
8111ffd8:	df000104 	addi	fp,sp,4
8111ffdc:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111ffe0:	000b883a 	mov	r5,zero
8111ffe4:	e13fff17 	ldw	r4,-4(fp)
8111ffe8:	114684c0 	call	8114684c <alt_up_sd_card_fopen>
}
8111ffec:	e037883a 	mov	sp,fp
8111fff0:	dfc00117 	ldw	ra,4(sp)
8111fff4:	df000017 	ldw	fp,0(sp)
8111fff8:	dec00204 	addi	sp,sp,8
8111fffc:	f800283a 	ret

81120000 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81120000:	defffd04 	addi	sp,sp,-12
81120004:	de00012e 	bgeu	sp,et,8112000c <siCloseFile+0xc>
81120008:	003b68fa 	trap	3
8112000c:	dfc00215 	stw	ra,8(sp)
81120010:	df000115 	stw	fp,4(sp)
81120014:	df000104 	addi	fp,sp,4
81120018:	2005883a 	mov	r2,r4
8112001c:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81120020:	e0bfff0f 	ldh	r2,-4(fp)
81120024:	1009883a 	mov	r4,r2
81120028:	11476980 	call	81147698 <alt_up_sd_card_fclose>
}
8112002c:	e037883a 	mov	sp,fp
81120030:	dfc00117 	ldw	ra,4(sp)
81120034:	df000017 	ldw	fp,0(sp)
81120038:	dec00204 	addi	sp,sp,8
8112003c:	f800283a 	ret

81120040 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81120040:	defffd04 	addi	sp,sp,-12
81120044:	de00012e 	bgeu	sp,et,8112004c <cGetNextChar+0xc>
81120048:	003b68fa 	trap	3
8112004c:	dfc00215 	stw	ra,8(sp)
81120050:	df000115 	stw	fp,4(sp)
81120054:	df000104 	addi	fp,sp,4
81120058:	2005883a 	mov	r2,r4
8112005c:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81120060:	e0bfff0f 	ldh	r2,-4(fp)
81120064:	1009883a 	mov	r4,r2
81120068:	1146cf00 	call	81146cf0 <alt_up_sd_card_read>
}
8112006c:	e037883a 	mov	sp,fp
81120070:	dfc00117 	ldw	ra,4(sp)
81120074:	df000017 	ldw	fp,0(sp)
81120078:	dec00204 	addi	sp,sp,8
8112007c:	f800283a 	ret

81120080 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81120080:	defffd04 	addi	sp,sp,-12
81120084:	de00012e 	bgeu	sp,et,8112008c <bInitSync+0xc>
81120088:	003b68fa 	trap	3
8112008c:	dfc00215 	stw	ra,8(sp)
81120090:	df000115 	stw	fp,4(sp)
81120094:	df000104 	addi	fp,sp,4
	bool	bSuccess;

	vSyncInitIrq();
81120098:	110cb0c0 	call	8110cb0c <vSyncInitIrq>

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8112009c:	00a045f4 	movhi	r2,33047
811200a0:	10a00404 	addi	r2,r2,-32752
811200a4:	10800e8b 	ldhu	r2,58(r2)
811200a8:	10bfffcc 	andi	r2,r2,65535
811200ac:	108000e8 	cmpgeui	r2,r2,3
811200b0:	1000071e 	bne	r2,zero,811200d0 <bInitSync+0x50>
		debug(fp, "Initializing Sync Module.\n");
811200b4:	d0a06217 	ldw	r2,-32376(gp)
811200b8:	100f883a 	mov	r7,r2
811200bc:	01800684 	movi	r6,26
811200c0:	01400044 	movi	r5,1
811200c4:	01204574 	movhi	r4,33045
811200c8:	21063504 	addi	r4,r4,6356
811200cc:	11230300 	call	81123030 <fwrite>
	}
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
811200d0:	01004c74 	movhi	r4,305
811200d4:	210b4004 	addi	r4,r4,11520
811200d8:	110cd140 	call	8110cd14 <bSyncSetMbt>
811200dc:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811200e0:	e0bfff17 	ldw	r2,-4(fp)
811200e4:	1000021e 	bne	r2,zero,811200f0 <bInitSync+0x70>
		return bSuccess;
811200e8:	e0bfff17 	ldw	r2,-4(fp)
811200ec:	00004d06 	br	81120224 <bInitSync+0x1a4>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
811200f0:	01002674 	movhi	r4,153
811200f4:	2125a004 	addi	r4,r4,-27008
811200f8:	110cd540 	call	8110cd54 <bSyncSetBt>
811200fc:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120100:	e0bfff17 	ldw	r2,-4(fp)
81120104:	1000021e 	bne	r2,zero,81120110 <bInitSync+0x90>
		return bSuccess;
81120108:	e0bfff17 	ldw	r2,-4(fp)
8112010c:	00004506 	br	81120224 <bInitSync+0x1a4>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
81120110:	00a045f4 	movhi	r2,33047
81120114:	10a00404 	addi	r2,r2,-32752
81120118:	1080068b 	ldhu	r2,26(r2)
8112011c:	10bfffcc 	andi	r2,r2,65535
81120120:	1009883a 	mov	r4,r2
81120124:	110d9ec0 	call	8110d9ec <uliPerCalcPeriodMs>
81120128:	1009883a 	mov	r4,r2
8112012c:	110cd940 	call	8110cd94 <bSyncSetPer>
81120130:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120134:	e0bfff17 	ldw	r2,-4(fp)
81120138:	1000021e 	bne	r2,zero,81120144 <bInitSync+0xc4>
		return bSuccess;
8112013c:	e0bfff17 	ldw	r2,-4(fp)
81120140:	00003806 	br	81120224 <bInitSync+0x1a4>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
81120144:	01005f74 	movhi	r4,381
81120148:	211e1004 	addi	r4,r4,30784
8112014c:	110cdd40 	call	8110cdd4 <bSyncSetOst>
81120150:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120154:	e0bfff17 	ldw	r2,-4(fp)
81120158:	1000021e 	bne	r2,zero,81120164 <bInitSync+0xe4>
		return bSuccess;
8112015c:	e0bfff17 	ldw	r2,-4(fp)
81120160:	00003006 	br	81120224 <bInitSync+0x1a4>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
81120164:	0009883a 	mov	r4,zero
81120168:	110ce140 	call	8110ce14 <bSyncSetPolarity>
8112016c:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120170:	e0bfff17 	ldw	r2,-4(fp)
81120174:	1000021e 	bne	r2,zero,81120180 <bInitSync+0x100>
		return bSuccess;
81120178:	e0bfff17 	ldw	r2,-4(fp)
8112017c:	00002906 	br	81120224 <bInitSync+0x1a4>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81120180:	01000104 	movi	r4,4
81120184:	110ce880 	call	8110ce88 <bSyncSetNCycles>
81120188:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8112018c:	e0bfff17 	ldw	r2,-4(fp)
81120190:	1000021e 	bne	r2,zero,8112019c <bInitSync+0x11c>
		return bSuccess;
81120194:	e0bfff17 	ldw	r2,-4(fp)
81120198:	00002206 	br	81120224 <bInitSync+0x1a4>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8112019c:	01000044 	movi	r4,1
811201a0:	110d0640 	call	8110d064 <bSyncCtrExtnIrq>
811201a4:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811201a8:	e0bfff17 	ldw	r2,-4(fp)
811201ac:	1000021e 	bne	r2,zero,811201b8 <bInitSync+0x138>
		return bSuccess;
811201b0:	e0bfff17 	ldw	r2,-4(fp)
811201b4:	00001b06 	br	81120224 <bInitSync+0x1a4>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
811201b8:	01000044 	movi	r4,1
811201bc:	110d22c0 	call	8110d22c <bSyncCtrSyncOutEnable>
811201c0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811201c4:	e0bfff17 	ldw	r2,-4(fp)
811201c8:	1000021e 	bne	r2,zero,811201d4 <bInitSync+0x154>
		return bSuccess;
811201cc:	e0bfff17 	ldw	r2,-4(fp)
811201d0:	00001406 	br	81120224 <bInitSync+0x1a4>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
811201d4:	01000044 	movi	r4,1
811201d8:	110d2a00 	call	8110d2a0 <bSyncCtrCh1OutEnable>
811201dc:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811201e0:	e0bfff17 	ldw	r2,-4(fp)
811201e4:	1000021e 	bne	r2,zero,811201f0 <bInitSync+0x170>
		return bSuccess;
811201e8:	e0bfff17 	ldw	r2,-4(fp)
811201ec:	00000d06 	br	81120224 <bInitSync+0x1a4>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
811201f0:	01000044 	movi	r4,1
811201f4:	110d3140 	call	8110d314 <bSyncCtrCh2OutEnable>
811201f8:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811201fc:	e0bfff17 	ldw	r2,-4(fp)
81120200:	1000021e 	bne	r2,zero,8112020c <bInitSync+0x18c>
		return bSuccess;
81120204:	e0bfff17 	ldw	r2,-4(fp)
81120208:	00000606 	br	81120224 <bInitSync+0x1a4>
	}

	bSuccess = bSyncCtrStart();
8112020c:	110d0dc0 	call	8110d0dc <bSyncCtrStart>
81120210:	e0bfff15 	stw	r2,-4(fp)
	bSyncCtrReset();
81120214:	110d1300 	call	8110d130 <bSyncCtrReset>
	bSyncIrqEnableBlank(TRUE);
81120218:	01000044 	movi	r4,1
8112021c:	110d6b40 	call	8110d6b4 <bSyncIrqEnableBlank>


	return bSuccess;
81120220:	e0bfff17 	ldw	r2,-4(fp)
}
81120224:	e037883a 	mov	sp,fp
81120228:	dfc00117 	ldw	ra,4(sp)
8112022c:	df000017 	ldw	fp,0(sp)
81120230:	dec00204 	addi	sp,sp,8
81120234:	f800283a 	ret

81120238 <bStartSync>:


bool bStartSync(void) {
81120238:	defffd04 	addi	sp,sp,-12
8112023c:	de00012e 	bgeu	sp,et,81120244 <bStartSync+0xc>
81120240:	003b68fa 	trap	3
81120244:	dfc00215 	stw	ra,8(sp)
81120248:	df000115 	stw	fp,4(sp)
8112024c:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
81120250:	110d1300 	call	8110d130 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
81120254:	110d0dc0 	call	8110d0dc <bSyncCtrStart>
81120258:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8112025c:	e0bfff17 	ldw	r2,-4(fp)
}
81120260:	e037883a 	mov	sp,fp
81120264:	dfc00117 	ldw	ra,4(sp)
81120268:	df000017 	ldw	fp,0(sp)
8112026c:	dec00204 	addi	sp,sp,8
81120270:	f800283a 	ret

81120274 <bStopSync>:

bool bStopSync(void) {
81120274:	defffe04 	addi	sp,sp,-8
81120278:	de00012e 	bgeu	sp,et,81120280 <bStopSync+0xc>
8112027c:	003b68fa 	trap	3
81120280:	dfc00115 	stw	ra,4(sp)
81120284:	df000015 	stw	fp,0(sp)
81120288:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8112028c:	110d1300 	call	8110d130 <bSyncCtrReset>
}
81120290:	e037883a 	mov	sp,fp
81120294:	dfc00117 	ldw	ra,4(sp)
81120298:	df000017 	ldw	fp,0(sp)
8112029c:	dec00204 	addi	sp,sp,8
811202a0:	f800283a 	ret

811202a4 <bClearCounterSync>:

void bClearCounterSync(void) {
811202a4:	defffe04 	addi	sp,sp,-8
811202a8:	de00012e 	bgeu	sp,et,811202b0 <bClearCounterSync+0xc>
811202ac:	003b68fa 	trap	3
811202b0:	dfc00115 	stw	ra,4(sp)
811202b4:	df000015 	stw	fp,0(sp)
811202b8:	d839883a 	mov	fp,sp
	vSyncClearCounter();
811202bc:	110cae00 	call	8110cae0 <vSyncClearCounter>
}
811202c0:	0001883a 	nop
811202c4:	e037883a 	mov	sp,fp
811202c8:	dfc00117 	ldw	ra,4(sp)
811202cc:	df000017 	ldw	fp,0(sp)
811202d0:	dec00204 	addi	sp,sp,8
811202d4:	f800283a 	ret

811202d8 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
811202d8:	defffd04 	addi	sp,sp,-12
811202dc:	de00012e 	bgeu	sp,et,811202e4 <bTestSimucamCriticalHW+0xc>
811202e0:	003b68fa 	trap	3
811202e4:	dfc00215 	stw	ra,8(sp)
811202e8:	df000115 	stw	fp,4(sp)
811202ec:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
811202f0:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
811202f4:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
811202f8:	e0bfff17 	ldw	r2,-4(fp)
811202fc:	1000021e 	bne	r2,zero,81120308 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
81120300:	e0bfff17 	ldw	r2,-4(fp)
81120304:	00000706 	br	81120324 <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
81120308:	1103bec0 	call	81103bec <bSdmaInitM2Dma>
8112030c:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81120310:	e0bfff17 	ldw	r2,-4(fp)
81120314:	1000021e 	bne	r2,zero,81120320 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
81120318:	e0bfff17 	ldw	r2,-4(fp)
8112031c:	00000106 	br	81120324 <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
81120320:	00800044 	movi	r2,1
}
81120324:	e037883a 	mov	sp,fp
81120328:	dfc00117 	ldw	ra,4(sp)
8112032c:	df000017 	ldw	fp,0(sp)
81120330:	dec00204 	addi	sp,sp,8
81120334:	f800283a 	ret

81120338 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81120338:	defffc04 	addi	sp,sp,-16
8112033c:	de00012e 	bgeu	sp,et,81120344 <_reg_write+0xc>
81120340:	003b68fa 	trap	3
81120344:	df000315 	stw	fp,12(sp)
81120348:	df000304 	addi	fp,sp,12
8112034c:	e13ffd15 	stw	r4,-12(fp)
81120350:	e17ffe15 	stw	r5,-8(fp)
81120354:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81120358:	e0bffe17 	ldw	r2,-8(fp)
8112035c:	1085883a 	add	r2,r2,r2
81120360:	1085883a 	add	r2,r2,r2
81120364:	1007883a 	mov	r3,r2
81120368:	e0bffd17 	ldw	r2,-12(fp)
8112036c:	1885883a 	add	r2,r3,r2
81120370:	1007883a 	mov	r3,r2
81120374:	e0bfff17 	ldw	r2,-4(fp)
81120378:	18800035 	stwio	r2,0(r3)
	return 1;
8112037c:	00800044 	movi	r2,1

}
81120380:	e037883a 	mov	sp,fp
81120384:	df000017 	ldw	fp,0(sp)
81120388:	dec00104 	addi	sp,sp,4
8112038c:	f800283a 	ret

81120390 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81120390:	defffc04 	addi	sp,sp,-16
81120394:	de00012e 	bgeu	sp,et,8112039c <_reg_read+0xc>
81120398:	003b68fa 	trap	3
8112039c:	df000315 	stw	fp,12(sp)
811203a0:	df000304 	addi	fp,sp,12
811203a4:	e13ffd15 	stw	r4,-12(fp)
811203a8:	e17ffe15 	stw	r5,-8(fp)
811203ac:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
811203b0:	e0bffe17 	ldw	r2,-8(fp)
811203b4:	1085883a 	add	r2,r2,r2
811203b8:	1085883a 	add	r2,r2,r2
811203bc:	1007883a 	mov	r3,r2
811203c0:	e0bffd17 	ldw	r2,-12(fp)
811203c4:	1885883a 	add	r2,r3,r2
811203c8:	10c00037 	ldwio	r3,0(r2)
811203cc:	e0bfff17 	ldw	r2,-4(fp)
811203d0:	10c00015 	stw	r3,0(r2)
	return 1;
811203d4:	00800044 	movi	r2,1

}
811203d8:	e037883a 	mov	sp,fp
811203dc:	df000017 	ldw	fp,0(sp)
811203e0:	dec00104 	addi	sp,sp,4
811203e4:	f800283a 	ret

811203e8 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
811203e8:	defffa04 	addi	sp,sp,-24
811203ec:	de00012e 	bgeu	sp,et,811203f4 <_print_codec_status+0xc>
811203f0:	003b68fa 	trap	3
811203f4:	dfc00515 	stw	ra,20(sp)
811203f8:	df000415 	stw	fp,16(sp)
811203fc:	df000404 	addi	fp,sp,16
81120400:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
81120404:	e0bfff17 	ldw	r2,-4(fp)
81120408:	1005d1ba 	srai	r2,r2,6
8112040c:	1080004c 	andi	r2,r2,1
81120410:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81120414:	e0bfff17 	ldw	r2,-4(fp)
81120418:	1005d17a 	srai	r2,r2,5
8112041c:	1080004c 	andi	r2,r2,1
81120420:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81120424:	e0bfff17 	ldw	r2,-4(fp)
81120428:	1005d13a 	srai	r2,r2,4
8112042c:	1080004c 	andi	r2,r2,1
81120430:	e0bffe15 	stw	r2,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81120434:	00a045f4 	movhi	r2,33047
81120438:	10a00404 	addi	r2,r2,-32752
8112043c:	10800e8b 	ldhu	r2,58(r2)
81120440:	10bfffcc 	andi	r2,r2,65535
81120444:	108000e8 	cmpgeui	r2,r2,3
81120448:	1000661e 	bne	r2,zero,811205e4 <_print_codec_status+0x1fc>
		sprintf(cDebugBuffer, "-------- link status \n");
8112044c:	00e04574 	movhi	r3,33045
81120450:	18d22004 	addi	r3,r3,18560
81120454:	00a04574 	movhi	r2,33045
81120458:	10863c04 	addi	r2,r2,6384
8112045c:	1009883a 	mov	r4,r2
81120460:	008005c4 	movi	r2,23
81120464:	100d883a 	mov	r6,r2
81120468:	200b883a 	mov	r5,r4
8112046c:	1809883a 	mov	r4,r3
81120470:	1123a440 	call	81123a44 <memcpy>
		debug(fp, cDebugBuffer);
81120474:	d0a06217 	ldw	r2,-32376(gp)
81120478:	01604574 	movhi	r5,33045
8112047c:	29522004 	addi	r5,r5,18560
81120480:	1009883a 	mov	r4,r2
81120484:	11229940 	call	81122994 <fprintf>
		sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
81120488:	e0bffc17 	ldw	r2,-16(fp)
8112048c:	10800058 	cmpnei	r2,r2,1
81120490:	1000031e 	bne	r2,zero,811204a0 <_print_codec_status+0xb8>
81120494:	00a04574 	movhi	r2,33045
81120498:	10864204 	addi	r2,r2,6408
8112049c:	00000206 	br	811204a8 <_print_codec_status+0xc0>
811204a0:	00a04574 	movhi	r2,33045
811204a4:	10864304 	addi	r2,r2,6412
811204a8:	100d883a 	mov	r6,r2
811204ac:	01604574 	movhi	r5,33045
811204b0:	29464404 	addi	r5,r5,6416
811204b4:	01204574 	movhi	r4,33045
811204b8:	21122004 	addi	r4,r4,18560
811204bc:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
811204c0:	d0a06217 	ldw	r2,-32376(gp)
811204c4:	01604574 	movhi	r5,33045
811204c8:	29522004 	addi	r5,r5,18560
811204cc:	1009883a 	mov	r4,r2
811204d0:	11229940 	call	81122994 <fprintf>
		sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
811204d4:	e0bffd17 	ldw	r2,-12(fp)
811204d8:	10800058 	cmpnei	r2,r2,1
811204dc:	1000031e 	bne	r2,zero,811204ec <_print_codec_status+0x104>
811204e0:	00a04574 	movhi	r2,33045
811204e4:	10864204 	addi	r2,r2,6408
811204e8:	00000206 	br	811204f4 <_print_codec_status+0x10c>
811204ec:	00a04574 	movhi	r2,33045
811204f0:	10864304 	addi	r2,r2,6412
811204f4:	100d883a 	mov	r6,r2
811204f8:	01604574 	movhi	r5,33045
811204fc:	29464a04 	addi	r5,r5,6440
81120500:	01204574 	movhi	r4,33045
81120504:	21122004 	addi	r4,r4,18560
81120508:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
8112050c:	d0a06217 	ldw	r2,-32376(gp)
81120510:	01604574 	movhi	r5,33045
81120514:	29522004 	addi	r5,r5,18560
81120518:	1009883a 	mov	r4,r2
8112051c:	11229940 	call	81122994 <fprintf>
		sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
81120520:	e0bffe17 	ldw	r2,-8(fp)
81120524:	10800058 	cmpnei	r2,r2,1
81120528:	1000031e 	bne	r2,zero,81120538 <_print_codec_status+0x150>
8112052c:	00a04574 	movhi	r2,33045
81120530:	10864204 	addi	r2,r2,6408
81120534:	00000206 	br	81120540 <_print_codec_status+0x158>
81120538:	00a04574 	movhi	r2,33045
8112053c:	10864304 	addi	r2,r2,6412
81120540:	100d883a 	mov	r6,r2
81120544:	01604574 	movhi	r5,33045
81120548:	29465004 	addi	r5,r5,6464
8112054c:	01204574 	movhi	r4,33045
81120550:	21122004 	addi	r4,r4,18560
81120554:	11242a80 	call	811242a8 <sprintf>
		debug(fp, cDebugBuffer);
81120558:	d0a06217 	ldw	r2,-32376(gp)
8112055c:	01604574 	movhi	r5,33045
81120560:	29522004 	addi	r5,r5,18560
81120564:	1009883a 	mov	r4,r2
81120568:	11229940 	call	81122994 <fprintf>
		sprintf(cDebugBuffer, "--------  \n");
8112056c:	00a04574 	movhi	r2,33045
81120570:	10922004 	addi	r2,r2,18560
81120574:	00c00b44 	movi	r3,45
81120578:	10c00005 	stb	r3,0(r2)
8112057c:	00c00b44 	movi	r3,45
81120580:	10c00045 	stb	r3,1(r2)
81120584:	00c00b44 	movi	r3,45
81120588:	10c00085 	stb	r3,2(r2)
8112058c:	00c00b44 	movi	r3,45
81120590:	10c000c5 	stb	r3,3(r2)
81120594:	00c00b44 	movi	r3,45
81120598:	10c00105 	stb	r3,4(r2)
8112059c:	00c00b44 	movi	r3,45
811205a0:	10c00145 	stb	r3,5(r2)
811205a4:	00c00b44 	movi	r3,45
811205a8:	10c00185 	stb	r3,6(r2)
811205ac:	00c00b44 	movi	r3,45
811205b0:	10c001c5 	stb	r3,7(r2)
811205b4:	00c00804 	movi	r3,32
811205b8:	10c00205 	stb	r3,8(r2)
811205bc:	00c00804 	movi	r3,32
811205c0:	10c00245 	stb	r3,9(r2)
811205c4:	00c00284 	movi	r3,10
811205c8:	10c00285 	stb	r3,10(r2)
811205cc:	100002c5 	stb	zero,11(r2)
		debug(fp, cDebugBuffer);
811205d0:	d0a06217 	ldw	r2,-32376(gp)
811205d4:	01604574 	movhi	r5,33045
811205d8:	29522004 	addi	r5,r5,18560
811205dc:	1009883a 	mov	r4,r2
811205e0:	11229940 	call	81122994 <fprintf>
	}
#endif
}
811205e4:	0001883a 	nop
811205e8:	e037883a 	mov	sp,fp
811205ec:	dfc00117 	ldw	ra,4(sp)
811205f0:	df000017 	ldw	fp,0(sp)
811205f4:	dec00204 	addi	sp,sp,8
811205f8:	f800283a 	ret

811205fc <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
811205fc:	defffb04 	addi	sp,sp,-20
81120600:	de00012e 	bgeu	sp,et,81120608 <_split_codec_status+0xc>
81120604:	003b68fa 	trap	3
81120608:	df000415 	stw	fp,16(sp)
8112060c:	df000404 	addi	fp,sp,16
81120610:	e13ffc15 	stw	r4,-16(fp)
81120614:	e17ffd15 	stw	r5,-12(fp)
81120618:	e1bffe15 	stw	r6,-8(fp)
8112061c:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81120620:	e0bffc17 	ldw	r2,-16(fp)
81120624:	1005d1ba 	srai	r2,r2,6
81120628:	10c0004c 	andi	r3,r2,1
8112062c:	e0bffd17 	ldw	r2,-12(fp)
81120630:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81120634:	e0bffc17 	ldw	r2,-16(fp)
81120638:	1005d17a 	srai	r2,r2,5
8112063c:	10c0004c 	andi	r3,r2,1
81120640:	e0bffe17 	ldw	r2,-8(fp)
81120644:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
81120648:	e0bffc17 	ldw	r2,-16(fp)
8112064c:	1005d13a 	srai	r2,r2,4
81120650:	10c0004c 	andi	r3,r2,1
81120654:	e0bfff17 	ldw	r2,-4(fp)
81120658:	10c00015 	stw	r3,0(r2)
}
8112065c:	0001883a 	nop
81120660:	e037883a 	mov	sp,fp
81120664:	df000017 	ldw	fp,0(sp)
81120668:	dec00104 	addi	sp,sp,4
8112066c:	f800283a 	ret

81120670 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81120670:	defffc04 	addi	sp,sp,-16
81120674:	de00012e 	bgeu	sp,et,8112067c <aatoh+0xc>
81120678:	003b68fa 	trap	3
8112067c:	df000315 	stw	fp,12(sp)
81120680:	df000304 	addi	fp,sp,12
81120684:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81120688:	e0bfff17 	ldw	r2,-4(fp)
8112068c:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81120690:	e0bffd17 	ldw	r2,-12(fp)
81120694:	10c00003 	ldbu	r3,0(r2)
81120698:	e0bffd17 	ldw	r2,-12(fp)
8112069c:	10800003 	ldbu	r2,0(r2)
811206a0:	10803fcc 	andi	r2,r2,255
811206a4:	10800eb0 	cmpltui	r2,r2,58
811206a8:	1000021e 	bne	r2,zero,811206b4 <aatoh+0x44>
811206ac:	00800dc4 	movi	r2,55
811206b0:	00000106 	br	811206b8 <aatoh+0x48>
811206b4:	00800c04 	movi	r2,48
811206b8:	1885c83a 	sub	r2,r3,r2
811206bc:	1004913a 	slli	r2,r2,4
811206c0:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
811206c4:	e0bffd17 	ldw	r2,-12(fp)
811206c8:	10800044 	addi	r2,r2,1
811206cc:	10c00003 	ldbu	r3,0(r2)
811206d0:	e0bffd17 	ldw	r2,-12(fp)
811206d4:	10800044 	addi	r2,r2,1
811206d8:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
811206dc:	10803fcc 	andi	r2,r2,255
811206e0:	10800eb0 	cmpltui	r2,r2,58
811206e4:	1000021e 	bne	r2,zero,811206f0 <aatoh+0x80>
811206e8:	00800dc4 	movi	r2,55
811206ec:	00000106 	br	811206f4 <aatoh+0x84>
811206f0:	00800c04 	movi	r2,48
811206f4:	1885c83a 	sub	r2,r3,r2
811206f8:	2085883a 	add	r2,r4,r2
811206fc:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81120700:	e0bffe03 	ldbu	r2,-8(fp)
}
81120704:	e037883a 	mov	sp,fp
81120708:	df000017 	ldw	fp,0(sp)
8112070c:	dec00104 	addi	sp,sp,4
81120710:	f800283a 	ret

81120714 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81120714:	defffd04 	addi	sp,sp,-12
81120718:	de00012e 	bgeu	sp,et,81120720 <Verif_Error+0xc>
8112071c:	003b68fa 	trap	3
81120720:	dfc00215 	stw	ra,8(sp)
81120724:	df000115 	stw	fp,4(sp)
81120728:	df000104 	addi	fp,sp,4
8112072c:	2005883a 	mov	r2,r4
81120730:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81120734:	e0bfff03 	ldbu	r2,-4(fp)
81120738:	10000f1e 	bne	r2,zero,81120778 <Verif_Error+0x64>
#if DEBUG_ON
if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8112073c:	00a045f4 	movhi	r2,33047
81120740:	10a00404 	addi	r2,r2,-32752
81120744:	10800e8b 	ldhu	r2,58(r2)
81120748:	10bfffcc 	andi	r2,r2,65535
8112074c:	108001e8 	cmpgeui	r2,r2,7
81120750:	1000071e 	bne	r2,zero,81120770 <Verif_Error+0x5c>
	debug(fp, "ERROR\n\r");
81120754:	d0a06217 	ldw	r2,-32376(gp)
81120758:	100f883a 	mov	r7,r2
8112075c:	018001c4 	movi	r6,7
81120760:	01400044 	movi	r5,1
81120764:	01204574 	movhi	r4,33045
81120768:	21065604 	addi	r4,r4,6488
8112076c:	11230300 	call	81123030 <fwrite>
}
#endif
		return 0;
81120770:	0005883a 	mov	r2,zero
81120774:	00000106 	br	8112077c <Verif_Error+0x68>
	} else
		return 1;
81120778:	00800044 	movi	r2,1
}
8112077c:	e037883a 	mov	sp,fp
81120780:	dfc00117 	ldw	ra,4(sp)
81120784:	df000017 	ldw	fp,0(sp)
81120788:	dec00204 	addi	sp,sp,8
8112078c:	f800283a 	ret

81120790 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81120790:	defffe04 	addi	sp,sp,-8
81120794:	de00012e 	bgeu	sp,et,8112079c <toInt+0xc>
81120798:	003b68fa 	trap	3
8112079c:	df000115 	stw	fp,4(sp)
811207a0:	df000104 	addi	fp,sp,4
811207a4:	2005883a 	mov	r2,r4
811207a8:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
811207ac:	e0bfff03 	ldbu	r2,-4(fp)
811207b0:	10bff404 	addi	r2,r2,-48
}
811207b4:	e037883a 	mov	sp,fp
811207b8:	df000017 	ldw	fp,0(sp)
811207bc:	dec00104 	addi	sp,sp,4
811207c0:	f800283a 	ret

811207c4 <__fixunsdfsi>:
811207c4:	defffd04 	addi	sp,sp,-12
811207c8:	000d883a 	mov	r6,zero
811207cc:	01d07834 	movhi	r7,16864
811207d0:	de00012e 	bgeu	sp,et,811207d8 <__fixunsdfsi+0x14>
811207d4:	003b68fa 	trap	3
811207d8:	dc400115 	stw	r17,4(sp)
811207dc:	dc000015 	stw	r16,0(sp)
811207e0:	dfc00215 	stw	ra,8(sp)
811207e4:	2023883a 	mov	r17,r4
811207e8:	2821883a 	mov	r16,r5
811207ec:	11212b00 	call	811212b0 <__gedf2>
811207f0:	1000080e 	bge	r2,zero,81120814 <__fixunsdfsi+0x50>
811207f4:	8809883a 	mov	r4,r17
811207f8:	800b883a 	mov	r5,r16
811207fc:	11223b00 	call	811223b0 <__fixdfsi>
81120800:	dfc00217 	ldw	ra,8(sp)
81120804:	dc400117 	ldw	r17,4(sp)
81120808:	dc000017 	ldw	r16,0(sp)
8112080c:	dec00304 	addi	sp,sp,12
81120810:	f800283a 	ret
81120814:	000d883a 	mov	r6,zero
81120818:	01d07834 	movhi	r7,16864
8112081c:	8809883a 	mov	r4,r17
81120820:	800b883a 	mov	r5,r16
81120824:	1121aac0 	call	81121aac <__subdf3>
81120828:	180b883a 	mov	r5,r3
8112082c:	1009883a 	mov	r4,r2
81120830:	11223b00 	call	811223b0 <__fixdfsi>
81120834:	00e00034 	movhi	r3,32768
81120838:	10c5883a 	add	r2,r2,r3
8112083c:	003ff006 	br	81120800 <__reset+0xfb100800>

81120840 <__divsf3>:
81120840:	defff504 	addi	sp,sp,-44
81120844:	200cd5fa 	srli	r6,r4,23
81120848:	de00012e 	bgeu	sp,et,81120850 <__divsf3+0x10>
8112084c:	003b68fa 	trap	3
81120850:	dcc00415 	stw	r19,16(sp)
81120854:	2026d7fa 	srli	r19,r4,31
81120858:	00c02034 	movhi	r3,128
8112085c:	dd800715 	stw	r22,28(sp)
81120860:	dd000515 	stw	r20,20(sp)
81120864:	dc800315 	stw	r18,12(sp)
81120868:	18ffffc4 	addi	r3,r3,-1
8112086c:	dfc00a15 	stw	ra,40(sp)
81120870:	df000915 	stw	fp,36(sp)
81120874:	ddc00815 	stw	r23,32(sp)
81120878:	dd400615 	stw	r21,24(sp)
8112087c:	dc400215 	stw	r17,8(sp)
81120880:	dc000115 	stw	r16,4(sp)
81120884:	35003fcc 	andi	r20,r6,255
81120888:	1924703a 	and	r18,r3,r4
8112088c:	9d803fcc 	andi	r22,r19,255
81120890:	a0005226 	beq	r20,zero,811209dc <__divsf3+0x19c>
81120894:	00803fc4 	movi	r2,255
81120898:	a0802e26 	beq	r20,r2,81120954 <__divsf3+0x114>
8112089c:	91002034 	orhi	r4,r18,128
811208a0:	202490fa 	slli	r18,r4,3
811208a4:	a53fe044 	addi	r20,r20,-127
811208a8:	0021883a 	mov	r16,zero
811208ac:	002f883a 	mov	r23,zero
811208b0:	280cd5fa 	srli	r6,r5,23
811208b4:	282ad7fa 	srli	r21,r5,31
811208b8:	00c02034 	movhi	r3,128
811208bc:	18ffffc4 	addi	r3,r3,-1
811208c0:	31803fcc 	andi	r6,r6,255
811208c4:	1962703a 	and	r17,r3,r5
811208c8:	af003fcc 	andi	fp,r21,255
811208cc:	30004a26 	beq	r6,zero,811209f8 <__divsf3+0x1b8>
811208d0:	00803fc4 	movi	r2,255
811208d4:	30804526 	beq	r6,r2,811209ec <__divsf3+0x1ac>
811208d8:	89402034 	orhi	r5,r17,128
811208dc:	282290fa 	slli	r17,r5,3
811208e0:	31bfe044 	addi	r6,r6,-127
811208e4:	000b883a 	mov	r5,zero
811208e8:	2c20b03a 	or	r16,r5,r16
811208ec:	802090ba 	slli	r16,r16,2
811208f0:	00a044b4 	movhi	r2,33042
811208f4:	10824504 	addi	r2,r2,2324
811208f8:	80a1883a 	add	r16,r16,r2
811208fc:	81000017 	ldw	r4,0(r16)
81120900:	9d46f03a 	xor	r3,r19,r21
81120904:	180f883a 	mov	r7,r3
81120908:	18803fcc 	andi	r2,r3,255
8112090c:	a18dc83a 	sub	r6,r20,r6
81120910:	2000683a 	jmp	r4
81120914:	81120af8 	rdprs	r4,r16,18475
81120918:	8112097c 	xorhi	r4,r16,18469
8112091c:	81120aec 	andhi	r4,r16,18475
81120920:	81120968 	cmpgeui	r4,r16,18469
81120924:	81120aec 	andhi	r4,r16,18475
81120928:	81120ac4 	addi	r4,r16,18475
8112092c:	81120aec 	andhi	r4,r16,18475
81120930:	81120968 	cmpgeui	r4,r16,18469
81120934:	8112097c 	xorhi	r4,r16,18469
81120938:	8112097c 	xorhi	r4,r16,18469
8112093c:	81120ac4 	addi	r4,r16,18475
81120940:	81120968 	cmpgeui	r4,r16,18469
81120944:	81120bd8 	cmpnei	r4,r16,18479
81120948:	81120bd8 	cmpnei	r4,r16,18479
8112094c:	81120bd8 	cmpnei	r4,r16,18479
81120950:	81120b8c 	andi	r4,r16,18478
81120954:	9000581e 	bne	r18,zero,81120ab8 <__divsf3+0x278>
81120958:	04000204 	movi	r16,8
8112095c:	05c00084 	movi	r23,2
81120960:	003fd306 	br	811208b0 <__reset+0xfb1008b0>
81120964:	0023883a 	mov	r17,zero
81120968:	e02d883a 	mov	r22,fp
8112096c:	282f883a 	mov	r23,r5
81120970:	00800084 	movi	r2,2
81120974:	b8808f1e 	bne	r23,r2,81120bb4 <__divsf3+0x374>
81120978:	b005883a 	mov	r2,r22
8112097c:	11c0004c 	andi	r7,r2,1
81120980:	013fffc4 	movi	r4,-1
81120984:	000d883a 	mov	r6,zero
81120988:	21003fcc 	andi	r4,r4,255
8112098c:	200895fa 	slli	r4,r4,23
81120990:	38803fcc 	andi	r2,r7,255
81120994:	00c02034 	movhi	r3,128
81120998:	100497fa 	slli	r2,r2,31
8112099c:	18ffffc4 	addi	r3,r3,-1
811209a0:	30c6703a 	and	r3,r6,r3
811209a4:	1906b03a 	or	r3,r3,r4
811209a8:	1884b03a 	or	r2,r3,r2
811209ac:	dfc00a17 	ldw	ra,40(sp)
811209b0:	df000917 	ldw	fp,36(sp)
811209b4:	ddc00817 	ldw	r23,32(sp)
811209b8:	dd800717 	ldw	r22,28(sp)
811209bc:	dd400617 	ldw	r21,24(sp)
811209c0:	dd000517 	ldw	r20,20(sp)
811209c4:	dcc00417 	ldw	r19,16(sp)
811209c8:	dc800317 	ldw	r18,12(sp)
811209cc:	dc400217 	ldw	r17,8(sp)
811209d0:	dc000117 	ldw	r16,4(sp)
811209d4:	dec00b04 	addi	sp,sp,44
811209d8:	f800283a 	ret
811209dc:	90002b1e 	bne	r18,zero,81120a8c <__divsf3+0x24c>
811209e0:	04000104 	movi	r16,4
811209e4:	05c00044 	movi	r23,1
811209e8:	003fb106 	br	811208b0 <__reset+0xfb1008b0>
811209ec:	8800251e 	bne	r17,zero,81120a84 <__divsf3+0x244>
811209f0:	01400084 	movi	r5,2
811209f4:	00000206 	br	81120a00 <__divsf3+0x1c0>
811209f8:	88001a1e 	bne	r17,zero,81120a64 <__divsf3+0x224>
811209fc:	01400044 	movi	r5,1
81120a00:	8160b03a 	or	r16,r16,r5
81120a04:	802090ba 	slli	r16,r16,2
81120a08:	00e044b4 	movhi	r3,33042
81120a0c:	18c28904 	addi	r3,r3,2596
81120a10:	80e1883a 	add	r16,r16,r3
81120a14:	80c00017 	ldw	r3,0(r16)
81120a18:	9d44f03a 	xor	r2,r19,r21
81120a1c:	a18dc83a 	sub	r6,r20,r6
81120a20:	1800683a 	jmp	r3
81120a24:	8112097c 	xorhi	r4,r16,18469
81120a28:	8112097c 	xorhi	r4,r16,18469
81120a2c:	81120bc8 	cmpgei	r4,r16,18479
81120a30:	81120964 	muli	r4,r16,18469
81120a34:	81120bc8 	cmpgei	r4,r16,18479
81120a38:	81120ac4 	addi	r4,r16,18475
81120a3c:	81120bc8 	cmpgei	r4,r16,18479
81120a40:	81120964 	muli	r4,r16,18469
81120a44:	8112097c 	xorhi	r4,r16,18469
81120a48:	8112097c 	xorhi	r4,r16,18469
81120a4c:	81120ac4 	addi	r4,r16,18475
81120a50:	81120964 	muli	r4,r16,18469
81120a54:	81120bd8 	cmpnei	r4,r16,18479
81120a58:	81120bd8 	cmpnei	r4,r16,18479
81120a5c:	81120bd8 	cmpnei	r4,r16,18479
81120a60:	81120bf0 	cmpltui	r4,r16,18479
81120a64:	8809883a 	mov	r4,r17
81120a68:	11227d40 	call	811227d4 <__clzsi2>
81120a6c:	10fffec4 	addi	r3,r2,-5
81120a70:	10801d84 	addi	r2,r2,118
81120a74:	88e2983a 	sll	r17,r17,r3
81120a78:	008dc83a 	sub	r6,zero,r2
81120a7c:	000b883a 	mov	r5,zero
81120a80:	003f9906 	br	811208e8 <__reset+0xfb1008e8>
81120a84:	014000c4 	movi	r5,3
81120a88:	003f9706 	br	811208e8 <__reset+0xfb1008e8>
81120a8c:	9009883a 	mov	r4,r18
81120a90:	d9400015 	stw	r5,0(sp)
81120a94:	11227d40 	call	811227d4 <__clzsi2>
81120a98:	10fffec4 	addi	r3,r2,-5
81120a9c:	11801d84 	addi	r6,r2,118
81120aa0:	90e4983a 	sll	r18,r18,r3
81120aa4:	01a9c83a 	sub	r20,zero,r6
81120aa8:	0021883a 	mov	r16,zero
81120aac:	002f883a 	mov	r23,zero
81120ab0:	d9400017 	ldw	r5,0(sp)
81120ab4:	003f7e06 	br	811208b0 <__reset+0xfb1008b0>
81120ab8:	04000304 	movi	r16,12
81120abc:	05c000c4 	movi	r23,3
81120ac0:	003f7b06 	br	811208b0 <__reset+0xfb1008b0>
81120ac4:	01802034 	movhi	r6,128
81120ac8:	000f883a 	mov	r7,zero
81120acc:	31bfffc4 	addi	r6,r6,-1
81120ad0:	013fffc4 	movi	r4,-1
81120ad4:	003fac06 	br	81120988 <__reset+0xfb100988>
81120ad8:	01400044 	movi	r5,1
81120adc:	2909c83a 	sub	r4,r5,r4
81120ae0:	00c006c4 	movi	r3,27
81120ae4:	19004b0e 	bge	r3,r4,81120c14 <__divsf3+0x3d4>
81120ae8:	114e703a 	and	r7,r2,r5
81120aec:	0009883a 	mov	r4,zero
81120af0:	000d883a 	mov	r6,zero
81120af4:	003fa406 	br	81120988 <__reset+0xfb100988>
81120af8:	9006917a 	slli	r3,r18,5
81120afc:	8822917a 	slli	r17,r17,5
81120b00:	1c40372e 	bgeu	r3,r17,81120be0 <__divsf3+0x3a0>
81120b04:	31bfffc4 	addi	r6,r6,-1
81120b08:	010006c4 	movi	r4,27
81120b0c:	000b883a 	mov	r5,zero
81120b10:	180f883a 	mov	r7,r3
81120b14:	294b883a 	add	r5,r5,r5
81120b18:	18c7883a 	add	r3,r3,r3
81120b1c:	38000116 	blt	r7,zero,81120b24 <__divsf3+0x2e4>
81120b20:	1c400236 	bltu	r3,r17,81120b2c <__divsf3+0x2ec>
81120b24:	1c47c83a 	sub	r3,r3,r17
81120b28:	29400054 	ori	r5,r5,1
81120b2c:	213fffc4 	addi	r4,r4,-1
81120b30:	203ff71e 	bne	r4,zero,81120b10 <__reset+0xfb100b10>
81120b34:	1806c03a 	cmpne	r3,r3,zero
81120b38:	1962b03a 	or	r17,r3,r5
81120b3c:	31001fc4 	addi	r4,r6,127
81120b40:	013fe50e 	bge	zero,r4,81120ad8 <__reset+0xfb100ad8>
81120b44:	88c001cc 	andi	r3,r17,7
81120b48:	18000426 	beq	r3,zero,81120b5c <__divsf3+0x31c>
81120b4c:	88c003cc 	andi	r3,r17,15
81120b50:	01400104 	movi	r5,4
81120b54:	19400126 	beq	r3,r5,81120b5c <__divsf3+0x31c>
81120b58:	8963883a 	add	r17,r17,r5
81120b5c:	88c2002c 	andhi	r3,r17,2048
81120b60:	18000426 	beq	r3,zero,81120b74 <__divsf3+0x334>
81120b64:	00fe0034 	movhi	r3,63488
81120b68:	18ffffc4 	addi	r3,r3,-1
81120b6c:	31002004 	addi	r4,r6,128
81120b70:	88e2703a 	and	r17,r17,r3
81120b74:	00c03f84 	movi	r3,254
81120b78:	193f8016 	blt	r3,r4,8112097c <__reset+0xfb10097c>
81120b7c:	880c91ba 	slli	r6,r17,6
81120b80:	11c0004c 	andi	r7,r2,1
81120b84:	300cd27a 	srli	r6,r6,9
81120b88:	003f7f06 	br	81120988 <__reset+0xfb100988>
81120b8c:	9080102c 	andhi	r2,r18,64
81120b90:	10000226 	beq	r2,zero,81120b9c <__divsf3+0x35c>
81120b94:	8880102c 	andhi	r2,r17,64
81120b98:	10001826 	beq	r2,zero,81120bfc <__divsf3+0x3bc>
81120b9c:	00802034 	movhi	r2,128
81120ba0:	91801034 	orhi	r6,r18,64
81120ba4:	10bfffc4 	addi	r2,r2,-1
81120ba8:	980f883a 	mov	r7,r19
81120bac:	308c703a 	and	r6,r6,r2
81120bb0:	003fc706 	br	81120ad0 <__reset+0xfb100ad0>
81120bb4:	008000c4 	movi	r2,3
81120bb8:	b8802d26 	beq	r23,r2,81120c70 <__divsf3+0x430>
81120bbc:	00c00044 	movi	r3,1
81120bc0:	b005883a 	mov	r2,r22
81120bc4:	b8ffdd1e 	bne	r23,r3,81120b3c <__reset+0xfb100b3c>
81120bc8:	11c0004c 	andi	r7,r2,1
81120bcc:	0009883a 	mov	r4,zero
81120bd0:	000d883a 	mov	r6,zero
81120bd4:	003f6c06 	br	81120988 <__reset+0xfb100988>
81120bd8:	9023883a 	mov	r17,r18
81120bdc:	003f6406 	br	81120970 <__reset+0xfb100970>
81120be0:	1c47c83a 	sub	r3,r3,r17
81120be4:	01000684 	movi	r4,26
81120be8:	01400044 	movi	r5,1
81120bec:	003fc806 	br	81120b10 <__reset+0xfb100b10>
81120bf0:	9080102c 	andhi	r2,r18,64
81120bf4:	103fe926 	beq	r2,zero,81120b9c <__reset+0xfb100b9c>
81120bf8:	0023883a 	mov	r17,zero
81120bfc:	00802034 	movhi	r2,128
81120c00:	89801034 	orhi	r6,r17,64
81120c04:	10bfffc4 	addi	r2,r2,-1
81120c08:	a80f883a 	mov	r7,r21
81120c0c:	308c703a 	and	r6,r6,r2
81120c10:	003faf06 	br	81120ad0 <__reset+0xfb100ad0>
81120c14:	01c00804 	movi	r7,32
81120c18:	390fc83a 	sub	r7,r7,r4
81120c1c:	89ce983a 	sll	r7,r17,r7
81120c20:	890ad83a 	srl	r5,r17,r4
81120c24:	380ec03a 	cmpne	r7,r7,zero
81120c28:	29cab03a 	or	r5,r5,r7
81120c2c:	28c001cc 	andi	r3,r5,7
81120c30:	18000426 	beq	r3,zero,81120c44 <__divsf3+0x404>
81120c34:	28c003cc 	andi	r3,r5,15
81120c38:	01000104 	movi	r4,4
81120c3c:	19000126 	beq	r3,r4,81120c44 <__divsf3+0x404>
81120c40:	290b883a 	add	r5,r5,r4
81120c44:	28c1002c 	andhi	r3,r5,1024
81120c48:	18000426 	beq	r3,zero,81120c5c <__divsf3+0x41c>
81120c4c:	11c0004c 	andi	r7,r2,1
81120c50:	01000044 	movi	r4,1
81120c54:	000d883a 	mov	r6,zero
81120c58:	003f4b06 	br	81120988 <__reset+0xfb100988>
81120c5c:	280a91ba 	slli	r5,r5,6
81120c60:	11c0004c 	andi	r7,r2,1
81120c64:	0009883a 	mov	r4,zero
81120c68:	280cd27a 	srli	r6,r5,9
81120c6c:	003f4606 	br	81120988 <__reset+0xfb100988>
81120c70:	00802034 	movhi	r2,128
81120c74:	89801034 	orhi	r6,r17,64
81120c78:	10bfffc4 	addi	r2,r2,-1
81120c7c:	b00f883a 	mov	r7,r22
81120c80:	308c703a 	and	r6,r6,r2
81120c84:	003f9206 	br	81120ad0 <__reset+0xfb100ad0>

81120c88 <__mulsf3>:
81120c88:	defff504 	addi	sp,sp,-44
81120c8c:	de00012e 	bgeu	sp,et,81120c94 <__mulsf3+0xc>
81120c90:	003b68fa 	trap	3
81120c94:	dc000115 	stw	r16,4(sp)
81120c98:	2020d5fa 	srli	r16,r4,23
81120c9c:	dd400615 	stw	r21,24(sp)
81120ca0:	202ad7fa 	srli	r21,r4,31
81120ca4:	dc800315 	stw	r18,12(sp)
81120ca8:	04802034 	movhi	r18,128
81120cac:	df000915 	stw	fp,36(sp)
81120cb0:	dd000515 	stw	r20,20(sp)
81120cb4:	94bfffc4 	addi	r18,r18,-1
81120cb8:	dfc00a15 	stw	ra,40(sp)
81120cbc:	ddc00815 	stw	r23,32(sp)
81120cc0:	dd800715 	stw	r22,28(sp)
81120cc4:	dcc00415 	stw	r19,16(sp)
81120cc8:	dc400215 	stw	r17,8(sp)
81120ccc:	84003fcc 	andi	r16,r16,255
81120cd0:	9124703a 	and	r18,r18,r4
81120cd4:	a829883a 	mov	r20,r21
81120cd8:	af003fcc 	andi	fp,r21,255
81120cdc:	80005426 	beq	r16,zero,81120e30 <__mulsf3+0x1a8>
81120ce0:	00803fc4 	movi	r2,255
81120ce4:	80802f26 	beq	r16,r2,81120da4 <__mulsf3+0x11c>
81120ce8:	91002034 	orhi	r4,r18,128
81120cec:	202490fa 	slli	r18,r4,3
81120cf0:	843fe044 	addi	r16,r16,-127
81120cf4:	0023883a 	mov	r17,zero
81120cf8:	002f883a 	mov	r23,zero
81120cfc:	2804d5fa 	srli	r2,r5,23
81120d00:	282cd7fa 	srli	r22,r5,31
81120d04:	01002034 	movhi	r4,128
81120d08:	213fffc4 	addi	r4,r4,-1
81120d0c:	10803fcc 	andi	r2,r2,255
81120d10:	2166703a 	and	r19,r4,r5
81120d14:	b1803fcc 	andi	r6,r22,255
81120d18:	10004c26 	beq	r2,zero,81120e4c <__mulsf3+0x1c4>
81120d1c:	00c03fc4 	movi	r3,255
81120d20:	10c04726 	beq	r2,r3,81120e40 <__mulsf3+0x1b8>
81120d24:	99002034 	orhi	r4,r19,128
81120d28:	202690fa 	slli	r19,r4,3
81120d2c:	10bfe044 	addi	r2,r2,-127
81120d30:	0007883a 	mov	r3,zero
81120d34:	80a1883a 	add	r16,r16,r2
81120d38:	010003c4 	movi	r4,15
81120d3c:	1c44b03a 	or	r2,r3,r17
81120d40:	b56af03a 	xor	r21,r22,r21
81120d44:	81c00044 	addi	r7,r16,1
81120d48:	20806b36 	bltu	r4,r2,81120ef8 <__mulsf3+0x270>
81120d4c:	100490ba 	slli	r2,r2,2
81120d50:	012044b4 	movhi	r4,33042
81120d54:	21035904 	addi	r4,r4,3428
81120d58:	1105883a 	add	r2,r2,r4
81120d5c:	10800017 	ldw	r2,0(r2)
81120d60:	1000683a 	jmp	r2
81120d64:	81120ef8 	rdprs	r4,r16,18491
81120d68:	81120db8 	rdprs	r4,r16,18486
81120d6c:	81120db8 	rdprs	r4,r16,18486
81120d70:	81120db4 	orhi	r4,r16,18486
81120d74:	81120edc 	xori	r4,r16,18491
81120d78:	81120edc 	xori	r4,r16,18491
81120d7c:	81120ec8 	cmpgei	r4,r16,18491
81120d80:	81120db4 	orhi	r4,r16,18486
81120d84:	81120edc 	xori	r4,r16,18491
81120d88:	81120ec8 	cmpgei	r4,r16,18491
81120d8c:	81120edc 	xori	r4,r16,18491
81120d90:	81120db4 	orhi	r4,r16,18486
81120d94:	81120ee8 	cmpgeui	r4,r16,18491
81120d98:	81120ee8 	cmpgeui	r4,r16,18491
81120d9c:	81120ee8 	cmpgeui	r4,r16,18491
81120da0:	81120fc4 	addi	r4,r16,18495
81120da4:	90003b1e 	bne	r18,zero,81120e94 <__mulsf3+0x20c>
81120da8:	04400204 	movi	r17,8
81120dac:	05c00084 	movi	r23,2
81120db0:	003fd206 	br	81120cfc <__reset+0xfb100cfc>
81120db4:	302b883a 	mov	r21,r6
81120db8:	00800084 	movi	r2,2
81120dbc:	18802626 	beq	r3,r2,81120e58 <__mulsf3+0x1d0>
81120dc0:	008000c4 	movi	r2,3
81120dc4:	1880ab26 	beq	r3,r2,81121074 <__mulsf3+0x3ec>
81120dc8:	00800044 	movi	r2,1
81120dcc:	1880a21e 	bne	r3,r2,81121058 <__mulsf3+0x3d0>
81120dd0:	a829883a 	mov	r20,r21
81120dd4:	0007883a 	mov	r3,zero
81120dd8:	0009883a 	mov	r4,zero
81120ddc:	18803fcc 	andi	r2,r3,255
81120de0:	100695fa 	slli	r3,r2,23
81120de4:	a0803fcc 	andi	r2,r20,255
81120de8:	100a97fa 	slli	r5,r2,31
81120dec:	00802034 	movhi	r2,128
81120df0:	10bfffc4 	addi	r2,r2,-1
81120df4:	2084703a 	and	r2,r4,r2
81120df8:	10c4b03a 	or	r2,r2,r3
81120dfc:	1144b03a 	or	r2,r2,r5
81120e00:	dfc00a17 	ldw	ra,40(sp)
81120e04:	df000917 	ldw	fp,36(sp)
81120e08:	ddc00817 	ldw	r23,32(sp)
81120e0c:	dd800717 	ldw	r22,28(sp)
81120e10:	dd400617 	ldw	r21,24(sp)
81120e14:	dd000517 	ldw	r20,20(sp)
81120e18:	dcc00417 	ldw	r19,16(sp)
81120e1c:	dc800317 	ldw	r18,12(sp)
81120e20:	dc400217 	ldw	r17,8(sp)
81120e24:	dc000117 	ldw	r16,4(sp)
81120e28:	dec00b04 	addi	sp,sp,44
81120e2c:	f800283a 	ret
81120e30:	90000d1e 	bne	r18,zero,81120e68 <__mulsf3+0x1e0>
81120e34:	04400104 	movi	r17,4
81120e38:	05c00044 	movi	r23,1
81120e3c:	003faf06 	br	81120cfc <__reset+0xfb100cfc>
81120e40:	9806c03a 	cmpne	r3,r19,zero
81120e44:	18c00084 	addi	r3,r3,2
81120e48:	003fba06 	br	81120d34 <__reset+0xfb100d34>
81120e4c:	9800141e 	bne	r19,zero,81120ea0 <__mulsf3+0x218>
81120e50:	00c00044 	movi	r3,1
81120e54:	003fb706 	br	81120d34 <__reset+0xfb100d34>
81120e58:	a829883a 	mov	r20,r21
81120e5c:	00ffffc4 	movi	r3,-1
81120e60:	0009883a 	mov	r4,zero
81120e64:	003fdd06 	br	81120ddc <__reset+0xfb100ddc>
81120e68:	9009883a 	mov	r4,r18
81120e6c:	d9400015 	stw	r5,0(sp)
81120e70:	11227d40 	call	811227d4 <__clzsi2>
81120e74:	10fffec4 	addi	r3,r2,-5
81120e78:	10801d84 	addi	r2,r2,118
81120e7c:	90e4983a 	sll	r18,r18,r3
81120e80:	00a1c83a 	sub	r16,zero,r2
81120e84:	0023883a 	mov	r17,zero
81120e88:	002f883a 	mov	r23,zero
81120e8c:	d9400017 	ldw	r5,0(sp)
81120e90:	003f9a06 	br	81120cfc <__reset+0xfb100cfc>
81120e94:	04400304 	movi	r17,12
81120e98:	05c000c4 	movi	r23,3
81120e9c:	003f9706 	br	81120cfc <__reset+0xfb100cfc>
81120ea0:	9809883a 	mov	r4,r19
81120ea4:	d9800015 	stw	r6,0(sp)
81120ea8:	11227d40 	call	811227d4 <__clzsi2>
81120eac:	10fffec4 	addi	r3,r2,-5
81120eb0:	10801d84 	addi	r2,r2,118
81120eb4:	98e6983a 	sll	r19,r19,r3
81120eb8:	0085c83a 	sub	r2,zero,r2
81120ebc:	0007883a 	mov	r3,zero
81120ec0:	d9800017 	ldw	r6,0(sp)
81120ec4:	003f9b06 	br	81120d34 <__reset+0xfb100d34>
81120ec8:	01002034 	movhi	r4,128
81120ecc:	0029883a 	mov	r20,zero
81120ed0:	213fffc4 	addi	r4,r4,-1
81120ed4:	00ffffc4 	movi	r3,-1
81120ed8:	003fc006 	br	81120ddc <__reset+0xfb100ddc>
81120edc:	9027883a 	mov	r19,r18
81120ee0:	b807883a 	mov	r3,r23
81120ee4:	003fb406 	br	81120db8 <__reset+0xfb100db8>
81120ee8:	9027883a 	mov	r19,r18
81120eec:	e02b883a 	mov	r21,fp
81120ef0:	b807883a 	mov	r3,r23
81120ef4:	003fb006 	br	81120db8 <__reset+0xfb100db8>
81120ef8:	9004d43a 	srli	r2,r18,16
81120efc:	9810d43a 	srli	r8,r19,16
81120f00:	94bfffcc 	andi	r18,r18,65535
81120f04:	993fffcc 	andi	r4,r19,65535
81120f08:	910d383a 	mul	r6,r18,r4
81120f0c:	20a7383a 	mul	r19,r4,r2
81120f10:	9225383a 	mul	r18,r18,r8
81120f14:	3006d43a 	srli	r3,r6,16
81120f18:	1211383a 	mul	r8,r2,r8
81120f1c:	94e5883a 	add	r18,r18,r19
81120f20:	1c87883a 	add	r3,r3,r18
81120f24:	1cc0022e 	bgeu	r3,r19,81120f30 <__mulsf3+0x2a8>
81120f28:	00800074 	movhi	r2,1
81120f2c:	4091883a 	add	r8,r8,r2
81120f30:	1804943a 	slli	r2,r3,16
81120f34:	31bfffcc 	andi	r6,r6,65535
81120f38:	1806d43a 	srli	r3,r3,16
81120f3c:	1185883a 	add	r2,r2,r6
81120f40:	102691ba 	slli	r19,r2,6
81120f44:	1a07883a 	add	r3,r3,r8
81120f48:	1004d6ba 	srli	r2,r2,26
81120f4c:	180891ba 	slli	r4,r3,6
81120f50:	9826c03a 	cmpne	r19,r19,zero
81120f54:	9884b03a 	or	r2,r19,r2
81120f58:	1126b03a 	or	r19,r2,r4
81120f5c:	9882002c 	andhi	r2,r19,2048
81120f60:	10000426 	beq	r2,zero,81120f74 <__mulsf3+0x2ec>
81120f64:	9804d07a 	srli	r2,r19,1
81120f68:	9900004c 	andi	r4,r19,1
81120f6c:	3821883a 	mov	r16,r7
81120f70:	1126b03a 	or	r19,r2,r4
81120f74:	80c01fc4 	addi	r3,r16,127
81120f78:	00c0210e 	bge	zero,r3,81121000 <__mulsf3+0x378>
81120f7c:	988001cc 	andi	r2,r19,7
81120f80:	10000426 	beq	r2,zero,81120f94 <__mulsf3+0x30c>
81120f84:	988003cc 	andi	r2,r19,15
81120f88:	01000104 	movi	r4,4
81120f8c:	11000126 	beq	r2,r4,81120f94 <__mulsf3+0x30c>
81120f90:	9927883a 	add	r19,r19,r4
81120f94:	9882002c 	andhi	r2,r19,2048
81120f98:	10000426 	beq	r2,zero,81120fac <__mulsf3+0x324>
81120f9c:	00be0034 	movhi	r2,63488
81120fa0:	10bfffc4 	addi	r2,r2,-1
81120fa4:	80c02004 	addi	r3,r16,128
81120fa8:	98a6703a 	and	r19,r19,r2
81120fac:	00803f84 	movi	r2,254
81120fb0:	10ffa916 	blt	r2,r3,81120e58 <__reset+0xfb100e58>
81120fb4:	980891ba 	slli	r4,r19,6
81120fb8:	a829883a 	mov	r20,r21
81120fbc:	2008d27a 	srli	r4,r4,9
81120fc0:	003f8606 	br	81120ddc <__reset+0xfb100ddc>
81120fc4:	9080102c 	andhi	r2,r18,64
81120fc8:	10000826 	beq	r2,zero,81120fec <__mulsf3+0x364>
81120fcc:	9880102c 	andhi	r2,r19,64
81120fd0:	1000061e 	bne	r2,zero,81120fec <__mulsf3+0x364>
81120fd4:	00802034 	movhi	r2,128
81120fd8:	99001034 	orhi	r4,r19,64
81120fdc:	10bfffc4 	addi	r2,r2,-1
81120fe0:	b029883a 	mov	r20,r22
81120fe4:	2088703a 	and	r4,r4,r2
81120fe8:	003fba06 	br	81120ed4 <__reset+0xfb100ed4>
81120fec:	00802034 	movhi	r2,128
81120ff0:	91001034 	orhi	r4,r18,64
81120ff4:	10bfffc4 	addi	r2,r2,-1
81120ff8:	2088703a 	and	r4,r4,r2
81120ffc:	003fb506 	br	81120ed4 <__reset+0xfb100ed4>
81121000:	00800044 	movi	r2,1
81121004:	10c7c83a 	sub	r3,r2,r3
81121008:	008006c4 	movi	r2,27
8112100c:	10ff7016 	blt	r2,r3,81120dd0 <__reset+0xfb100dd0>
81121010:	00800804 	movi	r2,32
81121014:	10c5c83a 	sub	r2,r2,r3
81121018:	9884983a 	sll	r2,r19,r2
8112101c:	98c6d83a 	srl	r3,r19,r3
81121020:	1004c03a 	cmpne	r2,r2,zero
81121024:	1884b03a 	or	r2,r3,r2
81121028:	10c001cc 	andi	r3,r2,7
8112102c:	18000426 	beq	r3,zero,81121040 <__mulsf3+0x3b8>
81121030:	10c003cc 	andi	r3,r2,15
81121034:	01000104 	movi	r4,4
81121038:	19000126 	beq	r3,r4,81121040 <__mulsf3+0x3b8>
8112103c:	1105883a 	add	r2,r2,r4
81121040:	10c1002c 	andhi	r3,r2,1024
81121044:	18000626 	beq	r3,zero,81121060 <__mulsf3+0x3d8>
81121048:	a829883a 	mov	r20,r21
8112104c:	00c00044 	movi	r3,1
81121050:	0009883a 	mov	r4,zero
81121054:	003f6106 	br	81120ddc <__reset+0xfb100ddc>
81121058:	3821883a 	mov	r16,r7
8112105c:	003fc506 	br	81120f74 <__reset+0xfb100f74>
81121060:	100491ba 	slli	r2,r2,6
81121064:	a829883a 	mov	r20,r21
81121068:	0007883a 	mov	r3,zero
8112106c:	1008d27a 	srli	r4,r2,9
81121070:	003f5a06 	br	81120ddc <__reset+0xfb100ddc>
81121074:	00802034 	movhi	r2,128
81121078:	99001034 	orhi	r4,r19,64
8112107c:	10bfffc4 	addi	r2,r2,-1
81121080:	a829883a 	mov	r20,r21
81121084:	2088703a 	and	r4,r4,r2
81121088:	003f9206 	br	81120ed4 <__reset+0xfb100ed4>

8112108c <__floatsisf>:
8112108c:	defffd04 	addi	sp,sp,-12
81121090:	de00012e 	bgeu	sp,et,81121098 <__floatsisf+0xc>
81121094:	003b68fa 	trap	3
81121098:	dfc00215 	stw	ra,8(sp)
8112109c:	dc400115 	stw	r17,4(sp)
811210a0:	dc000015 	stw	r16,0(sp)
811210a4:	20003526 	beq	r4,zero,8112117c <__floatsisf+0xf0>
811210a8:	2021883a 	mov	r16,r4
811210ac:	2022d7fa 	srli	r17,r4,31
811210b0:	20003616 	blt	r4,zero,8112118c <__floatsisf+0x100>
811210b4:	8009883a 	mov	r4,r16
811210b8:	11227d40 	call	811227d4 <__clzsi2>
811210bc:	00c02784 	movi	r3,158
811210c0:	1887c83a 	sub	r3,r3,r2
811210c4:	01002584 	movi	r4,150
811210c8:	20c01416 	blt	r4,r3,8112111c <__floatsisf+0x90>
811210cc:	20c9c83a 	sub	r4,r4,r3
811210d0:	8120983a 	sll	r16,r16,r4
811210d4:	00802034 	movhi	r2,128
811210d8:	10bfffc4 	addi	r2,r2,-1
811210dc:	8809883a 	mov	r4,r17
811210e0:	80a0703a 	and	r16,r16,r2
811210e4:	18803fcc 	andi	r2,r3,255
811210e8:	100695fa 	slli	r3,r2,23
811210ec:	20803fcc 	andi	r2,r4,255
811210f0:	100897fa 	slli	r4,r2,31
811210f4:	00802034 	movhi	r2,128
811210f8:	10bfffc4 	addi	r2,r2,-1
811210fc:	8084703a 	and	r2,r16,r2
81121100:	10c4b03a 	or	r2,r2,r3
81121104:	1104b03a 	or	r2,r2,r4
81121108:	dfc00217 	ldw	ra,8(sp)
8112110c:	dc400117 	ldw	r17,4(sp)
81121110:	dc000017 	ldw	r16,0(sp)
81121114:	dec00304 	addi	sp,sp,12
81121118:	f800283a 	ret
8112111c:	01002644 	movi	r4,153
81121120:	20c01c16 	blt	r4,r3,81121194 <__floatsisf+0x108>
81121124:	20c9c83a 	sub	r4,r4,r3
81121128:	8120983a 	sll	r16,r16,r4
8112112c:	013f0034 	movhi	r4,64512
81121130:	213fffc4 	addi	r4,r4,-1
81121134:	814001cc 	andi	r5,r16,7
81121138:	8108703a 	and	r4,r16,r4
8112113c:	28000426 	beq	r5,zero,81121150 <__floatsisf+0xc4>
81121140:	840003cc 	andi	r16,r16,15
81121144:	01400104 	movi	r5,4
81121148:	81400126 	beq	r16,r5,81121150 <__floatsisf+0xc4>
8112114c:	2149883a 	add	r4,r4,r5
81121150:	2141002c 	andhi	r5,r4,1024
81121154:	28000526 	beq	r5,zero,8112116c <__floatsisf+0xe0>
81121158:	00c027c4 	movi	r3,159
8112115c:	1887c83a 	sub	r3,r3,r2
81121160:	00bf0034 	movhi	r2,64512
81121164:	10bfffc4 	addi	r2,r2,-1
81121168:	2088703a 	and	r4,r4,r2
8112116c:	202091ba 	slli	r16,r4,6
81121170:	8809883a 	mov	r4,r17
81121174:	8020d27a 	srli	r16,r16,9
81121178:	003fda06 	br	811210e4 <__reset+0xfb1010e4>
8112117c:	0009883a 	mov	r4,zero
81121180:	0007883a 	mov	r3,zero
81121184:	0021883a 	mov	r16,zero
81121188:	003fd606 	br	811210e4 <__reset+0xfb1010e4>
8112118c:	0121c83a 	sub	r16,zero,r4
81121190:	003fc806 	br	811210b4 <__reset+0xfb1010b4>
81121194:	01002e44 	movi	r4,185
81121198:	20c9c83a 	sub	r4,r4,r3
8112119c:	01400144 	movi	r5,5
811211a0:	8108983a 	sll	r4,r16,r4
811211a4:	288bc83a 	sub	r5,r5,r2
811211a8:	8160d83a 	srl	r16,r16,r5
811211ac:	2008c03a 	cmpne	r4,r4,zero
811211b0:	8120b03a 	or	r16,r16,r4
811211b4:	003fdd06 	br	8112112c <__reset+0xfb10112c>

811211b8 <__floatunsisf>:
811211b8:	defffe04 	addi	sp,sp,-8
811211bc:	de00012e 	bgeu	sp,et,811211c4 <__floatunsisf+0xc>
811211c0:	003b68fa 	trap	3
811211c4:	dfc00115 	stw	ra,4(sp)
811211c8:	dc000015 	stw	r16,0(sp)
811211cc:	20002c26 	beq	r4,zero,81121280 <__floatunsisf+0xc8>
811211d0:	2021883a 	mov	r16,r4
811211d4:	11227d40 	call	811227d4 <__clzsi2>
811211d8:	00c02784 	movi	r3,158
811211dc:	1887c83a 	sub	r3,r3,r2
811211e0:	01002584 	movi	r4,150
811211e4:	20c00f16 	blt	r4,r3,81121224 <__floatunsisf+0x6c>
811211e8:	20c9c83a 	sub	r4,r4,r3
811211ec:	8108983a 	sll	r4,r16,r4
811211f0:	00802034 	movhi	r2,128
811211f4:	10bfffc4 	addi	r2,r2,-1
811211f8:	2088703a 	and	r4,r4,r2
811211fc:	18803fcc 	andi	r2,r3,255
81121200:	100695fa 	slli	r3,r2,23
81121204:	00802034 	movhi	r2,128
81121208:	10bfffc4 	addi	r2,r2,-1
8112120c:	2084703a 	and	r2,r4,r2
81121210:	10c4b03a 	or	r2,r2,r3
81121214:	dfc00117 	ldw	ra,4(sp)
81121218:	dc000017 	ldw	r16,0(sp)
8112121c:	dec00204 	addi	sp,sp,8
81121220:	f800283a 	ret
81121224:	01002644 	movi	r4,153
81121228:	20c01816 	blt	r4,r3,8112128c <__floatunsisf+0xd4>
8112122c:	20c9c83a 	sub	r4,r4,r3
81121230:	8108983a 	sll	r4,r16,r4
81121234:	017f0034 	movhi	r5,64512
81121238:	297fffc4 	addi	r5,r5,-1
8112123c:	218001cc 	andi	r6,r4,7
81121240:	214a703a 	and	r5,r4,r5
81121244:	30000426 	beq	r6,zero,81121258 <__floatunsisf+0xa0>
81121248:	210003cc 	andi	r4,r4,15
8112124c:	01800104 	movi	r6,4
81121250:	21800126 	beq	r4,r6,81121258 <__floatunsisf+0xa0>
81121254:	298b883a 	add	r5,r5,r6
81121258:	2901002c 	andhi	r4,r5,1024
8112125c:	20000526 	beq	r4,zero,81121274 <__floatunsisf+0xbc>
81121260:	00c027c4 	movi	r3,159
81121264:	1887c83a 	sub	r3,r3,r2
81121268:	00bf0034 	movhi	r2,64512
8112126c:	10bfffc4 	addi	r2,r2,-1
81121270:	288a703a 	and	r5,r5,r2
81121274:	280891ba 	slli	r4,r5,6
81121278:	2008d27a 	srli	r4,r4,9
8112127c:	003fdf06 	br	811211fc <__reset+0xfb1011fc>
81121280:	0007883a 	mov	r3,zero
81121284:	0009883a 	mov	r4,zero
81121288:	003fdc06 	br	811211fc <__reset+0xfb1011fc>
8112128c:	01402e44 	movi	r5,185
81121290:	28cbc83a 	sub	r5,r5,r3
81121294:	01000144 	movi	r4,5
81121298:	2089c83a 	sub	r4,r4,r2
8112129c:	814a983a 	sll	r5,r16,r5
811212a0:	8108d83a 	srl	r4,r16,r4
811212a4:	2820c03a 	cmpne	r16,r5,zero
811212a8:	2408b03a 	or	r4,r4,r16
811212ac:	003fe106 	br	81121234 <__reset+0xfb101234>

811212b0 <__gedf2>:
811212b0:	2804d53a 	srli	r2,r5,20
811212b4:	3806d53a 	srli	r3,r7,20
811212b8:	02000434 	movhi	r8,16
811212bc:	423fffc4 	addi	r8,r8,-1
811212c0:	1081ffcc 	andi	r2,r2,2047
811212c4:	0241ffc4 	movi	r9,2047
811212c8:	2a14703a 	and	r10,r5,r8
811212cc:	18c1ffcc 	andi	r3,r3,2047
811212d0:	3a10703a 	and	r8,r7,r8
811212d4:	280ad7fa 	srli	r5,r5,31
811212d8:	380ed7fa 	srli	r7,r7,31
811212dc:	12401d26 	beq	r2,r9,81121354 <__gedf2+0xa4>
811212e0:	0241ffc4 	movi	r9,2047
811212e4:	1a401226 	beq	r3,r9,81121330 <__gedf2+0x80>
811212e8:	1000081e 	bne	r2,zero,8112130c <__gedf2+0x5c>
811212ec:	2296b03a 	or	r11,r4,r10
811212f0:	5813003a 	cmpeq	r9,r11,zero
811212f4:	1800091e 	bne	r3,zero,8112131c <__gedf2+0x6c>
811212f8:	3218b03a 	or	r12,r6,r8
811212fc:	6000071e 	bne	r12,zero,8112131c <__gedf2+0x6c>
81121300:	0005883a 	mov	r2,zero
81121304:	5800101e 	bne	r11,zero,81121348 <__gedf2+0x98>
81121308:	f800283a 	ret
8112130c:	18000c1e 	bne	r3,zero,81121340 <__gedf2+0x90>
81121310:	3212b03a 	or	r9,r6,r8
81121314:	48000c26 	beq	r9,zero,81121348 <__gedf2+0x98>
81121318:	0013883a 	mov	r9,zero
8112131c:	39c03fcc 	andi	r7,r7,255
81121320:	48000826 	beq	r9,zero,81121344 <__gedf2+0x94>
81121324:	38000926 	beq	r7,zero,8112134c <__gedf2+0x9c>
81121328:	00800044 	movi	r2,1
8112132c:	f800283a 	ret
81121330:	3212b03a 	or	r9,r6,r8
81121334:	483fec26 	beq	r9,zero,811212e8 <__reset+0xfb1012e8>
81121338:	00bfff84 	movi	r2,-2
8112133c:	f800283a 	ret
81121340:	39c03fcc 	andi	r7,r7,255
81121344:	29c00626 	beq	r5,r7,81121360 <__gedf2+0xb0>
81121348:	283ff726 	beq	r5,zero,81121328 <__reset+0xfb101328>
8112134c:	00bfffc4 	movi	r2,-1
81121350:	f800283a 	ret
81121354:	2292b03a 	or	r9,r4,r10
81121358:	483fe126 	beq	r9,zero,811212e0 <__reset+0xfb1012e0>
8112135c:	003ff606 	br	81121338 <__reset+0xfb101338>
81121360:	18bff916 	blt	r3,r2,81121348 <__reset+0xfb101348>
81121364:	10c00316 	blt	r2,r3,81121374 <__gedf2+0xc4>
81121368:	42bff736 	bltu	r8,r10,81121348 <__reset+0xfb101348>
8112136c:	52000326 	beq	r10,r8,8112137c <__gedf2+0xcc>
81121370:	5200042e 	bgeu	r10,r8,81121384 <__gedf2+0xd4>
81121374:	283fec1e 	bne	r5,zero,81121328 <__reset+0xfb101328>
81121378:	003ff406 	br	8112134c <__reset+0xfb10134c>
8112137c:	313ff236 	bltu	r6,r4,81121348 <__reset+0xfb101348>
81121380:	21bffc36 	bltu	r4,r6,81121374 <__reset+0xfb101374>
81121384:	0005883a 	mov	r2,zero
81121388:	f800283a 	ret

8112138c <__muldf3>:
8112138c:	defff304 	addi	sp,sp,-52
81121390:	2804d53a 	srli	r2,r5,20
81121394:	de00012e 	bgeu	sp,et,8112139c <__muldf3+0x10>
81121398:	003b68fa 	trap	3
8112139c:	dd800915 	stw	r22,36(sp)
811213a0:	282cd7fa 	srli	r22,r5,31
811213a4:	dc000315 	stw	r16,12(sp)
811213a8:	04000434 	movhi	r16,16
811213ac:	dd400815 	stw	r21,32(sp)
811213b0:	dc800515 	stw	r18,20(sp)
811213b4:	843fffc4 	addi	r16,r16,-1
811213b8:	dfc00c15 	stw	ra,48(sp)
811213bc:	df000b15 	stw	fp,44(sp)
811213c0:	ddc00a15 	stw	r23,40(sp)
811213c4:	dd000715 	stw	r20,28(sp)
811213c8:	dcc00615 	stw	r19,24(sp)
811213cc:	dc400415 	stw	r17,16(sp)
811213d0:	1481ffcc 	andi	r18,r2,2047
811213d4:	2c20703a 	and	r16,r5,r16
811213d8:	b02b883a 	mov	r21,r22
811213dc:	b2403fcc 	andi	r9,r22,255
811213e0:	90006026 	beq	r18,zero,81121564 <__muldf3+0x1d8>
811213e4:	0081ffc4 	movi	r2,2047
811213e8:	2029883a 	mov	r20,r4
811213ec:	90803626 	beq	r18,r2,811214c8 <__muldf3+0x13c>
811213f0:	80800434 	orhi	r2,r16,16
811213f4:	100490fa 	slli	r2,r2,3
811213f8:	2020d77a 	srli	r16,r4,29
811213fc:	202890fa 	slli	r20,r4,3
81121400:	94bf0044 	addi	r18,r18,-1023
81121404:	80a0b03a 	or	r16,r16,r2
81121408:	0027883a 	mov	r19,zero
8112140c:	0039883a 	mov	fp,zero
81121410:	3804d53a 	srli	r2,r7,20
81121414:	382ed7fa 	srli	r23,r7,31
81121418:	04400434 	movhi	r17,16
8112141c:	8c7fffc4 	addi	r17,r17,-1
81121420:	1081ffcc 	andi	r2,r2,2047
81121424:	3011883a 	mov	r8,r6
81121428:	3c62703a 	and	r17,r7,r17
8112142c:	ba803fcc 	andi	r10,r23,255
81121430:	10006d26 	beq	r2,zero,811215e8 <__muldf3+0x25c>
81121434:	00c1ffc4 	movi	r3,2047
81121438:	10c06526 	beq	r2,r3,811215d0 <__muldf3+0x244>
8112143c:	88c00434 	orhi	r3,r17,16
81121440:	180690fa 	slli	r3,r3,3
81121444:	3022d77a 	srli	r17,r6,29
81121448:	301090fa 	slli	r8,r6,3
8112144c:	10bf0044 	addi	r2,r2,-1023
81121450:	88e2b03a 	or	r17,r17,r3
81121454:	000b883a 	mov	r5,zero
81121458:	9085883a 	add	r2,r18,r2
8112145c:	2cc8b03a 	or	r4,r5,r19
81121460:	00c003c4 	movi	r3,15
81121464:	bdacf03a 	xor	r22,r23,r22
81121468:	12c00044 	addi	r11,r2,1
8112146c:	19009936 	bltu	r3,r4,811216d4 <__muldf3+0x348>
81121470:	200890ba 	slli	r4,r4,2
81121474:	00e044b4 	movhi	r3,33042
81121478:	18c52204 	addi	r3,r3,5256
8112147c:	20c9883a 	add	r4,r4,r3
81121480:	20c00017 	ldw	r3,0(r4)
81121484:	1800683a 	jmp	r3
81121488:	811216d4 	ori	r4,r16,18523
8112148c:	811214e8 	cmpgeui	r4,r16,18515
81121490:	811214e8 	cmpgeui	r4,r16,18515
81121494:	811214e4 	muli	r4,r16,18515
81121498:	811216b0 	cmpltui	r4,r16,18522
8112149c:	811216b0 	cmpltui	r4,r16,18522
811214a0:	81121698 	cmpnei	r4,r16,18522
811214a4:	811214e4 	muli	r4,r16,18515
811214a8:	811216b0 	cmpltui	r4,r16,18522
811214ac:	81121698 	cmpnei	r4,r16,18522
811214b0:	811216b0 	cmpltui	r4,r16,18522
811214b4:	811214e4 	muli	r4,r16,18515
811214b8:	811216c0 	call	8811216c <__reset+0x20f216c>
811214bc:	811216c0 	call	8811216c <__reset+0x20f216c>
811214c0:	811216c0 	call	8811216c <__reset+0x20f216c>
811214c4:	811218dc 	xori	r4,r16,18531
811214c8:	2404b03a 	or	r2,r4,r16
811214cc:	10006f1e 	bne	r2,zero,8112168c <__muldf3+0x300>
811214d0:	04c00204 	movi	r19,8
811214d4:	0021883a 	mov	r16,zero
811214d8:	0029883a 	mov	r20,zero
811214dc:	07000084 	movi	fp,2
811214e0:	003fcb06 	br	81121410 <__reset+0xfb101410>
811214e4:	502d883a 	mov	r22,r10
811214e8:	00800084 	movi	r2,2
811214ec:	28805726 	beq	r5,r2,8112164c <__muldf3+0x2c0>
811214f0:	008000c4 	movi	r2,3
811214f4:	28816626 	beq	r5,r2,81121a90 <__muldf3+0x704>
811214f8:	00800044 	movi	r2,1
811214fc:	2881411e 	bne	r5,r2,81121a04 <__muldf3+0x678>
81121500:	b02b883a 	mov	r21,r22
81121504:	0005883a 	mov	r2,zero
81121508:	000b883a 	mov	r5,zero
8112150c:	0029883a 	mov	r20,zero
81121510:	1004953a 	slli	r2,r2,20
81121514:	a8c03fcc 	andi	r3,r21,255
81121518:	04400434 	movhi	r17,16
8112151c:	8c7fffc4 	addi	r17,r17,-1
81121520:	180697fa 	slli	r3,r3,31
81121524:	2c4a703a 	and	r5,r5,r17
81121528:	288ab03a 	or	r5,r5,r2
8112152c:	28c6b03a 	or	r3,r5,r3
81121530:	a005883a 	mov	r2,r20
81121534:	dfc00c17 	ldw	ra,48(sp)
81121538:	df000b17 	ldw	fp,44(sp)
8112153c:	ddc00a17 	ldw	r23,40(sp)
81121540:	dd800917 	ldw	r22,36(sp)
81121544:	dd400817 	ldw	r21,32(sp)
81121548:	dd000717 	ldw	r20,28(sp)
8112154c:	dcc00617 	ldw	r19,24(sp)
81121550:	dc800517 	ldw	r18,20(sp)
81121554:	dc400417 	ldw	r17,16(sp)
81121558:	dc000317 	ldw	r16,12(sp)
8112155c:	dec00d04 	addi	sp,sp,52
81121560:	f800283a 	ret
81121564:	2404b03a 	or	r2,r4,r16
81121568:	2027883a 	mov	r19,r4
8112156c:	10004226 	beq	r2,zero,81121678 <__muldf3+0x2ec>
81121570:	8000fc26 	beq	r16,zero,81121964 <__muldf3+0x5d8>
81121574:	8009883a 	mov	r4,r16
81121578:	d9800215 	stw	r6,8(sp)
8112157c:	d9c00015 	stw	r7,0(sp)
81121580:	da400115 	stw	r9,4(sp)
81121584:	11227d40 	call	811227d4 <__clzsi2>
81121588:	d9800217 	ldw	r6,8(sp)
8112158c:	d9c00017 	ldw	r7,0(sp)
81121590:	da400117 	ldw	r9,4(sp)
81121594:	113ffd44 	addi	r4,r2,-11
81121598:	00c00704 	movi	r3,28
8112159c:	1900ed16 	blt	r3,r4,81121954 <__muldf3+0x5c8>
811215a0:	00c00744 	movi	r3,29
811215a4:	147ffe04 	addi	r17,r2,-8
811215a8:	1907c83a 	sub	r3,r3,r4
811215ac:	8460983a 	sll	r16,r16,r17
811215b0:	98c6d83a 	srl	r3,r19,r3
811215b4:	9c68983a 	sll	r20,r19,r17
811215b8:	1c20b03a 	or	r16,r3,r16
811215bc:	1080fcc4 	addi	r2,r2,1011
811215c0:	00a5c83a 	sub	r18,zero,r2
811215c4:	0027883a 	mov	r19,zero
811215c8:	0039883a 	mov	fp,zero
811215cc:	003f9006 	br	81121410 <__reset+0xfb101410>
811215d0:	3446b03a 	or	r3,r6,r17
811215d4:	1800261e 	bne	r3,zero,81121670 <__muldf3+0x2e4>
811215d8:	0023883a 	mov	r17,zero
811215dc:	0011883a 	mov	r8,zero
811215e0:	01400084 	movi	r5,2
811215e4:	003f9c06 	br	81121458 <__reset+0xfb101458>
811215e8:	3446b03a 	or	r3,r6,r17
811215ec:	18001c26 	beq	r3,zero,81121660 <__muldf3+0x2d4>
811215f0:	8800ce26 	beq	r17,zero,8112192c <__muldf3+0x5a0>
811215f4:	8809883a 	mov	r4,r17
811215f8:	d9800215 	stw	r6,8(sp)
811215fc:	da400115 	stw	r9,4(sp)
81121600:	da800015 	stw	r10,0(sp)
81121604:	11227d40 	call	811227d4 <__clzsi2>
81121608:	d9800217 	ldw	r6,8(sp)
8112160c:	da400117 	ldw	r9,4(sp)
81121610:	da800017 	ldw	r10,0(sp)
81121614:	113ffd44 	addi	r4,r2,-11
81121618:	00c00704 	movi	r3,28
8112161c:	1900bf16 	blt	r3,r4,8112191c <__muldf3+0x590>
81121620:	00c00744 	movi	r3,29
81121624:	123ffe04 	addi	r8,r2,-8
81121628:	1907c83a 	sub	r3,r3,r4
8112162c:	8a22983a 	sll	r17,r17,r8
81121630:	30c6d83a 	srl	r3,r6,r3
81121634:	3210983a 	sll	r8,r6,r8
81121638:	1c62b03a 	or	r17,r3,r17
8112163c:	1080fcc4 	addi	r2,r2,1011
81121640:	0085c83a 	sub	r2,zero,r2
81121644:	000b883a 	mov	r5,zero
81121648:	003f8306 	br	81121458 <__reset+0xfb101458>
8112164c:	b02b883a 	mov	r21,r22
81121650:	0081ffc4 	movi	r2,2047
81121654:	000b883a 	mov	r5,zero
81121658:	0029883a 	mov	r20,zero
8112165c:	003fac06 	br	81121510 <__reset+0xfb101510>
81121660:	0023883a 	mov	r17,zero
81121664:	0011883a 	mov	r8,zero
81121668:	01400044 	movi	r5,1
8112166c:	003f7a06 	br	81121458 <__reset+0xfb101458>
81121670:	014000c4 	movi	r5,3
81121674:	003f7806 	br	81121458 <__reset+0xfb101458>
81121678:	04c00104 	movi	r19,4
8112167c:	0021883a 	mov	r16,zero
81121680:	0029883a 	mov	r20,zero
81121684:	07000044 	movi	fp,1
81121688:	003f6106 	br	81121410 <__reset+0xfb101410>
8112168c:	04c00304 	movi	r19,12
81121690:	070000c4 	movi	fp,3
81121694:	003f5e06 	br	81121410 <__reset+0xfb101410>
81121698:	01400434 	movhi	r5,16
8112169c:	002b883a 	mov	r21,zero
811216a0:	297fffc4 	addi	r5,r5,-1
811216a4:	053fffc4 	movi	r20,-1
811216a8:	0081ffc4 	movi	r2,2047
811216ac:	003f9806 	br	81121510 <__reset+0xfb101510>
811216b0:	8023883a 	mov	r17,r16
811216b4:	a011883a 	mov	r8,r20
811216b8:	e00b883a 	mov	r5,fp
811216bc:	003f8a06 	br	811214e8 <__reset+0xfb1014e8>
811216c0:	8023883a 	mov	r17,r16
811216c4:	a011883a 	mov	r8,r20
811216c8:	482d883a 	mov	r22,r9
811216cc:	e00b883a 	mov	r5,fp
811216d0:	003f8506 	br	811214e8 <__reset+0xfb1014e8>
811216d4:	a00ad43a 	srli	r5,r20,16
811216d8:	401ad43a 	srli	r13,r8,16
811216dc:	a53fffcc 	andi	r20,r20,65535
811216e0:	423fffcc 	andi	r8,r8,65535
811216e4:	4519383a 	mul	r12,r8,r20
811216e8:	4147383a 	mul	r3,r8,r5
811216ec:	6d09383a 	mul	r4,r13,r20
811216f0:	600cd43a 	srli	r6,r12,16
811216f4:	2b5d383a 	mul	r14,r5,r13
811216f8:	20c9883a 	add	r4,r4,r3
811216fc:	310d883a 	add	r6,r6,r4
81121700:	30c0022e 	bgeu	r6,r3,8112170c <__muldf3+0x380>
81121704:	00c00074 	movhi	r3,1
81121708:	70dd883a 	add	r14,r14,r3
8112170c:	8826d43a 	srli	r19,r17,16
81121710:	8bffffcc 	andi	r15,r17,65535
81121714:	7d23383a 	mul	r17,r15,r20
81121718:	7949383a 	mul	r4,r15,r5
8112171c:	9d29383a 	mul	r20,r19,r20
81121720:	8814d43a 	srli	r10,r17,16
81121724:	3012943a 	slli	r9,r6,16
81121728:	a129883a 	add	r20,r20,r4
8112172c:	633fffcc 	andi	r12,r12,65535
81121730:	5515883a 	add	r10,r10,r20
81121734:	3006d43a 	srli	r3,r6,16
81121738:	4b13883a 	add	r9,r9,r12
8112173c:	2ccb383a 	mul	r5,r5,r19
81121740:	5100022e 	bgeu	r10,r4,8112174c <__muldf3+0x3c0>
81121744:	01000074 	movhi	r4,1
81121748:	290b883a 	add	r5,r5,r4
8112174c:	802ad43a 	srli	r21,r16,16
81121750:	843fffcc 	andi	r16,r16,65535
81121754:	440d383a 	mul	r6,r8,r16
81121758:	4565383a 	mul	r18,r8,r21
8112175c:	8349383a 	mul	r4,r16,r13
81121760:	500e943a 	slli	r7,r10,16
81121764:	3010d43a 	srli	r8,r6,16
81121768:	5028d43a 	srli	r20,r10,16
8112176c:	2489883a 	add	r4,r4,r18
81121770:	8abfffcc 	andi	r10,r17,65535
81121774:	3a95883a 	add	r10,r7,r10
81121778:	4119883a 	add	r12,r8,r4
8112177c:	a169883a 	add	r20,r20,r5
81121780:	1a87883a 	add	r3,r3,r10
81121784:	6d5b383a 	mul	r13,r13,r21
81121788:	6480022e 	bgeu	r12,r18,81121794 <__muldf3+0x408>
8112178c:	01000074 	movhi	r4,1
81121790:	691b883a 	add	r13,r13,r4
81121794:	7c25383a 	mul	r18,r15,r16
81121798:	7d4b383a 	mul	r5,r15,r21
8112179c:	84cf383a 	mul	r7,r16,r19
811217a0:	901ed43a 	srli	r15,r18,16
811217a4:	6008d43a 	srli	r4,r12,16
811217a8:	6010943a 	slli	r8,r12,16
811217ac:	394f883a 	add	r7,r7,r5
811217b0:	333fffcc 	andi	r12,r6,65535
811217b4:	79df883a 	add	r15,r15,r7
811217b8:	235b883a 	add	r13,r4,r13
811217bc:	9d63383a 	mul	r17,r19,r21
811217c0:	4309883a 	add	r4,r8,r12
811217c4:	7940022e 	bgeu	r15,r5,811217d0 <__muldf3+0x444>
811217c8:	01400074 	movhi	r5,1
811217cc:	8963883a 	add	r17,r17,r5
811217d0:	780a943a 	slli	r5,r15,16
811217d4:	91bfffcc 	andi	r6,r18,65535
811217d8:	70c7883a 	add	r3,r14,r3
811217dc:	298d883a 	add	r6,r5,r6
811217e0:	1a8f803a 	cmpltu	r7,r3,r10
811217e4:	350b883a 	add	r5,r6,r20
811217e8:	20c7883a 	add	r3,r4,r3
811217ec:	3955883a 	add	r10,r7,r5
811217f0:	1909803a 	cmpltu	r4,r3,r4
811217f4:	6a91883a 	add	r8,r13,r10
811217f8:	780cd43a 	srli	r6,r15,16
811217fc:	2219883a 	add	r12,r4,r8
81121800:	2d0b803a 	cmpltu	r5,r5,r20
81121804:	51cf803a 	cmpltu	r7,r10,r7
81121808:	29ceb03a 	or	r7,r5,r7
8112180c:	4351803a 	cmpltu	r8,r8,r13
81121810:	610b803a 	cmpltu	r5,r12,r4
81121814:	4148b03a 	or	r4,r8,r5
81121818:	398f883a 	add	r7,r7,r6
8112181c:	3909883a 	add	r4,r7,r4
81121820:	1810927a 	slli	r8,r3,9
81121824:	2449883a 	add	r4,r4,r17
81121828:	2008927a 	slli	r4,r4,9
8112182c:	6022d5fa 	srli	r17,r12,23
81121830:	1806d5fa 	srli	r3,r3,23
81121834:	4252b03a 	or	r9,r8,r9
81121838:	600a927a 	slli	r5,r12,9
8112183c:	4810c03a 	cmpne	r8,r9,zero
81121840:	2462b03a 	or	r17,r4,r17
81121844:	40c6b03a 	or	r3,r8,r3
81121848:	8900402c 	andhi	r4,r17,256
8112184c:	1950b03a 	or	r8,r3,r5
81121850:	20000726 	beq	r4,zero,81121870 <__muldf3+0x4e4>
81121854:	4006d07a 	srli	r3,r8,1
81121858:	880497fa 	slli	r2,r17,31
8112185c:	4200004c 	andi	r8,r8,1
81121860:	8822d07a 	srli	r17,r17,1
81121864:	1a10b03a 	or	r8,r3,r8
81121868:	1210b03a 	or	r8,r2,r8
8112186c:	5805883a 	mov	r2,r11
81121870:	1140ffc4 	addi	r5,r2,1023
81121874:	0140440e 	bge	zero,r5,81121988 <__muldf3+0x5fc>
81121878:	40c001cc 	andi	r3,r8,7
8112187c:	18000726 	beq	r3,zero,8112189c <__muldf3+0x510>
81121880:	40c003cc 	andi	r3,r8,15
81121884:	01000104 	movi	r4,4
81121888:	19000426 	beq	r3,r4,8112189c <__muldf3+0x510>
8112188c:	4107883a 	add	r3,r8,r4
81121890:	1a11803a 	cmpltu	r8,r3,r8
81121894:	8a23883a 	add	r17,r17,r8
81121898:	1811883a 	mov	r8,r3
8112189c:	88c0402c 	andhi	r3,r17,256
811218a0:	18000426 	beq	r3,zero,811218b4 <__muldf3+0x528>
811218a4:	11410004 	addi	r5,r2,1024
811218a8:	00bfc034 	movhi	r2,65280
811218ac:	10bfffc4 	addi	r2,r2,-1
811218b0:	88a2703a 	and	r17,r17,r2
811218b4:	0081ff84 	movi	r2,2046
811218b8:	117f6416 	blt	r2,r5,8112164c <__reset+0xfb10164c>
811218bc:	8828977a 	slli	r20,r17,29
811218c0:	4010d0fa 	srli	r8,r8,3
811218c4:	8822927a 	slli	r17,r17,9
811218c8:	2881ffcc 	andi	r2,r5,2047
811218cc:	a228b03a 	or	r20,r20,r8
811218d0:	880ad33a 	srli	r5,r17,12
811218d4:	b02b883a 	mov	r21,r22
811218d8:	003f0d06 	br	81121510 <__reset+0xfb101510>
811218dc:	8080022c 	andhi	r2,r16,8
811218e0:	10000926 	beq	r2,zero,81121908 <__muldf3+0x57c>
811218e4:	8880022c 	andhi	r2,r17,8
811218e8:	1000071e 	bne	r2,zero,81121908 <__muldf3+0x57c>
811218ec:	00800434 	movhi	r2,16
811218f0:	89400234 	orhi	r5,r17,8
811218f4:	10bfffc4 	addi	r2,r2,-1
811218f8:	b82b883a 	mov	r21,r23
811218fc:	288a703a 	and	r5,r5,r2
81121900:	4029883a 	mov	r20,r8
81121904:	003f6806 	br	811216a8 <__reset+0xfb1016a8>
81121908:	00800434 	movhi	r2,16
8112190c:	81400234 	orhi	r5,r16,8
81121910:	10bfffc4 	addi	r2,r2,-1
81121914:	288a703a 	and	r5,r5,r2
81121918:	003f6306 	br	811216a8 <__reset+0xfb1016a8>
8112191c:	147ff604 	addi	r17,r2,-40
81121920:	3462983a 	sll	r17,r6,r17
81121924:	0011883a 	mov	r8,zero
81121928:	003f4406 	br	8112163c <__reset+0xfb10163c>
8112192c:	3009883a 	mov	r4,r6
81121930:	d9800215 	stw	r6,8(sp)
81121934:	da400115 	stw	r9,4(sp)
81121938:	da800015 	stw	r10,0(sp)
8112193c:	11227d40 	call	811227d4 <__clzsi2>
81121940:	10800804 	addi	r2,r2,32
81121944:	da800017 	ldw	r10,0(sp)
81121948:	da400117 	ldw	r9,4(sp)
8112194c:	d9800217 	ldw	r6,8(sp)
81121950:	003f3006 	br	81121614 <__reset+0xfb101614>
81121954:	143ff604 	addi	r16,r2,-40
81121958:	9c20983a 	sll	r16,r19,r16
8112195c:	0029883a 	mov	r20,zero
81121960:	003f1606 	br	811215bc <__reset+0xfb1015bc>
81121964:	d9800215 	stw	r6,8(sp)
81121968:	d9c00015 	stw	r7,0(sp)
8112196c:	da400115 	stw	r9,4(sp)
81121970:	11227d40 	call	811227d4 <__clzsi2>
81121974:	10800804 	addi	r2,r2,32
81121978:	da400117 	ldw	r9,4(sp)
8112197c:	d9c00017 	ldw	r7,0(sp)
81121980:	d9800217 	ldw	r6,8(sp)
81121984:	003f0306 	br	81121594 <__reset+0xfb101594>
81121988:	00c00044 	movi	r3,1
8112198c:	1947c83a 	sub	r3,r3,r5
81121990:	00800e04 	movi	r2,56
81121994:	10feda16 	blt	r2,r3,81121500 <__reset+0xfb101500>
81121998:	008007c4 	movi	r2,31
8112199c:	10c01b16 	blt	r2,r3,81121a0c <__muldf3+0x680>
811219a0:	00800804 	movi	r2,32
811219a4:	10c5c83a 	sub	r2,r2,r3
811219a8:	888a983a 	sll	r5,r17,r2
811219ac:	40c8d83a 	srl	r4,r8,r3
811219b0:	4084983a 	sll	r2,r8,r2
811219b4:	88e2d83a 	srl	r17,r17,r3
811219b8:	2906b03a 	or	r3,r5,r4
811219bc:	1004c03a 	cmpne	r2,r2,zero
811219c0:	1886b03a 	or	r3,r3,r2
811219c4:	188001cc 	andi	r2,r3,7
811219c8:	10000726 	beq	r2,zero,811219e8 <__muldf3+0x65c>
811219cc:	188003cc 	andi	r2,r3,15
811219d0:	01000104 	movi	r4,4
811219d4:	11000426 	beq	r2,r4,811219e8 <__muldf3+0x65c>
811219d8:	1805883a 	mov	r2,r3
811219dc:	10c00104 	addi	r3,r2,4
811219e0:	1885803a 	cmpltu	r2,r3,r2
811219e4:	88a3883a 	add	r17,r17,r2
811219e8:	8880202c 	andhi	r2,r17,128
811219ec:	10001c26 	beq	r2,zero,81121a60 <__muldf3+0x6d4>
811219f0:	b02b883a 	mov	r21,r22
811219f4:	00800044 	movi	r2,1
811219f8:	000b883a 	mov	r5,zero
811219fc:	0029883a 	mov	r20,zero
81121a00:	003ec306 	br	81121510 <__reset+0xfb101510>
81121a04:	5805883a 	mov	r2,r11
81121a08:	003f9906 	br	81121870 <__reset+0xfb101870>
81121a0c:	00bff844 	movi	r2,-31
81121a10:	1145c83a 	sub	r2,r2,r5
81121a14:	8888d83a 	srl	r4,r17,r2
81121a18:	00800804 	movi	r2,32
81121a1c:	18801a26 	beq	r3,r2,81121a88 <__muldf3+0x6fc>
81121a20:	00801004 	movi	r2,64
81121a24:	10c5c83a 	sub	r2,r2,r3
81121a28:	8884983a 	sll	r2,r17,r2
81121a2c:	1204b03a 	or	r2,r2,r8
81121a30:	1004c03a 	cmpne	r2,r2,zero
81121a34:	2084b03a 	or	r2,r4,r2
81121a38:	144001cc 	andi	r17,r2,7
81121a3c:	88000d1e 	bne	r17,zero,81121a74 <__muldf3+0x6e8>
81121a40:	000b883a 	mov	r5,zero
81121a44:	1028d0fa 	srli	r20,r2,3
81121a48:	b02b883a 	mov	r21,r22
81121a4c:	0005883a 	mov	r2,zero
81121a50:	a468b03a 	or	r20,r20,r17
81121a54:	003eae06 	br	81121510 <__reset+0xfb101510>
81121a58:	1007883a 	mov	r3,r2
81121a5c:	0023883a 	mov	r17,zero
81121a60:	880a927a 	slli	r5,r17,9
81121a64:	1805883a 	mov	r2,r3
81121a68:	8822977a 	slli	r17,r17,29
81121a6c:	280ad33a 	srli	r5,r5,12
81121a70:	003ff406 	br	81121a44 <__reset+0xfb101a44>
81121a74:	10c003cc 	andi	r3,r2,15
81121a78:	01000104 	movi	r4,4
81121a7c:	193ff626 	beq	r3,r4,81121a58 <__reset+0xfb101a58>
81121a80:	0023883a 	mov	r17,zero
81121a84:	003fd506 	br	811219dc <__reset+0xfb1019dc>
81121a88:	0005883a 	mov	r2,zero
81121a8c:	003fe706 	br	81121a2c <__reset+0xfb101a2c>
81121a90:	00800434 	movhi	r2,16
81121a94:	89400234 	orhi	r5,r17,8
81121a98:	10bfffc4 	addi	r2,r2,-1
81121a9c:	b02b883a 	mov	r21,r22
81121aa0:	288a703a 	and	r5,r5,r2
81121aa4:	4029883a 	mov	r20,r8
81121aa8:	003eff06 	br	811216a8 <__reset+0xfb1016a8>

81121aac <__subdf3>:
81121aac:	02000434 	movhi	r8,16
81121ab0:	423fffc4 	addi	r8,r8,-1
81121ab4:	defffb04 	addi	sp,sp,-20
81121ab8:	2a14703a 	and	r10,r5,r8
81121abc:	3812d53a 	srli	r9,r7,20
81121ac0:	3a10703a 	and	r8,r7,r8
81121ac4:	de00012e 	bgeu	sp,et,81121acc <__subdf3+0x20>
81121ac8:	003b68fa 	trap	3
81121acc:	2006d77a 	srli	r3,r4,29
81121ad0:	3004d77a 	srli	r2,r6,29
81121ad4:	dc000015 	stw	r16,0(sp)
81121ad8:	501490fa 	slli	r10,r10,3
81121adc:	2820d53a 	srli	r16,r5,20
81121ae0:	401090fa 	slli	r8,r8,3
81121ae4:	dc800215 	stw	r18,8(sp)
81121ae8:	dc400115 	stw	r17,4(sp)
81121aec:	dfc00415 	stw	ra,16(sp)
81121af0:	202290fa 	slli	r17,r4,3
81121af4:	dcc00315 	stw	r19,12(sp)
81121af8:	4a41ffcc 	andi	r9,r9,2047
81121afc:	0101ffc4 	movi	r4,2047
81121b00:	2824d7fa 	srli	r18,r5,31
81121b04:	8401ffcc 	andi	r16,r16,2047
81121b08:	50c6b03a 	or	r3,r10,r3
81121b0c:	380ed7fa 	srli	r7,r7,31
81121b10:	408ab03a 	or	r5,r8,r2
81121b14:	300c90fa 	slli	r6,r6,3
81121b18:	49009626 	beq	r9,r4,81121d74 <__subdf3+0x2c8>
81121b1c:	39c0005c 	xori	r7,r7,1
81121b20:	8245c83a 	sub	r2,r16,r9
81121b24:	3c807426 	beq	r7,r18,81121cf8 <__subdf3+0x24c>
81121b28:	0080af0e 	bge	zero,r2,81121de8 <__subdf3+0x33c>
81121b2c:	48002a1e 	bne	r9,zero,81121bd8 <__subdf3+0x12c>
81121b30:	2988b03a 	or	r4,r5,r6
81121b34:	20009a1e 	bne	r4,zero,81121da0 <__subdf3+0x2f4>
81121b38:	888001cc 	andi	r2,r17,7
81121b3c:	10000726 	beq	r2,zero,81121b5c <__subdf3+0xb0>
81121b40:	888003cc 	andi	r2,r17,15
81121b44:	01000104 	movi	r4,4
81121b48:	11000426 	beq	r2,r4,81121b5c <__subdf3+0xb0>
81121b4c:	890b883a 	add	r5,r17,r4
81121b50:	2c63803a 	cmpltu	r17,r5,r17
81121b54:	1c47883a 	add	r3,r3,r17
81121b58:	2823883a 	mov	r17,r5
81121b5c:	1880202c 	andhi	r2,r3,128
81121b60:	10005926 	beq	r2,zero,81121cc8 <__subdf3+0x21c>
81121b64:	84000044 	addi	r16,r16,1
81121b68:	0081ffc4 	movi	r2,2047
81121b6c:	8080be26 	beq	r16,r2,81121e68 <__subdf3+0x3bc>
81121b70:	017fe034 	movhi	r5,65408
81121b74:	297fffc4 	addi	r5,r5,-1
81121b78:	1946703a 	and	r3,r3,r5
81121b7c:	1804977a 	slli	r2,r3,29
81121b80:	1806927a 	slli	r3,r3,9
81121b84:	8822d0fa 	srli	r17,r17,3
81121b88:	8401ffcc 	andi	r16,r16,2047
81121b8c:	180ad33a 	srli	r5,r3,12
81121b90:	9100004c 	andi	r4,r18,1
81121b94:	1444b03a 	or	r2,r2,r17
81121b98:	80c1ffcc 	andi	r3,r16,2047
81121b9c:	1820953a 	slli	r16,r3,20
81121ba0:	20c03fcc 	andi	r3,r4,255
81121ba4:	180897fa 	slli	r4,r3,31
81121ba8:	00c00434 	movhi	r3,16
81121bac:	18ffffc4 	addi	r3,r3,-1
81121bb0:	28c6703a 	and	r3,r5,r3
81121bb4:	1c06b03a 	or	r3,r3,r16
81121bb8:	1906b03a 	or	r3,r3,r4
81121bbc:	dfc00417 	ldw	ra,16(sp)
81121bc0:	dcc00317 	ldw	r19,12(sp)
81121bc4:	dc800217 	ldw	r18,8(sp)
81121bc8:	dc400117 	ldw	r17,4(sp)
81121bcc:	dc000017 	ldw	r16,0(sp)
81121bd0:	dec00504 	addi	sp,sp,20
81121bd4:	f800283a 	ret
81121bd8:	0101ffc4 	movi	r4,2047
81121bdc:	813fd626 	beq	r16,r4,81121b38 <__reset+0xfb101b38>
81121be0:	29402034 	orhi	r5,r5,128
81121be4:	01000e04 	movi	r4,56
81121be8:	2080a316 	blt	r4,r2,81121e78 <__subdf3+0x3cc>
81121bec:	010007c4 	movi	r4,31
81121bf0:	2080c616 	blt	r4,r2,81121f0c <__subdf3+0x460>
81121bf4:	01000804 	movi	r4,32
81121bf8:	2089c83a 	sub	r4,r4,r2
81121bfc:	2910983a 	sll	r8,r5,r4
81121c00:	308ed83a 	srl	r7,r6,r2
81121c04:	3108983a 	sll	r4,r6,r4
81121c08:	2884d83a 	srl	r2,r5,r2
81121c0c:	41ccb03a 	or	r6,r8,r7
81121c10:	2008c03a 	cmpne	r4,r4,zero
81121c14:	310cb03a 	or	r6,r6,r4
81121c18:	898dc83a 	sub	r6,r17,r6
81121c1c:	89a3803a 	cmpltu	r17,r17,r6
81121c20:	1887c83a 	sub	r3,r3,r2
81121c24:	1c47c83a 	sub	r3,r3,r17
81121c28:	3023883a 	mov	r17,r6
81121c2c:	1880202c 	andhi	r2,r3,128
81121c30:	10002326 	beq	r2,zero,81121cc0 <__subdf3+0x214>
81121c34:	04c02034 	movhi	r19,128
81121c38:	9cffffc4 	addi	r19,r19,-1
81121c3c:	1ce6703a 	and	r19,r3,r19
81121c40:	98007a26 	beq	r19,zero,81121e2c <__subdf3+0x380>
81121c44:	9809883a 	mov	r4,r19
81121c48:	11227d40 	call	811227d4 <__clzsi2>
81121c4c:	113ffe04 	addi	r4,r2,-8
81121c50:	00c007c4 	movi	r3,31
81121c54:	19007b16 	blt	r3,r4,81121e44 <__subdf3+0x398>
81121c58:	00800804 	movi	r2,32
81121c5c:	1105c83a 	sub	r2,r2,r4
81121c60:	8884d83a 	srl	r2,r17,r2
81121c64:	9906983a 	sll	r3,r19,r4
81121c68:	8922983a 	sll	r17,r17,r4
81121c6c:	10c4b03a 	or	r2,r2,r3
81121c70:	24007816 	blt	r4,r16,81121e54 <__subdf3+0x3a8>
81121c74:	2421c83a 	sub	r16,r4,r16
81121c78:	80c00044 	addi	r3,r16,1
81121c7c:	010007c4 	movi	r4,31
81121c80:	20c09516 	blt	r4,r3,81121ed8 <__subdf3+0x42c>
81121c84:	01400804 	movi	r5,32
81121c88:	28cbc83a 	sub	r5,r5,r3
81121c8c:	88c8d83a 	srl	r4,r17,r3
81121c90:	8962983a 	sll	r17,r17,r5
81121c94:	114a983a 	sll	r5,r2,r5
81121c98:	10c6d83a 	srl	r3,r2,r3
81121c9c:	8804c03a 	cmpne	r2,r17,zero
81121ca0:	290ab03a 	or	r5,r5,r4
81121ca4:	28a2b03a 	or	r17,r5,r2
81121ca8:	0021883a 	mov	r16,zero
81121cac:	003fa206 	br	81121b38 <__reset+0xfb101b38>
81121cb0:	2090b03a 	or	r8,r4,r2
81121cb4:	40018e26 	beq	r8,zero,811222f0 <__subdf3+0x844>
81121cb8:	1007883a 	mov	r3,r2
81121cbc:	2023883a 	mov	r17,r4
81121cc0:	888001cc 	andi	r2,r17,7
81121cc4:	103f9e1e 	bne	r2,zero,81121b40 <__reset+0xfb101b40>
81121cc8:	1804977a 	slli	r2,r3,29
81121ccc:	8822d0fa 	srli	r17,r17,3
81121cd0:	1810d0fa 	srli	r8,r3,3
81121cd4:	9100004c 	andi	r4,r18,1
81121cd8:	1444b03a 	or	r2,r2,r17
81121cdc:	00c1ffc4 	movi	r3,2047
81121ce0:	80c02826 	beq	r16,r3,81121d84 <__subdf3+0x2d8>
81121ce4:	01400434 	movhi	r5,16
81121ce8:	297fffc4 	addi	r5,r5,-1
81121cec:	80e0703a 	and	r16,r16,r3
81121cf0:	414a703a 	and	r5,r8,r5
81121cf4:	003fa806 	br	81121b98 <__reset+0xfb101b98>
81121cf8:	0080630e 	bge	zero,r2,81121e88 <__subdf3+0x3dc>
81121cfc:	48003026 	beq	r9,zero,81121dc0 <__subdf3+0x314>
81121d00:	0101ffc4 	movi	r4,2047
81121d04:	813f8c26 	beq	r16,r4,81121b38 <__reset+0xfb101b38>
81121d08:	29402034 	orhi	r5,r5,128
81121d0c:	01000e04 	movi	r4,56
81121d10:	2080a90e 	bge	r4,r2,81121fb8 <__subdf3+0x50c>
81121d14:	298cb03a 	or	r6,r5,r6
81121d18:	3012c03a 	cmpne	r9,r6,zero
81121d1c:	0005883a 	mov	r2,zero
81121d20:	4c53883a 	add	r9,r9,r17
81121d24:	4c63803a 	cmpltu	r17,r9,r17
81121d28:	10c7883a 	add	r3,r2,r3
81121d2c:	88c7883a 	add	r3,r17,r3
81121d30:	4823883a 	mov	r17,r9
81121d34:	1880202c 	andhi	r2,r3,128
81121d38:	1000d026 	beq	r2,zero,8112207c <__subdf3+0x5d0>
81121d3c:	84000044 	addi	r16,r16,1
81121d40:	0081ffc4 	movi	r2,2047
81121d44:	8080fe26 	beq	r16,r2,81122140 <__subdf3+0x694>
81121d48:	00bfe034 	movhi	r2,65408
81121d4c:	10bfffc4 	addi	r2,r2,-1
81121d50:	1886703a 	and	r3,r3,r2
81121d54:	880ad07a 	srli	r5,r17,1
81121d58:	180497fa 	slli	r2,r3,31
81121d5c:	8900004c 	andi	r4,r17,1
81121d60:	2922b03a 	or	r17,r5,r4
81121d64:	1806d07a 	srli	r3,r3,1
81121d68:	1462b03a 	or	r17,r2,r17
81121d6c:	3825883a 	mov	r18,r7
81121d70:	003f7106 	br	81121b38 <__reset+0xfb101b38>
81121d74:	2984b03a 	or	r2,r5,r6
81121d78:	103f6826 	beq	r2,zero,81121b1c <__reset+0xfb101b1c>
81121d7c:	39c03fcc 	andi	r7,r7,255
81121d80:	003f6706 	br	81121b20 <__reset+0xfb101b20>
81121d84:	4086b03a 	or	r3,r8,r2
81121d88:	18015226 	beq	r3,zero,811222d4 <__subdf3+0x828>
81121d8c:	00c00434 	movhi	r3,16
81121d90:	41400234 	orhi	r5,r8,8
81121d94:	18ffffc4 	addi	r3,r3,-1
81121d98:	28ca703a 	and	r5,r5,r3
81121d9c:	003f7e06 	br	81121b98 <__reset+0xfb101b98>
81121da0:	10bfffc4 	addi	r2,r2,-1
81121da4:	1000491e 	bne	r2,zero,81121ecc <__subdf3+0x420>
81121da8:	898fc83a 	sub	r7,r17,r6
81121dac:	89e3803a 	cmpltu	r17,r17,r7
81121db0:	1947c83a 	sub	r3,r3,r5
81121db4:	1c47c83a 	sub	r3,r3,r17
81121db8:	3823883a 	mov	r17,r7
81121dbc:	003f9b06 	br	81121c2c <__reset+0xfb101c2c>
81121dc0:	2988b03a 	or	r4,r5,r6
81121dc4:	203f5c26 	beq	r4,zero,81121b38 <__reset+0xfb101b38>
81121dc8:	10bfffc4 	addi	r2,r2,-1
81121dcc:	1000931e 	bne	r2,zero,8112201c <__subdf3+0x570>
81121dd0:	898d883a 	add	r6,r17,r6
81121dd4:	3463803a 	cmpltu	r17,r6,r17
81121dd8:	1947883a 	add	r3,r3,r5
81121ddc:	88c7883a 	add	r3,r17,r3
81121de0:	3023883a 	mov	r17,r6
81121de4:	003fd306 	br	81121d34 <__reset+0xfb101d34>
81121de8:	1000541e 	bne	r2,zero,81121f3c <__subdf3+0x490>
81121dec:	80800044 	addi	r2,r16,1
81121df0:	1081ffcc 	andi	r2,r2,2047
81121df4:	01000044 	movi	r4,1
81121df8:	2080a20e 	bge	r4,r2,81122084 <__subdf3+0x5d8>
81121dfc:	8989c83a 	sub	r4,r17,r6
81121e00:	8905803a 	cmpltu	r2,r17,r4
81121e04:	1967c83a 	sub	r19,r3,r5
81121e08:	98a7c83a 	sub	r19,r19,r2
81121e0c:	9880202c 	andhi	r2,r19,128
81121e10:	10006326 	beq	r2,zero,81121fa0 <__subdf3+0x4f4>
81121e14:	3463c83a 	sub	r17,r6,r17
81121e18:	28c7c83a 	sub	r3,r5,r3
81121e1c:	344d803a 	cmpltu	r6,r6,r17
81121e20:	19a7c83a 	sub	r19,r3,r6
81121e24:	3825883a 	mov	r18,r7
81121e28:	983f861e 	bne	r19,zero,81121c44 <__reset+0xfb101c44>
81121e2c:	8809883a 	mov	r4,r17
81121e30:	11227d40 	call	811227d4 <__clzsi2>
81121e34:	10800804 	addi	r2,r2,32
81121e38:	113ffe04 	addi	r4,r2,-8
81121e3c:	00c007c4 	movi	r3,31
81121e40:	193f850e 	bge	r3,r4,81121c58 <__reset+0xfb101c58>
81121e44:	10bff604 	addi	r2,r2,-40
81121e48:	8884983a 	sll	r2,r17,r2
81121e4c:	0023883a 	mov	r17,zero
81121e50:	243f880e 	bge	r4,r16,81121c74 <__reset+0xfb101c74>
81121e54:	00ffe034 	movhi	r3,65408
81121e58:	18ffffc4 	addi	r3,r3,-1
81121e5c:	8121c83a 	sub	r16,r16,r4
81121e60:	10c6703a 	and	r3,r2,r3
81121e64:	003f3406 	br	81121b38 <__reset+0xfb101b38>
81121e68:	9100004c 	andi	r4,r18,1
81121e6c:	000b883a 	mov	r5,zero
81121e70:	0005883a 	mov	r2,zero
81121e74:	003f4806 	br	81121b98 <__reset+0xfb101b98>
81121e78:	298cb03a 	or	r6,r5,r6
81121e7c:	300cc03a 	cmpne	r6,r6,zero
81121e80:	0005883a 	mov	r2,zero
81121e84:	003f6406 	br	81121c18 <__reset+0xfb101c18>
81121e88:	10009a1e 	bne	r2,zero,811220f4 <__subdf3+0x648>
81121e8c:	82400044 	addi	r9,r16,1
81121e90:	4881ffcc 	andi	r2,r9,2047
81121e94:	02800044 	movi	r10,1
81121e98:	5080670e 	bge	r10,r2,81122038 <__subdf3+0x58c>
81121e9c:	0081ffc4 	movi	r2,2047
81121ea0:	4880af26 	beq	r9,r2,81122160 <__subdf3+0x6b4>
81121ea4:	898d883a 	add	r6,r17,r6
81121ea8:	1945883a 	add	r2,r3,r5
81121eac:	3447803a 	cmpltu	r3,r6,r17
81121eb0:	1887883a 	add	r3,r3,r2
81121eb4:	182297fa 	slli	r17,r3,31
81121eb8:	300cd07a 	srli	r6,r6,1
81121ebc:	1806d07a 	srli	r3,r3,1
81121ec0:	4821883a 	mov	r16,r9
81121ec4:	89a2b03a 	or	r17,r17,r6
81121ec8:	003f1b06 	br	81121b38 <__reset+0xfb101b38>
81121ecc:	0101ffc4 	movi	r4,2047
81121ed0:	813f441e 	bne	r16,r4,81121be4 <__reset+0xfb101be4>
81121ed4:	003f1806 	br	81121b38 <__reset+0xfb101b38>
81121ed8:	843ff844 	addi	r16,r16,-31
81121edc:	01400804 	movi	r5,32
81121ee0:	1408d83a 	srl	r4,r2,r16
81121ee4:	19405026 	beq	r3,r5,81122028 <__subdf3+0x57c>
81121ee8:	01401004 	movi	r5,64
81121eec:	28c7c83a 	sub	r3,r5,r3
81121ef0:	10c4983a 	sll	r2,r2,r3
81121ef4:	88a2b03a 	or	r17,r17,r2
81121ef8:	8822c03a 	cmpne	r17,r17,zero
81121efc:	2462b03a 	or	r17,r4,r17
81121f00:	0007883a 	mov	r3,zero
81121f04:	0021883a 	mov	r16,zero
81121f08:	003f6d06 	br	81121cc0 <__reset+0xfb101cc0>
81121f0c:	11fff804 	addi	r7,r2,-32
81121f10:	01000804 	movi	r4,32
81121f14:	29ced83a 	srl	r7,r5,r7
81121f18:	11004526 	beq	r2,r4,81122030 <__subdf3+0x584>
81121f1c:	01001004 	movi	r4,64
81121f20:	2089c83a 	sub	r4,r4,r2
81121f24:	2904983a 	sll	r2,r5,r4
81121f28:	118cb03a 	or	r6,r2,r6
81121f2c:	300cc03a 	cmpne	r6,r6,zero
81121f30:	398cb03a 	or	r6,r7,r6
81121f34:	0005883a 	mov	r2,zero
81121f38:	003f3706 	br	81121c18 <__reset+0xfb101c18>
81121f3c:	80002a26 	beq	r16,zero,81121fe8 <__subdf3+0x53c>
81121f40:	0101ffc4 	movi	r4,2047
81121f44:	49006626 	beq	r9,r4,811220e0 <__subdf3+0x634>
81121f48:	0085c83a 	sub	r2,zero,r2
81121f4c:	18c02034 	orhi	r3,r3,128
81121f50:	01000e04 	movi	r4,56
81121f54:	20807e16 	blt	r4,r2,81122150 <__subdf3+0x6a4>
81121f58:	010007c4 	movi	r4,31
81121f5c:	2080e716 	blt	r4,r2,811222fc <__subdf3+0x850>
81121f60:	01000804 	movi	r4,32
81121f64:	2089c83a 	sub	r4,r4,r2
81121f68:	1914983a 	sll	r10,r3,r4
81121f6c:	8890d83a 	srl	r8,r17,r2
81121f70:	8908983a 	sll	r4,r17,r4
81121f74:	1884d83a 	srl	r2,r3,r2
81121f78:	5222b03a 	or	r17,r10,r8
81121f7c:	2006c03a 	cmpne	r3,r4,zero
81121f80:	88e2b03a 	or	r17,r17,r3
81121f84:	3463c83a 	sub	r17,r6,r17
81121f88:	2885c83a 	sub	r2,r5,r2
81121f8c:	344d803a 	cmpltu	r6,r6,r17
81121f90:	1187c83a 	sub	r3,r2,r6
81121f94:	4821883a 	mov	r16,r9
81121f98:	3825883a 	mov	r18,r7
81121f9c:	003f2306 	br	81121c2c <__reset+0xfb101c2c>
81121fa0:	24d0b03a 	or	r8,r4,r19
81121fa4:	40001b1e 	bne	r8,zero,81122014 <__subdf3+0x568>
81121fa8:	0005883a 	mov	r2,zero
81121fac:	0009883a 	mov	r4,zero
81121fb0:	0021883a 	mov	r16,zero
81121fb4:	003f4906 	br	81121cdc <__reset+0xfb101cdc>
81121fb8:	010007c4 	movi	r4,31
81121fbc:	20803a16 	blt	r4,r2,811220a8 <__subdf3+0x5fc>
81121fc0:	01000804 	movi	r4,32
81121fc4:	2089c83a 	sub	r4,r4,r2
81121fc8:	2912983a 	sll	r9,r5,r4
81121fcc:	3090d83a 	srl	r8,r6,r2
81121fd0:	3108983a 	sll	r4,r6,r4
81121fd4:	2884d83a 	srl	r2,r5,r2
81121fd8:	4a12b03a 	or	r9,r9,r8
81121fdc:	2008c03a 	cmpne	r4,r4,zero
81121fe0:	4912b03a 	or	r9,r9,r4
81121fe4:	003f4e06 	br	81121d20 <__reset+0xfb101d20>
81121fe8:	1c48b03a 	or	r4,r3,r17
81121fec:	20003c26 	beq	r4,zero,811220e0 <__subdf3+0x634>
81121ff0:	0084303a 	nor	r2,zero,r2
81121ff4:	1000381e 	bne	r2,zero,811220d8 <__subdf3+0x62c>
81121ff8:	3463c83a 	sub	r17,r6,r17
81121ffc:	28c5c83a 	sub	r2,r5,r3
81122000:	344d803a 	cmpltu	r6,r6,r17
81122004:	1187c83a 	sub	r3,r2,r6
81122008:	4821883a 	mov	r16,r9
8112200c:	3825883a 	mov	r18,r7
81122010:	003f0606 	br	81121c2c <__reset+0xfb101c2c>
81122014:	2023883a 	mov	r17,r4
81122018:	003f0906 	br	81121c40 <__reset+0xfb101c40>
8112201c:	0101ffc4 	movi	r4,2047
81122020:	813f3a1e 	bne	r16,r4,81121d0c <__reset+0xfb101d0c>
81122024:	003ec406 	br	81121b38 <__reset+0xfb101b38>
81122028:	0005883a 	mov	r2,zero
8112202c:	003fb106 	br	81121ef4 <__reset+0xfb101ef4>
81122030:	0005883a 	mov	r2,zero
81122034:	003fbc06 	br	81121f28 <__reset+0xfb101f28>
81122038:	1c44b03a 	or	r2,r3,r17
8112203c:	80008e1e 	bne	r16,zero,81122278 <__subdf3+0x7cc>
81122040:	1000c826 	beq	r2,zero,81122364 <__subdf3+0x8b8>
81122044:	2984b03a 	or	r2,r5,r6
81122048:	103ebb26 	beq	r2,zero,81121b38 <__reset+0xfb101b38>
8112204c:	8989883a 	add	r4,r17,r6
81122050:	1945883a 	add	r2,r3,r5
81122054:	2447803a 	cmpltu	r3,r4,r17
81122058:	1887883a 	add	r3,r3,r2
8112205c:	1880202c 	andhi	r2,r3,128
81122060:	2023883a 	mov	r17,r4
81122064:	103f1626 	beq	r2,zero,81121cc0 <__reset+0xfb101cc0>
81122068:	00bfe034 	movhi	r2,65408
8112206c:	10bfffc4 	addi	r2,r2,-1
81122070:	5021883a 	mov	r16,r10
81122074:	1886703a 	and	r3,r3,r2
81122078:	003eaf06 	br	81121b38 <__reset+0xfb101b38>
8112207c:	3825883a 	mov	r18,r7
81122080:	003f0f06 	br	81121cc0 <__reset+0xfb101cc0>
81122084:	1c44b03a 	or	r2,r3,r17
81122088:	8000251e 	bne	r16,zero,81122120 <__subdf3+0x674>
8112208c:	1000661e 	bne	r2,zero,81122228 <__subdf3+0x77c>
81122090:	2990b03a 	or	r8,r5,r6
81122094:	40009626 	beq	r8,zero,811222f0 <__subdf3+0x844>
81122098:	2807883a 	mov	r3,r5
8112209c:	3023883a 	mov	r17,r6
811220a0:	3825883a 	mov	r18,r7
811220a4:	003ea406 	br	81121b38 <__reset+0xfb101b38>
811220a8:	127ff804 	addi	r9,r2,-32
811220ac:	01000804 	movi	r4,32
811220b0:	2a52d83a 	srl	r9,r5,r9
811220b4:	11008c26 	beq	r2,r4,811222e8 <__subdf3+0x83c>
811220b8:	01001004 	movi	r4,64
811220bc:	2085c83a 	sub	r2,r4,r2
811220c0:	2884983a 	sll	r2,r5,r2
811220c4:	118cb03a 	or	r6,r2,r6
811220c8:	300cc03a 	cmpne	r6,r6,zero
811220cc:	4992b03a 	or	r9,r9,r6
811220d0:	0005883a 	mov	r2,zero
811220d4:	003f1206 	br	81121d20 <__reset+0xfb101d20>
811220d8:	0101ffc4 	movi	r4,2047
811220dc:	493f9c1e 	bne	r9,r4,81121f50 <__reset+0xfb101f50>
811220e0:	2807883a 	mov	r3,r5
811220e4:	3023883a 	mov	r17,r6
811220e8:	4821883a 	mov	r16,r9
811220ec:	3825883a 	mov	r18,r7
811220f0:	003e9106 	br	81121b38 <__reset+0xfb101b38>
811220f4:	80001f1e 	bne	r16,zero,81122174 <__subdf3+0x6c8>
811220f8:	1c48b03a 	or	r4,r3,r17
811220fc:	20005a26 	beq	r4,zero,81122268 <__subdf3+0x7bc>
81122100:	0084303a 	nor	r2,zero,r2
81122104:	1000561e 	bne	r2,zero,81122260 <__subdf3+0x7b4>
81122108:	89a3883a 	add	r17,r17,r6
8112210c:	1945883a 	add	r2,r3,r5
81122110:	898d803a 	cmpltu	r6,r17,r6
81122114:	3087883a 	add	r3,r6,r2
81122118:	4821883a 	mov	r16,r9
8112211c:	003f0506 	br	81121d34 <__reset+0xfb101d34>
81122120:	10002b1e 	bne	r2,zero,811221d0 <__subdf3+0x724>
81122124:	2984b03a 	or	r2,r5,r6
81122128:	10008026 	beq	r2,zero,8112232c <__subdf3+0x880>
8112212c:	2807883a 	mov	r3,r5
81122130:	3023883a 	mov	r17,r6
81122134:	3825883a 	mov	r18,r7
81122138:	0401ffc4 	movi	r16,2047
8112213c:	003e7e06 	br	81121b38 <__reset+0xfb101b38>
81122140:	3809883a 	mov	r4,r7
81122144:	0011883a 	mov	r8,zero
81122148:	0005883a 	mov	r2,zero
8112214c:	003ee306 	br	81121cdc <__reset+0xfb101cdc>
81122150:	1c62b03a 	or	r17,r3,r17
81122154:	8822c03a 	cmpne	r17,r17,zero
81122158:	0005883a 	mov	r2,zero
8112215c:	003f8906 	br	81121f84 <__reset+0xfb101f84>
81122160:	3809883a 	mov	r4,r7
81122164:	4821883a 	mov	r16,r9
81122168:	0011883a 	mov	r8,zero
8112216c:	0005883a 	mov	r2,zero
81122170:	003eda06 	br	81121cdc <__reset+0xfb101cdc>
81122174:	0101ffc4 	movi	r4,2047
81122178:	49003b26 	beq	r9,r4,81122268 <__subdf3+0x7bc>
8112217c:	0085c83a 	sub	r2,zero,r2
81122180:	18c02034 	orhi	r3,r3,128
81122184:	01000e04 	movi	r4,56
81122188:	20806e16 	blt	r4,r2,81122344 <__subdf3+0x898>
8112218c:	010007c4 	movi	r4,31
81122190:	20807716 	blt	r4,r2,81122370 <__subdf3+0x8c4>
81122194:	01000804 	movi	r4,32
81122198:	2089c83a 	sub	r4,r4,r2
8112219c:	1914983a 	sll	r10,r3,r4
811221a0:	8890d83a 	srl	r8,r17,r2
811221a4:	8908983a 	sll	r4,r17,r4
811221a8:	1884d83a 	srl	r2,r3,r2
811221ac:	5222b03a 	or	r17,r10,r8
811221b0:	2006c03a 	cmpne	r3,r4,zero
811221b4:	88e2b03a 	or	r17,r17,r3
811221b8:	89a3883a 	add	r17,r17,r6
811221bc:	1145883a 	add	r2,r2,r5
811221c0:	898d803a 	cmpltu	r6,r17,r6
811221c4:	3087883a 	add	r3,r6,r2
811221c8:	4821883a 	mov	r16,r9
811221cc:	003ed906 	br	81121d34 <__reset+0xfb101d34>
811221d0:	2984b03a 	or	r2,r5,r6
811221d4:	10004226 	beq	r2,zero,811222e0 <__subdf3+0x834>
811221d8:	1808d0fa 	srli	r4,r3,3
811221dc:	8822d0fa 	srli	r17,r17,3
811221e0:	1806977a 	slli	r3,r3,29
811221e4:	2080022c 	andhi	r2,r4,8
811221e8:	1c62b03a 	or	r17,r3,r17
811221ec:	10000826 	beq	r2,zero,81122210 <__subdf3+0x764>
811221f0:	2812d0fa 	srli	r9,r5,3
811221f4:	4880022c 	andhi	r2,r9,8
811221f8:	1000051e 	bne	r2,zero,81122210 <__subdf3+0x764>
811221fc:	300cd0fa 	srli	r6,r6,3
81122200:	2804977a 	slli	r2,r5,29
81122204:	4809883a 	mov	r4,r9
81122208:	3825883a 	mov	r18,r7
8112220c:	11a2b03a 	or	r17,r2,r6
81122210:	8806d77a 	srli	r3,r17,29
81122214:	200890fa 	slli	r4,r4,3
81122218:	882290fa 	slli	r17,r17,3
8112221c:	0401ffc4 	movi	r16,2047
81122220:	1906b03a 	or	r3,r3,r4
81122224:	003e4406 	br	81121b38 <__reset+0xfb101b38>
81122228:	2984b03a 	or	r2,r5,r6
8112222c:	103e4226 	beq	r2,zero,81121b38 <__reset+0xfb101b38>
81122230:	8989c83a 	sub	r4,r17,r6
81122234:	8911803a 	cmpltu	r8,r17,r4
81122238:	1945c83a 	sub	r2,r3,r5
8112223c:	1205c83a 	sub	r2,r2,r8
81122240:	1200202c 	andhi	r8,r2,128
81122244:	403e9a26 	beq	r8,zero,81121cb0 <__reset+0xfb101cb0>
81122248:	3463c83a 	sub	r17,r6,r17
8112224c:	28c5c83a 	sub	r2,r5,r3
81122250:	344d803a 	cmpltu	r6,r6,r17
81122254:	1187c83a 	sub	r3,r2,r6
81122258:	3825883a 	mov	r18,r7
8112225c:	003e3606 	br	81121b38 <__reset+0xfb101b38>
81122260:	0101ffc4 	movi	r4,2047
81122264:	493fc71e 	bne	r9,r4,81122184 <__reset+0xfb102184>
81122268:	2807883a 	mov	r3,r5
8112226c:	3023883a 	mov	r17,r6
81122270:	4821883a 	mov	r16,r9
81122274:	003e3006 	br	81121b38 <__reset+0xfb101b38>
81122278:	10003626 	beq	r2,zero,81122354 <__subdf3+0x8a8>
8112227c:	2984b03a 	or	r2,r5,r6
81122280:	10001726 	beq	r2,zero,811222e0 <__subdf3+0x834>
81122284:	1808d0fa 	srli	r4,r3,3
81122288:	8822d0fa 	srli	r17,r17,3
8112228c:	1806977a 	slli	r3,r3,29
81122290:	2080022c 	andhi	r2,r4,8
81122294:	1c62b03a 	or	r17,r3,r17
81122298:	10000726 	beq	r2,zero,811222b8 <__subdf3+0x80c>
8112229c:	2812d0fa 	srli	r9,r5,3
811222a0:	4880022c 	andhi	r2,r9,8
811222a4:	1000041e 	bne	r2,zero,811222b8 <__subdf3+0x80c>
811222a8:	300cd0fa 	srli	r6,r6,3
811222ac:	2804977a 	slli	r2,r5,29
811222b0:	4809883a 	mov	r4,r9
811222b4:	11a2b03a 	or	r17,r2,r6
811222b8:	8806d77a 	srli	r3,r17,29
811222bc:	200890fa 	slli	r4,r4,3
811222c0:	882290fa 	slli	r17,r17,3
811222c4:	3825883a 	mov	r18,r7
811222c8:	1906b03a 	or	r3,r3,r4
811222cc:	0401ffc4 	movi	r16,2047
811222d0:	003e1906 	br	81121b38 <__reset+0xfb101b38>
811222d4:	000b883a 	mov	r5,zero
811222d8:	0005883a 	mov	r2,zero
811222dc:	003e2e06 	br	81121b98 <__reset+0xfb101b98>
811222e0:	0401ffc4 	movi	r16,2047
811222e4:	003e1406 	br	81121b38 <__reset+0xfb101b38>
811222e8:	0005883a 	mov	r2,zero
811222ec:	003f7506 	br	811220c4 <__reset+0xfb1020c4>
811222f0:	0005883a 	mov	r2,zero
811222f4:	0009883a 	mov	r4,zero
811222f8:	003e7806 	br	81121cdc <__reset+0xfb101cdc>
811222fc:	123ff804 	addi	r8,r2,-32
81122300:	01000804 	movi	r4,32
81122304:	1a10d83a 	srl	r8,r3,r8
81122308:	11002526 	beq	r2,r4,811223a0 <__subdf3+0x8f4>
8112230c:	01001004 	movi	r4,64
81122310:	2085c83a 	sub	r2,r4,r2
81122314:	1884983a 	sll	r2,r3,r2
81122318:	1444b03a 	or	r2,r2,r17
8112231c:	1004c03a 	cmpne	r2,r2,zero
81122320:	40a2b03a 	or	r17,r8,r2
81122324:	0005883a 	mov	r2,zero
81122328:	003f1606 	br	81121f84 <__reset+0xfb101f84>
8112232c:	02000434 	movhi	r8,16
81122330:	0009883a 	mov	r4,zero
81122334:	423fffc4 	addi	r8,r8,-1
81122338:	00bfffc4 	movi	r2,-1
8112233c:	0401ffc4 	movi	r16,2047
81122340:	003e6606 	br	81121cdc <__reset+0xfb101cdc>
81122344:	1c62b03a 	or	r17,r3,r17
81122348:	8822c03a 	cmpne	r17,r17,zero
8112234c:	0005883a 	mov	r2,zero
81122350:	003f9906 	br	811221b8 <__reset+0xfb1021b8>
81122354:	2807883a 	mov	r3,r5
81122358:	3023883a 	mov	r17,r6
8112235c:	0401ffc4 	movi	r16,2047
81122360:	003df506 	br	81121b38 <__reset+0xfb101b38>
81122364:	2807883a 	mov	r3,r5
81122368:	3023883a 	mov	r17,r6
8112236c:	003df206 	br	81121b38 <__reset+0xfb101b38>
81122370:	123ff804 	addi	r8,r2,-32
81122374:	01000804 	movi	r4,32
81122378:	1a10d83a 	srl	r8,r3,r8
8112237c:	11000a26 	beq	r2,r4,811223a8 <__subdf3+0x8fc>
81122380:	01001004 	movi	r4,64
81122384:	2085c83a 	sub	r2,r4,r2
81122388:	1884983a 	sll	r2,r3,r2
8112238c:	1444b03a 	or	r2,r2,r17
81122390:	1004c03a 	cmpne	r2,r2,zero
81122394:	40a2b03a 	or	r17,r8,r2
81122398:	0005883a 	mov	r2,zero
8112239c:	003f8606 	br	811221b8 <__reset+0xfb1021b8>
811223a0:	0005883a 	mov	r2,zero
811223a4:	003fdc06 	br	81122318 <__reset+0xfb102318>
811223a8:	0005883a 	mov	r2,zero
811223ac:	003ff706 	br	8112238c <__reset+0xfb10238c>

811223b0 <__fixdfsi>:
811223b0:	280cd53a 	srli	r6,r5,20
811223b4:	00c00434 	movhi	r3,16
811223b8:	18ffffc4 	addi	r3,r3,-1
811223bc:	3181ffcc 	andi	r6,r6,2047
811223c0:	01c0ff84 	movi	r7,1022
811223c4:	28c6703a 	and	r3,r5,r3
811223c8:	280ad7fa 	srli	r5,r5,31
811223cc:	3980120e 	bge	r7,r6,81122418 <__fixdfsi+0x68>
811223d0:	00810744 	movi	r2,1053
811223d4:	11800c16 	blt	r2,r6,81122408 <__fixdfsi+0x58>
811223d8:	00810cc4 	movi	r2,1075
811223dc:	1185c83a 	sub	r2,r2,r6
811223e0:	01c007c4 	movi	r7,31
811223e4:	18c00434 	orhi	r3,r3,16
811223e8:	38800d16 	blt	r7,r2,81122420 <__fixdfsi+0x70>
811223ec:	31befb44 	addi	r6,r6,-1043
811223f0:	2084d83a 	srl	r2,r4,r2
811223f4:	1986983a 	sll	r3,r3,r6
811223f8:	1884b03a 	or	r2,r3,r2
811223fc:	28000726 	beq	r5,zero,8112241c <__fixdfsi+0x6c>
81122400:	0085c83a 	sub	r2,zero,r2
81122404:	f800283a 	ret
81122408:	00a00034 	movhi	r2,32768
8112240c:	10bfffc4 	addi	r2,r2,-1
81122410:	2885883a 	add	r2,r5,r2
81122414:	f800283a 	ret
81122418:	0005883a 	mov	r2,zero
8112241c:	f800283a 	ret
81122420:	008104c4 	movi	r2,1043
81122424:	1185c83a 	sub	r2,r2,r6
81122428:	1884d83a 	srl	r2,r3,r2
8112242c:	003ff306 	br	811223fc <__reset+0xfb1023fc>

81122430 <__floatsidf>:
81122430:	defffd04 	addi	sp,sp,-12
81122434:	de00012e 	bgeu	sp,et,8112243c <__floatsidf+0xc>
81122438:	003b68fa 	trap	3
8112243c:	dfc00215 	stw	ra,8(sp)
81122440:	dc400115 	stw	r17,4(sp)
81122444:	dc000015 	stw	r16,0(sp)
81122448:	20002b26 	beq	r4,zero,811224f8 <__floatsidf+0xc8>
8112244c:	2023883a 	mov	r17,r4
81122450:	2020d7fa 	srli	r16,r4,31
81122454:	20002d16 	blt	r4,zero,8112250c <__floatsidf+0xdc>
81122458:	8809883a 	mov	r4,r17
8112245c:	11227d40 	call	811227d4 <__clzsi2>
81122460:	01410784 	movi	r5,1054
81122464:	288bc83a 	sub	r5,r5,r2
81122468:	01010cc4 	movi	r4,1075
8112246c:	2149c83a 	sub	r4,r4,r5
81122470:	00c007c4 	movi	r3,31
81122474:	1900160e 	bge	r3,r4,811224d0 <__floatsidf+0xa0>
81122478:	00c104c4 	movi	r3,1043
8112247c:	1947c83a 	sub	r3,r3,r5
81122480:	88c6983a 	sll	r3,r17,r3
81122484:	00800434 	movhi	r2,16
81122488:	10bfffc4 	addi	r2,r2,-1
8112248c:	1886703a 	and	r3,r3,r2
81122490:	2941ffcc 	andi	r5,r5,2047
81122494:	800d883a 	mov	r6,r16
81122498:	0005883a 	mov	r2,zero
8112249c:	280a953a 	slli	r5,r5,20
811224a0:	31803fcc 	andi	r6,r6,255
811224a4:	01000434 	movhi	r4,16
811224a8:	300c97fa 	slli	r6,r6,31
811224ac:	213fffc4 	addi	r4,r4,-1
811224b0:	1906703a 	and	r3,r3,r4
811224b4:	1946b03a 	or	r3,r3,r5
811224b8:	1986b03a 	or	r3,r3,r6
811224bc:	dfc00217 	ldw	ra,8(sp)
811224c0:	dc400117 	ldw	r17,4(sp)
811224c4:	dc000017 	ldw	r16,0(sp)
811224c8:	dec00304 	addi	sp,sp,12
811224cc:	f800283a 	ret
811224d0:	00c002c4 	movi	r3,11
811224d4:	1887c83a 	sub	r3,r3,r2
811224d8:	88c6d83a 	srl	r3,r17,r3
811224dc:	8904983a 	sll	r2,r17,r4
811224e0:	01000434 	movhi	r4,16
811224e4:	213fffc4 	addi	r4,r4,-1
811224e8:	2941ffcc 	andi	r5,r5,2047
811224ec:	1906703a 	and	r3,r3,r4
811224f0:	800d883a 	mov	r6,r16
811224f4:	003fe906 	br	8112249c <__reset+0xfb10249c>
811224f8:	000d883a 	mov	r6,zero
811224fc:	000b883a 	mov	r5,zero
81122500:	0007883a 	mov	r3,zero
81122504:	0005883a 	mov	r2,zero
81122508:	003fe406 	br	8112249c <__reset+0xfb10249c>
8112250c:	0123c83a 	sub	r17,zero,r4
81122510:	003fd106 	br	81122458 <__reset+0xfb102458>

81122514 <__extendsfdf2>:
81122514:	200ad5fa 	srli	r5,r4,23
81122518:	defffd04 	addi	sp,sp,-12
8112251c:	de00012e 	bgeu	sp,et,81122524 <__extendsfdf2+0x10>
81122520:	003b68fa 	trap	3
81122524:	29403fcc 	andi	r5,r5,255
81122528:	dc400115 	stw	r17,4(sp)
8112252c:	29800044 	addi	r6,r5,1
81122530:	04402034 	movhi	r17,128
81122534:	dc000015 	stw	r16,0(sp)
81122538:	8c7fffc4 	addi	r17,r17,-1
8112253c:	dfc00215 	stw	ra,8(sp)
81122540:	31803fcc 	andi	r6,r6,255
81122544:	00800044 	movi	r2,1
81122548:	8922703a 	and	r17,r17,r4
8112254c:	2020d7fa 	srli	r16,r4,31
81122550:	1180110e 	bge	r2,r6,81122598 <__extendsfdf2+0x84>
81122554:	880cd0fa 	srli	r6,r17,3
81122558:	8822977a 	slli	r17,r17,29
8112255c:	2940e004 	addi	r5,r5,896
81122560:	2941ffcc 	andi	r5,r5,2047
81122564:	2804953a 	slli	r2,r5,20
81122568:	01400434 	movhi	r5,16
8112256c:	800697fa 	slli	r3,r16,31
81122570:	297fffc4 	addi	r5,r5,-1
81122574:	314a703a 	and	r5,r6,r5
81122578:	288ab03a 	or	r5,r5,r2
8112257c:	28c6b03a 	or	r3,r5,r3
81122580:	8805883a 	mov	r2,r17
81122584:	dfc00217 	ldw	ra,8(sp)
81122588:	dc400117 	ldw	r17,4(sp)
8112258c:	dc000017 	ldw	r16,0(sp)
81122590:	dec00304 	addi	sp,sp,12
81122594:	f800283a 	ret
81122598:	2800111e 	bne	r5,zero,811225e0 <__extendsfdf2+0xcc>
8112259c:	88001c26 	beq	r17,zero,81122610 <__extendsfdf2+0xfc>
811225a0:	8809883a 	mov	r4,r17
811225a4:	11227d40 	call	811227d4 <__clzsi2>
811225a8:	00c00284 	movi	r3,10
811225ac:	18801b16 	blt	r3,r2,8112261c <__extendsfdf2+0x108>
811225b0:	018002c4 	movi	r6,11
811225b4:	308dc83a 	sub	r6,r6,r2
811225b8:	11000544 	addi	r4,r2,21
811225bc:	8986d83a 	srl	r3,r17,r6
811225c0:	8922983a 	sll	r17,r17,r4
811225c4:	0180e244 	movi	r6,905
811225c8:	01400434 	movhi	r5,16
811225cc:	3085c83a 	sub	r2,r6,r2
811225d0:	297fffc4 	addi	r5,r5,-1
811225d4:	194c703a 	and	r6,r3,r5
811225d8:	1141ffcc 	andi	r5,r2,2047
811225dc:	003fe006 	br	81122560 <__reset+0xfb102560>
811225e0:	88000826 	beq	r17,zero,81122604 <__extendsfdf2+0xf0>
811225e4:	880cd0fa 	srli	r6,r17,3
811225e8:	00800434 	movhi	r2,16
811225ec:	10bfffc4 	addi	r2,r2,-1
811225f0:	31800234 	orhi	r6,r6,8
811225f4:	8822977a 	slli	r17,r17,29
811225f8:	308c703a 	and	r6,r6,r2
811225fc:	0141ffc4 	movi	r5,2047
81122600:	003fd706 	br	81122560 <__reset+0xfb102560>
81122604:	0141ffc4 	movi	r5,2047
81122608:	000d883a 	mov	r6,zero
8112260c:	003fd406 	br	81122560 <__reset+0xfb102560>
81122610:	000b883a 	mov	r5,zero
81122614:	000d883a 	mov	r6,zero
81122618:	003fd106 	br	81122560 <__reset+0xfb102560>
8112261c:	11bffd44 	addi	r6,r2,-11
81122620:	8986983a 	sll	r3,r17,r6
81122624:	0023883a 	mov	r17,zero
81122628:	003fe606 	br	811225c4 <__reset+0xfb1025c4>

8112262c <__truncdfsf2>:
8112262c:	2810d53a 	srli	r8,r5,20
81122630:	01c00434 	movhi	r7,16
81122634:	39ffffc4 	addi	r7,r7,-1
81122638:	29ce703a 	and	r7,r5,r7
8112263c:	4201ffcc 	andi	r8,r8,2047
81122640:	380e90fa 	slli	r7,r7,3
81122644:	200cd77a 	srli	r6,r4,29
81122648:	42400044 	addi	r9,r8,1
8112264c:	4a41ffcc 	andi	r9,r9,2047
81122650:	00c00044 	movi	r3,1
81122654:	280ad7fa 	srli	r5,r5,31
81122658:	31ceb03a 	or	r7,r6,r7
8112265c:	200490fa 	slli	r2,r4,3
81122660:	1a40230e 	bge	r3,r9,811226f0 <__truncdfsf2+0xc4>
81122664:	40ff2004 	addi	r3,r8,-896
81122668:	01803f84 	movi	r6,254
8112266c:	30c01516 	blt	r6,r3,811226c4 <__truncdfsf2+0x98>
81122670:	00c0380e 	bge	zero,r3,81122754 <__truncdfsf2+0x128>
81122674:	200c91ba 	slli	r6,r4,6
81122678:	380e90fa 	slli	r7,r7,3
8112267c:	1004d77a 	srli	r2,r2,29
81122680:	300cc03a 	cmpne	r6,r6,zero
81122684:	31ccb03a 	or	r6,r6,r7
81122688:	308cb03a 	or	r6,r6,r2
8112268c:	308001cc 	andi	r2,r6,7
81122690:	10000426 	beq	r2,zero,811226a4 <__truncdfsf2+0x78>
81122694:	308003cc 	andi	r2,r6,15
81122698:	01000104 	movi	r4,4
8112269c:	11000126 	beq	r2,r4,811226a4 <__truncdfsf2+0x78>
811226a0:	31800104 	addi	r6,r6,4
811226a4:	3081002c 	andhi	r2,r6,1024
811226a8:	10001626 	beq	r2,zero,81122704 <__truncdfsf2+0xd8>
811226ac:	18c00044 	addi	r3,r3,1
811226b0:	00803fc4 	movi	r2,255
811226b4:	18800326 	beq	r3,r2,811226c4 <__truncdfsf2+0x98>
811226b8:	300c91ba 	slli	r6,r6,6
811226bc:	300cd27a 	srli	r6,r6,9
811226c0:	00000206 	br	811226cc <__truncdfsf2+0xa0>
811226c4:	00ffffc4 	movi	r3,-1
811226c8:	000d883a 	mov	r6,zero
811226cc:	18c03fcc 	andi	r3,r3,255
811226d0:	180895fa 	slli	r4,r3,23
811226d4:	00c02034 	movhi	r3,128
811226d8:	280a97fa 	slli	r5,r5,31
811226dc:	18ffffc4 	addi	r3,r3,-1
811226e0:	30c6703a 	and	r3,r6,r3
811226e4:	1906b03a 	or	r3,r3,r4
811226e8:	1944b03a 	or	r2,r3,r5
811226ec:	f800283a 	ret
811226f0:	40000b1e 	bne	r8,zero,81122720 <__truncdfsf2+0xf4>
811226f4:	388cb03a 	or	r6,r7,r2
811226f8:	0007883a 	mov	r3,zero
811226fc:	30000426 	beq	r6,zero,81122710 <__truncdfsf2+0xe4>
81122700:	01800144 	movi	r6,5
81122704:	00803fc4 	movi	r2,255
81122708:	300cd0fa 	srli	r6,r6,3
8112270c:	18800a26 	beq	r3,r2,81122738 <__truncdfsf2+0x10c>
81122710:	00802034 	movhi	r2,128
81122714:	10bfffc4 	addi	r2,r2,-1
81122718:	308c703a 	and	r6,r6,r2
8112271c:	003feb06 	br	811226cc <__reset+0xfb1026cc>
81122720:	3888b03a 	or	r4,r7,r2
81122724:	203fe726 	beq	r4,zero,811226c4 <__reset+0xfb1026c4>
81122728:	380c90fa 	slli	r6,r7,3
8112272c:	00c03fc4 	movi	r3,255
81122730:	31808034 	orhi	r6,r6,512
81122734:	003fd506 	br	8112268c <__reset+0xfb10268c>
81122738:	303fe226 	beq	r6,zero,811226c4 <__reset+0xfb1026c4>
8112273c:	00802034 	movhi	r2,128
81122740:	31801034 	orhi	r6,r6,64
81122744:	10bfffc4 	addi	r2,r2,-1
81122748:	00ffffc4 	movi	r3,-1
8112274c:	308c703a 	and	r6,r6,r2
81122750:	003fde06 	br	811226cc <__reset+0xfb1026cc>
81122754:	013ffa44 	movi	r4,-23
81122758:	19000e16 	blt	r3,r4,81122794 <__truncdfsf2+0x168>
8112275c:	01000784 	movi	r4,30
81122760:	20c9c83a 	sub	r4,r4,r3
81122764:	018007c4 	movi	r6,31
81122768:	39c02034 	orhi	r7,r7,128
8112276c:	31000b16 	blt	r6,r4,8112279c <__truncdfsf2+0x170>
81122770:	423f2084 	addi	r8,r8,-894
81122774:	120c983a 	sll	r6,r2,r8
81122778:	3a0e983a 	sll	r7,r7,r8
8112277c:	1104d83a 	srl	r2,r2,r4
81122780:	300cc03a 	cmpne	r6,r6,zero
81122784:	31ceb03a 	or	r7,r6,r7
81122788:	388cb03a 	or	r6,r7,r2
8112278c:	0007883a 	mov	r3,zero
81122790:	003fbe06 	br	8112268c <__reset+0xfb10268c>
81122794:	0007883a 	mov	r3,zero
81122798:	003fd906 	br	81122700 <__reset+0xfb102700>
8112279c:	01bfff84 	movi	r6,-2
811227a0:	30cdc83a 	sub	r6,r6,r3
811227a4:	00c00804 	movi	r3,32
811227a8:	398cd83a 	srl	r6,r7,r6
811227ac:	20c00726 	beq	r4,r3,811227cc <__truncdfsf2+0x1a0>
811227b0:	423f2884 	addi	r8,r8,-862
811227b4:	3a0e983a 	sll	r7,r7,r8
811227b8:	3884b03a 	or	r2,r7,r2
811227bc:	1004c03a 	cmpne	r2,r2,zero
811227c0:	118cb03a 	or	r6,r2,r6
811227c4:	0007883a 	mov	r3,zero
811227c8:	003fb006 	br	8112268c <__reset+0xfb10268c>
811227cc:	000f883a 	mov	r7,zero
811227d0:	003ff906 	br	811227b8 <__reset+0xfb1027b8>

811227d4 <__clzsi2>:
811227d4:	00bfffd4 	movui	r2,65535
811227d8:	11000536 	bltu	r2,r4,811227f0 <__clzsi2+0x1c>
811227dc:	00803fc4 	movi	r2,255
811227e0:	11000f36 	bltu	r2,r4,81122820 <__clzsi2+0x4c>
811227e4:	00800804 	movi	r2,32
811227e8:	0007883a 	mov	r3,zero
811227ec:	00000506 	br	81122804 <__clzsi2+0x30>
811227f0:	00804034 	movhi	r2,256
811227f4:	10bfffc4 	addi	r2,r2,-1
811227f8:	11000c2e 	bgeu	r2,r4,8112282c <__clzsi2+0x58>
811227fc:	00800204 	movi	r2,8
81122800:	00c00604 	movi	r3,24
81122804:	20c8d83a 	srl	r4,r4,r3
81122808:	00e04574 	movhi	r3,33045
8112280c:	18c65804 	addi	r3,r3,6496
81122810:	1909883a 	add	r4,r3,r4
81122814:	20c00003 	ldbu	r3,0(r4)
81122818:	10c5c83a 	sub	r2,r2,r3
8112281c:	f800283a 	ret
81122820:	00800604 	movi	r2,24
81122824:	00c00204 	movi	r3,8
81122828:	003ff606 	br	81122804 <__reset+0xfb102804>
8112282c:	00800404 	movi	r2,16
81122830:	1007883a 	mov	r3,r2
81122834:	003ff306 	br	81122804 <__reset+0xfb102804>

81122838 <atoi>:
81122838:	01800284 	movi	r6,10
8112283c:	000b883a 	mov	r5,zero
81122840:	11247d81 	jmpi	811247d8 <strtol>

81122844 <_atoi_r>:
81122844:	01c00284 	movi	r7,10
81122848:	000d883a 	mov	r6,zero
8112284c:	11245981 	jmpi	81124598 <_strtol_r>

81122850 <_fopen_r>:
81122850:	defffa04 	addi	sp,sp,-24
81122854:	3005883a 	mov	r2,r6
81122858:	de00012e 	bgeu	sp,et,81122860 <_fopen_r+0x10>
8112285c:	003b68fa 	trap	3
81122860:	d80d883a 	mov	r6,sp
81122864:	dcc00415 	stw	r19,16(sp)
81122868:	2827883a 	mov	r19,r5
8112286c:	100b883a 	mov	r5,r2
81122870:	dc800315 	stw	r18,12(sp)
81122874:	dfc00515 	stw	ra,20(sp)
81122878:	dc400215 	stw	r17,8(sp)
8112287c:	dc000115 	stw	r16,4(sp)
81122880:	2025883a 	mov	r18,r4
81122884:	112c7e00 	call	8112c7e0 <__sflags>
81122888:	10002726 	beq	r2,zero,81122928 <_fopen_r+0xd8>
8112288c:	9009883a 	mov	r4,r18
81122890:	1023883a 	mov	r17,r2
81122894:	112c6580 	call	8112c658 <__sfp>
81122898:	1021883a 	mov	r16,r2
8112289c:	10002226 	beq	r2,zero,81122928 <_fopen_r+0xd8>
811228a0:	d9800017 	ldw	r6,0(sp)
811228a4:	01c06d84 	movi	r7,438
811228a8:	980b883a 	mov	r5,r19
811228ac:	9009883a 	mov	r4,r18
811228b0:	1123cbc0 	call	81123cbc <_open_r>
811228b4:	10001916 	blt	r2,zero,8112291c <_fopen_r+0xcc>
811228b8:	8080038d 	sth	r2,14(r16)
811228bc:	00a044b4 	movhi	r2,33042
811228c0:	1090c704 	addi	r2,r2,17180
811228c4:	80800815 	stw	r2,32(r16)
811228c8:	00a044b4 	movhi	r2,33042
811228cc:	1090e004 	addi	r2,r2,17280
811228d0:	80800915 	stw	r2,36(r16)
811228d4:	00a044b4 	movhi	r2,33042
811228d8:	10910104 	addi	r2,r2,17412
811228dc:	80800a15 	stw	r2,40(r16)
811228e0:	00a044b4 	movhi	r2,33042
811228e4:	10911a04 	addi	r2,r2,17512
811228e8:	8440030d 	sth	r17,12(r16)
811228ec:	84000715 	stw	r16,28(r16)
811228f0:	80800b15 	stw	r2,44(r16)
811228f4:	8c40400c 	andi	r17,r17,256
811228f8:	88000d1e 	bne	r17,zero,81122930 <_fopen_r+0xe0>
811228fc:	8005883a 	mov	r2,r16
81122900:	dfc00517 	ldw	ra,20(sp)
81122904:	dcc00417 	ldw	r19,16(sp)
81122908:	dc800317 	ldw	r18,12(sp)
8112290c:	dc400217 	ldw	r17,8(sp)
81122910:	dc000117 	ldw	r16,4(sp)
81122914:	dec00604 	addi	sp,sp,24
81122918:	f800283a 	ret
8112291c:	112c7a00 	call	8112c7a0 <__sfp_lock_acquire>
81122920:	8000030d 	sth	zero,12(r16)
81122924:	112c7a40 	call	8112c7a4 <__sfp_lock_release>
81122928:	0005883a 	mov	r2,zero
8112292c:	003ff406 	br	81122900 <__reset+0xfb102900>
81122930:	01c00084 	movi	r7,2
81122934:	000d883a 	mov	r6,zero
81122938:	800b883a 	mov	r5,r16
8112293c:	9009883a 	mov	r4,r18
81122940:	1122a700 	call	81122a70 <_fseek_r>
81122944:	8005883a 	mov	r2,r16
81122948:	003fed06 	br	81122900 <__reset+0xfb102900>

8112294c <fopen>:
8112294c:	00a04574 	movhi	r2,33045
81122950:	10911304 	addi	r2,r2,17484
81122954:	280d883a 	mov	r6,r5
81122958:	200b883a 	mov	r5,r4
8112295c:	11000017 	ldw	r4,0(r2)
81122960:	11228501 	jmpi	81122850 <_fopen_r>

81122964 <_fprintf_r>:
81122964:	defffe04 	addi	sp,sp,-8
81122968:	2809883a 	mov	r4,r5
8112296c:	300b883a 	mov	r5,r6
81122970:	de00012e 	bgeu	sp,et,81122978 <_fprintf_r+0x14>
81122974:	003b68fa 	trap	3
81122978:	dfc00015 	stw	ra,0(sp)
8112297c:	d9c00115 	stw	r7,4(sp)
81122980:	d9800104 	addi	r6,sp,4
81122984:	1128bd40 	call	81128bd4 <__vfprintf_internal>
81122988:	dfc00017 	ldw	ra,0(sp)
8112298c:	dec00204 	addi	sp,sp,8
81122990:	f800283a 	ret

81122994 <fprintf>:
81122994:	defffd04 	addi	sp,sp,-12
81122998:	de00012e 	bgeu	sp,et,811229a0 <fprintf+0xc>
8112299c:	003b68fa 	trap	3
811229a0:	dfc00015 	stw	ra,0(sp)
811229a4:	d9800115 	stw	r6,4(sp)
811229a8:	d9c00215 	stw	r7,8(sp)
811229ac:	d9800104 	addi	r6,sp,4
811229b0:	1128bd40 	call	81128bd4 <__vfprintf_internal>
811229b4:	dfc00017 	ldw	ra,0(sp)
811229b8:	dec00304 	addi	sp,sp,12
811229bc:	f800283a 	ret

811229c0 <_fputc_r>:
811229c0:	defffc04 	addi	sp,sp,-16
811229c4:	de00012e 	bgeu	sp,et,811229cc <_fputc_r+0xc>
811229c8:	003b68fa 	trap	3
811229cc:	dc000215 	stw	r16,8(sp)
811229d0:	dfc00315 	stw	ra,12(sp)
811229d4:	2021883a 	mov	r16,r4
811229d8:	20000726 	beq	r4,zero,811229f8 <_fputc_r+0x38>
811229dc:	20800e17 	ldw	r2,56(r4)
811229e0:	1000051e 	bne	r2,zero,811229f8 <_fputc_r+0x38>
811229e4:	d9400015 	stw	r5,0(sp)
811229e8:	d9800115 	stw	r6,4(sp)
811229ec:	112c7900 	call	8112c790 <__sinit>
811229f0:	d9800117 	ldw	r6,4(sp)
811229f4:	d9400017 	ldw	r5,0(sp)
811229f8:	8009883a 	mov	r4,r16
811229fc:	dfc00317 	ldw	ra,12(sp)
81122a00:	dc000217 	ldw	r16,8(sp)
81122a04:	dec00404 	addi	sp,sp,16
81122a08:	1123d241 	jmpi	81123d24 <_putc_r>

81122a0c <fputc>:
81122a0c:	00a04574 	movhi	r2,33045
81122a10:	defffc04 	addi	sp,sp,-16
81122a14:	10911304 	addi	r2,r2,17484
81122a18:	de00012e 	bgeu	sp,et,81122a20 <fputc+0x14>
81122a1c:	003b68fa 	trap	3
81122a20:	dc000115 	stw	r16,4(sp)
81122a24:	14000017 	ldw	r16,0(r2)
81122a28:	dc400215 	stw	r17,8(sp)
81122a2c:	dfc00315 	stw	ra,12(sp)
81122a30:	2023883a 	mov	r17,r4
81122a34:	80000626 	beq	r16,zero,81122a50 <fputc+0x44>
81122a38:	80800e17 	ldw	r2,56(r16)
81122a3c:	1000041e 	bne	r2,zero,81122a50 <fputc+0x44>
81122a40:	8009883a 	mov	r4,r16
81122a44:	d9400015 	stw	r5,0(sp)
81122a48:	112c7900 	call	8112c790 <__sinit>
81122a4c:	d9400017 	ldw	r5,0(sp)
81122a50:	280d883a 	mov	r6,r5
81122a54:	8009883a 	mov	r4,r16
81122a58:	880b883a 	mov	r5,r17
81122a5c:	dfc00317 	ldw	ra,12(sp)
81122a60:	dc400217 	ldw	r17,8(sp)
81122a64:	dc000117 	ldw	r16,4(sp)
81122a68:	dec00404 	addi	sp,sp,16
81122a6c:	1123d241 	jmpi	81123d24 <_putc_r>

81122a70 <_fseek_r>:
81122a70:	1122a901 	jmpi	81122a90 <_fseeko_r>

81122a74 <fseek>:
81122a74:	00a04574 	movhi	r2,33045
81122a78:	10911304 	addi	r2,r2,17484
81122a7c:	300f883a 	mov	r7,r6
81122a80:	280d883a 	mov	r6,r5
81122a84:	200b883a 	mov	r5,r4
81122a88:	11000017 	ldw	r4,0(r2)
81122a8c:	1122a901 	jmpi	81122a90 <_fseeko_r>

81122a90 <_fseeko_r>:
81122a90:	deffe804 	addi	sp,sp,-96
81122a94:	de00012e 	bgeu	sp,et,81122a9c <_fseeko_r+0xc>
81122a98:	003b68fa 	trap	3
81122a9c:	dd401415 	stw	r21,80(sp)
81122aa0:	dc801115 	stw	r18,68(sp)
81122aa4:	dc401015 	stw	r17,64(sp)
81122aa8:	dc000f15 	stw	r16,60(sp)
81122aac:	dfc01715 	stw	ra,92(sp)
81122ab0:	ddc01615 	stw	r23,88(sp)
81122ab4:	dd801515 	stw	r22,84(sp)
81122ab8:	dd001315 	stw	r20,76(sp)
81122abc:	dcc01215 	stw	r19,72(sp)
81122ac0:	2023883a 	mov	r17,r4
81122ac4:	2821883a 	mov	r16,r5
81122ac8:	302b883a 	mov	r21,r6
81122acc:	3825883a 	mov	r18,r7
81122ad0:	20000226 	beq	r4,zero,81122adc <_fseeko_r+0x4c>
81122ad4:	20800e17 	ldw	r2,56(r4)
81122ad8:	10005a26 	beq	r2,zero,81122c44 <_fseeko_r+0x1b4>
81122adc:	8080030b 	ldhu	r2,12(r16)
81122ae0:	00c04204 	movi	r3,264
81122ae4:	1080420c 	andi	r2,r2,264
81122ae8:	10c05b26 	beq	r2,r3,81122c58 <_fseeko_r+0x1c8>
81122aec:	85000a17 	ldw	r20,40(r16)
81122af0:	a000f626 	beq	r20,zero,81122ecc <_fseeko_r+0x43c>
81122af4:	00800044 	movi	r2,1
81122af8:	90803e26 	beq	r18,r2,81122bf4 <_fseeko_r+0x164>
81122afc:	00800084 	movi	r2,2
81122b00:	90801026 	beq	r18,r2,81122b44 <_fseeko_r+0xb4>
81122b04:	90000f26 	beq	r18,zero,81122b44 <_fseeko_r+0xb4>
81122b08:	00800584 	movi	r2,22
81122b0c:	88800015 	stw	r2,0(r17)
81122b10:	04ffffc4 	movi	r19,-1
81122b14:	9805883a 	mov	r2,r19
81122b18:	dfc01717 	ldw	ra,92(sp)
81122b1c:	ddc01617 	ldw	r23,88(sp)
81122b20:	dd801517 	ldw	r22,84(sp)
81122b24:	dd401417 	ldw	r21,80(sp)
81122b28:	dd001317 	ldw	r20,76(sp)
81122b2c:	dcc01217 	ldw	r19,72(sp)
81122b30:	dc801117 	ldw	r18,68(sp)
81122b34:	dc401017 	ldw	r17,64(sp)
81122b38:	dc000f17 	ldw	r16,60(sp)
81122b3c:	dec01804 	addi	sp,sp,96
81122b40:	f800283a 	ret
81122b44:	80800417 	ldw	r2,16(r16)
81122b48:	002f883a 	mov	r23,zero
81122b4c:	0027883a 	mov	r19,zero
81122b50:	1000cb26 	beq	r2,zero,81122e80 <_fseeko_r+0x3f0>
81122b54:	8080030b 	ldhu	r2,12(r16)
81122b58:	10c2068c 	andi	r3,r2,2074
81122b5c:	1800071e 	bne	r3,zero,81122b7c <_fseeko_r+0xec>
81122b60:	10c1000c 	andi	r3,r2,1024
81122b64:	1800451e 	bne	r3,zero,81122c7c <_fseeko_r+0x1ec>
81122b68:	00e044b4 	movhi	r3,33042
81122b6c:	18d10104 	addi	r3,r3,17412
81122b70:	a0c0b726 	beq	r20,r3,81122e50 <_fseeko_r+0x3c0>
81122b74:	10820014 	ori	r2,r2,2048
81122b78:	8080030d 	sth	r2,12(r16)
81122b7c:	800b883a 	mov	r5,r16
81122b80:	8809883a 	mov	r4,r17
81122b84:	112c3940 	call	8112c394 <_fflush_r>
81122b88:	1027883a 	mov	r19,r2
81122b8c:	103fe01e 	bne	r2,zero,81122b10 <__reset+0xfb102b10>
81122b90:	81400717 	ldw	r5,28(r16)
81122b94:	900f883a 	mov	r7,r18
81122b98:	a80d883a 	mov	r6,r21
81122b9c:	8809883a 	mov	r4,r17
81122ba0:	a03ee83a 	callr	r20
81122ba4:	00ffffc4 	movi	r3,-1
81122ba8:	10ffd926 	beq	r2,r3,81122b10 <__reset+0xfb102b10>
81122bac:	81400c17 	ldw	r5,48(r16)
81122bb0:	28000526 	beq	r5,zero,81122bc8 <_fseeko_r+0x138>
81122bb4:	80801004 	addi	r2,r16,64
81122bb8:	28800226 	beq	r5,r2,81122bc4 <_fseeko_r+0x134>
81122bbc:	8809883a 	mov	r4,r17
81122bc0:	112cc280 	call	8112cc28 <_free_r>
81122bc4:	80000c15 	stw	zero,48(r16)
81122bc8:	8080030b 	ldhu	r2,12(r16)
81122bcc:	80c00417 	ldw	r3,16(r16)
81122bd0:	80000115 	stw	zero,4(r16)
81122bd4:	10bdf7cc 	andi	r2,r2,63455
81122bd8:	80c00015 	stw	r3,0(r16)
81122bdc:	8080030d 	sth	r2,12(r16)
81122be0:	01800204 	movi	r6,8
81122be4:	000b883a 	mov	r5,zero
81122be8:	81001704 	addi	r4,r16,92
81122bec:	1123b940 	call	81123b94 <memset>
81122bf0:	003fc806 	br	81122b14 <__reset+0xfb102b14>
81122bf4:	800b883a 	mov	r5,r16
81122bf8:	8809883a 	mov	r4,r17
81122bfc:	112c3940 	call	8112c394 <_fflush_r>
81122c00:	8080030b 	ldhu	r2,12(r16)
81122c04:	10c4000c 	andi	r3,r2,4096
81122c08:	18008726 	beq	r3,zero,81122e28 <_fseeko_r+0x398>
81122c0c:	84c01417 	ldw	r19,80(r16)
81122c10:	10c0010c 	andi	r3,r2,4
81122c14:	1800431e 	bne	r3,zero,81122d24 <_fseeko_r+0x294>
81122c18:	1080020c 	andi	r2,r2,8
81122c1c:	10008026 	beq	r2,zero,81122e20 <_fseeko_r+0x390>
81122c20:	80c00017 	ldw	r3,0(r16)
81122c24:	80800417 	ldw	r2,16(r16)
81122c28:	18000226 	beq	r3,zero,81122c34 <_fseeko_r+0x1a4>
81122c2c:	1887c83a 	sub	r3,r3,r2
81122c30:	98e7883a 	add	r19,r19,r3
81122c34:	aceb883a 	add	r21,r21,r19
81122c38:	05c00044 	movi	r23,1
81122c3c:	0025883a 	mov	r18,zero
81122c40:	003fc306 	br	81122b50 <__reset+0xfb102b50>
81122c44:	112c7900 	call	8112c790 <__sinit>
81122c48:	8080030b 	ldhu	r2,12(r16)
81122c4c:	00c04204 	movi	r3,264
81122c50:	1080420c 	andi	r2,r2,264
81122c54:	10ffa51e 	bne	r2,r3,81122aec <__reset+0xfb102aec>
81122c58:	800b883a 	mov	r5,r16
81122c5c:	8809883a 	mov	r4,r17
81122c60:	112c3940 	call	8112c394 <_fflush_r>
81122c64:	003fa106 	br	81122aec <__reset+0xfb102aec>
81122c68:	8080030b 	ldhu	r2,12(r16)
81122c6c:	00c10004 	movi	r3,1024
81122c70:	80c01315 	stw	r3,76(r16)
81122c74:	10c4b03a 	or	r2,r2,r3
81122c78:	8080030d 	sth	r2,12(r16)
81122c7c:	9000311e 	bne	r18,zero,81122d44 <_fseeko_r+0x2b4>
81122c80:	a82d883a 	mov	r22,r21
81122c84:	b800371e 	bne	r23,zero,81122d64 <_fseeko_r+0x2d4>
81122c88:	8080030b 	ldhu	r2,12(r16)
81122c8c:	1084000c 	andi	r2,r2,4096
81122c90:	10007f26 	beq	r2,zero,81122e90 <_fseeko_r+0x400>
81122c94:	80801417 	ldw	r2,80(r16)
81122c98:	81800117 	ldw	r6,4(r16)
81122c9c:	81400c17 	ldw	r5,48(r16)
81122ca0:	11a7c83a 	sub	r19,r2,r6
81122ca4:	28008226 	beq	r5,zero,81122eb0 <_fseeko_r+0x420>
81122ca8:	81c00f17 	ldw	r7,60(r16)
81122cac:	99e7c83a 	sub	r19,r19,r7
81122cb0:	81000e17 	ldw	r4,56(r16)
81122cb4:	80800417 	ldw	r2,16(r16)
81122cb8:	99a7883a 	add	r19,r19,r6
81122cbc:	2087c83a 	sub	r3,r4,r2
81122cc0:	98e7c83a 	sub	r19,r19,r3
81122cc4:	38c7883a 	add	r3,r7,r3
81122cc8:	b4c02b16 	blt	r22,r19,81122d78 <_fseeko_r+0x2e8>
81122ccc:	98c9883a 	add	r4,r19,r3
81122cd0:	b100292e 	bgeu	r22,r4,81122d78 <_fseeko_r+0x2e8>
81122cd4:	b4e7c83a 	sub	r19,r22,r19
81122cd8:	14c5883a 	add	r2,r2,r19
81122cdc:	1ce7c83a 	sub	r19,r3,r19
81122ce0:	80800015 	stw	r2,0(r16)
81122ce4:	84c00115 	stw	r19,4(r16)
81122ce8:	28000526 	beq	r5,zero,81122d00 <_fseeko_r+0x270>
81122cec:	80801004 	addi	r2,r16,64
81122cf0:	28800226 	beq	r5,r2,81122cfc <_fseeko_r+0x26c>
81122cf4:	8809883a 	mov	r4,r17
81122cf8:	112cc280 	call	8112cc28 <_free_r>
81122cfc:	80000c15 	stw	zero,48(r16)
81122d00:	8080030b 	ldhu	r2,12(r16)
81122d04:	01800204 	movi	r6,8
81122d08:	000b883a 	mov	r5,zero
81122d0c:	10bff7cc 	andi	r2,r2,65503
81122d10:	8080030d 	sth	r2,12(r16)
81122d14:	81001704 	addi	r4,r16,92
81122d18:	1123b940 	call	81123b94 <memset>
81122d1c:	0027883a 	mov	r19,zero
81122d20:	003f7c06 	br	81122b14 <__reset+0xfb102b14>
81122d24:	80c00117 	ldw	r3,4(r16)
81122d28:	80800c17 	ldw	r2,48(r16)
81122d2c:	98e7c83a 	sub	r19,r19,r3
81122d30:	10003b26 	beq	r2,zero,81122e20 <_fseeko_r+0x390>
81122d34:	80c00f17 	ldw	r3,60(r16)
81122d38:	80800417 	ldw	r2,16(r16)
81122d3c:	98e7c83a 	sub	r19,r19,r3
81122d40:	003fbc06 	br	81122c34 <__reset+0xfb102c34>
81122d44:	8140038f 	ldh	r5,14(r16)
81122d48:	d80d883a 	mov	r6,sp
81122d4c:	8809883a 	mov	r4,r17
81122d50:	1122ef80 	call	81122ef8 <_fstat_r>
81122d54:	103f891e 	bne	r2,zero,81122b7c <__reset+0xfb102b7c>
81122d58:	dd800417 	ldw	r22,16(sp)
81122d5c:	adad883a 	add	r22,r21,r22
81122d60:	b83fc926 	beq	r23,zero,81122c88 <__reset+0xfb102c88>
81122d64:	81400c17 	ldw	r5,48(r16)
81122d68:	81800117 	ldw	r6,4(r16)
81122d6c:	28005026 	beq	r5,zero,81122eb0 <_fseeko_r+0x420>
81122d70:	81c00f17 	ldw	r7,60(r16)
81122d74:	003fce06 	br	81122cb0 <__reset+0xfb102cb0>
81122d78:	84c01317 	ldw	r19,76(r16)
81122d7c:	81400717 	ldw	r5,28(r16)
81122d80:	000f883a 	mov	r7,zero
81122d84:	04e7c83a 	sub	r19,zero,r19
81122d88:	9da6703a 	and	r19,r19,r22
81122d8c:	980d883a 	mov	r6,r19
81122d90:	8809883a 	mov	r4,r17
81122d94:	a03ee83a 	callr	r20
81122d98:	00ffffc4 	movi	r3,-1
81122d9c:	10ff7726 	beq	r2,r3,81122b7c <__reset+0xfb102b7c>
81122da0:	80800417 	ldw	r2,16(r16)
81122da4:	81400c17 	ldw	r5,48(r16)
81122da8:	80000115 	stw	zero,4(r16)
81122dac:	80800015 	stw	r2,0(r16)
81122db0:	28000526 	beq	r5,zero,81122dc8 <_fseeko_r+0x338>
81122db4:	80801004 	addi	r2,r16,64
81122db8:	28800226 	beq	r5,r2,81122dc4 <_fseeko_r+0x334>
81122dbc:	8809883a 	mov	r4,r17
81122dc0:	112cc280 	call	8112cc28 <_free_r>
81122dc4:	80000c15 	stw	zero,48(r16)
81122dc8:	8080030b 	ldhu	r2,12(r16)
81122dcc:	b4e7c83a 	sub	r19,r22,r19
81122dd0:	10bff7cc 	andi	r2,r2,65503
81122dd4:	8080030d 	sth	r2,12(r16)
81122dd8:	98000b26 	beq	r19,zero,81122e08 <_fseeko_r+0x378>
81122ddc:	800b883a 	mov	r5,r16
81122de0:	8809883a 	mov	r4,r17
81122de4:	1123f940 	call	81123f94 <__srefill_r>
81122de8:	103f641e 	bne	r2,zero,81122b7c <__reset+0xfb102b7c>
81122dec:	80800117 	ldw	r2,4(r16)
81122df0:	14ff6236 	bltu	r2,r19,81122b7c <__reset+0xfb102b7c>
81122df4:	80c00017 	ldw	r3,0(r16)
81122df8:	14c5c83a 	sub	r2,r2,r19
81122dfc:	80800115 	stw	r2,4(r16)
81122e00:	1ce7883a 	add	r19,r3,r19
81122e04:	84c00015 	stw	r19,0(r16)
81122e08:	01800204 	movi	r6,8
81122e0c:	000b883a 	mov	r5,zero
81122e10:	81001704 	addi	r4,r16,92
81122e14:	1123b940 	call	81123b94 <memset>
81122e18:	0027883a 	mov	r19,zero
81122e1c:	003f3d06 	br	81122b14 <__reset+0xfb102b14>
81122e20:	80800417 	ldw	r2,16(r16)
81122e24:	003f8306 	br	81122c34 <__reset+0xfb102c34>
81122e28:	81400717 	ldw	r5,28(r16)
81122e2c:	900f883a 	mov	r7,r18
81122e30:	000d883a 	mov	r6,zero
81122e34:	8809883a 	mov	r4,r17
81122e38:	a03ee83a 	callr	r20
81122e3c:	1027883a 	mov	r19,r2
81122e40:	00bfffc4 	movi	r2,-1
81122e44:	98bf3226 	beq	r19,r2,81122b10 <__reset+0xfb102b10>
81122e48:	8080030b 	ldhu	r2,12(r16)
81122e4c:	003f7006 	br	81122c10 <__reset+0xfb102c10>
81122e50:	8140038f 	ldh	r5,14(r16)
81122e54:	283f4716 	blt	r5,zero,81122b74 <__reset+0xfb102b74>
81122e58:	d80d883a 	mov	r6,sp
81122e5c:	8809883a 	mov	r4,r17
81122e60:	1122ef80 	call	81122ef8 <_fstat_r>
81122e64:	1000041e 	bne	r2,zero,81122e78 <_fseeko_r+0x3e8>
81122e68:	d8800117 	ldw	r2,4(sp)
81122e6c:	00e00014 	movui	r3,32768
81122e70:	10bc000c 	andi	r2,r2,61440
81122e74:	10ff7c26 	beq	r2,r3,81122c68 <__reset+0xfb102c68>
81122e78:	8080030b 	ldhu	r2,12(r16)
81122e7c:	003f3d06 	br	81122b74 <__reset+0xfb102b74>
81122e80:	800b883a 	mov	r5,r16
81122e84:	8809883a 	mov	r4,r17
81122e88:	112306c0 	call	8112306c <__smakebuf_r>
81122e8c:	003f3106 	br	81122b54 <__reset+0xfb102b54>
81122e90:	81400717 	ldw	r5,28(r16)
81122e94:	01c00044 	movi	r7,1
81122e98:	000d883a 	mov	r6,zero
81122e9c:	8809883a 	mov	r4,r17
81122ea0:	a03ee83a 	callr	r20
81122ea4:	00ffffc4 	movi	r3,-1
81122ea8:	10ff7b1e 	bne	r2,r3,81122c98 <__reset+0xfb102c98>
81122eac:	003f3306 	br	81122b7c <__reset+0xfb102b7c>
81122eb0:	80c00017 	ldw	r3,0(r16)
81122eb4:	80800417 	ldw	r2,16(r16)
81122eb8:	000b883a 	mov	r5,zero
81122ebc:	1887c83a 	sub	r3,r3,r2
81122ec0:	98e7c83a 	sub	r19,r19,r3
81122ec4:	30c7883a 	add	r3,r6,r3
81122ec8:	003f7f06 	br	81122cc8 <__reset+0xfb102cc8>
81122ecc:	00800744 	movi	r2,29
81122ed0:	88800015 	stw	r2,0(r17)
81122ed4:	04ffffc4 	movi	r19,-1
81122ed8:	003f0e06 	br	81122b14 <__reset+0xfb102b14>

81122edc <fseeko>:
81122edc:	00a04574 	movhi	r2,33045
81122ee0:	10911304 	addi	r2,r2,17484
81122ee4:	300f883a 	mov	r7,r6
81122ee8:	280d883a 	mov	r6,r5
81122eec:	200b883a 	mov	r5,r4
81122ef0:	11000017 	ldw	r4,0(r2)
81122ef4:	1122a901 	jmpi	81122a90 <_fseeko_r>

81122ef8 <_fstat_r>:
81122ef8:	defffd04 	addi	sp,sp,-12
81122efc:	de00012e 	bgeu	sp,et,81122f04 <_fstat_r+0xc>
81122f00:	003b68fa 	trap	3
81122f04:	2805883a 	mov	r2,r5
81122f08:	dc000015 	stw	r16,0(sp)
81122f0c:	04204574 	movhi	r16,33045
81122f10:	dc400115 	stw	r17,4(sp)
81122f14:	84118604 	addi	r16,r16,17944
81122f18:	2023883a 	mov	r17,r4
81122f1c:	300b883a 	mov	r5,r6
81122f20:	1009883a 	mov	r4,r2
81122f24:	dfc00215 	stw	ra,8(sp)
81122f28:	80000015 	stw	zero,0(r16)
81122f2c:	11378a80 	call	811378a8 <fstat>
81122f30:	00ffffc4 	movi	r3,-1
81122f34:	10c00526 	beq	r2,r3,81122f4c <_fstat_r+0x54>
81122f38:	dfc00217 	ldw	ra,8(sp)
81122f3c:	dc400117 	ldw	r17,4(sp)
81122f40:	dc000017 	ldw	r16,0(sp)
81122f44:	dec00304 	addi	sp,sp,12
81122f48:	f800283a 	ret
81122f4c:	80c00017 	ldw	r3,0(r16)
81122f50:	183ff926 	beq	r3,zero,81122f38 <__reset+0xfb102f38>
81122f54:	88c00015 	stw	r3,0(r17)
81122f58:	003ff706 	br	81122f38 <__reset+0xfb102f38>

81122f5c <_fwrite_r>:
81122f5c:	defff504 	addi	sp,sp,-44
81122f60:	de00012e 	bgeu	sp,et,81122f68 <_fwrite_r+0xc>
81122f64:	003b68fa 	trap	3
81122f68:	dc800815 	stw	r18,32(sp)
81122f6c:	39a5383a 	mul	r18,r7,r6
81122f70:	d8800304 	addi	r2,sp,12
81122f74:	d8800015 	stw	r2,0(sp)
81122f78:	00800044 	movi	r2,1
81122f7c:	dcc00915 	stw	r19,36(sp)
81122f80:	dc400715 	stw	r17,28(sp)
81122f84:	dc000615 	stw	r16,24(sp)
81122f88:	d9400315 	stw	r5,12(sp)
81122f8c:	dfc00a15 	stw	ra,40(sp)
81122f90:	dc800415 	stw	r18,16(sp)
81122f94:	dc800215 	stw	r18,8(sp)
81122f98:	d8800115 	stw	r2,4(sp)
81122f9c:	3027883a 	mov	r19,r6
81122fa0:	3821883a 	mov	r16,r7
81122fa4:	2023883a 	mov	r17,r4
81122fa8:	d9400b17 	ldw	r5,44(sp)
81122fac:	20000226 	beq	r4,zero,81122fb8 <_fwrite_r+0x5c>
81122fb0:	20800e17 	ldw	r2,56(r4)
81122fb4:	10001a26 	beq	r2,zero,81123020 <_fwrite_r+0xc4>
81122fb8:	2880030b 	ldhu	r2,12(r5)
81122fbc:	10c8000c 	andi	r3,r2,8192
81122fc0:	1800061e 	bne	r3,zero,81122fdc <_fwrite_r+0x80>
81122fc4:	29001917 	ldw	r4,100(r5)
81122fc8:	00f7ffc4 	movi	r3,-8193
81122fcc:	10880014 	ori	r2,r2,8192
81122fd0:	20c6703a 	and	r3,r4,r3
81122fd4:	2880030d 	sth	r2,12(r5)
81122fd8:	28c01915 	stw	r3,100(r5)
81122fdc:	d80d883a 	mov	r6,sp
81122fe0:	8809883a 	mov	r4,r17
81122fe4:	112cf400 	call	8112cf40 <__sfvwrite_r>
81122fe8:	10000b26 	beq	r2,zero,81123018 <_fwrite_r+0xbc>
81122fec:	d9000217 	ldw	r4,8(sp)
81122ff0:	980b883a 	mov	r5,r19
81122ff4:	9109c83a 	sub	r4,r18,r4
81122ff8:	1135f340 	call	81135f34 <__udivsi3>
81122ffc:	dfc00a17 	ldw	ra,40(sp)
81123000:	dcc00917 	ldw	r19,36(sp)
81123004:	dc800817 	ldw	r18,32(sp)
81123008:	dc400717 	ldw	r17,28(sp)
8112300c:	dc000617 	ldw	r16,24(sp)
81123010:	dec00b04 	addi	sp,sp,44
81123014:	f800283a 	ret
81123018:	8005883a 	mov	r2,r16
8112301c:	003ff706 	br	81122ffc <__reset+0xfb102ffc>
81123020:	d9400515 	stw	r5,20(sp)
81123024:	112c7900 	call	8112c790 <__sinit>
81123028:	d9400517 	ldw	r5,20(sp)
8112302c:	003fe206 	br	81122fb8 <__reset+0xfb102fb8>

81123030 <fwrite>:
81123030:	defffe04 	addi	sp,sp,-8
81123034:	00a04574 	movhi	r2,33045
81123038:	de00012e 	bgeu	sp,et,81123040 <fwrite+0x10>
8112303c:	003b68fa 	trap	3
81123040:	10911304 	addi	r2,r2,17484
81123044:	d9c00015 	stw	r7,0(sp)
81123048:	300f883a 	mov	r7,r6
8112304c:	280d883a 	mov	r6,r5
81123050:	200b883a 	mov	r5,r4
81123054:	11000017 	ldw	r4,0(r2)
81123058:	dfc00115 	stw	ra,4(sp)
8112305c:	1122f5c0 	call	81122f5c <_fwrite_r>
81123060:	dfc00117 	ldw	ra,4(sp)
81123064:	dec00204 	addi	sp,sp,8
81123068:	f800283a 	ret

8112306c <__smakebuf_r>:
8112306c:	2880030b 	ldhu	r2,12(r5)
81123070:	10c0008c 	andi	r3,r2,2
81123074:	1800431e 	bne	r3,zero,81123184 <__smakebuf_r+0x118>
81123078:	deffec04 	addi	sp,sp,-80
8112307c:	de00012e 	bgeu	sp,et,81123084 <__smakebuf_r+0x18>
81123080:	003b68fa 	trap	3
81123084:	dc000f15 	stw	r16,60(sp)
81123088:	2821883a 	mov	r16,r5
8112308c:	2940038f 	ldh	r5,14(r5)
81123090:	dc401015 	stw	r17,64(sp)
81123094:	dfc01315 	stw	ra,76(sp)
81123098:	dcc01215 	stw	r19,72(sp)
8112309c:	dc801115 	stw	r18,68(sp)
811230a0:	2023883a 	mov	r17,r4
811230a4:	28001c16 	blt	r5,zero,81123118 <__smakebuf_r+0xac>
811230a8:	d80d883a 	mov	r6,sp
811230ac:	1122ef80 	call	81122ef8 <_fstat_r>
811230b0:	10001816 	blt	r2,zero,81123114 <__smakebuf_r+0xa8>
811230b4:	d8800117 	ldw	r2,4(sp)
811230b8:	00e00014 	movui	r3,32768
811230bc:	10bc000c 	andi	r2,r2,61440
811230c0:	14c80020 	cmpeqi	r19,r2,8192
811230c4:	10c03726 	beq	r2,r3,811231a4 <__smakebuf_r+0x138>
811230c8:	80c0030b 	ldhu	r3,12(r16)
811230cc:	18c20014 	ori	r3,r3,2048
811230d0:	80c0030d 	sth	r3,12(r16)
811230d4:	00c80004 	movi	r3,8192
811230d8:	10c0521e 	bne	r2,r3,81123224 <__smakebuf_r+0x1b8>
811230dc:	8140038f 	ldh	r5,14(r16)
811230e0:	8809883a 	mov	r4,r17
811230e4:	112d59c0 	call	8112d59c <_isatty_r>
811230e8:	10004c26 	beq	r2,zero,8112321c <__smakebuf_r+0x1b0>
811230ec:	8080030b 	ldhu	r2,12(r16)
811230f0:	80c010c4 	addi	r3,r16,67
811230f4:	80c00015 	stw	r3,0(r16)
811230f8:	10800054 	ori	r2,r2,1
811230fc:	8080030d 	sth	r2,12(r16)
81123100:	00800044 	movi	r2,1
81123104:	80c00415 	stw	r3,16(r16)
81123108:	80800515 	stw	r2,20(r16)
8112310c:	04810004 	movi	r18,1024
81123110:	00000706 	br	81123130 <__smakebuf_r+0xc4>
81123114:	8080030b 	ldhu	r2,12(r16)
81123118:	10c0200c 	andi	r3,r2,128
8112311c:	18001f1e 	bne	r3,zero,8112319c <__smakebuf_r+0x130>
81123120:	04810004 	movi	r18,1024
81123124:	10820014 	ori	r2,r2,2048
81123128:	8080030d 	sth	r2,12(r16)
8112312c:	0027883a 	mov	r19,zero
81123130:	900b883a 	mov	r5,r18
81123134:	8809883a 	mov	r4,r17
81123138:	11232300 	call	81123230 <_malloc_r>
8112313c:	10002c26 	beq	r2,zero,811231f0 <__smakebuf_r+0x184>
81123140:	80c0030b 	ldhu	r3,12(r16)
81123144:	012044f4 	movhi	r4,33043
81123148:	21310c04 	addi	r4,r4,-15312
8112314c:	89000f15 	stw	r4,60(r17)
81123150:	18c02014 	ori	r3,r3,128
81123154:	80c0030d 	sth	r3,12(r16)
81123158:	80800015 	stw	r2,0(r16)
8112315c:	80800415 	stw	r2,16(r16)
81123160:	84800515 	stw	r18,20(r16)
81123164:	98001a1e 	bne	r19,zero,811231d0 <__smakebuf_r+0x164>
81123168:	dfc01317 	ldw	ra,76(sp)
8112316c:	dcc01217 	ldw	r19,72(sp)
81123170:	dc801117 	ldw	r18,68(sp)
81123174:	dc401017 	ldw	r17,64(sp)
81123178:	dc000f17 	ldw	r16,60(sp)
8112317c:	dec01404 	addi	sp,sp,80
81123180:	f800283a 	ret
81123184:	288010c4 	addi	r2,r5,67
81123188:	28800015 	stw	r2,0(r5)
8112318c:	28800415 	stw	r2,16(r5)
81123190:	00800044 	movi	r2,1
81123194:	28800515 	stw	r2,20(r5)
81123198:	f800283a 	ret
8112319c:	04801004 	movi	r18,64
811231a0:	003fe006 	br	81123124 <__reset+0xfb103124>
811231a4:	81000a17 	ldw	r4,40(r16)
811231a8:	00e044b4 	movhi	r3,33042
811231ac:	18d10104 	addi	r3,r3,17412
811231b0:	20ffc51e 	bne	r4,r3,811230c8 <__reset+0xfb1030c8>
811231b4:	8080030b 	ldhu	r2,12(r16)
811231b8:	04810004 	movi	r18,1024
811231bc:	84801315 	stw	r18,76(r16)
811231c0:	1484b03a 	or	r2,r2,r18
811231c4:	8080030d 	sth	r2,12(r16)
811231c8:	0027883a 	mov	r19,zero
811231cc:	003fd806 	br	81123130 <__reset+0xfb103130>
811231d0:	8140038f 	ldh	r5,14(r16)
811231d4:	8809883a 	mov	r4,r17
811231d8:	112d59c0 	call	8112d59c <_isatty_r>
811231dc:	103fe226 	beq	r2,zero,81123168 <__reset+0xfb103168>
811231e0:	8080030b 	ldhu	r2,12(r16)
811231e4:	10800054 	ori	r2,r2,1
811231e8:	8080030d 	sth	r2,12(r16)
811231ec:	003fde06 	br	81123168 <__reset+0xfb103168>
811231f0:	8080030b 	ldhu	r2,12(r16)
811231f4:	10c0800c 	andi	r3,r2,512
811231f8:	183fdb1e 	bne	r3,zero,81123168 <__reset+0xfb103168>
811231fc:	10800094 	ori	r2,r2,2
81123200:	80c010c4 	addi	r3,r16,67
81123204:	8080030d 	sth	r2,12(r16)
81123208:	00800044 	movi	r2,1
8112320c:	80c00015 	stw	r3,0(r16)
81123210:	80c00415 	stw	r3,16(r16)
81123214:	80800515 	stw	r2,20(r16)
81123218:	003fd306 	br	81123168 <__reset+0xfb103168>
8112321c:	04810004 	movi	r18,1024
81123220:	003fc306 	br	81123130 <__reset+0xfb103130>
81123224:	0027883a 	mov	r19,zero
81123228:	04810004 	movi	r18,1024
8112322c:	003fc006 	br	81123130 <__reset+0xfb103130>

81123230 <_malloc_r>:
81123230:	defff504 	addi	sp,sp,-44
81123234:	de00012e 	bgeu	sp,et,8112323c <_malloc_r+0xc>
81123238:	003b68fa 	trap	3
8112323c:	288002c4 	addi	r2,r5,11
81123240:	dc800315 	stw	r18,12(sp)
81123244:	dfc00a15 	stw	ra,40(sp)
81123248:	df000915 	stw	fp,36(sp)
8112324c:	ddc00815 	stw	r23,32(sp)
81123250:	dd800715 	stw	r22,28(sp)
81123254:	dd400615 	stw	r21,24(sp)
81123258:	dd000515 	stw	r20,20(sp)
8112325c:	dcc00415 	stw	r19,16(sp)
81123260:	dc400215 	stw	r17,8(sp)
81123264:	dc000115 	stw	r16,4(sp)
81123268:	00c00584 	movi	r3,22
8112326c:	2025883a 	mov	r18,r4
81123270:	18807f2e 	bgeu	r3,r2,81123470 <_malloc_r+0x240>
81123274:	047ffe04 	movi	r17,-8
81123278:	1462703a 	and	r17,r2,r17
8112327c:	8800a316 	blt	r17,zero,8112350c <_malloc_r+0x2dc>
81123280:	8940a236 	bltu	r17,r5,8112350c <_malloc_r+0x2dc>
81123284:	11393f00 	call	811393f0 <__malloc_lock>
81123288:	00807dc4 	movi	r2,503
8112328c:	1441e92e 	bgeu	r2,r17,81123a34 <_malloc_r+0x804>
81123290:	8804d27a 	srli	r2,r17,9
81123294:	1000a126 	beq	r2,zero,8112351c <_malloc_r+0x2ec>
81123298:	00c00104 	movi	r3,4
8112329c:	18811e36 	bltu	r3,r2,81123718 <_malloc_r+0x4e8>
811232a0:	8804d1ba 	srli	r2,r17,6
811232a4:	12000e44 	addi	r8,r2,57
811232a8:	11c00e04 	addi	r7,r2,56
811232ac:	4209883a 	add	r4,r8,r8
811232b0:	04e04574 	movhi	r19,33045
811232b4:	2109883a 	add	r4,r4,r4
811232b8:	9ccad104 	addi	r19,r19,11076
811232bc:	2109883a 	add	r4,r4,r4
811232c0:	9909883a 	add	r4,r19,r4
811232c4:	24000117 	ldw	r16,4(r4)
811232c8:	213ffe04 	addi	r4,r4,-8
811232cc:	24009726 	beq	r4,r16,8112352c <_malloc_r+0x2fc>
811232d0:	80800117 	ldw	r2,4(r16)
811232d4:	01bfff04 	movi	r6,-4
811232d8:	014003c4 	movi	r5,15
811232dc:	1184703a 	and	r2,r2,r6
811232e0:	1447c83a 	sub	r3,r2,r17
811232e4:	28c00716 	blt	r5,r3,81123304 <_malloc_r+0xd4>
811232e8:	1800920e 	bge	r3,zero,81123534 <_malloc_r+0x304>
811232ec:	84000317 	ldw	r16,12(r16)
811232f0:	24008e26 	beq	r4,r16,8112352c <_malloc_r+0x2fc>
811232f4:	80800117 	ldw	r2,4(r16)
811232f8:	1184703a 	and	r2,r2,r6
811232fc:	1447c83a 	sub	r3,r2,r17
81123300:	28fff90e 	bge	r5,r3,811232e8 <__reset+0xfb1032e8>
81123304:	3809883a 	mov	r4,r7
81123308:	01a04574 	movhi	r6,33045
8112330c:	9c000417 	ldw	r16,16(r19)
81123310:	318ad104 	addi	r6,r6,11076
81123314:	32000204 	addi	r8,r6,8
81123318:	82013426 	beq	r16,r8,811237ec <_malloc_r+0x5bc>
8112331c:	80c00117 	ldw	r3,4(r16)
81123320:	00bfff04 	movi	r2,-4
81123324:	188e703a 	and	r7,r3,r2
81123328:	3c45c83a 	sub	r2,r7,r17
8112332c:	00c003c4 	movi	r3,15
81123330:	18811f16 	blt	r3,r2,811237b0 <_malloc_r+0x580>
81123334:	32000515 	stw	r8,20(r6)
81123338:	32000415 	stw	r8,16(r6)
8112333c:	10007f0e 	bge	r2,zero,8112353c <_malloc_r+0x30c>
81123340:	00807fc4 	movi	r2,511
81123344:	11c0fd36 	bltu	r2,r7,8112373c <_malloc_r+0x50c>
81123348:	3806d0fa 	srli	r3,r7,3
8112334c:	01c00044 	movi	r7,1
81123350:	30800117 	ldw	r2,4(r6)
81123354:	19400044 	addi	r5,r3,1
81123358:	294b883a 	add	r5,r5,r5
8112335c:	1807d0ba 	srai	r3,r3,2
81123360:	294b883a 	add	r5,r5,r5
81123364:	294b883a 	add	r5,r5,r5
81123368:	298b883a 	add	r5,r5,r6
8112336c:	38c6983a 	sll	r3,r7,r3
81123370:	29c00017 	ldw	r7,0(r5)
81123374:	2a7ffe04 	addi	r9,r5,-8
81123378:	1886b03a 	or	r3,r3,r2
8112337c:	82400315 	stw	r9,12(r16)
81123380:	81c00215 	stw	r7,8(r16)
81123384:	30c00115 	stw	r3,4(r6)
81123388:	2c000015 	stw	r16,0(r5)
8112338c:	3c000315 	stw	r16,12(r7)
81123390:	2005d0ba 	srai	r2,r4,2
81123394:	01400044 	movi	r5,1
81123398:	288a983a 	sll	r5,r5,r2
8112339c:	19406f36 	bltu	r3,r5,8112355c <_malloc_r+0x32c>
811233a0:	28c4703a 	and	r2,r5,r3
811233a4:	10000a1e 	bne	r2,zero,811233d0 <_malloc_r+0x1a0>
811233a8:	00bfff04 	movi	r2,-4
811233ac:	294b883a 	add	r5,r5,r5
811233b0:	2088703a 	and	r4,r4,r2
811233b4:	28c4703a 	and	r2,r5,r3
811233b8:	21000104 	addi	r4,r4,4
811233bc:	1000041e 	bne	r2,zero,811233d0 <_malloc_r+0x1a0>
811233c0:	294b883a 	add	r5,r5,r5
811233c4:	28c4703a 	and	r2,r5,r3
811233c8:	21000104 	addi	r4,r4,4
811233cc:	103ffc26 	beq	r2,zero,811233c0 <__reset+0xfb1033c0>
811233d0:	02bfff04 	movi	r10,-4
811233d4:	024003c4 	movi	r9,15
811233d8:	21800044 	addi	r6,r4,1
811233dc:	318d883a 	add	r6,r6,r6
811233e0:	318d883a 	add	r6,r6,r6
811233e4:	318d883a 	add	r6,r6,r6
811233e8:	998d883a 	add	r6,r19,r6
811233ec:	333ffe04 	addi	r12,r6,-8
811233f0:	2017883a 	mov	r11,r4
811233f4:	31800104 	addi	r6,r6,4
811233f8:	34000017 	ldw	r16,0(r6)
811233fc:	31fffd04 	addi	r7,r6,-12
81123400:	81c0041e 	bne	r16,r7,81123414 <_malloc_r+0x1e4>
81123404:	0000fb06 	br	811237f4 <_malloc_r+0x5c4>
81123408:	1801030e 	bge	r3,zero,81123818 <_malloc_r+0x5e8>
8112340c:	84000317 	ldw	r16,12(r16)
81123410:	81c0f826 	beq	r16,r7,811237f4 <_malloc_r+0x5c4>
81123414:	80800117 	ldw	r2,4(r16)
81123418:	1284703a 	and	r2,r2,r10
8112341c:	1447c83a 	sub	r3,r2,r17
81123420:	48fff90e 	bge	r9,r3,81123408 <__reset+0xfb103408>
81123424:	80800317 	ldw	r2,12(r16)
81123428:	81000217 	ldw	r4,8(r16)
8112342c:	89400054 	ori	r5,r17,1
81123430:	81400115 	stw	r5,4(r16)
81123434:	20800315 	stw	r2,12(r4)
81123438:	11000215 	stw	r4,8(r2)
8112343c:	8463883a 	add	r17,r16,r17
81123440:	9c400515 	stw	r17,20(r19)
81123444:	9c400415 	stw	r17,16(r19)
81123448:	18800054 	ori	r2,r3,1
8112344c:	88800115 	stw	r2,4(r17)
81123450:	8a000315 	stw	r8,12(r17)
81123454:	8a000215 	stw	r8,8(r17)
81123458:	88e3883a 	add	r17,r17,r3
8112345c:	88c00015 	stw	r3,0(r17)
81123460:	9009883a 	mov	r4,r18
81123464:	11395180 	call	81139518 <__malloc_unlock>
81123468:	80800204 	addi	r2,r16,8
8112346c:	00001b06 	br	811234dc <_malloc_r+0x2ac>
81123470:	04400404 	movi	r17,16
81123474:	89402536 	bltu	r17,r5,8112350c <_malloc_r+0x2dc>
81123478:	11393f00 	call	811393f0 <__malloc_lock>
8112347c:	00800184 	movi	r2,6
81123480:	01000084 	movi	r4,2
81123484:	04e04574 	movhi	r19,33045
81123488:	1085883a 	add	r2,r2,r2
8112348c:	9ccad104 	addi	r19,r19,11076
81123490:	1085883a 	add	r2,r2,r2
81123494:	9885883a 	add	r2,r19,r2
81123498:	14000117 	ldw	r16,4(r2)
8112349c:	10fffe04 	addi	r3,r2,-8
811234a0:	80c0d926 	beq	r16,r3,81123808 <_malloc_r+0x5d8>
811234a4:	80c00117 	ldw	r3,4(r16)
811234a8:	81000317 	ldw	r4,12(r16)
811234ac:	00bfff04 	movi	r2,-4
811234b0:	1884703a 	and	r2,r3,r2
811234b4:	81400217 	ldw	r5,8(r16)
811234b8:	8085883a 	add	r2,r16,r2
811234bc:	10c00117 	ldw	r3,4(r2)
811234c0:	29000315 	stw	r4,12(r5)
811234c4:	21400215 	stw	r5,8(r4)
811234c8:	18c00054 	ori	r3,r3,1
811234cc:	10c00115 	stw	r3,4(r2)
811234d0:	9009883a 	mov	r4,r18
811234d4:	11395180 	call	81139518 <__malloc_unlock>
811234d8:	80800204 	addi	r2,r16,8
811234dc:	dfc00a17 	ldw	ra,40(sp)
811234e0:	df000917 	ldw	fp,36(sp)
811234e4:	ddc00817 	ldw	r23,32(sp)
811234e8:	dd800717 	ldw	r22,28(sp)
811234ec:	dd400617 	ldw	r21,24(sp)
811234f0:	dd000517 	ldw	r20,20(sp)
811234f4:	dcc00417 	ldw	r19,16(sp)
811234f8:	dc800317 	ldw	r18,12(sp)
811234fc:	dc400217 	ldw	r17,8(sp)
81123500:	dc000117 	ldw	r16,4(sp)
81123504:	dec00b04 	addi	sp,sp,44
81123508:	f800283a 	ret
8112350c:	00800304 	movi	r2,12
81123510:	90800015 	stw	r2,0(r18)
81123514:	0005883a 	mov	r2,zero
81123518:	003ff006 	br	811234dc <__reset+0xfb1034dc>
8112351c:	01002004 	movi	r4,128
81123520:	02001004 	movi	r8,64
81123524:	01c00fc4 	movi	r7,63
81123528:	003f6106 	br	811232b0 <__reset+0xfb1032b0>
8112352c:	4009883a 	mov	r4,r8
81123530:	003f7506 	br	81123308 <__reset+0xfb103308>
81123534:	81000317 	ldw	r4,12(r16)
81123538:	003fde06 	br	811234b4 <__reset+0xfb1034b4>
8112353c:	81c5883a 	add	r2,r16,r7
81123540:	11400117 	ldw	r5,4(r2)
81123544:	9009883a 	mov	r4,r18
81123548:	29400054 	ori	r5,r5,1
8112354c:	11400115 	stw	r5,4(r2)
81123550:	11395180 	call	81139518 <__malloc_unlock>
81123554:	80800204 	addi	r2,r16,8
81123558:	003fe006 	br	811234dc <__reset+0xfb1034dc>
8112355c:	9c000217 	ldw	r16,8(r19)
81123560:	00bfff04 	movi	r2,-4
81123564:	85800117 	ldw	r22,4(r16)
81123568:	b0ac703a 	and	r22,r22,r2
8112356c:	b4400336 	bltu	r22,r17,8112357c <_malloc_r+0x34c>
81123570:	b445c83a 	sub	r2,r22,r17
81123574:	00c003c4 	movi	r3,15
81123578:	18805d16 	blt	r3,r2,811236f0 <_malloc_r+0x4c0>
8112357c:	05e04574 	movhi	r23,33045
81123580:	00a04574 	movhi	r2,33045
81123584:	10918904 	addi	r2,r2,17956
81123588:	bdd11404 	addi	r23,r23,17488
8112358c:	15400017 	ldw	r21,0(r2)
81123590:	b8c00017 	ldw	r3,0(r23)
81123594:	00bfffc4 	movi	r2,-1
81123598:	858d883a 	add	r6,r16,r22
8112359c:	8d6b883a 	add	r21,r17,r21
811235a0:	1880ea26 	beq	r3,r2,8112394c <_malloc_r+0x71c>
811235a4:	ad4403c4 	addi	r21,r21,4111
811235a8:	00bc0004 	movi	r2,-4096
811235ac:	a8aa703a 	and	r21,r21,r2
811235b0:	a80b883a 	mov	r5,r21
811235b4:	9009883a 	mov	r4,r18
811235b8:	d9800015 	stw	r6,0(sp)
811235bc:	11241700 	call	81124170 <_sbrk_r>
811235c0:	1029883a 	mov	r20,r2
811235c4:	00bfffc4 	movi	r2,-1
811235c8:	d9800017 	ldw	r6,0(sp)
811235cc:	a080e826 	beq	r20,r2,81123970 <_malloc_r+0x740>
811235d0:	a180a636 	bltu	r20,r6,8112386c <_malloc_r+0x63c>
811235d4:	07204574 	movhi	fp,33045
811235d8:	e7121604 	addi	fp,fp,18520
811235dc:	e0800017 	ldw	r2,0(fp)
811235e0:	a887883a 	add	r3,r21,r2
811235e4:	e0c00015 	stw	r3,0(fp)
811235e8:	3500e626 	beq	r6,r20,81123984 <_malloc_r+0x754>
811235ec:	b9000017 	ldw	r4,0(r23)
811235f0:	00bfffc4 	movi	r2,-1
811235f4:	2080ee26 	beq	r4,r2,811239b0 <_malloc_r+0x780>
811235f8:	a185c83a 	sub	r2,r20,r6
811235fc:	10c5883a 	add	r2,r2,r3
81123600:	e0800015 	stw	r2,0(fp)
81123604:	a0c001cc 	andi	r3,r20,7
81123608:	1800bc26 	beq	r3,zero,811238fc <_malloc_r+0x6cc>
8112360c:	a0e9c83a 	sub	r20,r20,r3
81123610:	00840204 	movi	r2,4104
81123614:	a5000204 	addi	r20,r20,8
81123618:	10c7c83a 	sub	r3,r2,r3
8112361c:	a545883a 	add	r2,r20,r21
81123620:	1083ffcc 	andi	r2,r2,4095
81123624:	18abc83a 	sub	r21,r3,r2
81123628:	a80b883a 	mov	r5,r21
8112362c:	9009883a 	mov	r4,r18
81123630:	11241700 	call	81124170 <_sbrk_r>
81123634:	00ffffc4 	movi	r3,-1
81123638:	10c0e126 	beq	r2,r3,811239c0 <_malloc_r+0x790>
8112363c:	1505c83a 	sub	r2,r2,r20
81123640:	1545883a 	add	r2,r2,r21
81123644:	10800054 	ori	r2,r2,1
81123648:	e0c00017 	ldw	r3,0(fp)
8112364c:	9d000215 	stw	r20,8(r19)
81123650:	a0800115 	stw	r2,4(r20)
81123654:	a8c7883a 	add	r3,r21,r3
81123658:	e0c00015 	stw	r3,0(fp)
8112365c:	84c00e26 	beq	r16,r19,81123698 <_malloc_r+0x468>
81123660:	018003c4 	movi	r6,15
81123664:	3580a72e 	bgeu	r6,r22,81123904 <_malloc_r+0x6d4>
81123668:	81400117 	ldw	r5,4(r16)
8112366c:	013ffe04 	movi	r4,-8
81123670:	b0bffd04 	addi	r2,r22,-12
81123674:	1104703a 	and	r2,r2,r4
81123678:	2900004c 	andi	r4,r5,1
8112367c:	2088b03a 	or	r4,r4,r2
81123680:	81000115 	stw	r4,4(r16)
81123684:	01400144 	movi	r5,5
81123688:	8089883a 	add	r4,r16,r2
8112368c:	21400115 	stw	r5,4(r4)
81123690:	21400215 	stw	r5,8(r4)
81123694:	3080cd36 	bltu	r6,r2,811239cc <_malloc_r+0x79c>
81123698:	00a04574 	movhi	r2,33045
8112369c:	10918804 	addi	r2,r2,17952
811236a0:	11000017 	ldw	r4,0(r2)
811236a4:	20c0012e 	bgeu	r4,r3,811236ac <_malloc_r+0x47c>
811236a8:	10c00015 	stw	r3,0(r2)
811236ac:	00a04574 	movhi	r2,33045
811236b0:	10918704 	addi	r2,r2,17948
811236b4:	11000017 	ldw	r4,0(r2)
811236b8:	9c000217 	ldw	r16,8(r19)
811236bc:	20c0012e 	bgeu	r4,r3,811236c4 <_malloc_r+0x494>
811236c0:	10c00015 	stw	r3,0(r2)
811236c4:	80c00117 	ldw	r3,4(r16)
811236c8:	00bfff04 	movi	r2,-4
811236cc:	1886703a 	and	r3,r3,r2
811236d0:	1c45c83a 	sub	r2,r3,r17
811236d4:	1c400236 	bltu	r3,r17,811236e0 <_malloc_r+0x4b0>
811236d8:	00c003c4 	movi	r3,15
811236dc:	18800416 	blt	r3,r2,811236f0 <_malloc_r+0x4c0>
811236e0:	9009883a 	mov	r4,r18
811236e4:	11395180 	call	81139518 <__malloc_unlock>
811236e8:	0005883a 	mov	r2,zero
811236ec:	003f7b06 	br	811234dc <__reset+0xfb1034dc>
811236f0:	88c00054 	ori	r3,r17,1
811236f4:	80c00115 	stw	r3,4(r16)
811236f8:	8463883a 	add	r17,r16,r17
811236fc:	10800054 	ori	r2,r2,1
81123700:	9c400215 	stw	r17,8(r19)
81123704:	88800115 	stw	r2,4(r17)
81123708:	9009883a 	mov	r4,r18
8112370c:	11395180 	call	81139518 <__malloc_unlock>
81123710:	80800204 	addi	r2,r16,8
81123714:	003f7106 	br	811234dc <__reset+0xfb1034dc>
81123718:	00c00504 	movi	r3,20
8112371c:	18804a2e 	bgeu	r3,r2,81123848 <_malloc_r+0x618>
81123720:	00c01504 	movi	r3,84
81123724:	18806e36 	bltu	r3,r2,811238e0 <_malloc_r+0x6b0>
81123728:	8804d33a 	srli	r2,r17,12
8112372c:	12001bc4 	addi	r8,r2,111
81123730:	11c01b84 	addi	r7,r2,110
81123734:	4209883a 	add	r4,r8,r8
81123738:	003edd06 	br	811232b0 <__reset+0xfb1032b0>
8112373c:	3804d27a 	srli	r2,r7,9
81123740:	00c00104 	movi	r3,4
81123744:	1880442e 	bgeu	r3,r2,81123858 <_malloc_r+0x628>
81123748:	00c00504 	movi	r3,20
8112374c:	18808136 	bltu	r3,r2,81123954 <_malloc_r+0x724>
81123750:	11401704 	addi	r5,r2,92
81123754:	10c016c4 	addi	r3,r2,91
81123758:	294b883a 	add	r5,r5,r5
8112375c:	294b883a 	add	r5,r5,r5
81123760:	294b883a 	add	r5,r5,r5
81123764:	994b883a 	add	r5,r19,r5
81123768:	28800017 	ldw	r2,0(r5)
8112376c:	01a04574 	movhi	r6,33045
81123770:	297ffe04 	addi	r5,r5,-8
81123774:	318ad104 	addi	r6,r6,11076
81123778:	28806526 	beq	r5,r2,81123910 <_malloc_r+0x6e0>
8112377c:	01bfff04 	movi	r6,-4
81123780:	10c00117 	ldw	r3,4(r2)
81123784:	1986703a 	and	r3,r3,r6
81123788:	38c0022e 	bgeu	r7,r3,81123794 <_malloc_r+0x564>
8112378c:	10800217 	ldw	r2,8(r2)
81123790:	28bffb1e 	bne	r5,r2,81123780 <__reset+0xfb103780>
81123794:	11400317 	ldw	r5,12(r2)
81123798:	98c00117 	ldw	r3,4(r19)
8112379c:	81400315 	stw	r5,12(r16)
811237a0:	80800215 	stw	r2,8(r16)
811237a4:	2c000215 	stw	r16,8(r5)
811237a8:	14000315 	stw	r16,12(r2)
811237ac:	003ef806 	br	81123390 <__reset+0xfb103390>
811237b0:	88c00054 	ori	r3,r17,1
811237b4:	80c00115 	stw	r3,4(r16)
811237b8:	8463883a 	add	r17,r16,r17
811237bc:	34400515 	stw	r17,20(r6)
811237c0:	34400415 	stw	r17,16(r6)
811237c4:	10c00054 	ori	r3,r2,1
811237c8:	8a000315 	stw	r8,12(r17)
811237cc:	8a000215 	stw	r8,8(r17)
811237d0:	88c00115 	stw	r3,4(r17)
811237d4:	88a3883a 	add	r17,r17,r2
811237d8:	88800015 	stw	r2,0(r17)
811237dc:	9009883a 	mov	r4,r18
811237e0:	11395180 	call	81139518 <__malloc_unlock>
811237e4:	80800204 	addi	r2,r16,8
811237e8:	003f3c06 	br	811234dc <__reset+0xfb1034dc>
811237ec:	30c00117 	ldw	r3,4(r6)
811237f0:	003ee706 	br	81123390 <__reset+0xfb103390>
811237f4:	5ac00044 	addi	r11,r11,1
811237f8:	588000cc 	andi	r2,r11,3
811237fc:	31800204 	addi	r6,r6,8
81123800:	103efd1e 	bne	r2,zero,811233f8 <__reset+0xfb1033f8>
81123804:	00002406 	br	81123898 <_malloc_r+0x668>
81123808:	14000317 	ldw	r16,12(r2)
8112380c:	143f251e 	bne	r2,r16,811234a4 <__reset+0xfb1034a4>
81123810:	21000084 	addi	r4,r4,2
81123814:	003ebc06 	br	81123308 <__reset+0xfb103308>
81123818:	8085883a 	add	r2,r16,r2
8112381c:	10c00117 	ldw	r3,4(r2)
81123820:	81000317 	ldw	r4,12(r16)
81123824:	81400217 	ldw	r5,8(r16)
81123828:	18c00054 	ori	r3,r3,1
8112382c:	10c00115 	stw	r3,4(r2)
81123830:	29000315 	stw	r4,12(r5)
81123834:	21400215 	stw	r5,8(r4)
81123838:	9009883a 	mov	r4,r18
8112383c:	11395180 	call	81139518 <__malloc_unlock>
81123840:	80800204 	addi	r2,r16,8
81123844:	003f2506 	br	811234dc <__reset+0xfb1034dc>
81123848:	12001704 	addi	r8,r2,92
8112384c:	11c016c4 	addi	r7,r2,91
81123850:	4209883a 	add	r4,r8,r8
81123854:	003e9606 	br	811232b0 <__reset+0xfb1032b0>
81123858:	3804d1ba 	srli	r2,r7,6
8112385c:	11400e44 	addi	r5,r2,57
81123860:	10c00e04 	addi	r3,r2,56
81123864:	294b883a 	add	r5,r5,r5
81123868:	003fbc06 	br	8112375c <__reset+0xfb10375c>
8112386c:	84ff5926 	beq	r16,r19,811235d4 <__reset+0xfb1035d4>
81123870:	00a04574 	movhi	r2,33045
81123874:	108ad104 	addi	r2,r2,11076
81123878:	14000217 	ldw	r16,8(r2)
8112387c:	00bfff04 	movi	r2,-4
81123880:	80c00117 	ldw	r3,4(r16)
81123884:	1886703a 	and	r3,r3,r2
81123888:	003f9106 	br	811236d0 <__reset+0xfb1036d0>
8112388c:	60800217 	ldw	r2,8(r12)
81123890:	213fffc4 	addi	r4,r4,-1
81123894:	1300651e 	bne	r2,r12,81123a2c <_malloc_r+0x7fc>
81123898:	208000cc 	andi	r2,r4,3
8112389c:	633ffe04 	addi	r12,r12,-8
811238a0:	103ffa1e 	bne	r2,zero,8112388c <__reset+0xfb10388c>
811238a4:	98800117 	ldw	r2,4(r19)
811238a8:	0146303a 	nor	r3,zero,r5
811238ac:	1884703a 	and	r2,r3,r2
811238b0:	98800115 	stw	r2,4(r19)
811238b4:	294b883a 	add	r5,r5,r5
811238b8:	117f2836 	bltu	r2,r5,8112355c <__reset+0xfb10355c>
811238bc:	283f2726 	beq	r5,zero,8112355c <__reset+0xfb10355c>
811238c0:	2886703a 	and	r3,r5,r2
811238c4:	5809883a 	mov	r4,r11
811238c8:	183ec31e 	bne	r3,zero,811233d8 <__reset+0xfb1033d8>
811238cc:	294b883a 	add	r5,r5,r5
811238d0:	2886703a 	and	r3,r5,r2
811238d4:	21000104 	addi	r4,r4,4
811238d8:	183ffc26 	beq	r3,zero,811238cc <__reset+0xfb1038cc>
811238dc:	003ebe06 	br	811233d8 <__reset+0xfb1033d8>
811238e0:	00c05504 	movi	r3,340
811238e4:	18801236 	bltu	r3,r2,81123930 <_malloc_r+0x700>
811238e8:	8804d3fa 	srli	r2,r17,15
811238ec:	12001e04 	addi	r8,r2,120
811238f0:	11c01dc4 	addi	r7,r2,119
811238f4:	4209883a 	add	r4,r8,r8
811238f8:	003e6d06 	br	811232b0 <__reset+0xfb1032b0>
811238fc:	00c40004 	movi	r3,4096
81123900:	003f4606 	br	8112361c <__reset+0xfb10361c>
81123904:	00800044 	movi	r2,1
81123908:	a0800115 	stw	r2,4(r20)
8112390c:	003f7406 	br	811236e0 <__reset+0xfb1036e0>
81123910:	1805d0ba 	srai	r2,r3,2
81123914:	01c00044 	movi	r7,1
81123918:	30c00117 	ldw	r3,4(r6)
8112391c:	388e983a 	sll	r7,r7,r2
81123920:	2805883a 	mov	r2,r5
81123924:	38c6b03a 	or	r3,r7,r3
81123928:	30c00115 	stw	r3,4(r6)
8112392c:	003f9b06 	br	8112379c <__reset+0xfb10379c>
81123930:	00c15504 	movi	r3,1364
81123934:	18801a36 	bltu	r3,r2,811239a0 <_malloc_r+0x770>
81123938:	8804d4ba 	srli	r2,r17,18
8112393c:	12001f44 	addi	r8,r2,125
81123940:	11c01f04 	addi	r7,r2,124
81123944:	4209883a 	add	r4,r8,r8
81123948:	003e5906 	br	811232b0 <__reset+0xfb1032b0>
8112394c:	ad400404 	addi	r21,r21,16
81123950:	003f1706 	br	811235b0 <__reset+0xfb1035b0>
81123954:	00c01504 	movi	r3,84
81123958:	18802336 	bltu	r3,r2,811239e8 <_malloc_r+0x7b8>
8112395c:	3804d33a 	srli	r2,r7,12
81123960:	11401bc4 	addi	r5,r2,111
81123964:	10c01b84 	addi	r3,r2,110
81123968:	294b883a 	add	r5,r5,r5
8112396c:	003f7b06 	br	8112375c <__reset+0xfb10375c>
81123970:	9c000217 	ldw	r16,8(r19)
81123974:	00bfff04 	movi	r2,-4
81123978:	80c00117 	ldw	r3,4(r16)
8112397c:	1886703a 	and	r3,r3,r2
81123980:	003f5306 	br	811236d0 <__reset+0xfb1036d0>
81123984:	3083ffcc 	andi	r2,r6,4095
81123988:	103f181e 	bne	r2,zero,811235ec <__reset+0xfb1035ec>
8112398c:	99000217 	ldw	r4,8(r19)
81123990:	b545883a 	add	r2,r22,r21
81123994:	10800054 	ori	r2,r2,1
81123998:	20800115 	stw	r2,4(r4)
8112399c:	003f3e06 	br	81123698 <__reset+0xfb103698>
811239a0:	01003f84 	movi	r4,254
811239a4:	02001fc4 	movi	r8,127
811239a8:	01c01f84 	movi	r7,126
811239ac:	003e4006 	br	811232b0 <__reset+0xfb1032b0>
811239b0:	00a04574 	movhi	r2,33045
811239b4:	10911404 	addi	r2,r2,17488
811239b8:	15000015 	stw	r20,0(r2)
811239bc:	003f1106 	br	81123604 <__reset+0xfb103604>
811239c0:	00800044 	movi	r2,1
811239c4:	002b883a 	mov	r21,zero
811239c8:	003f1f06 	br	81123648 <__reset+0xfb103648>
811239cc:	81400204 	addi	r5,r16,8
811239d0:	9009883a 	mov	r4,r18
811239d4:	112cc280 	call	8112cc28 <_free_r>
811239d8:	00a04574 	movhi	r2,33045
811239dc:	10921604 	addi	r2,r2,18520
811239e0:	10c00017 	ldw	r3,0(r2)
811239e4:	003f2c06 	br	81123698 <__reset+0xfb103698>
811239e8:	00c05504 	movi	r3,340
811239ec:	18800536 	bltu	r3,r2,81123a04 <_malloc_r+0x7d4>
811239f0:	3804d3fa 	srli	r2,r7,15
811239f4:	11401e04 	addi	r5,r2,120
811239f8:	10c01dc4 	addi	r3,r2,119
811239fc:	294b883a 	add	r5,r5,r5
81123a00:	003f5606 	br	8112375c <__reset+0xfb10375c>
81123a04:	00c15504 	movi	r3,1364
81123a08:	18800536 	bltu	r3,r2,81123a20 <_malloc_r+0x7f0>
81123a0c:	3804d4ba 	srli	r2,r7,18
81123a10:	11401f44 	addi	r5,r2,125
81123a14:	10c01f04 	addi	r3,r2,124
81123a18:	294b883a 	add	r5,r5,r5
81123a1c:	003f4f06 	br	8112375c <__reset+0xfb10375c>
81123a20:	01403f84 	movi	r5,254
81123a24:	00c01f84 	movi	r3,126
81123a28:	003f4c06 	br	8112375c <__reset+0xfb10375c>
81123a2c:	98800117 	ldw	r2,4(r19)
81123a30:	003fa006 	br	811238b4 <__reset+0xfb1038b4>
81123a34:	8808d0fa 	srli	r4,r17,3
81123a38:	20800044 	addi	r2,r4,1
81123a3c:	1085883a 	add	r2,r2,r2
81123a40:	003e9006 	br	81123484 <__reset+0xfb103484>

81123a44 <memcpy>:
81123a44:	defffd04 	addi	sp,sp,-12
81123a48:	de00012e 	bgeu	sp,et,81123a50 <memcpy+0xc>
81123a4c:	003b68fa 	trap	3
81123a50:	00c003c4 	movi	r3,15
81123a54:	dfc00215 	stw	ra,8(sp)
81123a58:	dc400115 	stw	r17,4(sp)
81123a5c:	dc000015 	stw	r16,0(sp)
81123a60:	2005883a 	mov	r2,r4
81123a64:	1980452e 	bgeu	r3,r6,81123b7c <memcpy+0x138>
81123a68:	2906b03a 	or	r3,r5,r4
81123a6c:	18c000cc 	andi	r3,r3,3
81123a70:	1800441e 	bne	r3,zero,81123b84 <memcpy+0x140>
81123a74:	347ffc04 	addi	r17,r6,-16
81123a78:	8822d13a 	srli	r17,r17,4
81123a7c:	28c00104 	addi	r3,r5,4
81123a80:	23400104 	addi	r13,r4,4
81123a84:	8820913a 	slli	r16,r17,4
81123a88:	2b000204 	addi	r12,r5,8
81123a8c:	22c00204 	addi	r11,r4,8
81123a90:	84000504 	addi	r16,r16,20
81123a94:	2a800304 	addi	r10,r5,12
81123a98:	22400304 	addi	r9,r4,12
81123a9c:	2c21883a 	add	r16,r5,r16
81123aa0:	2811883a 	mov	r8,r5
81123aa4:	200f883a 	mov	r7,r4
81123aa8:	41000017 	ldw	r4,0(r8)
81123aac:	1fc00017 	ldw	ra,0(r3)
81123ab0:	63c00017 	ldw	r15,0(r12)
81123ab4:	39000015 	stw	r4,0(r7)
81123ab8:	53800017 	ldw	r14,0(r10)
81123abc:	6fc00015 	stw	ra,0(r13)
81123ac0:	5bc00015 	stw	r15,0(r11)
81123ac4:	4b800015 	stw	r14,0(r9)
81123ac8:	18c00404 	addi	r3,r3,16
81123acc:	39c00404 	addi	r7,r7,16
81123ad0:	42000404 	addi	r8,r8,16
81123ad4:	6b400404 	addi	r13,r13,16
81123ad8:	63000404 	addi	r12,r12,16
81123adc:	5ac00404 	addi	r11,r11,16
81123ae0:	52800404 	addi	r10,r10,16
81123ae4:	4a400404 	addi	r9,r9,16
81123ae8:	1c3fef1e 	bne	r3,r16,81123aa8 <__reset+0xfb103aa8>
81123aec:	89c00044 	addi	r7,r17,1
81123af0:	380e913a 	slli	r7,r7,4
81123af4:	310003cc 	andi	r4,r6,15
81123af8:	02c000c4 	movi	r11,3
81123afc:	11c7883a 	add	r3,r2,r7
81123b00:	29cb883a 	add	r5,r5,r7
81123b04:	5900212e 	bgeu	r11,r4,81123b8c <memcpy+0x148>
81123b08:	1813883a 	mov	r9,r3
81123b0c:	2811883a 	mov	r8,r5
81123b10:	200f883a 	mov	r7,r4
81123b14:	42800017 	ldw	r10,0(r8)
81123b18:	4a400104 	addi	r9,r9,4
81123b1c:	39ffff04 	addi	r7,r7,-4
81123b20:	4abfff15 	stw	r10,-4(r9)
81123b24:	42000104 	addi	r8,r8,4
81123b28:	59fffa36 	bltu	r11,r7,81123b14 <__reset+0xfb103b14>
81123b2c:	213fff04 	addi	r4,r4,-4
81123b30:	2008d0ba 	srli	r4,r4,2
81123b34:	318000cc 	andi	r6,r6,3
81123b38:	21000044 	addi	r4,r4,1
81123b3c:	2109883a 	add	r4,r4,r4
81123b40:	2109883a 	add	r4,r4,r4
81123b44:	1907883a 	add	r3,r3,r4
81123b48:	290b883a 	add	r5,r5,r4
81123b4c:	30000626 	beq	r6,zero,81123b68 <memcpy+0x124>
81123b50:	198d883a 	add	r6,r3,r6
81123b54:	29c00003 	ldbu	r7,0(r5)
81123b58:	18c00044 	addi	r3,r3,1
81123b5c:	29400044 	addi	r5,r5,1
81123b60:	19ffffc5 	stb	r7,-1(r3)
81123b64:	19bffb1e 	bne	r3,r6,81123b54 <__reset+0xfb103b54>
81123b68:	dfc00217 	ldw	ra,8(sp)
81123b6c:	dc400117 	ldw	r17,4(sp)
81123b70:	dc000017 	ldw	r16,0(sp)
81123b74:	dec00304 	addi	sp,sp,12
81123b78:	f800283a 	ret
81123b7c:	2007883a 	mov	r3,r4
81123b80:	003ff206 	br	81123b4c <__reset+0xfb103b4c>
81123b84:	2007883a 	mov	r3,r4
81123b88:	003ff106 	br	81123b50 <__reset+0xfb103b50>
81123b8c:	200d883a 	mov	r6,r4
81123b90:	003fee06 	br	81123b4c <__reset+0xfb103b4c>

81123b94 <memset>:
81123b94:	20c000cc 	andi	r3,r4,3
81123b98:	2005883a 	mov	r2,r4
81123b9c:	18004426 	beq	r3,zero,81123cb0 <memset+0x11c>
81123ba0:	31ffffc4 	addi	r7,r6,-1
81123ba4:	30004026 	beq	r6,zero,81123ca8 <memset+0x114>
81123ba8:	2813883a 	mov	r9,r5
81123bac:	200d883a 	mov	r6,r4
81123bb0:	2007883a 	mov	r3,r4
81123bb4:	00000406 	br	81123bc8 <memset+0x34>
81123bb8:	3a3fffc4 	addi	r8,r7,-1
81123bbc:	31800044 	addi	r6,r6,1
81123bc0:	38003926 	beq	r7,zero,81123ca8 <memset+0x114>
81123bc4:	400f883a 	mov	r7,r8
81123bc8:	18c00044 	addi	r3,r3,1
81123bcc:	32400005 	stb	r9,0(r6)
81123bd0:	1a0000cc 	andi	r8,r3,3
81123bd4:	403ff81e 	bne	r8,zero,81123bb8 <__reset+0xfb103bb8>
81123bd8:	010000c4 	movi	r4,3
81123bdc:	21c02d2e 	bgeu	r4,r7,81123c94 <memset+0x100>
81123be0:	29003fcc 	andi	r4,r5,255
81123be4:	200c923a 	slli	r6,r4,8
81123be8:	3108b03a 	or	r4,r6,r4
81123bec:	200c943a 	slli	r6,r4,16
81123bf0:	218cb03a 	or	r6,r4,r6
81123bf4:	010003c4 	movi	r4,15
81123bf8:	21c0182e 	bgeu	r4,r7,81123c5c <memset+0xc8>
81123bfc:	3b3ffc04 	addi	r12,r7,-16
81123c00:	6018d13a 	srli	r12,r12,4
81123c04:	1a000104 	addi	r8,r3,4
81123c08:	1ac00204 	addi	r11,r3,8
81123c0c:	6008913a 	slli	r4,r12,4
81123c10:	1a800304 	addi	r10,r3,12
81123c14:	1813883a 	mov	r9,r3
81123c18:	21000504 	addi	r4,r4,20
81123c1c:	1909883a 	add	r4,r3,r4
81123c20:	49800015 	stw	r6,0(r9)
81123c24:	41800015 	stw	r6,0(r8)
81123c28:	59800015 	stw	r6,0(r11)
81123c2c:	51800015 	stw	r6,0(r10)
81123c30:	42000404 	addi	r8,r8,16
81123c34:	4a400404 	addi	r9,r9,16
81123c38:	5ac00404 	addi	r11,r11,16
81123c3c:	52800404 	addi	r10,r10,16
81123c40:	413ff71e 	bne	r8,r4,81123c20 <__reset+0xfb103c20>
81123c44:	63000044 	addi	r12,r12,1
81123c48:	6018913a 	slli	r12,r12,4
81123c4c:	39c003cc 	andi	r7,r7,15
81123c50:	010000c4 	movi	r4,3
81123c54:	1b07883a 	add	r3,r3,r12
81123c58:	21c00e2e 	bgeu	r4,r7,81123c94 <memset+0x100>
81123c5c:	1813883a 	mov	r9,r3
81123c60:	3811883a 	mov	r8,r7
81123c64:	010000c4 	movi	r4,3
81123c68:	49800015 	stw	r6,0(r9)
81123c6c:	423fff04 	addi	r8,r8,-4
81123c70:	4a400104 	addi	r9,r9,4
81123c74:	223ffc36 	bltu	r4,r8,81123c68 <__reset+0xfb103c68>
81123c78:	393fff04 	addi	r4,r7,-4
81123c7c:	2008d0ba 	srli	r4,r4,2
81123c80:	39c000cc 	andi	r7,r7,3
81123c84:	21000044 	addi	r4,r4,1
81123c88:	2109883a 	add	r4,r4,r4
81123c8c:	2109883a 	add	r4,r4,r4
81123c90:	1907883a 	add	r3,r3,r4
81123c94:	38000526 	beq	r7,zero,81123cac <memset+0x118>
81123c98:	19cf883a 	add	r7,r3,r7
81123c9c:	19400005 	stb	r5,0(r3)
81123ca0:	18c00044 	addi	r3,r3,1
81123ca4:	38fffd1e 	bne	r7,r3,81123c9c <__reset+0xfb103c9c>
81123ca8:	f800283a 	ret
81123cac:	f800283a 	ret
81123cb0:	2007883a 	mov	r3,r4
81123cb4:	300f883a 	mov	r7,r6
81123cb8:	003fc706 	br	81123bd8 <__reset+0xfb103bd8>

81123cbc <_open_r>:
81123cbc:	defffd04 	addi	sp,sp,-12
81123cc0:	de00012e 	bgeu	sp,et,81123cc8 <_open_r+0xc>
81123cc4:	003b68fa 	trap	3
81123cc8:	2805883a 	mov	r2,r5
81123ccc:	dc000015 	stw	r16,0(sp)
81123cd0:	04204574 	movhi	r16,33045
81123cd4:	dc400115 	stw	r17,4(sp)
81123cd8:	300b883a 	mov	r5,r6
81123cdc:	84118604 	addi	r16,r16,17944
81123ce0:	2023883a 	mov	r17,r4
81123ce4:	380d883a 	mov	r6,r7
81123ce8:	1009883a 	mov	r4,r2
81123cec:	dfc00215 	stw	ra,8(sp)
81123cf0:	80000015 	stw	zero,0(r16)
81123cf4:	1138a700 	call	81138a70 <open>
81123cf8:	00ffffc4 	movi	r3,-1
81123cfc:	10c00526 	beq	r2,r3,81123d14 <_open_r+0x58>
81123d00:	dfc00217 	ldw	ra,8(sp)
81123d04:	dc400117 	ldw	r17,4(sp)
81123d08:	dc000017 	ldw	r16,0(sp)
81123d0c:	dec00304 	addi	sp,sp,12
81123d10:	f800283a 	ret
81123d14:	80c00017 	ldw	r3,0(r16)
81123d18:	183ff926 	beq	r3,zero,81123d00 <__reset+0xfb103d00>
81123d1c:	88c00015 	stw	r3,0(r17)
81123d20:	003ff706 	br	81123d00 <__reset+0xfb103d00>

81123d24 <_putc_r>:
81123d24:	defffc04 	addi	sp,sp,-16
81123d28:	de00012e 	bgeu	sp,et,81123d30 <_putc_r+0xc>
81123d2c:	003b68fa 	trap	3
81123d30:	dc000215 	stw	r16,8(sp)
81123d34:	dfc00315 	stw	ra,12(sp)
81123d38:	2021883a 	mov	r16,r4
81123d3c:	20000226 	beq	r4,zero,81123d48 <_putc_r+0x24>
81123d40:	20800e17 	ldw	r2,56(r4)
81123d44:	10001b26 	beq	r2,zero,81123db4 <_putc_r+0x90>
81123d48:	30800217 	ldw	r2,8(r6)
81123d4c:	10bfffc4 	addi	r2,r2,-1
81123d50:	30800215 	stw	r2,8(r6)
81123d54:	10000a16 	blt	r2,zero,81123d80 <_putc_r+0x5c>
81123d58:	30800017 	ldw	r2,0(r6)
81123d5c:	11400005 	stb	r5,0(r2)
81123d60:	30800017 	ldw	r2,0(r6)
81123d64:	10c00044 	addi	r3,r2,1
81123d68:	30c00015 	stw	r3,0(r6)
81123d6c:	10800003 	ldbu	r2,0(r2)
81123d70:	dfc00317 	ldw	ra,12(sp)
81123d74:	dc000217 	ldw	r16,8(sp)
81123d78:	dec00404 	addi	sp,sp,16
81123d7c:	f800283a 	ret
81123d80:	30c00617 	ldw	r3,24(r6)
81123d84:	10c00616 	blt	r2,r3,81123da0 <_putc_r+0x7c>
81123d88:	30800017 	ldw	r2,0(r6)
81123d8c:	00c00284 	movi	r3,10
81123d90:	11400005 	stb	r5,0(r2)
81123d94:	30800017 	ldw	r2,0(r6)
81123d98:	11400003 	ldbu	r5,0(r2)
81123d9c:	28fff11e 	bne	r5,r3,81123d64 <__reset+0xfb103d64>
81123da0:	8009883a 	mov	r4,r16
81123da4:	dfc00317 	ldw	ra,12(sp)
81123da8:	dc000217 	ldw	r16,8(sp)
81123dac:	dec00404 	addi	sp,sp,16
81123db0:	112a5581 	jmpi	8112a558 <__swbuf_r>
81123db4:	d9400015 	stw	r5,0(sp)
81123db8:	d9800115 	stw	r6,4(sp)
81123dbc:	112c7900 	call	8112c790 <__sinit>
81123dc0:	d9800117 	ldw	r6,4(sp)
81123dc4:	d9400017 	ldw	r5,0(sp)
81123dc8:	003fdf06 	br	81123d48 <__reset+0xfb103d48>

81123dcc <putc>:
81123dcc:	00a04574 	movhi	r2,33045
81123dd0:	defffc04 	addi	sp,sp,-16
81123dd4:	10911304 	addi	r2,r2,17484
81123dd8:	de00012e 	bgeu	sp,et,81123de0 <putc+0x14>
81123ddc:	003b68fa 	trap	3
81123de0:	dc000115 	stw	r16,4(sp)
81123de4:	14000017 	ldw	r16,0(r2)
81123de8:	dc400215 	stw	r17,8(sp)
81123dec:	dfc00315 	stw	ra,12(sp)
81123df0:	2023883a 	mov	r17,r4
81123df4:	80000226 	beq	r16,zero,81123e00 <putc+0x34>
81123df8:	80800e17 	ldw	r2,56(r16)
81123dfc:	10001a26 	beq	r2,zero,81123e68 <putc+0x9c>
81123e00:	28800217 	ldw	r2,8(r5)
81123e04:	10bfffc4 	addi	r2,r2,-1
81123e08:	28800215 	stw	r2,8(r5)
81123e0c:	10000b16 	blt	r2,zero,81123e3c <putc+0x70>
81123e10:	28800017 	ldw	r2,0(r5)
81123e14:	14400005 	stb	r17,0(r2)
81123e18:	28800017 	ldw	r2,0(r5)
81123e1c:	10c00044 	addi	r3,r2,1
81123e20:	28c00015 	stw	r3,0(r5)
81123e24:	10800003 	ldbu	r2,0(r2)
81123e28:	dfc00317 	ldw	ra,12(sp)
81123e2c:	dc400217 	ldw	r17,8(sp)
81123e30:	dc000117 	ldw	r16,4(sp)
81123e34:	dec00404 	addi	sp,sp,16
81123e38:	f800283a 	ret
81123e3c:	28c00617 	ldw	r3,24(r5)
81123e40:	10c00e16 	blt	r2,r3,81123e7c <putc+0xb0>
81123e44:	28800017 	ldw	r2,0(r5)
81123e48:	01000284 	movi	r4,10
81123e4c:	14400005 	stb	r17,0(r2)
81123e50:	28800017 	ldw	r2,0(r5)
81123e54:	10c00003 	ldbu	r3,0(r2)
81123e58:	193ff01e 	bne	r3,r4,81123e1c <__reset+0xfb103e1c>
81123e5c:	280d883a 	mov	r6,r5
81123e60:	180b883a 	mov	r5,r3
81123e64:	00000706 	br	81123e84 <putc+0xb8>
81123e68:	8009883a 	mov	r4,r16
81123e6c:	d9400015 	stw	r5,0(sp)
81123e70:	112c7900 	call	8112c790 <__sinit>
81123e74:	d9400017 	ldw	r5,0(sp)
81123e78:	003fe106 	br	81123e00 <__reset+0xfb103e00>
81123e7c:	280d883a 	mov	r6,r5
81123e80:	880b883a 	mov	r5,r17
81123e84:	8009883a 	mov	r4,r16
81123e88:	dfc00317 	ldw	ra,12(sp)
81123e8c:	dc400217 	ldw	r17,8(sp)
81123e90:	dc000117 	ldw	r16,4(sp)
81123e94:	dec00404 	addi	sp,sp,16
81123e98:	112a5581 	jmpi	8112a558 <__swbuf_r>

81123e9c <_puts_r>:
81123e9c:	defff604 	addi	sp,sp,-40
81123ea0:	de00012e 	bgeu	sp,et,81123ea8 <_puts_r+0xc>
81123ea4:	003b68fa 	trap	3
81123ea8:	dc000715 	stw	r16,28(sp)
81123eac:	2021883a 	mov	r16,r4
81123eb0:	2809883a 	mov	r4,r5
81123eb4:	dc400815 	stw	r17,32(sp)
81123eb8:	dfc00915 	stw	ra,36(sp)
81123ebc:	2823883a 	mov	r17,r5
81123ec0:	11244bc0 	call	811244bc <strlen>
81123ec4:	10c00044 	addi	r3,r2,1
81123ec8:	d8800115 	stw	r2,4(sp)
81123ecc:	00a04574 	movhi	r2,33045
81123ed0:	10873a04 	addi	r2,r2,7400
81123ed4:	d8800215 	stw	r2,8(sp)
81123ed8:	00800044 	movi	r2,1
81123edc:	d8800315 	stw	r2,12(sp)
81123ee0:	00800084 	movi	r2,2
81123ee4:	dc400015 	stw	r17,0(sp)
81123ee8:	d8c00615 	stw	r3,24(sp)
81123eec:	dec00415 	stw	sp,16(sp)
81123ef0:	d8800515 	stw	r2,20(sp)
81123ef4:	80000226 	beq	r16,zero,81123f00 <_puts_r+0x64>
81123ef8:	80800e17 	ldw	r2,56(r16)
81123efc:	10001426 	beq	r2,zero,81123f50 <_puts_r+0xb4>
81123f00:	81400217 	ldw	r5,8(r16)
81123f04:	2880030b 	ldhu	r2,12(r5)
81123f08:	10c8000c 	andi	r3,r2,8192
81123f0c:	1800061e 	bne	r3,zero,81123f28 <_puts_r+0x8c>
81123f10:	29001917 	ldw	r4,100(r5)
81123f14:	00f7ffc4 	movi	r3,-8193
81123f18:	10880014 	ori	r2,r2,8192
81123f1c:	20c6703a 	and	r3,r4,r3
81123f20:	2880030d 	sth	r2,12(r5)
81123f24:	28c01915 	stw	r3,100(r5)
81123f28:	d9800404 	addi	r6,sp,16
81123f2c:	8009883a 	mov	r4,r16
81123f30:	112cf400 	call	8112cf40 <__sfvwrite_r>
81123f34:	1000091e 	bne	r2,zero,81123f5c <_puts_r+0xc0>
81123f38:	00800284 	movi	r2,10
81123f3c:	dfc00917 	ldw	ra,36(sp)
81123f40:	dc400817 	ldw	r17,32(sp)
81123f44:	dc000717 	ldw	r16,28(sp)
81123f48:	dec00a04 	addi	sp,sp,40
81123f4c:	f800283a 	ret
81123f50:	8009883a 	mov	r4,r16
81123f54:	112c7900 	call	8112c790 <__sinit>
81123f58:	003fe906 	br	81123f00 <__reset+0xfb103f00>
81123f5c:	00bfffc4 	movi	r2,-1
81123f60:	003ff606 	br	81123f3c <__reset+0xfb103f3c>

81123f64 <puts>:
81123f64:	00a04574 	movhi	r2,33045
81123f68:	10911304 	addi	r2,r2,17484
81123f6c:	200b883a 	mov	r5,r4
81123f70:	11000017 	ldw	r4,0(r2)
81123f74:	1123e9c1 	jmpi	81123e9c <_puts_r>

81123f78 <lflush>:
81123f78:	2080030b 	ldhu	r2,12(r4)
81123f7c:	00c00244 	movi	r3,9
81123f80:	1080024c 	andi	r2,r2,9
81123f84:	10c00226 	beq	r2,r3,81123f90 <lflush+0x18>
81123f88:	0005883a 	mov	r2,zero
81123f8c:	f800283a 	ret
81123f90:	112c3f81 	jmpi	8112c3f8 <fflush>

81123f94 <__srefill_r>:
81123f94:	defffc04 	addi	sp,sp,-16
81123f98:	de00012e 	bgeu	sp,et,81123fa0 <__srefill_r+0xc>
81123f9c:	003b68fa 	trap	3
81123fa0:	dc400115 	stw	r17,4(sp)
81123fa4:	dc000015 	stw	r16,0(sp)
81123fa8:	dfc00315 	stw	ra,12(sp)
81123fac:	dc800215 	stw	r18,8(sp)
81123fb0:	2023883a 	mov	r17,r4
81123fb4:	2821883a 	mov	r16,r5
81123fb8:	20000226 	beq	r4,zero,81123fc4 <__srefill_r+0x30>
81123fbc:	20800e17 	ldw	r2,56(r4)
81123fc0:	10003c26 	beq	r2,zero,811240b4 <__srefill_r+0x120>
81123fc4:	80c0030b 	ldhu	r3,12(r16)
81123fc8:	1908000c 	andi	r4,r3,8192
81123fcc:	1805883a 	mov	r2,r3
81123fd0:	2000071e 	bne	r4,zero,81123ff0 <__srefill_r+0x5c>
81123fd4:	81001917 	ldw	r4,100(r16)
81123fd8:	18880014 	ori	r2,r3,8192
81123fdc:	00f7ffc4 	movi	r3,-8193
81123fe0:	20c8703a 	and	r4,r4,r3
81123fe4:	8080030d 	sth	r2,12(r16)
81123fe8:	1007883a 	mov	r3,r2
81123fec:	81001915 	stw	r4,100(r16)
81123ff0:	80000115 	stw	zero,4(r16)
81123ff4:	1100080c 	andi	r4,r2,32
81123ff8:	2000571e 	bne	r4,zero,81124158 <__srefill_r+0x1c4>
81123ffc:	1100010c 	andi	r4,r2,4
81124000:	20001f26 	beq	r4,zero,81124080 <__srefill_r+0xec>
81124004:	81400c17 	ldw	r5,48(r16)
81124008:	28000826 	beq	r5,zero,8112402c <__srefill_r+0x98>
8112400c:	80801004 	addi	r2,r16,64
81124010:	28800226 	beq	r5,r2,8112401c <__srefill_r+0x88>
81124014:	8809883a 	mov	r4,r17
81124018:	112cc280 	call	8112cc28 <_free_r>
8112401c:	80800f17 	ldw	r2,60(r16)
81124020:	80000c15 	stw	zero,48(r16)
81124024:	80800115 	stw	r2,4(r16)
81124028:	1000391e 	bne	r2,zero,81124110 <__srefill_r+0x17c>
8112402c:	80800417 	ldw	r2,16(r16)
81124030:	10004b26 	beq	r2,zero,81124160 <__srefill_r+0x1cc>
81124034:	8480030b 	ldhu	r18,12(r16)
81124038:	908000cc 	andi	r2,r18,3
8112403c:	10001f1e 	bne	r2,zero,811240bc <__srefill_r+0x128>
81124040:	81800417 	ldw	r6,16(r16)
81124044:	80800817 	ldw	r2,32(r16)
81124048:	81c00517 	ldw	r7,20(r16)
8112404c:	81400717 	ldw	r5,28(r16)
81124050:	81800015 	stw	r6,0(r16)
81124054:	8809883a 	mov	r4,r17
81124058:	103ee83a 	callr	r2
8112405c:	80800115 	stw	r2,4(r16)
81124060:	00800e0e 	bge	zero,r2,8112409c <__srefill_r+0x108>
81124064:	0005883a 	mov	r2,zero
81124068:	dfc00317 	ldw	ra,12(sp)
8112406c:	dc800217 	ldw	r18,8(sp)
81124070:	dc400117 	ldw	r17,4(sp)
81124074:	dc000017 	ldw	r16,0(sp)
81124078:	dec00404 	addi	sp,sp,16
8112407c:	f800283a 	ret
81124080:	1100040c 	andi	r4,r2,16
81124084:	20003026 	beq	r4,zero,81124148 <__srefill_r+0x1b4>
81124088:	1080020c 	andi	r2,r2,8
8112408c:	1000241e 	bne	r2,zero,81124120 <__srefill_r+0x18c>
81124090:	18c00114 	ori	r3,r3,4
81124094:	80c0030d 	sth	r3,12(r16)
81124098:	003fe406 	br	8112402c <__reset+0xfb10402c>
8112409c:	80c0030b 	ldhu	r3,12(r16)
811240a0:	1000161e 	bne	r2,zero,811240fc <__srefill_r+0x168>
811240a4:	18c00814 	ori	r3,r3,32
811240a8:	00bfffc4 	movi	r2,-1
811240ac:	80c0030d 	sth	r3,12(r16)
811240b0:	003fed06 	br	81124068 <__reset+0xfb104068>
811240b4:	112c7900 	call	8112c790 <__sinit>
811240b8:	003fc206 	br	81123fc4 <__reset+0xfb103fc4>
811240bc:	00a04574 	movhi	r2,33045
811240c0:	10911204 	addi	r2,r2,17480
811240c4:	11000017 	ldw	r4,0(r2)
811240c8:	016044b4 	movhi	r5,33042
811240cc:	00800044 	movi	r2,1
811240d0:	294fde04 	addi	r5,r5,16248
811240d4:	8080030d 	sth	r2,12(r16)
811240d8:	112d4040 	call	8112d404 <_fwalk>
811240dc:	00800244 	movi	r2,9
811240e0:	8480030d 	sth	r18,12(r16)
811240e4:	9480024c 	andi	r18,r18,9
811240e8:	90bfd51e 	bne	r18,r2,81124040 <__reset+0xfb104040>
811240ec:	800b883a 	mov	r5,r16
811240f0:	8809883a 	mov	r4,r17
811240f4:	112c1700 	call	8112c170 <__sflush_r>
811240f8:	003fd106 	br	81124040 <__reset+0xfb104040>
811240fc:	18c01014 	ori	r3,r3,64
81124100:	80000115 	stw	zero,4(r16)
81124104:	00bfffc4 	movi	r2,-1
81124108:	80c0030d 	sth	r3,12(r16)
8112410c:	003fd606 	br	81124068 <__reset+0xfb104068>
81124110:	80c00e17 	ldw	r3,56(r16)
81124114:	0005883a 	mov	r2,zero
81124118:	80c00015 	stw	r3,0(r16)
8112411c:	003fd206 	br	81124068 <__reset+0xfb104068>
81124120:	800b883a 	mov	r5,r16
81124124:	8809883a 	mov	r4,r17
81124128:	112c3940 	call	8112c394 <_fflush_r>
8112412c:	10000a1e 	bne	r2,zero,81124158 <__srefill_r+0x1c4>
81124130:	8080030b 	ldhu	r2,12(r16)
81124134:	00fffdc4 	movi	r3,-9
81124138:	80000215 	stw	zero,8(r16)
8112413c:	1886703a 	and	r3,r3,r2
81124140:	80000615 	stw	zero,24(r16)
81124144:	003fd206 	br	81124090 <__reset+0xfb104090>
81124148:	00800244 	movi	r2,9
8112414c:	88800015 	stw	r2,0(r17)
81124150:	18c01014 	ori	r3,r3,64
81124154:	80c0030d 	sth	r3,12(r16)
81124158:	00bfffc4 	movi	r2,-1
8112415c:	003fc206 	br	81124068 <__reset+0xfb104068>
81124160:	800b883a 	mov	r5,r16
81124164:	8809883a 	mov	r4,r17
81124168:	112306c0 	call	8112306c <__smakebuf_r>
8112416c:	003fb106 	br	81124034 <__reset+0xfb104034>

81124170 <_sbrk_r>:
81124170:	defffd04 	addi	sp,sp,-12
81124174:	de00012e 	bgeu	sp,et,8112417c <_sbrk_r+0xc>
81124178:	003b68fa 	trap	3
8112417c:	dc000015 	stw	r16,0(sp)
81124180:	04204574 	movhi	r16,33045
81124184:	dc400115 	stw	r17,4(sp)
81124188:	84118604 	addi	r16,r16,17944
8112418c:	2023883a 	mov	r17,r4
81124190:	2809883a 	mov	r4,r5
81124194:	dfc00215 	stw	ra,8(sp)
81124198:	80000015 	stw	zero,0(r16)
8112419c:	1138d800 	call	81138d80 <sbrk>
811241a0:	00ffffc4 	movi	r3,-1
811241a4:	10c00526 	beq	r2,r3,811241bc <_sbrk_r+0x4c>
811241a8:	dfc00217 	ldw	ra,8(sp)
811241ac:	dc400117 	ldw	r17,4(sp)
811241b0:	dc000017 	ldw	r16,0(sp)
811241b4:	dec00304 	addi	sp,sp,12
811241b8:	f800283a 	ret
811241bc:	80c00017 	ldw	r3,0(r16)
811241c0:	183ff926 	beq	r3,zero,811241a8 <__reset+0xfb1041a8>
811241c4:	88c00015 	stw	r3,0(r17)
811241c8:	003ff706 	br	811241a8 <__reset+0xfb1041a8>

811241cc <scanf>:
811241cc:	defffc04 	addi	sp,sp,-16
811241d0:	de00012e 	bgeu	sp,et,811241d8 <scanf+0xc>
811241d4:	003b68fa 	trap	3
811241d8:	dfc00015 	stw	ra,0(sp)
811241dc:	d9400115 	stw	r5,4(sp)
811241e0:	d9800215 	stw	r6,8(sp)
811241e4:	d9c00315 	stw	r7,12(sp)
811241e8:	00a04574 	movhi	r2,33045
811241ec:	10911304 	addi	r2,r2,17484
811241f0:	200d883a 	mov	r6,r4
811241f4:	11000017 	ldw	r4,0(r2)
811241f8:	d9c00104 	addi	r7,sp,4
811241fc:	21400117 	ldw	r5,4(r4)
81124200:	112a5040 	call	8112a504 <_vfscanf_r>
81124204:	dfc00017 	ldw	ra,0(sp)
81124208:	dec00404 	addi	sp,sp,16
8112420c:	f800283a 	ret

81124210 <_scanf_r>:
81124210:	defffd04 	addi	sp,sp,-12
81124214:	2805883a 	mov	r2,r5
81124218:	de00012e 	bgeu	sp,et,81124220 <_scanf_r+0x10>
8112421c:	003b68fa 	trap	3
81124220:	dfc00015 	stw	ra,0(sp)
81124224:	d9800115 	stw	r6,4(sp)
81124228:	d9c00215 	stw	r7,8(sp)
8112422c:	21400117 	ldw	r5,4(r4)
81124230:	d9c00104 	addi	r7,sp,4
81124234:	100d883a 	mov	r6,r2
81124238:	112a5040 	call	8112a504 <_vfscanf_r>
8112423c:	dfc00017 	ldw	ra,0(sp)
81124240:	dec00304 	addi	sp,sp,12
81124244:	f800283a 	ret

81124248 <_sprintf_r>:
81124248:	deffe404 	addi	sp,sp,-112
8112424c:	2807883a 	mov	r3,r5
81124250:	de00012e 	bgeu	sp,et,81124258 <_sprintf_r+0x10>
81124254:	003b68fa 	trap	3
81124258:	dfc01a15 	stw	ra,104(sp)
8112425c:	d9c01b15 	stw	r7,108(sp)
81124260:	00a00034 	movhi	r2,32768
81124264:	10bfffc4 	addi	r2,r2,-1
81124268:	02008204 	movi	r8,520
8112426c:	d8800215 	stw	r2,8(sp)
81124270:	d8800515 	stw	r2,20(sp)
81124274:	d9c01b04 	addi	r7,sp,108
81124278:	d80b883a 	mov	r5,sp
8112427c:	00bfffc4 	movi	r2,-1
81124280:	d8c00015 	stw	r3,0(sp)
81124284:	d8c00415 	stw	r3,16(sp)
81124288:	da00030d 	sth	r8,12(sp)
8112428c:	d880038d 	sth	r2,14(sp)
81124290:	11247f40 	call	811247f4 <___svfprintf_internal_r>
81124294:	d8c00017 	ldw	r3,0(sp)
81124298:	18000005 	stb	zero,0(r3)
8112429c:	dfc01a17 	ldw	ra,104(sp)
811242a0:	dec01c04 	addi	sp,sp,112
811242a4:	f800283a 	ret

811242a8 <sprintf>:
811242a8:	deffe304 	addi	sp,sp,-116
811242ac:	2007883a 	mov	r3,r4
811242b0:	de00012e 	bgeu	sp,et,811242b8 <sprintf+0x10>
811242b4:	003b68fa 	trap	3
811242b8:	dfc01a15 	stw	ra,104(sp)
811242bc:	d9801b15 	stw	r6,108(sp)
811242c0:	d9c01c15 	stw	r7,112(sp)
811242c4:	01204574 	movhi	r4,33045
811242c8:	21111304 	addi	r4,r4,17484
811242cc:	21000017 	ldw	r4,0(r4)
811242d0:	00a00034 	movhi	r2,32768
811242d4:	10bfffc4 	addi	r2,r2,-1
811242d8:	280d883a 	mov	r6,r5
811242dc:	02008204 	movi	r8,520
811242e0:	d8800215 	stw	r2,8(sp)
811242e4:	d8800515 	stw	r2,20(sp)
811242e8:	d9c01b04 	addi	r7,sp,108
811242ec:	d80b883a 	mov	r5,sp
811242f0:	00bfffc4 	movi	r2,-1
811242f4:	d8c00015 	stw	r3,0(sp)
811242f8:	d8c00415 	stw	r3,16(sp)
811242fc:	da00030d 	sth	r8,12(sp)
81124300:	d880038d 	sth	r2,14(sp)
81124304:	11247f40 	call	811247f4 <___svfprintf_internal_r>
81124308:	d8c00017 	ldw	r3,0(sp)
8112430c:	18000005 	stb	zero,0(r3)
81124310:	dfc01a17 	ldw	ra,104(sp)
81124314:	dec01d04 	addi	sp,sp,116
81124318:	f800283a 	ret

8112431c <__sread>:
8112431c:	defffe04 	addi	sp,sp,-8
81124320:	de00012e 	bgeu	sp,et,81124328 <__sread+0xc>
81124324:	003b68fa 	trap	3
81124328:	dc000015 	stw	r16,0(sp)
8112432c:	2821883a 	mov	r16,r5
81124330:	2940038f 	ldh	r5,14(r5)
81124334:	dfc00115 	stw	ra,4(sp)
81124338:	112ec540 	call	8112ec54 <_read_r>
8112433c:	10000716 	blt	r2,zero,8112435c <__sread+0x40>
81124340:	80c01417 	ldw	r3,80(r16)
81124344:	1887883a 	add	r3,r3,r2
81124348:	80c01415 	stw	r3,80(r16)
8112434c:	dfc00117 	ldw	ra,4(sp)
81124350:	dc000017 	ldw	r16,0(sp)
81124354:	dec00204 	addi	sp,sp,8
81124358:	f800283a 	ret
8112435c:	80c0030b 	ldhu	r3,12(r16)
81124360:	18fbffcc 	andi	r3,r3,61439
81124364:	80c0030d 	sth	r3,12(r16)
81124368:	dfc00117 	ldw	ra,4(sp)
8112436c:	dc000017 	ldw	r16,0(sp)
81124370:	dec00204 	addi	sp,sp,8
81124374:	f800283a 	ret

81124378 <__seofread>:
81124378:	0005883a 	mov	r2,zero
8112437c:	f800283a 	ret

81124380 <__swrite>:
81124380:	defffb04 	addi	sp,sp,-20
81124384:	de00012e 	bgeu	sp,et,8112438c <__swrite+0xc>
81124388:	003b68fa 	trap	3
8112438c:	2880030b 	ldhu	r2,12(r5)
81124390:	dcc00315 	stw	r19,12(sp)
81124394:	dc800215 	stw	r18,8(sp)
81124398:	dc400115 	stw	r17,4(sp)
8112439c:	dc000015 	stw	r16,0(sp)
811243a0:	dfc00415 	stw	ra,16(sp)
811243a4:	10c0400c 	andi	r3,r2,256
811243a8:	2821883a 	mov	r16,r5
811243ac:	2023883a 	mov	r17,r4
811243b0:	3025883a 	mov	r18,r6
811243b4:	3827883a 	mov	r19,r7
811243b8:	18000526 	beq	r3,zero,811243d0 <__swrite+0x50>
811243bc:	2940038f 	ldh	r5,14(r5)
811243c0:	01c00084 	movi	r7,2
811243c4:	000d883a 	mov	r6,zero
811243c8:	112d70c0 	call	8112d70c <_lseek_r>
811243cc:	8080030b 	ldhu	r2,12(r16)
811243d0:	8140038f 	ldh	r5,14(r16)
811243d4:	10bbffcc 	andi	r2,r2,61439
811243d8:	980f883a 	mov	r7,r19
811243dc:	900d883a 	mov	r6,r18
811243e0:	8809883a 	mov	r4,r17
811243e4:	8080030d 	sth	r2,12(r16)
811243e8:	dfc00417 	ldw	ra,16(sp)
811243ec:	dcc00317 	ldw	r19,12(sp)
811243f0:	dc800217 	ldw	r18,8(sp)
811243f4:	dc400117 	ldw	r17,4(sp)
811243f8:	dc000017 	ldw	r16,0(sp)
811243fc:	dec00504 	addi	sp,sp,20
81124400:	112a6b81 	jmpi	8112a6b8 <_write_r>

81124404 <__sseek>:
81124404:	defffe04 	addi	sp,sp,-8
81124408:	de00012e 	bgeu	sp,et,81124410 <__sseek+0xc>
8112440c:	003b68fa 	trap	3
81124410:	dc000015 	stw	r16,0(sp)
81124414:	2821883a 	mov	r16,r5
81124418:	2940038f 	ldh	r5,14(r5)
8112441c:	dfc00115 	stw	ra,4(sp)
81124420:	112d70c0 	call	8112d70c <_lseek_r>
81124424:	00ffffc4 	movi	r3,-1
81124428:	10c00826 	beq	r2,r3,8112444c <__sseek+0x48>
8112442c:	80c0030b 	ldhu	r3,12(r16)
81124430:	80801415 	stw	r2,80(r16)
81124434:	18c40014 	ori	r3,r3,4096
81124438:	80c0030d 	sth	r3,12(r16)
8112443c:	dfc00117 	ldw	ra,4(sp)
81124440:	dc000017 	ldw	r16,0(sp)
81124444:	dec00204 	addi	sp,sp,8
81124448:	f800283a 	ret
8112444c:	80c0030b 	ldhu	r3,12(r16)
81124450:	18fbffcc 	andi	r3,r3,61439
81124454:	80c0030d 	sth	r3,12(r16)
81124458:	dfc00117 	ldw	ra,4(sp)
8112445c:	dc000017 	ldw	r16,0(sp)
81124460:	dec00204 	addi	sp,sp,8
81124464:	f800283a 	ret

81124468 <__sclose>:
81124468:	2940038f 	ldh	r5,14(r5)
8112446c:	112a87c1 	jmpi	8112a87c <_close_r>

81124470 <strcspn>:
81124470:	21c00007 	ldb	r7,0(r4)
81124474:	38000f26 	beq	r7,zero,811244b4 <strcspn+0x44>
81124478:	2a000007 	ldb	r8,0(r5)
8112447c:	2005883a 	mov	r2,r4
81124480:	40000726 	beq	r8,zero,811244a0 <strcspn+0x30>
81124484:	3a000926 	beq	r7,r8,811244ac <strcspn+0x3c>
81124488:	2807883a 	mov	r3,r5
8112448c:	00000106 	br	81124494 <strcspn+0x24>
81124490:	31c00626 	beq	r6,r7,811244ac <strcspn+0x3c>
81124494:	18c00044 	addi	r3,r3,1
81124498:	19800007 	ldb	r6,0(r3)
8112449c:	303ffc1e 	bne	r6,zero,81124490 <__reset+0xfb104490>
811244a0:	10800044 	addi	r2,r2,1
811244a4:	11c00007 	ldb	r7,0(r2)
811244a8:	383ff51e 	bne	r7,zero,81124480 <__reset+0xfb104480>
811244ac:	1105c83a 	sub	r2,r2,r4
811244b0:	f800283a 	ret
811244b4:	0005883a 	mov	r2,zero
811244b8:	f800283a 	ret

811244bc <strlen>:
811244bc:	208000cc 	andi	r2,r4,3
811244c0:	10002026 	beq	r2,zero,81124544 <strlen+0x88>
811244c4:	20800007 	ldb	r2,0(r4)
811244c8:	10002026 	beq	r2,zero,8112454c <strlen+0x90>
811244cc:	2005883a 	mov	r2,r4
811244d0:	00000206 	br	811244dc <strlen+0x20>
811244d4:	10c00007 	ldb	r3,0(r2)
811244d8:	18001826 	beq	r3,zero,8112453c <strlen+0x80>
811244dc:	10800044 	addi	r2,r2,1
811244e0:	10c000cc 	andi	r3,r2,3
811244e4:	183ffb1e 	bne	r3,zero,811244d4 <__reset+0xfb1044d4>
811244e8:	10c00017 	ldw	r3,0(r2)
811244ec:	01ffbff4 	movhi	r7,65279
811244f0:	39ffbfc4 	addi	r7,r7,-257
811244f4:	00ca303a 	nor	r5,zero,r3
811244f8:	01a02074 	movhi	r6,32897
811244fc:	19c7883a 	add	r3,r3,r7
81124500:	31a02004 	addi	r6,r6,-32640
81124504:	1946703a 	and	r3,r3,r5
81124508:	1986703a 	and	r3,r3,r6
8112450c:	1800091e 	bne	r3,zero,81124534 <strlen+0x78>
81124510:	10800104 	addi	r2,r2,4
81124514:	10c00017 	ldw	r3,0(r2)
81124518:	19cb883a 	add	r5,r3,r7
8112451c:	00c6303a 	nor	r3,zero,r3
81124520:	28c6703a 	and	r3,r5,r3
81124524:	1986703a 	and	r3,r3,r6
81124528:	183ff926 	beq	r3,zero,81124510 <__reset+0xfb104510>
8112452c:	00000106 	br	81124534 <strlen+0x78>
81124530:	10800044 	addi	r2,r2,1
81124534:	10c00007 	ldb	r3,0(r2)
81124538:	183ffd1e 	bne	r3,zero,81124530 <__reset+0xfb104530>
8112453c:	1105c83a 	sub	r2,r2,r4
81124540:	f800283a 	ret
81124544:	2005883a 	mov	r2,r4
81124548:	003fe706 	br	811244e8 <__reset+0xfb1044e8>
8112454c:	0005883a 	mov	r2,zero
81124550:	f800283a 	ret

81124554 <strnlen>:
81124554:	28000e26 	beq	r5,zero,81124590 <strnlen+0x3c>
81124558:	20800007 	ldb	r2,0(r4)
8112455c:	10000c26 	beq	r2,zero,81124590 <strnlen+0x3c>
81124560:	20c00044 	addi	r3,r4,1
81124564:	214b883a 	add	r5,r4,r5
81124568:	28c00526 	beq	r5,r3,81124580 <strnlen+0x2c>
8112456c:	19800007 	ldb	r6,0(r3)
81124570:	19c00044 	addi	r7,r3,1
81124574:	30000426 	beq	r6,zero,81124588 <strnlen+0x34>
81124578:	3807883a 	mov	r3,r7
8112457c:	28fffb1e 	bne	r5,r3,8112456c <__reset+0xfb10456c>
81124580:	2905c83a 	sub	r2,r5,r4
81124584:	f800283a 	ret
81124588:	1905c83a 	sub	r2,r3,r4
8112458c:	f800283a 	ret
81124590:	0005883a 	mov	r2,zero
81124594:	f800283a 	ret

81124598 <_strtol_r>:
81124598:	00a04574 	movhi	r2,33045
8112459c:	defff404 	addi	sp,sp,-48
811245a0:	10911104 	addi	r2,r2,17476
811245a4:	de00012e 	bgeu	sp,et,811245ac <_strtol_r+0x14>
811245a8:	003b68fa 	trap	3
811245ac:	dd400715 	stw	r21,28(sp)
811245b0:	15400017 	ldw	r21,0(r2)
811245b4:	dd800815 	stw	r22,32(sp)
811245b8:	dd000615 	stw	r20,24(sp)
811245bc:	dcc00515 	stw	r19,20(sp)
811245c0:	d9000015 	stw	r4,0(sp)
811245c4:	dfc00b15 	stw	ra,44(sp)
811245c8:	df000a15 	stw	fp,40(sp)
811245cc:	ddc00915 	stw	r23,36(sp)
811245d0:	dc800415 	stw	r18,16(sp)
811245d4:	dc400315 	stw	r17,12(sp)
811245d8:	dc000215 	stw	r16,8(sp)
811245dc:	2829883a 	mov	r20,r5
811245e0:	3027883a 	mov	r19,r6
811245e4:	382d883a 	mov	r22,r7
811245e8:	2809883a 	mov	r4,r5
811245ec:	24000003 	ldbu	r16,0(r4)
811245f0:	24400044 	addi	r17,r4,1
811245f4:	2007883a 	mov	r3,r4
811245f8:	ac05883a 	add	r2,r21,r16
811245fc:	10800043 	ldbu	r2,1(r2)
81124600:	8809883a 	mov	r4,r17
81124604:	1080020c 	andi	r2,r2,8
81124608:	103ff81e 	bne	r2,zero,811245ec <__reset+0xfb1045ec>
8112460c:	00800b44 	movi	r2,45
81124610:	80805826 	beq	r16,r2,81124774 <_strtol_r+0x1dc>
81124614:	00800ac4 	movi	r2,43
81124618:	80805a26 	beq	r16,r2,81124784 <_strtol_r+0x1ec>
8112461c:	0039883a 	mov	fp,zero
81124620:	b0004426 	beq	r22,zero,81124734 <_strtol_r+0x19c>
81124624:	00800404 	movi	r2,16
81124628:	b0806026 	beq	r22,r2,811247ac <_strtol_r+0x214>
8112462c:	b02f883a 	mov	r23,r22
81124630:	00a00034 	movhi	r2,32768
81124634:	e025003a 	cmpeq	r18,fp,zero
81124638:	14a5c83a 	sub	r18,r2,r18
8112463c:	b80b883a 	mov	r5,r23
81124640:	9009883a 	mov	r4,r18
81124644:	1135f980 	call	81135f98 <__umodsi3>
81124648:	b80b883a 	mov	r5,r23
8112464c:	9009883a 	mov	r4,r18
81124650:	d8800115 	stw	r2,4(sp)
81124654:	1135f340 	call	81135f34 <__udivsi3>
81124658:	ac07883a 	add	r3,r21,r16
8112465c:	18c00043 	ldbu	r3,1(r3)
81124660:	880b883a 	mov	r5,r17
81124664:	000d883a 	mov	r6,zero
81124668:	1a00010c 	andi	r8,r3,4
8112466c:	0009883a 	mov	r4,zero
81124670:	02800044 	movi	r10,1
81124674:	027fffc4 	movi	r9,-1
81124678:	d9c00117 	ldw	r7,4(sp)
8112467c:	40000e26 	beq	r8,zero,811246b8 <_strtol_r+0x120>
81124680:	843ff404 	addi	r16,r16,-48
81124684:	8580120e 	bge	r16,r22,811246d0 <_strtol_r+0x138>
81124688:	32400526 	beq	r6,r9,811246a0 <_strtol_r+0x108>
8112468c:	11002536 	bltu	r2,r4,81124724 <_strtol_r+0x18c>
81124690:	20802326 	beq	r4,r2,81124720 <_strtol_r+0x188>
81124694:	25c9383a 	mul	r4,r4,r23
81124698:	01800044 	movi	r6,1
8112469c:	8109883a 	add	r4,r16,r4
811246a0:	2c000003 	ldbu	r16,0(r5)
811246a4:	29400044 	addi	r5,r5,1
811246a8:	ac07883a 	add	r3,r21,r16
811246ac:	18c00043 	ldbu	r3,1(r3)
811246b0:	1a00010c 	andi	r8,r3,4
811246b4:	403ff21e 	bne	r8,zero,81124680 <__reset+0xfb104680>
811246b8:	18c000cc 	andi	r3,r3,3
811246bc:	18000426 	beq	r3,zero,811246d0 <_strtol_r+0x138>
811246c0:	1a801a26 	beq	r3,r10,8112472c <_strtol_r+0x194>
811246c4:	00c015c4 	movi	r3,87
811246c8:	80e1c83a 	sub	r16,r16,r3
811246cc:	85bfee16 	blt	r16,r22,81124688 <__reset+0xfb104688>
811246d0:	00bfffc4 	movi	r2,-1
811246d4:	30801e26 	beq	r6,r2,81124750 <_strtol_r+0x1b8>
811246d8:	e0001b1e 	bne	fp,zero,81124748 <_strtol_r+0x1b0>
811246dc:	2005883a 	mov	r2,r4
811246e0:	98000326 	beq	r19,zero,811246f0 <_strtol_r+0x158>
811246e4:	3000211e 	bne	r6,zero,8112476c <_strtol_r+0x1d4>
811246e8:	a00b883a 	mov	r5,r20
811246ec:	99400015 	stw	r5,0(r19)
811246f0:	dfc00b17 	ldw	ra,44(sp)
811246f4:	df000a17 	ldw	fp,40(sp)
811246f8:	ddc00917 	ldw	r23,36(sp)
811246fc:	dd800817 	ldw	r22,32(sp)
81124700:	dd400717 	ldw	r21,28(sp)
81124704:	dd000617 	ldw	r20,24(sp)
81124708:	dcc00517 	ldw	r19,20(sp)
8112470c:	dc800417 	ldw	r18,16(sp)
81124710:	dc400317 	ldw	r17,12(sp)
81124714:	dc000217 	ldw	r16,8(sp)
81124718:	dec00c04 	addi	sp,sp,48
8112471c:	f800283a 	ret
81124720:	3c3fdc0e 	bge	r7,r16,81124694 <__reset+0xfb104694>
81124724:	01bfffc4 	movi	r6,-1
81124728:	003fdd06 	br	811246a0 <__reset+0xfb1046a0>
8112472c:	00c00dc4 	movi	r3,55
81124730:	003fe506 	br	811246c8 <__reset+0xfb1046c8>
81124734:	00800c04 	movi	r2,48
81124738:	80801626 	beq	r16,r2,81124794 <_strtol_r+0x1fc>
8112473c:	05800284 	movi	r22,10
81124740:	b02f883a 	mov	r23,r22
81124744:	003fba06 	br	81124630 <__reset+0xfb104630>
81124748:	0109c83a 	sub	r4,zero,r4
8112474c:	003fe306 	br	811246dc <__reset+0xfb1046dc>
81124750:	d9000017 	ldw	r4,0(sp)
81124754:	00c00884 	movi	r3,34
81124758:	e005003a 	cmpeq	r2,fp,zero
8112475c:	20c00015 	stw	r3,0(r4)
81124760:	00e00034 	movhi	r3,32768
81124764:	1885c83a 	sub	r2,r3,r2
81124768:	983fe126 	beq	r19,zero,811246f0 <__reset+0xfb1046f0>
8112476c:	297fffc4 	addi	r5,r5,-1
81124770:	003fde06 	br	811246ec <__reset+0xfb1046ec>
81124774:	1c400084 	addi	r17,r3,2
81124778:	1c000043 	ldbu	r16,1(r3)
8112477c:	07000044 	movi	fp,1
81124780:	003fa706 	br	81124620 <__reset+0xfb104620>
81124784:	1c400084 	addi	r17,r3,2
81124788:	1c000043 	ldbu	r16,1(r3)
8112478c:	0039883a 	mov	fp,zero
81124790:	003fa306 	br	81124620 <__reset+0xfb104620>
81124794:	88800003 	ldbu	r2,0(r17)
81124798:	00c01604 	movi	r3,88
8112479c:	108037cc 	andi	r2,r2,223
811247a0:	10c00826 	beq	r2,r3,811247c4 <_strtol_r+0x22c>
811247a4:	05800204 	movi	r22,8
811247a8:	003fa006 	br	8112462c <__reset+0xfb10462c>
811247ac:	00800c04 	movi	r2,48
811247b0:	80bf9e1e 	bne	r16,r2,8112462c <__reset+0xfb10462c>
811247b4:	88800003 	ldbu	r2,0(r17)
811247b8:	00c01604 	movi	r3,88
811247bc:	108037cc 	andi	r2,r2,223
811247c0:	10ff9a1e 	bne	r2,r3,8112462c <__reset+0xfb10462c>
811247c4:	05c00404 	movi	r23,16
811247c8:	8c000043 	ldbu	r16,1(r17)
811247cc:	b82d883a 	mov	r22,r23
811247d0:	8c400084 	addi	r17,r17,2
811247d4:	003f9606 	br	81124630 <__reset+0xfb104630>

811247d8 <strtol>:
811247d8:	00a04574 	movhi	r2,33045
811247dc:	10911304 	addi	r2,r2,17484
811247e0:	300f883a 	mov	r7,r6
811247e4:	280d883a 	mov	r6,r5
811247e8:	200b883a 	mov	r5,r4
811247ec:	11000017 	ldw	r4,0(r2)
811247f0:	11245981 	jmpi	81124598 <_strtol_r>

811247f4 <___svfprintf_internal_r>:
811247f4:	deffb704 	addi	sp,sp,-292
811247f8:	de00012e 	bgeu	sp,et,81124800 <___svfprintf_internal_r+0xc>
811247fc:	003b68fa 	trap	3
81124800:	dfc04815 	stw	ra,288(sp)
81124804:	ddc04615 	stw	r23,280(sp)
81124808:	d9402c15 	stw	r5,176(sp)
8112480c:	d9003915 	stw	r4,228(sp)
81124810:	302f883a 	mov	r23,r6
81124814:	d9c02d15 	stw	r7,180(sp)
81124818:	df004715 	stw	fp,284(sp)
8112481c:	dd804515 	stw	r22,276(sp)
81124820:	dd404415 	stw	r21,272(sp)
81124824:	dd004315 	stw	r20,268(sp)
81124828:	dcc04215 	stw	r19,264(sp)
8112482c:	dc804115 	stw	r18,260(sp)
81124830:	dc404015 	stw	r17,256(sp)
81124834:	dc003f15 	stw	r16,252(sp)
81124838:	112d6dc0 	call	8112d6dc <_localeconv_r>
8112483c:	10800017 	ldw	r2,0(r2)
81124840:	1009883a 	mov	r4,r2
81124844:	d8803415 	stw	r2,208(sp)
81124848:	11244bc0 	call	811244bc <strlen>
8112484c:	d8c02c17 	ldw	r3,176(sp)
81124850:	d8803815 	stw	r2,224(sp)
81124854:	1880030b 	ldhu	r2,12(r3)
81124858:	1080200c 	andi	r2,r2,128
8112485c:	10000226 	beq	r2,zero,81124868 <___svfprintf_internal_r+0x74>
81124860:	18800417 	ldw	r2,16(r3)
81124864:	10067f26 	beq	r2,zero,81126264 <___svfprintf_internal_r+0x1a70>
81124868:	dcc03917 	ldw	r19,228(sp)
8112486c:	d8c00404 	addi	r3,sp,16
81124870:	05604574 	movhi	r21,33045
81124874:	d9001e04 	addi	r4,sp,120
81124878:	ad474b84 	addi	r21,r21,7470
8112487c:	d8c01e15 	stw	r3,120(sp)
81124880:	d8002015 	stw	zero,128(sp)
81124884:	d8001f15 	stw	zero,124(sp)
81124888:	d8003315 	stw	zero,204(sp)
8112488c:	d8003615 	stw	zero,216(sp)
81124890:	d8003715 	stw	zero,220(sp)
81124894:	1811883a 	mov	r8,r3
81124898:	d8003a15 	stw	zero,232(sp)
8112489c:	d8003b15 	stw	zero,236(sp)
811248a0:	d8002f15 	stw	zero,188(sp)
811248a4:	d9002815 	stw	r4,160(sp)
811248a8:	b8800007 	ldb	r2,0(r23)
811248ac:	10026726 	beq	r2,zero,8112524c <___svfprintf_internal_r+0xa58>
811248b0:	00c00944 	movi	r3,37
811248b4:	b821883a 	mov	r16,r23
811248b8:	10c0021e 	bne	r2,r3,811248c4 <___svfprintf_internal_r+0xd0>
811248bc:	00001406 	br	81124910 <___svfprintf_internal_r+0x11c>
811248c0:	10c00326 	beq	r2,r3,811248d0 <___svfprintf_internal_r+0xdc>
811248c4:	84000044 	addi	r16,r16,1
811248c8:	80800007 	ldb	r2,0(r16)
811248cc:	103ffc1e 	bne	r2,zero,811248c0 <__reset+0xfb1048c0>
811248d0:	85e3c83a 	sub	r17,r16,r23
811248d4:	88000e26 	beq	r17,zero,81124910 <___svfprintf_internal_r+0x11c>
811248d8:	d8c02017 	ldw	r3,128(sp)
811248dc:	d8801f17 	ldw	r2,124(sp)
811248e0:	45c00015 	stw	r23,0(r8)
811248e4:	1c47883a 	add	r3,r3,r17
811248e8:	10800044 	addi	r2,r2,1
811248ec:	d8c02015 	stw	r3,128(sp)
811248f0:	44400115 	stw	r17,4(r8)
811248f4:	d8801f15 	stw	r2,124(sp)
811248f8:	00c001c4 	movi	r3,7
811248fc:	18809716 	blt	r3,r2,81124b5c <___svfprintf_internal_r+0x368>
81124900:	42000204 	addi	r8,r8,8
81124904:	d9402f17 	ldw	r5,188(sp)
81124908:	2c4b883a 	add	r5,r5,r17
8112490c:	d9402f15 	stw	r5,188(sp)
81124910:	80800007 	ldb	r2,0(r16)
81124914:	10009826 	beq	r2,zero,81124b78 <___svfprintf_internal_r+0x384>
81124918:	84400047 	ldb	r17,1(r16)
8112491c:	00bfffc4 	movi	r2,-1
81124920:	85c00044 	addi	r23,r16,1
81124924:	d8002785 	stb	zero,158(sp)
81124928:	0007883a 	mov	r3,zero
8112492c:	000f883a 	mov	r7,zero
81124930:	d8802915 	stw	r2,164(sp)
81124934:	d8003115 	stw	zero,196(sp)
81124938:	0025883a 	mov	r18,zero
8112493c:	01401604 	movi	r5,88
81124940:	01800244 	movi	r6,9
81124944:	02800a84 	movi	r10,42
81124948:	02401b04 	movi	r9,108
8112494c:	bdc00044 	addi	r23,r23,1
81124950:	88bff804 	addi	r2,r17,-32
81124954:	2882f036 	bltu	r5,r2,81125518 <___svfprintf_internal_r+0xd24>
81124958:	100490ba 	slli	r2,r2,2
8112495c:	012044b4 	movhi	r4,33042
81124960:	21125c04 	addi	r4,r4,18800
81124964:	1105883a 	add	r2,r2,r4
81124968:	10800017 	ldw	r2,0(r2)
8112496c:	1000683a 	jmp	r2
81124970:	81125480 	call	88112548 <__reset+0x20f2548>
81124974:	81125518 	cmpnei	r4,r16,18772
81124978:	81125518 	cmpnei	r4,r16,18772
8112497c:	81125474 	orhi	r4,r16,18769
81124980:	81125518 	cmpnei	r4,r16,18772
81124984:	81125518 	cmpnei	r4,r16,18772
81124988:	81125518 	cmpnei	r4,r16,18772
8112498c:	81125518 	cmpnei	r4,r16,18772
81124990:	81125518 	cmpnei	r4,r16,18772
81124994:	81125518 	cmpnei	r4,r16,18772
81124998:	81124bd4 	ori	r4,r16,18735
8112499c:	811253b0 	cmpltui	r4,r16,18766
811249a0:	81125518 	cmpnei	r4,r16,18772
811249a4:	81124ae4 	muli	r4,r16,18731
811249a8:	81124bfc 	xorhi	r4,r16,18735
811249ac:	81125518 	cmpnei	r4,r16,18772
811249b0:	81124c70 	cmpltui	r4,r16,18737
811249b4:	81124c3c 	xorhi	r4,r16,18736
811249b8:	81124c3c 	xorhi	r4,r16,18736
811249bc:	81124c3c 	xorhi	r4,r16,18736
811249c0:	81124c3c 	xorhi	r4,r16,18736
811249c4:	81124c3c 	xorhi	r4,r16,18736
811249c8:	81124c3c 	xorhi	r4,r16,18736
811249cc:	81124c3c 	xorhi	r4,r16,18736
811249d0:	81124c3c 	xorhi	r4,r16,18736
811249d4:	81124c3c 	xorhi	r4,r16,18736
811249d8:	81125518 	cmpnei	r4,r16,18772
811249dc:	81125518 	cmpnei	r4,r16,18772
811249e0:	81125518 	cmpnei	r4,r16,18772
811249e4:	81125518 	cmpnei	r4,r16,18772
811249e8:	81125518 	cmpnei	r4,r16,18772
811249ec:	81125518 	cmpnei	r4,r16,18772
811249f0:	81125518 	cmpnei	r4,r16,18772
811249f4:	81125518 	cmpnei	r4,r16,18772
811249f8:	81125518 	cmpnei	r4,r16,18772
811249fc:	81125518 	cmpnei	r4,r16,18772
81124a00:	81124d28 	cmpgeui	r4,r16,18740
81124a04:	81124c7c 	xorhi	r4,r16,18737
81124a08:	81125518 	cmpnei	r4,r16,18772
81124a0c:	81124c7c 	xorhi	r4,r16,18737
81124a10:	81125518 	cmpnei	r4,r16,18772
81124a14:	81125518 	cmpnei	r4,r16,18772
81124a18:	81125518 	cmpnei	r4,r16,18772
81124a1c:	81125518 	cmpnei	r4,r16,18772
81124a20:	81124d1c 	xori	r4,r16,18740
81124a24:	81125518 	cmpnei	r4,r16,18772
81124a28:	81125518 	cmpnei	r4,r16,18772
81124a2c:	81124de4 	muli	r4,r16,18743
81124a30:	81125518 	cmpnei	r4,r16,18772
81124a34:	81125518 	cmpnei	r4,r16,18772
81124a38:	81125518 	cmpnei	r4,r16,18772
81124a3c:	81125518 	cmpnei	r4,r16,18772
81124a40:	81125518 	cmpnei	r4,r16,18772
81124a44:	81125254 	ori	r4,r16,18761
81124a48:	81125518 	cmpnei	r4,r16,18772
81124a4c:	81125518 	cmpnei	r4,r16,18772
81124a50:	811252b4 	orhi	r4,r16,18762
81124a54:	81125518 	cmpnei	r4,r16,18772
81124a58:	81125518 	cmpnei	r4,r16,18772
81124a5c:	81125518 	cmpnei	r4,r16,18772
81124a60:	81125518 	cmpnei	r4,r16,18772
81124a64:	81125518 	cmpnei	r4,r16,18772
81124a68:	81125518 	cmpnei	r4,r16,18772
81124a6c:	81125518 	cmpnei	r4,r16,18772
81124a70:	81125518 	cmpnei	r4,r16,18772
81124a74:	81125518 	cmpnei	r4,r16,18772
81124a78:	81125518 	cmpnei	r4,r16,18772
81124a7c:	81125364 	muli	r4,r16,18765
81124a80:	811254a0 	cmpeqi	r4,r16,18770
81124a84:	81124c7c 	xorhi	r4,r16,18737
81124a88:	81124c7c 	xorhi	r4,r16,18737
81124a8c:	81124c7c 	xorhi	r4,r16,18737
81124a90:	811254f4 	orhi	r4,r16,18771
81124a94:	811254a0 	cmpeqi	r4,r16,18770
81124a98:	81125518 	cmpnei	r4,r16,18772
81124a9c:	81125518 	cmpnei	r4,r16,18772
81124aa0:	811254b0 	cmpltui	r4,r16,18770
81124aa4:	81125518 	cmpnei	r4,r16,18772
81124aa8:	811254c0 	call	8811254c <__reset+0x20f254c>
81124aac:	811253a0 	cmpeqi	r4,r16,18766
81124ab0:	81124af0 	cmpltui	r4,r16,18731
81124ab4:	811253c0 	call	8811253c <__reset+0x20f253c>
81124ab8:	81125518 	cmpnei	r4,r16,18772
81124abc:	811253cc 	andi	r4,r16,18767
81124ac0:	81125518 	cmpnei	r4,r16,18772
81124ac4:	81125428 	cmpgeui	r4,r16,18768
81124ac8:	81125518 	cmpnei	r4,r16,18772
81124acc:	81125518 	cmpnei	r4,r16,18772
81124ad0:	81125438 	rdprs	r4,r16,18768
81124ad4:	d9003117 	ldw	r4,196(sp)
81124ad8:	d8802d15 	stw	r2,180(sp)
81124adc:	0109c83a 	sub	r4,zero,r4
81124ae0:	d9003115 	stw	r4,196(sp)
81124ae4:	94800114 	ori	r18,r18,4
81124ae8:	bc400007 	ldb	r17,0(r23)
81124aec:	003f9706 	br	8112494c <__reset+0xfb10494c>
81124af0:	00800c04 	movi	r2,48
81124af4:	d9002d17 	ldw	r4,180(sp)
81124af8:	d9402917 	ldw	r5,164(sp)
81124afc:	d8802705 	stb	r2,156(sp)
81124b00:	00801e04 	movi	r2,120
81124b04:	d8802745 	stb	r2,157(sp)
81124b08:	d8002785 	stb	zero,158(sp)
81124b0c:	20c00104 	addi	r3,r4,4
81124b10:	25000017 	ldw	r20,0(r4)
81124b14:	002d883a 	mov	r22,zero
81124b18:	90800094 	ori	r2,r18,2
81124b1c:	28028616 	blt	r5,zero,81125538 <___svfprintf_internal_r+0xd44>
81124b20:	00bfdfc4 	movi	r2,-129
81124b24:	90a4703a 	and	r18,r18,r2
81124b28:	d8c02d15 	stw	r3,180(sp)
81124b2c:	94800094 	ori	r18,r18,2
81124b30:	a002731e 	bne	r20,zero,81125500 <___svfprintf_internal_r+0xd0c>
81124b34:	00a04574 	movhi	r2,33045
81124b38:	10874404 	addi	r2,r2,7440
81124b3c:	d8803a15 	stw	r2,232(sp)
81124b40:	04401e04 	movi	r17,120
81124b44:	d8c02917 	ldw	r3,164(sp)
81124b48:	0039883a 	mov	fp,zero
81124b4c:	1801d526 	beq	r3,zero,811252a4 <___svfprintf_internal_r+0xab0>
81124b50:	0029883a 	mov	r20,zero
81124b54:	002d883a 	mov	r22,zero
81124b58:	0001f106 	br	81125320 <___svfprintf_internal_r+0xb2c>
81124b5c:	d9402c17 	ldw	r5,176(sp)
81124b60:	d9801e04 	addi	r6,sp,120
81124b64:	9809883a 	mov	r4,r19
81124b68:	11314140 	call	81131414 <__ssprint_r>
81124b6c:	1000081e 	bne	r2,zero,81124b90 <___svfprintf_internal_r+0x39c>
81124b70:	da000404 	addi	r8,sp,16
81124b74:	003f6306 	br	81124904 <__reset+0xfb104904>
81124b78:	d8802017 	ldw	r2,128(sp)
81124b7c:	10000426 	beq	r2,zero,81124b90 <___svfprintf_internal_r+0x39c>
81124b80:	d9402c17 	ldw	r5,176(sp)
81124b84:	d9003917 	ldw	r4,228(sp)
81124b88:	d9801e04 	addi	r6,sp,120
81124b8c:	11314140 	call	81131414 <__ssprint_r>
81124b90:	d8802c17 	ldw	r2,176(sp)
81124b94:	10c0030b 	ldhu	r3,12(r2)
81124b98:	d8802f17 	ldw	r2,188(sp)
81124b9c:	18c0100c 	andi	r3,r3,64
81124ba0:	1805f51e 	bne	r3,zero,81126378 <___svfprintf_internal_r+0x1b84>
81124ba4:	dfc04817 	ldw	ra,288(sp)
81124ba8:	df004717 	ldw	fp,284(sp)
81124bac:	ddc04617 	ldw	r23,280(sp)
81124bb0:	dd804517 	ldw	r22,276(sp)
81124bb4:	dd404417 	ldw	r21,272(sp)
81124bb8:	dd004317 	ldw	r20,268(sp)
81124bbc:	dcc04217 	ldw	r19,264(sp)
81124bc0:	dc804117 	ldw	r18,260(sp)
81124bc4:	dc404017 	ldw	r17,256(sp)
81124bc8:	dc003f17 	ldw	r16,252(sp)
81124bcc:	dec04904 	addi	sp,sp,292
81124bd0:	f800283a 	ret
81124bd4:	d8802d17 	ldw	r2,180(sp)
81124bd8:	d9002d17 	ldw	r4,180(sp)
81124bdc:	10800017 	ldw	r2,0(r2)
81124be0:	d8803115 	stw	r2,196(sp)
81124be4:	20800104 	addi	r2,r4,4
81124be8:	d9003117 	ldw	r4,196(sp)
81124bec:	203fb916 	blt	r4,zero,81124ad4 <__reset+0xfb104ad4>
81124bf0:	d8802d15 	stw	r2,180(sp)
81124bf4:	bc400007 	ldb	r17,0(r23)
81124bf8:	003f5406 	br	8112494c <__reset+0xfb10494c>
81124bfc:	bc400007 	ldb	r17,0(r23)
81124c00:	bac00044 	addi	r11,r23,1
81124c04:	8a873926 	beq	r17,r10,811268ec <___svfprintf_internal_r+0x20f8>
81124c08:	88bff404 	addi	r2,r17,-48
81124c0c:	0009883a 	mov	r4,zero
81124c10:	30868836 	bltu	r6,r2,81126634 <___svfprintf_internal_r+0x1e40>
81124c14:	5c400007 	ldb	r17,0(r11)
81124c18:	210002a4 	muli	r4,r4,10
81124c1c:	5dc00044 	addi	r23,r11,1
81124c20:	b817883a 	mov	r11,r23
81124c24:	2089883a 	add	r4,r4,r2
81124c28:	88bff404 	addi	r2,r17,-48
81124c2c:	30bff92e 	bgeu	r6,r2,81124c14 <__reset+0xfb104c14>
81124c30:	2005d716 	blt	r4,zero,81126390 <___svfprintf_internal_r+0x1b9c>
81124c34:	d9002915 	stw	r4,164(sp)
81124c38:	003f4506 	br	81124950 <__reset+0xfb104950>
81124c3c:	b809883a 	mov	r4,r23
81124c40:	d8003115 	stw	zero,196(sp)
81124c44:	88bff404 	addi	r2,r17,-48
81124c48:	0017883a 	mov	r11,zero
81124c4c:	24400007 	ldb	r17,0(r4)
81124c50:	5ac002a4 	muli	r11,r11,10
81124c54:	bdc00044 	addi	r23,r23,1
81124c58:	b809883a 	mov	r4,r23
81124c5c:	12d7883a 	add	r11,r2,r11
81124c60:	88bff404 	addi	r2,r17,-48
81124c64:	30bff92e 	bgeu	r6,r2,81124c4c <__reset+0xfb104c4c>
81124c68:	dac03115 	stw	r11,196(sp)
81124c6c:	003f3806 	br	81124950 <__reset+0xfb104950>
81124c70:	94802014 	ori	r18,r18,128
81124c74:	bc400007 	ldb	r17,0(r23)
81124c78:	003f3406 	br	8112494c <__reset+0xfb10494c>
81124c7c:	18c03fcc 	andi	r3,r3,255
81124c80:	1807471e 	bne	r3,zero,811269a0 <___svfprintf_internal_r+0x21ac>
81124c84:	9080020c 	andi	r2,r18,8
81124c88:	10047d26 	beq	r2,zero,81125e80 <___svfprintf_internal_r+0x168c>
81124c8c:	d8c02d17 	ldw	r3,180(sp)
81124c90:	d9002d17 	ldw	r4,180(sp)
81124c94:	d9402d17 	ldw	r5,180(sp)
81124c98:	18c00017 	ldw	r3,0(r3)
81124c9c:	21000117 	ldw	r4,4(r4)
81124ca0:	29400204 	addi	r5,r5,8
81124ca4:	d8c03615 	stw	r3,216(sp)
81124ca8:	d9003715 	stw	r4,220(sp)
81124cac:	d9402d15 	stw	r5,180(sp)
81124cb0:	d9003617 	ldw	r4,216(sp)
81124cb4:	d9403717 	ldw	r5,220(sp)
81124cb8:	da003e15 	stw	r8,248(sp)
81124cbc:	04000044 	movi	r16,1
81124cc0:	112f2280 	call	8112f228 <__fpclassifyd>
81124cc4:	da003e17 	ldw	r8,248(sp)
81124cc8:	14044b1e 	bne	r2,r16,81125df8 <___svfprintf_internal_r+0x1604>
81124ccc:	d9003617 	ldw	r4,216(sp)
81124cd0:	d9403717 	ldw	r5,220(sp)
81124cd4:	000d883a 	mov	r6,zero
81124cd8:	000f883a 	mov	r7,zero
81124cdc:	11374180 	call	81137418 <__ledf2>
81124ce0:	da003e17 	ldw	r8,248(sp)
81124ce4:	1005f316 	blt	r2,zero,811264b4 <___svfprintf_internal_r+0x1cc0>
81124ce8:	df002783 	ldbu	fp,158(sp)
81124cec:	008011c4 	movi	r2,71
81124cf0:	1445590e 	bge	r2,r17,81126258 <___svfprintf_internal_r+0x1a64>
81124cf4:	04204574 	movhi	r16,33045
81124cf8:	84073c04 	addi	r16,r16,7408
81124cfc:	00c000c4 	movi	r3,3
81124d00:	00bfdfc4 	movi	r2,-129
81124d04:	d8c02a15 	stw	r3,168(sp)
81124d08:	90a4703a 	and	r18,r18,r2
81124d0c:	d8c02e15 	stw	r3,184(sp)
81124d10:	d8002915 	stw	zero,164(sp)
81124d14:	d8003215 	stw	zero,200(sp)
81124d18:	00006606 	br	81124eb4 <___svfprintf_internal_r+0x6c0>
81124d1c:	94800214 	ori	r18,r18,8
81124d20:	bc400007 	ldb	r17,0(r23)
81124d24:	003f0906 	br	8112494c <__reset+0xfb10494c>
81124d28:	18c03fcc 	andi	r3,r3,255
81124d2c:	1807181e 	bne	r3,zero,81126990 <___svfprintf_internal_r+0x219c>
81124d30:	94800414 	ori	r18,r18,16
81124d34:	9080080c 	andi	r2,r18,32
81124d38:	10039626 	beq	r2,zero,81125b94 <___svfprintf_internal_r+0x13a0>
81124d3c:	d9402d17 	ldw	r5,180(sp)
81124d40:	28800117 	ldw	r2,4(r5)
81124d44:	2d000017 	ldw	r20,0(r5)
81124d48:	29400204 	addi	r5,r5,8
81124d4c:	d9402d15 	stw	r5,180(sp)
81124d50:	102d883a 	mov	r22,r2
81124d54:	10039816 	blt	r2,zero,81125bb8 <___svfprintf_internal_r+0x13c4>
81124d58:	d9402917 	ldw	r5,164(sp)
81124d5c:	df002783 	ldbu	fp,158(sp)
81124d60:	2803ab16 	blt	r5,zero,81125c10 <___svfprintf_internal_r+0x141c>
81124d64:	00ffdfc4 	movi	r3,-129
81124d68:	a584b03a 	or	r2,r20,r22
81124d6c:	90e4703a 	and	r18,r18,r3
81124d70:	10014a26 	beq	r2,zero,8112529c <___svfprintf_internal_r+0xaa8>
81124d74:	b0034b26 	beq	r22,zero,81125aa4 <___svfprintf_internal_r+0x12b0>
81124d78:	dc402a15 	stw	r17,168(sp)
81124d7c:	dc001e04 	addi	r16,sp,120
81124d80:	b023883a 	mov	r17,r22
81124d84:	402d883a 	mov	r22,r8
81124d88:	a009883a 	mov	r4,r20
81124d8c:	880b883a 	mov	r5,r17
81124d90:	01800284 	movi	r6,10
81124d94:	000f883a 	mov	r7,zero
81124d98:	11358fc0 	call	811358fc <__umoddi3>
81124d9c:	10800c04 	addi	r2,r2,48
81124da0:	843fffc4 	addi	r16,r16,-1
81124da4:	a009883a 	mov	r4,r20
81124da8:	880b883a 	mov	r5,r17
81124dac:	80800005 	stb	r2,0(r16)
81124db0:	01800284 	movi	r6,10
81124db4:	000f883a 	mov	r7,zero
81124db8:	113537c0 	call	8113537c <__udivdi3>
81124dbc:	1029883a 	mov	r20,r2
81124dc0:	10c4b03a 	or	r2,r2,r3
81124dc4:	1823883a 	mov	r17,r3
81124dc8:	103fef1e 	bne	r2,zero,81124d88 <__reset+0xfb104d88>
81124dcc:	d8c02817 	ldw	r3,160(sp)
81124dd0:	dc402a17 	ldw	r17,168(sp)
81124dd4:	b011883a 	mov	r8,r22
81124dd8:	1c07c83a 	sub	r3,r3,r16
81124ddc:	d8c02e15 	stw	r3,184(sp)
81124de0:	00002e06 	br	81124e9c <___svfprintf_internal_r+0x6a8>
81124de4:	18c03fcc 	andi	r3,r3,255
81124de8:	1806e71e 	bne	r3,zero,81126988 <___svfprintf_internal_r+0x2194>
81124dec:	94800414 	ori	r18,r18,16
81124df0:	9080080c 	andi	r2,r18,32
81124df4:	1002d426 	beq	r2,zero,81125948 <___svfprintf_internal_r+0x1154>
81124df8:	d9402d17 	ldw	r5,180(sp)
81124dfc:	d8c02917 	ldw	r3,164(sp)
81124e00:	d8002785 	stb	zero,158(sp)
81124e04:	28800204 	addi	r2,r5,8
81124e08:	2d000017 	ldw	r20,0(r5)
81124e0c:	2d800117 	ldw	r22,4(r5)
81124e10:	18041516 	blt	r3,zero,81125e68 <___svfprintf_internal_r+0x1674>
81124e14:	013fdfc4 	movi	r4,-129
81124e18:	a586b03a 	or	r3,r20,r22
81124e1c:	d8802d15 	stw	r2,180(sp)
81124e20:	9124703a 	and	r18,r18,r4
81124e24:	1802d51e 	bne	r3,zero,8112597c <___svfprintf_internal_r+0x1188>
81124e28:	d9402917 	ldw	r5,164(sp)
81124e2c:	0039883a 	mov	fp,zero
81124e30:	2806be26 	beq	r5,zero,8112692c <___svfprintf_internal_r+0x2138>
81124e34:	0029883a 	mov	r20,zero
81124e38:	002d883a 	mov	r22,zero
81124e3c:	dc001e04 	addi	r16,sp,120
81124e40:	a006d0fa 	srli	r3,r20,3
81124e44:	b008977a 	slli	r4,r22,29
81124e48:	b02cd0fa 	srli	r22,r22,3
81124e4c:	a50001cc 	andi	r20,r20,7
81124e50:	a0800c04 	addi	r2,r20,48
81124e54:	843fffc4 	addi	r16,r16,-1
81124e58:	20e8b03a 	or	r20,r4,r3
81124e5c:	80800005 	stb	r2,0(r16)
81124e60:	a586b03a 	or	r3,r20,r22
81124e64:	183ff61e 	bne	r3,zero,81124e40 <__reset+0xfb104e40>
81124e68:	90c0004c 	andi	r3,r18,1
81124e6c:	18013926 	beq	r3,zero,81125354 <___svfprintf_internal_r+0xb60>
81124e70:	10803fcc 	andi	r2,r2,255
81124e74:	1080201c 	xori	r2,r2,128
81124e78:	10bfe004 	addi	r2,r2,-128
81124e7c:	00c00c04 	movi	r3,48
81124e80:	10c13426 	beq	r2,r3,81125354 <___svfprintf_internal_r+0xb60>
81124e84:	80ffffc5 	stb	r3,-1(r16)
81124e88:	d8c02817 	ldw	r3,160(sp)
81124e8c:	80bfffc4 	addi	r2,r16,-1
81124e90:	1021883a 	mov	r16,r2
81124e94:	1887c83a 	sub	r3,r3,r2
81124e98:	d8c02e15 	stw	r3,184(sp)
81124e9c:	d8802e17 	ldw	r2,184(sp)
81124ea0:	d9002917 	ldw	r4,164(sp)
81124ea4:	1100010e 	bge	r2,r4,81124eac <___svfprintf_internal_r+0x6b8>
81124ea8:	2005883a 	mov	r2,r4
81124eac:	d8802a15 	stw	r2,168(sp)
81124eb0:	d8003215 	stw	zero,200(sp)
81124eb4:	e7003fcc 	andi	fp,fp,255
81124eb8:	e700201c 	xori	fp,fp,128
81124ebc:	e73fe004 	addi	fp,fp,-128
81124ec0:	e0000326 	beq	fp,zero,81124ed0 <___svfprintf_internal_r+0x6dc>
81124ec4:	d8c02a17 	ldw	r3,168(sp)
81124ec8:	18c00044 	addi	r3,r3,1
81124ecc:	d8c02a15 	stw	r3,168(sp)
81124ed0:	90c0008c 	andi	r3,r18,2
81124ed4:	d8c02b15 	stw	r3,172(sp)
81124ed8:	18000326 	beq	r3,zero,81124ee8 <___svfprintf_internal_r+0x6f4>
81124edc:	d8c02a17 	ldw	r3,168(sp)
81124ee0:	18c00084 	addi	r3,r3,2
81124ee4:	d8c02a15 	stw	r3,168(sp)
81124ee8:	90c0210c 	andi	r3,r18,132
81124eec:	d8c03015 	stw	r3,192(sp)
81124ef0:	1801a11e 	bne	r3,zero,81125578 <___svfprintf_internal_r+0xd84>
81124ef4:	d9003117 	ldw	r4,196(sp)
81124ef8:	d8c02a17 	ldw	r3,168(sp)
81124efc:	20e9c83a 	sub	r20,r4,r3
81124f00:	05019d0e 	bge	zero,r20,81125578 <___svfprintf_internal_r+0xd84>
81124f04:	02400404 	movi	r9,16
81124f08:	d8c02017 	ldw	r3,128(sp)
81124f0c:	d8801f17 	ldw	r2,124(sp)
81124f10:	4d051b0e 	bge	r9,r20,81126380 <___svfprintf_internal_r+0x1b8c>
81124f14:	01604574 	movhi	r5,33045
81124f18:	29474f84 	addi	r5,r5,7486
81124f1c:	dc403c15 	stw	r17,240(sp)
81124f20:	d9403515 	stw	r5,212(sp)
81124f24:	a023883a 	mov	r17,r20
81124f28:	482d883a 	mov	r22,r9
81124f2c:	9029883a 	mov	r20,r18
81124f30:	070001c4 	movi	fp,7
81124f34:	8025883a 	mov	r18,r16
81124f38:	dc002c17 	ldw	r16,176(sp)
81124f3c:	00000306 	br	81124f4c <___svfprintf_internal_r+0x758>
81124f40:	8c7ffc04 	addi	r17,r17,-16
81124f44:	42000204 	addi	r8,r8,8
81124f48:	b440130e 	bge	r22,r17,81124f98 <___svfprintf_internal_r+0x7a4>
81124f4c:	01204574 	movhi	r4,33045
81124f50:	18c00404 	addi	r3,r3,16
81124f54:	10800044 	addi	r2,r2,1
81124f58:	21074f84 	addi	r4,r4,7486
81124f5c:	41000015 	stw	r4,0(r8)
81124f60:	45800115 	stw	r22,4(r8)
81124f64:	d8c02015 	stw	r3,128(sp)
81124f68:	d8801f15 	stw	r2,124(sp)
81124f6c:	e0bff40e 	bge	fp,r2,81124f40 <__reset+0xfb104f40>
81124f70:	d9801e04 	addi	r6,sp,120
81124f74:	800b883a 	mov	r5,r16
81124f78:	9809883a 	mov	r4,r19
81124f7c:	11314140 	call	81131414 <__ssprint_r>
81124f80:	103f031e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81124f84:	8c7ffc04 	addi	r17,r17,-16
81124f88:	d8c02017 	ldw	r3,128(sp)
81124f8c:	d8801f17 	ldw	r2,124(sp)
81124f90:	da000404 	addi	r8,sp,16
81124f94:	b47fed16 	blt	r22,r17,81124f4c <__reset+0xfb104f4c>
81124f98:	9021883a 	mov	r16,r18
81124f9c:	a025883a 	mov	r18,r20
81124fa0:	8829883a 	mov	r20,r17
81124fa4:	dc403c17 	ldw	r17,240(sp)
81124fa8:	d9403517 	ldw	r5,212(sp)
81124fac:	a0c7883a 	add	r3,r20,r3
81124fb0:	10800044 	addi	r2,r2,1
81124fb4:	41400015 	stw	r5,0(r8)
81124fb8:	45000115 	stw	r20,4(r8)
81124fbc:	d8c02015 	stw	r3,128(sp)
81124fc0:	d8801f15 	stw	r2,124(sp)
81124fc4:	010001c4 	movi	r4,7
81124fc8:	20829f16 	blt	r4,r2,81125a48 <___svfprintf_internal_r+0x1254>
81124fcc:	df002787 	ldb	fp,158(sp)
81124fd0:	42000204 	addi	r8,r8,8
81124fd4:	e0000c26 	beq	fp,zero,81125008 <___svfprintf_internal_r+0x814>
81124fd8:	d8801f17 	ldw	r2,124(sp)
81124fdc:	d9002784 	addi	r4,sp,158
81124fe0:	18c00044 	addi	r3,r3,1
81124fe4:	10800044 	addi	r2,r2,1
81124fe8:	41000015 	stw	r4,0(r8)
81124fec:	01000044 	movi	r4,1
81124ff0:	41000115 	stw	r4,4(r8)
81124ff4:	d8c02015 	stw	r3,128(sp)
81124ff8:	d8801f15 	stw	r2,124(sp)
81124ffc:	010001c4 	movi	r4,7
81125000:	20823816 	blt	r4,r2,811258e4 <___svfprintf_internal_r+0x10f0>
81125004:	42000204 	addi	r8,r8,8
81125008:	d8802b17 	ldw	r2,172(sp)
8112500c:	10000c26 	beq	r2,zero,81125040 <___svfprintf_internal_r+0x84c>
81125010:	d8801f17 	ldw	r2,124(sp)
81125014:	d9002704 	addi	r4,sp,156
81125018:	18c00084 	addi	r3,r3,2
8112501c:	10800044 	addi	r2,r2,1
81125020:	41000015 	stw	r4,0(r8)
81125024:	01000084 	movi	r4,2
81125028:	41000115 	stw	r4,4(r8)
8112502c:	d8c02015 	stw	r3,128(sp)
81125030:	d8801f15 	stw	r2,124(sp)
81125034:	010001c4 	movi	r4,7
81125038:	20823216 	blt	r4,r2,81125904 <___svfprintf_internal_r+0x1110>
8112503c:	42000204 	addi	r8,r8,8
81125040:	d9003017 	ldw	r4,192(sp)
81125044:	00802004 	movi	r2,128
81125048:	20819726 	beq	r4,r2,811256a8 <___svfprintf_internal_r+0xeb4>
8112504c:	d9402917 	ldw	r5,164(sp)
81125050:	d8802e17 	ldw	r2,184(sp)
81125054:	28adc83a 	sub	r22,r5,r2
81125058:	05802f0e 	bge	zero,r22,81125118 <___svfprintf_internal_r+0x924>
8112505c:	07000404 	movi	fp,16
81125060:	d8801f17 	ldw	r2,124(sp)
81125064:	e583c00e 	bge	fp,r22,81125f68 <___svfprintf_internal_r+0x1774>
81125068:	01604574 	movhi	r5,33045
8112506c:	29474b84 	addi	r5,r5,7470
81125070:	dc402915 	stw	r17,164(sp)
81125074:	d9402b15 	stw	r5,172(sp)
81125078:	b023883a 	mov	r17,r22
8112507c:	050001c4 	movi	r20,7
81125080:	902d883a 	mov	r22,r18
81125084:	8025883a 	mov	r18,r16
81125088:	dc002c17 	ldw	r16,176(sp)
8112508c:	00000306 	br	8112509c <___svfprintf_internal_r+0x8a8>
81125090:	8c7ffc04 	addi	r17,r17,-16
81125094:	42000204 	addi	r8,r8,8
81125098:	e440110e 	bge	fp,r17,811250e0 <___svfprintf_internal_r+0x8ec>
8112509c:	18c00404 	addi	r3,r3,16
811250a0:	10800044 	addi	r2,r2,1
811250a4:	45400015 	stw	r21,0(r8)
811250a8:	47000115 	stw	fp,4(r8)
811250ac:	d8c02015 	stw	r3,128(sp)
811250b0:	d8801f15 	stw	r2,124(sp)
811250b4:	a0bff60e 	bge	r20,r2,81125090 <__reset+0xfb105090>
811250b8:	d9801e04 	addi	r6,sp,120
811250bc:	800b883a 	mov	r5,r16
811250c0:	9809883a 	mov	r4,r19
811250c4:	11314140 	call	81131414 <__ssprint_r>
811250c8:	103eb11e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811250cc:	8c7ffc04 	addi	r17,r17,-16
811250d0:	d8c02017 	ldw	r3,128(sp)
811250d4:	d8801f17 	ldw	r2,124(sp)
811250d8:	da000404 	addi	r8,sp,16
811250dc:	e47fef16 	blt	fp,r17,8112509c <__reset+0xfb10509c>
811250e0:	9021883a 	mov	r16,r18
811250e4:	b025883a 	mov	r18,r22
811250e8:	882d883a 	mov	r22,r17
811250ec:	dc402917 	ldw	r17,164(sp)
811250f0:	d9002b17 	ldw	r4,172(sp)
811250f4:	1d87883a 	add	r3,r3,r22
811250f8:	10800044 	addi	r2,r2,1
811250fc:	41000015 	stw	r4,0(r8)
81125100:	45800115 	stw	r22,4(r8)
81125104:	d8c02015 	stw	r3,128(sp)
81125108:	d8801f15 	stw	r2,124(sp)
8112510c:	010001c4 	movi	r4,7
81125110:	2081ec16 	blt	r4,r2,811258c4 <___svfprintf_internal_r+0x10d0>
81125114:	42000204 	addi	r8,r8,8
81125118:	9080400c 	andi	r2,r18,256
8112511c:	1001181e 	bne	r2,zero,81125580 <___svfprintf_internal_r+0xd8c>
81125120:	d9402e17 	ldw	r5,184(sp)
81125124:	d8801f17 	ldw	r2,124(sp)
81125128:	44000015 	stw	r16,0(r8)
8112512c:	1947883a 	add	r3,r3,r5
81125130:	10800044 	addi	r2,r2,1
81125134:	41400115 	stw	r5,4(r8)
81125138:	d8c02015 	stw	r3,128(sp)
8112513c:	d8801f15 	stw	r2,124(sp)
81125140:	010001c4 	movi	r4,7
81125144:	2081d116 	blt	r4,r2,8112588c <___svfprintf_internal_r+0x1098>
81125148:	42000204 	addi	r8,r8,8
8112514c:	9480010c 	andi	r18,r18,4
81125150:	90003226 	beq	r18,zero,8112521c <___svfprintf_internal_r+0xa28>
81125154:	d9403117 	ldw	r5,196(sp)
81125158:	d8802a17 	ldw	r2,168(sp)
8112515c:	28a1c83a 	sub	r16,r5,r2
81125160:	04002e0e 	bge	zero,r16,8112521c <___svfprintf_internal_r+0xa28>
81125164:	04400404 	movi	r17,16
81125168:	d8801f17 	ldw	r2,124(sp)
8112516c:	8c04b90e 	bge	r17,r16,81126454 <___svfprintf_internal_r+0x1c60>
81125170:	01604574 	movhi	r5,33045
81125174:	29474f84 	addi	r5,r5,7486
81125178:	d9403515 	stw	r5,212(sp)
8112517c:	048001c4 	movi	r18,7
81125180:	dd002c17 	ldw	r20,176(sp)
81125184:	00000306 	br	81125194 <___svfprintf_internal_r+0x9a0>
81125188:	843ffc04 	addi	r16,r16,-16
8112518c:	42000204 	addi	r8,r8,8
81125190:	8c00130e 	bge	r17,r16,811251e0 <___svfprintf_internal_r+0x9ec>
81125194:	01204574 	movhi	r4,33045
81125198:	18c00404 	addi	r3,r3,16
8112519c:	10800044 	addi	r2,r2,1
811251a0:	21074f84 	addi	r4,r4,7486
811251a4:	41000015 	stw	r4,0(r8)
811251a8:	44400115 	stw	r17,4(r8)
811251ac:	d8c02015 	stw	r3,128(sp)
811251b0:	d8801f15 	stw	r2,124(sp)
811251b4:	90bff40e 	bge	r18,r2,81125188 <__reset+0xfb105188>
811251b8:	d9801e04 	addi	r6,sp,120
811251bc:	a00b883a 	mov	r5,r20
811251c0:	9809883a 	mov	r4,r19
811251c4:	11314140 	call	81131414 <__ssprint_r>
811251c8:	103e711e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811251cc:	843ffc04 	addi	r16,r16,-16
811251d0:	d8c02017 	ldw	r3,128(sp)
811251d4:	d8801f17 	ldw	r2,124(sp)
811251d8:	da000404 	addi	r8,sp,16
811251dc:	8c3fed16 	blt	r17,r16,81125194 <__reset+0xfb105194>
811251e0:	d9403517 	ldw	r5,212(sp)
811251e4:	1c07883a 	add	r3,r3,r16
811251e8:	10800044 	addi	r2,r2,1
811251ec:	41400015 	stw	r5,0(r8)
811251f0:	44000115 	stw	r16,4(r8)
811251f4:	d8c02015 	stw	r3,128(sp)
811251f8:	d8801f15 	stw	r2,124(sp)
811251fc:	010001c4 	movi	r4,7
81125200:	2080060e 	bge	r4,r2,8112521c <___svfprintf_internal_r+0xa28>
81125204:	d9402c17 	ldw	r5,176(sp)
81125208:	d9801e04 	addi	r6,sp,120
8112520c:	9809883a 	mov	r4,r19
81125210:	11314140 	call	81131414 <__ssprint_r>
81125214:	103e5e1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125218:	d8c02017 	ldw	r3,128(sp)
8112521c:	d8803117 	ldw	r2,196(sp)
81125220:	d9002a17 	ldw	r4,168(sp)
81125224:	1100010e 	bge	r2,r4,8112522c <___svfprintf_internal_r+0xa38>
81125228:	2005883a 	mov	r2,r4
8112522c:	d9402f17 	ldw	r5,188(sp)
81125230:	288b883a 	add	r5,r5,r2
81125234:	d9402f15 	stw	r5,188(sp)
81125238:	18019c1e 	bne	r3,zero,811258ac <___svfprintf_internal_r+0x10b8>
8112523c:	b8800007 	ldb	r2,0(r23)
81125240:	d8001f15 	stw	zero,124(sp)
81125244:	da000404 	addi	r8,sp,16
81125248:	103d991e 	bne	r2,zero,811248b0 <__reset+0xfb1048b0>
8112524c:	b821883a 	mov	r16,r23
81125250:	003daf06 	br	81124910 <__reset+0xfb104910>
81125254:	18c03fcc 	andi	r3,r3,255
81125258:	1805c71e 	bne	r3,zero,81126978 <___svfprintf_internal_r+0x2184>
8112525c:	94800414 	ori	r18,r18,16
81125260:	9080080c 	andi	r2,r18,32
81125264:	10020126 	beq	r2,zero,81125a6c <___svfprintf_internal_r+0x1278>
81125268:	d8802d17 	ldw	r2,180(sp)
8112526c:	d9002917 	ldw	r4,164(sp)
81125270:	d8002785 	stb	zero,158(sp)
81125274:	10c00204 	addi	r3,r2,8
81125278:	15000017 	ldw	r20,0(r2)
8112527c:	15800117 	ldw	r22,4(r2)
81125280:	20038e16 	blt	r4,zero,811260bc <___svfprintf_internal_r+0x18c8>
81125284:	013fdfc4 	movi	r4,-129
81125288:	a584b03a 	or	r2,r20,r22
8112528c:	d8c02d15 	stw	r3,180(sp)
81125290:	9124703a 	and	r18,r18,r4
81125294:	0039883a 	mov	fp,zero
81125298:	103eb61e 	bne	r2,zero,81124d74 <__reset+0xfb104d74>
8112529c:	d8802917 	ldw	r2,164(sp)
811252a0:	1002c81e 	bne	r2,zero,81125dc4 <___svfprintf_internal_r+0x15d0>
811252a4:	d8002915 	stw	zero,164(sp)
811252a8:	d8002e15 	stw	zero,184(sp)
811252ac:	dc001e04 	addi	r16,sp,120
811252b0:	003efa06 	br	81124e9c <__reset+0xfb104e9c>
811252b4:	18c03fcc 	andi	r3,r3,255
811252b8:	1805ad1e 	bne	r3,zero,81126970 <___svfprintf_internal_r+0x217c>
811252bc:	01604574 	movhi	r5,33045
811252c0:	29473f04 	addi	r5,r5,7420
811252c4:	d9403a15 	stw	r5,232(sp)
811252c8:	9080080c 	andi	r2,r18,32
811252cc:	10006126 	beq	r2,zero,81125454 <___svfprintf_internal_r+0xc60>
811252d0:	d8802d17 	ldw	r2,180(sp)
811252d4:	15000017 	ldw	r20,0(r2)
811252d8:	15800117 	ldw	r22,4(r2)
811252dc:	10800204 	addi	r2,r2,8
811252e0:	d8802d15 	stw	r2,180(sp)
811252e4:	9080004c 	andi	r2,r18,1
811252e8:	10018e26 	beq	r2,zero,81125924 <___svfprintf_internal_r+0x1130>
811252ec:	a584b03a 	or	r2,r20,r22
811252f0:	10030926 	beq	r2,zero,81125f18 <___svfprintf_internal_r+0x1724>
811252f4:	d8c02917 	ldw	r3,164(sp)
811252f8:	00800c04 	movi	r2,48
811252fc:	d8802705 	stb	r2,156(sp)
81125300:	dc402745 	stb	r17,157(sp)
81125304:	d8002785 	stb	zero,158(sp)
81125308:	90800094 	ori	r2,r18,2
8112530c:	18048716 	blt	r3,zero,8112652c <___svfprintf_internal_r+0x1d38>
81125310:	00bfdfc4 	movi	r2,-129
81125314:	90a4703a 	and	r18,r18,r2
81125318:	94800094 	ori	r18,r18,2
8112531c:	0039883a 	mov	fp,zero
81125320:	d9003a17 	ldw	r4,232(sp)
81125324:	dc001e04 	addi	r16,sp,120
81125328:	a08003cc 	andi	r2,r20,15
8112532c:	b006973a 	slli	r3,r22,28
81125330:	2085883a 	add	r2,r4,r2
81125334:	a028d13a 	srli	r20,r20,4
81125338:	10800003 	ldbu	r2,0(r2)
8112533c:	b02cd13a 	srli	r22,r22,4
81125340:	843fffc4 	addi	r16,r16,-1
81125344:	1d28b03a 	or	r20,r3,r20
81125348:	80800005 	stb	r2,0(r16)
8112534c:	a584b03a 	or	r2,r20,r22
81125350:	103ff51e 	bne	r2,zero,81125328 <__reset+0xfb105328>
81125354:	d8c02817 	ldw	r3,160(sp)
81125358:	1c07c83a 	sub	r3,r3,r16
8112535c:	d8c02e15 	stw	r3,184(sp)
81125360:	003ece06 	br	81124e9c <__reset+0xfb104e9c>
81125364:	d8c02d17 	ldw	r3,180(sp)
81125368:	d9002d17 	ldw	r4,180(sp)
8112536c:	d8002785 	stb	zero,158(sp)
81125370:	18800017 	ldw	r2,0(r3)
81125374:	21000104 	addi	r4,r4,4
81125378:	00c00044 	movi	r3,1
8112537c:	d8c02a15 	stw	r3,168(sp)
81125380:	d8801405 	stb	r2,80(sp)
81125384:	d9002d15 	stw	r4,180(sp)
81125388:	d8c02e15 	stw	r3,184(sp)
8112538c:	d8002915 	stw	zero,164(sp)
81125390:	d8003215 	stw	zero,200(sp)
81125394:	dc001404 	addi	r16,sp,80
81125398:	0039883a 	mov	fp,zero
8112539c:	003ecc06 	br	81124ed0 <__reset+0xfb104ed0>
811253a0:	18c03fcc 	andi	r3,r3,255
811253a4:	183e9226 	beq	r3,zero,81124df0 <__reset+0xfb104df0>
811253a8:	d9c02785 	stb	r7,158(sp)
811253ac:	003e9006 	br	81124df0 <__reset+0xfb104df0>
811253b0:	00c00044 	movi	r3,1
811253b4:	01c00ac4 	movi	r7,43
811253b8:	bc400007 	ldb	r17,0(r23)
811253bc:	003d6306 	br	8112494c <__reset+0xfb10494c>
811253c0:	94800814 	ori	r18,r18,32
811253c4:	bc400007 	ldb	r17,0(r23)
811253c8:	003d6006 	br	8112494c <__reset+0xfb10494c>
811253cc:	d8c02d17 	ldw	r3,180(sp)
811253d0:	d8002785 	stb	zero,158(sp)
811253d4:	1c000017 	ldw	r16,0(r3)
811253d8:	1d000104 	addi	r20,r3,4
811253dc:	80040f26 	beq	r16,zero,8112641c <___svfprintf_internal_r+0x1c28>
811253e0:	d9002917 	ldw	r4,164(sp)
811253e4:	2003dc16 	blt	r4,zero,81126358 <___svfprintf_internal_r+0x1b64>
811253e8:	200d883a 	mov	r6,r4
811253ec:	000b883a 	mov	r5,zero
811253f0:	8009883a 	mov	r4,r16
811253f4:	da003e15 	stw	r8,248(sp)
811253f8:	112d9b80 	call	8112d9b8 <memchr>
811253fc:	da003e17 	ldw	r8,248(sp)
81125400:	10045826 	beq	r2,zero,81126564 <___svfprintf_internal_r+0x1d70>
81125404:	1405c83a 	sub	r2,r2,r16
81125408:	d8802e15 	stw	r2,184(sp)
8112540c:	1003d816 	blt	r2,zero,81126370 <___svfprintf_internal_r+0x1b7c>
81125410:	df002783 	ldbu	fp,158(sp)
81125414:	d8802a15 	stw	r2,168(sp)
81125418:	dd002d15 	stw	r20,180(sp)
8112541c:	d8002915 	stw	zero,164(sp)
81125420:	d8003215 	stw	zero,200(sp)
81125424:	003ea306 	br	81124eb4 <__reset+0xfb104eb4>
81125428:	18c03fcc 	andi	r3,r3,255
8112542c:	183f8c26 	beq	r3,zero,81125260 <__reset+0xfb105260>
81125430:	d9c02785 	stb	r7,158(sp)
81125434:	003f8a06 	br	81125260 <__reset+0xfb105260>
81125438:	18c03fcc 	andi	r3,r3,255
8112543c:	1805631e 	bne	r3,zero,811269cc <___svfprintf_internal_r+0x21d8>
81125440:	01604574 	movhi	r5,33045
81125444:	29474404 	addi	r5,r5,7440
81125448:	d9403a15 	stw	r5,232(sp)
8112544c:	9080080c 	andi	r2,r18,32
81125450:	103f9f1e 	bne	r2,zero,811252d0 <__reset+0xfb1052d0>
81125454:	9080040c 	andi	r2,r18,16
81125458:	10029c26 	beq	r2,zero,81125ecc <___svfprintf_internal_r+0x16d8>
8112545c:	d8c02d17 	ldw	r3,180(sp)
81125460:	002d883a 	mov	r22,zero
81125464:	1d000017 	ldw	r20,0(r3)
81125468:	18c00104 	addi	r3,r3,4
8112546c:	d8c02d15 	stw	r3,180(sp)
81125470:	003f9c06 	br	811252e4 <__reset+0xfb1052e4>
81125474:	94800054 	ori	r18,r18,1
81125478:	bc400007 	ldb	r17,0(r23)
8112547c:	003d3306 	br	8112494c <__reset+0xfb10494c>
81125480:	38803fcc 	andi	r2,r7,255
81125484:	1080201c 	xori	r2,r2,128
81125488:	10bfe004 	addi	r2,r2,-128
8112548c:	1002971e 	bne	r2,zero,81125eec <___svfprintf_internal_r+0x16f8>
81125490:	00c00044 	movi	r3,1
81125494:	01c00804 	movi	r7,32
81125498:	bc400007 	ldb	r17,0(r23)
8112549c:	003d2b06 	br	8112494c <__reset+0xfb10494c>
811254a0:	18c03fcc 	andi	r3,r3,255
811254a4:	183e2326 	beq	r3,zero,81124d34 <__reset+0xfb104d34>
811254a8:	d9c02785 	stb	r7,158(sp)
811254ac:	003e2106 	br	81124d34 <__reset+0xfb104d34>
811254b0:	bc400007 	ldb	r17,0(r23)
811254b4:	8a430426 	beq	r17,r9,811260c8 <___svfprintf_internal_r+0x18d4>
811254b8:	94800414 	ori	r18,r18,16
811254bc:	003d2306 	br	8112494c <__reset+0xfb10494c>
811254c0:	18c03fcc 	andi	r3,r3,255
811254c4:	18053f1e 	bne	r3,zero,811269c4 <___svfprintf_internal_r+0x21d0>
811254c8:	9080080c 	andi	r2,r18,32
811254cc:	10028926 	beq	r2,zero,81125ef4 <___svfprintf_internal_r+0x1700>
811254d0:	d9402d17 	ldw	r5,180(sp)
811254d4:	d9002f17 	ldw	r4,188(sp)
811254d8:	28800017 	ldw	r2,0(r5)
811254dc:	2007d7fa 	srai	r3,r4,31
811254e0:	29400104 	addi	r5,r5,4
811254e4:	d9402d15 	stw	r5,180(sp)
811254e8:	11000015 	stw	r4,0(r2)
811254ec:	10c00115 	stw	r3,4(r2)
811254f0:	003ced06 	br	811248a8 <__reset+0xfb1048a8>
811254f4:	94801014 	ori	r18,r18,64
811254f8:	bc400007 	ldb	r17,0(r23)
811254fc:	003d1306 	br	8112494c <__reset+0xfb10494c>
81125500:	01204574 	movhi	r4,33045
81125504:	21074404 	addi	r4,r4,7440
81125508:	0039883a 	mov	fp,zero
8112550c:	d9003a15 	stw	r4,232(sp)
81125510:	04401e04 	movi	r17,120
81125514:	003f8206 	br	81125320 <__reset+0xfb105320>
81125518:	18c03fcc 	andi	r3,r3,255
8112551c:	1805221e 	bne	r3,zero,811269a8 <___svfprintf_internal_r+0x21b4>
81125520:	883d9526 	beq	r17,zero,81124b78 <__reset+0xfb104b78>
81125524:	00c00044 	movi	r3,1
81125528:	d8c02a15 	stw	r3,168(sp)
8112552c:	dc401405 	stb	r17,80(sp)
81125530:	d8002785 	stb	zero,158(sp)
81125534:	003f9406 	br	81125388 <__reset+0xfb105388>
81125538:	01204574 	movhi	r4,33045
8112553c:	21074404 	addi	r4,r4,7440
81125540:	d9003a15 	stw	r4,232(sp)
81125544:	d8c02d15 	stw	r3,180(sp)
81125548:	1025883a 	mov	r18,r2
8112554c:	04401e04 	movi	r17,120
81125550:	a584b03a 	or	r2,r20,r22
81125554:	1000fa1e 	bne	r2,zero,81125940 <___svfprintf_internal_r+0x114c>
81125558:	0039883a 	mov	fp,zero
8112555c:	00800084 	movi	r2,2
81125560:	10803fcc 	andi	r2,r2,255
81125564:	00c00044 	movi	r3,1
81125568:	10c21626 	beq	r2,r3,81125dc4 <___svfprintf_internal_r+0x15d0>
8112556c:	00c00084 	movi	r3,2
81125570:	10fe301e 	bne	r2,r3,81124e34 <__reset+0xfb104e34>
81125574:	003d7606 	br	81124b50 <__reset+0xfb104b50>
81125578:	d8c02017 	ldw	r3,128(sp)
8112557c:	003e9506 	br	81124fd4 <__reset+0xfb104fd4>
81125580:	00801944 	movi	r2,101
81125584:	14407c0e 	bge	r2,r17,81125778 <___svfprintf_internal_r+0xf84>
81125588:	d9003617 	ldw	r4,216(sp)
8112558c:	d9403717 	ldw	r5,220(sp)
81125590:	000d883a 	mov	r6,zero
81125594:	000f883a 	mov	r7,zero
81125598:	d8c03d15 	stw	r3,244(sp)
8112559c:	da003e15 	stw	r8,248(sp)
811255a0:	11373900 	call	81137390 <__eqdf2>
811255a4:	d8c03d17 	ldw	r3,244(sp)
811255a8:	da003e17 	ldw	r8,248(sp)
811255ac:	1000f51e 	bne	r2,zero,81125984 <___svfprintf_internal_r+0x1190>
811255b0:	d8801f17 	ldw	r2,124(sp)
811255b4:	01204574 	movhi	r4,33045
811255b8:	21074b04 	addi	r4,r4,7468
811255bc:	18c00044 	addi	r3,r3,1
811255c0:	10800044 	addi	r2,r2,1
811255c4:	41000015 	stw	r4,0(r8)
811255c8:	01000044 	movi	r4,1
811255cc:	41000115 	stw	r4,4(r8)
811255d0:	d8c02015 	stw	r3,128(sp)
811255d4:	d8801f15 	stw	r2,124(sp)
811255d8:	010001c4 	movi	r4,7
811255dc:	20826616 	blt	r4,r2,81125f78 <___svfprintf_internal_r+0x1784>
811255e0:	42000204 	addi	r8,r8,8
811255e4:	d8802617 	ldw	r2,152(sp)
811255e8:	d9403317 	ldw	r5,204(sp)
811255ec:	11400216 	blt	r2,r5,811255f8 <___svfprintf_internal_r+0xe04>
811255f0:	9080004c 	andi	r2,r18,1
811255f4:	103ed526 	beq	r2,zero,8112514c <__reset+0xfb10514c>
811255f8:	d8803817 	ldw	r2,224(sp)
811255fc:	d9003417 	ldw	r4,208(sp)
81125600:	d9403817 	ldw	r5,224(sp)
81125604:	1887883a 	add	r3,r3,r2
81125608:	d8801f17 	ldw	r2,124(sp)
8112560c:	41000015 	stw	r4,0(r8)
81125610:	41400115 	stw	r5,4(r8)
81125614:	10800044 	addi	r2,r2,1
81125618:	d8c02015 	stw	r3,128(sp)
8112561c:	d8801f15 	stw	r2,124(sp)
81125620:	010001c4 	movi	r4,7
81125624:	2082af16 	blt	r4,r2,811260e4 <___svfprintf_internal_r+0x18f0>
81125628:	42000204 	addi	r8,r8,8
8112562c:	d8803317 	ldw	r2,204(sp)
81125630:	143fffc4 	addi	r16,r2,-1
81125634:	043ec50e 	bge	zero,r16,8112514c <__reset+0xfb10514c>
81125638:	04400404 	movi	r17,16
8112563c:	d8801f17 	ldw	r2,124(sp)
81125640:	8c00860e 	bge	r17,r16,8112585c <___svfprintf_internal_r+0x1068>
81125644:	01604574 	movhi	r5,33045
81125648:	29474b84 	addi	r5,r5,7470
8112564c:	d9402b15 	stw	r5,172(sp)
81125650:	058001c4 	movi	r22,7
81125654:	dd002c17 	ldw	r20,176(sp)
81125658:	00000306 	br	81125668 <___svfprintf_internal_r+0xe74>
8112565c:	42000204 	addi	r8,r8,8
81125660:	843ffc04 	addi	r16,r16,-16
81125664:	8c00800e 	bge	r17,r16,81125868 <___svfprintf_internal_r+0x1074>
81125668:	18c00404 	addi	r3,r3,16
8112566c:	10800044 	addi	r2,r2,1
81125670:	45400015 	stw	r21,0(r8)
81125674:	44400115 	stw	r17,4(r8)
81125678:	d8c02015 	stw	r3,128(sp)
8112567c:	d8801f15 	stw	r2,124(sp)
81125680:	b0bff60e 	bge	r22,r2,8112565c <__reset+0xfb10565c>
81125684:	d9801e04 	addi	r6,sp,120
81125688:	a00b883a 	mov	r5,r20
8112568c:	9809883a 	mov	r4,r19
81125690:	11314140 	call	81131414 <__ssprint_r>
81125694:	103d3e1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125698:	d8c02017 	ldw	r3,128(sp)
8112569c:	d8801f17 	ldw	r2,124(sp)
811256a0:	da000404 	addi	r8,sp,16
811256a4:	003fee06 	br	81125660 <__reset+0xfb105660>
811256a8:	d9403117 	ldw	r5,196(sp)
811256ac:	d8802a17 	ldw	r2,168(sp)
811256b0:	28adc83a 	sub	r22,r5,r2
811256b4:	05be650e 	bge	zero,r22,8112504c <__reset+0xfb10504c>
811256b8:	07000404 	movi	fp,16
811256bc:	d8801f17 	ldw	r2,124(sp)
811256c0:	e583a20e 	bge	fp,r22,8112654c <___svfprintf_internal_r+0x1d58>
811256c4:	01604574 	movhi	r5,33045
811256c8:	29474b84 	addi	r5,r5,7470
811256cc:	dc403015 	stw	r17,192(sp)
811256d0:	d9402b15 	stw	r5,172(sp)
811256d4:	b023883a 	mov	r17,r22
811256d8:	050001c4 	movi	r20,7
811256dc:	902d883a 	mov	r22,r18
811256e0:	8025883a 	mov	r18,r16
811256e4:	dc002c17 	ldw	r16,176(sp)
811256e8:	00000306 	br	811256f8 <___svfprintf_internal_r+0xf04>
811256ec:	8c7ffc04 	addi	r17,r17,-16
811256f0:	42000204 	addi	r8,r8,8
811256f4:	e440110e 	bge	fp,r17,8112573c <___svfprintf_internal_r+0xf48>
811256f8:	18c00404 	addi	r3,r3,16
811256fc:	10800044 	addi	r2,r2,1
81125700:	45400015 	stw	r21,0(r8)
81125704:	47000115 	stw	fp,4(r8)
81125708:	d8c02015 	stw	r3,128(sp)
8112570c:	d8801f15 	stw	r2,124(sp)
81125710:	a0bff60e 	bge	r20,r2,811256ec <__reset+0xfb1056ec>
81125714:	d9801e04 	addi	r6,sp,120
81125718:	800b883a 	mov	r5,r16
8112571c:	9809883a 	mov	r4,r19
81125720:	11314140 	call	81131414 <__ssprint_r>
81125724:	103d1a1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125728:	8c7ffc04 	addi	r17,r17,-16
8112572c:	d8c02017 	ldw	r3,128(sp)
81125730:	d8801f17 	ldw	r2,124(sp)
81125734:	da000404 	addi	r8,sp,16
81125738:	e47fef16 	blt	fp,r17,811256f8 <__reset+0xfb1056f8>
8112573c:	9021883a 	mov	r16,r18
81125740:	b025883a 	mov	r18,r22
81125744:	882d883a 	mov	r22,r17
81125748:	dc403017 	ldw	r17,192(sp)
8112574c:	d9002b17 	ldw	r4,172(sp)
81125750:	1d87883a 	add	r3,r3,r22
81125754:	10800044 	addi	r2,r2,1
81125758:	41000015 	stw	r4,0(r8)
8112575c:	45800115 	stw	r22,4(r8)
81125760:	d8c02015 	stw	r3,128(sp)
81125764:	d8801f15 	stw	r2,124(sp)
81125768:	010001c4 	movi	r4,7
8112576c:	20819a16 	blt	r4,r2,81125dd8 <___svfprintf_internal_r+0x15e4>
81125770:	42000204 	addi	r8,r8,8
81125774:	003e3506 	br	8112504c <__reset+0xfb10504c>
81125778:	d9403317 	ldw	r5,204(sp)
8112577c:	00800044 	movi	r2,1
81125780:	18c00044 	addi	r3,r3,1
81125784:	1141710e 	bge	r2,r5,81125d4c <___svfprintf_internal_r+0x1558>
81125788:	dc401f17 	ldw	r17,124(sp)
8112578c:	00800044 	movi	r2,1
81125790:	40800115 	stw	r2,4(r8)
81125794:	8c400044 	addi	r17,r17,1
81125798:	44000015 	stw	r16,0(r8)
8112579c:	d8c02015 	stw	r3,128(sp)
811257a0:	dc401f15 	stw	r17,124(sp)
811257a4:	008001c4 	movi	r2,7
811257a8:	14417416 	blt	r2,r17,81125d7c <___svfprintf_internal_r+0x1588>
811257ac:	42000204 	addi	r8,r8,8
811257b0:	d8803817 	ldw	r2,224(sp)
811257b4:	d9003417 	ldw	r4,208(sp)
811257b8:	8c400044 	addi	r17,r17,1
811257bc:	10c7883a 	add	r3,r2,r3
811257c0:	40800115 	stw	r2,4(r8)
811257c4:	41000015 	stw	r4,0(r8)
811257c8:	d8c02015 	stw	r3,128(sp)
811257cc:	dc401f15 	stw	r17,124(sp)
811257d0:	008001c4 	movi	r2,7
811257d4:	14417216 	blt	r2,r17,81125da0 <___svfprintf_internal_r+0x15ac>
811257d8:	45800204 	addi	r22,r8,8
811257dc:	d9003617 	ldw	r4,216(sp)
811257e0:	d9403717 	ldw	r5,220(sp)
811257e4:	000d883a 	mov	r6,zero
811257e8:	000f883a 	mov	r7,zero
811257ec:	d8c03d15 	stw	r3,244(sp)
811257f0:	11373900 	call	81137390 <__eqdf2>
811257f4:	d8c03d17 	ldw	r3,244(sp)
811257f8:	1000b326 	beq	r2,zero,81125ac8 <___svfprintf_internal_r+0x12d4>
811257fc:	d9403317 	ldw	r5,204(sp)
81125800:	84000044 	addi	r16,r16,1
81125804:	8c400044 	addi	r17,r17,1
81125808:	28bfffc4 	addi	r2,r5,-1
8112580c:	1887883a 	add	r3,r3,r2
81125810:	b0800115 	stw	r2,4(r22)
81125814:	b4000015 	stw	r16,0(r22)
81125818:	d8c02015 	stw	r3,128(sp)
8112581c:	dc401f15 	stw	r17,124(sp)
81125820:	008001c4 	movi	r2,7
81125824:	1440d216 	blt	r2,r17,81125b70 <___svfprintf_internal_r+0x137c>
81125828:	b5800204 	addi	r22,r22,8
8112582c:	d9003b17 	ldw	r4,236(sp)
81125830:	df0022c4 	addi	fp,sp,139
81125834:	8c400044 	addi	r17,r17,1
81125838:	20c7883a 	add	r3,r4,r3
8112583c:	b7000015 	stw	fp,0(r22)
81125840:	b1000115 	stw	r4,4(r22)
81125844:	d8c02015 	stw	r3,128(sp)
81125848:	dc401f15 	stw	r17,124(sp)
8112584c:	008001c4 	movi	r2,7
81125850:	14400e16 	blt	r2,r17,8112588c <___svfprintf_internal_r+0x1098>
81125854:	b2000204 	addi	r8,r22,8
81125858:	003e3c06 	br	8112514c <__reset+0xfb10514c>
8112585c:	01204574 	movhi	r4,33045
81125860:	21074b84 	addi	r4,r4,7470
81125864:	d9002b15 	stw	r4,172(sp)
81125868:	d9002b17 	ldw	r4,172(sp)
8112586c:	1c07883a 	add	r3,r3,r16
81125870:	44000115 	stw	r16,4(r8)
81125874:	41000015 	stw	r4,0(r8)
81125878:	10800044 	addi	r2,r2,1
8112587c:	d8c02015 	stw	r3,128(sp)
81125880:	d8801f15 	stw	r2,124(sp)
81125884:	010001c4 	movi	r4,7
81125888:	20be2f0e 	bge	r4,r2,81125148 <__reset+0xfb105148>
8112588c:	d9402c17 	ldw	r5,176(sp)
81125890:	d9801e04 	addi	r6,sp,120
81125894:	9809883a 	mov	r4,r19
81125898:	11314140 	call	81131414 <__ssprint_r>
8112589c:	103cbc1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811258a0:	d8c02017 	ldw	r3,128(sp)
811258a4:	da000404 	addi	r8,sp,16
811258a8:	003e2806 	br	8112514c <__reset+0xfb10514c>
811258ac:	d9402c17 	ldw	r5,176(sp)
811258b0:	d9801e04 	addi	r6,sp,120
811258b4:	9809883a 	mov	r4,r19
811258b8:	11314140 	call	81131414 <__ssprint_r>
811258bc:	103e5f26 	beq	r2,zero,8112523c <__reset+0xfb10523c>
811258c0:	003cb306 	br	81124b90 <__reset+0xfb104b90>
811258c4:	d9402c17 	ldw	r5,176(sp)
811258c8:	d9801e04 	addi	r6,sp,120
811258cc:	9809883a 	mov	r4,r19
811258d0:	11314140 	call	81131414 <__ssprint_r>
811258d4:	103cae1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811258d8:	d8c02017 	ldw	r3,128(sp)
811258dc:	da000404 	addi	r8,sp,16
811258e0:	003e0d06 	br	81125118 <__reset+0xfb105118>
811258e4:	d9402c17 	ldw	r5,176(sp)
811258e8:	d9801e04 	addi	r6,sp,120
811258ec:	9809883a 	mov	r4,r19
811258f0:	11314140 	call	81131414 <__ssprint_r>
811258f4:	103ca61e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811258f8:	d8c02017 	ldw	r3,128(sp)
811258fc:	da000404 	addi	r8,sp,16
81125900:	003dc106 	br	81125008 <__reset+0xfb105008>
81125904:	d9402c17 	ldw	r5,176(sp)
81125908:	d9801e04 	addi	r6,sp,120
8112590c:	9809883a 	mov	r4,r19
81125910:	11314140 	call	81131414 <__ssprint_r>
81125914:	103c9e1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125918:	d8c02017 	ldw	r3,128(sp)
8112591c:	da000404 	addi	r8,sp,16
81125920:	003dc706 	br	81125040 <__reset+0xfb105040>
81125924:	d8802917 	ldw	r2,164(sp)
81125928:	d8002785 	stb	zero,158(sp)
8112592c:	103f0816 	blt	r2,zero,81125550 <__reset+0xfb105550>
81125930:	00ffdfc4 	movi	r3,-129
81125934:	a584b03a 	or	r2,r20,r22
81125938:	90e4703a 	and	r18,r18,r3
8112593c:	103c8126 	beq	r2,zero,81124b44 <__reset+0xfb104b44>
81125940:	0039883a 	mov	fp,zero
81125944:	003e7606 	br	81125320 <__reset+0xfb105320>
81125948:	9080040c 	andi	r2,r18,16
8112594c:	10013d26 	beq	r2,zero,81125e44 <___svfprintf_internal_r+0x1650>
81125950:	d9002d17 	ldw	r4,180(sp)
81125954:	d9402917 	ldw	r5,164(sp)
81125958:	d8002785 	stb	zero,158(sp)
8112595c:	20800104 	addi	r2,r4,4
81125960:	25000017 	ldw	r20,0(r4)
81125964:	002d883a 	mov	r22,zero
81125968:	28013f16 	blt	r5,zero,81125e68 <___svfprintf_internal_r+0x1674>
8112596c:	00ffdfc4 	movi	r3,-129
81125970:	d8802d15 	stw	r2,180(sp)
81125974:	90e4703a 	and	r18,r18,r3
81125978:	a03d2b26 	beq	r20,zero,81124e28 <__reset+0xfb104e28>
8112597c:	0039883a 	mov	fp,zero
81125980:	003d2e06 	br	81124e3c <__reset+0xfb104e3c>
81125984:	dc402617 	ldw	r17,152(sp)
81125988:	0441830e 	bge	zero,r17,81125f98 <___svfprintf_internal_r+0x17a4>
8112598c:	dc403217 	ldw	r17,200(sp)
81125990:	d8803317 	ldw	r2,204(sp)
81125994:	1440010e 	bge	r2,r17,8112599c <___svfprintf_internal_r+0x11a8>
81125998:	1023883a 	mov	r17,r2
8112599c:	04400a0e 	bge	zero,r17,811259c8 <___svfprintf_internal_r+0x11d4>
811259a0:	d8801f17 	ldw	r2,124(sp)
811259a4:	1c47883a 	add	r3,r3,r17
811259a8:	44000015 	stw	r16,0(r8)
811259ac:	10800044 	addi	r2,r2,1
811259b0:	44400115 	stw	r17,4(r8)
811259b4:	d8c02015 	stw	r3,128(sp)
811259b8:	d8801f15 	stw	r2,124(sp)
811259bc:	010001c4 	movi	r4,7
811259c0:	20827516 	blt	r4,r2,81126398 <___svfprintf_internal_r+0x1ba4>
811259c4:	42000204 	addi	r8,r8,8
811259c8:	88027b16 	blt	r17,zero,811263b8 <___svfprintf_internal_r+0x1bc4>
811259cc:	d9003217 	ldw	r4,200(sp)
811259d0:	2463c83a 	sub	r17,r4,r17
811259d4:	0440990e 	bge	zero,r17,81125c3c <___svfprintf_internal_r+0x1448>
811259d8:	05800404 	movi	r22,16
811259dc:	d8801f17 	ldw	r2,124(sp)
811259e0:	b441530e 	bge	r22,r17,81125f30 <___svfprintf_internal_r+0x173c>
811259e4:	01204574 	movhi	r4,33045
811259e8:	21074b84 	addi	r4,r4,7470
811259ec:	d9002b15 	stw	r4,172(sp)
811259f0:	070001c4 	movi	fp,7
811259f4:	dd002c17 	ldw	r20,176(sp)
811259f8:	00000306 	br	81125a08 <___svfprintf_internal_r+0x1214>
811259fc:	42000204 	addi	r8,r8,8
81125a00:	8c7ffc04 	addi	r17,r17,-16
81125a04:	b4414d0e 	bge	r22,r17,81125f3c <___svfprintf_internal_r+0x1748>
81125a08:	18c00404 	addi	r3,r3,16
81125a0c:	10800044 	addi	r2,r2,1
81125a10:	45400015 	stw	r21,0(r8)
81125a14:	45800115 	stw	r22,4(r8)
81125a18:	d8c02015 	stw	r3,128(sp)
81125a1c:	d8801f15 	stw	r2,124(sp)
81125a20:	e0bff60e 	bge	fp,r2,811259fc <__reset+0xfb1059fc>
81125a24:	d9801e04 	addi	r6,sp,120
81125a28:	a00b883a 	mov	r5,r20
81125a2c:	9809883a 	mov	r4,r19
81125a30:	11314140 	call	81131414 <__ssprint_r>
81125a34:	103c561e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125a38:	d8c02017 	ldw	r3,128(sp)
81125a3c:	d8801f17 	ldw	r2,124(sp)
81125a40:	da000404 	addi	r8,sp,16
81125a44:	003fee06 	br	81125a00 <__reset+0xfb105a00>
81125a48:	d9402c17 	ldw	r5,176(sp)
81125a4c:	d9801e04 	addi	r6,sp,120
81125a50:	9809883a 	mov	r4,r19
81125a54:	11314140 	call	81131414 <__ssprint_r>
81125a58:	103c4d1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125a5c:	d8c02017 	ldw	r3,128(sp)
81125a60:	df002787 	ldb	fp,158(sp)
81125a64:	da000404 	addi	r8,sp,16
81125a68:	003d5a06 	br	81124fd4 <__reset+0xfb104fd4>
81125a6c:	9080040c 	andi	r2,r18,16
81125a70:	10005c26 	beq	r2,zero,81125be4 <___svfprintf_internal_r+0x13f0>
81125a74:	d9402d17 	ldw	r5,180(sp)
81125a78:	d8c02917 	ldw	r3,164(sp)
81125a7c:	d8002785 	stb	zero,158(sp)
81125a80:	28800104 	addi	r2,r5,4
81125a84:	2d000017 	ldw	r20,0(r5)
81125a88:	002d883a 	mov	r22,zero
81125a8c:	18005e16 	blt	r3,zero,81125c08 <___svfprintf_internal_r+0x1414>
81125a90:	00ffdfc4 	movi	r3,-129
81125a94:	d8802d15 	stw	r2,180(sp)
81125a98:	90e4703a 	and	r18,r18,r3
81125a9c:	0039883a 	mov	fp,zero
81125aa0:	a03dfe26 	beq	r20,zero,8112529c <__reset+0xfb10529c>
81125aa4:	00800244 	movi	r2,9
81125aa8:	153cb336 	bltu	r2,r20,81124d78 <__reset+0xfb104d78>
81125aac:	a5000c04 	addi	r20,r20,48
81125ab0:	dc001dc4 	addi	r16,sp,119
81125ab4:	dd001dc5 	stb	r20,119(sp)
81125ab8:	d8c02817 	ldw	r3,160(sp)
81125abc:	1c07c83a 	sub	r3,r3,r16
81125ac0:	d8c02e15 	stw	r3,184(sp)
81125ac4:	003cf506 	br	81124e9c <__reset+0xfb104e9c>
81125ac8:	d8803317 	ldw	r2,204(sp)
81125acc:	143fffc4 	addi	r16,r2,-1
81125ad0:	043f560e 	bge	zero,r16,8112582c <__reset+0xfb10582c>
81125ad4:	07000404 	movi	fp,16
81125ad8:	e403530e 	bge	fp,r16,81126828 <___svfprintf_internal_r+0x2034>
81125adc:	01604574 	movhi	r5,33045
81125ae0:	29474b84 	addi	r5,r5,7470
81125ae4:	d9402b15 	stw	r5,172(sp)
81125ae8:	01c001c4 	movi	r7,7
81125aec:	dd002c17 	ldw	r20,176(sp)
81125af0:	00000306 	br	81125b00 <___svfprintf_internal_r+0x130c>
81125af4:	843ffc04 	addi	r16,r16,-16
81125af8:	b5800204 	addi	r22,r22,8
81125afc:	e400130e 	bge	fp,r16,81125b4c <___svfprintf_internal_r+0x1358>
81125b00:	18c00404 	addi	r3,r3,16
81125b04:	8c400044 	addi	r17,r17,1
81125b08:	b5400015 	stw	r21,0(r22)
81125b0c:	b7000115 	stw	fp,4(r22)
81125b10:	d8c02015 	stw	r3,128(sp)
81125b14:	dc401f15 	stw	r17,124(sp)
81125b18:	3c7ff60e 	bge	r7,r17,81125af4 <__reset+0xfb105af4>
81125b1c:	d9801e04 	addi	r6,sp,120
81125b20:	a00b883a 	mov	r5,r20
81125b24:	9809883a 	mov	r4,r19
81125b28:	d9c03d15 	stw	r7,244(sp)
81125b2c:	11314140 	call	81131414 <__ssprint_r>
81125b30:	d9c03d17 	ldw	r7,244(sp)
81125b34:	103c161e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125b38:	843ffc04 	addi	r16,r16,-16
81125b3c:	d8c02017 	ldw	r3,128(sp)
81125b40:	dc401f17 	ldw	r17,124(sp)
81125b44:	dd800404 	addi	r22,sp,16
81125b48:	e43fed16 	blt	fp,r16,81125b00 <__reset+0xfb105b00>
81125b4c:	d8802b17 	ldw	r2,172(sp)
81125b50:	1c07883a 	add	r3,r3,r16
81125b54:	8c400044 	addi	r17,r17,1
81125b58:	b0800015 	stw	r2,0(r22)
81125b5c:	b4000115 	stw	r16,4(r22)
81125b60:	d8c02015 	stw	r3,128(sp)
81125b64:	dc401f15 	stw	r17,124(sp)
81125b68:	008001c4 	movi	r2,7
81125b6c:	147f2e0e 	bge	r2,r17,81125828 <__reset+0xfb105828>
81125b70:	d9402c17 	ldw	r5,176(sp)
81125b74:	d9801e04 	addi	r6,sp,120
81125b78:	9809883a 	mov	r4,r19
81125b7c:	11314140 	call	81131414 <__ssprint_r>
81125b80:	103c031e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125b84:	d8c02017 	ldw	r3,128(sp)
81125b88:	dc401f17 	ldw	r17,124(sp)
81125b8c:	dd800404 	addi	r22,sp,16
81125b90:	003f2606 	br	8112582c <__reset+0xfb10582c>
81125b94:	9080040c 	andi	r2,r18,16
81125b98:	1000c326 	beq	r2,zero,81125ea8 <___svfprintf_internal_r+0x16b4>
81125b9c:	d8802d17 	ldw	r2,180(sp)
81125ba0:	15000017 	ldw	r20,0(r2)
81125ba4:	10800104 	addi	r2,r2,4
81125ba8:	d8802d15 	stw	r2,180(sp)
81125bac:	a02dd7fa 	srai	r22,r20,31
81125bb0:	b005883a 	mov	r2,r22
81125bb4:	103c680e 	bge	r2,zero,81124d58 <__reset+0xfb104d58>
81125bb8:	0529c83a 	sub	r20,zero,r20
81125bbc:	a004c03a 	cmpne	r2,r20,zero
81125bc0:	05adc83a 	sub	r22,zero,r22
81125bc4:	b0adc83a 	sub	r22,r22,r2
81125bc8:	d8802917 	ldw	r2,164(sp)
81125bcc:	07000b44 	movi	fp,45
81125bd0:	df002785 	stb	fp,158(sp)
81125bd4:	10022e16 	blt	r2,zero,81126490 <___svfprintf_internal_r+0x1c9c>
81125bd8:	00bfdfc4 	movi	r2,-129
81125bdc:	90a4703a 	and	r18,r18,r2
81125be0:	003c6406 	br	81124d74 <__reset+0xfb104d74>
81125be4:	9080100c 	andi	r2,r18,64
81125be8:	d8002785 	stb	zero,158(sp)
81125bec:	10012526 	beq	r2,zero,81126084 <___svfprintf_internal_r+0x1890>
81125bf0:	d9002d17 	ldw	r4,180(sp)
81125bf4:	d9402917 	ldw	r5,164(sp)
81125bf8:	002d883a 	mov	r22,zero
81125bfc:	20800104 	addi	r2,r4,4
81125c00:	2500000b 	ldhu	r20,0(r4)
81125c04:	283fa20e 	bge	r5,zero,81125a90 <__reset+0xfb105a90>
81125c08:	d8802d15 	stw	r2,180(sp)
81125c0c:	0039883a 	mov	fp,zero
81125c10:	a584b03a 	or	r2,r20,r22
81125c14:	103c571e 	bne	r2,zero,81124d74 <__reset+0xfb104d74>
81125c18:	00800044 	movi	r2,1
81125c1c:	003e5006 	br	81125560 <__reset+0xfb105560>
81125c20:	d9402c17 	ldw	r5,176(sp)
81125c24:	d9801e04 	addi	r6,sp,120
81125c28:	9809883a 	mov	r4,r19
81125c2c:	11314140 	call	81131414 <__ssprint_r>
81125c30:	103bd71e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125c34:	d8c02017 	ldw	r3,128(sp)
81125c38:	da000404 	addi	r8,sp,16
81125c3c:	d9003217 	ldw	r4,200(sp)
81125c40:	d8802617 	ldw	r2,152(sp)
81125c44:	d9403317 	ldw	r5,204(sp)
81125c48:	8123883a 	add	r17,r16,r4
81125c4c:	11400216 	blt	r2,r5,81125c58 <___svfprintf_internal_r+0x1464>
81125c50:	9100004c 	andi	r4,r18,1
81125c54:	20000d26 	beq	r4,zero,81125c8c <___svfprintf_internal_r+0x1498>
81125c58:	d9003817 	ldw	r4,224(sp)
81125c5c:	d9403417 	ldw	r5,208(sp)
81125c60:	1907883a 	add	r3,r3,r4
81125c64:	d9001f17 	ldw	r4,124(sp)
81125c68:	41400015 	stw	r5,0(r8)
81125c6c:	d9403817 	ldw	r5,224(sp)
81125c70:	21000044 	addi	r4,r4,1
81125c74:	d8c02015 	stw	r3,128(sp)
81125c78:	41400115 	stw	r5,4(r8)
81125c7c:	d9001f15 	stw	r4,124(sp)
81125c80:	014001c4 	movi	r5,7
81125c84:	2901dc16 	blt	r5,r4,811263f8 <___svfprintf_internal_r+0x1c04>
81125c88:	42000204 	addi	r8,r8,8
81125c8c:	d9003317 	ldw	r4,204(sp)
81125c90:	8121883a 	add	r16,r16,r4
81125c94:	2085c83a 	sub	r2,r4,r2
81125c98:	8461c83a 	sub	r16,r16,r17
81125c9c:	1400010e 	bge	r2,r16,81125ca4 <___svfprintf_internal_r+0x14b0>
81125ca0:	1021883a 	mov	r16,r2
81125ca4:	04000a0e 	bge	zero,r16,81125cd0 <___svfprintf_internal_r+0x14dc>
81125ca8:	d9001f17 	ldw	r4,124(sp)
81125cac:	1c07883a 	add	r3,r3,r16
81125cb0:	44400015 	stw	r17,0(r8)
81125cb4:	21000044 	addi	r4,r4,1
81125cb8:	44000115 	stw	r16,4(r8)
81125cbc:	d8c02015 	stw	r3,128(sp)
81125cc0:	d9001f15 	stw	r4,124(sp)
81125cc4:	014001c4 	movi	r5,7
81125cc8:	2901e616 	blt	r5,r4,81126464 <___svfprintf_internal_r+0x1c70>
81125ccc:	42000204 	addi	r8,r8,8
81125cd0:	8001f616 	blt	r16,zero,811264ac <___svfprintf_internal_r+0x1cb8>
81125cd4:	1421c83a 	sub	r16,r2,r16
81125cd8:	043d1c0e 	bge	zero,r16,8112514c <__reset+0xfb10514c>
81125cdc:	04400404 	movi	r17,16
81125ce0:	d8801f17 	ldw	r2,124(sp)
81125ce4:	8c3edd0e 	bge	r17,r16,8112585c <__reset+0xfb10585c>
81125ce8:	01604574 	movhi	r5,33045
81125cec:	29474b84 	addi	r5,r5,7470
81125cf0:	d9402b15 	stw	r5,172(sp)
81125cf4:	058001c4 	movi	r22,7
81125cf8:	dd002c17 	ldw	r20,176(sp)
81125cfc:	00000306 	br	81125d0c <___svfprintf_internal_r+0x1518>
81125d00:	42000204 	addi	r8,r8,8
81125d04:	843ffc04 	addi	r16,r16,-16
81125d08:	8c3ed70e 	bge	r17,r16,81125868 <__reset+0xfb105868>
81125d0c:	18c00404 	addi	r3,r3,16
81125d10:	10800044 	addi	r2,r2,1
81125d14:	45400015 	stw	r21,0(r8)
81125d18:	44400115 	stw	r17,4(r8)
81125d1c:	d8c02015 	stw	r3,128(sp)
81125d20:	d8801f15 	stw	r2,124(sp)
81125d24:	b0bff60e 	bge	r22,r2,81125d00 <__reset+0xfb105d00>
81125d28:	d9801e04 	addi	r6,sp,120
81125d2c:	a00b883a 	mov	r5,r20
81125d30:	9809883a 	mov	r4,r19
81125d34:	11314140 	call	81131414 <__ssprint_r>
81125d38:	103b951e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125d3c:	d8c02017 	ldw	r3,128(sp)
81125d40:	d8801f17 	ldw	r2,124(sp)
81125d44:	da000404 	addi	r8,sp,16
81125d48:	003fee06 	br	81125d04 <__reset+0xfb105d04>
81125d4c:	9088703a 	and	r4,r18,r2
81125d50:	203e8d1e 	bne	r4,zero,81125788 <__reset+0xfb105788>
81125d54:	dc401f17 	ldw	r17,124(sp)
81125d58:	40800115 	stw	r2,4(r8)
81125d5c:	44000015 	stw	r16,0(r8)
81125d60:	8c400044 	addi	r17,r17,1
81125d64:	d8c02015 	stw	r3,128(sp)
81125d68:	dc401f15 	stw	r17,124(sp)
81125d6c:	008001c4 	movi	r2,7
81125d70:	147f7f16 	blt	r2,r17,81125b70 <__reset+0xfb105b70>
81125d74:	45800204 	addi	r22,r8,8
81125d78:	003eac06 	br	8112582c <__reset+0xfb10582c>
81125d7c:	d9402c17 	ldw	r5,176(sp)
81125d80:	d9801e04 	addi	r6,sp,120
81125d84:	9809883a 	mov	r4,r19
81125d88:	11314140 	call	81131414 <__ssprint_r>
81125d8c:	103b801e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125d90:	d8c02017 	ldw	r3,128(sp)
81125d94:	dc401f17 	ldw	r17,124(sp)
81125d98:	da000404 	addi	r8,sp,16
81125d9c:	003e8406 	br	811257b0 <__reset+0xfb1057b0>
81125da0:	d9402c17 	ldw	r5,176(sp)
81125da4:	d9801e04 	addi	r6,sp,120
81125da8:	9809883a 	mov	r4,r19
81125dac:	11314140 	call	81131414 <__ssprint_r>
81125db0:	103b771e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125db4:	d8c02017 	ldw	r3,128(sp)
81125db8:	dc401f17 	ldw	r17,124(sp)
81125dbc:	dd800404 	addi	r22,sp,16
81125dc0:	003e8606 	br	811257dc <__reset+0xfb1057dc>
81125dc4:	0029883a 	mov	r20,zero
81125dc8:	a5000c04 	addi	r20,r20,48
81125dcc:	dc001dc4 	addi	r16,sp,119
81125dd0:	dd001dc5 	stb	r20,119(sp)
81125dd4:	003f3806 	br	81125ab8 <__reset+0xfb105ab8>
81125dd8:	d9402c17 	ldw	r5,176(sp)
81125ddc:	d9801e04 	addi	r6,sp,120
81125de0:	9809883a 	mov	r4,r19
81125de4:	11314140 	call	81131414 <__ssprint_r>
81125de8:	103b691e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125dec:	d8c02017 	ldw	r3,128(sp)
81125df0:	da000404 	addi	r8,sp,16
81125df4:	003c9506 	br	8112504c <__reset+0xfb10504c>
81125df8:	d9003617 	ldw	r4,216(sp)
81125dfc:	d9403717 	ldw	r5,220(sp)
81125e00:	da003e15 	stw	r8,248(sp)
81125e04:	112f2280 	call	8112f228 <__fpclassifyd>
81125e08:	da003e17 	ldw	r8,248(sp)
81125e0c:	1000bd1e 	bne	r2,zero,81126104 <___svfprintf_internal_r+0x1910>
81125e10:	008011c4 	movi	r2,71
81125e14:	14411e0e 	bge	r2,r17,81126290 <___svfprintf_internal_r+0x1a9c>
81125e18:	04204574 	movhi	r16,33045
81125e1c:	84073e04 	addi	r16,r16,7416
81125e20:	00c000c4 	movi	r3,3
81125e24:	00bfdfc4 	movi	r2,-129
81125e28:	d8c02a15 	stw	r3,168(sp)
81125e2c:	90a4703a 	and	r18,r18,r2
81125e30:	df002783 	ldbu	fp,158(sp)
81125e34:	d8c02e15 	stw	r3,184(sp)
81125e38:	d8002915 	stw	zero,164(sp)
81125e3c:	d8003215 	stw	zero,200(sp)
81125e40:	003c1c06 	br	81124eb4 <__reset+0xfb104eb4>
81125e44:	9080100c 	andi	r2,r18,64
81125e48:	d8002785 	stb	zero,158(sp)
81125e4c:	10009426 	beq	r2,zero,811260a0 <___svfprintf_internal_r+0x18ac>
81125e50:	d8c02d17 	ldw	r3,180(sp)
81125e54:	d9002917 	ldw	r4,164(sp)
81125e58:	002d883a 	mov	r22,zero
81125e5c:	18800104 	addi	r2,r3,4
81125e60:	1d00000b 	ldhu	r20,0(r3)
81125e64:	203ec10e 	bge	r4,zero,8112596c <__reset+0xfb10596c>
81125e68:	a586b03a 	or	r3,r20,r22
81125e6c:	d8802d15 	stw	r2,180(sp)
81125e70:	183ec21e 	bne	r3,zero,8112597c <__reset+0xfb10597c>
81125e74:	0039883a 	mov	fp,zero
81125e78:	0005883a 	mov	r2,zero
81125e7c:	003db806 	br	81125560 <__reset+0xfb105560>
81125e80:	d8802d17 	ldw	r2,180(sp)
81125e84:	d8c02d17 	ldw	r3,180(sp)
81125e88:	d9002d17 	ldw	r4,180(sp)
81125e8c:	10800017 	ldw	r2,0(r2)
81125e90:	18c00117 	ldw	r3,4(r3)
81125e94:	21000204 	addi	r4,r4,8
81125e98:	d8803615 	stw	r2,216(sp)
81125e9c:	d8c03715 	stw	r3,220(sp)
81125ea0:	d9002d15 	stw	r4,180(sp)
81125ea4:	003b8206 	br	81124cb0 <__reset+0xfb104cb0>
81125ea8:	9080100c 	andi	r2,r18,64
81125eac:	10010726 	beq	r2,zero,811262cc <___svfprintf_internal_r+0x1ad8>
81125eb0:	d8c02d17 	ldw	r3,180(sp)
81125eb4:	1d00000f 	ldh	r20,0(r3)
81125eb8:	18c00104 	addi	r3,r3,4
81125ebc:	d8c02d15 	stw	r3,180(sp)
81125ec0:	a02dd7fa 	srai	r22,r20,31
81125ec4:	b005883a 	mov	r2,r22
81125ec8:	003ba206 	br	81124d54 <__reset+0xfb104d54>
81125ecc:	9080100c 	andi	r2,r18,64
81125ed0:	10010526 	beq	r2,zero,811262e8 <___svfprintf_internal_r+0x1af4>
81125ed4:	d9002d17 	ldw	r4,180(sp)
81125ed8:	002d883a 	mov	r22,zero
81125edc:	2500000b 	ldhu	r20,0(r4)
81125ee0:	21000104 	addi	r4,r4,4
81125ee4:	d9002d15 	stw	r4,180(sp)
81125ee8:	003cfe06 	br	811252e4 <__reset+0xfb1052e4>
81125eec:	bc400007 	ldb	r17,0(r23)
81125ef0:	003a9606 	br	8112494c <__reset+0xfb10494c>
81125ef4:	9080040c 	andi	r2,r18,16
81125ef8:	10010126 	beq	r2,zero,81126300 <___svfprintf_internal_r+0x1b0c>
81125efc:	d9402d17 	ldw	r5,180(sp)
81125f00:	d8c02f17 	ldw	r3,188(sp)
81125f04:	28800017 	ldw	r2,0(r5)
81125f08:	29400104 	addi	r5,r5,4
81125f0c:	d9402d15 	stw	r5,180(sp)
81125f10:	10c00015 	stw	r3,0(r2)
81125f14:	003a6406 	br	811248a8 <__reset+0xfb1048a8>
81125f18:	d9002917 	ldw	r4,164(sp)
81125f1c:	d8002785 	stb	zero,158(sp)
81125f20:	203d8d16 	blt	r4,zero,81125558 <__reset+0xfb105558>
81125f24:	00bfdfc4 	movi	r2,-129
81125f28:	90a4703a 	and	r18,r18,r2
81125f2c:	003b0506 	br	81124b44 <__reset+0xfb104b44>
81125f30:	01604574 	movhi	r5,33045
81125f34:	29474b84 	addi	r5,r5,7470
81125f38:	d9402b15 	stw	r5,172(sp)
81125f3c:	d9402b17 	ldw	r5,172(sp)
81125f40:	1c47883a 	add	r3,r3,r17
81125f44:	10800044 	addi	r2,r2,1
81125f48:	41400015 	stw	r5,0(r8)
81125f4c:	44400115 	stw	r17,4(r8)
81125f50:	d8c02015 	stw	r3,128(sp)
81125f54:	d8801f15 	stw	r2,124(sp)
81125f58:	010001c4 	movi	r4,7
81125f5c:	20bf3016 	blt	r4,r2,81125c20 <__reset+0xfb105c20>
81125f60:	42000204 	addi	r8,r8,8
81125f64:	003f3506 	br	81125c3c <__reset+0xfb105c3c>
81125f68:	01204574 	movhi	r4,33045
81125f6c:	21074b84 	addi	r4,r4,7470
81125f70:	d9002b15 	stw	r4,172(sp)
81125f74:	003c5e06 	br	811250f0 <__reset+0xfb1050f0>
81125f78:	d9402c17 	ldw	r5,176(sp)
81125f7c:	d9801e04 	addi	r6,sp,120
81125f80:	9809883a 	mov	r4,r19
81125f84:	11314140 	call	81131414 <__ssprint_r>
81125f88:	103b011e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81125f8c:	d8c02017 	ldw	r3,128(sp)
81125f90:	da000404 	addi	r8,sp,16
81125f94:	003d9306 	br	811255e4 <__reset+0xfb1055e4>
81125f98:	d8801f17 	ldw	r2,124(sp)
81125f9c:	01604574 	movhi	r5,33045
81125fa0:	01000044 	movi	r4,1
81125fa4:	18c00044 	addi	r3,r3,1
81125fa8:	10800044 	addi	r2,r2,1
81125fac:	29474b04 	addi	r5,r5,7468
81125fb0:	41000115 	stw	r4,4(r8)
81125fb4:	41400015 	stw	r5,0(r8)
81125fb8:	d8c02015 	stw	r3,128(sp)
81125fbc:	d8801f15 	stw	r2,124(sp)
81125fc0:	010001c4 	movi	r4,7
81125fc4:	2080b516 	blt	r4,r2,8112629c <___svfprintf_internal_r+0x1aa8>
81125fc8:	42000204 	addi	r8,r8,8
81125fcc:	8800041e 	bne	r17,zero,81125fe0 <___svfprintf_internal_r+0x17ec>
81125fd0:	d8803317 	ldw	r2,204(sp)
81125fd4:	1000021e 	bne	r2,zero,81125fe0 <___svfprintf_internal_r+0x17ec>
81125fd8:	9080004c 	andi	r2,r18,1
81125fdc:	103c5b26 	beq	r2,zero,8112514c <__reset+0xfb10514c>
81125fe0:	d9003817 	ldw	r4,224(sp)
81125fe4:	d8801f17 	ldw	r2,124(sp)
81125fe8:	d9403417 	ldw	r5,208(sp)
81125fec:	20c7883a 	add	r3,r4,r3
81125ff0:	10800044 	addi	r2,r2,1
81125ff4:	41000115 	stw	r4,4(r8)
81125ff8:	41400015 	stw	r5,0(r8)
81125ffc:	d8c02015 	stw	r3,128(sp)
81126000:	d8801f15 	stw	r2,124(sp)
81126004:	010001c4 	movi	r4,7
81126008:	20818016 	blt	r4,r2,8112660c <___svfprintf_internal_r+0x1e18>
8112600c:	42000204 	addi	r8,r8,8
81126010:	0463c83a 	sub	r17,zero,r17
81126014:	0440cb0e 	bge	zero,r17,81126344 <___svfprintf_internal_r+0x1b50>
81126018:	05800404 	movi	r22,16
8112601c:	b440e80e 	bge	r22,r17,811263c0 <___svfprintf_internal_r+0x1bcc>
81126020:	01604574 	movhi	r5,33045
81126024:	29474b84 	addi	r5,r5,7470
81126028:	d9402b15 	stw	r5,172(sp)
8112602c:	070001c4 	movi	fp,7
81126030:	dd002c17 	ldw	r20,176(sp)
81126034:	00000306 	br	81126044 <___svfprintf_internal_r+0x1850>
81126038:	42000204 	addi	r8,r8,8
8112603c:	8c7ffc04 	addi	r17,r17,-16
81126040:	b440e20e 	bge	r22,r17,811263cc <___svfprintf_internal_r+0x1bd8>
81126044:	18c00404 	addi	r3,r3,16
81126048:	10800044 	addi	r2,r2,1
8112604c:	45400015 	stw	r21,0(r8)
81126050:	45800115 	stw	r22,4(r8)
81126054:	d8c02015 	stw	r3,128(sp)
81126058:	d8801f15 	stw	r2,124(sp)
8112605c:	e0bff60e 	bge	fp,r2,81126038 <__reset+0xfb106038>
81126060:	d9801e04 	addi	r6,sp,120
81126064:	a00b883a 	mov	r5,r20
81126068:	9809883a 	mov	r4,r19
8112606c:	11314140 	call	81131414 <__ssprint_r>
81126070:	103ac71e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81126074:	d8c02017 	ldw	r3,128(sp)
81126078:	d8801f17 	ldw	r2,124(sp)
8112607c:	da000404 	addi	r8,sp,16
81126080:	003fee06 	br	8112603c <__reset+0xfb10603c>
81126084:	d8c02d17 	ldw	r3,180(sp)
81126088:	d9002917 	ldw	r4,164(sp)
8112608c:	002d883a 	mov	r22,zero
81126090:	18800104 	addi	r2,r3,4
81126094:	1d000017 	ldw	r20,0(r3)
81126098:	203e7d0e 	bge	r4,zero,81125a90 <__reset+0xfb105a90>
8112609c:	003eda06 	br	81125c08 <__reset+0xfb105c08>
811260a0:	d9402d17 	ldw	r5,180(sp)
811260a4:	d8c02917 	ldw	r3,164(sp)
811260a8:	002d883a 	mov	r22,zero
811260ac:	28800104 	addi	r2,r5,4
811260b0:	2d000017 	ldw	r20,0(r5)
811260b4:	183e2d0e 	bge	r3,zero,8112596c <__reset+0xfb10596c>
811260b8:	003f6b06 	br	81125e68 <__reset+0xfb105e68>
811260bc:	d8c02d15 	stw	r3,180(sp)
811260c0:	0039883a 	mov	fp,zero
811260c4:	003ed206 	br	81125c10 <__reset+0xfb105c10>
811260c8:	bc400043 	ldbu	r17,1(r23)
811260cc:	94800814 	ori	r18,r18,32
811260d0:	bdc00044 	addi	r23,r23,1
811260d4:	8c403fcc 	andi	r17,r17,255
811260d8:	8c40201c 	xori	r17,r17,128
811260dc:	8c7fe004 	addi	r17,r17,-128
811260e0:	003a1a06 	br	8112494c <__reset+0xfb10494c>
811260e4:	d9402c17 	ldw	r5,176(sp)
811260e8:	d9801e04 	addi	r6,sp,120
811260ec:	9809883a 	mov	r4,r19
811260f0:	11314140 	call	81131414 <__ssprint_r>
811260f4:	103aa61e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811260f8:	d8c02017 	ldw	r3,128(sp)
811260fc:	da000404 	addi	r8,sp,16
81126100:	003d4a06 	br	8112562c <__reset+0xfb10562c>
81126104:	d9002917 	ldw	r4,164(sp)
81126108:	05bff7c4 	movi	r22,-33
8112610c:	00bfffc4 	movi	r2,-1
81126110:	8dac703a 	and	r22,r17,r22
81126114:	20806a26 	beq	r4,r2,811262c0 <___svfprintf_internal_r+0x1acc>
81126118:	008011c4 	movi	r2,71
8112611c:	b0813726 	beq	r22,r2,811265fc <___svfprintf_internal_r+0x1e08>
81126120:	d9003717 	ldw	r4,220(sp)
81126124:	90c04014 	ori	r3,r18,256
81126128:	d8c02b15 	stw	r3,172(sp)
8112612c:	20015d16 	blt	r4,zero,811266a4 <___svfprintf_internal_r+0x1eb0>
81126130:	dd003717 	ldw	r20,220(sp)
81126134:	d8002a05 	stb	zero,168(sp)
81126138:	00801984 	movi	r2,102
8112613c:	88814026 	beq	r17,r2,81126640 <___svfprintf_internal_r+0x1e4c>
81126140:	00801184 	movi	r2,70
81126144:	88817126 	beq	r17,r2,8112670c <___svfprintf_internal_r+0x1f18>
81126148:	00801144 	movi	r2,69
8112614c:	b0816226 	beq	r22,r2,811266d8 <___svfprintf_internal_r+0x1ee4>
81126150:	d8c02917 	ldw	r3,164(sp)
81126154:	d8802104 	addi	r2,sp,132
81126158:	d8800315 	stw	r2,12(sp)
8112615c:	d9403617 	ldw	r5,216(sp)
81126160:	d8802504 	addi	r2,sp,148
81126164:	d8800215 	stw	r2,8(sp)
81126168:	d8802604 	addi	r2,sp,152
8112616c:	d8c00015 	stw	r3,0(sp)
81126170:	d8800115 	stw	r2,4(sp)
81126174:	01c00084 	movi	r7,2
81126178:	a00d883a 	mov	r6,r20
8112617c:	9809883a 	mov	r4,r19
81126180:	d8c03d15 	stw	r3,244(sp)
81126184:	da003e15 	stw	r8,248(sp)
81126188:	112aae00 	call	8112aae0 <_dtoa_r>
8112618c:	1021883a 	mov	r16,r2
81126190:	008019c4 	movi	r2,103
81126194:	d8c03d17 	ldw	r3,244(sp)
81126198:	da003e17 	ldw	r8,248(sp)
8112619c:	8880e726 	beq	r17,r2,8112653c <___svfprintf_internal_r+0x1d48>
811261a0:	008011c4 	movi	r2,71
811261a4:	8880d426 	beq	r17,r2,811264f8 <___svfprintf_internal_r+0x1d04>
811261a8:	80f9883a 	add	fp,r16,r3
811261ac:	d9003617 	ldw	r4,216(sp)
811261b0:	000d883a 	mov	r6,zero
811261b4:	000f883a 	mov	r7,zero
811261b8:	a00b883a 	mov	r5,r20
811261bc:	da003e15 	stw	r8,248(sp)
811261c0:	11373900 	call	81137390 <__eqdf2>
811261c4:	da003e17 	ldw	r8,248(sp)
811261c8:	1000e426 	beq	r2,zero,8112655c <___svfprintf_internal_r+0x1d68>
811261cc:	d8802117 	ldw	r2,132(sp)
811261d0:	1700062e 	bgeu	r2,fp,811261ec <___svfprintf_internal_r+0x19f8>
811261d4:	01000c04 	movi	r4,48
811261d8:	10c00044 	addi	r3,r2,1
811261dc:	d8c02115 	stw	r3,132(sp)
811261e0:	11000005 	stb	r4,0(r2)
811261e4:	d8802117 	ldw	r2,132(sp)
811261e8:	173ffb36 	bltu	r2,fp,811261d8 <__reset+0xfb1061d8>
811261ec:	1405c83a 	sub	r2,r2,r16
811261f0:	d8803315 	stw	r2,204(sp)
811261f4:	008011c4 	movi	r2,71
811261f8:	b080c526 	beq	r22,r2,81126510 <___svfprintf_internal_r+0x1d1c>
811261fc:	00801944 	movi	r2,101
81126200:	1441d90e 	bge	r2,r17,81126968 <___svfprintf_internal_r+0x2174>
81126204:	d8c02617 	ldw	r3,152(sp)
81126208:	00801984 	movi	r2,102
8112620c:	d8c03215 	stw	r3,200(sp)
81126210:	88813426 	beq	r17,r2,811266e4 <___svfprintf_internal_r+0x1ef0>
81126214:	d8c03217 	ldw	r3,200(sp)
81126218:	d9003317 	ldw	r4,204(sp)
8112621c:	19012516 	blt	r3,r4,811266b4 <___svfprintf_internal_r+0x1ec0>
81126220:	9480004c 	andi	r18,r18,1
81126224:	9001841e 	bne	r18,zero,81126838 <___svfprintf_internal_r+0x2044>
81126228:	1805883a 	mov	r2,r3
8112622c:	1801cc16 	blt	r3,zero,81126960 <___svfprintf_internal_r+0x216c>
81126230:	d8c03217 	ldw	r3,200(sp)
81126234:	044019c4 	movi	r17,103
81126238:	d8c02e15 	stw	r3,184(sp)
8112623c:	df002a07 	ldb	fp,168(sp)
81126240:	e000a61e 	bne	fp,zero,811264dc <___svfprintf_internal_r+0x1ce8>
81126244:	df002783 	ldbu	fp,158(sp)
81126248:	d8802a15 	stw	r2,168(sp)
8112624c:	dc802b17 	ldw	r18,172(sp)
81126250:	d8002915 	stw	zero,164(sp)
81126254:	003b1706 	br	81124eb4 <__reset+0xfb104eb4>
81126258:	04204574 	movhi	r16,33045
8112625c:	84073b04 	addi	r16,r16,7404
81126260:	003aa606 	br	81124cfc <__reset+0xfb104cfc>
81126264:	d9003917 	ldw	r4,228(sp)
81126268:	04001004 	movi	r16,64
8112626c:	800b883a 	mov	r5,r16
81126270:	11232300 	call	81123230 <_malloc_r>
81126274:	d9002c17 	ldw	r4,176(sp)
81126278:	20800015 	stw	r2,0(r4)
8112627c:	20800415 	stw	r2,16(r4)
81126280:	1001cb26 	beq	r2,zero,811269b0 <___svfprintf_internal_r+0x21bc>
81126284:	d8802c17 	ldw	r2,176(sp)
81126288:	14000515 	stw	r16,20(r2)
8112628c:	00397606 	br	81124868 <__reset+0xfb104868>
81126290:	04204574 	movhi	r16,33045
81126294:	84073d04 	addi	r16,r16,7412
81126298:	003ee106 	br	81125e20 <__reset+0xfb105e20>
8112629c:	d9402c17 	ldw	r5,176(sp)
811262a0:	d9801e04 	addi	r6,sp,120
811262a4:	9809883a 	mov	r4,r19
811262a8:	11314140 	call	81131414 <__ssprint_r>
811262ac:	103a381e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811262b0:	dc402617 	ldw	r17,152(sp)
811262b4:	d8c02017 	ldw	r3,128(sp)
811262b8:	da000404 	addi	r8,sp,16
811262bc:	003f4306 	br	81125fcc <__reset+0xfb105fcc>
811262c0:	01400184 	movi	r5,6
811262c4:	d9402915 	stw	r5,164(sp)
811262c8:	003f9506 	br	81126120 <__reset+0xfb106120>
811262cc:	d9002d17 	ldw	r4,180(sp)
811262d0:	25000017 	ldw	r20,0(r4)
811262d4:	21000104 	addi	r4,r4,4
811262d8:	d9002d15 	stw	r4,180(sp)
811262dc:	a02dd7fa 	srai	r22,r20,31
811262e0:	b005883a 	mov	r2,r22
811262e4:	003a9b06 	br	81124d54 <__reset+0xfb104d54>
811262e8:	d9402d17 	ldw	r5,180(sp)
811262ec:	002d883a 	mov	r22,zero
811262f0:	2d000017 	ldw	r20,0(r5)
811262f4:	29400104 	addi	r5,r5,4
811262f8:	d9402d15 	stw	r5,180(sp)
811262fc:	003bf906 	br	811252e4 <__reset+0xfb1052e4>
81126300:	9480100c 	andi	r18,r18,64
81126304:	90006e26 	beq	r18,zero,811264c0 <___svfprintf_internal_r+0x1ccc>
81126308:	d9002d17 	ldw	r4,180(sp)
8112630c:	d9402f17 	ldw	r5,188(sp)
81126310:	20800017 	ldw	r2,0(r4)
81126314:	21000104 	addi	r4,r4,4
81126318:	d9002d15 	stw	r4,180(sp)
8112631c:	1140000d 	sth	r5,0(r2)
81126320:	00396106 	br	811248a8 <__reset+0xfb1048a8>
81126324:	d9402c17 	ldw	r5,176(sp)
81126328:	d9801e04 	addi	r6,sp,120
8112632c:	9809883a 	mov	r4,r19
81126330:	11314140 	call	81131414 <__ssprint_r>
81126334:	103a161e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81126338:	d8c02017 	ldw	r3,128(sp)
8112633c:	d8801f17 	ldw	r2,124(sp)
81126340:	da000404 	addi	r8,sp,16
81126344:	d9403317 	ldw	r5,204(sp)
81126348:	10800044 	addi	r2,r2,1
8112634c:	44000015 	stw	r16,0(r8)
81126350:	28c7883a 	add	r3,r5,r3
81126354:	003b7706 	br	81125134 <__reset+0xfb105134>
81126358:	8009883a 	mov	r4,r16
8112635c:	da003e15 	stw	r8,248(sp)
81126360:	11244bc0 	call	811244bc <strlen>
81126364:	d8802e15 	stw	r2,184(sp)
81126368:	da003e17 	ldw	r8,248(sp)
8112636c:	103c280e 	bge	r2,zero,81125410 <__reset+0xfb105410>
81126370:	0005883a 	mov	r2,zero
81126374:	003c2606 	br	81125410 <__reset+0xfb105410>
81126378:	00bfffc4 	movi	r2,-1
8112637c:	003a0906 	br	81124ba4 <__reset+0xfb104ba4>
81126380:	01204574 	movhi	r4,33045
81126384:	21074f84 	addi	r4,r4,7486
81126388:	d9003515 	stw	r4,212(sp)
8112638c:	003b0606 	br	81124fa8 <__reset+0xfb104fa8>
81126390:	013fffc4 	movi	r4,-1
81126394:	003a2706 	br	81124c34 <__reset+0xfb104c34>
81126398:	d9402c17 	ldw	r5,176(sp)
8112639c:	d9801e04 	addi	r6,sp,120
811263a0:	9809883a 	mov	r4,r19
811263a4:	11314140 	call	81131414 <__ssprint_r>
811263a8:	1039f91e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
811263ac:	d8c02017 	ldw	r3,128(sp)
811263b0:	da000404 	addi	r8,sp,16
811263b4:	003d8406 	br	811259c8 <__reset+0xfb1059c8>
811263b8:	0023883a 	mov	r17,zero
811263bc:	003d8306 	br	811259cc <__reset+0xfb1059cc>
811263c0:	01204574 	movhi	r4,33045
811263c4:	21074b84 	addi	r4,r4,7470
811263c8:	d9002b15 	stw	r4,172(sp)
811263cc:	d9002b17 	ldw	r4,172(sp)
811263d0:	1c47883a 	add	r3,r3,r17
811263d4:	10800044 	addi	r2,r2,1
811263d8:	41000015 	stw	r4,0(r8)
811263dc:	44400115 	stw	r17,4(r8)
811263e0:	d8c02015 	stw	r3,128(sp)
811263e4:	d8801f15 	stw	r2,124(sp)
811263e8:	010001c4 	movi	r4,7
811263ec:	20bfcd16 	blt	r4,r2,81126324 <__reset+0xfb106324>
811263f0:	42000204 	addi	r8,r8,8
811263f4:	003fd306 	br	81126344 <__reset+0xfb106344>
811263f8:	d9402c17 	ldw	r5,176(sp)
811263fc:	d9801e04 	addi	r6,sp,120
81126400:	9809883a 	mov	r4,r19
81126404:	11314140 	call	81131414 <__ssprint_r>
81126408:	1039e11e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
8112640c:	d8802617 	ldw	r2,152(sp)
81126410:	d8c02017 	ldw	r3,128(sp)
81126414:	da000404 	addi	r8,sp,16
81126418:	003e1c06 	br	81125c8c <__reset+0xfb105c8c>
8112641c:	d8802917 	ldw	r2,164(sp)
81126420:	00c00184 	movi	r3,6
81126424:	1880012e 	bgeu	r3,r2,8112642c <___svfprintf_internal_r+0x1c38>
81126428:	1805883a 	mov	r2,r3
8112642c:	d8802e15 	stw	r2,184(sp)
81126430:	1000f316 	blt	r2,zero,81126800 <___svfprintf_internal_r+0x200c>
81126434:	04204574 	movhi	r16,33045
81126438:	d8802a15 	stw	r2,168(sp)
8112643c:	dd002d15 	stw	r20,180(sp)
81126440:	d8002915 	stw	zero,164(sp)
81126444:	d8003215 	stw	zero,200(sp)
81126448:	84074904 	addi	r16,r16,7460
8112644c:	0039883a 	mov	fp,zero
81126450:	003a9f06 	br	81124ed0 <__reset+0xfb104ed0>
81126454:	01204574 	movhi	r4,33045
81126458:	21074f84 	addi	r4,r4,7486
8112645c:	d9003515 	stw	r4,212(sp)
81126460:	003b5f06 	br	811251e0 <__reset+0xfb1051e0>
81126464:	d9402c17 	ldw	r5,176(sp)
81126468:	d9801e04 	addi	r6,sp,120
8112646c:	9809883a 	mov	r4,r19
81126470:	11314140 	call	81131414 <__ssprint_r>
81126474:	1039c61e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81126478:	d8802617 	ldw	r2,152(sp)
8112647c:	d9403317 	ldw	r5,204(sp)
81126480:	d8c02017 	ldw	r3,128(sp)
81126484:	da000404 	addi	r8,sp,16
81126488:	2885c83a 	sub	r2,r5,r2
8112648c:	003e1006 	br	81125cd0 <__reset+0xfb105cd0>
81126490:	00800044 	movi	r2,1
81126494:	10803fcc 	andi	r2,r2,255
81126498:	00c00044 	movi	r3,1
8112649c:	10fa3526 	beq	r2,r3,81124d74 <__reset+0xfb104d74>
811264a0:	00c00084 	movi	r3,2
811264a4:	10fb9e26 	beq	r2,r3,81125320 <__reset+0xfb105320>
811264a8:	003a6406 	br	81124e3c <__reset+0xfb104e3c>
811264ac:	0021883a 	mov	r16,zero
811264b0:	003e0806 	br	81125cd4 <__reset+0xfb105cd4>
811264b4:	07000b44 	movi	fp,45
811264b8:	df002785 	stb	fp,158(sp)
811264bc:	003a0b06 	br	81124cec <__reset+0xfb104cec>
811264c0:	d8c02d17 	ldw	r3,180(sp)
811264c4:	d9002f17 	ldw	r4,188(sp)
811264c8:	18800017 	ldw	r2,0(r3)
811264cc:	18c00104 	addi	r3,r3,4
811264d0:	d8c02d15 	stw	r3,180(sp)
811264d4:	11000015 	stw	r4,0(r2)
811264d8:	0038f306 	br	811248a8 <__reset+0xfb1048a8>
811264dc:	00c00b44 	movi	r3,45
811264e0:	d8c02785 	stb	r3,158(sp)
811264e4:	d8802a15 	stw	r2,168(sp)
811264e8:	dc802b17 	ldw	r18,172(sp)
811264ec:	d8002915 	stw	zero,164(sp)
811264f0:	07000b44 	movi	fp,45
811264f4:	003a7306 	br	81124ec4 <__reset+0xfb104ec4>
811264f8:	9080004c 	andi	r2,r18,1
811264fc:	1000941e 	bne	r2,zero,81126750 <___svfprintf_internal_r+0x1f5c>
81126500:	d8802117 	ldw	r2,132(sp)
81126504:	1405c83a 	sub	r2,r2,r16
81126508:	d8803315 	stw	r2,204(sp)
8112650c:	b441161e 	bne	r22,r17,81126968 <___svfprintf_internal_r+0x2174>
81126510:	dd802617 	ldw	r22,152(sp)
81126514:	00bfff44 	movi	r2,-3
81126518:	b0801a16 	blt	r22,r2,81126584 <___svfprintf_internal_r+0x1d90>
8112651c:	d9402917 	ldw	r5,164(sp)
81126520:	2d801816 	blt	r5,r22,81126584 <___svfprintf_internal_r+0x1d90>
81126524:	dd803215 	stw	r22,200(sp)
81126528:	003f3a06 	br	81126214 <__reset+0xfb106214>
8112652c:	1025883a 	mov	r18,r2
81126530:	0039883a 	mov	fp,zero
81126534:	00800084 	movi	r2,2
81126538:	003fd606 	br	81126494 <__reset+0xfb106494>
8112653c:	9080004c 	andi	r2,r18,1
81126540:	103f191e 	bne	r2,zero,811261a8 <__reset+0xfb1061a8>
81126544:	d8802117 	ldw	r2,132(sp)
81126548:	003f2806 	br	811261ec <__reset+0xfb1061ec>
8112654c:	01204574 	movhi	r4,33045
81126550:	21074b84 	addi	r4,r4,7470
81126554:	d9002b15 	stw	r4,172(sp)
81126558:	003c7c06 	br	8112574c <__reset+0xfb10574c>
8112655c:	e005883a 	mov	r2,fp
81126560:	003f2206 	br	811261ec <__reset+0xfb1061ec>
81126564:	d9402917 	ldw	r5,164(sp)
81126568:	df002783 	ldbu	fp,158(sp)
8112656c:	dd002d15 	stw	r20,180(sp)
81126570:	d9402a15 	stw	r5,168(sp)
81126574:	d9402e15 	stw	r5,184(sp)
81126578:	d8002915 	stw	zero,164(sp)
8112657c:	d8003215 	stw	zero,200(sp)
81126580:	003a4c06 	br	81124eb4 <__reset+0xfb104eb4>
81126584:	8c7fff84 	addi	r17,r17,-2
81126588:	b5bfffc4 	addi	r22,r22,-1
8112658c:	dd802615 	stw	r22,152(sp)
81126590:	dc4022c5 	stb	r17,139(sp)
81126594:	b000c316 	blt	r22,zero,811268a4 <___svfprintf_internal_r+0x20b0>
81126598:	00800ac4 	movi	r2,43
8112659c:	d8802305 	stb	r2,140(sp)
811265a0:	00800244 	movi	r2,9
811265a4:	15806e16 	blt	r2,r22,81126760 <___svfprintf_internal_r+0x1f6c>
811265a8:	00800c04 	movi	r2,48
811265ac:	b5800c04 	addi	r22,r22,48
811265b0:	d8802345 	stb	r2,141(sp)
811265b4:	dd802385 	stb	r22,142(sp)
811265b8:	d88023c4 	addi	r2,sp,143
811265bc:	df0022c4 	addi	fp,sp,139
811265c0:	d8c03317 	ldw	r3,204(sp)
811265c4:	1739c83a 	sub	fp,r2,fp
811265c8:	d9003317 	ldw	r4,204(sp)
811265cc:	e0c7883a 	add	r3,fp,r3
811265d0:	df003b15 	stw	fp,236(sp)
811265d4:	d8c02e15 	stw	r3,184(sp)
811265d8:	00800044 	movi	r2,1
811265dc:	1100b70e 	bge	r2,r4,811268bc <___svfprintf_internal_r+0x20c8>
811265e0:	d8c02e17 	ldw	r3,184(sp)
811265e4:	18c00044 	addi	r3,r3,1
811265e8:	d8c02e15 	stw	r3,184(sp)
811265ec:	1805883a 	mov	r2,r3
811265f0:	1800b016 	blt	r3,zero,811268b4 <___svfprintf_internal_r+0x20c0>
811265f4:	d8003215 	stw	zero,200(sp)
811265f8:	003f1006 	br	8112623c <__reset+0xfb10623c>
811265fc:	d8802917 	ldw	r2,164(sp)
81126600:	103ec71e 	bne	r2,zero,81126120 <__reset+0xfb106120>
81126604:	dc002915 	stw	r16,164(sp)
81126608:	003ec506 	br	81126120 <__reset+0xfb106120>
8112660c:	d9402c17 	ldw	r5,176(sp)
81126610:	d9801e04 	addi	r6,sp,120
81126614:	9809883a 	mov	r4,r19
81126618:	11314140 	call	81131414 <__ssprint_r>
8112661c:	10395c1e 	bne	r2,zero,81124b90 <__reset+0xfb104b90>
81126620:	dc402617 	ldw	r17,152(sp)
81126624:	d8c02017 	ldw	r3,128(sp)
81126628:	d8801f17 	ldw	r2,124(sp)
8112662c:	da000404 	addi	r8,sp,16
81126630:	003e7706 	br	81126010 <__reset+0xfb106010>
81126634:	582f883a 	mov	r23,r11
81126638:	d8002915 	stw	zero,164(sp)
8112663c:	0038c406 	br	81124950 <__reset+0xfb104950>
81126640:	d8c02917 	ldw	r3,164(sp)
81126644:	d8802104 	addi	r2,sp,132
81126648:	d8800315 	stw	r2,12(sp)
8112664c:	d9403617 	ldw	r5,216(sp)
81126650:	d8802504 	addi	r2,sp,148
81126654:	d8800215 	stw	r2,8(sp)
81126658:	d8802604 	addi	r2,sp,152
8112665c:	d8c00015 	stw	r3,0(sp)
81126660:	9809883a 	mov	r4,r19
81126664:	d8800115 	stw	r2,4(sp)
81126668:	01c000c4 	movi	r7,3
8112666c:	a00d883a 	mov	r6,r20
81126670:	da003e15 	stw	r8,248(sp)
81126674:	112aae00 	call	8112aae0 <_dtoa_r>
81126678:	d9002917 	ldw	r4,164(sp)
8112667c:	da003e17 	ldw	r8,248(sp)
81126680:	1021883a 	mov	r16,r2
81126684:	1139883a 	add	fp,r2,r4
81126688:	2007883a 	mov	r3,r4
8112668c:	81000007 	ldb	r4,0(r16)
81126690:	00800c04 	movi	r2,48
81126694:	20806f26 	beq	r4,r2,81126854 <___svfprintf_internal_r+0x2060>
81126698:	d8c02617 	ldw	r3,152(sp)
8112669c:	e0f9883a 	add	fp,fp,r3
811266a0:	003ec206 	br	811261ac <__reset+0xfb1061ac>
811266a4:	00c00b44 	movi	r3,45
811266a8:	2520003c 	xorhi	r20,r4,32768
811266ac:	d8c02a05 	stb	r3,168(sp)
811266b0:	003ea106 	br	81126138 <__reset+0xfb106138>
811266b4:	d8c03217 	ldw	r3,200(sp)
811266b8:	00c0890e 	bge	zero,r3,811268e0 <___svfprintf_internal_r+0x20ec>
811266bc:	00800044 	movi	r2,1
811266c0:	d9003317 	ldw	r4,204(sp)
811266c4:	1105883a 	add	r2,r2,r4
811266c8:	d8802e15 	stw	r2,184(sp)
811266cc:	10005f16 	blt	r2,zero,8112684c <___svfprintf_internal_r+0x2058>
811266d0:	044019c4 	movi	r17,103
811266d4:	003ed906 	br	8112623c <__reset+0xfb10623c>
811266d8:	d9002917 	ldw	r4,164(sp)
811266dc:	20c00044 	addi	r3,r4,1
811266e0:	003e9c06 	br	81126154 <__reset+0xfb106154>
811266e4:	d9002917 	ldw	r4,164(sp)
811266e8:	00c0680e 	bge	zero,r3,8112688c <___svfprintf_internal_r+0x2098>
811266ec:	2000461e 	bne	r4,zero,81126808 <___svfprintf_internal_r+0x2014>
811266f0:	9480004c 	andi	r18,r18,1
811266f4:	9000441e 	bne	r18,zero,81126808 <___svfprintf_internal_r+0x2014>
811266f8:	1805883a 	mov	r2,r3
811266fc:	1800a016 	blt	r3,zero,81126980 <___svfprintf_internal_r+0x218c>
81126700:	d8c03217 	ldw	r3,200(sp)
81126704:	d8c02e15 	stw	r3,184(sp)
81126708:	003ecc06 	br	8112623c <__reset+0xfb10623c>
8112670c:	d9402917 	ldw	r5,164(sp)
81126710:	d8802104 	addi	r2,sp,132
81126714:	d8800315 	stw	r2,12(sp)
81126718:	d9400015 	stw	r5,0(sp)
8112671c:	d8802504 	addi	r2,sp,148
81126720:	d9403617 	ldw	r5,216(sp)
81126724:	d8800215 	stw	r2,8(sp)
81126728:	d8802604 	addi	r2,sp,152
8112672c:	d8800115 	stw	r2,4(sp)
81126730:	01c000c4 	movi	r7,3
81126734:	a00d883a 	mov	r6,r20
81126738:	9809883a 	mov	r4,r19
8112673c:	da003e15 	stw	r8,248(sp)
81126740:	112aae00 	call	8112aae0 <_dtoa_r>
81126744:	d8c02917 	ldw	r3,164(sp)
81126748:	da003e17 	ldw	r8,248(sp)
8112674c:	1021883a 	mov	r16,r2
81126750:	00801184 	movi	r2,70
81126754:	80f9883a 	add	fp,r16,r3
81126758:	88bfcc26 	beq	r17,r2,8112668c <__reset+0xfb10668c>
8112675c:	003e9306 	br	811261ac <__reset+0xfb1061ac>
81126760:	df0022c4 	addi	fp,sp,139
81126764:	dc002915 	stw	r16,164(sp)
81126768:	9829883a 	mov	r20,r19
8112676c:	e021883a 	mov	r16,fp
81126770:	4027883a 	mov	r19,r8
81126774:	b009883a 	mov	r4,r22
81126778:	01400284 	movi	r5,10
8112677c:	1135ec00 	call	81135ec0 <__modsi3>
81126780:	10800c04 	addi	r2,r2,48
81126784:	843fffc4 	addi	r16,r16,-1
81126788:	b009883a 	mov	r4,r22
8112678c:	01400284 	movi	r5,10
81126790:	80800005 	stb	r2,0(r16)
81126794:	1135e3c0 	call	81135e3c <__divsi3>
81126798:	102d883a 	mov	r22,r2
8112679c:	00800244 	movi	r2,9
811267a0:	15bff416 	blt	r2,r22,81126774 <__reset+0xfb106774>
811267a4:	9811883a 	mov	r8,r19
811267a8:	b0800c04 	addi	r2,r22,48
811267ac:	a027883a 	mov	r19,r20
811267b0:	8029883a 	mov	r20,r16
811267b4:	a17fffc4 	addi	r5,r20,-1
811267b8:	a0bfffc5 	stb	r2,-1(r20)
811267bc:	dc002917 	ldw	r16,164(sp)
811267c0:	2f00752e 	bgeu	r5,fp,81126998 <___svfprintf_internal_r+0x21a4>
811267c4:	d9c02384 	addi	r7,sp,142
811267c8:	3d0fc83a 	sub	r7,r7,r20
811267cc:	d9002344 	addi	r4,sp,141
811267d0:	e1cf883a 	add	r7,fp,r7
811267d4:	00000106 	br	811267dc <___svfprintf_internal_r+0x1fe8>
811267d8:	28800003 	ldbu	r2,0(r5)
811267dc:	20800005 	stb	r2,0(r4)
811267e0:	21000044 	addi	r4,r4,1
811267e4:	29400044 	addi	r5,r5,1
811267e8:	21fffb1e 	bne	r4,r7,811267d8 <__reset+0xfb1067d8>
811267ec:	d8802304 	addi	r2,sp,140
811267f0:	1505c83a 	sub	r2,r2,r20
811267f4:	d8c02344 	addi	r3,sp,141
811267f8:	1885883a 	add	r2,r3,r2
811267fc:	003f7006 	br	811265c0 <__reset+0xfb1065c0>
81126800:	0005883a 	mov	r2,zero
81126804:	003f0b06 	br	81126434 <__reset+0xfb106434>
81126808:	d9002917 	ldw	r4,164(sp)
8112680c:	d8c03217 	ldw	r3,200(sp)
81126810:	20800044 	addi	r2,r4,1
81126814:	1885883a 	add	r2,r3,r2
81126818:	d8802e15 	stw	r2,184(sp)
8112681c:	103e870e 	bge	r2,zero,8112623c <__reset+0xfb10623c>
81126820:	0005883a 	mov	r2,zero
81126824:	003e8506 	br	8112623c <__reset+0xfb10623c>
81126828:	01204574 	movhi	r4,33045
8112682c:	21074b84 	addi	r4,r4,7470
81126830:	d9002b15 	stw	r4,172(sp)
81126834:	003cc506 	br	81125b4c <__reset+0xfb105b4c>
81126838:	d8c03217 	ldw	r3,200(sp)
8112683c:	18c00044 	addi	r3,r3,1
81126840:	d8c02e15 	stw	r3,184(sp)
81126844:	1805883a 	mov	r2,r3
81126848:	183fa10e 	bge	r3,zero,811266d0 <__reset+0xfb1066d0>
8112684c:	0005883a 	mov	r2,zero
81126850:	003f9f06 	br	811266d0 <__reset+0xfb1066d0>
81126854:	d9003617 	ldw	r4,216(sp)
81126858:	000d883a 	mov	r6,zero
8112685c:	000f883a 	mov	r7,zero
81126860:	a00b883a 	mov	r5,r20
81126864:	d8c03d15 	stw	r3,244(sp)
81126868:	da003e15 	stw	r8,248(sp)
8112686c:	11373900 	call	81137390 <__eqdf2>
81126870:	d8c03d17 	ldw	r3,244(sp)
81126874:	da003e17 	ldw	r8,248(sp)
81126878:	103f8726 	beq	r2,zero,81126698 <__reset+0xfb106698>
8112687c:	00800044 	movi	r2,1
81126880:	10c7c83a 	sub	r3,r2,r3
81126884:	d8c02615 	stw	r3,152(sp)
81126888:	003f8406 	br	8112669c <__reset+0xfb10669c>
8112688c:	20000e1e 	bne	r4,zero,811268c8 <___svfprintf_internal_r+0x20d4>
81126890:	9480004c 	andi	r18,r18,1
81126894:	90000c1e 	bne	r18,zero,811268c8 <___svfprintf_internal_r+0x20d4>
81126898:	00800044 	movi	r2,1
8112689c:	d8802e15 	stw	r2,184(sp)
811268a0:	003e6606 	br	8112623c <__reset+0xfb10623c>
811268a4:	00800b44 	movi	r2,45
811268a8:	05adc83a 	sub	r22,zero,r22
811268ac:	d8802305 	stb	r2,140(sp)
811268b0:	003f3b06 	br	811265a0 <__reset+0xfb1065a0>
811268b4:	0005883a 	mov	r2,zero
811268b8:	003f4e06 	br	811265f4 <__reset+0xfb1065f4>
811268bc:	90a4703a 	and	r18,r18,r2
811268c0:	903f4a26 	beq	r18,zero,811265ec <__reset+0xfb1065ec>
811268c4:	003f4606 	br	811265e0 <__reset+0xfb1065e0>
811268c8:	d8c02917 	ldw	r3,164(sp)
811268cc:	18c00084 	addi	r3,r3,2
811268d0:	d8c02e15 	stw	r3,184(sp)
811268d4:	1805883a 	mov	r2,r3
811268d8:	183e580e 	bge	r3,zero,8112623c <__reset+0xfb10623c>
811268dc:	003fd006 	br	81126820 <__reset+0xfb106820>
811268e0:	00800084 	movi	r2,2
811268e4:	10c5c83a 	sub	r2,r2,r3
811268e8:	003f7506 	br	811266c0 <__reset+0xfb1066c0>
811268ec:	d8802d17 	ldw	r2,180(sp)
811268f0:	d9002d17 	ldw	r4,180(sp)
811268f4:	bc400043 	ldbu	r17,1(r23)
811268f8:	10800017 	ldw	r2,0(r2)
811268fc:	582f883a 	mov	r23,r11
81126900:	d8802915 	stw	r2,164(sp)
81126904:	20800104 	addi	r2,r4,4
81126908:	d9002917 	ldw	r4,164(sp)
8112690c:	d8802d15 	stw	r2,180(sp)
81126910:	203df00e 	bge	r4,zero,811260d4 <__reset+0xfb1060d4>
81126914:	8c403fcc 	andi	r17,r17,255
81126918:	00bfffc4 	movi	r2,-1
8112691c:	8c40201c 	xori	r17,r17,128
81126920:	d8802915 	stw	r2,164(sp)
81126924:	8c7fe004 	addi	r17,r17,-128
81126928:	00380806 	br	8112494c <__reset+0xfb10494c>
8112692c:	9080004c 	andi	r2,r18,1
81126930:	0039883a 	mov	fp,zero
81126934:	10000726 	beq	r2,zero,81126954 <___svfprintf_internal_r+0x2160>
81126938:	d8c02817 	ldw	r3,160(sp)
8112693c:	dc001dc4 	addi	r16,sp,119
81126940:	00800c04 	movi	r2,48
81126944:	1c07c83a 	sub	r3,r3,r16
81126948:	d8801dc5 	stb	r2,119(sp)
8112694c:	d8c02e15 	stw	r3,184(sp)
81126950:	00395206 	br	81124e9c <__reset+0xfb104e9c>
81126954:	d8002e15 	stw	zero,184(sp)
81126958:	dc001e04 	addi	r16,sp,120
8112695c:	00394f06 	br	81124e9c <__reset+0xfb104e9c>
81126960:	0005883a 	mov	r2,zero
81126964:	003e3206 	br	81126230 <__reset+0xfb106230>
81126968:	dd802617 	ldw	r22,152(sp)
8112696c:	003f0606 	br	81126588 <__reset+0xfb106588>
81126970:	d9c02785 	stb	r7,158(sp)
81126974:	003a5106 	br	811252bc <__reset+0xfb1052bc>
81126978:	d9c02785 	stb	r7,158(sp)
8112697c:	003a3706 	br	8112525c <__reset+0xfb10525c>
81126980:	0005883a 	mov	r2,zero
81126984:	003f5e06 	br	81126700 <__reset+0xfb106700>
81126988:	d9c02785 	stb	r7,158(sp)
8112698c:	00391706 	br	81124dec <__reset+0xfb104dec>
81126990:	d9c02785 	stb	r7,158(sp)
81126994:	0038e606 	br	81124d30 <__reset+0xfb104d30>
81126998:	d8802344 	addi	r2,sp,141
8112699c:	003f0806 	br	811265c0 <__reset+0xfb1065c0>
811269a0:	d9c02785 	stb	r7,158(sp)
811269a4:	0038b706 	br	81124c84 <__reset+0xfb104c84>
811269a8:	d9c02785 	stb	r7,158(sp)
811269ac:	003adc06 	br	81125520 <__reset+0xfb105520>
811269b0:	d9403917 	ldw	r5,228(sp)
811269b4:	00800304 	movi	r2,12
811269b8:	28800015 	stw	r2,0(r5)
811269bc:	00bfffc4 	movi	r2,-1
811269c0:	00387806 	br	81124ba4 <__reset+0xfb104ba4>
811269c4:	d9c02785 	stb	r7,158(sp)
811269c8:	003abf06 	br	811254c8 <__reset+0xfb1054c8>
811269cc:	d9c02785 	stb	r7,158(sp)
811269d0:	003a9b06 	br	81125440 <__reset+0xfb105440>

811269d4 <___vfprintf_internal_r>:
811269d4:	deffb804 	addi	sp,sp,-288
811269d8:	de00012e 	bgeu	sp,et,811269e0 <___vfprintf_internal_r+0xc>
811269dc:	003b68fa 	trap	3
811269e0:	dfc04715 	stw	ra,284(sp)
811269e4:	ddc04515 	stw	r23,276(sp)
811269e8:	dd404315 	stw	r21,268(sp)
811269ec:	d9002c15 	stw	r4,176(sp)
811269f0:	282f883a 	mov	r23,r5
811269f4:	302b883a 	mov	r21,r6
811269f8:	d9c02d15 	stw	r7,180(sp)
811269fc:	df004615 	stw	fp,280(sp)
81126a00:	dd804415 	stw	r22,272(sp)
81126a04:	dd004215 	stw	r20,264(sp)
81126a08:	dcc04115 	stw	r19,260(sp)
81126a0c:	dc804015 	stw	r18,256(sp)
81126a10:	dc403f15 	stw	r17,252(sp)
81126a14:	dc003e15 	stw	r16,248(sp)
81126a18:	112d6dc0 	call	8112d6dc <_localeconv_r>
81126a1c:	10800017 	ldw	r2,0(r2)
81126a20:	1009883a 	mov	r4,r2
81126a24:	d8803415 	stw	r2,208(sp)
81126a28:	11244bc0 	call	811244bc <strlen>
81126a2c:	d8803715 	stw	r2,220(sp)
81126a30:	d8802c17 	ldw	r2,176(sp)
81126a34:	10000226 	beq	r2,zero,81126a40 <___vfprintf_internal_r+0x6c>
81126a38:	10800e17 	ldw	r2,56(r2)
81126a3c:	1000f926 	beq	r2,zero,81126e24 <___vfprintf_internal_r+0x450>
81126a40:	b880030b 	ldhu	r2,12(r23)
81126a44:	10c8000c 	andi	r3,r2,8192
81126a48:	1800061e 	bne	r3,zero,81126a64 <___vfprintf_internal_r+0x90>
81126a4c:	b9001917 	ldw	r4,100(r23)
81126a50:	00f7ffc4 	movi	r3,-8193
81126a54:	10880014 	ori	r2,r2,8192
81126a58:	20c6703a 	and	r3,r4,r3
81126a5c:	b880030d 	sth	r2,12(r23)
81126a60:	b8c01915 	stw	r3,100(r23)
81126a64:	10c0020c 	andi	r3,r2,8
81126a68:	1800c126 	beq	r3,zero,81126d70 <___vfprintf_internal_r+0x39c>
81126a6c:	b8c00417 	ldw	r3,16(r23)
81126a70:	1800bf26 	beq	r3,zero,81126d70 <___vfprintf_internal_r+0x39c>
81126a74:	1080068c 	andi	r2,r2,26
81126a78:	00c00284 	movi	r3,10
81126a7c:	10c0c426 	beq	r2,r3,81126d90 <___vfprintf_internal_r+0x3bc>
81126a80:	d8c00404 	addi	r3,sp,16
81126a84:	05204574 	movhi	r20,33045
81126a88:	d9001e04 	addi	r4,sp,120
81126a8c:	a5075384 	addi	r20,r20,7502
81126a90:	d8c01e15 	stw	r3,120(sp)
81126a94:	d8002015 	stw	zero,128(sp)
81126a98:	d8001f15 	stw	zero,124(sp)
81126a9c:	d8003315 	stw	zero,204(sp)
81126aa0:	d8003615 	stw	zero,216(sp)
81126aa4:	d8003815 	stw	zero,224(sp)
81126aa8:	1811883a 	mov	r8,r3
81126aac:	d8003915 	stw	zero,228(sp)
81126ab0:	d8003a15 	stw	zero,232(sp)
81126ab4:	d8002f15 	stw	zero,188(sp)
81126ab8:	d9002815 	stw	r4,160(sp)
81126abc:	a8800007 	ldb	r2,0(r21)
81126ac0:	10027b26 	beq	r2,zero,811274b0 <___vfprintf_internal_r+0xadc>
81126ac4:	00c00944 	movi	r3,37
81126ac8:	a821883a 	mov	r16,r21
81126acc:	10c0021e 	bne	r2,r3,81126ad8 <___vfprintf_internal_r+0x104>
81126ad0:	00001406 	br	81126b24 <___vfprintf_internal_r+0x150>
81126ad4:	10c00326 	beq	r2,r3,81126ae4 <___vfprintf_internal_r+0x110>
81126ad8:	84000044 	addi	r16,r16,1
81126adc:	80800007 	ldb	r2,0(r16)
81126ae0:	103ffc1e 	bne	r2,zero,81126ad4 <__reset+0xfb106ad4>
81126ae4:	8563c83a 	sub	r17,r16,r21
81126ae8:	88000e26 	beq	r17,zero,81126b24 <___vfprintf_internal_r+0x150>
81126aec:	d8c02017 	ldw	r3,128(sp)
81126af0:	d8801f17 	ldw	r2,124(sp)
81126af4:	45400015 	stw	r21,0(r8)
81126af8:	1c47883a 	add	r3,r3,r17
81126afc:	10800044 	addi	r2,r2,1
81126b00:	d8c02015 	stw	r3,128(sp)
81126b04:	44400115 	stw	r17,4(r8)
81126b08:	d8801f15 	stw	r2,124(sp)
81126b0c:	00c001c4 	movi	r3,7
81126b10:	1880a716 	blt	r3,r2,81126db0 <___vfprintf_internal_r+0x3dc>
81126b14:	42000204 	addi	r8,r8,8
81126b18:	d9402f17 	ldw	r5,188(sp)
81126b1c:	2c4b883a 	add	r5,r5,r17
81126b20:	d9402f15 	stw	r5,188(sp)
81126b24:	80800007 	ldb	r2,0(r16)
81126b28:	1000a826 	beq	r2,zero,81126dcc <___vfprintf_internal_r+0x3f8>
81126b2c:	84400047 	ldb	r17,1(r16)
81126b30:	00bfffc4 	movi	r2,-1
81126b34:	85400044 	addi	r21,r16,1
81126b38:	d8002785 	stb	zero,158(sp)
81126b3c:	0007883a 	mov	r3,zero
81126b40:	000f883a 	mov	r7,zero
81126b44:	d8802915 	stw	r2,164(sp)
81126b48:	d8003115 	stw	zero,196(sp)
81126b4c:	0025883a 	mov	r18,zero
81126b50:	01401604 	movi	r5,88
81126b54:	01800244 	movi	r6,9
81126b58:	02800a84 	movi	r10,42
81126b5c:	02401b04 	movi	r9,108
81126b60:	ad400044 	addi	r21,r21,1
81126b64:	88bff804 	addi	r2,r17,-32
81126b68:	28830436 	bltu	r5,r2,8112777c <___vfprintf_internal_r+0xda8>
81126b6c:	100490ba 	slli	r2,r2,2
81126b70:	012044b4 	movhi	r4,33042
81126b74:	211ae104 	addi	r4,r4,27524
81126b78:	1105883a 	add	r2,r2,r4
81126b7c:	10800017 	ldw	r2,0(r2)
81126b80:	1000683a 	jmp	r2
81126b84:	8112769c 	xori	r4,r16,18906
81126b88:	8112777c 	xorhi	r4,r16,18909
81126b8c:	8112777c 	xorhi	r4,r16,18909
81126b90:	811276bc 	xorhi	r4,r16,18906
81126b94:	8112777c 	xorhi	r4,r16,18909
81126b98:	8112777c 	xorhi	r4,r16,18909
81126b9c:	8112777c 	xorhi	r4,r16,18909
81126ba0:	8112777c 	xorhi	r4,r16,18909
81126ba4:	8112777c 	xorhi	r4,r16,18909
81126ba8:	8112777c 	xorhi	r4,r16,18909
81126bac:	81126e30 	cmpltui	r4,r16,18872
81126bb0:	811275d8 	cmpnei	r4,r16,18903
81126bb4:	8112777c 	xorhi	r4,r16,18909
81126bb8:	81126cf8 	rdprs	r4,r16,18867
81126bbc:	81126e58 	cmpnei	r4,r16,18873
81126bc0:	8112777c 	xorhi	r4,r16,18909
81126bc4:	81126e98 	cmpnei	r4,r16,18874
81126bc8:	81126ea4 	muli	r4,r16,18874
81126bcc:	81126ea4 	muli	r4,r16,18874
81126bd0:	81126ea4 	muli	r4,r16,18874
81126bd4:	81126ea4 	muli	r4,r16,18874
81126bd8:	81126ea4 	muli	r4,r16,18874
81126bdc:	81126ea4 	muli	r4,r16,18874
81126be0:	81126ea4 	muli	r4,r16,18874
81126be4:	81126ea4 	muli	r4,r16,18874
81126be8:	81126ea4 	muli	r4,r16,18874
81126bec:	8112777c 	xorhi	r4,r16,18909
81126bf0:	8112777c 	xorhi	r4,r16,18909
81126bf4:	8112777c 	xorhi	r4,r16,18909
81126bf8:	8112777c 	xorhi	r4,r16,18909
81126bfc:	8112777c 	xorhi	r4,r16,18909
81126c00:	8112777c 	xorhi	r4,r16,18909
81126c04:	8112777c 	xorhi	r4,r16,18909
81126c08:	8112777c 	xorhi	r4,r16,18909
81126c0c:	8112777c 	xorhi	r4,r16,18909
81126c10:	8112777c 	xorhi	r4,r16,18909
81126c14:	81126ed8 	cmpnei	r4,r16,18875
81126c18:	81126f94 	ori	r4,r16,18878
81126c1c:	8112777c 	xorhi	r4,r16,18909
81126c20:	81126f94 	ori	r4,r16,18878
81126c24:	8112777c 	xorhi	r4,r16,18909
81126c28:	8112777c 	xorhi	r4,r16,18909
81126c2c:	8112777c 	xorhi	r4,r16,18909
81126c30:	8112777c 	xorhi	r4,r16,18909
81126c34:	81127034 	orhi	r4,r16,18880
81126c38:	8112777c 	xorhi	r4,r16,18909
81126c3c:	8112777c 	xorhi	r4,r16,18909
81126c40:	81127040 	call	88112704 <__reset+0x20f2704>
81126c44:	8112777c 	xorhi	r4,r16,18909
81126c48:	8112777c 	xorhi	r4,r16,18909
81126c4c:	8112777c 	xorhi	r4,r16,18909
81126c50:	8112777c 	xorhi	r4,r16,18909
81126c54:	8112777c 	xorhi	r4,r16,18909
81126c58:	811274b8 	rdprs	r4,r16,18898
81126c5c:	8112777c 	xorhi	r4,r16,18909
81126c60:	8112777c 	xorhi	r4,r16,18909
81126c64:	81127518 	cmpnei	r4,r16,18900
81126c68:	8112777c 	xorhi	r4,r16,18909
81126c6c:	8112777c 	xorhi	r4,r16,18909
81126c70:	8112777c 	xorhi	r4,r16,18909
81126c74:	8112777c 	xorhi	r4,r16,18909
81126c78:	8112777c 	xorhi	r4,r16,18909
81126c7c:	8112777c 	xorhi	r4,r16,18909
81126c80:	8112777c 	xorhi	r4,r16,18909
81126c84:	8112777c 	xorhi	r4,r16,18909
81126c88:	8112777c 	xorhi	r4,r16,18909
81126c8c:	8112777c 	xorhi	r4,r16,18909
81126c90:	81127728 	cmpgeui	r4,r16,18908
81126c94:	811276c8 	cmpgei	r4,r16,18907
81126c98:	81126f94 	ori	r4,r16,18878
81126c9c:	81126f94 	ori	r4,r16,18878
81126ca0:	81126f94 	ori	r4,r16,18878
81126ca4:	811276d8 	cmpnei	r4,r16,18907
81126ca8:	811276c8 	cmpgei	r4,r16,18907
81126cac:	8112777c 	xorhi	r4,r16,18909
81126cb0:	8112777c 	xorhi	r4,r16,18909
81126cb4:	811276e4 	muli	r4,r16,18907
81126cb8:	8112777c 	xorhi	r4,r16,18909
81126cbc:	811276f4 	orhi	r4,r16,18907
81126cc0:	811275c8 	cmpgei	r4,r16,18903
81126cc4:	81126d04 	addi	r4,r16,18868
81126cc8:	811275e8 	cmpgeui	r4,r16,18903
81126ccc:	8112777c 	xorhi	r4,r16,18909
81126cd0:	811275f4 	orhi	r4,r16,18903
81126cd4:	8112777c 	xorhi	r4,r16,18909
81126cd8:	81127650 	cmplti	r4,r16,18905
81126cdc:	8112777c 	xorhi	r4,r16,18909
81126ce0:	8112777c 	xorhi	r4,r16,18909
81126ce4:	81127660 	cmpeqi	r4,r16,18905
81126ce8:	d9003117 	ldw	r4,196(sp)
81126cec:	d8802d15 	stw	r2,180(sp)
81126cf0:	0109c83a 	sub	r4,zero,r4
81126cf4:	d9003115 	stw	r4,196(sp)
81126cf8:	94800114 	ori	r18,r18,4
81126cfc:	ac400007 	ldb	r17,0(r21)
81126d00:	003f9706 	br	81126b60 <__reset+0xfb106b60>
81126d04:	00800c04 	movi	r2,48
81126d08:	d9002d17 	ldw	r4,180(sp)
81126d0c:	d9402917 	ldw	r5,164(sp)
81126d10:	d8802705 	stb	r2,156(sp)
81126d14:	00801e04 	movi	r2,120
81126d18:	d8802745 	stb	r2,157(sp)
81126d1c:	d8002785 	stb	zero,158(sp)
81126d20:	20c00104 	addi	r3,r4,4
81126d24:	24c00017 	ldw	r19,0(r4)
81126d28:	002d883a 	mov	r22,zero
81126d2c:	90800094 	ori	r2,r18,2
81126d30:	28029a16 	blt	r5,zero,8112779c <___vfprintf_internal_r+0xdc8>
81126d34:	00bfdfc4 	movi	r2,-129
81126d38:	90a4703a 	and	r18,r18,r2
81126d3c:	d8c02d15 	stw	r3,180(sp)
81126d40:	94800094 	ori	r18,r18,2
81126d44:	9802871e 	bne	r19,zero,81127764 <___vfprintf_internal_r+0xd90>
81126d48:	00a04574 	movhi	r2,33045
81126d4c:	10874404 	addi	r2,r2,7440
81126d50:	d8803915 	stw	r2,228(sp)
81126d54:	04401e04 	movi	r17,120
81126d58:	d8802917 	ldw	r2,164(sp)
81126d5c:	0039883a 	mov	fp,zero
81126d60:	1001e926 	beq	r2,zero,81127508 <___vfprintf_internal_r+0xb34>
81126d64:	0027883a 	mov	r19,zero
81126d68:	002d883a 	mov	r22,zero
81126d6c:	00020506 	br	81127584 <___vfprintf_internal_r+0xbb0>
81126d70:	d9002c17 	ldw	r4,176(sp)
81126d74:	b80b883a 	mov	r5,r23
81126d78:	112a7200 	call	8112a720 <__swsetup_r>
81126d7c:	1005ac1e 	bne	r2,zero,81128430 <___vfprintf_internal_r+0x1a5c>
81126d80:	b880030b 	ldhu	r2,12(r23)
81126d84:	00c00284 	movi	r3,10
81126d88:	1080068c 	andi	r2,r2,26
81126d8c:	10ff3c1e 	bne	r2,r3,81126a80 <__reset+0xfb106a80>
81126d90:	b880038f 	ldh	r2,14(r23)
81126d94:	103f3a16 	blt	r2,zero,81126a80 <__reset+0xfb106a80>
81126d98:	d9c02d17 	ldw	r7,180(sp)
81126d9c:	d9002c17 	ldw	r4,176(sp)
81126da0:	a80d883a 	mov	r6,r21
81126da4:	b80b883a 	mov	r5,r23
81126da8:	1128bf00 	call	81128bf0 <__sbprintf>
81126dac:	00001106 	br	81126df4 <___vfprintf_internal_r+0x420>
81126db0:	d9002c17 	ldw	r4,176(sp)
81126db4:	d9801e04 	addi	r6,sp,120
81126db8:	b80b883a 	mov	r5,r23
81126dbc:	1132bc40 	call	81132bc4 <__sprint_r>
81126dc0:	1000081e 	bne	r2,zero,81126de4 <___vfprintf_internal_r+0x410>
81126dc4:	da000404 	addi	r8,sp,16
81126dc8:	003f5306 	br	81126b18 <__reset+0xfb106b18>
81126dcc:	d8802017 	ldw	r2,128(sp)
81126dd0:	10000426 	beq	r2,zero,81126de4 <___vfprintf_internal_r+0x410>
81126dd4:	d9002c17 	ldw	r4,176(sp)
81126dd8:	d9801e04 	addi	r6,sp,120
81126ddc:	b80b883a 	mov	r5,r23
81126de0:	1132bc40 	call	81132bc4 <__sprint_r>
81126de4:	b880030b 	ldhu	r2,12(r23)
81126de8:	1080100c 	andi	r2,r2,64
81126dec:	1005901e 	bne	r2,zero,81128430 <___vfprintf_internal_r+0x1a5c>
81126df0:	d8802f17 	ldw	r2,188(sp)
81126df4:	dfc04717 	ldw	ra,284(sp)
81126df8:	df004617 	ldw	fp,280(sp)
81126dfc:	ddc04517 	ldw	r23,276(sp)
81126e00:	dd804417 	ldw	r22,272(sp)
81126e04:	dd404317 	ldw	r21,268(sp)
81126e08:	dd004217 	ldw	r20,264(sp)
81126e0c:	dcc04117 	ldw	r19,260(sp)
81126e10:	dc804017 	ldw	r18,256(sp)
81126e14:	dc403f17 	ldw	r17,252(sp)
81126e18:	dc003e17 	ldw	r16,248(sp)
81126e1c:	dec04804 	addi	sp,sp,288
81126e20:	f800283a 	ret
81126e24:	d9002c17 	ldw	r4,176(sp)
81126e28:	112c7900 	call	8112c790 <__sinit>
81126e2c:	003f0406 	br	81126a40 <__reset+0xfb106a40>
81126e30:	d8802d17 	ldw	r2,180(sp)
81126e34:	d9002d17 	ldw	r4,180(sp)
81126e38:	10800017 	ldw	r2,0(r2)
81126e3c:	d8803115 	stw	r2,196(sp)
81126e40:	20800104 	addi	r2,r4,4
81126e44:	d9003117 	ldw	r4,196(sp)
81126e48:	203fa716 	blt	r4,zero,81126ce8 <__reset+0xfb106ce8>
81126e4c:	d8802d15 	stw	r2,180(sp)
81126e50:	ac400007 	ldb	r17,0(r21)
81126e54:	003f4206 	br	81126b60 <__reset+0xfb106b60>
81126e58:	ac400007 	ldb	r17,0(r21)
81126e5c:	aac00044 	addi	r11,r21,1
81126e60:	8a872826 	beq	r17,r10,81128b04 <___vfprintf_internal_r+0x2130>
81126e64:	88bff404 	addi	r2,r17,-48
81126e68:	0009883a 	mov	r4,zero
81126e6c:	30867d36 	bltu	r6,r2,81128864 <___vfprintf_internal_r+0x1e90>
81126e70:	5c400007 	ldb	r17,0(r11)
81126e74:	210002a4 	muli	r4,r4,10
81126e78:	5d400044 	addi	r21,r11,1
81126e7c:	a817883a 	mov	r11,r21
81126e80:	2089883a 	add	r4,r4,r2
81126e84:	88bff404 	addi	r2,r17,-48
81126e88:	30bff92e 	bgeu	r6,r2,81126e70 <__reset+0xfb106e70>
81126e8c:	2005c916 	blt	r4,zero,811285b4 <___vfprintf_internal_r+0x1be0>
81126e90:	d9002915 	stw	r4,164(sp)
81126e94:	003f3306 	br	81126b64 <__reset+0xfb106b64>
81126e98:	94802014 	ori	r18,r18,128
81126e9c:	ac400007 	ldb	r17,0(r21)
81126ea0:	003f2f06 	br	81126b60 <__reset+0xfb106b60>
81126ea4:	a809883a 	mov	r4,r21
81126ea8:	d8003115 	stw	zero,196(sp)
81126eac:	88bff404 	addi	r2,r17,-48
81126eb0:	0017883a 	mov	r11,zero
81126eb4:	24400007 	ldb	r17,0(r4)
81126eb8:	5ac002a4 	muli	r11,r11,10
81126ebc:	ad400044 	addi	r21,r21,1
81126ec0:	a809883a 	mov	r4,r21
81126ec4:	12d7883a 	add	r11,r2,r11
81126ec8:	88bff404 	addi	r2,r17,-48
81126ecc:	30bff92e 	bgeu	r6,r2,81126eb4 <__reset+0xfb106eb4>
81126ed0:	dac03115 	stw	r11,196(sp)
81126ed4:	003f2306 	br	81126b64 <__reset+0xfb106b64>
81126ed8:	18c03fcc 	andi	r3,r3,255
81126edc:	18072b1e 	bne	r3,zero,81128b8c <___vfprintf_internal_r+0x21b8>
81126ee0:	94800414 	ori	r18,r18,16
81126ee4:	9080080c 	andi	r2,r18,32
81126ee8:	10037b26 	beq	r2,zero,81127cd8 <___vfprintf_internal_r+0x1304>
81126eec:	d9402d17 	ldw	r5,180(sp)
81126ef0:	28800117 	ldw	r2,4(r5)
81126ef4:	2cc00017 	ldw	r19,0(r5)
81126ef8:	29400204 	addi	r5,r5,8
81126efc:	d9402d15 	stw	r5,180(sp)
81126f00:	102d883a 	mov	r22,r2
81126f04:	10044b16 	blt	r2,zero,81128034 <___vfprintf_internal_r+0x1660>
81126f08:	d9402917 	ldw	r5,164(sp)
81126f0c:	df002783 	ldbu	fp,158(sp)
81126f10:	2803bc16 	blt	r5,zero,81127e04 <___vfprintf_internal_r+0x1430>
81126f14:	00ffdfc4 	movi	r3,-129
81126f18:	9d84b03a 	or	r2,r19,r22
81126f1c:	90e4703a 	and	r18,r18,r3
81126f20:	10017726 	beq	r2,zero,81127500 <___vfprintf_internal_r+0xb2c>
81126f24:	b0038326 	beq	r22,zero,81127d34 <___vfprintf_internal_r+0x1360>
81126f28:	dc402a15 	stw	r17,168(sp)
81126f2c:	dc001e04 	addi	r16,sp,120
81126f30:	b023883a 	mov	r17,r22
81126f34:	402d883a 	mov	r22,r8
81126f38:	9809883a 	mov	r4,r19
81126f3c:	880b883a 	mov	r5,r17
81126f40:	01800284 	movi	r6,10
81126f44:	000f883a 	mov	r7,zero
81126f48:	11358fc0 	call	811358fc <__umoddi3>
81126f4c:	10800c04 	addi	r2,r2,48
81126f50:	843fffc4 	addi	r16,r16,-1
81126f54:	9809883a 	mov	r4,r19
81126f58:	880b883a 	mov	r5,r17
81126f5c:	80800005 	stb	r2,0(r16)
81126f60:	01800284 	movi	r6,10
81126f64:	000f883a 	mov	r7,zero
81126f68:	113537c0 	call	8113537c <__udivdi3>
81126f6c:	1027883a 	mov	r19,r2
81126f70:	10c4b03a 	or	r2,r2,r3
81126f74:	1823883a 	mov	r17,r3
81126f78:	103fef1e 	bne	r2,zero,81126f38 <__reset+0xfb106f38>
81126f7c:	d8c02817 	ldw	r3,160(sp)
81126f80:	dc402a17 	ldw	r17,168(sp)
81126f84:	b011883a 	mov	r8,r22
81126f88:	1c07c83a 	sub	r3,r3,r16
81126f8c:	d8c02e15 	stw	r3,184(sp)
81126f90:	00005906 	br	811270f8 <___vfprintf_internal_r+0x724>
81126f94:	18c03fcc 	andi	r3,r3,255
81126f98:	1806fa1e 	bne	r3,zero,81128b84 <___vfprintf_internal_r+0x21b0>
81126f9c:	9080020c 	andi	r2,r18,8
81126fa0:	10048a26 	beq	r2,zero,811281cc <___vfprintf_internal_r+0x17f8>
81126fa4:	d8c02d17 	ldw	r3,180(sp)
81126fa8:	d9002d17 	ldw	r4,180(sp)
81126fac:	d9402d17 	ldw	r5,180(sp)
81126fb0:	18c00017 	ldw	r3,0(r3)
81126fb4:	21000117 	ldw	r4,4(r4)
81126fb8:	29400204 	addi	r5,r5,8
81126fbc:	d8c03615 	stw	r3,216(sp)
81126fc0:	d9003815 	stw	r4,224(sp)
81126fc4:	d9402d15 	stw	r5,180(sp)
81126fc8:	d9003617 	ldw	r4,216(sp)
81126fcc:	d9403817 	ldw	r5,224(sp)
81126fd0:	da003d15 	stw	r8,244(sp)
81126fd4:	04000044 	movi	r16,1
81126fd8:	112f2280 	call	8112f228 <__fpclassifyd>
81126fdc:	da003d17 	ldw	r8,244(sp)
81126fe0:	14041f1e 	bne	r2,r16,81128060 <___vfprintf_internal_r+0x168c>
81126fe4:	d9003617 	ldw	r4,216(sp)
81126fe8:	d9403817 	ldw	r5,224(sp)
81126fec:	000d883a 	mov	r6,zero
81126ff0:	000f883a 	mov	r7,zero
81126ff4:	11374180 	call	81137418 <__ledf2>
81126ff8:	da003d17 	ldw	r8,244(sp)
81126ffc:	1005be16 	blt	r2,zero,811286f8 <___vfprintf_internal_r+0x1d24>
81127000:	df002783 	ldbu	fp,158(sp)
81127004:	008011c4 	movi	r2,71
81127008:	1445330e 	bge	r2,r17,811284d8 <___vfprintf_internal_r+0x1b04>
8112700c:	04204574 	movhi	r16,33045
81127010:	84073c04 	addi	r16,r16,7408
81127014:	00c000c4 	movi	r3,3
81127018:	00bfdfc4 	movi	r2,-129
8112701c:	d8c02a15 	stw	r3,168(sp)
81127020:	90a4703a 	and	r18,r18,r2
81127024:	d8c02e15 	stw	r3,184(sp)
81127028:	d8002915 	stw	zero,164(sp)
8112702c:	d8003215 	stw	zero,200(sp)
81127030:	00003706 	br	81127110 <___vfprintf_internal_r+0x73c>
81127034:	94800214 	ori	r18,r18,8
81127038:	ac400007 	ldb	r17,0(r21)
8112703c:	003ec806 	br	81126b60 <__reset+0xfb106b60>
81127040:	18c03fcc 	andi	r3,r3,255
81127044:	1806db1e 	bne	r3,zero,81128bb4 <___vfprintf_internal_r+0x21e0>
81127048:	94800414 	ori	r18,r18,16
8112704c:	9080080c 	andi	r2,r18,32
81127050:	1002d826 	beq	r2,zero,81127bb4 <___vfprintf_internal_r+0x11e0>
81127054:	d9402d17 	ldw	r5,180(sp)
81127058:	d8c02917 	ldw	r3,164(sp)
8112705c:	d8002785 	stb	zero,158(sp)
81127060:	28800204 	addi	r2,r5,8
81127064:	2cc00017 	ldw	r19,0(r5)
81127068:	2d800117 	ldw	r22,4(r5)
8112706c:	18048f16 	blt	r3,zero,811282ac <___vfprintf_internal_r+0x18d8>
81127070:	013fdfc4 	movi	r4,-129
81127074:	9d86b03a 	or	r3,r19,r22
81127078:	d8802d15 	stw	r2,180(sp)
8112707c:	9124703a 	and	r18,r18,r4
81127080:	1802d91e 	bne	r3,zero,81127be8 <___vfprintf_internal_r+0x1214>
81127084:	d8c02917 	ldw	r3,164(sp)
81127088:	0039883a 	mov	fp,zero
8112708c:	1805c326 	beq	r3,zero,8112879c <___vfprintf_internal_r+0x1dc8>
81127090:	0027883a 	mov	r19,zero
81127094:	002d883a 	mov	r22,zero
81127098:	dc001e04 	addi	r16,sp,120
8112709c:	9806d0fa 	srli	r3,r19,3
811270a0:	b008977a 	slli	r4,r22,29
811270a4:	b02cd0fa 	srli	r22,r22,3
811270a8:	9cc001cc 	andi	r19,r19,7
811270ac:	98800c04 	addi	r2,r19,48
811270b0:	843fffc4 	addi	r16,r16,-1
811270b4:	20e6b03a 	or	r19,r4,r3
811270b8:	80800005 	stb	r2,0(r16)
811270bc:	9d86b03a 	or	r3,r19,r22
811270c0:	183ff61e 	bne	r3,zero,8112709c <__reset+0xfb10709c>
811270c4:	90c0004c 	andi	r3,r18,1
811270c8:	18013b26 	beq	r3,zero,811275b8 <___vfprintf_internal_r+0xbe4>
811270cc:	10803fcc 	andi	r2,r2,255
811270d0:	1080201c 	xori	r2,r2,128
811270d4:	10bfe004 	addi	r2,r2,-128
811270d8:	00c00c04 	movi	r3,48
811270dc:	10c13626 	beq	r2,r3,811275b8 <___vfprintf_internal_r+0xbe4>
811270e0:	80ffffc5 	stb	r3,-1(r16)
811270e4:	d8c02817 	ldw	r3,160(sp)
811270e8:	80bfffc4 	addi	r2,r16,-1
811270ec:	1021883a 	mov	r16,r2
811270f0:	1887c83a 	sub	r3,r3,r2
811270f4:	d8c02e15 	stw	r3,184(sp)
811270f8:	d8802e17 	ldw	r2,184(sp)
811270fc:	d9002917 	ldw	r4,164(sp)
81127100:	1100010e 	bge	r2,r4,81127108 <___vfprintf_internal_r+0x734>
81127104:	2005883a 	mov	r2,r4
81127108:	d8802a15 	stw	r2,168(sp)
8112710c:	d8003215 	stw	zero,200(sp)
81127110:	e7003fcc 	andi	fp,fp,255
81127114:	e700201c 	xori	fp,fp,128
81127118:	e73fe004 	addi	fp,fp,-128
8112711c:	e0000326 	beq	fp,zero,8112712c <___vfprintf_internal_r+0x758>
81127120:	d8c02a17 	ldw	r3,168(sp)
81127124:	18c00044 	addi	r3,r3,1
81127128:	d8c02a15 	stw	r3,168(sp)
8112712c:	90c0008c 	andi	r3,r18,2
81127130:	d8c02b15 	stw	r3,172(sp)
81127134:	18000326 	beq	r3,zero,81127144 <___vfprintf_internal_r+0x770>
81127138:	d8c02a17 	ldw	r3,168(sp)
8112713c:	18c00084 	addi	r3,r3,2
81127140:	d8c02a15 	stw	r3,168(sp)
81127144:	90c0210c 	andi	r3,r18,132
81127148:	d8c03015 	stw	r3,192(sp)
8112714c:	1801a31e 	bne	r3,zero,811277dc <___vfprintf_internal_r+0xe08>
81127150:	d9003117 	ldw	r4,196(sp)
81127154:	d8c02a17 	ldw	r3,168(sp)
81127158:	20e7c83a 	sub	r19,r4,r3
8112715c:	04c19f0e 	bge	zero,r19,811277dc <___vfprintf_internal_r+0xe08>
81127160:	02400404 	movi	r9,16
81127164:	d8c02017 	ldw	r3,128(sp)
81127168:	d8801f17 	ldw	r2,124(sp)
8112716c:	4cc50d0e 	bge	r9,r19,811285a4 <___vfprintf_internal_r+0x1bd0>
81127170:	01604574 	movhi	r5,33045
81127174:	29475784 	addi	r5,r5,7518
81127178:	dc403b15 	stw	r17,236(sp)
8112717c:	d9403515 	stw	r5,212(sp)
81127180:	9823883a 	mov	r17,r19
81127184:	482d883a 	mov	r22,r9
81127188:	9027883a 	mov	r19,r18
8112718c:	070001c4 	movi	fp,7
81127190:	8025883a 	mov	r18,r16
81127194:	dc002c17 	ldw	r16,176(sp)
81127198:	00000306 	br	811271a8 <___vfprintf_internal_r+0x7d4>
8112719c:	8c7ffc04 	addi	r17,r17,-16
811271a0:	42000204 	addi	r8,r8,8
811271a4:	b440130e 	bge	r22,r17,811271f4 <___vfprintf_internal_r+0x820>
811271a8:	01204574 	movhi	r4,33045
811271ac:	18c00404 	addi	r3,r3,16
811271b0:	10800044 	addi	r2,r2,1
811271b4:	21075784 	addi	r4,r4,7518
811271b8:	41000015 	stw	r4,0(r8)
811271bc:	45800115 	stw	r22,4(r8)
811271c0:	d8c02015 	stw	r3,128(sp)
811271c4:	d8801f15 	stw	r2,124(sp)
811271c8:	e0bff40e 	bge	fp,r2,8112719c <__reset+0xfb10719c>
811271cc:	d9801e04 	addi	r6,sp,120
811271d0:	b80b883a 	mov	r5,r23
811271d4:	8009883a 	mov	r4,r16
811271d8:	1132bc40 	call	81132bc4 <__sprint_r>
811271dc:	103f011e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
811271e0:	8c7ffc04 	addi	r17,r17,-16
811271e4:	d8c02017 	ldw	r3,128(sp)
811271e8:	d8801f17 	ldw	r2,124(sp)
811271ec:	da000404 	addi	r8,sp,16
811271f0:	b47fed16 	blt	r22,r17,811271a8 <__reset+0xfb1071a8>
811271f4:	9021883a 	mov	r16,r18
811271f8:	9825883a 	mov	r18,r19
811271fc:	8827883a 	mov	r19,r17
81127200:	dc403b17 	ldw	r17,236(sp)
81127204:	d9403517 	ldw	r5,212(sp)
81127208:	98c7883a 	add	r3,r19,r3
8112720c:	10800044 	addi	r2,r2,1
81127210:	41400015 	stw	r5,0(r8)
81127214:	44c00115 	stw	r19,4(r8)
81127218:	d8c02015 	stw	r3,128(sp)
8112721c:	d8801f15 	stw	r2,124(sp)
81127220:	010001c4 	movi	r4,7
81127224:	2082a316 	blt	r4,r2,81127cb4 <___vfprintf_internal_r+0x12e0>
81127228:	df002787 	ldb	fp,158(sp)
8112722c:	42000204 	addi	r8,r8,8
81127230:	e0000c26 	beq	fp,zero,81127264 <___vfprintf_internal_r+0x890>
81127234:	d8801f17 	ldw	r2,124(sp)
81127238:	d9002784 	addi	r4,sp,158
8112723c:	18c00044 	addi	r3,r3,1
81127240:	10800044 	addi	r2,r2,1
81127244:	41000015 	stw	r4,0(r8)
81127248:	01000044 	movi	r4,1
8112724c:	41000115 	stw	r4,4(r8)
81127250:	d8c02015 	stw	r3,128(sp)
81127254:	d8801f15 	stw	r2,124(sp)
81127258:	010001c4 	movi	r4,7
8112725c:	20823c16 	blt	r4,r2,81127b50 <___vfprintf_internal_r+0x117c>
81127260:	42000204 	addi	r8,r8,8
81127264:	d8802b17 	ldw	r2,172(sp)
81127268:	10000c26 	beq	r2,zero,8112729c <___vfprintf_internal_r+0x8c8>
8112726c:	d8801f17 	ldw	r2,124(sp)
81127270:	d9002704 	addi	r4,sp,156
81127274:	18c00084 	addi	r3,r3,2
81127278:	10800044 	addi	r2,r2,1
8112727c:	41000015 	stw	r4,0(r8)
81127280:	01000084 	movi	r4,2
81127284:	41000115 	stw	r4,4(r8)
81127288:	d8c02015 	stw	r3,128(sp)
8112728c:	d8801f15 	stw	r2,124(sp)
81127290:	010001c4 	movi	r4,7
81127294:	20823616 	blt	r4,r2,81127b70 <___vfprintf_internal_r+0x119c>
81127298:	42000204 	addi	r8,r8,8
8112729c:	d9003017 	ldw	r4,192(sp)
811272a0:	00802004 	movi	r2,128
811272a4:	20819926 	beq	r4,r2,8112790c <___vfprintf_internal_r+0xf38>
811272a8:	d9402917 	ldw	r5,164(sp)
811272ac:	d8802e17 	ldw	r2,184(sp)
811272b0:	28adc83a 	sub	r22,r5,r2
811272b4:	0580310e 	bge	zero,r22,8112737c <___vfprintf_internal_r+0x9a8>
811272b8:	07000404 	movi	fp,16
811272bc:	d8801f17 	ldw	r2,124(sp)
811272c0:	e584140e 	bge	fp,r22,81128314 <___vfprintf_internal_r+0x1940>
811272c4:	01604574 	movhi	r5,33045
811272c8:	29475384 	addi	r5,r5,7502
811272cc:	dc402915 	stw	r17,164(sp)
811272d0:	d9402b15 	stw	r5,172(sp)
811272d4:	b023883a 	mov	r17,r22
811272d8:	04c001c4 	movi	r19,7
811272dc:	a82d883a 	mov	r22,r21
811272e0:	902b883a 	mov	r21,r18
811272e4:	8025883a 	mov	r18,r16
811272e8:	dc002c17 	ldw	r16,176(sp)
811272ec:	00000306 	br	811272fc <___vfprintf_internal_r+0x928>
811272f0:	8c7ffc04 	addi	r17,r17,-16
811272f4:	42000204 	addi	r8,r8,8
811272f8:	e440110e 	bge	fp,r17,81127340 <___vfprintf_internal_r+0x96c>
811272fc:	18c00404 	addi	r3,r3,16
81127300:	10800044 	addi	r2,r2,1
81127304:	45000015 	stw	r20,0(r8)
81127308:	47000115 	stw	fp,4(r8)
8112730c:	d8c02015 	stw	r3,128(sp)
81127310:	d8801f15 	stw	r2,124(sp)
81127314:	98bff60e 	bge	r19,r2,811272f0 <__reset+0xfb1072f0>
81127318:	d9801e04 	addi	r6,sp,120
8112731c:	b80b883a 	mov	r5,r23
81127320:	8009883a 	mov	r4,r16
81127324:	1132bc40 	call	81132bc4 <__sprint_r>
81127328:	103eae1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
8112732c:	8c7ffc04 	addi	r17,r17,-16
81127330:	d8c02017 	ldw	r3,128(sp)
81127334:	d8801f17 	ldw	r2,124(sp)
81127338:	da000404 	addi	r8,sp,16
8112733c:	e47fef16 	blt	fp,r17,811272fc <__reset+0xfb1072fc>
81127340:	9021883a 	mov	r16,r18
81127344:	a825883a 	mov	r18,r21
81127348:	b02b883a 	mov	r21,r22
8112734c:	882d883a 	mov	r22,r17
81127350:	dc402917 	ldw	r17,164(sp)
81127354:	d9002b17 	ldw	r4,172(sp)
81127358:	1d87883a 	add	r3,r3,r22
8112735c:	10800044 	addi	r2,r2,1
81127360:	41000015 	stw	r4,0(r8)
81127364:	45800115 	stw	r22,4(r8)
81127368:	d8c02015 	stw	r3,128(sp)
8112736c:	d8801f15 	stw	r2,124(sp)
81127370:	010001c4 	movi	r4,7
81127374:	2081ee16 	blt	r4,r2,81127b30 <___vfprintf_internal_r+0x115c>
81127378:	42000204 	addi	r8,r8,8
8112737c:	9080400c 	andi	r2,r18,256
81127380:	1001181e 	bne	r2,zero,811277e4 <___vfprintf_internal_r+0xe10>
81127384:	d9402e17 	ldw	r5,184(sp)
81127388:	d8801f17 	ldw	r2,124(sp)
8112738c:	44000015 	stw	r16,0(r8)
81127390:	1947883a 	add	r3,r3,r5
81127394:	10800044 	addi	r2,r2,1
81127398:	41400115 	stw	r5,4(r8)
8112739c:	d8c02015 	stw	r3,128(sp)
811273a0:	d8801f15 	stw	r2,124(sp)
811273a4:	010001c4 	movi	r4,7
811273a8:	2081d316 	blt	r4,r2,81127af8 <___vfprintf_internal_r+0x1124>
811273ac:	42000204 	addi	r8,r8,8
811273b0:	9480010c 	andi	r18,r18,4
811273b4:	90003226 	beq	r18,zero,81127480 <___vfprintf_internal_r+0xaac>
811273b8:	d9403117 	ldw	r5,196(sp)
811273bc:	d8802a17 	ldw	r2,168(sp)
811273c0:	28a1c83a 	sub	r16,r5,r2
811273c4:	04002e0e 	bge	zero,r16,81127480 <___vfprintf_internal_r+0xaac>
811273c8:	04400404 	movi	r17,16
811273cc:	d8801f17 	ldw	r2,124(sp)
811273d0:	8c04a20e 	bge	r17,r16,8112865c <___vfprintf_internal_r+0x1c88>
811273d4:	01604574 	movhi	r5,33045
811273d8:	29475784 	addi	r5,r5,7518
811273dc:	d9403515 	stw	r5,212(sp)
811273e0:	048001c4 	movi	r18,7
811273e4:	dcc02c17 	ldw	r19,176(sp)
811273e8:	00000306 	br	811273f8 <___vfprintf_internal_r+0xa24>
811273ec:	843ffc04 	addi	r16,r16,-16
811273f0:	42000204 	addi	r8,r8,8
811273f4:	8c00130e 	bge	r17,r16,81127444 <___vfprintf_internal_r+0xa70>
811273f8:	01204574 	movhi	r4,33045
811273fc:	18c00404 	addi	r3,r3,16
81127400:	10800044 	addi	r2,r2,1
81127404:	21075784 	addi	r4,r4,7518
81127408:	41000015 	stw	r4,0(r8)
8112740c:	44400115 	stw	r17,4(r8)
81127410:	d8c02015 	stw	r3,128(sp)
81127414:	d8801f15 	stw	r2,124(sp)
81127418:	90bff40e 	bge	r18,r2,811273ec <__reset+0xfb1073ec>
8112741c:	d9801e04 	addi	r6,sp,120
81127420:	b80b883a 	mov	r5,r23
81127424:	9809883a 	mov	r4,r19
81127428:	1132bc40 	call	81132bc4 <__sprint_r>
8112742c:	103e6d1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127430:	843ffc04 	addi	r16,r16,-16
81127434:	d8c02017 	ldw	r3,128(sp)
81127438:	d8801f17 	ldw	r2,124(sp)
8112743c:	da000404 	addi	r8,sp,16
81127440:	8c3fed16 	blt	r17,r16,811273f8 <__reset+0xfb1073f8>
81127444:	d9403517 	ldw	r5,212(sp)
81127448:	1c07883a 	add	r3,r3,r16
8112744c:	10800044 	addi	r2,r2,1
81127450:	41400015 	stw	r5,0(r8)
81127454:	44000115 	stw	r16,4(r8)
81127458:	d8c02015 	stw	r3,128(sp)
8112745c:	d8801f15 	stw	r2,124(sp)
81127460:	010001c4 	movi	r4,7
81127464:	2080060e 	bge	r4,r2,81127480 <___vfprintf_internal_r+0xaac>
81127468:	d9002c17 	ldw	r4,176(sp)
8112746c:	d9801e04 	addi	r6,sp,120
81127470:	b80b883a 	mov	r5,r23
81127474:	1132bc40 	call	81132bc4 <__sprint_r>
81127478:	103e5a1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
8112747c:	d8c02017 	ldw	r3,128(sp)
81127480:	d8803117 	ldw	r2,196(sp)
81127484:	d9002a17 	ldw	r4,168(sp)
81127488:	1100010e 	bge	r2,r4,81127490 <___vfprintf_internal_r+0xabc>
8112748c:	2005883a 	mov	r2,r4
81127490:	d9402f17 	ldw	r5,188(sp)
81127494:	288b883a 	add	r5,r5,r2
81127498:	d9402f15 	stw	r5,188(sp)
8112749c:	18019e1e 	bne	r3,zero,81127b18 <___vfprintf_internal_r+0x1144>
811274a0:	a8800007 	ldb	r2,0(r21)
811274a4:	d8001f15 	stw	zero,124(sp)
811274a8:	da000404 	addi	r8,sp,16
811274ac:	103d851e 	bne	r2,zero,81126ac4 <__reset+0xfb106ac4>
811274b0:	a821883a 	mov	r16,r21
811274b4:	003d9b06 	br	81126b24 <__reset+0xfb106b24>
811274b8:	18c03fcc 	andi	r3,r3,255
811274bc:	1805c11e 	bne	r3,zero,81128bc4 <___vfprintf_internal_r+0x21f0>
811274c0:	94800414 	ori	r18,r18,16
811274c4:	9080080c 	andi	r2,r18,32
811274c8:	10020c26 	beq	r2,zero,81127cfc <___vfprintf_internal_r+0x1328>
811274cc:	d8802d17 	ldw	r2,180(sp)
811274d0:	d9002917 	ldw	r4,164(sp)
811274d4:	d8002785 	stb	zero,158(sp)
811274d8:	10c00204 	addi	r3,r2,8
811274dc:	14c00017 	ldw	r19,0(r2)
811274e0:	15800117 	ldw	r22,4(r2)
811274e4:	20040f16 	blt	r4,zero,81128524 <___vfprintf_internal_r+0x1b50>
811274e8:	013fdfc4 	movi	r4,-129
811274ec:	9d84b03a 	or	r2,r19,r22
811274f0:	d8c02d15 	stw	r3,180(sp)
811274f4:	9124703a 	and	r18,r18,r4
811274f8:	0039883a 	mov	fp,zero
811274fc:	103e891e 	bne	r2,zero,81126f24 <__reset+0xfb106f24>
81127500:	d9002917 	ldw	r4,164(sp)
81127504:	2002c11e 	bne	r4,zero,8112800c <___vfprintf_internal_r+0x1638>
81127508:	d8002915 	stw	zero,164(sp)
8112750c:	d8002e15 	stw	zero,184(sp)
81127510:	dc001e04 	addi	r16,sp,120
81127514:	003ef806 	br	811270f8 <__reset+0xfb1070f8>
81127518:	18c03fcc 	andi	r3,r3,255
8112751c:	18059d1e 	bne	r3,zero,81128b94 <___vfprintf_internal_r+0x21c0>
81127520:	01604574 	movhi	r5,33045
81127524:	29473f04 	addi	r5,r5,7420
81127528:	d9403915 	stw	r5,228(sp)
8112752c:	9080080c 	andi	r2,r18,32
81127530:	10005226 	beq	r2,zero,8112767c <___vfprintf_internal_r+0xca8>
81127534:	d8802d17 	ldw	r2,180(sp)
81127538:	14c00017 	ldw	r19,0(r2)
8112753c:	15800117 	ldw	r22,4(r2)
81127540:	10800204 	addi	r2,r2,8
81127544:	d8802d15 	stw	r2,180(sp)
81127548:	9080004c 	andi	r2,r18,1
8112754c:	10019026 	beq	r2,zero,81127b90 <___vfprintf_internal_r+0x11bc>
81127550:	9d84b03a 	or	r2,r19,r22
81127554:	10036926 	beq	r2,zero,811282fc <___vfprintf_internal_r+0x1928>
81127558:	d8c02917 	ldw	r3,164(sp)
8112755c:	00800c04 	movi	r2,48
81127560:	d8802705 	stb	r2,156(sp)
81127564:	dc402745 	stb	r17,157(sp)
81127568:	d8002785 	stb	zero,158(sp)
8112756c:	90800094 	ori	r2,r18,2
81127570:	18045d16 	blt	r3,zero,811286e8 <___vfprintf_internal_r+0x1d14>
81127574:	00bfdfc4 	movi	r2,-129
81127578:	90a4703a 	and	r18,r18,r2
8112757c:	94800094 	ori	r18,r18,2
81127580:	0039883a 	mov	fp,zero
81127584:	d9003917 	ldw	r4,228(sp)
81127588:	dc001e04 	addi	r16,sp,120
8112758c:	988003cc 	andi	r2,r19,15
81127590:	b006973a 	slli	r3,r22,28
81127594:	2085883a 	add	r2,r4,r2
81127598:	9826d13a 	srli	r19,r19,4
8112759c:	10800003 	ldbu	r2,0(r2)
811275a0:	b02cd13a 	srli	r22,r22,4
811275a4:	843fffc4 	addi	r16,r16,-1
811275a8:	1ce6b03a 	or	r19,r3,r19
811275ac:	80800005 	stb	r2,0(r16)
811275b0:	9d84b03a 	or	r2,r19,r22
811275b4:	103ff51e 	bne	r2,zero,8112758c <__reset+0xfb10758c>
811275b8:	d8c02817 	ldw	r3,160(sp)
811275bc:	1c07c83a 	sub	r3,r3,r16
811275c0:	d8c02e15 	stw	r3,184(sp)
811275c4:	003ecc06 	br	811270f8 <__reset+0xfb1070f8>
811275c8:	18c03fcc 	andi	r3,r3,255
811275cc:	183e9f26 	beq	r3,zero,8112704c <__reset+0xfb10704c>
811275d0:	d9c02785 	stb	r7,158(sp)
811275d4:	003e9d06 	br	8112704c <__reset+0xfb10704c>
811275d8:	00c00044 	movi	r3,1
811275dc:	01c00ac4 	movi	r7,43
811275e0:	ac400007 	ldb	r17,0(r21)
811275e4:	003d5e06 	br	81126b60 <__reset+0xfb106b60>
811275e8:	94800814 	ori	r18,r18,32
811275ec:	ac400007 	ldb	r17,0(r21)
811275f0:	003d5b06 	br	81126b60 <__reset+0xfb106b60>
811275f4:	d8c02d17 	ldw	r3,180(sp)
811275f8:	d8002785 	stb	zero,158(sp)
811275fc:	1c000017 	ldw	r16,0(r3)
81127600:	1cc00104 	addi	r19,r3,4
81127604:	80041926 	beq	r16,zero,8112866c <___vfprintf_internal_r+0x1c98>
81127608:	d9002917 	ldw	r4,164(sp)
8112760c:	2003d016 	blt	r4,zero,81128550 <___vfprintf_internal_r+0x1b7c>
81127610:	200d883a 	mov	r6,r4
81127614:	000b883a 	mov	r5,zero
81127618:	8009883a 	mov	r4,r16
8112761c:	da003d15 	stw	r8,244(sp)
81127620:	112d9b80 	call	8112d9b8 <memchr>
81127624:	da003d17 	ldw	r8,244(sp)
81127628:	10045426 	beq	r2,zero,8112877c <___vfprintf_internal_r+0x1da8>
8112762c:	1405c83a 	sub	r2,r2,r16
81127630:	d8802e15 	stw	r2,184(sp)
81127634:	1003cc16 	blt	r2,zero,81128568 <___vfprintf_internal_r+0x1b94>
81127638:	df002783 	ldbu	fp,158(sp)
8112763c:	d8802a15 	stw	r2,168(sp)
81127640:	dcc02d15 	stw	r19,180(sp)
81127644:	d8002915 	stw	zero,164(sp)
81127648:	d8003215 	stw	zero,200(sp)
8112764c:	003eb006 	br	81127110 <__reset+0xfb107110>
81127650:	18c03fcc 	andi	r3,r3,255
81127654:	183f9b26 	beq	r3,zero,811274c4 <__reset+0xfb1074c4>
81127658:	d9c02785 	stb	r7,158(sp)
8112765c:	003f9906 	br	811274c4 <__reset+0xfb1074c4>
81127660:	18c03fcc 	andi	r3,r3,255
81127664:	1805551e 	bne	r3,zero,81128bbc <___vfprintf_internal_r+0x21e8>
81127668:	01604574 	movhi	r5,33045
8112766c:	29474404 	addi	r5,r5,7440
81127670:	d9403915 	stw	r5,228(sp)
81127674:	9080080c 	andi	r2,r18,32
81127678:	103fae1e 	bne	r2,zero,81127534 <__reset+0xfb107534>
8112767c:	9080040c 	andi	r2,r18,16
81127680:	1002de26 	beq	r2,zero,811281fc <___vfprintf_internal_r+0x1828>
81127684:	d8c02d17 	ldw	r3,180(sp)
81127688:	002d883a 	mov	r22,zero
8112768c:	1cc00017 	ldw	r19,0(r3)
81127690:	18c00104 	addi	r3,r3,4
81127694:	d8c02d15 	stw	r3,180(sp)
81127698:	003fab06 	br	81127548 <__reset+0xfb107548>
8112769c:	38803fcc 	andi	r2,r7,255
811276a0:	1080201c 	xori	r2,r2,128
811276a4:	10bfe004 	addi	r2,r2,-128
811276a8:	1002d21e 	bne	r2,zero,811281f4 <___vfprintf_internal_r+0x1820>
811276ac:	00c00044 	movi	r3,1
811276b0:	01c00804 	movi	r7,32
811276b4:	ac400007 	ldb	r17,0(r21)
811276b8:	003d2906 	br	81126b60 <__reset+0xfb106b60>
811276bc:	94800054 	ori	r18,r18,1
811276c0:	ac400007 	ldb	r17,0(r21)
811276c4:	003d2606 	br	81126b60 <__reset+0xfb106b60>
811276c8:	18c03fcc 	andi	r3,r3,255
811276cc:	183e0526 	beq	r3,zero,81126ee4 <__reset+0xfb106ee4>
811276d0:	d9c02785 	stb	r7,158(sp)
811276d4:	003e0306 	br	81126ee4 <__reset+0xfb106ee4>
811276d8:	94801014 	ori	r18,r18,64
811276dc:	ac400007 	ldb	r17,0(r21)
811276e0:	003d1f06 	br	81126b60 <__reset+0xfb106b60>
811276e4:	ac400007 	ldb	r17,0(r21)
811276e8:	8a438726 	beq	r17,r9,81128508 <___vfprintf_internal_r+0x1b34>
811276ec:	94800414 	ori	r18,r18,16
811276f0:	003d1b06 	br	81126b60 <__reset+0xfb106b60>
811276f4:	18c03fcc 	andi	r3,r3,255
811276f8:	1805341e 	bne	r3,zero,81128bcc <___vfprintf_internal_r+0x21f8>
811276fc:	9080080c 	andi	r2,r18,32
81127700:	1002cd26 	beq	r2,zero,81128238 <___vfprintf_internal_r+0x1864>
81127704:	d9402d17 	ldw	r5,180(sp)
81127708:	d9002f17 	ldw	r4,188(sp)
8112770c:	28800017 	ldw	r2,0(r5)
81127710:	2007d7fa 	srai	r3,r4,31
81127714:	29400104 	addi	r5,r5,4
81127718:	d9402d15 	stw	r5,180(sp)
8112771c:	11000015 	stw	r4,0(r2)
81127720:	10c00115 	stw	r3,4(r2)
81127724:	003ce506 	br	81126abc <__reset+0xfb106abc>
81127728:	d8c02d17 	ldw	r3,180(sp)
8112772c:	d9002d17 	ldw	r4,180(sp)
81127730:	d8002785 	stb	zero,158(sp)
81127734:	18800017 	ldw	r2,0(r3)
81127738:	21000104 	addi	r4,r4,4
8112773c:	00c00044 	movi	r3,1
81127740:	d8c02a15 	stw	r3,168(sp)
81127744:	d8801405 	stb	r2,80(sp)
81127748:	d9002d15 	stw	r4,180(sp)
8112774c:	d8c02e15 	stw	r3,184(sp)
81127750:	d8002915 	stw	zero,164(sp)
81127754:	d8003215 	stw	zero,200(sp)
81127758:	dc001404 	addi	r16,sp,80
8112775c:	0039883a 	mov	fp,zero
81127760:	003e7206 	br	8112712c <__reset+0xfb10712c>
81127764:	01204574 	movhi	r4,33045
81127768:	21074404 	addi	r4,r4,7440
8112776c:	0039883a 	mov	fp,zero
81127770:	d9003915 	stw	r4,228(sp)
81127774:	04401e04 	movi	r17,120
81127778:	003f8206 	br	81127584 <__reset+0xfb107584>
8112777c:	18c03fcc 	andi	r3,r3,255
81127780:	1805061e 	bne	r3,zero,81128b9c <___vfprintf_internal_r+0x21c8>
81127784:	883d9126 	beq	r17,zero,81126dcc <__reset+0xfb106dcc>
81127788:	00c00044 	movi	r3,1
8112778c:	d8c02a15 	stw	r3,168(sp)
81127790:	dc401405 	stb	r17,80(sp)
81127794:	d8002785 	stb	zero,158(sp)
81127798:	003fec06 	br	8112774c <__reset+0xfb10774c>
8112779c:	01604574 	movhi	r5,33045
811277a0:	29474404 	addi	r5,r5,7440
811277a4:	d9403915 	stw	r5,228(sp)
811277a8:	d8c02d15 	stw	r3,180(sp)
811277ac:	1025883a 	mov	r18,r2
811277b0:	04401e04 	movi	r17,120
811277b4:	9d84b03a 	or	r2,r19,r22
811277b8:	1000fc1e 	bne	r2,zero,81127bac <___vfprintf_internal_r+0x11d8>
811277bc:	0039883a 	mov	fp,zero
811277c0:	00800084 	movi	r2,2
811277c4:	10803fcc 	andi	r2,r2,255
811277c8:	00c00044 	movi	r3,1
811277cc:	10c20f26 	beq	r2,r3,8112800c <___vfprintf_internal_r+0x1638>
811277d0:	00c00084 	movi	r3,2
811277d4:	10fd6326 	beq	r2,r3,81126d64 <__reset+0xfb106d64>
811277d8:	003e2d06 	br	81127090 <__reset+0xfb107090>
811277dc:	d8c02017 	ldw	r3,128(sp)
811277e0:	003e9306 	br	81127230 <__reset+0xfb107230>
811277e4:	00801944 	movi	r2,101
811277e8:	14407e0e 	bge	r2,r17,811279e4 <___vfprintf_internal_r+0x1010>
811277ec:	d9003617 	ldw	r4,216(sp)
811277f0:	d9403817 	ldw	r5,224(sp)
811277f4:	000d883a 	mov	r6,zero
811277f8:	000f883a 	mov	r7,zero
811277fc:	d8c03c15 	stw	r3,240(sp)
81127800:	da003d15 	stw	r8,244(sp)
81127804:	11373900 	call	81137390 <__eqdf2>
81127808:	d8c03c17 	ldw	r3,240(sp)
8112780c:	da003d17 	ldw	r8,244(sp)
81127810:	1000f71e 	bne	r2,zero,81127bf0 <___vfprintf_internal_r+0x121c>
81127814:	d8801f17 	ldw	r2,124(sp)
81127818:	01204574 	movhi	r4,33045
8112781c:	21074b04 	addi	r4,r4,7468
81127820:	18c00044 	addi	r3,r3,1
81127824:	10800044 	addi	r2,r2,1
81127828:	41000015 	stw	r4,0(r8)
8112782c:	01000044 	movi	r4,1
81127830:	41000115 	stw	r4,4(r8)
81127834:	d8c02015 	stw	r3,128(sp)
81127838:	d8801f15 	stw	r2,124(sp)
8112783c:	010001c4 	movi	r4,7
81127840:	2082b816 	blt	r4,r2,81128324 <___vfprintf_internal_r+0x1950>
81127844:	42000204 	addi	r8,r8,8
81127848:	d8802617 	ldw	r2,152(sp)
8112784c:	d9403317 	ldw	r5,204(sp)
81127850:	11400216 	blt	r2,r5,8112785c <___vfprintf_internal_r+0xe88>
81127854:	9080004c 	andi	r2,r18,1
81127858:	103ed526 	beq	r2,zero,811273b0 <__reset+0xfb1073b0>
8112785c:	d8803717 	ldw	r2,220(sp)
81127860:	d9003417 	ldw	r4,208(sp)
81127864:	d9403717 	ldw	r5,220(sp)
81127868:	1887883a 	add	r3,r3,r2
8112786c:	d8801f17 	ldw	r2,124(sp)
81127870:	41000015 	stw	r4,0(r8)
81127874:	41400115 	stw	r5,4(r8)
81127878:	10800044 	addi	r2,r2,1
8112787c:	d8c02015 	stw	r3,128(sp)
81127880:	d8801f15 	stw	r2,124(sp)
81127884:	010001c4 	movi	r4,7
81127888:	20832916 	blt	r4,r2,81128530 <___vfprintf_internal_r+0x1b5c>
8112788c:	42000204 	addi	r8,r8,8
81127890:	d8803317 	ldw	r2,204(sp)
81127894:	143fffc4 	addi	r16,r2,-1
81127898:	043ec50e 	bge	zero,r16,811273b0 <__reset+0xfb1073b0>
8112789c:	04400404 	movi	r17,16
811278a0:	d8801f17 	ldw	r2,124(sp)
811278a4:	8c00880e 	bge	r17,r16,81127ac8 <___vfprintf_internal_r+0x10f4>
811278a8:	01604574 	movhi	r5,33045
811278ac:	29475384 	addi	r5,r5,7502
811278b0:	d9402b15 	stw	r5,172(sp)
811278b4:	058001c4 	movi	r22,7
811278b8:	dcc02c17 	ldw	r19,176(sp)
811278bc:	00000306 	br	811278cc <___vfprintf_internal_r+0xef8>
811278c0:	42000204 	addi	r8,r8,8
811278c4:	843ffc04 	addi	r16,r16,-16
811278c8:	8c00820e 	bge	r17,r16,81127ad4 <___vfprintf_internal_r+0x1100>
811278cc:	18c00404 	addi	r3,r3,16
811278d0:	10800044 	addi	r2,r2,1
811278d4:	45000015 	stw	r20,0(r8)
811278d8:	44400115 	stw	r17,4(r8)
811278dc:	d8c02015 	stw	r3,128(sp)
811278e0:	d8801f15 	stw	r2,124(sp)
811278e4:	b0bff60e 	bge	r22,r2,811278c0 <__reset+0xfb1078c0>
811278e8:	d9801e04 	addi	r6,sp,120
811278ec:	b80b883a 	mov	r5,r23
811278f0:	9809883a 	mov	r4,r19
811278f4:	1132bc40 	call	81132bc4 <__sprint_r>
811278f8:	103d3a1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
811278fc:	d8c02017 	ldw	r3,128(sp)
81127900:	d8801f17 	ldw	r2,124(sp)
81127904:	da000404 	addi	r8,sp,16
81127908:	003fee06 	br	811278c4 <__reset+0xfb1078c4>
8112790c:	d9403117 	ldw	r5,196(sp)
81127910:	d8802a17 	ldw	r2,168(sp)
81127914:	28adc83a 	sub	r22,r5,r2
81127918:	05be630e 	bge	zero,r22,811272a8 <__reset+0xfb1072a8>
8112791c:	07000404 	movi	fp,16
81127920:	d8801f17 	ldw	r2,124(sp)
81127924:	e5838f0e 	bge	fp,r22,81128764 <___vfprintf_internal_r+0x1d90>
81127928:	01604574 	movhi	r5,33045
8112792c:	29475384 	addi	r5,r5,7502
81127930:	dc403015 	stw	r17,192(sp)
81127934:	d9402b15 	stw	r5,172(sp)
81127938:	b023883a 	mov	r17,r22
8112793c:	04c001c4 	movi	r19,7
81127940:	a82d883a 	mov	r22,r21
81127944:	902b883a 	mov	r21,r18
81127948:	8025883a 	mov	r18,r16
8112794c:	dc002c17 	ldw	r16,176(sp)
81127950:	00000306 	br	81127960 <___vfprintf_internal_r+0xf8c>
81127954:	8c7ffc04 	addi	r17,r17,-16
81127958:	42000204 	addi	r8,r8,8
8112795c:	e440110e 	bge	fp,r17,811279a4 <___vfprintf_internal_r+0xfd0>
81127960:	18c00404 	addi	r3,r3,16
81127964:	10800044 	addi	r2,r2,1
81127968:	45000015 	stw	r20,0(r8)
8112796c:	47000115 	stw	fp,4(r8)
81127970:	d8c02015 	stw	r3,128(sp)
81127974:	d8801f15 	stw	r2,124(sp)
81127978:	98bff60e 	bge	r19,r2,81127954 <__reset+0xfb107954>
8112797c:	d9801e04 	addi	r6,sp,120
81127980:	b80b883a 	mov	r5,r23
81127984:	8009883a 	mov	r4,r16
81127988:	1132bc40 	call	81132bc4 <__sprint_r>
8112798c:	103d151e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127990:	8c7ffc04 	addi	r17,r17,-16
81127994:	d8c02017 	ldw	r3,128(sp)
81127998:	d8801f17 	ldw	r2,124(sp)
8112799c:	da000404 	addi	r8,sp,16
811279a0:	e47fef16 	blt	fp,r17,81127960 <__reset+0xfb107960>
811279a4:	9021883a 	mov	r16,r18
811279a8:	a825883a 	mov	r18,r21
811279ac:	b02b883a 	mov	r21,r22
811279b0:	882d883a 	mov	r22,r17
811279b4:	dc403017 	ldw	r17,192(sp)
811279b8:	d9002b17 	ldw	r4,172(sp)
811279bc:	1d87883a 	add	r3,r3,r22
811279c0:	10800044 	addi	r2,r2,1
811279c4:	41000015 	stw	r4,0(r8)
811279c8:	45800115 	stw	r22,4(r8)
811279cc:	d8c02015 	stw	r3,128(sp)
811279d0:	d8801f15 	stw	r2,124(sp)
811279d4:	010001c4 	movi	r4,7
811279d8:	20818e16 	blt	r4,r2,81128014 <___vfprintf_internal_r+0x1640>
811279dc:	42000204 	addi	r8,r8,8
811279e0:	003e3106 	br	811272a8 <__reset+0xfb1072a8>
811279e4:	d9403317 	ldw	r5,204(sp)
811279e8:	00800044 	movi	r2,1
811279ec:	18c00044 	addi	r3,r3,1
811279f0:	1141530e 	bge	r2,r5,81127f40 <___vfprintf_internal_r+0x156c>
811279f4:	dc401f17 	ldw	r17,124(sp)
811279f8:	00800044 	movi	r2,1
811279fc:	40800115 	stw	r2,4(r8)
81127a00:	8c400044 	addi	r17,r17,1
81127a04:	44000015 	stw	r16,0(r8)
81127a08:	d8c02015 	stw	r3,128(sp)
81127a0c:	dc401f15 	stw	r17,124(sp)
81127a10:	008001c4 	movi	r2,7
81127a14:	14416b16 	blt	r2,r17,81127fc4 <___vfprintf_internal_r+0x15f0>
81127a18:	42000204 	addi	r8,r8,8
81127a1c:	d8803717 	ldw	r2,220(sp)
81127a20:	d9003417 	ldw	r4,208(sp)
81127a24:	8c400044 	addi	r17,r17,1
81127a28:	10c7883a 	add	r3,r2,r3
81127a2c:	40800115 	stw	r2,4(r8)
81127a30:	41000015 	stw	r4,0(r8)
81127a34:	d8c02015 	stw	r3,128(sp)
81127a38:	dc401f15 	stw	r17,124(sp)
81127a3c:	008001c4 	movi	r2,7
81127a40:	14416916 	blt	r2,r17,81127fe8 <___vfprintf_internal_r+0x1614>
81127a44:	45800204 	addi	r22,r8,8
81127a48:	d9003617 	ldw	r4,216(sp)
81127a4c:	d9403817 	ldw	r5,224(sp)
81127a50:	000d883a 	mov	r6,zero
81127a54:	000f883a 	mov	r7,zero
81127a58:	d8c03c15 	stw	r3,240(sp)
81127a5c:	11373900 	call	81137390 <__eqdf2>
81127a60:	d8c03c17 	ldw	r3,240(sp)
81127a64:	1000bc26 	beq	r2,zero,81127d58 <___vfprintf_internal_r+0x1384>
81127a68:	d9403317 	ldw	r5,204(sp)
81127a6c:	84000044 	addi	r16,r16,1
81127a70:	8c400044 	addi	r17,r17,1
81127a74:	28bfffc4 	addi	r2,r5,-1
81127a78:	1887883a 	add	r3,r3,r2
81127a7c:	b0800115 	stw	r2,4(r22)
81127a80:	b4000015 	stw	r16,0(r22)
81127a84:	d8c02015 	stw	r3,128(sp)
81127a88:	dc401f15 	stw	r17,124(sp)
81127a8c:	008001c4 	movi	r2,7
81127a90:	14414316 	blt	r2,r17,81127fa0 <___vfprintf_internal_r+0x15cc>
81127a94:	b5800204 	addi	r22,r22,8
81127a98:	d9003a17 	ldw	r4,232(sp)
81127a9c:	df0022c4 	addi	fp,sp,139
81127aa0:	8c400044 	addi	r17,r17,1
81127aa4:	20c7883a 	add	r3,r4,r3
81127aa8:	b7000015 	stw	fp,0(r22)
81127aac:	b1000115 	stw	r4,4(r22)
81127ab0:	d8c02015 	stw	r3,128(sp)
81127ab4:	dc401f15 	stw	r17,124(sp)
81127ab8:	008001c4 	movi	r2,7
81127abc:	14400e16 	blt	r2,r17,81127af8 <___vfprintf_internal_r+0x1124>
81127ac0:	b2000204 	addi	r8,r22,8
81127ac4:	003e3a06 	br	811273b0 <__reset+0xfb1073b0>
81127ac8:	01204574 	movhi	r4,33045
81127acc:	21075384 	addi	r4,r4,7502
81127ad0:	d9002b15 	stw	r4,172(sp)
81127ad4:	d9002b17 	ldw	r4,172(sp)
81127ad8:	1c07883a 	add	r3,r3,r16
81127adc:	44000115 	stw	r16,4(r8)
81127ae0:	41000015 	stw	r4,0(r8)
81127ae4:	10800044 	addi	r2,r2,1
81127ae8:	d8c02015 	stw	r3,128(sp)
81127aec:	d8801f15 	stw	r2,124(sp)
81127af0:	010001c4 	movi	r4,7
81127af4:	20be2d0e 	bge	r4,r2,811273ac <__reset+0xfb1073ac>
81127af8:	d9002c17 	ldw	r4,176(sp)
81127afc:	d9801e04 	addi	r6,sp,120
81127b00:	b80b883a 	mov	r5,r23
81127b04:	1132bc40 	call	81132bc4 <__sprint_r>
81127b08:	103cb61e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127b0c:	d8c02017 	ldw	r3,128(sp)
81127b10:	da000404 	addi	r8,sp,16
81127b14:	003e2606 	br	811273b0 <__reset+0xfb1073b0>
81127b18:	d9002c17 	ldw	r4,176(sp)
81127b1c:	d9801e04 	addi	r6,sp,120
81127b20:	b80b883a 	mov	r5,r23
81127b24:	1132bc40 	call	81132bc4 <__sprint_r>
81127b28:	103e5d26 	beq	r2,zero,811274a0 <__reset+0xfb1074a0>
81127b2c:	003cad06 	br	81126de4 <__reset+0xfb106de4>
81127b30:	d9002c17 	ldw	r4,176(sp)
81127b34:	d9801e04 	addi	r6,sp,120
81127b38:	b80b883a 	mov	r5,r23
81127b3c:	1132bc40 	call	81132bc4 <__sprint_r>
81127b40:	103ca81e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127b44:	d8c02017 	ldw	r3,128(sp)
81127b48:	da000404 	addi	r8,sp,16
81127b4c:	003e0b06 	br	8112737c <__reset+0xfb10737c>
81127b50:	d9002c17 	ldw	r4,176(sp)
81127b54:	d9801e04 	addi	r6,sp,120
81127b58:	b80b883a 	mov	r5,r23
81127b5c:	1132bc40 	call	81132bc4 <__sprint_r>
81127b60:	103ca01e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127b64:	d8c02017 	ldw	r3,128(sp)
81127b68:	da000404 	addi	r8,sp,16
81127b6c:	003dbd06 	br	81127264 <__reset+0xfb107264>
81127b70:	d9002c17 	ldw	r4,176(sp)
81127b74:	d9801e04 	addi	r6,sp,120
81127b78:	b80b883a 	mov	r5,r23
81127b7c:	1132bc40 	call	81132bc4 <__sprint_r>
81127b80:	103c981e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127b84:	d8c02017 	ldw	r3,128(sp)
81127b88:	da000404 	addi	r8,sp,16
81127b8c:	003dc306 	br	8112729c <__reset+0xfb10729c>
81127b90:	d8802917 	ldw	r2,164(sp)
81127b94:	d8002785 	stb	zero,158(sp)
81127b98:	103f0616 	blt	r2,zero,811277b4 <__reset+0xfb1077b4>
81127b9c:	00ffdfc4 	movi	r3,-129
81127ba0:	9d84b03a 	or	r2,r19,r22
81127ba4:	90e4703a 	and	r18,r18,r3
81127ba8:	103c6b26 	beq	r2,zero,81126d58 <__reset+0xfb106d58>
81127bac:	0039883a 	mov	fp,zero
81127bb0:	003e7406 	br	81127584 <__reset+0xfb107584>
81127bb4:	9080040c 	andi	r2,r18,16
81127bb8:	1001b326 	beq	r2,zero,81128288 <___vfprintf_internal_r+0x18b4>
81127bbc:	d9002d17 	ldw	r4,180(sp)
81127bc0:	d9402917 	ldw	r5,164(sp)
81127bc4:	d8002785 	stb	zero,158(sp)
81127bc8:	20800104 	addi	r2,r4,4
81127bcc:	24c00017 	ldw	r19,0(r4)
81127bd0:	002d883a 	mov	r22,zero
81127bd4:	2801b516 	blt	r5,zero,811282ac <___vfprintf_internal_r+0x18d8>
81127bd8:	00ffdfc4 	movi	r3,-129
81127bdc:	d8802d15 	stw	r2,180(sp)
81127be0:	90e4703a 	and	r18,r18,r3
81127be4:	983d2726 	beq	r19,zero,81127084 <__reset+0xfb107084>
81127be8:	0039883a 	mov	fp,zero
81127bec:	003d2a06 	br	81127098 <__reset+0xfb107098>
81127bf0:	dc402617 	ldw	r17,152(sp)
81127bf4:	0441d30e 	bge	zero,r17,81128344 <___vfprintf_internal_r+0x1970>
81127bf8:	dc403217 	ldw	r17,200(sp)
81127bfc:	d8803317 	ldw	r2,204(sp)
81127c00:	1440010e 	bge	r2,r17,81127c08 <___vfprintf_internal_r+0x1234>
81127c04:	1023883a 	mov	r17,r2
81127c08:	04400a0e 	bge	zero,r17,81127c34 <___vfprintf_internal_r+0x1260>
81127c0c:	d8801f17 	ldw	r2,124(sp)
81127c10:	1c47883a 	add	r3,r3,r17
81127c14:	44000015 	stw	r16,0(r8)
81127c18:	10800044 	addi	r2,r2,1
81127c1c:	44400115 	stw	r17,4(r8)
81127c20:	d8c02015 	stw	r3,128(sp)
81127c24:	d8801f15 	stw	r2,124(sp)
81127c28:	010001c4 	movi	r4,7
81127c2c:	20826516 	blt	r4,r2,811285c4 <___vfprintf_internal_r+0x1bf0>
81127c30:	42000204 	addi	r8,r8,8
81127c34:	88026116 	blt	r17,zero,811285bc <___vfprintf_internal_r+0x1be8>
81127c38:	d9003217 	ldw	r4,200(sp)
81127c3c:	2463c83a 	sub	r17,r4,r17
81127c40:	04407b0e 	bge	zero,r17,81127e30 <___vfprintf_internal_r+0x145c>
81127c44:	05800404 	movi	r22,16
81127c48:	d8801f17 	ldw	r2,124(sp)
81127c4c:	b4419d0e 	bge	r22,r17,811282c4 <___vfprintf_internal_r+0x18f0>
81127c50:	01204574 	movhi	r4,33045
81127c54:	21075384 	addi	r4,r4,7502
81127c58:	d9002b15 	stw	r4,172(sp)
81127c5c:	070001c4 	movi	fp,7
81127c60:	dcc02c17 	ldw	r19,176(sp)
81127c64:	00000306 	br	81127c74 <___vfprintf_internal_r+0x12a0>
81127c68:	42000204 	addi	r8,r8,8
81127c6c:	8c7ffc04 	addi	r17,r17,-16
81127c70:	b441970e 	bge	r22,r17,811282d0 <___vfprintf_internal_r+0x18fc>
81127c74:	18c00404 	addi	r3,r3,16
81127c78:	10800044 	addi	r2,r2,1
81127c7c:	45000015 	stw	r20,0(r8)
81127c80:	45800115 	stw	r22,4(r8)
81127c84:	d8c02015 	stw	r3,128(sp)
81127c88:	d8801f15 	stw	r2,124(sp)
81127c8c:	e0bff60e 	bge	fp,r2,81127c68 <__reset+0xfb107c68>
81127c90:	d9801e04 	addi	r6,sp,120
81127c94:	b80b883a 	mov	r5,r23
81127c98:	9809883a 	mov	r4,r19
81127c9c:	1132bc40 	call	81132bc4 <__sprint_r>
81127ca0:	103c501e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127ca4:	d8c02017 	ldw	r3,128(sp)
81127ca8:	d8801f17 	ldw	r2,124(sp)
81127cac:	da000404 	addi	r8,sp,16
81127cb0:	003fee06 	br	81127c6c <__reset+0xfb107c6c>
81127cb4:	d9002c17 	ldw	r4,176(sp)
81127cb8:	d9801e04 	addi	r6,sp,120
81127cbc:	b80b883a 	mov	r5,r23
81127cc0:	1132bc40 	call	81132bc4 <__sprint_r>
81127cc4:	103c471e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127cc8:	d8c02017 	ldw	r3,128(sp)
81127ccc:	df002787 	ldb	fp,158(sp)
81127cd0:	da000404 	addi	r8,sp,16
81127cd4:	003d5606 	br	81127230 <__reset+0xfb107230>
81127cd8:	9080040c 	andi	r2,r18,16
81127cdc:	10016126 	beq	r2,zero,81128264 <___vfprintf_internal_r+0x1890>
81127ce0:	d8802d17 	ldw	r2,180(sp)
81127ce4:	14c00017 	ldw	r19,0(r2)
81127ce8:	10800104 	addi	r2,r2,4
81127cec:	d8802d15 	stw	r2,180(sp)
81127cf0:	982dd7fa 	srai	r22,r19,31
81127cf4:	b005883a 	mov	r2,r22
81127cf8:	003c8206 	br	81126f04 <__reset+0xfb106f04>
81127cfc:	9080040c 	andi	r2,r18,16
81127d00:	10003526 	beq	r2,zero,81127dd8 <___vfprintf_internal_r+0x1404>
81127d04:	d9402d17 	ldw	r5,180(sp)
81127d08:	d8c02917 	ldw	r3,164(sp)
81127d0c:	d8002785 	stb	zero,158(sp)
81127d10:	28800104 	addi	r2,r5,4
81127d14:	2cc00017 	ldw	r19,0(r5)
81127d18:	002d883a 	mov	r22,zero
81127d1c:	18003716 	blt	r3,zero,81127dfc <___vfprintf_internal_r+0x1428>
81127d20:	00ffdfc4 	movi	r3,-129
81127d24:	d8802d15 	stw	r2,180(sp)
81127d28:	90e4703a 	and	r18,r18,r3
81127d2c:	0039883a 	mov	fp,zero
81127d30:	983df326 	beq	r19,zero,81127500 <__reset+0xfb107500>
81127d34:	00800244 	movi	r2,9
81127d38:	14fc7b36 	bltu	r2,r19,81126f28 <__reset+0xfb106f28>
81127d3c:	d8c02817 	ldw	r3,160(sp)
81127d40:	dc001dc4 	addi	r16,sp,119
81127d44:	9cc00c04 	addi	r19,r19,48
81127d48:	1c07c83a 	sub	r3,r3,r16
81127d4c:	dcc01dc5 	stb	r19,119(sp)
81127d50:	d8c02e15 	stw	r3,184(sp)
81127d54:	003ce806 	br	811270f8 <__reset+0xfb1070f8>
81127d58:	d8803317 	ldw	r2,204(sp)
81127d5c:	143fffc4 	addi	r16,r2,-1
81127d60:	043f4d0e 	bge	zero,r16,81127a98 <__reset+0xfb107a98>
81127d64:	07000404 	movi	fp,16
81127d68:	e400810e 	bge	fp,r16,81127f70 <___vfprintf_internal_r+0x159c>
81127d6c:	01604574 	movhi	r5,33045
81127d70:	29475384 	addi	r5,r5,7502
81127d74:	d9402b15 	stw	r5,172(sp)
81127d78:	01c001c4 	movi	r7,7
81127d7c:	dcc02c17 	ldw	r19,176(sp)
81127d80:	00000306 	br	81127d90 <___vfprintf_internal_r+0x13bc>
81127d84:	b5800204 	addi	r22,r22,8
81127d88:	843ffc04 	addi	r16,r16,-16
81127d8c:	e4007b0e 	bge	fp,r16,81127f7c <___vfprintf_internal_r+0x15a8>
81127d90:	18c00404 	addi	r3,r3,16
81127d94:	8c400044 	addi	r17,r17,1
81127d98:	b5000015 	stw	r20,0(r22)
81127d9c:	b7000115 	stw	fp,4(r22)
81127da0:	d8c02015 	stw	r3,128(sp)
81127da4:	dc401f15 	stw	r17,124(sp)
81127da8:	3c7ff60e 	bge	r7,r17,81127d84 <__reset+0xfb107d84>
81127dac:	d9801e04 	addi	r6,sp,120
81127db0:	b80b883a 	mov	r5,r23
81127db4:	9809883a 	mov	r4,r19
81127db8:	d9c03c15 	stw	r7,240(sp)
81127dbc:	1132bc40 	call	81132bc4 <__sprint_r>
81127dc0:	d9c03c17 	ldw	r7,240(sp)
81127dc4:	103c071e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127dc8:	d8c02017 	ldw	r3,128(sp)
81127dcc:	dc401f17 	ldw	r17,124(sp)
81127dd0:	dd800404 	addi	r22,sp,16
81127dd4:	003fec06 	br	81127d88 <__reset+0xfb107d88>
81127dd8:	9080100c 	andi	r2,r18,64
81127ddc:	d8002785 	stb	zero,158(sp)
81127de0:	10010e26 	beq	r2,zero,8112821c <___vfprintf_internal_r+0x1848>
81127de4:	d9002d17 	ldw	r4,180(sp)
81127de8:	d9402917 	ldw	r5,164(sp)
81127dec:	002d883a 	mov	r22,zero
81127df0:	20800104 	addi	r2,r4,4
81127df4:	24c0000b 	ldhu	r19,0(r4)
81127df8:	283fc90e 	bge	r5,zero,81127d20 <__reset+0xfb107d20>
81127dfc:	d8802d15 	stw	r2,180(sp)
81127e00:	0039883a 	mov	fp,zero
81127e04:	9d84b03a 	or	r2,r19,r22
81127e08:	103c461e 	bne	r2,zero,81126f24 <__reset+0xfb106f24>
81127e0c:	00800044 	movi	r2,1
81127e10:	003e6c06 	br	811277c4 <__reset+0xfb1077c4>
81127e14:	d9002c17 	ldw	r4,176(sp)
81127e18:	d9801e04 	addi	r6,sp,120
81127e1c:	b80b883a 	mov	r5,r23
81127e20:	1132bc40 	call	81132bc4 <__sprint_r>
81127e24:	103bef1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127e28:	d8c02017 	ldw	r3,128(sp)
81127e2c:	da000404 	addi	r8,sp,16
81127e30:	d9003217 	ldw	r4,200(sp)
81127e34:	d8802617 	ldw	r2,152(sp)
81127e38:	d9403317 	ldw	r5,204(sp)
81127e3c:	8123883a 	add	r17,r16,r4
81127e40:	11400216 	blt	r2,r5,81127e4c <___vfprintf_internal_r+0x1478>
81127e44:	9100004c 	andi	r4,r18,1
81127e48:	20000d26 	beq	r4,zero,81127e80 <___vfprintf_internal_r+0x14ac>
81127e4c:	d9003717 	ldw	r4,220(sp)
81127e50:	d9403417 	ldw	r5,208(sp)
81127e54:	1907883a 	add	r3,r3,r4
81127e58:	d9001f17 	ldw	r4,124(sp)
81127e5c:	41400015 	stw	r5,0(r8)
81127e60:	d9403717 	ldw	r5,220(sp)
81127e64:	21000044 	addi	r4,r4,1
81127e68:	d8c02015 	stw	r3,128(sp)
81127e6c:	41400115 	stw	r5,4(r8)
81127e70:	d9001f15 	stw	r4,124(sp)
81127e74:	014001c4 	movi	r5,7
81127e78:	2901e816 	blt	r5,r4,8112861c <___vfprintf_internal_r+0x1c48>
81127e7c:	42000204 	addi	r8,r8,8
81127e80:	d9003317 	ldw	r4,204(sp)
81127e84:	8121883a 	add	r16,r16,r4
81127e88:	2085c83a 	sub	r2,r4,r2
81127e8c:	8461c83a 	sub	r16,r16,r17
81127e90:	1400010e 	bge	r2,r16,81127e98 <___vfprintf_internal_r+0x14c4>
81127e94:	1021883a 	mov	r16,r2
81127e98:	04000a0e 	bge	zero,r16,81127ec4 <___vfprintf_internal_r+0x14f0>
81127e9c:	d9001f17 	ldw	r4,124(sp)
81127ea0:	1c07883a 	add	r3,r3,r16
81127ea4:	44400015 	stw	r17,0(r8)
81127ea8:	21000044 	addi	r4,r4,1
81127eac:	44000115 	stw	r16,4(r8)
81127eb0:	d8c02015 	stw	r3,128(sp)
81127eb4:	d9001f15 	stw	r4,124(sp)
81127eb8:	014001c4 	movi	r5,7
81127ebc:	2901fb16 	blt	r5,r4,811286ac <___vfprintf_internal_r+0x1cd8>
81127ec0:	42000204 	addi	r8,r8,8
81127ec4:	8001f716 	blt	r16,zero,811286a4 <___vfprintf_internal_r+0x1cd0>
81127ec8:	1421c83a 	sub	r16,r2,r16
81127ecc:	043d380e 	bge	zero,r16,811273b0 <__reset+0xfb1073b0>
81127ed0:	04400404 	movi	r17,16
81127ed4:	d8801f17 	ldw	r2,124(sp)
81127ed8:	8c3efb0e 	bge	r17,r16,81127ac8 <__reset+0xfb107ac8>
81127edc:	01604574 	movhi	r5,33045
81127ee0:	29475384 	addi	r5,r5,7502
81127ee4:	d9402b15 	stw	r5,172(sp)
81127ee8:	058001c4 	movi	r22,7
81127eec:	dcc02c17 	ldw	r19,176(sp)
81127ef0:	00000306 	br	81127f00 <___vfprintf_internal_r+0x152c>
81127ef4:	42000204 	addi	r8,r8,8
81127ef8:	843ffc04 	addi	r16,r16,-16
81127efc:	8c3ef50e 	bge	r17,r16,81127ad4 <__reset+0xfb107ad4>
81127f00:	18c00404 	addi	r3,r3,16
81127f04:	10800044 	addi	r2,r2,1
81127f08:	45000015 	stw	r20,0(r8)
81127f0c:	44400115 	stw	r17,4(r8)
81127f10:	d8c02015 	stw	r3,128(sp)
81127f14:	d8801f15 	stw	r2,124(sp)
81127f18:	b0bff60e 	bge	r22,r2,81127ef4 <__reset+0xfb107ef4>
81127f1c:	d9801e04 	addi	r6,sp,120
81127f20:	b80b883a 	mov	r5,r23
81127f24:	9809883a 	mov	r4,r19
81127f28:	1132bc40 	call	81132bc4 <__sprint_r>
81127f2c:	103bad1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127f30:	d8c02017 	ldw	r3,128(sp)
81127f34:	d8801f17 	ldw	r2,124(sp)
81127f38:	da000404 	addi	r8,sp,16
81127f3c:	003fee06 	br	81127ef8 <__reset+0xfb107ef8>
81127f40:	9088703a 	and	r4,r18,r2
81127f44:	203eab1e 	bne	r4,zero,811279f4 <__reset+0xfb1079f4>
81127f48:	dc401f17 	ldw	r17,124(sp)
81127f4c:	40800115 	stw	r2,4(r8)
81127f50:	44000015 	stw	r16,0(r8)
81127f54:	8c400044 	addi	r17,r17,1
81127f58:	d8c02015 	stw	r3,128(sp)
81127f5c:	dc401f15 	stw	r17,124(sp)
81127f60:	008001c4 	movi	r2,7
81127f64:	14400e16 	blt	r2,r17,81127fa0 <___vfprintf_internal_r+0x15cc>
81127f68:	45800204 	addi	r22,r8,8
81127f6c:	003eca06 	br	81127a98 <__reset+0xfb107a98>
81127f70:	01204574 	movhi	r4,33045
81127f74:	21075384 	addi	r4,r4,7502
81127f78:	d9002b15 	stw	r4,172(sp)
81127f7c:	d8802b17 	ldw	r2,172(sp)
81127f80:	1c07883a 	add	r3,r3,r16
81127f84:	8c400044 	addi	r17,r17,1
81127f88:	b0800015 	stw	r2,0(r22)
81127f8c:	b4000115 	stw	r16,4(r22)
81127f90:	d8c02015 	stw	r3,128(sp)
81127f94:	dc401f15 	stw	r17,124(sp)
81127f98:	008001c4 	movi	r2,7
81127f9c:	147ebd0e 	bge	r2,r17,81127a94 <__reset+0xfb107a94>
81127fa0:	d9002c17 	ldw	r4,176(sp)
81127fa4:	d9801e04 	addi	r6,sp,120
81127fa8:	b80b883a 	mov	r5,r23
81127fac:	1132bc40 	call	81132bc4 <__sprint_r>
81127fb0:	103b8c1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127fb4:	d8c02017 	ldw	r3,128(sp)
81127fb8:	dc401f17 	ldw	r17,124(sp)
81127fbc:	dd800404 	addi	r22,sp,16
81127fc0:	003eb506 	br	81127a98 <__reset+0xfb107a98>
81127fc4:	d9002c17 	ldw	r4,176(sp)
81127fc8:	d9801e04 	addi	r6,sp,120
81127fcc:	b80b883a 	mov	r5,r23
81127fd0:	1132bc40 	call	81132bc4 <__sprint_r>
81127fd4:	103b831e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127fd8:	d8c02017 	ldw	r3,128(sp)
81127fdc:	dc401f17 	ldw	r17,124(sp)
81127fe0:	da000404 	addi	r8,sp,16
81127fe4:	003e8d06 	br	81127a1c <__reset+0xfb107a1c>
81127fe8:	d9002c17 	ldw	r4,176(sp)
81127fec:	d9801e04 	addi	r6,sp,120
81127ff0:	b80b883a 	mov	r5,r23
81127ff4:	1132bc40 	call	81132bc4 <__sprint_r>
81127ff8:	103b7a1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81127ffc:	d8c02017 	ldw	r3,128(sp)
81128000:	dc401f17 	ldw	r17,124(sp)
81128004:	dd800404 	addi	r22,sp,16
81128008:	003e8f06 	br	81127a48 <__reset+0xfb107a48>
8112800c:	0027883a 	mov	r19,zero
81128010:	003f4a06 	br	81127d3c <__reset+0xfb107d3c>
81128014:	d9002c17 	ldw	r4,176(sp)
81128018:	d9801e04 	addi	r6,sp,120
8112801c:	b80b883a 	mov	r5,r23
81128020:	1132bc40 	call	81132bc4 <__sprint_r>
81128024:	103b6f1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128028:	d8c02017 	ldw	r3,128(sp)
8112802c:	da000404 	addi	r8,sp,16
81128030:	003c9d06 	br	811272a8 <__reset+0xfb1072a8>
81128034:	04e7c83a 	sub	r19,zero,r19
81128038:	9804c03a 	cmpne	r2,r19,zero
8112803c:	05adc83a 	sub	r22,zero,r22
81128040:	b0adc83a 	sub	r22,r22,r2
81128044:	d8802917 	ldw	r2,164(sp)
81128048:	07000b44 	movi	fp,45
8112804c:	df002785 	stb	fp,158(sp)
81128050:	10017b16 	blt	r2,zero,81128640 <___vfprintf_internal_r+0x1c6c>
81128054:	00bfdfc4 	movi	r2,-129
81128058:	90a4703a 	and	r18,r18,r2
8112805c:	003bb106 	br	81126f24 <__reset+0xfb106f24>
81128060:	d9003617 	ldw	r4,216(sp)
81128064:	d9403817 	ldw	r5,224(sp)
81128068:	da003d15 	stw	r8,244(sp)
8112806c:	112f2280 	call	8112f228 <__fpclassifyd>
81128070:	da003d17 	ldw	r8,244(sp)
81128074:	1000f026 	beq	r2,zero,81128438 <___vfprintf_internal_r+0x1a64>
81128078:	d9002917 	ldw	r4,164(sp)
8112807c:	05bff7c4 	movi	r22,-33
81128080:	00bfffc4 	movi	r2,-1
81128084:	8dac703a 	and	r22,r17,r22
81128088:	20820026 	beq	r4,r2,8112888c <___vfprintf_internal_r+0x1eb8>
8112808c:	008011c4 	movi	r2,71
81128090:	b081f726 	beq	r22,r2,81128870 <___vfprintf_internal_r+0x1e9c>
81128094:	d9003817 	ldw	r4,224(sp)
81128098:	90c04014 	ori	r3,r18,256
8112809c:	d8c02b15 	stw	r3,172(sp)
811280a0:	20021516 	blt	r4,zero,811288f8 <___vfprintf_internal_r+0x1f24>
811280a4:	dcc03817 	ldw	r19,224(sp)
811280a8:	d8002a05 	stb	zero,168(sp)
811280ac:	00801984 	movi	r2,102
811280b0:	8881f926 	beq	r17,r2,81128898 <___vfprintf_internal_r+0x1ec4>
811280b4:	00801184 	movi	r2,70
811280b8:	88821c26 	beq	r17,r2,8112892c <___vfprintf_internal_r+0x1f58>
811280bc:	00801144 	movi	r2,69
811280c0:	b081ef26 	beq	r22,r2,81128880 <___vfprintf_internal_r+0x1eac>
811280c4:	d8c02917 	ldw	r3,164(sp)
811280c8:	d8802104 	addi	r2,sp,132
811280cc:	d8800315 	stw	r2,12(sp)
811280d0:	d9403617 	ldw	r5,216(sp)
811280d4:	d8802504 	addi	r2,sp,148
811280d8:	d9002c17 	ldw	r4,176(sp)
811280dc:	d8800215 	stw	r2,8(sp)
811280e0:	d8802604 	addi	r2,sp,152
811280e4:	d8c00015 	stw	r3,0(sp)
811280e8:	d8800115 	stw	r2,4(sp)
811280ec:	01c00084 	movi	r7,2
811280f0:	980d883a 	mov	r6,r19
811280f4:	d8c03c15 	stw	r3,240(sp)
811280f8:	da003d15 	stw	r8,244(sp)
811280fc:	112aae00 	call	8112aae0 <_dtoa_r>
81128100:	1021883a 	mov	r16,r2
81128104:	008019c4 	movi	r2,103
81128108:	d8c03c17 	ldw	r3,240(sp)
8112810c:	da003d17 	ldw	r8,244(sp)
81128110:	88817126 	beq	r17,r2,811286d8 <___vfprintf_internal_r+0x1d04>
81128114:	008011c4 	movi	r2,71
81128118:	88829226 	beq	r17,r2,81128b64 <___vfprintf_internal_r+0x2190>
8112811c:	80f9883a 	add	fp,r16,r3
81128120:	d9003617 	ldw	r4,216(sp)
81128124:	000d883a 	mov	r6,zero
81128128:	000f883a 	mov	r7,zero
8112812c:	980b883a 	mov	r5,r19
81128130:	da003d15 	stw	r8,244(sp)
81128134:	11373900 	call	81137390 <__eqdf2>
81128138:	da003d17 	ldw	r8,244(sp)
8112813c:	10018d26 	beq	r2,zero,81128774 <___vfprintf_internal_r+0x1da0>
81128140:	d8802117 	ldw	r2,132(sp)
81128144:	1700062e 	bgeu	r2,fp,81128160 <___vfprintf_internal_r+0x178c>
81128148:	01000c04 	movi	r4,48
8112814c:	10c00044 	addi	r3,r2,1
81128150:	d8c02115 	stw	r3,132(sp)
81128154:	11000005 	stb	r4,0(r2)
81128158:	d8802117 	ldw	r2,132(sp)
8112815c:	173ffb36 	bltu	r2,fp,8112814c <__reset+0xfb10814c>
81128160:	1405c83a 	sub	r2,r2,r16
81128164:	d8803315 	stw	r2,204(sp)
81128168:	008011c4 	movi	r2,71
8112816c:	b0817626 	beq	r22,r2,81128748 <___vfprintf_internal_r+0x1d74>
81128170:	00801944 	movi	r2,101
81128174:	1442810e 	bge	r2,r17,81128b7c <___vfprintf_internal_r+0x21a8>
81128178:	d8c02617 	ldw	r3,152(sp)
8112817c:	00801984 	movi	r2,102
81128180:	d8c03215 	stw	r3,200(sp)
81128184:	8881fe26 	beq	r17,r2,81128980 <___vfprintf_internal_r+0x1fac>
81128188:	d8c03217 	ldw	r3,200(sp)
8112818c:	d9003317 	ldw	r4,204(sp)
81128190:	1901dd16 	blt	r3,r4,81128908 <___vfprintf_internal_r+0x1f34>
81128194:	9480004c 	andi	r18,r18,1
81128198:	90022b1e 	bne	r18,zero,81128a48 <___vfprintf_internal_r+0x2074>
8112819c:	1805883a 	mov	r2,r3
811281a0:	18028016 	blt	r3,zero,81128ba4 <___vfprintf_internal_r+0x21d0>
811281a4:	d8c03217 	ldw	r3,200(sp)
811281a8:	044019c4 	movi	r17,103
811281ac:	d8c02e15 	stw	r3,184(sp)
811281b0:	df002a07 	ldb	fp,168(sp)
811281b4:	e001531e 	bne	fp,zero,81128704 <___vfprintf_internal_r+0x1d30>
811281b8:	df002783 	ldbu	fp,158(sp)
811281bc:	d8802a15 	stw	r2,168(sp)
811281c0:	dc802b17 	ldw	r18,172(sp)
811281c4:	d8002915 	stw	zero,164(sp)
811281c8:	003bd106 	br	81127110 <__reset+0xfb107110>
811281cc:	d8802d17 	ldw	r2,180(sp)
811281d0:	d8c02d17 	ldw	r3,180(sp)
811281d4:	d9002d17 	ldw	r4,180(sp)
811281d8:	10800017 	ldw	r2,0(r2)
811281dc:	18c00117 	ldw	r3,4(r3)
811281e0:	21000204 	addi	r4,r4,8
811281e4:	d8803615 	stw	r2,216(sp)
811281e8:	d8c03815 	stw	r3,224(sp)
811281ec:	d9002d15 	stw	r4,180(sp)
811281f0:	003b7506 	br	81126fc8 <__reset+0xfb106fc8>
811281f4:	ac400007 	ldb	r17,0(r21)
811281f8:	003a5906 	br	81126b60 <__reset+0xfb106b60>
811281fc:	9080100c 	andi	r2,r18,64
81128200:	1000a826 	beq	r2,zero,811284a4 <___vfprintf_internal_r+0x1ad0>
81128204:	d9002d17 	ldw	r4,180(sp)
81128208:	002d883a 	mov	r22,zero
8112820c:	24c0000b 	ldhu	r19,0(r4)
81128210:	21000104 	addi	r4,r4,4
81128214:	d9002d15 	stw	r4,180(sp)
81128218:	003ccb06 	br	81127548 <__reset+0xfb107548>
8112821c:	d8c02d17 	ldw	r3,180(sp)
81128220:	d9002917 	ldw	r4,164(sp)
81128224:	002d883a 	mov	r22,zero
81128228:	18800104 	addi	r2,r3,4
8112822c:	1cc00017 	ldw	r19,0(r3)
81128230:	203ebb0e 	bge	r4,zero,81127d20 <__reset+0xfb107d20>
81128234:	003ef106 	br	81127dfc <__reset+0xfb107dfc>
81128238:	9080040c 	andi	r2,r18,16
8112823c:	1000921e 	bne	r2,zero,81128488 <___vfprintf_internal_r+0x1ab4>
81128240:	9480100c 	andi	r18,r18,64
81128244:	90013926 	beq	r18,zero,8112872c <___vfprintf_internal_r+0x1d58>
81128248:	d9002d17 	ldw	r4,180(sp)
8112824c:	d9402f17 	ldw	r5,188(sp)
81128250:	20800017 	ldw	r2,0(r4)
81128254:	21000104 	addi	r4,r4,4
81128258:	d9002d15 	stw	r4,180(sp)
8112825c:	1140000d 	sth	r5,0(r2)
81128260:	003a1606 	br	81126abc <__reset+0xfb106abc>
81128264:	9080100c 	andi	r2,r18,64
81128268:	10008026 	beq	r2,zero,8112846c <___vfprintf_internal_r+0x1a98>
8112826c:	d8c02d17 	ldw	r3,180(sp)
81128270:	1cc0000f 	ldh	r19,0(r3)
81128274:	18c00104 	addi	r3,r3,4
81128278:	d8c02d15 	stw	r3,180(sp)
8112827c:	982dd7fa 	srai	r22,r19,31
81128280:	b005883a 	mov	r2,r22
81128284:	003b1f06 	br	81126f04 <__reset+0xfb106f04>
81128288:	9080100c 	andi	r2,r18,64
8112828c:	d8002785 	stb	zero,158(sp)
81128290:	10008a1e 	bne	r2,zero,811284bc <___vfprintf_internal_r+0x1ae8>
81128294:	d9402d17 	ldw	r5,180(sp)
81128298:	d8c02917 	ldw	r3,164(sp)
8112829c:	002d883a 	mov	r22,zero
811282a0:	28800104 	addi	r2,r5,4
811282a4:	2cc00017 	ldw	r19,0(r5)
811282a8:	183e4b0e 	bge	r3,zero,81127bd8 <__reset+0xfb107bd8>
811282ac:	9d86b03a 	or	r3,r19,r22
811282b0:	d8802d15 	stw	r2,180(sp)
811282b4:	183e4c1e 	bne	r3,zero,81127be8 <__reset+0xfb107be8>
811282b8:	0039883a 	mov	fp,zero
811282bc:	0005883a 	mov	r2,zero
811282c0:	003d4006 	br	811277c4 <__reset+0xfb1077c4>
811282c4:	01604574 	movhi	r5,33045
811282c8:	29475384 	addi	r5,r5,7502
811282cc:	d9402b15 	stw	r5,172(sp)
811282d0:	d9402b17 	ldw	r5,172(sp)
811282d4:	1c47883a 	add	r3,r3,r17
811282d8:	10800044 	addi	r2,r2,1
811282dc:	41400015 	stw	r5,0(r8)
811282e0:	44400115 	stw	r17,4(r8)
811282e4:	d8c02015 	stw	r3,128(sp)
811282e8:	d8801f15 	stw	r2,124(sp)
811282ec:	010001c4 	movi	r4,7
811282f0:	20bec816 	blt	r4,r2,81127e14 <__reset+0xfb107e14>
811282f4:	42000204 	addi	r8,r8,8
811282f8:	003ecd06 	br	81127e30 <__reset+0xfb107e30>
811282fc:	d9002917 	ldw	r4,164(sp)
81128300:	d8002785 	stb	zero,158(sp)
81128304:	203d2d16 	blt	r4,zero,811277bc <__reset+0xfb1077bc>
81128308:	00bfdfc4 	movi	r2,-129
8112830c:	90a4703a 	and	r18,r18,r2
81128310:	003a9106 	br	81126d58 <__reset+0xfb106d58>
81128314:	01204574 	movhi	r4,33045
81128318:	21075384 	addi	r4,r4,7502
8112831c:	d9002b15 	stw	r4,172(sp)
81128320:	003c0c06 	br	81127354 <__reset+0xfb107354>
81128324:	d9002c17 	ldw	r4,176(sp)
81128328:	d9801e04 	addi	r6,sp,120
8112832c:	b80b883a 	mov	r5,r23
81128330:	1132bc40 	call	81132bc4 <__sprint_r>
81128334:	103aab1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128338:	d8c02017 	ldw	r3,128(sp)
8112833c:	da000404 	addi	r8,sp,16
81128340:	003d4106 	br	81127848 <__reset+0xfb107848>
81128344:	d8801f17 	ldw	r2,124(sp)
81128348:	01604574 	movhi	r5,33045
8112834c:	01000044 	movi	r4,1
81128350:	18c00044 	addi	r3,r3,1
81128354:	10800044 	addi	r2,r2,1
81128358:	29474b04 	addi	r5,r5,7468
8112835c:	41000115 	stw	r4,4(r8)
81128360:	41400015 	stw	r5,0(r8)
81128364:	d8c02015 	stw	r3,128(sp)
81128368:	d8801f15 	stw	r2,124(sp)
8112836c:	010001c4 	movi	r4,7
81128370:	20805c16 	blt	r4,r2,811284e4 <___vfprintf_internal_r+0x1b10>
81128374:	42000204 	addi	r8,r8,8
81128378:	8800041e 	bne	r17,zero,8112838c <___vfprintf_internal_r+0x19b8>
8112837c:	d8803317 	ldw	r2,204(sp)
81128380:	1000021e 	bne	r2,zero,8112838c <___vfprintf_internal_r+0x19b8>
81128384:	9080004c 	andi	r2,r18,1
81128388:	103c0926 	beq	r2,zero,811273b0 <__reset+0xfb1073b0>
8112838c:	d9003717 	ldw	r4,220(sp)
81128390:	d8801f17 	ldw	r2,124(sp)
81128394:	d9403417 	ldw	r5,208(sp)
81128398:	20c7883a 	add	r3,r4,r3
8112839c:	10800044 	addi	r2,r2,1
811283a0:	41000115 	stw	r4,4(r8)
811283a4:	41400015 	stw	r5,0(r8)
811283a8:	d8c02015 	stw	r3,128(sp)
811283ac:	d8801f15 	stw	r2,124(sp)
811283b0:	010001c4 	movi	r4,7
811283b4:	20812116 	blt	r4,r2,8112883c <___vfprintf_internal_r+0x1e68>
811283b8:	42000204 	addi	r8,r8,8
811283bc:	0463c83a 	sub	r17,zero,r17
811283c0:	0440730e 	bge	zero,r17,81128590 <___vfprintf_internal_r+0x1bbc>
811283c4:	05800404 	movi	r22,16
811283c8:	b440860e 	bge	r22,r17,811285e4 <___vfprintf_internal_r+0x1c10>
811283cc:	01604574 	movhi	r5,33045
811283d0:	29475384 	addi	r5,r5,7502
811283d4:	d9402b15 	stw	r5,172(sp)
811283d8:	070001c4 	movi	fp,7
811283dc:	dcc02c17 	ldw	r19,176(sp)
811283e0:	00000306 	br	811283f0 <___vfprintf_internal_r+0x1a1c>
811283e4:	42000204 	addi	r8,r8,8
811283e8:	8c7ffc04 	addi	r17,r17,-16
811283ec:	b440800e 	bge	r22,r17,811285f0 <___vfprintf_internal_r+0x1c1c>
811283f0:	18c00404 	addi	r3,r3,16
811283f4:	10800044 	addi	r2,r2,1
811283f8:	45000015 	stw	r20,0(r8)
811283fc:	45800115 	stw	r22,4(r8)
81128400:	d8c02015 	stw	r3,128(sp)
81128404:	d8801f15 	stw	r2,124(sp)
81128408:	e0bff60e 	bge	fp,r2,811283e4 <__reset+0xfb1083e4>
8112840c:	d9801e04 	addi	r6,sp,120
81128410:	b80b883a 	mov	r5,r23
81128414:	9809883a 	mov	r4,r19
81128418:	1132bc40 	call	81132bc4 <__sprint_r>
8112841c:	103a711e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128420:	d8c02017 	ldw	r3,128(sp)
81128424:	d8801f17 	ldw	r2,124(sp)
81128428:	da000404 	addi	r8,sp,16
8112842c:	003fee06 	br	811283e8 <__reset+0xfb1083e8>
81128430:	00bfffc4 	movi	r2,-1
81128434:	003a6f06 	br	81126df4 <__reset+0xfb106df4>
81128438:	008011c4 	movi	r2,71
8112843c:	1440b816 	blt	r2,r17,81128720 <___vfprintf_internal_r+0x1d4c>
81128440:	04204574 	movhi	r16,33045
81128444:	84073d04 	addi	r16,r16,7412
81128448:	00c000c4 	movi	r3,3
8112844c:	00bfdfc4 	movi	r2,-129
81128450:	d8c02a15 	stw	r3,168(sp)
81128454:	90a4703a 	and	r18,r18,r2
81128458:	df002783 	ldbu	fp,158(sp)
8112845c:	d8c02e15 	stw	r3,184(sp)
81128460:	d8002915 	stw	zero,164(sp)
81128464:	d8003215 	stw	zero,200(sp)
81128468:	003b2906 	br	81127110 <__reset+0xfb107110>
8112846c:	d9002d17 	ldw	r4,180(sp)
81128470:	24c00017 	ldw	r19,0(r4)
81128474:	21000104 	addi	r4,r4,4
81128478:	d9002d15 	stw	r4,180(sp)
8112847c:	982dd7fa 	srai	r22,r19,31
81128480:	b005883a 	mov	r2,r22
81128484:	003a9f06 	br	81126f04 <__reset+0xfb106f04>
81128488:	d9402d17 	ldw	r5,180(sp)
8112848c:	d8c02f17 	ldw	r3,188(sp)
81128490:	28800017 	ldw	r2,0(r5)
81128494:	29400104 	addi	r5,r5,4
81128498:	d9402d15 	stw	r5,180(sp)
8112849c:	10c00015 	stw	r3,0(r2)
811284a0:	00398606 	br	81126abc <__reset+0xfb106abc>
811284a4:	d9402d17 	ldw	r5,180(sp)
811284a8:	002d883a 	mov	r22,zero
811284ac:	2cc00017 	ldw	r19,0(r5)
811284b0:	29400104 	addi	r5,r5,4
811284b4:	d9402d15 	stw	r5,180(sp)
811284b8:	003c2306 	br	81127548 <__reset+0xfb107548>
811284bc:	d8c02d17 	ldw	r3,180(sp)
811284c0:	d9002917 	ldw	r4,164(sp)
811284c4:	002d883a 	mov	r22,zero
811284c8:	18800104 	addi	r2,r3,4
811284cc:	1cc0000b 	ldhu	r19,0(r3)
811284d0:	203dc10e 	bge	r4,zero,81127bd8 <__reset+0xfb107bd8>
811284d4:	003f7506 	br	811282ac <__reset+0xfb1082ac>
811284d8:	04204574 	movhi	r16,33045
811284dc:	84073b04 	addi	r16,r16,7404
811284e0:	003acc06 	br	81127014 <__reset+0xfb107014>
811284e4:	d9002c17 	ldw	r4,176(sp)
811284e8:	d9801e04 	addi	r6,sp,120
811284ec:	b80b883a 	mov	r5,r23
811284f0:	1132bc40 	call	81132bc4 <__sprint_r>
811284f4:	103a3b1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
811284f8:	dc402617 	ldw	r17,152(sp)
811284fc:	d8c02017 	ldw	r3,128(sp)
81128500:	da000404 	addi	r8,sp,16
81128504:	003f9c06 	br	81128378 <__reset+0xfb108378>
81128508:	ac400043 	ldbu	r17,1(r21)
8112850c:	94800814 	ori	r18,r18,32
81128510:	ad400044 	addi	r21,r21,1
81128514:	8c403fcc 	andi	r17,r17,255
81128518:	8c40201c 	xori	r17,r17,128
8112851c:	8c7fe004 	addi	r17,r17,-128
81128520:	00398f06 	br	81126b60 <__reset+0xfb106b60>
81128524:	d8c02d15 	stw	r3,180(sp)
81128528:	0039883a 	mov	fp,zero
8112852c:	003e3506 	br	81127e04 <__reset+0xfb107e04>
81128530:	d9002c17 	ldw	r4,176(sp)
81128534:	d9801e04 	addi	r6,sp,120
81128538:	b80b883a 	mov	r5,r23
8112853c:	1132bc40 	call	81132bc4 <__sprint_r>
81128540:	103a281e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128544:	d8c02017 	ldw	r3,128(sp)
81128548:	da000404 	addi	r8,sp,16
8112854c:	003cd006 	br	81127890 <__reset+0xfb107890>
81128550:	8009883a 	mov	r4,r16
81128554:	da003d15 	stw	r8,244(sp)
81128558:	11244bc0 	call	811244bc <strlen>
8112855c:	d8802e15 	stw	r2,184(sp)
81128560:	da003d17 	ldw	r8,244(sp)
81128564:	103c340e 	bge	r2,zero,81127638 <__reset+0xfb107638>
81128568:	0005883a 	mov	r2,zero
8112856c:	003c3206 	br	81127638 <__reset+0xfb107638>
81128570:	d9002c17 	ldw	r4,176(sp)
81128574:	d9801e04 	addi	r6,sp,120
81128578:	b80b883a 	mov	r5,r23
8112857c:	1132bc40 	call	81132bc4 <__sprint_r>
81128580:	103a181e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128584:	d8c02017 	ldw	r3,128(sp)
81128588:	d8801f17 	ldw	r2,124(sp)
8112858c:	da000404 	addi	r8,sp,16
81128590:	d9403317 	ldw	r5,204(sp)
81128594:	10800044 	addi	r2,r2,1
81128598:	44000015 	stw	r16,0(r8)
8112859c:	28c7883a 	add	r3,r5,r3
811285a0:	003b7d06 	br	81127398 <__reset+0xfb107398>
811285a4:	01204574 	movhi	r4,33045
811285a8:	21075784 	addi	r4,r4,7518
811285ac:	d9003515 	stw	r4,212(sp)
811285b0:	003b1406 	br	81127204 <__reset+0xfb107204>
811285b4:	013fffc4 	movi	r4,-1
811285b8:	003a3506 	br	81126e90 <__reset+0xfb106e90>
811285bc:	0023883a 	mov	r17,zero
811285c0:	003d9d06 	br	81127c38 <__reset+0xfb107c38>
811285c4:	d9002c17 	ldw	r4,176(sp)
811285c8:	d9801e04 	addi	r6,sp,120
811285cc:	b80b883a 	mov	r5,r23
811285d0:	1132bc40 	call	81132bc4 <__sprint_r>
811285d4:	103a031e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
811285d8:	d8c02017 	ldw	r3,128(sp)
811285dc:	da000404 	addi	r8,sp,16
811285e0:	003d9406 	br	81127c34 <__reset+0xfb107c34>
811285e4:	01204574 	movhi	r4,33045
811285e8:	21075384 	addi	r4,r4,7502
811285ec:	d9002b15 	stw	r4,172(sp)
811285f0:	d9002b17 	ldw	r4,172(sp)
811285f4:	1c47883a 	add	r3,r3,r17
811285f8:	10800044 	addi	r2,r2,1
811285fc:	41000015 	stw	r4,0(r8)
81128600:	44400115 	stw	r17,4(r8)
81128604:	d8c02015 	stw	r3,128(sp)
81128608:	d8801f15 	stw	r2,124(sp)
8112860c:	010001c4 	movi	r4,7
81128610:	20bfd716 	blt	r4,r2,81128570 <__reset+0xfb108570>
81128614:	42000204 	addi	r8,r8,8
81128618:	003fdd06 	br	81128590 <__reset+0xfb108590>
8112861c:	d9002c17 	ldw	r4,176(sp)
81128620:	d9801e04 	addi	r6,sp,120
81128624:	b80b883a 	mov	r5,r23
81128628:	1132bc40 	call	81132bc4 <__sprint_r>
8112862c:	1039ed1e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128630:	d8802617 	ldw	r2,152(sp)
81128634:	d8c02017 	ldw	r3,128(sp)
81128638:	da000404 	addi	r8,sp,16
8112863c:	003e1006 	br	81127e80 <__reset+0xfb107e80>
81128640:	00800044 	movi	r2,1
81128644:	10803fcc 	andi	r2,r2,255
81128648:	00c00044 	movi	r3,1
8112864c:	10fa3526 	beq	r2,r3,81126f24 <__reset+0xfb106f24>
81128650:	00c00084 	movi	r3,2
81128654:	10fbcb26 	beq	r2,r3,81127584 <__reset+0xfb107584>
81128658:	003a8f06 	br	81127098 <__reset+0xfb107098>
8112865c:	01204574 	movhi	r4,33045
81128660:	21075784 	addi	r4,r4,7518
81128664:	d9003515 	stw	r4,212(sp)
81128668:	003b7606 	br	81127444 <__reset+0xfb107444>
8112866c:	d8802917 	ldw	r2,164(sp)
81128670:	00c00184 	movi	r3,6
81128674:	1880012e 	bgeu	r3,r2,8112867c <___vfprintf_internal_r+0x1ca8>
81128678:	1805883a 	mov	r2,r3
8112867c:	d8802e15 	stw	r2,184(sp)
81128680:	1000ef16 	blt	r2,zero,81128a40 <___vfprintf_internal_r+0x206c>
81128684:	04204574 	movhi	r16,33045
81128688:	d8802a15 	stw	r2,168(sp)
8112868c:	dcc02d15 	stw	r19,180(sp)
81128690:	d8002915 	stw	zero,164(sp)
81128694:	d8003215 	stw	zero,200(sp)
81128698:	84074904 	addi	r16,r16,7460
8112869c:	0039883a 	mov	fp,zero
811286a0:	003aa206 	br	8112712c <__reset+0xfb10712c>
811286a4:	0021883a 	mov	r16,zero
811286a8:	003e0706 	br	81127ec8 <__reset+0xfb107ec8>
811286ac:	d9002c17 	ldw	r4,176(sp)
811286b0:	d9801e04 	addi	r6,sp,120
811286b4:	b80b883a 	mov	r5,r23
811286b8:	1132bc40 	call	81132bc4 <__sprint_r>
811286bc:	1039c91e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
811286c0:	d8802617 	ldw	r2,152(sp)
811286c4:	d9403317 	ldw	r5,204(sp)
811286c8:	d8c02017 	ldw	r3,128(sp)
811286cc:	da000404 	addi	r8,sp,16
811286d0:	2885c83a 	sub	r2,r5,r2
811286d4:	003dfb06 	br	81127ec4 <__reset+0xfb107ec4>
811286d8:	9080004c 	andi	r2,r18,1
811286dc:	103e8f1e 	bne	r2,zero,8112811c <__reset+0xfb10811c>
811286e0:	d8802117 	ldw	r2,132(sp)
811286e4:	003e9e06 	br	81128160 <__reset+0xfb108160>
811286e8:	1025883a 	mov	r18,r2
811286ec:	0039883a 	mov	fp,zero
811286f0:	00800084 	movi	r2,2
811286f4:	003fd306 	br	81128644 <__reset+0xfb108644>
811286f8:	07000b44 	movi	fp,45
811286fc:	df002785 	stb	fp,158(sp)
81128700:	003a4006 	br	81127004 <__reset+0xfb107004>
81128704:	00c00b44 	movi	r3,45
81128708:	d8c02785 	stb	r3,158(sp)
8112870c:	d8802a15 	stw	r2,168(sp)
81128710:	dc802b17 	ldw	r18,172(sp)
81128714:	d8002915 	stw	zero,164(sp)
81128718:	07000b44 	movi	fp,45
8112871c:	003a8006 	br	81127120 <__reset+0xfb107120>
81128720:	04204574 	movhi	r16,33045
81128724:	84073e04 	addi	r16,r16,7416
81128728:	003f4706 	br	81128448 <__reset+0xfb108448>
8112872c:	d8c02d17 	ldw	r3,180(sp)
81128730:	d9002f17 	ldw	r4,188(sp)
81128734:	18800017 	ldw	r2,0(r3)
81128738:	18c00104 	addi	r3,r3,4
8112873c:	d8c02d15 	stw	r3,180(sp)
81128740:	11000015 	stw	r4,0(r2)
81128744:	0038dd06 	br	81126abc <__reset+0xfb106abc>
81128748:	dd802617 	ldw	r22,152(sp)
8112874c:	00bfff44 	movi	r2,-3
81128750:	b0801c16 	blt	r22,r2,811287c4 <___vfprintf_internal_r+0x1df0>
81128754:	d9402917 	ldw	r5,164(sp)
81128758:	2d801a16 	blt	r5,r22,811287c4 <___vfprintf_internal_r+0x1df0>
8112875c:	dd803215 	stw	r22,200(sp)
81128760:	003e8906 	br	81128188 <__reset+0xfb108188>
81128764:	01204574 	movhi	r4,33045
81128768:	21075384 	addi	r4,r4,7502
8112876c:	d9002b15 	stw	r4,172(sp)
81128770:	003c9106 	br	811279b8 <__reset+0xfb1079b8>
81128774:	e005883a 	mov	r2,fp
81128778:	003e7906 	br	81128160 <__reset+0xfb108160>
8112877c:	d9402917 	ldw	r5,164(sp)
81128780:	df002783 	ldbu	fp,158(sp)
81128784:	dcc02d15 	stw	r19,180(sp)
81128788:	d9402a15 	stw	r5,168(sp)
8112878c:	d9402e15 	stw	r5,184(sp)
81128790:	d8002915 	stw	zero,164(sp)
81128794:	d8003215 	stw	zero,200(sp)
81128798:	003a5d06 	br	81127110 <__reset+0xfb107110>
8112879c:	9080004c 	andi	r2,r18,1
811287a0:	0039883a 	mov	fp,zero
811287a4:	10000426 	beq	r2,zero,811287b8 <___vfprintf_internal_r+0x1de4>
811287a8:	00800c04 	movi	r2,48
811287ac:	dc001dc4 	addi	r16,sp,119
811287b0:	d8801dc5 	stb	r2,119(sp)
811287b4:	003b8006 	br	811275b8 <__reset+0xfb1075b8>
811287b8:	d8002e15 	stw	zero,184(sp)
811287bc:	dc001e04 	addi	r16,sp,120
811287c0:	003a4d06 	br	811270f8 <__reset+0xfb1070f8>
811287c4:	8c7fff84 	addi	r17,r17,-2
811287c8:	b5bfffc4 	addi	r22,r22,-1
811287cc:	dd802615 	stw	r22,152(sp)
811287d0:	dc4022c5 	stb	r17,139(sp)
811287d4:	b000bf16 	blt	r22,zero,81128ad4 <___vfprintf_internal_r+0x2100>
811287d8:	00800ac4 	movi	r2,43
811287dc:	d8802305 	stb	r2,140(sp)
811287e0:	00800244 	movi	r2,9
811287e4:	15807016 	blt	r2,r22,811289a8 <___vfprintf_internal_r+0x1fd4>
811287e8:	00800c04 	movi	r2,48
811287ec:	b5800c04 	addi	r22,r22,48
811287f0:	d8802345 	stb	r2,141(sp)
811287f4:	dd802385 	stb	r22,142(sp)
811287f8:	d88023c4 	addi	r2,sp,143
811287fc:	df0022c4 	addi	fp,sp,139
81128800:	d8c03317 	ldw	r3,204(sp)
81128804:	1739c83a 	sub	fp,r2,fp
81128808:	d9003317 	ldw	r4,204(sp)
8112880c:	e0c7883a 	add	r3,fp,r3
81128810:	df003a15 	stw	fp,232(sp)
81128814:	d8c02e15 	stw	r3,184(sp)
81128818:	00800044 	movi	r2,1
8112881c:	1100b30e 	bge	r2,r4,81128aec <___vfprintf_internal_r+0x2118>
81128820:	d8c02e17 	ldw	r3,184(sp)
81128824:	18c00044 	addi	r3,r3,1
81128828:	d8c02e15 	stw	r3,184(sp)
8112882c:	1805883a 	mov	r2,r3
81128830:	1800ac16 	blt	r3,zero,81128ae4 <___vfprintf_internal_r+0x2110>
81128834:	d8003215 	stw	zero,200(sp)
81128838:	003e5d06 	br	811281b0 <__reset+0xfb1081b0>
8112883c:	d9002c17 	ldw	r4,176(sp)
81128840:	d9801e04 	addi	r6,sp,120
81128844:	b80b883a 	mov	r5,r23
81128848:	1132bc40 	call	81132bc4 <__sprint_r>
8112884c:	1039651e 	bne	r2,zero,81126de4 <__reset+0xfb106de4>
81128850:	dc402617 	ldw	r17,152(sp)
81128854:	d8c02017 	ldw	r3,128(sp)
81128858:	d8801f17 	ldw	r2,124(sp)
8112885c:	da000404 	addi	r8,sp,16
81128860:	003ed606 	br	811283bc <__reset+0xfb1083bc>
81128864:	582b883a 	mov	r21,r11
81128868:	d8002915 	stw	zero,164(sp)
8112886c:	0038bd06 	br	81126b64 <__reset+0xfb106b64>
81128870:	d8802917 	ldw	r2,164(sp)
81128874:	103e071e 	bne	r2,zero,81128094 <__reset+0xfb108094>
81128878:	dc002915 	stw	r16,164(sp)
8112887c:	003e0506 	br	81128094 <__reset+0xfb108094>
81128880:	d9002917 	ldw	r4,164(sp)
81128884:	20c00044 	addi	r3,r4,1
81128888:	003e0f06 	br	811280c8 <__reset+0xfb1080c8>
8112888c:	01400184 	movi	r5,6
81128890:	d9402915 	stw	r5,164(sp)
81128894:	003dff06 	br	81128094 <__reset+0xfb108094>
81128898:	d8802104 	addi	r2,sp,132
8112889c:	d8800315 	stw	r2,12(sp)
811288a0:	d8802504 	addi	r2,sp,148
811288a4:	d8800215 	stw	r2,8(sp)
811288a8:	d8802604 	addi	r2,sp,152
811288ac:	d8800115 	stw	r2,4(sp)
811288b0:	d8802917 	ldw	r2,164(sp)
811288b4:	d9403617 	ldw	r5,216(sp)
811288b8:	d9002c17 	ldw	r4,176(sp)
811288bc:	d8800015 	stw	r2,0(sp)
811288c0:	01c000c4 	movi	r7,3
811288c4:	980d883a 	mov	r6,r19
811288c8:	da003d15 	stw	r8,244(sp)
811288cc:	112aae00 	call	8112aae0 <_dtoa_r>
811288d0:	d8c02917 	ldw	r3,164(sp)
811288d4:	da003d17 	ldw	r8,244(sp)
811288d8:	1021883a 	mov	r16,r2
811288dc:	10f9883a 	add	fp,r2,r3
811288e0:	81000007 	ldb	r4,0(r16)
811288e4:	00800c04 	movi	r2,48
811288e8:	20805e26 	beq	r4,r2,81128a64 <___vfprintf_internal_r+0x2090>
811288ec:	d8c02617 	ldw	r3,152(sp)
811288f0:	e0f9883a 	add	fp,fp,r3
811288f4:	003e0a06 	br	81128120 <__reset+0xfb108120>
811288f8:	00c00b44 	movi	r3,45
811288fc:	24e0003c 	xorhi	r19,r4,32768
81128900:	d8c02a05 	stb	r3,168(sp)
81128904:	003de906 	br	811280ac <__reset+0xfb1080ac>
81128908:	d8c03217 	ldw	r3,200(sp)
8112890c:	00c07a0e 	bge	zero,r3,81128af8 <___vfprintf_internal_r+0x2124>
81128910:	00800044 	movi	r2,1
81128914:	d9003317 	ldw	r4,204(sp)
81128918:	1105883a 	add	r2,r2,r4
8112891c:	d8802e15 	stw	r2,184(sp)
81128920:	10004e16 	blt	r2,zero,81128a5c <___vfprintf_internal_r+0x2088>
81128924:	044019c4 	movi	r17,103
81128928:	003e2106 	br	811281b0 <__reset+0xfb1081b0>
8112892c:	d9002917 	ldw	r4,164(sp)
81128930:	d8802104 	addi	r2,sp,132
81128934:	d8800315 	stw	r2,12(sp)
81128938:	d9000015 	stw	r4,0(sp)
8112893c:	d8802504 	addi	r2,sp,148
81128940:	d9403617 	ldw	r5,216(sp)
81128944:	d9002c17 	ldw	r4,176(sp)
81128948:	d8800215 	stw	r2,8(sp)
8112894c:	d8802604 	addi	r2,sp,152
81128950:	d8800115 	stw	r2,4(sp)
81128954:	01c000c4 	movi	r7,3
81128958:	980d883a 	mov	r6,r19
8112895c:	da003d15 	stw	r8,244(sp)
81128960:	112aae00 	call	8112aae0 <_dtoa_r>
81128964:	d8c02917 	ldw	r3,164(sp)
81128968:	da003d17 	ldw	r8,244(sp)
8112896c:	1021883a 	mov	r16,r2
81128970:	00801184 	movi	r2,70
81128974:	80f9883a 	add	fp,r16,r3
81128978:	88bfd926 	beq	r17,r2,811288e0 <__reset+0xfb1088e0>
8112897c:	003de806 	br	81128120 <__reset+0xfb108120>
81128980:	d9002917 	ldw	r4,164(sp)
81128984:	00c04d0e 	bge	zero,r3,81128abc <___vfprintf_internal_r+0x20e8>
81128988:	2000441e 	bne	r4,zero,81128a9c <___vfprintf_internal_r+0x20c8>
8112898c:	9480004c 	andi	r18,r18,1
81128990:	9000421e 	bne	r18,zero,81128a9c <___vfprintf_internal_r+0x20c8>
81128994:	1805883a 	mov	r2,r3
81128998:	18007016 	blt	r3,zero,81128b5c <___vfprintf_internal_r+0x2188>
8112899c:	d8c03217 	ldw	r3,200(sp)
811289a0:	d8c02e15 	stw	r3,184(sp)
811289a4:	003e0206 	br	811281b0 <__reset+0xfb1081b0>
811289a8:	df0022c4 	addi	fp,sp,139
811289ac:	dc002915 	stw	r16,164(sp)
811289b0:	4027883a 	mov	r19,r8
811289b4:	e021883a 	mov	r16,fp
811289b8:	b009883a 	mov	r4,r22
811289bc:	01400284 	movi	r5,10
811289c0:	1135ec00 	call	81135ec0 <__modsi3>
811289c4:	10800c04 	addi	r2,r2,48
811289c8:	843fffc4 	addi	r16,r16,-1
811289cc:	b009883a 	mov	r4,r22
811289d0:	01400284 	movi	r5,10
811289d4:	80800005 	stb	r2,0(r16)
811289d8:	1135e3c0 	call	81135e3c <__divsi3>
811289dc:	102d883a 	mov	r22,r2
811289e0:	00800244 	movi	r2,9
811289e4:	15bff416 	blt	r2,r22,811289b8 <__reset+0xfb1089b8>
811289e8:	9811883a 	mov	r8,r19
811289ec:	b0800c04 	addi	r2,r22,48
811289f0:	8027883a 	mov	r19,r16
811289f4:	997fffc4 	addi	r5,r19,-1
811289f8:	98bfffc5 	stb	r2,-1(r19)
811289fc:	dc002917 	ldw	r16,164(sp)
81128a00:	2f006a2e 	bgeu	r5,fp,81128bac <___vfprintf_internal_r+0x21d8>
81128a04:	d9c02384 	addi	r7,sp,142
81128a08:	3ccfc83a 	sub	r7,r7,r19
81128a0c:	d9002344 	addi	r4,sp,141
81128a10:	e1cf883a 	add	r7,fp,r7
81128a14:	00000106 	br	81128a1c <___vfprintf_internal_r+0x2048>
81128a18:	28800003 	ldbu	r2,0(r5)
81128a1c:	20800005 	stb	r2,0(r4)
81128a20:	21000044 	addi	r4,r4,1
81128a24:	29400044 	addi	r5,r5,1
81128a28:	393ffb1e 	bne	r7,r4,81128a18 <__reset+0xfb108a18>
81128a2c:	d8802304 	addi	r2,sp,140
81128a30:	14c5c83a 	sub	r2,r2,r19
81128a34:	d8c02344 	addi	r3,sp,141
81128a38:	1885883a 	add	r2,r3,r2
81128a3c:	003f7006 	br	81128800 <__reset+0xfb108800>
81128a40:	0005883a 	mov	r2,zero
81128a44:	003f0f06 	br	81128684 <__reset+0xfb108684>
81128a48:	d8c03217 	ldw	r3,200(sp)
81128a4c:	18c00044 	addi	r3,r3,1
81128a50:	d8c02e15 	stw	r3,184(sp)
81128a54:	1805883a 	mov	r2,r3
81128a58:	183fb20e 	bge	r3,zero,81128924 <__reset+0xfb108924>
81128a5c:	0005883a 	mov	r2,zero
81128a60:	003fb006 	br	81128924 <__reset+0xfb108924>
81128a64:	d9003617 	ldw	r4,216(sp)
81128a68:	000d883a 	mov	r6,zero
81128a6c:	000f883a 	mov	r7,zero
81128a70:	980b883a 	mov	r5,r19
81128a74:	d8c03c15 	stw	r3,240(sp)
81128a78:	da003d15 	stw	r8,244(sp)
81128a7c:	11373900 	call	81137390 <__eqdf2>
81128a80:	d8c03c17 	ldw	r3,240(sp)
81128a84:	da003d17 	ldw	r8,244(sp)
81128a88:	103f9826 	beq	r2,zero,811288ec <__reset+0xfb1088ec>
81128a8c:	00800044 	movi	r2,1
81128a90:	10c7c83a 	sub	r3,r2,r3
81128a94:	d8c02615 	stw	r3,152(sp)
81128a98:	003f9506 	br	811288f0 <__reset+0xfb1088f0>
81128a9c:	d9002917 	ldw	r4,164(sp)
81128aa0:	d8c03217 	ldw	r3,200(sp)
81128aa4:	20800044 	addi	r2,r4,1
81128aa8:	1885883a 	add	r2,r3,r2
81128aac:	d8802e15 	stw	r2,184(sp)
81128ab0:	103dbf0e 	bge	r2,zero,811281b0 <__reset+0xfb1081b0>
81128ab4:	0005883a 	mov	r2,zero
81128ab8:	003dbd06 	br	811281b0 <__reset+0xfb1081b0>
81128abc:	2000211e 	bne	r4,zero,81128b44 <___vfprintf_internal_r+0x2170>
81128ac0:	9480004c 	andi	r18,r18,1
81128ac4:	90001f1e 	bne	r18,zero,81128b44 <___vfprintf_internal_r+0x2170>
81128ac8:	00800044 	movi	r2,1
81128acc:	d8802e15 	stw	r2,184(sp)
81128ad0:	003db706 	br	811281b0 <__reset+0xfb1081b0>
81128ad4:	00800b44 	movi	r2,45
81128ad8:	05adc83a 	sub	r22,zero,r22
81128adc:	d8802305 	stb	r2,140(sp)
81128ae0:	003f3f06 	br	811287e0 <__reset+0xfb1087e0>
81128ae4:	0005883a 	mov	r2,zero
81128ae8:	003f5206 	br	81128834 <__reset+0xfb108834>
81128aec:	90a4703a 	and	r18,r18,r2
81128af0:	903f4e26 	beq	r18,zero,8112882c <__reset+0xfb10882c>
81128af4:	003f4a06 	br	81128820 <__reset+0xfb108820>
81128af8:	00800084 	movi	r2,2
81128afc:	10c5c83a 	sub	r2,r2,r3
81128b00:	003f8406 	br	81128914 <__reset+0xfb108914>
81128b04:	d8802d17 	ldw	r2,180(sp)
81128b08:	d9002d17 	ldw	r4,180(sp)
81128b0c:	ac400043 	ldbu	r17,1(r21)
81128b10:	10800017 	ldw	r2,0(r2)
81128b14:	582b883a 	mov	r21,r11
81128b18:	d8802915 	stw	r2,164(sp)
81128b1c:	20800104 	addi	r2,r4,4
81128b20:	d9002917 	ldw	r4,164(sp)
81128b24:	d8802d15 	stw	r2,180(sp)
81128b28:	203e7a0e 	bge	r4,zero,81128514 <__reset+0xfb108514>
81128b2c:	8c403fcc 	andi	r17,r17,255
81128b30:	00bfffc4 	movi	r2,-1
81128b34:	8c40201c 	xori	r17,r17,128
81128b38:	d8802915 	stw	r2,164(sp)
81128b3c:	8c7fe004 	addi	r17,r17,-128
81128b40:	00380706 	br	81126b60 <__reset+0xfb106b60>
81128b44:	d8c02917 	ldw	r3,164(sp)
81128b48:	18c00084 	addi	r3,r3,2
81128b4c:	d8c02e15 	stw	r3,184(sp)
81128b50:	1805883a 	mov	r2,r3
81128b54:	183d960e 	bge	r3,zero,811281b0 <__reset+0xfb1081b0>
81128b58:	003fd606 	br	81128ab4 <__reset+0xfb108ab4>
81128b5c:	0005883a 	mov	r2,zero
81128b60:	003f8e06 	br	8112899c <__reset+0xfb10899c>
81128b64:	9080004c 	andi	r2,r18,1
81128b68:	103f811e 	bne	r2,zero,81128970 <__reset+0xfb108970>
81128b6c:	d8802117 	ldw	r2,132(sp)
81128b70:	1405c83a 	sub	r2,r2,r16
81128b74:	d8803315 	stw	r2,204(sp)
81128b78:	b47ef326 	beq	r22,r17,81128748 <__reset+0xfb108748>
81128b7c:	dd802617 	ldw	r22,152(sp)
81128b80:	003f1106 	br	811287c8 <__reset+0xfb1087c8>
81128b84:	d9c02785 	stb	r7,158(sp)
81128b88:	00390406 	br	81126f9c <__reset+0xfb106f9c>
81128b8c:	d9c02785 	stb	r7,158(sp)
81128b90:	0038d306 	br	81126ee0 <__reset+0xfb106ee0>
81128b94:	d9c02785 	stb	r7,158(sp)
81128b98:	003a6106 	br	81127520 <__reset+0xfb107520>
81128b9c:	d9c02785 	stb	r7,158(sp)
81128ba0:	003af806 	br	81127784 <__reset+0xfb107784>
81128ba4:	0005883a 	mov	r2,zero
81128ba8:	003d7e06 	br	811281a4 <__reset+0xfb1081a4>
81128bac:	d8802344 	addi	r2,sp,141
81128bb0:	003f1306 	br	81128800 <__reset+0xfb108800>
81128bb4:	d9c02785 	stb	r7,158(sp)
81128bb8:	00392306 	br	81127048 <__reset+0xfb107048>
81128bbc:	d9c02785 	stb	r7,158(sp)
81128bc0:	003aa906 	br	81127668 <__reset+0xfb107668>
81128bc4:	d9c02785 	stb	r7,158(sp)
81128bc8:	003a3d06 	br	811274c0 <__reset+0xfb1074c0>
81128bcc:	d9c02785 	stb	r7,158(sp)
81128bd0:	003aca06 	br	811276fc <__reset+0xfb1076fc>

81128bd4 <__vfprintf_internal>:
81128bd4:	00a04574 	movhi	r2,33045
81128bd8:	10911304 	addi	r2,r2,17484
81128bdc:	300f883a 	mov	r7,r6
81128be0:	280d883a 	mov	r6,r5
81128be4:	200b883a 	mov	r5,r4
81128be8:	11000017 	ldw	r4,0(r2)
81128bec:	11269d41 	jmpi	811269d4 <___vfprintf_internal_r>

81128bf0 <__sbprintf>:
81128bf0:	defee204 	addi	sp,sp,-1144
81128bf4:	de00012e 	bgeu	sp,et,81128bfc <__sbprintf+0xc>
81128bf8:	003b68fa 	trap	3
81128bfc:	2880030b 	ldhu	r2,12(r5)
81128c00:	2ac01917 	ldw	r11,100(r5)
81128c04:	2a80038b 	ldhu	r10,14(r5)
81128c08:	2a400717 	ldw	r9,28(r5)
81128c0c:	2a000917 	ldw	r8,36(r5)
81128c10:	00c10004 	movi	r3,1024
81128c14:	dc011a15 	stw	r16,1128(sp)
81128c18:	10bfff4c 	andi	r2,r2,65533
81128c1c:	2821883a 	mov	r16,r5
81128c20:	d8cb883a 	add	r5,sp,r3
81128c24:	dc811c15 	stw	r18,1136(sp)
81128c28:	dc411b15 	stw	r17,1132(sp)
81128c2c:	dfc11d15 	stw	ra,1140(sp)
81128c30:	2025883a 	mov	r18,r4
81128c34:	d881030d 	sth	r2,1036(sp)
81128c38:	dac11915 	stw	r11,1124(sp)
81128c3c:	da81038d 	sth	r10,1038(sp)
81128c40:	da410715 	stw	r9,1052(sp)
81128c44:	da010915 	stw	r8,1060(sp)
81128c48:	dec10015 	stw	sp,1024(sp)
81128c4c:	dec10415 	stw	sp,1040(sp)
81128c50:	d8c10215 	stw	r3,1032(sp)
81128c54:	d8c10515 	stw	r3,1044(sp)
81128c58:	d8010615 	stw	zero,1048(sp)
81128c5c:	11269d40 	call	811269d4 <___vfprintf_internal_r>
81128c60:	1023883a 	mov	r17,r2
81128c64:	10000416 	blt	r2,zero,81128c78 <__sbprintf+0x88>
81128c68:	d9410004 	addi	r5,sp,1024
81128c6c:	9009883a 	mov	r4,r18
81128c70:	112c3940 	call	8112c394 <_fflush_r>
81128c74:	10000d1e 	bne	r2,zero,81128cac <__sbprintf+0xbc>
81128c78:	d881030b 	ldhu	r2,1036(sp)
81128c7c:	1080100c 	andi	r2,r2,64
81128c80:	10000326 	beq	r2,zero,81128c90 <__sbprintf+0xa0>
81128c84:	8080030b 	ldhu	r2,12(r16)
81128c88:	10801014 	ori	r2,r2,64
81128c8c:	8080030d 	sth	r2,12(r16)
81128c90:	8805883a 	mov	r2,r17
81128c94:	dfc11d17 	ldw	ra,1140(sp)
81128c98:	dc811c17 	ldw	r18,1136(sp)
81128c9c:	dc411b17 	ldw	r17,1132(sp)
81128ca0:	dc011a17 	ldw	r16,1128(sp)
81128ca4:	dec11e04 	addi	sp,sp,1144
81128ca8:	f800283a 	ret
81128cac:	047fffc4 	movi	r17,-1
81128cb0:	003ff106 	br	81128c78 <__reset+0xfb108c78>

81128cb4 <__svfscanf_r>:
81128cb4:	deff4b04 	addi	sp,sp,-724
81128cb8:	de00012e 	bgeu	sp,et,81128cc0 <__svfscanf_r+0xc>
81128cbc:	003b68fa 	trap	3
81128cc0:	2880030b 	ldhu	r2,12(r5)
81128cc4:	df00b315 	stw	fp,716(sp)
81128cc8:	dd80b115 	stw	r22,708(sp)
81128ccc:	dfc0b415 	stw	ra,720(sp)
81128cd0:	ddc0b215 	stw	r23,712(sp)
81128cd4:	dd40b015 	stw	r21,704(sp)
81128cd8:	dd00af15 	stw	r20,700(sp)
81128cdc:	dcc0ae15 	stw	r19,696(sp)
81128ce0:	dc80ad15 	stw	r18,692(sp)
81128ce4:	dc40ac15 	stw	r17,688(sp)
81128ce8:	dc00ab15 	stw	r16,684(sp)
81128cec:	10c8000c 	andi	r3,r2,8192
81128cf0:	d9c09c15 	stw	r7,624(sp)
81128cf4:	2839883a 	mov	fp,r5
81128cf8:	202d883a 	mov	r22,r4
81128cfc:	1800061e 	bne	r3,zero,81128d18 <__svfscanf_r+0x64>
81128d00:	29001917 	ldw	r4,100(r5)
81128d04:	00f7ffc4 	movi	r3,-8193
81128d08:	10880014 	ori	r2,r2,8192
81128d0c:	20c6703a 	and	r3,r4,r3
81128d10:	2880030d 	sth	r2,12(r5)
81128d14:	28c01915 	stw	r3,100(r5)
81128d18:	30800003 	ldbu	r2,0(r6)
81128d1c:	0021883a 	mov	r16,zero
81128d20:	05e04574 	movhi	r23,33045
81128d24:	d800a115 	stw	zero,644(sp)
81128d28:	d8009e15 	stw	zero,632(sp)
81128d2c:	d800a015 	stw	zero,640(sp)
81128d30:	d8809b15 	stw	r2,620(sp)
81128d34:	bdd11104 	addi	r23,r23,17476
81128d38:	8025883a 	mov	r18,r16
81128d3c:	35000044 	addi	r20,r6,1
81128d40:	10001e26 	beq	r2,zero,81128dbc <__svfscanf_r+0x108>
81128d44:	b9c00017 	ldw	r7,0(r23)
81128d48:	3887883a 	add	r3,r7,r2
81128d4c:	18c00043 	ldbu	r3,1(r3)
81128d50:	18c0020c 	andi	r3,r3,8
81128d54:	18001b26 	beq	r3,zero,81128dc4 <__svfscanf_r+0x110>
81128d58:	e0800117 	ldw	r2,4(fp)
81128d5c:	00800e0e 	bge	zero,r2,81128d98 <__svfscanf_r+0xe4>
81128d60:	e0c00017 	ldw	r3,0(fp)
81128d64:	b9000017 	ldw	r4,0(r23)
81128d68:	18800003 	ldbu	r2,0(r3)
81128d6c:	2085883a 	add	r2,r4,r2
81128d70:	10800043 	ldbu	r2,1(r2)
81128d74:	1080020c 	andi	r2,r2,8
81128d78:	10000b26 	beq	r2,zero,81128da8 <__svfscanf_r+0xf4>
81128d7c:	e0800117 	ldw	r2,4(fp)
81128d80:	18c00044 	addi	r3,r3,1
81128d84:	e0c00015 	stw	r3,0(fp)
81128d88:	10bfffc4 	addi	r2,r2,-1
81128d8c:	e0800115 	stw	r2,4(fp)
81128d90:	94800044 	addi	r18,r18,1
81128d94:	00bff216 	blt	zero,r2,81128d60 <__reset+0xfb108d60>
81128d98:	e00b883a 	mov	r5,fp
81128d9c:	b009883a 	mov	r4,r22
81128da0:	1123f940 	call	81123f94 <__srefill_r>
81128da4:	103fee26 	beq	r2,zero,81128d60 <__reset+0xfb108d60>
81128da8:	a00d883a 	mov	r6,r20
81128dac:	30800003 	ldbu	r2,0(r6)
81128db0:	35000044 	addi	r20,r6,1
81128db4:	d8809b15 	stw	r2,620(sp)
81128db8:	103fe21e 	bne	r2,zero,81128d44 <__reset+0xfb108d44>
81128dbc:	d880a017 	ldw	r2,640(sp)
81128dc0:	00009906 	br	81129028 <__svfscanf_r+0x374>
81128dc4:	00c00944 	movi	r3,37
81128dc8:	10c0881e 	bne	r2,r3,81128fec <__svfscanf_r+0x338>
81128dcc:	30c00043 	ldbu	r3,1(r6)
81128dd0:	0023883a 	mov	r17,zero
81128dd4:	0027883a 	mov	r19,zero
81128dd8:	01001e04 	movi	r4,120
81128ddc:	01401b04 	movi	r5,108
81128de0:	a1800044 	addi	r6,r20,1
81128de4:	20c0a236 	bltu	r4,r3,81129070 <__svfscanf_r+0x3bc>
81128de8:	180490ba 	slli	r2,r3,2
81128dec:	022044f4 	movhi	r8,33043
81128df0:	42238004 	addi	r8,r8,-29184
81128df4:	1205883a 	add	r2,r2,r8
81128df8:	10800017 	ldw	r2,0(r2)
81128dfc:	1000683a 	jmp	r2
81128e00:	81129024 	muli	r4,r16,19008
81128e04:	81129070 	cmpltui	r4,r16,19009
81128e08:	81129070 	cmpltui	r4,r16,19009
81128e0c:	81129070 	cmpltui	r4,r16,19009
81128e10:	81129070 	cmpltui	r4,r16,19009
81128e14:	81129070 	cmpltui	r4,r16,19009
81128e18:	81129070 	cmpltui	r4,r16,19009
81128e1c:	81129070 	cmpltui	r4,r16,19009
81128e20:	81129070 	cmpltui	r4,r16,19009
81128e24:	81129070 	cmpltui	r4,r16,19009
81128e28:	81129070 	cmpltui	r4,r16,19009
81128e2c:	81129070 	cmpltui	r4,r16,19009
81128e30:	81129070 	cmpltui	r4,r16,19009
81128e34:	81129070 	cmpltui	r4,r16,19009
81128e38:	81129070 	cmpltui	r4,r16,19009
81128e3c:	81129070 	cmpltui	r4,r16,19009
81128e40:	81129070 	cmpltui	r4,r16,19009
81128e44:	81129070 	cmpltui	r4,r16,19009
81128e48:	81129070 	cmpltui	r4,r16,19009
81128e4c:	81129070 	cmpltui	r4,r16,19009
81128e50:	81129070 	cmpltui	r4,r16,19009
81128e54:	81129070 	cmpltui	r4,r16,19009
81128e58:	81129070 	cmpltui	r4,r16,19009
81128e5c:	81129070 	cmpltui	r4,r16,19009
81128e60:	81129070 	cmpltui	r4,r16,19009
81128e64:	81129070 	cmpltui	r4,r16,19009
81128e68:	81129070 	cmpltui	r4,r16,19009
81128e6c:	81129070 	cmpltui	r4,r16,19009
81128e70:	81129070 	cmpltui	r4,r16,19009
81128e74:	81129070 	cmpltui	r4,r16,19009
81128e78:	81129070 	cmpltui	r4,r16,19009
81128e7c:	81129070 	cmpltui	r4,r16,19009
81128e80:	81129070 	cmpltui	r4,r16,19009
81128e84:	81129070 	cmpltui	r4,r16,19009
81128e88:	81129070 	cmpltui	r4,r16,19009
81128e8c:	81129070 	cmpltui	r4,r16,19009
81128e90:	81129070 	cmpltui	r4,r16,19009
81128e94:	81128fe4 	muli	r4,r16,19007
81128e98:	81129070 	cmpltui	r4,r16,19009
81128e9c:	81129070 	cmpltui	r4,r16,19009
81128ea0:	81129070 	cmpltui	r4,r16,19009
81128ea4:	81129070 	cmpltui	r4,r16,19009
81128ea8:	81129058 	cmpnei	r4,r16,19009
81128eac:	81129070 	cmpltui	r4,r16,19009
81128eb0:	81129070 	cmpltui	r4,r16,19009
81128eb4:	81129070 	cmpltui	r4,r16,19009
81128eb8:	81129070 	cmpltui	r4,r16,19009
81128ebc:	81129070 	cmpltui	r4,r16,19009
81128ec0:	8112918c 	andi	r4,r16,19014
81128ec4:	8112918c 	andi	r4,r16,19014
81128ec8:	8112918c 	andi	r4,r16,19014
81128ecc:	8112918c 	andi	r4,r16,19014
81128ed0:	8112918c 	andi	r4,r16,19014
81128ed4:	8112918c 	andi	r4,r16,19014
81128ed8:	8112918c 	andi	r4,r16,19014
81128edc:	8112918c 	andi	r4,r16,19014
81128ee0:	8112918c 	andi	r4,r16,19014
81128ee4:	8112918c 	andi	r4,r16,19014
81128ee8:	81129070 	cmpltui	r4,r16,19009
81128eec:	81129070 	cmpltui	r4,r16,19009
81128ef0:	81129070 	cmpltui	r4,r16,19009
81128ef4:	81129070 	cmpltui	r4,r16,19009
81128ef8:	81129070 	cmpltui	r4,r16,19009
81128efc:	81129070 	cmpltui	r4,r16,19009
81128f00:	81129070 	cmpltui	r4,r16,19009
81128f04:	81129070 	cmpltui	r4,r16,19009
81128f08:	81129070 	cmpltui	r4,r16,19009
81128f0c:	81129070 	cmpltui	r4,r16,19009
81128f10:	81129160 	cmpeqi	r4,r16,19013
81128f14:	81129210 	cmplti	r4,r16,19016
81128f18:	81129070 	cmpltui	r4,r16,19009
81128f1c:	81129210 	cmplti	r4,r16,19016
81128f20:	81129070 	cmpltui	r4,r16,19009
81128f24:	81129070 	cmpltui	r4,r16,19009
81128f28:	81129070 	cmpltui	r4,r16,19009
81128f2c:	81129070 	cmpltui	r4,r16,19009
81128f30:	811291fc 	xorhi	r4,r16,19015
81128f34:	81129070 	cmpltui	r4,r16,19009
81128f38:	81129070 	cmpltui	r4,r16,19009
81128f3c:	811291d0 	cmplti	r4,r16,19015
81128f40:	81129070 	cmpltui	r4,r16,19009
81128f44:	81129070 	cmpltui	r4,r16,19009
81128f48:	81129070 	cmpltui	r4,r16,19009
81128f4c:	81129070 	cmpltui	r4,r16,19009
81128f50:	81129070 	cmpltui	r4,r16,19009
81128f54:	81129070 	cmpltui	r4,r16,19009
81128f58:	81129070 	cmpltui	r4,r16,19009
81128f5c:	81129070 	cmpltui	r4,r16,19009
81128f60:	811291a8 	cmpgeui	r4,r16,19014
81128f64:	81129070 	cmpltui	r4,r16,19009
81128f68:	81129070 	cmpltui	r4,r16,19009
81128f6c:	81129344 	addi	r4,r16,19021
81128f70:	81129070 	cmpltui	r4,r16,19009
81128f74:	81129070 	cmpltui	r4,r16,19009
81128f78:	81129070 	cmpltui	r4,r16,19009
81128f7c:	81129070 	cmpltui	r4,r16,19009
81128f80:	81129070 	cmpltui	r4,r16,19009
81128f84:	81129070 	cmpltui	r4,r16,19009
81128f88:	81129070 	cmpltui	r4,r16,19009
81128f8c:	811292c8 	cmpgei	r4,r16,19019
81128f90:	811292a0 	cmpeqi	r4,r16,19018
81128f94:	81129210 	cmplti	r4,r16,19016
81128f98:	81129210 	cmplti	r4,r16,19016
81128f9c:	81129210 	cmplti	r4,r16,19016
81128fa0:	8112928c 	andi	r4,r16,19018
81128fa4:	811293d0 	cmplti	r4,r16,19023
81128fa8:	81129070 	cmpltui	r4,r16,19009
81128fac:	81129070 	cmpltui	r4,r16,19009
81128fb0:	81129278 	rdprs	r4,r16,19017
81128fb4:	81129070 	cmpltui	r4,r16,19009
81128fb8:	81129248 	cmpgei	r4,r16,19017
81128fbc:	81129224 	muli	r4,r16,19016
81128fc0:	81129134 	orhi	r4,r16,19012
81128fc4:	81129070 	cmpltui	r4,r16,19009
81128fc8:	81129070 	cmpltui	r4,r16,19009
81128fcc:	81129120 	cmpeqi	r4,r16,19012
81128fd0:	81129070 	cmpltui	r4,r16,19009
81128fd4:	811290a8 	cmpgeui	r4,r16,19010
81128fd8:	81129070 	cmpltui	r4,r16,19009
81128fdc:	81129070 	cmpltui	r4,r16,19009
81128fe0:	811291a8 	cmpgeui	r4,r16,19014
81128fe4:	d9809d15 	stw	r6,628(sp)
81128fe8:	3029883a 	mov	r20,r6
81128fec:	e0800117 	ldw	r2,4(fp)
81128ff0:	0081aa0e 	bge	zero,r2,8112969c <__svfscanf_r+0x9e8>
81128ff4:	e0800017 	ldw	r2,0(fp)
81128ff8:	a0ffffc3 	ldbu	r3,-1(r20)
81128ffc:	11000003 	ldbu	r4,0(r2)
81129000:	20ff6e1e 	bne	r4,r3,81128dbc <__reset+0xfb108dbc>
81129004:	e0c00117 	ldw	r3,4(fp)
81129008:	10800044 	addi	r2,r2,1
8112900c:	e0800015 	stw	r2,0(fp)
81129010:	18bfffc4 	addi	r2,r3,-1
81129014:	e0800115 	stw	r2,4(fp)
81129018:	94800044 	addi	r18,r18,1
8112901c:	a00d883a 	mov	r6,r20
81129020:	003f6206 	br	81128dac <__reset+0xfb108dac>
81129024:	00bfffc4 	movi	r2,-1
81129028:	dfc0b417 	ldw	ra,720(sp)
8112902c:	df00b317 	ldw	fp,716(sp)
81129030:	ddc0b217 	ldw	r23,712(sp)
81129034:	dd80b117 	ldw	r22,708(sp)
81129038:	dd40b017 	ldw	r21,704(sp)
8112903c:	dd00af17 	ldw	r20,700(sp)
81129040:	dcc0ae17 	ldw	r19,696(sp)
81129044:	dc80ad17 	ldw	r18,692(sp)
81129048:	dc40ac17 	ldw	r17,688(sp)
8112904c:	dc00ab17 	ldw	r16,684(sp)
81129050:	dec0b504 	addi	sp,sp,724
81129054:	f800283a 	ret
81129058:	a0800043 	ldbu	r2,1(r20)
8112905c:	3029883a 	mov	r20,r6
81129060:	8c400414 	ori	r17,r17,16
81129064:	10c03fcc 	andi	r3,r2,255
81129068:	a1800044 	addi	r6,r20,1
8112906c:	20ff5e2e 	bgeu	r4,r3,81128de8 <__reset+0xfb108de8>
81129070:	38c7883a 	add	r3,r7,r3
81129074:	18800043 	ldbu	r2,1(r3)
81129078:	d9809d15 	stw	r6,628(sp)
8112907c:	00c00044 	movi	r3,1
81129080:	108000cc 	andi	r2,r2,3
81129084:	10c18f26 	beq	r2,r3,811296c4 <__svfscanf_r+0xa10>
81129088:	e0800117 	ldw	r2,4(fp)
8112908c:	00808716 	blt	zero,r2,811292ac <__svfscanf_r+0x5f8>
81129090:	e00b883a 	mov	r5,fp
81129094:	b009883a 	mov	r4,r22
81129098:	1123f940 	call	81123f94 <__srefill_r>
8112909c:	1001431e 	bne	r2,zero,811295ac <__svfscanf_r+0x8f8>
811290a0:	b9c00017 	ldw	r7,0(r23)
811290a4:	00008106 	br	811292ac <__svfscanf_r+0x5f8>
811290a8:	e0800117 	ldw	r2,4(fp)
811290ac:	d9809d15 	stw	r6,628(sp)
811290b0:	0081a30e 	bge	zero,r2,81129740 <__svfscanf_r+0xa8c>
811290b4:	00a044f4 	movhi	r2,33043
811290b8:	1083b104 	addi	r2,r2,3780
811290bc:	02000284 	movi	r8,10
811290c0:	d880a115 	stw	r2,644(sp)
811290c4:	da009e15 	stw	r8,632(sp)
811290c8:	050000c4 	movi	r20,3
811290cc:	e0c00017 	ldw	r3,0(fp)
811290d0:	00000206 	br	811290dc <__svfscanf_r+0x428>
811290d4:	18c00044 	addi	r3,r3,1
811290d8:	e0c00015 	stw	r3,0(fp)
811290dc:	19000003 	ldbu	r4,0(r3)
811290e0:	20803fcc 	andi	r2,r4,255
811290e4:	3885883a 	add	r2,r7,r2
811290e8:	10800043 	ldbu	r2,1(r2)
811290ec:	1140020c 	andi	r5,r2,8
811290f0:	2801ab26 	beq	r5,zero,811297a0 <__svfscanf_r+0xaec>
811290f4:	e0800117 	ldw	r2,4(fp)
811290f8:	94800044 	addi	r18,r18,1
811290fc:	10bfffc4 	addi	r2,r2,-1
81129100:	e0800115 	stw	r2,4(fp)
81129104:	00bff316 	blt	zero,r2,811290d4 <__reset+0xfb1090d4>
81129108:	e00b883a 	mov	r5,fp
8112910c:	b009883a 	mov	r4,r22
81129110:	1123f940 	call	81123f94 <__srefill_r>
81129114:	1001251e 	bne	r2,zero,811295ac <__svfscanf_r+0x8f8>
81129118:	b9c00017 	ldw	r7,0(r23)
8112911c:	003feb06 	br	811290cc <__reset+0xfb1090cc>
81129120:	e0800117 	ldw	r2,4(fp)
81129124:	d9809d15 	stw	r6,628(sp)
81129128:	00818b0e 	bge	zero,r2,81129758 <__svfscanf_r+0xaa4>
8112912c:	05000084 	movi	r20,2
81129130:	003fe606 	br	811290cc <__reset+0xfb1090cc>
81129134:	e0800117 	ldw	r2,4(fp)
81129138:	d9809d15 	stw	r6,628(sp)
8112913c:	8c408814 	ori	r17,r17,544
81129140:	00801d0e 	bge	zero,r2,811291b8 <__svfscanf_r+0x504>
81129144:	00a044f4 	movhi	r2,33043
81129148:	1083b104 	addi	r2,r2,3780
8112914c:	02000404 	movi	r8,16
81129150:	d880a115 	stw	r2,644(sp)
81129154:	da009e15 	stw	r8,632(sp)
81129158:	050000c4 	movi	r20,3
8112915c:	003fdb06 	br	811290cc <__reset+0xfb1090cc>
81129160:	e0800117 	ldw	r2,4(fp)
81129164:	d9809d15 	stw	r6,628(sp)
81129168:	8c400054 	ori	r17,r17,1
8112916c:	00bfc80e 	bge	zero,r2,81129090 <__reset+0xfb109090>
81129170:	00e044b4 	movhi	r3,33042
81129174:	18d16604 	addi	r3,r3,17816
81129178:	02000284 	movi	r8,10
8112917c:	d8c0a115 	stw	r3,644(sp)
81129180:	da009e15 	stw	r8,632(sp)
81129184:	050000c4 	movi	r20,3
81129188:	003fd006 	br	811290cc <__reset+0xfb1090cc>
8112918c:	9cc002a4 	muli	r19,r19,10
81129190:	a0800043 	ldbu	r2,1(r20)
81129194:	3029883a 	mov	r20,r6
81129198:	98e7883a 	add	r19,r19,r3
8112919c:	9cfff404 	addi	r19,r19,-48
811291a0:	10c03fcc 	andi	r3,r2,255
811291a4:	003f0e06 	br	81128de0 <__reset+0xfb108de0>
811291a8:	e0800117 	ldw	r2,4(fp)
811291ac:	d9809d15 	stw	r6,628(sp)
811291b0:	8c408014 	ori	r17,r17,512
811291b4:	00bfe316 	blt	zero,r2,81129144 <__reset+0xfb109144>
811291b8:	e00b883a 	mov	r5,fp
811291bc:	b009883a 	mov	r4,r22
811291c0:	1123f940 	call	81123f94 <__srefill_r>
811291c4:	1000f91e 	bne	r2,zero,811295ac <__svfscanf_r+0x8f8>
811291c8:	b9c00017 	ldw	r7,0(r23)
811291cc:	003fdd06 	br	81129144 <__reset+0xfb109144>
811291d0:	e0800117 	ldw	r2,4(fp)
811291d4:	d9809d15 	stw	r6,628(sp)
811291d8:	8c400054 	ori	r17,r17,1
811291dc:	0080140e 	bge	zero,r2,81129230 <__svfscanf_r+0x57c>
811291e0:	00a044f4 	movhi	r2,33043
811291e4:	1083b104 	addi	r2,r2,3780
811291e8:	02000204 	movi	r8,8
811291ec:	d880a115 	stw	r2,644(sp)
811291f0:	da009e15 	stw	r8,632(sp)
811291f4:	050000c4 	movi	r20,3
811291f8:	003fb406 	br	811290cc <__reset+0xfb1090cc>
811291fc:	a0800043 	ldbu	r2,1(r20)
81129200:	8c400094 	ori	r17,r17,2
81129204:	3029883a 	mov	r20,r6
81129208:	10c03fcc 	andi	r3,r2,255
8112920c:	003ef406 	br	81128de0 <__reset+0xfb108de0>
81129210:	e0800117 	ldw	r2,4(fp)
81129214:	d9809d15 	stw	r6,628(sp)
81129218:	0081420e 	bge	zero,r2,81129724 <__svfscanf_r+0xa70>
8112921c:	05000104 	movi	r20,4
81129220:	003faa06 	br	811290cc <__reset+0xfb1090cc>
81129224:	e0800117 	ldw	r2,4(fp)
81129228:	d9809d15 	stw	r6,628(sp)
8112922c:	00bfec16 	blt	zero,r2,811291e0 <__reset+0xfb1091e0>
81129230:	e00b883a 	mov	r5,fp
81129234:	b009883a 	mov	r4,r22
81129238:	1123f940 	call	81123f94 <__srefill_r>
8112923c:	1000db1e 	bne	r2,zero,811295ac <__svfscanf_r+0x8f8>
81129240:	b9c00017 	ldw	r7,0(r23)
81129244:	003fe606 	br	811291e0 <__reset+0xfb1091e0>
81129248:	d9809d15 	stw	r6,628(sp)
8112924c:	8880040c 	andi	r2,r17,16
81129250:	10009c1e 	bne	r2,zero,811294c4 <__svfscanf_r+0x810>
81129254:	8880010c 	andi	r2,r17,4
81129258:	10011e26 	beq	r2,zero,811296d4 <__svfscanf_r+0xa20>
8112925c:	da009c17 	ldw	r8,624(sp)
81129260:	3029883a 	mov	r20,r6
81129264:	40800017 	ldw	r2,0(r8)
81129268:	42000104 	addi	r8,r8,4
8112926c:	da009c15 	stw	r8,624(sp)
81129270:	1480000d 	sth	r18,0(r2)
81129274:	003ecc06 	br	81128da8 <__reset+0xfb108da8>
81129278:	a0c00043 	ldbu	r3,1(r20)
8112927c:	19410c26 	beq	r3,r5,811296b0 <__svfscanf_r+0x9fc>
81129280:	8c400054 	ori	r17,r17,1
81129284:	3029883a 	mov	r20,r6
81129288:	003ed506 	br	81128de0 <__reset+0xfb108de0>
8112928c:	a0800043 	ldbu	r2,1(r20)
81129290:	8c400114 	ori	r17,r17,4
81129294:	3029883a 	mov	r20,r6
81129298:	10c03fcc 	andi	r3,r2,255
8112929c:	003ed006 	br	81128de0 <__reset+0xfb108de0>
811292a0:	e0800117 	ldw	r2,4(fp)
811292a4:	d9809d15 	stw	r6,628(sp)
811292a8:	00bf790e 	bge	zero,r2,81129090 <__reset+0xfb109090>
811292ac:	00a044b4 	movhi	r2,33042
811292b0:	10916604 	addi	r2,r2,17816
811292b4:	02000284 	movi	r8,10
811292b8:	d880a115 	stw	r2,644(sp)
811292bc:	da009e15 	stw	r8,632(sp)
811292c0:	050000c4 	movi	r20,3
811292c4:	003f8106 	br	811290cc <__reset+0xfb1090cc>
811292c8:	e0800117 	ldw	r2,4(fp)
811292cc:	d9809d15 	stw	r6,628(sp)
811292d0:	0080c40e 	bge	zero,r2,811295e4 <__svfscanf_r+0x930>
811292d4:	9800011e 	bne	r19,zero,811292dc <__svfscanf_r+0x628>
811292d8:	04c00044 	movi	r19,1
811292dc:	8880004c 	andi	r2,r17,1
811292e0:	1000441e 	bne	r2,zero,811293f4 <__svfscanf_r+0x740>
811292e4:	8c40040c 	andi	r17,r17,16
811292e8:	8800da26 	beq	r17,zero,81129654 <__svfscanf_r+0x9a0>
811292ec:	0021883a 	mov	r16,zero
811292f0:	00000806 	br	81129314 <__svfscanf_r+0x660>
811292f4:	1887883a 	add	r3,r3,r2
811292f8:	e00b883a 	mov	r5,fp
811292fc:	b009883a 	mov	r4,r22
81129300:	e0c00015 	stw	r3,0(fp)
81129304:	80a1883a 	add	r16,r16,r2
81129308:	98a7c83a 	sub	r19,r19,r2
8112930c:	1123f940 	call	81123f94 <__srefill_r>
81129310:	1000ca1e 	bne	r2,zero,8112963c <__svfscanf_r+0x988>
81129314:	e0800117 	ldw	r2,4(fp)
81129318:	e0c00017 	ldw	r3,0(fp)
8112931c:	14fff516 	blt	r2,r19,811292f4 <__reset+0xfb1092f4>
81129320:	14c5c83a 	sub	r2,r2,r19
81129324:	1cd5883a 	add	r10,r3,r19
81129328:	84e1883a 	add	r16,r16,r19
8112932c:	e0800115 	stw	r2,4(fp)
81129330:	e2800015 	stw	r10,0(fp)
81129334:	dd009d17 	ldw	r20,628(sp)
81129338:	9425883a 	add	r18,r18,r16
8112933c:	a00d883a 	mov	r6,r20
81129340:	003e9a06 	br	81128dac <__reset+0xfb108dac>
81129344:	300b883a 	mov	r5,r6
81129348:	d9005884 	addi	r4,sp,354
8112934c:	d9809d15 	stw	r6,628(sp)
81129350:	112f29c0 	call	8112f29c <__sccl>
81129354:	1029883a 	mov	r20,r2
81129358:	e0800117 	ldw	r2,4(fp)
8112935c:	0081050e 	bge	zero,r2,81129774 <__svfscanf_r+0xac0>
81129360:	e1000017 	ldw	r4,0(fp)
81129364:	20800003 	ldbu	r2,0(r4)
81129368:	98005926 	beq	r19,zero,811294d0 <__svfscanf_r+0x81c>
8112936c:	8c40040c 	andi	r17,r17,16
81129370:	88005a26 	beq	r17,zero,811294dc <__svfscanf_r+0x828>
81129374:	9823883a 	mov	r17,r19
81129378:	0021883a 	mov	r16,zero
8112937c:	00000106 	br	81129384 <__svfscanf_r+0x6d0>
81129380:	20800003 	ldbu	r2,0(r4)
81129384:	10803fcc 	andi	r2,r2,255
81129388:	d8c05884 	addi	r3,sp,354
8112938c:	1885883a 	add	r2,r3,r2
81129390:	10800007 	ldb	r2,0(r2)
81129394:	1000ad26 	beq	r2,zero,8112964c <__svfscanf_r+0x998>
81129398:	e0800117 	ldw	r2,4(fp)
8112939c:	21000044 	addi	r4,r4,1
811293a0:	84000044 	addi	r16,r16,1
811293a4:	10bfffc4 	addi	r2,r2,-1
811293a8:	e0800115 	stw	r2,4(fp)
811293ac:	e1000015 	stw	r4,0(fp)
811293b0:	84c0a026 	beq	r16,r19,81129634 <__svfscanf_r+0x980>
811293b4:	00bff216 	blt	zero,r2,81129380 <__reset+0xfb109380>
811293b8:	e00b883a 	mov	r5,fp
811293bc:	b009883a 	mov	r4,r22
811293c0:	1123f940 	call	81123f94 <__srefill_r>
811293c4:	10009a1e 	bne	r2,zero,81129630 <__svfscanf_r+0x97c>
811293c8:	e1000017 	ldw	r4,0(fp)
811293cc:	003fec06 	br	81129380 <__reset+0xfb109380>
811293d0:	e0800117 	ldw	r2,4(fp)
811293d4:	d9809d15 	stw	r6,628(sp)
811293d8:	0080eb0e 	bge	zero,r2,81129788 <__svfscanf_r+0xad4>
811293dc:	00a044b4 	movhi	r2,33042
811293e0:	10916604 	addi	r2,r2,17816
811293e4:	d880a115 	stw	r2,644(sp)
811293e8:	d8009e15 	stw	zero,632(sp)
811293ec:	050000c4 	movi	r20,3
811293f0:	003f3606 	br	811290cc <__reset+0xfb1090cc>
811293f4:	dd409904 	addi	r21,sp,612
811293f8:	8c40040c 	andi	r17,r17,16
811293fc:	01800204 	movi	r6,8
81129400:	000b883a 	mov	r5,zero
81129404:	a809883a 	mov	r4,r21
81129408:	dc409f15 	stw	r17,636(sp)
8112940c:	1123b940 	call	81123b94 <memset>
81129410:	dc409f17 	ldw	r17,636(sp)
81129414:	88006e26 	beq	r17,zero,811295d0 <__svfscanf_r+0x91c>
81129418:	0029883a 	mov	r20,zero
8112941c:	0023883a 	mov	r17,zero
81129420:	112d6b80 	call	8112d6b8 <__locale_mb_cur_max>
81129424:	14406126 	beq	r2,r17,811295ac <__svfscanf_r+0x8f8>
81129428:	e0800017 	ldw	r2,0(fp)
8112942c:	e0c00117 	ldw	r3,4(fp)
81129430:	d9000104 	addi	r4,sp,4
81129434:	12000003 	ldbu	r8,0(r2)
81129438:	18ffffc4 	addi	r3,r3,-1
8112943c:	10800044 	addi	r2,r2,1
81129440:	e0c00115 	stw	r3,4(fp)
81129444:	e0800015 	stw	r2,0(fp)
81129448:	8c000044 	addi	r16,r17,1
8112944c:	dd400015 	stw	r21,0(sp)
81129450:	2463883a 	add	r17,r4,r17
81129454:	200d883a 	mov	r6,r4
81129458:	a00b883a 	mov	r5,r20
8112945c:	800f883a 	mov	r7,r16
81129460:	b009883a 	mov	r4,r22
81129464:	8a000005 	stb	r8,0(r17)
81129468:	112d7740 	call	8112d774 <_mbrtowc_r>
8112946c:	017fffc4 	movi	r5,-1
81129470:	11404e26 	beq	r2,r5,811295ac <__svfscanf_r+0x8f8>
81129474:	1000601e 	bne	r2,zero,811295f8 <__svfscanf_r+0x944>
81129478:	da009f17 	ldw	r8,636(sp)
8112947c:	4000641e 	bne	r8,zero,81129610 <__svfscanf_r+0x95c>
81129480:	a0000015 	stw	zero,0(r20)
81129484:	9425883a 	add	r18,r18,r16
81129488:	9967883a 	add	r19,r19,r5
8112948c:	a5000104 	addi	r20,r20,4
81129490:	e0800117 	ldw	r2,4(fp)
81129494:	0023883a 	mov	r17,zero
81129498:	00804b16 	blt	zero,r2,811295c8 <__svfscanf_r+0x914>
8112949c:	e00b883a 	mov	r5,fp
811294a0:	b009883a 	mov	r4,r22
811294a4:	1123f940 	call	81123f94 <__srefill_r>
811294a8:	10004726 	beq	r2,zero,811295c8 <__svfscanf_r+0x914>
811294ac:	88003f1e 	bne	r17,zero,811295ac <__svfscanf_r+0x8f8>
811294b0:	d8c09f17 	ldw	r3,636(sp)
811294b4:	1800031e 	bne	r3,zero,811294c4 <__svfscanf_r+0x810>
811294b8:	da00a017 	ldw	r8,640(sp)
811294bc:	42000044 	addi	r8,r8,1
811294c0:	da00a015 	stw	r8,640(sp)
811294c4:	dd009d17 	ldw	r20,628(sp)
811294c8:	a00d883a 	mov	r6,r20
811294cc:	003e3706 	br	81128dac <__reset+0xfb108dac>
811294d0:	8c40040c 	andi	r17,r17,16
811294d4:	04ffffc4 	movi	r19,-1
811294d8:	883fa61e 	bne	r17,zero,81129374 <__reset+0xfb109374>
811294dc:	da009c17 	ldw	r8,624(sp)
811294e0:	9abfffc4 	addi	r10,r19,-1
811294e4:	44000017 	ldw	r16,0(r8)
811294e8:	44400104 	addi	r17,r8,4
811294ec:	8007883a 	mov	r3,r16
811294f0:	82ab883a 	add	r21,r16,r10
811294f4:	00000306 	br	81129504 <__svfscanf_r+0x850>
811294f8:	e1000017 	ldw	r4,0(fp)
811294fc:	9807883a 	mov	r3,r19
81129500:	20800003 	ldbu	r2,0(r4)
81129504:	10803fcc 	andi	r2,r2,255
81129508:	d9405884 	addi	r5,sp,354
8112950c:	2885883a 	add	r2,r5,r2
81129510:	10800007 	ldb	r2,0(r2)
81129514:	10004b26 	beq	r2,zero,81129644 <__svfscanf_r+0x990>
81129518:	e0800117 	ldw	r2,4(fp)
8112951c:	21400044 	addi	r5,r4,1
81129520:	e1400015 	stw	r5,0(fp)
81129524:	10bfffc4 	addi	r2,r2,-1
81129528:	e0800115 	stw	r2,4(fp)
8112952c:	20800003 	ldbu	r2,0(r4)
81129530:	1cc00044 	addi	r19,r3,1
81129534:	18800005 	stb	r2,0(r3)
81129538:	1d400726 	beq	r3,r21,81129558 <__svfscanf_r+0x8a4>
8112953c:	e0800117 	ldw	r2,4(fp)
81129540:	00bfed16 	blt	zero,r2,811294f8 <__reset+0xfb1094f8>
81129544:	e00b883a 	mov	r5,fp
81129548:	b009883a 	mov	r4,r22
8112954c:	1123f940 	call	81123f94 <__srefill_r>
81129550:	103fe926 	beq	r2,zero,811294f8 <__reset+0xfb1094f8>
81129554:	84c01526 	beq	r16,r19,811295ac <__svfscanf_r+0x8f8>
81129558:	9c21c83a 	sub	r16,r19,r16
8112955c:	803e1726 	beq	r16,zero,81128dbc <__reset+0xfb108dbc>
81129560:	da00a017 	ldw	r8,640(sp)
81129564:	98000005 	stb	zero,0(r19)
81129568:	dc409c15 	stw	r17,624(sp)
8112956c:	42000044 	addi	r8,r8,1
81129570:	da00a015 	stw	r8,640(sp)
81129574:	9425883a 	add	r18,r18,r16
81129578:	a00d883a 	mov	r6,r20
8112957c:	003e0b06 	br	81128dac <__reset+0xfb108dac>
81129580:	017fff84 	movi	r5,-2
81129584:	11439b1e 	bne	r2,r5,8112a3f4 <__svfscanf_r+0x1740>
81129588:	8821883a 	mov	r16,r17
8112958c:	e0800117 	ldw	r2,4(fp)
81129590:	0082e516 	blt	zero,r2,8112a128 <__svfscanf_r+0x1474>
81129594:	e00b883a 	mov	r5,fp
81129598:	b009883a 	mov	r4,r22
8112959c:	1123f940 	call	81123f94 <__srefill_r>
811295a0:	1002e126 	beq	r2,zero,8112a128 <__svfscanf_r+0x1474>
811295a4:	dc409f17 	ldw	r17,636(sp)
811295a8:	8002e826 	beq	r16,zero,8112a14c <__svfscanf_r+0x1498>
811295ac:	da00a017 	ldw	r8,640(sp)
811295b0:	403e9c26 	beq	r8,zero,81129024 <__reset+0xfb109024>
811295b4:	e080030b 	ldhu	r2,12(fp)
811295b8:	1080100c 	andi	r2,r2,64
811295bc:	103e991e 	bne	r2,zero,81129024 <__reset+0xfb109024>
811295c0:	4005883a 	mov	r2,r8
811295c4:	003e9806 	br	81129028 <__reset+0xfb109028>
811295c8:	983f951e 	bne	r19,zero,81129420 <__reset+0xfb109420>
811295cc:	003fb806 	br	811294b0 <__reset+0xfb1094b0>
811295d0:	da009c17 	ldw	r8,624(sp)
811295d4:	45000017 	ldw	r20,0(r8)
811295d8:	42000104 	addi	r8,r8,4
811295dc:	da009c15 	stw	r8,624(sp)
811295e0:	003f8e06 	br	8112941c <__reset+0xfb10941c>
811295e4:	e00b883a 	mov	r5,fp
811295e8:	b009883a 	mov	r4,r22
811295ec:	1123f940 	call	81123f94 <__srefill_r>
811295f0:	103f3826 	beq	r2,zero,811292d4 <__reset+0xfb1092d4>
811295f4:	003fed06 	br	811295ac <__reset+0xfb1095ac>
811295f8:	00ffff84 	movi	r3,-2
811295fc:	10c0071e 	bne	r2,r3,8112961c <__svfscanf_r+0x968>
81129600:	e0800117 	ldw	r2,4(fp)
81129604:	8023883a 	mov	r17,r16
81129608:	00bf8516 	blt	zero,r2,81129420 <__reset+0xfb109420>
8112960c:	003fa306 	br	8112949c <__reset+0xfb10949c>
81129610:	9425883a 	add	r18,r18,r16
81129614:	9cffffc4 	addi	r19,r19,-1
81129618:	003f9d06 	br	81129490 <__reset+0xfb109490>
8112961c:	da009f17 	ldw	r8,636(sp)
81129620:	9425883a 	add	r18,r18,r16
81129624:	9cffffc4 	addi	r19,r19,-1
81129628:	403f9826 	beq	r8,zero,8112948c <__reset+0xfb10948c>
8112962c:	003f9806 	br	81129490 <__reset+0xfb109490>
81129630:	8023883a 	mov	r17,r16
81129634:	8821883a 	mov	r16,r17
81129638:	003fce06 	br	81129574 <__reset+0xfb109574>
8112963c:	803f3d1e 	bne	r16,zero,81129334 <__reset+0xfb109334>
81129640:	003fda06 	br	811295ac <__reset+0xfb1095ac>
81129644:	1827883a 	mov	r19,r3
81129648:	003fc306 	br	81129558 <__reset+0xfb109558>
8112964c:	803fc91e 	bne	r16,zero,81129574 <__reset+0xfb109574>
81129650:	003dda06 	br	81128dbc <__reset+0xfb108dbc>
81129654:	da009c17 	ldw	r8,624(sp)
81129658:	df000015 	stw	fp,0(sp)
8112965c:	980f883a 	mov	r7,r19
81129660:	41400017 	ldw	r5,0(r8)
81129664:	01800044 	movi	r6,1
81129668:	b009883a 	mov	r4,r22
8112966c:	112c88c0 	call	8112c88c <_fread_r>
81129670:	da009c17 	ldw	r8,624(sp)
81129674:	40c00104 	addi	r3,r8,4
81129678:	103fcc26 	beq	r2,zero,811295ac <__reset+0xfb1095ac>
8112967c:	da00a017 	ldw	r8,640(sp)
81129680:	dd009d17 	ldw	r20,628(sp)
81129684:	90a5883a 	add	r18,r18,r2
81129688:	42000044 	addi	r8,r8,1
8112968c:	da00a015 	stw	r8,640(sp)
81129690:	d8c09c15 	stw	r3,624(sp)
81129694:	a00d883a 	mov	r6,r20
81129698:	003dc406 	br	81128dac <__reset+0xfb108dac>
8112969c:	e00b883a 	mov	r5,fp
811296a0:	b009883a 	mov	r4,r22
811296a4:	1123f940 	call	81123f94 <__srefill_r>
811296a8:	103e5226 	beq	r2,zero,81128ff4 <__reset+0xfb108ff4>
811296ac:	003fbf06 	br	811295ac <__reset+0xfb1095ac>
811296b0:	a0800083 	ldbu	r2,2(r20)
811296b4:	8c400094 	ori	r17,r17,2
811296b8:	a5000084 	addi	r20,r20,2
811296bc:	10c03fcc 	andi	r3,r2,255
811296c0:	003dc706 	br	81128de0 <__reset+0xfb108de0>
811296c4:	e0800117 	ldw	r2,4(fp)
811296c8:	88e2b03a 	or	r17,r17,r3
811296cc:	00bef716 	blt	zero,r2,811292ac <__reset+0xfb1092ac>
811296d0:	003e6f06 	br	81129090 <__reset+0xfb109090>
811296d4:	8880004c 	andi	r2,r17,1
811296d8:	10000b1e 	bne	r2,zero,81129708 <__svfscanf_r+0xa54>
811296dc:	8c40008c 	andi	r17,r17,2
811296e0:	88000926 	beq	r17,zero,81129708 <__svfscanf_r+0xa54>
811296e4:	da009c17 	ldw	r8,624(sp)
811296e8:	9007d7fa 	srai	r3,r18,31
811296ec:	dd009d17 	ldw	r20,628(sp)
811296f0:	40800017 	ldw	r2,0(r8)
811296f4:	42000104 	addi	r8,r8,4
811296f8:	da009c15 	stw	r8,624(sp)
811296fc:	14800015 	stw	r18,0(r2)
81129700:	10c00115 	stw	r3,4(r2)
81129704:	003da806 	br	81128da8 <__reset+0xfb108da8>
81129708:	da009c17 	ldw	r8,624(sp)
8112970c:	dd009d17 	ldw	r20,628(sp)
81129710:	40800017 	ldw	r2,0(r8)
81129714:	42000104 	addi	r8,r8,4
81129718:	da009c15 	stw	r8,624(sp)
8112971c:	14800015 	stw	r18,0(r2)
81129720:	003da106 	br	81128da8 <__reset+0xfb108da8>
81129724:	e00b883a 	mov	r5,fp
81129728:	b009883a 	mov	r4,r22
8112972c:	1123f940 	call	81123f94 <__srefill_r>
81129730:	103f9e1e 	bne	r2,zero,811295ac <__reset+0xfb1095ac>
81129734:	b9c00017 	ldw	r7,0(r23)
81129738:	05000104 	movi	r20,4
8112973c:	003e6306 	br	811290cc <__reset+0xfb1090cc>
81129740:	e00b883a 	mov	r5,fp
81129744:	b009883a 	mov	r4,r22
81129748:	1123f940 	call	81123f94 <__srefill_r>
8112974c:	103f971e 	bne	r2,zero,811295ac <__reset+0xfb1095ac>
81129750:	b9c00017 	ldw	r7,0(r23)
81129754:	003e5706 	br	811290b4 <__reset+0xfb1090b4>
81129758:	e00b883a 	mov	r5,fp
8112975c:	b009883a 	mov	r4,r22
81129760:	1123f940 	call	81123f94 <__srefill_r>
81129764:	103f911e 	bne	r2,zero,811295ac <__reset+0xfb1095ac>
81129768:	b9c00017 	ldw	r7,0(r23)
8112976c:	05000084 	movi	r20,2
81129770:	003e5606 	br	811290cc <__reset+0xfb1090cc>
81129774:	e00b883a 	mov	r5,fp
81129778:	b009883a 	mov	r4,r22
8112977c:	1123f940 	call	81123f94 <__srefill_r>
81129780:	103ef726 	beq	r2,zero,81129360 <__reset+0xfb109360>
81129784:	003f8906 	br	811295ac <__reset+0xfb1095ac>
81129788:	e00b883a 	mov	r5,fp
8112978c:	b009883a 	mov	r4,r22
81129790:	1123f940 	call	81123f94 <__srefill_r>
81129794:	103f851e 	bne	r2,zero,811295ac <__reset+0xfb1095ac>
81129798:	b9c00017 	ldw	r7,0(r23)
8112979c:	003f0f06 	br	811293dc <__reset+0xfb1093dc>
811297a0:	014000c4 	movi	r5,3
811297a4:	a1414a26 	beq	r20,r5,81129cd0 <__svfscanf_r+0x101c>
811297a8:	01000104 	movi	r4,4
811297ac:	a101f11e 	bne	r20,r4,81129f74 <__svfscanf_r+0x12c0>
811297b0:	b009883a 	mov	r4,r22
811297b4:	112d6dc0 	call	8112d6dc <_localeconv_r>
811297b8:	10800017 	ldw	r2,0(r2)
811297bc:	98ffffc4 	addi	r3,r19,-1
811297c0:	d880a315 	stw	r2,652(sp)
811297c4:	00805704 	movi	r2,348
811297c8:	10c21e2e 	bgeu	r2,r3,8112a044 <__svfscanf_r+0x1390>
811297cc:	9cffa8c4 	addi	r19,r19,-349
811297d0:	dcc0a215 	stw	r19,648(sp)
811297d4:	04c05744 	movi	r19,349
811297d8:	8d01e014 	ori	r20,r17,1920
811297dc:	0023883a 	mov	r17,zero
811297e0:	dc000104 	addi	r16,sp,4
811297e4:	8805883a 	mov	r2,r17
811297e8:	0019883a 	mov	r12,zero
811297ec:	8023883a 	mov	r17,r16
811297f0:	b007883a 	mov	r3,r22
811297f4:	9821883a 	mov	r16,r19
811297f8:	002b883a 	mov	r21,zero
811297fc:	d800a515 	stw	zero,660(sp)
81129800:	d800a415 	stw	zero,656(sp)
81129804:	d8009f15 	stw	zero,636(sp)
81129808:	01c01384 	movi	r7,78
8112980c:	602d883a 	mov	r22,r12
81129810:	1027883a 	mov	r19,r2
81129814:	e1000017 	ldw	r4,0(fp)
81129818:	21400003 	ldbu	r5,0(r4)
8112981c:	28bff544 	addi	r2,r5,-43
81129820:	10803fcc 	andi	r2,r2,255
81129824:	38810e36 	bltu	r7,r2,81129c60 <__svfscanf_r+0xfac>
81129828:	100490ba 	slli	r2,r2,2
8112982c:	01a044f4 	movhi	r6,33043
81129830:	31a61004 	addi	r6,r6,-26560
81129834:	1185883a 	add	r2,r2,r6
81129838:	10800017 	ldw	r2,0(r2)
8112983c:	1000683a 	jmp	r2
81129840:	81129b38 	rdprs	r4,r16,19052
81129844:	81129c60 	cmpeqi	r4,r16,19057
81129848:	81129b38 	rdprs	r4,r16,19052
8112984c:	81129c60 	cmpeqi	r4,r16,19057
81129850:	81129c60 	cmpeqi	r4,r16,19057
81129854:	81129b0c 	andi	r4,r16,19052
81129858:	8112997c 	xorhi	r4,r16,19045
8112985c:	8112997c 	xorhi	r4,r16,19045
81129860:	8112997c 	xorhi	r4,r16,19045
81129864:	8112997c 	xorhi	r4,r16,19045
81129868:	8112997c 	xorhi	r4,r16,19045
8112986c:	8112997c 	xorhi	r4,r16,19045
81129870:	8112997c 	xorhi	r4,r16,19045
81129874:	8112997c 	xorhi	r4,r16,19045
81129878:	8112997c 	xorhi	r4,r16,19045
8112987c:	81129c60 	cmpeqi	r4,r16,19057
81129880:	81129c60 	cmpeqi	r4,r16,19057
81129884:	81129c60 	cmpeqi	r4,r16,19057
81129888:	81129c60 	cmpeqi	r4,r16,19057
8112988c:	81129c60 	cmpeqi	r4,r16,19057
81129890:	81129c60 	cmpeqi	r4,r16,19057
81129894:	81129c60 	cmpeqi	r4,r16,19057
81129898:	81129c50 	cmplti	r4,r16,19057
8112989c:	81129c60 	cmpeqi	r4,r16,19057
811298a0:	81129c60 	cmpeqi	r4,r16,19057
811298a4:	81129c60 	cmpeqi	r4,r16,19057
811298a8:	81129c0c 	andi	r4,r16,19056
811298ac:	81129bf0 	cmpltui	r4,r16,19055
811298b0:	81129c60 	cmpeqi	r4,r16,19057
811298b4:	81129c60 	cmpeqi	r4,r16,19057
811298b8:	81129bbc 	xorhi	r4,r16,19054
811298bc:	81129c60 	cmpeqi	r4,r16,19057
811298c0:	81129c60 	cmpeqi	r4,r16,19057
811298c4:	81129c60 	cmpeqi	r4,r16,19057
811298c8:	81129c60 	cmpeqi	r4,r16,19057
811298cc:	81129b84 	addi	r4,r16,19054
811298d0:	81129c60 	cmpeqi	r4,r16,19057
811298d4:	81129c60 	cmpeqi	r4,r16,19057
811298d8:	81129c60 	cmpeqi	r4,r16,19057
811298dc:	81129c60 	cmpeqi	r4,r16,19057
811298e0:	81129c60 	cmpeqi	r4,r16,19057
811298e4:	81129b68 	cmpgeui	r4,r16,19053
811298e8:	81129c60 	cmpeqi	r4,r16,19057
811298ec:	81129c60 	cmpeqi	r4,r16,19057
811298f0:	81129c60 	cmpeqi	r4,r16,19057
811298f4:	81129c60 	cmpeqi	r4,r16,19057
811298f8:	81129b4c 	andi	r4,r16,19053
811298fc:	81129c60 	cmpeqi	r4,r16,19057
81129900:	81129c60 	cmpeqi	r4,r16,19057
81129904:	81129c60 	cmpeqi	r4,r16,19057
81129908:	81129c60 	cmpeqi	r4,r16,19057
8112990c:	81129c60 	cmpeqi	r4,r16,19057
81129910:	81129c60 	cmpeqi	r4,r16,19057
81129914:	81129c60 	cmpeqi	r4,r16,19057
81129918:	81129c50 	cmplti	r4,r16,19057
8112991c:	81129c60 	cmpeqi	r4,r16,19057
81129920:	81129c60 	cmpeqi	r4,r16,19057
81129924:	81129c60 	cmpeqi	r4,r16,19057
81129928:	81129c0c 	andi	r4,r16,19056
8112992c:	81129bf0 	cmpltui	r4,r16,19055
81129930:	81129c60 	cmpeqi	r4,r16,19057
81129934:	81129c60 	cmpeqi	r4,r16,19057
81129938:	81129bbc 	xorhi	r4,r16,19054
8112993c:	81129c60 	cmpeqi	r4,r16,19057
81129940:	81129c60 	cmpeqi	r4,r16,19057
81129944:	81129c60 	cmpeqi	r4,r16,19057
81129948:	81129c60 	cmpeqi	r4,r16,19057
8112994c:	81129b84 	addi	r4,r16,19054
81129950:	81129c60 	cmpeqi	r4,r16,19057
81129954:	81129c60 	cmpeqi	r4,r16,19057
81129958:	81129c60 	cmpeqi	r4,r16,19057
8112995c:	81129c60 	cmpeqi	r4,r16,19057
81129960:	81129c60 	cmpeqi	r4,r16,19057
81129964:	81129b68 	cmpgeui	r4,r16,19053
81129968:	81129c60 	cmpeqi	r4,r16,19057
8112996c:	81129c60 	cmpeqi	r4,r16,19057
81129970:	81129c60 	cmpeqi	r4,r16,19057
81129974:	81129c60 	cmpeqi	r4,r16,19057
81129978:	81129b4c 	andi	r4,r16,19053
8112997c:	a8803fcc 	andi	r2,r21,255
81129980:	1080201c 	xori	r2,r2,128
81129984:	10bfe004 	addi	r2,r2,-128
81129988:	b085883a 	add	r2,r22,r2
8112998c:	10000d1e 	bne	r2,zero,811299c4 <__svfscanf_r+0xd10>
81129990:	00bf9fc4 	movi	r2,-385
81129994:	a0a8703a 	and	r20,r20,r2
81129998:	89400005 	stb	r5,0(r17)
8112999c:	8c400044 	addi	r17,r17,1
811299a0:	e0800117 	ldw	r2,4(fp)
811299a4:	843fffc4 	addi	r16,r16,-1
811299a8:	94800044 	addi	r18,r18,1
811299ac:	10bfffc4 	addi	r2,r2,-1
811299b0:	e0800115 	stw	r2,4(fp)
811299b4:	0080b40e 	bge	zero,r2,81129c88 <__svfscanf_r+0xfd4>
811299b8:	21000044 	addi	r4,r4,1
811299bc:	e1000015 	stw	r4,0(fp)
811299c0:	803f941e 	bne	r16,zero,81129814 <__reset+0xfb109814>
811299c4:	8821883a 	mov	r16,r17
811299c8:	b019883a 	mov	r12,r22
811299cc:	9823883a 	mov	r17,r19
811299d0:	182d883a 	mov	r22,r3
811299d4:	9801961e 	bne	r19,zero,8112a030 <__svfscanf_r+0x137c>
811299d8:	633fffc4 	addi	r12,r12,-1
811299dc:	00800044 	movi	r2,1
811299e0:	1302882e 	bgeu	r2,r12,8112a404 <__svfscanf_r+0x1750>
811299e4:	a8803fcc 	andi	r2,r21,255
811299e8:	1080201c 	xori	r2,r2,128
811299ec:	10bfe004 	addi	r2,r2,-128
811299f0:	113fffc4 	addi	r4,r2,-1
811299f4:	01400184 	movi	r5,6
811299f8:	29001136 	bltu	r5,r4,81129a40 <__svfscanf_r+0xd8c>
811299fc:	01000084 	movi	r4,2
81129a00:	2082900e 	bge	r4,r2,8112a444 <__svfscanf_r+0x1790>
81129a04:	00c000c4 	movi	r3,3
81129a08:	10c00d26 	beq	r2,r3,81129a40 <__svfscanf_r+0xd8c>
81129a0c:	9425c83a 	sub	r18,r18,r16
81129a10:	1827883a 	mov	r19,r3
81129a14:	843fffc4 	addi	r16,r16,-1
81129a18:	81400007 	ldb	r5,0(r16)
81129a1c:	e00d883a 	mov	r6,fp
81129a20:	b009883a 	mov	r4,r22
81129a24:	113290c0 	call	8113290c <_ungetc_r>
81129a28:	a8bfffc4 	addi	r2,r21,-1
81129a2c:	10c03fcc 	andi	r3,r2,255
81129a30:	8493883a 	add	r9,r16,r18
81129a34:	102b883a 	mov	r21,r2
81129a38:	98fff636 	bltu	r19,r3,81129a14 <__reset+0xfb109a14>
81129a3c:	4825883a 	mov	r18,r9
81129a40:	a080400c 	andi	r2,r20,256
81129a44:	10001426 	beq	r2,zero,81129a98 <__svfscanf_r+0xde4>
81129a48:	a081000c 	andi	r2,r20,1024
81129a4c:	1002571e 	bne	r2,zero,8112a3ac <__svfscanf_r+0x16f8>
81129a50:	817fffc7 	ldb	r5,-1(r16)
81129a54:	00801944 	movi	r2,101
81129a58:	84ffffc4 	addi	r19,r16,-1
81129a5c:	957fffc4 	addi	r21,r18,-1
81129a60:	28800826 	beq	r5,r2,81129a84 <__svfscanf_r+0xdd0>
81129a64:	00801144 	movi	r2,69
81129a68:	28800626 	beq	r5,r2,81129a84 <__svfscanf_r+0xdd0>
81129a6c:	e00d883a 	mov	r6,fp
81129a70:	b009883a 	mov	r4,r22
81129a74:	113290c0 	call	8113290c <_ungetc_r>
81129a78:	817fff87 	ldb	r5,-2(r16)
81129a7c:	84ffff84 	addi	r19,r16,-2
81129a80:	957fff84 	addi	r21,r18,-2
81129a84:	e00d883a 	mov	r6,fp
81129a88:	b009883a 	mov	r4,r22
81129a8c:	113290c0 	call	8113290c <_ungetc_r>
81129a90:	a825883a 	mov	r18,r21
81129a94:	9821883a 	mov	r16,r19
81129a98:	a080040c 	andi	r2,r20,16
81129a9c:	103e891e 	bne	r2,zero,811294c4 <__reset+0xfb1094c4>
81129aa0:	80000005 	stb	zero,0(r16)
81129aa4:	a081800c 	andi	r2,r20,1536
81129aa8:	01010004 	movi	r4,1024
81129aac:	1101dd26 	beq	r2,r4,8112a224 <__svfscanf_r+0x1570>
81129ab0:	da00a417 	ldw	r8,656(sp)
81129ab4:	4001e71e 	bne	r8,zero,8112a254 <__svfscanf_r+0x15a0>
81129ab8:	000d883a 	mov	r6,zero
81129abc:	d9400104 	addi	r5,sp,4
81129ac0:	b009883a 	mov	r4,r22
81129ac4:	112f4bc0 	call	8112f4bc <_strtod_r>
81129ac8:	1021883a 	mov	r16,r2
81129acc:	a080004c 	andi	r2,r20,1
81129ad0:	1000021e 	bne	r2,zero,81129adc <__svfscanf_r+0xe28>
81129ad4:	a2c0008c 	andi	r11,r20,2
81129ad8:	5801e826 	beq	r11,zero,8112a27c <__svfscanf_r+0x15c8>
81129adc:	da009c17 	ldw	r8,624(sp)
81129ae0:	40800017 	ldw	r2,0(r8)
81129ae4:	42000104 	addi	r8,r8,4
81129ae8:	da009c15 	stw	r8,624(sp)
81129aec:	14000015 	stw	r16,0(r2)
81129af0:	10c00115 	stw	r3,4(r2)
81129af4:	da00a017 	ldw	r8,640(sp)
81129af8:	dd009d17 	ldw	r20,628(sp)
81129afc:	42000044 	addi	r8,r8,1
81129b00:	da00a015 	stw	r8,640(sp)
81129b04:	a00d883a 	mov	r6,r20
81129b08:	003ca806 	br	81128dac <__reset+0xfb108dac>
81129b0c:	a080400c 	andi	r2,r20,256
81129b10:	103f9a26 	beq	r2,zero,8112997c <__reset+0xfb10997c>
81129b14:	da00a217 	ldw	r8,648(sp)
81129b18:	00bfdfc4 	movi	r2,-129
81129b1c:	a0a8703a 	and	r20,r20,r2
81129b20:	9cc00044 	addi	r19,r19,1
81129b24:	403f9e26 	beq	r8,zero,811299a0 <__reset+0xfb1099a0>
81129b28:	423fffc4 	addi	r8,r8,-1
81129b2c:	da00a215 	stw	r8,648(sp)
81129b30:	84000044 	addi	r16,r16,1
81129b34:	003f9a06 	br	811299a0 <__reset+0xfb1099a0>
81129b38:	a080200c 	andi	r2,r20,128
81129b3c:	103fa126 	beq	r2,zero,811299c4 <__reset+0xfb1099c4>
81129b40:	00bfdfc4 	movi	r2,-129
81129b44:	a0a8703a 	and	r20,r20,r2
81129b48:	003f9306 	br	81129998 <__reset+0xfb109998>
81129b4c:	a8803fcc 	andi	r2,r21,255
81129b50:	1080201c 	xori	r2,r2,128
81129b54:	10bfe004 	addi	r2,r2,-128
81129b58:	020001c4 	movi	r8,7
81129b5c:	123f991e 	bne	r2,r8,811299c4 <__reset+0xfb1099c4>
81129b60:	05400204 	movi	r21,8
81129b64:	003f8c06 	br	81129998 <__reset+0xfb109998>
81129b68:	a8803fcc 	andi	r2,r21,255
81129b6c:	1080201c 	xori	r2,r2,128
81129b70:	10bfe004 	addi	r2,r2,-128
81129b74:	01800184 	movi	r6,6
81129b78:	11bf921e 	bne	r2,r6,811299c4 <__reset+0xfb1099c4>
81129b7c:	054001c4 	movi	r21,7
81129b80:	003f8506 	br	81129998 <__reset+0xfb109998>
81129b84:	b000491e 	bne	r22,zero,81129cac <__svfscanf_r+0xff8>
81129b88:	9800031e 	bne	r19,zero,81129b98 <__svfscanf_r+0xee4>
81129b8c:	a081c00c 	andi	r2,r20,1792
81129b90:	0181c004 	movi	r6,1792
81129b94:	11819f26 	beq	r2,r6,8112a214 <__svfscanf_r+0x1560>
81129b98:	a8803fcc 	andi	r2,r21,255
81129b9c:	1080201c 	xori	r2,r2,128
81129ba0:	10bfe004 	addi	r2,r2,-128
81129ba4:	01800044 	movi	r6,1
81129ba8:	11800226 	beq	r2,r6,81129bb4 <__svfscanf_r+0xf00>
81129bac:	01800104 	movi	r6,4
81129bb0:	11bf841e 	bne	r2,r6,811299c4 <__reset+0xfb1099c4>
81129bb4:	ad400044 	addi	r21,r21,1
81129bb8:	003f7706 	br	81129998 <__reset+0xfb109998>
81129bbc:	a8803fcc 	andi	r2,r21,255
81129bc0:	1080201c 	xori	r2,r2,128
81129bc4:	10bfe004 	addi	r2,r2,-128
81129bc8:	10003c1e 	bne	r2,zero,81129cbc <__svfscanf_r+0x1008>
81129bcc:	9801141e 	bne	r19,zero,8112a020 <__svfscanf_r+0x136c>
81129bd0:	a081c00c 	andi	r2,r20,1792
81129bd4:	0181c004 	movi	r6,1792
81129bd8:	11818226 	beq	r2,r6,8112a1e4 <__svfscanf_r+0x1530>
81129bdc:	8821883a 	mov	r16,r17
81129be0:	b019883a 	mov	r12,r22
81129be4:	9823883a 	mov	r17,r19
81129be8:	182d883a 	mov	r22,r3
81129bec:	003f7a06 	br	811299d8 <__reset+0xfb1099d8>
81129bf0:	a8803fcc 	andi	r2,r21,255
81129bf4:	1080201c 	xori	r2,r2,128
81129bf8:	10bfe004 	addi	r2,r2,-128
81129bfc:	01800084 	movi	r6,2
81129c00:	11bf701e 	bne	r2,r6,811299c4 <__reset+0xfb1099c4>
81129c04:	054000c4 	movi	r21,3
81129c08:	003f6306 	br	81129998 <__reset+0xfb109998>
81129c0c:	a081400c 	andi	r2,r20,1280
81129c10:	01810004 	movi	r6,1024
81129c14:	11800326 	beq	r2,r6,81129c24 <__svfscanf_r+0xf70>
81129c18:	a184703a 	and	r2,r20,r6
81129c1c:	103f6926 	beq	r2,zero,811299c4 <__reset+0xfb1099c4>
81129c20:	983fee26 	beq	r19,zero,81129bdc <__reset+0xfb109bdc>
81129c24:	a080800c 	andi	r2,r20,512
81129c28:	1000041e 	bne	r2,zero,81129c3c <__svfscanf_r+0xf88>
81129c2c:	da009f17 	ldw	r8,636(sp)
81129c30:	dc40a515 	stw	r17,660(sp)
81129c34:	9a27c83a 	sub	r19,r19,r8
81129c38:	dcc0a415 	stw	r19,656(sp)
81129c3c:	00be1fc4 	movi	r2,-1921
81129c40:	a0a8703a 	and	r20,r20,r2
81129c44:	a5006014 	ori	r20,r20,384
81129c48:	0027883a 	mov	r19,zero
81129c4c:	003f5206 	br	81129998 <__reset+0xfb109998>
81129c50:	00800044 	movi	r2,1
81129c54:	b0bf5b1e 	bne	r22,r2,811299c4 <__reset+0xfb1099c4>
81129c58:	05800084 	movi	r22,2
81129c5c:	003f4e06 	br	81129998 <__reset+0xfb109998>
81129c60:	d980a317 	ldw	r6,652(sp)
81129c64:	30800003 	ldbu	r2,0(r6)
81129c68:	29803fcc 	andi	r6,r5,255
81129c6c:	30bf551e 	bne	r6,r2,811299c4 <__reset+0xfb1099c4>
81129c70:	a080800c 	andi	r2,r20,512
81129c74:	103f5326 	beq	r2,zero,811299c4 <__reset+0xfb1099c4>
81129c78:	023f5fc4 	movi	r8,-641
81129c7c:	a228703a 	and	r20,r20,r8
81129c80:	dcc09f15 	stw	r19,636(sp)
81129c84:	003f4406 	br	81129998 <__reset+0xfb109998>
81129c88:	1809883a 	mov	r4,r3
81129c8c:	e00b883a 	mov	r5,fp
81129c90:	d8c0a615 	stw	r3,664(sp)
81129c94:	d9c0aa15 	stw	r7,680(sp)
81129c98:	1123f940 	call	81123f94 <__srefill_r>
81129c9c:	d8c0a617 	ldw	r3,664(sp)
81129ca0:	d9c0aa17 	ldw	r7,680(sp)
81129ca4:	103f4626 	beq	r2,zero,811299c0 <__reset+0xfb1099c0>
81129ca8:	003f4606 	br	811299c4 <__reset+0xfb1099c4>
81129cac:	00800084 	movi	r2,2
81129cb0:	b0bfb91e 	bne	r22,r2,81129b98 <__reset+0xfb109b98>
81129cb4:	058000c4 	movi	r22,3
81129cb8:	003f3706 	br	81129998 <__reset+0xfb109998>
81129cbc:	018000c4 	movi	r6,3
81129cc0:	11bfbc26 	beq	r2,r6,81129bb4 <__reset+0xfb109bb4>
81129cc4:	01800144 	movi	r6,5
81129cc8:	11bfba26 	beq	r2,r6,81129bb4 <__reset+0xfb109bb4>
81129ccc:	003f3d06 	br	811299c4 <__reset+0xfb1099c4>
81129cd0:	98bfffc4 	addi	r2,r19,-1
81129cd4:	01405704 	movi	r5,348
81129cd8:	2880d82e 	bgeu	r5,r2,8112a03c <__svfscanf_r+0x1388>
81129cdc:	99ffa8c4 	addi	r7,r19,-349
81129ce0:	04c05744 	movi	r19,349
81129ce4:	8c436014 	ori	r17,r17,3456
81129ce8:	9013883a 	mov	r9,r18
81129cec:	8825883a 	mov	r18,r17
81129cf0:	dc409e17 	ldw	r17,632(sp)
81129cf4:	0029883a 	mov	r20,zero
81129cf8:	dc000104 	addi	r16,sp,4
81129cfc:	05401344 	movi	r21,77
81129d00:	02c08004 	movi	r11,512
81129d04:	01bf7fc4 	movi	r6,-513
81129d08:	023fdfc4 	movi	r8,-129
81129d0c:	20bff544 	addi	r2,r4,-43
81129d10:	10803fcc 	andi	r2,r2,255
81129d14:	a8807236 	bltu	r21,r2,81129ee0 <__svfscanf_r+0x122c>
81129d18:	100490ba 	slli	r2,r2,2
81129d1c:	016044f4 	movhi	r5,33043
81129d20:	29674c04 	addi	r5,r5,-25296
81129d24:	1145883a 	add	r2,r2,r5
81129d28:	10800017 	ldw	r2,0(r2)
81129d2c:	1000683a 	jmp	r2
81129d30:	81129f64 	muli	r4,r16,19069
81129d34:	81129ee0 	cmpeqi	r4,r16,19067
81129d38:	81129f64 	muli	r4,r16,19069
81129d3c:	81129ee0 	cmpeqi	r4,r16,19067
81129d40:	81129ee0 	cmpeqi	r4,r16,19067
81129d44:	81129f3c 	xorhi	r4,r16,19068
81129d48:	81129f1c 	xori	r4,r16,19068
81129d4c:	81129f1c 	xori	r4,r16,19068
81129d50:	81129f1c 	xori	r4,r16,19068
81129d54:	81129f1c 	xori	r4,r16,19068
81129d58:	81129f1c 	xori	r4,r16,19068
81129d5c:	81129f1c 	xori	r4,r16,19068
81129d60:	81129f1c 	xori	r4,r16,19068
81129d64:	81129ec4 	addi	r4,r16,19067
81129d68:	81129ec4 	addi	r4,r16,19067
81129d6c:	81129ee0 	cmpeqi	r4,r16,19067
81129d70:	81129ee0 	cmpeqi	r4,r16,19067
81129d74:	81129ee0 	cmpeqi	r4,r16,19067
81129d78:	81129ee0 	cmpeqi	r4,r16,19067
81129d7c:	81129ee0 	cmpeqi	r4,r16,19067
81129d80:	81129ee0 	cmpeqi	r4,r16,19067
81129d84:	81129ee0 	cmpeqi	r4,r16,19067
81129d88:	81129eb0 	cmpltui	r4,r16,19066
81129d8c:	81129eb0 	cmpltui	r4,r16,19066
81129d90:	81129eb0 	cmpltui	r4,r16,19066
81129d94:	81129eb0 	cmpltui	r4,r16,19066
81129d98:	81129eb0 	cmpltui	r4,r16,19066
81129d9c:	81129eb0 	cmpltui	r4,r16,19066
81129da0:	81129ee0 	cmpeqi	r4,r16,19067
81129da4:	81129ee0 	cmpeqi	r4,r16,19067
81129da8:	81129ee0 	cmpeqi	r4,r16,19067
81129dac:	81129ee0 	cmpeqi	r4,r16,19067
81129db0:	81129ee0 	cmpeqi	r4,r16,19067
81129db4:	81129ee0 	cmpeqi	r4,r16,19067
81129db8:	81129ee0 	cmpeqi	r4,r16,19067
81129dbc:	81129ee0 	cmpeqi	r4,r16,19067
81129dc0:	81129ee0 	cmpeqi	r4,r16,19067
81129dc4:	81129ee0 	cmpeqi	r4,r16,19067
81129dc8:	81129ee0 	cmpeqi	r4,r16,19067
81129dcc:	81129ee0 	cmpeqi	r4,r16,19067
81129dd0:	81129ee0 	cmpeqi	r4,r16,19067
81129dd4:	81129ee0 	cmpeqi	r4,r16,19067
81129dd8:	81129ee0 	cmpeqi	r4,r16,19067
81129ddc:	81129ee0 	cmpeqi	r4,r16,19067
81129de0:	81129ee0 	cmpeqi	r4,r16,19067
81129de4:	81129e68 	cmpgeui	r4,r16,19065
81129de8:	81129ee0 	cmpeqi	r4,r16,19067
81129dec:	81129ee0 	cmpeqi	r4,r16,19067
81129df0:	81129ee0 	cmpeqi	r4,r16,19067
81129df4:	81129ee0 	cmpeqi	r4,r16,19067
81129df8:	81129ee0 	cmpeqi	r4,r16,19067
81129dfc:	81129ee0 	cmpeqi	r4,r16,19067
81129e00:	81129ee0 	cmpeqi	r4,r16,19067
81129e04:	81129ee0 	cmpeqi	r4,r16,19067
81129e08:	81129eb0 	cmpltui	r4,r16,19066
81129e0c:	81129eb0 	cmpltui	r4,r16,19066
81129e10:	81129eb0 	cmpltui	r4,r16,19066
81129e14:	81129eb0 	cmpltui	r4,r16,19066
81129e18:	81129eb0 	cmpltui	r4,r16,19066
81129e1c:	81129eb0 	cmpltui	r4,r16,19066
81129e20:	81129ee0 	cmpeqi	r4,r16,19067
81129e24:	81129ee0 	cmpeqi	r4,r16,19067
81129e28:	81129ee0 	cmpeqi	r4,r16,19067
81129e2c:	81129ee0 	cmpeqi	r4,r16,19067
81129e30:	81129ee0 	cmpeqi	r4,r16,19067
81129e34:	81129ee0 	cmpeqi	r4,r16,19067
81129e38:	81129ee0 	cmpeqi	r4,r16,19067
81129e3c:	81129ee0 	cmpeqi	r4,r16,19067
81129e40:	81129ee0 	cmpeqi	r4,r16,19067
81129e44:	81129ee0 	cmpeqi	r4,r16,19067
81129e48:	81129ee0 	cmpeqi	r4,r16,19067
81129e4c:	81129ee0 	cmpeqi	r4,r16,19067
81129e50:	81129ee0 	cmpeqi	r4,r16,19067
81129e54:	81129ee0 	cmpeqi	r4,r16,19067
81129e58:	81129ee0 	cmpeqi	r4,r16,19067
81129e5c:	81129ee0 	cmpeqi	r4,r16,19067
81129e60:	81129ee0 	cmpeqi	r4,r16,19067
81129e64:	81129e68 	cmpgeui	r4,r16,19065
81129e68:	9081800c 	andi	r2,r18,1536
81129e6c:	12c01c1e 	bne	r2,r11,81129ee0 <__svfscanf_r+0x122c>
81129e70:	91a4703a 	and	r18,r18,r6
81129e74:	94814014 	ori	r18,r18,1280
81129e78:	04400404 	movi	r17,16
81129e7c:	81000005 	stb	r4,0(r16)
81129e80:	84000044 	addi	r16,r16,1
81129e84:	e0800117 	ldw	r2,4(fp)
81129e88:	10bfffc4 	addi	r2,r2,-1
81129e8c:	e0800115 	stw	r2,4(fp)
81129e90:	0080540e 	bge	zero,r2,81129fe4 <__svfscanf_r+0x1330>
81129e94:	18c00044 	addi	r3,r3,1
81129e98:	e0c00015 	stw	r3,0(fp)
81129e9c:	9cffffc4 	addi	r19,r19,-1
81129ea0:	98000f26 	beq	r19,zero,81129ee0 <__svfscanf_r+0x122c>
81129ea4:	e0c00017 	ldw	r3,0(fp)
81129ea8:	19000003 	ldbu	r4,0(r3)
81129eac:	003f9706 	br	81129d0c <__reset+0xfb109d0c>
81129eb0:	00800284 	movi	r2,10
81129eb4:	14400a0e 	bge	r2,r17,81129ee0 <__svfscanf_r+0x122c>
81129eb8:	00bd1fc4 	movi	r2,-2945
81129ebc:	90a4703a 	and	r18,r18,r2
81129ec0:	003fee06 	br	81129e7c <__reset+0xfb109e7c>
81129ec4:	01604574 	movhi	r5,33045
81129ec8:	8c63883a 	add	r17,r17,r17
81129ecc:	29475d84 	addi	r5,r5,7542
81129ed0:	2c45883a 	add	r2,r5,r17
81129ed4:	1440000f 	ldh	r17,0(r2)
81129ed8:	00800204 	movi	r2,8
81129edc:	147ff616 	blt	r2,r17,81129eb8 <__reset+0xfb109eb8>
81129ee0:	dc409e15 	stw	r17,632(sp)
81129ee4:	9023883a 	mov	r17,r18
81129ee8:	8880400c 	andi	r2,r17,256
81129eec:	4825883a 	mov	r18,r9
81129ef0:	10000426 	beq	r2,zero,81129f04 <__svfscanf_r+0x1250>
81129ef4:	d9800104 	addi	r6,sp,4
81129ef8:	3400be36 	bltu	r6,r16,8112a1f4 <__svfscanf_r+0x1540>
81129efc:	da000104 	addi	r8,sp,4
81129f00:	443bae26 	beq	r8,r16,81128dbc <__reset+0xfb108dbc>
81129f04:	8880040c 	andi	r2,r17,16
81129f08:	10009326 	beq	r2,zero,8112a158 <__svfscanf_r+0x14a4>
81129f0c:	d8800104 	addi	r2,sp,4
81129f10:	80a1c83a 	sub	r16,r16,r2
81129f14:	8521883a 	add	r16,r16,r20
81129f18:	003d0606 	br	81129334 <__reset+0xfb109334>
81129f1c:	01604574 	movhi	r5,33045
81129f20:	8c63883a 	add	r17,r17,r17
81129f24:	29475d84 	addi	r5,r5,7542
81129f28:	2c45883a 	add	r2,r5,r17
81129f2c:	1440000f 	ldh	r17,0(r2)
81129f30:	00bd1fc4 	movi	r2,-2945
81129f34:	90a4703a 	and	r18,r18,r2
81129f38:	003fd006 	br	81129e7c <__reset+0xfb109e7c>
81129f3c:	9082000c 	andi	r2,r18,2048
81129f40:	103fce26 	beq	r2,zero,81129e7c <__reset+0xfb109e7c>
81129f44:	8800021e 	bne	r17,zero,81129f50 <__svfscanf_r+0x129c>
81129f48:	94808014 	ori	r18,r18,512
81129f4c:	04400204 	movi	r17,8
81129f50:	9081000c 	andi	r2,r18,1024
81129f54:	10009426 	beq	r2,zero,8112a1a8 <__svfscanf_r+0x14f4>
81129f58:	00be9fc4 	movi	r2,-1409
81129f5c:	90a4703a 	and	r18,r18,r2
81129f60:	003fc606 	br	81129e7c <__reset+0xfb109e7c>
81129f64:	9080200c 	andi	r2,r18,128
81129f68:	103fdd26 	beq	r2,zero,81129ee0 <__reset+0xfb109ee0>
81129f6c:	9224703a 	and	r18,r18,r8
81129f70:	003fc206 	br	81129e7c <__reset+0xfb109e7c>
81129f74:	9800011e 	bne	r19,zero,81129f7c <__svfscanf_r+0x12c8>
81129f78:	04ffffc4 	movi	r19,-1
81129f7c:	8900004c 	andi	r4,r17,1
81129f80:	20005b1e 	bne	r4,zero,8112a0f0 <__svfscanf_r+0x143c>
81129f84:	8c40040c 	andi	r17,r17,16
81129f88:	88003026 	beq	r17,zero,8112a04c <__svfscanf_r+0x1398>
81129f8c:	0021883a 	mov	r16,zero
81129f90:	00000306 	br	81129fa0 <__svfscanf_r+0x12ec>
81129f94:	18800003 	ldbu	r2,0(r3)
81129f98:	3885883a 	add	r2,r7,r2
81129f9c:	10800043 	ldbu	r2,1(r2)
81129fa0:	1080020c 	andi	r2,r2,8
81129fa4:	103ce31e 	bne	r2,zero,81129334 <__reset+0xfb109334>
81129fa8:	e0800117 	ldw	r2,4(fp)
81129fac:	18c00044 	addi	r3,r3,1
81129fb0:	84000044 	addi	r16,r16,1
81129fb4:	10bfffc4 	addi	r2,r2,-1
81129fb8:	e0800115 	stw	r2,4(fp)
81129fbc:	e0c00015 	stw	r3,0(fp)
81129fc0:	84fcdc26 	beq	r16,r19,81129334 <__reset+0xfb109334>
81129fc4:	00bff316 	blt	zero,r2,81129f94 <__reset+0xfb109f94>
81129fc8:	e00b883a 	mov	r5,fp
81129fcc:	b009883a 	mov	r4,r22
81129fd0:	1123f940 	call	81123f94 <__srefill_r>
81129fd4:	103cd71e 	bne	r2,zero,81129334 <__reset+0xfb109334>
81129fd8:	b9c00017 	ldw	r7,0(r23)
81129fdc:	e0c00017 	ldw	r3,0(fp)
81129fe0:	003fec06 	br	81129f94 <__reset+0xfb109f94>
81129fe4:	e00b883a 	mov	r5,fp
81129fe8:	b009883a 	mov	r4,r22
81129fec:	d980a715 	stw	r6,668(sp)
81129ff0:	d9c0aa15 	stw	r7,680(sp)
81129ff4:	da00a815 	stw	r8,672(sp)
81129ff8:	da40a915 	stw	r9,676(sp)
81129ffc:	dac0a615 	stw	r11,664(sp)
8112a000:	1123f940 	call	81123f94 <__srefill_r>
8112a004:	d980a717 	ldw	r6,668(sp)
8112a008:	d9c0aa17 	ldw	r7,680(sp)
8112a00c:	da00a817 	ldw	r8,672(sp)
8112a010:	da40a917 	ldw	r9,676(sp)
8112a014:	dac0a617 	ldw	r11,664(sp)
8112a018:	103fa026 	beq	r2,zero,81129e9c <__reset+0xfb109e9c>
8112a01c:	003fb006 	br	81129ee0 <__reset+0xfb109ee0>
8112a020:	8821883a 	mov	r16,r17
8112a024:	b019883a 	mov	r12,r22
8112a028:	9823883a 	mov	r17,r19
8112a02c:	182d883a 	mov	r22,r3
8112a030:	00bfbfc4 	movi	r2,-257
8112a034:	a0a8703a 	and	r20,r20,r2
8112a038:	003e6706 	br	811299d8 <__reset+0xfb1099d8>
8112a03c:	000f883a 	mov	r7,zero
8112a040:	003f2806 	br	81129ce4 <__reset+0xfb109ce4>
8112a044:	d800a215 	stw	zero,648(sp)
8112a048:	003de306 	br	811297d8 <__reset+0xfb1097d8>
8112a04c:	da009c17 	ldw	r8,624(sp)
8112a050:	9abfffc4 	addi	r10,r19,-1
8112a054:	44400017 	ldw	r17,0(r8)
8112a058:	44000104 	addi	r16,r8,4
8112a05c:	880b883a 	mov	r5,r17
8112a060:	8aa9883a 	add	r20,r17,r10
8112a064:	00000606 	br	8112a080 <__svfscanf_r+0x13cc>
8112a068:	e0c00017 	ldw	r3,0(fp)
8112a06c:	b9000017 	ldw	r4,0(r23)
8112a070:	a80b883a 	mov	r5,r21
8112a074:	18800003 	ldbu	r2,0(r3)
8112a078:	2085883a 	add	r2,r4,r2
8112a07c:	10800043 	ldbu	r2,1(r2)
8112a080:	1080020c 	andi	r2,r2,8
8112a084:	1000551e 	bne	r2,zero,8112a1dc <__svfscanf_r+0x1528>
8112a088:	e0800117 	ldw	r2,4(fp)
8112a08c:	19000044 	addi	r4,r3,1
8112a090:	e1000015 	stw	r4,0(fp)
8112a094:	10bfffc4 	addi	r2,r2,-1
8112a098:	e0800115 	stw	r2,4(fp)
8112a09c:	18800003 	ldbu	r2,0(r3)
8112a0a0:	2d400044 	addi	r21,r5,1
8112a0a4:	a827883a 	mov	r19,r21
8112a0a8:	28800005 	stb	r2,0(r5)
8112a0ac:	2d000626 	beq	r5,r20,8112a0c8 <__svfscanf_r+0x1414>
8112a0b0:	e0800117 	ldw	r2,4(fp)
8112a0b4:	00bfec16 	blt	zero,r2,8112a068 <__reset+0xfb10a068>
8112a0b8:	e00b883a 	mov	r5,fp
8112a0bc:	b009883a 	mov	r4,r22
8112a0c0:	1123f940 	call	81123f94 <__srefill_r>
8112a0c4:	103fe826 	beq	r2,zero,8112a068 <__reset+0xfb10a068>
8112a0c8:	da00a017 	ldw	r8,640(sp)
8112a0cc:	dd009d17 	ldw	r20,628(sp)
8112a0d0:	9c63c83a 	sub	r17,r19,r17
8112a0d4:	42000044 	addi	r8,r8,1
8112a0d8:	98000005 	stb	zero,0(r19)
8112a0dc:	9465883a 	add	r18,r18,r17
8112a0e0:	da00a015 	stw	r8,640(sp)
8112a0e4:	dc009c15 	stw	r16,624(sp)
8112a0e8:	a00d883a 	mov	r6,r20
8112a0ec:	003b2f06 	br	81128dac <__reset+0xfb108dac>
8112a0f0:	dd409904 	addi	r21,sp,612
8112a0f4:	8c40040c 	andi	r17,r17,16
8112a0f8:	01800204 	movi	r6,8
8112a0fc:	000b883a 	mov	r5,zero
8112a100:	a809883a 	mov	r4,r21
8112a104:	1123b940 	call	81123b94 <memset>
8112a108:	8800401e 	bne	r17,zero,8112a20c <__svfscanf_r+0x1558>
8112a10c:	da009c17 	ldw	r8,624(sp)
8112a110:	45000017 	ldw	r20,0(r8)
8112a114:	42000104 	addi	r8,r8,4
8112a118:	da009c15 	stw	r8,624(sp)
8112a11c:	000d883a 	mov	r6,zero
8112a120:	3021883a 	mov	r16,r6
8112a124:	dc409f15 	stw	r17,636(sp)
8112a128:	e0800017 	ldw	r2,0(fp)
8112a12c:	b8c00017 	ldw	r3,0(r23)
8112a130:	10800003 	ldbu	r2,0(r2)
8112a134:	1885883a 	add	r2,r3,r2
8112a138:	10800043 	ldbu	r2,1(r2)
8112a13c:	1080020c 	andi	r2,r2,8
8112a140:	1000011e 	bne	r2,zero,8112a148 <__svfscanf_r+0x1494>
8112a144:	9800701e 	bne	r19,zero,8112a308 <__svfscanf_r+0x1654>
8112a148:	dc409f17 	ldw	r17,636(sp)
8112a14c:	883cdd1e 	bne	r17,zero,811294c4 <__reset+0xfb1094c4>
8112a150:	a0000015 	stw	zero,0(r20)
8112a154:	003cd806 	br	811294b8 <__reset+0xfb1094b8>
8112a158:	d9c09e17 	ldw	r7,632(sp)
8112a15c:	da00a117 	ldw	r8,644(sp)
8112a160:	000d883a 	mov	r6,zero
8112a164:	d9400104 	addi	r5,sp,4
8112a168:	b009883a 	mov	r4,r22
8112a16c:	80000005 	stb	zero,0(r16)
8112a170:	403ee83a 	callr	r8
8112a174:	88c0080c 	andi	r3,r17,32
8112a178:	1800121e 	bne	r3,zero,8112a1c4 <__svfscanf_r+0x1510>
8112a17c:	88c0010c 	andi	r3,r17,4
8112a180:	18004d26 	beq	r3,zero,8112a2b8 <__svfscanf_r+0x1604>
8112a184:	da009c17 	ldw	r8,624(sp)
8112a188:	40c00017 	ldw	r3,0(r8)
8112a18c:	42000104 	addi	r8,r8,4
8112a190:	da009c15 	stw	r8,624(sp)
8112a194:	1880000d 	sth	r2,0(r3)
8112a198:	da00a017 	ldw	r8,640(sp)
8112a19c:	42000044 	addi	r8,r8,1
8112a1a0:	da00a015 	stw	r8,640(sp)
8112a1a4:	003f5906 	br	81129f0c <__reset+0xfb109f0c>
8112a1a8:	00bf1fc4 	movi	r2,-897
8112a1ac:	90a4703a 	and	r18,r18,r2
8112a1b0:	38000226 	beq	r7,zero,8112a1bc <__svfscanf_r+0x1508>
8112a1b4:	39ffffc4 	addi	r7,r7,-1
8112a1b8:	9cc00044 	addi	r19,r19,1
8112a1bc:	a5000044 	addi	r20,r20,1
8112a1c0:	003f3006 	br	81129e84 <__reset+0xfb109e84>
8112a1c4:	da009c17 	ldw	r8,624(sp)
8112a1c8:	40c00017 	ldw	r3,0(r8)
8112a1cc:	42000104 	addi	r8,r8,4
8112a1d0:	da009c15 	stw	r8,624(sp)
8112a1d4:	18800015 	stw	r2,0(r3)
8112a1d8:	003fef06 	br	8112a198 <__reset+0xfb10a198>
8112a1dc:	2827883a 	mov	r19,r5
8112a1e0:	003fb906 	br	8112a0c8 <__reset+0xfb10a0c8>
8112a1e4:	01be1fc4 	movi	r6,-1921
8112a1e8:	a1a8703a 	and	r20,r20,r6
8112a1ec:	05400044 	movi	r21,1
8112a1f0:	003de906 	br	81129998 <__reset+0xfb109998>
8112a1f4:	817fffc7 	ldb	r5,-1(r16)
8112a1f8:	e00d883a 	mov	r6,fp
8112a1fc:	b009883a 	mov	r4,r22
8112a200:	843fffc4 	addi	r16,r16,-1
8112a204:	113290c0 	call	8113290c <_ungetc_r>
8112a208:	003f3c06 	br	81129efc <__reset+0xfb109efc>
8112a20c:	dd009b04 	addi	r20,sp,620
8112a210:	003fc206 	br	8112a11c <__reset+0xfb10a11c>
8112a214:	00be1fc4 	movi	r2,-1921
8112a218:	a0a8703a 	and	r20,r20,r2
8112a21c:	05800044 	movi	r22,1
8112a220:	003ddd06 	br	81129998 <__reset+0xfb109998>
8112a224:	d8c09f17 	ldw	r3,636(sp)
8112a228:	88e3c83a 	sub	r17,r17,r3
8112a22c:	044dc83a 	sub	r6,zero,r17
8112a230:	883e2126 	beq	r17,zero,81129ab8 <__reset+0xfb109ab8>
8112a234:	d88055c4 	addi	r2,sp,343
8112a238:	80800136 	bltu	r16,r2,8112a240 <__svfscanf_r+0x158c>
8112a23c:	dc005584 	addi	r16,sp,342
8112a240:	01604574 	movhi	r5,33045
8112a244:	29475c04 	addi	r5,r5,7536
8112a248:	8009883a 	mov	r4,r16
8112a24c:	11242a80 	call	811242a8 <sprintf>
8112a250:	003e1906 	br	81129ab8 <__reset+0xfb109ab8>
8112a254:	d8c0a517 	ldw	r3,660(sp)
8112a258:	000d883a 	mov	r6,zero
8112a25c:	01c00284 	movi	r7,10
8112a260:	19400044 	addi	r5,r3,1
8112a264:	b009883a 	mov	r4,r22
8112a268:	11245980 	call	81124598 <_strtol_r>
8112a26c:	da00a417 	ldw	r8,656(sp)
8112a270:	dc00a517 	ldw	r16,660(sp)
8112a274:	120dc83a 	sub	r6,r2,r8
8112a278:	003fee06 	br	8112a234 <__reset+0xfb10a234>
8112a27c:	da009c17 	ldw	r8,624(sp)
8112a280:	180b883a 	mov	r5,r3
8112a284:	8009883a 	mov	r4,r16
8112a288:	45000017 	ldw	r20,0(r8)
8112a28c:	44400104 	addi	r17,r8,4
8112a290:	d8c0a615 	stw	r3,664(sp)
8112a294:	112f2280 	call	8112f228 <__fpclassifyd>
8112a298:	d8c0a617 	ldw	r3,664(sp)
8112a29c:	10006426 	beq	r2,zero,8112a430 <__svfscanf_r+0x177c>
8112a2a0:	8009883a 	mov	r4,r16
8112a2a4:	180b883a 	mov	r5,r3
8112a2a8:	112262c0 	call	8112262c <__truncdfsf2>
8112a2ac:	a0800015 	stw	r2,0(r20)
8112a2b0:	dc409c15 	stw	r17,624(sp)
8112a2b4:	003e0f06 	br	81129af4 <__reset+0xfb109af4>
8112a2b8:	88c0004c 	andi	r3,r17,1
8112a2bc:	183fc11e 	bne	r3,zero,8112a1c4 <__reset+0xfb10a1c4>
8112a2c0:	8c40008c 	andi	r17,r17,2
8112a2c4:	883fbf26 	beq	r17,zero,8112a1c4 <__reset+0xfb10a1c4>
8112a2c8:	da00a117 	ldw	r8,644(sp)
8112a2cc:	00a044f4 	movhi	r2,33043
8112a2d0:	1083b104 	addi	r2,r2,3780
8112a2d4:	d9c09e17 	ldw	r7,632(sp)
8112a2d8:	000d883a 	mov	r6,zero
8112a2dc:	d9400104 	addi	r5,sp,4
8112a2e0:	b009883a 	mov	r4,r22
8112a2e4:	40806226 	beq	r8,r2,8112a470 <__svfscanf_r+0x17bc>
8112a2e8:	1130bdc0 	call	81130bdc <_strtoll_r>
8112a2ec:	da009c17 	ldw	r8,624(sp)
8112a2f0:	41000017 	ldw	r4,0(r8)
8112a2f4:	42000104 	addi	r8,r8,4
8112a2f8:	da009c15 	stw	r8,624(sp)
8112a2fc:	20800015 	stw	r2,0(r4)
8112a300:	20c00115 	stw	r3,4(r4)
8112a304:	003fa406 	br	8112a198 <__reset+0xfb10a198>
8112a308:	112d6b80 	call	8112d6b8 <__locale_mb_cur_max>
8112a30c:	80bca726 	beq	r16,r2,811295ac <__reset+0xfb1095ac>
8112a310:	e0800017 	ldw	r2,0(fp)
8112a314:	e1000117 	ldw	r4,4(fp)
8112a318:	d8c00104 	addi	r3,sp,4
8112a31c:	12000003 	ldbu	r8,0(r2)
8112a320:	213fffc4 	addi	r4,r4,-1
8112a324:	10800044 	addi	r2,r2,1
8112a328:	e1000115 	stw	r4,4(fp)
8112a32c:	e0800015 	stw	r2,0(fp)
8112a330:	84400044 	addi	r17,r16,1
8112a334:	dd400015 	stw	r21,0(sp)
8112a338:	1c21883a 	add	r16,r3,r16
8112a33c:	b009883a 	mov	r4,r22
8112a340:	880f883a 	mov	r7,r17
8112a344:	180d883a 	mov	r6,r3
8112a348:	a00b883a 	mov	r5,r20
8112a34c:	82000005 	stb	r8,0(r16)
8112a350:	112d7740 	call	8112d774 <_mbrtowc_r>
8112a354:	013fffc4 	movi	r4,-1
8112a358:	113c9426 	beq	r2,r4,811295ac <__reset+0xfb1095ac>
8112a35c:	103c881e 	bne	r2,zero,81129580 <__reset+0xfb109580>
8112a360:	a0000015 	stw	zero,0(r20)
8112a364:	0009883a 	mov	r4,zero
8112a368:	112d5f80 	call	8112d5f8 <iswspace>
8112a36c:	10001a26 	beq	r2,zero,8112a3d8 <__svfscanf_r+0x1724>
8112a370:	8821883a 	mov	r16,r17
8112a374:	dc409f17 	ldw	r17,636(sp)
8112a378:	803f7426 	beq	r16,zero,8112a14c <__reset+0xfb10a14c>
8112a37c:	843fffc4 	addi	r16,r16,-1
8112a380:	d9800104 	addi	r6,sp,4
8112a384:	342b883a 	add	r21,r6,r16
8112a388:	00000106 	br	8112a390 <__svfscanf_r+0x16dc>
8112a38c:	843fffc4 	addi	r16,r16,-1
8112a390:	a9400003 	ldbu	r5,0(r21)
8112a394:	e00d883a 	mov	r6,fp
8112a398:	b009883a 	mov	r4,r22
8112a39c:	113290c0 	call	8113290c <_ungetc_r>
8112a3a0:	ad7fffc4 	addi	r21,r21,-1
8112a3a4:	803ff91e 	bne	r16,zero,8112a38c <__reset+0xfb10a38c>
8112a3a8:	003f6806 	br	8112a14c <__reset+0xfb10a14c>
8112a3ac:	d9800104 	addi	r6,sp,4
8112a3b0:	802b883a 	mov	r21,r16
8112a3b4:	343a812e 	bgeu	r6,r16,81128dbc <__reset+0xfb108dbc>
8112a3b8:	ad7fffc4 	addi	r21,r21,-1
8112a3bc:	a9400007 	ldb	r5,0(r21)
8112a3c0:	e00d883a 	mov	r6,fp
8112a3c4:	b009883a 	mov	r4,r22
8112a3c8:	113290c0 	call	8113290c <_ungetc_r>
8112a3cc:	da000104 	addi	r8,sp,4
8112a3d0:	457ff91e 	bne	r8,r21,8112a3b8 <__reset+0xfb10a3b8>
8112a3d4:	003a7906 	br	81128dbc <__reset+0xfb108dbc>
8112a3d8:	da009f17 	ldw	r8,636(sp)
8112a3dc:	9465883a 	add	r18,r18,r17
8112a3e0:	9cffffc4 	addi	r19,r19,-1
8112a3e4:	4000051e 	bne	r8,zero,8112a3fc <__svfscanf_r+0x1748>
8112a3e8:	a5000104 	addi	r20,r20,4
8112a3ec:	0021883a 	mov	r16,zero
8112a3f0:	003c6606 	br	8112958c <__reset+0xfb10958c>
8112a3f4:	a1000017 	ldw	r4,0(r20)
8112a3f8:	003fdb06 	br	8112a368 <__reset+0xfb10a368>
8112a3fc:	0021883a 	mov	r16,zero
8112a400:	003c6206 	br	8112958c <__reset+0xfb10958c>
8112a404:	d8800104 	addi	r2,sp,4
8112a408:	802b883a 	mov	r21,r16
8112a40c:	143a6b2e 	bgeu	r2,r16,81128dbc <__reset+0xfb108dbc>
8112a410:	ad7fffc4 	addi	r21,r21,-1
8112a414:	a9400007 	ldb	r5,0(r21)
8112a418:	e00d883a 	mov	r6,fp
8112a41c:	b009883a 	mov	r4,r22
8112a420:	113290c0 	call	8113290c <_ungetc_r>
8112a424:	d8c00104 	addi	r3,sp,4
8112a428:	1d7ff91e 	bne	r3,r21,8112a410 <__reset+0xfb10a410>
8112a42c:	003a6306 	br	81128dbc <__reset+0xfb108dbc>
8112a430:	0009883a 	mov	r4,zero
8112a434:	112f36c0 	call	8112f36c <nanf>
8112a438:	a0800015 	stw	r2,0(r20)
8112a43c:	dc409c15 	stw	r17,624(sp)
8112a440:	003dac06 	br	81129af4 <__reset+0xfb109af4>
8112a444:	d9000104 	addi	r4,sp,4
8112a448:	802b883a 	mov	r21,r16
8112a44c:	243a5b2e 	bgeu	r4,r16,81128dbc <__reset+0xfb108dbc>
8112a450:	ad7fffc4 	addi	r21,r21,-1
8112a454:	a9400007 	ldb	r5,0(r21)
8112a458:	e00d883a 	mov	r6,fp
8112a45c:	b009883a 	mov	r4,r22
8112a460:	113290c0 	call	8113290c <_ungetc_r>
8112a464:	d9400104 	addi	r5,sp,4
8112a468:	2d7ff91e 	bne	r5,r21,8112a450 <__reset+0xfb10a450>
8112a46c:	003a5306 	br	81128dbc <__reset+0xfb108dbc>
8112a470:	11311340 	call	81131134 <_strtoull_r>
8112a474:	003f9d06 	br	8112a2ec <__reset+0xfb10a2ec>

8112a478 <vfscanf>:
8112a478:	00a04574 	movhi	r2,33045
8112a47c:	defffb04 	addi	sp,sp,-20
8112a480:	10911304 	addi	r2,r2,17484
8112a484:	de00012e 	bgeu	sp,et,8112a48c <vfscanf+0x14>
8112a488:	003b68fa 	trap	3
8112a48c:	dc000215 	stw	r16,8(sp)
8112a490:	14000017 	ldw	r16,0(r2)
8112a494:	dc400315 	stw	r17,12(sp)
8112a498:	dfc00415 	stw	ra,16(sp)
8112a49c:	2023883a 	mov	r17,r4
8112a4a0:	80000826 	beq	r16,zero,8112a4c4 <vfscanf+0x4c>
8112a4a4:	80800e17 	ldw	r2,56(r16)
8112a4a8:	1000061e 	bne	r2,zero,8112a4c4 <vfscanf+0x4c>
8112a4ac:	8009883a 	mov	r4,r16
8112a4b0:	d9400015 	stw	r5,0(sp)
8112a4b4:	d9800115 	stw	r6,4(sp)
8112a4b8:	112c7900 	call	8112c790 <__sinit>
8112a4bc:	d9800117 	ldw	r6,4(sp)
8112a4c0:	d9400017 	ldw	r5,0(sp)
8112a4c4:	300f883a 	mov	r7,r6
8112a4c8:	8009883a 	mov	r4,r16
8112a4cc:	280d883a 	mov	r6,r5
8112a4d0:	880b883a 	mov	r5,r17
8112a4d4:	dfc00417 	ldw	ra,16(sp)
8112a4d8:	dc400317 	ldw	r17,12(sp)
8112a4dc:	dc000217 	ldw	r16,8(sp)
8112a4e0:	dec00504 	addi	sp,sp,20
8112a4e4:	1128cb41 	jmpi	81128cb4 <__svfscanf_r>

8112a4e8 <__svfscanf>:
8112a4e8:	00a04574 	movhi	r2,33045
8112a4ec:	10911304 	addi	r2,r2,17484
8112a4f0:	300f883a 	mov	r7,r6
8112a4f4:	280d883a 	mov	r6,r5
8112a4f8:	200b883a 	mov	r5,r4
8112a4fc:	11000017 	ldw	r4,0(r2)
8112a500:	1128cb41 	jmpi	81128cb4 <__svfscanf_r>

8112a504 <_vfscanf_r>:
8112a504:	defffb04 	addi	sp,sp,-20
8112a508:	de00012e 	bgeu	sp,et,8112a510 <_vfscanf_r+0xc>
8112a50c:	003b68fa 	trap	3
8112a510:	dc000315 	stw	r16,12(sp)
8112a514:	dfc00415 	stw	ra,16(sp)
8112a518:	2021883a 	mov	r16,r4
8112a51c:	20000926 	beq	r4,zero,8112a544 <_vfscanf_r+0x40>
8112a520:	20800e17 	ldw	r2,56(r4)
8112a524:	1000071e 	bne	r2,zero,8112a544 <_vfscanf_r+0x40>
8112a528:	d9400015 	stw	r5,0(sp)
8112a52c:	d9800115 	stw	r6,4(sp)
8112a530:	d9c00215 	stw	r7,8(sp)
8112a534:	112c7900 	call	8112c790 <__sinit>
8112a538:	d9c00217 	ldw	r7,8(sp)
8112a53c:	d9800117 	ldw	r6,4(sp)
8112a540:	d9400017 	ldw	r5,0(sp)
8112a544:	8009883a 	mov	r4,r16
8112a548:	dfc00417 	ldw	ra,16(sp)
8112a54c:	dc000317 	ldw	r16,12(sp)
8112a550:	dec00504 	addi	sp,sp,20
8112a554:	1128cb41 	jmpi	81128cb4 <__svfscanf_r>

8112a558 <__swbuf_r>:
8112a558:	defffb04 	addi	sp,sp,-20
8112a55c:	de00012e 	bgeu	sp,et,8112a564 <__swbuf_r+0xc>
8112a560:	003b68fa 	trap	3
8112a564:	dcc00315 	stw	r19,12(sp)
8112a568:	dc800215 	stw	r18,8(sp)
8112a56c:	dc000015 	stw	r16,0(sp)
8112a570:	dfc00415 	stw	ra,16(sp)
8112a574:	dc400115 	stw	r17,4(sp)
8112a578:	2025883a 	mov	r18,r4
8112a57c:	2827883a 	mov	r19,r5
8112a580:	3021883a 	mov	r16,r6
8112a584:	20000226 	beq	r4,zero,8112a590 <__swbuf_r+0x38>
8112a588:	20800e17 	ldw	r2,56(r4)
8112a58c:	10004226 	beq	r2,zero,8112a698 <__swbuf_r+0x140>
8112a590:	80800617 	ldw	r2,24(r16)
8112a594:	8100030b 	ldhu	r4,12(r16)
8112a598:	80800215 	stw	r2,8(r16)
8112a59c:	2080020c 	andi	r2,r4,8
8112a5a0:	10003626 	beq	r2,zero,8112a67c <__swbuf_r+0x124>
8112a5a4:	80c00417 	ldw	r3,16(r16)
8112a5a8:	18003426 	beq	r3,zero,8112a67c <__swbuf_r+0x124>
8112a5ac:	2088000c 	andi	r2,r4,8192
8112a5b0:	9c403fcc 	andi	r17,r19,255
8112a5b4:	10001a26 	beq	r2,zero,8112a620 <__swbuf_r+0xc8>
8112a5b8:	80800017 	ldw	r2,0(r16)
8112a5bc:	81000517 	ldw	r4,20(r16)
8112a5c0:	10c7c83a 	sub	r3,r2,r3
8112a5c4:	1900200e 	bge	r3,r4,8112a648 <__swbuf_r+0xf0>
8112a5c8:	18c00044 	addi	r3,r3,1
8112a5cc:	81000217 	ldw	r4,8(r16)
8112a5d0:	11400044 	addi	r5,r2,1
8112a5d4:	81400015 	stw	r5,0(r16)
8112a5d8:	213fffc4 	addi	r4,r4,-1
8112a5dc:	81000215 	stw	r4,8(r16)
8112a5e0:	14c00005 	stb	r19,0(r2)
8112a5e4:	80800517 	ldw	r2,20(r16)
8112a5e8:	10c01e26 	beq	r2,r3,8112a664 <__swbuf_r+0x10c>
8112a5ec:	8080030b 	ldhu	r2,12(r16)
8112a5f0:	1080004c 	andi	r2,r2,1
8112a5f4:	10000226 	beq	r2,zero,8112a600 <__swbuf_r+0xa8>
8112a5f8:	00800284 	movi	r2,10
8112a5fc:	88801926 	beq	r17,r2,8112a664 <__swbuf_r+0x10c>
8112a600:	8805883a 	mov	r2,r17
8112a604:	dfc00417 	ldw	ra,16(sp)
8112a608:	dcc00317 	ldw	r19,12(sp)
8112a60c:	dc800217 	ldw	r18,8(sp)
8112a610:	dc400117 	ldw	r17,4(sp)
8112a614:	dc000017 	ldw	r16,0(sp)
8112a618:	dec00504 	addi	sp,sp,20
8112a61c:	f800283a 	ret
8112a620:	81401917 	ldw	r5,100(r16)
8112a624:	00b7ffc4 	movi	r2,-8193
8112a628:	21080014 	ori	r4,r4,8192
8112a62c:	2884703a 	and	r2,r5,r2
8112a630:	80801915 	stw	r2,100(r16)
8112a634:	80800017 	ldw	r2,0(r16)
8112a638:	8100030d 	sth	r4,12(r16)
8112a63c:	81000517 	ldw	r4,20(r16)
8112a640:	10c7c83a 	sub	r3,r2,r3
8112a644:	193fe016 	blt	r3,r4,8112a5c8 <__reset+0xfb10a5c8>
8112a648:	800b883a 	mov	r5,r16
8112a64c:	9009883a 	mov	r4,r18
8112a650:	112c3940 	call	8112c394 <_fflush_r>
8112a654:	1000071e 	bne	r2,zero,8112a674 <__swbuf_r+0x11c>
8112a658:	80800017 	ldw	r2,0(r16)
8112a65c:	00c00044 	movi	r3,1
8112a660:	003fda06 	br	8112a5cc <__reset+0xfb10a5cc>
8112a664:	800b883a 	mov	r5,r16
8112a668:	9009883a 	mov	r4,r18
8112a66c:	112c3940 	call	8112c394 <_fflush_r>
8112a670:	103fe326 	beq	r2,zero,8112a600 <__reset+0xfb10a600>
8112a674:	00bfffc4 	movi	r2,-1
8112a678:	003fe206 	br	8112a604 <__reset+0xfb10a604>
8112a67c:	800b883a 	mov	r5,r16
8112a680:	9009883a 	mov	r4,r18
8112a684:	112a7200 	call	8112a720 <__swsetup_r>
8112a688:	103ffa1e 	bne	r2,zero,8112a674 <__reset+0xfb10a674>
8112a68c:	8100030b 	ldhu	r4,12(r16)
8112a690:	80c00417 	ldw	r3,16(r16)
8112a694:	003fc506 	br	8112a5ac <__reset+0xfb10a5ac>
8112a698:	112c7900 	call	8112c790 <__sinit>
8112a69c:	003fbc06 	br	8112a590 <__reset+0xfb10a590>

8112a6a0 <__swbuf>:
8112a6a0:	00a04574 	movhi	r2,33045
8112a6a4:	10911304 	addi	r2,r2,17484
8112a6a8:	280d883a 	mov	r6,r5
8112a6ac:	200b883a 	mov	r5,r4
8112a6b0:	11000017 	ldw	r4,0(r2)
8112a6b4:	112a5581 	jmpi	8112a558 <__swbuf_r>

8112a6b8 <_write_r>:
8112a6b8:	defffd04 	addi	sp,sp,-12
8112a6bc:	de00012e 	bgeu	sp,et,8112a6c4 <_write_r+0xc>
8112a6c0:	003b68fa 	trap	3
8112a6c4:	2805883a 	mov	r2,r5
8112a6c8:	dc000015 	stw	r16,0(sp)
8112a6cc:	04204574 	movhi	r16,33045
8112a6d0:	dc400115 	stw	r17,4(sp)
8112a6d4:	300b883a 	mov	r5,r6
8112a6d8:	84118604 	addi	r16,r16,17944
8112a6dc:	2023883a 	mov	r17,r4
8112a6e0:	380d883a 	mov	r6,r7
8112a6e4:	1009883a 	mov	r4,r2
8112a6e8:	dfc00215 	stw	ra,8(sp)
8112a6ec:	80000015 	stw	zero,0(r16)
8112a6f0:	11391b00 	call	811391b0 <write>
8112a6f4:	00ffffc4 	movi	r3,-1
8112a6f8:	10c00526 	beq	r2,r3,8112a710 <_write_r+0x58>
8112a6fc:	dfc00217 	ldw	ra,8(sp)
8112a700:	dc400117 	ldw	r17,4(sp)
8112a704:	dc000017 	ldw	r16,0(sp)
8112a708:	dec00304 	addi	sp,sp,12
8112a70c:	f800283a 	ret
8112a710:	80c00017 	ldw	r3,0(r16)
8112a714:	183ff926 	beq	r3,zero,8112a6fc <__reset+0xfb10a6fc>
8112a718:	88c00015 	stw	r3,0(r17)
8112a71c:	003ff706 	br	8112a6fc <__reset+0xfb10a6fc>

8112a720 <__swsetup_r>:
8112a720:	00a04574 	movhi	r2,33045
8112a724:	defffd04 	addi	sp,sp,-12
8112a728:	10911304 	addi	r2,r2,17484
8112a72c:	de00012e 	bgeu	sp,et,8112a734 <__swsetup_r+0x14>
8112a730:	003b68fa 	trap	3
8112a734:	dc400115 	stw	r17,4(sp)
8112a738:	2023883a 	mov	r17,r4
8112a73c:	11000017 	ldw	r4,0(r2)
8112a740:	dc000015 	stw	r16,0(sp)
8112a744:	dfc00215 	stw	ra,8(sp)
8112a748:	2821883a 	mov	r16,r5
8112a74c:	20000226 	beq	r4,zero,8112a758 <__swsetup_r+0x38>
8112a750:	20800e17 	ldw	r2,56(r4)
8112a754:	10003126 	beq	r2,zero,8112a81c <__swsetup_r+0xfc>
8112a758:	8080030b 	ldhu	r2,12(r16)
8112a75c:	10c0020c 	andi	r3,r2,8
8112a760:	1009883a 	mov	r4,r2
8112a764:	18000f26 	beq	r3,zero,8112a7a4 <__swsetup_r+0x84>
8112a768:	80c00417 	ldw	r3,16(r16)
8112a76c:	18001526 	beq	r3,zero,8112a7c4 <__swsetup_r+0xa4>
8112a770:	1100004c 	andi	r4,r2,1
8112a774:	20001c1e 	bne	r4,zero,8112a7e8 <__swsetup_r+0xc8>
8112a778:	1080008c 	andi	r2,r2,2
8112a77c:	1000291e 	bne	r2,zero,8112a824 <__swsetup_r+0x104>
8112a780:	80800517 	ldw	r2,20(r16)
8112a784:	80800215 	stw	r2,8(r16)
8112a788:	18001c26 	beq	r3,zero,8112a7fc <__swsetup_r+0xdc>
8112a78c:	0005883a 	mov	r2,zero
8112a790:	dfc00217 	ldw	ra,8(sp)
8112a794:	dc400117 	ldw	r17,4(sp)
8112a798:	dc000017 	ldw	r16,0(sp)
8112a79c:	dec00304 	addi	sp,sp,12
8112a7a0:	f800283a 	ret
8112a7a4:	2080040c 	andi	r2,r4,16
8112a7a8:	10002e26 	beq	r2,zero,8112a864 <__swsetup_r+0x144>
8112a7ac:	2080010c 	andi	r2,r4,4
8112a7b0:	10001e1e 	bne	r2,zero,8112a82c <__swsetup_r+0x10c>
8112a7b4:	80c00417 	ldw	r3,16(r16)
8112a7b8:	20800214 	ori	r2,r4,8
8112a7bc:	8080030d 	sth	r2,12(r16)
8112a7c0:	183feb1e 	bne	r3,zero,8112a770 <__reset+0xfb10a770>
8112a7c4:	1100a00c 	andi	r4,r2,640
8112a7c8:	01408004 	movi	r5,512
8112a7cc:	217fe826 	beq	r4,r5,8112a770 <__reset+0xfb10a770>
8112a7d0:	800b883a 	mov	r5,r16
8112a7d4:	8809883a 	mov	r4,r17
8112a7d8:	112306c0 	call	8112306c <__smakebuf_r>
8112a7dc:	8080030b 	ldhu	r2,12(r16)
8112a7e0:	80c00417 	ldw	r3,16(r16)
8112a7e4:	003fe206 	br	8112a770 <__reset+0xfb10a770>
8112a7e8:	80800517 	ldw	r2,20(r16)
8112a7ec:	80000215 	stw	zero,8(r16)
8112a7f0:	0085c83a 	sub	r2,zero,r2
8112a7f4:	80800615 	stw	r2,24(r16)
8112a7f8:	183fe41e 	bne	r3,zero,8112a78c <__reset+0xfb10a78c>
8112a7fc:	80c0030b 	ldhu	r3,12(r16)
8112a800:	0005883a 	mov	r2,zero
8112a804:	1900200c 	andi	r4,r3,128
8112a808:	203fe126 	beq	r4,zero,8112a790 <__reset+0xfb10a790>
8112a80c:	18c01014 	ori	r3,r3,64
8112a810:	80c0030d 	sth	r3,12(r16)
8112a814:	00bfffc4 	movi	r2,-1
8112a818:	003fdd06 	br	8112a790 <__reset+0xfb10a790>
8112a81c:	112c7900 	call	8112c790 <__sinit>
8112a820:	003fcd06 	br	8112a758 <__reset+0xfb10a758>
8112a824:	0005883a 	mov	r2,zero
8112a828:	003fd606 	br	8112a784 <__reset+0xfb10a784>
8112a82c:	81400c17 	ldw	r5,48(r16)
8112a830:	28000626 	beq	r5,zero,8112a84c <__swsetup_r+0x12c>
8112a834:	80801004 	addi	r2,r16,64
8112a838:	28800326 	beq	r5,r2,8112a848 <__swsetup_r+0x128>
8112a83c:	8809883a 	mov	r4,r17
8112a840:	112cc280 	call	8112cc28 <_free_r>
8112a844:	8100030b 	ldhu	r4,12(r16)
8112a848:	80000c15 	stw	zero,48(r16)
8112a84c:	80c00417 	ldw	r3,16(r16)
8112a850:	00bff6c4 	movi	r2,-37
8112a854:	1108703a 	and	r4,r2,r4
8112a858:	80000115 	stw	zero,4(r16)
8112a85c:	80c00015 	stw	r3,0(r16)
8112a860:	003fd506 	br	8112a7b8 <__reset+0xfb10a7b8>
8112a864:	00800244 	movi	r2,9
8112a868:	88800015 	stw	r2,0(r17)
8112a86c:	20801014 	ori	r2,r4,64
8112a870:	8080030d 	sth	r2,12(r16)
8112a874:	00bfffc4 	movi	r2,-1
8112a878:	003fc506 	br	8112a790 <__reset+0xfb10a790>

8112a87c <_close_r>:
8112a87c:	defffd04 	addi	sp,sp,-12
8112a880:	de00012e 	bgeu	sp,et,8112a888 <_close_r+0xc>
8112a884:	003b68fa 	trap	3
8112a888:	dc000015 	stw	r16,0(sp)
8112a88c:	04204574 	movhi	r16,33045
8112a890:	dc400115 	stw	r17,4(sp)
8112a894:	84118604 	addi	r16,r16,17944
8112a898:	2023883a 	mov	r17,r4
8112a89c:	2809883a 	mov	r4,r5
8112a8a0:	dfc00215 	stw	ra,8(sp)
8112a8a4:	80000015 	stw	zero,0(r16)
8112a8a8:	11377300 	call	81137730 <close>
8112a8ac:	00ffffc4 	movi	r3,-1
8112a8b0:	10c00526 	beq	r2,r3,8112a8c8 <_close_r+0x4c>
8112a8b4:	dfc00217 	ldw	ra,8(sp)
8112a8b8:	dc400117 	ldw	r17,4(sp)
8112a8bc:	dc000017 	ldw	r16,0(sp)
8112a8c0:	dec00304 	addi	sp,sp,12
8112a8c4:	f800283a 	ret
8112a8c8:	80c00017 	ldw	r3,0(r16)
8112a8cc:	183ff926 	beq	r3,zero,8112a8b4 <__reset+0xfb10a8b4>
8112a8d0:	88c00015 	stw	r3,0(r17)
8112a8d4:	003ff706 	br	8112a8b4 <__reset+0xfb10a8b4>

8112a8d8 <quorem>:
8112a8d8:	defff704 	addi	sp,sp,-36
8112a8dc:	de00012e 	bgeu	sp,et,8112a8e4 <quorem+0xc>
8112a8e0:	003b68fa 	trap	3
8112a8e4:	dc800215 	stw	r18,8(sp)
8112a8e8:	20800417 	ldw	r2,16(r4)
8112a8ec:	2c800417 	ldw	r18,16(r5)
8112a8f0:	dfc00815 	stw	ra,32(sp)
8112a8f4:	ddc00715 	stw	r23,28(sp)
8112a8f8:	dd800615 	stw	r22,24(sp)
8112a8fc:	dd400515 	stw	r21,20(sp)
8112a900:	dd000415 	stw	r20,16(sp)
8112a904:	dcc00315 	stw	r19,12(sp)
8112a908:	dc400115 	stw	r17,4(sp)
8112a90c:	dc000015 	stw	r16,0(sp)
8112a910:	14807116 	blt	r2,r18,8112aad8 <quorem+0x200>
8112a914:	94bfffc4 	addi	r18,r18,-1
8112a918:	94ad883a 	add	r22,r18,r18
8112a91c:	b5ad883a 	add	r22,r22,r22
8112a920:	2c400504 	addi	r17,r5,20
8112a924:	8da9883a 	add	r20,r17,r22
8112a928:	25400504 	addi	r21,r4,20
8112a92c:	282f883a 	mov	r23,r5
8112a930:	adad883a 	add	r22,r21,r22
8112a934:	a1400017 	ldw	r5,0(r20)
8112a938:	2021883a 	mov	r16,r4
8112a93c:	b1000017 	ldw	r4,0(r22)
8112a940:	29400044 	addi	r5,r5,1
8112a944:	1135f340 	call	81135f34 <__udivsi3>
8112a948:	1027883a 	mov	r19,r2
8112a94c:	10002c26 	beq	r2,zero,8112aa00 <quorem+0x128>
8112a950:	a813883a 	mov	r9,r21
8112a954:	880b883a 	mov	r5,r17
8112a958:	0009883a 	mov	r4,zero
8112a95c:	000d883a 	mov	r6,zero
8112a960:	2a000017 	ldw	r8,0(r5)
8112a964:	49c00017 	ldw	r7,0(r9)
8112a968:	29400104 	addi	r5,r5,4
8112a96c:	40bfffcc 	andi	r2,r8,65535
8112a970:	14c5383a 	mul	r2,r2,r19
8112a974:	4010d43a 	srli	r8,r8,16
8112a978:	38ffffcc 	andi	r3,r7,65535
8112a97c:	1105883a 	add	r2,r2,r4
8112a980:	1008d43a 	srli	r4,r2,16
8112a984:	44d1383a 	mul	r8,r8,r19
8112a988:	198d883a 	add	r6,r3,r6
8112a98c:	10ffffcc 	andi	r3,r2,65535
8112a990:	30c7c83a 	sub	r3,r6,r3
8112a994:	380ed43a 	srli	r7,r7,16
8112a998:	4105883a 	add	r2,r8,r4
8112a99c:	180dd43a 	srai	r6,r3,16
8112a9a0:	113fffcc 	andi	r4,r2,65535
8112a9a4:	390fc83a 	sub	r7,r7,r4
8112a9a8:	398d883a 	add	r6,r7,r6
8112a9ac:	300e943a 	slli	r7,r6,16
8112a9b0:	18ffffcc 	andi	r3,r3,65535
8112a9b4:	1008d43a 	srli	r4,r2,16
8112a9b8:	38ceb03a 	or	r7,r7,r3
8112a9bc:	49c00015 	stw	r7,0(r9)
8112a9c0:	300dd43a 	srai	r6,r6,16
8112a9c4:	4a400104 	addi	r9,r9,4
8112a9c8:	a17fe52e 	bgeu	r20,r5,8112a960 <__reset+0xfb10a960>
8112a9cc:	b0800017 	ldw	r2,0(r22)
8112a9d0:	10000b1e 	bne	r2,zero,8112aa00 <quorem+0x128>
8112a9d4:	b0bfff04 	addi	r2,r22,-4
8112a9d8:	a880082e 	bgeu	r21,r2,8112a9fc <quorem+0x124>
8112a9dc:	b0ffff17 	ldw	r3,-4(r22)
8112a9e0:	18000326 	beq	r3,zero,8112a9f0 <quorem+0x118>
8112a9e4:	00000506 	br	8112a9fc <quorem+0x124>
8112a9e8:	10c00017 	ldw	r3,0(r2)
8112a9ec:	1800031e 	bne	r3,zero,8112a9fc <quorem+0x124>
8112a9f0:	10bfff04 	addi	r2,r2,-4
8112a9f4:	94bfffc4 	addi	r18,r18,-1
8112a9f8:	a8bffb36 	bltu	r21,r2,8112a9e8 <__reset+0xfb10a9e8>
8112a9fc:	84800415 	stw	r18,16(r16)
8112aa00:	b80b883a 	mov	r5,r23
8112aa04:	8009883a 	mov	r4,r16
8112aa08:	112e4f80 	call	8112e4f8 <__mcmp>
8112aa0c:	10002616 	blt	r2,zero,8112aaa8 <quorem+0x1d0>
8112aa10:	9cc00044 	addi	r19,r19,1
8112aa14:	a805883a 	mov	r2,r21
8112aa18:	000b883a 	mov	r5,zero
8112aa1c:	11000017 	ldw	r4,0(r2)
8112aa20:	89800017 	ldw	r6,0(r17)
8112aa24:	10800104 	addi	r2,r2,4
8112aa28:	20ffffcc 	andi	r3,r4,65535
8112aa2c:	194b883a 	add	r5,r3,r5
8112aa30:	30ffffcc 	andi	r3,r6,65535
8112aa34:	28c7c83a 	sub	r3,r5,r3
8112aa38:	300cd43a 	srli	r6,r6,16
8112aa3c:	2008d43a 	srli	r4,r4,16
8112aa40:	180bd43a 	srai	r5,r3,16
8112aa44:	18ffffcc 	andi	r3,r3,65535
8112aa48:	2189c83a 	sub	r4,r4,r6
8112aa4c:	2149883a 	add	r4,r4,r5
8112aa50:	200c943a 	slli	r6,r4,16
8112aa54:	8c400104 	addi	r17,r17,4
8112aa58:	200bd43a 	srai	r5,r4,16
8112aa5c:	30c6b03a 	or	r3,r6,r3
8112aa60:	10ffff15 	stw	r3,-4(r2)
8112aa64:	a47fed2e 	bgeu	r20,r17,8112aa1c <__reset+0xfb10aa1c>
8112aa68:	9485883a 	add	r2,r18,r18
8112aa6c:	1085883a 	add	r2,r2,r2
8112aa70:	a887883a 	add	r3,r21,r2
8112aa74:	18800017 	ldw	r2,0(r3)
8112aa78:	10000b1e 	bne	r2,zero,8112aaa8 <quorem+0x1d0>
8112aa7c:	18bfff04 	addi	r2,r3,-4
8112aa80:	a880082e 	bgeu	r21,r2,8112aaa4 <quorem+0x1cc>
8112aa84:	18ffff17 	ldw	r3,-4(r3)
8112aa88:	18000326 	beq	r3,zero,8112aa98 <quorem+0x1c0>
8112aa8c:	00000506 	br	8112aaa4 <quorem+0x1cc>
8112aa90:	10c00017 	ldw	r3,0(r2)
8112aa94:	1800031e 	bne	r3,zero,8112aaa4 <quorem+0x1cc>
8112aa98:	10bfff04 	addi	r2,r2,-4
8112aa9c:	94bfffc4 	addi	r18,r18,-1
8112aaa0:	a8bffb36 	bltu	r21,r2,8112aa90 <__reset+0xfb10aa90>
8112aaa4:	84800415 	stw	r18,16(r16)
8112aaa8:	9805883a 	mov	r2,r19
8112aaac:	dfc00817 	ldw	ra,32(sp)
8112aab0:	ddc00717 	ldw	r23,28(sp)
8112aab4:	dd800617 	ldw	r22,24(sp)
8112aab8:	dd400517 	ldw	r21,20(sp)
8112aabc:	dd000417 	ldw	r20,16(sp)
8112aac0:	dcc00317 	ldw	r19,12(sp)
8112aac4:	dc800217 	ldw	r18,8(sp)
8112aac8:	dc400117 	ldw	r17,4(sp)
8112aacc:	dc000017 	ldw	r16,0(sp)
8112aad0:	dec00904 	addi	sp,sp,36
8112aad4:	f800283a 	ret
8112aad8:	0005883a 	mov	r2,zero
8112aadc:	003ff306 	br	8112aaac <__reset+0xfb10aaac>

8112aae0 <_dtoa_r>:
8112aae0:	deffde04 	addi	sp,sp,-136
8112aae4:	de00012e 	bgeu	sp,et,8112aaec <_dtoa_r+0xc>
8112aae8:	003b68fa 	trap	3
8112aaec:	20801017 	ldw	r2,64(r4)
8112aaf0:	df002015 	stw	fp,128(sp)
8112aaf4:	dcc01b15 	stw	r19,108(sp)
8112aaf8:	dc801a15 	stw	r18,104(sp)
8112aafc:	dc401915 	stw	r17,100(sp)
8112ab00:	dc001815 	stw	r16,96(sp)
8112ab04:	dfc02115 	stw	ra,132(sp)
8112ab08:	ddc01f15 	stw	r23,124(sp)
8112ab0c:	dd801e15 	stw	r22,120(sp)
8112ab10:	dd401d15 	stw	r21,116(sp)
8112ab14:	dd001c15 	stw	r20,112(sp)
8112ab18:	d9c00315 	stw	r7,12(sp)
8112ab1c:	2039883a 	mov	fp,r4
8112ab20:	3023883a 	mov	r17,r6
8112ab24:	2825883a 	mov	r18,r5
8112ab28:	dc002417 	ldw	r16,144(sp)
8112ab2c:	3027883a 	mov	r19,r6
8112ab30:	10000826 	beq	r2,zero,8112ab54 <_dtoa_r+0x74>
8112ab34:	21801117 	ldw	r6,68(r4)
8112ab38:	00c00044 	movi	r3,1
8112ab3c:	100b883a 	mov	r5,r2
8112ab40:	1986983a 	sll	r3,r3,r6
8112ab44:	11800115 	stw	r6,4(r2)
8112ab48:	10c00215 	stw	r3,8(r2)
8112ab4c:	112dca80 	call	8112dca8 <_Bfree>
8112ab50:	e0001015 	stw	zero,64(fp)
8112ab54:	88002e16 	blt	r17,zero,8112ac10 <_dtoa_r+0x130>
8112ab58:	80000015 	stw	zero,0(r16)
8112ab5c:	889ffc2c 	andhi	r2,r17,32752
8112ab60:	00dffc34 	movhi	r3,32752
8112ab64:	10c01c26 	beq	r2,r3,8112abd8 <_dtoa_r+0xf8>
8112ab68:	000d883a 	mov	r6,zero
8112ab6c:	000f883a 	mov	r7,zero
8112ab70:	9009883a 	mov	r4,r18
8112ab74:	980b883a 	mov	r5,r19
8112ab78:	11373900 	call	81137390 <__eqdf2>
8112ab7c:	10002b1e 	bne	r2,zero,8112ac2c <_dtoa_r+0x14c>
8112ab80:	d9c02317 	ldw	r7,140(sp)
8112ab84:	00800044 	movi	r2,1
8112ab88:	38800015 	stw	r2,0(r7)
8112ab8c:	d8802517 	ldw	r2,148(sp)
8112ab90:	10019e26 	beq	r2,zero,8112b20c <_dtoa_r+0x72c>
8112ab94:	d8c02517 	ldw	r3,148(sp)
8112ab98:	00a04574 	movhi	r2,33045
8112ab9c:	10874b44 	addi	r2,r2,7469
8112aba0:	18800015 	stw	r2,0(r3)
8112aba4:	10bfffc4 	addi	r2,r2,-1
8112aba8:	dfc02117 	ldw	ra,132(sp)
8112abac:	df002017 	ldw	fp,128(sp)
8112abb0:	ddc01f17 	ldw	r23,124(sp)
8112abb4:	dd801e17 	ldw	r22,120(sp)
8112abb8:	dd401d17 	ldw	r21,116(sp)
8112abbc:	dd001c17 	ldw	r20,112(sp)
8112abc0:	dcc01b17 	ldw	r19,108(sp)
8112abc4:	dc801a17 	ldw	r18,104(sp)
8112abc8:	dc401917 	ldw	r17,100(sp)
8112abcc:	dc001817 	ldw	r16,96(sp)
8112abd0:	dec02204 	addi	sp,sp,136
8112abd4:	f800283a 	ret
8112abd8:	d8c02317 	ldw	r3,140(sp)
8112abdc:	0089c3c4 	movi	r2,9999
8112abe0:	18800015 	stw	r2,0(r3)
8112abe4:	90017726 	beq	r18,zero,8112b1c4 <_dtoa_r+0x6e4>
8112abe8:	00a04574 	movhi	r2,33045
8112abec:	10876904 	addi	r2,r2,7588
8112abf0:	d9002517 	ldw	r4,148(sp)
8112abf4:	203fec26 	beq	r4,zero,8112aba8 <__reset+0xfb10aba8>
8112abf8:	10c000c7 	ldb	r3,3(r2)
8112abfc:	1801781e 	bne	r3,zero,8112b1e0 <_dtoa_r+0x700>
8112ac00:	10c000c4 	addi	r3,r2,3
8112ac04:	d9802517 	ldw	r6,148(sp)
8112ac08:	30c00015 	stw	r3,0(r6)
8112ac0c:	003fe606 	br	8112aba8 <__reset+0xfb10aba8>
8112ac10:	04e00034 	movhi	r19,32768
8112ac14:	9cffffc4 	addi	r19,r19,-1
8112ac18:	00800044 	movi	r2,1
8112ac1c:	8ce6703a 	and	r19,r17,r19
8112ac20:	80800015 	stw	r2,0(r16)
8112ac24:	9823883a 	mov	r17,r19
8112ac28:	003fcc06 	br	8112ab5c <__reset+0xfb10ab5c>
8112ac2c:	d8800204 	addi	r2,sp,8
8112ac30:	d8800015 	stw	r2,0(sp)
8112ac34:	d9c00104 	addi	r7,sp,4
8112ac38:	900b883a 	mov	r5,r18
8112ac3c:	980d883a 	mov	r6,r19
8112ac40:	e009883a 	mov	r4,fp
8112ac44:	8820d53a 	srli	r16,r17,20
8112ac48:	112e8d40 	call	8112e8d4 <__d2b>
8112ac4c:	d8800915 	stw	r2,36(sp)
8112ac50:	8001651e 	bne	r16,zero,8112b1e8 <_dtoa_r+0x708>
8112ac54:	dd800217 	ldw	r22,8(sp)
8112ac58:	dc000117 	ldw	r16,4(sp)
8112ac5c:	00800804 	movi	r2,32
8112ac60:	b421883a 	add	r16,r22,r16
8112ac64:	80c10c84 	addi	r3,r16,1074
8112ac68:	10c2d10e 	bge	r2,r3,8112b7b0 <_dtoa_r+0xcd0>
8112ac6c:	00801004 	movi	r2,64
8112ac70:	81010484 	addi	r4,r16,1042
8112ac74:	10c7c83a 	sub	r3,r2,r3
8112ac78:	9108d83a 	srl	r4,r18,r4
8112ac7c:	88e2983a 	sll	r17,r17,r3
8112ac80:	2448b03a 	or	r4,r4,r17
8112ac84:	113750c0 	call	8113750c <__floatunsidf>
8112ac88:	017f8434 	movhi	r5,65040
8112ac8c:	01800044 	movi	r6,1
8112ac90:	1009883a 	mov	r4,r2
8112ac94:	194b883a 	add	r5,r3,r5
8112ac98:	843fffc4 	addi	r16,r16,-1
8112ac9c:	d9801115 	stw	r6,68(sp)
8112aca0:	000d883a 	mov	r6,zero
8112aca4:	01cffe34 	movhi	r7,16376
8112aca8:	1121aac0 	call	81121aac <__subdf3>
8112acac:	0198dbf4 	movhi	r6,25455
8112acb0:	01cff4f4 	movhi	r7,16339
8112acb4:	3190d844 	addi	r6,r6,17249
8112acb8:	39e1e9c4 	addi	r7,r7,-30809
8112acbc:	1009883a 	mov	r4,r2
8112acc0:	180b883a 	mov	r5,r3
8112acc4:	112138c0 	call	8112138c <__muldf3>
8112acc8:	01a2d874 	movhi	r6,35681
8112accc:	01cff1f4 	movhi	r7,16327
8112acd0:	31b22cc4 	addi	r6,r6,-14157
8112acd4:	39e28a04 	addi	r7,r7,-30168
8112acd8:	180b883a 	mov	r5,r3
8112acdc:	1009883a 	mov	r4,r2
8112ace0:	11361ec0 	call	811361ec <__adddf3>
8112ace4:	8009883a 	mov	r4,r16
8112ace8:	1029883a 	mov	r20,r2
8112acec:	1823883a 	mov	r17,r3
8112acf0:	11224300 	call	81122430 <__floatsidf>
8112acf4:	019427f4 	movhi	r6,20639
8112acf8:	01cff4f4 	movhi	r7,16339
8112acfc:	319e7ec4 	addi	r6,r6,31227
8112ad00:	39d104c4 	addi	r7,r7,17427
8112ad04:	1009883a 	mov	r4,r2
8112ad08:	180b883a 	mov	r5,r3
8112ad0c:	112138c0 	call	8112138c <__muldf3>
8112ad10:	100d883a 	mov	r6,r2
8112ad14:	180f883a 	mov	r7,r3
8112ad18:	a009883a 	mov	r4,r20
8112ad1c:	880b883a 	mov	r5,r17
8112ad20:	11361ec0 	call	811361ec <__adddf3>
8112ad24:	1009883a 	mov	r4,r2
8112ad28:	180b883a 	mov	r5,r3
8112ad2c:	1029883a 	mov	r20,r2
8112ad30:	1823883a 	mov	r17,r3
8112ad34:	11223b00 	call	811223b0 <__fixdfsi>
8112ad38:	000d883a 	mov	r6,zero
8112ad3c:	000f883a 	mov	r7,zero
8112ad40:	a009883a 	mov	r4,r20
8112ad44:	880b883a 	mov	r5,r17
8112ad48:	d8800515 	stw	r2,20(sp)
8112ad4c:	11374180 	call	81137418 <__ledf2>
8112ad50:	10028716 	blt	r2,zero,8112b770 <_dtoa_r+0xc90>
8112ad54:	d8c00517 	ldw	r3,20(sp)
8112ad58:	00800584 	movi	r2,22
8112ad5c:	10c27536 	bltu	r2,r3,8112b734 <_dtoa_r+0xc54>
8112ad60:	180490fa 	slli	r2,r3,3
8112ad64:	00e04574 	movhi	r3,33045
8112ad68:	18c78404 	addi	r3,r3,7696
8112ad6c:	1885883a 	add	r2,r3,r2
8112ad70:	11000017 	ldw	r4,0(r2)
8112ad74:	11400117 	ldw	r5,4(r2)
8112ad78:	900d883a 	mov	r6,r18
8112ad7c:	980f883a 	mov	r7,r19
8112ad80:	11212b00 	call	811212b0 <__gedf2>
8112ad84:	00828d0e 	bge	zero,r2,8112b7bc <_dtoa_r+0xcdc>
8112ad88:	d9000517 	ldw	r4,20(sp)
8112ad8c:	d8000e15 	stw	zero,56(sp)
8112ad90:	213fffc4 	addi	r4,r4,-1
8112ad94:	d9000515 	stw	r4,20(sp)
8112ad98:	b42dc83a 	sub	r22,r22,r16
8112ad9c:	b5bfffc4 	addi	r22,r22,-1
8112ada0:	b0026f16 	blt	r22,zero,8112b760 <_dtoa_r+0xc80>
8112ada4:	d8000815 	stw	zero,32(sp)
8112ada8:	d9c00517 	ldw	r7,20(sp)
8112adac:	38026416 	blt	r7,zero,8112b740 <_dtoa_r+0xc60>
8112adb0:	b1ed883a 	add	r22,r22,r7
8112adb4:	d9c00d15 	stw	r7,52(sp)
8112adb8:	d8000a15 	stw	zero,40(sp)
8112adbc:	d9800317 	ldw	r6,12(sp)
8112adc0:	00800244 	movi	r2,9
8112adc4:	11811436 	bltu	r2,r6,8112b218 <_dtoa_r+0x738>
8112adc8:	00800144 	movi	r2,5
8112adcc:	1184e10e 	bge	r2,r6,8112c154 <_dtoa_r+0x1674>
8112add0:	31bfff04 	addi	r6,r6,-4
8112add4:	d9800315 	stw	r6,12(sp)
8112add8:	0023883a 	mov	r17,zero
8112addc:	d9800317 	ldw	r6,12(sp)
8112ade0:	008000c4 	movi	r2,3
8112ade4:	30836726 	beq	r6,r2,8112bb84 <_dtoa_r+0x10a4>
8112ade8:	1183410e 	bge	r2,r6,8112baf0 <_dtoa_r+0x1010>
8112adec:	d9c00317 	ldw	r7,12(sp)
8112adf0:	00800104 	movi	r2,4
8112adf4:	38827c26 	beq	r7,r2,8112b7e8 <_dtoa_r+0xd08>
8112adf8:	00800144 	movi	r2,5
8112adfc:	3884c41e 	bne	r7,r2,8112c110 <_dtoa_r+0x1630>
8112ae00:	00800044 	movi	r2,1
8112ae04:	d8800b15 	stw	r2,44(sp)
8112ae08:	d8c00517 	ldw	r3,20(sp)
8112ae0c:	d9002217 	ldw	r4,136(sp)
8112ae10:	1907883a 	add	r3,r3,r4
8112ae14:	19800044 	addi	r6,r3,1
8112ae18:	d8c00c15 	stw	r3,48(sp)
8112ae1c:	d9800615 	stw	r6,24(sp)
8112ae20:	0183a40e 	bge	zero,r6,8112bcb4 <_dtoa_r+0x11d4>
8112ae24:	d9800617 	ldw	r6,24(sp)
8112ae28:	3021883a 	mov	r16,r6
8112ae2c:	e0001115 	stw	zero,68(fp)
8112ae30:	008005c4 	movi	r2,23
8112ae34:	1184c92e 	bgeu	r2,r6,8112c15c <_dtoa_r+0x167c>
8112ae38:	00c00044 	movi	r3,1
8112ae3c:	00800104 	movi	r2,4
8112ae40:	1085883a 	add	r2,r2,r2
8112ae44:	11000504 	addi	r4,r2,20
8112ae48:	180b883a 	mov	r5,r3
8112ae4c:	18c00044 	addi	r3,r3,1
8112ae50:	313ffb2e 	bgeu	r6,r4,8112ae40 <__reset+0xfb10ae40>
8112ae54:	e1401115 	stw	r5,68(fp)
8112ae58:	e009883a 	mov	r4,fp
8112ae5c:	112dbf80 	call	8112dbf8 <_Balloc>
8112ae60:	d8800715 	stw	r2,28(sp)
8112ae64:	e0801015 	stw	r2,64(fp)
8112ae68:	00800384 	movi	r2,14
8112ae6c:	1400f736 	bltu	r2,r16,8112b24c <_dtoa_r+0x76c>
8112ae70:	8800f626 	beq	r17,zero,8112b24c <_dtoa_r+0x76c>
8112ae74:	d9c00517 	ldw	r7,20(sp)
8112ae78:	01c39a0e 	bge	zero,r7,8112bce4 <_dtoa_r+0x1204>
8112ae7c:	388003cc 	andi	r2,r7,15
8112ae80:	100490fa 	slli	r2,r2,3
8112ae84:	382bd13a 	srai	r21,r7,4
8112ae88:	00e04574 	movhi	r3,33045
8112ae8c:	18c78404 	addi	r3,r3,7696
8112ae90:	1885883a 	add	r2,r3,r2
8112ae94:	a8c0040c 	andi	r3,r21,16
8112ae98:	12400017 	ldw	r9,0(r2)
8112ae9c:	12000117 	ldw	r8,4(r2)
8112aea0:	18037926 	beq	r3,zero,8112bc88 <_dtoa_r+0x11a8>
8112aea4:	00a04574 	movhi	r2,33045
8112aea8:	10877a04 	addi	r2,r2,7656
8112aeac:	11800817 	ldw	r6,32(r2)
8112aeb0:	11c00917 	ldw	r7,36(r2)
8112aeb4:	9009883a 	mov	r4,r18
8112aeb8:	980b883a 	mov	r5,r19
8112aebc:	da001715 	stw	r8,92(sp)
8112aec0:	da401615 	stw	r9,88(sp)
8112aec4:	1136aa00 	call	81136aa0 <__divdf3>
8112aec8:	da001717 	ldw	r8,92(sp)
8112aecc:	da401617 	ldw	r9,88(sp)
8112aed0:	ad4003cc 	andi	r21,r21,15
8112aed4:	040000c4 	movi	r16,3
8112aed8:	1023883a 	mov	r17,r2
8112aedc:	1829883a 	mov	r20,r3
8112aee0:	a8001126 	beq	r21,zero,8112af28 <_dtoa_r+0x448>
8112aee4:	05e04574 	movhi	r23,33045
8112aee8:	bdc77a04 	addi	r23,r23,7656
8112aeec:	4805883a 	mov	r2,r9
8112aef0:	4007883a 	mov	r3,r8
8112aef4:	a980004c 	andi	r6,r21,1
8112aef8:	1009883a 	mov	r4,r2
8112aefc:	a82bd07a 	srai	r21,r21,1
8112af00:	180b883a 	mov	r5,r3
8112af04:	30000426 	beq	r6,zero,8112af18 <_dtoa_r+0x438>
8112af08:	b9800017 	ldw	r6,0(r23)
8112af0c:	b9c00117 	ldw	r7,4(r23)
8112af10:	84000044 	addi	r16,r16,1
8112af14:	112138c0 	call	8112138c <__muldf3>
8112af18:	bdc00204 	addi	r23,r23,8
8112af1c:	a83ff51e 	bne	r21,zero,8112aef4 <__reset+0xfb10aef4>
8112af20:	1013883a 	mov	r9,r2
8112af24:	1811883a 	mov	r8,r3
8112af28:	480d883a 	mov	r6,r9
8112af2c:	400f883a 	mov	r7,r8
8112af30:	8809883a 	mov	r4,r17
8112af34:	a00b883a 	mov	r5,r20
8112af38:	1136aa00 	call	81136aa0 <__divdf3>
8112af3c:	d8800f15 	stw	r2,60(sp)
8112af40:	d8c01015 	stw	r3,64(sp)
8112af44:	d8c00e17 	ldw	r3,56(sp)
8112af48:	18000626 	beq	r3,zero,8112af64 <_dtoa_r+0x484>
8112af4c:	d9000f17 	ldw	r4,60(sp)
8112af50:	d9401017 	ldw	r5,64(sp)
8112af54:	000d883a 	mov	r6,zero
8112af58:	01cffc34 	movhi	r7,16368
8112af5c:	11374180 	call	81137418 <__ledf2>
8112af60:	10040b16 	blt	r2,zero,8112bf90 <_dtoa_r+0x14b0>
8112af64:	8009883a 	mov	r4,r16
8112af68:	11224300 	call	81122430 <__floatsidf>
8112af6c:	d9800f17 	ldw	r6,60(sp)
8112af70:	d9c01017 	ldw	r7,64(sp)
8112af74:	1009883a 	mov	r4,r2
8112af78:	180b883a 	mov	r5,r3
8112af7c:	112138c0 	call	8112138c <__muldf3>
8112af80:	000d883a 	mov	r6,zero
8112af84:	01d00734 	movhi	r7,16412
8112af88:	1009883a 	mov	r4,r2
8112af8c:	180b883a 	mov	r5,r3
8112af90:	11361ec0 	call	811361ec <__adddf3>
8112af94:	1021883a 	mov	r16,r2
8112af98:	d8800617 	ldw	r2,24(sp)
8112af9c:	047f3034 	movhi	r17,64704
8112afa0:	1c63883a 	add	r17,r3,r17
8112afa4:	10031826 	beq	r2,zero,8112bc08 <_dtoa_r+0x1128>
8112afa8:	d8c00517 	ldw	r3,20(sp)
8112afac:	db000617 	ldw	r12,24(sp)
8112afb0:	d8c01315 	stw	r3,76(sp)
8112afb4:	d9000b17 	ldw	r4,44(sp)
8112afb8:	20038f26 	beq	r4,zero,8112bdf8 <_dtoa_r+0x1318>
8112afbc:	60bfffc4 	addi	r2,r12,-1
8112afc0:	100490fa 	slli	r2,r2,3
8112afc4:	00e04574 	movhi	r3,33045
8112afc8:	18c78404 	addi	r3,r3,7696
8112afcc:	1885883a 	add	r2,r3,r2
8112afd0:	11800017 	ldw	r6,0(r2)
8112afd4:	11c00117 	ldw	r7,4(r2)
8112afd8:	d8800717 	ldw	r2,28(sp)
8112afdc:	0009883a 	mov	r4,zero
8112afe0:	014ff834 	movhi	r5,16352
8112afe4:	db001615 	stw	r12,88(sp)
8112afe8:	15c00044 	addi	r23,r2,1
8112afec:	1136aa00 	call	81136aa0 <__divdf3>
8112aff0:	800d883a 	mov	r6,r16
8112aff4:	880f883a 	mov	r7,r17
8112aff8:	1009883a 	mov	r4,r2
8112affc:	180b883a 	mov	r5,r3
8112b000:	1121aac0 	call	81121aac <__subdf3>
8112b004:	d9401017 	ldw	r5,64(sp)
8112b008:	d9000f17 	ldw	r4,60(sp)
8112b00c:	102b883a 	mov	r21,r2
8112b010:	d8c01215 	stw	r3,72(sp)
8112b014:	11223b00 	call	811223b0 <__fixdfsi>
8112b018:	1009883a 	mov	r4,r2
8112b01c:	1029883a 	mov	r20,r2
8112b020:	11224300 	call	81122430 <__floatsidf>
8112b024:	d9000f17 	ldw	r4,60(sp)
8112b028:	d9401017 	ldw	r5,64(sp)
8112b02c:	100d883a 	mov	r6,r2
8112b030:	180f883a 	mov	r7,r3
8112b034:	1121aac0 	call	81121aac <__subdf3>
8112b038:	1823883a 	mov	r17,r3
8112b03c:	d8c00717 	ldw	r3,28(sp)
8112b040:	d9401217 	ldw	r5,72(sp)
8112b044:	a2000c04 	addi	r8,r20,48
8112b048:	1021883a 	mov	r16,r2
8112b04c:	1a000005 	stb	r8,0(r3)
8112b050:	800d883a 	mov	r6,r16
8112b054:	880f883a 	mov	r7,r17
8112b058:	a809883a 	mov	r4,r21
8112b05c:	4029883a 	mov	r20,r8
8112b060:	11212b00 	call	811212b0 <__gedf2>
8112b064:	00841d16 	blt	zero,r2,8112c0dc <_dtoa_r+0x15fc>
8112b068:	800d883a 	mov	r6,r16
8112b06c:	880f883a 	mov	r7,r17
8112b070:	0009883a 	mov	r4,zero
8112b074:	014ffc34 	movhi	r5,16368
8112b078:	1121aac0 	call	81121aac <__subdf3>
8112b07c:	d9401217 	ldw	r5,72(sp)
8112b080:	100d883a 	mov	r6,r2
8112b084:	180f883a 	mov	r7,r3
8112b088:	a809883a 	mov	r4,r21
8112b08c:	11212b00 	call	811212b0 <__gedf2>
8112b090:	db001617 	ldw	r12,88(sp)
8112b094:	00840e16 	blt	zero,r2,8112c0d0 <_dtoa_r+0x15f0>
8112b098:	00800044 	movi	r2,1
8112b09c:	13006b0e 	bge	r2,r12,8112b24c <_dtoa_r+0x76c>
8112b0a0:	d9000717 	ldw	r4,28(sp)
8112b0a4:	dd800f15 	stw	r22,60(sp)
8112b0a8:	dcc01015 	stw	r19,64(sp)
8112b0ac:	2319883a 	add	r12,r4,r12
8112b0b0:	dcc01217 	ldw	r19,72(sp)
8112b0b4:	602d883a 	mov	r22,r12
8112b0b8:	dc801215 	stw	r18,72(sp)
8112b0bc:	b825883a 	mov	r18,r23
8112b0c0:	00000906 	br	8112b0e8 <_dtoa_r+0x608>
8112b0c4:	1121aac0 	call	81121aac <__subdf3>
8112b0c8:	a80d883a 	mov	r6,r21
8112b0cc:	980f883a 	mov	r7,r19
8112b0d0:	1009883a 	mov	r4,r2
8112b0d4:	180b883a 	mov	r5,r3
8112b0d8:	11374180 	call	81137418 <__ledf2>
8112b0dc:	1003e816 	blt	r2,zero,8112c080 <_dtoa_r+0x15a0>
8112b0e0:	b825883a 	mov	r18,r23
8112b0e4:	bd83e926 	beq	r23,r22,8112c08c <_dtoa_r+0x15ac>
8112b0e8:	a809883a 	mov	r4,r21
8112b0ec:	980b883a 	mov	r5,r19
8112b0f0:	000d883a 	mov	r6,zero
8112b0f4:	01d00934 	movhi	r7,16420
8112b0f8:	112138c0 	call	8112138c <__muldf3>
8112b0fc:	000d883a 	mov	r6,zero
8112b100:	01d00934 	movhi	r7,16420
8112b104:	8009883a 	mov	r4,r16
8112b108:	880b883a 	mov	r5,r17
8112b10c:	102b883a 	mov	r21,r2
8112b110:	1827883a 	mov	r19,r3
8112b114:	112138c0 	call	8112138c <__muldf3>
8112b118:	180b883a 	mov	r5,r3
8112b11c:	1009883a 	mov	r4,r2
8112b120:	1821883a 	mov	r16,r3
8112b124:	1023883a 	mov	r17,r2
8112b128:	11223b00 	call	811223b0 <__fixdfsi>
8112b12c:	1009883a 	mov	r4,r2
8112b130:	1029883a 	mov	r20,r2
8112b134:	11224300 	call	81122430 <__floatsidf>
8112b138:	8809883a 	mov	r4,r17
8112b13c:	800b883a 	mov	r5,r16
8112b140:	100d883a 	mov	r6,r2
8112b144:	180f883a 	mov	r7,r3
8112b148:	1121aac0 	call	81121aac <__subdf3>
8112b14c:	a5000c04 	addi	r20,r20,48
8112b150:	a80d883a 	mov	r6,r21
8112b154:	980f883a 	mov	r7,r19
8112b158:	1009883a 	mov	r4,r2
8112b15c:	180b883a 	mov	r5,r3
8112b160:	95000005 	stb	r20,0(r18)
8112b164:	1021883a 	mov	r16,r2
8112b168:	1823883a 	mov	r17,r3
8112b16c:	11374180 	call	81137418 <__ledf2>
8112b170:	bdc00044 	addi	r23,r23,1
8112b174:	800d883a 	mov	r6,r16
8112b178:	880f883a 	mov	r7,r17
8112b17c:	0009883a 	mov	r4,zero
8112b180:	014ffc34 	movhi	r5,16368
8112b184:	103fcf0e 	bge	r2,zero,8112b0c4 <__reset+0xfb10b0c4>
8112b188:	d8c01317 	ldw	r3,76(sp)
8112b18c:	d8c00515 	stw	r3,20(sp)
8112b190:	d9400917 	ldw	r5,36(sp)
8112b194:	e009883a 	mov	r4,fp
8112b198:	112dca80 	call	8112dca8 <_Bfree>
8112b19c:	d9000517 	ldw	r4,20(sp)
8112b1a0:	d9802317 	ldw	r6,140(sp)
8112b1a4:	d9c02517 	ldw	r7,148(sp)
8112b1a8:	b8000005 	stb	zero,0(r23)
8112b1ac:	20800044 	addi	r2,r4,1
8112b1b0:	30800015 	stw	r2,0(r6)
8112b1b4:	3802aa26 	beq	r7,zero,8112bc60 <_dtoa_r+0x1180>
8112b1b8:	3dc00015 	stw	r23,0(r7)
8112b1bc:	d8800717 	ldw	r2,28(sp)
8112b1c0:	003e7906 	br	8112aba8 <__reset+0xfb10aba8>
8112b1c4:	00800434 	movhi	r2,16
8112b1c8:	10bfffc4 	addi	r2,r2,-1
8112b1cc:	88a2703a 	and	r17,r17,r2
8112b1d0:	883e851e 	bne	r17,zero,8112abe8 <__reset+0xfb10abe8>
8112b1d4:	00a04574 	movhi	r2,33045
8112b1d8:	10876604 	addi	r2,r2,7576
8112b1dc:	003e8406 	br	8112abf0 <__reset+0xfb10abf0>
8112b1e0:	10c00204 	addi	r3,r2,8
8112b1e4:	003e8706 	br	8112ac04 <__reset+0xfb10ac04>
8112b1e8:	01400434 	movhi	r5,16
8112b1ec:	297fffc4 	addi	r5,r5,-1
8112b1f0:	994a703a 	and	r5,r19,r5
8112b1f4:	9009883a 	mov	r4,r18
8112b1f8:	843f0044 	addi	r16,r16,-1023
8112b1fc:	294ffc34 	orhi	r5,r5,16368
8112b200:	dd800217 	ldw	r22,8(sp)
8112b204:	d8001115 	stw	zero,68(sp)
8112b208:	003ea506 	br	8112aca0 <__reset+0xfb10aca0>
8112b20c:	00a04574 	movhi	r2,33045
8112b210:	10874b04 	addi	r2,r2,7468
8112b214:	003e6406 	br	8112aba8 <__reset+0xfb10aba8>
8112b218:	e0001115 	stw	zero,68(fp)
8112b21c:	000b883a 	mov	r5,zero
8112b220:	e009883a 	mov	r4,fp
8112b224:	112dbf80 	call	8112dbf8 <_Balloc>
8112b228:	01bfffc4 	movi	r6,-1
8112b22c:	01c00044 	movi	r7,1
8112b230:	d8800715 	stw	r2,28(sp)
8112b234:	d9800c15 	stw	r6,48(sp)
8112b238:	e0801015 	stw	r2,64(fp)
8112b23c:	d8000315 	stw	zero,12(sp)
8112b240:	d9c00b15 	stw	r7,44(sp)
8112b244:	d9800615 	stw	r6,24(sp)
8112b248:	d8002215 	stw	zero,136(sp)
8112b24c:	d8800117 	ldw	r2,4(sp)
8112b250:	10008916 	blt	r2,zero,8112b478 <_dtoa_r+0x998>
8112b254:	d9000517 	ldw	r4,20(sp)
8112b258:	00c00384 	movi	r3,14
8112b25c:	19008616 	blt	r3,r4,8112b478 <_dtoa_r+0x998>
8112b260:	200490fa 	slli	r2,r4,3
8112b264:	00e04574 	movhi	r3,33045
8112b268:	d9802217 	ldw	r6,136(sp)
8112b26c:	18c78404 	addi	r3,r3,7696
8112b270:	1885883a 	add	r2,r3,r2
8112b274:	14000017 	ldw	r16,0(r2)
8112b278:	14400117 	ldw	r17,4(r2)
8112b27c:	30016316 	blt	r6,zero,8112b80c <_dtoa_r+0xd2c>
8112b280:	800d883a 	mov	r6,r16
8112b284:	880f883a 	mov	r7,r17
8112b288:	9009883a 	mov	r4,r18
8112b28c:	980b883a 	mov	r5,r19
8112b290:	1136aa00 	call	81136aa0 <__divdf3>
8112b294:	180b883a 	mov	r5,r3
8112b298:	1009883a 	mov	r4,r2
8112b29c:	11223b00 	call	811223b0 <__fixdfsi>
8112b2a0:	1009883a 	mov	r4,r2
8112b2a4:	102b883a 	mov	r21,r2
8112b2a8:	11224300 	call	81122430 <__floatsidf>
8112b2ac:	800d883a 	mov	r6,r16
8112b2b0:	880f883a 	mov	r7,r17
8112b2b4:	1009883a 	mov	r4,r2
8112b2b8:	180b883a 	mov	r5,r3
8112b2bc:	112138c0 	call	8112138c <__muldf3>
8112b2c0:	100d883a 	mov	r6,r2
8112b2c4:	180f883a 	mov	r7,r3
8112b2c8:	9009883a 	mov	r4,r18
8112b2cc:	980b883a 	mov	r5,r19
8112b2d0:	1121aac0 	call	81121aac <__subdf3>
8112b2d4:	d9c00717 	ldw	r7,28(sp)
8112b2d8:	1009883a 	mov	r4,r2
8112b2dc:	a8800c04 	addi	r2,r21,48
8112b2e0:	38800005 	stb	r2,0(r7)
8112b2e4:	3dc00044 	addi	r23,r7,1
8112b2e8:	d9c00617 	ldw	r7,24(sp)
8112b2ec:	01800044 	movi	r6,1
8112b2f0:	180b883a 	mov	r5,r3
8112b2f4:	2005883a 	mov	r2,r4
8112b2f8:	39803826 	beq	r7,r6,8112b3dc <_dtoa_r+0x8fc>
8112b2fc:	000d883a 	mov	r6,zero
8112b300:	01d00934 	movhi	r7,16420
8112b304:	112138c0 	call	8112138c <__muldf3>
8112b308:	000d883a 	mov	r6,zero
8112b30c:	000f883a 	mov	r7,zero
8112b310:	1009883a 	mov	r4,r2
8112b314:	180b883a 	mov	r5,r3
8112b318:	1025883a 	mov	r18,r2
8112b31c:	1827883a 	mov	r19,r3
8112b320:	11373900 	call	81137390 <__eqdf2>
8112b324:	103f9a26 	beq	r2,zero,8112b190 <__reset+0xfb10b190>
8112b328:	d9c00617 	ldw	r7,24(sp)
8112b32c:	d8c00717 	ldw	r3,28(sp)
8112b330:	b829883a 	mov	r20,r23
8112b334:	38bfffc4 	addi	r2,r7,-1
8112b338:	18ad883a 	add	r22,r3,r2
8112b33c:	00000a06 	br	8112b368 <_dtoa_r+0x888>
8112b340:	112138c0 	call	8112138c <__muldf3>
8112b344:	000d883a 	mov	r6,zero
8112b348:	000f883a 	mov	r7,zero
8112b34c:	1009883a 	mov	r4,r2
8112b350:	180b883a 	mov	r5,r3
8112b354:	1025883a 	mov	r18,r2
8112b358:	1827883a 	mov	r19,r3
8112b35c:	b829883a 	mov	r20,r23
8112b360:	11373900 	call	81137390 <__eqdf2>
8112b364:	103f8a26 	beq	r2,zero,8112b190 <__reset+0xfb10b190>
8112b368:	800d883a 	mov	r6,r16
8112b36c:	880f883a 	mov	r7,r17
8112b370:	9009883a 	mov	r4,r18
8112b374:	980b883a 	mov	r5,r19
8112b378:	1136aa00 	call	81136aa0 <__divdf3>
8112b37c:	180b883a 	mov	r5,r3
8112b380:	1009883a 	mov	r4,r2
8112b384:	11223b00 	call	811223b0 <__fixdfsi>
8112b388:	1009883a 	mov	r4,r2
8112b38c:	102b883a 	mov	r21,r2
8112b390:	11224300 	call	81122430 <__floatsidf>
8112b394:	800d883a 	mov	r6,r16
8112b398:	880f883a 	mov	r7,r17
8112b39c:	1009883a 	mov	r4,r2
8112b3a0:	180b883a 	mov	r5,r3
8112b3a4:	112138c0 	call	8112138c <__muldf3>
8112b3a8:	100d883a 	mov	r6,r2
8112b3ac:	180f883a 	mov	r7,r3
8112b3b0:	9009883a 	mov	r4,r18
8112b3b4:	980b883a 	mov	r5,r19
8112b3b8:	1121aac0 	call	81121aac <__subdf3>
8112b3bc:	aa000c04 	addi	r8,r21,48
8112b3c0:	a2000005 	stb	r8,0(r20)
8112b3c4:	000d883a 	mov	r6,zero
8112b3c8:	01d00934 	movhi	r7,16420
8112b3cc:	1009883a 	mov	r4,r2
8112b3d0:	180b883a 	mov	r5,r3
8112b3d4:	a5c00044 	addi	r23,r20,1
8112b3d8:	b53fd91e 	bne	r22,r20,8112b340 <__reset+0xfb10b340>
8112b3dc:	100d883a 	mov	r6,r2
8112b3e0:	180f883a 	mov	r7,r3
8112b3e4:	1009883a 	mov	r4,r2
8112b3e8:	180b883a 	mov	r5,r3
8112b3ec:	11361ec0 	call	811361ec <__adddf3>
8112b3f0:	100d883a 	mov	r6,r2
8112b3f4:	180f883a 	mov	r7,r3
8112b3f8:	8009883a 	mov	r4,r16
8112b3fc:	880b883a 	mov	r5,r17
8112b400:	1027883a 	mov	r19,r2
8112b404:	1825883a 	mov	r18,r3
8112b408:	11374180 	call	81137418 <__ledf2>
8112b40c:	10000816 	blt	r2,zero,8112b430 <_dtoa_r+0x950>
8112b410:	980d883a 	mov	r6,r19
8112b414:	900f883a 	mov	r7,r18
8112b418:	8009883a 	mov	r4,r16
8112b41c:	880b883a 	mov	r5,r17
8112b420:	11373900 	call	81137390 <__eqdf2>
8112b424:	103f5a1e 	bne	r2,zero,8112b190 <__reset+0xfb10b190>
8112b428:	ad40004c 	andi	r21,r21,1
8112b42c:	a83f5826 	beq	r21,zero,8112b190 <__reset+0xfb10b190>
8112b430:	bd3fffc3 	ldbu	r20,-1(r23)
8112b434:	b8bfffc4 	addi	r2,r23,-1
8112b438:	1007883a 	mov	r3,r2
8112b43c:	01400e44 	movi	r5,57
8112b440:	d9800717 	ldw	r6,28(sp)
8112b444:	00000506 	br	8112b45c <_dtoa_r+0x97c>
8112b448:	18ffffc4 	addi	r3,r3,-1
8112b44c:	11824726 	beq	r2,r6,8112bd6c <_dtoa_r+0x128c>
8112b450:	1d000003 	ldbu	r20,0(r3)
8112b454:	102f883a 	mov	r23,r2
8112b458:	10bfffc4 	addi	r2,r2,-1
8112b45c:	a1003fcc 	andi	r4,r20,255
8112b460:	2100201c 	xori	r4,r4,128
8112b464:	213fe004 	addi	r4,r4,-128
8112b468:	217ff726 	beq	r4,r5,8112b448 <__reset+0xfb10b448>
8112b46c:	a2000044 	addi	r8,r20,1
8112b470:	12000005 	stb	r8,0(r2)
8112b474:	003f4606 	br	8112b190 <__reset+0xfb10b190>
8112b478:	d9000b17 	ldw	r4,44(sp)
8112b47c:	2000c826 	beq	r4,zero,8112b7a0 <_dtoa_r+0xcc0>
8112b480:	d9800317 	ldw	r6,12(sp)
8112b484:	00c00044 	movi	r3,1
8112b488:	1980f90e 	bge	r3,r6,8112b870 <_dtoa_r+0xd90>
8112b48c:	d8800617 	ldw	r2,24(sp)
8112b490:	d8c00a17 	ldw	r3,40(sp)
8112b494:	157fffc4 	addi	r21,r2,-1
8112b498:	1d41f316 	blt	r3,r21,8112bc68 <_dtoa_r+0x1188>
8112b49c:	1d6bc83a 	sub	r21,r3,r21
8112b4a0:	d9c00617 	ldw	r7,24(sp)
8112b4a4:	3802aa16 	blt	r7,zero,8112bf50 <_dtoa_r+0x1470>
8112b4a8:	dd000817 	ldw	r20,32(sp)
8112b4ac:	d8800617 	ldw	r2,24(sp)
8112b4b0:	d8c00817 	ldw	r3,32(sp)
8112b4b4:	01400044 	movi	r5,1
8112b4b8:	e009883a 	mov	r4,fp
8112b4bc:	1887883a 	add	r3,r3,r2
8112b4c0:	d8c00815 	stw	r3,32(sp)
8112b4c4:	b0ad883a 	add	r22,r22,r2
8112b4c8:	112e01c0 	call	8112e01c <__i2b>
8112b4cc:	1023883a 	mov	r17,r2
8112b4d0:	a0000826 	beq	r20,zero,8112b4f4 <_dtoa_r+0xa14>
8112b4d4:	0580070e 	bge	zero,r22,8112b4f4 <_dtoa_r+0xa14>
8112b4d8:	a005883a 	mov	r2,r20
8112b4dc:	b500b916 	blt	r22,r20,8112b7c4 <_dtoa_r+0xce4>
8112b4e0:	d9000817 	ldw	r4,32(sp)
8112b4e4:	a0a9c83a 	sub	r20,r20,r2
8112b4e8:	b0adc83a 	sub	r22,r22,r2
8112b4ec:	2089c83a 	sub	r4,r4,r2
8112b4f0:	d9000815 	stw	r4,32(sp)
8112b4f4:	d9800a17 	ldw	r6,40(sp)
8112b4f8:	0181810e 	bge	zero,r6,8112bb00 <_dtoa_r+0x1020>
8112b4fc:	d9c00b17 	ldw	r7,44(sp)
8112b500:	3800b326 	beq	r7,zero,8112b7d0 <_dtoa_r+0xcf0>
8112b504:	a800b226 	beq	r21,zero,8112b7d0 <_dtoa_r+0xcf0>
8112b508:	880b883a 	mov	r5,r17
8112b50c:	a80d883a 	mov	r6,r21
8112b510:	e009883a 	mov	r4,fp
8112b514:	112e2600 	call	8112e260 <__pow5mult>
8112b518:	d9800917 	ldw	r6,36(sp)
8112b51c:	100b883a 	mov	r5,r2
8112b520:	e009883a 	mov	r4,fp
8112b524:	1023883a 	mov	r17,r2
8112b528:	112e0600 	call	8112e060 <__multiply>
8112b52c:	1021883a 	mov	r16,r2
8112b530:	d8800a17 	ldw	r2,40(sp)
8112b534:	d9400917 	ldw	r5,36(sp)
8112b538:	e009883a 	mov	r4,fp
8112b53c:	1545c83a 	sub	r2,r2,r21
8112b540:	d8800a15 	stw	r2,40(sp)
8112b544:	112dca80 	call	8112dca8 <_Bfree>
8112b548:	d8c00a17 	ldw	r3,40(sp)
8112b54c:	18009f1e 	bne	r3,zero,8112b7cc <_dtoa_r+0xcec>
8112b550:	05c00044 	movi	r23,1
8112b554:	e009883a 	mov	r4,fp
8112b558:	b80b883a 	mov	r5,r23
8112b55c:	112e01c0 	call	8112e01c <__i2b>
8112b560:	d9000d17 	ldw	r4,52(sp)
8112b564:	102b883a 	mov	r21,r2
8112b568:	2000ce26 	beq	r4,zero,8112b8a4 <_dtoa_r+0xdc4>
8112b56c:	200d883a 	mov	r6,r4
8112b570:	100b883a 	mov	r5,r2
8112b574:	e009883a 	mov	r4,fp
8112b578:	112e2600 	call	8112e260 <__pow5mult>
8112b57c:	d9800317 	ldw	r6,12(sp)
8112b580:	102b883a 	mov	r21,r2
8112b584:	b981810e 	bge	r23,r6,8112bb8c <_dtoa_r+0x10ac>
8112b588:	0027883a 	mov	r19,zero
8112b58c:	a8800417 	ldw	r2,16(r21)
8112b590:	05c00804 	movi	r23,32
8112b594:	10800104 	addi	r2,r2,4
8112b598:	1085883a 	add	r2,r2,r2
8112b59c:	1085883a 	add	r2,r2,r2
8112b5a0:	a885883a 	add	r2,r21,r2
8112b5a4:	11000017 	ldw	r4,0(r2)
8112b5a8:	112df040 	call	8112df04 <__hi0bits>
8112b5ac:	b885c83a 	sub	r2,r23,r2
8112b5b0:	1585883a 	add	r2,r2,r22
8112b5b4:	108007cc 	andi	r2,r2,31
8112b5b8:	1000b326 	beq	r2,zero,8112b888 <_dtoa_r+0xda8>
8112b5bc:	00c00804 	movi	r3,32
8112b5c0:	1887c83a 	sub	r3,r3,r2
8112b5c4:	01000104 	movi	r4,4
8112b5c8:	20c2cd0e 	bge	r4,r3,8112c100 <_dtoa_r+0x1620>
8112b5cc:	00c00704 	movi	r3,28
8112b5d0:	1885c83a 	sub	r2,r3,r2
8112b5d4:	d8c00817 	ldw	r3,32(sp)
8112b5d8:	a0a9883a 	add	r20,r20,r2
8112b5dc:	b0ad883a 	add	r22,r22,r2
8112b5e0:	1887883a 	add	r3,r3,r2
8112b5e4:	d8c00815 	stw	r3,32(sp)
8112b5e8:	d9800817 	ldw	r6,32(sp)
8112b5ec:	0180040e 	bge	zero,r6,8112b600 <_dtoa_r+0xb20>
8112b5f0:	800b883a 	mov	r5,r16
8112b5f4:	e009883a 	mov	r4,fp
8112b5f8:	112e3a80 	call	8112e3a8 <__lshift>
8112b5fc:	1021883a 	mov	r16,r2
8112b600:	0580050e 	bge	zero,r22,8112b618 <_dtoa_r+0xb38>
8112b604:	a80b883a 	mov	r5,r21
8112b608:	b00d883a 	mov	r6,r22
8112b60c:	e009883a 	mov	r4,fp
8112b610:	112e3a80 	call	8112e3a8 <__lshift>
8112b614:	102b883a 	mov	r21,r2
8112b618:	d9c00e17 	ldw	r7,56(sp)
8112b61c:	3801211e 	bne	r7,zero,8112baa4 <_dtoa_r+0xfc4>
8112b620:	d9800617 	ldw	r6,24(sp)
8112b624:	0181380e 	bge	zero,r6,8112bb08 <_dtoa_r+0x1028>
8112b628:	d8c00b17 	ldw	r3,44(sp)
8112b62c:	1800ab1e 	bne	r3,zero,8112b8dc <_dtoa_r+0xdfc>
8112b630:	dc800717 	ldw	r18,28(sp)
8112b634:	dcc00617 	ldw	r19,24(sp)
8112b638:	9029883a 	mov	r20,r18
8112b63c:	00000206 	br	8112b648 <_dtoa_r+0xb68>
8112b640:	112dcd00 	call	8112dcd0 <__multadd>
8112b644:	1021883a 	mov	r16,r2
8112b648:	a80b883a 	mov	r5,r21
8112b64c:	8009883a 	mov	r4,r16
8112b650:	112a8d80 	call	8112a8d8 <quorem>
8112b654:	10800c04 	addi	r2,r2,48
8112b658:	90800005 	stb	r2,0(r18)
8112b65c:	94800044 	addi	r18,r18,1
8112b660:	9507c83a 	sub	r3,r18,r20
8112b664:	000f883a 	mov	r7,zero
8112b668:	01800284 	movi	r6,10
8112b66c:	800b883a 	mov	r5,r16
8112b670:	e009883a 	mov	r4,fp
8112b674:	1cfff216 	blt	r3,r19,8112b640 <__reset+0xfb10b640>
8112b678:	1011883a 	mov	r8,r2
8112b67c:	d8800617 	ldw	r2,24(sp)
8112b680:	0082370e 	bge	zero,r2,8112bf60 <_dtoa_r+0x1480>
8112b684:	d9000717 	ldw	r4,28(sp)
8112b688:	0025883a 	mov	r18,zero
8112b68c:	20af883a 	add	r23,r4,r2
8112b690:	01800044 	movi	r6,1
8112b694:	800b883a 	mov	r5,r16
8112b698:	e009883a 	mov	r4,fp
8112b69c:	da001715 	stw	r8,92(sp)
8112b6a0:	112e3a80 	call	8112e3a8 <__lshift>
8112b6a4:	a80b883a 	mov	r5,r21
8112b6a8:	1009883a 	mov	r4,r2
8112b6ac:	d8800915 	stw	r2,36(sp)
8112b6b0:	112e4f80 	call	8112e4f8 <__mcmp>
8112b6b4:	da001717 	ldw	r8,92(sp)
8112b6b8:	0081800e 	bge	zero,r2,8112bcbc <_dtoa_r+0x11dc>
8112b6bc:	b93fffc3 	ldbu	r4,-1(r23)
8112b6c0:	b8bfffc4 	addi	r2,r23,-1
8112b6c4:	1007883a 	mov	r3,r2
8112b6c8:	01800e44 	movi	r6,57
8112b6cc:	d9c00717 	ldw	r7,28(sp)
8112b6d0:	00000506 	br	8112b6e8 <_dtoa_r+0xc08>
8112b6d4:	18ffffc4 	addi	r3,r3,-1
8112b6d8:	11c12326 	beq	r2,r7,8112bb68 <_dtoa_r+0x1088>
8112b6dc:	19000003 	ldbu	r4,0(r3)
8112b6e0:	102f883a 	mov	r23,r2
8112b6e4:	10bfffc4 	addi	r2,r2,-1
8112b6e8:	21403fcc 	andi	r5,r4,255
8112b6ec:	2940201c 	xori	r5,r5,128
8112b6f0:	297fe004 	addi	r5,r5,-128
8112b6f4:	29bff726 	beq	r5,r6,8112b6d4 <__reset+0xfb10b6d4>
8112b6f8:	21000044 	addi	r4,r4,1
8112b6fc:	11000005 	stb	r4,0(r2)
8112b700:	a80b883a 	mov	r5,r21
8112b704:	e009883a 	mov	r4,fp
8112b708:	112dca80 	call	8112dca8 <_Bfree>
8112b70c:	883ea026 	beq	r17,zero,8112b190 <__reset+0xfb10b190>
8112b710:	90000426 	beq	r18,zero,8112b724 <_dtoa_r+0xc44>
8112b714:	94400326 	beq	r18,r17,8112b724 <_dtoa_r+0xc44>
8112b718:	900b883a 	mov	r5,r18
8112b71c:	e009883a 	mov	r4,fp
8112b720:	112dca80 	call	8112dca8 <_Bfree>
8112b724:	880b883a 	mov	r5,r17
8112b728:	e009883a 	mov	r4,fp
8112b72c:	112dca80 	call	8112dca8 <_Bfree>
8112b730:	003e9706 	br	8112b190 <__reset+0xfb10b190>
8112b734:	01800044 	movi	r6,1
8112b738:	d9800e15 	stw	r6,56(sp)
8112b73c:	003d9606 	br	8112ad98 <__reset+0xfb10ad98>
8112b740:	d8800817 	ldw	r2,32(sp)
8112b744:	d8c00517 	ldw	r3,20(sp)
8112b748:	d8000d15 	stw	zero,52(sp)
8112b74c:	10c5c83a 	sub	r2,r2,r3
8112b750:	00c9c83a 	sub	r4,zero,r3
8112b754:	d8800815 	stw	r2,32(sp)
8112b758:	d9000a15 	stw	r4,40(sp)
8112b75c:	003d9706 	br	8112adbc <__reset+0xfb10adbc>
8112b760:	05adc83a 	sub	r22,zero,r22
8112b764:	dd800815 	stw	r22,32(sp)
8112b768:	002d883a 	mov	r22,zero
8112b76c:	003d8e06 	br	8112ada8 <__reset+0xfb10ada8>
8112b770:	d9000517 	ldw	r4,20(sp)
8112b774:	11224300 	call	81122430 <__floatsidf>
8112b778:	100d883a 	mov	r6,r2
8112b77c:	180f883a 	mov	r7,r3
8112b780:	a009883a 	mov	r4,r20
8112b784:	880b883a 	mov	r5,r17
8112b788:	11373900 	call	81137390 <__eqdf2>
8112b78c:	103d7126 	beq	r2,zero,8112ad54 <__reset+0xfb10ad54>
8112b790:	d9c00517 	ldw	r7,20(sp)
8112b794:	39ffffc4 	addi	r7,r7,-1
8112b798:	d9c00515 	stw	r7,20(sp)
8112b79c:	003d6d06 	br	8112ad54 <__reset+0xfb10ad54>
8112b7a0:	dd400a17 	ldw	r21,40(sp)
8112b7a4:	dd000817 	ldw	r20,32(sp)
8112b7a8:	0023883a 	mov	r17,zero
8112b7ac:	003f4806 	br	8112b4d0 <__reset+0xfb10b4d0>
8112b7b0:	10e3c83a 	sub	r17,r2,r3
8112b7b4:	9448983a 	sll	r4,r18,r17
8112b7b8:	003d3206 	br	8112ac84 <__reset+0xfb10ac84>
8112b7bc:	d8000e15 	stw	zero,56(sp)
8112b7c0:	003d7506 	br	8112ad98 <__reset+0xfb10ad98>
8112b7c4:	b005883a 	mov	r2,r22
8112b7c8:	003f4506 	br	8112b4e0 <__reset+0xfb10b4e0>
8112b7cc:	dc000915 	stw	r16,36(sp)
8112b7d0:	d9800a17 	ldw	r6,40(sp)
8112b7d4:	d9400917 	ldw	r5,36(sp)
8112b7d8:	e009883a 	mov	r4,fp
8112b7dc:	112e2600 	call	8112e260 <__pow5mult>
8112b7e0:	1021883a 	mov	r16,r2
8112b7e4:	003f5a06 	br	8112b550 <__reset+0xfb10b550>
8112b7e8:	01c00044 	movi	r7,1
8112b7ec:	d9c00b15 	stw	r7,44(sp)
8112b7f0:	d8802217 	ldw	r2,136(sp)
8112b7f4:	0081280e 	bge	zero,r2,8112bc98 <_dtoa_r+0x11b8>
8112b7f8:	100d883a 	mov	r6,r2
8112b7fc:	1021883a 	mov	r16,r2
8112b800:	d8800c15 	stw	r2,48(sp)
8112b804:	d8800615 	stw	r2,24(sp)
8112b808:	003d8806 	br	8112ae2c <__reset+0xfb10ae2c>
8112b80c:	d8800617 	ldw	r2,24(sp)
8112b810:	00be9b16 	blt	zero,r2,8112b280 <__reset+0xfb10b280>
8112b814:	10010f1e 	bne	r2,zero,8112bc54 <_dtoa_r+0x1174>
8112b818:	880b883a 	mov	r5,r17
8112b81c:	000d883a 	mov	r6,zero
8112b820:	01d00534 	movhi	r7,16404
8112b824:	8009883a 	mov	r4,r16
8112b828:	112138c0 	call	8112138c <__muldf3>
8112b82c:	900d883a 	mov	r6,r18
8112b830:	980f883a 	mov	r7,r19
8112b834:	1009883a 	mov	r4,r2
8112b838:	180b883a 	mov	r5,r3
8112b83c:	11212b00 	call	811212b0 <__gedf2>
8112b840:	002b883a 	mov	r21,zero
8112b844:	0023883a 	mov	r17,zero
8112b848:	1000bf16 	blt	r2,zero,8112bb48 <_dtoa_r+0x1068>
8112b84c:	d9802217 	ldw	r6,136(sp)
8112b850:	ddc00717 	ldw	r23,28(sp)
8112b854:	018c303a 	nor	r6,zero,r6
8112b858:	d9800515 	stw	r6,20(sp)
8112b85c:	a80b883a 	mov	r5,r21
8112b860:	e009883a 	mov	r4,fp
8112b864:	112dca80 	call	8112dca8 <_Bfree>
8112b868:	883e4926 	beq	r17,zero,8112b190 <__reset+0xfb10b190>
8112b86c:	003fad06 	br	8112b724 <__reset+0xfb10b724>
8112b870:	d9c01117 	ldw	r7,68(sp)
8112b874:	3801bc26 	beq	r7,zero,8112bf68 <_dtoa_r+0x1488>
8112b878:	10810cc4 	addi	r2,r2,1075
8112b87c:	dd400a17 	ldw	r21,40(sp)
8112b880:	dd000817 	ldw	r20,32(sp)
8112b884:	003f0a06 	br	8112b4b0 <__reset+0xfb10b4b0>
8112b888:	00800704 	movi	r2,28
8112b88c:	d9000817 	ldw	r4,32(sp)
8112b890:	a0a9883a 	add	r20,r20,r2
8112b894:	b0ad883a 	add	r22,r22,r2
8112b898:	2089883a 	add	r4,r4,r2
8112b89c:	d9000815 	stw	r4,32(sp)
8112b8a0:	003f5106 	br	8112b5e8 <__reset+0xfb10b5e8>
8112b8a4:	d8c00317 	ldw	r3,12(sp)
8112b8a8:	b8c1fc0e 	bge	r23,r3,8112c09c <_dtoa_r+0x15bc>
8112b8ac:	0027883a 	mov	r19,zero
8112b8b0:	b805883a 	mov	r2,r23
8112b8b4:	003f3e06 	br	8112b5b0 <__reset+0xfb10b5b0>
8112b8b8:	880b883a 	mov	r5,r17
8112b8bc:	e009883a 	mov	r4,fp
8112b8c0:	000f883a 	mov	r7,zero
8112b8c4:	01800284 	movi	r6,10
8112b8c8:	112dcd00 	call	8112dcd0 <__multadd>
8112b8cc:	d9000c17 	ldw	r4,48(sp)
8112b8d0:	1023883a 	mov	r17,r2
8112b8d4:	0102040e 	bge	zero,r4,8112c0e8 <_dtoa_r+0x1608>
8112b8d8:	d9000615 	stw	r4,24(sp)
8112b8dc:	0500050e 	bge	zero,r20,8112b8f4 <_dtoa_r+0xe14>
8112b8e0:	880b883a 	mov	r5,r17
8112b8e4:	a00d883a 	mov	r6,r20
8112b8e8:	e009883a 	mov	r4,fp
8112b8ec:	112e3a80 	call	8112e3a8 <__lshift>
8112b8f0:	1023883a 	mov	r17,r2
8112b8f4:	9801241e 	bne	r19,zero,8112bd88 <_dtoa_r+0x12a8>
8112b8f8:	8829883a 	mov	r20,r17
8112b8fc:	d9000617 	ldw	r4,24(sp)
8112b900:	dcc00717 	ldw	r19,28(sp)
8112b904:	9480004c 	andi	r18,r18,1
8112b908:	20bfffc4 	addi	r2,r4,-1
8112b90c:	9885883a 	add	r2,r19,r2
8112b910:	d8800415 	stw	r2,16(sp)
8112b914:	dc800615 	stw	r18,24(sp)
8112b918:	a80b883a 	mov	r5,r21
8112b91c:	8009883a 	mov	r4,r16
8112b920:	112a8d80 	call	8112a8d8 <quorem>
8112b924:	880b883a 	mov	r5,r17
8112b928:	8009883a 	mov	r4,r16
8112b92c:	102f883a 	mov	r23,r2
8112b930:	112e4f80 	call	8112e4f8 <__mcmp>
8112b934:	a80b883a 	mov	r5,r21
8112b938:	a00d883a 	mov	r6,r20
8112b93c:	e009883a 	mov	r4,fp
8112b940:	102d883a 	mov	r22,r2
8112b944:	112e5580 	call	8112e558 <__mdiff>
8112b948:	1007883a 	mov	r3,r2
8112b94c:	10800317 	ldw	r2,12(r2)
8112b950:	bc800c04 	addi	r18,r23,48
8112b954:	180b883a 	mov	r5,r3
8112b958:	10004e1e 	bne	r2,zero,8112ba94 <_dtoa_r+0xfb4>
8112b95c:	8009883a 	mov	r4,r16
8112b960:	d8c01615 	stw	r3,88(sp)
8112b964:	112e4f80 	call	8112e4f8 <__mcmp>
8112b968:	d8c01617 	ldw	r3,88(sp)
8112b96c:	e009883a 	mov	r4,fp
8112b970:	d8801615 	stw	r2,88(sp)
8112b974:	180b883a 	mov	r5,r3
8112b978:	112dca80 	call	8112dca8 <_Bfree>
8112b97c:	d8801617 	ldw	r2,88(sp)
8112b980:	1000041e 	bne	r2,zero,8112b994 <_dtoa_r+0xeb4>
8112b984:	d9800317 	ldw	r6,12(sp)
8112b988:	3000021e 	bne	r6,zero,8112b994 <_dtoa_r+0xeb4>
8112b98c:	d8c00617 	ldw	r3,24(sp)
8112b990:	18003726 	beq	r3,zero,8112ba70 <_dtoa_r+0xf90>
8112b994:	b0002016 	blt	r22,zero,8112ba18 <_dtoa_r+0xf38>
8112b998:	b000041e 	bne	r22,zero,8112b9ac <_dtoa_r+0xecc>
8112b99c:	d9000317 	ldw	r4,12(sp)
8112b9a0:	2000021e 	bne	r4,zero,8112b9ac <_dtoa_r+0xecc>
8112b9a4:	d8c00617 	ldw	r3,24(sp)
8112b9a8:	18001b26 	beq	r3,zero,8112ba18 <_dtoa_r+0xf38>
8112b9ac:	00810716 	blt	zero,r2,8112bdcc <_dtoa_r+0x12ec>
8112b9b0:	d8c00417 	ldw	r3,16(sp)
8112b9b4:	9d800044 	addi	r22,r19,1
8112b9b8:	9c800005 	stb	r18,0(r19)
8112b9bc:	b02f883a 	mov	r23,r22
8112b9c0:	98c10626 	beq	r19,r3,8112bddc <_dtoa_r+0x12fc>
8112b9c4:	800b883a 	mov	r5,r16
8112b9c8:	000f883a 	mov	r7,zero
8112b9cc:	01800284 	movi	r6,10
8112b9d0:	e009883a 	mov	r4,fp
8112b9d4:	112dcd00 	call	8112dcd0 <__multadd>
8112b9d8:	1021883a 	mov	r16,r2
8112b9dc:	000f883a 	mov	r7,zero
8112b9e0:	01800284 	movi	r6,10
8112b9e4:	880b883a 	mov	r5,r17
8112b9e8:	e009883a 	mov	r4,fp
8112b9ec:	8d002526 	beq	r17,r20,8112ba84 <_dtoa_r+0xfa4>
8112b9f0:	112dcd00 	call	8112dcd0 <__multadd>
8112b9f4:	a00b883a 	mov	r5,r20
8112b9f8:	000f883a 	mov	r7,zero
8112b9fc:	01800284 	movi	r6,10
8112ba00:	e009883a 	mov	r4,fp
8112ba04:	1023883a 	mov	r17,r2
8112ba08:	112dcd00 	call	8112dcd0 <__multadd>
8112ba0c:	1029883a 	mov	r20,r2
8112ba10:	b027883a 	mov	r19,r22
8112ba14:	003fc006 	br	8112b918 <__reset+0xfb10b918>
8112ba18:	9011883a 	mov	r8,r18
8112ba1c:	00800e0e 	bge	zero,r2,8112ba58 <_dtoa_r+0xf78>
8112ba20:	800b883a 	mov	r5,r16
8112ba24:	01800044 	movi	r6,1
8112ba28:	e009883a 	mov	r4,fp
8112ba2c:	da001715 	stw	r8,92(sp)
8112ba30:	112e3a80 	call	8112e3a8 <__lshift>
8112ba34:	a80b883a 	mov	r5,r21
8112ba38:	1009883a 	mov	r4,r2
8112ba3c:	1021883a 	mov	r16,r2
8112ba40:	112e4f80 	call	8112e4f8 <__mcmp>
8112ba44:	da001717 	ldw	r8,92(sp)
8112ba48:	0081960e 	bge	zero,r2,8112c0a4 <_dtoa_r+0x15c4>
8112ba4c:	00800e44 	movi	r2,57
8112ba50:	40817026 	beq	r8,r2,8112c014 <_dtoa_r+0x1534>
8112ba54:	ba000c44 	addi	r8,r23,49
8112ba58:	8825883a 	mov	r18,r17
8112ba5c:	9dc00044 	addi	r23,r19,1
8112ba60:	9a000005 	stb	r8,0(r19)
8112ba64:	a023883a 	mov	r17,r20
8112ba68:	dc000915 	stw	r16,36(sp)
8112ba6c:	003f2406 	br	8112b700 <__reset+0xfb10b700>
8112ba70:	00800e44 	movi	r2,57
8112ba74:	9011883a 	mov	r8,r18
8112ba78:	90816626 	beq	r18,r2,8112c014 <_dtoa_r+0x1534>
8112ba7c:	05bff516 	blt	zero,r22,8112ba54 <__reset+0xfb10ba54>
8112ba80:	003ff506 	br	8112ba58 <__reset+0xfb10ba58>
8112ba84:	112dcd00 	call	8112dcd0 <__multadd>
8112ba88:	1023883a 	mov	r17,r2
8112ba8c:	1029883a 	mov	r20,r2
8112ba90:	003fdf06 	br	8112ba10 <__reset+0xfb10ba10>
8112ba94:	e009883a 	mov	r4,fp
8112ba98:	112dca80 	call	8112dca8 <_Bfree>
8112ba9c:	00800044 	movi	r2,1
8112baa0:	003fbc06 	br	8112b994 <__reset+0xfb10b994>
8112baa4:	a80b883a 	mov	r5,r21
8112baa8:	8009883a 	mov	r4,r16
8112baac:	112e4f80 	call	8112e4f8 <__mcmp>
8112bab0:	103edb0e 	bge	r2,zero,8112b620 <__reset+0xfb10b620>
8112bab4:	800b883a 	mov	r5,r16
8112bab8:	000f883a 	mov	r7,zero
8112babc:	01800284 	movi	r6,10
8112bac0:	e009883a 	mov	r4,fp
8112bac4:	112dcd00 	call	8112dcd0 <__multadd>
8112bac8:	1021883a 	mov	r16,r2
8112bacc:	d8800517 	ldw	r2,20(sp)
8112bad0:	d8c00b17 	ldw	r3,44(sp)
8112bad4:	10bfffc4 	addi	r2,r2,-1
8112bad8:	d8800515 	stw	r2,20(sp)
8112badc:	183f761e 	bne	r3,zero,8112b8b8 <__reset+0xfb10b8b8>
8112bae0:	d9000c17 	ldw	r4,48(sp)
8112bae4:	0101730e 	bge	zero,r4,8112c0b4 <_dtoa_r+0x15d4>
8112bae8:	d9000615 	stw	r4,24(sp)
8112baec:	003ed006 	br	8112b630 <__reset+0xfb10b630>
8112baf0:	00800084 	movi	r2,2
8112baf4:	3081861e 	bne	r6,r2,8112c110 <_dtoa_r+0x1630>
8112baf8:	d8000b15 	stw	zero,44(sp)
8112bafc:	003f3c06 	br	8112b7f0 <__reset+0xfb10b7f0>
8112bb00:	dc000917 	ldw	r16,36(sp)
8112bb04:	003e9206 	br	8112b550 <__reset+0xfb10b550>
8112bb08:	d9c00317 	ldw	r7,12(sp)
8112bb0c:	00800084 	movi	r2,2
8112bb10:	11fec50e 	bge	r2,r7,8112b628 <__reset+0xfb10b628>
8112bb14:	d9000617 	ldw	r4,24(sp)
8112bb18:	20013c1e 	bne	r4,zero,8112c00c <_dtoa_r+0x152c>
8112bb1c:	a80b883a 	mov	r5,r21
8112bb20:	000f883a 	mov	r7,zero
8112bb24:	01800144 	movi	r6,5
8112bb28:	e009883a 	mov	r4,fp
8112bb2c:	112dcd00 	call	8112dcd0 <__multadd>
8112bb30:	100b883a 	mov	r5,r2
8112bb34:	8009883a 	mov	r4,r16
8112bb38:	102b883a 	mov	r21,r2
8112bb3c:	112e4f80 	call	8112e4f8 <__mcmp>
8112bb40:	dc000915 	stw	r16,36(sp)
8112bb44:	00bf410e 	bge	zero,r2,8112b84c <__reset+0xfb10b84c>
8112bb48:	d9c00717 	ldw	r7,28(sp)
8112bb4c:	00800c44 	movi	r2,49
8112bb50:	38800005 	stb	r2,0(r7)
8112bb54:	d8800517 	ldw	r2,20(sp)
8112bb58:	3dc00044 	addi	r23,r7,1
8112bb5c:	10800044 	addi	r2,r2,1
8112bb60:	d8800515 	stw	r2,20(sp)
8112bb64:	003f3d06 	br	8112b85c <__reset+0xfb10b85c>
8112bb68:	d9800517 	ldw	r6,20(sp)
8112bb6c:	d9c00717 	ldw	r7,28(sp)
8112bb70:	00800c44 	movi	r2,49
8112bb74:	31800044 	addi	r6,r6,1
8112bb78:	d9800515 	stw	r6,20(sp)
8112bb7c:	38800005 	stb	r2,0(r7)
8112bb80:	003edf06 	br	8112b700 <__reset+0xfb10b700>
8112bb84:	d8000b15 	stw	zero,44(sp)
8112bb88:	003c9f06 	br	8112ae08 <__reset+0xfb10ae08>
8112bb8c:	903e7e1e 	bne	r18,zero,8112b588 <__reset+0xfb10b588>
8112bb90:	00800434 	movhi	r2,16
8112bb94:	10bfffc4 	addi	r2,r2,-1
8112bb98:	9884703a 	and	r2,r19,r2
8112bb9c:	1000ea1e 	bne	r2,zero,8112bf48 <_dtoa_r+0x1468>
8112bba0:	9cdffc2c 	andhi	r19,r19,32752
8112bba4:	9800e826 	beq	r19,zero,8112bf48 <_dtoa_r+0x1468>
8112bba8:	d9c00817 	ldw	r7,32(sp)
8112bbac:	b5800044 	addi	r22,r22,1
8112bbb0:	04c00044 	movi	r19,1
8112bbb4:	39c00044 	addi	r7,r7,1
8112bbb8:	d9c00815 	stw	r7,32(sp)
8112bbbc:	d8800d17 	ldw	r2,52(sp)
8112bbc0:	103e721e 	bne	r2,zero,8112b58c <__reset+0xfb10b58c>
8112bbc4:	00800044 	movi	r2,1
8112bbc8:	003e7906 	br	8112b5b0 <__reset+0xfb10b5b0>
8112bbcc:	8009883a 	mov	r4,r16
8112bbd0:	11224300 	call	81122430 <__floatsidf>
8112bbd4:	d9800f17 	ldw	r6,60(sp)
8112bbd8:	d9c01017 	ldw	r7,64(sp)
8112bbdc:	1009883a 	mov	r4,r2
8112bbe0:	180b883a 	mov	r5,r3
8112bbe4:	112138c0 	call	8112138c <__muldf3>
8112bbe8:	000d883a 	mov	r6,zero
8112bbec:	01d00734 	movhi	r7,16412
8112bbf0:	1009883a 	mov	r4,r2
8112bbf4:	180b883a 	mov	r5,r3
8112bbf8:	11361ec0 	call	811361ec <__adddf3>
8112bbfc:	047f3034 	movhi	r17,64704
8112bc00:	1021883a 	mov	r16,r2
8112bc04:	1c63883a 	add	r17,r3,r17
8112bc08:	d9000f17 	ldw	r4,60(sp)
8112bc0c:	d9401017 	ldw	r5,64(sp)
8112bc10:	000d883a 	mov	r6,zero
8112bc14:	01d00534 	movhi	r7,16404
8112bc18:	1121aac0 	call	81121aac <__subdf3>
8112bc1c:	800d883a 	mov	r6,r16
8112bc20:	880f883a 	mov	r7,r17
8112bc24:	1009883a 	mov	r4,r2
8112bc28:	180b883a 	mov	r5,r3
8112bc2c:	102b883a 	mov	r21,r2
8112bc30:	1829883a 	mov	r20,r3
8112bc34:	11212b00 	call	811212b0 <__gedf2>
8112bc38:	00806c16 	blt	zero,r2,8112bdec <_dtoa_r+0x130c>
8112bc3c:	89e0003c 	xorhi	r7,r17,32768
8112bc40:	800d883a 	mov	r6,r16
8112bc44:	a809883a 	mov	r4,r21
8112bc48:	a00b883a 	mov	r5,r20
8112bc4c:	11374180 	call	81137418 <__ledf2>
8112bc50:	103d7e0e 	bge	r2,zero,8112b24c <__reset+0xfb10b24c>
8112bc54:	002b883a 	mov	r21,zero
8112bc58:	0023883a 	mov	r17,zero
8112bc5c:	003efb06 	br	8112b84c <__reset+0xfb10b84c>
8112bc60:	d8800717 	ldw	r2,28(sp)
8112bc64:	003bd006 	br	8112aba8 <__reset+0xfb10aba8>
8112bc68:	d9000a17 	ldw	r4,40(sp)
8112bc6c:	d9800d17 	ldw	r6,52(sp)
8112bc70:	dd400a15 	stw	r21,40(sp)
8112bc74:	a905c83a 	sub	r2,r21,r4
8112bc78:	308d883a 	add	r6,r6,r2
8112bc7c:	d9800d15 	stw	r6,52(sp)
8112bc80:	002b883a 	mov	r21,zero
8112bc84:	003e0606 	br	8112b4a0 <__reset+0xfb10b4a0>
8112bc88:	9023883a 	mov	r17,r18
8112bc8c:	9829883a 	mov	r20,r19
8112bc90:	04000084 	movi	r16,2
8112bc94:	003c9206 	br	8112aee0 <__reset+0xfb10aee0>
8112bc98:	04000044 	movi	r16,1
8112bc9c:	dc000c15 	stw	r16,48(sp)
8112bca0:	dc000615 	stw	r16,24(sp)
8112bca4:	dc002215 	stw	r16,136(sp)
8112bca8:	e0001115 	stw	zero,68(fp)
8112bcac:	000b883a 	mov	r5,zero
8112bcb0:	003c6906 	br	8112ae58 <__reset+0xfb10ae58>
8112bcb4:	3021883a 	mov	r16,r6
8112bcb8:	003ffb06 	br	8112bca8 <__reset+0xfb10bca8>
8112bcbc:	1000021e 	bne	r2,zero,8112bcc8 <_dtoa_r+0x11e8>
8112bcc0:	4200004c 	andi	r8,r8,1
8112bcc4:	403e7d1e 	bne	r8,zero,8112b6bc <__reset+0xfb10b6bc>
8112bcc8:	01000c04 	movi	r4,48
8112bccc:	00000106 	br	8112bcd4 <_dtoa_r+0x11f4>
8112bcd0:	102f883a 	mov	r23,r2
8112bcd4:	b8bfffc4 	addi	r2,r23,-1
8112bcd8:	10c00007 	ldb	r3,0(r2)
8112bcdc:	193ffc26 	beq	r3,r4,8112bcd0 <__reset+0xfb10bcd0>
8112bce0:	003e8706 	br	8112b700 <__reset+0xfb10b700>
8112bce4:	d8800517 	ldw	r2,20(sp)
8112bce8:	00a3c83a 	sub	r17,zero,r2
8112bcec:	8800a426 	beq	r17,zero,8112bf80 <_dtoa_r+0x14a0>
8112bcf0:	888003cc 	andi	r2,r17,15
8112bcf4:	100490fa 	slli	r2,r2,3
8112bcf8:	00e04574 	movhi	r3,33045
8112bcfc:	18c78404 	addi	r3,r3,7696
8112bd00:	1885883a 	add	r2,r3,r2
8112bd04:	11800017 	ldw	r6,0(r2)
8112bd08:	11c00117 	ldw	r7,4(r2)
8112bd0c:	9009883a 	mov	r4,r18
8112bd10:	980b883a 	mov	r5,r19
8112bd14:	8823d13a 	srai	r17,r17,4
8112bd18:	112138c0 	call	8112138c <__muldf3>
8112bd1c:	d8800f15 	stw	r2,60(sp)
8112bd20:	d8c01015 	stw	r3,64(sp)
8112bd24:	8800e826 	beq	r17,zero,8112c0c8 <_dtoa_r+0x15e8>
8112bd28:	05204574 	movhi	r20,33045
8112bd2c:	a5077a04 	addi	r20,r20,7656
8112bd30:	04000084 	movi	r16,2
8112bd34:	8980004c 	andi	r6,r17,1
8112bd38:	1009883a 	mov	r4,r2
8112bd3c:	8823d07a 	srai	r17,r17,1
8112bd40:	180b883a 	mov	r5,r3
8112bd44:	30000426 	beq	r6,zero,8112bd58 <_dtoa_r+0x1278>
8112bd48:	a1800017 	ldw	r6,0(r20)
8112bd4c:	a1c00117 	ldw	r7,4(r20)
8112bd50:	84000044 	addi	r16,r16,1
8112bd54:	112138c0 	call	8112138c <__muldf3>
8112bd58:	a5000204 	addi	r20,r20,8
8112bd5c:	883ff51e 	bne	r17,zero,8112bd34 <__reset+0xfb10bd34>
8112bd60:	d8800f15 	stw	r2,60(sp)
8112bd64:	d8c01015 	stw	r3,64(sp)
8112bd68:	003c7606 	br	8112af44 <__reset+0xfb10af44>
8112bd6c:	00c00c04 	movi	r3,48
8112bd70:	10c00005 	stb	r3,0(r2)
8112bd74:	d8c00517 	ldw	r3,20(sp)
8112bd78:	bd3fffc3 	ldbu	r20,-1(r23)
8112bd7c:	18c00044 	addi	r3,r3,1
8112bd80:	d8c00515 	stw	r3,20(sp)
8112bd84:	003db906 	br	8112b46c <__reset+0xfb10b46c>
8112bd88:	89400117 	ldw	r5,4(r17)
8112bd8c:	e009883a 	mov	r4,fp
8112bd90:	112dbf80 	call	8112dbf8 <_Balloc>
8112bd94:	89800417 	ldw	r6,16(r17)
8112bd98:	89400304 	addi	r5,r17,12
8112bd9c:	11000304 	addi	r4,r2,12
8112bda0:	31800084 	addi	r6,r6,2
8112bda4:	318d883a 	add	r6,r6,r6
8112bda8:	318d883a 	add	r6,r6,r6
8112bdac:	1027883a 	mov	r19,r2
8112bdb0:	1123a440 	call	81123a44 <memcpy>
8112bdb4:	01800044 	movi	r6,1
8112bdb8:	980b883a 	mov	r5,r19
8112bdbc:	e009883a 	mov	r4,fp
8112bdc0:	112e3a80 	call	8112e3a8 <__lshift>
8112bdc4:	1029883a 	mov	r20,r2
8112bdc8:	003ecc06 	br	8112b8fc <__reset+0xfb10b8fc>
8112bdcc:	00800e44 	movi	r2,57
8112bdd0:	90809026 	beq	r18,r2,8112c014 <_dtoa_r+0x1534>
8112bdd4:	92000044 	addi	r8,r18,1
8112bdd8:	003f1f06 	br	8112ba58 <__reset+0xfb10ba58>
8112bddc:	9011883a 	mov	r8,r18
8112bde0:	8825883a 	mov	r18,r17
8112bde4:	a023883a 	mov	r17,r20
8112bde8:	003e2906 	br	8112b690 <__reset+0xfb10b690>
8112bdec:	002b883a 	mov	r21,zero
8112bdf0:	0023883a 	mov	r17,zero
8112bdf4:	003f5406 	br	8112bb48 <__reset+0xfb10bb48>
8112bdf8:	61bfffc4 	addi	r6,r12,-1
8112bdfc:	300490fa 	slli	r2,r6,3
8112be00:	00e04574 	movhi	r3,33045
8112be04:	18c78404 	addi	r3,r3,7696
8112be08:	1885883a 	add	r2,r3,r2
8112be0c:	11000017 	ldw	r4,0(r2)
8112be10:	11400117 	ldw	r5,4(r2)
8112be14:	d8800717 	ldw	r2,28(sp)
8112be18:	880f883a 	mov	r7,r17
8112be1c:	d9801215 	stw	r6,72(sp)
8112be20:	800d883a 	mov	r6,r16
8112be24:	db001615 	stw	r12,88(sp)
8112be28:	15c00044 	addi	r23,r2,1
8112be2c:	112138c0 	call	8112138c <__muldf3>
8112be30:	d9401017 	ldw	r5,64(sp)
8112be34:	d9000f17 	ldw	r4,60(sp)
8112be38:	d8c01515 	stw	r3,84(sp)
8112be3c:	d8801415 	stw	r2,80(sp)
8112be40:	11223b00 	call	811223b0 <__fixdfsi>
8112be44:	1009883a 	mov	r4,r2
8112be48:	1021883a 	mov	r16,r2
8112be4c:	11224300 	call	81122430 <__floatsidf>
8112be50:	d9000f17 	ldw	r4,60(sp)
8112be54:	d9401017 	ldw	r5,64(sp)
8112be58:	100d883a 	mov	r6,r2
8112be5c:	180f883a 	mov	r7,r3
8112be60:	1121aac0 	call	81121aac <__subdf3>
8112be64:	1829883a 	mov	r20,r3
8112be68:	d8c00717 	ldw	r3,28(sp)
8112be6c:	84000c04 	addi	r16,r16,48
8112be70:	1023883a 	mov	r17,r2
8112be74:	1c000005 	stb	r16,0(r3)
8112be78:	db001617 	ldw	r12,88(sp)
8112be7c:	00800044 	movi	r2,1
8112be80:	60802226 	beq	r12,r2,8112bf0c <_dtoa_r+0x142c>
8112be84:	d9c00717 	ldw	r7,28(sp)
8112be88:	8805883a 	mov	r2,r17
8112be8c:	b82b883a 	mov	r21,r23
8112be90:	3b19883a 	add	r12,r7,r12
8112be94:	6023883a 	mov	r17,r12
8112be98:	a007883a 	mov	r3,r20
8112be9c:	dc800f15 	stw	r18,60(sp)
8112bea0:	000d883a 	mov	r6,zero
8112bea4:	01d00934 	movhi	r7,16420
8112bea8:	1009883a 	mov	r4,r2
8112beac:	180b883a 	mov	r5,r3
8112beb0:	112138c0 	call	8112138c <__muldf3>
8112beb4:	180b883a 	mov	r5,r3
8112beb8:	1009883a 	mov	r4,r2
8112bebc:	1829883a 	mov	r20,r3
8112bec0:	1025883a 	mov	r18,r2
8112bec4:	11223b00 	call	811223b0 <__fixdfsi>
8112bec8:	1009883a 	mov	r4,r2
8112becc:	1021883a 	mov	r16,r2
8112bed0:	11224300 	call	81122430 <__floatsidf>
8112bed4:	100d883a 	mov	r6,r2
8112bed8:	180f883a 	mov	r7,r3
8112bedc:	9009883a 	mov	r4,r18
8112bee0:	a00b883a 	mov	r5,r20
8112bee4:	84000c04 	addi	r16,r16,48
8112bee8:	1121aac0 	call	81121aac <__subdf3>
8112beec:	ad400044 	addi	r21,r21,1
8112bef0:	ac3fffc5 	stb	r16,-1(r21)
8112bef4:	ac7fea1e 	bne	r21,r17,8112bea0 <__reset+0xfb10bea0>
8112bef8:	1023883a 	mov	r17,r2
8112befc:	d8801217 	ldw	r2,72(sp)
8112bf00:	dc800f17 	ldw	r18,60(sp)
8112bf04:	1829883a 	mov	r20,r3
8112bf08:	b8af883a 	add	r23,r23,r2
8112bf0c:	d9001417 	ldw	r4,80(sp)
8112bf10:	d9401517 	ldw	r5,84(sp)
8112bf14:	000d883a 	mov	r6,zero
8112bf18:	01cff834 	movhi	r7,16352
8112bf1c:	11361ec0 	call	811361ec <__adddf3>
8112bf20:	880d883a 	mov	r6,r17
8112bf24:	a00f883a 	mov	r7,r20
8112bf28:	1009883a 	mov	r4,r2
8112bf2c:	180b883a 	mov	r5,r3
8112bf30:	11374180 	call	81137418 <__ledf2>
8112bf34:	10003e0e 	bge	r2,zero,8112c030 <_dtoa_r+0x1550>
8112bf38:	d9001317 	ldw	r4,76(sp)
8112bf3c:	bd3fffc3 	ldbu	r20,-1(r23)
8112bf40:	d9000515 	stw	r4,20(sp)
8112bf44:	003d3b06 	br	8112b434 <__reset+0xfb10b434>
8112bf48:	0027883a 	mov	r19,zero
8112bf4c:	003f1b06 	br	8112bbbc <__reset+0xfb10bbbc>
8112bf50:	d8800817 	ldw	r2,32(sp)
8112bf54:	11e9c83a 	sub	r20,r2,r7
8112bf58:	0005883a 	mov	r2,zero
8112bf5c:	003d5406 	br	8112b4b0 <__reset+0xfb10b4b0>
8112bf60:	00800044 	movi	r2,1
8112bf64:	003dc706 	br	8112b684 <__reset+0xfb10b684>
8112bf68:	d8c00217 	ldw	r3,8(sp)
8112bf6c:	00800d84 	movi	r2,54
8112bf70:	dd400a17 	ldw	r21,40(sp)
8112bf74:	10c5c83a 	sub	r2,r2,r3
8112bf78:	dd000817 	ldw	r20,32(sp)
8112bf7c:	003d4c06 	br	8112b4b0 <__reset+0xfb10b4b0>
8112bf80:	dc800f15 	stw	r18,60(sp)
8112bf84:	dcc01015 	stw	r19,64(sp)
8112bf88:	04000084 	movi	r16,2
8112bf8c:	003bed06 	br	8112af44 <__reset+0xfb10af44>
8112bf90:	d9000617 	ldw	r4,24(sp)
8112bf94:	203f0d26 	beq	r4,zero,8112bbcc <__reset+0xfb10bbcc>
8112bf98:	d9800c17 	ldw	r6,48(sp)
8112bf9c:	01bcab0e 	bge	zero,r6,8112b24c <__reset+0xfb10b24c>
8112bfa0:	d9401017 	ldw	r5,64(sp)
8112bfa4:	d9000f17 	ldw	r4,60(sp)
8112bfa8:	000d883a 	mov	r6,zero
8112bfac:	01d00934 	movhi	r7,16420
8112bfb0:	112138c0 	call	8112138c <__muldf3>
8112bfb4:	81000044 	addi	r4,r16,1
8112bfb8:	d8800f15 	stw	r2,60(sp)
8112bfbc:	d8c01015 	stw	r3,64(sp)
8112bfc0:	11224300 	call	81122430 <__floatsidf>
8112bfc4:	d9800f17 	ldw	r6,60(sp)
8112bfc8:	d9c01017 	ldw	r7,64(sp)
8112bfcc:	1009883a 	mov	r4,r2
8112bfd0:	180b883a 	mov	r5,r3
8112bfd4:	112138c0 	call	8112138c <__muldf3>
8112bfd8:	01d00734 	movhi	r7,16412
8112bfdc:	000d883a 	mov	r6,zero
8112bfe0:	1009883a 	mov	r4,r2
8112bfe4:	180b883a 	mov	r5,r3
8112bfe8:	11361ec0 	call	811361ec <__adddf3>
8112bfec:	d9c00517 	ldw	r7,20(sp)
8112bff0:	047f3034 	movhi	r17,64704
8112bff4:	1021883a 	mov	r16,r2
8112bff8:	39ffffc4 	addi	r7,r7,-1
8112bffc:	d9c01315 	stw	r7,76(sp)
8112c000:	1c63883a 	add	r17,r3,r17
8112c004:	db000c17 	ldw	r12,48(sp)
8112c008:	003bea06 	br	8112afb4 <__reset+0xfb10afb4>
8112c00c:	dc000915 	stw	r16,36(sp)
8112c010:	003e0e06 	br	8112b84c <__reset+0xfb10b84c>
8112c014:	01000e44 	movi	r4,57
8112c018:	8825883a 	mov	r18,r17
8112c01c:	9dc00044 	addi	r23,r19,1
8112c020:	99000005 	stb	r4,0(r19)
8112c024:	a023883a 	mov	r17,r20
8112c028:	dc000915 	stw	r16,36(sp)
8112c02c:	003da406 	br	8112b6c0 <__reset+0xfb10b6c0>
8112c030:	d9801417 	ldw	r6,80(sp)
8112c034:	d9c01517 	ldw	r7,84(sp)
8112c038:	0009883a 	mov	r4,zero
8112c03c:	014ff834 	movhi	r5,16352
8112c040:	1121aac0 	call	81121aac <__subdf3>
8112c044:	880d883a 	mov	r6,r17
8112c048:	a00f883a 	mov	r7,r20
8112c04c:	1009883a 	mov	r4,r2
8112c050:	180b883a 	mov	r5,r3
8112c054:	11212b00 	call	811212b0 <__gedf2>
8112c058:	00bc7c0e 	bge	zero,r2,8112b24c <__reset+0xfb10b24c>
8112c05c:	01000c04 	movi	r4,48
8112c060:	00000106 	br	8112c068 <_dtoa_r+0x1588>
8112c064:	102f883a 	mov	r23,r2
8112c068:	b8bfffc4 	addi	r2,r23,-1
8112c06c:	10c00007 	ldb	r3,0(r2)
8112c070:	193ffc26 	beq	r3,r4,8112c064 <__reset+0xfb10c064>
8112c074:	d9801317 	ldw	r6,76(sp)
8112c078:	d9800515 	stw	r6,20(sp)
8112c07c:	003c4406 	br	8112b190 <__reset+0xfb10b190>
8112c080:	d9801317 	ldw	r6,76(sp)
8112c084:	d9800515 	stw	r6,20(sp)
8112c088:	003cea06 	br	8112b434 <__reset+0xfb10b434>
8112c08c:	dd800f17 	ldw	r22,60(sp)
8112c090:	dcc01017 	ldw	r19,64(sp)
8112c094:	dc801217 	ldw	r18,72(sp)
8112c098:	003c6c06 	br	8112b24c <__reset+0xfb10b24c>
8112c09c:	903e031e 	bne	r18,zero,8112b8ac <__reset+0xfb10b8ac>
8112c0a0:	003ebb06 	br	8112bb90 <__reset+0xfb10bb90>
8112c0a4:	103e6c1e 	bne	r2,zero,8112ba58 <__reset+0xfb10ba58>
8112c0a8:	4080004c 	andi	r2,r8,1
8112c0ac:	103e6a26 	beq	r2,zero,8112ba58 <__reset+0xfb10ba58>
8112c0b0:	003e6606 	br	8112ba4c <__reset+0xfb10ba4c>
8112c0b4:	d8c00317 	ldw	r3,12(sp)
8112c0b8:	00800084 	movi	r2,2
8112c0bc:	10c02916 	blt	r2,r3,8112c164 <_dtoa_r+0x1684>
8112c0c0:	d9000c17 	ldw	r4,48(sp)
8112c0c4:	003e8806 	br	8112bae8 <__reset+0xfb10bae8>
8112c0c8:	04000084 	movi	r16,2
8112c0cc:	003b9d06 	br	8112af44 <__reset+0xfb10af44>
8112c0d0:	d9001317 	ldw	r4,76(sp)
8112c0d4:	d9000515 	stw	r4,20(sp)
8112c0d8:	003cd606 	br	8112b434 <__reset+0xfb10b434>
8112c0dc:	d8801317 	ldw	r2,76(sp)
8112c0e0:	d8800515 	stw	r2,20(sp)
8112c0e4:	003c2a06 	br	8112b190 <__reset+0xfb10b190>
8112c0e8:	d9800317 	ldw	r6,12(sp)
8112c0ec:	00800084 	movi	r2,2
8112c0f0:	11801516 	blt	r2,r6,8112c148 <_dtoa_r+0x1668>
8112c0f4:	d9c00c17 	ldw	r7,48(sp)
8112c0f8:	d9c00615 	stw	r7,24(sp)
8112c0fc:	003df706 	br	8112b8dc <__reset+0xfb10b8dc>
8112c100:	193d3926 	beq	r3,r4,8112b5e8 <__reset+0xfb10b5e8>
8112c104:	00c00f04 	movi	r3,60
8112c108:	1885c83a 	sub	r2,r3,r2
8112c10c:	003ddf06 	br	8112b88c <__reset+0xfb10b88c>
8112c110:	e009883a 	mov	r4,fp
8112c114:	e0001115 	stw	zero,68(fp)
8112c118:	000b883a 	mov	r5,zero
8112c11c:	112dbf80 	call	8112dbf8 <_Balloc>
8112c120:	d8800715 	stw	r2,28(sp)
8112c124:	d8c00717 	ldw	r3,28(sp)
8112c128:	00bfffc4 	movi	r2,-1
8112c12c:	01000044 	movi	r4,1
8112c130:	d8800c15 	stw	r2,48(sp)
8112c134:	e0c01015 	stw	r3,64(fp)
8112c138:	d9000b15 	stw	r4,44(sp)
8112c13c:	d8800615 	stw	r2,24(sp)
8112c140:	d8002215 	stw	zero,136(sp)
8112c144:	003c4106 	br	8112b24c <__reset+0xfb10b24c>
8112c148:	d8c00c17 	ldw	r3,48(sp)
8112c14c:	d8c00615 	stw	r3,24(sp)
8112c150:	003e7006 	br	8112bb14 <__reset+0xfb10bb14>
8112c154:	04400044 	movi	r17,1
8112c158:	003b2006 	br	8112addc <__reset+0xfb10addc>
8112c15c:	000b883a 	mov	r5,zero
8112c160:	003b3d06 	br	8112ae58 <__reset+0xfb10ae58>
8112c164:	d8800c17 	ldw	r2,48(sp)
8112c168:	d8800615 	stw	r2,24(sp)
8112c16c:	003e6906 	br	8112bb14 <__reset+0xfb10bb14>

8112c170 <__sflush_r>:
8112c170:	defffb04 	addi	sp,sp,-20
8112c174:	de00012e 	bgeu	sp,et,8112c17c <__sflush_r+0xc>
8112c178:	003b68fa 	trap	3
8112c17c:	2880030b 	ldhu	r2,12(r5)
8112c180:	dcc00315 	stw	r19,12(sp)
8112c184:	dc400115 	stw	r17,4(sp)
8112c188:	dfc00415 	stw	ra,16(sp)
8112c18c:	dc800215 	stw	r18,8(sp)
8112c190:	dc000015 	stw	r16,0(sp)
8112c194:	10c0020c 	andi	r3,r2,8
8112c198:	2823883a 	mov	r17,r5
8112c19c:	2027883a 	mov	r19,r4
8112c1a0:	1800311e 	bne	r3,zero,8112c268 <__sflush_r+0xf8>
8112c1a4:	28c00117 	ldw	r3,4(r5)
8112c1a8:	10820014 	ori	r2,r2,2048
8112c1ac:	2880030d 	sth	r2,12(r5)
8112c1b0:	00c04b0e 	bge	zero,r3,8112c2e0 <__sflush_r+0x170>
8112c1b4:	8a000a17 	ldw	r8,40(r17)
8112c1b8:	40002326 	beq	r8,zero,8112c248 <__sflush_r+0xd8>
8112c1bc:	9c000017 	ldw	r16,0(r19)
8112c1c0:	10c4000c 	andi	r3,r2,4096
8112c1c4:	98000015 	stw	zero,0(r19)
8112c1c8:	18004826 	beq	r3,zero,8112c2ec <__sflush_r+0x17c>
8112c1cc:	89801417 	ldw	r6,80(r17)
8112c1d0:	10c0010c 	andi	r3,r2,4
8112c1d4:	18000626 	beq	r3,zero,8112c1f0 <__sflush_r+0x80>
8112c1d8:	88c00117 	ldw	r3,4(r17)
8112c1dc:	88800c17 	ldw	r2,48(r17)
8112c1e0:	30cdc83a 	sub	r6,r6,r3
8112c1e4:	10000226 	beq	r2,zero,8112c1f0 <__sflush_r+0x80>
8112c1e8:	88800f17 	ldw	r2,60(r17)
8112c1ec:	308dc83a 	sub	r6,r6,r2
8112c1f0:	89400717 	ldw	r5,28(r17)
8112c1f4:	000f883a 	mov	r7,zero
8112c1f8:	9809883a 	mov	r4,r19
8112c1fc:	403ee83a 	callr	r8
8112c200:	00ffffc4 	movi	r3,-1
8112c204:	10c04426 	beq	r2,r3,8112c318 <__sflush_r+0x1a8>
8112c208:	88c0030b 	ldhu	r3,12(r17)
8112c20c:	89000417 	ldw	r4,16(r17)
8112c210:	88000115 	stw	zero,4(r17)
8112c214:	197dffcc 	andi	r5,r3,63487
8112c218:	8940030d 	sth	r5,12(r17)
8112c21c:	89000015 	stw	r4,0(r17)
8112c220:	18c4000c 	andi	r3,r3,4096
8112c224:	18002c1e 	bne	r3,zero,8112c2d8 <__sflush_r+0x168>
8112c228:	89400c17 	ldw	r5,48(r17)
8112c22c:	9c000015 	stw	r16,0(r19)
8112c230:	28000526 	beq	r5,zero,8112c248 <__sflush_r+0xd8>
8112c234:	88801004 	addi	r2,r17,64
8112c238:	28800226 	beq	r5,r2,8112c244 <__sflush_r+0xd4>
8112c23c:	9809883a 	mov	r4,r19
8112c240:	112cc280 	call	8112cc28 <_free_r>
8112c244:	88000c15 	stw	zero,48(r17)
8112c248:	0005883a 	mov	r2,zero
8112c24c:	dfc00417 	ldw	ra,16(sp)
8112c250:	dcc00317 	ldw	r19,12(sp)
8112c254:	dc800217 	ldw	r18,8(sp)
8112c258:	dc400117 	ldw	r17,4(sp)
8112c25c:	dc000017 	ldw	r16,0(sp)
8112c260:	dec00504 	addi	sp,sp,20
8112c264:	f800283a 	ret
8112c268:	2c800417 	ldw	r18,16(r5)
8112c26c:	903ff626 	beq	r18,zero,8112c248 <__reset+0xfb10c248>
8112c270:	2c000017 	ldw	r16,0(r5)
8112c274:	108000cc 	andi	r2,r2,3
8112c278:	2c800015 	stw	r18,0(r5)
8112c27c:	84a1c83a 	sub	r16,r16,r18
8112c280:	1000131e 	bne	r2,zero,8112c2d0 <__sflush_r+0x160>
8112c284:	28800517 	ldw	r2,20(r5)
8112c288:	88800215 	stw	r2,8(r17)
8112c28c:	04000316 	blt	zero,r16,8112c29c <__sflush_r+0x12c>
8112c290:	003fed06 	br	8112c248 <__reset+0xfb10c248>
8112c294:	90a5883a 	add	r18,r18,r2
8112c298:	043feb0e 	bge	zero,r16,8112c248 <__reset+0xfb10c248>
8112c29c:	88800917 	ldw	r2,36(r17)
8112c2a0:	89400717 	ldw	r5,28(r17)
8112c2a4:	800f883a 	mov	r7,r16
8112c2a8:	900d883a 	mov	r6,r18
8112c2ac:	9809883a 	mov	r4,r19
8112c2b0:	103ee83a 	callr	r2
8112c2b4:	80a1c83a 	sub	r16,r16,r2
8112c2b8:	00bff616 	blt	zero,r2,8112c294 <__reset+0xfb10c294>
8112c2bc:	88c0030b 	ldhu	r3,12(r17)
8112c2c0:	00bfffc4 	movi	r2,-1
8112c2c4:	18c01014 	ori	r3,r3,64
8112c2c8:	88c0030d 	sth	r3,12(r17)
8112c2cc:	003fdf06 	br	8112c24c <__reset+0xfb10c24c>
8112c2d0:	0005883a 	mov	r2,zero
8112c2d4:	003fec06 	br	8112c288 <__reset+0xfb10c288>
8112c2d8:	88801415 	stw	r2,80(r17)
8112c2dc:	003fd206 	br	8112c228 <__reset+0xfb10c228>
8112c2e0:	28c00f17 	ldw	r3,60(r5)
8112c2e4:	00ffb316 	blt	zero,r3,8112c1b4 <__reset+0xfb10c1b4>
8112c2e8:	003fd706 	br	8112c248 <__reset+0xfb10c248>
8112c2ec:	89400717 	ldw	r5,28(r17)
8112c2f0:	000d883a 	mov	r6,zero
8112c2f4:	01c00044 	movi	r7,1
8112c2f8:	9809883a 	mov	r4,r19
8112c2fc:	403ee83a 	callr	r8
8112c300:	100d883a 	mov	r6,r2
8112c304:	00bfffc4 	movi	r2,-1
8112c308:	30801426 	beq	r6,r2,8112c35c <__sflush_r+0x1ec>
8112c30c:	8880030b 	ldhu	r2,12(r17)
8112c310:	8a000a17 	ldw	r8,40(r17)
8112c314:	003fae06 	br	8112c1d0 <__reset+0xfb10c1d0>
8112c318:	98c00017 	ldw	r3,0(r19)
8112c31c:	183fba26 	beq	r3,zero,8112c208 <__reset+0xfb10c208>
8112c320:	01000744 	movi	r4,29
8112c324:	19000626 	beq	r3,r4,8112c340 <__sflush_r+0x1d0>
8112c328:	01000584 	movi	r4,22
8112c32c:	19000426 	beq	r3,r4,8112c340 <__sflush_r+0x1d0>
8112c330:	88c0030b 	ldhu	r3,12(r17)
8112c334:	18c01014 	ori	r3,r3,64
8112c338:	88c0030d 	sth	r3,12(r17)
8112c33c:	003fc306 	br	8112c24c <__reset+0xfb10c24c>
8112c340:	8880030b 	ldhu	r2,12(r17)
8112c344:	88c00417 	ldw	r3,16(r17)
8112c348:	88000115 	stw	zero,4(r17)
8112c34c:	10bdffcc 	andi	r2,r2,63487
8112c350:	8880030d 	sth	r2,12(r17)
8112c354:	88c00015 	stw	r3,0(r17)
8112c358:	003fb306 	br	8112c228 <__reset+0xfb10c228>
8112c35c:	98800017 	ldw	r2,0(r19)
8112c360:	103fea26 	beq	r2,zero,8112c30c <__reset+0xfb10c30c>
8112c364:	00c00744 	movi	r3,29
8112c368:	10c00226 	beq	r2,r3,8112c374 <__sflush_r+0x204>
8112c36c:	00c00584 	movi	r3,22
8112c370:	10c0031e 	bne	r2,r3,8112c380 <__sflush_r+0x210>
8112c374:	9c000015 	stw	r16,0(r19)
8112c378:	0005883a 	mov	r2,zero
8112c37c:	003fb306 	br	8112c24c <__reset+0xfb10c24c>
8112c380:	88c0030b 	ldhu	r3,12(r17)
8112c384:	3005883a 	mov	r2,r6
8112c388:	18c01014 	ori	r3,r3,64
8112c38c:	88c0030d 	sth	r3,12(r17)
8112c390:	003fae06 	br	8112c24c <__reset+0xfb10c24c>

8112c394 <_fflush_r>:
8112c394:	defffd04 	addi	sp,sp,-12
8112c398:	de00012e 	bgeu	sp,et,8112c3a0 <_fflush_r+0xc>
8112c39c:	003b68fa 	trap	3
8112c3a0:	dc000115 	stw	r16,4(sp)
8112c3a4:	dfc00215 	stw	ra,8(sp)
8112c3a8:	2021883a 	mov	r16,r4
8112c3ac:	20000226 	beq	r4,zero,8112c3b8 <_fflush_r+0x24>
8112c3b0:	20800e17 	ldw	r2,56(r4)
8112c3b4:	10000c26 	beq	r2,zero,8112c3e8 <_fflush_r+0x54>
8112c3b8:	2880030f 	ldh	r2,12(r5)
8112c3bc:	1000051e 	bne	r2,zero,8112c3d4 <_fflush_r+0x40>
8112c3c0:	0005883a 	mov	r2,zero
8112c3c4:	dfc00217 	ldw	ra,8(sp)
8112c3c8:	dc000117 	ldw	r16,4(sp)
8112c3cc:	dec00304 	addi	sp,sp,12
8112c3d0:	f800283a 	ret
8112c3d4:	8009883a 	mov	r4,r16
8112c3d8:	dfc00217 	ldw	ra,8(sp)
8112c3dc:	dc000117 	ldw	r16,4(sp)
8112c3e0:	dec00304 	addi	sp,sp,12
8112c3e4:	112c1701 	jmpi	8112c170 <__sflush_r>
8112c3e8:	d9400015 	stw	r5,0(sp)
8112c3ec:	112c7900 	call	8112c790 <__sinit>
8112c3f0:	d9400017 	ldw	r5,0(sp)
8112c3f4:	003ff006 	br	8112c3b8 <__reset+0xfb10c3b8>

8112c3f8 <fflush>:
8112c3f8:	20000526 	beq	r4,zero,8112c410 <fflush+0x18>
8112c3fc:	00a04574 	movhi	r2,33045
8112c400:	10911304 	addi	r2,r2,17484
8112c404:	200b883a 	mov	r5,r4
8112c408:	11000017 	ldw	r4,0(r2)
8112c40c:	112c3941 	jmpi	8112c394 <_fflush_r>
8112c410:	00a04574 	movhi	r2,33045
8112c414:	10911204 	addi	r2,r2,17480
8112c418:	11000017 	ldw	r4,0(r2)
8112c41c:	016044f4 	movhi	r5,33043
8112c420:	2970e504 	addi	r5,r5,-15468
8112c424:	112d4d01 	jmpi	8112d4d0 <_fwalk_reent>

8112c428 <__fp_unlock>:
8112c428:	0005883a 	mov	r2,zero
8112c42c:	f800283a 	ret

8112c430 <_cleanup_r>:
8112c430:	016044f4 	movhi	r5,33043
8112c434:	29507b04 	addi	r5,r5,16876
8112c438:	112d4d01 	jmpi	8112d4d0 <_fwalk_reent>

8112c43c <__sinit.part.1>:
8112c43c:	defff704 	addi	sp,sp,-36
8112c440:	00e044f4 	movhi	r3,33043
8112c444:	de00012e 	bgeu	sp,et,8112c44c <__sinit.part.1+0x10>
8112c448:	003b68fa 	trap	3
8112c44c:	18f10c04 	addi	r3,r3,-15312
8112c450:	dfc00815 	stw	ra,32(sp)
8112c454:	ddc00715 	stw	r23,28(sp)
8112c458:	dd800615 	stw	r22,24(sp)
8112c45c:	dd400515 	stw	r21,20(sp)
8112c460:	dd000415 	stw	r20,16(sp)
8112c464:	dcc00315 	stw	r19,12(sp)
8112c468:	dc800215 	stw	r18,8(sp)
8112c46c:	dc400115 	stw	r17,4(sp)
8112c470:	dc000015 	stw	r16,0(sp)
8112c474:	24000117 	ldw	r16,4(r4)
8112c478:	20c00f15 	stw	r3,60(r4)
8112c47c:	2080bb04 	addi	r2,r4,748
8112c480:	00c000c4 	movi	r3,3
8112c484:	20c0b915 	stw	r3,740(r4)
8112c488:	2080ba15 	stw	r2,744(r4)
8112c48c:	2000b815 	stw	zero,736(r4)
8112c490:	05c00204 	movi	r23,8
8112c494:	00800104 	movi	r2,4
8112c498:	2025883a 	mov	r18,r4
8112c49c:	b80d883a 	mov	r6,r23
8112c4a0:	81001704 	addi	r4,r16,92
8112c4a4:	000b883a 	mov	r5,zero
8112c4a8:	80000015 	stw	zero,0(r16)
8112c4ac:	80000115 	stw	zero,4(r16)
8112c4b0:	80000215 	stw	zero,8(r16)
8112c4b4:	8080030d 	sth	r2,12(r16)
8112c4b8:	80001915 	stw	zero,100(r16)
8112c4bc:	8000038d 	sth	zero,14(r16)
8112c4c0:	80000415 	stw	zero,16(r16)
8112c4c4:	80000515 	stw	zero,20(r16)
8112c4c8:	80000615 	stw	zero,24(r16)
8112c4cc:	1123b940 	call	81123b94 <memset>
8112c4d0:	05a044b4 	movhi	r22,33042
8112c4d4:	94400217 	ldw	r17,8(r18)
8112c4d8:	056044b4 	movhi	r21,33042
8112c4dc:	052044b4 	movhi	r20,33042
8112c4e0:	04e044b4 	movhi	r19,33042
8112c4e4:	b590c704 	addi	r22,r22,17180
8112c4e8:	ad50e004 	addi	r21,r21,17280
8112c4ec:	a5110104 	addi	r20,r20,17412
8112c4f0:	9cd11a04 	addi	r19,r19,17512
8112c4f4:	85800815 	stw	r22,32(r16)
8112c4f8:	85400915 	stw	r21,36(r16)
8112c4fc:	85000a15 	stw	r20,40(r16)
8112c500:	84c00b15 	stw	r19,44(r16)
8112c504:	84000715 	stw	r16,28(r16)
8112c508:	00800284 	movi	r2,10
8112c50c:	8880030d 	sth	r2,12(r17)
8112c510:	00800044 	movi	r2,1
8112c514:	b80d883a 	mov	r6,r23
8112c518:	89001704 	addi	r4,r17,92
8112c51c:	000b883a 	mov	r5,zero
8112c520:	88000015 	stw	zero,0(r17)
8112c524:	88000115 	stw	zero,4(r17)
8112c528:	88000215 	stw	zero,8(r17)
8112c52c:	88001915 	stw	zero,100(r17)
8112c530:	8880038d 	sth	r2,14(r17)
8112c534:	88000415 	stw	zero,16(r17)
8112c538:	88000515 	stw	zero,20(r17)
8112c53c:	88000615 	stw	zero,24(r17)
8112c540:	1123b940 	call	81123b94 <memset>
8112c544:	94000317 	ldw	r16,12(r18)
8112c548:	00800484 	movi	r2,18
8112c54c:	8c400715 	stw	r17,28(r17)
8112c550:	8d800815 	stw	r22,32(r17)
8112c554:	8d400915 	stw	r21,36(r17)
8112c558:	8d000a15 	stw	r20,40(r17)
8112c55c:	8cc00b15 	stw	r19,44(r17)
8112c560:	8080030d 	sth	r2,12(r16)
8112c564:	00800084 	movi	r2,2
8112c568:	80000015 	stw	zero,0(r16)
8112c56c:	80000115 	stw	zero,4(r16)
8112c570:	80000215 	stw	zero,8(r16)
8112c574:	80001915 	stw	zero,100(r16)
8112c578:	8080038d 	sth	r2,14(r16)
8112c57c:	80000415 	stw	zero,16(r16)
8112c580:	80000515 	stw	zero,20(r16)
8112c584:	80000615 	stw	zero,24(r16)
8112c588:	b80d883a 	mov	r6,r23
8112c58c:	000b883a 	mov	r5,zero
8112c590:	81001704 	addi	r4,r16,92
8112c594:	1123b940 	call	81123b94 <memset>
8112c598:	00800044 	movi	r2,1
8112c59c:	84000715 	stw	r16,28(r16)
8112c5a0:	85800815 	stw	r22,32(r16)
8112c5a4:	85400915 	stw	r21,36(r16)
8112c5a8:	85000a15 	stw	r20,40(r16)
8112c5ac:	84c00b15 	stw	r19,44(r16)
8112c5b0:	90800e15 	stw	r2,56(r18)
8112c5b4:	dfc00817 	ldw	ra,32(sp)
8112c5b8:	ddc00717 	ldw	r23,28(sp)
8112c5bc:	dd800617 	ldw	r22,24(sp)
8112c5c0:	dd400517 	ldw	r21,20(sp)
8112c5c4:	dd000417 	ldw	r20,16(sp)
8112c5c8:	dcc00317 	ldw	r19,12(sp)
8112c5cc:	dc800217 	ldw	r18,8(sp)
8112c5d0:	dc400117 	ldw	r17,4(sp)
8112c5d4:	dc000017 	ldw	r16,0(sp)
8112c5d8:	dec00904 	addi	sp,sp,36
8112c5dc:	f800283a 	ret

8112c5e0 <__fp_lock>:
8112c5e0:	0005883a 	mov	r2,zero
8112c5e4:	f800283a 	ret

8112c5e8 <__sfmoreglue>:
8112c5e8:	defffc04 	addi	sp,sp,-16
8112c5ec:	de00012e 	bgeu	sp,et,8112c5f4 <__sfmoreglue+0xc>
8112c5f0:	003b68fa 	trap	3
8112c5f4:	dc400115 	stw	r17,4(sp)
8112c5f8:	2c7fffc4 	addi	r17,r5,-1
8112c5fc:	8c401a24 	muli	r17,r17,104
8112c600:	dc800215 	stw	r18,8(sp)
8112c604:	2825883a 	mov	r18,r5
8112c608:	89401d04 	addi	r5,r17,116
8112c60c:	dc000015 	stw	r16,0(sp)
8112c610:	dfc00315 	stw	ra,12(sp)
8112c614:	11232300 	call	81123230 <_malloc_r>
8112c618:	1021883a 	mov	r16,r2
8112c61c:	10000726 	beq	r2,zero,8112c63c <__sfmoreglue+0x54>
8112c620:	11000304 	addi	r4,r2,12
8112c624:	10000015 	stw	zero,0(r2)
8112c628:	14800115 	stw	r18,4(r2)
8112c62c:	11000215 	stw	r4,8(r2)
8112c630:	89801a04 	addi	r6,r17,104
8112c634:	000b883a 	mov	r5,zero
8112c638:	1123b940 	call	81123b94 <memset>
8112c63c:	8005883a 	mov	r2,r16
8112c640:	dfc00317 	ldw	ra,12(sp)
8112c644:	dc800217 	ldw	r18,8(sp)
8112c648:	dc400117 	ldw	r17,4(sp)
8112c64c:	dc000017 	ldw	r16,0(sp)
8112c650:	dec00404 	addi	sp,sp,16
8112c654:	f800283a 	ret

8112c658 <__sfp>:
8112c658:	defffb04 	addi	sp,sp,-20
8112c65c:	de00012e 	bgeu	sp,et,8112c664 <__sfp+0xc>
8112c660:	003b68fa 	trap	3
8112c664:	dc000015 	stw	r16,0(sp)
8112c668:	04204574 	movhi	r16,33045
8112c66c:	84111204 	addi	r16,r16,17480
8112c670:	dcc00315 	stw	r19,12(sp)
8112c674:	2027883a 	mov	r19,r4
8112c678:	81000017 	ldw	r4,0(r16)
8112c67c:	dfc00415 	stw	ra,16(sp)
8112c680:	dc800215 	stw	r18,8(sp)
8112c684:	20800e17 	ldw	r2,56(r4)
8112c688:	dc400115 	stw	r17,4(sp)
8112c68c:	1000021e 	bne	r2,zero,8112c698 <__sfp+0x40>
8112c690:	112c43c0 	call	8112c43c <__sinit.part.1>
8112c694:	81000017 	ldw	r4,0(r16)
8112c698:	2480b804 	addi	r18,r4,736
8112c69c:	047fffc4 	movi	r17,-1
8112c6a0:	91000117 	ldw	r4,4(r18)
8112c6a4:	94000217 	ldw	r16,8(r18)
8112c6a8:	213fffc4 	addi	r4,r4,-1
8112c6ac:	20000a16 	blt	r4,zero,8112c6d8 <__sfp+0x80>
8112c6b0:	8080030f 	ldh	r2,12(r16)
8112c6b4:	10000c26 	beq	r2,zero,8112c6e8 <__sfp+0x90>
8112c6b8:	80c01d04 	addi	r3,r16,116
8112c6bc:	00000206 	br	8112c6c8 <__sfp+0x70>
8112c6c0:	18bfe60f 	ldh	r2,-104(r3)
8112c6c4:	10000826 	beq	r2,zero,8112c6e8 <__sfp+0x90>
8112c6c8:	213fffc4 	addi	r4,r4,-1
8112c6cc:	1c3ffd04 	addi	r16,r3,-12
8112c6d0:	18c01a04 	addi	r3,r3,104
8112c6d4:	247ffa1e 	bne	r4,r17,8112c6c0 <__reset+0xfb10c6c0>
8112c6d8:	90800017 	ldw	r2,0(r18)
8112c6dc:	10001d26 	beq	r2,zero,8112c754 <__sfp+0xfc>
8112c6e0:	1025883a 	mov	r18,r2
8112c6e4:	003fee06 	br	8112c6a0 <__reset+0xfb10c6a0>
8112c6e8:	00bfffc4 	movi	r2,-1
8112c6ec:	8080038d 	sth	r2,14(r16)
8112c6f0:	00800044 	movi	r2,1
8112c6f4:	8080030d 	sth	r2,12(r16)
8112c6f8:	80001915 	stw	zero,100(r16)
8112c6fc:	80000015 	stw	zero,0(r16)
8112c700:	80000215 	stw	zero,8(r16)
8112c704:	80000115 	stw	zero,4(r16)
8112c708:	80000415 	stw	zero,16(r16)
8112c70c:	80000515 	stw	zero,20(r16)
8112c710:	80000615 	stw	zero,24(r16)
8112c714:	01800204 	movi	r6,8
8112c718:	000b883a 	mov	r5,zero
8112c71c:	81001704 	addi	r4,r16,92
8112c720:	1123b940 	call	81123b94 <memset>
8112c724:	8005883a 	mov	r2,r16
8112c728:	80000c15 	stw	zero,48(r16)
8112c72c:	80000d15 	stw	zero,52(r16)
8112c730:	80001115 	stw	zero,68(r16)
8112c734:	80001215 	stw	zero,72(r16)
8112c738:	dfc00417 	ldw	ra,16(sp)
8112c73c:	dcc00317 	ldw	r19,12(sp)
8112c740:	dc800217 	ldw	r18,8(sp)
8112c744:	dc400117 	ldw	r17,4(sp)
8112c748:	dc000017 	ldw	r16,0(sp)
8112c74c:	dec00504 	addi	sp,sp,20
8112c750:	f800283a 	ret
8112c754:	01400104 	movi	r5,4
8112c758:	9809883a 	mov	r4,r19
8112c75c:	112c5e80 	call	8112c5e8 <__sfmoreglue>
8112c760:	90800015 	stw	r2,0(r18)
8112c764:	103fde1e 	bne	r2,zero,8112c6e0 <__reset+0xfb10c6e0>
8112c768:	00800304 	movi	r2,12
8112c76c:	98800015 	stw	r2,0(r19)
8112c770:	0005883a 	mov	r2,zero
8112c774:	003ff006 	br	8112c738 <__reset+0xfb10c738>

8112c778 <_cleanup>:
8112c778:	00a04574 	movhi	r2,33045
8112c77c:	10911204 	addi	r2,r2,17480
8112c780:	11000017 	ldw	r4,0(r2)
8112c784:	016044f4 	movhi	r5,33043
8112c788:	29507b04 	addi	r5,r5,16876
8112c78c:	112d4d01 	jmpi	8112d4d0 <_fwalk_reent>

8112c790 <__sinit>:
8112c790:	20800e17 	ldw	r2,56(r4)
8112c794:	10000126 	beq	r2,zero,8112c79c <__sinit+0xc>
8112c798:	f800283a 	ret
8112c79c:	112c43c1 	jmpi	8112c43c <__sinit.part.1>

8112c7a0 <__sfp_lock_acquire>:
8112c7a0:	f800283a 	ret

8112c7a4 <__sfp_lock_release>:
8112c7a4:	f800283a 	ret

8112c7a8 <__sinit_lock_acquire>:
8112c7a8:	f800283a 	ret

8112c7ac <__sinit_lock_release>:
8112c7ac:	f800283a 	ret

8112c7b0 <__fp_lock_all>:
8112c7b0:	00a04574 	movhi	r2,33045
8112c7b4:	10911304 	addi	r2,r2,17484
8112c7b8:	11000017 	ldw	r4,0(r2)
8112c7bc:	016044f4 	movhi	r5,33043
8112c7c0:	29717804 	addi	r5,r5,-14880
8112c7c4:	112d4041 	jmpi	8112d404 <_fwalk>

8112c7c8 <__fp_unlock_all>:
8112c7c8:	00a04574 	movhi	r2,33045
8112c7cc:	10911304 	addi	r2,r2,17484
8112c7d0:	11000017 	ldw	r4,0(r2)
8112c7d4:	016044f4 	movhi	r5,33043
8112c7d8:	29710a04 	addi	r5,r5,-15320
8112c7dc:	112d4041 	jmpi	8112d404 <_fwalk>

8112c7e0 <__sflags>:
8112c7e0:	28800007 	ldb	r2,0(r5)
8112c7e4:	00c01c84 	movi	r3,114
8112c7e8:	10c02426 	beq	r2,r3,8112c87c <__sflags+0x9c>
8112c7ec:	00c01dc4 	movi	r3,119
8112c7f0:	10c01e26 	beq	r2,r3,8112c86c <__sflags+0x8c>
8112c7f4:	00c01844 	movi	r3,97
8112c7f8:	10c00426 	beq	r2,r3,8112c80c <__sflags+0x2c>
8112c7fc:	00800584 	movi	r2,22
8112c800:	20800015 	stw	r2,0(r4)
8112c804:	0005883a 	mov	r2,zero
8112c808:	f800283a 	ret
8112c80c:	02c08204 	movi	r11,520
8112c810:	01000044 	movi	r4,1
8112c814:	00804204 	movi	r2,264
8112c818:	01c00ac4 	movi	r7,43
8112c81c:	02bff8c4 	movi	r10,-29
8112c820:	027fff04 	movi	r9,-4
8112c824:	02001e04 	movi	r8,120
8112c828:	29400044 	addi	r5,r5,1
8112c82c:	28c00007 	ldb	r3,0(r5)
8112c830:	18000626 	beq	r3,zero,8112c84c <__sflags+0x6c>
8112c834:	19c00826 	beq	r3,r7,8112c858 <__sflags+0x78>
8112c838:	1a3ffb1e 	bne	r3,r8,8112c828 <__reset+0xfb10c828>
8112c83c:	29400044 	addi	r5,r5,1
8112c840:	28c00007 	ldb	r3,0(r5)
8112c844:	21020014 	ori	r4,r4,2048
8112c848:	183ffa1e 	bne	r3,zero,8112c834 <__reset+0xfb10c834>
8112c84c:	22c8b03a 	or	r4,r4,r11
8112c850:	31000015 	stw	r4,0(r6)
8112c854:	f800283a 	ret
8112c858:	1284703a 	and	r2,r2,r10
8112c85c:	2248703a 	and	r4,r4,r9
8112c860:	10800414 	ori	r2,r2,16
8112c864:	21000094 	ori	r4,r4,2
8112c868:	003fef06 	br	8112c828 <__reset+0xfb10c828>
8112c86c:	02c18004 	movi	r11,1536
8112c870:	01000044 	movi	r4,1
8112c874:	00800204 	movi	r2,8
8112c878:	003fe706 	br	8112c818 <__reset+0xfb10c818>
8112c87c:	0017883a 	mov	r11,zero
8112c880:	0009883a 	mov	r4,zero
8112c884:	00800104 	movi	r2,4
8112c888:	003fe306 	br	8112c818 <__reset+0xfb10c818>

8112c88c <_fread_r>:
8112c88c:	defff404 	addi	sp,sp,-48
8112c890:	de00012e 	bgeu	sp,et,8112c898 <_fread_r+0xc>
8112c894:	003b68fa 	trap	3
8112c898:	dd800815 	stw	r22,32(sp)
8112c89c:	39ad383a 	mul	r22,r7,r6
8112c8a0:	dc000215 	stw	r16,8(sp)
8112c8a4:	dfc00b15 	stw	ra,44(sp)
8112c8a8:	df000a15 	stw	fp,40(sp)
8112c8ac:	ddc00915 	stw	r23,36(sp)
8112c8b0:	dd400715 	stw	r21,28(sp)
8112c8b4:	dd000615 	stw	r20,24(sp)
8112c8b8:	dcc00515 	stw	r19,20(sp)
8112c8bc:	dc800415 	stw	r18,16(sp)
8112c8c0:	dc400315 	stw	r17,12(sp)
8112c8c4:	dc000c17 	ldw	r16,48(sp)
8112c8c8:	b0003b26 	beq	r22,zero,8112c9b8 <_fread_r+0x12c>
8112c8cc:	302f883a 	mov	r23,r6
8112c8d0:	382b883a 	mov	r21,r7
8112c8d4:	2029883a 	mov	r20,r4
8112c8d8:	2827883a 	mov	r19,r5
8112c8dc:	20000226 	beq	r4,zero,8112c8e8 <_fread_r+0x5c>
8112c8e0:	20800e17 	ldw	r2,56(r4)
8112c8e4:	10006e26 	beq	r2,zero,8112caa0 <_fread_r+0x214>
8112c8e8:	8080030b 	ldhu	r2,12(r16)
8112c8ec:	10c8000c 	andi	r3,r2,8192
8112c8f0:	1800061e 	bne	r3,zero,8112c90c <_fread_r+0x80>
8112c8f4:	81001917 	ldw	r4,100(r16)
8112c8f8:	00f7ffc4 	movi	r3,-8193
8112c8fc:	10880014 	ori	r2,r2,8192
8112c900:	20c6703a 	and	r3,r4,r3
8112c904:	8080030d 	sth	r2,12(r16)
8112c908:	80c01915 	stw	r3,100(r16)
8112c90c:	84400117 	ldw	r17,4(r16)
8112c910:	88005f16 	blt	r17,zero,8112ca90 <_fread_r+0x204>
8112c914:	8809883a 	mov	r4,r17
8112c918:	1080008c 	andi	r2,r2,2
8112c91c:	1000281e 	bne	r2,zero,8112c9c0 <_fread_r+0x134>
8112c920:	b025883a 	mov	r18,r22
8112c924:	00000b06 	br	8112c954 <_fread_r+0xc8>
8112c928:	1123a440 	call	81123a44 <memcpy>
8112c92c:	80800017 	ldw	r2,0(r16)
8112c930:	9c67883a 	add	r19,r19,r17
8112c934:	9465c83a 	sub	r18,r18,r17
8112c938:	1463883a 	add	r17,r2,r17
8112c93c:	800b883a 	mov	r5,r16
8112c940:	a009883a 	mov	r4,r20
8112c944:	84400015 	stw	r17,0(r16)
8112c948:	1123f940 	call	81123f94 <__srefill_r>
8112c94c:	10004c1e 	bne	r2,zero,8112ca80 <_fread_r+0x1f4>
8112c950:	84400117 	ldw	r17,4(r16)
8112c954:	880d883a 	mov	r6,r17
8112c958:	9809883a 	mov	r4,r19
8112c95c:	81400017 	ldw	r5,0(r16)
8112c960:	8cbff136 	bltu	r17,r18,8112c928 <__reset+0xfb10c928>
8112c964:	900d883a 	mov	r6,r18
8112c968:	1123a440 	call	81123a44 <memcpy>
8112c96c:	80c00117 	ldw	r3,4(r16)
8112c970:	81000017 	ldw	r4,0(r16)
8112c974:	a805883a 	mov	r2,r21
8112c978:	1c87c83a 	sub	r3,r3,r18
8112c97c:	24a5883a 	add	r18,r4,r18
8112c980:	80c00115 	stw	r3,4(r16)
8112c984:	84800015 	stw	r18,0(r16)
8112c988:	dfc00b17 	ldw	ra,44(sp)
8112c98c:	df000a17 	ldw	fp,40(sp)
8112c990:	ddc00917 	ldw	r23,36(sp)
8112c994:	dd800817 	ldw	r22,32(sp)
8112c998:	dd400717 	ldw	r21,28(sp)
8112c99c:	dd000617 	ldw	r20,24(sp)
8112c9a0:	dcc00517 	ldw	r19,20(sp)
8112c9a4:	dc800417 	ldw	r18,16(sp)
8112c9a8:	dc400317 	ldw	r17,12(sp)
8112c9ac:	dc000217 	ldw	r16,8(sp)
8112c9b0:	dec00c04 	addi	sp,sp,48
8112c9b4:	f800283a 	ret
8112c9b8:	0005883a 	mov	r2,zero
8112c9bc:	003ff206 	br	8112c988 <__reset+0xfb10c988>
8112c9c0:	b007883a 	mov	r3,r22
8112c9c4:	2580012e 	bgeu	r4,r22,8112c9cc <_fread_r+0x140>
8112c9c8:	2007883a 	mov	r3,r4
8112c9cc:	81400017 	ldw	r5,0(r16)
8112c9d0:	180d883a 	mov	r6,r3
8112c9d4:	9809883a 	mov	r4,r19
8112c9d8:	d8c00115 	stw	r3,4(sp)
8112c9dc:	1123a440 	call	81123a44 <memcpy>
8112c9e0:	d8c00117 	ldw	r3,4(sp)
8112c9e4:	84400017 	ldw	r17,0(r16)
8112c9e8:	80800117 	ldw	r2,4(r16)
8112c9ec:	81400c17 	ldw	r5,48(r16)
8112c9f0:	88e3883a 	add	r17,r17,r3
8112c9f4:	10c5c83a 	sub	r2,r2,r3
8112c9f8:	84400015 	stw	r17,0(r16)
8112c9fc:	80800115 	stw	r2,4(r16)
8112ca00:	b0e5c83a 	sub	r18,r22,r3
8112ca04:	28002b26 	beq	r5,zero,8112cab4 <_fread_r+0x228>
8112ca08:	90002b26 	beq	r18,zero,8112cab8 <_fread_r+0x22c>
8112ca0c:	80801004 	addi	r2,r16,64
8112ca10:	28800526 	beq	r5,r2,8112ca28 <_fread_r+0x19c>
8112ca14:	a009883a 	mov	r4,r20
8112ca18:	d8c00115 	stw	r3,4(sp)
8112ca1c:	112cc280 	call	8112cc28 <_free_r>
8112ca20:	d8c00117 	ldw	r3,4(sp)
8112ca24:	84400017 	ldw	r17,0(r16)
8112ca28:	80000c15 	stw	zero,48(r16)
8112ca2c:	80800517 	ldw	r2,20(r16)
8112ca30:	87000417 	ldw	fp,16(r16)
8112ca34:	98e7883a 	add	r19,r19,r3
8112ca38:	d8800015 	stw	r2,0(sp)
8112ca3c:	00000106 	br	8112ca44 <_fread_r+0x1b8>
8112ca40:	90001d26 	beq	r18,zero,8112cab8 <_fread_r+0x22c>
8112ca44:	84c00415 	stw	r19,16(r16)
8112ca48:	84800515 	stw	r18,20(r16)
8112ca4c:	84c00015 	stw	r19,0(r16)
8112ca50:	a009883a 	mov	r4,r20
8112ca54:	800b883a 	mov	r5,r16
8112ca58:	1123f940 	call	81123f94 <__srefill_r>
8112ca5c:	d9000017 	ldw	r4,0(sp)
8112ca60:	80c00117 	ldw	r3,4(r16)
8112ca64:	87000415 	stw	fp,16(r16)
8112ca68:	81000515 	stw	r4,20(r16)
8112ca6c:	84400015 	stw	r17,0(r16)
8112ca70:	80000115 	stw	zero,4(r16)
8112ca74:	90e5c83a 	sub	r18,r18,r3
8112ca78:	98e7883a 	add	r19,r19,r3
8112ca7c:	103ff026 	beq	r2,zero,8112ca40 <__reset+0xfb10ca40>
8112ca80:	b80b883a 	mov	r5,r23
8112ca84:	b489c83a 	sub	r4,r22,r18
8112ca88:	1135f340 	call	81135f34 <__udivsi3>
8112ca8c:	003fbe06 	br	8112c988 <__reset+0xfb10c988>
8112ca90:	80000115 	stw	zero,4(r16)
8112ca94:	0009883a 	mov	r4,zero
8112ca98:	0023883a 	mov	r17,zero
8112ca9c:	003f9e06 	br	8112c918 <__reset+0xfb10c918>
8112caa0:	112c7900 	call	8112c790 <__sinit>
8112caa4:	8080030b 	ldhu	r2,12(r16)
8112caa8:	10c8000c 	andi	r3,r2,8192
8112caac:	183f971e 	bne	r3,zero,8112c90c <__reset+0xfb10c90c>
8112cab0:	003f9006 	br	8112c8f4 <__reset+0xfb10c8f4>
8112cab4:	903fdd1e 	bne	r18,zero,8112ca2c <__reset+0xfb10ca2c>
8112cab8:	a805883a 	mov	r2,r21
8112cabc:	003fb206 	br	8112c988 <__reset+0xfb10c988>

8112cac0 <fread>:
8112cac0:	defffe04 	addi	sp,sp,-8
8112cac4:	00a04574 	movhi	r2,33045
8112cac8:	de00012e 	bgeu	sp,et,8112cad0 <fread+0x10>
8112cacc:	003b68fa 	trap	3
8112cad0:	10911304 	addi	r2,r2,17484
8112cad4:	d9c00015 	stw	r7,0(sp)
8112cad8:	300f883a 	mov	r7,r6
8112cadc:	280d883a 	mov	r6,r5
8112cae0:	200b883a 	mov	r5,r4
8112cae4:	11000017 	ldw	r4,0(r2)
8112cae8:	dfc00115 	stw	ra,4(sp)
8112caec:	112c88c0 	call	8112c88c <_fread_r>
8112caf0:	dfc00117 	ldw	ra,4(sp)
8112caf4:	dec00204 	addi	sp,sp,8
8112caf8:	f800283a 	ret

8112cafc <_malloc_trim_r>:
8112cafc:	defffb04 	addi	sp,sp,-20
8112cb00:	de00012e 	bgeu	sp,et,8112cb08 <_malloc_trim_r+0xc>
8112cb04:	003b68fa 	trap	3
8112cb08:	dcc00315 	stw	r19,12(sp)
8112cb0c:	04e04574 	movhi	r19,33045
8112cb10:	dc800215 	stw	r18,8(sp)
8112cb14:	dc400115 	stw	r17,4(sp)
8112cb18:	dc000015 	stw	r16,0(sp)
8112cb1c:	dfc00415 	stw	ra,16(sp)
8112cb20:	2821883a 	mov	r16,r5
8112cb24:	9ccad104 	addi	r19,r19,11076
8112cb28:	2025883a 	mov	r18,r4
8112cb2c:	11393f00 	call	811393f0 <__malloc_lock>
8112cb30:	98800217 	ldw	r2,8(r19)
8112cb34:	14400117 	ldw	r17,4(r2)
8112cb38:	00bfff04 	movi	r2,-4
8112cb3c:	88a2703a 	and	r17,r17,r2
8112cb40:	8c21c83a 	sub	r16,r17,r16
8112cb44:	8403fbc4 	addi	r16,r16,4079
8112cb48:	8020d33a 	srli	r16,r16,12
8112cb4c:	0083ffc4 	movi	r2,4095
8112cb50:	843fffc4 	addi	r16,r16,-1
8112cb54:	8020933a 	slli	r16,r16,12
8112cb58:	1400060e 	bge	r2,r16,8112cb74 <_malloc_trim_r+0x78>
8112cb5c:	000b883a 	mov	r5,zero
8112cb60:	9009883a 	mov	r4,r18
8112cb64:	11241700 	call	81124170 <_sbrk_r>
8112cb68:	98c00217 	ldw	r3,8(r19)
8112cb6c:	1c47883a 	add	r3,r3,r17
8112cb70:	10c00a26 	beq	r2,r3,8112cb9c <_malloc_trim_r+0xa0>
8112cb74:	9009883a 	mov	r4,r18
8112cb78:	11395180 	call	81139518 <__malloc_unlock>
8112cb7c:	0005883a 	mov	r2,zero
8112cb80:	dfc00417 	ldw	ra,16(sp)
8112cb84:	dcc00317 	ldw	r19,12(sp)
8112cb88:	dc800217 	ldw	r18,8(sp)
8112cb8c:	dc400117 	ldw	r17,4(sp)
8112cb90:	dc000017 	ldw	r16,0(sp)
8112cb94:	dec00504 	addi	sp,sp,20
8112cb98:	f800283a 	ret
8112cb9c:	040bc83a 	sub	r5,zero,r16
8112cba0:	9009883a 	mov	r4,r18
8112cba4:	11241700 	call	81124170 <_sbrk_r>
8112cba8:	00ffffc4 	movi	r3,-1
8112cbac:	10c00d26 	beq	r2,r3,8112cbe4 <_malloc_trim_r+0xe8>
8112cbb0:	00e04574 	movhi	r3,33045
8112cbb4:	18d21604 	addi	r3,r3,18520
8112cbb8:	18800017 	ldw	r2,0(r3)
8112cbbc:	99000217 	ldw	r4,8(r19)
8112cbc0:	8c23c83a 	sub	r17,r17,r16
8112cbc4:	8c400054 	ori	r17,r17,1
8112cbc8:	1421c83a 	sub	r16,r2,r16
8112cbcc:	24400115 	stw	r17,4(r4)
8112cbd0:	9009883a 	mov	r4,r18
8112cbd4:	1c000015 	stw	r16,0(r3)
8112cbd8:	11395180 	call	81139518 <__malloc_unlock>
8112cbdc:	00800044 	movi	r2,1
8112cbe0:	003fe706 	br	8112cb80 <__reset+0xfb10cb80>
8112cbe4:	000b883a 	mov	r5,zero
8112cbe8:	9009883a 	mov	r4,r18
8112cbec:	11241700 	call	81124170 <_sbrk_r>
8112cbf0:	99000217 	ldw	r4,8(r19)
8112cbf4:	014003c4 	movi	r5,15
8112cbf8:	1107c83a 	sub	r3,r2,r4
8112cbfc:	28ffdd0e 	bge	r5,r3,8112cb74 <__reset+0xfb10cb74>
8112cc00:	01604574 	movhi	r5,33045
8112cc04:	29511404 	addi	r5,r5,17488
8112cc08:	29400017 	ldw	r5,0(r5)
8112cc0c:	18c00054 	ori	r3,r3,1
8112cc10:	20c00115 	stw	r3,4(r4)
8112cc14:	00e04574 	movhi	r3,33045
8112cc18:	1145c83a 	sub	r2,r2,r5
8112cc1c:	18d21604 	addi	r3,r3,18520
8112cc20:	18800015 	stw	r2,0(r3)
8112cc24:	003fd306 	br	8112cb74 <__reset+0xfb10cb74>

8112cc28 <_free_r>:
8112cc28:	28004326 	beq	r5,zero,8112cd38 <_free_r+0x110>
8112cc2c:	defffd04 	addi	sp,sp,-12
8112cc30:	de00012e 	bgeu	sp,et,8112cc38 <_free_r+0x10>
8112cc34:	003b68fa 	trap	3
8112cc38:	dc400115 	stw	r17,4(sp)
8112cc3c:	dc000015 	stw	r16,0(sp)
8112cc40:	2023883a 	mov	r17,r4
8112cc44:	2821883a 	mov	r16,r5
8112cc48:	dfc00215 	stw	ra,8(sp)
8112cc4c:	11393f00 	call	811393f0 <__malloc_lock>
8112cc50:	81ffff17 	ldw	r7,-4(r16)
8112cc54:	00bfff84 	movi	r2,-2
8112cc58:	01204574 	movhi	r4,33045
8112cc5c:	81bffe04 	addi	r6,r16,-8
8112cc60:	3884703a 	and	r2,r7,r2
8112cc64:	210ad104 	addi	r4,r4,11076
8112cc68:	308b883a 	add	r5,r6,r2
8112cc6c:	2a400117 	ldw	r9,4(r5)
8112cc70:	22000217 	ldw	r8,8(r4)
8112cc74:	00ffff04 	movi	r3,-4
8112cc78:	48c6703a 	and	r3,r9,r3
8112cc7c:	2a005726 	beq	r5,r8,8112cddc <_free_r+0x1b4>
8112cc80:	28c00115 	stw	r3,4(r5)
8112cc84:	39c0004c 	andi	r7,r7,1
8112cc88:	3800091e 	bne	r7,zero,8112ccb0 <_free_r+0x88>
8112cc8c:	823ffe17 	ldw	r8,-8(r16)
8112cc90:	22400204 	addi	r9,r4,8
8112cc94:	320dc83a 	sub	r6,r6,r8
8112cc98:	31c00217 	ldw	r7,8(r6)
8112cc9c:	1205883a 	add	r2,r2,r8
8112cca0:	3a406526 	beq	r7,r9,8112ce38 <_free_r+0x210>
8112cca4:	32000317 	ldw	r8,12(r6)
8112cca8:	3a000315 	stw	r8,12(r7)
8112ccac:	41c00215 	stw	r7,8(r8)
8112ccb0:	28cf883a 	add	r7,r5,r3
8112ccb4:	39c00117 	ldw	r7,4(r7)
8112ccb8:	39c0004c 	andi	r7,r7,1
8112ccbc:	38003a26 	beq	r7,zero,8112cda8 <_free_r+0x180>
8112ccc0:	10c00054 	ori	r3,r2,1
8112ccc4:	30c00115 	stw	r3,4(r6)
8112ccc8:	3087883a 	add	r3,r6,r2
8112cccc:	18800015 	stw	r2,0(r3)
8112ccd0:	00c07fc4 	movi	r3,511
8112ccd4:	18801936 	bltu	r3,r2,8112cd3c <_free_r+0x114>
8112ccd8:	1004d0fa 	srli	r2,r2,3
8112ccdc:	01c00044 	movi	r7,1
8112cce0:	21400117 	ldw	r5,4(r4)
8112cce4:	10c00044 	addi	r3,r2,1
8112cce8:	18c7883a 	add	r3,r3,r3
8112ccec:	1005d0ba 	srai	r2,r2,2
8112ccf0:	18c7883a 	add	r3,r3,r3
8112ccf4:	18c7883a 	add	r3,r3,r3
8112ccf8:	1907883a 	add	r3,r3,r4
8112ccfc:	3884983a 	sll	r2,r7,r2
8112cd00:	19c00017 	ldw	r7,0(r3)
8112cd04:	1a3ffe04 	addi	r8,r3,-8
8112cd08:	1144b03a 	or	r2,r2,r5
8112cd0c:	32000315 	stw	r8,12(r6)
8112cd10:	31c00215 	stw	r7,8(r6)
8112cd14:	20800115 	stw	r2,4(r4)
8112cd18:	19800015 	stw	r6,0(r3)
8112cd1c:	39800315 	stw	r6,12(r7)
8112cd20:	8809883a 	mov	r4,r17
8112cd24:	dfc00217 	ldw	ra,8(sp)
8112cd28:	dc400117 	ldw	r17,4(sp)
8112cd2c:	dc000017 	ldw	r16,0(sp)
8112cd30:	dec00304 	addi	sp,sp,12
8112cd34:	11395181 	jmpi	81139518 <__malloc_unlock>
8112cd38:	f800283a 	ret
8112cd3c:	100ad27a 	srli	r5,r2,9
8112cd40:	00c00104 	movi	r3,4
8112cd44:	19404a36 	bltu	r3,r5,8112ce70 <_free_r+0x248>
8112cd48:	100ad1ba 	srli	r5,r2,6
8112cd4c:	28c00e44 	addi	r3,r5,57
8112cd50:	18c7883a 	add	r3,r3,r3
8112cd54:	29400e04 	addi	r5,r5,56
8112cd58:	18c7883a 	add	r3,r3,r3
8112cd5c:	18c7883a 	add	r3,r3,r3
8112cd60:	1909883a 	add	r4,r3,r4
8112cd64:	20c00017 	ldw	r3,0(r4)
8112cd68:	01e04574 	movhi	r7,33045
8112cd6c:	213ffe04 	addi	r4,r4,-8
8112cd70:	39cad104 	addi	r7,r7,11076
8112cd74:	20c04426 	beq	r4,r3,8112ce88 <_free_r+0x260>
8112cd78:	01ffff04 	movi	r7,-4
8112cd7c:	19400117 	ldw	r5,4(r3)
8112cd80:	29ca703a 	and	r5,r5,r7
8112cd84:	1140022e 	bgeu	r2,r5,8112cd90 <_free_r+0x168>
8112cd88:	18c00217 	ldw	r3,8(r3)
8112cd8c:	20fffb1e 	bne	r4,r3,8112cd7c <__reset+0xfb10cd7c>
8112cd90:	19000317 	ldw	r4,12(r3)
8112cd94:	31000315 	stw	r4,12(r6)
8112cd98:	30c00215 	stw	r3,8(r6)
8112cd9c:	21800215 	stw	r6,8(r4)
8112cda0:	19800315 	stw	r6,12(r3)
8112cda4:	003fde06 	br	8112cd20 <__reset+0xfb10cd20>
8112cda8:	29c00217 	ldw	r7,8(r5)
8112cdac:	10c5883a 	add	r2,r2,r3
8112cdb0:	00e04574 	movhi	r3,33045
8112cdb4:	18cad304 	addi	r3,r3,11084
8112cdb8:	38c03b26 	beq	r7,r3,8112cea8 <_free_r+0x280>
8112cdbc:	2a000317 	ldw	r8,12(r5)
8112cdc0:	11400054 	ori	r5,r2,1
8112cdc4:	3087883a 	add	r3,r6,r2
8112cdc8:	3a000315 	stw	r8,12(r7)
8112cdcc:	41c00215 	stw	r7,8(r8)
8112cdd0:	31400115 	stw	r5,4(r6)
8112cdd4:	18800015 	stw	r2,0(r3)
8112cdd8:	003fbd06 	br	8112ccd0 <__reset+0xfb10ccd0>
8112cddc:	39c0004c 	andi	r7,r7,1
8112cde0:	10c5883a 	add	r2,r2,r3
8112cde4:	3800071e 	bne	r7,zero,8112ce04 <_free_r+0x1dc>
8112cde8:	81fffe17 	ldw	r7,-8(r16)
8112cdec:	31cdc83a 	sub	r6,r6,r7
8112cdf0:	30c00317 	ldw	r3,12(r6)
8112cdf4:	31400217 	ldw	r5,8(r6)
8112cdf8:	11c5883a 	add	r2,r2,r7
8112cdfc:	28c00315 	stw	r3,12(r5)
8112ce00:	19400215 	stw	r5,8(r3)
8112ce04:	10c00054 	ori	r3,r2,1
8112ce08:	30c00115 	stw	r3,4(r6)
8112ce0c:	00e04574 	movhi	r3,33045
8112ce10:	18d11504 	addi	r3,r3,17492
8112ce14:	18c00017 	ldw	r3,0(r3)
8112ce18:	21800215 	stw	r6,8(r4)
8112ce1c:	10ffc036 	bltu	r2,r3,8112cd20 <__reset+0xfb10cd20>
8112ce20:	00a04574 	movhi	r2,33045
8112ce24:	10918904 	addi	r2,r2,17956
8112ce28:	11400017 	ldw	r5,0(r2)
8112ce2c:	8809883a 	mov	r4,r17
8112ce30:	112cafc0 	call	8112cafc <_malloc_trim_r>
8112ce34:	003fba06 	br	8112cd20 <__reset+0xfb10cd20>
8112ce38:	28c9883a 	add	r4,r5,r3
8112ce3c:	21000117 	ldw	r4,4(r4)
8112ce40:	2100004c 	andi	r4,r4,1
8112ce44:	2000391e 	bne	r4,zero,8112cf2c <_free_r+0x304>
8112ce48:	29c00217 	ldw	r7,8(r5)
8112ce4c:	29000317 	ldw	r4,12(r5)
8112ce50:	1885883a 	add	r2,r3,r2
8112ce54:	10c00054 	ori	r3,r2,1
8112ce58:	39000315 	stw	r4,12(r7)
8112ce5c:	21c00215 	stw	r7,8(r4)
8112ce60:	30c00115 	stw	r3,4(r6)
8112ce64:	308d883a 	add	r6,r6,r2
8112ce68:	30800015 	stw	r2,0(r6)
8112ce6c:	003fac06 	br	8112cd20 <__reset+0xfb10cd20>
8112ce70:	00c00504 	movi	r3,20
8112ce74:	19401536 	bltu	r3,r5,8112cecc <_free_r+0x2a4>
8112ce78:	28c01704 	addi	r3,r5,92
8112ce7c:	18c7883a 	add	r3,r3,r3
8112ce80:	294016c4 	addi	r5,r5,91
8112ce84:	003fb406 	br	8112cd58 <__reset+0xfb10cd58>
8112ce88:	280bd0ba 	srai	r5,r5,2
8112ce8c:	00c00044 	movi	r3,1
8112ce90:	38800117 	ldw	r2,4(r7)
8112ce94:	194a983a 	sll	r5,r3,r5
8112ce98:	2007883a 	mov	r3,r4
8112ce9c:	2884b03a 	or	r2,r5,r2
8112cea0:	38800115 	stw	r2,4(r7)
8112cea4:	003fbb06 	br	8112cd94 <__reset+0xfb10cd94>
8112cea8:	21800515 	stw	r6,20(r4)
8112ceac:	21800415 	stw	r6,16(r4)
8112ceb0:	10c00054 	ori	r3,r2,1
8112ceb4:	31c00315 	stw	r7,12(r6)
8112ceb8:	31c00215 	stw	r7,8(r6)
8112cebc:	30c00115 	stw	r3,4(r6)
8112cec0:	308d883a 	add	r6,r6,r2
8112cec4:	30800015 	stw	r2,0(r6)
8112cec8:	003f9506 	br	8112cd20 <__reset+0xfb10cd20>
8112cecc:	00c01504 	movi	r3,84
8112ced0:	19400536 	bltu	r3,r5,8112cee8 <_free_r+0x2c0>
8112ced4:	100ad33a 	srli	r5,r2,12
8112ced8:	28c01bc4 	addi	r3,r5,111
8112cedc:	18c7883a 	add	r3,r3,r3
8112cee0:	29401b84 	addi	r5,r5,110
8112cee4:	003f9c06 	br	8112cd58 <__reset+0xfb10cd58>
8112cee8:	00c05504 	movi	r3,340
8112ceec:	19400536 	bltu	r3,r5,8112cf04 <_free_r+0x2dc>
8112cef0:	100ad3fa 	srli	r5,r2,15
8112cef4:	28c01e04 	addi	r3,r5,120
8112cef8:	18c7883a 	add	r3,r3,r3
8112cefc:	29401dc4 	addi	r5,r5,119
8112cf00:	003f9506 	br	8112cd58 <__reset+0xfb10cd58>
8112cf04:	00c15504 	movi	r3,1364
8112cf08:	19400536 	bltu	r3,r5,8112cf20 <_free_r+0x2f8>
8112cf0c:	100ad4ba 	srli	r5,r2,18
8112cf10:	28c01f44 	addi	r3,r5,125
8112cf14:	18c7883a 	add	r3,r3,r3
8112cf18:	29401f04 	addi	r5,r5,124
8112cf1c:	003f8e06 	br	8112cd58 <__reset+0xfb10cd58>
8112cf20:	00c03f84 	movi	r3,254
8112cf24:	01401f84 	movi	r5,126
8112cf28:	003f8b06 	br	8112cd58 <__reset+0xfb10cd58>
8112cf2c:	10c00054 	ori	r3,r2,1
8112cf30:	30c00115 	stw	r3,4(r6)
8112cf34:	308d883a 	add	r6,r6,r2
8112cf38:	30800015 	stw	r2,0(r6)
8112cf3c:	003f7806 	br	8112cd20 <__reset+0xfb10cd20>

8112cf40 <__sfvwrite_r>:
8112cf40:	30800217 	ldw	r2,8(r6)
8112cf44:	10006926 	beq	r2,zero,8112d0ec <__sfvwrite_r+0x1ac>
8112cf48:	defff404 	addi	sp,sp,-48
8112cf4c:	de00012e 	bgeu	sp,et,8112cf54 <__sfvwrite_r+0x14>
8112cf50:	003b68fa 	trap	3
8112cf54:	28c0030b 	ldhu	r3,12(r5)
8112cf58:	dd400715 	stw	r21,28(sp)
8112cf5c:	dd000615 	stw	r20,24(sp)
8112cf60:	dc000215 	stw	r16,8(sp)
8112cf64:	dfc00b15 	stw	ra,44(sp)
8112cf68:	df000a15 	stw	fp,40(sp)
8112cf6c:	ddc00915 	stw	r23,36(sp)
8112cf70:	dd800815 	stw	r22,32(sp)
8112cf74:	dcc00515 	stw	r19,20(sp)
8112cf78:	dc800415 	stw	r18,16(sp)
8112cf7c:	dc400315 	stw	r17,12(sp)
8112cf80:	1880020c 	andi	r2,r3,8
8112cf84:	2821883a 	mov	r16,r5
8112cf88:	202b883a 	mov	r21,r4
8112cf8c:	3029883a 	mov	r20,r6
8112cf90:	10002726 	beq	r2,zero,8112d030 <__sfvwrite_r+0xf0>
8112cf94:	28800417 	ldw	r2,16(r5)
8112cf98:	10002526 	beq	r2,zero,8112d030 <__sfvwrite_r+0xf0>
8112cf9c:	1880008c 	andi	r2,r3,2
8112cfa0:	a4400017 	ldw	r17,0(r20)
8112cfa4:	10002a26 	beq	r2,zero,8112d050 <__sfvwrite_r+0x110>
8112cfa8:	05a00034 	movhi	r22,32768
8112cfac:	0027883a 	mov	r19,zero
8112cfb0:	0025883a 	mov	r18,zero
8112cfb4:	b5bf0004 	addi	r22,r22,-1024
8112cfb8:	980d883a 	mov	r6,r19
8112cfbc:	a809883a 	mov	r4,r21
8112cfc0:	90004626 	beq	r18,zero,8112d0dc <__sfvwrite_r+0x19c>
8112cfc4:	900f883a 	mov	r7,r18
8112cfc8:	b480022e 	bgeu	r22,r18,8112cfd4 <__sfvwrite_r+0x94>
8112cfcc:	01e00034 	movhi	r7,32768
8112cfd0:	39ff0004 	addi	r7,r7,-1024
8112cfd4:	80800917 	ldw	r2,36(r16)
8112cfd8:	81400717 	ldw	r5,28(r16)
8112cfdc:	103ee83a 	callr	r2
8112cfe0:	0080570e 	bge	zero,r2,8112d140 <__sfvwrite_r+0x200>
8112cfe4:	a0c00217 	ldw	r3,8(r20)
8112cfe8:	98a7883a 	add	r19,r19,r2
8112cfec:	90a5c83a 	sub	r18,r18,r2
8112cff0:	1885c83a 	sub	r2,r3,r2
8112cff4:	a0800215 	stw	r2,8(r20)
8112cff8:	103fef1e 	bne	r2,zero,8112cfb8 <__reset+0xfb10cfb8>
8112cffc:	0005883a 	mov	r2,zero
8112d000:	dfc00b17 	ldw	ra,44(sp)
8112d004:	df000a17 	ldw	fp,40(sp)
8112d008:	ddc00917 	ldw	r23,36(sp)
8112d00c:	dd800817 	ldw	r22,32(sp)
8112d010:	dd400717 	ldw	r21,28(sp)
8112d014:	dd000617 	ldw	r20,24(sp)
8112d018:	dcc00517 	ldw	r19,20(sp)
8112d01c:	dc800417 	ldw	r18,16(sp)
8112d020:	dc400317 	ldw	r17,12(sp)
8112d024:	dc000217 	ldw	r16,8(sp)
8112d028:	dec00c04 	addi	sp,sp,48
8112d02c:	f800283a 	ret
8112d030:	800b883a 	mov	r5,r16
8112d034:	a809883a 	mov	r4,r21
8112d038:	112a7200 	call	8112a720 <__swsetup_r>
8112d03c:	1000eb1e 	bne	r2,zero,8112d3ec <__sfvwrite_r+0x4ac>
8112d040:	80c0030b 	ldhu	r3,12(r16)
8112d044:	a4400017 	ldw	r17,0(r20)
8112d048:	1880008c 	andi	r2,r3,2
8112d04c:	103fd61e 	bne	r2,zero,8112cfa8 <__reset+0xfb10cfa8>
8112d050:	1880004c 	andi	r2,r3,1
8112d054:	10003f1e 	bne	r2,zero,8112d154 <__sfvwrite_r+0x214>
8112d058:	0039883a 	mov	fp,zero
8112d05c:	0025883a 	mov	r18,zero
8112d060:	90001a26 	beq	r18,zero,8112d0cc <__sfvwrite_r+0x18c>
8112d064:	1880800c 	andi	r2,r3,512
8112d068:	84c00217 	ldw	r19,8(r16)
8112d06c:	10002126 	beq	r2,zero,8112d0f4 <__sfvwrite_r+0x1b4>
8112d070:	982f883a 	mov	r23,r19
8112d074:	94c09336 	bltu	r18,r19,8112d2c4 <__sfvwrite_r+0x384>
8112d078:	1881200c 	andi	r2,r3,1152
8112d07c:	10009e1e 	bne	r2,zero,8112d2f8 <__sfvwrite_r+0x3b8>
8112d080:	81000017 	ldw	r4,0(r16)
8112d084:	b80d883a 	mov	r6,r23
8112d088:	e00b883a 	mov	r5,fp
8112d08c:	112da9c0 	call	8112da9c <memmove>
8112d090:	80c00217 	ldw	r3,8(r16)
8112d094:	81000017 	ldw	r4,0(r16)
8112d098:	9005883a 	mov	r2,r18
8112d09c:	1ce7c83a 	sub	r19,r3,r19
8112d0a0:	25cf883a 	add	r7,r4,r23
8112d0a4:	84c00215 	stw	r19,8(r16)
8112d0a8:	81c00015 	stw	r7,0(r16)
8112d0ac:	a0c00217 	ldw	r3,8(r20)
8112d0b0:	e0b9883a 	add	fp,fp,r2
8112d0b4:	90a5c83a 	sub	r18,r18,r2
8112d0b8:	18a7c83a 	sub	r19,r3,r2
8112d0bc:	a4c00215 	stw	r19,8(r20)
8112d0c0:	983fce26 	beq	r19,zero,8112cffc <__reset+0xfb10cffc>
8112d0c4:	80c0030b 	ldhu	r3,12(r16)
8112d0c8:	903fe61e 	bne	r18,zero,8112d064 <__reset+0xfb10d064>
8112d0cc:	8f000017 	ldw	fp,0(r17)
8112d0d0:	8c800117 	ldw	r18,4(r17)
8112d0d4:	8c400204 	addi	r17,r17,8
8112d0d8:	003fe106 	br	8112d060 <__reset+0xfb10d060>
8112d0dc:	8cc00017 	ldw	r19,0(r17)
8112d0e0:	8c800117 	ldw	r18,4(r17)
8112d0e4:	8c400204 	addi	r17,r17,8
8112d0e8:	003fb306 	br	8112cfb8 <__reset+0xfb10cfb8>
8112d0ec:	0005883a 	mov	r2,zero
8112d0f0:	f800283a 	ret
8112d0f4:	81000017 	ldw	r4,0(r16)
8112d0f8:	80800417 	ldw	r2,16(r16)
8112d0fc:	11005736 	bltu	r2,r4,8112d25c <__sfvwrite_r+0x31c>
8112d100:	85c00517 	ldw	r23,20(r16)
8112d104:	95c05536 	bltu	r18,r23,8112d25c <__sfvwrite_r+0x31c>
8112d108:	00a00034 	movhi	r2,32768
8112d10c:	10bfffc4 	addi	r2,r2,-1
8112d110:	9009883a 	mov	r4,r18
8112d114:	1480012e 	bgeu	r2,r18,8112d11c <__sfvwrite_r+0x1dc>
8112d118:	1009883a 	mov	r4,r2
8112d11c:	b80b883a 	mov	r5,r23
8112d120:	1135e3c0 	call	81135e3c <__divsi3>
8112d124:	15cf383a 	mul	r7,r2,r23
8112d128:	81400717 	ldw	r5,28(r16)
8112d12c:	80800917 	ldw	r2,36(r16)
8112d130:	e00d883a 	mov	r6,fp
8112d134:	a809883a 	mov	r4,r21
8112d138:	103ee83a 	callr	r2
8112d13c:	00bfdb16 	blt	zero,r2,8112d0ac <__reset+0xfb10d0ac>
8112d140:	8080030b 	ldhu	r2,12(r16)
8112d144:	10801014 	ori	r2,r2,64
8112d148:	8080030d 	sth	r2,12(r16)
8112d14c:	00bfffc4 	movi	r2,-1
8112d150:	003fab06 	br	8112d000 <__reset+0xfb10d000>
8112d154:	0027883a 	mov	r19,zero
8112d158:	0011883a 	mov	r8,zero
8112d15c:	0039883a 	mov	fp,zero
8112d160:	0025883a 	mov	r18,zero
8112d164:	90001f26 	beq	r18,zero,8112d1e4 <__sfvwrite_r+0x2a4>
8112d168:	40005a26 	beq	r8,zero,8112d2d4 <__sfvwrite_r+0x394>
8112d16c:	982d883a 	mov	r22,r19
8112d170:	94c0012e 	bgeu	r18,r19,8112d178 <__sfvwrite_r+0x238>
8112d174:	902d883a 	mov	r22,r18
8112d178:	81000017 	ldw	r4,0(r16)
8112d17c:	80800417 	ldw	r2,16(r16)
8112d180:	b02f883a 	mov	r23,r22
8112d184:	81c00517 	ldw	r7,20(r16)
8112d188:	1100032e 	bgeu	r2,r4,8112d198 <__sfvwrite_r+0x258>
8112d18c:	80c00217 	ldw	r3,8(r16)
8112d190:	38c7883a 	add	r3,r7,r3
8112d194:	1d801816 	blt	r3,r22,8112d1f8 <__sfvwrite_r+0x2b8>
8112d198:	b1c03e16 	blt	r22,r7,8112d294 <__sfvwrite_r+0x354>
8112d19c:	80800917 	ldw	r2,36(r16)
8112d1a0:	81400717 	ldw	r5,28(r16)
8112d1a4:	e00d883a 	mov	r6,fp
8112d1a8:	da000115 	stw	r8,4(sp)
8112d1ac:	a809883a 	mov	r4,r21
8112d1b0:	103ee83a 	callr	r2
8112d1b4:	102f883a 	mov	r23,r2
8112d1b8:	da000117 	ldw	r8,4(sp)
8112d1bc:	00bfe00e 	bge	zero,r2,8112d140 <__reset+0xfb10d140>
8112d1c0:	9de7c83a 	sub	r19,r19,r23
8112d1c4:	98001f26 	beq	r19,zero,8112d244 <__sfvwrite_r+0x304>
8112d1c8:	a0800217 	ldw	r2,8(r20)
8112d1cc:	e5f9883a 	add	fp,fp,r23
8112d1d0:	95e5c83a 	sub	r18,r18,r23
8112d1d4:	15efc83a 	sub	r23,r2,r23
8112d1d8:	a5c00215 	stw	r23,8(r20)
8112d1dc:	b83f8726 	beq	r23,zero,8112cffc <__reset+0xfb10cffc>
8112d1e0:	903fe11e 	bne	r18,zero,8112d168 <__reset+0xfb10d168>
8112d1e4:	8f000017 	ldw	fp,0(r17)
8112d1e8:	8c800117 	ldw	r18,4(r17)
8112d1ec:	0011883a 	mov	r8,zero
8112d1f0:	8c400204 	addi	r17,r17,8
8112d1f4:	003fdb06 	br	8112d164 <__reset+0xfb10d164>
8112d1f8:	180d883a 	mov	r6,r3
8112d1fc:	e00b883a 	mov	r5,fp
8112d200:	da000115 	stw	r8,4(sp)
8112d204:	d8c00015 	stw	r3,0(sp)
8112d208:	112da9c0 	call	8112da9c <memmove>
8112d20c:	d8c00017 	ldw	r3,0(sp)
8112d210:	80800017 	ldw	r2,0(r16)
8112d214:	800b883a 	mov	r5,r16
8112d218:	a809883a 	mov	r4,r21
8112d21c:	10c5883a 	add	r2,r2,r3
8112d220:	80800015 	stw	r2,0(r16)
8112d224:	d8c00015 	stw	r3,0(sp)
8112d228:	112c3940 	call	8112c394 <_fflush_r>
8112d22c:	d8c00017 	ldw	r3,0(sp)
8112d230:	da000117 	ldw	r8,4(sp)
8112d234:	103fc21e 	bne	r2,zero,8112d140 <__reset+0xfb10d140>
8112d238:	182f883a 	mov	r23,r3
8112d23c:	9de7c83a 	sub	r19,r19,r23
8112d240:	983fe11e 	bne	r19,zero,8112d1c8 <__reset+0xfb10d1c8>
8112d244:	800b883a 	mov	r5,r16
8112d248:	a809883a 	mov	r4,r21
8112d24c:	112c3940 	call	8112c394 <_fflush_r>
8112d250:	103fbb1e 	bne	r2,zero,8112d140 <__reset+0xfb10d140>
8112d254:	0011883a 	mov	r8,zero
8112d258:	003fdb06 	br	8112d1c8 <__reset+0xfb10d1c8>
8112d25c:	94c0012e 	bgeu	r18,r19,8112d264 <__sfvwrite_r+0x324>
8112d260:	9027883a 	mov	r19,r18
8112d264:	980d883a 	mov	r6,r19
8112d268:	e00b883a 	mov	r5,fp
8112d26c:	112da9c0 	call	8112da9c <memmove>
8112d270:	80800217 	ldw	r2,8(r16)
8112d274:	80c00017 	ldw	r3,0(r16)
8112d278:	14c5c83a 	sub	r2,r2,r19
8112d27c:	1cc7883a 	add	r3,r3,r19
8112d280:	80800215 	stw	r2,8(r16)
8112d284:	80c00015 	stw	r3,0(r16)
8112d288:	10004326 	beq	r2,zero,8112d398 <__sfvwrite_r+0x458>
8112d28c:	9805883a 	mov	r2,r19
8112d290:	003f8606 	br	8112d0ac <__reset+0xfb10d0ac>
8112d294:	b00d883a 	mov	r6,r22
8112d298:	e00b883a 	mov	r5,fp
8112d29c:	da000115 	stw	r8,4(sp)
8112d2a0:	112da9c0 	call	8112da9c <memmove>
8112d2a4:	80800217 	ldw	r2,8(r16)
8112d2a8:	80c00017 	ldw	r3,0(r16)
8112d2ac:	da000117 	ldw	r8,4(sp)
8112d2b0:	1585c83a 	sub	r2,r2,r22
8112d2b4:	1dad883a 	add	r22,r3,r22
8112d2b8:	80800215 	stw	r2,8(r16)
8112d2bc:	85800015 	stw	r22,0(r16)
8112d2c0:	003fbf06 	br	8112d1c0 <__reset+0xfb10d1c0>
8112d2c4:	81000017 	ldw	r4,0(r16)
8112d2c8:	9027883a 	mov	r19,r18
8112d2cc:	902f883a 	mov	r23,r18
8112d2d0:	003f6c06 	br	8112d084 <__reset+0xfb10d084>
8112d2d4:	900d883a 	mov	r6,r18
8112d2d8:	01400284 	movi	r5,10
8112d2dc:	e009883a 	mov	r4,fp
8112d2e0:	112d9b80 	call	8112d9b8 <memchr>
8112d2e4:	10003e26 	beq	r2,zero,8112d3e0 <__sfvwrite_r+0x4a0>
8112d2e8:	10800044 	addi	r2,r2,1
8112d2ec:	1727c83a 	sub	r19,r2,fp
8112d2f0:	02000044 	movi	r8,1
8112d2f4:	003f9d06 	br	8112d16c <__reset+0xfb10d16c>
8112d2f8:	80800517 	ldw	r2,20(r16)
8112d2fc:	81400417 	ldw	r5,16(r16)
8112d300:	81c00017 	ldw	r7,0(r16)
8112d304:	10a7883a 	add	r19,r2,r2
8112d308:	9885883a 	add	r2,r19,r2
8112d30c:	1026d7fa 	srli	r19,r2,31
8112d310:	396dc83a 	sub	r22,r7,r5
8112d314:	b1000044 	addi	r4,r22,1
8112d318:	9885883a 	add	r2,r19,r2
8112d31c:	1027d07a 	srai	r19,r2,1
8112d320:	2485883a 	add	r2,r4,r18
8112d324:	980d883a 	mov	r6,r19
8112d328:	9880022e 	bgeu	r19,r2,8112d334 <__sfvwrite_r+0x3f4>
8112d32c:	1027883a 	mov	r19,r2
8112d330:	100d883a 	mov	r6,r2
8112d334:	18c1000c 	andi	r3,r3,1024
8112d338:	18001c26 	beq	r3,zero,8112d3ac <__sfvwrite_r+0x46c>
8112d33c:	300b883a 	mov	r5,r6
8112d340:	a809883a 	mov	r4,r21
8112d344:	11232300 	call	81123230 <_malloc_r>
8112d348:	102f883a 	mov	r23,r2
8112d34c:	10002926 	beq	r2,zero,8112d3f4 <__sfvwrite_r+0x4b4>
8112d350:	81400417 	ldw	r5,16(r16)
8112d354:	b00d883a 	mov	r6,r22
8112d358:	1009883a 	mov	r4,r2
8112d35c:	1123a440 	call	81123a44 <memcpy>
8112d360:	8080030b 	ldhu	r2,12(r16)
8112d364:	00fedfc4 	movi	r3,-1153
8112d368:	10c4703a 	and	r2,r2,r3
8112d36c:	10802014 	ori	r2,r2,128
8112d370:	8080030d 	sth	r2,12(r16)
8112d374:	bd89883a 	add	r4,r23,r22
8112d378:	9d8fc83a 	sub	r7,r19,r22
8112d37c:	85c00415 	stw	r23,16(r16)
8112d380:	84c00515 	stw	r19,20(r16)
8112d384:	81000015 	stw	r4,0(r16)
8112d388:	9027883a 	mov	r19,r18
8112d38c:	81c00215 	stw	r7,8(r16)
8112d390:	902f883a 	mov	r23,r18
8112d394:	003f3b06 	br	8112d084 <__reset+0xfb10d084>
8112d398:	800b883a 	mov	r5,r16
8112d39c:	a809883a 	mov	r4,r21
8112d3a0:	112c3940 	call	8112c394 <_fflush_r>
8112d3a4:	103fb926 	beq	r2,zero,8112d28c <__reset+0xfb10d28c>
8112d3a8:	003f6506 	br	8112d140 <__reset+0xfb10d140>
8112d3ac:	a809883a 	mov	r4,r21
8112d3b0:	112ecbc0 	call	8112ecbc <_realloc_r>
8112d3b4:	102f883a 	mov	r23,r2
8112d3b8:	103fee1e 	bne	r2,zero,8112d374 <__reset+0xfb10d374>
8112d3bc:	81400417 	ldw	r5,16(r16)
8112d3c0:	a809883a 	mov	r4,r21
8112d3c4:	112cc280 	call	8112cc28 <_free_r>
8112d3c8:	8080030b 	ldhu	r2,12(r16)
8112d3cc:	00ffdfc4 	movi	r3,-129
8112d3d0:	1884703a 	and	r2,r3,r2
8112d3d4:	00c00304 	movi	r3,12
8112d3d8:	a8c00015 	stw	r3,0(r21)
8112d3dc:	003f5906 	br	8112d144 <__reset+0xfb10d144>
8112d3e0:	94c00044 	addi	r19,r18,1
8112d3e4:	02000044 	movi	r8,1
8112d3e8:	003f6006 	br	8112d16c <__reset+0xfb10d16c>
8112d3ec:	00bfffc4 	movi	r2,-1
8112d3f0:	003f0306 	br	8112d000 <__reset+0xfb10d000>
8112d3f4:	00800304 	movi	r2,12
8112d3f8:	a8800015 	stw	r2,0(r21)
8112d3fc:	8080030b 	ldhu	r2,12(r16)
8112d400:	003f5006 	br	8112d144 <__reset+0xfb10d144>

8112d404 <_fwalk>:
8112d404:	defff704 	addi	sp,sp,-36
8112d408:	de00012e 	bgeu	sp,et,8112d410 <_fwalk+0xc>
8112d40c:	003b68fa 	trap	3
8112d410:	dd000415 	stw	r20,16(sp)
8112d414:	dfc00815 	stw	ra,32(sp)
8112d418:	ddc00715 	stw	r23,28(sp)
8112d41c:	dd800615 	stw	r22,24(sp)
8112d420:	dd400515 	stw	r21,20(sp)
8112d424:	dcc00315 	stw	r19,12(sp)
8112d428:	dc800215 	stw	r18,8(sp)
8112d42c:	dc400115 	stw	r17,4(sp)
8112d430:	dc000015 	stw	r16,0(sp)
8112d434:	2500b804 	addi	r20,r4,736
8112d438:	a0002326 	beq	r20,zero,8112d4c8 <_fwalk+0xc4>
8112d43c:	282b883a 	mov	r21,r5
8112d440:	002f883a 	mov	r23,zero
8112d444:	05800044 	movi	r22,1
8112d448:	04ffffc4 	movi	r19,-1
8112d44c:	a4400117 	ldw	r17,4(r20)
8112d450:	a4800217 	ldw	r18,8(r20)
8112d454:	8c7fffc4 	addi	r17,r17,-1
8112d458:	88000d16 	blt	r17,zero,8112d490 <_fwalk+0x8c>
8112d45c:	94000304 	addi	r16,r18,12
8112d460:	94800384 	addi	r18,r18,14
8112d464:	8080000b 	ldhu	r2,0(r16)
8112d468:	8c7fffc4 	addi	r17,r17,-1
8112d46c:	813ffd04 	addi	r4,r16,-12
8112d470:	b080042e 	bgeu	r22,r2,8112d484 <_fwalk+0x80>
8112d474:	9080000f 	ldh	r2,0(r18)
8112d478:	14c00226 	beq	r2,r19,8112d484 <_fwalk+0x80>
8112d47c:	a83ee83a 	callr	r21
8112d480:	b8aeb03a 	or	r23,r23,r2
8112d484:	84001a04 	addi	r16,r16,104
8112d488:	94801a04 	addi	r18,r18,104
8112d48c:	8cfff51e 	bne	r17,r19,8112d464 <__reset+0xfb10d464>
8112d490:	a5000017 	ldw	r20,0(r20)
8112d494:	a03fed1e 	bne	r20,zero,8112d44c <__reset+0xfb10d44c>
8112d498:	b805883a 	mov	r2,r23
8112d49c:	dfc00817 	ldw	ra,32(sp)
8112d4a0:	ddc00717 	ldw	r23,28(sp)
8112d4a4:	dd800617 	ldw	r22,24(sp)
8112d4a8:	dd400517 	ldw	r21,20(sp)
8112d4ac:	dd000417 	ldw	r20,16(sp)
8112d4b0:	dcc00317 	ldw	r19,12(sp)
8112d4b4:	dc800217 	ldw	r18,8(sp)
8112d4b8:	dc400117 	ldw	r17,4(sp)
8112d4bc:	dc000017 	ldw	r16,0(sp)
8112d4c0:	dec00904 	addi	sp,sp,36
8112d4c4:	f800283a 	ret
8112d4c8:	002f883a 	mov	r23,zero
8112d4cc:	003ff206 	br	8112d498 <__reset+0xfb10d498>

8112d4d0 <_fwalk_reent>:
8112d4d0:	defff704 	addi	sp,sp,-36
8112d4d4:	de00012e 	bgeu	sp,et,8112d4dc <_fwalk_reent+0xc>
8112d4d8:	003b68fa 	trap	3
8112d4dc:	dd000415 	stw	r20,16(sp)
8112d4e0:	dfc00815 	stw	ra,32(sp)
8112d4e4:	ddc00715 	stw	r23,28(sp)
8112d4e8:	dd800615 	stw	r22,24(sp)
8112d4ec:	dd400515 	stw	r21,20(sp)
8112d4f0:	dcc00315 	stw	r19,12(sp)
8112d4f4:	dc800215 	stw	r18,8(sp)
8112d4f8:	dc400115 	stw	r17,4(sp)
8112d4fc:	dc000015 	stw	r16,0(sp)
8112d500:	2500b804 	addi	r20,r4,736
8112d504:	a0002326 	beq	r20,zero,8112d594 <_fwalk_reent+0xc4>
8112d508:	282b883a 	mov	r21,r5
8112d50c:	2027883a 	mov	r19,r4
8112d510:	002f883a 	mov	r23,zero
8112d514:	05800044 	movi	r22,1
8112d518:	04bfffc4 	movi	r18,-1
8112d51c:	a4400117 	ldw	r17,4(r20)
8112d520:	a4000217 	ldw	r16,8(r20)
8112d524:	8c7fffc4 	addi	r17,r17,-1
8112d528:	88000c16 	blt	r17,zero,8112d55c <_fwalk_reent+0x8c>
8112d52c:	84000304 	addi	r16,r16,12
8112d530:	8080000b 	ldhu	r2,0(r16)
8112d534:	8c7fffc4 	addi	r17,r17,-1
8112d538:	817ffd04 	addi	r5,r16,-12
8112d53c:	b080052e 	bgeu	r22,r2,8112d554 <_fwalk_reent+0x84>
8112d540:	8080008f 	ldh	r2,2(r16)
8112d544:	9809883a 	mov	r4,r19
8112d548:	14800226 	beq	r2,r18,8112d554 <_fwalk_reent+0x84>
8112d54c:	a83ee83a 	callr	r21
8112d550:	b8aeb03a 	or	r23,r23,r2
8112d554:	84001a04 	addi	r16,r16,104
8112d558:	8cbff51e 	bne	r17,r18,8112d530 <__reset+0xfb10d530>
8112d55c:	a5000017 	ldw	r20,0(r20)
8112d560:	a03fee1e 	bne	r20,zero,8112d51c <__reset+0xfb10d51c>
8112d564:	b805883a 	mov	r2,r23
8112d568:	dfc00817 	ldw	ra,32(sp)
8112d56c:	ddc00717 	ldw	r23,28(sp)
8112d570:	dd800617 	ldw	r22,24(sp)
8112d574:	dd400517 	ldw	r21,20(sp)
8112d578:	dd000417 	ldw	r20,16(sp)
8112d57c:	dcc00317 	ldw	r19,12(sp)
8112d580:	dc800217 	ldw	r18,8(sp)
8112d584:	dc400117 	ldw	r17,4(sp)
8112d588:	dc000017 	ldw	r16,0(sp)
8112d58c:	dec00904 	addi	sp,sp,36
8112d590:	f800283a 	ret
8112d594:	002f883a 	mov	r23,zero
8112d598:	003ff206 	br	8112d564 <__reset+0xfb10d564>

8112d59c <_isatty_r>:
8112d59c:	defffd04 	addi	sp,sp,-12
8112d5a0:	de00012e 	bgeu	sp,et,8112d5a8 <_isatty_r+0xc>
8112d5a4:	003b68fa 	trap	3
8112d5a8:	dc000015 	stw	r16,0(sp)
8112d5ac:	04204574 	movhi	r16,33045
8112d5b0:	dc400115 	stw	r17,4(sp)
8112d5b4:	84118604 	addi	r16,r16,17944
8112d5b8:	2023883a 	mov	r17,r4
8112d5bc:	2809883a 	mov	r4,r5
8112d5c0:	dfc00215 	stw	ra,8(sp)
8112d5c4:	80000015 	stw	zero,0(r16)
8112d5c8:	1137b2c0 	call	81137b2c <isatty>
8112d5cc:	00ffffc4 	movi	r3,-1
8112d5d0:	10c00526 	beq	r2,r3,8112d5e8 <_isatty_r+0x4c>
8112d5d4:	dfc00217 	ldw	ra,8(sp)
8112d5d8:	dc400117 	ldw	r17,4(sp)
8112d5dc:	dc000017 	ldw	r16,0(sp)
8112d5e0:	dec00304 	addi	sp,sp,12
8112d5e4:	f800283a 	ret
8112d5e8:	80c00017 	ldw	r3,0(r16)
8112d5ec:	183ff926 	beq	r3,zero,8112d5d4 <__reset+0xfb10d5d4>
8112d5f0:	88c00015 	stw	r3,0(r17)
8112d5f4:	003ff706 	br	8112d5d4 <__reset+0xfb10d5d4>

8112d5f8 <iswspace>:
8112d5f8:	00803fc4 	movi	r2,255
8112d5fc:	11000836 	bltu	r2,r4,8112d620 <iswspace+0x28>
8112d600:	00a04574 	movhi	r2,33045
8112d604:	10911104 	addi	r2,r2,17476
8112d608:	10800017 	ldw	r2,0(r2)
8112d60c:	1109883a 	add	r4,r2,r4
8112d610:	20800043 	ldbu	r2,1(r4)
8112d614:	1080020c 	andi	r2,r2,8
8112d618:	10803fcc 	andi	r2,r2,255
8112d61c:	f800283a 	ret
8112d620:	0005883a 	mov	r2,zero
8112d624:	f800283a 	ret

8112d628 <_setlocale_r>:
8112d628:	30001d26 	beq	r6,zero,8112d6a0 <_setlocale_r+0x78>
8112d62c:	01604574 	movhi	r5,33045
8112d630:	defffe04 	addi	sp,sp,-8
8112d634:	29476a04 	addi	r5,r5,7592
8112d638:	3009883a 	mov	r4,r6
8112d63c:	de00012e 	bgeu	sp,et,8112d644 <_setlocale_r+0x1c>
8112d640:	003b68fa 	trap	3
8112d644:	dc000015 	stw	r16,0(sp)
8112d648:	dfc00115 	stw	ra,4(sp)
8112d64c:	3021883a 	mov	r16,r6
8112d650:	112f3740 	call	8112f374 <strcmp>
8112d654:	1000061e 	bne	r2,zero,8112d670 <_setlocale_r+0x48>
8112d658:	00a04574 	movhi	r2,33045
8112d65c:	10873904 	addi	r2,r2,7396
8112d660:	dfc00117 	ldw	ra,4(sp)
8112d664:	dc000017 	ldw	r16,0(sp)
8112d668:	dec00204 	addi	sp,sp,8
8112d66c:	f800283a 	ret
8112d670:	01604574 	movhi	r5,33045
8112d674:	29473904 	addi	r5,r5,7396
8112d678:	8009883a 	mov	r4,r16
8112d67c:	112f3740 	call	8112f374 <strcmp>
8112d680:	103ff526 	beq	r2,zero,8112d658 <__reset+0xfb10d658>
8112d684:	01604574 	movhi	r5,33045
8112d688:	29474304 	addi	r5,r5,7436
8112d68c:	8009883a 	mov	r4,r16
8112d690:	112f3740 	call	8112f374 <strcmp>
8112d694:	103ff026 	beq	r2,zero,8112d658 <__reset+0xfb10d658>
8112d698:	0005883a 	mov	r2,zero
8112d69c:	003ff006 	br	8112d660 <__reset+0xfb10d660>
8112d6a0:	00a04574 	movhi	r2,33045
8112d6a4:	10873904 	addi	r2,r2,7396
8112d6a8:	f800283a 	ret

8112d6ac <__locale_charset>:
8112d6ac:	00a04574 	movhi	r2,33045
8112d6b0:	108bdb04 	addi	r2,r2,12140
8112d6b4:	f800283a 	ret

8112d6b8 <__locale_mb_cur_max>:
8112d6b8:	00a04574 	movhi	r2,33045
8112d6bc:	10911604 	addi	r2,r2,17496
8112d6c0:	10800017 	ldw	r2,0(r2)
8112d6c4:	f800283a 	ret

8112d6c8 <__locale_msgcharset>:
8112d6c8:	00a04574 	movhi	r2,33045
8112d6cc:	108bd304 	addi	r2,r2,12108
8112d6d0:	f800283a 	ret

8112d6d4 <__locale_cjk_lang>:
8112d6d4:	0005883a 	mov	r2,zero
8112d6d8:	f800283a 	ret

8112d6dc <_localeconv_r>:
8112d6dc:	00a04574 	movhi	r2,33045
8112d6e0:	108be304 	addi	r2,r2,12172
8112d6e4:	f800283a 	ret

8112d6e8 <setlocale>:
8112d6e8:	00a04574 	movhi	r2,33045
8112d6ec:	10911304 	addi	r2,r2,17484
8112d6f0:	280d883a 	mov	r6,r5
8112d6f4:	200b883a 	mov	r5,r4
8112d6f8:	11000017 	ldw	r4,0(r2)
8112d6fc:	112d6281 	jmpi	8112d628 <_setlocale_r>

8112d700 <localeconv>:
8112d700:	00a04574 	movhi	r2,33045
8112d704:	108be304 	addi	r2,r2,12172
8112d708:	f800283a 	ret

8112d70c <_lseek_r>:
8112d70c:	defffd04 	addi	sp,sp,-12
8112d710:	de00012e 	bgeu	sp,et,8112d718 <_lseek_r+0xc>
8112d714:	003b68fa 	trap	3
8112d718:	2805883a 	mov	r2,r5
8112d71c:	dc000015 	stw	r16,0(sp)
8112d720:	04204574 	movhi	r16,33045
8112d724:	dc400115 	stw	r17,4(sp)
8112d728:	300b883a 	mov	r5,r6
8112d72c:	84118604 	addi	r16,r16,17944
8112d730:	2023883a 	mov	r17,r4
8112d734:	380d883a 	mov	r6,r7
8112d738:	1009883a 	mov	r4,r2
8112d73c:	dfc00215 	stw	ra,8(sp)
8112d740:	80000015 	stw	zero,0(r16)
8112d744:	11387280 	call	81138728 <lseek>
8112d748:	00ffffc4 	movi	r3,-1
8112d74c:	10c00526 	beq	r2,r3,8112d764 <_lseek_r+0x58>
8112d750:	dfc00217 	ldw	ra,8(sp)
8112d754:	dc400117 	ldw	r17,4(sp)
8112d758:	dc000017 	ldw	r16,0(sp)
8112d75c:	dec00304 	addi	sp,sp,12
8112d760:	f800283a 	ret
8112d764:	80c00017 	ldw	r3,0(r16)
8112d768:	183ff926 	beq	r3,zero,8112d750 <__reset+0xfb10d750>
8112d76c:	88c00015 	stw	r3,0(r17)
8112d770:	003ff706 	br	8112d750 <__reset+0xfb10d750>

8112d774 <_mbrtowc_r>:
8112d774:	defff704 	addi	sp,sp,-36
8112d778:	00a04574 	movhi	r2,33045
8112d77c:	de00012e 	bgeu	sp,et,8112d784 <_mbrtowc_r+0x10>
8112d780:	003b68fa 	trap	3
8112d784:	10911704 	addi	r2,r2,17500
8112d788:	dc800715 	stw	r18,28(sp)
8112d78c:	dc400615 	stw	r17,24(sp)
8112d790:	dc000515 	stw	r16,20(sp)
8112d794:	dfc00815 	stw	ra,32(sp)
8112d798:	2021883a 	mov	r16,r4
8112d79c:	dc400917 	ldw	r17,36(sp)
8112d7a0:	14800017 	ldw	r18,0(r2)
8112d7a4:	30001626 	beq	r6,zero,8112d800 <_mbrtowc_r+0x8c>
8112d7a8:	d9400215 	stw	r5,8(sp)
8112d7ac:	d9800315 	stw	r6,12(sp)
8112d7b0:	d9c00415 	stw	r7,16(sp)
8112d7b4:	112d6ac0 	call	8112d6ac <__locale_charset>
8112d7b8:	d9c00417 	ldw	r7,16(sp)
8112d7bc:	d9800317 	ldw	r6,12(sp)
8112d7c0:	d9400217 	ldw	r5,8(sp)
8112d7c4:	d8800015 	stw	r2,0(sp)
8112d7c8:	dc400115 	stw	r17,4(sp)
8112d7cc:	8009883a 	mov	r4,r16
8112d7d0:	903ee83a 	callr	r18
8112d7d4:	00ffffc4 	movi	r3,-1
8112d7d8:	10c0031e 	bne	r2,r3,8112d7e8 <_mbrtowc_r+0x74>
8112d7dc:	88000015 	stw	zero,0(r17)
8112d7e0:	00c02284 	movi	r3,138
8112d7e4:	80c00015 	stw	r3,0(r16)
8112d7e8:	dfc00817 	ldw	ra,32(sp)
8112d7ec:	dc800717 	ldw	r18,28(sp)
8112d7f0:	dc400617 	ldw	r17,24(sp)
8112d7f4:	dc000517 	ldw	r16,20(sp)
8112d7f8:	dec00904 	addi	sp,sp,36
8112d7fc:	f800283a 	ret
8112d800:	112d6ac0 	call	8112d6ac <__locale_charset>
8112d804:	01a04574 	movhi	r6,33045
8112d808:	31874304 	addi	r6,r6,7436
8112d80c:	dc400115 	stw	r17,4(sp)
8112d810:	d8800015 	stw	r2,0(sp)
8112d814:	01c00044 	movi	r7,1
8112d818:	000b883a 	mov	r5,zero
8112d81c:	8009883a 	mov	r4,r16
8112d820:	903ee83a 	callr	r18
8112d824:	003feb06 	br	8112d7d4 <__reset+0xfb10d7d4>

8112d828 <mbrtowc>:
8112d828:	defff704 	addi	sp,sp,-36
8112d82c:	00a04574 	movhi	r2,33045
8112d830:	de00012e 	bgeu	sp,et,8112d838 <mbrtowc+0x10>
8112d834:	003b68fa 	trap	3
8112d838:	10911304 	addi	r2,r2,17484
8112d83c:	dc800415 	stw	r18,16(sp)
8112d840:	dc400315 	stw	r17,12(sp)
8112d844:	dfc00815 	stw	ra,32(sp)
8112d848:	dd400715 	stw	r21,28(sp)
8112d84c:	dd000615 	stw	r20,24(sp)
8112d850:	dcc00515 	stw	r19,20(sp)
8112d854:	dc000215 	stw	r16,8(sp)
8112d858:	3825883a 	mov	r18,r7
8112d85c:	14400017 	ldw	r17,0(r2)
8112d860:	28001c26 	beq	r5,zero,8112d8d4 <mbrtowc+0xac>
8112d864:	00a04574 	movhi	r2,33045
8112d868:	10911704 	addi	r2,r2,17500
8112d86c:	15400017 	ldw	r21,0(r2)
8112d870:	2821883a 	mov	r16,r5
8112d874:	2027883a 	mov	r19,r4
8112d878:	3029883a 	mov	r20,r6
8112d87c:	112d6ac0 	call	8112d6ac <__locale_charset>
8112d880:	d8800015 	stw	r2,0(sp)
8112d884:	dc800115 	stw	r18,4(sp)
8112d888:	a00f883a 	mov	r7,r20
8112d88c:	800d883a 	mov	r6,r16
8112d890:	980b883a 	mov	r5,r19
8112d894:	8809883a 	mov	r4,r17
8112d898:	a83ee83a 	callr	r21
8112d89c:	00ffffc4 	movi	r3,-1
8112d8a0:	10c0031e 	bne	r2,r3,8112d8b0 <mbrtowc+0x88>
8112d8a4:	90000015 	stw	zero,0(r18)
8112d8a8:	00c02284 	movi	r3,138
8112d8ac:	88c00015 	stw	r3,0(r17)
8112d8b0:	dfc00817 	ldw	ra,32(sp)
8112d8b4:	dd400717 	ldw	r21,28(sp)
8112d8b8:	dd000617 	ldw	r20,24(sp)
8112d8bc:	dcc00517 	ldw	r19,20(sp)
8112d8c0:	dc800417 	ldw	r18,16(sp)
8112d8c4:	dc400317 	ldw	r17,12(sp)
8112d8c8:	dc000217 	ldw	r16,8(sp)
8112d8cc:	dec00904 	addi	sp,sp,36
8112d8d0:	f800283a 	ret
8112d8d4:	00a04574 	movhi	r2,33045
8112d8d8:	10911704 	addi	r2,r2,17500
8112d8dc:	14000017 	ldw	r16,0(r2)
8112d8e0:	112d6ac0 	call	8112d6ac <__locale_charset>
8112d8e4:	01a04574 	movhi	r6,33045
8112d8e8:	31874304 	addi	r6,r6,7436
8112d8ec:	dc800115 	stw	r18,4(sp)
8112d8f0:	d8800015 	stw	r2,0(sp)
8112d8f4:	01c00044 	movi	r7,1
8112d8f8:	000b883a 	mov	r5,zero
8112d8fc:	8809883a 	mov	r4,r17
8112d900:	803ee83a 	callr	r16
8112d904:	003fe506 	br	8112d89c <__reset+0xfb10d89c>

8112d908 <__ascii_mbtowc>:
8112d908:	deffff04 	addi	sp,sp,-4
8112d90c:	de00012e 	bgeu	sp,et,8112d914 <__ascii_mbtowc+0xc>
8112d910:	003b68fa 	trap	3
8112d914:	28000826 	beq	r5,zero,8112d938 <__ascii_mbtowc+0x30>
8112d918:	30000926 	beq	r6,zero,8112d940 <__ascii_mbtowc+0x38>
8112d91c:	38000b26 	beq	r7,zero,8112d94c <__ascii_mbtowc+0x44>
8112d920:	30800003 	ldbu	r2,0(r6)
8112d924:	28800015 	stw	r2,0(r5)
8112d928:	30800003 	ldbu	r2,0(r6)
8112d92c:	1004c03a 	cmpne	r2,r2,zero
8112d930:	dec00104 	addi	sp,sp,4
8112d934:	f800283a 	ret
8112d938:	d80b883a 	mov	r5,sp
8112d93c:	303ff71e 	bne	r6,zero,8112d91c <__reset+0xfb10d91c>
8112d940:	0005883a 	mov	r2,zero
8112d944:	dec00104 	addi	sp,sp,4
8112d948:	f800283a 	ret
8112d94c:	00bfff84 	movi	r2,-2
8112d950:	003ff706 	br	8112d930 <__reset+0xfb10d930>

8112d954 <_mbtowc_r>:
8112d954:	00a04574 	movhi	r2,33045
8112d958:	defff804 	addi	sp,sp,-32
8112d95c:	10911704 	addi	r2,r2,17500
8112d960:	de00012e 	bgeu	sp,et,8112d968 <_mbtowc_r+0x14>
8112d964:	003b68fa 	trap	3
8112d968:	dfc00715 	stw	ra,28(sp)
8112d96c:	dc000615 	stw	r16,24(sp)
8112d970:	14000017 	ldw	r16,0(r2)
8112d974:	d9000215 	stw	r4,8(sp)
8112d978:	d9400315 	stw	r5,12(sp)
8112d97c:	d9800415 	stw	r6,16(sp)
8112d980:	d9c00515 	stw	r7,20(sp)
8112d984:	112d6ac0 	call	8112d6ac <__locale_charset>
8112d988:	d8800015 	stw	r2,0(sp)
8112d98c:	d8800817 	ldw	r2,32(sp)
8112d990:	d9c00517 	ldw	r7,20(sp)
8112d994:	d9800417 	ldw	r6,16(sp)
8112d998:	d9400317 	ldw	r5,12(sp)
8112d99c:	d9000217 	ldw	r4,8(sp)
8112d9a0:	d8800115 	stw	r2,4(sp)
8112d9a4:	803ee83a 	callr	r16
8112d9a8:	dfc00717 	ldw	ra,28(sp)
8112d9ac:	dc000617 	ldw	r16,24(sp)
8112d9b0:	dec00804 	addi	sp,sp,32
8112d9b4:	f800283a 	ret

8112d9b8 <memchr>:
8112d9b8:	208000cc 	andi	r2,r4,3
8112d9bc:	280f883a 	mov	r7,r5
8112d9c0:	10003426 	beq	r2,zero,8112da94 <memchr+0xdc>
8112d9c4:	30bfffc4 	addi	r2,r6,-1
8112d9c8:	30001a26 	beq	r6,zero,8112da34 <memchr+0x7c>
8112d9cc:	20c00003 	ldbu	r3,0(r4)
8112d9d0:	29803fcc 	andi	r6,r5,255
8112d9d4:	30c0051e 	bne	r6,r3,8112d9ec <memchr+0x34>
8112d9d8:	00001806 	br	8112da3c <memchr+0x84>
8112d9dc:	10001526 	beq	r2,zero,8112da34 <memchr+0x7c>
8112d9e0:	20c00003 	ldbu	r3,0(r4)
8112d9e4:	10bfffc4 	addi	r2,r2,-1
8112d9e8:	30c01426 	beq	r6,r3,8112da3c <memchr+0x84>
8112d9ec:	21000044 	addi	r4,r4,1
8112d9f0:	20c000cc 	andi	r3,r4,3
8112d9f4:	183ff91e 	bne	r3,zero,8112d9dc <__reset+0xfb10d9dc>
8112d9f8:	020000c4 	movi	r8,3
8112d9fc:	40801136 	bltu	r8,r2,8112da44 <memchr+0x8c>
8112da00:	10000c26 	beq	r2,zero,8112da34 <memchr+0x7c>
8112da04:	20c00003 	ldbu	r3,0(r4)
8112da08:	29403fcc 	andi	r5,r5,255
8112da0c:	28c00b26 	beq	r5,r3,8112da3c <memchr+0x84>
8112da10:	20c00044 	addi	r3,r4,1
8112da14:	39803fcc 	andi	r6,r7,255
8112da18:	2089883a 	add	r4,r4,r2
8112da1c:	00000306 	br	8112da2c <memchr+0x74>
8112da20:	18c00044 	addi	r3,r3,1
8112da24:	197fffc3 	ldbu	r5,-1(r3)
8112da28:	31400526 	beq	r6,r5,8112da40 <memchr+0x88>
8112da2c:	1805883a 	mov	r2,r3
8112da30:	20fffb1e 	bne	r4,r3,8112da20 <__reset+0xfb10da20>
8112da34:	0005883a 	mov	r2,zero
8112da38:	f800283a 	ret
8112da3c:	2005883a 	mov	r2,r4
8112da40:	f800283a 	ret
8112da44:	28c03fcc 	andi	r3,r5,255
8112da48:	1812923a 	slli	r9,r3,8
8112da4c:	02ffbff4 	movhi	r11,65279
8112da50:	02a02074 	movhi	r10,32897
8112da54:	48d2b03a 	or	r9,r9,r3
8112da58:	4806943a 	slli	r3,r9,16
8112da5c:	5affbfc4 	addi	r11,r11,-257
8112da60:	52a02004 	addi	r10,r10,-32640
8112da64:	48d2b03a 	or	r9,r9,r3
8112da68:	20c00017 	ldw	r3,0(r4)
8112da6c:	48c6f03a 	xor	r3,r9,r3
8112da70:	1acd883a 	add	r6,r3,r11
8112da74:	00c6303a 	nor	r3,zero,r3
8112da78:	30c6703a 	and	r3,r6,r3
8112da7c:	1a86703a 	and	r3,r3,r10
8112da80:	183fe01e 	bne	r3,zero,8112da04 <__reset+0xfb10da04>
8112da84:	10bfff04 	addi	r2,r2,-4
8112da88:	21000104 	addi	r4,r4,4
8112da8c:	40bff636 	bltu	r8,r2,8112da68 <__reset+0xfb10da68>
8112da90:	003fdb06 	br	8112da00 <__reset+0xfb10da00>
8112da94:	3005883a 	mov	r2,r6
8112da98:	003fd706 	br	8112d9f8 <__reset+0xfb10d9f8>

8112da9c <memmove>:
8112da9c:	2005883a 	mov	r2,r4
8112daa0:	29000b2e 	bgeu	r5,r4,8112dad0 <memmove+0x34>
8112daa4:	298f883a 	add	r7,r5,r6
8112daa8:	21c0092e 	bgeu	r4,r7,8112dad0 <memmove+0x34>
8112daac:	2187883a 	add	r3,r4,r6
8112dab0:	198bc83a 	sub	r5,r3,r6
8112dab4:	30004826 	beq	r6,zero,8112dbd8 <memmove+0x13c>
8112dab8:	39ffffc4 	addi	r7,r7,-1
8112dabc:	39000003 	ldbu	r4,0(r7)
8112dac0:	18ffffc4 	addi	r3,r3,-1
8112dac4:	19000005 	stb	r4,0(r3)
8112dac8:	28fffb1e 	bne	r5,r3,8112dab8 <__reset+0xfb10dab8>
8112dacc:	f800283a 	ret
8112dad0:	00c003c4 	movi	r3,15
8112dad4:	1980412e 	bgeu	r3,r6,8112dbdc <memmove+0x140>
8112dad8:	2886b03a 	or	r3,r5,r2
8112dadc:	18c000cc 	andi	r3,r3,3
8112dae0:	1800401e 	bne	r3,zero,8112dbe4 <memmove+0x148>
8112dae4:	33fffc04 	addi	r15,r6,-16
8112dae8:	781ed13a 	srli	r15,r15,4
8112daec:	28c00104 	addi	r3,r5,4
8112daf0:	13400104 	addi	r13,r2,4
8112daf4:	781c913a 	slli	r14,r15,4
8112daf8:	2b000204 	addi	r12,r5,8
8112dafc:	12c00204 	addi	r11,r2,8
8112db00:	73800504 	addi	r14,r14,20
8112db04:	2a800304 	addi	r10,r5,12
8112db08:	12400304 	addi	r9,r2,12
8112db0c:	2b9d883a 	add	r14,r5,r14
8112db10:	2811883a 	mov	r8,r5
8112db14:	100f883a 	mov	r7,r2
8112db18:	41000017 	ldw	r4,0(r8)
8112db1c:	39c00404 	addi	r7,r7,16
8112db20:	18c00404 	addi	r3,r3,16
8112db24:	393ffc15 	stw	r4,-16(r7)
8112db28:	193ffc17 	ldw	r4,-16(r3)
8112db2c:	6b400404 	addi	r13,r13,16
8112db30:	5ac00404 	addi	r11,r11,16
8112db34:	693ffc15 	stw	r4,-16(r13)
8112db38:	61000017 	ldw	r4,0(r12)
8112db3c:	4a400404 	addi	r9,r9,16
8112db40:	42000404 	addi	r8,r8,16
8112db44:	593ffc15 	stw	r4,-16(r11)
8112db48:	51000017 	ldw	r4,0(r10)
8112db4c:	63000404 	addi	r12,r12,16
8112db50:	52800404 	addi	r10,r10,16
8112db54:	493ffc15 	stw	r4,-16(r9)
8112db58:	1bbfef1e 	bne	r3,r14,8112db18 <__reset+0xfb10db18>
8112db5c:	79000044 	addi	r4,r15,1
8112db60:	2008913a 	slli	r4,r4,4
8112db64:	328003cc 	andi	r10,r6,15
8112db68:	02c000c4 	movi	r11,3
8112db6c:	1107883a 	add	r3,r2,r4
8112db70:	290b883a 	add	r5,r5,r4
8112db74:	5a801e2e 	bgeu	r11,r10,8112dbf0 <memmove+0x154>
8112db78:	1813883a 	mov	r9,r3
8112db7c:	2811883a 	mov	r8,r5
8112db80:	500f883a 	mov	r7,r10
8112db84:	41000017 	ldw	r4,0(r8)
8112db88:	4a400104 	addi	r9,r9,4
8112db8c:	39ffff04 	addi	r7,r7,-4
8112db90:	493fff15 	stw	r4,-4(r9)
8112db94:	42000104 	addi	r8,r8,4
8112db98:	59fffa36 	bltu	r11,r7,8112db84 <__reset+0xfb10db84>
8112db9c:	513fff04 	addi	r4,r10,-4
8112dba0:	2008d0ba 	srli	r4,r4,2
8112dba4:	318000cc 	andi	r6,r6,3
8112dba8:	21000044 	addi	r4,r4,1
8112dbac:	2109883a 	add	r4,r4,r4
8112dbb0:	2109883a 	add	r4,r4,r4
8112dbb4:	1907883a 	add	r3,r3,r4
8112dbb8:	290b883a 	add	r5,r5,r4
8112dbbc:	30000b26 	beq	r6,zero,8112dbec <memmove+0x150>
8112dbc0:	198d883a 	add	r6,r3,r6
8112dbc4:	29c00003 	ldbu	r7,0(r5)
8112dbc8:	18c00044 	addi	r3,r3,1
8112dbcc:	29400044 	addi	r5,r5,1
8112dbd0:	19ffffc5 	stb	r7,-1(r3)
8112dbd4:	19bffb1e 	bne	r3,r6,8112dbc4 <__reset+0xfb10dbc4>
8112dbd8:	f800283a 	ret
8112dbdc:	1007883a 	mov	r3,r2
8112dbe0:	003ff606 	br	8112dbbc <__reset+0xfb10dbbc>
8112dbe4:	1007883a 	mov	r3,r2
8112dbe8:	003ff506 	br	8112dbc0 <__reset+0xfb10dbc0>
8112dbec:	f800283a 	ret
8112dbf0:	500d883a 	mov	r6,r10
8112dbf4:	003ff106 	br	8112dbbc <__reset+0xfb10dbbc>

8112dbf8 <_Balloc>:
8112dbf8:	defffc04 	addi	sp,sp,-16
8112dbfc:	de00012e 	bgeu	sp,et,8112dc04 <_Balloc+0xc>
8112dc00:	003b68fa 	trap	3
8112dc04:	20801317 	ldw	r2,76(r4)
8112dc08:	dc400115 	stw	r17,4(sp)
8112dc0c:	dc000015 	stw	r16,0(sp)
8112dc10:	dfc00315 	stw	ra,12(sp)
8112dc14:	dc800215 	stw	r18,8(sp)
8112dc18:	2023883a 	mov	r17,r4
8112dc1c:	2821883a 	mov	r16,r5
8112dc20:	10000f26 	beq	r2,zero,8112dc60 <_Balloc+0x68>
8112dc24:	8407883a 	add	r3,r16,r16
8112dc28:	18c7883a 	add	r3,r3,r3
8112dc2c:	10c7883a 	add	r3,r2,r3
8112dc30:	18800017 	ldw	r2,0(r3)
8112dc34:	10001126 	beq	r2,zero,8112dc7c <_Balloc+0x84>
8112dc38:	11000017 	ldw	r4,0(r2)
8112dc3c:	19000015 	stw	r4,0(r3)
8112dc40:	10000415 	stw	zero,16(r2)
8112dc44:	10000315 	stw	zero,12(r2)
8112dc48:	dfc00317 	ldw	ra,12(sp)
8112dc4c:	dc800217 	ldw	r18,8(sp)
8112dc50:	dc400117 	ldw	r17,4(sp)
8112dc54:	dc000017 	ldw	r16,0(sp)
8112dc58:	dec00404 	addi	sp,sp,16
8112dc5c:	f800283a 	ret
8112dc60:	01800844 	movi	r6,33
8112dc64:	01400104 	movi	r5,4
8112dc68:	11341200 	call	81134120 <_calloc_r>
8112dc6c:	88801315 	stw	r2,76(r17)
8112dc70:	103fec1e 	bne	r2,zero,8112dc24 <__reset+0xfb10dc24>
8112dc74:	0005883a 	mov	r2,zero
8112dc78:	003ff306 	br	8112dc48 <__reset+0xfb10dc48>
8112dc7c:	01400044 	movi	r5,1
8112dc80:	2c24983a 	sll	r18,r5,r16
8112dc84:	8809883a 	mov	r4,r17
8112dc88:	91800144 	addi	r6,r18,5
8112dc8c:	318d883a 	add	r6,r6,r6
8112dc90:	318d883a 	add	r6,r6,r6
8112dc94:	11341200 	call	81134120 <_calloc_r>
8112dc98:	103ff626 	beq	r2,zero,8112dc74 <__reset+0xfb10dc74>
8112dc9c:	14000115 	stw	r16,4(r2)
8112dca0:	14800215 	stw	r18,8(r2)
8112dca4:	003fe606 	br	8112dc40 <__reset+0xfb10dc40>

8112dca8 <_Bfree>:
8112dca8:	28000826 	beq	r5,zero,8112dccc <_Bfree+0x24>
8112dcac:	28c00117 	ldw	r3,4(r5)
8112dcb0:	20801317 	ldw	r2,76(r4)
8112dcb4:	18c7883a 	add	r3,r3,r3
8112dcb8:	18c7883a 	add	r3,r3,r3
8112dcbc:	10c5883a 	add	r2,r2,r3
8112dcc0:	10c00017 	ldw	r3,0(r2)
8112dcc4:	28c00015 	stw	r3,0(r5)
8112dcc8:	11400015 	stw	r5,0(r2)
8112dccc:	f800283a 	ret

8112dcd0 <__multadd>:
8112dcd0:	defffa04 	addi	sp,sp,-24
8112dcd4:	de00012e 	bgeu	sp,et,8112dcdc <__multadd+0xc>
8112dcd8:	003b68fa 	trap	3
8112dcdc:	0011883a 	mov	r8,zero
8112dce0:	dc800315 	stw	r18,12(sp)
8112dce4:	dc400215 	stw	r17,8(sp)
8112dce8:	dc000115 	stw	r16,4(sp)
8112dcec:	2823883a 	mov	r17,r5
8112dcf0:	2c000417 	ldw	r16,16(r5)
8112dcf4:	dfc00515 	stw	ra,20(sp)
8112dcf8:	dcc00415 	stw	r19,16(sp)
8112dcfc:	2025883a 	mov	r18,r4
8112dd00:	29400504 	addi	r5,r5,20
8112dd04:	28c00017 	ldw	r3,0(r5)
8112dd08:	29400104 	addi	r5,r5,4
8112dd0c:	42000044 	addi	r8,r8,1
8112dd10:	18bfffcc 	andi	r2,r3,65535
8112dd14:	1185383a 	mul	r2,r2,r6
8112dd18:	1806d43a 	srli	r3,r3,16
8112dd1c:	11cf883a 	add	r7,r2,r7
8112dd20:	3808d43a 	srli	r4,r7,16
8112dd24:	1987383a 	mul	r3,r3,r6
8112dd28:	38bfffcc 	andi	r2,r7,65535
8112dd2c:	1907883a 	add	r3,r3,r4
8112dd30:	1808943a 	slli	r4,r3,16
8112dd34:	180ed43a 	srli	r7,r3,16
8112dd38:	2085883a 	add	r2,r4,r2
8112dd3c:	28bfff15 	stw	r2,-4(r5)
8112dd40:	443ff016 	blt	r8,r16,8112dd04 <__reset+0xfb10dd04>
8112dd44:	38000926 	beq	r7,zero,8112dd6c <__multadd+0x9c>
8112dd48:	88800217 	ldw	r2,8(r17)
8112dd4c:	80800f0e 	bge	r16,r2,8112dd8c <__multadd+0xbc>
8112dd50:	80800144 	addi	r2,r16,5
8112dd54:	1085883a 	add	r2,r2,r2
8112dd58:	1085883a 	add	r2,r2,r2
8112dd5c:	8885883a 	add	r2,r17,r2
8112dd60:	11c00015 	stw	r7,0(r2)
8112dd64:	84000044 	addi	r16,r16,1
8112dd68:	8c000415 	stw	r16,16(r17)
8112dd6c:	8805883a 	mov	r2,r17
8112dd70:	dfc00517 	ldw	ra,20(sp)
8112dd74:	dcc00417 	ldw	r19,16(sp)
8112dd78:	dc800317 	ldw	r18,12(sp)
8112dd7c:	dc400217 	ldw	r17,8(sp)
8112dd80:	dc000117 	ldw	r16,4(sp)
8112dd84:	dec00604 	addi	sp,sp,24
8112dd88:	f800283a 	ret
8112dd8c:	89400117 	ldw	r5,4(r17)
8112dd90:	9009883a 	mov	r4,r18
8112dd94:	d9c00015 	stw	r7,0(sp)
8112dd98:	29400044 	addi	r5,r5,1
8112dd9c:	112dbf80 	call	8112dbf8 <_Balloc>
8112dda0:	89800417 	ldw	r6,16(r17)
8112dda4:	89400304 	addi	r5,r17,12
8112dda8:	11000304 	addi	r4,r2,12
8112ddac:	31800084 	addi	r6,r6,2
8112ddb0:	318d883a 	add	r6,r6,r6
8112ddb4:	318d883a 	add	r6,r6,r6
8112ddb8:	1027883a 	mov	r19,r2
8112ddbc:	1123a440 	call	81123a44 <memcpy>
8112ddc0:	d9c00017 	ldw	r7,0(sp)
8112ddc4:	88000a26 	beq	r17,zero,8112ddf0 <__multadd+0x120>
8112ddc8:	88c00117 	ldw	r3,4(r17)
8112ddcc:	90801317 	ldw	r2,76(r18)
8112ddd0:	18c7883a 	add	r3,r3,r3
8112ddd4:	18c7883a 	add	r3,r3,r3
8112ddd8:	10c5883a 	add	r2,r2,r3
8112dddc:	10c00017 	ldw	r3,0(r2)
8112dde0:	88c00015 	stw	r3,0(r17)
8112dde4:	14400015 	stw	r17,0(r2)
8112dde8:	9823883a 	mov	r17,r19
8112ddec:	003fd806 	br	8112dd50 <__reset+0xfb10dd50>
8112ddf0:	9823883a 	mov	r17,r19
8112ddf4:	003fd606 	br	8112dd50 <__reset+0xfb10dd50>

8112ddf8 <__s2b>:
8112ddf8:	defff904 	addi	sp,sp,-28
8112ddfc:	de00012e 	bgeu	sp,et,8112de04 <__s2b+0xc>
8112de00:	003b68fa 	trap	3
8112de04:	dc400115 	stw	r17,4(sp)
8112de08:	dc000015 	stw	r16,0(sp)
8112de0c:	2023883a 	mov	r17,r4
8112de10:	2821883a 	mov	r16,r5
8112de14:	39000204 	addi	r4,r7,8
8112de18:	01400244 	movi	r5,9
8112de1c:	dcc00315 	stw	r19,12(sp)
8112de20:	dc800215 	stw	r18,8(sp)
8112de24:	dfc00615 	stw	ra,24(sp)
8112de28:	dd400515 	stw	r21,20(sp)
8112de2c:	dd000415 	stw	r20,16(sp)
8112de30:	3825883a 	mov	r18,r7
8112de34:	3027883a 	mov	r19,r6
8112de38:	1135e3c0 	call	81135e3c <__divsi3>
8112de3c:	00c00044 	movi	r3,1
8112de40:	000b883a 	mov	r5,zero
8112de44:	1880030e 	bge	r3,r2,8112de54 <__s2b+0x5c>
8112de48:	18c7883a 	add	r3,r3,r3
8112de4c:	29400044 	addi	r5,r5,1
8112de50:	18bffd16 	blt	r3,r2,8112de48 <__reset+0xfb10de48>
8112de54:	8809883a 	mov	r4,r17
8112de58:	112dbf80 	call	8112dbf8 <_Balloc>
8112de5c:	d8c00717 	ldw	r3,28(sp)
8112de60:	10c00515 	stw	r3,20(r2)
8112de64:	00c00044 	movi	r3,1
8112de68:	10c00415 	stw	r3,16(r2)
8112de6c:	00c00244 	movi	r3,9
8112de70:	1cc0210e 	bge	r3,r19,8112def8 <__s2b+0x100>
8112de74:	80eb883a 	add	r21,r16,r3
8112de78:	a829883a 	mov	r20,r21
8112de7c:	84e1883a 	add	r16,r16,r19
8112de80:	a1c00007 	ldb	r7,0(r20)
8112de84:	01800284 	movi	r6,10
8112de88:	a5000044 	addi	r20,r20,1
8112de8c:	100b883a 	mov	r5,r2
8112de90:	39fff404 	addi	r7,r7,-48
8112de94:	8809883a 	mov	r4,r17
8112de98:	112dcd00 	call	8112dcd0 <__multadd>
8112de9c:	a43ff81e 	bne	r20,r16,8112de80 <__reset+0xfb10de80>
8112dea0:	ace1883a 	add	r16,r21,r19
8112dea4:	843ffe04 	addi	r16,r16,-8
8112dea8:	9c800a0e 	bge	r19,r18,8112ded4 <__s2b+0xdc>
8112deac:	94e5c83a 	sub	r18,r18,r19
8112deb0:	84a5883a 	add	r18,r16,r18
8112deb4:	81c00007 	ldb	r7,0(r16)
8112deb8:	01800284 	movi	r6,10
8112debc:	84000044 	addi	r16,r16,1
8112dec0:	100b883a 	mov	r5,r2
8112dec4:	39fff404 	addi	r7,r7,-48
8112dec8:	8809883a 	mov	r4,r17
8112decc:	112dcd00 	call	8112dcd0 <__multadd>
8112ded0:	84bff81e 	bne	r16,r18,8112deb4 <__reset+0xfb10deb4>
8112ded4:	dfc00617 	ldw	ra,24(sp)
8112ded8:	dd400517 	ldw	r21,20(sp)
8112dedc:	dd000417 	ldw	r20,16(sp)
8112dee0:	dcc00317 	ldw	r19,12(sp)
8112dee4:	dc800217 	ldw	r18,8(sp)
8112dee8:	dc400117 	ldw	r17,4(sp)
8112deec:	dc000017 	ldw	r16,0(sp)
8112def0:	dec00704 	addi	sp,sp,28
8112def4:	f800283a 	ret
8112def8:	84000284 	addi	r16,r16,10
8112defc:	1827883a 	mov	r19,r3
8112df00:	003fe906 	br	8112dea8 <__reset+0xfb10dea8>

8112df04 <__hi0bits>:
8112df04:	20bfffec 	andhi	r2,r4,65535
8112df08:	1000141e 	bne	r2,zero,8112df5c <__hi0bits+0x58>
8112df0c:	2008943a 	slli	r4,r4,16
8112df10:	00800404 	movi	r2,16
8112df14:	20ffc02c 	andhi	r3,r4,65280
8112df18:	1800021e 	bne	r3,zero,8112df24 <__hi0bits+0x20>
8112df1c:	2008923a 	slli	r4,r4,8
8112df20:	10800204 	addi	r2,r2,8
8112df24:	20fc002c 	andhi	r3,r4,61440
8112df28:	1800021e 	bne	r3,zero,8112df34 <__hi0bits+0x30>
8112df2c:	2008913a 	slli	r4,r4,4
8112df30:	10800104 	addi	r2,r2,4
8112df34:	20f0002c 	andhi	r3,r4,49152
8112df38:	1800031e 	bne	r3,zero,8112df48 <__hi0bits+0x44>
8112df3c:	2109883a 	add	r4,r4,r4
8112df40:	10800084 	addi	r2,r2,2
8112df44:	2109883a 	add	r4,r4,r4
8112df48:	20000316 	blt	r4,zero,8112df58 <__hi0bits+0x54>
8112df4c:	2110002c 	andhi	r4,r4,16384
8112df50:	2000041e 	bne	r4,zero,8112df64 <__hi0bits+0x60>
8112df54:	00800804 	movi	r2,32
8112df58:	f800283a 	ret
8112df5c:	0005883a 	mov	r2,zero
8112df60:	003fec06 	br	8112df14 <__reset+0xfb10df14>
8112df64:	10800044 	addi	r2,r2,1
8112df68:	f800283a 	ret

8112df6c <__lo0bits>:
8112df6c:	20c00017 	ldw	r3,0(r4)
8112df70:	188001cc 	andi	r2,r3,7
8112df74:	10000826 	beq	r2,zero,8112df98 <__lo0bits+0x2c>
8112df78:	1880004c 	andi	r2,r3,1
8112df7c:	1000211e 	bne	r2,zero,8112e004 <__lo0bits+0x98>
8112df80:	1880008c 	andi	r2,r3,2
8112df84:	1000211e 	bne	r2,zero,8112e00c <__lo0bits+0xa0>
8112df88:	1806d0ba 	srli	r3,r3,2
8112df8c:	00800084 	movi	r2,2
8112df90:	20c00015 	stw	r3,0(r4)
8112df94:	f800283a 	ret
8112df98:	18bfffcc 	andi	r2,r3,65535
8112df9c:	10001326 	beq	r2,zero,8112dfec <__lo0bits+0x80>
8112dfa0:	0005883a 	mov	r2,zero
8112dfa4:	19403fcc 	andi	r5,r3,255
8112dfa8:	2800021e 	bne	r5,zero,8112dfb4 <__lo0bits+0x48>
8112dfac:	1806d23a 	srli	r3,r3,8
8112dfb0:	10800204 	addi	r2,r2,8
8112dfb4:	194003cc 	andi	r5,r3,15
8112dfb8:	2800021e 	bne	r5,zero,8112dfc4 <__lo0bits+0x58>
8112dfbc:	1806d13a 	srli	r3,r3,4
8112dfc0:	10800104 	addi	r2,r2,4
8112dfc4:	194000cc 	andi	r5,r3,3
8112dfc8:	2800021e 	bne	r5,zero,8112dfd4 <__lo0bits+0x68>
8112dfcc:	1806d0ba 	srli	r3,r3,2
8112dfd0:	10800084 	addi	r2,r2,2
8112dfd4:	1940004c 	andi	r5,r3,1
8112dfd8:	2800081e 	bne	r5,zero,8112dffc <__lo0bits+0x90>
8112dfdc:	1806d07a 	srli	r3,r3,1
8112dfe0:	1800051e 	bne	r3,zero,8112dff8 <__lo0bits+0x8c>
8112dfe4:	00800804 	movi	r2,32
8112dfe8:	f800283a 	ret
8112dfec:	1806d43a 	srli	r3,r3,16
8112dff0:	00800404 	movi	r2,16
8112dff4:	003feb06 	br	8112dfa4 <__reset+0xfb10dfa4>
8112dff8:	10800044 	addi	r2,r2,1
8112dffc:	20c00015 	stw	r3,0(r4)
8112e000:	f800283a 	ret
8112e004:	0005883a 	mov	r2,zero
8112e008:	f800283a 	ret
8112e00c:	1806d07a 	srli	r3,r3,1
8112e010:	00800044 	movi	r2,1
8112e014:	20c00015 	stw	r3,0(r4)
8112e018:	f800283a 	ret

8112e01c <__i2b>:
8112e01c:	defffd04 	addi	sp,sp,-12
8112e020:	de00012e 	bgeu	sp,et,8112e028 <__i2b+0xc>
8112e024:	003b68fa 	trap	3
8112e028:	dc000015 	stw	r16,0(sp)
8112e02c:	04000044 	movi	r16,1
8112e030:	dc400115 	stw	r17,4(sp)
8112e034:	2823883a 	mov	r17,r5
8112e038:	800b883a 	mov	r5,r16
8112e03c:	dfc00215 	stw	ra,8(sp)
8112e040:	112dbf80 	call	8112dbf8 <_Balloc>
8112e044:	14400515 	stw	r17,20(r2)
8112e048:	14000415 	stw	r16,16(r2)
8112e04c:	dfc00217 	ldw	ra,8(sp)
8112e050:	dc400117 	ldw	r17,4(sp)
8112e054:	dc000017 	ldw	r16,0(sp)
8112e058:	dec00304 	addi	sp,sp,12
8112e05c:	f800283a 	ret

8112e060 <__multiply>:
8112e060:	defffa04 	addi	sp,sp,-24
8112e064:	de00012e 	bgeu	sp,et,8112e06c <__multiply+0xc>
8112e068:	003b68fa 	trap	3
8112e06c:	dcc00315 	stw	r19,12(sp)
8112e070:	dc800215 	stw	r18,8(sp)
8112e074:	34c00417 	ldw	r19,16(r6)
8112e078:	2c800417 	ldw	r18,16(r5)
8112e07c:	dd000415 	stw	r20,16(sp)
8112e080:	dc400115 	stw	r17,4(sp)
8112e084:	dfc00515 	stw	ra,20(sp)
8112e088:	dc000015 	stw	r16,0(sp)
8112e08c:	2829883a 	mov	r20,r5
8112e090:	3023883a 	mov	r17,r6
8112e094:	94c0050e 	bge	r18,r19,8112e0ac <__multiply+0x4c>
8112e098:	9007883a 	mov	r3,r18
8112e09c:	3029883a 	mov	r20,r6
8112e0a0:	9825883a 	mov	r18,r19
8112e0a4:	2823883a 	mov	r17,r5
8112e0a8:	1827883a 	mov	r19,r3
8112e0ac:	a0800217 	ldw	r2,8(r20)
8112e0b0:	94e1883a 	add	r16,r18,r19
8112e0b4:	a1400117 	ldw	r5,4(r20)
8112e0b8:	1400010e 	bge	r2,r16,8112e0c0 <__multiply+0x60>
8112e0bc:	29400044 	addi	r5,r5,1
8112e0c0:	112dbf80 	call	8112dbf8 <_Balloc>
8112e0c4:	8415883a 	add	r10,r16,r16
8112e0c8:	12c00504 	addi	r11,r2,20
8112e0cc:	5295883a 	add	r10,r10,r10
8112e0d0:	5a95883a 	add	r10,r11,r10
8112e0d4:	5807883a 	mov	r3,r11
8112e0d8:	5a80032e 	bgeu	r11,r10,8112e0e8 <__multiply+0x88>
8112e0dc:	18000015 	stw	zero,0(r3)
8112e0e0:	18c00104 	addi	r3,r3,4
8112e0e4:	1abffd36 	bltu	r3,r10,8112e0dc <__reset+0xfb10e0dc>
8112e0e8:	9ce7883a 	add	r19,r19,r19
8112e0ec:	94a5883a 	add	r18,r18,r18
8112e0f0:	89800504 	addi	r6,r17,20
8112e0f4:	9ce7883a 	add	r19,r19,r19
8112e0f8:	a3400504 	addi	r13,r20,20
8112e0fc:	94a5883a 	add	r18,r18,r18
8112e100:	34d9883a 	add	r12,r6,r19
8112e104:	6c93883a 	add	r9,r13,r18
8112e108:	3300422e 	bgeu	r6,r12,8112e214 <__multiply+0x1b4>
8112e10c:	37c00017 	ldw	ra,0(r6)
8112e110:	fbffffcc 	andi	r15,ra,65535
8112e114:	78001b26 	beq	r15,zero,8112e184 <__multiply+0x124>
8112e118:	5811883a 	mov	r8,r11
8112e11c:	681d883a 	mov	r14,r13
8112e120:	000f883a 	mov	r7,zero
8112e124:	71000017 	ldw	r4,0(r14)
8112e128:	40c00017 	ldw	r3,0(r8)
8112e12c:	73800104 	addi	r14,r14,4
8112e130:	217fffcc 	andi	r5,r4,65535
8112e134:	2bcb383a 	mul	r5,r5,r15
8112e138:	2008d43a 	srli	r4,r4,16
8112e13c:	1c7fffcc 	andi	r17,r3,65535
8112e140:	2c4b883a 	add	r5,r5,r17
8112e144:	29cb883a 	add	r5,r5,r7
8112e148:	23c9383a 	mul	r4,r4,r15
8112e14c:	1806d43a 	srli	r3,r3,16
8112e150:	280ed43a 	srli	r7,r5,16
8112e154:	297fffcc 	andi	r5,r5,65535
8112e158:	20c7883a 	add	r3,r4,r3
8112e15c:	19c7883a 	add	r3,r3,r7
8112e160:	1808943a 	slli	r4,r3,16
8112e164:	4023883a 	mov	r17,r8
8112e168:	180ed43a 	srli	r7,r3,16
8112e16c:	214ab03a 	or	r5,r4,r5
8112e170:	41400015 	stw	r5,0(r8)
8112e174:	42000104 	addi	r8,r8,4
8112e178:	727fea36 	bltu	r14,r9,8112e124 <__reset+0xfb10e124>
8112e17c:	89c00115 	stw	r7,4(r17)
8112e180:	37c00017 	ldw	ra,0(r6)
8112e184:	f83ed43a 	srli	ra,ra,16
8112e188:	f8001f26 	beq	ra,zero,8112e208 <__multiply+0x1a8>
8112e18c:	58c00017 	ldw	r3,0(r11)
8112e190:	681d883a 	mov	r14,r13
8112e194:	581f883a 	mov	r15,r11
8112e198:	1811883a 	mov	r8,r3
8112e19c:	5825883a 	mov	r18,r11
8112e1a0:	000f883a 	mov	r7,zero
8112e1a4:	00000106 	br	8112e1ac <__multiply+0x14c>
8112e1a8:	8825883a 	mov	r18,r17
8112e1ac:	7140000b 	ldhu	r5,0(r14)
8112e1b0:	4010d43a 	srli	r8,r8,16
8112e1b4:	193fffcc 	andi	r4,r3,65535
8112e1b8:	2fcb383a 	mul	r5,r5,ra
8112e1bc:	7bc00104 	addi	r15,r15,4
8112e1c0:	73800104 	addi	r14,r14,4
8112e1c4:	2a0b883a 	add	r5,r5,r8
8112e1c8:	29cb883a 	add	r5,r5,r7
8112e1cc:	2806943a 	slli	r3,r5,16
8112e1d0:	94400104 	addi	r17,r18,4
8112e1d4:	280ad43a 	srli	r5,r5,16
8112e1d8:	1908b03a 	or	r4,r3,r4
8112e1dc:	793fff15 	stw	r4,-4(r15)
8112e1e0:	70ffff17 	ldw	r3,-4(r14)
8112e1e4:	8a000017 	ldw	r8,0(r17)
8112e1e8:	1806d43a 	srli	r3,r3,16
8112e1ec:	413fffcc 	andi	r4,r8,65535
8112e1f0:	1fc7383a 	mul	r3,r3,ra
8112e1f4:	1907883a 	add	r3,r3,r4
8112e1f8:	1947883a 	add	r3,r3,r5
8112e1fc:	180ed43a 	srli	r7,r3,16
8112e200:	727fe936 	bltu	r14,r9,8112e1a8 <__reset+0xfb10e1a8>
8112e204:	90c00115 	stw	r3,4(r18)
8112e208:	31800104 	addi	r6,r6,4
8112e20c:	5ac00104 	addi	r11,r11,4
8112e210:	333fbe36 	bltu	r6,r12,8112e10c <__reset+0xfb10e10c>
8112e214:	0400090e 	bge	zero,r16,8112e23c <__multiply+0x1dc>
8112e218:	50ffff17 	ldw	r3,-4(r10)
8112e21c:	52bfff04 	addi	r10,r10,-4
8112e220:	18000326 	beq	r3,zero,8112e230 <__multiply+0x1d0>
8112e224:	00000506 	br	8112e23c <__multiply+0x1dc>
8112e228:	50c00017 	ldw	r3,0(r10)
8112e22c:	1800031e 	bne	r3,zero,8112e23c <__multiply+0x1dc>
8112e230:	843fffc4 	addi	r16,r16,-1
8112e234:	52bfff04 	addi	r10,r10,-4
8112e238:	803ffb1e 	bne	r16,zero,8112e228 <__reset+0xfb10e228>
8112e23c:	14000415 	stw	r16,16(r2)
8112e240:	dfc00517 	ldw	ra,20(sp)
8112e244:	dd000417 	ldw	r20,16(sp)
8112e248:	dcc00317 	ldw	r19,12(sp)
8112e24c:	dc800217 	ldw	r18,8(sp)
8112e250:	dc400117 	ldw	r17,4(sp)
8112e254:	dc000017 	ldw	r16,0(sp)
8112e258:	dec00604 	addi	sp,sp,24
8112e25c:	f800283a 	ret

8112e260 <__pow5mult>:
8112e260:	defffa04 	addi	sp,sp,-24
8112e264:	de00012e 	bgeu	sp,et,8112e26c <__pow5mult+0xc>
8112e268:	003b68fa 	trap	3
8112e26c:	308000cc 	andi	r2,r6,3
8112e270:	dcc00315 	stw	r19,12(sp)
8112e274:	dc000015 	stw	r16,0(sp)
8112e278:	dfc00515 	stw	ra,20(sp)
8112e27c:	dd000415 	stw	r20,16(sp)
8112e280:	dc800215 	stw	r18,8(sp)
8112e284:	dc400115 	stw	r17,4(sp)
8112e288:	3021883a 	mov	r16,r6
8112e28c:	2027883a 	mov	r19,r4
8112e290:	10002f1e 	bne	r2,zero,8112e350 <__pow5mult+0xf0>
8112e294:	2825883a 	mov	r18,r5
8112e298:	8021d0ba 	srai	r16,r16,2
8112e29c:	80001a26 	beq	r16,zero,8112e308 <__pow5mult+0xa8>
8112e2a0:	9c401217 	ldw	r17,72(r19)
8112e2a4:	8800061e 	bne	r17,zero,8112e2c0 <__pow5mult+0x60>
8112e2a8:	00003406 	br	8112e37c <__pow5mult+0x11c>
8112e2ac:	8021d07a 	srai	r16,r16,1
8112e2b0:	80001526 	beq	r16,zero,8112e308 <__pow5mult+0xa8>
8112e2b4:	88800017 	ldw	r2,0(r17)
8112e2b8:	10001c26 	beq	r2,zero,8112e32c <__pow5mult+0xcc>
8112e2bc:	1023883a 	mov	r17,r2
8112e2c0:	8080004c 	andi	r2,r16,1
8112e2c4:	103ff926 	beq	r2,zero,8112e2ac <__reset+0xfb10e2ac>
8112e2c8:	880d883a 	mov	r6,r17
8112e2cc:	900b883a 	mov	r5,r18
8112e2d0:	9809883a 	mov	r4,r19
8112e2d4:	112e0600 	call	8112e060 <__multiply>
8112e2d8:	90001b26 	beq	r18,zero,8112e348 <__pow5mult+0xe8>
8112e2dc:	91000117 	ldw	r4,4(r18)
8112e2e0:	98c01317 	ldw	r3,76(r19)
8112e2e4:	8021d07a 	srai	r16,r16,1
8112e2e8:	2109883a 	add	r4,r4,r4
8112e2ec:	2109883a 	add	r4,r4,r4
8112e2f0:	1907883a 	add	r3,r3,r4
8112e2f4:	19000017 	ldw	r4,0(r3)
8112e2f8:	91000015 	stw	r4,0(r18)
8112e2fc:	1c800015 	stw	r18,0(r3)
8112e300:	1025883a 	mov	r18,r2
8112e304:	803feb1e 	bne	r16,zero,8112e2b4 <__reset+0xfb10e2b4>
8112e308:	9005883a 	mov	r2,r18
8112e30c:	dfc00517 	ldw	ra,20(sp)
8112e310:	dd000417 	ldw	r20,16(sp)
8112e314:	dcc00317 	ldw	r19,12(sp)
8112e318:	dc800217 	ldw	r18,8(sp)
8112e31c:	dc400117 	ldw	r17,4(sp)
8112e320:	dc000017 	ldw	r16,0(sp)
8112e324:	dec00604 	addi	sp,sp,24
8112e328:	f800283a 	ret
8112e32c:	880d883a 	mov	r6,r17
8112e330:	880b883a 	mov	r5,r17
8112e334:	9809883a 	mov	r4,r19
8112e338:	112e0600 	call	8112e060 <__multiply>
8112e33c:	88800015 	stw	r2,0(r17)
8112e340:	10000015 	stw	zero,0(r2)
8112e344:	003fdd06 	br	8112e2bc <__reset+0xfb10e2bc>
8112e348:	1025883a 	mov	r18,r2
8112e34c:	003fd706 	br	8112e2ac <__reset+0xfb10e2ac>
8112e350:	10bfffc4 	addi	r2,r2,-1
8112e354:	1085883a 	add	r2,r2,r2
8112e358:	00e04574 	movhi	r3,33045
8112e35c:	18c76d04 	addi	r3,r3,7604
8112e360:	1085883a 	add	r2,r2,r2
8112e364:	1885883a 	add	r2,r3,r2
8112e368:	11800017 	ldw	r6,0(r2)
8112e36c:	000f883a 	mov	r7,zero
8112e370:	112dcd00 	call	8112dcd0 <__multadd>
8112e374:	1025883a 	mov	r18,r2
8112e378:	003fc706 	br	8112e298 <__reset+0xfb10e298>
8112e37c:	05000044 	movi	r20,1
8112e380:	a00b883a 	mov	r5,r20
8112e384:	9809883a 	mov	r4,r19
8112e388:	112dbf80 	call	8112dbf8 <_Balloc>
8112e38c:	1023883a 	mov	r17,r2
8112e390:	00809c44 	movi	r2,625
8112e394:	88800515 	stw	r2,20(r17)
8112e398:	8d000415 	stw	r20,16(r17)
8112e39c:	9c401215 	stw	r17,72(r19)
8112e3a0:	88000015 	stw	zero,0(r17)
8112e3a4:	003fc606 	br	8112e2c0 <__reset+0xfb10e2c0>

8112e3a8 <__lshift>:
8112e3a8:	defff904 	addi	sp,sp,-28
8112e3ac:	de00012e 	bgeu	sp,et,8112e3b4 <__lshift+0xc>
8112e3b0:	003b68fa 	trap	3
8112e3b4:	dd400515 	stw	r21,20(sp)
8112e3b8:	dcc00315 	stw	r19,12(sp)
8112e3bc:	302bd17a 	srai	r21,r6,5
8112e3c0:	2cc00417 	ldw	r19,16(r5)
8112e3c4:	28800217 	ldw	r2,8(r5)
8112e3c8:	dd000415 	stw	r20,16(sp)
8112e3cc:	ace7883a 	add	r19,r21,r19
8112e3d0:	dc800215 	stw	r18,8(sp)
8112e3d4:	dc400115 	stw	r17,4(sp)
8112e3d8:	dc000015 	stw	r16,0(sp)
8112e3dc:	dfc00615 	stw	ra,24(sp)
8112e3e0:	9c000044 	addi	r16,r19,1
8112e3e4:	2823883a 	mov	r17,r5
8112e3e8:	3029883a 	mov	r20,r6
8112e3ec:	2025883a 	mov	r18,r4
8112e3f0:	29400117 	ldw	r5,4(r5)
8112e3f4:	1400030e 	bge	r2,r16,8112e404 <__lshift+0x5c>
8112e3f8:	1085883a 	add	r2,r2,r2
8112e3fc:	29400044 	addi	r5,r5,1
8112e400:	143ffd16 	blt	r2,r16,8112e3f8 <__reset+0xfb10e3f8>
8112e404:	9009883a 	mov	r4,r18
8112e408:	112dbf80 	call	8112dbf8 <_Balloc>
8112e40c:	10c00504 	addi	r3,r2,20
8112e410:	0540070e 	bge	zero,r21,8112e430 <__lshift+0x88>
8112e414:	ad6b883a 	add	r21,r21,r21
8112e418:	ad6b883a 	add	r21,r21,r21
8112e41c:	1809883a 	mov	r4,r3
8112e420:	1d47883a 	add	r3,r3,r21
8112e424:	20000015 	stw	zero,0(r4)
8112e428:	21000104 	addi	r4,r4,4
8112e42c:	193ffd1e 	bne	r3,r4,8112e424 <__reset+0xfb10e424>
8112e430:	8a000417 	ldw	r8,16(r17)
8112e434:	89000504 	addi	r4,r17,20
8112e438:	a18007cc 	andi	r6,r20,31
8112e43c:	4211883a 	add	r8,r8,r8
8112e440:	4211883a 	add	r8,r8,r8
8112e444:	2211883a 	add	r8,r4,r8
8112e448:	30002326 	beq	r6,zero,8112e4d8 <__lshift+0x130>
8112e44c:	02400804 	movi	r9,32
8112e450:	4993c83a 	sub	r9,r9,r6
8112e454:	000b883a 	mov	r5,zero
8112e458:	21c00017 	ldw	r7,0(r4)
8112e45c:	1815883a 	mov	r10,r3
8112e460:	18c00104 	addi	r3,r3,4
8112e464:	398e983a 	sll	r7,r7,r6
8112e468:	21000104 	addi	r4,r4,4
8112e46c:	394ab03a 	or	r5,r7,r5
8112e470:	197fff15 	stw	r5,-4(r3)
8112e474:	217fff17 	ldw	r5,-4(r4)
8112e478:	2a4ad83a 	srl	r5,r5,r9
8112e47c:	223ff636 	bltu	r4,r8,8112e458 <__reset+0xfb10e458>
8112e480:	51400115 	stw	r5,4(r10)
8112e484:	28001a1e 	bne	r5,zero,8112e4f0 <__lshift+0x148>
8112e488:	843fffc4 	addi	r16,r16,-1
8112e48c:	14000415 	stw	r16,16(r2)
8112e490:	88000826 	beq	r17,zero,8112e4b4 <__lshift+0x10c>
8112e494:	89000117 	ldw	r4,4(r17)
8112e498:	90c01317 	ldw	r3,76(r18)
8112e49c:	2109883a 	add	r4,r4,r4
8112e4a0:	2109883a 	add	r4,r4,r4
8112e4a4:	1907883a 	add	r3,r3,r4
8112e4a8:	19000017 	ldw	r4,0(r3)
8112e4ac:	89000015 	stw	r4,0(r17)
8112e4b0:	1c400015 	stw	r17,0(r3)
8112e4b4:	dfc00617 	ldw	ra,24(sp)
8112e4b8:	dd400517 	ldw	r21,20(sp)
8112e4bc:	dd000417 	ldw	r20,16(sp)
8112e4c0:	dcc00317 	ldw	r19,12(sp)
8112e4c4:	dc800217 	ldw	r18,8(sp)
8112e4c8:	dc400117 	ldw	r17,4(sp)
8112e4cc:	dc000017 	ldw	r16,0(sp)
8112e4d0:	dec00704 	addi	sp,sp,28
8112e4d4:	f800283a 	ret
8112e4d8:	21400017 	ldw	r5,0(r4)
8112e4dc:	18c00104 	addi	r3,r3,4
8112e4e0:	21000104 	addi	r4,r4,4
8112e4e4:	197fff15 	stw	r5,-4(r3)
8112e4e8:	223ffb36 	bltu	r4,r8,8112e4d8 <__reset+0xfb10e4d8>
8112e4ec:	003fe606 	br	8112e488 <__reset+0xfb10e488>
8112e4f0:	9c000084 	addi	r16,r19,2
8112e4f4:	003fe406 	br	8112e488 <__reset+0xfb10e488>

8112e4f8 <__mcmp>:
8112e4f8:	20800417 	ldw	r2,16(r4)
8112e4fc:	28c00417 	ldw	r3,16(r5)
8112e500:	10c5c83a 	sub	r2,r2,r3
8112e504:	1000111e 	bne	r2,zero,8112e54c <__mcmp+0x54>
8112e508:	18c7883a 	add	r3,r3,r3
8112e50c:	18c7883a 	add	r3,r3,r3
8112e510:	21000504 	addi	r4,r4,20
8112e514:	29400504 	addi	r5,r5,20
8112e518:	20c5883a 	add	r2,r4,r3
8112e51c:	28cb883a 	add	r5,r5,r3
8112e520:	00000106 	br	8112e528 <__mcmp+0x30>
8112e524:	20800a2e 	bgeu	r4,r2,8112e550 <__mcmp+0x58>
8112e528:	10bfff04 	addi	r2,r2,-4
8112e52c:	297fff04 	addi	r5,r5,-4
8112e530:	11800017 	ldw	r6,0(r2)
8112e534:	28c00017 	ldw	r3,0(r5)
8112e538:	30fffa26 	beq	r6,r3,8112e524 <__reset+0xfb10e524>
8112e53c:	30c00236 	bltu	r6,r3,8112e548 <__mcmp+0x50>
8112e540:	00800044 	movi	r2,1
8112e544:	f800283a 	ret
8112e548:	00bfffc4 	movi	r2,-1
8112e54c:	f800283a 	ret
8112e550:	0005883a 	mov	r2,zero
8112e554:	f800283a 	ret

8112e558 <__mdiff>:
8112e558:	defffa04 	addi	sp,sp,-24
8112e55c:	de00012e 	bgeu	sp,et,8112e564 <__mdiff+0xc>
8112e560:	003b68fa 	trap	3
8112e564:	28c00417 	ldw	r3,16(r5)
8112e568:	30800417 	ldw	r2,16(r6)
8112e56c:	dcc00315 	stw	r19,12(sp)
8112e570:	dc800215 	stw	r18,8(sp)
8112e574:	dfc00515 	stw	ra,20(sp)
8112e578:	dd000415 	stw	r20,16(sp)
8112e57c:	dc400115 	stw	r17,4(sp)
8112e580:	dc000015 	stw	r16,0(sp)
8112e584:	1887c83a 	sub	r3,r3,r2
8112e588:	2825883a 	mov	r18,r5
8112e58c:	3027883a 	mov	r19,r6
8112e590:	1800141e 	bne	r3,zero,8112e5e4 <__mdiff+0x8c>
8112e594:	1085883a 	add	r2,r2,r2
8112e598:	1085883a 	add	r2,r2,r2
8112e59c:	2a000504 	addi	r8,r5,20
8112e5a0:	34000504 	addi	r16,r6,20
8112e5a4:	4087883a 	add	r3,r8,r2
8112e5a8:	8085883a 	add	r2,r16,r2
8112e5ac:	00000106 	br	8112e5b4 <__mdiff+0x5c>
8112e5b0:	40c0592e 	bgeu	r8,r3,8112e718 <__mdiff+0x1c0>
8112e5b4:	18ffff04 	addi	r3,r3,-4
8112e5b8:	10bfff04 	addi	r2,r2,-4
8112e5bc:	19c00017 	ldw	r7,0(r3)
8112e5c0:	11400017 	ldw	r5,0(r2)
8112e5c4:	397ffa26 	beq	r7,r5,8112e5b0 <__reset+0xfb10e5b0>
8112e5c8:	3940592e 	bgeu	r7,r5,8112e730 <__mdiff+0x1d8>
8112e5cc:	9005883a 	mov	r2,r18
8112e5d0:	4023883a 	mov	r17,r8
8112e5d4:	9825883a 	mov	r18,r19
8112e5d8:	05000044 	movi	r20,1
8112e5dc:	1027883a 	mov	r19,r2
8112e5e0:	00000406 	br	8112e5f4 <__mdiff+0x9c>
8112e5e4:	18005616 	blt	r3,zero,8112e740 <__mdiff+0x1e8>
8112e5e8:	34400504 	addi	r17,r6,20
8112e5ec:	2c000504 	addi	r16,r5,20
8112e5f0:	0029883a 	mov	r20,zero
8112e5f4:	91400117 	ldw	r5,4(r18)
8112e5f8:	112dbf80 	call	8112dbf8 <_Balloc>
8112e5fc:	92400417 	ldw	r9,16(r18)
8112e600:	9b000417 	ldw	r12,16(r19)
8112e604:	12c00504 	addi	r11,r2,20
8112e608:	4a51883a 	add	r8,r9,r9
8112e60c:	6319883a 	add	r12,r12,r12
8112e610:	4211883a 	add	r8,r8,r8
8112e614:	6319883a 	add	r12,r12,r12
8112e618:	15000315 	stw	r20,12(r2)
8112e61c:	8211883a 	add	r8,r16,r8
8112e620:	8b19883a 	add	r12,r17,r12
8112e624:	0007883a 	mov	r3,zero
8112e628:	81400017 	ldw	r5,0(r16)
8112e62c:	89c00017 	ldw	r7,0(r17)
8112e630:	59800104 	addi	r6,r11,4
8112e634:	293fffcc 	andi	r4,r5,65535
8112e638:	20c7883a 	add	r3,r4,r3
8112e63c:	393fffcc 	andi	r4,r7,65535
8112e640:	1909c83a 	sub	r4,r3,r4
8112e644:	280ad43a 	srli	r5,r5,16
8112e648:	380ed43a 	srli	r7,r7,16
8112e64c:	2007d43a 	srai	r3,r4,16
8112e650:	213fffcc 	andi	r4,r4,65535
8112e654:	29cbc83a 	sub	r5,r5,r7
8112e658:	28c7883a 	add	r3,r5,r3
8112e65c:	180a943a 	slli	r5,r3,16
8112e660:	8c400104 	addi	r17,r17,4
8112e664:	84000104 	addi	r16,r16,4
8112e668:	2908b03a 	or	r4,r5,r4
8112e66c:	59000015 	stw	r4,0(r11)
8112e670:	1807d43a 	srai	r3,r3,16
8112e674:	3015883a 	mov	r10,r6
8112e678:	3017883a 	mov	r11,r6
8112e67c:	8b3fea36 	bltu	r17,r12,8112e628 <__reset+0xfb10e628>
8112e680:	8200162e 	bgeu	r16,r8,8112e6dc <__mdiff+0x184>
8112e684:	8017883a 	mov	r11,r16
8112e688:	59400017 	ldw	r5,0(r11)
8112e68c:	31800104 	addi	r6,r6,4
8112e690:	5ac00104 	addi	r11,r11,4
8112e694:	293fffcc 	andi	r4,r5,65535
8112e698:	20c7883a 	add	r3,r4,r3
8112e69c:	280ed43a 	srli	r7,r5,16
8112e6a0:	180bd43a 	srai	r5,r3,16
8112e6a4:	193fffcc 	andi	r4,r3,65535
8112e6a8:	3947883a 	add	r3,r7,r5
8112e6ac:	180a943a 	slli	r5,r3,16
8112e6b0:	1807d43a 	srai	r3,r3,16
8112e6b4:	2908b03a 	or	r4,r5,r4
8112e6b8:	313fff15 	stw	r4,-4(r6)
8112e6bc:	5a3ff236 	bltu	r11,r8,8112e688 <__reset+0xfb10e688>
8112e6c0:	0406303a 	nor	r3,zero,r16
8112e6c4:	1a07883a 	add	r3,r3,r8
8112e6c8:	1806d0ba 	srli	r3,r3,2
8112e6cc:	18c00044 	addi	r3,r3,1
8112e6d0:	18c7883a 	add	r3,r3,r3
8112e6d4:	18c7883a 	add	r3,r3,r3
8112e6d8:	50d5883a 	add	r10,r10,r3
8112e6dc:	50ffff04 	addi	r3,r10,-4
8112e6e0:	2000041e 	bne	r4,zero,8112e6f4 <__mdiff+0x19c>
8112e6e4:	18ffff04 	addi	r3,r3,-4
8112e6e8:	19000017 	ldw	r4,0(r3)
8112e6ec:	4a7fffc4 	addi	r9,r9,-1
8112e6f0:	203ffc26 	beq	r4,zero,8112e6e4 <__reset+0xfb10e6e4>
8112e6f4:	12400415 	stw	r9,16(r2)
8112e6f8:	dfc00517 	ldw	ra,20(sp)
8112e6fc:	dd000417 	ldw	r20,16(sp)
8112e700:	dcc00317 	ldw	r19,12(sp)
8112e704:	dc800217 	ldw	r18,8(sp)
8112e708:	dc400117 	ldw	r17,4(sp)
8112e70c:	dc000017 	ldw	r16,0(sp)
8112e710:	dec00604 	addi	sp,sp,24
8112e714:	f800283a 	ret
8112e718:	000b883a 	mov	r5,zero
8112e71c:	112dbf80 	call	8112dbf8 <_Balloc>
8112e720:	00c00044 	movi	r3,1
8112e724:	10c00415 	stw	r3,16(r2)
8112e728:	10000515 	stw	zero,20(r2)
8112e72c:	003ff206 	br	8112e6f8 <__reset+0xfb10e6f8>
8112e730:	8023883a 	mov	r17,r16
8112e734:	0029883a 	mov	r20,zero
8112e738:	4021883a 	mov	r16,r8
8112e73c:	003fad06 	br	8112e5f4 <__reset+0xfb10e5f4>
8112e740:	9005883a 	mov	r2,r18
8112e744:	94400504 	addi	r17,r18,20
8112e748:	9c000504 	addi	r16,r19,20
8112e74c:	9825883a 	mov	r18,r19
8112e750:	05000044 	movi	r20,1
8112e754:	1027883a 	mov	r19,r2
8112e758:	003fa606 	br	8112e5f4 <__reset+0xfb10e5f4>

8112e75c <__ulp>:
8112e75c:	295ffc2c 	andhi	r5,r5,32752
8112e760:	00bf3034 	movhi	r2,64704
8112e764:	2887883a 	add	r3,r5,r2
8112e768:	00c0020e 	bge	zero,r3,8112e774 <__ulp+0x18>
8112e76c:	0005883a 	mov	r2,zero
8112e770:	f800283a 	ret
8112e774:	00c7c83a 	sub	r3,zero,r3
8112e778:	1807d53a 	srai	r3,r3,20
8112e77c:	008004c4 	movi	r2,19
8112e780:	10c00b0e 	bge	r2,r3,8112e7b0 <__ulp+0x54>
8112e784:	18bffb04 	addi	r2,r3,-20
8112e788:	01000784 	movi	r4,30
8112e78c:	0007883a 	mov	r3,zero
8112e790:	20800516 	blt	r4,r2,8112e7a8 <__ulp+0x4c>
8112e794:	010007c4 	movi	r4,31
8112e798:	2089c83a 	sub	r4,r4,r2
8112e79c:	00800044 	movi	r2,1
8112e7a0:	1104983a 	sll	r2,r2,r4
8112e7a4:	f800283a 	ret
8112e7a8:	00800044 	movi	r2,1
8112e7ac:	f800283a 	ret
8112e7b0:	01400234 	movhi	r5,8
8112e7b4:	28c7d83a 	sra	r3,r5,r3
8112e7b8:	0005883a 	mov	r2,zero
8112e7bc:	f800283a 	ret

8112e7c0 <__b2d>:
8112e7c0:	defffa04 	addi	sp,sp,-24
8112e7c4:	de00012e 	bgeu	sp,et,8112e7cc <__b2d+0xc>
8112e7c8:	003b68fa 	trap	3
8112e7cc:	dc000015 	stw	r16,0(sp)
8112e7d0:	24000417 	ldw	r16,16(r4)
8112e7d4:	dc400115 	stw	r17,4(sp)
8112e7d8:	24400504 	addi	r17,r4,20
8112e7dc:	8421883a 	add	r16,r16,r16
8112e7e0:	8421883a 	add	r16,r16,r16
8112e7e4:	8c21883a 	add	r16,r17,r16
8112e7e8:	dc800215 	stw	r18,8(sp)
8112e7ec:	84bfff17 	ldw	r18,-4(r16)
8112e7f0:	dd000415 	stw	r20,16(sp)
8112e7f4:	dcc00315 	stw	r19,12(sp)
8112e7f8:	9009883a 	mov	r4,r18
8112e7fc:	2829883a 	mov	r20,r5
8112e800:	dfc00515 	stw	ra,20(sp)
8112e804:	112df040 	call	8112df04 <__hi0bits>
8112e808:	00c00804 	movi	r3,32
8112e80c:	1889c83a 	sub	r4,r3,r2
8112e810:	a1000015 	stw	r4,0(r20)
8112e814:	01000284 	movi	r4,10
8112e818:	84ffff04 	addi	r19,r16,-4
8112e81c:	20801216 	blt	r4,r2,8112e868 <__b2d+0xa8>
8112e820:	018002c4 	movi	r6,11
8112e824:	308dc83a 	sub	r6,r6,r2
8112e828:	9186d83a 	srl	r3,r18,r6
8112e82c:	18cffc34 	orhi	r3,r3,16368
8112e830:	8cc0212e 	bgeu	r17,r19,8112e8b8 <__b2d+0xf8>
8112e834:	813ffe17 	ldw	r4,-8(r16)
8112e838:	218cd83a 	srl	r6,r4,r6
8112e83c:	10800544 	addi	r2,r2,21
8112e840:	9084983a 	sll	r2,r18,r2
8112e844:	1184b03a 	or	r2,r2,r6
8112e848:	dfc00517 	ldw	ra,20(sp)
8112e84c:	dd000417 	ldw	r20,16(sp)
8112e850:	dcc00317 	ldw	r19,12(sp)
8112e854:	dc800217 	ldw	r18,8(sp)
8112e858:	dc400117 	ldw	r17,4(sp)
8112e85c:	dc000017 	ldw	r16,0(sp)
8112e860:	dec00604 	addi	sp,sp,24
8112e864:	f800283a 	ret
8112e868:	8cc00f2e 	bgeu	r17,r19,8112e8a8 <__b2d+0xe8>
8112e86c:	117ffd44 	addi	r5,r2,-11
8112e870:	80bffe17 	ldw	r2,-8(r16)
8112e874:	28000e26 	beq	r5,zero,8112e8b0 <__b2d+0xf0>
8112e878:	1949c83a 	sub	r4,r3,r5
8112e87c:	9164983a 	sll	r18,r18,r5
8112e880:	1106d83a 	srl	r3,r2,r4
8112e884:	81bffe04 	addi	r6,r16,-8
8112e888:	948ffc34 	orhi	r18,r18,16368
8112e88c:	90c6b03a 	or	r3,r18,r3
8112e890:	89800e2e 	bgeu	r17,r6,8112e8cc <__b2d+0x10c>
8112e894:	81bffd17 	ldw	r6,-12(r16)
8112e898:	1144983a 	sll	r2,r2,r5
8112e89c:	310ad83a 	srl	r5,r6,r4
8112e8a0:	2884b03a 	or	r2,r5,r2
8112e8a4:	003fe806 	br	8112e848 <__reset+0xfb10e848>
8112e8a8:	10bffd44 	addi	r2,r2,-11
8112e8ac:	1000041e 	bne	r2,zero,8112e8c0 <__b2d+0x100>
8112e8b0:	90cffc34 	orhi	r3,r18,16368
8112e8b4:	003fe406 	br	8112e848 <__reset+0xfb10e848>
8112e8b8:	000d883a 	mov	r6,zero
8112e8bc:	003fdf06 	br	8112e83c <__reset+0xfb10e83c>
8112e8c0:	90a4983a 	sll	r18,r18,r2
8112e8c4:	0005883a 	mov	r2,zero
8112e8c8:	003ff906 	br	8112e8b0 <__reset+0xfb10e8b0>
8112e8cc:	1144983a 	sll	r2,r2,r5
8112e8d0:	003fdd06 	br	8112e848 <__reset+0xfb10e848>

8112e8d4 <__d2b>:
8112e8d4:	defff804 	addi	sp,sp,-32
8112e8d8:	de00012e 	bgeu	sp,et,8112e8e0 <__d2b+0xc>
8112e8dc:	003b68fa 	trap	3
8112e8e0:	dc000215 	stw	r16,8(sp)
8112e8e4:	3021883a 	mov	r16,r6
8112e8e8:	dc400315 	stw	r17,12(sp)
8112e8ec:	8022907a 	slli	r17,r16,1
8112e8f0:	dd000615 	stw	r20,24(sp)
8112e8f4:	2829883a 	mov	r20,r5
8112e8f8:	01400044 	movi	r5,1
8112e8fc:	dcc00515 	stw	r19,20(sp)
8112e900:	dc800415 	stw	r18,16(sp)
8112e904:	dfc00715 	stw	ra,28(sp)
8112e908:	3825883a 	mov	r18,r7
8112e90c:	8822d57a 	srli	r17,r17,21
8112e910:	112dbf80 	call	8112dbf8 <_Balloc>
8112e914:	1027883a 	mov	r19,r2
8112e918:	00800434 	movhi	r2,16
8112e91c:	10bfffc4 	addi	r2,r2,-1
8112e920:	808c703a 	and	r6,r16,r2
8112e924:	88000126 	beq	r17,zero,8112e92c <__d2b+0x58>
8112e928:	31800434 	orhi	r6,r6,16
8112e92c:	d9800015 	stw	r6,0(sp)
8112e930:	a0002426 	beq	r20,zero,8112e9c4 <__d2b+0xf0>
8112e934:	d9000104 	addi	r4,sp,4
8112e938:	dd000115 	stw	r20,4(sp)
8112e93c:	112df6c0 	call	8112df6c <__lo0bits>
8112e940:	d8c00017 	ldw	r3,0(sp)
8112e944:	10002f1e 	bne	r2,zero,8112ea04 <__d2b+0x130>
8112e948:	d9000117 	ldw	r4,4(sp)
8112e94c:	99000515 	stw	r4,20(r19)
8112e950:	1821003a 	cmpeq	r16,r3,zero
8112e954:	01000084 	movi	r4,2
8112e958:	2421c83a 	sub	r16,r4,r16
8112e95c:	98c00615 	stw	r3,24(r19)
8112e960:	9c000415 	stw	r16,16(r19)
8112e964:	88001f1e 	bne	r17,zero,8112e9e4 <__d2b+0x110>
8112e968:	10bef384 	addi	r2,r2,-1074
8112e96c:	90800015 	stw	r2,0(r18)
8112e970:	00900034 	movhi	r2,16384
8112e974:	10bfffc4 	addi	r2,r2,-1
8112e978:	8085883a 	add	r2,r16,r2
8112e97c:	1085883a 	add	r2,r2,r2
8112e980:	1085883a 	add	r2,r2,r2
8112e984:	9885883a 	add	r2,r19,r2
8112e988:	11000517 	ldw	r4,20(r2)
8112e98c:	8020917a 	slli	r16,r16,5
8112e990:	112df040 	call	8112df04 <__hi0bits>
8112e994:	d8c00817 	ldw	r3,32(sp)
8112e998:	8085c83a 	sub	r2,r16,r2
8112e99c:	18800015 	stw	r2,0(r3)
8112e9a0:	9805883a 	mov	r2,r19
8112e9a4:	dfc00717 	ldw	ra,28(sp)
8112e9a8:	dd000617 	ldw	r20,24(sp)
8112e9ac:	dcc00517 	ldw	r19,20(sp)
8112e9b0:	dc800417 	ldw	r18,16(sp)
8112e9b4:	dc400317 	ldw	r17,12(sp)
8112e9b8:	dc000217 	ldw	r16,8(sp)
8112e9bc:	dec00804 	addi	sp,sp,32
8112e9c0:	f800283a 	ret
8112e9c4:	d809883a 	mov	r4,sp
8112e9c8:	112df6c0 	call	8112df6c <__lo0bits>
8112e9cc:	d8c00017 	ldw	r3,0(sp)
8112e9d0:	04000044 	movi	r16,1
8112e9d4:	9c000415 	stw	r16,16(r19)
8112e9d8:	98c00515 	stw	r3,20(r19)
8112e9dc:	10800804 	addi	r2,r2,32
8112e9e0:	883fe126 	beq	r17,zero,8112e968 <__reset+0xfb10e968>
8112e9e4:	00c00d44 	movi	r3,53
8112e9e8:	8c7ef344 	addi	r17,r17,-1075
8112e9ec:	88a3883a 	add	r17,r17,r2
8112e9f0:	1885c83a 	sub	r2,r3,r2
8112e9f4:	d8c00817 	ldw	r3,32(sp)
8112e9f8:	94400015 	stw	r17,0(r18)
8112e9fc:	18800015 	stw	r2,0(r3)
8112ea00:	003fe706 	br	8112e9a0 <__reset+0xfb10e9a0>
8112ea04:	01000804 	movi	r4,32
8112ea08:	2089c83a 	sub	r4,r4,r2
8112ea0c:	1908983a 	sll	r4,r3,r4
8112ea10:	d9400117 	ldw	r5,4(sp)
8112ea14:	1886d83a 	srl	r3,r3,r2
8112ea18:	2148b03a 	or	r4,r4,r5
8112ea1c:	99000515 	stw	r4,20(r19)
8112ea20:	d8c00015 	stw	r3,0(sp)
8112ea24:	003fca06 	br	8112e950 <__reset+0xfb10e950>

8112ea28 <__ratio>:
8112ea28:	defff904 	addi	sp,sp,-28
8112ea2c:	de00012e 	bgeu	sp,et,8112ea34 <__ratio+0xc>
8112ea30:	003b68fa 	trap	3
8112ea34:	dc400315 	stw	r17,12(sp)
8112ea38:	2823883a 	mov	r17,r5
8112ea3c:	d9400104 	addi	r5,sp,4
8112ea40:	dfc00615 	stw	ra,24(sp)
8112ea44:	dcc00515 	stw	r19,20(sp)
8112ea48:	dc800415 	stw	r18,16(sp)
8112ea4c:	2027883a 	mov	r19,r4
8112ea50:	dc000215 	stw	r16,8(sp)
8112ea54:	112e7c00 	call	8112e7c0 <__b2d>
8112ea58:	d80b883a 	mov	r5,sp
8112ea5c:	8809883a 	mov	r4,r17
8112ea60:	1025883a 	mov	r18,r2
8112ea64:	1821883a 	mov	r16,r3
8112ea68:	112e7c00 	call	8112e7c0 <__b2d>
8112ea6c:	8a000417 	ldw	r8,16(r17)
8112ea70:	99000417 	ldw	r4,16(r19)
8112ea74:	d9400117 	ldw	r5,4(sp)
8112ea78:	2209c83a 	sub	r4,r4,r8
8112ea7c:	2010917a 	slli	r8,r4,5
8112ea80:	d9000017 	ldw	r4,0(sp)
8112ea84:	2909c83a 	sub	r4,r5,r4
8112ea88:	4109883a 	add	r4,r8,r4
8112ea8c:	01000e0e 	bge	zero,r4,8112eac8 <__ratio+0xa0>
8112ea90:	2008953a 	slli	r4,r4,20
8112ea94:	2421883a 	add	r16,r4,r16
8112ea98:	100d883a 	mov	r6,r2
8112ea9c:	180f883a 	mov	r7,r3
8112eaa0:	9009883a 	mov	r4,r18
8112eaa4:	800b883a 	mov	r5,r16
8112eaa8:	1136aa00 	call	81136aa0 <__divdf3>
8112eaac:	dfc00617 	ldw	ra,24(sp)
8112eab0:	dcc00517 	ldw	r19,20(sp)
8112eab4:	dc800417 	ldw	r18,16(sp)
8112eab8:	dc400317 	ldw	r17,12(sp)
8112eabc:	dc000217 	ldw	r16,8(sp)
8112eac0:	dec00704 	addi	sp,sp,28
8112eac4:	f800283a 	ret
8112eac8:	2008953a 	slli	r4,r4,20
8112eacc:	1907c83a 	sub	r3,r3,r4
8112ead0:	003ff106 	br	8112ea98 <__reset+0xfb10ea98>

8112ead4 <_mprec_log10>:
8112ead4:	defffe04 	addi	sp,sp,-8
8112ead8:	de00012e 	bgeu	sp,et,8112eae0 <_mprec_log10+0xc>
8112eadc:	003b68fa 	trap	3
8112eae0:	008005c4 	movi	r2,23
8112eae4:	dc000015 	stw	r16,0(sp)
8112eae8:	dfc00115 	stw	ra,4(sp)
8112eaec:	2021883a 	mov	r16,r4
8112eaf0:	11000d0e 	bge	r2,r4,8112eb28 <_mprec_log10+0x54>
8112eaf4:	0005883a 	mov	r2,zero
8112eaf8:	00cffc34 	movhi	r3,16368
8112eafc:	843fffc4 	addi	r16,r16,-1
8112eb00:	000d883a 	mov	r6,zero
8112eb04:	01d00934 	movhi	r7,16420
8112eb08:	1009883a 	mov	r4,r2
8112eb0c:	180b883a 	mov	r5,r3
8112eb10:	112138c0 	call	8112138c <__muldf3>
8112eb14:	803ff91e 	bne	r16,zero,8112eafc <__reset+0xfb10eafc>
8112eb18:	dfc00117 	ldw	ra,4(sp)
8112eb1c:	dc000017 	ldw	r16,0(sp)
8112eb20:	dec00204 	addi	sp,sp,8
8112eb24:	f800283a 	ret
8112eb28:	202090fa 	slli	r16,r4,3
8112eb2c:	00a04574 	movhi	r2,33045
8112eb30:	10878404 	addi	r2,r2,7696
8112eb34:	1421883a 	add	r16,r2,r16
8112eb38:	80800017 	ldw	r2,0(r16)
8112eb3c:	80c00117 	ldw	r3,4(r16)
8112eb40:	dfc00117 	ldw	ra,4(sp)
8112eb44:	dc000017 	ldw	r16,0(sp)
8112eb48:	dec00204 	addi	sp,sp,8
8112eb4c:	f800283a 	ret

8112eb50 <__copybits>:
8112eb50:	297fffc4 	addi	r5,r5,-1
8112eb54:	280fd17a 	srai	r7,r5,5
8112eb58:	30c00417 	ldw	r3,16(r6)
8112eb5c:	30800504 	addi	r2,r6,20
8112eb60:	39c00044 	addi	r7,r7,1
8112eb64:	18c7883a 	add	r3,r3,r3
8112eb68:	39cf883a 	add	r7,r7,r7
8112eb6c:	18c7883a 	add	r3,r3,r3
8112eb70:	39cf883a 	add	r7,r7,r7
8112eb74:	10c7883a 	add	r3,r2,r3
8112eb78:	21cf883a 	add	r7,r4,r7
8112eb7c:	10c00d2e 	bgeu	r2,r3,8112ebb4 <__copybits+0x64>
8112eb80:	200b883a 	mov	r5,r4
8112eb84:	12000017 	ldw	r8,0(r2)
8112eb88:	29400104 	addi	r5,r5,4
8112eb8c:	10800104 	addi	r2,r2,4
8112eb90:	2a3fff15 	stw	r8,-4(r5)
8112eb94:	10fffb36 	bltu	r2,r3,8112eb84 <__reset+0xfb10eb84>
8112eb98:	1985c83a 	sub	r2,r3,r6
8112eb9c:	10bffac4 	addi	r2,r2,-21
8112eba0:	1004d0ba 	srli	r2,r2,2
8112eba4:	10800044 	addi	r2,r2,1
8112eba8:	1085883a 	add	r2,r2,r2
8112ebac:	1085883a 	add	r2,r2,r2
8112ebb0:	2089883a 	add	r4,r4,r2
8112ebb4:	21c0032e 	bgeu	r4,r7,8112ebc4 <__copybits+0x74>
8112ebb8:	20000015 	stw	zero,0(r4)
8112ebbc:	21000104 	addi	r4,r4,4
8112ebc0:	21fffd36 	bltu	r4,r7,8112ebb8 <__reset+0xfb10ebb8>
8112ebc4:	f800283a 	ret

8112ebc8 <__any_on>:
8112ebc8:	20c00417 	ldw	r3,16(r4)
8112ebcc:	2805d17a 	srai	r2,r5,5
8112ebd0:	21000504 	addi	r4,r4,20
8112ebd4:	18800d0e 	bge	r3,r2,8112ec0c <__any_on+0x44>
8112ebd8:	18c7883a 	add	r3,r3,r3
8112ebdc:	18c7883a 	add	r3,r3,r3
8112ebe0:	20c7883a 	add	r3,r4,r3
8112ebe4:	20c0192e 	bgeu	r4,r3,8112ec4c <__any_on+0x84>
8112ebe8:	18bfff17 	ldw	r2,-4(r3)
8112ebec:	18ffff04 	addi	r3,r3,-4
8112ebf0:	1000041e 	bne	r2,zero,8112ec04 <__any_on+0x3c>
8112ebf4:	20c0142e 	bgeu	r4,r3,8112ec48 <__any_on+0x80>
8112ebf8:	18ffff04 	addi	r3,r3,-4
8112ebfc:	19400017 	ldw	r5,0(r3)
8112ec00:	283ffc26 	beq	r5,zero,8112ebf4 <__reset+0xfb10ebf4>
8112ec04:	00800044 	movi	r2,1
8112ec08:	f800283a 	ret
8112ec0c:	10c00a0e 	bge	r2,r3,8112ec38 <__any_on+0x70>
8112ec10:	1085883a 	add	r2,r2,r2
8112ec14:	1085883a 	add	r2,r2,r2
8112ec18:	294007cc 	andi	r5,r5,31
8112ec1c:	2087883a 	add	r3,r4,r2
8112ec20:	283ff026 	beq	r5,zero,8112ebe4 <__reset+0xfb10ebe4>
8112ec24:	19800017 	ldw	r6,0(r3)
8112ec28:	3144d83a 	srl	r2,r6,r5
8112ec2c:	114a983a 	sll	r5,r2,r5
8112ec30:	317ff41e 	bne	r6,r5,8112ec04 <__reset+0xfb10ec04>
8112ec34:	003feb06 	br	8112ebe4 <__reset+0xfb10ebe4>
8112ec38:	1085883a 	add	r2,r2,r2
8112ec3c:	1085883a 	add	r2,r2,r2
8112ec40:	2087883a 	add	r3,r4,r2
8112ec44:	003fe706 	br	8112ebe4 <__reset+0xfb10ebe4>
8112ec48:	f800283a 	ret
8112ec4c:	0005883a 	mov	r2,zero
8112ec50:	f800283a 	ret

8112ec54 <_read_r>:
8112ec54:	defffd04 	addi	sp,sp,-12
8112ec58:	de00012e 	bgeu	sp,et,8112ec60 <_read_r+0xc>
8112ec5c:	003b68fa 	trap	3
8112ec60:	2805883a 	mov	r2,r5
8112ec64:	dc000015 	stw	r16,0(sp)
8112ec68:	04204574 	movhi	r16,33045
8112ec6c:	dc400115 	stw	r17,4(sp)
8112ec70:	300b883a 	mov	r5,r6
8112ec74:	84118604 	addi	r16,r16,17944
8112ec78:	2023883a 	mov	r17,r4
8112ec7c:	380d883a 	mov	r6,r7
8112ec80:	1009883a 	mov	r4,r2
8112ec84:	dfc00215 	stw	ra,8(sp)
8112ec88:	80000015 	stw	zero,0(r16)
8112ec8c:	1138c100 	call	81138c10 <read>
8112ec90:	00ffffc4 	movi	r3,-1
8112ec94:	10c00526 	beq	r2,r3,8112ecac <_read_r+0x58>
8112ec98:	dfc00217 	ldw	ra,8(sp)
8112ec9c:	dc400117 	ldw	r17,4(sp)
8112eca0:	dc000017 	ldw	r16,0(sp)
8112eca4:	dec00304 	addi	sp,sp,12
8112eca8:	f800283a 	ret
8112ecac:	80c00017 	ldw	r3,0(r16)
8112ecb0:	183ff926 	beq	r3,zero,8112ec98 <__reset+0xfb10ec98>
8112ecb4:	88c00015 	stw	r3,0(r17)
8112ecb8:	003ff706 	br	8112ec98 <__reset+0xfb10ec98>

8112ecbc <_realloc_r>:
8112ecbc:	defff604 	addi	sp,sp,-40
8112ecc0:	de00012e 	bgeu	sp,et,8112ecc8 <_realloc_r+0xc>
8112ecc4:	003b68fa 	trap	3
8112ecc8:	dc800215 	stw	r18,8(sp)
8112eccc:	dfc00915 	stw	ra,36(sp)
8112ecd0:	df000815 	stw	fp,32(sp)
8112ecd4:	ddc00715 	stw	r23,28(sp)
8112ecd8:	dd800615 	stw	r22,24(sp)
8112ecdc:	dd400515 	stw	r21,20(sp)
8112ece0:	dd000415 	stw	r20,16(sp)
8112ece4:	dcc00315 	stw	r19,12(sp)
8112ece8:	dc400115 	stw	r17,4(sp)
8112ecec:	dc000015 	stw	r16,0(sp)
8112ecf0:	3025883a 	mov	r18,r6
8112ecf4:	2800b726 	beq	r5,zero,8112efd4 <_realloc_r+0x318>
8112ecf8:	282b883a 	mov	r21,r5
8112ecfc:	2029883a 	mov	r20,r4
8112ed00:	11393f00 	call	811393f0 <__malloc_lock>
8112ed04:	a8bfff17 	ldw	r2,-4(r21)
8112ed08:	043fff04 	movi	r16,-4
8112ed0c:	90c002c4 	addi	r3,r18,11
8112ed10:	01000584 	movi	r4,22
8112ed14:	acfffe04 	addi	r19,r21,-8
8112ed18:	1420703a 	and	r16,r2,r16
8112ed1c:	20c0332e 	bgeu	r4,r3,8112edec <_realloc_r+0x130>
8112ed20:	047ffe04 	movi	r17,-8
8112ed24:	1c62703a 	and	r17,r3,r17
8112ed28:	8807883a 	mov	r3,r17
8112ed2c:	88005816 	blt	r17,zero,8112ee90 <_realloc_r+0x1d4>
8112ed30:	8c805736 	bltu	r17,r18,8112ee90 <_realloc_r+0x1d4>
8112ed34:	80c0300e 	bge	r16,r3,8112edf8 <_realloc_r+0x13c>
8112ed38:	07204574 	movhi	fp,33045
8112ed3c:	e70ad104 	addi	fp,fp,11076
8112ed40:	e1c00217 	ldw	r7,8(fp)
8112ed44:	9c09883a 	add	r4,r19,r16
8112ed48:	22000117 	ldw	r8,4(r4)
8112ed4c:	21c06326 	beq	r4,r7,8112eedc <_realloc_r+0x220>
8112ed50:	017fff84 	movi	r5,-2
8112ed54:	414a703a 	and	r5,r8,r5
8112ed58:	214b883a 	add	r5,r4,r5
8112ed5c:	29800117 	ldw	r6,4(r5)
8112ed60:	3180004c 	andi	r6,r6,1
8112ed64:	30003f26 	beq	r6,zero,8112ee64 <_realloc_r+0x1a8>
8112ed68:	1080004c 	andi	r2,r2,1
8112ed6c:	10008326 	beq	r2,zero,8112ef7c <_realloc_r+0x2c0>
8112ed70:	900b883a 	mov	r5,r18
8112ed74:	a009883a 	mov	r4,r20
8112ed78:	11232300 	call	81123230 <_malloc_r>
8112ed7c:	1025883a 	mov	r18,r2
8112ed80:	10011e26 	beq	r2,zero,8112f1fc <_realloc_r+0x540>
8112ed84:	a93fff17 	ldw	r4,-4(r21)
8112ed88:	10fffe04 	addi	r3,r2,-8
8112ed8c:	00bfff84 	movi	r2,-2
8112ed90:	2084703a 	and	r2,r4,r2
8112ed94:	9885883a 	add	r2,r19,r2
8112ed98:	1880ee26 	beq	r3,r2,8112f154 <_realloc_r+0x498>
8112ed9c:	81bfff04 	addi	r6,r16,-4
8112eda0:	00800904 	movi	r2,36
8112eda4:	1180b836 	bltu	r2,r6,8112f088 <_realloc_r+0x3cc>
8112eda8:	00c004c4 	movi	r3,19
8112edac:	19809636 	bltu	r3,r6,8112f008 <_realloc_r+0x34c>
8112edb0:	9005883a 	mov	r2,r18
8112edb4:	a807883a 	mov	r3,r21
8112edb8:	19000017 	ldw	r4,0(r3)
8112edbc:	11000015 	stw	r4,0(r2)
8112edc0:	19000117 	ldw	r4,4(r3)
8112edc4:	11000115 	stw	r4,4(r2)
8112edc8:	18c00217 	ldw	r3,8(r3)
8112edcc:	10c00215 	stw	r3,8(r2)
8112edd0:	a80b883a 	mov	r5,r21
8112edd4:	a009883a 	mov	r4,r20
8112edd8:	112cc280 	call	8112cc28 <_free_r>
8112eddc:	a009883a 	mov	r4,r20
8112ede0:	11395180 	call	81139518 <__malloc_unlock>
8112ede4:	9005883a 	mov	r2,r18
8112ede8:	00001206 	br	8112ee34 <_realloc_r+0x178>
8112edec:	00c00404 	movi	r3,16
8112edf0:	1823883a 	mov	r17,r3
8112edf4:	003fce06 	br	8112ed30 <__reset+0xfb10ed30>
8112edf8:	a825883a 	mov	r18,r21
8112edfc:	8445c83a 	sub	r2,r16,r17
8112ee00:	00c003c4 	movi	r3,15
8112ee04:	18802636 	bltu	r3,r2,8112eea0 <_realloc_r+0x1e4>
8112ee08:	99800117 	ldw	r6,4(r19)
8112ee0c:	9c07883a 	add	r3,r19,r16
8112ee10:	3180004c 	andi	r6,r6,1
8112ee14:	3420b03a 	or	r16,r6,r16
8112ee18:	9c000115 	stw	r16,4(r19)
8112ee1c:	18800117 	ldw	r2,4(r3)
8112ee20:	10800054 	ori	r2,r2,1
8112ee24:	18800115 	stw	r2,4(r3)
8112ee28:	a009883a 	mov	r4,r20
8112ee2c:	11395180 	call	81139518 <__malloc_unlock>
8112ee30:	9005883a 	mov	r2,r18
8112ee34:	dfc00917 	ldw	ra,36(sp)
8112ee38:	df000817 	ldw	fp,32(sp)
8112ee3c:	ddc00717 	ldw	r23,28(sp)
8112ee40:	dd800617 	ldw	r22,24(sp)
8112ee44:	dd400517 	ldw	r21,20(sp)
8112ee48:	dd000417 	ldw	r20,16(sp)
8112ee4c:	dcc00317 	ldw	r19,12(sp)
8112ee50:	dc800217 	ldw	r18,8(sp)
8112ee54:	dc400117 	ldw	r17,4(sp)
8112ee58:	dc000017 	ldw	r16,0(sp)
8112ee5c:	dec00a04 	addi	sp,sp,40
8112ee60:	f800283a 	ret
8112ee64:	017fff04 	movi	r5,-4
8112ee68:	414a703a 	and	r5,r8,r5
8112ee6c:	814d883a 	add	r6,r16,r5
8112ee70:	30c01f16 	blt	r6,r3,8112eef0 <_realloc_r+0x234>
8112ee74:	20800317 	ldw	r2,12(r4)
8112ee78:	20c00217 	ldw	r3,8(r4)
8112ee7c:	a825883a 	mov	r18,r21
8112ee80:	3021883a 	mov	r16,r6
8112ee84:	18800315 	stw	r2,12(r3)
8112ee88:	10c00215 	stw	r3,8(r2)
8112ee8c:	003fdb06 	br	8112edfc <__reset+0xfb10edfc>
8112ee90:	00800304 	movi	r2,12
8112ee94:	a0800015 	stw	r2,0(r20)
8112ee98:	0005883a 	mov	r2,zero
8112ee9c:	003fe506 	br	8112ee34 <__reset+0xfb10ee34>
8112eea0:	98c00117 	ldw	r3,4(r19)
8112eea4:	9c4b883a 	add	r5,r19,r17
8112eea8:	11000054 	ori	r4,r2,1
8112eeac:	18c0004c 	andi	r3,r3,1
8112eeb0:	1c62b03a 	or	r17,r3,r17
8112eeb4:	9c400115 	stw	r17,4(r19)
8112eeb8:	29000115 	stw	r4,4(r5)
8112eebc:	2885883a 	add	r2,r5,r2
8112eec0:	10c00117 	ldw	r3,4(r2)
8112eec4:	29400204 	addi	r5,r5,8
8112eec8:	a009883a 	mov	r4,r20
8112eecc:	18c00054 	ori	r3,r3,1
8112eed0:	10c00115 	stw	r3,4(r2)
8112eed4:	112cc280 	call	8112cc28 <_free_r>
8112eed8:	003fd306 	br	8112ee28 <__reset+0xfb10ee28>
8112eedc:	017fff04 	movi	r5,-4
8112eee0:	414a703a 	and	r5,r8,r5
8112eee4:	89800404 	addi	r6,r17,16
8112eee8:	8151883a 	add	r8,r16,r5
8112eeec:	4180590e 	bge	r8,r6,8112f054 <_realloc_r+0x398>
8112eef0:	1080004c 	andi	r2,r2,1
8112eef4:	103f9e1e 	bne	r2,zero,8112ed70 <__reset+0xfb10ed70>
8112eef8:	adbffe17 	ldw	r22,-8(r21)
8112eefc:	00bfff04 	movi	r2,-4
8112ef00:	9dadc83a 	sub	r22,r19,r22
8112ef04:	b1800117 	ldw	r6,4(r22)
8112ef08:	3084703a 	and	r2,r6,r2
8112ef0c:	20002026 	beq	r4,zero,8112ef90 <_realloc_r+0x2d4>
8112ef10:	80af883a 	add	r23,r16,r2
8112ef14:	b96f883a 	add	r23,r23,r5
8112ef18:	21c05f26 	beq	r4,r7,8112f098 <_realloc_r+0x3dc>
8112ef1c:	b8c01c16 	blt	r23,r3,8112ef90 <_realloc_r+0x2d4>
8112ef20:	20800317 	ldw	r2,12(r4)
8112ef24:	20c00217 	ldw	r3,8(r4)
8112ef28:	81bfff04 	addi	r6,r16,-4
8112ef2c:	01000904 	movi	r4,36
8112ef30:	18800315 	stw	r2,12(r3)
8112ef34:	10c00215 	stw	r3,8(r2)
8112ef38:	b0c00217 	ldw	r3,8(r22)
8112ef3c:	b0800317 	ldw	r2,12(r22)
8112ef40:	b4800204 	addi	r18,r22,8
8112ef44:	18800315 	stw	r2,12(r3)
8112ef48:	10c00215 	stw	r3,8(r2)
8112ef4c:	21801b36 	bltu	r4,r6,8112efbc <_realloc_r+0x300>
8112ef50:	008004c4 	movi	r2,19
8112ef54:	1180352e 	bgeu	r2,r6,8112f02c <_realloc_r+0x370>
8112ef58:	a8800017 	ldw	r2,0(r21)
8112ef5c:	b0800215 	stw	r2,8(r22)
8112ef60:	a8800117 	ldw	r2,4(r21)
8112ef64:	b0800315 	stw	r2,12(r22)
8112ef68:	008006c4 	movi	r2,27
8112ef6c:	11807f36 	bltu	r2,r6,8112f16c <_realloc_r+0x4b0>
8112ef70:	b0800404 	addi	r2,r22,16
8112ef74:	ad400204 	addi	r21,r21,8
8112ef78:	00002d06 	br	8112f030 <_realloc_r+0x374>
8112ef7c:	adbffe17 	ldw	r22,-8(r21)
8112ef80:	00bfff04 	movi	r2,-4
8112ef84:	9dadc83a 	sub	r22,r19,r22
8112ef88:	b1000117 	ldw	r4,4(r22)
8112ef8c:	2084703a 	and	r2,r4,r2
8112ef90:	b03f7726 	beq	r22,zero,8112ed70 <__reset+0xfb10ed70>
8112ef94:	80af883a 	add	r23,r16,r2
8112ef98:	b8ff7516 	blt	r23,r3,8112ed70 <__reset+0xfb10ed70>
8112ef9c:	b0800317 	ldw	r2,12(r22)
8112efa0:	b0c00217 	ldw	r3,8(r22)
8112efa4:	81bfff04 	addi	r6,r16,-4
8112efa8:	01000904 	movi	r4,36
8112efac:	18800315 	stw	r2,12(r3)
8112efb0:	10c00215 	stw	r3,8(r2)
8112efb4:	b4800204 	addi	r18,r22,8
8112efb8:	21bfe52e 	bgeu	r4,r6,8112ef50 <__reset+0xfb10ef50>
8112efbc:	a80b883a 	mov	r5,r21
8112efc0:	9009883a 	mov	r4,r18
8112efc4:	112da9c0 	call	8112da9c <memmove>
8112efc8:	b821883a 	mov	r16,r23
8112efcc:	b027883a 	mov	r19,r22
8112efd0:	003f8a06 	br	8112edfc <__reset+0xfb10edfc>
8112efd4:	300b883a 	mov	r5,r6
8112efd8:	dfc00917 	ldw	ra,36(sp)
8112efdc:	df000817 	ldw	fp,32(sp)
8112efe0:	ddc00717 	ldw	r23,28(sp)
8112efe4:	dd800617 	ldw	r22,24(sp)
8112efe8:	dd400517 	ldw	r21,20(sp)
8112efec:	dd000417 	ldw	r20,16(sp)
8112eff0:	dcc00317 	ldw	r19,12(sp)
8112eff4:	dc800217 	ldw	r18,8(sp)
8112eff8:	dc400117 	ldw	r17,4(sp)
8112effc:	dc000017 	ldw	r16,0(sp)
8112f000:	dec00a04 	addi	sp,sp,40
8112f004:	11232301 	jmpi	81123230 <_malloc_r>
8112f008:	a8c00017 	ldw	r3,0(r21)
8112f00c:	90c00015 	stw	r3,0(r18)
8112f010:	a8c00117 	ldw	r3,4(r21)
8112f014:	90c00115 	stw	r3,4(r18)
8112f018:	00c006c4 	movi	r3,27
8112f01c:	19804536 	bltu	r3,r6,8112f134 <_realloc_r+0x478>
8112f020:	90800204 	addi	r2,r18,8
8112f024:	a8c00204 	addi	r3,r21,8
8112f028:	003f6306 	br	8112edb8 <__reset+0xfb10edb8>
8112f02c:	9005883a 	mov	r2,r18
8112f030:	a8c00017 	ldw	r3,0(r21)
8112f034:	b821883a 	mov	r16,r23
8112f038:	b027883a 	mov	r19,r22
8112f03c:	10c00015 	stw	r3,0(r2)
8112f040:	a8c00117 	ldw	r3,4(r21)
8112f044:	10c00115 	stw	r3,4(r2)
8112f048:	a8c00217 	ldw	r3,8(r21)
8112f04c:	10c00215 	stw	r3,8(r2)
8112f050:	003f6a06 	br	8112edfc <__reset+0xfb10edfc>
8112f054:	9c67883a 	add	r19,r19,r17
8112f058:	4445c83a 	sub	r2,r8,r17
8112f05c:	e4c00215 	stw	r19,8(fp)
8112f060:	10800054 	ori	r2,r2,1
8112f064:	98800115 	stw	r2,4(r19)
8112f068:	a8bfff17 	ldw	r2,-4(r21)
8112f06c:	a009883a 	mov	r4,r20
8112f070:	1080004c 	andi	r2,r2,1
8112f074:	1462b03a 	or	r17,r2,r17
8112f078:	ac7fff15 	stw	r17,-4(r21)
8112f07c:	11395180 	call	81139518 <__malloc_unlock>
8112f080:	a805883a 	mov	r2,r21
8112f084:	003f6b06 	br	8112ee34 <__reset+0xfb10ee34>
8112f088:	a80b883a 	mov	r5,r21
8112f08c:	9009883a 	mov	r4,r18
8112f090:	112da9c0 	call	8112da9c <memmove>
8112f094:	003f4e06 	br	8112edd0 <__reset+0xfb10edd0>
8112f098:	89000404 	addi	r4,r17,16
8112f09c:	b93fbc16 	blt	r23,r4,8112ef90 <__reset+0xfb10ef90>
8112f0a0:	b0800317 	ldw	r2,12(r22)
8112f0a4:	b0c00217 	ldw	r3,8(r22)
8112f0a8:	81bfff04 	addi	r6,r16,-4
8112f0ac:	01000904 	movi	r4,36
8112f0b0:	18800315 	stw	r2,12(r3)
8112f0b4:	10c00215 	stw	r3,8(r2)
8112f0b8:	b4800204 	addi	r18,r22,8
8112f0bc:	21804336 	bltu	r4,r6,8112f1cc <_realloc_r+0x510>
8112f0c0:	008004c4 	movi	r2,19
8112f0c4:	11803f2e 	bgeu	r2,r6,8112f1c4 <_realloc_r+0x508>
8112f0c8:	a8800017 	ldw	r2,0(r21)
8112f0cc:	b0800215 	stw	r2,8(r22)
8112f0d0:	a8800117 	ldw	r2,4(r21)
8112f0d4:	b0800315 	stw	r2,12(r22)
8112f0d8:	008006c4 	movi	r2,27
8112f0dc:	11803f36 	bltu	r2,r6,8112f1dc <_realloc_r+0x520>
8112f0e0:	b0800404 	addi	r2,r22,16
8112f0e4:	ad400204 	addi	r21,r21,8
8112f0e8:	a8c00017 	ldw	r3,0(r21)
8112f0ec:	10c00015 	stw	r3,0(r2)
8112f0f0:	a8c00117 	ldw	r3,4(r21)
8112f0f4:	10c00115 	stw	r3,4(r2)
8112f0f8:	a8c00217 	ldw	r3,8(r21)
8112f0fc:	10c00215 	stw	r3,8(r2)
8112f100:	b447883a 	add	r3,r22,r17
8112f104:	bc45c83a 	sub	r2,r23,r17
8112f108:	e0c00215 	stw	r3,8(fp)
8112f10c:	10800054 	ori	r2,r2,1
8112f110:	18800115 	stw	r2,4(r3)
8112f114:	b0800117 	ldw	r2,4(r22)
8112f118:	a009883a 	mov	r4,r20
8112f11c:	1080004c 	andi	r2,r2,1
8112f120:	1462b03a 	or	r17,r2,r17
8112f124:	b4400115 	stw	r17,4(r22)
8112f128:	11395180 	call	81139518 <__malloc_unlock>
8112f12c:	9005883a 	mov	r2,r18
8112f130:	003f4006 	br	8112ee34 <__reset+0xfb10ee34>
8112f134:	a8c00217 	ldw	r3,8(r21)
8112f138:	90c00215 	stw	r3,8(r18)
8112f13c:	a8c00317 	ldw	r3,12(r21)
8112f140:	90c00315 	stw	r3,12(r18)
8112f144:	30801126 	beq	r6,r2,8112f18c <_realloc_r+0x4d0>
8112f148:	90800404 	addi	r2,r18,16
8112f14c:	a8c00404 	addi	r3,r21,16
8112f150:	003f1906 	br	8112edb8 <__reset+0xfb10edb8>
8112f154:	90ffff17 	ldw	r3,-4(r18)
8112f158:	00bfff04 	movi	r2,-4
8112f15c:	a825883a 	mov	r18,r21
8112f160:	1884703a 	and	r2,r3,r2
8112f164:	80a1883a 	add	r16,r16,r2
8112f168:	003f2406 	br	8112edfc <__reset+0xfb10edfc>
8112f16c:	a8800217 	ldw	r2,8(r21)
8112f170:	b0800415 	stw	r2,16(r22)
8112f174:	a8800317 	ldw	r2,12(r21)
8112f178:	b0800515 	stw	r2,20(r22)
8112f17c:	31000a26 	beq	r6,r4,8112f1a8 <_realloc_r+0x4ec>
8112f180:	b0800604 	addi	r2,r22,24
8112f184:	ad400404 	addi	r21,r21,16
8112f188:	003fa906 	br	8112f030 <__reset+0xfb10f030>
8112f18c:	a9000417 	ldw	r4,16(r21)
8112f190:	90800604 	addi	r2,r18,24
8112f194:	a8c00604 	addi	r3,r21,24
8112f198:	91000415 	stw	r4,16(r18)
8112f19c:	a9000517 	ldw	r4,20(r21)
8112f1a0:	91000515 	stw	r4,20(r18)
8112f1a4:	003f0406 	br	8112edb8 <__reset+0xfb10edb8>
8112f1a8:	a8c00417 	ldw	r3,16(r21)
8112f1ac:	ad400604 	addi	r21,r21,24
8112f1b0:	b0800804 	addi	r2,r22,32
8112f1b4:	b0c00615 	stw	r3,24(r22)
8112f1b8:	a8ffff17 	ldw	r3,-4(r21)
8112f1bc:	b0c00715 	stw	r3,28(r22)
8112f1c0:	003f9b06 	br	8112f030 <__reset+0xfb10f030>
8112f1c4:	9005883a 	mov	r2,r18
8112f1c8:	003fc706 	br	8112f0e8 <__reset+0xfb10f0e8>
8112f1cc:	a80b883a 	mov	r5,r21
8112f1d0:	9009883a 	mov	r4,r18
8112f1d4:	112da9c0 	call	8112da9c <memmove>
8112f1d8:	003fc906 	br	8112f100 <__reset+0xfb10f100>
8112f1dc:	a8800217 	ldw	r2,8(r21)
8112f1e0:	b0800415 	stw	r2,16(r22)
8112f1e4:	a8800317 	ldw	r2,12(r21)
8112f1e8:	b0800515 	stw	r2,20(r22)
8112f1ec:	31000726 	beq	r6,r4,8112f20c <_realloc_r+0x550>
8112f1f0:	b0800604 	addi	r2,r22,24
8112f1f4:	ad400404 	addi	r21,r21,16
8112f1f8:	003fbb06 	br	8112f0e8 <__reset+0xfb10f0e8>
8112f1fc:	a009883a 	mov	r4,r20
8112f200:	11395180 	call	81139518 <__malloc_unlock>
8112f204:	0005883a 	mov	r2,zero
8112f208:	003f0a06 	br	8112ee34 <__reset+0xfb10ee34>
8112f20c:	a8c00417 	ldw	r3,16(r21)
8112f210:	ad400604 	addi	r21,r21,24
8112f214:	b0800804 	addi	r2,r22,32
8112f218:	b0c00615 	stw	r3,24(r22)
8112f21c:	a8ffff17 	ldw	r3,-4(r21)
8112f220:	b0c00715 	stw	r3,28(r22)
8112f224:	003fb006 	br	8112f0e8 <__reset+0xfb10f0e8>

8112f228 <__fpclassifyd>:
8112f228:	00a00034 	movhi	r2,32768
8112f22c:	10bfffc4 	addi	r2,r2,-1
8112f230:	2884703a 	and	r2,r5,r2
8112f234:	10000726 	beq	r2,zero,8112f254 <__fpclassifyd+0x2c>
8112f238:	00fffc34 	movhi	r3,65520
8112f23c:	019ff834 	movhi	r6,32736
8112f240:	28c7883a 	add	r3,r5,r3
8112f244:	31bfffc4 	addi	r6,r6,-1
8112f248:	30c00536 	bltu	r6,r3,8112f260 <__fpclassifyd+0x38>
8112f24c:	00800104 	movi	r2,4
8112f250:	f800283a 	ret
8112f254:	2000021e 	bne	r4,zero,8112f260 <__fpclassifyd+0x38>
8112f258:	00800084 	movi	r2,2
8112f25c:	f800283a 	ret
8112f260:	00dffc34 	movhi	r3,32752
8112f264:	019ff834 	movhi	r6,32736
8112f268:	28cb883a 	add	r5,r5,r3
8112f26c:	31bfffc4 	addi	r6,r6,-1
8112f270:	317ff62e 	bgeu	r6,r5,8112f24c <__reset+0xfb10f24c>
8112f274:	01400434 	movhi	r5,16
8112f278:	297fffc4 	addi	r5,r5,-1
8112f27c:	28800236 	bltu	r5,r2,8112f288 <__fpclassifyd+0x60>
8112f280:	008000c4 	movi	r2,3
8112f284:	f800283a 	ret
8112f288:	10c00226 	beq	r2,r3,8112f294 <__fpclassifyd+0x6c>
8112f28c:	0005883a 	mov	r2,zero
8112f290:	f800283a 	ret
8112f294:	2005003a 	cmpeq	r2,r4,zero
8112f298:	f800283a 	ret

8112f29c <__sccl>:
8112f29c:	2a000003 	ldbu	r8,0(r5)
8112f2a0:	00801784 	movi	r2,94
8112f2a4:	40802a26 	beq	r8,r2,8112f350 <__sccl+0xb4>
8112f2a8:	29400044 	addi	r5,r5,1
8112f2ac:	000f883a 	mov	r7,zero
8112f2b0:	0013883a 	mov	r9,zero
8112f2b4:	2007883a 	mov	r3,r4
8112f2b8:	21804004 	addi	r6,r4,256
8112f2bc:	19c00005 	stb	r7,0(r3)
8112f2c0:	18c00044 	addi	r3,r3,1
8112f2c4:	19bffd1e 	bne	r3,r6,8112f2bc <__reset+0xfb10f2bc>
8112f2c8:	40001126 	beq	r8,zero,8112f310 <__sccl+0x74>
8112f2cc:	00800044 	movi	r2,1
8112f2d0:	124fc83a 	sub	r7,r2,r9
8112f2d4:	02800b44 	movi	r10,45
8112f2d8:	02c01744 	movi	r11,93
8112f2dc:	2205883a 	add	r2,r4,r8
8112f2e0:	11c00005 	stb	r7,0(r2)
8112f2e4:	28800044 	addi	r2,r5,1
8112f2e8:	28c00003 	ldbu	r3,0(r5)
8112f2ec:	1a800a26 	beq	r3,r10,8112f318 <__sccl+0x7c>
8112f2f0:	1ac00426 	beq	r3,r11,8112f304 <__sccl+0x68>
8112f2f4:	18000426 	beq	r3,zero,8112f308 <__sccl+0x6c>
8112f2f8:	1811883a 	mov	r8,r3
8112f2fc:	100b883a 	mov	r5,r2
8112f300:	003ff606 	br	8112f2dc <__reset+0xfb10f2dc>
8112f304:	f800283a 	ret
8112f308:	2805883a 	mov	r2,r5
8112f30c:	f800283a 	ret
8112f310:	28bfffc4 	addi	r2,r5,-1
8112f314:	f800283a 	ret
8112f318:	12400003 	ldbu	r9,0(r2)
8112f31c:	4ac01126 	beq	r9,r11,8112f364 <__sccl+0xc8>
8112f320:	4a001016 	blt	r9,r8,8112f364 <__sccl+0xc8>
8112f324:	41800044 	addi	r6,r8,1
8112f328:	29400084 	addi	r5,r5,2
8112f32c:	2187883a 	add	r3,r4,r6
8112f330:	00000106 	br	8112f338 <__sccl+0x9c>
8112f334:	31800044 	addi	r6,r6,1
8112f338:	19c00005 	stb	r7,0(r3)
8112f33c:	3011883a 	mov	r8,r6
8112f340:	18c00044 	addi	r3,r3,1
8112f344:	327ffb16 	blt	r6,r9,8112f334 <__reset+0xfb10f334>
8112f348:	10800084 	addi	r2,r2,2
8112f34c:	003fe606 	br	8112f2e8 <__reset+0xfb10f2e8>
8112f350:	2a000043 	ldbu	r8,1(r5)
8112f354:	01c00044 	movi	r7,1
8112f358:	29400084 	addi	r5,r5,2
8112f35c:	02400044 	movi	r9,1
8112f360:	003fd406 	br	8112f2b4 <__reset+0xfb10f2b4>
8112f364:	5011883a 	mov	r8,r10
8112f368:	003fe406 	br	8112f2fc <__reset+0xfb10f2fc>

8112f36c <nanf>:
8112f36c:	009ff034 	movhi	r2,32704
8112f370:	f800283a 	ret

8112f374 <strcmp>:
8112f374:	2144b03a 	or	r2,r4,r5
8112f378:	108000cc 	andi	r2,r2,3
8112f37c:	1000171e 	bne	r2,zero,8112f3dc <strcmp+0x68>
8112f380:	20800017 	ldw	r2,0(r4)
8112f384:	28c00017 	ldw	r3,0(r5)
8112f388:	10c0141e 	bne	r2,r3,8112f3dc <strcmp+0x68>
8112f38c:	027fbff4 	movhi	r9,65279
8112f390:	4a7fbfc4 	addi	r9,r9,-257
8112f394:	0086303a 	nor	r3,zero,r2
8112f398:	02202074 	movhi	r8,32897
8112f39c:	1245883a 	add	r2,r2,r9
8112f3a0:	42202004 	addi	r8,r8,-32640
8112f3a4:	10c4703a 	and	r2,r2,r3
8112f3a8:	1204703a 	and	r2,r2,r8
8112f3ac:	10000226 	beq	r2,zero,8112f3b8 <strcmp+0x44>
8112f3b0:	00002306 	br	8112f440 <strcmp+0xcc>
8112f3b4:	1000221e 	bne	r2,zero,8112f440 <strcmp+0xcc>
8112f3b8:	21000104 	addi	r4,r4,4
8112f3bc:	20c00017 	ldw	r3,0(r4)
8112f3c0:	29400104 	addi	r5,r5,4
8112f3c4:	29800017 	ldw	r6,0(r5)
8112f3c8:	1a4f883a 	add	r7,r3,r9
8112f3cc:	00c4303a 	nor	r2,zero,r3
8112f3d0:	3884703a 	and	r2,r7,r2
8112f3d4:	1204703a 	and	r2,r2,r8
8112f3d8:	19bff626 	beq	r3,r6,8112f3b4 <__reset+0xfb10f3b4>
8112f3dc:	20800003 	ldbu	r2,0(r4)
8112f3e0:	10c03fcc 	andi	r3,r2,255
8112f3e4:	18c0201c 	xori	r3,r3,128
8112f3e8:	18ffe004 	addi	r3,r3,-128
8112f3ec:	18000c26 	beq	r3,zero,8112f420 <strcmp+0xac>
8112f3f0:	29800007 	ldb	r6,0(r5)
8112f3f4:	19800326 	beq	r3,r6,8112f404 <strcmp+0x90>
8112f3f8:	00001306 	br	8112f448 <strcmp+0xd4>
8112f3fc:	29800007 	ldb	r6,0(r5)
8112f400:	11800b1e 	bne	r2,r6,8112f430 <strcmp+0xbc>
8112f404:	21000044 	addi	r4,r4,1
8112f408:	20c00003 	ldbu	r3,0(r4)
8112f40c:	29400044 	addi	r5,r5,1
8112f410:	18803fcc 	andi	r2,r3,255
8112f414:	1080201c 	xori	r2,r2,128
8112f418:	10bfe004 	addi	r2,r2,-128
8112f41c:	103ff71e 	bne	r2,zero,8112f3fc <__reset+0xfb10f3fc>
8112f420:	0007883a 	mov	r3,zero
8112f424:	28800003 	ldbu	r2,0(r5)
8112f428:	1885c83a 	sub	r2,r3,r2
8112f42c:	f800283a 	ret
8112f430:	28800003 	ldbu	r2,0(r5)
8112f434:	18c03fcc 	andi	r3,r3,255
8112f438:	1885c83a 	sub	r2,r3,r2
8112f43c:	f800283a 	ret
8112f440:	0005883a 	mov	r2,zero
8112f444:	f800283a 	ret
8112f448:	10c03fcc 	andi	r3,r2,255
8112f44c:	003ff506 	br	8112f424 <__reset+0xfb10f424>

8112f450 <sulp>:
8112f450:	defffd04 	addi	sp,sp,-12
8112f454:	de00012e 	bgeu	sp,et,8112f45c <sulp+0xc>
8112f458:	003b68fa 	trap	3
8112f45c:	dc400115 	stw	r17,4(sp)
8112f460:	3023883a 	mov	r17,r6
8112f464:	dc000015 	stw	r16,0(sp)
8112f468:	dfc00215 	stw	ra,8(sp)
8112f46c:	2821883a 	mov	r16,r5
8112f470:	112e75c0 	call	8112e75c <__ulp>
8112f474:	88000c26 	beq	r17,zero,8112f4a8 <sulp+0x58>
8112f478:	841ffc2c 	andhi	r16,r16,32752
8112f47c:	8020d53a 	srli	r16,r16,20
8112f480:	01c01ac4 	movi	r7,107
8112f484:	3c21c83a 	sub	r16,r7,r16
8112f488:	0400070e 	bge	zero,r16,8112f4a8 <sulp+0x58>
8112f48c:	8020953a 	slli	r16,r16,20
8112f490:	01cffc34 	movhi	r7,16368
8112f494:	000d883a 	mov	r6,zero
8112f498:	81cf883a 	add	r7,r16,r7
8112f49c:	1009883a 	mov	r4,r2
8112f4a0:	180b883a 	mov	r5,r3
8112f4a4:	112138c0 	call	8112138c <__muldf3>
8112f4a8:	dfc00217 	ldw	ra,8(sp)
8112f4ac:	dc400117 	ldw	r17,4(sp)
8112f4b0:	dc000017 	ldw	r16,0(sp)
8112f4b4:	dec00304 	addi	sp,sp,12
8112f4b8:	f800283a 	ret

8112f4bc <_strtod_r>:
8112f4bc:	deffe204 	addi	sp,sp,-120
8112f4c0:	de00012e 	bgeu	sp,et,8112f4c8 <_strtod_r+0xc>
8112f4c4:	003b68fa 	trap	3
8112f4c8:	ddc01b15 	stw	r23,108(sp)
8112f4cc:	dd001815 	stw	r20,96(sp)
8112f4d0:	dc801615 	stw	r18,88(sp)
8112f4d4:	dc401515 	stw	r17,84(sp)
8112f4d8:	dc001415 	stw	r16,80(sp)
8112f4dc:	d9400615 	stw	r5,24(sp)
8112f4e0:	dfc01d15 	stw	ra,116(sp)
8112f4e4:	df001c15 	stw	fp,112(sp)
8112f4e8:	dd801a15 	stw	r22,104(sp)
8112f4ec:	dd401915 	stw	r21,100(sp)
8112f4f0:	dcc01715 	stw	r19,92(sp)
8112f4f4:	2021883a 	mov	r16,r4
8112f4f8:	d8000515 	stw	zero,20(sp)
8112f4fc:	2809883a 	mov	r4,r5
8112f500:	20800003 	ldbu	r2,0(r4)
8112f504:	01e044f4 	movhi	r7,33043
8112f508:	282f883a 	mov	r23,r5
8112f50c:	10c03fcc 	andi	r3,r2,255
8112f510:	01400b44 	movi	r5,45
8112f514:	39fd4e04 	addi	r7,r7,-2760
8112f518:	3029883a 	mov	r20,r6
8112f51c:	0025883a 	mov	r18,zero
8112f520:	0023883a 	mov	r17,zero
8112f524:	28c0ba36 	bltu	r5,r3,8112f810 <_strtod_r+0x354>
8112f528:	180690ba 	slli	r3,r3,2
8112f52c:	19c7883a 	add	r3,r3,r7
8112f530:	18c00017 	ldw	r3,0(r3)
8112f534:	1800683a 	jmp	r3
8112f538:	8112f5f8 	rdprs	r4,r16,19415
8112f53c:	8112f810 	cmplti	r4,r16,19424
8112f540:	8112f810 	cmplti	r4,r16,19424
8112f544:	8112f810 	cmplti	r4,r16,19424
8112f548:	8112f810 	cmplti	r4,r16,19424
8112f54c:	8112f810 	cmplti	r4,r16,19424
8112f550:	8112f810 	cmplti	r4,r16,19424
8112f554:	8112f810 	cmplti	r4,r16,19424
8112f558:	8112f810 	cmplti	r4,r16,19424
8112f55c:	8112f7fc 	xorhi	r4,r16,19423
8112f560:	8112f7fc 	xorhi	r4,r16,19423
8112f564:	8112f7fc 	xorhi	r4,r16,19423
8112f568:	8112f7fc 	xorhi	r4,r16,19423
8112f56c:	8112f7fc 	xorhi	r4,r16,19423
8112f570:	8112f810 	cmplti	r4,r16,19424
8112f574:	8112f810 	cmplti	r4,r16,19424
8112f578:	8112f810 	cmplti	r4,r16,19424
8112f57c:	8112f810 	cmplti	r4,r16,19424
8112f580:	8112f810 	cmplti	r4,r16,19424
8112f584:	8112f810 	cmplti	r4,r16,19424
8112f588:	8112f810 	cmplti	r4,r16,19424
8112f58c:	8112f810 	cmplti	r4,r16,19424
8112f590:	8112f810 	cmplti	r4,r16,19424
8112f594:	8112f810 	cmplti	r4,r16,19424
8112f598:	8112f810 	cmplti	r4,r16,19424
8112f59c:	8112f810 	cmplti	r4,r16,19424
8112f5a0:	8112f810 	cmplti	r4,r16,19424
8112f5a4:	8112f810 	cmplti	r4,r16,19424
8112f5a8:	8112f810 	cmplti	r4,r16,19424
8112f5ac:	8112f810 	cmplti	r4,r16,19424
8112f5b0:	8112f810 	cmplti	r4,r16,19424
8112f5b4:	8112f810 	cmplti	r4,r16,19424
8112f5b8:	8112f7fc 	xorhi	r4,r16,19423
8112f5bc:	8112f810 	cmplti	r4,r16,19424
8112f5c0:	8112f810 	cmplti	r4,r16,19424
8112f5c4:	8112f810 	cmplti	r4,r16,19424
8112f5c8:	8112f810 	cmplti	r4,r16,19424
8112f5cc:	8112f810 	cmplti	r4,r16,19424
8112f5d0:	8112f810 	cmplti	r4,r16,19424
8112f5d4:	8112f810 	cmplti	r4,r16,19424
8112f5d8:	8112f810 	cmplti	r4,r16,19424
8112f5dc:	8112f810 	cmplti	r4,r16,19424
8112f5e0:	8112f810 	cmplti	r4,r16,19424
8112f5e4:	8112f650 	cmplti	r4,r16,19417
8112f5e8:	8112f810 	cmplti	r4,r16,19424
8112f5ec:	8112f7f0 	cmpltui	r4,r16,19423
8112f5f0:	00801244 	movi	r2,73
8112f5f4:	88843526 	beq	r17,r2,811306cc <_strtod_r+0x1210>
8112f5f8:	002b883a 	mov	r21,zero
8112f5fc:	002d883a 	mov	r22,zero
8112f600:	a0000526 	beq	r20,zero,8112f618 <_strtod_r+0x15c>
8112f604:	d8000715 	stw	zero,28(sp)
8112f608:	a5c00015 	stw	r23,0(r20)
8112f60c:	d9000717 	ldw	r4,28(sp)
8112f610:	20000126 	beq	r4,zero,8112f618 <_strtod_r+0x15c>
8112f614:	b5a0003c 	xorhi	r22,r22,32768
8112f618:	a805883a 	mov	r2,r21
8112f61c:	b007883a 	mov	r3,r22
8112f620:	dfc01d17 	ldw	ra,116(sp)
8112f624:	df001c17 	ldw	fp,112(sp)
8112f628:	ddc01b17 	ldw	r23,108(sp)
8112f62c:	dd801a17 	ldw	r22,104(sp)
8112f630:	dd401917 	ldw	r21,100(sp)
8112f634:	dd001817 	ldw	r20,96(sp)
8112f638:	dcc01717 	ldw	r19,92(sp)
8112f63c:	dc801617 	ldw	r18,88(sp)
8112f640:	dc401517 	ldw	r17,84(sp)
8112f644:	dc001417 	ldw	r16,80(sp)
8112f648:	dec01e04 	addi	sp,sp,120
8112f64c:	f800283a 	ret
8112f650:	d8000715 	stw	zero,28(sp)
8112f654:	24c00044 	addi	r19,r4,1
8112f658:	dcc00615 	stw	r19,24(sp)
8112f65c:	20800043 	ldbu	r2,1(r4)
8112f660:	10c03fcc 	andi	r3,r2,255
8112f664:	18c0201c 	xori	r3,r3,128
8112f668:	18ffe004 	addi	r3,r3,-128
8112f66c:	183fe226 	beq	r3,zero,8112f5f8 <__reset+0xfb10f5f8>
8112f670:	11403fcc 	andi	r5,r2,255
8112f674:	2940201c 	xori	r5,r5,128
8112f678:	297fe004 	addi	r5,r5,-128
8112f67c:	00c00c04 	movi	r3,48
8112f680:	28c0e526 	beq	r5,r3,8112fa18 <_strtod_r+0x55c>
8112f684:	dcc00815 	stw	r19,32(sp)
8112f688:	0025883a 	mov	r18,zero
8112f68c:	10fff404 	addi	r3,r2,-48
8112f690:	18c03fcc 	andi	r3,r3,255
8112f694:	01000244 	movi	r4,9
8112f698:	20c37536 	bltu	r4,r3,81130470 <_strtod_r+0xfb4>
8112f69c:	dd400817 	ldw	r21,32(sp)
8112f6a0:	0027883a 	mov	r19,zero
8112f6a4:	0039883a 	mov	fp,zero
8112f6a8:	002d883a 	mov	r22,zero
8112f6ac:	01400204 	movi	r5,8
8112f6b0:	2d805a16 	blt	r5,r22,8112f81c <_strtod_r+0x360>
8112f6b4:	e70002a4 	muli	fp,fp,10
8112f6b8:	10c03fcc 	andi	r3,r2,255
8112f6bc:	18c0201c 	xori	r3,r3,128
8112f6c0:	18ffe004 	addi	r3,r3,-128
8112f6c4:	e0f9883a 	add	fp,fp,r3
8112f6c8:	e73ff404 	addi	fp,fp,-48
8112f6cc:	ad400044 	addi	r21,r21,1
8112f6d0:	dd400615 	stw	r21,24(sp)
8112f6d4:	a8800003 	ldbu	r2,0(r21)
8112f6d8:	b5800044 	addi	r22,r22,1
8112f6dc:	10fff404 	addi	r3,r2,-48
8112f6e0:	18c03fcc 	andi	r3,r3,255
8112f6e4:	20fff22e 	bgeu	r4,r3,8112f6b0 <__reset+0xfb10f6b0>
8112f6e8:	14403fcc 	andi	r17,r2,255
8112f6ec:	8c40201c 	xori	r17,r17,128
8112f6f0:	8c7fe004 	addi	r17,r17,-128
8112f6f4:	8009883a 	mov	r4,r16
8112f6f8:	112d6dc0 	call	8112d6dc <_localeconv_r>
8112f6fc:	11400017 	ldw	r5,0(r2)
8112f700:	8009883a 	mov	r4,r16
8112f704:	d9401315 	stw	r5,76(sp)
8112f708:	112d6dc0 	call	8112d6dc <_localeconv_r>
8112f70c:	11000017 	ldw	r4,0(r2)
8112f710:	11244bc0 	call	811244bc <strlen>
8112f714:	d9401317 	ldw	r5,76(sp)
8112f718:	100d883a 	mov	r6,r2
8112f71c:	a809883a 	mov	r4,r21
8112f720:	11350ac0 	call	811350ac <strncmp>
8112f724:	1000ce26 	beq	r2,zero,8112fa60 <_strtod_r+0x5a4>
8112f728:	b013883a 	mov	r9,r22
8112f72c:	000b883a 	mov	r5,zero
8112f730:	0015883a 	mov	r10,zero
8112f734:	0017883a 	mov	r11,zero
8112f738:	00801944 	movi	r2,101
8112f73c:	88807826 	beq	r17,r2,8112f920 <_strtod_r+0x464>
8112f740:	00801144 	movi	r2,69
8112f744:	88807626 	beq	r17,r2,8112f920 <_strtod_r+0x464>
8112f748:	002b883a 	mov	r21,zero
8112f74c:	48003d1e 	bne	r9,zero,8112f844 <_strtod_r+0x388>
8112f750:	2800391e 	bne	r5,zero,8112f838 <_strtod_r+0x37c>
8112f754:	9000381e 	bne	r18,zero,8112f838 <_strtod_r+0x37c>
8112f758:	583fa71e 	bne	r11,zero,8112f5f8 <__reset+0xfb10f5f8>
8112f75c:	00801384 	movi	r2,78
8112f760:	88800526 	beq	r17,r2,8112f778 <_strtod_r+0x2bc>
8112f764:	147fa20e 	bge	r2,r17,8112f5f0 <__reset+0xfb10f5f0>
8112f768:	00801a44 	movi	r2,105
8112f76c:	8883d726 	beq	r17,r2,811306cc <_strtod_r+0x1210>
8112f770:	00801b84 	movi	r2,110
8112f774:	88bfa01e 	bne	r17,r2,8112f5f8 <__reset+0xfb10f5f8>
8112f778:	01604574 	movhi	r5,33045
8112f77c:	d9000617 	ldw	r4,24(sp)
8112f780:	2947b904 	addi	r5,r5,7908
8112f784:	01c00644 	movi	r7,25
8112f788:	00000b06 	br	8112f7b8 <_strtod_r+0x2fc>
8112f78c:	21000044 	addi	r4,r4,1
8112f790:	20800003 	ldbu	r2,0(r4)
8112f794:	10ffefc4 	addi	r3,r2,-65
8112f798:	10803fcc 	andi	r2,r2,255
8112f79c:	1080201c 	xori	r2,r2,128
8112f7a0:	18c03fcc 	andi	r3,r3,255
8112f7a4:	10bfe004 	addi	r2,r2,-128
8112f7a8:	38c00136 	bltu	r7,r3,8112f7b0 <_strtod_r+0x2f4>
8112f7ac:	10800804 	addi	r2,r2,32
8112f7b0:	29400044 	addi	r5,r5,1
8112f7b4:	11bf901e 	bne	r2,r6,8112f5f8 <__reset+0xfb10f5f8>
8112f7b8:	29800007 	ldb	r6,0(r5)
8112f7bc:	303ff31e 	bne	r6,zero,8112f78c <__reset+0xfb10f78c>
8112f7c0:	20800044 	addi	r2,r4,1
8112f7c4:	d8800615 	stw	r2,24(sp)
8112f7c8:	20c00047 	ldb	r3,1(r4)
8112f7cc:	00800a04 	movi	r2,40
8112f7d0:	18849d26 	beq	r3,r2,81130a48 <_strtod_r+0x158c>
8112f7d4:	047ffe34 	movhi	r17,65528
8112f7d8:	0025883a 	mov	r18,zero
8112f7dc:	902b883a 	mov	r21,r18
8112f7e0:	882d883a 	mov	r22,r17
8112f7e4:	a03f8926 	beq	r20,zero,8112f60c <__reset+0xfb10f60c>
8112f7e8:	ddc00617 	ldw	r23,24(sp)
8112f7ec:	003f8606 	br	8112f608 <__reset+0xfb10f608>
8112f7f0:	00800044 	movi	r2,1
8112f7f4:	d8800715 	stw	r2,28(sp)
8112f7f8:	003f9606 	br	8112f654 <__reset+0xfb10f654>
8112f7fc:	21000044 	addi	r4,r4,1
8112f800:	d9000615 	stw	r4,24(sp)
8112f804:	20800003 	ldbu	r2,0(r4)
8112f808:	10c03fcc 	andi	r3,r2,255
8112f80c:	28ff462e 	bgeu	r5,r3,8112f528 <__reset+0xfb10f528>
8112f810:	2027883a 	mov	r19,r4
8112f814:	d8000715 	stw	zero,28(sp)
8112f818:	003f9506 	br	8112f670 <__reset+0xfb10f670>
8112f81c:	9cc002a4 	muli	r19,r19,10
8112f820:	10803fcc 	andi	r2,r2,255
8112f824:	1080201c 	xori	r2,r2,128
8112f828:	10bfe004 	addi	r2,r2,-128
8112f82c:	9885883a 	add	r2,r19,r2
8112f830:	14fff404 	addi	r19,r2,-48
8112f834:	003fa506 	br	8112f6cc <__reset+0xfb10f6cc>
8112f838:	002b883a 	mov	r21,zero
8112f83c:	002d883a 	mov	r22,zero
8112f840:	003fe806 	br	8112f7e4 <__reset+0xfb10f7e4>
8112f844:	aaabc83a 	sub	r21,r21,r10
8112f848:	b000011e 	bne	r22,zero,8112f850 <_strtod_r+0x394>
8112f84c:	482d883a 	mov	r22,r9
8112f850:	00800404 	movi	r2,16
8112f854:	482f883a 	mov	r23,r9
8112f858:	1240010e 	bge	r2,r9,8112f860 <_strtod_r+0x3a4>
8112f85c:	102f883a 	mov	r23,r2
8112f860:	e009883a 	mov	r4,fp
8112f864:	da401315 	stw	r9,76(sp)
8112f868:	113750c0 	call	8113750c <__floatunsidf>
8112f86c:	1025883a 	mov	r18,r2
8112f870:	00800244 	movi	r2,9
8112f874:	1823883a 	mov	r17,r3
8112f878:	da401317 	ldw	r9,76(sp)
8112f87c:	15c0160e 	bge	r2,r23,8112f8d8 <_strtod_r+0x41c>
8112f880:	b8bffdc4 	addi	r2,r23,-9
8112f884:	100490fa 	slli	r2,r2,3
8112f888:	180b883a 	mov	r5,r3
8112f88c:	00e04574 	movhi	r3,33045
8112f890:	18c78404 	addi	r3,r3,7696
8112f894:	1885883a 	add	r2,r3,r2
8112f898:	11800017 	ldw	r6,0(r2)
8112f89c:	11c00117 	ldw	r7,4(r2)
8112f8a0:	9009883a 	mov	r4,r18
8112f8a4:	112138c0 	call	8112138c <__muldf3>
8112f8a8:	9809883a 	mov	r4,r19
8112f8ac:	1025883a 	mov	r18,r2
8112f8b0:	1823883a 	mov	r17,r3
8112f8b4:	113750c0 	call	8113750c <__floatunsidf>
8112f8b8:	9009883a 	mov	r4,r18
8112f8bc:	880b883a 	mov	r5,r17
8112f8c0:	100d883a 	mov	r6,r2
8112f8c4:	180f883a 	mov	r7,r3
8112f8c8:	11361ec0 	call	811361ec <__adddf3>
8112f8cc:	da401317 	ldw	r9,76(sp)
8112f8d0:	1025883a 	mov	r18,r2
8112f8d4:	1823883a 	mov	r17,r3
8112f8d8:	008003c4 	movi	r2,15
8112f8dc:	12407b16 	blt	r2,r9,8112facc <_strtod_r+0x610>
8112f8e0:	a83fbe26 	beq	r21,zero,8112f7dc <__reset+0xfb10f7dc>
8112f8e4:	0543670e 	bge	zero,r21,81130684 <_strtod_r+0x11c8>
8112f8e8:	00c00584 	movi	r3,22
8112f8ec:	1d42e816 	blt	r3,r21,81130490 <_strtod_r+0xfd4>
8112f8f0:	a82a90fa 	slli	r21,r21,3
8112f8f4:	00a04574 	movhi	r2,33045
8112f8f8:	10878404 	addi	r2,r2,7696
8112f8fc:	1545883a 	add	r2,r2,r21
8112f900:	11000017 	ldw	r4,0(r2)
8112f904:	11400117 	ldw	r5,4(r2)
8112f908:	900d883a 	mov	r6,r18
8112f90c:	880f883a 	mov	r7,r17
8112f910:	112138c0 	call	8112138c <__muldf3>
8112f914:	102b883a 	mov	r21,r2
8112f918:	182d883a 	mov	r22,r3
8112f91c:	003fb106 	br	8112f7e4 <__reset+0xfb10f7e4>
8112f920:	4801b526 	beq	r9,zero,8112fff8 <_strtod_r+0xb3c>
8112f924:	ddc00617 	ldw	r23,24(sp)
8112f928:	00c00ac4 	movi	r3,43
8112f92c:	b8800044 	addi	r2,r23,1
8112f930:	d8800615 	stw	r2,24(sp)
8112f934:	b8800047 	ldb	r2,1(r23)
8112f938:	10c1e926 	beq	r2,r3,811300e0 <_strtod_r+0xc24>
8112f93c:	00c00b44 	movi	r3,45
8112f940:	10c1ec26 	beq	r2,r3,811300f4 <_strtod_r+0xc38>
8112f944:	1023883a 	mov	r17,r2
8112f948:	0019883a 	mov	r12,zero
8112f94c:	88bff404 	addi	r2,r17,-48
8112f950:	00c00244 	movi	r3,9
8112f954:	1881b736 	bltu	r3,r2,81130034 <_strtod_r+0xb78>
8112f958:	00800c04 	movi	r2,48
8112f95c:	8880071e 	bne	r17,r2,8112f97c <_strtod_r+0x4c0>
8112f960:	d8800617 	ldw	r2,24(sp)
8112f964:	8807883a 	mov	r3,r17
8112f968:	10800044 	addi	r2,r2,1
8112f96c:	d8800615 	stw	r2,24(sp)
8112f970:	14400007 	ldb	r17,0(r2)
8112f974:	10800044 	addi	r2,r2,1
8112f978:	88fffc26 	beq	r17,r3,8112f96c <__reset+0xfb10f96c>
8112f97c:	88bff3c4 	addi	r2,r17,-49
8112f980:	00c00204 	movi	r3,8
8112f984:	18bf7036 	bltu	r3,r2,8112f748 <__reset+0xfb10f748>
8112f988:	db800617 	ldw	r14,24(sp)
8112f98c:	88bff404 	addi	r2,r17,-48
8112f990:	03400244 	movi	r13,9
8112f994:	71c00044 	addi	r7,r14,1
8112f998:	d9c00615 	stw	r7,24(sp)
8112f99c:	74400043 	ldbu	r17,1(r14)
8112f9a0:	88fff404 	addi	r3,r17,-48
8112f9a4:	8c403fcc 	andi	r17,r17,255
8112f9a8:	8c40201c 	xori	r17,r17,128
8112f9ac:	18c03fcc 	andi	r3,r3,255
8112f9b0:	8c7fe004 	addi	r17,r17,-128
8112f9b4:	68c00e36 	bltu	r13,r3,8112f9f0 <_strtod_r+0x534>
8112f9b8:	71000084 	addi	r4,r14,2
8112f9bc:	d9000615 	stw	r4,24(sp)
8112f9c0:	108002a4 	muli	r2,r2,10
8112f9c4:	21800003 	ldbu	r6,0(r4)
8112f9c8:	200f883a 	mov	r7,r4
8112f9cc:	1463883a 	add	r17,r2,r17
8112f9d0:	30fff404 	addi	r3,r6,-48
8112f9d4:	88bff404 	addi	r2,r17,-48
8112f9d8:	34403fcc 	andi	r17,r6,255
8112f9dc:	8c40201c 	xori	r17,r17,128
8112f9e0:	18c03fcc 	andi	r3,r3,255
8112f9e4:	8c7fe004 	addi	r17,r17,-128
8112f9e8:	21000044 	addi	r4,r4,1
8112f9ec:	68fff32e 	bgeu	r13,r3,8112f9bc <__reset+0xfb10f9bc>
8112f9f0:	3b8fc83a 	sub	r7,r7,r14
8112f9f4:	00c00204 	movi	r3,8
8112f9f8:	19c29716 	blt	r3,r7,81130458 <_strtod_r+0xf9c>
8112f9fc:	102b883a 	mov	r21,r2
8112fa00:	009387c4 	movi	r2,19999
8112fa04:	1540010e 	bge	r2,r21,8112fa0c <_strtod_r+0x550>
8112fa08:	102b883a 	mov	r21,r2
8112fa0c:	603f4f26 	beq	r12,zero,8112f74c <__reset+0xfb10f74c>
8112fa10:	056bc83a 	sub	r21,zero,r21
8112fa14:	003f4d06 	br	8112f74c <__reset+0xfb10f74c>
8112fa18:	98800047 	ldb	r2,1(r19)
8112fa1c:	00c01604 	movi	r3,88
8112fa20:	10c1de26 	beq	r2,r3,8113019c <_strtod_r+0xce0>
8112fa24:	00c01e04 	movi	r3,120
8112fa28:	10c1dc26 	beq	r2,r3,8113019c <_strtod_r+0xce0>
8112fa2c:	98c00044 	addi	r3,r19,1
8112fa30:	1827883a 	mov	r19,r3
8112fa34:	d8c00615 	stw	r3,24(sp)
8112fa38:	18c00044 	addi	r3,r3,1
8112fa3c:	18bfffc3 	ldbu	r2,-1(r3)
8112fa40:	11003fcc 	andi	r4,r2,255
8112fa44:	2100201c 	xori	r4,r4,128
8112fa48:	213fe004 	addi	r4,r4,-128
8112fa4c:	217ff826 	beq	r4,r5,8112fa30 <__reset+0xfb10fa30>
8112fa50:	203f7926 	beq	r4,zero,8112f838 <__reset+0xfb10f838>
8112fa54:	dcc00815 	stw	r19,32(sp)
8112fa58:	04800044 	movi	r18,1
8112fa5c:	003f0b06 	br	8112f68c <__reset+0xfb10f68c>
8112fa60:	8009883a 	mov	r4,r16
8112fa64:	112d6dc0 	call	8112d6dc <_localeconv_r>
8112fa68:	11000017 	ldw	r4,0(r2)
8112fa6c:	11244bc0 	call	811244bc <strlen>
8112fa70:	d8c00617 	ldw	r3,24(sp)
8112fa74:	1885883a 	add	r2,r3,r2
8112fa78:	d8800615 	stw	r2,24(sp)
8112fa7c:	14400007 	ldb	r17,0(r2)
8112fa80:	b001881e 	bne	r22,zero,811300a4 <_strtod_r+0xbe8>
8112fa84:	00c00c04 	movi	r3,48
8112fa88:	88c3391e 	bne	r17,r3,81130770 <_strtod_r+0x12b4>
8112fa8c:	10c00044 	addi	r3,r2,1
8112fa90:	8809883a 	mov	r4,r17
8112fa94:	d8c00615 	stw	r3,24(sp)
8112fa98:	1c400007 	ldb	r17,0(r3)
8112fa9c:	188bc83a 	sub	r5,r3,r2
8112faa0:	18c00044 	addi	r3,r3,1
8112faa4:	893ffb26 	beq	r17,r4,8112fa94 <__reset+0xfb10fa94>
8112faa8:	88bff3c4 	addi	r2,r17,-49
8112faac:	00c00204 	movi	r3,8
8112fab0:	1882e72e 	bgeu	r3,r2,81130650 <_strtod_r+0x1194>
8112fab4:	00801944 	movi	r2,101
8112fab8:	88814d26 	beq	r17,r2,8112fff0 <_strtod_r+0xb34>
8112fabc:	0013883a 	mov	r9,zero
8112fac0:	0015883a 	mov	r10,zero
8112fac4:	02c00044 	movi	r11,1
8112fac8:	003f1d06 	br	8112f740 <__reset+0xfb10f740>
8112facc:	4defc83a 	sub	r23,r9,r23
8112fad0:	bd6f883a 	add	r23,r23,r21
8112fad4:	05c21e0e 	bge	zero,r23,81130350 <_strtod_r+0xe94>
8112fad8:	b88003cc 	andi	r2,r23,15
8112fadc:	10000d26 	beq	r2,zero,8112fb14 <_strtod_r+0x658>
8112fae0:	100490fa 	slli	r2,r2,3
8112fae4:	00e04574 	movhi	r3,33045
8112fae8:	18c78404 	addi	r3,r3,7696
8112faec:	1885883a 	add	r2,r3,r2
8112faf0:	11000017 	ldw	r4,0(r2)
8112faf4:	11400117 	ldw	r5,4(r2)
8112faf8:	900d883a 	mov	r6,r18
8112fafc:	880f883a 	mov	r7,r17
8112fb00:	da401315 	stw	r9,76(sp)
8112fb04:	112138c0 	call	8112138c <__muldf3>
8112fb08:	da401317 	ldw	r9,76(sp)
8112fb0c:	1025883a 	mov	r18,r2
8112fb10:	1823883a 	mov	r17,r3
8112fb14:	023ffc04 	movi	r8,-16
8112fb18:	ba10703a 	and	r8,r23,r8
8112fb1c:	40003c26 	beq	r8,zero,8112fc10 <_strtod_r+0x754>
8112fb20:	00804d04 	movi	r2,308
8112fb24:	1201cd16 	blt	r2,r8,8113025c <_strtod_r+0xda0>
8112fb28:	4011d13a 	srai	r8,r8,4
8112fb2c:	03000044 	movi	r12,1
8112fb30:	62037c0e 	bge	r12,r8,81130924 <_strtod_r+0x1468>
8112fb34:	01204574 	movhi	r4,33045
8112fb38:	21077a04 	addi	r4,r4,7656
8112fb3c:	2015883a 	mov	r10,r4
8112fb40:	0027883a 	mov	r19,zero
8112fb44:	d9000915 	stw	r4,36(sp)
8112fb48:	9005883a 	mov	r2,r18
8112fb4c:	8807883a 	mov	r3,r17
8112fb50:	dc000c15 	stw	r16,48(sp)
8112fb54:	dc800e15 	stw	r18,56(sp)
8112fb58:	9821883a 	mov	r16,r19
8112fb5c:	0009883a 	mov	r4,zero
8112fb60:	8827883a 	mov	r19,r17
8112fb64:	602f883a 	mov	r23,r12
8112fb68:	da400a15 	stw	r9,40(sp)
8112fb6c:	5025883a 	mov	r18,r10
8112fb70:	4023883a 	mov	r17,r8
8112fb74:	8980004c 	andi	r6,r17,1
8112fb78:	30000626 	beq	r6,zero,8112fb94 <_strtod_r+0x6d8>
8112fb7c:	91800017 	ldw	r6,0(r18)
8112fb80:	91c00117 	ldw	r7,4(r18)
8112fb84:	1009883a 	mov	r4,r2
8112fb88:	180b883a 	mov	r5,r3
8112fb8c:	112138c0 	call	8112138c <__muldf3>
8112fb90:	01000044 	movi	r4,1
8112fb94:	8823d07a 	srai	r17,r17,1
8112fb98:	84000044 	addi	r16,r16,1
8112fb9c:	94800204 	addi	r18,r18,8
8112fba0:	8dfff41e 	bne	r17,r23,8112fb74 <__reset+0xfb10fb74>
8112fba4:	21003fcc 	andi	r4,r4,255
8112fba8:	9823883a 	mov	r17,r19
8112fbac:	da400a17 	ldw	r9,40(sp)
8112fbb0:	8027883a 	mov	r19,r16
8112fbb4:	dc800e17 	ldw	r18,56(sp)
8112fbb8:	dc000c17 	ldw	r16,48(sp)
8112fbbc:	2003b11e 	bne	r4,zero,81130a84 <_strtod_r+0x15c8>
8112fbc0:	981690fa 	slli	r11,r19,3
8112fbc4:	d8800917 	ldw	r2,36(sp)
8112fbc8:	01ff2c34 	movhi	r7,64688
8112fbcc:	900d883a 	mov	r6,r18
8112fbd0:	12ef883a 	add	r23,r2,r11
8112fbd4:	b9000017 	ldw	r4,0(r23)
8112fbd8:	b9400117 	ldw	r5,4(r23)
8112fbdc:	89cf883a 	add	r7,r17,r7
8112fbe0:	da401315 	stw	r9,76(sp)
8112fbe4:	112138c0 	call	8112138c <__muldf3>
8112fbe8:	1025883a 	mov	r18,r2
8112fbec:	011f2834 	movhi	r4,31904
8112fbf0:	189ffc2c 	andhi	r2,r3,32752
8112fbf4:	da401317 	ldw	r9,76(sp)
8112fbf8:	20819836 	bltu	r4,r2,8113025c <_strtod_r+0xda0>
8112fbfc:	011f2434 	movhi	r4,31888
8112fc00:	2083382e 	bgeu	r4,r2,811308e4 <_strtod_r+0x1428>
8112fc04:	045ffc34 	movhi	r17,32752
8112fc08:	8c7fffc4 	addi	r17,r17,-1
8112fc0c:	04bfffc4 	movi	r18,-1
8112fc10:	d8000915 	stw	zero,36(sp)
8112fc14:	d9400817 	ldw	r5,32(sp)
8112fc18:	df000015 	stw	fp,0(sp)
8112fc1c:	480f883a 	mov	r7,r9
8112fc20:	b00d883a 	mov	r6,r22
8112fc24:	8009883a 	mov	r4,r16
8112fc28:	112ddf80 	call	8112ddf8 <__s2b>
8112fc2c:	d8800815 	stw	r2,32(sp)
8112fc30:	10018a26 	beq	r2,zero,8113025c <_strtod_r+0xda0>
8112fc34:	a807d7fa 	srai	r3,r21,31
8112fc38:	0545c83a 	sub	r2,zero,r21
8112fc3c:	dd400a15 	stw	r21,40(sp)
8112fc40:	1886703a 	and	r3,r3,r2
8112fc44:	d8c00c15 	stw	r3,48(sp)
8112fc48:	a8013516 	blt	r21,zero,81130120 <_strtod_r+0xc64>
8112fc4c:	d9400817 	ldw	r5,32(sp)
8112fc50:	0011883a 	mov	r8,zero
8112fc54:	0027883a 	mov	r19,zero
8112fc58:	29400304 	addi	r5,r5,12
8112fc5c:	d9400f15 	stw	r5,60(sp)
8112fc60:	402b883a 	mov	r21,r8
8112fc64:	dd001215 	stw	r20,72(sp)
8112fc68:	d8800817 	ldw	r2,32(sp)
8112fc6c:	8009883a 	mov	r4,r16
8112fc70:	11400117 	ldw	r5,4(r2)
8112fc74:	112dbf80 	call	8112dbf8 <_Balloc>
8112fc78:	1029883a 	mov	r20,r2
8112fc7c:	10012d26 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fc80:	d8c00817 	ldw	r3,32(sp)
8112fc84:	d9400f17 	ldw	r5,60(sp)
8112fc88:	11000304 	addi	r4,r2,12
8112fc8c:	19800417 	ldw	r6,16(r3)
8112fc90:	31800084 	addi	r6,r6,2
8112fc94:	318d883a 	add	r6,r6,r6
8112fc98:	318d883a 	add	r6,r6,r6
8112fc9c:	1123a440 	call	81123a44 <memcpy>
8112fca0:	d9000204 	addi	r4,sp,8
8112fca4:	d9000015 	stw	r4,0(sp)
8112fca8:	d9c00404 	addi	r7,sp,16
8112fcac:	900b883a 	mov	r5,r18
8112fcb0:	880d883a 	mov	r6,r17
8112fcb4:	8009883a 	mov	r4,r16
8112fcb8:	112e8d40 	call	8112e8d4 <__d2b>
8112fcbc:	d8800515 	stw	r2,20(sp)
8112fcc0:	dc801115 	stw	r18,68(sp)
8112fcc4:	dc401015 	stw	r17,64(sp)
8112fcc8:	10027c26 	beq	r2,zero,811306bc <_strtod_r+0x1200>
8112fccc:	01400044 	movi	r5,1
8112fcd0:	8009883a 	mov	r4,r16
8112fcd4:	112e01c0 	call	8112e01c <__i2b>
8112fcd8:	1027883a 	mov	r19,r2
8112fcdc:	10011526 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fce0:	d8800417 	ldw	r2,16(sp)
8112fce4:	1000c816 	blt	r2,zero,81130008 <_strtod_r+0xb4c>
8112fce8:	d9400c17 	ldw	r5,48(sp)
8112fcec:	d9000a17 	ldw	r4,40(sp)
8112fcf0:	28ad883a 	add	r22,r5,r2
8112fcf4:	d9400917 	ldw	r5,36(sp)
8112fcf8:	df000217 	ldw	fp,8(sp)
8112fcfc:	05ff0084 	movi	r23,-1022
8112fd00:	1147c83a 	sub	r3,r2,r5
8112fd04:	1f07883a 	add	r3,r3,fp
8112fd08:	00800d84 	movi	r2,54
8112fd0c:	18ffffc4 	addi	r3,r3,-1
8112fd10:	1739c83a 	sub	fp,r2,fp
8112fd14:	1dc0a50e 	bge	r3,r23,8112ffac <_strtod_r+0xaf0>
8112fd18:	b8efc83a 	sub	r23,r23,r3
8112fd1c:	008007c4 	movi	r2,31
8112fd20:	e5f9c83a 	sub	fp,fp,r23
8112fd24:	15c0bc16 	blt	r2,r23,81130018 <_strtod_r+0xb5c>
8112fd28:	00800044 	movi	r2,1
8112fd2c:	15c4983a 	sll	r2,r2,r23
8112fd30:	d8000b15 	stw	zero,44(sp)
8112fd34:	d8800d15 	stw	r2,52(sp)
8112fd38:	2707883a 	add	r3,r4,fp
8112fd3c:	d9000917 	ldw	r4,36(sp)
8112fd40:	b739883a 	add	fp,r22,fp
8112fd44:	20ef883a 	add	r23,r4,r3
8112fd48:	b009883a 	mov	r4,r22
8112fd4c:	e580010e 	bge	fp,r22,8112fd54 <_strtod_r+0x898>
8112fd50:	e009883a 	mov	r4,fp
8112fd54:	b805883a 	mov	r2,r23
8112fd58:	25c0010e 	bge	r4,r23,8112fd60 <_strtod_r+0x8a4>
8112fd5c:	2005883a 	mov	r2,r4
8112fd60:	0080030e 	bge	zero,r2,8112fd70 <_strtod_r+0x8b4>
8112fd64:	e0b9c83a 	sub	fp,fp,r2
8112fd68:	b8afc83a 	sub	r23,r23,r2
8112fd6c:	b0adc83a 	sub	r22,r22,r2
8112fd70:	d9400c17 	ldw	r5,48(sp)
8112fd74:	28001126 	beq	r5,zero,8112fdbc <_strtod_r+0x900>
8112fd78:	280d883a 	mov	r6,r5
8112fd7c:	8009883a 	mov	r4,r16
8112fd80:	980b883a 	mov	r5,r19
8112fd84:	112e2600 	call	8112e260 <__pow5mult>
8112fd88:	1027883a 	mov	r19,r2
8112fd8c:	1000e926 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fd90:	d9800517 	ldw	r6,20(sp)
8112fd94:	100b883a 	mov	r5,r2
8112fd98:	8009883a 	mov	r4,r16
8112fd9c:	112e0600 	call	8112e060 <__multiply>
8112fda0:	1000e426 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fda4:	d9400517 	ldw	r5,20(sp)
8112fda8:	8009883a 	mov	r4,r16
8112fdac:	d8801315 	stw	r2,76(sp)
8112fdb0:	112dca80 	call	8112dca8 <_Bfree>
8112fdb4:	d8801317 	ldw	r2,76(sp)
8112fdb8:	d8800515 	stw	r2,20(sp)
8112fdbc:	0700060e 	bge	zero,fp,8112fdd8 <_strtod_r+0x91c>
8112fdc0:	d9400517 	ldw	r5,20(sp)
8112fdc4:	e00d883a 	mov	r6,fp
8112fdc8:	8009883a 	mov	r4,r16
8112fdcc:	112e3a80 	call	8112e3a8 <__lshift>
8112fdd0:	d8800515 	stw	r2,20(sp)
8112fdd4:	10023926 	beq	r2,zero,811306bc <_strtod_r+0x1200>
8112fdd8:	d8800a17 	ldw	r2,40(sp)
8112fddc:	10000626 	beq	r2,zero,8112fdf8 <_strtod_r+0x93c>
8112fde0:	d9800a17 	ldw	r6,40(sp)
8112fde4:	a00b883a 	mov	r5,r20
8112fde8:	8009883a 	mov	r4,r16
8112fdec:	112e2600 	call	8112e260 <__pow5mult>
8112fdf0:	1029883a 	mov	r20,r2
8112fdf4:	1000cf26 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fdf8:	05c0060e 	bge	zero,r23,8112fe14 <_strtod_r+0x958>
8112fdfc:	a00b883a 	mov	r5,r20
8112fe00:	b80d883a 	mov	r6,r23
8112fe04:	8009883a 	mov	r4,r16
8112fe08:	112e3a80 	call	8112e3a8 <__lshift>
8112fe0c:	1029883a 	mov	r20,r2
8112fe10:	1000c826 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fe14:	0580060e 	bge	zero,r22,8112fe30 <_strtod_r+0x974>
8112fe18:	980b883a 	mov	r5,r19
8112fe1c:	b00d883a 	mov	r6,r22
8112fe20:	8009883a 	mov	r4,r16
8112fe24:	112e3a80 	call	8112e3a8 <__lshift>
8112fe28:	1027883a 	mov	r19,r2
8112fe2c:	1000c126 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fe30:	d9400517 	ldw	r5,20(sp)
8112fe34:	a00d883a 	mov	r6,r20
8112fe38:	8009883a 	mov	r4,r16
8112fe3c:	112e5580 	call	8112e558 <__mdiff>
8112fe40:	102b883a 	mov	r21,r2
8112fe44:	1000bb26 	beq	r2,zero,81130134 <_strtod_r+0xc78>
8112fe48:	10c00317 	ldw	r3,12(r2)
8112fe4c:	980b883a 	mov	r5,r19
8112fe50:	10000315 	stw	zero,12(r2)
8112fe54:	1009883a 	mov	r4,r2
8112fe58:	d8c00e15 	stw	r3,56(sp)
8112fe5c:	112e4f80 	call	8112e4f8 <__mcmp>
8112fe60:	10027616 	blt	r2,zero,8113083c <_strtod_r+0x1380>
8112fe64:	10024426 	beq	r2,zero,81130778 <_strtod_r+0x12bc>
8112fe68:	980b883a 	mov	r5,r19
8112fe6c:	a809883a 	mov	r4,r21
8112fe70:	112ea280 	call	8112ea28 <__ratio>
8112fe74:	000d883a 	mov	r6,zero
8112fe78:	01d00034 	movhi	r7,16384
8112fe7c:	1009883a 	mov	r4,r2
8112fe80:	180b883a 	mov	r5,r3
8112fe84:	102f883a 	mov	r23,r2
8112fe88:	182d883a 	mov	r22,r3
8112fe8c:	11374180 	call	81137418 <__ledf2>
8112fe90:	00804a16 	blt	zero,r2,8112ffbc <_strtod_r+0xb00>
8112fe94:	d9400e17 	ldw	r5,56(sp)
8112fe98:	28006b26 	beq	r5,zero,81130048 <_strtod_r+0xb8c>
8112fe9c:	058ffc34 	movhi	r22,16368
8112fea0:	d8000b15 	stw	zero,44(sp)
8112fea4:	d8000d15 	stw	zero,52(sp)
8112fea8:	b02f883a 	mov	r23,r22
8112feac:	8f1ffc2c 	andhi	fp,r17,32752
8112feb0:	009ff834 	movhi	r2,32736
8112feb4:	e080cd26 	beq	fp,r2,811301ec <_strtod_r+0xd30>
8112feb8:	d9400917 	ldw	r5,36(sp)
8112febc:	28001a26 	beq	r5,zero,8112ff28 <_strtod_r+0xa6c>
8112fec0:	0081a834 	movhi	r2,1696
8112fec4:	17001836 	bltu	r2,fp,8112ff28 <_strtod_r+0xa6c>
8112fec8:	d9000d17 	ldw	r4,52(sp)
8112fecc:	01d07834 	movhi	r7,16864
8112fed0:	39ffffc4 	addi	r7,r7,-1
8112fed4:	01bff034 	movhi	r6,65472
8112fed8:	b80b883a 	mov	r5,r23
8112fedc:	11374180 	call	81137418 <__ledf2>
8112fee0:	00800e16 	blt	zero,r2,8112ff1c <_strtod_r+0xa60>
8112fee4:	d9000d17 	ldw	r4,52(sp)
8112fee8:	b80b883a 	mov	r5,r23
8112feec:	11207c40 	call	811207c4 <__fixunsdfsi>
8112fef0:	10018126 	beq	r2,zero,811304f8 <_strtod_r+0x103c>
8112fef4:	1009883a 	mov	r4,r2
8112fef8:	113750c0 	call	8113750c <__floatunsidf>
8112fefc:	d8800d15 	stw	r2,52(sp)
8112ff00:	182f883a 	mov	r23,r3
8112ff04:	d8800e17 	ldw	r2,56(sp)
8112ff08:	1001791e 	bne	r2,zero,811304f0 <_strtod_r+0x1034>
8112ff0c:	ba20003c 	xorhi	r8,r23,32768
8112ff10:	d8c00d17 	ldw	r3,52(sp)
8112ff14:	402d883a 	mov	r22,r8
8112ff18:	d8c00b15 	stw	r3,44(sp)
8112ff1c:	0081ac34 	movhi	r2,1712
8112ff20:	b091883a 	add	r8,r22,r2
8112ff24:	472dc83a 	sub	r22,r8,fp
8112ff28:	9009883a 	mov	r4,r18
8112ff2c:	880b883a 	mov	r5,r17
8112ff30:	112e75c0 	call	8112e75c <__ulp>
8112ff34:	d9000b17 	ldw	r4,44(sp)
8112ff38:	b00b883a 	mov	r5,r22
8112ff3c:	100d883a 	mov	r6,r2
8112ff40:	180f883a 	mov	r7,r3
8112ff44:	112138c0 	call	8112138c <__muldf3>
8112ff48:	900d883a 	mov	r6,r18
8112ff4c:	880f883a 	mov	r7,r17
8112ff50:	1009883a 	mov	r4,r2
8112ff54:	180b883a 	mov	r5,r3
8112ff58:	11361ec0 	call	811361ec <__adddf3>
8112ff5c:	1025883a 	mov	r18,r2
8112ff60:	1823883a 	mov	r17,r3
8112ff64:	182d883a 	mov	r22,r3
8112ff68:	d9000917 	ldw	r4,36(sp)
8112ff6c:	2000021e 	bne	r4,zero,8112ff78 <_strtod_r+0xabc>
8112ff70:	b09ffc2c 	andhi	r2,r22,32752
8112ff74:	e080be26 	beq	fp,r2,81130270 <_strtod_r+0xdb4>
8112ff78:	d9400517 	ldw	r5,20(sp)
8112ff7c:	8009883a 	mov	r4,r16
8112ff80:	112dca80 	call	8112dca8 <_Bfree>
8112ff84:	a00b883a 	mov	r5,r20
8112ff88:	8009883a 	mov	r4,r16
8112ff8c:	112dca80 	call	8112dca8 <_Bfree>
8112ff90:	980b883a 	mov	r5,r19
8112ff94:	8009883a 	mov	r4,r16
8112ff98:	112dca80 	call	8112dca8 <_Bfree>
8112ff9c:	a80b883a 	mov	r5,r21
8112ffa0:	8009883a 	mov	r4,r16
8112ffa4:	112dca80 	call	8112dca8 <_Bfree>
8112ffa8:	003f2f06 	br	8112fc68 <__reset+0xfb10fc68>
8112ffac:	00c00044 	movi	r3,1
8112ffb0:	d8000b15 	stw	zero,44(sp)
8112ffb4:	d8c00d15 	stw	r3,52(sp)
8112ffb8:	003f5f06 	br	8112fd38 <__reset+0xfb10fd38>
8112ffbc:	b809883a 	mov	r4,r23
8112ffc0:	000d883a 	mov	r6,zero
8112ffc4:	01cff834 	movhi	r7,16352
8112ffc8:	b00b883a 	mov	r5,r22
8112ffcc:	112138c0 	call	8112138c <__muldf3>
8112ffd0:	d9000e17 	ldw	r4,56(sp)
8112ffd4:	d8800d15 	stw	r2,52(sp)
8112ffd8:	182f883a 	mov	r23,r3
8112ffdc:	2000181e 	bne	r4,zero,81130040 <_strtod_r+0xb84>
8112ffe0:	1a20003c 	xorhi	r8,r3,32768
8112ffe4:	d8800b15 	stw	r2,44(sp)
8112ffe8:	402d883a 	mov	r22,r8
8112ffec:	003faf06 	br	8112feac <__reset+0xfb10feac>
8112fff0:	0015883a 	mov	r10,zero
8112fff4:	02c00044 	movi	r11,1
8112fff8:	2800011e 	bne	r5,zero,81130000 <_strtod_r+0xb44>
8112fffc:	903d7e26 	beq	r18,zero,8112f5f8 <__reset+0xfb10f5f8>
81130000:	0013883a 	mov	r9,zero
81130004:	003e4706 	br	8112f924 <__reset+0xfb10f924>
81130008:	d8c00a17 	ldw	r3,40(sp)
8113000c:	dd800c17 	ldw	r22,48(sp)
81130010:	1889c83a 	sub	r4,r3,r2
81130014:	003f3706 	br	8112fcf4 <__reset+0xfb10fcf4>
81130018:	00bef884 	movi	r2,-1054
8113001c:	05c00044 	movi	r23,1
81130020:	10c5c83a 	sub	r2,r2,r3
81130024:	b884983a 	sll	r2,r23,r2
81130028:	ddc00d15 	stw	r23,52(sp)
8113002c:	d8800b15 	stw	r2,44(sp)
81130030:	003f4106 	br	8112fd38 <__reset+0xfb10fd38>
81130034:	ddc00615 	stw	r23,24(sp)
81130038:	002b883a 	mov	r21,zero
8113003c:	003dc306 	br	8112f74c <__reset+0xfb10f74c>
81130040:	1811883a 	mov	r8,r3
81130044:	003fe706 	br	8112ffe4 <__reset+0xfb10ffe4>
81130048:	90002e1e 	bne	r18,zero,81130104 <_strtod_r+0xc48>
8113004c:	00c00434 	movhi	r3,16
81130050:	18ffffc4 	addi	r3,r3,-1
81130054:	88c4703a 	and	r2,r17,r3
81130058:	10002c1e 	bne	r2,zero,8113010c <_strtod_r+0xc50>
8113005c:	000d883a 	mov	r6,zero
81130060:	01cffc34 	movhi	r7,16368
81130064:	b809883a 	mov	r4,r23
81130068:	b00b883a 	mov	r5,r22
8113006c:	11374180 	call	81137418 <__ledf2>
81130070:	10021716 	blt	r2,zero,811308d0 <_strtod_r+0x1414>
81130074:	b809883a 	mov	r4,r23
81130078:	b00b883a 	mov	r5,r22
8113007c:	000d883a 	mov	r6,zero
81130080:	01cff834 	movhi	r7,16352
81130084:	112138c0 	call	8112138c <__muldf3>
81130088:	d8800d15 	stw	r2,52(sp)
8113008c:	182f883a 	mov	r23,r3
81130090:	102d883a 	mov	r22,r2
81130094:	1a20003c 	xorhi	r8,r3,32768
81130098:	dd800b15 	stw	r22,44(sp)
8113009c:	402d883a 	mov	r22,r8
811300a0:	003f8206 	br	8112feac <__reset+0xfb10feac>
811300a4:	b013883a 	mov	r9,r22
811300a8:	000b883a 	mov	r5,zero
811300ac:	0015883a 	mov	r10,zero
811300b0:	893ff404 	addi	r4,r17,-48
811300b4:	00800244 	movi	r2,9
811300b8:	11001036 	bltu	r2,r4,811300fc <_strtod_r+0xc40>
811300bc:	28c00044 	addi	r3,r5,1
811300c0:	2023883a 	mov	r17,r4
811300c4:	20014d1e 	bne	r4,zero,811305fc <_strtod_r+0x1140>
811300c8:	d9800617 	ldw	r6,24(sp)
811300cc:	180b883a 	mov	r5,r3
811300d0:	30800044 	addi	r2,r6,1
811300d4:	d8800615 	stw	r2,24(sp)
811300d8:	34400047 	ldb	r17,1(r6)
811300dc:	003ff406 	br	811300b0 <__reset+0xfb1100b0>
811300e0:	0019883a 	mov	r12,zero
811300e4:	b8800084 	addi	r2,r23,2
811300e8:	d8800615 	stw	r2,24(sp)
811300ec:	bc400087 	ldb	r17,2(r23)
811300f0:	003e1606 	br	8112f94c <__reset+0xfb10f94c>
811300f4:	03000044 	movi	r12,1
811300f8:	003ffa06 	br	811300e4 <__reset+0xfb1100e4>
811300fc:	02c00044 	movi	r11,1
81130100:	003d8d06 	br	8112f738 <__reset+0xfb10f738>
81130104:	00800044 	movi	r2,1
81130108:	9080fe26 	beq	r18,r2,81130504 <_strtod_r+0x1048>
8113010c:	d8000b15 	stw	zero,44(sp)
81130110:	05affc34 	movhi	r22,49136
81130114:	d8000d15 	stw	zero,52(sp)
81130118:	05cffc34 	movhi	r23,16368
8113011c:	003f6306 	br	8112feac <__reset+0xfb10feac>
81130120:	d8000a15 	stw	zero,40(sp)
81130124:	003ec906 	br	8112fc4c <__reset+0xfb10fc4c>
81130128:	d9001117 	ldw	r4,68(sp)
8113012c:	00bfffc4 	movi	r2,-1
81130130:	2080461e 	bne	r4,r2,8113024c <_strtod_r+0xd90>
81130134:	dd000a15 	stw	r20,40(sp)
81130138:	dd001217 	ldw	r20,72(sp)
8113013c:	a811883a 	mov	r8,r21
81130140:	d8800517 	ldw	r2,20(sp)
81130144:	00c00884 	movi	r3,34
81130148:	80c00015 	stw	r3,0(r16)
8113014c:	002b883a 	mov	r21,zero
81130150:	059ffc34 	movhi	r22,32752
81130154:	100b883a 	mov	r5,r2
81130158:	8009883a 	mov	r4,r16
8113015c:	da001315 	stw	r8,76(sp)
81130160:	112dca80 	call	8112dca8 <_Bfree>
81130164:	d9400a17 	ldw	r5,40(sp)
81130168:	8009883a 	mov	r4,r16
8113016c:	112dca80 	call	8112dca8 <_Bfree>
81130170:	980b883a 	mov	r5,r19
81130174:	8009883a 	mov	r4,r16
81130178:	112dca80 	call	8112dca8 <_Bfree>
8113017c:	d9400817 	ldw	r5,32(sp)
81130180:	8009883a 	mov	r4,r16
81130184:	112dca80 	call	8112dca8 <_Bfree>
81130188:	da001317 	ldw	r8,76(sp)
8113018c:	8009883a 	mov	r4,r16
81130190:	400b883a 	mov	r5,r8
81130194:	112dca80 	call	8112dca8 <_Bfree>
81130198:	003d9206 	br	8112f7e4 <__reset+0xfb10f7e4>
8113019c:	d8c00717 	ldw	r3,28(sp)
811301a0:	d8800504 	addi	r2,sp,20
811301a4:	01a04574 	movhi	r6,33045
811301a8:	3187bf04 	addi	r6,r6,7932
811301ac:	d8c00115 	stw	r3,4(sp)
811301b0:	d8800015 	stw	r2,0(sp)
811301b4:	d9c00404 	addi	r7,sp,16
811301b8:	d9400604 	addi	r5,sp,24
811301bc:	8009883a 	mov	r4,r16
811301c0:	11346100 	call	81134610 <__gethex>
811301c4:	154001cc 	andi	r21,r2,7
811301c8:	a83d9b26 	beq	r21,zero,8112f838 <__reset+0xfb10f838>
811301cc:	00c00184 	movi	r3,6
811301d0:	a8c0d61e 	bne	r21,r3,8113052c <_strtod_r+0x1070>
811301d4:	9cc00044 	addi	r19,r19,1
811301d8:	dcc00615 	stw	r19,24(sp)
811301dc:	002b883a 	mov	r21,zero
811301e0:	002d883a 	mov	r22,zero
811301e4:	d8000715 	stw	zero,28(sp)
811301e8:	003d7e06 	br	8112f7e4 <__reset+0xfb10f7e4>
811301ec:	00bf2c34 	movhi	r2,64688
811301f0:	88a3883a 	add	r17,r17,r2
811301f4:	9009883a 	mov	r4,r18
811301f8:	880b883a 	mov	r5,r17
811301fc:	112e75c0 	call	8112e75c <__ulp>
81130200:	d9000b17 	ldw	r4,44(sp)
81130204:	100d883a 	mov	r6,r2
81130208:	180f883a 	mov	r7,r3
8113020c:	b00b883a 	mov	r5,r22
81130210:	112138c0 	call	8112138c <__muldf3>
81130214:	900d883a 	mov	r6,r18
81130218:	180b883a 	mov	r5,r3
8113021c:	880f883a 	mov	r7,r17
81130220:	1009883a 	mov	r4,r2
81130224:	11361ec0 	call	811361ec <__adddf3>
81130228:	015f2834 	movhi	r5,31904
8113022c:	1025883a 	mov	r18,r2
81130230:	297fffc4 	addi	r5,r5,-1
81130234:	189ffc2c 	andhi	r2,r3,32752
81130238:	2880892e 	bgeu	r5,r2,81130460 <_strtod_r+0xfa4>
8113023c:	d8801017 	ldw	r2,64(sp)
81130240:	00dffc34 	movhi	r3,32752
81130244:	18ffffc4 	addi	r3,r3,-1
81130248:	10ffb726 	beq	r2,r3,81130128 <__reset+0xfb110128>
8113024c:	045ffc34 	movhi	r17,32752
81130250:	8c7fffc4 	addi	r17,r17,-1
81130254:	04bfffc4 	movi	r18,-1
81130258:	003f4706 	br	8112ff78 <__reset+0xfb10ff78>
8113025c:	00800884 	movi	r2,34
81130260:	80800015 	stw	r2,0(r16)
81130264:	002b883a 	mov	r21,zero
81130268:	059ffc34 	movhi	r22,32752
8113026c:	003d5d06 	br	8112f7e4 <__reset+0xfb10f7e4>
81130270:	d9000d17 	ldw	r4,52(sp)
81130274:	b80b883a 	mov	r5,r23
81130278:	11223b00 	call	811223b0 <__fixdfsi>
8113027c:	1009883a 	mov	r4,r2
81130280:	11224300 	call	81122430 <__floatsidf>
81130284:	d9000d17 	ldw	r4,52(sp)
81130288:	b80b883a 	mov	r5,r23
8113028c:	100d883a 	mov	r6,r2
81130290:	180f883a 	mov	r7,r3
81130294:	1121aac0 	call	81121aac <__subdf3>
81130298:	d9400e17 	ldw	r5,56(sp)
8113029c:	1039883a 	mov	fp,r2
811302a0:	182f883a 	mov	r23,r3
811302a4:	2800141e 	bne	r5,zero,811302f8 <_strtod_r+0xe3c>
811302a8:	9000131e 	bne	r18,zero,811302f8 <_strtod_r+0xe3c>
811302ac:	00800434 	movhi	r2,16
811302b0:	10bfffc4 	addi	r2,r2,-1
811302b4:	b0ac703a 	and	r22,r22,r2
811302b8:	b0000f1e 	bne	r22,zero,811302f8 <_strtod_r+0xe3c>
811302bc:	01a52834 	movhi	r6,38048
811302c0:	01cff434 	movhi	r7,16336
811302c4:	318d6544 	addi	r6,r6,13717
811302c8:	39ffffc4 	addi	r7,r7,-1
811302cc:	e009883a 	mov	r4,fp
811302d0:	180b883a 	mov	r5,r3
811302d4:	11374180 	call	81137418 <__ledf2>
811302d8:	103f270e 	bge	r2,zero,8112ff78 <__reset+0xfb10ff78>
811302dc:	dd000a15 	stw	r20,40(sp)
811302e0:	a811883a 	mov	r8,r21
811302e4:	dd001217 	ldw	r20,72(sp)
811302e8:	d8800517 	ldw	r2,20(sp)
811302ec:	002b883a 	mov	r21,zero
811302f0:	882d883a 	mov	r22,r17
811302f4:	003f9706 	br	81130154 <__reset+0xfb110154>
811302f8:	01a52834 	movhi	r6,38048
811302fc:	01cff834 	movhi	r7,16352
81130300:	318d6544 	addi	r6,r6,13717
81130304:	39ffffc4 	addi	r7,r7,-1
81130308:	e009883a 	mov	r4,fp
8113030c:	b80b883a 	mov	r5,r23
81130310:	11374180 	call	81137418 <__ledf2>
81130314:	10000716 	blt	r2,zero,81130334 <_strtod_r+0xe78>
81130318:	018d6c34 	movhi	r6,13744
8113031c:	31b94d44 	addi	r6,r6,-6859
81130320:	01cff834 	movhi	r7,16352
81130324:	e009883a 	mov	r4,fp
81130328:	b80b883a 	mov	r5,r23
8113032c:	11212b00 	call	811212b0 <__gedf2>
81130330:	00bf110e 	bge	zero,r2,8112ff78 <__reset+0xfb10ff78>
81130334:	dd000a15 	stw	r20,40(sp)
81130338:	a811883a 	mov	r8,r21
8113033c:	dd001217 	ldw	r20,72(sp)
81130340:	d8800517 	ldw	r2,20(sp)
81130344:	902b883a 	mov	r21,r18
81130348:	882d883a 	mov	r22,r17
8113034c:	003f8106 	br	81130154 <__reset+0xfb110154>
81130350:	b83e2f26 	beq	r23,zero,8112fc10 <__reset+0xfb10fc10>
81130354:	05efc83a 	sub	r23,zero,r23
81130358:	b88003cc 	andi	r2,r23,15
8113035c:	10000d26 	beq	r2,zero,81130394 <_strtod_r+0xed8>
81130360:	100490fa 	slli	r2,r2,3
81130364:	00e04574 	movhi	r3,33045
81130368:	18c78404 	addi	r3,r3,7696
8113036c:	1885883a 	add	r2,r3,r2
81130370:	11800017 	ldw	r6,0(r2)
81130374:	11c00117 	ldw	r7,4(r2)
81130378:	9009883a 	mov	r4,r18
8113037c:	880b883a 	mov	r5,r17
81130380:	da401315 	stw	r9,76(sp)
81130384:	1136aa00 	call	81136aa0 <__divdf3>
81130388:	da401317 	ldw	r9,76(sp)
8113038c:	1025883a 	mov	r18,r2
81130390:	1823883a 	mov	r17,r3
81130394:	b82fd13a 	srai	r23,r23,4
81130398:	b83e1d26 	beq	r23,zero,8112fc10 <__reset+0xfb10fc10>
8113039c:	008007c4 	movi	r2,31
811303a0:	15c02816 	blt	r2,r23,81130444 <_strtod_r+0xf88>
811303a4:	b880040c 	andi	r2,r23,16
811303a8:	10019726 	beq	r2,zero,81130a08 <_strtod_r+0x154c>
811303ac:	05c1880e 	bge	zero,r23,811309d0 <_strtod_r+0x1514>
811303b0:	00c01a84 	movi	r3,106
811303b4:	d8c00915 	stw	r3,36(sp)
811303b8:	04e04574 	movhi	r19,33045
811303bc:	9cc7c404 	addi	r19,r19,7952
811303c0:	8807883a 	mov	r3,r17
811303c4:	9005883a 	mov	r2,r18
811303c8:	8023883a 	mov	r17,r16
811303cc:	0009883a 	mov	r4,zero
811303d0:	9821883a 	mov	r16,r19
811303d4:	da400a15 	stw	r9,40(sp)
811303d8:	1827883a 	mov	r19,r3
811303dc:	b980004c 	andi	r6,r23,1
811303e0:	30000626 	beq	r6,zero,811303fc <_strtod_r+0xf40>
811303e4:	81800017 	ldw	r6,0(r16)
811303e8:	81c00117 	ldw	r7,4(r16)
811303ec:	1009883a 	mov	r4,r2
811303f0:	180b883a 	mov	r5,r3
811303f4:	112138c0 	call	8112138c <__muldf3>
811303f8:	01000044 	movi	r4,1
811303fc:	b82fd07a 	srai	r23,r23,1
81130400:	84000204 	addi	r16,r16,8
81130404:	b83ff51e 	bne	r23,zero,811303dc <__reset+0xfb1103dc>
81130408:	21003fcc 	andi	r4,r4,255
8113040c:	8821883a 	mov	r16,r17
81130410:	da400a17 	ldw	r9,40(sp)
81130414:	9823883a 	mov	r17,r19
81130418:	2001a51e 	bne	r4,zero,81130ab0 <_strtod_r+0x15f4>
8113041c:	d9000917 	ldw	r4,36(sp)
81130420:	20016d1e 	bne	r4,zero,811309d8 <_strtod_r+0x151c>
81130424:	000d883a 	mov	r6,zero
81130428:	000f883a 	mov	r7,zero
8113042c:	9009883a 	mov	r4,r18
81130430:	880b883a 	mov	r5,r17
81130434:	da401315 	stw	r9,76(sp)
81130438:	11373900 	call	81137390 <__eqdf2>
8113043c:	da401317 	ldw	r9,76(sp)
81130440:	103df41e 	bne	r2,zero,8112fc14 <__reset+0xfb10fc14>
81130444:	00800884 	movi	r2,34
81130448:	80800015 	stw	r2,0(r16)
8113044c:	002b883a 	mov	r21,zero
81130450:	002d883a 	mov	r22,zero
81130454:	003ce306 	br	8112f7e4 <__reset+0xfb10f7e4>
81130458:	055387c4 	movi	r21,19999
8113045c:	003d6b06 	br	8112fa0c <__reset+0xfb10fa0c>
81130460:	0440d434 	movhi	r17,848
81130464:	1c63883a 	add	r17,r3,r17
81130468:	882d883a 	mov	r22,r17
8113046c:	003ebe06 	br	8112ff68 <__reset+0xfb10ff68>
81130470:	14403fcc 	andi	r17,r2,255
81130474:	8c40201c 	xori	r17,r17,128
81130478:	8c7fe004 	addi	r17,r17,-128
8113047c:	dd400817 	ldw	r21,32(sp)
81130480:	0027883a 	mov	r19,zero
81130484:	0039883a 	mov	fp,zero
81130488:	002d883a 	mov	r22,zero
8113048c:	003c9906 	br	8112f6f4 <__reset+0xfb10f6f4>
81130490:	00c00944 	movi	r3,37
81130494:	1a47c83a 	sub	r3,r3,r9
81130498:	1d7d8c16 	blt	r3,r21,8112facc <__reset+0xfb10facc>
8113049c:	1261c83a 	sub	r16,r2,r9
811304a0:	800490fa 	slli	r2,r16,3
811304a4:	04e04574 	movhi	r19,33045
811304a8:	9cc78404 	addi	r19,r19,7696
811304ac:	9885883a 	add	r2,r19,r2
811304b0:	11000017 	ldw	r4,0(r2)
811304b4:	11400117 	ldw	r5,4(r2)
811304b8:	900d883a 	mov	r6,r18
811304bc:	880f883a 	mov	r7,r17
811304c0:	112138c0 	call	8112138c <__muldf3>
811304c4:	ac0dc83a 	sub	r6,r21,r16
811304c8:	300c90fa 	slli	r6,r6,3
811304cc:	1009883a 	mov	r4,r2
811304d0:	180b883a 	mov	r5,r3
811304d4:	9985883a 	add	r2,r19,r6
811304d8:	11800017 	ldw	r6,0(r2)
811304dc:	11c00117 	ldw	r7,4(r2)
811304e0:	112138c0 	call	8112138c <__muldf3>
811304e4:	102b883a 	mov	r21,r2
811304e8:	182d883a 	mov	r22,r3
811304ec:	003cbd06 	br	8112f7e4 <__reset+0xfb10f7e4>
811304f0:	b811883a 	mov	r8,r23
811304f4:	003e8606 	br	8112ff10 <__reset+0xfb10ff10>
811304f8:	d8000d15 	stw	zero,52(sp)
811304fc:	05cffc34 	movhi	r23,16368
81130500:	003e8006 	br	8112ff04 <__reset+0xfb10ff04>
81130504:	883f011e 	bne	r17,zero,8113010c <__reset+0xfb11010c>
81130508:	dd000a15 	stw	r20,40(sp)
8113050c:	dd001217 	ldw	r20,72(sp)
81130510:	a811883a 	mov	r8,r21
81130514:	00800884 	movi	r2,34
81130518:	80800015 	stw	r2,0(r16)
8113051c:	002b883a 	mov	r21,zero
81130520:	d8800517 	ldw	r2,20(sp)
81130524:	002d883a 	mov	r22,zero
81130528:	003f0a06 	br	81130154 <__reset+0xfb110154>
8113052c:	d9800517 	ldw	r6,20(sp)
81130530:	30000826 	beq	r6,zero,81130554 <_strtod_r+0x1098>
81130534:	01400d44 	movi	r5,53
81130538:	d9000204 	addi	r4,sp,8
8113053c:	d8801315 	stw	r2,76(sp)
81130540:	112eb500 	call	8112eb50 <__copybits>
81130544:	d9400517 	ldw	r5,20(sp)
81130548:	8009883a 	mov	r4,r16
8113054c:	112dca80 	call	8112dca8 <_Bfree>
81130550:	d8801317 	ldw	r2,76(sp)
81130554:	00c00184 	movi	r3,6
81130558:	1d400f36 	bltu	r3,r21,81130598 <_strtod_r+0x10dc>
8113055c:	a82a90ba 	slli	r21,r21,2
81130560:	00e044f4 	movhi	r3,33043
81130564:	18c15d04 	addi	r3,r3,1396
81130568:	a8eb883a 	add	r21,r21,r3
8113056c:	a8c00017 	ldw	r3,0(r21)
81130570:	1800683a 	jmp	r3
81130574:	811305f0 	cmpltui	r4,r16,19479
81130578:	811305c8 	cmpgei	r4,r16,19479
8113057c:	811305ac 	andhi	r4,r16,19478
81130580:	81130590 	cmplti	r4,r16,19478
81130584:	811305b8 	rdprs	r4,r16,19478
81130588:	811305c8 	cmpgei	r4,r16,19479
8113058c:	811305f0 	cmpltui	r4,r16,19479
81130590:	045ffc34 	movhi	r17,32752
81130594:	0025883a 	mov	r18,zero
81130598:	1080020c 	andi	r2,r2,8
8113059c:	902b883a 	mov	r21,r18
811305a0:	103c8f26 	beq	r2,zero,8112f7e0 <__reset+0xfb10f7e0>
811305a4:	8da00034 	orhi	r22,r17,32768
811305a8:	003c8e06 	br	8112f7e4 <__reset+0xfb10f7e4>
811305ac:	dc800217 	ldw	r18,8(sp)
811305b0:	dc400317 	ldw	r17,12(sp)
811305b4:	003ff806 	br	81130598 <__reset+0xfb110598>
811305b8:	04600034 	movhi	r17,32768
811305bc:	8c7fffc4 	addi	r17,r17,-1
811305c0:	04bfffc4 	movi	r18,-1
811305c4:	003ff406 	br	81130598 <__reset+0xfb110598>
811305c8:	d8c00417 	ldw	r3,16(sp)
811305cc:	dc400317 	ldw	r17,12(sp)
811305d0:	013ffc34 	movhi	r4,65520
811305d4:	18c10cc4 	addi	r3,r3,1075
811305d8:	1806953a 	slli	r3,r3,20
811305dc:	213fffc4 	addi	r4,r4,-1
811305e0:	8922703a 	and	r17,r17,r4
811305e4:	dc800217 	ldw	r18,8(sp)
811305e8:	88e2b03a 	or	r17,r17,r3
811305ec:	003fea06 	br	81130598 <__reset+0xfb110598>
811305f0:	0023883a 	mov	r17,zero
811305f4:	0025883a 	mov	r18,zero
811305f8:	003fe706 	br	81130598 <__reset+0xfb110598>
811305fc:	01800044 	movi	r6,1
81130600:	50d5883a 	add	r10,r10,r3
81130604:	2a4b883a 	add	r5,r5,r9
81130608:	19811a26 	beq	r3,r6,81130a74 <_strtod_r+0x15b8>
8113060c:	01800204 	movi	r6,8
81130610:	01c00404 	movi	r7,16
81130614:	4a400044 	addi	r9,r9,1
81130618:	48bfffc4 	addi	r2,r9,-1
8113061c:	30801616 	blt	r6,r2,81130678 <_strtod_r+0x11bc>
81130620:	e70002a4 	muli	fp,fp,10
81130624:	497ffb1e 	bne	r9,r5,81130614 <__reset+0xfb110614>
81130628:	d9800617 	ldw	r6,24(sp)
8113062c:	4a400044 	addi	r9,r9,1
81130630:	00c00204 	movi	r3,8
81130634:	19400c0e 	bge	r3,r5,81130668 <_strtod_r+0x11ac>
81130638:	00800404 	movi	r2,16
8113063c:	000b883a 	mov	r5,zero
81130640:	127ea316 	blt	r2,r9,811300d0 <__reset+0xfb1100d0>
81130644:	988002a4 	muli	r2,r19,10
81130648:	20a7883a 	add	r19,r4,r2
8113064c:	003ea006 	br	811300d0 <__reset+0xfb1100d0>
81130650:	d8800617 	ldw	r2,24(sp)
81130654:	8c7ff404 	addi	r17,r17,-48
81130658:	2a800044 	addi	r10,r5,1
8113065c:	d8800815 	stw	r2,32(sp)
81130660:	100d883a 	mov	r6,r2
81130664:	02400044 	movi	r9,1
81130668:	e08002a4 	muli	r2,fp,10
8113066c:	000b883a 	mov	r5,zero
81130670:	88b9883a 	add	fp,r17,r2
81130674:	003e9606 	br	811300d0 <__reset+0xfb1100d0>
81130678:	3a7fea16 	blt	r7,r9,81130624 <__reset+0xfb110624>
8113067c:	9cc002a4 	muli	r19,r19,10
81130680:	003fe806 	br	81130624 <__reset+0xfb110624>
81130684:	00bffa84 	movi	r2,-22
81130688:	a8bd1016 	blt	r21,r2,8112facc <__reset+0xfb10facc>
8113068c:	a82a90fa 	slli	r21,r21,3
81130690:	00a04574 	movhi	r2,33045
81130694:	10878404 	addi	r2,r2,7696
81130698:	1545c83a 	sub	r2,r2,r21
8113069c:	11800017 	ldw	r6,0(r2)
811306a0:	11c00117 	ldw	r7,4(r2)
811306a4:	9009883a 	mov	r4,r18
811306a8:	880b883a 	mov	r5,r17
811306ac:	1136aa00 	call	81136aa0 <__divdf3>
811306b0:	102b883a 	mov	r21,r2
811306b4:	182d883a 	mov	r22,r3
811306b8:	003c4a06 	br	8112f7e4 <__reset+0xfb10f7e4>
811306bc:	dd000a15 	stw	r20,40(sp)
811306c0:	a811883a 	mov	r8,r21
811306c4:	dd001217 	ldw	r20,72(sp)
811306c8:	003e9e06 	br	81130144 <__reset+0xfb110144>
811306cc:	01604574 	movhi	r5,33045
811306d0:	d9000617 	ldw	r4,24(sp)
811306d4:	2947b604 	addi	r5,r5,7896
811306d8:	01c00644 	movi	r7,25
811306dc:	00000b06 	br	8113070c <_strtod_r+0x1250>
811306e0:	21000044 	addi	r4,r4,1
811306e4:	20800003 	ldbu	r2,0(r4)
811306e8:	10ffefc4 	addi	r3,r2,-65
811306ec:	10803fcc 	andi	r2,r2,255
811306f0:	1080201c 	xori	r2,r2,128
811306f4:	18c03fcc 	andi	r3,r3,255
811306f8:	10bfe004 	addi	r2,r2,-128
811306fc:	38c00136 	bltu	r7,r3,81130704 <_strtod_r+0x1248>
81130700:	10800804 	addi	r2,r2,32
81130704:	29400044 	addi	r5,r5,1
81130708:	11bbbb1e 	bne	r2,r6,8112f5f8 <__reset+0xfb10f5f8>
8113070c:	29800007 	ldb	r6,0(r5)
81130710:	303ff31e 	bne	r6,zero,811306e0 <__reset+0xfb1106e0>
81130714:	01a04574 	movhi	r6,33045
81130718:	d9000615 	stw	r4,24(sp)
8113071c:	3187b704 	addi	r6,r6,7900
81130720:	200b883a 	mov	r5,r4
81130724:	02000644 	movi	r8,25
81130728:	00000a06 	br	81130754 <_strtod_r+0x1298>
8113072c:	28800003 	ldbu	r2,0(r5)
81130730:	10ffefc4 	addi	r3,r2,-65
81130734:	10803fcc 	andi	r2,r2,255
81130738:	1080201c 	xori	r2,r2,128
8113073c:	18c03fcc 	andi	r3,r3,255
81130740:	10bfe004 	addi	r2,r2,-128
81130744:	40c00136 	bltu	r8,r3,8113074c <_strtod_r+0x1290>
81130748:	10800804 	addi	r2,r2,32
8113074c:	31800044 	addi	r6,r6,1
81130750:	11c0711e 	bne	r2,r7,81130918 <_strtod_r+0x145c>
81130754:	31c00007 	ldb	r7,0(r6)
81130758:	29400044 	addi	r5,r5,1
8113075c:	383ff31e 	bne	r7,zero,8113072c <__reset+0xfb11072c>
81130760:	d9400615 	stw	r5,24(sp)
81130764:	045ffc34 	movhi	r17,32752
81130768:	0025883a 	mov	r18,zero
8113076c:	003c1b06 	br	8112f7dc <__reset+0xfb10f7dc>
81130770:	000b883a 	mov	r5,zero
81130774:	003ccc06 	br	8112faa8 <__reset+0xfb10faa8>
81130778:	d9400e17 	ldw	r5,56(sp)
8113077c:	dd000a15 	stw	r20,40(sp)
81130780:	00800434 	movhi	r2,16
81130784:	a811883a 	mov	r8,r21
81130788:	dd001217 	ldw	r20,72(sp)
8113078c:	dd401117 	ldw	r21,68(sp)
81130790:	dd801017 	ldw	r22,64(sp)
81130794:	10bfffc4 	addi	r2,r2,-1
81130798:	28005626 	beq	r5,zero,811308f4 <_strtod_r+0x1438>
8113079c:	8886703a 	and	r3,r17,r2
811307a0:	18807826 	beq	r3,r2,81130984 <_strtod_r+0x14c8>
811307a4:	d8c00b17 	ldw	r3,44(sp)
811307a8:	18005726 	beq	r3,zero,81130908 <_strtod_r+0x144c>
811307ac:	1c44703a 	and	r2,r3,r17
811307b0:	10000f26 	beq	r2,zero,811307f0 <_strtod_r+0x1334>
811307b4:	d9000e17 	ldw	r4,56(sp)
811307b8:	d9800917 	ldw	r6,36(sp)
811307bc:	20005e26 	beq	r4,zero,81130938 <_strtod_r+0x147c>
811307c0:	9009883a 	mov	r4,r18
811307c4:	880b883a 	mov	r5,r17
811307c8:	da001315 	stw	r8,76(sp)
811307cc:	112f4500 	call	8112f450 <sulp>
811307d0:	100d883a 	mov	r6,r2
811307d4:	180f883a 	mov	r7,r3
811307d8:	9009883a 	mov	r4,r18
811307dc:	880b883a 	mov	r5,r17
811307e0:	11361ec0 	call	811361ec <__adddf3>
811307e4:	da001317 	ldw	r8,76(sp)
811307e8:	102b883a 	mov	r21,r2
811307ec:	182d883a 	mov	r22,r3
811307f0:	d8c00917 	ldw	r3,36(sp)
811307f4:	18000f26 	beq	r3,zero,81130834 <_strtod_r+0x1378>
811307f8:	a809883a 	mov	r4,r21
811307fc:	b00b883a 	mov	r5,r22
81130800:	000d883a 	mov	r6,zero
81130804:	01ce5434 	movhi	r7,14672
81130808:	da001315 	stw	r8,76(sp)
8113080c:	112138c0 	call	8112138c <__muldf3>
81130810:	102b883a 	mov	r21,r2
81130814:	182d883a 	mov	r22,r3
81130818:	da001317 	ldw	r8,76(sp)
8113081c:	1800051e 	bne	r3,zero,81130834 <_strtod_r+0x1378>
81130820:	d8800517 	ldw	r2,20(sp)
81130824:	a83e4b1e 	bne	r21,zero,81130154 <__reset+0xfb110154>
81130828:	00c00884 	movi	r3,34
8113082c:	80c00015 	stw	r3,0(r16)
81130830:	003e4806 	br	81130154 <__reset+0xfb110154>
81130834:	d8800517 	ldw	r2,20(sp)
81130838:	003e4606 	br	81130154 <__reset+0xfb110154>
8113083c:	d9000e17 	ldw	r4,56(sp)
81130840:	dd000a15 	stw	r20,40(sp)
81130844:	a811883a 	mov	r8,r21
81130848:	dd001217 	ldw	r20,72(sp)
8113084c:	dd401117 	ldw	r21,68(sp)
81130850:	dd801017 	ldw	r22,64(sp)
81130854:	203fe61e 	bne	r4,zero,811307f0 <__reset+0xfb1107f0>
81130858:	903fe51e 	bne	r18,zero,811307f0 <__reset+0xfb1107f0>
8113085c:	00800434 	movhi	r2,16
81130860:	10bfffc4 	addi	r2,r2,-1
81130864:	8884703a 	and	r2,r17,r2
81130868:	103fe11e 	bne	r2,zero,811307f0 <__reset+0xfb1107f0>
8113086c:	8ddffc2c 	andhi	r23,r17,32752
81130870:	0081ac34 	movhi	r2,1712
81130874:	15ffde2e 	bgeu	r2,r23,811307f0 <__reset+0xfb1107f0>
81130878:	40800517 	ldw	r2,20(r8)
8113087c:	1000031e 	bne	r2,zero,8113088c <_strtod_r+0x13d0>
81130880:	40800417 	ldw	r2,16(r8)
81130884:	00c00044 	movi	r3,1
81130888:	18bfd90e 	bge	r3,r2,811307f0 <__reset+0xfb1107f0>
8113088c:	400b883a 	mov	r5,r8
81130890:	01800044 	movi	r6,1
81130894:	8009883a 	mov	r4,r16
81130898:	112e3a80 	call	8112e3a8 <__lshift>
8113089c:	980b883a 	mov	r5,r19
811308a0:	1009883a 	mov	r4,r2
811308a4:	d8801315 	stw	r2,76(sp)
811308a8:	112e4f80 	call	8112e4f8 <__mcmp>
811308ac:	da001317 	ldw	r8,76(sp)
811308b0:	00bfcf0e 	bge	zero,r2,811307f0 <__reset+0xfb1107f0>
811308b4:	d8c00917 	ldw	r3,36(sp)
811308b8:	18005c26 	beq	r3,zero,81130a2c <_strtod_r+0x1570>
811308bc:	0081ac34 	movhi	r2,1712
811308c0:	15c05a16 	blt	r2,r23,81130a2c <_strtod_r+0x1570>
811308c4:	0080dc34 	movhi	r2,880
811308c8:	15ffcb16 	blt	r2,r23,811307f8 <__reset+0xfb1107f8>
811308cc:	003f1106 	br	81130514 <__reset+0xfb110514>
811308d0:	002d883a 	mov	r22,zero
811308d4:	022ff834 	movhi	r8,49120
811308d8:	d8000d15 	stw	zero,52(sp)
811308dc:	05cff834 	movhi	r23,16352
811308e0:	003ded06 	br	81130098 <__reset+0xfb110098>
811308e4:	0440d434 	movhi	r17,848
811308e8:	1c63883a 	add	r17,r3,r17
811308ec:	d8000915 	stw	zero,36(sp)
811308f0:	003cc806 	br	8112fc14 <__reset+0xfb10fc14>
811308f4:	8884703a 	and	r2,r17,r2
811308f8:	103faa1e 	bne	r2,zero,811307a4 <__reset+0xfb1107a4>
811308fc:	903fa91e 	bne	r18,zero,811307a4 <__reset+0xfb1107a4>
81130900:	8ddffc2c 	andhi	r23,r17,32752
81130904:	003feb06 	br	811308b4 <__reset+0xfb1108b4>
81130908:	d8c00d17 	ldw	r3,52(sp)
8113090c:	1cae703a 	and	r23,r3,r18
81130910:	b83fb726 	beq	r23,zero,811307f0 <__reset+0xfb1107f0>
81130914:	003fa706 	br	811307b4 <__reset+0xfb1107b4>
81130918:	21000044 	addi	r4,r4,1
8113091c:	d9000615 	stw	r4,24(sp)
81130920:	003f9006 	br	81130764 <__reset+0xfb110764>
81130924:	01604574 	movhi	r5,33045
81130928:	29477a04 	addi	r5,r5,7656
8113092c:	d9400915 	stw	r5,36(sp)
81130930:	0027883a 	mov	r19,zero
81130934:	003ca206 	br	8112fbc0 <__reset+0xfb10fbc0>
81130938:	9009883a 	mov	r4,r18
8113093c:	880b883a 	mov	r5,r17
81130940:	da001315 	stw	r8,76(sp)
81130944:	112f4500 	call	8112f450 <sulp>
81130948:	100d883a 	mov	r6,r2
8113094c:	180f883a 	mov	r7,r3
81130950:	9009883a 	mov	r4,r18
81130954:	880b883a 	mov	r5,r17
81130958:	1121aac0 	call	81121aac <__subdf3>
8113095c:	000d883a 	mov	r6,zero
81130960:	000f883a 	mov	r7,zero
81130964:	1009883a 	mov	r4,r2
81130968:	180b883a 	mov	r5,r3
8113096c:	102b883a 	mov	r21,r2
81130970:	182d883a 	mov	r22,r3
81130974:	11373900 	call	81137390 <__eqdf2>
81130978:	da001317 	ldw	r8,76(sp)
8113097c:	103ee526 	beq	r2,zero,81130514 <__reset+0xfb110514>
81130980:	003f9b06 	br	811307f0 <__reset+0xfb1107f0>
81130984:	d8800917 	ldw	r2,36(sp)
81130988:	10002226 	beq	r2,zero,81130a14 <_strtod_r+0x1558>
8113098c:	889ffc2c 	andhi	r2,r17,32752
81130990:	00c1a834 	movhi	r3,1696
81130994:	18801f36 	bltu	r3,r2,81130a14 <_strtod_r+0x1558>
81130998:	1004d53a 	srli	r2,r2,20
8113099c:	00c01ac4 	movi	r3,107
811309a0:	1887c83a 	sub	r3,r3,r2
811309a4:	00bfffc4 	movi	r2,-1
811309a8:	10c4983a 	sll	r2,r2,r3
811309ac:	14bf7d1e 	bne	r2,r18,811307a4 <__reset+0xfb1107a4>
811309b0:	00dffc34 	movhi	r3,32752
811309b4:	18ffffc4 	addi	r3,r3,-1
811309b8:	88c03526 	beq	r17,r3,81130a90 <_strtod_r+0x15d4>
811309bc:	8c5ffc2c 	andhi	r17,r17,32752
811309c0:	00800434 	movhi	r2,16
811309c4:	002b883a 	mov	r21,zero
811309c8:	88ad883a 	add	r22,r17,r2
811309cc:	003f8806 	br	811307f0 <__reset+0xfb1107f0>
811309d0:	01401a84 	movi	r5,106
811309d4:	d9400915 	stw	r5,36(sp)
811309d8:	8ddffc2c 	andhi	r23,r17,32752
811309dc:	b82ed53a 	srli	r23,r23,20
811309e0:	00801ac4 	movi	r2,107
811309e4:	15c5c83a 	sub	r2,r2,r23
811309e8:	00be8e0e 	bge	zero,r2,81130424 <__reset+0xfb110424>
811309ec:	00c007c4 	movi	r3,31
811309f0:	18800a0e 	bge	r3,r2,81130a1c <_strtod_r+0x1560>
811309f4:	00c00d04 	movi	r3,52
811309f8:	0025883a 	mov	r18,zero
811309fc:	1880270e 	bge	r3,r2,81130a9c <_strtod_r+0x15e0>
81130a00:	0440dc34 	movhi	r17,880
81130a04:	003e8706 	br	81130424 <__reset+0xfb110424>
81130a08:	d8000915 	stw	zero,36(sp)
81130a0c:	05fe6a16 	blt	zero,r23,811303b8 <__reset+0xfb1103b8>
81130a10:	003e8406 	br	81130424 <__reset+0xfb110424>
81130a14:	00bfffc4 	movi	r2,-1
81130a18:	003fe406 	br	811309ac <__reset+0xfb1109ac>
81130a1c:	00ffffc4 	movi	r3,-1
81130a20:	1884983a 	sll	r2,r3,r2
81130a24:	14a4703a 	and	r18,r2,r18
81130a28:	003e7e06 	br	81130424 <__reset+0xfb110424>
81130a2c:	00bffc34 	movhi	r2,65520
81130a30:	b8af883a 	add	r23,r23,r2
81130a34:	057fffc4 	movi	r21,-1
81130a38:	00800434 	movhi	r2,16
81130a3c:	1545883a 	add	r2,r2,r21
81130a40:	b8acb03a 	or	r22,r23,r2
81130a44:	003f6a06 	br	811307f0 <__reset+0xfb1107f0>
81130a48:	01604574 	movhi	r5,33045
81130a4c:	2947ba04 	addi	r5,r5,7912
81130a50:	d9800204 	addi	r6,sp,8
81130a54:	d9000604 	addi	r4,sp,24
81130a58:	1134e480 	call	81134e48 <__hexnan>
81130a5c:	00c00144 	movi	r3,5
81130a60:	10fb5c1e 	bne	r2,r3,8112f7d4 <__reset+0xfb10f7d4>
81130a64:	dc400317 	ldw	r17,12(sp)
81130a68:	dc800217 	ldw	r18,8(sp)
81130a6c:	8c5ffc34 	orhi	r17,r17,32752
81130a70:	003b5a06 	br	8112f7dc <__reset+0xfb10f7dc>
81130a74:	480b883a 	mov	r5,r9
81130a78:	d9800617 	ldw	r6,24(sp)
81130a7c:	4a400044 	addi	r9,r9,1
81130a80:	003eeb06 	br	81130630 <__reset+0xfb110630>
81130a84:	1025883a 	mov	r18,r2
81130a88:	1823883a 	mov	r17,r3
81130a8c:	003c4c06 	br	8112fbc0 <__reset+0xfb10fbc0>
81130a90:	00ffffc4 	movi	r3,-1
81130a94:	10ffc91e 	bne	r2,r3,811309bc <__reset+0xfb1109bc>
81130a98:	003da906 	br	81130140 <__reset+0xfb110140>
81130a9c:	10bff804 	addi	r2,r2,-32
81130aa0:	00ffffc4 	movi	r3,-1
81130aa4:	1884983a 	sll	r2,r3,r2
81130aa8:	1462703a 	and	r17,r2,r17
81130aac:	003e5d06 	br	81130424 <__reset+0xfb110424>
81130ab0:	1025883a 	mov	r18,r2
81130ab4:	1823883a 	mov	r17,r3
81130ab8:	003e5806 	br	8113041c <__reset+0xfb11041c>

81130abc <strtod>:
81130abc:	00a04574 	movhi	r2,33045
81130ac0:	10911304 	addi	r2,r2,17484
81130ac4:	280d883a 	mov	r6,r5
81130ac8:	200b883a 	mov	r5,r4
81130acc:	11000017 	ldw	r4,0(r2)
81130ad0:	112f4bc1 	jmpi	8112f4bc <_strtod_r>

81130ad4 <strtof>:
81130ad4:	defffb04 	addi	sp,sp,-20
81130ad8:	de00012e 	bgeu	sp,et,81130ae0 <strtof+0xc>
81130adc:	003b68fa 	trap	3
81130ae0:	dcc00315 	stw	r19,12(sp)
81130ae4:	04e04574 	movhi	r19,33045
81130ae8:	9cd11304 	addi	r19,r19,17484
81130aec:	280d883a 	mov	r6,r5
81130af0:	200b883a 	mov	r5,r4
81130af4:	99000017 	ldw	r4,0(r19)
81130af8:	dfc00415 	stw	ra,16(sp)
81130afc:	dc800215 	stw	r18,8(sp)
81130b00:	dc400115 	stw	r17,4(sp)
81130b04:	dc000015 	stw	r16,0(sp)
81130b08:	112f4bc0 	call	8112f4bc <_strtod_r>
81130b0c:	1009883a 	mov	r4,r2
81130b10:	180b883a 	mov	r5,r3
81130b14:	1025883a 	mov	r18,r2
81130b18:	1823883a 	mov	r17,r3
81130b1c:	112262c0 	call	8112262c <__truncdfsf2>
81130b20:	000b883a 	mov	r5,zero
81130b24:	1009883a 	mov	r4,r2
81130b28:	1021883a 	mov	r16,r2
81130b2c:	1135ff00 	call	81135ff0 <__eqsf2>
81130b30:	1000111e 	bne	r2,zero,81130b78 <strtof+0xa4>
81130b34:	000d883a 	mov	r6,zero
81130b38:	000f883a 	mov	r7,zero
81130b3c:	9009883a 	mov	r4,r18
81130b40:	880b883a 	mov	r5,r17
81130b44:	11373900 	call	81137390 <__eqdf2>
81130b48:	10000b26 	beq	r2,zero,81130b78 <strtof+0xa4>
81130b4c:	98800017 	ldw	r2,0(r19)
81130b50:	00c00884 	movi	r3,34
81130b54:	10c00015 	stw	r3,0(r2)
81130b58:	8005883a 	mov	r2,r16
81130b5c:	dfc00417 	ldw	ra,16(sp)
81130b60:	dcc00317 	ldw	r19,12(sp)
81130b64:	dc800217 	ldw	r18,8(sp)
81130b68:	dc400117 	ldw	r17,4(sp)
81130b6c:	dc000017 	ldw	r16,0(sp)
81130b70:	dec00504 	addi	sp,sp,20
81130b74:	f800283a 	ret
81130b78:	015fe034 	movhi	r5,32640
81130b7c:	297fffc4 	addi	r5,r5,-1
81130b80:	8009883a 	mov	r4,r16
81130b84:	11360680 	call	81136068 <__gesf2>
81130b88:	0080070e 	bge	zero,r2,81130ba8 <strtof+0xd4>
81130b8c:	01dffc34 	movhi	r7,32752
81130b90:	39ffffc4 	addi	r7,r7,-1
81130b94:	01bfffc4 	movi	r6,-1
81130b98:	9009883a 	mov	r4,r18
81130b9c:	880b883a 	mov	r5,r17
81130ba0:	11212b00 	call	811212b0 <__gedf2>
81130ba4:	00bfe90e 	bge	zero,r2,81130b4c <__reset+0xfb110b4c>
81130ba8:	017fe034 	movhi	r5,65408
81130bac:	297fffc4 	addi	r5,r5,-1
81130bb0:	8009883a 	mov	r4,r16
81130bb4:	11361240 	call	81136124 <__lesf2>
81130bb8:	103fe70e 	bge	r2,zero,81130b58 <__reset+0xfb110b58>
81130bbc:	01fffc34 	movhi	r7,65520
81130bc0:	39ffffc4 	addi	r7,r7,-1
81130bc4:	01bfffc4 	movi	r6,-1
81130bc8:	9009883a 	mov	r4,r18
81130bcc:	880b883a 	mov	r5,r17
81130bd0:	11374180 	call	81137418 <__ledf2>
81130bd4:	103fdd0e 	bge	r2,zero,81130b4c <__reset+0xfb110b4c>
81130bd8:	003fdf06 	br	81130b58 <__reset+0xfb110b58>

81130bdc <_strtoll_r>:
81130bdc:	00a04574 	movhi	r2,33045
81130be0:	defff304 	addi	sp,sp,-52
81130be4:	10911104 	addi	r2,r2,17476
81130be8:	de00012e 	bgeu	sp,et,81130bf0 <_strtoll_r+0x14>
81130bec:	003b68fa 	trap	3
81130bf0:	dc800515 	stw	r18,20(sp)
81130bf4:	14800017 	ldw	r18,0(r2)
81130bf8:	dd800915 	stw	r22,36(sp)
81130bfc:	dd400815 	stw	r21,32(sp)
81130c00:	dcc00615 	stw	r19,24(sp)
81130c04:	d9000015 	stw	r4,0(sp)
81130c08:	dfc00c15 	stw	ra,48(sp)
81130c0c:	df000b15 	stw	fp,44(sp)
81130c10:	ddc00a15 	stw	r23,40(sp)
81130c14:	dd000715 	stw	r20,28(sp)
81130c18:	dc400415 	stw	r17,16(sp)
81130c1c:	dc000315 	stw	r16,12(sp)
81130c20:	282d883a 	mov	r22,r5
81130c24:	302b883a 	mov	r21,r6
81130c28:	3827883a 	mov	r19,r7
81130c2c:	2809883a 	mov	r4,r5
81130c30:	24000003 	ldbu	r16,0(r4)
81130c34:	24400044 	addi	r17,r4,1
81130c38:	2007883a 	mov	r3,r4
81130c3c:	9405883a 	add	r2,r18,r16
81130c40:	10800043 	ldbu	r2,1(r2)
81130c44:	8809883a 	mov	r4,r17
81130c48:	1080020c 	andi	r2,r2,8
81130c4c:	103ff81e 	bne	r2,zero,81130c30 <__reset+0xfb110c30>
81130c50:	00800b44 	movi	r2,45
81130c54:	80807826 	beq	r16,r2,81130e38 <_strtoll_r+0x25c>
81130c58:	00800ac4 	movi	r2,43
81130c5c:	80807a26 	beq	r16,r2,81130e48 <_strtoll_r+0x26c>
81130c60:	0039883a 	mov	fp,zero
81130c64:	98004e26 	beq	r19,zero,81130da0 <_strtoll_r+0x1c4>
81130c68:	00800404 	movi	r2,16
81130c6c:	98808226 	beq	r19,r2,81130e78 <_strtoll_r+0x29c>
81130c70:	982fd7fa 	srai	r23,r19,31
81130c74:	9829883a 	mov	r20,r19
81130c78:	e0004f26 	beq	fp,zero,81130db8 <_strtoll_r+0x1dc>
81130c7c:	0017883a 	mov	r11,zero
81130c80:	02a00034 	movhi	r10,32768
81130c84:	5809883a 	mov	r4,r11
81130c88:	500b883a 	mov	r5,r10
81130c8c:	a00d883a 	mov	r6,r20
81130c90:	b80f883a 	mov	r7,r23
81130c94:	da800215 	stw	r10,8(sp)
81130c98:	dac00115 	stw	r11,4(sp)
81130c9c:	11358fc0 	call	811358fc <__umoddi3>
81130ca0:	dac00117 	ldw	r11,4(sp)
81130ca4:	da800217 	ldw	r10,8(sp)
81130ca8:	a00d883a 	mov	r6,r20
81130cac:	5809883a 	mov	r4,r11
81130cb0:	500b883a 	mov	r5,r10
81130cb4:	b80f883a 	mov	r7,r23
81130cb8:	d8800115 	stw	r2,4(sp)
81130cbc:	113537c0 	call	8113537c <__udivdi3>
81130cc0:	9409883a 	add	r4,r18,r16
81130cc4:	21000043 	ldbu	r4,1(r4)
81130cc8:	1019883a 	mov	r12,r2
81130ccc:	880b883a 	mov	r5,r17
81130cd0:	2240010c 	andi	r9,r4,4
81130cd4:	0015883a 	mov	r10,zero
81130cd8:	000d883a 	mov	r6,zero
81130cdc:	000f883a 	mov	r7,zero
81130ce0:	03400044 	movi	r13,1
81130ce4:	02ffffc4 	movi	r11,-1
81130ce8:	da000117 	ldw	r8,4(sp)
81130cec:	48000d26 	beq	r9,zero,81130d24 <_strtoll_r+0x148>
81130cf0:	843ff404 	addi	r16,r16,-48
81130cf4:	84c0110e 	bge	r16,r19,81130d3c <_strtoll_r+0x160>
81130cf8:	52c00426 	beq	r10,r11,81130d0c <_strtoll_r+0x130>
81130cfc:	19c00236 	bltu	r3,r7,81130d08 <_strtoll_r+0x12c>
81130d00:	38c0311e 	bne	r7,r3,81130dc8 <_strtoll_r+0x1ec>
81130d04:	6180302e 	bgeu	r12,r6,81130dc8 <_strtoll_r+0x1ec>
81130d08:	02bfffc4 	movi	r10,-1
81130d0c:	2c000003 	ldbu	r16,0(r5)
81130d10:	29400044 	addi	r5,r5,1
81130d14:	9409883a 	add	r4,r18,r16
81130d18:	21000043 	ldbu	r4,1(r4)
81130d1c:	2240010c 	andi	r9,r4,4
81130d20:	483ff31e 	bne	r9,zero,81130cf0 <__reset+0xfb110cf0>
81130d24:	210000cc 	andi	r4,r4,3
81130d28:	20000426 	beq	r4,zero,81130d3c <_strtoll_r+0x160>
81130d2c:	23403426 	beq	r4,r13,81130e00 <_strtoll_r+0x224>
81130d30:	008015c4 	movi	r2,87
81130d34:	80a1c83a 	sub	r16,r16,r2
81130d38:	84ffef16 	blt	r16,r19,81130cf8 <__reset+0xfb110cf8>
81130d3c:	00bfffc4 	movi	r2,-1
81130d40:	50803426 	beq	r10,r2,81130e14 <_strtoll_r+0x238>
81130d44:	e0000426 	beq	fp,zero,81130d58 <_strtoll_r+0x17c>
81130d48:	018dc83a 	sub	r6,zero,r6
81130d4c:	3004c03a 	cmpne	r2,r6,zero
81130d50:	01e1c83a 	sub	r16,zero,r7
81130d54:	808fc83a 	sub	r7,r16,r2
81130d58:	3005883a 	mov	r2,r6
81130d5c:	3807883a 	mov	r3,r7
81130d60:	a8000326 	beq	r21,zero,81130d70 <_strtoll_r+0x194>
81130d64:	5000321e 	bne	r10,zero,81130e30 <_strtoll_r+0x254>
81130d68:	b00b883a 	mov	r5,r22
81130d6c:	a9400015 	stw	r5,0(r21)
81130d70:	dfc00c17 	ldw	ra,48(sp)
81130d74:	df000b17 	ldw	fp,44(sp)
81130d78:	ddc00a17 	ldw	r23,40(sp)
81130d7c:	dd800917 	ldw	r22,36(sp)
81130d80:	dd400817 	ldw	r21,32(sp)
81130d84:	dd000717 	ldw	r20,28(sp)
81130d88:	dcc00617 	ldw	r19,24(sp)
81130d8c:	dc800517 	ldw	r18,20(sp)
81130d90:	dc400417 	ldw	r17,16(sp)
81130d94:	dc000317 	ldw	r16,12(sp)
81130d98:	dec00d04 	addi	sp,sp,52
81130d9c:	f800283a 	ret
81130da0:	00800c04 	movi	r2,48
81130da4:	80802c26 	beq	r16,r2,81130e58 <_strtoll_r+0x27c>
81130da8:	05000284 	movi	r20,10
81130dac:	002f883a 	mov	r23,zero
81130db0:	a027883a 	mov	r19,r20
81130db4:	e03fb11e 	bne	fp,zero,81130c7c <__reset+0xfb110c7c>
81130db8:	02a00034 	movhi	r10,32768
81130dbc:	52bfffc4 	addi	r10,r10,-1
81130dc0:	02ffffc4 	movi	r11,-1
81130dc4:	003faf06 	br	81130c84 <__reset+0xfb110c84>
81130dc8:	33000f26 	beq	r6,r12,81130e08 <_strtoll_r+0x22c>
81130dcc:	b985383a 	mul	r2,r23,r6
81130dd0:	3d0f383a 	mul	r7,r7,r20
81130dd4:	3508383a 	mulxuu	r4,r6,r20
81130dd8:	350d383a 	mul	r6,r6,r20
81130ddc:	8013d7fa 	srai	r9,r16,31
81130de0:	388f883a 	add	r7,r7,r2
81130de4:	818d883a 	add	r6,r16,r6
81130de8:	390f883a 	add	r7,r7,r4
81130dec:	3421803a 	cmpltu	r16,r6,r16
81130df0:	49cf883a 	add	r7,r9,r7
81130df4:	81cf883a 	add	r7,r16,r7
81130df8:	02800044 	movi	r10,1
81130dfc:	003fc306 	br	81130d0c <__reset+0xfb110d0c>
81130e00:	00800dc4 	movi	r2,55
81130e04:	003fcb06 	br	81130d34 <__reset+0xfb110d34>
81130e08:	38fff01e 	bne	r7,r3,81130dcc <__reset+0xfb110dcc>
81130e0c:	443fbe16 	blt	r8,r16,81130d08 <__reset+0xfb110d08>
81130e10:	003fee06 	br	81130dcc <__reset+0xfb110dcc>
81130e14:	e0002426 	beq	fp,zero,81130ea8 <_strtoll_r+0x2cc>
81130e18:	0005883a 	mov	r2,zero
81130e1c:	00e00034 	movhi	r3,32768
81130e20:	d9800017 	ldw	r6,0(sp)
81130e24:	01000884 	movi	r4,34
81130e28:	31000015 	stw	r4,0(r6)
81130e2c:	a83fd026 	beq	r21,zero,81130d70 <__reset+0xfb110d70>
81130e30:	297fffc4 	addi	r5,r5,-1
81130e34:	003fcd06 	br	81130d6c <__reset+0xfb110d6c>
81130e38:	1c400084 	addi	r17,r3,2
81130e3c:	1c000043 	ldbu	r16,1(r3)
81130e40:	07000044 	movi	fp,1
81130e44:	003f8706 	br	81130c64 <__reset+0xfb110c64>
81130e48:	1c400084 	addi	r17,r3,2
81130e4c:	1c000043 	ldbu	r16,1(r3)
81130e50:	0039883a 	mov	fp,zero
81130e54:	003f8306 	br	81130c64 <__reset+0xfb110c64>
81130e58:	88800003 	ldbu	r2,0(r17)
81130e5c:	00c01604 	movi	r3,88
81130e60:	108037cc 	andi	r2,r2,223
81130e64:	10c00a26 	beq	r2,r3,81130e90 <_strtoll_r+0x2b4>
81130e68:	05000204 	movi	r20,8
81130e6c:	002f883a 	mov	r23,zero
81130e70:	a027883a 	mov	r19,r20
81130e74:	003f8006 	br	81130c78 <__reset+0xfb110c78>
81130e78:	00800c04 	movi	r2,48
81130e7c:	80800e1e 	bne	r16,r2,81130eb8 <_strtoll_r+0x2dc>
81130e80:	88800003 	ldbu	r2,0(r17)
81130e84:	00c01604 	movi	r3,88
81130e88:	108037cc 	andi	r2,r2,223
81130e8c:	10c00a1e 	bne	r2,r3,81130eb8 <_strtoll_r+0x2dc>
81130e90:	05000404 	movi	r20,16
81130e94:	8c000043 	ldbu	r16,1(r17)
81130e98:	002f883a 	mov	r23,zero
81130e9c:	8c400084 	addi	r17,r17,2
81130ea0:	a027883a 	mov	r19,r20
81130ea4:	003f7406 	br	81130c78 <__reset+0xfb110c78>
81130ea8:	00e00034 	movhi	r3,32768
81130eac:	18ffffc4 	addi	r3,r3,-1
81130eb0:	5005883a 	mov	r2,r10
81130eb4:	003fda06 	br	81130e20 <__reset+0xfb110e20>
81130eb8:	9829883a 	mov	r20,r19
81130ebc:	002f883a 	mov	r23,zero
81130ec0:	003f6d06 	br	81130c78 <__reset+0xfb110c78>

81130ec4 <_strtoul_r>:
81130ec4:	00a04574 	movhi	r2,33045
81130ec8:	defff604 	addi	sp,sp,-40
81130ecc:	10911104 	addi	r2,r2,17476
81130ed0:	de00012e 	bgeu	sp,et,81130ed8 <_strtoul_r+0x14>
81130ed4:	003b68fa 	trap	3
81130ed8:	dc800315 	stw	r18,12(sp)
81130edc:	14800017 	ldw	r18,0(r2)
81130ee0:	dd400615 	stw	r21,24(sp)
81130ee4:	dd000515 	stw	r20,20(sp)
81130ee8:	dcc00415 	stw	r19,16(sp)
81130eec:	2029883a 	mov	r20,r4
81130ef0:	dfc00915 	stw	ra,36(sp)
81130ef4:	ddc00815 	stw	r23,32(sp)
81130ef8:	dd800715 	stw	r22,28(sp)
81130efc:	dc400215 	stw	r17,8(sp)
81130f00:	dc000115 	stw	r16,4(sp)
81130f04:	2827883a 	mov	r19,r5
81130f08:	382b883a 	mov	r21,r7
81130f0c:	2809883a 	mov	r4,r5
81130f10:	24000003 	ldbu	r16,0(r4)
81130f14:	24400044 	addi	r17,r4,1
81130f18:	2007883a 	mov	r3,r4
81130f1c:	9405883a 	add	r2,r18,r16
81130f20:	10800043 	ldbu	r2,1(r2)
81130f24:	8809883a 	mov	r4,r17
81130f28:	1080020c 	andi	r2,r2,8
81130f2c:	103ff81e 	bne	r2,zero,81130f10 <__reset+0xfb110f10>
81130f30:	00800b44 	movi	r2,45
81130f34:	80805326 	beq	r16,r2,81131084 <_strtoul_r+0x1c0>
81130f38:	00800ac4 	movi	r2,43
81130f3c:	80805526 	beq	r16,r2,81131094 <_strtoul_r+0x1d0>
81130f40:	002f883a 	mov	r23,zero
81130f44:	a8000f26 	beq	r21,zero,81130f84 <_strtoul_r+0xc0>
81130f48:	00800404 	movi	r2,16
81130f4c:	a8805f26 	beq	r21,r2,811310cc <_strtoul_r+0x208>
81130f50:	013fffc4 	movi	r4,-1
81130f54:	a80b883a 	mov	r5,r21
81130f58:	d9800015 	stw	r6,0(sp)
81130f5c:	1135f340 	call	81135f34 <__udivsi3>
81130f60:	a80b883a 	mov	r5,r21
81130f64:	013fffc4 	movi	r4,-1
81130f68:	102d883a 	mov	r22,r2
81130f6c:	1135f980 	call	81135f98 <__umodsi3>
81130f70:	d9800017 	ldw	r6,0(sp)
81130f74:	1019883a 	mov	r12,r2
81130f78:	a817883a 	mov	r11,r21
81130f7c:	b00f883a 	mov	r7,r22
81130f80:	00000706 	br	81130fa0 <_strtoul_r+0xdc>
81130f84:	00800c04 	movi	r2,48
81130f88:	80804626 	beq	r16,r2,811310a4 <_strtoul_r+0x1e0>
81130f8c:	05400284 	movi	r21,10
81130f90:	01c666b4 	movhi	r7,6554
81130f94:	03000144 	movi	r12,5
81130f98:	39e66644 	addi	r7,r7,-26215
81130f9c:	a817883a 	mov	r11,r21
81130fa0:	9407883a 	add	r3,r18,r16
81130fa4:	18c00043 	ldbu	r3,1(r3)
81130fa8:	8809883a 	mov	r4,r17
81130fac:	0011883a 	mov	r8,zero
81130fb0:	1940010c 	andi	r5,r3,4
81130fb4:	0005883a 	mov	r2,zero
81130fb8:	02800044 	movi	r10,1
81130fbc:	027fffc4 	movi	r9,-1
81130fc0:	28000e26 	beq	r5,zero,81130ffc <_strtoul_r+0x138>
81130fc4:	843ff404 	addi	r16,r16,-48
81130fc8:	8540120e 	bge	r16,r21,81131014 <_strtoul_r+0x150>
81130fcc:	42400526 	beq	r8,r9,81130fe4 <_strtoul_r+0x120>
81130fd0:	38802236 	bltu	r7,r2,8113105c <_strtoul_r+0x198>
81130fd4:	11c02026 	beq	r2,r7,81131058 <_strtoul_r+0x194>
81130fd8:	12c5383a 	mul	r2,r2,r11
81130fdc:	02000044 	movi	r8,1
81130fe0:	8085883a 	add	r2,r16,r2
81130fe4:	24000003 	ldbu	r16,0(r4)
81130fe8:	21000044 	addi	r4,r4,1
81130fec:	9407883a 	add	r3,r18,r16
81130ff0:	18c00043 	ldbu	r3,1(r3)
81130ff4:	1940010c 	andi	r5,r3,4
81130ff8:	283ff21e 	bne	r5,zero,81130fc4 <__reset+0xfb110fc4>
81130ffc:	18c000cc 	andi	r3,r3,3
81131000:	18000426 	beq	r3,zero,81131014 <_strtoul_r+0x150>
81131004:	1a801726 	beq	r3,r10,81131064 <_strtoul_r+0x1a0>
81131008:	00c015c4 	movi	r3,87
8113100c:	80e1c83a 	sub	r16,r16,r3
81131010:	857fee16 	blt	r16,r21,81130fcc <__reset+0xfb110fcc>
81131014:	40001516 	blt	r8,zero,8113106c <_strtoul_r+0x1a8>
81131018:	b8000126 	beq	r23,zero,81131020 <_strtoul_r+0x15c>
8113101c:	0085c83a 	sub	r2,zero,r2
81131020:	30000226 	beq	r6,zero,8113102c <_strtoul_r+0x168>
81131024:	4000151e 	bne	r8,zero,8113107c <_strtoul_r+0x1b8>
81131028:	34c00015 	stw	r19,0(r6)
8113102c:	dfc00917 	ldw	ra,36(sp)
81131030:	ddc00817 	ldw	r23,32(sp)
81131034:	dd800717 	ldw	r22,28(sp)
81131038:	dd400617 	ldw	r21,24(sp)
8113103c:	dd000517 	ldw	r20,20(sp)
81131040:	dcc00417 	ldw	r19,16(sp)
81131044:	dc800317 	ldw	r18,12(sp)
81131048:	dc400217 	ldw	r17,8(sp)
8113104c:	dc000117 	ldw	r16,4(sp)
81131050:	dec00a04 	addi	sp,sp,40
81131054:	f800283a 	ret
81131058:	643fdf0e 	bge	r12,r16,81130fd8 <__reset+0xfb110fd8>
8113105c:	023fffc4 	movi	r8,-1
81131060:	003fe006 	br	81130fe4 <__reset+0xfb110fe4>
81131064:	00c00dc4 	movi	r3,55
81131068:	003fe806 	br	8113100c <__reset+0xfb11100c>
8113106c:	00800884 	movi	r2,34
81131070:	a0800015 	stw	r2,0(r20)
81131074:	00bfffc4 	movi	r2,-1
81131078:	303fec26 	beq	r6,zero,8113102c <__reset+0xfb11102c>
8113107c:	24ffffc4 	addi	r19,r4,-1
81131080:	003fe906 	br	81131028 <__reset+0xfb111028>
81131084:	1c400084 	addi	r17,r3,2
81131088:	1c000043 	ldbu	r16,1(r3)
8113108c:	05c00044 	movi	r23,1
81131090:	003fac06 	br	81130f44 <__reset+0xfb110f44>
81131094:	1c400084 	addi	r17,r3,2
81131098:	1c000043 	ldbu	r16,1(r3)
8113109c:	002f883a 	mov	r23,zero
811310a0:	003fa806 	br	81130f44 <__reset+0xfb110f44>
811310a4:	88800003 	ldbu	r2,0(r17)
811310a8:	00c01604 	movi	r3,88
811310ac:	108037cc 	andi	r2,r2,223
811310b0:	10c00c26 	beq	r2,r3,811310e4 <_strtoul_r+0x220>
811310b4:	05400204 	movi	r21,8
811310b8:	01c80034 	movhi	r7,8192
811310bc:	030001c4 	movi	r12,7
811310c0:	39ffffc4 	addi	r7,r7,-1
811310c4:	a817883a 	mov	r11,r21
811310c8:	003fb506 	br	81130fa0 <__reset+0xfb110fa0>
811310cc:	00800c04 	movi	r2,48
811310d0:	80800c1e 	bne	r16,r2,81131104 <_strtoul_r+0x240>
811310d4:	88800003 	ldbu	r2,0(r17)
811310d8:	00c01604 	movi	r3,88
811310dc:	108037cc 	andi	r2,r2,223
811310e0:	10c0081e 	bne	r2,r3,81131104 <_strtoul_r+0x240>
811310e4:	02c00404 	movi	r11,16
811310e8:	05840034 	movhi	r22,4096
811310ec:	8c000043 	ldbu	r16,1(r17)
811310f0:	030003c4 	movi	r12,15
811310f4:	8c400084 	addi	r17,r17,2
811310f8:	b5bfffc4 	addi	r22,r22,-1
811310fc:	582b883a 	mov	r21,r11
81131100:	003f9e06 	br	81130f7c <__reset+0xfb110f7c>
81131104:	01c40034 	movhi	r7,4096
81131108:	030003c4 	movi	r12,15
8113110c:	39ffffc4 	addi	r7,r7,-1
81131110:	a817883a 	mov	r11,r21
81131114:	003fa206 	br	81130fa0 <__reset+0xfb110fa0>

81131118 <strtoul>:
81131118:	00a04574 	movhi	r2,33045
8113111c:	10911304 	addi	r2,r2,17484
81131120:	300f883a 	mov	r7,r6
81131124:	280d883a 	mov	r6,r5
81131128:	200b883a 	mov	r5,r4
8113112c:	11000017 	ldw	r4,0(r2)
81131130:	1130ec41 	jmpi	81130ec4 <_strtoul_r>

81131134 <_strtoull_r>:
81131134:	00a04574 	movhi	r2,33045
81131138:	defff404 	addi	sp,sp,-48
8113113c:	10911104 	addi	r2,r2,17476
81131140:	de00012e 	bgeu	sp,et,81131148 <_strtoull_r+0x14>
81131144:	003b68fa 	trap	3
81131148:	dc400315 	stw	r17,12(sp)
8113114c:	14400017 	ldw	r17,0(r2)
81131150:	dd400715 	stw	r21,28(sp)
81131154:	dd000615 	stw	r20,24(sp)
81131158:	dcc00515 	stw	r19,20(sp)
8113115c:	dc800415 	stw	r18,16(sp)
81131160:	dfc00b15 	stw	ra,44(sp)
81131164:	df000a15 	stw	fp,40(sp)
81131168:	ddc00915 	stw	r23,36(sp)
8113116c:	dd800815 	stw	r22,32(sp)
81131170:	dc000215 	stw	r16,8(sp)
81131174:	2827883a 	mov	r19,r5
81131178:	202b883a 	mov	r21,r4
8113117c:	3029883a 	mov	r20,r6
81131180:	3825883a 	mov	r18,r7
81131184:	2807883a 	mov	r3,r5
81131188:	1c000003 	ldbu	r16,0(r3)
8113118c:	1f000044 	addi	fp,r3,1
81131190:	1809883a 	mov	r4,r3
81131194:	8c05883a 	add	r2,r17,r16
81131198:	10800043 	ldbu	r2,1(r2)
8113119c:	e007883a 	mov	r3,fp
811311a0:	1080020c 	andi	r2,r2,8
811311a4:	103ff81e 	bne	r2,zero,81131188 <__reset+0xfb111188>
811311a8:	00800b44 	movi	r2,45
811311ac:	80806e26 	beq	r16,r2,81131368 <_strtoull_r+0x234>
811311b0:	00800ac4 	movi	r2,43
811311b4:	80807026 	beq	r16,r2,81131378 <_strtoull_r+0x244>
811311b8:	002f883a 	mov	r23,zero
811311bc:	90001426 	beq	r18,zero,81131210 <_strtoull_r+0xdc>
811311c0:	00800404 	movi	r2,16
811311c4:	90807c26 	beq	r18,r2,811313b8 <_strtoull_r+0x284>
811311c8:	902dd7fa 	srai	r22,r18,31
811311cc:	013fffc4 	movi	r4,-1
811311d0:	200b883a 	mov	r5,r4
811311d4:	900d883a 	mov	r6,r18
811311d8:	b00f883a 	mov	r7,r22
811311dc:	113537c0 	call	8113537c <__udivdi3>
811311e0:	013fffc4 	movi	r4,-1
811311e4:	900d883a 	mov	r6,r18
811311e8:	b00f883a 	mov	r7,r22
811311ec:	200b883a 	mov	r5,r4
811311f0:	d8c00115 	stw	r3,4(sp)
811311f4:	d8800015 	stw	r2,0(sp)
811311f8:	11358fc0 	call	811358fc <__umoddi3>
811311fc:	101b883a 	mov	r13,r2
81131200:	9015883a 	mov	r10,r18
81131204:	dac00017 	ldw	r11,0(sp)
81131208:	da000117 	ldw	r8,4(sp)
8113120c:	00000a06 	br	81131238 <_strtoull_r+0x104>
81131210:	00800c04 	movi	r2,48
81131214:	80805c26 	beq	r16,r2,81131388 <_strtoull_r+0x254>
81131218:	02800284 	movi	r10,10
8113121c:	02e666b4 	movhi	r11,39322
81131220:	020666b4 	movhi	r8,6554
81131224:	03400144 	movi	r13,5
81131228:	5ae66644 	addi	r11,r11,-26215
8113122c:	42266644 	addi	r8,r8,-26215
81131230:	002d883a 	mov	r22,zero
81131234:	5025883a 	mov	r18,r10
81131238:	8c0b883a 	add	r5,r17,r16
8113123c:	29400043 	ldbu	r5,1(r5)
81131240:	e009883a 	mov	r4,fp
81131244:	000f883a 	mov	r7,zero
81131248:	2980010c 	andi	r6,r5,4
8113124c:	0005883a 	mov	r2,zero
81131250:	0007883a 	mov	r3,zero
81131254:	03000044 	movi	r12,1
81131258:	027fffc4 	movi	r9,-1
8113125c:	30000d26 	beq	r6,zero,81131294 <_strtoull_r+0x160>
81131260:	843ff404 	addi	r16,r16,-48
81131264:	8480110e 	bge	r16,r18,811312ac <_strtoull_r+0x178>
81131268:	3a400426 	beq	r7,r9,8113127c <_strtoull_r+0x148>
8113126c:	40c00236 	bltu	r8,r3,81131278 <_strtoull_r+0x144>
81131270:	1a00231e 	bne	r3,r8,81131300 <_strtoull_r+0x1cc>
81131274:	5880222e 	bgeu	r11,r2,81131300 <_strtoull_r+0x1cc>
81131278:	01ffffc4 	movi	r7,-1
8113127c:	24000003 	ldbu	r16,0(r4)
81131280:	21000044 	addi	r4,r4,1
81131284:	8c0b883a 	add	r5,r17,r16
81131288:	29400043 	ldbu	r5,1(r5)
8113128c:	2980010c 	andi	r6,r5,4
81131290:	303ff31e 	bne	r6,zero,81131260 <__reset+0xfb111260>
81131294:	294000cc 	andi	r5,r5,3
81131298:	28000426 	beq	r5,zero,811312ac <_strtoull_r+0x178>
8113129c:	2b002626 	beq	r5,r12,81131338 <_strtoull_r+0x204>
811312a0:	014015c4 	movi	r5,87
811312a4:	8161c83a 	sub	r16,r16,r5
811312a8:	84bfef16 	blt	r16,r18,81131268 <__reset+0xfb111268>
811312ac:	38002716 	blt	r7,zero,8113134c <_strtoull_r+0x218>
811312b0:	b8000426 	beq	r23,zero,811312c4 <_strtoull_r+0x190>
811312b4:	0085c83a 	sub	r2,zero,r2
811312b8:	100ac03a 	cmpne	r5,r2,zero
811312bc:	00e1c83a 	sub	r16,zero,r3
811312c0:	8147c83a 	sub	r3,r16,r5
811312c4:	a0000226 	beq	r20,zero,811312d0 <_strtoull_r+0x19c>
811312c8:	3800251e 	bne	r7,zero,81131360 <_strtoull_r+0x22c>
811312cc:	a4c00015 	stw	r19,0(r20)
811312d0:	dfc00b17 	ldw	ra,44(sp)
811312d4:	df000a17 	ldw	fp,40(sp)
811312d8:	ddc00917 	ldw	r23,36(sp)
811312dc:	dd800817 	ldw	r22,32(sp)
811312e0:	dd400717 	ldw	r21,28(sp)
811312e4:	dd000617 	ldw	r20,24(sp)
811312e8:	dcc00517 	ldw	r19,20(sp)
811312ec:	dc800417 	ldw	r18,16(sp)
811312f0:	dc400317 	ldw	r17,12(sp)
811312f4:	dc000217 	ldw	r16,8(sp)
811312f8:	dec00c04 	addi	sp,sp,48
811312fc:	f800283a 	ret
81131300:	12c00f26 	beq	r2,r11,81131340 <_strtoull_r+0x20c>
81131304:	b08d383a 	mul	r6,r22,r2
81131308:	1a87383a 	mul	r3,r3,r10
8113130c:	128a383a 	mulxuu	r5,r2,r10
81131310:	1285383a 	mul	r2,r2,r10
81131314:	800fd7fa 	srai	r7,r16,31
81131318:	1987883a 	add	r3,r3,r6
8113131c:	8085883a 	add	r2,r16,r2
81131320:	1947883a 	add	r3,r3,r5
81131324:	38c7883a 	add	r3,r7,r3
81131328:	1421803a 	cmpltu	r16,r2,r16
8113132c:	80c7883a 	add	r3,r16,r3
81131330:	01c00044 	movi	r7,1
81131334:	003fd106 	br	8113127c <__reset+0xfb11127c>
81131338:	01400dc4 	movi	r5,55
8113133c:	003fd906 	br	811312a4 <__reset+0xfb1112a4>
81131340:	1a3ff01e 	bne	r3,r8,81131304 <__reset+0xfb111304>
81131344:	6c3fcc16 	blt	r13,r16,81131278 <__reset+0xfb111278>
81131348:	003fee06 	br	81131304 <__reset+0xfb111304>
8113134c:	00800884 	movi	r2,34
81131350:	a8800015 	stw	r2,0(r21)
81131354:	00bfffc4 	movi	r2,-1
81131358:	1007883a 	mov	r3,r2
8113135c:	a03fdc26 	beq	r20,zero,811312d0 <__reset+0xfb1112d0>
81131360:	24ffffc4 	addi	r19,r4,-1
81131364:	003fd906 	br	811312cc <__reset+0xfb1112cc>
81131368:	27000084 	addi	fp,r4,2
8113136c:	24000043 	ldbu	r16,1(r4)
81131370:	05c00044 	movi	r23,1
81131374:	003f9106 	br	811311bc <__reset+0xfb1111bc>
81131378:	27000084 	addi	fp,r4,2
8113137c:	24000043 	ldbu	r16,1(r4)
81131380:	002f883a 	mov	r23,zero
81131384:	003f8d06 	br	811311bc <__reset+0xfb1111bc>
81131388:	e0800003 	ldbu	r2,0(fp)
8113138c:	00c01604 	movi	r3,88
81131390:	108037cc 	andi	r2,r2,223
81131394:	10c00e26 	beq	r2,r3,811313d0 <_strtoull_r+0x29c>
81131398:	02800204 	movi	r10,8
8113139c:	02ffffc4 	movi	r11,-1
811313a0:	02080034 	movhi	r8,8192
811313a4:	034001c4 	movi	r13,7
811313a8:	42d1883a 	add	r8,r8,r11
811313ac:	002d883a 	mov	r22,zero
811313b0:	5025883a 	mov	r18,r10
811313b4:	003fa006 	br	81131238 <__reset+0xfb111238>
811313b8:	00800c04 	movi	r2,48
811313bc:	80800e1e 	bne	r16,r2,811313f8 <_strtoull_r+0x2c4>
811313c0:	e0800003 	ldbu	r2,0(fp)
811313c4:	00c01604 	movi	r3,88
811313c8:	108037cc 	andi	r2,r2,223
811313cc:	10c00a1e 	bne	r2,r3,811313f8 <_strtoull_r+0x2c4>
811313d0:	02800404 	movi	r10,16
811313d4:	02ffffc4 	movi	r11,-1
811313d8:	02040034 	movhi	r8,4096
811313dc:	e4000043 	ldbu	r16,1(fp)
811313e0:	034003c4 	movi	r13,15
811313e4:	e7000084 	addi	fp,fp,2
811313e8:	42d1883a 	add	r8,r8,r11
811313ec:	002d883a 	mov	r22,zero
811313f0:	5025883a 	mov	r18,r10
811313f4:	003f9006 	br	81131238 <__reset+0xfb111238>
811313f8:	02ffffc4 	movi	r11,-1
811313fc:	02040034 	movhi	r8,4096
81131400:	034003c4 	movi	r13,15
81131404:	42d1883a 	add	r8,r8,r11
81131408:	9015883a 	mov	r10,r18
8113140c:	002d883a 	mov	r22,zero
81131410:	003f8906 	br	81131238 <__reset+0xfb111238>

81131414 <__ssprint_r>:
81131414:	defff604 	addi	sp,sp,-40
81131418:	de00012e 	bgeu	sp,et,81131420 <__ssprint_r+0xc>
8113141c:	003b68fa 	trap	3
81131420:	30800217 	ldw	r2,8(r6)
81131424:	dc800215 	stw	r18,8(sp)
81131428:	dfc00915 	stw	ra,36(sp)
8113142c:	df000815 	stw	fp,32(sp)
81131430:	ddc00715 	stw	r23,28(sp)
81131434:	dd800615 	stw	r22,24(sp)
81131438:	dd400515 	stw	r21,20(sp)
8113143c:	dd000415 	stw	r20,16(sp)
81131440:	dcc00315 	stw	r19,12(sp)
81131444:	dc400115 	stw	r17,4(sp)
81131448:	dc000015 	stw	r16,0(sp)
8113144c:	3025883a 	mov	r18,r6
81131450:	10005826 	beq	r2,zero,811315b4 <__ssprint_r+0x1a0>
81131454:	2027883a 	mov	r19,r4
81131458:	35c00017 	ldw	r23,0(r6)
8113145c:	29000017 	ldw	r4,0(r5)
81131460:	28800217 	ldw	r2,8(r5)
81131464:	2823883a 	mov	r17,r5
81131468:	0039883a 	mov	fp,zero
8113146c:	0021883a 	mov	r16,zero
81131470:	80003926 	beq	r16,zero,81131558 <__ssprint_r+0x144>
81131474:	102b883a 	mov	r21,r2
81131478:	102d883a 	mov	r22,r2
8113147c:	80803a36 	bltu	r16,r2,81131568 <__ssprint_r+0x154>
81131480:	88c0030b 	ldhu	r3,12(r17)
81131484:	1881200c 	andi	r2,r3,1152
81131488:	10002626 	beq	r2,zero,81131524 <__ssprint_r+0x110>
8113148c:	88800517 	ldw	r2,20(r17)
81131490:	89400417 	ldw	r5,16(r17)
81131494:	81800044 	addi	r6,r16,1
81131498:	108f883a 	add	r7,r2,r2
8113149c:	3885883a 	add	r2,r7,r2
811314a0:	100ed7fa 	srli	r7,r2,31
811314a4:	216dc83a 	sub	r22,r4,r5
811314a8:	3589883a 	add	r4,r6,r22
811314ac:	3885883a 	add	r2,r7,r2
811314b0:	102bd07a 	srai	r21,r2,1
811314b4:	a80d883a 	mov	r6,r21
811314b8:	a900022e 	bgeu	r21,r4,811314c4 <__ssprint_r+0xb0>
811314bc:	202b883a 	mov	r21,r4
811314c0:	200d883a 	mov	r6,r4
811314c4:	18c1000c 	andi	r3,r3,1024
811314c8:	18002a26 	beq	r3,zero,81131574 <__ssprint_r+0x160>
811314cc:	300b883a 	mov	r5,r6
811314d0:	9809883a 	mov	r4,r19
811314d4:	11232300 	call	81123230 <_malloc_r>
811314d8:	1029883a 	mov	r20,r2
811314dc:	10002c26 	beq	r2,zero,81131590 <__ssprint_r+0x17c>
811314e0:	89400417 	ldw	r5,16(r17)
811314e4:	b00d883a 	mov	r6,r22
811314e8:	1009883a 	mov	r4,r2
811314ec:	1123a440 	call	81123a44 <memcpy>
811314f0:	8880030b 	ldhu	r2,12(r17)
811314f4:	00fedfc4 	movi	r3,-1153
811314f8:	10c4703a 	and	r2,r2,r3
811314fc:	10802014 	ori	r2,r2,128
81131500:	8880030d 	sth	r2,12(r17)
81131504:	a589883a 	add	r4,r20,r22
81131508:	adadc83a 	sub	r22,r21,r22
8113150c:	8d400515 	stw	r21,20(r17)
81131510:	8d800215 	stw	r22,8(r17)
81131514:	8d000415 	stw	r20,16(r17)
81131518:	89000015 	stw	r4,0(r17)
8113151c:	802b883a 	mov	r21,r16
81131520:	802d883a 	mov	r22,r16
81131524:	b00d883a 	mov	r6,r22
81131528:	e00b883a 	mov	r5,fp
8113152c:	112da9c0 	call	8112da9c <memmove>
81131530:	88800217 	ldw	r2,8(r17)
81131534:	89000017 	ldw	r4,0(r17)
81131538:	90c00217 	ldw	r3,8(r18)
8113153c:	1545c83a 	sub	r2,r2,r21
81131540:	2589883a 	add	r4,r4,r22
81131544:	88800215 	stw	r2,8(r17)
81131548:	89000015 	stw	r4,0(r17)
8113154c:	1c21c83a 	sub	r16,r3,r16
81131550:	94000215 	stw	r16,8(r18)
81131554:	80001726 	beq	r16,zero,811315b4 <__ssprint_r+0x1a0>
81131558:	bf000017 	ldw	fp,0(r23)
8113155c:	bc000117 	ldw	r16,4(r23)
81131560:	bdc00204 	addi	r23,r23,8
81131564:	003fc206 	br	81131470 <__reset+0xfb111470>
81131568:	802b883a 	mov	r21,r16
8113156c:	802d883a 	mov	r22,r16
81131570:	003fec06 	br	81131524 <__reset+0xfb111524>
81131574:	9809883a 	mov	r4,r19
81131578:	112ecbc0 	call	8112ecbc <_realloc_r>
8113157c:	1029883a 	mov	r20,r2
81131580:	103fe01e 	bne	r2,zero,81131504 <__reset+0xfb111504>
81131584:	89400417 	ldw	r5,16(r17)
81131588:	9809883a 	mov	r4,r19
8113158c:	112cc280 	call	8112cc28 <_free_r>
81131590:	88c0030b 	ldhu	r3,12(r17)
81131594:	00800304 	movi	r2,12
81131598:	98800015 	stw	r2,0(r19)
8113159c:	18c01014 	ori	r3,r3,64
811315a0:	88c0030d 	sth	r3,12(r17)
811315a4:	00bfffc4 	movi	r2,-1
811315a8:	90000215 	stw	zero,8(r18)
811315ac:	90000115 	stw	zero,4(r18)
811315b0:	00000206 	br	811315bc <__ssprint_r+0x1a8>
811315b4:	90000115 	stw	zero,4(r18)
811315b8:	0005883a 	mov	r2,zero
811315bc:	dfc00917 	ldw	ra,36(sp)
811315c0:	df000817 	ldw	fp,32(sp)
811315c4:	ddc00717 	ldw	r23,28(sp)
811315c8:	dd800617 	ldw	r22,24(sp)
811315cc:	dd400517 	ldw	r21,20(sp)
811315d0:	dd000417 	ldw	r20,16(sp)
811315d4:	dcc00317 	ldw	r19,12(sp)
811315d8:	dc800217 	ldw	r18,8(sp)
811315dc:	dc400117 	ldw	r17,4(sp)
811315e0:	dc000017 	ldw	r16,0(sp)
811315e4:	dec00a04 	addi	sp,sp,40
811315e8:	f800283a 	ret

811315ec <___svfiprintf_internal_r>:
811315ec:	deffc804 	addi	sp,sp,-224
811315f0:	de00012e 	bgeu	sp,et,811315f8 <___svfiprintf_internal_r+0xc>
811315f4:	003b68fa 	trap	3
811315f8:	2880030b 	ldhu	r2,12(r5)
811315fc:	dcc03115 	stw	r19,196(sp)
81131600:	dfc03715 	stw	ra,220(sp)
81131604:	df003615 	stw	fp,216(sp)
81131608:	ddc03515 	stw	r23,212(sp)
8113160c:	dd803415 	stw	r22,208(sp)
81131610:	dd403315 	stw	r21,204(sp)
81131614:	dd003215 	stw	r20,200(sp)
81131618:	dc803015 	stw	r18,192(sp)
8113161c:	dc402f15 	stw	r17,188(sp)
81131620:	dc002e15 	stw	r16,184(sp)
81131624:	d9402715 	stw	r5,156(sp)
81131628:	d9002a15 	stw	r4,168(sp)
8113162c:	1080200c 	andi	r2,r2,128
81131630:	d9c02315 	stw	r7,140(sp)
81131634:	3027883a 	mov	r19,r6
81131638:	10000226 	beq	r2,zero,81131644 <___svfiprintf_internal_r+0x58>
8113163c:	28800417 	ldw	r2,16(r5)
81131640:	10041d26 	beq	r2,zero,811326b8 <___svfiprintf_internal_r+0x10cc>
81131644:	dac01a04 	addi	r11,sp,104
81131648:	dac01e15 	stw	r11,120(sp)
8113164c:	d8801e17 	ldw	r2,120(sp)
81131650:	dac019c4 	addi	r11,sp,103
81131654:	dd402a17 	ldw	r21,168(sp)
81131658:	ddc02717 	ldw	r23,156(sp)
8113165c:	05a04574 	movhi	r22,33045
81131660:	05204574 	movhi	r20,33045
81131664:	dac01f15 	stw	r11,124(sp)
81131668:	12d7c83a 	sub	r11,r2,r11
8113166c:	b587d204 	addi	r22,r22,8008
81131670:	a507ce04 	addi	r20,r20,7992
81131674:	dec01a15 	stw	sp,104(sp)
81131678:	d8001c15 	stw	zero,112(sp)
8113167c:	d8001b15 	stw	zero,108(sp)
81131680:	d811883a 	mov	r8,sp
81131684:	d8002915 	stw	zero,164(sp)
81131688:	d8002515 	stw	zero,148(sp)
8113168c:	dac02b15 	stw	r11,172(sp)
81131690:	98800007 	ldb	r2,0(r19)
81131694:	1002dd26 	beq	r2,zero,8113220c <___svfiprintf_internal_r+0xc20>
81131698:	00c00944 	movi	r3,37
8113169c:	9823883a 	mov	r17,r19
811316a0:	10c0021e 	bne	r2,r3,811316ac <___svfiprintf_internal_r+0xc0>
811316a4:	00001406 	br	811316f8 <___svfiprintf_internal_r+0x10c>
811316a8:	10c00326 	beq	r2,r3,811316b8 <___svfiprintf_internal_r+0xcc>
811316ac:	8c400044 	addi	r17,r17,1
811316b0:	88800007 	ldb	r2,0(r17)
811316b4:	103ffc1e 	bne	r2,zero,811316a8 <__reset+0xfb1116a8>
811316b8:	8ce1c83a 	sub	r16,r17,r19
811316bc:	80000e26 	beq	r16,zero,811316f8 <___svfiprintf_internal_r+0x10c>
811316c0:	d8c01c17 	ldw	r3,112(sp)
811316c4:	d8801b17 	ldw	r2,108(sp)
811316c8:	44c00015 	stw	r19,0(r8)
811316cc:	1c07883a 	add	r3,r3,r16
811316d0:	10800044 	addi	r2,r2,1
811316d4:	d8c01c15 	stw	r3,112(sp)
811316d8:	44000115 	stw	r16,4(r8)
811316dc:	d8801b15 	stw	r2,108(sp)
811316e0:	00c001c4 	movi	r3,7
811316e4:	18831e16 	blt	r3,r2,81132360 <___svfiprintf_internal_r+0xd74>
811316e8:	42000204 	addi	r8,r8,8
811316ec:	dac02517 	ldw	r11,148(sp)
811316f0:	5c17883a 	add	r11,r11,r16
811316f4:	dac02515 	stw	r11,148(sp)
811316f8:	88800007 	ldb	r2,0(r17)
811316fc:	1002c526 	beq	r2,zero,81132214 <___svfiprintf_internal_r+0xc28>
81131700:	88c00047 	ldb	r3,1(r17)
81131704:	8cc00044 	addi	r19,r17,1
81131708:	d8001d85 	stb	zero,118(sp)
8113170c:	0009883a 	mov	r4,zero
81131710:	000f883a 	mov	r7,zero
81131714:	043fffc4 	movi	r16,-1
81131718:	d8002415 	stw	zero,144(sp)
8113171c:	0025883a 	mov	r18,zero
81131720:	01401604 	movi	r5,88
81131724:	01800244 	movi	r6,9
81131728:	02800a84 	movi	r10,42
8113172c:	02401b04 	movi	r9,108
81131730:	9cc00044 	addi	r19,r19,1
81131734:	18bff804 	addi	r2,r3,-32
81131738:	2881dd36 	bltu	r5,r2,81131eb0 <___svfiprintf_internal_r+0x8c4>
8113173c:	100490ba 	slli	r2,r2,2
81131740:	02e044f4 	movhi	r11,33043
81131744:	5ac5d504 	addi	r11,r11,5972
81131748:	12c5883a 	add	r2,r2,r11
8113174c:	10800017 	ldw	r2,0(r2)
81131750:	1000683a 	jmp	r2
81131754:	81131950 	cmplti	r4,r16,19557
81131758:	81131eb0 	cmpltui	r4,r16,19578
8113175c:	81131eb0 	cmpltui	r4,r16,19578
81131760:	81131944 	addi	r4,r16,19557
81131764:	81131eb0 	cmpltui	r4,r16,19578
81131768:	81131eb0 	cmpltui	r4,r16,19578
8113176c:	81131eb0 	cmpltui	r4,r16,19578
81131770:	81131eb0 	cmpltui	r4,r16,19578
81131774:	81131eb0 	cmpltui	r4,r16,19578
81131778:	81131eb0 	cmpltui	r4,r16,19578
8113177c:	811318b8 	rdprs	r4,r16,19554
81131780:	81131a94 	ori	r4,r16,19562
81131784:	81131eb0 	cmpltui	r4,r16,19578
81131788:	811318e4 	muli	r4,r16,19555
8113178c:	81131ee4 	muli	r4,r16,19579
81131790:	81131eb0 	cmpltui	r4,r16,19578
81131794:	81131ed8 	cmpnei	r4,r16,19579
81131798:	81131e78 	rdprs	r4,r16,19577
8113179c:	81131e78 	rdprs	r4,r16,19577
811317a0:	81131e78 	rdprs	r4,r16,19577
811317a4:	81131e78 	rdprs	r4,r16,19577
811317a8:	81131e78 	rdprs	r4,r16,19577
811317ac:	81131e78 	rdprs	r4,r16,19577
811317b0:	81131e78 	rdprs	r4,r16,19577
811317b4:	81131e78 	rdprs	r4,r16,19577
811317b8:	81131e78 	rdprs	r4,r16,19577
811317bc:	81131eb0 	cmpltui	r4,r16,19578
811317c0:	81131eb0 	cmpltui	r4,r16,19578
811317c4:	81131eb0 	cmpltui	r4,r16,19578
811317c8:	81131eb0 	cmpltui	r4,r16,19578
811317cc:	81131eb0 	cmpltui	r4,r16,19578
811317d0:	81131eb0 	cmpltui	r4,r16,19578
811317d4:	81131eb0 	cmpltui	r4,r16,19578
811317d8:	81131eb0 	cmpltui	r4,r16,19578
811317dc:	81131eb0 	cmpltui	r4,r16,19578
811317e0:	81131eb0 	cmpltui	r4,r16,19578
811317e4:	81131e14 	ori	r4,r16,19576
811317e8:	81131eb0 	cmpltui	r4,r16,19578
811317ec:	81131eb0 	cmpltui	r4,r16,19578
811317f0:	81131eb0 	cmpltui	r4,r16,19578
811317f4:	81131eb0 	cmpltui	r4,r16,19578
811317f8:	81131eb0 	cmpltui	r4,r16,19578
811317fc:	81131eb0 	cmpltui	r4,r16,19578
81131800:	81131eb0 	cmpltui	r4,r16,19578
81131804:	81131eb0 	cmpltui	r4,r16,19578
81131808:	81131eb0 	cmpltui	r4,r16,19578
8113180c:	81131eb0 	cmpltui	r4,r16,19578
81131810:	81131f8c 	andi	r4,r16,19582
81131814:	81131eb0 	cmpltui	r4,r16,19578
81131818:	81131eb0 	cmpltui	r4,r16,19578
8113181c:	81131eb0 	cmpltui	r4,r16,19578
81131820:	81131eb0 	cmpltui	r4,r16,19578
81131824:	81131eb0 	cmpltui	r4,r16,19578
81131828:	81131f24 	muli	r4,r16,19580
8113182c:	81131eb0 	cmpltui	r4,r16,19578
81131830:	81131eb0 	cmpltui	r4,r16,19578
81131834:	81131c58 	cmpnei	r4,r16,19569
81131838:	81131eb0 	cmpltui	r4,r16,19578
8113183c:	81131eb0 	cmpltui	r4,r16,19578
81131840:	81131eb0 	cmpltui	r4,r16,19578
81131844:	81131eb0 	cmpltui	r4,r16,19578
81131848:	81131eb0 	cmpltui	r4,r16,19578
8113184c:	81131eb0 	cmpltui	r4,r16,19578
81131850:	81131eb0 	cmpltui	r4,r16,19578
81131854:	81131eb0 	cmpltui	r4,r16,19578
81131858:	81131eb0 	cmpltui	r4,r16,19578
8113185c:	81131eb0 	cmpltui	r4,r16,19578
81131860:	81131b48 	cmpgei	r4,r16,19565
81131864:	81131cf4 	orhi	r4,r16,19571
81131868:	81131eb0 	cmpltui	r4,r16,19578
8113186c:	81131eb0 	cmpltui	r4,r16,19578
81131870:	81131eb0 	cmpltui	r4,r16,19578
81131874:	81131ce8 	cmpgeui	r4,r16,19571
81131878:	81131cf4 	orhi	r4,r16,19571
8113187c:	81131eb0 	cmpltui	r4,r16,19578
81131880:	81131eb0 	cmpltui	r4,r16,19578
81131884:	81131cd8 	cmpnei	r4,r16,19571
81131888:	81131eb0 	cmpltui	r4,r16,19578
8113188c:	81131c9c 	xori	r4,r16,19570
81131890:	81131aa4 	muli	r4,r16,19562
81131894:	811318f0 	cmpltui	r4,r16,19555
81131898:	81131e08 	cmpgei	r4,r16,19576
8113189c:	81131eb0 	cmpltui	r4,r16,19578
811318a0:	81131dbc 	xorhi	r4,r16,19574
811318a4:	81131eb0 	cmpltui	r4,r16,19578
811318a8:	81131a14 	ori	r4,r16,19560
811318ac:	81131eb0 	cmpltui	r4,r16,19578
811318b0:	81131eb0 	cmpltui	r4,r16,19578
811318b4:	81131970 	cmpltui	r4,r16,19557
811318b8:	dac02317 	ldw	r11,140(sp)
811318bc:	5ac00017 	ldw	r11,0(r11)
811318c0:	dac02415 	stw	r11,144(sp)
811318c4:	dac02317 	ldw	r11,140(sp)
811318c8:	58800104 	addi	r2,r11,4
811318cc:	dac02417 	ldw	r11,144(sp)
811318d0:	5802e90e 	bge	r11,zero,81132478 <___svfiprintf_internal_r+0xe8c>
811318d4:	dac02417 	ldw	r11,144(sp)
811318d8:	d8802315 	stw	r2,140(sp)
811318dc:	02d7c83a 	sub	r11,zero,r11
811318e0:	dac02415 	stw	r11,144(sp)
811318e4:	94800114 	ori	r18,r18,4
811318e8:	98c00007 	ldb	r3,0(r19)
811318ec:	003f9006 	br	81131730 <__reset+0xfb111730>
811318f0:	00800c04 	movi	r2,48
811318f4:	dac02317 	ldw	r11,140(sp)
811318f8:	d8801d05 	stb	r2,116(sp)
811318fc:	00801e04 	movi	r2,120
81131900:	d8801d45 	stb	r2,117(sp)
81131904:	d8001d85 	stb	zero,118(sp)
81131908:	58c00104 	addi	r3,r11,4
8113190c:	5f000017 	ldw	fp,0(r11)
81131910:	0013883a 	mov	r9,zero
81131914:	90800094 	ori	r2,r18,2
81131918:	80032b16 	blt	r16,zero,811325c8 <___svfiprintf_internal_r+0xfdc>
8113191c:	00bfdfc4 	movi	r2,-129
81131920:	90a4703a 	and	r18,r18,r2
81131924:	d8c02315 	stw	r3,140(sp)
81131928:	94800094 	ori	r18,r18,2
8113192c:	e002dc26 	beq	fp,zero,811324a0 <___svfiprintf_internal_r+0xeb4>
81131930:	01204574 	movhi	r4,33045
81131934:	21074404 	addi	r4,r4,7440
81131938:	0015883a 	mov	r10,zero
8113193c:	d9002915 	stw	r4,164(sp)
81131940:	00002306 	br	811319d0 <___svfiprintf_internal_r+0x3e4>
81131944:	94800054 	ori	r18,r18,1
81131948:	98c00007 	ldb	r3,0(r19)
8113194c:	003f7806 	br	81131730 <__reset+0xfb111730>
81131950:	38803fcc 	andi	r2,r7,255
81131954:	1080201c 	xori	r2,r2,128
81131958:	10bfe004 	addi	r2,r2,-128
8113195c:	1002f31e 	bne	r2,zero,8113252c <___svfiprintf_internal_r+0xf40>
81131960:	01000044 	movi	r4,1
81131964:	01c00804 	movi	r7,32
81131968:	98c00007 	ldb	r3,0(r19)
8113196c:	003f7006 	br	81131730 <__reset+0xfb111730>
81131970:	21003fcc 	andi	r4,r4,255
81131974:	2003aa1e 	bne	r4,zero,81132820 <___svfiprintf_internal_r+0x1234>
81131978:	00a04574 	movhi	r2,33045
8113197c:	10874404 	addi	r2,r2,7440
81131980:	d8802915 	stw	r2,164(sp)
81131984:	9080080c 	andi	r2,r18,32
81131988:	1000ba26 	beq	r2,zero,81131c74 <___svfiprintf_internal_r+0x688>
8113198c:	dac02317 	ldw	r11,140(sp)
81131990:	5f000017 	ldw	fp,0(r11)
81131994:	5a400117 	ldw	r9,4(r11)
81131998:	5ac00204 	addi	r11,r11,8
8113199c:	dac02315 	stw	r11,140(sp)
811319a0:	9080004c 	andi	r2,r18,1
811319a4:	10029026 	beq	r2,zero,811323e8 <___svfiprintf_internal_r+0xdfc>
811319a8:	e244b03a 	or	r2,fp,r9
811319ac:	1002d41e 	bne	r2,zero,81132500 <___svfiprintf_internal_r+0xf14>
811319b0:	d8001d85 	stb	zero,118(sp)
811319b4:	80030b16 	blt	r16,zero,811325e4 <___svfiprintf_internal_r+0xff8>
811319b8:	00bfdfc4 	movi	r2,-129
811319bc:	90a4703a 	and	r18,r18,r2
811319c0:	0015883a 	mov	r10,zero
811319c4:	80002426 	beq	r16,zero,81131a58 <___svfiprintf_internal_r+0x46c>
811319c8:	0039883a 	mov	fp,zero
811319cc:	0013883a 	mov	r9,zero
811319d0:	d9002917 	ldw	r4,164(sp)
811319d4:	dc401a04 	addi	r17,sp,104
811319d8:	e08003cc 	andi	r2,fp,15
811319dc:	4806973a 	slli	r3,r9,28
811319e0:	2085883a 	add	r2,r4,r2
811319e4:	e038d13a 	srli	fp,fp,4
811319e8:	10800003 	ldbu	r2,0(r2)
811319ec:	4812d13a 	srli	r9,r9,4
811319f0:	8c7fffc4 	addi	r17,r17,-1
811319f4:	1f38b03a 	or	fp,r3,fp
811319f8:	88800005 	stb	r2,0(r17)
811319fc:	e244b03a 	or	r2,fp,r9
81131a00:	103ff51e 	bne	r2,zero,811319d8 <__reset+0xfb1119d8>
81131a04:	dac01e17 	ldw	r11,120(sp)
81131a08:	5c57c83a 	sub	r11,r11,r17
81131a0c:	dac02115 	stw	r11,132(sp)
81131a10:	00001406 	br	81131a64 <___svfiprintf_internal_r+0x478>
81131a14:	21003fcc 	andi	r4,r4,255
81131a18:	2003741e 	bne	r4,zero,811327ec <___svfiprintf_internal_r+0x1200>
81131a1c:	9080080c 	andi	r2,r18,32
81131a20:	10014526 	beq	r2,zero,81131f38 <___svfiprintf_internal_r+0x94c>
81131a24:	dac02317 	ldw	r11,140(sp)
81131a28:	d8001d85 	stb	zero,118(sp)
81131a2c:	58c00204 	addi	r3,r11,8
81131a30:	5f000017 	ldw	fp,0(r11)
81131a34:	5a400117 	ldw	r9,4(r11)
81131a38:	8002d916 	blt	r16,zero,811325a0 <___svfiprintf_internal_r+0xfb4>
81131a3c:	013fdfc4 	movi	r4,-129
81131a40:	e244b03a 	or	r2,fp,r9
81131a44:	d8c02315 	stw	r3,140(sp)
81131a48:	9124703a 	and	r18,r18,r4
81131a4c:	0015883a 	mov	r10,zero
81131a50:	1000b91e 	bne	r2,zero,81131d38 <___svfiprintf_internal_r+0x74c>
81131a54:	8002e61e 	bne	r16,zero,811325f0 <___svfiprintf_internal_r+0x1004>
81131a58:	0021883a 	mov	r16,zero
81131a5c:	d8002115 	stw	zero,132(sp)
81131a60:	dc401a04 	addi	r17,sp,104
81131a64:	d8c02117 	ldw	r3,132(sp)
81131a68:	dc002015 	stw	r16,128(sp)
81131a6c:	80c0010e 	bge	r16,r3,81131a74 <___svfiprintf_internal_r+0x488>
81131a70:	d8c02015 	stw	r3,128(sp)
81131a74:	52803fcc 	andi	r10,r10,255
81131a78:	5280201c 	xori	r10,r10,128
81131a7c:	52bfe004 	addi	r10,r10,-128
81131a80:	50003c26 	beq	r10,zero,81131b74 <___svfiprintf_internal_r+0x588>
81131a84:	dac02017 	ldw	r11,128(sp)
81131a88:	5ac00044 	addi	r11,r11,1
81131a8c:	dac02015 	stw	r11,128(sp)
81131a90:	00003806 	br	81131b74 <___svfiprintf_internal_r+0x588>
81131a94:	01000044 	movi	r4,1
81131a98:	01c00ac4 	movi	r7,43
81131a9c:	98c00007 	ldb	r3,0(r19)
81131aa0:	003f2306 	br	81131730 <__reset+0xfb111730>
81131aa4:	21003fcc 	andi	r4,r4,255
81131aa8:	2003481e 	bne	r4,zero,811327cc <___svfiprintf_internal_r+0x11e0>
81131aac:	9080080c 	andi	r2,r18,32
81131ab0:	10013b26 	beq	r2,zero,81131fa0 <___svfiprintf_internal_r+0x9b4>
81131ab4:	dac02317 	ldw	r11,140(sp)
81131ab8:	d8001d85 	stb	zero,118(sp)
81131abc:	58800204 	addi	r2,r11,8
81131ac0:	5f000017 	ldw	fp,0(r11)
81131ac4:	5a400117 	ldw	r9,4(r11)
81131ac8:	8002a816 	blt	r16,zero,8113256c <___svfiprintf_internal_r+0xf80>
81131acc:	013fdfc4 	movi	r4,-129
81131ad0:	e246b03a 	or	r3,fp,r9
81131ad4:	d8802315 	stw	r2,140(sp)
81131ad8:	9124703a 	and	r18,r18,r4
81131adc:	18013c26 	beq	r3,zero,81131fd0 <___svfiprintf_internal_r+0x9e4>
81131ae0:	0015883a 	mov	r10,zero
81131ae4:	dc401a04 	addi	r17,sp,104
81131ae8:	e006d0fa 	srli	r3,fp,3
81131aec:	4808977a 	slli	r4,r9,29
81131af0:	4812d0fa 	srli	r9,r9,3
81131af4:	e70001cc 	andi	fp,fp,7
81131af8:	e0800c04 	addi	r2,fp,48
81131afc:	8c7fffc4 	addi	r17,r17,-1
81131b00:	20f8b03a 	or	fp,r4,r3
81131b04:	88800005 	stb	r2,0(r17)
81131b08:	e246b03a 	or	r3,fp,r9
81131b0c:	183ff61e 	bne	r3,zero,81131ae8 <__reset+0xfb111ae8>
81131b10:	90c0004c 	andi	r3,r18,1
81131b14:	1800a526 	beq	r3,zero,81131dac <___svfiprintf_internal_r+0x7c0>
81131b18:	10803fcc 	andi	r2,r2,255
81131b1c:	1080201c 	xori	r2,r2,128
81131b20:	10bfe004 	addi	r2,r2,-128
81131b24:	00c00c04 	movi	r3,48
81131b28:	10ffb626 	beq	r2,r3,81131a04 <__reset+0xfb111a04>
81131b2c:	88ffffc5 	stb	r3,-1(r17)
81131b30:	d8c01e17 	ldw	r3,120(sp)
81131b34:	88bfffc4 	addi	r2,r17,-1
81131b38:	1023883a 	mov	r17,r2
81131b3c:	1887c83a 	sub	r3,r3,r2
81131b40:	d8c02115 	stw	r3,132(sp)
81131b44:	003fc706 	br	81131a64 <__reset+0xfb111a64>
81131b48:	dac02317 	ldw	r11,140(sp)
81131b4c:	00c00044 	movi	r3,1
81131b50:	d8c02015 	stw	r3,128(sp)
81131b54:	58800017 	ldw	r2,0(r11)
81131b58:	5ac00104 	addi	r11,r11,4
81131b5c:	d8001d85 	stb	zero,118(sp)
81131b60:	d8801005 	stb	r2,64(sp)
81131b64:	dac02315 	stw	r11,140(sp)
81131b68:	d8c02115 	stw	r3,132(sp)
81131b6c:	dc401004 	addi	r17,sp,64
81131b70:	0021883a 	mov	r16,zero
81131b74:	90c0008c 	andi	r3,r18,2
81131b78:	d8c02215 	stw	r3,136(sp)
81131b7c:	18000326 	beq	r3,zero,81131b8c <___svfiprintf_internal_r+0x5a0>
81131b80:	dac02017 	ldw	r11,128(sp)
81131b84:	5ac00084 	addi	r11,r11,2
81131b88:	dac02015 	stw	r11,128(sp)
81131b8c:	90c0210c 	andi	r3,r18,132
81131b90:	d8c02615 	stw	r3,152(sp)
81131b94:	1801131e 	bne	r3,zero,81131fe4 <___svfiprintf_internal_r+0x9f8>
81131b98:	dac02417 	ldw	r11,144(sp)
81131b9c:	d8c02017 	ldw	r3,128(sp)
81131ba0:	58f9c83a 	sub	fp,r11,r3
81131ba4:	07010f0e 	bge	zero,fp,81131fe4 <___svfiprintf_internal_r+0x9f8>
81131ba8:	02400404 	movi	r9,16
81131bac:	d8c01c17 	ldw	r3,112(sp)
81131bb0:	d8801b17 	ldw	r2,108(sp)
81131bb4:	4f02d60e 	bge	r9,fp,81132710 <___svfiprintf_internal_r+0x1124>
81131bb8:	01604574 	movhi	r5,33045
81131bbc:	2947d204 	addi	r5,r5,8008
81131bc0:	d9402815 	stw	r5,160(sp)
81131bc4:	028001c4 	movi	r10,7
81131bc8:	00000306 	br	81131bd8 <___svfiprintf_internal_r+0x5ec>
81131bcc:	e73ffc04 	addi	fp,fp,-16
81131bd0:	42000204 	addi	r8,r8,8
81131bd4:	4f00150e 	bge	r9,fp,81131c2c <___svfiprintf_internal_r+0x640>
81131bd8:	18c00404 	addi	r3,r3,16
81131bdc:	10800044 	addi	r2,r2,1
81131be0:	45800015 	stw	r22,0(r8)
81131be4:	42400115 	stw	r9,4(r8)
81131be8:	d8c01c15 	stw	r3,112(sp)
81131bec:	d8801b15 	stw	r2,108(sp)
81131bf0:	50bff60e 	bge	r10,r2,81131bcc <__reset+0xfb111bcc>
81131bf4:	d9801a04 	addi	r6,sp,104
81131bf8:	b80b883a 	mov	r5,r23
81131bfc:	a809883a 	mov	r4,r21
81131c00:	da402c15 	stw	r9,176(sp)
81131c04:	da802d15 	stw	r10,180(sp)
81131c08:	11314140 	call	81131414 <__ssprint_r>
81131c0c:	da402c17 	ldw	r9,176(sp)
81131c10:	da802d17 	ldw	r10,180(sp)
81131c14:	1001851e 	bne	r2,zero,8113222c <___svfiprintf_internal_r+0xc40>
81131c18:	e73ffc04 	addi	fp,fp,-16
81131c1c:	d8c01c17 	ldw	r3,112(sp)
81131c20:	d8801b17 	ldw	r2,108(sp)
81131c24:	d811883a 	mov	r8,sp
81131c28:	4f3feb16 	blt	r9,fp,81131bd8 <__reset+0xfb111bd8>
81131c2c:	dac02817 	ldw	r11,160(sp)
81131c30:	e0c7883a 	add	r3,fp,r3
81131c34:	10800044 	addi	r2,r2,1
81131c38:	42c00015 	stw	r11,0(r8)
81131c3c:	47000115 	stw	fp,4(r8)
81131c40:	d8c01c15 	stw	r3,112(sp)
81131c44:	d8801b15 	stw	r2,108(sp)
81131c48:	010001c4 	movi	r4,7
81131c4c:	2081ee16 	blt	r4,r2,81132408 <___svfiprintf_internal_r+0xe1c>
81131c50:	42000204 	addi	r8,r8,8
81131c54:	0000e506 	br	81131fec <___svfiprintf_internal_r+0xa00>
81131c58:	21003fcc 	andi	r4,r4,255
81131c5c:	2002dd1e 	bne	r4,zero,811327d4 <___svfiprintf_internal_r+0x11e8>
81131c60:	00a04574 	movhi	r2,33045
81131c64:	10873f04 	addi	r2,r2,7420
81131c68:	d8802915 	stw	r2,164(sp)
81131c6c:	9080080c 	andi	r2,r18,32
81131c70:	103f461e 	bne	r2,zero,8113198c <__reset+0xfb11198c>
81131c74:	9080040c 	andi	r2,r18,16
81131c78:	10022e1e 	bne	r2,zero,81132534 <___svfiprintf_internal_r+0xf48>
81131c7c:	9080100c 	andi	r2,r18,64
81131c80:	dac02317 	ldw	r11,140(sp)
81131c84:	10027326 	beq	r2,zero,81132654 <___svfiprintf_internal_r+0x1068>
81131c88:	5f00000b 	ldhu	fp,0(r11)
81131c8c:	5ac00104 	addi	r11,r11,4
81131c90:	0013883a 	mov	r9,zero
81131c94:	dac02315 	stw	r11,140(sp)
81131c98:	003f4106 	br	811319a0 <__reset+0xfb1119a0>
81131c9c:	21003fcc 	andi	r4,r4,255
81131ca0:	2002e11e 	bne	r4,zero,81132828 <___svfiprintf_internal_r+0x123c>
81131ca4:	9080080c 	andi	r2,r18,32
81131ca8:	1002011e 	bne	r2,zero,811324b0 <___svfiprintf_internal_r+0xec4>
81131cac:	9080040c 	andi	r2,r18,16
81131cb0:	10023e1e 	bne	r2,zero,811325ac <___svfiprintf_internal_r+0xfc0>
81131cb4:	9480100c 	andi	r18,r18,64
81131cb8:	90023c26 	beq	r18,zero,811325ac <___svfiprintf_internal_r+0xfc0>
81131cbc:	dac02317 	ldw	r11,140(sp)
81131cc0:	58800017 	ldw	r2,0(r11)
81131cc4:	5ac00104 	addi	r11,r11,4
81131cc8:	dac02315 	stw	r11,140(sp)
81131ccc:	dac02517 	ldw	r11,148(sp)
81131cd0:	12c0000d 	sth	r11,0(r2)
81131cd4:	003e6e06 	br	81131690 <__reset+0xfb111690>
81131cd8:	98c00007 	ldb	r3,0(r19)
81131cdc:	1a422926 	beq	r3,r9,81132584 <___svfiprintf_internal_r+0xf98>
81131ce0:	94800414 	ori	r18,r18,16
81131ce4:	003e9206 	br	81131730 <__reset+0xfb111730>
81131ce8:	94801014 	ori	r18,r18,64
81131cec:	98c00007 	ldb	r3,0(r19)
81131cf0:	003e8f06 	br	81131730 <__reset+0xfb111730>
81131cf4:	21003fcc 	andi	r4,r4,255
81131cf8:	2002c71e 	bne	r4,zero,81132818 <___svfiprintf_internal_r+0x122c>
81131cfc:	9080080c 	andi	r2,r18,32
81131d00:	10004926 	beq	r2,zero,81131e28 <___svfiprintf_internal_r+0x83c>
81131d04:	dac02317 	ldw	r11,140(sp)
81131d08:	58800117 	ldw	r2,4(r11)
81131d0c:	5f000017 	ldw	fp,0(r11)
81131d10:	5ac00204 	addi	r11,r11,8
81131d14:	dac02315 	stw	r11,140(sp)
81131d18:	1013883a 	mov	r9,r2
81131d1c:	10004b16 	blt	r2,zero,81131e4c <___svfiprintf_internal_r+0x860>
81131d20:	da801d83 	ldbu	r10,118(sp)
81131d24:	8001cb16 	blt	r16,zero,81132454 <___svfiprintf_internal_r+0xe68>
81131d28:	00ffdfc4 	movi	r3,-129
81131d2c:	e244b03a 	or	r2,fp,r9
81131d30:	90e4703a 	and	r18,r18,r3
81131d34:	103f4726 	beq	r2,zero,81131a54 <__reset+0xfb111a54>
81131d38:	48008c26 	beq	r9,zero,81131f6c <___svfiprintf_internal_r+0x980>
81131d3c:	dc802015 	stw	r18,128(sp)
81131d40:	dc002115 	stw	r16,132(sp)
81131d44:	dc401a04 	addi	r17,sp,104
81131d48:	e021883a 	mov	r16,fp
81131d4c:	da002215 	stw	r8,136(sp)
81131d50:	5039883a 	mov	fp,r10
81131d54:	4825883a 	mov	r18,r9
81131d58:	8009883a 	mov	r4,r16
81131d5c:	900b883a 	mov	r5,r18
81131d60:	01800284 	movi	r6,10
81131d64:	000f883a 	mov	r7,zero
81131d68:	11358fc0 	call	811358fc <__umoddi3>
81131d6c:	10800c04 	addi	r2,r2,48
81131d70:	8c7fffc4 	addi	r17,r17,-1
81131d74:	8009883a 	mov	r4,r16
81131d78:	900b883a 	mov	r5,r18
81131d7c:	88800005 	stb	r2,0(r17)
81131d80:	01800284 	movi	r6,10
81131d84:	000f883a 	mov	r7,zero
81131d88:	113537c0 	call	8113537c <__udivdi3>
81131d8c:	1021883a 	mov	r16,r2
81131d90:	10c4b03a 	or	r2,r2,r3
81131d94:	1825883a 	mov	r18,r3
81131d98:	103fef1e 	bne	r2,zero,81131d58 <__reset+0xfb111d58>
81131d9c:	dc802017 	ldw	r18,128(sp)
81131da0:	dc002117 	ldw	r16,132(sp)
81131da4:	da002217 	ldw	r8,136(sp)
81131da8:	e015883a 	mov	r10,fp
81131dac:	d8c01e17 	ldw	r3,120(sp)
81131db0:	1c47c83a 	sub	r3,r3,r17
81131db4:	d8c02115 	stw	r3,132(sp)
81131db8:	003f2a06 	br	81131a64 <__reset+0xfb111a64>
81131dbc:	dac02317 	ldw	r11,140(sp)
81131dc0:	d8001d85 	stb	zero,118(sp)
81131dc4:	5c400017 	ldw	r17,0(r11)
81131dc8:	5f000104 	addi	fp,r11,4
81131dcc:	88022f26 	beq	r17,zero,8113268c <___svfiprintf_internal_r+0x10a0>
81131dd0:	80022516 	blt	r16,zero,81132668 <___svfiprintf_internal_r+0x107c>
81131dd4:	800d883a 	mov	r6,r16
81131dd8:	000b883a 	mov	r5,zero
81131ddc:	8809883a 	mov	r4,r17
81131de0:	da002c15 	stw	r8,176(sp)
81131de4:	112d9b80 	call	8112d9b8 <memchr>
81131de8:	da002c17 	ldw	r8,176(sp)
81131dec:	10026426 	beq	r2,zero,81132780 <___svfiprintf_internal_r+0x1194>
81131df0:	1445c83a 	sub	r2,r2,r17
81131df4:	d8802115 	stw	r2,132(sp)
81131df8:	da801d83 	ldbu	r10,118(sp)
81131dfc:	df002315 	stw	fp,140(sp)
81131e00:	0021883a 	mov	r16,zero
81131e04:	003f1706 	br	81131a64 <__reset+0xfb111a64>
81131e08:	94800814 	ori	r18,r18,32
81131e0c:	98c00007 	ldb	r3,0(r19)
81131e10:	003e4706 	br	81131730 <__reset+0xfb111730>
81131e14:	21003fcc 	andi	r4,r4,255
81131e18:	2002701e 	bne	r4,zero,811327dc <___svfiprintf_internal_r+0x11f0>
81131e1c:	94800414 	ori	r18,r18,16
81131e20:	9080080c 	andi	r2,r18,32
81131e24:	103fb71e 	bne	r2,zero,81131d04 <__reset+0xfb111d04>
81131e28:	9080040c 	andi	r2,r18,16
81131e2c:	1001ab26 	beq	r2,zero,811324dc <___svfiprintf_internal_r+0xef0>
81131e30:	dac02317 	ldw	r11,140(sp)
81131e34:	5f000017 	ldw	fp,0(r11)
81131e38:	5ac00104 	addi	r11,r11,4
81131e3c:	dac02315 	stw	r11,140(sp)
81131e40:	e013d7fa 	srai	r9,fp,31
81131e44:	4805883a 	mov	r2,r9
81131e48:	103fb50e 	bge	r2,zero,81131d20 <__reset+0xfb111d20>
81131e4c:	0739c83a 	sub	fp,zero,fp
81131e50:	02800b44 	movi	r10,45
81131e54:	e004c03a 	cmpne	r2,fp,zero
81131e58:	0253c83a 	sub	r9,zero,r9
81131e5c:	da801d85 	stb	r10,118(sp)
81131e60:	4893c83a 	sub	r9,r9,r2
81131e64:	80023016 	blt	r16,zero,81132728 <___svfiprintf_internal_r+0x113c>
81131e68:	00bfdfc4 	movi	r2,-129
81131e6c:	90a4703a 	and	r18,r18,r2
81131e70:	483fb21e 	bne	r9,zero,81131d3c <__reset+0xfb111d3c>
81131e74:	00003d06 	br	81131f6c <___svfiprintf_internal_r+0x980>
81131e78:	9817883a 	mov	r11,r19
81131e7c:	d8002415 	stw	zero,144(sp)
81131e80:	18bff404 	addi	r2,r3,-48
81131e84:	0019883a 	mov	r12,zero
81131e88:	58c00007 	ldb	r3,0(r11)
81131e8c:	630002a4 	muli	r12,r12,10
81131e90:	9cc00044 	addi	r19,r19,1
81131e94:	9817883a 	mov	r11,r19
81131e98:	1319883a 	add	r12,r2,r12
81131e9c:	18bff404 	addi	r2,r3,-48
81131ea0:	30bff92e 	bgeu	r6,r2,81131e88 <__reset+0xfb111e88>
81131ea4:	db002415 	stw	r12,144(sp)
81131ea8:	18bff804 	addi	r2,r3,-32
81131eac:	28be232e 	bgeu	r5,r2,8113173c <__reset+0xfb11173c>
81131eb0:	21003fcc 	andi	r4,r4,255
81131eb4:	20024b1e 	bne	r4,zero,811327e4 <___svfiprintf_internal_r+0x11f8>
81131eb8:	1800d626 	beq	r3,zero,81132214 <___svfiprintf_internal_r+0xc28>
81131ebc:	02c00044 	movi	r11,1
81131ec0:	dac02015 	stw	r11,128(sp)
81131ec4:	d8c01005 	stb	r3,64(sp)
81131ec8:	d8001d85 	stb	zero,118(sp)
81131ecc:	dac02115 	stw	r11,132(sp)
81131ed0:	dc401004 	addi	r17,sp,64
81131ed4:	003f2606 	br	81131b70 <__reset+0xfb111b70>
81131ed8:	94802014 	ori	r18,r18,128
81131edc:	98c00007 	ldb	r3,0(r19)
81131ee0:	003e1306 	br	81131730 <__reset+0xfb111730>
81131ee4:	98c00007 	ldb	r3,0(r19)
81131ee8:	9ac00044 	addi	r11,r19,1
81131eec:	1a822b26 	beq	r3,r10,8113279c <___svfiprintf_internal_r+0x11b0>
81131ef0:	18bff404 	addi	r2,r3,-48
81131ef4:	0021883a 	mov	r16,zero
81131ef8:	30821e36 	bltu	r6,r2,81132774 <___svfiprintf_internal_r+0x1188>
81131efc:	58c00007 	ldb	r3,0(r11)
81131f00:	840002a4 	muli	r16,r16,10
81131f04:	5cc00044 	addi	r19,r11,1
81131f08:	9817883a 	mov	r11,r19
81131f0c:	80a1883a 	add	r16,r16,r2
81131f10:	18bff404 	addi	r2,r3,-48
81131f14:	30bff92e 	bgeu	r6,r2,81131efc <__reset+0xfb111efc>
81131f18:	803e060e 	bge	r16,zero,81131734 <__reset+0xfb111734>
81131f1c:	043fffc4 	movi	r16,-1
81131f20:	003e0406 	br	81131734 <__reset+0xfb111734>
81131f24:	21003fcc 	andi	r4,r4,255
81131f28:	2002371e 	bne	r4,zero,81132808 <___svfiprintf_internal_r+0x121c>
81131f2c:	94800414 	ori	r18,r18,16
81131f30:	9080080c 	andi	r2,r18,32
81131f34:	103ebb1e 	bne	r2,zero,81131a24 <__reset+0xfb111a24>
81131f38:	9080040c 	andi	r2,r18,16
81131f3c:	10013b26 	beq	r2,zero,8113242c <___svfiprintf_internal_r+0xe40>
81131f40:	dac02317 	ldw	r11,140(sp)
81131f44:	d8001d85 	stb	zero,118(sp)
81131f48:	0013883a 	mov	r9,zero
81131f4c:	58800104 	addi	r2,r11,4
81131f50:	5f000017 	ldw	fp,0(r11)
81131f54:	80013d16 	blt	r16,zero,8113244c <___svfiprintf_internal_r+0xe60>
81131f58:	00ffdfc4 	movi	r3,-129
81131f5c:	d8802315 	stw	r2,140(sp)
81131f60:	90e4703a 	and	r18,r18,r3
81131f64:	0015883a 	mov	r10,zero
81131f68:	e03eba26 	beq	fp,zero,81131a54 <__reset+0xfb111a54>
81131f6c:	00800244 	movi	r2,9
81131f70:	173f7236 	bltu	r2,fp,81131d3c <__reset+0xfb111d3c>
81131f74:	dac02b17 	ldw	r11,172(sp)
81131f78:	e7000c04 	addi	fp,fp,48
81131f7c:	df0019c5 	stb	fp,103(sp)
81131f80:	dac02115 	stw	r11,132(sp)
81131f84:	dc4019c4 	addi	r17,sp,103
81131f88:	003eb606 	br	81131a64 <__reset+0xfb111a64>
81131f8c:	21003fcc 	andi	r4,r4,255
81131f90:	20021f1e 	bne	r4,zero,81132810 <___svfiprintf_internal_r+0x1224>
81131f94:	94800414 	ori	r18,r18,16
81131f98:	9080080c 	andi	r2,r18,32
81131f9c:	103ec51e 	bne	r2,zero,81131ab4 <__reset+0xfb111ab4>
81131fa0:	9080040c 	andi	r2,r18,16
81131fa4:	10016926 	beq	r2,zero,8113254c <___svfiprintf_internal_r+0xf60>
81131fa8:	dac02317 	ldw	r11,140(sp)
81131fac:	d8001d85 	stb	zero,118(sp)
81131fb0:	0013883a 	mov	r9,zero
81131fb4:	58800104 	addi	r2,r11,4
81131fb8:	5f000017 	ldw	fp,0(r11)
81131fbc:	80016b16 	blt	r16,zero,8113256c <___svfiprintf_internal_r+0xf80>
81131fc0:	00ffdfc4 	movi	r3,-129
81131fc4:	d8802315 	stw	r2,140(sp)
81131fc8:	90e4703a 	and	r18,r18,r3
81131fcc:	e03ec41e 	bne	fp,zero,81131ae0 <__reset+0xfb111ae0>
81131fd0:	0015883a 	mov	r10,zero
81131fd4:	8001c226 	beq	r16,zero,811326e0 <___svfiprintf_internal_r+0x10f4>
81131fd8:	0039883a 	mov	fp,zero
81131fdc:	0013883a 	mov	r9,zero
81131fe0:	003ec006 	br	81131ae4 <__reset+0xfb111ae4>
81131fe4:	d8c01c17 	ldw	r3,112(sp)
81131fe8:	d8801b17 	ldw	r2,108(sp)
81131fec:	d9001d87 	ldb	r4,118(sp)
81131ff0:	20000b26 	beq	r4,zero,81132020 <___svfiprintf_internal_r+0xa34>
81131ff4:	d9001d84 	addi	r4,sp,118
81131ff8:	18c00044 	addi	r3,r3,1
81131ffc:	10800044 	addi	r2,r2,1
81132000:	41000015 	stw	r4,0(r8)
81132004:	01000044 	movi	r4,1
81132008:	41000115 	stw	r4,4(r8)
8113200c:	d8c01c15 	stw	r3,112(sp)
81132010:	d8801b15 	stw	r2,108(sp)
81132014:	010001c4 	movi	r4,7
81132018:	2080e116 	blt	r4,r2,811323a0 <___svfiprintf_internal_r+0xdb4>
8113201c:	42000204 	addi	r8,r8,8
81132020:	dac02217 	ldw	r11,136(sp)
81132024:	58000b26 	beq	r11,zero,81132054 <___svfiprintf_internal_r+0xa68>
81132028:	d9001d04 	addi	r4,sp,116
8113202c:	18c00084 	addi	r3,r3,2
81132030:	10800044 	addi	r2,r2,1
81132034:	41000015 	stw	r4,0(r8)
81132038:	01000084 	movi	r4,2
8113203c:	41000115 	stw	r4,4(r8)
81132040:	d8c01c15 	stw	r3,112(sp)
81132044:	d8801b15 	stw	r2,108(sp)
81132048:	010001c4 	movi	r4,7
8113204c:	2080dd16 	blt	r4,r2,811323c4 <___svfiprintf_internal_r+0xdd8>
81132050:	42000204 	addi	r8,r8,8
81132054:	dac02617 	ldw	r11,152(sp)
81132058:	01002004 	movi	r4,128
8113205c:	59008426 	beq	r11,r4,81132270 <___svfiprintf_internal_r+0xc84>
81132060:	dac02117 	ldw	r11,132(sp)
81132064:	82e1c83a 	sub	r16,r16,r11
81132068:	0400270e 	bge	zero,r16,81132108 <___svfiprintf_internal_r+0xb1c>
8113206c:	01c00404 	movi	r7,16
81132070:	3c016a0e 	bge	r7,r16,8113261c <___svfiprintf_internal_r+0x1030>
81132074:	01604574 	movhi	r5,33045
81132078:	2947ce04 	addi	r5,r5,7992
8113207c:	d9402215 	stw	r5,136(sp)
81132080:	070001c4 	movi	fp,7
81132084:	00000306 	br	81132094 <___svfiprintf_internal_r+0xaa8>
81132088:	843ffc04 	addi	r16,r16,-16
8113208c:	42000204 	addi	r8,r8,8
81132090:	3c00130e 	bge	r7,r16,811320e0 <___svfiprintf_internal_r+0xaf4>
81132094:	18c00404 	addi	r3,r3,16
81132098:	10800044 	addi	r2,r2,1
8113209c:	45000015 	stw	r20,0(r8)
811320a0:	41c00115 	stw	r7,4(r8)
811320a4:	d8c01c15 	stw	r3,112(sp)
811320a8:	d8801b15 	stw	r2,108(sp)
811320ac:	e0bff60e 	bge	fp,r2,81132088 <__reset+0xfb112088>
811320b0:	d9801a04 	addi	r6,sp,104
811320b4:	b80b883a 	mov	r5,r23
811320b8:	a809883a 	mov	r4,r21
811320bc:	d9c02c15 	stw	r7,176(sp)
811320c0:	11314140 	call	81131414 <__ssprint_r>
811320c4:	d9c02c17 	ldw	r7,176(sp)
811320c8:	1000581e 	bne	r2,zero,8113222c <___svfiprintf_internal_r+0xc40>
811320cc:	843ffc04 	addi	r16,r16,-16
811320d0:	d8c01c17 	ldw	r3,112(sp)
811320d4:	d8801b17 	ldw	r2,108(sp)
811320d8:	d811883a 	mov	r8,sp
811320dc:	3c3fed16 	blt	r7,r16,81132094 <__reset+0xfb112094>
811320e0:	dac02217 	ldw	r11,136(sp)
811320e4:	1c07883a 	add	r3,r3,r16
811320e8:	10800044 	addi	r2,r2,1
811320ec:	42c00015 	stw	r11,0(r8)
811320f0:	44000115 	stw	r16,4(r8)
811320f4:	d8c01c15 	stw	r3,112(sp)
811320f8:	d8801b15 	stw	r2,108(sp)
811320fc:	010001c4 	movi	r4,7
81132100:	20809e16 	blt	r4,r2,8113237c <___svfiprintf_internal_r+0xd90>
81132104:	42000204 	addi	r8,r8,8
81132108:	dac02117 	ldw	r11,132(sp)
8113210c:	10800044 	addi	r2,r2,1
81132110:	44400015 	stw	r17,0(r8)
81132114:	58c7883a 	add	r3,r11,r3
81132118:	42c00115 	stw	r11,4(r8)
8113211c:	d8c01c15 	stw	r3,112(sp)
81132120:	d8801b15 	stw	r2,108(sp)
81132124:	010001c4 	movi	r4,7
81132128:	20807f16 	blt	r4,r2,81132328 <___svfiprintf_internal_r+0xd3c>
8113212c:	42000204 	addi	r8,r8,8
81132130:	9480010c 	andi	r18,r18,4
81132134:	90002926 	beq	r18,zero,811321dc <___svfiprintf_internal_r+0xbf0>
81132138:	dac02417 	ldw	r11,144(sp)
8113213c:	d8802017 	ldw	r2,128(sp)
81132140:	58a1c83a 	sub	r16,r11,r2
81132144:	0400250e 	bge	zero,r16,811321dc <___svfiprintf_internal_r+0xbf0>
81132148:	04400404 	movi	r17,16
8113214c:	d8801b17 	ldw	r2,108(sp)
81132150:	8c017c0e 	bge	r17,r16,81132744 <___svfiprintf_internal_r+0x1158>
81132154:	01604574 	movhi	r5,33045
81132158:	2947d204 	addi	r5,r5,8008
8113215c:	d9402815 	stw	r5,160(sp)
81132160:	048001c4 	movi	r18,7
81132164:	00000306 	br	81132174 <___svfiprintf_internal_r+0xb88>
81132168:	843ffc04 	addi	r16,r16,-16
8113216c:	42000204 	addi	r8,r8,8
81132170:	8c00110e 	bge	r17,r16,811321b8 <___svfiprintf_internal_r+0xbcc>
81132174:	18c00404 	addi	r3,r3,16
81132178:	10800044 	addi	r2,r2,1
8113217c:	45800015 	stw	r22,0(r8)
81132180:	44400115 	stw	r17,4(r8)
81132184:	d8c01c15 	stw	r3,112(sp)
81132188:	d8801b15 	stw	r2,108(sp)
8113218c:	90bff60e 	bge	r18,r2,81132168 <__reset+0xfb112168>
81132190:	d9801a04 	addi	r6,sp,104
81132194:	b80b883a 	mov	r5,r23
81132198:	a809883a 	mov	r4,r21
8113219c:	11314140 	call	81131414 <__ssprint_r>
811321a0:	1000221e 	bne	r2,zero,8113222c <___svfiprintf_internal_r+0xc40>
811321a4:	843ffc04 	addi	r16,r16,-16
811321a8:	d8c01c17 	ldw	r3,112(sp)
811321ac:	d8801b17 	ldw	r2,108(sp)
811321b0:	d811883a 	mov	r8,sp
811321b4:	8c3fef16 	blt	r17,r16,81132174 <__reset+0xfb112174>
811321b8:	dac02817 	ldw	r11,160(sp)
811321bc:	1c07883a 	add	r3,r3,r16
811321c0:	10800044 	addi	r2,r2,1
811321c4:	42c00015 	stw	r11,0(r8)
811321c8:	44000115 	stw	r16,4(r8)
811321cc:	d8c01c15 	stw	r3,112(sp)
811321d0:	d8801b15 	stw	r2,108(sp)
811321d4:	010001c4 	movi	r4,7
811321d8:	2080aa16 	blt	r4,r2,81132484 <___svfiprintf_internal_r+0xe98>
811321dc:	d8802417 	ldw	r2,144(sp)
811321e0:	dac02017 	ldw	r11,128(sp)
811321e4:	12c0010e 	bge	r2,r11,811321ec <___svfiprintf_internal_r+0xc00>
811321e8:	5805883a 	mov	r2,r11
811321ec:	dac02517 	ldw	r11,148(sp)
811321f0:	5897883a 	add	r11,r11,r2
811321f4:	dac02515 	stw	r11,148(sp)
811321f8:	1800531e 	bne	r3,zero,81132348 <___svfiprintf_internal_r+0xd5c>
811321fc:	98800007 	ldb	r2,0(r19)
81132200:	d8001b15 	stw	zero,108(sp)
81132204:	d811883a 	mov	r8,sp
81132208:	103d231e 	bne	r2,zero,81131698 <__reset+0xfb111698>
8113220c:	9823883a 	mov	r17,r19
81132210:	003d3906 	br	811316f8 <__reset+0xfb1116f8>
81132214:	d8801c17 	ldw	r2,112(sp)
81132218:	10000426 	beq	r2,zero,8113222c <___svfiprintf_internal_r+0xc40>
8113221c:	d9402717 	ldw	r5,156(sp)
81132220:	d9002a17 	ldw	r4,168(sp)
81132224:	d9801a04 	addi	r6,sp,104
81132228:	11314140 	call	81131414 <__ssprint_r>
8113222c:	dac02717 	ldw	r11,156(sp)
81132230:	d8802517 	ldw	r2,148(sp)
81132234:	58c0030b 	ldhu	r3,12(r11)
81132238:	18c0100c 	andi	r3,r3,64
8113223c:	1801381e 	bne	r3,zero,81132720 <___svfiprintf_internal_r+0x1134>
81132240:	dfc03717 	ldw	ra,220(sp)
81132244:	df003617 	ldw	fp,216(sp)
81132248:	ddc03517 	ldw	r23,212(sp)
8113224c:	dd803417 	ldw	r22,208(sp)
81132250:	dd403317 	ldw	r21,204(sp)
81132254:	dd003217 	ldw	r20,200(sp)
81132258:	dcc03117 	ldw	r19,196(sp)
8113225c:	dc803017 	ldw	r18,192(sp)
81132260:	dc402f17 	ldw	r17,188(sp)
81132264:	dc002e17 	ldw	r16,184(sp)
81132268:	dec03804 	addi	sp,sp,224
8113226c:	f800283a 	ret
81132270:	dac02417 	ldw	r11,144(sp)
81132274:	d9002017 	ldw	r4,128(sp)
81132278:	5939c83a 	sub	fp,r11,r4
8113227c:	073f780e 	bge	zero,fp,81132060 <__reset+0xfb112060>
81132280:	02400404 	movi	r9,16
81132284:	4f01370e 	bge	r9,fp,81132764 <___svfiprintf_internal_r+0x1178>
81132288:	02e04574 	movhi	r11,33045
8113228c:	5ac7ce04 	addi	r11,r11,7992
81132290:	dac02215 	stw	r11,136(sp)
81132294:	028001c4 	movi	r10,7
81132298:	00000306 	br	811322a8 <___svfiprintf_internal_r+0xcbc>
8113229c:	e73ffc04 	addi	fp,fp,-16
811322a0:	42000204 	addi	r8,r8,8
811322a4:	4f00150e 	bge	r9,fp,811322fc <___svfiprintf_internal_r+0xd10>
811322a8:	18c00404 	addi	r3,r3,16
811322ac:	10800044 	addi	r2,r2,1
811322b0:	45000015 	stw	r20,0(r8)
811322b4:	42400115 	stw	r9,4(r8)
811322b8:	d8c01c15 	stw	r3,112(sp)
811322bc:	d8801b15 	stw	r2,108(sp)
811322c0:	50bff60e 	bge	r10,r2,8113229c <__reset+0xfb11229c>
811322c4:	d9801a04 	addi	r6,sp,104
811322c8:	b80b883a 	mov	r5,r23
811322cc:	a809883a 	mov	r4,r21
811322d0:	da402c15 	stw	r9,176(sp)
811322d4:	da802d15 	stw	r10,180(sp)
811322d8:	11314140 	call	81131414 <__ssprint_r>
811322dc:	da402c17 	ldw	r9,176(sp)
811322e0:	da802d17 	ldw	r10,180(sp)
811322e4:	103fd11e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
811322e8:	e73ffc04 	addi	fp,fp,-16
811322ec:	d8c01c17 	ldw	r3,112(sp)
811322f0:	d8801b17 	ldw	r2,108(sp)
811322f4:	d811883a 	mov	r8,sp
811322f8:	4f3feb16 	blt	r9,fp,811322a8 <__reset+0xfb1122a8>
811322fc:	dac02217 	ldw	r11,136(sp)
81132300:	1f07883a 	add	r3,r3,fp
81132304:	10800044 	addi	r2,r2,1
81132308:	42c00015 	stw	r11,0(r8)
8113230c:	47000115 	stw	fp,4(r8)
81132310:	d8c01c15 	stw	r3,112(sp)
81132314:	d8801b15 	stw	r2,108(sp)
81132318:	010001c4 	movi	r4,7
8113231c:	2080b616 	blt	r4,r2,811325f8 <___svfiprintf_internal_r+0x100c>
81132320:	42000204 	addi	r8,r8,8
81132324:	003f4e06 	br	81132060 <__reset+0xfb112060>
81132328:	d9801a04 	addi	r6,sp,104
8113232c:	b80b883a 	mov	r5,r23
81132330:	a809883a 	mov	r4,r21
81132334:	11314140 	call	81131414 <__ssprint_r>
81132338:	103fbc1e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
8113233c:	d8c01c17 	ldw	r3,112(sp)
81132340:	d811883a 	mov	r8,sp
81132344:	003f7a06 	br	81132130 <__reset+0xfb112130>
81132348:	d9801a04 	addi	r6,sp,104
8113234c:	b80b883a 	mov	r5,r23
81132350:	a809883a 	mov	r4,r21
81132354:	11314140 	call	81131414 <__ssprint_r>
81132358:	103fa826 	beq	r2,zero,811321fc <__reset+0xfb1121fc>
8113235c:	003fb306 	br	8113222c <__reset+0xfb11222c>
81132360:	d9801a04 	addi	r6,sp,104
81132364:	b80b883a 	mov	r5,r23
81132368:	a809883a 	mov	r4,r21
8113236c:	11314140 	call	81131414 <__ssprint_r>
81132370:	103fae1e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
81132374:	d811883a 	mov	r8,sp
81132378:	003cdc06 	br	811316ec <__reset+0xfb1116ec>
8113237c:	d9801a04 	addi	r6,sp,104
81132380:	b80b883a 	mov	r5,r23
81132384:	a809883a 	mov	r4,r21
81132388:	11314140 	call	81131414 <__ssprint_r>
8113238c:	103fa71e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
81132390:	d8c01c17 	ldw	r3,112(sp)
81132394:	d8801b17 	ldw	r2,108(sp)
81132398:	d811883a 	mov	r8,sp
8113239c:	003f5a06 	br	81132108 <__reset+0xfb112108>
811323a0:	d9801a04 	addi	r6,sp,104
811323a4:	b80b883a 	mov	r5,r23
811323a8:	a809883a 	mov	r4,r21
811323ac:	11314140 	call	81131414 <__ssprint_r>
811323b0:	103f9e1e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
811323b4:	d8c01c17 	ldw	r3,112(sp)
811323b8:	d8801b17 	ldw	r2,108(sp)
811323bc:	d811883a 	mov	r8,sp
811323c0:	003f1706 	br	81132020 <__reset+0xfb112020>
811323c4:	d9801a04 	addi	r6,sp,104
811323c8:	b80b883a 	mov	r5,r23
811323cc:	a809883a 	mov	r4,r21
811323d0:	11314140 	call	81131414 <__ssprint_r>
811323d4:	103f951e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
811323d8:	d8c01c17 	ldw	r3,112(sp)
811323dc:	d8801b17 	ldw	r2,108(sp)
811323e0:	d811883a 	mov	r8,sp
811323e4:	003f1b06 	br	81132054 <__reset+0xfb112054>
811323e8:	d8001d85 	stb	zero,118(sp)
811323ec:	80007b16 	blt	r16,zero,811325dc <___svfiprintf_internal_r+0xff0>
811323f0:	00ffdfc4 	movi	r3,-129
811323f4:	e244b03a 	or	r2,fp,r9
811323f8:	90e4703a 	and	r18,r18,r3
811323fc:	103d7026 	beq	r2,zero,811319c0 <__reset+0xfb1119c0>
81132400:	0015883a 	mov	r10,zero
81132404:	003d7206 	br	811319d0 <__reset+0xfb1119d0>
81132408:	d9801a04 	addi	r6,sp,104
8113240c:	b80b883a 	mov	r5,r23
81132410:	a809883a 	mov	r4,r21
81132414:	11314140 	call	81131414 <__ssprint_r>
81132418:	103f841e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
8113241c:	d8c01c17 	ldw	r3,112(sp)
81132420:	d8801b17 	ldw	r2,108(sp)
81132424:	d811883a 	mov	r8,sp
81132428:	003ef006 	br	81131fec <__reset+0xfb111fec>
8113242c:	9080100c 	andi	r2,r18,64
81132430:	d8001d85 	stb	zero,118(sp)
81132434:	dac02317 	ldw	r11,140(sp)
81132438:	10008126 	beq	r2,zero,81132640 <___svfiprintf_internal_r+0x1054>
8113243c:	58800104 	addi	r2,r11,4
81132440:	5f00000b 	ldhu	fp,0(r11)
81132444:	0013883a 	mov	r9,zero
81132448:	803ec30e 	bge	r16,zero,81131f58 <__reset+0xfb111f58>
8113244c:	d8802315 	stw	r2,140(sp)
81132450:	0015883a 	mov	r10,zero
81132454:	e244b03a 	or	r2,fp,r9
81132458:	103e371e 	bne	r2,zero,81131d38 <__reset+0xfb111d38>
8113245c:	00800044 	movi	r2,1
81132460:	10803fcc 	andi	r2,r2,255
81132464:	00c00044 	movi	r3,1
81132468:	10c06126 	beq	r2,r3,811325f0 <___svfiprintf_internal_r+0x1004>
8113246c:	00c00084 	movi	r3,2
81132470:	10fd5526 	beq	r2,r3,811319c8 <__reset+0xfb1119c8>
81132474:	003ed806 	br	81131fd8 <__reset+0xfb111fd8>
81132478:	d8802315 	stw	r2,140(sp)
8113247c:	98c00007 	ldb	r3,0(r19)
81132480:	003cab06 	br	81131730 <__reset+0xfb111730>
81132484:	d9801a04 	addi	r6,sp,104
81132488:	b80b883a 	mov	r5,r23
8113248c:	a809883a 	mov	r4,r21
81132490:	11314140 	call	81131414 <__ssprint_r>
81132494:	103f651e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
81132498:	d8c01c17 	ldw	r3,112(sp)
8113249c:	003f4f06 	br	811321dc <__reset+0xfb1121dc>
811324a0:	00a04574 	movhi	r2,33045
811324a4:	10874404 	addi	r2,r2,7440
811324a8:	d8802915 	stw	r2,164(sp)
811324ac:	003d4406 	br	811319c0 <__reset+0xfb1119c0>
811324b0:	dac02317 	ldw	r11,140(sp)
811324b4:	58800017 	ldw	r2,0(r11)
811324b8:	dac02517 	ldw	r11,148(sp)
811324bc:	5807d7fa 	srai	r3,r11,31
811324c0:	dac02317 	ldw	r11,140(sp)
811324c4:	10c00115 	stw	r3,4(r2)
811324c8:	5ac00104 	addi	r11,r11,4
811324cc:	dac02315 	stw	r11,140(sp)
811324d0:	dac02517 	ldw	r11,148(sp)
811324d4:	12c00015 	stw	r11,0(r2)
811324d8:	003c6d06 	br	81131690 <__reset+0xfb111690>
811324dc:	9080100c 	andi	r2,r18,64
811324e0:	dac02317 	ldw	r11,140(sp)
811324e4:	103e5326 	beq	r2,zero,81131e34 <__reset+0xfb111e34>
811324e8:	5f00000f 	ldh	fp,0(r11)
811324ec:	5ac00104 	addi	r11,r11,4
811324f0:	dac02315 	stw	r11,140(sp)
811324f4:	e013d7fa 	srai	r9,fp,31
811324f8:	4805883a 	mov	r2,r9
811324fc:	003e0706 	br	81131d1c <__reset+0xfb111d1c>
81132500:	00800c04 	movi	r2,48
81132504:	d8801d05 	stb	r2,116(sp)
81132508:	d8c01d45 	stb	r3,117(sp)
8113250c:	d8001d85 	stb	zero,118(sp)
81132510:	90800094 	ori	r2,r18,2
81132514:	80008f16 	blt	r16,zero,81132754 <___svfiprintf_internal_r+0x1168>
81132518:	00bfdfc4 	movi	r2,-129
8113251c:	90a4703a 	and	r18,r18,r2
81132520:	94800094 	ori	r18,r18,2
81132524:	0015883a 	mov	r10,zero
81132528:	003d2906 	br	811319d0 <__reset+0xfb1119d0>
8113252c:	98c00007 	ldb	r3,0(r19)
81132530:	003c7f06 	br	81131730 <__reset+0xfb111730>
81132534:	dac02317 	ldw	r11,140(sp)
81132538:	0013883a 	mov	r9,zero
8113253c:	5f000017 	ldw	fp,0(r11)
81132540:	5ac00104 	addi	r11,r11,4
81132544:	dac02315 	stw	r11,140(sp)
81132548:	003d1506 	br	811319a0 <__reset+0xfb1119a0>
8113254c:	9080100c 	andi	r2,r18,64
81132550:	d8001d85 	stb	zero,118(sp)
81132554:	dac02317 	ldw	r11,140(sp)
81132558:	10003426 	beq	r2,zero,8113262c <___svfiprintf_internal_r+0x1040>
8113255c:	58800104 	addi	r2,r11,4
81132560:	5f00000b 	ldhu	fp,0(r11)
81132564:	0013883a 	mov	r9,zero
81132568:	803e950e 	bge	r16,zero,81131fc0 <__reset+0xfb111fc0>
8113256c:	e246b03a 	or	r3,fp,r9
81132570:	d8802315 	stw	r2,140(sp)
81132574:	183d5a1e 	bne	r3,zero,81131ae0 <__reset+0xfb111ae0>
81132578:	0015883a 	mov	r10,zero
8113257c:	0005883a 	mov	r2,zero
81132580:	003fb706 	br	81132460 <__reset+0xfb112460>
81132584:	98c00043 	ldbu	r3,1(r19)
81132588:	94800814 	ori	r18,r18,32
8113258c:	9cc00044 	addi	r19,r19,1
81132590:	18c03fcc 	andi	r3,r3,255
81132594:	18c0201c 	xori	r3,r3,128
81132598:	18ffe004 	addi	r3,r3,-128
8113259c:	003c6406 	br	81131730 <__reset+0xfb111730>
811325a0:	d8c02315 	stw	r3,140(sp)
811325a4:	0015883a 	mov	r10,zero
811325a8:	003faa06 	br	81132454 <__reset+0xfb112454>
811325ac:	dac02317 	ldw	r11,140(sp)
811325b0:	58800017 	ldw	r2,0(r11)
811325b4:	5ac00104 	addi	r11,r11,4
811325b8:	dac02315 	stw	r11,140(sp)
811325bc:	dac02517 	ldw	r11,148(sp)
811325c0:	12c00015 	stw	r11,0(r2)
811325c4:	003c3206 	br	81131690 <__reset+0xfb111690>
811325c8:	01204574 	movhi	r4,33045
811325cc:	21074404 	addi	r4,r4,7440
811325d0:	d9002915 	stw	r4,164(sp)
811325d4:	d8c02315 	stw	r3,140(sp)
811325d8:	1025883a 	mov	r18,r2
811325dc:	e244b03a 	or	r2,fp,r9
811325e0:	103f871e 	bne	r2,zero,81132400 <__reset+0xfb112400>
811325e4:	0015883a 	mov	r10,zero
811325e8:	00800084 	movi	r2,2
811325ec:	003f9c06 	br	81132460 <__reset+0xfb112460>
811325f0:	0039883a 	mov	fp,zero
811325f4:	003e5f06 	br	81131f74 <__reset+0xfb111f74>
811325f8:	d9801a04 	addi	r6,sp,104
811325fc:	b80b883a 	mov	r5,r23
81132600:	a809883a 	mov	r4,r21
81132604:	11314140 	call	81131414 <__ssprint_r>
81132608:	103f081e 	bne	r2,zero,8113222c <__reset+0xfb11222c>
8113260c:	d8c01c17 	ldw	r3,112(sp)
81132610:	d8801b17 	ldw	r2,108(sp)
81132614:	d811883a 	mov	r8,sp
81132618:	003e9106 	br	81132060 <__reset+0xfb112060>
8113261c:	01204574 	movhi	r4,33045
81132620:	2107ce04 	addi	r4,r4,7992
81132624:	d9002215 	stw	r4,136(sp)
81132628:	003ead06 	br	811320e0 <__reset+0xfb1120e0>
8113262c:	58800104 	addi	r2,r11,4
81132630:	5f000017 	ldw	fp,0(r11)
81132634:	0013883a 	mov	r9,zero
81132638:	803e610e 	bge	r16,zero,81131fc0 <__reset+0xfb111fc0>
8113263c:	003fcb06 	br	8113256c <__reset+0xfb11256c>
81132640:	58800104 	addi	r2,r11,4
81132644:	5f000017 	ldw	fp,0(r11)
81132648:	0013883a 	mov	r9,zero
8113264c:	803e420e 	bge	r16,zero,81131f58 <__reset+0xfb111f58>
81132650:	003f7e06 	br	8113244c <__reset+0xfb11244c>
81132654:	5f000017 	ldw	fp,0(r11)
81132658:	5ac00104 	addi	r11,r11,4
8113265c:	0013883a 	mov	r9,zero
81132660:	dac02315 	stw	r11,140(sp)
81132664:	003cce06 	br	811319a0 <__reset+0xfb1119a0>
81132668:	8809883a 	mov	r4,r17
8113266c:	da002c15 	stw	r8,176(sp)
81132670:	11244bc0 	call	811244bc <strlen>
81132674:	d8802115 	stw	r2,132(sp)
81132678:	da801d83 	ldbu	r10,118(sp)
8113267c:	df002315 	stw	fp,140(sp)
81132680:	0021883a 	mov	r16,zero
81132684:	da002c17 	ldw	r8,176(sp)
81132688:	003cf606 	br	81131a64 <__reset+0xfb111a64>
8113268c:	00800184 	movi	r2,6
81132690:	1400012e 	bgeu	r2,r16,81132698 <___svfiprintf_internal_r+0x10ac>
81132694:	1021883a 	mov	r16,r2
81132698:	dc002115 	stw	r16,132(sp)
8113269c:	8005883a 	mov	r2,r16
811326a0:	80003c16 	blt	r16,zero,81132794 <___svfiprintf_internal_r+0x11a8>
811326a4:	04604574 	movhi	r17,33045
811326a8:	d8802015 	stw	r2,128(sp)
811326ac:	df002315 	stw	fp,140(sp)
811326b0:	8c474904 	addi	r17,r17,7460
811326b4:	003d2e06 	br	81131b70 <__reset+0xfb111b70>
811326b8:	04001004 	movi	r16,64
811326bc:	800b883a 	mov	r5,r16
811326c0:	11232300 	call	81123230 <_malloc_r>
811326c4:	dac02717 	ldw	r11,156(sp)
811326c8:	58800015 	stw	r2,0(r11)
811326cc:	58800415 	stw	r2,16(r11)
811326d0:	10004826 	beq	r2,zero,811327f4 <___svfiprintf_internal_r+0x1208>
811326d4:	dac02717 	ldw	r11,156(sp)
811326d8:	5c000515 	stw	r16,20(r11)
811326dc:	003bd906 	br	81131644 <__reset+0xfb111644>
811326e0:	9080004c 	andi	r2,r18,1
811326e4:	0015883a 	mov	r10,zero
811326e8:	10000626 	beq	r2,zero,81132704 <___svfiprintf_internal_r+0x1118>
811326ec:	dac02b17 	ldw	r11,172(sp)
811326f0:	00800c04 	movi	r2,48
811326f4:	d88019c5 	stb	r2,103(sp)
811326f8:	dac02115 	stw	r11,132(sp)
811326fc:	dc4019c4 	addi	r17,sp,103
81132700:	003cd806 	br	81131a64 <__reset+0xfb111a64>
81132704:	d8002115 	stw	zero,132(sp)
81132708:	dc401a04 	addi	r17,sp,104
8113270c:	003cd506 	br	81131a64 <__reset+0xfb111a64>
81132710:	01204574 	movhi	r4,33045
81132714:	2107d204 	addi	r4,r4,8008
81132718:	d9002815 	stw	r4,160(sp)
8113271c:	003d4306 	br	81131c2c <__reset+0xfb111c2c>
81132720:	00bfffc4 	movi	r2,-1
81132724:	003ec606 	br	81132240 <__reset+0xfb112240>
81132728:	00800044 	movi	r2,1
8113272c:	10803fcc 	andi	r2,r2,255
81132730:	00c00044 	movi	r3,1
81132734:	10fd8026 	beq	r2,r3,81131d38 <__reset+0xfb111d38>
81132738:	00c00084 	movi	r3,2
8113273c:	10fca426 	beq	r2,r3,811319d0 <__reset+0xfb1119d0>
81132740:	003ce806 	br	81131ae4 <__reset+0xfb111ae4>
81132744:	01204574 	movhi	r4,33045
81132748:	2107d204 	addi	r4,r4,8008
8113274c:	d9002815 	stw	r4,160(sp)
81132750:	003e9906 	br	811321b8 <__reset+0xfb1121b8>
81132754:	1025883a 	mov	r18,r2
81132758:	0015883a 	mov	r10,zero
8113275c:	00800084 	movi	r2,2
81132760:	003ff206 	br	8113272c <__reset+0xfb11272c>
81132764:	01604574 	movhi	r5,33045
81132768:	2947ce04 	addi	r5,r5,7992
8113276c:	d9402215 	stw	r5,136(sp)
81132770:	003ee206 	br	811322fc <__reset+0xfb1122fc>
81132774:	5827883a 	mov	r19,r11
81132778:	0021883a 	mov	r16,zero
8113277c:	003bed06 	br	81131734 <__reset+0xfb111734>
81132780:	dc002115 	stw	r16,132(sp)
81132784:	da801d83 	ldbu	r10,118(sp)
81132788:	df002315 	stw	fp,140(sp)
8113278c:	0021883a 	mov	r16,zero
81132790:	003cb406 	br	81131a64 <__reset+0xfb111a64>
81132794:	0005883a 	mov	r2,zero
81132798:	003fc206 	br	811326a4 <__reset+0xfb1126a4>
8113279c:	d8802317 	ldw	r2,140(sp)
811327a0:	98c00043 	ldbu	r3,1(r19)
811327a4:	5827883a 	mov	r19,r11
811327a8:	14000017 	ldw	r16,0(r2)
811327ac:	10800104 	addi	r2,r2,4
811327b0:	d8802315 	stw	r2,140(sp)
811327b4:	803f760e 	bge	r16,zero,81132590 <__reset+0xfb112590>
811327b8:	18c03fcc 	andi	r3,r3,255
811327bc:	18c0201c 	xori	r3,r3,128
811327c0:	043fffc4 	movi	r16,-1
811327c4:	18ffe004 	addi	r3,r3,-128
811327c8:	003bd906 	br	81131730 <__reset+0xfb111730>
811327cc:	d9c01d85 	stb	r7,118(sp)
811327d0:	003cb606 	br	81131aac <__reset+0xfb111aac>
811327d4:	d9c01d85 	stb	r7,118(sp)
811327d8:	003d2106 	br	81131c60 <__reset+0xfb111c60>
811327dc:	d9c01d85 	stb	r7,118(sp)
811327e0:	003d8e06 	br	81131e1c <__reset+0xfb111e1c>
811327e4:	d9c01d85 	stb	r7,118(sp)
811327e8:	003db306 	br	81131eb8 <__reset+0xfb111eb8>
811327ec:	d9c01d85 	stb	r7,118(sp)
811327f0:	003c8a06 	br	81131a1c <__reset+0xfb111a1c>
811327f4:	dac02a17 	ldw	r11,168(sp)
811327f8:	00800304 	movi	r2,12
811327fc:	58800015 	stw	r2,0(r11)
81132800:	00bfffc4 	movi	r2,-1
81132804:	003e8e06 	br	81132240 <__reset+0xfb112240>
81132808:	d9c01d85 	stb	r7,118(sp)
8113280c:	003dc706 	br	81131f2c <__reset+0xfb111f2c>
81132810:	d9c01d85 	stb	r7,118(sp)
81132814:	003ddf06 	br	81131f94 <__reset+0xfb111f94>
81132818:	d9c01d85 	stb	r7,118(sp)
8113281c:	003d3706 	br	81131cfc <__reset+0xfb111cfc>
81132820:	d9c01d85 	stb	r7,118(sp)
81132824:	003c5406 	br	81131978 <__reset+0xfb111978>
81132828:	d9c01d85 	stb	r7,118(sp)
8113282c:	003d1d06 	br	81131ca4 <__reset+0xfb111ca4>

81132830 <__submore>:
81132830:	defffa04 	addi	sp,sp,-24
81132834:	de00012e 	bgeu	sp,et,8113283c <__submore+0xc>
81132838:	003b68fa 	trap	3
8113283c:	dc000015 	stw	r16,0(sp)
81132840:	2821883a 	mov	r16,r5
81132844:	29400c17 	ldw	r5,48(r5)
81132848:	dfc00515 	stw	ra,20(sp)
8113284c:	dd000415 	stw	r20,16(sp)
81132850:	dcc00315 	stw	r19,12(sp)
81132854:	dc800215 	stw	r18,8(sp)
81132858:	dc400115 	stw	r17,4(sp)
8113285c:	80801004 	addi	r2,r16,64
81132860:	28801726 	beq	r5,r2,811328c0 <__submore+0x90>
81132864:	84400d17 	ldw	r17,52(r16)
81132868:	8c67883a 	add	r19,r17,r17
8113286c:	980d883a 	mov	r6,r19
81132870:	112ecbc0 	call	8112ecbc <_realloc_r>
81132874:	1025883a 	mov	r18,r2
81132878:	10002226 	beq	r2,zero,81132904 <__submore+0xd4>
8113287c:	1469883a 	add	r20,r2,r17
81132880:	880d883a 	mov	r6,r17
81132884:	100b883a 	mov	r5,r2
81132888:	a009883a 	mov	r4,r20
8113288c:	1123a440 	call	81123a44 <memcpy>
81132890:	0005883a 	mov	r2,zero
81132894:	85000015 	stw	r20,0(r16)
81132898:	84800c15 	stw	r18,48(r16)
8113289c:	84c00d15 	stw	r19,52(r16)
811328a0:	dfc00517 	ldw	ra,20(sp)
811328a4:	dd000417 	ldw	r20,16(sp)
811328a8:	dcc00317 	ldw	r19,12(sp)
811328ac:	dc800217 	ldw	r18,8(sp)
811328b0:	dc400117 	ldw	r17,4(sp)
811328b4:	dc000017 	ldw	r16,0(sp)
811328b8:	dec00604 	addi	sp,sp,24
811328bc:	f800283a 	ret
811328c0:	04410004 	movi	r17,1024
811328c4:	880b883a 	mov	r5,r17
811328c8:	11232300 	call	81123230 <_malloc_r>
811328cc:	1007883a 	mov	r3,r2
811328d0:	10000c26 	beq	r2,zero,81132904 <__submore+0xd4>
811328d4:	80801083 	ldbu	r2,66(r16)
811328d8:	80c00c15 	stw	r3,48(r16)
811328dc:	84400d15 	stw	r17,52(r16)
811328e0:	1880ffc5 	stb	r2,1023(r3)
811328e4:	81401043 	ldbu	r5,65(r16)
811328e8:	1900ff44 	addi	r4,r3,1021
811328ec:	0005883a 	mov	r2,zero
811328f0:	1940ff85 	stb	r5,1022(r3)
811328f4:	81401003 	ldbu	r5,64(r16)
811328f8:	1940ff45 	stb	r5,1021(r3)
811328fc:	81000015 	stw	r4,0(r16)
81132900:	003fe706 	br	811328a0 <__reset+0xfb1128a0>
81132904:	00bfffc4 	movi	r2,-1
81132908:	003fe506 	br	811328a0 <__reset+0xfb1128a0>

8113290c <_ungetc_r>:
8113290c:	00bfffc4 	movi	r2,-1
81132910:	28806326 	beq	r5,r2,81132aa0 <_ungetc_r+0x194>
81132914:	defffb04 	addi	sp,sp,-20
81132918:	de00012e 	bgeu	sp,et,81132920 <_ungetc_r+0x14>
8113291c:	003b68fa 	trap	3
81132920:	dcc00315 	stw	r19,12(sp)
81132924:	dc400115 	stw	r17,4(sp)
81132928:	dc000015 	stw	r16,0(sp)
8113292c:	dfc00415 	stw	ra,16(sp)
81132930:	dc800215 	stw	r18,8(sp)
81132934:	2023883a 	mov	r17,r4
81132938:	3021883a 	mov	r16,r6
8113293c:	2827883a 	mov	r19,r5
81132940:	20000226 	beq	r4,zero,8113294c <_ungetc_r+0x40>
81132944:	20800e17 	ldw	r2,56(r4)
81132948:	10002e26 	beq	r2,zero,81132a04 <_ungetc_r+0xf8>
8113294c:	80c0030b 	ldhu	r3,12(r16)
81132950:	1888000c 	andi	r2,r3,8192
81132954:	1000051e 	bne	r2,zero,8113296c <_ungetc_r+0x60>
81132958:	81001917 	ldw	r4,100(r16)
8113295c:	00b7ffc4 	movi	r2,-8193
81132960:	18c80014 	ori	r3,r3,8192
81132964:	2084703a 	and	r2,r4,r2
81132968:	80801915 	stw	r2,100(r16)
8113296c:	00bff7c4 	movi	r2,-33
81132970:	1884703a 	and	r2,r3,r2
81132974:	8080030d 	sth	r2,12(r16)
81132978:	1900010c 	andi	r4,r3,4
8113297c:	2000061e 	bne	r4,zero,81132998 <_ungetc_r+0x8c>
81132980:	1900040c 	andi	r4,r3,16
81132984:	20001d26 	beq	r4,zero,811329fc <_ungetc_r+0xf0>
81132988:	18c0020c 	andi	r3,r3,8
8113298c:	1800331e 	bne	r3,zero,81132a5c <_ungetc_r+0x150>
81132990:	10800114 	ori	r2,r2,4
81132994:	8080030d 	sth	r2,12(r16)
81132998:	80800c17 	ldw	r2,48(r16)
8113299c:	9c803fcc 	andi	r18,r19,255
811329a0:	10001a26 	beq	r2,zero,81132a0c <_ungetc_r+0x100>
811329a4:	80c00117 	ldw	r3,4(r16)
811329a8:	80800d17 	ldw	r2,52(r16)
811329ac:	18800f0e 	bge	r3,r2,811329ec <_ungetc_r+0xe0>
811329b0:	80c00017 	ldw	r3,0(r16)
811329b4:	9005883a 	mov	r2,r18
811329b8:	193fffc4 	addi	r4,r3,-1
811329bc:	81000015 	stw	r4,0(r16)
811329c0:	1cffffc5 	stb	r19,-1(r3)
811329c4:	80c00117 	ldw	r3,4(r16)
811329c8:	18c00044 	addi	r3,r3,1
811329cc:	80c00115 	stw	r3,4(r16)
811329d0:	dfc00417 	ldw	ra,16(sp)
811329d4:	dcc00317 	ldw	r19,12(sp)
811329d8:	dc800217 	ldw	r18,8(sp)
811329dc:	dc400117 	ldw	r17,4(sp)
811329e0:	dc000017 	ldw	r16,0(sp)
811329e4:	dec00504 	addi	sp,sp,20
811329e8:	f800283a 	ret
811329ec:	800b883a 	mov	r5,r16
811329f0:	8809883a 	mov	r4,r17
811329f4:	11328300 	call	81132830 <__submore>
811329f8:	103fed26 	beq	r2,zero,811329b0 <__reset+0xfb1129b0>
811329fc:	00bfffc4 	movi	r2,-1
81132a00:	003ff306 	br	811329d0 <__reset+0xfb1129d0>
81132a04:	112c7900 	call	8112c790 <__sinit>
81132a08:	003fd006 	br	8113294c <__reset+0xfb11294c>
81132a0c:	80c00417 	ldw	r3,16(r16)
81132a10:	80800017 	ldw	r2,0(r16)
81132a14:	18000326 	beq	r3,zero,81132a24 <_ungetc_r+0x118>
81132a18:	1880022e 	bgeu	r3,r2,81132a24 <_ungetc_r+0x118>
81132a1c:	10ffffc3 	ldbu	r3,-1(r2)
81132a20:	90c01826 	beq	r18,r3,81132a84 <_ungetc_r+0x178>
81132a24:	81400117 	ldw	r5,4(r16)
81132a28:	80800e15 	stw	r2,56(r16)
81132a2c:	008000c4 	movi	r2,3
81132a30:	81001004 	addi	r4,r16,64
81132a34:	80c01084 	addi	r3,r16,66
81132a38:	80800d15 	stw	r2,52(r16)
81132a3c:	00800044 	movi	r2,1
81132a40:	80800115 	stw	r2,4(r16)
81132a44:	81400f15 	stw	r5,60(r16)
81132a48:	81000c15 	stw	r4,48(r16)
81132a4c:	84c01085 	stb	r19,66(r16)
81132a50:	80c00015 	stw	r3,0(r16)
81132a54:	9005883a 	mov	r2,r18
81132a58:	003fdd06 	br	811329d0 <__reset+0xfb1129d0>
81132a5c:	800b883a 	mov	r5,r16
81132a60:	8809883a 	mov	r4,r17
81132a64:	112c3940 	call	8112c394 <_fflush_r>
81132a68:	103fe41e 	bne	r2,zero,811329fc <__reset+0xfb1129fc>
81132a6c:	8080030b 	ldhu	r2,12(r16)
81132a70:	00fffdc4 	movi	r3,-9
81132a74:	80000215 	stw	zero,8(r16)
81132a78:	1884703a 	and	r2,r3,r2
81132a7c:	80000615 	stw	zero,24(r16)
81132a80:	003fc306 	br	81132990 <__reset+0xfb112990>
81132a84:	80c00117 	ldw	r3,4(r16)
81132a88:	10bfffc4 	addi	r2,r2,-1
81132a8c:	80800015 	stw	r2,0(r16)
81132a90:	18800044 	addi	r2,r3,1
81132a94:	80800115 	stw	r2,4(r16)
81132a98:	9005883a 	mov	r2,r18
81132a9c:	003fcc06 	br	811329d0 <__reset+0xfb1129d0>
81132aa0:	00bfffc4 	movi	r2,-1
81132aa4:	f800283a 	ret

81132aa8 <ungetc>:
81132aa8:	00a04574 	movhi	r2,33045
81132aac:	10911304 	addi	r2,r2,17484
81132ab0:	280d883a 	mov	r6,r5
81132ab4:	200b883a 	mov	r5,r4
81132ab8:	11000017 	ldw	r4,0(r2)
81132abc:	113290c1 	jmpi	8113290c <_ungetc_r>

81132ac0 <__sprint_r.part.0>:
81132ac0:	defff604 	addi	sp,sp,-40
81132ac4:	de00012e 	bgeu	sp,et,81132acc <__sprint_r.part.0+0xc>
81132ac8:	003b68fa 	trap	3
81132acc:	28801917 	ldw	r2,100(r5)
81132ad0:	dd400515 	stw	r21,20(sp)
81132ad4:	dfc00915 	stw	ra,36(sp)
81132ad8:	df000815 	stw	fp,32(sp)
81132adc:	ddc00715 	stw	r23,28(sp)
81132ae0:	dd800615 	stw	r22,24(sp)
81132ae4:	dd000415 	stw	r20,16(sp)
81132ae8:	dcc00315 	stw	r19,12(sp)
81132aec:	dc800215 	stw	r18,8(sp)
81132af0:	dc400115 	stw	r17,4(sp)
81132af4:	dc000015 	stw	r16,0(sp)
81132af8:	1088000c 	andi	r2,r2,8192
81132afc:	302b883a 	mov	r21,r6
81132b00:	10002e26 	beq	r2,zero,81132bbc <__sprint_r.part.0+0xfc>
81132b04:	30800217 	ldw	r2,8(r6)
81132b08:	35800017 	ldw	r22,0(r6)
81132b0c:	10002926 	beq	r2,zero,81132bb4 <__sprint_r.part.0+0xf4>
81132b10:	2827883a 	mov	r19,r5
81132b14:	2029883a 	mov	r20,r4
81132b18:	b5c00104 	addi	r23,r22,4
81132b1c:	04bfffc4 	movi	r18,-1
81132b20:	bc400017 	ldw	r17,0(r23)
81132b24:	b4000017 	ldw	r16,0(r22)
81132b28:	0039883a 	mov	fp,zero
81132b2c:	8822d0ba 	srli	r17,r17,2
81132b30:	8800031e 	bne	r17,zero,81132b40 <__sprint_r.part.0+0x80>
81132b34:	00001806 	br	81132b98 <__sprint_r.part.0+0xd8>
81132b38:	84000104 	addi	r16,r16,4
81132b3c:	8f001526 	beq	r17,fp,81132b94 <__sprint_r.part.0+0xd4>
81132b40:	81400017 	ldw	r5,0(r16)
81132b44:	980d883a 	mov	r6,r19
81132b48:	a009883a 	mov	r4,r20
81132b4c:	11344640 	call	81134464 <_fputwc_r>
81132b50:	e7000044 	addi	fp,fp,1
81132b54:	14bff81e 	bne	r2,r18,81132b38 <__reset+0xfb112b38>
81132b58:	9005883a 	mov	r2,r18
81132b5c:	a8000215 	stw	zero,8(r21)
81132b60:	a8000115 	stw	zero,4(r21)
81132b64:	dfc00917 	ldw	ra,36(sp)
81132b68:	df000817 	ldw	fp,32(sp)
81132b6c:	ddc00717 	ldw	r23,28(sp)
81132b70:	dd800617 	ldw	r22,24(sp)
81132b74:	dd400517 	ldw	r21,20(sp)
81132b78:	dd000417 	ldw	r20,16(sp)
81132b7c:	dcc00317 	ldw	r19,12(sp)
81132b80:	dc800217 	ldw	r18,8(sp)
81132b84:	dc400117 	ldw	r17,4(sp)
81132b88:	dc000017 	ldw	r16,0(sp)
81132b8c:	dec00a04 	addi	sp,sp,40
81132b90:	f800283a 	ret
81132b94:	a8800217 	ldw	r2,8(r21)
81132b98:	8c63883a 	add	r17,r17,r17
81132b9c:	8c63883a 	add	r17,r17,r17
81132ba0:	1445c83a 	sub	r2,r2,r17
81132ba4:	a8800215 	stw	r2,8(r21)
81132ba8:	b5800204 	addi	r22,r22,8
81132bac:	bdc00204 	addi	r23,r23,8
81132bb0:	103fdb1e 	bne	r2,zero,81132b20 <__reset+0xfb112b20>
81132bb4:	0005883a 	mov	r2,zero
81132bb8:	003fe806 	br	81132b5c <__reset+0xfb112b5c>
81132bbc:	112cf400 	call	8112cf40 <__sfvwrite_r>
81132bc0:	003fe606 	br	81132b5c <__reset+0xfb112b5c>

81132bc4 <__sprint_r>:
81132bc4:	30c00217 	ldw	r3,8(r6)
81132bc8:	18000126 	beq	r3,zero,81132bd0 <__sprint_r+0xc>
81132bcc:	1132ac01 	jmpi	81132ac0 <__sprint_r.part.0>
81132bd0:	30000115 	stw	zero,4(r6)
81132bd4:	0005883a 	mov	r2,zero
81132bd8:	f800283a 	ret

81132bdc <___vfiprintf_internal_r>:
81132bdc:	deffc904 	addi	sp,sp,-220
81132be0:	de00012e 	bgeu	sp,et,81132be8 <___vfiprintf_internal_r+0xc>
81132be4:	003b68fa 	trap	3
81132be8:	df003515 	stw	fp,212(sp)
81132bec:	dd003115 	stw	r20,196(sp)
81132bf0:	dfc03615 	stw	ra,216(sp)
81132bf4:	ddc03415 	stw	r23,208(sp)
81132bf8:	dd803315 	stw	r22,204(sp)
81132bfc:	dd403215 	stw	r21,200(sp)
81132c00:	dcc03015 	stw	r19,192(sp)
81132c04:	dc802f15 	stw	r18,188(sp)
81132c08:	dc402e15 	stw	r17,184(sp)
81132c0c:	dc002d15 	stw	r16,180(sp)
81132c10:	d9002015 	stw	r4,128(sp)
81132c14:	d9c02215 	stw	r7,136(sp)
81132c18:	2829883a 	mov	r20,r5
81132c1c:	3039883a 	mov	fp,r6
81132c20:	20000226 	beq	r4,zero,81132c2c <___vfiprintf_internal_r+0x50>
81132c24:	20800e17 	ldw	r2,56(r4)
81132c28:	1000cf26 	beq	r2,zero,81132f68 <___vfiprintf_internal_r+0x38c>
81132c2c:	a080030b 	ldhu	r2,12(r20)
81132c30:	10c8000c 	andi	r3,r2,8192
81132c34:	1800061e 	bne	r3,zero,81132c50 <___vfiprintf_internal_r+0x74>
81132c38:	a1001917 	ldw	r4,100(r20)
81132c3c:	00f7ffc4 	movi	r3,-8193
81132c40:	10880014 	ori	r2,r2,8192
81132c44:	20c6703a 	and	r3,r4,r3
81132c48:	a080030d 	sth	r2,12(r20)
81132c4c:	a0c01915 	stw	r3,100(r20)
81132c50:	10c0020c 	andi	r3,r2,8
81132c54:	1800a926 	beq	r3,zero,81132efc <___vfiprintf_internal_r+0x320>
81132c58:	a0c00417 	ldw	r3,16(r20)
81132c5c:	1800a726 	beq	r3,zero,81132efc <___vfiprintf_internal_r+0x320>
81132c60:	1080068c 	andi	r2,r2,26
81132c64:	00c00284 	movi	r3,10
81132c68:	10c0ac26 	beq	r2,r3,81132f1c <___vfiprintf_internal_r+0x340>
81132c6c:	da801a04 	addi	r10,sp,104
81132c70:	da801e15 	stw	r10,120(sp)
81132c74:	d8801e17 	ldw	r2,120(sp)
81132c78:	da8019c4 	addi	r10,sp,103
81132c7c:	05a04574 	movhi	r22,33045
81132c80:	05e04574 	movhi	r23,33045
81132c84:	da801f15 	stw	r10,124(sp)
81132c88:	1295c83a 	sub	r10,r2,r10
81132c8c:	b587da04 	addi	r22,r22,8040
81132c90:	bdc7d604 	addi	r23,r23,8024
81132c94:	dec01a15 	stw	sp,104(sp)
81132c98:	d8001c15 	stw	zero,112(sp)
81132c9c:	d8001b15 	stw	zero,108(sp)
81132ca0:	d8002615 	stw	zero,152(sp)
81132ca4:	d8002315 	stw	zero,140(sp)
81132ca8:	da802715 	stw	r10,156(sp)
81132cac:	d811883a 	mov	r8,sp
81132cb0:	dd002115 	stw	r20,132(sp)
81132cb4:	e021883a 	mov	r16,fp
81132cb8:	80800007 	ldb	r2,0(r16)
81132cbc:	1003ea26 	beq	r2,zero,81133c68 <___vfiprintf_internal_r+0x108c>
81132cc0:	00c00944 	movi	r3,37
81132cc4:	8025883a 	mov	r18,r16
81132cc8:	10c0021e 	bne	r2,r3,81132cd4 <___vfiprintf_internal_r+0xf8>
81132ccc:	00001606 	br	81132d28 <___vfiprintf_internal_r+0x14c>
81132cd0:	10c00326 	beq	r2,r3,81132ce0 <___vfiprintf_internal_r+0x104>
81132cd4:	94800044 	addi	r18,r18,1
81132cd8:	90800007 	ldb	r2,0(r18)
81132cdc:	103ffc1e 	bne	r2,zero,81132cd0 <__reset+0xfb112cd0>
81132ce0:	9423c83a 	sub	r17,r18,r16
81132ce4:	88001026 	beq	r17,zero,81132d28 <___vfiprintf_internal_r+0x14c>
81132ce8:	d8c01c17 	ldw	r3,112(sp)
81132cec:	d8801b17 	ldw	r2,108(sp)
81132cf0:	44000015 	stw	r16,0(r8)
81132cf4:	88c7883a 	add	r3,r17,r3
81132cf8:	10800044 	addi	r2,r2,1
81132cfc:	44400115 	stw	r17,4(r8)
81132d00:	d8c01c15 	stw	r3,112(sp)
81132d04:	d8801b15 	stw	r2,108(sp)
81132d08:	010001c4 	movi	r4,7
81132d0c:	2080760e 	bge	r4,r2,81132ee8 <___vfiprintf_internal_r+0x30c>
81132d10:	1803821e 	bne	r3,zero,81133b1c <___vfiprintf_internal_r+0xf40>
81132d14:	da802317 	ldw	r10,140(sp)
81132d18:	d8001b15 	stw	zero,108(sp)
81132d1c:	d811883a 	mov	r8,sp
81132d20:	5455883a 	add	r10,r10,r17
81132d24:	da802315 	stw	r10,140(sp)
81132d28:	90800007 	ldb	r2,0(r18)
81132d2c:	10044626 	beq	r2,zero,81133e48 <___vfiprintf_internal_r+0x126c>
81132d30:	90c00047 	ldb	r3,1(r18)
81132d34:	94000044 	addi	r16,r18,1
81132d38:	d8001d85 	stb	zero,118(sp)
81132d3c:	0009883a 	mov	r4,zero
81132d40:	000f883a 	mov	r7,zero
81132d44:	027fffc4 	movi	r9,-1
81132d48:	0023883a 	mov	r17,zero
81132d4c:	0029883a 	mov	r20,zero
81132d50:	01401604 	movi	r5,88
81132d54:	01800244 	movi	r6,9
81132d58:	03400a84 	movi	r13,42
81132d5c:	03001b04 	movi	r12,108
81132d60:	84000044 	addi	r16,r16,1
81132d64:	18bff804 	addi	r2,r3,-32
81132d68:	28827336 	bltu	r5,r2,81133738 <___vfiprintf_internal_r+0xb5c>
81132d6c:	100490ba 	slli	r2,r2,2
81132d70:	02a044f4 	movhi	r10,33043
81132d74:	528b6104 	addi	r10,r10,11652
81132d78:	1285883a 	add	r2,r2,r10
81132d7c:	10800017 	ldw	r2,0(r2)
81132d80:	1000683a 	jmp	r2
81132d84:	8113346c 	andhi	r4,r16,19665
81132d88:	81133738 	rdprs	r4,r16,19676
81132d8c:	81133738 	rdprs	r4,r16,19676
81132d90:	8113348c 	andi	r4,r16,19666
81132d94:	81133738 	rdprs	r4,r16,19676
81132d98:	81133738 	rdprs	r4,r16,19676
81132d9c:	81133738 	rdprs	r4,r16,19676
81132da0:	81133738 	rdprs	r4,r16,19676
81132da4:	81133738 	rdprs	r4,r16,19676
81132da8:	81133738 	rdprs	r4,r16,19676
81132dac:	81133674 	orhi	r4,r16,19673
81132db0:	81133690 	cmplti	r4,r16,19674
81132db4:	81133738 	rdprs	r4,r16,19676
81132db8:	81132f78 	rdprs	r4,r16,19645
81132dbc:	811336a0 	cmpeqi	r4,r16,19674
81132dc0:	81133738 	rdprs	r4,r16,19676
81132dc4:	81133498 	cmpnei	r4,r16,19666
81132dc8:	811334a4 	muli	r4,r16,19666
81132dcc:	811334a4 	muli	r4,r16,19666
81132dd0:	811334a4 	muli	r4,r16,19666
81132dd4:	811334a4 	muli	r4,r16,19666
81132dd8:	811334a4 	muli	r4,r16,19666
81132ddc:	811334a4 	muli	r4,r16,19666
81132de0:	811334a4 	muli	r4,r16,19666
81132de4:	811334a4 	muli	r4,r16,19666
81132de8:	811334a4 	muli	r4,r16,19666
81132dec:	81133738 	rdprs	r4,r16,19676
81132df0:	81133738 	rdprs	r4,r16,19676
81132df4:	81133738 	rdprs	r4,r16,19676
81132df8:	81133738 	rdprs	r4,r16,19676
81132dfc:	81133738 	rdprs	r4,r16,19676
81132e00:	81133738 	rdprs	r4,r16,19676
81132e04:	81133738 	rdprs	r4,r16,19676
81132e08:	81133738 	rdprs	r4,r16,19676
81132e0c:	81133738 	rdprs	r4,r16,19676
81132e10:	81133738 	rdprs	r4,r16,19676
81132e14:	811334d0 	cmplti	r4,r16,19667
81132e18:	81133738 	rdprs	r4,r16,19676
81132e1c:	81133738 	rdprs	r4,r16,19676
81132e20:	81133738 	rdprs	r4,r16,19676
81132e24:	81133738 	rdprs	r4,r16,19676
81132e28:	81133738 	rdprs	r4,r16,19676
81132e2c:	81133738 	rdprs	r4,r16,19676
81132e30:	81133738 	rdprs	r4,r16,19676
81132e34:	81133738 	rdprs	r4,r16,19676
81132e38:	81133738 	rdprs	r4,r16,19676
81132e3c:	81133738 	rdprs	r4,r16,19676
81132e40:	81133508 	cmpgei	r4,r16,19668
81132e44:	81133738 	rdprs	r4,r16,19676
81132e48:	81133738 	rdprs	r4,r16,19676
81132e4c:	81133738 	rdprs	r4,r16,19676
81132e50:	81133738 	rdprs	r4,r16,19676
81132e54:	81133738 	rdprs	r4,r16,19676
81132e58:	81133560 	cmpeqi	r4,r16,19669
81132e5c:	81133738 	rdprs	r4,r16,19676
81132e60:	81133738 	rdprs	r4,r16,19676
81132e64:	811335d0 	cmplti	r4,r16,19671
81132e68:	81133738 	rdprs	r4,r16,19676
81132e6c:	81133738 	rdprs	r4,r16,19676
81132e70:	81133738 	rdprs	r4,r16,19676
81132e74:	81133738 	rdprs	r4,r16,19676
81132e78:	81133738 	rdprs	r4,r16,19676
81132e7c:	81133738 	rdprs	r4,r16,19676
81132e80:	81133738 	rdprs	r4,r16,19676
81132e84:	81133738 	rdprs	r4,r16,19676
81132e88:	81133738 	rdprs	r4,r16,19676
81132e8c:	81133738 	rdprs	r4,r16,19676
81132e90:	8113337c 	xorhi	r4,r16,19661
81132e94:	811333a8 	cmpgeui	r4,r16,19662
81132e98:	81133738 	rdprs	r4,r16,19676
81132e9c:	81133738 	rdprs	r4,r16,19676
81132ea0:	81133738 	rdprs	r4,r16,19676
81132ea4:	811336e0 	cmpeqi	r4,r16,19675
81132ea8:	811333a8 	cmpgeui	r4,r16,19662
81132eac:	81133738 	rdprs	r4,r16,19676
81132eb0:	81133738 	rdprs	r4,r16,19676
81132eb4:	8113323c 	xorhi	r4,r16,19656
81132eb8:	81133738 	rdprs	r4,r16,19676
81132ebc:	8113324c 	andi	r4,r16,19657
81132ec0:	81133288 	cmpgei	r4,r16,19658
81132ec4:	81132f84 	addi	r4,r16,19646
81132ec8:	81133230 	cmpltui	r4,r16,19656
81132ecc:	81133738 	rdprs	r4,r16,19676
81132ed0:	8113360c 	andi	r4,r16,19672
81132ed4:	81133738 	rdprs	r4,r16,19676
81132ed8:	81133664 	muli	r4,r16,19673
81132edc:	81133738 	rdprs	r4,r16,19676
81132ee0:	81133738 	rdprs	r4,r16,19676
81132ee4:	81133328 	cmpgeui	r4,r16,19660
81132ee8:	42000204 	addi	r8,r8,8
81132eec:	da802317 	ldw	r10,140(sp)
81132ef0:	5455883a 	add	r10,r10,r17
81132ef4:	da802315 	stw	r10,140(sp)
81132ef8:	003f8b06 	br	81132d28 <__reset+0xfb112d28>
81132efc:	d9002017 	ldw	r4,128(sp)
81132f00:	a00b883a 	mov	r5,r20
81132f04:	112a7200 	call	8112a720 <__swsetup_r>
81132f08:	1003b11e 	bne	r2,zero,81133dd0 <___vfiprintf_internal_r+0x11f4>
81132f0c:	a080030b 	ldhu	r2,12(r20)
81132f10:	00c00284 	movi	r3,10
81132f14:	1080068c 	andi	r2,r2,26
81132f18:	10ff541e 	bne	r2,r3,81132c6c <__reset+0xfb112c6c>
81132f1c:	a080038f 	ldh	r2,14(r20)
81132f20:	103f5216 	blt	r2,zero,81132c6c <__reset+0xfb112c6c>
81132f24:	d9c02217 	ldw	r7,136(sp)
81132f28:	d9002017 	ldw	r4,128(sp)
81132f2c:	e00d883a 	mov	r6,fp
81132f30:	a00b883a 	mov	r5,r20
81132f34:	113405c0 	call	8113405c <__sbprintf>
81132f38:	dfc03617 	ldw	ra,216(sp)
81132f3c:	df003517 	ldw	fp,212(sp)
81132f40:	ddc03417 	ldw	r23,208(sp)
81132f44:	dd803317 	ldw	r22,204(sp)
81132f48:	dd403217 	ldw	r21,200(sp)
81132f4c:	dd003117 	ldw	r20,196(sp)
81132f50:	dcc03017 	ldw	r19,192(sp)
81132f54:	dc802f17 	ldw	r18,188(sp)
81132f58:	dc402e17 	ldw	r17,184(sp)
81132f5c:	dc002d17 	ldw	r16,180(sp)
81132f60:	dec03704 	addi	sp,sp,220
81132f64:	f800283a 	ret
81132f68:	112c7900 	call	8112c790 <__sinit>
81132f6c:	003f2f06 	br	81132c2c <__reset+0xfb112c2c>
81132f70:	0463c83a 	sub	r17,zero,r17
81132f74:	d8802215 	stw	r2,136(sp)
81132f78:	a5000114 	ori	r20,r20,4
81132f7c:	80c00007 	ldb	r3,0(r16)
81132f80:	003f7706 	br	81132d60 <__reset+0xfb112d60>
81132f84:	00800c04 	movi	r2,48
81132f88:	da802217 	ldw	r10,136(sp)
81132f8c:	d8801d05 	stb	r2,116(sp)
81132f90:	00801e04 	movi	r2,120
81132f94:	d8801d45 	stb	r2,117(sp)
81132f98:	d8001d85 	stb	zero,118(sp)
81132f9c:	50c00104 	addi	r3,r10,4
81132fa0:	54800017 	ldw	r18,0(r10)
81132fa4:	0027883a 	mov	r19,zero
81132fa8:	a0800094 	ori	r2,r20,2
81132fac:	48030b16 	blt	r9,zero,81133bdc <___vfiprintf_internal_r+0x1000>
81132fb0:	00bfdfc4 	movi	r2,-129
81132fb4:	a096703a 	and	r11,r20,r2
81132fb8:	d8c02215 	stw	r3,136(sp)
81132fbc:	5d000094 	ori	r20,r11,2
81132fc0:	90032b1e 	bne	r18,zero,81133c70 <___vfiprintf_internal_r+0x1094>
81132fc4:	00a04574 	movhi	r2,33045
81132fc8:	10874404 	addi	r2,r2,7440
81132fcc:	d8802615 	stw	r2,152(sp)
81132fd0:	0039883a 	mov	fp,zero
81132fd4:	48017b1e 	bne	r9,zero,811335c4 <___vfiprintf_internal_r+0x9e8>
81132fd8:	0013883a 	mov	r9,zero
81132fdc:	0027883a 	mov	r19,zero
81132fe0:	dd401a04 	addi	r21,sp,104
81132fe4:	4825883a 	mov	r18,r9
81132fe8:	4cc0010e 	bge	r9,r19,81132ff0 <___vfiprintf_internal_r+0x414>
81132fec:	9825883a 	mov	r18,r19
81132ff0:	e7003fcc 	andi	fp,fp,255
81132ff4:	e700201c 	xori	fp,fp,128
81132ff8:	e73fe004 	addi	fp,fp,-128
81132ffc:	e0000126 	beq	fp,zero,81133004 <___vfiprintf_internal_r+0x428>
81133000:	94800044 	addi	r18,r18,1
81133004:	a380008c 	andi	r14,r20,2
81133008:	70000126 	beq	r14,zero,81133010 <___vfiprintf_internal_r+0x434>
8113300c:	94800084 	addi	r18,r18,2
81133010:	a700210c 	andi	fp,r20,132
81133014:	e001df1e 	bne	fp,zero,81133794 <___vfiprintf_internal_r+0xbb8>
81133018:	8c87c83a 	sub	r3,r17,r18
8113301c:	00c1dd0e 	bge	zero,r3,81133794 <___vfiprintf_internal_r+0xbb8>
81133020:	01c00404 	movi	r7,16
81133024:	d8801c17 	ldw	r2,112(sp)
81133028:	38c3ad0e 	bge	r7,r3,81133ee0 <___vfiprintf_internal_r+0x1304>
8113302c:	02a04574 	movhi	r10,33045
81133030:	5287da04 	addi	r10,r10,8040
81133034:	dc002915 	stw	r16,164(sp)
81133038:	d9801b17 	ldw	r6,108(sp)
8113303c:	da802415 	stw	r10,144(sp)
81133040:	03c001c4 	movi	r15,7
81133044:	da402515 	stw	r9,148(sp)
81133048:	db802815 	stw	r14,160(sp)
8113304c:	1821883a 	mov	r16,r3
81133050:	00000506 	br	81133068 <___vfiprintf_internal_r+0x48c>
81133054:	31400084 	addi	r5,r6,2
81133058:	42000204 	addi	r8,r8,8
8113305c:	200d883a 	mov	r6,r4
81133060:	843ffc04 	addi	r16,r16,-16
81133064:	3c000d0e 	bge	r7,r16,8113309c <___vfiprintf_internal_r+0x4c0>
81133068:	10800404 	addi	r2,r2,16
8113306c:	31000044 	addi	r4,r6,1
81133070:	45800015 	stw	r22,0(r8)
81133074:	41c00115 	stw	r7,4(r8)
81133078:	d8801c15 	stw	r2,112(sp)
8113307c:	d9001b15 	stw	r4,108(sp)
81133080:	793ff40e 	bge	r15,r4,81133054 <__reset+0xfb113054>
81133084:	1001b51e 	bne	r2,zero,8113375c <___vfiprintf_internal_r+0xb80>
81133088:	843ffc04 	addi	r16,r16,-16
8113308c:	000d883a 	mov	r6,zero
81133090:	01400044 	movi	r5,1
81133094:	d811883a 	mov	r8,sp
81133098:	3c3ff316 	blt	r7,r16,81133068 <__reset+0xfb113068>
8113309c:	8007883a 	mov	r3,r16
811330a0:	da402517 	ldw	r9,148(sp)
811330a4:	db802817 	ldw	r14,160(sp)
811330a8:	dc002917 	ldw	r16,164(sp)
811330ac:	da802417 	ldw	r10,144(sp)
811330b0:	1885883a 	add	r2,r3,r2
811330b4:	40c00115 	stw	r3,4(r8)
811330b8:	42800015 	stw	r10,0(r8)
811330bc:	d8801c15 	stw	r2,112(sp)
811330c0:	d9401b15 	stw	r5,108(sp)
811330c4:	00c001c4 	movi	r3,7
811330c8:	19426016 	blt	r3,r5,81133a4c <___vfiprintf_internal_r+0xe70>
811330cc:	d8c01d87 	ldb	r3,118(sp)
811330d0:	42000204 	addi	r8,r8,8
811330d4:	29000044 	addi	r4,r5,1
811330d8:	1801b31e 	bne	r3,zero,811337a8 <___vfiprintf_internal_r+0xbcc>
811330dc:	7001c026 	beq	r14,zero,811337e0 <___vfiprintf_internal_r+0xc04>
811330e0:	d8c01d04 	addi	r3,sp,116
811330e4:	10800084 	addi	r2,r2,2
811330e8:	40c00015 	stw	r3,0(r8)
811330ec:	00c00084 	movi	r3,2
811330f0:	40c00115 	stw	r3,4(r8)
811330f4:	d8801c15 	stw	r2,112(sp)
811330f8:	d9001b15 	stw	r4,108(sp)
811330fc:	00c001c4 	movi	r3,7
81133100:	1902650e 	bge	r3,r4,81133a98 <___vfiprintf_internal_r+0xebc>
81133104:	10029a1e 	bne	r2,zero,81133b70 <___vfiprintf_internal_r+0xf94>
81133108:	00c02004 	movi	r3,128
8113310c:	01000044 	movi	r4,1
81133110:	000b883a 	mov	r5,zero
81133114:	d811883a 	mov	r8,sp
81133118:	e0c1b31e 	bne	fp,r3,811337e8 <___vfiprintf_internal_r+0xc0c>
8113311c:	8cb9c83a 	sub	fp,r17,r18
81133120:	0701b10e 	bge	zero,fp,811337e8 <___vfiprintf_internal_r+0xc0c>
81133124:	01c00404 	movi	r7,16
81133128:	3f03890e 	bge	r7,fp,81133f50 <___vfiprintf_internal_r+0x1374>
8113312c:	00e04574 	movhi	r3,33045
81133130:	18c7d604 	addi	r3,r3,8024
81133134:	d8c02415 	stw	r3,144(sp)
81133138:	8007883a 	mov	r3,r16
8113313c:	034001c4 	movi	r13,7
81133140:	e021883a 	mov	r16,fp
81133144:	da402515 	stw	r9,148(sp)
81133148:	1839883a 	mov	fp,r3
8113314c:	00000506 	br	81133164 <___vfiprintf_internal_r+0x588>
81133150:	29800084 	addi	r6,r5,2
81133154:	42000204 	addi	r8,r8,8
81133158:	180b883a 	mov	r5,r3
8113315c:	843ffc04 	addi	r16,r16,-16
81133160:	3c000d0e 	bge	r7,r16,81133198 <___vfiprintf_internal_r+0x5bc>
81133164:	10800404 	addi	r2,r2,16
81133168:	28c00044 	addi	r3,r5,1
8113316c:	45c00015 	stw	r23,0(r8)
81133170:	41c00115 	stw	r7,4(r8)
81133174:	d8801c15 	stw	r2,112(sp)
81133178:	d8c01b15 	stw	r3,108(sp)
8113317c:	68fff40e 	bge	r13,r3,81133150 <__reset+0xfb113150>
81133180:	1002241e 	bne	r2,zero,81133a14 <___vfiprintf_internal_r+0xe38>
81133184:	843ffc04 	addi	r16,r16,-16
81133188:	01800044 	movi	r6,1
8113318c:	000b883a 	mov	r5,zero
81133190:	d811883a 	mov	r8,sp
81133194:	3c3ff316 	blt	r7,r16,81133164 <__reset+0xfb113164>
81133198:	da402517 	ldw	r9,148(sp)
8113319c:	e007883a 	mov	r3,fp
811331a0:	8039883a 	mov	fp,r16
811331a4:	1821883a 	mov	r16,r3
811331a8:	d8c02417 	ldw	r3,144(sp)
811331ac:	1705883a 	add	r2,r2,fp
811331b0:	47000115 	stw	fp,4(r8)
811331b4:	40c00015 	stw	r3,0(r8)
811331b8:	d8801c15 	stw	r2,112(sp)
811331bc:	d9801b15 	stw	r6,108(sp)
811331c0:	00c001c4 	movi	r3,7
811331c4:	19827616 	blt	r3,r6,81133ba0 <___vfiprintf_internal_r+0xfc4>
811331c8:	4cf9c83a 	sub	fp,r9,r19
811331cc:	42000204 	addi	r8,r8,8
811331d0:	31000044 	addi	r4,r6,1
811331d4:	300b883a 	mov	r5,r6
811331d8:	07018516 	blt	zero,fp,811337f0 <___vfiprintf_internal_r+0xc14>
811331dc:	9885883a 	add	r2,r19,r2
811331e0:	45400015 	stw	r21,0(r8)
811331e4:	44c00115 	stw	r19,4(r8)
811331e8:	d8801c15 	stw	r2,112(sp)
811331ec:	d9001b15 	stw	r4,108(sp)
811331f0:	00c001c4 	movi	r3,7
811331f4:	1901dd0e 	bge	r3,r4,8113396c <___vfiprintf_internal_r+0xd90>
811331f8:	1002401e 	bne	r2,zero,81133afc <___vfiprintf_internal_r+0xf20>
811331fc:	d8001b15 	stw	zero,108(sp)
81133200:	a2c0010c 	andi	r11,r20,4
81133204:	58000226 	beq	r11,zero,81133210 <___vfiprintf_internal_r+0x634>
81133208:	8ca7c83a 	sub	r19,r17,r18
8113320c:	04c2f216 	blt	zero,r19,81133dd8 <___vfiprintf_internal_r+0x11fc>
81133210:	8c80010e 	bge	r17,r18,81133218 <___vfiprintf_internal_r+0x63c>
81133214:	9023883a 	mov	r17,r18
81133218:	da802317 	ldw	r10,140(sp)
8113321c:	5455883a 	add	r10,r10,r17
81133220:	da802315 	stw	r10,140(sp)
81133224:	d8001b15 	stw	zero,108(sp)
81133228:	d811883a 	mov	r8,sp
8113322c:	003ea206 	br	81132cb8 <__reset+0xfb112cb8>
81133230:	a5000814 	ori	r20,r20,32
81133234:	80c00007 	ldb	r3,0(r16)
81133238:	003ec906 	br	81132d60 <__reset+0xfb112d60>
8113323c:	80c00007 	ldb	r3,0(r16)
81133240:	1b030926 	beq	r3,r12,81133e68 <___vfiprintf_internal_r+0x128c>
81133244:	a5000414 	ori	r20,r20,16
81133248:	003ec506 	br	81132d60 <__reset+0xfb112d60>
8113324c:	21003fcc 	andi	r4,r4,255
81133250:	20035e1e 	bne	r4,zero,81133fcc <___vfiprintf_internal_r+0x13f0>
81133254:	a080080c 	andi	r2,r20,32
81133258:	1002a526 	beq	r2,zero,81133cf0 <___vfiprintf_internal_r+0x1114>
8113325c:	da802217 	ldw	r10,136(sp)
81133260:	50800017 	ldw	r2,0(r10)
81133264:	da802317 	ldw	r10,140(sp)
81133268:	5007d7fa 	srai	r3,r10,31
8113326c:	da802217 	ldw	r10,136(sp)
81133270:	10c00115 	stw	r3,4(r2)
81133274:	52800104 	addi	r10,r10,4
81133278:	da802215 	stw	r10,136(sp)
8113327c:	da802317 	ldw	r10,140(sp)
81133280:	12800015 	stw	r10,0(r2)
81133284:	003e8c06 	br	81132cb8 <__reset+0xfb112cb8>
81133288:	21003fcc 	andi	r4,r4,255
8113328c:	2003511e 	bne	r4,zero,81133fd4 <___vfiprintf_internal_r+0x13f8>
81133290:	a080080c 	andi	r2,r20,32
81133294:	1000a126 	beq	r2,zero,8113351c <___vfiprintf_internal_r+0x940>
81133298:	da802217 	ldw	r10,136(sp)
8113329c:	d8001d85 	stb	zero,118(sp)
811332a0:	50800204 	addi	r2,r10,8
811332a4:	54800017 	ldw	r18,0(r10)
811332a8:	54c00117 	ldw	r19,4(r10)
811332ac:	4802b416 	blt	r9,zero,81133d80 <___vfiprintf_internal_r+0x11a4>
811332b0:	013fdfc4 	movi	r4,-129
811332b4:	94c6b03a 	or	r3,r18,r19
811332b8:	d8802215 	stw	r2,136(sp)
811332bc:	a128703a 	and	r20,r20,r4
811332c0:	1800a226 	beq	r3,zero,8113354c <___vfiprintf_internal_r+0x970>
811332c4:	0039883a 	mov	fp,zero
811332c8:	dd401a04 	addi	r21,sp,104
811332cc:	9006d0fa 	srli	r3,r18,3
811332d0:	9808977a 	slli	r4,r19,29
811332d4:	9826d0fa 	srli	r19,r19,3
811332d8:	948001cc 	andi	r18,r18,7
811332dc:	90800c04 	addi	r2,r18,48
811332e0:	ad7fffc4 	addi	r21,r21,-1
811332e4:	20e4b03a 	or	r18,r4,r3
811332e8:	a8800005 	stb	r2,0(r21)
811332ec:	94c6b03a 	or	r3,r18,r19
811332f0:	183ff61e 	bne	r3,zero,811332cc <__reset+0xfb1132cc>
811332f4:	a0c0004c 	andi	r3,r20,1
811332f8:	18005926 	beq	r3,zero,81133460 <___vfiprintf_internal_r+0x884>
811332fc:	10803fcc 	andi	r2,r2,255
81133300:	1080201c 	xori	r2,r2,128
81133304:	10bfe004 	addi	r2,r2,-128
81133308:	00c00c04 	movi	r3,48
8113330c:	10c05426 	beq	r2,r3,81133460 <___vfiprintf_internal_r+0x884>
81133310:	da801e17 	ldw	r10,120(sp)
81133314:	a8bfffc4 	addi	r2,r21,-1
81133318:	a8ffffc5 	stb	r3,-1(r21)
8113331c:	50a7c83a 	sub	r19,r10,r2
81133320:	102b883a 	mov	r21,r2
81133324:	003f2f06 	br	81132fe4 <__reset+0xfb112fe4>
81133328:	21003fcc 	andi	r4,r4,255
8113332c:	2003421e 	bne	r4,zero,81134038 <___vfiprintf_internal_r+0x145c>
81133330:	00a04574 	movhi	r2,33045
81133334:	10874404 	addi	r2,r2,7440
81133338:	d8802615 	stw	r2,152(sp)
8113333c:	a080080c 	andi	r2,r20,32
81133340:	1000aa26 	beq	r2,zero,811335ec <___vfiprintf_internal_r+0xa10>
81133344:	da802217 	ldw	r10,136(sp)
81133348:	54800017 	ldw	r18,0(r10)
8113334c:	54c00117 	ldw	r19,4(r10)
81133350:	52800204 	addi	r10,r10,8
81133354:	da802215 	stw	r10,136(sp)
81133358:	a080004c 	andi	r2,r20,1
8113335c:	1001d226 	beq	r2,zero,81133aa8 <___vfiprintf_internal_r+0xecc>
81133360:	94c4b03a 	or	r2,r18,r19
81133364:	1002351e 	bne	r2,zero,81133c3c <___vfiprintf_internal_r+0x1060>
81133368:	d8001d85 	stb	zero,118(sp)
8113336c:	48022216 	blt	r9,zero,81133bf8 <___vfiprintf_internal_r+0x101c>
81133370:	00bfdfc4 	movi	r2,-129
81133374:	a0a8703a 	and	r20,r20,r2
81133378:	003f1506 	br	81132fd0 <__reset+0xfb112fd0>
8113337c:	da802217 	ldw	r10,136(sp)
81133380:	04800044 	movi	r18,1
81133384:	d8001d85 	stb	zero,118(sp)
81133388:	50800017 	ldw	r2,0(r10)
8113338c:	52800104 	addi	r10,r10,4
81133390:	da802215 	stw	r10,136(sp)
81133394:	d8801005 	stb	r2,64(sp)
81133398:	9027883a 	mov	r19,r18
8113339c:	dd401004 	addi	r21,sp,64
811333a0:	0013883a 	mov	r9,zero
811333a4:	003f1706 	br	81133004 <__reset+0xfb113004>
811333a8:	21003fcc 	andi	r4,r4,255
811333ac:	2003201e 	bne	r4,zero,81134030 <___vfiprintf_internal_r+0x1454>
811333b0:	a080080c 	andi	r2,r20,32
811333b4:	10004b26 	beq	r2,zero,811334e4 <___vfiprintf_internal_r+0x908>
811333b8:	da802217 	ldw	r10,136(sp)
811333bc:	50800117 	ldw	r2,4(r10)
811333c0:	54800017 	ldw	r18,0(r10)
811333c4:	52800204 	addi	r10,r10,8
811333c8:	da802215 	stw	r10,136(sp)
811333cc:	1027883a 	mov	r19,r2
811333d0:	10022c16 	blt	r2,zero,81133c84 <___vfiprintf_internal_r+0x10a8>
811333d4:	df001d83 	ldbu	fp,118(sp)
811333d8:	48007216 	blt	r9,zero,811335a4 <___vfiprintf_internal_r+0x9c8>
811333dc:	00ffdfc4 	movi	r3,-129
811333e0:	94c4b03a 	or	r2,r18,r19
811333e4:	a0e8703a 	and	r20,r20,r3
811333e8:	1000cc26 	beq	r2,zero,8113371c <___vfiprintf_internal_r+0xb40>
811333ec:	98021026 	beq	r19,zero,81133c30 <___vfiprintf_internal_r+0x1054>
811333f0:	dc402415 	stw	r17,144(sp)
811333f4:	dc002515 	stw	r16,148(sp)
811333f8:	9823883a 	mov	r17,r19
811333fc:	9021883a 	mov	r16,r18
81133400:	dd401a04 	addi	r21,sp,104
81133404:	4825883a 	mov	r18,r9
81133408:	4027883a 	mov	r19,r8
8113340c:	8009883a 	mov	r4,r16
81133410:	880b883a 	mov	r5,r17
81133414:	01800284 	movi	r6,10
81133418:	000f883a 	mov	r7,zero
8113341c:	11358fc0 	call	811358fc <__umoddi3>
81133420:	10800c04 	addi	r2,r2,48
81133424:	ad7fffc4 	addi	r21,r21,-1
81133428:	8009883a 	mov	r4,r16
8113342c:	880b883a 	mov	r5,r17
81133430:	a8800005 	stb	r2,0(r21)
81133434:	01800284 	movi	r6,10
81133438:	000f883a 	mov	r7,zero
8113343c:	113537c0 	call	8113537c <__udivdi3>
81133440:	1021883a 	mov	r16,r2
81133444:	10c4b03a 	or	r2,r2,r3
81133448:	1823883a 	mov	r17,r3
8113344c:	103fef1e 	bne	r2,zero,8113340c <__reset+0xfb11340c>
81133450:	dc402417 	ldw	r17,144(sp)
81133454:	dc002517 	ldw	r16,148(sp)
81133458:	9013883a 	mov	r9,r18
8113345c:	9811883a 	mov	r8,r19
81133460:	da801e17 	ldw	r10,120(sp)
81133464:	5567c83a 	sub	r19,r10,r21
81133468:	003ede06 	br	81132fe4 <__reset+0xfb112fe4>
8113346c:	38803fcc 	andi	r2,r7,255
81133470:	1080201c 	xori	r2,r2,128
81133474:	10bfe004 	addi	r2,r2,-128
81133478:	1002371e 	bne	r2,zero,81133d58 <___vfiprintf_internal_r+0x117c>
8113347c:	01000044 	movi	r4,1
81133480:	01c00804 	movi	r7,32
81133484:	80c00007 	ldb	r3,0(r16)
81133488:	003e3506 	br	81132d60 <__reset+0xfb112d60>
8113348c:	a5000054 	ori	r20,r20,1
81133490:	80c00007 	ldb	r3,0(r16)
81133494:	003e3206 	br	81132d60 <__reset+0xfb112d60>
81133498:	a5002014 	ori	r20,r20,128
8113349c:	80c00007 	ldb	r3,0(r16)
811334a0:	003e2f06 	br	81132d60 <__reset+0xfb112d60>
811334a4:	8015883a 	mov	r10,r16
811334a8:	0023883a 	mov	r17,zero
811334ac:	18bff404 	addi	r2,r3,-48
811334b0:	50c00007 	ldb	r3,0(r10)
811334b4:	8c4002a4 	muli	r17,r17,10
811334b8:	84000044 	addi	r16,r16,1
811334bc:	8015883a 	mov	r10,r16
811334c0:	1463883a 	add	r17,r2,r17
811334c4:	18bff404 	addi	r2,r3,-48
811334c8:	30bff92e 	bgeu	r6,r2,811334b0 <__reset+0xfb1134b0>
811334cc:	003e2506 	br	81132d64 <__reset+0xfb112d64>
811334d0:	21003fcc 	andi	r4,r4,255
811334d4:	2002d41e 	bne	r4,zero,81134028 <___vfiprintf_internal_r+0x144c>
811334d8:	a5000414 	ori	r20,r20,16
811334dc:	a080080c 	andi	r2,r20,32
811334e0:	103fb51e 	bne	r2,zero,811333b8 <__reset+0xfb1133b8>
811334e4:	a080040c 	andi	r2,r20,16
811334e8:	1001f826 	beq	r2,zero,81133ccc <___vfiprintf_internal_r+0x10f0>
811334ec:	da802217 	ldw	r10,136(sp)
811334f0:	54800017 	ldw	r18,0(r10)
811334f4:	52800104 	addi	r10,r10,4
811334f8:	da802215 	stw	r10,136(sp)
811334fc:	9027d7fa 	srai	r19,r18,31
81133500:	9805883a 	mov	r2,r19
81133504:	003fb206 	br	811333d0 <__reset+0xfb1133d0>
81133508:	21003fcc 	andi	r4,r4,255
8113350c:	2002c41e 	bne	r4,zero,81134020 <___vfiprintf_internal_r+0x1444>
81133510:	a5000414 	ori	r20,r20,16
81133514:	a080080c 	andi	r2,r20,32
81133518:	103f5f1e 	bne	r2,zero,81133298 <__reset+0xfb113298>
8113351c:	a080040c 	andi	r2,r20,16
81133520:	10020f26 	beq	r2,zero,81133d60 <___vfiprintf_internal_r+0x1184>
81133524:	da802217 	ldw	r10,136(sp)
81133528:	d8001d85 	stb	zero,118(sp)
8113352c:	0027883a 	mov	r19,zero
81133530:	50800104 	addi	r2,r10,4
81133534:	54800017 	ldw	r18,0(r10)
81133538:	48021116 	blt	r9,zero,81133d80 <___vfiprintf_internal_r+0x11a4>
8113353c:	00ffdfc4 	movi	r3,-129
81133540:	d8802215 	stw	r2,136(sp)
81133544:	a0e8703a 	and	r20,r20,r3
81133548:	903f5e1e 	bne	r18,zero,811332c4 <__reset+0xfb1132c4>
8113354c:	0039883a 	mov	fp,zero
81133550:	4802a626 	beq	r9,zero,81133fec <___vfiprintf_internal_r+0x1410>
81133554:	0025883a 	mov	r18,zero
81133558:	0027883a 	mov	r19,zero
8113355c:	003f5a06 	br	811332c8 <__reset+0xfb1132c8>
81133560:	21003fcc 	andi	r4,r4,255
81133564:	20029f1e 	bne	r4,zero,81133fe4 <___vfiprintf_internal_r+0x1408>
81133568:	a5000414 	ori	r20,r20,16
8113356c:	a080080c 	andi	r2,r20,32
81133570:	10005e1e 	bne	r2,zero,811336ec <___vfiprintf_internal_r+0xb10>
81133574:	a080040c 	andi	r2,r20,16
81133578:	1001a21e 	bne	r2,zero,81133c04 <___vfiprintf_internal_r+0x1028>
8113357c:	a080100c 	andi	r2,r20,64
81133580:	d8001d85 	stb	zero,118(sp)
81133584:	da802217 	ldw	r10,136(sp)
81133588:	1002231e 	bne	r2,zero,81133e18 <___vfiprintf_internal_r+0x123c>
8113358c:	50800104 	addi	r2,r10,4
81133590:	54800017 	ldw	r18,0(r10)
81133594:	0027883a 	mov	r19,zero
81133598:	4801a00e 	bge	r9,zero,81133c1c <___vfiprintf_internal_r+0x1040>
8113359c:	d8802215 	stw	r2,136(sp)
811335a0:	0039883a 	mov	fp,zero
811335a4:	94c4b03a 	or	r2,r18,r19
811335a8:	103f901e 	bne	r2,zero,811333ec <__reset+0xfb1133ec>
811335ac:	00800044 	movi	r2,1
811335b0:	10803fcc 	andi	r2,r2,255
811335b4:	00c00044 	movi	r3,1
811335b8:	10c05926 	beq	r2,r3,81133720 <___vfiprintf_internal_r+0xb44>
811335bc:	00c00084 	movi	r3,2
811335c0:	10ffe41e 	bne	r2,r3,81133554 <__reset+0xfb113554>
811335c4:	0025883a 	mov	r18,zero
811335c8:	0027883a 	mov	r19,zero
811335cc:	00013d06 	br	81133ac4 <___vfiprintf_internal_r+0xee8>
811335d0:	21003fcc 	andi	r4,r4,255
811335d4:	2002811e 	bne	r4,zero,81133fdc <___vfiprintf_internal_r+0x1400>
811335d8:	00a04574 	movhi	r2,33045
811335dc:	10873f04 	addi	r2,r2,7420
811335e0:	d8802615 	stw	r2,152(sp)
811335e4:	a080080c 	andi	r2,r20,32
811335e8:	103f561e 	bne	r2,zero,81133344 <__reset+0xfb113344>
811335ec:	a080040c 	andi	r2,r20,16
811335f0:	1001d126 	beq	r2,zero,81133d38 <___vfiprintf_internal_r+0x115c>
811335f4:	da802217 	ldw	r10,136(sp)
811335f8:	0027883a 	mov	r19,zero
811335fc:	54800017 	ldw	r18,0(r10)
81133600:	52800104 	addi	r10,r10,4
81133604:	da802215 	stw	r10,136(sp)
81133608:	003f5306 	br	81133358 <__reset+0xfb113358>
8113360c:	da802217 	ldw	r10,136(sp)
81133610:	d8001d85 	stb	zero,118(sp)
81133614:	55400017 	ldw	r21,0(r10)
81133618:	50c00104 	addi	r3,r10,4
8113361c:	a8024226 	beq	r21,zero,81133f28 <___vfiprintf_internal_r+0x134c>
81133620:	48021816 	blt	r9,zero,81133e84 <___vfiprintf_internal_r+0x12a8>
81133624:	480d883a 	mov	r6,r9
81133628:	000b883a 	mov	r5,zero
8113362c:	a809883a 	mov	r4,r21
81133630:	d8c02a15 	stw	r3,168(sp)
81133634:	da002b15 	stw	r8,172(sp)
81133638:	da402c15 	stw	r9,176(sp)
8113363c:	112d9b80 	call	8112d9b8 <memchr>
81133640:	d8c02a17 	ldw	r3,168(sp)
81133644:	da002b17 	ldw	r8,172(sp)
81133648:	da402c17 	ldw	r9,176(sp)
8113364c:	10024826 	beq	r2,zero,81133f70 <___vfiprintf_internal_r+0x1394>
81133650:	1567c83a 	sub	r19,r2,r21
81133654:	df001d83 	ldbu	fp,118(sp)
81133658:	d8c02215 	stw	r3,136(sp)
8113365c:	0013883a 	mov	r9,zero
81133660:	003e6006 	br	81132fe4 <__reset+0xfb112fe4>
81133664:	21003fcc 	andi	r4,r4,255
81133668:	203fc026 	beq	r4,zero,8113356c <__reset+0xfb11356c>
8113366c:	d9c01d85 	stb	r7,118(sp)
81133670:	003fbe06 	br	8113356c <__reset+0xfb11356c>
81133674:	da802217 	ldw	r10,136(sp)
81133678:	54400017 	ldw	r17,0(r10)
8113367c:	50800104 	addi	r2,r10,4
81133680:	883e3b16 	blt	r17,zero,81132f70 <__reset+0xfb112f70>
81133684:	d8802215 	stw	r2,136(sp)
81133688:	80c00007 	ldb	r3,0(r16)
8113368c:	003db406 	br	81132d60 <__reset+0xfb112d60>
81133690:	01000044 	movi	r4,1
81133694:	01c00ac4 	movi	r7,43
81133698:	80c00007 	ldb	r3,0(r16)
8113369c:	003db006 	br	81132d60 <__reset+0xfb112d60>
811336a0:	80c00007 	ldb	r3,0(r16)
811336a4:	82800044 	addi	r10,r16,1
811336a8:	1b423c26 	beq	r3,r13,81133f9c <___vfiprintf_internal_r+0x13c0>
811336ac:	18bff404 	addi	r2,r3,-48
811336b0:	0013883a 	mov	r9,zero
811336b4:	30822b36 	bltu	r6,r2,81133f64 <___vfiprintf_internal_r+0x1388>
811336b8:	50c00007 	ldb	r3,0(r10)
811336bc:	4a4002a4 	muli	r9,r9,10
811336c0:	54000044 	addi	r16,r10,1
811336c4:	8015883a 	mov	r10,r16
811336c8:	4893883a 	add	r9,r9,r2
811336cc:	18bff404 	addi	r2,r3,-48
811336d0:	30bff92e 	bgeu	r6,r2,811336b8 <__reset+0xfb1136b8>
811336d4:	483da30e 	bge	r9,zero,81132d64 <__reset+0xfb112d64>
811336d8:	027fffc4 	movi	r9,-1
811336dc:	003da106 	br	81132d64 <__reset+0xfb112d64>
811336e0:	a5001014 	ori	r20,r20,64
811336e4:	80c00007 	ldb	r3,0(r16)
811336e8:	003d9d06 	br	81132d60 <__reset+0xfb112d60>
811336ec:	da802217 	ldw	r10,136(sp)
811336f0:	d8001d85 	stb	zero,118(sp)
811336f4:	50c00204 	addi	r3,r10,8
811336f8:	54800017 	ldw	r18,0(r10)
811336fc:	54c00117 	ldw	r19,4(r10)
81133700:	4801ca16 	blt	r9,zero,81133e2c <___vfiprintf_internal_r+0x1250>
81133704:	013fdfc4 	movi	r4,-129
81133708:	94c4b03a 	or	r2,r18,r19
8113370c:	d8c02215 	stw	r3,136(sp)
81133710:	a128703a 	and	r20,r20,r4
81133714:	0039883a 	mov	fp,zero
81133718:	103f341e 	bne	r2,zero,811333ec <__reset+0xfb1133ec>
8113371c:	483e2e26 	beq	r9,zero,81132fd8 <__reset+0xfb112fd8>
81133720:	0025883a 	mov	r18,zero
81133724:	94800c04 	addi	r18,r18,48
81133728:	dc8019c5 	stb	r18,103(sp)
8113372c:	dcc02717 	ldw	r19,156(sp)
81133730:	dd4019c4 	addi	r21,sp,103
81133734:	003e2b06 	br	81132fe4 <__reset+0xfb112fe4>
81133738:	21003fcc 	andi	r4,r4,255
8113373c:	2002361e 	bne	r4,zero,81134018 <___vfiprintf_internal_r+0x143c>
81133740:	1801c126 	beq	r3,zero,81133e48 <___vfiprintf_internal_r+0x126c>
81133744:	04800044 	movi	r18,1
81133748:	d8c01005 	stb	r3,64(sp)
8113374c:	d8001d85 	stb	zero,118(sp)
81133750:	9027883a 	mov	r19,r18
81133754:	dd401004 	addi	r21,sp,64
81133758:	003f1106 	br	811333a0 <__reset+0xfb1133a0>
8113375c:	d9402117 	ldw	r5,132(sp)
81133760:	d9002017 	ldw	r4,128(sp)
81133764:	d9801a04 	addi	r6,sp,104
81133768:	d9c02b15 	stw	r7,172(sp)
8113376c:	dbc02a15 	stw	r15,168(sp)
81133770:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133774:	d9c02b17 	ldw	r7,172(sp)
81133778:	dbc02a17 	ldw	r15,168(sp)
8113377c:	10006d1e 	bne	r2,zero,81133934 <___vfiprintf_internal_r+0xd58>
81133780:	d9801b17 	ldw	r6,108(sp)
81133784:	d8801c17 	ldw	r2,112(sp)
81133788:	d811883a 	mov	r8,sp
8113378c:	31400044 	addi	r5,r6,1
81133790:	003e3306 	br	81133060 <__reset+0xfb113060>
81133794:	d9401b17 	ldw	r5,108(sp)
81133798:	d8801c17 	ldw	r2,112(sp)
8113379c:	29000044 	addi	r4,r5,1
811337a0:	d8c01d87 	ldb	r3,118(sp)
811337a4:	183e4d26 	beq	r3,zero,811330dc <__reset+0xfb1130dc>
811337a8:	00c00044 	movi	r3,1
811337ac:	d9401d84 	addi	r5,sp,118
811337b0:	10c5883a 	add	r2,r2,r3
811337b4:	41400015 	stw	r5,0(r8)
811337b8:	40c00115 	stw	r3,4(r8)
811337bc:	d8801c15 	stw	r2,112(sp)
811337c0:	d9001b15 	stw	r4,108(sp)
811337c4:	014001c4 	movi	r5,7
811337c8:	2900a90e 	bge	r5,r4,81133a70 <___vfiprintf_internal_r+0xe94>
811337cc:	1000da1e 	bne	r2,zero,81133b38 <___vfiprintf_internal_r+0xf5c>
811337d0:	7000ab1e 	bne	r14,zero,81133a80 <___vfiprintf_internal_r+0xea4>
811337d4:	000b883a 	mov	r5,zero
811337d8:	1809883a 	mov	r4,r3
811337dc:	d811883a 	mov	r8,sp
811337e0:	00c02004 	movi	r3,128
811337e4:	e0fe4d26 	beq	fp,r3,8113311c <__reset+0xfb11311c>
811337e8:	4cf9c83a 	sub	fp,r9,r19
811337ec:	073e7b0e 	bge	zero,fp,811331dc <__reset+0xfb1131dc>
811337f0:	01c00404 	movi	r7,16
811337f4:	3f01900e 	bge	r7,fp,81133e38 <___vfiprintf_internal_r+0x125c>
811337f8:	00e04574 	movhi	r3,33045
811337fc:	18c7d604 	addi	r3,r3,8024
81133800:	d8c02415 	stw	r3,144(sp)
81133804:	034001c4 	movi	r13,7
81133808:	00000506 	br	81133820 <___vfiprintf_internal_r+0xc44>
8113380c:	29000084 	addi	r4,r5,2
81133810:	42000204 	addi	r8,r8,8
81133814:	180b883a 	mov	r5,r3
81133818:	e73ffc04 	addi	fp,fp,-16
8113381c:	3f000d0e 	bge	r7,fp,81133854 <___vfiprintf_internal_r+0xc78>
81133820:	10800404 	addi	r2,r2,16
81133824:	28c00044 	addi	r3,r5,1
81133828:	45c00015 	stw	r23,0(r8)
8113382c:	41c00115 	stw	r7,4(r8)
81133830:	d8801c15 	stw	r2,112(sp)
81133834:	d8c01b15 	stw	r3,108(sp)
81133838:	68fff40e 	bge	r13,r3,8113380c <__reset+0xfb11380c>
8113383c:	1000101e 	bne	r2,zero,81133880 <___vfiprintf_internal_r+0xca4>
81133840:	e73ffc04 	addi	fp,fp,-16
81133844:	01000044 	movi	r4,1
81133848:	000b883a 	mov	r5,zero
8113384c:	d811883a 	mov	r8,sp
81133850:	3f3ff316 	blt	r7,fp,81133820 <__reset+0xfb113820>
81133854:	da802417 	ldw	r10,144(sp)
81133858:	1705883a 	add	r2,r2,fp
8113385c:	47000115 	stw	fp,4(r8)
81133860:	42800015 	stw	r10,0(r8)
81133864:	d8801c15 	stw	r2,112(sp)
81133868:	d9001b15 	stw	r4,108(sp)
8113386c:	00c001c4 	movi	r3,7
81133870:	19003616 	blt	r3,r4,8113394c <___vfiprintf_internal_r+0xd70>
81133874:	42000204 	addi	r8,r8,8
81133878:	21000044 	addi	r4,r4,1
8113387c:	003e5706 	br	811331dc <__reset+0xfb1131dc>
81133880:	d9402117 	ldw	r5,132(sp)
81133884:	d9002017 	ldw	r4,128(sp)
81133888:	d9801a04 	addi	r6,sp,104
8113388c:	d9c02b15 	stw	r7,172(sp)
81133890:	db402a15 	stw	r13,168(sp)
81133894:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133898:	d9c02b17 	ldw	r7,172(sp)
8113389c:	db402a17 	ldw	r13,168(sp)
811338a0:	1000241e 	bne	r2,zero,81133934 <___vfiprintf_internal_r+0xd58>
811338a4:	d9401b17 	ldw	r5,108(sp)
811338a8:	d8801c17 	ldw	r2,112(sp)
811338ac:	d811883a 	mov	r8,sp
811338b0:	29000044 	addi	r4,r5,1
811338b4:	003fd806 	br	81133818 <__reset+0xfb113818>
811338b8:	d9401b17 	ldw	r5,108(sp)
811338bc:	00e04574 	movhi	r3,33045
811338c0:	18c7da04 	addi	r3,r3,8040
811338c4:	d8c02415 	stw	r3,144(sp)
811338c8:	29400044 	addi	r5,r5,1
811338cc:	d8c02417 	ldw	r3,144(sp)
811338d0:	14c5883a 	add	r2,r2,r19
811338d4:	44c00115 	stw	r19,4(r8)
811338d8:	40c00015 	stw	r3,0(r8)
811338dc:	d8801c15 	stw	r2,112(sp)
811338e0:	d9401b15 	stw	r5,108(sp)
811338e4:	00c001c4 	movi	r3,7
811338e8:	1940070e 	bge	r3,r5,81133908 <___vfiprintf_internal_r+0xd2c>
811338ec:	103e4826 	beq	r2,zero,81133210 <__reset+0xfb113210>
811338f0:	d9402117 	ldw	r5,132(sp)
811338f4:	d9002017 	ldw	r4,128(sp)
811338f8:	d9801a04 	addi	r6,sp,104
811338fc:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133900:	10000c1e 	bne	r2,zero,81133934 <___vfiprintf_internal_r+0xd58>
81133904:	d8801c17 	ldw	r2,112(sp)
81133908:	8c80010e 	bge	r17,r18,81133910 <___vfiprintf_internal_r+0xd34>
8113390c:	9023883a 	mov	r17,r18
81133910:	da802317 	ldw	r10,140(sp)
81133914:	5455883a 	add	r10,r10,r17
81133918:	da802315 	stw	r10,140(sp)
8113391c:	103e4126 	beq	r2,zero,81133224 <__reset+0xfb113224>
81133920:	d9402117 	ldw	r5,132(sp)
81133924:	d9002017 	ldw	r4,128(sp)
81133928:	d9801a04 	addi	r6,sp,104
8113392c:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133930:	103e3c26 	beq	r2,zero,81133224 <__reset+0xfb113224>
81133934:	dd002117 	ldw	r20,132(sp)
81133938:	a080030b 	ldhu	r2,12(r20)
8113393c:	1080100c 	andi	r2,r2,64
81133940:	1001231e 	bne	r2,zero,81133dd0 <___vfiprintf_internal_r+0x11f4>
81133944:	d8802317 	ldw	r2,140(sp)
81133948:	003d7b06 	br	81132f38 <__reset+0xfb112f38>
8113394c:	1000991e 	bne	r2,zero,81133bb4 <___vfiprintf_internal_r+0xfd8>
81133950:	00c00044 	movi	r3,1
81133954:	9805883a 	mov	r2,r19
81133958:	dd400015 	stw	r21,0(sp)
8113395c:	dcc00115 	stw	r19,4(sp)
81133960:	dcc01c15 	stw	r19,112(sp)
81133964:	d8c01b15 	stw	r3,108(sp)
81133968:	d811883a 	mov	r8,sp
8113396c:	42000204 	addi	r8,r8,8
81133970:	a2c0010c 	andi	r11,r20,4
81133974:	583fe426 	beq	r11,zero,81133908 <__reset+0xfb113908>
81133978:	8ca7c83a 	sub	r19,r17,r18
8113397c:	04ffe20e 	bge	zero,r19,81133908 <__reset+0xfb113908>
81133980:	01c00404 	movi	r7,16
81133984:	3cffcc0e 	bge	r7,r19,811338b8 <__reset+0xfb1138b8>
81133988:	02a04574 	movhi	r10,33045
8113398c:	5287da04 	addi	r10,r10,8040
81133990:	d9001b17 	ldw	r4,108(sp)
81133994:	da802415 	stw	r10,144(sp)
81133998:	382b883a 	mov	r21,r7
8113399c:	050001c4 	movi	r20,7
811339a0:	df002017 	ldw	fp,128(sp)
811339a4:	00000506 	br	811339bc <___vfiprintf_internal_r+0xde0>
811339a8:	21400084 	addi	r5,r4,2
811339ac:	42000204 	addi	r8,r8,8
811339b0:	1809883a 	mov	r4,r3
811339b4:	9cfffc04 	addi	r19,r19,-16
811339b8:	acffc40e 	bge	r21,r19,811338cc <__reset+0xfb1138cc>
811339bc:	10800404 	addi	r2,r2,16
811339c0:	20c00044 	addi	r3,r4,1
811339c4:	45800015 	stw	r22,0(r8)
811339c8:	45400115 	stw	r21,4(r8)
811339cc:	d8801c15 	stw	r2,112(sp)
811339d0:	d8c01b15 	stw	r3,108(sp)
811339d4:	a0fff40e 	bge	r20,r3,811339a8 <__reset+0xfb1139a8>
811339d8:	1000041e 	bne	r2,zero,811339ec <___vfiprintf_internal_r+0xe10>
811339dc:	01400044 	movi	r5,1
811339e0:	0009883a 	mov	r4,zero
811339e4:	d811883a 	mov	r8,sp
811339e8:	003ff206 	br	811339b4 <__reset+0xfb1139b4>
811339ec:	d9402117 	ldw	r5,132(sp)
811339f0:	d9801a04 	addi	r6,sp,104
811339f4:	e009883a 	mov	r4,fp
811339f8:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
811339fc:	103fcd1e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133a00:	d9001b17 	ldw	r4,108(sp)
81133a04:	d8801c17 	ldw	r2,112(sp)
81133a08:	d811883a 	mov	r8,sp
81133a0c:	21400044 	addi	r5,r4,1
81133a10:	003fe806 	br	811339b4 <__reset+0xfb1139b4>
81133a14:	d9402117 	ldw	r5,132(sp)
81133a18:	d9002017 	ldw	r4,128(sp)
81133a1c:	d9801a04 	addi	r6,sp,104
81133a20:	d9c02b15 	stw	r7,172(sp)
81133a24:	db402a15 	stw	r13,168(sp)
81133a28:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133a2c:	d9c02b17 	ldw	r7,172(sp)
81133a30:	db402a17 	ldw	r13,168(sp)
81133a34:	103fbf1e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133a38:	d9401b17 	ldw	r5,108(sp)
81133a3c:	d8801c17 	ldw	r2,112(sp)
81133a40:	d811883a 	mov	r8,sp
81133a44:	29800044 	addi	r6,r5,1
81133a48:	003dc406 	br	8113315c <__reset+0xfb11315c>
81133a4c:	1000d21e 	bne	r2,zero,81133d98 <___vfiprintf_internal_r+0x11bc>
81133a50:	d8c01d87 	ldb	r3,118(sp)
81133a54:	18009526 	beq	r3,zero,81133cac <___vfiprintf_internal_r+0x10d0>
81133a58:	00800044 	movi	r2,1
81133a5c:	d8c01d84 	addi	r3,sp,118
81133a60:	1009883a 	mov	r4,r2
81133a64:	d8c00015 	stw	r3,0(sp)
81133a68:	d8800115 	stw	r2,4(sp)
81133a6c:	d811883a 	mov	r8,sp
81133a70:	200b883a 	mov	r5,r4
81133a74:	42000204 	addi	r8,r8,8
81133a78:	21000044 	addi	r4,r4,1
81133a7c:	003d9706 	br	811330dc <__reset+0xfb1130dc>
81133a80:	d9001d04 	addi	r4,sp,116
81133a84:	00800084 	movi	r2,2
81133a88:	d9000015 	stw	r4,0(sp)
81133a8c:	d8800115 	stw	r2,4(sp)
81133a90:	1809883a 	mov	r4,r3
81133a94:	d811883a 	mov	r8,sp
81133a98:	200b883a 	mov	r5,r4
81133a9c:	42000204 	addi	r8,r8,8
81133aa0:	21000044 	addi	r4,r4,1
81133aa4:	003f4e06 	br	811337e0 <__reset+0xfb1137e0>
81133aa8:	d8001d85 	stb	zero,118(sp)
81133aac:	48005016 	blt	r9,zero,81133bf0 <___vfiprintf_internal_r+0x1014>
81133ab0:	00ffdfc4 	movi	r3,-129
81133ab4:	94c4b03a 	or	r2,r18,r19
81133ab8:	a0e8703a 	and	r20,r20,r3
81133abc:	103d4426 	beq	r2,zero,81132fd0 <__reset+0xfb112fd0>
81133ac0:	0039883a 	mov	fp,zero
81133ac4:	d9002617 	ldw	r4,152(sp)
81133ac8:	dd401a04 	addi	r21,sp,104
81133acc:	908003cc 	andi	r2,r18,15
81133ad0:	9806973a 	slli	r3,r19,28
81133ad4:	2085883a 	add	r2,r4,r2
81133ad8:	9024d13a 	srli	r18,r18,4
81133adc:	10800003 	ldbu	r2,0(r2)
81133ae0:	9826d13a 	srli	r19,r19,4
81133ae4:	ad7fffc4 	addi	r21,r21,-1
81133ae8:	1ca4b03a 	or	r18,r3,r18
81133aec:	a8800005 	stb	r2,0(r21)
81133af0:	94c4b03a 	or	r2,r18,r19
81133af4:	103ff51e 	bne	r2,zero,81133acc <__reset+0xfb113acc>
81133af8:	003e5906 	br	81133460 <__reset+0xfb113460>
81133afc:	d9402117 	ldw	r5,132(sp)
81133b00:	d9002017 	ldw	r4,128(sp)
81133b04:	d9801a04 	addi	r6,sp,104
81133b08:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133b0c:	103f891e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133b10:	d8801c17 	ldw	r2,112(sp)
81133b14:	d811883a 	mov	r8,sp
81133b18:	003f9506 	br	81133970 <__reset+0xfb113970>
81133b1c:	d9402117 	ldw	r5,132(sp)
81133b20:	d9002017 	ldw	r4,128(sp)
81133b24:	d9801a04 	addi	r6,sp,104
81133b28:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133b2c:	103f811e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133b30:	d811883a 	mov	r8,sp
81133b34:	003ced06 	br	81132eec <__reset+0xfb112eec>
81133b38:	d9402117 	ldw	r5,132(sp)
81133b3c:	d9002017 	ldw	r4,128(sp)
81133b40:	d9801a04 	addi	r6,sp,104
81133b44:	da402c15 	stw	r9,176(sp)
81133b48:	db802a15 	stw	r14,168(sp)
81133b4c:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133b50:	da402c17 	ldw	r9,176(sp)
81133b54:	db802a17 	ldw	r14,168(sp)
81133b58:	103f761e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133b5c:	d9401b17 	ldw	r5,108(sp)
81133b60:	d8801c17 	ldw	r2,112(sp)
81133b64:	d811883a 	mov	r8,sp
81133b68:	29000044 	addi	r4,r5,1
81133b6c:	003d5b06 	br	811330dc <__reset+0xfb1130dc>
81133b70:	d9402117 	ldw	r5,132(sp)
81133b74:	d9002017 	ldw	r4,128(sp)
81133b78:	d9801a04 	addi	r6,sp,104
81133b7c:	da402c15 	stw	r9,176(sp)
81133b80:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133b84:	da402c17 	ldw	r9,176(sp)
81133b88:	103f6a1e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133b8c:	d9401b17 	ldw	r5,108(sp)
81133b90:	d8801c17 	ldw	r2,112(sp)
81133b94:	d811883a 	mov	r8,sp
81133b98:	29000044 	addi	r4,r5,1
81133b9c:	003f1006 	br	811337e0 <__reset+0xfb1137e0>
81133ba0:	1000c31e 	bne	r2,zero,81133eb0 <___vfiprintf_internal_r+0x12d4>
81133ba4:	01000044 	movi	r4,1
81133ba8:	000b883a 	mov	r5,zero
81133bac:	d811883a 	mov	r8,sp
81133bb0:	003f0d06 	br	811337e8 <__reset+0xfb1137e8>
81133bb4:	d9402117 	ldw	r5,132(sp)
81133bb8:	d9002017 	ldw	r4,128(sp)
81133bbc:	d9801a04 	addi	r6,sp,104
81133bc0:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133bc4:	103f5b1e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133bc8:	d9001b17 	ldw	r4,108(sp)
81133bcc:	d8801c17 	ldw	r2,112(sp)
81133bd0:	d811883a 	mov	r8,sp
81133bd4:	21000044 	addi	r4,r4,1
81133bd8:	003d8006 	br	811331dc <__reset+0xfb1131dc>
81133bdc:	01204574 	movhi	r4,33045
81133be0:	21074404 	addi	r4,r4,7440
81133be4:	d9002615 	stw	r4,152(sp)
81133be8:	d8c02215 	stw	r3,136(sp)
81133bec:	1029883a 	mov	r20,r2
81133bf0:	94c4b03a 	or	r2,r18,r19
81133bf4:	103fb21e 	bne	r2,zero,81133ac0 <__reset+0xfb113ac0>
81133bf8:	0039883a 	mov	fp,zero
81133bfc:	00800084 	movi	r2,2
81133c00:	003e6b06 	br	811335b0 <__reset+0xfb1135b0>
81133c04:	da802217 	ldw	r10,136(sp)
81133c08:	d8001d85 	stb	zero,118(sp)
81133c0c:	0027883a 	mov	r19,zero
81133c10:	50800104 	addi	r2,r10,4
81133c14:	54800017 	ldw	r18,0(r10)
81133c18:	483e6016 	blt	r9,zero,8113359c <__reset+0xfb11359c>
81133c1c:	00ffdfc4 	movi	r3,-129
81133c20:	d8802215 	stw	r2,136(sp)
81133c24:	a0e8703a 	and	r20,r20,r3
81133c28:	0039883a 	mov	fp,zero
81133c2c:	903ebb26 	beq	r18,zero,8113371c <__reset+0xfb11371c>
81133c30:	00800244 	movi	r2,9
81133c34:	14bdee36 	bltu	r2,r18,811333f0 <__reset+0xfb1133f0>
81133c38:	003eba06 	br	81133724 <__reset+0xfb113724>
81133c3c:	00800c04 	movi	r2,48
81133c40:	d8c01d45 	stb	r3,117(sp)
81133c44:	d8801d05 	stb	r2,116(sp)
81133c48:	d8001d85 	stb	zero,118(sp)
81133c4c:	a0c00094 	ori	r3,r20,2
81133c50:	4800a916 	blt	r9,zero,81133ef8 <___vfiprintf_internal_r+0x131c>
81133c54:	00bfdfc4 	movi	r2,-129
81133c58:	a096703a 	and	r11,r20,r2
81133c5c:	5d000094 	ori	r20,r11,2
81133c60:	0039883a 	mov	fp,zero
81133c64:	003f9706 	br	81133ac4 <__reset+0xfb113ac4>
81133c68:	8025883a 	mov	r18,r16
81133c6c:	003c2e06 	br	81132d28 <__reset+0xfb112d28>
81133c70:	00a04574 	movhi	r2,33045
81133c74:	10874404 	addi	r2,r2,7440
81133c78:	0039883a 	mov	fp,zero
81133c7c:	d8802615 	stw	r2,152(sp)
81133c80:	003f9006 	br	81133ac4 <__reset+0xfb113ac4>
81133c84:	04a5c83a 	sub	r18,zero,r18
81133c88:	07000b44 	movi	fp,45
81133c8c:	9004c03a 	cmpne	r2,r18,zero
81133c90:	04e7c83a 	sub	r19,zero,r19
81133c94:	df001d85 	stb	fp,118(sp)
81133c98:	98a7c83a 	sub	r19,r19,r2
81133c9c:	48009f16 	blt	r9,zero,81133f1c <___vfiprintf_internal_r+0x1340>
81133ca0:	00bfdfc4 	movi	r2,-129
81133ca4:	a0a8703a 	and	r20,r20,r2
81133ca8:	003dd006 	br	811333ec <__reset+0xfb1133ec>
81133cac:	70004c26 	beq	r14,zero,81133de0 <___vfiprintf_internal_r+0x1204>
81133cb0:	00800084 	movi	r2,2
81133cb4:	d8c01d04 	addi	r3,sp,116
81133cb8:	d8c00015 	stw	r3,0(sp)
81133cbc:	d8800115 	stw	r2,4(sp)
81133cc0:	01000044 	movi	r4,1
81133cc4:	d811883a 	mov	r8,sp
81133cc8:	003f7306 	br	81133a98 <__reset+0xfb113a98>
81133ccc:	a080100c 	andi	r2,r20,64
81133cd0:	da802217 	ldw	r10,136(sp)
81133cd4:	103e0626 	beq	r2,zero,811334f0 <__reset+0xfb1134f0>
81133cd8:	5480000f 	ldh	r18,0(r10)
81133cdc:	52800104 	addi	r10,r10,4
81133ce0:	da802215 	stw	r10,136(sp)
81133ce4:	9027d7fa 	srai	r19,r18,31
81133ce8:	9805883a 	mov	r2,r19
81133cec:	003db806 	br	811333d0 <__reset+0xfb1133d0>
81133cf0:	a080040c 	andi	r2,r20,16
81133cf4:	1000091e 	bne	r2,zero,81133d1c <___vfiprintf_internal_r+0x1140>
81133cf8:	a2c0100c 	andi	r11,r20,64
81133cfc:	58000726 	beq	r11,zero,81133d1c <___vfiprintf_internal_r+0x1140>
81133d00:	da802217 	ldw	r10,136(sp)
81133d04:	50800017 	ldw	r2,0(r10)
81133d08:	52800104 	addi	r10,r10,4
81133d0c:	da802215 	stw	r10,136(sp)
81133d10:	da802317 	ldw	r10,140(sp)
81133d14:	1280000d 	sth	r10,0(r2)
81133d18:	003be706 	br	81132cb8 <__reset+0xfb112cb8>
81133d1c:	da802217 	ldw	r10,136(sp)
81133d20:	50800017 	ldw	r2,0(r10)
81133d24:	52800104 	addi	r10,r10,4
81133d28:	da802215 	stw	r10,136(sp)
81133d2c:	da802317 	ldw	r10,140(sp)
81133d30:	12800015 	stw	r10,0(r2)
81133d34:	003be006 	br	81132cb8 <__reset+0xfb112cb8>
81133d38:	a080100c 	andi	r2,r20,64
81133d3c:	da802217 	ldw	r10,136(sp)
81133d40:	10003026 	beq	r2,zero,81133e04 <___vfiprintf_internal_r+0x1228>
81133d44:	5480000b 	ldhu	r18,0(r10)
81133d48:	52800104 	addi	r10,r10,4
81133d4c:	0027883a 	mov	r19,zero
81133d50:	da802215 	stw	r10,136(sp)
81133d54:	003d8006 	br	81133358 <__reset+0xfb113358>
81133d58:	80c00007 	ldb	r3,0(r16)
81133d5c:	003c0006 	br	81132d60 <__reset+0xfb112d60>
81133d60:	a080100c 	andi	r2,r20,64
81133d64:	d8001d85 	stb	zero,118(sp)
81133d68:	da802217 	ldw	r10,136(sp)
81133d6c:	1000201e 	bne	r2,zero,81133df0 <___vfiprintf_internal_r+0x1214>
81133d70:	50800104 	addi	r2,r10,4
81133d74:	54800017 	ldw	r18,0(r10)
81133d78:	0027883a 	mov	r19,zero
81133d7c:	483def0e 	bge	r9,zero,8113353c <__reset+0xfb11353c>
81133d80:	94c6b03a 	or	r3,r18,r19
81133d84:	d8802215 	stw	r2,136(sp)
81133d88:	183d4e1e 	bne	r3,zero,811332c4 <__reset+0xfb1132c4>
81133d8c:	0039883a 	mov	fp,zero
81133d90:	0005883a 	mov	r2,zero
81133d94:	003e0606 	br	811335b0 <__reset+0xfb1135b0>
81133d98:	d9402117 	ldw	r5,132(sp)
81133d9c:	d9002017 	ldw	r4,128(sp)
81133da0:	d9801a04 	addi	r6,sp,104
81133da4:	da402c15 	stw	r9,176(sp)
81133da8:	db802a15 	stw	r14,168(sp)
81133dac:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133db0:	da402c17 	ldw	r9,176(sp)
81133db4:	db802a17 	ldw	r14,168(sp)
81133db8:	103ede1e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133dbc:	d9401b17 	ldw	r5,108(sp)
81133dc0:	d8801c17 	ldw	r2,112(sp)
81133dc4:	d811883a 	mov	r8,sp
81133dc8:	29000044 	addi	r4,r5,1
81133dcc:	003e7406 	br	811337a0 <__reset+0xfb1137a0>
81133dd0:	00bfffc4 	movi	r2,-1
81133dd4:	003c5806 	br	81132f38 <__reset+0xfb112f38>
81133dd8:	d811883a 	mov	r8,sp
81133ddc:	003ee806 	br	81133980 <__reset+0xfb113980>
81133de0:	000b883a 	mov	r5,zero
81133de4:	01000044 	movi	r4,1
81133de8:	d811883a 	mov	r8,sp
81133dec:	003e7c06 	br	811337e0 <__reset+0xfb1137e0>
81133df0:	50800104 	addi	r2,r10,4
81133df4:	5480000b 	ldhu	r18,0(r10)
81133df8:	0027883a 	mov	r19,zero
81133dfc:	483dcf0e 	bge	r9,zero,8113353c <__reset+0xfb11353c>
81133e00:	003fdf06 	br	81133d80 <__reset+0xfb113d80>
81133e04:	54800017 	ldw	r18,0(r10)
81133e08:	52800104 	addi	r10,r10,4
81133e0c:	0027883a 	mov	r19,zero
81133e10:	da802215 	stw	r10,136(sp)
81133e14:	003d5006 	br	81133358 <__reset+0xfb113358>
81133e18:	50800104 	addi	r2,r10,4
81133e1c:	5480000b 	ldhu	r18,0(r10)
81133e20:	0027883a 	mov	r19,zero
81133e24:	483f7d0e 	bge	r9,zero,81133c1c <__reset+0xfb113c1c>
81133e28:	003ddc06 	br	8113359c <__reset+0xfb11359c>
81133e2c:	d8c02215 	stw	r3,136(sp)
81133e30:	0039883a 	mov	fp,zero
81133e34:	003ddb06 	br	811335a4 <__reset+0xfb1135a4>
81133e38:	02a04574 	movhi	r10,33045
81133e3c:	5287d604 	addi	r10,r10,8024
81133e40:	da802415 	stw	r10,144(sp)
81133e44:	003e8306 	br	81133854 <__reset+0xfb113854>
81133e48:	d8801c17 	ldw	r2,112(sp)
81133e4c:	dd002117 	ldw	r20,132(sp)
81133e50:	103eb926 	beq	r2,zero,81133938 <__reset+0xfb113938>
81133e54:	d9002017 	ldw	r4,128(sp)
81133e58:	d9801a04 	addi	r6,sp,104
81133e5c:	a00b883a 	mov	r5,r20
81133e60:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133e64:	003eb406 	br	81133938 <__reset+0xfb113938>
81133e68:	80c00043 	ldbu	r3,1(r16)
81133e6c:	a5000814 	ori	r20,r20,32
81133e70:	84000044 	addi	r16,r16,1
81133e74:	18c03fcc 	andi	r3,r3,255
81133e78:	18c0201c 	xori	r3,r3,128
81133e7c:	18ffe004 	addi	r3,r3,-128
81133e80:	003bb706 	br	81132d60 <__reset+0xfb112d60>
81133e84:	a809883a 	mov	r4,r21
81133e88:	d8c02a15 	stw	r3,168(sp)
81133e8c:	da002b15 	stw	r8,172(sp)
81133e90:	11244bc0 	call	811244bc <strlen>
81133e94:	d8c02a17 	ldw	r3,168(sp)
81133e98:	1027883a 	mov	r19,r2
81133e9c:	df001d83 	ldbu	fp,118(sp)
81133ea0:	d8c02215 	stw	r3,136(sp)
81133ea4:	0013883a 	mov	r9,zero
81133ea8:	da002b17 	ldw	r8,172(sp)
81133eac:	003c4d06 	br	81132fe4 <__reset+0xfb112fe4>
81133eb0:	d9402117 	ldw	r5,132(sp)
81133eb4:	d9002017 	ldw	r4,128(sp)
81133eb8:	d9801a04 	addi	r6,sp,104
81133ebc:	da402c15 	stw	r9,176(sp)
81133ec0:	1132ac00 	call	81132ac0 <__sprint_r.part.0>
81133ec4:	da402c17 	ldw	r9,176(sp)
81133ec8:	103e9a1e 	bne	r2,zero,81133934 <__reset+0xfb113934>
81133ecc:	d9401b17 	ldw	r5,108(sp)
81133ed0:	d8801c17 	ldw	r2,112(sp)
81133ed4:	d811883a 	mov	r8,sp
81133ed8:	29000044 	addi	r4,r5,1
81133edc:	003e4206 	br	811337e8 <__reset+0xfb1137e8>
81133ee0:	d9401b17 	ldw	r5,108(sp)
81133ee4:	01204574 	movhi	r4,33045
81133ee8:	2107da04 	addi	r4,r4,8040
81133eec:	d9002415 	stw	r4,144(sp)
81133ef0:	29400044 	addi	r5,r5,1
81133ef4:	003c6d06 	br	811330ac <__reset+0xfb1130ac>
81133ef8:	0039883a 	mov	fp,zero
81133efc:	00800084 	movi	r2,2
81133f00:	10803fcc 	andi	r2,r2,255
81133f04:	01000044 	movi	r4,1
81133f08:	11001e26 	beq	r2,r4,81133f84 <___vfiprintf_internal_r+0x13a8>
81133f0c:	01000084 	movi	r4,2
81133f10:	11001e1e 	bne	r2,r4,81133f8c <___vfiprintf_internal_r+0x13b0>
81133f14:	1829883a 	mov	r20,r3
81133f18:	003eea06 	br	81133ac4 <__reset+0xfb113ac4>
81133f1c:	a007883a 	mov	r3,r20
81133f20:	00800044 	movi	r2,1
81133f24:	003ff606 	br	81133f00 <__reset+0xfb113f00>
81133f28:	00800184 	movi	r2,6
81133f2c:	1240012e 	bgeu	r2,r9,81133f34 <___vfiprintf_internal_r+0x1358>
81133f30:	1013883a 	mov	r9,r2
81133f34:	4827883a 	mov	r19,r9
81133f38:	4825883a 	mov	r18,r9
81133f3c:	48001516 	blt	r9,zero,81133f94 <___vfiprintf_internal_r+0x13b8>
81133f40:	05604574 	movhi	r21,33045
81133f44:	d8c02215 	stw	r3,136(sp)
81133f48:	ad474904 	addi	r21,r21,7460
81133f4c:	003d1406 	br	811333a0 <__reset+0xfb1133a0>
81133f50:	02a04574 	movhi	r10,33045
81133f54:	5287d604 	addi	r10,r10,8024
81133f58:	da802415 	stw	r10,144(sp)
81133f5c:	200d883a 	mov	r6,r4
81133f60:	003c9106 	br	811331a8 <__reset+0xfb1131a8>
81133f64:	5021883a 	mov	r16,r10
81133f68:	0013883a 	mov	r9,zero
81133f6c:	003b7d06 	br	81132d64 <__reset+0xfb112d64>
81133f70:	4827883a 	mov	r19,r9
81133f74:	df001d83 	ldbu	fp,118(sp)
81133f78:	d8c02215 	stw	r3,136(sp)
81133f7c:	0013883a 	mov	r9,zero
81133f80:	003c1806 	br	81132fe4 <__reset+0xfb112fe4>
81133f84:	1829883a 	mov	r20,r3
81133f88:	003d1806 	br	811333ec <__reset+0xfb1133ec>
81133f8c:	1829883a 	mov	r20,r3
81133f90:	003ccd06 	br	811332c8 <__reset+0xfb1132c8>
81133f94:	0025883a 	mov	r18,zero
81133f98:	003fe906 	br	81133f40 <__reset+0xfb113f40>
81133f9c:	d8802217 	ldw	r2,136(sp)
81133fa0:	80c00043 	ldbu	r3,1(r16)
81133fa4:	5021883a 	mov	r16,r10
81133fa8:	12400017 	ldw	r9,0(r2)
81133fac:	10800104 	addi	r2,r2,4
81133fb0:	d8802215 	stw	r2,136(sp)
81133fb4:	483faf0e 	bge	r9,zero,81133e74 <__reset+0xfb113e74>
81133fb8:	18c03fcc 	andi	r3,r3,255
81133fbc:	18c0201c 	xori	r3,r3,128
81133fc0:	027fffc4 	movi	r9,-1
81133fc4:	18ffe004 	addi	r3,r3,-128
81133fc8:	003b6506 	br	81132d60 <__reset+0xfb112d60>
81133fcc:	d9c01d85 	stb	r7,118(sp)
81133fd0:	003ca006 	br	81133254 <__reset+0xfb113254>
81133fd4:	d9c01d85 	stb	r7,118(sp)
81133fd8:	003cad06 	br	81133290 <__reset+0xfb113290>
81133fdc:	d9c01d85 	stb	r7,118(sp)
81133fe0:	003d7d06 	br	811335d8 <__reset+0xfb1135d8>
81133fe4:	d9c01d85 	stb	r7,118(sp)
81133fe8:	003d5f06 	br	81133568 <__reset+0xfb113568>
81133fec:	a080004c 	andi	r2,r20,1
81133ff0:	0039883a 	mov	fp,zero
81133ff4:	10000526 	beq	r2,zero,8113400c <___vfiprintf_internal_r+0x1430>
81133ff8:	00800c04 	movi	r2,48
81133ffc:	d88019c5 	stb	r2,103(sp)
81134000:	dcc02717 	ldw	r19,156(sp)
81134004:	dd4019c4 	addi	r21,sp,103
81134008:	003bf606 	br	81132fe4 <__reset+0xfb112fe4>
8113400c:	0027883a 	mov	r19,zero
81134010:	dd401a04 	addi	r21,sp,104
81134014:	003bf306 	br	81132fe4 <__reset+0xfb112fe4>
81134018:	d9c01d85 	stb	r7,118(sp)
8113401c:	003dc806 	br	81133740 <__reset+0xfb113740>
81134020:	d9c01d85 	stb	r7,118(sp)
81134024:	003d3a06 	br	81133510 <__reset+0xfb113510>
81134028:	d9c01d85 	stb	r7,118(sp)
8113402c:	003d2a06 	br	811334d8 <__reset+0xfb1134d8>
81134030:	d9c01d85 	stb	r7,118(sp)
81134034:	003cde06 	br	811333b0 <__reset+0xfb1133b0>
81134038:	d9c01d85 	stb	r7,118(sp)
8113403c:	003cbc06 	br	81133330 <__reset+0xfb113330>

81134040 <__vfiprintf_internal>:
81134040:	00a04574 	movhi	r2,33045
81134044:	10911304 	addi	r2,r2,17484
81134048:	300f883a 	mov	r7,r6
8113404c:	280d883a 	mov	r6,r5
81134050:	200b883a 	mov	r5,r4
81134054:	11000017 	ldw	r4,0(r2)
81134058:	1132bdc1 	jmpi	81132bdc <___vfiprintf_internal_r>

8113405c <__sbprintf>:
8113405c:	defee204 	addi	sp,sp,-1144
81134060:	de00012e 	bgeu	sp,et,81134068 <__sbprintf+0xc>
81134064:	003b68fa 	trap	3
81134068:	2880030b 	ldhu	r2,12(r5)
8113406c:	2ac01917 	ldw	r11,100(r5)
81134070:	2a80038b 	ldhu	r10,14(r5)
81134074:	2a400717 	ldw	r9,28(r5)
81134078:	2a000917 	ldw	r8,36(r5)
8113407c:	00c10004 	movi	r3,1024
81134080:	dc011a15 	stw	r16,1128(sp)
81134084:	10bfff4c 	andi	r2,r2,65533
81134088:	2821883a 	mov	r16,r5
8113408c:	d8cb883a 	add	r5,sp,r3
81134090:	dc811c15 	stw	r18,1136(sp)
81134094:	dc411b15 	stw	r17,1132(sp)
81134098:	dfc11d15 	stw	ra,1140(sp)
8113409c:	2025883a 	mov	r18,r4
811340a0:	d881030d 	sth	r2,1036(sp)
811340a4:	dac11915 	stw	r11,1124(sp)
811340a8:	da81038d 	sth	r10,1038(sp)
811340ac:	da410715 	stw	r9,1052(sp)
811340b0:	da010915 	stw	r8,1060(sp)
811340b4:	dec10015 	stw	sp,1024(sp)
811340b8:	dec10415 	stw	sp,1040(sp)
811340bc:	d8c10215 	stw	r3,1032(sp)
811340c0:	d8c10515 	stw	r3,1044(sp)
811340c4:	d8010615 	stw	zero,1048(sp)
811340c8:	1132bdc0 	call	81132bdc <___vfiprintf_internal_r>
811340cc:	1023883a 	mov	r17,r2
811340d0:	10000416 	blt	r2,zero,811340e4 <__sbprintf+0x88>
811340d4:	d9410004 	addi	r5,sp,1024
811340d8:	9009883a 	mov	r4,r18
811340dc:	112c3940 	call	8112c394 <_fflush_r>
811340e0:	10000d1e 	bne	r2,zero,81134118 <__sbprintf+0xbc>
811340e4:	d881030b 	ldhu	r2,1036(sp)
811340e8:	1080100c 	andi	r2,r2,64
811340ec:	10000326 	beq	r2,zero,811340fc <__sbprintf+0xa0>
811340f0:	8080030b 	ldhu	r2,12(r16)
811340f4:	10801014 	ori	r2,r2,64
811340f8:	8080030d 	sth	r2,12(r16)
811340fc:	8805883a 	mov	r2,r17
81134100:	dfc11d17 	ldw	ra,1140(sp)
81134104:	dc811c17 	ldw	r18,1136(sp)
81134108:	dc411b17 	ldw	r17,1132(sp)
8113410c:	dc011a17 	ldw	r16,1128(sp)
81134110:	dec11e04 	addi	sp,sp,1144
81134114:	f800283a 	ret
81134118:	047fffc4 	movi	r17,-1
8113411c:	003ff106 	br	811340e4 <__reset+0xfb1140e4>

81134120 <_calloc_r>:
81134120:	298b383a 	mul	r5,r5,r6
81134124:	defffe04 	addi	sp,sp,-8
81134128:	de00012e 	bgeu	sp,et,81134130 <_calloc_r+0x10>
8113412c:	003b68fa 	trap	3
81134130:	dfc00115 	stw	ra,4(sp)
81134134:	dc000015 	stw	r16,0(sp)
81134138:	11232300 	call	81123230 <_malloc_r>
8113413c:	10002926 	beq	r2,zero,811341e4 <_calloc_r+0xc4>
81134140:	11bfff17 	ldw	r6,-4(r2)
81134144:	1021883a 	mov	r16,r2
81134148:	00bfff04 	movi	r2,-4
8113414c:	308c703a 	and	r6,r6,r2
81134150:	00c00904 	movi	r3,36
81134154:	308d883a 	add	r6,r6,r2
81134158:	19801636 	bltu	r3,r6,811341b4 <_calloc_r+0x94>
8113415c:	008004c4 	movi	r2,19
81134160:	11800b2e 	bgeu	r2,r6,81134190 <_calloc_r+0x70>
81134164:	80000015 	stw	zero,0(r16)
81134168:	80000115 	stw	zero,4(r16)
8113416c:	008006c4 	movi	r2,27
81134170:	11801a2e 	bgeu	r2,r6,811341dc <_calloc_r+0xbc>
81134174:	80000215 	stw	zero,8(r16)
81134178:	80000315 	stw	zero,12(r16)
8113417c:	30c0151e 	bne	r6,r3,811341d4 <_calloc_r+0xb4>
81134180:	80000415 	stw	zero,16(r16)
81134184:	80800604 	addi	r2,r16,24
81134188:	80000515 	stw	zero,20(r16)
8113418c:	00000106 	br	81134194 <_calloc_r+0x74>
81134190:	8005883a 	mov	r2,r16
81134194:	10000015 	stw	zero,0(r2)
81134198:	10000115 	stw	zero,4(r2)
8113419c:	10000215 	stw	zero,8(r2)
811341a0:	8005883a 	mov	r2,r16
811341a4:	dfc00117 	ldw	ra,4(sp)
811341a8:	dc000017 	ldw	r16,0(sp)
811341ac:	dec00204 	addi	sp,sp,8
811341b0:	f800283a 	ret
811341b4:	000b883a 	mov	r5,zero
811341b8:	8009883a 	mov	r4,r16
811341bc:	1123b940 	call	81123b94 <memset>
811341c0:	8005883a 	mov	r2,r16
811341c4:	dfc00117 	ldw	ra,4(sp)
811341c8:	dc000017 	ldw	r16,0(sp)
811341cc:	dec00204 	addi	sp,sp,8
811341d0:	f800283a 	ret
811341d4:	80800404 	addi	r2,r16,16
811341d8:	003fee06 	br	81134194 <__reset+0xfb114194>
811341dc:	80800204 	addi	r2,r16,8
811341e0:	003fec06 	br	81134194 <__reset+0xfb114194>
811341e4:	0005883a 	mov	r2,zero
811341e8:	003fee06 	br	811341a4 <__reset+0xfb1141a4>

811341ec <_fclose_r>:
811341ec:	28003b26 	beq	r5,zero,811342dc <_fclose_r+0xf0>
811341f0:	defffc04 	addi	sp,sp,-16
811341f4:	de00012e 	bgeu	sp,et,811341fc <_fclose_r+0x10>
811341f8:	003b68fa 	trap	3
811341fc:	dc400115 	stw	r17,4(sp)
81134200:	dc000015 	stw	r16,0(sp)
81134204:	dfc00315 	stw	ra,12(sp)
81134208:	dc800215 	stw	r18,8(sp)
8113420c:	2023883a 	mov	r17,r4
81134210:	2821883a 	mov	r16,r5
81134214:	20000226 	beq	r4,zero,81134220 <_fclose_r+0x34>
81134218:	20800e17 	ldw	r2,56(r4)
8113421c:	10002726 	beq	r2,zero,811342bc <_fclose_r+0xd0>
81134220:	8080030f 	ldh	r2,12(r16)
81134224:	1000071e 	bne	r2,zero,81134244 <_fclose_r+0x58>
81134228:	0005883a 	mov	r2,zero
8113422c:	dfc00317 	ldw	ra,12(sp)
81134230:	dc800217 	ldw	r18,8(sp)
81134234:	dc400117 	ldw	r17,4(sp)
81134238:	dc000017 	ldw	r16,0(sp)
8113423c:	dec00404 	addi	sp,sp,16
81134240:	f800283a 	ret
81134244:	800b883a 	mov	r5,r16
81134248:	8809883a 	mov	r4,r17
8113424c:	112c1700 	call	8112c170 <__sflush_r>
81134250:	1025883a 	mov	r18,r2
81134254:	80800b17 	ldw	r2,44(r16)
81134258:	10000426 	beq	r2,zero,8113426c <_fclose_r+0x80>
8113425c:	81400717 	ldw	r5,28(r16)
81134260:	8809883a 	mov	r4,r17
81134264:	103ee83a 	callr	r2
81134268:	10001616 	blt	r2,zero,811342c4 <_fclose_r+0xd8>
8113426c:	8080030b 	ldhu	r2,12(r16)
81134270:	1080200c 	andi	r2,r2,128
81134274:	1000151e 	bne	r2,zero,811342cc <_fclose_r+0xe0>
81134278:	81400c17 	ldw	r5,48(r16)
8113427c:	28000526 	beq	r5,zero,81134294 <_fclose_r+0xa8>
81134280:	80801004 	addi	r2,r16,64
81134284:	28800226 	beq	r5,r2,81134290 <_fclose_r+0xa4>
81134288:	8809883a 	mov	r4,r17
8113428c:	112cc280 	call	8112cc28 <_free_r>
81134290:	80000c15 	stw	zero,48(r16)
81134294:	81401117 	ldw	r5,68(r16)
81134298:	28000326 	beq	r5,zero,811342a8 <_fclose_r+0xbc>
8113429c:	8809883a 	mov	r4,r17
811342a0:	112cc280 	call	8112cc28 <_free_r>
811342a4:	80001115 	stw	zero,68(r16)
811342a8:	112c7a00 	call	8112c7a0 <__sfp_lock_acquire>
811342ac:	8000030d 	sth	zero,12(r16)
811342b0:	112c7a40 	call	8112c7a4 <__sfp_lock_release>
811342b4:	9005883a 	mov	r2,r18
811342b8:	003fdc06 	br	8113422c <__reset+0xfb11422c>
811342bc:	112c7900 	call	8112c790 <__sinit>
811342c0:	003fd706 	br	81134220 <__reset+0xfb114220>
811342c4:	04bfffc4 	movi	r18,-1
811342c8:	003fe806 	br	8113426c <__reset+0xfb11426c>
811342cc:	81400417 	ldw	r5,16(r16)
811342d0:	8809883a 	mov	r4,r17
811342d4:	112cc280 	call	8112cc28 <_free_r>
811342d8:	003fe706 	br	81134278 <__reset+0xfb114278>
811342dc:	0005883a 	mov	r2,zero
811342e0:	f800283a 	ret

811342e4 <fclose>:
811342e4:	00a04574 	movhi	r2,33045
811342e8:	10911304 	addi	r2,r2,17484
811342ec:	200b883a 	mov	r5,r4
811342f0:	11000017 	ldw	r4,0(r2)
811342f4:	11341ec1 	jmpi	811341ec <_fclose_r>

811342f8 <__fputwc>:
811342f8:	defff804 	addi	sp,sp,-32
811342fc:	de00012e 	bgeu	sp,et,81134304 <__fputwc+0xc>
81134300:	003b68fa 	trap	3
81134304:	dcc00415 	stw	r19,16(sp)
81134308:	dc800315 	stw	r18,12(sp)
8113430c:	dc000115 	stw	r16,4(sp)
81134310:	dfc00715 	stw	ra,28(sp)
81134314:	dd400615 	stw	r21,24(sp)
81134318:	dd000515 	stw	r20,20(sp)
8113431c:	dc400215 	stw	r17,8(sp)
81134320:	2027883a 	mov	r19,r4
81134324:	2825883a 	mov	r18,r5
81134328:	3021883a 	mov	r16,r6
8113432c:	112d6b80 	call	8112d6b8 <__locale_mb_cur_max>
81134330:	00c00044 	movi	r3,1
81134334:	10c03e26 	beq	r2,r3,81134430 <__fputwc+0x138>
81134338:	81c01704 	addi	r7,r16,92
8113433c:	900d883a 	mov	r6,r18
81134340:	d80b883a 	mov	r5,sp
81134344:	9809883a 	mov	r4,r19
81134348:	113517c0 	call	8113517c <_wcrtomb_r>
8113434c:	1029883a 	mov	r20,r2
81134350:	00bfffc4 	movi	r2,-1
81134354:	a0802026 	beq	r20,r2,811343d8 <__fputwc+0xe0>
81134358:	d9400003 	ldbu	r5,0(sp)
8113435c:	a0001c26 	beq	r20,zero,811343d0 <__fputwc+0xd8>
81134360:	0023883a 	mov	r17,zero
81134364:	05400284 	movi	r21,10
81134368:	00000906 	br	81134390 <__fputwc+0x98>
8113436c:	80800017 	ldw	r2,0(r16)
81134370:	11400005 	stb	r5,0(r2)
81134374:	80c00017 	ldw	r3,0(r16)
81134378:	18c00044 	addi	r3,r3,1
8113437c:	80c00015 	stw	r3,0(r16)
81134380:	8c400044 	addi	r17,r17,1
81134384:	dc45883a 	add	r2,sp,r17
81134388:	8d00112e 	bgeu	r17,r20,811343d0 <__fputwc+0xd8>
8113438c:	11400003 	ldbu	r5,0(r2)
81134390:	80c00217 	ldw	r3,8(r16)
81134394:	18ffffc4 	addi	r3,r3,-1
81134398:	80c00215 	stw	r3,8(r16)
8113439c:	183ff30e 	bge	r3,zero,8113436c <__reset+0xfb11436c>
811343a0:	80800617 	ldw	r2,24(r16)
811343a4:	18801916 	blt	r3,r2,8113440c <__fputwc+0x114>
811343a8:	80800017 	ldw	r2,0(r16)
811343ac:	11400005 	stb	r5,0(r2)
811343b0:	80800017 	ldw	r2,0(r16)
811343b4:	10c00003 	ldbu	r3,0(r2)
811343b8:	10800044 	addi	r2,r2,1
811343bc:	1d402326 	beq	r3,r21,8113444c <__fputwc+0x154>
811343c0:	80800015 	stw	r2,0(r16)
811343c4:	8c400044 	addi	r17,r17,1
811343c8:	dc45883a 	add	r2,sp,r17
811343cc:	8d3fef36 	bltu	r17,r20,8113438c <__reset+0xfb11438c>
811343d0:	9005883a 	mov	r2,r18
811343d4:	00000406 	br	811343e8 <__fputwc+0xf0>
811343d8:	80c0030b 	ldhu	r3,12(r16)
811343dc:	a005883a 	mov	r2,r20
811343e0:	18c01014 	ori	r3,r3,64
811343e4:	80c0030d 	sth	r3,12(r16)
811343e8:	dfc00717 	ldw	ra,28(sp)
811343ec:	dd400617 	ldw	r21,24(sp)
811343f0:	dd000517 	ldw	r20,20(sp)
811343f4:	dcc00417 	ldw	r19,16(sp)
811343f8:	dc800317 	ldw	r18,12(sp)
811343fc:	dc400217 	ldw	r17,8(sp)
81134400:	dc000117 	ldw	r16,4(sp)
81134404:	dec00804 	addi	sp,sp,32
81134408:	f800283a 	ret
8113440c:	800d883a 	mov	r6,r16
81134410:	29403fcc 	andi	r5,r5,255
81134414:	9809883a 	mov	r4,r19
81134418:	112a5580 	call	8112a558 <__swbuf_r>
8113441c:	10bfffe0 	cmpeqi	r2,r2,-1
81134420:	10803fcc 	andi	r2,r2,255
81134424:	103fd626 	beq	r2,zero,81134380 <__reset+0xfb114380>
81134428:	00bfffc4 	movi	r2,-1
8113442c:	003fee06 	br	811343e8 <__reset+0xfb1143e8>
81134430:	90ffffc4 	addi	r3,r18,-1
81134434:	01003f84 	movi	r4,254
81134438:	20ffbf36 	bltu	r4,r3,81134338 <__reset+0xfb114338>
8113443c:	900b883a 	mov	r5,r18
81134440:	dc800005 	stb	r18,0(sp)
81134444:	1029883a 	mov	r20,r2
81134448:	003fc506 	br	81134360 <__reset+0xfb114360>
8113444c:	800d883a 	mov	r6,r16
81134450:	a80b883a 	mov	r5,r21
81134454:	9809883a 	mov	r4,r19
81134458:	112a5580 	call	8112a558 <__swbuf_r>
8113445c:	10bfffe0 	cmpeqi	r2,r2,-1
81134460:	003fef06 	br	81134420 <__reset+0xfb114420>

81134464 <_fputwc_r>:
81134464:	3080030b 	ldhu	r2,12(r6)
81134468:	10c8000c 	andi	r3,r2,8192
8113446c:	1800051e 	bne	r3,zero,81134484 <_fputwc_r+0x20>
81134470:	30c01917 	ldw	r3,100(r6)
81134474:	10880014 	ori	r2,r2,8192
81134478:	3080030d 	sth	r2,12(r6)
8113447c:	18880014 	ori	r2,r3,8192
81134480:	30801915 	stw	r2,100(r6)
81134484:	11342f81 	jmpi	811342f8 <__fputwc>

81134488 <fputwc>:
81134488:	00a04574 	movhi	r2,33045
8113448c:	defffc04 	addi	sp,sp,-16
81134490:	10911304 	addi	r2,r2,17484
81134494:	de00012e 	bgeu	sp,et,8113449c <fputwc+0x14>
81134498:	003b68fa 	trap	3
8113449c:	dc000115 	stw	r16,4(sp)
811344a0:	14000017 	ldw	r16,0(r2)
811344a4:	dc400215 	stw	r17,8(sp)
811344a8:	dfc00315 	stw	ra,12(sp)
811344ac:	2023883a 	mov	r17,r4
811344b0:	80000226 	beq	r16,zero,811344bc <fputwc+0x34>
811344b4:	80800e17 	ldw	r2,56(r16)
811344b8:	10001026 	beq	r2,zero,811344fc <fputwc+0x74>
811344bc:	2880030b 	ldhu	r2,12(r5)
811344c0:	10c8000c 	andi	r3,r2,8192
811344c4:	1800051e 	bne	r3,zero,811344dc <fputwc+0x54>
811344c8:	28c01917 	ldw	r3,100(r5)
811344cc:	10880014 	ori	r2,r2,8192
811344d0:	2880030d 	sth	r2,12(r5)
811344d4:	18880014 	ori	r2,r3,8192
811344d8:	28801915 	stw	r2,100(r5)
811344dc:	280d883a 	mov	r6,r5
811344e0:	8009883a 	mov	r4,r16
811344e4:	880b883a 	mov	r5,r17
811344e8:	dfc00317 	ldw	ra,12(sp)
811344ec:	dc400217 	ldw	r17,8(sp)
811344f0:	dc000117 	ldw	r16,4(sp)
811344f4:	dec00404 	addi	sp,sp,16
811344f8:	11342f81 	jmpi	811342f8 <__fputwc>
811344fc:	8009883a 	mov	r4,r16
81134500:	d9400015 	stw	r5,0(sp)
81134504:	112c7900 	call	8112c790 <__sinit>
81134508:	d9400017 	ldw	r5,0(sp)
8113450c:	003feb06 	br	811344bc <__reset+0xfb1144bc>

81134510 <rshift>:
81134510:	2807d17a 	srai	r3,r5,5
81134514:	20800417 	ldw	r2,16(r4)
81134518:	22000504 	addi	r8,r4,20
8113451c:	1880250e 	bge	r3,r2,811345b4 <rshift+0xa4>
81134520:	1085883a 	add	r2,r2,r2
81134524:	18c7883a 	add	r3,r3,r3
81134528:	1085883a 	add	r2,r2,r2
8113452c:	18c7883a 	add	r3,r3,r3
81134530:	294007cc 	andi	r5,r5,31
81134534:	4085883a 	add	r2,r8,r2
81134538:	40c7883a 	add	r3,r8,r3
8113453c:	28002026 	beq	r5,zero,811345c0 <rshift+0xb0>
81134540:	19800017 	ldw	r6,0(r3)
81134544:	02c00804 	movi	r11,32
81134548:	19c00104 	addi	r7,r3,4
8113454c:	5957c83a 	sub	r11,r11,r5
81134550:	314cd83a 	srl	r6,r6,r5
81134554:	38802c2e 	bgeu	r7,r2,81134608 <rshift+0xf8>
81134558:	4015883a 	mov	r10,r8
8113455c:	3a400017 	ldw	r9,0(r7)
81134560:	52800104 	addi	r10,r10,4
81134564:	39c00104 	addi	r7,r7,4
81134568:	4ad2983a 	sll	r9,r9,r11
8113456c:	498cb03a 	or	r6,r9,r6
81134570:	51bfff15 	stw	r6,-4(r10)
81134574:	39bfff17 	ldw	r6,-4(r7)
81134578:	314cd83a 	srl	r6,r6,r5
8113457c:	38bff736 	bltu	r7,r2,8113455c <__reset+0xfb11455c>
81134580:	10c7c83a 	sub	r3,r2,r3
81134584:	18fffec4 	addi	r3,r3,-5
81134588:	1806d0ba 	srli	r3,r3,2
8113458c:	18c00044 	addi	r3,r3,1
81134590:	18c7883a 	add	r3,r3,r3
81134594:	18c7883a 	add	r3,r3,r3
81134598:	40c7883a 	add	r3,r8,r3
8113459c:	19800015 	stw	r6,0(r3)
811345a0:	30000126 	beq	r6,zero,811345a8 <rshift+0x98>
811345a4:	18c00104 	addi	r3,r3,4
811345a8:	1a05c83a 	sub	r2,r3,r8
811345ac:	1005d0ba 	srai	r2,r2,2
811345b0:	00001206 	br	811345fc <rshift+0xec>
811345b4:	20000415 	stw	zero,16(r4)
811345b8:	20000515 	stw	zero,20(r4)
811345bc:	f800283a 	ret
811345c0:	18bffc2e 	bgeu	r3,r2,811345b4 <__reset+0xfb1145b4>
811345c4:	180d883a 	mov	r6,r3
811345c8:	400b883a 	mov	r5,r8
811345cc:	31c00017 	ldw	r7,0(r6)
811345d0:	29400104 	addi	r5,r5,4
811345d4:	31800104 	addi	r6,r6,4
811345d8:	29ffff15 	stw	r7,-4(r5)
811345dc:	30bffb36 	bltu	r6,r2,811345cc <__reset+0xfb1145cc>
811345e0:	00c6303a 	nor	r3,zero,r3
811345e4:	1885883a 	add	r2,r3,r2
811345e8:	1004d0ba 	srli	r2,r2,2
811345ec:	10800044 	addi	r2,r2,1
811345f0:	1085883a 	add	r2,r2,r2
811345f4:	1085883a 	add	r2,r2,r2
811345f8:	1005d0ba 	srai	r2,r2,2
811345fc:	20800415 	stw	r2,16(r4)
81134600:	103fed26 	beq	r2,zero,811345b8 <__reset+0xfb1145b8>
81134604:	f800283a 	ret
81134608:	4007883a 	mov	r3,r8
8113460c:	003fe306 	br	8113459c <__reset+0xfb11459c>

81134610 <__gethex>:
81134610:	deffeb04 	addi	sp,sp,-84
81134614:	de00012e 	bgeu	sp,et,8113461c <__gethex+0xc>
81134618:	003b68fa 	trap	3
8113461c:	dfc01415 	stw	ra,80(sp)
81134620:	dd801115 	stw	r22,68(sp)
81134624:	dcc00e15 	stw	r19,56(sp)
81134628:	dc800d15 	stw	r18,52(sp)
8113462c:	2827883a 	mov	r19,r5
81134630:	d9000115 	stw	r4,4(sp)
81134634:	d9800015 	stw	r6,0(sp)
81134638:	d9c00415 	stw	r7,16(sp)
8113463c:	df001315 	stw	fp,76(sp)
81134640:	ddc01215 	stw	r23,72(sp)
81134644:	dd401015 	stw	r21,64(sp)
81134648:	dd000f15 	stw	r20,60(sp)
8113464c:	dc400c15 	stw	r17,48(sp)
81134650:	dc000b15 	stw	r16,44(sp)
81134654:	112d6dc0 	call	8112d6dc <_localeconv_r>
81134658:	14800017 	ldw	r18,0(r2)
8113465c:	9009883a 	mov	r4,r18
81134660:	11244bc0 	call	811244bc <strlen>
81134664:	98c00017 	ldw	r3,0(r19)
81134668:	102d883a 	mov	r22,r2
8113466c:	9085883a 	add	r2,r18,r2
81134670:	10bfffc3 	ldbu	r2,-1(r2)
81134674:	19000083 	ldbu	r4,2(r3)
81134678:	d8800305 	stb	r2,12(sp)
8113467c:	00800c04 	movi	r2,48
81134680:	2081521e 	bne	r4,r2,81134bcc <__gethex+0x5bc>
81134684:	017fff84 	movi	r5,-2
81134688:	188000c4 	addi	r2,r3,3
8113468c:	28cbc83a 	sub	r5,r5,r3
81134690:	200d883a 	mov	r6,r4
81134694:	28a3883a 	add	r17,r5,r2
81134698:	102b883a 	mov	r21,r2
8113469c:	10800044 	addi	r2,r2,1
811346a0:	113fffc3 	ldbu	r4,-1(r2)
811346a4:	21bffb26 	beq	r4,r6,81134694 <__reset+0xfb114694>
811346a8:	05204574 	movhi	r20,33045
811346ac:	a507de04 	addi	r20,r20,8056
811346b0:	a109883a 	add	r4,r20,r4
811346b4:	20800003 	ldbu	r2,0(r4)
811346b8:	10008826 	beq	r2,zero,811348dc <__gethex+0x2cc>
811346bc:	a8800003 	ldbu	r2,0(r21)
811346c0:	0015883a 	mov	r10,zero
811346c4:	002f883a 	mov	r23,zero
811346c8:	a085883a 	add	r2,r20,r2
811346cc:	10800003 	ldbu	r2,0(r2)
811346d0:	a821883a 	mov	r16,r21
811346d4:	10000526 	beq	r2,zero,811346ec <__gethex+0xdc>
811346d8:	84000044 	addi	r16,r16,1
811346dc:	80800003 	ldbu	r2,0(r16)
811346e0:	a085883a 	add	r2,r20,r2
811346e4:	10800003 	ldbu	r2,0(r2)
811346e8:	103ffb1e 	bne	r2,zero,811346d8 <__reset+0xfb1146d8>
811346ec:	b00d883a 	mov	r6,r22
811346f0:	900b883a 	mov	r5,r18
811346f4:	8009883a 	mov	r4,r16
811346f8:	da800a15 	stw	r10,40(sp)
811346fc:	11350ac0 	call	811350ac <strncmp>
81134700:	da800a17 	ldw	r10,40(sp)
81134704:	1000031e 	bne	r2,zero,81134714 <__gethex+0x104>
81134708:	b8015226 	beq	r23,zero,81134c54 <__gethex+0x644>
8113470c:	80800003 	ldbu	r2,0(r16)
81134710:	00000206 	br	8113471c <__gethex+0x10c>
81134714:	80800003 	ldbu	r2,0(r16)
81134718:	b8011f26 	beq	r23,zero,81134b98 <__gethex+0x588>
8113471c:	85efc83a 	sub	r23,r16,r23
81134720:	bdef883a 	add	r23,r23,r23
81134724:	bdef883a 	add	r23,r23,r23
81134728:	05efc83a 	sub	r23,zero,r23
8113472c:	10803fcc 	andi	r2,r2,255
81134730:	01001404 	movi	r4,80
81134734:	11008626 	beq	r2,r4,81134950 <__gethex+0x340>
81134738:	01001c04 	movi	r4,112
8113473c:	11008426 	beq	r2,r4,81134950 <__gethex+0x340>
81134740:	8039883a 	mov	fp,r16
81134744:	9c000015 	stw	r16,0(r19)
81134748:	5000711e 	bne	r10,zero,81134910 <__gethex+0x300>
8113474c:	e545c83a 	sub	r2,fp,r21
81134750:	10bfffc4 	addi	r2,r2,-1
81134754:	010001c4 	movi	r4,7
81134758:	000b883a 	mov	r5,zero
8113475c:	2080030e 	bge	r4,r2,8113476c <__gethex+0x15c>
81134760:	1005d07a 	srai	r2,r2,1
81134764:	29400044 	addi	r5,r5,1
81134768:	20bffd16 	blt	r4,r2,81134760 <__reset+0xfb114760>
8113476c:	d9000117 	ldw	r4,4(sp)
81134770:	112dbf80 	call	8112dbf8 <_Balloc>
81134774:	10c00504 	addi	r3,r2,20
81134778:	d8c00215 	stw	r3,8(sp)
8113477c:	1021883a 	mov	r16,r2
81134780:	af01732e 	bgeu	r21,fp,81134d50 <__gethex+0x740>
81134784:	dc400303 	ldbu	r17,12(sp)
81134788:	03400044 	movi	r13,1
8113478c:	1815883a 	mov	r10,r3
81134790:	0013883a 	mov	r9,zero
81134794:	0027883a 	mov	r19,zero
81134798:	6d9bc83a 	sub	r13,r13,r22
8113479c:	02c00804 	movi	r11,32
811347a0:	e0bfffc3 	ldbu	r2,-1(fp)
811347a4:	e3bfffc4 	addi	r14,fp,-1
811347a8:	88803026 	beq	r17,r2,8113486c <__gethex+0x25c>
811347ac:	9ac04526 	beq	r19,r11,811348c4 <__gethex+0x2b4>
811347b0:	980b883a 	mov	r5,r19
811347b4:	9cc00104 	addi	r19,r19,4
811347b8:	e13fffc3 	ldbu	r4,-1(fp)
811347bc:	7039883a 	mov	fp,r14
811347c0:	a109883a 	add	r4,r20,r4
811347c4:	20800003 	ldbu	r2,0(r4)
811347c8:	108003cc 	andi	r2,r2,15
811347cc:	1144983a 	sll	r2,r2,r5
811347d0:	4892b03a 	or	r9,r9,r2
811347d4:	af3ff236 	bltu	r21,fp,811347a0 <__reset+0xfb1147a0>
811347d8:	d8c00217 	ldw	r3,8(sp)
811347dc:	50800104 	addi	r2,r10,4
811347e0:	52400015 	stw	r9,0(r10)
811347e4:	10c5c83a 	sub	r2,r2,r3
811347e8:	1005d0ba 	srai	r2,r2,2
811347ec:	4809883a 	mov	r4,r9
811347f0:	80800415 	stw	r2,16(r16)
811347f4:	1022917a 	slli	r17,r2,5
811347f8:	112df040 	call	8112df04 <__hi0bits>
811347fc:	d8c00017 	ldw	r3,0(sp)
81134800:	8885c83a 	sub	r2,r17,r2
81134804:	1c800017 	ldw	r18,0(r3)
81134808:	9080c716 	blt	r18,r2,81134b28 <__gethex+0x518>
8113480c:	1480e416 	blt	r2,r18,81134ba0 <__gethex+0x590>
81134810:	0027883a 	mov	r19,zero
81134814:	d8c00017 	ldw	r3,0(sp)
81134818:	18800217 	ldw	r2,8(r3)
8113481c:	15c08d16 	blt	r2,r23,81134a54 <__gethex+0x444>
81134820:	d8c00017 	ldw	r3,0(sp)
81134824:	18800117 	ldw	r2,4(r3)
81134828:	b880aa0e 	bge	r23,r2,81134ad4 <__gethex+0x4c4>
8113482c:	15efc83a 	sub	r23,r2,r23
81134830:	bc80ed16 	blt	r23,r18,81134be8 <__gethex+0x5d8>
81134834:	18c00317 	ldw	r3,12(r3)
81134838:	01000084 	movi	r4,2
8113483c:	19014926 	beq	r3,r4,81134d64 <__gethex+0x754>
81134840:	010000c4 	movi	r4,3
81134844:	19012e26 	beq	r3,r4,81134d00 <__gethex+0x6f0>
81134848:	01000044 	movi	r4,1
8113484c:	19014826 	beq	r3,r4,81134d70 <__gethex+0x760>
81134850:	d9000117 	ldw	r4,4(sp)
81134854:	800b883a 	mov	r5,r16
81134858:	112dca80 	call	8112dca8 <_Bfree>
8113485c:	d8801517 	ldw	r2,84(sp)
81134860:	10000015 	stw	zero,0(r2)
81134864:	00801404 	movi	r2,80
81134868:	00002b06 	br	81134918 <__gethex+0x308>
8113486c:	735f883a 	add	r15,r14,r13
81134870:	7d7fce36 	bltu	r15,r21,811347ac <__reset+0xfb1147ac>
81134874:	7809883a 	mov	r4,r15
81134878:	b00d883a 	mov	r6,r22
8113487c:	900b883a 	mov	r5,r18
81134880:	da400515 	stw	r9,20(sp)
81134884:	da800a15 	stw	r10,40(sp)
81134888:	dac00915 	stw	r11,36(sp)
8113488c:	db400815 	stw	r13,32(sp)
81134890:	db800615 	stw	r14,24(sp)
81134894:	dbc00715 	stw	r15,28(sp)
81134898:	11350ac0 	call	811350ac <strncmp>
8113489c:	da400517 	ldw	r9,20(sp)
811348a0:	da800a17 	ldw	r10,40(sp)
811348a4:	dac00917 	ldw	r11,36(sp)
811348a8:	db400817 	ldw	r13,32(sp)
811348ac:	db800617 	ldw	r14,24(sp)
811348b0:	dbc00717 	ldw	r15,28(sp)
811348b4:	103fbd1e 	bne	r2,zero,811347ac <__reset+0xfb1147ac>
811348b8:	7839883a 	mov	fp,r15
811348bc:	af3fb836 	bltu	r21,fp,811347a0 <__reset+0xfb1147a0>
811348c0:	003fc506 	br	811347d8 <__reset+0xfb1147d8>
811348c4:	04c00104 	movi	r19,4
811348c8:	52400015 	stw	r9,0(r10)
811348cc:	000b883a 	mov	r5,zero
811348d0:	54d5883a 	add	r10,r10,r19
811348d4:	0013883a 	mov	r9,zero
811348d8:	003fb706 	br	811347b8 <__reset+0xfb1147b8>
811348dc:	b00d883a 	mov	r6,r22
811348e0:	900b883a 	mov	r5,r18
811348e4:	a809883a 	mov	r4,r21
811348e8:	11350ac0 	call	811350ac <strncmp>
811348ec:	10006426 	beq	r2,zero,81134a80 <__gethex+0x470>
811348f0:	a8800003 	ldbu	r2,0(r21)
811348f4:	a821883a 	mov	r16,r21
811348f8:	10803fcc 	andi	r2,r2,255
811348fc:	01001404 	movi	r4,80
81134900:	11001126 	beq	r2,r4,81134948 <__gethex+0x338>
81134904:	01001c04 	movi	r4,112
81134908:	11000f26 	beq	r2,r4,81134948 <__gethex+0x338>
8113490c:	9c000015 	stw	r16,0(r19)
81134910:	8800831e 	bne	r17,zero,81134b20 <__gethex+0x510>
81134914:	00800184 	movi	r2,6
81134918:	dfc01417 	ldw	ra,80(sp)
8113491c:	df001317 	ldw	fp,76(sp)
81134920:	ddc01217 	ldw	r23,72(sp)
81134924:	dd801117 	ldw	r22,68(sp)
81134928:	dd401017 	ldw	r21,64(sp)
8113492c:	dd000f17 	ldw	r20,60(sp)
81134930:	dcc00e17 	ldw	r19,56(sp)
81134934:	dc800d17 	ldw	r18,52(sp)
81134938:	dc400c17 	ldw	r17,48(sp)
8113493c:	dc000b17 	ldw	r16,44(sp)
81134940:	dec01504 	addi	sp,sp,84
81134944:	f800283a 	ret
81134948:	002f883a 	mov	r23,zero
8113494c:	02800044 	movi	r10,1
81134950:	80800043 	ldbu	r2,1(r16)
81134954:	01400ac4 	movi	r5,43
81134958:	11003fcc 	andi	r4,r2,255
8113495c:	21406e26 	beq	r4,r5,81134b18 <__gethex+0x508>
81134960:	01400b44 	movi	r5,45
81134964:	21404226 	beq	r4,r5,81134a70 <__gethex+0x460>
81134968:	81400044 	addi	r5,r16,1
8113496c:	000d883a 	mov	r6,zero
81134970:	10803fcc 	andi	r2,r2,255
81134974:	a085883a 	add	r2,r20,r2
81134978:	11000003 	ldbu	r4,0(r2)
8113497c:	03000604 	movi	r12,24
81134980:	20bfffc4 	addi	r2,r4,-1
81134984:	10803fcc 	andi	r2,r2,255
81134988:	60bf6d36 	bltu	r12,r2,81134740 <__reset+0xfb114740>
8113498c:	2ac00043 	ldbu	r11,1(r5)
81134990:	20803fcc 	andi	r2,r4,255
81134994:	01204574 	movhi	r4,33045
81134998:	2107de04 	addi	r4,r4,8056
8113499c:	22c9883a 	add	r4,r4,r11
811349a0:	23400003 	ldbu	r13,0(r4)
811349a4:	10bffc04 	addi	r2,r2,-16
811349a8:	29400044 	addi	r5,r5,1
811349ac:	693fffc4 	addi	r4,r13,-1
811349b0:	21003fcc 	andi	r4,r4,255
811349b4:	6b403fcc 	andi	r13,r13,255
811349b8:	61000b36 	bltu	r12,r4,811349e8 <__gethex+0x3d8>
811349bc:	29400044 	addi	r5,r5,1
811349c0:	29000003 	ldbu	r4,0(r5)
811349c4:	108002a4 	muli	r2,r2,10
811349c8:	a109883a 	add	r4,r20,r4
811349cc:	22c00003 	ldbu	r11,0(r4)
811349d0:	1345883a 	add	r2,r2,r13
811349d4:	10bffc04 	addi	r2,r2,-16
811349d8:	593fffc4 	addi	r4,r11,-1
811349dc:	21003fcc 	andi	r4,r4,255
811349e0:	5b403fcc 	andi	r13,r11,255
811349e4:	613ff52e 	bgeu	r12,r4,811349bc <__reset+0xfb1149bc>
811349e8:	30000126 	beq	r6,zero,811349f0 <__gethex+0x3e0>
811349ec:	0085c83a 	sub	r2,zero,r2
811349f0:	8039883a 	mov	fp,r16
811349f4:	b8af883a 	add	r23,r23,r2
811349f8:	2821883a 	mov	r16,r5
811349fc:	003f5106 	br	81134744 <__reset+0xfb114744>
81134a00:	80800217 	ldw	r2,8(r16)
81134a04:	e080f00e 	bge	fp,r2,81134dc8 <__gethex+0x7b8>
81134a08:	e007883a 	mov	r3,fp
81134a0c:	18800144 	addi	r2,r3,5
81134a10:	1085883a 	add	r2,r2,r2
81134a14:	18c00044 	addi	r3,r3,1
81134a18:	1085883a 	add	r2,r2,r2
81134a1c:	8085883a 	add	r2,r16,r2
81134a20:	80c00415 	stw	r3,16(r16)
81134a24:	01000044 	movi	r4,1
81134a28:	11000015 	stw	r4,0(r2)
81134a2c:	00800084 	movi	r2,2
81134a30:	8880d826 	beq	r17,r2,81134d94 <__gethex+0x784>
81134a34:	e0c0ac0e 	bge	fp,r3,81134ce8 <__gethex+0x6d8>
81134a38:	01400044 	movi	r5,1
81134a3c:	8009883a 	mov	r4,r16
81134a40:	11345100 	call	81134510 <rshift>
81134a44:	d8c00017 	ldw	r3,0(sp)
81134a48:	bdc00044 	addi	r23,r23,1
81134a4c:	18800217 	ldw	r2,8(r3)
81134a50:	15c0a70e 	bge	r2,r23,81134cf0 <__gethex+0x6e0>
81134a54:	d9000117 	ldw	r4,4(sp)
81134a58:	800b883a 	mov	r5,r16
81134a5c:	112dca80 	call	8112dca8 <_Bfree>
81134a60:	d9001517 	ldw	r4,84(sp)
81134a64:	008028c4 	movi	r2,163
81134a68:	20000015 	stw	zero,0(r4)
81134a6c:	003faa06 	br	81134918 <__reset+0xfb114918>
81134a70:	01800044 	movi	r6,1
81134a74:	80800083 	ldbu	r2,2(r16)
81134a78:	81400084 	addi	r5,r16,2
81134a7c:	003fbc06 	br	81134970 <__reset+0xfb114970>
81134a80:	ada1883a 	add	r16,r21,r22
81134a84:	81000003 	ldbu	r4,0(r16)
81134a88:	21403fcc 	andi	r5,r4,255
81134a8c:	a145883a 	add	r2,r20,r5
81134a90:	10800003 	ldbu	r2,0(r2)
81134a94:	11803fcc 	andi	r6,r2,255
81134a98:	30004f26 	beq	r6,zero,81134bd8 <__gethex+0x5c8>
81134a9c:	00c00c04 	movi	r3,48
81134aa0:	802b883a 	mov	r21,r16
81134aa4:	28c0061e 	bne	r5,r3,81134ac0 <__gethex+0x4b0>
81134aa8:	2809883a 	mov	r4,r5
81134aac:	ad400044 	addi	r21,r21,1
81134ab0:	a8800003 	ldbu	r2,0(r21)
81134ab4:	113ffd26 	beq	r2,r4,81134aac <__reset+0xfb114aac>
81134ab8:	a085883a 	add	r2,r20,r2
81134abc:	10800003 	ldbu	r2,0(r2)
81134ac0:	10803fcc 	andi	r2,r2,255
81134ac4:	1015003a 	cmpeq	r10,r2,zero
81134ac8:	802f883a 	mov	r23,r16
81134acc:	04400044 	movi	r17,1
81134ad0:	003eff06 	br	811346d0 <__reset+0xfb1146d0>
81134ad4:	04400044 	movi	r17,1
81134ad8:	98000926 	beq	r19,zero,81134b00 <__gethex+0x4f0>
81134adc:	d8c00017 	ldw	r3,0(sp)
81134ae0:	18800317 	ldw	r2,12(r3)
81134ae4:	00c00084 	movi	r3,2
81134ae8:	10c06826 	beq	r2,r3,81134c8c <__gethex+0x67c>
81134aec:	00c000c4 	movi	r3,3
81134af0:	10c06a26 	beq	r2,r3,81134c9c <__gethex+0x68c>
81134af4:	00c00044 	movi	r3,1
81134af8:	10c08d26 	beq	r2,r3,81134d30 <__gethex+0x720>
81134afc:	8c400414 	ori	r17,r17,16
81134b00:	d9001517 	ldw	r4,84(sp)
81134b04:	d8c00417 	ldw	r3,16(sp)
81134b08:	8805883a 	mov	r2,r17
81134b0c:	24000015 	stw	r16,0(r4)
81134b10:	1dc00015 	stw	r23,0(r3)
81134b14:	003f8006 	br	81134918 <__reset+0xfb114918>
81134b18:	000d883a 	mov	r6,zero
81134b1c:	003fd506 	br	81134a74 <__reset+0xfb114a74>
81134b20:	0005883a 	mov	r2,zero
81134b24:	003f7c06 	br	81134918 <__reset+0xfb114918>
81134b28:	14a3c83a 	sub	r17,r2,r18
81134b2c:	880b883a 	mov	r5,r17
81134b30:	8009883a 	mov	r4,r16
81134b34:	112ebc80 	call	8112ebc8 <__any_on>
81134b38:	10002926 	beq	r2,zero,81134be0 <__gethex+0x5d0>
81134b3c:	897fffc4 	addi	r5,r17,-1
81134b40:	2807d17a 	srai	r3,r5,5
81134b44:	d8800217 	ldw	r2,8(sp)
81134b48:	290007cc 	andi	r4,r5,31
81134b4c:	18c7883a 	add	r3,r3,r3
81134b50:	18c7883a 	add	r3,r3,r3
81134b54:	04c00044 	movi	r19,1
81134b58:	10c7883a 	add	r3,r2,r3
81134b5c:	9908983a 	sll	r4,r19,r4
81134b60:	18c00017 	ldw	r3,0(r3)
81134b64:	20c6703a 	and	r3,r4,r3
81134b68:	18000626 	beq	r3,zero,81134b84 <__gethex+0x574>
81134b6c:	99407b0e 	bge	r19,r5,81134d5c <__gethex+0x74c>
81134b70:	897fff84 	addi	r5,r17,-2
81134b74:	8009883a 	mov	r4,r16
81134b78:	112ebc80 	call	8112ebc8 <__any_on>
81134b7c:	10007726 	beq	r2,zero,81134d5c <__gethex+0x74c>
81134b80:	04c000c4 	movi	r19,3
81134b84:	880b883a 	mov	r5,r17
81134b88:	8009883a 	mov	r4,r16
81134b8c:	11345100 	call	81134510 <rshift>
81134b90:	bc6f883a 	add	r23,r23,r17
81134b94:	003f1f06 	br	81134814 <__reset+0xfb114814>
81134b98:	002f883a 	mov	r23,zero
81134b9c:	003ee306 	br	8113472c <__reset+0xfb11472c>
81134ba0:	d9000117 	ldw	r4,4(sp)
81134ba4:	90a3c83a 	sub	r17,r18,r2
81134ba8:	800b883a 	mov	r5,r16
81134bac:	880d883a 	mov	r6,r17
81134bb0:	112e3a80 	call	8112e3a8 <__lshift>
81134bb4:	10c00504 	addi	r3,r2,20
81134bb8:	1021883a 	mov	r16,r2
81134bbc:	bc6fc83a 	sub	r23,r23,r17
81134bc0:	d8c00215 	stw	r3,8(sp)
81134bc4:	0027883a 	mov	r19,zero
81134bc8:	003f1206 	br	81134814 <__reset+0xfb114814>
81134bcc:	1d400084 	addi	r21,r3,2
81134bd0:	0023883a 	mov	r17,zero
81134bd4:	003eb406 	br	811346a8 <__reset+0xfb1146a8>
81134bd8:	2005883a 	mov	r2,r4
81134bdc:	003f4606 	br	811348f8 <__reset+0xfb1148f8>
81134be0:	0027883a 	mov	r19,zero
81134be4:	003fe706 	br	81134b84 <__reset+0xfb114b84>
81134be8:	bc7fffc4 	addi	r17,r23,-1
81134bec:	9800421e 	bne	r19,zero,81134cf8 <__gethex+0x6e8>
81134bf0:	88000426 	beq	r17,zero,81134c04 <__gethex+0x5f4>
81134bf4:	880b883a 	mov	r5,r17
81134bf8:	8009883a 	mov	r4,r16
81134bfc:	112ebc80 	call	8112ebc8 <__any_on>
81134c00:	1027883a 	mov	r19,r2
81134c04:	8805d17a 	srai	r2,r17,5
81134c08:	d8c00217 	ldw	r3,8(sp)
81134c0c:	8c4007cc 	andi	r17,r17,31
81134c10:	1085883a 	add	r2,r2,r2
81134c14:	1085883a 	add	r2,r2,r2
81134c18:	1885883a 	add	r2,r3,r2
81134c1c:	00c00044 	movi	r3,1
81134c20:	1c62983a 	sll	r17,r3,r17
81134c24:	10800017 	ldw	r2,0(r2)
81134c28:	8884703a 	and	r2,r17,r2
81134c2c:	10000126 	beq	r2,zero,81134c34 <__gethex+0x624>
81134c30:	9cc00094 	ori	r19,r19,2
81134c34:	b80b883a 	mov	r5,r23
81134c38:	8009883a 	mov	r4,r16
81134c3c:	11345100 	call	81134510 <rshift>
81134c40:	d8c00017 	ldw	r3,0(sp)
81134c44:	95e5c83a 	sub	r18,r18,r23
81134c48:	04400084 	movi	r17,2
81134c4c:	1dc00117 	ldw	r23,4(r3)
81134c50:	003fa106 	br	81134ad8 <__reset+0xfb114ad8>
81134c54:	85af883a 	add	r23,r16,r22
81134c58:	b8800003 	ldbu	r2,0(r23)
81134c5c:	b821883a 	mov	r16,r23
81134c60:	11003fcc 	andi	r4,r2,255
81134c64:	a109883a 	add	r4,r20,r4
81134c68:	21000003 	ldbu	r4,0(r4)
81134c6c:	203eaa26 	beq	r4,zero,81134718 <__reset+0xfb114718>
81134c70:	84000044 	addi	r16,r16,1
81134c74:	80800003 	ldbu	r2,0(r16)
81134c78:	11003fcc 	andi	r4,r2,255
81134c7c:	a109883a 	add	r4,r20,r4
81134c80:	21000003 	ldbu	r4,0(r4)
81134c84:	203ffa1e 	bne	r4,zero,81134c70 <__reset+0xfb114c70>
81134c88:	003ea306 	br	81134718 <__reset+0xfb114718>
81134c8c:	d9001617 	ldw	r4,88(sp)
81134c90:	00800044 	movi	r2,1
81134c94:	1109c83a 	sub	r4,r2,r4
81134c98:	d9001615 	stw	r4,88(sp)
81134c9c:	d8801617 	ldw	r2,88(sp)
81134ca0:	103f9626 	beq	r2,zero,81134afc <__reset+0xfb114afc>
81134ca4:	87000417 	ldw	fp,16(r16)
81134ca8:	d9800217 	ldw	r6,8(sp)
81134cac:	013fffc4 	movi	r4,-1
81134cb0:	e727883a 	add	r19,fp,fp
81134cb4:	9ce7883a 	add	r19,r19,r19
81134cb8:	3005883a 	mov	r2,r6
81134cbc:	34cb883a 	add	r5,r6,r19
81134cc0:	00000306 	br	81134cd0 <__gethex+0x6c0>
81134cc4:	10000015 	stw	zero,0(r2)
81134cc8:	10800104 	addi	r2,r2,4
81134ccc:	117f4c2e 	bgeu	r2,r5,81134a00 <__reset+0xfb114a00>
81134cd0:	10c00017 	ldw	r3,0(r2)
81134cd4:	193ffb26 	beq	r3,r4,81134cc4 <__reset+0xfb114cc4>
81134cd8:	18c00044 	addi	r3,r3,1
81134cdc:	10c00015 	stw	r3,0(r2)
81134ce0:	00800084 	movi	r2,2
81134ce4:	88802b26 	beq	r17,r2,81134d94 <__gethex+0x784>
81134ce8:	948007cc 	andi	r18,r18,31
81134cec:	90002f1e 	bne	r18,zero,81134dac <__gethex+0x79c>
81134cf0:	04400844 	movi	r17,33
81134cf4:	003f8206 	br	81134b00 <__reset+0xfb114b00>
81134cf8:	04c00044 	movi	r19,1
81134cfc:	003fc106 	br	81134c04 <__reset+0xfb114c04>
81134d00:	d8c01617 	ldw	r3,88(sp)
81134d04:	183ed226 	beq	r3,zero,81134850 <__reset+0xfb114850>
81134d08:	d8c00417 	ldw	r3,16(sp)
81134d0c:	d9001517 	ldw	r4,84(sp)
81134d10:	18800015 	stw	r2,0(r3)
81134d14:	d8c00217 	ldw	r3,8(sp)
81134d18:	00800044 	movi	r2,1
81134d1c:	80800415 	stw	r2,16(r16)
81134d20:	18800015 	stw	r2,0(r3)
81134d24:	24000015 	stw	r16,0(r4)
81134d28:	00801884 	movi	r2,98
81134d2c:	003efa06 	br	81134918 <__reset+0xfb114918>
81134d30:	9880008c 	andi	r2,r19,2
81134d34:	103f7126 	beq	r2,zero,81134afc <__reset+0xfb114afc>
81134d38:	d8c00217 	ldw	r3,8(sp)
81134d3c:	18800017 	ldw	r2,0(r3)
81134d40:	9884b03a 	or	r2,r19,r2
81134d44:	1080004c 	andi	r2,r2,1
81134d48:	103fd61e 	bne	r2,zero,81134ca4 <__reset+0xfb114ca4>
81134d4c:	003f6b06 	br	81134afc <__reset+0xfb114afc>
81134d50:	da800217 	ldw	r10,8(sp)
81134d54:	0013883a 	mov	r9,zero
81134d58:	003e9f06 	br	811347d8 <__reset+0xfb1147d8>
81134d5c:	04c00084 	movi	r19,2
81134d60:	003f8806 	br	81134b84 <__reset+0xfb114b84>
81134d64:	d9001617 	ldw	r4,88(sp)
81134d68:	203fe726 	beq	r4,zero,81134d08 <__reset+0xfb114d08>
81134d6c:	003eb806 	br	81134850 <__reset+0xfb114850>
81134d70:	95feb71e 	bne	r18,r23,81134850 <__reset+0xfb114850>
81134d74:	1cbfe40e 	bge	r3,r18,81134d08 <__reset+0xfb114d08>
81134d78:	917fffc4 	addi	r5,r18,-1
81134d7c:	8009883a 	mov	r4,r16
81134d80:	112ebc80 	call	8112ebc8 <__any_on>
81134d84:	103eb226 	beq	r2,zero,81134850 <__reset+0xfb114850>
81134d88:	d8c00017 	ldw	r3,0(sp)
81134d8c:	18800117 	ldw	r2,4(r3)
81134d90:	003fdd06 	br	81134d08 <__reset+0xfb114d08>
81134d94:	d8c00017 	ldw	r3,0(sp)
81134d98:	18800017 	ldw	r2,0(r3)
81134d9c:	10bfffc4 	addi	r2,r2,-1
81134da0:	90801c26 	beq	r18,r2,81134e14 <__gethex+0x804>
81134da4:	04400884 	movi	r17,34
81134da8:	003f5506 	br	81134b00 <__reset+0xfb114b00>
81134dac:	34c5883a 	add	r2,r6,r19
81134db0:	113fff17 	ldw	r4,-4(r2)
81134db4:	112df040 	call	8112df04 <__hi0bits>
81134db8:	00c00804 	movi	r3,32
81134dbc:	1ca5c83a 	sub	r18,r3,r18
81134dc0:	14bfcb0e 	bge	r2,r18,81134cf0 <__reset+0xfb114cf0>
81134dc4:	003f1c06 	br	81134a38 <__reset+0xfb114a38>
81134dc8:	81400117 	ldw	r5,4(r16)
81134dcc:	d9000117 	ldw	r4,4(sp)
81134dd0:	29400044 	addi	r5,r5,1
81134dd4:	112dbf80 	call	8112dbf8 <_Balloc>
81134dd8:	81800417 	ldw	r6,16(r16)
81134ddc:	81400304 	addi	r5,r16,12
81134de0:	11000304 	addi	r4,r2,12
81134de4:	31800084 	addi	r6,r6,2
81134de8:	318d883a 	add	r6,r6,r6
81134dec:	318d883a 	add	r6,r6,r6
81134df0:	1029883a 	mov	r20,r2
81134df4:	1123a440 	call	81123a44 <memcpy>
81134df8:	d9000117 	ldw	r4,4(sp)
81134dfc:	800b883a 	mov	r5,r16
81134e00:	a021883a 	mov	r16,r20
81134e04:	112dca80 	call	8112dca8 <_Bfree>
81134e08:	a0c00417 	ldw	r3,16(r20)
81134e0c:	a1800504 	addi	r6,r20,20
81134e10:	003efe06 	br	81134a0c <__reset+0xfb114a0c>
81134e14:	9005d17a 	srai	r2,r18,5
81134e18:	944007cc 	andi	r17,r18,31
81134e1c:	1085883a 	add	r2,r2,r2
81134e20:	1085883a 	add	r2,r2,r2
81134e24:	3087883a 	add	r3,r6,r2
81134e28:	00800044 	movi	r2,1
81134e2c:	1462983a 	sll	r17,r2,r17
81134e30:	18800017 	ldw	r2,0(r3)
81134e34:	8884703a 	and	r2,r17,r2
81134e38:	1022c03a 	cmpne	r17,r2,zero
81134e3c:	00800884 	movi	r2,34
81134e40:	1463c83a 	sub	r17,r2,r17
81134e44:	003f2e06 	br	81134b00 <__reset+0xfb114b00>

81134e48 <__hexnan>:
81134e48:	defff904 	addi	sp,sp,-28
81134e4c:	de00012e 	bgeu	sp,et,81134e54 <__hexnan+0xc>
81134e50:	003b68fa 	trap	3
81134e54:	dc800215 	stw	r18,8(sp)
81134e58:	2c800017 	ldw	r18,0(r5)
81134e5c:	dfc00615 	stw	ra,24(sp)
81134e60:	dd400515 	stw	r21,20(sp)
81134e64:	901fd17a 	srai	r15,r18,5
81134e68:	dd000415 	stw	r20,16(sp)
81134e6c:	dcc00315 	stw	r19,12(sp)
81134e70:	7bdf883a 	add	r15,r15,r15
81134e74:	7bdf883a 	add	r15,r15,r15
81134e78:	dc400115 	stw	r17,4(sp)
81134e7c:	dc000015 	stw	r16,0(sp)
81134e80:	948007cc 	andi	r18,r18,31
81134e84:	33df883a 	add	r15,r6,r15
81134e88:	90000126 	beq	r18,zero,81134e90 <__hexnan+0x48>
81134e8c:	7bc00104 	addi	r15,r15,4
81134e90:	22000017 	ldw	r8,0(r4)
81134e94:	7affff04 	addi	r11,r15,-4
81134e98:	03a04574 	movhi	r14,33045
81134e9c:	783fff15 	stw	zero,-4(r15)
81134ea0:	581b883a 	mov	r13,r11
81134ea4:	580b883a 	mov	r5,r11
81134ea8:	000f883a 	mov	r7,zero
81134eac:	003f883a 	mov	ra,zero
81134eb0:	0019883a 	mov	r12,zero
81134eb4:	7387de04 	addi	r14,r14,8056
81134eb8:	04400204 	movi	r17,8
81134ebc:	04000804 	movi	r16,32
81134ec0:	04c001c4 	movi	r19,7
81134ec4:	42000044 	addi	r8,r8,1
81134ec8:	40c00003 	ldbu	r3,0(r8)
81134ecc:	18001d26 	beq	r3,zero,81134f44 <__hexnan+0xfc>
81134ed0:	70c5883a 	add	r2,r14,r3
81134ed4:	10800003 	ldbu	r2,0(r2)
81134ed8:	12403fcc 	andi	r9,r2,255
81134edc:	4800301e 	bne	r9,zero,81134fa0 <__hexnan+0x158>
81134ee0:	80c04236 	bltu	r16,r3,81134fec <__hexnan+0x1a4>
81134ee4:	fb3ff70e 	bge	ra,r12,81134ec4 <__reset+0xfb114ec4>
81134ee8:	2b40112e 	bgeu	r5,r13,81134f30 <__hexnan+0xe8>
81134eec:	99c01016 	blt	r19,r7,81134f30 <__hexnan+0xe8>
81134ef0:	89e9c83a 	sub	r20,r17,r7
81134ef4:	a529883a 	add	r20,r20,r20
81134ef8:	2a800017 	ldw	r10,0(r5)
81134efc:	a529883a 	add	r20,r20,r20
81134f00:	852bc83a 	sub	r21,r16,r20
81134f04:	28c00104 	addi	r3,r5,4
81134f08:	2805883a 	mov	r2,r5
81134f0c:	19c00017 	ldw	r7,0(r3)
81134f10:	10800104 	addi	r2,r2,4
81134f14:	18c00104 	addi	r3,r3,4
81134f18:	3d52983a 	sll	r9,r7,r21
81134f1c:	4a92b03a 	or	r9,r9,r10
81134f20:	3d14d83a 	srl	r10,r7,r20
81134f24:	127fff15 	stw	r9,-4(r2)
81134f28:	1abfff15 	stw	r10,-4(r3)
81134f2c:	137ff736 	bltu	r2,r13,81134f0c <__reset+0xfb114f0c>
81134f30:	31402836 	bltu	r6,r5,81134fd4 <__hexnan+0x18c>
81134f34:	42000044 	addi	r8,r8,1
81134f38:	40c00003 	ldbu	r3,0(r8)
81134f3c:	01c00204 	movi	r7,8
81134f40:	183fe31e 	bne	r3,zero,81134ed0 <__reset+0xfb114ed0>
81134f44:	60002b26 	beq	r12,zero,81134ff4 <__hexnan+0x1ac>
81134f48:	2b40022e 	bgeu	r5,r13,81134f54 <__hexnan+0x10c>
81134f4c:	008001c4 	movi	r2,7
81134f50:	11c0430e 	bge	r2,r7,81135060 <__hexnan+0x218>
81134f54:	3140312e 	bgeu	r6,r5,8113501c <__hexnan+0x1d4>
81134f58:	3007883a 	mov	r3,r6
81134f5c:	29000017 	ldw	r4,0(r5)
81134f60:	18800104 	addi	r2,r3,4
81134f64:	29400104 	addi	r5,r5,4
81134f68:	19000015 	stw	r4,0(r3)
81134f6c:	1007883a 	mov	r3,r2
81134f70:	597ffa2e 	bgeu	r11,r5,81134f5c <__reset+0xfb114f5c>
81134f74:	10000015 	stw	zero,0(r2)
81134f78:	10800104 	addi	r2,r2,4
81134f7c:	58bffd2e 	bgeu	r11,r2,81134f74 <__reset+0xfb114f74>
81134f80:	78bfff17 	ldw	r2,-4(r15)
81134f84:	1000041e 	bne	r2,zero,81134f98 <__hexnan+0x150>
81134f88:	32c02d26 	beq	r6,r11,81135040 <__hexnan+0x1f8>
81134f8c:	5affff04 	addi	r11,r11,-4
81134f90:	58800017 	ldw	r2,0(r11)
81134f94:	103ffc26 	beq	r2,zero,81134f88 <__reset+0xfb114f88>
81134f98:	00800144 	movi	r2,5
81134f9c:	00001606 	br	81134ff8 <__hexnan+0x1b0>
81134fa0:	39c00044 	addi	r7,r7,1
81134fa4:	63000044 	addi	r12,r12,1
81134fa8:	89c0040e 	bge	r17,r7,81134fbc <__hexnan+0x174>
81134fac:	317fc52e 	bgeu	r6,r5,81134ec4 <__reset+0xfb114ec4>
81134fb0:	283fff15 	stw	zero,-4(r5)
81134fb4:	01c00044 	movi	r7,1
81134fb8:	297fff04 	addi	r5,r5,-4
81134fbc:	28c00017 	ldw	r3,0(r5)
81134fc0:	108003cc 	andi	r2,r2,15
81134fc4:	1806913a 	slli	r3,r3,4
81134fc8:	1884b03a 	or	r2,r3,r2
81134fcc:	28800015 	stw	r2,0(r5)
81134fd0:	003fbc06 	br	81134ec4 <__reset+0xfb114ec4>
81134fd4:	2b7fff04 	addi	r13,r5,-4
81134fd8:	283fff15 	stw	zero,-4(r5)
81134fdc:	603f883a 	mov	ra,r12
81134fe0:	680b883a 	mov	r5,r13
81134fe4:	000f883a 	mov	r7,zero
81134fe8:	003fb606 	br	81134ec4 <__reset+0xfb114ec4>
81134fec:	00800a44 	movi	r2,41
81134ff0:	18801726 	beq	r3,r2,81135050 <__hexnan+0x208>
81134ff4:	00800104 	movi	r2,4
81134ff8:	dfc00617 	ldw	ra,24(sp)
81134ffc:	dd400517 	ldw	r21,20(sp)
81135000:	dd000417 	ldw	r20,16(sp)
81135004:	dcc00317 	ldw	r19,12(sp)
81135008:	dc800217 	ldw	r18,8(sp)
8113500c:	dc400117 	ldw	r17,4(sp)
81135010:	dc000017 	ldw	r16,0(sp)
81135014:	dec00704 	addi	sp,sp,28
81135018:	f800283a 	ret
8113501c:	903fd826 	beq	r18,zero,81134f80 <__reset+0xfb114f80>
81135020:	00c00804 	movi	r3,32
81135024:	1ca5c83a 	sub	r18,r3,r18
81135028:	00ffffc4 	movi	r3,-1
8113502c:	78bfff17 	ldw	r2,-4(r15)
81135030:	1c86d83a 	srl	r3,r3,r18
81135034:	1884703a 	and	r2,r3,r2
81135038:	78bfff15 	stw	r2,-4(r15)
8113503c:	003fd106 	br	81134f84 <__reset+0xfb114f84>
81135040:	00800044 	movi	r2,1
81135044:	58800015 	stw	r2,0(r11)
81135048:	00800144 	movi	r2,5
8113504c:	003fea06 	br	81134ff8 <__reset+0xfb114ff8>
81135050:	42000044 	addi	r8,r8,1
81135054:	22000015 	stw	r8,0(r4)
81135058:	603fbb1e 	bne	r12,zero,81134f48 <__reset+0xfb114f48>
8113505c:	003fe506 	br	81134ff4 <__reset+0xfb114ff4>
81135060:	02400204 	movi	r9,8
81135064:	49d3c83a 	sub	r9,r9,r7
81135068:	4a53883a 	add	r9,r9,r9
8113506c:	2a000017 	ldw	r8,0(r5)
81135070:	4a53883a 	add	r9,r9,r9
81135074:	02800804 	movi	r10,32
81135078:	5255c83a 	sub	r10,r10,r9
8113507c:	28c00104 	addi	r3,r5,4
81135080:	2805883a 	mov	r2,r5
81135084:	19c00017 	ldw	r7,0(r3)
81135088:	10800104 	addi	r2,r2,4
8113508c:	18c00104 	addi	r3,r3,4
81135090:	3a88983a 	sll	r4,r7,r10
81135094:	2208b03a 	or	r4,r4,r8
81135098:	3a50d83a 	srl	r8,r7,r9
8113509c:	113fff15 	stw	r4,-4(r2)
811350a0:	1a3fff15 	stw	r8,-4(r3)
811350a4:	137ff736 	bltu	r2,r13,81135084 <__reset+0xfb115084>
811350a8:	003faa06 	br	81134f54 <__reset+0xfb114f54>

811350ac <strncmp>:
811350ac:	30003126 	beq	r6,zero,81135174 <strncmp+0xc8>
811350b0:	2144b03a 	or	r2,r4,r5
811350b4:	108000cc 	andi	r2,r2,3
811350b8:	10001e1e 	bne	r2,zero,81135134 <strncmp+0x88>
811350bc:	024000c4 	movi	r9,3
811350c0:	49801c2e 	bgeu	r9,r6,81135134 <strncmp+0x88>
811350c4:	20800017 	ldw	r2,0(r4)
811350c8:	28c00017 	ldw	r3,0(r5)
811350cc:	10c0191e 	bne	r2,r3,81135134 <strncmp+0x88>
811350d0:	31bfff04 	addi	r6,r6,-4
811350d4:	30002726 	beq	r6,zero,81135174 <strncmp+0xc8>
811350d8:	02ffbff4 	movhi	r11,65279
811350dc:	5affbfc4 	addi	r11,r11,-257
811350e0:	0086303a 	nor	r3,zero,r2
811350e4:	02a02074 	movhi	r10,32897
811350e8:	12c5883a 	add	r2,r2,r11
811350ec:	52a02004 	addi	r10,r10,-32640
811350f0:	10c4703a 	and	r2,r2,r3
811350f4:	1284703a 	and	r2,r2,r10
811350f8:	10000b26 	beq	r2,zero,81135128 <strncmp+0x7c>
811350fc:	00001d06 	br	81135174 <strncmp+0xc8>
81135100:	20c00017 	ldw	r3,0(r4)
81135104:	29c00017 	ldw	r7,0(r5)
81135108:	1ad1883a 	add	r8,r3,r11
8113510c:	00c4303a 	nor	r2,zero,r3
81135110:	4084703a 	and	r2,r8,r2
81135114:	1284703a 	and	r2,r2,r10
81135118:	19c0061e 	bne	r3,r7,81135134 <strncmp+0x88>
8113511c:	31bfff04 	addi	r6,r6,-4
81135120:	30001426 	beq	r6,zero,81135174 <strncmp+0xc8>
81135124:	1000131e 	bne	r2,zero,81135174 <strncmp+0xc8>
81135128:	21000104 	addi	r4,r4,4
8113512c:	29400104 	addi	r5,r5,4
81135130:	49bff336 	bltu	r9,r6,81135100 <__reset+0xfb115100>
81135134:	28800007 	ldb	r2,0(r5)
81135138:	20c00007 	ldb	r3,0(r4)
8113513c:	31bfffc4 	addi	r6,r6,-1
81135140:	10c0081e 	bne	r2,r3,81135164 <strncmp+0xb8>
81135144:	30000b26 	beq	r6,zero,81135174 <strncmp+0xc8>
81135148:	10000a26 	beq	r2,zero,81135174 <strncmp+0xc8>
8113514c:	21000044 	addi	r4,r4,1
81135150:	29400044 	addi	r5,r5,1
81135154:	20800007 	ldb	r2,0(r4)
81135158:	28c00007 	ldb	r3,0(r5)
8113515c:	31bfffc4 	addi	r6,r6,-1
81135160:	10fff826 	beq	r2,r3,81135144 <__reset+0xfb115144>
81135164:	20800003 	ldbu	r2,0(r4)
81135168:	28c00003 	ldbu	r3,0(r5)
8113516c:	10c5c83a 	sub	r2,r2,r3
81135170:	f800283a 	ret
81135174:	0005883a 	mov	r2,zero
81135178:	f800283a 	ret

8113517c <_wcrtomb_r>:
8113517c:	defff604 	addi	sp,sp,-40
81135180:	00a04574 	movhi	r2,33045
81135184:	de00012e 	bgeu	sp,et,8113518c <_wcrtomb_r+0x10>
81135188:	003b68fa 	trap	3
8113518c:	10911804 	addi	r2,r2,17504
81135190:	dc800815 	stw	r18,32(sp)
81135194:	dc400715 	stw	r17,28(sp)
81135198:	dc000615 	stw	r16,24(sp)
8113519c:	dfc00915 	stw	ra,36(sp)
811351a0:	2021883a 	mov	r16,r4
811351a4:	3823883a 	mov	r17,r7
811351a8:	14800017 	ldw	r18,0(r2)
811351ac:	28001426 	beq	r5,zero,81135200 <_wcrtomb_r+0x84>
811351b0:	d9400415 	stw	r5,16(sp)
811351b4:	d9800515 	stw	r6,20(sp)
811351b8:	112d6ac0 	call	8112d6ac <__locale_charset>
811351bc:	d9800517 	ldw	r6,20(sp)
811351c0:	d9400417 	ldw	r5,16(sp)
811351c4:	100f883a 	mov	r7,r2
811351c8:	dc400015 	stw	r17,0(sp)
811351cc:	8009883a 	mov	r4,r16
811351d0:	903ee83a 	callr	r18
811351d4:	00ffffc4 	movi	r3,-1
811351d8:	10c0031e 	bne	r2,r3,811351e8 <_wcrtomb_r+0x6c>
811351dc:	88000015 	stw	zero,0(r17)
811351e0:	00c02284 	movi	r3,138
811351e4:	80c00015 	stw	r3,0(r16)
811351e8:	dfc00917 	ldw	ra,36(sp)
811351ec:	dc800817 	ldw	r18,32(sp)
811351f0:	dc400717 	ldw	r17,28(sp)
811351f4:	dc000617 	ldw	r16,24(sp)
811351f8:	dec00a04 	addi	sp,sp,40
811351fc:	f800283a 	ret
81135200:	112d6ac0 	call	8112d6ac <__locale_charset>
81135204:	100f883a 	mov	r7,r2
81135208:	dc400015 	stw	r17,0(sp)
8113520c:	000d883a 	mov	r6,zero
81135210:	d9400104 	addi	r5,sp,4
81135214:	8009883a 	mov	r4,r16
81135218:	903ee83a 	callr	r18
8113521c:	003fed06 	br	811351d4 <__reset+0xfb1151d4>

81135220 <wcrtomb>:
81135220:	defff604 	addi	sp,sp,-40
81135224:	00a04574 	movhi	r2,33045
81135228:	de00012e 	bgeu	sp,et,81135230 <wcrtomb+0x10>
8113522c:	003b68fa 	trap	3
81135230:	10911304 	addi	r2,r2,17484
81135234:	dc800615 	stw	r18,24(sp)
81135238:	dc400515 	stw	r17,20(sp)
8113523c:	dfc00915 	stw	ra,36(sp)
81135240:	dd000815 	stw	r20,32(sp)
81135244:	dcc00715 	stw	r19,28(sp)
81135248:	dc000415 	stw	r16,16(sp)
8113524c:	3025883a 	mov	r18,r6
81135250:	14400017 	ldw	r17,0(r2)
81135254:	20001926 	beq	r4,zero,811352bc <wcrtomb+0x9c>
81135258:	00a04574 	movhi	r2,33045
8113525c:	10911804 	addi	r2,r2,17504
81135260:	15000017 	ldw	r20,0(r2)
81135264:	2021883a 	mov	r16,r4
81135268:	2827883a 	mov	r19,r5
8113526c:	112d6ac0 	call	8112d6ac <__locale_charset>
81135270:	100f883a 	mov	r7,r2
81135274:	dc800015 	stw	r18,0(sp)
81135278:	980d883a 	mov	r6,r19
8113527c:	800b883a 	mov	r5,r16
81135280:	8809883a 	mov	r4,r17
81135284:	a03ee83a 	callr	r20
81135288:	00ffffc4 	movi	r3,-1
8113528c:	10c0031e 	bne	r2,r3,8113529c <wcrtomb+0x7c>
81135290:	90000015 	stw	zero,0(r18)
81135294:	00c02284 	movi	r3,138
81135298:	88c00015 	stw	r3,0(r17)
8113529c:	dfc00917 	ldw	ra,36(sp)
811352a0:	dd000817 	ldw	r20,32(sp)
811352a4:	dcc00717 	ldw	r19,28(sp)
811352a8:	dc800617 	ldw	r18,24(sp)
811352ac:	dc400517 	ldw	r17,20(sp)
811352b0:	dc000417 	ldw	r16,16(sp)
811352b4:	dec00a04 	addi	sp,sp,40
811352b8:	f800283a 	ret
811352bc:	00a04574 	movhi	r2,33045
811352c0:	10911804 	addi	r2,r2,17504
811352c4:	14000017 	ldw	r16,0(r2)
811352c8:	112d6ac0 	call	8112d6ac <__locale_charset>
811352cc:	100f883a 	mov	r7,r2
811352d0:	dc800015 	stw	r18,0(sp)
811352d4:	000d883a 	mov	r6,zero
811352d8:	d9400104 	addi	r5,sp,4
811352dc:	8809883a 	mov	r4,r17
811352e0:	803ee83a 	callr	r16
811352e4:	003fe806 	br	81135288 <__reset+0xfb115288>

811352e8 <__ascii_wctomb>:
811352e8:	28000526 	beq	r5,zero,81135300 <__ascii_wctomb+0x18>
811352ec:	00803fc4 	movi	r2,255
811352f0:	11800536 	bltu	r2,r6,81135308 <__ascii_wctomb+0x20>
811352f4:	29800005 	stb	r6,0(r5)
811352f8:	00800044 	movi	r2,1
811352fc:	f800283a 	ret
81135300:	0005883a 	mov	r2,zero
81135304:	f800283a 	ret
81135308:	00802284 	movi	r2,138
8113530c:	20800015 	stw	r2,0(r4)
81135310:	00bfffc4 	movi	r2,-1
81135314:	f800283a 	ret

81135318 <_wctomb_r>:
81135318:	00a04574 	movhi	r2,33045
8113531c:	defff904 	addi	sp,sp,-28
81135320:	10911804 	addi	r2,r2,17504
81135324:	de00012e 	bgeu	sp,et,8113532c <_wctomb_r+0x14>
81135328:	003b68fa 	trap	3
8113532c:	dfc00615 	stw	ra,24(sp)
81135330:	dc400515 	stw	r17,20(sp)
81135334:	dc000415 	stw	r16,16(sp)
81135338:	3823883a 	mov	r17,r7
8113533c:	14000017 	ldw	r16,0(r2)
81135340:	d9000115 	stw	r4,4(sp)
81135344:	d9400215 	stw	r5,8(sp)
81135348:	d9800315 	stw	r6,12(sp)
8113534c:	112d6ac0 	call	8112d6ac <__locale_charset>
81135350:	d9800317 	ldw	r6,12(sp)
81135354:	d9400217 	ldw	r5,8(sp)
81135358:	d9000117 	ldw	r4,4(sp)
8113535c:	100f883a 	mov	r7,r2
81135360:	dc400015 	stw	r17,0(sp)
81135364:	803ee83a 	callr	r16
81135368:	dfc00617 	ldw	ra,24(sp)
8113536c:	dc400517 	ldw	r17,20(sp)
81135370:	dc000417 	ldw	r16,16(sp)
81135374:	dec00704 	addi	sp,sp,28
81135378:	f800283a 	ret

8113537c <__udivdi3>:
8113537c:	defff504 	addi	sp,sp,-44
81135380:	de00012e 	bgeu	sp,et,81135388 <__udivdi3+0xc>
81135384:	003b68fa 	trap	3
81135388:	dcc00415 	stw	r19,16(sp)
8113538c:	dc000115 	stw	r16,4(sp)
81135390:	dfc00a15 	stw	ra,40(sp)
81135394:	df000915 	stw	fp,36(sp)
81135398:	ddc00815 	stw	r23,32(sp)
8113539c:	dd800715 	stw	r22,28(sp)
811353a0:	dd400615 	stw	r21,24(sp)
811353a4:	dd000515 	stw	r20,20(sp)
811353a8:	dc800315 	stw	r18,12(sp)
811353ac:	dc400215 	stw	r17,8(sp)
811353b0:	2027883a 	mov	r19,r4
811353b4:	2821883a 	mov	r16,r5
811353b8:	3800411e 	bne	r7,zero,811354c0 <__udivdi3+0x144>
811353bc:	3023883a 	mov	r17,r6
811353c0:	2025883a 	mov	r18,r4
811353c4:	2980522e 	bgeu	r5,r6,81135510 <__udivdi3+0x194>
811353c8:	00bfffd4 	movui	r2,65535
811353cc:	282d883a 	mov	r22,r5
811353d0:	1180a836 	bltu	r2,r6,81135674 <__udivdi3+0x2f8>
811353d4:	00803fc4 	movi	r2,255
811353d8:	1185803a 	cmpltu	r2,r2,r6
811353dc:	100490fa 	slli	r2,r2,3
811353e0:	3086d83a 	srl	r3,r6,r2
811353e4:	01204574 	movhi	r4,33045
811353e8:	21065804 	addi	r4,r4,6496
811353ec:	20c7883a 	add	r3,r4,r3
811353f0:	18c00003 	ldbu	r3,0(r3)
811353f4:	1885883a 	add	r2,r3,r2
811353f8:	00c00804 	movi	r3,32
811353fc:	1887c83a 	sub	r3,r3,r2
81135400:	18000526 	beq	r3,zero,81135418 <__udivdi3+0x9c>
81135404:	80e0983a 	sll	r16,r16,r3
81135408:	9884d83a 	srl	r2,r19,r2
8113540c:	30e2983a 	sll	r17,r6,r3
81135410:	98e4983a 	sll	r18,r19,r3
81135414:	142cb03a 	or	r22,r2,r16
81135418:	882ad43a 	srli	r21,r17,16
8113541c:	b009883a 	mov	r4,r22
81135420:	8d3fffcc 	andi	r20,r17,65535
81135424:	a80b883a 	mov	r5,r21
81135428:	1135f980 	call	81135f98 <__umodsi3>
8113542c:	b009883a 	mov	r4,r22
81135430:	a80b883a 	mov	r5,r21
81135434:	1027883a 	mov	r19,r2
81135438:	1135f340 	call	81135f34 <__udivsi3>
8113543c:	102d883a 	mov	r22,r2
81135440:	9826943a 	slli	r19,r19,16
81135444:	9004d43a 	srli	r2,r18,16
81135448:	a5a1383a 	mul	r16,r20,r22
8113544c:	14c4b03a 	or	r2,r2,r19
81135450:	1400052e 	bgeu	r2,r16,81135468 <__udivdi3+0xec>
81135454:	1445883a 	add	r2,r2,r17
81135458:	b0ffffc4 	addi	r3,r22,-1
8113545c:	14400136 	bltu	r2,r17,81135464 <__udivdi3+0xe8>
81135460:	14012336 	bltu	r2,r16,811358f0 <__udivdi3+0x574>
81135464:	182d883a 	mov	r22,r3
81135468:	1421c83a 	sub	r16,r2,r16
8113546c:	a80b883a 	mov	r5,r21
81135470:	8009883a 	mov	r4,r16
81135474:	1135f980 	call	81135f98 <__umodsi3>
81135478:	1027883a 	mov	r19,r2
8113547c:	a80b883a 	mov	r5,r21
81135480:	8009883a 	mov	r4,r16
81135484:	1135f340 	call	81135f34 <__udivsi3>
81135488:	9826943a 	slli	r19,r19,16
8113548c:	a0a9383a 	mul	r20,r20,r2
81135490:	94bfffcc 	andi	r18,r18,65535
81135494:	94e4b03a 	or	r18,r18,r19
81135498:	9500052e 	bgeu	r18,r20,811354b0 <__udivdi3+0x134>
8113549c:	8ca5883a 	add	r18,r17,r18
811354a0:	10ffffc4 	addi	r3,r2,-1
811354a4:	9440f136 	bltu	r18,r17,8113586c <__udivdi3+0x4f0>
811354a8:	9500f02e 	bgeu	r18,r20,8113586c <__udivdi3+0x4f0>
811354ac:	10bfff84 	addi	r2,r2,-2
811354b0:	b00c943a 	slli	r6,r22,16
811354b4:	0007883a 	mov	r3,zero
811354b8:	3084b03a 	or	r2,r6,r2
811354bc:	00005906 	br	81135624 <__udivdi3+0x2a8>
811354c0:	29c05636 	bltu	r5,r7,8113561c <__udivdi3+0x2a0>
811354c4:	00bfffd4 	movui	r2,65535
811354c8:	11c0622e 	bgeu	r2,r7,81135654 <__udivdi3+0x2d8>
811354cc:	00804034 	movhi	r2,256
811354d0:	10bfffc4 	addi	r2,r2,-1
811354d4:	11c0ee36 	bltu	r2,r7,81135890 <__udivdi3+0x514>
811354d8:	00800404 	movi	r2,16
811354dc:	3886d83a 	srl	r3,r7,r2
811354e0:	01204574 	movhi	r4,33045
811354e4:	21065804 	addi	r4,r4,6496
811354e8:	20c7883a 	add	r3,r4,r3
811354ec:	18c00003 	ldbu	r3,0(r3)
811354f0:	05400804 	movi	r21,32
811354f4:	1885883a 	add	r2,r3,r2
811354f8:	a8abc83a 	sub	r21,r21,r2
811354fc:	a800621e 	bne	r21,zero,81135688 <__udivdi3+0x30c>
81135500:	3c00e936 	bltu	r7,r16,811358a8 <__udivdi3+0x52c>
81135504:	9985403a 	cmpgeu	r2,r19,r6
81135508:	0007883a 	mov	r3,zero
8113550c:	00004506 	br	81135624 <__udivdi3+0x2a8>
81135510:	3000041e 	bne	r6,zero,81135524 <__udivdi3+0x1a8>
81135514:	000b883a 	mov	r5,zero
81135518:	01000044 	movi	r4,1
8113551c:	1135f340 	call	81135f34 <__udivsi3>
81135520:	1023883a 	mov	r17,r2
81135524:	00bfffd4 	movui	r2,65535
81135528:	14404e2e 	bgeu	r2,r17,81135664 <__udivdi3+0x2e8>
8113552c:	00804034 	movhi	r2,256
81135530:	10bfffc4 	addi	r2,r2,-1
81135534:	1440d836 	bltu	r2,r17,81135898 <__udivdi3+0x51c>
81135538:	00800404 	movi	r2,16
8113553c:	8886d83a 	srl	r3,r17,r2
81135540:	01204574 	movhi	r4,33045
81135544:	21065804 	addi	r4,r4,6496
81135548:	20c7883a 	add	r3,r4,r3
8113554c:	18c00003 	ldbu	r3,0(r3)
81135550:	1885883a 	add	r2,r3,r2
81135554:	00c00804 	movi	r3,32
81135558:	1887c83a 	sub	r3,r3,r2
8113555c:	18008f1e 	bne	r3,zero,8113579c <__udivdi3+0x420>
81135560:	882ad43a 	srli	r21,r17,16
81135564:	8461c83a 	sub	r16,r16,r17
81135568:	8d3fffcc 	andi	r20,r17,65535
8113556c:	00c00044 	movi	r3,1
81135570:	8009883a 	mov	r4,r16
81135574:	a80b883a 	mov	r5,r21
81135578:	d8c00015 	stw	r3,0(sp)
8113557c:	1135f980 	call	81135f98 <__umodsi3>
81135580:	8009883a 	mov	r4,r16
81135584:	a80b883a 	mov	r5,r21
81135588:	1027883a 	mov	r19,r2
8113558c:	1135f340 	call	81135f34 <__udivsi3>
81135590:	9826943a 	slli	r19,r19,16
81135594:	9008d43a 	srli	r4,r18,16
81135598:	1521383a 	mul	r16,r2,r20
8113559c:	102d883a 	mov	r22,r2
811355a0:	24c8b03a 	or	r4,r4,r19
811355a4:	d8c00017 	ldw	r3,0(sp)
811355a8:	2400052e 	bgeu	r4,r16,811355c0 <__udivdi3+0x244>
811355ac:	2449883a 	add	r4,r4,r17
811355b0:	b0bfffc4 	addi	r2,r22,-1
811355b4:	24400136 	bltu	r4,r17,811355bc <__udivdi3+0x240>
811355b8:	2400ca36 	bltu	r4,r16,811358e4 <__udivdi3+0x568>
811355bc:	102d883a 	mov	r22,r2
811355c0:	2421c83a 	sub	r16,r4,r16
811355c4:	a80b883a 	mov	r5,r21
811355c8:	8009883a 	mov	r4,r16
811355cc:	d8c00015 	stw	r3,0(sp)
811355d0:	1135f980 	call	81135f98 <__umodsi3>
811355d4:	1027883a 	mov	r19,r2
811355d8:	a80b883a 	mov	r5,r21
811355dc:	8009883a 	mov	r4,r16
811355e0:	1135f340 	call	81135f34 <__udivsi3>
811355e4:	9826943a 	slli	r19,r19,16
811355e8:	1529383a 	mul	r20,r2,r20
811355ec:	94bfffcc 	andi	r18,r18,65535
811355f0:	94e4b03a 	or	r18,r18,r19
811355f4:	d8c00017 	ldw	r3,0(sp)
811355f8:	9500052e 	bgeu	r18,r20,81135610 <__udivdi3+0x294>
811355fc:	8ca5883a 	add	r18,r17,r18
81135600:	113fffc4 	addi	r4,r2,-1
81135604:	94409736 	bltu	r18,r17,81135864 <__udivdi3+0x4e8>
81135608:	9500962e 	bgeu	r18,r20,81135864 <__udivdi3+0x4e8>
8113560c:	10bfff84 	addi	r2,r2,-2
81135610:	b00c943a 	slli	r6,r22,16
81135614:	3084b03a 	or	r2,r6,r2
81135618:	00000206 	br	81135624 <__udivdi3+0x2a8>
8113561c:	0007883a 	mov	r3,zero
81135620:	0005883a 	mov	r2,zero
81135624:	dfc00a17 	ldw	ra,40(sp)
81135628:	df000917 	ldw	fp,36(sp)
8113562c:	ddc00817 	ldw	r23,32(sp)
81135630:	dd800717 	ldw	r22,28(sp)
81135634:	dd400617 	ldw	r21,24(sp)
81135638:	dd000517 	ldw	r20,20(sp)
8113563c:	dcc00417 	ldw	r19,16(sp)
81135640:	dc800317 	ldw	r18,12(sp)
81135644:	dc400217 	ldw	r17,8(sp)
81135648:	dc000117 	ldw	r16,4(sp)
8113564c:	dec00b04 	addi	sp,sp,44
81135650:	f800283a 	ret
81135654:	00803fc4 	movi	r2,255
81135658:	11c5803a 	cmpltu	r2,r2,r7
8113565c:	100490fa 	slli	r2,r2,3
81135660:	003f9e06 	br	811354dc <__reset+0xfb1154dc>
81135664:	00803fc4 	movi	r2,255
81135668:	1445803a 	cmpltu	r2,r2,r17
8113566c:	100490fa 	slli	r2,r2,3
81135670:	003fb206 	br	8113553c <__reset+0xfb11553c>
81135674:	00804034 	movhi	r2,256
81135678:	10bfffc4 	addi	r2,r2,-1
8113567c:	11808836 	bltu	r2,r6,811358a0 <__udivdi3+0x524>
81135680:	00800404 	movi	r2,16
81135684:	003f5606 	br	811353e0 <__reset+0xfb1153e0>
81135688:	30aed83a 	srl	r23,r6,r2
8113568c:	3d4e983a 	sll	r7,r7,r21
81135690:	80acd83a 	srl	r22,r16,r2
81135694:	9884d83a 	srl	r2,r19,r2
81135698:	3deeb03a 	or	r23,r7,r23
8113569c:	b824d43a 	srli	r18,r23,16
811356a0:	8560983a 	sll	r16,r16,r21
811356a4:	b009883a 	mov	r4,r22
811356a8:	900b883a 	mov	r5,r18
811356ac:	3568983a 	sll	r20,r6,r21
811356b0:	1420b03a 	or	r16,r2,r16
811356b4:	1135f980 	call	81135f98 <__umodsi3>
811356b8:	b009883a 	mov	r4,r22
811356bc:	900b883a 	mov	r5,r18
811356c0:	1023883a 	mov	r17,r2
811356c4:	1135f340 	call	81135f34 <__udivsi3>
811356c8:	8808943a 	slli	r4,r17,16
811356cc:	bf3fffcc 	andi	fp,r23,65535
811356d0:	8006d43a 	srli	r3,r16,16
811356d4:	e0a3383a 	mul	r17,fp,r2
811356d8:	100d883a 	mov	r6,r2
811356dc:	1906b03a 	or	r3,r3,r4
811356e0:	1c40042e 	bgeu	r3,r17,811356f4 <__udivdi3+0x378>
811356e4:	1dc7883a 	add	r3,r3,r23
811356e8:	10bfffc4 	addi	r2,r2,-1
811356ec:	1dc0752e 	bgeu	r3,r23,811358c4 <__udivdi3+0x548>
811356f0:	100d883a 	mov	r6,r2
811356f4:	1c63c83a 	sub	r17,r3,r17
811356f8:	900b883a 	mov	r5,r18
811356fc:	8809883a 	mov	r4,r17
81135700:	d9800015 	stw	r6,0(sp)
81135704:	1135f980 	call	81135f98 <__umodsi3>
81135708:	102d883a 	mov	r22,r2
8113570c:	8809883a 	mov	r4,r17
81135710:	900b883a 	mov	r5,r18
81135714:	1135f340 	call	81135f34 <__udivsi3>
81135718:	b02c943a 	slli	r22,r22,16
8113571c:	e089383a 	mul	r4,fp,r2
81135720:	843fffcc 	andi	r16,r16,65535
81135724:	85a0b03a 	or	r16,r16,r22
81135728:	d9800017 	ldw	r6,0(sp)
8113572c:	8100042e 	bgeu	r16,r4,81135740 <__udivdi3+0x3c4>
81135730:	85e1883a 	add	r16,r16,r23
81135734:	10ffffc4 	addi	r3,r2,-1
81135738:	85c05e2e 	bgeu	r16,r23,811358b4 <__udivdi3+0x538>
8113573c:	1805883a 	mov	r2,r3
81135740:	300c943a 	slli	r6,r6,16
81135744:	a17fffcc 	andi	r5,r20,65535
81135748:	a028d43a 	srli	r20,r20,16
8113574c:	3084b03a 	or	r2,r6,r2
81135750:	10ffffcc 	andi	r3,r2,65535
81135754:	100cd43a 	srli	r6,r2,16
81135758:	194f383a 	mul	r7,r3,r5
8113575c:	1d07383a 	mul	r3,r3,r20
81135760:	314b383a 	mul	r5,r6,r5
81135764:	3810d43a 	srli	r8,r7,16
81135768:	8121c83a 	sub	r16,r16,r4
8113576c:	1947883a 	add	r3,r3,r5
81135770:	40c7883a 	add	r3,r8,r3
81135774:	350d383a 	mul	r6,r6,r20
81135778:	1940022e 	bgeu	r3,r5,81135784 <__udivdi3+0x408>
8113577c:	01000074 	movhi	r4,1
81135780:	310d883a 	add	r6,r6,r4
81135784:	1828d43a 	srli	r20,r3,16
81135788:	a18d883a 	add	r6,r20,r6
8113578c:	81803e36 	bltu	r16,r6,81135888 <__udivdi3+0x50c>
81135790:	81803826 	beq	r16,r6,81135874 <__udivdi3+0x4f8>
81135794:	0007883a 	mov	r3,zero
81135798:	003fa206 	br	81135624 <__reset+0xfb115624>
8113579c:	88e2983a 	sll	r17,r17,r3
811357a0:	80a8d83a 	srl	r20,r16,r2
811357a4:	80e0983a 	sll	r16,r16,r3
811357a8:	882ad43a 	srli	r21,r17,16
811357ac:	9884d83a 	srl	r2,r19,r2
811357b0:	a009883a 	mov	r4,r20
811357b4:	a80b883a 	mov	r5,r21
811357b8:	142eb03a 	or	r23,r2,r16
811357bc:	98e4983a 	sll	r18,r19,r3
811357c0:	1135f980 	call	81135f98 <__umodsi3>
811357c4:	a009883a 	mov	r4,r20
811357c8:	a80b883a 	mov	r5,r21
811357cc:	1021883a 	mov	r16,r2
811357d0:	1135f340 	call	81135f34 <__udivsi3>
811357d4:	1039883a 	mov	fp,r2
811357d8:	8d3fffcc 	andi	r20,r17,65535
811357dc:	8020943a 	slli	r16,r16,16
811357e0:	b804d43a 	srli	r2,r23,16
811357e4:	a72d383a 	mul	r22,r20,fp
811357e8:	1404b03a 	or	r2,r2,r16
811357ec:	1580062e 	bgeu	r2,r22,81135808 <__udivdi3+0x48c>
811357f0:	1445883a 	add	r2,r2,r17
811357f4:	e0ffffc4 	addi	r3,fp,-1
811357f8:	14403836 	bltu	r2,r17,811358dc <__udivdi3+0x560>
811357fc:	1580372e 	bgeu	r2,r22,811358dc <__udivdi3+0x560>
81135800:	e73fff84 	addi	fp,fp,-2
81135804:	1445883a 	add	r2,r2,r17
81135808:	15adc83a 	sub	r22,r2,r22
8113580c:	a80b883a 	mov	r5,r21
81135810:	b009883a 	mov	r4,r22
81135814:	1135f980 	call	81135f98 <__umodsi3>
81135818:	1027883a 	mov	r19,r2
8113581c:	b009883a 	mov	r4,r22
81135820:	a80b883a 	mov	r5,r21
81135824:	1135f340 	call	81135f34 <__udivsi3>
81135828:	9826943a 	slli	r19,r19,16
8113582c:	a0a1383a 	mul	r16,r20,r2
81135830:	b93fffcc 	andi	r4,r23,65535
81135834:	24c8b03a 	or	r4,r4,r19
81135838:	2400062e 	bgeu	r4,r16,81135854 <__udivdi3+0x4d8>
8113583c:	2449883a 	add	r4,r4,r17
81135840:	10ffffc4 	addi	r3,r2,-1
81135844:	24402336 	bltu	r4,r17,811358d4 <__udivdi3+0x558>
81135848:	2400222e 	bgeu	r4,r16,811358d4 <__udivdi3+0x558>
8113584c:	10bfff84 	addi	r2,r2,-2
81135850:	2449883a 	add	r4,r4,r17
81135854:	e038943a 	slli	fp,fp,16
81135858:	2421c83a 	sub	r16,r4,r16
8113585c:	e086b03a 	or	r3,fp,r2
81135860:	003f4306 	br	81135570 <__reset+0xfb115570>
81135864:	2005883a 	mov	r2,r4
81135868:	003f6906 	br	81135610 <__reset+0xfb115610>
8113586c:	1805883a 	mov	r2,r3
81135870:	003f0f06 	br	811354b0 <__reset+0xfb1154b0>
81135874:	1806943a 	slli	r3,r3,16
81135878:	9d66983a 	sll	r19,r19,r21
8113587c:	39ffffcc 	andi	r7,r7,65535
81135880:	19c7883a 	add	r3,r3,r7
81135884:	98ffc32e 	bgeu	r19,r3,81135794 <__reset+0xfb115794>
81135888:	10bfffc4 	addi	r2,r2,-1
8113588c:	003fc106 	br	81135794 <__reset+0xfb115794>
81135890:	00800604 	movi	r2,24
81135894:	003f1106 	br	811354dc <__reset+0xfb1154dc>
81135898:	00800604 	movi	r2,24
8113589c:	003f2706 	br	8113553c <__reset+0xfb11553c>
811358a0:	00800604 	movi	r2,24
811358a4:	003ece06 	br	811353e0 <__reset+0xfb1153e0>
811358a8:	0007883a 	mov	r3,zero
811358ac:	00800044 	movi	r2,1
811358b0:	003f5c06 	br	81135624 <__reset+0xfb115624>
811358b4:	813fa12e 	bgeu	r16,r4,8113573c <__reset+0xfb11573c>
811358b8:	10bfff84 	addi	r2,r2,-2
811358bc:	85e1883a 	add	r16,r16,r23
811358c0:	003f9f06 	br	81135740 <__reset+0xfb115740>
811358c4:	1c7f8a2e 	bgeu	r3,r17,811356f0 <__reset+0xfb1156f0>
811358c8:	31bfff84 	addi	r6,r6,-2
811358cc:	1dc7883a 	add	r3,r3,r23
811358d0:	003f8806 	br	811356f4 <__reset+0xfb1156f4>
811358d4:	1805883a 	mov	r2,r3
811358d8:	003fde06 	br	81135854 <__reset+0xfb115854>
811358dc:	1839883a 	mov	fp,r3
811358e0:	003fc906 	br	81135808 <__reset+0xfb115808>
811358e4:	b5bfff84 	addi	r22,r22,-2
811358e8:	2449883a 	add	r4,r4,r17
811358ec:	003f3406 	br	811355c0 <__reset+0xfb1155c0>
811358f0:	b5bfff84 	addi	r22,r22,-2
811358f4:	1445883a 	add	r2,r2,r17
811358f8:	003edb06 	br	81135468 <__reset+0xfb115468>

811358fc <__umoddi3>:
811358fc:	defff404 	addi	sp,sp,-48
81135900:	de00012e 	bgeu	sp,et,81135908 <__umoddi3+0xc>
81135904:	003b68fa 	trap	3
81135908:	df000a15 	stw	fp,40(sp)
8113590c:	dc400315 	stw	r17,12(sp)
81135910:	dc000215 	stw	r16,8(sp)
81135914:	dfc00b15 	stw	ra,44(sp)
81135918:	ddc00915 	stw	r23,36(sp)
8113591c:	dd800815 	stw	r22,32(sp)
81135920:	dd400715 	stw	r21,28(sp)
81135924:	dd000615 	stw	r20,24(sp)
81135928:	dcc00515 	stw	r19,20(sp)
8113592c:	dc800415 	stw	r18,16(sp)
81135930:	2021883a 	mov	r16,r4
81135934:	2823883a 	mov	r17,r5
81135938:	2839883a 	mov	fp,r5
8113593c:	38003c1e 	bne	r7,zero,81135a30 <__umoddi3+0x134>
81135940:	3027883a 	mov	r19,r6
81135944:	2029883a 	mov	r20,r4
81135948:	2980512e 	bgeu	r5,r6,81135a90 <__umoddi3+0x194>
8113594c:	00bfffd4 	movui	r2,65535
81135950:	11809a36 	bltu	r2,r6,81135bbc <__umoddi3+0x2c0>
81135954:	01003fc4 	movi	r4,255
81135958:	2189803a 	cmpltu	r4,r4,r6
8113595c:	200890fa 	slli	r4,r4,3
81135960:	3104d83a 	srl	r2,r6,r4
81135964:	00e04574 	movhi	r3,33045
81135968:	18c65804 	addi	r3,r3,6496
8113596c:	1885883a 	add	r2,r3,r2
81135970:	10c00003 	ldbu	r3,0(r2)
81135974:	00800804 	movi	r2,32
81135978:	1909883a 	add	r4,r3,r4
8113597c:	1125c83a 	sub	r18,r2,r4
81135980:	90000526 	beq	r18,zero,81135998 <__umoddi3+0x9c>
81135984:	8ca2983a 	sll	r17,r17,r18
81135988:	8108d83a 	srl	r4,r16,r4
8113598c:	34a6983a 	sll	r19,r6,r18
81135990:	84a8983a 	sll	r20,r16,r18
81135994:	2478b03a 	or	fp,r4,r17
81135998:	982ed43a 	srli	r23,r19,16
8113599c:	e009883a 	mov	r4,fp
811359a0:	9dbfffcc 	andi	r22,r19,65535
811359a4:	b80b883a 	mov	r5,r23
811359a8:	1135f980 	call	81135f98 <__umodsi3>
811359ac:	e009883a 	mov	r4,fp
811359b0:	b80b883a 	mov	r5,r23
811359b4:	102b883a 	mov	r21,r2
811359b8:	1135f340 	call	81135f34 <__udivsi3>
811359bc:	a806943a 	slli	r3,r21,16
811359c0:	a008d43a 	srli	r4,r20,16
811359c4:	b085383a 	mul	r2,r22,r2
811359c8:	20c8b03a 	or	r4,r4,r3
811359cc:	2080032e 	bgeu	r4,r2,811359dc <__umoddi3+0xe0>
811359d0:	24c9883a 	add	r4,r4,r19
811359d4:	24c00136 	bltu	r4,r19,811359dc <__umoddi3+0xe0>
811359d8:	20811036 	bltu	r4,r2,81135e1c <__umoddi3+0x520>
811359dc:	20abc83a 	sub	r21,r4,r2
811359e0:	b80b883a 	mov	r5,r23
811359e4:	a809883a 	mov	r4,r21
811359e8:	1135f980 	call	81135f98 <__umodsi3>
811359ec:	1023883a 	mov	r17,r2
811359f0:	b80b883a 	mov	r5,r23
811359f4:	a809883a 	mov	r4,r21
811359f8:	1135f340 	call	81135f34 <__udivsi3>
811359fc:	8822943a 	slli	r17,r17,16
81135a00:	b085383a 	mul	r2,r22,r2
81135a04:	a0ffffcc 	andi	r3,r20,65535
81135a08:	1c46b03a 	or	r3,r3,r17
81135a0c:	1880042e 	bgeu	r3,r2,81135a20 <__umoddi3+0x124>
81135a10:	1cc7883a 	add	r3,r3,r19
81135a14:	1cc00236 	bltu	r3,r19,81135a20 <__umoddi3+0x124>
81135a18:	1880012e 	bgeu	r3,r2,81135a20 <__umoddi3+0x124>
81135a1c:	1cc7883a 	add	r3,r3,r19
81135a20:	1885c83a 	sub	r2,r3,r2
81135a24:	1484d83a 	srl	r2,r2,r18
81135a28:	0007883a 	mov	r3,zero
81135a2c:	00004f06 	br	81135b6c <__umoddi3+0x270>
81135a30:	29c04c36 	bltu	r5,r7,81135b64 <__umoddi3+0x268>
81135a34:	00bfffd4 	movui	r2,65535
81135a38:	11c0582e 	bgeu	r2,r7,81135b9c <__umoddi3+0x2a0>
81135a3c:	00804034 	movhi	r2,256
81135a40:	10bfffc4 	addi	r2,r2,-1
81135a44:	11c0e736 	bltu	r2,r7,81135de4 <__umoddi3+0x4e8>
81135a48:	01000404 	movi	r4,16
81135a4c:	3904d83a 	srl	r2,r7,r4
81135a50:	00e04574 	movhi	r3,33045
81135a54:	18c65804 	addi	r3,r3,6496
81135a58:	1885883a 	add	r2,r3,r2
81135a5c:	14c00003 	ldbu	r19,0(r2)
81135a60:	00c00804 	movi	r3,32
81135a64:	9927883a 	add	r19,r19,r4
81135a68:	1ce9c83a 	sub	r20,r3,r19
81135a6c:	a000581e 	bne	r20,zero,81135bd0 <__umoddi3+0x2d4>
81135a70:	3c400136 	bltu	r7,r17,81135a78 <__umoddi3+0x17c>
81135a74:	8180eb36 	bltu	r16,r6,81135e24 <__umoddi3+0x528>
81135a78:	8185c83a 	sub	r2,r16,r6
81135a7c:	89e3c83a 	sub	r17,r17,r7
81135a80:	8089803a 	cmpltu	r4,r16,r2
81135a84:	8939c83a 	sub	fp,r17,r4
81135a88:	e007883a 	mov	r3,fp
81135a8c:	00003706 	br	81135b6c <__umoddi3+0x270>
81135a90:	3000041e 	bne	r6,zero,81135aa4 <__umoddi3+0x1a8>
81135a94:	000b883a 	mov	r5,zero
81135a98:	01000044 	movi	r4,1
81135a9c:	1135f340 	call	81135f34 <__udivsi3>
81135aa0:	1027883a 	mov	r19,r2
81135aa4:	00bfffd4 	movui	r2,65535
81135aa8:	14c0402e 	bgeu	r2,r19,81135bac <__umoddi3+0x2b0>
81135aac:	00804034 	movhi	r2,256
81135ab0:	10bfffc4 	addi	r2,r2,-1
81135ab4:	14c0cd36 	bltu	r2,r19,81135dec <__umoddi3+0x4f0>
81135ab8:	00800404 	movi	r2,16
81135abc:	9886d83a 	srl	r3,r19,r2
81135ac0:	01204574 	movhi	r4,33045
81135ac4:	21065804 	addi	r4,r4,6496
81135ac8:	20c7883a 	add	r3,r4,r3
81135acc:	18c00003 	ldbu	r3,0(r3)
81135ad0:	1887883a 	add	r3,r3,r2
81135ad4:	00800804 	movi	r2,32
81135ad8:	10e5c83a 	sub	r18,r2,r3
81135adc:	9000901e 	bne	r18,zero,81135d20 <__umoddi3+0x424>
81135ae0:	982cd43a 	srli	r22,r19,16
81135ae4:	8ce3c83a 	sub	r17,r17,r19
81135ae8:	9d7fffcc 	andi	r21,r19,65535
81135aec:	b00b883a 	mov	r5,r22
81135af0:	8809883a 	mov	r4,r17
81135af4:	1135f980 	call	81135f98 <__umodsi3>
81135af8:	8809883a 	mov	r4,r17
81135afc:	b00b883a 	mov	r5,r22
81135b00:	1021883a 	mov	r16,r2
81135b04:	1135f340 	call	81135f34 <__udivsi3>
81135b08:	8006943a 	slli	r3,r16,16
81135b0c:	a008d43a 	srli	r4,r20,16
81135b10:	1545383a 	mul	r2,r2,r21
81135b14:	20c8b03a 	or	r4,r4,r3
81135b18:	2080042e 	bgeu	r4,r2,81135b2c <__umoddi3+0x230>
81135b1c:	24c9883a 	add	r4,r4,r19
81135b20:	24c00236 	bltu	r4,r19,81135b2c <__umoddi3+0x230>
81135b24:	2080012e 	bgeu	r4,r2,81135b2c <__umoddi3+0x230>
81135b28:	24c9883a 	add	r4,r4,r19
81135b2c:	20a1c83a 	sub	r16,r4,r2
81135b30:	b00b883a 	mov	r5,r22
81135b34:	8009883a 	mov	r4,r16
81135b38:	1135f980 	call	81135f98 <__umodsi3>
81135b3c:	1023883a 	mov	r17,r2
81135b40:	b00b883a 	mov	r5,r22
81135b44:	8009883a 	mov	r4,r16
81135b48:	1135f340 	call	81135f34 <__udivsi3>
81135b4c:	8822943a 	slli	r17,r17,16
81135b50:	1545383a 	mul	r2,r2,r21
81135b54:	a53fffcc 	andi	r20,r20,65535
81135b58:	a446b03a 	or	r3,r20,r17
81135b5c:	18bfb02e 	bgeu	r3,r2,81135a20 <__reset+0xfb115a20>
81135b60:	003fab06 	br	81135a10 <__reset+0xfb115a10>
81135b64:	2005883a 	mov	r2,r4
81135b68:	2807883a 	mov	r3,r5
81135b6c:	dfc00b17 	ldw	ra,44(sp)
81135b70:	df000a17 	ldw	fp,40(sp)
81135b74:	ddc00917 	ldw	r23,36(sp)
81135b78:	dd800817 	ldw	r22,32(sp)
81135b7c:	dd400717 	ldw	r21,28(sp)
81135b80:	dd000617 	ldw	r20,24(sp)
81135b84:	dcc00517 	ldw	r19,20(sp)
81135b88:	dc800417 	ldw	r18,16(sp)
81135b8c:	dc400317 	ldw	r17,12(sp)
81135b90:	dc000217 	ldw	r16,8(sp)
81135b94:	dec00c04 	addi	sp,sp,48
81135b98:	f800283a 	ret
81135b9c:	04c03fc4 	movi	r19,255
81135ba0:	99c9803a 	cmpltu	r4,r19,r7
81135ba4:	200890fa 	slli	r4,r4,3
81135ba8:	003fa806 	br	81135a4c <__reset+0xfb115a4c>
81135bac:	00803fc4 	movi	r2,255
81135bb0:	14c5803a 	cmpltu	r2,r2,r19
81135bb4:	100490fa 	slli	r2,r2,3
81135bb8:	003fc006 	br	81135abc <__reset+0xfb115abc>
81135bbc:	00804034 	movhi	r2,256
81135bc0:	10bfffc4 	addi	r2,r2,-1
81135bc4:	11808b36 	bltu	r2,r6,81135df4 <__umoddi3+0x4f8>
81135bc8:	01000404 	movi	r4,16
81135bcc:	003f6406 	br	81135960 <__reset+0xfb115960>
81135bd0:	34c4d83a 	srl	r2,r6,r19
81135bd4:	3d0e983a 	sll	r7,r7,r20
81135bd8:	8cf8d83a 	srl	fp,r17,r19
81135bdc:	8d10983a 	sll	r8,r17,r20
81135be0:	38aab03a 	or	r21,r7,r2
81135be4:	a82cd43a 	srli	r22,r21,16
81135be8:	84e2d83a 	srl	r17,r16,r19
81135bec:	e009883a 	mov	r4,fp
81135bf0:	b00b883a 	mov	r5,r22
81135bf4:	8a22b03a 	or	r17,r17,r8
81135bf8:	3524983a 	sll	r18,r6,r20
81135bfc:	1135f980 	call	81135f98 <__umodsi3>
81135c00:	e009883a 	mov	r4,fp
81135c04:	b00b883a 	mov	r5,r22
81135c08:	102f883a 	mov	r23,r2
81135c0c:	1135f340 	call	81135f34 <__udivsi3>
81135c10:	100d883a 	mov	r6,r2
81135c14:	b808943a 	slli	r4,r23,16
81135c18:	aa3fffcc 	andi	r8,r21,65535
81135c1c:	8804d43a 	srli	r2,r17,16
81135c20:	41af383a 	mul	r23,r8,r6
81135c24:	8520983a 	sll	r16,r16,r20
81135c28:	1104b03a 	or	r2,r2,r4
81135c2c:	15c0042e 	bgeu	r2,r23,81135c40 <__umoddi3+0x344>
81135c30:	1545883a 	add	r2,r2,r21
81135c34:	30ffffc4 	addi	r3,r6,-1
81135c38:	1540742e 	bgeu	r2,r21,81135e0c <__umoddi3+0x510>
81135c3c:	180d883a 	mov	r6,r3
81135c40:	15efc83a 	sub	r23,r2,r23
81135c44:	b00b883a 	mov	r5,r22
81135c48:	b809883a 	mov	r4,r23
81135c4c:	d9800115 	stw	r6,4(sp)
81135c50:	da000015 	stw	r8,0(sp)
81135c54:	1135f980 	call	81135f98 <__umodsi3>
81135c58:	b00b883a 	mov	r5,r22
81135c5c:	b809883a 	mov	r4,r23
81135c60:	1039883a 	mov	fp,r2
81135c64:	1135f340 	call	81135f34 <__udivsi3>
81135c68:	da000017 	ldw	r8,0(sp)
81135c6c:	e038943a 	slli	fp,fp,16
81135c70:	100b883a 	mov	r5,r2
81135c74:	4089383a 	mul	r4,r8,r2
81135c78:	8a3fffcc 	andi	r8,r17,65535
81135c7c:	4710b03a 	or	r8,r8,fp
81135c80:	d9800117 	ldw	r6,4(sp)
81135c84:	4100042e 	bgeu	r8,r4,81135c98 <__umoddi3+0x39c>
81135c88:	4551883a 	add	r8,r8,r21
81135c8c:	10bfffc4 	addi	r2,r2,-1
81135c90:	45405a2e 	bgeu	r8,r21,81135dfc <__umoddi3+0x500>
81135c94:	100b883a 	mov	r5,r2
81135c98:	300c943a 	slli	r6,r6,16
81135c9c:	91ffffcc 	andi	r7,r18,65535
81135ca0:	9004d43a 	srli	r2,r18,16
81135ca4:	314cb03a 	or	r6,r6,r5
81135ca8:	317fffcc 	andi	r5,r6,65535
81135cac:	300cd43a 	srli	r6,r6,16
81135cb0:	29d3383a 	mul	r9,r5,r7
81135cb4:	288b383a 	mul	r5,r5,r2
81135cb8:	31cf383a 	mul	r7,r6,r7
81135cbc:	4806d43a 	srli	r3,r9,16
81135cc0:	4111c83a 	sub	r8,r8,r4
81135cc4:	29cb883a 	add	r5,r5,r7
81135cc8:	194b883a 	add	r5,r3,r5
81135ccc:	3085383a 	mul	r2,r6,r2
81135cd0:	29c0022e 	bgeu	r5,r7,81135cdc <__umoddi3+0x3e0>
81135cd4:	00c00074 	movhi	r3,1
81135cd8:	10c5883a 	add	r2,r2,r3
81135cdc:	2808d43a 	srli	r4,r5,16
81135ce0:	280a943a 	slli	r5,r5,16
81135ce4:	4a7fffcc 	andi	r9,r9,65535
81135ce8:	2085883a 	add	r2,r4,r2
81135cec:	2a4b883a 	add	r5,r5,r9
81135cf0:	40803636 	bltu	r8,r2,81135dcc <__umoddi3+0x4d0>
81135cf4:	40804d26 	beq	r8,r2,81135e2c <__umoddi3+0x530>
81135cf8:	4089c83a 	sub	r4,r8,r2
81135cfc:	280f883a 	mov	r7,r5
81135d00:	81cfc83a 	sub	r7,r16,r7
81135d04:	81c7803a 	cmpltu	r3,r16,r7
81135d08:	20c7c83a 	sub	r3,r4,r3
81135d0c:	1cc4983a 	sll	r2,r3,r19
81135d10:	3d0ed83a 	srl	r7,r7,r20
81135d14:	1d06d83a 	srl	r3,r3,r20
81135d18:	11c4b03a 	or	r2,r2,r7
81135d1c:	003f9306 	br	81135b6c <__reset+0xfb115b6c>
81135d20:	9ca6983a 	sll	r19,r19,r18
81135d24:	88e8d83a 	srl	r20,r17,r3
81135d28:	80c4d83a 	srl	r2,r16,r3
81135d2c:	982cd43a 	srli	r22,r19,16
81135d30:	8ca2983a 	sll	r17,r17,r18
81135d34:	a009883a 	mov	r4,r20
81135d38:	b00b883a 	mov	r5,r22
81135d3c:	1478b03a 	or	fp,r2,r17
81135d40:	1135f980 	call	81135f98 <__umodsi3>
81135d44:	a009883a 	mov	r4,r20
81135d48:	b00b883a 	mov	r5,r22
81135d4c:	1023883a 	mov	r17,r2
81135d50:	1135f340 	call	81135f34 <__udivsi3>
81135d54:	9d7fffcc 	andi	r21,r19,65535
81135d58:	880a943a 	slli	r5,r17,16
81135d5c:	e008d43a 	srli	r4,fp,16
81135d60:	a885383a 	mul	r2,r21,r2
81135d64:	84a8983a 	sll	r20,r16,r18
81135d68:	2148b03a 	or	r4,r4,r5
81135d6c:	2080042e 	bgeu	r4,r2,81135d80 <__umoddi3+0x484>
81135d70:	24c9883a 	add	r4,r4,r19
81135d74:	24c00236 	bltu	r4,r19,81135d80 <__umoddi3+0x484>
81135d78:	2080012e 	bgeu	r4,r2,81135d80 <__umoddi3+0x484>
81135d7c:	24c9883a 	add	r4,r4,r19
81135d80:	20a3c83a 	sub	r17,r4,r2
81135d84:	b00b883a 	mov	r5,r22
81135d88:	8809883a 	mov	r4,r17
81135d8c:	1135f980 	call	81135f98 <__umodsi3>
81135d90:	102f883a 	mov	r23,r2
81135d94:	8809883a 	mov	r4,r17
81135d98:	b00b883a 	mov	r5,r22
81135d9c:	1135f340 	call	81135f34 <__udivsi3>
81135da0:	b82e943a 	slli	r23,r23,16
81135da4:	a885383a 	mul	r2,r21,r2
81135da8:	e13fffcc 	andi	r4,fp,65535
81135dac:	25c8b03a 	or	r4,r4,r23
81135db0:	2080042e 	bgeu	r4,r2,81135dc4 <__umoddi3+0x4c8>
81135db4:	24c9883a 	add	r4,r4,r19
81135db8:	24c00236 	bltu	r4,r19,81135dc4 <__umoddi3+0x4c8>
81135dbc:	2080012e 	bgeu	r4,r2,81135dc4 <__umoddi3+0x4c8>
81135dc0:	24c9883a 	add	r4,r4,r19
81135dc4:	20a3c83a 	sub	r17,r4,r2
81135dc8:	003f4806 	br	81135aec <__reset+0xfb115aec>
81135dcc:	2c8fc83a 	sub	r7,r5,r18
81135dd0:	1545c83a 	sub	r2,r2,r21
81135dd4:	29cb803a 	cmpltu	r5,r5,r7
81135dd8:	1145c83a 	sub	r2,r2,r5
81135ddc:	4089c83a 	sub	r4,r8,r2
81135de0:	003fc706 	br	81135d00 <__reset+0xfb115d00>
81135de4:	01000604 	movi	r4,24
81135de8:	003f1806 	br	81135a4c <__reset+0xfb115a4c>
81135dec:	00800604 	movi	r2,24
81135df0:	003f3206 	br	81135abc <__reset+0xfb115abc>
81135df4:	01000604 	movi	r4,24
81135df8:	003ed906 	br	81135960 <__reset+0xfb115960>
81135dfc:	413fa52e 	bgeu	r8,r4,81135c94 <__reset+0xfb115c94>
81135e00:	297fff84 	addi	r5,r5,-2
81135e04:	4551883a 	add	r8,r8,r21
81135e08:	003fa306 	br	81135c98 <__reset+0xfb115c98>
81135e0c:	15ff8b2e 	bgeu	r2,r23,81135c3c <__reset+0xfb115c3c>
81135e10:	31bfff84 	addi	r6,r6,-2
81135e14:	1545883a 	add	r2,r2,r21
81135e18:	003f8906 	br	81135c40 <__reset+0xfb115c40>
81135e1c:	24c9883a 	add	r4,r4,r19
81135e20:	003eee06 	br	811359dc <__reset+0xfb1159dc>
81135e24:	8005883a 	mov	r2,r16
81135e28:	003f1706 	br	81135a88 <__reset+0xfb115a88>
81135e2c:	817fe736 	bltu	r16,r5,81135dcc <__reset+0xfb115dcc>
81135e30:	280f883a 	mov	r7,r5
81135e34:	0009883a 	mov	r4,zero
81135e38:	003fb106 	br	81135d00 <__reset+0xfb115d00>

81135e3c <__divsi3>:
81135e3c:	20001b16 	blt	r4,zero,81135eac <__divsi3+0x70>
81135e40:	000f883a 	mov	r7,zero
81135e44:	28001616 	blt	r5,zero,81135ea0 <__divsi3+0x64>
81135e48:	200d883a 	mov	r6,r4
81135e4c:	29001a2e 	bgeu	r5,r4,81135eb8 <__divsi3+0x7c>
81135e50:	00800804 	movi	r2,32
81135e54:	00c00044 	movi	r3,1
81135e58:	00000106 	br	81135e60 <__divsi3+0x24>
81135e5c:	10000d26 	beq	r2,zero,81135e94 <__divsi3+0x58>
81135e60:	294b883a 	add	r5,r5,r5
81135e64:	10bfffc4 	addi	r2,r2,-1
81135e68:	18c7883a 	add	r3,r3,r3
81135e6c:	293ffb36 	bltu	r5,r4,81135e5c <__reset+0xfb115e5c>
81135e70:	0005883a 	mov	r2,zero
81135e74:	18000726 	beq	r3,zero,81135e94 <__divsi3+0x58>
81135e78:	0005883a 	mov	r2,zero
81135e7c:	31400236 	bltu	r6,r5,81135e88 <__divsi3+0x4c>
81135e80:	314dc83a 	sub	r6,r6,r5
81135e84:	10c4b03a 	or	r2,r2,r3
81135e88:	1806d07a 	srli	r3,r3,1
81135e8c:	280ad07a 	srli	r5,r5,1
81135e90:	183ffa1e 	bne	r3,zero,81135e7c <__reset+0xfb115e7c>
81135e94:	38000126 	beq	r7,zero,81135e9c <__divsi3+0x60>
81135e98:	0085c83a 	sub	r2,zero,r2
81135e9c:	f800283a 	ret
81135ea0:	014bc83a 	sub	r5,zero,r5
81135ea4:	39c0005c 	xori	r7,r7,1
81135ea8:	003fe706 	br	81135e48 <__reset+0xfb115e48>
81135eac:	0109c83a 	sub	r4,zero,r4
81135eb0:	01c00044 	movi	r7,1
81135eb4:	003fe306 	br	81135e44 <__reset+0xfb115e44>
81135eb8:	00c00044 	movi	r3,1
81135ebc:	003fee06 	br	81135e78 <__reset+0xfb115e78>

81135ec0 <__modsi3>:
81135ec0:	20001716 	blt	r4,zero,81135f20 <__modsi3+0x60>
81135ec4:	000f883a 	mov	r7,zero
81135ec8:	2005883a 	mov	r2,r4
81135ecc:	28001216 	blt	r5,zero,81135f18 <__modsi3+0x58>
81135ed0:	2900162e 	bgeu	r5,r4,81135f2c <__modsi3+0x6c>
81135ed4:	01800804 	movi	r6,32
81135ed8:	00c00044 	movi	r3,1
81135edc:	00000106 	br	81135ee4 <__modsi3+0x24>
81135ee0:	30000a26 	beq	r6,zero,81135f0c <__modsi3+0x4c>
81135ee4:	294b883a 	add	r5,r5,r5
81135ee8:	31bfffc4 	addi	r6,r6,-1
81135eec:	18c7883a 	add	r3,r3,r3
81135ef0:	293ffb36 	bltu	r5,r4,81135ee0 <__reset+0xfb115ee0>
81135ef4:	18000526 	beq	r3,zero,81135f0c <__modsi3+0x4c>
81135ef8:	1806d07a 	srli	r3,r3,1
81135efc:	11400136 	bltu	r2,r5,81135f04 <__modsi3+0x44>
81135f00:	1145c83a 	sub	r2,r2,r5
81135f04:	280ad07a 	srli	r5,r5,1
81135f08:	183ffb1e 	bne	r3,zero,81135ef8 <__reset+0xfb115ef8>
81135f0c:	38000126 	beq	r7,zero,81135f14 <__modsi3+0x54>
81135f10:	0085c83a 	sub	r2,zero,r2
81135f14:	f800283a 	ret
81135f18:	014bc83a 	sub	r5,zero,r5
81135f1c:	003fec06 	br	81135ed0 <__reset+0xfb115ed0>
81135f20:	0109c83a 	sub	r4,zero,r4
81135f24:	01c00044 	movi	r7,1
81135f28:	003fe706 	br	81135ec8 <__reset+0xfb115ec8>
81135f2c:	00c00044 	movi	r3,1
81135f30:	003ff106 	br	81135ef8 <__reset+0xfb115ef8>

81135f34 <__udivsi3>:
81135f34:	200d883a 	mov	r6,r4
81135f38:	2900152e 	bgeu	r5,r4,81135f90 <__udivsi3+0x5c>
81135f3c:	28001416 	blt	r5,zero,81135f90 <__udivsi3+0x5c>
81135f40:	00800804 	movi	r2,32
81135f44:	00c00044 	movi	r3,1
81135f48:	00000206 	br	81135f54 <__udivsi3+0x20>
81135f4c:	10000e26 	beq	r2,zero,81135f88 <__udivsi3+0x54>
81135f50:	28000516 	blt	r5,zero,81135f68 <__udivsi3+0x34>
81135f54:	294b883a 	add	r5,r5,r5
81135f58:	10bfffc4 	addi	r2,r2,-1
81135f5c:	18c7883a 	add	r3,r3,r3
81135f60:	293ffa36 	bltu	r5,r4,81135f4c <__reset+0xfb115f4c>
81135f64:	18000826 	beq	r3,zero,81135f88 <__udivsi3+0x54>
81135f68:	0005883a 	mov	r2,zero
81135f6c:	31400236 	bltu	r6,r5,81135f78 <__udivsi3+0x44>
81135f70:	314dc83a 	sub	r6,r6,r5
81135f74:	10c4b03a 	or	r2,r2,r3
81135f78:	1806d07a 	srli	r3,r3,1
81135f7c:	280ad07a 	srli	r5,r5,1
81135f80:	183ffa1e 	bne	r3,zero,81135f6c <__reset+0xfb115f6c>
81135f84:	f800283a 	ret
81135f88:	0005883a 	mov	r2,zero
81135f8c:	f800283a 	ret
81135f90:	00c00044 	movi	r3,1
81135f94:	003ff406 	br	81135f68 <__reset+0xfb115f68>

81135f98 <__umodsi3>:
81135f98:	2005883a 	mov	r2,r4
81135f9c:	2900122e 	bgeu	r5,r4,81135fe8 <__umodsi3+0x50>
81135fa0:	28001116 	blt	r5,zero,81135fe8 <__umodsi3+0x50>
81135fa4:	01800804 	movi	r6,32
81135fa8:	00c00044 	movi	r3,1
81135fac:	00000206 	br	81135fb8 <__umodsi3+0x20>
81135fb0:	30000c26 	beq	r6,zero,81135fe4 <__umodsi3+0x4c>
81135fb4:	28000516 	blt	r5,zero,81135fcc <__umodsi3+0x34>
81135fb8:	294b883a 	add	r5,r5,r5
81135fbc:	31bfffc4 	addi	r6,r6,-1
81135fc0:	18c7883a 	add	r3,r3,r3
81135fc4:	293ffa36 	bltu	r5,r4,81135fb0 <__reset+0xfb115fb0>
81135fc8:	18000626 	beq	r3,zero,81135fe4 <__umodsi3+0x4c>
81135fcc:	1806d07a 	srli	r3,r3,1
81135fd0:	11400136 	bltu	r2,r5,81135fd8 <__umodsi3+0x40>
81135fd4:	1145c83a 	sub	r2,r2,r5
81135fd8:	280ad07a 	srli	r5,r5,1
81135fdc:	183ffb1e 	bne	r3,zero,81135fcc <__reset+0xfb115fcc>
81135fe0:	f800283a 	ret
81135fe4:	f800283a 	ret
81135fe8:	00c00044 	movi	r3,1
81135fec:	003ff706 	br	81135fcc <__reset+0xfb115fcc>

81135ff0 <__eqsf2>:
81135ff0:	2006d5fa 	srli	r3,r4,23
81135ff4:	280cd5fa 	srli	r6,r5,23
81135ff8:	01c02034 	movhi	r7,128
81135ffc:	39ffffc4 	addi	r7,r7,-1
81136000:	18c03fcc 	andi	r3,r3,255
81136004:	02003fc4 	movi	r8,255
81136008:	3904703a 	and	r2,r7,r4
8113600c:	31803fcc 	andi	r6,r6,255
81136010:	394e703a 	and	r7,r7,r5
81136014:	2008d7fa 	srli	r4,r4,31
81136018:	280ad7fa 	srli	r5,r5,31
8113601c:	1a000d26 	beq	r3,r8,81136054 <__eqsf2+0x64>
81136020:	02003fc4 	movi	r8,255
81136024:	32000826 	beq	r6,r8,81136048 <__eqsf2+0x58>
81136028:	19800226 	beq	r3,r6,81136034 <__eqsf2+0x44>
8113602c:	00800044 	movi	r2,1
81136030:	f800283a 	ret
81136034:	11fffd1e 	bne	r2,r7,8113602c <__reset+0xfb11602c>
81136038:	21400926 	beq	r4,r5,81136060 <__eqsf2+0x70>
8113603c:	183ffb1e 	bne	r3,zero,8113602c <__reset+0xfb11602c>
81136040:	1004c03a 	cmpne	r2,r2,zero
81136044:	f800283a 	ret
81136048:	383ff726 	beq	r7,zero,81136028 <__reset+0xfb116028>
8113604c:	00800044 	movi	r2,1
81136050:	f800283a 	ret
81136054:	103ff226 	beq	r2,zero,81136020 <__reset+0xfb116020>
81136058:	00800044 	movi	r2,1
8113605c:	f800283a 	ret
81136060:	0005883a 	mov	r2,zero
81136064:	f800283a 	ret

81136068 <__gesf2>:
81136068:	2004d5fa 	srli	r2,r4,23
8113606c:	2806d5fa 	srli	r3,r5,23
81136070:	01802034 	movhi	r6,128
81136074:	31bfffc4 	addi	r6,r6,-1
81136078:	10803fcc 	andi	r2,r2,255
8113607c:	01c03fc4 	movi	r7,255
81136080:	3110703a 	and	r8,r6,r4
81136084:	18c03fcc 	andi	r3,r3,255
81136088:	314c703a 	and	r6,r6,r5
8113608c:	2008d7fa 	srli	r4,r4,31
81136090:	280ad7fa 	srli	r5,r5,31
81136094:	11c01926 	beq	r2,r7,811360fc <__gesf2+0x94>
81136098:	01c03fc4 	movi	r7,255
8113609c:	19c00f26 	beq	r3,r7,811360dc <__gesf2+0x74>
811360a0:	1000061e 	bne	r2,zero,811360bc <__gesf2+0x54>
811360a4:	400f003a 	cmpeq	r7,r8,zero
811360a8:	1800071e 	bne	r3,zero,811360c8 <__gesf2+0x60>
811360ac:	3000061e 	bne	r6,zero,811360c8 <__gesf2+0x60>
811360b0:	0005883a 	mov	r2,zero
811360b4:	40000e1e 	bne	r8,zero,811360f0 <__gesf2+0x88>
811360b8:	f800283a 	ret
811360bc:	18000a1e 	bne	r3,zero,811360e8 <__gesf2+0x80>
811360c0:	30000b26 	beq	r6,zero,811360f0 <__gesf2+0x88>
811360c4:	000f883a 	mov	r7,zero
811360c8:	29403fcc 	andi	r5,r5,255
811360cc:	38000726 	beq	r7,zero,811360ec <__gesf2+0x84>
811360d0:	28000826 	beq	r5,zero,811360f4 <__gesf2+0x8c>
811360d4:	00800044 	movi	r2,1
811360d8:	f800283a 	ret
811360dc:	303ff026 	beq	r6,zero,811360a0 <__reset+0xfb1160a0>
811360e0:	00bfff84 	movi	r2,-2
811360e4:	f800283a 	ret
811360e8:	29403fcc 	andi	r5,r5,255
811360ec:	21400526 	beq	r4,r5,81136104 <__gesf2+0x9c>
811360f0:	203ff826 	beq	r4,zero,811360d4 <__reset+0xfb1160d4>
811360f4:	00bfffc4 	movi	r2,-1
811360f8:	f800283a 	ret
811360fc:	403fe626 	beq	r8,zero,81136098 <__reset+0xfb116098>
81136100:	003ff706 	br	811360e0 <__reset+0xfb1160e0>
81136104:	18bffa16 	blt	r3,r2,811360f0 <__reset+0xfb1160f0>
81136108:	10c00216 	blt	r2,r3,81136114 <__gesf2+0xac>
8113610c:	323ff836 	bltu	r6,r8,811360f0 <__reset+0xfb1160f0>
81136110:	4180022e 	bgeu	r8,r6,8113611c <__gesf2+0xb4>
81136114:	203fef1e 	bne	r4,zero,811360d4 <__reset+0xfb1160d4>
81136118:	003ff606 	br	811360f4 <__reset+0xfb1160f4>
8113611c:	0005883a 	mov	r2,zero
81136120:	f800283a 	ret

81136124 <__lesf2>:
81136124:	2004d5fa 	srli	r2,r4,23
81136128:	280cd5fa 	srli	r6,r5,23
8113612c:	00c02034 	movhi	r3,128
81136130:	18ffffc4 	addi	r3,r3,-1
81136134:	10803fcc 	andi	r2,r2,255
81136138:	01c03fc4 	movi	r7,255
8113613c:	1910703a 	and	r8,r3,r4
81136140:	31803fcc 	andi	r6,r6,255
81136144:	1946703a 	and	r3,r3,r5
81136148:	2008d7fa 	srli	r4,r4,31
8113614c:	280ad7fa 	srli	r5,r5,31
81136150:	11c01b26 	beq	r2,r7,811361c0 <__lesf2+0x9c>
81136154:	01c03fc4 	movi	r7,255
81136158:	31c01126 	beq	r6,r7,811361a0 <__lesf2+0x7c>
8113615c:	1000071e 	bne	r2,zero,8113617c <__lesf2+0x58>
81136160:	400f003a 	cmpeq	r7,r8,zero
81136164:	21003fcc 	andi	r4,r4,255
81136168:	3000081e 	bne	r6,zero,8113618c <__lesf2+0x68>
8113616c:	1800071e 	bne	r3,zero,8113618c <__lesf2+0x68>
81136170:	0005883a 	mov	r2,zero
81136174:	40000f1e 	bne	r8,zero,811361b4 <__lesf2+0x90>
81136178:	f800283a 	ret
8113617c:	21003fcc 	andi	r4,r4,255
81136180:	30000a1e 	bne	r6,zero,811361ac <__lesf2+0x88>
81136184:	18000b26 	beq	r3,zero,811361b4 <__lesf2+0x90>
81136188:	000f883a 	mov	r7,zero
8113618c:	29403fcc 	andi	r5,r5,255
81136190:	38000726 	beq	r7,zero,811361b0 <__lesf2+0x8c>
81136194:	28000826 	beq	r5,zero,811361b8 <__lesf2+0x94>
81136198:	00800044 	movi	r2,1
8113619c:	f800283a 	ret
811361a0:	183fee26 	beq	r3,zero,8113615c <__reset+0xfb11615c>
811361a4:	00800084 	movi	r2,2
811361a8:	f800283a 	ret
811361ac:	29403fcc 	andi	r5,r5,255
811361b0:	21400626 	beq	r4,r5,811361cc <__lesf2+0xa8>
811361b4:	203ff826 	beq	r4,zero,81136198 <__reset+0xfb116198>
811361b8:	00bfffc4 	movi	r2,-1
811361bc:	f800283a 	ret
811361c0:	403fe426 	beq	r8,zero,81136154 <__reset+0xfb116154>
811361c4:	00800084 	movi	r2,2
811361c8:	f800283a 	ret
811361cc:	30bff916 	blt	r6,r2,811361b4 <__reset+0xfb1161b4>
811361d0:	11800216 	blt	r2,r6,811361dc <__lesf2+0xb8>
811361d4:	1a3ff736 	bltu	r3,r8,811361b4 <__reset+0xfb1161b4>
811361d8:	40c0022e 	bgeu	r8,r3,811361e4 <__lesf2+0xc0>
811361dc:	203fee1e 	bne	r4,zero,81136198 <__reset+0xfb116198>
811361e0:	003ff506 	br	811361b8 <__reset+0xfb1161b8>
811361e4:	0005883a 	mov	r2,zero
811361e8:	f800283a 	ret

811361ec <__adddf3>:
811361ec:	02c00434 	movhi	r11,16
811361f0:	5affffc4 	addi	r11,r11,-1
811361f4:	2806d7fa 	srli	r3,r5,31
811361f8:	2ad4703a 	and	r10,r5,r11
811361fc:	3ad2703a 	and	r9,r7,r11
81136200:	3804d53a 	srli	r2,r7,20
81136204:	3018d77a 	srli	r12,r6,29
81136208:	280ad53a 	srli	r5,r5,20
8113620c:	501490fa 	slli	r10,r10,3
81136210:	2010d77a 	srli	r8,r4,29
81136214:	481290fa 	slli	r9,r9,3
81136218:	380ed7fa 	srli	r7,r7,31
8113621c:	defffb04 	addi	sp,sp,-20
81136220:	de00012e 	bgeu	sp,et,81136228 <__adddf3+0x3c>
81136224:	003b68fa 	trap	3
81136228:	dc800215 	stw	r18,8(sp)
8113622c:	dc400115 	stw	r17,4(sp)
81136230:	dc000015 	stw	r16,0(sp)
81136234:	dfc00415 	stw	ra,16(sp)
81136238:	dcc00315 	stw	r19,12(sp)
8113623c:	1c803fcc 	andi	r18,r3,255
81136240:	2c01ffcc 	andi	r16,r5,2047
81136244:	5210b03a 	or	r8,r10,r8
81136248:	202290fa 	slli	r17,r4,3
8113624c:	1081ffcc 	andi	r2,r2,2047
81136250:	4b12b03a 	or	r9,r9,r12
81136254:	300c90fa 	slli	r6,r6,3
81136258:	91c07526 	beq	r18,r7,81136430 <__adddf3+0x244>
8113625c:	8087c83a 	sub	r3,r16,r2
81136260:	00c0ab0e 	bge	zero,r3,81136510 <__adddf3+0x324>
81136264:	10002a1e 	bne	r2,zero,81136310 <__adddf3+0x124>
81136268:	4984b03a 	or	r2,r9,r6
8113626c:	1000961e 	bne	r2,zero,811364c8 <__adddf3+0x2dc>
81136270:	888001cc 	andi	r2,r17,7
81136274:	10000726 	beq	r2,zero,81136294 <__adddf3+0xa8>
81136278:	888003cc 	andi	r2,r17,15
8113627c:	00c00104 	movi	r3,4
81136280:	10c00426 	beq	r2,r3,81136294 <__adddf3+0xa8>
81136284:	88c7883a 	add	r3,r17,r3
81136288:	1c63803a 	cmpltu	r17,r3,r17
8113628c:	4451883a 	add	r8,r8,r17
81136290:	1823883a 	mov	r17,r3
81136294:	4080202c 	andhi	r2,r8,128
81136298:	10005926 	beq	r2,zero,81136400 <__adddf3+0x214>
8113629c:	84000044 	addi	r16,r16,1
811362a0:	0081ffc4 	movi	r2,2047
811362a4:	8080ba26 	beq	r16,r2,81136590 <__adddf3+0x3a4>
811362a8:	00bfe034 	movhi	r2,65408
811362ac:	10bfffc4 	addi	r2,r2,-1
811362b0:	4090703a 	and	r8,r8,r2
811362b4:	4004977a 	slli	r2,r8,29
811362b8:	4010927a 	slli	r8,r8,9
811362bc:	8822d0fa 	srli	r17,r17,3
811362c0:	8401ffcc 	andi	r16,r16,2047
811362c4:	4010d33a 	srli	r8,r8,12
811362c8:	9007883a 	mov	r3,r18
811362cc:	1444b03a 	or	r2,r2,r17
811362d0:	8401ffcc 	andi	r16,r16,2047
811362d4:	8020953a 	slli	r16,r16,20
811362d8:	18c03fcc 	andi	r3,r3,255
811362dc:	01000434 	movhi	r4,16
811362e0:	213fffc4 	addi	r4,r4,-1
811362e4:	180697fa 	slli	r3,r3,31
811362e8:	4110703a 	and	r8,r8,r4
811362ec:	4410b03a 	or	r8,r8,r16
811362f0:	40c6b03a 	or	r3,r8,r3
811362f4:	dfc00417 	ldw	ra,16(sp)
811362f8:	dcc00317 	ldw	r19,12(sp)
811362fc:	dc800217 	ldw	r18,8(sp)
81136300:	dc400117 	ldw	r17,4(sp)
81136304:	dc000017 	ldw	r16,0(sp)
81136308:	dec00504 	addi	sp,sp,20
8113630c:	f800283a 	ret
81136310:	0081ffc4 	movi	r2,2047
81136314:	80bfd626 	beq	r16,r2,81136270 <__reset+0xfb116270>
81136318:	4a402034 	orhi	r9,r9,128
8113631c:	00800e04 	movi	r2,56
81136320:	10c09f16 	blt	r2,r3,811365a0 <__adddf3+0x3b4>
81136324:	008007c4 	movi	r2,31
81136328:	10c0c216 	blt	r2,r3,81136634 <__adddf3+0x448>
8113632c:	00800804 	movi	r2,32
81136330:	10c5c83a 	sub	r2,r2,r3
81136334:	488a983a 	sll	r5,r9,r2
81136338:	30c8d83a 	srl	r4,r6,r3
8113633c:	3084983a 	sll	r2,r6,r2
81136340:	48c6d83a 	srl	r3,r9,r3
81136344:	290cb03a 	or	r6,r5,r4
81136348:	1004c03a 	cmpne	r2,r2,zero
8113634c:	308cb03a 	or	r6,r6,r2
81136350:	898dc83a 	sub	r6,r17,r6
81136354:	89a3803a 	cmpltu	r17,r17,r6
81136358:	40d1c83a 	sub	r8,r8,r3
8113635c:	4451c83a 	sub	r8,r8,r17
81136360:	3023883a 	mov	r17,r6
81136364:	4080202c 	andhi	r2,r8,128
81136368:	10002326 	beq	r2,zero,811363f8 <__adddf3+0x20c>
8113636c:	04c02034 	movhi	r19,128
81136370:	9cffffc4 	addi	r19,r19,-1
81136374:	44e6703a 	and	r19,r8,r19
81136378:	98007626 	beq	r19,zero,81136554 <__adddf3+0x368>
8113637c:	9809883a 	mov	r4,r19
81136380:	11227d40 	call	811227d4 <__clzsi2>
81136384:	10fffe04 	addi	r3,r2,-8
81136388:	010007c4 	movi	r4,31
8113638c:	20c07716 	blt	r4,r3,8113656c <__adddf3+0x380>
81136390:	00800804 	movi	r2,32
81136394:	10c5c83a 	sub	r2,r2,r3
81136398:	8884d83a 	srl	r2,r17,r2
8113639c:	98d0983a 	sll	r8,r19,r3
811363a0:	88e2983a 	sll	r17,r17,r3
811363a4:	1204b03a 	or	r2,r2,r8
811363a8:	1c007416 	blt	r3,r16,8113657c <__adddf3+0x390>
811363ac:	1c21c83a 	sub	r16,r3,r16
811363b0:	82000044 	addi	r8,r16,1
811363b4:	00c007c4 	movi	r3,31
811363b8:	1a009116 	blt	r3,r8,81136600 <__adddf3+0x414>
811363bc:	00c00804 	movi	r3,32
811363c0:	1a07c83a 	sub	r3,r3,r8
811363c4:	8a08d83a 	srl	r4,r17,r8
811363c8:	88e2983a 	sll	r17,r17,r3
811363cc:	10c6983a 	sll	r3,r2,r3
811363d0:	1210d83a 	srl	r8,r2,r8
811363d4:	8804c03a 	cmpne	r2,r17,zero
811363d8:	1906b03a 	or	r3,r3,r4
811363dc:	18a2b03a 	or	r17,r3,r2
811363e0:	0021883a 	mov	r16,zero
811363e4:	003fa206 	br	81136270 <__reset+0xfb116270>
811363e8:	1890b03a 	or	r8,r3,r2
811363ec:	40017d26 	beq	r8,zero,811369e4 <__adddf3+0x7f8>
811363f0:	1011883a 	mov	r8,r2
811363f4:	1823883a 	mov	r17,r3
811363f8:	888001cc 	andi	r2,r17,7
811363fc:	103f9e1e 	bne	r2,zero,81136278 <__reset+0xfb116278>
81136400:	4004977a 	slli	r2,r8,29
81136404:	8822d0fa 	srli	r17,r17,3
81136408:	4010d0fa 	srli	r8,r8,3
8113640c:	9007883a 	mov	r3,r18
81136410:	1444b03a 	or	r2,r2,r17
81136414:	0101ffc4 	movi	r4,2047
81136418:	81002426 	beq	r16,r4,811364ac <__adddf3+0x2c0>
8113641c:	8120703a 	and	r16,r16,r4
81136420:	01000434 	movhi	r4,16
81136424:	213fffc4 	addi	r4,r4,-1
81136428:	4110703a 	and	r8,r8,r4
8113642c:	003fa806 	br	811362d0 <__reset+0xfb1162d0>
81136430:	8089c83a 	sub	r4,r16,r2
81136434:	01005e0e 	bge	zero,r4,811365b0 <__adddf3+0x3c4>
81136438:	10002b26 	beq	r2,zero,811364e8 <__adddf3+0x2fc>
8113643c:	0081ffc4 	movi	r2,2047
81136440:	80bf8b26 	beq	r16,r2,81136270 <__reset+0xfb116270>
81136444:	4a402034 	orhi	r9,r9,128
81136448:	00800e04 	movi	r2,56
8113644c:	1100a40e 	bge	r2,r4,811366e0 <__adddf3+0x4f4>
81136450:	498cb03a 	or	r6,r9,r6
81136454:	300ac03a 	cmpne	r5,r6,zero
81136458:	0013883a 	mov	r9,zero
8113645c:	2c4b883a 	add	r5,r5,r17
81136460:	2c63803a 	cmpltu	r17,r5,r17
81136464:	4a11883a 	add	r8,r9,r8
81136468:	8a11883a 	add	r8,r17,r8
8113646c:	2823883a 	mov	r17,r5
81136470:	4080202c 	andhi	r2,r8,128
81136474:	103fe026 	beq	r2,zero,811363f8 <__reset+0xfb1163f8>
81136478:	84000044 	addi	r16,r16,1
8113647c:	0081ffc4 	movi	r2,2047
81136480:	8080d226 	beq	r16,r2,811367cc <__adddf3+0x5e0>
81136484:	00bfe034 	movhi	r2,65408
81136488:	10bfffc4 	addi	r2,r2,-1
8113648c:	4090703a 	and	r8,r8,r2
81136490:	880ad07a 	srli	r5,r17,1
81136494:	400897fa 	slli	r4,r8,31
81136498:	88c0004c 	andi	r3,r17,1
8113649c:	28e2b03a 	or	r17,r5,r3
811364a0:	4010d07a 	srli	r8,r8,1
811364a4:	2462b03a 	or	r17,r4,r17
811364a8:	003f7106 	br	81136270 <__reset+0xfb116270>
811364ac:	4088b03a 	or	r4,r8,r2
811364b0:	20014526 	beq	r4,zero,811369c8 <__adddf3+0x7dc>
811364b4:	01000434 	movhi	r4,16
811364b8:	42000234 	orhi	r8,r8,8
811364bc:	213fffc4 	addi	r4,r4,-1
811364c0:	4110703a 	and	r8,r8,r4
811364c4:	003f8206 	br	811362d0 <__reset+0xfb1162d0>
811364c8:	18ffffc4 	addi	r3,r3,-1
811364cc:	1800491e 	bne	r3,zero,811365f4 <__adddf3+0x408>
811364d0:	898bc83a 	sub	r5,r17,r6
811364d4:	8963803a 	cmpltu	r17,r17,r5
811364d8:	4251c83a 	sub	r8,r8,r9
811364dc:	4451c83a 	sub	r8,r8,r17
811364e0:	2823883a 	mov	r17,r5
811364e4:	003f9f06 	br	81136364 <__reset+0xfb116364>
811364e8:	4984b03a 	or	r2,r9,r6
811364ec:	103f6026 	beq	r2,zero,81136270 <__reset+0xfb116270>
811364f0:	213fffc4 	addi	r4,r4,-1
811364f4:	2000931e 	bne	r4,zero,81136744 <__adddf3+0x558>
811364f8:	898d883a 	add	r6,r17,r6
811364fc:	3463803a 	cmpltu	r17,r6,r17
81136500:	4251883a 	add	r8,r8,r9
81136504:	8a11883a 	add	r8,r17,r8
81136508:	3023883a 	mov	r17,r6
8113650c:	003fd806 	br	81136470 <__reset+0xfb116470>
81136510:	1800541e 	bne	r3,zero,81136664 <__adddf3+0x478>
81136514:	80800044 	addi	r2,r16,1
81136518:	1081ffcc 	andi	r2,r2,2047
8113651c:	00c00044 	movi	r3,1
81136520:	1880a00e 	bge	r3,r2,811367a4 <__adddf3+0x5b8>
81136524:	8989c83a 	sub	r4,r17,r6
81136528:	8905803a 	cmpltu	r2,r17,r4
8113652c:	4267c83a 	sub	r19,r8,r9
81136530:	98a7c83a 	sub	r19,r19,r2
81136534:	9880202c 	andhi	r2,r19,128
81136538:	10006326 	beq	r2,zero,811366c8 <__adddf3+0x4dc>
8113653c:	3463c83a 	sub	r17,r6,r17
81136540:	4a07c83a 	sub	r3,r9,r8
81136544:	344d803a 	cmpltu	r6,r6,r17
81136548:	19a7c83a 	sub	r19,r3,r6
8113654c:	3825883a 	mov	r18,r7
81136550:	983f8a1e 	bne	r19,zero,8113637c <__reset+0xfb11637c>
81136554:	8809883a 	mov	r4,r17
81136558:	11227d40 	call	811227d4 <__clzsi2>
8113655c:	10800804 	addi	r2,r2,32
81136560:	10fffe04 	addi	r3,r2,-8
81136564:	010007c4 	movi	r4,31
81136568:	20ff890e 	bge	r4,r3,81136390 <__reset+0xfb116390>
8113656c:	10bff604 	addi	r2,r2,-40
81136570:	8884983a 	sll	r2,r17,r2
81136574:	0023883a 	mov	r17,zero
81136578:	1c3f8c0e 	bge	r3,r16,811363ac <__reset+0xfb1163ac>
8113657c:	023fe034 	movhi	r8,65408
81136580:	423fffc4 	addi	r8,r8,-1
81136584:	80e1c83a 	sub	r16,r16,r3
81136588:	1210703a 	and	r8,r2,r8
8113658c:	003f3806 	br	81136270 <__reset+0xfb116270>
81136590:	9007883a 	mov	r3,r18
81136594:	0011883a 	mov	r8,zero
81136598:	0005883a 	mov	r2,zero
8113659c:	003f4c06 	br	811362d0 <__reset+0xfb1162d0>
811365a0:	498cb03a 	or	r6,r9,r6
811365a4:	300cc03a 	cmpne	r6,r6,zero
811365a8:	0007883a 	mov	r3,zero
811365ac:	003f6806 	br	81136350 <__reset+0xfb116350>
811365b0:	20009c1e 	bne	r4,zero,81136824 <__adddf3+0x638>
811365b4:	80800044 	addi	r2,r16,1
811365b8:	1141ffcc 	andi	r5,r2,2047
811365bc:	01000044 	movi	r4,1
811365c0:	2140670e 	bge	r4,r5,81136760 <__adddf3+0x574>
811365c4:	0101ffc4 	movi	r4,2047
811365c8:	11007f26 	beq	r2,r4,811367c8 <__adddf3+0x5dc>
811365cc:	898d883a 	add	r6,r17,r6
811365d0:	4247883a 	add	r3,r8,r9
811365d4:	3451803a 	cmpltu	r8,r6,r17
811365d8:	40d1883a 	add	r8,r8,r3
811365dc:	402297fa 	slli	r17,r8,31
811365e0:	300cd07a 	srli	r6,r6,1
811365e4:	4010d07a 	srli	r8,r8,1
811365e8:	1021883a 	mov	r16,r2
811365ec:	89a2b03a 	or	r17,r17,r6
811365f0:	003f1f06 	br	81136270 <__reset+0xfb116270>
811365f4:	0081ffc4 	movi	r2,2047
811365f8:	80bf481e 	bne	r16,r2,8113631c <__reset+0xfb11631c>
811365fc:	003f1c06 	br	81136270 <__reset+0xfb116270>
81136600:	843ff844 	addi	r16,r16,-31
81136604:	01000804 	movi	r4,32
81136608:	1406d83a 	srl	r3,r2,r16
8113660c:	41005026 	beq	r8,r4,81136750 <__adddf3+0x564>
81136610:	01001004 	movi	r4,64
81136614:	2211c83a 	sub	r8,r4,r8
81136618:	1204983a 	sll	r2,r2,r8
8113661c:	88a2b03a 	or	r17,r17,r2
81136620:	8822c03a 	cmpne	r17,r17,zero
81136624:	1c62b03a 	or	r17,r3,r17
81136628:	0011883a 	mov	r8,zero
8113662c:	0021883a 	mov	r16,zero
81136630:	003f7106 	br	811363f8 <__reset+0xfb1163f8>
81136634:	193ff804 	addi	r4,r3,-32
81136638:	00800804 	movi	r2,32
8113663c:	4908d83a 	srl	r4,r9,r4
81136640:	18804526 	beq	r3,r2,81136758 <__adddf3+0x56c>
81136644:	00801004 	movi	r2,64
81136648:	10c5c83a 	sub	r2,r2,r3
8113664c:	4886983a 	sll	r3,r9,r2
81136650:	198cb03a 	or	r6,r3,r6
81136654:	300cc03a 	cmpne	r6,r6,zero
81136658:	218cb03a 	or	r6,r4,r6
8113665c:	0007883a 	mov	r3,zero
81136660:	003f3b06 	br	81136350 <__reset+0xfb116350>
81136664:	80002a26 	beq	r16,zero,81136710 <__adddf3+0x524>
81136668:	0101ffc4 	movi	r4,2047
8113666c:	11006826 	beq	r2,r4,81136810 <__adddf3+0x624>
81136670:	00c7c83a 	sub	r3,zero,r3
81136674:	42002034 	orhi	r8,r8,128
81136678:	01000e04 	movi	r4,56
8113667c:	20c07c16 	blt	r4,r3,81136870 <__adddf3+0x684>
81136680:	010007c4 	movi	r4,31
81136684:	20c0da16 	blt	r4,r3,811369f0 <__adddf3+0x804>
81136688:	01000804 	movi	r4,32
8113668c:	20c9c83a 	sub	r4,r4,r3
81136690:	4114983a 	sll	r10,r8,r4
81136694:	88cad83a 	srl	r5,r17,r3
81136698:	8908983a 	sll	r4,r17,r4
8113669c:	40c6d83a 	srl	r3,r8,r3
811366a0:	5162b03a 	or	r17,r10,r5
811366a4:	2008c03a 	cmpne	r4,r4,zero
811366a8:	8922b03a 	or	r17,r17,r4
811366ac:	3463c83a 	sub	r17,r6,r17
811366b0:	48c7c83a 	sub	r3,r9,r3
811366b4:	344d803a 	cmpltu	r6,r6,r17
811366b8:	1991c83a 	sub	r8,r3,r6
811366bc:	1021883a 	mov	r16,r2
811366c0:	3825883a 	mov	r18,r7
811366c4:	003f2706 	br	81136364 <__reset+0xfb116364>
811366c8:	24d0b03a 	or	r8,r4,r19
811366cc:	40001b1e 	bne	r8,zero,8113673c <__adddf3+0x550>
811366d0:	0005883a 	mov	r2,zero
811366d4:	0007883a 	mov	r3,zero
811366d8:	0021883a 	mov	r16,zero
811366dc:	003f4d06 	br	81136414 <__reset+0xfb116414>
811366e0:	008007c4 	movi	r2,31
811366e4:	11003c16 	blt	r2,r4,811367d8 <__adddf3+0x5ec>
811366e8:	00800804 	movi	r2,32
811366ec:	1105c83a 	sub	r2,r2,r4
811366f0:	488e983a 	sll	r7,r9,r2
811366f4:	310ad83a 	srl	r5,r6,r4
811366f8:	3084983a 	sll	r2,r6,r2
811366fc:	4912d83a 	srl	r9,r9,r4
81136700:	394ab03a 	or	r5,r7,r5
81136704:	1004c03a 	cmpne	r2,r2,zero
81136708:	288ab03a 	or	r5,r5,r2
8113670c:	003f5306 	br	8113645c <__reset+0xfb11645c>
81136710:	4448b03a 	or	r4,r8,r17
81136714:	20003e26 	beq	r4,zero,81136810 <__adddf3+0x624>
81136718:	00c6303a 	nor	r3,zero,r3
8113671c:	18003a1e 	bne	r3,zero,81136808 <__adddf3+0x61c>
81136720:	3463c83a 	sub	r17,r6,r17
81136724:	4a07c83a 	sub	r3,r9,r8
81136728:	344d803a 	cmpltu	r6,r6,r17
8113672c:	1991c83a 	sub	r8,r3,r6
81136730:	1021883a 	mov	r16,r2
81136734:	3825883a 	mov	r18,r7
81136738:	003f0a06 	br	81136364 <__reset+0xfb116364>
8113673c:	2023883a 	mov	r17,r4
81136740:	003f0d06 	br	81136378 <__reset+0xfb116378>
81136744:	0081ffc4 	movi	r2,2047
81136748:	80bf3f1e 	bne	r16,r2,81136448 <__reset+0xfb116448>
8113674c:	003ec806 	br	81136270 <__reset+0xfb116270>
81136750:	0005883a 	mov	r2,zero
81136754:	003fb106 	br	8113661c <__reset+0xfb11661c>
81136758:	0007883a 	mov	r3,zero
8113675c:	003fbc06 	br	81136650 <__reset+0xfb116650>
81136760:	4444b03a 	or	r2,r8,r17
81136764:	8000871e 	bne	r16,zero,81136984 <__adddf3+0x798>
81136768:	1000ba26 	beq	r2,zero,81136a54 <__adddf3+0x868>
8113676c:	4984b03a 	or	r2,r9,r6
81136770:	103ebf26 	beq	r2,zero,81136270 <__reset+0xfb116270>
81136774:	8985883a 	add	r2,r17,r6
81136778:	4247883a 	add	r3,r8,r9
8113677c:	1451803a 	cmpltu	r8,r2,r17
81136780:	40d1883a 	add	r8,r8,r3
81136784:	40c0202c 	andhi	r3,r8,128
81136788:	1023883a 	mov	r17,r2
8113678c:	183f1a26 	beq	r3,zero,811363f8 <__reset+0xfb1163f8>
81136790:	00bfe034 	movhi	r2,65408
81136794:	10bfffc4 	addi	r2,r2,-1
81136798:	2021883a 	mov	r16,r4
8113679c:	4090703a 	and	r8,r8,r2
811367a0:	003eb306 	br	81136270 <__reset+0xfb116270>
811367a4:	4444b03a 	or	r2,r8,r17
811367a8:	8000291e 	bne	r16,zero,81136850 <__adddf3+0x664>
811367ac:	10004b1e 	bne	r2,zero,811368dc <__adddf3+0x6f0>
811367b0:	4990b03a 	or	r8,r9,r6
811367b4:	40008b26 	beq	r8,zero,811369e4 <__adddf3+0x7f8>
811367b8:	4811883a 	mov	r8,r9
811367bc:	3023883a 	mov	r17,r6
811367c0:	3825883a 	mov	r18,r7
811367c4:	003eaa06 	br	81136270 <__reset+0xfb116270>
811367c8:	1021883a 	mov	r16,r2
811367cc:	0011883a 	mov	r8,zero
811367d0:	0005883a 	mov	r2,zero
811367d4:	003f0f06 	br	81136414 <__reset+0xfb116414>
811367d8:	217ff804 	addi	r5,r4,-32
811367dc:	00800804 	movi	r2,32
811367e0:	494ad83a 	srl	r5,r9,r5
811367e4:	20807d26 	beq	r4,r2,811369dc <__adddf3+0x7f0>
811367e8:	00801004 	movi	r2,64
811367ec:	1109c83a 	sub	r4,r2,r4
811367f0:	4912983a 	sll	r9,r9,r4
811367f4:	498cb03a 	or	r6,r9,r6
811367f8:	300cc03a 	cmpne	r6,r6,zero
811367fc:	298ab03a 	or	r5,r5,r6
81136800:	0013883a 	mov	r9,zero
81136804:	003f1506 	br	8113645c <__reset+0xfb11645c>
81136808:	0101ffc4 	movi	r4,2047
8113680c:	113f9a1e 	bne	r2,r4,81136678 <__reset+0xfb116678>
81136810:	4811883a 	mov	r8,r9
81136814:	3023883a 	mov	r17,r6
81136818:	1021883a 	mov	r16,r2
8113681c:	3825883a 	mov	r18,r7
81136820:	003e9306 	br	81136270 <__reset+0xfb116270>
81136824:	8000161e 	bne	r16,zero,81136880 <__adddf3+0x694>
81136828:	444ab03a 	or	r5,r8,r17
8113682c:	28005126 	beq	r5,zero,81136974 <__adddf3+0x788>
81136830:	0108303a 	nor	r4,zero,r4
81136834:	20004d1e 	bne	r4,zero,8113696c <__adddf3+0x780>
81136838:	89a3883a 	add	r17,r17,r6
8113683c:	4253883a 	add	r9,r8,r9
81136840:	898d803a 	cmpltu	r6,r17,r6
81136844:	3251883a 	add	r8,r6,r9
81136848:	1021883a 	mov	r16,r2
8113684c:	003f0806 	br	81136470 <__reset+0xfb116470>
81136850:	1000301e 	bne	r2,zero,81136914 <__adddf3+0x728>
81136854:	4984b03a 	or	r2,r9,r6
81136858:	10007126 	beq	r2,zero,81136a20 <__adddf3+0x834>
8113685c:	4811883a 	mov	r8,r9
81136860:	3023883a 	mov	r17,r6
81136864:	3825883a 	mov	r18,r7
81136868:	0401ffc4 	movi	r16,2047
8113686c:	003e8006 	br	81136270 <__reset+0xfb116270>
81136870:	4462b03a 	or	r17,r8,r17
81136874:	8822c03a 	cmpne	r17,r17,zero
81136878:	0007883a 	mov	r3,zero
8113687c:	003f8b06 	br	811366ac <__reset+0xfb1166ac>
81136880:	0141ffc4 	movi	r5,2047
81136884:	11403b26 	beq	r2,r5,81136974 <__adddf3+0x788>
81136888:	0109c83a 	sub	r4,zero,r4
8113688c:	42002034 	orhi	r8,r8,128
81136890:	01400e04 	movi	r5,56
81136894:	29006716 	blt	r5,r4,81136a34 <__adddf3+0x848>
81136898:	014007c4 	movi	r5,31
8113689c:	29007016 	blt	r5,r4,81136a60 <__adddf3+0x874>
811368a0:	01400804 	movi	r5,32
811368a4:	290bc83a 	sub	r5,r5,r4
811368a8:	4154983a 	sll	r10,r8,r5
811368ac:	890ed83a 	srl	r7,r17,r4
811368b0:	894a983a 	sll	r5,r17,r5
811368b4:	4108d83a 	srl	r4,r8,r4
811368b8:	51e2b03a 	or	r17,r10,r7
811368bc:	280ac03a 	cmpne	r5,r5,zero
811368c0:	8962b03a 	or	r17,r17,r5
811368c4:	89a3883a 	add	r17,r17,r6
811368c8:	2253883a 	add	r9,r4,r9
811368cc:	898d803a 	cmpltu	r6,r17,r6
811368d0:	3251883a 	add	r8,r6,r9
811368d4:	1021883a 	mov	r16,r2
811368d8:	003ee506 	br	81136470 <__reset+0xfb116470>
811368dc:	4984b03a 	or	r2,r9,r6
811368e0:	103e6326 	beq	r2,zero,81136270 <__reset+0xfb116270>
811368e4:	8987c83a 	sub	r3,r17,r6
811368e8:	88c9803a 	cmpltu	r4,r17,r3
811368ec:	4245c83a 	sub	r2,r8,r9
811368f0:	1105c83a 	sub	r2,r2,r4
811368f4:	1100202c 	andhi	r4,r2,128
811368f8:	203ebb26 	beq	r4,zero,811363e8 <__reset+0xfb1163e8>
811368fc:	3463c83a 	sub	r17,r6,r17
81136900:	4a07c83a 	sub	r3,r9,r8
81136904:	344d803a 	cmpltu	r6,r6,r17
81136908:	1991c83a 	sub	r8,r3,r6
8113690c:	3825883a 	mov	r18,r7
81136910:	003e5706 	br	81136270 <__reset+0xfb116270>
81136914:	4984b03a 	or	r2,r9,r6
81136918:	10002e26 	beq	r2,zero,811369d4 <__adddf3+0x7e8>
8113691c:	4004d0fa 	srli	r2,r8,3
81136920:	8822d0fa 	srli	r17,r17,3
81136924:	4010977a 	slli	r8,r8,29
81136928:	10c0022c 	andhi	r3,r2,8
8113692c:	4462b03a 	or	r17,r8,r17
81136930:	18000826 	beq	r3,zero,81136954 <__adddf3+0x768>
81136934:	4808d0fa 	srli	r4,r9,3
81136938:	20c0022c 	andhi	r3,r4,8
8113693c:	1800051e 	bne	r3,zero,81136954 <__adddf3+0x768>
81136940:	300cd0fa 	srli	r6,r6,3
81136944:	4806977a 	slli	r3,r9,29
81136948:	2005883a 	mov	r2,r4
8113694c:	3825883a 	mov	r18,r7
81136950:	19a2b03a 	or	r17,r3,r6
81136954:	8810d77a 	srli	r8,r17,29
81136958:	100490fa 	slli	r2,r2,3
8113695c:	882290fa 	slli	r17,r17,3
81136960:	0401ffc4 	movi	r16,2047
81136964:	4090b03a 	or	r8,r8,r2
81136968:	003e4106 	br	81136270 <__reset+0xfb116270>
8113696c:	0141ffc4 	movi	r5,2047
81136970:	117fc71e 	bne	r2,r5,81136890 <__reset+0xfb116890>
81136974:	4811883a 	mov	r8,r9
81136978:	3023883a 	mov	r17,r6
8113697c:	1021883a 	mov	r16,r2
81136980:	003e3b06 	br	81136270 <__reset+0xfb116270>
81136984:	10002f26 	beq	r2,zero,81136a44 <__adddf3+0x858>
81136988:	4984b03a 	or	r2,r9,r6
8113698c:	10001126 	beq	r2,zero,811369d4 <__adddf3+0x7e8>
81136990:	4004d0fa 	srli	r2,r8,3
81136994:	8822d0fa 	srli	r17,r17,3
81136998:	4010977a 	slli	r8,r8,29
8113699c:	10c0022c 	andhi	r3,r2,8
811369a0:	4462b03a 	or	r17,r8,r17
811369a4:	183feb26 	beq	r3,zero,81136954 <__reset+0xfb116954>
811369a8:	4808d0fa 	srli	r4,r9,3
811369ac:	20c0022c 	andhi	r3,r4,8
811369b0:	183fe81e 	bne	r3,zero,81136954 <__reset+0xfb116954>
811369b4:	300cd0fa 	srli	r6,r6,3
811369b8:	4806977a 	slli	r3,r9,29
811369bc:	2005883a 	mov	r2,r4
811369c0:	19a2b03a 	or	r17,r3,r6
811369c4:	003fe306 	br	81136954 <__reset+0xfb116954>
811369c8:	0011883a 	mov	r8,zero
811369cc:	0005883a 	mov	r2,zero
811369d0:	003e3f06 	br	811362d0 <__reset+0xfb1162d0>
811369d4:	0401ffc4 	movi	r16,2047
811369d8:	003e2506 	br	81136270 <__reset+0xfb116270>
811369dc:	0013883a 	mov	r9,zero
811369e0:	003f8406 	br	811367f4 <__reset+0xfb1167f4>
811369e4:	0005883a 	mov	r2,zero
811369e8:	0007883a 	mov	r3,zero
811369ec:	003e8906 	br	81136414 <__reset+0xfb116414>
811369f0:	197ff804 	addi	r5,r3,-32
811369f4:	01000804 	movi	r4,32
811369f8:	414ad83a 	srl	r5,r8,r5
811369fc:	19002426 	beq	r3,r4,81136a90 <__adddf3+0x8a4>
81136a00:	01001004 	movi	r4,64
81136a04:	20c7c83a 	sub	r3,r4,r3
81136a08:	40c6983a 	sll	r3,r8,r3
81136a0c:	1c46b03a 	or	r3,r3,r17
81136a10:	1806c03a 	cmpne	r3,r3,zero
81136a14:	28e2b03a 	or	r17,r5,r3
81136a18:	0007883a 	mov	r3,zero
81136a1c:	003f2306 	br	811366ac <__reset+0xfb1166ac>
81136a20:	0007883a 	mov	r3,zero
81136a24:	5811883a 	mov	r8,r11
81136a28:	00bfffc4 	movi	r2,-1
81136a2c:	0401ffc4 	movi	r16,2047
81136a30:	003e7806 	br	81136414 <__reset+0xfb116414>
81136a34:	4462b03a 	or	r17,r8,r17
81136a38:	8822c03a 	cmpne	r17,r17,zero
81136a3c:	0009883a 	mov	r4,zero
81136a40:	003fa006 	br	811368c4 <__reset+0xfb1168c4>
81136a44:	4811883a 	mov	r8,r9
81136a48:	3023883a 	mov	r17,r6
81136a4c:	0401ffc4 	movi	r16,2047
81136a50:	003e0706 	br	81136270 <__reset+0xfb116270>
81136a54:	4811883a 	mov	r8,r9
81136a58:	3023883a 	mov	r17,r6
81136a5c:	003e0406 	br	81136270 <__reset+0xfb116270>
81136a60:	21fff804 	addi	r7,r4,-32
81136a64:	01400804 	movi	r5,32
81136a68:	41ced83a 	srl	r7,r8,r7
81136a6c:	21400a26 	beq	r4,r5,81136a98 <__adddf3+0x8ac>
81136a70:	01401004 	movi	r5,64
81136a74:	2909c83a 	sub	r4,r5,r4
81136a78:	4108983a 	sll	r4,r8,r4
81136a7c:	2448b03a 	or	r4,r4,r17
81136a80:	2008c03a 	cmpne	r4,r4,zero
81136a84:	3922b03a 	or	r17,r7,r4
81136a88:	0009883a 	mov	r4,zero
81136a8c:	003f8d06 	br	811368c4 <__reset+0xfb1168c4>
81136a90:	0007883a 	mov	r3,zero
81136a94:	003fdd06 	br	81136a0c <__reset+0xfb116a0c>
81136a98:	0009883a 	mov	r4,zero
81136a9c:	003ff706 	br	81136a7c <__reset+0xfb116a7c>

81136aa0 <__divdf3>:
81136aa0:	defff204 	addi	sp,sp,-56
81136aa4:	de00012e 	bgeu	sp,et,81136aac <__divdf3+0xc>
81136aa8:	003b68fa 	trap	3
81136aac:	dd400915 	stw	r21,36(sp)
81136ab0:	282ad53a 	srli	r21,r5,20
81136ab4:	dd000815 	stw	r20,32(sp)
81136ab8:	2828d7fa 	srli	r20,r5,31
81136abc:	dc000415 	stw	r16,16(sp)
81136ac0:	04000434 	movhi	r16,16
81136ac4:	df000c15 	stw	fp,48(sp)
81136ac8:	843fffc4 	addi	r16,r16,-1
81136acc:	dfc00d15 	stw	ra,52(sp)
81136ad0:	ddc00b15 	stw	r23,44(sp)
81136ad4:	dd800a15 	stw	r22,40(sp)
81136ad8:	dcc00715 	stw	r19,28(sp)
81136adc:	dc800615 	stw	r18,24(sp)
81136ae0:	dc400515 	stw	r17,20(sp)
81136ae4:	ad41ffcc 	andi	r21,r21,2047
81136ae8:	2c20703a 	and	r16,r5,r16
81136aec:	a7003fcc 	andi	fp,r20,255
81136af0:	a8006126 	beq	r21,zero,81136c78 <__divdf3+0x1d8>
81136af4:	0081ffc4 	movi	r2,2047
81136af8:	2025883a 	mov	r18,r4
81136afc:	a8803726 	beq	r21,r2,81136bdc <__divdf3+0x13c>
81136b00:	80800434 	orhi	r2,r16,16
81136b04:	100490fa 	slli	r2,r2,3
81136b08:	2020d77a 	srli	r16,r4,29
81136b0c:	202490fa 	slli	r18,r4,3
81136b10:	ad7f0044 	addi	r21,r21,-1023
81136b14:	80a0b03a 	or	r16,r16,r2
81136b18:	0027883a 	mov	r19,zero
81136b1c:	0013883a 	mov	r9,zero
81136b20:	3804d53a 	srli	r2,r7,20
81136b24:	382cd7fa 	srli	r22,r7,31
81136b28:	04400434 	movhi	r17,16
81136b2c:	8c7fffc4 	addi	r17,r17,-1
81136b30:	1081ffcc 	andi	r2,r2,2047
81136b34:	3011883a 	mov	r8,r6
81136b38:	3c62703a 	and	r17,r7,r17
81136b3c:	b5c03fcc 	andi	r23,r22,255
81136b40:	10006c26 	beq	r2,zero,81136cf4 <__divdf3+0x254>
81136b44:	00c1ffc4 	movi	r3,2047
81136b48:	10c06426 	beq	r2,r3,81136cdc <__divdf3+0x23c>
81136b4c:	88c00434 	orhi	r3,r17,16
81136b50:	180690fa 	slli	r3,r3,3
81136b54:	3022d77a 	srli	r17,r6,29
81136b58:	301090fa 	slli	r8,r6,3
81136b5c:	10bf0044 	addi	r2,r2,-1023
81136b60:	88e2b03a 	or	r17,r17,r3
81136b64:	000f883a 	mov	r7,zero
81136b68:	a58cf03a 	xor	r6,r20,r22
81136b6c:	3cc8b03a 	or	r4,r7,r19
81136b70:	a8abc83a 	sub	r21,r21,r2
81136b74:	008003c4 	movi	r2,15
81136b78:	3007883a 	mov	r3,r6
81136b7c:	34c03fcc 	andi	r19,r6,255
81136b80:	11009036 	bltu	r2,r4,81136dc4 <__divdf3+0x324>
81136b84:	200890ba 	slli	r4,r4,2
81136b88:	00a044f4 	movhi	r2,33043
81136b8c:	109ae704 	addi	r2,r2,27548
81136b90:	2089883a 	add	r4,r4,r2
81136b94:	20800017 	ldw	r2,0(r4)
81136b98:	1000683a 	jmp	r2
81136b9c:	81136dc4 	addi	r4,r16,19895
81136ba0:	81136c14 	ori	r4,r16,19888
81136ba4:	81136db4 	orhi	r4,r16,19894
81136ba8:	81136c08 	cmpgei	r4,r16,19888
81136bac:	81136db4 	orhi	r4,r16,19894
81136bb0:	81136d88 	cmpgei	r4,r16,19894
81136bb4:	81136db4 	orhi	r4,r16,19894
81136bb8:	81136c08 	cmpgei	r4,r16,19888
81136bbc:	81136c14 	ori	r4,r16,19888
81136bc0:	81136c14 	ori	r4,r16,19888
81136bc4:	81136d88 	cmpgei	r4,r16,19894
81136bc8:	81136c08 	cmpgei	r4,r16,19888
81136bcc:	81136bf8 	rdprs	r4,r16,19887
81136bd0:	81136bf8 	rdprs	r4,r16,19887
81136bd4:	81136bf8 	rdprs	r4,r16,19887
81136bd8:	811370a8 	cmpgeui	r4,r16,19906
81136bdc:	2404b03a 	or	r2,r4,r16
81136be0:	1000661e 	bne	r2,zero,81136d7c <__divdf3+0x2dc>
81136be4:	04c00204 	movi	r19,8
81136be8:	0021883a 	mov	r16,zero
81136bec:	0025883a 	mov	r18,zero
81136bf0:	02400084 	movi	r9,2
81136bf4:	003fca06 	br	81136b20 <__reset+0xfb116b20>
81136bf8:	8023883a 	mov	r17,r16
81136bfc:	9011883a 	mov	r8,r18
81136c00:	e02f883a 	mov	r23,fp
81136c04:	480f883a 	mov	r7,r9
81136c08:	00800084 	movi	r2,2
81136c0c:	3881311e 	bne	r7,r2,811370d4 <__divdf3+0x634>
81136c10:	b827883a 	mov	r19,r23
81136c14:	98c0004c 	andi	r3,r19,1
81136c18:	0081ffc4 	movi	r2,2047
81136c1c:	000b883a 	mov	r5,zero
81136c20:	0025883a 	mov	r18,zero
81136c24:	1004953a 	slli	r2,r2,20
81136c28:	18c03fcc 	andi	r3,r3,255
81136c2c:	04400434 	movhi	r17,16
81136c30:	8c7fffc4 	addi	r17,r17,-1
81136c34:	180697fa 	slli	r3,r3,31
81136c38:	2c4a703a 	and	r5,r5,r17
81136c3c:	288ab03a 	or	r5,r5,r2
81136c40:	28c6b03a 	or	r3,r5,r3
81136c44:	9005883a 	mov	r2,r18
81136c48:	dfc00d17 	ldw	ra,52(sp)
81136c4c:	df000c17 	ldw	fp,48(sp)
81136c50:	ddc00b17 	ldw	r23,44(sp)
81136c54:	dd800a17 	ldw	r22,40(sp)
81136c58:	dd400917 	ldw	r21,36(sp)
81136c5c:	dd000817 	ldw	r20,32(sp)
81136c60:	dcc00717 	ldw	r19,28(sp)
81136c64:	dc800617 	ldw	r18,24(sp)
81136c68:	dc400517 	ldw	r17,20(sp)
81136c6c:	dc000417 	ldw	r16,16(sp)
81136c70:	dec00e04 	addi	sp,sp,56
81136c74:	f800283a 	ret
81136c78:	2404b03a 	or	r2,r4,r16
81136c7c:	2027883a 	mov	r19,r4
81136c80:	10003926 	beq	r2,zero,81136d68 <__divdf3+0x2c8>
81136c84:	80012e26 	beq	r16,zero,81137140 <__divdf3+0x6a0>
81136c88:	8009883a 	mov	r4,r16
81136c8c:	d9800315 	stw	r6,12(sp)
81136c90:	d9c00215 	stw	r7,8(sp)
81136c94:	11227d40 	call	811227d4 <__clzsi2>
81136c98:	d9800317 	ldw	r6,12(sp)
81136c9c:	d9c00217 	ldw	r7,8(sp)
81136ca0:	113ffd44 	addi	r4,r2,-11
81136ca4:	00c00704 	movi	r3,28
81136ca8:	19012116 	blt	r3,r4,81137130 <__divdf3+0x690>
81136cac:	00c00744 	movi	r3,29
81136cb0:	147ffe04 	addi	r17,r2,-8
81136cb4:	1907c83a 	sub	r3,r3,r4
81136cb8:	8460983a 	sll	r16,r16,r17
81136cbc:	98c6d83a 	srl	r3,r19,r3
81136cc0:	9c64983a 	sll	r18,r19,r17
81136cc4:	1c20b03a 	or	r16,r3,r16
81136cc8:	1080fcc4 	addi	r2,r2,1011
81136ccc:	00abc83a 	sub	r21,zero,r2
81136cd0:	0027883a 	mov	r19,zero
81136cd4:	0013883a 	mov	r9,zero
81136cd8:	003f9106 	br	81136b20 <__reset+0xfb116b20>
81136cdc:	3446b03a 	or	r3,r6,r17
81136ce0:	18001f1e 	bne	r3,zero,81136d60 <__divdf3+0x2c0>
81136ce4:	0023883a 	mov	r17,zero
81136ce8:	0011883a 	mov	r8,zero
81136cec:	01c00084 	movi	r7,2
81136cf0:	003f9d06 	br	81136b68 <__reset+0xfb116b68>
81136cf4:	3446b03a 	or	r3,r6,r17
81136cf8:	18001526 	beq	r3,zero,81136d50 <__divdf3+0x2b0>
81136cfc:	88011b26 	beq	r17,zero,8113716c <__divdf3+0x6cc>
81136d00:	8809883a 	mov	r4,r17
81136d04:	d9800315 	stw	r6,12(sp)
81136d08:	da400115 	stw	r9,4(sp)
81136d0c:	11227d40 	call	811227d4 <__clzsi2>
81136d10:	d9800317 	ldw	r6,12(sp)
81136d14:	da400117 	ldw	r9,4(sp)
81136d18:	113ffd44 	addi	r4,r2,-11
81136d1c:	00c00704 	movi	r3,28
81136d20:	19010e16 	blt	r3,r4,8113715c <__divdf3+0x6bc>
81136d24:	00c00744 	movi	r3,29
81136d28:	123ffe04 	addi	r8,r2,-8
81136d2c:	1907c83a 	sub	r3,r3,r4
81136d30:	8a22983a 	sll	r17,r17,r8
81136d34:	30c6d83a 	srl	r3,r6,r3
81136d38:	3210983a 	sll	r8,r6,r8
81136d3c:	1c62b03a 	or	r17,r3,r17
81136d40:	1080fcc4 	addi	r2,r2,1011
81136d44:	0085c83a 	sub	r2,zero,r2
81136d48:	000f883a 	mov	r7,zero
81136d4c:	003f8606 	br	81136b68 <__reset+0xfb116b68>
81136d50:	0023883a 	mov	r17,zero
81136d54:	0011883a 	mov	r8,zero
81136d58:	01c00044 	movi	r7,1
81136d5c:	003f8206 	br	81136b68 <__reset+0xfb116b68>
81136d60:	01c000c4 	movi	r7,3
81136d64:	003f8006 	br	81136b68 <__reset+0xfb116b68>
81136d68:	04c00104 	movi	r19,4
81136d6c:	0021883a 	mov	r16,zero
81136d70:	0025883a 	mov	r18,zero
81136d74:	02400044 	movi	r9,1
81136d78:	003f6906 	br	81136b20 <__reset+0xfb116b20>
81136d7c:	04c00304 	movi	r19,12
81136d80:	024000c4 	movi	r9,3
81136d84:	003f6606 	br	81136b20 <__reset+0xfb116b20>
81136d88:	01400434 	movhi	r5,16
81136d8c:	0007883a 	mov	r3,zero
81136d90:	297fffc4 	addi	r5,r5,-1
81136d94:	04bfffc4 	movi	r18,-1
81136d98:	0081ffc4 	movi	r2,2047
81136d9c:	003fa106 	br	81136c24 <__reset+0xfb116c24>
81136da0:	00c00044 	movi	r3,1
81136da4:	1887c83a 	sub	r3,r3,r2
81136da8:	01000e04 	movi	r4,56
81136dac:	20c1210e 	bge	r4,r3,81137234 <__divdf3+0x794>
81136db0:	98c0004c 	andi	r3,r19,1
81136db4:	0005883a 	mov	r2,zero
81136db8:	000b883a 	mov	r5,zero
81136dbc:	0025883a 	mov	r18,zero
81136dc0:	003f9806 	br	81136c24 <__reset+0xfb116c24>
81136dc4:	8c00fd36 	bltu	r17,r16,811371bc <__divdf3+0x71c>
81136dc8:	8440fb26 	beq	r16,r17,811371b8 <__divdf3+0x718>
81136dcc:	8007883a 	mov	r3,r16
81136dd0:	ad7fffc4 	addi	r21,r21,-1
81136dd4:	0021883a 	mov	r16,zero
81136dd8:	4004d63a 	srli	r2,r8,24
81136ddc:	8822923a 	slli	r17,r17,8
81136de0:	1809883a 	mov	r4,r3
81136de4:	402c923a 	slli	r22,r8,8
81136de8:	88b8b03a 	or	fp,r17,r2
81136dec:	e028d43a 	srli	r20,fp,16
81136df0:	d8c00015 	stw	r3,0(sp)
81136df4:	e5ffffcc 	andi	r23,fp,65535
81136df8:	a00b883a 	mov	r5,r20
81136dfc:	1135f340 	call	81135f34 <__udivsi3>
81136e00:	d8c00017 	ldw	r3,0(sp)
81136e04:	a00b883a 	mov	r5,r20
81136e08:	d8800315 	stw	r2,12(sp)
81136e0c:	1809883a 	mov	r4,r3
81136e10:	1135f980 	call	81135f98 <__umodsi3>
81136e14:	d9800317 	ldw	r6,12(sp)
81136e18:	1006943a 	slli	r3,r2,16
81136e1c:	9004d43a 	srli	r2,r18,16
81136e20:	b9a3383a 	mul	r17,r23,r6
81136e24:	10c4b03a 	or	r2,r2,r3
81136e28:	1440062e 	bgeu	r2,r17,81136e44 <__divdf3+0x3a4>
81136e2c:	1705883a 	add	r2,r2,fp
81136e30:	30ffffc4 	addi	r3,r6,-1
81136e34:	1700ee36 	bltu	r2,fp,811371f0 <__divdf3+0x750>
81136e38:	1440ed2e 	bgeu	r2,r17,811371f0 <__divdf3+0x750>
81136e3c:	31bfff84 	addi	r6,r6,-2
81136e40:	1705883a 	add	r2,r2,fp
81136e44:	1463c83a 	sub	r17,r2,r17
81136e48:	a00b883a 	mov	r5,r20
81136e4c:	8809883a 	mov	r4,r17
81136e50:	d9800315 	stw	r6,12(sp)
81136e54:	1135f340 	call	81135f34 <__udivsi3>
81136e58:	a00b883a 	mov	r5,r20
81136e5c:	8809883a 	mov	r4,r17
81136e60:	d8800215 	stw	r2,8(sp)
81136e64:	1135f980 	call	81135f98 <__umodsi3>
81136e68:	d9c00217 	ldw	r7,8(sp)
81136e6c:	1004943a 	slli	r2,r2,16
81136e70:	94bfffcc 	andi	r18,r18,65535
81136e74:	b9d1383a 	mul	r8,r23,r7
81136e78:	90a4b03a 	or	r18,r18,r2
81136e7c:	d9800317 	ldw	r6,12(sp)
81136e80:	9200062e 	bgeu	r18,r8,81136e9c <__divdf3+0x3fc>
81136e84:	9725883a 	add	r18,r18,fp
81136e88:	38bfffc4 	addi	r2,r7,-1
81136e8c:	9700d636 	bltu	r18,fp,811371e8 <__divdf3+0x748>
81136e90:	9200d52e 	bgeu	r18,r8,811371e8 <__divdf3+0x748>
81136e94:	39ffff84 	addi	r7,r7,-2
81136e98:	9725883a 	add	r18,r18,fp
81136e9c:	3004943a 	slli	r2,r6,16
81136ea0:	b012d43a 	srli	r9,r22,16
81136ea4:	b1bfffcc 	andi	r6,r22,65535
81136ea8:	11e2b03a 	or	r17,r2,r7
81136eac:	8806d43a 	srli	r3,r17,16
81136eb0:	893fffcc 	andi	r4,r17,65535
81136eb4:	218b383a 	mul	r5,r4,r6
81136eb8:	30c5383a 	mul	r2,r6,r3
81136ebc:	2249383a 	mul	r4,r4,r9
81136ec0:	280ed43a 	srli	r7,r5,16
81136ec4:	9225c83a 	sub	r18,r18,r8
81136ec8:	2089883a 	add	r4,r4,r2
81136ecc:	3909883a 	add	r4,r7,r4
81136ed0:	1a47383a 	mul	r3,r3,r9
81136ed4:	2080022e 	bgeu	r4,r2,81136ee0 <__divdf3+0x440>
81136ed8:	00800074 	movhi	r2,1
81136edc:	1887883a 	add	r3,r3,r2
81136ee0:	2004d43a 	srli	r2,r4,16
81136ee4:	2008943a 	slli	r4,r4,16
81136ee8:	297fffcc 	andi	r5,r5,65535
81136eec:	10c7883a 	add	r3,r2,r3
81136ef0:	2149883a 	add	r4,r4,r5
81136ef4:	90c0a536 	bltu	r18,r3,8113718c <__divdf3+0x6ec>
81136ef8:	90c0bf26 	beq	r18,r3,811371f8 <__divdf3+0x758>
81136efc:	90c7c83a 	sub	r3,r18,r3
81136f00:	810fc83a 	sub	r7,r16,r4
81136f04:	81e5803a 	cmpltu	r18,r16,r7
81136f08:	1ca5c83a 	sub	r18,r3,r18
81136f0c:	e480c126 	beq	fp,r18,81137214 <__divdf3+0x774>
81136f10:	a00b883a 	mov	r5,r20
81136f14:	9009883a 	mov	r4,r18
81136f18:	d9800315 	stw	r6,12(sp)
81136f1c:	d9c00215 	stw	r7,8(sp)
81136f20:	da400115 	stw	r9,4(sp)
81136f24:	1135f340 	call	81135f34 <__udivsi3>
81136f28:	a00b883a 	mov	r5,r20
81136f2c:	9009883a 	mov	r4,r18
81136f30:	d8800015 	stw	r2,0(sp)
81136f34:	1135f980 	call	81135f98 <__umodsi3>
81136f38:	d9c00217 	ldw	r7,8(sp)
81136f3c:	da000017 	ldw	r8,0(sp)
81136f40:	1006943a 	slli	r3,r2,16
81136f44:	3804d43a 	srli	r2,r7,16
81136f48:	ba21383a 	mul	r16,r23,r8
81136f4c:	d9800317 	ldw	r6,12(sp)
81136f50:	10c4b03a 	or	r2,r2,r3
81136f54:	da400117 	ldw	r9,4(sp)
81136f58:	1400062e 	bgeu	r2,r16,81136f74 <__divdf3+0x4d4>
81136f5c:	1705883a 	add	r2,r2,fp
81136f60:	40ffffc4 	addi	r3,r8,-1
81136f64:	1700ad36 	bltu	r2,fp,8113721c <__divdf3+0x77c>
81136f68:	1400ac2e 	bgeu	r2,r16,8113721c <__divdf3+0x77c>
81136f6c:	423fff84 	addi	r8,r8,-2
81136f70:	1705883a 	add	r2,r2,fp
81136f74:	1421c83a 	sub	r16,r2,r16
81136f78:	a00b883a 	mov	r5,r20
81136f7c:	8009883a 	mov	r4,r16
81136f80:	d9800315 	stw	r6,12(sp)
81136f84:	d9c00215 	stw	r7,8(sp)
81136f88:	da000015 	stw	r8,0(sp)
81136f8c:	da400115 	stw	r9,4(sp)
81136f90:	1135f340 	call	81135f34 <__udivsi3>
81136f94:	8009883a 	mov	r4,r16
81136f98:	a00b883a 	mov	r5,r20
81136f9c:	1025883a 	mov	r18,r2
81136fa0:	1135f980 	call	81135f98 <__umodsi3>
81136fa4:	d9c00217 	ldw	r7,8(sp)
81136fa8:	1004943a 	slli	r2,r2,16
81136fac:	bcaf383a 	mul	r23,r23,r18
81136fb0:	393fffcc 	andi	r4,r7,65535
81136fb4:	2088b03a 	or	r4,r4,r2
81136fb8:	d9800317 	ldw	r6,12(sp)
81136fbc:	da000017 	ldw	r8,0(sp)
81136fc0:	da400117 	ldw	r9,4(sp)
81136fc4:	25c0062e 	bgeu	r4,r23,81136fe0 <__divdf3+0x540>
81136fc8:	2709883a 	add	r4,r4,fp
81136fcc:	90bfffc4 	addi	r2,r18,-1
81136fd0:	27009436 	bltu	r4,fp,81137224 <__divdf3+0x784>
81136fd4:	25c0932e 	bgeu	r4,r23,81137224 <__divdf3+0x784>
81136fd8:	94bfff84 	addi	r18,r18,-2
81136fdc:	2709883a 	add	r4,r4,fp
81136fe0:	4004943a 	slli	r2,r8,16
81136fe4:	25efc83a 	sub	r23,r4,r23
81136fe8:	1490b03a 	or	r8,r2,r18
81136fec:	4008d43a 	srli	r4,r8,16
81136ff0:	40ffffcc 	andi	r3,r8,65535
81136ff4:	30c5383a 	mul	r2,r6,r3
81136ff8:	1a47383a 	mul	r3,r3,r9
81136ffc:	310d383a 	mul	r6,r6,r4
81137000:	100ad43a 	srli	r5,r2,16
81137004:	4913383a 	mul	r9,r9,r4
81137008:	1987883a 	add	r3,r3,r6
8113700c:	28c7883a 	add	r3,r5,r3
81137010:	1980022e 	bgeu	r3,r6,8113701c <__divdf3+0x57c>
81137014:	01000074 	movhi	r4,1
81137018:	4913883a 	add	r9,r9,r4
8113701c:	1808d43a 	srli	r4,r3,16
81137020:	1806943a 	slli	r3,r3,16
81137024:	10bfffcc 	andi	r2,r2,65535
81137028:	2253883a 	add	r9,r4,r9
8113702c:	1887883a 	add	r3,r3,r2
81137030:	ba403836 	bltu	r23,r9,81137114 <__divdf3+0x674>
81137034:	ba403626 	beq	r23,r9,81137110 <__divdf3+0x670>
81137038:	42000054 	ori	r8,r8,1
8113703c:	a880ffc4 	addi	r2,r21,1023
81137040:	00bf570e 	bge	zero,r2,81136da0 <__reset+0xfb116da0>
81137044:	40c001cc 	andi	r3,r8,7
81137048:	18000726 	beq	r3,zero,81137068 <__divdf3+0x5c8>
8113704c:	40c003cc 	andi	r3,r8,15
81137050:	01000104 	movi	r4,4
81137054:	19000426 	beq	r3,r4,81137068 <__divdf3+0x5c8>
81137058:	4107883a 	add	r3,r8,r4
8113705c:	1a11803a 	cmpltu	r8,r3,r8
81137060:	8a23883a 	add	r17,r17,r8
81137064:	1811883a 	mov	r8,r3
81137068:	88c0402c 	andhi	r3,r17,256
8113706c:	18000426 	beq	r3,zero,81137080 <__divdf3+0x5e0>
81137070:	00ffc034 	movhi	r3,65280
81137074:	18ffffc4 	addi	r3,r3,-1
81137078:	a8810004 	addi	r2,r21,1024
8113707c:	88e2703a 	and	r17,r17,r3
81137080:	00c1ff84 	movi	r3,2046
81137084:	18bee316 	blt	r3,r2,81136c14 <__reset+0xfb116c14>
81137088:	8824977a 	slli	r18,r17,29
8113708c:	4010d0fa 	srli	r8,r8,3
81137090:	8822927a 	slli	r17,r17,9
81137094:	1081ffcc 	andi	r2,r2,2047
81137098:	9224b03a 	or	r18,r18,r8
8113709c:	880ad33a 	srli	r5,r17,12
811370a0:	98c0004c 	andi	r3,r19,1
811370a4:	003edf06 	br	81136c24 <__reset+0xfb116c24>
811370a8:	8080022c 	andhi	r2,r16,8
811370ac:	10001226 	beq	r2,zero,811370f8 <__divdf3+0x658>
811370b0:	8880022c 	andhi	r2,r17,8
811370b4:	1000101e 	bne	r2,zero,811370f8 <__divdf3+0x658>
811370b8:	00800434 	movhi	r2,16
811370bc:	89400234 	orhi	r5,r17,8
811370c0:	10bfffc4 	addi	r2,r2,-1
811370c4:	b007883a 	mov	r3,r22
811370c8:	288a703a 	and	r5,r5,r2
811370cc:	4025883a 	mov	r18,r8
811370d0:	003f3106 	br	81136d98 <__reset+0xfb116d98>
811370d4:	008000c4 	movi	r2,3
811370d8:	3880a626 	beq	r7,r2,81137374 <__divdf3+0x8d4>
811370dc:	00800044 	movi	r2,1
811370e0:	3880521e 	bne	r7,r2,8113722c <__divdf3+0x78c>
811370e4:	b807883a 	mov	r3,r23
811370e8:	0005883a 	mov	r2,zero
811370ec:	000b883a 	mov	r5,zero
811370f0:	0025883a 	mov	r18,zero
811370f4:	003ecb06 	br	81136c24 <__reset+0xfb116c24>
811370f8:	00800434 	movhi	r2,16
811370fc:	81400234 	orhi	r5,r16,8
81137100:	10bfffc4 	addi	r2,r2,-1
81137104:	a007883a 	mov	r3,r20
81137108:	288a703a 	and	r5,r5,r2
8113710c:	003f2206 	br	81136d98 <__reset+0xfb116d98>
81137110:	183fca26 	beq	r3,zero,8113703c <__reset+0xfb11703c>
81137114:	e5ef883a 	add	r23,fp,r23
81137118:	40bfffc4 	addi	r2,r8,-1
8113711c:	bf00392e 	bgeu	r23,fp,81137204 <__divdf3+0x764>
81137120:	1011883a 	mov	r8,r2
81137124:	ba7fc41e 	bne	r23,r9,81137038 <__reset+0xfb117038>
81137128:	b0ffc31e 	bne	r22,r3,81137038 <__reset+0xfb117038>
8113712c:	003fc306 	br	8113703c <__reset+0xfb11703c>
81137130:	143ff604 	addi	r16,r2,-40
81137134:	9c20983a 	sll	r16,r19,r16
81137138:	0025883a 	mov	r18,zero
8113713c:	003ee206 	br	81136cc8 <__reset+0xfb116cc8>
81137140:	d9800315 	stw	r6,12(sp)
81137144:	d9c00215 	stw	r7,8(sp)
81137148:	11227d40 	call	811227d4 <__clzsi2>
8113714c:	10800804 	addi	r2,r2,32
81137150:	d9c00217 	ldw	r7,8(sp)
81137154:	d9800317 	ldw	r6,12(sp)
81137158:	003ed106 	br	81136ca0 <__reset+0xfb116ca0>
8113715c:	147ff604 	addi	r17,r2,-40
81137160:	3462983a 	sll	r17,r6,r17
81137164:	0011883a 	mov	r8,zero
81137168:	003ef506 	br	81136d40 <__reset+0xfb116d40>
8113716c:	3009883a 	mov	r4,r6
81137170:	d9800315 	stw	r6,12(sp)
81137174:	da400115 	stw	r9,4(sp)
81137178:	11227d40 	call	811227d4 <__clzsi2>
8113717c:	10800804 	addi	r2,r2,32
81137180:	da400117 	ldw	r9,4(sp)
81137184:	d9800317 	ldw	r6,12(sp)
81137188:	003ee306 	br	81136d18 <__reset+0xfb116d18>
8113718c:	85a1883a 	add	r16,r16,r22
81137190:	8585803a 	cmpltu	r2,r16,r22
81137194:	1705883a 	add	r2,r2,fp
81137198:	14a5883a 	add	r18,r2,r18
8113719c:	88bfffc4 	addi	r2,r17,-1
811371a0:	e4800c2e 	bgeu	fp,r18,811371d4 <__divdf3+0x734>
811371a4:	90c03e36 	bltu	r18,r3,811372a0 <__divdf3+0x800>
811371a8:	1c806926 	beq	r3,r18,81137350 <__divdf3+0x8b0>
811371ac:	90c7c83a 	sub	r3,r18,r3
811371b0:	1023883a 	mov	r17,r2
811371b4:	003f5206 	br	81136f00 <__reset+0xfb116f00>
811371b8:	923f0436 	bltu	r18,r8,81136dcc <__reset+0xfb116dcc>
811371bc:	800897fa 	slli	r4,r16,31
811371c0:	9004d07a 	srli	r2,r18,1
811371c4:	8006d07a 	srli	r3,r16,1
811371c8:	902097fa 	slli	r16,r18,31
811371cc:	20a4b03a 	or	r18,r4,r2
811371d0:	003f0106 	br	81136dd8 <__reset+0xfb116dd8>
811371d4:	e4bff51e 	bne	fp,r18,811371ac <__reset+0xfb1171ac>
811371d8:	85bff22e 	bgeu	r16,r22,811371a4 <__reset+0xfb1171a4>
811371dc:	e0c7c83a 	sub	r3,fp,r3
811371e0:	1023883a 	mov	r17,r2
811371e4:	003f4606 	br	81136f00 <__reset+0xfb116f00>
811371e8:	100f883a 	mov	r7,r2
811371ec:	003f2b06 	br	81136e9c <__reset+0xfb116e9c>
811371f0:	180d883a 	mov	r6,r3
811371f4:	003f1306 	br	81136e44 <__reset+0xfb116e44>
811371f8:	813fe436 	bltu	r16,r4,8113718c <__reset+0xfb11718c>
811371fc:	0007883a 	mov	r3,zero
81137200:	003f3f06 	br	81136f00 <__reset+0xfb116f00>
81137204:	ba402c36 	bltu	r23,r9,811372b8 <__divdf3+0x818>
81137208:	4dc05426 	beq	r9,r23,8113735c <__divdf3+0x8bc>
8113720c:	1011883a 	mov	r8,r2
81137210:	003f8906 	br	81137038 <__reset+0xfb117038>
81137214:	023fffc4 	movi	r8,-1
81137218:	003f8806 	br	8113703c <__reset+0xfb11703c>
8113721c:	1811883a 	mov	r8,r3
81137220:	003f5406 	br	81136f74 <__reset+0xfb116f74>
81137224:	1025883a 	mov	r18,r2
81137228:	003f6d06 	br	81136fe0 <__reset+0xfb116fe0>
8113722c:	b827883a 	mov	r19,r23
81137230:	003f8206 	br	8113703c <__reset+0xfb11703c>
81137234:	010007c4 	movi	r4,31
81137238:	20c02616 	blt	r4,r3,811372d4 <__divdf3+0x834>
8113723c:	00800804 	movi	r2,32
81137240:	10c5c83a 	sub	r2,r2,r3
81137244:	888a983a 	sll	r5,r17,r2
81137248:	40c8d83a 	srl	r4,r8,r3
8113724c:	4084983a 	sll	r2,r8,r2
81137250:	88e2d83a 	srl	r17,r17,r3
81137254:	2906b03a 	or	r3,r5,r4
81137258:	1004c03a 	cmpne	r2,r2,zero
8113725c:	1886b03a 	or	r3,r3,r2
81137260:	188001cc 	andi	r2,r3,7
81137264:	10000726 	beq	r2,zero,81137284 <__divdf3+0x7e4>
81137268:	188003cc 	andi	r2,r3,15
8113726c:	01000104 	movi	r4,4
81137270:	11000426 	beq	r2,r4,81137284 <__divdf3+0x7e4>
81137274:	1805883a 	mov	r2,r3
81137278:	10c00104 	addi	r3,r2,4
8113727c:	1885803a 	cmpltu	r2,r3,r2
81137280:	88a3883a 	add	r17,r17,r2
81137284:	8880202c 	andhi	r2,r17,128
81137288:	10002726 	beq	r2,zero,81137328 <__divdf3+0x888>
8113728c:	98c0004c 	andi	r3,r19,1
81137290:	00800044 	movi	r2,1
81137294:	000b883a 	mov	r5,zero
81137298:	0025883a 	mov	r18,zero
8113729c:	003e6106 	br	81136c24 <__reset+0xfb116c24>
811372a0:	85a1883a 	add	r16,r16,r22
811372a4:	8585803a 	cmpltu	r2,r16,r22
811372a8:	1705883a 	add	r2,r2,fp
811372ac:	14a5883a 	add	r18,r2,r18
811372b0:	8c7fff84 	addi	r17,r17,-2
811372b4:	003f1106 	br	81136efc <__reset+0xfb116efc>
811372b8:	b589883a 	add	r4,r22,r22
811372bc:	25ad803a 	cmpltu	r22,r4,r22
811372c0:	b739883a 	add	fp,r22,fp
811372c4:	40bfff84 	addi	r2,r8,-2
811372c8:	bf2f883a 	add	r23,r23,fp
811372cc:	202d883a 	mov	r22,r4
811372d0:	003f9306 	br	81137120 <__reset+0xfb117120>
811372d4:	013ff844 	movi	r4,-31
811372d8:	2085c83a 	sub	r2,r4,r2
811372dc:	8888d83a 	srl	r4,r17,r2
811372e0:	00800804 	movi	r2,32
811372e4:	18802126 	beq	r3,r2,8113736c <__divdf3+0x8cc>
811372e8:	00801004 	movi	r2,64
811372ec:	10c5c83a 	sub	r2,r2,r3
811372f0:	8884983a 	sll	r2,r17,r2
811372f4:	1204b03a 	or	r2,r2,r8
811372f8:	1004c03a 	cmpne	r2,r2,zero
811372fc:	2084b03a 	or	r2,r4,r2
81137300:	144001cc 	andi	r17,r2,7
81137304:	88000d1e 	bne	r17,zero,8113733c <__divdf3+0x89c>
81137308:	000b883a 	mov	r5,zero
8113730c:	1024d0fa 	srli	r18,r2,3
81137310:	98c0004c 	andi	r3,r19,1
81137314:	0005883a 	mov	r2,zero
81137318:	9464b03a 	or	r18,r18,r17
8113731c:	003e4106 	br	81136c24 <__reset+0xfb116c24>
81137320:	1007883a 	mov	r3,r2
81137324:	0023883a 	mov	r17,zero
81137328:	880a927a 	slli	r5,r17,9
8113732c:	1805883a 	mov	r2,r3
81137330:	8822977a 	slli	r17,r17,29
81137334:	280ad33a 	srli	r5,r5,12
81137338:	003ff406 	br	8113730c <__reset+0xfb11730c>
8113733c:	10c003cc 	andi	r3,r2,15
81137340:	01000104 	movi	r4,4
81137344:	193ff626 	beq	r3,r4,81137320 <__reset+0xfb117320>
81137348:	0023883a 	mov	r17,zero
8113734c:	003fca06 	br	81137278 <__reset+0xfb117278>
81137350:	813fd336 	bltu	r16,r4,811372a0 <__reset+0xfb1172a0>
81137354:	1023883a 	mov	r17,r2
81137358:	003fa806 	br	811371fc <__reset+0xfb1171fc>
8113735c:	b0ffd636 	bltu	r22,r3,811372b8 <__reset+0xfb1172b8>
81137360:	1011883a 	mov	r8,r2
81137364:	b0ff341e 	bne	r22,r3,81137038 <__reset+0xfb117038>
81137368:	003f3406 	br	8113703c <__reset+0xfb11703c>
8113736c:	0005883a 	mov	r2,zero
81137370:	003fe006 	br	811372f4 <__reset+0xfb1172f4>
81137374:	00800434 	movhi	r2,16
81137378:	89400234 	orhi	r5,r17,8
8113737c:	10bfffc4 	addi	r2,r2,-1
81137380:	b807883a 	mov	r3,r23
81137384:	288a703a 	and	r5,r5,r2
81137388:	4025883a 	mov	r18,r8
8113738c:	003e8206 	br	81136d98 <__reset+0xfb116d98>

81137390 <__eqdf2>:
81137390:	2804d53a 	srli	r2,r5,20
81137394:	3806d53a 	srli	r3,r7,20
81137398:	02000434 	movhi	r8,16
8113739c:	423fffc4 	addi	r8,r8,-1
811373a0:	1081ffcc 	andi	r2,r2,2047
811373a4:	0281ffc4 	movi	r10,2047
811373a8:	2a12703a 	and	r9,r5,r8
811373ac:	18c1ffcc 	andi	r3,r3,2047
811373b0:	3a10703a 	and	r8,r7,r8
811373b4:	280ad7fa 	srli	r5,r5,31
811373b8:	380ed7fa 	srli	r7,r7,31
811373bc:	12801026 	beq	r2,r10,81137400 <__eqdf2+0x70>
811373c0:	0281ffc4 	movi	r10,2047
811373c4:	1a800a26 	beq	r3,r10,811373f0 <__eqdf2+0x60>
811373c8:	10c00226 	beq	r2,r3,811373d4 <__eqdf2+0x44>
811373cc:	00800044 	movi	r2,1
811373d0:	f800283a 	ret
811373d4:	4a3ffd1e 	bne	r9,r8,811373cc <__reset+0xfb1173cc>
811373d8:	21bffc1e 	bne	r4,r6,811373cc <__reset+0xfb1173cc>
811373dc:	29c00c26 	beq	r5,r7,81137410 <__eqdf2+0x80>
811373e0:	103ffa1e 	bne	r2,zero,811373cc <__reset+0xfb1173cc>
811373e4:	2244b03a 	or	r2,r4,r9
811373e8:	1004c03a 	cmpne	r2,r2,zero
811373ec:	f800283a 	ret
811373f0:	3214b03a 	or	r10,r6,r8
811373f4:	503ff426 	beq	r10,zero,811373c8 <__reset+0xfb1173c8>
811373f8:	00800044 	movi	r2,1
811373fc:	f800283a 	ret
81137400:	2254b03a 	or	r10,r4,r9
81137404:	503fee26 	beq	r10,zero,811373c0 <__reset+0xfb1173c0>
81137408:	00800044 	movi	r2,1
8113740c:	f800283a 	ret
81137410:	0005883a 	mov	r2,zero
81137414:	f800283a 	ret

81137418 <__ledf2>:
81137418:	2804d53a 	srli	r2,r5,20
8113741c:	3810d53a 	srli	r8,r7,20
81137420:	00c00434 	movhi	r3,16
81137424:	18ffffc4 	addi	r3,r3,-1
81137428:	1081ffcc 	andi	r2,r2,2047
8113742c:	0241ffc4 	movi	r9,2047
81137430:	28d4703a 	and	r10,r5,r3
81137434:	4201ffcc 	andi	r8,r8,2047
81137438:	38c6703a 	and	r3,r7,r3
8113743c:	280ad7fa 	srli	r5,r5,31
81137440:	380ed7fa 	srli	r7,r7,31
81137444:	12401f26 	beq	r2,r9,811374c4 <__ledf2+0xac>
81137448:	0241ffc4 	movi	r9,2047
8113744c:	42401426 	beq	r8,r9,811374a0 <__ledf2+0x88>
81137450:	1000091e 	bne	r2,zero,81137478 <__ledf2+0x60>
81137454:	2296b03a 	or	r11,r4,r10
81137458:	5813003a 	cmpeq	r9,r11,zero
8113745c:	29403fcc 	andi	r5,r5,255
81137460:	40000a1e 	bne	r8,zero,8113748c <__ledf2+0x74>
81137464:	30d8b03a 	or	r12,r6,r3
81137468:	6000081e 	bne	r12,zero,8113748c <__ledf2+0x74>
8113746c:	0005883a 	mov	r2,zero
81137470:	5800111e 	bne	r11,zero,811374b8 <__ledf2+0xa0>
81137474:	f800283a 	ret
81137478:	29403fcc 	andi	r5,r5,255
8113747c:	40000c1e 	bne	r8,zero,811374b0 <__ledf2+0x98>
81137480:	30d2b03a 	or	r9,r6,r3
81137484:	48000c26 	beq	r9,zero,811374b8 <__ledf2+0xa0>
81137488:	0013883a 	mov	r9,zero
8113748c:	39c03fcc 	andi	r7,r7,255
81137490:	48000826 	beq	r9,zero,811374b4 <__ledf2+0x9c>
81137494:	38001126 	beq	r7,zero,811374dc <__ledf2+0xc4>
81137498:	00800044 	movi	r2,1
8113749c:	f800283a 	ret
811374a0:	30d2b03a 	or	r9,r6,r3
811374a4:	483fea26 	beq	r9,zero,81137450 <__reset+0xfb117450>
811374a8:	00800084 	movi	r2,2
811374ac:	f800283a 	ret
811374b0:	39c03fcc 	andi	r7,r7,255
811374b4:	39400726 	beq	r7,r5,811374d4 <__ledf2+0xbc>
811374b8:	2800081e 	bne	r5,zero,811374dc <__ledf2+0xc4>
811374bc:	00800044 	movi	r2,1
811374c0:	f800283a 	ret
811374c4:	2292b03a 	or	r9,r4,r10
811374c8:	483fdf26 	beq	r9,zero,81137448 <__reset+0xfb117448>
811374cc:	00800084 	movi	r2,2
811374d0:	f800283a 	ret
811374d4:	4080030e 	bge	r8,r2,811374e4 <__ledf2+0xcc>
811374d8:	383fef26 	beq	r7,zero,81137498 <__reset+0xfb117498>
811374dc:	00bfffc4 	movi	r2,-1
811374e0:	f800283a 	ret
811374e4:	123feb16 	blt	r2,r8,81137494 <__reset+0xfb117494>
811374e8:	1abff336 	bltu	r3,r10,811374b8 <__reset+0xfb1174b8>
811374ec:	50c00326 	beq	r10,r3,811374fc <__ledf2+0xe4>
811374f0:	50c0042e 	bgeu	r10,r3,81137504 <__ledf2+0xec>
811374f4:	283fe81e 	bne	r5,zero,81137498 <__reset+0xfb117498>
811374f8:	003ff806 	br	811374dc <__reset+0xfb1174dc>
811374fc:	313fee36 	bltu	r6,r4,811374b8 <__reset+0xfb1174b8>
81137500:	21bffc36 	bltu	r4,r6,811374f4 <__reset+0xfb1174f4>
81137504:	0005883a 	mov	r2,zero
81137508:	f800283a 	ret

8113750c <__floatunsidf>:
8113750c:	defffe04 	addi	sp,sp,-8
81137510:	de00012e 	bgeu	sp,et,81137518 <__floatunsidf+0xc>
81137514:	003b68fa 	trap	3
81137518:	dc000015 	stw	r16,0(sp)
8113751c:	dfc00115 	stw	ra,4(sp)
81137520:	2021883a 	mov	r16,r4
81137524:	20002226 	beq	r4,zero,811375b0 <__floatunsidf+0xa4>
81137528:	11227d40 	call	811227d4 <__clzsi2>
8113752c:	01010784 	movi	r4,1054
81137530:	2089c83a 	sub	r4,r4,r2
81137534:	01810cc4 	movi	r6,1075
81137538:	310dc83a 	sub	r6,r6,r4
8113753c:	00c007c4 	movi	r3,31
81137540:	1980120e 	bge	r3,r6,8113758c <__floatunsidf+0x80>
81137544:	00c104c4 	movi	r3,1043
81137548:	1907c83a 	sub	r3,r3,r4
8113754c:	80ca983a 	sll	r5,r16,r3
81137550:	00800434 	movhi	r2,16
81137554:	10bfffc4 	addi	r2,r2,-1
81137558:	2101ffcc 	andi	r4,r4,2047
8113755c:	0021883a 	mov	r16,zero
81137560:	288a703a 	and	r5,r5,r2
81137564:	2008953a 	slli	r4,r4,20
81137568:	00c00434 	movhi	r3,16
8113756c:	18ffffc4 	addi	r3,r3,-1
81137570:	28c6703a 	and	r3,r5,r3
81137574:	8005883a 	mov	r2,r16
81137578:	1906b03a 	or	r3,r3,r4
8113757c:	dfc00117 	ldw	ra,4(sp)
81137580:	dc000017 	ldw	r16,0(sp)
81137584:	dec00204 	addi	sp,sp,8
81137588:	f800283a 	ret
8113758c:	00c002c4 	movi	r3,11
81137590:	188bc83a 	sub	r5,r3,r2
81137594:	814ad83a 	srl	r5,r16,r5
81137598:	00c00434 	movhi	r3,16
8113759c:	18ffffc4 	addi	r3,r3,-1
811375a0:	81a0983a 	sll	r16,r16,r6
811375a4:	2101ffcc 	andi	r4,r4,2047
811375a8:	28ca703a 	and	r5,r5,r3
811375ac:	003fed06 	br	81137564 <__reset+0xfb117564>
811375b0:	0009883a 	mov	r4,zero
811375b4:	000b883a 	mov	r5,zero
811375b8:	003fea06 	br	81137564 <__reset+0xfb117564>

811375bc <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
811375bc:	defffb04 	addi	sp,sp,-20
811375c0:	de00012e 	bgeu	sp,et,811375c8 <alt_busy_sleep+0xc>
811375c4:	003b68fa 	trap	3
811375c8:	df000415 	stw	fp,16(sp)
811375cc:	df000404 	addi	fp,sp,16
811375d0:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
811375d4:	008000c4 	movi	r2,3
811375d8:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
811375dc:	e0fffd17 	ldw	r3,-12(fp)
811375e0:	008003f4 	movhi	r2,15
811375e4:	10909004 	addi	r2,r2,16960
811375e8:	1887383a 	mul	r3,r3,r2
811375ec:	00817db4 	movhi	r2,1526
811375f0:	10b84004 	addi	r2,r2,-7936
811375f4:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
811375f8:	00a00034 	movhi	r2,32768
811375fc:	10bfffc4 	addi	r2,r2,-1
81137600:	10c5203a 	divu	r2,r2,r3
81137604:	e0ffff17 	ldw	r3,-4(fp)
81137608:	1885203a 	divu	r2,r3,r2
8113760c:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81137610:	e0bffe17 	ldw	r2,-8(fp)
81137614:	10002526 	beq	r2,zero,811376ac <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81137618:	e03ffc15 	stw	zero,-16(fp)
8113761c:	00001406 	br	81137670 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81137620:	00a00034 	movhi	r2,32768
81137624:	10bfffc4 	addi	r2,r2,-1
81137628:	10bfffc4 	addi	r2,r2,-1
8113762c:	103ffe1e 	bne	r2,zero,81137628 <__reset+0xfb117628>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81137630:	e0fffd17 	ldw	r3,-12(fp)
81137634:	008003f4 	movhi	r2,15
81137638:	10909004 	addi	r2,r2,16960
8113763c:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81137640:	00817db4 	movhi	r2,1526
81137644:	10b84004 	addi	r2,r2,-7936
81137648:	10c7203a 	divu	r3,r2,r3
8113764c:	00a00034 	movhi	r2,32768
81137650:	10bfffc4 	addi	r2,r2,-1
81137654:	10c5203a 	divu	r2,r2,r3
81137658:	e0ffff17 	ldw	r3,-4(fp)
8113765c:	1885c83a 	sub	r2,r3,r2
81137660:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81137664:	e0bffc17 	ldw	r2,-16(fp)
81137668:	10800044 	addi	r2,r2,1
8113766c:	e0bffc15 	stw	r2,-16(fp)
81137670:	e0fffc17 	ldw	r3,-16(fp)
81137674:	e0bffe17 	ldw	r2,-8(fp)
81137678:	18bfe916 	blt	r3,r2,81137620 <__reset+0xfb117620>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8113767c:	e0fffd17 	ldw	r3,-12(fp)
81137680:	008003f4 	movhi	r2,15
81137684:	10909004 	addi	r2,r2,16960
81137688:	1887383a 	mul	r3,r3,r2
8113768c:	00817db4 	movhi	r2,1526
81137690:	10b84004 	addi	r2,r2,-7936
81137694:	10c7203a 	divu	r3,r2,r3
81137698:	e0bfff17 	ldw	r2,-4(fp)
8113769c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811376a0:	10bfffc4 	addi	r2,r2,-1
811376a4:	103ffe1e 	bne	r2,zero,811376a0 <__reset+0xfb1176a0>
811376a8:	00000b06 	br	811376d8 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
811376ac:	e0fffd17 	ldw	r3,-12(fp)
811376b0:	008003f4 	movhi	r2,15
811376b4:	10909004 	addi	r2,r2,16960
811376b8:	1887383a 	mul	r3,r3,r2
811376bc:	00817db4 	movhi	r2,1526
811376c0:	10b84004 	addi	r2,r2,-7936
811376c4:	10c7203a 	divu	r3,r2,r3
811376c8:	e0bfff17 	ldw	r2,-4(fp)
811376cc:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811376d0:	10bfffc4 	addi	r2,r2,-1
811376d4:	00bffe16 	blt	zero,r2,811376d0 <__reset+0xfb1176d0>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
811376d8:	0005883a 	mov	r2,zero
}
811376dc:	e037883a 	mov	sp,fp
811376e0:	df000017 	ldw	fp,0(sp)
811376e4:	dec00104 	addi	sp,sp,4
811376e8:	f800283a 	ret

811376ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811376ec:	defffe04 	addi	sp,sp,-8
811376f0:	de00012e 	bgeu	sp,et,811376f8 <alt_get_errno+0xc>
811376f4:	003b68fa 	trap	3
811376f8:	dfc00115 	stw	ra,4(sp)
811376fc:	df000015 	stw	fp,0(sp)
81137700:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137704:	d0a01017 	ldw	r2,-32704(gp)
81137708:	10000326 	beq	r2,zero,81137718 <alt_get_errno+0x2c>
8113770c:	d0a01017 	ldw	r2,-32704(gp)
81137710:	103ee83a 	callr	r2
81137714:	00000106 	br	8113771c <alt_get_errno+0x30>
81137718:	d0a07804 	addi	r2,gp,-32288
}
8113771c:	e037883a 	mov	sp,fp
81137720:	dfc00117 	ldw	ra,4(sp)
81137724:	df000017 	ldw	fp,0(sp)
81137728:	dec00204 	addi	sp,sp,8
8113772c:	f800283a 	ret

81137730 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81137730:	defffb04 	addi	sp,sp,-20
81137734:	de00012e 	bgeu	sp,et,8113773c <close+0xc>
81137738:	003b68fa 	trap	3
8113773c:	dfc00415 	stw	ra,16(sp)
81137740:	df000315 	stw	fp,12(sp)
81137744:	df000304 	addi	fp,sp,12
81137748:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
8113774c:	e0bfff17 	ldw	r2,-4(fp)
81137750:	10000616 	blt	r2,zero,8113776c <close+0x3c>
81137754:	e0bfff17 	ldw	r2,-4(fp)
81137758:	10c00324 	muli	r3,r2,12
8113775c:	00a04574 	movhi	r2,33045
81137760:	108bfb04 	addi	r2,r2,12268
81137764:	1885883a 	add	r2,r3,r2
81137768:	00000106 	br	81137770 <close+0x40>
8113776c:	0005883a 	mov	r2,zero
81137770:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81137774:	e0bffd17 	ldw	r2,-12(fp)
81137778:	10001926 	beq	r2,zero,811377e0 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
8113777c:	e0bffd17 	ldw	r2,-12(fp)
81137780:	10800017 	ldw	r2,0(r2)
81137784:	10800417 	ldw	r2,16(r2)
81137788:	10000626 	beq	r2,zero,811377a4 <close+0x74>
8113778c:	e0bffd17 	ldw	r2,-12(fp)
81137790:	10800017 	ldw	r2,0(r2)
81137794:	10800417 	ldw	r2,16(r2)
81137798:	e13ffd17 	ldw	r4,-12(fp)
8113779c:	103ee83a 	callr	r2
811377a0:	00000106 	br	811377a8 <close+0x78>
811377a4:	0005883a 	mov	r2,zero
811377a8:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
811377ac:	e13fff17 	ldw	r4,-4(fp)
811377b0:	1138d140 	call	81138d14 <alt_release_fd>
    if (rval < 0)
811377b4:	e0bffe17 	ldw	r2,-8(fp)
811377b8:	1000070e 	bge	r2,zero,811377d8 <close+0xa8>
    {
      ALT_ERRNO = -rval;
811377bc:	11376ec0 	call	811376ec <alt_get_errno>
811377c0:	1007883a 	mov	r3,r2
811377c4:	e0bffe17 	ldw	r2,-8(fp)
811377c8:	0085c83a 	sub	r2,zero,r2
811377cc:	18800015 	stw	r2,0(r3)
      return -1;
811377d0:	00bfffc4 	movi	r2,-1
811377d4:	00000706 	br	811377f4 <close+0xc4>
    }
    return 0;
811377d8:	0005883a 	mov	r2,zero
811377dc:	00000506 	br	811377f4 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
811377e0:	11376ec0 	call	811376ec <alt_get_errno>
811377e4:	1007883a 	mov	r3,r2
811377e8:	00801444 	movi	r2,81
811377ec:	18800015 	stw	r2,0(r3)
    return -1;
811377f0:	00bfffc4 	movi	r2,-1
  }
}
811377f4:	e037883a 	mov	sp,fp
811377f8:	dfc00117 	ldw	ra,4(sp)
811377fc:	df000017 	ldw	fp,0(sp)
81137800:	dec00204 	addi	sp,sp,8
81137804:	f800283a 	ret

81137808 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81137808:	deffff04 	addi	sp,sp,-4
8113780c:	de00012e 	bgeu	sp,et,81137814 <alt_dcache_flush_all+0xc>
81137810:	003b68fa 	trap	3
81137814:	df000015 	stw	fp,0(sp)
81137818:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
8113781c:	0001883a 	nop
81137820:	e037883a 	mov	sp,fp
81137824:	df000017 	ldw	fp,0(sp)
81137828:	dec00104 	addi	sp,sp,4
8113782c:	f800283a 	ret

81137830 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81137830:	defffc04 	addi	sp,sp,-16
81137834:	de00012e 	bgeu	sp,et,8113783c <alt_dev_null_write+0xc>
81137838:	003b68fa 	trap	3
8113783c:	df000315 	stw	fp,12(sp)
81137840:	df000304 	addi	fp,sp,12
81137844:	e13ffd15 	stw	r4,-12(fp)
81137848:	e17ffe15 	stw	r5,-8(fp)
8113784c:	e1bfff15 	stw	r6,-4(fp)
  return len;
81137850:	e0bfff17 	ldw	r2,-4(fp)
}
81137854:	e037883a 	mov	sp,fp
81137858:	df000017 	ldw	fp,0(sp)
8113785c:	dec00104 	addi	sp,sp,4
81137860:	f800283a 	ret

81137864 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137864:	defffe04 	addi	sp,sp,-8
81137868:	de00012e 	bgeu	sp,et,81137870 <alt_get_errno+0xc>
8113786c:	003b68fa 	trap	3
81137870:	dfc00115 	stw	ra,4(sp)
81137874:	df000015 	stw	fp,0(sp)
81137878:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113787c:	d0a01017 	ldw	r2,-32704(gp)
81137880:	10000326 	beq	r2,zero,81137890 <alt_get_errno+0x2c>
81137884:	d0a01017 	ldw	r2,-32704(gp)
81137888:	103ee83a 	callr	r2
8113788c:	00000106 	br	81137894 <alt_get_errno+0x30>
81137890:	d0a07804 	addi	r2,gp,-32288
}
81137894:	e037883a 	mov	sp,fp
81137898:	dfc00117 	ldw	ra,4(sp)
8113789c:	df000017 	ldw	fp,0(sp)
811378a0:	dec00204 	addi	sp,sp,8
811378a4:	f800283a 	ret

811378a8 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
811378a8:	defffb04 	addi	sp,sp,-20
811378ac:	de00012e 	bgeu	sp,et,811378b4 <fstat+0xc>
811378b0:	003b68fa 	trap	3
811378b4:	dfc00415 	stw	ra,16(sp)
811378b8:	df000315 	stw	fp,12(sp)
811378bc:	df000304 	addi	fp,sp,12
811378c0:	e13ffe15 	stw	r4,-8(fp)
811378c4:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811378c8:	e0bffe17 	ldw	r2,-8(fp)
811378cc:	10000616 	blt	r2,zero,811378e8 <fstat+0x40>
811378d0:	e0bffe17 	ldw	r2,-8(fp)
811378d4:	10c00324 	muli	r3,r2,12
811378d8:	00a04574 	movhi	r2,33045
811378dc:	108bfb04 	addi	r2,r2,12268
811378e0:	1885883a 	add	r2,r3,r2
811378e4:	00000106 	br	811378ec <fstat+0x44>
811378e8:	0005883a 	mov	r2,zero
811378ec:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811378f0:	e0bffd17 	ldw	r2,-12(fp)
811378f4:	10001026 	beq	r2,zero,81137938 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
811378f8:	e0bffd17 	ldw	r2,-12(fp)
811378fc:	10800017 	ldw	r2,0(r2)
81137900:	10800817 	ldw	r2,32(r2)
81137904:	10000726 	beq	r2,zero,81137924 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81137908:	e0bffd17 	ldw	r2,-12(fp)
8113790c:	10800017 	ldw	r2,0(r2)
81137910:	10800817 	ldw	r2,32(r2)
81137914:	e17fff17 	ldw	r5,-4(fp)
81137918:	e13ffd17 	ldw	r4,-12(fp)
8113791c:	103ee83a 	callr	r2
81137920:	00000a06 	br	8113794c <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81137924:	e0bfff17 	ldw	r2,-4(fp)
81137928:	00c80004 	movi	r3,8192
8113792c:	10c00115 	stw	r3,4(r2)
      return 0;
81137930:	0005883a 	mov	r2,zero
81137934:	00000506 	br	8113794c <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81137938:	11378640 	call	81137864 <alt_get_errno>
8113793c:	1007883a 	mov	r3,r2
81137940:	00801444 	movi	r2,81
81137944:	18800015 	stw	r2,0(r3)
    return -1;
81137948:	00bfffc4 	movi	r2,-1
  }
}
8113794c:	e037883a 	mov	sp,fp
81137950:	dfc00117 	ldw	ra,4(sp)
81137954:	df000017 	ldw	fp,0(sp)
81137958:	dec00204 	addi	sp,sp,8
8113795c:	f800283a 	ret

81137960 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81137960:	defff004 	addi	sp,sp,-64
81137964:	de00012e 	bgeu	sp,et,8113796c <alt_irq_register+0xc>
81137968:	003b68fa 	trap	3
8113796c:	df000f15 	stw	fp,60(sp)
81137970:	df000f04 	addi	fp,sp,60
81137974:	e13ffd15 	stw	r4,-12(fp)
81137978:	e17ffe15 	stw	r5,-8(fp)
8113797c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81137980:	00bffa84 	movi	r2,-22
81137984:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81137988:	e0bffd17 	ldw	r2,-12(fp)
8113798c:	10800828 	cmpgeui	r2,r2,32
81137990:	1000501e 	bne	r2,zero,81137ad4 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137994:	0005303a 	rdctl	r2,status
81137998:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113799c:	e0fff617 	ldw	r3,-40(fp)
811379a0:	00bfff84 	movi	r2,-2
811379a4:	1884703a 	and	r2,r3,r2
811379a8:	1001703a 	wrctl	status,r2
  
  return context;
811379ac:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
811379b0:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
811379b4:	00a045f4 	movhi	r2,33047
811379b8:	10b9a104 	addi	r2,r2,-6524
811379bc:	e0fffd17 	ldw	r3,-12(fp)
811379c0:	180690fa 	slli	r3,r3,3
811379c4:	10c5883a 	add	r2,r2,r3
811379c8:	e0ffff17 	ldw	r3,-4(fp)
811379cc:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
811379d0:	00a045f4 	movhi	r2,33047
811379d4:	10b9a104 	addi	r2,r2,-6524
811379d8:	e0fffd17 	ldw	r3,-12(fp)
811379dc:	180690fa 	slli	r3,r3,3
811379e0:	10c5883a 	add	r2,r2,r3
811379e4:	10800104 	addi	r2,r2,4
811379e8:	e0fffe17 	ldw	r3,-8(fp)
811379ec:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811379f0:	e0bfff17 	ldw	r2,-4(fp)
811379f4:	10001926 	beq	r2,zero,81137a5c <alt_irq_register+0xfc>
811379f8:	e0bffd17 	ldw	r2,-12(fp)
811379fc:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137a00:	0005303a 	rdctl	r2,status
81137a04:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137a08:	e0fff717 	ldw	r3,-36(fp)
81137a0c:	00bfff84 	movi	r2,-2
81137a10:	1884703a 	and	r2,r3,r2
81137a14:	1001703a 	wrctl	status,r2
  
  return context;
81137a18:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81137a1c:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81137a20:	00c00044 	movi	r3,1
81137a24:	e0bff217 	ldw	r2,-56(fp)
81137a28:	1884983a 	sll	r2,r3,r2
81137a2c:	1007883a 	mov	r3,r2
81137a30:	d0a08017 	ldw	r2,-32256(gp)
81137a34:	1884b03a 	or	r2,r3,r2
81137a38:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81137a3c:	d0a08017 	ldw	r2,-32256(gp)
81137a40:	100170fa 	wrctl	ienable,r2
81137a44:	e0bff817 	ldw	r2,-32(fp)
81137a48:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137a4c:	e0bff917 	ldw	r2,-28(fp)
81137a50:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81137a54:	0005883a 	mov	r2,zero
81137a58:	00001906 	br	81137ac0 <alt_irq_register+0x160>
81137a5c:	e0bffd17 	ldw	r2,-12(fp)
81137a60:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137a64:	0005303a 	rdctl	r2,status
81137a68:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137a6c:	e0fffa17 	ldw	r3,-24(fp)
81137a70:	00bfff84 	movi	r2,-2
81137a74:	1884703a 	and	r2,r3,r2
81137a78:	1001703a 	wrctl	status,r2
  
  return context;
81137a7c:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81137a80:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81137a84:	00c00044 	movi	r3,1
81137a88:	e0bff417 	ldw	r2,-48(fp)
81137a8c:	1884983a 	sll	r2,r3,r2
81137a90:	0084303a 	nor	r2,zero,r2
81137a94:	1007883a 	mov	r3,r2
81137a98:	d0a08017 	ldw	r2,-32256(gp)
81137a9c:	1884703a 	and	r2,r3,r2
81137aa0:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81137aa4:	d0a08017 	ldw	r2,-32256(gp)
81137aa8:	100170fa 	wrctl	ienable,r2
81137aac:	e0bffb17 	ldw	r2,-20(fp)
81137ab0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ab4:	e0bffc17 	ldw	r2,-16(fp)
81137ab8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81137abc:	0005883a 	mov	r2,zero
81137ac0:	e0bff115 	stw	r2,-60(fp)
81137ac4:	e0bff317 	ldw	r2,-52(fp)
81137ac8:	e0bff515 	stw	r2,-44(fp)
81137acc:	e0bff517 	ldw	r2,-44(fp)
81137ad0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81137ad4:	e0bff117 	ldw	r2,-60(fp)
}
81137ad8:	e037883a 	mov	sp,fp
81137adc:	df000017 	ldw	fp,0(sp)
81137ae0:	dec00104 	addi	sp,sp,4
81137ae4:	f800283a 	ret

81137ae8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137ae8:	defffe04 	addi	sp,sp,-8
81137aec:	de00012e 	bgeu	sp,et,81137af4 <alt_get_errno+0xc>
81137af0:	003b68fa 	trap	3
81137af4:	dfc00115 	stw	ra,4(sp)
81137af8:	df000015 	stw	fp,0(sp)
81137afc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137b00:	d0a01017 	ldw	r2,-32704(gp)
81137b04:	10000326 	beq	r2,zero,81137b14 <alt_get_errno+0x2c>
81137b08:	d0a01017 	ldw	r2,-32704(gp)
81137b0c:	103ee83a 	callr	r2
81137b10:	00000106 	br	81137b18 <alt_get_errno+0x30>
81137b14:	d0a07804 	addi	r2,gp,-32288
}
81137b18:	e037883a 	mov	sp,fp
81137b1c:	dfc00117 	ldw	ra,4(sp)
81137b20:	df000017 	ldw	fp,0(sp)
81137b24:	dec00204 	addi	sp,sp,8
81137b28:	f800283a 	ret

81137b2c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81137b2c:	deffed04 	addi	sp,sp,-76
81137b30:	de00012e 	bgeu	sp,et,81137b38 <isatty+0xc>
81137b34:	003b68fa 	trap	3
81137b38:	dfc01215 	stw	ra,72(sp)
81137b3c:	df001115 	stw	fp,68(sp)
81137b40:	df001104 	addi	fp,sp,68
81137b44:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137b48:	e0bfff17 	ldw	r2,-4(fp)
81137b4c:	10000616 	blt	r2,zero,81137b68 <isatty+0x3c>
81137b50:	e0bfff17 	ldw	r2,-4(fp)
81137b54:	10c00324 	muli	r3,r2,12
81137b58:	00a04574 	movhi	r2,33045
81137b5c:	108bfb04 	addi	r2,r2,12268
81137b60:	1885883a 	add	r2,r3,r2
81137b64:	00000106 	br	81137b6c <isatty+0x40>
81137b68:	0005883a 	mov	r2,zero
81137b6c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81137b70:	e0bfef17 	ldw	r2,-68(fp)
81137b74:	10000e26 	beq	r2,zero,81137bb0 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81137b78:	e0bfef17 	ldw	r2,-68(fp)
81137b7c:	10800017 	ldw	r2,0(r2)
81137b80:	10800817 	ldw	r2,32(r2)
81137b84:	1000021e 	bne	r2,zero,81137b90 <isatty+0x64>
    {
      return 1;
81137b88:	00800044 	movi	r2,1
81137b8c:	00000d06 	br	81137bc4 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81137b90:	e0bff004 	addi	r2,fp,-64
81137b94:	100b883a 	mov	r5,r2
81137b98:	e13fff17 	ldw	r4,-4(fp)
81137b9c:	11378a80 	call	811378a8 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81137ba0:	e0bff117 	ldw	r2,-60(fp)
81137ba4:	10880020 	cmpeqi	r2,r2,8192
81137ba8:	10803fcc 	andi	r2,r2,255
81137bac:	00000506 	br	81137bc4 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81137bb0:	1137ae80 	call	81137ae8 <alt_get_errno>
81137bb4:	1007883a 	mov	r3,r2
81137bb8:	00801444 	movi	r2,81
81137bbc:	18800015 	stw	r2,0(r3)
    return 0;
81137bc0:	0005883a 	mov	r2,zero
  }
}
81137bc4:	e037883a 	mov	sp,fp
81137bc8:	dfc00117 	ldw	ra,4(sp)
81137bcc:	df000017 	ldw	fp,0(sp)
81137bd0:	dec00204 	addi	sp,sp,8
81137bd4:	f800283a 	ret

81137bd8 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81137bd8:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81137bdc:	318c2404 	addi	r6,r6,12432

81137be0 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81137be0:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
81137be4:	01c00826 	beq	zero,r7,81137c08 <end_tx>

81137be8 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81137be8:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81137bec:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81137bf0:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
81137bf4:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81137bf8:	283ffb26 	beq	r5,zero,81137be8 <__reset+0xfb117be8>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81137bfc:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81137c00:	21000044 	addi	r4,r4,1
	br tx_next_char
81137c04:	003ff606 	br	81137be0 <__reset+0xfb117be0>

81137c08 <end_tx>:
end_tx:	
        ret
81137c08:	f800283a 	ret

81137c0c <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81137c0c:	defffd04 	addi	sp,sp,-12
81137c10:	de00012e 	bgeu	sp,et,81137c18 <alt_log_txchar+0xc>
81137c14:	003b68fa 	trap	3
81137c18:	df000215 	stw	fp,8(sp)
81137c1c:	df000204 	addi	fp,sp,8
81137c20:	e13ffe15 	stw	r4,-8(fp)
81137c24:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81137c28:	0001883a 	nop
81137c2c:	e0bfff17 	ldw	r2,-4(fp)
81137c30:	10800104 	addi	r2,r2,4
81137c34:	10800037 	ldwio	r2,0(r2)
81137c38:	10bfffec 	andhi	r2,r2,65535
81137c3c:	103ffb26 	beq	r2,zero,81137c2c <__reset+0xfb117c2c>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81137c40:	e0bfff17 	ldw	r2,-4(fp)
81137c44:	e0fffe17 	ldw	r3,-8(fp)
81137c48:	10c00035 	stwio	r3,0(r2)
}
81137c4c:	0001883a 	nop
81137c50:	e037883a 	mov	sp,fp
81137c54:	df000017 	ldw	fp,0(sp)
81137c58:	dec00104 	addi	sp,sp,4
81137c5c:	f800283a 	ret

81137c60 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81137c60:	defffb04 	addi	sp,sp,-20
81137c64:	de00012e 	bgeu	sp,et,81137c6c <alt_log_repchar+0xc>
81137c68:	003b68fa 	trap	3
81137c6c:	dfc00415 	stw	ra,16(sp)
81137c70:	df000315 	stw	fp,12(sp)
81137c74:	df000304 	addi	fp,sp,12
81137c78:	2005883a 	mov	r2,r4
81137c7c:	e17ffe15 	stw	r5,-8(fp)
81137c80:	e1bfff15 	stw	r6,-4(fp)
81137c84:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81137c88:	00000506 	br	81137ca0 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81137c8c:	e0bffd07 	ldb	r2,-12(fp)
81137c90:	e0ffff17 	ldw	r3,-4(fp)
81137c94:	180b883a 	mov	r5,r3
81137c98:	1009883a 	mov	r4,r2
81137c9c:	1137c0c0 	call	81137c0c <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81137ca0:	e0bffe17 	ldw	r2,-8(fp)
81137ca4:	10ffffc4 	addi	r3,r2,-1
81137ca8:	e0fffe15 	stw	r3,-8(fp)
81137cac:	00bff716 	blt	zero,r2,81137c8c <__reset+0xfb117c8c>
    alt_log_txchar(c,(char*) base);
}
81137cb0:	0001883a 	nop
81137cb4:	e037883a 	mov	sp,fp
81137cb8:	dfc00117 	ldw	ra,4(sp)
81137cbc:	df000017 	ldw	fp,0(sp)
81137cc0:	dec00204 	addi	sp,sp,8
81137cc4:	f800283a 	ret

81137cc8 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81137cc8:	deffe904 	addi	sp,sp,-92
81137ccc:	de00012e 	bgeu	sp,et,81137cd4 <alt_log_private_printf+0xc>
81137cd0:	003b68fa 	trap	3
81137cd4:	dfc01615 	stw	ra,88(sp)
81137cd8:	df001515 	stw	fp,84(sp)
81137cdc:	dc001415 	stw	r16,80(sp)
81137ce0:	df001504 	addi	fp,sp,84
81137ce4:	e13ffc15 	stw	r4,-16(fp)
81137ce8:	e17ffd15 	stw	r5,-12(fp)
81137cec:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81137cf0:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
81137cf4:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81137cf8:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81137cfc:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81137d00:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
81137d04:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81137d08:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81137d0c:	e0bffc17 	ldw	r2,-16(fp)
81137d10:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
81137d14:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81137d18:	00014b06 	br	81138248 <alt_log_private_printf+0x580>
    {
    switch(state)
81137d1c:	e0bfec17 	ldw	r2,-80(fp)
81137d20:	10c00060 	cmpeqi	r3,r2,1
81137d24:	18001b1e 	bne	r3,zero,81137d94 <alt_log_private_printf+0xcc>
81137d28:	10c000a0 	cmpeqi	r3,r2,2
81137d2c:	18002d1e 	bne	r3,zero,81137de4 <alt_log_private_printf+0x11c>
81137d30:	10000126 	beq	r2,zero,81137d38 <alt_log_private_printf+0x70>
81137d34:	00014406 	br	81138248 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81137d38:	e0bffb07 	ldb	r2,-20(fp)
81137d3c:	10800958 	cmpnei	r2,r2,37
81137d40:	10000e1e 	bne	r2,zero,81137d7c <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81137d44:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81137d48:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81137d4c:	00800284 	movi	r2,10
81137d50:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81137d54:	00800044 	movi	r2,1
81137d58:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81137d5c:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81137d60:	00bfffc4 	movi	r2,-1
81137d64:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81137d68:	00bfffc4 	movi	r2,-1
81137d6c:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81137d70:	00800044 	movi	r2,1
81137d74:	e0bfec15 	stw	r2,-80(fp)
81137d78:	00013306 	br	81138248 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81137d7c:	e0bffb07 	ldb	r2,-20(fp)
81137d80:	e0fffd17 	ldw	r3,-12(fp)
81137d84:	180b883a 	mov	r5,r3
81137d88:	1009883a 	mov	r4,r2
81137d8c:	1137c0c0 	call	81137c0c <alt_log_txchar>
        }
        break;
81137d90:	00012d06 	br	81138248 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81137d94:	e0bffb07 	ldb	r2,-20(fp)
81137d98:	10800c18 	cmpnei	r2,r2,48
81137d9c:	1000051e 	bne	r2,zero,81137db4 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81137da0:	00800044 	movi	r2,1
81137da4:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81137da8:	00800084 	movi	r2,2
81137dac:	e0bfec15 	stw	r2,-80(fp)
81137db0:	00012506 	br	81138248 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81137db4:	e0bffb07 	ldb	r2,-20(fp)
81137db8:	10800958 	cmpnei	r2,r2,37
81137dbc:	1000071e 	bne	r2,zero,81137ddc <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81137dc0:	e0bffb07 	ldb	r2,-20(fp)
81137dc4:	e0fffd17 	ldw	r3,-12(fp)
81137dc8:	180b883a 	mov	r5,r3
81137dcc:	1009883a 	mov	r4,r2
81137dd0:	1137c0c0 	call	81137c0c <alt_log_txchar>
          state = pfState_chars;
81137dd4:	e03fec15 	stw	zero,-80(fp)
81137dd8:	00011b06 	br	81138248 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81137ddc:	00800084 	movi	r2,2
81137de0:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81137de4:	e0bffb07 	ldb	r2,-20(fp)
81137de8:	10800b98 	cmpnei	r2,r2,46
81137dec:	1000021e 	bne	r2,zero,81137df8 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81137df0:	e03ff015 	stw	zero,-64(fp)
81137df4:	00011306 	br	81138244 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81137df8:	e0bffb07 	ldb	r2,-20(fp)
81137dfc:	10800c10 	cmplti	r2,r2,48
81137e00:	10001a1e 	bne	r2,zero,81137e6c <alt_log_private_printf+0x1a4>
81137e04:	e0bffb07 	ldb	r2,-20(fp)
81137e08:	10800e88 	cmpgei	r2,r2,58
81137e0c:	1000171e 	bne	r2,zero,81137e6c <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81137e10:	e0bffb03 	ldbu	r2,-20(fp)
81137e14:	10bff404 	addi	r2,r2,-48
81137e18:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81137e1c:	e0bff017 	ldw	r2,-64(fp)
81137e20:	10000c0e 	bge	r2,zero,81137e54 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81137e24:	e0bfef17 	ldw	r2,-68(fp)
81137e28:	1000020e 	bge	r2,zero,81137e34 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81137e2c:	e03fef15 	stw	zero,-68(fp)
81137e30:	00000306 	br	81137e40 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81137e34:	e0bfef17 	ldw	r2,-68(fp)
81137e38:	108002a4 	muli	r2,r2,10
81137e3c:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81137e40:	e0bffb07 	ldb	r2,-20(fp)
81137e44:	e0ffef17 	ldw	r3,-68(fp)
81137e48:	1885883a 	add	r2,r3,r2
81137e4c:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81137e50:	0000fc06 	br	81138244 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81137e54:	e0bff017 	ldw	r2,-64(fp)
81137e58:	10c002a4 	muli	r3,r2,10
81137e5c:	e0bffb07 	ldb	r2,-20(fp)
81137e60:	1885883a 	add	r2,r3,r2
81137e64:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81137e68:	0000f606 	br	81138244 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81137e6c:	e0bffb07 	ldb	r2,-20(fp)
81137e70:	10801b18 	cmpnei	r2,r2,108
81137e74:	1000031e 	bne	r2,zero,81137e84 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81137e78:	00800044 	movi	r2,1
81137e7c:	e0bfee15 	stw	r2,-72(fp)
81137e80:	0000f006 	br	81138244 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81137e84:	e0bffb07 	ldb	r2,-20(fp)
81137e88:	10bfea04 	addi	r2,r2,-88
81137e8c:	10c00868 	cmpgeui	r3,r2,33
81137e90:	1800eb1e 	bne	r3,zero,81138240 <alt_log_private_printf+0x578>
81137e94:	100690ba 	slli	r3,r2,2
81137e98:	00a044f4 	movhi	r2,33043
81137e9c:	109fab04 	addi	r2,r2,32428
81137ea0:	1885883a 	add	r2,r3,r2
81137ea4:	10800017 	ldw	r2,0(r2)
81137ea8:	1000683a 	jmp	r2
81137eac:	8113816c 	andhi	r4,r16,19973
81137eb0:	81138240 	call	88113824 <__reset+0x20f3824>
81137eb4:	81138240 	call	88113824 <__reset+0x20f3824>
81137eb8:	81138240 	call	88113824 <__reset+0x20f3824>
81137ebc:	81138240 	call	88113824 <__reset+0x20f3824>
81137ec0:	81138240 	call	88113824 <__reset+0x20f3824>
81137ec4:	81138240 	call	88113824 <__reset+0x20f3824>
81137ec8:	81138240 	call	88113824 <__reset+0x20f3824>
81137ecc:	81138240 	call	88113824 <__reset+0x20f3824>
81137ed0:	81138240 	call	88113824 <__reset+0x20f3824>
81137ed4:	81138240 	call	88113824 <__reset+0x20f3824>
81137ed8:	81138184 	addi	r4,r16,19974
81137edc:	81137f30 	cmpltui	r4,r16,19964
81137ee0:	81138240 	call	88113824 <__reset+0x20f3824>
81137ee4:	81138240 	call	88113824 <__reset+0x20f3824>
81137ee8:	81138240 	call	88113824 <__reset+0x20f3824>
81137eec:	81138240 	call	88113824 <__reset+0x20f3824>
81137ef0:	81137f30 	cmpltui	r4,r16,19964
81137ef4:	81138240 	call	88113824 <__reset+0x20f3824>
81137ef8:	81138240 	call	88113824 <__reset+0x20f3824>
81137efc:	81138240 	call	88113824 <__reset+0x20f3824>
81137f00:	81138240 	call	88113824 <__reset+0x20f3824>
81137f04:	81138240 	call	88113824 <__reset+0x20f3824>
81137f08:	8113814c 	andi	r4,r16,19973
81137f0c:	81138240 	call	88113824 <__reset+0x20f3824>
81137f10:	81138240 	call	88113824 <__reset+0x20f3824>
81137f14:	81138240 	call	88113824 <__reset+0x20f3824>
81137f18:	811381c0 	call	8811381c <__reset+0x20f381c>
81137f1c:	81138240 	call	88113824 <__reset+0x20f3824>
81137f20:	81138144 	addi	r4,r16,19973
81137f24:	81138240 	call	88113824 <__reset+0x20f3824>
81137f28:	81138240 	call	88113824 <__reset+0x20f3824>
81137f2c:	8113815c 	xori	r4,r16,19973
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81137f30:	e0bfee17 	ldw	r2,-72(fp)
81137f34:	10000e26 	beq	r2,zero,81137f70 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81137f38:	e0bff217 	ldw	r2,-56(fp)
81137f3c:	10000626 	beq	r2,zero,81137f58 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81137f40:	e0bffe17 	ldw	r2,-8(fp)
81137f44:	10c00104 	addi	r3,r2,4
81137f48:	e0fffe15 	stw	r3,-8(fp)
81137f4c:	10800017 	ldw	r2,0(r2)
81137f50:	e0bff415 	stw	r2,-48(fp)
81137f54:	00001306 	br	81137fa4 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81137f58:	e0bffe17 	ldw	r2,-8(fp)
81137f5c:	10c00104 	addi	r3,r2,4
81137f60:	e0fffe15 	stw	r3,-8(fp)
81137f64:	10800017 	ldw	r2,0(r2)
81137f68:	e0bff415 	stw	r2,-48(fp)
81137f6c:	00000d06 	br	81137fa4 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81137f70:	e0bff217 	ldw	r2,-56(fp)
81137f74:	10000626 	beq	r2,zero,81137f90 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81137f78:	e0bffe17 	ldw	r2,-8(fp)
81137f7c:	10c00104 	addi	r3,r2,4
81137f80:	e0fffe15 	stw	r3,-8(fp)
81137f84:	10800017 	ldw	r2,0(r2)
81137f88:	e0bff415 	stw	r2,-48(fp)
81137f8c:	00000506 	br	81137fa4 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81137f90:	e0bffe17 	ldw	r2,-8(fp)
81137f94:	10c00104 	addi	r3,r2,4
81137f98:	e0fffe15 	stw	r3,-8(fp)
81137f9c:	10800017 	ldw	r2,0(r2)
81137fa0:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81137fa4:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81137fa8:	e0bff217 	ldw	r2,-56(fp)
81137fac:	10000726 	beq	r2,zero,81137fcc <alt_log_private_printf+0x304>
81137fb0:	e0bff417 	ldw	r2,-48(fp)
81137fb4:	1000050e 	bge	r2,zero,81137fcc <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81137fb8:	e0bff417 	ldw	r2,-48(fp)
81137fbc:	0085c83a 	sub	r2,zero,r2
81137fc0:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81137fc4:	00800044 	movi	r2,1
81137fc8:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81137fcc:	e0bff417 	ldw	r2,-48(fp)
81137fd0:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81137fd4:	00800044 	movi	r2,1
81137fd8:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81137fdc:	00800044 	movi	r2,1
81137fe0:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81137fe4:	00000706 	br	81138004 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81137fe8:	e0bff817 	ldw	r2,-32(fp)
81137fec:	10800044 	addi	r2,r2,1
81137ff0:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81137ff4:	e0bff117 	ldw	r2,-60(fp)
81137ff8:	e0fff517 	ldw	r3,-44(fp)
81137ffc:	1885383a 	mul	r2,r3,r2
81138000:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81138004:	e0bff117 	ldw	r2,-60(fp)
81138008:	e0fff617 	ldw	r3,-40(fp)
8113800c:	1885203a 	divu	r2,r3,r2
81138010:	e0bff615 	stw	r2,-40(fp)
81138014:	e0bff617 	ldw	r2,-40(fp)
81138018:	103ff31e 	bne	r2,zero,81137fe8 <__reset+0xfb117fe8>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
8113801c:	e0ffef17 	ldw	r3,-68(fp)
81138020:	e0bff817 	ldw	r2,-32(fp)
81138024:	1885c83a 	sub	r2,r3,r2
81138028:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
8113802c:	e0bfed17 	ldw	r2,-76(fp)
81138030:	10000e26 	beq	r2,zero,8113806c <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81138034:	e0bff717 	ldw	r2,-36(fp)
81138038:	10000726 	beq	r2,zero,81138058 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
8113803c:	e0bffd17 	ldw	r2,-12(fp)
81138040:	100b883a 	mov	r5,r2
81138044:	01000b44 	movi	r4,45
81138048:	1137c0c0 	call	81137c0c <alt_log_txchar>
                    fmtBeforeDecimal--;
8113804c:	e0bfef17 	ldw	r2,-68(fp)
81138050:	10bfffc4 	addi	r2,r2,-1
81138054:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81138058:	e1bffd17 	ldw	r6,-12(fp)
8113805c:	e17fef17 	ldw	r5,-68(fp)
81138060:	01000c04 	movi	r4,48
81138064:	1137c600 	call	81137c60 <alt_log_repchar>
81138068:	00003206 	br	81138134 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
8113806c:	e0bff717 	ldw	r2,-36(fp)
81138070:	10000326 	beq	r2,zero,81138080 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81138074:	e0bfef17 	ldw	r2,-68(fp)
81138078:	10bfffc4 	addi	r2,r2,-1
8113807c:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81138080:	e1bffd17 	ldw	r6,-12(fp)
81138084:	e17fef17 	ldw	r5,-68(fp)
81138088:	01000804 	movi	r4,32
8113808c:	1137c600 	call	81137c60 <alt_log_repchar>
                    if(sign)
81138090:	e0bff717 	ldw	r2,-36(fp)
81138094:	10002726 	beq	r2,zero,81138134 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81138098:	e0bffd17 	ldw	r2,-12(fp)
8113809c:	100b883a 	mov	r5,r2
811380a0:	01000b44 	movi	r4,45
811380a4:	1137c0c0 	call	81137c0c <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
811380a8:	00002206 	br	81138134 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
811380ac:	e0fff417 	ldw	r3,-48(fp)
811380b0:	e0bff517 	ldw	r2,-44(fp)
811380b4:	1885203a 	divu	r2,r3,r2
811380b8:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
811380bc:	e0bff903 	ldbu	r2,-28(fp)
811380c0:	10800c04 	addi	r2,r2,48
811380c4:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
811380c8:	e0bff903 	ldbu	r2,-28(fp)
811380cc:	10800eb0 	cmpltui	r2,r2,58
811380d0:	1000081e 	bne	r2,zero,811380f4 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
811380d4:	e0bff317 	ldw	r2,-52(fp)
811380d8:	10000226 	beq	r2,zero,811380e4 <alt_log_private_printf+0x41c>
811380dc:	008001c4 	movi	r2,7
811380e0:	00000106 	br	811380e8 <alt_log_private_printf+0x420>
811380e4:	008009c4 	movi	r2,39
811380e8:	e0fff903 	ldbu	r3,-28(fp)
811380ec:	10c5883a 	add	r2,r2,r3
811380f0:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
811380f4:	e0bff903 	ldbu	r2,-28(fp)
811380f8:	e0fffd17 	ldw	r3,-12(fp)
811380fc:	180b883a 	mov	r5,r3
81138100:	1009883a 	mov	r4,r2
81138104:	1137c0c0 	call	81137c0c <alt_log_txchar>

                  v = v % p;
81138108:	e0bff417 	ldw	r2,-48(fp)
8113810c:	e0fff517 	ldw	r3,-44(fp)
81138110:	10c9203a 	divu	r4,r2,r3
81138114:	e0fff517 	ldw	r3,-44(fp)
81138118:	20c7383a 	mul	r3,r4,r3
8113811c:	10c5c83a 	sub	r2,r2,r3
81138120:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81138124:	e0bff117 	ldw	r2,-60(fp)
81138128:	e0fff517 	ldw	r3,-44(fp)
8113812c:	1885203a 	divu	r2,r3,r2
81138130:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81138134:	e0bff517 	ldw	r2,-44(fp)
81138138:	103fdc1e 	bne	r2,zero,811380ac <__reset+0xfb1180ac>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
8113813c:	e03fec15 	stw	zero,-80(fp)
              break;
81138140:	00003f06 	br	81138240 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81138144:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81138148:	003f7906 	br	81137f30 <__reset+0xfb117f30>
            case 'o':
              fmtSigned = 0;
8113814c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81138150:	00800204 	movi	r2,8
81138154:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138158:	003f7506 	br	81137f30 <__reset+0xfb117f30>
            case 'x':
              fmtSigned = 0;
8113815c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138160:	00800404 	movi	r2,16
81138164:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138168:	003f7106 	br	81137f30 <__reset+0xfb117f30>
            case 'X':
              fmtSigned = 0;
8113816c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138170:	00800404 	movi	r2,16
81138174:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81138178:	00800044 	movi	r2,1
8113817c:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81138180:	003f6b06 	br	81137f30 <__reset+0xfb117f30>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81138184:	e0bfef17 	ldw	r2,-68(fp)
81138188:	10bfffc4 	addi	r2,r2,-1
8113818c:	e1bffd17 	ldw	r6,-12(fp)
81138190:	100b883a 	mov	r5,r2
81138194:	01000804 	movi	r4,32
81138198:	1137c600 	call	81137c60 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
8113819c:	e0bffe17 	ldw	r2,-8(fp)
811381a0:	10c00104 	addi	r3,r2,4
811381a4:	e0fffe15 	stw	r3,-8(fp)
811381a8:	10800017 	ldw	r2,0(r2)
811381ac:	e0fffd17 	ldw	r3,-12(fp)
811381b0:	180b883a 	mov	r5,r3
811381b4:	1009883a 	mov	r4,r2
811381b8:	1137c0c0 	call	81137c0c <alt_log_txchar>
              break;
811381bc:	00002006 	br	81138240 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
811381c0:	e0bffe17 	ldw	r2,-8(fp)
811381c4:	10c00104 	addi	r3,r2,4
811381c8:	e0fffe15 	stw	r3,-8(fp)
811381cc:	10800017 	ldw	r2,0(r2)
811381d0:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
811381d4:	e43fef17 	ldw	r16,-68(fp)
811381d8:	e13ffa17 	ldw	r4,-24(fp)
811381dc:	11244bc0 	call	811244bc <strlen>
811381e0:	8085c83a 	sub	r2,r16,r2
811381e4:	e1bffd17 	ldw	r6,-12(fp)
811381e8:	100b883a 	mov	r5,r2
811381ec:	01000804 	movi	r4,32
811381f0:	1137c600 	call	81137c60 <alt_log_repchar>

                while(*s)
811381f4:	00000b06 	br	81138224 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
811381f8:	e0bffa17 	ldw	r2,-24(fp)
811381fc:	10c00044 	addi	r3,r2,1
81138200:	e0fffa15 	stw	r3,-24(fp)
81138204:	10800003 	ldbu	r2,0(r2)
81138208:	10803fcc 	andi	r2,r2,255
8113820c:	1080201c 	xori	r2,r2,128
81138210:	10bfe004 	addi	r2,r2,-128
81138214:	e0fffd17 	ldw	r3,-12(fp)
81138218:	180b883a 	mov	r5,r3
8113821c:	1009883a 	mov	r4,r2
81138220:	1137c0c0 	call	81137c0c <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81138224:	e0bffa17 	ldw	r2,-24(fp)
81138228:	10800003 	ldbu	r2,0(r2)
8113822c:	10803fcc 	andi	r2,r2,255
81138230:	1080201c 	xori	r2,r2,128
81138234:	10bfe004 	addi	r2,r2,-128
81138238:	103fef1e 	bne	r2,zero,811381f8 <__reset+0xfb1181f8>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
8113823c:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81138240:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81138244:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81138248:	e0bfeb17 	ldw	r2,-84(fp)
8113824c:	10c00044 	addi	r3,r2,1
81138250:	e0ffeb15 	stw	r3,-84(fp)
81138254:	10800003 	ldbu	r2,0(r2)
81138258:	e0bffb05 	stb	r2,-20(fp)
8113825c:	e0bffb07 	ldb	r2,-20(fp)
81138260:	103eae1e 	bne	r2,zero,81137d1c <__reset+0xfb117d1c>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81138264:	0001883a 	nop
81138268:	e6ffff04 	addi	sp,fp,-4
8113826c:	dfc00217 	ldw	ra,8(sp)
81138270:	df000117 	ldw	fp,4(sp)
81138274:	dc000017 	ldw	r16,0(sp)
81138278:	dec00304 	addi	sp,sp,12
8113827c:	f800283a 	ret

81138280 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81138280:	defff904 	addi	sp,sp,-28
81138284:	de00012e 	bgeu	sp,et,8113828c <alt_log_printf_proc+0xc>
81138288:	003b68fa 	trap	3
8113828c:	dfc00315 	stw	ra,12(sp)
81138290:	df000215 	stw	fp,8(sp)
81138294:	df000204 	addi	fp,sp,8
81138298:	e13fff15 	stw	r4,-4(fp)
8113829c:	e1400215 	stw	r5,8(fp)
811382a0:	e1800315 	stw	r6,12(fp)
811382a4:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
811382a8:	e0800204 	addi	r2,fp,8
811382ac:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
811382b0:	e0bffe17 	ldw	r2,-8(fp)
811382b4:	100d883a 	mov	r6,r2
811382b8:	01604834 	movhi	r5,33056
811382bc:	294c2404 	addi	r5,r5,12432
811382c0:	e13fff17 	ldw	r4,-4(fp)
811382c4:	1137cc80 	call	81137cc8 <alt_log_private_printf>
    return (0);
811382c8:	0005883a 	mov	r2,zero
}
811382cc:	e037883a 	mov	sp,fp
811382d0:	dfc00117 	ldw	ra,4(sp)
811382d4:	df000017 	ldw	fp,0(sp)
811382d8:	dec00504 	addi	sp,sp,20
811382dc:	f800283a 	ret

811382e0 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
811382e0:	defff904 	addi	sp,sp,-28
811382e4:	de00012e 	bgeu	sp,et,811382ec <altera_avalon_jtag_uart_report_log+0xc>
811382e8:	003b68fa 	trap	3
811382ec:	dfc00615 	stw	ra,24(sp)
811382f0:	df000515 	stw	fp,20(sp)
811382f4:	dc400415 	stw	r17,16(sp)
811382f8:	dc000315 	stw	r16,12(sp)
811382fc:	df000504 	addi	fp,sp,20
81138300:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81138304:	d0a08183 	ldbu	r2,-32250(gp)
81138308:	10803fcc 	andi	r2,r2,255
8113830c:	10001426 	beq	r2,zero,81138360 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81138310:	e0bffd17 	ldw	r2,-12(fp)
81138314:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81138318:	00a04574 	movhi	r2,33045
8113831c:	10882104 	addi	r2,r2,8324
81138320:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81138324:	e0bffb17 	ldw	r2,-20(fp)
81138328:	10800017 	ldw	r2,0(r2)
8113832c:	e1bffc17 	ldw	r6,-16(fp)
81138330:	100b883a 	mov	r5,r2
81138334:	e13ffb17 	ldw	r4,-20(fp)
81138338:	11383800 	call	81138380 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8113833c:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81138340:	00b33374 	movhi	r2,52429
81138344:	10b33344 	addi	r2,r2,-13107
81138348:	1888383a 	mulxuu	r4,r3,r2
8113834c:	1885383a 	mul	r2,r3,r2
81138350:	1021883a 	mov	r16,r2
81138354:	2023883a 	mov	r17,r4
81138358:	8804d0fa 	srli	r2,r17,3
8113835c:	00000106 	br	81138364 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81138360:	0005883a 	mov	r2,zero
    }
}
81138364:	e6fffe04 	addi	sp,fp,-8
81138368:	dfc00317 	ldw	ra,12(sp)
8113836c:	df000217 	ldw	fp,8(sp)
81138370:	dc400117 	ldw	r17,4(sp)
81138374:	dc000017 	ldw	r16,0(sp)
81138378:	dec00404 	addi	sp,sp,16
8113837c:	f800283a 	ret

81138380 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81138380:	deffef04 	addi	sp,sp,-68
81138384:	de00012e 	bgeu	sp,et,8113838c <alt_log_jtag_uart_print_control_reg+0xc>
81138388:	003b68fa 	trap	3
8113838c:	dfc01015 	stw	ra,64(sp)
81138390:	df000f15 	stw	fp,60(sp)
81138394:	df000f04 	addi	fp,sp,60
81138398:	e13ffd15 	stw	r4,-12(fp)
8113839c:	e17ffe15 	stw	r5,-8(fp)
811383a0:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811383a4:	e0bffe17 	ldw	r2,-8(fp)
811383a8:	10800104 	addi	r2,r2,4
811383ac:	10800037 	ldwio	r2,0(r2)
811383b0:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
811383b4:	e0bff617 	ldw	r2,-40(fp)
811383b8:	1004d43a 	srli	r2,r2,16
811383bc:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
811383c0:	e0bff617 	ldw	r2,-40(fp)
811383c4:	1080008c 	andi	r2,r2,2
811383c8:	1004d07a 	srli	r2,r2,1
811383cc:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
811383d0:	e0bff617 	ldw	r2,-40(fp)
811383d4:	1080004c 	andi	r2,r2,1
811383d8:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
811383dc:	e0bff617 	ldw	r2,-40(fp)
811383e0:	1080400c 	andi	r2,r2,256
811383e4:	1004d23a 	srli	r2,r2,8
811383e8:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
811383ec:	e0bff617 	ldw	r2,-40(fp)
811383f0:	1080800c 	andi	r2,r2,512
811383f4:	1004d27a 	srli	r2,r2,9
811383f8:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
811383fc:	e0bff617 	ldw	r2,-40(fp)
81138400:	1081000c 	andi	r2,r2,1024
81138404:	1004d2ba 	srli	r2,r2,10
81138408:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
8113840c:	e0bffd17 	ldw	r2,-12(fp)
81138410:	10c01017 	ldw	r3,64(r2)
81138414:	e0bffd17 	ldw	r2,-12(fp)
81138418:	10800f17 	ldw	r2,60(r2)
8113841c:	1887c83a 	sub	r3,r3,r2
81138420:	e0bff917 	ldw	r2,-28(fp)
81138424:	d8800415 	stw	r2,16(sp)
81138428:	e0bff817 	ldw	r2,-32(fp)
8113842c:	d8800315 	stw	r2,12(sp)
81138430:	e0bffa17 	ldw	r2,-24(fp)
81138434:	d8800215 	stw	r2,8(sp)
81138438:	e0bffb17 	ldw	r2,-20(fp)
8113843c:	d8800115 	stw	r2,4(sp)
81138440:	e0bffc17 	ldw	r2,-16(fp)
81138444:	d8800015 	stw	r2,0(sp)
81138448:	e1fff717 	ldw	r7,-36(fp)
8113844c:	180d883a 	mov	r6,r3
81138450:	e17fff17 	ldw	r5,-4(fp)
81138454:	01204574 	movhi	r4,33045
81138458:	21082404 	addi	r4,r4,8336
8113845c:	11382800 	call	81138280 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81138460:	0001883a 	nop

}
81138464:	e037883a 	mov	sp,fp
81138468:	dfc00117 	ldw	ra,4(sp)
8113846c:	df000017 	ldw	fp,0(sp)
81138470:	dec00204 	addi	sp,sp,8
81138474:	f800283a 	ret

81138478 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81138478:	defffb04 	addi	sp,sp,-20
8113847c:	de00012e 	bgeu	sp,et,81138484 <alt_log_jtag_uart_startup_info+0xc>
81138480:	003b68fa 	trap	3
81138484:	dfc00415 	stw	ra,16(sp)
81138488:	df000315 	stw	fp,12(sp)
8113848c:	df000304 	addi	fp,sp,12
81138490:	e13ffe15 	stw	r4,-8(fp)
81138494:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81138498:	00a04574 	movhi	r2,33045
8113849c:	10883604 	addi	r2,r2,8408
811384a0:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
811384a4:	e1bffd17 	ldw	r6,-12(fp)
811384a8:	e17fff17 	ldw	r5,-4(fp)
811384ac:	e13ffe17 	ldw	r4,-8(fp)
811384b0:	11383800 	call	81138380 <alt_log_jtag_uart_print_control_reg>
     return;
811384b4:	0001883a 	nop
}
811384b8:	e037883a 	mov	sp,fp
811384bc:	dfc00117 	ldw	ra,4(sp)
811384c0:	df000017 	ldw	fp,0(sp)
811384c4:	dec00204 	addi	sp,sp,8
811384c8:	f800283a 	ret

811384cc <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
811384cc:	defffb04 	addi	sp,sp,-20
811384d0:	de00012e 	bgeu	sp,et,811384d8 <alt_log_jtag_uart_isr_proc+0xc>
811384d4:	003b68fa 	trap	3
811384d8:	dfc00415 	stw	ra,16(sp)
811384dc:	df000315 	stw	fp,12(sp)
811384e0:	df000304 	addi	fp,sp,12
811384e4:	e13ffe15 	stw	r4,-8(fp)
811384e8:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811384ec:	d0a081c3 	ldbu	r2,-32249(gp)
811384f0:	10803fcc 	andi	r2,r2,255
811384f4:	10000826 	beq	r2,zero,81138518 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
811384f8:	00a04574 	movhi	r2,33045
811384fc:	10883b04 	addi	r2,r2,8428
81138500:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81138504:	e1bffd17 	ldw	r6,-12(fp)
81138508:	e17ffe17 	ldw	r5,-8(fp)
8113850c:	e13fff17 	ldw	r4,-4(fp)
81138510:	11383800 	call	81138380 <alt_log_jtag_uart_print_control_reg>
    }
    return;
81138514:	0001883a 	nop
81138518:	0001883a 	nop
}
8113851c:	e037883a 	mov	sp,fp
81138520:	dfc00117 	ldw	ra,4(sp)
81138524:	df000017 	ldw	fp,0(sp)
81138528:	dec00204 	addi	sp,sp,8
8113852c:	f800283a 	ret

81138530 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81138530:	defffa04 	addi	sp,sp,-24
81138534:	de00012e 	bgeu	sp,et,8113853c <alt_log_write+0xc>
81138538:	003b68fa 	trap	3
8113853c:	dfc00515 	stw	ra,20(sp)
81138540:	df000415 	stw	fp,16(sp)
81138544:	df000404 	addi	fp,sp,16
81138548:	e13ffe15 	stw	r4,-8(fp)
8113854c:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81138550:	d0a08103 	ldbu	r2,-32252(gp)
81138554:	10803fcc 	andi	r2,r2,255
81138558:	10004026 	beq	r2,zero,8113865c <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
8113855c:	e0bfff17 	ldw	r2,-4(fp)
81138560:	10c00430 	cmpltui	r3,r2,16
81138564:	1800011e 	bne	r3,zero,8113856c <alt_log_write+0x3c>
81138568:	008003c4 	movi	r2,15
8113856c:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81138570:	e0bffd17 	ldw	r2,-12(fp)
81138574:	10800088 	cmpgei	r2,r2,2
81138578:	10003726 	beq	r2,zero,81138658 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
8113857c:	e0bffd17 	ldw	r2,-12(fp)
81138580:	100d883a 	mov	r6,r2
81138584:	e17ffe17 	ldw	r5,-8(fp)
81138588:	012045f4 	movhi	r4,33047
8113858c:	21201b04 	addi	r4,r4,-32660
81138590:	114c4fc0 	call	8114c4fc <strncpy>
    alt_log_write_buf[length-1]='\n';
81138594:	e0bffd17 	ldw	r2,-12(fp)
81138598:	10ffffc4 	addi	r3,r2,-1
8113859c:	00a045f4 	movhi	r2,33047
811385a0:	10a01b04 	addi	r2,r2,-32660
811385a4:	10c5883a 	add	r2,r2,r3
811385a8:	00c00284 	movi	r3,10
811385ac:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
811385b0:	00a045f4 	movhi	r2,33047
811385b4:	10a01b04 	addi	r2,r2,-32660
811385b8:	e0fffd17 	ldw	r3,-12(fp)
811385bc:	10c5883a 	add	r2,r2,r3
811385c0:	00c00344 	movi	r3,13
811385c4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
811385c8:	e0bffd17 	ldw	r2,-12(fp)
811385cc:	10c00044 	addi	r3,r2,1
811385d0:	00a045f4 	movhi	r2,33047
811385d4:	10a01b04 	addi	r2,r2,-32660
811385d8:	10c5883a 	add	r2,r2,r3
811385dc:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811385e0:	e03ffc15 	stw	zero,-16(fp)
811385e4:	00001306 	br	81138634 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811385e8:	00a045f4 	movhi	r2,33047
811385ec:	10a01b04 	addi	r2,r2,-32660
811385f0:	e0fffc17 	ldw	r3,-16(fp)
811385f4:	10c5883a 	add	r2,r2,r3
811385f8:	10800003 	ldbu	r2,0(r2)
811385fc:	10803fcc 	andi	r2,r2,255
81138600:	1080201c 	xori	r2,r2,128
81138604:	10bfe004 	addi	r2,r2,-128
81138608:	10800118 	cmpnei	r2,r2,4
8113860c:	1000061e 	bne	r2,zero,81138628 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81138610:	00a045f4 	movhi	r2,33047
81138614:	10a01b04 	addi	r2,r2,-32660
81138618:	e0fffc17 	ldw	r3,-16(fp)
8113861c:	10c5883a 	add	r2,r2,r3
81138620:	00c01104 	movi	r3,68
81138624:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81138628:	e0bffc17 	ldw	r2,-16(fp)
8113862c:	10800044 	addi	r2,r2,1
81138630:	e0bffc15 	stw	r2,-16(fp)
81138634:	e0fffc17 	ldw	r3,-16(fp)
81138638:	e0bffd17 	ldw	r2,-12(fp)
8113863c:	18bfea16 	blt	r3,r2,811385e8 <__reset+0xfb1185e8>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81138640:	016045f4 	movhi	r5,33047
81138644:	29601b04 	addi	r5,r5,-32660
81138648:	01204574 	movhi	r4,33045
8113864c:	21083e04 	addi	r4,r4,8440
81138650:	11382800 	call	81138280 <alt_log_printf_proc>
81138654:	00000106 	br	8113865c <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81138658:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
8113865c:	e037883a 	mov	sp,fp
81138660:	dfc00117 	ldw	ra,4(sp)
81138664:	df000017 	ldw	fp,0(sp)
81138668:	dec00204 	addi	sp,sp,8
8113866c:	f800283a 	ret

81138670 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81138670:	defffe04 	addi	sp,sp,-8
81138674:	de00012e 	bgeu	sp,et,8113867c <alt_log_system_clock+0xc>
81138678:	003b68fa 	trap	3
8113867c:	dfc00115 	stw	ra,4(sp)
81138680:	df000015 	stw	fp,0(sp)
81138684:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81138688:	d0a08143 	ldbu	r2,-32251(gp)
8113868c:	10803fcc 	andi	r2,r2,255
81138690:	10000e26 	beq	r2,zero,811386cc <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81138694:	d0a08417 	ldw	r2,-32240(gp)
81138698:	10800044 	addi	r2,r2,1
8113869c:	d0a08415 	stw	r2,-32240(gp)
811386a0:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
811386a4:	d0e08417 	ldw	r3,-32240(gp)
811386a8:	10c0082e 	bgeu	r2,r3,811386cc <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
811386ac:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
811386b0:	d0a08317 	ldw	r2,-32244(gp)
811386b4:	10c00044 	addi	r3,r2,1
811386b8:	d0e08315 	stw	r3,-32244(gp)
811386bc:	100b883a 	mov	r5,r2
811386c0:	01204574 	movhi	r4,33045
811386c4:	21084204 	addi	r4,r4,8456
811386c8:	11382800 	call	81138280 <alt_log_printf_proc>
        }
    }
}
811386cc:	0001883a 	nop
811386d0:	e037883a 	mov	sp,fp
811386d4:	dfc00117 	ldw	ra,4(sp)
811386d8:	df000017 	ldw	fp,0(sp)
811386dc:	dec00204 	addi	sp,sp,8
811386e0:	f800283a 	ret

811386e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811386e4:	defffe04 	addi	sp,sp,-8
811386e8:	de00012e 	bgeu	sp,et,811386f0 <alt_get_errno+0xc>
811386ec:	003b68fa 	trap	3
811386f0:	dfc00115 	stw	ra,4(sp)
811386f4:	df000015 	stw	fp,0(sp)
811386f8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811386fc:	d0a01017 	ldw	r2,-32704(gp)
81138700:	10000326 	beq	r2,zero,81138710 <alt_get_errno+0x2c>
81138704:	d0a01017 	ldw	r2,-32704(gp)
81138708:	103ee83a 	callr	r2
8113870c:	00000106 	br	81138714 <alt_get_errno+0x30>
81138710:	d0a07804 	addi	r2,gp,-32288
}
81138714:	e037883a 	mov	sp,fp
81138718:	dfc00117 	ldw	ra,4(sp)
8113871c:	df000017 	ldw	fp,0(sp)
81138720:	dec00204 	addi	sp,sp,8
81138724:	f800283a 	ret

81138728 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81138728:	defff904 	addi	sp,sp,-28
8113872c:	de00012e 	bgeu	sp,et,81138734 <lseek+0xc>
81138730:	003b68fa 	trap	3
81138734:	dfc00615 	stw	ra,24(sp)
81138738:	df000515 	stw	fp,20(sp)
8113873c:	df000504 	addi	fp,sp,20
81138740:	e13ffd15 	stw	r4,-12(fp)
81138744:	e17ffe15 	stw	r5,-8(fp)
81138748:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
8113874c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81138750:	e0bffd17 	ldw	r2,-12(fp)
81138754:	10000616 	blt	r2,zero,81138770 <lseek+0x48>
81138758:	e0bffd17 	ldw	r2,-12(fp)
8113875c:	10c00324 	muli	r3,r2,12
81138760:	00a04574 	movhi	r2,33045
81138764:	108bfb04 	addi	r2,r2,12268
81138768:	1885883a 	add	r2,r3,r2
8113876c:	00000106 	br	81138774 <lseek+0x4c>
81138770:	0005883a 	mov	r2,zero
81138774:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81138778:	e0bffc17 	ldw	r2,-16(fp)
8113877c:	10001026 	beq	r2,zero,811387c0 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81138780:	e0bffc17 	ldw	r2,-16(fp)
81138784:	10800017 	ldw	r2,0(r2)
81138788:	10800717 	ldw	r2,28(r2)
8113878c:	10000926 	beq	r2,zero,811387b4 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81138790:	e0bffc17 	ldw	r2,-16(fp)
81138794:	10800017 	ldw	r2,0(r2)
81138798:	10800717 	ldw	r2,28(r2)
8113879c:	e1bfff17 	ldw	r6,-4(fp)
811387a0:	e17ffe17 	ldw	r5,-8(fp)
811387a4:	e13ffc17 	ldw	r4,-16(fp)
811387a8:	103ee83a 	callr	r2
811387ac:	e0bffb15 	stw	r2,-20(fp)
811387b0:	00000506 	br	811387c8 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
811387b4:	00bfde84 	movi	r2,-134
811387b8:	e0bffb15 	stw	r2,-20(fp)
811387bc:	00000206 	br	811387c8 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
811387c0:	00bfebc4 	movi	r2,-81
811387c4:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
811387c8:	e0bffb17 	ldw	r2,-20(fp)
811387cc:	1000070e 	bge	r2,zero,811387ec <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
811387d0:	11386e40 	call	811386e4 <alt_get_errno>
811387d4:	1007883a 	mov	r3,r2
811387d8:	e0bffb17 	ldw	r2,-20(fp)
811387dc:	0085c83a 	sub	r2,zero,r2
811387e0:	18800015 	stw	r2,0(r3)
    rc = -1;
811387e4:	00bfffc4 	movi	r2,-1
811387e8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811387ec:	e0bffb17 	ldw	r2,-20(fp)
}
811387f0:	e037883a 	mov	sp,fp
811387f4:	dfc00117 	ldw	ra,4(sp)
811387f8:	df000017 	ldw	fp,0(sp)
811387fc:	dec00204 	addi	sp,sp,8
81138800:	f800283a 	ret

81138804 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
81138804:	defff904 	addi	sp,sp,-28
81138808:	de00012e 	bgeu	sp,et,81138810 <alt_main+0xc>
8113880c:	003b68fa 	trap	3
81138810:	dfc00615 	stw	ra,24(sp)
81138814:	df000515 	stw	fp,20(sp)
81138818:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
8113881c:	d0a01217 	ldw	r2,-32696(gp)
81138820:	10800058 	cmpnei	r2,r2,1
81138824:	1000031e 	bne	r2,zero,81138834 <alt_main+0x30>
81138828:	01204574 	movhi	r4,33045
8113882c:	21084804 	addi	r4,r4,8480
81138830:	11382800 	call	81138280 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81138834:	0009883a 	mov	r4,zero
81138838:	114335c0 	call	8114335c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
8113883c:	d0a01217 	ldw	r2,-32696(gp)
81138840:	10800058 	cmpnei	r2,r2,1
81138844:	1000031e 	bne	r2,zero,81138854 <alt_main+0x50>
81138848:	01204574 	movhi	r4,33045
8113884c:	21085604 	addi	r4,r4,8536
81138850:	11382800 	call	81138280 <alt_log_printf_proc>
  ALT_OS_INIT();
81138854:	1139df00 	call	81139df0 <OSInit>
81138858:	01000044 	movi	r4,1
8113885c:	113fb0c0 	call	8113fb0c <OSSemCreate>
81138860:	d0a08b15 	stw	r2,-32212(gp)
81138864:	01000044 	movi	r4,1
81138868:	113fb0c0 	call	8113fb0c <OSSemCreate>
8113886c:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81138870:	d0a01217 	ldw	r2,-32696(gp)
81138874:	10800058 	cmpnei	r2,r2,1
81138878:	1000031e 	bne	r2,zero,81138888 <alt_main+0x84>
8113887c:	01204574 	movhi	r4,33045
81138880:	21086404 	addi	r4,r4,8592
81138884:	11382800 	call	81138280 <alt_log_printf_proc>
81138888:	d0a07f04 	addi	r2,gp,-32260
8113888c:	e0bffc15 	stw	r2,-16(fp)
81138890:	00800044 	movi	r2,1
81138894:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81138898:	e0bffd0b 	ldhu	r2,-12(fp)
8113889c:	1009883a 	mov	r4,r2
811388a0:	113fb0c0 	call	8113fb0c <OSSemCreate>
811388a4:	1007883a 	mov	r3,r2
811388a8:	e0bffc17 	ldw	r2,-16(fp)
811388ac:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
811388b0:	d0a01217 	ldw	r2,-32696(gp)
811388b4:	10800058 	cmpnei	r2,r2,1
811388b8:	1000031e 	bne	r2,zero,811388c8 <alt_main+0xc4>
811388bc:	01204574 	movhi	r4,33045
811388c0:	21087204 	addi	r4,r4,8648
811388c4:	11382800 	call	81138280 <alt_log_printf_proc>
  alt_sys_init();
811388c8:	114339c0 	call	8114339c <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
811388cc:	d0a01217 	ldw	r2,-32696(gp)
811388d0:	10800058 	cmpnei	r2,r2,1
811388d4:	1000031e 	bne	r2,zero,811388e4 <alt_main+0xe0>
811388d8:	01204574 	movhi	r4,33045
811388dc:	21087c04 	addi	r4,r4,8688
811388e0:	11382800 	call	81138280 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811388e4:	d0a01217 	ldw	r2,-32696(gp)
811388e8:	10800058 	cmpnei	r2,r2,1
811388ec:	1000031e 	bne	r2,zero,811388fc <alt_main+0xf8>
811388f0:	01204574 	movhi	r4,33045
811388f4:	21088504 	addi	r4,r4,8724
811388f8:	11382800 	call	81138280 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811388fc:	01a04574 	movhi	r6,33045
81138900:	31888d04 	addi	r6,r6,8756
81138904:	01604574 	movhi	r5,33045
81138908:	29489204 	addi	r5,r5,8776
8113890c:	01204574 	movhi	r4,33045
81138910:	21089204 	addi	r4,r4,8776
81138914:	114bc8c0 	call	8114bc8c <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81138918:	d0a01217 	ldw	r2,-32696(gp)
8113891c:	10800058 	cmpnei	r2,r2,1
81138920:	1000031e 	bne	r2,zero,81138930 <alt_main+0x12c>
81138924:	01204574 	movhi	r4,33045
81138928:	21089604 	addi	r4,r4,8792
8113892c:	11382800 	call	81138280 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81138930:	d0a08517 	ldw	r2,-32236(gp)
81138934:	d0e08617 	ldw	r3,-32232(gp)
81138938:	d1208717 	ldw	r4,-32228(gp)
8113893c:	200d883a 	mov	r6,r4
81138940:	180b883a 	mov	r5,r3
81138944:	1009883a 	mov	r4,r2
81138948:	1118bac0 	call	81118bac <main>
8113894c:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81138950:	01000044 	movi	r4,1
81138954:	11377300 	call	81137730 <close>
  exit (result);
81138958:	e13ffb17 	ldw	r4,-20(fp)
8113895c:	114c4400 	call	8114c440 <exit>

81138960 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138960:	defffe04 	addi	sp,sp,-8
81138964:	de00012e 	bgeu	sp,et,8113896c <alt_get_errno+0xc>
81138968:	003b68fa 	trap	3
8113896c:	dfc00115 	stw	ra,4(sp)
81138970:	df000015 	stw	fp,0(sp)
81138974:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138978:	d0a01017 	ldw	r2,-32704(gp)
8113897c:	10000326 	beq	r2,zero,8113898c <alt_get_errno+0x2c>
81138980:	d0a01017 	ldw	r2,-32704(gp)
81138984:	103ee83a 	callr	r2
81138988:	00000106 	br	81138990 <alt_get_errno+0x30>
8113898c:	d0a07804 	addi	r2,gp,-32288
}
81138990:	e037883a 	mov	sp,fp
81138994:	dfc00117 	ldw	ra,4(sp)
81138998:	df000017 	ldw	fp,0(sp)
8113899c:	dec00204 	addi	sp,sp,8
811389a0:	f800283a 	ret

811389a4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
811389a4:	defffd04 	addi	sp,sp,-12
811389a8:	de00012e 	bgeu	sp,et,811389b0 <alt_file_locked+0xc>
811389ac:	003b68fa 	trap	3
811389b0:	df000215 	stw	fp,8(sp)
811389b4:	df000204 	addi	fp,sp,8
811389b8:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
811389bc:	e0bfff17 	ldw	r2,-4(fp)
811389c0:	10800217 	ldw	r2,8(r2)
811389c4:	10d00034 	orhi	r3,r2,16384
811389c8:	e0bfff17 	ldw	r2,-4(fp)
811389cc:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811389d0:	e03ffe15 	stw	zero,-8(fp)
811389d4:	00001d06 	br	81138a4c <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811389d8:	00a04574 	movhi	r2,33045
811389dc:	108bfb04 	addi	r2,r2,12268
811389e0:	e0fffe17 	ldw	r3,-8(fp)
811389e4:	18c00324 	muli	r3,r3,12
811389e8:	10c5883a 	add	r2,r2,r3
811389ec:	10c00017 	ldw	r3,0(r2)
811389f0:	e0bfff17 	ldw	r2,-4(fp)
811389f4:	10800017 	ldw	r2,0(r2)
811389f8:	1880111e 	bne	r3,r2,81138a40 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811389fc:	00a04574 	movhi	r2,33045
81138a00:	108bfb04 	addi	r2,r2,12268
81138a04:	e0fffe17 	ldw	r3,-8(fp)
81138a08:	18c00324 	muli	r3,r3,12
81138a0c:	10c5883a 	add	r2,r2,r3
81138a10:	10800204 	addi	r2,r2,8
81138a14:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81138a18:	1000090e 	bge	r2,zero,81138a40 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81138a1c:	e0bffe17 	ldw	r2,-8(fp)
81138a20:	10c00324 	muli	r3,r2,12
81138a24:	00a04574 	movhi	r2,33045
81138a28:	108bfb04 	addi	r2,r2,12268
81138a2c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81138a30:	e0bfff17 	ldw	r2,-4(fp)
81138a34:	18800226 	beq	r3,r2,81138a40 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81138a38:	00bffcc4 	movi	r2,-13
81138a3c:	00000806 	br	81138a60 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81138a40:	e0bffe17 	ldw	r2,-8(fp)
81138a44:	10800044 	addi	r2,r2,1
81138a48:	e0bffe15 	stw	r2,-8(fp)
81138a4c:	d0a00f17 	ldw	r2,-32708(gp)
81138a50:	1007883a 	mov	r3,r2
81138a54:	e0bffe17 	ldw	r2,-8(fp)
81138a58:	18bfdf2e 	bgeu	r3,r2,811389d8 <__reset+0xfb1189d8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81138a5c:	0005883a 	mov	r2,zero
}
81138a60:	e037883a 	mov	sp,fp
81138a64:	df000017 	ldw	fp,0(sp)
81138a68:	dec00104 	addi	sp,sp,4
81138a6c:	f800283a 	ret

81138a70 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81138a70:	defff604 	addi	sp,sp,-40
81138a74:	de00012e 	bgeu	sp,et,81138a7c <open+0xc>
81138a78:	003b68fa 	trap	3
81138a7c:	dfc00915 	stw	ra,36(sp)
81138a80:	df000815 	stw	fp,32(sp)
81138a84:	df000804 	addi	fp,sp,32
81138a88:	e13ffd15 	stw	r4,-12(fp)
81138a8c:	e17ffe15 	stw	r5,-8(fp)
81138a90:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81138a94:	00bfffc4 	movi	r2,-1
81138a98:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81138a9c:	00bffb44 	movi	r2,-19
81138aa0:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81138aa4:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81138aa8:	d1600d04 	addi	r5,gp,-32716
81138aac:	e13ffd17 	ldw	r4,-12(fp)
81138ab0:	114b66c0 	call	8114b66c <alt_find_dev>
81138ab4:	e0bff815 	stw	r2,-32(fp)
81138ab8:	e0bff817 	ldw	r2,-32(fp)
81138abc:	1000051e 	bne	r2,zero,81138ad4 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81138ac0:	e13ffd17 	ldw	r4,-12(fp)
81138ac4:	114b7040 	call	8114b704 <alt_find_file>
81138ac8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81138acc:	00800044 	movi	r2,1
81138ad0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81138ad4:	e0bff817 	ldw	r2,-32(fp)
81138ad8:	10002926 	beq	r2,zero,81138b80 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81138adc:	e13ff817 	ldw	r4,-32(fp)
81138ae0:	114b8140 	call	8114b814 <alt_get_fd>
81138ae4:	e0bff915 	stw	r2,-28(fp)
81138ae8:	e0bff917 	ldw	r2,-28(fp)
81138aec:	1000030e 	bge	r2,zero,81138afc <open+0x8c>
    {
      status = index;
81138af0:	e0bff917 	ldw	r2,-28(fp)
81138af4:	e0bffa15 	stw	r2,-24(fp)
81138af8:	00002306 	br	81138b88 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81138afc:	e0bff917 	ldw	r2,-28(fp)
81138b00:	10c00324 	muli	r3,r2,12
81138b04:	00a04574 	movhi	r2,33045
81138b08:	108bfb04 	addi	r2,r2,12268
81138b0c:	1885883a 	add	r2,r3,r2
81138b10:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
81138b14:	e0fffe17 	ldw	r3,-8(fp)
81138b18:	00900034 	movhi	r2,16384
81138b1c:	10bfffc4 	addi	r2,r2,-1
81138b20:	1886703a 	and	r3,r3,r2
81138b24:	e0bffc17 	ldw	r2,-16(fp)
81138b28:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81138b2c:	e0bffb17 	ldw	r2,-20(fp)
81138b30:	1000051e 	bne	r2,zero,81138b48 <open+0xd8>
81138b34:	e13ffc17 	ldw	r4,-16(fp)
81138b38:	11389a40 	call	811389a4 <alt_file_locked>
81138b3c:	e0bffa15 	stw	r2,-24(fp)
81138b40:	e0bffa17 	ldw	r2,-24(fp)
81138b44:	10001016 	blt	r2,zero,81138b88 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81138b48:	e0bff817 	ldw	r2,-32(fp)
81138b4c:	10800317 	ldw	r2,12(r2)
81138b50:	10000826 	beq	r2,zero,81138b74 <open+0x104>
81138b54:	e0bff817 	ldw	r2,-32(fp)
81138b58:	10800317 	ldw	r2,12(r2)
81138b5c:	e1ffff17 	ldw	r7,-4(fp)
81138b60:	e1bffe17 	ldw	r6,-8(fp)
81138b64:	e17ffd17 	ldw	r5,-12(fp)
81138b68:	e13ffc17 	ldw	r4,-16(fp)
81138b6c:	103ee83a 	callr	r2
81138b70:	00000106 	br	81138b78 <open+0x108>
81138b74:	0005883a 	mov	r2,zero
81138b78:	e0bffa15 	stw	r2,-24(fp)
81138b7c:	00000206 	br	81138b88 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81138b80:	00bffb44 	movi	r2,-19
81138b84:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81138b88:	e0bffa17 	ldw	r2,-24(fp)
81138b8c:	1000090e 	bge	r2,zero,81138bb4 <open+0x144>
  {
    alt_release_fd (index);  
81138b90:	e13ff917 	ldw	r4,-28(fp)
81138b94:	1138d140 	call	81138d14 <alt_release_fd>
    ALT_ERRNO = -status;
81138b98:	11389600 	call	81138960 <alt_get_errno>
81138b9c:	1007883a 	mov	r3,r2
81138ba0:	e0bffa17 	ldw	r2,-24(fp)
81138ba4:	0085c83a 	sub	r2,zero,r2
81138ba8:	18800015 	stw	r2,0(r3)
    return -1;
81138bac:	00bfffc4 	movi	r2,-1
81138bb0:	00000106 	br	81138bb8 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81138bb4:	e0bff917 	ldw	r2,-28(fp)
}
81138bb8:	e037883a 	mov	sp,fp
81138bbc:	dfc00117 	ldw	ra,4(sp)
81138bc0:	df000017 	ldw	fp,0(sp)
81138bc4:	dec00204 	addi	sp,sp,8
81138bc8:	f800283a 	ret

81138bcc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138bcc:	defffe04 	addi	sp,sp,-8
81138bd0:	de00012e 	bgeu	sp,et,81138bd8 <alt_get_errno+0xc>
81138bd4:	003b68fa 	trap	3
81138bd8:	dfc00115 	stw	ra,4(sp)
81138bdc:	df000015 	stw	fp,0(sp)
81138be0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138be4:	d0a01017 	ldw	r2,-32704(gp)
81138be8:	10000326 	beq	r2,zero,81138bf8 <alt_get_errno+0x2c>
81138bec:	d0a01017 	ldw	r2,-32704(gp)
81138bf0:	103ee83a 	callr	r2
81138bf4:	00000106 	br	81138bfc <alt_get_errno+0x30>
81138bf8:	d0a07804 	addi	r2,gp,-32288
}
81138bfc:	e037883a 	mov	sp,fp
81138c00:	dfc00117 	ldw	ra,4(sp)
81138c04:	df000017 	ldw	fp,0(sp)
81138c08:	dec00204 	addi	sp,sp,8
81138c0c:	f800283a 	ret

81138c10 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81138c10:	defff904 	addi	sp,sp,-28
81138c14:	de00012e 	bgeu	sp,et,81138c1c <read+0xc>
81138c18:	003b68fa 	trap	3
81138c1c:	dfc00615 	stw	ra,24(sp)
81138c20:	df000515 	stw	fp,20(sp)
81138c24:	df000504 	addi	fp,sp,20
81138c28:	e13ffd15 	stw	r4,-12(fp)
81138c2c:	e17ffe15 	stw	r5,-8(fp)
81138c30:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81138c34:	e0bffd17 	ldw	r2,-12(fp)
81138c38:	10000616 	blt	r2,zero,81138c54 <read+0x44>
81138c3c:	e0bffd17 	ldw	r2,-12(fp)
81138c40:	10c00324 	muli	r3,r2,12
81138c44:	00a04574 	movhi	r2,33045
81138c48:	108bfb04 	addi	r2,r2,12268
81138c4c:	1885883a 	add	r2,r3,r2
81138c50:	00000106 	br	81138c58 <read+0x48>
81138c54:	0005883a 	mov	r2,zero
81138c58:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81138c5c:	e0bffb17 	ldw	r2,-20(fp)
81138c60:	10002226 	beq	r2,zero,81138cec <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81138c64:	e0bffb17 	ldw	r2,-20(fp)
81138c68:	10800217 	ldw	r2,8(r2)
81138c6c:	108000cc 	andi	r2,r2,3
81138c70:	10800060 	cmpeqi	r2,r2,1
81138c74:	1000181e 	bne	r2,zero,81138cd8 <read+0xc8>
        (fd->dev->read))
81138c78:	e0bffb17 	ldw	r2,-20(fp)
81138c7c:	10800017 	ldw	r2,0(r2)
81138c80:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81138c84:	10001426 	beq	r2,zero,81138cd8 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81138c88:	e0bffb17 	ldw	r2,-20(fp)
81138c8c:	10800017 	ldw	r2,0(r2)
81138c90:	10800517 	ldw	r2,20(r2)
81138c94:	e0ffff17 	ldw	r3,-4(fp)
81138c98:	180d883a 	mov	r6,r3
81138c9c:	e17ffe17 	ldw	r5,-8(fp)
81138ca0:	e13ffb17 	ldw	r4,-20(fp)
81138ca4:	103ee83a 	callr	r2
81138ca8:	e0bffc15 	stw	r2,-16(fp)
81138cac:	e0bffc17 	ldw	r2,-16(fp)
81138cb0:	1000070e 	bge	r2,zero,81138cd0 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81138cb4:	1138bcc0 	call	81138bcc <alt_get_errno>
81138cb8:	1007883a 	mov	r3,r2
81138cbc:	e0bffc17 	ldw	r2,-16(fp)
81138cc0:	0085c83a 	sub	r2,zero,r2
81138cc4:	18800015 	stw	r2,0(r3)
          return -1;
81138cc8:	00bfffc4 	movi	r2,-1
81138ccc:	00000c06 	br	81138d00 <read+0xf0>
        }
        return rval;
81138cd0:	e0bffc17 	ldw	r2,-16(fp)
81138cd4:	00000a06 	br	81138d00 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81138cd8:	1138bcc0 	call	81138bcc <alt_get_errno>
81138cdc:	1007883a 	mov	r3,r2
81138ce0:	00800344 	movi	r2,13
81138ce4:	18800015 	stw	r2,0(r3)
81138ce8:	00000406 	br	81138cfc <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81138cec:	1138bcc0 	call	81138bcc <alt_get_errno>
81138cf0:	1007883a 	mov	r3,r2
81138cf4:	00801444 	movi	r2,81
81138cf8:	18800015 	stw	r2,0(r3)
  }
  return -1;
81138cfc:	00bfffc4 	movi	r2,-1
}
81138d00:	e037883a 	mov	sp,fp
81138d04:	dfc00117 	ldw	ra,4(sp)
81138d08:	df000017 	ldw	fp,0(sp)
81138d0c:	dec00204 	addi	sp,sp,8
81138d10:	f800283a 	ret

81138d14 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
81138d14:	defffe04 	addi	sp,sp,-8
81138d18:	de00012e 	bgeu	sp,et,81138d20 <alt_release_fd+0xc>
81138d1c:	003b68fa 	trap	3
81138d20:	df000115 	stw	fp,4(sp)
81138d24:	df000104 	addi	fp,sp,4
81138d28:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81138d2c:	e0bfff17 	ldw	r2,-4(fp)
81138d30:	108000d0 	cmplti	r2,r2,3
81138d34:	10000d1e 	bne	r2,zero,81138d6c <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81138d38:	00a04574 	movhi	r2,33045
81138d3c:	108bfb04 	addi	r2,r2,12268
81138d40:	e0ffff17 	ldw	r3,-4(fp)
81138d44:	18c00324 	muli	r3,r3,12
81138d48:	10c5883a 	add	r2,r2,r3
81138d4c:	10800204 	addi	r2,r2,8
81138d50:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81138d54:	00a04574 	movhi	r2,33045
81138d58:	108bfb04 	addi	r2,r2,12268
81138d5c:	e0ffff17 	ldw	r3,-4(fp)
81138d60:	18c00324 	muli	r3,r3,12
81138d64:	10c5883a 	add	r2,r2,r3
81138d68:	10000015 	stw	zero,0(r2)
  }
}
81138d6c:	0001883a 	nop
81138d70:	e037883a 	mov	sp,fp
81138d74:	df000017 	ldw	fp,0(sp)
81138d78:	dec00104 	addi	sp,sp,4
81138d7c:	f800283a 	ret

81138d80 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81138d80:	defff604 	addi	sp,sp,-40
81138d84:	de00012e 	bgeu	sp,et,81138d8c <sbrk+0xc>
81138d88:	003b68fa 	trap	3
81138d8c:	df000915 	stw	fp,36(sp)
81138d90:	df000904 	addi	fp,sp,36
81138d94:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d98:	0005303a 	rdctl	r2,status
81138d9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138da0:	e0fffe17 	ldw	r3,-8(fp)
81138da4:	00bfff84 	movi	r2,-2
81138da8:	1884703a 	and	r2,r3,r2
81138dac:	1001703a 	wrctl	status,r2
  
  return context;
81138db0:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81138db4:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81138db8:	d0a01317 	ldw	r2,-32692(gp)
81138dbc:	10c000c4 	addi	r3,r2,3
81138dc0:	00bfff04 	movi	r2,-4
81138dc4:	1884703a 	and	r2,r3,r2
81138dc8:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81138dcc:	d0e01317 	ldw	r3,-32692(gp)
81138dd0:	e0bfff17 	ldw	r2,-4(fp)
81138dd4:	1887883a 	add	r3,r3,r2
81138dd8:	00a04834 	movhi	r2,33056
81138ddc:	10a80004 	addi	r2,r2,-24576
81138de0:	10c0062e 	bgeu	r2,r3,81138dfc <sbrk+0x7c>
81138de4:	e0bff817 	ldw	r2,-32(fp)
81138de8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138dec:	e0bff717 	ldw	r2,-36(fp)
81138df0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81138df4:	00bfffc4 	movi	r2,-1
81138df8:	00001c06 	br	81138e6c <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81138dfc:	d0a01317 	ldw	r2,-32692(gp)
81138e00:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81138e04:	d0e01317 	ldw	r3,-32692(gp)
81138e08:	e0bfff17 	ldw	r2,-4(fp)
81138e0c:	1885883a 	add	r2,r3,r2
81138e10:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81138e14:	c005883a 	mov	r2,et
81138e18:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81138e1c:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81138e20:	e0bffa17 	ldw	r2,-24(fp)
81138e24:	18800c1e 	bne	r3,r2,81138e58 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81138e28:	d805883a 	mov	r2,sp
81138e2c:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81138e30:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81138e34:	d0e01317 	ldw	r3,-32692(gp)
81138e38:	18800136 	bltu	r3,r2,81138e40 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81138e3c:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81138e40:	d0a01317 	ldw	r2,-32692(gp)
81138e44:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81138e48:	e0bffc17 	ldw	r2,-16(fp)
81138e4c:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81138e50:	e0bffc17 	ldw	r2,-16(fp)
81138e54:	1031883a 	mov	et,r2
81138e58:	e0bff817 	ldw	r2,-32(fp)
81138e5c:	e0bffd15 	stw	r2,-12(fp)
81138e60:	e0bffd17 	ldw	r2,-12(fp)
81138e64:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81138e68:	e0bffa17 	ldw	r2,-24(fp)
} 
81138e6c:	e037883a 	mov	sp,fp
81138e70:	df000017 	ldw	fp,0(sp)
81138e74:	dec00104 	addi	sp,sp,4
81138e78:	f800283a 	ret

81138e7c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81138e7c:	defffa04 	addi	sp,sp,-24
81138e80:	de00012e 	bgeu	sp,et,81138e88 <alt_alarm_stop+0xc>
81138e84:	003b68fa 	trap	3
81138e88:	df000515 	stw	fp,20(sp)
81138e8c:	df000504 	addi	fp,sp,20
81138e90:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e94:	0005303a 	rdctl	r2,status
81138e98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e9c:	e0fffc17 	ldw	r3,-16(fp)
81138ea0:	00bfff84 	movi	r2,-2
81138ea4:	1884703a 	and	r2,r3,r2
81138ea8:	1001703a 	wrctl	status,r2
  
  return context;
81138eac:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81138eb0:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81138eb4:	e0bfff17 	ldw	r2,-4(fp)
81138eb8:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81138ebc:	e0bffd17 	ldw	r2,-12(fp)
81138ec0:	10800017 	ldw	r2,0(r2)
81138ec4:	e0fffd17 	ldw	r3,-12(fp)
81138ec8:	18c00117 	ldw	r3,4(r3)
81138ecc:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81138ed0:	e0bffd17 	ldw	r2,-12(fp)
81138ed4:	10800117 	ldw	r2,4(r2)
81138ed8:	e0fffd17 	ldw	r3,-12(fp)
81138edc:	18c00017 	ldw	r3,0(r3)
81138ee0:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81138ee4:	e0bffd17 	ldw	r2,-12(fp)
81138ee8:	e0fffd17 	ldw	r3,-12(fp)
81138eec:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81138ef0:	e0bffd17 	ldw	r2,-12(fp)
81138ef4:	e0fffd17 	ldw	r3,-12(fp)
81138ef8:	10c00015 	stw	r3,0(r2)
81138efc:	e0bffb17 	ldw	r2,-20(fp)
81138f00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138f04:	e0bffe17 	ldw	r2,-8(fp)
81138f08:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81138f0c:	0001883a 	nop
81138f10:	e037883a 	mov	sp,fp
81138f14:	df000017 	ldw	fp,0(sp)
81138f18:	dec00104 	addi	sp,sp,4
81138f1c:	f800283a 	ret

81138f20 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81138f20:	defffb04 	addi	sp,sp,-20
81138f24:	de00012e 	bgeu	sp,et,81138f2c <alt_tick+0xc>
81138f28:	003b68fa 	trap	3
81138f2c:	dfc00415 	stw	ra,16(sp)
81138f30:	df000315 	stw	fp,12(sp)
81138f34:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81138f38:	d0a01417 	ldw	r2,-32688(gp)
81138f3c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81138f40:	d0a08917 	ldw	r2,-32220(gp)
81138f44:	10800044 	addi	r2,r2,1
81138f48:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81138f4c:	00002e06 	br	81139008 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81138f50:	e0bffd17 	ldw	r2,-12(fp)
81138f54:	10800017 	ldw	r2,0(r2)
81138f58:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81138f5c:	e0bffd17 	ldw	r2,-12(fp)
81138f60:	10800403 	ldbu	r2,16(r2)
81138f64:	10803fcc 	andi	r2,r2,255
81138f68:	10000426 	beq	r2,zero,81138f7c <alt_tick+0x5c>
81138f6c:	d0a08917 	ldw	r2,-32220(gp)
81138f70:	1000021e 	bne	r2,zero,81138f7c <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81138f74:	e0bffd17 	ldw	r2,-12(fp)
81138f78:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81138f7c:	e0bffd17 	ldw	r2,-12(fp)
81138f80:	10800217 	ldw	r2,8(r2)
81138f84:	d0e08917 	ldw	r3,-32220(gp)
81138f88:	18801d36 	bltu	r3,r2,81139000 <alt_tick+0xe0>
81138f8c:	e0bffd17 	ldw	r2,-12(fp)
81138f90:	10800403 	ldbu	r2,16(r2)
81138f94:	10803fcc 	andi	r2,r2,255
81138f98:	1000191e 	bne	r2,zero,81139000 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81138f9c:	e0bffd17 	ldw	r2,-12(fp)
81138fa0:	10800317 	ldw	r2,12(r2)
81138fa4:	e0fffd17 	ldw	r3,-12(fp)
81138fa8:	18c00517 	ldw	r3,20(r3)
81138fac:	1809883a 	mov	r4,r3
81138fb0:	103ee83a 	callr	r2
81138fb4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81138fb8:	e0bfff17 	ldw	r2,-4(fp)
81138fbc:	1000031e 	bne	r2,zero,81138fcc <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81138fc0:	e13ffd17 	ldw	r4,-12(fp)
81138fc4:	1138e7c0 	call	81138e7c <alt_alarm_stop>
81138fc8:	00000d06 	br	81139000 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81138fcc:	e0bffd17 	ldw	r2,-12(fp)
81138fd0:	10c00217 	ldw	r3,8(r2)
81138fd4:	e0bfff17 	ldw	r2,-4(fp)
81138fd8:	1887883a 	add	r3,r3,r2
81138fdc:	e0bffd17 	ldw	r2,-12(fp)
81138fe0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81138fe4:	e0bffd17 	ldw	r2,-12(fp)
81138fe8:	10c00217 	ldw	r3,8(r2)
81138fec:	d0a08917 	ldw	r2,-32220(gp)
81138ff0:	1880032e 	bgeu	r3,r2,81139000 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81138ff4:	e0bffd17 	ldw	r2,-12(fp)
81138ff8:	00c00044 	movi	r3,1
81138ffc:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81139000:	e0bffe17 	ldw	r2,-8(fp)
81139004:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81139008:	e0fffd17 	ldw	r3,-12(fp)
8113900c:	d0a01404 	addi	r2,gp,-32688
81139010:	18bfcf1e 	bne	r3,r2,81138f50 <__reset+0xfb118f50>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81139014:	113a2500 	call	8113a250 <OSTimeTick>
}
81139018:	0001883a 	nop
8113901c:	e037883a 	mov	sp,fp
81139020:	dfc00117 	ldw	ra,4(sp)
81139024:	df000017 	ldw	fp,0(sp)
81139028:	dec00204 	addi	sp,sp,8
8113902c:	f800283a 	ret

81139030 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81139030:	defffb04 	addi	sp,sp,-20
81139034:	de00012e 	bgeu	sp,et,8113903c <usleep+0xc>
81139038:	003b68fa 	trap	3
8113903c:	dfc00415 	stw	ra,16(sp)
81139040:	df000315 	stw	fp,12(sp)
81139044:	df000304 	addi	fp,sp,12
81139048:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
8113904c:	d0a09103 	ldbu	r2,-32188(gp)
81139050:	10803fcc 	andi	r2,r2,255
81139054:	1000031e 	bne	r2,zero,81139064 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81139058:	e13fff17 	ldw	r4,-4(fp)
8113905c:	11375bc0 	call	811375bc <alt_busy_sleep>
81139060:	00003d06 	br	81139158 <usleep+0x128>
81139064:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81139068:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
8113906c:	e0ffff17 	ldw	r3,-4(fp)
81139070:	0090c734 	movhi	r2,17180
81139074:	10b7a0c4 	addi	r2,r2,-8573
81139078:	1888383a 	mulxuu	r4,r3,r2
8113907c:	1885383a 	mul	r2,r3,r2
81139080:	1013883a 	mov	r9,r2
81139084:	2015883a 	mov	r10,r4
81139088:	5006d4ba 	srli	r3,r10,18
8113908c:	e0bffe17 	ldw	r2,-8(fp)
81139090:	1893383a 	mul	r9,r3,r2
81139094:	e0ffff17 	ldw	r3,-4(fp)
81139098:	0090c734 	movhi	r2,17180
8113909c:	10b7a0c4 	addi	r2,r2,-8573
811390a0:	1888383a 	mulxuu	r4,r3,r2
811390a4:	1885383a 	mul	r2,r3,r2
811390a8:	100f883a 	mov	r7,r2
811390ac:	2011883a 	mov	r8,r4
811390b0:	4004d4ba 	srli	r2,r8,18
811390b4:	010003f4 	movhi	r4,15
811390b8:	21109004 	addi	r4,r4,16960
811390bc:	1105383a 	mul	r2,r2,r4
811390c0:	1885c83a 	sub	r2,r3,r2
811390c4:	e0fffe17 	ldw	r3,-8(fp)
811390c8:	10c7383a 	mul	r3,r2,r3
811390cc:	0090c734 	movhi	r2,17180
811390d0:	10b7a0c4 	addi	r2,r2,-8573
811390d4:	1888383a 	mulxuu	r4,r3,r2
811390d8:	1885383a 	mul	r2,r3,r2
811390dc:	100b883a 	mov	r5,r2
811390e0:	200d883a 	mov	r6,r4
811390e4:	3004d4ba 	srli	r2,r6,18
811390e8:	4885883a 	add	r2,r9,r2
811390ec:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
811390f0:	00000706 	br	81139110 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
811390f4:	013fffd4 	movui	r4,65535
811390f8:	1141cc00 	call	81141cc0 <OSTimeDly>
    ticks -= 0xffff;
811390fc:	e0fffd17 	ldw	r3,-12(fp)
81139100:	00bffff4 	movhi	r2,65535
81139104:	10800044 	addi	r2,r2,1
81139108:	1885883a 	add	r2,r3,r2
8113910c:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81139110:	e0bffd17 	ldw	r2,-12(fp)
81139114:	00ffffd4 	movui	r3,65535
81139118:	18bff636 	bltu	r3,r2,811390f4 <__reset+0xfb1190f4>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
8113911c:	e0bffd17 	ldw	r2,-12(fp)
81139120:	10bfffcc 	andi	r2,r2,65535
81139124:	1009883a 	mov	r4,r2
81139128:	1141cc00 	call	81141cc0 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
8113912c:	008003f4 	movhi	r2,15
81139130:	10909004 	addi	r2,r2,16960
81139134:	e0fffe17 	ldw	r3,-8(fp)
81139138:	10c7203a 	divu	r3,r2,r3
8113913c:	e0bfff17 	ldw	r2,-4(fp)
81139140:	10c9203a 	divu	r4,r2,r3
81139144:	20c7383a 	mul	r3,r4,r3
81139148:	10c5c83a 	sub	r2,r2,r3
8113914c:	1009883a 	mov	r4,r2
81139150:	11375bc0 	call	811375bc <alt_busy_sleep>

  return 0;  
81139154:	0005883a 	mov	r2,zero
}
81139158:	e037883a 	mov	sp,fp
8113915c:	dfc00117 	ldw	ra,4(sp)
81139160:	df000017 	ldw	fp,0(sp)
81139164:	dec00204 	addi	sp,sp,8
81139168:	f800283a 	ret

8113916c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113916c:	defffe04 	addi	sp,sp,-8
81139170:	de00012e 	bgeu	sp,et,81139178 <alt_get_errno+0xc>
81139174:	003b68fa 	trap	3
81139178:	dfc00115 	stw	ra,4(sp)
8113917c:	df000015 	stw	fp,0(sp)
81139180:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81139184:	d0a01017 	ldw	r2,-32704(gp)
81139188:	10000326 	beq	r2,zero,81139198 <alt_get_errno+0x2c>
8113918c:	d0a01017 	ldw	r2,-32704(gp)
81139190:	103ee83a 	callr	r2
81139194:	00000106 	br	8113919c <alt_get_errno+0x30>
81139198:	d0a07804 	addi	r2,gp,-32288
}
8113919c:	e037883a 	mov	sp,fp
811391a0:	dfc00117 	ldw	ra,4(sp)
811391a4:	df000017 	ldw	fp,0(sp)
811391a8:	dec00204 	addi	sp,sp,8
811391ac:	f800283a 	ret

811391b0 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
811391b0:	defff904 	addi	sp,sp,-28
811391b4:	de00012e 	bgeu	sp,et,811391bc <write+0xc>
811391b8:	003b68fa 	trap	3
811391bc:	dfc00615 	stw	ra,24(sp)
811391c0:	df000515 	stw	fp,20(sp)
811391c4:	df000504 	addi	fp,sp,20
811391c8:	e13ffd15 	stw	r4,-12(fp)
811391cc:	e17ffe15 	stw	r5,-8(fp)
811391d0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811391d4:	e0bffd17 	ldw	r2,-12(fp)
811391d8:	10000616 	blt	r2,zero,811391f4 <write+0x44>
811391dc:	e0bffd17 	ldw	r2,-12(fp)
811391e0:	10c00324 	muli	r3,r2,12
811391e4:	00a04574 	movhi	r2,33045
811391e8:	108bfb04 	addi	r2,r2,12268
811391ec:	1885883a 	add	r2,r3,r2
811391f0:	00000106 	br	811391f8 <write+0x48>
811391f4:	0005883a 	mov	r2,zero
811391f8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
811391fc:	e0bffb17 	ldw	r2,-20(fp)
81139200:	10002426 	beq	r2,zero,81139294 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81139204:	e0bffb17 	ldw	r2,-20(fp)
81139208:	10800217 	ldw	r2,8(r2)
8113920c:	108000cc 	andi	r2,r2,3
81139210:	10001b26 	beq	r2,zero,81139280 <write+0xd0>
81139214:	e0bffb17 	ldw	r2,-20(fp)
81139218:	10800017 	ldw	r2,0(r2)
8113921c:	10800617 	ldw	r2,24(r2)
81139220:	10001726 	beq	r2,zero,81139280 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81139224:	e17fff17 	ldw	r5,-4(fp)
81139228:	e13ffe17 	ldw	r4,-8(fp)
8113922c:	11385300 	call	81138530 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81139230:	e0bffb17 	ldw	r2,-20(fp)
81139234:	10800017 	ldw	r2,0(r2)
81139238:	10800617 	ldw	r2,24(r2)
8113923c:	e0ffff17 	ldw	r3,-4(fp)
81139240:	180d883a 	mov	r6,r3
81139244:	e17ffe17 	ldw	r5,-8(fp)
81139248:	e13ffb17 	ldw	r4,-20(fp)
8113924c:	103ee83a 	callr	r2
81139250:	e0bffc15 	stw	r2,-16(fp)
81139254:	e0bffc17 	ldw	r2,-16(fp)
81139258:	1000070e 	bge	r2,zero,81139278 <write+0xc8>
      {
        ALT_ERRNO = -rval;
8113925c:	113916c0 	call	8113916c <alt_get_errno>
81139260:	1007883a 	mov	r3,r2
81139264:	e0bffc17 	ldw	r2,-16(fp)
81139268:	0085c83a 	sub	r2,zero,r2
8113926c:	18800015 	stw	r2,0(r3)
        return -1;
81139270:	00bfffc4 	movi	r2,-1
81139274:	00000c06 	br	811392a8 <write+0xf8>
      }
      return rval;
81139278:	e0bffc17 	ldw	r2,-16(fp)
8113927c:	00000a06 	br	811392a8 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81139280:	113916c0 	call	8113916c <alt_get_errno>
81139284:	1007883a 	mov	r3,r2
81139288:	00800344 	movi	r2,13
8113928c:	18800015 	stw	r2,0(r3)
81139290:	00000406 	br	811392a4 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81139294:	113916c0 	call	8113916c <alt_get_errno>
81139298:	1007883a 	mov	r3,r2
8113929c:	00801444 	movi	r2,81
811392a0:	18800015 	stw	r2,0(r3)
  }
  return -1;
811392a4:	00bfffc4 	movi	r2,-1
}
811392a8:	e037883a 	mov	sp,fp
811392ac:	dfc00117 	ldw	ra,4(sp)
811392b0:	df000017 	ldw	fp,0(sp)
811392b4:	dec00204 	addi	sp,sp,8
811392b8:	f800283a 	ret

811392bc <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
811392bc:	deffde04 	addi	sp,sp,-136
811392c0:	de00012e 	bgeu	sp,et,811392c8 <__env_lock+0xc>
811392c4:	003b68fa 	trap	3
811392c8:	dfc02115 	stw	ra,132(sp)
811392cc:	df002015 	stw	fp,128(sp)
811392d0:	df002004 	addi	fp,sp,128
811392d4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
811392d8:	e0bfe104 	addi	r2,fp,-124
811392dc:	100b883a 	mov	r5,r2
811392e0:	01003fc4 	movi	r4,255
811392e4:	1141b1c0 	call	81141b1c <OSTaskQuery>
811392e8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
811392ec:	e0bffe83 	ldbu	r2,-6(fp)
811392f0:	10803fcc 	andi	r2,r2,255
811392f4:	10001e1e 	bne	r2,zero,81139370 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
811392f8:	e0bfed83 	ldbu	r2,-74(fp)
811392fc:	10803fcc 	andi	r2,r2,255
81139300:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81139304:	d0a08b17 	ldw	r2,-32212(gp)
81139308:	e0fffc04 	addi	r3,fp,-16
8113930c:	180b883a 	mov	r5,r3
81139310:	1009883a 	mov	r4,r2
81139314:	11402d40 	call	811402d4 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81139318:	e0bffe03 	ldbu	r2,-8(fp)
8113931c:	10803fcc 	andi	r2,r2,255
81139320:	10000726 	beq	r2,zero,81139340 <__env_lock+0x84>
81139324:	d0a01617 	ldw	r2,-32680(gp)
81139328:	e0ffe017 	ldw	r3,-128(fp)
8113932c:	1880041e 	bne	r3,r2,81139340 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81139330:	d0a08a17 	ldw	r2,-32216(gp)
81139334:	10800044 	addi	r2,r2,1
81139338:	d0a08a15 	stw	r2,-32216(gp)
8113933c:	00000a06 	br	81139368 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81139340:	d0a08b17 	ldw	r2,-32212(gp)
81139344:	e0fffe84 	addi	r3,fp,-6
81139348:	180d883a 	mov	r6,r3
8113934c:	000b883a 	mov	r5,zero
81139350:	1009883a 	mov	r4,r2
81139354:	113fe340 	call	8113fe34 <OSSemPend>
    locks  = 1;
81139358:	00800044 	movi	r2,1
8113935c:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
81139360:	e0bfe017 	ldw	r2,-128(fp)
81139364:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81139368:	0001883a 	nop
8113936c:	00000106 	br	81139374 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81139370:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81139374:	e037883a 	mov	sp,fp
81139378:	dfc00117 	ldw	ra,4(sp)
8113937c:	df000017 	ldw	fp,0(sp)
81139380:	dec00204 	addi	sp,sp,8
81139384:	f800283a 	ret

81139388 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81139388:	defffd04 	addi	sp,sp,-12
8113938c:	de00012e 	bgeu	sp,et,81139394 <__env_unlock+0xc>
81139390:	003b68fa 	trap	3
81139394:	dfc00215 	stw	ra,8(sp)
81139398:	df000115 	stw	fp,4(sp)
8113939c:	df000104 	addi	fp,sp,4
811393a0:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
811393a4:	d0a08a17 	ldw	r2,-32216(gp)
811393a8:	10000b26 	beq	r2,zero,811393d8 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
811393ac:	d0a08a17 	ldw	r2,-32216(gp)
811393b0:	10bfffc4 	addi	r2,r2,-1
811393b4:	d0a08a15 	stw	r2,-32216(gp)
811393b8:	d0a08a17 	ldw	r2,-32216(gp)
811393bc:	1000071e 	bne	r2,zero,811393dc <__env_unlock+0x54>
  {
    lockid = -1;
811393c0:	00bfffc4 	movi	r2,-1
811393c4:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
811393c8:	d0a08b17 	ldw	r2,-32212(gp)
811393cc:	1009883a 	mov	r4,r2
811393d0:	11401bc0 	call	811401bc <OSSemPost>
811393d4:	00000106 	br	811393dc <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
811393d8:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811393dc:	e037883a 	mov	sp,fp
811393e0:	dfc00117 	ldw	ra,4(sp)
811393e4:	df000017 	ldw	fp,0(sp)
811393e8:	dec00204 	addi	sp,sp,8
811393ec:	f800283a 	ret

811393f0 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
811393f0:	deffda04 	addi	sp,sp,-152
811393f4:	de00012e 	bgeu	sp,et,811393fc <__malloc_lock+0xc>
811393f8:	003b68fa 	trap	3
811393fc:	dfc02515 	stw	ra,148(sp)
81139400:	df002415 	stw	fp,144(sp)
81139404:	df002404 	addi	fp,sp,144
81139408:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113940c:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81139410:	d0a09103 	ldbu	r2,-32188(gp)
81139414:	10803fcc 	andi	r2,r2,255
81139418:	10800060 	cmpeqi	r2,r2,1
8113941c:	10003626 	beq	r2,zero,811394f8 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81139420:	e0bfe104 	addi	r2,fp,-124
81139424:	100b883a 	mov	r5,r2
81139428:	01003fc4 	movi	r4,255
8113942c:	1141b1c0 	call	81141b1c <OSTaskQuery>
81139430:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81139434:	e0bffe83 	ldbu	r2,-6(fp)
81139438:	10803fcc 	andi	r2,r2,255
8113943c:	1000301e 	bne	r2,zero,81139500 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81139440:	e0bfed83 	ldbu	r2,-74(fp)
81139444:	10803fcc 	andi	r2,r2,255
81139448:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
8113944c:	d0a08d17 	ldw	r2,-32204(gp)
81139450:	e0fffc04 	addi	r3,fp,-16
81139454:	180b883a 	mov	r5,r3
81139458:	1009883a 	mov	r4,r2
8113945c:	11402d40 	call	811402d4 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139460:	0005303a 	rdctl	r2,status
81139464:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139468:	e0ffe017 	ldw	r3,-128(fp)
8113946c:	00bfff84 	movi	r2,-2
81139470:	1884703a 	and	r2,r3,r2
81139474:	1001703a 	wrctl	status,r2
  
  return context;
81139478:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8113947c:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81139480:	e0bffc0b 	ldhu	r2,-16(fp)
81139484:	10bfffcc 	andi	r2,r2,65535
81139488:	10000b1e 	bne	r2,zero,811394b8 <__malloc_lock+0xc8>
8113948c:	d0a01717 	ldw	r2,-32676(gp)
81139490:	e0ffdd17 	ldw	r3,-140(fp)
81139494:	1880081e 	bne	r3,r2,811394b8 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81139498:	d0a08c17 	ldw	r2,-32208(gp)
8113949c:	10800044 	addi	r2,r2,1
811394a0:	d0a08c15 	stw	r2,-32208(gp)
811394a4:	e0bfdc17 	ldw	r2,-144(fp)
811394a8:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811394ac:	e0bfde17 	ldw	r2,-136(fp)
811394b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
811394b4:	00000e06 	br	811394f0 <__malloc_lock+0x100>
811394b8:	e0bfdc17 	ldw	r2,-144(fp)
811394bc:	e0bfdf15 	stw	r2,-132(fp)
811394c0:	e0bfdf17 	ldw	r2,-132(fp)
811394c4:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
811394c8:	d0a08d17 	ldw	r2,-32204(gp)
811394cc:	e0fffe84 	addi	r3,fp,-6
811394d0:	180d883a 	mov	r6,r3
811394d4:	000b883a 	mov	r5,zero
811394d8:	1009883a 	mov	r4,r2
811394dc:	113fe340 	call	8113fe34 <OSSemPend>
    locks  = 1;
811394e0:	00800044 	movi	r2,1
811394e4:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
811394e8:	e0bfdd17 	ldw	r2,-140(fp)
811394ec:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811394f0:	0001883a 	nop
811394f4:	00000306 	br	81139504 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
811394f8:	0001883a 	nop
811394fc:	00000106 	br	81139504 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81139500:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81139504:	e037883a 	mov	sp,fp
81139508:	dfc00117 	ldw	ra,4(sp)
8113950c:	df000017 	ldw	fp,0(sp)
81139510:	dec00204 	addi	sp,sp,8
81139514:	f800283a 	ret

81139518 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81139518:	defff804 	addi	sp,sp,-32
8113951c:	de00012e 	bgeu	sp,et,81139524 <__malloc_unlock+0xc>
81139520:	003b68fa 	trap	3
81139524:	dfc00715 	stw	ra,28(sp)
81139528:	df000615 	stw	fp,24(sp)
8113952c:	df000604 	addi	fp,sp,24
81139530:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139534:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81139538:	d0a09103 	ldbu	r2,-32188(gp)
8113953c:	10803fcc 	andi	r2,r2,255
81139540:	10800060 	cmpeqi	r2,r2,1
81139544:	10002326 	beq	r2,zero,811395d4 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139548:	0005303a 	rdctl	r2,status
8113954c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139550:	e0fffe17 	ldw	r3,-8(fp)
81139554:	00bfff84 	movi	r2,-2
81139558:	1884703a 	and	r2,r3,r2
8113955c:	1001703a 	wrctl	status,r2
  
  return context;
81139560:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81139564:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81139568:	d0a08c17 	ldw	r2,-32208(gp)
8113956c:	1000051e 	bne	r2,zero,81139584 <__malloc_unlock+0x6c>
81139570:	e0bffa17 	ldw	r2,-24(fp)
81139574:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139578:	e0bffb17 	ldw	r2,-20(fp)
8113957c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81139580:	00001506 	br	811395d8 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81139584:	d0a08c17 	ldw	r2,-32208(gp)
81139588:	10bfffc4 	addi	r2,r2,-1
8113958c:	d0a08c15 	stw	r2,-32208(gp)
81139590:	d0a08c17 	ldw	r2,-32208(gp)
81139594:	10000a1e 	bne	r2,zero,811395c0 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81139598:	00bfffc4 	movi	r2,-1
8113959c:	d0a01715 	stw	r2,-32676(gp)
811395a0:	e0bffa17 	ldw	r2,-24(fp)
811395a4:	e0bffc15 	stw	r2,-16(fp)
811395a8:	e0bffc17 	ldw	r2,-16(fp)
811395ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
811395b0:	d0a08d17 	ldw	r2,-32204(gp)
811395b4:	1009883a 	mov	r4,r2
811395b8:	11401bc0 	call	811401bc <OSSemPost>
811395bc:	00000606 	br	811395d8 <__malloc_unlock+0xc0>
811395c0:	e0bffa17 	ldw	r2,-24(fp)
811395c4:	e0bffd15 	stw	r2,-12(fp)
811395c8:	e0bffd17 	ldw	r2,-12(fp)
811395cc:	1001703a 	wrctl	status,r2
811395d0:	00000106 	br	811395d8 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
811395d4:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811395d8:	e037883a 	mov	sp,fp
811395dc:	dfc00117 	ldw	ra,4(sp)
811395e0:	df000017 	ldw	fp,0(sp)
811395e4:	dec00204 	addi	sp,sp,8
811395e8:	f800283a 	ret

811395ec <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811395ec:	defff704 	addi	sp,sp,-36
811395f0:	de00012e 	bgeu	sp,et,811395f8 <OSEventNameGet+0xc>
811395f4:	003b68fa 	trap	3
811395f8:	dfc00815 	stw	ra,32(sp)
811395fc:	df000715 	stw	fp,28(sp)
81139600:	df000704 	addi	fp,sp,28
81139604:	e13ffd15 	stw	r4,-12(fp)
81139608:	e17ffe15 	stw	r5,-8(fp)
8113960c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139610:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81139614:	e0bfff17 	ldw	r2,-4(fp)
81139618:	1000021e 	bne	r2,zero,81139624 <OSEventNameGet+0x38>
        return (0);
8113961c:	0005883a 	mov	r2,zero
81139620:	00003706 	br	81139700 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81139624:	e0bffd17 	ldw	r2,-12(fp)
81139628:	1000051e 	bne	r2,zero,81139640 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
8113962c:	e0bfff17 	ldw	r2,-4(fp)
81139630:	00c00104 	movi	r3,4
81139634:	10c00005 	stb	r3,0(r2)
        return (0);
81139638:	0005883a 	mov	r2,zero
8113963c:	00003006 	br	81139700 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81139640:	e0bffe17 	ldw	r2,-8(fp)
81139644:	1000051e 	bne	r2,zero,8113965c <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81139648:	e0bfff17 	ldw	r2,-4(fp)
8113964c:	00c00304 	movi	r3,12
81139650:	10c00005 	stb	r3,0(r2)
        return (0);
81139654:	0005883a 	mov	r2,zero
81139658:	00002906 	br	81139700 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113965c:	d0a0a103 	ldbu	r2,-32124(gp)
81139660:	10803fcc 	andi	r2,r2,255
81139664:	10000526 	beq	r2,zero,8113967c <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81139668:	e0bfff17 	ldw	r2,-4(fp)
8113966c:	00c00444 	movi	r3,17
81139670:	10c00005 	stb	r3,0(r2)
        return (0);
81139674:	0005883a 	mov	r2,zero
81139678:	00002106 	br	81139700 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8113967c:	e0bffd17 	ldw	r2,-12(fp)
81139680:	10800003 	ldbu	r2,0(r2)
81139684:	10803fcc 	andi	r2,r2,255
81139688:	10bfffc4 	addi	r2,r2,-1
8113968c:	10800128 	cmpgeui	r2,r2,4
81139690:	10000526 	beq	r2,zero,811396a8 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81139694:	e0bfff17 	ldw	r2,-4(fp)
81139698:	00c00044 	movi	r3,1
8113969c:	10c00005 	stb	r3,0(r2)
             return (0);
811396a0:	0005883a 	mov	r2,zero
811396a4:	00001606 	br	81139700 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811396a8:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811396ac:	0005303a 	rdctl	r2,status
811396b0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811396b4:	e0fffb17 	ldw	r3,-20(fp)
811396b8:	00bfff84 	movi	r2,-2
811396bc:	1884703a 	and	r2,r3,r2
811396c0:	1001703a 	wrctl	status,r2
  
  return context;
811396c4:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
811396c8:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
811396cc:	e0bffd17 	ldw	r2,-12(fp)
811396d0:	10800444 	addi	r2,r2,17
811396d4:	100b883a 	mov	r5,r2
811396d8:	e13ffe17 	ldw	r4,-8(fp)
811396dc:	113b0d80 	call	8113b0d8 <OS_StrCopy>
811396e0:	e0bffa05 	stb	r2,-24(fp)
811396e4:	e0bff917 	ldw	r2,-28(fp)
811396e8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396ec:	e0bffc17 	ldw	r2,-16(fp)
811396f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811396f4:	e0bfff17 	ldw	r2,-4(fp)
811396f8:	10000005 	stb	zero,0(r2)
    return (len);
811396fc:	e0bffa03 	ldbu	r2,-24(fp)
}
81139700:	e037883a 	mov	sp,fp
81139704:	dfc00117 	ldw	ra,4(sp)
81139708:	df000017 	ldw	fp,0(sp)
8113970c:	dec00204 	addi	sp,sp,8
81139710:	f800283a 	ret

81139714 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81139714:	defff604 	addi	sp,sp,-40
81139718:	de00012e 	bgeu	sp,et,81139720 <OSEventNameSet+0xc>
8113971c:	003b68fa 	trap	3
81139720:	dfc00915 	stw	ra,36(sp)
81139724:	df000815 	stw	fp,32(sp)
81139728:	df000804 	addi	fp,sp,32
8113972c:	e13ffd15 	stw	r4,-12(fp)
81139730:	e17ffe15 	stw	r5,-8(fp)
81139734:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139738:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113973c:	e0bfff17 	ldw	r2,-4(fp)
81139740:	10004026 	beq	r2,zero,81139844 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81139744:	e0bffd17 	ldw	r2,-12(fp)
81139748:	1000041e 	bne	r2,zero,8113975c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113974c:	e0bfff17 	ldw	r2,-4(fp)
81139750:	00c00104 	movi	r3,4
81139754:	10c00005 	stb	r3,0(r2)
        return;
81139758:	00003b06 	br	81139848 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113975c:	e0bffe17 	ldw	r2,-8(fp)
81139760:	1000041e 	bne	r2,zero,81139774 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81139764:	e0bfff17 	ldw	r2,-4(fp)
81139768:	00c00304 	movi	r3,12
8113976c:	10c00005 	stb	r3,0(r2)
        return;
81139770:	00003506 	br	81139848 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81139774:	d0a0a103 	ldbu	r2,-32124(gp)
81139778:	10803fcc 	andi	r2,r2,255
8113977c:	10000426 	beq	r2,zero,81139790 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81139780:	e0bfff17 	ldw	r2,-4(fp)
81139784:	00c00484 	movi	r3,18
81139788:	10c00005 	stb	r3,0(r2)
        return;
8113978c:	00002e06 	br	81139848 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81139790:	e0bffd17 	ldw	r2,-12(fp)
81139794:	10800003 	ldbu	r2,0(r2)
81139798:	10803fcc 	andi	r2,r2,255
8113979c:	10bfffc4 	addi	r2,r2,-1
811397a0:	10800128 	cmpgeui	r2,r2,4
811397a4:	10000426 	beq	r2,zero,811397b8 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
811397a8:	e0bfff17 	ldw	r2,-4(fp)
811397ac:	00c00044 	movi	r3,1
811397b0:	10c00005 	stb	r3,0(r2)
             return;
811397b4:	00002406 	br	81139848 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811397b8:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811397bc:	0005303a 	rdctl	r2,status
811397c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811397c4:	e0fffc17 	ldw	r3,-16(fp)
811397c8:	00bfff84 	movi	r2,-2
811397cc:	1884703a 	and	r2,r3,r2
811397d0:	1001703a 	wrctl	status,r2
  
  return context;
811397d4:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
811397d8:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
811397dc:	e13ffe17 	ldw	r4,-8(fp)
811397e0:	113b1540 	call	8113b154 <OS_StrLen>
811397e4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
811397e8:	e0bffa03 	ldbu	r2,-24(fp)
811397ec:	10800830 	cmpltui	r2,r2,32
811397f0:	1000081e 	bne	r2,zero,81139814 <OSEventNameSet+0x100>
811397f4:	e0bff817 	ldw	r2,-32(fp)
811397f8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811397fc:	e0bff917 	ldw	r2,-28(fp)
81139800:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
81139804:	e0bfff17 	ldw	r2,-4(fp)
81139808:	00c002c4 	movi	r3,11
8113980c:	10c00005 	stb	r3,0(r2)
        return;
81139810:	00000d06 	br	81139848 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
81139814:	e0bffd17 	ldw	r2,-12(fp)
81139818:	10800444 	addi	r2,r2,17
8113981c:	e17ffe17 	ldw	r5,-8(fp)
81139820:	1009883a 	mov	r4,r2
81139824:	113b0d80 	call	8113b0d8 <OS_StrCopy>
81139828:	e0bff817 	ldw	r2,-32(fp)
8113982c:	e0bffb15 	stw	r2,-20(fp)
81139830:	e0bffb17 	ldw	r2,-20(fp)
81139834:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139838:	e0bfff17 	ldw	r2,-4(fp)
8113983c:	10000005 	stb	zero,0(r2)
81139840:	00000106 	br	81139848 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81139844:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81139848:	e037883a 	mov	sp,fp
8113984c:	dfc00117 	ldw	ra,4(sp)
81139850:	df000017 	ldw	fp,0(sp)
81139854:	dec00204 	addi	sp,sp,8
81139858:	f800283a 	ret

8113985c <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8113985c:	deffed04 	addi	sp,sp,-76
81139860:	de00012e 	bgeu	sp,et,81139868 <OSEventPendMulti+0xc>
81139864:	003b68fa 	trap	3
81139868:	dfc01215 	stw	ra,72(sp)
8113986c:	df001115 	stw	fp,68(sp)
81139870:	df001104 	addi	fp,sp,68
81139874:	e13ffc15 	stw	r4,-16(fp)
81139878:	e17ffd15 	stw	r5,-12(fp)
8113987c:	e1bffe15 	stw	r6,-8(fp)
81139880:	3805883a 	mov	r2,r7
81139884:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81139888:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8113988c:	e0800217 	ldw	r2,8(fp)
81139890:	1000021e 	bne	r2,zero,8113989c <OSEventPendMulti+0x40>
        return (0);
81139894:	0005883a 	mov	r2,zero
81139898:	00015006 	br	81139ddc <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8113989c:	e0bffc17 	ldw	r2,-16(fp)
811398a0:	1000051e 	bne	r2,zero,811398b8 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
811398a4:	e0800217 	ldw	r2,8(fp)
811398a8:	00c00104 	movi	r3,4
811398ac:	10c00005 	stb	r3,0(r2)
        return (0);
811398b0:	0005883a 	mov	r2,zero
811398b4:	00014906 	br	81139ddc <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
811398b8:	e0bffd17 	ldw	r2,-12(fp)
811398bc:	1000051e 	bne	r2,zero,811398d4 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
811398c0:	e0800217 	ldw	r2,8(fp)
811398c4:	00c00104 	movi	r3,4
811398c8:	10c00005 	stb	r3,0(r2)
        return (0);
811398cc:	0005883a 	mov	r2,zero
811398d0:	00014206 	br	81139ddc <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
811398d4:	e0bffe17 	ldw	r2,-8(fp)
811398d8:	1000051e 	bne	r2,zero,811398f0 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
811398dc:	e0800217 	ldw	r2,8(fp)
811398e0:	00c00104 	movi	r3,4
811398e4:	10c00005 	stb	r3,0(r2)
        return (0);
811398e8:	0005883a 	mov	r2,zero
811398ec:	00013b06 	br	81139ddc <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811398f0:	e0bffd17 	ldw	r2,-12(fp)
811398f4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
811398f8:	e0bffc17 	ldw	r2,-16(fp)
811398fc:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81139900:	e0bfef17 	ldw	r2,-68(fp)
81139904:	10800017 	ldw	r2,0(r2)
81139908:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
8113990c:	00001506 	br	81139964 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81139910:	e0bff017 	ldw	r2,-64(fp)
81139914:	10800003 	ldbu	r2,0(r2)
81139918:	10803fcc 	andi	r2,r2,255
8113991c:	10c000a0 	cmpeqi	r3,r2,2
81139920:	1800071e 	bne	r3,zero,81139940 <OSEventPendMulti+0xe4>
81139924:	108000e0 	cmpeqi	r2,r2,3
81139928:	1000071e 	bne	r2,zero,81139948 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
8113992c:	e0800217 	ldw	r2,8(fp)
81139930:	00c00044 	movi	r3,1
81139934:	10c00005 	stb	r3,0(r2)
                 return (0);
81139938:	0005883a 	mov	r2,zero
8113993c:	00012706 	br	81139ddc <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81139940:	0001883a 	nop
81139944:	00000106 	br	8113994c <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81139948:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8113994c:	e0bfef17 	ldw	r2,-68(fp)
81139950:	10800104 	addi	r2,r2,4
81139954:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81139958:	e0bfef17 	ldw	r2,-68(fp)
8113995c:	10800017 	ldw	r2,0(r2)
81139960:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81139964:	e0bff017 	ldw	r2,-64(fp)
81139968:	103fe91e 	bne	r2,zero,81139910 <__reset+0xfb119910>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8113996c:	d0a0a103 	ldbu	r2,-32124(gp)
81139970:	10803fcc 	andi	r2,r2,255
81139974:	10000526 	beq	r2,zero,8113998c <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81139978:	e0800217 	ldw	r2,8(fp)
8113997c:	00c00084 	movi	r3,2
81139980:	10c00005 	stb	r3,0(r2)
        return (0);
81139984:	0005883a 	mov	r2,zero
81139988:	00011406 	br	81139ddc <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8113998c:	d0a08f03 	ldbu	r2,-32196(gp)
81139990:	10803fcc 	andi	r2,r2,255
81139994:	10000526 	beq	r2,zero,811399ac <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81139998:	e0800217 	ldw	r2,8(fp)
8113999c:	00c00344 	movi	r3,13
811399a0:	10c00005 	stb	r3,0(r2)
        return (0);
811399a4:	0005883a 	mov	r2,zero
811399a8:	00010c06 	br	81139ddc <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811399ac:	0005303a 	rdctl	r2,status
811399b0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811399b4:	e0fffb17 	ldw	r3,-20(fp)
811399b8:	00bfff84 	movi	r2,-2
811399bc:	1884703a 	and	r2,r3,r2
811399c0:	1001703a 	wrctl	status,r2
  
  return context;
811399c4:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
811399c8:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
811399cc:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
811399d0:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
811399d4:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
811399d8:	e0bffc17 	ldw	r2,-16(fp)
811399dc:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
811399e0:	e0bfef17 	ldw	r2,-68(fp)
811399e4:	10800017 	ldw	r2,0(r2)
811399e8:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811399ec:	00006406 	br	81139b80 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
811399f0:	e0bff017 	ldw	r2,-64(fp)
811399f4:	10800003 	ldbu	r2,0(r2)
811399f8:	10803fcc 	andi	r2,r2,255
811399fc:	10c000a0 	cmpeqi	r3,r2,2
81139a00:	18001f1e 	bne	r3,zero,81139a80 <OSEventPendMulti+0x224>
81139a04:	108000e0 	cmpeqi	r2,r2,3
81139a08:	10004c26 	beq	r2,zero,81139b3c <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81139a0c:	e0bff017 	ldw	r2,-64(fp)
81139a10:	1080020b 	ldhu	r2,8(r2)
81139a14:	10bfffcc 	andi	r2,r2,65535
81139a18:	10001526 	beq	r2,zero,81139a70 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81139a1c:	e0bff017 	ldw	r2,-64(fp)
81139a20:	1080020b 	ldhu	r2,8(r2)
81139a24:	10bfffc4 	addi	r2,r2,-1
81139a28:	1007883a 	mov	r3,r2
81139a2c:	e0bff017 	ldw	r2,-64(fp)
81139a30:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81139a34:	e0bffd17 	ldw	r2,-12(fp)
81139a38:	10c00104 	addi	r3,r2,4
81139a3c:	e0fffd15 	stw	r3,-12(fp)
81139a40:	e0fff017 	ldw	r3,-64(fp)
81139a44:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81139a48:	00800044 	movi	r2,1
81139a4c:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81139a50:	e0bffe17 	ldw	r2,-8(fp)
81139a54:	10c00104 	addi	r3,r2,4
81139a58:	e0fffe15 	stw	r3,-8(fp)
81139a5c:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81139a60:	e0bff18b 	ldhu	r2,-58(fp)
81139a64:	10800044 	addi	r2,r2,1
81139a68:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81139a6c:	00003e06 	br	81139b68 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81139a70:	e0bff203 	ldbu	r2,-56(fp)
81139a74:	10800054 	ori	r2,r2,1
81139a78:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81139a7c:	00003a06 	br	81139b68 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81139a80:	e0bff017 	ldw	r2,-64(fp)
81139a84:	10800117 	ldw	r2,4(r2)
81139a88:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81139a8c:	e0bff517 	ldw	r2,-44(fp)
81139a90:	1080058b 	ldhu	r2,22(r2)
81139a94:	10bfffcc 	andi	r2,r2,65535
81139a98:	10002426 	beq	r2,zero,81139b2c <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81139a9c:	e0bffe17 	ldw	r2,-8(fp)
81139aa0:	10c00104 	addi	r3,r2,4
81139aa4:	e0fffe15 	stw	r3,-8(fp)
81139aa8:	e0fff517 	ldw	r3,-44(fp)
81139aac:	18c00417 	ldw	r3,16(r3)
81139ab0:	19400104 	addi	r5,r3,4
81139ab4:	e13ff517 	ldw	r4,-44(fp)
81139ab8:	21400415 	stw	r5,16(r4)
81139abc:	18c00017 	ldw	r3,0(r3)
81139ac0:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81139ac4:	e0bff517 	ldw	r2,-44(fp)
81139ac8:	10c00417 	ldw	r3,16(r2)
81139acc:	e0bff517 	ldw	r2,-44(fp)
81139ad0:	10800217 	ldw	r2,8(r2)
81139ad4:	1880041e 	bne	r3,r2,81139ae8 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81139ad8:	e0bff517 	ldw	r2,-44(fp)
81139adc:	10c00117 	ldw	r3,4(r2)
81139ae0:	e0bff517 	ldw	r2,-44(fp)
81139ae4:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81139ae8:	e0bff517 	ldw	r2,-44(fp)
81139aec:	1080058b 	ldhu	r2,22(r2)
81139af0:	10bfffc4 	addi	r2,r2,-1
81139af4:	1007883a 	mov	r3,r2
81139af8:	e0bff517 	ldw	r2,-44(fp)
81139afc:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81139b00:	e0bffd17 	ldw	r2,-12(fp)
81139b04:	10c00104 	addi	r3,r2,4
81139b08:	e0fffd15 	stw	r3,-12(fp)
81139b0c:	e0fff017 	ldw	r3,-64(fp)
81139b10:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
81139b14:	00800044 	movi	r2,1
81139b18:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81139b1c:	e0bff18b 	ldhu	r2,-58(fp)
81139b20:	10800044 	addi	r2,r2,1
81139b24:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
81139b28:	00000f06 	br	81139b68 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81139b2c:	e0bff203 	ldbu	r2,-56(fp)
81139b30:	10800114 	ori	r2,r2,4
81139b34:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81139b38:	00000b06 	br	81139b68 <OSEventPendMulti+0x30c>
81139b3c:	e0bff317 	ldw	r2,-52(fp)
81139b40:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139b44:	e0bff417 	ldw	r2,-48(fp)
81139b48:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81139b4c:	e0bffd17 	ldw	r2,-12(fp)
81139b50:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81139b54:	e0800217 	ldw	r2,8(fp)
81139b58:	00c00044 	movi	r3,1
81139b5c:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81139b60:	e0bff18b 	ldhu	r2,-58(fp)
81139b64:	00009d06 	br	81139ddc <OSEventPendMulti+0x580>
        }
        pevents++;
81139b68:	e0bfef17 	ldw	r2,-68(fp)
81139b6c:	10800104 	addi	r2,r2,4
81139b70:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81139b74:	e0bfef17 	ldw	r2,-68(fp)
81139b78:	10800017 	ldw	r2,0(r2)
81139b7c:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81139b80:	e0bff017 	ldw	r2,-64(fp)
81139b84:	103f9a1e 	bne	r2,zero,811399f0 <__reset+0xfb1199f0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81139b88:	e0bff103 	ldbu	r2,-60(fp)
81139b8c:	10800058 	cmpnei	r2,r2,1
81139b90:	10000a1e 	bne	r2,zero,81139bbc <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81139b94:	e0bffd17 	ldw	r2,-12(fp)
81139b98:	10000015 	stw	zero,0(r2)
81139b9c:	e0bff317 	ldw	r2,-52(fp)
81139ba0:	e0bff615 	stw	r2,-40(fp)
81139ba4:	e0bff617 	ldw	r2,-40(fp)
81139ba8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81139bac:	e0800217 	ldw	r2,8(fp)
81139bb0:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81139bb4:	e0bff18b 	ldhu	r2,-58(fp)
81139bb8:	00008806 	br	81139ddc <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81139bbc:	d0a0a217 	ldw	r2,-32120(gp)
81139bc0:	d0e0a217 	ldw	r3,-32120(gp)
81139bc4:	19000c03 	ldbu	r4,48(r3)
81139bc8:	e0fff203 	ldbu	r3,-56(fp)
81139bcc:	20c6b03a 	or	r3,r4,r3
81139bd0:	1809883a 	mov	r4,r3
81139bd4:	00ffe004 	movi	r3,-128
81139bd8:	20c6b03a 	or	r3,r4,r3
81139bdc:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139be0:	d0a0a217 	ldw	r2,-32120(gp)
81139be4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81139be8:	d0a0a217 	ldw	r2,-32120(gp)
81139bec:	e0ffff0b 	ldhu	r3,-4(fp)
81139bf0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81139bf4:	e13ffc17 	ldw	r4,-16(fp)
81139bf8:	113a7800 	call	8113a780 <OS_EventTaskWaitMulti>
81139bfc:	e0bff317 	ldw	r2,-52(fp)
81139c00:	e0bff915 	stw	r2,-28(fp)
81139c04:	e0bff917 	ldw	r2,-28(fp)
81139c08:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81139c0c:	113af840 	call	8113af84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c10:	0005303a 	rdctl	r2,status
81139c14:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c18:	e0fff717 	ldw	r3,-36(fp)
81139c1c:	00bfff84 	movi	r2,-2
81139c20:	1884703a 	and	r2,r3,r2
81139c24:	1001703a 	wrctl	status,r2
  
  return context;
81139c28:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81139c2c:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81139c30:	d0a0a217 	ldw	r2,-32120(gp)
81139c34:	10800c43 	ldbu	r2,49(r2)
81139c38:	10803fcc 	andi	r2,r2,255
81139c3c:	10000226 	beq	r2,zero,81139c48 <OSEventPendMulti+0x3ec>
81139c40:	108000a0 	cmpeqi	r2,r2,2
81139c44:	10001826 	beq	r2,zero,81139ca8 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81139c48:	d0a0a217 	ldw	r2,-32120(gp)
81139c4c:	10800717 	ldw	r2,28(r2)
81139c50:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81139c54:	e0bff017 	ldw	r2,-64(fp)
81139c58:	10000b26 	beq	r2,zero,81139c88 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81139c5c:	e0bffd17 	ldw	r2,-12(fp)
81139c60:	10c00104 	addi	r3,r2,4
81139c64:	e0fffd15 	stw	r3,-12(fp)
81139c68:	e0fff017 	ldw	r3,-64(fp)
81139c6c:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81139c70:	e0bffd17 	ldw	r2,-12(fp)
81139c74:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81139c78:	e0bff18b 	ldhu	r2,-58(fp)
81139c7c:	10800044 	addi	r2,r2,1
81139c80:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81139c84:	00000d06 	br	81139cbc <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81139c88:	d0a0a217 	ldw	r2,-32120(gp)
81139c8c:	00c00044 	movi	r3,1
81139c90:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81139c94:	d0a0a217 	ldw	r2,-32120(gp)
81139c98:	e17ffc17 	ldw	r5,-16(fp)
81139c9c:	1009883a 	mov	r4,r2
81139ca0:	113a9980 	call	8113a998 <OS_EventTaskRemoveMulti>
             }
			 break;
81139ca4:	00000506 	br	81139cbc <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81139ca8:	d0a0a217 	ldw	r2,-32120(gp)
81139cac:	e17ffc17 	ldw	r5,-16(fp)
81139cb0:	1009883a 	mov	r4,r2
81139cb4:	113a9980 	call	8113a998 <OS_EventTaskRemoveMulti>
             break;
81139cb8:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81139cbc:	d0a0a217 	ldw	r2,-32120(gp)
81139cc0:	10800c43 	ldbu	r2,49(r2)
81139cc4:	10803fcc 	andi	r2,r2,255
81139cc8:	10000326 	beq	r2,zero,81139cd8 <OSEventPendMulti+0x47c>
81139ccc:	108000a0 	cmpeqi	r2,r2,2
81139cd0:	1000231e 	bne	r2,zero,81139d60 <OSEventPendMulti+0x504>
81139cd4:	00002a06 	br	81139d80 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81139cd8:	e0bff017 	ldw	r2,-64(fp)
81139cdc:	10800003 	ldbu	r2,0(r2)
81139ce0:	10803fcc 	andi	r2,r2,255
81139ce4:	0080100e 	bge	zero,r2,81139d28 <OSEventPendMulti+0x4cc>
81139ce8:	10c000d0 	cmplti	r3,r2,3
81139cec:	1800071e 	bne	r3,zero,81139d0c <OSEventPendMulti+0x4b0>
81139cf0:	108000e0 	cmpeqi	r2,r2,3
81139cf4:	10000c26 	beq	r2,zero,81139d28 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81139cf8:	e0bffe17 	ldw	r2,-8(fp)
81139cfc:	10c00104 	addi	r3,r2,4
81139d00:	e0fffe15 	stw	r3,-8(fp)
81139d04:	10000015 	stw	zero,0(r2)
                      break;
81139d08:	00001206 	br	81139d54 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81139d0c:	e0bffe17 	ldw	r2,-8(fp)
81139d10:	10c00104 	addi	r3,r2,4
81139d14:	e0fffe15 	stw	r3,-8(fp)
81139d18:	d0e0a217 	ldw	r3,-32120(gp)
81139d1c:	18c00917 	ldw	r3,36(r3)
81139d20:	10c00015 	stw	r3,0(r2)
                      break;
81139d24:	00000b06 	br	81139d54 <OSEventPendMulti+0x4f8>
81139d28:	e0bff317 	ldw	r2,-52(fp)
81139d2c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d30:	e0bff817 	ldw	r2,-32(fp)
81139d34:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81139d38:	e0bffd17 	ldw	r2,-12(fp)
81139d3c:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81139d40:	e0800217 	ldw	r2,8(fp)
81139d44:	00c00044 	movi	r3,1
81139d48:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81139d4c:	e0bff18b 	ldhu	r2,-58(fp)
81139d50:	00002206 	br	81139ddc <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81139d54:	e0800217 	ldw	r2,8(fp)
81139d58:	10000005 	stb	zero,0(r2)
             break;
81139d5c:	00001006 	br	81139da0 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81139d60:	e0bffe17 	ldw	r2,-8(fp)
81139d64:	10c00104 	addi	r3,r2,4
81139d68:	e0fffe15 	stw	r3,-8(fp)
81139d6c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81139d70:	e0800217 	ldw	r2,8(fp)
81139d74:	00c00384 	movi	r3,14
81139d78:	10c00005 	stb	r3,0(r2)
             break;
81139d7c:	00000806 	br	81139da0 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81139d80:	e0bffe17 	ldw	r2,-8(fp)
81139d84:	10c00104 	addi	r3,r2,4
81139d88:	e0fffe15 	stw	r3,-8(fp)
81139d8c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81139d90:	e0800217 	ldw	r2,8(fp)
81139d94:	00c00284 	movi	r3,10
81139d98:	10c00005 	stb	r3,0(r2)
             break;
81139d9c:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81139da0:	d0a0a217 	ldw	r2,-32120(gp)
81139da4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81139da8:	d0a0a217 	ldw	r2,-32120(gp)
81139dac:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81139db0:	d0a0a217 	ldw	r2,-32120(gp)
81139db4:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81139db8:	d0a0a217 	ldw	r2,-32120(gp)
81139dbc:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81139dc0:	d0a0a217 	ldw	r2,-32120(gp)
81139dc4:	10000915 	stw	zero,36(r2)
81139dc8:	e0bff317 	ldw	r2,-52(fp)
81139dcc:	e0bffa15 	stw	r2,-24(fp)
81139dd0:	e0bffa17 	ldw	r2,-24(fp)
81139dd4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81139dd8:	e0bff18b 	ldhu	r2,-58(fp)
}
81139ddc:	e037883a 	mov	sp,fp
81139de0:	dfc00117 	ldw	ra,4(sp)
81139de4:	df000017 	ldw	fp,0(sp)
81139de8:	dec00204 	addi	sp,sp,8
81139dec:	f800283a 	ret

81139df0 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81139df0:	defffe04 	addi	sp,sp,-8
81139df4:	de00012e 	bgeu	sp,et,81139dfc <OSInit+0xc>
81139df8:	003b68fa 	trap	3
81139dfc:	dfc00115 	stw	ra,4(sp)
81139e00:	df000015 	stw	fp,0(sp)
81139e04:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81139e08:	114c2f40 	call	8114c2f4 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81139e0c:	113abf80 	call	8113abf8 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81139e10:	113ac480 	call	8113ac48 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81139e14:	113adcc0 	call	8113adcc <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81139e18:	113ab100 	call	8113ab10 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81139e1c:	113cd8c0 	call	8113cd8c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81139e20:	113d6d40 	call	8113d6d4 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81139e24:	113f9a40 	call	8113f9a4 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81139e28:	113acbc0 	call	8113acbc <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81139e2c:	113ad440 	call	8113ad44 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81139e30:	1142d480 	call	81142d48 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81139e34:	114c3200 	call	8114c320 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81139e38:	113b6a80 	call	8113b6a8 <OSDebugInit>
#endif
}
81139e3c:	0001883a 	nop
81139e40:	e037883a 	mov	sp,fp
81139e44:	dfc00117 	ldw	ra,4(sp)
81139e48:	df000017 	ldw	fp,0(sp)
81139e4c:	dec00204 	addi	sp,sp,8
81139e50:	f800283a 	ret

81139e54 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81139e54:	deffff04 	addi	sp,sp,-4
81139e58:	de00012e 	bgeu	sp,et,81139e60 <OSIntEnter+0xc>
81139e5c:	003b68fa 	trap	3
81139e60:	df000015 	stw	fp,0(sp)
81139e64:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81139e68:	d0a09103 	ldbu	r2,-32188(gp)
81139e6c:	10803fcc 	andi	r2,r2,255
81139e70:	10800058 	cmpnei	r2,r2,1
81139e74:	1000071e 	bne	r2,zero,81139e94 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81139e78:	d0a0a103 	ldbu	r2,-32124(gp)
81139e7c:	10803fcc 	andi	r2,r2,255
81139e80:	10803fe0 	cmpeqi	r2,r2,255
81139e84:	1000031e 	bne	r2,zero,81139e94 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81139e88:	d0a0a103 	ldbu	r2,-32124(gp)
81139e8c:	10800044 	addi	r2,r2,1
81139e90:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
81139e94:	0001883a 	nop
81139e98:	e037883a 	mov	sp,fp
81139e9c:	df000017 	ldw	fp,0(sp)
81139ea0:	dec00104 	addi	sp,sp,4
81139ea4:	f800283a 	ret

81139ea8 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81139ea8:	defffb04 	addi	sp,sp,-20
81139eac:	de00012e 	bgeu	sp,et,81139eb4 <OSIntExit+0xc>
81139eb0:	003b68fa 	trap	3
81139eb4:	dfc00415 	stw	ra,16(sp)
81139eb8:	df000315 	stw	fp,12(sp)
81139ebc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139ec0:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81139ec4:	d0a09103 	ldbu	r2,-32188(gp)
81139ec8:	10803fcc 	andi	r2,r2,255
81139ecc:	10800058 	cmpnei	r2,r2,1
81139ed0:	10002f1e 	bne	r2,zero,81139f90 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139ed4:	0005303a 	rdctl	r2,status
81139ed8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139edc:	e0ffff17 	ldw	r3,-4(fp)
81139ee0:	00bfff84 	movi	r2,-2
81139ee4:	1884703a 	and	r2,r3,r2
81139ee8:	1001703a 	wrctl	status,r2
  
  return context;
81139eec:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81139ef0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81139ef4:	d0a0a103 	ldbu	r2,-32124(gp)
81139ef8:	10803fcc 	andi	r2,r2,255
81139efc:	10000326 	beq	r2,zero,81139f0c <OSIntExit+0x64>
            OSIntNesting--;
81139f00:	d0a0a103 	ldbu	r2,-32124(gp)
81139f04:	10bfffc4 	addi	r2,r2,-1
81139f08:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81139f0c:	d0a0a103 	ldbu	r2,-32124(gp)
81139f10:	10803fcc 	andi	r2,r2,255
81139f14:	10001a1e 	bne	r2,zero,81139f80 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81139f18:	d0a08f03 	ldbu	r2,-32196(gp)
81139f1c:	10803fcc 	andi	r2,r2,255
81139f20:	1000171e 	bne	r2,zero,81139f80 <OSIntExit+0xd8>
                OS_SchedNew();
81139f24:	113b05c0 	call	8113b05c <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81139f28:	d0e09383 	ldbu	r3,-32178(gp)
81139f2c:	d0a093c3 	ldbu	r2,-32177(gp)
81139f30:	18c03fcc 	andi	r3,r3,255
81139f34:	10803fcc 	andi	r2,r2,255
81139f38:	18801126 	beq	r3,r2,81139f80 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81139f3c:	d0a09383 	ldbu	r2,-32178(gp)
81139f40:	10c03fcc 	andi	r3,r2,255
81139f44:	00a045f4 	movhi	r2,33047
81139f48:	10b81c04 	addi	r2,r2,-8080
81139f4c:	18c7883a 	add	r3,r3,r3
81139f50:	18c7883a 	add	r3,r3,r3
81139f54:	10c5883a 	add	r2,r2,r3
81139f58:	10800017 	ldw	r2,0(r2)
81139f5c:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81139f60:	d0a09c17 	ldw	r2,-32144(gp)
81139f64:	10c00e17 	ldw	r3,56(r2)
81139f68:	18c00044 	addi	r3,r3,1
81139f6c:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81139f70:	d0a09617 	ldw	r2,-32168(gp)
81139f74:	10800044 	addi	r2,r2,1
81139f78:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81139f7c:	114bfb40 	call	8114bfb4 <OSCtxSw>
81139f80:	e0bffd17 	ldw	r2,-12(fp)
81139f84:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f88:	e0bffe17 	ldw	r2,-8(fp)
81139f8c:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81139f90:	0001883a 	nop
81139f94:	e037883a 	mov	sp,fp
81139f98:	dfc00117 	ldw	ra,4(sp)
81139f9c:	df000017 	ldw	fp,0(sp)
81139fa0:	dec00204 	addi	sp,sp,8
81139fa4:	f800283a 	ret

81139fa8 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81139fa8:	defffc04 	addi	sp,sp,-16
81139fac:	de00012e 	bgeu	sp,et,81139fb4 <OSSchedLock+0xc>
81139fb0:	003b68fa 	trap	3
81139fb4:	df000315 	stw	fp,12(sp)
81139fb8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139fbc:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81139fc0:	d0a09103 	ldbu	r2,-32188(gp)
81139fc4:	10803fcc 	andi	r2,r2,255
81139fc8:	10800058 	cmpnei	r2,r2,1
81139fcc:	1000161e 	bne	r2,zero,8113a028 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139fd0:	0005303a 	rdctl	r2,status
81139fd4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139fd8:	e0ffff17 	ldw	r3,-4(fp)
81139fdc:	00bfff84 	movi	r2,-2
81139fe0:	1884703a 	and	r2,r3,r2
81139fe4:	1001703a 	wrctl	status,r2
  
  return context;
81139fe8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81139fec:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81139ff0:	d0a0a103 	ldbu	r2,-32124(gp)
81139ff4:	10803fcc 	andi	r2,r2,255
81139ff8:	1000071e 	bne	r2,zero,8113a018 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81139ffc:	d0a08f03 	ldbu	r2,-32196(gp)
8113a000:	10803fcc 	andi	r2,r2,255
8113a004:	10803fe0 	cmpeqi	r2,r2,255
8113a008:	1000031e 	bne	r2,zero,8113a018 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
8113a00c:	d0a08f03 	ldbu	r2,-32196(gp)
8113a010:	10800044 	addi	r2,r2,1
8113a014:	d0a08f05 	stb	r2,-32196(gp)
8113a018:	e0bffd17 	ldw	r2,-12(fp)
8113a01c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a020:	e0bffe17 	ldw	r2,-8(fp)
8113a024:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113a028:	0001883a 	nop
8113a02c:	e037883a 	mov	sp,fp
8113a030:	df000017 	ldw	fp,0(sp)
8113a034:	dec00104 	addi	sp,sp,4
8113a038:	f800283a 	ret

8113a03c <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
8113a03c:	defff804 	addi	sp,sp,-32
8113a040:	de00012e 	bgeu	sp,et,8113a048 <OSSchedUnlock+0xc>
8113a044:	003b68fa 	trap	3
8113a048:	dfc00715 	stw	ra,28(sp)
8113a04c:	df000615 	stw	fp,24(sp)
8113a050:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a054:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8113a058:	d0a09103 	ldbu	r2,-32188(gp)
8113a05c:	10803fcc 	andi	r2,r2,255
8113a060:	10800058 	cmpnei	r2,r2,1
8113a064:	1000281e 	bne	r2,zero,8113a108 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a068:	0005303a 	rdctl	r2,status
8113a06c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a070:	e0ffff17 	ldw	r3,-4(fp)
8113a074:	00bfff84 	movi	r2,-2
8113a078:	1884703a 	and	r2,r3,r2
8113a07c:	1001703a 	wrctl	status,r2
  
  return context;
8113a080:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113a084:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8113a088:	d0a08f03 	ldbu	r2,-32196(gp)
8113a08c:	10803fcc 	andi	r2,r2,255
8113a090:	10001926 	beq	r2,zero,8113a0f8 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8113a094:	d0a08f03 	ldbu	r2,-32196(gp)
8113a098:	10bfffc4 	addi	r2,r2,-1
8113a09c:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8113a0a0:	d0a08f03 	ldbu	r2,-32196(gp)
8113a0a4:	10803fcc 	andi	r2,r2,255
8113a0a8:	10000e1e 	bne	r2,zero,8113a0e4 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
8113a0ac:	d0a0a103 	ldbu	r2,-32124(gp)
8113a0b0:	10803fcc 	andi	r2,r2,255
8113a0b4:	1000061e 	bne	r2,zero,8113a0d0 <OSSchedUnlock+0x94>
8113a0b8:	e0bffa17 	ldw	r2,-24(fp)
8113a0bc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0c0:	e0bffb17 	ldw	r2,-20(fp)
8113a0c4:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8113a0c8:	113af840 	call	8113af84 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
8113a0cc:	00000e06 	br	8113a108 <OSSchedUnlock+0xcc>
8113a0d0:	e0bffa17 	ldw	r2,-24(fp)
8113a0d4:	e0bffc15 	stw	r2,-16(fp)
8113a0d8:	e0bffc17 	ldw	r2,-16(fp)
8113a0dc:	1001703a 	wrctl	status,r2
8113a0e0:	00000906 	br	8113a108 <OSSchedUnlock+0xcc>
8113a0e4:	e0bffa17 	ldw	r2,-24(fp)
8113a0e8:	e0bffd15 	stw	r2,-12(fp)
8113a0ec:	e0bffd17 	ldw	r2,-12(fp)
8113a0f0:	1001703a 	wrctl	status,r2
8113a0f4:	00000406 	br	8113a108 <OSSchedUnlock+0xcc>
8113a0f8:	e0bffa17 	ldw	r2,-24(fp)
8113a0fc:	e0bffe15 	stw	r2,-8(fp)
8113a100:	e0bffe17 	ldw	r2,-8(fp)
8113a104:	1001703a 	wrctl	status,r2
8113a108:	0001883a 	nop
8113a10c:	e037883a 	mov	sp,fp
8113a110:	dfc00117 	ldw	ra,4(sp)
8113a114:	df000017 	ldw	fp,0(sp)
8113a118:	dec00204 	addi	sp,sp,8
8113a11c:	f800283a 	ret

8113a120 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
8113a120:	defffe04 	addi	sp,sp,-8
8113a124:	de00012e 	bgeu	sp,et,8113a12c <OSStart+0xc>
8113a128:	003b68fa 	trap	3
8113a12c:	dfc00115 	stw	ra,4(sp)
8113a130:	df000015 	stw	fp,0(sp)
8113a134:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8113a138:	d0a09103 	ldbu	r2,-32188(gp)
8113a13c:	10803fcc 	andi	r2,r2,255
8113a140:	10000f1e 	bne	r2,zero,8113a180 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8113a144:	113b05c0 	call	8113b05c <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8113a148:	d0a09383 	ldbu	r2,-32178(gp)
8113a14c:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
8113a150:	d0a09383 	ldbu	r2,-32178(gp)
8113a154:	10c03fcc 	andi	r3,r2,255
8113a158:	00a045f4 	movhi	r2,33047
8113a15c:	10b81c04 	addi	r2,r2,-8080
8113a160:	18c7883a 	add	r3,r3,r3
8113a164:	18c7883a 	add	r3,r3,r3
8113a168:	10c5883a 	add	r2,r2,r3
8113a16c:	10800017 	ldw	r2,0(r2)
8113a170:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
8113a174:	d0a09c17 	ldw	r2,-32144(gp)
8113a178:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8113a17c:	114c0500 	call	8114c050 <OSStartHighRdy>
    }
}
8113a180:	0001883a 	nop
8113a184:	e037883a 	mov	sp,fp
8113a188:	dfc00117 	ldw	ra,4(sp)
8113a18c:	df000017 	ldw	fp,0(sp)
8113a190:	dec00204 	addi	sp,sp,8
8113a194:	f800283a 	ret

8113a198 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8113a198:	defff904 	addi	sp,sp,-28
8113a19c:	de00012e 	bgeu	sp,et,8113a1a4 <OSStatInit+0xc>
8113a1a0:	003b68fa 	trap	3
8113a1a4:	dfc00615 	stw	ra,24(sp)
8113a1a8:	df000515 	stw	fp,20(sp)
8113a1ac:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a1b0:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8113a1b4:	01000084 	movi	r4,2
8113a1b8:	1141cc00 	call	81141cc0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a1bc:	0005303a 	rdctl	r2,status
8113a1c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a1c4:	e0fffc17 	ldw	r3,-16(fp)
8113a1c8:	00bfff84 	movi	r2,-2
8113a1cc:	1884703a 	and	r2,r3,r2
8113a1d0:	1001703a 	wrctl	status,r2
  
  return context;
8113a1d4:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8113a1d8:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8113a1dc:	d0209215 	stw	zero,-32184(gp)
8113a1e0:	e0bffb17 	ldw	r2,-20(fp)
8113a1e4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a1e8:	e0bffd17 	ldw	r2,-12(fp)
8113a1ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8113a1f0:	01001904 	movi	r4,100
8113a1f4:	1141cc00 	call	81141cc0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a1f8:	0005303a 	rdctl	r2,status
8113a1fc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a200:	e0fffe17 	ldw	r3,-8(fp)
8113a204:	00bfff84 	movi	r2,-2
8113a208:	1884703a 	and	r2,r3,r2
8113a20c:	1001703a 	wrctl	status,r2
  
  return context;
8113a210:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8113a214:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8113a218:	d0a09217 	ldw	r2,-32184(gp)
8113a21c:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
8113a220:	00800044 	movi	r2,1
8113a224:	d0a0a705 	stb	r2,-32100(gp)
8113a228:	e0bffb17 	ldw	r2,-20(fp)
8113a22c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a230:	e0bfff17 	ldw	r2,-4(fp)
8113a234:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113a238:	0001883a 	nop
8113a23c:	e037883a 	mov	sp,fp
8113a240:	dfc00117 	ldw	ra,4(sp)
8113a244:	df000017 	ldw	fp,0(sp)
8113a248:	dec00204 	addi	sp,sp,8
8113a24c:	f800283a 	ret

8113a250 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
8113a250:	defff704 	addi	sp,sp,-36
8113a254:	de00012e 	bgeu	sp,et,8113a25c <OSTimeTick+0xc>
8113a258:	003b68fa 	trap	3
8113a25c:	dfc00815 	stw	ra,32(sp)
8113a260:	df000715 	stw	fp,28(sp)
8113a264:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113a268:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8113a26c:	114c2a00 	call	8114c2a0 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a270:	0005303a 	rdctl	r2,status
8113a274:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a278:	e0fffd17 	ldw	r3,-12(fp)
8113a27c:	00bfff84 	movi	r2,-2
8113a280:	1884703a 	and	r2,r3,r2
8113a284:	1001703a 	wrctl	status,r2
  
  return context;
8113a288:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8113a28c:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8113a290:	d0a0a417 	ldw	r2,-32112(gp)
8113a294:	10800044 	addi	r2,r2,1
8113a298:	d0a0a415 	stw	r2,-32112(gp)
8113a29c:	e0bffb17 	ldw	r2,-20(fp)
8113a2a0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a2a4:	e0bfff17 	ldw	r2,-4(fp)
8113a2a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8113a2ac:	d0a09103 	ldbu	r2,-32188(gp)
8113a2b0:	10803fcc 	andi	r2,r2,255
8113a2b4:	10800058 	cmpnei	r2,r2,1
8113a2b8:	10006a1e 	bne	r2,zero,8113a464 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8113a2bc:	d0a09503 	ldbu	r2,-32172(gp)
8113a2c0:	10803fcc 	andi	r2,r2,255
8113a2c4:	10c00060 	cmpeqi	r3,r2,1
8113a2c8:	1800061e 	bne	r3,zero,8113a2e4 <OSTimeTick+0x94>
8113a2cc:	10c000a0 	cmpeqi	r3,r2,2
8113a2d0:	1800061e 	bne	r3,zero,8113a2ec <OSTimeTick+0x9c>
8113a2d4:	10000a1e 	bne	r2,zero,8113a300 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8113a2d8:	00800044 	movi	r2,1
8113a2dc:	e0bffa05 	stb	r2,-24(fp)
                 break;
8113a2e0:	00000b06 	br	8113a310 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8113a2e4:	e03ffa05 	stb	zero,-24(fp)
                 break;
8113a2e8:	00000906 	br	8113a310 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8113a2ec:	00800044 	movi	r2,1
8113a2f0:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8113a2f4:	00800044 	movi	r2,1
8113a2f8:	d0a09505 	stb	r2,-32172(gp)
                 break;
8113a2fc:	00000406 	br	8113a310 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8113a300:	00800044 	movi	r2,1
8113a304:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8113a308:	d0209505 	stb	zero,-32172(gp)
                 break;
8113a30c:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8113a310:	e0bffa03 	ldbu	r2,-24(fp)
8113a314:	10005226 	beq	r2,zero,8113a460 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8113a318:	d0a09417 	ldw	r2,-32176(gp)
8113a31c:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113a320:	00004906 	br	8113a448 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a324:	0005303a 	rdctl	r2,status
8113a328:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a32c:	e0fffc17 	ldw	r3,-16(fp)
8113a330:	00bfff84 	movi	r2,-2
8113a334:	1884703a 	and	r2,r3,r2
8113a338:	1001703a 	wrctl	status,r2
  
  return context;
8113a33c:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
8113a340:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8113a344:	e0bff917 	ldw	r2,-28(fp)
8113a348:	10800b8b 	ldhu	r2,46(r2)
8113a34c:	10bfffcc 	andi	r2,r2,65535
8113a350:	10003626 	beq	r2,zero,8113a42c <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8113a354:	e0bff917 	ldw	r2,-28(fp)
8113a358:	10800b8b 	ldhu	r2,46(r2)
8113a35c:	10bfffc4 	addi	r2,r2,-1
8113a360:	1007883a 	mov	r3,r2
8113a364:	e0bff917 	ldw	r2,-28(fp)
8113a368:	10c00b8d 	sth	r3,46(r2)
8113a36c:	e0bff917 	ldw	r2,-28(fp)
8113a370:	10800b8b 	ldhu	r2,46(r2)
8113a374:	10bfffcc 	andi	r2,r2,65535
8113a378:	10002c1e 	bne	r2,zero,8113a42c <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113a37c:	e0bff917 	ldw	r2,-28(fp)
8113a380:	10800c03 	ldbu	r2,48(r2)
8113a384:	10803fcc 	andi	r2,r2,255
8113a388:	10800dcc 	andi	r2,r2,55
8113a38c:	10000b26 	beq	r2,zero,8113a3bc <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
8113a390:	e0bff917 	ldw	r2,-28(fp)
8113a394:	10c00c03 	ldbu	r3,48(r2)
8113a398:	00bff204 	movi	r2,-56
8113a39c:	1884703a 	and	r2,r3,r2
8113a3a0:	1007883a 	mov	r3,r2
8113a3a4:	e0bff917 	ldw	r2,-28(fp)
8113a3a8:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8113a3ac:	e0bff917 	ldw	r2,-28(fp)
8113a3b0:	00c00044 	movi	r3,1
8113a3b4:	10c00c45 	stb	r3,49(r2)
8113a3b8:	00000206 	br	8113a3c4 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113a3bc:	e0bff917 	ldw	r2,-28(fp)
8113a3c0:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8113a3c4:	e0bff917 	ldw	r2,-28(fp)
8113a3c8:	10800c03 	ldbu	r2,48(r2)
8113a3cc:	10803fcc 	andi	r2,r2,255
8113a3d0:	1080020c 	andi	r2,r2,8
8113a3d4:	1000151e 	bne	r2,zero,8113a42c <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8113a3d8:	e0bff917 	ldw	r2,-28(fp)
8113a3dc:	10c00d83 	ldbu	r3,54(r2)
8113a3e0:	d0a09e03 	ldbu	r2,-32136(gp)
8113a3e4:	1884b03a 	or	r2,r3,r2
8113a3e8:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113a3ec:	e0bff917 	ldw	r2,-28(fp)
8113a3f0:	10800d03 	ldbu	r2,52(r2)
8113a3f4:	10c03fcc 	andi	r3,r2,255
8113a3f8:	e0bff917 	ldw	r2,-28(fp)
8113a3fc:	10800d03 	ldbu	r2,52(r2)
8113a400:	11003fcc 	andi	r4,r2,255
8113a404:	d0a09e44 	addi	r2,gp,-32135
8113a408:	2085883a 	add	r2,r4,r2
8113a40c:	11000003 	ldbu	r4,0(r2)
8113a410:	e0bff917 	ldw	r2,-28(fp)
8113a414:	10800d43 	ldbu	r2,53(r2)
8113a418:	2084b03a 	or	r2,r4,r2
8113a41c:	1009883a 	mov	r4,r2
8113a420:	d0a09e44 	addi	r2,gp,-32135
8113a424:	1885883a 	add	r2,r3,r2
8113a428:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8113a42c:	e0bff917 	ldw	r2,-28(fp)
8113a430:	10800517 	ldw	r2,20(r2)
8113a434:	e0bff915 	stw	r2,-28(fp)
8113a438:	e0bffb17 	ldw	r2,-20(fp)
8113a43c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a440:	e0bffe17 	ldw	r2,-8(fp)
8113a444:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113a448:	e0bff917 	ldw	r2,-28(fp)
8113a44c:	10800c83 	ldbu	r2,50(r2)
8113a450:	10803fcc 	andi	r2,r2,255
8113a454:	10800a98 	cmpnei	r2,r2,42
8113a458:	103fb21e 	bne	r2,zero,8113a324 <__reset+0xfb11a324>
8113a45c:	00000106 	br	8113a464 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8113a460:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8113a464:	e037883a 	mov	sp,fp
8113a468:	dfc00117 	ldw	ra,4(sp)
8113a46c:	df000017 	ldw	fp,0(sp)
8113a470:	dec00204 	addi	sp,sp,8
8113a474:	f800283a 	ret

8113a478 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113a478:	deffff04 	addi	sp,sp,-4
8113a47c:	de00012e 	bgeu	sp,et,8113a484 <OSVersion+0xc>
8113a480:	003b68fa 	trap	3
8113a484:	df000015 	stw	fp,0(sp)
8113a488:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8113a48c:	00804784 	movi	r2,286
}
8113a490:	e037883a 	mov	sp,fp
8113a494:	df000017 	ldw	fp,0(sp)
8113a498:	dec00104 	addi	sp,sp,4
8113a49c:	f800283a 	ret

8113a4a0 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8113a4a0:	deffff04 	addi	sp,sp,-4
8113a4a4:	de00012e 	bgeu	sp,et,8113a4ac <OS_Dummy+0xc>
8113a4a8:	003b68fa 	trap	3
8113a4ac:	df000015 	stw	fp,0(sp)
8113a4b0:	d839883a 	mov	fp,sp
}
8113a4b4:	0001883a 	nop
8113a4b8:	e037883a 	mov	sp,fp
8113a4bc:	df000017 	ldw	fp,0(sp)
8113a4c0:	dec00104 	addi	sp,sp,4
8113a4c4:	f800283a 	ret

8113a4c8 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8113a4c8:	defff804 	addi	sp,sp,-32
8113a4cc:	de00012e 	bgeu	sp,et,8113a4d4 <OS_EventTaskRdy+0xc>
8113a4d0:	003b68fa 	trap	3
8113a4d4:	dfc00715 	stw	ra,28(sp)
8113a4d8:	df000615 	stw	fp,24(sp)
8113a4dc:	df000604 	addi	fp,sp,24
8113a4e0:	e13ffc15 	stw	r4,-16(fp)
8113a4e4:	e17ffd15 	stw	r5,-12(fp)
8113a4e8:	3007883a 	mov	r3,r6
8113a4ec:	3805883a 	mov	r2,r7
8113a4f0:	e0fffe05 	stb	r3,-8(fp)
8113a4f4:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8113a4f8:	e0bffc17 	ldw	r2,-16(fp)
8113a4fc:	10800283 	ldbu	r2,10(r2)
8113a500:	10c03fcc 	andi	r3,r2,255
8113a504:	00a04574 	movhi	r2,33045
8113a508:	10889e04 	addi	r2,r2,8824
8113a50c:	10c5883a 	add	r2,r2,r3
8113a510:	10800003 	ldbu	r2,0(r2)
8113a514:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8113a518:	e0bffa03 	ldbu	r2,-24(fp)
8113a51c:	e0fffc17 	ldw	r3,-16(fp)
8113a520:	1885883a 	add	r2,r3,r2
8113a524:	108002c4 	addi	r2,r2,11
8113a528:	10800003 	ldbu	r2,0(r2)
8113a52c:	10c03fcc 	andi	r3,r2,255
8113a530:	00a04574 	movhi	r2,33045
8113a534:	10889e04 	addi	r2,r2,8824
8113a538:	10c5883a 	add	r2,r2,r3
8113a53c:	10800003 	ldbu	r2,0(r2)
8113a540:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8113a544:	e0bffa03 	ldbu	r2,-24(fp)
8113a548:	100490fa 	slli	r2,r2,3
8113a54c:	1007883a 	mov	r3,r2
8113a550:	e0bffa43 	ldbu	r2,-23(fp)
8113a554:	1885883a 	add	r2,r3,r2
8113a558:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8113a55c:	e0fffa83 	ldbu	r3,-22(fp)
8113a560:	00a045f4 	movhi	r2,33047
8113a564:	10b81c04 	addi	r2,r2,-8080
8113a568:	18c7883a 	add	r3,r3,r3
8113a56c:	18c7883a 	add	r3,r3,r3
8113a570:	10c5883a 	add	r2,r2,r3
8113a574:	10800017 	ldw	r2,0(r2)
8113a578:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8113a57c:	e0bffb17 	ldw	r2,-20(fp)
8113a580:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8113a584:	e0bffb17 	ldw	r2,-20(fp)
8113a588:	e0fffd17 	ldw	r3,-12(fp)
8113a58c:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8113a590:	e0bffb17 	ldw	r2,-20(fp)
8113a594:	10800c03 	ldbu	r2,48(r2)
8113a598:	1007883a 	mov	r3,r2
8113a59c:	e0bffe03 	ldbu	r2,-8(fp)
8113a5a0:	0084303a 	nor	r2,zero,r2
8113a5a4:	1884703a 	and	r2,r3,r2
8113a5a8:	1007883a 	mov	r3,r2
8113a5ac:	e0bffb17 	ldw	r2,-20(fp)
8113a5b0:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8113a5b4:	e0bffb17 	ldw	r2,-20(fp)
8113a5b8:	e0ffff03 	ldbu	r3,-4(fp)
8113a5bc:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8113a5c0:	e0bffb17 	ldw	r2,-20(fp)
8113a5c4:	10800c03 	ldbu	r2,48(r2)
8113a5c8:	10803fcc 	andi	r2,r2,255
8113a5cc:	1080020c 	andi	r2,r2,8
8113a5d0:	1000111e 	bne	r2,zero,8113a618 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8113a5d4:	e0bffb17 	ldw	r2,-20(fp)
8113a5d8:	10c00d83 	ldbu	r3,54(r2)
8113a5dc:	d0a09e03 	ldbu	r2,-32136(gp)
8113a5e0:	1884b03a 	or	r2,r3,r2
8113a5e4:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8113a5e8:	e0fffa03 	ldbu	r3,-24(fp)
8113a5ec:	e13ffa03 	ldbu	r4,-24(fp)
8113a5f0:	d0a09e44 	addi	r2,gp,-32135
8113a5f4:	2085883a 	add	r2,r4,r2
8113a5f8:	11000003 	ldbu	r4,0(r2)
8113a5fc:	e0bffb17 	ldw	r2,-20(fp)
8113a600:	10800d43 	ldbu	r2,53(r2)
8113a604:	2084b03a 	or	r2,r4,r2
8113a608:	1009883a 	mov	r4,r2
8113a60c:	d0a09e44 	addi	r2,gp,-32135
8113a610:	1885883a 	add	r2,r3,r2
8113a614:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8113a618:	e17ffc17 	ldw	r5,-16(fp)
8113a61c:	e13ffb17 	ldw	r4,-20(fp)
8113a620:	113a8d80 	call	8113a8d8 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8113a624:	e0bffb17 	ldw	r2,-20(fp)
8113a628:	10800817 	ldw	r2,32(r2)
8113a62c:	10000826 	beq	r2,zero,8113a650 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113a630:	e0bffb17 	ldw	r2,-20(fp)
8113a634:	10800817 	ldw	r2,32(r2)
8113a638:	100b883a 	mov	r5,r2
8113a63c:	e13ffb17 	ldw	r4,-20(fp)
8113a640:	113a9980 	call	8113a998 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8113a644:	e0bffb17 	ldw	r2,-20(fp)
8113a648:	e0fffc17 	ldw	r3,-16(fp)
8113a64c:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8113a650:	e0bffa83 	ldbu	r2,-22(fp)
}
8113a654:	e037883a 	mov	sp,fp
8113a658:	dfc00117 	ldw	ra,4(sp)
8113a65c:	df000017 	ldw	fp,0(sp)
8113a660:	dec00204 	addi	sp,sp,8
8113a664:	f800283a 	ret

8113a668 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8113a668:	defffd04 	addi	sp,sp,-12
8113a66c:	de00012e 	bgeu	sp,et,8113a674 <OS_EventTaskWait+0xc>
8113a670:	003b68fa 	trap	3
8113a674:	df000215 	stw	fp,8(sp)
8113a678:	df000204 	addi	fp,sp,8
8113a67c:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8113a680:	d0a0a217 	ldw	r2,-32120(gp)
8113a684:	e0ffff17 	ldw	r3,-4(fp)
8113a688:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8113a68c:	d0a0a217 	ldw	r2,-32120(gp)
8113a690:	10800d03 	ldbu	r2,52(r2)
8113a694:	10803fcc 	andi	r2,r2,255
8113a698:	d0e0a217 	ldw	r3,-32120(gp)
8113a69c:	18c00d03 	ldbu	r3,52(r3)
8113a6a0:	18c03fcc 	andi	r3,r3,255
8113a6a4:	e13fff17 	ldw	r4,-4(fp)
8113a6a8:	20c7883a 	add	r3,r4,r3
8113a6ac:	18c002c4 	addi	r3,r3,11
8113a6b0:	19000003 	ldbu	r4,0(r3)
8113a6b4:	d0e0a217 	ldw	r3,-32120(gp)
8113a6b8:	18c00d43 	ldbu	r3,53(r3)
8113a6bc:	20c6b03a 	or	r3,r4,r3
8113a6c0:	1809883a 	mov	r4,r3
8113a6c4:	e0ffff17 	ldw	r3,-4(fp)
8113a6c8:	1885883a 	add	r2,r3,r2
8113a6cc:	108002c4 	addi	r2,r2,11
8113a6d0:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113a6d4:	e0bfff17 	ldw	r2,-4(fp)
8113a6d8:	10c00283 	ldbu	r3,10(r2)
8113a6dc:	d0a0a217 	ldw	r2,-32120(gp)
8113a6e0:	10800d83 	ldbu	r2,54(r2)
8113a6e4:	1884b03a 	or	r2,r3,r2
8113a6e8:	1007883a 	mov	r3,r2
8113a6ec:	e0bfff17 	ldw	r2,-4(fp)
8113a6f0:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113a6f4:	d0a0a217 	ldw	r2,-32120(gp)
8113a6f8:	10800d03 	ldbu	r2,52(r2)
8113a6fc:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113a700:	e0fffe03 	ldbu	r3,-8(fp)
8113a704:	e13ffe03 	ldbu	r4,-8(fp)
8113a708:	d0a09e44 	addi	r2,gp,-32135
8113a70c:	2085883a 	add	r2,r4,r2
8113a710:	10800003 	ldbu	r2,0(r2)
8113a714:	1009883a 	mov	r4,r2
8113a718:	d0a0a217 	ldw	r2,-32120(gp)
8113a71c:	10800d43 	ldbu	r2,53(r2)
8113a720:	0084303a 	nor	r2,zero,r2
8113a724:	2084703a 	and	r2,r4,r2
8113a728:	1009883a 	mov	r4,r2
8113a72c:	d0a09e44 	addi	r2,gp,-32135
8113a730:	1885883a 	add	r2,r3,r2
8113a734:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113a738:	e0fffe03 	ldbu	r3,-8(fp)
8113a73c:	d0a09e44 	addi	r2,gp,-32135
8113a740:	1885883a 	add	r2,r3,r2
8113a744:	10800003 	ldbu	r2,0(r2)
8113a748:	10803fcc 	andi	r2,r2,255
8113a74c:	1000071e 	bne	r2,zero,8113a76c <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113a750:	d0a0a217 	ldw	r2,-32120(gp)
8113a754:	10800d83 	ldbu	r2,54(r2)
8113a758:	0084303a 	nor	r2,zero,r2
8113a75c:	1007883a 	mov	r3,r2
8113a760:	d0a09e03 	ldbu	r2,-32136(gp)
8113a764:	1884703a 	and	r2,r3,r2
8113a768:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113a76c:	0001883a 	nop
8113a770:	e037883a 	mov	sp,fp
8113a774:	df000017 	ldw	fp,0(sp)
8113a778:	dec00104 	addi	sp,sp,4
8113a77c:	f800283a 	ret

8113a780 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8113a780:	defffb04 	addi	sp,sp,-20
8113a784:	de00012e 	bgeu	sp,et,8113a78c <OS_EventTaskWaitMulti+0xc>
8113a788:	003b68fa 	trap	3
8113a78c:	df000415 	stw	fp,16(sp)
8113a790:	df000404 	addi	fp,sp,16
8113a794:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8113a798:	d0a0a217 	ldw	r2,-32120(gp)
8113a79c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8113a7a0:	d0a0a217 	ldw	r2,-32120(gp)
8113a7a4:	e0ffff17 	ldw	r3,-4(fp)
8113a7a8:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8113a7ac:	e0bfff17 	ldw	r2,-4(fp)
8113a7b0:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8113a7b4:	e0bffc17 	ldw	r2,-16(fp)
8113a7b8:	10800017 	ldw	r2,0(r2)
8113a7bc:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113a7c0:	00002006 	br	8113a844 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8113a7c4:	d0a0a217 	ldw	r2,-32120(gp)
8113a7c8:	10800d03 	ldbu	r2,52(r2)
8113a7cc:	10803fcc 	andi	r2,r2,255
8113a7d0:	d0e0a217 	ldw	r3,-32120(gp)
8113a7d4:	18c00d03 	ldbu	r3,52(r3)
8113a7d8:	18c03fcc 	andi	r3,r3,255
8113a7dc:	e13ffd17 	ldw	r4,-12(fp)
8113a7e0:	20c7883a 	add	r3,r4,r3
8113a7e4:	18c002c4 	addi	r3,r3,11
8113a7e8:	19000003 	ldbu	r4,0(r3)
8113a7ec:	d0e0a217 	ldw	r3,-32120(gp)
8113a7f0:	18c00d43 	ldbu	r3,53(r3)
8113a7f4:	20c6b03a 	or	r3,r4,r3
8113a7f8:	1809883a 	mov	r4,r3
8113a7fc:	e0fffd17 	ldw	r3,-12(fp)
8113a800:	1885883a 	add	r2,r3,r2
8113a804:	108002c4 	addi	r2,r2,11
8113a808:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113a80c:	e0bffd17 	ldw	r2,-12(fp)
8113a810:	10c00283 	ldbu	r3,10(r2)
8113a814:	d0a0a217 	ldw	r2,-32120(gp)
8113a818:	10800d83 	ldbu	r2,54(r2)
8113a81c:	1884b03a 	or	r2,r3,r2
8113a820:	1007883a 	mov	r3,r2
8113a824:	e0bffd17 	ldw	r2,-12(fp)
8113a828:	10c00285 	stb	r3,10(r2)
        pevents++;
8113a82c:	e0bffc17 	ldw	r2,-16(fp)
8113a830:	10800104 	addi	r2,r2,4
8113a834:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113a838:	e0bffc17 	ldw	r2,-16(fp)
8113a83c:	10800017 	ldw	r2,0(r2)
8113a840:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113a844:	e0bffd17 	ldw	r2,-12(fp)
8113a848:	103fde1e 	bne	r2,zero,8113a7c4 <__reset+0xfb11a7c4>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113a84c:	d0a0a217 	ldw	r2,-32120(gp)
8113a850:	10800d03 	ldbu	r2,52(r2)
8113a854:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113a858:	e0fffe03 	ldbu	r3,-8(fp)
8113a85c:	e13ffe03 	ldbu	r4,-8(fp)
8113a860:	d0a09e44 	addi	r2,gp,-32135
8113a864:	2085883a 	add	r2,r4,r2
8113a868:	10800003 	ldbu	r2,0(r2)
8113a86c:	1009883a 	mov	r4,r2
8113a870:	d0a0a217 	ldw	r2,-32120(gp)
8113a874:	10800d43 	ldbu	r2,53(r2)
8113a878:	0084303a 	nor	r2,zero,r2
8113a87c:	2084703a 	and	r2,r4,r2
8113a880:	1009883a 	mov	r4,r2
8113a884:	d0a09e44 	addi	r2,gp,-32135
8113a888:	1885883a 	add	r2,r3,r2
8113a88c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113a890:	e0fffe03 	ldbu	r3,-8(fp)
8113a894:	d0a09e44 	addi	r2,gp,-32135
8113a898:	1885883a 	add	r2,r3,r2
8113a89c:	10800003 	ldbu	r2,0(r2)
8113a8a0:	10803fcc 	andi	r2,r2,255
8113a8a4:	1000071e 	bne	r2,zero,8113a8c4 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113a8a8:	d0a0a217 	ldw	r2,-32120(gp)
8113a8ac:	10800d83 	ldbu	r2,54(r2)
8113a8b0:	0084303a 	nor	r2,zero,r2
8113a8b4:	1007883a 	mov	r3,r2
8113a8b8:	d0a09e03 	ldbu	r2,-32136(gp)
8113a8bc:	1884703a 	and	r2,r3,r2
8113a8c0:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113a8c4:	0001883a 	nop
8113a8c8:	e037883a 	mov	sp,fp
8113a8cc:	df000017 	ldw	fp,0(sp)
8113a8d0:	dec00104 	addi	sp,sp,4
8113a8d4:	f800283a 	ret

8113a8d8 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8113a8d8:	defffc04 	addi	sp,sp,-16
8113a8dc:	de00012e 	bgeu	sp,et,8113a8e4 <OS_EventTaskRemove+0xc>
8113a8e0:	003b68fa 	trap	3
8113a8e4:	df000315 	stw	fp,12(sp)
8113a8e8:	df000304 	addi	fp,sp,12
8113a8ec:	e13ffe15 	stw	r4,-8(fp)
8113a8f0:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8113a8f4:	e0bffe17 	ldw	r2,-8(fp)
8113a8f8:	10800d03 	ldbu	r2,52(r2)
8113a8fc:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8113a900:	e0bffd03 	ldbu	r2,-12(fp)
8113a904:	e0fffd03 	ldbu	r3,-12(fp)
8113a908:	e13fff17 	ldw	r4,-4(fp)
8113a90c:	20c7883a 	add	r3,r4,r3
8113a910:	18c002c4 	addi	r3,r3,11
8113a914:	18c00003 	ldbu	r3,0(r3)
8113a918:	1809883a 	mov	r4,r3
8113a91c:	e0fffe17 	ldw	r3,-8(fp)
8113a920:	18c00d43 	ldbu	r3,53(r3)
8113a924:	00c6303a 	nor	r3,zero,r3
8113a928:	20c6703a 	and	r3,r4,r3
8113a92c:	1809883a 	mov	r4,r3
8113a930:	e0ffff17 	ldw	r3,-4(fp)
8113a934:	1885883a 	add	r2,r3,r2
8113a938:	108002c4 	addi	r2,r2,11
8113a93c:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8113a940:	e0bffd03 	ldbu	r2,-12(fp)
8113a944:	e0ffff17 	ldw	r3,-4(fp)
8113a948:	1885883a 	add	r2,r3,r2
8113a94c:	108002c4 	addi	r2,r2,11
8113a950:	10800003 	ldbu	r2,0(r2)
8113a954:	10803fcc 	andi	r2,r2,255
8113a958:	10000a1e 	bne	r2,zero,8113a984 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8113a95c:	e0bfff17 	ldw	r2,-4(fp)
8113a960:	10800283 	ldbu	r2,10(r2)
8113a964:	1007883a 	mov	r3,r2
8113a968:	e0bffe17 	ldw	r2,-8(fp)
8113a96c:	10800d83 	ldbu	r2,54(r2)
8113a970:	0084303a 	nor	r2,zero,r2
8113a974:	1884703a 	and	r2,r3,r2
8113a978:	1007883a 	mov	r3,r2
8113a97c:	e0bfff17 	ldw	r2,-4(fp)
8113a980:	10c00285 	stb	r3,10(r2)
    }
}
8113a984:	0001883a 	nop
8113a988:	e037883a 	mov	sp,fp
8113a98c:	df000017 	ldw	fp,0(sp)
8113a990:	dec00104 	addi	sp,sp,4
8113a994:	f800283a 	ret

8113a998 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8113a998:	defffa04 	addi	sp,sp,-24
8113a99c:	de00012e 	bgeu	sp,et,8113a9a4 <OS_EventTaskRemoveMulti+0xc>
8113a9a0:	003b68fa 	trap	3
8113a9a4:	df000515 	stw	fp,20(sp)
8113a9a8:	df000504 	addi	fp,sp,20
8113a9ac:	e13ffe15 	stw	r4,-8(fp)
8113a9b0:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8113a9b4:	e0bffe17 	ldw	r2,-8(fp)
8113a9b8:	10800d03 	ldbu	r2,52(r2)
8113a9bc:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8113a9c0:	e0bffe17 	ldw	r2,-8(fp)
8113a9c4:	10800d83 	ldbu	r2,54(r2)
8113a9c8:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8113a9cc:	e0bffe17 	ldw	r2,-8(fp)
8113a9d0:	10800d43 	ldbu	r2,53(r2)
8113a9d4:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8113a9d8:	e0bfff17 	ldw	r2,-4(fp)
8113a9dc:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8113a9e0:	e0bffb17 	ldw	r2,-20(fp)
8113a9e4:	10800017 	ldw	r2,0(r2)
8113a9e8:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113a9ec:	00002506 	br	8113aa84 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8113a9f0:	e0bffd03 	ldbu	r2,-12(fp)
8113a9f4:	e0fffd03 	ldbu	r3,-12(fp)
8113a9f8:	e13ffc17 	ldw	r4,-16(fp)
8113a9fc:	20c7883a 	add	r3,r4,r3
8113aa00:	18c002c4 	addi	r3,r3,11
8113aa04:	18c00003 	ldbu	r3,0(r3)
8113aa08:	1809883a 	mov	r4,r3
8113aa0c:	e0fffd83 	ldbu	r3,-10(fp)
8113aa10:	00c6303a 	nor	r3,zero,r3
8113aa14:	20c6703a 	and	r3,r4,r3
8113aa18:	1809883a 	mov	r4,r3
8113aa1c:	e0fffc17 	ldw	r3,-16(fp)
8113aa20:	1885883a 	add	r2,r3,r2
8113aa24:	108002c4 	addi	r2,r2,11
8113aa28:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8113aa2c:	e0bffd03 	ldbu	r2,-12(fp)
8113aa30:	e0fffc17 	ldw	r3,-16(fp)
8113aa34:	1885883a 	add	r2,r3,r2
8113aa38:	108002c4 	addi	r2,r2,11
8113aa3c:	10800003 	ldbu	r2,0(r2)
8113aa40:	10803fcc 	andi	r2,r2,255
8113aa44:	1000091e 	bne	r2,zero,8113aa6c <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113aa48:	e0bffc17 	ldw	r2,-16(fp)
8113aa4c:	10800283 	ldbu	r2,10(r2)
8113aa50:	1007883a 	mov	r3,r2
8113aa54:	e0bffd43 	ldbu	r2,-11(fp)
8113aa58:	0084303a 	nor	r2,zero,r2
8113aa5c:	1884703a 	and	r2,r3,r2
8113aa60:	1007883a 	mov	r3,r2
8113aa64:	e0bffc17 	ldw	r2,-16(fp)
8113aa68:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8113aa6c:	e0bffb17 	ldw	r2,-20(fp)
8113aa70:	10800104 	addi	r2,r2,4
8113aa74:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8113aa78:	e0bffb17 	ldw	r2,-20(fp)
8113aa7c:	10800017 	ldw	r2,0(r2)
8113aa80:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113aa84:	e0bffc17 	ldw	r2,-16(fp)
8113aa88:	103fd91e 	bne	r2,zero,8113a9f0 <__reset+0xfb11a9f0>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8113aa8c:	0001883a 	nop
8113aa90:	e037883a 	mov	sp,fp
8113aa94:	df000017 	ldw	fp,0(sp)
8113aa98:	dec00104 	addi	sp,sp,4
8113aa9c:	f800283a 	ret

8113aaa0 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8113aaa0:	defffc04 	addi	sp,sp,-16
8113aaa4:	de00012e 	bgeu	sp,et,8113aaac <OS_EventWaitListInit+0xc>
8113aaa8:	003b68fa 	trap	3
8113aaac:	df000315 	stw	fp,12(sp)
8113aab0:	df000304 	addi	fp,sp,12
8113aab4:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8113aab8:	e0bfff17 	ldw	r2,-4(fp)
8113aabc:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8113aac0:	e0bfff17 	ldw	r2,-4(fp)
8113aac4:	108002c4 	addi	r2,r2,11
8113aac8:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113aacc:	e03ffe05 	stb	zero,-8(fp)
8113aad0:	00000706 	br	8113aaf0 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8113aad4:	e0bffd17 	ldw	r2,-12(fp)
8113aad8:	10c00044 	addi	r3,r2,1
8113aadc:	e0fffd15 	stw	r3,-12(fp)
8113aae0:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113aae4:	e0bffe03 	ldbu	r2,-8(fp)
8113aae8:	10800044 	addi	r2,r2,1
8113aaec:	e0bffe05 	stb	r2,-8(fp)
8113aaf0:	e0bffe03 	ldbu	r2,-8(fp)
8113aaf4:	108001b0 	cmpltui	r2,r2,6
8113aaf8:	103ff61e 	bne	r2,zero,8113aad4 <__reset+0xfb11aad4>
        *ptbl++ = 0;
    }
}
8113aafc:	0001883a 	nop
8113ab00:	e037883a 	mov	sp,fp
8113ab04:	df000017 	ldw	fp,0(sp)
8113ab08:	dec00104 	addi	sp,sp,4
8113ab0c:	f800283a 	ret

8113ab10 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8113ab10:	defffb04 	addi	sp,sp,-20
8113ab14:	de00012e 	bgeu	sp,et,8113ab1c <OS_InitEventList+0xc>
8113ab18:	003b68fa 	trap	3
8113ab1c:	dfc00415 	stw	ra,16(sp)
8113ab20:	df000315 	stw	fp,12(sp)
8113ab24:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113ab28:	01434004 	movi	r5,3328
8113ab2c:	012045f4 	movhi	r4,33047
8113ab30:	21306e04 	addi	r4,r4,-15944
8113ab34:	113aeb80 	call	8113aeb8 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113ab38:	00a045f4 	movhi	r2,33047
8113ab3c:	10b06e04 	addi	r2,r2,-15944
8113ab40:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113ab44:	00a045f4 	movhi	r2,33047
8113ab48:	10b07b04 	addi	r2,r2,-15892
8113ab4c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113ab50:	e03ffd0d 	sth	zero,-12(fp)
8113ab54:	00001306 	br	8113aba4 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ab58:	e0bffe17 	ldw	r2,-8(fp)
8113ab5c:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8113ab60:	e0bffe17 	ldw	r2,-8(fp)
8113ab64:	e0ffff17 	ldw	r3,-4(fp)
8113ab68:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8113ab6c:	e0bffe17 	ldw	r2,-8(fp)
8113ab70:	00c00fc4 	movi	r3,63
8113ab74:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8113ab78:	e0bffe17 	ldw	r2,-8(fp)
8113ab7c:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8113ab80:	e0bffe17 	ldw	r2,-8(fp)
8113ab84:	10800d04 	addi	r2,r2,52
8113ab88:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8113ab8c:	e0bfff17 	ldw	r2,-4(fp)
8113ab90:	10800d04 	addi	r2,r2,52
8113ab94:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113ab98:	e0bffd0b 	ldhu	r2,-12(fp)
8113ab9c:	10800044 	addi	r2,r2,1
8113aba0:	e0bffd0d 	sth	r2,-12(fp)
8113aba4:	e0bffd0b 	ldhu	r2,-12(fp)
8113aba8:	10800ff0 	cmpltui	r2,r2,63
8113abac:	103fea1e 	bne	r2,zero,8113ab58 <__reset+0xfb11ab58>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8113abb0:	e0bffe17 	ldw	r2,-8(fp)
8113abb4:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8113abb8:	e0bffe17 	ldw	r2,-8(fp)
8113abbc:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8113abc0:	e0bffe17 	ldw	r2,-8(fp)
8113abc4:	00c00fc4 	movi	r3,63
8113abc8:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8113abcc:	e0bffe17 	ldw	r2,-8(fp)
8113abd0:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8113abd4:	00a045f4 	movhi	r2,33047
8113abd8:	10b06e04 	addi	r2,r2,-15944
8113abdc:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8113abe0:	0001883a 	nop
8113abe4:	e037883a 	mov	sp,fp
8113abe8:	dfc00117 	ldw	ra,4(sp)
8113abec:	df000017 	ldw	fp,0(sp)
8113abf0:	dec00204 	addi	sp,sp,8
8113abf4:	f800283a 	ret

8113abf8 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8113abf8:	deffff04 	addi	sp,sp,-4
8113abfc:	de00012e 	bgeu	sp,et,8113ac04 <OS_InitMisc+0xc>
8113ac00:	003b68fa 	trap	3
8113ac04:	df000015 	stw	fp,0(sp)
8113ac08:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8113ac0c:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8113ac10:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113ac14:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8113ac18:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8113ac1c:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8113ac20:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113ac24:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113ac28:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
8113ac2c:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8113ac30:	d020a705 	stb	zero,-32100(gp)
#endif
}
8113ac34:	0001883a 	nop
8113ac38:	e037883a 	mov	sp,fp
8113ac3c:	df000017 	ldw	fp,0(sp)
8113ac40:	dec00104 	addi	sp,sp,4
8113ac44:	f800283a 	ret

8113ac48 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113ac48:	defffd04 	addi	sp,sp,-12
8113ac4c:	de00012e 	bgeu	sp,et,8113ac54 <OS_InitRdyList+0xc>
8113ac50:	003b68fa 	trap	3
8113ac54:	df000215 	stw	fp,8(sp)
8113ac58:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8113ac5c:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
8113ac60:	d0a09e44 	addi	r2,gp,-32135
8113ac64:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113ac68:	e03ffe05 	stb	zero,-8(fp)
8113ac6c:	00000706 	br	8113ac8c <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8113ac70:	e0bfff17 	ldw	r2,-4(fp)
8113ac74:	10c00044 	addi	r3,r2,1
8113ac78:	e0ffff15 	stw	r3,-4(fp)
8113ac7c:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113ac80:	e0bffe03 	ldbu	r2,-8(fp)
8113ac84:	10800044 	addi	r2,r2,1
8113ac88:	e0bffe05 	stb	r2,-8(fp)
8113ac8c:	e0bffe03 	ldbu	r2,-8(fp)
8113ac90:	108001b0 	cmpltui	r2,r2,6
8113ac94:	103ff61e 	bne	r2,zero,8113ac70 <__reset+0xfb11ac70>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113ac98:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
8113ac9c:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8113aca0:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
8113aca4:	d020a215 	stw	zero,-32120(gp)
}
8113aca8:	0001883a 	nop
8113acac:	e037883a 	mov	sp,fp
8113acb0:	df000017 	ldw	fp,0(sp)
8113acb4:	dec00104 	addi	sp,sp,4
8113acb8:	f800283a 	ret

8113acbc <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8113acbc:	defff804 	addi	sp,sp,-32
8113acc0:	de00012e 	bgeu	sp,et,8113acc8 <OS_InitTaskIdle+0xc>
8113acc4:	003b68fa 	trap	3
8113acc8:	dfc00715 	stw	ra,28(sp)
8113accc:	df000615 	stw	fp,24(sp)
8113acd0:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8113acd4:	008000c4 	movi	r2,3
8113acd8:	d8800415 	stw	r2,16(sp)
8113acdc:	d8000315 	stw	zero,12(sp)
8113ace0:	00810004 	movi	r2,1024
8113ace4:	d8800215 	stw	r2,8(sp)
8113ace8:	00a045f4 	movhi	r2,33047
8113acec:	10ac6e04 	addi	r2,r2,-20040
8113acf0:	d8800115 	stw	r2,4(sp)
8113acf4:	00bfffd4 	movui	r2,65535
8113acf8:	d8800015 	stw	r2,0(sp)
8113acfc:	01c00a84 	movi	r7,42
8113ad00:	01a045f4 	movhi	r6,33047
8113ad04:	31b06d04 	addi	r6,r6,-15948
8113ad08:	000b883a 	mov	r5,zero
8113ad0c:	01204534 	movhi	r4,33044
8113ad10:	212c6c04 	addi	r4,r4,-20048
8113ad14:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8113ad18:	e1bfff04 	addi	r6,fp,-4
8113ad1c:	01604574 	movhi	r5,33045
8113ad20:	2948de04 	addi	r5,r5,9080
8113ad24:	01000a84 	movi	r4,42
8113ad28:	11413d00 	call	811413d0 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8113ad2c:	0001883a 	nop
8113ad30:	e037883a 	mov	sp,fp
8113ad34:	dfc00117 	ldw	ra,4(sp)
8113ad38:	df000017 	ldw	fp,0(sp)
8113ad3c:	dec00204 	addi	sp,sp,8
8113ad40:	f800283a 	ret

8113ad44 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113ad44:	defff804 	addi	sp,sp,-32
8113ad48:	de00012e 	bgeu	sp,et,8113ad50 <OS_InitTaskStat+0xc>
8113ad4c:	003b68fa 	trap	3
8113ad50:	dfc00715 	stw	ra,28(sp)
8113ad54:	df000615 	stw	fp,24(sp)
8113ad58:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8113ad5c:	008000c4 	movi	r2,3
8113ad60:	d8800415 	stw	r2,16(sp)
8113ad64:	d8000315 	stw	zero,12(sp)
8113ad68:	00810004 	movi	r2,1024
8113ad6c:	d8800215 	stw	r2,8(sp)
8113ad70:	00a045f4 	movhi	r2,33047
8113ad74:	10a5ae04 	addi	r2,r2,-26952
8113ad78:	d8800115 	stw	r2,4(sp)
8113ad7c:	00bfff94 	movui	r2,65534
8113ad80:	d8800015 	stw	r2,0(sp)
8113ad84:	01c00a44 	movi	r7,41
8113ad88:	01a045f4 	movhi	r6,33047
8113ad8c:	31a9ad04 	addi	r6,r6,-22860
8113ad90:	000b883a 	mov	r5,zero
8113ad94:	01204534 	movhi	r4,33044
8113ad98:	212c8504 	addi	r4,r4,-19948
8113ad9c:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8113ada0:	e1bfff04 	addi	r6,fp,-4
8113ada4:	01604574 	movhi	r5,33045
8113ada8:	2948e204 	addi	r5,r5,9096
8113adac:	01000a44 	movi	r4,41
8113adb0:	11413d00 	call	811413d0 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8113adb4:	0001883a 	nop
8113adb8:	e037883a 	mov	sp,fp
8113adbc:	dfc00117 	ldw	ra,4(sp)
8113adc0:	df000017 	ldw	fp,0(sp)
8113adc4:	dec00204 	addi	sp,sp,8
8113adc8:	f800283a 	ret

8113adcc <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8113adcc:	defffb04 	addi	sp,sp,-20
8113add0:	de00012e 	bgeu	sp,et,8113add8 <OS_InitTCBList+0xc>
8113add4:	003b68fa 	trap	3
8113add8:	dfc00415 	stw	ra,16(sp)
8113addc:	df000315 	stw	fp,12(sp)
8113ade0:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8113ade4:	01446e04 	movi	r5,4536
8113ade8:	012045f4 	movhi	r4,33047
8113adec:	2133ae04 	addi	r4,r4,-12616
8113adf0:	113aeb80 	call	8113aeb8 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8113adf4:	01402b04 	movi	r5,172
8113adf8:	012045f4 	movhi	r4,33047
8113adfc:	21381c04 	addi	r4,r4,-8080
8113ae00:	113aeb80 	call	8113aeb8 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8113ae04:	00a045f4 	movhi	r2,33047
8113ae08:	10b3ae04 	addi	r2,r2,-12616
8113ae0c:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8113ae10:	00a045f4 	movhi	r2,33047
8113ae14:	10b3c904 	addi	r2,r2,-12508
8113ae18:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113ae1c:	e03ffd05 	stb	zero,-12(fp)
8113ae20:	00001106 	br	8113ae68 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8113ae24:	e0bffe17 	ldw	r2,-8(fp)
8113ae28:	e0ffff17 	ldw	r3,-4(fp)
8113ae2c:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8113ae30:	e0bffe17 	ldw	r2,-8(fp)
8113ae34:	00c00fc4 	movi	r3,63
8113ae38:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113ae3c:	e0bffe17 	ldw	r2,-8(fp)
8113ae40:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8113ae44:	e0bffe17 	ldw	r2,-8(fp)
8113ae48:	10801b04 	addi	r2,r2,108
8113ae4c:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8113ae50:	e0bfff17 	ldw	r2,-4(fp)
8113ae54:	10801b04 	addi	r2,r2,108
8113ae58:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113ae5c:	e0bffd03 	ldbu	r2,-12(fp)
8113ae60:	10800044 	addi	r2,r2,1
8113ae64:	e0bffd05 	stb	r2,-12(fp)
8113ae68:	e0bffd03 	ldbu	r2,-12(fp)
8113ae6c:	10800a70 	cmpltui	r2,r2,41
8113ae70:	103fec1e 	bne	r2,zero,8113ae24 <__reset+0xfb11ae24>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8113ae74:	e0bffe17 	ldw	r2,-8(fp)
8113ae78:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8113ae7c:	e0bffe17 	ldw	r2,-8(fp)
8113ae80:	00c00fc4 	movi	r3,63
8113ae84:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113ae88:	e0bffe17 	ldw	r2,-8(fp)
8113ae8c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8113ae90:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8113ae94:	00a045f4 	movhi	r2,33047
8113ae98:	10b3ae04 	addi	r2,r2,-12616
8113ae9c:	d0a09915 	stw	r2,-32156(gp)
}
8113aea0:	0001883a 	nop
8113aea4:	e037883a 	mov	sp,fp
8113aea8:	dfc00117 	ldw	ra,4(sp)
8113aeac:	df000017 	ldw	fp,0(sp)
8113aeb0:	dec00204 	addi	sp,sp,8
8113aeb4:	f800283a 	ret

8113aeb8 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8113aeb8:	defffd04 	addi	sp,sp,-12
8113aebc:	de00012e 	bgeu	sp,et,8113aec4 <OS_MemClr+0xc>
8113aec0:	003b68fa 	trap	3
8113aec4:	df000215 	stw	fp,8(sp)
8113aec8:	df000204 	addi	fp,sp,8
8113aecc:	e13ffe15 	stw	r4,-8(fp)
8113aed0:	2805883a 	mov	r2,r5
8113aed4:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113aed8:	00000706 	br	8113aef8 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8113aedc:	e0bffe17 	ldw	r2,-8(fp)
8113aee0:	10c00044 	addi	r3,r2,1
8113aee4:	e0fffe15 	stw	r3,-8(fp)
8113aee8:	10000005 	stb	zero,0(r2)
        size--;
8113aeec:	e0bfff0b 	ldhu	r2,-4(fp)
8113aef0:	10bfffc4 	addi	r2,r2,-1
8113aef4:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8113aef8:	e0bfff0b 	ldhu	r2,-4(fp)
8113aefc:	103ff71e 	bne	r2,zero,8113aedc <__reset+0xfb11aedc>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8113af00:	0001883a 	nop
8113af04:	e037883a 	mov	sp,fp
8113af08:	df000017 	ldw	fp,0(sp)
8113af0c:	dec00104 	addi	sp,sp,4
8113af10:	f800283a 	ret

8113af14 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8113af14:	defffc04 	addi	sp,sp,-16
8113af18:	de00012e 	bgeu	sp,et,8113af20 <OS_MemCopy+0xc>
8113af1c:	003b68fa 	trap	3
8113af20:	df000315 	stw	fp,12(sp)
8113af24:	df000304 	addi	fp,sp,12
8113af28:	e13ffd15 	stw	r4,-12(fp)
8113af2c:	e17ffe15 	stw	r5,-8(fp)
8113af30:	3005883a 	mov	r2,r6
8113af34:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113af38:	00000b06 	br	8113af68 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8113af3c:	e0bffd17 	ldw	r2,-12(fp)
8113af40:	10c00044 	addi	r3,r2,1
8113af44:	e0fffd15 	stw	r3,-12(fp)
8113af48:	e0fffe17 	ldw	r3,-8(fp)
8113af4c:	19000044 	addi	r4,r3,1
8113af50:	e13ffe15 	stw	r4,-8(fp)
8113af54:	18c00003 	ldbu	r3,0(r3)
8113af58:	10c00005 	stb	r3,0(r2)
        size--;
8113af5c:	e0bfff0b 	ldhu	r2,-4(fp)
8113af60:	10bfffc4 	addi	r2,r2,-1
8113af64:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8113af68:	e0bfff0b 	ldhu	r2,-4(fp)
8113af6c:	103ff31e 	bne	r2,zero,8113af3c <__reset+0xfb11af3c>
        *pdest++ = *psrc++;
        size--;
    }
}
8113af70:	0001883a 	nop
8113af74:	e037883a 	mov	sp,fp
8113af78:	df000017 	ldw	fp,0(sp)
8113af7c:	dec00104 	addi	sp,sp,4
8113af80:	f800283a 	ret

8113af84 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8113af84:	defffb04 	addi	sp,sp,-20
8113af88:	de00012e 	bgeu	sp,et,8113af90 <OS_Sched+0xc>
8113af8c:	003b68fa 	trap	3
8113af90:	dfc00415 	stw	ra,16(sp)
8113af94:	df000315 	stw	fp,12(sp)
8113af98:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113af9c:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113afa0:	0005303a 	rdctl	r2,status
8113afa4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113afa8:	e0ffff17 	ldw	r3,-4(fp)
8113afac:	00bfff84 	movi	r2,-2
8113afb0:	1884703a 	and	r2,r3,r2
8113afb4:	1001703a 	wrctl	status,r2
  
  return context;
8113afb8:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8113afbc:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8113afc0:	d0a0a103 	ldbu	r2,-32124(gp)
8113afc4:	10803fcc 	andi	r2,r2,255
8113afc8:	10001a1e 	bne	r2,zero,8113b034 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8113afcc:	d0a08f03 	ldbu	r2,-32196(gp)
8113afd0:	10803fcc 	andi	r2,r2,255
8113afd4:	1000171e 	bne	r2,zero,8113b034 <OS_Sched+0xb0>
            OS_SchedNew();
8113afd8:	113b05c0 	call	8113b05c <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8113afdc:	d0e09383 	ldbu	r3,-32178(gp)
8113afe0:	d0a093c3 	ldbu	r2,-32177(gp)
8113afe4:	18c03fcc 	andi	r3,r3,255
8113afe8:	10803fcc 	andi	r2,r2,255
8113afec:	18801126 	beq	r3,r2,8113b034 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8113aff0:	d0a09383 	ldbu	r2,-32178(gp)
8113aff4:	10c03fcc 	andi	r3,r2,255
8113aff8:	00a045f4 	movhi	r2,33047
8113affc:	10b81c04 	addi	r2,r2,-8080
8113b000:	18c7883a 	add	r3,r3,r3
8113b004:	18c7883a 	add	r3,r3,r3
8113b008:	10c5883a 	add	r2,r2,r3
8113b00c:	10800017 	ldw	r2,0(r2)
8113b010:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8113b014:	d0a09c17 	ldw	r2,-32144(gp)
8113b018:	10c00e17 	ldw	r3,56(r2)
8113b01c:	18c00044 	addi	r3,r3,1
8113b020:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8113b024:	d0a09617 	ldw	r2,-32168(gp)
8113b028:	10800044 	addi	r2,r2,1
8113b02c:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8113b030:	114bfb40 	call	8114bfb4 <OSCtxSw>
8113b034:	e0bffd17 	ldw	r2,-12(fp)
8113b038:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b03c:	e0bffe17 	ldw	r2,-8(fp)
8113b040:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8113b044:	0001883a 	nop
8113b048:	e037883a 	mov	sp,fp
8113b04c:	dfc00117 	ldw	ra,4(sp)
8113b050:	df000017 	ldw	fp,0(sp)
8113b054:	dec00204 	addi	sp,sp,8
8113b058:	f800283a 	ret

8113b05c <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8113b05c:	defffe04 	addi	sp,sp,-8
8113b060:	de00012e 	bgeu	sp,et,8113b068 <OS_SchedNew+0xc>
8113b064:	003b68fa 	trap	3
8113b068:	df000115 	stw	fp,4(sp)
8113b06c:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8113b070:	d0a09e03 	ldbu	r2,-32136(gp)
8113b074:	10c03fcc 	andi	r3,r2,255
8113b078:	00a04574 	movhi	r2,33045
8113b07c:	10889e04 	addi	r2,r2,8824
8113b080:	10c5883a 	add	r2,r2,r3
8113b084:	10800003 	ldbu	r2,0(r2)
8113b088:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8113b08c:	e0bfff03 	ldbu	r2,-4(fp)
8113b090:	100490fa 	slli	r2,r2,3
8113b094:	1009883a 	mov	r4,r2
8113b098:	e0ffff03 	ldbu	r3,-4(fp)
8113b09c:	d0a09e44 	addi	r2,gp,-32135
8113b0a0:	1885883a 	add	r2,r3,r2
8113b0a4:	10800003 	ldbu	r2,0(r2)
8113b0a8:	10c03fcc 	andi	r3,r2,255
8113b0ac:	00a04574 	movhi	r2,33045
8113b0b0:	10889e04 	addi	r2,r2,8824
8113b0b4:	10c5883a 	add	r2,r2,r3
8113b0b8:	10800003 	ldbu	r2,0(r2)
8113b0bc:	2085883a 	add	r2,r4,r2
8113b0c0:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8113b0c4:	0001883a 	nop
8113b0c8:	e037883a 	mov	sp,fp
8113b0cc:	df000017 	ldw	fp,0(sp)
8113b0d0:	dec00104 	addi	sp,sp,4
8113b0d4:	f800283a 	ret

8113b0d8 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8113b0d8:	defffc04 	addi	sp,sp,-16
8113b0dc:	de00012e 	bgeu	sp,et,8113b0e4 <OS_StrCopy+0xc>
8113b0e0:	003b68fa 	trap	3
8113b0e4:	df000315 	stw	fp,12(sp)
8113b0e8:	df000304 	addi	fp,sp,12
8113b0ec:	e13ffe15 	stw	r4,-8(fp)
8113b0f0:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8113b0f4:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8113b0f8:	00000b06 	br	8113b128 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8113b0fc:	e0bffe17 	ldw	r2,-8(fp)
8113b100:	10c00044 	addi	r3,r2,1
8113b104:	e0fffe15 	stw	r3,-8(fp)
8113b108:	e0ffff17 	ldw	r3,-4(fp)
8113b10c:	19000044 	addi	r4,r3,1
8113b110:	e13fff15 	stw	r4,-4(fp)
8113b114:	18c00003 	ldbu	r3,0(r3)
8113b118:	10c00005 	stb	r3,0(r2)
        len++;
8113b11c:	e0bffd03 	ldbu	r2,-12(fp)
8113b120:	10800044 	addi	r2,r2,1
8113b124:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113b128:	e0bfff17 	ldw	r2,-4(fp)
8113b12c:	10800003 	ldbu	r2,0(r2)
8113b130:	10803fcc 	andi	r2,r2,255
8113b134:	103ff11e 	bne	r2,zero,8113b0fc <__reset+0xfb11b0fc>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8113b138:	e0bffe17 	ldw	r2,-8(fp)
8113b13c:	10000005 	stb	zero,0(r2)
    return (len);
8113b140:	e0bffd03 	ldbu	r2,-12(fp)
}
8113b144:	e037883a 	mov	sp,fp
8113b148:	df000017 	ldw	fp,0(sp)
8113b14c:	dec00104 	addi	sp,sp,4
8113b150:	f800283a 	ret

8113b154 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8113b154:	defffd04 	addi	sp,sp,-12
8113b158:	de00012e 	bgeu	sp,et,8113b160 <OS_StrLen+0xc>
8113b15c:	003b68fa 	trap	3
8113b160:	df000215 	stw	fp,8(sp)
8113b164:	df000204 	addi	fp,sp,8
8113b168:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8113b16c:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
8113b170:	00000606 	br	8113b18c <OS_StrLen+0x38>
        psrc++;
8113b174:	e0bfff17 	ldw	r2,-4(fp)
8113b178:	10800044 	addi	r2,r2,1
8113b17c:	e0bfff15 	stw	r2,-4(fp)
        len++;
8113b180:	e0bffe03 	ldbu	r2,-8(fp)
8113b184:	10800044 	addi	r2,r2,1
8113b188:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113b18c:	e0bfff17 	ldw	r2,-4(fp)
8113b190:	10800003 	ldbu	r2,0(r2)
8113b194:	10803fcc 	andi	r2,r2,255
8113b198:	103ff61e 	bne	r2,zero,8113b174 <__reset+0xfb11b174>
        psrc++;
        len++;
    }
    return (len);
8113b19c:	e0bffe03 	ldbu	r2,-8(fp)
}
8113b1a0:	e037883a 	mov	sp,fp
8113b1a4:	df000017 	ldw	fp,0(sp)
8113b1a8:	dec00104 	addi	sp,sp,4
8113b1ac:	f800283a 	ret

8113b1b0 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8113b1b0:	defffa04 	addi	sp,sp,-24
8113b1b4:	de00012e 	bgeu	sp,et,8113b1bc <OS_TaskIdle+0xc>
8113b1b8:	003b68fa 	trap	3
8113b1bc:	dfc00515 	stw	ra,20(sp)
8113b1c0:	df000415 	stw	fp,16(sp)
8113b1c4:	df000404 	addi	fp,sp,16
8113b1c8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b1cc:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b1d0:	0005303a 	rdctl	r2,status
8113b1d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b1d8:	e0fffd17 	ldw	r3,-12(fp)
8113b1dc:	00bfff84 	movi	r2,-2
8113b1e0:	1884703a 	and	r2,r3,r2
8113b1e4:	1001703a 	wrctl	status,r2
  
  return context;
8113b1e8:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8113b1ec:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8113b1f0:	d0a09217 	ldw	r2,-32184(gp)
8113b1f4:	10800044 	addi	r2,r2,1
8113b1f8:	d0a09215 	stw	r2,-32184(gp)
8113b1fc:	e0bffc17 	ldw	r2,-16(fp)
8113b200:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b204:	e0bffe17 	ldw	r2,-8(fp)
8113b208:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
8113b20c:	114c3480 	call	8114c348 <OSTaskIdleHook>
    }
8113b210:	003fef06 	br	8113b1d0 <__reset+0xfb11b1d0>

8113b214 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8113b214:	defff804 	addi	sp,sp,-32
8113b218:	de00012e 	bgeu	sp,et,8113b220 <OS_TaskStat+0xc>
8113b21c:	003b68fa 	trap	3
8113b220:	dfc00715 	stw	ra,28(sp)
8113b224:	df000615 	stw	fp,24(sp)
8113b228:	dc400515 	stw	r17,20(sp)
8113b22c:	dc000415 	stw	r16,16(sp)
8113b230:	df000604 	addi	fp,sp,24
8113b234:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b238:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113b23c:	00000206 	br	8113b248 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
8113b240:	01003204 	movi	r4,200
8113b244:	1141cc00 	call	81141cc0 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113b248:	d0a0a703 	ldbu	r2,-32100(gp)
8113b24c:	10803fcc 	andi	r2,r2,255
8113b250:	103ffb26 	beq	r2,zero,8113b240 <__reset+0xfb11b240>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8113b254:	d0e09817 	ldw	r3,-32160(gp)
8113b258:	00947b34 	movhi	r2,20972
8113b25c:	10a147c4 	addi	r2,r2,-31457
8113b260:	1888383a 	mulxuu	r4,r3,r2
8113b264:	1885383a 	mul	r2,r3,r2
8113b268:	1021883a 	mov	r16,r2
8113b26c:	2023883a 	mov	r17,r4
8113b270:	8804d17a 	srli	r2,r17,5
8113b274:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
8113b278:	d0a09817 	ldw	r2,-32160(gp)
8113b27c:	1000031e 	bne	r2,zero,8113b28c <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8113b280:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8113b284:	01003fc4 	movi	r4,255
8113b288:	11419300 	call	81141930 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b28c:	0005303a 	rdctl	r2,status
8113b290:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b294:	e0fffb17 	ldw	r3,-20(fp)
8113b298:	00bfff84 	movi	r2,-2
8113b29c:	1884703a 	and	r2,r3,r2
8113b2a0:	1001703a 	wrctl	status,r2
  
  return context;
8113b2a4:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8113b2a8:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8113b2ac:	d0a09217 	ldw	r2,-32184(gp)
8113b2b0:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8113b2b4:	d0209215 	stw	zero,-32184(gp)
8113b2b8:	e0bffa17 	ldw	r2,-24(fp)
8113b2bc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b2c0:	e0bffc17 	ldw	r2,-16(fp)
8113b2c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113b2c8:	d0e0a817 	ldw	r3,-32096(gp)
8113b2cc:	d0a09817 	ldw	r2,-32160(gp)
8113b2d0:	1885203a 	divu	r2,r3,r2
8113b2d4:	1007883a 	mov	r3,r2
8113b2d8:	00801904 	movi	r2,100
8113b2dc:	10c5c83a 	sub	r2,r2,r3
8113b2e0:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8113b2e4:	114c2780 	call	8114c278 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8113b2e8:	113b2f80 	call	8113b2f8 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8113b2ec:	01001904 	movi	r4,100
8113b2f0:	1141cc00 	call	81141cc0 <OSTimeDly>
    }
8113b2f4:	003fe506 	br	8113b28c <__reset+0xfb11b28c>

8113b2f8 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8113b2f8:	defffa04 	addi	sp,sp,-24
8113b2fc:	de00012e 	bgeu	sp,et,8113b304 <OS_TaskStatStkChk+0xc>
8113b300:	003b68fa 	trap	3
8113b304:	dfc00515 	stw	ra,20(sp)
8113b308:	df000415 	stw	fp,16(sp)
8113b30c:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113b310:	e03ffc05 	stb	zero,-16(fp)
8113b314:	00002406 	br	8113b3a8 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8113b318:	e0bffc03 	ldbu	r2,-16(fp)
8113b31c:	e0fffe04 	addi	r3,fp,-8
8113b320:	180b883a 	mov	r5,r3
8113b324:	1009883a 	mov	r4,r2
8113b328:	11417680 	call	81141768 <OSTaskStkChk>
8113b32c:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8113b330:	e0bffc43 	ldbu	r2,-15(fp)
8113b334:	1000191e 	bne	r2,zero,8113b39c <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113b338:	e0fffc03 	ldbu	r3,-16(fp)
8113b33c:	00a045f4 	movhi	r2,33047
8113b340:	10b81c04 	addi	r2,r2,-8080
8113b344:	18c7883a 	add	r3,r3,r3
8113b348:	18c7883a 	add	r3,r3,r3
8113b34c:	10c5883a 	add	r2,r2,r3
8113b350:	10800017 	ldw	r2,0(r2)
8113b354:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113b358:	e0bffd17 	ldw	r2,-12(fp)
8113b35c:	10000f26 	beq	r2,zero,8113b39c <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8113b360:	e0bffd17 	ldw	r2,-12(fp)
8113b364:	10800060 	cmpeqi	r2,r2,1
8113b368:	10000c1e 	bne	r2,zero,8113b39c <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113b36c:	e0bffd17 	ldw	r2,-12(fp)
8113b370:	10c00217 	ldw	r3,8(r2)
8113b374:	e0bffd17 	ldw	r2,-12(fp)
8113b378:	10800317 	ldw	r2,12(r2)
8113b37c:	1085883a 	add	r2,r2,r2
8113b380:	1085883a 	add	r2,r2,r2
8113b384:	1887883a 	add	r3,r3,r2
8113b388:	e0bffd17 	ldw	r2,-12(fp)
8113b38c:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8113b390:	e0ffff17 	ldw	r3,-4(fp)
8113b394:	e0bffd17 	ldw	r2,-12(fp)
8113b398:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113b39c:	e0bffc03 	ldbu	r2,-16(fp)
8113b3a0:	10800044 	addi	r2,r2,1
8113b3a4:	e0bffc05 	stb	r2,-16(fp)
8113b3a8:	e0bffc03 	ldbu	r2,-16(fp)
8113b3ac:	10800af0 	cmpltui	r2,r2,43
8113b3b0:	103fd91e 	bne	r2,zero,8113b318 <__reset+0xfb11b318>
#endif
                }
            }
        }
    }
}
8113b3b4:	0001883a 	nop
8113b3b8:	e037883a 	mov	sp,fp
8113b3bc:	dfc00117 	ldw	ra,4(sp)
8113b3c0:	df000017 	ldw	fp,0(sp)
8113b3c4:	dec00204 	addi	sp,sp,8
8113b3c8:	f800283a 	ret

8113b3cc <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113b3cc:	defff204 	addi	sp,sp,-56
8113b3d0:	de00012e 	bgeu	sp,et,8113b3d8 <OS_TCBInit+0xc>
8113b3d4:	003b68fa 	trap	3
8113b3d8:	dfc00d15 	stw	ra,52(sp)
8113b3dc:	df000c15 	stw	fp,48(sp)
8113b3e0:	df000c04 	addi	fp,sp,48
8113b3e4:	e17ffc15 	stw	r5,-16(fp)
8113b3e8:	e1bffd15 	stw	r6,-12(fp)
8113b3ec:	3807883a 	mov	r3,r7
8113b3f0:	e0800417 	ldw	r2,16(fp)
8113b3f4:	e13ffb05 	stb	r4,-20(fp)
8113b3f8:	e0fffe0d 	sth	r3,-8(fp)
8113b3fc:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b400:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b404:	0005303a 	rdctl	r2,status
8113b408:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b40c:	e0fffa17 	ldw	r3,-24(fp)
8113b410:	00bfff84 	movi	r2,-2
8113b414:	1884703a 	and	r2,r3,r2
8113b418:	1001703a 	wrctl	status,r2
  
  return context;
8113b41c:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8113b420:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8113b424:	d0a09917 	ldw	r2,-32156(gp)
8113b428:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8113b42c:	e0bff617 	ldw	r2,-40(fp)
8113b430:	10009326 	beq	r2,zero,8113b680 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8113b434:	e0bff617 	ldw	r2,-40(fp)
8113b438:	10800517 	ldw	r2,20(r2)
8113b43c:	d0a09915 	stw	r2,-32156(gp)
8113b440:	e0bff417 	ldw	r2,-48(fp)
8113b444:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b448:	e0bff817 	ldw	r2,-32(fp)
8113b44c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8113b450:	e0bff617 	ldw	r2,-40(fp)
8113b454:	e0fffc17 	ldw	r3,-16(fp)
8113b458:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8113b45c:	e0bff617 	ldw	r2,-40(fp)
8113b460:	e0fffb03 	ldbu	r3,-20(fp)
8113b464:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113b468:	e0bff617 	ldw	r2,-40(fp)
8113b46c:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8113b470:	e0bff617 	ldw	r2,-40(fp)
8113b474:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113b478:	e0bff617 	ldw	r2,-40(fp)
8113b47c:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8113b480:	e0bff617 	ldw	r2,-40(fp)
8113b484:	e0c00317 	ldw	r3,12(fp)
8113b488:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113b48c:	e0bff617 	ldw	r2,-40(fp)
8113b490:	e0c00217 	ldw	r3,8(fp)
8113b494:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113b498:	e0bff617 	ldw	r2,-40(fp)
8113b49c:	e0fffd17 	ldw	r3,-12(fp)
8113b4a0:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8113b4a4:	e0bff617 	ldw	r2,-40(fp)
8113b4a8:	e0ffff0b 	ldhu	r3,-4(fp)
8113b4ac:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8113b4b0:	e0bff617 	ldw	r2,-40(fp)
8113b4b4:	e0fffe0b 	ldhu	r3,-8(fp)
8113b4b8:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113b4bc:	e0bff617 	ldw	r2,-40(fp)
8113b4c0:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8113b4c4:	e0bffb03 	ldbu	r2,-20(fp)
8113b4c8:	1004d0fa 	srli	r2,r2,3
8113b4cc:	1007883a 	mov	r3,r2
8113b4d0:	e0bff617 	ldw	r2,-40(fp)
8113b4d4:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113b4d8:	e0bffb03 	ldbu	r2,-20(fp)
8113b4dc:	108001cc 	andi	r2,r2,7
8113b4e0:	1007883a 	mov	r3,r2
8113b4e4:	e0bff617 	ldw	r2,-40(fp)
8113b4e8:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8113b4ec:	e0bff617 	ldw	r2,-40(fp)
8113b4f0:	10800d03 	ldbu	r2,52(r2)
8113b4f4:	10803fcc 	andi	r2,r2,255
8113b4f8:	00c00044 	movi	r3,1
8113b4fc:	1884983a 	sll	r2,r3,r2
8113b500:	1007883a 	mov	r3,r2
8113b504:	e0bff617 	ldw	r2,-40(fp)
8113b508:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8113b50c:	e0bff617 	ldw	r2,-40(fp)
8113b510:	10800cc3 	ldbu	r2,51(r2)
8113b514:	10803fcc 	andi	r2,r2,255
8113b518:	00c00044 	movi	r3,1
8113b51c:	1884983a 	sll	r2,r3,r2
8113b520:	1007883a 	mov	r3,r2
8113b524:	e0bff617 	ldw	r2,-40(fp)
8113b528:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8113b52c:	e0bff617 	ldw	r2,-40(fp)
8113b530:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8113b534:	e0bff617 	ldw	r2,-40(fp)
8113b538:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8113b53c:	e0bff617 	ldw	r2,-40(fp)
8113b540:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8113b544:	e0bff617 	ldw	r2,-40(fp)
8113b548:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8113b54c:	e0bff617 	ldw	r2,-40(fp)
8113b550:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8113b554:	e0bff617 	ldw	r2,-40(fp)
8113b558:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8113b55c:	e0bff617 	ldw	r2,-40(fp)
8113b560:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8113b564:	e0bff617 	ldw	r2,-40(fp)
8113b568:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113b56c:	e0bff617 	ldw	r2,-40(fp)
8113b570:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8113b574:	e0bff617 	ldw	r2,-40(fp)
8113b578:	00c00fc4 	movi	r3,63
8113b57c:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113b580:	e0bff617 	ldw	r2,-40(fp)
8113b584:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113b588:	e13ff617 	ldw	r4,-40(fp)
8113b58c:	114c3700 	call	8114c370 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8113b590:	e13ff617 	ldw	r4,-40(fp)
8113b594:	114c1f80 	call	8114c1f8 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b598:	0005303a 	rdctl	r2,status
8113b59c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b5a0:	e0fff517 	ldw	r3,-44(fp)
8113b5a4:	00bfff84 	movi	r2,-2
8113b5a8:	1884703a 	and	r2,r3,r2
8113b5ac:	1001703a 	wrctl	status,r2
  
  return context;
8113b5b0:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8113b5b4:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113b5b8:	e0fffb03 	ldbu	r3,-20(fp)
8113b5bc:	00a045f4 	movhi	r2,33047
8113b5c0:	10b81c04 	addi	r2,r2,-8080
8113b5c4:	18c7883a 	add	r3,r3,r3
8113b5c8:	18c7883a 	add	r3,r3,r3
8113b5cc:	10c5883a 	add	r2,r2,r3
8113b5d0:	e0fff617 	ldw	r3,-40(fp)
8113b5d4:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113b5d8:	d0e09417 	ldw	r3,-32176(gp)
8113b5dc:	e0bff617 	ldw	r2,-40(fp)
8113b5e0:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8113b5e4:	e0bff617 	ldw	r2,-40(fp)
8113b5e8:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113b5ec:	d0a09417 	ldw	r2,-32176(gp)
8113b5f0:	10000326 	beq	r2,zero,8113b600 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8113b5f4:	d0a09417 	ldw	r2,-32176(gp)
8113b5f8:	e0fff617 	ldw	r3,-40(fp)
8113b5fc:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8113b600:	e0bff617 	ldw	r2,-40(fp)
8113b604:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113b608:	e0bff617 	ldw	r2,-40(fp)
8113b60c:	10c00d83 	ldbu	r3,54(r2)
8113b610:	d0a09e03 	ldbu	r2,-32136(gp)
8113b614:	1884b03a 	or	r2,r3,r2
8113b618:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b61c:	e0bff617 	ldw	r2,-40(fp)
8113b620:	10800d03 	ldbu	r2,52(r2)
8113b624:	10c03fcc 	andi	r3,r2,255
8113b628:	e0bff617 	ldw	r2,-40(fp)
8113b62c:	10800d03 	ldbu	r2,52(r2)
8113b630:	11003fcc 	andi	r4,r2,255
8113b634:	d0a09e44 	addi	r2,gp,-32135
8113b638:	2085883a 	add	r2,r4,r2
8113b63c:	11000003 	ldbu	r4,0(r2)
8113b640:	e0bff617 	ldw	r2,-40(fp)
8113b644:	10800d43 	ldbu	r2,53(r2)
8113b648:	2084b03a 	or	r2,r4,r2
8113b64c:	1009883a 	mov	r4,r2
8113b650:	d0a09e44 	addi	r2,gp,-32135
8113b654:	1885883a 	add	r2,r3,r2
8113b658:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113b65c:	d0a09a43 	ldbu	r2,-32151(gp)
8113b660:	10800044 	addi	r2,r2,1
8113b664:	d0a09a45 	stb	r2,-32151(gp)
8113b668:	e0bff417 	ldw	r2,-48(fp)
8113b66c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b670:	e0bff717 	ldw	r2,-36(fp)
8113b674:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113b678:	0005883a 	mov	r2,zero
8113b67c:	00000506 	br	8113b694 <OS_TCBInit+0x2c8>
8113b680:	e0bff417 	ldw	r2,-48(fp)
8113b684:	e0bff915 	stw	r2,-28(fp)
8113b688:	e0bff917 	ldw	r2,-28(fp)
8113b68c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8113b690:	00801084 	movi	r2,66
}
8113b694:	e037883a 	mov	sp,fp
8113b698:	dfc00117 	ldw	ra,4(sp)
8113b69c:	df000017 	ldw	fp,0(sp)
8113b6a0:	dec00204 	addi	sp,sp,8
8113b6a4:	f800283a 	ret

8113b6a8 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113b6a8:	defffe04 	addi	sp,sp,-8
8113b6ac:	de00012e 	bgeu	sp,et,8113b6b4 <OSDebugInit+0xc>
8113b6b0:	003b68fa 	trap	3
8113b6b4:	df000115 	stw	fp,4(sp)
8113b6b8:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113b6bc:	d0a01804 	addi	r2,gp,-32672
8113b6c0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8113b6c4:	d0a01904 	addi	r2,gp,-32668
8113b6c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113b6cc:	d0a01a84 	addi	r2,gp,-32662
8113b6d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8113b6d4:	d0a01b04 	addi	r2,gp,-32660
8113b6d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113b6dc:	d0a01a04 	addi	r2,gp,-32664
8113b6e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8113b6e4:	d0a01b84 	addi	r2,gp,-32658
8113b6e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113b6ec:	d0a01c04 	addi	r2,gp,-32656
8113b6f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8113b6f4:	d0a01c84 	addi	r2,gp,-32654
8113b6f8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113b6fc:	d0a01d04 	addi	r2,gp,-32652
8113b700:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113b704:	d0a01d84 	addi	r2,gp,-32650
8113b708:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8113b70c:	d0a01e04 	addi	r2,gp,-32648
8113b710:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113b714:	d0a01e84 	addi	r2,gp,-32646
8113b718:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8113b71c:	d0a01f04 	addi	r2,gp,-32644
8113b720:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113b724:	d0a01f84 	addi	r2,gp,-32642
8113b728:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8113b72c:	d0a02004 	addi	r2,gp,-32640
8113b730:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113b734:	d0a02084 	addi	r2,gp,-32638
8113b738:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8113b73c:	d0a02104 	addi	r2,gp,-32636
8113b740:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113b744:	d0a02184 	addi	r2,gp,-32634
8113b748:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113b74c:	d0a02204 	addi	r2,gp,-32632
8113b750:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113b754:	d0a02284 	addi	r2,gp,-32630
8113b758:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113b75c:	d0a02304 	addi	r2,gp,-32628
8113b760:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113b764:	d0a02384 	addi	r2,gp,-32626
8113b768:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113b76c:	d0a02404 	addi	r2,gp,-32624
8113b770:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113b774:	d0a02484 	addi	r2,gp,-32622
8113b778:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113b77c:	d0a02504 	addi	r2,gp,-32620
8113b780:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113b784:	d0a02584 	addi	r2,gp,-32618
8113b788:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113b78c:	d0a02604 	addi	r2,gp,-32616
8113b790:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113b794:	d0a02684 	addi	r2,gp,-32614
8113b798:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113b79c:	d0a02704 	addi	r2,gp,-32612
8113b7a0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8113b7a4:	d0a02784 	addi	r2,gp,-32610
8113b7a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113b7ac:	d0a02804 	addi	r2,gp,-32608
8113b7b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8113b7b4:	d0a02884 	addi	r2,gp,-32606
8113b7b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113b7bc:	d0a02904 	addi	r2,gp,-32604
8113b7c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8113b7c4:	d0a02984 	addi	r2,gp,-32602
8113b7c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113b7cc:	d0a02a04 	addi	r2,gp,-32600
8113b7d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8113b7d4:	d0a02a84 	addi	r2,gp,-32598
8113b7d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113b7dc:	d0a02b04 	addi	r2,gp,-32596
8113b7e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8113b7e4:	d0a02b84 	addi	r2,gp,-32594
8113b7e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113b7ec:	d0a02c04 	addi	r2,gp,-32592
8113b7f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8113b7f4:	d0a02c84 	addi	r2,gp,-32590
8113b7f8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113b7fc:	d0a02d04 	addi	r2,gp,-32588
8113b800:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113b804:	d0a02d84 	addi	r2,gp,-32586
8113b808:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8113b80c:	d0a02e04 	addi	r2,gp,-32584
8113b810:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113b814:	d0a02e84 	addi	r2,gp,-32582
8113b818:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8113b81c:	00a045f4 	movhi	r2,33047
8113b820:	10a23a04 	addi	r2,r2,-30488
8113b824:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113b828:	00a045f4 	movhi	r2,33047
8113b82c:	10a02604 	addi	r2,r2,-32616
8113b830:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113b834:	d0a02f84 	addi	r2,gp,-32578
8113b838:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8113b83c:	d0a03004 	addi	r2,gp,-32576
8113b840:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113b844:	d0a03084 	addi	r2,gp,-32574
8113b848:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113b84c:	d0a03104 	addi	r2,gp,-32572
8113b850:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113b854:	d0a03184 	addi	r2,gp,-32570
8113b858:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113b85c:	d0a03204 	addi	r2,gp,-32568
8113b860:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113b864:	d0a03284 	addi	r2,gp,-32566
8113b868:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113b86c:	d0a03304 	addi	r2,gp,-32564
8113b870:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113b874:	d0a03384 	addi	r2,gp,-32562
8113b878:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113b87c:	d0a02f04 	addi	r2,gp,-32580
8113b880:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113b884:	d0a03404 	addi	r2,gp,-32560
8113b888:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113b88c:	0001883a 	nop
8113b890:	e037883a 	mov	sp,fp
8113b894:	df000017 	ldw	fp,0(sp)
8113b898:	dec00104 	addi	sp,sp,4
8113b89c:	f800283a 	ret

8113b8a0 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113b8a0:	defff204 	addi	sp,sp,-56
8113b8a4:	de00012e 	bgeu	sp,et,8113b8ac <OSFlagAccept+0xc>
8113b8a8:	003b68fa 	trap	3
8113b8ac:	df000d15 	stw	fp,52(sp)
8113b8b0:	df000d04 	addi	fp,sp,52
8113b8b4:	e13ffc15 	stw	r4,-16(fp)
8113b8b8:	2807883a 	mov	r3,r5
8113b8bc:	3005883a 	mov	r2,r6
8113b8c0:	e1ffff15 	stw	r7,-4(fp)
8113b8c4:	e0fffd0d 	sth	r3,-12(fp)
8113b8c8:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113b8cc:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113b8d0:	e0bfff17 	ldw	r2,-4(fp)
8113b8d4:	1000021e 	bne	r2,zero,8113b8e0 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113b8d8:	0005883a 	mov	r2,zero
8113b8dc:	0000b006 	br	8113bba0 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113b8e0:	e0bffc17 	ldw	r2,-16(fp)
8113b8e4:	1000051e 	bne	r2,zero,8113b8fc <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b8e8:	e0bfff17 	ldw	r2,-4(fp)
8113b8ec:	00c01b84 	movi	r3,110
8113b8f0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b8f4:	0005883a 	mov	r2,zero
8113b8f8:	0000a906 	br	8113bba0 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113b8fc:	e0bffc17 	ldw	r2,-16(fp)
8113b900:	10800003 	ldbu	r2,0(r2)
8113b904:	10803fcc 	andi	r2,r2,255
8113b908:	10800160 	cmpeqi	r2,r2,5
8113b90c:	1000051e 	bne	r2,zero,8113b924 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8113b910:	e0bfff17 	ldw	r2,-4(fp)
8113b914:	00c00044 	movi	r3,1
8113b918:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b91c:	0005883a 	mov	r2,zero
8113b920:	00009f06 	br	8113bba0 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113b924:	e0fffe03 	ldbu	r3,-8(fp)
8113b928:	00bfe004 	movi	r2,-128
8113b92c:	1884703a 	and	r2,r3,r2
8113b930:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113b934:	e0bff503 	ldbu	r2,-44(fp)
8113b938:	10000626 	beq	r2,zero,8113b954 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8113b93c:	e0bffe03 	ldbu	r2,-8(fp)
8113b940:	10801fcc 	andi	r2,r2,127
8113b944:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113b948:	00800044 	movi	r2,1
8113b94c:	e0bff385 	stb	r2,-50(fp)
8113b950:	00000106 	br	8113b958 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113b954:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113b958:	e0bfff17 	ldw	r2,-4(fp)
8113b95c:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b960:	0005303a 	rdctl	r2,status
8113b964:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b968:	e0fffb17 	ldw	r3,-20(fp)
8113b96c:	00bfff84 	movi	r2,-2
8113b970:	1884703a 	and	r2,r3,r2
8113b974:	1001703a 	wrctl	status,r2
  
  return context;
8113b978:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113b97c:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113b980:	e0bffe03 	ldbu	r2,-8(fp)
8113b984:	10c00060 	cmpeqi	r3,r2,1
8113b988:	18005f1e 	bne	r3,zero,8113bb08 <OSFlagAccept+0x268>
8113b98c:	10c00088 	cmpgei	r3,r2,2
8113b990:	1800021e 	bne	r3,zero,8113b99c <OSFlagAccept+0xfc>
8113b994:	10003f26 	beq	r2,zero,8113ba94 <OSFlagAccept+0x1f4>
8113b998:	00007706 	br	8113bb78 <OSFlagAccept+0x2d8>
8113b99c:	10c000a0 	cmpeqi	r3,r2,2
8113b9a0:	1800031e 	bne	r3,zero,8113b9b0 <OSFlagAccept+0x110>
8113b9a4:	108000e0 	cmpeqi	r2,r2,3
8113b9a8:	10001e1e 	bne	r2,zero,8113ba24 <OSFlagAccept+0x184>
8113b9ac:	00007206 	br	8113bb78 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113b9b0:	e0bffc17 	ldw	r2,-16(fp)
8113b9b4:	10c0020b 	ldhu	r3,8(r2)
8113b9b8:	e0bffd0b 	ldhu	r2,-12(fp)
8113b9bc:	1884703a 	and	r2,r3,r2
8113b9c0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113b9c4:	e0fff30b 	ldhu	r3,-52(fp)
8113b9c8:	e0bffd0b 	ldhu	r2,-12(fp)
8113b9cc:	18800d1e 	bne	r3,r2,8113ba04 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113b9d0:	e0bff383 	ldbu	r2,-50(fp)
8113b9d4:	10800058 	cmpnei	r2,r2,1
8113b9d8:	10000d1e 	bne	r2,zero,8113ba10 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113b9dc:	e0bffc17 	ldw	r2,-16(fp)
8113b9e0:	1080020b 	ldhu	r2,8(r2)
8113b9e4:	1007883a 	mov	r3,r2
8113b9e8:	e0bff30b 	ldhu	r2,-52(fp)
8113b9ec:	0084303a 	nor	r2,zero,r2
8113b9f0:	1884703a 	and	r2,r3,r2
8113b9f4:	1007883a 	mov	r3,r2
8113b9f8:	e0bffc17 	ldw	r2,-16(fp)
8113b9fc:	10c0020d 	sth	r3,8(r2)
8113ba00:	00000306 	br	8113ba10 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113ba04:	e0bfff17 	ldw	r2,-4(fp)
8113ba08:	00c01c04 	movi	r3,112
8113ba0c:	10c00005 	stb	r3,0(r2)
8113ba10:	e0bff417 	ldw	r2,-48(fp)
8113ba14:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ba18:	e0bff617 	ldw	r2,-40(fp)
8113ba1c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113ba20:	00005e06 	br	8113bb9c <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113ba24:	e0bffc17 	ldw	r2,-16(fp)
8113ba28:	10c0020b 	ldhu	r3,8(r2)
8113ba2c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ba30:	1884703a 	and	r2,r3,r2
8113ba34:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113ba38:	e0bff30b 	ldhu	r2,-52(fp)
8113ba3c:	10000d26 	beq	r2,zero,8113ba74 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113ba40:	e0bff383 	ldbu	r2,-50(fp)
8113ba44:	10800058 	cmpnei	r2,r2,1
8113ba48:	10000d1e 	bne	r2,zero,8113ba80 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113ba4c:	e0bffc17 	ldw	r2,-16(fp)
8113ba50:	1080020b 	ldhu	r2,8(r2)
8113ba54:	1007883a 	mov	r3,r2
8113ba58:	e0bff30b 	ldhu	r2,-52(fp)
8113ba5c:	0084303a 	nor	r2,zero,r2
8113ba60:	1884703a 	and	r2,r3,r2
8113ba64:	1007883a 	mov	r3,r2
8113ba68:	e0bffc17 	ldw	r2,-16(fp)
8113ba6c:	10c0020d 	sth	r3,8(r2)
8113ba70:	00000306 	br	8113ba80 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113ba74:	e0bfff17 	ldw	r2,-4(fp)
8113ba78:	00c01c04 	movi	r3,112
8113ba7c:	10c00005 	stb	r3,0(r2)
8113ba80:	e0bff417 	ldw	r2,-48(fp)
8113ba84:	e0bff715 	stw	r2,-36(fp)
8113ba88:	e0bff717 	ldw	r2,-36(fp)
8113ba8c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113ba90:	00004206 	br	8113bb9c <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113ba94:	e0bffc17 	ldw	r2,-16(fp)
8113ba98:	1080020b 	ldhu	r2,8(r2)
8113ba9c:	0084303a 	nor	r2,zero,r2
8113baa0:	1007883a 	mov	r3,r2
8113baa4:	e0bffd0b 	ldhu	r2,-12(fp)
8113baa8:	1884703a 	and	r2,r3,r2
8113baac:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113bab0:	e0fff30b 	ldhu	r3,-52(fp)
8113bab4:	e0bffd0b 	ldhu	r2,-12(fp)
8113bab8:	18800b1e 	bne	r3,r2,8113bae8 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113babc:	e0bff383 	ldbu	r2,-50(fp)
8113bac0:	10800058 	cmpnei	r2,r2,1
8113bac4:	10000b1e 	bne	r2,zero,8113baf4 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113bac8:	e0bffc17 	ldw	r2,-16(fp)
8113bacc:	10c0020b 	ldhu	r3,8(r2)
8113bad0:	e0bff30b 	ldhu	r2,-52(fp)
8113bad4:	1884b03a 	or	r2,r3,r2
8113bad8:	1007883a 	mov	r3,r2
8113badc:	e0bffc17 	ldw	r2,-16(fp)
8113bae0:	10c0020d 	sth	r3,8(r2)
8113bae4:	00000306 	br	8113baf4 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113bae8:	e0bfff17 	ldw	r2,-4(fp)
8113baec:	00c01c04 	movi	r3,112
8113baf0:	10c00005 	stb	r3,0(r2)
8113baf4:	e0bff417 	ldw	r2,-48(fp)
8113baf8:	e0bff815 	stw	r2,-32(fp)
8113bafc:	e0bff817 	ldw	r2,-32(fp)
8113bb00:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113bb04:	00002506 	br	8113bb9c <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113bb08:	e0bffc17 	ldw	r2,-16(fp)
8113bb0c:	1080020b 	ldhu	r2,8(r2)
8113bb10:	0084303a 	nor	r2,zero,r2
8113bb14:	1007883a 	mov	r3,r2
8113bb18:	e0bffd0b 	ldhu	r2,-12(fp)
8113bb1c:	1884703a 	and	r2,r3,r2
8113bb20:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113bb24:	e0bff30b 	ldhu	r2,-52(fp)
8113bb28:	10000b26 	beq	r2,zero,8113bb58 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113bb2c:	e0bff383 	ldbu	r2,-50(fp)
8113bb30:	10800058 	cmpnei	r2,r2,1
8113bb34:	10000b1e 	bne	r2,zero,8113bb64 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113bb38:	e0bffc17 	ldw	r2,-16(fp)
8113bb3c:	10c0020b 	ldhu	r3,8(r2)
8113bb40:	e0bff30b 	ldhu	r2,-52(fp)
8113bb44:	1884b03a 	or	r2,r3,r2
8113bb48:	1007883a 	mov	r3,r2
8113bb4c:	e0bffc17 	ldw	r2,-16(fp)
8113bb50:	10c0020d 	sth	r3,8(r2)
8113bb54:	00000306 	br	8113bb64 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113bb58:	e0bfff17 	ldw	r2,-4(fp)
8113bb5c:	00c01c04 	movi	r3,112
8113bb60:	10c00005 	stb	r3,0(r2)
8113bb64:	e0bff417 	ldw	r2,-48(fp)
8113bb68:	e0bff915 	stw	r2,-28(fp)
8113bb6c:	e0bff917 	ldw	r2,-28(fp)
8113bb70:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113bb74:	00000906 	br	8113bb9c <OSFlagAccept+0x2fc>
8113bb78:	e0bff417 	ldw	r2,-48(fp)
8113bb7c:	e0bffa15 	stw	r2,-24(fp)
8113bb80:	e0bffa17 	ldw	r2,-24(fp)
8113bb84:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113bb88:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113bb8c:	e0bfff17 	ldw	r2,-4(fp)
8113bb90:	00c01bc4 	movi	r3,111
8113bb94:	10c00005 	stb	r3,0(r2)
             break;
8113bb98:	0001883a 	nop
    }
    return (flags_rdy);
8113bb9c:	e0bff30b 	ldhu	r2,-52(fp)
}
8113bba0:	e037883a 	mov	sp,fp
8113bba4:	df000017 	ldw	fp,0(sp)
8113bba8:	dec00104 	addi	sp,sp,4
8113bbac:	f800283a 	ret

8113bbb0 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113bbb0:	defff804 	addi	sp,sp,-32
8113bbb4:	de00012e 	bgeu	sp,et,8113bbbc <OSFlagCreate+0xc>
8113bbb8:	003b68fa 	trap	3
8113bbbc:	df000715 	stw	fp,28(sp)
8113bbc0:	df000704 	addi	fp,sp,28
8113bbc4:	2005883a 	mov	r2,r4
8113bbc8:	e17fff15 	stw	r5,-4(fp)
8113bbcc:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113bbd0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113bbd4:	e0bfff17 	ldw	r2,-4(fp)
8113bbd8:	1000021e 	bne	r2,zero,8113bbe4 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113bbdc:	0005883a 	mov	r2,zero
8113bbe0:	00003306 	br	8113bcb0 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113bbe4:	d0a0a103 	ldbu	r2,-32124(gp)
8113bbe8:	10803fcc 	andi	r2,r2,255
8113bbec:	10000526 	beq	r2,zero,8113bc04 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113bbf0:	e0bfff17 	ldw	r2,-4(fp)
8113bbf4:	00c00404 	movi	r3,16
8113bbf8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113bbfc:	0005883a 	mov	r2,zero
8113bc00:	00002b06 	br	8113bcb0 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bc04:	0005303a 	rdctl	r2,status
8113bc08:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bc0c:	e0fffd17 	ldw	r3,-12(fp)
8113bc10:	00bfff84 	movi	r2,-2
8113bc14:	1884703a 	and	r2,r3,r2
8113bc18:	1001703a 	wrctl	status,r2
  
  return context;
8113bc1c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113bc20:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113bc24:	d0a0a617 	ldw	r2,-32104(gp)
8113bc28:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113bc2c:	e0bffb17 	ldw	r2,-20(fp)
8113bc30:	10001726 	beq	r2,zero,8113bc90 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113bc34:	d0a0a617 	ldw	r2,-32104(gp)
8113bc38:	10800117 	ldw	r2,4(r2)
8113bc3c:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113bc40:	e0bffb17 	ldw	r2,-20(fp)
8113bc44:	00c00144 	movi	r3,5
8113bc48:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113bc4c:	e0bffb17 	ldw	r2,-20(fp)
8113bc50:	e0fffe0b 	ldhu	r3,-8(fp)
8113bc54:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113bc58:	e0bffb17 	ldw	r2,-20(fp)
8113bc5c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113bc60:	e0bffb17 	ldw	r2,-20(fp)
8113bc64:	00c00fc4 	movi	r3,63
8113bc68:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113bc6c:	e0bffb17 	ldw	r2,-20(fp)
8113bc70:	100002c5 	stb	zero,11(r2)
8113bc74:	e0bff917 	ldw	r2,-28(fp)
8113bc78:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bc7c:	e0bffa17 	ldw	r2,-24(fp)
8113bc80:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113bc84:	e0bfff17 	ldw	r2,-4(fp)
8113bc88:	10000005 	stb	zero,0(r2)
8113bc8c:	00000706 	br	8113bcac <OSFlagCreate+0xfc>
8113bc90:	e0bff917 	ldw	r2,-28(fp)
8113bc94:	e0bffc15 	stw	r2,-16(fp)
8113bc98:	e0bffc17 	ldw	r2,-16(fp)
8113bc9c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113bca0:	e0bfff17 	ldw	r2,-4(fp)
8113bca4:	00c01c84 	movi	r3,114
8113bca8:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113bcac:	e0bffb17 	ldw	r2,-20(fp)
}
8113bcb0:	e037883a 	mov	sp,fp
8113bcb4:	df000017 	ldw	fp,0(sp)
8113bcb8:	dec00104 	addi	sp,sp,4
8113bcbc:	f800283a 	ret

8113bcc0 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113bcc0:	defff204 	addi	sp,sp,-56
8113bcc4:	de00012e 	bgeu	sp,et,8113bccc <OSFlagDel+0xc>
8113bcc8:	003b68fa 	trap	3
8113bccc:	dfc00d15 	stw	ra,52(sp)
8113bcd0:	df000c15 	stw	fp,48(sp)
8113bcd4:	df000c04 	addi	fp,sp,48
8113bcd8:	e13ffd15 	stw	r4,-12(fp)
8113bcdc:	2805883a 	mov	r2,r5
8113bce0:	e1bfff15 	stw	r6,-4(fp)
8113bce4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113bce8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113bcec:	e0bfff17 	ldw	r2,-4(fp)
8113bcf0:	1000021e 	bne	r2,zero,8113bcfc <OSFlagDel+0x3c>
        return (pgrp);
8113bcf4:	e0bffd17 	ldw	r2,-12(fp)
8113bcf8:	00008006 	br	8113befc <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113bcfc:	e0bffd17 	ldw	r2,-12(fp)
8113bd00:	1000051e 	bne	r2,zero,8113bd18 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113bd04:	e0bfff17 	ldw	r2,-4(fp)
8113bd08:	00c01b84 	movi	r3,110
8113bd0c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113bd10:	e0bffd17 	ldw	r2,-12(fp)
8113bd14:	00007906 	br	8113befc <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113bd18:	d0a0a103 	ldbu	r2,-32124(gp)
8113bd1c:	10803fcc 	andi	r2,r2,255
8113bd20:	10000526 	beq	r2,zero,8113bd38 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113bd24:	e0bfff17 	ldw	r2,-4(fp)
8113bd28:	00c003c4 	movi	r3,15
8113bd2c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113bd30:	e0bffd17 	ldw	r2,-12(fp)
8113bd34:	00007106 	br	8113befc <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113bd38:	e0bffd17 	ldw	r2,-12(fp)
8113bd3c:	10800003 	ldbu	r2,0(r2)
8113bd40:	10803fcc 	andi	r2,r2,255
8113bd44:	10800160 	cmpeqi	r2,r2,5
8113bd48:	1000051e 	bne	r2,zero,8113bd60 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113bd4c:	e0bfff17 	ldw	r2,-4(fp)
8113bd50:	00c00044 	movi	r3,1
8113bd54:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113bd58:	e0bffd17 	ldw	r2,-12(fp)
8113bd5c:	00006706 	br	8113befc <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bd60:	0005303a 	rdctl	r2,status
8113bd64:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd68:	e0fffc17 	ldw	r3,-16(fp)
8113bd6c:	00bfff84 	movi	r2,-2
8113bd70:	1884703a 	and	r2,r3,r2
8113bd74:	1001703a 	wrctl	status,r2
  
  return context;
8113bd78:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bd7c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113bd80:	e0bffd17 	ldw	r2,-12(fp)
8113bd84:	10800117 	ldw	r2,4(r2)
8113bd88:	10000326 	beq	r2,zero,8113bd98 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113bd8c:	00800044 	movi	r2,1
8113bd90:	e0bff405 	stb	r2,-48(fp)
8113bd94:	00000106 	br	8113bd9c <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113bd98:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113bd9c:	e0bffe03 	ldbu	r2,-8(fp)
8113bda0:	10000326 	beq	r2,zero,8113bdb0 <OSFlagDel+0xf0>
8113bda4:	10800060 	cmpeqi	r2,r2,1
8113bda8:	1000231e 	bne	r2,zero,8113be38 <OSFlagDel+0x178>
8113bdac:	00004806 	br	8113bed0 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113bdb0:	e0bff403 	ldbu	r2,-48(fp)
8113bdb4:	1000161e 	bne	r2,zero,8113be10 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113bdb8:	e0bffd17 	ldw	r2,-12(fp)
8113bdbc:	00c00fc4 	movi	r3,63
8113bdc0:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113bdc4:	e0bffd17 	ldw	r2,-12(fp)
8113bdc8:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113bdcc:	e0bffd17 	ldw	r2,-12(fp)
8113bdd0:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113bdd4:	d0e0a617 	ldw	r3,-32104(gp)
8113bdd8:	e0bffd17 	ldw	r2,-12(fp)
8113bddc:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113bde0:	e0bffd17 	ldw	r2,-12(fp)
8113bde4:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113bde8:	e0bffd17 	ldw	r2,-12(fp)
8113bdec:	d0a0a615 	stw	r2,-32104(gp)
8113bdf0:	e0bff717 	ldw	r2,-36(fp)
8113bdf4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bdf8:	e0bff817 	ldw	r2,-32(fp)
8113bdfc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113be00:	e0bfff17 	ldw	r2,-4(fp)
8113be04:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113be08:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113be0c:	00003a06 	br	8113bef8 <OSFlagDel+0x238>
8113be10:	e0bff717 	ldw	r2,-36(fp)
8113be14:	e0bff915 	stw	r2,-28(fp)
8113be18:	e0bff917 	ldw	r2,-28(fp)
8113be1c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113be20:	e0bfff17 	ldw	r2,-4(fp)
8113be24:	00c01244 	movi	r3,73
8113be28:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113be2c:	e0bffd17 	ldw	r2,-12(fp)
8113be30:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113be34:	00003006 	br	8113bef8 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113be38:	e0bffd17 	ldw	r2,-12(fp)
8113be3c:	10800117 	ldw	r2,4(r2)
8113be40:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113be44:	00000606 	br	8113be60 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113be48:	000b883a 	mov	r5,zero
8113be4c:	e13ff517 	ldw	r4,-44(fp)
8113be50:	113ce740 	call	8113ce74 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113be54:	e0bff517 	ldw	r2,-44(fp)
8113be58:	10800017 	ldw	r2,0(r2)
8113be5c:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113be60:	e0bff517 	ldw	r2,-44(fp)
8113be64:	103ff81e 	bne	r2,zero,8113be48 <__reset+0xfb11be48>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113be68:	e0bffd17 	ldw	r2,-12(fp)
8113be6c:	00c00fc4 	movi	r3,63
8113be70:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113be74:	e0bffd17 	ldw	r2,-12(fp)
8113be78:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113be7c:	e0bffd17 	ldw	r2,-12(fp)
8113be80:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113be84:	d0e0a617 	ldw	r3,-32104(gp)
8113be88:	e0bffd17 	ldw	r2,-12(fp)
8113be8c:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113be90:	e0bffd17 	ldw	r2,-12(fp)
8113be94:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113be98:	e0bffd17 	ldw	r2,-12(fp)
8113be9c:	d0a0a615 	stw	r2,-32104(gp)
8113bea0:	e0bff717 	ldw	r2,-36(fp)
8113bea4:	e0bffa15 	stw	r2,-24(fp)
8113bea8:	e0bffa17 	ldw	r2,-24(fp)
8113beac:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113beb0:	e0bff403 	ldbu	r2,-48(fp)
8113beb4:	10800058 	cmpnei	r2,r2,1
8113beb8:	1000011e 	bne	r2,zero,8113bec0 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113bebc:	113af840 	call	8113af84 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113bec0:	e0bfff17 	ldw	r2,-4(fp)
8113bec4:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113bec8:	e03ff615 	stw	zero,-40(fp)
             break;
8113becc:	00000a06 	br	8113bef8 <OSFlagDel+0x238>
8113bed0:	e0bff717 	ldw	r2,-36(fp)
8113bed4:	e0bffb15 	stw	r2,-20(fp)
8113bed8:	e0bffb17 	ldw	r2,-20(fp)
8113bedc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113bee0:	e0bfff17 	ldw	r2,-4(fp)
8113bee4:	00c001c4 	movi	r3,7
8113bee8:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113beec:	e0bffd17 	ldw	r2,-12(fp)
8113bef0:	e0bff615 	stw	r2,-40(fp)
             break;
8113bef4:	0001883a 	nop
    }
    return (pgrp_return);
8113bef8:	e0bff617 	ldw	r2,-40(fp)
}
8113befc:	e037883a 	mov	sp,fp
8113bf00:	dfc00117 	ldw	ra,4(sp)
8113bf04:	df000017 	ldw	fp,0(sp)
8113bf08:	dec00204 	addi	sp,sp,8
8113bf0c:	f800283a 	ret

8113bf10 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113bf10:	defff604 	addi	sp,sp,-40
8113bf14:	de00012e 	bgeu	sp,et,8113bf1c <OSFlagNameGet+0xc>
8113bf18:	003b68fa 	trap	3
8113bf1c:	dfc00915 	stw	ra,36(sp)
8113bf20:	df000815 	stw	fp,32(sp)
8113bf24:	df000804 	addi	fp,sp,32
8113bf28:	e13ffd15 	stw	r4,-12(fp)
8113bf2c:	e17ffe15 	stw	r5,-8(fp)
8113bf30:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bf34:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113bf38:	e0bfff17 	ldw	r2,-4(fp)
8113bf3c:	1000021e 	bne	r2,zero,8113bf48 <OSFlagNameGet+0x38>
        return (0);
8113bf40:	0005883a 	mov	r2,zero
8113bf44:	00003906 	br	8113c02c <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113bf48:	e0bffd17 	ldw	r2,-12(fp)
8113bf4c:	1000051e 	bne	r2,zero,8113bf64 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113bf50:	e0bfff17 	ldw	r2,-4(fp)
8113bf54:	00c01b84 	movi	r3,110
8113bf58:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf5c:	0005883a 	mov	r2,zero
8113bf60:	00003206 	br	8113c02c <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113bf64:	e0bffe17 	ldw	r2,-8(fp)
8113bf68:	1000051e 	bne	r2,zero,8113bf80 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113bf6c:	e0bfff17 	ldw	r2,-4(fp)
8113bf70:	00c00304 	movi	r3,12
8113bf74:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf78:	0005883a 	mov	r2,zero
8113bf7c:	00002b06 	br	8113c02c <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113bf80:	d0a0a103 	ldbu	r2,-32124(gp)
8113bf84:	10803fcc 	andi	r2,r2,255
8113bf88:	10000526 	beq	r2,zero,8113bfa0 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113bf8c:	e0bfff17 	ldw	r2,-4(fp)
8113bf90:	00c00444 	movi	r3,17
8113bf94:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf98:	0005883a 	mov	r2,zero
8113bf9c:	00002306 	br	8113c02c <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bfa0:	0005303a 	rdctl	r2,status
8113bfa4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bfa8:	e0fffc17 	ldw	r3,-16(fp)
8113bfac:	00bfff84 	movi	r2,-2
8113bfb0:	1884703a 	and	r2,r3,r2
8113bfb4:	1001703a 	wrctl	status,r2
  
  return context;
8113bfb8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bfbc:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113bfc0:	e0bffd17 	ldw	r2,-12(fp)
8113bfc4:	10800003 	ldbu	r2,0(r2)
8113bfc8:	10803fcc 	andi	r2,r2,255
8113bfcc:	10800160 	cmpeqi	r2,r2,5
8113bfd0:	1000091e 	bne	r2,zero,8113bff8 <OSFlagNameGet+0xe8>
8113bfd4:	e0bff817 	ldw	r2,-32(fp)
8113bfd8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bfdc:	e0bff917 	ldw	r2,-28(fp)
8113bfe0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113bfe4:	e0bfff17 	ldw	r2,-4(fp)
8113bfe8:	00c00044 	movi	r3,1
8113bfec:	10c00005 	stb	r3,0(r2)
        return (0);
8113bff0:	0005883a 	mov	r2,zero
8113bff4:	00000d06 	br	8113c02c <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113bff8:	e0bffd17 	ldw	r2,-12(fp)
8113bffc:	10800284 	addi	r2,r2,10
8113c000:	100b883a 	mov	r5,r2
8113c004:	e13ffe17 	ldw	r4,-8(fp)
8113c008:	113b0d80 	call	8113b0d8 <OS_StrCopy>
8113c00c:	e0bffb05 	stb	r2,-20(fp)
8113c010:	e0bff817 	ldw	r2,-32(fp)
8113c014:	e0bffa15 	stw	r2,-24(fp)
8113c018:	e0bffa17 	ldw	r2,-24(fp)
8113c01c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c020:	e0bfff17 	ldw	r2,-4(fp)
8113c024:	10000005 	stb	zero,0(r2)
    return (len);
8113c028:	e0bffb03 	ldbu	r2,-20(fp)
}
8113c02c:	e037883a 	mov	sp,fp
8113c030:	dfc00117 	ldw	ra,4(sp)
8113c034:	df000017 	ldw	fp,0(sp)
8113c038:	dec00204 	addi	sp,sp,8
8113c03c:	f800283a 	ret

8113c040 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113c040:	defff504 	addi	sp,sp,-44
8113c044:	de00012e 	bgeu	sp,et,8113c04c <OSFlagNameSet+0xc>
8113c048:	003b68fa 	trap	3
8113c04c:	dfc00a15 	stw	ra,40(sp)
8113c050:	df000915 	stw	fp,36(sp)
8113c054:	df000904 	addi	fp,sp,36
8113c058:	e13ffd15 	stw	r4,-12(fp)
8113c05c:	e17ffe15 	stw	r5,-8(fp)
8113c060:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c064:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113c068:	e0bfff17 	ldw	r2,-4(fp)
8113c06c:	10004326 	beq	r2,zero,8113c17c <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113c070:	e0bffd17 	ldw	r2,-12(fp)
8113c074:	1000041e 	bne	r2,zero,8113c088 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c078:	e0bfff17 	ldw	r2,-4(fp)
8113c07c:	00c01b84 	movi	r3,110
8113c080:	10c00005 	stb	r3,0(r2)
        return;
8113c084:	00003e06 	br	8113c180 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113c088:	e0bffe17 	ldw	r2,-8(fp)
8113c08c:	1000041e 	bne	r2,zero,8113c0a0 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113c090:	e0bfff17 	ldw	r2,-4(fp)
8113c094:	00c00304 	movi	r3,12
8113c098:	10c00005 	stb	r3,0(r2)
        return;
8113c09c:	00003806 	br	8113c180 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c0a0:	d0a0a103 	ldbu	r2,-32124(gp)
8113c0a4:	10803fcc 	andi	r2,r2,255
8113c0a8:	10000426 	beq	r2,zero,8113c0bc <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113c0ac:	e0bfff17 	ldw	r2,-4(fp)
8113c0b0:	00c00484 	movi	r3,18
8113c0b4:	10c00005 	stb	r3,0(r2)
        return;
8113c0b8:	00003106 	br	8113c180 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c0bc:	0005303a 	rdctl	r2,status
8113c0c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c0c4:	e0fffc17 	ldw	r3,-16(fp)
8113c0c8:	00bfff84 	movi	r2,-2
8113c0cc:	1884703a 	and	r2,r3,r2
8113c0d0:	1001703a 	wrctl	status,r2
  
  return context;
8113c0d4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c0d8:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113c0dc:	e0bffd17 	ldw	r2,-12(fp)
8113c0e0:	10800003 	ldbu	r2,0(r2)
8113c0e4:	10803fcc 	andi	r2,r2,255
8113c0e8:	10800160 	cmpeqi	r2,r2,5
8113c0ec:	1000081e 	bne	r2,zero,8113c110 <OSFlagNameSet+0xd0>
8113c0f0:	e0bff717 	ldw	r2,-36(fp)
8113c0f4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c0f8:	e0bff817 	ldw	r2,-32(fp)
8113c0fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113c100:	e0bfff17 	ldw	r2,-4(fp)
8113c104:	00c00044 	movi	r3,1
8113c108:	10c00005 	stb	r3,0(r2)
        return;
8113c10c:	00001c06 	br	8113c180 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113c110:	e13ffe17 	ldw	r4,-8(fp)
8113c114:	113b1540 	call	8113b154 <OS_StrLen>
8113c118:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113c11c:	e0bffa03 	ldbu	r2,-24(fp)
8113c120:	10800830 	cmpltui	r2,r2,32
8113c124:	1000081e 	bne	r2,zero,8113c148 <OSFlagNameSet+0x108>
8113c128:	e0bff717 	ldw	r2,-36(fp)
8113c12c:	e0bff915 	stw	r2,-28(fp)
8113c130:	e0bff917 	ldw	r2,-28(fp)
8113c134:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113c138:	e0bfff17 	ldw	r2,-4(fp)
8113c13c:	00c01cc4 	movi	r3,115
8113c140:	10c00005 	stb	r3,0(r2)
        return;
8113c144:	00000e06 	br	8113c180 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113c148:	e0bffd17 	ldw	r2,-12(fp)
8113c14c:	10800284 	addi	r2,r2,10
8113c150:	e17ffe17 	ldw	r5,-8(fp)
8113c154:	1009883a 	mov	r4,r2
8113c158:	113b0d80 	call	8113b0d8 <OS_StrCopy>
8113c15c:	e0bff717 	ldw	r2,-36(fp)
8113c160:	e0bffb15 	stw	r2,-20(fp)
8113c164:	e0bffb17 	ldw	r2,-20(fp)
8113c168:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c16c:	e0bfff17 	ldw	r2,-4(fp)
8113c170:	10000005 	stb	zero,0(r2)
    return;
8113c174:	0001883a 	nop
8113c178:	00000106 	br	8113c180 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113c17c:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113c180:	e037883a 	mov	sp,fp
8113c184:	dfc00117 	ldw	ra,4(sp)
8113c188:	df000017 	ldw	fp,0(sp)
8113c18c:	dec00204 	addi	sp,sp,8
8113c190:	f800283a 	ret

8113c194 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113c194:	deffe104 	addi	sp,sp,-124
8113c198:	de00012e 	bgeu	sp,et,8113c1a0 <OSFlagPend+0xc>
8113c19c:	003b68fa 	trap	3
8113c1a0:	dfc01e15 	stw	ra,120(sp)
8113c1a4:	df001d15 	stw	fp,116(sp)
8113c1a8:	df001d04 	addi	fp,sp,116
8113c1ac:	e13ffc15 	stw	r4,-16(fp)
8113c1b0:	2809883a 	mov	r4,r5
8113c1b4:	3007883a 	mov	r3,r6
8113c1b8:	3805883a 	mov	r2,r7
8113c1bc:	e13ffd0d 	sth	r4,-12(fp)
8113c1c0:	e0fffe05 	stb	r3,-8(fp)
8113c1c4:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c1c8:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c1cc:	e0800217 	ldw	r2,8(fp)
8113c1d0:	1000021e 	bne	r2,zero,8113c1dc <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113c1d4:	0005883a 	mov	r2,zero
8113c1d8:	00015906 	br	8113c740 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113c1dc:	e0bffc17 	ldw	r2,-16(fp)
8113c1e0:	1000051e 	bne	r2,zero,8113c1f8 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c1e4:	e0800217 	ldw	r2,8(fp)
8113c1e8:	00c01b84 	movi	r3,110
8113c1ec:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c1f0:	0005883a 	mov	r2,zero
8113c1f4:	00015206 	br	8113c740 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c1f8:	d0a0a103 	ldbu	r2,-32124(gp)
8113c1fc:	10803fcc 	andi	r2,r2,255
8113c200:	10000526 	beq	r2,zero,8113c218 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113c204:	e0800217 	ldw	r2,8(fp)
8113c208:	00c00084 	movi	r3,2
8113c20c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c210:	0005883a 	mov	r2,zero
8113c214:	00014a06 	br	8113c740 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113c218:	d0a08f03 	ldbu	r2,-32196(gp)
8113c21c:	10803fcc 	andi	r2,r2,255
8113c220:	10000526 	beq	r2,zero,8113c238 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113c224:	e0800217 	ldw	r2,8(fp)
8113c228:	00c00344 	movi	r3,13
8113c22c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c230:	0005883a 	mov	r2,zero
8113c234:	00014206 	br	8113c740 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113c238:	e0bffc17 	ldw	r2,-16(fp)
8113c23c:	10800003 	ldbu	r2,0(r2)
8113c240:	10803fcc 	andi	r2,r2,255
8113c244:	10800160 	cmpeqi	r2,r2,5
8113c248:	1000051e 	bne	r2,zero,8113c260 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113c24c:	e0800217 	ldw	r2,8(fp)
8113c250:	00c00044 	movi	r3,1
8113c254:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c258:	0005883a 	mov	r2,zero
8113c25c:	00013806 	br	8113c740 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113c260:	e0fffe03 	ldbu	r3,-8(fp)
8113c264:	00bfe004 	movi	r2,-128
8113c268:	1884703a 	and	r2,r3,r2
8113c26c:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113c270:	e0bfe603 	ldbu	r2,-104(fp)
8113c274:	10000626 	beq	r2,zero,8113c290 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113c278:	e0bffe03 	ldbu	r2,-8(fp)
8113c27c:	10801fcc 	andi	r2,r2,127
8113c280:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113c284:	00800044 	movi	r2,1
8113c288:	e0bfe405 	stb	r2,-112(fp)
8113c28c:	00000106 	br	8113c294 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113c290:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c294:	0005303a 	rdctl	r2,status
8113c298:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c29c:	e0fff617 	ldw	r3,-40(fp)
8113c2a0:	00bfff84 	movi	r2,-2
8113c2a4:	1884703a 	and	r2,r3,r2
8113c2a8:	1001703a 	wrctl	status,r2
  
  return context;
8113c2ac:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c2b0:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113c2b4:	e0bffe03 	ldbu	r2,-8(fp)
8113c2b8:	10c00060 	cmpeqi	r3,r2,1
8113c2bc:	1800921e 	bne	r3,zero,8113c508 <OSFlagPend+0x374>
8113c2c0:	10c00088 	cmpgei	r3,r2,2
8113c2c4:	1800021e 	bne	r3,zero,8113c2d0 <OSFlagPend+0x13c>
8113c2c8:	10006126 	beq	r2,zero,8113c450 <OSFlagPend+0x2bc>
8113c2cc:	0000bb06 	br	8113c5bc <OSFlagPend+0x428>
8113c2d0:	10c000a0 	cmpeqi	r3,r2,2
8113c2d4:	1800031e 	bne	r3,zero,8113c2e4 <OSFlagPend+0x150>
8113c2d8:	108000e0 	cmpeqi	r2,r2,3
8113c2dc:	10002f1e 	bne	r2,zero,8113c39c <OSFlagPend+0x208>
8113c2e0:	0000b606 	br	8113c5bc <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113c2e4:	e0bffc17 	ldw	r2,-16(fp)
8113c2e8:	10c0020b 	ldhu	r3,8(r2)
8113c2ec:	e0bffd0b 	ldhu	r2,-12(fp)
8113c2f0:	1884703a 	and	r2,r3,r2
8113c2f4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c2f8:	e0ffe80b 	ldhu	r3,-96(fp)
8113c2fc:	e0bffd0b 	ldhu	r2,-12(fp)
8113c300:	1880171e 	bne	r3,r2,8113c360 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c304:	e0bfe403 	ldbu	r2,-112(fp)
8113c308:	10800058 	cmpnei	r2,r2,1
8113c30c:	1000091e 	bne	r2,zero,8113c334 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113c310:	e0bffc17 	ldw	r2,-16(fp)
8113c314:	1080020b 	ldhu	r2,8(r2)
8113c318:	1007883a 	mov	r3,r2
8113c31c:	e0bfe80b 	ldhu	r2,-96(fp)
8113c320:	0084303a 	nor	r2,zero,r2
8113c324:	1884703a 	and	r2,r3,r2
8113c328:	1007883a 	mov	r3,r2
8113c32c:	e0bffc17 	ldw	r2,-16(fp)
8113c330:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c334:	d0a0a217 	ldw	r2,-32120(gp)
8113c338:	e0ffe80b 	ldhu	r3,-96(fp)
8113c33c:	10c00b0d 	sth	r3,44(r2)
8113c340:	e0bfe517 	ldw	r2,-108(fp)
8113c344:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c348:	e0bfe717 	ldw	r2,-100(fp)
8113c34c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c350:	e0800217 	ldw	r2,8(fp)
8113c354:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c358:	e0bfe80b 	ldhu	r2,-96(fp)
8113c35c:	0000f806 	br	8113c740 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c360:	e13ffd0b 	ldhu	r4,-12(fp)
8113c364:	e17ffe03 	ldbu	r5,-8(fp)
8113c368:	e0bfff0b 	ldhu	r2,-4(fp)
8113c36c:	e0fff704 	addi	r3,fp,-36
8113c370:	d8800015 	stw	r2,0(sp)
8113c374:	280f883a 	mov	r7,r5
8113c378:	200d883a 	mov	r6,r4
8113c37c:	180b883a 	mov	r5,r3
8113c380:	e13ffc17 	ldw	r4,-16(fp)
8113c384:	113cc240 	call	8113cc24 <OS_FlagBlock>
8113c388:	e0bfe517 	ldw	r2,-108(fp)
8113c38c:	e0bfe915 	stw	r2,-92(fp)
8113c390:	e0bfe917 	ldw	r2,-92(fp)
8113c394:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c398:	00009206 	br	8113c5e4 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113c39c:	e0bffc17 	ldw	r2,-16(fp)
8113c3a0:	10c0020b 	ldhu	r3,8(r2)
8113c3a4:	e0bffd0b 	ldhu	r2,-12(fp)
8113c3a8:	1884703a 	and	r2,r3,r2
8113c3ac:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113c3b0:	e0bfe80b 	ldhu	r2,-96(fp)
8113c3b4:	10001726 	beq	r2,zero,8113c414 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c3b8:	e0bfe403 	ldbu	r2,-112(fp)
8113c3bc:	10800058 	cmpnei	r2,r2,1
8113c3c0:	1000091e 	bne	r2,zero,8113c3e8 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113c3c4:	e0bffc17 	ldw	r2,-16(fp)
8113c3c8:	1080020b 	ldhu	r2,8(r2)
8113c3cc:	1007883a 	mov	r3,r2
8113c3d0:	e0bfe80b 	ldhu	r2,-96(fp)
8113c3d4:	0084303a 	nor	r2,zero,r2
8113c3d8:	1884703a 	and	r2,r3,r2
8113c3dc:	1007883a 	mov	r3,r2
8113c3e0:	e0bffc17 	ldw	r2,-16(fp)
8113c3e4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c3e8:	d0a0a217 	ldw	r2,-32120(gp)
8113c3ec:	e0ffe80b 	ldhu	r3,-96(fp)
8113c3f0:	10c00b0d 	sth	r3,44(r2)
8113c3f4:	e0bfe517 	ldw	r2,-108(fp)
8113c3f8:	e0bfea15 	stw	r2,-88(fp)
8113c3fc:	e0bfea17 	ldw	r2,-88(fp)
8113c400:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c404:	e0800217 	ldw	r2,8(fp)
8113c408:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c40c:	e0bfe80b 	ldhu	r2,-96(fp)
8113c410:	0000cb06 	br	8113c740 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c414:	e13ffd0b 	ldhu	r4,-12(fp)
8113c418:	e17ffe03 	ldbu	r5,-8(fp)
8113c41c:	e0bfff0b 	ldhu	r2,-4(fp)
8113c420:	e0fff704 	addi	r3,fp,-36
8113c424:	d8800015 	stw	r2,0(sp)
8113c428:	280f883a 	mov	r7,r5
8113c42c:	200d883a 	mov	r6,r4
8113c430:	180b883a 	mov	r5,r3
8113c434:	e13ffc17 	ldw	r4,-16(fp)
8113c438:	113cc240 	call	8113cc24 <OS_FlagBlock>
8113c43c:	e0bfe517 	ldw	r2,-108(fp)
8113c440:	e0bfeb15 	stw	r2,-84(fp)
8113c444:	e0bfeb17 	ldw	r2,-84(fp)
8113c448:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c44c:	00006506 	br	8113c5e4 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113c450:	e0bffc17 	ldw	r2,-16(fp)
8113c454:	1080020b 	ldhu	r2,8(r2)
8113c458:	0084303a 	nor	r2,zero,r2
8113c45c:	1007883a 	mov	r3,r2
8113c460:	e0bffd0b 	ldhu	r2,-12(fp)
8113c464:	1884703a 	and	r2,r3,r2
8113c468:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c46c:	e0ffe80b 	ldhu	r3,-96(fp)
8113c470:	e0bffd0b 	ldhu	r2,-12(fp)
8113c474:	1880151e 	bne	r3,r2,8113c4cc <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c478:	e0bfe403 	ldbu	r2,-112(fp)
8113c47c:	10800058 	cmpnei	r2,r2,1
8113c480:	1000071e 	bne	r2,zero,8113c4a0 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113c484:	e0bffc17 	ldw	r2,-16(fp)
8113c488:	10c0020b 	ldhu	r3,8(r2)
8113c48c:	e0bfe80b 	ldhu	r2,-96(fp)
8113c490:	1884b03a 	or	r2,r3,r2
8113c494:	1007883a 	mov	r3,r2
8113c498:	e0bffc17 	ldw	r2,-16(fp)
8113c49c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c4a0:	d0a0a217 	ldw	r2,-32120(gp)
8113c4a4:	e0ffe80b 	ldhu	r3,-96(fp)
8113c4a8:	10c00b0d 	sth	r3,44(r2)
8113c4ac:	e0bfe517 	ldw	r2,-108(fp)
8113c4b0:	e0bfec15 	stw	r2,-80(fp)
8113c4b4:	e0bfec17 	ldw	r2,-80(fp)
8113c4b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c4bc:	e0800217 	ldw	r2,8(fp)
8113c4c0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c4c4:	e0bfe80b 	ldhu	r2,-96(fp)
8113c4c8:	00009d06 	br	8113c740 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c4cc:	e13ffd0b 	ldhu	r4,-12(fp)
8113c4d0:	e17ffe03 	ldbu	r5,-8(fp)
8113c4d4:	e0bfff0b 	ldhu	r2,-4(fp)
8113c4d8:	e0fff704 	addi	r3,fp,-36
8113c4dc:	d8800015 	stw	r2,0(sp)
8113c4e0:	280f883a 	mov	r7,r5
8113c4e4:	200d883a 	mov	r6,r4
8113c4e8:	180b883a 	mov	r5,r3
8113c4ec:	e13ffc17 	ldw	r4,-16(fp)
8113c4f0:	113cc240 	call	8113cc24 <OS_FlagBlock>
8113c4f4:	e0bfe517 	ldw	r2,-108(fp)
8113c4f8:	e0bfed15 	stw	r2,-76(fp)
8113c4fc:	e0bfed17 	ldw	r2,-76(fp)
8113c500:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c504:	00003706 	br	8113c5e4 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113c508:	e0bffc17 	ldw	r2,-16(fp)
8113c50c:	1080020b 	ldhu	r2,8(r2)
8113c510:	0084303a 	nor	r2,zero,r2
8113c514:	1007883a 	mov	r3,r2
8113c518:	e0bffd0b 	ldhu	r2,-12(fp)
8113c51c:	1884703a 	and	r2,r3,r2
8113c520:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113c524:	e0bfe80b 	ldhu	r2,-96(fp)
8113c528:	10001526 	beq	r2,zero,8113c580 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c52c:	e0bfe403 	ldbu	r2,-112(fp)
8113c530:	10800058 	cmpnei	r2,r2,1
8113c534:	1000071e 	bne	r2,zero,8113c554 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113c538:	e0bffc17 	ldw	r2,-16(fp)
8113c53c:	10c0020b 	ldhu	r3,8(r2)
8113c540:	e0bfe80b 	ldhu	r2,-96(fp)
8113c544:	1884b03a 	or	r2,r3,r2
8113c548:	1007883a 	mov	r3,r2
8113c54c:	e0bffc17 	ldw	r2,-16(fp)
8113c550:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c554:	d0a0a217 	ldw	r2,-32120(gp)
8113c558:	e0ffe80b 	ldhu	r3,-96(fp)
8113c55c:	10c00b0d 	sth	r3,44(r2)
8113c560:	e0bfe517 	ldw	r2,-108(fp)
8113c564:	e0bfee15 	stw	r2,-72(fp)
8113c568:	e0bfee17 	ldw	r2,-72(fp)
8113c56c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c570:	e0800217 	ldw	r2,8(fp)
8113c574:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c578:	e0bfe80b 	ldhu	r2,-96(fp)
8113c57c:	00007006 	br	8113c740 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c580:	e13ffd0b 	ldhu	r4,-12(fp)
8113c584:	e17ffe03 	ldbu	r5,-8(fp)
8113c588:	e0bfff0b 	ldhu	r2,-4(fp)
8113c58c:	e0fff704 	addi	r3,fp,-36
8113c590:	d8800015 	stw	r2,0(sp)
8113c594:	280f883a 	mov	r7,r5
8113c598:	200d883a 	mov	r6,r4
8113c59c:	180b883a 	mov	r5,r3
8113c5a0:	e13ffc17 	ldw	r4,-16(fp)
8113c5a4:	113cc240 	call	8113cc24 <OS_FlagBlock>
8113c5a8:	e0bfe517 	ldw	r2,-108(fp)
8113c5ac:	e0bfef15 	stw	r2,-68(fp)
8113c5b0:	e0bfef17 	ldw	r2,-68(fp)
8113c5b4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c5b8:	00000a06 	br	8113c5e4 <OSFlagPend+0x450>
8113c5bc:	e0bfe517 	ldw	r2,-108(fp)
8113c5c0:	e0bff015 	stw	r2,-64(fp)
8113c5c4:	e0bff017 	ldw	r2,-64(fp)
8113c5c8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113c5cc:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113c5d0:	e0800217 	ldw	r2,8(fp)
8113c5d4:	00c01bc4 	movi	r3,111
8113c5d8:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113c5dc:	e0bfe80b 	ldhu	r2,-96(fp)
8113c5e0:	00005706 	br	8113c740 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113c5e4:	113af840 	call	8113af84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c5e8:	0005303a 	rdctl	r2,status
8113c5ec:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c5f0:	e0fff117 	ldw	r3,-60(fp)
8113c5f4:	00bfff84 	movi	r2,-2
8113c5f8:	1884703a 	and	r2,r3,r2
8113c5fc:	1001703a 	wrctl	status,r2
  
  return context;
8113c600:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113c604:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113c608:	d0a0a217 	ldw	r2,-32120(gp)
8113c60c:	10800c43 	ldbu	r2,49(r2)
8113c610:	10803fcc 	andi	r2,r2,255
8113c614:	10001c26 	beq	r2,zero,8113c688 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113c618:	d0a0a217 	ldw	r2,-32120(gp)
8113c61c:	10800c43 	ldbu	r2,49(r2)
8113c620:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113c624:	d0a0a217 	ldw	r2,-32120(gp)
8113c628:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113c62c:	e0bff704 	addi	r2,fp,-36
8113c630:	1009883a 	mov	r4,r2
8113c634:	113cf700 	call	8113cf70 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113c638:	d0a0a217 	ldw	r2,-32120(gp)
8113c63c:	10000c05 	stb	zero,48(r2)
8113c640:	e0bfe517 	ldw	r2,-108(fp)
8113c644:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c648:	e0bff217 	ldw	r2,-56(fp)
8113c64c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113c650:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113c654:	e0bff303 	ldbu	r2,-52(fp)
8113c658:	108000a0 	cmpeqi	r2,r2,2
8113c65c:	10000426 	beq	r2,zero,8113c670 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113c660:	e0800217 	ldw	r2,8(fp)
8113c664:	00c00384 	movi	r3,14
8113c668:	10c00005 	stb	r3,0(r2)
                 break;
8113c66c:	00000406 	br	8113c680 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113c670:	e0800217 	ldw	r2,8(fp)
8113c674:	00c00284 	movi	r3,10
8113c678:	10c00005 	stb	r3,0(r2)
                 break;
8113c67c:	0001883a 	nop
        }
        return (flags_rdy);
8113c680:	e0bfe80b 	ldhu	r2,-96(fp)
8113c684:	00002e06 	br	8113c740 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113c688:	d0a0a217 	ldw	r2,-32120(gp)
8113c68c:	10800b0b 	ldhu	r2,44(r2)
8113c690:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113c694:	e0bfe403 	ldbu	r2,-112(fp)
8113c698:	10800058 	cmpnei	r2,r2,1
8113c69c:	1000211e 	bne	r2,zero,8113c724 <OSFlagPend+0x590>
        switch (wait_type) {
8113c6a0:	e0bffe03 	ldbu	r2,-8(fp)
8113c6a4:	10001616 	blt	r2,zero,8113c700 <OSFlagPend+0x56c>
8113c6a8:	10c00090 	cmplti	r3,r2,2
8113c6ac:	18000c1e 	bne	r3,zero,8113c6e0 <OSFlagPend+0x54c>
8113c6b0:	10800108 	cmpgei	r2,r2,4
8113c6b4:	1000121e 	bne	r2,zero,8113c700 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113c6b8:	e0bffc17 	ldw	r2,-16(fp)
8113c6bc:	1080020b 	ldhu	r2,8(r2)
8113c6c0:	1007883a 	mov	r3,r2
8113c6c4:	e0bfe80b 	ldhu	r2,-96(fp)
8113c6c8:	0084303a 	nor	r2,zero,r2
8113c6cc:	1884703a 	and	r2,r3,r2
8113c6d0:	1007883a 	mov	r3,r2
8113c6d4:	e0bffc17 	ldw	r2,-16(fp)
8113c6d8:	10c0020d 	sth	r3,8(r2)
                 break;
8113c6dc:	00001106 	br	8113c724 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113c6e0:	e0bffc17 	ldw	r2,-16(fp)
8113c6e4:	10c0020b 	ldhu	r3,8(r2)
8113c6e8:	e0bfe80b 	ldhu	r2,-96(fp)
8113c6ec:	1884b03a 	or	r2,r3,r2
8113c6f0:	1007883a 	mov	r3,r2
8113c6f4:	e0bffc17 	ldw	r2,-16(fp)
8113c6f8:	10c0020d 	sth	r3,8(r2)
                 break;
8113c6fc:	00000906 	br	8113c724 <OSFlagPend+0x590>
8113c700:	e0bfe517 	ldw	r2,-108(fp)
8113c704:	e0bff415 	stw	r2,-48(fp)
8113c708:	e0bff417 	ldw	r2,-48(fp)
8113c70c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113c710:	e0800217 	ldw	r2,8(fp)
8113c714:	00c01bc4 	movi	r3,111
8113c718:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113c71c:	0005883a 	mov	r2,zero
8113c720:	00000706 	br	8113c740 <OSFlagPend+0x5ac>
8113c724:	e0bfe517 	ldw	r2,-108(fp)
8113c728:	e0bff515 	stw	r2,-44(fp)
8113c72c:	e0bff517 	ldw	r2,-44(fp)
8113c730:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113c734:	e0800217 	ldw	r2,8(fp)
8113c738:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113c73c:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113c740:	e037883a 	mov	sp,fp
8113c744:	dfc00117 	ldw	ra,4(sp)
8113c748:	df000017 	ldw	fp,0(sp)
8113c74c:	dec00204 	addi	sp,sp,8
8113c750:	f800283a 	ret

8113c754 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113c754:	defffb04 	addi	sp,sp,-20
8113c758:	de00012e 	bgeu	sp,et,8113c760 <OSFlagPendGetFlagsRdy+0xc>
8113c75c:	003b68fa 	trap	3
8113c760:	df000415 	stw	fp,16(sp)
8113c764:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c768:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c76c:	0005303a 	rdctl	r2,status
8113c770:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c774:	e0fffe17 	ldw	r3,-8(fp)
8113c778:	00bfff84 	movi	r2,-2
8113c77c:	1884703a 	and	r2,r3,r2
8113c780:	1001703a 	wrctl	status,r2
  
  return context;
8113c784:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113c788:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113c78c:	d0a0a217 	ldw	r2,-32120(gp)
8113c790:	10800b0b 	ldhu	r2,44(r2)
8113c794:	e0bffd0d 	sth	r2,-12(fp)
8113c798:	e0bffc17 	ldw	r2,-16(fp)
8113c79c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c7a0:	e0bfff17 	ldw	r2,-4(fp)
8113c7a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113c7a8:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113c7ac:	e037883a 	mov	sp,fp
8113c7b0:	df000017 	ldw	fp,0(sp)
8113c7b4:	dec00104 	addi	sp,sp,4
8113c7b8:	f800283a 	ret

8113c7bc <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113c7bc:	deffef04 	addi	sp,sp,-68
8113c7c0:	de00012e 	bgeu	sp,et,8113c7c8 <OSFlagPost+0xc>
8113c7c4:	003b68fa 	trap	3
8113c7c8:	dfc01015 	stw	ra,64(sp)
8113c7cc:	df000f15 	stw	fp,60(sp)
8113c7d0:	df000f04 	addi	fp,sp,60
8113c7d4:	e13ffc15 	stw	r4,-16(fp)
8113c7d8:	2807883a 	mov	r3,r5
8113c7dc:	3005883a 	mov	r2,r6
8113c7e0:	e1ffff15 	stw	r7,-4(fp)
8113c7e4:	e0fffd0d 	sth	r3,-12(fp)
8113c7e8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113c7ec:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113c7f0:	e0bfff17 	ldw	r2,-4(fp)
8113c7f4:	1000021e 	bne	r2,zero,8113c800 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113c7f8:	0005883a 	mov	r2,zero
8113c7fc:	0000d106 	br	8113cb44 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113c800:	e0bffc17 	ldw	r2,-16(fp)
8113c804:	1000051e 	bne	r2,zero,8113c81c <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c808:	e0bfff17 	ldw	r2,-4(fp)
8113c80c:	00c01b84 	movi	r3,110
8113c810:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c814:	0005883a 	mov	r2,zero
8113c818:	0000ca06 	br	8113cb44 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113c81c:	e0bffc17 	ldw	r2,-16(fp)
8113c820:	10800003 	ldbu	r2,0(r2)
8113c824:	10803fcc 	andi	r2,r2,255
8113c828:	10800160 	cmpeqi	r2,r2,5
8113c82c:	1000051e 	bne	r2,zero,8113c844 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113c830:	e0bfff17 	ldw	r2,-4(fp)
8113c834:	00c00044 	movi	r3,1
8113c838:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c83c:	0005883a 	mov	r2,zero
8113c840:	0000c006 	br	8113cb44 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c844:	0005303a 	rdctl	r2,status
8113c848:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c84c:	e0fffb17 	ldw	r3,-20(fp)
8113c850:	00bfff84 	movi	r2,-2
8113c854:	1884703a 	and	r2,r3,r2
8113c858:	1001703a 	wrctl	status,r2
  
  return context;
8113c85c:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c860:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113c864:	e0bffe03 	ldbu	r2,-8(fp)
8113c868:	10000326 	beq	r2,zero,8113c878 <OSFlagPost+0xbc>
8113c86c:	10800060 	cmpeqi	r2,r2,1
8113c870:	10000b1e 	bne	r2,zero,8113c8a0 <OSFlagPost+0xe4>
8113c874:	00001206 	br	8113c8c0 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113c878:	e0bffc17 	ldw	r2,-16(fp)
8113c87c:	1080020b 	ldhu	r2,8(r2)
8113c880:	1007883a 	mov	r3,r2
8113c884:	e0bffd0b 	ldhu	r2,-12(fp)
8113c888:	0084303a 	nor	r2,zero,r2
8113c88c:	1884703a 	and	r2,r3,r2
8113c890:	1007883a 	mov	r3,r2
8113c894:	e0bffc17 	ldw	r2,-16(fp)
8113c898:	10c0020d 	sth	r3,8(r2)
             break;
8113c89c:	00001106 	br	8113c8e4 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113c8a0:	e0bffc17 	ldw	r2,-16(fp)
8113c8a4:	10c0020b 	ldhu	r3,8(r2)
8113c8a8:	e0bffd0b 	ldhu	r2,-12(fp)
8113c8ac:	1884b03a 	or	r2,r3,r2
8113c8b0:	1007883a 	mov	r3,r2
8113c8b4:	e0bffc17 	ldw	r2,-16(fp)
8113c8b8:	10c0020d 	sth	r3,8(r2)
             break;
8113c8bc:	00000906 	br	8113c8e4 <OSFlagPost+0x128>
8113c8c0:	e0bff317 	ldw	r2,-52(fp)
8113c8c4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c8c8:	e0bff417 	ldw	r2,-48(fp)
8113c8cc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113c8d0:	e0bfff17 	ldw	r2,-4(fp)
8113c8d4:	00c01c44 	movi	r3,113
8113c8d8:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113c8dc:	0005883a 	mov	r2,zero
8113c8e0:	00009806 	br	8113cb44 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113c8e4:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113c8e8:	e0bffc17 	ldw	r2,-16(fp)
8113c8ec:	10800117 	ldw	r2,4(r2)
8113c8f0:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113c8f4:	00007706 	br	8113cad4 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113c8f8:	e0bff117 	ldw	r2,-60(fp)
8113c8fc:	10800483 	ldbu	r2,18(r2)
8113c900:	10803fcc 	andi	r2,r2,255
8113c904:	10c00060 	cmpeqi	r3,r2,1
8113c908:	18004a1e 	bne	r3,zero,8113ca34 <OSFlagPost+0x278>
8113c90c:	10c00088 	cmpgei	r3,r2,2
8113c910:	1800021e 	bne	r3,zero,8113c91c <OSFlagPost+0x160>
8113c914:	10002f26 	beq	r2,zero,8113c9d4 <OSFlagPost+0x218>
8113c918:	00005b06 	br	8113ca88 <OSFlagPost+0x2cc>
8113c91c:	10c000a0 	cmpeqi	r3,r2,2
8113c920:	1800031e 	bne	r3,zero,8113c930 <OSFlagPost+0x174>
8113c924:	108000e0 	cmpeqi	r2,r2,3
8113c928:	1000171e 	bne	r2,zero,8113c988 <OSFlagPost+0x1cc>
8113c92c:	00005606 	br	8113ca88 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c930:	e0bffc17 	ldw	r2,-16(fp)
8113c934:	10c0020b 	ldhu	r3,8(r2)
8113c938:	e0bff117 	ldw	r2,-60(fp)
8113c93c:	1080040b 	ldhu	r2,16(r2)
8113c940:	1884703a 	and	r2,r3,r2
8113c944:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113c948:	e0bff117 	ldw	r2,-60(fp)
8113c94c:	1080040b 	ldhu	r2,16(r2)
8113c950:	10ffffcc 	andi	r3,r2,65535
8113c954:	e0bff60b 	ldhu	r2,-40(fp)
8113c958:	1880541e 	bne	r3,r2,8113caac <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113c95c:	e0bff60b 	ldhu	r2,-40(fp)
8113c960:	100b883a 	mov	r5,r2
8113c964:	e13ff117 	ldw	r4,-60(fp)
8113c968:	113ce740 	call	8113ce74 <OS_FlagTaskRdy>
8113c96c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113c970:	e0bff683 	ldbu	r2,-38(fp)
8113c974:	10800058 	cmpnei	r2,r2,1
8113c978:	10004c1e 	bne	r2,zero,8113caac <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113c97c:	00800044 	movi	r2,1
8113c980:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113c984:	00004906 	br	8113caac <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c988:	e0bffc17 	ldw	r2,-16(fp)
8113c98c:	10c0020b 	ldhu	r3,8(r2)
8113c990:	e0bff117 	ldw	r2,-60(fp)
8113c994:	1080040b 	ldhu	r2,16(r2)
8113c998:	1884703a 	and	r2,r3,r2
8113c99c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113c9a0:	e0bff60b 	ldhu	r2,-40(fp)
8113c9a4:	10004326 	beq	r2,zero,8113cab4 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113c9a8:	e0bff60b 	ldhu	r2,-40(fp)
8113c9ac:	100b883a 	mov	r5,r2
8113c9b0:	e13ff117 	ldw	r4,-60(fp)
8113c9b4:	113ce740 	call	8113ce74 <OS_FlagTaskRdy>
8113c9b8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113c9bc:	e0bff683 	ldbu	r2,-38(fp)
8113c9c0:	10800058 	cmpnei	r2,r2,1
8113c9c4:	10003b1e 	bne	r2,zero,8113cab4 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113c9c8:	00800044 	movi	r2,1
8113c9cc:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113c9d0:	00003806 	br	8113cab4 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c9d4:	e0bffc17 	ldw	r2,-16(fp)
8113c9d8:	1080020b 	ldhu	r2,8(r2)
8113c9dc:	0084303a 	nor	r2,zero,r2
8113c9e0:	1007883a 	mov	r3,r2
8113c9e4:	e0bff117 	ldw	r2,-60(fp)
8113c9e8:	1080040b 	ldhu	r2,16(r2)
8113c9ec:	1884703a 	and	r2,r3,r2
8113c9f0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113c9f4:	e0bff117 	ldw	r2,-60(fp)
8113c9f8:	1080040b 	ldhu	r2,16(r2)
8113c9fc:	10ffffcc 	andi	r3,r2,65535
8113ca00:	e0bff60b 	ldhu	r2,-40(fp)
8113ca04:	18802d1e 	bne	r3,r2,8113cabc <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113ca08:	e0bff60b 	ldhu	r2,-40(fp)
8113ca0c:	100b883a 	mov	r5,r2
8113ca10:	e13ff117 	ldw	r4,-60(fp)
8113ca14:	113ce740 	call	8113ce74 <OS_FlagTaskRdy>
8113ca18:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113ca1c:	e0bff683 	ldbu	r2,-38(fp)
8113ca20:	10800058 	cmpnei	r2,r2,1
8113ca24:	1000251e 	bne	r2,zero,8113cabc <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113ca28:	00800044 	movi	r2,1
8113ca2c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113ca30:	00002206 	br	8113cabc <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113ca34:	e0bffc17 	ldw	r2,-16(fp)
8113ca38:	1080020b 	ldhu	r2,8(r2)
8113ca3c:	0084303a 	nor	r2,zero,r2
8113ca40:	1007883a 	mov	r3,r2
8113ca44:	e0bff117 	ldw	r2,-60(fp)
8113ca48:	1080040b 	ldhu	r2,16(r2)
8113ca4c:	1884703a 	and	r2,r3,r2
8113ca50:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113ca54:	e0bff60b 	ldhu	r2,-40(fp)
8113ca58:	10001a26 	beq	r2,zero,8113cac4 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113ca5c:	e0bff60b 	ldhu	r2,-40(fp)
8113ca60:	100b883a 	mov	r5,r2
8113ca64:	e13ff117 	ldw	r4,-60(fp)
8113ca68:	113ce740 	call	8113ce74 <OS_FlagTaskRdy>
8113ca6c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113ca70:	e0bff683 	ldbu	r2,-38(fp)
8113ca74:	10800058 	cmpnei	r2,r2,1
8113ca78:	1000121e 	bne	r2,zero,8113cac4 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113ca7c:	00800044 	movi	r2,1
8113ca80:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113ca84:	00000f06 	br	8113cac4 <OSFlagPost+0x308>
8113ca88:	e0bff317 	ldw	r2,-52(fp)
8113ca8c:	e0bff515 	stw	r2,-44(fp)
8113ca90:	e0bff517 	ldw	r2,-44(fp)
8113ca94:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113ca98:	e0bfff17 	ldw	r2,-4(fp)
8113ca9c:	00c01bc4 	movi	r3,111
8113caa0:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113caa4:	0005883a 	mov	r2,zero
8113caa8:	00002606 	br	8113cb44 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113caac:	0001883a 	nop
8113cab0:	00000506 	br	8113cac8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113cab4:	0001883a 	nop
8113cab8:	00000306 	br	8113cac8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113cabc:	0001883a 	nop
8113cac0:	00000106 	br	8113cac8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113cac4:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113cac8:	e0bff117 	ldw	r2,-60(fp)
8113cacc:	10800017 	ldw	r2,0(r2)
8113cad0:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113cad4:	e0bff117 	ldw	r2,-60(fp)
8113cad8:	103f871e 	bne	r2,zero,8113c8f8 <__reset+0xfb11c8f8>
8113cadc:	e0bff317 	ldw	r2,-52(fp)
8113cae0:	e0bff715 	stw	r2,-36(fp)
8113cae4:	e0bff717 	ldw	r2,-36(fp)
8113cae8:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113caec:	e0bff203 	ldbu	r2,-56(fp)
8113caf0:	10800058 	cmpnei	r2,r2,1
8113caf4:	1000011e 	bne	r2,zero,8113cafc <OSFlagPost+0x340>
        OS_Sched();
8113caf8:	113af840 	call	8113af84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cafc:	0005303a 	rdctl	r2,status
8113cb00:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cb04:	e0fffa17 	ldw	r3,-24(fp)
8113cb08:	00bfff84 	movi	r2,-2
8113cb0c:	1884703a 	and	r2,r3,r2
8113cb10:	1001703a 	wrctl	status,r2
  
  return context;
8113cb14:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113cb18:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113cb1c:	e0bffc17 	ldw	r2,-16(fp)
8113cb20:	1080020b 	ldhu	r2,8(r2)
8113cb24:	e0bff90d 	sth	r2,-28(fp)
8113cb28:	e0bff317 	ldw	r2,-52(fp)
8113cb2c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cb30:	e0bff817 	ldw	r2,-32(fp)
8113cb34:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113cb38:	e0bfff17 	ldw	r2,-4(fp)
8113cb3c:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113cb40:	e0bff90b 	ldhu	r2,-28(fp)
}
8113cb44:	e037883a 	mov	sp,fp
8113cb48:	dfc00117 	ldw	ra,4(sp)
8113cb4c:	df000017 	ldw	fp,0(sp)
8113cb50:	dec00204 	addi	sp,sp,8
8113cb54:	f800283a 	ret

8113cb58 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113cb58:	defff904 	addi	sp,sp,-28
8113cb5c:	de00012e 	bgeu	sp,et,8113cb64 <OSFlagQuery+0xc>
8113cb60:	003b68fa 	trap	3
8113cb64:	df000615 	stw	fp,24(sp)
8113cb68:	df000604 	addi	fp,sp,24
8113cb6c:	e13ffe15 	stw	r4,-8(fp)
8113cb70:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113cb74:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113cb78:	e0bfff17 	ldw	r2,-4(fp)
8113cb7c:	1000021e 	bne	r2,zero,8113cb88 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113cb80:	0005883a 	mov	r2,zero
8113cb84:	00002306 	br	8113cc14 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113cb88:	e0bffe17 	ldw	r2,-8(fp)
8113cb8c:	1000051e 	bne	r2,zero,8113cba4 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113cb90:	e0bfff17 	ldw	r2,-4(fp)
8113cb94:	00c01b84 	movi	r3,110
8113cb98:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb9c:	0005883a 	mov	r2,zero
8113cba0:	00001c06 	br	8113cc14 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113cba4:	e0bffe17 	ldw	r2,-8(fp)
8113cba8:	10800003 	ldbu	r2,0(r2)
8113cbac:	10803fcc 	andi	r2,r2,255
8113cbb0:	10800160 	cmpeqi	r2,r2,5
8113cbb4:	1000051e 	bne	r2,zero,8113cbcc <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113cbb8:	e0bfff17 	ldw	r2,-4(fp)
8113cbbc:	00c00044 	movi	r3,1
8113cbc0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cbc4:	0005883a 	mov	r2,zero
8113cbc8:	00001206 	br	8113cc14 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cbcc:	0005303a 	rdctl	r2,status
8113cbd0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cbd4:	e0fffc17 	ldw	r3,-16(fp)
8113cbd8:	00bfff84 	movi	r2,-2
8113cbdc:	1884703a 	and	r2,r3,r2
8113cbe0:	1001703a 	wrctl	status,r2
  
  return context;
8113cbe4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cbe8:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113cbec:	e0bffe17 	ldw	r2,-8(fp)
8113cbf0:	1080020b 	ldhu	r2,8(r2)
8113cbf4:	e0bffb0d 	sth	r2,-20(fp)
8113cbf8:	e0bffa17 	ldw	r2,-24(fp)
8113cbfc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cc00:	e0bffd17 	ldw	r2,-12(fp)
8113cc04:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113cc08:	e0bfff17 	ldw	r2,-4(fp)
8113cc0c:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113cc10:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113cc14:	e037883a 	mov	sp,fp
8113cc18:	df000017 	ldw	fp,0(sp)
8113cc1c:	dec00104 	addi	sp,sp,4
8113cc20:	f800283a 	ret

8113cc24 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113cc24:	defff804 	addi	sp,sp,-32
8113cc28:	de00012e 	bgeu	sp,et,8113cc30 <OS_FlagBlock+0xc>
8113cc2c:	003b68fa 	trap	3
8113cc30:	df000715 	stw	fp,28(sp)
8113cc34:	df000704 	addi	fp,sp,28
8113cc38:	e13ffb15 	stw	r4,-20(fp)
8113cc3c:	e17ffc15 	stw	r5,-16(fp)
8113cc40:	3009883a 	mov	r4,r6
8113cc44:	3807883a 	mov	r3,r7
8113cc48:	e0800117 	ldw	r2,4(fp)
8113cc4c:	e13ffd0d 	sth	r4,-12(fp)
8113cc50:	e0fffe05 	stb	r3,-8(fp)
8113cc54:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113cc58:	d0a0a217 	ldw	r2,-32120(gp)
8113cc5c:	d0e0a217 	ldw	r3,-32120(gp)
8113cc60:	18c00c03 	ldbu	r3,48(r3)
8113cc64:	18c00814 	ori	r3,r3,32
8113cc68:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113cc6c:	d0a0a217 	ldw	r2,-32120(gp)
8113cc70:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113cc74:	d0a0a217 	ldw	r2,-32120(gp)
8113cc78:	e0ffff0b 	ldhu	r3,-4(fp)
8113cc7c:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113cc80:	d0a0a217 	ldw	r2,-32120(gp)
8113cc84:	e0fffc17 	ldw	r3,-16(fp)
8113cc88:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113cc8c:	e0bffc17 	ldw	r2,-16(fp)
8113cc90:	e0fffd0b 	ldhu	r3,-12(fp)
8113cc94:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113cc98:	e0bffc17 	ldw	r2,-16(fp)
8113cc9c:	e0fffe03 	ldbu	r3,-8(fp)
8113cca0:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113cca4:	d0e0a217 	ldw	r3,-32120(gp)
8113cca8:	e0bffc17 	ldw	r2,-16(fp)
8113ccac:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113ccb0:	e0bffb17 	ldw	r2,-20(fp)
8113ccb4:	10c00117 	ldw	r3,4(r2)
8113ccb8:	e0bffc17 	ldw	r2,-16(fp)
8113ccbc:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113ccc0:	e0bffc17 	ldw	r2,-16(fp)
8113ccc4:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113ccc8:	e0bffc17 	ldw	r2,-16(fp)
8113cccc:	e0fffb17 	ldw	r3,-20(fp)
8113ccd0:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113ccd4:	e0bffb17 	ldw	r2,-20(fp)
8113ccd8:	10800117 	ldw	r2,4(r2)
8113ccdc:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113cce0:	e0bff917 	ldw	r2,-28(fp)
8113cce4:	10000326 	beq	r2,zero,8113ccf4 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113cce8:	e0bff917 	ldw	r2,-28(fp)
8113ccec:	e0fffc17 	ldw	r3,-16(fp)
8113ccf0:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113ccf4:	e0bffb17 	ldw	r2,-20(fp)
8113ccf8:	e0fffc17 	ldw	r3,-16(fp)
8113ccfc:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113cd00:	d0a0a217 	ldw	r2,-32120(gp)
8113cd04:	10800d03 	ldbu	r2,52(r2)
8113cd08:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113cd0c:	e0fffa03 	ldbu	r3,-24(fp)
8113cd10:	e13ffa03 	ldbu	r4,-24(fp)
8113cd14:	d0a09e44 	addi	r2,gp,-32135
8113cd18:	2085883a 	add	r2,r4,r2
8113cd1c:	10800003 	ldbu	r2,0(r2)
8113cd20:	1009883a 	mov	r4,r2
8113cd24:	d0a0a217 	ldw	r2,-32120(gp)
8113cd28:	10800d43 	ldbu	r2,53(r2)
8113cd2c:	0084303a 	nor	r2,zero,r2
8113cd30:	2084703a 	and	r2,r4,r2
8113cd34:	1009883a 	mov	r4,r2
8113cd38:	d0a09e44 	addi	r2,gp,-32135
8113cd3c:	1885883a 	add	r2,r3,r2
8113cd40:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113cd44:	e0fffa03 	ldbu	r3,-24(fp)
8113cd48:	d0a09e44 	addi	r2,gp,-32135
8113cd4c:	1885883a 	add	r2,r3,r2
8113cd50:	10800003 	ldbu	r2,0(r2)
8113cd54:	10803fcc 	andi	r2,r2,255
8113cd58:	1000071e 	bne	r2,zero,8113cd78 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113cd5c:	d0a0a217 	ldw	r2,-32120(gp)
8113cd60:	10800d83 	ldbu	r2,54(r2)
8113cd64:	0084303a 	nor	r2,zero,r2
8113cd68:	1007883a 	mov	r3,r2
8113cd6c:	d0a09e03 	ldbu	r2,-32136(gp)
8113cd70:	1884703a 	and	r2,r3,r2
8113cd74:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113cd78:	0001883a 	nop
8113cd7c:	e037883a 	mov	sp,fp
8113cd80:	df000017 	ldw	fp,0(sp)
8113cd84:	dec00104 	addi	sp,sp,4
8113cd88:	f800283a 	ret

8113cd8c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113cd8c:	defffb04 	addi	sp,sp,-20
8113cd90:	de00012e 	bgeu	sp,et,8113cd98 <OS_FlagInit+0xc>
8113cd94:	003b68fa 	trap	3
8113cd98:	dfc00415 	stw	ra,16(sp)
8113cd9c:	df000315 	stw	fp,12(sp)
8113cda0:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113cda4:	01421004 	movi	r5,2112
8113cda8:	012045f4 	movhi	r4,33047
8113cdac:	21202a04 	addi	r4,r4,-32600
8113cdb0:	113aeb80 	call	8113aeb8 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113cdb4:	00a045f4 	movhi	r2,33047
8113cdb8:	10a02a04 	addi	r2,r2,-32600
8113cdbc:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113cdc0:	00a045f4 	movhi	r2,33047
8113cdc4:	10a03504 	addi	r2,r2,-32556
8113cdc8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113cdcc:	e03ffd0d 	sth	zero,-12(fp)
8113cdd0:	00001306 	br	8113ce20 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113cdd4:	e0bffe17 	ldw	r2,-8(fp)
8113cdd8:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113cddc:	e0bffe17 	ldw	r2,-8(fp)
8113cde0:	e0ffff17 	ldw	r3,-4(fp)
8113cde4:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113cde8:	e0bffe17 	ldw	r2,-8(fp)
8113cdec:	00c00fc4 	movi	r3,63
8113cdf0:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113cdf4:	e0bffe17 	ldw	r2,-8(fp)
8113cdf8:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113cdfc:	e0bffe17 	ldw	r2,-8(fp)
8113ce00:	10800b04 	addi	r2,r2,44
8113ce04:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113ce08:	e0bfff17 	ldw	r2,-4(fp)
8113ce0c:	10800b04 	addi	r2,r2,44
8113ce10:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113ce14:	e0bffd0b 	ldhu	r2,-12(fp)
8113ce18:	10800044 	addi	r2,r2,1
8113ce1c:	e0bffd0d 	sth	r2,-12(fp)
8113ce20:	e0bffd0b 	ldhu	r2,-12(fp)
8113ce24:	10800bf0 	cmpltui	r2,r2,47
8113ce28:	103fea1e 	bne	r2,zero,8113cdd4 <__reset+0xfb11cdd4>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113ce2c:	e0bffe17 	ldw	r2,-8(fp)
8113ce30:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113ce34:	e0bffe17 	ldw	r2,-8(fp)
8113ce38:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113ce3c:	e0bffe17 	ldw	r2,-8(fp)
8113ce40:	00c00fc4 	movi	r3,63
8113ce44:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113ce48:	e0bffe17 	ldw	r2,-8(fp)
8113ce4c:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113ce50:	00a045f4 	movhi	r2,33047
8113ce54:	10a02a04 	addi	r2,r2,-32600
8113ce58:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113ce5c:	0001883a 	nop
8113ce60:	e037883a 	mov	sp,fp
8113ce64:	dfc00117 	ldw	ra,4(sp)
8113ce68:	df000017 	ldw	fp,0(sp)
8113ce6c:	dec00204 	addi	sp,sp,8
8113ce70:	f800283a 	ret

8113ce74 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113ce74:	defffa04 	addi	sp,sp,-24
8113ce78:	de00012e 	bgeu	sp,et,8113ce80 <OS_FlagTaskRdy+0xc>
8113ce7c:	003b68fa 	trap	3
8113ce80:	dfc00515 	stw	ra,20(sp)
8113ce84:	df000415 	stw	fp,16(sp)
8113ce88:	df000404 	addi	fp,sp,16
8113ce8c:	e13ffe15 	stw	r4,-8(fp)
8113ce90:	2805883a 	mov	r2,r5
8113ce94:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113ce98:	e0bffe17 	ldw	r2,-8(fp)
8113ce9c:	10800217 	ldw	r2,8(r2)
8113cea0:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113cea4:	e0bffd17 	ldw	r2,-12(fp)
8113cea8:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113ceac:	e0bffd17 	ldw	r2,-12(fp)
8113ceb0:	e0ffff0b 	ldhu	r3,-4(fp)
8113ceb4:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113ceb8:	e0bffd17 	ldw	r2,-12(fp)
8113cebc:	10c00c03 	ldbu	r3,48(r2)
8113cec0:	00bff7c4 	movi	r2,-33
8113cec4:	1884703a 	and	r2,r3,r2
8113cec8:	1007883a 	mov	r3,r2
8113cecc:	e0bffd17 	ldw	r2,-12(fp)
8113ced0:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ced4:	e0bffd17 	ldw	r2,-12(fp)
8113ced8:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113cedc:	e0bffd17 	ldw	r2,-12(fp)
8113cee0:	10800c03 	ldbu	r2,48(r2)
8113cee4:	10803fcc 	andi	r2,r2,255
8113cee8:	1000181e 	bne	r2,zero,8113cf4c <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113ceec:	e0bffd17 	ldw	r2,-12(fp)
8113cef0:	10c00d83 	ldbu	r3,54(r2)
8113cef4:	d0a09e03 	ldbu	r2,-32136(gp)
8113cef8:	1884b03a 	or	r2,r3,r2
8113cefc:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cf00:	e0bffd17 	ldw	r2,-12(fp)
8113cf04:	10800d03 	ldbu	r2,52(r2)
8113cf08:	10c03fcc 	andi	r3,r2,255
8113cf0c:	e0bffd17 	ldw	r2,-12(fp)
8113cf10:	10800d03 	ldbu	r2,52(r2)
8113cf14:	11003fcc 	andi	r4,r2,255
8113cf18:	d0a09e44 	addi	r2,gp,-32135
8113cf1c:	2085883a 	add	r2,r4,r2
8113cf20:	11000003 	ldbu	r4,0(r2)
8113cf24:	e0bffd17 	ldw	r2,-12(fp)
8113cf28:	10800d43 	ldbu	r2,53(r2)
8113cf2c:	2084b03a 	or	r2,r4,r2
8113cf30:	1009883a 	mov	r4,r2
8113cf34:	d0a09e44 	addi	r2,gp,-32135
8113cf38:	1885883a 	add	r2,r3,r2
8113cf3c:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113cf40:	00800044 	movi	r2,1
8113cf44:	e0bffc05 	stb	r2,-16(fp)
8113cf48:	00000106 	br	8113cf50 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113cf4c:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113cf50:	e13ffe17 	ldw	r4,-8(fp)
8113cf54:	113cf700 	call	8113cf70 <OS_FlagUnlink>
    return (sched);
8113cf58:	e0bffc03 	ldbu	r2,-16(fp)
}
8113cf5c:	e037883a 	mov	sp,fp
8113cf60:	dfc00117 	ldw	ra,4(sp)
8113cf64:	df000017 	ldw	fp,0(sp)
8113cf68:	dec00204 	addi	sp,sp,8
8113cf6c:	f800283a 	ret

8113cf70 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113cf70:	defffa04 	addi	sp,sp,-24
8113cf74:	de00012e 	bgeu	sp,et,8113cf7c <OS_FlagUnlink+0xc>
8113cf78:	003b68fa 	trap	3
8113cf7c:	df000515 	stw	fp,20(sp)
8113cf80:	df000504 	addi	fp,sp,20
8113cf84:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113cf88:	e0bfff17 	ldw	r2,-4(fp)
8113cf8c:	10800117 	ldw	r2,4(r2)
8113cf90:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113cf94:	e0bfff17 	ldw	r2,-4(fp)
8113cf98:	10800017 	ldw	r2,0(r2)
8113cf9c:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113cfa0:	e0bffb17 	ldw	r2,-20(fp)
8113cfa4:	10000b1e 	bne	r2,zero,8113cfd4 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113cfa8:	e0bfff17 	ldw	r2,-4(fp)
8113cfac:	10800317 	ldw	r2,12(r2)
8113cfb0:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113cfb4:	e0bffd17 	ldw	r2,-12(fp)
8113cfb8:	e0fffc17 	ldw	r3,-16(fp)
8113cfbc:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113cfc0:	e0bffc17 	ldw	r2,-16(fp)
8113cfc4:	10000b26 	beq	r2,zero,8113cff4 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113cfc8:	e0bffc17 	ldw	r2,-16(fp)
8113cfcc:	10000115 	stw	zero,4(r2)
8113cfd0:	00000806 	br	8113cff4 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113cfd4:	e0bffb17 	ldw	r2,-20(fp)
8113cfd8:	e0fffc17 	ldw	r3,-16(fp)
8113cfdc:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113cfe0:	e0bffc17 	ldw	r2,-16(fp)
8113cfe4:	10000326 	beq	r2,zero,8113cff4 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113cfe8:	e0bffc17 	ldw	r2,-16(fp)
8113cfec:	e0fffb17 	ldw	r3,-20(fp)
8113cff0:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113cff4:	e0bfff17 	ldw	r2,-4(fp)
8113cff8:	10800217 	ldw	r2,8(r2)
8113cffc:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113d000:	e0bffe17 	ldw	r2,-8(fp)
8113d004:	10000a15 	stw	zero,40(r2)
#endif
}
8113d008:	0001883a 	nop
8113d00c:	e037883a 	mov	sp,fp
8113d010:	df000017 	ldw	fp,0(sp)
8113d014:	dec00104 	addi	sp,sp,4
8113d018:	f800283a 	ret

8113d01c <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113d01c:	defff404 	addi	sp,sp,-48
8113d020:	de00012e 	bgeu	sp,et,8113d028 <OSMemCreate+0xc>
8113d024:	003b68fa 	trap	3
8113d028:	df000b15 	stw	fp,44(sp)
8113d02c:	df000b04 	addi	fp,sp,44
8113d030:	e13ffc15 	stw	r4,-16(fp)
8113d034:	e17ffd15 	stw	r5,-12(fp)
8113d038:	e1bffe15 	stw	r6,-8(fp)
8113d03c:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d040:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113d044:	e0bfff17 	ldw	r2,-4(fp)
8113d048:	1000021e 	bne	r2,zero,8113d054 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113d04c:	0005883a 	mov	r2,zero
8113d050:	00006506 	br	8113d1e8 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113d054:	e0bffc17 	ldw	r2,-16(fp)
8113d058:	1000051e 	bne	r2,zero,8113d070 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113d05c:	e0bfff17 	ldw	r2,-4(fp)
8113d060:	00c01884 	movi	r3,98
8113d064:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d068:	0005883a 	mov	r2,zero
8113d06c:	00005e06 	br	8113d1e8 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113d070:	e0bffc17 	ldw	r2,-16(fp)
8113d074:	108000cc 	andi	r2,r2,3
8113d078:	10000526 	beq	r2,zero,8113d090 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113d07c:	e0bfff17 	ldw	r2,-4(fp)
8113d080:	00c01884 	movi	r3,98
8113d084:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d088:	0005883a 	mov	r2,zero
8113d08c:	00005606 	br	8113d1e8 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113d090:	e0bffd17 	ldw	r2,-12(fp)
8113d094:	108000a8 	cmpgeui	r2,r2,2
8113d098:	1000051e 	bne	r2,zero,8113d0b0 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113d09c:	e0bfff17 	ldw	r2,-4(fp)
8113d0a0:	00c016c4 	movi	r3,91
8113d0a4:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d0a8:	0005883a 	mov	r2,zero
8113d0ac:	00004e06 	br	8113d1e8 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113d0b0:	e0bffe17 	ldw	r2,-8(fp)
8113d0b4:	10800128 	cmpgeui	r2,r2,4
8113d0b8:	1000051e 	bne	r2,zero,8113d0d0 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113d0bc:	e0bfff17 	ldw	r2,-4(fp)
8113d0c0:	00c01704 	movi	r3,92
8113d0c4:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d0c8:	0005883a 	mov	r2,zero
8113d0cc:	00004606 	br	8113d1e8 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d0d0:	0005303a 	rdctl	r2,status
8113d0d4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d0d8:	e0fffb17 	ldw	r3,-20(fp)
8113d0dc:	00bfff84 	movi	r2,-2
8113d0e0:	1884703a 	and	r2,r3,r2
8113d0e4:	1001703a 	wrctl	status,r2
  
  return context;
8113d0e8:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d0ec:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113d0f0:	d0a09b17 	ldw	r2,-32148(gp)
8113d0f4:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113d0f8:	d0a09b17 	ldw	r2,-32148(gp)
8113d0fc:	10000326 	beq	r2,zero,8113d10c <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113d100:	d0a09b17 	ldw	r2,-32148(gp)
8113d104:	10800117 	ldw	r2,4(r2)
8113d108:	d0a09b15 	stw	r2,-32148(gp)
8113d10c:	e0bff817 	ldw	r2,-32(fp)
8113d110:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d114:	e0bff917 	ldw	r2,-28(fp)
8113d118:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113d11c:	e0bffa17 	ldw	r2,-24(fp)
8113d120:	1000051e 	bne	r2,zero,8113d138 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113d124:	e0bfff17 	ldw	r2,-4(fp)
8113d128:	00c01684 	movi	r3,90
8113d12c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d130:	0005883a 	mov	r2,zero
8113d134:	00002c06 	br	8113d1e8 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113d138:	e0bffc17 	ldw	r2,-16(fp)
8113d13c:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113d140:	e0fffc17 	ldw	r3,-16(fp)
8113d144:	e0bffe17 	ldw	r2,-8(fp)
8113d148:	1885883a 	add	r2,r3,r2
8113d14c:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113d150:	e03ff715 	stw	zero,-36(fp)
8113d154:	00000c06 	br	8113d188 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113d158:	e0bff617 	ldw	r2,-40(fp)
8113d15c:	e0fff517 	ldw	r3,-44(fp)
8113d160:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113d164:	e0bff517 	ldw	r2,-44(fp)
8113d168:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113d16c:	e0fff517 	ldw	r3,-44(fp)
8113d170:	e0bffe17 	ldw	r2,-8(fp)
8113d174:	1885883a 	add	r2,r3,r2
8113d178:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113d17c:	e0bff717 	ldw	r2,-36(fp)
8113d180:	10800044 	addi	r2,r2,1
8113d184:	e0bff715 	stw	r2,-36(fp)
8113d188:	e0bffd17 	ldw	r2,-12(fp)
8113d18c:	10bfffc4 	addi	r2,r2,-1
8113d190:	e0fff717 	ldw	r3,-36(fp)
8113d194:	18bff036 	bltu	r3,r2,8113d158 <__reset+0xfb11d158>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113d198:	e0bff617 	ldw	r2,-40(fp)
8113d19c:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113d1a0:	e0bffa17 	ldw	r2,-24(fp)
8113d1a4:	e0fffc17 	ldw	r3,-16(fp)
8113d1a8:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113d1ac:	e0bffa17 	ldw	r2,-24(fp)
8113d1b0:	e0fffc17 	ldw	r3,-16(fp)
8113d1b4:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113d1b8:	e0bffa17 	ldw	r2,-24(fp)
8113d1bc:	e0fffd17 	ldw	r3,-12(fp)
8113d1c0:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113d1c4:	e0bffa17 	ldw	r2,-24(fp)
8113d1c8:	e0fffd17 	ldw	r3,-12(fp)
8113d1cc:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113d1d0:	e0bffa17 	ldw	r2,-24(fp)
8113d1d4:	e0fffe17 	ldw	r3,-8(fp)
8113d1d8:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113d1dc:	e0bfff17 	ldw	r2,-4(fp)
8113d1e0:	10000005 	stb	zero,0(r2)
    return (pmem);
8113d1e4:	e0bffa17 	ldw	r2,-24(fp)
}
8113d1e8:	e037883a 	mov	sp,fp
8113d1ec:	df000017 	ldw	fp,0(sp)
8113d1f0:	dec00104 	addi	sp,sp,4
8113d1f4:	f800283a 	ret

8113d1f8 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113d1f8:	defff804 	addi	sp,sp,-32
8113d1fc:	de00012e 	bgeu	sp,et,8113d204 <OSMemGet+0xc>
8113d200:	003b68fa 	trap	3
8113d204:	df000715 	stw	fp,28(sp)
8113d208:	df000704 	addi	fp,sp,28
8113d20c:	e13ffe15 	stw	r4,-8(fp)
8113d210:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d214:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113d218:	e0bfff17 	ldw	r2,-4(fp)
8113d21c:	1000021e 	bne	r2,zero,8113d228 <OSMemGet+0x30>
        return ((void *)0);
8113d220:	0005883a 	mov	r2,zero
8113d224:	00002e06 	br	8113d2e0 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113d228:	e0bffe17 	ldw	r2,-8(fp)
8113d22c:	1000051e 	bne	r2,zero,8113d244 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113d230:	e0bfff17 	ldw	r2,-4(fp)
8113d234:	00c01804 	movi	r3,96
8113d238:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d23c:	0005883a 	mov	r2,zero
8113d240:	00002706 	br	8113d2e0 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d244:	0005303a 	rdctl	r2,status
8113d248:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d24c:	e0fffd17 	ldw	r3,-12(fp)
8113d250:	00bfff84 	movi	r2,-2
8113d254:	1884703a 	and	r2,r3,r2
8113d258:	1001703a 	wrctl	status,r2
  
  return context;
8113d25c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d260:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113d264:	e0bffe17 	ldw	r2,-8(fp)
8113d268:	10800417 	ldw	r2,16(r2)
8113d26c:	10001426 	beq	r2,zero,8113d2c0 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113d270:	e0bffe17 	ldw	r2,-8(fp)
8113d274:	10800117 	ldw	r2,4(r2)
8113d278:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113d27c:	e0bffb17 	ldw	r2,-20(fp)
8113d280:	10c00017 	ldw	r3,0(r2)
8113d284:	e0bffe17 	ldw	r2,-8(fp)
8113d288:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113d28c:	e0bffe17 	ldw	r2,-8(fp)
8113d290:	10800417 	ldw	r2,16(r2)
8113d294:	10ffffc4 	addi	r3,r2,-1
8113d298:	e0bffe17 	ldw	r2,-8(fp)
8113d29c:	10c00415 	stw	r3,16(r2)
8113d2a0:	e0bff917 	ldw	r2,-28(fp)
8113d2a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d2a8:	e0bffa17 	ldw	r2,-24(fp)
8113d2ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113d2b0:	e0bfff17 	ldw	r2,-4(fp)
8113d2b4:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113d2b8:	e0bffb17 	ldw	r2,-20(fp)
8113d2bc:	00000806 	br	8113d2e0 <OSMemGet+0xe8>
8113d2c0:	e0bff917 	ldw	r2,-28(fp)
8113d2c4:	e0bffc15 	stw	r2,-16(fp)
8113d2c8:	e0bffc17 	ldw	r2,-16(fp)
8113d2cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113d2d0:	e0bfff17 	ldw	r2,-4(fp)
8113d2d4:	00c01744 	movi	r3,93
8113d2d8:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113d2dc:	0005883a 	mov	r2,zero
}
8113d2e0:	e037883a 	mov	sp,fp
8113d2e4:	df000017 	ldw	fp,0(sp)
8113d2e8:	dec00104 	addi	sp,sp,4
8113d2ec:	f800283a 	ret

8113d2f0 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113d2f0:	defff704 	addi	sp,sp,-36
8113d2f4:	de00012e 	bgeu	sp,et,8113d2fc <OSMemNameGet+0xc>
8113d2f8:	003b68fa 	trap	3
8113d2fc:	dfc00815 	stw	ra,32(sp)
8113d300:	df000715 	stw	fp,28(sp)
8113d304:	df000704 	addi	fp,sp,28
8113d308:	e13ffd15 	stw	r4,-12(fp)
8113d30c:	e17ffe15 	stw	r5,-8(fp)
8113d310:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d314:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d318:	e0bfff17 	ldw	r2,-4(fp)
8113d31c:	1000021e 	bne	r2,zero,8113d328 <OSMemNameGet+0x38>
        return (0);
8113d320:	0005883a 	mov	r2,zero
8113d324:	00002b06 	br	8113d3d4 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113d328:	e0bffd17 	ldw	r2,-12(fp)
8113d32c:	1000051e 	bne	r2,zero,8113d344 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113d330:	e0bfff17 	ldw	r2,-4(fp)
8113d334:	00c01804 	movi	r3,96
8113d338:	10c00005 	stb	r3,0(r2)
        return (0);
8113d33c:	0005883a 	mov	r2,zero
8113d340:	00002406 	br	8113d3d4 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113d344:	e0bffe17 	ldw	r2,-8(fp)
8113d348:	1000051e 	bne	r2,zero,8113d360 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113d34c:	e0bfff17 	ldw	r2,-4(fp)
8113d350:	00c00304 	movi	r3,12
8113d354:	10c00005 	stb	r3,0(r2)
        return (0);
8113d358:	0005883a 	mov	r2,zero
8113d35c:	00001d06 	br	8113d3d4 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113d360:	d0a0a103 	ldbu	r2,-32124(gp)
8113d364:	10803fcc 	andi	r2,r2,255
8113d368:	10000526 	beq	r2,zero,8113d380 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113d36c:	e0bfff17 	ldw	r2,-4(fp)
8113d370:	00c00444 	movi	r3,17
8113d374:	10c00005 	stb	r3,0(r2)
        return (0);
8113d378:	0005883a 	mov	r2,zero
8113d37c:	00001506 	br	8113d3d4 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d380:	0005303a 	rdctl	r2,status
8113d384:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d388:	e0fffb17 	ldw	r3,-20(fp)
8113d38c:	00bfff84 	movi	r2,-2
8113d390:	1884703a 	and	r2,r3,r2
8113d394:	1001703a 	wrctl	status,r2
  
  return context;
8113d398:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113d39c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113d3a0:	e0bffd17 	ldw	r2,-12(fp)
8113d3a4:	10800504 	addi	r2,r2,20
8113d3a8:	100b883a 	mov	r5,r2
8113d3ac:	e13ffe17 	ldw	r4,-8(fp)
8113d3b0:	113b0d80 	call	8113b0d8 <OS_StrCopy>
8113d3b4:	e0bffa05 	stb	r2,-24(fp)
8113d3b8:	e0bff917 	ldw	r2,-28(fp)
8113d3bc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d3c0:	e0bffc17 	ldw	r2,-16(fp)
8113d3c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d3c8:	e0bfff17 	ldw	r2,-4(fp)
8113d3cc:	10000005 	stb	zero,0(r2)
    return (len);
8113d3d0:	e0bffa03 	ldbu	r2,-24(fp)
}
8113d3d4:	e037883a 	mov	sp,fp
8113d3d8:	dfc00117 	ldw	ra,4(sp)
8113d3dc:	df000017 	ldw	fp,0(sp)
8113d3e0:	dec00204 	addi	sp,sp,8
8113d3e4:	f800283a 	ret

8113d3e8 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113d3e8:	defff604 	addi	sp,sp,-40
8113d3ec:	de00012e 	bgeu	sp,et,8113d3f4 <OSMemNameSet+0xc>
8113d3f0:	003b68fa 	trap	3
8113d3f4:	dfc00915 	stw	ra,36(sp)
8113d3f8:	df000815 	stw	fp,32(sp)
8113d3fc:	df000804 	addi	fp,sp,32
8113d400:	e13ffd15 	stw	r4,-12(fp)
8113d404:	e17ffe15 	stw	r5,-8(fp)
8113d408:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d40c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d410:	e0bfff17 	ldw	r2,-4(fp)
8113d414:	10003526 	beq	r2,zero,8113d4ec <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113d418:	e0bffd17 	ldw	r2,-12(fp)
8113d41c:	1000041e 	bne	r2,zero,8113d430 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113d420:	e0bfff17 	ldw	r2,-4(fp)
8113d424:	00c01804 	movi	r3,96
8113d428:	10c00005 	stb	r3,0(r2)
        return;
8113d42c:	00003006 	br	8113d4f0 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113d430:	e0bffe17 	ldw	r2,-8(fp)
8113d434:	1000041e 	bne	r2,zero,8113d448 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113d438:	e0bfff17 	ldw	r2,-4(fp)
8113d43c:	00c00304 	movi	r3,12
8113d440:	10c00005 	stb	r3,0(r2)
        return;
8113d444:	00002a06 	br	8113d4f0 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113d448:	d0a0a103 	ldbu	r2,-32124(gp)
8113d44c:	10803fcc 	andi	r2,r2,255
8113d450:	10000426 	beq	r2,zero,8113d464 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113d454:	e0bfff17 	ldw	r2,-4(fp)
8113d458:	00c00484 	movi	r3,18
8113d45c:	10c00005 	stb	r3,0(r2)
        return;
8113d460:	00002306 	br	8113d4f0 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d464:	0005303a 	rdctl	r2,status
8113d468:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d46c:	e0fffc17 	ldw	r3,-16(fp)
8113d470:	00bfff84 	movi	r2,-2
8113d474:	1884703a 	and	r2,r3,r2
8113d478:	1001703a 	wrctl	status,r2
  
  return context;
8113d47c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d480:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113d484:	e13ffe17 	ldw	r4,-8(fp)
8113d488:	113b1540 	call	8113b154 <OS_StrLen>
8113d48c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113d490:	e0bffa03 	ldbu	r2,-24(fp)
8113d494:	10800830 	cmpltui	r2,r2,32
8113d498:	1000081e 	bne	r2,zero,8113d4bc <OSMemNameSet+0xd4>
8113d49c:	e0bff817 	ldw	r2,-32(fp)
8113d4a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d4a4:	e0bff917 	ldw	r2,-28(fp)
8113d4a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113d4ac:	e0bfff17 	ldw	r2,-4(fp)
8113d4b0:	00c018c4 	movi	r3,99
8113d4b4:	10c00005 	stb	r3,0(r2)
        return;
8113d4b8:	00000d06 	br	8113d4f0 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113d4bc:	e0bffd17 	ldw	r2,-12(fp)
8113d4c0:	10800504 	addi	r2,r2,20
8113d4c4:	e17ffe17 	ldw	r5,-8(fp)
8113d4c8:	1009883a 	mov	r4,r2
8113d4cc:	113b0d80 	call	8113b0d8 <OS_StrCopy>
8113d4d0:	e0bff817 	ldw	r2,-32(fp)
8113d4d4:	e0bffb15 	stw	r2,-20(fp)
8113d4d8:	e0bffb17 	ldw	r2,-20(fp)
8113d4dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d4e0:	e0bfff17 	ldw	r2,-4(fp)
8113d4e4:	10000005 	stb	zero,0(r2)
8113d4e8:	00000106 	br	8113d4f0 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113d4ec:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113d4f0:	e037883a 	mov	sp,fp
8113d4f4:	dfc00117 	ldw	ra,4(sp)
8113d4f8:	df000017 	ldw	fp,0(sp)
8113d4fc:	dec00204 	addi	sp,sp,8
8113d500:	f800283a 	ret

8113d504 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113d504:	defff904 	addi	sp,sp,-28
8113d508:	de00012e 	bgeu	sp,et,8113d510 <OSMemPut+0xc>
8113d50c:	003b68fa 	trap	3
8113d510:	df000615 	stw	fp,24(sp)
8113d514:	df000604 	addi	fp,sp,24
8113d518:	e13ffe15 	stw	r4,-8(fp)
8113d51c:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d520:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113d524:	e0bffe17 	ldw	r2,-8(fp)
8113d528:	1000021e 	bne	r2,zero,8113d534 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113d52c:	00801804 	movi	r2,96
8113d530:	00002806 	br	8113d5d4 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113d534:	e0bfff17 	ldw	r2,-4(fp)
8113d538:	1000021e 	bne	r2,zero,8113d544 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113d53c:	008017c4 	movi	r2,95
8113d540:	00002406 	br	8113d5d4 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d544:	0005303a 	rdctl	r2,status
8113d548:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d54c:	e0fffd17 	ldw	r3,-12(fp)
8113d550:	00bfff84 	movi	r2,-2
8113d554:	1884703a 	and	r2,r3,r2
8113d558:	1001703a 	wrctl	status,r2
  
  return context;
8113d55c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d560:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113d564:	e0bffe17 	ldw	r2,-8(fp)
8113d568:	10c00417 	ldw	r3,16(r2)
8113d56c:	e0bffe17 	ldw	r2,-8(fp)
8113d570:	10800317 	ldw	r2,12(r2)
8113d574:	18800636 	bltu	r3,r2,8113d590 <OSMemPut+0x8c>
8113d578:	e0bffa17 	ldw	r2,-24(fp)
8113d57c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d580:	e0bffb17 	ldw	r2,-20(fp)
8113d584:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113d588:	00801784 	movi	r2,94
8113d58c:	00001106 	br	8113d5d4 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113d590:	e0bffe17 	ldw	r2,-8(fp)
8113d594:	10c00117 	ldw	r3,4(r2)
8113d598:	e0bfff17 	ldw	r2,-4(fp)
8113d59c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113d5a0:	e0bffe17 	ldw	r2,-8(fp)
8113d5a4:	e0ffff17 	ldw	r3,-4(fp)
8113d5a8:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113d5ac:	e0bffe17 	ldw	r2,-8(fp)
8113d5b0:	10800417 	ldw	r2,16(r2)
8113d5b4:	10c00044 	addi	r3,r2,1
8113d5b8:	e0bffe17 	ldw	r2,-8(fp)
8113d5bc:	10c00415 	stw	r3,16(r2)
8113d5c0:	e0bffa17 	ldw	r2,-24(fp)
8113d5c4:	e0bffc15 	stw	r2,-16(fp)
8113d5c8:	e0bffc17 	ldw	r2,-16(fp)
8113d5cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113d5d0:	0005883a 	mov	r2,zero
}
8113d5d4:	e037883a 	mov	sp,fp
8113d5d8:	df000017 	ldw	fp,0(sp)
8113d5dc:	dec00104 	addi	sp,sp,4
8113d5e0:	f800283a 	ret

8113d5e4 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113d5e4:	defffa04 	addi	sp,sp,-24
8113d5e8:	de00012e 	bgeu	sp,et,8113d5f0 <OSMemQuery+0xc>
8113d5ec:	003b68fa 	trap	3
8113d5f0:	df000515 	stw	fp,20(sp)
8113d5f4:	df000504 	addi	fp,sp,20
8113d5f8:	e13ffe15 	stw	r4,-8(fp)
8113d5fc:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d600:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113d604:	e0bffe17 	ldw	r2,-8(fp)
8113d608:	1000021e 	bne	r2,zero,8113d614 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113d60c:	00801804 	movi	r2,96
8113d610:	00002c06 	br	8113d6c4 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113d614:	e0bfff17 	ldw	r2,-4(fp)
8113d618:	1000021e 	bne	r2,zero,8113d624 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113d61c:	00801844 	movi	r2,97
8113d620:	00002806 	br	8113d6c4 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d624:	0005303a 	rdctl	r2,status
8113d628:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d62c:	e0fffc17 	ldw	r3,-16(fp)
8113d630:	00bfff84 	movi	r2,-2
8113d634:	1884703a 	and	r2,r3,r2
8113d638:	1001703a 	wrctl	status,r2
  
  return context;
8113d63c:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d640:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113d644:	e0bffe17 	ldw	r2,-8(fp)
8113d648:	10c00017 	ldw	r3,0(r2)
8113d64c:	e0bfff17 	ldw	r2,-4(fp)
8113d650:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113d654:	e0bffe17 	ldw	r2,-8(fp)
8113d658:	10c00117 	ldw	r3,4(r2)
8113d65c:	e0bfff17 	ldw	r2,-4(fp)
8113d660:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113d664:	e0bffe17 	ldw	r2,-8(fp)
8113d668:	10c00217 	ldw	r3,8(r2)
8113d66c:	e0bfff17 	ldw	r2,-4(fp)
8113d670:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113d674:	e0bffe17 	ldw	r2,-8(fp)
8113d678:	10c00317 	ldw	r3,12(r2)
8113d67c:	e0bfff17 	ldw	r2,-4(fp)
8113d680:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113d684:	e0bffe17 	ldw	r2,-8(fp)
8113d688:	10c00417 	ldw	r3,16(r2)
8113d68c:	e0bfff17 	ldw	r2,-4(fp)
8113d690:	10c00415 	stw	r3,16(r2)
8113d694:	e0bffb17 	ldw	r2,-20(fp)
8113d698:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d69c:	e0bffd17 	ldw	r2,-12(fp)
8113d6a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113d6a4:	e0bfff17 	ldw	r2,-4(fp)
8113d6a8:	10c00317 	ldw	r3,12(r2)
8113d6ac:	e0bfff17 	ldw	r2,-4(fp)
8113d6b0:	10800417 	ldw	r2,16(r2)
8113d6b4:	1887c83a 	sub	r3,r3,r2
8113d6b8:	e0bfff17 	ldw	r2,-4(fp)
8113d6bc:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113d6c0:	0005883a 	mov	r2,zero
}
8113d6c4:	e037883a 	mov	sp,fp
8113d6c8:	df000017 	ldw	fp,0(sp)
8113d6cc:	dec00104 	addi	sp,sp,4
8113d6d0:	f800283a 	ret

8113d6d4 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113d6d4:	defffc04 	addi	sp,sp,-16
8113d6d8:	de00012e 	bgeu	sp,et,8113d6e0 <OS_MemInit+0xc>
8113d6dc:	003b68fa 	trap	3
8113d6e0:	dfc00315 	stw	ra,12(sp)
8113d6e4:	df000215 	stw	fp,8(sp)
8113d6e8:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113d6ec:	01430c04 	movi	r5,3120
8113d6f0:	012045f4 	movhi	r4,33047
8113d6f4:	2122a204 	addi	r4,r4,-30072
8113d6f8:	113aeb80 	call	8113aeb8 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113d6fc:	00a045f4 	movhi	r2,33047
8113d700:	10a2a204 	addi	r2,r2,-30072
8113d704:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113d708:	e03fff0d 	sth	zero,-4(fp)
8113d70c:	00001306 	br	8113d75c <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113d710:	e0bfff0b 	ldhu	r2,-4(fp)
8113d714:	10800044 	addi	r2,r2,1
8113d718:	10c00d24 	muli	r3,r2,52
8113d71c:	00a045f4 	movhi	r2,33047
8113d720:	10a2a204 	addi	r2,r2,-30072
8113d724:	1887883a 	add	r3,r3,r2
8113d728:	e0bffe17 	ldw	r2,-8(fp)
8113d72c:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113d730:	e0bffe17 	ldw	r2,-8(fp)
8113d734:	00c00fc4 	movi	r3,63
8113d738:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113d73c:	e0bffe17 	ldw	r2,-8(fp)
8113d740:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113d744:	e0bffe17 	ldw	r2,-8(fp)
8113d748:	10800d04 	addi	r2,r2,52
8113d74c:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113d750:	e0bfff0b 	ldhu	r2,-4(fp)
8113d754:	10800044 	addi	r2,r2,1
8113d758:	e0bfff0d 	sth	r2,-4(fp)
8113d75c:	e0bfff0b 	ldhu	r2,-4(fp)
8113d760:	10800ef0 	cmpltui	r2,r2,59
8113d764:	103fea1e 	bne	r2,zero,8113d710 <__reset+0xfb11d710>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113d768:	e0bffe17 	ldw	r2,-8(fp)
8113d76c:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113d770:	e0bffe17 	ldw	r2,-8(fp)
8113d774:	00c00fc4 	movi	r3,63
8113d778:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113d77c:	e0bffe17 	ldw	r2,-8(fp)
8113d780:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113d784:	00a045f4 	movhi	r2,33047
8113d788:	10a2a204 	addi	r2,r2,-30072
8113d78c:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113d790:	0001883a 	nop
8113d794:	e037883a 	mov	sp,fp
8113d798:	dfc00117 	ldw	ra,4(sp)
8113d79c:	df000017 	ldw	fp,0(sp)
8113d7a0:	dec00204 	addi	sp,sp,8
8113d7a4:	f800283a 	ret

8113d7a8 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113d7a8:	defff704 	addi	sp,sp,-36
8113d7ac:	de00012e 	bgeu	sp,et,8113d7b4 <OSMutexAccept+0xc>
8113d7b0:	003b68fa 	trap	3
8113d7b4:	df000815 	stw	fp,32(sp)
8113d7b8:	df000804 	addi	fp,sp,32
8113d7bc:	e13ffe15 	stw	r4,-8(fp)
8113d7c0:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113d7c4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113d7c8:	e0bfff17 	ldw	r2,-4(fp)
8113d7cc:	1000021e 	bne	r2,zero,8113d7d8 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113d7d0:	0005883a 	mov	r2,zero
8113d7d4:	00005b06 	br	8113d944 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113d7d8:	e0bffe17 	ldw	r2,-8(fp)
8113d7dc:	1000051e 	bne	r2,zero,8113d7f4 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113d7e0:	e0bfff17 	ldw	r2,-4(fp)
8113d7e4:	00c00104 	movi	r3,4
8113d7e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d7ec:	0005883a 	mov	r2,zero
8113d7f0:	00005406 	br	8113d944 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113d7f4:	e0bffe17 	ldw	r2,-8(fp)
8113d7f8:	10800003 	ldbu	r2,0(r2)
8113d7fc:	10803fcc 	andi	r2,r2,255
8113d800:	10800120 	cmpeqi	r2,r2,4
8113d804:	1000051e 	bne	r2,zero,8113d81c <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113d808:	e0bfff17 	ldw	r2,-4(fp)
8113d80c:	00c00044 	movi	r3,1
8113d810:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d814:	0005883a 	mov	r2,zero
8113d818:	00004a06 	br	8113d944 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113d81c:	d0a0a103 	ldbu	r2,-32124(gp)
8113d820:	10803fcc 	andi	r2,r2,255
8113d824:	10000526 	beq	r2,zero,8113d83c <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113d828:	e0bfff17 	ldw	r2,-4(fp)
8113d82c:	00c00084 	movi	r3,2
8113d830:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d834:	0005883a 	mov	r2,zero
8113d838:	00004206 	br	8113d944 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d83c:	0005303a 	rdctl	r2,status
8113d840:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d844:	e0fffd17 	ldw	r3,-12(fp)
8113d848:	00bfff84 	movi	r2,-2
8113d84c:	1884703a 	and	r2,r3,r2
8113d850:	1001703a 	wrctl	status,r2
  
  return context;
8113d854:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113d858:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113d85c:	e0bffe17 	ldw	r2,-8(fp)
8113d860:	1080020b 	ldhu	r2,8(r2)
8113d864:	10bfffcc 	andi	r2,r2,65535
8113d868:	1004d23a 	srli	r2,r2,8
8113d86c:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113d870:	e0bffe17 	ldw	r2,-8(fp)
8113d874:	1080020b 	ldhu	r2,8(r2)
8113d878:	10bfffcc 	andi	r2,r2,65535
8113d87c:	10803fcc 	andi	r2,r2,255
8113d880:	10803fd8 	cmpnei	r2,r2,255
8113d884:	1000281e 	bne	r2,zero,8113d928 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113d888:	e0bffe17 	ldw	r2,-8(fp)
8113d88c:	10c0020b 	ldhu	r3,8(r2)
8113d890:	00bfc004 	movi	r2,-256
8113d894:	1884703a 	and	r2,r3,r2
8113d898:	1007883a 	mov	r3,r2
8113d89c:	e0bffe17 	ldw	r2,-8(fp)
8113d8a0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113d8a4:	e0bffe17 	ldw	r2,-8(fp)
8113d8a8:	10c0020b 	ldhu	r3,8(r2)
8113d8ac:	d0a0a217 	ldw	r2,-32120(gp)
8113d8b0:	10800c83 	ldbu	r2,50(r2)
8113d8b4:	10803fcc 	andi	r2,r2,255
8113d8b8:	1884b03a 	or	r2,r3,r2
8113d8bc:	1007883a 	mov	r3,r2
8113d8c0:	e0bffe17 	ldw	r2,-8(fp)
8113d8c4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113d8c8:	d0e0a217 	ldw	r3,-32120(gp)
8113d8cc:	e0bffe17 	ldw	r2,-8(fp)
8113d8d0:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113d8d4:	d0a0a217 	ldw	r2,-32120(gp)
8113d8d8:	10800c83 	ldbu	r2,50(r2)
8113d8dc:	10803fcc 	andi	r2,r2,255
8113d8e0:	e0fffa03 	ldbu	r3,-24(fp)
8113d8e4:	18800836 	bltu	r3,r2,8113d908 <OSMutexAccept+0x160>
8113d8e8:	e0bff817 	ldw	r2,-32(fp)
8113d8ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d8f0:	e0bff917 	ldw	r2,-28(fp)
8113d8f4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113d8f8:	e0bfff17 	ldw	r2,-4(fp)
8113d8fc:	00c01e04 	movi	r3,120
8113d900:	10c00005 	stb	r3,0(r2)
8113d904:	00000606 	br	8113d920 <OSMutexAccept+0x178>
8113d908:	e0bff817 	ldw	r2,-32(fp)
8113d90c:	e0bffb15 	stw	r2,-20(fp)
8113d910:	e0bffb17 	ldw	r2,-20(fp)
8113d914:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113d918:	e0bfff17 	ldw	r2,-4(fp)
8113d91c:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113d920:	00800044 	movi	r2,1
8113d924:	00000706 	br	8113d944 <OSMutexAccept+0x19c>
8113d928:	e0bff817 	ldw	r2,-32(fp)
8113d92c:	e0bffc15 	stw	r2,-16(fp)
8113d930:	e0bffc17 	ldw	r2,-16(fp)
8113d934:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d938:	e0bfff17 	ldw	r2,-4(fp)
8113d93c:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113d940:	0005883a 	mov	r2,zero
}
8113d944:	e037883a 	mov	sp,fp
8113d948:	df000017 	ldw	fp,0(sp)
8113d94c:	dec00104 	addi	sp,sp,4
8113d950:	f800283a 	ret

8113d954 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113d954:	defff604 	addi	sp,sp,-40
8113d958:	de00012e 	bgeu	sp,et,8113d960 <OSMutexCreate+0xc>
8113d95c:	003b68fa 	trap	3
8113d960:	dfc00915 	stw	ra,36(sp)
8113d964:	df000815 	stw	fp,32(sp)
8113d968:	df000804 	addi	fp,sp,32
8113d96c:	2005883a 	mov	r2,r4
8113d970:	e17fff15 	stw	r5,-4(fp)
8113d974:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d978:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d97c:	e0bfff17 	ldw	r2,-4(fp)
8113d980:	1000021e 	bne	r2,zero,8113d98c <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113d984:	0005883a 	mov	r2,zero
8113d988:	00006106 	br	8113db10 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113d98c:	e0bffe03 	ldbu	r2,-8(fp)
8113d990:	10800ab0 	cmpltui	r2,r2,42
8113d994:	1000051e 	bne	r2,zero,8113d9ac <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113d998:	e0bfff17 	ldw	r2,-4(fp)
8113d99c:	00c00a84 	movi	r3,42
8113d9a0:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113d9a4:	0005883a 	mov	r2,zero
8113d9a8:	00005906 	br	8113db10 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d9ac:	d0a0a103 	ldbu	r2,-32124(gp)
8113d9b0:	10803fcc 	andi	r2,r2,255
8113d9b4:	10000526 	beq	r2,zero,8113d9cc <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113d9b8:	e0bfff17 	ldw	r2,-4(fp)
8113d9bc:	00c00404 	movi	r3,16
8113d9c0:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113d9c4:	0005883a 	mov	r2,zero
8113d9c8:	00005106 	br	8113db10 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d9cc:	0005303a 	rdctl	r2,status
8113d9d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d9d4:	e0fffd17 	ldw	r3,-12(fp)
8113d9d8:	00bfff84 	movi	r2,-2
8113d9dc:	1884703a 	and	r2,r3,r2
8113d9e0:	1001703a 	wrctl	status,r2
  
  return context;
8113d9e4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d9e8:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113d9ec:	e0fffe03 	ldbu	r3,-8(fp)
8113d9f0:	00a045f4 	movhi	r2,33047
8113d9f4:	10b81c04 	addi	r2,r2,-8080
8113d9f8:	18c7883a 	add	r3,r3,r3
8113d9fc:	18c7883a 	add	r3,r3,r3
8113da00:	10c5883a 	add	r2,r2,r3
8113da04:	10800017 	ldw	r2,0(r2)
8113da08:	10000926 	beq	r2,zero,8113da30 <OSMutexCreate+0xdc>
8113da0c:	e0bff817 	ldw	r2,-32(fp)
8113da10:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da14:	e0bff917 	ldw	r2,-28(fp)
8113da18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113da1c:	e0bfff17 	ldw	r2,-4(fp)
8113da20:	00c00a04 	movi	r3,40
8113da24:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113da28:	0005883a 	mov	r2,zero
8113da2c:	00003806 	br	8113db10 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113da30:	e0fffe03 	ldbu	r3,-8(fp)
8113da34:	00a045f4 	movhi	r2,33047
8113da38:	10b81c04 	addi	r2,r2,-8080
8113da3c:	18c7883a 	add	r3,r3,r3
8113da40:	18c7883a 	add	r3,r3,r3
8113da44:	10c5883a 	add	r2,r2,r3
8113da48:	00c00044 	movi	r3,1
8113da4c:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113da50:	d0a0a017 	ldw	r2,-32128(gp)
8113da54:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113da58:	e0bffb17 	ldw	r2,-20(fp)
8113da5c:	1000101e 	bne	r2,zero,8113daa0 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113da60:	e0fffe03 	ldbu	r3,-8(fp)
8113da64:	00a045f4 	movhi	r2,33047
8113da68:	10b81c04 	addi	r2,r2,-8080
8113da6c:	18c7883a 	add	r3,r3,r3
8113da70:	18c7883a 	add	r3,r3,r3
8113da74:	10c5883a 	add	r2,r2,r3
8113da78:	10000015 	stw	zero,0(r2)
8113da7c:	e0bff817 	ldw	r2,-32(fp)
8113da80:	e0bffa15 	stw	r2,-24(fp)
8113da84:	e0bffa17 	ldw	r2,-24(fp)
8113da88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113da8c:	e0bfff17 	ldw	r2,-4(fp)
8113da90:	00c00104 	movi	r3,4
8113da94:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113da98:	e0bffb17 	ldw	r2,-20(fp)
8113da9c:	00001c06 	br	8113db10 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113daa0:	d0a0a017 	ldw	r2,-32128(gp)
8113daa4:	10800117 	ldw	r2,4(r2)
8113daa8:	d0a0a015 	stw	r2,-32128(gp)
8113daac:	e0bff817 	ldw	r2,-32(fp)
8113dab0:	e0bffc15 	stw	r2,-16(fp)
8113dab4:	e0bffc17 	ldw	r2,-16(fp)
8113dab8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113dabc:	e0bffb17 	ldw	r2,-20(fp)
8113dac0:	00c00104 	movi	r3,4
8113dac4:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113dac8:	e0bffe03 	ldbu	r2,-8(fp)
8113dacc:	1004923a 	slli	r2,r2,8
8113dad0:	10803fd4 	ori	r2,r2,255
8113dad4:	1007883a 	mov	r3,r2
8113dad8:	e0bffb17 	ldw	r2,-20(fp)
8113dadc:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113dae0:	e0bffb17 	ldw	r2,-20(fp)
8113dae4:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113dae8:	e0bffb17 	ldw	r2,-20(fp)
8113daec:	00c00fc4 	movi	r3,63
8113daf0:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113daf4:	e0bffb17 	ldw	r2,-20(fp)
8113daf8:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113dafc:	e13ffb17 	ldw	r4,-20(fp)
8113db00:	113aaa00 	call	8113aaa0 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113db04:	e0bfff17 	ldw	r2,-4(fp)
8113db08:	10000005 	stb	zero,0(r2)
    return (pevent);
8113db0c:	e0bffb17 	ldw	r2,-20(fp)
}
8113db10:	e037883a 	mov	sp,fp
8113db14:	dfc00117 	ldw	ra,4(sp)
8113db18:	df000017 	ldw	fp,0(sp)
8113db1c:	dec00204 	addi	sp,sp,8
8113db20:	f800283a 	ret

8113db24 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113db24:	defff004 	addi	sp,sp,-64
8113db28:	de00012e 	bgeu	sp,et,8113db30 <OSMutexDel+0xc>
8113db2c:	003b68fa 	trap	3
8113db30:	dfc00f15 	stw	ra,60(sp)
8113db34:	df000e15 	stw	fp,56(sp)
8113db38:	df000e04 	addi	fp,sp,56
8113db3c:	e13ffd15 	stw	r4,-12(fp)
8113db40:	2805883a 	mov	r2,r5
8113db44:	e1bfff15 	stw	r6,-4(fp)
8113db48:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113db4c:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113db50:	e0bfff17 	ldw	r2,-4(fp)
8113db54:	1000021e 	bne	r2,zero,8113db60 <OSMutexDel+0x3c>
        return (pevent);
8113db58:	e0bffd17 	ldw	r2,-12(fp)
8113db5c:	0000ad06 	br	8113de14 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113db60:	e0bffd17 	ldw	r2,-12(fp)
8113db64:	1000051e 	bne	r2,zero,8113db7c <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113db68:	e0bfff17 	ldw	r2,-4(fp)
8113db6c:	00c00104 	movi	r3,4
8113db70:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db74:	e0bffd17 	ldw	r2,-12(fp)
8113db78:	0000a606 	br	8113de14 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113db7c:	e0bffd17 	ldw	r2,-12(fp)
8113db80:	10800003 	ldbu	r2,0(r2)
8113db84:	10803fcc 	andi	r2,r2,255
8113db88:	10800120 	cmpeqi	r2,r2,4
8113db8c:	1000051e 	bne	r2,zero,8113dba4 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113db90:	e0bfff17 	ldw	r2,-4(fp)
8113db94:	00c00044 	movi	r3,1
8113db98:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db9c:	e0bffd17 	ldw	r2,-12(fp)
8113dba0:	00009c06 	br	8113de14 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113dba4:	d0a0a103 	ldbu	r2,-32124(gp)
8113dba8:	10803fcc 	andi	r2,r2,255
8113dbac:	10000526 	beq	r2,zero,8113dbc4 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113dbb0:	e0bfff17 	ldw	r2,-4(fp)
8113dbb4:	00c003c4 	movi	r3,15
8113dbb8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113dbbc:	e0bffd17 	ldw	r2,-12(fp)
8113dbc0:	00009406 	br	8113de14 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dbc4:	0005303a 	rdctl	r2,status
8113dbc8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dbcc:	e0fffc17 	ldw	r3,-16(fp)
8113dbd0:	00bfff84 	movi	r2,-2
8113dbd4:	1884703a 	and	r2,r3,r2
8113dbd8:	1001703a 	wrctl	status,r2
  
  return context;
8113dbdc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dbe0:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113dbe4:	e0bffd17 	ldw	r2,-12(fp)
8113dbe8:	10800283 	ldbu	r2,10(r2)
8113dbec:	10803fcc 	andi	r2,r2,255
8113dbf0:	10000326 	beq	r2,zero,8113dc00 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113dbf4:	00800044 	movi	r2,1
8113dbf8:	e0bff205 	stb	r2,-56(fp)
8113dbfc:	00000106 	br	8113dc04 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113dc00:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113dc04:	e0bffe03 	ldbu	r2,-8(fp)
8113dc08:	10000326 	beq	r2,zero,8113dc18 <OSMutexDel+0xf4>
8113dc0c:	10800060 	cmpeqi	r2,r2,1
8113dc10:	10002f1e 	bne	r2,zero,8113dcd0 <OSMutexDel+0x1ac>
8113dc14:	00007406 	br	8113dde8 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113dc18:	e0bff203 	ldbu	r2,-56(fp)
8113dc1c:	1000221e 	bne	r2,zero,8113dca8 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113dc20:	e0bffd17 	ldw	r2,-12(fp)
8113dc24:	00c00fc4 	movi	r3,63
8113dc28:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113dc2c:	e0bffd17 	ldw	r2,-12(fp)
8113dc30:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113dc34:	e0bffd17 	ldw	r2,-12(fp)
8113dc38:	1080020b 	ldhu	r2,8(r2)
8113dc3c:	10bfffcc 	andi	r2,r2,65535
8113dc40:	1004d23a 	srli	r2,r2,8
8113dc44:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113dc48:	e0fff603 	ldbu	r3,-40(fp)
8113dc4c:	00a045f4 	movhi	r2,33047
8113dc50:	10b81c04 	addi	r2,r2,-8080
8113dc54:	18c7883a 	add	r3,r3,r3
8113dc58:	18c7883a 	add	r3,r3,r3
8113dc5c:	10c5883a 	add	r2,r2,r3
8113dc60:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113dc64:	e0bffd17 	ldw	r2,-12(fp)
8113dc68:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113dc6c:	d0e0a017 	ldw	r3,-32128(gp)
8113dc70:	e0bffd17 	ldw	r2,-12(fp)
8113dc74:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113dc78:	e0bffd17 	ldw	r2,-12(fp)
8113dc7c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113dc80:	e0bffd17 	ldw	r2,-12(fp)
8113dc84:	d0a0a015 	stw	r2,-32128(gp)
8113dc88:	e0bff417 	ldw	r2,-48(fp)
8113dc8c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dc90:	e0bff517 	ldw	r2,-44(fp)
8113dc94:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113dc98:	e0bfff17 	ldw	r2,-4(fp)
8113dc9c:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113dca0:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113dca4:	00005a06 	br	8113de10 <OSMutexDel+0x2ec>
8113dca8:	e0bff417 	ldw	r2,-48(fp)
8113dcac:	e0bff715 	stw	r2,-36(fp)
8113dcb0:	e0bff717 	ldw	r2,-36(fp)
8113dcb4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113dcb8:	e0bfff17 	ldw	r2,-4(fp)
8113dcbc:	00c01244 	movi	r3,73
8113dcc0:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113dcc4:	e0bffd17 	ldw	r2,-12(fp)
8113dcc8:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113dccc:	00005006 	br	8113de10 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113dcd0:	e0bffd17 	ldw	r2,-12(fp)
8113dcd4:	1080020b 	ldhu	r2,8(r2)
8113dcd8:	10bfffcc 	andi	r2,r2,65535
8113dcdc:	1004d23a 	srli	r2,r2,8
8113dce0:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113dce4:	e0bffd17 	ldw	r2,-12(fp)
8113dce8:	1080020b 	ldhu	r2,8(r2)
8113dcec:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113dcf0:	e0bffd17 	ldw	r2,-12(fp)
8113dcf4:	10800117 	ldw	r2,4(r2)
8113dcf8:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113dcfc:	e0bffa17 	ldw	r2,-24(fp)
8113dd00:	10000f26 	beq	r2,zero,8113dd40 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113dd04:	e0bffa17 	ldw	r2,-24(fp)
8113dd08:	10800c83 	ldbu	r2,50(r2)
8113dd0c:	10c03fcc 	andi	r3,r2,255
8113dd10:	e0bff603 	ldbu	r2,-40(fp)
8113dd14:	18800a1e 	bne	r3,r2,8113dd40 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113dd18:	e0bff903 	ldbu	r2,-28(fp)
8113dd1c:	100b883a 	mov	r5,r2
8113dd20:	e13ffa17 	ldw	r4,-24(fp)
8113dd24:	113e7600 	call	8113e760 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113dd28:	00000506 	br	8113dd40 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113dd2c:	000f883a 	mov	r7,zero
8113dd30:	01800404 	movi	r6,16
8113dd34:	000b883a 	mov	r5,zero
8113dd38:	e13ffd17 	ldw	r4,-12(fp)
8113dd3c:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113dd40:	e0bffd17 	ldw	r2,-12(fp)
8113dd44:	10800283 	ldbu	r2,10(r2)
8113dd48:	10803fcc 	andi	r2,r2,255
8113dd4c:	103ff71e 	bne	r2,zero,8113dd2c <__reset+0xfb11dd2c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113dd50:	e0bffd17 	ldw	r2,-12(fp)
8113dd54:	00c00fc4 	movi	r3,63
8113dd58:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113dd5c:	e0bffd17 	ldw	r2,-12(fp)
8113dd60:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113dd64:	e0bffd17 	ldw	r2,-12(fp)
8113dd68:	1080020b 	ldhu	r2,8(r2)
8113dd6c:	10bfffcc 	andi	r2,r2,65535
8113dd70:	1004d23a 	srli	r2,r2,8
8113dd74:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113dd78:	e0fff603 	ldbu	r3,-40(fp)
8113dd7c:	00a045f4 	movhi	r2,33047
8113dd80:	10b81c04 	addi	r2,r2,-8080
8113dd84:	18c7883a 	add	r3,r3,r3
8113dd88:	18c7883a 	add	r3,r3,r3
8113dd8c:	10c5883a 	add	r2,r2,r3
8113dd90:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113dd94:	e0bffd17 	ldw	r2,-12(fp)
8113dd98:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113dd9c:	d0e0a017 	ldw	r3,-32128(gp)
8113dda0:	e0bffd17 	ldw	r2,-12(fp)
8113dda4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113dda8:	e0bffd17 	ldw	r2,-12(fp)
8113ddac:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113ddb0:	e0bffd17 	ldw	r2,-12(fp)
8113ddb4:	d0a0a015 	stw	r2,-32128(gp)
8113ddb8:	e0bff417 	ldw	r2,-48(fp)
8113ddbc:	e0bff815 	stw	r2,-32(fp)
8113ddc0:	e0bff817 	ldw	r2,-32(fp)
8113ddc4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113ddc8:	e0bff203 	ldbu	r2,-56(fp)
8113ddcc:	10800058 	cmpnei	r2,r2,1
8113ddd0:	1000011e 	bne	r2,zero,8113ddd8 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113ddd4:	113af840 	call	8113af84 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113ddd8:	e0bfff17 	ldw	r2,-4(fp)
8113dddc:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113dde0:	e03ff315 	stw	zero,-52(fp)
             break;
8113dde4:	00000a06 	br	8113de10 <OSMutexDel+0x2ec>
8113dde8:	e0bff417 	ldw	r2,-48(fp)
8113ddec:	e0bffb15 	stw	r2,-20(fp)
8113ddf0:	e0bffb17 	ldw	r2,-20(fp)
8113ddf4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113ddf8:	e0bfff17 	ldw	r2,-4(fp)
8113ddfc:	00c001c4 	movi	r3,7
8113de00:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113de04:	e0bffd17 	ldw	r2,-12(fp)
8113de08:	e0bff315 	stw	r2,-52(fp)
             break;
8113de0c:	0001883a 	nop
    }
    return (pevent_return);
8113de10:	e0bff317 	ldw	r2,-52(fp)
}
8113de14:	e037883a 	mov	sp,fp
8113de18:	dfc00117 	ldw	ra,4(sp)
8113de1c:	df000017 	ldw	fp,0(sp)
8113de20:	dec00204 	addi	sp,sp,8
8113de24:	f800283a 	ret

8113de28 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113de28:	deffee04 	addi	sp,sp,-72
8113de2c:	de00012e 	bgeu	sp,et,8113de34 <OSMutexPend+0xc>
8113de30:	003b68fa 	trap	3
8113de34:	dfc01115 	stw	ra,68(sp)
8113de38:	df001015 	stw	fp,64(sp)
8113de3c:	df001004 	addi	fp,sp,64
8113de40:	e13ffd15 	stw	r4,-12(fp)
8113de44:	2805883a 	mov	r2,r5
8113de48:	e1bfff15 	stw	r6,-4(fp)
8113de4c:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113de50:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113de54:	e0bfff17 	ldw	r2,-4(fp)
8113de58:	10015626 	beq	r2,zero,8113e3b4 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113de5c:	e0bffd17 	ldw	r2,-12(fp)
8113de60:	1000041e 	bne	r2,zero,8113de74 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113de64:	e0bfff17 	ldw	r2,-4(fp)
8113de68:	00c00104 	movi	r3,4
8113de6c:	10c00005 	stb	r3,0(r2)
        return;
8113de70:	00015106 	br	8113e3b8 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113de74:	e0bffd17 	ldw	r2,-12(fp)
8113de78:	10800003 	ldbu	r2,0(r2)
8113de7c:	10803fcc 	andi	r2,r2,255
8113de80:	10800120 	cmpeqi	r2,r2,4
8113de84:	1000041e 	bne	r2,zero,8113de98 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113de88:	e0bfff17 	ldw	r2,-4(fp)
8113de8c:	00c00044 	movi	r3,1
8113de90:	10c00005 	stb	r3,0(r2)
        return;
8113de94:	00014806 	br	8113e3b8 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113de98:	d0a0a103 	ldbu	r2,-32124(gp)
8113de9c:	10803fcc 	andi	r2,r2,255
8113dea0:	10000426 	beq	r2,zero,8113deb4 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113dea4:	e0bfff17 	ldw	r2,-4(fp)
8113dea8:	00c00084 	movi	r3,2
8113deac:	10c00005 	stb	r3,0(r2)
        return;
8113deb0:	00014106 	br	8113e3b8 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113deb4:	d0a08f03 	ldbu	r2,-32196(gp)
8113deb8:	10803fcc 	andi	r2,r2,255
8113debc:	10000426 	beq	r2,zero,8113ded0 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113dec0:	e0bfff17 	ldw	r2,-4(fp)
8113dec4:	00c00344 	movi	r3,13
8113dec8:	10c00005 	stb	r3,0(r2)
        return;
8113decc:	00013a06 	br	8113e3b8 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ded0:	0005303a 	rdctl	r2,status
8113ded4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ded8:	e0fffc17 	ldw	r3,-16(fp)
8113dedc:	00bfff84 	movi	r2,-2
8113dee0:	1884703a 	and	r2,r3,r2
8113dee4:	1001703a 	wrctl	status,r2
  
  return context;
8113dee8:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113deec:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113def0:	e0bffd17 	ldw	r2,-12(fp)
8113def4:	1080020b 	ldhu	r2,8(r2)
8113def8:	10bfffcc 	andi	r2,r2,65535
8113defc:	1004d23a 	srli	r2,r2,8
8113df00:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113df04:	e0bffd17 	ldw	r2,-12(fp)
8113df08:	1080020b 	ldhu	r2,8(r2)
8113df0c:	10803fcc 	andi	r2,r2,255
8113df10:	10803fd8 	cmpnei	r2,r2,255
8113df14:	1000271e 	bne	r2,zero,8113dfb4 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113df18:	e0bffd17 	ldw	r2,-12(fp)
8113df1c:	10c0020b 	ldhu	r3,8(r2)
8113df20:	00bfc004 	movi	r2,-256
8113df24:	1884703a 	and	r2,r3,r2
8113df28:	1007883a 	mov	r3,r2
8113df2c:	e0bffd17 	ldw	r2,-12(fp)
8113df30:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113df34:	e0bffd17 	ldw	r2,-12(fp)
8113df38:	10c0020b 	ldhu	r3,8(r2)
8113df3c:	d0a0a217 	ldw	r2,-32120(gp)
8113df40:	10800c83 	ldbu	r2,50(r2)
8113df44:	10803fcc 	andi	r2,r2,255
8113df48:	1884b03a 	or	r2,r3,r2
8113df4c:	1007883a 	mov	r3,r2
8113df50:	e0bffd17 	ldw	r2,-12(fp)
8113df54:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113df58:	d0e0a217 	ldw	r3,-32120(gp)
8113df5c:	e0bffd17 	ldw	r2,-12(fp)
8113df60:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113df64:	d0a0a217 	ldw	r2,-32120(gp)
8113df68:	10800c83 	ldbu	r2,50(r2)
8113df6c:	10803fcc 	andi	r2,r2,255
8113df70:	e0fff303 	ldbu	r3,-52(fp)
8113df74:	18800836 	bltu	r3,r2,8113df98 <OSMutexPend+0x170>
8113df78:	e0bff117 	ldw	r2,-60(fp)
8113df7c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113df80:	e0bff217 	ldw	r2,-56(fp)
8113df84:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113df88:	e0bfff17 	ldw	r2,-4(fp)
8113df8c:	00c01e04 	movi	r3,120
8113df90:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113df94:	00010806 	br	8113e3b8 <OSMutexPend+0x590>
8113df98:	e0bff117 	ldw	r2,-60(fp)
8113df9c:	e0bff415 	stw	r2,-48(fp)
8113dfa0:	e0bff417 	ldw	r2,-48(fp)
8113dfa4:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113dfa8:	e0bfff17 	ldw	r2,-4(fp)
8113dfac:	10000005 	stb	zero,0(r2)
        }
        return;
8113dfb0:	00010106 	br	8113e3b8 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113dfb4:	e0bffd17 	ldw	r2,-12(fp)
8113dfb8:	1080020b 	ldhu	r2,8(r2)
8113dfbc:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113dfc0:	e0bffd17 	ldw	r2,-12(fp)
8113dfc4:	10800117 	ldw	r2,4(r2)
8113dfc8:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113dfcc:	e0bff717 	ldw	r2,-36(fp)
8113dfd0:	10800c83 	ldbu	r2,50(r2)
8113dfd4:	10803fcc 	andi	r2,r2,255
8113dfd8:	e0fff303 	ldbu	r3,-52(fp)
8113dfdc:	1880b92e 	bgeu	r3,r2,8113e2c4 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113dfe0:	d0a0a217 	ldw	r2,-32120(gp)
8113dfe4:	10800c83 	ldbu	r2,50(r2)
8113dfe8:	10c03fcc 	andi	r3,r2,255
8113dfec:	e0bff603 	ldbu	r2,-40(fp)
8113dff0:	1880b42e 	bgeu	r3,r2,8113e2c4 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113dff4:	e0bff717 	ldw	r2,-36(fp)
8113dff8:	10800d03 	ldbu	r2,52(r2)
8113dffc:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113e000:	e0fff803 	ldbu	r3,-32(fp)
8113e004:	d0a09e44 	addi	r2,gp,-32135
8113e008:	1885883a 	add	r2,r3,r2
8113e00c:	10c00003 	ldbu	r3,0(r2)
8113e010:	e0bff717 	ldw	r2,-36(fp)
8113e014:	10800d43 	ldbu	r2,53(r2)
8113e018:	1884703a 	and	r2,r3,r2
8113e01c:	10803fcc 	andi	r2,r2,255
8113e020:	10001e26 	beq	r2,zero,8113e09c <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113e024:	e0fff803 	ldbu	r3,-32(fp)
8113e028:	e13ff803 	ldbu	r4,-32(fp)
8113e02c:	d0a09e44 	addi	r2,gp,-32135
8113e030:	2085883a 	add	r2,r4,r2
8113e034:	10800003 	ldbu	r2,0(r2)
8113e038:	1009883a 	mov	r4,r2
8113e03c:	e0bff717 	ldw	r2,-36(fp)
8113e040:	10800d43 	ldbu	r2,53(r2)
8113e044:	0084303a 	nor	r2,zero,r2
8113e048:	2084703a 	and	r2,r4,r2
8113e04c:	1009883a 	mov	r4,r2
8113e050:	d0a09e44 	addi	r2,gp,-32135
8113e054:	1885883a 	add	r2,r3,r2
8113e058:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113e05c:	e0fff803 	ldbu	r3,-32(fp)
8113e060:	d0a09e44 	addi	r2,gp,-32135
8113e064:	1885883a 	add	r2,r3,r2
8113e068:	10800003 	ldbu	r2,0(r2)
8113e06c:	10803fcc 	andi	r2,r2,255
8113e070:	1000071e 	bne	r2,zero,8113e090 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113e074:	e0bff717 	ldw	r2,-36(fp)
8113e078:	10800d83 	ldbu	r2,54(r2)
8113e07c:	0084303a 	nor	r2,zero,r2
8113e080:	1007883a 	mov	r3,r2
8113e084:	d0a09e03 	ldbu	r2,-32136(gp)
8113e088:	1884703a 	and	r2,r3,r2
8113e08c:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113e090:	00800044 	movi	r2,1
8113e094:	e0bff005 	stb	r2,-64(fp)
8113e098:	00002a06 	br	8113e144 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113e09c:	e0bff717 	ldw	r2,-36(fp)
8113e0a0:	10800717 	ldw	r2,28(r2)
8113e0a4:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113e0a8:	e0bff917 	ldw	r2,-28(fp)
8113e0ac:	10002426 	beq	r2,zero,8113e140 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113e0b0:	e0bff717 	ldw	r2,-36(fp)
8113e0b4:	10800d03 	ldbu	r2,52(r2)
8113e0b8:	10803fcc 	andi	r2,r2,255
8113e0bc:	e0fff717 	ldw	r3,-36(fp)
8113e0c0:	18c00d03 	ldbu	r3,52(r3)
8113e0c4:	18c03fcc 	andi	r3,r3,255
8113e0c8:	e13ff917 	ldw	r4,-28(fp)
8113e0cc:	20c7883a 	add	r3,r4,r3
8113e0d0:	18c002c4 	addi	r3,r3,11
8113e0d4:	18c00003 	ldbu	r3,0(r3)
8113e0d8:	1809883a 	mov	r4,r3
8113e0dc:	e0fff717 	ldw	r3,-36(fp)
8113e0e0:	18c00d43 	ldbu	r3,53(r3)
8113e0e4:	00c6303a 	nor	r3,zero,r3
8113e0e8:	20c6703a 	and	r3,r4,r3
8113e0ec:	1809883a 	mov	r4,r3
8113e0f0:	e0fff917 	ldw	r3,-28(fp)
8113e0f4:	1887883a 	add	r3,r3,r2
8113e0f8:	18c002c4 	addi	r3,r3,11
8113e0fc:	19000005 	stb	r4,0(r3)
8113e100:	e0fff917 	ldw	r3,-28(fp)
8113e104:	1885883a 	add	r2,r3,r2
8113e108:	108002c4 	addi	r2,r2,11
8113e10c:	10800003 	ldbu	r2,0(r2)
8113e110:	10803fcc 	andi	r2,r2,255
8113e114:	10000a1e 	bne	r2,zero,8113e140 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113e118:	e0bff917 	ldw	r2,-28(fp)
8113e11c:	10800283 	ldbu	r2,10(r2)
8113e120:	1007883a 	mov	r3,r2
8113e124:	e0bff717 	ldw	r2,-36(fp)
8113e128:	10800d83 	ldbu	r2,54(r2)
8113e12c:	0084303a 	nor	r2,zero,r2
8113e130:	1884703a 	and	r2,r3,r2
8113e134:	1007883a 	mov	r3,r2
8113e138:	e0bff917 	ldw	r2,-28(fp)
8113e13c:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113e140:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113e144:	e0bff717 	ldw	r2,-36(fp)
8113e148:	e0fff303 	ldbu	r3,-52(fp)
8113e14c:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113e150:	e0bff717 	ldw	r2,-36(fp)
8113e154:	10800c83 	ldbu	r2,50(r2)
8113e158:	10803fcc 	andi	r2,r2,255
8113e15c:	1004d0fa 	srli	r2,r2,3
8113e160:	1007883a 	mov	r3,r2
8113e164:	e0bff717 	ldw	r2,-36(fp)
8113e168:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113e16c:	e0bff717 	ldw	r2,-36(fp)
8113e170:	10800c83 	ldbu	r2,50(r2)
8113e174:	108001cc 	andi	r2,r2,7
8113e178:	1007883a 	mov	r3,r2
8113e17c:	e0bff717 	ldw	r2,-36(fp)
8113e180:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113e184:	e0bff717 	ldw	r2,-36(fp)
8113e188:	10800d03 	ldbu	r2,52(r2)
8113e18c:	10803fcc 	andi	r2,r2,255
8113e190:	00c00044 	movi	r3,1
8113e194:	1884983a 	sll	r2,r3,r2
8113e198:	1007883a 	mov	r3,r2
8113e19c:	e0bff717 	ldw	r2,-36(fp)
8113e1a0:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113e1a4:	e0bff717 	ldw	r2,-36(fp)
8113e1a8:	10800cc3 	ldbu	r2,51(r2)
8113e1ac:	10803fcc 	andi	r2,r2,255
8113e1b0:	00c00044 	movi	r3,1
8113e1b4:	1884983a 	sll	r2,r3,r2
8113e1b8:	1007883a 	mov	r3,r2
8113e1bc:	e0bff717 	ldw	r2,-36(fp)
8113e1c0:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113e1c4:	e0bff003 	ldbu	r2,-64(fp)
8113e1c8:	10800058 	cmpnei	r2,r2,1
8113e1cc:	1000161e 	bne	r2,zero,8113e228 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113e1d0:	e0bff717 	ldw	r2,-36(fp)
8113e1d4:	10c00d83 	ldbu	r3,54(r2)
8113e1d8:	d0a09e03 	ldbu	r2,-32136(gp)
8113e1dc:	1884b03a 	or	r2,r3,r2
8113e1e0:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e1e4:	e0bff717 	ldw	r2,-36(fp)
8113e1e8:	10800d03 	ldbu	r2,52(r2)
8113e1ec:	10c03fcc 	andi	r3,r2,255
8113e1f0:	e0bff717 	ldw	r2,-36(fp)
8113e1f4:	10800d03 	ldbu	r2,52(r2)
8113e1f8:	11003fcc 	andi	r4,r2,255
8113e1fc:	d0a09e44 	addi	r2,gp,-32135
8113e200:	2085883a 	add	r2,r4,r2
8113e204:	11000003 	ldbu	r4,0(r2)
8113e208:	e0bff717 	ldw	r2,-36(fp)
8113e20c:	10800d43 	ldbu	r2,53(r2)
8113e210:	2084b03a 	or	r2,r4,r2
8113e214:	1009883a 	mov	r4,r2
8113e218:	d0a09e44 	addi	r2,gp,-32135
8113e21c:	1885883a 	add	r2,r3,r2
8113e220:	11000005 	stb	r4,0(r2)
8113e224:	00001f06 	br	8113e2a4 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113e228:	e0bff717 	ldw	r2,-36(fp)
8113e22c:	10800717 	ldw	r2,28(r2)
8113e230:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113e234:	e0bff917 	ldw	r2,-28(fp)
8113e238:	10001a26 	beq	r2,zero,8113e2a4 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113e23c:	e0bff917 	ldw	r2,-28(fp)
8113e240:	10c00283 	ldbu	r3,10(r2)
8113e244:	e0bff717 	ldw	r2,-36(fp)
8113e248:	10800d83 	ldbu	r2,54(r2)
8113e24c:	1884b03a 	or	r2,r3,r2
8113e250:	1007883a 	mov	r3,r2
8113e254:	e0bff917 	ldw	r2,-28(fp)
8113e258:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e25c:	e0bff717 	ldw	r2,-36(fp)
8113e260:	10800d03 	ldbu	r2,52(r2)
8113e264:	10803fcc 	andi	r2,r2,255
8113e268:	e0fff717 	ldw	r3,-36(fp)
8113e26c:	18c00d03 	ldbu	r3,52(r3)
8113e270:	18c03fcc 	andi	r3,r3,255
8113e274:	e13ff917 	ldw	r4,-28(fp)
8113e278:	20c7883a 	add	r3,r4,r3
8113e27c:	18c002c4 	addi	r3,r3,11
8113e280:	19000003 	ldbu	r4,0(r3)
8113e284:	e0fff717 	ldw	r3,-36(fp)
8113e288:	18c00d43 	ldbu	r3,53(r3)
8113e28c:	20c6b03a 	or	r3,r4,r3
8113e290:	1809883a 	mov	r4,r3
8113e294:	e0fff917 	ldw	r3,-28(fp)
8113e298:	1885883a 	add	r2,r3,r2
8113e29c:	108002c4 	addi	r2,r2,11
8113e2a0:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113e2a4:	e0fff303 	ldbu	r3,-52(fp)
8113e2a8:	00a045f4 	movhi	r2,33047
8113e2ac:	10b81c04 	addi	r2,r2,-8080
8113e2b0:	18c7883a 	add	r3,r3,r3
8113e2b4:	18c7883a 	add	r3,r3,r3
8113e2b8:	10c5883a 	add	r2,r2,r3
8113e2bc:	e0fff717 	ldw	r3,-36(fp)
8113e2c0:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113e2c4:	d0a0a217 	ldw	r2,-32120(gp)
8113e2c8:	d0e0a217 	ldw	r3,-32120(gp)
8113e2cc:	18c00c03 	ldbu	r3,48(r3)
8113e2d0:	18c00414 	ori	r3,r3,16
8113e2d4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113e2d8:	d0a0a217 	ldw	r2,-32120(gp)
8113e2dc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113e2e0:	d0a0a217 	ldw	r2,-32120(gp)
8113e2e4:	e0fffe0b 	ldhu	r3,-8(fp)
8113e2e8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113e2ec:	e13ffd17 	ldw	r4,-12(fp)
8113e2f0:	113a6680 	call	8113a668 <OS_EventTaskWait>
8113e2f4:	e0bff117 	ldw	r2,-60(fp)
8113e2f8:	e0bffb15 	stw	r2,-20(fp)
8113e2fc:	e0bffb17 	ldw	r2,-20(fp)
8113e300:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113e304:	113af840 	call	8113af84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e308:	0005303a 	rdctl	r2,status
8113e30c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e310:	e0fff517 	ldw	r3,-44(fp)
8113e314:	00bfff84 	movi	r2,-2
8113e318:	1884703a 	and	r2,r3,r2
8113e31c:	1001703a 	wrctl	status,r2
  
  return context;
8113e320:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113e324:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113e328:	d0a0a217 	ldw	r2,-32120(gp)
8113e32c:	10800c43 	ldbu	r2,49(r2)
8113e330:	10803fcc 	andi	r2,r2,255
8113e334:	10000326 	beq	r2,zero,8113e344 <OSMutexPend+0x51c>
8113e338:	108000a0 	cmpeqi	r2,r2,2
8113e33c:	1000041e 	bne	r2,zero,8113e350 <OSMutexPend+0x528>
8113e340:	00000706 	br	8113e360 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113e344:	e0bfff17 	ldw	r2,-4(fp)
8113e348:	10000005 	stb	zero,0(r2)
             break;
8113e34c:	00000c06 	br	8113e380 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113e350:	e0bfff17 	ldw	r2,-4(fp)
8113e354:	00c00384 	movi	r3,14
8113e358:	10c00005 	stb	r3,0(r2)
             break;
8113e35c:	00000806 	br	8113e380 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113e360:	d0a0a217 	ldw	r2,-32120(gp)
8113e364:	e17ffd17 	ldw	r5,-12(fp)
8113e368:	1009883a 	mov	r4,r2
8113e36c:	113a8d80 	call	8113a8d8 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113e370:	e0bfff17 	ldw	r2,-4(fp)
8113e374:	00c00284 	movi	r3,10
8113e378:	10c00005 	stb	r3,0(r2)
             break;
8113e37c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113e380:	d0a0a217 	ldw	r2,-32120(gp)
8113e384:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113e388:	d0a0a217 	ldw	r2,-32120(gp)
8113e38c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113e390:	d0a0a217 	ldw	r2,-32120(gp)
8113e394:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113e398:	d0a0a217 	ldw	r2,-32120(gp)
8113e39c:	10000815 	stw	zero,32(r2)
8113e3a0:	e0bff117 	ldw	r2,-60(fp)
8113e3a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e3a8:	e0bffa17 	ldw	r2,-24(fp)
8113e3ac:	1001703a 	wrctl	status,r2
8113e3b0:	00000106 	br	8113e3b8 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113e3b4:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113e3b8:	e037883a 	mov	sp,fp
8113e3bc:	dfc00117 	ldw	ra,4(sp)
8113e3c0:	df000017 	ldw	fp,0(sp)
8113e3c4:	dec00204 	addi	sp,sp,8
8113e3c8:	f800283a 	ret

8113e3cc <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113e3cc:	defff604 	addi	sp,sp,-40
8113e3d0:	de00012e 	bgeu	sp,et,8113e3d8 <OSMutexPost+0xc>
8113e3d4:	003b68fa 	trap	3
8113e3d8:	dfc00915 	stw	ra,36(sp)
8113e3dc:	df000815 	stw	fp,32(sp)
8113e3e0:	df000804 	addi	fp,sp,32
8113e3e4:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e3e8:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113e3ec:	d0a0a103 	ldbu	r2,-32124(gp)
8113e3f0:	10803fcc 	andi	r2,r2,255
8113e3f4:	10000226 	beq	r2,zero,8113e400 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113e3f8:	00800144 	movi	r2,5
8113e3fc:	00007606 	br	8113e5d8 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e400:	e0bfff17 	ldw	r2,-4(fp)
8113e404:	1000021e 	bne	r2,zero,8113e410 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113e408:	00800104 	movi	r2,4
8113e40c:	00007206 	br	8113e5d8 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113e410:	e0bfff17 	ldw	r2,-4(fp)
8113e414:	10800003 	ldbu	r2,0(r2)
8113e418:	10803fcc 	andi	r2,r2,255
8113e41c:	10800120 	cmpeqi	r2,r2,4
8113e420:	1000021e 	bne	r2,zero,8113e42c <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113e424:	00800044 	movi	r2,1
8113e428:	00006b06 	br	8113e5d8 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e42c:	0005303a 	rdctl	r2,status
8113e430:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e434:	e0fffe17 	ldw	r3,-8(fp)
8113e438:	00bfff84 	movi	r2,-2
8113e43c:	1884703a 	and	r2,r3,r2
8113e440:	1001703a 	wrctl	status,r2
  
  return context;
8113e444:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e448:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113e44c:	e0bfff17 	ldw	r2,-4(fp)
8113e450:	1080020b 	ldhu	r2,8(r2)
8113e454:	10bfffcc 	andi	r2,r2,65535
8113e458:	1004d23a 	srli	r2,r2,8
8113e45c:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113e460:	e0bfff17 	ldw	r2,-4(fp)
8113e464:	1080020b 	ldhu	r2,8(r2)
8113e468:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113e46c:	e0bfff17 	ldw	r2,-4(fp)
8113e470:	10c00117 	ldw	r3,4(r2)
8113e474:	d0a0a217 	ldw	r2,-32120(gp)
8113e478:	18800626 	beq	r3,r2,8113e494 <OSMutexPost+0xc8>
8113e47c:	e0bff817 	ldw	r2,-32(fp)
8113e480:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e484:	e0bff917 	ldw	r2,-28(fp)
8113e488:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113e48c:	00801904 	movi	r2,100
8113e490:	00005106 	br	8113e5d8 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113e494:	d0a0a217 	ldw	r2,-32120(gp)
8113e498:	10800c83 	ldbu	r2,50(r2)
8113e49c:	10c03fcc 	andi	r3,r2,255
8113e4a0:	e0bffa03 	ldbu	r2,-24(fp)
8113e4a4:	1880051e 	bne	r3,r2,8113e4bc <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113e4a8:	d0a0a217 	ldw	r2,-32120(gp)
8113e4ac:	e0fffa43 	ldbu	r3,-23(fp)
8113e4b0:	180b883a 	mov	r5,r3
8113e4b4:	1009883a 	mov	r4,r2
8113e4b8:	113e7600 	call	8113e760 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113e4bc:	e0fffa03 	ldbu	r3,-24(fp)
8113e4c0:	00a045f4 	movhi	r2,33047
8113e4c4:	10b81c04 	addi	r2,r2,-8080
8113e4c8:	18c7883a 	add	r3,r3,r3
8113e4cc:	18c7883a 	add	r3,r3,r3
8113e4d0:	10c5883a 	add	r2,r2,r3
8113e4d4:	00c00044 	movi	r3,1
8113e4d8:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113e4dc:	e0bfff17 	ldw	r2,-4(fp)
8113e4e0:	10800283 	ldbu	r2,10(r2)
8113e4e4:	10803fcc 	andi	r2,r2,255
8113e4e8:	10002e26 	beq	r2,zero,8113e5a4 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113e4ec:	000f883a 	mov	r7,zero
8113e4f0:	01800404 	movi	r6,16
8113e4f4:	000b883a 	mov	r5,zero
8113e4f8:	e13fff17 	ldw	r4,-4(fp)
8113e4fc:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
8113e500:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113e504:	e0bfff17 	ldw	r2,-4(fp)
8113e508:	10c0020b 	ldhu	r3,8(r2)
8113e50c:	00bfc004 	movi	r2,-256
8113e510:	1884703a 	and	r2,r3,r2
8113e514:	1007883a 	mov	r3,r2
8113e518:	e0bfff17 	ldw	r2,-4(fp)
8113e51c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113e520:	e0bfff17 	ldw	r2,-4(fp)
8113e524:	10c0020b 	ldhu	r3,8(r2)
8113e528:	e0bffa43 	ldbu	r2,-23(fp)
8113e52c:	1884b03a 	or	r2,r3,r2
8113e530:	1007883a 	mov	r3,r2
8113e534:	e0bfff17 	ldw	r2,-4(fp)
8113e538:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113e53c:	e0fffa43 	ldbu	r3,-23(fp)
8113e540:	00a045f4 	movhi	r2,33047
8113e544:	10b81c04 	addi	r2,r2,-8080
8113e548:	18c7883a 	add	r3,r3,r3
8113e54c:	18c7883a 	add	r3,r3,r3
8113e550:	10c5883a 	add	r2,r2,r3
8113e554:	10c00017 	ldw	r3,0(r2)
8113e558:	e0bfff17 	ldw	r2,-4(fp)
8113e55c:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113e560:	e0bffa43 	ldbu	r2,-23(fp)
8113e564:	e0fffa03 	ldbu	r3,-24(fp)
8113e568:	18800736 	bltu	r3,r2,8113e588 <OSMutexPost+0x1bc>
8113e56c:	e0bff817 	ldw	r2,-32(fp)
8113e570:	e0bffb15 	stw	r2,-20(fp)
8113e574:	e0bffb17 	ldw	r2,-20(fp)
8113e578:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113e57c:	113af840 	call	8113af84 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113e580:	00801e04 	movi	r2,120
8113e584:	00001406 	br	8113e5d8 <OSMutexPost+0x20c>
8113e588:	e0bff817 	ldw	r2,-32(fp)
8113e58c:	e0bffc15 	stw	r2,-16(fp)
8113e590:	e0bffc17 	ldw	r2,-16(fp)
8113e594:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113e598:	113af840 	call	8113af84 <OS_Sched>
            return (OS_ERR_NONE);
8113e59c:	0005883a 	mov	r2,zero
8113e5a0:	00000d06 	br	8113e5d8 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113e5a4:	e0bfff17 	ldw	r2,-4(fp)
8113e5a8:	1080020b 	ldhu	r2,8(r2)
8113e5ac:	10803fd4 	ori	r2,r2,255
8113e5b0:	1007883a 	mov	r3,r2
8113e5b4:	e0bfff17 	ldw	r2,-4(fp)
8113e5b8:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113e5bc:	e0bfff17 	ldw	r2,-4(fp)
8113e5c0:	10000115 	stw	zero,4(r2)
8113e5c4:	e0bff817 	ldw	r2,-32(fp)
8113e5c8:	e0bffd15 	stw	r2,-12(fp)
8113e5cc:	e0bffd17 	ldw	r2,-12(fp)
8113e5d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e5d4:	0005883a 	mov	r2,zero
}
8113e5d8:	e037883a 	mov	sp,fp
8113e5dc:	dfc00117 	ldw	ra,4(sp)
8113e5e0:	df000017 	ldw	fp,0(sp)
8113e5e4:	dec00204 	addi	sp,sp,8
8113e5e8:	f800283a 	ret

8113e5ec <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113e5ec:	defff704 	addi	sp,sp,-36
8113e5f0:	de00012e 	bgeu	sp,et,8113e5f8 <OSMutexQuery+0xc>
8113e5f4:	003b68fa 	trap	3
8113e5f8:	df000815 	stw	fp,32(sp)
8113e5fc:	df000804 	addi	fp,sp,32
8113e600:	e13ffe15 	stw	r4,-8(fp)
8113e604:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e608:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e60c:	d0a0a103 	ldbu	r2,-32124(gp)
8113e610:	10803fcc 	andi	r2,r2,255
8113e614:	10000226 	beq	r2,zero,8113e620 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113e618:	00800184 	movi	r2,6
8113e61c:	00004c06 	br	8113e750 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e620:	e0bffe17 	ldw	r2,-8(fp)
8113e624:	1000021e 	bne	r2,zero,8113e630 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113e628:	00800104 	movi	r2,4
8113e62c:	00004806 	br	8113e750 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113e630:	e0bfff17 	ldw	r2,-4(fp)
8113e634:	1000021e 	bne	r2,zero,8113e640 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113e638:	00800244 	movi	r2,9
8113e63c:	00004406 	br	8113e750 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113e640:	e0bffe17 	ldw	r2,-8(fp)
8113e644:	10800003 	ldbu	r2,0(r2)
8113e648:	10803fcc 	andi	r2,r2,255
8113e64c:	10800120 	cmpeqi	r2,r2,4
8113e650:	1000021e 	bne	r2,zero,8113e65c <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113e654:	00800044 	movi	r2,1
8113e658:	00003d06 	br	8113e750 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e65c:	0005303a 	rdctl	r2,status
8113e660:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e664:	e0fffd17 	ldw	r3,-12(fp)
8113e668:	00bfff84 	movi	r2,-2
8113e66c:	1884703a 	and	r2,r3,r2
8113e670:	1001703a 	wrctl	status,r2
  
  return context;
8113e674:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e678:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113e67c:	e0bffe17 	ldw	r2,-8(fp)
8113e680:	1080020b 	ldhu	r2,8(r2)
8113e684:	10bfffcc 	andi	r2,r2,65535
8113e688:	1004d23a 	srli	r2,r2,8
8113e68c:	1007883a 	mov	r3,r2
8113e690:	e0bfff17 	ldw	r2,-4(fp)
8113e694:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113e698:	e0bffe17 	ldw	r2,-8(fp)
8113e69c:	1080020b 	ldhu	r2,8(r2)
8113e6a0:	1007883a 	mov	r3,r2
8113e6a4:	e0bfff17 	ldw	r2,-4(fp)
8113e6a8:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113e6ac:	e0bfff17 	ldw	r2,-4(fp)
8113e6b0:	10800203 	ldbu	r2,8(r2)
8113e6b4:	10803fcc 	andi	r2,r2,255
8113e6b8:	10803fd8 	cmpnei	r2,r2,255
8113e6bc:	1000041e 	bne	r2,zero,8113e6d0 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113e6c0:	e0bfff17 	ldw	r2,-4(fp)
8113e6c4:	00c00044 	movi	r3,1
8113e6c8:	10c001c5 	stb	r3,7(r2)
8113e6cc:	00000206 	br	8113e6d8 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113e6d0:	e0bfff17 	ldw	r2,-4(fp)
8113e6d4:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113e6d8:	e0bffe17 	ldw	r2,-8(fp)
8113e6dc:	10c00283 	ldbu	r3,10(r2)
8113e6e0:	e0bfff17 	ldw	r2,-4(fp)
8113e6e4:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113e6e8:	e0bffe17 	ldw	r2,-8(fp)
8113e6ec:	108002c4 	addi	r2,r2,11
8113e6f0:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113e6f4:	e0bfff17 	ldw	r2,-4(fp)
8113e6f8:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e6fc:	e03ff805 	stb	zero,-32(fp)
8113e700:	00000b06 	br	8113e730 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113e704:	e0bffa17 	ldw	r2,-24(fp)
8113e708:	10c00044 	addi	r3,r2,1
8113e70c:	e0fffa15 	stw	r3,-24(fp)
8113e710:	e0fff917 	ldw	r3,-28(fp)
8113e714:	19000044 	addi	r4,r3,1
8113e718:	e13ff915 	stw	r4,-28(fp)
8113e71c:	18c00003 	ldbu	r3,0(r3)
8113e720:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e724:	e0bff803 	ldbu	r2,-32(fp)
8113e728:	10800044 	addi	r2,r2,1
8113e72c:	e0bff805 	stb	r2,-32(fp)
8113e730:	e0bff803 	ldbu	r2,-32(fp)
8113e734:	108001b0 	cmpltui	r2,r2,6
8113e738:	103ff21e 	bne	r2,zero,8113e704 <__reset+0xfb11e704>
8113e73c:	e0bffb17 	ldw	r2,-20(fp)
8113e740:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e744:	e0bffc17 	ldw	r2,-16(fp)
8113e748:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e74c:	0005883a 	mov	r2,zero
}
8113e750:	e037883a 	mov	sp,fp
8113e754:	df000017 	ldw	fp,0(sp)
8113e758:	dec00104 	addi	sp,sp,4
8113e75c:	f800283a 	ret

8113e760 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113e760:	defffc04 	addi	sp,sp,-16
8113e764:	de00012e 	bgeu	sp,et,8113e76c <OSMutex_RdyAtPrio+0xc>
8113e768:	003b68fa 	trap	3
8113e76c:	df000315 	stw	fp,12(sp)
8113e770:	df000304 	addi	fp,sp,12
8113e774:	e13ffe15 	stw	r4,-8(fp)
8113e778:	2805883a 	mov	r2,r5
8113e77c:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113e780:	e0bffe17 	ldw	r2,-8(fp)
8113e784:	10800d03 	ldbu	r2,52(r2)
8113e788:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113e78c:	e0fffd03 	ldbu	r3,-12(fp)
8113e790:	e13ffd03 	ldbu	r4,-12(fp)
8113e794:	d0a09e44 	addi	r2,gp,-32135
8113e798:	2085883a 	add	r2,r4,r2
8113e79c:	10800003 	ldbu	r2,0(r2)
8113e7a0:	1009883a 	mov	r4,r2
8113e7a4:	e0bffe17 	ldw	r2,-8(fp)
8113e7a8:	10800d43 	ldbu	r2,53(r2)
8113e7ac:	0084303a 	nor	r2,zero,r2
8113e7b0:	2084703a 	and	r2,r4,r2
8113e7b4:	1009883a 	mov	r4,r2
8113e7b8:	d0a09e44 	addi	r2,gp,-32135
8113e7bc:	1885883a 	add	r2,r3,r2
8113e7c0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113e7c4:	e0fffd03 	ldbu	r3,-12(fp)
8113e7c8:	d0a09e44 	addi	r2,gp,-32135
8113e7cc:	1885883a 	add	r2,r3,r2
8113e7d0:	10800003 	ldbu	r2,0(r2)
8113e7d4:	10803fcc 	andi	r2,r2,255
8113e7d8:	1000071e 	bne	r2,zero,8113e7f8 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113e7dc:	e0bffe17 	ldw	r2,-8(fp)
8113e7e0:	10800d83 	ldbu	r2,54(r2)
8113e7e4:	0084303a 	nor	r2,zero,r2
8113e7e8:	1007883a 	mov	r3,r2
8113e7ec:	d0a09e03 	ldbu	r2,-32136(gp)
8113e7f0:	1884703a 	and	r2,r3,r2
8113e7f4:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113e7f8:	e0bffe17 	ldw	r2,-8(fp)
8113e7fc:	e0ffff03 	ldbu	r3,-4(fp)
8113e800:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113e804:	e0bfff03 	ldbu	r2,-4(fp)
8113e808:	1004d0fa 	srli	r2,r2,3
8113e80c:	108001cc 	andi	r2,r2,7
8113e810:	1007883a 	mov	r3,r2
8113e814:	e0bffe17 	ldw	r2,-8(fp)
8113e818:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113e81c:	e0bfff03 	ldbu	r2,-4(fp)
8113e820:	108001cc 	andi	r2,r2,7
8113e824:	1007883a 	mov	r3,r2
8113e828:	e0bffe17 	ldw	r2,-8(fp)
8113e82c:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113e830:	e0bffe17 	ldw	r2,-8(fp)
8113e834:	10800d03 	ldbu	r2,52(r2)
8113e838:	10803fcc 	andi	r2,r2,255
8113e83c:	00c00044 	movi	r3,1
8113e840:	1884983a 	sll	r2,r3,r2
8113e844:	1007883a 	mov	r3,r2
8113e848:	e0bffe17 	ldw	r2,-8(fp)
8113e84c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113e850:	e0bffe17 	ldw	r2,-8(fp)
8113e854:	10800cc3 	ldbu	r2,51(r2)
8113e858:	10803fcc 	andi	r2,r2,255
8113e85c:	00c00044 	movi	r3,1
8113e860:	1884983a 	sll	r2,r3,r2
8113e864:	1007883a 	mov	r3,r2
8113e868:	e0bffe17 	ldw	r2,-8(fp)
8113e86c:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113e870:	e0bffe17 	ldw	r2,-8(fp)
8113e874:	10c00d83 	ldbu	r3,54(r2)
8113e878:	d0a09e03 	ldbu	r2,-32136(gp)
8113e87c:	1884b03a 	or	r2,r3,r2
8113e880:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e884:	e0bffe17 	ldw	r2,-8(fp)
8113e888:	10800d03 	ldbu	r2,52(r2)
8113e88c:	10c03fcc 	andi	r3,r2,255
8113e890:	e0bffe17 	ldw	r2,-8(fp)
8113e894:	10800d03 	ldbu	r2,52(r2)
8113e898:	11003fcc 	andi	r4,r2,255
8113e89c:	d0a09e44 	addi	r2,gp,-32135
8113e8a0:	2085883a 	add	r2,r4,r2
8113e8a4:	11000003 	ldbu	r4,0(r2)
8113e8a8:	e0bffe17 	ldw	r2,-8(fp)
8113e8ac:	10800d43 	ldbu	r2,53(r2)
8113e8b0:	2084b03a 	or	r2,r4,r2
8113e8b4:	1009883a 	mov	r4,r2
8113e8b8:	d0a09e44 	addi	r2,gp,-32135
8113e8bc:	1885883a 	add	r2,r3,r2
8113e8c0:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113e8c4:	e0ffff03 	ldbu	r3,-4(fp)
8113e8c8:	00a045f4 	movhi	r2,33047
8113e8cc:	10b81c04 	addi	r2,r2,-8080
8113e8d0:	18c7883a 	add	r3,r3,r3
8113e8d4:	18c7883a 	add	r3,r3,r3
8113e8d8:	10c5883a 	add	r2,r2,r3
8113e8dc:	e0fffe17 	ldw	r3,-8(fp)
8113e8e0:	10c00015 	stw	r3,0(r2)
}
8113e8e4:	0001883a 	nop
8113e8e8:	e037883a 	mov	sp,fp
8113e8ec:	df000017 	ldw	fp,0(sp)
8113e8f0:	dec00104 	addi	sp,sp,4
8113e8f4:	f800283a 	ret

8113e8f8 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113e8f8:	defff804 	addi	sp,sp,-32
8113e8fc:	de00012e 	bgeu	sp,et,8113e904 <OSQAccept+0xc>
8113e900:	003b68fa 	trap	3
8113e904:	df000715 	stw	fp,28(sp)
8113e908:	df000704 	addi	fp,sp,28
8113e90c:	e13ffe15 	stw	r4,-8(fp)
8113e910:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e914:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113e918:	e0bfff17 	ldw	r2,-4(fp)
8113e91c:	1000021e 	bne	r2,zero,8113e928 <OSQAccept+0x30>
        return ((void *)0);
8113e920:	0005883a 	mov	r2,zero
8113e924:	00004206 	br	8113ea30 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113e928:	e0bffe17 	ldw	r2,-8(fp)
8113e92c:	1000051e 	bne	r2,zero,8113e944 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e930:	e0bfff17 	ldw	r2,-4(fp)
8113e934:	00c00104 	movi	r3,4
8113e938:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113e93c:	0005883a 	mov	r2,zero
8113e940:	00003b06 	br	8113ea30 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113e944:	e0bffe17 	ldw	r2,-8(fp)
8113e948:	10800003 	ldbu	r2,0(r2)
8113e94c:	10803fcc 	andi	r2,r2,255
8113e950:	108000a0 	cmpeqi	r2,r2,2
8113e954:	1000051e 	bne	r2,zero,8113e96c <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113e958:	e0bfff17 	ldw	r2,-4(fp)
8113e95c:	00c00044 	movi	r3,1
8113e960:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113e964:	0005883a 	mov	r2,zero
8113e968:	00003106 	br	8113ea30 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e96c:	0005303a 	rdctl	r2,status
8113e970:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e974:	e0fffd17 	ldw	r3,-12(fp)
8113e978:	00bfff84 	movi	r2,-2
8113e97c:	1884703a 	and	r2,r3,r2
8113e980:	1001703a 	wrctl	status,r2
  
  return context;
8113e984:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e988:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113e98c:	e0bffe17 	ldw	r2,-8(fp)
8113e990:	10800117 	ldw	r2,4(r2)
8113e994:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113e998:	e0bffc17 	ldw	r2,-16(fp)
8113e99c:	1080058b 	ldhu	r2,22(r2)
8113e9a0:	10bfffcc 	andi	r2,r2,65535
8113e9a4:	10001926 	beq	r2,zero,8113ea0c <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113e9a8:	e0bffc17 	ldw	r2,-16(fp)
8113e9ac:	10800417 	ldw	r2,16(r2)
8113e9b0:	11000104 	addi	r4,r2,4
8113e9b4:	e0fffc17 	ldw	r3,-16(fp)
8113e9b8:	19000415 	stw	r4,16(r3)
8113e9bc:	10800017 	ldw	r2,0(r2)
8113e9c0:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113e9c4:	e0bffc17 	ldw	r2,-16(fp)
8113e9c8:	1080058b 	ldhu	r2,22(r2)
8113e9cc:	10bfffc4 	addi	r2,r2,-1
8113e9d0:	1007883a 	mov	r3,r2
8113e9d4:	e0bffc17 	ldw	r2,-16(fp)
8113e9d8:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113e9dc:	e0bffc17 	ldw	r2,-16(fp)
8113e9e0:	10c00417 	ldw	r3,16(r2)
8113e9e4:	e0bffc17 	ldw	r2,-16(fp)
8113e9e8:	10800217 	ldw	r2,8(r2)
8113e9ec:	1880041e 	bne	r3,r2,8113ea00 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113e9f0:	e0bffc17 	ldw	r2,-16(fp)
8113e9f4:	10c00117 	ldw	r3,4(r2)
8113e9f8:	e0bffc17 	ldw	r2,-16(fp)
8113e9fc:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113ea00:	e0bfff17 	ldw	r2,-4(fp)
8113ea04:	10000005 	stb	zero,0(r2)
8113ea08:	00000406 	br	8113ea1c <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113ea0c:	e0bfff17 	ldw	r2,-4(fp)
8113ea10:	00c007c4 	movi	r3,31
8113ea14:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113ea18:	e03ff915 	stw	zero,-28(fp)
8113ea1c:	e0bffa17 	ldw	r2,-24(fp)
8113ea20:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea24:	e0bffb17 	ldw	r2,-20(fp)
8113ea28:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113ea2c:	e0bff917 	ldw	r2,-28(fp)
}
8113ea30:	e037883a 	mov	sp,fp
8113ea34:	df000017 	ldw	fp,0(sp)
8113ea38:	dec00104 	addi	sp,sp,4
8113ea3c:	f800283a 	ret

8113ea40 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113ea40:	defff404 	addi	sp,sp,-48
8113ea44:	de00012e 	bgeu	sp,et,8113ea4c <OSQCreate+0xc>
8113ea48:	003b68fa 	trap	3
8113ea4c:	dfc00b15 	stw	ra,44(sp)
8113ea50:	df000a15 	stw	fp,40(sp)
8113ea54:	df000a04 	addi	fp,sp,40
8113ea58:	e13ffe15 	stw	r4,-8(fp)
8113ea5c:	2805883a 	mov	r2,r5
8113ea60:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ea64:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113ea68:	d0a0a103 	ldbu	r2,-32124(gp)
8113ea6c:	10803fcc 	andi	r2,r2,255
8113ea70:	10000226 	beq	r2,zero,8113ea7c <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113ea74:	0005883a 	mov	r2,zero
8113ea78:	00005906 	br	8113ebe0 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ea7c:	0005303a 	rdctl	r2,status
8113ea80:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ea84:	e0fffd17 	ldw	r3,-12(fp)
8113ea88:	00bfff84 	movi	r2,-2
8113ea8c:	1884703a 	and	r2,r3,r2
8113ea90:	1001703a 	wrctl	status,r2
  
  return context;
8113ea94:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113ea98:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113ea9c:	d0a0a017 	ldw	r2,-32128(gp)
8113eaa0:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113eaa4:	d0a0a017 	ldw	r2,-32128(gp)
8113eaa8:	10000326 	beq	r2,zero,8113eab8 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113eaac:	d0a0a017 	ldw	r2,-32128(gp)
8113eab0:	10800117 	ldw	r2,4(r2)
8113eab4:	d0a0a015 	stw	r2,-32128(gp)
8113eab8:	e0bff717 	ldw	r2,-36(fp)
8113eabc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eac0:	e0bff817 	ldw	r2,-32(fp)
8113eac4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113eac8:	e0bff617 	ldw	r2,-40(fp)
8113eacc:	10004326 	beq	r2,zero,8113ebdc <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ead0:	0005303a 	rdctl	r2,status
8113ead4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ead8:	e0fff917 	ldw	r3,-28(fp)
8113eadc:	00bfff84 	movi	r2,-2
8113eae0:	1884703a 	and	r2,r3,r2
8113eae4:	1001703a 	wrctl	status,r2
  
  return context;
8113eae8:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113eaec:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113eaf0:	d0a09d17 	ldw	r2,-32140(gp)
8113eaf4:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113eaf8:	e0bffb17 	ldw	r2,-20(fp)
8113eafc:	10002d26 	beq	r2,zero,8113ebb4 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113eb00:	d0a09d17 	ldw	r2,-32140(gp)
8113eb04:	10800017 	ldw	r2,0(r2)
8113eb08:	d0a09d15 	stw	r2,-32140(gp)
8113eb0c:	e0bff717 	ldw	r2,-36(fp)
8113eb10:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eb14:	e0bffa17 	ldw	r2,-24(fp)
8113eb18:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113eb1c:	e0bffb17 	ldw	r2,-20(fp)
8113eb20:	e0fffe17 	ldw	r3,-8(fp)
8113eb24:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113eb28:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb2c:	1085883a 	add	r2,r2,r2
8113eb30:	1085883a 	add	r2,r2,r2
8113eb34:	1007883a 	mov	r3,r2
8113eb38:	e0bffe17 	ldw	r2,-8(fp)
8113eb3c:	10c7883a 	add	r3,r2,r3
8113eb40:	e0bffb17 	ldw	r2,-20(fp)
8113eb44:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113eb48:	e0bffb17 	ldw	r2,-20(fp)
8113eb4c:	e0fffe17 	ldw	r3,-8(fp)
8113eb50:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113eb54:	e0bffb17 	ldw	r2,-20(fp)
8113eb58:	e0fffe17 	ldw	r3,-8(fp)
8113eb5c:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113eb60:	e0bffb17 	ldw	r2,-20(fp)
8113eb64:	e0ffff0b 	ldhu	r3,-4(fp)
8113eb68:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113eb6c:	e0bffb17 	ldw	r2,-20(fp)
8113eb70:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113eb74:	e0bff617 	ldw	r2,-40(fp)
8113eb78:	00c00084 	movi	r3,2
8113eb7c:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113eb80:	e0bff617 	ldw	r2,-40(fp)
8113eb84:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113eb88:	e0bff617 	ldw	r2,-40(fp)
8113eb8c:	e0fffb17 	ldw	r3,-20(fp)
8113eb90:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113eb94:	e0bff617 	ldw	r2,-40(fp)
8113eb98:	00c00fc4 	movi	r3,63
8113eb9c:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113eba0:	e0bff617 	ldw	r2,-40(fp)
8113eba4:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113eba8:	e13ff617 	ldw	r4,-40(fp)
8113ebac:	113aaa00 	call	8113aaa0 <OS_EventWaitListInit>
8113ebb0:	00000a06 	br	8113ebdc <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113ebb4:	d0e0a017 	ldw	r3,-32128(gp)
8113ebb8:	e0bff617 	ldw	r2,-40(fp)
8113ebbc:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113ebc0:	e0bff617 	ldw	r2,-40(fp)
8113ebc4:	d0a0a015 	stw	r2,-32128(gp)
8113ebc8:	e0bff717 	ldw	r2,-36(fp)
8113ebcc:	e0bffc15 	stw	r2,-16(fp)
8113ebd0:	e0bffc17 	ldw	r2,-16(fp)
8113ebd4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113ebd8:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113ebdc:	e0bff617 	ldw	r2,-40(fp)
}
8113ebe0:	e037883a 	mov	sp,fp
8113ebe4:	dfc00117 	ldw	ra,4(sp)
8113ebe8:	df000017 	ldw	fp,0(sp)
8113ebec:	dec00204 	addi	sp,sp,8
8113ebf0:	f800283a 	ret

8113ebf4 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113ebf4:	defff204 	addi	sp,sp,-56
8113ebf8:	de00012e 	bgeu	sp,et,8113ec00 <OSQDel+0xc>
8113ebfc:	003b68fa 	trap	3
8113ec00:	dfc00d15 	stw	ra,52(sp)
8113ec04:	df000c15 	stw	fp,48(sp)
8113ec08:	df000c04 	addi	fp,sp,48
8113ec0c:	e13ffd15 	stw	r4,-12(fp)
8113ec10:	2805883a 	mov	r2,r5
8113ec14:	e1bfff15 	stw	r6,-4(fp)
8113ec18:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113ec1c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113ec20:	e0bfff17 	ldw	r2,-4(fp)
8113ec24:	1000021e 	bne	r2,zero,8113ec30 <OSQDel+0x3c>
        return (pevent);
8113ec28:	e0bffd17 	ldw	r2,-12(fp)
8113ec2c:	00008e06 	br	8113ee68 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ec30:	e0bffd17 	ldw	r2,-12(fp)
8113ec34:	1000051e 	bne	r2,zero,8113ec4c <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ec38:	e0bfff17 	ldw	r2,-4(fp)
8113ec3c:	00c00104 	movi	r3,4
8113ec40:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ec44:	e0bffd17 	ldw	r2,-12(fp)
8113ec48:	00008706 	br	8113ee68 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113ec4c:	e0bffd17 	ldw	r2,-12(fp)
8113ec50:	10800003 	ldbu	r2,0(r2)
8113ec54:	10803fcc 	andi	r2,r2,255
8113ec58:	108000a0 	cmpeqi	r2,r2,2
8113ec5c:	1000051e 	bne	r2,zero,8113ec74 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ec60:	e0bfff17 	ldw	r2,-4(fp)
8113ec64:	00c00044 	movi	r3,1
8113ec68:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ec6c:	e0bffd17 	ldw	r2,-12(fp)
8113ec70:	00007d06 	br	8113ee68 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ec74:	d0a0a103 	ldbu	r2,-32124(gp)
8113ec78:	10803fcc 	andi	r2,r2,255
8113ec7c:	10000526 	beq	r2,zero,8113ec94 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113ec80:	e0bfff17 	ldw	r2,-4(fp)
8113ec84:	00c003c4 	movi	r3,15
8113ec88:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ec8c:	e0bffd17 	ldw	r2,-12(fp)
8113ec90:	00007506 	br	8113ee68 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec94:	0005303a 	rdctl	r2,status
8113ec98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec9c:	e0fffc17 	ldw	r3,-16(fp)
8113eca0:	00bfff84 	movi	r2,-2
8113eca4:	1884703a 	and	r2,r3,r2
8113eca8:	1001703a 	wrctl	status,r2
  
  return context;
8113ecac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ecb0:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113ecb4:	e0bffd17 	ldw	r2,-12(fp)
8113ecb8:	10800283 	ldbu	r2,10(r2)
8113ecbc:	10803fcc 	andi	r2,r2,255
8113ecc0:	10000326 	beq	r2,zero,8113ecd0 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113ecc4:	00800044 	movi	r2,1
8113ecc8:	e0bff405 	stb	r2,-48(fp)
8113eccc:	00000106 	br	8113ecd4 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113ecd0:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113ecd4:	e0bffe03 	ldbu	r2,-8(fp)
8113ecd8:	10000326 	beq	r2,zero,8113ece8 <OSQDel+0xf4>
8113ecdc:	10800060 	cmpeqi	r2,r2,1
8113ece0:	1000301e 	bne	r2,zero,8113eda4 <OSQDel+0x1b0>
8113ece4:	00005506 	br	8113ee3c <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113ece8:	e0bff403 	ldbu	r2,-48(fp)
8113ecec:	10001e1e 	bne	r2,zero,8113ed68 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113ecf0:	e0bffd17 	ldw	r2,-12(fp)
8113ecf4:	00c00fc4 	movi	r3,63
8113ecf8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113ecfc:	e0bffd17 	ldw	r2,-12(fp)
8113ed00:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113ed04:	e0bffd17 	ldw	r2,-12(fp)
8113ed08:	10800117 	ldw	r2,4(r2)
8113ed0c:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113ed10:	d0e09d17 	ldw	r3,-32140(gp)
8113ed14:	e0bff817 	ldw	r2,-32(fp)
8113ed18:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113ed1c:	e0bff817 	ldw	r2,-32(fp)
8113ed20:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ed24:	e0bffd17 	ldw	r2,-12(fp)
8113ed28:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113ed2c:	d0e0a017 	ldw	r3,-32128(gp)
8113ed30:	e0bffd17 	ldw	r2,-12(fp)
8113ed34:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113ed38:	e0bffd17 	ldw	r2,-12(fp)
8113ed3c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113ed40:	e0bffd17 	ldw	r2,-12(fp)
8113ed44:	d0a0a015 	stw	r2,-32128(gp)
8113ed48:	e0bff617 	ldw	r2,-40(fp)
8113ed4c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ed50:	e0bff717 	ldw	r2,-36(fp)
8113ed54:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113ed58:	e0bfff17 	ldw	r2,-4(fp)
8113ed5c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113ed60:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113ed64:	00003f06 	br	8113ee64 <OSQDel+0x270>
8113ed68:	e0bff617 	ldw	r2,-40(fp)
8113ed6c:	e0bff915 	stw	r2,-28(fp)
8113ed70:	e0bff917 	ldw	r2,-28(fp)
8113ed74:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113ed78:	e0bfff17 	ldw	r2,-4(fp)
8113ed7c:	00c01244 	movi	r3,73
8113ed80:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113ed84:	e0bffd17 	ldw	r2,-12(fp)
8113ed88:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113ed8c:	00003506 	br	8113ee64 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113ed90:	000f883a 	mov	r7,zero
8113ed94:	01800104 	movi	r6,4
8113ed98:	000b883a 	mov	r5,zero
8113ed9c:	e13ffd17 	ldw	r4,-12(fp)
8113eda0:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113eda4:	e0bffd17 	ldw	r2,-12(fp)
8113eda8:	10800283 	ldbu	r2,10(r2)
8113edac:	10803fcc 	andi	r2,r2,255
8113edb0:	103ff71e 	bne	r2,zero,8113ed90 <__reset+0xfb11ed90>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113edb4:	e0bffd17 	ldw	r2,-12(fp)
8113edb8:	00c00fc4 	movi	r3,63
8113edbc:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113edc0:	e0bffd17 	ldw	r2,-12(fp)
8113edc4:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113edc8:	e0bffd17 	ldw	r2,-12(fp)
8113edcc:	10800117 	ldw	r2,4(r2)
8113edd0:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113edd4:	d0e09d17 	ldw	r3,-32140(gp)
8113edd8:	e0bff817 	ldw	r2,-32(fp)
8113eddc:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113ede0:	e0bff817 	ldw	r2,-32(fp)
8113ede4:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ede8:	e0bffd17 	ldw	r2,-12(fp)
8113edec:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113edf0:	d0e0a017 	ldw	r3,-32128(gp)
8113edf4:	e0bffd17 	ldw	r2,-12(fp)
8113edf8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113edfc:	e0bffd17 	ldw	r2,-12(fp)
8113ee00:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113ee04:	e0bffd17 	ldw	r2,-12(fp)
8113ee08:	d0a0a015 	stw	r2,-32128(gp)
8113ee0c:	e0bff617 	ldw	r2,-40(fp)
8113ee10:	e0bffa15 	stw	r2,-24(fp)
8113ee14:	e0bffa17 	ldw	r2,-24(fp)
8113ee18:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113ee1c:	e0bff403 	ldbu	r2,-48(fp)
8113ee20:	10800058 	cmpnei	r2,r2,1
8113ee24:	1000011e 	bne	r2,zero,8113ee2c <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113ee28:	113af840 	call	8113af84 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113ee2c:	e0bfff17 	ldw	r2,-4(fp)
8113ee30:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113ee34:	e03ff515 	stw	zero,-44(fp)
             break;
8113ee38:	00000a06 	br	8113ee64 <OSQDel+0x270>
8113ee3c:	e0bff617 	ldw	r2,-40(fp)
8113ee40:	e0bffb15 	stw	r2,-20(fp)
8113ee44:	e0bffb17 	ldw	r2,-20(fp)
8113ee48:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113ee4c:	e0bfff17 	ldw	r2,-4(fp)
8113ee50:	00c001c4 	movi	r3,7
8113ee54:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113ee58:	e0bffd17 	ldw	r2,-12(fp)
8113ee5c:	e0bff515 	stw	r2,-44(fp)
             break;
8113ee60:	0001883a 	nop
    }
    return (pevent_return);
8113ee64:	e0bff517 	ldw	r2,-44(fp)
}
8113ee68:	e037883a 	mov	sp,fp
8113ee6c:	dfc00117 	ldw	ra,4(sp)
8113ee70:	df000017 	ldw	fp,0(sp)
8113ee74:	dec00204 	addi	sp,sp,8
8113ee78:	f800283a 	ret

8113ee7c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113ee7c:	defffa04 	addi	sp,sp,-24
8113ee80:	de00012e 	bgeu	sp,et,8113ee88 <OSQFlush+0xc>
8113ee84:	003b68fa 	trap	3
8113ee88:	df000515 	stw	fp,20(sp)
8113ee8c:	df000504 	addi	fp,sp,20
8113ee90:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ee94:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ee98:	e0bfff17 	ldw	r2,-4(fp)
8113ee9c:	1000021e 	bne	r2,zero,8113eea8 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113eea0:	00800104 	movi	r2,4
8113eea4:	00002106 	br	8113ef2c <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113eea8:	e0bfff17 	ldw	r2,-4(fp)
8113eeac:	10800003 	ldbu	r2,0(r2)
8113eeb0:	10803fcc 	andi	r2,r2,255
8113eeb4:	108000a0 	cmpeqi	r2,r2,2
8113eeb8:	1000021e 	bne	r2,zero,8113eec4 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113eebc:	00800044 	movi	r2,1
8113eec0:	00001a06 	br	8113ef2c <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113eec4:	0005303a 	rdctl	r2,status
8113eec8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113eecc:	e0fffd17 	ldw	r3,-12(fp)
8113eed0:	00bfff84 	movi	r2,-2
8113eed4:	1884703a 	and	r2,r3,r2
8113eed8:	1001703a 	wrctl	status,r2
  
  return context;
8113eedc:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113eee0:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113eee4:	e0bfff17 	ldw	r2,-4(fp)
8113eee8:	10800117 	ldw	r2,4(r2)
8113eeec:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113eef0:	e0bffc17 	ldw	r2,-16(fp)
8113eef4:	10c00117 	ldw	r3,4(r2)
8113eef8:	e0bffc17 	ldw	r2,-16(fp)
8113eefc:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113ef00:	e0bffc17 	ldw	r2,-16(fp)
8113ef04:	10c00117 	ldw	r3,4(r2)
8113ef08:	e0bffc17 	ldw	r2,-16(fp)
8113ef0c:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113ef10:	e0bffc17 	ldw	r2,-16(fp)
8113ef14:	1000058d 	sth	zero,22(r2)
8113ef18:	e0bffb17 	ldw	r2,-20(fp)
8113ef1c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ef20:	e0bffe17 	ldw	r2,-8(fp)
8113ef24:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113ef28:	0005883a 	mov	r2,zero
}
8113ef2c:	e037883a 	mov	sp,fp
8113ef30:	df000017 	ldw	fp,0(sp)
8113ef34:	dec00104 	addi	sp,sp,4
8113ef38:	f800283a 	ret

8113ef3c <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113ef3c:	defff304 	addi	sp,sp,-52
8113ef40:	de00012e 	bgeu	sp,et,8113ef48 <OSQPend+0xc>
8113ef44:	003b68fa 	trap	3
8113ef48:	dfc00c15 	stw	ra,48(sp)
8113ef4c:	df000b15 	stw	fp,44(sp)
8113ef50:	df000b04 	addi	fp,sp,44
8113ef54:	e13ffd15 	stw	r4,-12(fp)
8113ef58:	2805883a 	mov	r2,r5
8113ef5c:	e1bfff15 	stw	r6,-4(fp)
8113ef60:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ef64:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113ef68:	e0bfff17 	ldw	r2,-4(fp)
8113ef6c:	1000021e 	bne	r2,zero,8113ef78 <OSQPend+0x3c>
        return ((void *)0);
8113ef70:	0005883a 	mov	r2,zero
8113ef74:	00009106 	br	8113f1bc <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113ef78:	e0bffd17 	ldw	r2,-12(fp)
8113ef7c:	1000051e 	bne	r2,zero,8113ef94 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ef80:	e0bfff17 	ldw	r2,-4(fp)
8113ef84:	00c00104 	movi	r3,4
8113ef88:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ef8c:	0005883a 	mov	r2,zero
8113ef90:	00008a06 	br	8113f1bc <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113ef94:	e0bffd17 	ldw	r2,-12(fp)
8113ef98:	10800003 	ldbu	r2,0(r2)
8113ef9c:	10803fcc 	andi	r2,r2,255
8113efa0:	108000a0 	cmpeqi	r2,r2,2
8113efa4:	1000051e 	bne	r2,zero,8113efbc <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113efa8:	e0bfff17 	ldw	r2,-4(fp)
8113efac:	00c00044 	movi	r3,1
8113efb0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113efb4:	0005883a 	mov	r2,zero
8113efb8:	00008006 	br	8113f1bc <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113efbc:	d0a0a103 	ldbu	r2,-32124(gp)
8113efc0:	10803fcc 	andi	r2,r2,255
8113efc4:	10000526 	beq	r2,zero,8113efdc <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113efc8:	e0bfff17 	ldw	r2,-4(fp)
8113efcc:	00c00084 	movi	r3,2
8113efd0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113efd4:	0005883a 	mov	r2,zero
8113efd8:	00007806 	br	8113f1bc <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113efdc:	d0a08f03 	ldbu	r2,-32196(gp)
8113efe0:	10803fcc 	andi	r2,r2,255
8113efe4:	10000526 	beq	r2,zero,8113effc <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113efe8:	e0bfff17 	ldw	r2,-4(fp)
8113efec:	00c00344 	movi	r3,13
8113eff0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113eff4:	0005883a 	mov	r2,zero
8113eff8:	00007006 	br	8113f1bc <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113effc:	0005303a 	rdctl	r2,status
8113f000:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f004:	e0fffc17 	ldw	r3,-16(fp)
8113f008:	00bfff84 	movi	r2,-2
8113f00c:	1884703a 	and	r2,r3,r2
8113f010:	1001703a 	wrctl	status,r2
  
  return context;
8113f014:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f018:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113f01c:	e0bffd17 	ldw	r2,-12(fp)
8113f020:	10800117 	ldw	r2,4(r2)
8113f024:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113f028:	e0bff817 	ldw	r2,-32(fp)
8113f02c:	1080058b 	ldhu	r2,22(r2)
8113f030:	10bfffcc 	andi	r2,r2,65535
8113f034:	10001e26 	beq	r2,zero,8113f0b0 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113f038:	e0bff817 	ldw	r2,-32(fp)
8113f03c:	10800417 	ldw	r2,16(r2)
8113f040:	11000104 	addi	r4,r2,4
8113f044:	e0fff817 	ldw	r3,-32(fp)
8113f048:	19000415 	stw	r4,16(r3)
8113f04c:	10800017 	ldw	r2,0(r2)
8113f050:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113f054:	e0bff817 	ldw	r2,-32(fp)
8113f058:	1080058b 	ldhu	r2,22(r2)
8113f05c:	10bfffc4 	addi	r2,r2,-1
8113f060:	1007883a 	mov	r3,r2
8113f064:	e0bff817 	ldw	r2,-32(fp)
8113f068:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113f06c:	e0bff817 	ldw	r2,-32(fp)
8113f070:	10c00417 	ldw	r3,16(r2)
8113f074:	e0bff817 	ldw	r2,-32(fp)
8113f078:	10800217 	ldw	r2,8(r2)
8113f07c:	1880041e 	bne	r3,r2,8113f090 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113f080:	e0bff817 	ldw	r2,-32(fp)
8113f084:	10c00117 	ldw	r3,4(r2)
8113f088:	e0bff817 	ldw	r2,-32(fp)
8113f08c:	10c00415 	stw	r3,16(r2)
8113f090:	e0bff617 	ldw	r2,-40(fp)
8113f094:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f098:	e0bff717 	ldw	r2,-36(fp)
8113f09c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113f0a0:	e0bfff17 	ldw	r2,-4(fp)
8113f0a4:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113f0a8:	e0bff517 	ldw	r2,-44(fp)
8113f0ac:	00004306 	br	8113f1bc <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113f0b0:	d0a0a217 	ldw	r2,-32120(gp)
8113f0b4:	d0e0a217 	ldw	r3,-32120(gp)
8113f0b8:	18c00c03 	ldbu	r3,48(r3)
8113f0bc:	18c00114 	ori	r3,r3,4
8113f0c0:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113f0c4:	d0a0a217 	ldw	r2,-32120(gp)
8113f0c8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113f0cc:	d0a0a217 	ldw	r2,-32120(gp)
8113f0d0:	e0fffe0b 	ldhu	r3,-8(fp)
8113f0d4:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113f0d8:	e13ffd17 	ldw	r4,-12(fp)
8113f0dc:	113a6680 	call	8113a668 <OS_EventTaskWait>
8113f0e0:	e0bff617 	ldw	r2,-40(fp)
8113f0e4:	e0bffb15 	stw	r2,-20(fp)
8113f0e8:	e0bffb17 	ldw	r2,-20(fp)
8113f0ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113f0f0:	113af840 	call	8113af84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f0f4:	0005303a 	rdctl	r2,status
8113f0f8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f0fc:	e0fff917 	ldw	r3,-28(fp)
8113f100:	00bfff84 	movi	r2,-2
8113f104:	1884703a 	and	r2,r3,r2
8113f108:	1001703a 	wrctl	status,r2
  
  return context;
8113f10c:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113f110:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113f114:	d0a0a217 	ldw	r2,-32120(gp)
8113f118:	10800c43 	ldbu	r2,49(r2)
8113f11c:	10803fcc 	andi	r2,r2,255
8113f120:	10000326 	beq	r2,zero,8113f130 <OSQPend+0x1f4>
8113f124:	108000a0 	cmpeqi	r2,r2,2
8113f128:	1000071e 	bne	r2,zero,8113f148 <OSQPend+0x20c>
8113f12c:	00000b06 	br	8113f15c <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113f130:	d0a0a217 	ldw	r2,-32120(gp)
8113f134:	10800917 	ldw	r2,36(r2)
8113f138:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113f13c:	e0bfff17 	ldw	r2,-4(fp)
8113f140:	10000005 	stb	zero,0(r2)
             break;
8113f144:	00000e06 	br	8113f180 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113f148:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113f14c:	e0bfff17 	ldw	r2,-4(fp)
8113f150:	00c00384 	movi	r3,14
8113f154:	10c00005 	stb	r3,0(r2)
             break;
8113f158:	00000906 	br	8113f180 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113f15c:	d0a0a217 	ldw	r2,-32120(gp)
8113f160:	e17ffd17 	ldw	r5,-12(fp)
8113f164:	1009883a 	mov	r4,r2
8113f168:	113a8d80 	call	8113a8d8 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113f16c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113f170:	e0bfff17 	ldw	r2,-4(fp)
8113f174:	00c00284 	movi	r3,10
8113f178:	10c00005 	stb	r3,0(r2)
             break;
8113f17c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113f180:	d0a0a217 	ldw	r2,-32120(gp)
8113f184:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113f188:	d0a0a217 	ldw	r2,-32120(gp)
8113f18c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113f190:	d0a0a217 	ldw	r2,-32120(gp)
8113f194:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113f198:	d0a0a217 	ldw	r2,-32120(gp)
8113f19c:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113f1a0:	d0a0a217 	ldw	r2,-32120(gp)
8113f1a4:	10000915 	stw	zero,36(r2)
8113f1a8:	e0bff617 	ldw	r2,-40(fp)
8113f1ac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f1b0:	e0bffa17 	ldw	r2,-24(fp)
8113f1b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113f1b8:	e0bff517 	ldw	r2,-44(fp)
}
8113f1bc:	e037883a 	mov	sp,fp
8113f1c0:	dfc00117 	ldw	ra,4(sp)
8113f1c4:	df000017 	ldw	fp,0(sp)
8113f1c8:	dec00204 	addi	sp,sp,8
8113f1cc:	f800283a 	ret

8113f1d0 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113f1d0:	defff604 	addi	sp,sp,-40
8113f1d4:	de00012e 	bgeu	sp,et,8113f1dc <OSQPendAbort+0xc>
8113f1d8:	003b68fa 	trap	3
8113f1dc:	dfc00915 	stw	ra,36(sp)
8113f1e0:	df000815 	stw	fp,32(sp)
8113f1e4:	df000804 	addi	fp,sp,32
8113f1e8:	e13ffd15 	stw	r4,-12(fp)
8113f1ec:	2805883a 	mov	r2,r5
8113f1f0:	e1bfff15 	stw	r6,-4(fp)
8113f1f4:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113f1f8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113f1fc:	e0bfff17 	ldw	r2,-4(fp)
8113f200:	1000021e 	bne	r2,zero,8113f20c <OSQPendAbort+0x3c>
        return (0);
8113f204:	0005883a 	mov	r2,zero
8113f208:	00004906 	br	8113f330 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113f20c:	e0bffd17 	ldw	r2,-12(fp)
8113f210:	1000051e 	bne	r2,zero,8113f228 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113f214:	e0bfff17 	ldw	r2,-4(fp)
8113f218:	00c00104 	movi	r3,4
8113f21c:	10c00005 	stb	r3,0(r2)
        return (0);
8113f220:	0005883a 	mov	r2,zero
8113f224:	00004206 	br	8113f330 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113f228:	e0bffd17 	ldw	r2,-12(fp)
8113f22c:	10800003 	ldbu	r2,0(r2)
8113f230:	10803fcc 	andi	r2,r2,255
8113f234:	108000a0 	cmpeqi	r2,r2,2
8113f238:	1000051e 	bne	r2,zero,8113f250 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113f23c:	e0bfff17 	ldw	r2,-4(fp)
8113f240:	00c00044 	movi	r3,1
8113f244:	10c00005 	stb	r3,0(r2)
        return (0);
8113f248:	0005883a 	mov	r2,zero
8113f24c:	00003806 	br	8113f330 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f250:	0005303a 	rdctl	r2,status
8113f254:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f258:	e0fffc17 	ldw	r3,-16(fp)
8113f25c:	00bfff84 	movi	r2,-2
8113f260:	1884703a 	and	r2,r3,r2
8113f264:	1001703a 	wrctl	status,r2
  
  return context;
8113f268:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f26c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113f270:	e0bffd17 	ldw	r2,-12(fp)
8113f274:	10800283 	ldbu	r2,10(r2)
8113f278:	10803fcc 	andi	r2,r2,255
8113f27c:	10002526 	beq	r2,zero,8113f314 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113f280:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113f284:	e0bffe03 	ldbu	r2,-8(fp)
8113f288:	10800060 	cmpeqi	r2,r2,1
8113f28c:	10000e26 	beq	r2,zero,8113f2c8 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113f290:	00000806 	br	8113f2b4 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113f294:	01c00084 	movi	r7,2
8113f298:	01800104 	movi	r6,4
8113f29c:	000b883a 	mov	r5,zero
8113f2a0:	e13ffd17 	ldw	r4,-12(fp)
8113f2a4:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
                     nbr_tasks++;
8113f2a8:	e0bff803 	ldbu	r2,-32(fp)
8113f2ac:	10800044 	addi	r2,r2,1
8113f2b0:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113f2b4:	e0bffd17 	ldw	r2,-12(fp)
8113f2b8:	10800283 	ldbu	r2,10(r2)
8113f2bc:	10803fcc 	andi	r2,r2,255
8113f2c0:	103ff41e 	bne	r2,zero,8113f294 <__reset+0xfb11f294>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113f2c4:	00000906 	br	8113f2ec <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113f2c8:	01c00084 	movi	r7,2
8113f2cc:	01800104 	movi	r6,4
8113f2d0:	000b883a 	mov	r5,zero
8113f2d4:	e13ffd17 	ldw	r4,-12(fp)
8113f2d8:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
                 nbr_tasks++;
8113f2dc:	e0bff803 	ldbu	r2,-32(fp)
8113f2e0:	10800044 	addi	r2,r2,1
8113f2e4:	e0bff805 	stb	r2,-32(fp)
                 break;
8113f2e8:	0001883a 	nop
8113f2ec:	e0bff917 	ldw	r2,-28(fp)
8113f2f0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f2f4:	e0bffa17 	ldw	r2,-24(fp)
8113f2f8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113f2fc:	113af840 	call	8113af84 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113f300:	e0bfff17 	ldw	r2,-4(fp)
8113f304:	00c00384 	movi	r3,14
8113f308:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113f30c:	e0bff803 	ldbu	r2,-32(fp)
8113f310:	00000706 	br	8113f330 <OSQPendAbort+0x160>
8113f314:	e0bff917 	ldw	r2,-28(fp)
8113f318:	e0bffb15 	stw	r2,-20(fp)
8113f31c:	e0bffb17 	ldw	r2,-20(fp)
8113f320:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113f324:	e0bfff17 	ldw	r2,-4(fp)
8113f328:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113f32c:	0005883a 	mov	r2,zero
}
8113f330:	e037883a 	mov	sp,fp
8113f334:	dfc00117 	ldw	ra,4(sp)
8113f338:	df000017 	ldw	fp,0(sp)
8113f33c:	dec00204 	addi	sp,sp,8
8113f340:	f800283a 	ret

8113f344 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113f344:	defff604 	addi	sp,sp,-40
8113f348:	de00012e 	bgeu	sp,et,8113f350 <OSQPost+0xc>
8113f34c:	003b68fa 	trap	3
8113f350:	dfc00915 	stw	ra,36(sp)
8113f354:	df000815 	stw	fp,32(sp)
8113f358:	df000804 	addi	fp,sp,32
8113f35c:	e13ffe15 	stw	r4,-8(fp)
8113f360:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113f364:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113f368:	e0bffe17 	ldw	r2,-8(fp)
8113f36c:	1000021e 	bne	r2,zero,8113f378 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113f370:	00800104 	movi	r2,4
8113f374:	00004a06 	br	8113f4a0 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113f378:	e0bffe17 	ldw	r2,-8(fp)
8113f37c:	10800003 	ldbu	r2,0(r2)
8113f380:	10803fcc 	andi	r2,r2,255
8113f384:	108000a0 	cmpeqi	r2,r2,2
8113f388:	1000021e 	bne	r2,zero,8113f394 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113f38c:	00800044 	movi	r2,1
8113f390:	00004306 	br	8113f4a0 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f394:	0005303a 	rdctl	r2,status
8113f398:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f39c:	e0fffd17 	ldw	r3,-12(fp)
8113f3a0:	00bfff84 	movi	r2,-2
8113f3a4:	1884703a 	and	r2,r3,r2
8113f3a8:	1001703a 	wrctl	status,r2
  
  return context;
8113f3ac:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f3b0:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113f3b4:	e0bffe17 	ldw	r2,-8(fp)
8113f3b8:	10800283 	ldbu	r2,10(r2)
8113f3bc:	10803fcc 	andi	r2,r2,255
8113f3c0:	10000c26 	beq	r2,zero,8113f3f4 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f3c4:	000f883a 	mov	r7,zero
8113f3c8:	01800104 	movi	r6,4
8113f3cc:	e17fff17 	ldw	r5,-4(fp)
8113f3d0:	e13ffe17 	ldw	r4,-8(fp)
8113f3d4:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
8113f3d8:	e0bff817 	ldw	r2,-32(fp)
8113f3dc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f3e0:	e0bff917 	ldw	r2,-28(fp)
8113f3e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113f3e8:	113af840 	call	8113af84 <OS_Sched>
        return (OS_ERR_NONE);
8113f3ec:	0005883a 	mov	r2,zero
8113f3f0:	00002b06 	br	8113f4a0 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113f3f4:	e0bffe17 	ldw	r2,-8(fp)
8113f3f8:	10800117 	ldw	r2,4(r2)
8113f3fc:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113f400:	e0bffb17 	ldw	r2,-20(fp)
8113f404:	10c0058b 	ldhu	r3,22(r2)
8113f408:	e0bffb17 	ldw	r2,-20(fp)
8113f40c:	1080050b 	ldhu	r2,20(r2)
8113f410:	18ffffcc 	andi	r3,r3,65535
8113f414:	10bfffcc 	andi	r2,r2,65535
8113f418:	18800636 	bltu	r3,r2,8113f434 <OSQPost+0xf0>
8113f41c:	e0bff817 	ldw	r2,-32(fp)
8113f420:	e0bffa15 	stw	r2,-24(fp)
8113f424:	e0bffa17 	ldw	r2,-24(fp)
8113f428:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113f42c:	00800784 	movi	r2,30
8113f430:	00001b06 	br	8113f4a0 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113f434:	e0bffb17 	ldw	r2,-20(fp)
8113f438:	10800317 	ldw	r2,12(r2)
8113f43c:	11000104 	addi	r4,r2,4
8113f440:	e0fffb17 	ldw	r3,-20(fp)
8113f444:	19000315 	stw	r4,12(r3)
8113f448:	e0ffff17 	ldw	r3,-4(fp)
8113f44c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113f450:	e0bffb17 	ldw	r2,-20(fp)
8113f454:	1080058b 	ldhu	r2,22(r2)
8113f458:	10800044 	addi	r2,r2,1
8113f45c:	1007883a 	mov	r3,r2
8113f460:	e0bffb17 	ldw	r2,-20(fp)
8113f464:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113f468:	e0bffb17 	ldw	r2,-20(fp)
8113f46c:	10c00317 	ldw	r3,12(r2)
8113f470:	e0bffb17 	ldw	r2,-20(fp)
8113f474:	10800217 	ldw	r2,8(r2)
8113f478:	1880041e 	bne	r3,r2,8113f48c <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113f47c:	e0bffb17 	ldw	r2,-20(fp)
8113f480:	10c00117 	ldw	r3,4(r2)
8113f484:	e0bffb17 	ldw	r2,-20(fp)
8113f488:	10c00315 	stw	r3,12(r2)
8113f48c:	e0bff817 	ldw	r2,-32(fp)
8113f490:	e0bffc15 	stw	r2,-16(fp)
8113f494:	e0bffc17 	ldw	r2,-16(fp)
8113f498:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f49c:	0005883a 	mov	r2,zero
}
8113f4a0:	e037883a 	mov	sp,fp
8113f4a4:	dfc00117 	ldw	ra,4(sp)
8113f4a8:	df000017 	ldw	fp,0(sp)
8113f4ac:	dec00204 	addi	sp,sp,8
8113f4b0:	f800283a 	ret

8113f4b4 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113f4b4:	defff604 	addi	sp,sp,-40
8113f4b8:	de00012e 	bgeu	sp,et,8113f4c0 <OSQPostFront+0xc>
8113f4bc:	003b68fa 	trap	3
8113f4c0:	dfc00915 	stw	ra,36(sp)
8113f4c4:	df000815 	stw	fp,32(sp)
8113f4c8:	df000804 	addi	fp,sp,32
8113f4cc:	e13ffe15 	stw	r4,-8(fp)
8113f4d0:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f4d4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f4d8:	e0bffe17 	ldw	r2,-8(fp)
8113f4dc:	1000021e 	bne	r2,zero,8113f4e8 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113f4e0:	00800104 	movi	r2,4
8113f4e4:	00004c06 	br	8113f618 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113f4e8:	e0bffe17 	ldw	r2,-8(fp)
8113f4ec:	10800003 	ldbu	r2,0(r2)
8113f4f0:	10803fcc 	andi	r2,r2,255
8113f4f4:	108000a0 	cmpeqi	r2,r2,2
8113f4f8:	1000021e 	bne	r2,zero,8113f504 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113f4fc:	00800044 	movi	r2,1
8113f500:	00004506 	br	8113f618 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f504:	0005303a 	rdctl	r2,status
8113f508:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f50c:	e0fffd17 	ldw	r3,-12(fp)
8113f510:	00bfff84 	movi	r2,-2
8113f514:	1884703a 	and	r2,r3,r2
8113f518:	1001703a 	wrctl	status,r2
  
  return context;
8113f51c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f520:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113f524:	e0bffe17 	ldw	r2,-8(fp)
8113f528:	10800283 	ldbu	r2,10(r2)
8113f52c:	10803fcc 	andi	r2,r2,255
8113f530:	10000c26 	beq	r2,zero,8113f564 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f534:	000f883a 	mov	r7,zero
8113f538:	01800104 	movi	r6,4
8113f53c:	e17fff17 	ldw	r5,-4(fp)
8113f540:	e13ffe17 	ldw	r4,-8(fp)
8113f544:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
8113f548:	e0bff817 	ldw	r2,-32(fp)
8113f54c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f550:	e0bff917 	ldw	r2,-28(fp)
8113f554:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113f558:	113af840 	call	8113af84 <OS_Sched>
        return (OS_ERR_NONE);
8113f55c:	0005883a 	mov	r2,zero
8113f560:	00002d06 	br	8113f618 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113f564:	e0bffe17 	ldw	r2,-8(fp)
8113f568:	10800117 	ldw	r2,4(r2)
8113f56c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113f570:	e0bffb17 	ldw	r2,-20(fp)
8113f574:	10c0058b 	ldhu	r3,22(r2)
8113f578:	e0bffb17 	ldw	r2,-20(fp)
8113f57c:	1080050b 	ldhu	r2,20(r2)
8113f580:	18ffffcc 	andi	r3,r3,65535
8113f584:	10bfffcc 	andi	r2,r2,65535
8113f588:	18800636 	bltu	r3,r2,8113f5a4 <OSQPostFront+0xf0>
8113f58c:	e0bff817 	ldw	r2,-32(fp)
8113f590:	e0bffa15 	stw	r2,-24(fp)
8113f594:	e0bffa17 	ldw	r2,-24(fp)
8113f598:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113f59c:	00800784 	movi	r2,30
8113f5a0:	00001d06 	br	8113f618 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113f5a4:	e0bffb17 	ldw	r2,-20(fp)
8113f5a8:	10c00417 	ldw	r3,16(r2)
8113f5ac:	e0bffb17 	ldw	r2,-20(fp)
8113f5b0:	10800117 	ldw	r2,4(r2)
8113f5b4:	1880041e 	bne	r3,r2,8113f5c8 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113f5b8:	e0bffb17 	ldw	r2,-20(fp)
8113f5bc:	10c00217 	ldw	r3,8(r2)
8113f5c0:	e0bffb17 	ldw	r2,-20(fp)
8113f5c4:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113f5c8:	e0bffb17 	ldw	r2,-20(fp)
8113f5cc:	10800417 	ldw	r2,16(r2)
8113f5d0:	10ffff04 	addi	r3,r2,-4
8113f5d4:	e0bffb17 	ldw	r2,-20(fp)
8113f5d8:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113f5dc:	e0bffb17 	ldw	r2,-20(fp)
8113f5e0:	10800417 	ldw	r2,16(r2)
8113f5e4:	e0ffff17 	ldw	r3,-4(fp)
8113f5e8:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113f5ec:	e0bffb17 	ldw	r2,-20(fp)
8113f5f0:	1080058b 	ldhu	r2,22(r2)
8113f5f4:	10800044 	addi	r2,r2,1
8113f5f8:	1007883a 	mov	r3,r2
8113f5fc:	e0bffb17 	ldw	r2,-20(fp)
8113f600:	10c0058d 	sth	r3,22(r2)
8113f604:	e0bff817 	ldw	r2,-32(fp)
8113f608:	e0bffc15 	stw	r2,-16(fp)
8113f60c:	e0bffc17 	ldw	r2,-16(fp)
8113f610:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f614:	0005883a 	mov	r2,zero
}
8113f618:	e037883a 	mov	sp,fp
8113f61c:	dfc00117 	ldw	ra,4(sp)
8113f620:	df000017 	ldw	fp,0(sp)
8113f624:	dec00204 	addi	sp,sp,8
8113f628:	f800283a 	ret

8113f62c <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113f62c:	defff504 	addi	sp,sp,-44
8113f630:	de00012e 	bgeu	sp,et,8113f638 <OSQPostOpt+0xc>
8113f634:	003b68fa 	trap	3
8113f638:	dfc00a15 	stw	ra,40(sp)
8113f63c:	df000915 	stw	fp,36(sp)
8113f640:	df000904 	addi	fp,sp,36
8113f644:	e13ffd15 	stw	r4,-12(fp)
8113f648:	e17ffe15 	stw	r5,-8(fp)
8113f64c:	3005883a 	mov	r2,r6
8113f650:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f654:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f658:	e0bffd17 	ldw	r2,-12(fp)
8113f65c:	1000021e 	bne	r2,zero,8113f668 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113f660:	00800104 	movi	r2,4
8113f664:	00007106 	br	8113f82c <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113f668:	e0bffd17 	ldw	r2,-12(fp)
8113f66c:	10800003 	ldbu	r2,0(r2)
8113f670:	10803fcc 	andi	r2,r2,255
8113f674:	108000a0 	cmpeqi	r2,r2,2
8113f678:	1000021e 	bne	r2,zero,8113f684 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113f67c:	00800044 	movi	r2,1
8113f680:	00006a06 	br	8113f82c <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f684:	0005303a 	rdctl	r2,status
8113f688:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f68c:	e0fffc17 	ldw	r3,-16(fp)
8113f690:	00bfff84 	movi	r2,-2
8113f694:	1884703a 	and	r2,r3,r2
8113f698:	1001703a 	wrctl	status,r2
  
  return context;
8113f69c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f6a0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113f6a4:	e0bffd17 	ldw	r2,-12(fp)
8113f6a8:	10800283 	ldbu	r2,10(r2)
8113f6ac:	10803fcc 	andi	r2,r2,255
8113f6b0:	10001d26 	beq	r2,zero,8113f728 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113f6b4:	e0bfff03 	ldbu	r2,-4(fp)
8113f6b8:	1080004c 	andi	r2,r2,1
8113f6bc:	10000b26 	beq	r2,zero,8113f6ec <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113f6c0:	00000506 	br	8113f6d8 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f6c4:	000f883a 	mov	r7,zero
8113f6c8:	01800104 	movi	r6,4
8113f6cc:	e17ffe17 	ldw	r5,-8(fp)
8113f6d0:	e13ffd17 	ldw	r4,-12(fp)
8113f6d4:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113f6d8:	e0bffd17 	ldw	r2,-12(fp)
8113f6dc:	10800283 	ldbu	r2,10(r2)
8113f6e0:	10803fcc 	andi	r2,r2,255
8113f6e4:	103ff71e 	bne	r2,zero,8113f6c4 <__reset+0xfb11f6c4>
8113f6e8:	00000506 	br	8113f700 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f6ec:	000f883a 	mov	r7,zero
8113f6f0:	01800104 	movi	r6,4
8113f6f4:	e17ffe17 	ldw	r5,-8(fp)
8113f6f8:	e13ffd17 	ldw	r4,-12(fp)
8113f6fc:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
8113f700:	e0bff717 	ldw	r2,-36(fp)
8113f704:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f708:	e0bff817 	ldw	r2,-32(fp)
8113f70c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113f710:	e0bfff03 	ldbu	r2,-4(fp)
8113f714:	1080010c 	andi	r2,r2,4
8113f718:	1000011e 	bne	r2,zero,8113f720 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113f71c:	113af840 	call	8113af84 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113f720:	0005883a 	mov	r2,zero
8113f724:	00004106 	br	8113f82c <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113f728:	e0bffd17 	ldw	r2,-12(fp)
8113f72c:	10800117 	ldw	r2,4(r2)
8113f730:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113f734:	e0bffa17 	ldw	r2,-24(fp)
8113f738:	10c0058b 	ldhu	r3,22(r2)
8113f73c:	e0bffa17 	ldw	r2,-24(fp)
8113f740:	1080050b 	ldhu	r2,20(r2)
8113f744:	18ffffcc 	andi	r3,r3,65535
8113f748:	10bfffcc 	andi	r2,r2,65535
8113f74c:	18800636 	bltu	r3,r2,8113f768 <OSQPostOpt+0x13c>
8113f750:	e0bff717 	ldw	r2,-36(fp)
8113f754:	e0bff915 	stw	r2,-28(fp)
8113f758:	e0bff917 	ldw	r2,-28(fp)
8113f75c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113f760:	00800784 	movi	r2,30
8113f764:	00003106 	br	8113f82c <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113f768:	e0bfff03 	ldbu	r2,-4(fp)
8113f76c:	1080008c 	andi	r2,r2,2
8113f770:	10001326 	beq	r2,zero,8113f7c0 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113f774:	e0bffa17 	ldw	r2,-24(fp)
8113f778:	10c00417 	ldw	r3,16(r2)
8113f77c:	e0bffa17 	ldw	r2,-24(fp)
8113f780:	10800117 	ldw	r2,4(r2)
8113f784:	1880041e 	bne	r3,r2,8113f798 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113f788:	e0bffa17 	ldw	r2,-24(fp)
8113f78c:	10c00217 	ldw	r3,8(r2)
8113f790:	e0bffa17 	ldw	r2,-24(fp)
8113f794:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113f798:	e0bffa17 	ldw	r2,-24(fp)
8113f79c:	10800417 	ldw	r2,16(r2)
8113f7a0:	10ffff04 	addi	r3,r2,-4
8113f7a4:	e0bffa17 	ldw	r2,-24(fp)
8113f7a8:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113f7ac:	e0bffa17 	ldw	r2,-24(fp)
8113f7b0:	10800417 	ldw	r2,16(r2)
8113f7b4:	e0fffe17 	ldw	r3,-8(fp)
8113f7b8:	10c00015 	stw	r3,0(r2)
8113f7bc:	00001006 	br	8113f800 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113f7c0:	e0bffa17 	ldw	r2,-24(fp)
8113f7c4:	10800317 	ldw	r2,12(r2)
8113f7c8:	11000104 	addi	r4,r2,4
8113f7cc:	e0fffa17 	ldw	r3,-24(fp)
8113f7d0:	19000315 	stw	r4,12(r3)
8113f7d4:	e0fffe17 	ldw	r3,-8(fp)
8113f7d8:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113f7dc:	e0bffa17 	ldw	r2,-24(fp)
8113f7e0:	10c00317 	ldw	r3,12(r2)
8113f7e4:	e0bffa17 	ldw	r2,-24(fp)
8113f7e8:	10800217 	ldw	r2,8(r2)
8113f7ec:	1880041e 	bne	r3,r2,8113f800 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113f7f0:	e0bffa17 	ldw	r2,-24(fp)
8113f7f4:	10c00117 	ldw	r3,4(r2)
8113f7f8:	e0bffa17 	ldw	r2,-24(fp)
8113f7fc:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113f800:	e0bffa17 	ldw	r2,-24(fp)
8113f804:	1080058b 	ldhu	r2,22(r2)
8113f808:	10800044 	addi	r2,r2,1
8113f80c:	1007883a 	mov	r3,r2
8113f810:	e0bffa17 	ldw	r2,-24(fp)
8113f814:	10c0058d 	sth	r3,22(r2)
8113f818:	e0bff717 	ldw	r2,-36(fp)
8113f81c:	e0bffb15 	stw	r2,-20(fp)
8113f820:	e0bffb17 	ldw	r2,-20(fp)
8113f824:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f828:	0005883a 	mov	r2,zero
}
8113f82c:	e037883a 	mov	sp,fp
8113f830:	dfc00117 	ldw	ra,4(sp)
8113f834:	df000017 	ldw	fp,0(sp)
8113f838:	dec00204 	addi	sp,sp,8
8113f83c:	f800283a 	ret

8113f840 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113f840:	defff604 	addi	sp,sp,-40
8113f844:	de00012e 	bgeu	sp,et,8113f84c <OSQQuery+0xc>
8113f848:	003b68fa 	trap	3
8113f84c:	df000915 	stw	fp,36(sp)
8113f850:	df000904 	addi	fp,sp,36
8113f854:	e13ffe15 	stw	r4,-8(fp)
8113f858:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113f85c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113f860:	e0bffe17 	ldw	r2,-8(fp)
8113f864:	1000021e 	bne	r2,zero,8113f870 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113f868:	00800104 	movi	r2,4
8113f86c:	00004906 	br	8113f994 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113f870:	e0bfff17 	ldw	r2,-4(fp)
8113f874:	1000021e 	bne	r2,zero,8113f880 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113f878:	00800244 	movi	r2,9
8113f87c:	00004506 	br	8113f994 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113f880:	e0bffe17 	ldw	r2,-8(fp)
8113f884:	10800003 	ldbu	r2,0(r2)
8113f888:	10803fcc 	andi	r2,r2,255
8113f88c:	108000a0 	cmpeqi	r2,r2,2
8113f890:	1000021e 	bne	r2,zero,8113f89c <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113f894:	00800044 	movi	r2,1
8113f898:	00003e06 	br	8113f994 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f89c:	0005303a 	rdctl	r2,status
8113f8a0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f8a4:	e0fffd17 	ldw	r3,-12(fp)
8113f8a8:	00bfff84 	movi	r2,-2
8113f8ac:	1884703a 	and	r2,r3,r2
8113f8b0:	1001703a 	wrctl	status,r2
  
  return context;
8113f8b4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f8b8:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113f8bc:	e0bffe17 	ldw	r2,-8(fp)
8113f8c0:	10c00283 	ldbu	r3,10(r2)
8113f8c4:	e0bfff17 	ldw	r2,-4(fp)
8113f8c8:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113f8cc:	e0bffe17 	ldw	r2,-8(fp)
8113f8d0:	108002c4 	addi	r2,r2,11
8113f8d4:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113f8d8:	e0bfff17 	ldw	r2,-4(fp)
8113f8dc:	10800204 	addi	r2,r2,8
8113f8e0:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f8e4:	e03ff705 	stb	zero,-36(fp)
8113f8e8:	00000b06 	br	8113f918 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113f8ec:	e0bff917 	ldw	r2,-28(fp)
8113f8f0:	10c00044 	addi	r3,r2,1
8113f8f4:	e0fff915 	stw	r3,-28(fp)
8113f8f8:	e0fff817 	ldw	r3,-32(fp)
8113f8fc:	19000044 	addi	r4,r3,1
8113f900:	e13ff815 	stw	r4,-32(fp)
8113f904:	18c00003 	ldbu	r3,0(r3)
8113f908:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f90c:	e0bff703 	ldbu	r2,-36(fp)
8113f910:	10800044 	addi	r2,r2,1
8113f914:	e0bff705 	stb	r2,-36(fp)
8113f918:	e0bff703 	ldbu	r2,-36(fp)
8113f91c:	108001b0 	cmpltui	r2,r2,6
8113f920:	103ff21e 	bne	r2,zero,8113f8ec <__reset+0xfb11f8ec>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113f924:	e0bffe17 	ldw	r2,-8(fp)
8113f928:	10800117 	ldw	r2,4(r2)
8113f92c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113f930:	e0bffc17 	ldw	r2,-16(fp)
8113f934:	1080058b 	ldhu	r2,22(r2)
8113f938:	10bfffcc 	andi	r2,r2,65535
8113f93c:	10000626 	beq	r2,zero,8113f958 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113f940:	e0bffc17 	ldw	r2,-16(fp)
8113f944:	10800417 	ldw	r2,16(r2)
8113f948:	10c00017 	ldw	r3,0(r2)
8113f94c:	e0bfff17 	ldw	r2,-4(fp)
8113f950:	10c00015 	stw	r3,0(r2)
8113f954:	00000206 	br	8113f960 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113f958:	e0bfff17 	ldw	r2,-4(fp)
8113f95c:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113f960:	e0bffc17 	ldw	r2,-16(fp)
8113f964:	10c0058b 	ldhu	r3,22(r2)
8113f968:	e0bfff17 	ldw	r2,-4(fp)
8113f96c:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113f970:	e0bffc17 	ldw	r2,-16(fp)
8113f974:	10c0050b 	ldhu	r3,20(r2)
8113f978:	e0bfff17 	ldw	r2,-4(fp)
8113f97c:	10c0018d 	sth	r3,6(r2)
8113f980:	e0bffa17 	ldw	r2,-24(fp)
8113f984:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f988:	e0bffb17 	ldw	r2,-20(fp)
8113f98c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f990:	0005883a 	mov	r2,zero
}
8113f994:	e037883a 	mov	sp,fp
8113f998:	df000017 	ldw	fp,0(sp)
8113f99c:	dec00104 	addi	sp,sp,4
8113f9a0:	f800283a 	ret

8113f9a4 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113f9a4:	defffb04 	addi	sp,sp,-20
8113f9a8:	de00012e 	bgeu	sp,et,8113f9b0 <OS_QInit+0xc>
8113f9ac:	003b68fa 	trap	3
8113f9b0:	dfc00415 	stw	ra,16(sp)
8113f9b4:	df000315 	stw	fp,12(sp)
8113f9b8:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113f9bc:	0140c004 	movi	r5,768
8113f9c0:	012045f4 	movhi	r4,33047
8113f9c4:	2129ae04 	addi	r4,r4,-22856
8113f9c8:	113aeb80 	call	8113aeb8 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113f9cc:	00a045f4 	movhi	r2,33047
8113f9d0:	10a9ae04 	addi	r2,r2,-22856
8113f9d4:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113f9d8:	00a045f4 	movhi	r2,33047
8113f9dc:	10a9b404 	addi	r2,r2,-22832
8113f9e0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113f9e4:	e03ffd0d 	sth	zero,-12(fp)
8113f9e8:	00000c06 	br	8113fa1c <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113f9ec:	e0bffe17 	ldw	r2,-8(fp)
8113f9f0:	e0ffff17 	ldw	r3,-4(fp)
8113f9f4:	10c00015 	stw	r3,0(r2)
        pq1++;
8113f9f8:	e0bffe17 	ldw	r2,-8(fp)
8113f9fc:	10800604 	addi	r2,r2,24
8113fa00:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113fa04:	e0bfff17 	ldw	r2,-4(fp)
8113fa08:	10800604 	addi	r2,r2,24
8113fa0c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113fa10:	e0bffd0b 	ldhu	r2,-12(fp)
8113fa14:	10800044 	addi	r2,r2,1
8113fa18:	e0bffd0d 	sth	r2,-12(fp)
8113fa1c:	e0bffd0b 	ldhu	r2,-12(fp)
8113fa20:	108007f0 	cmpltui	r2,r2,31
8113fa24:	103ff11e 	bne	r2,zero,8113f9ec <__reset+0xfb11f9ec>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113fa28:	e0bffe17 	ldw	r2,-8(fp)
8113fa2c:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113fa30:	00a045f4 	movhi	r2,33047
8113fa34:	10a9ae04 	addi	r2,r2,-22856
8113fa38:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
8113fa3c:	0001883a 	nop
8113fa40:	e037883a 	mov	sp,fp
8113fa44:	dfc00117 	ldw	ra,4(sp)
8113fa48:	df000017 	ldw	fp,0(sp)
8113fa4c:	dec00204 	addi	sp,sp,8
8113fa50:	f800283a 	ret

8113fa54 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113fa54:	defffa04 	addi	sp,sp,-24
8113fa58:	de00012e 	bgeu	sp,et,8113fa60 <OSSemAccept+0xc>
8113fa5c:	003b68fa 	trap	3
8113fa60:	df000515 	stw	fp,20(sp)
8113fa64:	df000504 	addi	fp,sp,20
8113fa68:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fa6c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113fa70:	e0bfff17 	ldw	r2,-4(fp)
8113fa74:	1000021e 	bne	r2,zero,8113fa80 <OSSemAccept+0x2c>
        return (0);
8113fa78:	0005883a 	mov	r2,zero
8113fa7c:	00001f06 	br	8113fafc <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113fa80:	e0bfff17 	ldw	r2,-4(fp)
8113fa84:	10800003 	ldbu	r2,0(r2)
8113fa88:	10803fcc 	andi	r2,r2,255
8113fa8c:	108000e0 	cmpeqi	r2,r2,3
8113fa90:	1000021e 	bne	r2,zero,8113fa9c <OSSemAccept+0x48>
        return (0);
8113fa94:	0005883a 	mov	r2,zero
8113fa98:	00001806 	br	8113fafc <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa9c:	0005303a 	rdctl	r2,status
8113faa0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113faa4:	e0fffe17 	ldw	r3,-8(fp)
8113faa8:	00bfff84 	movi	r2,-2
8113faac:	1884703a 	and	r2,r3,r2
8113fab0:	1001703a 	wrctl	status,r2
  
  return context;
8113fab4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113fab8:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113fabc:	e0bfff17 	ldw	r2,-4(fp)
8113fac0:	1080020b 	ldhu	r2,8(r2)
8113fac4:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113fac8:	e0bffd0b 	ldhu	r2,-12(fp)
8113facc:	10000626 	beq	r2,zero,8113fae8 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113fad0:	e0bfff17 	ldw	r2,-4(fp)
8113fad4:	1080020b 	ldhu	r2,8(r2)
8113fad8:	10bfffc4 	addi	r2,r2,-1
8113fadc:	1007883a 	mov	r3,r2
8113fae0:	e0bfff17 	ldw	r2,-4(fp)
8113fae4:	10c0020d 	sth	r3,8(r2)
8113fae8:	e0bffb17 	ldw	r2,-20(fp)
8113faec:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113faf0:	e0bffc17 	ldw	r2,-16(fp)
8113faf4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113faf8:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113fafc:	e037883a 	mov	sp,fp
8113fb00:	df000017 	ldw	fp,0(sp)
8113fb04:	dec00104 	addi	sp,sp,4
8113fb08:	f800283a 	ret

8113fb0c <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113fb0c:	defff904 	addi	sp,sp,-28
8113fb10:	de00012e 	bgeu	sp,et,8113fb18 <OSSemCreate+0xc>
8113fb14:	003b68fa 	trap	3
8113fb18:	dfc00615 	stw	ra,24(sp)
8113fb1c:	df000515 	stw	fp,20(sp)
8113fb20:	df000504 	addi	fp,sp,20
8113fb24:	2005883a 	mov	r2,r4
8113fb28:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113fb2c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113fb30:	d0a0a103 	ldbu	r2,-32124(gp)
8113fb34:	10803fcc 	andi	r2,r2,255
8113fb38:	10000226 	beq	r2,zero,8113fb44 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113fb3c:	0005883a 	mov	r2,zero
8113fb40:	00002506 	br	8113fbd8 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fb44:	0005303a 	rdctl	r2,status
8113fb48:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fb4c:	e0fffe17 	ldw	r3,-8(fp)
8113fb50:	00bfff84 	movi	r2,-2
8113fb54:	1884703a 	and	r2,r3,r2
8113fb58:	1001703a 	wrctl	status,r2
  
  return context;
8113fb5c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113fb60:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113fb64:	d0a0a017 	ldw	r2,-32128(gp)
8113fb68:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113fb6c:	d0a0a017 	ldw	r2,-32128(gp)
8113fb70:	10000326 	beq	r2,zero,8113fb80 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113fb74:	d0a0a017 	ldw	r2,-32128(gp)
8113fb78:	10800117 	ldw	r2,4(r2)
8113fb7c:	d0a0a015 	stw	r2,-32128(gp)
8113fb80:	e0bffb17 	ldw	r2,-20(fp)
8113fb84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fb88:	e0bffc17 	ldw	r2,-16(fp)
8113fb8c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113fb90:	e0bffd17 	ldw	r2,-12(fp)
8113fb94:	10000f26 	beq	r2,zero,8113fbd4 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113fb98:	e0bffd17 	ldw	r2,-12(fp)
8113fb9c:	00c000c4 	movi	r3,3
8113fba0:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113fba4:	e0bffd17 	ldw	r2,-12(fp)
8113fba8:	e0ffff0b 	ldhu	r3,-4(fp)
8113fbac:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113fbb0:	e0bffd17 	ldw	r2,-12(fp)
8113fbb4:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113fbb8:	e0bffd17 	ldw	r2,-12(fp)
8113fbbc:	00c00fc4 	movi	r3,63
8113fbc0:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113fbc4:	e0bffd17 	ldw	r2,-12(fp)
8113fbc8:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113fbcc:	e13ffd17 	ldw	r4,-12(fp)
8113fbd0:	113aaa00 	call	8113aaa0 <OS_EventWaitListInit>
    }
    return (pevent);
8113fbd4:	e0bffd17 	ldw	r2,-12(fp)
}
8113fbd8:	e037883a 	mov	sp,fp
8113fbdc:	dfc00117 	ldw	ra,4(sp)
8113fbe0:	df000017 	ldw	fp,0(sp)
8113fbe4:	dec00204 	addi	sp,sp,8
8113fbe8:	f800283a 	ret

8113fbec <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113fbec:	defff304 	addi	sp,sp,-52
8113fbf0:	de00012e 	bgeu	sp,et,8113fbf8 <OSSemDel+0xc>
8113fbf4:	003b68fa 	trap	3
8113fbf8:	dfc00c15 	stw	ra,48(sp)
8113fbfc:	df000b15 	stw	fp,44(sp)
8113fc00:	df000b04 	addi	fp,sp,44
8113fc04:	e13ffd15 	stw	r4,-12(fp)
8113fc08:	2805883a 	mov	r2,r5
8113fc0c:	e1bfff15 	stw	r6,-4(fp)
8113fc10:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113fc14:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113fc18:	e0bfff17 	ldw	r2,-4(fp)
8113fc1c:	1000021e 	bne	r2,zero,8113fc28 <OSSemDel+0x3c>
        return (pevent);
8113fc20:	e0bffd17 	ldw	r2,-12(fp)
8113fc24:	00007e06 	br	8113fe20 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113fc28:	e0bffd17 	ldw	r2,-12(fp)
8113fc2c:	1000051e 	bne	r2,zero,8113fc44 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113fc30:	e0bfff17 	ldw	r2,-4(fp)
8113fc34:	00c00104 	movi	r3,4
8113fc38:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113fc3c:	e0bffd17 	ldw	r2,-12(fp)
8113fc40:	00007706 	br	8113fe20 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113fc44:	e0bffd17 	ldw	r2,-12(fp)
8113fc48:	10800003 	ldbu	r2,0(r2)
8113fc4c:	10803fcc 	andi	r2,r2,255
8113fc50:	108000e0 	cmpeqi	r2,r2,3
8113fc54:	1000051e 	bne	r2,zero,8113fc6c <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113fc58:	e0bfff17 	ldw	r2,-4(fp)
8113fc5c:	00c00044 	movi	r3,1
8113fc60:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113fc64:	e0bffd17 	ldw	r2,-12(fp)
8113fc68:	00006d06 	br	8113fe20 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113fc6c:	d0a0a103 	ldbu	r2,-32124(gp)
8113fc70:	10803fcc 	andi	r2,r2,255
8113fc74:	10000526 	beq	r2,zero,8113fc8c <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113fc78:	e0bfff17 	ldw	r2,-4(fp)
8113fc7c:	00c003c4 	movi	r3,15
8113fc80:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113fc84:	e0bffd17 	ldw	r2,-12(fp)
8113fc88:	00006506 	br	8113fe20 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fc8c:	0005303a 	rdctl	r2,status
8113fc90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fc94:	e0fffc17 	ldw	r3,-16(fp)
8113fc98:	00bfff84 	movi	r2,-2
8113fc9c:	1884703a 	and	r2,r3,r2
8113fca0:	1001703a 	wrctl	status,r2
  
  return context;
8113fca4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fca8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113fcac:	e0bffd17 	ldw	r2,-12(fp)
8113fcb0:	10800283 	ldbu	r2,10(r2)
8113fcb4:	10803fcc 	andi	r2,r2,255
8113fcb8:	10000326 	beq	r2,zero,8113fcc8 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113fcbc:	00800044 	movi	r2,1
8113fcc0:	e0bff505 	stb	r2,-44(fp)
8113fcc4:	00000106 	br	8113fccc <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113fcc8:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113fccc:	e0bffe03 	ldbu	r2,-8(fp)
8113fcd0:	10000326 	beq	r2,zero,8113fce0 <OSSemDel+0xf4>
8113fcd4:	10800060 	cmpeqi	r2,r2,1
8113fcd8:	1000281e 	bne	r2,zero,8113fd7c <OSSemDel+0x190>
8113fcdc:	00004506 	br	8113fdf4 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113fce0:	e0bff503 	ldbu	r2,-44(fp)
8113fce4:	1000161e 	bne	r2,zero,8113fd40 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113fce8:	e0bffd17 	ldw	r2,-12(fp)
8113fcec:	00c00fc4 	movi	r3,63
8113fcf0:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113fcf4:	e0bffd17 	ldw	r2,-12(fp)
8113fcf8:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113fcfc:	e0bffd17 	ldw	r2,-12(fp)
8113fd00:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113fd04:	d0e0a017 	ldw	r3,-32128(gp)
8113fd08:	e0bffd17 	ldw	r2,-12(fp)
8113fd0c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113fd10:	e0bffd17 	ldw	r2,-12(fp)
8113fd14:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113fd18:	e0bffd17 	ldw	r2,-12(fp)
8113fd1c:	d0a0a015 	stw	r2,-32128(gp)
8113fd20:	e0bff717 	ldw	r2,-36(fp)
8113fd24:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fd28:	e0bff817 	ldw	r2,-32(fp)
8113fd2c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113fd30:	e0bfff17 	ldw	r2,-4(fp)
8113fd34:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113fd38:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113fd3c:	00003706 	br	8113fe1c <OSSemDel+0x230>
8113fd40:	e0bff717 	ldw	r2,-36(fp)
8113fd44:	e0bff915 	stw	r2,-28(fp)
8113fd48:	e0bff917 	ldw	r2,-28(fp)
8113fd4c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113fd50:	e0bfff17 	ldw	r2,-4(fp)
8113fd54:	00c01244 	movi	r3,73
8113fd58:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113fd5c:	e0bffd17 	ldw	r2,-12(fp)
8113fd60:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113fd64:	00002d06 	br	8113fe1c <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113fd68:	000f883a 	mov	r7,zero
8113fd6c:	01800044 	movi	r6,1
8113fd70:	000b883a 	mov	r5,zero
8113fd74:	e13ffd17 	ldw	r4,-12(fp)
8113fd78:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113fd7c:	e0bffd17 	ldw	r2,-12(fp)
8113fd80:	10800283 	ldbu	r2,10(r2)
8113fd84:	10803fcc 	andi	r2,r2,255
8113fd88:	103ff71e 	bne	r2,zero,8113fd68 <__reset+0xfb11fd68>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113fd8c:	e0bffd17 	ldw	r2,-12(fp)
8113fd90:	00c00fc4 	movi	r3,63
8113fd94:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113fd98:	e0bffd17 	ldw	r2,-12(fp)
8113fd9c:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113fda0:	e0bffd17 	ldw	r2,-12(fp)
8113fda4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113fda8:	d0e0a017 	ldw	r3,-32128(gp)
8113fdac:	e0bffd17 	ldw	r2,-12(fp)
8113fdb0:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113fdb4:	e0bffd17 	ldw	r2,-12(fp)
8113fdb8:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113fdbc:	e0bffd17 	ldw	r2,-12(fp)
8113fdc0:	d0a0a015 	stw	r2,-32128(gp)
8113fdc4:	e0bff717 	ldw	r2,-36(fp)
8113fdc8:	e0bffa15 	stw	r2,-24(fp)
8113fdcc:	e0bffa17 	ldw	r2,-24(fp)
8113fdd0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113fdd4:	e0bff503 	ldbu	r2,-44(fp)
8113fdd8:	10800058 	cmpnei	r2,r2,1
8113fddc:	1000011e 	bne	r2,zero,8113fde4 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113fde0:	113af840 	call	8113af84 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113fde4:	e0bfff17 	ldw	r2,-4(fp)
8113fde8:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113fdec:	e03ff615 	stw	zero,-40(fp)
             break;
8113fdf0:	00000a06 	br	8113fe1c <OSSemDel+0x230>
8113fdf4:	e0bff717 	ldw	r2,-36(fp)
8113fdf8:	e0bffb15 	stw	r2,-20(fp)
8113fdfc:	e0bffb17 	ldw	r2,-20(fp)
8113fe00:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113fe04:	e0bfff17 	ldw	r2,-4(fp)
8113fe08:	00c001c4 	movi	r3,7
8113fe0c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113fe10:	e0bffd17 	ldw	r2,-12(fp)
8113fe14:	e0bff615 	stw	r2,-40(fp)
             break;
8113fe18:	0001883a 	nop
    }
    return (pevent_return);
8113fe1c:	e0bff617 	ldw	r2,-40(fp)
}
8113fe20:	e037883a 	mov	sp,fp
8113fe24:	dfc00117 	ldw	ra,4(sp)
8113fe28:	df000017 	ldw	fp,0(sp)
8113fe2c:	dec00204 	addi	sp,sp,8
8113fe30:	f800283a 	ret

8113fe34 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113fe34:	defff504 	addi	sp,sp,-44
8113fe38:	de00012e 	bgeu	sp,et,8113fe40 <OSSemPend+0xc>
8113fe3c:	003b68fa 	trap	3
8113fe40:	dfc00a15 	stw	ra,40(sp)
8113fe44:	df000915 	stw	fp,36(sp)
8113fe48:	df000904 	addi	fp,sp,36
8113fe4c:	e13ffd15 	stw	r4,-12(fp)
8113fe50:	2805883a 	mov	r2,r5
8113fe54:	e1bfff15 	stw	r6,-4(fp)
8113fe58:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fe5c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113fe60:	e0bfff17 	ldw	r2,-4(fp)
8113fe64:	10007226 	beq	r2,zero,81140030 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113fe68:	e0bffd17 	ldw	r2,-12(fp)
8113fe6c:	1000041e 	bne	r2,zero,8113fe80 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113fe70:	e0bfff17 	ldw	r2,-4(fp)
8113fe74:	00c00104 	movi	r3,4
8113fe78:	10c00005 	stb	r3,0(r2)
        return;
8113fe7c:	00006d06 	br	81140034 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113fe80:	e0bffd17 	ldw	r2,-12(fp)
8113fe84:	10800003 	ldbu	r2,0(r2)
8113fe88:	10803fcc 	andi	r2,r2,255
8113fe8c:	108000e0 	cmpeqi	r2,r2,3
8113fe90:	1000041e 	bne	r2,zero,8113fea4 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113fe94:	e0bfff17 	ldw	r2,-4(fp)
8113fe98:	00c00044 	movi	r3,1
8113fe9c:	10c00005 	stb	r3,0(r2)
        return;
8113fea0:	00006406 	br	81140034 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113fea4:	d0a0a103 	ldbu	r2,-32124(gp)
8113fea8:	10803fcc 	andi	r2,r2,255
8113feac:	10000426 	beq	r2,zero,8113fec0 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113feb0:	e0bfff17 	ldw	r2,-4(fp)
8113feb4:	00c00084 	movi	r3,2
8113feb8:	10c00005 	stb	r3,0(r2)
        return;
8113febc:	00005d06 	br	81140034 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113fec0:	d0a08f03 	ldbu	r2,-32196(gp)
8113fec4:	10803fcc 	andi	r2,r2,255
8113fec8:	10000426 	beq	r2,zero,8113fedc <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113fecc:	e0bfff17 	ldw	r2,-4(fp)
8113fed0:	00c00344 	movi	r3,13
8113fed4:	10c00005 	stb	r3,0(r2)
        return;
8113fed8:	00005606 	br	81140034 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fedc:	0005303a 	rdctl	r2,status
8113fee0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fee4:	e0fffc17 	ldw	r3,-16(fp)
8113fee8:	00bfff84 	movi	r2,-2
8113feec:	1884703a 	and	r2,r3,r2
8113fef0:	1001703a 	wrctl	status,r2
  
  return context;
8113fef4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fef8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113fefc:	e0bffd17 	ldw	r2,-12(fp)
8113ff00:	1080020b 	ldhu	r2,8(r2)
8113ff04:	10bfffcc 	andi	r2,r2,65535
8113ff08:	10000d26 	beq	r2,zero,8113ff40 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113ff0c:	e0bffd17 	ldw	r2,-12(fp)
8113ff10:	1080020b 	ldhu	r2,8(r2)
8113ff14:	10bfffc4 	addi	r2,r2,-1
8113ff18:	1007883a 	mov	r3,r2
8113ff1c:	e0bffd17 	ldw	r2,-12(fp)
8113ff20:	10c0020d 	sth	r3,8(r2)
8113ff24:	e0bff717 	ldw	r2,-36(fp)
8113ff28:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ff2c:	e0bff817 	ldw	r2,-32(fp)
8113ff30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113ff34:	e0bfff17 	ldw	r2,-4(fp)
8113ff38:	10000005 	stb	zero,0(r2)
        return;
8113ff3c:	00003d06 	br	81140034 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113ff40:	d0a0a217 	ldw	r2,-32120(gp)
8113ff44:	d0e0a217 	ldw	r3,-32120(gp)
8113ff48:	18c00c03 	ldbu	r3,48(r3)
8113ff4c:	18c00054 	ori	r3,r3,1
8113ff50:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ff54:	d0a0a217 	ldw	r2,-32120(gp)
8113ff58:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113ff5c:	d0a0a217 	ldw	r2,-32120(gp)
8113ff60:	e0fffe0b 	ldhu	r3,-8(fp)
8113ff64:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113ff68:	e13ffd17 	ldw	r4,-12(fp)
8113ff6c:	113a6680 	call	8113a668 <OS_EventTaskWait>
8113ff70:	e0bff717 	ldw	r2,-36(fp)
8113ff74:	e0bffb15 	stw	r2,-20(fp)
8113ff78:	e0bffb17 	ldw	r2,-20(fp)
8113ff7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113ff80:	113af840 	call	8113af84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ff84:	0005303a 	rdctl	r2,status
8113ff88:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ff8c:	e0fff917 	ldw	r3,-28(fp)
8113ff90:	00bfff84 	movi	r2,-2
8113ff94:	1884703a 	and	r2,r3,r2
8113ff98:	1001703a 	wrctl	status,r2
  
  return context;
8113ff9c:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113ffa0:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113ffa4:	d0a0a217 	ldw	r2,-32120(gp)
8113ffa8:	10800c43 	ldbu	r2,49(r2)
8113ffac:	10803fcc 	andi	r2,r2,255
8113ffb0:	10000326 	beq	r2,zero,8113ffc0 <OSSemPend+0x18c>
8113ffb4:	108000a0 	cmpeqi	r2,r2,2
8113ffb8:	1000041e 	bne	r2,zero,8113ffcc <OSSemPend+0x198>
8113ffbc:	00000706 	br	8113ffdc <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113ffc0:	e0bfff17 	ldw	r2,-4(fp)
8113ffc4:	10000005 	stb	zero,0(r2)
             break;
8113ffc8:	00000c06 	br	8113fffc <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113ffcc:	e0bfff17 	ldw	r2,-4(fp)
8113ffd0:	00c00384 	movi	r3,14
8113ffd4:	10c00005 	stb	r3,0(r2)
             break;
8113ffd8:	00000806 	br	8113fffc <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ffdc:	d0a0a217 	ldw	r2,-32120(gp)
8113ffe0:	e17ffd17 	ldw	r5,-12(fp)
8113ffe4:	1009883a 	mov	r4,r2
8113ffe8:	113a8d80 	call	8113a8d8 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113ffec:	e0bfff17 	ldw	r2,-4(fp)
8113fff0:	00c00284 	movi	r3,10
8113fff4:	10c00005 	stb	r3,0(r2)
             break;
8113fff8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113fffc:	d0a0a217 	ldw	r2,-32120(gp)
81140000:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81140004:	d0a0a217 	ldw	r2,-32120(gp)
81140008:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8114000c:	d0a0a217 	ldw	r2,-32120(gp)
81140010:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81140014:	d0a0a217 	ldw	r2,-32120(gp)
81140018:	10000815 	stw	zero,32(r2)
8114001c:	e0bff717 	ldw	r2,-36(fp)
81140020:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140024:	e0bffa17 	ldw	r2,-24(fp)
81140028:	1001703a 	wrctl	status,r2
8114002c:	00000106 	br	81140034 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81140030:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81140034:	e037883a 	mov	sp,fp
81140038:	dfc00117 	ldw	ra,4(sp)
8114003c:	df000017 	ldw	fp,0(sp)
81140040:	dec00204 	addi	sp,sp,8
81140044:	f800283a 	ret

81140048 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81140048:	defff604 	addi	sp,sp,-40
8114004c:	de00012e 	bgeu	sp,et,81140054 <OSSemPendAbort+0xc>
81140050:	003b68fa 	trap	3
81140054:	dfc00915 	stw	ra,36(sp)
81140058:	df000815 	stw	fp,32(sp)
8114005c:	df000804 	addi	fp,sp,32
81140060:	e13ffd15 	stw	r4,-12(fp)
81140064:	2805883a 	mov	r2,r5
81140068:	e1bfff15 	stw	r6,-4(fp)
8114006c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140070:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81140074:	e0bfff17 	ldw	r2,-4(fp)
81140078:	1000021e 	bne	r2,zero,81140084 <OSSemPendAbort+0x3c>
        return (0);
8114007c:	0005883a 	mov	r2,zero
81140080:	00004906 	br	811401a8 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140084:	e0bffd17 	ldw	r2,-12(fp)
81140088:	1000051e 	bne	r2,zero,811400a0 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8114008c:	e0bfff17 	ldw	r2,-4(fp)
81140090:	00c00104 	movi	r3,4
81140094:	10c00005 	stb	r3,0(r2)
        return (0);
81140098:	0005883a 	mov	r2,zero
8114009c:	00004206 	br	811401a8 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811400a0:	e0bffd17 	ldw	r2,-12(fp)
811400a4:	10800003 	ldbu	r2,0(r2)
811400a8:	10803fcc 	andi	r2,r2,255
811400ac:	108000e0 	cmpeqi	r2,r2,3
811400b0:	1000051e 	bne	r2,zero,811400c8 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811400b4:	e0bfff17 	ldw	r2,-4(fp)
811400b8:	00c00044 	movi	r3,1
811400bc:	10c00005 	stb	r3,0(r2)
        return (0);
811400c0:	0005883a 	mov	r2,zero
811400c4:	00003806 	br	811401a8 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811400c8:	0005303a 	rdctl	r2,status
811400cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811400d0:	e0fffc17 	ldw	r3,-16(fp)
811400d4:	00bfff84 	movi	r2,-2
811400d8:	1884703a 	and	r2,r3,r2
811400dc:	1001703a 	wrctl	status,r2
  
  return context;
811400e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811400e4:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
811400e8:	e0bffd17 	ldw	r2,-12(fp)
811400ec:	10800283 	ldbu	r2,10(r2)
811400f0:	10803fcc 	andi	r2,r2,255
811400f4:	10002526 	beq	r2,zero,8114018c <OSSemPendAbort+0x144>
        nbr_tasks = 0;
811400f8:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
811400fc:	e0bffe03 	ldbu	r2,-8(fp)
81140100:	10800060 	cmpeqi	r2,r2,1
81140104:	10000e26 	beq	r2,zero,81140140 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81140108:	00000806 	br	8114012c <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8114010c:	01c00084 	movi	r7,2
81140110:	01800044 	movi	r6,1
81140114:	000b883a 	mov	r5,zero
81140118:	e13ffd17 	ldw	r4,-12(fp)
8114011c:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
                     nbr_tasks++;
81140120:	e0bff803 	ldbu	r2,-32(fp)
81140124:	10800044 	addi	r2,r2,1
81140128:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8114012c:	e0bffd17 	ldw	r2,-12(fp)
81140130:	10800283 	ldbu	r2,10(r2)
81140134:	10803fcc 	andi	r2,r2,255
81140138:	103ff41e 	bne	r2,zero,8114010c <__reset+0xfb12010c>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8114013c:	00000906 	br	81140164 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81140140:	01c00084 	movi	r7,2
81140144:	01800044 	movi	r6,1
81140148:	000b883a 	mov	r5,zero
8114014c:	e13ffd17 	ldw	r4,-12(fp)
81140150:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
                 nbr_tasks++;
81140154:	e0bff803 	ldbu	r2,-32(fp)
81140158:	10800044 	addi	r2,r2,1
8114015c:	e0bff805 	stb	r2,-32(fp)
                 break;
81140160:	0001883a 	nop
81140164:	e0bff917 	ldw	r2,-28(fp)
81140168:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114016c:	e0bffa17 	ldw	r2,-24(fp)
81140170:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81140174:	113af840 	call	8113af84 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81140178:	e0bfff17 	ldw	r2,-4(fp)
8114017c:	00c00384 	movi	r3,14
81140180:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81140184:	e0bff803 	ldbu	r2,-32(fp)
81140188:	00000706 	br	811401a8 <OSSemPendAbort+0x160>
8114018c:	e0bff917 	ldw	r2,-28(fp)
81140190:	e0bffb15 	stw	r2,-20(fp)
81140194:	e0bffb17 	ldw	r2,-20(fp)
81140198:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8114019c:	e0bfff17 	ldw	r2,-4(fp)
811401a0:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
811401a4:	0005883a 	mov	r2,zero
}
811401a8:	e037883a 	mov	sp,fp
811401ac:	dfc00117 	ldw	ra,4(sp)
811401b0:	df000017 	ldw	fp,0(sp)
811401b4:	dec00204 	addi	sp,sp,8
811401b8:	f800283a 	ret

811401bc <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
811401bc:	defff804 	addi	sp,sp,-32
811401c0:	de00012e 	bgeu	sp,et,811401c8 <OSSemPost+0xc>
811401c4:	003b68fa 	trap	3
811401c8:	dfc00715 	stw	ra,28(sp)
811401cc:	df000615 	stw	fp,24(sp)
811401d0:	df000604 	addi	fp,sp,24
811401d4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811401d8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811401dc:	e0bfff17 	ldw	r2,-4(fp)
811401e0:	1000021e 	bne	r2,zero,811401ec <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
811401e4:	00800104 	movi	r2,4
811401e8:	00003506 	br	811402c0 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811401ec:	e0bfff17 	ldw	r2,-4(fp)
811401f0:	10800003 	ldbu	r2,0(r2)
811401f4:	10803fcc 	andi	r2,r2,255
811401f8:	108000e0 	cmpeqi	r2,r2,3
811401fc:	1000021e 	bne	r2,zero,81140208 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81140200:	00800044 	movi	r2,1
81140204:	00002e06 	br	811402c0 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140208:	0005303a 	rdctl	r2,status
8114020c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140210:	e0fffe17 	ldw	r3,-8(fp)
81140214:	00bfff84 	movi	r2,-2
81140218:	1884703a 	and	r2,r3,r2
8114021c:	1001703a 	wrctl	status,r2
  
  return context;
81140220:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140224:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81140228:	e0bfff17 	ldw	r2,-4(fp)
8114022c:	10800283 	ldbu	r2,10(r2)
81140230:	10803fcc 	andi	r2,r2,255
81140234:	10000c26 	beq	r2,zero,81140268 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81140238:	000f883a 	mov	r7,zero
8114023c:	01800044 	movi	r6,1
81140240:	000b883a 	mov	r5,zero
81140244:	e13fff17 	ldw	r4,-4(fp)
81140248:	113a4c80 	call	8113a4c8 <OS_EventTaskRdy>
8114024c:	e0bffa17 	ldw	r2,-24(fp)
81140250:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140254:	e0bffb17 	ldw	r2,-20(fp)
81140258:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8114025c:	113af840 	call	8113af84 <OS_Sched>
        return (OS_ERR_NONE);
81140260:	0005883a 	mov	r2,zero
81140264:	00001606 	br	811402c0 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81140268:	e0bfff17 	ldw	r2,-4(fp)
8114026c:	1080020b 	ldhu	r2,8(r2)
81140270:	10ffffcc 	andi	r3,r2,65535
81140274:	00bfffd4 	movui	r2,65535
81140278:	18800c26 	beq	r3,r2,811402ac <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8114027c:	e0bfff17 	ldw	r2,-4(fp)
81140280:	1080020b 	ldhu	r2,8(r2)
81140284:	10800044 	addi	r2,r2,1
81140288:	1007883a 	mov	r3,r2
8114028c:	e0bfff17 	ldw	r2,-4(fp)
81140290:	10c0020d 	sth	r3,8(r2)
81140294:	e0bffa17 	ldw	r2,-24(fp)
81140298:	e0bffc15 	stw	r2,-16(fp)
8114029c:	e0bffc17 	ldw	r2,-16(fp)
811402a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
811402a4:	0005883a 	mov	r2,zero
811402a8:	00000506 	br	811402c0 <OSSemPost+0x104>
811402ac:	e0bffa17 	ldw	r2,-24(fp)
811402b0:	e0bffd15 	stw	r2,-12(fp)
811402b4:	e0bffd17 	ldw	r2,-12(fp)
811402b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
811402bc:	00800c84 	movi	r2,50
}
811402c0:	e037883a 	mov	sp,fp
811402c4:	dfc00117 	ldw	ra,4(sp)
811402c8:	df000017 	ldw	fp,0(sp)
811402cc:	dec00204 	addi	sp,sp,8
811402d0:	f800283a 	ret

811402d4 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
811402d4:	defff704 	addi	sp,sp,-36
811402d8:	de00012e 	bgeu	sp,et,811402e0 <OSSemQuery+0xc>
811402dc:	003b68fa 	trap	3
811402e0:	df000815 	stw	fp,32(sp)
811402e4:	df000804 	addi	fp,sp,32
811402e8:	e13ffe15 	stw	r4,-8(fp)
811402ec:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811402f0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811402f4:	e0bffe17 	ldw	r2,-8(fp)
811402f8:	1000021e 	bne	r2,zero,81140304 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
811402fc:	00800104 	movi	r2,4
81140300:	00003606 	br	811403dc <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
81140304:	e0bfff17 	ldw	r2,-4(fp)
81140308:	1000021e 	bne	r2,zero,81140314 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8114030c:	00800244 	movi	r2,9
81140310:	00003206 	br	811403dc <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81140314:	e0bffe17 	ldw	r2,-8(fp)
81140318:	10800003 	ldbu	r2,0(r2)
8114031c:	10803fcc 	andi	r2,r2,255
81140320:	108000e0 	cmpeqi	r2,r2,3
81140324:	1000021e 	bne	r2,zero,81140330 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81140328:	00800044 	movi	r2,1
8114032c:	00002b06 	br	811403dc <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140330:	0005303a 	rdctl	r2,status
81140334:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140338:	e0fffd17 	ldw	r3,-12(fp)
8114033c:	00bfff84 	movi	r2,-2
81140340:	1884703a 	and	r2,r3,r2
81140344:	1001703a 	wrctl	status,r2
  
  return context;
81140348:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8114034c:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81140350:	e0bffe17 	ldw	r2,-8(fp)
81140354:	10c00283 	ldbu	r3,10(r2)
81140358:	e0bfff17 	ldw	r2,-4(fp)
8114035c:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81140360:	e0bffe17 	ldw	r2,-8(fp)
81140364:	108002c4 	addi	r2,r2,11
81140368:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8114036c:	e0bfff17 	ldw	r2,-4(fp)
81140370:	10800084 	addi	r2,r2,2
81140374:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81140378:	e03ffa05 	stb	zero,-24(fp)
8114037c:	00000b06 	br	811403ac <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81140380:	e0bff917 	ldw	r2,-28(fp)
81140384:	10c00044 	addi	r3,r2,1
81140388:	e0fff915 	stw	r3,-28(fp)
8114038c:	e0fff817 	ldw	r3,-32(fp)
81140390:	19000044 	addi	r4,r3,1
81140394:	e13ff815 	stw	r4,-32(fp)
81140398:	18c00003 	ldbu	r3,0(r3)
8114039c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811403a0:	e0bffa03 	ldbu	r2,-24(fp)
811403a4:	10800044 	addi	r2,r2,1
811403a8:	e0bffa05 	stb	r2,-24(fp)
811403ac:	e0bffa03 	ldbu	r2,-24(fp)
811403b0:	108001b0 	cmpltui	r2,r2,6
811403b4:	103ff21e 	bne	r2,zero,81140380 <__reset+0xfb120380>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
811403b8:	e0bffe17 	ldw	r2,-8(fp)
811403bc:	10c0020b 	ldhu	r3,8(r2)
811403c0:	e0bfff17 	ldw	r2,-4(fp)
811403c4:	10c0000d 	sth	r3,0(r2)
811403c8:	e0bffb17 	ldw	r2,-20(fp)
811403cc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811403d0:	e0bffc17 	ldw	r2,-16(fp)
811403d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811403d8:	0005883a 	mov	r2,zero
}
811403dc:	e037883a 	mov	sp,fp
811403e0:	df000017 	ldw	fp,0(sp)
811403e4:	dec00104 	addi	sp,sp,4
811403e8:	f800283a 	ret

811403ec <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
811403ec:	defff904 	addi	sp,sp,-28
811403f0:	de00012e 	bgeu	sp,et,811403f8 <OSSemSet+0xc>
811403f4:	003b68fa 	trap	3
811403f8:	df000615 	stw	fp,24(sp)
811403fc:	df000604 	addi	fp,sp,24
81140400:	e13ffd15 	stw	r4,-12(fp)
81140404:	2805883a 	mov	r2,r5
81140408:	e1bfff15 	stw	r6,-4(fp)
8114040c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140410:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81140414:	e0bfff17 	ldw	r2,-4(fp)
81140418:	10003126 	beq	r2,zero,811404e0 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8114041c:	e0bffd17 	ldw	r2,-12(fp)
81140420:	1000041e 	bne	r2,zero,81140434 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81140424:	e0bfff17 	ldw	r2,-4(fp)
81140428:	00c00104 	movi	r3,4
8114042c:	10c00005 	stb	r3,0(r2)
        return;
81140430:	00002c06 	br	811404e4 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140434:	e0bffd17 	ldw	r2,-12(fp)
81140438:	10800003 	ldbu	r2,0(r2)
8114043c:	10803fcc 	andi	r2,r2,255
81140440:	108000e0 	cmpeqi	r2,r2,3
81140444:	1000041e 	bne	r2,zero,81140458 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81140448:	e0bfff17 	ldw	r2,-4(fp)
8114044c:	00c00044 	movi	r3,1
81140450:	10c00005 	stb	r3,0(r2)
        return;
81140454:	00002306 	br	811404e4 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140458:	0005303a 	rdctl	r2,status
8114045c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140460:	e0fffc17 	ldw	r3,-16(fp)
81140464:	00bfff84 	movi	r2,-2
81140468:	1884703a 	and	r2,r3,r2
8114046c:	1001703a 	wrctl	status,r2
  
  return context;
81140470:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140474:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81140478:	e0bfff17 	ldw	r2,-4(fp)
8114047c:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81140480:	e0bffd17 	ldw	r2,-12(fp)
81140484:	1080020b 	ldhu	r2,8(r2)
81140488:	10bfffcc 	andi	r2,r2,65535
8114048c:	10000426 	beq	r2,zero,811404a0 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81140490:	e0bffd17 	ldw	r2,-12(fp)
81140494:	e0fffe0b 	ldhu	r3,-8(fp)
81140498:	10c0020d 	sth	r3,8(r2)
8114049c:	00000b06 	br	811404cc <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
811404a0:	e0bffd17 	ldw	r2,-12(fp)
811404a4:	10800283 	ldbu	r2,10(r2)
811404a8:	10803fcc 	andi	r2,r2,255
811404ac:	1000041e 	bne	r2,zero,811404c0 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
811404b0:	e0bffd17 	ldw	r2,-12(fp)
811404b4:	e0fffe0b 	ldhu	r3,-8(fp)
811404b8:	10c0020d 	sth	r3,8(r2)
811404bc:	00000306 	br	811404cc <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
811404c0:	e0bfff17 	ldw	r2,-4(fp)
811404c4:	00c01244 	movi	r3,73
811404c8:	10c00005 	stb	r3,0(r2)
811404cc:	e0bffa17 	ldw	r2,-24(fp)
811404d0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811404d4:	e0bffb17 	ldw	r2,-20(fp)
811404d8:	1001703a 	wrctl	status,r2
811404dc:	00000106 	br	811404e4 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
811404e0:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
811404e4:	e037883a 	mov	sp,fp
811404e8:	df000017 	ldw	fp,0(sp)
811404ec:	dec00104 	addi	sp,sp,4
811404f0:	f800283a 	ret

811404f4 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
811404f4:	defff104 	addi	sp,sp,-60
811404f8:	de00012e 	bgeu	sp,et,81140500 <OSTaskChangePrio+0xc>
811404fc:	003b68fa 	trap	3
81140500:	dfc00e15 	stw	ra,56(sp)
81140504:	df000d15 	stw	fp,52(sp)
81140508:	df000d04 	addi	fp,sp,52
8114050c:	2007883a 	mov	r3,r4
81140510:	2805883a 	mov	r2,r5
81140514:	e0fffe05 	stb	r3,-8(fp)
81140518:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8114051c:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81140520:	e0bffe03 	ldbu	r2,-8(fp)
81140524:	10800ab0 	cmpltui	r2,r2,42
81140528:	1000051e 	bne	r2,zero,81140540 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8114052c:	e0bffe03 	ldbu	r2,-8(fp)
81140530:	10803fe0 	cmpeqi	r2,r2,255
81140534:	1000021e 	bne	r2,zero,81140540 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81140538:	00800a84 	movi	r2,42
8114053c:	00012606 	br	811409d8 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81140540:	e0bfff03 	ldbu	r2,-4(fp)
81140544:	10800ab0 	cmpltui	r2,r2,42
81140548:	1000021e 	bne	r2,zero,81140554 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8114054c:	00800a84 	movi	r2,42
81140550:	00012106 	br	811409d8 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140554:	0005303a 	rdctl	r2,status
81140558:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114055c:	e0fffd17 	ldw	r3,-12(fp)
81140560:	00bfff84 	movi	r2,-2
81140564:	1884703a 	and	r2,r3,r2
81140568:	1001703a 	wrctl	status,r2
  
  return context;
8114056c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140570:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
81140574:	e0ffff03 	ldbu	r3,-4(fp)
81140578:	00a045f4 	movhi	r2,33047
8114057c:	10b81c04 	addi	r2,r2,-8080
81140580:	18c7883a 	add	r3,r3,r3
81140584:	18c7883a 	add	r3,r3,r3
81140588:	10c5883a 	add	r2,r2,r3
8114058c:	10800017 	ldw	r2,0(r2)
81140590:	10000626 	beq	r2,zero,811405ac <OSTaskChangePrio+0xb8>
81140594:	e0bff517 	ldw	r2,-44(fp)
81140598:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114059c:	e0bff617 	ldw	r2,-40(fp)
811405a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
811405a4:	00800a04 	movi	r2,40
811405a8:	00010b06 	br	811409d8 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
811405ac:	e0bffe03 	ldbu	r2,-8(fp)
811405b0:	10803fd8 	cmpnei	r2,r2,255
811405b4:	1000031e 	bne	r2,zero,811405c4 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
811405b8:	d0a0a217 	ldw	r2,-32120(gp)
811405bc:	10800c83 	ldbu	r2,50(r2)
811405c0:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
811405c4:	e0fffe03 	ldbu	r3,-8(fp)
811405c8:	00a045f4 	movhi	r2,33047
811405cc:	10b81c04 	addi	r2,r2,-8080
811405d0:	18c7883a 	add	r3,r3,r3
811405d4:	18c7883a 	add	r3,r3,r3
811405d8:	10c5883a 	add	r2,r2,r3
811405dc:	10800017 	ldw	r2,0(r2)
811405e0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
811405e4:	e0bff817 	ldw	r2,-32(fp)
811405e8:	1000061e 	bne	r2,zero,81140604 <OSTaskChangePrio+0x110>
811405ec:	e0bff517 	ldw	r2,-44(fp)
811405f0:	e0bff715 	stw	r2,-36(fp)
811405f4:	e0bff717 	ldw	r2,-36(fp)
811405f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
811405fc:	00800a44 	movi	r2,41
81140600:	0000f506 	br	811409d8 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
81140604:	e0bff817 	ldw	r2,-32(fp)
81140608:	10800058 	cmpnei	r2,r2,1
8114060c:	1000061e 	bne	r2,zero,81140628 <OSTaskChangePrio+0x134>
81140610:	e0bff517 	ldw	r2,-44(fp)
81140614:	e0bff915 	stw	r2,-28(fp)
81140618:	e0bff917 	ldw	r2,-28(fp)
8114061c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81140620:	008010c4 	movi	r2,67
81140624:	0000ec06 	br	811409d8 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81140628:	e0bfff03 	ldbu	r2,-4(fp)
8114062c:	1004d0fa 	srli	r2,r2,3
81140630:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
81140634:	e0bfff03 	ldbu	r2,-4(fp)
81140638:	108001cc 	andi	r2,r2,7
8114063c:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81140640:	e0bffb03 	ldbu	r2,-20(fp)
81140644:	00c00044 	movi	r3,1
81140648:	1884983a 	sll	r2,r3,r2
8114064c:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81140650:	e0bffb43 	ldbu	r2,-19(fp)
81140654:	00c00044 	movi	r3,1
81140658:	1884983a 	sll	r2,r3,r2
8114065c:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81140660:	e0fffe03 	ldbu	r3,-8(fp)
81140664:	00a045f4 	movhi	r2,33047
81140668:	10b81c04 	addi	r2,r2,-8080
8114066c:	18c7883a 	add	r3,r3,r3
81140670:	18c7883a 	add	r3,r3,r3
81140674:	10c5883a 	add	r2,r2,r3
81140678:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8114067c:	e0ffff03 	ldbu	r3,-4(fp)
81140680:	00a045f4 	movhi	r2,33047
81140684:	10b81c04 	addi	r2,r2,-8080
81140688:	18c7883a 	add	r3,r3,r3
8114068c:	18c7883a 	add	r3,r3,r3
81140690:	10c5883a 	add	r2,r2,r3
81140694:	e0fff817 	ldw	r3,-32(fp)
81140698:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8114069c:	e0bff817 	ldw	r2,-32(fp)
811406a0:	10800d03 	ldbu	r2,52(r2)
811406a4:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
811406a8:	e0bff817 	ldw	r2,-32(fp)
811406ac:	10800d83 	ldbu	r2,54(r2)
811406b0:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
811406b4:	e0bff817 	ldw	r2,-32(fp)
811406b8:	10800d43 	ldbu	r2,53(r2)
811406bc:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
811406c0:	e0fffc03 	ldbu	r3,-16(fp)
811406c4:	d0a09e44 	addi	r2,gp,-32135
811406c8:	1885883a 	add	r2,r3,r2
811406cc:	10c00003 	ldbu	r3,0(r2)
811406d0:	e0bffc83 	ldbu	r2,-14(fp)
811406d4:	1884703a 	and	r2,r3,r2
811406d8:	10803fcc 	andi	r2,r2,255
811406dc:	10002826 	beq	r2,zero,81140780 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
811406e0:	e0fffc03 	ldbu	r3,-16(fp)
811406e4:	e13ffc03 	ldbu	r4,-16(fp)
811406e8:	d0a09e44 	addi	r2,gp,-32135
811406ec:	2085883a 	add	r2,r4,r2
811406f0:	10800003 	ldbu	r2,0(r2)
811406f4:	1009883a 	mov	r4,r2
811406f8:	e0bffc83 	ldbu	r2,-14(fp)
811406fc:	0084303a 	nor	r2,zero,r2
81140700:	2084703a 	and	r2,r4,r2
81140704:	1009883a 	mov	r4,r2
81140708:	d0a09e44 	addi	r2,gp,-32135
8114070c:	1885883a 	add	r2,r3,r2
81140710:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
81140714:	e0fffc03 	ldbu	r3,-16(fp)
81140718:	d0a09e44 	addi	r2,gp,-32135
8114071c:	1885883a 	add	r2,r3,r2
81140720:	10800003 	ldbu	r2,0(r2)
81140724:	10803fcc 	andi	r2,r2,255
81140728:	1000061e 	bne	r2,zero,81140744 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8114072c:	e0bffc43 	ldbu	r2,-15(fp)
81140730:	0084303a 	nor	r2,zero,r2
81140734:	1007883a 	mov	r3,r2
81140738:	d0a09e03 	ldbu	r2,-32136(gp)
8114073c:	1884703a 	and	r2,r3,r2
81140740:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
81140744:	d0e09e03 	ldbu	r3,-32136(gp)
81140748:	e0bffb83 	ldbu	r2,-18(fp)
8114074c:	1884b03a 	or	r2,r3,r2
81140750:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
81140754:	e0fffb03 	ldbu	r3,-20(fp)
81140758:	e13ffb03 	ldbu	r4,-20(fp)
8114075c:	d0a09e44 	addi	r2,gp,-32135
81140760:	2085883a 	add	r2,r4,r2
81140764:	11000003 	ldbu	r4,0(r2)
81140768:	e0bffbc3 	ldbu	r2,-17(fp)
8114076c:	2084b03a 	or	r2,r4,r2
81140770:	1009883a 	mov	r4,r2
81140774:	d0a09e44 	addi	r2,gp,-32135
81140778:	1885883a 	add	r2,r3,r2
8114077c:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81140780:	e0bff817 	ldw	r2,-32(fp)
81140784:	10800717 	ldw	r2,28(r2)
81140788:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8114078c:	e0bff317 	ldw	r2,-52(fp)
81140790:	10003326 	beq	r2,zero,81140860 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
81140794:	e0bffc03 	ldbu	r2,-16(fp)
81140798:	e0fffc03 	ldbu	r3,-16(fp)
8114079c:	e13ff317 	ldw	r4,-52(fp)
811407a0:	20c7883a 	add	r3,r4,r3
811407a4:	18c002c4 	addi	r3,r3,11
811407a8:	18c00003 	ldbu	r3,0(r3)
811407ac:	1809883a 	mov	r4,r3
811407b0:	e0fffc83 	ldbu	r3,-14(fp)
811407b4:	00c6303a 	nor	r3,zero,r3
811407b8:	20c6703a 	and	r3,r4,r3
811407bc:	1809883a 	mov	r4,r3
811407c0:	e0fff317 	ldw	r3,-52(fp)
811407c4:	1885883a 	add	r2,r3,r2
811407c8:	108002c4 	addi	r2,r2,11
811407cc:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
811407d0:	e0bffc03 	ldbu	r2,-16(fp)
811407d4:	e0fff317 	ldw	r3,-52(fp)
811407d8:	1885883a 	add	r2,r3,r2
811407dc:	108002c4 	addi	r2,r2,11
811407e0:	10800003 	ldbu	r2,0(r2)
811407e4:	10803fcc 	andi	r2,r2,255
811407e8:	1000091e 	bne	r2,zero,81140810 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
811407ec:	e0bff317 	ldw	r2,-52(fp)
811407f0:	10800283 	ldbu	r2,10(r2)
811407f4:	1007883a 	mov	r3,r2
811407f8:	e0bffc43 	ldbu	r2,-15(fp)
811407fc:	0084303a 	nor	r2,zero,r2
81140800:	1884703a 	and	r2,r3,r2
81140804:	1007883a 	mov	r3,r2
81140808:	e0bff317 	ldw	r2,-52(fp)
8114080c:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
81140810:	e0bff317 	ldw	r2,-52(fp)
81140814:	10c00283 	ldbu	r3,10(r2)
81140818:	e0bffb83 	ldbu	r2,-18(fp)
8114081c:	1884b03a 	or	r2,r3,r2
81140820:	1007883a 	mov	r3,r2
81140824:	e0bff317 	ldw	r2,-52(fp)
81140828:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8114082c:	e0bffb03 	ldbu	r2,-20(fp)
81140830:	e0fffb03 	ldbu	r3,-20(fp)
81140834:	e13ff317 	ldw	r4,-52(fp)
81140838:	20c7883a 	add	r3,r4,r3
8114083c:	18c002c4 	addi	r3,r3,11
81140840:	19000003 	ldbu	r4,0(r3)
81140844:	e0fffbc3 	ldbu	r3,-17(fp)
81140848:	20c6b03a 	or	r3,r4,r3
8114084c:	1809883a 	mov	r4,r3
81140850:	e0fff317 	ldw	r3,-52(fp)
81140854:	1885883a 	add	r2,r3,r2
81140858:	108002c4 	addi	r2,r2,11
8114085c:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81140860:	e0bff817 	ldw	r2,-32(fp)
81140864:	10800817 	ldw	r2,32(r2)
81140868:	10004226 	beq	r2,zero,81140974 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8114086c:	e0bff817 	ldw	r2,-32(fp)
81140870:	10800817 	ldw	r2,32(r2)
81140874:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
81140878:	e0bff417 	ldw	r2,-48(fp)
8114087c:	10800017 	ldw	r2,0(r2)
81140880:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
81140884:	00003906 	br	8114096c <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
81140888:	e0bffc03 	ldbu	r2,-16(fp)
8114088c:	e0fffc03 	ldbu	r3,-16(fp)
81140890:	e13ff317 	ldw	r4,-52(fp)
81140894:	20c7883a 	add	r3,r4,r3
81140898:	18c002c4 	addi	r3,r3,11
8114089c:	18c00003 	ldbu	r3,0(r3)
811408a0:	1809883a 	mov	r4,r3
811408a4:	e0fffc83 	ldbu	r3,-14(fp)
811408a8:	00c6303a 	nor	r3,zero,r3
811408ac:	20c6703a 	and	r3,r4,r3
811408b0:	1809883a 	mov	r4,r3
811408b4:	e0fff317 	ldw	r3,-52(fp)
811408b8:	1885883a 	add	r2,r3,r2
811408bc:	108002c4 	addi	r2,r2,11
811408c0:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
811408c4:	e0bffc03 	ldbu	r2,-16(fp)
811408c8:	e0fff317 	ldw	r3,-52(fp)
811408cc:	1885883a 	add	r2,r3,r2
811408d0:	108002c4 	addi	r2,r2,11
811408d4:	10800003 	ldbu	r2,0(r2)
811408d8:	10803fcc 	andi	r2,r2,255
811408dc:	1000091e 	bne	r2,zero,81140904 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
811408e0:	e0bff317 	ldw	r2,-52(fp)
811408e4:	10800283 	ldbu	r2,10(r2)
811408e8:	1007883a 	mov	r3,r2
811408ec:	e0bffc43 	ldbu	r2,-15(fp)
811408f0:	0084303a 	nor	r2,zero,r2
811408f4:	1884703a 	and	r2,r3,r2
811408f8:	1007883a 	mov	r3,r2
811408fc:	e0bff317 	ldw	r2,-52(fp)
81140900:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
81140904:	e0bff317 	ldw	r2,-52(fp)
81140908:	10c00283 	ldbu	r3,10(r2)
8114090c:	e0bffb83 	ldbu	r2,-18(fp)
81140910:	1884b03a 	or	r2,r3,r2
81140914:	1007883a 	mov	r3,r2
81140918:	e0bff317 	ldw	r2,-52(fp)
8114091c:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
81140920:	e0bffb03 	ldbu	r2,-20(fp)
81140924:	e0fffb03 	ldbu	r3,-20(fp)
81140928:	e13ff317 	ldw	r4,-52(fp)
8114092c:	20c7883a 	add	r3,r4,r3
81140930:	18c002c4 	addi	r3,r3,11
81140934:	19000003 	ldbu	r4,0(r3)
81140938:	e0fffbc3 	ldbu	r3,-17(fp)
8114093c:	20c6b03a 	or	r3,r4,r3
81140940:	1809883a 	mov	r4,r3
81140944:	e0fff317 	ldw	r3,-52(fp)
81140948:	1885883a 	add	r2,r3,r2
8114094c:	108002c4 	addi	r2,r2,11
81140950:	11000005 	stb	r4,0(r2)
            pevents++;
81140954:	e0bff417 	ldw	r2,-48(fp)
81140958:	10800104 	addi	r2,r2,4
8114095c:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81140960:	e0bff417 	ldw	r2,-48(fp)
81140964:	10800017 	ldw	r2,0(r2)
81140968:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8114096c:	e0bff317 	ldw	r2,-52(fp)
81140970:	103fc51e 	bne	r2,zero,81140888 <__reset+0xfb120888>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
81140974:	e0bff817 	ldw	r2,-32(fp)
81140978:	e0ffff03 	ldbu	r3,-4(fp)
8114097c:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
81140980:	e0bff817 	ldw	r2,-32(fp)
81140984:	e0fffb03 	ldbu	r3,-20(fp)
81140988:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8114098c:	e0bff817 	ldw	r2,-32(fp)
81140990:	e0fffb43 	ldbu	r3,-19(fp)
81140994:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
81140998:	e0bff817 	ldw	r2,-32(fp)
8114099c:	e0fffb83 	ldbu	r3,-18(fp)
811409a0:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
811409a4:	e0bff817 	ldw	r2,-32(fp)
811409a8:	e0fffbc3 	ldbu	r3,-17(fp)
811409ac:	10c00d45 	stb	r3,53(r2)
811409b0:	e0bff517 	ldw	r2,-44(fp)
811409b4:	e0bffa15 	stw	r2,-24(fp)
811409b8:	e0bffa17 	ldw	r2,-24(fp)
811409bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811409c0:	d0a09103 	ldbu	r2,-32188(gp)
811409c4:	10803fcc 	andi	r2,r2,255
811409c8:	10800058 	cmpnei	r2,r2,1
811409cc:	1000011e 	bne	r2,zero,811409d4 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
811409d0:	113af840 	call	8113af84 <OS_Sched>
    }
    return (OS_ERR_NONE);
811409d4:	0005883a 	mov	r2,zero
}
811409d8:	e037883a 	mov	sp,fp
811409dc:	dfc00117 	ldw	ra,4(sp)
811409e0:	df000017 	ldw	fp,0(sp)
811409e4:	dec00204 	addi	sp,sp,8
811409e8:	f800283a 	ret

811409ec <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
811409ec:	deffee04 	addi	sp,sp,-72
811409f0:	de00012e 	bgeu	sp,et,811409f8 <OSTaskCreate+0xc>
811409f4:	003b68fa 	trap	3
811409f8:	dfc01115 	stw	ra,68(sp)
811409fc:	df001015 	stw	fp,64(sp)
81140a00:	df001004 	addi	fp,sp,64
81140a04:	e13ffc15 	stw	r4,-16(fp)
81140a08:	e17ffd15 	stw	r5,-12(fp)
81140a0c:	e1bffe15 	stw	r6,-8(fp)
81140a10:	3805883a 	mov	r2,r7
81140a14:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81140a18:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81140a1c:	e0bfff03 	ldbu	r2,-4(fp)
81140a20:	10800af0 	cmpltui	r2,r2,43
81140a24:	1000021e 	bne	r2,zero,81140a30 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
81140a28:	00800a84 	movi	r2,42
81140a2c:	00005706 	br	81140b8c <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140a30:	0005303a 	rdctl	r2,status
81140a34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140a38:	e0fffb17 	ldw	r3,-20(fp)
81140a3c:	00bfff84 	movi	r2,-2
81140a40:	1884703a 	and	r2,r3,r2
81140a44:	1001703a 	wrctl	status,r2
  
  return context;
81140a48:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140a4c:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81140a50:	d0a0a103 	ldbu	r2,-32124(gp)
81140a54:	10803fcc 	andi	r2,r2,255
81140a58:	10000626 	beq	r2,zero,81140a74 <OSTaskCreate+0x88>
81140a5c:	e0bff317 	ldw	r2,-52(fp)
81140a60:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140a64:	e0bff417 	ldw	r2,-48(fp)
81140a68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81140a6c:	00800f04 	movi	r2,60
81140a70:	00004606 	br	81140b8c <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81140a74:	e0ffff03 	ldbu	r3,-4(fp)
81140a78:	00a045f4 	movhi	r2,33047
81140a7c:	10b81c04 	addi	r2,r2,-8080
81140a80:	18c7883a 	add	r3,r3,r3
81140a84:	18c7883a 	add	r3,r3,r3
81140a88:	10c5883a 	add	r2,r2,r3
81140a8c:	10800017 	ldw	r2,0(r2)
81140a90:	1000391e 	bne	r2,zero,81140b78 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81140a94:	e0ffff03 	ldbu	r3,-4(fp)
81140a98:	00a045f4 	movhi	r2,33047
81140a9c:	10b81c04 	addi	r2,r2,-8080
81140aa0:	18c7883a 	add	r3,r3,r3
81140aa4:	18c7883a 	add	r3,r3,r3
81140aa8:	10c5883a 	add	r2,r2,r3
81140aac:	00c00044 	movi	r3,1
81140ab0:	10c00015 	stw	r3,0(r2)
81140ab4:	e0bff317 	ldw	r2,-52(fp)
81140ab8:	e0bff515 	stw	r2,-44(fp)
81140abc:	e0bff517 	ldw	r2,-44(fp)
81140ac0:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
81140ac4:	000f883a 	mov	r7,zero
81140ac8:	e1bffe17 	ldw	r6,-8(fp)
81140acc:	e17ffd17 	ldw	r5,-12(fp)
81140ad0:	e13ffc17 	ldw	r4,-16(fp)
81140ad4:	114c0940 	call	8114c094 <OSTaskStkInit>
81140ad8:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
81140adc:	e0bfff03 	ldbu	r2,-4(fp)
81140ae0:	d8000215 	stw	zero,8(sp)
81140ae4:	d8000115 	stw	zero,4(sp)
81140ae8:	d8000015 	stw	zero,0(sp)
81140aec:	000f883a 	mov	r7,zero
81140af0:	000d883a 	mov	r6,zero
81140af4:	e17ff717 	ldw	r5,-36(fp)
81140af8:	1009883a 	mov	r4,r2
81140afc:	113b3cc0 	call	8113b3cc <OS_TCBInit>
81140b00:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
81140b04:	e0bff803 	ldbu	r2,-32(fp)
81140b08:	1000061e 	bne	r2,zero,81140b24 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
81140b0c:	d0a09103 	ldbu	r2,-32188(gp)
81140b10:	10803fcc 	andi	r2,r2,255
81140b14:	10800058 	cmpnei	r2,r2,1
81140b18:	1000151e 	bne	r2,zero,81140b70 <OSTaskCreate+0x184>
                OS_Sched();
81140b1c:	113af840 	call	8113af84 <OS_Sched>
81140b20:	00001306 	br	81140b70 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140b24:	0005303a 	rdctl	r2,status
81140b28:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140b2c:	e0fffa17 	ldw	r3,-24(fp)
81140b30:	00bfff84 	movi	r2,-2
81140b34:	1884703a 	and	r2,r3,r2
81140b38:	1001703a 	wrctl	status,r2
  
  return context;
81140b3c:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81140b40:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
81140b44:	e0ffff03 	ldbu	r3,-4(fp)
81140b48:	00a045f4 	movhi	r2,33047
81140b4c:	10b81c04 	addi	r2,r2,-8080
81140b50:	18c7883a 	add	r3,r3,r3
81140b54:	18c7883a 	add	r3,r3,r3
81140b58:	10c5883a 	add	r2,r2,r3
81140b5c:	10000015 	stw	zero,0(r2)
81140b60:	e0bff317 	ldw	r2,-52(fp)
81140b64:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140b68:	e0bff617 	ldw	r2,-40(fp)
81140b6c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81140b70:	e0bff803 	ldbu	r2,-32(fp)
81140b74:	00000506 	br	81140b8c <OSTaskCreate+0x1a0>
81140b78:	e0bff317 	ldw	r2,-52(fp)
81140b7c:	e0bff915 	stw	r2,-28(fp)
81140b80:	e0bff917 	ldw	r2,-28(fp)
81140b84:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81140b88:	00800a04 	movi	r2,40
}
81140b8c:	e037883a 	mov	sp,fp
81140b90:	dfc00117 	ldw	ra,4(sp)
81140b94:	df000017 	ldw	fp,0(sp)
81140b98:	dec00204 	addi	sp,sp,8
81140b9c:	f800283a 	ret

81140ba0 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
81140ba0:	deffec04 	addi	sp,sp,-80
81140ba4:	de00012e 	bgeu	sp,et,81140bac <OSTaskCreateExt+0xc>
81140ba8:	003b68fa 	trap	3
81140bac:	dfc01315 	stw	ra,76(sp)
81140bb0:	df001215 	stw	fp,72(sp)
81140bb4:	df001204 	addi	fp,sp,72
81140bb8:	e13ffa15 	stw	r4,-24(fp)
81140bbc:	e17ffb15 	stw	r5,-20(fp)
81140bc0:	e1bffc15 	stw	r6,-16(fp)
81140bc4:	3809883a 	mov	r4,r7
81140bc8:	e0c00217 	ldw	r3,8(fp)
81140bcc:	e0800617 	ldw	r2,24(fp)
81140bd0:	e13ffd05 	stb	r4,-12(fp)
81140bd4:	e0fffe0d 	sth	r3,-8(fp)
81140bd8:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81140bdc:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81140be0:	e0bffd03 	ldbu	r2,-12(fp)
81140be4:	10800af0 	cmpltui	r2,r2,43
81140be8:	1000021e 	bne	r2,zero,81140bf4 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81140bec:	00800a84 	movi	r2,42
81140bf0:	00006106 	br	81140d78 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140bf4:	0005303a 	rdctl	r2,status
81140bf8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140bfc:	e0fff917 	ldw	r3,-28(fp)
81140c00:	00bfff84 	movi	r2,-2
81140c04:	1884703a 	and	r2,r3,r2
81140c08:	1001703a 	wrctl	status,r2
  
  return context;
81140c0c:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140c10:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81140c14:	d0a0a103 	ldbu	r2,-32124(gp)
81140c18:	10803fcc 	andi	r2,r2,255
81140c1c:	10000626 	beq	r2,zero,81140c38 <OSTaskCreateExt+0x98>
81140c20:	e0bff117 	ldw	r2,-60(fp)
81140c24:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140c28:	e0bff217 	ldw	r2,-56(fp)
81140c2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81140c30:	00800f04 	movi	r2,60
81140c34:	00005006 	br	81140d78 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81140c38:	e0fffd03 	ldbu	r3,-12(fp)
81140c3c:	00a045f4 	movhi	r2,33047
81140c40:	10b81c04 	addi	r2,r2,-8080
81140c44:	18c7883a 	add	r3,r3,r3
81140c48:	18c7883a 	add	r3,r3,r3
81140c4c:	10c5883a 	add	r2,r2,r3
81140c50:	10800017 	ldw	r2,0(r2)
81140c54:	1000431e 	bne	r2,zero,81140d64 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81140c58:	e0fffd03 	ldbu	r3,-12(fp)
81140c5c:	00a045f4 	movhi	r2,33047
81140c60:	10b81c04 	addi	r2,r2,-8080
81140c64:	18c7883a 	add	r3,r3,r3
81140c68:	18c7883a 	add	r3,r3,r3
81140c6c:	10c5883a 	add	r2,r2,r3
81140c70:	00c00044 	movi	r3,1
81140c74:	10c00015 	stw	r3,0(r2)
81140c78:	e0bff117 	ldw	r2,-60(fp)
81140c7c:	e0bff315 	stw	r2,-52(fp)
81140c80:	e0bff317 	ldw	r2,-52(fp)
81140c84:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
81140c88:	e0bfff0b 	ldhu	r2,-4(fp)
81140c8c:	100d883a 	mov	r6,r2
81140c90:	e1400417 	ldw	r5,16(fp)
81140c94:	e1000317 	ldw	r4,12(fp)
81140c98:	1141c480 	call	81141c48 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
81140c9c:	e0bfff0b 	ldhu	r2,-4(fp)
81140ca0:	100f883a 	mov	r7,r2
81140ca4:	e1bffc17 	ldw	r6,-16(fp)
81140ca8:	e17ffb17 	ldw	r5,-20(fp)
81140cac:	e13ffa17 	ldw	r4,-24(fp)
81140cb0:	114c0940 	call	8114c094 <OSTaskStkInit>
81140cb4:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
81140cb8:	e0fffd03 	ldbu	r3,-12(fp)
81140cbc:	e13ffe0b 	ldhu	r4,-8(fp)
81140cc0:	e0bfff0b 	ldhu	r2,-4(fp)
81140cc4:	d8800215 	stw	r2,8(sp)
81140cc8:	e0800517 	ldw	r2,20(fp)
81140ccc:	d8800115 	stw	r2,4(sp)
81140cd0:	e0800417 	ldw	r2,16(fp)
81140cd4:	d8800015 	stw	r2,0(sp)
81140cd8:	200f883a 	mov	r7,r4
81140cdc:	e1800317 	ldw	r6,12(fp)
81140ce0:	e17ff517 	ldw	r5,-44(fp)
81140ce4:	1809883a 	mov	r4,r3
81140ce8:	113b3cc0 	call	8113b3cc <OS_TCBInit>
81140cec:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81140cf0:	e0bff603 	ldbu	r2,-40(fp)
81140cf4:	1000061e 	bne	r2,zero,81140d10 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
81140cf8:	d0a09103 	ldbu	r2,-32188(gp)
81140cfc:	10803fcc 	andi	r2,r2,255
81140d00:	10800058 	cmpnei	r2,r2,1
81140d04:	1000151e 	bne	r2,zero,81140d5c <OSTaskCreateExt+0x1bc>
                OS_Sched();
81140d08:	113af840 	call	8113af84 <OS_Sched>
81140d0c:	00001306 	br	81140d5c <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140d10:	0005303a 	rdctl	r2,status
81140d14:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140d18:	e0fff817 	ldw	r3,-32(fp)
81140d1c:	00bfff84 	movi	r2,-2
81140d20:	1884703a 	and	r2,r3,r2
81140d24:	1001703a 	wrctl	status,r2
  
  return context;
81140d28:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81140d2c:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81140d30:	e0fffd03 	ldbu	r3,-12(fp)
81140d34:	00a045f4 	movhi	r2,33047
81140d38:	10b81c04 	addi	r2,r2,-8080
81140d3c:	18c7883a 	add	r3,r3,r3
81140d40:	18c7883a 	add	r3,r3,r3
81140d44:	10c5883a 	add	r2,r2,r3
81140d48:	10000015 	stw	zero,0(r2)
81140d4c:	e0bff117 	ldw	r2,-60(fp)
81140d50:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140d54:	e0bff417 	ldw	r2,-48(fp)
81140d58:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81140d5c:	e0bff603 	ldbu	r2,-40(fp)
81140d60:	00000506 	br	81140d78 <OSTaskCreateExt+0x1d8>
81140d64:	e0bff117 	ldw	r2,-60(fp)
81140d68:	e0bff715 	stw	r2,-36(fp)
81140d6c:	e0bff717 	ldw	r2,-36(fp)
81140d70:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81140d74:	00800a04 	movi	r2,40
}
81140d78:	e037883a 	mov	sp,fp
81140d7c:	dfc00117 	ldw	ra,4(sp)
81140d80:	df000017 	ldw	fp,0(sp)
81140d84:	dec00204 	addi	sp,sp,8
81140d88:	f800283a 	ret

81140d8c <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
81140d8c:	defff404 	addi	sp,sp,-48
81140d90:	de00012e 	bgeu	sp,et,81140d98 <OSTaskDel+0xc>
81140d94:	003b68fa 	trap	3
81140d98:	dfc00b15 	stw	ra,44(sp)
81140d9c:	df000a15 	stw	fp,40(sp)
81140da0:	df000a04 	addi	fp,sp,40
81140da4:	2005883a 	mov	r2,r4
81140da8:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
81140dac:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
81140db0:	d0a0a103 	ldbu	r2,-32124(gp)
81140db4:	10803fcc 	andi	r2,r2,255
81140db8:	10000226 	beq	r2,zero,81140dc4 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81140dbc:	00801004 	movi	r2,64
81140dc0:	0000c006 	br	811410c4 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
81140dc4:	e0bfff03 	ldbu	r2,-4(fp)
81140dc8:	10800a98 	cmpnei	r2,r2,42
81140dcc:	1000021e 	bne	r2,zero,81140dd8 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81140dd0:	00800f84 	movi	r2,62
81140dd4:	0000bb06 	br	811410c4 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81140dd8:	e0bfff03 	ldbu	r2,-4(fp)
81140ddc:	10800ab0 	cmpltui	r2,r2,42
81140de0:	1000051e 	bne	r2,zero,81140df8 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81140de4:	e0bfff03 	ldbu	r2,-4(fp)
81140de8:	10803fe0 	cmpeqi	r2,r2,255
81140dec:	1000021e 	bne	r2,zero,81140df8 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81140df0:	00800a84 	movi	r2,42
81140df4:	0000b306 	br	811410c4 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140df8:	0005303a 	rdctl	r2,status
81140dfc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140e00:	e0fffe17 	ldw	r3,-8(fp)
81140e04:	00bfff84 	movi	r2,-2
81140e08:	1884703a 	and	r2,r3,r2
81140e0c:	1001703a 	wrctl	status,r2
  
  return context;
81140e10:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81140e14:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81140e18:	e0bfff03 	ldbu	r2,-4(fp)
81140e1c:	10803fd8 	cmpnei	r2,r2,255
81140e20:	1000031e 	bne	r2,zero,81140e30 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81140e24:	d0a0a217 	ldw	r2,-32120(gp)
81140e28:	10800c83 	ldbu	r2,50(r2)
81140e2c:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81140e30:	e0ffff03 	ldbu	r3,-4(fp)
81140e34:	00a045f4 	movhi	r2,33047
81140e38:	10b81c04 	addi	r2,r2,-8080
81140e3c:	18c7883a 	add	r3,r3,r3
81140e40:	18c7883a 	add	r3,r3,r3
81140e44:	10c5883a 	add	r2,r2,r3
81140e48:	10800017 	ldw	r2,0(r2)
81140e4c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81140e50:	e0bff817 	ldw	r2,-32(fp)
81140e54:	1000061e 	bne	r2,zero,81140e70 <OSTaskDel+0xe4>
81140e58:	e0bff617 	ldw	r2,-40(fp)
81140e5c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140e60:	e0bff717 	ldw	r2,-36(fp)
81140e64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140e68:	008010c4 	movi	r2,67
81140e6c:	00009506 	br	811410c4 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
81140e70:	e0bff817 	ldw	r2,-32(fp)
81140e74:	10800058 	cmpnei	r2,r2,1
81140e78:	1000061e 	bne	r2,zero,81140e94 <OSTaskDel+0x108>
81140e7c:	e0bff617 	ldw	r2,-40(fp)
81140e80:	e0bff915 	stw	r2,-28(fp)
81140e84:	e0bff917 	ldw	r2,-28(fp)
81140e88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81140e8c:	00800f44 	movi	r2,61
81140e90:	00008c06 	br	811410c4 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
81140e94:	e0bff817 	ldw	r2,-32(fp)
81140e98:	10800d03 	ldbu	r2,52(r2)
81140e9c:	10c03fcc 	andi	r3,r2,255
81140ea0:	e0bff817 	ldw	r2,-32(fp)
81140ea4:	10800d03 	ldbu	r2,52(r2)
81140ea8:	11003fcc 	andi	r4,r2,255
81140eac:	d0a09e44 	addi	r2,gp,-32135
81140eb0:	2085883a 	add	r2,r4,r2
81140eb4:	10800003 	ldbu	r2,0(r2)
81140eb8:	1009883a 	mov	r4,r2
81140ebc:	e0bff817 	ldw	r2,-32(fp)
81140ec0:	10800d43 	ldbu	r2,53(r2)
81140ec4:	0084303a 	nor	r2,zero,r2
81140ec8:	2084703a 	and	r2,r4,r2
81140ecc:	1009883a 	mov	r4,r2
81140ed0:	d0a09e44 	addi	r2,gp,-32135
81140ed4:	1885883a 	add	r2,r3,r2
81140ed8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81140edc:	e0bff817 	ldw	r2,-32(fp)
81140ee0:	10800d03 	ldbu	r2,52(r2)
81140ee4:	10c03fcc 	andi	r3,r2,255
81140ee8:	d0a09e44 	addi	r2,gp,-32135
81140eec:	1885883a 	add	r2,r3,r2
81140ef0:	10800003 	ldbu	r2,0(r2)
81140ef4:	10803fcc 	andi	r2,r2,255
81140ef8:	1000071e 	bne	r2,zero,81140f18 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81140efc:	e0bff817 	ldw	r2,-32(fp)
81140f00:	10800d83 	ldbu	r2,54(r2)
81140f04:	0084303a 	nor	r2,zero,r2
81140f08:	1007883a 	mov	r3,r2
81140f0c:	d0a09e03 	ldbu	r2,-32136(gp)
81140f10:	1884703a 	and	r2,r3,r2
81140f14:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81140f18:	e0bff817 	ldw	r2,-32(fp)
81140f1c:	10800717 	ldw	r2,28(r2)
81140f20:	10000526 	beq	r2,zero,81140f38 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81140f24:	e0bff817 	ldw	r2,-32(fp)
81140f28:	10800717 	ldw	r2,28(r2)
81140f2c:	100b883a 	mov	r5,r2
81140f30:	e13ff817 	ldw	r4,-32(fp)
81140f34:	113a8d80 	call	8113a8d8 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
81140f38:	e0bff817 	ldw	r2,-32(fp)
81140f3c:	10800817 	ldw	r2,32(r2)
81140f40:	10000526 	beq	r2,zero,81140f58 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81140f44:	e0bff817 	ldw	r2,-32(fp)
81140f48:	10800817 	ldw	r2,32(r2)
81140f4c:	100b883a 	mov	r5,r2
81140f50:	e13ff817 	ldw	r4,-32(fp)
81140f54:	113a9980 	call	8113a998 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
81140f58:	e0bff817 	ldw	r2,-32(fp)
81140f5c:	10800a17 	ldw	r2,40(r2)
81140f60:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
81140f64:	e0bffb17 	ldw	r2,-20(fp)
81140f68:	10000226 	beq	r2,zero,81140f74 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
81140f6c:	e13ffb17 	ldw	r4,-20(fp)
81140f70:	113cf700 	call	8113cf70 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
81140f74:	e0bff817 	ldw	r2,-32(fp)
81140f78:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
81140f7c:	e0bff817 	ldw	r2,-32(fp)
81140f80:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81140f84:	e0bff817 	ldw	r2,-32(fp)
81140f88:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
81140f8c:	d0a08f03 	ldbu	r2,-32196(gp)
81140f90:	10803fcc 	andi	r2,r2,255
81140f94:	10803fe0 	cmpeqi	r2,r2,255
81140f98:	1000031e 	bne	r2,zero,81140fa8 <OSTaskDel+0x21c>
        OSLockNesting++;
81140f9c:	d0a08f03 	ldbu	r2,-32196(gp)
81140fa0:	10800044 	addi	r2,r2,1
81140fa4:	d0a08f05 	stb	r2,-32196(gp)
81140fa8:	e0bff617 	ldw	r2,-40(fp)
81140fac:	e0bffd15 	stw	r2,-12(fp)
81140fb0:	e0bffd17 	ldw	r2,-12(fp)
81140fb4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81140fb8:	113a4a00 	call	8113a4a0 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140fbc:	0005303a 	rdctl	r2,status
81140fc0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140fc4:	e0fffa17 	ldw	r3,-24(fp)
81140fc8:	00bfff84 	movi	r2,-2
81140fcc:	1884703a 	and	r2,r3,r2
81140fd0:	1001703a 	wrctl	status,r2
  
  return context;
81140fd4:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81140fd8:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81140fdc:	d0a08f03 	ldbu	r2,-32196(gp)
81140fe0:	10803fcc 	andi	r2,r2,255
81140fe4:	10000326 	beq	r2,zero,81140ff4 <OSTaskDel+0x268>
        OSLockNesting--;
81140fe8:	d0a08f03 	ldbu	r2,-32196(gp)
81140fec:	10bfffc4 	addi	r2,r2,-1
81140ff0:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81140ff4:	e13ff817 	ldw	r4,-32(fp)
81140ff8:	114c2240 	call	8114c224 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81140ffc:	d0a09a43 	ldbu	r2,-32151(gp)
81141000:	10bfffc4 	addi	r2,r2,-1
81141004:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81141008:	e0ffff03 	ldbu	r3,-4(fp)
8114100c:	00a045f4 	movhi	r2,33047
81141010:	10b81c04 	addi	r2,r2,-8080
81141014:	18c7883a 	add	r3,r3,r3
81141018:	18c7883a 	add	r3,r3,r3
8114101c:	10c5883a 	add	r2,r2,r3
81141020:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81141024:	e0bff817 	ldw	r2,-32(fp)
81141028:	10800617 	ldw	r2,24(r2)
8114102c:	1000071e 	bne	r2,zero,8114104c <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81141030:	e0bff817 	ldw	r2,-32(fp)
81141034:	10800517 	ldw	r2,20(r2)
81141038:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8114103c:	e0bff817 	ldw	r2,-32(fp)
81141040:	10800517 	ldw	r2,20(r2)
81141044:	d0a09415 	stw	r2,-32176(gp)
81141048:	00000a06 	br	81141074 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8114104c:	e0bff817 	ldw	r2,-32(fp)
81141050:	10800617 	ldw	r2,24(r2)
81141054:	e0fff817 	ldw	r3,-32(fp)
81141058:	18c00517 	ldw	r3,20(r3)
8114105c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81141060:	e0bff817 	ldw	r2,-32(fp)
81141064:	10800517 	ldw	r2,20(r2)
81141068:	e0fff817 	ldw	r3,-32(fp)
8114106c:	18c00617 	ldw	r3,24(r3)
81141070:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
81141074:	d0e09917 	ldw	r3,-32156(gp)
81141078:	e0bff817 	ldw	r2,-32(fp)
8114107c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
81141080:	e0bff817 	ldw	r2,-32(fp)
81141084:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81141088:	e0bff817 	ldw	r2,-32(fp)
8114108c:	00c00fc4 	movi	r3,63
81141090:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81141094:	e0bff817 	ldw	r2,-32(fp)
81141098:	10001345 	stb	zero,77(r2)
8114109c:	e0bff617 	ldw	r2,-40(fp)
811410a0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811410a4:	e0bffc17 	ldw	r2,-16(fp)
811410a8:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811410ac:	d0a09103 	ldbu	r2,-32188(gp)
811410b0:	10803fcc 	andi	r2,r2,255
811410b4:	10800058 	cmpnei	r2,r2,1
811410b8:	1000011e 	bne	r2,zero,811410c0 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
811410bc:	113af840 	call	8113af84 <OS_Sched>
    }
    return (OS_ERR_NONE);
811410c0:	0005883a 	mov	r2,zero
}
811410c4:	e037883a 	mov	sp,fp
811410c8:	dfc00117 	ldw	ra,4(sp)
811410cc:	df000017 	ldw	fp,0(sp)
811410d0:	dec00204 	addi	sp,sp,8
811410d4:	f800283a 	ret

811410d8 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
811410d8:	defff504 	addi	sp,sp,-44
811410dc:	de00012e 	bgeu	sp,et,811410e4 <OSTaskDelReq+0xc>
811410e0:	003b68fa 	trap	3
811410e4:	df000a15 	stw	fp,40(sp)
811410e8:	df000a04 	addi	fp,sp,40
811410ec:	2005883a 	mov	r2,r4
811410f0:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811410f4:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
811410f8:	e0bfff03 	ldbu	r2,-4(fp)
811410fc:	10800a98 	cmpnei	r2,r2,42
81141100:	1000021e 	bne	r2,zero,8114110c <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81141104:	00800f84 	movi	r2,62
81141108:	00004506 	br	81141220 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8114110c:	e0bfff03 	ldbu	r2,-4(fp)
81141110:	10800ab0 	cmpltui	r2,r2,42
81141114:	1000051e 	bne	r2,zero,8114112c <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81141118:	e0bfff03 	ldbu	r2,-4(fp)
8114111c:	10803fe0 	cmpeqi	r2,r2,255
81141120:	1000021e 	bne	r2,zero,8114112c <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81141124:	00800a84 	movi	r2,42
81141128:	00003d06 	br	81141220 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8114112c:	e0bfff03 	ldbu	r2,-4(fp)
81141130:	10803fd8 	cmpnei	r2,r2,255
81141134:	1000111e 	bne	r2,zero,8114117c <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141138:	0005303a 	rdctl	r2,status
8114113c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141140:	e0fff917 	ldw	r3,-28(fp)
81141144:	00bfff84 	movi	r2,-2
81141148:	1884703a 	and	r2,r3,r2
8114114c:	1001703a 	wrctl	status,r2
  
  return context;
81141150:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81141154:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
81141158:	d0a0a217 	ldw	r2,-32120(gp)
8114115c:	10800dc3 	ldbu	r2,55(r2)
81141160:	e0bff805 	stb	r2,-32(fp)
81141164:	e0bff617 	ldw	r2,-40(fp)
81141168:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114116c:	e0bffe17 	ldw	r2,-8(fp)
81141170:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
81141174:	e0bff803 	ldbu	r2,-32(fp)
81141178:	00002906 	br	81141220 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114117c:	0005303a 	rdctl	r2,status
81141180:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141184:	e0fff717 	ldw	r3,-36(fp)
81141188:	00bfff84 	movi	r2,-2
8114118c:	1884703a 	and	r2,r3,r2
81141190:	1001703a 	wrctl	status,r2
  
  return context;
81141194:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81141198:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8114119c:	e0ffff03 	ldbu	r3,-4(fp)
811411a0:	00a045f4 	movhi	r2,33047
811411a4:	10b81c04 	addi	r2,r2,-8080
811411a8:	18c7883a 	add	r3,r3,r3
811411ac:	18c7883a 	add	r3,r3,r3
811411b0:	10c5883a 	add	r2,r2,r3
811411b4:	10800017 	ldw	r2,0(r2)
811411b8:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
811411bc:	e0bffb17 	ldw	r2,-20(fp)
811411c0:	1000061e 	bne	r2,zero,811411dc <OSTaskDelReq+0x104>
811411c4:	e0bff617 	ldw	r2,-40(fp)
811411c8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811411cc:	e0bffa17 	ldw	r2,-24(fp)
811411d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
811411d4:	008010c4 	movi	r2,67
811411d8:	00001106 	br	81141220 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
811411dc:	e0bffb17 	ldw	r2,-20(fp)
811411e0:	10800058 	cmpnei	r2,r2,1
811411e4:	1000061e 	bne	r2,zero,81141200 <OSTaskDelReq+0x128>
811411e8:	e0bff617 	ldw	r2,-40(fp)
811411ec:	e0bffc15 	stw	r2,-16(fp)
811411f0:	e0bffc17 	ldw	r2,-16(fp)
811411f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
811411f8:	00800f44 	movi	r2,61
811411fc:	00000806 	br	81141220 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81141200:	e0bffb17 	ldw	r2,-20(fp)
81141204:	00c00fc4 	movi	r3,63
81141208:	10c00dc5 	stb	r3,55(r2)
8114120c:	e0bff617 	ldw	r2,-40(fp)
81141210:	e0bffd15 	stw	r2,-12(fp)
81141214:	e0bffd17 	ldw	r2,-12(fp)
81141218:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8114121c:	0005883a 	mov	r2,zero
}
81141220:	e037883a 	mov	sp,fp
81141224:	df000017 	ldw	fp,0(sp)
81141228:	dec00104 	addi	sp,sp,4
8114122c:	f800283a 	ret

81141230 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81141230:	defff404 	addi	sp,sp,-48
81141234:	de00012e 	bgeu	sp,et,8114123c <OSTaskNameGet+0xc>
81141238:	003b68fa 	trap	3
8114123c:	dfc00b15 	stw	ra,44(sp)
81141240:	df000a15 	stw	fp,40(sp)
81141244:	df000a04 	addi	fp,sp,40
81141248:	2005883a 	mov	r2,r4
8114124c:	e17ffe15 	stw	r5,-8(fp)
81141250:	e1bfff15 	stw	r6,-4(fp)
81141254:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
81141258:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8114125c:	e0bfff17 	ldw	r2,-4(fp)
81141260:	1000021e 	bne	r2,zero,8114126c <OSTaskNameGet+0x3c>
        return (0);
81141264:	0005883a 	mov	r2,zero
81141268:	00005406 	br	811413bc <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8114126c:	e0bffd03 	ldbu	r2,-12(fp)
81141270:	10800af0 	cmpltui	r2,r2,43
81141274:	1000081e 	bne	r2,zero,81141298 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81141278:	e0bffd03 	ldbu	r2,-12(fp)
8114127c:	10803fe0 	cmpeqi	r2,r2,255
81141280:	1000051e 	bne	r2,zero,81141298 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
81141284:	e0bfff17 	ldw	r2,-4(fp)
81141288:	00c00a84 	movi	r3,42
8114128c:	10c00005 	stb	r3,0(r2)
            return (0);
81141290:	0005883a 	mov	r2,zero
81141294:	00004906 	br	811413bc <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81141298:	e0bffe17 	ldw	r2,-8(fp)
8114129c:	1000051e 	bne	r2,zero,811412b4 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
811412a0:	e0bfff17 	ldw	r2,-4(fp)
811412a4:	00c00304 	movi	r3,12
811412a8:	10c00005 	stb	r3,0(r2)
        return (0);
811412ac:	0005883a 	mov	r2,zero
811412b0:	00004206 	br	811413bc <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
811412b4:	d0a0a103 	ldbu	r2,-32124(gp)
811412b8:	10803fcc 	andi	r2,r2,255
811412bc:	10000526 	beq	r2,zero,811412d4 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
811412c0:	e0bfff17 	ldw	r2,-4(fp)
811412c4:	00c00444 	movi	r3,17
811412c8:	10c00005 	stb	r3,0(r2)
        return (0);
811412cc:	0005883a 	mov	r2,zero
811412d0:	00003a06 	br	811413bc <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811412d4:	0005303a 	rdctl	r2,status
811412d8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811412dc:	e0fffc17 	ldw	r3,-16(fp)
811412e0:	00bfff84 	movi	r2,-2
811412e4:	1884703a 	and	r2,r3,r2
811412e8:	1001703a 	wrctl	status,r2
  
  return context;
811412ec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811412f0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
811412f4:	e0bffd03 	ldbu	r2,-12(fp)
811412f8:	10803fd8 	cmpnei	r2,r2,255
811412fc:	1000031e 	bne	r2,zero,8114130c <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81141300:	d0a0a217 	ldw	r2,-32120(gp)
81141304:	10800c83 	ldbu	r2,50(r2)
81141308:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8114130c:	e0fffd03 	ldbu	r3,-12(fp)
81141310:	00a045f4 	movhi	r2,33047
81141314:	10b81c04 	addi	r2,r2,-8080
81141318:	18c7883a 	add	r3,r3,r3
8114131c:	18c7883a 	add	r3,r3,r3
81141320:	10c5883a 	add	r2,r2,r3
81141324:	10800017 	ldw	r2,0(r2)
81141328:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8114132c:	e0bff817 	ldw	r2,-32(fp)
81141330:	1000091e 	bne	r2,zero,81141358 <OSTaskNameGet+0x128>
81141334:	e0bff617 	ldw	r2,-40(fp)
81141338:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114133c:	e0bff717 	ldw	r2,-36(fp)
81141340:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141344:	e0bfff17 	ldw	r2,-4(fp)
81141348:	00c010c4 	movi	r3,67
8114134c:	10c00005 	stb	r3,0(r2)
        return (0);
81141350:	0005883a 	mov	r2,zero
81141354:	00001906 	br	811413bc <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81141358:	e0bff817 	ldw	r2,-32(fp)
8114135c:	10800058 	cmpnei	r2,r2,1
81141360:	1000091e 	bne	r2,zero,81141388 <OSTaskNameGet+0x158>
81141364:	e0bff617 	ldw	r2,-40(fp)
81141368:	e0bff915 	stw	r2,-28(fp)
8114136c:	e0bff917 	ldw	r2,-28(fp)
81141370:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141374:	e0bfff17 	ldw	r2,-4(fp)
81141378:	00c010c4 	movi	r3,67
8114137c:	10c00005 	stb	r3,0(r2)
        return (0);
81141380:	0005883a 	mov	r2,zero
81141384:	00000d06 	br	811413bc <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81141388:	e0bff817 	ldw	r2,-32(fp)
8114138c:	10801304 	addi	r2,r2,76
81141390:	100b883a 	mov	r5,r2
81141394:	e13ffe17 	ldw	r4,-8(fp)
81141398:	113b0d80 	call	8113b0d8 <OS_StrCopy>
8114139c:	e0bffb05 	stb	r2,-20(fp)
811413a0:	e0bff617 	ldw	r2,-40(fp)
811413a4:	e0bffa15 	stw	r2,-24(fp)
811413a8:	e0bffa17 	ldw	r2,-24(fp)
811413ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811413b0:	e0bfff17 	ldw	r2,-4(fp)
811413b4:	10000005 	stb	zero,0(r2)
    return (len);
811413b8:	e0bffb03 	ldbu	r2,-20(fp)
}
811413bc:	e037883a 	mov	sp,fp
811413c0:	dfc00117 	ldw	ra,4(sp)
811413c4:	df000017 	ldw	fp,0(sp)
811413c8:	dec00204 	addi	sp,sp,8
811413cc:	f800283a 	ret

811413d0 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
811413d0:	defff304 	addi	sp,sp,-52
811413d4:	de00012e 	bgeu	sp,et,811413dc <OSTaskNameSet+0xc>
811413d8:	003b68fa 	trap	3
811413dc:	dfc00c15 	stw	ra,48(sp)
811413e0:	df000b15 	stw	fp,44(sp)
811413e4:	df000b04 	addi	fp,sp,44
811413e8:	2005883a 	mov	r2,r4
811413ec:	e17ffe15 	stw	r5,-8(fp)
811413f0:	e1bfff15 	stw	r6,-4(fp)
811413f4:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
811413f8:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811413fc:	e0bfff17 	ldw	r2,-4(fp)
81141400:	10005c26 	beq	r2,zero,81141574 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81141404:	e0bffd03 	ldbu	r2,-12(fp)
81141408:	10800af0 	cmpltui	r2,r2,43
8114140c:	1000071e 	bne	r2,zero,8114142c <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81141410:	e0bffd03 	ldbu	r2,-12(fp)
81141414:	10803fe0 	cmpeqi	r2,r2,255
81141418:	1000041e 	bne	r2,zero,8114142c <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8114141c:	e0bfff17 	ldw	r2,-4(fp)
81141420:	00c00a84 	movi	r3,42
81141424:	10c00005 	stb	r3,0(r2)
            return;
81141428:	00005306 	br	81141578 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8114142c:	e0bffe17 	ldw	r2,-8(fp)
81141430:	1000041e 	bne	r2,zero,81141444 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81141434:	e0bfff17 	ldw	r2,-4(fp)
81141438:	00c00304 	movi	r3,12
8114143c:	10c00005 	stb	r3,0(r2)
        return;
81141440:	00004d06 	br	81141578 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81141444:	d0a0a103 	ldbu	r2,-32124(gp)
81141448:	10803fcc 	andi	r2,r2,255
8114144c:	10000426 	beq	r2,zero,81141460 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81141450:	e0bfff17 	ldw	r2,-4(fp)
81141454:	00c00484 	movi	r3,18
81141458:	10c00005 	stb	r3,0(r2)
        return;
8114145c:	00004606 	br	81141578 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141460:	0005303a 	rdctl	r2,status
81141464:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141468:	e0fffc17 	ldw	r3,-16(fp)
8114146c:	00bfff84 	movi	r2,-2
81141470:	1884703a 	and	r2,r3,r2
81141474:	1001703a 	wrctl	status,r2
  
  return context;
81141478:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8114147c:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81141480:	e0bffd03 	ldbu	r2,-12(fp)
81141484:	10803fd8 	cmpnei	r2,r2,255
81141488:	1000031e 	bne	r2,zero,81141498 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8114148c:	d0a0a217 	ldw	r2,-32120(gp)
81141490:	10800c83 	ldbu	r2,50(r2)
81141494:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141498:	e0fffd03 	ldbu	r3,-12(fp)
8114149c:	00a045f4 	movhi	r2,33047
811414a0:	10b81c04 	addi	r2,r2,-8080
811414a4:	18c7883a 	add	r3,r3,r3
811414a8:	18c7883a 	add	r3,r3,r3
811414ac:	10c5883a 	add	r2,r2,r3
811414b0:	10800017 	ldw	r2,0(r2)
811414b4:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
811414b8:	e0bff717 	ldw	r2,-36(fp)
811414bc:	1000081e 	bne	r2,zero,811414e0 <OSTaskNameSet+0x110>
811414c0:	e0bff517 	ldw	r2,-44(fp)
811414c4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811414c8:	e0bff617 	ldw	r2,-40(fp)
811414cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
811414d0:	e0bfff17 	ldw	r2,-4(fp)
811414d4:	00c010c4 	movi	r3,67
811414d8:	10c00005 	stb	r3,0(r2)
        return;
811414dc:	00002606 	br	81141578 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
811414e0:	e0bff717 	ldw	r2,-36(fp)
811414e4:	10800058 	cmpnei	r2,r2,1
811414e8:	1000081e 	bne	r2,zero,8114150c <OSTaskNameSet+0x13c>
811414ec:	e0bff517 	ldw	r2,-44(fp)
811414f0:	e0bff815 	stw	r2,-32(fp)
811414f4:	e0bff817 	ldw	r2,-32(fp)
811414f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
811414fc:	e0bfff17 	ldw	r2,-4(fp)
81141500:	00c010c4 	movi	r3,67
81141504:	10c00005 	stb	r3,0(r2)
        return;
81141508:	00001b06 	br	81141578 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8114150c:	e13ffe17 	ldw	r4,-8(fp)
81141510:	113b1540 	call	8113b154 <OS_StrLen>
81141514:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
81141518:	e0bffa03 	ldbu	r2,-24(fp)
8114151c:	10800830 	cmpltui	r2,r2,32
81141520:	1000081e 	bne	r2,zero,81141544 <OSTaskNameSet+0x174>
81141524:	e0bff517 	ldw	r2,-44(fp)
81141528:	e0bff915 	stw	r2,-28(fp)
8114152c:	e0bff917 	ldw	r2,-28(fp)
81141530:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81141534:	e0bfff17 	ldw	r2,-4(fp)
81141538:	00c01044 	movi	r3,65
8114153c:	10c00005 	stb	r3,0(r2)
        return;
81141540:	00000d06 	br	81141578 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81141544:	e0bff717 	ldw	r2,-36(fp)
81141548:	10801304 	addi	r2,r2,76
8114154c:	e17ffe17 	ldw	r5,-8(fp)
81141550:	1009883a 	mov	r4,r2
81141554:	113b0d80 	call	8113b0d8 <OS_StrCopy>
81141558:	e0bff517 	ldw	r2,-44(fp)
8114155c:	e0bffb15 	stw	r2,-20(fp)
81141560:	e0bffb17 	ldw	r2,-20(fp)
81141564:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81141568:	e0bfff17 	ldw	r2,-4(fp)
8114156c:	10000005 	stb	zero,0(r2)
81141570:	00000106 	br	81141578 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81141574:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81141578:	e037883a 	mov	sp,fp
8114157c:	dfc00117 	ldw	ra,4(sp)
81141580:	df000017 	ldw	fp,0(sp)
81141584:	dec00204 	addi	sp,sp,8
81141588:	f800283a 	ret

8114158c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8114158c:	defff404 	addi	sp,sp,-48
81141590:	de00012e 	bgeu	sp,et,81141598 <OSTaskResume+0xc>
81141594:	003b68fa 	trap	3
81141598:	dfc00b15 	stw	ra,44(sp)
8114159c:	df000a15 	stw	fp,40(sp)
811415a0:	df000a04 	addi	fp,sp,40
811415a4:	2005883a 	mov	r2,r4
811415a8:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
811415ac:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
811415b0:	e0bfff03 	ldbu	r2,-4(fp)
811415b4:	10800ab0 	cmpltui	r2,r2,42
811415b8:	1000021e 	bne	r2,zero,811415c4 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811415bc:	00800a84 	movi	r2,42
811415c0:	00006406 	br	81141754 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811415c4:	0005303a 	rdctl	r2,status
811415c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811415cc:	e0fffe17 	ldw	r3,-8(fp)
811415d0:	00bfff84 	movi	r2,-2
811415d4:	1884703a 	and	r2,r3,r2
811415d8:	1001703a 	wrctl	status,r2
  
  return context;
811415dc:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811415e0:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
811415e4:	e0ffff03 	ldbu	r3,-4(fp)
811415e8:	00a045f4 	movhi	r2,33047
811415ec:	10b81c04 	addi	r2,r2,-8080
811415f0:	18c7883a 	add	r3,r3,r3
811415f4:	18c7883a 	add	r3,r3,r3
811415f8:	10c5883a 	add	r2,r2,r3
811415fc:	10800017 	ldw	r2,0(r2)
81141600:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
81141604:	e0bff817 	ldw	r2,-32(fp)
81141608:	1000061e 	bne	r2,zero,81141624 <OSTaskResume+0x98>
8114160c:	e0bff617 	ldw	r2,-40(fp)
81141610:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141614:	e0bff717 	ldw	r2,-36(fp)
81141618:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8114161c:	00801184 	movi	r2,70
81141620:	00004c06 	br	81141754 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81141624:	e0bff817 	ldw	r2,-32(fp)
81141628:	10800058 	cmpnei	r2,r2,1
8114162c:	1000061e 	bne	r2,zero,81141648 <OSTaskResume+0xbc>
81141630:	e0bff617 	ldw	r2,-40(fp)
81141634:	e0bff915 	stw	r2,-28(fp)
81141638:	e0bff917 	ldw	r2,-28(fp)
8114163c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141640:	008010c4 	movi	r2,67
81141644:	00004306 	br	81141754 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81141648:	e0bff817 	ldw	r2,-32(fp)
8114164c:	10800c03 	ldbu	r2,48(r2)
81141650:	10803fcc 	andi	r2,r2,255
81141654:	1080020c 	andi	r2,r2,8
81141658:	10003926 	beq	r2,zero,81141740 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8114165c:	e0bff817 	ldw	r2,-32(fp)
81141660:	10c00c03 	ldbu	r3,48(r2)
81141664:	00bffdc4 	movi	r2,-9
81141668:	1884703a 	and	r2,r3,r2
8114166c:	1007883a 	mov	r3,r2
81141670:	e0bff817 	ldw	r2,-32(fp)
81141674:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81141678:	e0bff817 	ldw	r2,-32(fp)
8114167c:	10800c03 	ldbu	r2,48(r2)
81141680:	10803fcc 	andi	r2,r2,255
81141684:	1000281e 	bne	r2,zero,81141728 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81141688:	e0bff817 	ldw	r2,-32(fp)
8114168c:	10800b8b 	ldhu	r2,46(r2)
81141690:	10bfffcc 	andi	r2,r2,65535
81141694:	10001f1e 	bne	r2,zero,81141714 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
81141698:	e0bff817 	ldw	r2,-32(fp)
8114169c:	10c00d83 	ldbu	r3,54(r2)
811416a0:	d0a09e03 	ldbu	r2,-32136(gp)
811416a4:	1884b03a 	or	r2,r3,r2
811416a8:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811416ac:	e0bff817 	ldw	r2,-32(fp)
811416b0:	10800d03 	ldbu	r2,52(r2)
811416b4:	10c03fcc 	andi	r3,r2,255
811416b8:	e0bff817 	ldw	r2,-32(fp)
811416bc:	10800d03 	ldbu	r2,52(r2)
811416c0:	11003fcc 	andi	r4,r2,255
811416c4:	d0a09e44 	addi	r2,gp,-32135
811416c8:	2085883a 	add	r2,r4,r2
811416cc:	11000003 	ldbu	r4,0(r2)
811416d0:	e0bff817 	ldw	r2,-32(fp)
811416d4:	10800d43 	ldbu	r2,53(r2)
811416d8:	2084b03a 	or	r2,r4,r2
811416dc:	1009883a 	mov	r4,r2
811416e0:	d0a09e44 	addi	r2,gp,-32135
811416e4:	1885883a 	add	r2,r3,r2
811416e8:	11000005 	stb	r4,0(r2)
811416ec:	e0bff617 	ldw	r2,-40(fp)
811416f0:	e0bffa15 	stw	r2,-24(fp)
811416f4:	e0bffa17 	ldw	r2,-24(fp)
811416f8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
811416fc:	d0a09103 	ldbu	r2,-32188(gp)
81141700:	10803fcc 	andi	r2,r2,255
81141704:	10800058 	cmpnei	r2,r2,1
81141708:	10000b1e 	bne	r2,zero,81141738 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8114170c:	113af840 	call	8113af84 <OS_Sched>
81141710:	00000906 	br	81141738 <OSTaskResume+0x1ac>
81141714:	e0bff617 	ldw	r2,-40(fp)
81141718:	e0bffb15 	stw	r2,-20(fp)
8114171c:	e0bffb17 	ldw	r2,-20(fp)
81141720:	1001703a 	wrctl	status,r2
81141724:	00000406 	br	81141738 <OSTaskResume+0x1ac>
81141728:	e0bff617 	ldw	r2,-40(fp)
8114172c:	e0bffc15 	stw	r2,-16(fp)
81141730:	e0bffc17 	ldw	r2,-16(fp)
81141734:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81141738:	0005883a 	mov	r2,zero
8114173c:	00000506 	br	81141754 <OSTaskResume+0x1c8>
81141740:	e0bff617 	ldw	r2,-40(fp)
81141744:	e0bffd15 	stw	r2,-12(fp)
81141748:	e0bffd17 	ldw	r2,-12(fp)
8114174c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81141750:	00801104 	movi	r2,68
}
81141754:	e037883a 	mov	sp,fp
81141758:	dfc00117 	ldw	ra,4(sp)
8114175c:	df000017 	ldw	fp,0(sp)
81141760:	dec00204 	addi	sp,sp,8
81141764:	f800283a 	ret

81141768 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81141768:	defff304 	addi	sp,sp,-52
8114176c:	de00012e 	bgeu	sp,et,81141774 <OSTaskStkChk+0xc>
81141770:	003b68fa 	trap	3
81141774:	df000c15 	stw	fp,48(sp)
81141778:	df000c04 	addi	fp,sp,48
8114177c:	2005883a 	mov	r2,r4
81141780:	e17fff15 	stw	r5,-4(fp)
81141784:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81141788:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8114178c:	e0bffe03 	ldbu	r2,-8(fp)
81141790:	10800af0 	cmpltui	r2,r2,43
81141794:	1000051e 	bne	r2,zero,811417ac <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
81141798:	e0bffe03 	ldbu	r2,-8(fp)
8114179c:	10803fe0 	cmpeqi	r2,r2,255
811417a0:	1000021e 	bne	r2,zero,811417ac <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
811417a4:	00800a84 	movi	r2,42
811417a8:	00005d06 	br	81141920 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
811417ac:	e0bfff17 	ldw	r2,-4(fp)
811417b0:	1000021e 	bne	r2,zero,811417bc <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
811417b4:	00800244 	movi	r2,9
811417b8:	00005906 	br	81141920 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
811417bc:	e0bfff17 	ldw	r2,-4(fp)
811417c0:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
811417c4:	e0bfff17 	ldw	r2,-4(fp)
811417c8:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811417cc:	0005303a 	rdctl	r2,status
811417d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811417d4:	e0fffd17 	ldw	r3,-12(fp)
811417d8:	00bfff84 	movi	r2,-2
811417dc:	1884703a 	and	r2,r3,r2
811417e0:	1001703a 	wrctl	status,r2
  
  return context;
811417e4:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
811417e8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
811417ec:	e0bffe03 	ldbu	r2,-8(fp)
811417f0:	10803fd8 	cmpnei	r2,r2,255
811417f4:	1000031e 	bne	r2,zero,81141804 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811417f8:	d0a0a217 	ldw	r2,-32120(gp)
811417fc:	10800c83 	ldbu	r2,50(r2)
81141800:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141804:	e0fffe03 	ldbu	r3,-8(fp)
81141808:	00a045f4 	movhi	r2,33047
8114180c:	10b81c04 	addi	r2,r2,-8080
81141810:	18c7883a 	add	r3,r3,r3
81141814:	18c7883a 	add	r3,r3,r3
81141818:	10c5883a 	add	r2,r2,r3
8114181c:	10800017 	ldw	r2,0(r2)
81141820:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
81141824:	e0bff817 	ldw	r2,-32(fp)
81141828:	1000061e 	bne	r2,zero,81141844 <OSTaskStkChk+0xdc>
8114182c:	e0bff617 	ldw	r2,-40(fp)
81141830:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141834:	e0bff717 	ldw	r2,-36(fp)
81141838:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8114183c:	008010c4 	movi	r2,67
81141840:	00003706 	br	81141920 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81141844:	e0bff817 	ldw	r2,-32(fp)
81141848:	10800058 	cmpnei	r2,r2,1
8114184c:	1000061e 	bne	r2,zero,81141868 <OSTaskStkChk+0x100>
81141850:	e0bff617 	ldw	r2,-40(fp)
81141854:	e0bff915 	stw	r2,-28(fp)
81141858:	e0bff917 	ldw	r2,-28(fp)
8114185c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141860:	008010c4 	movi	r2,67
81141864:	00002e06 	br	81141920 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81141868:	e0bff817 	ldw	r2,-32(fp)
8114186c:	1080040b 	ldhu	r2,16(r2)
81141870:	10bfffcc 	andi	r2,r2,65535
81141874:	1080004c 	andi	r2,r2,1
81141878:	1000061e 	bne	r2,zero,81141894 <OSTaskStkChk+0x12c>
8114187c:	e0bff617 	ldw	r2,-40(fp)
81141880:	e0bffa15 	stw	r2,-24(fp)
81141884:	e0bffa17 	ldw	r2,-24(fp)
81141888:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8114188c:	00801144 	movi	r2,69
81141890:	00002306 	br	81141920 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
81141894:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
81141898:	e0bff817 	ldw	r2,-32(fp)
8114189c:	10800317 	ldw	r2,12(r2)
811418a0:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
811418a4:	e0bff817 	ldw	r2,-32(fp)
811418a8:	10800217 	ldw	r2,8(r2)
811418ac:	e0bff415 	stw	r2,-48(fp)
811418b0:	e0bff617 	ldw	r2,-40(fp)
811418b4:	e0bffb15 	stw	r2,-20(fp)
811418b8:	e0bffb17 	ldw	r2,-20(fp)
811418bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811418c0:	00000306 	br	811418d0 <OSTaskStkChk+0x168>
        nfree++;
811418c4:	e0bff517 	ldw	r2,-44(fp)
811418c8:	10800044 	addi	r2,r2,1
811418cc:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811418d0:	e0bff417 	ldw	r2,-48(fp)
811418d4:	10c00104 	addi	r3,r2,4
811418d8:	e0fff415 	stw	r3,-48(fp)
811418dc:	10800017 	ldw	r2,0(r2)
811418e0:	103ff826 	beq	r2,zero,811418c4 <__reset+0xfb1218c4>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
811418e4:	e0bff517 	ldw	r2,-44(fp)
811418e8:	1085883a 	add	r2,r2,r2
811418ec:	1085883a 	add	r2,r2,r2
811418f0:	1007883a 	mov	r3,r2
811418f4:	e0bfff17 	ldw	r2,-4(fp)
811418f8:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
811418fc:	e0fffc17 	ldw	r3,-16(fp)
81141900:	e0bff517 	ldw	r2,-44(fp)
81141904:	1885c83a 	sub	r2,r3,r2
81141908:	1085883a 	add	r2,r2,r2
8114190c:	1085883a 	add	r2,r2,r2
81141910:	1007883a 	mov	r3,r2
81141914:	e0bfff17 	ldw	r2,-4(fp)
81141918:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8114191c:	0005883a 	mov	r2,zero
}
81141920:	e037883a 	mov	sp,fp
81141924:	df000017 	ldw	fp,0(sp)
81141928:	dec00104 	addi	sp,sp,4
8114192c:	f800283a 	ret

81141930 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81141930:	defff504 	addi	sp,sp,-44
81141934:	de00012e 	bgeu	sp,et,8114193c <OSTaskSuspend+0xc>
81141938:	003b68fa 	trap	3
8114193c:	dfc00a15 	stw	ra,40(sp)
81141940:	df000915 	stw	fp,36(sp)
81141944:	df000904 	addi	fp,sp,36
81141948:	2005883a 	mov	r2,r4
8114194c:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141950:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
81141954:	e0bfff03 	ldbu	r2,-4(fp)
81141958:	10800a98 	cmpnei	r2,r2,42
8114195c:	1000021e 	bne	r2,zero,81141968 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
81141960:	008011c4 	movi	r2,71
81141964:	00006806 	br	81141b08 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81141968:	e0bfff03 	ldbu	r2,-4(fp)
8114196c:	10800ab0 	cmpltui	r2,r2,42
81141970:	1000051e 	bne	r2,zero,81141988 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
81141974:	e0bfff03 	ldbu	r2,-4(fp)
81141978:	10803fe0 	cmpeqi	r2,r2,255
8114197c:	1000021e 	bne	r2,zero,81141988 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
81141980:	00800a84 	movi	r2,42
81141984:	00006006 	br	81141b08 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141988:	0005303a 	rdctl	r2,status
8114198c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141990:	e0fffe17 	ldw	r3,-8(fp)
81141994:	00bfff84 	movi	r2,-2
81141998:	1884703a 	and	r2,r3,r2
8114199c:	1001703a 	wrctl	status,r2
  
  return context;
811419a0:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
811419a4:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
811419a8:	e0bfff03 	ldbu	r2,-4(fp)
811419ac:	10803fd8 	cmpnei	r2,r2,255
811419b0:	1000061e 	bne	r2,zero,811419cc <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811419b4:	d0a0a217 	ldw	r2,-32120(gp)
811419b8:	10800c83 	ldbu	r2,50(r2)
811419bc:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
811419c0:	00800044 	movi	r2,1
811419c4:	e0bff705 	stb	r2,-36(fp)
811419c8:	00000906 	br	811419f0 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
811419cc:	d0a0a217 	ldw	r2,-32120(gp)
811419d0:	10800c83 	ldbu	r2,50(r2)
811419d4:	10c03fcc 	andi	r3,r2,255
811419d8:	e0bfff03 	ldbu	r2,-4(fp)
811419dc:	1880031e 	bne	r3,r2,811419ec <OSTaskSuspend+0xbc>
        self = OS_TRUE;
811419e0:	00800044 	movi	r2,1
811419e4:	e0bff705 	stb	r2,-36(fp)
811419e8:	00000106 	br	811419f0 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
811419ec:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811419f0:	e0ffff03 	ldbu	r3,-4(fp)
811419f4:	00a045f4 	movhi	r2,33047
811419f8:	10b81c04 	addi	r2,r2,-8080
811419fc:	18c7883a 	add	r3,r3,r3
81141a00:	18c7883a 	add	r3,r3,r3
81141a04:	10c5883a 	add	r2,r2,r3
81141a08:	10800017 	ldw	r2,0(r2)
81141a0c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81141a10:	e0bffa17 	ldw	r2,-24(fp)
81141a14:	1000061e 	bne	r2,zero,81141a30 <OSTaskSuspend+0x100>
81141a18:	e0bff817 	ldw	r2,-32(fp)
81141a1c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141a20:	e0bff917 	ldw	r2,-28(fp)
81141a24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
81141a28:	00801204 	movi	r2,72
81141a2c:	00003606 	br	81141b08 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81141a30:	e0bffa17 	ldw	r2,-24(fp)
81141a34:	10800058 	cmpnei	r2,r2,1
81141a38:	1000061e 	bne	r2,zero,81141a54 <OSTaskSuspend+0x124>
81141a3c:	e0bff817 	ldw	r2,-32(fp)
81141a40:	e0bffb15 	stw	r2,-20(fp)
81141a44:	e0bffb17 	ldw	r2,-20(fp)
81141a48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141a4c:	008010c4 	movi	r2,67
81141a50:	00002d06 	br	81141b08 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
81141a54:	e0bffa17 	ldw	r2,-24(fp)
81141a58:	10800d03 	ldbu	r2,52(r2)
81141a5c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
81141a60:	e0fffd03 	ldbu	r3,-12(fp)
81141a64:	e13ffd03 	ldbu	r4,-12(fp)
81141a68:	d0a09e44 	addi	r2,gp,-32135
81141a6c:	2085883a 	add	r2,r4,r2
81141a70:	10800003 	ldbu	r2,0(r2)
81141a74:	1009883a 	mov	r4,r2
81141a78:	e0bffa17 	ldw	r2,-24(fp)
81141a7c:	10800d43 	ldbu	r2,53(r2)
81141a80:	0084303a 	nor	r2,zero,r2
81141a84:	2084703a 	and	r2,r4,r2
81141a88:	1009883a 	mov	r4,r2
81141a8c:	d0a09e44 	addi	r2,gp,-32135
81141a90:	1885883a 	add	r2,r3,r2
81141a94:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81141a98:	e0fffd03 	ldbu	r3,-12(fp)
81141a9c:	d0a09e44 	addi	r2,gp,-32135
81141aa0:	1885883a 	add	r2,r3,r2
81141aa4:	10800003 	ldbu	r2,0(r2)
81141aa8:	10803fcc 	andi	r2,r2,255
81141aac:	1000071e 	bne	r2,zero,81141acc <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81141ab0:	e0bffa17 	ldw	r2,-24(fp)
81141ab4:	10800d83 	ldbu	r2,54(r2)
81141ab8:	0084303a 	nor	r2,zero,r2
81141abc:	1007883a 	mov	r3,r2
81141ac0:	d0a09e03 	ldbu	r2,-32136(gp)
81141ac4:	1884703a 	and	r2,r3,r2
81141ac8:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81141acc:	e0bffa17 	ldw	r2,-24(fp)
81141ad0:	10800c03 	ldbu	r2,48(r2)
81141ad4:	10800214 	ori	r2,r2,8
81141ad8:	1007883a 	mov	r3,r2
81141adc:	e0bffa17 	ldw	r2,-24(fp)
81141ae0:	10c00c05 	stb	r3,48(r2)
81141ae4:	e0bff817 	ldw	r2,-32(fp)
81141ae8:	e0bffc15 	stw	r2,-16(fp)
81141aec:	e0bffc17 	ldw	r2,-16(fp)
81141af0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
81141af4:	e0bff703 	ldbu	r2,-36(fp)
81141af8:	10800058 	cmpnei	r2,r2,1
81141afc:	1000011e 	bne	r2,zero,81141b04 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81141b00:	113af840 	call	8113af84 <OS_Sched>
    }
    return (OS_ERR_NONE);
81141b04:	0005883a 	mov	r2,zero
}
81141b08:	e037883a 	mov	sp,fp
81141b0c:	dfc00117 	ldw	ra,4(sp)
81141b10:	df000017 	ldw	fp,0(sp)
81141b14:	dec00204 	addi	sp,sp,8
81141b18:	f800283a 	ret

81141b1c <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81141b1c:	defff604 	addi	sp,sp,-40
81141b20:	de00012e 	bgeu	sp,et,81141b28 <OSTaskQuery+0xc>
81141b24:	003b68fa 	trap	3
81141b28:	dfc00915 	stw	ra,36(sp)
81141b2c:	df000815 	stw	fp,32(sp)
81141b30:	df000804 	addi	fp,sp,32
81141b34:	2005883a 	mov	r2,r4
81141b38:	e17fff15 	stw	r5,-4(fp)
81141b3c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141b40:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
81141b44:	e0bffe03 	ldbu	r2,-8(fp)
81141b48:	10800af0 	cmpltui	r2,r2,43
81141b4c:	1000051e 	bne	r2,zero,81141b64 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81141b50:	e0bffe03 	ldbu	r2,-8(fp)
81141b54:	10803fe0 	cmpeqi	r2,r2,255
81141b58:	1000021e 	bne	r2,zero,81141b64 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
81141b5c:	00800a84 	movi	r2,42
81141b60:	00003406 	br	81141c34 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
81141b64:	e0bfff17 	ldw	r2,-4(fp)
81141b68:	1000021e 	bne	r2,zero,81141b74 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
81141b6c:	00800244 	movi	r2,9
81141b70:	00003006 	br	81141c34 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141b74:	0005303a 	rdctl	r2,status
81141b78:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141b7c:	e0fffd17 	ldw	r3,-12(fp)
81141b80:	00bfff84 	movi	r2,-2
81141b84:	1884703a 	and	r2,r3,r2
81141b88:	1001703a 	wrctl	status,r2
  
  return context;
81141b8c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141b90:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
81141b94:	e0bffe03 	ldbu	r2,-8(fp)
81141b98:	10803fd8 	cmpnei	r2,r2,255
81141b9c:	1000031e 	bne	r2,zero,81141bac <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
81141ba0:	d0a0a217 	ldw	r2,-32120(gp)
81141ba4:	10800c83 	ldbu	r2,50(r2)
81141ba8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141bac:	e0fffe03 	ldbu	r3,-8(fp)
81141bb0:	00a045f4 	movhi	r2,33047
81141bb4:	10b81c04 	addi	r2,r2,-8080
81141bb8:	18c7883a 	add	r3,r3,r3
81141bbc:	18c7883a 	add	r3,r3,r3
81141bc0:	10c5883a 	add	r2,r2,r3
81141bc4:	10800017 	ldw	r2,0(r2)
81141bc8:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81141bcc:	e0bffa17 	ldw	r2,-24(fp)
81141bd0:	1000061e 	bne	r2,zero,81141bec <OSTaskQuery+0xd0>
81141bd4:	e0bff817 	ldw	r2,-32(fp)
81141bd8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141bdc:	e0bff917 	ldw	r2,-28(fp)
81141be0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
81141be4:	00800a44 	movi	r2,41
81141be8:	00001206 	br	81141c34 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81141bec:	e0bffa17 	ldw	r2,-24(fp)
81141bf0:	10800058 	cmpnei	r2,r2,1
81141bf4:	1000061e 	bne	r2,zero,81141c10 <OSTaskQuery+0xf4>
81141bf8:	e0bff817 	ldw	r2,-32(fp)
81141bfc:	e0bffb15 	stw	r2,-20(fp)
81141c00:	e0bffb17 	ldw	r2,-20(fp)
81141c04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141c08:	008010c4 	movi	r2,67
81141c0c:	00000906 	br	81141c34 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81141c10:	01801b04 	movi	r6,108
81141c14:	e17ffa17 	ldw	r5,-24(fp)
81141c18:	e13fff17 	ldw	r4,-4(fp)
81141c1c:	113af140 	call	8113af14 <OS_MemCopy>
81141c20:	e0bff817 	ldw	r2,-32(fp)
81141c24:	e0bffc15 	stw	r2,-16(fp)
81141c28:	e0bffc17 	ldw	r2,-16(fp)
81141c2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81141c30:	0005883a 	mov	r2,zero
}
81141c34:	e037883a 	mov	sp,fp
81141c38:	dfc00117 	ldw	ra,4(sp)
81141c3c:	df000017 	ldw	fp,0(sp)
81141c40:	dec00204 	addi	sp,sp,8
81141c44:	f800283a 	ret

81141c48 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
81141c48:	defffc04 	addi	sp,sp,-16
81141c4c:	de00012e 	bgeu	sp,et,81141c54 <OS_TaskStkClr+0xc>
81141c50:	003b68fa 	trap	3
81141c54:	df000315 	stw	fp,12(sp)
81141c58:	df000304 	addi	fp,sp,12
81141c5c:	e13ffd15 	stw	r4,-12(fp)
81141c60:	e17ffe15 	stw	r5,-8(fp)
81141c64:	3005883a 	mov	r2,r6
81141c68:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
81141c6c:	e0bfff0b 	ldhu	r2,-4(fp)
81141c70:	1080004c 	andi	r2,r2,1
81141c74:	10000d26 	beq	r2,zero,81141cac <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
81141c78:	e0bfff0b 	ldhu	r2,-4(fp)
81141c7c:	1080008c 	andi	r2,r2,2
81141c80:	10000a26 	beq	r2,zero,81141cac <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81141c84:	00000706 	br	81141ca4 <OS_TaskStkClr+0x5c>
                size--;
81141c88:	e0bffe17 	ldw	r2,-8(fp)
81141c8c:	10bfffc4 	addi	r2,r2,-1
81141c90:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
81141c94:	e0bffd17 	ldw	r2,-12(fp)
81141c98:	10c00104 	addi	r3,r2,4
81141c9c:	e0fffd15 	stw	r3,-12(fp)
81141ca0:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81141ca4:	e0bffe17 	ldw	r2,-8(fp)
81141ca8:	103ff71e 	bne	r2,zero,81141c88 <__reset+0xfb121c88>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
81141cac:	0001883a 	nop
81141cb0:	e037883a 	mov	sp,fp
81141cb4:	df000017 	ldw	fp,0(sp)
81141cb8:	dec00104 	addi	sp,sp,4
81141cbc:	f800283a 	ret

81141cc0 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
81141cc0:	defff904 	addi	sp,sp,-28
81141cc4:	de00012e 	bgeu	sp,et,81141ccc <OSTimeDly+0xc>
81141cc8:	003b68fa 	trap	3
81141ccc:	dfc00615 	stw	ra,24(sp)
81141cd0:	df000515 	stw	fp,20(sp)
81141cd4:	df000504 	addi	fp,sp,20
81141cd8:	2005883a 	mov	r2,r4
81141cdc:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141ce0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81141ce4:	d0a0a103 	ldbu	r2,-32124(gp)
81141ce8:	10803fcc 	andi	r2,r2,255
81141cec:	1000311e 	bne	r2,zero,81141db4 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81141cf0:	e0bfff0b 	ldhu	r2,-4(fp)
81141cf4:	10003026 	beq	r2,zero,81141db8 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141cf8:	0005303a 	rdctl	r2,status
81141cfc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141d00:	e0fffe17 	ldw	r3,-8(fp)
81141d04:	00bfff84 	movi	r2,-2
81141d08:	1884703a 	and	r2,r3,r2
81141d0c:	1001703a 	wrctl	status,r2
  
  return context;
81141d10:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
81141d14:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
81141d18:	d0a0a217 	ldw	r2,-32120(gp)
81141d1c:	10800d03 	ldbu	r2,52(r2)
81141d20:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81141d24:	e0fffd03 	ldbu	r3,-12(fp)
81141d28:	e13ffd03 	ldbu	r4,-12(fp)
81141d2c:	d0a09e44 	addi	r2,gp,-32135
81141d30:	2085883a 	add	r2,r4,r2
81141d34:	10800003 	ldbu	r2,0(r2)
81141d38:	1009883a 	mov	r4,r2
81141d3c:	d0a0a217 	ldw	r2,-32120(gp)
81141d40:	10800d43 	ldbu	r2,53(r2)
81141d44:	0084303a 	nor	r2,zero,r2
81141d48:	2084703a 	and	r2,r4,r2
81141d4c:	1009883a 	mov	r4,r2
81141d50:	d0a09e44 	addi	r2,gp,-32135
81141d54:	1885883a 	add	r2,r3,r2
81141d58:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81141d5c:	e0fffd03 	ldbu	r3,-12(fp)
81141d60:	d0a09e44 	addi	r2,gp,-32135
81141d64:	1885883a 	add	r2,r3,r2
81141d68:	10800003 	ldbu	r2,0(r2)
81141d6c:	10803fcc 	andi	r2,r2,255
81141d70:	1000071e 	bne	r2,zero,81141d90 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81141d74:	d0a0a217 	ldw	r2,-32120(gp)
81141d78:	10800d83 	ldbu	r2,54(r2)
81141d7c:	0084303a 	nor	r2,zero,r2
81141d80:	1007883a 	mov	r3,r2
81141d84:	d0a09e03 	ldbu	r2,-32136(gp)
81141d88:	1884703a 	and	r2,r3,r2
81141d8c:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
81141d90:	d0a0a217 	ldw	r2,-32120(gp)
81141d94:	e0ffff0b 	ldhu	r3,-4(fp)
81141d98:	10c00b8d 	sth	r3,46(r2)
81141d9c:	e0bffb17 	ldw	r2,-20(fp)
81141da0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141da4:	e0bffc17 	ldw	r2,-16(fp)
81141da8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81141dac:	113af840 	call	8113af84 <OS_Sched>
81141db0:	00000106 	br	81141db8 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
81141db4:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81141db8:	e037883a 	mov	sp,fp
81141dbc:	dfc00117 	ldw	ra,4(sp)
81141dc0:	df000017 	ldw	fp,0(sp)
81141dc4:	dec00204 	addi	sp,sp,8
81141dc8:	f800283a 	ret

81141dcc <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81141dcc:	defff804 	addi	sp,sp,-32
81141dd0:	de00012e 	bgeu	sp,et,81141dd8 <OSTimeDlyHMSM+0xc>
81141dd4:	003b68fa 	trap	3
81141dd8:	dfc00715 	stw	ra,28(sp)
81141ddc:	df000615 	stw	fp,24(sp)
81141de0:	df000604 	addi	fp,sp,24
81141de4:	2015883a 	mov	r10,r4
81141de8:	2809883a 	mov	r4,r5
81141dec:	3007883a 	mov	r3,r6
81141df0:	3805883a 	mov	r2,r7
81141df4:	e2bffc05 	stb	r10,-16(fp)
81141df8:	e13ffd05 	stb	r4,-12(fp)
81141dfc:	e0fffe05 	stb	r3,-8(fp)
81141e00:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81141e04:	d0a0a103 	ldbu	r2,-32124(gp)
81141e08:	10803fcc 	andi	r2,r2,255
81141e0c:	10000226 	beq	r2,zero,81141e18 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81141e10:	00801544 	movi	r2,85
81141e14:	00004106 	br	81141f1c <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81141e18:	e0bffc03 	ldbu	r2,-16(fp)
81141e1c:	1000081e 	bne	r2,zero,81141e40 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81141e20:	e0bffd03 	ldbu	r2,-12(fp)
81141e24:	1000061e 	bne	r2,zero,81141e40 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81141e28:	e0bffe03 	ldbu	r2,-8(fp)
81141e2c:	1000041e 	bne	r2,zero,81141e40 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81141e30:	e0bfff0b 	ldhu	r2,-4(fp)
81141e34:	1000021e 	bne	r2,zero,81141e40 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81141e38:	00801504 	movi	r2,84
81141e3c:	00003706 	br	81141f1c <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81141e40:	e0bffd03 	ldbu	r2,-12(fp)
81141e44:	10800f30 	cmpltui	r2,r2,60
81141e48:	1000021e 	bne	r2,zero,81141e54 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81141e4c:	00801444 	movi	r2,81
81141e50:	00003206 	br	81141f1c <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81141e54:	e0bffe03 	ldbu	r2,-8(fp)
81141e58:	10800f30 	cmpltui	r2,r2,60
81141e5c:	1000021e 	bne	r2,zero,81141e68 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81141e60:	00801484 	movi	r2,82
81141e64:	00002d06 	br	81141f1c <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81141e68:	e0bfff0b 	ldhu	r2,-4(fp)
81141e6c:	1080fa30 	cmpltui	r2,r2,1000
81141e70:	1000021e 	bne	r2,zero,81141e7c <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81141e74:	008014c4 	movi	r2,83
81141e78:	00002806 	br	81141f1c <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81141e7c:	e0bffc03 	ldbu	r2,-16(fp)
81141e80:	10c38424 	muli	r3,r2,3600
81141e84:	e0bffd03 	ldbu	r2,-12(fp)
81141e88:	10800f24 	muli	r2,r2,60
81141e8c:	1887883a 	add	r3,r3,r2
81141e90:	e0bffe03 	ldbu	r2,-8(fp)
81141e94:	1885883a 	add	r2,r3,r2
81141e98:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81141e9c:	e0bfff0b 	ldhu	r2,-4(fp)
81141ea0:	10c0fa24 	muli	r3,r2,1000
81141ea4:	008418b4 	movhi	r2,4194
81141ea8:	109374c4 	addi	r2,r2,19923
81141eac:	188a383a 	mulxuu	r5,r3,r2
81141eb0:	1885383a 	mul	r2,r3,r2
81141eb4:	1011883a 	mov	r8,r2
81141eb8:	2813883a 	mov	r9,r5
81141ebc:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81141ec0:	2085883a 	add	r2,r4,r2
81141ec4:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81141ec8:	e0bffb17 	ldw	r2,-20(fp)
81141ecc:	1004d43a 	srli	r2,r2,16
81141ed0:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81141ed4:	e0bffb17 	ldw	r2,-20(fp)
81141ed8:	10bfffcc 	andi	r2,r2,65535
81141edc:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81141ee0:	e0bffb17 	ldw	r2,-20(fp)
81141ee4:	10bfffcc 	andi	r2,r2,65535
81141ee8:	1009883a 	mov	r4,r2
81141eec:	1141cc00 	call	81141cc0 <OSTimeDly>
    while (loops > 0) {
81141ef0:	00000706 	br	81141f10 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81141ef4:	01200014 	movui	r4,32768
81141ef8:	1141cc00 	call	81141cc0 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81141efc:	01200014 	movui	r4,32768
81141f00:	1141cc00 	call	81141cc0 <OSTimeDly>
        loops--;
81141f04:	e0bffa0b 	ldhu	r2,-24(fp)
81141f08:	10bfffc4 	addi	r2,r2,-1
81141f0c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81141f10:	e0bffa0b 	ldhu	r2,-24(fp)
81141f14:	103ff71e 	bne	r2,zero,81141ef4 <__reset+0xfb121ef4>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81141f18:	0005883a 	mov	r2,zero
}
81141f1c:	e037883a 	mov	sp,fp
81141f20:	dfc00117 	ldw	ra,4(sp)
81141f24:	df000017 	ldw	fp,0(sp)
81141f28:	dec00204 	addi	sp,sp,8
81141f2c:	f800283a 	ret

81141f30 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81141f30:	defff504 	addi	sp,sp,-44
81141f34:	de00012e 	bgeu	sp,et,81141f3c <OSTimeDlyResume+0xc>
81141f38:	003b68fa 	trap	3
81141f3c:	dfc00a15 	stw	ra,40(sp)
81141f40:	df000915 	stw	fp,36(sp)
81141f44:	df000904 	addi	fp,sp,36
81141f48:	2005883a 	mov	r2,r4
81141f4c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81141f50:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81141f54:	e0bfff03 	ldbu	r2,-4(fp)
81141f58:	10800ab0 	cmpltui	r2,r2,42
81141f5c:	1000021e 	bne	r2,zero,81141f68 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81141f60:	00800a84 	movi	r2,42
81141f64:	00006406 	br	811420f8 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141f68:	0005303a 	rdctl	r2,status
81141f6c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141f70:	e0fffe17 	ldw	r3,-8(fp)
81141f74:	00bfff84 	movi	r2,-2
81141f78:	1884703a 	and	r2,r3,r2
81141f7c:	1001703a 	wrctl	status,r2
  
  return context;
81141f80:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81141f84:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81141f88:	e0ffff03 	ldbu	r3,-4(fp)
81141f8c:	00a045f4 	movhi	r2,33047
81141f90:	10b81c04 	addi	r2,r2,-8080
81141f94:	18c7883a 	add	r3,r3,r3
81141f98:	18c7883a 	add	r3,r3,r3
81141f9c:	10c5883a 	add	r2,r2,r3
81141fa0:	10800017 	ldw	r2,0(r2)
81141fa4:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81141fa8:	e0bff917 	ldw	r2,-28(fp)
81141fac:	1000061e 	bne	r2,zero,81141fc8 <OSTimeDlyResume+0x98>
81141fb0:	e0bff717 	ldw	r2,-36(fp)
81141fb4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141fb8:	e0bff817 	ldw	r2,-32(fp)
81141fbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81141fc0:	008010c4 	movi	r2,67
81141fc4:	00004c06 	br	811420f8 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81141fc8:	e0bff917 	ldw	r2,-28(fp)
81141fcc:	10800058 	cmpnei	r2,r2,1
81141fd0:	1000061e 	bne	r2,zero,81141fec <OSTimeDlyResume+0xbc>
81141fd4:	e0bff717 	ldw	r2,-36(fp)
81141fd8:	e0bffa15 	stw	r2,-24(fp)
81141fdc:	e0bffa17 	ldw	r2,-24(fp)
81141fe0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81141fe4:	008010c4 	movi	r2,67
81141fe8:	00004306 	br	811420f8 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81141fec:	e0bff917 	ldw	r2,-28(fp)
81141ff0:	10800b8b 	ldhu	r2,46(r2)
81141ff4:	10bfffcc 	andi	r2,r2,65535
81141ff8:	1000061e 	bne	r2,zero,81142014 <OSTimeDlyResume+0xe4>
81141ffc:	e0bff717 	ldw	r2,-36(fp)
81142000:	e0bffb15 	stw	r2,-20(fp)
81142004:	e0bffb17 	ldw	r2,-20(fp)
81142008:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8114200c:	00801404 	movi	r2,80
81142010:	00003906 	br	811420f8 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81142014:	e0bff917 	ldw	r2,-28(fp)
81142018:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8114201c:	e0bff917 	ldw	r2,-28(fp)
81142020:	10800c03 	ldbu	r2,48(r2)
81142024:	10803fcc 	andi	r2,r2,255
81142028:	10800dcc 	andi	r2,r2,55
8114202c:	10000b26 	beq	r2,zero,8114205c <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81142030:	e0bff917 	ldw	r2,-28(fp)
81142034:	10c00c03 	ldbu	r3,48(r2)
81142038:	00bff204 	movi	r2,-56
8114203c:	1884703a 	and	r2,r3,r2
81142040:	1007883a 	mov	r3,r2
81142044:	e0bff917 	ldw	r2,-28(fp)
81142048:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8114204c:	e0bff917 	ldw	r2,-28(fp)
81142050:	00c00044 	movi	r3,1
81142054:	10c00c45 	stb	r3,49(r2)
81142058:	00000206 	br	81142064 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8114205c:	e0bff917 	ldw	r2,-28(fp)
81142060:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81142064:	e0bff917 	ldw	r2,-28(fp)
81142068:	10800c03 	ldbu	r2,48(r2)
8114206c:	10803fcc 	andi	r2,r2,255
81142070:	1080020c 	andi	r2,r2,8
81142074:	10001b1e 	bne	r2,zero,811420e4 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81142078:	e0bff917 	ldw	r2,-28(fp)
8114207c:	10c00d83 	ldbu	r3,54(r2)
81142080:	d0a09e03 	ldbu	r2,-32136(gp)
81142084:	1884b03a 	or	r2,r3,r2
81142088:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8114208c:	e0bff917 	ldw	r2,-28(fp)
81142090:	10800d03 	ldbu	r2,52(r2)
81142094:	10c03fcc 	andi	r3,r2,255
81142098:	e0bff917 	ldw	r2,-28(fp)
8114209c:	10800d03 	ldbu	r2,52(r2)
811420a0:	11003fcc 	andi	r4,r2,255
811420a4:	d0a09e44 	addi	r2,gp,-32135
811420a8:	2085883a 	add	r2,r4,r2
811420ac:	11000003 	ldbu	r4,0(r2)
811420b0:	e0bff917 	ldw	r2,-28(fp)
811420b4:	10800d43 	ldbu	r2,53(r2)
811420b8:	2084b03a 	or	r2,r4,r2
811420bc:	1009883a 	mov	r4,r2
811420c0:	d0a09e44 	addi	r2,gp,-32135
811420c4:	1885883a 	add	r2,r3,r2
811420c8:	11000005 	stb	r4,0(r2)
811420cc:	e0bff717 	ldw	r2,-36(fp)
811420d0:	e0bffc15 	stw	r2,-16(fp)
811420d4:	e0bffc17 	ldw	r2,-16(fp)
811420d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
811420dc:	113af840 	call	8113af84 <OS_Sched>
811420e0:	00000406 	br	811420f4 <OSTimeDlyResume+0x1c4>
811420e4:	e0bff717 	ldw	r2,-36(fp)
811420e8:	e0bffd15 	stw	r2,-12(fp)
811420ec:	e0bffd17 	ldw	r2,-12(fp)
811420f0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
811420f4:	0005883a 	mov	r2,zero
}
811420f8:	e037883a 	mov	sp,fp
811420fc:	dfc00117 	ldw	ra,4(sp)
81142100:	df000017 	ldw	fp,0(sp)
81142104:	dec00204 	addi	sp,sp,8
81142108:	f800283a 	ret

8114210c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8114210c:	defffb04 	addi	sp,sp,-20
81142110:	de00012e 	bgeu	sp,et,81142118 <OSTimeGet+0xc>
81142114:	003b68fa 	trap	3
81142118:	df000415 	stw	fp,16(sp)
8114211c:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142120:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142124:	0005303a 	rdctl	r2,status
81142128:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114212c:	e0fffe17 	ldw	r3,-8(fp)
81142130:	00bfff84 	movi	r2,-2
81142134:	1884703a 	and	r2,r3,r2
81142138:	1001703a 	wrctl	status,r2
  
  return context;
8114213c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81142140:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81142144:	d0a0a417 	ldw	r2,-32112(gp)
81142148:	e0bffd15 	stw	r2,-12(fp)
8114214c:	e0bffc17 	ldw	r2,-16(fp)
81142150:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142154:	e0bfff17 	ldw	r2,-4(fp)
81142158:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8114215c:	e0bffd17 	ldw	r2,-12(fp)
}
81142160:	e037883a 	mov	sp,fp
81142164:	df000017 	ldw	fp,0(sp)
81142168:	dec00104 	addi	sp,sp,4
8114216c:	f800283a 	ret

81142170 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81142170:	defffb04 	addi	sp,sp,-20
81142174:	de00012e 	bgeu	sp,et,8114217c <OSTimeSet+0xc>
81142178:	003b68fa 	trap	3
8114217c:	df000415 	stw	fp,16(sp)
81142180:	df000404 	addi	fp,sp,16
81142184:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142188:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114218c:	0005303a 	rdctl	r2,status
81142190:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142194:	e0fffd17 	ldw	r3,-12(fp)
81142198:	00bfff84 	movi	r2,-2
8114219c:	1884703a 	and	r2,r3,r2
811421a0:	1001703a 	wrctl	status,r2
  
  return context;
811421a4:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
811421a8:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
811421ac:	e0bfff17 	ldw	r2,-4(fp)
811421b0:	d0a0a415 	stw	r2,-32112(gp)
811421b4:	e0bffc17 	ldw	r2,-16(fp)
811421b8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811421bc:	e0bffe17 	ldw	r2,-8(fp)
811421c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
811421c4:	0001883a 	nop
811421c8:	e037883a 	mov	sp,fp
811421cc:	df000017 	ldw	fp,0(sp)
811421d0:	dec00104 	addi	sp,sp,4
811421d4:	f800283a 	ret

811421d8 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
811421d8:	defff804 	addi	sp,sp,-32
811421dc:	de00012e 	bgeu	sp,et,811421e4 <OSTmrCreate+0xc>
811421e0:	003b68fa 	trap	3
811421e4:	dfc00715 	stw	ra,28(sp)
811421e8:	df000615 	stw	fp,24(sp)
811421ec:	df000604 	addi	fp,sp,24
811421f0:	e13ffc15 	stw	r4,-16(fp)
811421f4:	e17ffd15 	stw	r5,-12(fp)
811421f8:	3005883a 	mov	r2,r6
811421fc:	e1ffff15 	stw	r7,-4(fp)
81142200:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81142204:	e0800417 	ldw	r2,16(fp)
81142208:	1000021e 	bne	r2,zero,81142214 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8114220c:	0005883a 	mov	r2,zero
81142210:	00005d06 	br	81142388 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81142214:	e0bffe03 	ldbu	r2,-8(fp)
81142218:	10c00060 	cmpeqi	r3,r2,1
8114221c:	1800091e 	bne	r3,zero,81142244 <OSTmrCreate+0x6c>
81142220:	108000a0 	cmpeqi	r2,r2,2
81142224:	10000e26 	beq	r2,zero,81142260 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81142228:	e0bffd17 	ldw	r2,-12(fp)
8114222c:	1000111e 	bne	r2,zero,81142274 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81142230:	e0800417 	ldw	r2,16(fp)
81142234:	00ffe0c4 	movi	r3,-125
81142238:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8114223c:	0005883a 	mov	r2,zero
81142240:	00005106 	br	81142388 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81142244:	e0bffc17 	ldw	r2,-16(fp)
81142248:	10000c1e 	bne	r2,zero,8114227c <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8114224c:	e0800417 	ldw	r2,16(fp)
81142250:	00ffe084 	movi	r3,-126
81142254:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81142258:	0005883a 	mov	r2,zero
8114225c:	00004a06 	br	81142388 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81142260:	e0800417 	ldw	r2,16(fp)
81142264:	00ffe104 	movi	r3,-124
81142268:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8114226c:	0005883a 	mov	r2,zero
81142270:	00004506 	br	81142388 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81142274:	0001883a 	nop
81142278:	00000106 	br	81142280 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8114227c:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142280:	d0a0a103 	ldbu	r2,-32124(gp)
81142284:	10803fcc 	andi	r2,r2,255
81142288:	10000526 	beq	r2,zero,811422a0 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8114228c:	e0800417 	ldw	r2,16(fp)
81142290:	00ffe2c4 	movi	r3,-117
81142294:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81142298:	0005883a 	mov	r2,zero
8114229c:	00003a06 	br	81142388 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
811422a0:	11431900 	call	81143190 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
811422a4:	1142c300 	call	81142c30 <OSTmr_Alloc>
811422a8:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
811422ac:	e0bffa17 	ldw	r2,-24(fp)
811422b0:	1000061e 	bne	r2,zero,811422cc <OSTmrCreate+0xf4>
        OSTmr_Unlock();
811422b4:	11431d40 	call	811431d4 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
811422b8:	e0800417 	ldw	r2,16(fp)
811422bc:	00ffe184 	movi	r3,-122
811422c0:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
811422c4:	0005883a 	mov	r2,zero
811422c8:	00002f06 	br	81142388 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
811422cc:	e0bffa17 	ldw	r2,-24(fp)
811422d0:	00c00044 	movi	r3,1
811422d4:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
811422d8:	e0bffa17 	ldw	r2,-24(fp)
811422dc:	e0fffc17 	ldw	r3,-16(fp)
811422e0:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
811422e4:	e0bffa17 	ldw	r2,-24(fp)
811422e8:	e0fffd17 	ldw	r3,-12(fp)
811422ec:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
811422f0:	e0bffa17 	ldw	r2,-24(fp)
811422f4:	e0fffe03 	ldbu	r3,-8(fp)
811422f8:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
811422fc:	e0bffa17 	ldw	r2,-24(fp)
81142300:	e0ffff17 	ldw	r3,-4(fp)
81142304:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81142308:	e0bffa17 	ldw	r2,-24(fp)
8114230c:	e0c00217 	ldw	r3,8(fp)
81142310:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81142314:	e0800317 	ldw	r2,12(fp)
81142318:	10001726 	beq	r2,zero,81142378 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8114231c:	e1000317 	ldw	r4,12(fp)
81142320:	113b1540 	call	8113b154 <OS_StrLen>
81142324:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81142328:	e0bffb03 	ldbu	r2,-20(fp)
8114232c:	10800428 	cmpgeui	r2,r2,16
81142330:	1000061e 	bne	r2,zero,8114234c <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81142334:	e0bffa17 	ldw	r2,-24(fp)
81142338:	10800804 	addi	r2,r2,32
8114233c:	e1400317 	ldw	r5,12(fp)
81142340:	1009883a 	mov	r4,r2
81142344:	113b0d80 	call	8113b0d8 <OS_StrCopy>
81142348:	00000b06 	br	81142378 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8114234c:	e0bffa17 	ldw	r2,-24(fp)
81142350:	00c008c4 	movi	r3,35
81142354:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81142358:	e0bffa17 	ldw	r2,-24(fp)
8114235c:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81142360:	e0800417 	ldw	r2,16(fp)
81142364:	00ffe304 	movi	r3,-116
81142368:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8114236c:	11431d40 	call	811431d4 <OSTmr_Unlock>
            return (ptmr);
81142370:	e0bffa17 	ldw	r2,-24(fp)
81142374:	00000406 	br	81142388 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81142378:	11431d40 	call	811431d4 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8114237c:	e0800417 	ldw	r2,16(fp)
81142380:	10000005 	stb	zero,0(r2)
    return (ptmr);
81142384:	e0bffa17 	ldw	r2,-24(fp)
}
81142388:	e037883a 	mov	sp,fp
8114238c:	dfc00117 	ldw	ra,4(sp)
81142390:	df000017 	ldw	fp,0(sp)
81142394:	dec00204 	addi	sp,sp,8
81142398:	f800283a 	ret

8114239c <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8114239c:	defffc04 	addi	sp,sp,-16
811423a0:	de00012e 	bgeu	sp,et,811423a8 <OSTmrDel+0xc>
811423a4:	003b68fa 	trap	3
811423a8:	dfc00315 	stw	ra,12(sp)
811423ac:	df000215 	stw	fp,8(sp)
811423b0:	df000204 	addi	fp,sp,8
811423b4:	e13ffe15 	stw	r4,-8(fp)
811423b8:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811423bc:	e0bfff17 	ldw	r2,-4(fp)
811423c0:	1000021e 	bne	r2,zero,811423cc <OSTmrDel+0x30>
        return (OS_FALSE);
811423c4:	0005883a 	mov	r2,zero
811423c8:	00003f06 	br	811424c8 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
811423cc:	e0bffe17 	ldw	r2,-8(fp)
811423d0:	1000051e 	bne	r2,zero,811423e8 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811423d4:	e0bfff17 	ldw	r2,-4(fp)
811423d8:	00ffe284 	movi	r3,-118
811423dc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811423e0:	0005883a 	mov	r2,zero
811423e4:	00003806 	br	811424c8 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811423e8:	e0bffe17 	ldw	r2,-8(fp)
811423ec:	10800003 	ldbu	r2,0(r2)
811423f0:	10803fcc 	andi	r2,r2,255
811423f4:	10801920 	cmpeqi	r2,r2,100
811423f8:	1000051e 	bne	r2,zero,81142410 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811423fc:	e0bfff17 	ldw	r2,-4(fp)
81142400:	00ffe244 	movi	r3,-119
81142404:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142408:	0005883a 	mov	r2,zero
8114240c:	00002e06 	br	811424c8 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142410:	d0a0a103 	ldbu	r2,-32124(gp)
81142414:	10803fcc 	andi	r2,r2,255
81142418:	10000526 	beq	r2,zero,81142430 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8114241c:	e0bfff17 	ldw	r2,-4(fp)
81142420:	00ffe2c4 	movi	r3,-117
81142424:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142428:	0005883a 	mov	r2,zero
8114242c:	00002606 	br	811424c8 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81142430:	11431900 	call	81143190 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142434:	e0bffe17 	ldw	r2,-8(fp)
81142438:	10800c43 	ldbu	r2,49(r2)
8114243c:	10803fcc 	andi	r2,r2,255
81142440:	10c000c8 	cmpgei	r3,r2,3
81142444:	1800031e 	bne	r3,zero,81142454 <OSTmrDel+0xb8>
81142448:	00800d16 	blt	zero,r2,81142480 <OSTmrDel+0xe4>
8114244c:	10001326 	beq	r2,zero,8114249c <OSTmrDel+0x100>
81142450:	00001806 	br	811424b4 <OSTmrDel+0x118>
81142454:	108000e0 	cmpeqi	r2,r2,3
81142458:	10001626 	beq	r2,zero,811424b4 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8114245c:	e13ffe17 	ldw	r4,-8(fp)
81142460:	11430940 	call	81143094 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81142464:	e13ffe17 	ldw	r4,-8(fp)
81142468:	1142ca40 	call	81142ca4 <OSTmr_Free>
             OSTmr_Unlock();
8114246c:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142470:	e0bfff17 	ldw	r2,-4(fp)
81142474:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142478:	00800044 	movi	r2,1
8114247c:	00001206 	br	811424c8 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81142480:	e13ffe17 	ldw	r4,-8(fp)
81142484:	1142ca40 	call	81142ca4 <OSTmr_Free>
             OSTmr_Unlock();
81142488:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114248c:	e0bfff17 	ldw	r2,-4(fp)
81142490:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142494:	00800044 	movi	r2,1
81142498:	00000b06 	br	811424c8 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8114249c:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811424a0:	e0bfff17 	ldw	r2,-4(fp)
811424a4:	00ffe1c4 	movi	r3,-121
811424a8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811424ac:	0005883a 	mov	r2,zero
811424b0:	00000506 	br	811424c8 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
811424b4:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811424b8:	e0bfff17 	ldw	r2,-4(fp)
811424bc:	00ffe344 	movi	r3,-115
811424c0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811424c4:	0005883a 	mov	r2,zero
    }
}
811424c8:	e037883a 	mov	sp,fp
811424cc:	dfc00117 	ldw	ra,4(sp)
811424d0:	df000017 	ldw	fp,0(sp)
811424d4:	dec00204 	addi	sp,sp,8
811424d8:	f800283a 	ret

811424dc <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
811424dc:	defffa04 	addi	sp,sp,-24
811424e0:	de00012e 	bgeu	sp,et,811424e8 <OSTmrNameGet+0xc>
811424e4:	003b68fa 	trap	3
811424e8:	dfc00515 	stw	ra,20(sp)
811424ec:	df000415 	stw	fp,16(sp)
811424f0:	df000404 	addi	fp,sp,16
811424f4:	e13ffd15 	stw	r4,-12(fp)
811424f8:	e17ffe15 	stw	r5,-8(fp)
811424fc:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81142500:	e0bfff17 	ldw	r2,-4(fp)
81142504:	1000021e 	bne	r2,zero,81142510 <OSTmrNameGet+0x34>
        return (0);
81142508:	0005883a 	mov	r2,zero
8114250c:	00003e06 	br	81142608 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81142510:	e0bffe17 	ldw	r2,-8(fp)
81142514:	1000051e 	bne	r2,zero,8114252c <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81142518:	e0bfff17 	ldw	r2,-4(fp)
8114251c:	00ffe204 	movi	r3,-120
81142520:	10c00005 	stb	r3,0(r2)
        return (0);
81142524:	0005883a 	mov	r2,zero
81142528:	00003706 	br	81142608 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8114252c:	e0bffd17 	ldw	r2,-12(fp)
81142530:	1000051e 	bne	r2,zero,81142548 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81142534:	e0bfff17 	ldw	r2,-4(fp)
81142538:	00ffe284 	movi	r3,-118
8114253c:	10c00005 	stb	r3,0(r2)
        return (0);
81142540:	0005883a 	mov	r2,zero
81142544:	00003006 	br	81142608 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81142548:	e0bffd17 	ldw	r2,-12(fp)
8114254c:	10800003 	ldbu	r2,0(r2)
81142550:	10803fcc 	andi	r2,r2,255
81142554:	10801920 	cmpeqi	r2,r2,100
81142558:	1000051e 	bne	r2,zero,81142570 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114255c:	e0bfff17 	ldw	r2,-4(fp)
81142560:	00ffe244 	movi	r3,-119
81142564:	10c00005 	stb	r3,0(r2)
        return (0);
81142568:	0005883a 	mov	r2,zero
8114256c:	00002606 	br	81142608 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142570:	d0a0a103 	ldbu	r2,-32124(gp)
81142574:	10803fcc 	andi	r2,r2,255
81142578:	10000526 	beq	r2,zero,81142590 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8114257c:	e0bfff17 	ldw	r2,-4(fp)
81142580:	00c00444 	movi	r3,17
81142584:	10c00005 	stb	r3,0(r2)
        return (0);
81142588:	0005883a 	mov	r2,zero
8114258c:	00001e06 	br	81142608 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81142590:	11431900 	call	81143190 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142594:	e0bffd17 	ldw	r2,-12(fp)
81142598:	10800c43 	ldbu	r2,49(r2)
8114259c:	10803fcc 	andi	r2,r2,255
811425a0:	10000e26 	beq	r2,zero,811425dc <OSTmrNameGet+0x100>
811425a4:	10001316 	blt	r2,zero,811425f4 <OSTmrNameGet+0x118>
811425a8:	10800108 	cmpgei	r2,r2,4
811425ac:	1000111e 	bne	r2,zero,811425f4 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
811425b0:	e0bffd17 	ldw	r2,-12(fp)
811425b4:	10800804 	addi	r2,r2,32
811425b8:	100b883a 	mov	r5,r2
811425bc:	e13ffe17 	ldw	r4,-8(fp)
811425c0:	113b0d80 	call	8113b0d8 <OS_StrCopy>
811425c4:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
811425c8:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811425cc:	e0bfff17 	ldw	r2,-4(fp)
811425d0:	10000005 	stb	zero,0(r2)
             return (len);
811425d4:	e0bffc03 	ldbu	r2,-16(fp)
811425d8:	00000b06 	br	81142608 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
811425dc:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811425e0:	e0bfff17 	ldw	r2,-4(fp)
811425e4:	00ffe1c4 	movi	r3,-121
811425e8:	10c00005 	stb	r3,0(r2)
             return (0);
811425ec:	0005883a 	mov	r2,zero
811425f0:	00000506 	br	81142608 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
811425f4:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811425f8:	e0bfff17 	ldw	r2,-4(fp)
811425fc:	00ffe344 	movi	r3,-115
81142600:	10c00005 	stb	r3,0(r2)
             return (0);
81142604:	0005883a 	mov	r2,zero
    }
}
81142608:	e037883a 	mov	sp,fp
8114260c:	dfc00117 	ldw	ra,4(sp)
81142610:	df000017 	ldw	fp,0(sp)
81142614:	dec00204 	addi	sp,sp,8
81142618:	f800283a 	ret

8114261c <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8114261c:	defffb04 	addi	sp,sp,-20
81142620:	de00012e 	bgeu	sp,et,81142628 <OSTmrRemainGet+0xc>
81142624:	003b68fa 	trap	3
81142628:	dfc00415 	stw	ra,16(sp)
8114262c:	df000315 	stw	fp,12(sp)
81142630:	df000304 	addi	fp,sp,12
81142634:	e13ffe15 	stw	r4,-8(fp)
81142638:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8114263c:	e0bfff17 	ldw	r2,-4(fp)
81142640:	1000021e 	bne	r2,zero,8114264c <OSTmrRemainGet+0x30>
        return (0);
81142644:	0005883a 	mov	r2,zero
81142648:	00005d06 	br	811427c0 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8114264c:	e0bffe17 	ldw	r2,-8(fp)
81142650:	1000051e 	bne	r2,zero,81142668 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81142654:	e0bfff17 	ldw	r2,-4(fp)
81142658:	00ffe284 	movi	r3,-118
8114265c:	10c00005 	stb	r3,0(r2)
        return (0);
81142660:	0005883a 	mov	r2,zero
81142664:	00005606 	br	811427c0 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81142668:	e0bffe17 	ldw	r2,-8(fp)
8114266c:	10800003 	ldbu	r2,0(r2)
81142670:	10803fcc 	andi	r2,r2,255
81142674:	10801920 	cmpeqi	r2,r2,100
81142678:	1000051e 	bne	r2,zero,81142690 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114267c:	e0bfff17 	ldw	r2,-4(fp)
81142680:	00ffe244 	movi	r3,-119
81142684:	10c00005 	stb	r3,0(r2)
        return (0);
81142688:	0005883a 	mov	r2,zero
8114268c:	00004c06 	br	811427c0 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142690:	d0a0a103 	ldbu	r2,-32124(gp)
81142694:	10803fcc 	andi	r2,r2,255
81142698:	10000526 	beq	r2,zero,811426b0 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8114269c:	e0bfff17 	ldw	r2,-4(fp)
811426a0:	00ffe2c4 	movi	r3,-117
811426a4:	10c00005 	stb	r3,0(r2)
        return (0);
811426a8:	0005883a 	mov	r2,zero
811426ac:	00004406 	br	811427c0 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
811426b0:	11431900 	call	81143190 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811426b4:	e0bffe17 	ldw	r2,-8(fp)
811426b8:	10800c43 	ldbu	r2,49(r2)
811426bc:	10803fcc 	andi	r2,r2,255
811426c0:	10c00060 	cmpeqi	r3,r2,1
811426c4:	1800121e 	bne	r3,zero,81142710 <OSTmrRemainGet+0xf4>
811426c8:	10c00088 	cmpgei	r3,r2,2
811426cc:	1800021e 	bne	r3,zero,811426d8 <OSTmrRemainGet+0xbc>
811426d0:	10003026 	beq	r2,zero,81142794 <OSTmrRemainGet+0x178>
811426d4:	00003506 	br	811427ac <OSTmrRemainGet+0x190>
811426d8:	10c000a0 	cmpeqi	r3,r2,2
811426dc:	1800281e 	bne	r3,zero,81142780 <OSTmrRemainGet+0x164>
811426e0:	108000e0 	cmpeqi	r2,r2,3
811426e4:	10003126 	beq	r2,zero,811427ac <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
811426e8:	e0bffe17 	ldw	r2,-8(fp)
811426ec:	10c00517 	ldw	r3,20(r2)
811426f0:	d0a0a317 	ldw	r2,-32116(gp)
811426f4:	1885c83a 	sub	r2,r3,r2
811426f8:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
811426fc:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81142700:	e0bfff17 	ldw	r2,-4(fp)
81142704:	10000005 	stb	zero,0(r2)
             return (remain);
81142708:	e0bffd17 	ldw	r2,-12(fp)
8114270c:	00002c06 	br	811427c0 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81142710:	e0bffe17 	ldw	r2,-8(fp)
81142714:	10800c03 	ldbu	r2,48(r2)
81142718:	10803fcc 	andi	r2,r2,255
8114271c:	108000a0 	cmpeqi	r2,r2,2
81142720:	10000e26 	beq	r2,zero,8114275c <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81142724:	e0bffe17 	ldw	r2,-8(fp)
81142728:	10800617 	ldw	r2,24(r2)
8114272c:	1000041e 	bne	r2,zero,81142740 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81142730:	e0bffe17 	ldw	r2,-8(fp)
81142734:	10800717 	ldw	r2,28(r2)
81142738:	e0bffd15 	stw	r2,-12(fp)
8114273c:	00000306 	br	8114274c <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81142740:	e0bffe17 	ldw	r2,-8(fp)
81142744:	10800617 	ldw	r2,24(r2)
81142748:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8114274c:	11431d40 	call	811431d4 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81142750:	e0bfff17 	ldw	r2,-4(fp)
81142754:	10000005 	stb	zero,0(r2)
                      break;
81142758:	00000706 	br	81142778 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8114275c:	e0bffe17 	ldw	r2,-8(fp)
81142760:	10800617 	ldw	r2,24(r2)
81142764:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81142768:	11431d40 	call	811431d4 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8114276c:	e0bfff17 	ldw	r2,-4(fp)
81142770:	10000005 	stb	zero,0(r2)
                      break;
81142774:	0001883a 	nop
             }
             return (remain);
81142778:	e0bffd17 	ldw	r2,-12(fp)
8114277c:	00001006 	br	811427c0 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81142780:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142784:	e0bfff17 	ldw	r2,-4(fp)
81142788:	10000005 	stb	zero,0(r2)
             return (0);
8114278c:	0005883a 	mov	r2,zero
81142790:	00000b06 	br	811427c0 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
81142794:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142798:	e0bfff17 	ldw	r2,-4(fp)
8114279c:	00ffe1c4 	movi	r3,-121
811427a0:	10c00005 	stb	r3,0(r2)
             return (0);
811427a4:	0005883a 	mov	r2,zero
811427a8:	00000506 	br	811427c0 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
811427ac:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811427b0:	e0bfff17 	ldw	r2,-4(fp)
811427b4:	00ffe344 	movi	r3,-115
811427b8:	10c00005 	stb	r3,0(r2)
             return (0);
811427bc:	0005883a 	mov	r2,zero
    }
}
811427c0:	e037883a 	mov	sp,fp
811427c4:	dfc00117 	ldw	ra,4(sp)
811427c8:	df000017 	ldw	fp,0(sp)
811427cc:	dec00204 	addi	sp,sp,8
811427d0:	f800283a 	ret

811427d4 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
811427d4:	defffb04 	addi	sp,sp,-20
811427d8:	de00012e 	bgeu	sp,et,811427e0 <OSTmrStateGet+0xc>
811427dc:	003b68fa 	trap	3
811427e0:	dfc00415 	stw	ra,16(sp)
811427e4:	df000315 	stw	fp,12(sp)
811427e8:	df000304 	addi	fp,sp,12
811427ec:	e13ffe15 	stw	r4,-8(fp)
811427f0:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811427f4:	e0bfff17 	ldw	r2,-4(fp)
811427f8:	1000021e 	bne	r2,zero,81142804 <OSTmrStateGet+0x30>
        return (0);
811427fc:	0005883a 	mov	r2,zero
81142800:	00002a06 	br	811428ac <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
81142804:	e0bffe17 	ldw	r2,-8(fp)
81142808:	1000051e 	bne	r2,zero,81142820 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8114280c:	e0bfff17 	ldw	r2,-4(fp)
81142810:	00ffe284 	movi	r3,-118
81142814:	10c00005 	stb	r3,0(r2)
        return (0);
81142818:	0005883a 	mov	r2,zero
8114281c:	00002306 	br	811428ac <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81142820:	e0bffe17 	ldw	r2,-8(fp)
81142824:	10800003 	ldbu	r2,0(r2)
81142828:	10803fcc 	andi	r2,r2,255
8114282c:	10801920 	cmpeqi	r2,r2,100
81142830:	1000051e 	bne	r2,zero,81142848 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142834:	e0bfff17 	ldw	r2,-4(fp)
81142838:	00ffe244 	movi	r3,-119
8114283c:	10c00005 	stb	r3,0(r2)
        return (0);
81142840:	0005883a 	mov	r2,zero
81142844:	00001906 	br	811428ac <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142848:	d0a0a103 	ldbu	r2,-32124(gp)
8114284c:	10803fcc 	andi	r2,r2,255
81142850:	10000526 	beq	r2,zero,81142868 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81142854:	e0bfff17 	ldw	r2,-4(fp)
81142858:	00ffe2c4 	movi	r3,-117
8114285c:	10c00005 	stb	r3,0(r2)
        return (0);
81142860:	0005883a 	mov	r2,zero
81142864:	00001106 	br	811428ac <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81142868:	11431900 	call	81143190 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8114286c:	e0bffe17 	ldw	r2,-8(fp)
81142870:	10800c43 	ldbu	r2,49(r2)
81142874:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81142878:	e0bffd03 	ldbu	r2,-12(fp)
8114287c:	1005883a 	mov	r2,r2
81142880:	10800128 	cmpgeui	r2,r2,4
81142884:	1000031e 	bne	r2,zero,81142894 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81142888:	e0bfff17 	ldw	r2,-4(fp)
8114288c:	10000005 	stb	zero,0(r2)
             break;
81142890:	00000406 	br	811428a4 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
81142894:	e0bfff17 	ldw	r2,-4(fp)
81142898:	00ffe344 	movi	r3,-115
8114289c:	10c00005 	stb	r3,0(r2)
             break;
811428a0:	0001883a 	nop
    }
    OSTmr_Unlock();
811428a4:	11431d40 	call	811431d4 <OSTmr_Unlock>
    return (state);
811428a8:	e0bffd03 	ldbu	r2,-12(fp)
}
811428ac:	e037883a 	mov	sp,fp
811428b0:	dfc00117 	ldw	ra,4(sp)
811428b4:	df000017 	ldw	fp,0(sp)
811428b8:	dec00204 	addi	sp,sp,8
811428bc:	f800283a 	ret

811428c0 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
811428c0:	defffc04 	addi	sp,sp,-16
811428c4:	de00012e 	bgeu	sp,et,811428cc <OSTmrStart+0xc>
811428c8:	003b68fa 	trap	3
811428cc:	dfc00315 	stw	ra,12(sp)
811428d0:	df000215 	stw	fp,8(sp)
811428d4:	df000204 	addi	fp,sp,8
811428d8:	e13ffe15 	stw	r4,-8(fp)
811428dc:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811428e0:	e0bfff17 	ldw	r2,-4(fp)
811428e4:	1000021e 	bne	r2,zero,811428f0 <OSTmrStart+0x30>
        return (OS_FALSE);
811428e8:	0005883a 	mov	r2,zero
811428ec:	00004106 	br	811429f4 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
811428f0:	e0bffe17 	ldw	r2,-8(fp)
811428f4:	1000051e 	bne	r2,zero,8114290c <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811428f8:	e0bfff17 	ldw	r2,-4(fp)
811428fc:	00ffe284 	movi	r3,-118
81142900:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142904:	0005883a 	mov	r2,zero
81142908:	00003a06 	br	811429f4 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8114290c:	e0bffe17 	ldw	r2,-8(fp)
81142910:	10800003 	ldbu	r2,0(r2)
81142914:	10803fcc 	andi	r2,r2,255
81142918:	10801920 	cmpeqi	r2,r2,100
8114291c:	1000051e 	bne	r2,zero,81142934 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142920:	e0bfff17 	ldw	r2,-4(fp)
81142924:	00ffe244 	movi	r3,-119
81142928:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114292c:	0005883a 	mov	r2,zero
81142930:	00003006 	br	811429f4 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142934:	d0a0a103 	ldbu	r2,-32124(gp)
81142938:	10803fcc 	andi	r2,r2,255
8114293c:	10000526 	beq	r2,zero,81142954 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81142940:	e0bfff17 	ldw	r2,-4(fp)
81142944:	00ffe2c4 	movi	r3,-117
81142948:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114294c:	0005883a 	mov	r2,zero
81142950:	00002806 	br	811429f4 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
81142954:	11431900 	call	81143190 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142958:	e0bffe17 	ldw	r2,-8(fp)
8114295c:	10800c43 	ldbu	r2,49(r2)
81142960:	10803fcc 	andi	r2,r2,255
81142964:	10c000c8 	cmpgei	r3,r2,3
81142968:	1800031e 	bne	r3,zero,81142978 <OSTmrStart+0xb8>
8114296c:	00800e16 	blt	zero,r2,811429a8 <OSTmrStart+0xe8>
81142970:	10001526 	beq	r2,zero,811429c8 <OSTmrStart+0x108>
81142974:	00001a06 	br	811429e0 <OSTmrStart+0x120>
81142978:	108000e0 	cmpeqi	r2,r2,3
8114297c:	10001826 	beq	r2,zero,811429e0 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
81142980:	e13ffe17 	ldw	r4,-8(fp)
81142984:	11430940 	call	81143094 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81142988:	000b883a 	mov	r5,zero
8114298c:	e13ffe17 	ldw	r4,-8(fp)
81142990:	1142f440 	call	81142f44 <OSTmr_Link>
             OSTmr_Unlock();
81142994:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142998:	e0bfff17 	ldw	r2,-4(fp)
8114299c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811429a0:	00800044 	movi	r2,1
811429a4:	00001306 	br	811429f4 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811429a8:	000b883a 	mov	r5,zero
811429ac:	e13ffe17 	ldw	r4,-8(fp)
811429b0:	1142f440 	call	81142f44 <OSTmr_Link>
             OSTmr_Unlock();
811429b4:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811429b8:	e0bfff17 	ldw	r2,-4(fp)
811429bc:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811429c0:	00800044 	movi	r2,1
811429c4:	00000b06 	br	811429f4 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
811429c8:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811429cc:	e0bfff17 	ldw	r2,-4(fp)
811429d0:	00ffe1c4 	movi	r3,-121
811429d4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811429d8:	0005883a 	mov	r2,zero
811429dc:	00000506 	br	811429f4 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
811429e0:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811429e4:	e0bfff17 	ldw	r2,-4(fp)
811429e8:	00ffe344 	movi	r3,-115
811429ec:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811429f0:	0005883a 	mov	r2,zero
    }
}
811429f4:	e037883a 	mov	sp,fp
811429f8:	dfc00117 	ldw	ra,4(sp)
811429fc:	df000017 	ldw	fp,0(sp)
81142a00:	dec00204 	addi	sp,sp,8
81142a04:	f800283a 	ret

81142a08 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
81142a08:	defff904 	addi	sp,sp,-28
81142a0c:	de00012e 	bgeu	sp,et,81142a14 <OSTmrStop+0xc>
81142a10:	003b68fa 	trap	3
81142a14:	dfc00615 	stw	ra,24(sp)
81142a18:	df000515 	stw	fp,20(sp)
81142a1c:	df000504 	addi	fp,sp,20
81142a20:	e13ffc15 	stw	r4,-16(fp)
81142a24:	2805883a 	mov	r2,r5
81142a28:	e1bffe15 	stw	r6,-8(fp)
81142a2c:	e1ffff15 	stw	r7,-4(fp)
81142a30:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
81142a34:	e0bfff17 	ldw	r2,-4(fp)
81142a38:	1000021e 	bne	r2,zero,81142a44 <OSTmrStop+0x3c>
        return (OS_FALSE);
81142a3c:	0005883a 	mov	r2,zero
81142a40:	00006606 	br	81142bdc <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
81142a44:	e0bffc17 	ldw	r2,-16(fp)
81142a48:	1000051e 	bne	r2,zero,81142a60 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
81142a4c:	e0bfff17 	ldw	r2,-4(fp)
81142a50:	00ffe284 	movi	r3,-118
81142a54:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142a58:	0005883a 	mov	r2,zero
81142a5c:	00005f06 	br	81142bdc <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81142a60:	e0bffc17 	ldw	r2,-16(fp)
81142a64:	10800003 	ldbu	r2,0(r2)
81142a68:	10803fcc 	andi	r2,r2,255
81142a6c:	10801920 	cmpeqi	r2,r2,100
81142a70:	1000051e 	bne	r2,zero,81142a88 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142a74:	e0bfff17 	ldw	r2,-4(fp)
81142a78:	00ffe244 	movi	r3,-119
81142a7c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142a80:	0005883a 	mov	r2,zero
81142a84:	00005506 	br	81142bdc <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81142a88:	d0a0a103 	ldbu	r2,-32124(gp)
81142a8c:	10803fcc 	andi	r2,r2,255
81142a90:	10000526 	beq	r2,zero,81142aa8 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
81142a94:	e0bfff17 	ldw	r2,-4(fp)
81142a98:	00ffe2c4 	movi	r3,-117
81142a9c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142aa0:	0005883a 	mov	r2,zero
81142aa4:	00004d06 	br	81142bdc <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
81142aa8:	11431900 	call	81143190 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142aac:	e0bffc17 	ldw	r2,-16(fp)
81142ab0:	10800c43 	ldbu	r2,49(r2)
81142ab4:	10803fcc 	andi	r2,r2,255
81142ab8:	10c000c8 	cmpgei	r3,r2,3
81142abc:	1800031e 	bne	r3,zero,81142acc <OSTmrStop+0xc4>
81142ac0:	00803516 	blt	zero,r2,81142b98 <OSTmrStop+0x190>
81142ac4:	10003a26 	beq	r2,zero,81142bb0 <OSTmrStop+0x1a8>
81142ac8:	00003f06 	br	81142bc8 <OSTmrStop+0x1c0>
81142acc:	108000e0 	cmpeqi	r2,r2,3
81142ad0:	10003d26 	beq	r2,zero,81142bc8 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
81142ad4:	e13ffc17 	ldw	r4,-16(fp)
81142ad8:	11430940 	call	81143094 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81142adc:	e0bfff17 	ldw	r2,-4(fp)
81142ae0:	10000005 	stb	zero,0(r2)
             switch (opt) {
81142ae4:	e0bffd03 	ldbu	r2,-12(fp)
81142ae8:	10c000e0 	cmpeqi	r3,r2,3
81142aec:	1800041e 	bne	r3,zero,81142b00 <OSTmrStop+0xf8>
81142af0:	10c00120 	cmpeqi	r3,r2,4
81142af4:	1800121e 	bne	r3,zero,81142b40 <OSTmrStop+0x138>
81142af8:	10002326 	beq	r2,zero,81142b88 <OSTmrStop+0x180>
81142afc:	00001e06 	br	81142b78 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81142b00:	e0bffc17 	ldw	r2,-16(fp)
81142b04:	10800117 	ldw	r2,4(r2)
81142b08:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81142b0c:	e0bffb17 	ldw	r2,-20(fp)
81142b10:	10000726 	beq	r2,zero,81142b30 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
81142b14:	e0bffc17 	ldw	r2,-16(fp)
81142b18:	10c00217 	ldw	r3,8(r2)
81142b1c:	e0bffb17 	ldw	r2,-20(fp)
81142b20:	180b883a 	mov	r5,r3
81142b24:	e13ffc17 	ldw	r4,-16(fp)
81142b28:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81142b2c:	00001706 	br	81142b8c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81142b30:	e0bfff17 	ldw	r2,-4(fp)
81142b34:	00ffe3c4 	movi	r3,-113
81142b38:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81142b3c:	00001306 	br	81142b8c <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81142b40:	e0bffc17 	ldw	r2,-16(fp)
81142b44:	10800117 	ldw	r2,4(r2)
81142b48:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81142b4c:	e0bffb17 	ldw	r2,-20(fp)
81142b50:	10000526 	beq	r2,zero,81142b68 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
81142b54:	e0bffb17 	ldw	r2,-20(fp)
81142b58:	e17ffe17 	ldw	r5,-8(fp)
81142b5c:	e13ffc17 	ldw	r4,-16(fp)
81142b60:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81142b64:	00000906 	br	81142b8c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81142b68:	e0bfff17 	ldw	r2,-4(fp)
81142b6c:	00ffe3c4 	movi	r3,-113
81142b70:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81142b74:	00000506 	br	81142b8c <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
81142b78:	e0bfff17 	ldw	r2,-4(fp)
81142b7c:	00ffe104 	movi	r3,-124
81142b80:	10c00005 	stb	r3,0(r2)
                     break;
81142b84:	00000106 	br	81142b8c <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81142b88:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81142b8c:	11431d40 	call	811431d4 <OSTmr_Unlock>
             return (OS_TRUE);
81142b90:	00800044 	movi	r2,1
81142b94:	00001106 	br	81142bdc <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
81142b98:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81142b9c:	e0bfff17 	ldw	r2,-4(fp)
81142ba0:	00ffe384 	movi	r3,-114
81142ba4:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
81142ba8:	00800044 	movi	r2,1
81142bac:	00000b06 	br	81142bdc <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
81142bb0:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142bb4:	e0bfff17 	ldw	r2,-4(fp)
81142bb8:	00ffe1c4 	movi	r3,-121
81142bbc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142bc0:	0005883a 	mov	r2,zero
81142bc4:	00000506 	br	81142bdc <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
81142bc8:	11431d40 	call	811431d4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142bcc:	e0bfff17 	ldw	r2,-4(fp)
81142bd0:	00ffe344 	movi	r3,-115
81142bd4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142bd8:	0005883a 	mov	r2,zero
    }
}
81142bdc:	e037883a 	mov	sp,fp
81142be0:	dfc00117 	ldw	ra,4(sp)
81142be4:	df000017 	ldw	fp,0(sp)
81142be8:	dec00204 	addi	sp,sp,8
81142bec:	f800283a 	ret

81142bf0 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81142bf0:	defffd04 	addi	sp,sp,-12
81142bf4:	de00012e 	bgeu	sp,et,81142bfc <OSTmrSignal+0xc>
81142bf8:	003b68fa 	trap	3
81142bfc:	dfc00215 	stw	ra,8(sp)
81142c00:	df000115 	stw	fp,4(sp)
81142c04:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81142c08:	d0a09017 	ldw	r2,-32192(gp)
81142c0c:	1009883a 	mov	r4,r2
81142c10:	11401bc0 	call	811401bc <OSSemPost>
81142c14:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81142c18:	e0bfff03 	ldbu	r2,-4(fp)
}
81142c1c:	e037883a 	mov	sp,fp
81142c20:	dfc00117 	ldw	ra,4(sp)
81142c24:	df000017 	ldw	fp,0(sp)
81142c28:	dec00204 	addi	sp,sp,8
81142c2c:	f800283a 	ret

81142c30 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81142c30:	defffe04 	addi	sp,sp,-8
81142c34:	de00012e 	bgeu	sp,et,81142c3c <OSTmr_Alloc+0xc>
81142c38:	003b68fa 	trap	3
81142c3c:	df000115 	stw	fp,4(sp)
81142c40:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
81142c44:	d0a08e17 	ldw	r2,-32200(gp)
81142c48:	1000021e 	bne	r2,zero,81142c54 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81142c4c:	0005883a 	mov	r2,zero
81142c50:	00001006 	br	81142c94 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
81142c54:	d0a08e17 	ldw	r2,-32200(gp)
81142c58:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81142c5c:	e0bfff17 	ldw	r2,-4(fp)
81142c60:	10800317 	ldw	r2,12(r2)
81142c64:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
81142c68:	e0bfff17 	ldw	r2,-4(fp)
81142c6c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81142c70:	e0bfff17 	ldw	r2,-4(fp)
81142c74:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
81142c78:	d0a0930b 	ldhu	r2,-32180(gp)
81142c7c:	10800044 	addi	r2,r2,1
81142c80:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
81142c84:	d0a0970b 	ldhu	r2,-32164(gp)
81142c88:	10bfffc4 	addi	r2,r2,-1
81142c8c:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
81142c90:	e0bfff17 	ldw	r2,-4(fp)
}
81142c94:	e037883a 	mov	sp,fp
81142c98:	df000017 	ldw	fp,0(sp)
81142c9c:	dec00104 	addi	sp,sp,4
81142ca0:	f800283a 	ret

81142ca4 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
81142ca4:	defffe04 	addi	sp,sp,-8
81142ca8:	de00012e 	bgeu	sp,et,81142cb0 <OSTmr_Free+0xc>
81142cac:	003b68fa 	trap	3
81142cb0:	df000115 	stw	fp,4(sp)
81142cb4:	df000104 	addi	fp,sp,4
81142cb8:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81142cbc:	e0bfff17 	ldw	r2,-4(fp)
81142cc0:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
81142cc4:	e0bfff17 	ldw	r2,-4(fp)
81142cc8:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81142ccc:	e0bfff17 	ldw	r2,-4(fp)
81142cd0:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
81142cd4:	e0bfff17 	ldw	r2,-4(fp)
81142cd8:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81142cdc:	e0bfff17 	ldw	r2,-4(fp)
81142ce0:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
81142ce4:	e0bfff17 	ldw	r2,-4(fp)
81142ce8:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81142cec:	e0bfff17 	ldw	r2,-4(fp)
81142cf0:	00c00fc4 	movi	r3,63
81142cf4:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81142cf8:	e0bfff17 	ldw	r2,-4(fp)
81142cfc:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81142d00:	e0bfff17 	ldw	r2,-4(fp)
81142d04:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81142d08:	d0e08e17 	ldw	r3,-32200(gp)
81142d0c:	e0bfff17 	ldw	r2,-4(fp)
81142d10:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
81142d14:	e0bfff17 	ldw	r2,-4(fp)
81142d18:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81142d1c:	d0a0930b 	ldhu	r2,-32180(gp)
81142d20:	10bfffc4 	addi	r2,r2,-1
81142d24:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
81142d28:	d0a0970b 	ldhu	r2,-32164(gp)
81142d2c:	10800044 	addi	r2,r2,1
81142d30:	d0a0970d 	sth	r2,-32164(gp)
}
81142d34:	0001883a 	nop
81142d38:	e037883a 	mov	sp,fp
81142d3c:	df000017 	ldw	fp,0(sp)
81142d40:	dec00104 	addi	sp,sp,4
81142d44:	f800283a 	ret

81142d48 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81142d48:	defffa04 	addi	sp,sp,-24
81142d4c:	de00012e 	bgeu	sp,et,81142d54 <OSTmr_Init+0xc>
81142d50:	003b68fa 	trap	3
81142d54:	dfc00515 	stw	ra,20(sp)
81142d58:	df000415 	stw	fp,16(sp)
81142d5c:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81142d60:	01406804 	movi	r5,416
81142d64:	012045f4 	movhi	r4,33047
81142d68:	21223a04 	addi	r4,r4,-30488
81142d6c:	113aeb80 	call	8113aeb8 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81142d70:	01400404 	movi	r5,16
81142d74:	012045f4 	movhi	r4,33047
81142d78:	21202604 	addi	r4,r4,-32616
81142d7c:	113aeb80 	call	8113aeb8 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
81142d80:	00a045f4 	movhi	r2,33047
81142d84:	10a23a04 	addi	r2,r2,-30488
81142d88:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81142d8c:	00a045f4 	movhi	r2,33047
81142d90:	10a24704 	addi	r2,r2,-30436
81142d94:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81142d98:	e03ffc0d 	sth	zero,-16(fp)
81142d9c:	00001606 	br	81142df8 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81142da0:	e0bffd17 	ldw	r2,-12(fp)
81142da4:	00c01904 	movi	r3,100
81142da8:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81142dac:	e0bffd17 	ldw	r2,-12(fp)
81142db0:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81142db4:	e0bffd17 	ldw	r2,-12(fp)
81142db8:	e0fffe17 	ldw	r3,-8(fp)
81142dbc:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81142dc0:	e0bffd17 	ldw	r2,-12(fp)
81142dc4:	00c00fc4 	movi	r3,63
81142dc8:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81142dcc:	e0bffd17 	ldw	r2,-12(fp)
81142dd0:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81142dd4:	e0bffd17 	ldw	r2,-12(fp)
81142dd8:	10800d04 	addi	r2,r2,52
81142ddc:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81142de0:	e0bffe17 	ldw	r2,-8(fp)
81142de4:	10800d04 	addi	r2,r2,52
81142de8:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81142dec:	e0bffc0b 	ldhu	r2,-16(fp)
81142df0:	10800044 	addi	r2,r2,1
81142df4:	e0bffc0d 	sth	r2,-16(fp)
81142df8:	e0bffc0b 	ldhu	r2,-16(fp)
81142dfc:	108001f0 	cmpltui	r2,r2,7
81142e00:	103fe71e 	bne	r2,zero,81142da0 <__reset+0xfb122da0>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81142e04:	e0bffd17 	ldw	r2,-12(fp)
81142e08:	00c01904 	movi	r3,100
81142e0c:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81142e10:	e0bffd17 	ldw	r2,-12(fp)
81142e14:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81142e18:	e0bffd17 	ldw	r2,-12(fp)
81142e1c:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81142e20:	e0bffd17 	ldw	r2,-12(fp)
81142e24:	00c00fc4 	movi	r3,63
81142e28:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81142e2c:	e0bffd17 	ldw	r2,-12(fp)
81142e30:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81142e34:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
81142e38:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81142e3c:	00800204 	movi	r2,8
81142e40:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81142e44:	00a045f4 	movhi	r2,33047
81142e48:	10a23a04 	addi	r2,r2,-30488
81142e4c:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
81142e50:	01000044 	movi	r4,1
81142e54:	113fb0c0 	call	8113fb0c <OSSemCreate>
81142e58:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81142e5c:	0009883a 	mov	r4,zero
81142e60:	113fb0c0 	call	8113fb0c <OSSemCreate>
81142e64:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81142e68:	d0a0a517 	ldw	r2,-32108(gp)
81142e6c:	e0ffff04 	addi	r3,fp,-4
81142e70:	180d883a 	mov	r6,r3
81142e74:	01604574 	movhi	r5,33045
81142e78:	2948e604 	addi	r5,r5,9112
81142e7c:	1009883a 	mov	r4,r2
81142e80:	11397140 	call	81139714 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81142e84:	d0a09017 	ldw	r2,-32192(gp)
81142e88:	e0ffff04 	addi	r3,fp,-4
81142e8c:	180d883a 	mov	r6,r3
81142e90:	01604574 	movhi	r5,33045
81142e94:	2948eb04 	addi	r5,r5,9132
81142e98:	1009883a 	mov	r4,r2
81142e9c:	11397140 	call	81139714 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81142ea0:	1142ebc0 	call	81142ebc <OSTmr_InitTask>
}
81142ea4:	0001883a 	nop
81142ea8:	e037883a 	mov	sp,fp
81142eac:	dfc00117 	ldw	ra,4(sp)
81142eb0:	df000017 	ldw	fp,0(sp)
81142eb4:	dec00204 	addi	sp,sp,8
81142eb8:	f800283a 	ret

81142ebc <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81142ebc:	defff804 	addi	sp,sp,-32
81142ec0:	de00012e 	bgeu	sp,et,81142ec8 <OSTmr_InitTask+0xc>
81142ec4:	003b68fa 	trap	3
81142ec8:	dfc00715 	stw	ra,28(sp)
81142ecc:	df000615 	stw	fp,24(sp)
81142ed0:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81142ed4:	008000c4 	movi	r2,3
81142ed8:	d8800415 	stw	r2,16(sp)
81142edc:	d8000315 	stw	zero,12(sp)
81142ee0:	00808004 	movi	r2,512
81142ee4:	d8800215 	stw	r2,8(sp)
81142ee8:	00a045f4 	movhi	r2,33047
81142eec:	10aa6e04 	addi	r2,r2,-22088
81142ef0:	d8800115 	stw	r2,4(sp)
81142ef4:	00bfff54 	movui	r2,65533
81142ef8:	d8800015 	stw	r2,0(sp)
81142efc:	01c00744 	movi	r7,29
81142f00:	01a045f4 	movhi	r6,33047
81142f04:	31ac6d04 	addi	r6,r6,-20044
81142f08:	000b883a 	mov	r5,zero
81142f0c:	01204534 	movhi	r4,33044
81142f10:	210c8404 	addi	r4,r4,12816
81142f14:	1140ba00 	call	81140ba0 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81142f18:	e1bfff04 	addi	r6,fp,-4
81142f1c:	01604574 	movhi	r5,33045
81142f20:	2948f004 	addi	r5,r5,9152
81142f24:	01000744 	movi	r4,29
81142f28:	11413d00 	call	811413d0 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81142f2c:	0001883a 	nop
81142f30:	e037883a 	mov	sp,fp
81142f34:	dfc00117 	ldw	ra,4(sp)
81142f38:	df000017 	ldw	fp,0(sp)
81142f3c:	dec00204 	addi	sp,sp,8
81142f40:	f800283a 	ret

81142f44 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81142f44:	defffa04 	addi	sp,sp,-24
81142f48:	de00012e 	bgeu	sp,et,81142f50 <OSTmr_Link+0xc>
81142f4c:	003b68fa 	trap	3
81142f50:	df000515 	stw	fp,20(sp)
81142f54:	df000504 	addi	fp,sp,20
81142f58:	e13ffe15 	stw	r4,-8(fp)
81142f5c:	2805883a 	mov	r2,r5
81142f60:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81142f64:	e0bffe17 	ldw	r2,-8(fp)
81142f68:	00c000c4 	movi	r3,3
81142f6c:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81142f70:	e0bfff03 	ldbu	r2,-4(fp)
81142f74:	10800058 	cmpnei	r2,r2,1
81142f78:	1000071e 	bne	r2,zero,81142f98 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81142f7c:	e0bffe17 	ldw	r2,-8(fp)
81142f80:	10c00717 	ldw	r3,28(r2)
81142f84:	d0a0a317 	ldw	r2,-32116(gp)
81142f88:	1887883a 	add	r3,r3,r2
81142f8c:	e0bffe17 	ldw	r2,-8(fp)
81142f90:	10c00515 	stw	r3,20(r2)
81142f94:	00001006 	br	81142fd8 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81142f98:	e0bffe17 	ldw	r2,-8(fp)
81142f9c:	10800617 	ldw	r2,24(r2)
81142fa0:	1000071e 	bne	r2,zero,81142fc0 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81142fa4:	e0bffe17 	ldw	r2,-8(fp)
81142fa8:	10c00717 	ldw	r3,28(r2)
81142fac:	d0a0a317 	ldw	r2,-32116(gp)
81142fb0:	1887883a 	add	r3,r3,r2
81142fb4:	e0bffe17 	ldw	r2,-8(fp)
81142fb8:	10c00515 	stw	r3,20(r2)
81142fbc:	00000606 	br	81142fd8 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81142fc0:	e0bffe17 	ldw	r2,-8(fp)
81142fc4:	10c00617 	ldw	r3,24(r2)
81142fc8:	d0a0a317 	ldw	r2,-32116(gp)
81142fcc:	1887883a 	add	r3,r3,r2
81142fd0:	e0bffe17 	ldw	r2,-8(fp)
81142fd4:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81142fd8:	e0bffe17 	ldw	r2,-8(fp)
81142fdc:	10800517 	ldw	r2,20(r2)
81142fe0:	1080004c 	andi	r2,r2,1
81142fe4:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81142fe8:	e0bffb0b 	ldhu	r2,-20(fp)
81142fec:	100690fa 	slli	r3,r2,3
81142ff0:	00a045f4 	movhi	r2,33047
81142ff4:	10a02604 	addi	r2,r2,-32616
81142ff8:	1885883a 	add	r2,r3,r2
81142ffc:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81143000:	e0bffc17 	ldw	r2,-16(fp)
81143004:	10800017 	ldw	r2,0(r2)
81143008:	1000091e 	bne	r2,zero,81143030 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8114300c:	e0bffc17 	ldw	r2,-16(fp)
81143010:	e0fffe17 	ldw	r3,-8(fp)
81143014:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81143018:	e0bffe17 	ldw	r2,-8(fp)
8114301c:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81143020:	e0bffc17 	ldw	r2,-16(fp)
81143024:	00c00044 	movi	r3,1
81143028:	10c0010d 	sth	r3,4(r2)
8114302c:	00001206 	br	81143078 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81143030:	e0bffc17 	ldw	r2,-16(fp)
81143034:	10800017 	ldw	r2,0(r2)
81143038:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8114303c:	e0bffc17 	ldw	r2,-16(fp)
81143040:	e0fffe17 	ldw	r3,-8(fp)
81143044:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81143048:	e0bffe17 	ldw	r2,-8(fp)
8114304c:	e0fffd17 	ldw	r3,-12(fp)
81143050:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81143054:	e0bffd17 	ldw	r2,-12(fp)
81143058:	e0fffe17 	ldw	r3,-8(fp)
8114305c:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81143060:	e0bffc17 	ldw	r2,-16(fp)
81143064:	1080010b 	ldhu	r2,4(r2)
81143068:	10800044 	addi	r2,r2,1
8114306c:	1007883a 	mov	r3,r2
81143070:	e0bffc17 	ldw	r2,-16(fp)
81143074:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81143078:	e0bffe17 	ldw	r2,-8(fp)
8114307c:	10000415 	stw	zero,16(r2)
}
81143080:	0001883a 	nop
81143084:	e037883a 	mov	sp,fp
81143088:	df000017 	ldw	fp,0(sp)
8114308c:	dec00104 	addi	sp,sp,4
81143090:	f800283a 	ret

81143094 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81143094:	defffa04 	addi	sp,sp,-24
81143098:	de00012e 	bgeu	sp,et,811430a0 <OSTmr_Unlink+0xc>
8114309c:	003b68fa 	trap	3
811430a0:	df000515 	stw	fp,20(sp)
811430a4:	df000504 	addi	fp,sp,20
811430a8:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
811430ac:	e0bfff17 	ldw	r2,-4(fp)
811430b0:	10800517 	ldw	r2,20(r2)
811430b4:	1080004c 	andi	r2,r2,1
811430b8:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
811430bc:	e0bffb0b 	ldhu	r2,-20(fp)
811430c0:	100690fa 	slli	r3,r2,3
811430c4:	00a045f4 	movhi	r2,33047
811430c8:	10a02604 	addi	r2,r2,-32616
811430cc:	1885883a 	add	r2,r3,r2
811430d0:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
811430d4:	e0bffc17 	ldw	r2,-16(fp)
811430d8:	10c00017 	ldw	r3,0(r2)
811430dc:	e0bfff17 	ldw	r2,-4(fp)
811430e0:	18800b1e 	bne	r3,r2,81143110 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
811430e4:	e0bfff17 	ldw	r2,-4(fp)
811430e8:	10800317 	ldw	r2,12(r2)
811430ec:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
811430f0:	e0bffc17 	ldw	r2,-16(fp)
811430f4:	e0fffd17 	ldw	r3,-12(fp)
811430f8:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
811430fc:	e0bffd17 	ldw	r2,-12(fp)
81143100:	10001126 	beq	r2,zero,81143148 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81143104:	e0bffd17 	ldw	r2,-12(fp)
81143108:	10000415 	stw	zero,16(r2)
8114310c:	00000e06 	br	81143148 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81143110:	e0bfff17 	ldw	r2,-4(fp)
81143114:	10800417 	ldw	r2,16(r2)
81143118:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8114311c:	e0bfff17 	ldw	r2,-4(fp)
81143120:	10800317 	ldw	r2,12(r2)
81143124:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81143128:	e0bffd17 	ldw	r2,-12(fp)
8114312c:	e0fffe17 	ldw	r3,-8(fp)
81143130:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81143134:	e0bffe17 	ldw	r2,-8(fp)
81143138:	10000326 	beq	r2,zero,81143148 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8114313c:	e0bffe17 	ldw	r2,-8(fp)
81143140:	e0fffd17 	ldw	r3,-12(fp)
81143144:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81143148:	e0bfff17 	ldw	r2,-4(fp)
8114314c:	00c00044 	movi	r3,1
81143150:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81143154:	e0bfff17 	ldw	r2,-4(fp)
81143158:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8114315c:	e0bfff17 	ldw	r2,-4(fp)
81143160:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81143164:	e0bffc17 	ldw	r2,-16(fp)
81143168:	1080010b 	ldhu	r2,4(r2)
8114316c:	10bfffc4 	addi	r2,r2,-1
81143170:	1007883a 	mov	r3,r2
81143174:	e0bffc17 	ldw	r2,-16(fp)
81143178:	10c0010d 	sth	r3,4(r2)
}
8114317c:	0001883a 	nop
81143180:	e037883a 	mov	sp,fp
81143184:	df000017 	ldw	fp,0(sp)
81143188:	dec00104 	addi	sp,sp,4
8114318c:	f800283a 	ret

81143190 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81143190:	defffd04 	addi	sp,sp,-12
81143194:	de00012e 	bgeu	sp,et,8114319c <OSTmr_Lock+0xc>
81143198:	003b68fa 	trap	3
8114319c:	dfc00215 	stw	ra,8(sp)
811431a0:	df000115 	stw	fp,4(sp)
811431a4:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
811431a8:	d0a0a517 	ldw	r2,-32108(gp)
811431ac:	e1bfff04 	addi	r6,fp,-4
811431b0:	000b883a 	mov	r5,zero
811431b4:	1009883a 	mov	r4,r2
811431b8:	113fe340 	call	8113fe34 <OSSemPend>
    (void)err;
}
811431bc:	0001883a 	nop
811431c0:	e037883a 	mov	sp,fp
811431c4:	dfc00117 	ldw	ra,4(sp)
811431c8:	df000017 	ldw	fp,0(sp)
811431cc:	dec00204 	addi	sp,sp,8
811431d0:	f800283a 	ret

811431d4 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
811431d4:	defffe04 	addi	sp,sp,-8
811431d8:	de00012e 	bgeu	sp,et,811431e0 <OSTmr_Unlock+0xc>
811431dc:	003b68fa 	trap	3
811431e0:	dfc00115 	stw	ra,4(sp)
811431e4:	df000015 	stw	fp,0(sp)
811431e8:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
811431ec:	d0a0a517 	ldw	r2,-32108(gp)
811431f0:	1009883a 	mov	r4,r2
811431f4:	11401bc0 	call	811401bc <OSSemPost>
}
811431f8:	0001883a 	nop
811431fc:	e037883a 	mov	sp,fp
81143200:	dfc00117 	ldw	ra,4(sp)
81143204:	df000017 	ldw	fp,0(sp)
81143208:	dec00204 	addi	sp,sp,8
8114320c:	f800283a 	ret

81143210 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81143210:	defff704 	addi	sp,sp,-36
81143214:	de00012e 	bgeu	sp,et,8114321c <OSTmr_Task+0xc>
81143218:	003b68fa 	trap	3
8114321c:	dfc00815 	stw	ra,32(sp)
81143220:	df000715 	stw	fp,28(sp)
81143224:	df000704 	addi	fp,sp,28
81143228:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8114322c:	d0a09017 	ldw	r2,-32192(gp)
81143230:	e0fffe04 	addi	r3,fp,-8
81143234:	180d883a 	mov	r6,r3
81143238:	000b883a 	mov	r5,zero
8114323c:	1009883a 	mov	r4,r2
81143240:	113fe340 	call	8113fe34 <OSSemPend>
        OSTmr_Lock();
81143244:	11431900 	call	81143190 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81143248:	d0a0a317 	ldw	r2,-32116(gp)
8114324c:	10800044 	addi	r2,r2,1
81143250:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81143254:	d0a0a317 	ldw	r2,-32116(gp)
81143258:	1080004c 	andi	r2,r2,1
8114325c:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81143260:	e0bffa0b 	ldhu	r2,-24(fp)
81143264:	100690fa 	slli	r3,r2,3
81143268:	00a045f4 	movhi	r2,33047
8114326c:	10a02604 	addi	r2,r2,-32616
81143270:	1885883a 	add	r2,r3,r2
81143274:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81143278:	e0bffb17 	ldw	r2,-20(fp)
8114327c:	10800017 	ldw	r2,0(r2)
81143280:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81143284:	00002206 	br	81143310 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81143288:	e0bff917 	ldw	r2,-28(fp)
8114328c:	10800317 	ldw	r2,12(r2)
81143290:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81143294:	e0bff917 	ldw	r2,-28(fp)
81143298:	10c00517 	ldw	r3,20(r2)
8114329c:	d0a0a317 	ldw	r2,-32116(gp)
811432a0:	1880191e 	bne	r3,r2,81143308 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
811432a4:	e0bff917 	ldw	r2,-28(fp)
811432a8:	10800117 	ldw	r2,4(r2)
811432ac:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
811432b0:	e0bffd17 	ldw	r2,-12(fp)
811432b4:	10000626 	beq	r2,zero,811432d0 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
811432b8:	e0bff917 	ldw	r2,-28(fp)
811432bc:	10c00217 	ldw	r3,8(r2)
811432c0:	e0bffd17 	ldw	r2,-12(fp)
811432c4:	180b883a 	mov	r5,r3
811432c8:	e13ff917 	ldw	r4,-28(fp)
811432cc:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
811432d0:	e13ff917 	ldw	r4,-28(fp)
811432d4:	11430940 	call	81143094 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
811432d8:	e0bff917 	ldw	r2,-28(fp)
811432dc:	10800c03 	ldbu	r2,48(r2)
811432e0:	10803fcc 	andi	r2,r2,255
811432e4:	10800098 	cmpnei	r2,r2,2
811432e8:	1000041e 	bne	r2,zero,811432fc <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
811432ec:	01400044 	movi	r5,1
811432f0:	e13ff917 	ldw	r4,-28(fp)
811432f4:	1142f440 	call	81142f44 <OSTmr_Link>
811432f8:	00000306 	br	81143308 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
811432fc:	e0bff917 	ldw	r2,-28(fp)
81143300:	00c00084 	movi	r3,2
81143304:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81143308:	e0bffc17 	ldw	r2,-16(fp)
8114330c:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81143310:	e0bff917 	ldw	r2,-28(fp)
81143314:	103fdc1e 	bne	r2,zero,81143288 <__reset+0xfb123288>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81143318:	11431d40 	call	811431d4 <OSTmr_Unlock>
    }
8114331c:	003fc306 	br	8114322c <__reset+0xfb12322c>

81143320 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81143320:	defffd04 	addi	sp,sp,-12
81143324:	de00012e 	bgeu	sp,et,8114332c <alt_dev_reg+0xc>
81143328:	003b68fa 	trap	3
8114332c:	dfc00215 	stw	ra,8(sp)
81143330:	df000115 	stw	fp,4(sp)
81143334:	df000104 	addi	fp,sp,4
81143338:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8114333c:	d1600d04 	addi	r5,gp,-32716
81143340:	e13fff17 	ldw	r4,-4(fp)
81143344:	114b5c00 	call	8114b5c0 <alt_dev_llist_insert>
}
81143348:	e037883a 	mov	sp,fp
8114334c:	dfc00117 	ldw	ra,4(sp)
81143350:	df000017 	ldw	fp,0(sp)
81143354:	dec00204 	addi	sp,sp,8
81143358:	f800283a 	ret

8114335c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8114335c:	defffd04 	addi	sp,sp,-12
81143360:	de00012e 	bgeu	sp,et,81143368 <alt_irq_init+0xc>
81143364:	003b68fa 	trap	3
81143368:	dfc00215 	stw	ra,8(sp)
8114336c:	df000115 	stw	fp,4(sp)
81143370:	df000104 	addi	fp,sp,4
81143374:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81143378:	114bf880 	call	8114bf88 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8114337c:	00800044 	movi	r2,1
81143380:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81143384:	0001883a 	nop
81143388:	e037883a 	mov	sp,fp
8114338c:	dfc00117 	ldw	ra,4(sp)
81143390:	df000017 	ldw	fp,0(sp)
81143394:	dec00204 	addi	sp,sp,8
81143398:	f800283a 	ret

8114339c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8114339c:	defffe04 	addi	sp,sp,-8
811433a0:	de00012e 	bgeu	sp,et,811433a8 <alt_sys_init+0xc>
811433a4:	003b68fa 	trap	3
811433a8:	dfc00115 	stw	ra,4(sp)
811433ac:	df000015 	stw	fp,0(sp)
811433b0:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
811433b4:	01c0fa04 	movi	r7,1000
811433b8:	01800304 	movi	r6,12
811433bc:	000b883a 	mov	r5,zero
811433c0:	01200034 	movhi	r4,32768
811433c4:	21022004 	addi	r4,r4,2176
811433c8:	11486f40 	call	811486f4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
811433cc:	018002c4 	movi	r6,11
811433d0:	000b883a 	mov	r5,zero
811433d4:	01204574 	movhi	r4,33045
811433d8:	210c8c04 	addi	r4,r4,12848
811433dc:	11479e00 	call	811479e0 <altera_avalon_jtag_uart_init>
811433e0:	01204574 	movhi	r4,33045
811433e4:	210c8204 	addi	r4,r4,12808
811433e8:	11433200 	call	81143320 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
811433ec:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
811433f0:	018003c4 	movi	r6,15
811433f4:	000b883a 	mov	r5,zero
811433f8:	01204574 	movhi	r4,33045
811433fc:	2110a704 	addi	r4,r4,17052
81143400:	11488a00 	call	811488a0 <altera_avalon_uart_init>
81143404:	01204574 	movhi	r4,33045
81143408:	21109d04 	addi	r4,r4,17012
8114340c:	11433200 	call	81143320 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81143410:	00a04574 	movhi	r2,33045
81143414:	1090d104 	addi	r2,r2,17220
81143418:	10c00717 	ldw	r3,28(r2)
8114341c:	00a04574 	movhi	r2,33045
81143420:	1090d104 	addi	r2,r2,17220
81143424:	10800817 	ldw	r2,32(r2)
81143428:	100d883a 	mov	r6,r2
8114342c:	180b883a 	mov	r5,r3
81143430:	01204574 	movhi	r4,33045
81143434:	2110d104 	addi	r4,r4,17220
81143438:	114b1280 	call	8114b128 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8114343c:	00a04574 	movhi	r2,33045
81143440:	1090ea04 	addi	r2,r2,17320
81143444:	10c00717 	ldw	r3,28(r2)
81143448:	00a04574 	movhi	r2,33045
8114344c:	1090ea04 	addi	r2,r2,17320
81143450:	10800817 	ldw	r2,32(r2)
81143454:	100d883a 	mov	r6,r2
81143458:	180b883a 	mov	r5,r3
8114345c:	01204574 	movhi	r4,33045
81143460:	2110ea04 	addi	r4,r4,17320
81143464:	114b1280 	call	8114b128 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81143468:	01204574 	movhi	r4,33045
8114346c:	21110304 	addi	r4,r4,17420
81143470:	11433200 	call	81143320 <alt_dev_reg>
}
81143474:	0001883a 	nop
81143478:	e037883a 	mov	sp,fp
8114347c:	dfc00117 	ldw	ra,4(sp)
81143480:	df000017 	ldw	fp,0(sp)
81143484:	dec00204 	addi	sp,sp,8
81143488:	f800283a 	ret

8114348c <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8114348c:	defffa04 	addi	sp,sp,-24
81143490:	de00012e 	bgeu	sp,et,81143498 <Write_Sector_Data+0xc>
81143494:	003b68fa 	trap	3
81143498:	dfc00515 	stw	ra,20(sp)
8114349c:	df000415 	stw	fp,16(sp)
811434a0:	df000404 	addi	fp,sp,16
811434a4:	e13ffe15 	stw	r4,-8(fp)
811434a8:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811434ac:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
811434b0:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
811434b4:	10001e26 	beq	r2,zero,81143530 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
811434b8:	00803fc4 	movi	r2,255
811434bc:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811434c0:	d0a0af17 	ldw	r2,-32068(gp)
811434c4:	e13ffe17 	ldw	r4,-8(fp)
811434c8:	e0ffff17 	ldw	r3,-4(fp)
811434cc:	20c7883a 	add	r3,r4,r3
811434d0:	1806927a 	slli	r3,r3,9
811434d4:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
811434d8:	d0a0ae17 	ldw	r2,-32072(gp)
811434dc:	00c00604 	movi	r3,24
811434e0:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811434e4:	d0a0ab17 	ldw	r2,-32084(gp)
811434e8:	1080002b 	ldhuio	r2,0(r2)
811434ec:	10bfffcc 	andi	r2,r2,65535
811434f0:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
811434f4:	e0bffd0b 	ldhu	r2,-12(fp)
811434f8:	10bfffcc 	andi	r2,r2,65535
811434fc:	1080010c 	andi	r2,r2,4
81143500:	103ff81e 	bne	r2,zero,811434e4 <__reset+0xfb1234e4>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81143504:	e0bffd0b 	ldhu	r2,-12(fp)
81143508:	10bfffcc 	andi	r2,r2,65535
8114350c:	1080040c 	andi	r2,r2,16
81143510:	1000071e 	bne	r2,zero,81143530 <Write_Sector_Data+0xa4>
        {
            result = true;
81143514:	00800044 	movi	r2,1
81143518:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8114351c:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81143520:	e0fffe17 	ldw	r3,-8(fp)
81143524:	e0bfff17 	ldw	r2,-4(fp)
81143528:	1885883a 	add	r2,r3,r2
8114352c:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
81143530:	e0bffc17 	ldw	r2,-16(fp)
}
81143534:	e037883a 	mov	sp,fp
81143538:	dfc00117 	ldw	ra,4(sp)
8114353c:	df000017 	ldw	fp,0(sp)
81143540:	dec00204 	addi	sp,sp,8
81143544:	f800283a 	ret

81143548 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81143548:	defffd04 	addi	sp,sp,-12
8114354c:	de00012e 	bgeu	sp,et,81143554 <Save_Modified_Sector+0xc>
81143550:	003b68fa 	trap	3
81143554:	dfc00215 	stw	ra,8(sp)
81143558:	df000115 	stw	fp,4(sp)
8114355c:	df000104 	addi	fp,sp,4
    bool result = true;
81143560:	00800044 	movi	r2,1
81143564:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81143568:	d0a0b417 	ldw	r2,-32048(gp)
8114356c:	10000526 	beq	r2,zero,81143584 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81143570:	d0a0b517 	ldw	r2,-32044(gp)
81143574:	000b883a 	mov	r5,zero
81143578:	1009883a 	mov	r4,r2
8114357c:	114348c0 	call	8114348c <Write_Sector_Data>
81143580:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81143584:	e0bfff17 	ldw	r2,-4(fp)
}
81143588:	e037883a 	mov	sp,fp
8114358c:	dfc00117 	ldw	ra,4(sp)
81143590:	df000017 	ldw	fp,0(sp)
81143594:	dec00204 	addi	sp,sp,8
81143598:	f800283a 	ret

8114359c <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8114359c:	defffa04 	addi	sp,sp,-24
811435a0:	de00012e 	bgeu	sp,et,811435a8 <Read_Sector_Data+0xc>
811435a4:	003b68fa 	trap	3
811435a8:	dfc00515 	stw	ra,20(sp)
811435ac:	df000415 	stw	fp,16(sp)
811435b0:	df000404 	addi	fp,sp,16
811435b4:	e13ffe15 	stw	r4,-8(fp)
811435b8:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
811435bc:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
811435c0:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
811435c4:	10002726 	beq	r2,zero,81143664 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
811435c8:	00803fc4 	movi	r2,255
811435cc:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
811435d0:	d0a0b417 	ldw	r2,-32048(gp)
811435d4:	10000726 	beq	r2,zero,811435f4 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
811435d8:	d0a0b517 	ldw	r2,-32044(gp)
811435dc:	000b883a 	mov	r5,zero
811435e0:	1009883a 	mov	r4,r2
811435e4:	114348c0 	call	8114348c <Write_Sector_Data>
811435e8:	1000021e 	bne	r2,zero,811435f4 <Read_Sector_Data+0x58>
            {
                return false;
811435ec:	0005883a 	mov	r2,zero
811435f0:	00001d06 	br	81143668 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811435f4:	d0a0af17 	ldw	r2,-32068(gp)
811435f8:	e13ffe17 	ldw	r4,-8(fp)
811435fc:	e0ffff17 	ldw	r3,-4(fp)
81143600:	20c7883a 	add	r3,r4,r3
81143604:	1806927a 	slli	r3,r3,9
81143608:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8114360c:	d0a0ae17 	ldw	r2,-32072(gp)
81143610:	00c00444 	movi	r3,17
81143614:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81143618:	d0a0ab17 	ldw	r2,-32084(gp)
8114361c:	1080002b 	ldhuio	r2,0(r2)
81143620:	10bfffcc 	andi	r2,r2,65535
81143624:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81143628:	e0bffd0b 	ldhu	r2,-12(fp)
8114362c:	10bfffcc 	andi	r2,r2,65535
81143630:	1080010c 	andi	r2,r2,4
81143634:	103ff81e 	bne	r2,zero,81143618 <__reset+0xfb123618>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81143638:	e0bffd0b 	ldhu	r2,-12(fp)
8114363c:	10bfffcc 	andi	r2,r2,65535
81143640:	1080040c 	andi	r2,r2,16
81143644:	1000071e 	bne	r2,zero,81143664 <Read_Sector_Data+0xc8>
		{
			result = true;
81143648:	00800044 	movi	r2,1
8114364c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81143650:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81143654:	e0fffe17 	ldw	r3,-8(fp)
81143658:	e0bfff17 	ldw	r2,-4(fp)
8114365c:	1885883a 	add	r2,r3,r2
81143660:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
81143664:	e0bffc17 	ldw	r2,-16(fp)
}
81143668:	e037883a 	mov	sp,fp
8114366c:	dfc00117 	ldw	ra,4(sp)
81143670:	df000017 	ldw	fp,0(sp)
81143674:	dec00204 	addi	sp,sp,8
81143678:	f800283a 	ret

8114367c <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8114367c:	defffb04 	addi	sp,sp,-20
81143680:	de00012e 	bgeu	sp,et,81143688 <get_cluster_flag+0xc>
81143684:	003b68fa 	trap	3
81143688:	dfc00415 	stw	ra,16(sp)
8114368c:	df000315 	stw	fp,12(sp)
81143690:	df000304 	addi	fp,sp,12
81143694:	e13ffe15 	stw	r4,-8(fp)
81143698:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8114369c:	e0bffe17 	ldw	r2,-8(fp)
811436a0:	1004d23a 	srli	r2,r2,8
811436a4:	d0e0b117 	ldw	r3,-32060(gp)
811436a8:	10c5883a 	add	r2,r2,r3
811436ac:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811436b0:	00a045f4 	movhi	r2,33047
811436b4:	10b84c04 	addi	r2,r2,-7888
811436b8:	10801117 	ldw	r2,68(r2)
811436bc:	e0fffd17 	ldw	r3,-12(fp)
811436c0:	1885883a 	add	r2,r3,r2
811436c4:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
811436c8:	d0a0b517 	ldw	r2,-32044(gp)
811436cc:	e0fffd17 	ldw	r3,-12(fp)
811436d0:	18800726 	beq	r3,r2,811436f0 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811436d4:	e0bffd17 	ldw	r2,-12(fp)
811436d8:	000b883a 	mov	r5,zero
811436dc:	1009883a 	mov	r4,r2
811436e0:	114359c0 	call	8114359c <Read_Sector_Data>
811436e4:	1000021e 	bne	r2,zero,811436f0 <get_cluster_flag+0x74>
        {
            return false;
811436e8:	0005883a 	mov	r2,zero
811436ec:	00000d06 	br	81143724 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
811436f0:	e0bffe17 	ldw	r2,-8(fp)
811436f4:	10803fcc 	andi	r2,r2,255
811436f8:	1085883a 	add	r2,r2,r2
811436fc:	1007883a 	mov	r3,r2
81143700:	d0a0b317 	ldw	r2,-32052(gp)
81143704:	10800a17 	ldw	r2,40(r2)
81143708:	1885883a 	add	r2,r3,r2
8114370c:	1080002b 	ldhuio	r2,0(r2)
81143710:	10bfffcc 	andi	r2,r2,65535
81143714:	1007883a 	mov	r3,r2
81143718:	e0bfff17 	ldw	r2,-4(fp)
8114371c:	10c0000d 	sth	r3,0(r2)
    return true;
81143720:	00800044 	movi	r2,1
}
81143724:	e037883a 	mov	sp,fp
81143728:	dfc00117 	ldw	ra,4(sp)
8114372c:	df000017 	ldw	fp,0(sp)
81143730:	dec00204 	addi	sp,sp,8
81143734:	f800283a 	ret

81143738 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81143738:	defffa04 	addi	sp,sp,-24
8114373c:	de00012e 	bgeu	sp,et,81143744 <mark_cluster+0xc>
81143740:	003b68fa 	trap	3
81143744:	dfc00515 	stw	ra,20(sp)
81143748:	df000415 	stw	fp,16(sp)
8114374c:	df000404 	addi	fp,sp,16
81143750:	e13ffd15 	stw	r4,-12(fp)
81143754:	2805883a 	mov	r2,r5
81143758:	e1bfff15 	stw	r6,-4(fp)
8114375c:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81143760:	e0bffd17 	ldw	r2,-12(fp)
81143764:	1004d23a 	srli	r2,r2,8
81143768:	d0e0b117 	ldw	r3,-32060(gp)
8114376c:	10c5883a 	add	r2,r2,r3
81143770:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81143774:	e0bfff17 	ldw	r2,-4(fp)
81143778:	10000726 	beq	r2,zero,81143798 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8114377c:	00a045f4 	movhi	r2,33047
81143780:	10b84c04 	addi	r2,r2,-7888
81143784:	10801117 	ldw	r2,68(r2)
81143788:	e0fffc17 	ldw	r3,-16(fp)
8114378c:	1885883a 	add	r2,r3,r2
81143790:	e0bffc15 	stw	r2,-16(fp)
81143794:	00000606 	br	811437b0 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
81143798:	00a045f4 	movhi	r2,33047
8114379c:	10b84c04 	addi	r2,r2,-7888
811437a0:	10801217 	ldw	r2,72(r2)
811437a4:	e0fffc17 	ldw	r3,-16(fp)
811437a8:	1885883a 	add	r2,r3,r2
811437ac:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
811437b0:	d0a0b517 	ldw	r2,-32044(gp)
811437b4:	e0fffc17 	ldw	r3,-16(fp)
811437b8:	18800726 	beq	r3,r2,811437d8 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811437bc:	e0bffc17 	ldw	r2,-16(fp)
811437c0:	000b883a 	mov	r5,zero
811437c4:	1009883a 	mov	r4,r2
811437c8:	114359c0 	call	8114359c <Read_Sector_Data>
811437cc:	1000021e 	bne	r2,zero,811437d8 <mark_cluster+0xa0>
        {
            return false;
811437d0:	0005883a 	mov	r2,zero
811437d4:	00000d06 	br	8114380c <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
811437d8:	e0bffd17 	ldw	r2,-12(fp)
811437dc:	10803fcc 	andi	r2,r2,255
811437e0:	1085883a 	add	r2,r2,r2
811437e4:	1007883a 	mov	r3,r2
811437e8:	d0a0b317 	ldw	r2,-32052(gp)
811437ec:	10800a17 	ldw	r2,40(r2)
811437f0:	1885883a 	add	r2,r3,r2
811437f4:	1007883a 	mov	r3,r2
811437f8:	e0bffe0f 	ldh	r2,-8(fp)
811437fc:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81143800:	00800044 	movi	r2,1
81143804:	d0a0b415 	stw	r2,-32048(gp)
    return true;
81143808:	00800044 	movi	r2,1
}
8114380c:	e037883a 	mov	sp,fp
81143810:	dfc00117 	ldw	ra,4(sp)
81143814:	df000017 	ldw	fp,0(sp)
81143818:	dec00204 	addi	sp,sp,8
8114381c:	f800283a 	ret

81143820 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81143820:	defff704 	addi	sp,sp,-36
81143824:	de00012e 	bgeu	sp,et,8114382c <Check_for_Master_Boot_Record+0xc>
81143828:	003b68fa 	trap	3
8114382c:	dfc00815 	stw	ra,32(sp)
81143830:	df000715 	stw	fp,28(sp)
81143834:	df000704 	addi	fp,sp,28
	bool result = false;
81143838:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8114383c:	000b883a 	mov	r5,zero
81143840:	0009883a 	mov	r4,zero
81143844:	114359c0 	call	8114359c <Read_Sector_Data>
81143848:	10005a26 	beq	r2,zero,811439b4 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8114384c:	d0a0b317 	ldw	r2,-32052(gp)
81143850:	10800a17 	ldw	r2,40(r2)
81143854:	10807f84 	addi	r2,r2,510
81143858:	1080002b 	ldhuio	r2,0(r2)
8114385c:	10bfffcc 	andi	r2,r2,65535
81143860:	10bfffcc 	andi	r2,r2,65535
81143864:	10a0001c 	xori	r2,r2,32768
81143868:	10a00004 	addi	r2,r2,-32768
8114386c:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81143870:	e0bffb17 	ldw	r2,-20(fp)
81143874:	10ffffcc 	andi	r3,r2,65535
81143878:	00aa9554 	movui	r2,43605
8114387c:	18804d1e 	bne	r3,r2,811439b4 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81143880:	e03ffa15 	stw	zero,-24(fp)
81143884:	00004806 	br	811439a8 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81143888:	e0bffa17 	ldw	r2,-24(fp)
8114388c:	1004913a 	slli	r2,r2,4
81143890:	10806f84 	addi	r2,r2,446
81143894:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
81143898:	d0a0b317 	ldw	r2,-32052(gp)
8114389c:	10c00a17 	ldw	r3,40(r2)
811438a0:	e0bffc17 	ldw	r2,-16(fp)
811438a4:	1885883a 	add	r2,r3,r2
811438a8:	10800104 	addi	r2,r2,4
811438ac:	10800023 	ldbuio	r2,0(r2)
811438b0:	10803fcc 	andi	r2,r2,255
811438b4:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
811438b8:	e0bffd07 	ldb	r2,-12(fp)
811438bc:	10800060 	cmpeqi	r2,r2,1
811438c0:	1000091e 	bne	r2,zero,811438e8 <Check_for_Master_Boot_Record+0xc8>
811438c4:	e0bffd07 	ldb	r2,-12(fp)
811438c8:	10800120 	cmpeqi	r2,r2,4
811438cc:	1000061e 	bne	r2,zero,811438e8 <Check_for_Master_Boot_Record+0xc8>
811438d0:	e0bffd07 	ldb	r2,-12(fp)
811438d4:	108001a0 	cmpeqi	r2,r2,6
811438d8:	1000031e 	bne	r2,zero,811438e8 <Check_for_Master_Boot_Record+0xc8>
811438dc:	e0bffd07 	ldb	r2,-12(fp)
811438e0:	10800398 	cmpnei	r2,r2,14
811438e4:	10002d1e 	bne	r2,zero,8114399c <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
811438e8:	d0a0b317 	ldw	r2,-32052(gp)
811438ec:	10c00a17 	ldw	r3,40(r2)
811438f0:	e0bffc17 	ldw	r2,-16(fp)
811438f4:	1885883a 	add	r2,r3,r2
811438f8:	10800284 	addi	r2,r2,10
811438fc:	1080002b 	ldhuio	r2,0(r2)
81143900:	10bfffcc 	andi	r2,r2,65535
81143904:	1006943a 	slli	r3,r2,16
81143908:	d0a0b317 	ldw	r2,-32052(gp)
8114390c:	11000a17 	ldw	r4,40(r2)
81143910:	e0bffc17 	ldw	r2,-16(fp)
81143914:	2085883a 	add	r2,r4,r2
81143918:	10800204 	addi	r2,r2,8
8114391c:	1080002b 	ldhuio	r2,0(r2)
81143920:	10bfffcc 	andi	r2,r2,65535
81143924:	10bfffcc 	andi	r2,r2,65535
81143928:	1884b03a 	or	r2,r3,r2
8114392c:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81143930:	d0a0b317 	ldw	r2,-32052(gp)
81143934:	10c00a17 	ldw	r3,40(r2)
81143938:	e0bffc17 	ldw	r2,-16(fp)
8114393c:	1885883a 	add	r2,r3,r2
81143940:	10800384 	addi	r2,r2,14
81143944:	1080002b 	ldhuio	r2,0(r2)
81143948:	10bfffcc 	andi	r2,r2,65535
8114394c:	1006943a 	slli	r3,r2,16
81143950:	d0a0b317 	ldw	r2,-32052(gp)
81143954:	11000a17 	ldw	r4,40(r2)
81143958:	e0bffc17 	ldw	r2,-16(fp)
8114395c:	2085883a 	add	r2,r4,r2
81143960:	10800304 	addi	r2,r2,12
81143964:	1080002b 	ldhuio	r2,0(r2)
81143968:	10bfffcc 	andi	r2,r2,65535
8114396c:	10bfffcc 	andi	r2,r2,65535
81143970:	1884b03a 	or	r2,r3,r2
81143974:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
81143978:	e0bfff17 	ldw	r2,-4(fp)
8114397c:	0080070e 	bge	zero,r2,8114399c <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81143980:	00800044 	movi	r2,1
81143984:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81143988:	e0bfff17 	ldw	r2,-4(fp)
8114398c:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81143990:	e0bffe17 	ldw	r2,-8(fp)
81143994:	d0a0b115 	stw	r2,-32060(gp)
						break;
81143998:	00000606 	br	811439b4 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8114399c:	e0bffa17 	ldw	r2,-24(fp)
811439a0:	10800044 	addi	r2,r2,1
811439a4:	e0bffa15 	stw	r2,-24(fp)
811439a8:	e0bffa17 	ldw	r2,-24(fp)
811439ac:	10800110 	cmplti	r2,r2,4
811439b0:	103fb51e 	bne	r2,zero,81143888 <__reset+0xfb123888>
				}
			}
		}
	}

	return result;
811439b4:	e0bff917 	ldw	r2,-28(fp)
}
811439b8:	e037883a 	mov	sp,fp
811439bc:	dfc00117 	ldw	ra,4(sp)
811439c0:	df000017 	ldw	fp,0(sp)
811439c4:	dec00204 	addi	sp,sp,8
811439c8:	f800283a 	ret

811439cc <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
811439cc:	defff804 	addi	sp,sp,-32
811439d0:	de00012e 	bgeu	sp,et,811439d8 <Read_File_Record_At_Offset+0xc>
811439d4:	003b68fa 	trap	3
811439d8:	dfc00715 	stw	ra,28(sp)
811439dc:	df000615 	stw	fp,24(sp)
811439e0:	df000604 	addi	fp,sp,24
811439e4:	e13ffc15 	stw	r4,-16(fp)
811439e8:	e17ffd15 	stw	r5,-12(fp)
811439ec:	e1bffe15 	stw	r6,-8(fp)
811439f0:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
811439f4:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811439f8:	e0bffc17 	ldw	r2,-16(fp)
811439fc:	108007cc 	andi	r2,r2,31
81143a00:	10008d1e 	bne	r2,zero,81143c38 <Read_File_Record_At_Offset+0x26c>
81143a04:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
81143a08:	10008b26 	beq	r2,zero,81143c38 <Read_File_Record_At_Offset+0x26c>
81143a0c:	d0a0aa17 	ldw	r2,-32088(gp)
81143a10:	10008926 	beq	r2,zero,81143c38 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81143a14:	e03ffb15 	stw	zero,-20(fp)
81143a18:	00001106 	br	81143a60 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81143a1c:	e0fffc17 	ldw	r3,-16(fp)
81143a20:	e0bffb17 	ldw	r2,-20(fp)
81143a24:	1885883a 	add	r2,r3,r2
81143a28:	1007883a 	mov	r3,r2
81143a2c:	d0a0b317 	ldw	r2,-32052(gp)
81143a30:	10800a17 	ldw	r2,40(r2)
81143a34:	1885883a 	add	r2,r3,r2
81143a38:	10800023 	ldbuio	r2,0(r2)
81143a3c:	10803fcc 	andi	r2,r2,255
81143a40:	1009883a 	mov	r4,r2
81143a44:	e0fffd17 	ldw	r3,-12(fp)
81143a48:	e0bffb17 	ldw	r2,-20(fp)
81143a4c:	1885883a 	add	r2,r3,r2
81143a50:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81143a54:	e0bffb17 	ldw	r2,-20(fp)
81143a58:	10800044 	addi	r2,r2,1
81143a5c:	e0bffb15 	stw	r2,-20(fp)
81143a60:	e0bffb17 	ldw	r2,-20(fp)
81143a64:	10800210 	cmplti	r2,r2,8
81143a68:	103fec1e 	bne	r2,zero,81143a1c <__reset+0xfb123a1c>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81143a6c:	e03ffb15 	stw	zero,-20(fp)
81143a70:	00001306 	br	81143ac0 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81143a74:	e0fffc17 	ldw	r3,-16(fp)
81143a78:	e0bffb17 	ldw	r2,-20(fp)
81143a7c:	1885883a 	add	r2,r3,r2
81143a80:	1007883a 	mov	r3,r2
81143a84:	d0a0b317 	ldw	r2,-32052(gp)
81143a88:	10800a17 	ldw	r2,40(r2)
81143a8c:	1885883a 	add	r2,r3,r2
81143a90:	10800204 	addi	r2,r2,8
81143a94:	10800023 	ldbuio	r2,0(r2)
81143a98:	10803fcc 	andi	r2,r2,255
81143a9c:	1009883a 	mov	r4,r2
81143aa0:	e0fffd17 	ldw	r3,-12(fp)
81143aa4:	e0bffb17 	ldw	r2,-20(fp)
81143aa8:	1885883a 	add	r2,r3,r2
81143aac:	10800204 	addi	r2,r2,8
81143ab0:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81143ab4:	e0bffb17 	ldw	r2,-20(fp)
81143ab8:	10800044 	addi	r2,r2,1
81143abc:	e0bffb15 	stw	r2,-20(fp)
81143ac0:	e0bffb17 	ldw	r2,-20(fp)
81143ac4:	108000d0 	cmplti	r2,r2,3
81143ac8:	103fea1e 	bne	r2,zero,81143a74 <__reset+0xfb123a74>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
81143acc:	d0a0b317 	ldw	r2,-32052(gp)
81143ad0:	10c00a17 	ldw	r3,40(r2)
81143ad4:	e0bffc17 	ldw	r2,-16(fp)
81143ad8:	1885883a 	add	r2,r3,r2
81143adc:	108002c4 	addi	r2,r2,11
81143ae0:	10800023 	ldbuio	r2,0(r2)
81143ae4:	10803fcc 	andi	r2,r2,255
81143ae8:	1007883a 	mov	r3,r2
81143aec:	e0bffd17 	ldw	r2,-12(fp)
81143af0:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
81143af4:	d0a0b317 	ldw	r2,-32052(gp)
81143af8:	10c00a17 	ldw	r3,40(r2)
81143afc:	e0bffc17 	ldw	r2,-16(fp)
81143b00:	1885883a 	add	r2,r3,r2
81143b04:	10800384 	addi	r2,r2,14
81143b08:	1080002b 	ldhuio	r2,0(r2)
81143b0c:	10bfffcc 	andi	r2,r2,65535
81143b10:	1007883a 	mov	r3,r2
81143b14:	e0bffd17 	ldw	r2,-12(fp)
81143b18:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81143b1c:	d0a0b317 	ldw	r2,-32052(gp)
81143b20:	10c00a17 	ldw	r3,40(r2)
81143b24:	e0bffc17 	ldw	r2,-16(fp)
81143b28:	1885883a 	add	r2,r3,r2
81143b2c:	10800404 	addi	r2,r2,16
81143b30:	1080002b 	ldhuio	r2,0(r2)
81143b34:	10bfffcc 	andi	r2,r2,65535
81143b38:	1007883a 	mov	r3,r2
81143b3c:	e0bffd17 	ldw	r2,-12(fp)
81143b40:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
81143b44:	d0a0b317 	ldw	r2,-32052(gp)
81143b48:	10c00a17 	ldw	r3,40(r2)
81143b4c:	e0bffc17 	ldw	r2,-16(fp)
81143b50:	1885883a 	add	r2,r3,r2
81143b54:	10800484 	addi	r2,r2,18
81143b58:	1080002b 	ldhuio	r2,0(r2)
81143b5c:	10bfffcc 	andi	r2,r2,65535
81143b60:	1007883a 	mov	r3,r2
81143b64:	e0bffd17 	ldw	r2,-12(fp)
81143b68:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81143b6c:	d0a0b317 	ldw	r2,-32052(gp)
81143b70:	10c00a17 	ldw	r3,40(r2)
81143b74:	e0bffc17 	ldw	r2,-16(fp)
81143b78:	1885883a 	add	r2,r3,r2
81143b7c:	10800584 	addi	r2,r2,22
81143b80:	1080002b 	ldhuio	r2,0(r2)
81143b84:	10bfffcc 	andi	r2,r2,65535
81143b88:	1007883a 	mov	r3,r2
81143b8c:	e0bffd17 	ldw	r2,-12(fp)
81143b90:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
81143b94:	d0a0b317 	ldw	r2,-32052(gp)
81143b98:	10c00a17 	ldw	r3,40(r2)
81143b9c:	e0bffc17 	ldw	r2,-16(fp)
81143ba0:	1885883a 	add	r2,r3,r2
81143ba4:	10800604 	addi	r2,r2,24
81143ba8:	1080002b 	ldhuio	r2,0(r2)
81143bac:	10bfffcc 	andi	r2,r2,65535
81143bb0:	1007883a 	mov	r3,r2
81143bb4:	e0bffd17 	ldw	r2,-12(fp)
81143bb8:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81143bbc:	d0a0b317 	ldw	r2,-32052(gp)
81143bc0:	10c00a17 	ldw	r3,40(r2)
81143bc4:	e0bffc17 	ldw	r2,-16(fp)
81143bc8:	1885883a 	add	r2,r3,r2
81143bcc:	10800684 	addi	r2,r2,26
81143bd0:	1080002b 	ldhuio	r2,0(r2)
81143bd4:	10bfffcc 	andi	r2,r2,65535
81143bd8:	1007883a 	mov	r3,r2
81143bdc:	e0bffd17 	ldw	r2,-12(fp)
81143be0:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
81143be4:	d0a0b317 	ldw	r2,-32052(gp)
81143be8:	10c00a17 	ldw	r3,40(r2)
81143bec:	e0bffc17 	ldw	r2,-16(fp)
81143bf0:	1885883a 	add	r2,r3,r2
81143bf4:	10800704 	addi	r2,r2,28
81143bf8:	10800037 	ldwio	r2,0(r2)
81143bfc:	1007883a 	mov	r3,r2
81143c00:	e0bffd17 	ldw	r2,-12(fp)
81143c04:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81143c08:	e0bffd17 	ldw	r2,-12(fp)
81143c0c:	e0fffe17 	ldw	r3,-8(fp)
81143c10:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
81143c14:	e0bffd17 	ldw	r2,-12(fp)
81143c18:	e0ffff17 	ldw	r3,-4(fp)
81143c1c:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81143c20:	e0bffc17 	ldw	r2,-16(fp)
81143c24:	1007883a 	mov	r3,r2
81143c28:	e0bffd17 	ldw	r2,-12(fp)
81143c2c:	10c00c0d 	sth	r3,48(r2)
		result = true;
81143c30:	00800044 	movi	r2,1
81143c34:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81143c38:	e0bffa17 	ldw	r2,-24(fp)
}
81143c3c:	e037883a 	mov	sp,fp
81143c40:	dfc00117 	ldw	ra,4(sp)
81143c44:	df000017 	ldw	fp,0(sp)
81143c48:	dec00204 	addi	sp,sp,8
81143c4c:	f800283a 	ret

81143c50 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81143c50:	defff904 	addi	sp,sp,-28
81143c54:	de00012e 	bgeu	sp,et,81143c5c <Write_File_Record_At_Offset+0xc>
81143c58:	003b68fa 	trap	3
81143c5c:	dfc00615 	stw	ra,24(sp)
81143c60:	df000515 	stw	fp,20(sp)
81143c64:	df000504 	addi	fp,sp,20
81143c68:	e13ffe15 	stw	r4,-8(fp)
81143c6c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81143c70:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81143c74:	e0bffe17 	ldw	r2,-8(fp)
81143c78:	108007cc 	andi	r2,r2,31
81143c7c:	1000931e 	bne	r2,zero,81143ecc <Write_File_Record_At_Offset+0x27c>
81143c80:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
81143c84:	10009126 	beq	r2,zero,81143ecc <Write_File_Record_At_Offset+0x27c>
81143c88:	d0a0aa17 	ldw	r2,-32088(gp)
81143c8c:	10008f26 	beq	r2,zero,81143ecc <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81143c90:	e03ffc15 	stw	zero,-16(fp)
81143c94:	00001f06 	br	81143d14 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
81143c98:	e0bffc17 	ldw	r2,-16(fp)
81143c9c:	10800044 	addi	r2,r2,1
81143ca0:	e0ffff17 	ldw	r3,-4(fp)
81143ca4:	1885883a 	add	r2,r3,r2
81143ca8:	10800003 	ldbu	r2,0(r2)
81143cac:	10803fcc 	andi	r2,r2,255
81143cb0:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
81143cb4:	e0bffd0f 	ldh	r2,-12(fp)
81143cb8:	1004923a 	slli	r2,r2,8
81143cbc:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
81143cc0:	e0ffff17 	ldw	r3,-4(fp)
81143cc4:	e0bffc17 	ldw	r2,-16(fp)
81143cc8:	1885883a 	add	r2,r3,r2
81143ccc:	10800003 	ldbu	r2,0(r2)
81143cd0:	10c03fcc 	andi	r3,r2,255
81143cd4:	e0bffd0b 	ldhu	r2,-12(fp)
81143cd8:	1884b03a 	or	r2,r3,r2
81143cdc:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81143ce0:	e0fffe17 	ldw	r3,-8(fp)
81143ce4:	e0bffc17 	ldw	r2,-16(fp)
81143ce8:	1885883a 	add	r2,r3,r2
81143cec:	1007883a 	mov	r3,r2
81143cf0:	d0a0b317 	ldw	r2,-32052(gp)
81143cf4:	10800a17 	ldw	r2,40(r2)
81143cf8:	1885883a 	add	r2,r3,r2
81143cfc:	1007883a 	mov	r3,r2
81143d00:	e0bffd0f 	ldh	r2,-12(fp)
81143d04:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81143d08:	e0bffc17 	ldw	r2,-16(fp)
81143d0c:	10800084 	addi	r2,r2,2
81143d10:	e0bffc15 	stw	r2,-16(fp)
81143d14:	e0bffc17 	ldw	r2,-16(fp)
81143d18:	10800210 	cmplti	r2,r2,8
81143d1c:	103fde1e 	bne	r2,zero,81143c98 <__reset+0xfb123c98>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81143d20:	e03ffc15 	stw	zero,-16(fp)
81143d24:	00001306 	br	81143d74 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81143d28:	e0fffe17 	ldw	r3,-8(fp)
81143d2c:	e0bffc17 	ldw	r2,-16(fp)
81143d30:	1885883a 	add	r2,r3,r2
81143d34:	1007883a 	mov	r3,r2
81143d38:	d0a0b317 	ldw	r2,-32052(gp)
81143d3c:	10800a17 	ldw	r2,40(r2)
81143d40:	1885883a 	add	r2,r3,r2
81143d44:	10800204 	addi	r2,r2,8
81143d48:	1009883a 	mov	r4,r2
81143d4c:	e0ffff17 	ldw	r3,-4(fp)
81143d50:	e0bffc17 	ldw	r2,-16(fp)
81143d54:	1885883a 	add	r2,r3,r2
81143d58:	10800204 	addi	r2,r2,8
81143d5c:	10800003 	ldbu	r2,0(r2)
81143d60:	10803fcc 	andi	r2,r2,255
81143d64:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81143d68:	e0bffc17 	ldw	r2,-16(fp)
81143d6c:	10800044 	addi	r2,r2,1
81143d70:	e0bffc15 	stw	r2,-16(fp)
81143d74:	e0bffc17 	ldw	r2,-16(fp)
81143d78:	108000d0 	cmplti	r2,r2,3
81143d7c:	103fea1e 	bne	r2,zero,81143d28 <__reset+0xfb123d28>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81143d80:	d0a0b317 	ldw	r2,-32052(gp)
81143d84:	10c00a17 	ldw	r3,40(r2)
81143d88:	e0bffe17 	ldw	r2,-8(fp)
81143d8c:	1885883a 	add	r2,r3,r2
81143d90:	108002c4 	addi	r2,r2,11
81143d94:	1007883a 	mov	r3,r2
81143d98:	e0bfff17 	ldw	r2,-4(fp)
81143d9c:	108002c3 	ldbu	r2,11(r2)
81143da0:	10803fcc 	andi	r2,r2,255
81143da4:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81143da8:	d0a0b317 	ldw	r2,-32052(gp)
81143dac:	10c00a17 	ldw	r3,40(r2)
81143db0:	e0bffe17 	ldw	r2,-8(fp)
81143db4:	1885883a 	add	r2,r3,r2
81143db8:	10800384 	addi	r2,r2,14
81143dbc:	1007883a 	mov	r3,r2
81143dc0:	e0bfff17 	ldw	r2,-4(fp)
81143dc4:	1080030b 	ldhu	r2,12(r2)
81143dc8:	10bfffcc 	andi	r2,r2,65535
81143dcc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81143dd0:	d0a0b317 	ldw	r2,-32052(gp)
81143dd4:	10c00a17 	ldw	r3,40(r2)
81143dd8:	e0bffe17 	ldw	r2,-8(fp)
81143ddc:	1885883a 	add	r2,r3,r2
81143de0:	10800404 	addi	r2,r2,16
81143de4:	1007883a 	mov	r3,r2
81143de8:	e0bfff17 	ldw	r2,-4(fp)
81143dec:	1080038b 	ldhu	r2,14(r2)
81143df0:	10bfffcc 	andi	r2,r2,65535
81143df4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81143df8:	d0a0b317 	ldw	r2,-32052(gp)
81143dfc:	10c00a17 	ldw	r3,40(r2)
81143e00:	e0bffe17 	ldw	r2,-8(fp)
81143e04:	1885883a 	add	r2,r3,r2
81143e08:	10800484 	addi	r2,r2,18
81143e0c:	1007883a 	mov	r3,r2
81143e10:	e0bfff17 	ldw	r2,-4(fp)
81143e14:	1080040b 	ldhu	r2,16(r2)
81143e18:	10bfffcc 	andi	r2,r2,65535
81143e1c:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81143e20:	d0a0b317 	ldw	r2,-32052(gp)
81143e24:	10c00a17 	ldw	r3,40(r2)
81143e28:	e0bffe17 	ldw	r2,-8(fp)
81143e2c:	1885883a 	add	r2,r3,r2
81143e30:	10800584 	addi	r2,r2,22
81143e34:	1007883a 	mov	r3,r2
81143e38:	e0bfff17 	ldw	r2,-4(fp)
81143e3c:	1080048b 	ldhu	r2,18(r2)
81143e40:	10bfffcc 	andi	r2,r2,65535
81143e44:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81143e48:	d0a0b317 	ldw	r2,-32052(gp)
81143e4c:	10c00a17 	ldw	r3,40(r2)
81143e50:	e0bffe17 	ldw	r2,-8(fp)
81143e54:	1885883a 	add	r2,r3,r2
81143e58:	10800604 	addi	r2,r2,24
81143e5c:	1007883a 	mov	r3,r2
81143e60:	e0bfff17 	ldw	r2,-4(fp)
81143e64:	1080050b 	ldhu	r2,20(r2)
81143e68:	10bfffcc 	andi	r2,r2,65535
81143e6c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81143e70:	d0a0b317 	ldw	r2,-32052(gp)
81143e74:	10c00a17 	ldw	r3,40(r2)
81143e78:	e0bffe17 	ldw	r2,-8(fp)
81143e7c:	1885883a 	add	r2,r3,r2
81143e80:	10800684 	addi	r2,r2,26
81143e84:	1007883a 	mov	r3,r2
81143e88:	e0bfff17 	ldw	r2,-4(fp)
81143e8c:	1080058b 	ldhu	r2,22(r2)
81143e90:	10bfffcc 	andi	r2,r2,65535
81143e94:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81143e98:	d0a0b317 	ldw	r2,-32052(gp)
81143e9c:	10c00a17 	ldw	r3,40(r2)
81143ea0:	e0bffe17 	ldw	r2,-8(fp)
81143ea4:	1885883a 	add	r2,r3,r2
81143ea8:	10800704 	addi	r2,r2,28
81143eac:	1007883a 	mov	r3,r2
81143eb0:	e0bfff17 	ldw	r2,-4(fp)
81143eb4:	10800617 	ldw	r2,24(r2)
81143eb8:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81143ebc:	00800044 	movi	r2,1
81143ec0:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
81143ec4:	00800044 	movi	r2,1
81143ec8:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81143ecc:	e0bffb17 	ldw	r2,-20(fp)
}
81143ed0:	e037883a 	mov	sp,fp
81143ed4:	dfc00117 	ldw	ra,4(sp)
81143ed8:	df000017 	ldw	fp,0(sp)
81143edc:	dec00204 	addi	sp,sp,8
81143ee0:	f800283a 	ret

81143ee4 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81143ee4:	defff904 	addi	sp,sp,-28
81143ee8:	de00012e 	bgeu	sp,et,81143ef0 <Check_for_DOS_FAT+0xc>
81143eec:	003b68fa 	trap	3
81143ef0:	dfc00615 	stw	ra,24(sp)
81143ef4:	df000515 	stw	fp,20(sp)
81143ef8:	df000504 	addi	fp,sp,20
81143efc:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81143f00:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81143f04:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81143f08:	e17fff17 	ldw	r5,-4(fp)
81143f0c:	0009883a 	mov	r4,zero
81143f10:	114359c0 	call	8114359c <Read_Sector_Data>
81143f14:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81143f18:	d0a0b317 	ldw	r2,-32052(gp)
81143f1c:	10800a17 	ldw	r2,40(r2)
81143f20:	10807f84 	addi	r2,r2,510
81143f24:	1080002b 	ldhuio	r2,0(r2)
81143f28:	10bfffcc 	andi	r2,r2,65535
81143f2c:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81143f30:	e0bffe0f 	ldh	r2,-8(fp)
81143f34:	10ffffcc 	andi	r3,r2,65535
81143f38:	00aa9554 	movui	r2,43605
81143f3c:	1881841e 	bne	r3,r2,81144550 <Check_for_DOS_FAT+0x66c>
81143f40:	e0bffb17 	ldw	r2,-20(fp)
81143f44:	10018226 	beq	r2,zero,81144550 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81143f48:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81143f4c:	d0a0b317 	ldw	r2,-32052(gp)
81143f50:	10800a17 	ldw	r2,40(r2)
81143f54:	10800023 	ldbuio	r2,0(r2)
81143f58:	10803fcc 	andi	r2,r2,255
81143f5c:	1007883a 	mov	r3,r2
81143f60:	00a045f4 	movhi	r2,33047
81143f64:	10b84c04 	addi	r2,r2,-7888
81143f68:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81143f6c:	d0a0b317 	ldw	r2,-32052(gp)
81143f70:	10800a17 	ldw	r2,40(r2)
81143f74:	10800044 	addi	r2,r2,1
81143f78:	10800023 	ldbuio	r2,0(r2)
81143f7c:	10803fcc 	andi	r2,r2,255
81143f80:	1007883a 	mov	r3,r2
81143f84:	00a045f4 	movhi	r2,33047
81143f88:	10b84c04 	addi	r2,r2,-7888
81143f8c:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81143f90:	d0a0b317 	ldw	r2,-32052(gp)
81143f94:	10800a17 	ldw	r2,40(r2)
81143f98:	10800084 	addi	r2,r2,2
81143f9c:	10800023 	ldbuio	r2,0(r2)
81143fa0:	10803fcc 	andi	r2,r2,255
81143fa4:	1007883a 	mov	r3,r2
81143fa8:	00a045f4 	movhi	r2,33047
81143fac:	10b84c04 	addi	r2,r2,-7888
81143fb0:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81143fb4:	e03ffc15 	stw	zero,-16(fp)
81143fb8:	00001106 	br	81144000 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81143fbc:	d0a0b317 	ldw	r2,-32052(gp)
81143fc0:	10c00a17 	ldw	r3,40(r2)
81143fc4:	e0bffc17 	ldw	r2,-16(fp)
81143fc8:	1885883a 	add	r2,r3,r2
81143fcc:	108000c4 	addi	r2,r2,3
81143fd0:	10800023 	ldbuio	r2,0(r2)
81143fd4:	10803fcc 	andi	r2,r2,255
81143fd8:	1009883a 	mov	r4,r2
81143fdc:	00a045f4 	movhi	r2,33047
81143fe0:	10b84c04 	addi	r2,r2,-7888
81143fe4:	e0fffc17 	ldw	r3,-16(fp)
81143fe8:	10c5883a 	add	r2,r2,r3
81143fec:	108000c4 	addi	r2,r2,3
81143ff0:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81143ff4:	e0bffc17 	ldw	r2,-16(fp)
81143ff8:	10800044 	addi	r2,r2,1
81143ffc:	e0bffc15 	stw	r2,-16(fp)
81144000:	e0bffc17 	ldw	r2,-16(fp)
81144004:	10800210 	cmplti	r2,r2,8
81144008:	103fec1e 	bne	r2,zero,81143fbc <__reset+0xfb123fbc>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8114400c:	d0a0b317 	ldw	r2,-32052(gp)
81144010:	10800a17 	ldw	r2,40(r2)
81144014:	10800304 	addi	r2,r2,12
81144018:	10800023 	ldbuio	r2,0(r2)
8114401c:	10803fcc 	andi	r2,r2,255
81144020:	1004923a 	slli	r2,r2,8
81144024:	1007883a 	mov	r3,r2
81144028:	d0a0b317 	ldw	r2,-32052(gp)
8114402c:	10800a17 	ldw	r2,40(r2)
81144030:	108002c4 	addi	r2,r2,11
81144034:	10800023 	ldbuio	r2,0(r2)
81144038:	10803fcc 	andi	r2,r2,255
8114403c:	10803fcc 	andi	r2,r2,255
81144040:	1080201c 	xori	r2,r2,128
81144044:	10bfe004 	addi	r2,r2,-128
81144048:	1884b03a 	or	r2,r3,r2
8114404c:	1007883a 	mov	r3,r2
81144050:	00a045f4 	movhi	r2,33047
81144054:	10b84c04 	addi	r2,r2,-7888
81144058:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8114405c:	d0a0b317 	ldw	r2,-32052(gp)
81144060:	10800a17 	ldw	r2,40(r2)
81144064:	10800344 	addi	r2,r2,13
81144068:	10800023 	ldbuio	r2,0(r2)
8114406c:	10803fcc 	andi	r2,r2,255
81144070:	1007883a 	mov	r3,r2
81144074:	00a045f4 	movhi	r2,33047
81144078:	10b84c04 	addi	r2,r2,-7888
8114407c:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81144080:	d0a0b317 	ldw	r2,-32052(gp)
81144084:	10800a17 	ldw	r2,40(r2)
81144088:	10800384 	addi	r2,r2,14
8114408c:	1080002b 	ldhuio	r2,0(r2)
81144090:	10bfffcc 	andi	r2,r2,65535
81144094:	1007883a 	mov	r3,r2
81144098:	00a045f4 	movhi	r2,33047
8114409c:	10b84c04 	addi	r2,r2,-7888
811440a0:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
811440a4:	d0a0b317 	ldw	r2,-32052(gp)
811440a8:	10800a17 	ldw	r2,40(r2)
811440ac:	10800404 	addi	r2,r2,16
811440b0:	10800023 	ldbuio	r2,0(r2)
811440b4:	10803fcc 	andi	r2,r2,255
811440b8:	1007883a 	mov	r3,r2
811440bc:	00a045f4 	movhi	r2,33047
811440c0:	10b84c04 	addi	r2,r2,-7888
811440c4:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
811440c8:	d0a0b317 	ldw	r2,-32052(gp)
811440cc:	10800a17 	ldw	r2,40(r2)
811440d0:	10800484 	addi	r2,r2,18
811440d4:	10800023 	ldbuio	r2,0(r2)
811440d8:	10803fcc 	andi	r2,r2,255
811440dc:	1004923a 	slli	r2,r2,8
811440e0:	1007883a 	mov	r3,r2
811440e4:	d0a0b317 	ldw	r2,-32052(gp)
811440e8:	10800a17 	ldw	r2,40(r2)
811440ec:	10800444 	addi	r2,r2,17
811440f0:	10800023 	ldbuio	r2,0(r2)
811440f4:	10803fcc 	andi	r2,r2,255
811440f8:	10803fcc 	andi	r2,r2,255
811440fc:	1884b03a 	or	r2,r3,r2
81144100:	1007883a 	mov	r3,r2
81144104:	00a045f4 	movhi	r2,33047
81144108:	10b84c04 	addi	r2,r2,-7888
8114410c:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81144110:	d0a0b317 	ldw	r2,-32052(gp)
81144114:	10800a17 	ldw	r2,40(r2)
81144118:	10800504 	addi	r2,r2,20
8114411c:	10800023 	ldbuio	r2,0(r2)
81144120:	10803fcc 	andi	r2,r2,255
81144124:	1004923a 	slli	r2,r2,8
81144128:	1007883a 	mov	r3,r2
8114412c:	d0a0b317 	ldw	r2,-32052(gp)
81144130:	10800a17 	ldw	r2,40(r2)
81144134:	108004c4 	addi	r2,r2,19
81144138:	10800023 	ldbuio	r2,0(r2)
8114413c:	10803fcc 	andi	r2,r2,255
81144140:	10803fcc 	andi	r2,r2,255
81144144:	1884b03a 	or	r2,r3,r2
81144148:	1007883a 	mov	r3,r2
8114414c:	00a045f4 	movhi	r2,33047
81144150:	10b84c04 	addi	r2,r2,-7888
81144154:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81144158:	d0a0b317 	ldw	r2,-32052(gp)
8114415c:	10800a17 	ldw	r2,40(r2)
81144160:	10800544 	addi	r2,r2,21
81144164:	10800023 	ldbuio	r2,0(r2)
81144168:	10803fcc 	andi	r2,r2,255
8114416c:	1007883a 	mov	r3,r2
81144170:	00a045f4 	movhi	r2,33047
81144174:	10b84c04 	addi	r2,r2,-7888
81144178:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8114417c:	d0a0b317 	ldw	r2,-32052(gp)
81144180:	10800a17 	ldw	r2,40(r2)
81144184:	10800584 	addi	r2,r2,22
81144188:	1080002b 	ldhuio	r2,0(r2)
8114418c:	10bfffcc 	andi	r2,r2,65535
81144190:	1007883a 	mov	r3,r2
81144194:	00a045f4 	movhi	r2,33047
81144198:	10b84c04 	addi	r2,r2,-7888
8114419c:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
811441a0:	d0a0b317 	ldw	r2,-32052(gp)
811441a4:	10800a17 	ldw	r2,40(r2)
811441a8:	10800604 	addi	r2,r2,24
811441ac:	1080002b 	ldhuio	r2,0(r2)
811441b0:	10bfffcc 	andi	r2,r2,65535
811441b4:	1007883a 	mov	r3,r2
811441b8:	00a045f4 	movhi	r2,33047
811441bc:	10b84c04 	addi	r2,r2,-7888
811441c0:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
811441c4:	d0a0b317 	ldw	r2,-32052(gp)
811441c8:	10800a17 	ldw	r2,40(r2)
811441cc:	10800684 	addi	r2,r2,26
811441d0:	1080002b 	ldhuio	r2,0(r2)
811441d4:	10bfffcc 	andi	r2,r2,65535
811441d8:	1007883a 	mov	r3,r2
811441dc:	00a045f4 	movhi	r2,33047
811441e0:	10b84c04 	addi	r2,r2,-7888
811441e4:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
811441e8:	d0a0b317 	ldw	r2,-32052(gp)
811441ec:	10800a17 	ldw	r2,40(r2)
811441f0:	10800704 	addi	r2,r2,28
811441f4:	10800037 	ldwio	r2,0(r2)
811441f8:	1007883a 	mov	r3,r2
811441fc:	00a045f4 	movhi	r2,33047
81144200:	10b84c04 	addi	r2,r2,-7888
81144204:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81144208:	d0a0b317 	ldw	r2,-32052(gp)
8114420c:	10800a17 	ldw	r2,40(r2)
81144210:	10800804 	addi	r2,r2,32
81144214:	10800037 	ldwio	r2,0(r2)
81144218:	1007883a 	mov	r3,r2
8114421c:	00a045f4 	movhi	r2,33047
81144220:	10b84c04 	addi	r2,r2,-7888
81144224:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81144228:	d0a0b317 	ldw	r2,-32052(gp)
8114422c:	10800a17 	ldw	r2,40(r2)
81144230:	10800904 	addi	r2,r2,36
81144234:	10800023 	ldbuio	r2,0(r2)
81144238:	10803fcc 	andi	r2,r2,255
8114423c:	1007883a 	mov	r3,r2
81144240:	00a045f4 	movhi	r2,33047
81144244:	10b84c04 	addi	r2,r2,-7888
81144248:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8114424c:	d0a0b317 	ldw	r2,-32052(gp)
81144250:	10800a17 	ldw	r2,40(r2)
81144254:	10800944 	addi	r2,r2,37
81144258:	10800023 	ldbuio	r2,0(r2)
8114425c:	10803fcc 	andi	r2,r2,255
81144260:	1007883a 	mov	r3,r2
81144264:	00a045f4 	movhi	r2,33047
81144268:	10b84c04 	addi	r2,r2,-7888
8114426c:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81144270:	d0a0b317 	ldw	r2,-32052(gp)
81144274:	10800a17 	ldw	r2,40(r2)
81144278:	10800984 	addi	r2,r2,38
8114427c:	10800023 	ldbuio	r2,0(r2)
81144280:	10803fcc 	andi	r2,r2,255
81144284:	1007883a 	mov	r3,r2
81144288:	00a045f4 	movhi	r2,33047
8114428c:	10b84c04 	addi	r2,r2,-7888
81144290:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81144294:	00a045f4 	movhi	r2,33047
81144298:	10b84c04 	addi	r2,r2,-7888
8114429c:	1080040b 	ldhu	r2,16(r2)
811442a0:	10ffffcc 	andi	r3,r2,65535
811442a4:	00a045f4 	movhi	r2,33047
811442a8:	10b84c04 	addi	r2,r2,-7888
811442ac:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
811442b0:	00a045f4 	movhi	r2,33047
811442b4:	10b84c04 	addi	r2,r2,-7888
811442b8:	10c01117 	ldw	r3,68(r2)
811442bc:	00a045f4 	movhi	r2,33047
811442c0:	10b84c04 	addi	r2,r2,-7888
811442c4:	1080068b 	ldhu	r2,26(r2)
811442c8:	10bfffcc 	andi	r2,r2,65535
811442cc:	1887883a 	add	r3,r3,r2
811442d0:	00a045f4 	movhi	r2,33047
811442d4:	10b84c04 	addi	r2,r2,-7888
811442d8:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
811442dc:	00a045f4 	movhi	r2,33047
811442e0:	10b84c04 	addi	r2,r2,-7888
811442e4:	10c01217 	ldw	r3,72(r2)
811442e8:	00a045f4 	movhi	r2,33047
811442ec:	10b84c04 	addi	r2,r2,-7888
811442f0:	1080068b 	ldhu	r2,26(r2)
811442f4:	10bfffcc 	andi	r2,r2,65535
811442f8:	1887883a 	add	r3,r3,r2
811442fc:	00a045f4 	movhi	r2,33047
81144300:	10b84c04 	addi	r2,r2,-7888
81144304:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81144308:	00a045f4 	movhi	r2,33047
8114430c:	10b84c04 	addi	r2,r2,-7888
81144310:	10c01317 	ldw	r3,76(r2)
81144314:	00a045f4 	movhi	r2,33047
81144318:	10b84c04 	addi	r2,r2,-7888
8114431c:	1080050b 	ldhu	r2,20(r2)
81144320:	10bfffcc 	andi	r2,r2,65535
81144324:	1008917a 	slli	r4,r2,5
81144328:	00a045f4 	movhi	r2,33047
8114432c:	10b84c04 	addi	r2,r2,-7888
81144330:	1080030b 	ldhu	r2,12(r2)
81144334:	10bfffcc 	andi	r2,r2,65535
81144338:	2085283a 	div	r2,r4,r2
8114433c:	1887883a 	add	r3,r3,r2
81144340:	00a045f4 	movhi	r2,33047
81144344:	10b84c04 	addi	r2,r2,-7888
81144348:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8114434c:	00a045f4 	movhi	r2,33047
81144350:	10b84c04 	addi	r2,r2,-7888
81144354:	1080058b 	ldhu	r2,22(r2)
81144358:	10bfffcc 	andi	r2,r2,65535
8114435c:	10000b26 	beq	r2,zero,8114438c <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81144360:	00a045f4 	movhi	r2,33047
81144364:	10b84c04 	addi	r2,r2,-7888
81144368:	1080058b 	ldhu	r2,22(r2)
8114436c:	10ffffcc 	andi	r3,r2,65535
81144370:	00a045f4 	movhi	r2,33047
81144374:	10b84c04 	addi	r2,r2,-7888
81144378:	10800383 	ldbu	r2,14(r2)
8114437c:	10803fcc 	andi	r2,r2,255
81144380:	1885283a 	div	r2,r3,r2
81144384:	e0bffd15 	stw	r2,-12(fp)
81144388:	00000906 	br	811443b0 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8114438c:	00a045f4 	movhi	r2,33047
81144390:	10b84c04 	addi	r2,r2,-7888
81144394:	10c00917 	ldw	r3,36(r2)
81144398:	00a045f4 	movhi	r2,33047
8114439c:	10b84c04 	addi	r2,r2,-7888
811443a0:	10800383 	ldbu	r2,14(r2)
811443a4:	10803fcc 	andi	r2,r2,255
811443a8:	1885203a 	divu	r2,r3,r2
811443ac:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
811443b0:	e0bffd17 	ldw	r2,-12(fp)
811443b4:	1083fdc8 	cmpgei	r2,r2,4087
811443b8:	1000051e 	bne	r2,zero,811443d0 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
811443bc:	00a045f4 	movhi	r2,33047
811443c0:	10b84c04 	addi	r2,r2,-7888
811443c4:	00c00304 	movi	r3,12
811443c8:	10c01085 	stb	r3,66(r2)
811443cc:	00000c06 	br	81144400 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
811443d0:	e0bffd17 	ldw	r2,-12(fp)
811443d4:	00fffb54 	movui	r3,65517
811443d8:	18800516 	blt	r3,r2,811443f0 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
811443dc:	00a045f4 	movhi	r2,33047
811443e0:	10b84c04 	addi	r2,r2,-7888
811443e4:	00c00404 	movi	r3,16
811443e8:	10c01085 	stb	r3,66(r2)
811443ec:	00000406 	br	81144400 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
811443f0:	00a045f4 	movhi	r2,33047
811443f4:	10b84c04 	addi	r2,r2,-7888
811443f8:	00c00804 	movi	r3,32
811443fc:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81144400:	e03ffc15 	stw	zero,-16(fp)
81144404:	00001106 	br	8114444c <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
81144408:	d0a0b317 	ldw	r2,-32052(gp)
8114440c:	10c00a17 	ldw	r3,40(r2)
81144410:	e0bffc17 	ldw	r2,-16(fp)
81144414:	1885883a 	add	r2,r3,r2
81144418:	108009c4 	addi	r2,r2,39
8114441c:	10800023 	ldbuio	r2,0(r2)
81144420:	10803fcc 	andi	r2,r2,255
81144424:	1009883a 	mov	r4,r2
81144428:	00a045f4 	movhi	r2,33047
8114442c:	10b84c04 	addi	r2,r2,-7888
81144430:	e0fffc17 	ldw	r3,-16(fp)
81144434:	10c5883a 	add	r2,r2,r3
81144438:	10800ac4 	addi	r2,r2,43
8114443c:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81144440:	e0bffc17 	ldw	r2,-16(fp)
81144444:	10800044 	addi	r2,r2,1
81144448:	e0bffc15 	stw	r2,-16(fp)
8114444c:	e0bffc17 	ldw	r2,-16(fp)
81144450:	10800110 	cmplti	r2,r2,4
81144454:	103fec1e 	bne	r2,zero,81144408 <__reset+0xfb124408>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81144458:	e03ffc15 	stw	zero,-16(fp)
8114445c:	00001106 	br	811444a4 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81144460:	d0a0b317 	ldw	r2,-32052(gp)
81144464:	10c00a17 	ldw	r3,40(r2)
81144468:	e0bffc17 	ldw	r2,-16(fp)
8114446c:	1885883a 	add	r2,r3,r2
81144470:	10800ac4 	addi	r2,r2,43
81144474:	10800023 	ldbuio	r2,0(r2)
81144478:	10803fcc 	andi	r2,r2,255
8114447c:	1009883a 	mov	r4,r2
81144480:	00a045f4 	movhi	r2,33047
81144484:	10b84c04 	addi	r2,r2,-7888
81144488:	e0fffc17 	ldw	r3,-16(fp)
8114448c:	10c5883a 	add	r2,r2,r3
81144490:	10800bc4 	addi	r2,r2,47
81144494:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81144498:	e0bffc17 	ldw	r2,-16(fp)
8114449c:	10800044 	addi	r2,r2,1
811444a0:	e0bffc15 	stw	r2,-16(fp)
811444a4:	e0bffc17 	ldw	r2,-16(fp)
811444a8:	108002d0 	cmplti	r2,r2,11
811444ac:	103fec1e 	bne	r2,zero,81144460 <__reset+0xfb124460>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811444b0:	e03ffc15 	stw	zero,-16(fp)
811444b4:	00001106 	br	811444fc <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
811444b8:	d0a0b317 	ldw	r2,-32052(gp)
811444bc:	10c00a17 	ldw	r3,40(r2)
811444c0:	e0bffc17 	ldw	r2,-16(fp)
811444c4:	1885883a 	add	r2,r3,r2
811444c8:	10800d84 	addi	r2,r2,54
811444cc:	10800023 	ldbuio	r2,0(r2)
811444d0:	10803fcc 	andi	r2,r2,255
811444d4:	1009883a 	mov	r4,r2
811444d8:	00a045f4 	movhi	r2,33047
811444dc:	10b84c04 	addi	r2,r2,-7888
811444e0:	e0fffc17 	ldw	r3,-16(fp)
811444e4:	10c5883a 	add	r2,r2,r3
811444e8:	10800e84 	addi	r2,r2,58
811444ec:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811444f0:	e0bffc17 	ldw	r2,-16(fp)
811444f4:	10800044 	addi	r2,r2,1
811444f8:	e0bffc15 	stw	r2,-16(fp)
811444fc:	e0bffc17 	ldw	r2,-16(fp)
81144500:	10800210 	cmplti	r2,r2,8
81144504:	103fec1e 	bne	r2,zero,811444b8 <__reset+0xfb1244b8>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81144508:	e03ffc15 	stw	zero,-16(fp)
8114450c:	00000a06 	br	81144538 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81144510:	00a045f4 	movhi	r2,33047
81144514:	10b86104 	addi	r2,r2,-7804
81144518:	e0fffc17 	ldw	r3,-16(fp)
8114451c:	180691ba 	slli	r3,r3,6
81144520:	10c5883a 	add	r2,r2,r3
81144524:	10800f04 	addi	r2,r2,60
81144528:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8114452c:	e0bffc17 	ldw	r2,-16(fp)
81144530:	10800044 	addi	r2,r2,1
81144534:	e0bffc15 	stw	r2,-16(fp)
81144538:	e0bffc17 	ldw	r2,-16(fp)
8114453c:	10800510 	cmplti	r2,r2,20
81144540:	103ff31e 	bne	r2,zero,81144510 <__reset+0xfb124510>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81144544:	00800044 	movi	r2,1
81144548:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8114454c:	00000106 	br	81144554 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81144550:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81144554:	e0bffb17 	ldw	r2,-20(fp)
}
81144558:	e037883a 	mov	sp,fp
8114455c:	dfc00117 	ldw	ra,4(sp)
81144560:	df000017 	ldw	fp,0(sp)
81144564:	dec00204 	addi	sp,sp,8
81144568:	f800283a 	ret

8114456c <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8114456c:	defffc04 	addi	sp,sp,-16
81144570:	de00012e 	bgeu	sp,et,81144578 <Look_for_FAT16+0xc>
81144574:	003b68fa 	trap	3
81144578:	dfc00315 	stw	ra,12(sp)
8114457c:	df000215 	stw	fp,8(sp)
81144580:	df000204 	addi	fp,sp,8
	bool result = false;
81144584:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81144588:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
8114458c:	10002e26 	beq	r2,zero,81144648 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81144590:	d0a0ad17 	ldw	r2,-32076(gp)
81144594:	1080000b 	ldhu	r2,0(r2)
81144598:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8114459c:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
811445a0:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
811445a4:	e0bfff0f 	ldh	r2,-4(fp)
811445a8:	10002716 	blt	r2,zero,81144648 <Look_for_FAT16+0xdc>
811445ac:	e0bfff0b 	ldhu	r2,-4(fp)
811445b0:	10bfffcc 	andi	r2,r2,65535
811445b4:	1083000c 	andi	r2,r2,3072
811445b8:	10830020 	cmpeqi	r2,r2,3072
811445bc:	1000221e 	bne	r2,zero,81144648 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
811445c0:	e0bfff0b 	ldhu	r2,-4(fp)
811445c4:	10bfffcc 	andi	r2,r2,65535
811445c8:	1083000c 	andi	r2,r2,3072
811445cc:	10810018 	cmpnei	r2,r2,1024
811445d0:	1000031e 	bne	r2,zero,811445e0 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
811445d4:	0009883a 	mov	r4,zero
811445d8:	1143ee40 	call	81143ee4 <Check_for_DOS_FAT>
811445dc:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
811445e0:	e0bfff0b 	ldhu	r2,-4(fp)
811445e4:	10bfffcc 	andi	r2,r2,65535
811445e8:	1083000c 	andi	r2,r2,3072
811445ec:	1000061e 	bne	r2,zero,81144608 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
811445f0:	11438200 	call	81143820 <Check_for_Master_Boot_Record>
811445f4:	10000426 	beq	r2,zero,81144608 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
811445f8:	d0a0b117 	ldw	r2,-32060(gp)
811445fc:	1009883a 	mov	r4,r2
81144600:	1143ee40 	call	81143ee4 <Check_for_DOS_FAT>
81144604:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
81144608:	e0bffe17 	ldw	r2,-8(fp)
8114460c:	10800058 	cmpnei	r2,r2,1
81144610:	10000d1e 	bne	r2,zero,81144648 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
81144614:	00a045f4 	movhi	r2,33047
81144618:	10b84c04 	addi	r2,r2,-7888
8114461c:	10801083 	ldbu	r2,66(r2)
81144620:	10803fcc 	andi	r2,r2,255
81144624:	10800420 	cmpeqi	r2,r2,16
81144628:	1000021e 	bne	r2,zero,81144634 <Look_for_FAT16+0xc8>
				{
					result = false;
8114462c:	e03ffe15 	stw	zero,-8(fp)
81144630:	00000506 	br	81144648 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81144634:	00a045f4 	movhi	r2,33047
81144638:	10b84c04 	addi	r2,r2,-7888
8114463c:	1080058b 	ldhu	r2,22(r2)
81144640:	10bfffcc 	andi	r2,r2,65535
81144644:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
81144648:	e0bffe17 	ldw	r2,-8(fp)
}
8114464c:	e037883a 	mov	sp,fp
81144650:	dfc00117 	ldw	ra,4(sp)
81144654:	df000017 	ldw	fp,0(sp)
81144658:	dec00204 	addi	sp,sp,8
8114465c:	f800283a 	ret

81144660 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81144660:	defffb04 	addi	sp,sp,-20
81144664:	de00012e 	bgeu	sp,et,8114466c <filename_to_upper_case+0xc>
81144668:	003b68fa 	trap	3
8114466c:	dfc00415 	stw	ra,16(sp)
81144670:	df000315 	stw	fp,12(sp)
81144674:	df000304 	addi	fp,sp,12
81144678:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8114467c:	e13fff17 	ldw	r4,-4(fp)
81144680:	11244bc0 	call	811244bc <strlen>
81144684:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81144688:	e03ffd15 	stw	zero,-12(fp)
8114468c:	00001e06 	br	81144708 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81144690:	e0bffd17 	ldw	r2,-12(fp)
81144694:	e0ffff17 	ldw	r3,-4(fp)
81144698:	1885883a 	add	r2,r3,r2
8114469c:	10800003 	ldbu	r2,0(r2)
811446a0:	10803fcc 	andi	r2,r2,255
811446a4:	1080201c 	xori	r2,r2,128
811446a8:	10bfe004 	addi	r2,r2,-128
811446ac:	10801850 	cmplti	r2,r2,97
811446b0:	1000121e 	bne	r2,zero,811446fc <filename_to_upper_case+0x9c>
811446b4:	e0bffd17 	ldw	r2,-12(fp)
811446b8:	e0ffff17 	ldw	r3,-4(fp)
811446bc:	1885883a 	add	r2,r3,r2
811446c0:	10800003 	ldbu	r2,0(r2)
811446c4:	10803fcc 	andi	r2,r2,255
811446c8:	1080201c 	xori	r2,r2,128
811446cc:	10bfe004 	addi	r2,r2,-128
811446d0:	10801ec8 	cmpgei	r2,r2,123
811446d4:	1000091e 	bne	r2,zero,811446fc <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
811446d8:	e0bffd17 	ldw	r2,-12(fp)
811446dc:	e0ffff17 	ldw	r3,-4(fp)
811446e0:	1885883a 	add	r2,r3,r2
811446e4:	e0fffd17 	ldw	r3,-12(fp)
811446e8:	e13fff17 	ldw	r4,-4(fp)
811446ec:	20c7883a 	add	r3,r4,r3
811446f0:	18c00003 	ldbu	r3,0(r3)
811446f4:	18fff804 	addi	r3,r3,-32
811446f8:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
811446fc:	e0bffd17 	ldw	r2,-12(fp)
81144700:	10800044 	addi	r2,r2,1
81144704:	e0bffd15 	stw	r2,-12(fp)
81144708:	e0fffd17 	ldw	r3,-12(fp)
8114470c:	e0bffe17 	ldw	r2,-8(fp)
81144710:	18bfdf16 	blt	r3,r2,81144690 <__reset+0xfb124690>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
81144714:	0001883a 	nop
81144718:	e037883a 	mov	sp,fp
8114471c:	dfc00117 	ldw	ra,4(sp)
81144720:	df000017 	ldw	fp,0(sp)
81144724:	dec00204 	addi	sp,sp,8
81144728:	f800283a 	ret

8114472c <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8114472c:	defff804 	addi	sp,sp,-32
81144730:	de00012e 	bgeu	sp,et,81144738 <check_file_name_for_FAT16_compliance+0xc>
81144734:	003b68fa 	trap	3
81144738:	dfc00715 	stw	ra,28(sp)
8114473c:	df000615 	stw	fp,24(sp)
81144740:	df000604 	addi	fp,sp,24
81144744:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81144748:	e13fff17 	ldw	r4,-4(fp)
8114474c:	11244bc0 	call	811244bc <strlen>
81144750:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81144754:	00bfffc4 	movi	r2,-1
81144758:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8114475c:	00bfffc4 	movi	r2,-1
81144760:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81144764:	00800044 	movi	r2,1
81144768:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8114476c:	e03ffa15 	stw	zero,-24(fp)
81144770:	00006d06 	br	81144928 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81144774:	e0bffa17 	ldw	r2,-24(fp)
81144778:	e0ffff17 	ldw	r3,-4(fp)
8114477c:	1885883a 	add	r2,r3,r2
81144780:	10800003 	ldbu	r2,0(r2)
81144784:	10803fcc 	andi	r2,r2,255
81144788:	1080201c 	xori	r2,r2,128
8114478c:	10bfe004 	addi	r2,r2,-128
81144790:	10800820 	cmpeqi	r2,r2,32
81144794:	10003e1e 	bne	r2,zero,81144890 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81144798:	e0bffa17 	ldw	r2,-24(fp)
8114479c:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
811447a0:	e0bffb17 	ldw	r2,-20(fp)
811447a4:	1880121e 	bne	r3,r2,811447f0 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811447a8:	e0bffa17 	ldw	r2,-24(fp)
811447ac:	e0ffff17 	ldw	r3,-4(fp)
811447b0:	1885883a 	add	r2,r3,r2
811447b4:	10800003 	ldbu	r2,0(r2)
811447b8:	10803fcc 	andi	r2,r2,255
811447bc:	1080201c 	xori	r2,r2,128
811447c0:	10bfe004 	addi	r2,r2,-128
811447c4:	10801720 	cmpeqi	r2,r2,92
811447c8:	1000311e 	bne	r2,zero,81144890 <check_file_name_for_FAT16_compliance+0x164>
811447cc:	e0bffa17 	ldw	r2,-24(fp)
811447d0:	e0ffff17 	ldw	r3,-4(fp)
811447d4:	1885883a 	add	r2,r3,r2
811447d8:	10800003 	ldbu	r2,0(r2)
811447dc:	10803fcc 	andi	r2,r2,255
811447e0:	1080201c 	xori	r2,r2,128
811447e4:	10bfe004 	addi	r2,r2,-128
811447e8:	10800be0 	cmpeqi	r2,r2,47
811447ec:	1000281e 	bne	r2,zero,81144890 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811447f0:	e0fffa17 	ldw	r3,-24(fp)
811447f4:	e0bffc17 	ldw	r2,-16(fp)
811447f8:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811447fc:	10800258 	cmpnei	r2,r2,9
81144800:	1000091e 	bne	r2,zero,81144828 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81144804:	e0bffa17 	ldw	r2,-24(fp)
81144808:	e0ffff17 	ldw	r3,-4(fp)
8114480c:	1885883a 	add	r2,r3,r2
81144810:	10800003 	ldbu	r2,0(r2)
81144814:	10803fcc 	andi	r2,r2,255
81144818:	1080201c 	xori	r2,r2,128
8114481c:	10bfe004 	addi	r2,r2,-128
81144820:	10800b98 	cmpnei	r2,r2,46
81144824:	10001a1e 	bne	r2,zero,81144890 <check_file_name_for_FAT16_compliance+0x164>
81144828:	e0fffb17 	ldw	r3,-20(fp)
8114482c:	e0bffc17 	ldw	r2,-16(fp)
81144830:	18801926 	beq	r3,r2,81144898 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81144834:	e0fffa17 	ldw	r3,-24(fp)
81144838:	e0bffc17 	ldw	r2,-16(fp)
8114483c:	1885c83a 	sub	r2,r3,r2
81144840:	10800110 	cmplti	r2,r2,4
81144844:	1000141e 	bne	r2,zero,81144898 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81144848:	e0bffa17 	ldw	r2,-24(fp)
8114484c:	e0ffff17 	ldw	r3,-4(fp)
81144850:	1885883a 	add	r2,r3,r2
81144854:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81144858:	10803fcc 	andi	r2,r2,255
8114485c:	1080201c 	xori	r2,r2,128
81144860:	10bfe004 	addi	r2,r2,-128
81144864:	10801720 	cmpeqi	r2,r2,92
81144868:	10000b1e 	bne	r2,zero,81144898 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8114486c:	e0bffa17 	ldw	r2,-24(fp)
81144870:	e0ffff17 	ldw	r3,-4(fp)
81144874:	1885883a 	add	r2,r3,r2
81144878:	10800003 	ldbu	r2,0(r2)
8114487c:	10803fcc 	andi	r2,r2,255
81144880:	1080201c 	xori	r2,r2,128
81144884:	10bfe004 	addi	r2,r2,-128
81144888:	10800be0 	cmpeqi	r2,r2,47
8114488c:	1000021e 	bne	r2,zero,81144898 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81144890:	e03ffd15 	stw	zero,-12(fp)
            break;
81144894:	00002706 	br	81144934 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81144898:	e0bffa17 	ldw	r2,-24(fp)
8114489c:	e0ffff17 	ldw	r3,-4(fp)
811448a0:	1885883a 	add	r2,r3,r2
811448a4:	10800003 	ldbu	r2,0(r2)
811448a8:	10803fcc 	andi	r2,r2,255
811448ac:	1080201c 	xori	r2,r2,128
811448b0:	10bfe004 	addi	r2,r2,-128
811448b4:	10801720 	cmpeqi	r2,r2,92
811448b8:	1000091e 	bne	r2,zero,811448e0 <check_file_name_for_FAT16_compliance+0x1b4>
811448bc:	e0bffa17 	ldw	r2,-24(fp)
811448c0:	e0ffff17 	ldw	r3,-4(fp)
811448c4:	1885883a 	add	r2,r3,r2
811448c8:	10800003 	ldbu	r2,0(r2)
811448cc:	10803fcc 	andi	r2,r2,255
811448d0:	1080201c 	xori	r2,r2,128
811448d4:	10bfe004 	addi	r2,r2,-128
811448d8:	10800bd8 	cmpnei	r2,r2,47
811448dc:	1000041e 	bne	r2,zero,811448f0 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
811448e0:	e0bffa17 	ldw	r2,-24(fp)
811448e4:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
811448e8:	e0bffa17 	ldw	r2,-24(fp)
811448ec:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
811448f0:	e0bffa17 	ldw	r2,-24(fp)
811448f4:	e0ffff17 	ldw	r3,-4(fp)
811448f8:	1885883a 	add	r2,r3,r2
811448fc:	10800003 	ldbu	r2,0(r2)
81144900:	10803fcc 	andi	r2,r2,255
81144904:	1080201c 	xori	r2,r2,128
81144908:	10bfe004 	addi	r2,r2,-128
8114490c:	10800b98 	cmpnei	r2,r2,46
81144910:	1000021e 	bne	r2,zero,8114491c <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
81144914:	e0bffa17 	ldw	r2,-24(fp)
81144918:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8114491c:	e0bffa17 	ldw	r2,-24(fp)
81144920:	10800044 	addi	r2,r2,1
81144924:	e0bffa15 	stw	r2,-24(fp)
81144928:	e0fffa17 	ldw	r3,-24(fp)
8114492c:	e0bffe17 	ldw	r2,-8(fp)
81144930:	18bf9016 	blt	r3,r2,81144774 <__reset+0xfb124774>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
81144934:	e0bffe17 	ldw	r2,-8(fp)
81144938:	10bfffc4 	addi	r2,r2,-1
8114493c:	e0ffff17 	ldw	r3,-4(fp)
81144940:	1885883a 	add	r2,r3,r2
81144944:	10800003 	ldbu	r2,0(r2)
81144948:	10803fcc 	andi	r2,r2,255
8114494c:	1080201c 	xori	r2,r2,128
81144950:	10bfe004 	addi	r2,r2,-128
81144954:	10801720 	cmpeqi	r2,r2,92
81144958:	10000a1e 	bne	r2,zero,81144984 <check_file_name_for_FAT16_compliance+0x258>
8114495c:	e0bffe17 	ldw	r2,-8(fp)
81144960:	10bfffc4 	addi	r2,r2,-1
81144964:	e0ffff17 	ldw	r3,-4(fp)
81144968:	1885883a 	add	r2,r3,r2
8114496c:	10800003 	ldbu	r2,0(r2)
81144970:	10803fcc 	andi	r2,r2,255
81144974:	1080201c 	xori	r2,r2,128
81144978:	10bfe004 	addi	r2,r2,-128
8114497c:	10800bd8 	cmpnei	r2,r2,47
81144980:	1000011e 	bne	r2,zero,81144988 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81144984:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81144988:	e0bffd17 	ldw	r2,-12(fp)
}
8114498c:	e037883a 	mov	sp,fp
81144990:	dfc00117 	ldw	ra,4(sp)
81144994:	df000017 	ldw	fp,0(sp)
81144998:	dec00204 	addi	sp,sp,8
8114499c:	f800283a 	ret

811449a0 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
811449a0:	defffb04 	addi	sp,sp,-20
811449a4:	de00012e 	bgeu	sp,et,811449ac <get_dir_divider_location+0xc>
811449a8:	003b68fa 	trap	3
811449ac:	dfc00415 	stw	ra,16(sp)
811449b0:	df000315 	stw	fp,12(sp)
811449b4:	df000304 	addi	fp,sp,12
811449b8:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
811449bc:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
811449c0:	e13fff17 	ldw	r4,-4(fp)
811449c4:	11244bc0 	call	811244bc <strlen>
811449c8:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
811449cc:	e03ffd15 	stw	zero,-12(fp)
811449d0:	00001506 	br	81144a28 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
811449d4:	e0bffd17 	ldw	r2,-12(fp)
811449d8:	e0ffff17 	ldw	r3,-4(fp)
811449dc:	1885883a 	add	r2,r3,r2
811449e0:	10800003 	ldbu	r2,0(r2)
811449e4:	10803fcc 	andi	r2,r2,255
811449e8:	1080201c 	xori	r2,r2,128
811449ec:	10bfe004 	addi	r2,r2,-128
811449f0:	10801720 	cmpeqi	r2,r2,92
811449f4:	10000f1e 	bne	r2,zero,81144a34 <get_dir_divider_location+0x94>
811449f8:	e0bffd17 	ldw	r2,-12(fp)
811449fc:	e0ffff17 	ldw	r3,-4(fp)
81144a00:	1885883a 	add	r2,r3,r2
81144a04:	10800003 	ldbu	r2,0(r2)
81144a08:	10803fcc 	andi	r2,r2,255
81144a0c:	1080201c 	xori	r2,r2,128
81144a10:	10bfe004 	addi	r2,r2,-128
81144a14:	10800be0 	cmpeqi	r2,r2,47
81144a18:	1000061e 	bne	r2,zero,81144a34 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81144a1c:	e0bffd17 	ldw	r2,-12(fp)
81144a20:	10800044 	addi	r2,r2,1
81144a24:	e0bffd15 	stw	r2,-12(fp)
81144a28:	e0fffd17 	ldw	r3,-12(fp)
81144a2c:	e0bffe17 	ldw	r2,-8(fp)
81144a30:	18bfe816 	blt	r3,r2,811449d4 <__reset+0xfb1249d4>
        {
            break;
        }
    }
    
    if (index == length)
81144a34:	e0fffd17 	ldw	r3,-12(fp)
81144a38:	e0bffe17 	ldw	r2,-8(fp)
81144a3c:	1880021e 	bne	r3,r2,81144a48 <get_dir_divider_location+0xa8>
    {
        index = -1;
81144a40:	00bfffc4 	movi	r2,-1
81144a44:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
81144a48:	e0bffd17 	ldw	r2,-12(fp)
}
81144a4c:	e037883a 	mov	sp,fp
81144a50:	dfc00117 	ldw	ra,4(sp)
81144a54:	df000017 	ldw	fp,0(sp)
81144a58:	dec00204 	addi	sp,sp,8
81144a5c:	f800283a 	ret

81144a60 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81144a60:	defffa04 	addi	sp,sp,-24
81144a64:	de00012e 	bgeu	sp,et,81144a6c <match_file_record_to_name_ext+0xc>
81144a68:	003b68fa 	trap	3
81144a6c:	df000515 	stw	fp,20(sp)
81144a70:	df000504 	addi	fp,sp,20
81144a74:	e13ffd15 	stw	r4,-12(fp)
81144a78:	e17ffe15 	stw	r5,-8(fp)
81144a7c:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81144a80:	00800044 	movi	r2,1
81144a84:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81144a88:	e03ffc15 	stw	zero,-16(fp)
81144a8c:	00004606 	br	81144ba8 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81144a90:	e0fffd17 	ldw	r3,-12(fp)
81144a94:	e0bffc17 	ldw	r2,-16(fp)
81144a98:	1885883a 	add	r2,r3,r2
81144a9c:	10800003 	ldbu	r2,0(r2)
81144aa0:	10803fcc 	andi	r2,r2,255
81144aa4:	10801870 	cmpltui	r2,r2,97
81144aa8:	1000101e 	bne	r2,zero,81144aec <match_file_record_to_name_ext+0x8c>
81144aac:	e0fffd17 	ldw	r3,-12(fp)
81144ab0:	e0bffc17 	ldw	r2,-16(fp)
81144ab4:	1885883a 	add	r2,r3,r2
81144ab8:	10800003 	ldbu	r2,0(r2)
81144abc:	10803fcc 	andi	r2,r2,255
81144ac0:	10801ee8 	cmpgeui	r2,r2,123
81144ac4:	1000091e 	bne	r2,zero,81144aec <match_file_record_to_name_ext+0x8c>
81144ac8:	e0fffd17 	ldw	r3,-12(fp)
81144acc:	e0bffc17 	ldw	r2,-16(fp)
81144ad0:	1885883a 	add	r2,r3,r2
81144ad4:	10800003 	ldbu	r2,0(r2)
81144ad8:	10bff804 	addi	r2,r2,-32
81144adc:	10c03fcc 	andi	r3,r2,255
81144ae0:	18c0201c 	xori	r3,r3,128
81144ae4:	18ffe004 	addi	r3,r3,-128
81144ae8:	00000706 	br	81144b08 <match_file_record_to_name_ext+0xa8>
81144aec:	e0fffd17 	ldw	r3,-12(fp)
81144af0:	e0bffc17 	ldw	r2,-16(fp)
81144af4:	1885883a 	add	r2,r3,r2
81144af8:	10800003 	ldbu	r2,0(r2)
81144afc:	10c03fcc 	andi	r3,r2,255
81144b00:	18c0201c 	xori	r3,r3,128
81144b04:	18ffe004 	addi	r3,r3,-128
81144b08:	e0bffc17 	ldw	r2,-16(fp)
81144b0c:	e13ffe17 	ldw	r4,-8(fp)
81144b10:	2085883a 	add	r2,r4,r2
81144b14:	10800003 	ldbu	r2,0(r2)
81144b18:	10803fcc 	andi	r2,r2,255
81144b1c:	1080201c 	xori	r2,r2,128
81144b20:	10bfe004 	addi	r2,r2,-128
81144b24:	10801850 	cmplti	r2,r2,97
81144b28:	1000121e 	bne	r2,zero,81144b74 <match_file_record_to_name_ext+0x114>
81144b2c:	e0bffc17 	ldw	r2,-16(fp)
81144b30:	e13ffe17 	ldw	r4,-8(fp)
81144b34:	2085883a 	add	r2,r4,r2
81144b38:	10800003 	ldbu	r2,0(r2)
81144b3c:	10803fcc 	andi	r2,r2,255
81144b40:	1080201c 	xori	r2,r2,128
81144b44:	10bfe004 	addi	r2,r2,-128
81144b48:	10801ec8 	cmpgei	r2,r2,123
81144b4c:	1000091e 	bne	r2,zero,81144b74 <match_file_record_to_name_ext+0x114>
81144b50:	e0bffc17 	ldw	r2,-16(fp)
81144b54:	e13ffe17 	ldw	r4,-8(fp)
81144b58:	2085883a 	add	r2,r4,r2
81144b5c:	10800003 	ldbu	r2,0(r2)
81144b60:	10bff804 	addi	r2,r2,-32
81144b64:	10803fcc 	andi	r2,r2,255
81144b68:	1080201c 	xori	r2,r2,128
81144b6c:	10bfe004 	addi	r2,r2,-128
81144b70:	00000706 	br	81144b90 <match_file_record_to_name_ext+0x130>
81144b74:	e0bffc17 	ldw	r2,-16(fp)
81144b78:	e13ffe17 	ldw	r4,-8(fp)
81144b7c:	2085883a 	add	r2,r4,r2
81144b80:	10800003 	ldbu	r2,0(r2)
81144b84:	10803fcc 	andi	r2,r2,255
81144b88:	1080201c 	xori	r2,r2,128
81144b8c:	10bfe004 	addi	r2,r2,-128
81144b90:	18800226 	beq	r3,r2,81144b9c <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81144b94:	e03ffb15 	stw	zero,-20(fp)
			break;
81144b98:	00000606 	br	81144bb4 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81144b9c:	e0bffc17 	ldw	r2,-16(fp)
81144ba0:	10800044 	addi	r2,r2,1
81144ba4:	e0bffc15 	stw	r2,-16(fp)
81144ba8:	e0bffc17 	ldw	r2,-16(fp)
81144bac:	10800210 	cmplti	r2,r2,8
81144bb0:	103fb71e 	bne	r2,zero,81144a90 <__reset+0xfb124a90>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81144bb4:	e03ffc15 	stw	zero,-16(fp)
81144bb8:	00004a06 	br	81144ce4 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81144bbc:	e0fffd17 	ldw	r3,-12(fp)
81144bc0:	e0bffc17 	ldw	r2,-16(fp)
81144bc4:	1885883a 	add	r2,r3,r2
81144bc8:	10800204 	addi	r2,r2,8
81144bcc:	10800003 	ldbu	r2,0(r2)
81144bd0:	10803fcc 	andi	r2,r2,255
81144bd4:	10801870 	cmpltui	r2,r2,97
81144bd8:	1000121e 	bne	r2,zero,81144c24 <match_file_record_to_name_ext+0x1c4>
81144bdc:	e0fffd17 	ldw	r3,-12(fp)
81144be0:	e0bffc17 	ldw	r2,-16(fp)
81144be4:	1885883a 	add	r2,r3,r2
81144be8:	10800204 	addi	r2,r2,8
81144bec:	10800003 	ldbu	r2,0(r2)
81144bf0:	10803fcc 	andi	r2,r2,255
81144bf4:	10801ee8 	cmpgeui	r2,r2,123
81144bf8:	10000a1e 	bne	r2,zero,81144c24 <match_file_record_to_name_ext+0x1c4>
81144bfc:	e0fffd17 	ldw	r3,-12(fp)
81144c00:	e0bffc17 	ldw	r2,-16(fp)
81144c04:	1885883a 	add	r2,r3,r2
81144c08:	10800204 	addi	r2,r2,8
81144c0c:	10800003 	ldbu	r2,0(r2)
81144c10:	10bff804 	addi	r2,r2,-32
81144c14:	10c03fcc 	andi	r3,r2,255
81144c18:	18c0201c 	xori	r3,r3,128
81144c1c:	18ffe004 	addi	r3,r3,-128
81144c20:	00000806 	br	81144c44 <match_file_record_to_name_ext+0x1e4>
81144c24:	e0fffd17 	ldw	r3,-12(fp)
81144c28:	e0bffc17 	ldw	r2,-16(fp)
81144c2c:	1885883a 	add	r2,r3,r2
81144c30:	10800204 	addi	r2,r2,8
81144c34:	10800003 	ldbu	r2,0(r2)
81144c38:	10c03fcc 	andi	r3,r2,255
81144c3c:	18c0201c 	xori	r3,r3,128
81144c40:	18ffe004 	addi	r3,r3,-128
81144c44:	e0bffc17 	ldw	r2,-16(fp)
81144c48:	e13fff17 	ldw	r4,-4(fp)
81144c4c:	2085883a 	add	r2,r4,r2
81144c50:	10800003 	ldbu	r2,0(r2)
81144c54:	10803fcc 	andi	r2,r2,255
81144c58:	1080201c 	xori	r2,r2,128
81144c5c:	10bfe004 	addi	r2,r2,-128
81144c60:	10801850 	cmplti	r2,r2,97
81144c64:	1000121e 	bne	r2,zero,81144cb0 <match_file_record_to_name_ext+0x250>
81144c68:	e0bffc17 	ldw	r2,-16(fp)
81144c6c:	e13fff17 	ldw	r4,-4(fp)
81144c70:	2085883a 	add	r2,r4,r2
81144c74:	10800003 	ldbu	r2,0(r2)
81144c78:	10803fcc 	andi	r2,r2,255
81144c7c:	1080201c 	xori	r2,r2,128
81144c80:	10bfe004 	addi	r2,r2,-128
81144c84:	10801ec8 	cmpgei	r2,r2,123
81144c88:	1000091e 	bne	r2,zero,81144cb0 <match_file_record_to_name_ext+0x250>
81144c8c:	e0bffc17 	ldw	r2,-16(fp)
81144c90:	e13fff17 	ldw	r4,-4(fp)
81144c94:	2085883a 	add	r2,r4,r2
81144c98:	10800003 	ldbu	r2,0(r2)
81144c9c:	10bff804 	addi	r2,r2,-32
81144ca0:	10803fcc 	andi	r2,r2,255
81144ca4:	1080201c 	xori	r2,r2,128
81144ca8:	10bfe004 	addi	r2,r2,-128
81144cac:	00000706 	br	81144ccc <match_file_record_to_name_ext+0x26c>
81144cb0:	e0bffc17 	ldw	r2,-16(fp)
81144cb4:	e13fff17 	ldw	r4,-4(fp)
81144cb8:	2085883a 	add	r2,r4,r2
81144cbc:	10800003 	ldbu	r2,0(r2)
81144cc0:	10803fcc 	andi	r2,r2,255
81144cc4:	1080201c 	xori	r2,r2,128
81144cc8:	10bfe004 	addi	r2,r2,-128
81144ccc:	18800226 	beq	r3,r2,81144cd8 <match_file_record_to_name_ext+0x278>
        {
            match = false;
81144cd0:	e03ffb15 	stw	zero,-20(fp)
			break;
81144cd4:	00000606 	br	81144cf0 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81144cd8:	e0bffc17 	ldw	r2,-16(fp)
81144cdc:	10800044 	addi	r2,r2,1
81144ce0:	e0bffc15 	stw	r2,-16(fp)
81144ce4:	e0bffc17 	ldw	r2,-16(fp)
81144ce8:	108000d0 	cmplti	r2,r2,3
81144cec:	103fb31e 	bne	r2,zero,81144bbc <__reset+0xfb124bbc>
        {
            match = false;
			break;
        }
    }
	return match;
81144cf0:	e0bffb17 	ldw	r2,-20(fp)
}
81144cf4:	e037883a 	mov	sp,fp
81144cf8:	df000017 	ldw	fp,0(sp)
81144cfc:	dec00104 	addi	sp,sp,4
81144d00:	f800283a 	ret

81144d04 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
81144d04:	deffe704 	addi	sp,sp,-100
81144d08:	de00012e 	bgeu	sp,et,81144d10 <get_home_directory_cluster_for_file+0xc>
81144d0c:	003b68fa 	trap	3
81144d10:	dfc01815 	stw	ra,96(sp)
81144d14:	df001715 	stw	fp,92(sp)
81144d18:	df001704 	addi	fp,sp,92
81144d1c:	e13ffd15 	stw	r4,-12(fp)
81144d20:	e17ffe15 	stw	r5,-8(fp)
81144d24:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81144d28:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81144d2c:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81144d30:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81144d34:	e13ffd17 	ldw	r4,-12(fp)
81144d38:	11449a00 	call	811449a0 <get_dir_divider_location>
81144d3c:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81144d40:	00012f06 	br	81145200 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81144d44:	00800804 	movi	r2,32
81144d48:	e0bff905 	stb	r2,-28(fp)
81144d4c:	00800804 	movi	r2,32
81144d50:	e0bff945 	stb	r2,-27(fp)
81144d54:	00800804 	movi	r2,32
81144d58:	e0bff985 	stb	r2,-26(fp)
81144d5c:	00800804 	movi	r2,32
81144d60:	e0bff9c5 	stb	r2,-25(fp)
81144d64:	00800804 	movi	r2,32
81144d68:	e0bffa05 	stb	r2,-24(fp)
81144d6c:	00800804 	movi	r2,32
81144d70:	e0bffa45 	stb	r2,-23(fp)
81144d74:	00800804 	movi	r2,32
81144d78:	e0bffa85 	stb	r2,-22(fp)
81144d7c:	00800804 	movi	r2,32
81144d80:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81144d84:	00800804 	movi	r2,32
81144d88:	e0bffb05 	stb	r2,-20(fp)
81144d8c:	00800804 	movi	r2,32
81144d90:	e0bffb45 	stb	r2,-19(fp)
81144d94:	00800804 	movi	r2,32
81144d98:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81144d9c:	00bfffc4 	movi	r2,-1
81144da0:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81144da4:	e0bfea17 	ldw	r2,-88(fp)
81144da8:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81144dac:	e03fec15 	stw	zero,-80(fp)
81144db0:	00002d06 	br	81144e68 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81144db4:	e0ffec17 	ldw	r3,-80(fp)
81144db8:	e0bfed17 	ldw	r2,-76(fp)
81144dbc:	1885883a 	add	r2,r3,r2
81144dc0:	1007883a 	mov	r3,r2
81144dc4:	e0bffd17 	ldw	r2,-12(fp)
81144dc8:	10c5883a 	add	r2,r2,r3
81144dcc:	10800003 	ldbu	r2,0(r2)
81144dd0:	10803fcc 	andi	r2,r2,255
81144dd4:	1080201c 	xori	r2,r2,128
81144dd8:	10bfe004 	addi	r2,r2,-128
81144ddc:	10800b98 	cmpnei	r2,r2,46
81144de0:	1000031e 	bne	r2,zero,81144df0 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81144de4:	e0bfec17 	ldw	r2,-80(fp)
81144de8:	e0bfee15 	stw	r2,-72(fp)
81144dec:	00001b06 	br	81144e5c <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81144df0:	e0bfee17 	ldw	r2,-72(fp)
81144df4:	10000c0e 	bge	r2,zero,81144e28 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81144df8:	e0ffec17 	ldw	r3,-80(fp)
81144dfc:	e0bfed17 	ldw	r2,-76(fp)
81144e00:	1885883a 	add	r2,r3,r2
81144e04:	1007883a 	mov	r3,r2
81144e08:	e0bffd17 	ldw	r2,-12(fp)
81144e0c:	10c5883a 	add	r2,r2,r3
81144e10:	10c00003 	ldbu	r3,0(r2)
81144e14:	e13ff904 	addi	r4,fp,-28
81144e18:	e0bfec17 	ldw	r2,-80(fp)
81144e1c:	2085883a 	add	r2,r4,r2
81144e20:	10c00005 	stb	r3,0(r2)
81144e24:	00000d06 	br	81144e5c <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81144e28:	e0ffec17 	ldw	r3,-80(fp)
81144e2c:	e0bfee17 	ldw	r2,-72(fp)
81144e30:	1885c83a 	sub	r2,r3,r2
81144e34:	e13fec17 	ldw	r4,-80(fp)
81144e38:	e0ffed17 	ldw	r3,-76(fp)
81144e3c:	20c7883a 	add	r3,r4,r3
81144e40:	1809883a 	mov	r4,r3
81144e44:	e0fffd17 	ldw	r3,-12(fp)
81144e48:	1907883a 	add	r3,r3,r4
81144e4c:	18c00003 	ldbu	r3,0(r3)
81144e50:	e13ffb04 	addi	r4,fp,-20
81144e54:	2085883a 	add	r2,r4,r2
81144e58:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81144e5c:	e0bfec17 	ldw	r2,-80(fp)
81144e60:	10800044 	addi	r2,r2,1
81144e64:	e0bfec15 	stw	r2,-80(fp)
81144e68:	e0ffec17 	ldw	r3,-80(fp)
81144e6c:	e0bfeb17 	ldw	r2,-84(fp)
81144e70:	18bfd016 	blt	r3,r2,81144db4 <__reset+0xfb124db4>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81144e74:	e0bfea17 	ldw	r2,-88(fp)
81144e78:	10005c1e 	bne	r2,zero,81144fec <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81144e7c:	00a045f4 	movhi	r2,33047
81144e80:	10b84c04 	addi	r2,r2,-7888
81144e84:	1080050b 	ldhu	r2,20(r2)
81144e88:	10bfffcc 	andi	r2,r2,65535
81144e8c:	1006917a 	slli	r3,r2,5
81144e90:	00a045f4 	movhi	r2,33047
81144e94:	10b84c04 	addi	r2,r2,-7888
81144e98:	1080030b 	ldhu	r2,12(r2)
81144e9c:	10bfffcc 	andi	r2,r2,65535
81144ea0:	1885283a 	div	r2,r3,r2
81144ea4:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81144ea8:	e03ff015 	stw	zero,-64(fp)
81144eac:	00003b06 	br	81144f9c <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81144eb0:	00a045f4 	movhi	r2,33047
81144eb4:	10b84c04 	addi	r2,r2,-7888
81144eb8:	10c01317 	ldw	r3,76(r2)
81144ebc:	e0bff017 	ldw	r2,-64(fp)
81144ec0:	1885883a 	add	r2,r3,r2
81144ec4:	1007883a 	mov	r3,r2
81144ec8:	d0a0b117 	ldw	r2,-32060(gp)
81144ecc:	100b883a 	mov	r5,r2
81144ed0:	1809883a 	mov	r4,r3
81144ed4:	114359c0 	call	8114359c <Read_Sector_Data>
81144ed8:	10003426 	beq	r2,zero,81144fac <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81144edc:	e03ff115 	stw	zero,-60(fp)
81144ee0:	00002506 	br	81144f78 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81144ee4:	e0bff117 	ldw	r2,-60(fp)
81144ee8:	1004917a 	slli	r2,r2,5
81144eec:	e0fff017 	ldw	r3,-64(fp)
81144ef0:	180f883a 	mov	r7,r3
81144ef4:	000d883a 	mov	r6,zero
81144ef8:	e17fff17 	ldw	r5,-4(fp)
81144efc:	1009883a 	mov	r4,r2
81144f00:	11439cc0 	call	811439cc <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81144f04:	e0bfff17 	ldw	r2,-4(fp)
81144f08:	10800003 	ldbu	r2,0(r2)
81144f0c:	10803fcc 	andi	r2,r2,255
81144f10:	10803960 	cmpeqi	r2,r2,229
81144f14:	1000151e 	bne	r2,zero,81144f6c <get_home_directory_cluster_for_file+0x268>
81144f18:	e0bfff17 	ldw	r2,-4(fp)
81144f1c:	10800003 	ldbu	r2,0(r2)
81144f20:	10803fcc 	andi	r2,r2,255
81144f24:	10001126 	beq	r2,zero,81144f6c <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81144f28:	e0fffb04 	addi	r3,fp,-20
81144f2c:	e0bff904 	addi	r2,fp,-28
81144f30:	180d883a 	mov	r6,r3
81144f34:	100b883a 	mov	r5,r2
81144f38:	e13fff17 	ldw	r4,-4(fp)
81144f3c:	1144a600 	call	81144a60 <match_file_record_to_name_ext>
81144f40:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81144f44:	e0bff817 	ldw	r2,-32(fp)
81144f48:	10000826 	beq	r2,zero,81144f6c <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81144f4c:	e0bfff17 	ldw	r2,-4(fp)
81144f50:	1080058b 	ldhu	r2,22(r2)
81144f54:	10bfffcc 	andi	r2,r2,65535
81144f58:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81144f5c:	e0bfff17 	ldw	r2,-4(fp)
81144f60:	00c00044 	movi	r3,1
81144f64:	10c00a15 	stw	r3,40(r2)
                                break;
81144f68:	00000606 	br	81144f84 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81144f6c:	e0bff117 	ldw	r2,-60(fp)
81144f70:	10800044 	addi	r2,r2,1
81144f74:	e0bff115 	stw	r2,-60(fp)
81144f78:	e0bff117 	ldw	r2,-60(fp)
81144f7c:	10800410 	cmplti	r2,r2,16
81144f80:	103fd81e 	bne	r2,zero,81144ee4 <__reset+0xfb124ee4>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81144f84:	e0ffef17 	ldw	r3,-68(fp)
81144f88:	e0bfea17 	ldw	r2,-88(fp)
81144f8c:	1880091e 	bne	r3,r2,81144fb4 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81144f90:	e0bff017 	ldw	r2,-64(fp)
81144f94:	10800044 	addi	r2,r2,1
81144f98:	e0bff015 	stw	r2,-64(fp)
81144f9c:	e0fff017 	ldw	r3,-64(fp)
81144fa0:	e0bff717 	ldw	r2,-36(fp)
81144fa4:	18bfc216 	blt	r3,r2,81144eb0 <__reset+0xfb124eb0>
81144fa8:	00000306 	br	81144fb8 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81144fac:	0001883a 	nop
81144fb0:	00000106 	br	81144fb8 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81144fb4:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81144fb8:	e0ffef17 	ldw	r3,-68(fp)
81144fbc:	e0bfea17 	ldw	r2,-88(fp)
81144fc0:	18800826 	beq	r3,r2,81144fe4 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81144fc4:	e0bfef17 	ldw	r2,-68(fp)
81144fc8:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81144fcc:	e0ffed17 	ldw	r3,-76(fp)
81144fd0:	e0bfeb17 	ldw	r2,-84(fp)
81144fd4:	1885883a 	add	r2,r3,r2
81144fd8:	10800044 	addi	r2,r2,1
81144fdc:	e0bfed15 	stw	r2,-76(fp)
81144fe0:	00007d06 	br	811451d8 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81144fe4:	0005883a 	mov	r2,zero
81144fe8:	00009106 	br	81145230 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81144fec:	e0bfea17 	ldw	r2,-88(fp)
81144ff0:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81144ff4:	e0bff417 	ldw	r2,-48(fp)
81144ff8:	10ffff84 	addi	r3,r2,-2
81144ffc:	00a045f4 	movhi	r2,33047
81145000:	10b84c04 	addi	r2,r2,-7888
81145004:	10800383 	ldbu	r2,14(r2)
81145008:	10803fcc 	andi	r2,r2,255
8114500c:	1885383a 	mul	r2,r3,r2
81145010:	1007883a 	mov	r3,r2
81145014:	00a045f4 	movhi	r2,33047
81145018:	10b84c04 	addi	r2,r2,-7888
8114501c:	10801417 	ldw	r2,80(r2)
81145020:	1885883a 	add	r2,r3,r2
81145024:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145028:	e03ff215 	stw	zero,-56(fp)
8114502c:	00003606 	br	81145108 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81145030:	e0fff217 	ldw	r3,-56(fp)
81145034:	e0bff517 	ldw	r2,-44(fp)
81145038:	1885883a 	add	r2,r3,r2
8114503c:	d0e0b117 	ldw	r3,-32060(gp)
81145040:	180b883a 	mov	r5,r3
81145044:	1009883a 	mov	r4,r2
81145048:	114359c0 	call	8114359c <Read_Sector_Data>
8114504c:	10003526 	beq	r2,zero,81145124 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81145050:	e03ff315 	stw	zero,-52(fp)
81145054:	00002306 	br	811450e4 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81145058:	e0bff317 	ldw	r2,-52(fp)
8114505c:	1004917a 	slli	r2,r2,5
81145060:	e0fff417 	ldw	r3,-48(fp)
81145064:	e13ff217 	ldw	r4,-56(fp)
81145068:	200f883a 	mov	r7,r4
8114506c:	180d883a 	mov	r6,r3
81145070:	e17fff17 	ldw	r5,-4(fp)
81145074:	1009883a 	mov	r4,r2
81145078:	11439cc0 	call	811439cc <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114507c:	e0bfff17 	ldw	r2,-4(fp)
81145080:	10800003 	ldbu	r2,0(r2)
81145084:	10803fcc 	andi	r2,r2,255
81145088:	10803960 	cmpeqi	r2,r2,229
8114508c:	1000121e 	bne	r2,zero,811450d8 <get_home_directory_cluster_for_file+0x3d4>
81145090:	e0bfff17 	ldw	r2,-4(fp)
81145094:	10800003 	ldbu	r2,0(r2)
81145098:	10803fcc 	andi	r2,r2,255
8114509c:	10000e26 	beq	r2,zero,811450d8 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
811450a0:	e0fffb04 	addi	r3,fp,-20
811450a4:	e0bff904 	addi	r2,fp,-28
811450a8:	180d883a 	mov	r6,r3
811450ac:	100b883a 	mov	r5,r2
811450b0:	e13fff17 	ldw	r4,-4(fp)
811450b4:	1144a600 	call	81144a60 <match_file_record_to_name_ext>
811450b8:	e0bff615 	stw	r2,-40(fp)
                                if (match)
811450bc:	e0bff617 	ldw	r2,-40(fp)
811450c0:	10000526 	beq	r2,zero,811450d8 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
811450c4:	e0bfff17 	ldw	r2,-4(fp)
811450c8:	1080058b 	ldhu	r2,22(r2)
811450cc:	10bfffcc 	andi	r2,r2,65535
811450d0:	e0bfef15 	stw	r2,-68(fp)
                                    break;
811450d4:	00000606 	br	811450f0 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
811450d8:	e0bff317 	ldw	r2,-52(fp)
811450dc:	10800044 	addi	r2,r2,1
811450e0:	e0bff315 	stw	r2,-52(fp)
811450e4:	e0bff317 	ldw	r2,-52(fp)
811450e8:	10800410 	cmplti	r2,r2,16
811450ec:	103fda1e 	bne	r2,zero,81145058 <__reset+0xfb125058>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
811450f0:	e0ffef17 	ldw	r3,-68(fp)
811450f4:	e0bfea17 	ldw	r2,-88(fp)
811450f8:	18800c1e 	bne	r3,r2,8114512c <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811450fc:	e0bff217 	ldw	r2,-56(fp)
81145100:	10800044 	addi	r2,r2,1
81145104:	e0bff215 	stw	r2,-56(fp)
81145108:	00a045f4 	movhi	r2,33047
8114510c:	10b84c04 	addi	r2,r2,-7888
81145110:	10800383 	ldbu	r2,14(r2)
81145114:	10803fcc 	andi	r2,r2,255
81145118:	e0fff217 	ldw	r3,-56(fp)
8114511c:	18bfc416 	blt	r3,r2,81145030 <__reset+0xfb125030>
81145120:	00000306 	br	81145130 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81145124:	0001883a 	nop
81145128:	00000106 	br	81145130 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8114512c:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81145130:	e0ffef17 	ldw	r3,-68(fp)
81145134:	e0bfea17 	ldw	r2,-88(fp)
81145138:	1880141e 	bne	r3,r2,8114518c <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8114513c:	e0bfef17 	ldw	r2,-68(fp)
81145140:	e0fffc04 	addi	r3,fp,-16
81145144:	180b883a 	mov	r5,r3
81145148:	1009883a 	mov	r4,r2
8114514c:	114367c0 	call	8114367c <get_cluster_flag>
81145150:	10000c26 	beq	r2,zero,81145184 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81145154:	e0bffc0b 	ldhu	r2,-16(fp)
81145158:	10bfffcc 	andi	r2,r2,65535
8114515c:	10fffe0c 	andi	r3,r2,65528
81145160:	00bffe14 	movui	r2,65528
81145164:	1880021e 	bne	r3,r2,81145170 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81145168:	0005883a 	mov	r2,zero
8114516c:	00003006 	br	81145230 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81145170:	e0bffc0b 	ldhu	r2,-16(fp)
81145174:	10bfffcc 	andi	r2,r2,65535
81145178:	10bffe0c 	andi	r2,r2,65528
8114517c:	e0bfef15 	stw	r2,-68(fp)
81145180:	00000206 	br	8114518c <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81145184:	0005883a 	mov	r2,zero
81145188:	00002906 	br	81145230 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8114518c:	e0bff417 	ldw	r2,-48(fp)
81145190:	00fffdd4 	movui	r3,65527
81145194:	18800316 	blt	r3,r2,811451a4 <get_home_directory_cluster_for_file+0x4a0>
81145198:	e0ffef17 	ldw	r3,-68(fp)
8114519c:	e0bfea17 	ldw	r2,-88(fp)
811451a0:	18bf9426 	beq	r3,r2,81144ff4 <__reset+0xfb124ff4>
            if (new_cluster != home_dir_cluster)
811451a4:	e0ffef17 	ldw	r3,-68(fp)
811451a8:	e0bfea17 	ldw	r2,-88(fp)
811451ac:	18800826 	beq	r3,r2,811451d0 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
811451b0:	e0bfef17 	ldw	r2,-68(fp)
811451b4:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
811451b8:	e0ffed17 	ldw	r3,-76(fp)
811451bc:	e0bfeb17 	ldw	r2,-84(fp)
811451c0:	1885883a 	add	r2,r3,r2
811451c4:	10800044 	addi	r2,r2,1
811451c8:	e0bfed15 	stw	r2,-76(fp)
811451cc:	00000206 	br	811451d8 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
811451d0:	0005883a 	mov	r2,zero
811451d4:	00001606 	br	81145230 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
811451d8:	e0bfed17 	ldw	r2,-76(fp)
811451dc:	e0fffd17 	ldw	r3,-12(fp)
811451e0:	1885883a 	add	r2,r3,r2
811451e4:	1009883a 	mov	r4,r2
811451e8:	11449a00 	call	811449a0 <get_dir_divider_location>
811451ec:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
811451f0:	e0bfeb17 	ldw	r2,-84(fp)
811451f4:	1000020e 	bge	r2,zero,81145200 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
811451f8:	00800044 	movi	r2,1
811451fc:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81145200:	e0bfeb17 	ldw	r2,-84(fp)
81145204:	00becf16 	blt	zero,r2,81144d44 <__reset+0xfb124d44>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81145208:	e0bffe17 	ldw	r2,-8(fp)
8114520c:	e0ffea17 	ldw	r3,-88(fp)
81145210:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81145214:	e0bfea17 	ldw	r2,-88(fp)
81145218:	1000041e 	bne	r2,zero,8114522c <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8114521c:	e0bfff17 	ldw	r2,-4(fp)
81145220:	10000a15 	stw	zero,40(r2)
		result = true;
81145224:	00800044 	movi	r2,1
81145228:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8114522c:	e0bfe917 	ldw	r2,-92(fp)
}
81145230:	e037883a 	mov	sp,fp
81145234:	dfc00117 	ldw	ra,4(sp)
81145238:	df000017 	ldw	fp,0(sp)
8114523c:	dec00204 	addi	sp,sp,8
81145240:	f800283a 	ret

81145244 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81145244:	deffe804 	addi	sp,sp,-96
81145248:	de00012e 	bgeu	sp,et,81145250 <find_file_in_directory+0xc>
8114524c:	003b68fa 	trap	3
81145250:	dfc01715 	stw	ra,92(sp)
81145254:	df001615 	stw	fp,88(sp)
81145258:	df001604 	addi	fp,sp,88
8114525c:	e13ffd15 	stw	r4,-12(fp)
81145260:	e17ffe15 	stw	r5,-8(fp)
81145264:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81145268:	e13ffe17 	ldw	r4,-8(fp)
8114526c:	11449a00 	call	811449a0 <get_dir_divider_location>
81145270:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81145274:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81145278:	00800804 	movi	r2,32
8114527c:	e0bff905 	stb	r2,-28(fp)
81145280:	00800804 	movi	r2,32
81145284:	e0bff945 	stb	r2,-27(fp)
81145288:	00800804 	movi	r2,32
8114528c:	e0bff985 	stb	r2,-26(fp)
81145290:	00800804 	movi	r2,32
81145294:	e0bff9c5 	stb	r2,-25(fp)
81145298:	00800804 	movi	r2,32
8114529c:	e0bffa05 	stb	r2,-24(fp)
811452a0:	00800804 	movi	r2,32
811452a4:	e0bffa45 	stb	r2,-23(fp)
811452a8:	00800804 	movi	r2,32
811452ac:	e0bffa85 	stb	r2,-22(fp)
811452b0:	00800804 	movi	r2,32
811452b4:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
811452b8:	00800804 	movi	r2,32
811452bc:	e0bffb05 	stb	r2,-20(fp)
811452c0:	00800804 	movi	r2,32
811452c4:	e0bffb45 	stb	r2,-19(fp)
811452c8:	00800804 	movi	r2,32
811452cc:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
811452d0:	00bfffc4 	movi	r2,-1
811452d4:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
811452d8:	e0bffd17 	ldw	r2,-12(fp)
811452dc:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
811452e0:	e13ffe17 	ldw	r4,-8(fp)
811452e4:	11244bc0 	call	811244bc <strlen>
811452e8:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
811452ec:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
811452f0:	00000b06 	br	81145320 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
811452f4:	e0ffeb17 	ldw	r3,-84(fp)
811452f8:	e0bfea17 	ldw	r2,-88(fp)
811452fc:	1885883a 	add	r2,r3,r2
81145300:	10800044 	addi	r2,r2,1
81145304:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81145308:	e0bfeb17 	ldw	r2,-84(fp)
8114530c:	e0fffe17 	ldw	r3,-8(fp)
81145310:	1885883a 	add	r2,r3,r2
81145314:	1009883a 	mov	r4,r2
81145318:	11449a00 	call	811449a0 <get_dir_divider_location>
8114531c:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81145320:	e0bfea17 	ldw	r2,-88(fp)
81145324:	00bff316 	blt	zero,r2,811452f4 <__reset+0xfb1252f4>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81145328:	e0bfeb17 	ldw	r2,-84(fp)
8114532c:	e0bfee15 	stw	r2,-72(fp)
81145330:	00002706 	br	811453d0 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81145334:	e0bfee17 	ldw	r2,-72(fp)
81145338:	e0fffe17 	ldw	r3,-8(fp)
8114533c:	1885883a 	add	r2,r3,r2
81145340:	10800003 	ldbu	r2,0(r2)
81145344:	10803fcc 	andi	r2,r2,255
81145348:	1080201c 	xori	r2,r2,128
8114534c:	10bfe004 	addi	r2,r2,-128
81145350:	10800b98 	cmpnei	r2,r2,46
81145354:	1000031e 	bne	r2,zero,81145364 <find_file_in_directory+0x120>
        {
            ext_index = index;
81145358:	e0bfee17 	ldw	r2,-72(fp)
8114535c:	e0bfec15 	stw	r2,-80(fp)
81145360:	00001806 	br	811453c4 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81145364:	e0bfec17 	ldw	r2,-80(fp)
81145368:	10000b0e 	bge	r2,zero,81145398 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8114536c:	e0ffee17 	ldw	r3,-72(fp)
81145370:	e0bfeb17 	ldw	r2,-84(fp)
81145374:	1885c83a 	sub	r2,r3,r2
81145378:	e0ffee17 	ldw	r3,-72(fp)
8114537c:	e13ffe17 	ldw	r4,-8(fp)
81145380:	20c7883a 	add	r3,r4,r3
81145384:	18c00003 	ldbu	r3,0(r3)
81145388:	e13ff904 	addi	r4,fp,-28
8114538c:	2085883a 	add	r2,r4,r2
81145390:	10c00005 	stb	r3,0(r2)
81145394:	00000b06 	br	811453c4 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81145398:	e0ffee17 	ldw	r3,-72(fp)
8114539c:	e0bfec17 	ldw	r2,-80(fp)
811453a0:	1885c83a 	sub	r2,r3,r2
811453a4:	10bfffc4 	addi	r2,r2,-1
811453a8:	e0ffee17 	ldw	r3,-72(fp)
811453ac:	e13ffe17 	ldw	r4,-8(fp)
811453b0:	20c7883a 	add	r3,r4,r3
811453b4:	18c00003 	ldbu	r3,0(r3)
811453b8:	e13ffb04 	addi	r4,fp,-20
811453bc:	2085883a 	add	r2,r4,r2
811453c0:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
811453c4:	e0bfee17 	ldw	r2,-72(fp)
811453c8:	10800044 	addi	r2,r2,1
811453cc:	e0bfee15 	stw	r2,-72(fp)
811453d0:	e0ffee17 	ldw	r3,-72(fp)
811453d4:	e0bff417 	ldw	r2,-48(fp)
811453d8:	18bfd616 	blt	r3,r2,81145334 <__reset+0xfb125334>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
811453dc:	e0bffd17 	ldw	r2,-12(fp)
811453e0:	1000461e 	bne	r2,zero,811454fc <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811453e4:	00a045f4 	movhi	r2,33047
811453e8:	10b84c04 	addi	r2,r2,-7888
811453ec:	1080050b 	ldhu	r2,20(r2)
811453f0:	10bfffcc 	andi	r2,r2,65535
811453f4:	1006917a 	slli	r3,r2,5
811453f8:	00a045f4 	movhi	r2,33047
811453fc:	10b84c04 	addi	r2,r2,-7888
81145400:	1080030b 	ldhu	r2,12(r2)
81145404:	10bfffcc 	andi	r2,r2,65535
81145408:	1885283a 	div	r2,r3,r2
8114540c:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145410:	e03ff015 	stw	zero,-64(fp)
81145414:	00003506 	br	811454ec <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81145418:	00a045f4 	movhi	r2,33047
8114541c:	10b84c04 	addi	r2,r2,-7888
81145420:	10c01317 	ldw	r3,76(r2)
81145424:	e0bff017 	ldw	r2,-64(fp)
81145428:	1885883a 	add	r2,r3,r2
8114542c:	1007883a 	mov	r3,r2
81145430:	d0a0b117 	ldw	r2,-32060(gp)
81145434:	100b883a 	mov	r5,r2
81145438:	1809883a 	mov	r4,r3
8114543c:	114359c0 	call	8114359c <Read_Sector_Data>
81145440:	10009626 	beq	r2,zero,8114569c <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145444:	e03ff115 	stw	zero,-60(fp)
81145448:	00002006 	br	811454cc <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8114544c:	e0bff117 	ldw	r2,-60(fp)
81145450:	1004917a 	slli	r2,r2,5
81145454:	e0fff017 	ldw	r3,-64(fp)
81145458:	180f883a 	mov	r7,r3
8114545c:	000d883a 	mov	r6,zero
81145460:	e17fff17 	ldw	r5,-4(fp)
81145464:	1009883a 	mov	r4,r2
81145468:	11439cc0 	call	811439cc <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114546c:	e0bfff17 	ldw	r2,-4(fp)
81145470:	10800003 	ldbu	r2,0(r2)
81145474:	10803fcc 	andi	r2,r2,255
81145478:	10803960 	cmpeqi	r2,r2,229
8114547c:	1000101e 	bne	r2,zero,811454c0 <find_file_in_directory+0x27c>
81145480:	e0bfff17 	ldw	r2,-4(fp)
81145484:	10800003 	ldbu	r2,0(r2)
81145488:	10803fcc 	andi	r2,r2,255
8114548c:	10000c26 	beq	r2,zero,811454c0 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81145490:	e0fffb04 	addi	r3,fp,-20
81145494:	e0bff904 	addi	r2,fp,-28
81145498:	180d883a 	mov	r6,r3
8114549c:	100b883a 	mov	r5,r2
811454a0:	e13fff17 	ldw	r4,-4(fp)
811454a4:	1144a600 	call	81144a60 <match_file_record_to_name_ext>
811454a8:	e0bff815 	stw	r2,-32(fp)

                        if (match)
811454ac:	e0bff817 	ldw	r2,-32(fp)
811454b0:	10000326 	beq	r2,zero,811454c0 <find_file_in_directory+0x27c>
                        {
                            result = true;
811454b4:	00800044 	movi	r2,1
811454b8:	e0bfef15 	stw	r2,-68(fp)
                            break;
811454bc:	00000606 	br	811454d8 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811454c0:	e0bff117 	ldw	r2,-60(fp)
811454c4:	10800044 	addi	r2,r2,1
811454c8:	e0bff115 	stw	r2,-60(fp)
811454cc:	e0bff117 	ldw	r2,-60(fp)
811454d0:	10800410 	cmplti	r2,r2,16
811454d4:	103fdd1e 	bne	r2,zero,8114544c <__reset+0xfb12544c>
            }
            else
            {
                break;
            }
            if (result)
811454d8:	e0bfef17 	ldw	r2,-68(fp)
811454dc:	1000711e 	bne	r2,zero,811456a4 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811454e0:	e0bff017 	ldw	r2,-64(fp)
811454e4:	10800044 	addi	r2,r2,1
811454e8:	e0bff015 	stw	r2,-64(fp)
811454ec:	e0fff017 	ldw	r3,-64(fp)
811454f0:	e0bff717 	ldw	r2,-36(fp)
811454f4:	18bfc816 	blt	r3,r2,81145418 <__reset+0xfb125418>
811454f8:	00006b06 	br	811456a8 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811454fc:	e0bfed17 	ldw	r2,-76(fp)
81145500:	10ffff84 	addi	r3,r2,-2
81145504:	00a045f4 	movhi	r2,33047
81145508:	10b84c04 	addi	r2,r2,-7888
8114550c:	10800383 	ldbu	r2,14(r2)
81145510:	10803fcc 	andi	r2,r2,255
81145514:	1885383a 	mul	r2,r3,r2
81145518:	1007883a 	mov	r3,r2
8114551c:	00a045f4 	movhi	r2,33047
81145520:	10b84c04 	addi	r2,r2,-7888
81145524:	10801417 	ldw	r2,80(r2)
81145528:	1885883a 	add	r2,r3,r2
8114552c:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145530:	e03ff215 	stw	zero,-56(fp)
81145534:	00003306 	br	81145604 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81145538:	e0fff217 	ldw	r3,-56(fp)
8114553c:	e0bff517 	ldw	r2,-44(fp)
81145540:	1885883a 	add	r2,r3,r2
81145544:	d0e0b117 	ldw	r3,-32060(gp)
81145548:	180b883a 	mov	r5,r3
8114554c:	1009883a 	mov	r4,r2
81145550:	114359c0 	call	8114359c <Read_Sector_Data>
81145554:	10003226 	beq	r2,zero,81145620 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145558:	e03ff315 	stw	zero,-52(fp)
8114555c:	00002106 	br	811455e4 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81145560:	e0bff317 	ldw	r2,-52(fp)
81145564:	1004917a 	slli	r2,r2,5
81145568:	e0ffed17 	ldw	r3,-76(fp)
8114556c:	e13ff217 	ldw	r4,-56(fp)
81145570:	200f883a 	mov	r7,r4
81145574:	180d883a 	mov	r6,r3
81145578:	e17fff17 	ldw	r5,-4(fp)
8114557c:	1009883a 	mov	r4,r2
81145580:	11439cc0 	call	811439cc <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145584:	e0bfff17 	ldw	r2,-4(fp)
81145588:	10800003 	ldbu	r2,0(r2)
8114558c:	10803fcc 	andi	r2,r2,255
81145590:	10803960 	cmpeqi	r2,r2,229
81145594:	1000101e 	bne	r2,zero,811455d8 <find_file_in_directory+0x394>
81145598:	e0bfff17 	ldw	r2,-4(fp)
8114559c:	10800003 	ldbu	r2,0(r2)
811455a0:	10803fcc 	andi	r2,r2,255
811455a4:	10000c26 	beq	r2,zero,811455d8 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
811455a8:	e0fffb04 	addi	r3,fp,-20
811455ac:	e0bff904 	addi	r2,fp,-28
811455b0:	180d883a 	mov	r6,r3
811455b4:	100b883a 	mov	r5,r2
811455b8:	e13fff17 	ldw	r4,-4(fp)
811455bc:	1144a600 	call	81144a60 <match_file_record_to_name_ext>
811455c0:	e0bff615 	stw	r2,-40(fp)

                            if (match)
811455c4:	e0bff617 	ldw	r2,-40(fp)
811455c8:	10000326 	beq	r2,zero,811455d8 <find_file_in_directory+0x394>
                            {                               
                                result = true;
811455cc:	00800044 	movi	r2,1
811455d0:	e0bfef15 	stw	r2,-68(fp)
                                break;
811455d4:	00000606 	br	811455f0 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811455d8:	e0bff317 	ldw	r2,-52(fp)
811455dc:	10800044 	addi	r2,r2,1
811455e0:	e0bff315 	stw	r2,-52(fp)
811455e4:	e0bff317 	ldw	r2,-52(fp)
811455e8:	10800410 	cmplti	r2,r2,16
811455ec:	103fdc1e 	bne	r2,zero,81145560 <__reset+0xfb125560>
                }
                else
                {
                    break;
                }
                if (result)
811455f0:	e0bfef17 	ldw	r2,-68(fp)
811455f4:	10000c1e 	bne	r2,zero,81145628 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811455f8:	e0bff217 	ldw	r2,-56(fp)
811455fc:	10800044 	addi	r2,r2,1
81145600:	e0bff215 	stw	r2,-56(fp)
81145604:	00a045f4 	movhi	r2,33047
81145608:	10b84c04 	addi	r2,r2,-7888
8114560c:	10800383 	ldbu	r2,14(r2)
81145610:	10803fcc 	andi	r2,r2,255
81145614:	e0fff217 	ldw	r3,-56(fp)
81145618:	18bfc716 	blt	r3,r2,81145538 <__reset+0xfb125538>
8114561c:	00000306 	br	8114562c <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81145620:	0001883a 	nop
81145624:	00000106 	br	8114562c <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81145628:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8114562c:	e0bfef17 	ldw	r2,-68(fp)
81145630:	1000141e 	bne	r2,zero,81145684 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81145634:	e0bfed17 	ldw	r2,-76(fp)
81145638:	e0fffc04 	addi	r3,fp,-16
8114563c:	180b883a 	mov	r5,r3
81145640:	1009883a 	mov	r4,r2
81145644:	114367c0 	call	8114367c <get_cluster_flag>
81145648:	10000c26 	beq	r2,zero,8114567c <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8114564c:	e0bffc0b 	ldhu	r2,-16(fp)
81145650:	10bfffcc 	andi	r2,r2,65535
81145654:	10fffe0c 	andi	r3,r2,65528
81145658:	00bffe14 	movui	r2,65528
8114565c:	1880021e 	bne	r3,r2,81145668 <find_file_in_directory+0x424>
					{
						return false;
81145660:	0005883a 	mov	r2,zero
81145664:	00001106 	br	811456ac <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81145668:	e0bffc0b 	ldhu	r2,-16(fp)
8114566c:	10bfffcc 	andi	r2,r2,65535
81145670:	10bffe0c 	andi	r2,r2,65528
81145674:	e0bfed15 	stw	r2,-76(fp)
81145678:	00000206 	br	81145684 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8114567c:	0005883a 	mov	r2,zero
81145680:	00000a06 	br	811456ac <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81145684:	e0bfed17 	ldw	r2,-76(fp)
81145688:	00fffdd4 	movui	r3,65527
8114568c:	18800616 	blt	r3,r2,811456a8 <find_file_in_directory+0x464>
81145690:	e0bfef17 	ldw	r2,-68(fp)
81145694:	103f9926 	beq	r2,zero,811454fc <__reset+0xfb1254fc>
81145698:	00000306 	br	811456a8 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8114569c:	0001883a 	nop
811456a0:	00000106 	br	811456a8 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
811456a4:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
811456a8:	e0bfef17 	ldw	r2,-68(fp)
}
811456ac:	e037883a 	mov	sp,fp
811456b0:	dfc00117 	ldw	ra,4(sp)
811456b4:	df000017 	ldw	fp,0(sp)
811456b8:	dec00204 	addi	sp,sp,8
811456bc:	f800283a 	ret

811456c0 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
811456c0:	defff504 	addi	sp,sp,-44
811456c4:	de00012e 	bgeu	sp,et,811456cc <find_first_empty_cluster+0xc>
811456c8:	003b68fa 	trap	3
811456cc:	dfc00a15 	stw	ra,40(sp)
811456d0:	df000915 	stw	fp,36(sp)
811456d4:	df000904 	addi	fp,sp,36
811456d8:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
811456dc:	00a045f4 	movhi	r2,33047
811456e0:	10b84c04 	addi	r2,r2,-7888
811456e4:	10801117 	ldw	r2,68(r2)
811456e8:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
811456ec:	00800084 	movi	r2,2
811456f0:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
811456f4:	00bfffc4 	movi	r2,-1
811456f8:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
811456fc:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81145700:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
81145704:	00a045f4 	movhi	r2,33047
81145708:	10b84c04 	addi	r2,r2,-7888
8114570c:	10801417 	ldw	r2,80(r2)
81145710:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
81145714:	00a045f4 	movhi	r2,33047
81145718:	10b84c04 	addi	r2,r2,-7888
8114571c:	1080058b 	ldhu	r2,22(r2)
81145720:	10bfffcc 	andi	r2,r2,65535
81145724:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81145728:	00a045f4 	movhi	r2,33047
8114572c:	10b84c04 	addi	r2,r2,-7888
81145730:	10800917 	ldw	r2,36(r2)
81145734:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81145738:	e0bffd17 	ldw	r2,-12(fp)
8114573c:	e0fffe17 	ldw	r3,-8(fp)
81145740:	18800b2e 	bgeu	r3,r2,81145770 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81145744:	e0fffd17 	ldw	r3,-12(fp)
81145748:	e0bffc17 	ldw	r2,-16(fp)
8114574c:	1887c83a 	sub	r3,r3,r2
81145750:	00a045f4 	movhi	r2,33047
81145754:	10b84c04 	addi	r2,r2,-7888
81145758:	10800383 	ldbu	r2,14(r2)
8114575c:	10803fcc 	andi	r2,r2,255
81145760:	1885203a 	divu	r2,r3,r2
81145764:	10800044 	addi	r2,r2,1
81145768:	e0bffb15 	stw	r2,-20(fp)
8114576c:	00002a06 	br	81145818 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81145770:	e0fffe17 	ldw	r3,-8(fp)
81145774:	e0bffc17 	ldw	r2,-16(fp)
81145778:	1887c83a 	sub	r3,r3,r2
8114577c:	00a045f4 	movhi	r2,33047
81145780:	10b84c04 	addi	r2,r2,-7888
81145784:	10800383 	ldbu	r2,14(r2)
81145788:	10803fcc 	andi	r2,r2,255
8114578c:	1885203a 	divu	r2,r3,r2
81145790:	10800044 	addi	r2,r2,1
81145794:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81145798:	00001f06 	br	81145818 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8114579c:	e0bff717 	ldw	r2,-36(fp)
811457a0:	d0e0b117 	ldw	r3,-32060(gp)
811457a4:	180b883a 	mov	r5,r3
811457a8:	1009883a 	mov	r4,r2
811457ac:	114359c0 	call	8114359c <Read_Sector_Data>
811457b0:	10001426 	beq	r2,zero,81145804 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
811457b4:	e0bff817 	ldw	r2,-32(fp)
811457b8:	10803fcc 	andi	r2,r2,255
811457bc:	1085883a 	add	r2,r2,r2
811457c0:	1007883a 	mov	r3,r2
811457c4:	d0a0b317 	ldw	r2,-32052(gp)
811457c8:	10800a17 	ldw	r2,40(r2)
811457cc:	1885883a 	add	r2,r3,r2
811457d0:	1080002b 	ldhuio	r2,0(r2)
811457d4:	10bfffcc 	andi	r2,r2,65535
811457d8:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
811457dc:	e0bff90f 	ldh	r2,-28(fp)
811457e0:	10000726 	beq	r2,zero,81145800 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
811457e4:	e0bff817 	ldw	r2,-32(fp)
811457e8:	10800044 	addi	r2,r2,1
811457ec:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
811457f0:	e0bff817 	ldw	r2,-32(fp)
811457f4:	10803fcc 	andi	r2,r2,255
811457f8:	103fee1e 	bne	r2,zero,811457b4 <__reset+0xfb1257b4>
811457fc:	00000106 	br	81145804 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81145800:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
81145804:	e0bff90f 	ldh	r2,-28(fp)
81145808:	10000926 	beq	r2,zero,81145830 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8114580c:	e0bff717 	ldw	r2,-36(fp)
81145810:	10800044 	addi	r2,r2,1
81145814:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81145818:	00a045f4 	movhi	r2,33047
8114581c:	10b84c04 	addi	r2,r2,-7888
81145820:	10c01217 	ldw	r3,72(r2)
81145824:	e0bff717 	ldw	r2,-36(fp)
81145828:	18bfdc1e 	bne	r3,r2,8114579c <__reset+0xfb12579c>
8114582c:	00000106 	br	81145834 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81145830:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
81145834:	e0bff90f 	ldh	r2,-28(fp)
81145838:	1000081e 	bne	r2,zero,8114585c <find_first_empty_cluster+0x19c>
8114583c:	e0bff90f 	ldh	r2,-28(fp)
81145840:	e0fffb17 	ldw	r3,-20(fp)
81145844:	18800536 	bltu	r3,r2,8114585c <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81145848:	e0bfff17 	ldw	r2,-4(fp)
8114584c:	e0fff817 	ldw	r3,-32(fp)
81145850:	10c00015 	stw	r3,0(r2)
		result = true;
81145854:	00800044 	movi	r2,1
81145858:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8114585c:	e0bffa17 	ldw	r2,-24(fp)
}
81145860:	e037883a 	mov	sp,fp
81145864:	dfc00117 	ldw	ra,4(sp)
81145868:	df000017 	ldw	fp,0(sp)
8114586c:	dec00204 	addi	sp,sp,8
81145870:	f800283a 	ret

81145874 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81145874:	defff604 	addi	sp,sp,-40
81145878:	de00012e 	bgeu	sp,et,81145880 <find_first_empty_record_in_a_subdirectory+0xc>
8114587c:	003b68fa 	trap	3
81145880:	dfc00915 	stw	ra,36(sp)
81145884:	df000815 	stw	fp,32(sp)
81145888:	df000804 	addi	fp,sp,32
8114588c:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81145890:	00bfffc4 	movi	r2,-1
81145894:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81145898:	e0bfff17 	ldw	r2,-4(fp)
8114589c:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811458a0:	e0bff917 	ldw	r2,-28(fp)
811458a4:	10ffff84 	addi	r3,r2,-2
811458a8:	00a045f4 	movhi	r2,33047
811458ac:	10b84c04 	addi	r2,r2,-7888
811458b0:	10800383 	ldbu	r2,14(r2)
811458b4:	10803fcc 	andi	r2,r2,255
811458b8:	1885383a 	mul	r2,r3,r2
811458bc:	1007883a 	mov	r3,r2
811458c0:	00a045f4 	movhi	r2,33047
811458c4:	10b84c04 	addi	r2,r2,-7888
811458c8:	10801417 	ldw	r2,80(r2)
811458cc:	1885883a 	add	r2,r3,r2
811458d0:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811458d4:	e03ffa15 	stw	zero,-24(fp)
811458d8:	00002c06 	br	8114598c <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811458dc:	e0fffa17 	ldw	r3,-24(fp)
811458e0:	e0bffc17 	ldw	r2,-16(fp)
811458e4:	1885883a 	add	r2,r3,r2
811458e8:	d0e0b117 	ldw	r3,-32060(gp)
811458ec:	180b883a 	mov	r5,r3
811458f0:	1009883a 	mov	r4,r2
811458f4:	114359c0 	call	8114359c <Read_Sector_Data>
811458f8:	10002b26 	beq	r2,zero,811459a8 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811458fc:	e03ffb15 	stw	zero,-20(fp)
81145900:	00001c06 	br	81145974 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81145904:	e0bffb17 	ldw	r2,-20(fp)
81145908:	1004917a 	slli	r2,r2,5
8114590c:	1007883a 	mov	r3,r2
81145910:	d0a0b317 	ldw	r2,-32052(gp)
81145914:	10800a17 	ldw	r2,40(r2)
81145918:	1885883a 	add	r2,r3,r2
8114591c:	10800023 	ldbuio	r2,0(r2)
81145920:	10803fcc 	andi	r2,r2,255
81145924:	10803fcc 	andi	r2,r2,255
81145928:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8114592c:	e0bffd0b 	ldhu	r2,-12(fp)
81145930:	10803960 	cmpeqi	r2,r2,229
81145934:	1000021e 	bne	r2,zero,81145940 <find_first_empty_record_in_a_subdirectory+0xcc>
81145938:	e0bffd0b 	ldhu	r2,-12(fp)
8114593c:	10000a1e 	bne	r2,zero,81145968 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81145940:	e0bffa17 	ldw	r2,-24(fp)
81145944:	1006913a 	slli	r3,r2,4
81145948:	e0bffb17 	ldw	r2,-20(fp)
8114594c:	1885883a 	add	r2,r3,r2
81145950:	1006943a 	slli	r3,r2,16
81145954:	e0bff917 	ldw	r2,-28(fp)
81145958:	1884b03a 	or	r2,r3,r2
8114595c:	e0bff815 	stw	r2,-32(fp)
                        return result;
81145960:	e0bff817 	ldw	r2,-32(fp)
81145964:	00005306 	br	81145ab4 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145968:	e0bffb17 	ldw	r2,-20(fp)
8114596c:	10800044 	addi	r2,r2,1
81145970:	e0bffb15 	stw	r2,-20(fp)
81145974:	e0bffb17 	ldw	r2,-20(fp)
81145978:	10800410 	cmplti	r2,r2,16
8114597c:	103fe11e 	bne	r2,zero,81145904 <__reset+0xfb125904>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145980:	e0bffa17 	ldw	r2,-24(fp)
81145984:	10800044 	addi	r2,r2,1
81145988:	e0bffa15 	stw	r2,-24(fp)
8114598c:	00a045f4 	movhi	r2,33047
81145990:	10b84c04 	addi	r2,r2,-7888
81145994:	10800383 	ldbu	r2,14(r2)
81145998:	10803fcc 	andi	r2,r2,255
8114599c:	e0fffa17 	ldw	r3,-24(fp)
811459a0:	18bfce16 	blt	r3,r2,811458dc <__reset+0xfb1258dc>
811459a4:	00000106 	br	811459ac <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
811459a8:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
811459ac:	e0bff817 	ldw	r2,-32(fp)
811459b0:	1000390e 	bge	r2,zero,81145a98 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
811459b4:	e0bff917 	ldw	r2,-28(fp)
811459b8:	e0fffd84 	addi	r3,fp,-10
811459bc:	180b883a 	mov	r5,r3
811459c0:	1009883a 	mov	r4,r2
811459c4:	114367c0 	call	8114367c <get_cluster_flag>
811459c8:	10003126 	beq	r2,zero,81145a90 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811459cc:	e0bffd8b 	ldhu	r2,-10(fp)
811459d0:	10bfffcc 	andi	r2,r2,65535
811459d4:	10fffe0c 	andi	r3,r2,65528
811459d8:	00bffe14 	movui	r2,65528
811459dc:	18802e1e 	bne	r3,r2,81145a98 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
811459e0:	e0bffe04 	addi	r2,fp,-8
811459e4:	1009883a 	mov	r4,r2
811459e8:	11456c00 	call	811456c0 <find_first_empty_cluster>
811459ec:	10002326 	beq	r2,zero,81145a7c <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811459f0:	e0bff917 	ldw	r2,-28(fp)
811459f4:	e0fffe17 	ldw	r3,-8(fp)
811459f8:	18ffffcc 	andi	r3,r3,65535
811459fc:	18e0001c 	xori	r3,r3,32768
81145a00:	18e00004 	addi	r3,r3,-32768
81145a04:	01800044 	movi	r6,1
81145a08:	180b883a 	mov	r5,r3
81145a0c:	1009883a 	mov	r4,r2
81145a10:	11437380 	call	81143738 <mark_cluster>
81145a14:	10001926 	beq	r2,zero,81145a7c <find_first_empty_record_in_a_subdirectory+0x208>
81145a18:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81145a1c:	01800044 	movi	r6,1
81145a20:	017fffc4 	movi	r5,-1
81145a24:	1009883a 	mov	r4,r2
81145a28:	11437380 	call	81143738 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81145a2c:	10001326 	beq	r2,zero,81145a7c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81145a30:	e0bff917 	ldw	r2,-28(fp)
81145a34:	e0fffe17 	ldw	r3,-8(fp)
81145a38:	18ffffcc 	andi	r3,r3,65535
81145a3c:	18e0001c 	xori	r3,r3,32768
81145a40:	18e00004 	addi	r3,r3,-32768
81145a44:	000d883a 	mov	r6,zero
81145a48:	180b883a 	mov	r5,r3
81145a4c:	1009883a 	mov	r4,r2
81145a50:	11437380 	call	81143738 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81145a54:	10000926 	beq	r2,zero,81145a7c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81145a58:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81145a5c:	000d883a 	mov	r6,zero
81145a60:	017fffc4 	movi	r5,-1
81145a64:	1009883a 	mov	r4,r2
81145a68:	11437380 	call	81143738 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81145a6c:	10000326 	beq	r2,zero,81145a7c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81145a70:	11435480 	call	81143548 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81145a74:	e0bffe17 	ldw	r2,-8(fp)
81145a78:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81145a7c:	e0bffd8b 	ldhu	r2,-10(fp)
81145a80:	10bfffcc 	andi	r2,r2,65535
81145a84:	10bffe0c 	andi	r2,r2,65528
81145a88:	e0bff915 	stw	r2,-28(fp)
81145a8c:	00000206 	br	81145a98 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81145a90:	00bfffc4 	movi	r2,-1
81145a94:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81145a98:	e0bff917 	ldw	r2,-28(fp)
81145a9c:	00fffdd4 	movui	r3,65527
81145aa0:	18800316 	blt	r3,r2,81145ab0 <find_first_empty_record_in_a_subdirectory+0x23c>
81145aa4:	e0bff817 	ldw	r2,-32(fp)
81145aa8:	10bfffe0 	cmpeqi	r2,r2,-1
81145aac:	103f7c1e 	bne	r2,zero,811458a0 <__reset+0xfb1258a0>
    return result; 
81145ab0:	e0bff817 	ldw	r2,-32(fp)
}
81145ab4:	e037883a 	mov	sp,fp
81145ab8:	dfc00117 	ldw	ra,4(sp)
81145abc:	df000017 	ldw	fp,0(sp)
81145ac0:	dec00204 	addi	sp,sp,8
81145ac4:	f800283a 	ret

81145ac8 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81145ac8:	defff904 	addi	sp,sp,-28
81145acc:	de00012e 	bgeu	sp,et,81145ad4 <find_first_empty_record_in_root_directory+0xc>
81145ad0:	003b68fa 	trap	3
81145ad4:	dfc00615 	stw	ra,24(sp)
81145ad8:	df000515 	stw	fp,20(sp)
81145adc:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81145ae0:	00a045f4 	movhi	r2,33047
81145ae4:	10b84c04 	addi	r2,r2,-7888
81145ae8:	1080050b 	ldhu	r2,20(r2)
81145aec:	10bfffcc 	andi	r2,r2,65535
81145af0:	1006917a 	slli	r3,r2,5
81145af4:	00a045f4 	movhi	r2,33047
81145af8:	10b84c04 	addi	r2,r2,-7888
81145afc:	1080030b 	ldhu	r2,12(r2)
81145b00:	10bfffcc 	andi	r2,r2,65535
81145b04:	1885283a 	div	r2,r3,r2
81145b08:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81145b0c:	00bfffc4 	movi	r2,-1
81145b10:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145b14:	e03ffb15 	stw	zero,-20(fp)
81145b18:	00002d06 	br	81145bd0 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81145b1c:	00a045f4 	movhi	r2,33047
81145b20:	10b84c04 	addi	r2,r2,-7888
81145b24:	10c01317 	ldw	r3,76(r2)
81145b28:	e0bffb17 	ldw	r2,-20(fp)
81145b2c:	1885883a 	add	r2,r3,r2
81145b30:	1007883a 	mov	r3,r2
81145b34:	d0a0b117 	ldw	r2,-32060(gp)
81145b38:	100b883a 	mov	r5,r2
81145b3c:	1809883a 	mov	r4,r3
81145b40:	114359c0 	call	8114359c <Read_Sector_Data>
81145b44:	10002626 	beq	r2,zero,81145be0 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81145b48:	e03ffc15 	stw	zero,-16(fp)
81145b4c:	00001a06 	br	81145bb8 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81145b50:	e0bffc17 	ldw	r2,-16(fp)
81145b54:	1004917a 	slli	r2,r2,5
81145b58:	1007883a 	mov	r3,r2
81145b5c:	d0a0b317 	ldw	r2,-32052(gp)
81145b60:	10800a17 	ldw	r2,40(r2)
81145b64:	1885883a 	add	r2,r3,r2
81145b68:	10800023 	ldbuio	r2,0(r2)
81145b6c:	10803fcc 	andi	r2,r2,255
81145b70:	10803fcc 	andi	r2,r2,255
81145b74:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81145b78:	e0bfff0b 	ldhu	r2,-4(fp)
81145b7c:	10803960 	cmpeqi	r2,r2,229
81145b80:	1000021e 	bne	r2,zero,81145b8c <find_first_empty_record_in_root_directory+0xc4>
81145b84:	e0bfff0b 	ldhu	r2,-4(fp)
81145b88:	1000081e 	bne	r2,zero,81145bac <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81145b8c:	e0bffb17 	ldw	r2,-20(fp)
81145b90:	1006913a 	slli	r3,r2,4
81145b94:	e0bffc17 	ldw	r2,-16(fp)
81145b98:	1885883a 	add	r2,r3,r2
81145b9c:	1004943a 	slli	r2,r2,16
81145ba0:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81145ba4:	e0bffe17 	ldw	r2,-8(fp)
81145ba8:	00000f06 	br	81145be8 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81145bac:	e0bffc17 	ldw	r2,-16(fp)
81145bb0:	10800044 	addi	r2,r2,1
81145bb4:	e0bffc15 	stw	r2,-16(fp)
81145bb8:	e0bffc17 	ldw	r2,-16(fp)
81145bbc:	10800410 	cmplti	r2,r2,16
81145bc0:	103fe31e 	bne	r2,zero,81145b50 <__reset+0xfb125b50>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145bc4:	e0bffb17 	ldw	r2,-20(fp)
81145bc8:	10800044 	addi	r2,r2,1
81145bcc:	e0bffb15 	stw	r2,-20(fp)
81145bd0:	e0fffb17 	ldw	r3,-20(fp)
81145bd4:	e0bffd17 	ldw	r2,-12(fp)
81145bd8:	18bfd016 	blt	r3,r2,81145b1c <__reset+0xfb125b1c>
81145bdc:	00000106 	br	81145be4 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81145be0:	0001883a 	nop
        }
    }
    return result;
81145be4:	e0bffe17 	ldw	r2,-8(fp)
}
81145be8:	e037883a 	mov	sp,fp
81145bec:	dfc00117 	ldw	ra,4(sp)
81145bf0:	df000017 	ldw	fp,0(sp)
81145bf4:	dec00204 	addi	sp,sp,8
81145bf8:	f800283a 	ret

81145bfc <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81145bfc:	defffa04 	addi	sp,sp,-24
81145c00:	de00012e 	bgeu	sp,et,81145c08 <convert_filename_to_name_extension+0xc>
81145c04:	003b68fa 	trap	3
81145c08:	df000515 	stw	fp,20(sp)
81145c0c:	df000504 	addi	fp,sp,20
81145c10:	e13ffd15 	stw	r4,-12(fp)
81145c14:	e17ffe15 	stw	r5,-8(fp)
81145c18:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81145c1c:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81145c20:	e03ffb15 	stw	zero,-20(fp)
81145c24:	00002506 	br	81145cbc <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
81145c28:	e0bffc17 	ldw	r2,-16(fp)
81145c2c:	e0fffd17 	ldw	r3,-12(fp)
81145c30:	1885883a 	add	r2,r3,r2
81145c34:	10800003 	ldbu	r2,0(r2)
81145c38:	10803fcc 	andi	r2,r2,255
81145c3c:	1080201c 	xori	r2,r2,128
81145c40:	10bfe004 	addi	r2,r2,-128
81145c44:	10800ba0 	cmpeqi	r2,r2,46
81145c48:	1000141e 	bne	r2,zero,81145c9c <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81145c4c:	e0bffb17 	ldw	r2,-20(fp)
81145c50:	e0fffe17 	ldw	r3,-8(fp)
81145c54:	1885883a 	add	r2,r3,r2
81145c58:	e0fffc17 	ldw	r3,-16(fp)
81145c5c:	e13ffd17 	ldw	r4,-12(fp)
81145c60:	20c7883a 	add	r3,r4,r3
81145c64:	18c00003 	ldbu	r3,0(r3)
81145c68:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81145c6c:	e0bffc17 	ldw	r2,-16(fp)
81145c70:	e0fffd17 	ldw	r3,-12(fp)
81145c74:	1885883a 	add	r2,r3,r2
81145c78:	10800003 	ldbu	r2,0(r2)
81145c7c:	10803fcc 	andi	r2,r2,255
81145c80:	1080201c 	xori	r2,r2,128
81145c84:	10bfe004 	addi	r2,r2,-128
81145c88:	10000926 	beq	r2,zero,81145cb0 <convert_filename_to_name_extension+0xb4>
81145c8c:	e0bffc17 	ldw	r2,-16(fp)
81145c90:	10800044 	addi	r2,r2,1
81145c94:	e0bffc15 	stw	r2,-16(fp)
81145c98:	00000506 	br	81145cb0 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81145c9c:	e0bffb17 	ldw	r2,-20(fp)
81145ca0:	e0fffe17 	ldw	r3,-8(fp)
81145ca4:	1885883a 	add	r2,r3,r2
81145ca8:	00c00804 	movi	r3,32
81145cac:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81145cb0:	e0bffb17 	ldw	r2,-20(fp)
81145cb4:	10800044 	addi	r2,r2,1
81145cb8:	e0bffb15 	stw	r2,-20(fp)
81145cbc:	e0bffb17 	ldw	r2,-20(fp)
81145cc0:	10800210 	cmplti	r2,r2,8
81145cc4:	103fd81e 	bne	r2,zero,81145c28 <__reset+0xfb125c28>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81145cc8:	e0bffc17 	ldw	r2,-16(fp)
81145ccc:	e0fffd17 	ldw	r3,-12(fp)
81145cd0:	1885883a 	add	r2,r3,r2
81145cd4:	10800003 	ldbu	r2,0(r2)
81145cd8:	10803fcc 	andi	r2,r2,255
81145cdc:	1080201c 	xori	r2,r2,128
81145ce0:	10bfe004 	addi	r2,r2,-128
81145ce4:	10800b98 	cmpnei	r2,r2,46
81145ce8:	1000031e 	bne	r2,zero,81145cf8 <convert_filename_to_name_extension+0xfc>
81145cec:	e0bffc17 	ldw	r2,-16(fp)
81145cf0:	10800044 	addi	r2,r2,1
81145cf4:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81145cf8:	e03ffb15 	stw	zero,-20(fp)
81145cfc:	00001c06 	br	81145d70 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81145d00:	e0bffc17 	ldw	r2,-16(fp)
81145d04:	e0fffd17 	ldw	r3,-12(fp)
81145d08:	1885883a 	add	r2,r3,r2
81145d0c:	10800003 	ldbu	r2,0(r2)
81145d10:	10803fcc 	andi	r2,r2,255
81145d14:	1080201c 	xori	r2,r2,128
81145d18:	10bfe004 	addi	r2,r2,-128
81145d1c:	10000c26 	beq	r2,zero,81145d50 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81145d20:	e0bffb17 	ldw	r2,-20(fp)
81145d24:	e0ffff17 	ldw	r3,-4(fp)
81145d28:	1885883a 	add	r2,r3,r2
81145d2c:	e0fffc17 	ldw	r3,-16(fp)
81145d30:	e13ffd17 	ldw	r4,-12(fp)
81145d34:	20c7883a 	add	r3,r4,r3
81145d38:	18c00003 	ldbu	r3,0(r3)
81145d3c:	10c00005 	stb	r3,0(r2)
            local++;
81145d40:	e0bffc17 	ldw	r2,-16(fp)
81145d44:	10800044 	addi	r2,r2,1
81145d48:	e0bffc15 	stw	r2,-16(fp)
81145d4c:	00000506 	br	81145d64 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81145d50:	e0bffb17 	ldw	r2,-20(fp)
81145d54:	e0ffff17 	ldw	r3,-4(fp)
81145d58:	1885883a 	add	r2,r3,r2
81145d5c:	00c00804 	movi	r3,32
81145d60:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81145d64:	e0bffb17 	ldw	r2,-20(fp)
81145d68:	10800044 	addi	r2,r2,1
81145d6c:	e0bffb15 	stw	r2,-20(fp)
81145d70:	e0bffb17 	ldw	r2,-20(fp)
81145d74:	108000d0 	cmplti	r2,r2,3
81145d78:	103fe11e 	bne	r2,zero,81145d00 <__reset+0xfb125d00>
        {
            extension[counter] = ' ';
        }
    }

}
81145d7c:	0001883a 	nop
81145d80:	e037883a 	mov	sp,fp
81145d84:	df000017 	ldw	fp,0(sp)
81145d88:	dec00104 	addi	sp,sp,4
81145d8c:	f800283a 	ret

81145d90 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81145d90:	defff504 	addi	sp,sp,-44
81145d94:	de00012e 	bgeu	sp,et,81145d9c <create_file+0xc>
81145d98:	003b68fa 	trap	3
81145d9c:	dfc00a15 	stw	ra,40(sp)
81145da0:	df000915 	stw	fp,36(sp)
81145da4:	df000904 	addi	fp,sp,36
81145da8:	e13ffd15 	stw	r4,-12(fp)
81145dac:	e17ffe15 	stw	r5,-8(fp)
81145db0:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81145db4:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81145db8:	e0bffc04 	addi	r2,fp,-16
81145dbc:	1009883a 	mov	r4,r2
81145dc0:	11456c00 	call	811456c0 <find_first_empty_cluster>
81145dc4:	1000a026 	beq	r2,zero,81146048 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81145dc8:	e0bfff17 	ldw	r2,-4(fp)
81145dcc:	10800a17 	ldw	r2,40(r2)
81145dd0:	1000031e 	bne	r2,zero,81145de0 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81145dd4:	1145ac80 	call	81145ac8 <find_first_empty_record_in_root_directory>
81145dd8:	e0bff815 	stw	r2,-32(fp)
81145ddc:	00000606 	br	81145df8 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81145de0:	e0bfff17 	ldw	r2,-4(fp)
81145de4:	1080058b 	ldhu	r2,22(r2)
81145de8:	10bfffcc 	andi	r2,r2,65535
81145dec:	1009883a 	mov	r4,r2
81145df0:	11458740 	call	81145874 <find_first_empty_record_in_a_subdirectory>
81145df4:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81145df8:	e0bff817 	ldw	r2,-32(fp)
81145dfc:	10009216 	blt	r2,zero,81146048 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81145e00:	e13ffd17 	ldw	r4,-12(fp)
81145e04:	11449a00 	call	811449a0 <get_dir_divider_location>
81145e08:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81145e0c:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81145e10:	00000b06 	br	81145e40 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81145e14:	e0fffa17 	ldw	r3,-24(fp)
81145e18:	e0bff917 	ldw	r2,-28(fp)
81145e1c:	1885883a 	add	r2,r3,r2
81145e20:	10800044 	addi	r2,r2,1
81145e24:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81145e28:	e0bffa17 	ldw	r2,-24(fp)
81145e2c:	e0fffd17 	ldw	r3,-12(fp)
81145e30:	1885883a 	add	r2,r3,r2
81145e34:	1009883a 	mov	r4,r2
81145e38:	11449a00 	call	811449a0 <get_dir_divider_location>
81145e3c:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81145e40:	e0bff917 	ldw	r2,-28(fp)
81145e44:	00bff316 	blt	zero,r2,81145e14 <__reset+0xfb125e14>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81145e48:	e0bffa17 	ldw	r2,-24(fp)
81145e4c:	e0fffd17 	ldw	r3,-12(fp)
81145e50:	1887883a 	add	r3,r3,r2
81145e54:	e13ffe17 	ldw	r4,-8(fp)
81145e58:	e0bffe17 	ldw	r2,-8(fp)
81145e5c:	10800204 	addi	r2,r2,8
81145e60:	100d883a 	mov	r6,r2
81145e64:	200b883a 	mov	r5,r4
81145e68:	1809883a 	mov	r4,r3
81145e6c:	1145bfc0 	call	81145bfc <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81145e70:	e0bffe17 	ldw	r2,-8(fp)
81145e74:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81145e78:	e0bffe17 	ldw	r2,-8(fp)
81145e7c:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81145e80:	e0bffe17 	ldw	r2,-8(fp)
81145e84:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81145e88:	e0bffe17 	ldw	r2,-8(fp)
81145e8c:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81145e90:	e0bffe17 	ldw	r2,-8(fp)
81145e94:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81145e98:	e0bffe17 	ldw	r2,-8(fp)
81145e9c:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81145ea0:	e0bffc17 	ldw	r2,-16(fp)
81145ea4:	1007883a 	mov	r3,r2
81145ea8:	e0bffe17 	ldw	r2,-8(fp)
81145eac:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81145eb0:	e0bffe17 	ldw	r2,-8(fp)
81145eb4:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81145eb8:	e0fffc17 	ldw	r3,-16(fp)
81145ebc:	e0bffe17 	ldw	r2,-8(fp)
81145ec0:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81145ec4:	e0bffe17 	ldw	r2,-8(fp)
81145ec8:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81145ecc:	e0bffe17 	ldw	r2,-8(fp)
81145ed0:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81145ed4:	e0bff817 	ldw	r2,-32(fp)
81145ed8:	10ffffcc 	andi	r3,r2,65535
81145edc:	e0bffe17 	ldw	r2,-8(fp)
81145ee0:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81145ee4:	e0bff817 	ldw	r2,-32(fp)
81145ee8:	1004d43a 	srli	r2,r2,16
81145eec:	1000010e 	bge	r2,zero,81145ef4 <create_file+0x164>
81145ef0:	108003c4 	addi	r2,r2,15
81145ef4:	1005d13a 	srai	r2,r2,4
81145ef8:	1007883a 	mov	r3,r2
81145efc:	e0bffe17 	ldw	r2,-8(fp)
81145f00:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81145f04:	e0bff817 	ldw	r2,-32(fp)
81145f08:	1004d43a 	srli	r2,r2,16
81145f0c:	1007883a 	mov	r3,r2
81145f10:	00a00034 	movhi	r2,32768
81145f14:	108003c4 	addi	r2,r2,15
81145f18:	1884703a 	and	r2,r3,r2
81145f1c:	1000040e 	bge	r2,zero,81145f30 <create_file+0x1a0>
81145f20:	10bfffc4 	addi	r2,r2,-1
81145f24:	00fffc04 	movi	r3,-16
81145f28:	10c4b03a 	or	r2,r2,r3
81145f2c:	10800044 	addi	r2,r2,1
81145f30:	1004917a 	slli	r2,r2,5
81145f34:	1007883a 	mov	r3,r2
81145f38:	e0bffe17 	ldw	r2,-8(fp)
81145f3c:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81145f40:	e0bfff17 	ldw	r2,-4(fp)
81145f44:	1080058b 	ldhu	r2,22(r2)
81145f48:	10ffffcc 	andi	r3,r2,65535
81145f4c:	e0bffe17 	ldw	r2,-8(fp)
81145f50:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81145f54:	e0bffe17 	ldw	r2,-8(fp)
81145f58:	00c00044 	movi	r3,1
81145f5c:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81145f60:	e0bffe17 	ldw	r2,-8(fp)
81145f64:	00c00044 	movi	r3,1
81145f68:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81145f6c:	e0bffe17 	ldw	r2,-8(fp)
81145f70:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81145f74:	1000071e 	bne	r2,zero,81145f94 <create_file+0x204>
81145f78:	00a045f4 	movhi	r2,33047
81145f7c:	10b84c04 	addi	r2,r2,-7888
81145f80:	10c01317 	ldw	r3,76(r2)
81145f84:	e0bffe17 	ldw	r2,-8(fp)
81145f88:	10800b17 	ldw	r2,44(r2)
81145f8c:	1885883a 	add	r2,r3,r2
81145f90:	00000f06 	br	81145fd0 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81145f94:	00a045f4 	movhi	r2,33047
81145f98:	10b84c04 	addi	r2,r2,-7888
81145f9c:	10c01417 	ldw	r3,80(r2)
81145fa0:	e0bffe17 	ldw	r2,-8(fp)
81145fa4:	10800a17 	ldw	r2,40(r2)
81145fa8:	113fff84 	addi	r4,r2,-2
81145fac:	00a045f4 	movhi	r2,33047
81145fb0:	10b84c04 	addi	r2,r2,-7888
81145fb4:	10800383 	ldbu	r2,14(r2)
81145fb8:	10803fcc 	andi	r2,r2,255
81145fbc:	2085383a 	mul	r2,r4,r2
81145fc0:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81145fc4:	e0bffe17 	ldw	r2,-8(fp)
81145fc8:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81145fcc:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81145fd0:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81145fd4:	e0bffb17 	ldw	r2,-20(fp)
81145fd8:	d0e0b117 	ldw	r3,-32060(gp)
81145fdc:	180b883a 	mov	r5,r3
81145fe0:	1009883a 	mov	r4,r2
81145fe4:	114359c0 	call	8114359c <Read_Sector_Data>
81145fe8:	10001726 	beq	r2,zero,81146048 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81145fec:	e0bffe17 	ldw	r2,-8(fp)
81145ff0:	10800c0b 	ldhu	r2,48(r2)
81145ff4:	10bfffcc 	andi	r2,r2,65535
81145ff8:	10a0001c 	xori	r2,r2,32768
81145ffc:	10a00004 	addi	r2,r2,-32768
81146000:	e17ffe17 	ldw	r5,-8(fp)
81146004:	1009883a 	mov	r4,r2
81146008:	1143c500 	call	81143c50 <Write_File_Record_At_Offset>
8114600c:	10000e26 	beq	r2,zero,81146048 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81146010:	11435480 	call	81143548 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81146014:	e0bffc17 	ldw	r2,-16(fp)
81146018:	01800044 	movi	r6,1
8114601c:	017fffc4 	movi	r5,-1
81146020:	1009883a 	mov	r4,r2
81146024:	11437380 	call	81143738 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81146028:	e0bffc17 	ldw	r2,-16(fp)
8114602c:	000d883a 	mov	r6,zero
81146030:	017fffc4 	movi	r5,-1
81146034:	1009883a 	mov	r4,r2
81146038:	11437380 	call	81143738 <mark_cluster>
8114603c:	10000226 	beq	r2,zero,81146048 <create_file+0x2b8>
                    {
                        result = true;
81146040:	00800044 	movi	r2,1
81146044:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81146048:	e0bff717 	ldw	r2,-36(fp)
}
8114604c:	e037883a 	mov	sp,fp
81146050:	dfc00117 	ldw	ra,4(sp)
81146054:	df000017 	ldw	fp,0(sp)
81146058:	dec00204 	addi	sp,sp,8
8114605c:	f800283a 	ret

81146060 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81146060:	defffb04 	addi	sp,sp,-20
81146064:	de00012e 	bgeu	sp,et,8114606c <copy_file_record_name_to_string+0xc>
81146068:	003b68fa 	trap	3
8114606c:	df000415 	stw	fp,16(sp)
81146070:	df000404 	addi	fp,sp,16
81146074:	e13ffe15 	stw	r4,-8(fp)
81146078:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
8114607c:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81146080:	e03ffc15 	stw	zero,-16(fp)
81146084:	00001506 	br	811460dc <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81146088:	e0fffe17 	ldw	r3,-8(fp)
8114608c:	e0bffc17 	ldw	r2,-16(fp)
81146090:	1885883a 	add	r2,r3,r2
81146094:	10800003 	ldbu	r2,0(r2)
81146098:	10803fcc 	andi	r2,r2,255
8114609c:	10800820 	cmpeqi	r2,r2,32
811460a0:	10000b1e 	bne	r2,zero,811460d0 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
811460a4:	e0bffd17 	ldw	r2,-12(fp)
811460a8:	e0ffff17 	ldw	r3,-4(fp)
811460ac:	1885883a 	add	r2,r3,r2
811460b0:	e13ffe17 	ldw	r4,-8(fp)
811460b4:	e0fffc17 	ldw	r3,-16(fp)
811460b8:	20c7883a 	add	r3,r4,r3
811460bc:	18c00003 	ldbu	r3,0(r3)
811460c0:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
811460c4:	e0bffd17 	ldw	r2,-12(fp)
811460c8:	10800044 	addi	r2,r2,1
811460cc:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
811460d0:	e0bffc17 	ldw	r2,-16(fp)
811460d4:	10800044 	addi	r2,r2,1
811460d8:	e0bffc15 	stw	r2,-16(fp)
811460dc:	e0bffc17 	ldw	r2,-16(fp)
811460e0:	10800210 	cmplti	r2,r2,8
811460e4:	103fe81e 	bne	r2,zero,81146088 <__reset+0xfb126088>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
811460e8:	e0bffe17 	ldw	r2,-8(fp)
811460ec:	10800203 	ldbu	r2,8(r2)
811460f0:	10803fcc 	andi	r2,r2,255
811460f4:	10800820 	cmpeqi	r2,r2,32
811460f8:	1000241e 	bne	r2,zero,8114618c <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
811460fc:	e0bffd17 	ldw	r2,-12(fp)
81146100:	e0ffff17 	ldw	r3,-4(fp)
81146104:	1885883a 	add	r2,r3,r2
81146108:	00c00b84 	movi	r3,46
8114610c:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81146110:	e0bffd17 	ldw	r2,-12(fp)
81146114:	10800044 	addi	r2,r2,1
81146118:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
8114611c:	e03ffc15 	stw	zero,-16(fp)
81146120:	00001706 	br	81146180 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81146124:	e0fffe17 	ldw	r3,-8(fp)
81146128:	e0bffc17 	ldw	r2,-16(fp)
8114612c:	1885883a 	add	r2,r3,r2
81146130:	10800204 	addi	r2,r2,8
81146134:	10800003 	ldbu	r2,0(r2)
81146138:	10803fcc 	andi	r2,r2,255
8114613c:	10800820 	cmpeqi	r2,r2,32
81146140:	10000c1e 	bne	r2,zero,81146174 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81146144:	e0bffd17 	ldw	r2,-12(fp)
81146148:	e0ffff17 	ldw	r3,-4(fp)
8114614c:	1885883a 	add	r2,r3,r2
81146150:	e13ffe17 	ldw	r4,-8(fp)
81146154:	e0fffc17 	ldw	r3,-16(fp)
81146158:	20c7883a 	add	r3,r4,r3
8114615c:	18c00204 	addi	r3,r3,8
81146160:	18c00003 	ldbu	r3,0(r3)
81146164:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81146168:	e0bffd17 	ldw	r2,-12(fp)
8114616c:	10800044 	addi	r2,r2,1
81146170:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81146174:	e0bffc17 	ldw	r2,-16(fp)
81146178:	10800044 	addi	r2,r2,1
8114617c:	e0bffc15 	stw	r2,-16(fp)
81146180:	e0bffc17 	ldw	r2,-16(fp)
81146184:	108000d0 	cmplti	r2,r2,3
81146188:	103fe61e 	bne	r2,zero,81146124 <__reset+0xfb126124>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8114618c:	e0bffd17 	ldw	r2,-12(fp)
81146190:	e0ffff17 	ldw	r3,-4(fp)
81146194:	1885883a 	add	r2,r3,r2
81146198:	10000005 	stb	zero,0(r2)
}
8114619c:	0001883a 	nop
811461a0:	e037883a 	mov	sp,fp
811461a4:	df000017 	ldw	fp,0(sp)
811461a8:	dec00104 	addi	sp,sp,4
811461ac:	f800283a 	ret

811461b0 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
811461b0:	defffc04 	addi	sp,sp,-16
811461b4:	de00012e 	bgeu	sp,et,811461bc <alt_up_sd_card_open_dev+0xc>
811461b8:	003b68fa 	trap	3
811461bc:	dfc00315 	stw	ra,12(sp)
811461c0:	df000215 	stw	fp,8(sp)
811461c4:	df000204 	addi	fp,sp,8
811461c8:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
811461cc:	d1600d04 	addi	r5,gp,-32716
811461d0:	e13fff17 	ldw	r4,-4(fp)
811461d4:	114b66c0 	call	8114b66c <alt_find_dev>
811461d8:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
811461dc:	e0bffe17 	ldw	r2,-8(fp)
811461e0:	10001e26 	beq	r2,zero,8114625c <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
811461e4:	e0bffe17 	ldw	r2,-8(fp)
811461e8:	10800a17 	ldw	r2,40(r2)
811461ec:	10808d04 	addi	r2,r2,564
811461f0:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
811461f4:	e0bffe17 	ldw	r2,-8(fp)
811461f8:	10800a17 	ldw	r2,40(r2)
811461fc:	10808904 	addi	r2,r2,548
81146200:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81146204:	e0bffe17 	ldw	r2,-8(fp)
81146208:	10800a17 	ldw	r2,40(r2)
8114620c:	10808404 	addi	r2,r2,528
81146210:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81146214:	e0bffe17 	ldw	r2,-8(fp)
81146218:	10800a17 	ldw	r2,40(r2)
8114621c:	10808c04 	addi	r2,r2,560
81146220:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81146224:	e0bffe17 	ldw	r2,-8(fp)
81146228:	10800a17 	ldw	r2,40(r2)
8114622c:	10808b04 	addi	r2,r2,556
81146230:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81146234:	e0bffe17 	ldw	r2,-8(fp)
81146238:	10800a17 	ldw	r2,40(r2)
8114623c:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
81146240:	e0bffe17 	ldw	r2,-8(fp)
81146244:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
81146248:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
8114624c:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
81146250:	00a045f4 	movhi	r2,33047
81146254:	10b84704 	addi	r2,r2,-7908
81146258:	10000415 	stw	zero,16(r2)
	}
	return dev;
8114625c:	e0bffe17 	ldw	r2,-8(fp)
}
81146260:	e037883a 	mov	sp,fp
81146264:	dfc00117 	ldw	ra,4(sp)
81146268:	df000017 	ldw	fp,0(sp)
8114626c:	dec00204 	addi	sp,sp,8
81146270:	f800283a 	ret

81146274 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81146274:	defffd04 	addi	sp,sp,-12
81146278:	de00012e 	bgeu	sp,et,81146280 <alt_up_sd_card_is_Present+0xc>
8114627c:	003b68fa 	trap	3
81146280:	df000215 	stw	fp,8(sp)
81146284:	df000204 	addi	fp,sp,8
    bool result = false;
81146288:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8114628c:	d0a0b317 	ldw	r2,-32052(gp)
81146290:	10000826 	beq	r2,zero,811462b4 <alt_up_sd_card_is_Present+0x40>
81146294:	d0a0ab17 	ldw	r2,-32084(gp)
81146298:	1080002b 	ldhuio	r2,0(r2)
8114629c:	10bfffcc 	andi	r2,r2,65535
811462a0:	1080008c 	andi	r2,r2,2
811462a4:	10000326 	beq	r2,zero,811462b4 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
811462a8:	00800044 	movi	r2,1
811462ac:	e0bffe15 	stw	r2,-8(fp)
811462b0:	00001e06 	br	8114632c <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
811462b4:	d0a0a917 	ldw	r2,-32092(gp)
811462b8:	10800058 	cmpnei	r2,r2,1
811462bc:	10001b1e 	bne	r2,zero,8114632c <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
811462c0:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
811462c4:	00a045f4 	movhi	r2,33047
811462c8:	10b84704 	addi	r2,r2,-7908
811462cc:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
811462d0:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
811462d4:	e03fff15 	stw	zero,-4(fp)
811462d8:	00001106 	br	81146320 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
811462dc:	00a045f4 	movhi	r2,33047
811462e0:	10b86104 	addi	r2,r2,-7804
811462e4:	e0ffff17 	ldw	r3,-4(fp)
811462e8:	180691ba 	slli	r3,r3,6
811462ec:	10c5883a 	add	r2,r2,r3
811462f0:	10800f04 	addi	r2,r2,60
811462f4:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
811462f8:	00a045f4 	movhi	r2,33047
811462fc:	10b86104 	addi	r2,r2,-7804
81146300:	e0ffff17 	ldw	r3,-4(fp)
81146304:	180691ba 	slli	r3,r3,6
81146308:	10c5883a 	add	r2,r2,r3
8114630c:	10800e04 	addi	r2,r2,56
81146310:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81146314:	e0bfff17 	ldw	r2,-4(fp)
81146318:	10800044 	addi	r2,r2,1
8114631c:	e0bfff15 	stw	r2,-4(fp)
81146320:	e0bfff17 	ldw	r2,-4(fp)
81146324:	10800510 	cmplti	r2,r2,20
81146328:	103fec1e 	bne	r2,zero,811462dc <__reset+0xfb1262dc>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
8114632c:	e0bffe17 	ldw	r2,-8(fp)
}
81146330:	e037883a 	mov	sp,fp
81146334:	df000017 	ldw	fp,0(sp)
81146338:	dec00104 	addi	sp,sp,4
8114633c:	f800283a 	ret

81146340 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81146340:	defffd04 	addi	sp,sp,-12
81146344:	de00012e 	bgeu	sp,et,8114634c <alt_up_sd_card_is_FAT16+0xc>
81146348:	003b68fa 	trap	3
8114634c:	dfc00215 	stw	ra,8(sp)
81146350:	df000115 	stw	fp,4(sp)
81146354:	df000104 	addi	fp,sp,4
	bool result = false;
81146358:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8114635c:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
81146360:	10000c26 	beq	r2,zero,81146394 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81146364:	d0a0a917 	ldw	r2,-32092(gp)
81146368:	1000071e 	bne	r2,zero,81146388 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8114636c:	114456c0 	call	8114456c <Look_for_FAT16>
81146370:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
81146374:	d0a0aa17 	ldw	r2,-32088(gp)
81146378:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
8114637c:	00a045f4 	movhi	r2,33047
81146380:	10b84704 	addi	r2,r2,-7908
81146384:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81146388:	d0a0aa17 	ldw	r2,-32088(gp)
8114638c:	e0bfff15 	stw	r2,-4(fp)
81146390:	00000206 	br	8114639c <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81146394:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81146398:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
8114639c:	e0bfff17 	ldw	r2,-4(fp)
}
811463a0:	e037883a 	mov	sp,fp
811463a4:	dfc00117 	ldw	ra,4(sp)
811463a8:	df000017 	ldw	fp,0(sp)
811463ac:	dec00204 	addi	sp,sp,8
811463b0:	f800283a 	ret

811463b4 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
811463b4:	deffea04 	addi	sp,sp,-88
811463b8:	de00012e 	bgeu	sp,et,811463c0 <alt_up_sd_card_find_first+0xc>
811463bc:	003b68fa 	trap	3
811463c0:	dfc01515 	stw	ra,84(sp)
811463c4:	df001415 	stw	fp,80(sp)
811463c8:	df001404 	addi	fp,sp,80
811463cc:	e13ffe15 	stw	r4,-8(fp)
811463d0:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
811463d4:	00800084 	movi	r2,2
811463d8:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811463dc:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
811463e0:	10002426 	beq	r2,zero,81146474 <alt_up_sd_card_find_first+0xc0>
811463e4:	d0a0aa17 	ldw	r2,-32088(gp)
811463e8:	10002226 	beq	r2,zero,81146474 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
811463ec:	e0ffee04 	addi	r3,fp,-72
811463f0:	e0bfed04 	addi	r2,fp,-76
811463f4:	180d883a 	mov	r6,r3
811463f8:	100b883a 	mov	r5,r2
811463fc:	e13ffe17 	ldw	r4,-8(fp)
81146400:	1144d040 	call	81144d04 <get_home_directory_cluster_for_file>
81146404:	10001926 	beq	r2,zero,8114646c <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
81146408:	e0bfed17 	ldw	r2,-76(fp)
8114640c:	1007883a 	mov	r3,r2
81146410:	00a045f4 	movhi	r2,33047
81146414:	10b84704 	addi	r2,r2,-7908
81146418:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
8114641c:	e0bfed17 	ldw	r2,-76(fp)
81146420:	1007883a 	mov	r3,r2
81146424:	00a045f4 	movhi	r2,33047
81146428:	10b84704 	addi	r2,r2,-7908
8114642c:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81146430:	00a045f4 	movhi	r2,33047
81146434:	10b84704 	addi	r2,r2,-7908
81146438:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
8114643c:	00a045f4 	movhi	r2,33047
81146440:	10b84704 	addi	r2,r2,-7908
81146444:	00ffffc4 	movi	r3,-1
81146448:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8114644c:	00a045f4 	movhi	r2,33047
81146450:	10b84704 	addi	r2,r2,-7908
81146454:	00c00044 	movi	r3,1
81146458:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8114645c:	e13fff17 	ldw	r4,-4(fp)
81146460:	114648c0 	call	8114648c <alt_up_sd_card_find_next>
81146464:	e0bfec0d 	sth	r2,-80(fp)
81146468:	00000206 	br	81146474 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8114646c:	00800044 	movi	r2,1
81146470:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81146474:	e0bfec0b 	ldhu	r2,-80(fp)
}
81146478:	e037883a 	mov	sp,fp
8114647c:	dfc00117 	ldw	ra,4(sp)
81146480:	df000017 	ldw	fp,0(sp)
81146484:	dec00204 	addi	sp,sp,8
81146488:	f800283a 	ret

8114648c <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8114648c:	deffe404 	addi	sp,sp,-112
81146490:	de00012e 	bgeu	sp,et,81146498 <alt_up_sd_card_find_next+0xc>
81146494:	003b68fa 	trap	3
81146498:	dfc01b15 	stw	ra,108(sp)
8114649c:	df001a15 	stw	fp,104(sp)
811464a0:	df001a04 	addi	fp,sp,104
811464a4:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
811464a8:	00800084 	movi	r2,2
811464ac:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811464b0:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
811464b4:	1000df26 	beq	r2,zero,81146834 <alt_up_sd_card_find_next+0x3a8>
811464b8:	d0a0aa17 	ldw	r2,-32088(gp)
811464bc:	1000dd26 	beq	r2,zero,81146834 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
811464c0:	00a045f4 	movhi	r2,33047
811464c4:	10b84704 	addi	r2,r2,-7908
811464c8:	10800417 	ldw	r2,16(r2)
811464cc:	1000d726 	beq	r2,zero,8114682c <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
811464d0:	00a045f4 	movhi	r2,33047
811464d4:	10b84704 	addi	r2,r2,-7908
811464d8:	10800117 	ldw	r2,4(r2)
811464dc:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
811464e0:	e0bfe717 	ldw	r2,-100(fp)
811464e4:	1000561e 	bne	r2,zero,81146640 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811464e8:	00a045f4 	movhi	r2,33047
811464ec:	10b84c04 	addi	r2,r2,-7888
811464f0:	1080050b 	ldhu	r2,20(r2)
811464f4:	10bfffcc 	andi	r2,r2,65535
811464f8:	1006917a 	slli	r3,r2,5
811464fc:	00a045f4 	movhi	r2,33047
81146500:	10b84c04 	addi	r2,r2,-7888
81146504:	1080030b 	ldhu	r2,12(r2)
81146508:	10bfffcc 	andi	r2,r2,65535
8114650c:	1885283a 	div	r2,r3,r2
81146510:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81146514:	00a045f4 	movhi	r2,33047
81146518:	10b84704 	addi	r2,r2,-7908
8114651c:	10800217 	ldw	r2,8(r2)
81146520:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81146524:	00a045f4 	movhi	r2,33047
81146528:	10b84704 	addi	r2,r2,-7908
8114652c:	1080030b 	ldhu	r2,12(r2)
81146530:	10bfffcc 	andi	r2,r2,65535
81146534:	10a0001c 	xori	r2,r2,32768
81146538:	10a00004 	addi	r2,r2,-32768
8114653c:	10800044 	addi	r2,r2,1
81146540:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81146544:	00003606 	br	81146620 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81146548:	00a045f4 	movhi	r2,33047
8114654c:	10b84c04 	addi	r2,r2,-7888
81146550:	10c01317 	ldw	r3,76(r2)
81146554:	e0bfe817 	ldw	r2,-96(fp)
81146558:	1885883a 	add	r2,r3,r2
8114655c:	1007883a 	mov	r3,r2
81146560:	d0a0b117 	ldw	r2,-32060(gp)
81146564:	100b883a 	mov	r5,r2
81146568:	1809883a 	mov	r4,r3
8114656c:	114359c0 	call	8114359c <Read_Sector_Data>
81146570:	10002f26 	beq	r2,zero,81146630 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81146574:	00002306 	br	81146604 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81146578:	e0bfe917 	ldw	r2,-92(fp)
8114657c:	1004917a 	slli	r2,r2,5
81146580:	e13fe817 	ldw	r4,-96(fp)
81146584:	e0ffef04 	addi	r3,fp,-68
81146588:	200f883a 	mov	r7,r4
8114658c:	000d883a 	mov	r6,zero
81146590:	180b883a 	mov	r5,r3
81146594:	1009883a 	mov	r4,r2
81146598:	11439cc0 	call	811439cc <Read_File_Record_At_Offset>
8114659c:	10001626 	beq	r2,zero,811465f8 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811465a0:	e0bfef03 	ldbu	r2,-68(fp)
811465a4:	10803fcc 	andi	r2,r2,255
811465a8:	10001326 	beq	r2,zero,811465f8 <alt_up_sd_card_find_next+0x16c>
811465ac:	e0bfef03 	ldbu	r2,-68(fp)
811465b0:	10803fcc 	andi	r2,r2,255
811465b4:	10803960 	cmpeqi	r2,r2,229
811465b8:	10000f1e 	bne	r2,zero,811465f8 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
811465bc:	e0bfe917 	ldw	r2,-92(fp)
811465c0:	1007883a 	mov	r3,r2
811465c4:	00a045f4 	movhi	r2,33047
811465c8:	10b84704 	addi	r2,r2,-7908
811465cc:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
811465d0:	e0ffe817 	ldw	r3,-96(fp)
811465d4:	00a045f4 	movhi	r2,33047
811465d8:	10b84704 	addi	r2,r2,-7908
811465dc:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
811465e0:	e0bfef04 	addi	r2,fp,-68
811465e4:	e17fff17 	ldw	r5,-4(fp)
811465e8:	1009883a 	mov	r4,r2
811465ec:	11460600 	call	81146060 <copy_file_record_name_to_string>
									return 0;
811465f0:	0005883a 	mov	r2,zero
811465f4:	00009006 	br	81146838 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811465f8:	e0bfe917 	ldw	r2,-92(fp)
811465fc:	10800044 	addi	r2,r2,1
81146600:	e0bfe915 	stw	r2,-92(fp)
81146604:	e0bfe917 	ldw	r2,-92(fp)
81146608:	10800410 	cmplti	r2,r2,16
8114660c:	103fda1e 	bne	r2,zero,81146578 <__reset+0xfb126578>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81146610:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81146614:	e0bfe817 	ldw	r2,-96(fp)
81146618:	10800044 	addi	r2,r2,1
8114661c:	e0bfe815 	stw	r2,-96(fp)
81146620:	e0ffe817 	ldw	r3,-96(fp)
81146624:	e0bfec17 	ldw	r2,-80(fp)
81146628:	18bfc716 	blt	r3,r2,81146548 <__reset+0xfb126548>
8114662c:	00000106 	br	81146634 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81146630:	0001883a 	nop
					}
				}
				result = -1;
81146634:	00bfffc4 	movi	r2,-1
81146638:	e0bfe60d 	sth	r2,-104(fp)
8114663c:	00007d06 	br	81146834 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81146640:	00a045f4 	movhi	r2,33047
81146644:	10b84704 	addi	r2,r2,-7908
81146648:	1080030b 	ldhu	r2,12(r2)
8114664c:	10bfffcc 	andi	r2,r2,65535
81146650:	10a0001c 	xori	r2,r2,32768
81146654:	10a00004 	addi	r2,r2,-32768
81146658:	10800044 	addi	r2,r2,1
8114665c:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81146660:	e0bfe717 	ldw	r2,-100(fp)
81146664:	10ffff84 	addi	r3,r2,-2
81146668:	00a045f4 	movhi	r2,33047
8114666c:	10b84c04 	addi	r2,r2,-7888
81146670:	10800383 	ldbu	r2,14(r2)
81146674:	10803fcc 	andi	r2,r2,255
81146678:	1885383a 	mul	r2,r3,r2
8114667c:	1007883a 	mov	r3,r2
81146680:	00a045f4 	movhi	r2,33047
81146684:	10b84c04 	addi	r2,r2,-7888
81146688:	10801417 	ldw	r2,80(r2)
8114668c:	1885883a 	add	r2,r3,r2
81146690:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81146694:	00a045f4 	movhi	r2,33047
81146698:	10b84704 	addi	r2,r2,-7908
8114669c:	10800217 	ldw	r2,8(r2)
811466a0:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811466a4:	00003806 	br	81146788 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811466a8:	e0ffeb17 	ldw	r3,-84(fp)
811466ac:	e0bfed17 	ldw	r2,-76(fp)
811466b0:	1885883a 	add	r2,r3,r2
811466b4:	d0e0b117 	ldw	r3,-32060(gp)
811466b8:	180b883a 	mov	r5,r3
811466bc:	1009883a 	mov	r4,r2
811466c0:	114359c0 	call	8114359c <Read_Sector_Data>
811466c4:	10003726 	beq	r2,zero,811467a4 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
811466c8:	00002806 	br	8114676c <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
811466cc:	e0bfea17 	ldw	r2,-88(fp)
811466d0:	1004917a 	slli	r2,r2,5
811466d4:	e13fe717 	ldw	r4,-100(fp)
811466d8:	e17feb17 	ldw	r5,-84(fp)
811466dc:	e0ffef04 	addi	r3,fp,-68
811466e0:	280f883a 	mov	r7,r5
811466e4:	200d883a 	mov	r6,r4
811466e8:	180b883a 	mov	r5,r3
811466ec:	1009883a 	mov	r4,r2
811466f0:	11439cc0 	call	811439cc <Read_File_Record_At_Offset>
811466f4:	10001a26 	beq	r2,zero,81146760 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811466f8:	e0bfef03 	ldbu	r2,-68(fp)
811466fc:	10803fcc 	andi	r2,r2,255
81146700:	10001726 	beq	r2,zero,81146760 <alt_up_sd_card_find_next+0x2d4>
81146704:	e0bfef03 	ldbu	r2,-68(fp)
81146708:	10803fcc 	andi	r2,r2,255
8114670c:	10803960 	cmpeqi	r2,r2,229
81146710:	1000131e 	bne	r2,zero,81146760 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
81146714:	e0ffe717 	ldw	r3,-100(fp)
81146718:	00a045f4 	movhi	r2,33047
8114671c:	10b84704 	addi	r2,r2,-7908
81146720:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81146724:	e0bfea17 	ldw	r2,-88(fp)
81146728:	1007883a 	mov	r3,r2
8114672c:	00a045f4 	movhi	r2,33047
81146730:	10b84704 	addi	r2,r2,-7908
81146734:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81146738:	e0ffeb17 	ldw	r3,-84(fp)
8114673c:	00a045f4 	movhi	r2,33047
81146740:	10b84704 	addi	r2,r2,-7908
81146744:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81146748:	e0bfef04 	addi	r2,fp,-68
8114674c:	e17fff17 	ldw	r5,-4(fp)
81146750:	1009883a 	mov	r4,r2
81146754:	11460600 	call	81146060 <copy_file_record_name_to_string>
										return 0;
81146758:	0005883a 	mov	r2,zero
8114675c:	00003606 	br	81146838 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81146760:	e0bfea17 	ldw	r2,-88(fp)
81146764:	10800044 	addi	r2,r2,1
81146768:	e0bfea15 	stw	r2,-88(fp)
8114676c:	e0bfea17 	ldw	r2,-88(fp)
81146770:	10800410 	cmplti	r2,r2,16
81146774:	103fd51e 	bne	r2,zero,811466cc <__reset+0xfb1266cc>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81146778:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114677c:	e0bfeb17 	ldw	r2,-84(fp)
81146780:	10800044 	addi	r2,r2,1
81146784:	e0bfeb15 	stw	r2,-84(fp)
81146788:	00a045f4 	movhi	r2,33047
8114678c:	10b84c04 	addi	r2,r2,-7888
81146790:	10800383 	ldbu	r2,14(r2)
81146794:	10803fcc 	andi	r2,r2,255
81146798:	e0ffeb17 	ldw	r3,-84(fp)
8114679c:	18bfc216 	blt	r3,r2,811466a8 <__reset+0xfb1266a8>
811467a0:	00000106 	br	811467a8 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
811467a4:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
811467a8:	00a045f4 	movhi	r2,33047
811467ac:	10b84c04 	addi	r2,r2,-7888
811467b0:	10800383 	ldbu	r2,14(r2)
811467b4:	10803fcc 	andi	r2,r2,255
811467b8:	e0ffeb17 	ldw	r3,-84(fp)
811467bc:	18801716 	blt	r3,r2,8114681c <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
811467c0:	e0bfe717 	ldw	r2,-100(fp)
811467c4:	e0ffee04 	addi	r3,fp,-72
811467c8:	180b883a 	mov	r5,r3
811467cc:	1009883a 	mov	r4,r2
811467d0:	114367c0 	call	8114367c <get_cluster_flag>
811467d4:	10000f26 	beq	r2,zero,81146814 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811467d8:	e0bfee0b 	ldhu	r2,-72(fp)
811467dc:	10bfffcc 	andi	r2,r2,65535
811467e0:	10fffe0c 	andi	r3,r2,65528
811467e4:	00bffe14 	movui	r2,65528
811467e8:	1880051e 	bne	r3,r2,81146800 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
811467ec:	00bfffc4 	movi	r2,-1
811467f0:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
811467f4:	00a045f4 	movhi	r2,33047
811467f8:	10b84704 	addi	r2,r2,-7908
811467fc:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81146800:	e0bfee0b 	ldhu	r2,-72(fp)
81146804:	10bfffcc 	andi	r2,r2,65535
81146808:	10bffe0c 	andi	r2,r2,65528
8114680c:	e0bfe715 	stw	r2,-100(fp)
81146810:	00000206 	br	8114681c <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
81146814:	00bfffc4 	movi	r2,-1
81146818:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
8114681c:	e0bfe717 	ldw	r2,-100(fp)
81146820:	00fffdd4 	movui	r3,65527
81146824:	18bf8e0e 	bge	r3,r2,81146660 <__reset+0xfb126660>
81146828:	00000206 	br	81146834 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
8114682c:	008000c4 	movi	r2,3
81146830:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81146834:	e0bfe60b 	ldhu	r2,-104(fp)
}
81146838:	e037883a 	mov	sp,fp
8114683c:	dfc00117 	ldw	ra,4(sp)
81146840:	df000017 	ldw	fp,0(sp)
81146844:	dec00204 	addi	sp,sp,8
81146848:	f800283a 	ret

8114684c <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
8114684c:	deffe904 	addi	sp,sp,-92
81146850:	de00012e 	bgeu	sp,et,81146858 <alt_up_sd_card_fopen+0xc>
81146854:	003b68fa 	trap	3
81146858:	dfc01615 	stw	ra,88(sp)
8114685c:	df001515 	stw	fp,84(sp)
81146860:	df001504 	addi	fp,sp,84
81146864:	e13ffe15 	stw	r4,-8(fp)
81146868:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8114686c:	00bfffc4 	movi	r2,-1
81146870:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81146874:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
81146878:	1000cf26 	beq	r2,zero,81146bb8 <alt_up_sd_card_fopen+0x36c>
8114687c:	d0a0aa17 	ldw	r2,-32088(gp)
81146880:	1000cd26 	beq	r2,zero,81146bb8 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81146884:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81146888:	e13ffe17 	ldw	r4,-8(fp)
8114688c:	11446600 	call	81144660 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81146890:	e13ffe17 	ldw	r4,-8(fp)
81146894:	114472c0 	call	8114472c <check_file_name_for_FAT16_compliance>
81146898:	1000c726 	beq	r2,zero,81146bb8 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8114689c:	e0ffee04 	addi	r3,fp,-72
811468a0:	e0bfed04 	addi	r2,fp,-76
811468a4:	180d883a 	mov	r6,r3
811468a8:	100b883a 	mov	r5,r2
811468ac:	e13ffe17 	ldw	r4,-8(fp)
811468b0:	1144d040 	call	81144d04 <get_home_directory_cluster_for_file>
811468b4:	1000021e 	bne	r2,zero,811468c0 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
811468b8:	e0bfeb0b 	ldhu	r2,-84(fp)
811468bc:	0000bf06 	br	81146bbc <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811468c0:	e03fec15 	stw	zero,-80(fp)
811468c4:	00000e06 	br	81146900 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
811468c8:	00a045f4 	movhi	r2,33047
811468cc:	10b86104 	addi	r2,r2,-7804
811468d0:	e0ffec17 	ldw	r3,-80(fp)
811468d4:	180691ba 	slli	r3,r3,6
811468d8:	10c5883a 	add	r2,r2,r3
811468dc:	10800f04 	addi	r2,r2,60
811468e0:	10800017 	ldw	r2,0(r2)
811468e4:	1000031e 	bne	r2,zero,811468f4 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
811468e8:	e0bfec17 	ldw	r2,-80(fp)
811468ec:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
811468f0:	00000606 	br	8114690c <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811468f4:	e0bfec17 	ldw	r2,-80(fp)
811468f8:	10800044 	addi	r2,r2,1
811468fc:	e0bfec15 	stw	r2,-80(fp)
81146900:	e0bfec17 	ldw	r2,-80(fp)
81146904:	10800510 	cmplti	r2,r2,20
81146908:	103fef1e 	bne	r2,zero,811468c8 <__reset+0xfb1268c8>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8114690c:	e0bfeb0f 	ldh	r2,-84(fp)
81146910:	1000a916 	blt	r2,zero,81146bb8 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
81146914:	e0bfed17 	ldw	r2,-76(fp)
81146918:	1009883a 	mov	r4,r2
8114691c:	e0bfeb0f 	ldh	r2,-84(fp)
81146920:	100691ba 	slli	r3,r2,6
81146924:	00a045f4 	movhi	r2,33047
81146928:	10b86104 	addi	r2,r2,-7804
8114692c:	1885883a 	add	r2,r3,r2
81146930:	100d883a 	mov	r6,r2
81146934:	e17ffe17 	ldw	r5,-8(fp)
81146938:	11452440 	call	81145244 <find_file_in_directory>
8114693c:	10007b26 	beq	r2,zero,81146b2c <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81146940:	e0bfff17 	ldw	r2,-4(fp)
81146944:	10000226 	beq	r2,zero,81146950 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81146948:	00bfffc4 	movi	r2,-1
8114694c:	00009b06 	br	81146bbc <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81146950:	e13feb0f 	ldh	r4,-84(fp)
81146954:	e0ffeb0f 	ldh	r3,-84(fp)
81146958:	00a045f4 	movhi	r2,33047
8114695c:	10b86104 	addi	r2,r2,-7804
81146960:	180691ba 	slli	r3,r3,6
81146964:	10c5883a 	add	r2,r2,r3
81146968:	10800584 	addi	r2,r2,22
8114696c:	1080000b 	ldhu	r2,0(r2)
81146970:	10ffffcc 	andi	r3,r2,65535
81146974:	00a045f4 	movhi	r2,33047
81146978:	10b86104 	addi	r2,r2,-7804
8114697c:	200891ba 	slli	r4,r4,6
81146980:	1105883a 	add	r2,r2,r4
81146984:	10800704 	addi	r2,r2,28
81146988:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8114698c:	e0ffeb0f 	ldh	r3,-84(fp)
81146990:	00a045f4 	movhi	r2,33047
81146994:	10b86104 	addi	r2,r2,-7804
81146998:	180691ba 	slli	r3,r3,6
8114699c:	10c5883a 	add	r2,r2,r3
811469a0:	10800804 	addi	r2,r2,32
811469a4:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
811469a8:	e0ffeb0f 	ldh	r3,-84(fp)
811469ac:	00a045f4 	movhi	r2,33047
811469b0:	10b86104 	addi	r2,r2,-7804
811469b4:	180691ba 	slli	r3,r3,6
811469b8:	10c5883a 	add	r2,r2,r3
811469bc:	10800904 	addi	r2,r2,36
811469c0:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
811469c4:	e0ffeb0f 	ldh	r3,-84(fp)
811469c8:	00a045f4 	movhi	r2,33047
811469cc:	10b86104 	addi	r2,r2,-7804
811469d0:	180691ba 	slli	r3,r3,6
811469d4:	10c5883a 	add	r2,r2,r3
811469d8:	10800f04 	addi	r2,r2,60
811469dc:	00c00044 	movi	r3,1
811469e0:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
811469e4:	e0ffeb0f 	ldh	r3,-84(fp)
811469e8:	00a045f4 	movhi	r2,33047
811469ec:	10b86104 	addi	r2,r2,-7804
811469f0:	180691ba 	slli	r3,r3,6
811469f4:	10c5883a 	add	r2,r2,r3
811469f8:	10800e04 	addi	r2,r2,56
811469fc:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81146a00:	e03fec15 	stw	zero,-80(fp)
81146a04:	00004506 	br	81146b1c <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
81146a08:	e0ffeb0f 	ldh	r3,-84(fp)
81146a0c:	e0bfec17 	ldw	r2,-80(fp)
81146a10:	18803f26 	beq	r3,r2,81146b10 <alt_up_sd_card_fopen+0x2c4>
81146a14:	00a045f4 	movhi	r2,33047
81146a18:	10b86104 	addi	r2,r2,-7804
81146a1c:	e0ffec17 	ldw	r3,-80(fp)
81146a20:	180691ba 	slli	r3,r3,6
81146a24:	10c5883a 	add	r2,r2,r3
81146a28:	10800f04 	addi	r2,r2,60
81146a2c:	10800017 	ldw	r2,0(r2)
81146a30:	10800058 	cmpnei	r2,r2,1
81146a34:	1000361e 	bne	r2,zero,81146b10 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81146a38:	e0ffeb0f 	ldh	r3,-84(fp)
81146a3c:	00a045f4 	movhi	r2,33047
81146a40:	10b86104 	addi	r2,r2,-7804
81146a44:	180691ba 	slli	r3,r3,6
81146a48:	10c5883a 	add	r2,r2,r3
81146a4c:	10800a04 	addi	r2,r2,40
81146a50:	10c00017 	ldw	r3,0(r2)
81146a54:	00a045f4 	movhi	r2,33047
81146a58:	10b86104 	addi	r2,r2,-7804
81146a5c:	e13fec17 	ldw	r4,-80(fp)
81146a60:	200891ba 	slli	r4,r4,6
81146a64:	1105883a 	add	r2,r2,r4
81146a68:	10800a04 	addi	r2,r2,40
81146a6c:	10800017 	ldw	r2,0(r2)
81146a70:	1880271e 	bne	r3,r2,81146b10 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81146a74:	e0ffeb0f 	ldh	r3,-84(fp)
81146a78:	00a045f4 	movhi	r2,33047
81146a7c:	10b86104 	addi	r2,r2,-7804
81146a80:	180691ba 	slli	r3,r3,6
81146a84:	10c5883a 	add	r2,r2,r3
81146a88:	10800b04 	addi	r2,r2,44
81146a8c:	10c00017 	ldw	r3,0(r2)
81146a90:	00a045f4 	movhi	r2,33047
81146a94:	10b86104 	addi	r2,r2,-7804
81146a98:	e13fec17 	ldw	r4,-80(fp)
81146a9c:	200891ba 	slli	r4,r4,6
81146aa0:	1105883a 	add	r2,r2,r4
81146aa4:	10800b04 	addi	r2,r2,44
81146aa8:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81146aac:	1880181e 	bne	r3,r2,81146b10 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81146ab0:	e0ffeb0f 	ldh	r3,-84(fp)
81146ab4:	00a045f4 	movhi	r2,33047
81146ab8:	10b86104 	addi	r2,r2,-7804
81146abc:	180691ba 	slli	r3,r3,6
81146ac0:	10c5883a 	add	r2,r2,r3
81146ac4:	10800c04 	addi	r2,r2,48
81146ac8:	1100000b 	ldhu	r4,0(r2)
81146acc:	00a045f4 	movhi	r2,33047
81146ad0:	10b86104 	addi	r2,r2,-7804
81146ad4:	e0ffec17 	ldw	r3,-80(fp)
81146ad8:	180691ba 	slli	r3,r3,6
81146adc:	10c5883a 	add	r2,r2,r3
81146ae0:	10800c04 	addi	r2,r2,48
81146ae4:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81146ae8:	20ffffcc 	andi	r3,r4,65535
81146aec:	18e0001c 	xori	r3,r3,32768
81146af0:	18e00004 	addi	r3,r3,-32768
81146af4:	10bfffcc 	andi	r2,r2,65535
81146af8:	10a0001c 	xori	r2,r2,32768
81146afc:	10a00004 	addi	r2,r2,-32768
81146b00:	1880031e 	bne	r3,r2,81146b10 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
81146b04:	00bfff84 	movi	r2,-2
81146b08:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81146b0c:	00002a06 	br	81146bb8 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81146b10:	e0bfec17 	ldw	r2,-80(fp)
81146b14:	10800044 	addi	r2,r2,1
81146b18:	e0bfec15 	stw	r2,-80(fp)
81146b1c:	e0bfec17 	ldw	r2,-80(fp)
81146b20:	10800510 	cmplti	r2,r2,20
81146b24:	103fb81e 	bne	r2,zero,81146a08 <__reset+0xfb126a08>
81146b28:	00002306 	br	81146bb8 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81146b2c:	e0bfff17 	ldw	r2,-4(fp)
81146b30:	10001f26 	beq	r2,zero,81146bb0 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
81146b34:	e0bfeb0f 	ldh	r2,-84(fp)
81146b38:	100691ba 	slli	r3,r2,6
81146b3c:	00a045f4 	movhi	r2,33047
81146b40:	10b86104 	addi	r2,r2,-7804
81146b44:	1885883a 	add	r2,r3,r2
81146b48:	e0ffee04 	addi	r3,fp,-72
81146b4c:	180d883a 	mov	r6,r3
81146b50:	100b883a 	mov	r5,r2
81146b54:	e13ffe17 	ldw	r4,-8(fp)
81146b58:	1145d900 	call	81145d90 <create_file>
81146b5c:	10001126 	beq	r2,zero,81146ba4 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81146b60:	e0ffeb0f 	ldh	r3,-84(fp)
81146b64:	00a045f4 	movhi	r2,33047
81146b68:	10b86104 	addi	r2,r2,-7804
81146b6c:	180691ba 	slli	r3,r3,6
81146b70:	10c5883a 	add	r2,r2,r3
81146b74:	10800f04 	addi	r2,r2,60
81146b78:	00c00044 	movi	r3,1
81146b7c:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81146b80:	e0ffeb0f 	ldh	r3,-84(fp)
81146b84:	00a045f4 	movhi	r2,33047
81146b88:	10b86104 	addi	r2,r2,-7804
81146b8c:	180691ba 	slli	r3,r3,6
81146b90:	10c5883a 	add	r2,r2,r3
81146b94:	10800e04 	addi	r2,r2,56
81146b98:	00c00044 	movi	r3,1
81146b9c:	10c00015 	stw	r3,0(r2)
81146ba0:	00000506 	br	81146bb8 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81146ba4:	00bfffc4 	movi	r2,-1
81146ba8:	e0bfeb0d 	sth	r2,-84(fp)
81146bac:	00000206 	br	81146bb8 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81146bb0:	00bfffc4 	movi	r2,-1
81146bb4:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81146bb8:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81146bbc:	e037883a 	mov	sp,fp
81146bc0:	dfc00117 	ldw	ra,4(sp)
81146bc4:	df000017 	ldw	fp,0(sp)
81146bc8:	dec00204 	addi	sp,sp,8
81146bcc:	f800283a 	ret

81146bd0 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81146bd0:	defffd04 	addi	sp,sp,-12
81146bd4:	de00012e 	bgeu	sp,et,81146bdc <alt_up_sd_card_set_attributes+0xc>
81146bd8:	003b68fa 	trap	3
81146bdc:	df000215 	stw	fp,8(sp)
81146be0:	df000204 	addi	fp,sp,8
81146be4:	2007883a 	mov	r3,r4
81146be8:	2805883a 	mov	r2,r5
81146bec:	e0fffe0d 	sth	r3,-8(fp)
81146bf0:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81146bf4:	e0bffe0f 	ldh	r2,-8(fp)
81146bf8:	10001416 	blt	r2,zero,81146c4c <alt_up_sd_card_set_attributes+0x7c>
81146bfc:	e0bffe0f 	ldh	r2,-8(fp)
81146c00:	10800508 	cmpgei	r2,r2,20
81146c04:	1000111e 	bne	r2,zero,81146c4c <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81146c08:	e0fffe0f 	ldh	r3,-8(fp)
81146c0c:	00a045f4 	movhi	r2,33047
81146c10:	10b86104 	addi	r2,r2,-7804
81146c14:	180691ba 	slli	r3,r3,6
81146c18:	10c5883a 	add	r2,r2,r3
81146c1c:	10800f04 	addi	r2,r2,60
81146c20:	10800017 	ldw	r2,0(r2)
81146c24:	10000926 	beq	r2,zero,81146c4c <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81146c28:	e0fffe0f 	ldh	r3,-8(fp)
81146c2c:	e0bfff0b 	ldhu	r2,-4(fp)
81146c30:	1009883a 	mov	r4,r2
81146c34:	00a045f4 	movhi	r2,33047
81146c38:	10b86104 	addi	r2,r2,-7804
81146c3c:	180691ba 	slli	r3,r3,6
81146c40:	10c5883a 	add	r2,r2,r3
81146c44:	108002c4 	addi	r2,r2,11
81146c48:	11000005 	stb	r4,0(r2)
        }
    }
}
81146c4c:	0001883a 	nop
81146c50:	e037883a 	mov	sp,fp
81146c54:	df000017 	ldw	fp,0(sp)
81146c58:	dec00104 	addi	sp,sp,4
81146c5c:	f800283a 	ret

81146c60 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81146c60:	defffd04 	addi	sp,sp,-12
81146c64:	de00012e 	bgeu	sp,et,81146c6c <alt_up_sd_card_get_attributes+0xc>
81146c68:	003b68fa 	trap	3
81146c6c:	df000215 	stw	fp,8(sp)
81146c70:	df000204 	addi	fp,sp,8
81146c74:	2005883a 	mov	r2,r4
81146c78:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81146c7c:	00bfffc4 	movi	r2,-1
81146c80:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81146c84:	e0bfff0f 	ldh	r2,-4(fp)
81146c88:	10001416 	blt	r2,zero,81146cdc <alt_up_sd_card_get_attributes+0x7c>
81146c8c:	e0bfff0f 	ldh	r2,-4(fp)
81146c90:	10800508 	cmpgei	r2,r2,20
81146c94:	1000111e 	bne	r2,zero,81146cdc <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81146c98:	e0ffff0f 	ldh	r3,-4(fp)
81146c9c:	00a045f4 	movhi	r2,33047
81146ca0:	10b86104 	addi	r2,r2,-7804
81146ca4:	180691ba 	slli	r3,r3,6
81146ca8:	10c5883a 	add	r2,r2,r3
81146cac:	10800f04 	addi	r2,r2,60
81146cb0:	10800017 	ldw	r2,0(r2)
81146cb4:	10000926 	beq	r2,zero,81146cdc <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81146cb8:	e0ffff0f 	ldh	r3,-4(fp)
81146cbc:	00a045f4 	movhi	r2,33047
81146cc0:	10b86104 	addi	r2,r2,-7804
81146cc4:	180691ba 	slli	r3,r3,6
81146cc8:	10c5883a 	add	r2,r2,r3
81146ccc:	108002c4 	addi	r2,r2,11
81146cd0:	10800003 	ldbu	r2,0(r2)
81146cd4:	10803fcc 	andi	r2,r2,255
81146cd8:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81146cdc:	e0bffe0b 	ldhu	r2,-8(fp)
}
81146ce0:	e037883a 	mov	sp,fp
81146ce4:	df000017 	ldw	fp,0(sp)
81146ce8:	dec00104 	addi	sp,sp,4
81146cec:	f800283a 	ret

81146cf0 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81146cf0:	defffa04 	addi	sp,sp,-24
81146cf4:	de00012e 	bgeu	sp,et,81146cfc <alt_up_sd_card_read+0xc>
81146cf8:	003b68fa 	trap	3
81146cfc:	dfc00515 	stw	ra,20(sp)
81146d00:	df000415 	stw	fp,16(sp)
81146d04:	df000404 	addi	fp,sp,16
81146d08:	2005883a 	mov	r2,r4
81146d0c:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81146d10:	00bfffc4 	movi	r2,-1
81146d14:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81146d18:	e0bfff0f 	ldh	r2,-4(fp)
81146d1c:	1000ce16 	blt	r2,zero,81147058 <alt_up_sd_card_read+0x368>
81146d20:	e0bfff0f 	ldh	r2,-4(fp)
81146d24:	10800508 	cmpgei	r2,r2,20
81146d28:	1000cb1e 	bne	r2,zero,81147058 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81146d2c:	e0ffff0f 	ldh	r3,-4(fp)
81146d30:	00a045f4 	movhi	r2,33047
81146d34:	10b86104 	addi	r2,r2,-7804
81146d38:	180691ba 	slli	r3,r3,6
81146d3c:	10c5883a 	add	r2,r2,r3
81146d40:	10800f04 	addi	r2,r2,60
81146d44:	10800017 	ldw	r2,0(r2)
81146d48:	1000c326 	beq	r2,zero,81147058 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81146d4c:	e0ffff0f 	ldh	r3,-4(fp)
81146d50:	00a045f4 	movhi	r2,33047
81146d54:	10b86104 	addi	r2,r2,-7804
81146d58:	180691ba 	slli	r3,r3,6
81146d5c:	10c5883a 	add	r2,r2,r3
81146d60:	10800904 	addi	r2,r2,36
81146d64:	10c00017 	ldw	r3,0(r2)
81146d68:	e13fff0f 	ldh	r4,-4(fp)
81146d6c:	00a045f4 	movhi	r2,33047
81146d70:	10b86104 	addi	r2,r2,-7804
81146d74:	200891ba 	slli	r4,r4,6
81146d78:	1105883a 	add	r2,r2,r4
81146d7c:	10800604 	addi	r2,r2,24
81146d80:	10800017 	ldw	r2,0(r2)
81146d84:	1880b42e 	bgeu	r3,r2,81147058 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146d88:	00a045f4 	movhi	r2,33047
81146d8c:	10b84c04 	addi	r2,r2,-7888
81146d90:	10c01417 	ldw	r3,80(r2)
81146d94:	e13fff0f 	ldh	r4,-4(fp)
81146d98:	00a045f4 	movhi	r2,33047
81146d9c:	10b86104 	addi	r2,r2,-7804
81146da0:	200891ba 	slli	r4,r4,6
81146da4:	1105883a 	add	r2,r2,r4
81146da8:	10800704 	addi	r2,r2,28
81146dac:	10800017 	ldw	r2,0(r2)
81146db0:	113fff84 	addi	r4,r2,-2
81146db4:	00a045f4 	movhi	r2,33047
81146db8:	10b84c04 	addi	r2,r2,-7888
81146dbc:	10800383 	ldbu	r2,14(r2)
81146dc0:	10803fcc 	andi	r2,r2,255
81146dc4:	2085383a 	mul	r2,r4,r2
81146dc8:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81146dcc:	e13fff0f 	ldh	r4,-4(fp)
81146dd0:	00a045f4 	movhi	r2,33047
81146dd4:	10b86104 	addi	r2,r2,-7804
81146dd8:	200891ba 	slli	r4,r4,6
81146ddc:	1105883a 	add	r2,r2,r4
81146de0:	10800804 	addi	r2,r2,32
81146de4:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146de8:	1885883a 	add	r2,r3,r2
81146dec:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81146df0:	e0ffff0f 	ldh	r3,-4(fp)
81146df4:	00a045f4 	movhi	r2,33047
81146df8:	10b86104 	addi	r2,r2,-7804
81146dfc:	180691ba 	slli	r3,r3,6
81146e00:	10c5883a 	add	r2,r2,r3
81146e04:	10800904 	addi	r2,r2,36
81146e08:	10800017 	ldw	r2,0(r2)
81146e0c:	10006826 	beq	r2,zero,81146fb0 <alt_up_sd_card_read+0x2c0>
81146e10:	e0ffff0f 	ldh	r3,-4(fp)
81146e14:	00a045f4 	movhi	r2,33047
81146e18:	10b86104 	addi	r2,r2,-7804
81146e1c:	180691ba 	slli	r3,r3,6
81146e20:	10c5883a 	add	r2,r2,r3
81146e24:	10800904 	addi	r2,r2,36
81146e28:	10800017 	ldw	r2,0(r2)
81146e2c:	10807fcc 	andi	r2,r2,511
81146e30:	10005f1e 	bne	r2,zero,81146fb0 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81146e34:	e0ffff0f 	ldh	r3,-4(fp)
81146e38:	00a045f4 	movhi	r2,33047
81146e3c:	10b86104 	addi	r2,r2,-7804
81146e40:	180691ba 	slli	r3,r3,6
81146e44:	10c5883a 	add	r2,r2,r3
81146e48:	10800804 	addi	r2,r2,32
81146e4c:	10c00017 	ldw	r3,0(r2)
81146e50:	00a045f4 	movhi	r2,33047
81146e54:	10b84c04 	addi	r2,r2,-7888
81146e58:	10800383 	ldbu	r2,14(r2)
81146e5c:	10803fcc 	andi	r2,r2,255
81146e60:	10bfffc4 	addi	r2,r2,-1
81146e64:	1880401e 	bne	r3,r2,81146f68 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81146e68:	e0ffff0f 	ldh	r3,-4(fp)
81146e6c:	00a045f4 	movhi	r2,33047
81146e70:	10b86104 	addi	r2,r2,-7804
81146e74:	180691ba 	slli	r3,r3,6
81146e78:	10c5883a 	add	r2,r2,r3
81146e7c:	10800704 	addi	r2,r2,28
81146e80:	10800017 	ldw	r2,0(r2)
81146e84:	e0fffe04 	addi	r3,fp,-8
81146e88:	180b883a 	mov	r5,r3
81146e8c:	1009883a 	mov	r4,r2
81146e90:	114367c0 	call	8114367c <get_cluster_flag>
81146e94:	10003226 	beq	r2,zero,81146f60 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81146e98:	e0bffe0b 	ldhu	r2,-8(fp)
81146e9c:	10bfffcc 	andi	r2,r2,65535
81146ea0:	10fffe0c 	andi	r3,r2,65528
81146ea4:	00bffe14 	movui	r2,65528
81146ea8:	1880021e 	bne	r3,r2,81146eb4 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81146eac:	00bfffc4 	movi	r2,-1
81146eb0:	00006a06 	br	8114705c <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81146eb4:	e13fff0f 	ldh	r4,-4(fp)
81146eb8:	e0bffe0b 	ldhu	r2,-8(fp)
81146ebc:	10ffffcc 	andi	r3,r2,65535
81146ec0:	00a045f4 	movhi	r2,33047
81146ec4:	10b86104 	addi	r2,r2,-7804
81146ec8:	200891ba 	slli	r4,r4,6
81146ecc:	1105883a 	add	r2,r2,r4
81146ed0:	10800704 	addi	r2,r2,28
81146ed4:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81146ed8:	e0ffff0f 	ldh	r3,-4(fp)
81146edc:	00a045f4 	movhi	r2,33047
81146ee0:	10b86104 	addi	r2,r2,-7804
81146ee4:	180691ba 	slli	r3,r3,6
81146ee8:	10c5883a 	add	r2,r2,r3
81146eec:	10800804 	addi	r2,r2,32
81146ef0:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146ef4:	00a045f4 	movhi	r2,33047
81146ef8:	10b84c04 	addi	r2,r2,-7888
81146efc:	10c01417 	ldw	r3,80(r2)
81146f00:	e13fff0f 	ldh	r4,-4(fp)
81146f04:	00a045f4 	movhi	r2,33047
81146f08:	10b86104 	addi	r2,r2,-7804
81146f0c:	200891ba 	slli	r4,r4,6
81146f10:	1105883a 	add	r2,r2,r4
81146f14:	10800704 	addi	r2,r2,28
81146f18:	10800017 	ldw	r2,0(r2)
81146f1c:	113fff84 	addi	r4,r2,-2
81146f20:	00a045f4 	movhi	r2,33047
81146f24:	10b84c04 	addi	r2,r2,-7888
81146f28:	10800383 	ldbu	r2,14(r2)
81146f2c:	10803fcc 	andi	r2,r2,255
81146f30:	2085383a 	mul	r2,r4,r2
81146f34:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81146f38:	e13fff0f 	ldh	r4,-4(fp)
81146f3c:	00a045f4 	movhi	r2,33047
81146f40:	10b86104 	addi	r2,r2,-7804
81146f44:	200891ba 	slli	r4,r4,6
81146f48:	1105883a 	add	r2,r2,r4
81146f4c:	10800804 	addi	r2,r2,32
81146f50:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146f54:	1885883a 	add	r2,r3,r2
81146f58:	e0bffd15 	stw	r2,-12(fp)
81146f5c:	00001406 	br	81146fb0 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81146f60:	00bfff84 	movi	r2,-2
81146f64:	00003d06 	br	8114705c <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81146f68:	e13fff0f 	ldh	r4,-4(fp)
81146f6c:	e0ffff0f 	ldh	r3,-4(fp)
81146f70:	00a045f4 	movhi	r2,33047
81146f74:	10b86104 	addi	r2,r2,-7804
81146f78:	180691ba 	slli	r3,r3,6
81146f7c:	10c5883a 	add	r2,r2,r3
81146f80:	10800804 	addi	r2,r2,32
81146f84:	10800017 	ldw	r2,0(r2)
81146f88:	10c00044 	addi	r3,r2,1
81146f8c:	00a045f4 	movhi	r2,33047
81146f90:	10b86104 	addi	r2,r2,-7804
81146f94:	200891ba 	slli	r4,r4,6
81146f98:	1105883a 	add	r2,r2,r4
81146f9c:	10800804 	addi	r2,r2,32
81146fa0:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81146fa4:	e0bffd17 	ldw	r2,-12(fp)
81146fa8:	10800044 	addi	r2,r2,1
81146fac:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81146fb0:	d0e0b117 	ldw	r3,-32060(gp)
81146fb4:	e0bffd17 	ldw	r2,-12(fp)
81146fb8:	1885883a 	add	r2,r3,r2
81146fbc:	1007883a 	mov	r3,r2
81146fc0:	d0a0b517 	ldw	r2,-32044(gp)
81146fc4:	18800726 	beq	r3,r2,81146fe4 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81146fc8:	d0a0b117 	ldw	r2,-32060(gp)
81146fcc:	100b883a 	mov	r5,r2
81146fd0:	e13ffd17 	ldw	r4,-12(fp)
81146fd4:	114359c0 	call	8114359c <Read_Sector_Data>
81146fd8:	1000021e 	bne	r2,zero,81146fe4 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81146fdc:	00bfff84 	movi	r2,-2
81146fe0:	00001e06 	br	8114705c <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81146fe4:	d0e0b017 	ldw	r3,-32064(gp)
81146fe8:	e13fff0f 	ldh	r4,-4(fp)
81146fec:	00a045f4 	movhi	r2,33047
81146ff0:	10b86104 	addi	r2,r2,-7804
81146ff4:	200891ba 	slli	r4,r4,6
81146ff8:	1105883a 	add	r2,r2,r4
81146ffc:	10800904 	addi	r2,r2,36
81147000:	10800017 	ldw	r2,0(r2)
81147004:	10807fcc 	andi	r2,r2,511
81147008:	1885883a 	add	r2,r3,r2
8114700c:	10800023 	ldbuio	r2,0(r2)
81147010:	10803fcc 	andi	r2,r2,255
81147014:	10803fcc 	andi	r2,r2,255
81147018:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8114701c:	e13fff0f 	ldh	r4,-4(fp)
81147020:	e0ffff0f 	ldh	r3,-4(fp)
81147024:	00a045f4 	movhi	r2,33047
81147028:	10b86104 	addi	r2,r2,-7804
8114702c:	180691ba 	slli	r3,r3,6
81147030:	10c5883a 	add	r2,r2,r3
81147034:	10800904 	addi	r2,r2,36
81147038:	10800017 	ldw	r2,0(r2)
8114703c:	10c00044 	addi	r3,r2,1
81147040:	00a045f4 	movhi	r2,33047
81147044:	10b86104 	addi	r2,r2,-7804
81147048:	200891ba 	slli	r4,r4,6
8114704c:	1105883a 	add	r2,r2,r4
81147050:	10800904 	addi	r2,r2,36
81147054:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81147058:	e0bffc0b 	ldhu	r2,-16(fp)
}
8114705c:	e037883a 	mov	sp,fp
81147060:	dfc00117 	ldw	ra,4(sp)
81147064:	df000017 	ldw	fp,0(sp)
81147068:	dec00204 	addi	sp,sp,8
8114706c:	f800283a 	ret

81147070 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81147070:	defff804 	addi	sp,sp,-32
81147074:	de00012e 	bgeu	sp,et,8114707c <alt_up_sd_card_write+0xc>
81147078:	003b68fa 	trap	3
8114707c:	dfc00715 	stw	ra,28(sp)
81147080:	df000615 	stw	fp,24(sp)
81147084:	df000604 	addi	fp,sp,24
81147088:	2007883a 	mov	r3,r4
8114708c:	2805883a 	mov	r2,r5
81147090:	e0fffe0d 	sth	r3,-8(fp)
81147094:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81147098:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8114709c:	e0bffe0f 	ldh	r2,-8(fp)
811470a0:	10017716 	blt	r2,zero,81147680 <alt_up_sd_card_write+0x610>
811470a4:	e0bffe0f 	ldh	r2,-8(fp)
811470a8:	10800508 	cmpgei	r2,r2,20
811470ac:	1001741e 	bne	r2,zero,81147680 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
811470b0:	e0fffe0f 	ldh	r3,-8(fp)
811470b4:	00a045f4 	movhi	r2,33047
811470b8:	10b86104 	addi	r2,r2,-7804
811470bc:	180691ba 	slli	r3,r3,6
811470c0:	10c5883a 	add	r2,r2,r3
811470c4:	10800f04 	addi	r2,r2,60
811470c8:	10800017 	ldw	r2,0(r2)
811470cc:	10016c26 	beq	r2,zero,81147680 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811470d0:	00a045f4 	movhi	r2,33047
811470d4:	10b84c04 	addi	r2,r2,-7888
811470d8:	10c01417 	ldw	r3,80(r2)
811470dc:	e13ffe0f 	ldh	r4,-8(fp)
811470e0:	00a045f4 	movhi	r2,33047
811470e4:	10b86104 	addi	r2,r2,-7804
811470e8:	200891ba 	slli	r4,r4,6
811470ec:	1105883a 	add	r2,r2,r4
811470f0:	10800704 	addi	r2,r2,28
811470f4:	10800017 	ldw	r2,0(r2)
811470f8:	113fff84 	addi	r4,r2,-2
811470fc:	00a045f4 	movhi	r2,33047
81147100:	10b84c04 	addi	r2,r2,-7888
81147104:	10800383 	ldbu	r2,14(r2)
81147108:	10803fcc 	andi	r2,r2,255
8114710c:	2085383a 	mul	r2,r4,r2
81147110:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81147114:	e13ffe0f 	ldh	r4,-8(fp)
81147118:	00a045f4 	movhi	r2,33047
8114711c:	10b86104 	addi	r2,r2,-7804
81147120:	200891ba 	slli	r4,r4,6
81147124:	1105883a 	add	r2,r2,r4
81147128:	10800804 	addi	r2,r2,32
8114712c:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147130:	1885883a 	add	r2,r3,r2
81147134:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81147138:	e0fffe0f 	ldh	r3,-8(fp)
8114713c:	00a045f4 	movhi	r2,33047
81147140:	10b86104 	addi	r2,r2,-7804
81147144:	180691ba 	slli	r3,r3,6
81147148:	10c5883a 	add	r2,r2,r3
8114714c:	10800904 	addi	r2,r2,36
81147150:	10c00017 	ldw	r3,0(r2)
81147154:	00a045f4 	movhi	r2,33047
81147158:	10b84c04 	addi	r2,r2,-7888
8114715c:	1080030b 	ldhu	r2,12(r2)
81147160:	10bfffcc 	andi	r2,r2,65535
81147164:	1889203a 	divu	r4,r3,r2
81147168:	2085383a 	mul	r2,r4,r2
8114716c:	1885c83a 	sub	r2,r3,r2
81147170:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81147174:	e0fffe0f 	ldh	r3,-8(fp)
81147178:	00a045f4 	movhi	r2,33047
8114717c:	10b86104 	addi	r2,r2,-7804
81147180:	180691ba 	slli	r3,r3,6
81147184:	10c5883a 	add	r2,r2,r3
81147188:	10800904 	addi	r2,r2,36
8114718c:	10c00017 	ldw	r3,0(r2)
81147190:	e13ffe0f 	ldh	r4,-8(fp)
81147194:	00a045f4 	movhi	r2,33047
81147198:	10b86104 	addi	r2,r2,-7804
8114719c:	200891ba 	slli	r4,r4,6
811471a0:	1105883a 	add	r2,r2,r4
811471a4:	10800604 	addi	r2,r2,24
811471a8:	10800017 	ldw	r2,0(r2)
811471ac:	1880672e 	bgeu	r3,r2,8114734c <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
811471b0:	e0fffe0f 	ldh	r3,-8(fp)
811471b4:	00a045f4 	movhi	r2,33047
811471b8:	10b86104 	addi	r2,r2,-7804
811471bc:	180691ba 	slli	r3,r3,6
811471c0:	10c5883a 	add	r2,r2,r3
811471c4:	10800904 	addi	r2,r2,36
811471c8:	10800017 	ldw	r2,0(r2)
811471cc:	1000e126 	beq	r2,zero,81147554 <alt_up_sd_card_write+0x4e4>
811471d0:	e0bffc0f 	ldh	r2,-16(fp)
811471d4:	1000df1e 	bne	r2,zero,81147554 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811471d8:	e0fffe0f 	ldh	r3,-8(fp)
811471dc:	00a045f4 	movhi	r2,33047
811471e0:	10b86104 	addi	r2,r2,-7804
811471e4:	180691ba 	slli	r3,r3,6
811471e8:	10c5883a 	add	r2,r2,r3
811471ec:	10800804 	addi	r2,r2,32
811471f0:	10c00017 	ldw	r3,0(r2)
811471f4:	00a045f4 	movhi	r2,33047
811471f8:	10b84c04 	addi	r2,r2,-7888
811471fc:	10800383 	ldbu	r2,14(r2)
81147200:	10803fcc 	andi	r2,r2,255
81147204:	10bfffc4 	addi	r2,r2,-1
81147208:	18803d1e 	bne	r3,r2,81147300 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8114720c:	e0fffe0f 	ldh	r3,-8(fp)
81147210:	00a045f4 	movhi	r2,33047
81147214:	10b86104 	addi	r2,r2,-7804
81147218:	180691ba 	slli	r3,r3,6
8114721c:	10c5883a 	add	r2,r2,r3
81147220:	10800704 	addi	r2,r2,28
81147224:	10800017 	ldw	r2,0(r2)
81147228:	e0fffc84 	addi	r3,fp,-14
8114722c:	180b883a 	mov	r5,r3
81147230:	1009883a 	mov	r4,r2
81147234:	114367c0 	call	8114367c <get_cluster_flag>
81147238:	10002f26 	beq	r2,zero,811472f8 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
8114723c:	e0bffc8b 	ldhu	r2,-14(fp)
81147240:	10bfffcc 	andi	r2,r2,65535
81147244:	10bffe28 	cmpgeui	r2,r2,65528
81147248:	1000c21e 	bne	r2,zero,81147554 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8114724c:	e13ffe0f 	ldh	r4,-8(fp)
81147250:	e0bffc8b 	ldhu	r2,-14(fp)
81147254:	10ffffcc 	andi	r3,r2,65535
81147258:	00a045f4 	movhi	r2,33047
8114725c:	10b86104 	addi	r2,r2,-7804
81147260:	200891ba 	slli	r4,r4,6
81147264:	1105883a 	add	r2,r2,r4
81147268:	10800704 	addi	r2,r2,28
8114726c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81147270:	e0fffe0f 	ldh	r3,-8(fp)
81147274:	00a045f4 	movhi	r2,33047
81147278:	10b86104 	addi	r2,r2,-7804
8114727c:	180691ba 	slli	r3,r3,6
81147280:	10c5883a 	add	r2,r2,r3
81147284:	10800804 	addi	r2,r2,32
81147288:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114728c:	00a045f4 	movhi	r2,33047
81147290:	10b84c04 	addi	r2,r2,-7888
81147294:	10c01417 	ldw	r3,80(r2)
81147298:	e13ffe0f 	ldh	r4,-8(fp)
8114729c:	00a045f4 	movhi	r2,33047
811472a0:	10b86104 	addi	r2,r2,-7804
811472a4:	200891ba 	slli	r4,r4,6
811472a8:	1105883a 	add	r2,r2,r4
811472ac:	10800704 	addi	r2,r2,28
811472b0:	10800017 	ldw	r2,0(r2)
811472b4:	113fff84 	addi	r4,r2,-2
811472b8:	00a045f4 	movhi	r2,33047
811472bc:	10b84c04 	addi	r2,r2,-7888
811472c0:	10800383 	ldbu	r2,14(r2)
811472c4:	10803fcc 	andi	r2,r2,255
811472c8:	2085383a 	mul	r2,r4,r2
811472cc:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
811472d0:	e13ffe0f 	ldh	r4,-8(fp)
811472d4:	00a045f4 	movhi	r2,33047
811472d8:	10b86104 	addi	r2,r2,-7804
811472dc:	200891ba 	slli	r4,r4,6
811472e0:	1105883a 	add	r2,r2,r4
811472e4:	10800804 	addi	r2,r2,32
811472e8:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811472ec:	1885883a 	add	r2,r3,r2
811472f0:	e0bffb15 	stw	r2,-20(fp)
811472f4:	00009706 	br	81147554 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
811472f8:	0005883a 	mov	r2,zero
811472fc:	0000e106 	br	81147684 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81147300:	e13ffe0f 	ldh	r4,-8(fp)
81147304:	e0fffe0f 	ldh	r3,-8(fp)
81147308:	00a045f4 	movhi	r2,33047
8114730c:	10b86104 	addi	r2,r2,-7804
81147310:	180691ba 	slli	r3,r3,6
81147314:	10c5883a 	add	r2,r2,r3
81147318:	10800804 	addi	r2,r2,32
8114731c:	10800017 	ldw	r2,0(r2)
81147320:	10c00044 	addi	r3,r2,1
81147324:	00a045f4 	movhi	r2,33047
81147328:	10b86104 	addi	r2,r2,-7804
8114732c:	200891ba 	slli	r4,r4,6
81147330:	1105883a 	add	r2,r2,r4
81147334:	10800804 	addi	r2,r2,32
81147338:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8114733c:	e0bffb17 	ldw	r2,-20(fp)
81147340:	10800044 	addi	r2,r2,1
81147344:	e0bffb15 	stw	r2,-20(fp)
81147348:	00008206 	br	81147554 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8114734c:	e0fffe0f 	ldh	r3,-8(fp)
81147350:	00a045f4 	movhi	r2,33047
81147354:	10b86104 	addi	r2,r2,-7804
81147358:	180691ba 	slli	r3,r3,6
8114735c:	10c5883a 	add	r2,r2,r3
81147360:	10800904 	addi	r2,r2,36
81147364:	10800017 	ldw	r2,0(r2)
81147368:	10007a26 	beq	r2,zero,81147554 <alt_up_sd_card_write+0x4e4>
8114736c:	e0bffc0f 	ldh	r2,-16(fp)
81147370:	1000781e 	bne	r2,zero,81147554 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81147374:	e0fffe0f 	ldh	r3,-8(fp)
81147378:	00a045f4 	movhi	r2,33047
8114737c:	10b86104 	addi	r2,r2,-7804
81147380:	180691ba 	slli	r3,r3,6
81147384:	10c5883a 	add	r2,r2,r3
81147388:	10800804 	addi	r2,r2,32
8114738c:	10c00017 	ldw	r3,0(r2)
81147390:	00a045f4 	movhi	r2,33047
81147394:	10b84c04 	addi	r2,r2,-7888
81147398:	10800383 	ldbu	r2,14(r2)
8114739c:	10803fcc 	andi	r2,r2,255
811473a0:	10bfffc4 	addi	r2,r2,-1
811473a4:	18803e1e 	bne	r3,r2,811474a0 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
811473a8:	e0bffd04 	addi	r2,fp,-12
811473ac:	1009883a 	mov	r4,r2
811473b0:	11456c00 	call	811456c0 <find_first_empty_cluster>
811473b4:	10003826 	beq	r2,zero,81147498 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
811473b8:	e0fffe0f 	ldh	r3,-8(fp)
811473bc:	00a045f4 	movhi	r2,33047
811473c0:	10b86104 	addi	r2,r2,-7804
811473c4:	180691ba 	slli	r3,r3,6
811473c8:	10c5883a 	add	r2,r2,r3
811473cc:	10800704 	addi	r2,r2,28
811473d0:	10800017 	ldw	r2,0(r2)
811473d4:	e0fffd17 	ldw	r3,-12(fp)
811473d8:	18ffffcc 	andi	r3,r3,65535
811473dc:	18e0001c 	xori	r3,r3,32768
811473e0:	18e00004 	addi	r3,r3,-32768
811473e4:	01800044 	movi	r6,1
811473e8:	180b883a 	mov	r5,r3
811473ec:	1009883a 	mov	r4,r2
811473f0:	11437380 	call	81143738 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
811473f4:	e0bffd17 	ldw	r2,-12(fp)
811473f8:	01800044 	movi	r6,1
811473fc:	017fffc4 	movi	r5,-1
81147400:	1009883a 	mov	r4,r2
81147404:	11437380 	call	81143738 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
81147408:	e0fffe0f 	ldh	r3,-8(fp)
8114740c:	00a045f4 	movhi	r2,33047
81147410:	10b86104 	addi	r2,r2,-7804
81147414:	180691ba 	slli	r3,r3,6
81147418:	10c5883a 	add	r2,r2,r3
8114741c:	10800704 	addi	r2,r2,28
81147420:	10800017 	ldw	r2,0(r2)
81147424:	e0fffd17 	ldw	r3,-12(fp)
81147428:	18ffffcc 	andi	r3,r3,65535
8114742c:	18e0001c 	xori	r3,r3,32768
81147430:	18e00004 	addi	r3,r3,-32768
81147434:	000d883a 	mov	r6,zero
81147438:	180b883a 	mov	r5,r3
8114743c:	1009883a 	mov	r4,r2
81147440:	11437380 	call	81143738 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81147444:	e0bffd17 	ldw	r2,-12(fp)
81147448:	000d883a 	mov	r6,zero
8114744c:	017fffc4 	movi	r5,-1
81147450:	1009883a 	mov	r4,r2
81147454:	11437380 	call	81143738 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81147458:	e13ffe0f 	ldh	r4,-8(fp)
8114745c:	e0fffd17 	ldw	r3,-12(fp)
81147460:	00a045f4 	movhi	r2,33047
81147464:	10b86104 	addi	r2,r2,-7804
81147468:	200891ba 	slli	r4,r4,6
8114746c:	1105883a 	add	r2,r2,r4
81147470:	10800704 	addi	r2,r2,28
81147474:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81147478:	e0fffe0f 	ldh	r3,-8(fp)
8114747c:	00a045f4 	movhi	r2,33047
81147480:	10b86104 	addi	r2,r2,-7804
81147484:	180691ba 	slli	r3,r3,6
81147488:	10c5883a 	add	r2,r2,r3
8114748c:	10800804 	addi	r2,r2,32
81147490:	10000015 	stw	zero,0(r2)
81147494:	00001506 	br	811474ec <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81147498:	0005883a 	mov	r2,zero
8114749c:	00007906 	br	81147684 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
811474a0:	e13ffe0f 	ldh	r4,-8(fp)
811474a4:	e0fffe0f 	ldh	r3,-8(fp)
811474a8:	00a045f4 	movhi	r2,33047
811474ac:	10b86104 	addi	r2,r2,-7804
811474b0:	180691ba 	slli	r3,r3,6
811474b4:	10c5883a 	add	r2,r2,r3
811474b8:	10800904 	addi	r2,r2,36
811474bc:	10c00017 	ldw	r3,0(r2)
811474c0:	00a045f4 	movhi	r2,33047
811474c4:	10b84c04 	addi	r2,r2,-7888
811474c8:	1080030b 	ldhu	r2,12(r2)
811474cc:	10bfffcc 	andi	r2,r2,65535
811474d0:	1887203a 	divu	r3,r3,r2
811474d4:	00a045f4 	movhi	r2,33047
811474d8:	10b86104 	addi	r2,r2,-7804
811474dc:	200891ba 	slli	r4,r4,6
811474e0:	1105883a 	add	r2,r2,r4
811474e4:	10800804 	addi	r2,r2,32
811474e8:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811474ec:	00a045f4 	movhi	r2,33047
811474f0:	10b84c04 	addi	r2,r2,-7888
811474f4:	10c01417 	ldw	r3,80(r2)
811474f8:	e13ffe0f 	ldh	r4,-8(fp)
811474fc:	00a045f4 	movhi	r2,33047
81147500:	10b86104 	addi	r2,r2,-7804
81147504:	200891ba 	slli	r4,r4,6
81147508:	1105883a 	add	r2,r2,r4
8114750c:	10800704 	addi	r2,r2,28
81147510:	10800017 	ldw	r2,0(r2)
81147514:	113fff84 	addi	r4,r2,-2
81147518:	00a045f4 	movhi	r2,33047
8114751c:	10b84c04 	addi	r2,r2,-7888
81147520:	10800383 	ldbu	r2,14(r2)
81147524:	10803fcc 	andi	r2,r2,255
81147528:	2085383a 	mul	r2,r4,r2
8114752c:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81147530:	e13ffe0f 	ldh	r4,-8(fp)
81147534:	00a045f4 	movhi	r2,33047
81147538:	10b86104 	addi	r2,r2,-7804
8114753c:	200891ba 	slli	r4,r4,6
81147540:	1105883a 	add	r2,r2,r4
81147544:	10800804 	addi	r2,r2,32
81147548:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114754c:	1885883a 	add	r2,r3,r2
81147550:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81147554:	d0e0b117 	ldw	r3,-32060(gp)
81147558:	e0bffb17 	ldw	r2,-20(fp)
8114755c:	1885883a 	add	r2,r3,r2
81147560:	1007883a 	mov	r3,r2
81147564:	d0a0b517 	ldw	r2,-32044(gp)
81147568:	18800726 	beq	r3,r2,81147588 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8114756c:	d0a0b117 	ldw	r2,-32060(gp)
81147570:	100b883a 	mov	r5,r2
81147574:	e13ffb17 	ldw	r4,-20(fp)
81147578:	114359c0 	call	8114359c <Read_Sector_Data>
8114757c:	1000021e 	bne	r2,zero,81147588 <alt_up_sd_card_write+0x518>
                {
					return false;
81147580:	0005883a 	mov	r2,zero
81147584:	00003f06 	br	81147684 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81147588:	d0e0b017 	ldw	r3,-32064(gp)
8114758c:	e0bffc0f 	ldh	r2,-16(fp)
81147590:	1885883a 	add	r2,r3,r2
81147594:	e0ffff07 	ldb	r3,-4(fp)
81147598:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8114759c:	e13ffe0f 	ldh	r4,-8(fp)
811475a0:	e0fffe0f 	ldh	r3,-8(fp)
811475a4:	00a045f4 	movhi	r2,33047
811475a8:	10b86104 	addi	r2,r2,-7804
811475ac:	180691ba 	slli	r3,r3,6
811475b0:	10c5883a 	add	r2,r2,r3
811475b4:	10800904 	addi	r2,r2,36
811475b8:	10800017 	ldw	r2,0(r2)
811475bc:	10c00044 	addi	r3,r2,1
811475c0:	00a045f4 	movhi	r2,33047
811475c4:	10b86104 	addi	r2,r2,-7804
811475c8:	200891ba 	slli	r4,r4,6
811475cc:	1105883a 	add	r2,r2,r4
811475d0:	10800904 	addi	r2,r2,36
811475d4:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
811475d8:	e0fffe0f 	ldh	r3,-8(fp)
811475dc:	00a045f4 	movhi	r2,33047
811475e0:	10b86104 	addi	r2,r2,-7804
811475e4:	180691ba 	slli	r3,r3,6
811475e8:	10c5883a 	add	r2,r2,r3
811475ec:	10800904 	addi	r2,r2,36
811475f0:	10c00017 	ldw	r3,0(r2)
811475f4:	e13ffe0f 	ldh	r4,-8(fp)
811475f8:	00a045f4 	movhi	r2,33047
811475fc:	10b86104 	addi	r2,r2,-7804
81147600:	200891ba 	slli	r4,r4,6
81147604:	1105883a 	add	r2,r2,r4
81147608:	10800604 	addi	r2,r2,24
8114760c:	10800017 	ldw	r2,0(r2)
81147610:	18801736 	bltu	r3,r2,81147670 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81147614:	e13ffe0f 	ldh	r4,-8(fp)
81147618:	e0fffe0f 	ldh	r3,-8(fp)
8114761c:	00a045f4 	movhi	r2,33047
81147620:	10b86104 	addi	r2,r2,-7804
81147624:	180691ba 	slli	r3,r3,6
81147628:	10c5883a 	add	r2,r2,r3
8114762c:	10800604 	addi	r2,r2,24
81147630:	10800017 	ldw	r2,0(r2)
81147634:	10c00044 	addi	r3,r2,1
81147638:	00a045f4 	movhi	r2,33047
8114763c:	10b86104 	addi	r2,r2,-7804
81147640:	200891ba 	slli	r4,r4,6
81147644:	1105883a 	add	r2,r2,r4
81147648:	10800604 	addi	r2,r2,24
8114764c:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81147650:	e0fffe0f 	ldh	r3,-8(fp)
81147654:	00a045f4 	movhi	r2,33047
81147658:	10b86104 	addi	r2,r2,-7804
8114765c:	180691ba 	slli	r3,r3,6
81147660:	10c5883a 	add	r2,r2,r3
81147664:	10800e04 	addi	r2,r2,56
81147668:	00c00044 	movi	r3,1
8114766c:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81147670:	00800044 	movi	r2,1
81147674:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
81147678:	00800044 	movi	r2,1
8114767c:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81147680:	e0bffa17 	ldw	r2,-24(fp)
}
81147684:	e037883a 	mov	sp,fp
81147688:	dfc00117 	ldw	ra,4(sp)
8114768c:	df000017 	ldw	fp,0(sp)
81147690:	dec00204 	addi	sp,sp,8
81147694:	f800283a 	ret

81147698 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81147698:	defffb04 	addi	sp,sp,-20
8114769c:	de00012e 	bgeu	sp,et,811476a4 <alt_up_sd_card_fclose+0xc>
811476a0:	003b68fa 	trap	3
811476a4:	dfc00415 	stw	ra,16(sp)
811476a8:	df000315 	stw	fp,12(sp)
811476ac:	df000304 	addi	fp,sp,12
811476b0:	2005883a 	mov	r2,r4
811476b4:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
811476b8:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811476bc:	11462740 	call	81146274 <alt_up_sd_card_is_Present>
811476c0:	10006026 	beq	r2,zero,81147844 <alt_up_sd_card_fclose+0x1ac>
811476c4:	d0a0aa17 	ldw	r2,-32088(gp)
811476c8:	10005e26 	beq	r2,zero,81147844 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
811476cc:	e0ffff0f 	ldh	r3,-4(fp)
811476d0:	00a045f4 	movhi	r2,33047
811476d4:	10b86104 	addi	r2,r2,-7804
811476d8:	180691ba 	slli	r3,r3,6
811476dc:	10c5883a 	add	r2,r2,r3
811476e0:	10800f04 	addi	r2,r2,60
811476e4:	10800017 	ldw	r2,0(r2)
811476e8:	10005626 	beq	r2,zero,81147844 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
811476ec:	e0ffff0f 	ldh	r3,-4(fp)
811476f0:	00a045f4 	movhi	r2,33047
811476f4:	10b86104 	addi	r2,r2,-7804
811476f8:	180691ba 	slli	r3,r3,6
811476fc:	10c5883a 	add	r2,r2,r3
81147700:	10800e04 	addi	r2,r2,56
81147704:	10800017 	ldw	r2,0(r2)
81147708:	10004526 	beq	r2,zero,81147820 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
8114770c:	e0ffff0f 	ldh	r3,-4(fp)
81147710:	00a045f4 	movhi	r2,33047
81147714:	10b86104 	addi	r2,r2,-7804
81147718:	180691ba 	slli	r3,r3,6
8114771c:	10c5883a 	add	r2,r2,r3
81147720:	10800b04 	addi	r2,r2,44
81147724:	10800017 	ldw	r2,0(r2)
81147728:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
8114772c:	e0ffff0f 	ldh	r3,-4(fp)
81147730:	00a045f4 	movhi	r2,33047
81147734:	10b86104 	addi	r2,r2,-7804
81147738:	180691ba 	slli	r3,r3,6
8114773c:	10c5883a 	add	r2,r2,r3
81147740:	10800a04 	addi	r2,r2,40
81147744:	10800017 	ldw	r2,0(r2)
81147748:	1000071e 	bne	r2,zero,81147768 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
8114774c:	00a045f4 	movhi	r2,33047
81147750:	10b84c04 	addi	r2,r2,-7888
81147754:	10801317 	ldw	r2,76(r2)
81147758:	e0fffe17 	ldw	r3,-8(fp)
8114775c:	1885883a 	add	r2,r3,r2
81147760:	e0bffe15 	stw	r2,-8(fp)
81147764:	00001406 	br	811477b8 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81147768:	00a045f4 	movhi	r2,33047
8114776c:	10b84c04 	addi	r2,r2,-7888
81147770:	10c01417 	ldw	r3,80(r2)
81147774:	e0bffe17 	ldw	r2,-8(fp)
81147778:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8114777c:	e13fff0f 	ldh	r4,-4(fp)
81147780:	00a045f4 	movhi	r2,33047
81147784:	10b86104 	addi	r2,r2,-7804
81147788:	200891ba 	slli	r4,r4,6
8114778c:	1105883a 	add	r2,r2,r4
81147790:	10800a04 	addi	r2,r2,40
81147794:	10800017 	ldw	r2,0(r2)
81147798:	113fff84 	addi	r4,r2,-2
8114779c:	00a045f4 	movhi	r2,33047
811477a0:	10b84c04 	addi	r2,r2,-7888
811477a4:	10800383 	ldbu	r2,14(r2)
811477a8:	10803fcc 	andi	r2,r2,255
811477ac:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811477b0:	1885883a 	add	r2,r3,r2
811477b4:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
811477b8:	e0bffe17 	ldw	r2,-8(fp)
811477bc:	d0e0b117 	ldw	r3,-32060(gp)
811477c0:	180b883a 	mov	r5,r3
811477c4:	1009883a 	mov	r4,r2
811477c8:	114359c0 	call	8114359c <Read_Sector_Data>
811477cc:	10001426 	beq	r2,zero,81147820 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
811477d0:	e0ffff0f 	ldh	r3,-4(fp)
811477d4:	00a045f4 	movhi	r2,33047
811477d8:	10b86104 	addi	r2,r2,-7804
811477dc:	180691ba 	slli	r3,r3,6
811477e0:	10c5883a 	add	r2,r2,r3
811477e4:	10800c04 	addi	r2,r2,48
811477e8:	1080000b 	ldhu	r2,0(r2)
811477ec:	113fffcc 	andi	r4,r2,65535
811477f0:	2120001c 	xori	r4,r4,32768
811477f4:	21200004 	addi	r4,r4,-32768
811477f8:	e0bfff0f 	ldh	r2,-4(fp)
811477fc:	100691ba 	slli	r3,r2,6
81147800:	00a045f4 	movhi	r2,33047
81147804:	10b86104 	addi	r2,r2,-7804
81147808:	1885883a 	add	r2,r3,r2
8114780c:	100b883a 	mov	r5,r2
81147810:	1143c500 	call	81143c50 <Write_File_Record_At_Offset>
81147814:	10000226 	beq	r2,zero,81147820 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
81147818:	11435480 	call	81143548 <Save_Modified_Sector>
8114781c:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81147820:	e0ffff0f 	ldh	r3,-4(fp)
81147824:	00a045f4 	movhi	r2,33047
81147828:	10b86104 	addi	r2,r2,-7804
8114782c:	180691ba 	slli	r3,r3,6
81147830:	10c5883a 	add	r2,r2,r3
81147834:	10800f04 	addi	r2,r2,60
81147838:	10000015 	stw	zero,0(r2)
			result = true;
8114783c:	00800044 	movi	r2,1
81147840:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81147844:	e0bffd17 	ldw	r2,-12(fp)
}
81147848:	e037883a 	mov	sp,fp
8114784c:	dfc00117 	ldw	ra,4(sp)
81147850:	df000017 	ldw	fp,0(sp)
81147854:	dec00204 	addi	sp,sp,8
81147858:	f800283a 	ret

8114785c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8114785c:	defffa04 	addi	sp,sp,-24
81147860:	de00012e 	bgeu	sp,et,81147868 <altera_avalon_jtag_uart_read_fd+0xc>
81147864:	003b68fa 	trap	3
81147868:	dfc00515 	stw	ra,20(sp)
8114786c:	df000415 	stw	fp,16(sp)
81147870:	df000404 	addi	fp,sp,16
81147874:	e13ffd15 	stw	r4,-12(fp)
81147878:	e17ffe15 	stw	r5,-8(fp)
8114787c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81147880:	e0bffd17 	ldw	r2,-12(fp)
81147884:	10800017 	ldw	r2,0(r2)
81147888:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8114788c:	e0bffc17 	ldw	r2,-16(fp)
81147890:	10c00a04 	addi	r3,r2,40
81147894:	e0bffd17 	ldw	r2,-12(fp)
81147898:	10800217 	ldw	r2,8(r2)
8114789c:	100f883a 	mov	r7,r2
811478a0:	e1bfff17 	ldw	r6,-4(fp)
811478a4:	e17ffe17 	ldw	r5,-8(fp)
811478a8:	1809883a 	mov	r4,r3
811478ac:	11480e00 	call	811480e0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
811478b0:	e037883a 	mov	sp,fp
811478b4:	dfc00117 	ldw	ra,4(sp)
811478b8:	df000017 	ldw	fp,0(sp)
811478bc:	dec00204 	addi	sp,sp,8
811478c0:	f800283a 	ret

811478c4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811478c4:	defffa04 	addi	sp,sp,-24
811478c8:	de00012e 	bgeu	sp,et,811478d0 <altera_avalon_jtag_uart_write_fd+0xc>
811478cc:	003b68fa 	trap	3
811478d0:	dfc00515 	stw	ra,20(sp)
811478d4:	df000415 	stw	fp,16(sp)
811478d8:	df000404 	addi	fp,sp,16
811478dc:	e13ffd15 	stw	r4,-12(fp)
811478e0:	e17ffe15 	stw	r5,-8(fp)
811478e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811478e8:	e0bffd17 	ldw	r2,-12(fp)
811478ec:	10800017 	ldw	r2,0(r2)
811478f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
811478f4:	e0bffc17 	ldw	r2,-16(fp)
811478f8:	10c00a04 	addi	r3,r2,40
811478fc:	e0bffd17 	ldw	r2,-12(fp)
81147900:	10800217 	ldw	r2,8(r2)
81147904:	100f883a 	mov	r7,r2
81147908:	e1bfff17 	ldw	r6,-4(fp)
8114790c:	e17ffe17 	ldw	r5,-8(fp)
81147910:	1809883a 	mov	r4,r3
81147914:	11483a40 	call	811483a4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
81147918:	e037883a 	mov	sp,fp
8114791c:	dfc00117 	ldw	ra,4(sp)
81147920:	df000017 	ldw	fp,0(sp)
81147924:	dec00204 	addi	sp,sp,8
81147928:	f800283a 	ret

8114792c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
8114792c:	defffc04 	addi	sp,sp,-16
81147930:	de00012e 	bgeu	sp,et,81147938 <altera_avalon_jtag_uart_close_fd+0xc>
81147934:	003b68fa 	trap	3
81147938:	dfc00315 	stw	ra,12(sp)
8114793c:	df000215 	stw	fp,8(sp)
81147940:	df000204 	addi	fp,sp,8
81147944:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81147948:	e0bfff17 	ldw	r2,-4(fp)
8114794c:	10800017 	ldw	r2,0(r2)
81147950:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81147954:	e0bffe17 	ldw	r2,-8(fp)
81147958:	10c00a04 	addi	r3,r2,40
8114795c:	e0bfff17 	ldw	r2,-4(fp)
81147960:	10800217 	ldw	r2,8(r2)
81147964:	100b883a 	mov	r5,r2
81147968:	1809883a 	mov	r4,r3
8114796c:	1147f780 	call	81147f78 <altera_avalon_jtag_uart_close>
}
81147970:	e037883a 	mov	sp,fp
81147974:	dfc00117 	ldw	ra,4(sp)
81147978:	df000017 	ldw	fp,0(sp)
8114797c:	dec00204 	addi	sp,sp,8
81147980:	f800283a 	ret

81147984 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81147984:	defffa04 	addi	sp,sp,-24
81147988:	de00012e 	bgeu	sp,et,81147990 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8114798c:	003b68fa 	trap	3
81147990:	dfc00515 	stw	ra,20(sp)
81147994:	df000415 	stw	fp,16(sp)
81147998:	df000404 	addi	fp,sp,16
8114799c:	e13ffd15 	stw	r4,-12(fp)
811479a0:	e17ffe15 	stw	r5,-8(fp)
811479a4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
811479a8:	e0bffd17 	ldw	r2,-12(fp)
811479ac:	10800017 	ldw	r2,0(r2)
811479b0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
811479b4:	e0bffc17 	ldw	r2,-16(fp)
811479b8:	10800a04 	addi	r2,r2,40
811479bc:	e1bfff17 	ldw	r6,-4(fp)
811479c0:	e17ffe17 	ldw	r5,-8(fp)
811479c4:	1009883a 	mov	r4,r2
811479c8:	1147fe80 	call	81147fe8 <altera_avalon_jtag_uart_ioctl>
}
811479cc:	e037883a 	mov	sp,fp
811479d0:	dfc00117 	ldw	ra,4(sp)
811479d4:	df000017 	ldw	fp,0(sp)
811479d8:	dec00204 	addi	sp,sp,8
811479dc:	f800283a 	ret

811479e0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
811479e0:	deffef04 	addi	sp,sp,-68
811479e4:	de00012e 	bgeu	sp,et,811479ec <altera_avalon_jtag_uart_init+0xc>
811479e8:	003b68fa 	trap	3
811479ec:	dfc01015 	stw	ra,64(sp)
811479f0:	df000f15 	stw	fp,60(sp)
811479f4:	dc400e15 	stw	r17,56(sp)
811479f8:	dc000d15 	stw	r16,52(sp)
811479fc:	df000f04 	addi	fp,sp,60
81147a00:	e13ff715 	stw	r4,-36(fp)
81147a04:	e17ff815 	stw	r5,-32(fp)
81147a08:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81147a0c:	e0bff717 	ldw	r2,-36(fp)
81147a10:	10800c04 	addi	r2,r2,48
81147a14:	e0bff215 	stw	r2,-56(fp)
81147a18:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81147a1c:	e0bff60b 	ldhu	r2,-40(fp)
81147a20:	e0fff684 	addi	r3,fp,-38
81147a24:	180b883a 	mov	r5,r3
81147a28:	1009883a 	mov	r4,r2
81147a2c:	113bbb00 	call	8113bbb0 <OSFlagCreate>
81147a30:	1007883a 	mov	r3,r2
81147a34:	e0bff217 	ldw	r2,-56(fp)
81147a38:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81147a3c:	e0bff717 	ldw	r2,-36(fp)
81147a40:	10800a04 	addi	r2,r2,40
81147a44:	e0bff315 	stw	r2,-52(fp)
81147a48:	00800044 	movi	r2,1
81147a4c:	e0bff58d 	sth	r2,-42(fp)
81147a50:	e0bff58b 	ldhu	r2,-42(fp)
81147a54:	1009883a 	mov	r4,r2
81147a58:	113fb0c0 	call	8113fb0c <OSSemCreate>
81147a5c:	1007883a 	mov	r3,r2
81147a60:	e0bff317 	ldw	r2,-52(fp)
81147a64:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81147a68:	e0bff717 	ldw	r2,-36(fp)
81147a6c:	10800b04 	addi	r2,r2,44
81147a70:	e0bff415 	stw	r2,-48(fp)
81147a74:	00800044 	movi	r2,1
81147a78:	e0bff50d 	sth	r2,-44(fp)
81147a7c:	e0bff50b 	ldhu	r2,-44(fp)
81147a80:	1009883a 	mov	r4,r2
81147a84:	113fb0c0 	call	8113fb0c <OSSemCreate>
81147a88:	1007883a 	mov	r3,r2
81147a8c:	e0bff417 	ldw	r2,-48(fp)
81147a90:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81147a94:	e0bff717 	ldw	r2,-36(fp)
81147a98:	00c00044 	movi	r3,1
81147a9c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81147aa0:	e0bff717 	ldw	r2,-36(fp)
81147aa4:	10800017 	ldw	r2,0(r2)
81147aa8:	10800104 	addi	r2,r2,4
81147aac:	1007883a 	mov	r3,r2
81147ab0:	e0bff717 	ldw	r2,-36(fp)
81147ab4:	10800817 	ldw	r2,32(r2)
81147ab8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81147abc:	e0bff817 	ldw	r2,-32(fp)
81147ac0:	e0fff917 	ldw	r3,-28(fp)
81147ac4:	d8000015 	stw	zero,0(sp)
81147ac8:	e1fff717 	ldw	r7,-36(fp)
81147acc:	01a04534 	movhi	r6,33044
81147ad0:	319eec04 	addi	r6,r6,31664
81147ad4:	180b883a 	mov	r5,r3
81147ad8:	1009883a 	mov	r4,r2
81147adc:	114b8f80 	call	8114b8f8 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81147ae0:	e0bff717 	ldw	r2,-36(fp)
81147ae4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81147ae8:	e0bff717 	ldw	r2,-36(fp)
81147aec:	10800204 	addi	r2,r2,8
81147af0:	d0e08817 	ldw	r3,-32224(gp)
81147af4:	e1fff717 	ldw	r7,-36(fp)
81147af8:	01a04534 	movhi	r6,33044
81147afc:	319f9b04 	addi	r6,r6,32364
81147b00:	180b883a 	mov	r5,r3
81147b04:	1009883a 	mov	r4,r2
81147b08:	114b4480 	call	8114b448 <alt_alarm_start>
81147b0c:	1000040e 	bge	r2,zero,81147b20 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81147b10:	e0fff717 	ldw	r3,-36(fp)
81147b14:	00a00034 	movhi	r2,32768
81147b18:	10bfffc4 	addi	r2,r2,-1
81147b1c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81147b20:	d0a08183 	ldbu	r2,-32250(gp)
81147b24:	10803fcc 	andi	r2,r2,255
81147b28:	10800058 	cmpnei	r2,r2,1
81147b2c:	10000f1e 	bne	r2,zero,81147b6c <altera_avalon_jtag_uart_init+0x18c>
81147b30:	d0e08817 	ldw	r3,-32224(gp)
81147b34:	00b33374 	movhi	r2,52429
81147b38:	10b33344 	addi	r2,r2,-13107
81147b3c:	1888383a 	mulxuu	r4,r3,r2
81147b40:	1885383a 	mul	r2,r3,r2
81147b44:	1021883a 	mov	r16,r2
81147b48:	2023883a 	mov	r17,r4
81147b4c:	8804d0fa 	srli	r2,r17,3
81147b50:	e1fff717 	ldw	r7,-36(fp)
81147b54:	01a04534 	movhi	r6,33044
81147b58:	31a0b804 	addi	r6,r6,-32032
81147b5c:	100b883a 	mov	r5,r2
81147b60:	012045f4 	movhi	r4,33047
81147b64:	21202004 	addi	r4,r4,-32640
81147b68:	114b4480 	call	8114b448 <alt_alarm_start>
81147b6c:	d0a08203 	ldbu	r2,-32248(gp)
81147b70:	10803fcc 	andi	r2,r2,255
81147b74:	10800058 	cmpnei	r2,r2,1
81147b78:	1000051e 	bne	r2,zero,81147b90 <altera_avalon_jtag_uart_init+0x1b0>
81147b7c:	e0bff717 	ldw	r2,-36(fp)
81147b80:	10800017 	ldw	r2,0(r2)
81147b84:	100b883a 	mov	r5,r2
81147b88:	e13ff717 	ldw	r4,-36(fp)
81147b8c:	11384780 	call	81138478 <alt_log_jtag_uart_startup_info>
}
81147b90:	0001883a 	nop
81147b94:	e6fffe04 	addi	sp,fp,-8
81147b98:	dfc00317 	ldw	ra,12(sp)
81147b9c:	df000217 	ldw	fp,8(sp)
81147ba0:	dc400117 	ldw	r17,4(sp)
81147ba4:	dc000017 	ldw	r16,0(sp)
81147ba8:	dec00404 	addi	sp,sp,16
81147bac:	f800283a 	ret

81147bb0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81147bb0:	defff204 	addi	sp,sp,-56
81147bb4:	de00012e 	bgeu	sp,et,81147bbc <altera_avalon_jtag_uart_irq+0xc>
81147bb8:	003b68fa 	trap	3
81147bbc:	dfc00d15 	stw	ra,52(sp)
81147bc0:	df000c15 	stw	fp,48(sp)
81147bc4:	df000c04 	addi	fp,sp,48
81147bc8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81147bcc:	e0bfff17 	ldw	r2,-4(fp)
81147bd0:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81147bd4:	e0bff617 	ldw	r2,-40(fp)
81147bd8:	10800017 	ldw	r2,0(r2)
81147bdc:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81147be0:	e0bff717 	ldw	r2,-36(fp)
81147be4:	e17ff617 	ldw	r5,-40(fp)
81147be8:	1009883a 	mov	r4,r2
81147bec:	11384cc0 	call	811384cc <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81147bf0:	e0bff717 	ldw	r2,-36(fp)
81147bf4:	10800104 	addi	r2,r2,4
81147bf8:	10800037 	ldwio	r2,0(r2)
81147bfc:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81147c00:	e0bff817 	ldw	r2,-32(fp)
81147c04:	1080c00c 	andi	r2,r2,768
81147c08:	10009126 	beq	r2,zero,81147e50 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81147c0c:	e0bff817 	ldw	r2,-32(fp)
81147c10:	1080400c 	andi	r2,r2,256
81147c14:	10004726 	beq	r2,zero,81147d34 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
81147c18:	00800074 	movhi	r2,1
81147c1c:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81147c20:	e0bff617 	ldw	r2,-40(fp)
81147c24:	10800d17 	ldw	r2,52(r2)
81147c28:	10800044 	addi	r2,r2,1
81147c2c:	1081ffcc 	andi	r2,r2,2047
81147c30:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81147c34:	e0bff617 	ldw	r2,-40(fp)
81147c38:	10c00e17 	ldw	r3,56(r2)
81147c3c:	e0bff917 	ldw	r2,-28(fp)
81147c40:	18802726 	beq	r3,r2,81147ce0 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81147c44:	e0bff717 	ldw	r2,-36(fp)
81147c48:	10800037 	ldwio	r2,0(r2)
81147c4c:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81147c50:	e0bff417 	ldw	r2,-48(fp)
81147c54:	10a0000c 	andi	r2,r2,32768
81147c58:	10002326 	beq	r2,zero,81147ce8 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81147c5c:	e0bff617 	ldw	r2,-40(fp)
81147c60:	10800d17 	ldw	r2,52(r2)
81147c64:	e0fff417 	ldw	r3,-48(fp)
81147c68:	1809883a 	mov	r4,r3
81147c6c:	e0fff617 	ldw	r3,-40(fp)
81147c70:	1885883a 	add	r2,r3,r2
81147c74:	10801104 	addi	r2,r2,68
81147c78:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81147c7c:	e0bff617 	ldw	r2,-40(fp)
81147c80:	10800d17 	ldw	r2,52(r2)
81147c84:	10800044 	addi	r2,r2,1
81147c88:	10c1ffcc 	andi	r3,r2,2047
81147c8c:	e0bff617 	ldw	r2,-40(fp)
81147c90:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81147c94:	e0bff617 	ldw	r2,-40(fp)
81147c98:	10800c17 	ldw	r2,48(r2)
81147c9c:	e0bffb15 	stw	r2,-20(fp)
81147ca0:	00800044 	movi	r2,1
81147ca4:	e0bffc0d 	sth	r2,-16(fp)
81147ca8:	00800044 	movi	r2,1
81147cac:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147cb0:	d0a09103 	ldbu	r2,-32188(gp)
81147cb4:	10803fcc 	andi	r2,r2,255
81147cb8:	103fd926 	beq	r2,zero,81147c20 <__reset+0xfb127c20>
  {
    OSFlagPost (group, flags, opt, &err);
81147cbc:	e0bffc0b 	ldhu	r2,-16(fp)
81147cc0:	e0fffc83 	ldbu	r3,-14(fp)
81147cc4:	e13ffdc4 	addi	r4,fp,-9
81147cc8:	200f883a 	mov	r7,r4
81147ccc:	180d883a 	mov	r6,r3
81147cd0:	100b883a 	mov	r5,r2
81147cd4:	e13ffb17 	ldw	r4,-20(fp)
81147cd8:	113c7bc0 	call	8113c7bc <OSFlagPost>
      }
81147cdc:	003fd006 	br	81147c20 <__reset+0xfb127c20>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81147ce0:	0001883a 	nop
81147ce4:	00000106 	br	81147cec <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81147ce8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81147cec:	e0bff417 	ldw	r2,-48(fp)
81147cf0:	10bfffec 	andhi	r2,r2,65535
81147cf4:	10000f26 	beq	r2,zero,81147d34 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81147cf8:	e0bff617 	ldw	r2,-40(fp)
81147cfc:	10c00817 	ldw	r3,32(r2)
81147d00:	00bfff84 	movi	r2,-2
81147d04:	1886703a 	and	r3,r3,r2
81147d08:	e0bff617 	ldw	r2,-40(fp)
81147d0c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81147d10:	e0bff717 	ldw	r2,-36(fp)
81147d14:	10800104 	addi	r2,r2,4
81147d18:	1007883a 	mov	r3,r2
81147d1c:	e0bff617 	ldw	r2,-40(fp)
81147d20:	10800817 	ldw	r2,32(r2)
81147d24:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81147d28:	e0bff717 	ldw	r2,-36(fp)
81147d2c:	10800104 	addi	r2,r2,4
81147d30:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81147d34:	e0bff817 	ldw	r2,-32(fp)
81147d38:	1080800c 	andi	r2,r2,512
81147d3c:	103fac26 	beq	r2,zero,81147bf0 <__reset+0xfb127bf0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81147d40:	e0bff817 	ldw	r2,-32(fp)
81147d44:	1004d43a 	srli	r2,r2,16
81147d48:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81147d4c:	00002606 	br	81147de8 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81147d50:	e0bff717 	ldw	r2,-36(fp)
81147d54:	e0fff617 	ldw	r3,-40(fp)
81147d58:	18c01017 	ldw	r3,64(r3)
81147d5c:	e13ff617 	ldw	r4,-40(fp)
81147d60:	20c7883a 	add	r3,r4,r3
81147d64:	18c21104 	addi	r3,r3,2116
81147d68:	18c00003 	ldbu	r3,0(r3)
81147d6c:	18c03fcc 	andi	r3,r3,255
81147d70:	18c0201c 	xori	r3,r3,128
81147d74:	18ffe004 	addi	r3,r3,-128
81147d78:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81147d7c:	e0bff617 	ldw	r2,-40(fp)
81147d80:	10801017 	ldw	r2,64(r2)
81147d84:	10800044 	addi	r2,r2,1
81147d88:	10c1ffcc 	andi	r3,r2,2047
81147d8c:	e0bff617 	ldw	r2,-40(fp)
81147d90:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81147d94:	e0bff617 	ldw	r2,-40(fp)
81147d98:	10800c17 	ldw	r2,48(r2)
81147d9c:	e0bffa15 	stw	r2,-24(fp)
81147da0:	00800084 	movi	r2,2
81147da4:	e0bffd0d 	sth	r2,-12(fp)
81147da8:	00800044 	movi	r2,1
81147dac:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147db0:	d0a09103 	ldbu	r2,-32188(gp)
81147db4:	10803fcc 	andi	r2,r2,255
81147db8:	10000826 	beq	r2,zero,81147ddc <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81147dbc:	e0bffd0b 	ldhu	r2,-12(fp)
81147dc0:	e0fffd83 	ldbu	r3,-10(fp)
81147dc4:	e13ffe04 	addi	r4,fp,-8
81147dc8:	200f883a 	mov	r7,r4
81147dcc:	180d883a 	mov	r6,r3
81147dd0:	100b883a 	mov	r5,r2
81147dd4:	e13ffa17 	ldw	r4,-24(fp)
81147dd8:	113c7bc0 	call	8113c7bc <OSFlagPost>

        space--;
81147ddc:	e0bff517 	ldw	r2,-44(fp)
81147de0:	10bfffc4 	addi	r2,r2,-1
81147de4:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81147de8:	e0bff517 	ldw	r2,-44(fp)
81147dec:	10000526 	beq	r2,zero,81147e04 <altera_avalon_jtag_uart_irq+0x254>
81147df0:	e0bff617 	ldw	r2,-40(fp)
81147df4:	10c01017 	ldw	r3,64(r2)
81147df8:	e0bff617 	ldw	r2,-40(fp)
81147dfc:	10800f17 	ldw	r2,60(r2)
81147e00:	18bfd31e 	bne	r3,r2,81147d50 <__reset+0xfb127d50>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81147e04:	e0bff517 	ldw	r2,-44(fp)
81147e08:	103f7926 	beq	r2,zero,81147bf0 <__reset+0xfb127bf0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81147e0c:	e0bff617 	ldw	r2,-40(fp)
81147e10:	10c00817 	ldw	r3,32(r2)
81147e14:	00bfff44 	movi	r2,-3
81147e18:	1886703a 	and	r3,r3,r2
81147e1c:	e0bff617 	ldw	r2,-40(fp)
81147e20:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81147e24:	e0bff617 	ldw	r2,-40(fp)
81147e28:	10800017 	ldw	r2,0(r2)
81147e2c:	10800104 	addi	r2,r2,4
81147e30:	1007883a 	mov	r3,r2
81147e34:	e0bff617 	ldw	r2,-40(fp)
81147e38:	10800817 	ldw	r2,32(r2)
81147e3c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81147e40:	e0bff717 	ldw	r2,-36(fp)
81147e44:	10800104 	addi	r2,r2,4
81147e48:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81147e4c:	003f6806 	br	81147bf0 <__reset+0xfb127bf0>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81147e50:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81147e54:	0001883a 	nop
81147e58:	e037883a 	mov	sp,fp
81147e5c:	dfc00117 	ldw	ra,4(sp)
81147e60:	df000017 	ldw	fp,0(sp)
81147e64:	dec00204 	addi	sp,sp,8
81147e68:	f800283a 	ret

81147e6c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81147e6c:	defff904 	addi	sp,sp,-28
81147e70:	de00012e 	bgeu	sp,et,81147e78 <altera_avalon_jtag_uart_timeout+0xc>
81147e74:	003b68fa 	trap	3
81147e78:	dfc00615 	stw	ra,24(sp)
81147e7c:	df000515 	stw	fp,20(sp)
81147e80:	df000504 	addi	fp,sp,20
81147e84:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81147e88:	e0bfff17 	ldw	r2,-4(fp)
81147e8c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81147e90:	e0bffb17 	ldw	r2,-20(fp)
81147e94:	10800017 	ldw	r2,0(r2)
81147e98:	10800104 	addi	r2,r2,4
81147e9c:	10800037 	ldwio	r2,0(r2)
81147ea0:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81147ea4:	e0bffc17 	ldw	r2,-16(fp)
81147ea8:	1081000c 	andi	r2,r2,1024
81147eac:	10000b26 	beq	r2,zero,81147edc <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81147eb0:	e0bffb17 	ldw	r2,-20(fp)
81147eb4:	10800017 	ldw	r2,0(r2)
81147eb8:	10800104 	addi	r2,r2,4
81147ebc:	1007883a 	mov	r3,r2
81147ec0:	e0bffb17 	ldw	r2,-20(fp)
81147ec4:	10800817 	ldw	r2,32(r2)
81147ec8:	10810014 	ori	r2,r2,1024
81147ecc:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81147ed0:	e0bffb17 	ldw	r2,-20(fp)
81147ed4:	10000915 	stw	zero,36(r2)
81147ed8:	00002106 	br	81147f60 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81147edc:	e0bffb17 	ldw	r2,-20(fp)
81147ee0:	10c00917 	ldw	r3,36(r2)
81147ee4:	00a00034 	movhi	r2,32768
81147ee8:	10bfff04 	addi	r2,r2,-4
81147eec:	10c01c36 	bltu	r2,r3,81147f60 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81147ef0:	e0bffb17 	ldw	r2,-20(fp)
81147ef4:	10800917 	ldw	r2,36(r2)
81147ef8:	10c00044 	addi	r3,r2,1
81147efc:	e0bffb17 	ldw	r2,-20(fp)
81147f00:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81147f04:	e0bffb17 	ldw	r2,-20(fp)
81147f08:	10c00917 	ldw	r3,36(r2)
81147f0c:	e0bffb17 	ldw	r2,-20(fp)
81147f10:	10800117 	ldw	r2,4(r2)
81147f14:	18801236 	bltu	r3,r2,81147f60 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81147f18:	e0bffb17 	ldw	r2,-20(fp)
81147f1c:	10800c17 	ldw	r2,48(r2)
81147f20:	e0bffd15 	stw	r2,-12(fp)
81147f24:	00800104 	movi	r2,4
81147f28:	e0bffe0d 	sth	r2,-8(fp)
81147f2c:	00800044 	movi	r2,1
81147f30:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147f34:	d0a09103 	ldbu	r2,-32188(gp)
81147f38:	10803fcc 	andi	r2,r2,255
81147f3c:	10000826 	beq	r2,zero,81147f60 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81147f40:	e0bffe0b 	ldhu	r2,-8(fp)
81147f44:	e0fffe83 	ldbu	r3,-6(fp)
81147f48:	e13ffec4 	addi	r4,fp,-5
81147f4c:	200f883a 	mov	r7,r4
81147f50:	180d883a 	mov	r6,r3
81147f54:	100b883a 	mov	r5,r2
81147f58:	e13ffd17 	ldw	r4,-12(fp)
81147f5c:	113c7bc0 	call	8113c7bc <OSFlagPost>
81147f60:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
81147f64:	e037883a 	mov	sp,fp
81147f68:	dfc00117 	ldw	ra,4(sp)
81147f6c:	df000017 	ldw	fp,0(sp)
81147f70:	dec00204 	addi	sp,sp,8
81147f74:	f800283a 	ret

81147f78 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81147f78:	defffd04 	addi	sp,sp,-12
81147f7c:	de00012e 	bgeu	sp,et,81147f84 <altera_avalon_jtag_uart_close+0xc>
81147f80:	003b68fa 	trap	3
81147f84:	df000215 	stw	fp,8(sp)
81147f88:	df000204 	addi	fp,sp,8
81147f8c:	e13ffe15 	stw	r4,-8(fp)
81147f90:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81147f94:	00000506 	br	81147fac <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81147f98:	e0bfff17 	ldw	r2,-4(fp)
81147f9c:	1090000c 	andi	r2,r2,16384
81147fa0:	10000226 	beq	r2,zero,81147fac <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81147fa4:	00bffd44 	movi	r2,-11
81147fa8:	00000b06 	br	81147fd8 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81147fac:	e0bffe17 	ldw	r2,-8(fp)
81147fb0:	10c01017 	ldw	r3,64(r2)
81147fb4:	e0bffe17 	ldw	r2,-8(fp)
81147fb8:	10800f17 	ldw	r2,60(r2)
81147fbc:	18800526 	beq	r3,r2,81147fd4 <altera_avalon_jtag_uart_close+0x5c>
81147fc0:	e0bffe17 	ldw	r2,-8(fp)
81147fc4:	10c00917 	ldw	r3,36(r2)
81147fc8:	e0bffe17 	ldw	r2,-8(fp)
81147fcc:	10800117 	ldw	r2,4(r2)
81147fd0:	18bff136 	bltu	r3,r2,81147f98 <__reset+0xfb127f98>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81147fd4:	0005883a 	mov	r2,zero
}
81147fd8:	e037883a 	mov	sp,fp
81147fdc:	df000017 	ldw	fp,0(sp)
81147fe0:	dec00104 	addi	sp,sp,4
81147fe4:	f800283a 	ret

81147fe8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81147fe8:	defffa04 	addi	sp,sp,-24
81147fec:	de00012e 	bgeu	sp,et,81147ff4 <altera_avalon_jtag_uart_ioctl+0xc>
81147ff0:	003b68fa 	trap	3
81147ff4:	df000515 	stw	fp,20(sp)
81147ff8:	df000504 	addi	fp,sp,20
81147ffc:	e13ffd15 	stw	r4,-12(fp)
81148000:	e17ffe15 	stw	r5,-8(fp)
81148004:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81148008:	00bff9c4 	movi	r2,-25
8114800c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81148010:	e0bffe17 	ldw	r2,-8(fp)
81148014:	10da8060 	cmpeqi	r3,r2,27137
81148018:	1800031e 	bne	r3,zero,81148028 <altera_avalon_jtag_uart_ioctl+0x40>
8114801c:	109a80a0 	cmpeqi	r2,r2,27138
81148020:	1000181e 	bne	r2,zero,81148084 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81148024:	00002906 	br	811480cc <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81148028:	e0bffd17 	ldw	r2,-12(fp)
8114802c:	10c00117 	ldw	r3,4(r2)
81148030:	00a00034 	movhi	r2,32768
81148034:	10bfffc4 	addi	r2,r2,-1
81148038:	18802126 	beq	r3,r2,811480c0 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
8114803c:	e0bfff17 	ldw	r2,-4(fp)
81148040:	10800017 	ldw	r2,0(r2)
81148044:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81148048:	e0bffc17 	ldw	r2,-16(fp)
8114804c:	10800090 	cmplti	r2,r2,2
81148050:	1000061e 	bne	r2,zero,8114806c <altera_avalon_jtag_uart_ioctl+0x84>
81148054:	e0fffc17 	ldw	r3,-16(fp)
81148058:	00a00034 	movhi	r2,32768
8114805c:	10bfffc4 	addi	r2,r2,-1
81148060:	18800226 	beq	r3,r2,8114806c <altera_avalon_jtag_uart_ioctl+0x84>
81148064:	e0bffc17 	ldw	r2,-16(fp)
81148068:	00000206 	br	81148074 <altera_avalon_jtag_uart_ioctl+0x8c>
8114806c:	00a00034 	movhi	r2,32768
81148070:	10bfff84 	addi	r2,r2,-2
81148074:	e0fffd17 	ldw	r3,-12(fp)
81148078:	18800115 	stw	r2,4(r3)
      rc = 0;
8114807c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81148080:	00000f06 	br	811480c0 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81148084:	e0bffd17 	ldw	r2,-12(fp)
81148088:	10c00117 	ldw	r3,4(r2)
8114808c:	00a00034 	movhi	r2,32768
81148090:	10bfffc4 	addi	r2,r2,-1
81148094:	18800c26 	beq	r3,r2,811480c8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81148098:	e0bffd17 	ldw	r2,-12(fp)
8114809c:	10c00917 	ldw	r3,36(r2)
811480a0:	e0bffd17 	ldw	r2,-12(fp)
811480a4:	10800117 	ldw	r2,4(r2)
811480a8:	1885803a 	cmpltu	r2,r3,r2
811480ac:	10c03fcc 	andi	r3,r2,255
811480b0:	e0bfff17 	ldw	r2,-4(fp)
811480b4:	10c00015 	stw	r3,0(r2)
      rc = 0;
811480b8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
811480bc:	00000206 	br	811480c8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
811480c0:	0001883a 	nop
811480c4:	00000106 	br	811480cc <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
811480c8:	0001883a 	nop

  default:
    break;
  }

  return rc;
811480cc:	e0bffb17 	ldw	r2,-20(fp)
}
811480d0:	e037883a 	mov	sp,fp
811480d4:	df000017 	ldw	fp,0(sp)
811480d8:	dec00104 	addi	sp,sp,4
811480dc:	f800283a 	ret

811480e0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
811480e0:	deffed04 	addi	sp,sp,-76
811480e4:	de00012e 	bgeu	sp,et,811480ec <altera_avalon_jtag_uart_read+0xc>
811480e8:	003b68fa 	trap	3
811480ec:	dfc01215 	stw	ra,72(sp)
811480f0:	df001115 	stw	fp,68(sp)
811480f4:	df001104 	addi	fp,sp,68
811480f8:	e13ffc15 	stw	r4,-16(fp)
811480fc:	e17ffd15 	stw	r5,-12(fp)
81148100:	e1bffe15 	stw	r6,-8(fp)
81148104:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81148108:	e0bffd17 	ldw	r2,-12(fp)
8114810c:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81148110:	e0bffc17 	ldw	r2,-16(fp)
81148114:	10800a17 	ldw	r2,40(r2)
81148118:	e0bff815 	stw	r2,-32(fp)
8114811c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81148120:	e0bff90b 	ldhu	r2,-28(fp)
81148124:	e0fffb04 	addi	r3,fp,-20
81148128:	180d883a 	mov	r6,r3
8114812c:	100b883a 	mov	r5,r2
81148130:	e13ff817 	ldw	r4,-32(fp)
81148134:	113fe340 	call	8113fe34 <OSSemPend>

  while (space > 0)
81148138:	00006106 	br	811482c0 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
8114813c:	e0bffc17 	ldw	r2,-16(fp)
81148140:	10800d17 	ldw	r2,52(r2)
81148144:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81148148:	e0bffc17 	ldw	r2,-16(fp)
8114814c:	10800e17 	ldw	r2,56(r2)
81148150:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81148154:	e0fff317 	ldw	r3,-52(fp)
81148158:	e0bff417 	ldw	r2,-48(fp)
8114815c:	18800536 	bltu	r3,r2,81148174 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81148160:	e0fff317 	ldw	r3,-52(fp)
81148164:	e0bff417 	ldw	r2,-48(fp)
81148168:	1885c83a 	sub	r2,r3,r2
8114816c:	e0bff115 	stw	r2,-60(fp)
81148170:	00000406 	br	81148184 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81148174:	00c20004 	movi	r3,2048
81148178:	e0bff417 	ldw	r2,-48(fp)
8114817c:	1885c83a 	sub	r2,r3,r2
81148180:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81148184:	e0bff117 	ldw	r2,-60(fp)
81148188:	10001e26 	beq	r2,zero,81148204 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
8114818c:	e0fffe17 	ldw	r3,-8(fp)
81148190:	e0bff117 	ldw	r2,-60(fp)
81148194:	1880022e 	bgeu	r3,r2,811481a0 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81148198:	e0bffe17 	ldw	r2,-8(fp)
8114819c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
811481a0:	e0bffc17 	ldw	r2,-16(fp)
811481a4:	10c01104 	addi	r3,r2,68
811481a8:	e0bff417 	ldw	r2,-48(fp)
811481ac:	1885883a 	add	r2,r3,r2
811481b0:	e1bff117 	ldw	r6,-60(fp)
811481b4:	100b883a 	mov	r5,r2
811481b8:	e13ff017 	ldw	r4,-64(fp)
811481bc:	1123a440 	call	81123a44 <memcpy>
      ptr   += n;
811481c0:	e0fff017 	ldw	r3,-64(fp)
811481c4:	e0bff117 	ldw	r2,-60(fp)
811481c8:	1885883a 	add	r2,r3,r2
811481cc:	e0bff015 	stw	r2,-64(fp)
      space -= n;
811481d0:	e0fffe17 	ldw	r3,-8(fp)
811481d4:	e0bff117 	ldw	r2,-60(fp)
811481d8:	1885c83a 	sub	r2,r3,r2
811481dc:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811481e0:	e0fff417 	ldw	r3,-48(fp)
811481e4:	e0bff117 	ldw	r2,-60(fp)
811481e8:	1885883a 	add	r2,r3,r2
811481ec:	10c1ffcc 	andi	r3,r2,2047
811481f0:	e0bffc17 	ldw	r2,-16(fp)
811481f4:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
811481f8:	e0bffe17 	ldw	r2,-8(fp)
811481fc:	00bfcf16 	blt	zero,r2,8114813c <__reset+0xfb12813c>
81148200:	00000106 	br	81148208 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81148204:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81148208:	e0fff017 	ldw	r3,-64(fp)
8114820c:	e0bffd17 	ldw	r2,-12(fp)
81148210:	18802e1e 	bne	r3,r2,811482cc <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81148214:	e0bfff17 	ldw	r2,-4(fp)
81148218:	1090000c 	andi	r2,r2,16384
8114821c:	10002d1e 	bne	r2,zero,811482d4 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81148220:	d0a09103 	ldbu	r2,-32188(gp)
81148224:	10803fcc 	andi	r2,r2,255
81148228:	10800058 	cmpnei	r2,r2,1
8114822c:	1000161e 	bne	r2,zero,81148288 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81148230:	e0bffc17 	ldw	r2,-16(fp)
81148234:	10800c17 	ldw	r2,48(r2)
81148238:	e0bff215 	stw	r2,-56(fp)
8114823c:	00800144 	movi	r2,5
81148240:	e0bff98d 	sth	r2,-26(fp)
81148244:	00bfe0c4 	movi	r2,-125
81148248:	e0bffa05 	stb	r2,-24(fp)
8114824c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148250:	d0a09103 	ldbu	r2,-32188(gp)
81148254:	10803fcc 	andi	r2,r2,255
81148258:	10001526 	beq	r2,zero,811482b0 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8114825c:	e0fff98b 	ldhu	r3,-26(fp)
81148260:	e13ffa03 	ldbu	r4,-24(fp)
81148264:	e17ffa8b 	ldhu	r5,-22(fp)
81148268:	e0bffb44 	addi	r2,fp,-19
8114826c:	d8800015 	stw	r2,0(sp)
81148270:	280f883a 	mov	r7,r5
81148274:	200d883a 	mov	r6,r4
81148278:	180b883a 	mov	r5,r3
8114827c:	e13ff217 	ldw	r4,-56(fp)
81148280:	113c1940 	call	8113c194 <OSFlagPend>
81148284:	00000a06 	br	811482b0 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81148288:	0001883a 	nop
8114828c:	e0bffc17 	ldw	r2,-16(fp)
81148290:	10c00d17 	ldw	r3,52(r2)
81148294:	e0bff317 	ldw	r2,-52(fp)
81148298:	1880051e 	bne	r3,r2,811482b0 <altera_avalon_jtag_uart_read+0x1d0>
8114829c:	e0bffc17 	ldw	r2,-16(fp)
811482a0:	10c00917 	ldw	r3,36(r2)
811482a4:	e0bffc17 	ldw	r2,-16(fp)
811482a8:	10800117 	ldw	r2,4(r2)
811482ac:	18bff736 	bltu	r3,r2,8114828c <__reset+0xfb12828c>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
811482b0:	e0bffc17 	ldw	r2,-16(fp)
811482b4:	10c00d17 	ldw	r3,52(r2)
811482b8:	e0bff317 	ldw	r2,-52(fp)
811482bc:	18800726 	beq	r3,r2,811482dc <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
811482c0:	e0bffe17 	ldw	r2,-8(fp)
811482c4:	00bf9d16 	blt	zero,r2,8114813c <__reset+0xfb12813c>
811482c8:	00000506 	br	811482e0 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
811482cc:	0001883a 	nop
811482d0:	00000306 	br	811482e0 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
811482d4:	0001883a 	nop
811482d8:	00000106 	br	811482e0 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
811482dc:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
811482e0:	e0bffc17 	ldw	r2,-16(fp)
811482e4:	10800a17 	ldw	r2,40(r2)
811482e8:	1009883a 	mov	r4,r2
811482ec:	11401bc0 	call	811401bc <OSSemPost>

  if (ptr != buffer)
811482f0:	e0fff017 	ldw	r3,-64(fp)
811482f4:	e0bffd17 	ldw	r2,-12(fp)
811482f8:	18801826 	beq	r3,r2,8114835c <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811482fc:	0005303a 	rdctl	r2,status
81148300:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148304:	e0fff717 	ldw	r3,-36(fp)
81148308:	00bfff84 	movi	r2,-2
8114830c:	1884703a 	and	r2,r3,r2
81148310:	1001703a 	wrctl	status,r2
  
  return context;
81148314:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81148318:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8114831c:	e0bffc17 	ldw	r2,-16(fp)
81148320:	10800817 	ldw	r2,32(r2)
81148324:	10c00054 	ori	r3,r2,1
81148328:	e0bffc17 	ldw	r2,-16(fp)
8114832c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81148330:	e0bffc17 	ldw	r2,-16(fp)
81148334:	10800017 	ldw	r2,0(r2)
81148338:	10800104 	addi	r2,r2,4
8114833c:	1007883a 	mov	r3,r2
81148340:	e0bffc17 	ldw	r2,-16(fp)
81148344:	10800817 	ldw	r2,32(r2)
81148348:	18800035 	stwio	r2,0(r3)
8114834c:	e0bff617 	ldw	r2,-40(fp)
81148350:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148354:	e0bff517 	ldw	r2,-44(fp)
81148358:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
8114835c:	e0fff017 	ldw	r3,-64(fp)
81148360:	e0bffd17 	ldw	r2,-12(fp)
81148364:	18800426 	beq	r3,r2,81148378 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81148368:	e0fff017 	ldw	r3,-64(fp)
8114836c:	e0bffd17 	ldw	r2,-12(fp)
81148370:	1885c83a 	sub	r2,r3,r2
81148374:	00000606 	br	81148390 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81148378:	e0bfff17 	ldw	r2,-4(fp)
8114837c:	1090000c 	andi	r2,r2,16384
81148380:	10000226 	beq	r2,zero,8114838c <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81148384:	00bffd44 	movi	r2,-11
81148388:	00000106 	br	81148390 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
8114838c:	00bffec4 	movi	r2,-5
}
81148390:	e037883a 	mov	sp,fp
81148394:	dfc00117 	ldw	ra,4(sp)
81148398:	df000017 	ldw	fp,0(sp)
8114839c:	dec00204 	addi	sp,sp,8
811483a0:	f800283a 	ret

811483a4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
811483a4:	deffed04 	addi	sp,sp,-76
811483a8:	de00012e 	bgeu	sp,et,811483b0 <altera_avalon_jtag_uart_write+0xc>
811483ac:	003b68fa 	trap	3
811483b0:	dfc01215 	stw	ra,72(sp)
811483b4:	df001115 	stw	fp,68(sp)
811483b8:	df001104 	addi	fp,sp,68
811483bc:	e13ffc15 	stw	r4,-16(fp)
811483c0:	e17ffd15 	stw	r5,-12(fp)
811483c4:	e1bffe15 	stw	r6,-8(fp)
811483c8:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
811483cc:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
811483d0:	e0bffd17 	ldw	r2,-12(fp)
811483d4:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
811483d8:	e0bffc17 	ldw	r2,-16(fp)
811483dc:	10800b17 	ldw	r2,44(r2)
811483e0:	e0bff815 	stw	r2,-32(fp)
811483e4:	e03ff90d 	sth	zero,-28(fp)
811483e8:	e0bff90b 	ldhu	r2,-28(fp)
811483ec:	e0fffb44 	addi	r3,fp,-19
811483f0:	180d883a 	mov	r6,r3
811483f4:	100b883a 	mov	r5,r2
811483f8:	e13ff817 	ldw	r4,-32(fp)
811483fc:	113fe340 	call	8113fe34 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81148400:	00003706 	br	811484e0 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81148404:	e0bffc17 	ldw	r2,-16(fp)
81148408:	10800f17 	ldw	r2,60(r2)
8114840c:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81148410:	e0bffc17 	ldw	r2,-16(fp)
81148414:	10801017 	ldw	r2,64(r2)
81148418:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
8114841c:	e0fff417 	ldw	r3,-48(fp)
81148420:	e0bff017 	ldw	r2,-64(fp)
81148424:	1880062e 	bgeu	r3,r2,81148440 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81148428:	e0fff017 	ldw	r3,-64(fp)
8114842c:	e0bff417 	ldw	r2,-48(fp)
81148430:	1885c83a 	sub	r2,r3,r2
81148434:	10bfffc4 	addi	r2,r2,-1
81148438:	e0bff115 	stw	r2,-60(fp)
8114843c:	00000b06 	br	8114846c <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81148440:	e0bff017 	ldw	r2,-64(fp)
81148444:	10000526 	beq	r2,zero,8114845c <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81148448:	00c20004 	movi	r3,2048
8114844c:	e0bff417 	ldw	r2,-48(fp)
81148450:	1885c83a 	sub	r2,r3,r2
81148454:	e0bff115 	stw	r2,-60(fp)
81148458:	00000406 	br	8114846c <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
8114845c:	00c1ffc4 	movi	r3,2047
81148460:	e0bff417 	ldw	r2,-48(fp)
81148464:	1885c83a 	sub	r2,r3,r2
81148468:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8114846c:	e0bff117 	ldw	r2,-60(fp)
81148470:	10001e26 	beq	r2,zero,811484ec <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81148474:	e0fffe17 	ldw	r3,-8(fp)
81148478:	e0bff117 	ldw	r2,-60(fp)
8114847c:	1880022e 	bgeu	r3,r2,81148488 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81148480:	e0bffe17 	ldw	r2,-8(fp)
81148484:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81148488:	e0bffc17 	ldw	r2,-16(fp)
8114848c:	10c21104 	addi	r3,r2,2116
81148490:	e0bff417 	ldw	r2,-48(fp)
81148494:	1885883a 	add	r2,r3,r2
81148498:	e1bff117 	ldw	r6,-60(fp)
8114849c:	e17ffd17 	ldw	r5,-12(fp)
811484a0:	1009883a 	mov	r4,r2
811484a4:	1123a440 	call	81123a44 <memcpy>
      ptr   += n;
811484a8:	e0fffd17 	ldw	r3,-12(fp)
811484ac:	e0bff117 	ldw	r2,-60(fp)
811484b0:	1885883a 	add	r2,r3,r2
811484b4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
811484b8:	e0fffe17 	ldw	r3,-8(fp)
811484bc:	e0bff117 	ldw	r2,-60(fp)
811484c0:	1885c83a 	sub	r2,r3,r2
811484c4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811484c8:	e0fff417 	ldw	r3,-48(fp)
811484cc:	e0bff117 	ldw	r2,-60(fp)
811484d0:	1885883a 	add	r2,r3,r2
811484d4:	10c1ffcc 	andi	r3,r2,2047
811484d8:	e0bffc17 	ldw	r2,-16(fp)
811484dc:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811484e0:	e0bffe17 	ldw	r2,-8(fp)
811484e4:	00bfc716 	blt	zero,r2,81148404 <__reset+0xfb128404>
811484e8:	00000106 	br	811484f0 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
811484ec:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811484f0:	0005303a 	rdctl	r2,status
811484f4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811484f8:	e0fff717 	ldw	r3,-36(fp)
811484fc:	00bfff84 	movi	r2,-2
81148500:	1884703a 	and	r2,r3,r2
81148504:	1001703a 	wrctl	status,r2
  
  return context;
81148508:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
8114850c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81148510:	e0bffc17 	ldw	r2,-16(fp)
81148514:	10800817 	ldw	r2,32(r2)
81148518:	10c00094 	ori	r3,r2,2
8114851c:	e0bffc17 	ldw	r2,-16(fp)
81148520:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81148524:	e0bffc17 	ldw	r2,-16(fp)
81148528:	10800017 	ldw	r2,0(r2)
8114852c:	10800104 	addi	r2,r2,4
81148530:	1007883a 	mov	r3,r2
81148534:	e0bffc17 	ldw	r2,-16(fp)
81148538:	10800817 	ldw	r2,32(r2)
8114853c:	18800035 	stwio	r2,0(r3)
81148540:	e0bff617 	ldw	r2,-40(fp)
81148544:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148548:	e0bff317 	ldw	r2,-52(fp)
8114854c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81148550:	e0bffe17 	ldw	r2,-8(fp)
81148554:	00802a0e 	bge	zero,r2,81148600 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81148558:	e0bfff17 	ldw	r2,-4(fp)
8114855c:	1090000c 	andi	r2,r2,16384
81148560:	10002a1e 	bne	r2,zero,8114860c <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81148564:	d0a09103 	ldbu	r2,-32188(gp)
81148568:	10803fcc 	andi	r2,r2,255
8114856c:	10800058 	cmpnei	r2,r2,1
81148570:	1000161e 	bne	r2,zero,811485cc <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81148574:	e0bffc17 	ldw	r2,-16(fp)
81148578:	10800c17 	ldw	r2,48(r2)
8114857c:	e0bff515 	stw	r2,-44(fp)
81148580:	00800184 	movi	r2,6
81148584:	e0bff98d 	sth	r2,-26(fp)
81148588:	00bfe0c4 	movi	r2,-125
8114858c:	e0bffa05 	stb	r2,-24(fp)
81148590:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148594:	d0a09103 	ldbu	r2,-32188(gp)
81148598:	10803fcc 	andi	r2,r2,255
8114859c:	10001526 	beq	r2,zero,811485f4 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811485a0:	e0fff98b 	ldhu	r3,-26(fp)
811485a4:	e13ffa03 	ldbu	r4,-24(fp)
811485a8:	e17ffa8b 	ldhu	r5,-22(fp)
811485ac:	e0bffb04 	addi	r2,fp,-20
811485b0:	d8800015 	stw	r2,0(sp)
811485b4:	280f883a 	mov	r7,r5
811485b8:	200d883a 	mov	r6,r4
811485bc:	180b883a 	mov	r5,r3
811485c0:	e13ff517 	ldw	r4,-44(fp)
811485c4:	113c1940 	call	8113c194 <OSFlagPend>
811485c8:	00000a06 	br	811485f4 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
811485cc:	0001883a 	nop
811485d0:	e0bffc17 	ldw	r2,-16(fp)
811485d4:	10c01017 	ldw	r3,64(r2)
811485d8:	e0bff017 	ldw	r2,-64(fp)
811485dc:	1880051e 	bne	r3,r2,811485f4 <altera_avalon_jtag_uart_write+0x250>
811485e0:	e0bffc17 	ldw	r2,-16(fp)
811485e4:	10c00917 	ldw	r3,36(r2)
811485e8:	e0bffc17 	ldw	r2,-16(fp)
811485ec:	10800117 	ldw	r2,4(r2)
811485f0:	18bff736 	bltu	r3,r2,811485d0 <__reset+0xfb1285d0>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
811485f4:	e0bffc17 	ldw	r2,-16(fp)
811485f8:	10800917 	ldw	r2,36(r2)
811485fc:	1000051e 	bne	r2,zero,81148614 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81148600:	e0bffe17 	ldw	r2,-8(fp)
81148604:	00bfb616 	blt	zero,r2,811484e0 <__reset+0xfb1284e0>
81148608:	00000306 	br	81148618 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
8114860c:	0001883a 	nop
81148610:	00000106 	br	81148618 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
81148614:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
81148618:	e0bffc17 	ldw	r2,-16(fp)
8114861c:	10800b17 	ldw	r2,44(r2)
81148620:	1009883a 	mov	r4,r2
81148624:	11401bc0 	call	811401bc <OSSemPost>

  if (ptr != start)
81148628:	e0fffd17 	ldw	r3,-12(fp)
8114862c:	e0bff217 	ldw	r2,-56(fp)
81148630:	18800426 	beq	r3,r2,81148644 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81148634:	e0fffd17 	ldw	r3,-12(fp)
81148638:	e0bff217 	ldw	r2,-56(fp)
8114863c:	1885c83a 	sub	r2,r3,r2
81148640:	00000606 	br	8114865c <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81148644:	e0bfff17 	ldw	r2,-4(fp)
81148648:	1090000c 	andi	r2,r2,16384
8114864c:	10000226 	beq	r2,zero,81148658 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81148650:	00bffd44 	movi	r2,-11
81148654:	00000106 	br	8114865c <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81148658:	00bffec4 	movi	r2,-5
}
8114865c:	e037883a 	mov	sp,fp
81148660:	dfc00117 	ldw	ra,4(sp)
81148664:	df000017 	ldw	fp,0(sp)
81148668:	dec00204 	addi	sp,sp,8
8114866c:	f800283a 	ret

81148670 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81148670:	defffa04 	addi	sp,sp,-24
81148674:	de00012e 	bgeu	sp,et,8114867c <alt_avalon_timer_sc_irq+0xc>
81148678:	003b68fa 	trap	3
8114867c:	dfc00515 	stw	ra,20(sp)
81148680:	df000415 	stw	fp,16(sp)
81148684:	df000404 	addi	fp,sp,16
81148688:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8114868c:	0007883a 	mov	r3,zero
81148690:	e0bfff17 	ldw	r2,-4(fp)
81148694:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81148698:	e0bfff17 	ldw	r2,-4(fp)
8114869c:	10800104 	addi	r2,r2,4
811486a0:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
811486a4:	11386700 	call	81138670 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811486a8:	0005303a 	rdctl	r2,status
811486ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811486b0:	e0fffd17 	ldw	r3,-12(fp)
811486b4:	00bfff84 	movi	r2,-2
811486b8:	1884703a 	and	r2,r3,r2
811486bc:	1001703a 	wrctl	status,r2
  
  return context;
811486c0:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
811486c4:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
811486c8:	1138f200 	call	81138f20 <alt_tick>
811486cc:	e0bffc17 	ldw	r2,-16(fp)
811486d0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811486d4:	e0bffe17 	ldw	r2,-8(fp)
811486d8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
811486dc:	0001883a 	nop
811486e0:	e037883a 	mov	sp,fp
811486e4:	dfc00117 	ldw	ra,4(sp)
811486e8:	df000017 	ldw	fp,0(sp)
811486ec:	dec00204 	addi	sp,sp,8
811486f0:	f800283a 	ret

811486f4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
811486f4:	defff804 	addi	sp,sp,-32
811486f8:	de00012e 	bgeu	sp,et,81148700 <alt_avalon_timer_sc_init+0xc>
811486fc:	003b68fa 	trap	3
81148700:	dfc00715 	stw	ra,28(sp)
81148704:	df000615 	stw	fp,24(sp)
81148708:	df000604 	addi	fp,sp,24
8114870c:	e13ffc15 	stw	r4,-16(fp)
81148710:	e17ffd15 	stw	r5,-12(fp)
81148714:	e1bffe15 	stw	r6,-8(fp)
81148718:	e1ffff15 	stw	r7,-4(fp)
8114871c:	e0bfff17 	ldw	r2,-4(fp)
81148720:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81148724:	d0a08817 	ldw	r2,-32224(gp)
81148728:	1000021e 	bne	r2,zero,81148734 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
8114872c:	e0bffb17 	ldw	r2,-20(fp)
81148730:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81148734:	e0bffc17 	ldw	r2,-16(fp)
81148738:	10800104 	addi	r2,r2,4
8114873c:	00c001c4 	movi	r3,7
81148740:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81148744:	d8000015 	stw	zero,0(sp)
81148748:	e1fffc17 	ldw	r7,-16(fp)
8114874c:	01a04574 	movhi	r6,33045
81148750:	31a19c04 	addi	r6,r6,-31120
81148754:	e17ffe17 	ldw	r5,-8(fp)
81148758:	e13ffd17 	ldw	r4,-12(fp)
8114875c:	114b8f80 	call	8114b8f8 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81148760:	0001883a 	nop
81148764:	e037883a 	mov	sp,fp
81148768:	dfc00117 	ldw	ra,4(sp)
8114876c:	df000017 	ldw	fp,0(sp)
81148770:	dec00204 	addi	sp,sp,8
81148774:	f800283a 	ret

81148778 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81148778:	defffa04 	addi	sp,sp,-24
8114877c:	de00012e 	bgeu	sp,et,81148784 <altera_avalon_uart_read_fd+0xc>
81148780:	003b68fa 	trap	3
81148784:	dfc00515 	stw	ra,20(sp)
81148788:	df000415 	stw	fp,16(sp)
8114878c:	df000404 	addi	fp,sp,16
81148790:	e13ffd15 	stw	r4,-12(fp)
81148794:	e17ffe15 	stw	r5,-8(fp)
81148798:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114879c:	e0bffd17 	ldw	r2,-12(fp)
811487a0:	10800017 	ldw	r2,0(r2)
811487a4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
811487a8:	e0bffc17 	ldw	r2,-16(fp)
811487ac:	10c00a04 	addi	r3,r2,40
811487b0:	e0bffd17 	ldw	r2,-12(fp)
811487b4:	10800217 	ldw	r2,8(r2)
811487b8:	100f883a 	mov	r7,r2
811487bc:	e1bfff17 	ldw	r6,-4(fp)
811487c0:	e17ffe17 	ldw	r5,-8(fp)
811487c4:	1809883a 	mov	r4,r3
811487c8:	1148e380 	call	81148e38 <altera_avalon_uart_read>
      fd->fd_flags);
}
811487cc:	e037883a 	mov	sp,fp
811487d0:	dfc00117 	ldw	ra,4(sp)
811487d4:	df000017 	ldw	fp,0(sp)
811487d8:	dec00204 	addi	sp,sp,8
811487dc:	f800283a 	ret

811487e0 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811487e0:	defffa04 	addi	sp,sp,-24
811487e4:	de00012e 	bgeu	sp,et,811487ec <altera_avalon_uart_write_fd+0xc>
811487e8:	003b68fa 	trap	3
811487ec:	dfc00515 	stw	ra,20(sp)
811487f0:	df000415 	stw	fp,16(sp)
811487f4:	df000404 	addi	fp,sp,16
811487f8:	e13ffd15 	stw	r4,-12(fp)
811487fc:	e17ffe15 	stw	r5,-8(fp)
81148800:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81148804:	e0bffd17 	ldw	r2,-12(fp)
81148808:	10800017 	ldw	r2,0(r2)
8114880c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81148810:	e0bffc17 	ldw	r2,-16(fp)
81148814:	10c00a04 	addi	r3,r2,40
81148818:	e0bffd17 	ldw	r2,-12(fp)
8114881c:	10800217 	ldw	r2,8(r2)
81148820:	100f883a 	mov	r7,r2
81148824:	e1bfff17 	ldw	r6,-4(fp)
81148828:	e17ffe17 	ldw	r5,-8(fp)
8114882c:	1809883a 	mov	r4,r3
81148830:	11490ec0 	call	811490ec <altera_avalon_uart_write>
      fd->fd_flags);
}
81148834:	e037883a 	mov	sp,fp
81148838:	dfc00117 	ldw	ra,4(sp)
8114883c:	df000017 	ldw	fp,0(sp)
81148840:	dec00204 	addi	sp,sp,8
81148844:	f800283a 	ret

81148848 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81148848:	defffc04 	addi	sp,sp,-16
8114884c:	de00012e 	bgeu	sp,et,81148854 <altera_avalon_uart_close_fd+0xc>
81148850:	003b68fa 	trap	3
81148854:	dfc00315 	stw	ra,12(sp)
81148858:	df000215 	stw	fp,8(sp)
8114885c:	df000204 	addi	fp,sp,8
81148860:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81148864:	e0bfff17 	ldw	r2,-4(fp)
81148868:	10800017 	ldw	r2,0(r2)
8114886c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81148870:	e0bffe17 	ldw	r2,-8(fp)
81148874:	10c00a04 	addi	r3,r2,40
81148878:	e0bfff17 	ldw	r2,-4(fp)
8114887c:	10800217 	ldw	r2,8(r2)
81148880:	100b883a 	mov	r5,r2
81148884:	1809883a 	mov	r4,r3
81148888:	1148d980 	call	81148d98 <altera_avalon_uart_close>
}
8114888c:	e037883a 	mov	sp,fp
81148890:	dfc00117 	ldw	ra,4(sp)
81148894:	df000017 	ldw	fp,0(sp)
81148898:	dec00204 	addi	sp,sp,8
8114889c:	f800283a 	ret

811488a0 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
811488a0:	defff304 	addi	sp,sp,-52
811488a4:	de00012e 	bgeu	sp,et,811488ac <altera_avalon_uart_init+0xc>
811488a8:	003b68fa 	trap	3
811488ac:	dfc00c15 	stw	ra,48(sp)
811488b0:	df000b15 	stw	fp,44(sp)
811488b4:	df000b04 	addi	fp,sp,44
811488b8:	e13ffd15 	stw	r4,-12(fp)
811488bc:	e17ffe15 	stw	r5,-8(fp)
811488c0:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
811488c4:	e0bffd17 	ldw	r2,-12(fp)
811488c8:	10800017 	ldw	r2,0(r2)
811488cc:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811488d0:	e0bffd17 	ldw	r2,-12(fp)
811488d4:	10800704 	addi	r2,r2,28
811488d8:	e0bffa15 	stw	r2,-24(fp)
811488dc:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811488e0:	e0bffb0b 	ldhu	r2,-20(fp)
811488e4:	e0fffc84 	addi	r3,fp,-14
811488e8:	180b883a 	mov	r5,r3
811488ec:	1009883a 	mov	r4,r2
811488f0:	113bbb00 	call	8113bbb0 <OSFlagCreate>
811488f4:	1007883a 	mov	r3,r2
811488f8:	e0bffa17 	ldw	r2,-24(fp)
811488fc:	10c00015 	stw	r3,0(r2)
  return err;
81148900:	e0bffc83 	ldbu	r2,-14(fp)
81148904:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81148908:	1000241e 	bne	r2,zero,8114899c <altera_avalon_uart_init+0xfc>
8114890c:	e0bffd17 	ldw	r2,-12(fp)
81148910:	10800804 	addi	r2,r2,32
81148914:	e0bff715 	stw	r2,-36(fp)
81148918:	00800044 	movi	r2,1
8114891c:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81148920:	e0bffb8b 	ldhu	r2,-18(fp)
81148924:	1009883a 	mov	r4,r2
81148928:	113fb0c0 	call	8113fb0c <OSSemCreate>
8114892c:	1007883a 	mov	r3,r2
81148930:	e0bff717 	ldw	r2,-36(fp)
81148934:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81148938:	e0bff717 	ldw	r2,-36(fp)
8114893c:	10800017 	ldw	r2,0(r2)
81148940:	10000226 	beq	r2,zero,8114894c <altera_avalon_uart_init+0xac>
81148944:	0005883a 	mov	r2,zero
81148948:	00000106 	br	81148950 <altera_avalon_uart_init+0xb0>
8114894c:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81148950:	1000121e 	bne	r2,zero,8114899c <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81148954:	e0bffd17 	ldw	r2,-12(fp)
81148958:	10800904 	addi	r2,r2,36
8114895c:	e0bff815 	stw	r2,-32(fp)
81148960:	00800044 	movi	r2,1
81148964:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81148968:	e0bffc0b 	ldhu	r2,-16(fp)
8114896c:	1009883a 	mov	r4,r2
81148970:	113fb0c0 	call	8113fb0c <OSSemCreate>
81148974:	1007883a 	mov	r3,r2
81148978:	e0bff817 	ldw	r2,-32(fp)
8114897c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81148980:	e0bff817 	ldw	r2,-32(fp)
81148984:	10800017 	ldw	r2,0(r2)
81148988:	10000226 	beq	r2,zero,81148994 <altera_avalon_uart_init+0xf4>
8114898c:	0005883a 	mov	r2,zero
81148990:	00000106 	br	81148998 <altera_avalon_uart_init+0xf8>
81148994:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81148998:	10000226 	beq	r2,zero,811489a4 <altera_avalon_uart_init+0x104>
8114899c:	00800044 	movi	r2,1
811489a0:	00000106 	br	811489a8 <altera_avalon_uart_init+0x108>
811489a4:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811489a8:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
811489ac:	e0bff917 	ldw	r2,-28(fp)
811489b0:	10000f1e 	bne	r2,zero,811489f0 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
811489b4:	e0bffd17 	ldw	r2,-12(fp)
811489b8:	00c32004 	movi	r3,3200
811489bc:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
811489c0:	e0bff617 	ldw	r2,-40(fp)
811489c4:	10800304 	addi	r2,r2,12
811489c8:	e0fffd17 	ldw	r3,-12(fp)
811489cc:	18c00117 	ldw	r3,4(r3)
811489d0:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
811489d4:	d8000015 	stw	zero,0(sp)
811489d8:	e1fffd17 	ldw	r7,-12(fp)
811489dc:	01a04574 	movhi	r6,33045
811489e0:	31a28204 	addi	r6,r6,-30200
811489e4:	e17fff17 	ldw	r5,-4(fp)
811489e8:	e13ffe17 	ldw	r4,-8(fp)
811489ec:	114b8f80 	call	8114b8f8 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
811489f0:	0001883a 	nop
811489f4:	e037883a 	mov	sp,fp
811489f8:	dfc00117 	ldw	ra,4(sp)
811489fc:	df000017 	ldw	fp,0(sp)
81148a00:	dec00204 	addi	sp,sp,8
81148a04:	f800283a 	ret

81148a08 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81148a08:	defffa04 	addi	sp,sp,-24
81148a0c:	de00012e 	bgeu	sp,et,81148a14 <altera_avalon_uart_irq+0xc>
81148a10:	003b68fa 	trap	3
81148a14:	dfc00515 	stw	ra,20(sp)
81148a18:	df000415 	stw	fp,16(sp)
81148a1c:	df000404 	addi	fp,sp,16
81148a20:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81148a24:	e0bfff17 	ldw	r2,-4(fp)
81148a28:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81148a2c:	e0bffc17 	ldw	r2,-16(fp)
81148a30:	10800017 	ldw	r2,0(r2)
81148a34:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
81148a38:	e0bffd17 	ldw	r2,-12(fp)
81148a3c:	10800204 	addi	r2,r2,8
81148a40:	10800037 	ldwio	r2,0(r2)
81148a44:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81148a48:	e0bffd17 	ldw	r2,-12(fp)
81148a4c:	10800204 	addi	r2,r2,8
81148a50:	0007883a 	mov	r3,zero
81148a54:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81148a58:	e0bffd17 	ldw	r2,-12(fp)
81148a5c:	10800204 	addi	r2,r2,8
81148a60:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81148a64:	e0bffe17 	ldw	r2,-8(fp)
81148a68:	1080200c 	andi	r2,r2,128
81148a6c:	10000326 	beq	r2,zero,81148a7c <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81148a70:	e17ffe17 	ldw	r5,-8(fp)
81148a74:	e13ffc17 	ldw	r4,-16(fp)
81148a78:	1148aac0 	call	81148aac <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81148a7c:	e0bffe17 	ldw	r2,-8(fp)
81148a80:	1081100c 	andi	r2,r2,1088
81148a84:	10000326 	beq	r2,zero,81148a94 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81148a88:	e17ffe17 	ldw	r5,-8(fp)
81148a8c:	e13ffc17 	ldw	r4,-16(fp)
81148a90:	1148bec0 	call	81148bec <altera_avalon_uart_txirq>
  }
  

}
81148a94:	0001883a 	nop
81148a98:	e037883a 	mov	sp,fp
81148a9c:	dfc00117 	ldw	ra,4(sp)
81148aa0:	df000017 	ldw	fp,0(sp)
81148aa4:	dec00204 	addi	sp,sp,8
81148aa8:	f800283a 	ret

81148aac <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81148aac:	defff904 	addi	sp,sp,-28
81148ab0:	de00012e 	bgeu	sp,et,81148ab8 <altera_avalon_uart_rxirq+0xc>
81148ab4:	003b68fa 	trap	3
81148ab8:	dfc00615 	stw	ra,24(sp)
81148abc:	df000515 	stw	fp,20(sp)
81148ac0:	df000504 	addi	fp,sp,20
81148ac4:	e13ffe15 	stw	r4,-8(fp)
81148ac8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81148acc:	e0bfff17 	ldw	r2,-4(fp)
81148ad0:	108000cc 	andi	r2,r2,3
81148ad4:	10003f1e 	bne	r2,zero,81148bd4 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81148ad8:	e0bffe17 	ldw	r2,-8(fp)
81148adc:	10c00317 	ldw	r3,12(r2)
81148ae0:	e0bffe17 	ldw	r2,-8(fp)
81148ae4:	10800217 	ldw	r2,8(r2)
81148ae8:	1880121e 	bne	r3,r2,81148b34 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81148aec:	e0bffe17 	ldw	r2,-8(fp)
81148af0:	10800717 	ldw	r2,28(r2)
81148af4:	e0bffc15 	stw	r2,-16(fp)
81148af8:	00800044 	movi	r2,1
81148afc:	e0bffd0d 	sth	r2,-12(fp)
81148b00:	00800044 	movi	r2,1
81148b04:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148b08:	d0a09103 	ldbu	r2,-32188(gp)
81148b0c:	10803fcc 	andi	r2,r2,255
81148b10:	10000826 	beq	r2,zero,81148b34 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
81148b14:	e0bffd0b 	ldhu	r2,-12(fp)
81148b18:	e0fffd83 	ldbu	r3,-10(fp)
81148b1c:	e13ffdc4 	addi	r4,fp,-9
81148b20:	200f883a 	mov	r7,r4
81148b24:	180d883a 	mov	r6,r3
81148b28:	100b883a 	mov	r5,r2
81148b2c:	e13ffc17 	ldw	r4,-16(fp)
81148b30:	113c7bc0 	call	8113c7bc <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81148b34:	e0bffe17 	ldw	r2,-8(fp)
81148b38:	10800317 	ldw	r2,12(r2)
81148b3c:	10800044 	addi	r2,r2,1
81148b40:	10800fcc 	andi	r2,r2,63
81148b44:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81148b48:	e0bffe17 	ldw	r2,-8(fp)
81148b4c:	10800317 	ldw	r2,12(r2)
81148b50:	e0fffe17 	ldw	r3,-8(fp)
81148b54:	18c00017 	ldw	r3,0(r3)
81148b58:	18c00037 	ldwio	r3,0(r3)
81148b5c:	1809883a 	mov	r4,r3
81148b60:	e0fffe17 	ldw	r3,-8(fp)
81148b64:	1885883a 	add	r2,r3,r2
81148b68:	10800a04 	addi	r2,r2,40
81148b6c:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81148b70:	e0bffe17 	ldw	r2,-8(fp)
81148b74:	e0fffb17 	ldw	r3,-20(fp)
81148b78:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81148b7c:	e0bffe17 	ldw	r2,-8(fp)
81148b80:	10800317 	ldw	r2,12(r2)
81148b84:	10800044 	addi	r2,r2,1
81148b88:	10800fcc 	andi	r2,r2,63
81148b8c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81148b90:	e0bffe17 	ldw	r2,-8(fp)
81148b94:	10c00217 	ldw	r3,8(r2)
81148b98:	e0bffb17 	ldw	r2,-20(fp)
81148b9c:	18800e1e 	bne	r3,r2,81148bd8 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81148ba0:	e0bffe17 	ldw	r2,-8(fp)
81148ba4:	10c00117 	ldw	r3,4(r2)
81148ba8:	00bfdfc4 	movi	r2,-129
81148bac:	1886703a 	and	r3,r3,r2
81148bb0:	e0bffe17 	ldw	r2,-8(fp)
81148bb4:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81148bb8:	e0bffe17 	ldw	r2,-8(fp)
81148bbc:	10800017 	ldw	r2,0(r2)
81148bc0:	10800304 	addi	r2,r2,12
81148bc4:	e0fffe17 	ldw	r3,-8(fp)
81148bc8:	18c00117 	ldw	r3,4(r3)
81148bcc:	10c00035 	stwio	r3,0(r2)
81148bd0:	00000106 	br	81148bd8 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81148bd4:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81148bd8:	e037883a 	mov	sp,fp
81148bdc:	dfc00117 	ldw	ra,4(sp)
81148be0:	df000017 	ldw	fp,0(sp)
81148be4:	dec00204 	addi	sp,sp,8
81148be8:	f800283a 	ret

81148bec <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81148bec:	defffa04 	addi	sp,sp,-24
81148bf0:	de00012e 	bgeu	sp,et,81148bf8 <altera_avalon_uart_txirq+0xc>
81148bf4:	003b68fa 	trap	3
81148bf8:	dfc00515 	stw	ra,20(sp)
81148bfc:	df000415 	stw	fp,16(sp)
81148c00:	df000404 	addi	fp,sp,16
81148c04:	e13ffe15 	stw	r4,-8(fp)
81148c08:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81148c0c:	e0bffe17 	ldw	r2,-8(fp)
81148c10:	10c00417 	ldw	r3,16(r2)
81148c14:	e0bffe17 	ldw	r2,-8(fp)
81148c18:	10800517 	ldw	r2,20(r2)
81148c1c:	18804726 	beq	r3,r2,81148d3c <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81148c20:	e0bffe17 	ldw	r2,-8(fp)
81148c24:	10800617 	ldw	r2,24(r2)
81148c28:	1080008c 	andi	r2,r2,2
81148c2c:	10000326 	beq	r2,zero,81148c3c <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81148c30:	e0bfff17 	ldw	r2,-4(fp)
81148c34:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81148c38:	10003226 	beq	r2,zero,81148d04 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81148c3c:	e0bffe17 	ldw	r2,-8(fp)
81148c40:	10c00417 	ldw	r3,16(r2)
81148c44:	e0bffe17 	ldw	r2,-8(fp)
81148c48:	10800517 	ldw	r2,20(r2)
81148c4c:	10800044 	addi	r2,r2,1
81148c50:	10800fcc 	andi	r2,r2,63
81148c54:	1880121e 	bne	r3,r2,81148ca0 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81148c58:	e0bffe17 	ldw	r2,-8(fp)
81148c5c:	10800717 	ldw	r2,28(r2)
81148c60:	e0bffc15 	stw	r2,-16(fp)
81148c64:	00800084 	movi	r2,2
81148c68:	e0bffd0d 	sth	r2,-12(fp)
81148c6c:	00800044 	movi	r2,1
81148c70:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148c74:	d0a09103 	ldbu	r2,-32188(gp)
81148c78:	10803fcc 	andi	r2,r2,255
81148c7c:	10000826 	beq	r2,zero,81148ca0 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81148c80:	e0bffd0b 	ldhu	r2,-12(fp)
81148c84:	e0fffd83 	ldbu	r3,-10(fp)
81148c88:	e13ffdc4 	addi	r4,fp,-9
81148c8c:	200f883a 	mov	r7,r4
81148c90:	180d883a 	mov	r6,r3
81148c94:	100b883a 	mov	r5,r2
81148c98:	e13ffc17 	ldw	r4,-16(fp)
81148c9c:	113c7bc0 	call	8113c7bc <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81148ca0:	e0bffe17 	ldw	r2,-8(fp)
81148ca4:	10800017 	ldw	r2,0(r2)
81148ca8:	10800104 	addi	r2,r2,4
81148cac:	e0fffe17 	ldw	r3,-8(fp)
81148cb0:	18c00417 	ldw	r3,16(r3)
81148cb4:	e13ffe17 	ldw	r4,-8(fp)
81148cb8:	20c7883a 	add	r3,r4,r3
81148cbc:	18c01a04 	addi	r3,r3,104
81148cc0:	18c00003 	ldbu	r3,0(r3)
81148cc4:	18c03fcc 	andi	r3,r3,255
81148cc8:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81148ccc:	e0bffe17 	ldw	r2,-8(fp)
81148cd0:	10800417 	ldw	r2,16(r2)
81148cd4:	10800044 	addi	r2,r2,1
81148cd8:	e0fffe17 	ldw	r3,-8(fp)
81148cdc:	18800415 	stw	r2,16(r3)
81148ce0:	10c00fcc 	andi	r3,r2,63
81148ce4:	e0bffe17 	ldw	r2,-8(fp)
81148ce8:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81148cec:	e0bffe17 	ldw	r2,-8(fp)
81148cf0:	10800117 	ldw	r2,4(r2)
81148cf4:	10c01014 	ori	r3,r2,64
81148cf8:	e0bffe17 	ldw	r2,-8(fp)
81148cfc:	10c00115 	stw	r3,4(r2)
81148d00:	00000e06 	br	81148d3c <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81148d04:	e0bffe17 	ldw	r2,-8(fp)
81148d08:	10800017 	ldw	r2,0(r2)
81148d0c:	10800204 	addi	r2,r2,8
81148d10:	10800037 	ldwio	r2,0(r2)
81148d14:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81148d18:	e0bfff17 	ldw	r2,-4(fp)
81148d1c:	1082000c 	andi	r2,r2,2048
81148d20:	1000061e 	bne	r2,zero,81148d3c <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81148d24:	e0bffe17 	ldw	r2,-8(fp)
81148d28:	10c00117 	ldw	r3,4(r2)
81148d2c:	00bfefc4 	movi	r2,-65
81148d30:	1886703a 	and	r3,r3,r2
81148d34:	e0bffe17 	ldw	r2,-8(fp)
81148d38:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81148d3c:	e0bffe17 	ldw	r2,-8(fp)
81148d40:	10c00417 	ldw	r3,16(r2)
81148d44:	e0bffe17 	ldw	r2,-8(fp)
81148d48:	10800517 	ldw	r2,20(r2)
81148d4c:	1880061e 	bne	r3,r2,81148d68 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81148d50:	e0bffe17 	ldw	r2,-8(fp)
81148d54:	10c00117 	ldw	r3,4(r2)
81148d58:	00beefc4 	movi	r2,-1089
81148d5c:	1886703a 	and	r3,r3,r2
81148d60:	e0bffe17 	ldw	r2,-8(fp)
81148d64:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81148d68:	e0bffe17 	ldw	r2,-8(fp)
81148d6c:	10800017 	ldw	r2,0(r2)
81148d70:	10800304 	addi	r2,r2,12
81148d74:	e0fffe17 	ldw	r3,-8(fp)
81148d78:	18c00117 	ldw	r3,4(r3)
81148d7c:	10c00035 	stwio	r3,0(r2)
}
81148d80:	0001883a 	nop
81148d84:	e037883a 	mov	sp,fp
81148d88:	dfc00117 	ldw	ra,4(sp)
81148d8c:	df000017 	ldw	fp,0(sp)
81148d90:	dec00204 	addi	sp,sp,8
81148d94:	f800283a 	ret

81148d98 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81148d98:	defffd04 	addi	sp,sp,-12
81148d9c:	de00012e 	bgeu	sp,et,81148da4 <altera_avalon_uart_close+0xc>
81148da0:	003b68fa 	trap	3
81148da4:	df000215 	stw	fp,8(sp)
81148da8:	df000204 	addi	fp,sp,8
81148dac:	e13ffe15 	stw	r4,-8(fp)
81148db0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81148db4:	00000506 	br	81148dcc <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81148db8:	e0bfff17 	ldw	r2,-4(fp)
81148dbc:	1090000c 	andi	r2,r2,16384
81148dc0:	10000226 	beq	r2,zero,81148dcc <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81148dc4:	00bffd44 	movi	r2,-11
81148dc8:	00000606 	br	81148de4 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81148dcc:	e0bffe17 	ldw	r2,-8(fp)
81148dd0:	10c00417 	ldw	r3,16(r2)
81148dd4:	e0bffe17 	ldw	r2,-8(fp)
81148dd8:	10800517 	ldw	r2,20(r2)
81148ddc:	18bff61e 	bne	r3,r2,81148db8 <__reset+0xfb128db8>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81148de0:	0005883a 	mov	r2,zero
}
81148de4:	e037883a 	mov	sp,fp
81148de8:	df000017 	ldw	fp,0(sp)
81148dec:	dec00104 	addi	sp,sp,4
81148df0:	f800283a 	ret

81148df4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81148df4:	defffe04 	addi	sp,sp,-8
81148df8:	de00012e 	bgeu	sp,et,81148e00 <alt_get_errno+0xc>
81148dfc:	003b68fa 	trap	3
81148e00:	dfc00115 	stw	ra,4(sp)
81148e04:	df000015 	stw	fp,0(sp)
81148e08:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81148e0c:	d0a01017 	ldw	r2,-32704(gp)
81148e10:	10000326 	beq	r2,zero,81148e20 <alt_get_errno+0x2c>
81148e14:	d0a01017 	ldw	r2,-32704(gp)
81148e18:	103ee83a 	callr	r2
81148e1c:	00000106 	br	81148e24 <alt_get_errno+0x30>
81148e20:	d0a07804 	addi	r2,gp,-32288
}
81148e24:	e037883a 	mov	sp,fp
81148e28:	dfc00117 	ldw	ra,4(sp)
81148e2c:	df000017 	ldw	fp,0(sp)
81148e30:	dec00204 	addi	sp,sp,8
81148e34:	f800283a 	ret

81148e38 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81148e38:	deffec04 	addi	sp,sp,-80
81148e3c:	de00012e 	bgeu	sp,et,81148e44 <altera_avalon_uart_read+0xc>
81148e40:	003b68fa 	trap	3
81148e44:	dfc01315 	stw	ra,76(sp)
81148e48:	df001215 	stw	fp,72(sp)
81148e4c:	df001204 	addi	fp,sp,72
81148e50:	e13ffc15 	stw	r4,-16(fp)
81148e54:	e17ffd15 	stw	r5,-12(fp)
81148e58:	e1bffe15 	stw	r6,-8(fp)
81148e5c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81148e60:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81148e64:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81148e68:	e0bfff17 	ldw	r2,-4(fp)
81148e6c:	1090000c 	andi	r2,r2,16384
81148e70:	1005003a 	cmpeq	r2,r2,zero
81148e74:	10803fcc 	andi	r2,r2,255
81148e78:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81148e7c:	e0bffc17 	ldw	r2,-16(fp)
81148e80:	10800817 	ldw	r2,32(r2)
81148e84:	e0bff815 	stw	r2,-32(fp)
81148e88:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81148e8c:	e0bff90b 	ldhu	r2,-28(fp)
81148e90:	e0fffb44 	addi	r3,fp,-19
81148e94:	180d883a 	mov	r6,r3
81148e98:	100b883a 	mov	r5,r2
81148e9c:	e13ff817 	ldw	r4,-32(fp)
81148ea0:	113fe340 	call	8113fe34 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81148ea4:	00001306 	br	81148ef4 <altera_avalon_uart_read+0xbc>
    {
      count++;
81148ea8:	e0bff017 	ldw	r2,-64(fp)
81148eac:	10800044 	addi	r2,r2,1
81148eb0:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81148eb4:	e0bffd17 	ldw	r2,-12(fp)
81148eb8:	10c00044 	addi	r3,r2,1
81148ebc:	e0fffd15 	stw	r3,-12(fp)
81148ec0:	e0fffc17 	ldw	r3,-16(fp)
81148ec4:	18c00217 	ldw	r3,8(r3)
81148ec8:	e13ffc17 	ldw	r4,-16(fp)
81148ecc:	20c7883a 	add	r3,r4,r3
81148ed0:	18c00a04 	addi	r3,r3,40
81148ed4:	18c00003 	ldbu	r3,0(r3)
81148ed8:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81148edc:	e0bffc17 	ldw	r2,-16(fp)
81148ee0:	10800217 	ldw	r2,8(r2)
81148ee4:	10800044 	addi	r2,r2,1
81148ee8:	10c00fcc 	andi	r3,r2,63
81148eec:	e0bffc17 	ldw	r2,-16(fp)
81148ef0:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81148ef4:	e0fff017 	ldw	r3,-64(fp)
81148ef8:	e0bffe17 	ldw	r2,-8(fp)
81148efc:	1880050e 	bge	r3,r2,81148f14 <altera_avalon_uart_read+0xdc>
81148f00:	e0bffc17 	ldw	r2,-16(fp)
81148f04:	10c00217 	ldw	r3,8(r2)
81148f08:	e0bffc17 	ldw	r2,-16(fp)
81148f0c:	10800317 	ldw	r2,12(r2)
81148f10:	18bfe51e 	bne	r3,r2,81148ea8 <__reset+0xfb128ea8>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81148f14:	e0bff017 	ldw	r2,-64(fp)
81148f18:	10003a1e 	bne	r2,zero,81149004 <altera_avalon_uart_read+0x1cc>
81148f1c:	e0bffc17 	ldw	r2,-16(fp)
81148f20:	10c00217 	ldw	r3,8(r2)
81148f24:	e0bffc17 	ldw	r2,-16(fp)
81148f28:	10800317 	ldw	r2,12(r2)
81148f2c:	1880351e 	bne	r3,r2,81149004 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81148f30:	e0bff117 	ldw	r2,-60(fp)
81148f34:	1000071e 	bne	r2,zero,81148f54 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81148f38:	1148df40 	call	81148df4 <alt_get_errno>
81148f3c:	1007883a 	mov	r3,r2
81148f40:	008002c4 	movi	r2,11
81148f44:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81148f48:	00800044 	movi	r2,1
81148f4c:	e0bfef05 	stb	r2,-68(fp)
        break;
81148f50:	00003006 	br	81149014 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148f54:	0005303a 	rdctl	r2,status
81148f58:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148f5c:	e0fff517 	ldw	r3,-44(fp)
81148f60:	00bfff84 	movi	r2,-2
81148f64:	1884703a 	and	r2,r3,r2
81148f68:	1001703a 	wrctl	status,r2
  
  return context;
81148f6c:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81148f70:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81148f74:	e0bffc17 	ldw	r2,-16(fp)
81148f78:	10800117 	ldw	r2,4(r2)
81148f7c:	10c02014 	ori	r3,r2,128
81148f80:	e0bffc17 	ldw	r2,-16(fp)
81148f84:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81148f88:	e0bffc17 	ldw	r2,-16(fp)
81148f8c:	10800017 	ldw	r2,0(r2)
81148f90:	10800304 	addi	r2,r2,12
81148f94:	e0fffc17 	ldw	r3,-16(fp)
81148f98:	18c00117 	ldw	r3,4(r3)
81148f9c:	10c00035 	stwio	r3,0(r2)
81148fa0:	e0bff417 	ldw	r2,-48(fp)
81148fa4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148fa8:	e0bff617 	ldw	r2,-40(fp)
81148fac:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81148fb0:	e0bffc17 	ldw	r2,-16(fp)
81148fb4:	10800717 	ldw	r2,28(r2)
81148fb8:	e0bff215 	stw	r2,-56(fp)
81148fbc:	00800044 	movi	r2,1
81148fc0:	e0bff98d 	sth	r2,-26(fp)
81148fc4:	00bfe0c4 	movi	r2,-125
81148fc8:	e0bffa05 	stb	r2,-24(fp)
81148fcc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148fd0:	d0a09103 	ldbu	r2,-32188(gp)
81148fd4:	10803fcc 	andi	r2,r2,255
81148fd8:	10000a26 	beq	r2,zero,81149004 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81148fdc:	e0fff98b 	ldhu	r3,-26(fp)
81148fe0:	e13ffa03 	ldbu	r4,-24(fp)
81148fe4:	e17ffa8b 	ldhu	r5,-22(fp)
81148fe8:	e0bffb04 	addi	r2,fp,-20
81148fec:	d8800015 	stw	r2,0(sp)
81148ff0:	280f883a 	mov	r7,r5
81148ff4:	200d883a 	mov	r6,r4
81148ff8:	180b883a 	mov	r5,r3
81148ffc:	e13ff217 	ldw	r4,-56(fp)
81149000:	113c1940 	call	8113c194 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81149004:	e0bff017 	ldw	r2,-64(fp)
81149008:	1000021e 	bne	r2,zero,81149014 <altera_avalon_uart_read+0x1dc>
8114900c:	e0bffe17 	ldw	r2,-8(fp)
81149010:	103fb81e 	bne	r2,zero,81148ef4 <__reset+0xfb128ef4>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81149014:	e0bffc17 	ldw	r2,-16(fp)
81149018:	10800817 	ldw	r2,32(r2)
8114901c:	1009883a 	mov	r4,r2
81149020:	11401bc0 	call	811401bc <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149024:	0005303a 	rdctl	r2,status
81149028:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114902c:	e0fff717 	ldw	r3,-36(fp)
81149030:	00bfff84 	movi	r2,-2
81149034:	1884703a 	and	r2,r3,r2
81149038:	1001703a 	wrctl	status,r2
  
  return context;
8114903c:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81149040:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81149044:	e0bffc17 	ldw	r2,-16(fp)
81149048:	10800117 	ldw	r2,4(r2)
8114904c:	10c02014 	ori	r3,r2,128
81149050:	e0bffc17 	ldw	r2,-16(fp)
81149054:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149058:	e0bffc17 	ldw	r2,-16(fp)
8114905c:	10800017 	ldw	r2,0(r2)
81149060:	10800304 	addi	r2,r2,12
81149064:	e0fffc17 	ldw	r3,-16(fp)
81149068:	18c00117 	ldw	r3,4(r3)
8114906c:	10c00035 	stwio	r3,0(r2)
81149070:	e0bff417 	ldw	r2,-48(fp)
81149074:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149078:	e0bff317 	ldw	r2,-52(fp)
8114907c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81149080:	e0bfef03 	ldbu	r2,-68(fp)
81149084:	10000226 	beq	r2,zero,81149090 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81149088:	00bffd44 	movi	r2,-11
8114908c:	00000106 	br	81149094 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81149090:	e0bff017 	ldw	r2,-64(fp)
  }
}
81149094:	e037883a 	mov	sp,fp
81149098:	dfc00117 	ldw	ra,4(sp)
8114909c:	df000017 	ldw	fp,0(sp)
811490a0:	dec00204 	addi	sp,sp,8
811490a4:	f800283a 	ret

811490a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811490a8:	defffe04 	addi	sp,sp,-8
811490ac:	de00012e 	bgeu	sp,et,811490b4 <alt_get_errno+0xc>
811490b0:	003b68fa 	trap	3
811490b4:	dfc00115 	stw	ra,4(sp)
811490b8:	df000015 	stw	fp,0(sp)
811490bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811490c0:	d0a01017 	ldw	r2,-32704(gp)
811490c4:	10000326 	beq	r2,zero,811490d4 <alt_get_errno+0x2c>
811490c8:	d0a01017 	ldw	r2,-32704(gp)
811490cc:	103ee83a 	callr	r2
811490d0:	00000106 	br	811490d8 <alt_get_errno+0x30>
811490d4:	d0a07804 	addi	r2,gp,-32288
}
811490d8:	e037883a 	mov	sp,fp
811490dc:	dfc00117 	ldw	ra,4(sp)
811490e0:	df000017 	ldw	fp,0(sp)
811490e4:	dec00204 	addi	sp,sp,8
811490e8:	f800283a 	ret

811490ec <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
811490ec:	deffec04 	addi	sp,sp,-80
811490f0:	de00012e 	bgeu	sp,et,811490f8 <altera_avalon_uart_write+0xc>
811490f4:	003b68fa 	trap	3
811490f8:	dfc01315 	stw	ra,76(sp)
811490fc:	df001215 	stw	fp,72(sp)
81149100:	df001204 	addi	fp,sp,72
81149104:	e13ffc15 	stw	r4,-16(fp)
81149108:	e17ffd15 	stw	r5,-12(fp)
8114910c:	e1bffe15 	stw	r6,-8(fp)
81149110:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81149114:	e0bffe17 	ldw	r2,-8(fp)
81149118:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
8114911c:	e0bfff17 	ldw	r2,-4(fp)
81149120:	1090000c 	andi	r2,r2,16384
81149124:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81149128:	e0bffc17 	ldw	r2,-16(fp)
8114912c:	10800917 	ldw	r2,36(r2)
81149130:	e0bff815 	stw	r2,-32(fp)
81149134:	e03ff90d 	sth	zero,-28(fp)
81149138:	e0bff90b 	ldhu	r2,-28(fp)
8114913c:	e0fffb44 	addi	r3,fp,-19
81149140:	180d883a 	mov	r6,r3
81149144:	100b883a 	mov	r5,r2
81149148:	e13ff817 	ldw	r4,-32(fp)
8114914c:	113fe340 	call	8113fe34 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149150:	00005106 	br	81149298 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81149154:	e0bffc17 	ldw	r2,-16(fp)
81149158:	10800517 	ldw	r2,20(r2)
8114915c:	10800044 	addi	r2,r2,1
81149160:	10800fcc 	andi	r2,r2,63
81149164:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81149168:	e0bffc17 	ldw	r2,-16(fp)
8114916c:	10c00417 	ldw	r3,16(r2)
81149170:	e0bff217 	ldw	r2,-56(fp)
81149174:	1880371e 	bne	r3,r2,81149254 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81149178:	e0bff017 	ldw	r2,-64(fp)
8114917c:	10000526 	beq	r2,zero,81149194 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81149180:	11490a80 	call	811490a8 <alt_get_errno>
81149184:	1007883a 	mov	r3,r2
81149188:	008002c4 	movi	r2,11
8114918c:	18800015 	stw	r2,0(r3)
        break;
81149190:	00004306 	br	811492a0 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149194:	0005303a 	rdctl	r2,status
81149198:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114919c:	e0fff517 	ldw	r3,-44(fp)
811491a0:	00bfff84 	movi	r2,-2
811491a4:	1884703a 	and	r2,r3,r2
811491a8:	1001703a 	wrctl	status,r2
  
  return context;
811491ac:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
811491b0:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811491b4:	e0bffc17 	ldw	r2,-16(fp)
811491b8:	10800117 	ldw	r2,4(r2)
811491bc:	10c11014 	ori	r3,r2,1088
811491c0:	e0bffc17 	ldw	r2,-16(fp)
811491c4:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811491c8:	e0bffc17 	ldw	r2,-16(fp)
811491cc:	10800017 	ldw	r2,0(r2)
811491d0:	10800304 	addi	r2,r2,12
811491d4:	e0fffc17 	ldw	r3,-16(fp)
811491d8:	18c00117 	ldw	r3,4(r3)
811491dc:	10c00035 	stwio	r3,0(r2)
811491e0:	e0bff417 	ldw	r2,-48(fp)
811491e4:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811491e8:	e0bff117 	ldw	r2,-60(fp)
811491ec:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
811491f0:	e0bffc17 	ldw	r2,-16(fp)
811491f4:	10800717 	ldw	r2,28(r2)
811491f8:	e0bff315 	stw	r2,-52(fp)
811491fc:	00800084 	movi	r2,2
81149200:	e0bff98d 	sth	r2,-26(fp)
81149204:	00bfe0c4 	movi	r2,-125
81149208:	e0bffa05 	stb	r2,-24(fp)
8114920c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81149210:	d0a09103 	ldbu	r2,-32188(gp)
81149214:	10803fcc 	andi	r2,r2,255
81149218:	10000a26 	beq	r2,zero,81149244 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8114921c:	e0fff98b 	ldhu	r3,-26(fp)
81149220:	e13ffa03 	ldbu	r4,-24(fp)
81149224:	e17ffa8b 	ldhu	r5,-22(fp)
81149228:	e0bffb04 	addi	r2,fp,-20
8114922c:	d8800015 	stw	r2,0(sp)
81149230:	280f883a 	mov	r7,r5
81149234:	200d883a 	mov	r6,r4
81149238:	180b883a 	mov	r5,r3
8114923c:	e13ff317 	ldw	r4,-52(fp)
81149240:	113c1940 	call	8113c194 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81149244:	e0bffc17 	ldw	r2,-16(fp)
81149248:	10c00417 	ldw	r3,16(r2)
8114924c:	e0bff217 	ldw	r2,-56(fp)
81149250:	18bfe726 	beq	r3,r2,811491f0 <__reset+0xfb1291f0>
      }
    }

    count--;
81149254:	e0bfef17 	ldw	r2,-68(fp)
81149258:	10bfffc4 	addi	r2,r2,-1
8114925c:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81149260:	e0bffc17 	ldw	r2,-16(fp)
81149264:	10c00517 	ldw	r3,20(r2)
81149268:	e0bffd17 	ldw	r2,-12(fp)
8114926c:	11000044 	addi	r4,r2,1
81149270:	e13ffd15 	stw	r4,-12(fp)
81149274:	10800003 	ldbu	r2,0(r2)
81149278:	1009883a 	mov	r4,r2
8114927c:	e0bffc17 	ldw	r2,-16(fp)
81149280:	10c5883a 	add	r2,r2,r3
81149284:	10801a04 	addi	r2,r2,104
81149288:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
8114928c:	e0bffc17 	ldw	r2,-16(fp)
81149290:	e0fff217 	ldw	r3,-56(fp)
81149294:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149298:	e0bfef17 	ldw	r2,-68(fp)
8114929c:	103fad1e 	bne	r2,zero,81149154 <__reset+0xfb129154>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
811492a0:	e0bffc17 	ldw	r2,-16(fp)
811492a4:	10800917 	ldw	r2,36(r2)
811492a8:	1009883a 	mov	r4,r2
811492ac:	11401bc0 	call	811401bc <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811492b0:	0005303a 	rdctl	r2,status
811492b4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811492b8:	e0fff717 	ldw	r3,-36(fp)
811492bc:	00bfff84 	movi	r2,-2
811492c0:	1884703a 	and	r2,r3,r2
811492c4:	1001703a 	wrctl	status,r2
  
  return context;
811492c8:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
811492cc:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811492d0:	e0bffc17 	ldw	r2,-16(fp)
811492d4:	10800117 	ldw	r2,4(r2)
811492d8:	10c11014 	ori	r3,r2,1088
811492dc:	e0bffc17 	ldw	r2,-16(fp)
811492e0:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811492e4:	e0bffc17 	ldw	r2,-16(fp)
811492e8:	10800017 	ldw	r2,0(r2)
811492ec:	10800304 	addi	r2,r2,12
811492f0:	e0fffc17 	ldw	r3,-16(fp)
811492f4:	18c00117 	ldw	r3,4(r3)
811492f8:	10c00035 	stwio	r3,0(r2)
811492fc:	e0bff417 	ldw	r2,-48(fp)
81149300:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149304:	e0bff617 	ldw	r2,-40(fp)
81149308:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
8114930c:	e0fffe17 	ldw	r3,-8(fp)
81149310:	e0bfef17 	ldw	r2,-68(fp)
81149314:	1885c83a 	sub	r2,r3,r2
}
81149318:	e037883a 	mov	sp,fp
8114931c:	dfc00117 	ldw	ra,4(sp)
81149320:	df000017 	ldw	fp,0(sp)
81149324:	dec00204 	addi	sp,sp,8
81149328:	f800283a 	ret

8114932c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114932c:	defffe04 	addi	sp,sp,-8
81149330:	de00012e 	bgeu	sp,et,81149338 <alt_get_errno+0xc>
81149334:	003b68fa 	trap	3
81149338:	dfc00115 	stw	ra,4(sp)
8114933c:	df000015 	stw	fp,0(sp)
81149340:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149344:	d0a01017 	ldw	r2,-32704(gp)
81149348:	10000326 	beq	r2,zero,81149358 <alt_get_errno+0x2c>
8114934c:	d0a01017 	ldw	r2,-32704(gp)
81149350:	103ee83a 	callr	r2
81149354:	00000106 	br	8114935c <alt_get_errno+0x30>
81149358:	d0a07804 	addi	r2,gp,-32288
}
8114935c:	e037883a 	mov	sp,fp
81149360:	dfc00117 	ldw	ra,4(sp)
81149364:	df000017 	ldw	fp,0(sp)
81149368:	dec00204 	addi	sp,sp,8
8114936c:	f800283a 	ret

81149370 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81149370:	defffc04 	addi	sp,sp,-16
81149374:	de00012e 	bgeu	sp,et,8114937c <alt_msgdma_write_standard_descriptor+0xc>
81149378:	003b68fa 	trap	3
8114937c:	df000315 	stw	fp,12(sp)
81149380:	df000304 	addi	fp,sp,12
81149384:	e13ffd15 	stw	r4,-12(fp)
81149388:	e17ffe15 	stw	r5,-8(fp)
8114938c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81149390:	e0bffd17 	ldw	r2,-12(fp)
81149394:	10800037 	ldwio	r2,0(r2)
81149398:	1080010c 	andi	r2,r2,4
8114939c:	10000226 	beq	r2,zero,811493a8 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
811493a0:	00bff904 	movi	r2,-28
811493a4:	00001506 	br	811493fc <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
811493a8:	e0bfff17 	ldw	r2,-4(fp)
811493ac:	10800017 	ldw	r2,0(r2)
811493b0:	1007883a 	mov	r3,r2
811493b4:	e0bffe17 	ldw	r2,-8(fp)
811493b8:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
811493bc:	e0bffe17 	ldw	r2,-8(fp)
811493c0:	10800104 	addi	r2,r2,4
811493c4:	e0ffff17 	ldw	r3,-4(fp)
811493c8:	18c00117 	ldw	r3,4(r3)
811493cc:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
811493d0:	e0bffe17 	ldw	r2,-8(fp)
811493d4:	10800204 	addi	r2,r2,8
811493d8:	e0ffff17 	ldw	r3,-4(fp)
811493dc:	18c00217 	ldw	r3,8(r3)
811493e0:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
811493e4:	e0bffe17 	ldw	r2,-8(fp)
811493e8:	10800304 	addi	r2,r2,12
811493ec:	e0ffff17 	ldw	r3,-4(fp)
811493f0:	18c00317 	ldw	r3,12(r3)
811493f4:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
811493f8:	0005883a 	mov	r2,zero
}
811493fc:	e037883a 	mov	sp,fp
81149400:	df000017 	ldw	fp,0(sp)
81149404:	dec00104 	addi	sp,sp,4
81149408:	f800283a 	ret

8114940c <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
8114940c:	defffc04 	addi	sp,sp,-16
81149410:	de00012e 	bgeu	sp,et,81149418 <alt_msgdma_write_extended_descriptor+0xc>
81149414:	003b68fa 	trap	3
81149418:	df000315 	stw	fp,12(sp)
8114941c:	df000304 	addi	fp,sp,12
81149420:	e13ffd15 	stw	r4,-12(fp)
81149424:	e17ffe15 	stw	r5,-8(fp)
81149428:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8114942c:	e0bffd17 	ldw	r2,-12(fp)
81149430:	10800037 	ldwio	r2,0(r2)
81149434:	1080010c 	andi	r2,r2,4
81149438:	10000226 	beq	r2,zero,81149444 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
8114943c:	00bff904 	movi	r2,-28
81149440:	00003b06 	br	81149530 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81149444:	e0bfff17 	ldw	r2,-4(fp)
81149448:	10800017 	ldw	r2,0(r2)
8114944c:	1007883a 	mov	r3,r2
81149450:	e0bffe17 	ldw	r2,-8(fp)
81149454:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81149458:	e0bffe17 	ldw	r2,-8(fp)
8114945c:	10800104 	addi	r2,r2,4
81149460:	e0ffff17 	ldw	r3,-4(fp)
81149464:	18c00117 	ldw	r3,4(r3)
81149468:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8114946c:	e0bffe17 	ldw	r2,-8(fp)
81149470:	10800204 	addi	r2,r2,8
81149474:	e0ffff17 	ldw	r3,-4(fp)
81149478:	18c00217 	ldw	r3,8(r3)
8114947c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81149480:	e0bffe17 	ldw	r2,-8(fp)
81149484:	10800304 	addi	r2,r2,12
81149488:	e0ffff17 	ldw	r3,-4(fp)
8114948c:	18c0030b 	ldhu	r3,12(r3)
81149490:	18ffffcc 	andi	r3,r3,65535
81149494:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81149498:	e0bffe17 	ldw	r2,-8(fp)
8114949c:	10800384 	addi	r2,r2,14
811494a0:	e0ffff17 	ldw	r3,-4(fp)
811494a4:	18c00383 	ldbu	r3,14(r3)
811494a8:	18c03fcc 	andi	r3,r3,255
811494ac:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
811494b0:	e0bffe17 	ldw	r2,-8(fp)
811494b4:	108003c4 	addi	r2,r2,15
811494b8:	e0ffff17 	ldw	r3,-4(fp)
811494bc:	18c003c3 	ldbu	r3,15(r3)
811494c0:	18c03fcc 	andi	r3,r3,255
811494c4:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
811494c8:	e0bffe17 	ldw	r2,-8(fp)
811494cc:	10800404 	addi	r2,r2,16
811494d0:	e0ffff17 	ldw	r3,-4(fp)
811494d4:	18c0040b 	ldhu	r3,16(r3)
811494d8:	18ffffcc 	andi	r3,r3,65535
811494dc:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
811494e0:	e0bffe17 	ldw	r2,-8(fp)
811494e4:	10800484 	addi	r2,r2,18
811494e8:	e0ffff17 	ldw	r3,-4(fp)
811494ec:	18c0048b 	ldhu	r3,18(r3)
811494f0:	18ffffcc 	andi	r3,r3,65535
811494f4:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
811494f8:	e0bffe17 	ldw	r2,-8(fp)
811494fc:	10800504 	addi	r2,r2,20
81149500:	0007883a 	mov	r3,zero
81149504:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81149508:	e0bffe17 	ldw	r2,-8(fp)
8114950c:	10800604 	addi	r2,r2,24
81149510:	0007883a 	mov	r3,zero
81149514:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81149518:	e0bffe17 	ldw	r2,-8(fp)
8114951c:	10800704 	addi	r2,r2,28
81149520:	e0ffff17 	ldw	r3,-4(fp)
81149524:	18c00717 	ldw	r3,28(r3)
81149528:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
8114952c:	0005883a 	mov	r2,zero
}
81149530:	e037883a 	mov	sp,fp
81149534:	df000017 	ldw	fp,0(sp)
81149538:	dec00104 	addi	sp,sp,4
8114953c:	f800283a 	ret

81149540 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81149540:	defff804 	addi	sp,sp,-32
81149544:	de00012e 	bgeu	sp,et,8114954c <alt_msgdma_irq+0xc>
81149548:	003b68fa 	trap	3
8114954c:	dfc00715 	stw	ra,28(sp)
81149550:	df000615 	stw	fp,24(sp)
81149554:	df000604 	addi	fp,sp,24
81149558:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
8114955c:	e0bfff17 	ldw	r2,-4(fp)
81149560:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81149564:	e0bffa17 	ldw	r2,-24(fp)
81149568:	10801783 	ldbu	r2,94(r2)
8114956c:	10803fcc 	andi	r2,r2,255
81149570:	10001126 	beq	r2,zero,811495b8 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81149574:	e0bffa17 	ldw	r2,-24(fp)
81149578:	10800617 	ldw	r2,24(r2)
8114957c:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81149580:	1007883a 	mov	r3,r2
81149584:	00bffdc4 	movi	r2,-9
81149588:	1884703a 	and	r2,r3,r2
8114958c:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81149590:	e0bffa17 	ldw	r2,-24(fp)
81149594:	10800617 	ldw	r2,24(r2)
81149598:	e0fffb17 	ldw	r3,-20(fp)
8114959c:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
811495a0:	e0bffa17 	ldw	r2,-24(fp)
811495a4:	10800617 	ldw	r2,24(r2)
811495a8:	10800404 	addi	r2,r2,16
811495ac:	00c00044 	movi	r3,1
811495b0:	10c00035 	stwio	r3,0(r2)
811495b4:	00001106 	br	811495fc <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
811495b8:	e0bffa17 	ldw	r2,-24(fp)
811495bc:	10800317 	ldw	r2,12(r2)
811495c0:	10800104 	addi	r2,r2,4
811495c4:	10800037 	ldwio	r2,0(r2)
811495c8:	1007883a 	mov	r3,r2
811495cc:	00bffbc4 	movi	r2,-17
811495d0:	1884703a 	and	r2,r3,r2
811495d4:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811495d8:	e0bffa17 	ldw	r2,-24(fp)
811495dc:	10800317 	ldw	r2,12(r2)
811495e0:	10800104 	addi	r2,r2,4
811495e4:	e0fffb17 	ldw	r3,-20(fp)
811495e8:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811495ec:	e0bffa17 	ldw	r2,-24(fp)
811495f0:	10800317 	ldw	r2,12(r2)
811495f4:	00c08004 	movi	r3,512
811495f8:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
811495fc:	e0bffa17 	ldw	r2,-24(fp)
81149600:	10800b17 	ldw	r2,44(r2)
81149604:	10001226 	beq	r2,zero,81149650 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149608:	0005303a 	rdctl	r2,status
8114960c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149610:	e0fffd17 	ldw	r3,-12(fp)
81149614:	00bfff84 	movi	r2,-2
81149618:	1884703a 	and	r2,r3,r2
8114961c:	1001703a 	wrctl	status,r2
  
  return context;
81149620:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81149624:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81149628:	e0bffa17 	ldw	r2,-24(fp)
8114962c:	10800b17 	ldw	r2,44(r2)
81149630:	e0fffa17 	ldw	r3,-24(fp)
81149634:	18c00c17 	ldw	r3,48(r3)
81149638:	1809883a 	mov	r4,r3
8114963c:	103ee83a 	callr	r2
81149640:	e0bffc17 	ldw	r2,-16(fp)
81149644:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149648:	e0bffe17 	ldw	r2,-8(fp)
8114964c:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81149650:	e0bffa17 	ldw	r2,-24(fp)
81149654:	10801783 	ldbu	r2,94(r2)
81149658:	10803fcc 	andi	r2,r2,255
8114965c:	10000a26 	beq	r2,zero,81149688 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81149660:	e0bffa17 	ldw	r2,-24(fp)
81149664:	10800617 	ldw	r2,24(r2)
81149668:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114966c:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81149670:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81149674:	e0bffa17 	ldw	r2,-24(fp)
81149678:	10800617 	ldw	r2,24(r2)
8114967c:	e0fffb17 	ldw	r3,-20(fp)
81149680:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81149684:	00000c06 	br	811496b8 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81149688:	e0bffa17 	ldw	r2,-24(fp)
8114968c:	10800317 	ldw	r2,12(r2)
81149690:	10800104 	addi	r2,r2,4
81149694:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81149698:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114969c:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811496a0:	e0bffa17 	ldw	r2,-24(fp)
811496a4:	10800317 	ldw	r2,12(r2)
811496a8:	10800104 	addi	r2,r2,4
811496ac:	e0fffb17 	ldw	r3,-20(fp)
811496b0:	10c00035 	stwio	r3,0(r2)
    }

    return;
811496b4:	0001883a 	nop
}
811496b8:	e037883a 	mov	sp,fp
811496bc:	dfc00117 	ldw	ra,4(sp)
811496c0:	df000017 	ldw	fp,0(sp)
811496c4:	dec00204 	addi	sp,sp,8
811496c8:	f800283a 	ret

811496cc <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
811496cc:	defffb04 	addi	sp,sp,-20
811496d0:	de00012e 	bgeu	sp,et,811496d8 <alt_msgdma_construct_standard_descriptor+0xc>
811496d4:	003b68fa 	trap	3
811496d8:	df000415 	stw	fp,16(sp)
811496dc:	df000404 	addi	fp,sp,16
811496e0:	e13ffc15 	stw	r4,-16(fp)
811496e4:	e17ffd15 	stw	r5,-12(fp)
811496e8:	e1bffe15 	stw	r6,-8(fp)
811496ec:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811496f0:	e0bffc17 	ldw	r2,-16(fp)
811496f4:	10c01217 	ldw	r3,72(r2)
811496f8:	e0800117 	ldw	r2,4(fp)
811496fc:	18800436 	bltu	r3,r2,81149710 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81149700:	e0bffc17 	ldw	r2,-16(fp)
81149704:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81149708:	10803fcc 	andi	r2,r2,255
8114970c:	10000226 	beq	r2,zero,81149718 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81149710:	00bffa84 	movi	r2,-22
81149714:	00000e06 	br	81149750 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81149718:	e0bffd17 	ldw	r2,-12(fp)
8114971c:	e0fffe17 	ldw	r3,-8(fp)
81149720:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81149724:	e0bffd17 	ldw	r2,-12(fp)
81149728:	e0ffff17 	ldw	r3,-4(fp)
8114972c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81149730:	e0bffd17 	ldw	r2,-12(fp)
81149734:	e0c00117 	ldw	r3,4(fp)
81149738:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114973c:	e0800217 	ldw	r2,8(fp)
81149740:	10e00034 	orhi	r3,r2,32768
81149744:	e0bffd17 	ldw	r2,-12(fp)
81149748:	10c00315 	stw	r3,12(r2)
    
    return 0;
8114974c:	0005883a 	mov	r2,zero
}
81149750:	e037883a 	mov	sp,fp
81149754:	df000017 	ldw	fp,0(sp)
81149758:	dec00104 	addi	sp,sp,4
8114975c:	f800283a 	ret

81149760 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81149760:	defff604 	addi	sp,sp,-40
81149764:	de00012e 	bgeu	sp,et,8114976c <alt_msgdma_construct_extended_descriptor+0xc>
81149768:	003b68fa 	trap	3
8114976c:	df000915 	stw	fp,36(sp)
81149770:	df000904 	addi	fp,sp,36
81149774:	e13ff715 	stw	r4,-36(fp)
81149778:	e17ff815 	stw	r5,-32(fp)
8114977c:	e1bff915 	stw	r6,-28(fp)
81149780:	e1fffa15 	stw	r7,-24(fp)
81149784:	e1800317 	ldw	r6,12(fp)
81149788:	e1400417 	ldw	r5,16(fp)
8114978c:	e1000517 	ldw	r4,20(fp)
81149790:	e0c00617 	ldw	r3,24(fp)
81149794:	e0800717 	ldw	r2,28(fp)
81149798:	e1bffb0d 	sth	r6,-20(fp)
8114979c:	e17ffc05 	stb	r5,-16(fp)
811497a0:	e13ffd05 	stb	r4,-12(fp)
811497a4:	e0fffe0d 	sth	r3,-8(fp)
811497a8:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
811497ac:	e0bff717 	ldw	r2,-36(fp)
811497b0:	10c01217 	ldw	r3,72(r2)
811497b4:	e0800117 	ldw	r2,4(fp)
811497b8:	18801936 	bltu	r3,r2,81149820 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811497bc:	e13ff717 	ldw	r4,-36(fp)
811497c0:	20801317 	ldw	r2,76(r4)
811497c4:	20c01417 	ldw	r3,80(r4)
811497c8:	e13ffe0b 	ldhu	r4,-8(fp)
811497cc:	213fffcc 	andi	r4,r4,65535
811497d0:	2015883a 	mov	r10,r4
811497d4:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
811497d8:	1ac01136 	bltu	r3,r11,81149820 <alt_msgdma_construct_extended_descriptor+0xc0>
811497dc:	58c0011e 	bne	r11,r3,811497e4 <alt_msgdma_construct_extended_descriptor+0x84>
811497e0:	12800f36 	bltu	r2,r10,81149820 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811497e4:	e13ff717 	ldw	r4,-36(fp)
811497e8:	20801317 	ldw	r2,76(r4)
811497ec:	20c01417 	ldw	r3,80(r4)
811497f0:	e13fff0b 	ldhu	r4,-4(fp)
811497f4:	213fffcc 	andi	r4,r4,65535
811497f8:	2011883a 	mov	r8,r4
811497fc:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81149800:	1a400736 	bltu	r3,r9,81149820 <alt_msgdma_construct_extended_descriptor+0xc0>
81149804:	48c0011e 	bne	r9,r3,8114980c <alt_msgdma_construct_extended_descriptor+0xac>
81149808:	12000536 	bltu	r2,r8,81149820 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114980c:	e0bff717 	ldw	r2,-36(fp)
81149810:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81149814:	10803fcc 	andi	r2,r2,255
81149818:	10800060 	cmpeqi	r2,r2,1
8114981c:	1000021e 	bne	r2,zero,81149828 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81149820:	00bffa84 	movi	r2,-22
81149824:	00002106 	br	811498ac <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
81149828:	e0bff817 	ldw	r2,-32(fp)
8114982c:	e0fff917 	ldw	r3,-28(fp)
81149830:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81149834:	e0bff817 	ldw	r2,-32(fp)
81149838:	e0fffa17 	ldw	r3,-24(fp)
8114983c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81149840:	e0bff817 	ldw	r2,-32(fp)
81149844:	e0c00117 	ldw	r3,4(fp)
81149848:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114984c:	e0bff817 	ldw	r2,-32(fp)
81149850:	e0fffb0b 	ldhu	r3,-20(fp)
81149854:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81149858:	e0bff817 	ldw	r2,-32(fp)
8114985c:	e0fffc03 	ldbu	r3,-16(fp)
81149860:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81149864:	e0bff817 	ldw	r2,-32(fp)
81149868:	e0fffd03 	ldbu	r3,-12(fp)
8114986c:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81149870:	e0bff817 	ldw	r2,-32(fp)
81149874:	e0fffe0b 	ldhu	r3,-8(fp)
81149878:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8114987c:	e0bff817 	ldw	r2,-32(fp)
81149880:	e0ffff0b 	ldhu	r3,-4(fp)
81149884:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81149888:	e0bff817 	ldw	r2,-32(fp)
8114988c:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81149890:	e0bff817 	ldw	r2,-32(fp)
81149894:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81149898:	e0800217 	ldw	r2,8(fp)
8114989c:	10e00034 	orhi	r3,r2,32768
811498a0:	e0bff817 	ldw	r2,-32(fp)
811498a4:	10c00715 	stw	r3,28(r2)

  return 0 ;
811498a8:	0005883a 	mov	r2,zero

}
811498ac:	e037883a 	mov	sp,fp
811498b0:	df000017 	ldw	fp,0(sp)
811498b4:	dec00104 	addi	sp,sp,4
811498b8:	f800283a 	ret

811498bc <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811498bc:	deffee04 	addi	sp,sp,-72
811498c0:	de00012e 	bgeu	sp,et,811498c8 <alt_msgdma_descriptor_async_transfer+0xc>
811498c4:	003b68fa 	trap	3
811498c8:	dfc01115 	stw	ra,68(sp)
811498cc:	df001015 	stw	fp,64(sp)
811498d0:	df001004 	addi	fp,sp,64
811498d4:	e13ffd15 	stw	r4,-12(fp)
811498d8:	e17ffe15 	stw	r5,-8(fp)
811498dc:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
811498e0:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
811498e4:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
811498e8:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811498ec:	e0bffd17 	ldw	r2,-12(fp)
811498f0:	10800317 	ldw	r2,12(r2)
811498f4:	10800204 	addi	r2,r2,8
811498f8:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811498fc:	10bfffcc 	andi	r2,r2,65535
81149900:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149904:	e0bffd17 	ldw	r2,-12(fp)
81149908:	10800317 	ldw	r2,12(r2)
8114990c:	10800204 	addi	r2,r2,8
81149910:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81149914:	1004d43a 	srli	r2,r2,16
81149918:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114991c:	e0bffd17 	ldw	r2,-12(fp)
81149920:	10800917 	ldw	r2,36(r2)
81149924:	e0fff417 	ldw	r3,-48(fp)
81149928:	1880042e 	bgeu	r3,r2,8114993c <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114992c:	e0bffd17 	ldw	r2,-12(fp)
81149930:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149934:	e0fff317 	ldw	r3,-52(fp)
81149938:	18800236 	bltu	r3,r2,81149944 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
8114993c:	00bff904 	movi	r2,-28
81149940:	0000a906 	br	81149be8 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81149944:	e0bffd17 	ldw	r2,-12(fp)
81149948:	10801817 	ldw	r2,96(r2)
8114994c:	e0bff615 	stw	r2,-40(fp)
81149950:	e03ffc0d 	sth	zero,-16(fp)
81149954:	e0bffc0b 	ldhu	r2,-16(fp)
81149958:	e0fffc84 	addi	r3,fp,-14
8114995c:	180d883a 	mov	r6,r3
81149960:	100b883a 	mov	r5,r2
81149964:	e13ff617 	ldw	r4,-40(fp)
81149968:	113fe340 	call	8113fe34 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114996c:	00800804 	movi	r2,32
81149970:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149974:	0005303a 	rdctl	r2,status
81149978:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114997c:	e0fff717 	ldw	r3,-36(fp)
81149980:	00bfff84 	movi	r2,-2
81149984:	1884703a 	and	r2,r3,r2
81149988:	1001703a 	wrctl	status,r2
  
  return context;
8114998c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81149990:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149994:	e0bffd17 	ldw	r2,-12(fp)
81149998:	10800317 	ldw	r2,12(r2)
8114999c:	10800104 	addi	r2,r2,4
811499a0:	e0fff117 	ldw	r3,-60(fp)
811499a4:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
811499a8:	e0bffd17 	ldw	r2,-12(fp)
811499ac:	10800317 	ldw	r2,12(r2)
811499b0:	e0fffd17 	ldw	r3,-12(fp)
811499b4:	18c00317 	ldw	r3,12(r3)
811499b8:	18c00037 	ldwio	r3,0(r3)
811499bc:	10c00035 	stwio	r3,0(r2)
811499c0:	e0bff217 	ldw	r2,-56(fp)
811499c4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811499c8:	e0bffb17 	ldw	r2,-20(fp)
811499cc:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811499d0:	e0bffe17 	ldw	r2,-8(fp)
811499d4:	10001e26 	beq	r2,zero,81149a50 <alt_msgdma_descriptor_async_transfer+0x194>
811499d8:	e0bfff17 	ldw	r2,-4(fp)
811499dc:	10001c1e 	bne	r2,zero,81149a50 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811499e0:	00001106 	br	81149a28 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811499e4:	01000044 	movi	r4,1
811499e8:	11375bc0 	call	811375bc <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811499ec:	e0bff00b 	ldhu	r2,-64(fp)
811499f0:	1084e230 	cmpltui	r2,r2,5000
811499f4:	1000091e 	bne	r2,zero,81149a1c <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
811499f8:	01204574 	movhi	r4,33045
811499fc:	21091804 	addi	r4,r4,9312
81149a00:	114bd100 	call	8114bd10 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149a04:	e0bffd17 	ldw	r2,-12(fp)
81149a08:	10801817 	ldw	r2,96(r2)
81149a0c:	1009883a 	mov	r4,r2
81149a10:	11401bc0 	call	811401bc <OSSemPost>
				
                return -ETIME;
81149a14:	00bff084 	movi	r2,-62
81149a18:	00007306 	br	81149be8 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81149a1c:	e0bff00b 	ldhu	r2,-64(fp)
81149a20:	10800044 	addi	r2,r2,1
81149a24:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81149a28:	e0bffd17 	ldw	r2,-12(fp)
81149a2c:	10c00317 	ldw	r3,12(r2)
81149a30:	e0bffd17 	ldw	r2,-12(fp)
81149a34:	10800417 	ldw	r2,16(r2)
81149a38:	e1bffe17 	ldw	r6,-8(fp)
81149a3c:	100b883a 	mov	r5,r2
81149a40:	1809883a 	mov	r4,r3
81149a44:	11493700 	call	81149370 <alt_msgdma_write_standard_descriptor>
81149a48:	103fe61e 	bne	r2,zero,811499e4 <__reset+0xfb1299e4>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81149a4c:	00002706 	br	81149aec <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149a50:	e0bffe17 	ldw	r2,-8(fp)
81149a54:	10001f1e 	bne	r2,zero,81149ad4 <alt_msgdma_descriptor_async_transfer+0x218>
81149a58:	e0bfff17 	ldw	r2,-4(fp)
81149a5c:	10001d26 	beq	r2,zero,81149ad4 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81149a60:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149a64:	00001106 	br	81149aac <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81149a68:	01000044 	movi	r4,1
81149a6c:	11375bc0 	call	811375bc <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149a70:	e0bff00b 	ldhu	r2,-64(fp)
81149a74:	1084e230 	cmpltui	r2,r2,5000
81149a78:	1000091e 	bne	r2,zero,81149aa0 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81149a7c:	01204574 	movhi	r4,33045
81149a80:	21092e04 	addi	r4,r4,9400
81149a84:	114bd100 	call	8114bd10 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149a88:	e0bffd17 	ldw	r2,-12(fp)
81149a8c:	10801817 	ldw	r2,96(r2)
81149a90:	1009883a 	mov	r4,r2
81149a94:	11401bc0 	call	811401bc <OSSemPost>
				
                return -ETIME;
81149a98:	00bff084 	movi	r2,-62
81149a9c:	00005206 	br	81149be8 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81149aa0:	e0bff00b 	ldhu	r2,-64(fp)
81149aa4:	10800044 	addi	r2,r2,1
81149aa8:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149aac:	e0bffd17 	ldw	r2,-12(fp)
81149ab0:	10c00317 	ldw	r3,12(r2)
81149ab4:	e0bffd17 	ldw	r2,-12(fp)
81149ab8:	10800417 	ldw	r2,16(r2)
81149abc:	e1bfff17 	ldw	r6,-4(fp)
81149ac0:	100b883a 	mov	r5,r2
81149ac4:	1809883a 	mov	r4,r3
81149ac8:	114940c0 	call	8114940c <alt_msgdma_write_extended_descriptor>
81149acc:	103fe61e 	bne	r2,zero,81149a68 <__reset+0xfb129a68>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149ad0:	00000606 	br	81149aec <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81149ad4:	e0bffd17 	ldw	r2,-12(fp)
81149ad8:	10801817 	ldw	r2,96(r2)
81149adc:	1009883a 	mov	r4,r2
81149ae0:	11401bc0 	call	811401bc <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81149ae4:	00bfffc4 	movi	r2,-1
81149ae8:	00003f06 	br	81149be8 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81149aec:	e0bffd17 	ldw	r2,-12(fp)
81149af0:	10800b17 	ldw	r2,44(r2)
81149af4:	10001c26 	beq	r2,zero,81149b68 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81149af8:	e0bffd17 	ldw	r2,-12(fp)
81149afc:	10c00d17 	ldw	r3,52(r2)
81149b00:	e0bff117 	ldw	r2,-60(fp)
81149b04:	1884b03a 	or	r2,r3,r2
81149b08:	10800514 	ori	r2,r2,20
81149b0c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81149b10:	e0fff117 	ldw	r3,-60(fp)
81149b14:	00bff7c4 	movi	r2,-33
81149b18:	1884703a 	and	r2,r3,r2
81149b1c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149b20:	0005303a 	rdctl	r2,status
81149b24:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149b28:	e0fff917 	ldw	r3,-28(fp)
81149b2c:	00bfff84 	movi	r2,-2
81149b30:	1884703a 	and	r2,r3,r2
81149b34:	1001703a 	wrctl	status,r2
  
  return context;
81149b38:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81149b3c:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149b40:	e0bffd17 	ldw	r2,-12(fp)
81149b44:	10800317 	ldw	r2,12(r2)
81149b48:	10800104 	addi	r2,r2,4
81149b4c:	e0fff117 	ldw	r3,-60(fp)
81149b50:	10c00035 	stwio	r3,0(r2)
81149b54:	e0bff217 	ldw	r2,-56(fp)
81149b58:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149b5c:	e0bff517 	ldw	r2,-44(fp)
81149b60:	1001703a 	wrctl	status,r2
81149b64:	00001b06 	br	81149bd4 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81149b68:	e0bffd17 	ldw	r2,-12(fp)
81149b6c:	10c00d17 	ldw	r3,52(r2)
81149b70:	e0bff117 	ldw	r2,-60(fp)
81149b74:	1884b03a 	or	r2,r3,r2
81149b78:	10800114 	ori	r2,r2,4
81149b7c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81149b80:	e0fff117 	ldw	r3,-60(fp)
81149b84:	00bff3c4 	movi	r2,-49
81149b88:	1884703a 	and	r2,r3,r2
81149b8c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149b90:	0005303a 	rdctl	r2,status
81149b94:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149b98:	e0fffa17 	ldw	r3,-24(fp)
81149b9c:	00bfff84 	movi	r2,-2
81149ba0:	1884703a 	and	r2,r3,r2
81149ba4:	1001703a 	wrctl	status,r2
  
  return context;
81149ba8:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81149bac:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149bb0:	e0bffd17 	ldw	r2,-12(fp)
81149bb4:	10800317 	ldw	r2,12(r2)
81149bb8:	10800104 	addi	r2,r2,4
81149bbc:	e0fff117 	ldw	r3,-60(fp)
81149bc0:	10c00035 	stwio	r3,0(r2)
81149bc4:	e0bff217 	ldw	r2,-56(fp)
81149bc8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149bcc:	e0bff817 	ldw	r2,-32(fp)
81149bd0:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81149bd4:	e0bffd17 	ldw	r2,-12(fp)
81149bd8:	10801817 	ldw	r2,96(r2)
81149bdc:	1009883a 	mov	r4,r2
81149be0:	11401bc0 	call	811401bc <OSSemPost>
    
    return 0;
81149be4:	0005883a 	mov	r2,zero
}
81149be8:	e037883a 	mov	sp,fp
81149bec:	dfc00117 	ldw	ra,4(sp)
81149bf0:	df000017 	ldw	fp,0(sp)
81149bf4:	dec00204 	addi	sp,sp,8
81149bf8:	f800283a 	ret

81149bfc <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81149bfc:	deffee04 	addi	sp,sp,-72
81149c00:	de00012e 	bgeu	sp,et,81149c08 <alt_msgdma_descriptor_sync_transfer+0xc>
81149c04:	003b68fa 	trap	3
81149c08:	dfc01115 	stw	ra,68(sp)
81149c0c:	df001015 	stw	fp,64(sp)
81149c10:	df001004 	addi	fp,sp,64
81149c14:	e13ffd15 	stw	r4,-12(fp)
81149c18:	e17ffe15 	stw	r5,-8(fp)
81149c1c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81149c20:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81149c24:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
81149c28:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81149c2c:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149c30:	e0bffd17 	ldw	r2,-12(fp)
81149c34:	10800317 	ldw	r2,12(r2)
81149c38:	10800204 	addi	r2,r2,8
81149c3c:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81149c40:	10bfffcc 	andi	r2,r2,65535
81149c44:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149c48:	e0bffd17 	ldw	r2,-12(fp)
81149c4c:	10800317 	ldw	r2,12(r2)
81149c50:	10800204 	addi	r2,r2,8
81149c54:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81149c58:	1004d43a 	srli	r2,r2,16
81149c5c:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81149c60:	00807804 	movi	r2,480
81149c64:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149c68:	00001906 	br	81149cd0 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81149c6c:	01000044 	movi	r4,1
81149c70:	11375bc0 	call	811375bc <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149c74:	e0bff10b 	ldhu	r2,-60(fp)
81149c78:	1084e230 	cmpltui	r2,r2,5000
81149c7c:	1000051e 	bne	r2,zero,81149c94 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81149c80:	01204574 	movhi	r4,33045
81149c84:	21094404 	addi	r4,r4,9488
81149c88:	114bd100 	call	8114bd10 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81149c8c:	00bff084 	movi	r2,-62
81149c90:	0000d706 	br	81149ff0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81149c94:	e0bff10b 	ldhu	r2,-60(fp)
81149c98:	10800044 	addi	r2,r2,1
81149c9c:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149ca0:	e0bffd17 	ldw	r2,-12(fp)
81149ca4:	10800317 	ldw	r2,12(r2)
81149ca8:	10800204 	addi	r2,r2,8
81149cac:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81149cb0:	10bfffcc 	andi	r2,r2,65535
81149cb4:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149cb8:	e0bffd17 	ldw	r2,-12(fp)
81149cbc:	10800317 	ldw	r2,12(r2)
81149cc0:	10800204 	addi	r2,r2,8
81149cc4:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81149cc8:	1004d43a 	srli	r2,r2,16
81149ccc:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149cd0:	e0bffd17 	ldw	r2,-12(fp)
81149cd4:	10800917 	ldw	r2,36(r2)
81149cd8:	e0fff317 	ldw	r3,-52(fp)
81149cdc:	18bfe32e 	bgeu	r3,r2,81149c6c <__reset+0xfb129c6c>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81149ce0:	e0bffd17 	ldw	r2,-12(fp)
81149ce4:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149ce8:	e0fff217 	ldw	r3,-56(fp)
81149cec:	18bfdf2e 	bgeu	r3,r2,81149c6c <__reset+0xfb129c6c>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81149cf0:	e0bffd17 	ldw	r2,-12(fp)
81149cf4:	10801817 	ldw	r2,96(r2)
81149cf8:	e0bff815 	stw	r2,-32(fp)
81149cfc:	e03ffc0d 	sth	zero,-16(fp)
81149d00:	e0bffc0b 	ldhu	r2,-16(fp)
81149d04:	e0fffc84 	addi	r3,fp,-14
81149d08:	180d883a 	mov	r6,r3
81149d0c:	100b883a 	mov	r5,r2
81149d10:	e13ff817 	ldw	r4,-32(fp)
81149d14:	113fe340 	call	8113fe34 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149d18:	0005303a 	rdctl	r2,status
81149d1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149d20:	e0fffb17 	ldw	r3,-20(fp)
81149d24:	00bfff84 	movi	r2,-2
81149d28:	1884703a 	and	r2,r3,r2
81149d2c:	1001703a 	wrctl	status,r2
  
  return context;
81149d30:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81149d34:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81149d38:	e0bffd17 	ldw	r2,-12(fp)
81149d3c:	10800317 	ldw	r2,12(r2)
81149d40:	10800104 	addi	r2,r2,4
81149d44:	00c00804 	movi	r3,32
81149d48:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81149d4c:	e0bffd17 	ldw	r2,-12(fp)
81149d50:	10800317 	ldw	r2,12(r2)
81149d54:	e0fffd17 	ldw	r3,-12(fp)
81149d58:	18c00317 	ldw	r3,12(r3)
81149d5c:	18c00037 	ldwio	r3,0(r3)
81149d60:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81149d64:	e0bffe17 	ldw	r2,-8(fp)
81149d68:	10001f26 	beq	r2,zero,81149de8 <alt_msgdma_descriptor_sync_transfer+0x1ec>
81149d6c:	e0bfff17 	ldw	r2,-4(fp)
81149d70:	10001d1e 	bne	r2,zero,81149de8 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81149d74:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81149d78:	00001106 	br	81149dc0 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81149d7c:	01000044 	movi	r4,1
81149d80:	11375bc0 	call	811375bc <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149d84:	e0bff10b 	ldhu	r2,-60(fp)
81149d88:	1084e230 	cmpltui	r2,r2,5000
81149d8c:	1000091e 	bne	r2,zero,81149db4 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81149d90:	01204574 	movhi	r4,33045
81149d94:	21095804 	addi	r4,r4,9568
81149d98:	114bd100 	call	8114bd10 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149d9c:	e0bffd17 	ldw	r2,-12(fp)
81149da0:	10801817 	ldw	r2,96(r2)
81149da4:	1009883a 	mov	r4,r2
81149da8:	11401bc0 	call	811401bc <OSSemPost>
				
                return -ETIME;
81149dac:	00bff084 	movi	r2,-62
81149db0:	00008f06 	br	81149ff0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81149db4:	e0bff10b 	ldhu	r2,-60(fp)
81149db8:	10800044 	addi	r2,r2,1
81149dbc:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81149dc0:	e0bffd17 	ldw	r2,-12(fp)
81149dc4:	10c00317 	ldw	r3,12(r2)
81149dc8:	e0bffd17 	ldw	r2,-12(fp)
81149dcc:	10800417 	ldw	r2,16(r2)
81149dd0:	e1bffe17 	ldw	r6,-8(fp)
81149dd4:	100b883a 	mov	r5,r2
81149dd8:	1809883a 	mov	r4,r3
81149ddc:	11493700 	call	81149370 <alt_msgdma_write_standard_descriptor>
81149de0:	103fe61e 	bne	r2,zero,81149d7c <__reset+0xfb129d7c>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81149de4:	00002706 	br	81149e84 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149de8:	e0bffe17 	ldw	r2,-8(fp)
81149dec:	10001f1e 	bne	r2,zero,81149e6c <alt_msgdma_descriptor_sync_transfer+0x270>
81149df0:	e0bfff17 	ldw	r2,-4(fp)
81149df4:	10001d26 	beq	r2,zero,81149e6c <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81149df8:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149dfc:	00001106 	br	81149e44 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81149e00:	01000044 	movi	r4,1
81149e04:	11375bc0 	call	811375bc <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149e08:	e0bff10b 	ldhu	r2,-60(fp)
81149e0c:	1084e230 	cmpltui	r2,r2,5000
81149e10:	1000091e 	bne	r2,zero,81149e38 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81149e14:	01204574 	movhi	r4,33045
81149e18:	21096904 	addi	r4,r4,9636
81149e1c:	114bd100 	call	8114bd10 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149e20:	e0bffd17 	ldw	r2,-12(fp)
81149e24:	10801817 	ldw	r2,96(r2)
81149e28:	1009883a 	mov	r4,r2
81149e2c:	11401bc0 	call	811401bc <OSSemPost>
				
                return -ETIME;
81149e30:	00bff084 	movi	r2,-62
81149e34:	00006e06 	br	81149ff0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81149e38:	e0bff10b 	ldhu	r2,-60(fp)
81149e3c:	10800044 	addi	r2,r2,1
81149e40:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149e44:	e0bffd17 	ldw	r2,-12(fp)
81149e48:	10c00317 	ldw	r3,12(r2)
81149e4c:	e0bffd17 	ldw	r2,-12(fp)
81149e50:	10800417 	ldw	r2,16(r2)
81149e54:	e1bfff17 	ldw	r6,-4(fp)
81149e58:	100b883a 	mov	r5,r2
81149e5c:	1809883a 	mov	r4,r3
81149e60:	114940c0 	call	8114940c <alt_msgdma_write_extended_descriptor>
81149e64:	103fe61e 	bne	r2,zero,81149e00 <__reset+0xfb129e00>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149e68:	00000606 	br	81149e84 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81149e6c:	e0bffd17 	ldw	r2,-12(fp)
81149e70:	10801817 	ldw	r2,96(r2)
81149e74:	1009883a 	mov	r4,r2
81149e78:	11401bc0 	call	811401bc <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81149e7c:	00bfffc4 	movi	r2,-1
81149e80:	00005b06 	br	81149ff0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81149e84:	e0bffd17 	ldw	r2,-12(fp)
81149e88:	10800317 	ldw	r2,12(r2)
81149e8c:	10800104 	addi	r2,r2,4
81149e90:	e0fffd17 	ldw	r3,-12(fp)
81149e94:	19000d17 	ldw	r4,52(r3)
81149e98:	00fff2c4 	movi	r3,-53
81149e9c:	20c6703a 	and	r3,r4,r3
81149ea0:	18c00114 	ori	r3,r3,4
81149ea4:	10c00035 	stwio	r3,0(r2)
81149ea8:	e0bff517 	ldw	r2,-44(fp)
81149eac:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149eb0:	e0bff717 	ldw	r2,-36(fp)
81149eb4:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81149eb8:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81149ebc:	e0bffd17 	ldw	r2,-12(fp)
81149ec0:	10800317 	ldw	r2,12(r2)
81149ec4:	10800037 	ldwio	r2,0(r2)
81149ec8:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81149ecc:	00001506 	br	81149f24 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81149ed0:	01000044 	movi	r4,1
81149ed4:	11375bc0 	call	811375bc <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149ed8:	e0bff10b 	ldhu	r2,-60(fp)
81149edc:	1084e230 	cmpltui	r2,r2,5000
81149ee0:	1000091e 	bne	r2,zero,81149f08 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81149ee4:	01204574 	movhi	r4,33045
81149ee8:	21097a04 	addi	r4,r4,9704
81149eec:	114bd100 	call	8114bd10 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81149ef0:	e0bffd17 	ldw	r2,-12(fp)
81149ef4:	10801817 	ldw	r2,96(r2)
81149ef8:	1009883a 	mov	r4,r2
81149efc:	11401bc0 	call	811401bc <OSSemPost>
			
            return -ETIME;
81149f00:	00bff084 	movi	r2,-62
81149f04:	00003a06 	br	81149ff0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81149f08:	e0bff10b 	ldhu	r2,-60(fp)
81149f0c:	10800044 	addi	r2,r2,1
81149f10:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81149f14:	e0bffd17 	ldw	r2,-12(fp)
81149f18:	10800317 	ldw	r2,12(r2)
81149f1c:	10800037 	ldwio	r2,0(r2)
81149f20:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81149f24:	e0fff017 	ldw	r3,-64(fp)
81149f28:	e0bff617 	ldw	r2,-40(fp)
81149f2c:	1884703a 	and	r2,r3,r2
81149f30:	1000031e 	bne	r2,zero,81149f40 <alt_msgdma_descriptor_sync_transfer+0x344>
81149f34:	e0bff017 	ldw	r2,-64(fp)
81149f38:	1080004c 	andi	r2,r2,1
81149f3c:	103fe41e 	bne	r2,zero,81149ed0 <__reset+0xfb129ed0>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81149f40:	e0fff017 	ldw	r3,-64(fp)
81149f44:	e0bff617 	ldw	r2,-40(fp)
81149f48:	1884703a 	and	r2,r3,r2
81149f4c:	10000626 	beq	r2,zero,81149f68 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81149f50:	e0bffd17 	ldw	r2,-12(fp)
81149f54:	10801817 	ldw	r2,96(r2)
81149f58:	1009883a 	mov	r4,r2
81149f5c:	11401bc0 	call	811401bc <OSSemPost>
		
        return error;
81149f60:	e0bff617 	ldw	r2,-40(fp)
81149f64:	00002206 	br	81149ff0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81149f68:	e0bffd17 	ldw	r2,-12(fp)
81149f6c:	10800317 	ldw	r2,12(r2)
81149f70:	10800104 	addi	r2,r2,4
81149f74:	10800037 	ldwio	r2,0(r2)
81149f78:	10800814 	ori	r2,r2,32
81149f7c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149f80:	0005303a 	rdctl	r2,status
81149f84:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149f88:	e0fffa17 	ldw	r3,-24(fp)
81149f8c:	00bfff84 	movi	r2,-2
81149f90:	1884703a 	and	r2,r3,r2
81149f94:	1001703a 	wrctl	status,r2
  
  return context;
81149f98:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81149f9c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149fa0:	e0bffd17 	ldw	r2,-12(fp)
81149fa4:	10800317 	ldw	r2,12(r2)
81149fa8:	10800104 	addi	r2,r2,4
81149fac:	e0fff417 	ldw	r3,-48(fp)
81149fb0:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81149fb4:	e0bffd17 	ldw	r2,-12(fp)
81149fb8:	10800317 	ldw	r2,12(r2)
81149fbc:	e0fffd17 	ldw	r3,-12(fp)
81149fc0:	18c00317 	ldw	r3,12(r3)
81149fc4:	18c00037 	ldwio	r3,0(r3)
81149fc8:	10c00035 	stwio	r3,0(r2)
81149fcc:	e0bff517 	ldw	r2,-44(fp)
81149fd0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149fd4:	e0bff917 	ldw	r2,-28(fp)
81149fd8:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81149fdc:	e0bffd17 	ldw	r2,-12(fp)
81149fe0:	10801817 	ldw	r2,96(r2)
81149fe4:	1009883a 	mov	r4,r2
81149fe8:	11401bc0 	call	811401bc <OSSemPost>
    
    return 0;
81149fec:	0005883a 	mov	r2,zero

}
81149ff0:	e037883a 	mov	sp,fp
81149ff4:	dfc00117 	ldw	ra,4(sp)
81149ff8:	df000017 	ldw	fp,0(sp)
81149ffc:	dec00204 	addi	sp,sp,8
8114a000:	f800283a 	ret

8114a004 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
8114a004:	defff804 	addi	sp,sp,-32
8114a008:	de00012e 	bgeu	sp,et,8114a010 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
8114a00c:	003b68fa 	trap	3
8114a010:	dfc00715 	stw	ra,28(sp)
8114a014:	df000615 	stw	fp,24(sp)
8114a018:	df000604 	addi	fp,sp,24
8114a01c:	e13ffc15 	stw	r4,-16(fp)
8114a020:	e17ffd15 	stw	r5,-12(fp)
8114a024:	e1bffe15 	stw	r6,-8(fp)
8114a028:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
8114a02c:	e0800217 	ldw	r2,8(fp)
8114a030:	d8800115 	stw	r2,4(sp)
8114a034:	e0bfff17 	ldw	r2,-4(fp)
8114a038:	d8800015 	stw	r2,0(sp)
8114a03c:	e1fffe17 	ldw	r7,-8(fp)
8114a040:	000d883a 	mov	r6,zero
8114a044:	e17ffd17 	ldw	r5,-12(fp)
8114a048:	e13ffc17 	ldw	r4,-16(fp)
8114a04c:	11496cc0 	call	811496cc <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114a050:	e037883a 	mov	sp,fp
8114a054:	dfc00117 	ldw	ra,4(sp)
8114a058:	df000017 	ldw	fp,0(sp)
8114a05c:	dec00204 	addi	sp,sp,8
8114a060:	f800283a 	ret

8114a064 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
8114a064:	defff804 	addi	sp,sp,-32
8114a068:	de00012e 	bgeu	sp,et,8114a070 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
8114a06c:	003b68fa 	trap	3
8114a070:	dfc00715 	stw	ra,28(sp)
8114a074:	df000615 	stw	fp,24(sp)
8114a078:	df000604 	addi	fp,sp,24
8114a07c:	e13ffc15 	stw	r4,-16(fp)
8114a080:	e17ffd15 	stw	r5,-12(fp)
8114a084:	e1bffe15 	stw	r6,-8(fp)
8114a088:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114a08c:	e0800217 	ldw	r2,8(fp)
8114a090:	d8800115 	stw	r2,4(sp)
8114a094:	e0bfff17 	ldw	r2,-4(fp)
8114a098:	d8800015 	stw	r2,0(sp)
8114a09c:	000f883a 	mov	r7,zero
8114a0a0:	e1bffe17 	ldw	r6,-8(fp)
8114a0a4:	e17ffd17 	ldw	r5,-12(fp)
8114a0a8:	e13ffc17 	ldw	r4,-16(fp)
8114a0ac:	11496cc0 	call	811496cc <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8114a0b0:	e037883a 	mov	sp,fp
8114a0b4:	dfc00117 	ldw	ra,4(sp)
8114a0b8:	df000017 	ldw	fp,0(sp)
8114a0bc:	dec00204 	addi	sp,sp,8
8114a0c0:	f800283a 	ret

8114a0c4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a0c4:	defff804 	addi	sp,sp,-32
8114a0c8:	de00012e 	bgeu	sp,et,8114a0d0 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
8114a0cc:	003b68fa 	trap	3
8114a0d0:	dfc00715 	stw	ra,28(sp)
8114a0d4:	df000615 	stw	fp,24(sp)
8114a0d8:	df000604 	addi	fp,sp,24
8114a0dc:	e13ffc15 	stw	r4,-16(fp)
8114a0e0:	e17ffd15 	stw	r5,-12(fp)
8114a0e4:	e1bffe15 	stw	r6,-8(fp)
8114a0e8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114a0ec:	e0800317 	ldw	r2,12(fp)
8114a0f0:	d8800115 	stw	r2,4(sp)
8114a0f4:	e0800217 	ldw	r2,8(fp)
8114a0f8:	d8800015 	stw	r2,0(sp)
8114a0fc:	e1ffff17 	ldw	r7,-4(fp)
8114a100:	e1bffe17 	ldw	r6,-8(fp)
8114a104:	e17ffd17 	ldw	r5,-12(fp)
8114a108:	e13ffc17 	ldw	r4,-16(fp)
8114a10c:	11496cc0 	call	811496cc <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114a110:	e037883a 	mov	sp,fp
8114a114:	dfc00117 	ldw	ra,4(sp)
8114a118:	df000017 	ldw	fp,0(sp)
8114a11c:	dec00204 	addi	sp,sp,8
8114a120:	f800283a 	ret

8114a124 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
8114a124:	defff004 	addi	sp,sp,-64
8114a128:	de00012e 	bgeu	sp,et,8114a130 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
8114a12c:	003b68fa 	trap	3
8114a130:	dfc00f15 	stw	ra,60(sp)
8114a134:	df000e15 	stw	fp,56(sp)
8114a138:	df000e04 	addi	fp,sp,56
8114a13c:	e13ff915 	stw	r4,-28(fp)
8114a140:	e17ffa15 	stw	r5,-24(fp)
8114a144:	e1bffb15 	stw	r6,-20(fp)
8114a148:	e1fffc15 	stw	r7,-16(fp)
8114a14c:	e1000317 	ldw	r4,12(fp)
8114a150:	e0c00417 	ldw	r3,16(fp)
8114a154:	e0800517 	ldw	r2,20(fp)
8114a158:	e13ffd0d 	sth	r4,-12(fp)
8114a15c:	e0fffe05 	stb	r3,-8(fp)
8114a160:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114a164:	e0bffd0b 	ldhu	r2,-12(fp)
8114a168:	e0fffe03 	ldbu	r3,-8(fp)
8114a16c:	e13fff0b 	ldhu	r4,-4(fp)
8114a170:	d9000615 	stw	r4,24(sp)
8114a174:	d8000515 	stw	zero,20(sp)
8114a178:	d8c00415 	stw	r3,16(sp)
8114a17c:	d8000315 	stw	zero,12(sp)
8114a180:	d8800215 	stw	r2,8(sp)
8114a184:	e0800217 	ldw	r2,8(fp)
8114a188:	d8800115 	stw	r2,4(sp)
8114a18c:	e0bffc17 	ldw	r2,-16(fp)
8114a190:	d8800015 	stw	r2,0(sp)
8114a194:	e1fffb17 	ldw	r7,-20(fp)
8114a198:	000d883a 	mov	r6,zero
8114a19c:	e17ffa17 	ldw	r5,-24(fp)
8114a1a0:	e13ff917 	ldw	r4,-28(fp)
8114a1a4:	11497600 	call	81149760 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8114a1a8:	e037883a 	mov	sp,fp
8114a1ac:	dfc00117 	ldw	ra,4(sp)
8114a1b0:	df000017 	ldw	fp,0(sp)
8114a1b4:	dec00204 	addi	sp,sp,8
8114a1b8:	f800283a 	ret

8114a1bc <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114a1bc:	defff004 	addi	sp,sp,-64
8114a1c0:	de00012e 	bgeu	sp,et,8114a1c8 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8114a1c4:	003b68fa 	trap	3
8114a1c8:	dfc00f15 	stw	ra,60(sp)
8114a1cc:	df000e15 	stw	fp,56(sp)
8114a1d0:	df000e04 	addi	fp,sp,56
8114a1d4:	e13ff915 	stw	r4,-28(fp)
8114a1d8:	e17ffa15 	stw	r5,-24(fp)
8114a1dc:	e1bffb15 	stw	r6,-20(fp)
8114a1e0:	e1fffc15 	stw	r7,-16(fp)
8114a1e4:	e1000317 	ldw	r4,12(fp)
8114a1e8:	e0c00417 	ldw	r3,16(fp)
8114a1ec:	e0800517 	ldw	r2,20(fp)
8114a1f0:	e13ffd0d 	sth	r4,-12(fp)
8114a1f4:	e0fffe05 	stb	r3,-8(fp)
8114a1f8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8114a1fc:	e0bffd0b 	ldhu	r2,-12(fp)
8114a200:	e0fffe03 	ldbu	r3,-8(fp)
8114a204:	e13fff0b 	ldhu	r4,-4(fp)
8114a208:	d8000615 	stw	zero,24(sp)
8114a20c:	d9000515 	stw	r4,20(sp)
8114a210:	d8000415 	stw	zero,16(sp)
8114a214:	d8c00315 	stw	r3,12(sp)
8114a218:	d8800215 	stw	r2,8(sp)
8114a21c:	e0800217 	ldw	r2,8(fp)
8114a220:	d8800115 	stw	r2,4(sp)
8114a224:	e0bffc17 	ldw	r2,-16(fp)
8114a228:	d8800015 	stw	r2,0(sp)
8114a22c:	000f883a 	mov	r7,zero
8114a230:	e1bffb17 	ldw	r6,-20(fp)
8114a234:	e17ffa17 	ldw	r5,-24(fp)
8114a238:	e13ff917 	ldw	r4,-28(fp)
8114a23c:	11497600 	call	81149760 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
8114a240:	e037883a 	mov	sp,fp
8114a244:	dfc00117 	ldw	ra,4(sp)
8114a248:	df000017 	ldw	fp,0(sp)
8114a24c:	dec00204 	addi	sp,sp,8
8114a250:	f800283a 	ret

8114a254 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8114a254:	deffee04 	addi	sp,sp,-72
8114a258:	de00012e 	bgeu	sp,et,8114a260 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
8114a25c:	003b68fa 	trap	3
8114a260:	dfc01115 	stw	ra,68(sp)
8114a264:	df001015 	stw	fp,64(sp)
8114a268:	df001004 	addi	fp,sp,64
8114a26c:	e13ff715 	stw	r4,-36(fp)
8114a270:	e17ff815 	stw	r5,-32(fp)
8114a274:	e1bff915 	stw	r6,-28(fp)
8114a278:	e1fffa15 	stw	r7,-24(fp)
8114a27c:	e1800417 	ldw	r6,16(fp)
8114a280:	e1400517 	ldw	r5,20(fp)
8114a284:	e1000617 	ldw	r4,24(fp)
8114a288:	e0c00717 	ldw	r3,28(fp)
8114a28c:	e0800817 	ldw	r2,32(fp)
8114a290:	e1bffb0d 	sth	r6,-20(fp)
8114a294:	e17ffc05 	stb	r5,-16(fp)
8114a298:	e13ffd05 	stb	r4,-12(fp)
8114a29c:	e0fffe0d 	sth	r3,-8(fp)
8114a2a0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114a2a4:	e0bffb0b 	ldhu	r2,-20(fp)
8114a2a8:	e0fffc03 	ldbu	r3,-16(fp)
8114a2ac:	e13ffd03 	ldbu	r4,-12(fp)
8114a2b0:	e17ffe0b 	ldhu	r5,-8(fp)
8114a2b4:	e1bfff0b 	ldhu	r6,-4(fp)
8114a2b8:	d9800615 	stw	r6,24(sp)
8114a2bc:	d9400515 	stw	r5,20(sp)
8114a2c0:	d9000415 	stw	r4,16(sp)
8114a2c4:	d8c00315 	stw	r3,12(sp)
8114a2c8:	d8800215 	stw	r2,8(sp)
8114a2cc:	e0800317 	ldw	r2,12(fp)
8114a2d0:	d8800115 	stw	r2,4(sp)
8114a2d4:	e0800217 	ldw	r2,8(fp)
8114a2d8:	d8800015 	stw	r2,0(sp)
8114a2dc:	e1fffa17 	ldw	r7,-24(fp)
8114a2e0:	e1bff917 	ldw	r6,-28(fp)
8114a2e4:	e17ff817 	ldw	r5,-32(fp)
8114a2e8:	e13ff717 	ldw	r4,-36(fp)
8114a2ec:	11497600 	call	81149760 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8114a2f0:	e037883a 	mov	sp,fp
8114a2f4:	dfc00117 	ldw	ra,4(sp)
8114a2f8:	df000017 	ldw	fp,0(sp)
8114a2fc:	dec00204 	addi	sp,sp,8
8114a300:	f800283a 	ret

8114a304 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a304:	defffb04 	addi	sp,sp,-20
8114a308:	de00012e 	bgeu	sp,et,8114a310 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
8114a30c:	003b68fa 	trap	3
8114a310:	df000415 	stw	fp,16(sp)
8114a314:	df000404 	addi	fp,sp,16
8114a318:	e13ffc15 	stw	r4,-16(fp)
8114a31c:	e17ffd15 	stw	r5,-12(fp)
8114a320:	e1bffe15 	stw	r6,-8(fp)
8114a324:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114a328:	e0bffc17 	ldw	r2,-16(fp)
8114a32c:	10c01217 	ldw	r3,72(r2)
8114a330:	e0800117 	ldw	r2,4(fp)
8114a334:	18800436 	bltu	r3,r2,8114a348 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114a338:	e0bffc17 	ldw	r2,-16(fp)
8114a33c:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114a340:	10803fcc 	andi	r2,r2,255
8114a344:	10000226 	beq	r2,zero,8114a350 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114a348:	00bffa84 	movi	r2,-22
8114a34c:	00001406 	br	8114a3a0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
8114a350:	e0bffd17 	ldw	r2,-12(fp)
8114a354:	e0fffe17 	ldw	r3,-8(fp)
8114a358:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114a35c:	e0bffd17 	ldw	r2,-12(fp)
8114a360:	e0ffff17 	ldw	r3,-4(fp)
8114a364:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a368:	e0bffd17 	ldw	r2,-12(fp)
8114a36c:	e0c00117 	ldw	r3,4(fp)
8114a370:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8114a374:	e0fffd17 	ldw	r3,-12(fp)
8114a378:	e0bffd17 	ldw	r2,-12(fp)
8114a37c:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a380:	e0c00217 	ldw	r3,8(fp)
8114a384:	00900034 	movhi	r2,16384
8114a388:	10bfffc4 	addi	r2,r2,-1
8114a38c:	1884703a 	and	r2,r3,r2
8114a390:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8114a394:	e0bffd17 	ldw	r2,-12(fp)
8114a398:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8114a39c:	0005883a 	mov	r2,zero
}
8114a3a0:	e037883a 	mov	sp,fp
8114a3a4:	df000017 	ldw	fp,0(sp)
8114a3a8:	dec00104 	addi	sp,sp,4
8114a3ac:	f800283a 	ret

8114a3b0 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114a3b0:	defff404 	addi	sp,sp,-48
8114a3b4:	de00012e 	bgeu	sp,et,8114a3bc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114a3b8:	003b68fa 	trap	3
8114a3bc:	df000b15 	stw	fp,44(sp)
8114a3c0:	df000b04 	addi	fp,sp,44
8114a3c4:	e13ff715 	stw	r4,-36(fp)
8114a3c8:	e17ff815 	stw	r5,-32(fp)
8114a3cc:	e1bff915 	stw	r6,-28(fp)
8114a3d0:	e1fffa15 	stw	r7,-24(fp)
8114a3d4:	e1800517 	ldw	r6,20(fp)
8114a3d8:	e1400617 	ldw	r5,24(fp)
8114a3dc:	e1000717 	ldw	r4,28(fp)
8114a3e0:	e0c00817 	ldw	r3,32(fp)
8114a3e4:	e0800917 	ldw	r2,36(fp)
8114a3e8:	e1bffb0d 	sth	r6,-20(fp)
8114a3ec:	e17ffc05 	stb	r5,-16(fp)
8114a3f0:	e13ffd05 	stb	r4,-12(fp)
8114a3f4:	e0fffe0d 	sth	r3,-8(fp)
8114a3f8:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114a3fc:	e0bff717 	ldw	r2,-36(fp)
8114a400:	10c01217 	ldw	r3,72(r2)
8114a404:	e0800317 	ldw	r2,12(fp)
8114a408:	18801936 	bltu	r3,r2,8114a470 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114a40c:	e13ff717 	ldw	r4,-36(fp)
8114a410:	20801317 	ldw	r2,76(r4)
8114a414:	20c01417 	ldw	r3,80(r4)
8114a418:	e13ffe0b 	ldhu	r4,-8(fp)
8114a41c:	213fffcc 	andi	r4,r4,65535
8114a420:	2015883a 	mov	r10,r4
8114a424:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114a428:	1ac01136 	bltu	r3,r11,8114a470 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114a42c:	58c0011e 	bne	r11,r3,8114a434 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
8114a430:	12800f36 	bltu	r2,r10,8114a470 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a434:	e13ff717 	ldw	r4,-36(fp)
8114a438:	20801317 	ldw	r2,76(r4)
8114a43c:	20c01417 	ldw	r3,80(r4)
8114a440:	e13fff0b 	ldhu	r4,-4(fp)
8114a444:	213fffcc 	andi	r4,r4,65535
8114a448:	2011883a 	mov	r8,r4
8114a44c:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8114a450:	1a400736 	bltu	r3,r9,8114a470 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114a454:	48c0011e 	bne	r9,r3,8114a45c <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114a458:	12000536 	bltu	r2,r8,8114a470 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114a45c:	e0bff717 	ldw	r2,-36(fp)
8114a460:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a464:	10803fcc 	andi	r2,r2,255
8114a468:	10800060 	cmpeqi	r2,r2,1
8114a46c:	1000021e 	bne	r2,zero,8114a478 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8114a470:	00bffa84 	movi	r2,-22
8114a474:	00003106 	br	8114a53c <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114a478:	e0bff817 	ldw	r2,-32(fp)
8114a47c:	e0fff917 	ldw	r3,-28(fp)
8114a480:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8114a484:	e0bff817 	ldw	r2,-32(fp)
8114a488:	e0fffa17 	ldw	r3,-24(fp)
8114a48c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8114a490:	e0bff817 	ldw	r2,-32(fp)
8114a494:	e0c00117 	ldw	r3,4(fp)
8114a498:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114a49c:	e0bff817 	ldw	r2,-32(fp)
8114a4a0:	e0c00217 	ldw	r3,8(fp)
8114a4a4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a4a8:	e0bff817 	ldw	r2,-32(fp)
8114a4ac:	e0c00317 	ldw	r3,12(fp)
8114a4b0:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114a4b4:	e0bff817 	ldw	r2,-32(fp)
8114a4b8:	e0fffb0b 	ldhu	r3,-20(fp)
8114a4bc:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8114a4c0:	e0bff817 	ldw	r2,-32(fp)
8114a4c4:	e0fffc03 	ldbu	r3,-16(fp)
8114a4c8:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114a4cc:	e0bff817 	ldw	r2,-32(fp)
8114a4d0:	e0fffd03 	ldbu	r3,-12(fp)
8114a4d4:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8114a4d8:	e0bff817 	ldw	r2,-32(fp)
8114a4dc:	e0fffe0b 	ldhu	r3,-8(fp)
8114a4e0:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8114a4e4:	e0bff817 	ldw	r2,-32(fp)
8114a4e8:	e0ffff0b 	ldhu	r3,-4(fp)
8114a4ec:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8114a4f0:	e0bff817 	ldw	r2,-32(fp)
8114a4f4:	1019883a 	mov	r12,r2
8114a4f8:	001b883a 	mov	r13,zero
8114a4fc:	e33ff515 	stw	r12,-44(fp)
8114a500:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8114a504:	e0fff517 	ldw	r3,-44(fp)
8114a508:	e0bff817 	ldw	r2,-32(fp)
8114a50c:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8114a510:	e0fff617 	ldw	r3,-40(fp)
8114a514:	e0bff817 	ldw	r2,-32(fp)
8114a518:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a51c:	e0c00417 	ldw	r3,16(fp)
8114a520:	00900034 	movhi	r2,16384
8114a524:	10bfffc4 	addi	r2,r2,-1
8114a528:	1884703a 	and	r2,r3,r2
8114a52c:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8114a530:	e0bff817 	ldw	r2,-32(fp)
8114a534:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8114a538:	0005883a 	mov	r2,zero
}
8114a53c:	e037883a 	mov	sp,fp
8114a540:	df000017 	ldw	fp,0(sp)
8114a544:	dec00104 	addi	sp,sp,4
8114a548:	f800283a 	ret

8114a54c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8114a54c:	defff804 	addi	sp,sp,-32
8114a550:	de00012e 	bgeu	sp,et,8114a558 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8114a554:	003b68fa 	trap	3
8114a558:	dfc00715 	stw	ra,28(sp)
8114a55c:	df000615 	stw	fp,24(sp)
8114a560:	df000604 	addi	fp,sp,24
8114a564:	e13ffc15 	stw	r4,-16(fp)
8114a568:	e17ffd15 	stw	r5,-12(fp)
8114a56c:	e1bffe15 	stw	r6,-8(fp)
8114a570:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114a574:	e0800317 	ldw	r2,12(fp)
8114a578:	d8800115 	stw	r2,4(sp)
8114a57c:	e0800217 	ldw	r2,8(fp)
8114a580:	d8800015 	stw	r2,0(sp)
8114a584:	e1ffff17 	ldw	r7,-4(fp)
8114a588:	e1bffe17 	ldw	r6,-8(fp)
8114a58c:	e17ffd17 	ldw	r5,-12(fp)
8114a590:	e13ffc17 	ldw	r4,-16(fp)
8114a594:	114a3040 	call	8114a304 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114a598:	e037883a 	mov	sp,fp
8114a59c:	dfc00117 	ldw	ra,4(sp)
8114a5a0:	df000017 	ldw	fp,0(sp)
8114a5a4:	dec00204 	addi	sp,sp,8
8114a5a8:	f800283a 	ret

8114a5ac <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a5ac:	defff804 	addi	sp,sp,-32
8114a5b0:	de00012e 	bgeu	sp,et,8114a5b8 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8114a5b4:	003b68fa 	trap	3
8114a5b8:	dfc00715 	stw	ra,28(sp)
8114a5bc:	df000615 	stw	fp,24(sp)
8114a5c0:	df000604 	addi	fp,sp,24
8114a5c4:	e13ffc15 	stw	r4,-16(fp)
8114a5c8:	e17ffd15 	stw	r5,-12(fp)
8114a5cc:	e1bffe15 	stw	r6,-8(fp)
8114a5d0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114a5d4:	e0800217 	ldw	r2,8(fp)
8114a5d8:	d8800115 	stw	r2,4(sp)
8114a5dc:	e0bfff17 	ldw	r2,-4(fp)
8114a5e0:	d8800015 	stw	r2,0(sp)
8114a5e4:	e1fffe17 	ldw	r7,-8(fp)
8114a5e8:	000d883a 	mov	r6,zero
8114a5ec:	e17ffd17 	ldw	r5,-12(fp)
8114a5f0:	e13ffc17 	ldw	r4,-16(fp)
8114a5f4:	114a3040 	call	8114a304 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8114a5f8:	e037883a 	mov	sp,fp
8114a5fc:	dfc00117 	ldw	ra,4(sp)
8114a600:	df000017 	ldw	fp,0(sp)
8114a604:	dec00204 	addi	sp,sp,8
8114a608:	f800283a 	ret

8114a60c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a60c:	defff804 	addi	sp,sp,-32
8114a610:	de00012e 	bgeu	sp,et,8114a618 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8114a614:	003b68fa 	trap	3
8114a618:	dfc00715 	stw	ra,28(sp)
8114a61c:	df000615 	stw	fp,24(sp)
8114a620:	df000604 	addi	fp,sp,24
8114a624:	e13ffc15 	stw	r4,-16(fp)
8114a628:	e17ffd15 	stw	r5,-12(fp)
8114a62c:	e1bffe15 	stw	r6,-8(fp)
8114a630:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114a634:	e0800217 	ldw	r2,8(fp)
8114a638:	d8800115 	stw	r2,4(sp)
8114a63c:	e0bfff17 	ldw	r2,-4(fp)
8114a640:	d8800015 	stw	r2,0(sp)
8114a644:	000f883a 	mov	r7,zero
8114a648:	e1bffe17 	ldw	r6,-8(fp)
8114a64c:	e17ffd17 	ldw	r5,-12(fp)
8114a650:	e13ffc17 	ldw	r4,-16(fp)
8114a654:	114a3040 	call	8114a304 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8114a658:	e037883a 	mov	sp,fp
8114a65c:	dfc00117 	ldw	ra,4(sp)
8114a660:	df000017 	ldw	fp,0(sp)
8114a664:	dec00204 	addi	sp,sp,8
8114a668:	f800283a 	ret

8114a66c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8114a66c:	deffee04 	addi	sp,sp,-72
8114a670:	de00012e 	bgeu	sp,et,8114a678 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8114a674:	003b68fa 	trap	3
8114a678:	dfc01115 	stw	ra,68(sp)
8114a67c:	df001015 	stw	fp,64(sp)
8114a680:	df001004 	addi	fp,sp,64
8114a684:	e13ff915 	stw	r4,-28(fp)
8114a688:	e17ffa15 	stw	r5,-24(fp)
8114a68c:	e1bffb15 	stw	r6,-20(fp)
8114a690:	e1fffc15 	stw	r7,-16(fp)
8114a694:	e1000417 	ldw	r4,16(fp)
8114a698:	e0c00517 	ldw	r3,20(fp)
8114a69c:	e0800617 	ldw	r2,24(fp)
8114a6a0:	e13ffd0d 	sth	r4,-12(fp)
8114a6a4:	e0fffe05 	stb	r3,-8(fp)
8114a6a8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114a6ac:	e0bffd0b 	ldhu	r2,-12(fp)
8114a6b0:	e0fffe03 	ldbu	r3,-8(fp)
8114a6b4:	e13fff0b 	ldhu	r4,-4(fp)
8114a6b8:	d9000815 	stw	r4,32(sp)
8114a6bc:	d8000715 	stw	zero,28(sp)
8114a6c0:	d8c00615 	stw	r3,24(sp)
8114a6c4:	d8000515 	stw	zero,20(sp)
8114a6c8:	d8800415 	stw	r2,16(sp)
8114a6cc:	e0800317 	ldw	r2,12(fp)
8114a6d0:	d8800315 	stw	r2,12(sp)
8114a6d4:	e0800217 	ldw	r2,8(fp)
8114a6d8:	d8800215 	stw	r2,8(sp)
8114a6dc:	e0bffc17 	ldw	r2,-16(fp)
8114a6e0:	d8800115 	stw	r2,4(sp)
8114a6e4:	e0bffb17 	ldw	r2,-20(fp)
8114a6e8:	d8800015 	stw	r2,0(sp)
8114a6ec:	000f883a 	mov	r7,zero
8114a6f0:	000d883a 	mov	r6,zero
8114a6f4:	e17ffa17 	ldw	r5,-24(fp)
8114a6f8:	e13ff917 	ldw	r4,-28(fp)
8114a6fc:	114a3b00 	call	8114a3b0 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8114a700:	e037883a 	mov	sp,fp
8114a704:	dfc00117 	ldw	ra,4(sp)
8114a708:	df000017 	ldw	fp,0(sp)
8114a70c:	dec00204 	addi	sp,sp,8
8114a710:	f800283a 	ret

8114a714 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114a714:	deffee04 	addi	sp,sp,-72
8114a718:	de00012e 	bgeu	sp,et,8114a720 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8114a71c:	003b68fa 	trap	3
8114a720:	dfc01115 	stw	ra,68(sp)
8114a724:	df001015 	stw	fp,64(sp)
8114a728:	df001004 	addi	fp,sp,64
8114a72c:	e13ff915 	stw	r4,-28(fp)
8114a730:	e17ffa15 	stw	r5,-24(fp)
8114a734:	e1bffb15 	stw	r6,-20(fp)
8114a738:	e1fffc15 	stw	r7,-16(fp)
8114a73c:	e1000417 	ldw	r4,16(fp)
8114a740:	e0c00517 	ldw	r3,20(fp)
8114a744:	e0800617 	ldw	r2,24(fp)
8114a748:	e13ffd0d 	sth	r4,-12(fp)
8114a74c:	e0fffe05 	stb	r3,-8(fp)
8114a750:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114a754:	e0bffd0b 	ldhu	r2,-12(fp)
8114a758:	e0fffe03 	ldbu	r3,-8(fp)
8114a75c:	e13fff0b 	ldhu	r4,-4(fp)
8114a760:	d8000815 	stw	zero,32(sp)
8114a764:	d9000715 	stw	r4,28(sp)
8114a768:	d8000615 	stw	zero,24(sp)
8114a76c:	d8c00515 	stw	r3,20(sp)
8114a770:	d8800415 	stw	r2,16(sp)
8114a774:	e0800317 	ldw	r2,12(fp)
8114a778:	d8800315 	stw	r2,12(sp)
8114a77c:	e0800217 	ldw	r2,8(fp)
8114a780:	d8800215 	stw	r2,8(sp)
8114a784:	d8000115 	stw	zero,4(sp)
8114a788:	d8000015 	stw	zero,0(sp)
8114a78c:	e1fffc17 	ldw	r7,-16(fp)
8114a790:	e1bffb17 	ldw	r6,-20(fp)
8114a794:	e17ffa17 	ldw	r5,-24(fp)
8114a798:	e13ff917 	ldw	r4,-28(fp)
8114a79c:	114a3b00 	call	8114a3b0 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8114a7a0:	e037883a 	mov	sp,fp
8114a7a4:	dfc00117 	ldw	ra,4(sp)
8114a7a8:	df000017 	ldw	fp,0(sp)
8114a7ac:	dec00204 	addi	sp,sp,8
8114a7b0:	f800283a 	ret

8114a7b4 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114a7b4:	deffec04 	addi	sp,sp,-80
8114a7b8:	de00012e 	bgeu	sp,et,8114a7c0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114a7bc:	003b68fa 	trap	3
8114a7c0:	dfc01315 	stw	ra,76(sp)
8114a7c4:	df001215 	stw	fp,72(sp)
8114a7c8:	df001204 	addi	fp,sp,72
8114a7cc:	e13ff715 	stw	r4,-36(fp)
8114a7d0:	e17ff815 	stw	r5,-32(fp)
8114a7d4:	e1bff915 	stw	r6,-28(fp)
8114a7d8:	e1fffa15 	stw	r7,-24(fp)
8114a7dc:	e1800617 	ldw	r6,24(fp)
8114a7e0:	e1400717 	ldw	r5,28(fp)
8114a7e4:	e1000817 	ldw	r4,32(fp)
8114a7e8:	e0c00917 	ldw	r3,36(fp)
8114a7ec:	e0800a17 	ldw	r2,40(fp)
8114a7f0:	e1bffb0d 	sth	r6,-20(fp)
8114a7f4:	e17ffc05 	stb	r5,-16(fp)
8114a7f8:	e13ffd05 	stb	r4,-12(fp)
8114a7fc:	e0fffe0d 	sth	r3,-8(fp)
8114a800:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114a804:	e0bffb0b 	ldhu	r2,-20(fp)
8114a808:	e0fffc03 	ldbu	r3,-16(fp)
8114a80c:	e13ffd03 	ldbu	r4,-12(fp)
8114a810:	e17ffe0b 	ldhu	r5,-8(fp)
8114a814:	e1bfff0b 	ldhu	r6,-4(fp)
8114a818:	d9800815 	stw	r6,32(sp)
8114a81c:	d9400715 	stw	r5,28(sp)
8114a820:	d9000615 	stw	r4,24(sp)
8114a824:	d8c00515 	stw	r3,20(sp)
8114a828:	d8800415 	stw	r2,16(sp)
8114a82c:	e0800517 	ldw	r2,20(fp)
8114a830:	d8800315 	stw	r2,12(sp)
8114a834:	e0800417 	ldw	r2,16(fp)
8114a838:	d8800215 	stw	r2,8(sp)
8114a83c:	e0800317 	ldw	r2,12(fp)
8114a840:	d8800115 	stw	r2,4(sp)
8114a844:	e0800217 	ldw	r2,8(fp)
8114a848:	d8800015 	stw	r2,0(sp)
8114a84c:	e1fffa17 	ldw	r7,-24(fp)
8114a850:	e1bff917 	ldw	r6,-28(fp)
8114a854:	e17ff817 	ldw	r5,-32(fp)
8114a858:	e13ff717 	ldw	r4,-36(fp)
8114a85c:	114a3b00 	call	8114a3b0 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8114a860:	e037883a 	mov	sp,fp
8114a864:	dfc00117 	ldw	ra,4(sp)
8114a868:	df000017 	ldw	fp,0(sp)
8114a86c:	dec00204 	addi	sp,sp,8
8114a870:	f800283a 	ret

8114a874 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8114a874:	defffc04 	addi	sp,sp,-16
8114a878:	de00012e 	bgeu	sp,et,8114a880 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114a87c:	003b68fa 	trap	3
8114a880:	df000315 	stw	fp,12(sp)
8114a884:	df000304 	addi	fp,sp,12
8114a888:	e13ffe15 	stw	r4,-8(fp)
8114a88c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8114a890:	e0bfff17 	ldw	r2,-4(fp)
8114a894:	1000021e 	bne	r2,zero,8114a8a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114a898:	00bffa84 	movi	r2,-22
8114a89c:	00002f06 	br	8114a95c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8114a8a0:	e0bfff17 	ldw	r2,-4(fp)
8114a8a4:	10c00317 	ldw	r3,12(r2)
8114a8a8:	e0bfff17 	ldw	r2,-4(fp)
8114a8ac:	18800226 	beq	r3,r2,8114a8b8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114a8b0:	00bffa84 	movi	r2,-22
8114a8b4:	00002906 	br	8114a95c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114a8b8:	e0bffe17 	ldw	r2,-8(fp)
8114a8bc:	10800017 	ldw	r2,0(r2)
8114a8c0:	1000051e 	bne	r2,zero,8114a8d8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8114a8c4:	e0bffe17 	ldw	r2,-8(fp)
8114a8c8:	e0ffff17 	ldw	r3,-4(fp)
8114a8cc:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8114a8d0:	0005883a 	mov	r2,zero
8114a8d4:	00002106 	br	8114a95c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8114a8d8:	e0bffe17 	ldw	r2,-8(fp)
8114a8dc:	10c00017 	ldw	r3,0(r2)
8114a8e0:	e0bfff17 	ldw	r2,-4(fp)
8114a8e4:	1880021e 	bne	r3,r2,8114a8f0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114a8e8:	00bffa84 	movi	r2,-22
8114a8ec:	00001b06 	br	8114a95c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114a8f0:	e0bffe17 	ldw	r2,-8(fp)
8114a8f4:	10800017 	ldw	r2,0(r2)
8114a8f8:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114a8fc:	00000906 	br	8114a924 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8114a900:	e0bffd17 	ldw	r2,-12(fp)
8114a904:	10c00317 	ldw	r3,12(r2)
8114a908:	e0bfff17 	ldw	r2,-4(fp)
8114a90c:	1880021e 	bne	r3,r2,8114a918 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114a910:	00bffa84 	movi	r2,-22
8114a914:	00001106 	br	8114a95c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114a918:	e0bffd17 	ldw	r2,-12(fp)
8114a91c:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8114a920:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114a924:	e0bffd17 	ldw	r2,-12(fp)
8114a928:	10800317 	ldw	r2,12(r2)
8114a92c:	e0fffe17 	ldw	r3,-8(fp)
8114a930:	18c00017 	ldw	r3,0(r3)
8114a934:	10fff21e 	bne	r2,r3,8114a900 <__reset+0xfb12a900>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114a938:	e0ffff17 	ldw	r3,-4(fp)
8114a93c:	e0bffd17 	ldw	r2,-12(fp)
8114a940:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8114a944:	e0bffe17 	ldw	r2,-8(fp)
8114a948:	10800017 	ldw	r2,0(r2)
8114a94c:	1007883a 	mov	r3,r2
8114a950:	e0bfff17 	ldw	r2,-4(fp)
8114a954:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114a958:	0005883a 	mov	r2,zero
}
8114a95c:	e037883a 	mov	sp,fp
8114a960:	df000017 	ldw	fp,0(sp)
8114a964:	dec00104 	addi	sp,sp,4
8114a968:	f800283a 	ret

8114a96c <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8114a96c:	defff804 	addi	sp,sp,-32
8114a970:	de00012e 	bgeu	sp,et,8114a978 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8114a974:	003b68fa 	trap	3
8114a978:	df000715 	stw	fp,28(sp)
8114a97c:	df000704 	addi	fp,sp,28
8114a980:	e13ffe15 	stw	r4,-8(fp)
8114a984:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8114a988:	e13fff17 	ldw	r4,-4(fp)
8114a98c:	2000021e 	bne	r4,zero,8114a998 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114a990:	00bffa84 	movi	r2,-22
8114a994:	00005906 	br	8114aafc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8114a998:	e13fff17 	ldw	r4,-4(fp)
8114a99c:	2015883a 	mov	r10,r4
8114a9a0:	0017883a 	mov	r11,zero
8114a9a4:	e2bffc15 	stw	r10,-16(fp)
8114a9a8:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114a9ac:	e13fff17 	ldw	r4,-4(fp)
8114a9b0:	21400317 	ldw	r5,12(r4)
8114a9b4:	e13ffc17 	ldw	r4,-16(fp)
8114a9b8:	29000626 	beq	r5,r4,8114a9d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114a9bc:	e13fff17 	ldw	r4,-4(fp)
8114a9c0:	21400b17 	ldw	r5,44(r4)
8114a9c4:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114a9c8:	29000226 	beq	r5,r4,8114a9d4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114a9cc:	00bffa84 	movi	r2,-22
8114a9d0:	00004a06 	br	8114aafc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8114a9d4:	e13ffe17 	ldw	r4,-8(fp)
8114a9d8:	21000017 	ldw	r4,0(r4)
8114a9dc:	2000051e 	bne	r4,zero,8114a9f4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8114a9e0:	e0bffe17 	ldw	r2,-8(fp)
8114a9e4:	e0ffff17 	ldw	r3,-4(fp)
8114a9e8:	10c00015 	stw	r3,0(r2)
		return 0;
8114a9ec:	0005883a 	mov	r2,zero
8114a9f0:	00004206 	br	8114aafc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8114a9f4:	e13ffe17 	ldw	r4,-8(fp)
8114a9f8:	21400017 	ldw	r5,0(r4)
8114a9fc:	e13fff17 	ldw	r4,-4(fp)
8114aa00:	2900021e 	bne	r5,r4,8114aa0c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114aa04:	00bffa84 	movi	r2,-22
8114aa08:	00003c06 	br	8114aafc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114aa0c:	e13ffe17 	ldw	r4,-8(fp)
8114aa10:	21000017 	ldw	r4,0(r4)
8114aa14:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8114aa18:	e13ffe17 	ldw	r4,-8(fp)
8114aa1c:	21000017 	ldw	r4,0(r4)
8114aa20:	2011883a 	mov	r8,r4
8114aa24:	0013883a 	mov	r9,zero
8114aa28:	e23ffa15 	stw	r8,-24(fp)
8114aa2c:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114aa30:	00001806 	br	8114aa94 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8114aa34:	e13fff17 	ldw	r4,-4(fp)
8114aa38:	200d883a 	mov	r6,r4
8114aa3c:	000f883a 	mov	r7,zero
8114aa40:	e1bffc15 	stw	r6,-16(fp)
8114aa44:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114aa48:	e13ff917 	ldw	r4,-28(fp)
8114aa4c:	21400317 	ldw	r5,12(r4)
8114aa50:	e13ffc17 	ldw	r4,-16(fp)
8114aa54:	2900061e 	bne	r5,r4,8114aa70 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114aa58:	e13ff917 	ldw	r4,-28(fp)
8114aa5c:	21400b17 	ldw	r5,44(r4)
8114aa60:	e13ffd17 	ldw	r4,-12(fp)
8114aa64:	2900021e 	bne	r5,r4,8114aa70 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114aa68:	00bffa84 	movi	r2,-22
8114aa6c:	00002306 	br	8114aafc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114aa70:	e13ff917 	ldw	r4,-28(fp)
8114aa74:	21000317 	ldw	r4,12(r4)
8114aa78:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114aa7c:	e13ff917 	ldw	r4,-28(fp)
8114aa80:	21000b17 	ldw	r4,44(r4)
8114aa84:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114aa88:	e13ffc17 	ldw	r4,-16(fp)
8114aa8c:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114aa90:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114aa94:	e13ff917 	ldw	r4,-28(fp)
8114aa98:	21400317 	ldw	r5,12(r4)
8114aa9c:	e13ffa17 	ldw	r4,-24(fp)
8114aaa0:	29000426 	beq	r5,r4,8114aab4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114aaa4:	e13ff917 	ldw	r4,-28(fp)
8114aaa8:	21400b17 	ldw	r5,44(r4)
8114aaac:	e13ffb17 	ldw	r4,-20(fp)
8114aab0:	293fe01e 	bne	r5,r4,8114aa34 <__reset+0xfb12aa34>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8114aab4:	e13fff17 	ldw	r4,-4(fp)
8114aab8:	2005883a 	mov	r2,r4
8114aabc:	0007883a 	mov	r3,zero
8114aac0:	e0bffc15 	stw	r2,-16(fp)
8114aac4:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8114aac8:	e0fffc17 	ldw	r3,-16(fp)
8114aacc:	e0bff917 	ldw	r2,-28(fp)
8114aad0:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8114aad4:	e0fffd17 	ldw	r3,-12(fp)
8114aad8:	e0bff917 	ldw	r2,-28(fp)
8114aadc:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8114aae0:	e0fffa17 	ldw	r3,-24(fp)
8114aae4:	e0bfff17 	ldw	r2,-4(fp)
8114aae8:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8114aaec:	e0fffb17 	ldw	r3,-20(fp)
8114aaf0:	e0bfff17 	ldw	r2,-4(fp)
8114aaf4:	10c00b15 	stw	r3,44(r2)
	return 0;
8114aaf8:	0005883a 	mov	r2,zero
}
8114aafc:	e037883a 	mov	sp,fp
8114ab00:	df000017 	ldw	fp,0(sp)
8114ab04:	dec00104 	addi	sp,sp,4
8114ab08:	f800283a 	ret

8114ab0c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8114ab0c:	defffc04 	addi	sp,sp,-16
8114ab10:	de00012e 	bgeu	sp,et,8114ab18 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8114ab14:	003b68fa 	trap	3
8114ab18:	df000315 	stw	fp,12(sp)
8114ab1c:	df000304 	addi	fp,sp,12
8114ab20:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114ab24:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114ab28:	e0bfff17 	ldw	r2,-4(fp)
8114ab2c:	1000021e 	bne	r2,zero,8114ab38 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114ab30:	00bffa84 	movi	r2,-22
8114ab34:	00001906 	br	8114ab9c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114ab38:	e0bfff17 	ldw	r2,-4(fp)
8114ab3c:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114ab40:	00000a06 	br	8114ab6c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8114ab44:	e0bffd17 	ldw	r2,-12(fp)
8114ab48:	10800717 	ldw	r2,28(r2)
8114ab4c:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114ab50:	e0bffe17 	ldw	r2,-8(fp)
8114ab54:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114ab58:	e0bffd17 	ldw	r2,-12(fp)
8114ab5c:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114ab60:	e0bffd17 	ldw	r2,-12(fp)
8114ab64:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8114ab68:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114ab6c:	e0bffd17 	ldw	r2,-12(fp)
8114ab70:	10c00317 	ldw	r3,12(r2)
8114ab74:	e0bfff17 	ldw	r2,-4(fp)
8114ab78:	18bff21e 	bne	r3,r2,8114ab44 <__reset+0xfb12ab44>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8114ab7c:	e0bffd17 	ldw	r2,-12(fp)
8114ab80:	10800717 	ldw	r2,28(r2)
8114ab84:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114ab88:	e0bffe17 	ldw	r2,-8(fp)
8114ab8c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114ab90:	e0bffd17 	ldw	r2,-12(fp)
8114ab94:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114ab98:	0005883a 	mov	r2,zero
}
8114ab9c:	e037883a 	mov	sp,fp
8114aba0:	df000017 	ldw	fp,0(sp)
8114aba4:	dec00104 	addi	sp,sp,4
8114aba8:	f800283a 	ret

8114abac <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8114abac:	defff804 	addi	sp,sp,-32
8114abb0:	de00012e 	bgeu	sp,et,8114abb8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8114abb4:	003b68fa 	trap	3
8114abb8:	df000715 	stw	fp,28(sp)
8114abbc:	df000704 	addi	fp,sp,28
8114abc0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114abc4:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114abc8:	e13fff17 	ldw	r4,-4(fp)
8114abcc:	2000021e 	bne	r4,zero,8114abd8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114abd0:	00bffa84 	movi	r2,-22
8114abd4:	00002806 	br	8114ac78 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114abd8:	e13fff17 	ldw	r4,-4(fp)
8114abdc:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8114abe0:	e13fff17 	ldw	r4,-4(fp)
8114abe4:	2005883a 	mov	r2,r4
8114abe8:	0007883a 	mov	r3,zero
8114abec:	e0bffb15 	stw	r2,-20(fp)
8114abf0:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114abf4:	00001006 	br	8114ac38 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114abf8:	e0bff917 	ldw	r2,-28(fp)
8114abfc:	10800f17 	ldw	r2,60(r2)
8114ac00:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114ac04:	e0bffa17 	ldw	r2,-24(fp)
8114ac08:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114ac0c:	e0bff917 	ldw	r2,-28(fp)
8114ac10:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114ac14:	e0bff917 	ldw	r2,-28(fp)
8114ac18:	10800317 	ldw	r2,12(r2)
8114ac1c:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114ac20:	e0bff917 	ldw	r2,-28(fp)
8114ac24:	10800b17 	ldw	r2,44(r2)
8114ac28:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114ac2c:	e0bffd17 	ldw	r2,-12(fp)
8114ac30:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114ac34:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114ac38:	e0bff917 	ldw	r2,-28(fp)
8114ac3c:	10c00317 	ldw	r3,12(r2)
8114ac40:	e0bffb17 	ldw	r2,-20(fp)
8114ac44:	18800426 	beq	r3,r2,8114ac58 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114ac48:	e0bff917 	ldw	r2,-28(fp)
8114ac4c:	10c00b17 	ldw	r3,44(r2)
8114ac50:	e0bffc17 	ldw	r2,-16(fp)
8114ac54:	18bfe81e 	bne	r3,r2,8114abf8 <__reset+0xfb12abf8>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114ac58:	e0bff917 	ldw	r2,-28(fp)
8114ac5c:	10800f17 	ldw	r2,60(r2)
8114ac60:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114ac64:	e0bffa17 	ldw	r2,-24(fp)
8114ac68:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114ac6c:	e0bff917 	ldw	r2,-28(fp)
8114ac70:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8114ac74:	0005883a 	mov	r2,zero
}
8114ac78:	e037883a 	mov	sp,fp
8114ac7c:	df000017 	ldw	fp,0(sp)
8114ac80:	dec00104 	addi	sp,sp,4
8114ac84:	f800283a 	ret

8114ac88 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114ac88:	deffeb04 	addi	sp,sp,-84
8114ac8c:	de00012e 	bgeu	sp,et,8114ac94 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8114ac90:	003b68fa 	trap	3
8114ac94:	dfc01415 	stw	ra,80(sp)
8114ac98:	df001315 	stw	fp,76(sp)
8114ac9c:	df001304 	addi	fp,sp,76
8114aca0:	e13ffb15 	stw	r4,-20(fp)
8114aca4:	e17ffc15 	stw	r5,-16(fp)
8114aca8:	e1bffd15 	stw	r6,-12(fp)
8114acac:	3807883a 	mov	r3,r7
8114acb0:	e0800217 	ldw	r2,8(fp)
8114acb4:	e0fffe05 	stb	r3,-8(fp)
8114acb8:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8114acbc:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8114acc0:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8114acc4:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114acc8:	e0bffc17 	ldw	r2,-16(fp)
8114accc:	e0bff815 	stw	r2,-32(fp)
8114acd0:	e0bffd17 	ldw	r2,-12(fp)
8114acd4:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114acd8:	e0bffb17 	ldw	r2,-20(fp)
8114acdc:	10801817 	ldw	r2,96(r2)
8114ace0:	e0bff615 	stw	r2,-40(fp)
8114ace4:	e03ff70d 	sth	zero,-36(fp)
8114ace8:	e0bff70b 	ldhu	r2,-36(fp)
8114acec:	e0fffa04 	addi	r3,fp,-24
8114acf0:	180d883a 	mov	r6,r3
8114acf4:	100b883a 	mov	r5,r2
8114acf8:	e13ff617 	ldw	r4,-40(fp)
8114acfc:	113fe340 	call	8113fe34 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8114ad00:	e0bffb17 	ldw	r2,-20(fp)
8114ad04:	10800617 	ldw	r2,24(r2)
8114ad08:	10800037 	ldwio	r2,0(r2)
8114ad0c:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8114ad10:	e0bfed17 	ldw	r2,-76(fp)
8114ad14:	1080004c 	andi	r2,r2,1
8114ad18:	10000626 	beq	r2,zero,8114ad34 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8114ad1c:	e0bffb17 	ldw	r2,-20(fp)
8114ad20:	10801817 	ldw	r2,96(r2)
8114ad24:	1009883a 	mov	r4,r2
8114ad28:	11401bc0 	call	811401bc <OSSemPost>
		return -EBUSY;
8114ad2c:	00bffc04 	movi	r2,-16
8114ad30:	00009606 	br	8114af8c <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114ad34:	00800804 	movi	r2,32
8114ad38:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ad3c:	0005303a 	rdctl	r2,status
8114ad40:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ad44:	e0fff217 	ldw	r3,-56(fp)
8114ad48:	00bfff84 	movi	r2,-2
8114ad4c:	1884703a 	and	r2,r3,r2
8114ad50:	1001703a 	wrctl	status,r2
  
  return context;
8114ad54:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114ad58:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114ad5c:	e0bffb17 	ldw	r2,-20(fp)
8114ad60:	10800317 	ldw	r2,12(r2)
8114ad64:	10800104 	addi	r2,r2,4
8114ad68:	e0ffee17 	ldw	r3,-72(fp)
8114ad6c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8114ad70:	e0bffb17 	ldw	r2,-20(fp)
8114ad74:	10800317 	ldw	r2,12(r2)
8114ad78:	e0fffb17 	ldw	r3,-20(fp)
8114ad7c:	18c00317 	ldw	r3,12(r3)
8114ad80:	18c00037 	ldwio	r3,0(r3)
8114ad84:	10c00035 	stwio	r3,0(r2)
8114ad88:	e0bfef17 	ldw	r2,-68(fp)
8114ad8c:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ad90:	e0bff017 	ldw	r2,-64(fp)
8114ad94:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8114ad98:	e0bffb17 	ldw	r2,-20(fp)
8114ad9c:	10800b17 	ldw	r2,44(r2)
8114ada0:	10002326 	beq	r2,zero,8114ae30 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8114ada4:	e0bffb17 	ldw	r2,-20(fp)
8114ada8:	10c00d17 	ldw	r3,52(r2)
8114adac:	e0bfee17 	ldw	r2,-72(fp)
8114adb0:	1884b03a 	or	r2,r3,r2
8114adb4:	10800514 	ori	r2,r2,20
8114adb8:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114adbc:	e0ffee17 	ldw	r3,-72(fp)
8114adc0:	00bff7c4 	movi	r2,-33
8114adc4:	1884703a 	and	r2,r3,r2
8114adc8:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114adcc:	e0bfed17 	ldw	r2,-76(fp)
8114add0:	10800214 	ori	r2,r2,8
8114add4:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114add8:	0005303a 	rdctl	r2,status
8114addc:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ade0:	e0fff417 	ldw	r3,-48(fp)
8114ade4:	00bfff84 	movi	r2,-2
8114ade8:	1884703a 	and	r2,r3,r2
8114adec:	1001703a 	wrctl	status,r2
  
  return context;
8114adf0:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8114adf4:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114adf8:	e0bffb17 	ldw	r2,-20(fp)
8114adfc:	10800317 	ldw	r2,12(r2)
8114ae00:	10800104 	addi	r2,r2,4
8114ae04:	e0ffee17 	ldw	r3,-72(fp)
8114ae08:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114ae0c:	e0bffb17 	ldw	r2,-20(fp)
8114ae10:	10800617 	ldw	r2,24(r2)
8114ae14:	e0ffed17 	ldw	r3,-76(fp)
8114ae18:	10c00035 	stwio	r3,0(r2)
8114ae1c:	e0bfef17 	ldw	r2,-68(fp)
8114ae20:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ae24:	e0bff117 	ldw	r2,-60(fp)
8114ae28:	1001703a 	wrctl	status,r2
8114ae2c:	00002306 	br	8114aebc <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8114ae30:	e0bffb17 	ldw	r2,-20(fp)
8114ae34:	10c00d17 	ldw	r3,52(r2)
8114ae38:	e0bfee17 	ldw	r2,-72(fp)
8114ae3c:	1884b03a 	or	r2,r3,r2
8114ae40:	10800114 	ori	r2,r2,4
8114ae44:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114ae48:	e0ffee17 	ldw	r3,-72(fp)
8114ae4c:	00bff3c4 	movi	r2,-49
8114ae50:	1884703a 	and	r2,r3,r2
8114ae54:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8114ae58:	e0ffed17 	ldw	r3,-76(fp)
8114ae5c:	00bffdc4 	movi	r2,-9
8114ae60:	1884703a 	and	r2,r3,r2
8114ae64:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ae68:	0005303a 	rdctl	r2,status
8114ae6c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ae70:	e0fff517 	ldw	r3,-44(fp)
8114ae74:	00bfff84 	movi	r2,-2
8114ae78:	1884703a 	and	r2,r3,r2
8114ae7c:	1001703a 	wrctl	status,r2
  
  return context;
8114ae80:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8114ae84:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114ae88:	e0bffb17 	ldw	r2,-20(fp)
8114ae8c:	10800317 	ldw	r2,12(r2)
8114ae90:	10800104 	addi	r2,r2,4
8114ae94:	e0ffee17 	ldw	r3,-72(fp)
8114ae98:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114ae9c:	e0bffb17 	ldw	r2,-20(fp)
8114aea0:	10800617 	ldw	r2,24(r2)
8114aea4:	e0ffed17 	ldw	r3,-76(fp)
8114aea8:	10c00035 	stwio	r3,0(r2)
8114aeac:	e0bfef17 	ldw	r2,-68(fp)
8114aeb0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114aeb4:	e0bff317 	ldw	r2,-52(fp)
8114aeb8:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8114aebc:	e0bffb17 	ldw	r2,-20(fp)
8114aec0:	10800617 	ldw	r2,24(r2)
8114aec4:	10800104 	addi	r2,r2,4
8114aec8:	e0fff817 	ldw	r3,-32(fp)
8114aecc:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8114aed0:	e0bffb17 	ldw	r2,-20(fp)
8114aed4:	10800617 	ldw	r2,24(r2)
8114aed8:	10800204 	addi	r2,r2,8
8114aedc:	e0fff917 	ldw	r3,-28(fp)
8114aee0:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8114aee4:	e0bffe03 	ldbu	r2,-8(fp)
8114aee8:	10000426 	beq	r2,zero,8114aefc <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8114aeec:	e0bfed17 	ldw	r2,-76(fp)
8114aef0:	10800414 	ori	r2,r2,16
8114aef4:	e0bfed15 	stw	r2,-76(fp)
8114aef8:	00000406 	br	8114af0c <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8114aefc:	e0ffed17 	ldw	r3,-76(fp)
8114af00:	00bffbc4 	movi	r2,-17
8114af04:	1884703a 	and	r2,r3,r2
8114af08:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8114af0c:	e0bfff03 	ldbu	r2,-4(fp)
8114af10:	10000e26 	beq	r2,zero,8114af4c <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8114af14:	e0bfed17 	ldw	r2,-76(fp)
8114af18:	10800094 	ori	r2,r2,2
8114af1c:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114af20:	e0bffb17 	ldw	r2,-20(fp)
8114af24:	10800617 	ldw	r2,24(r2)
8114af28:	10800304 	addi	r2,r2,12
8114af2c:	10800037 	ldwio	r2,0(r2)
8114af30:	10000a1e 	bne	r2,zero,8114af5c <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114af34:	e0bffb17 	ldw	r2,-20(fp)
8114af38:	10800617 	ldw	r2,24(r2)
8114af3c:	10800304 	addi	r2,r2,12
8114af40:	00c03fc4 	movi	r3,255
8114af44:	10c00035 	stwio	r3,0(r2)
8114af48:	00000406 	br	8114af5c <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8114af4c:	e0ffed17 	ldw	r3,-76(fp)
8114af50:	00bfff44 	movi	r2,-3
8114af54:	1884703a 	and	r2,r3,r2
8114af58:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8114af5c:	e0bfed17 	ldw	r2,-76(fp)
8114af60:	10800054 	ori	r2,r2,1
8114af64:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114af68:	e0bffb17 	ldw	r2,-20(fp)
8114af6c:	10800617 	ldw	r2,24(r2)
8114af70:	e0ffed17 	ldw	r3,-76(fp)
8114af74:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8114af78:	e0bffb17 	ldw	r2,-20(fp)
8114af7c:	10801817 	ldw	r2,96(r2)
8114af80:	1009883a 	mov	r4,r2
8114af84:	11401bc0 	call	811401bc <OSSemPost>
	 
	 return 0;
8114af88:	0005883a 	mov	r2,zero
}
8114af8c:	e037883a 	mov	sp,fp
8114af90:	dfc00117 	ldw	ra,4(sp)
8114af94:	df000017 	ldw	fp,0(sp)
8114af98:	dec00204 	addi	sp,sp,8
8114af9c:	f800283a 	ret

8114afa0 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8114afa0:	defff704 	addi	sp,sp,-36
8114afa4:	de00012e 	bgeu	sp,et,8114afac <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8114afa8:	003b68fa 	trap	3
8114afac:	dfc00815 	stw	ra,32(sp)
8114afb0:	df000715 	stw	fp,28(sp)
8114afb4:	dc400615 	stw	r17,24(sp)
8114afb8:	dc000515 	stw	r16,20(sp)
8114afbc:	df000704 	addi	fp,sp,28
8114afc0:	e13ffa15 	stw	r4,-24(fp)
8114afc4:	e17ffb15 	stw	r5,-20(fp)
8114afc8:	3007883a 	mov	r3,r6
8114afcc:	3805883a 	mov	r2,r7
8114afd0:	e0fffc05 	stb	r3,-16(fp)
8114afd4:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114afd8:	e13ffb17 	ldw	r4,-20(fp)
8114afdc:	114ab0c0 	call	8114ab0c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8114afe0:	10000226 	beq	r2,zero,8114afec <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8114afe4:	00bffa84 	movi	r2,-22
8114afe8:	00000b06 	br	8114b018 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8114afec:	e0bffb17 	ldw	r2,-20(fp)
8114aff0:	1021883a 	mov	r16,r2
8114aff4:	0023883a 	mov	r17,zero
8114aff8:	e0fffc03 	ldbu	r3,-16(fp)
8114affc:	e0bffd03 	ldbu	r2,-12(fp)
8114b000:	d8800015 	stw	r2,0(sp)
8114b004:	180f883a 	mov	r7,r3
8114b008:	800b883a 	mov	r5,r16
8114b00c:	880d883a 	mov	r6,r17
8114b010:	e13ffa17 	ldw	r4,-24(fp)
8114b014:	114ac880 	call	8114ac88 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114b018:	e6fffe04 	addi	sp,fp,-8
8114b01c:	dfc00317 	ldw	ra,12(sp)
8114b020:	df000217 	ldw	fp,8(sp)
8114b024:	dc400117 	ldw	r17,4(sp)
8114b028:	dc000017 	ldw	r16,0(sp)
8114b02c:	dec00404 	addi	sp,sp,16
8114b030:	f800283a 	ret

8114b034 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114b034:	defff704 	addi	sp,sp,-36
8114b038:	de00012e 	bgeu	sp,et,8114b040 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8114b03c:	003b68fa 	trap	3
8114b040:	dfc00815 	stw	ra,32(sp)
8114b044:	df000715 	stw	fp,28(sp)
8114b048:	dc400615 	stw	r17,24(sp)
8114b04c:	dc000515 	stw	r16,20(sp)
8114b050:	df000704 	addi	fp,sp,28
8114b054:	e13ffa15 	stw	r4,-24(fp)
8114b058:	e17ffb15 	stw	r5,-20(fp)
8114b05c:	3007883a 	mov	r3,r6
8114b060:	3805883a 	mov	r2,r7
8114b064:	e0fffc05 	stb	r3,-16(fp)
8114b068:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8114b06c:	e13ffb17 	ldw	r4,-20(fp)
8114b070:	114abac0 	call	8114abac <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8114b074:	10000226 	beq	r2,zero,8114b080 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8114b078:	00bffa84 	movi	r2,-22
8114b07c:	00000b06 	br	8114b0ac <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8114b080:	e0bffb17 	ldw	r2,-20(fp)
8114b084:	1021883a 	mov	r16,r2
8114b088:	0023883a 	mov	r17,zero
8114b08c:	e0fffc03 	ldbu	r3,-16(fp)
8114b090:	e0bffd03 	ldbu	r2,-12(fp)
8114b094:	d8800015 	stw	r2,0(sp)
8114b098:	180f883a 	mov	r7,r3
8114b09c:	800b883a 	mov	r5,r16
8114b0a0:	880d883a 	mov	r6,r17
8114b0a4:	e13ffa17 	ldw	r4,-24(fp)
8114b0a8:	114ac880 	call	8114ac88 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114b0ac:	e6fffe04 	addi	sp,fp,-8
8114b0b0:	dfc00317 	ldw	ra,12(sp)
8114b0b4:	df000217 	ldw	fp,8(sp)
8114b0b8:	dc400117 	ldw	r17,4(sp)
8114b0bc:	dc000017 	ldw	r16,0(sp)
8114b0c0:	dec00404 	addi	sp,sp,16
8114b0c4:	f800283a 	ret

8114b0c8 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114b0c8:	defffc04 	addi	sp,sp,-16
8114b0cc:	de00012e 	bgeu	sp,et,8114b0d4 <alt_msgdma_open+0xc>
8114b0d0:	003b68fa 	trap	3
8114b0d4:	dfc00315 	stw	ra,12(sp)
8114b0d8:	df000215 	stw	fp,8(sp)
8114b0dc:	df000204 	addi	fp,sp,8
8114b0e0:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8114b0e4:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8114b0e8:	d1603504 	addi	r5,gp,-32556
8114b0ec:	e13fff17 	ldw	r4,-4(fp)
8114b0f0:	114b66c0 	call	8114b66c <alt_find_dev>
8114b0f4:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8114b0f8:	e0bffe17 	ldw	r2,-8(fp)
8114b0fc:	1000041e 	bne	r2,zero,8114b110 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8114b100:	114932c0 	call	8114932c <alt_get_errno>
8114b104:	1007883a 	mov	r3,r2
8114b108:	008004c4 	movi	r2,19
8114b10c:	18800015 	stw	r2,0(r3)
    }

    return dev;
8114b110:	e0bffe17 	ldw	r2,-8(fp)
}
8114b114:	e037883a 	mov	sp,fp
8114b118:	dfc00117 	ldw	ra,4(sp)
8114b11c:	df000017 	ldw	fp,0(sp)
8114b120:	dec00204 	addi	sp,sp,8
8114b124:	f800283a 	ret

8114b128 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8114b128:	defff604 	addi	sp,sp,-40
8114b12c:	de00012e 	bgeu	sp,et,8114b134 <alt_msgdma_init+0xc>
8114b130:	003b68fa 	trap	3
8114b134:	dfc00915 	stw	ra,36(sp)
8114b138:	df000815 	stw	fp,32(sp)
8114b13c:	df000804 	addi	fp,sp,32
8114b140:	e13ffd15 	stw	r4,-12(fp)
8114b144:	e17ffe15 	stw	r5,-8(fp)
8114b148:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8114b14c:	e0bffd17 	ldw	r2,-12(fp)
8114b150:	10801783 	ldbu	r2,94(r2)
8114b154:	10803fcc 	andi	r2,r2,255
8114b158:	10000b26 	beq	r2,zero,8114b188 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8114b15c:	e0bffd17 	ldw	r2,-12(fp)
8114b160:	10800617 	ldw	r2,24(r2)
8114b164:	00c00104 	movi	r3,4
8114b168:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8114b16c:	0001883a 	nop
8114b170:	e0bffd17 	ldw	r2,-12(fp)
8114b174:	10800617 	ldw	r2,24(r2)
8114b178:	10800037 	ldwio	r2,0(r2)
8114b17c:	1080010c 	andi	r2,r2,4
8114b180:	1005d0ba 	srai	r2,r2,2
8114b184:	103ffa1e 	bne	r2,zero,8114b170 <__reset+0xfb12b170>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8114b188:	e0bffd17 	ldw	r2,-12(fp)
8114b18c:	10800317 	ldw	r2,12(r2)
8114b190:	10800104 	addi	r2,r2,4
8114b194:	00c00084 	movi	r3,2
8114b198:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114b19c:	0001883a 	nop
8114b1a0:	e0bffd17 	ldw	r2,-12(fp)
8114b1a4:	10800317 	ldw	r2,12(r2)
8114b1a8:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8114b1ac:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114b1b0:	103ffb1e 	bne	r2,zero,8114b1a0 <__reset+0xfb12b1a0>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114b1b4:	e0bffd17 	ldw	r2,-12(fp)
8114b1b8:	10800317 	ldw	r2,12(r2)
8114b1bc:	10800104 	addi	r2,r2,4
8114b1c0:	10800037 	ldwio	r2,0(r2)
8114b1c4:	1007883a 	mov	r3,r2
8114b1c8:	00bffbc4 	movi	r2,-17
8114b1cc:	1884703a 	and	r2,r3,r2
8114b1d0:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114b1d4:	e0bff917 	ldw	r2,-28(fp)
8114b1d8:	10800814 	ori	r2,r2,32
8114b1dc:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114b1e0:	e0bffd17 	ldw	r2,-12(fp)
8114b1e4:	10800317 	ldw	r2,12(r2)
8114b1e8:	10800104 	addi	r2,r2,4
8114b1ec:	e0fff917 	ldw	r3,-28(fp)
8114b1f0:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8114b1f4:	e0bffd17 	ldw	r2,-12(fp)
8114b1f8:	10800317 	ldw	r2,12(r2)
8114b1fc:	e0fffd17 	ldw	r3,-12(fp)
8114b200:	18c00317 	ldw	r3,12(r3)
8114b204:	18c00037 	ldwio	r3,0(r3)
8114b208:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8114b20c:	e0bffd17 	ldw	r2,-12(fp)
8114b210:	10801783 	ldbu	r2,94(r2)
8114b214:	10803fcc 	andi	r2,r2,255
8114b218:	10000826 	beq	r2,zero,8114b23c <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8114b21c:	e0bffd17 	ldw	r2,-12(fp)
8114b220:	10800617 	ldw	r2,24(r2)
8114b224:	10800404 	addi	r2,r2,16
8114b228:	e0fffd17 	ldw	r3,-12(fp)
8114b22c:	18c00617 	ldw	r3,24(r3)
8114b230:	18c00404 	addi	r3,r3,16
8114b234:	18c00037 	ldwio	r3,0(r3)
8114b238:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8114b23c:	d1603504 	addi	r5,gp,-32556
8114b240:	e13ffd17 	ldw	r4,-12(fp)
8114b244:	114b5c00 	call	8114b5c0 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8114b248:	e0bffd17 	ldw	r2,-12(fp)
8114b24c:	10801804 	addi	r2,r2,96
8114b250:	e0bffb15 	stw	r2,-20(fp)
8114b254:	00800044 	movi	r2,1
8114b258:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8114b25c:	e0bffc0b 	ldhu	r2,-16(fp)
8114b260:	1009883a 	mov	r4,r2
8114b264:	113fb0c0 	call	8113fb0c <OSSemCreate>
8114b268:	1007883a 	mov	r3,r2
8114b26c:	e0bffb17 	ldw	r2,-20(fp)
8114b270:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114b274:	e0bffb17 	ldw	r2,-20(fp)
8114b278:	10800017 	ldw	r2,0(r2)
8114b27c:	10000226 	beq	r2,zero,8114b288 <alt_msgdma_init+0x160>
8114b280:	0005883a 	mov	r2,zero
8114b284:	00000106 	br	8114b28c <alt_msgdma_init+0x164>
8114b288:	00bfffc4 	movi	r2,-1
8114b28c:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8114b290:	e0bffa17 	ldw	r2,-24(fp)
8114b294:	1000081e 	bne	r2,zero,8114b2b8 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8114b298:	d8000015 	stw	zero,0(sp)
8114b29c:	e1fffd17 	ldw	r7,-12(fp)
8114b2a0:	01a04574 	movhi	r6,33045
8114b2a4:	31a55004 	addi	r6,r6,-27328
8114b2a8:	e17fff17 	ldw	r5,-4(fp)
8114b2ac:	e13ffe17 	ldw	r4,-8(fp)
8114b2b0:	114b8f80 	call	8114b8f8 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8114b2b4:	00000406 	br	8114b2c8 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8114b2b8:	01204574 	movhi	r4,33045
8114b2bc:	21098c04 	addi	r4,r4,9776
8114b2c0:	114bd100 	call	8114bd10 <alt_printf>
    }
    
    return;
8114b2c4:	0001883a 	nop

}
8114b2c8:	e037883a 	mov	sp,fp
8114b2cc:	dfc00117 	ldw	ra,4(sp)
8114b2d0:	df000017 	ldw	fp,0(sp)
8114b2d4:	dec00204 	addi	sp,sp,8
8114b2d8:	f800283a 	ret

8114b2dc <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8114b2dc:	defffb04 	addi	sp,sp,-20
8114b2e0:	de00012e 	bgeu	sp,et,8114b2e8 <alt_msgdma_register_callback+0xc>
8114b2e4:	003b68fa 	trap	3
8114b2e8:	df000415 	stw	fp,16(sp)
8114b2ec:	df000404 	addi	fp,sp,16
8114b2f0:	e13ffc15 	stw	r4,-16(fp)
8114b2f4:	e17ffd15 	stw	r5,-12(fp)
8114b2f8:	e1bffe15 	stw	r6,-8(fp)
8114b2fc:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8114b300:	e0bffc17 	ldw	r2,-16(fp)
8114b304:	e0fffd17 	ldw	r3,-12(fp)
8114b308:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8114b30c:	e0bffc17 	ldw	r2,-16(fp)
8114b310:	e0ffff17 	ldw	r3,-4(fp)
8114b314:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8114b318:	e0bffc17 	ldw	r2,-16(fp)
8114b31c:	e0fffe17 	ldw	r3,-8(fp)
8114b320:	10c00d15 	stw	r3,52(r2)

    return ;
8114b324:	0001883a 	nop
}
8114b328:	e037883a 	mov	sp,fp
8114b32c:	df000017 	ldw	fp,0(sp)
8114b330:	dec00104 	addi	sp,sp,4
8114b334:	f800283a 	ret

8114b338 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114b338:	defffc04 	addi	sp,sp,-16
8114b33c:	de00012e 	bgeu	sp,et,8114b344 <alt_msgdma_standard_descriptor_async_transfer+0xc>
8114b340:	003b68fa 	trap	3
8114b344:	dfc00315 	stw	ra,12(sp)
8114b348:	df000215 	stw	fp,8(sp)
8114b34c:	df000204 	addi	fp,sp,8
8114b350:	e13ffe15 	stw	r4,-8(fp)
8114b354:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114b358:	000d883a 	mov	r6,zero
8114b35c:	e17fff17 	ldw	r5,-4(fp)
8114b360:	e13ffe17 	ldw	r4,-8(fp)
8114b364:	11498bc0 	call	811498bc <alt_msgdma_descriptor_async_transfer>

}
8114b368:	e037883a 	mov	sp,fp
8114b36c:	dfc00117 	ldw	ra,4(sp)
8114b370:	df000017 	ldw	fp,0(sp)
8114b374:	dec00204 	addi	sp,sp,8
8114b378:	f800283a 	ret

8114b37c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114b37c:	defffc04 	addi	sp,sp,-16
8114b380:	de00012e 	bgeu	sp,et,8114b388 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8114b384:	003b68fa 	trap	3
8114b388:	dfc00315 	stw	ra,12(sp)
8114b38c:	df000215 	stw	fp,8(sp)
8114b390:	df000204 	addi	fp,sp,8
8114b394:	e13ffe15 	stw	r4,-8(fp)
8114b398:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114b39c:	e1bfff17 	ldw	r6,-4(fp)
8114b3a0:	000b883a 	mov	r5,zero
8114b3a4:	e13ffe17 	ldw	r4,-8(fp)
8114b3a8:	11498bc0 	call	811498bc <alt_msgdma_descriptor_async_transfer>
}
8114b3ac:	e037883a 	mov	sp,fp
8114b3b0:	dfc00117 	ldw	ra,4(sp)
8114b3b4:	df000017 	ldw	fp,0(sp)
8114b3b8:	dec00204 	addi	sp,sp,8
8114b3bc:	f800283a 	ret

8114b3c0 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114b3c0:	defffc04 	addi	sp,sp,-16
8114b3c4:	de00012e 	bgeu	sp,et,8114b3cc <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114b3c8:	003b68fa 	trap	3
8114b3cc:	dfc00315 	stw	ra,12(sp)
8114b3d0:	df000215 	stw	fp,8(sp)
8114b3d4:	df000204 	addi	fp,sp,8
8114b3d8:	e13ffe15 	stw	r4,-8(fp)
8114b3dc:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8114b3e0:	000d883a 	mov	r6,zero
8114b3e4:	e17fff17 	ldw	r5,-4(fp)
8114b3e8:	e13ffe17 	ldw	r4,-8(fp)
8114b3ec:	1149bfc0 	call	81149bfc <alt_msgdma_descriptor_sync_transfer>
}
8114b3f0:	e037883a 	mov	sp,fp
8114b3f4:	dfc00117 	ldw	ra,4(sp)
8114b3f8:	df000017 	ldw	fp,0(sp)
8114b3fc:	dec00204 	addi	sp,sp,8
8114b400:	f800283a 	ret

8114b404 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114b404:	defffc04 	addi	sp,sp,-16
8114b408:	de00012e 	bgeu	sp,et,8114b410 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8114b40c:	003b68fa 	trap	3
8114b410:	dfc00315 	stw	ra,12(sp)
8114b414:	df000215 	stw	fp,8(sp)
8114b418:	df000204 	addi	fp,sp,8
8114b41c:	e13ffe15 	stw	r4,-8(fp)
8114b420:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8114b424:	e1bfff17 	ldw	r6,-4(fp)
8114b428:	000b883a 	mov	r5,zero
8114b42c:	e13ffe17 	ldw	r4,-8(fp)
8114b430:	1149bfc0 	call	81149bfc <alt_msgdma_descriptor_sync_transfer>
}
8114b434:	e037883a 	mov	sp,fp
8114b438:	dfc00117 	ldw	ra,4(sp)
8114b43c:	df000017 	ldw	fp,0(sp)
8114b440:	dec00204 	addi	sp,sp,8
8114b444:	f800283a 	ret

8114b448 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114b448:	defff504 	addi	sp,sp,-44
8114b44c:	de00012e 	bgeu	sp,et,8114b454 <alt_alarm_start+0xc>
8114b450:	003b68fa 	trap	3
8114b454:	df000a15 	stw	fp,40(sp)
8114b458:	df000a04 	addi	fp,sp,40
8114b45c:	e13ffc15 	stw	r4,-16(fp)
8114b460:	e17ffd15 	stw	r5,-12(fp)
8114b464:	e1bffe15 	stw	r6,-8(fp)
8114b468:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114b46c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8114b470:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
8114b474:	10003c26 	beq	r2,zero,8114b568 <alt_alarm_start+0x120>
  {
    if (alarm)
8114b478:	e0bffc17 	ldw	r2,-16(fp)
8114b47c:	10003826 	beq	r2,zero,8114b560 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8114b480:	e0bffc17 	ldw	r2,-16(fp)
8114b484:	e0fffe17 	ldw	r3,-8(fp)
8114b488:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114b48c:	e0bffc17 	ldw	r2,-16(fp)
8114b490:	e0ffff17 	ldw	r3,-4(fp)
8114b494:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b498:	0005303a 	rdctl	r2,status
8114b49c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b4a0:	e0fff917 	ldw	r3,-28(fp)
8114b4a4:	00bfff84 	movi	r2,-2
8114b4a8:	1884703a 	and	r2,r3,r2
8114b4ac:	1001703a 	wrctl	status,r2
  
  return context;
8114b4b0:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8114b4b4:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114b4b8:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
8114b4bc:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8114b4c0:	e0fffd17 	ldw	r3,-12(fp)
8114b4c4:	e0bff617 	ldw	r2,-40(fp)
8114b4c8:	1885883a 	add	r2,r3,r2
8114b4cc:	10c00044 	addi	r3,r2,1
8114b4d0:	e0bffc17 	ldw	r2,-16(fp)
8114b4d4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114b4d8:	e0bffc17 	ldw	r2,-16(fp)
8114b4dc:	10c00217 	ldw	r3,8(r2)
8114b4e0:	e0bff617 	ldw	r2,-40(fp)
8114b4e4:	1880042e 	bgeu	r3,r2,8114b4f8 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8114b4e8:	e0bffc17 	ldw	r2,-16(fp)
8114b4ec:	00c00044 	movi	r3,1
8114b4f0:	10c00405 	stb	r3,16(r2)
8114b4f4:	00000206 	br	8114b500 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8114b4f8:	e0bffc17 	ldw	r2,-16(fp)
8114b4fc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8114b500:	e0bffc17 	ldw	r2,-16(fp)
8114b504:	d0e01404 	addi	r3,gp,-32688
8114b508:	e0fffa15 	stw	r3,-24(fp)
8114b50c:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114b510:	e0bffb17 	ldw	r2,-20(fp)
8114b514:	e0fffa17 	ldw	r3,-24(fp)
8114b518:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114b51c:	e0bffa17 	ldw	r2,-24(fp)
8114b520:	10c00017 	ldw	r3,0(r2)
8114b524:	e0bffb17 	ldw	r2,-20(fp)
8114b528:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114b52c:	e0bffa17 	ldw	r2,-24(fp)
8114b530:	10800017 	ldw	r2,0(r2)
8114b534:	e0fffb17 	ldw	r3,-20(fp)
8114b538:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114b53c:	e0bffa17 	ldw	r2,-24(fp)
8114b540:	e0fffb17 	ldw	r3,-20(fp)
8114b544:	10c00015 	stw	r3,0(r2)
8114b548:	e0bff817 	ldw	r2,-32(fp)
8114b54c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b550:	e0bff717 	ldw	r2,-36(fp)
8114b554:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114b558:	0005883a 	mov	r2,zero
8114b55c:	00000306 	br	8114b56c <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8114b560:	00bffa84 	movi	r2,-22
8114b564:	00000106 	br	8114b56c <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114b568:	00bfde84 	movi	r2,-134
  }
}
8114b56c:	e037883a 	mov	sp,fp
8114b570:	df000017 	ldw	fp,0(sp)
8114b574:	dec00104 	addi	sp,sp,4
8114b578:	f800283a 	ret

8114b57c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114b57c:	defffe04 	addi	sp,sp,-8
8114b580:	de00012e 	bgeu	sp,et,8114b588 <alt_get_errno+0xc>
8114b584:	003b68fa 	trap	3
8114b588:	dfc00115 	stw	ra,4(sp)
8114b58c:	df000015 	stw	fp,0(sp)
8114b590:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114b594:	d0a01017 	ldw	r2,-32704(gp)
8114b598:	10000326 	beq	r2,zero,8114b5a8 <alt_get_errno+0x2c>
8114b59c:	d0a01017 	ldw	r2,-32704(gp)
8114b5a0:	103ee83a 	callr	r2
8114b5a4:	00000106 	br	8114b5ac <alt_get_errno+0x30>
8114b5a8:	d0a07804 	addi	r2,gp,-32288
}
8114b5ac:	e037883a 	mov	sp,fp
8114b5b0:	dfc00117 	ldw	ra,4(sp)
8114b5b4:	df000017 	ldw	fp,0(sp)
8114b5b8:	dec00204 	addi	sp,sp,8
8114b5bc:	f800283a 	ret

8114b5c0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8114b5c0:	defffa04 	addi	sp,sp,-24
8114b5c4:	de00012e 	bgeu	sp,et,8114b5cc <alt_dev_llist_insert+0xc>
8114b5c8:	003b68fa 	trap	3
8114b5cc:	dfc00515 	stw	ra,20(sp)
8114b5d0:	df000415 	stw	fp,16(sp)
8114b5d4:	df000404 	addi	fp,sp,16
8114b5d8:	e13ffe15 	stw	r4,-8(fp)
8114b5dc:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8114b5e0:	e0bffe17 	ldw	r2,-8(fp)
8114b5e4:	10000326 	beq	r2,zero,8114b5f4 <alt_dev_llist_insert+0x34>
8114b5e8:	e0bffe17 	ldw	r2,-8(fp)
8114b5ec:	10800217 	ldw	r2,8(r2)
8114b5f0:	1000061e 	bne	r2,zero,8114b60c <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8114b5f4:	114b57c0 	call	8114b57c <alt_get_errno>
8114b5f8:	1007883a 	mov	r3,r2
8114b5fc:	00800584 	movi	r2,22
8114b600:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8114b604:	00bffa84 	movi	r2,-22
8114b608:	00001306 	br	8114b658 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114b60c:	e0bffe17 	ldw	r2,-8(fp)
8114b610:	e0ffff17 	ldw	r3,-4(fp)
8114b614:	e0fffc15 	stw	r3,-16(fp)
8114b618:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114b61c:	e0bffd17 	ldw	r2,-12(fp)
8114b620:	e0fffc17 	ldw	r3,-16(fp)
8114b624:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114b628:	e0bffc17 	ldw	r2,-16(fp)
8114b62c:	10c00017 	ldw	r3,0(r2)
8114b630:	e0bffd17 	ldw	r2,-12(fp)
8114b634:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114b638:	e0bffc17 	ldw	r2,-16(fp)
8114b63c:	10800017 	ldw	r2,0(r2)
8114b640:	e0fffd17 	ldw	r3,-12(fp)
8114b644:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114b648:	e0bffc17 	ldw	r2,-16(fp)
8114b64c:	e0fffd17 	ldw	r3,-12(fp)
8114b650:	10c00015 	stw	r3,0(r2)

  return 0;  
8114b654:	0005883a 	mov	r2,zero
}
8114b658:	e037883a 	mov	sp,fp
8114b65c:	dfc00117 	ldw	ra,4(sp)
8114b660:	df000017 	ldw	fp,0(sp)
8114b664:	dec00204 	addi	sp,sp,8
8114b668:	f800283a 	ret

8114b66c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114b66c:	defffa04 	addi	sp,sp,-24
8114b670:	de00012e 	bgeu	sp,et,8114b678 <alt_find_dev+0xc>
8114b674:	003b68fa 	trap	3
8114b678:	dfc00515 	stw	ra,20(sp)
8114b67c:	df000415 	stw	fp,16(sp)
8114b680:	df000404 	addi	fp,sp,16
8114b684:	e13ffe15 	stw	r4,-8(fp)
8114b688:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114b68c:	e0bfff17 	ldw	r2,-4(fp)
8114b690:	10800017 	ldw	r2,0(r2)
8114b694:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114b698:	e13ffe17 	ldw	r4,-8(fp)
8114b69c:	11244bc0 	call	811244bc <strlen>
8114b6a0:	10800044 	addi	r2,r2,1
8114b6a4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114b6a8:	00000d06 	br	8114b6e0 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114b6ac:	e0bffc17 	ldw	r2,-16(fp)
8114b6b0:	10800217 	ldw	r2,8(r2)
8114b6b4:	e0fffd17 	ldw	r3,-12(fp)
8114b6b8:	180d883a 	mov	r6,r3
8114b6bc:	e17ffe17 	ldw	r5,-8(fp)
8114b6c0:	1009883a 	mov	r4,r2
8114b6c4:	114c4800 	call	8114c480 <memcmp>
8114b6c8:	1000021e 	bne	r2,zero,8114b6d4 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114b6cc:	e0bffc17 	ldw	r2,-16(fp)
8114b6d0:	00000706 	br	8114b6f0 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8114b6d4:	e0bffc17 	ldw	r2,-16(fp)
8114b6d8:	10800017 	ldw	r2,0(r2)
8114b6dc:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114b6e0:	e0fffc17 	ldw	r3,-16(fp)
8114b6e4:	e0bfff17 	ldw	r2,-4(fp)
8114b6e8:	18bff01e 	bne	r3,r2,8114b6ac <__reset+0xfb12b6ac>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114b6ec:	0005883a 	mov	r2,zero
}
8114b6f0:	e037883a 	mov	sp,fp
8114b6f4:	dfc00117 	ldw	ra,4(sp)
8114b6f8:	df000017 	ldw	fp,0(sp)
8114b6fc:	dec00204 	addi	sp,sp,8
8114b700:	f800283a 	ret

8114b704 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8114b704:	defffb04 	addi	sp,sp,-20
8114b708:	de00012e 	bgeu	sp,et,8114b710 <alt_find_file+0xc>
8114b70c:	003b68fa 	trap	3
8114b710:	dfc00415 	stw	ra,16(sp)
8114b714:	df000315 	stw	fp,12(sp)
8114b718:	df000304 	addi	fp,sp,12
8114b71c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8114b720:	d0a00b17 	ldw	r2,-32724(gp)
8114b724:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114b728:	00003106 	br	8114b7f0 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114b72c:	e0bffd17 	ldw	r2,-12(fp)
8114b730:	10800217 	ldw	r2,8(r2)
8114b734:	1009883a 	mov	r4,r2
8114b738:	11244bc0 	call	811244bc <strlen>
8114b73c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8114b740:	e0bffd17 	ldw	r2,-12(fp)
8114b744:	10c00217 	ldw	r3,8(r2)
8114b748:	e0bffe17 	ldw	r2,-8(fp)
8114b74c:	10bfffc4 	addi	r2,r2,-1
8114b750:	1885883a 	add	r2,r3,r2
8114b754:	10800003 	ldbu	r2,0(r2)
8114b758:	10803fcc 	andi	r2,r2,255
8114b75c:	1080201c 	xori	r2,r2,128
8114b760:	10bfe004 	addi	r2,r2,-128
8114b764:	10800bd8 	cmpnei	r2,r2,47
8114b768:	1000031e 	bne	r2,zero,8114b778 <alt_find_file+0x74>
    {
      len -= 1;
8114b76c:	e0bffe17 	ldw	r2,-8(fp)
8114b770:	10bfffc4 	addi	r2,r2,-1
8114b774:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114b778:	e0bffe17 	ldw	r2,-8(fp)
8114b77c:	e0ffff17 	ldw	r3,-4(fp)
8114b780:	1885883a 	add	r2,r3,r2
8114b784:	10800003 	ldbu	r2,0(r2)
8114b788:	10803fcc 	andi	r2,r2,255
8114b78c:	1080201c 	xori	r2,r2,128
8114b790:	10bfe004 	addi	r2,r2,-128
8114b794:	10800be0 	cmpeqi	r2,r2,47
8114b798:	1000081e 	bne	r2,zero,8114b7bc <alt_find_file+0xb8>
8114b79c:	e0bffe17 	ldw	r2,-8(fp)
8114b7a0:	e0ffff17 	ldw	r3,-4(fp)
8114b7a4:	1885883a 	add	r2,r3,r2
8114b7a8:	10800003 	ldbu	r2,0(r2)
8114b7ac:	10803fcc 	andi	r2,r2,255
8114b7b0:	1080201c 	xori	r2,r2,128
8114b7b4:	10bfe004 	addi	r2,r2,-128
8114b7b8:	10000a1e 	bne	r2,zero,8114b7e4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114b7bc:	e0bffd17 	ldw	r2,-12(fp)
8114b7c0:	10800217 	ldw	r2,8(r2)
8114b7c4:	e0fffe17 	ldw	r3,-8(fp)
8114b7c8:	180d883a 	mov	r6,r3
8114b7cc:	e17fff17 	ldw	r5,-4(fp)
8114b7d0:	1009883a 	mov	r4,r2
8114b7d4:	114c4800 	call	8114c480 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114b7d8:	1000021e 	bne	r2,zero,8114b7e4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114b7dc:	e0bffd17 	ldw	r2,-12(fp)
8114b7e0:	00000706 	br	8114b800 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8114b7e4:	e0bffd17 	ldw	r2,-12(fp)
8114b7e8:	10800017 	ldw	r2,0(r2)
8114b7ec:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114b7f0:	e0fffd17 	ldw	r3,-12(fp)
8114b7f4:	d0a00b04 	addi	r2,gp,-32724
8114b7f8:	18bfcc1e 	bne	r3,r2,8114b72c <__reset+0xfb12b72c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114b7fc:	0005883a 	mov	r2,zero
}
8114b800:	e037883a 	mov	sp,fp
8114b804:	dfc00117 	ldw	ra,4(sp)
8114b808:	df000017 	ldw	fp,0(sp)
8114b80c:	dec00204 	addi	sp,sp,8
8114b810:	f800283a 	ret

8114b814 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8114b814:	defff904 	addi	sp,sp,-28
8114b818:	de00012e 	bgeu	sp,et,8114b820 <alt_get_fd+0xc>
8114b81c:	003b68fa 	trap	3
8114b820:	dfc00615 	stw	ra,24(sp)
8114b824:	df000515 	stw	fp,20(sp)
8114b828:	df000504 	addi	fp,sp,20
8114b82c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8114b830:	00bffa04 	movi	r2,-24
8114b834:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114b838:	d0a07f17 	ldw	r2,-32260(gp)
8114b83c:	e0bffd15 	stw	r2,-12(fp)
8114b840:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8114b844:	e0bffe0b 	ldhu	r2,-8(fp)
8114b848:	e0fffe84 	addi	r3,fp,-6
8114b84c:	180d883a 	mov	r6,r3
8114b850:	100b883a 	mov	r5,r2
8114b854:	e13ffd17 	ldw	r4,-12(fp)
8114b858:	113fe340 	call	8113fe34 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114b85c:	e03ffb15 	stw	zero,-20(fp)
8114b860:	00001906 	br	8114b8c8 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8114b864:	00a04574 	movhi	r2,33045
8114b868:	108bfb04 	addi	r2,r2,12268
8114b86c:	e0fffb17 	ldw	r3,-20(fp)
8114b870:	18c00324 	muli	r3,r3,12
8114b874:	10c5883a 	add	r2,r2,r3
8114b878:	10800017 	ldw	r2,0(r2)
8114b87c:	10000f1e 	bne	r2,zero,8114b8bc <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114b880:	00a04574 	movhi	r2,33045
8114b884:	108bfb04 	addi	r2,r2,12268
8114b888:	e0fffb17 	ldw	r3,-20(fp)
8114b88c:	18c00324 	muli	r3,r3,12
8114b890:	10c5883a 	add	r2,r2,r3
8114b894:	e0ffff17 	ldw	r3,-4(fp)
8114b898:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114b89c:	d0e00f17 	ldw	r3,-32708(gp)
8114b8a0:	e0bffb17 	ldw	r2,-20(fp)
8114b8a4:	1880020e 	bge	r3,r2,8114b8b0 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114b8a8:	e0bffb17 	ldw	r2,-20(fp)
8114b8ac:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114b8b0:	e0bffb17 	ldw	r2,-20(fp)
8114b8b4:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114b8b8:	00000606 	br	8114b8d4 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114b8bc:	e0bffb17 	ldw	r2,-20(fp)
8114b8c0:	10800044 	addi	r2,r2,1
8114b8c4:	e0bffb15 	stw	r2,-20(fp)
8114b8c8:	e0bffb17 	ldw	r2,-20(fp)
8114b8cc:	10800810 	cmplti	r2,r2,32
8114b8d0:	103fe41e 	bne	r2,zero,8114b864 <__reset+0xfb12b864>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8114b8d4:	d0a07f17 	ldw	r2,-32260(gp)
8114b8d8:	1009883a 	mov	r4,r2
8114b8dc:	11401bc0 	call	811401bc <OSSemPost>

  return rc;
8114b8e0:	e0bffc17 	ldw	r2,-16(fp)
}
8114b8e4:	e037883a 	mov	sp,fp
8114b8e8:	dfc00117 	ldw	ra,4(sp)
8114b8ec:	df000017 	ldw	fp,0(sp)
8114b8f0:	dec00204 	addi	sp,sp,8
8114b8f4:	f800283a 	ret

8114b8f8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114b8f8:	defff904 	addi	sp,sp,-28
8114b8fc:	de00012e 	bgeu	sp,et,8114b904 <alt_ic_isr_register+0xc>
8114b900:	003b68fa 	trap	3
8114b904:	dfc00615 	stw	ra,24(sp)
8114b908:	df000515 	stw	fp,20(sp)
8114b90c:	df000504 	addi	fp,sp,20
8114b910:	e13ffc15 	stw	r4,-16(fp)
8114b914:	e17ffd15 	stw	r5,-12(fp)
8114b918:	e1bffe15 	stw	r6,-8(fp)
8114b91c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8114b920:	e0800217 	ldw	r2,8(fp)
8114b924:	d8800015 	stw	r2,0(sp)
8114b928:	e1ffff17 	ldw	r7,-4(fp)
8114b92c:	e1bffe17 	ldw	r6,-8(fp)
8114b930:	e17ffd17 	ldw	r5,-12(fp)
8114b934:	e13ffc17 	ldw	r4,-16(fp)
8114b938:	114bac80 	call	8114bac8 <alt_iic_isr_register>
}  
8114b93c:	e037883a 	mov	sp,fp
8114b940:	dfc00117 	ldw	ra,4(sp)
8114b944:	df000017 	ldw	fp,0(sp)
8114b948:	dec00204 	addi	sp,sp,8
8114b94c:	f800283a 	ret

8114b950 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114b950:	defff904 	addi	sp,sp,-28
8114b954:	de00012e 	bgeu	sp,et,8114b95c <alt_ic_irq_enable+0xc>
8114b958:	003b68fa 	trap	3
8114b95c:	df000615 	stw	fp,24(sp)
8114b960:	df000604 	addi	fp,sp,24
8114b964:	e13ffe15 	stw	r4,-8(fp)
8114b968:	e17fff15 	stw	r5,-4(fp)
8114b96c:	e0bfff17 	ldw	r2,-4(fp)
8114b970:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b974:	0005303a 	rdctl	r2,status
8114b978:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b97c:	e0fffb17 	ldw	r3,-20(fp)
8114b980:	00bfff84 	movi	r2,-2
8114b984:	1884703a 	and	r2,r3,r2
8114b988:	1001703a 	wrctl	status,r2
  
  return context;
8114b98c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114b990:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114b994:	00c00044 	movi	r3,1
8114b998:	e0bffa17 	ldw	r2,-24(fp)
8114b99c:	1884983a 	sll	r2,r3,r2
8114b9a0:	1007883a 	mov	r3,r2
8114b9a4:	d0a08017 	ldw	r2,-32256(gp)
8114b9a8:	1884b03a 	or	r2,r3,r2
8114b9ac:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114b9b0:	d0a08017 	ldw	r2,-32256(gp)
8114b9b4:	100170fa 	wrctl	ienable,r2
8114b9b8:	e0bffc17 	ldw	r2,-16(fp)
8114b9bc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b9c0:	e0bffd17 	ldw	r2,-12(fp)
8114b9c4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114b9c8:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114b9cc:	0001883a 	nop
}
8114b9d0:	e037883a 	mov	sp,fp
8114b9d4:	df000017 	ldw	fp,0(sp)
8114b9d8:	dec00104 	addi	sp,sp,4
8114b9dc:	f800283a 	ret

8114b9e0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114b9e0:	defff904 	addi	sp,sp,-28
8114b9e4:	de00012e 	bgeu	sp,et,8114b9ec <alt_ic_irq_disable+0xc>
8114b9e8:	003b68fa 	trap	3
8114b9ec:	df000615 	stw	fp,24(sp)
8114b9f0:	df000604 	addi	fp,sp,24
8114b9f4:	e13ffe15 	stw	r4,-8(fp)
8114b9f8:	e17fff15 	stw	r5,-4(fp)
8114b9fc:	e0bfff17 	ldw	r2,-4(fp)
8114ba00:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ba04:	0005303a 	rdctl	r2,status
8114ba08:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ba0c:	e0fffb17 	ldw	r3,-20(fp)
8114ba10:	00bfff84 	movi	r2,-2
8114ba14:	1884703a 	and	r2,r3,r2
8114ba18:	1001703a 	wrctl	status,r2
  
  return context;
8114ba1c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114ba20:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114ba24:	00c00044 	movi	r3,1
8114ba28:	e0bffa17 	ldw	r2,-24(fp)
8114ba2c:	1884983a 	sll	r2,r3,r2
8114ba30:	0084303a 	nor	r2,zero,r2
8114ba34:	1007883a 	mov	r3,r2
8114ba38:	d0a08017 	ldw	r2,-32256(gp)
8114ba3c:	1884703a 	and	r2,r3,r2
8114ba40:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114ba44:	d0a08017 	ldw	r2,-32256(gp)
8114ba48:	100170fa 	wrctl	ienable,r2
8114ba4c:	e0bffc17 	ldw	r2,-16(fp)
8114ba50:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ba54:	e0bffd17 	ldw	r2,-12(fp)
8114ba58:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114ba5c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114ba60:	0001883a 	nop
}
8114ba64:	e037883a 	mov	sp,fp
8114ba68:	df000017 	ldw	fp,0(sp)
8114ba6c:	dec00104 	addi	sp,sp,4
8114ba70:	f800283a 	ret

8114ba74 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114ba74:	defffc04 	addi	sp,sp,-16
8114ba78:	de00012e 	bgeu	sp,et,8114ba80 <alt_ic_irq_enabled+0xc>
8114ba7c:	003b68fa 	trap	3
8114ba80:	df000315 	stw	fp,12(sp)
8114ba84:	df000304 	addi	fp,sp,12
8114ba88:	e13ffe15 	stw	r4,-8(fp)
8114ba8c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114ba90:	000530fa 	rdctl	r2,ienable
8114ba94:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114ba98:	00c00044 	movi	r3,1
8114ba9c:	e0bfff17 	ldw	r2,-4(fp)
8114baa0:	1884983a 	sll	r2,r3,r2
8114baa4:	1007883a 	mov	r3,r2
8114baa8:	e0bffd17 	ldw	r2,-12(fp)
8114baac:	1884703a 	and	r2,r3,r2
8114bab0:	1004c03a 	cmpne	r2,r2,zero
8114bab4:	10803fcc 	andi	r2,r2,255
}
8114bab8:	e037883a 	mov	sp,fp
8114babc:	df000017 	ldw	fp,0(sp)
8114bac0:	dec00104 	addi	sp,sp,4
8114bac4:	f800283a 	ret

8114bac8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114bac8:	defff504 	addi	sp,sp,-44
8114bacc:	de00012e 	bgeu	sp,et,8114bad4 <alt_iic_isr_register+0xc>
8114bad0:	003b68fa 	trap	3
8114bad4:	dfc00a15 	stw	ra,40(sp)
8114bad8:	df000915 	stw	fp,36(sp)
8114badc:	df000904 	addi	fp,sp,36
8114bae0:	e13ffc15 	stw	r4,-16(fp)
8114bae4:	e17ffd15 	stw	r5,-12(fp)
8114bae8:	e1bffe15 	stw	r6,-8(fp)
8114baec:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114baf0:	00bffa84 	movi	r2,-22
8114baf4:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114baf8:	e0bffd17 	ldw	r2,-12(fp)
8114bafc:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114bb00:	e0bff817 	ldw	r2,-32(fp)
8114bb04:	10800808 	cmpgei	r2,r2,32
8114bb08:	1000271e 	bne	r2,zero,8114bba8 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114bb0c:	0005303a 	rdctl	r2,status
8114bb10:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114bb14:	e0fffb17 	ldw	r3,-20(fp)
8114bb18:	00bfff84 	movi	r2,-2
8114bb1c:	1884703a 	and	r2,r3,r2
8114bb20:	1001703a 	wrctl	status,r2
  
  return context;
8114bb24:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114bb28:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114bb2c:	00a045f4 	movhi	r2,33047
8114bb30:	10b9a104 	addi	r2,r2,-6524
8114bb34:	e0fff817 	ldw	r3,-32(fp)
8114bb38:	180690fa 	slli	r3,r3,3
8114bb3c:	10c5883a 	add	r2,r2,r3
8114bb40:	e0fffe17 	ldw	r3,-8(fp)
8114bb44:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114bb48:	00a045f4 	movhi	r2,33047
8114bb4c:	10b9a104 	addi	r2,r2,-6524
8114bb50:	e0fff817 	ldw	r3,-32(fp)
8114bb54:	180690fa 	slli	r3,r3,3
8114bb58:	10c5883a 	add	r2,r2,r3
8114bb5c:	10800104 	addi	r2,r2,4
8114bb60:	e0ffff17 	ldw	r3,-4(fp)
8114bb64:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114bb68:	e0bffe17 	ldw	r2,-8(fp)
8114bb6c:	10000526 	beq	r2,zero,8114bb84 <alt_iic_isr_register+0xbc>
8114bb70:	e0bff817 	ldw	r2,-32(fp)
8114bb74:	100b883a 	mov	r5,r2
8114bb78:	e13ffc17 	ldw	r4,-16(fp)
8114bb7c:	114b9500 	call	8114b950 <alt_ic_irq_enable>
8114bb80:	00000406 	br	8114bb94 <alt_iic_isr_register+0xcc>
8114bb84:	e0bff817 	ldw	r2,-32(fp)
8114bb88:	100b883a 	mov	r5,r2
8114bb8c:	e13ffc17 	ldw	r4,-16(fp)
8114bb90:	114b9e00 	call	8114b9e0 <alt_ic_irq_disable>
8114bb94:	e0bff715 	stw	r2,-36(fp)
8114bb98:	e0bffa17 	ldw	r2,-24(fp)
8114bb9c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114bba0:	e0bff917 	ldw	r2,-28(fp)
8114bba4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114bba8:	e0bff717 	ldw	r2,-36(fp)
}
8114bbac:	e037883a 	mov	sp,fp
8114bbb0:	dfc00117 	ldw	ra,4(sp)
8114bbb4:	df000017 	ldw	fp,0(sp)
8114bbb8:	dec00204 	addi	sp,sp,8
8114bbbc:	f800283a 	ret

8114bbc0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114bbc0:	defff904 	addi	sp,sp,-28
8114bbc4:	de00012e 	bgeu	sp,et,8114bbcc <alt_open_fd+0xc>
8114bbc8:	003b68fa 	trap	3
8114bbcc:	dfc00615 	stw	ra,24(sp)
8114bbd0:	df000515 	stw	fp,20(sp)
8114bbd4:	df000504 	addi	fp,sp,20
8114bbd8:	e13ffc15 	stw	r4,-16(fp)
8114bbdc:	e17ffd15 	stw	r5,-12(fp)
8114bbe0:	e1bffe15 	stw	r6,-8(fp)
8114bbe4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114bbe8:	e1bfff17 	ldw	r6,-4(fp)
8114bbec:	e17ffe17 	ldw	r5,-8(fp)
8114bbf0:	e13ffd17 	ldw	r4,-12(fp)
8114bbf4:	1138a700 	call	81138a70 <open>
8114bbf8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114bbfc:	e0bffb17 	ldw	r2,-20(fp)
8114bc00:	10001c16 	blt	r2,zero,8114bc74 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114bc04:	00a04574 	movhi	r2,33045
8114bc08:	108bfb04 	addi	r2,r2,12268
8114bc0c:	e0fffb17 	ldw	r3,-20(fp)
8114bc10:	18c00324 	muli	r3,r3,12
8114bc14:	10c5883a 	add	r2,r2,r3
8114bc18:	10c00017 	ldw	r3,0(r2)
8114bc1c:	e0bffc17 	ldw	r2,-16(fp)
8114bc20:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114bc24:	00a04574 	movhi	r2,33045
8114bc28:	108bfb04 	addi	r2,r2,12268
8114bc2c:	e0fffb17 	ldw	r3,-20(fp)
8114bc30:	18c00324 	muli	r3,r3,12
8114bc34:	10c5883a 	add	r2,r2,r3
8114bc38:	10800104 	addi	r2,r2,4
8114bc3c:	10c00017 	ldw	r3,0(r2)
8114bc40:	e0bffc17 	ldw	r2,-16(fp)
8114bc44:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114bc48:	00a04574 	movhi	r2,33045
8114bc4c:	108bfb04 	addi	r2,r2,12268
8114bc50:	e0fffb17 	ldw	r3,-20(fp)
8114bc54:	18c00324 	muli	r3,r3,12
8114bc58:	10c5883a 	add	r2,r2,r3
8114bc5c:	10800204 	addi	r2,r2,8
8114bc60:	10c00017 	ldw	r3,0(r2)
8114bc64:	e0bffc17 	ldw	r2,-16(fp)
8114bc68:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114bc6c:	e13ffb17 	ldw	r4,-20(fp)
8114bc70:	1138d140 	call	81138d14 <alt_release_fd>
  }
} 
8114bc74:	0001883a 	nop
8114bc78:	e037883a 	mov	sp,fp
8114bc7c:	dfc00117 	ldw	ra,4(sp)
8114bc80:	df000017 	ldw	fp,0(sp)
8114bc84:	dec00204 	addi	sp,sp,8
8114bc88:	f800283a 	ret

8114bc8c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114bc8c:	defffb04 	addi	sp,sp,-20
8114bc90:	de00012e 	bgeu	sp,et,8114bc98 <alt_io_redirect+0xc>
8114bc94:	003b68fa 	trap	3
8114bc98:	dfc00415 	stw	ra,16(sp)
8114bc9c:	df000315 	stw	fp,12(sp)
8114bca0:	df000304 	addi	fp,sp,12
8114bca4:	e13ffd15 	stw	r4,-12(fp)
8114bca8:	e17ffe15 	stw	r5,-8(fp)
8114bcac:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114bcb0:	01c07fc4 	movi	r7,511
8114bcb4:	01800044 	movi	r6,1
8114bcb8:	e17ffd17 	ldw	r5,-12(fp)
8114bcbc:	01204574 	movhi	r4,33045
8114bcc0:	210bfe04 	addi	r4,r4,12280
8114bcc4:	114bbc00 	call	8114bbc0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114bcc8:	01c07fc4 	movi	r7,511
8114bccc:	000d883a 	mov	r6,zero
8114bcd0:	e17ffe17 	ldw	r5,-8(fp)
8114bcd4:	01204574 	movhi	r4,33045
8114bcd8:	210bfb04 	addi	r4,r4,12268
8114bcdc:	114bbc00 	call	8114bbc0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114bce0:	01c07fc4 	movi	r7,511
8114bce4:	01800044 	movi	r6,1
8114bce8:	e17fff17 	ldw	r5,-4(fp)
8114bcec:	01204574 	movhi	r4,33045
8114bcf0:	210c0104 	addi	r4,r4,12292
8114bcf4:	114bbc00 	call	8114bbc0 <alt_open_fd>
}  
8114bcf8:	0001883a 	nop
8114bcfc:	e037883a 	mov	sp,fp
8114bd00:	dfc00117 	ldw	ra,4(sp)
8114bd04:	df000017 	ldw	fp,0(sp)
8114bd08:	dec00204 	addi	sp,sp,8
8114bd0c:	f800283a 	ret

8114bd10 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114bd10:	defff204 	addi	sp,sp,-56
8114bd14:	de00012e 	bgeu	sp,et,8114bd1c <alt_printf+0xc>
8114bd18:	003b68fa 	trap	3
8114bd1c:	dfc00a15 	stw	ra,40(sp)
8114bd20:	df000915 	stw	fp,36(sp)
8114bd24:	df000904 	addi	fp,sp,36
8114bd28:	e13fff15 	stw	r4,-4(fp)
8114bd2c:	e1400215 	stw	r5,8(fp)
8114bd30:	e1800315 	stw	r6,12(fp)
8114bd34:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114bd38:	e0800204 	addi	r2,fp,8
8114bd3c:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114bd40:	e0bfff17 	ldw	r2,-4(fp)
8114bd44:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114bd48:	00006f06 	br	8114bf08 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114bd4c:	e0bff807 	ldb	r2,-32(fp)
8114bd50:	10800960 	cmpeqi	r2,r2,37
8114bd54:	1000041e 	bne	r2,zero,8114bd68 <alt_printf+0x58>
        {
            alt_putchar(c);
8114bd58:	e0bff807 	ldb	r2,-32(fp)
8114bd5c:	1009883a 	mov	r4,r2
8114bd60:	114bf440 	call	8114bf44 <alt_putchar>
8114bd64:	00006806 	br	8114bf08 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114bd68:	e0bff717 	ldw	r2,-36(fp)
8114bd6c:	10c00044 	addi	r3,r2,1
8114bd70:	e0fff715 	stw	r3,-36(fp)
8114bd74:	10800003 	ldbu	r2,0(r2)
8114bd78:	e0bff805 	stb	r2,-32(fp)
8114bd7c:	e0bff807 	ldb	r2,-32(fp)
8114bd80:	10006926 	beq	r2,zero,8114bf28 <alt_printf+0x218>
            {
                if (c == '%')
8114bd84:	e0bff807 	ldb	r2,-32(fp)
8114bd88:	10800958 	cmpnei	r2,r2,37
8114bd8c:	1000041e 	bne	r2,zero,8114bda0 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114bd90:	e0bff807 	ldb	r2,-32(fp)
8114bd94:	1009883a 	mov	r4,r2
8114bd98:	114bf440 	call	8114bf44 <alt_putchar>
8114bd9c:	00005a06 	br	8114bf08 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114bda0:	e0bff807 	ldb	r2,-32(fp)
8114bda4:	108018d8 	cmpnei	r2,r2,99
8114bda8:	1000081e 	bne	r2,zero,8114bdcc <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114bdac:	e0bffe17 	ldw	r2,-8(fp)
8114bdb0:	10c00104 	addi	r3,r2,4
8114bdb4:	e0fffe15 	stw	r3,-8(fp)
8114bdb8:	10800017 	ldw	r2,0(r2)
8114bdbc:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114bdc0:	e13ffd17 	ldw	r4,-12(fp)
8114bdc4:	114bf440 	call	8114bf44 <alt_putchar>
8114bdc8:	00004f06 	br	8114bf08 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114bdcc:	e0bff807 	ldb	r2,-32(fp)
8114bdd0:	10801e18 	cmpnei	r2,r2,120
8114bdd4:	1000341e 	bne	r2,zero,8114bea8 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114bdd8:	e0bffe17 	ldw	r2,-8(fp)
8114bddc:	10c00104 	addi	r3,r2,4
8114bde0:	e0fffe15 	stw	r3,-8(fp)
8114bde4:	10800017 	ldw	r2,0(r2)
8114bde8:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114bdec:	e0bffb17 	ldw	r2,-20(fp)
8114bdf0:	1000031e 	bne	r2,zero,8114be00 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114bdf4:	01000c04 	movi	r4,48
8114bdf8:	114bf440 	call	8114bf44 <alt_putchar>
                        continue;
8114bdfc:	00004206 	br	8114bf08 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114be00:	00800704 	movi	r2,28
8114be04:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114be08:	00000306 	br	8114be18 <alt_printf+0x108>
                        digit_shift -= 4;
8114be0c:	e0bff917 	ldw	r2,-28(fp)
8114be10:	10bfff04 	addi	r2,r2,-4
8114be14:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114be18:	00c003c4 	movi	r3,15
8114be1c:	e0bff917 	ldw	r2,-28(fp)
8114be20:	1884983a 	sll	r2,r3,r2
8114be24:	1007883a 	mov	r3,r2
8114be28:	e0bffb17 	ldw	r2,-20(fp)
8114be2c:	1884703a 	and	r2,r3,r2
8114be30:	103ff626 	beq	r2,zero,8114be0c <__reset+0xfb12be0c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114be34:	00001906 	br	8114be9c <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114be38:	00c003c4 	movi	r3,15
8114be3c:	e0bff917 	ldw	r2,-28(fp)
8114be40:	1884983a 	sll	r2,r3,r2
8114be44:	1007883a 	mov	r3,r2
8114be48:	e0bffb17 	ldw	r2,-20(fp)
8114be4c:	1886703a 	and	r3,r3,r2
8114be50:	e0bff917 	ldw	r2,-28(fp)
8114be54:	1884d83a 	srl	r2,r3,r2
8114be58:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114be5c:	e0bffc17 	ldw	r2,-16(fp)
8114be60:	108002a8 	cmpgeui	r2,r2,10
8114be64:	1000041e 	bne	r2,zero,8114be78 <alt_printf+0x168>
                            c = '0' + digit;
8114be68:	e0bffc17 	ldw	r2,-16(fp)
8114be6c:	10800c04 	addi	r2,r2,48
8114be70:	e0bff805 	stb	r2,-32(fp)
8114be74:	00000306 	br	8114be84 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114be78:	e0bffc17 	ldw	r2,-16(fp)
8114be7c:	108015c4 	addi	r2,r2,87
8114be80:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114be84:	e0bff807 	ldb	r2,-32(fp)
8114be88:	1009883a 	mov	r4,r2
8114be8c:	114bf440 	call	8114bf44 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114be90:	e0bff917 	ldw	r2,-28(fp)
8114be94:	10bfff04 	addi	r2,r2,-4
8114be98:	e0bff915 	stw	r2,-28(fp)
8114be9c:	e0bff917 	ldw	r2,-28(fp)
8114bea0:	103fe50e 	bge	r2,zero,8114be38 <__reset+0xfb12be38>
8114bea4:	00001806 	br	8114bf08 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114bea8:	e0bff807 	ldb	r2,-32(fp)
8114beac:	10801cd8 	cmpnei	r2,r2,115
8114beb0:	1000151e 	bne	r2,zero,8114bf08 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114beb4:	e0bffe17 	ldw	r2,-8(fp)
8114beb8:	10c00104 	addi	r3,r2,4
8114bebc:	e0fffe15 	stw	r3,-8(fp)
8114bec0:	10800017 	ldw	r2,0(r2)
8114bec4:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114bec8:	00000906 	br	8114bef0 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114becc:	e0bffa17 	ldw	r2,-24(fp)
8114bed0:	10c00044 	addi	r3,r2,1
8114bed4:	e0fffa15 	stw	r3,-24(fp)
8114bed8:	10800003 	ldbu	r2,0(r2)
8114bedc:	10803fcc 	andi	r2,r2,255
8114bee0:	1080201c 	xori	r2,r2,128
8114bee4:	10bfe004 	addi	r2,r2,-128
8114bee8:	1009883a 	mov	r4,r2
8114beec:	114bf440 	call	8114bf44 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114bef0:	e0bffa17 	ldw	r2,-24(fp)
8114bef4:	10800003 	ldbu	r2,0(r2)
8114bef8:	10803fcc 	andi	r2,r2,255
8114befc:	1080201c 	xori	r2,r2,128
8114bf00:	10bfe004 	addi	r2,r2,-128
8114bf04:	103ff11e 	bne	r2,zero,8114becc <__reset+0xfb12becc>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114bf08:	e0bff717 	ldw	r2,-36(fp)
8114bf0c:	10c00044 	addi	r3,r2,1
8114bf10:	e0fff715 	stw	r3,-36(fp)
8114bf14:	10800003 	ldbu	r2,0(r2)
8114bf18:	e0bff805 	stb	r2,-32(fp)
8114bf1c:	e0bff807 	ldb	r2,-32(fp)
8114bf20:	103f8a1e 	bne	r2,zero,8114bd4c <__reset+0xfb12bd4c>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114bf24:	00000106 	br	8114bf2c <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114bf28:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114bf2c:	0001883a 	nop
8114bf30:	e037883a 	mov	sp,fp
8114bf34:	dfc00117 	ldw	ra,4(sp)
8114bf38:	df000017 	ldw	fp,0(sp)
8114bf3c:	dec00504 	addi	sp,sp,20
8114bf40:	f800283a 	ret

8114bf44 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114bf44:	defffd04 	addi	sp,sp,-12
8114bf48:	de00012e 	bgeu	sp,et,8114bf50 <alt_putchar+0xc>
8114bf4c:	003b68fa 	trap	3
8114bf50:	dfc00215 	stw	ra,8(sp)
8114bf54:	df000115 	stw	fp,4(sp)
8114bf58:	df000104 	addi	fp,sp,4
8114bf5c:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114bf60:	d0a00517 	ldw	r2,-32748(gp)
8114bf64:	10800217 	ldw	r2,8(r2)
8114bf68:	100b883a 	mov	r5,r2
8114bf6c:	e13fff17 	ldw	r4,-4(fp)
8114bf70:	1123dcc0 	call	81123dcc <putc>
#endif
#endif
}
8114bf74:	e037883a 	mov	sp,fp
8114bf78:	dfc00117 	ldw	ra,4(sp)
8114bf7c:	df000017 	ldw	fp,0(sp)
8114bf80:	dec00204 	addi	sp,sp,8
8114bf84:	f800283a 	ret

8114bf88 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114bf88:	deffff04 	addi	sp,sp,-4
8114bf8c:	de00012e 	bgeu	sp,et,8114bf94 <altera_nios2_gen2_irq_init+0xc>
8114bf90:	003b68fa 	trap	3
8114bf94:	df000015 	stw	fp,0(sp)
8114bf98:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114bf9c:	000170fa 	wrctl	ienable,zero
}
8114bfa0:	0001883a 	nop
8114bfa4:	e037883a 	mov	sp,fp
8114bfa8:	df000017 	ldw	fp,0(sp)
8114bfac:	dec00104 	addi	sp,sp,4
8114bfb0:	f800283a 	ret

8114bfb4 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114bfb4:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114bfb8:	de002436 	bltu	sp,et,8114c04c <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114bfbc:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114bfc0:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114bfc4:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114bfc8:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114bfcc:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114bfd0:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114bfd4:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114bfd8:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114bfdc:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114bfe0:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114bfe4:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114bfe8:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114bfec:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114bff0:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114bff4:	114c2500 	call	8114c250 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114bff8:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114bffc:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114c000:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114c004:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114c008:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114c00c:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114c010:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114c014:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114c018:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114c01c:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114c020:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114c024:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114c028:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114c02c:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114c030:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114c034:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114c038:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114c03c:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114c040:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114c044:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114c048:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114c04c:	003da0fa 	break	3

8114c050 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114c050:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114c054:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114c058:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114c05c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114c060:	114c2500 	call	8114c250 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114c064:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114c068:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114c06c:	003fe206 	br	8114bff8 <__reset+0xfb12bff8>

8114c070 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114c070:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114c074:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114c078:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114c07c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114c080:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114c084:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114c088:	dec00204 	addi	sp,sp,8

      callr r2
8114c08c:	103ee83a 	callr	r2

      nop
8114c090:	0001883a 	nop

8114c094 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114c094:	defff704 	addi	sp,sp,-36
8114c098:	de00012e 	bgeu	sp,et,8114c0a0 <OSTaskStkInit+0xc>
8114c09c:	003b68fa 	trap	3
8114c0a0:	dfc00815 	stw	ra,32(sp)
8114c0a4:	df000715 	stw	fp,28(sp)
8114c0a8:	df000704 	addi	fp,sp,28
8114c0ac:	e13ffc15 	stw	r4,-16(fp)
8114c0b0:	e17ffd15 	stw	r5,-12(fp)
8114c0b4:	e1bffe15 	stw	r6,-8(fp)
8114c0b8:	3805883a 	mov	r2,r7
8114c0bc:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114c0c0:	e0fffe17 	ldw	r3,-8(fp)
8114c0c4:	00bfff04 	movi	r2,-4
8114c0c8:	1884703a 	and	r2,r3,r2
8114c0cc:	10bef704 	addi	r2,r2,-1060
8114c0d0:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114c0d4:	01810904 	movi	r6,1060
8114c0d8:	000b883a 	mov	r5,zero
8114c0dc:	e13ff917 	ldw	r4,-28(fp)
8114c0e0:	1123b940 	call	81123b94 <memset>
8114c0e4:	e0bff917 	ldw	r2,-28(fp)
8114c0e8:	10c0bb04 	addi	r3,r2,748
8114c0ec:	e0bff917 	ldw	r2,-28(fp)
8114c0f0:	10c00115 	stw	r3,4(r2)
8114c0f4:	e0bff917 	ldw	r2,-28(fp)
8114c0f8:	10c0d504 	addi	r3,r2,852
8114c0fc:	e0bff917 	ldw	r2,-28(fp)
8114c100:	10c00215 	stw	r3,8(r2)
8114c104:	e0bff917 	ldw	r2,-28(fp)
8114c108:	10c0ef04 	addi	r3,r2,956
8114c10c:	e0bff917 	ldw	r2,-28(fp)
8114c110:	10c00315 	stw	r3,12(r2)
8114c114:	e0fff917 	ldw	r3,-28(fp)
8114c118:	00a04574 	movhi	r2,33045
8114c11c:	10899404 	addi	r2,r2,9808
8114c120:	18800d15 	stw	r2,52(r3)
8114c124:	e0bff917 	ldw	r2,-28(fp)
8114c128:	00c00044 	movi	r3,1
8114c12c:	10c02915 	stw	r3,164(r2)
8114c130:	10002a15 	stw	zero,168(r2)
8114c134:	e0bff917 	ldw	r2,-28(fp)
8114c138:	00ccc384 	movi	r3,13070
8114c13c:	10c02b0d 	sth	r3,172(r2)
8114c140:	e0bff917 	ldw	r2,-28(fp)
8114c144:	00eaf344 	movi	r3,-21555
8114c148:	10c02b8d 	sth	r3,174(r2)
8114c14c:	e0bff917 	ldw	r2,-28(fp)
8114c150:	00c48d04 	movi	r3,4660
8114c154:	10c02c0d 	sth	r3,176(r2)
8114c158:	e0bff917 	ldw	r2,-28(fp)
8114c15c:	00f99b44 	movi	r3,-6547
8114c160:	10c02c8d 	sth	r3,178(r2)
8114c164:	e0bff917 	ldw	r2,-28(fp)
8114c168:	00f7bb04 	movi	r3,-8468
8114c16c:	10c02d0d 	sth	r3,180(r2)
8114c170:	e0bff917 	ldw	r2,-28(fp)
8114c174:	00c00144 	movi	r3,5
8114c178:	10c02d8d 	sth	r3,182(r2)
8114c17c:	e0bff917 	ldw	r2,-28(fp)
8114c180:	00c002c4 	movi	r3,11
8114c184:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114c188:	e0bff917 	ldw	r2,-28(fp)
8114c18c:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114c190:	e0bffa17 	ldw	r2,-24(fp)
8114c194:	10bff304 	addi	r2,r2,-52
8114c198:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114c19c:	e0bffb17 	ldw	r2,-20(fp)
8114c1a0:	10800c04 	addi	r2,r2,48
8114c1a4:	e0fffc17 	ldw	r3,-16(fp)
8114c1a8:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114c1ac:	e0bffb17 	ldw	r2,-20(fp)
8114c1b0:	10800b04 	addi	r2,r2,44
8114c1b4:	e0fffd17 	ldw	r3,-12(fp)
8114c1b8:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114c1bc:	e0bffb17 	ldw	r2,-20(fp)
8114c1c0:	10800a04 	addi	r2,r2,40
8114c1c4:	e0fff917 	ldw	r3,-28(fp)
8114c1c8:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114c1cc:	00a04574 	movhi	r2,33045
8114c1d0:	10b01c04 	addi	r2,r2,-16272
8114c1d4:	10c00104 	addi	r3,r2,4
8114c1d8:	e0bffb17 	ldw	r2,-20(fp)
8114c1dc:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114c1e0:	e0bffb17 	ldw	r2,-20(fp)
}
8114c1e4:	e037883a 	mov	sp,fp
8114c1e8:	dfc00117 	ldw	ra,4(sp)
8114c1ec:	df000017 	ldw	fp,0(sp)
8114c1f0:	dec00204 	addi	sp,sp,8
8114c1f4:	f800283a 	ret

8114c1f8 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114c1f8:	defffe04 	addi	sp,sp,-8
8114c1fc:	de00012e 	bgeu	sp,et,8114c204 <OSTaskCreateHook+0xc>
8114c200:	003b68fa 	trap	3
8114c204:	df000115 	stw	fp,4(sp)
8114c208:	df000104 	addi	fp,sp,4
8114c20c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114c210:	0001883a 	nop
8114c214:	e037883a 	mov	sp,fp
8114c218:	df000017 	ldw	fp,0(sp)
8114c21c:	dec00104 	addi	sp,sp,4
8114c220:	f800283a 	ret

8114c224 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114c224:	defffe04 	addi	sp,sp,-8
8114c228:	de00012e 	bgeu	sp,et,8114c230 <OSTaskDelHook+0xc>
8114c22c:	003b68fa 	trap	3
8114c230:	df000115 	stw	fp,4(sp)
8114c234:	df000104 	addi	fp,sp,4
8114c238:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114c23c:	0001883a 	nop
8114c240:	e037883a 	mov	sp,fp
8114c244:	df000017 	ldw	fp,0(sp)
8114c248:	dec00104 	addi	sp,sp,4
8114c24c:	f800283a 	ret

8114c250 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114c250:	deffff04 	addi	sp,sp,-4
8114c254:	de00012e 	bgeu	sp,et,8114c25c <OSTaskSwHook+0xc>
8114c258:	003b68fa 	trap	3
8114c25c:	df000015 	stw	fp,0(sp)
8114c260:	d839883a 	mov	fp,sp
}
8114c264:	0001883a 	nop
8114c268:	e037883a 	mov	sp,fp
8114c26c:	df000017 	ldw	fp,0(sp)
8114c270:	dec00104 	addi	sp,sp,4
8114c274:	f800283a 	ret

8114c278 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114c278:	deffff04 	addi	sp,sp,-4
8114c27c:	de00012e 	bgeu	sp,et,8114c284 <OSTaskStatHook+0xc>
8114c280:	003b68fa 	trap	3
8114c284:	df000015 	stw	fp,0(sp)
8114c288:	d839883a 	mov	fp,sp
}
8114c28c:	0001883a 	nop
8114c290:	e037883a 	mov	sp,fp
8114c294:	df000017 	ldw	fp,0(sp)
8114c298:	dec00104 	addi	sp,sp,4
8114c29c:	f800283a 	ret

8114c2a0 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114c2a0:	defffe04 	addi	sp,sp,-8
8114c2a4:	de00012e 	bgeu	sp,et,8114c2ac <OSTimeTickHook+0xc>
8114c2a8:	003b68fa 	trap	3
8114c2ac:	dfc00115 	stw	ra,4(sp)
8114c2b0:	df000015 	stw	fp,0(sp)
8114c2b4:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114c2b8:	d0a0b60b 	ldhu	r2,-32040(gp)
8114c2bc:	10800044 	addi	r2,r2,1
8114c2c0:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114c2c4:	d0a0b60b 	ldhu	r2,-32040(gp)
8114c2c8:	10bfffcc 	andi	r2,r2,65535
8114c2cc:	10807d30 	cmpltui	r2,r2,500
8114c2d0:	1000021e 	bne	r2,zero,8114c2dc <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114c2d4:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114c2d8:	1142bf00 	call	81142bf0 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114c2dc:	0001883a 	nop
8114c2e0:	e037883a 	mov	sp,fp
8114c2e4:	dfc00117 	ldw	ra,4(sp)
8114c2e8:	df000017 	ldw	fp,0(sp)
8114c2ec:	dec00204 	addi	sp,sp,8
8114c2f0:	f800283a 	ret

8114c2f4 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114c2f4:	deffff04 	addi	sp,sp,-4
8114c2f8:	de00012e 	bgeu	sp,et,8114c300 <OSInitHookBegin+0xc>
8114c2fc:	003b68fa 	trap	3
8114c300:	df000015 	stw	fp,0(sp)
8114c304:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114c308:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114c30c:	0001883a 	nop
8114c310:	e037883a 	mov	sp,fp
8114c314:	df000017 	ldw	fp,0(sp)
8114c318:	dec00104 	addi	sp,sp,4
8114c31c:	f800283a 	ret

8114c320 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114c320:	deffff04 	addi	sp,sp,-4
8114c324:	de00012e 	bgeu	sp,et,8114c32c <OSInitHookEnd+0xc>
8114c328:	003b68fa 	trap	3
8114c32c:	df000015 	stw	fp,0(sp)
8114c330:	d839883a 	mov	fp,sp
}
8114c334:	0001883a 	nop
8114c338:	e037883a 	mov	sp,fp
8114c33c:	df000017 	ldw	fp,0(sp)
8114c340:	dec00104 	addi	sp,sp,4
8114c344:	f800283a 	ret

8114c348 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114c348:	deffff04 	addi	sp,sp,-4
8114c34c:	de00012e 	bgeu	sp,et,8114c354 <OSTaskIdleHook+0xc>
8114c350:	003b68fa 	trap	3
8114c354:	df000015 	stw	fp,0(sp)
8114c358:	d839883a 	mov	fp,sp
}
8114c35c:	0001883a 	nop
8114c360:	e037883a 	mov	sp,fp
8114c364:	df000017 	ldw	fp,0(sp)
8114c368:	dec00104 	addi	sp,sp,4
8114c36c:	f800283a 	ret

8114c370 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114c370:	defffe04 	addi	sp,sp,-8
8114c374:	de00012e 	bgeu	sp,et,8114c37c <OSTCBInitHook+0xc>
8114c378:	003b68fa 	trap	3
8114c37c:	df000115 	stw	fp,4(sp)
8114c380:	df000104 	addi	fp,sp,4
8114c384:	e13fff15 	stw	r4,-4(fp)
}
8114c388:	0001883a 	nop
8114c38c:	e037883a 	mov	sp,fp
8114c390:	df000017 	ldw	fp,0(sp)
8114c394:	dec00104 	addi	sp,sp,4
8114c398:	f800283a 	ret

8114c39c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114c39c:	defffe04 	addi	sp,sp,-8
8114c3a0:	de00012e 	bgeu	sp,et,8114c3a8 <alt_exception_cause_generated_bad_addr+0xc>
8114c3a4:	003b68fa 	trap	3
8114c3a8:	df000115 	stw	fp,4(sp)
8114c3ac:	df000104 	addi	fp,sp,4
8114c3b0:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114c3b4:	e0bfff17 	ldw	r2,-4(fp)
8114c3b8:	10bffe84 	addi	r2,r2,-6
8114c3bc:	10c00428 	cmpgeui	r3,r2,16
8114c3c0:	18001a1e 	bne	r3,zero,8114c42c <alt_exception_cause_generated_bad_addr+0x90>
8114c3c4:	100690ba 	slli	r3,r2,2
8114c3c8:	00a04574 	movhi	r2,33045
8114c3cc:	10b0f704 	addi	r2,r2,-15396
8114c3d0:	1885883a 	add	r2,r3,r2
8114c3d4:	10800017 	ldw	r2,0(r2)
8114c3d8:	1000683a 	jmp	r2
8114c3dc:	8114c41c 	xori	r4,r16,21264
8114c3e0:	8114c41c 	xori	r4,r16,21264
8114c3e4:	8114c42c 	andhi	r4,r16,21264
8114c3e8:	8114c42c 	andhi	r4,r16,21264
8114c3ec:	8114c42c 	andhi	r4,r16,21264
8114c3f0:	8114c41c 	xori	r4,r16,21264
8114c3f4:	8114c424 	muli	r4,r16,21264
8114c3f8:	8114c42c 	andhi	r4,r16,21264
8114c3fc:	8114c41c 	xori	r4,r16,21264
8114c400:	8114c41c 	xori	r4,r16,21264
8114c404:	8114c42c 	andhi	r4,r16,21264
8114c408:	8114c41c 	xori	r4,r16,21264
8114c40c:	8114c424 	muli	r4,r16,21264
8114c410:	8114c42c 	andhi	r4,r16,21264
8114c414:	8114c42c 	andhi	r4,r16,21264
8114c418:	8114c41c 	xori	r4,r16,21264
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114c41c:	00800044 	movi	r2,1
8114c420:	00000306 	br	8114c430 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114c424:	0005883a 	mov	r2,zero
8114c428:	00000106 	br	8114c430 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114c42c:	0005883a 	mov	r2,zero
  }
}
8114c430:	e037883a 	mov	sp,fp
8114c434:	df000017 	ldw	fp,0(sp)
8114c438:	dec00104 	addi	sp,sp,4
8114c43c:	f800283a 	ret

8114c440 <exit>:
8114c440:	defffe04 	addi	sp,sp,-8
8114c444:	000b883a 	mov	r5,zero
8114c448:	de00012e 	bgeu	sp,et,8114c450 <exit+0x10>
8114c44c:	003b68fa 	trap	3
8114c450:	dc000015 	stw	r16,0(sp)
8114c454:	dfc00115 	stw	ra,4(sp)
8114c458:	2021883a 	mov	r16,r4
8114c45c:	114c5e80 	call	8114c5e8 <__call_exitprocs>
8114c460:	00a04574 	movhi	r2,33045
8114c464:	10911204 	addi	r2,r2,17480
8114c468:	11000017 	ldw	r4,0(r2)
8114c46c:	20800f17 	ldw	r2,60(r4)
8114c470:	10000126 	beq	r2,zero,8114c478 <exit+0x38>
8114c474:	103ee83a 	callr	r2
8114c478:	8009883a 	mov	r4,r16
8114c47c:	114c7700 	call	8114c770 <_exit>

8114c480 <memcmp>:
8114c480:	01c000c4 	movi	r7,3
8114c484:	3980192e 	bgeu	r7,r6,8114c4ec <memcmp+0x6c>
8114c488:	2144b03a 	or	r2,r4,r5
8114c48c:	11c4703a 	and	r2,r2,r7
8114c490:	10000f26 	beq	r2,zero,8114c4d0 <memcmp+0x50>
8114c494:	20800003 	ldbu	r2,0(r4)
8114c498:	28c00003 	ldbu	r3,0(r5)
8114c49c:	10c0151e 	bne	r2,r3,8114c4f4 <memcmp+0x74>
8114c4a0:	31bfff84 	addi	r6,r6,-2
8114c4a4:	01ffffc4 	movi	r7,-1
8114c4a8:	00000406 	br	8114c4bc <memcmp+0x3c>
8114c4ac:	20800003 	ldbu	r2,0(r4)
8114c4b0:	28c00003 	ldbu	r3,0(r5)
8114c4b4:	31bfffc4 	addi	r6,r6,-1
8114c4b8:	10c00e1e 	bne	r2,r3,8114c4f4 <memcmp+0x74>
8114c4bc:	21000044 	addi	r4,r4,1
8114c4c0:	29400044 	addi	r5,r5,1
8114c4c4:	31fff91e 	bne	r6,r7,8114c4ac <__reset+0xfb12c4ac>
8114c4c8:	0005883a 	mov	r2,zero
8114c4cc:	f800283a 	ret
8114c4d0:	20c00017 	ldw	r3,0(r4)
8114c4d4:	28800017 	ldw	r2,0(r5)
8114c4d8:	18bfee1e 	bne	r3,r2,8114c494 <__reset+0xfb12c494>
8114c4dc:	31bfff04 	addi	r6,r6,-4
8114c4e0:	21000104 	addi	r4,r4,4
8114c4e4:	29400104 	addi	r5,r5,4
8114c4e8:	39bff936 	bltu	r7,r6,8114c4d0 <__reset+0xfb12c4d0>
8114c4ec:	303fe91e 	bne	r6,zero,8114c494 <__reset+0xfb12c494>
8114c4f0:	003ff506 	br	8114c4c8 <__reset+0xfb12c4c8>
8114c4f4:	10c5c83a 	sub	r2,r2,r3
8114c4f8:	f800283a 	ret

8114c4fc <strncpy>:
8114c4fc:	2906b03a 	or	r3,r5,r4
8114c500:	18c000cc 	andi	r3,r3,3
8114c504:	2005883a 	mov	r2,r4
8114c508:	18002c1e 	bne	r3,zero,8114c5bc <strncpy+0xc0>
8114c50c:	010000c4 	movi	r4,3
8114c510:	21802a2e 	bgeu	r4,r6,8114c5bc <strncpy+0xc0>
8114c514:	033fbff4 	movhi	r12,65279
8114c518:	02e02074 	movhi	r11,32897
8114c51c:	633fbfc4 	addi	r12,r12,-257
8114c520:	5ae02004 	addi	r11,r11,-32640
8114c524:	100f883a 	mov	r7,r2
8114c528:	2a000017 	ldw	r8,0(r5)
8114c52c:	3815883a 	mov	r10,r7
8114c530:	4313883a 	add	r9,r8,r12
8114c534:	0206303a 	nor	r3,zero,r8
8114c538:	48c6703a 	and	r3,r9,r3
8114c53c:	1ac6703a 	and	r3,r3,r11
8114c540:	1800261e 	bne	r3,zero,8114c5dc <strncpy+0xe0>
8114c544:	39c00104 	addi	r7,r7,4
8114c548:	52000015 	stw	r8,0(r10)
8114c54c:	31bfff04 	addi	r6,r6,-4
8114c550:	3811883a 	mov	r8,r7
8114c554:	29400104 	addi	r5,r5,4
8114c558:	21bff336 	bltu	r4,r6,8114c528 <__reset+0xfb12c528>
8114c55c:	30001e26 	beq	r6,zero,8114c5d8 <strncpy+0xdc>
8114c560:	29c00003 	ldbu	r7,0(r5)
8114c564:	31bfffc4 	addi	r6,r6,-1
8114c568:	40c00044 	addi	r3,r8,1
8114c56c:	41c00005 	stb	r7,0(r8)
8114c570:	39c03fcc 	andi	r7,r7,255
8114c574:	39c0201c 	xori	r7,r7,128
8114c578:	39ffe004 	addi	r7,r7,-128
8114c57c:	29400044 	addi	r5,r5,1
8114c580:	38001026 	beq	r7,zero,8114c5c4 <strncpy+0xc8>
8114c584:	1811883a 	mov	r8,r3
8114c588:	00000906 	br	8114c5b0 <strncpy+0xb4>
8114c58c:	29c00003 	ldbu	r7,0(r5)
8114c590:	31bfffc4 	addi	r6,r6,-1
8114c594:	29400044 	addi	r5,r5,1
8114c598:	41c00005 	stb	r7,0(r8)
8114c59c:	39c03fcc 	andi	r7,r7,255
8114c5a0:	39c0201c 	xori	r7,r7,128
8114c5a4:	39ffe004 	addi	r7,r7,-128
8114c5a8:	1811883a 	mov	r8,r3
8114c5ac:	38000526 	beq	r7,zero,8114c5c4 <strncpy+0xc8>
8114c5b0:	18c00044 	addi	r3,r3,1
8114c5b4:	303ff51e 	bne	r6,zero,8114c58c <__reset+0xfb12c58c>
8114c5b8:	f800283a 	ret
8114c5bc:	1011883a 	mov	r8,r2
8114c5c0:	003fe606 	br	8114c55c <__reset+0xfb12c55c>
8114c5c4:	30000726 	beq	r6,zero,8114c5e4 <strncpy+0xe8>
8114c5c8:	198d883a 	add	r6,r3,r6
8114c5cc:	18000005 	stb	zero,0(r3)
8114c5d0:	18c00044 	addi	r3,r3,1
8114c5d4:	19bffd1e 	bne	r3,r6,8114c5cc <__reset+0xfb12c5cc>
8114c5d8:	f800283a 	ret
8114c5dc:	3811883a 	mov	r8,r7
8114c5e0:	003fdf06 	br	8114c560 <__reset+0xfb12c560>
8114c5e4:	f800283a 	ret

8114c5e8 <__call_exitprocs>:
8114c5e8:	defff504 	addi	sp,sp,-44
8114c5ec:	de00012e 	bgeu	sp,et,8114c5f4 <__call_exitprocs+0xc>
8114c5f0:	003b68fa 	trap	3
8114c5f4:	df000915 	stw	fp,36(sp)
8114c5f8:	dd400615 	stw	r21,24(sp)
8114c5fc:	dc800315 	stw	r18,12(sp)
8114c600:	dfc00a15 	stw	ra,40(sp)
8114c604:	ddc00815 	stw	r23,32(sp)
8114c608:	dd800715 	stw	r22,28(sp)
8114c60c:	dd000515 	stw	r20,20(sp)
8114c610:	dcc00415 	stw	r19,16(sp)
8114c614:	dc400215 	stw	r17,8(sp)
8114c618:	dc000115 	stw	r16,4(sp)
8114c61c:	d9000015 	stw	r4,0(sp)
8114c620:	2839883a 	mov	fp,r5
8114c624:	04800044 	movi	r18,1
8114c628:	057fffc4 	movi	r21,-1
8114c62c:	00a04574 	movhi	r2,33045
8114c630:	10911204 	addi	r2,r2,17480
8114c634:	12000017 	ldw	r8,0(r2)
8114c638:	45005217 	ldw	r20,328(r8)
8114c63c:	44c05204 	addi	r19,r8,328
8114c640:	a0001c26 	beq	r20,zero,8114c6b4 <__call_exitprocs+0xcc>
8114c644:	a0800117 	ldw	r2,4(r20)
8114c648:	15ffffc4 	addi	r23,r2,-1
8114c64c:	b8000d16 	blt	r23,zero,8114c684 <__call_exitprocs+0x9c>
8114c650:	14000044 	addi	r16,r2,1
8114c654:	8421883a 	add	r16,r16,r16
8114c658:	8421883a 	add	r16,r16,r16
8114c65c:	84402004 	addi	r17,r16,128
8114c660:	a463883a 	add	r17,r20,r17
8114c664:	a421883a 	add	r16,r20,r16
8114c668:	e0001e26 	beq	fp,zero,8114c6e4 <__call_exitprocs+0xfc>
8114c66c:	80804017 	ldw	r2,256(r16)
8114c670:	e0801c26 	beq	fp,r2,8114c6e4 <__call_exitprocs+0xfc>
8114c674:	bdffffc4 	addi	r23,r23,-1
8114c678:	843fff04 	addi	r16,r16,-4
8114c67c:	8c7fff04 	addi	r17,r17,-4
8114c680:	bd7ff91e 	bne	r23,r21,8114c668 <__reset+0xfb12c668>
8114c684:	00800034 	movhi	r2,0
8114c688:	10800004 	addi	r2,r2,0
8114c68c:	10000926 	beq	r2,zero,8114c6b4 <__call_exitprocs+0xcc>
8114c690:	a0800117 	ldw	r2,4(r20)
8114c694:	1000301e 	bne	r2,zero,8114c758 <__call_exitprocs+0x170>
8114c698:	a0800017 	ldw	r2,0(r20)
8114c69c:	10003226 	beq	r2,zero,8114c768 <__call_exitprocs+0x180>
8114c6a0:	a009883a 	mov	r4,r20
8114c6a4:	98800015 	stw	r2,0(r19)
8114c6a8:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114c6ac:	9d000017 	ldw	r20,0(r19)
8114c6b0:	a03fe41e 	bne	r20,zero,8114c644 <__reset+0xfb12c644>
8114c6b4:	dfc00a17 	ldw	ra,40(sp)
8114c6b8:	df000917 	ldw	fp,36(sp)
8114c6bc:	ddc00817 	ldw	r23,32(sp)
8114c6c0:	dd800717 	ldw	r22,28(sp)
8114c6c4:	dd400617 	ldw	r21,24(sp)
8114c6c8:	dd000517 	ldw	r20,20(sp)
8114c6cc:	dcc00417 	ldw	r19,16(sp)
8114c6d0:	dc800317 	ldw	r18,12(sp)
8114c6d4:	dc400217 	ldw	r17,8(sp)
8114c6d8:	dc000117 	ldw	r16,4(sp)
8114c6dc:	dec00b04 	addi	sp,sp,44
8114c6e0:	f800283a 	ret
8114c6e4:	a0800117 	ldw	r2,4(r20)
8114c6e8:	80c00017 	ldw	r3,0(r16)
8114c6ec:	10bfffc4 	addi	r2,r2,-1
8114c6f0:	15c01426 	beq	r2,r23,8114c744 <__call_exitprocs+0x15c>
8114c6f4:	80000015 	stw	zero,0(r16)
8114c6f8:	183fde26 	beq	r3,zero,8114c674 <__reset+0xfb12c674>
8114c6fc:	95c8983a 	sll	r4,r18,r23
8114c700:	a0806217 	ldw	r2,392(r20)
8114c704:	a5800117 	ldw	r22,4(r20)
8114c708:	2084703a 	and	r2,r4,r2
8114c70c:	10000b26 	beq	r2,zero,8114c73c <__call_exitprocs+0x154>
8114c710:	a0806317 	ldw	r2,396(r20)
8114c714:	2088703a 	and	r4,r4,r2
8114c718:	20000c1e 	bne	r4,zero,8114c74c <__call_exitprocs+0x164>
8114c71c:	89400017 	ldw	r5,0(r17)
8114c720:	d9000017 	ldw	r4,0(sp)
8114c724:	183ee83a 	callr	r3
8114c728:	a0800117 	ldw	r2,4(r20)
8114c72c:	15bfbf1e 	bne	r2,r22,8114c62c <__reset+0xfb12c62c>
8114c730:	98800017 	ldw	r2,0(r19)
8114c734:	153fcf26 	beq	r2,r20,8114c674 <__reset+0xfb12c674>
8114c738:	003fbc06 	br	8114c62c <__reset+0xfb12c62c>
8114c73c:	183ee83a 	callr	r3
8114c740:	003ff906 	br	8114c728 <__reset+0xfb12c728>
8114c744:	a5c00115 	stw	r23,4(r20)
8114c748:	003feb06 	br	8114c6f8 <__reset+0xfb12c6f8>
8114c74c:	89000017 	ldw	r4,0(r17)
8114c750:	183ee83a 	callr	r3
8114c754:	003ff406 	br	8114c728 <__reset+0xfb12c728>
8114c758:	a0800017 	ldw	r2,0(r20)
8114c75c:	a027883a 	mov	r19,r20
8114c760:	1029883a 	mov	r20,r2
8114c764:	003fb606 	br	8114c640 <__reset+0xfb12c640>
8114c768:	0005883a 	mov	r2,zero
8114c76c:	003ffb06 	br	8114c75c <__reset+0xfb12c75c>

8114c770 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114c770:	defffc04 	addi	sp,sp,-16
8114c774:	de00012e 	bgeu	sp,et,8114c77c <_exit+0xc>
8114c778:	003b68fa 	trap	3
8114c77c:	dfc00315 	stw	ra,12(sp)
8114c780:	df000215 	stw	fp,8(sp)
8114c784:	df000204 	addi	fp,sp,8
8114c788:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114c78c:	d0a01217 	ldw	r2,-32696(gp)
8114c790:	10800058 	cmpnei	r2,r2,1
8114c794:	1000031e 	bne	r2,zero,8114c7a4 <_exit+0x34>
8114c798:	01204574 	movhi	r4,33045
8114c79c:	21099504 	addi	r4,r4,9812
8114c7a0:	11382800 	call	81138280 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114c7a4:	d0a01217 	ldw	r2,-32696(gp)
8114c7a8:	10800058 	cmpnei	r2,r2,1
8114c7ac:	1000041e 	bne	r2,zero,8114c7c0 <_exit+0x50>
8114c7b0:	e17fff17 	ldw	r5,-4(fp)
8114c7b4:	01204574 	movhi	r4,33045
8114c7b8:	2109a004 	addi	r4,r4,9856
8114c7bc:	11382800 	call	81138280 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114c7c0:	d0a01217 	ldw	r2,-32696(gp)
8114c7c4:	10800058 	cmpnei	r2,r2,1
8114c7c8:	1000031e 	bne	r2,zero,8114c7d8 <_exit+0x68>
8114c7cc:	01204574 	movhi	r4,33045
8114c7d0:	2109ab04 	addi	r4,r4,9900
8114c7d4:	11382800 	call	81138280 <alt_log_printf_proc>
  ALT_OS_STOP();
8114c7d8:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114c7dc:	d0a01217 	ldw	r2,-32696(gp)
8114c7e0:	10800058 	cmpnei	r2,r2,1
8114c7e4:	1000031e 	bne	r2,zero,8114c7f4 <_exit+0x84>
8114c7e8:	01204574 	movhi	r4,33045
8114c7ec:	2109b504 	addi	r4,r4,9940
8114c7f0:	11382800 	call	81138280 <alt_log_printf_proc>
8114c7f4:	e0bfff17 	ldw	r2,-4(fp)
8114c7f8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114c7fc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114c800:	10000226 	beq	r2,zero,8114c80c <_exit+0x9c>
    ALT_SIM_FAIL();
8114c804:	002af070 	cmpltui	zero,zero,43969
8114c808:	00000106 	br	8114c810 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114c80c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114c810:	d0a01217 	ldw	r2,-32696(gp)
8114c814:	10800058 	cmpnei	r2,r2,1
8114c818:	1000031e 	bne	r2,zero,8114c828 <_exit+0xb8>
8114c81c:	01204574 	movhi	r4,33045
8114c820:	2109bf04 	addi	r4,r4,9980
8114c824:	11382800 	call	81138280 <alt_log_printf_proc>
  while (1);
8114c828:	003fff06 	br	8114c828 <__reset+0xfb12c828>
